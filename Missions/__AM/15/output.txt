// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34743 0 0
// InitNature ;
  19: CALL 34567 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10950 0 0
// PrepareRussian ;
  40: CALL 6924 0 0
// PrepareLegion ;
  44: CALL 4164 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14844 0 0
// MC_Start ( ) ;
  60: CALL 36855 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 126
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 127
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59132 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59225 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58575 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58390 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59132 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59225 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58390 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58575 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59005 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58072 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59132 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59225 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 131
 955: PUSH
 956: LD_EXP 131
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58390 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59132 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59225 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58282 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59543 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58714 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59005 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59005 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59337 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58390 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 58956 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger debug do var i , tmp ;
1549: LD_EXP 1
1553: IFFALSE 1660
1555: GO 1557
1557: DISABLE
1558: LD_INT 0
1560: PPUSH
1561: PPUSH
// begin enable ;
1562: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1563: LD_ADDR_VAR 0 2
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 1
1573: PUSH
1574: EMPTY
1575: LIST
1576: LIST
1577: PUSH
1578: LD_INT 3
1580: PUSH
1581: LD_INT 21
1583: PUSH
1584: LD_INT 3
1586: PUSH
1587: EMPTY
1588: LIST
1589: LIST
1590: PUSH
1591: EMPTY
1592: LIST
1593: LIST
1594: PUSH
1595: LD_INT 3
1597: PUSH
1598: LD_INT 24
1600: PUSH
1601: LD_INT 999
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: EMPTY
1613: LIST
1614: LIST
1615: LIST
1616: PPUSH
1617: CALL_OW 69
1621: ST_TO_ADDR
// if not tmp then
1622: LD_VAR 0 2
1626: NOT
1627: IFFALSE 1631
// exit ;
1629: GO 1660
// for i in tmp do
1631: LD_ADDR_VAR 0 1
1635: PUSH
1636: LD_VAR 0 2
1640: PUSH
1641: FOR_IN
1642: IFFALSE 1658
// SetLives ( i , 1000 ) ;
1644: LD_VAR 0 1
1648: PPUSH
1649: LD_INT 1000
1651: PPUSH
1652: CALL_OW 234
1656: GO 1641
1658: POP
1659: POP
// end ;
1660: PPOPN 2
1662: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1663: LD_EXP 36
1667: PUSH
1668: LD_EXP 17
1672: PUSH
1673: LD_INT 2
1675: GREATEREQUAL
1676: AND
1677: IFFALSE 1689
1679: GO 1681
1681: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1682: LD_STRING ACH_POWELL
1684: PPUSH
1685: CALL_OW 543
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64782 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 71897 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 71897 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 71897 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 71897 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 71897 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64782 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64782 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64782 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64782 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64782 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64782 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64782 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64782 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64782 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64782 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64782 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64782 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64782 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64782 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64782 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 2500
2959: PPUSH
2960: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2964: LD_INT 387
2966: PPUSH
2967: CALL_OW 274
2971: PPUSH
2972: LD_INT 2
2974: PPUSH
2975: LD_INT 400
2977: PPUSH
2978: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2982: LD_INT 387
2984: PPUSH
2985: CALL_OW 274
2989: PPUSH
2990: LD_INT 3
2992: PPUSH
2993: LD_INT 10
2995: PPUSH
2996: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3000: LD_ADDR_EXP 58
3004: PUSH
3005: LD_STRING Powell
3007: PPUSH
3008: CALL_OW 25
3012: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3013: LD_EXP 58
3017: PPUSH
3018: LD_INT 57
3020: PPUSH
3021: LD_INT 94
3023: PPUSH
3024: LD_INT 0
3026: PPUSH
3027: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3031: LD_EXP 58
3035: PPUSH
3036: LD_INT 58
3038: PPUSH
3039: LD_INT 94
3041: PPUSH
3042: CALL_OW 118
// vip := [ ] ;
3046: LD_ADDR_EXP 59
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// tmp := [ ] ;
3053: LD_ADDR_VAR 0 6
3057: PUSH
3058: EMPTY
3059: ST_TO_ADDR
// if JMMGirl <> 2 then
3060: LD_EXP 7
3064: PUSH
3065: LD_INT 2
3067: NONEQUAL
3068: IFFALSE 3092
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3070: LD_ADDR_EXP 42
3074: PUSH
3075: LD_STRING Lisa
3077: PPUSH
3078: LD_EXP 1
3082: NOT
3083: PPUSH
3084: LD_STRING 13s_
3086: PPUSH
3087: CALL 64782 0 3
3091: ST_TO_ADDR
// if Lisa then
3092: LD_EXP 42
3096: IFFALSE 3114
// tmp := tmp ^ Lisa ;
3098: LD_ADDR_VAR 0 6
3102: PUSH
3103: LD_VAR 0 6
3107: PUSH
3108: LD_EXP 42
3112: ADD
3113: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3114: LD_ADDR_EXP 43
3118: PUSH
3119: LD_STRING Donaldson
3121: PPUSH
3122: LD_EXP 1
3126: NOT
3127: PPUSH
3128: LD_STRING 13s_
3130: PPUSH
3131: CALL 64782 0 3
3135: ST_TO_ADDR
// if Donaldson then
3136: LD_EXP 43
3140: IFFALSE 3158
// tmp := tmp ^ Donaldson ;
3142: LD_ADDR_VAR 0 6
3146: PUSH
3147: LD_VAR 0 6
3151: PUSH
3152: LD_EXP 43
3156: ADD
3157: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3158: LD_ADDR_EXP 44
3162: PUSH
3163: LD_STRING Bobby
3165: PPUSH
3166: LD_EXP 1
3170: NOT
3171: PPUSH
3172: LD_STRING 13s_
3174: PPUSH
3175: CALL 64782 0 3
3179: ST_TO_ADDR
// if Bobby then
3180: LD_EXP 44
3184: IFFALSE 3202
// tmp := tmp ^ Bobby ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: LD_VAR 0 6
3195: PUSH
3196: LD_EXP 44
3200: ADD
3201: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3202: LD_ADDR_EXP 45
3206: PUSH
3207: LD_STRING Cyrus
3209: PPUSH
3210: LD_EXP 1
3214: NOT
3215: PPUSH
3216: LD_STRING 13s_
3218: PPUSH
3219: CALL 64782 0 3
3223: ST_TO_ADDR
// if Cyrus then
3224: LD_EXP 45
3228: IFFALSE 3246
// tmp := tmp ^ Cyrus ;
3230: LD_ADDR_VAR 0 6
3234: PUSH
3235: LD_VAR 0 6
3239: PUSH
3240: LD_EXP 45
3244: ADD
3245: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3246: LD_ADDR_EXP 46
3250: PUSH
3251: LD_STRING Denis
3253: PPUSH
3254: LD_EXP 1
3258: NOT
3259: PPUSH
3260: LD_STRING 13s_
3262: PPUSH
3263: CALL 64782 0 3
3267: ST_TO_ADDR
// if not Denis then
3268: LD_EXP 46
3272: NOT
3273: IFFALSE 3297
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3275: LD_ADDR_EXP 46
3279: PUSH
3280: LD_STRING Denis
3282: PPUSH
3283: LD_EXP 1
3287: NOT
3288: PPUSH
3289: LD_STRING 13f_
3291: PPUSH
3292: CALL 64782 0 3
3296: ST_TO_ADDR
// if Denis then
3297: LD_EXP 46
3301: IFFALSE 3319
// tmp := tmp ^ Denis ;
3303: LD_ADDR_VAR 0 6
3307: PUSH
3308: LD_VAR 0 6
3312: PUSH
3313: LD_EXP 46
3317: ADD
3318: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3319: LD_ADDR_EXP 47
3323: PUSH
3324: LD_STRING Brown
3326: PPUSH
3327: LD_EXP 1
3331: NOT
3332: PPUSH
3333: LD_STRING 13s_
3335: PPUSH
3336: CALL 64782 0 3
3340: ST_TO_ADDR
// if Brown then
3341: LD_EXP 47
3345: IFFALSE 3363
// tmp := tmp ^ Brown ;
3347: LD_ADDR_VAR 0 6
3351: PUSH
3352: LD_VAR 0 6
3356: PUSH
3357: LD_EXP 47
3361: ADD
3362: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3363: LD_ADDR_EXP 48
3367: PUSH
3368: LD_STRING Gladstone
3370: PPUSH
3371: LD_EXP 1
3375: NOT
3376: PPUSH
3377: LD_STRING 13s_
3379: PPUSH
3380: CALL 64782 0 3
3384: ST_TO_ADDR
// if Gladstone then
3385: LD_EXP 48
3389: IFFALSE 3407
// tmp := tmp ^ Gladstone ;
3391: LD_ADDR_VAR 0 6
3395: PUSH
3396: LD_VAR 0 6
3400: PUSH
3401: LD_EXP 48
3405: ADD
3406: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3407: LD_ADDR_EXP 49
3411: PUSH
3412: LD_STRING Houten
3414: PPUSH
3415: LD_EXP 1
3419: NOT
3420: PPUSH
3421: LD_STRING 13s_
3423: PPUSH
3424: CALL 64782 0 3
3428: ST_TO_ADDR
// if Houten then
3429: LD_EXP 49
3433: IFFALSE 3451
// tmp := tmp ^ Houten ;
3435: LD_ADDR_VAR 0 6
3439: PUSH
3440: LD_VAR 0 6
3444: PUSH
3445: LD_EXP 49
3449: ADD
3450: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3451: LD_ADDR_EXP 50
3455: PUSH
3456: LD_STRING Cornel
3458: PPUSH
3459: LD_EXP 1
3463: NOT
3464: PPUSH
3465: LD_STRING 13s_
3467: PPUSH
3468: CALL 64782 0 3
3472: ST_TO_ADDR
// if Cornel then
3473: LD_EXP 50
3477: IFFALSE 3495
// tmp := tmp ^ Cornel ;
3479: LD_ADDR_VAR 0 6
3483: PUSH
3484: LD_VAR 0 6
3488: PUSH
3489: LD_EXP 50
3493: ADD
3494: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3495: LD_ADDR_EXP 51
3499: PUSH
3500: LD_STRING Gary
3502: PPUSH
3503: LD_EXP 1
3507: NOT
3508: PPUSH
3509: LD_STRING 13s_
3511: PPUSH
3512: CALL 64782 0 3
3516: ST_TO_ADDR
// if Gary then
3517: LD_EXP 51
3521: IFFALSE 3539
// tmp := tmp ^ Gary ;
3523: LD_ADDR_VAR 0 6
3527: PUSH
3528: LD_VAR 0 6
3532: PUSH
3533: LD_EXP 51
3537: ADD
3538: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3539: LD_ADDR_EXP 52
3543: PUSH
3544: LD_STRING Frank
3546: PPUSH
3547: LD_EXP 1
3551: NOT
3552: PPUSH
3553: LD_STRING 13s_
3555: PPUSH
3556: CALL 64782 0 3
3560: ST_TO_ADDR
// if Frank then
3561: LD_EXP 52
3565: IFFALSE 3583
// tmp := tmp ^ Frank ;
3567: LD_ADDR_VAR 0 6
3571: PUSH
3572: LD_VAR 0 6
3576: PUSH
3577: LD_EXP 52
3581: ADD
3582: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3583: LD_ADDR_EXP 53
3587: PUSH
3588: LD_STRING Kikuchi
3590: PPUSH
3591: LD_EXP 1
3595: NOT
3596: PPUSH
3597: LD_STRING 13s_
3599: PPUSH
3600: CALL 64782 0 3
3604: ST_TO_ADDR
// if Kikuchi then
3605: LD_EXP 53
3609: IFFALSE 3627
// tmp := tmp ^ Kikuchi ;
3611: LD_ADDR_VAR 0 6
3615: PUSH
3616: LD_VAR 0 6
3620: PUSH
3621: LD_EXP 53
3625: ADD
3626: ST_TO_ADDR
// vip := tmp ;
3627: LD_ADDR_EXP 59
3631: PUSH
3632: LD_VAR 0 6
3636: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3637: LD_ADDR_VAR 0 6
3641: PUSH
3642: LD_VAR 0 6
3646: PUSH
3647: LD_STRING 13s_others
3649: PPUSH
3650: CALL_OW 31
3654: UNION
3655: ST_TO_ADDR
// if tmp < 20 then
3656: LD_VAR 0 6
3660: PUSH
3661: LD_INT 20
3663: LESS
3664: IFFALSE 3731
// for i = 1 to 20 - tmp do
3666: LD_ADDR_VAR 0 2
3670: PUSH
3671: DOUBLE
3672: LD_INT 1
3674: DEC
3675: ST_TO_ADDR
3676: LD_INT 20
3678: PUSH
3679: LD_VAR 0 6
3683: MINUS
3684: PUSH
3685: FOR_TO
3686: IFFALSE 3729
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3688: LD_INT 1
3690: PPUSH
3691: LD_VAR 0 2
3695: PUSH
3696: LD_INT 4
3698: MOD
3699: PUSH
3700: LD_INT 1
3702: PLUS
3703: PPUSH
3704: LD_INT 5
3706: PPUSH
3707: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3711: LD_ADDR_VAR 0 6
3715: PUSH
3716: LD_VAR 0 6
3720: PUSH
3721: CALL_OW 44
3725: ADD
3726: ST_TO_ADDR
// end ;
3727: GO 3685
3729: POP
3730: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3731: LD_ADDR_VAR 0 7
3735: PUSH
3736: LD_INT 22
3738: PUSH
3739: LD_INT 4
3741: PUSH
3742: EMPTY
3743: LIST
3744: LIST
3745: PUSH
3746: LD_INT 30
3748: PUSH
3749: LD_INT 0
3751: PUSH
3752: EMPTY
3753: LIST
3754: LIST
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PPUSH
3760: CALL_OW 69
3764: PUSH
3765: LD_INT 1
3767: ARRAY
3768: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3769: LD_ADDR_VAR 0 8
3773: PUSH
3774: LD_INT 22
3776: PUSH
3777: LD_INT 4
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 30
3786: PUSH
3787: LD_INT 6
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_INT 1
3805: ARRAY
3806: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3807: LD_ADDR_VAR 0 9
3811: PUSH
3812: LD_INT 22
3814: PUSH
3815: LD_INT 4
3817: PUSH
3818: EMPTY
3819: LIST
3820: LIST
3821: PUSH
3822: LD_INT 30
3824: PUSH
3825: LD_INT 4
3827: PUSH
3828: EMPTY
3829: LIST
3830: LIST
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PPUSH
3836: CALL_OW 69
3840: PUSH
3841: LD_INT 1
3843: ARRAY
3844: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3845: LD_ADDR_VAR 0 10
3849: PUSH
3850: LD_INT 22
3852: PUSH
3853: LD_INT 4
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: LD_INT 30
3862: PUSH
3863: LD_INT 2
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PPUSH
3874: CALL_OW 69
3878: PUSH
3879: LD_INT 1
3881: ARRAY
3882: ST_TO_ADDR
// for i in tmp do
3883: LD_ADDR_VAR 0 2
3887: PUSH
3888: LD_VAR 0 6
3892: PUSH
3893: FOR_IN
3894: IFFALSE 4020
// begin cl := GetClass ( i ) ;
3896: LD_ADDR_VAR 0 5
3900: PUSH
3901: LD_VAR 0 2
3905: PPUSH
3906: CALL_OW 257
3910: ST_TO_ADDR
// if cl > 4 then
3911: LD_VAR 0 5
3915: PUSH
3916: LD_INT 4
3918: GREATER
3919: IFFALSE 3929
// cl := 1 ;
3921: LD_ADDR_VAR 0 5
3925: PUSH
3926: LD_INT 1
3928: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3929: LD_ADDR_VAR 0 3
3933: PUSH
3934: LD_VAR 0 9
3938: PUSH
3939: LD_VAR 0 7
3943: PUSH
3944: LD_VAR 0 10
3948: PUSH
3949: LD_VAR 0 8
3953: PUSH
3954: EMPTY
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: PUSH
3960: LD_VAR 0 5
3964: ARRAY
3965: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3966: LD_VAR 0 3
3970: PPUSH
3971: CALL_OW 313
3975: PUSH
3976: LD_INT 5
3978: LESS
3979: IFFALSE 3997
// PlaceHumanInUnit ( i , b ) else
3981: LD_VAR 0 2
3985: PPUSH
3986: LD_VAR 0 3
3990: PPUSH
3991: CALL_OW 52
3995: GO 4018
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3997: LD_VAR 0 2
4001: PPUSH
4002: LD_INT 58
4004: PPUSH
4005: LD_INT 91
4007: PPUSH
4008: LD_INT 6
4010: PPUSH
4011: LD_INT 0
4013: PPUSH
4014: CALL_OW 50
// end ;
4018: GO 3893
4020: POP
4021: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4022: LD_INT 2
4024: PPUSH
4025: LD_INT 1
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 12
4033: PPUSH
4034: LD_INT 100
4036: PPUSH
4037: CALL 71897 0 5
// veh := CreateVehicle ;
4041: LD_ADDR_VAR 0 4
4045: PUSH
4046: CALL_OW 45
4050: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4051: LD_VAR 0 4
4055: PPUSH
4056: LD_INT 4
4058: PPUSH
4059: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4063: LD_VAR 0 4
4067: PPUSH
4068: LD_INT 49
4070: PPUSH
4071: LD_INT 88
4073: PPUSH
4074: LD_INT 0
4076: PPUSH
4077: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4081: LD_VAR 0 4
4085: PPUSH
4086: LD_INT 1
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL_OW 290
// uc_side := 0 ;
4096: LD_ADDR_OWVAR 20
4100: PUSH
4101: LD_INT 0
4103: ST_TO_ADDR
// uc_nation := 0 ;
4104: LD_ADDR_OWVAR 21
4108: PUSH
4109: LD_INT 0
4111: ST_TO_ADDR
// for i = 1 to 4 do
4112: LD_ADDR_VAR 0 2
4116: PUSH
4117: DOUBLE
4118: LD_INT 1
4120: DEC
4121: ST_TO_ADDR
4122: LD_INT 4
4124: PUSH
4125: FOR_TO
4126: IFFALSE 4157
// begin InitHc ;
4128: CALL_OW 19
// hc_class := class_apeman ;
4132: LD_ADDR_OWVAR 28
4136: PUSH
4137: LD_INT 12
4139: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4140: CALL_OW 44
4144: PPUSH
4145: LD_INT 13
4147: PPUSH
4148: LD_INT 0
4150: PPUSH
4151: CALL_OW 49
// end ;
4155: GO 4125
4157: POP
4158: POP
// end ; end_of_file
4159: LD_VAR 0 1
4163: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4164: LD_INT 0
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
// side := 8 ;
4171: LD_ADDR_VAR 0 3
4175: PUSH
4176: LD_INT 8
4178: ST_TO_ADDR
// uc_side := side ;
4179: LD_ADDR_OWVAR 20
4183: PUSH
4184: LD_VAR 0 3
4188: ST_TO_ADDR
// uc_nation := 2 ;
4189: LD_ADDR_OWVAR 21
4193: PUSH
4194: LD_INT 2
4196: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4197: LD_ADDR_VAR 0 2
4201: PUSH
4202: LD_INT 22
4204: PUSH
4205: LD_VAR 0 3
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: LD_INT 21
4216: PUSH
4217: LD_INT 3
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: PPUSH
4228: CALL_OW 69
4232: PUSH
4233: FOR_IN
4234: IFFALSE 4250
// SetBLevel ( i , 10 ) ;
4236: LD_VAR 0 2
4240: PPUSH
4241: LD_INT 10
4243: PPUSH
4244: CALL_OW 241
4248: GO 4233
4250: POP
4251: POP
// if KurtStatus then
4252: LD_EXP 3
4256: IFFALSE 4279
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4258: LD_ADDR_EXP 60
4262: PUSH
4263: LD_STRING Kurt
4265: PPUSH
4266: LD_INT 0
4268: PPUSH
4269: LD_STRING 
4271: PPUSH
4272: CALL 64782 0 3
4276: ST_TO_ADDR
4277: GO 4301
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4279: LD_ADDR_EXP 60
4283: PUSH
4284: LD_STRING AltKurt
4286: PPUSH
4287: LD_EXP 1
4291: NOT
4292: PPUSH
4293: LD_STRING 
4295: PPUSH
4296: CALL 64782 0 3
4300: ST_TO_ADDR
// if not Kurt then
4301: LD_EXP 60
4305: NOT
4306: IFFALSE 4332
// begin InitHc ;
4308: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4312: LD_INT 1
4314: PPUSH
4315: LD_INT 10
4317: PPUSH
4318: CALL_OW 381
// Kurt := CreateHuman ;
4322: LD_ADDR_EXP 60
4326: PUSH
4327: CALL_OW 44
4331: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4332: LD_EXP 60
4336: PPUSH
4337: LD_INT 324
4339: PPUSH
4340: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4344: LD_ADDR_EXP 61
4348: PUSH
4349: LD_STRING Kozlov
4351: PPUSH
4352: LD_INT 0
4354: PPUSH
4355: LD_STRING 
4357: PPUSH
4358: CALL 64782 0 3
4362: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4363: LD_EXP 61
4367: PPUSH
4368: LD_INT 22
4370: PUSH
4371: LD_INT 8
4373: PUSH
4374: EMPTY
4375: LIST
4376: LIST
4377: PUSH
4378: LD_INT 23
4380: PUSH
4381: LD_INT 3
4383: PUSH
4384: EMPTY
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 30
4390: PUSH
4391: LD_INT 8
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: LIST
4402: PPUSH
4403: CALL_OW 69
4407: PUSH
4408: LD_INT 1
4410: ARRAY
4411: PPUSH
4412: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4416: LD_EXP 61
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 10
4426: PPUSH
4427: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4431: LD_ADDR_VAR 0 5
4435: PUSH
4436: LD_INT 22
4438: PUSH
4439: LD_VAR 0 3
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: LD_INT 30
4450: PUSH
4451: LD_INT 32
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PUSH
4458: LD_INT 58
4460: PUSH
4461: EMPTY
4462: LIST
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: PPUSH
4469: CALL_OW 69
4473: ST_TO_ADDR
// for i = 1 to 10 do
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: DOUBLE
4480: LD_INT 1
4482: DEC
4483: ST_TO_ADDR
4484: LD_INT 10
4486: PUSH
4487: FOR_TO
4488: IFFALSE 4560
// begin uc_nation := nation_nature ;
4490: LD_ADDR_OWVAR 21
4494: PUSH
4495: LD_INT 0
4497: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4498: LD_ADDR_OWVAR 28
4502: PUSH
4503: LD_INT 15
4505: ST_TO_ADDR
// hc_gallery :=  ;
4506: LD_ADDR_OWVAR 33
4510: PUSH
4511: LD_STRING 
4513: ST_TO_ADDR
// hc_name :=  ;
4514: LD_ADDR_OWVAR 26
4518: PUSH
4519: LD_STRING 
4521: ST_TO_ADDR
// un := CreateHuman ;
4522: LD_ADDR_VAR 0 4
4526: PUSH
4527: CALL_OW 44
4531: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4532: LD_VAR 0 4
4536: PPUSH
4537: LD_VAR 0 5
4541: PUSH
4542: LD_VAR 0 5
4546: PUSH
4547: LD_VAR 0 2
4551: MINUS
4552: ARRAY
4553: PPUSH
4554: CALL_OW 52
// end ;
4558: GO 4487
4560: POP
4561: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4562: LD_ADDR_VAR 0 5
4566: PUSH
4567: LD_STRING 12_kurt_squad
4569: PPUSH
4570: CALL_OW 31
4574: ST_TO_ADDR
// if tmp then
4575: LD_VAR 0 5
4579: IFFALSE 4613
// for i in tmp do
4581: LD_ADDR_VAR 0 2
4585: PUSH
4586: LD_VAR 0 5
4590: PUSH
4591: FOR_IN
4592: IFFALSE 4611
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4594: LD_VAR 0 2
4598: PPUSH
4599: LD_INT 5
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 49
4609: GO 4591
4611: POP
4612: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4613: LD_INT 324
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_STRING 
4621: PPUSH
4622: LD_INT 8
4624: PUSH
4625: LD_INT 9
4627: PUSH
4628: LD_INT 10
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: LIST
4635: PUSH
4636: LD_OWVAR 67
4640: ARRAY
4641: PPUSH
4642: LD_INT 3000
4644: PUSH
4645: LD_INT 500
4647: PUSH
4648: LD_INT 150
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: PPUSH
4656: LD_INT 16
4658: PUSH
4659: LD_INT 6
4661: PUSH
4662: LD_INT 6
4664: PUSH
4665: LD_INT 8
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: LIST
4673: PPUSH
4674: CALL 75306 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4678: LD_ADDR_EXP 102
4682: PUSH
4683: LD_EXP 102
4687: PPUSH
4688: LD_INT 3
4690: PPUSH
4691: LD_INT 22
4693: PUSH
4694: LD_VAR 0 3
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PUSH
4703: LD_INT 23
4705: PUSH
4706: LD_INT 2
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: PUSH
4713: LD_INT 3
4715: PUSH
4716: LD_INT 21
4718: PUSH
4719: LD_INT 2
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: LIST
4734: PPUSH
4735: CALL_OW 69
4739: PUSH
4740: LD_EXP 60
4744: DIFF
4745: PPUSH
4746: CALL_OW 1
4750: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4751: LD_INT 1
4753: PPUSH
4754: LD_INT 7
4756: PPUSH
4757: CALL_OW 383
// Friend := CreateHuman ;
4761: LD_ADDR_EXP 62
4765: PUSH
4766: CALL_OW 44
4770: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4771: LD_INT 14
4773: PPUSH
4774: LD_INT 3
4776: PPUSH
4777: LD_INT 1
4779: PPUSH
4780: LD_INT 29
4782: PPUSH
4783: LD_INT 100
4785: PPUSH
4786: CALL 71897 0 5
// powellBomb := CreateVehicle ;
4790: LD_ADDR_EXP 63
4794: PUSH
4795: CALL_OW 45
4799: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4800: LD_EXP 63
4804: PPUSH
4805: LD_INT 90
4807: PPUSH
4808: LD_INT 51
4810: PPUSH
4811: LD_INT 0
4813: PPUSH
4814: CALL_OW 48
// end ;
4818: LD_VAR 0 1
4822: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4823: LD_INT 0
4825: PPUSH
4826: PPUSH
4827: PPUSH
// if IsLive ( kozlov_fac ) then
4828: LD_INT 332
4830: PPUSH
4831: CALL_OW 300
4835: IFFALSE 4839
// exit ;
4837: GO 5406
// ComExitBuilding ( Kozlov ) ;
4839: LD_EXP 61
4843: PPUSH
4844: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4848: LD_EXP 61
4852: PPUSH
4853: CALL_OW 257
4857: PUSH
4858: LD_INT 2
4860: NONEQUAL
4861: IFFALSE 4896
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4863: LD_EXP 61
4867: PPUSH
4868: LD_INT 324
4870: PPUSH
4871: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4875: LD_EXP 61
4879: PPUSH
4880: LD_INT 2
4882: PPUSH
4883: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4887: LD_EXP 61
4891: PPUSH
4892: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4896: LD_EXP 61
4900: PPUSH
4901: LD_INT 2
4903: PPUSH
4904: LD_INT 93
4906: PPUSH
4907: LD_INT 32
4909: PPUSH
4910: LD_INT 3
4912: PPUSH
4913: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4924: LD_INT 22
4926: PUSH
4927: LD_INT 8
4929: PUSH
4930: EMPTY
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 30
4936: PUSH
4937: LD_INT 3
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 23
4946: PUSH
4947: LD_INT 3
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: PUSH
4954: LD_INT 57
4956: PUSH
4957: EMPTY
4958: LIST
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PPUSH
4966: CALL_OW 69
4970: IFFALSE 4917
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4972: LD_ADDR_VAR 0 2
4976: PUSH
4977: LD_INT 22
4979: PUSH
4980: LD_INT 8
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 30
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: LD_INT 23
4999: PUSH
5000: LD_INT 3
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 57
5009: PUSH
5010: EMPTY
5011: LIST
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: PPUSH
5019: CALL_OW 69
5023: PUSH
5024: LD_INT 1
5026: ARRAY
5027: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5028: LD_INT 22
5030: PUSH
5031: LD_INT 8
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 23
5040: PUSH
5041: LD_INT 3
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 30
5050: PUSH
5051: LD_INT 21
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: NOT
5068: IFFALSE 5146
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5070: LD_EXP 61
5074: PPUSH
5075: LD_INT 21
5077: PPUSH
5078: LD_INT 97
5080: PPUSH
5081: LD_INT 36
5083: PPUSH
5084: LD_INT 5
5086: PPUSH
5087: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5091: LD_INT 35
5093: PPUSH
5094: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5098: LD_INT 22
5100: PUSH
5101: LD_INT 8
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: PUSH
5108: LD_INT 23
5110: PUSH
5111: LD_INT 3
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: PUSH
5118: LD_INT 30
5120: PUSH
5121: LD_INT 21
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PUSH
5128: LD_INT 57
5130: PUSH
5131: EMPTY
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: LIST
5138: LIST
5139: PPUSH
5140: CALL_OW 69
5144: IFFALSE 5091
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5146: LD_INT 22
5148: PUSH
5149: LD_INT 8
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 23
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 18
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: LIST
5180: PPUSH
5181: CALL_OW 69
5185: NOT
5186: IFFALSE 5264
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5188: LD_EXP 61
5192: PPUSH
5193: LD_INT 18
5195: PPUSH
5196: LD_INT 89
5198: PPUSH
5199: LD_INT 32
5201: PPUSH
5202: LD_INT 1
5204: PPUSH
5205: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5209: LD_INT 35
5211: PPUSH
5212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5216: LD_INT 22
5218: PUSH
5219: LD_INT 8
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 23
5228: PUSH
5229: LD_INT 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 30
5238: PUSH
5239: LD_INT 18
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 57
5248: PUSH
5249: EMPTY
5250: LIST
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PPUSH
5258: CALL_OW 69
5262: IFFALSE 5209
// end ; lab := kozlov_lab ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: LD_INT 336
5271: ST_TO_ADDR
// if not lab then
5272: LD_VAR 0 3
5276: NOT
5277: IFFALSE 5281
// exit ;
5279: GO 5406
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5281: LD_EXP 61
5285: PPUSH
5286: LD_VAR 0 3
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: PPUSH
5295: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5299: LD_EXP 61
5303: PPUSH
5304: LD_INT 4
5306: PPUSH
5307: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5311: LD_VAR 0 3
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 25
5322: PPUSH
5323: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5327: LD_INT 35
5329: PPUSH
5330: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5334: LD_INT 25
5336: PPUSH
5337: LD_INT 8
5339: PPUSH
5340: CALL_OW 321
5344: PUSH
5345: LD_INT 2
5347: EQUAL
5348: IFFALSE 5327
// ComExitBuilding ( Kozlov ) ;
5350: LD_EXP 61
5354: PPUSH
5355: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5359: LD_EXP 61
5363: PPUSH
5364: LD_VAR 0 2
5368: PPUSH
5369: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5373: LD_EXP 61
5377: PPUSH
5378: LD_INT 3
5380: PPUSH
5381: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5385: LD_VAR 0 2
5389: PPUSH
5390: LD_INT 23
5392: PPUSH
5393: LD_INT 3
5395: PPUSH
5396: LD_INT 1
5398: PPUSH
5399: LD_INT 48
5401: PPUSH
5402: CALL_OW 125
// end ;
5406: LD_VAR 0 1
5410: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5411: LD_EXP 22
5415: NOT
5416: PUSH
5417: LD_EXP 15
5421: PUSH
5422: LD_INT 6
5424: GREATEREQUAL
5425: AND
5426: IFFALSE 5507
5428: GO 5430
5430: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5431: LD_INT 3
5433: PPUSH
5434: LD_INT 3
5436: PPUSH
5437: CALL 58575 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5441: LD_INT 3
5443: PPUSH
5444: LD_INT 14
5446: PUSH
5447: LD_INT 1
5449: PUSH
5450: LD_INT 1
5452: PUSH
5453: LD_INT 28
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 14
5464: PUSH
5465: LD_INT 1
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 28
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 14
5482: PUSH
5483: LD_INT 1
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 28
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 58438 0 2
// end ;
5507: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: PUSH
5524: LD_INT 3
5526: PPUSH
5527: LD_INT 1
5529: PPUSH
5530: CALL 59856 0 2
5534: NOT
5535: AND
5536: IFFALSE 6376
5538: GO 5540
5540: DISABLE
5541: LD_INT 0
5543: PPUSH
5544: PPUSH
5545: PPUSH
// begin enable ;
5546: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5547: LD_INT 22
5549: PUSH
5550: LD_INT 8
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 23
5559: PUSH
5560: LD_INT 2
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 30
5569: PUSH
5570: LD_INT 3
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: NOT
5587: IFFALSE 5591
// exit ;
5589: GO 6376
// if Prob ( 40 ) then
5591: LD_INT 40
5593: PPUSH
5594: CALL_OW 13
5598: IFFALSE 5725
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5600: LD_INT 3
5602: PPUSH
5603: LD_INT 14
5605: PUSH
5606: LD_INT 1
5608: PUSH
5609: LD_INT 2
5611: PUSH
5612: LD_INT 28
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: LIST
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 28
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 2
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 26
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: PPUSH
5719: CALL 58438 0 2
// end else
5723: GO 5916
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5725: LD_INT 3
5727: PPUSH
5728: LD_INT 14
5730: PUSH
5731: LD_INT 1
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 27
5739: PUSH
5740: LD_INT 26
5742: PUSH
5743: LD_INT 26
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: EMPTY
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: PUSH
5763: LD_INT 14
5765: PUSH
5766: LD_INT 1
5768: PUSH
5769: LD_INT 2
5771: PUSH
5772: LD_INT 27
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: LD_INT 26
5780: PUSH
5781: EMPTY
5782: LIST
5783: LIST
5784: LIST
5785: PUSH
5786: LD_OWVAR 67
5790: ARRAY
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 14
5800: PUSH
5801: LD_INT 1
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: LD_INT 29
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_OWVAR 67
5825: ARRAY
5826: PUSH
5827: EMPTY
5828: LIST
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 13
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: LD_INT 2
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: LD_INT 29
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: LIST
5855: PUSH
5856: LD_OWVAR 67
5860: ARRAY
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 13
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: LD_INT 2
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 14
5888: PUSH
5889: LD_INT 1
5891: PUSH
5892: LD_INT 2
5894: PUSH
5895: LD_INT 26
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: PPUSH
5912: CALL 58438 0 2
// end ; repeat wait ( 0 0$1 ) ;
5916: LD_INT 35
5918: PPUSH
5919: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5923: LD_INT 3
5925: PPUSH
5926: LD_INT 1
5928: PPUSH
5929: CALL 59856 0 2
5933: PUSH
5934: LD_INT 6
5936: GREATEREQUAL
5937: IFFALSE 5916
// wait ( 0 0$30 ) ;
5939: LD_INT 1050
5941: PPUSH
5942: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5946: LD_ADDR_VAR 0 2
5950: PUSH
5951: LD_INT 3
5953: PPUSH
5954: LD_INT 1
5956: PPUSH
5957: CALL 59856 0 2
5961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5962: LD_ADDR_EXP 121
5966: PUSH
5967: LD_EXP 121
5971: PPUSH
5972: LD_INT 3
5974: PPUSH
5975: LD_EXP 121
5979: PUSH
5980: LD_INT 3
5982: ARRAY
5983: PUSH
5984: LD_VAR 0 2
5988: DIFF
5989: PPUSH
5990: CALL_OW 1
5994: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_INT 0
6002: PPUSH
6003: LD_INT 2
6005: PPUSH
6006: CALL_OW 12
6010: ST_TO_ADDR
// if target then
6011: LD_VAR 0 3
6015: IFFALSE 6143
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6017: LD_ADDR_VAR 0 2
6021: PUSH
6022: LD_VAR 0 2
6026: PPUSH
6027: LD_INT 24
6029: PUSH
6030: LD_INT 250
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: PPUSH
6037: CALL_OW 72
6041: ST_TO_ADDR
// for i in tmp do
6042: LD_ADDR_VAR 0 1
6046: PUSH
6047: LD_VAR 0 2
6051: PUSH
6052: FOR_IN
6053: IFFALSE 6093
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6055: LD_VAR 0 1
6059: PPUSH
6060: LD_INT 89
6062: PPUSH
6063: LD_INT 71
6065: PPUSH
6066: CALL_OW 297
6070: PUSH
6071: LD_INT 9
6073: GREATER
6074: IFFALSE 6091
// ComMoveXY ( i , 89 , 71 ) ;
6076: LD_VAR 0 1
6080: PPUSH
6081: LD_INT 89
6083: PPUSH
6084: LD_INT 71
6086: PPUSH
6087: CALL_OW 111
6091: GO 6052
6093: POP
6094: POP
// wait ( 0 0$1 ) ;
6095: LD_INT 35
6097: PPUSH
6098: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6102: LD_VAR 0 2
6106: PPUSH
6107: LD_INT 92
6109: PUSH
6110: LD_INT 89
6112: PUSH
6113: LD_INT 71
6115: PUSH
6116: LD_INT 9
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: CALL_OW 72
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_INT 1
6137: MINUS
6138: GREATEREQUAL
6139: IFFALSE 6017
// end else
6141: GO 6267
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6143: LD_ADDR_VAR 0 2
6147: PUSH
6148: LD_VAR 0 2
6152: PPUSH
6153: LD_INT 24
6155: PUSH
6156: LD_INT 250
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: PPUSH
6163: CALL_OW 72
6167: ST_TO_ADDR
// for i in tmp do
6168: LD_ADDR_VAR 0 1
6172: PUSH
6173: LD_VAR 0 2
6177: PUSH
6178: FOR_IN
6179: IFFALSE 6219
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6181: LD_VAR 0 1
6185: PPUSH
6186: LD_INT 125
6188: PPUSH
6189: LD_INT 129
6191: PPUSH
6192: CALL_OW 297
6196: PUSH
6197: LD_INT 9
6199: GREATER
6200: IFFALSE 6217
// ComMoveXY ( i , 125 , 129 ) ;
6202: LD_VAR 0 1
6206: PPUSH
6207: LD_INT 125
6209: PPUSH
6210: LD_INT 129
6212: PPUSH
6213: CALL_OW 111
6217: GO 6178
6219: POP
6220: POP
// wait ( 0 0$1 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6228: LD_VAR 0 2
6232: PPUSH
6233: LD_INT 92
6235: PUSH
6236: LD_INT 125
6238: PUSH
6239: LD_INT 129
6241: PUSH
6242: LD_INT 9
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: PUSH
6256: LD_VAR 0 2
6260: PUSH
6261: LD_INT 1
6263: MINUS
6264: GREATEREQUAL
6265: IFFALSE 6143
// end ; repeat wait ( 0 0$1 ) ;
6267: LD_INT 35
6269: PPUSH
6270: CALL_OW 67
// for i in tmp do
6274: LD_ADDR_VAR 0 1
6278: PUSH
6279: LD_VAR 0 2
6283: PUSH
6284: FOR_IN
6285: IFFALSE 6367
// begin if GetLives ( i ) > 251 then
6287: LD_VAR 0 1
6291: PPUSH
6292: CALL_OW 256
6296: PUSH
6297: LD_INT 251
6299: GREATER
6300: IFFALSE 6338
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6302: LD_VAR 0 1
6306: PPUSH
6307: LD_INT 81
6309: PUSH
6310: LD_INT 8
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 69
6321: PPUSH
6322: LD_VAR 0 1
6326: PPUSH
6327: CALL_OW 74
6331: PPUSH
6332: CALL_OW 115
6336: GO 6365
// if IsDead ( i ) then
6338: LD_VAR 0 1
6342: PPUSH
6343: CALL_OW 301
6347: IFFALSE 6365
// tmp := tmp diff i ;
6349: LD_ADDR_VAR 0 2
6353: PUSH
6354: LD_VAR 0 2
6358: PUSH
6359: LD_VAR 0 1
6363: DIFF
6364: ST_TO_ADDR
// end ;
6365: GO 6284
6367: POP
6368: POP
// until not tmp ;
6369: LD_VAR 0 2
6373: NOT
6374: IFFALSE 6267
// end ;
6376: PPOPN 3
6378: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6379: LD_EXP 22
6383: NOT
6384: PUSH
6385: LD_EXP 15
6389: PUSH
6390: LD_INT 6
6392: GREATEREQUAL
6393: AND
6394: PUSH
6395: LD_OWVAR 67
6399: PUSH
6400: LD_INT 1
6402: GREATER
6403: AND
6404: IFFALSE 6921
6406: GO 6408
6408: DISABLE
6409: LD_INT 0
6411: PPUSH
6412: PPUSH
6413: PPUSH
// begin enable ;
6414: ENABLE
// tmp := [ ] ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: EMPTY
6421: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6422: LD_ADDR_VAR 0 1
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_INT 4
6434: PUSH
6435: LD_INT 6
6437: PUSH
6438: LD_INT 7
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_OWVAR 67
6450: ARRAY
6451: PUSH
6452: FOR_TO
6453: IFFALSE 6613
// begin uc_side := 8 ;
6455: LD_ADDR_OWVAR 20
6459: PUSH
6460: LD_INT 8
6462: ST_TO_ADDR
// uc_nation := 2 ;
6463: LD_ADDR_OWVAR 21
6467: PUSH
6468: LD_INT 2
6470: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6471: LD_INT 13
6473: PUSH
6474: LD_INT 14
6476: PUSH
6477: EMPTY
6478: LIST
6479: LIST
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_INT 2
6486: PPUSH
6487: CALL_OW 12
6491: ARRAY
6492: PPUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 5
6498: PPUSH
6499: LD_INT 27
6501: PUSH
6502: LD_INT 28
6504: PUSH
6505: LD_INT 26
6507: PUSH
6508: LD_INT 25
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: LIST
6515: LIST
6516: PUSH
6517: LD_INT 1
6519: PPUSH
6520: LD_INT 4
6522: PPUSH
6523: CALL_OW 12
6527: ARRAY
6528: PPUSH
6529: LD_INT 88
6531: PPUSH
6532: CALL 71897 0 5
// un := CreateVehicle ;
6536: LD_ADDR_VAR 0 2
6540: PUSH
6541: CALL_OW 45
6545: ST_TO_ADDR
// tmp := tmp ^ un ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: LD_VAR 0 3
6555: PUSH
6556: LD_VAR 0 2
6560: ADD
6561: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6562: LD_VAR 0 2
6566: PPUSH
6567: LD_INT 3
6569: PPUSH
6570: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6574: LD_VAR 0 2
6578: PPUSH
6579: LD_INT 30
6581: PPUSH
6582: LD_INT 0
6584: PPUSH
6585: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6589: LD_VAR 0 2
6593: PPUSH
6594: LD_INT 16
6596: PPUSH
6597: LD_INT 11
6599: PPUSH
6600: CALL_OW 111
// wait ( 0 0$2 ) ;
6604: LD_INT 70
6606: PPUSH
6607: CALL_OW 67
// end ;
6611: GO 6452
6613: POP
6614: POP
// for i = 1 to Difficulty do
6615: LD_ADDR_VAR 0 1
6619: PUSH
6620: DOUBLE
6621: LD_INT 1
6623: DEC
6624: ST_TO_ADDR
6625: LD_OWVAR 67
6629: PUSH
6630: FOR_TO
6631: IFFALSE 6756
// begin uc_side := 8 ;
6633: LD_ADDR_OWVAR 20
6637: PUSH
6638: LD_INT 8
6640: ST_TO_ADDR
// uc_nation := 2 ;
6641: LD_ADDR_OWVAR 21
6645: PUSH
6646: LD_INT 2
6648: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6649: LD_INT 0
6651: PPUSH
6652: LD_INT 8
6654: PPUSH
6655: LD_INT 8
6657: PUSH
6658: LD_INT 8
6660: PUSH
6661: LD_INT 9
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: PUSH
6669: LD_OWVAR 67
6673: ARRAY
6674: PPUSH
6675: CALL_OW 380
// un := CreateHuman ;
6679: LD_ADDR_VAR 0 2
6683: PUSH
6684: CALL_OW 44
6688: ST_TO_ADDR
// tmp := tmp ^ un ;
6689: LD_ADDR_VAR 0 3
6693: PUSH
6694: LD_VAR 0 3
6698: PUSH
6699: LD_VAR 0 2
6703: ADD
6704: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6705: LD_VAR 0 2
6709: PPUSH
6710: LD_INT 3
6712: PPUSH
6713: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6717: LD_VAR 0 2
6721: PPUSH
6722: LD_INT 30
6724: PPUSH
6725: LD_INT 0
6727: PPUSH
6728: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 16
6739: PPUSH
6740: LD_INT 11
6742: PPUSH
6743: CALL_OW 111
// wait ( 0 0$2 ) ;
6747: LD_INT 70
6749: PPUSH
6750: CALL_OW 67
// end ;
6754: GO 6630
6756: POP
6757: POP
// repeat wait ( 0 0$1 ) ;
6758: LD_INT 35
6760: PPUSH
6761: CALL_OW 67
// for i in tmp do
6765: LD_ADDR_VAR 0 1
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: FOR_IN
6776: IFFALSE 6912
// begin if GetLives ( i ) > 250 then
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 256
6787: PUSH
6788: LD_INT 250
6790: GREATER
6791: IFFALSE 6883
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6793: LD_INT 81
6795: PUSH
6796: LD_INT 8
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: PUSH
6803: LD_INT 91
6805: PUSH
6806: LD_VAR 0 1
6810: PUSH
6811: LD_INT 10
6813: PUSH
6814: EMPTY
6815: LIST
6816: LIST
6817: LIST
6818: PUSH
6819: EMPTY
6820: LIST
6821: LIST
6822: PPUSH
6823: CALL_OW 69
6827: NOT
6828: IFFALSE 6847
// ComAgressiveMove ( i , 67 , 110 ) else
6830: LD_VAR 0 1
6834: PPUSH
6835: LD_INT 67
6837: PPUSH
6838: LD_INT 110
6840: PPUSH
6841: CALL_OW 114
6845: GO 6881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 81
6854: PUSH
6855: LD_INT 8
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PPUSH
6862: CALL_OW 69
6866: PPUSH
6867: LD_VAR 0 1
6871: PPUSH
6872: CALL_OW 74
6876: PPUSH
6877: CALL_OW 115
// end else
6881: GO 6910
// if IsDead ( i ) then
6883: LD_VAR 0 1
6887: PPUSH
6888: CALL_OW 301
6892: IFFALSE 6910
// tmp := tmp diff i ;
6894: LD_ADDR_VAR 0 3
6898: PUSH
6899: LD_VAR 0 3
6903: PUSH
6904: LD_VAR 0 1
6908: DIFF
6909: ST_TO_ADDR
// end ;
6910: GO 6775
6912: POP
6913: POP
// until not tmp ;
6914: LD_VAR 0 3
6918: NOT
6919: IFFALSE 6758
// end ; end_of_file
6921: PPOPN 3
6923: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6924: LD_INT 0
6926: PPUSH
6927: PPUSH
6928: PPUSH
6929: PPUSH
6930: PPUSH
6931: PPUSH
6932: PPUSH
6933: PPUSH
6934: PPUSH
// side := 3 ;
6935: LD_ADDR_VAR 0 6
6939: PUSH
6940: LD_INT 3
6942: ST_TO_ADDR
// uc_side := side ;
6943: LD_ADDR_OWVAR 20
6947: PUSH
6948: LD_VAR 0 6
6952: ST_TO_ADDR
// uc_nation := 3 ;
6953: LD_ADDR_OWVAR 21
6957: PUSH
6958: LD_INT 3
6960: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_VAR 0 6
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PUSH
6978: LD_INT 21
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PPUSH
6992: CALL_OW 69
6996: PUSH
6997: FOR_IN
6998: IFFALSE 7014
// SetBLevel ( i , 10 ) ;
7000: LD_VAR 0 2
7004: PPUSH
7005: LD_INT 10
7007: PPUSH
7008: CALL_OW 241
7012: GO 6997
7014: POP
7015: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7016: LD_ADDR_VAR 0 9
7020: PUSH
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 6
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 30
7035: PUSH
7036: LD_INT 34
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: CALL_OW 69
7051: ST_TO_ADDR
// if teleport then
7052: LD_VAR 0 9
7056: IFFALSE 7077
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7058: LD_VAR 0 9
7062: PUSH
7063: LD_INT 1
7065: ARRAY
7066: PPUSH
7067: LD_INT 123
7069: PPUSH
7070: LD_INT 122
7072: PPUSH
7073: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7077: LD_ADDR_EXP 64
7081: PUSH
7082: LD_STRING Platonov
7084: PPUSH
7085: CALL_OW 25
7089: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7090: LD_ADDR_EXP 65
7094: PUSH
7095: LD_STRING Kovalyuk
7097: PPUSH
7098: CALL_OW 25
7102: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7103: LD_ADDR_EXP 67
7107: PUSH
7108: LD_STRING Yakotich
7110: PPUSH
7111: LD_EXP 1
7115: NOT
7116: PPUSH
7117: LD_STRING 09_
7119: PPUSH
7120: CALL 64782 0 3
7124: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7125: LD_ADDR_EXP 66
7129: PUSH
7130: LD_STRING Bystrov
7132: PPUSH
7133: CALL_OW 25
7137: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7138: LD_ADDR_EXP 68
7142: PUSH
7143: LD_STRING Gleb
7145: PPUSH
7146: CALL_OW 25
7150: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7151: LD_STRING 03_Cornel
7153: PPUSH
7154: CALL_OW 28
7158: IFFALSE 7206
// begin Bierezov := NewCharacter ( Mikhail ) ;
7160: LD_ADDR_EXP 69
7164: PUSH
7165: LD_STRING Mikhail
7167: PPUSH
7168: CALL_OW 25
7172: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7173: LD_EXP 69
7177: PPUSH
7178: LD_INT 197
7180: PPUSH
7181: LD_INT 111
7183: PPUSH
7184: LD_INT 9
7186: PPUSH
7187: LD_INT 0
7189: PPUSH
7190: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7194: LD_EXP 69
7198: PPUSH
7199: LD_INT 3
7201: PPUSH
7202: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7206: LD_EXP 64
7210: PPUSH
7211: LD_INT 126
7213: PPUSH
7214: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7218: LD_EXP 65
7222: PPUSH
7223: LD_INT 134
7225: PPUSH
7226: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7230: LD_EXP 67
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7251: LD_EXP 66
7255: PPUSH
7256: LD_INT 197
7258: PPUSH
7259: LD_INT 111
7261: PPUSH
7262: LD_INT 9
7264: PPUSH
7265: LD_INT 0
7267: PPUSH
7268: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7272: LD_EXP 68
7276: PPUSH
7277: LD_INT 197
7279: PPUSH
7280: LD_INT 111
7282: PPUSH
7283: LD_INT 9
7285: PPUSH
7286: LD_INT 0
7288: PPUSH
7289: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7293: LD_ADDR_VAR 0 5
7297: PUSH
7298: LD_INT 126
7300: PPUSH
7301: LD_INT 4
7303: PPUSH
7304: LD_STRING zhukov
7306: PPUSH
7307: LD_INT 9
7309: PUSH
7310: LD_INT 10
7312: PUSH
7313: LD_INT 10
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: LIST
7320: PUSH
7321: LD_OWVAR 67
7325: ARRAY
7326: PPUSH
7327: LD_INT 90000
7329: PUSH
7330: LD_INT 1000
7332: PUSH
7333: LD_INT 300
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: LIST
7340: PPUSH
7341: LD_INT 21
7343: PUSH
7344: LD_INT 8
7346: PUSH
7347: LD_INT 13
7349: PUSH
7350: LD_INT 8
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: PPUSH
7359: CALL 75306 0 6
7363: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7364: LD_ADDR_VAR 0 4
7368: PUSH
7369: LD_INT 267
7371: PPUSH
7372: CALL_OW 274
7376: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7377: LD_VAR 0 4
7381: PPUSH
7382: LD_INT 1
7384: PPUSH
7385: LD_INT 5000
7387: PPUSH
7388: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7392: LD_VAR 0 4
7396: PPUSH
7397: LD_INT 2
7399: PPUSH
7400: LD_INT 200
7402: PPUSH
7403: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7407: LD_VAR 0 4
7411: PPUSH
7412: LD_INT 3
7414: PPUSH
7415: LD_INT 200
7417: PPUSH
7418: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7422: LD_ADDR_EXP 102
7426: PUSH
7427: LD_EXP 102
7431: PPUSH
7432: LD_INT 2
7434: PPUSH
7435: LD_VAR 0 5
7439: PUSH
7440: LD_INT 22
7442: PUSH
7443: LD_VAR 0 6
7447: PUSH
7448: EMPTY
7449: LIST
7450: LIST
7451: PUSH
7452: LD_INT 3
7454: PUSH
7455: LD_INT 21
7457: PUSH
7458: LD_INT 2
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PPUSH
7473: CALL_OW 69
7477: UNION
7478: PUSH
7479: LD_EXP 64
7483: DIFF
7484: PPUSH
7485: CALL_OW 1
7489: ST_TO_ADDR
// behemoths := [ ] ;
7490: LD_ADDR_EXP 72
7494: PUSH
7495: EMPTY
7496: ST_TO_ADDR
// behemothBuilders := [ ] ;
7497: LD_ADDR_EXP 73
7501: PUSH
7502: EMPTY
7503: ST_TO_ADDR
// if Kovalyuk then
7504: LD_EXP 65
7508: IFFALSE 7530
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7510: LD_ADDR_EXP 73
7514: PUSH
7515: LD_EXP 73
7519: PPUSH
7520: LD_EXP 65
7524: PPUSH
7525: CALL 107652 0 2
7529: ST_TO_ADDR
// j := 3 ;
7530: LD_ADDR_VAR 0 3
7534: PUSH
7535: LD_INT 3
7537: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7538: LD_ADDR_VAR 0 2
7542: PUSH
7543: LD_INT 22
7545: PUSH
7546: LD_INT 3
7548: PUSH
7549: EMPTY
7550: LIST
7551: LIST
7552: PUSH
7553: LD_INT 25
7555: PUSH
7556: LD_INT 3
7558: PUSH
7559: EMPTY
7560: LIST
7561: LIST
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PPUSH
7567: CALL_OW 69
7571: PUSH
7572: LD_EXP 65
7576: DIFF
7577: PUSH
7578: FOR_IN
7579: IFFALSE 7629
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7581: LD_ADDR_EXP 73
7585: PUSH
7586: LD_EXP 73
7590: PPUSH
7591: LD_VAR 0 2
7595: PPUSH
7596: CALL 107652 0 2
7600: ST_TO_ADDR
// j := j - 1 ;
7601: LD_ADDR_VAR 0 3
7605: PUSH
7606: LD_VAR 0 3
7610: PUSH
7611: LD_INT 1
7613: MINUS
7614: ST_TO_ADDR
// if j = 0 then
7615: LD_VAR 0 3
7619: PUSH
7620: LD_INT 0
7622: EQUAL
7623: IFFALSE 7627
// break ;
7625: GO 7629
// end ;
7627: GO 7578
7629: POP
7630: POP
// end ;
7631: LD_VAR 0 1
7635: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7636: LD_INT 0
7638: PPUSH
7639: PPUSH
7640: PPUSH
7641: PPUSH
7642: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7643: LD_ADDR_VAR 0 4
7647: PUSH
7648: LD_INT 209
7650: PUSH
7651: LD_INT 149
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 219
7660: PUSH
7661: LD_INT 154
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 223
7670: PUSH
7671: LD_INT 149
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 232
7680: PUSH
7681: LD_INT 155
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: ST_TO_ADDR
// if not behemothBuilders then
7694: LD_EXP 73
7698: NOT
7699: IFFALSE 7703
// exit ;
7701: GO 7807
// j := 1 ;
7703: LD_ADDR_VAR 0 3
7707: PUSH
7708: LD_INT 1
7710: ST_TO_ADDR
// for i in behemothBuilders do
7711: LD_ADDR_VAR 0 2
7715: PUSH
7716: LD_EXP 73
7720: PUSH
7721: FOR_IN
7722: IFFALSE 7805
// begin if IsInUnit ( i ) then
7724: LD_VAR 0 2
7728: PPUSH
7729: CALL_OW 310
7733: IFFALSE 7744
// ComExitBuilding ( i ) ;
7735: LD_VAR 0 2
7739: PPUSH
7740: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7744: LD_VAR 0 2
7748: PPUSH
7749: LD_INT 37
7751: PPUSH
7752: LD_VAR 0 4
7756: PUSH
7757: LD_VAR 0 3
7761: ARRAY
7762: PUSH
7763: LD_INT 1
7765: ARRAY
7766: PPUSH
7767: LD_VAR 0 4
7771: PUSH
7772: LD_VAR 0 3
7776: ARRAY
7777: PUSH
7778: LD_INT 2
7780: ARRAY
7781: PPUSH
7782: LD_INT 0
7784: PPUSH
7785: CALL_OW 230
// j := j + 1 ;
7789: LD_ADDR_VAR 0 3
7793: PUSH
7794: LD_VAR 0 3
7798: PUSH
7799: LD_INT 1
7801: PLUS
7802: ST_TO_ADDR
// end ;
7803: GO 7721
7805: POP
7806: POP
// end ;
7807: LD_VAR 0 1
7811: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7812: LD_INT 24
7814: PPUSH
7815: LD_INT 30
7817: PUSH
7818: LD_INT 37
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PPUSH
7825: CALL_OW 70
7829: IFFALSE 7842
7831: GO 7833
7833: DISABLE
// behemothUnderConstruct := true ;
7834: LD_ADDR_EXP 26
7838: PUSH
7839: LD_INT 1
7841: ST_TO_ADDR
7842: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7843: LD_INT 3
7845: PPUSH
7846: CALL 107700 0 1
7850: PUSH
7851: LD_INT 22
7853: PUSH
7854: LD_INT 3
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PUSH
7861: LD_INT 30
7863: PUSH
7864: LD_INT 37
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: PUSH
7871: EMPTY
7872: LIST
7873: LIST
7874: PPUSH
7875: CALL_OW 69
7879: NOT
7880: AND
7881: IFFALSE 8067
7883: GO 7885
7885: DISABLE
7886: LD_INT 0
7888: PPUSH
7889: PPUSH
// begin enable ;
7890: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7891: LD_ADDR_VAR 0 2
7895: PUSH
7896: LD_INT 3
7898: PPUSH
7899: CALL 107700 0 1
7903: ST_TO_ADDR
// for i in tmp do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: LD_VAR 0 2
7913: PUSH
7914: FOR_IN
7915: IFFALSE 8065
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7917: LD_VAR 0 1
7921: PPUSH
7922: LD_INT 9
7924: PPUSH
7925: CALL_OW 308
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 110
7939: PUSH
7940: LD_INT 2
7942: EQUAL
7943: NOT
7944: AND
7945: IFFALSE 7959
// SetTag ( i , 2 ) ;
7947: LD_VAR 0 1
7951: PPUSH
7952: LD_INT 2
7954: PPUSH
7955: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7959: LD_INT 81
7961: PUSH
7962: LD_INT 3
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: PUSH
7969: LD_INT 91
7971: PUSH
7972: LD_VAR 0 1
7976: PUSH
7977: LD_INT 12
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: LIST
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: PPUSH
7989: CALL_OW 69
7993: NOT
7994: PUSH
7995: LD_VAR 0 1
7999: PPUSH
8000: CALL_OW 110
8004: PUSH
8005: LD_INT 2
8007: EQUAL
8008: NOT
8009: AND
8010: IFFALSE 8029
// ComAgressiveMove ( i , 64 , 93 ) else
8012: LD_VAR 0 1
8016: PPUSH
8017: LD_INT 64
8019: PPUSH
8020: LD_INT 93
8022: PPUSH
8023: CALL_OW 114
8027: GO 8063
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 81
8036: PUSH
8037: LD_INT 3
8039: PUSH
8040: EMPTY
8041: LIST
8042: LIST
8043: PPUSH
8044: CALL_OW 69
8048: PPUSH
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 74
8058: PPUSH
8059: CALL_OW 115
// end ;
8063: GO 7914
8065: POP
8066: POP
// end ;
8067: PPOPN 2
8069: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// result := [ ] ;
8075: LD_ADDR_VAR 0 2
8079: PUSH
8080: EMPTY
8081: ST_TO_ADDR
// uc_side := 6 ;
8082: LD_ADDR_OWVAR 20
8086: PUSH
8087: LD_INT 6
8089: ST_TO_ADDR
// uc_nation := 3 ;
8090: LD_ADDR_OWVAR 21
8094: PUSH
8095: LD_INT 3
8097: ST_TO_ADDR
// case strength of 1 :
8098: LD_VAR 0 1
8102: PUSH
8103: LD_INT 1
8105: DOUBLE
8106: EQUAL
8107: IFTRUE 8111
8109: GO 8249
8111: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8112: LD_ADDR_VAR 0 3
8116: PUSH
8117: DOUBLE
8118: LD_INT 1
8120: DEC
8121: ST_TO_ADDR
8122: LD_INT 4
8124: PUSH
8125: LD_INT 5
8127: PUSH
8128: LD_INT 6
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: LIST
8135: PUSH
8136: LD_OWVAR 67
8140: ARRAY
8141: PUSH
8142: FOR_TO
8143: IFFALSE 8245
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8145: LD_INT 22
8147: PUSH
8148: LD_INT 24
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_VAR 0 3
8159: PUSH
8160: LD_INT 2
8162: MOD
8163: PUSH
8164: LD_INT 1
8166: PLUS
8167: ARRAY
8168: PPUSH
8169: LD_INT 1
8171: PUSH
8172: LD_INT 3
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PUSH
8179: LD_INT 1
8181: PPUSH
8182: LD_INT 2
8184: PPUSH
8185: CALL_OW 12
8189: ARRAY
8190: PPUSH
8191: LD_INT 3
8193: PPUSH
8194: LD_INT 43
8196: PUSH
8197: LD_INT 44
8199: PUSH
8200: LD_INT 45
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 1
8210: PPUSH
8211: LD_INT 3
8213: PPUSH
8214: CALL_OW 12
8218: ARRAY
8219: PPUSH
8220: LD_INT 80
8222: PPUSH
8223: CALL 71897 0 5
// result := result union CreateVehicle ;
8227: LD_ADDR_VAR 0 2
8231: PUSH
8232: LD_VAR 0 2
8236: PUSH
8237: CALL_OW 45
8241: UNION
8242: ST_TO_ADDR
// end ;
8243: GO 8142
8245: POP
8246: POP
// end ; 2 :
8247: GO 9193
8249: LD_INT 2
8251: DOUBLE
8252: EQUAL
8253: IFTRUE 8257
8255: GO 8413
8257: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: DOUBLE
8264: LD_INT 1
8266: DEC
8267: ST_TO_ADDR
8268: LD_INT 5
8270: PUSH
8271: LD_INT 6
8273: PUSH
8274: LD_INT 7
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: LIST
8281: PUSH
8282: LD_OWVAR 67
8286: ARRAY
8287: PUSH
8288: FOR_TO
8289: IFFALSE 8409
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8291: LD_INT 22
8293: PUSH
8294: LD_INT 24
8296: PUSH
8297: LD_INT 24
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: LIST
8304: PUSH
8305: LD_VAR 0 3
8309: PUSH
8310: LD_INT 3
8312: MOD
8313: PUSH
8314: LD_INT 1
8316: PLUS
8317: ARRAY
8318: PPUSH
8319: LD_INT 1
8321: PUSH
8322: LD_INT 3
8324: PUSH
8325: EMPTY
8326: LIST
8327: LIST
8328: PUSH
8329: LD_INT 1
8331: PPUSH
8332: LD_INT 2
8334: PPUSH
8335: CALL_OW 12
8339: ARRAY
8340: PPUSH
8341: LD_INT 3
8343: PPUSH
8344: LD_INT 43
8346: PUSH
8347: LD_INT 44
8349: PUSH
8350: LD_INT 45
8352: PUSH
8353: LD_INT 44
8355: PUSH
8356: LD_INT 46
8358: PUSH
8359: LD_INT 46
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: LIST
8366: LIST
8367: LIST
8368: LIST
8369: PUSH
8370: LD_VAR 0 3
8374: PUSH
8375: LD_INT 6
8377: MOD
8378: PUSH
8379: LD_INT 1
8381: PLUS
8382: ARRAY
8383: PPUSH
8384: LD_INT 80
8386: PPUSH
8387: CALL 71897 0 5
// result := result union CreateVehicle ;
8391: LD_ADDR_VAR 0 2
8395: PUSH
8396: LD_VAR 0 2
8400: PUSH
8401: CALL_OW 45
8405: UNION
8406: ST_TO_ADDR
// end ;
8407: GO 8288
8409: POP
8410: POP
// end ; 3 :
8411: GO 9193
8413: LD_INT 3
8415: DOUBLE
8416: EQUAL
8417: IFTRUE 8421
8419: GO 8577
8421: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8422: LD_ADDR_VAR 0 3
8426: PUSH
8427: DOUBLE
8428: LD_INT 1
8430: DEC
8431: ST_TO_ADDR
8432: LD_INT 5
8434: PUSH
8435: LD_INT 7
8437: PUSH
8438: LD_INT 8
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: LIST
8445: PUSH
8446: LD_OWVAR 67
8450: ARRAY
8451: PUSH
8452: FOR_TO
8453: IFFALSE 8573
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8455: LD_INT 22
8457: PUSH
8458: LD_INT 24
8460: PUSH
8461: LD_INT 24
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: PUSH
8469: LD_VAR 0 3
8473: PUSH
8474: LD_INT 3
8476: MOD
8477: PUSH
8478: LD_INT 1
8480: PLUS
8481: ARRAY
8482: PPUSH
8483: LD_INT 1
8485: PUSH
8486: LD_INT 3
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: PUSH
8493: LD_INT 1
8495: PPUSH
8496: LD_INT 2
8498: PPUSH
8499: CALL_OW 12
8503: ARRAY
8504: PPUSH
8505: LD_INT 3
8507: PPUSH
8508: LD_INT 43
8510: PUSH
8511: LD_INT 47
8513: PUSH
8514: LD_INT 45
8516: PUSH
8517: LD_INT 45
8519: PUSH
8520: LD_INT 46
8522: PUSH
8523: LD_INT 46
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: LIST
8533: PUSH
8534: LD_VAR 0 3
8538: PUSH
8539: LD_INT 6
8541: MOD
8542: PUSH
8543: LD_INT 1
8545: PLUS
8546: ARRAY
8547: PPUSH
8548: LD_INT 80
8550: PPUSH
8551: CALL 71897 0 5
// result := result union CreateVehicle ;
8555: LD_ADDR_VAR 0 2
8559: PUSH
8560: LD_VAR 0 2
8564: PUSH
8565: CALL_OW 45
8569: UNION
8570: ST_TO_ADDR
// end ;
8571: GO 8452
8573: POP
8574: POP
// end ; 4 :
8575: GO 9193
8577: LD_INT 4
8579: DOUBLE
8580: EQUAL
8581: IFTRUE 8585
8583: GO 9192
8585: POP
// begin uc_nation := 3 ;
8586: LD_ADDR_OWVAR 21
8590: PUSH
8591: LD_INT 3
8593: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8594: LD_ADDR_VAR 0 3
8598: PUSH
8599: DOUBLE
8600: LD_INT 1
8602: DEC
8603: ST_TO_ADDR
8604: LD_INT 6
8606: PUSH
8607: LD_INT 8
8609: PUSH
8610: LD_INT 9
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: LIST
8617: PUSH
8618: LD_OWVAR 67
8622: ARRAY
8623: PUSH
8624: FOR_TO
8625: IFFALSE 8745
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8627: LD_INT 22
8629: PUSH
8630: LD_INT 24
8632: PUSH
8633: LD_INT 24
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: LIST
8640: PUSH
8641: LD_VAR 0 3
8645: PUSH
8646: LD_INT 3
8648: MOD
8649: PUSH
8650: LD_INT 1
8652: PLUS
8653: ARRAY
8654: PPUSH
8655: LD_INT 1
8657: PUSH
8658: LD_INT 3
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: PUSH
8665: LD_INT 1
8667: PPUSH
8668: LD_INT 2
8670: PPUSH
8671: CALL_OW 12
8675: ARRAY
8676: PPUSH
8677: LD_INT 3
8679: PPUSH
8680: LD_INT 45
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: LD_INT 47
8688: PUSH
8689: LD_INT 45
8691: PUSH
8692: LD_INT 46
8694: PUSH
8695: LD_INT 46
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: LIST
8704: LIST
8705: PUSH
8706: LD_VAR 0 3
8710: PUSH
8711: LD_INT 6
8713: MOD
8714: PUSH
8715: LD_INT 1
8717: PLUS
8718: ARRAY
8719: PPUSH
8720: LD_INT 80
8722: PPUSH
8723: CALL 71897 0 5
// result := result union CreateVehicle ;
8727: LD_ADDR_VAR 0 2
8731: PUSH
8732: LD_VAR 0 2
8736: PUSH
8737: CALL_OW 45
8741: UNION
8742: ST_TO_ADDR
// end ;
8743: GO 8624
8745: POP
8746: POP
// if not KappaStatus then
8747: LD_EXP 2
8751: NOT
8752: IFFALSE 8987
// begin uc_nation := 1 ;
8754: LD_ADDR_OWVAR 21
8758: PUSH
8759: LD_INT 1
8761: ST_TO_ADDR
// for i = 1 to 3 do
8762: LD_ADDR_VAR 0 3
8766: PUSH
8767: DOUBLE
8768: LD_INT 1
8770: DEC
8771: ST_TO_ADDR
8772: LD_INT 3
8774: PUSH
8775: FOR_TO
8776: IFFALSE 8912
// begin j := rand ( 0 , 1 ) ;
8778: LD_ADDR_VAR 0 4
8782: PUSH
8783: LD_INT 0
8785: PPUSH
8786: LD_INT 1
8788: PPUSH
8789: CALL_OW 12
8793: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8794: LD_INT 3
8796: PUSH
8797: LD_INT 5
8799: PUSH
8800: LD_INT 5
8802: PUSH
8803: LD_INT 4
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: PUSH
8812: LD_VAR 0 4
8816: PUSH
8817: LD_INT 1
8819: PPUSH
8820: LD_INT 3
8822: PPUSH
8823: CALL_OW 12
8827: PLUS
8828: ARRAY
8829: PPUSH
8830: LD_INT 1
8832: PUSH
8833: LD_INT 3
8835: PUSH
8836: EMPTY
8837: LIST
8838: LIST
8839: PUSH
8840: LD_INT 1
8842: PPUSH
8843: LD_INT 2
8845: PPUSH
8846: CALL_OW 12
8850: ARRAY
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: LD_INT 9
8857: PUSH
8858: LD_INT 7
8860: PUSH
8861: LD_INT 6
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 2
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 85
8889: PPUSH
8890: CALL 71897 0 5
// result := result union CreateVehicle ;
8894: LD_ADDR_VAR 0 2
8898: PUSH
8899: LD_VAR 0 2
8903: PUSH
8904: CALL_OW 45
8908: UNION
8909: ST_TO_ADDR
// end ;
8910: GO 8775
8912: POP
8913: POP
// if vsevolodFirstAttack then
8914: LD_EXP 24
8918: IFFALSE 8985
// begin vsevolodFirstAttack := false ;
8920: LD_ADDR_EXP 24
8924: PUSH
8925: LD_INT 0
8927: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8928: LD_INT 5
8930: PPUSH
8931: LD_INT 3
8933: PPUSH
8934: LD_INT 1
8936: PPUSH
8937: LD_INT 6
8939: PPUSH
8940: LD_INT 100
8942: PPUSH
8943: CALL 71897 0 5
// sewiVeh := CreateVehicle ;
8947: LD_ADDR_EXP 71
8951: PUSH
8952: CALL_OW 45
8956: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8957: LD_EXP 71
8961: PPUSH
8962: LD_INT 1
8964: PPUSH
8965: CALL_OW 242
// result := result union sewiVeh ;
8969: LD_ADDR_VAR 0 2
8973: PUSH
8974: LD_VAR 0 2
8978: PUSH
8979: LD_EXP 71
8983: UNION
8984: ST_TO_ADDR
// end ; end else
8985: GO 9190
// if vsevolodFirstAttack then
8987: LD_EXP 24
8991: IFFALSE 9190
// begin vsevolodFirstAttack := false ;
8993: LD_ADDR_EXP 24
8997: PUSH
8998: LD_INT 0
9000: ST_TO_ADDR
// uc_nation := 3 ;
9001: LD_ADDR_OWVAR 21
9005: PUSH
9006: LD_INT 3
9008: ST_TO_ADDR
// for i = 1 to 3 do
9009: LD_ADDR_VAR 0 3
9013: PUSH
9014: DOUBLE
9015: LD_INT 1
9017: DEC
9018: ST_TO_ADDR
9019: LD_INT 3
9021: PUSH
9022: FOR_TO
9023: IFFALSE 9131
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9025: LD_INT 22
9027: PUSH
9028: LD_INT 24
9030: PUSH
9031: LD_INT 24
9033: PUSH
9034: EMPTY
9035: LIST
9036: LIST
9037: LIST
9038: PUSH
9039: LD_VAR 0 3
9043: PUSH
9044: LD_INT 3
9046: MOD
9047: PUSH
9048: LD_INT 1
9050: PLUS
9051: ARRAY
9052: PPUSH
9053: LD_INT 1
9055: PUSH
9056: LD_INT 3
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: LD_INT 1
9065: PPUSH
9066: LD_INT 2
9068: PPUSH
9069: CALL_OW 12
9073: ARRAY
9074: PPUSH
9075: LD_INT 3
9077: PPUSH
9078: LD_INT 45
9080: PUSH
9081: LD_INT 47
9083: PUSH
9084: LD_INT 47
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PUSH
9092: LD_VAR 0 3
9096: PUSH
9097: LD_INT 3
9099: MOD
9100: PUSH
9101: LD_INT 1
9103: PLUS
9104: ARRAY
9105: PPUSH
9106: LD_INT 80
9108: PPUSH
9109: CALL 71897 0 5
// result := result union CreateVehicle ;
9113: LD_ADDR_VAR 0 2
9117: PUSH
9118: LD_VAR 0 2
9122: PUSH
9123: CALL_OW 45
9127: UNION
9128: ST_TO_ADDR
// end ;
9129: GO 9022
9131: POP
9132: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9133: LD_INT 24
9135: PPUSH
9136: LD_INT 3
9138: PPUSH
9139: LD_INT 1
9141: PPUSH
9142: LD_INT 47
9144: PPUSH
9145: LD_INT 100
9147: PPUSH
9148: CALL 71897 0 5
// sewiVeh := CreateVehicle ;
9152: LD_ADDR_EXP 71
9156: PUSH
9157: CALL_OW 45
9161: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9162: LD_EXP 71
9166: PPUSH
9167: LD_INT 1
9169: PPUSH
9170: CALL_OW 242
// result := result union sewiVeh ;
9174: LD_ADDR_VAR 0 2
9178: PUSH
9179: LD_VAR 0 2
9183: PUSH
9184: LD_EXP 71
9188: UNION
9189: ST_TO_ADDR
// end ; end ; end ;
9190: GO 9193
9192: POP
// end ;
9193: LD_VAR 0 2
9197: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9198: LD_EXP 16
9202: IFFALSE 9960
9204: GO 9206
9206: DISABLE
9207: LD_INT 0
9209: PPUSH
9210: PPUSH
9211: PPUSH
9212: PPUSH
9213: PPUSH
9214: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9215: LD_ADDR_VAR 0 4
9219: PUSH
9220: LD_INT 11
9222: PUSH
9223: LD_INT 12
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$40 , 4 4$10 ] [ Difficulty ] ;
9230: LD_ADDR_VAR 0 3
9234: PUSH
9235: LD_INT 11550
9237: PUSH
9238: LD_INT 9800
9240: PUSH
9241: LD_INT 8750
9243: PUSH
9244: EMPTY
9245: LIST
9246: LIST
9247: LIST
9248: PUSH
9249: LD_OWVAR 67
9253: ARRAY
9254: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9255: LD_ADDR_VAR 0 6
9259: PUSH
9260: LD_INT 70
9262: PUSH
9263: LD_INT 118
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: PUSH
9270: LD_INT 78
9272: PUSH
9273: LD_INT 31
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: ST_TO_ADDR
// repeat if missionStage = 2 then
9284: LD_EXP 15
9288: PUSH
9289: LD_INT 2
9291: EQUAL
9292: IFFALSE 9303
// wait ( 1 1$30 ) else
9294: LD_INT 3150
9296: PPUSH
9297: CALL_OW 67
9301: GO 9312
// wait ( time ) ;
9303: LD_VAR 0 3
9307: PPUSH
9308: CALL_OW 67
// if missionStage = 6 then
9312: LD_EXP 15
9316: PUSH
9317: LD_INT 6
9319: EQUAL
9320: IFFALSE 9348
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9322: LD_INT 51
9324: PPUSH
9325: LD_INT 6
9327: PPUSH
9328: LD_INT 2
9330: PPUSH
9331: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9335: LD_INT 57
9337: PPUSH
9338: LD_INT 6
9340: PPUSH
9341: LD_INT 2
9343: PPUSH
9344: CALL_OW 322
// end ; if missionStage = 8 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 8
9355: EQUAL
9356: IFFALSE 9384
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9358: LD_INT 52
9360: PPUSH
9361: LD_INT 6
9363: PPUSH
9364: LD_INT 2
9366: PPUSH
9367: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9371: LD_INT 58
9373: PPUSH
9374: LD_INT 6
9376: PPUSH
9377: LD_INT 2
9379: PPUSH
9380: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9384: LD_EXP 15
9388: PUSH
9389: LD_INT 10
9391: EQUAL
9392: PUSH
9393: LD_OWVAR 67
9397: PUSH
9398: LD_INT 1
9400: GREATER
9401: AND
9402: IFFALSE 9430
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9404: LD_INT 53
9406: PPUSH
9407: LD_INT 6
9409: PPUSH
9410: LD_INT 2
9412: PPUSH
9413: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9417: LD_INT 59
9419: PPUSH
9420: LD_INT 6
9422: PPUSH
9423: LD_INT 2
9425: PPUSH
9426: CALL_OW 322
// end ; if activeAttacks then
9430: LD_EXP 16
9434: IFFALSE 9954
// begin if missionStage = 2 then
9436: LD_EXP 15
9440: PUSH
9441: LD_INT 2
9443: EQUAL
9444: IFFALSE 9454
// strength := 1 ;
9446: LD_ADDR_VAR 0 5
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// if missionStage > 2 then
9454: LD_EXP 15
9458: PUSH
9459: LD_INT 2
9461: GREATER
9462: IFFALSE 9472
// strength := 2 ;
9464: LD_ADDR_VAR 0 5
9468: PUSH
9469: LD_INT 2
9471: ST_TO_ADDR
// if missionStage > 6 then
9472: LD_EXP 15
9476: PUSH
9477: LD_INT 6
9479: GREATER
9480: IFFALSE 9490
// strength := 3 ;
9482: LD_ADDR_VAR 0 5
9486: PUSH
9487: LD_INT 3
9489: ST_TO_ADDR
// if missionStage > 10 then
9490: LD_EXP 15
9494: PUSH
9495: LD_INT 10
9497: GREATER
9498: IFFALSE 9508
// strength := 4 ;
9500: LD_ADDR_VAR 0 5
9504: PUSH
9505: LD_INT 4
9507: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9508: LD_ADDR_VAR 0 2
9512: PUSH
9513: LD_VAR 0 5
9517: PPUSH
9518: CALL 8070 0 1
9522: ST_TO_ADDR
// for i in tmp do
9523: LD_ADDR_VAR 0 1
9527: PUSH
9528: LD_VAR 0 2
9532: PUSH
9533: FOR_IN
9534: IFFALSE 9634
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9536: LD_VAR 0 1
9540: PPUSH
9541: LD_VAR 0 4
9545: PUSH
9546: LD_INT 1
9548: PPUSH
9549: LD_INT 2
9551: PPUSH
9552: CALL_OW 12
9556: ARRAY
9557: PPUSH
9558: LD_INT 0
9560: PPUSH
9561: CALL_OW 49
// if i = sewiVeh then
9565: LD_VAR 0 1
9569: PUSH
9570: LD_EXP 71
9574: EQUAL
9575: IFFALSE 9610
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9577: LD_ADDR_EXP 70
9581: PUSH
9582: LD_STRING Vsevolod
9584: PPUSH
9585: LD_INT 0
9587: PPUSH
9588: LD_STRING 
9590: PPUSH
9591: CALL 64782 0 3
9595: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9596: LD_EXP 70
9600: PPUSH
9601: LD_VAR 0 1
9605: PPUSH
9606: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9610: LD_VAR 0 1
9614: PPUSH
9615: LD_INT 111
9617: PPUSH
9618: LD_INT 197
9620: PPUSH
9621: CALL_OW 111
// wait ( 0 0$2 ) ;
9625: LD_INT 70
9627: PPUSH
9628: CALL_OW 67
// end ;
9632: GO 9533
9634: POP
9635: POP
// repeat wait ( 0 0$1 ) ;
9636: LD_INT 35
9638: PPUSH
9639: CALL_OW 67
// for i in tmp do
9643: LD_ADDR_VAR 0 1
9647: PUSH
9648: LD_VAR 0 2
9652: PUSH
9653: FOR_IN
9654: IFFALSE 9935
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9656: LD_INT 81
9658: PUSH
9659: LD_INT 6
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PUSH
9666: LD_INT 91
9668: PUSH
9669: LD_VAR 0 1
9673: PUSH
9674: LD_INT 12
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PPUSH
9686: CALL_OW 69
9690: IFFALSE 9748
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9692: LD_VAR 0 1
9696: PPUSH
9697: LD_INT 81
9699: PUSH
9700: LD_INT 6
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 91
9709: PUSH
9710: LD_VAR 0 1
9714: PUSH
9715: LD_INT 12
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: LIST
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: PPUSH
9727: CALL_OW 69
9731: PPUSH
9732: LD_VAR 0 1
9736: PPUSH
9737: CALL_OW 74
9741: PPUSH
9742: CALL_OW 115
9746: GO 9933
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9748: LD_INT 9
9750: PPUSH
9751: LD_INT 81
9753: PUSH
9754: LD_INT 6
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PPUSH
9761: CALL_OW 70
9765: IFFALSE 9899
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9767: LD_VAR 0 1
9771: PPUSH
9772: LD_VAR 0 6
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PUSH
9781: LD_INT 1
9783: ARRAY
9784: PPUSH
9785: LD_VAR 0 6
9789: PUSH
9790: LD_INT 1
9792: ARRAY
9793: PUSH
9794: LD_INT 2
9796: ARRAY
9797: PPUSH
9798: CALL_OW 297
9802: PUSH
9803: LD_INT 10
9805: GREATER
9806: PUSH
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_INT 9
9814: PPUSH
9815: CALL_OW 308
9819: NOT
9820: AND
9821: IFFALSE 9860
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9823: LD_VAR 0 1
9827: PPUSH
9828: LD_VAR 0 6
9832: PUSH
9833: LD_INT 1
9835: ARRAY
9836: PUSH
9837: LD_INT 1
9839: ARRAY
9840: PPUSH
9841: LD_VAR 0 6
9845: PUSH
9846: LD_INT 1
9848: ARRAY
9849: PUSH
9850: LD_INT 2
9852: ARRAY
9853: PPUSH
9854: CALL_OW 114
9858: GO 9897
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9860: LD_VAR 0 1
9864: PPUSH
9865: LD_INT 9
9867: PPUSH
9868: LD_INT 81
9870: PUSH
9871: LD_INT 6
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 70
9882: PPUSH
9883: LD_VAR 0 1
9887: PPUSH
9888: CALL_OW 74
9892: PPUSH
9893: CALL_OW 115
// end else
9897: GO 9933
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_INT 81
9906: PUSH
9907: LD_INT 6
9909: PUSH
9910: EMPTY
9911: LIST
9912: LIST
9913: PPUSH
9914: CALL_OW 69
9918: PPUSH
9919: LD_VAR 0 1
9923: PPUSH
9924: CALL_OW 74
9928: PPUSH
9929: CALL_OW 115
// end ;
9933: GO 9653
9935: POP
9936: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9937: LD_INT 22
9939: PUSH
9940: LD_INT 6
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PPUSH
9947: CALL_OW 69
9951: NOT
9952: IFFALSE 9636
// end ; until russianDestroyed ;
9954: LD_EXP 21
9958: IFFALSE 9284
// end ;
9960: PPOPN 6
9962: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9963: LD_EXP 21
9967: NOT
9968: PUSH
9969: LD_EXP 15
9973: PUSH
9974: LD_INT 6
9976: GREATEREQUAL
9977: AND
9978: PUSH
9979: LD_INT 2
9981: PPUSH
9982: LD_INT 1
9984: PPUSH
9985: CALL 59856 0 2
9989: NOT
9990: AND
9991: IFFALSE 10947
9993: GO 9995
9995: DISABLE
9996: LD_INT 0
9998: PPUSH
9999: PPUSH
10000: PPUSH
10001: PPUSH
// begin enable ;
10002: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10003: LD_INT 22
10005: PUSH
10006: LD_INT 3
10008: PUSH
10009: EMPTY
10010: LIST
10011: LIST
10012: PUSH
10013: LD_INT 30
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PUSH
10023: EMPTY
10024: LIST
10025: LIST
10026: PPUSH
10027: CALL_OW 69
10031: NOT
10032: IFFALSE 10036
// exit ;
10034: GO 10947
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10036: LD_ADDR_VAR 0 4
10040: PUSH
10041: LD_INT 22
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: EMPTY
10048: LIST
10049: LIST
10050: PUSH
10051: LD_INT 30
10053: PUSH
10054: LD_INT 34
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: PPUSH
10065: CALL_OW 69
10069: ST_TO_ADDR
// if Prob ( 40 ) then
10070: LD_INT 40
10072: PPUSH
10073: CALL_OW 13
10077: IFFALSE 10204
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10079: LD_INT 2
10081: PPUSH
10082: LD_INT 22
10084: PUSH
10085: LD_INT 3
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 49
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 22
10102: PUSH
10103: LD_INT 3
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 49
10111: PUSH
10112: EMPTY
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: LD_INT 22
10120: PUSH
10121: LD_INT 3
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 49
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_INT 24
10138: PUSH
10139: LD_INT 3
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 46
10147: PUSH
10148: EMPTY
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 24
10156: PUSH
10157: LD_INT 3
10159: PUSH
10160: LD_INT 3
10162: PUSH
10163: LD_INT 46
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: LIST
10170: LIST
10171: PUSH
10172: LD_INT 24
10174: PUSH
10175: LD_INT 3
10177: PUSH
10178: LD_INT 3
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: LIST
10195: LIST
10196: LIST
10197: PPUSH
10198: CALL 58438 0 2
// end else
10202: GO 10327
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10204: LD_INT 2
10206: PPUSH
10207: LD_INT 24
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 47
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 24
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 47
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 47
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: LD_INT 24
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 46
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: EMPTY
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: PPUSH
10323: CALL 58438 0 2
// end ; if Difficulty > 1 then
10327: LD_OWVAR 67
10331: PUSH
10332: LD_INT 1
10334: GREATER
10335: IFFALSE 10365
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10337: LD_INT 2
10339: PPUSH
10340: LD_INT 24
10342: PUSH
10343: LD_INT 3
10345: PUSH
10346: LD_INT 3
10348: PUSH
10349: LD_INT 47
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: PUSH
10358: EMPTY
10359: LIST
10360: PPUSH
10361: CALL 58438 0 2
// repeat wait ( 0 0$1 ) ;
10365: LD_INT 35
10367: PPUSH
10368: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10372: LD_INT 2
10374: PPUSH
10375: LD_INT 1
10377: PPUSH
10378: CALL 59856 0 2
10382: PUSH
10383: LD_INT 6
10385: PUSH
10386: LD_INT 7
10388: PUSH
10389: LD_INT 7
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: LIST
10396: PUSH
10397: LD_OWVAR 67
10401: ARRAY
10402: GREATEREQUAL
10403: IFFALSE 10365
// wait ( 0 0$30 ) ;
10405: LD_INT 1050
10407: PPUSH
10408: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10412: LD_ADDR_VAR 0 2
10416: PUSH
10417: LD_INT 2
10419: PPUSH
10420: LD_INT 1
10422: PPUSH
10423: CALL 59856 0 2
10427: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10428: LD_ADDR_EXP 121
10432: PUSH
10433: LD_EXP 121
10437: PPUSH
10438: LD_INT 2
10440: PPUSH
10441: LD_EXP 121
10445: PUSH
10446: LD_INT 2
10448: ARRAY
10449: PUSH
10450: LD_VAR 0 2
10454: DIFF
10455: PPUSH
10456: CALL_OW 1
10460: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10461: LD_ADDR_VAR 0 3
10465: PUSH
10466: LD_INT 0
10468: PPUSH
10469: LD_INT 1
10471: PPUSH
10472: CALL_OW 12
10476: ST_TO_ADDR
// if target then
10477: LD_VAR 0 3
10481: IFFALSE 10609
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10483: LD_ADDR_VAR 0 2
10487: PUSH
10488: LD_VAR 0 2
10492: PPUSH
10493: LD_INT 24
10495: PUSH
10496: LD_INT 250
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: PPUSH
10503: CALL_OW 72
10507: ST_TO_ADDR
// for i in tmp do
10508: LD_ADDR_VAR 0 1
10512: PUSH
10513: LD_VAR 0 2
10517: PUSH
10518: FOR_IN
10519: IFFALSE 10559
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10521: LD_VAR 0 1
10525: PPUSH
10526: LD_INT 139
10528: PPUSH
10529: LD_INT 89
10531: PPUSH
10532: CALL_OW 297
10536: PUSH
10537: LD_INT 9
10539: GREATER
10540: IFFALSE 10557
// ComMoveXY ( i , 139 , 89 ) ;
10542: LD_VAR 0 1
10546: PPUSH
10547: LD_INT 139
10549: PPUSH
10550: LD_INT 89
10552: PPUSH
10553: CALL_OW 111
10557: GO 10518
10559: POP
10560: POP
// wait ( 0 0$1 ) ;
10561: LD_INT 35
10563: PPUSH
10564: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10568: LD_VAR 0 2
10572: PPUSH
10573: LD_INT 92
10575: PUSH
10576: LD_INT 139
10578: PUSH
10579: LD_INT 89
10581: PUSH
10582: LD_INT 9
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: PPUSH
10591: CALL_OW 72
10595: PUSH
10596: LD_VAR 0 2
10600: PUSH
10601: LD_INT 1
10603: MINUS
10604: GREATEREQUAL
10605: IFFALSE 10483
// end else
10607: GO 10751
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10609: LD_VAR 0 2
10613: PPUSH
10614: LD_VAR 0 4
10618: PUSH
10619: LD_INT 1
10621: ARRAY
10622: PPUSH
10623: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10627: LD_ADDR_VAR 0 2
10631: PUSH
10632: LD_VAR 0 2
10636: PPUSH
10637: LD_INT 24
10639: PUSH
10640: LD_INT 250
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: PPUSH
10647: CALL_OW 72
10651: ST_TO_ADDR
// for i in tmp do
10652: LD_ADDR_VAR 0 1
10656: PUSH
10657: LD_VAR 0 2
10661: PUSH
10662: FOR_IN
10663: IFFALSE 10703
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10665: LD_VAR 0 1
10669: PPUSH
10670: LD_INT 124
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: CALL_OW 297
10680: PUSH
10681: LD_INT 9
10683: GREATER
10684: IFFALSE 10701
// ComMoveXY ( i , 124 , 139 ) ;
10686: LD_VAR 0 1
10690: PPUSH
10691: LD_INT 124
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: CALL_OW 111
10701: GO 10662
10703: POP
10704: POP
// wait ( 0 0$1 ) ;
10705: LD_INT 35
10707: PPUSH
10708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10712: LD_VAR 0 2
10716: PPUSH
10717: LD_INT 92
10719: PUSH
10720: LD_INT 124
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 9
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: LIST
10733: LIST
10734: PPUSH
10735: CALL_OW 72
10739: PUSH
10740: LD_VAR 0 2
10744: PUSH
10745: LD_INT 1
10747: MINUS
10748: GREATEREQUAL
10749: IFFALSE 10627
// end ; repeat wait ( 0 0$1 ) ;
10751: LD_INT 35
10753: PPUSH
10754: CALL_OW 67
// for i in tmp do
10758: LD_ADDR_VAR 0 1
10762: PUSH
10763: LD_VAR 0 2
10767: PUSH
10768: FOR_IN
10769: IFFALSE 10938
// begin if GetLives ( i ) > 251 then
10771: LD_VAR 0 1
10775: PPUSH
10776: CALL_OW 256
10780: PUSH
10781: LD_INT 251
10783: GREATER
10784: IFFALSE 10909
// begin if GetWeapon ( i ) = ru_time_lapser then
10786: LD_VAR 0 1
10790: PPUSH
10791: CALL_OW 264
10795: PUSH
10796: LD_INT 49
10798: EQUAL
10799: IFFALSE 10855
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10801: LD_VAR 0 1
10805: PPUSH
10806: LD_INT 2
10808: PUSH
10809: LD_INT 22
10811: PUSH
10812: LD_INT 1
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: PUSH
10819: LD_INT 22
10821: PUSH
10822: LD_INT 8
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: EMPTY
10830: LIST
10831: LIST
10832: LIST
10833: PPUSH
10834: CALL_OW 69
10838: PPUSH
10839: LD_VAR 0 1
10843: PPUSH
10844: CALL_OW 74
10848: PPUSH
10849: CALL_OW 112
10853: GO 10907
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10855: LD_VAR 0 1
10859: PPUSH
10860: LD_INT 2
10862: PUSH
10863: LD_INT 22
10865: PUSH
10866: LD_INT 1
10868: PUSH
10869: EMPTY
10870: LIST
10871: LIST
10872: PUSH
10873: LD_INT 22
10875: PUSH
10876: LD_INT 8
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: PPUSH
10888: CALL_OW 69
10892: PPUSH
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 74
10902: PPUSH
10903: CALL_OW 115
// end else
10907: GO 10936
// if IsDead ( i ) then
10909: LD_VAR 0 1
10913: PPUSH
10914: CALL_OW 301
10918: IFFALSE 10936
// tmp := tmp diff i ;
10920: LD_ADDR_VAR 0 2
10924: PUSH
10925: LD_VAR 0 2
10929: PUSH
10930: LD_VAR 0 1
10934: DIFF
10935: ST_TO_ADDR
// end ;
10936: GO 10768
10938: POP
10939: POP
// until not tmp ;
10940: LD_VAR 0 2
10944: NOT
10945: IFFALSE 10751
// end ; end_of_file
10947: PPOPN 4
10949: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10950: LD_INT 0
10952: PPUSH
10953: PPUSH
10954: PPUSH
10955: PPUSH
10956: PPUSH
10957: PPUSH
// side := 7 ;
10958: LD_ADDR_VAR 0 5
10962: PUSH
10963: LD_INT 7
10965: ST_TO_ADDR
// uc_side := side ;
10966: LD_ADDR_OWVAR 20
10970: PUSH
10971: LD_VAR 0 5
10975: ST_TO_ADDR
// uc_nation := 1 ;
10976: LD_ADDR_OWVAR 21
10980: PUSH
10981: LD_INT 1
10983: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10984: LD_ADDR_VAR 0 2
10988: PUSH
10989: LD_INT 22
10991: PUSH
10992: LD_VAR 0 5
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: LD_INT 21
11003: PUSH
11004: LD_INT 3
11006: PUSH
11007: EMPTY
11008: LIST
11009: LIST
11010: PUSH
11011: EMPTY
11012: LIST
11013: LIST
11014: PPUSH
11015: CALL_OW 69
11019: PUSH
11020: FOR_IN
11021: IFFALSE 11037
// SetBLevel ( i , 10 ) ;
11023: LD_VAR 0 2
11027: PPUSH
11028: LD_INT 10
11030: PPUSH
11031: CALL_OW 241
11035: GO 11020
11037: POP
11038: POP
// base := GetBase ( al_depot ) ;
11039: LD_ADDR_VAR 0 4
11043: PUSH
11044: LD_INT 2
11046: PPUSH
11047: CALL_OW 274
11051: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11052: LD_ADDR_VAR 0 6
11056: PUSH
11057: LD_INT 22
11059: PUSH
11060: LD_VAR 0 5
11064: PUSH
11065: EMPTY
11066: LIST
11067: LIST
11068: PUSH
11069: LD_INT 30
11071: PUSH
11072: LD_INT 34
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PPUSH
11083: CALL_OW 69
11087: ST_TO_ADDR
// if teleport then
11088: LD_VAR 0 6
11092: IFFALSE 11113
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11094: LD_VAR 0 6
11098: PUSH
11099: LD_INT 1
11101: ARRAY
11102: PPUSH
11103: LD_INT 262
11105: PPUSH
11106: LD_INT 119
11108: PPUSH
11109: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11113: LD_VAR 0 4
11117: PPUSH
11118: LD_INT 1
11120: PPUSH
11121: LD_INT 19500
11123: PPUSH
11124: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11128: LD_VAR 0 4
11132: PPUSH
11133: LD_INT 2
11135: PPUSH
11136: LD_INT 200
11138: PPUSH
11139: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11143: LD_VAR 0 4
11147: PPUSH
11148: LD_INT 3
11150: PPUSH
11151: LD_INT 650
11153: PPUSH
11154: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11158: LD_ADDR_EXP 74
11162: PUSH
11163: LD_STRING Roth
11165: PPUSH
11166: CALL_OW 25
11170: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11171: LD_ADDR_EXP 75
11175: PUSH
11176: LD_STRING Simms
11178: PPUSH
11179: LD_EXP 1
11183: NOT
11184: PPUSH
11185: LD_STRING 10c_
11187: PPUSH
11188: CALL 64782 0 3
11192: ST_TO_ADDR
// if not Simms then
11193: LD_EXP 75
11197: NOT
11198: IFFALSE 11228
// begin uc_nation := 1 ;
11200: LD_ADDR_OWVAR 21
11204: PUSH
11205: LD_INT 1
11207: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11208: LD_INT 2
11210: PPUSH
11211: LD_INT 10
11213: PPUSH
11214: CALL_OW 384
// Simms := CreateHuman ;
11218: LD_ADDR_EXP 75
11222: PUSH
11223: CALL_OW 44
11227: ST_TO_ADDR
// end ; uc_nation := 3 ;
11228: LD_ADDR_OWVAR 21
11232: PUSH
11233: LD_INT 3
11235: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11236: LD_ADDR_EXP 76
11240: PUSH
11241: LD_STRING Kirilenkova
11243: PPUSH
11244: CALL_OW 25
11248: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11249: LD_ADDR_EXP 90
11253: PUSH
11254: LD_STRING Oblukov
11256: PPUSH
11257: CALL_OW 25
11261: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11262: LD_ADDR_EXP 77
11266: PUSH
11267: LD_STRING Dolgov
11269: PPUSH
11270: CALL_OW 25
11274: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11275: LD_ADDR_EXP 78
11279: PUSH
11280: LD_STRING Petrosyan
11282: PPUSH
11283: CALL_OW 25
11287: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11288: LD_ADDR_EXP 89
11292: PUSH
11293: LD_STRING Scholtze
11295: PPUSH
11296: CALL_OW 25
11300: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11301: LD_ADDR_EXP 88
11305: PUSH
11306: LD_STRING Kapitsova
11308: PPUSH
11309: CALL_OW 25
11313: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11314: LD_ADDR_EXP 79
11318: PUSH
11319: LD_STRING Petrovova
11321: PPUSH
11322: CALL_OW 25
11326: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11327: LD_ADDR_EXP 80
11331: PUSH
11332: LD_STRING Kuzmov
11334: PPUSH
11335: CALL_OW 25
11339: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11340: LD_ADDR_EXP 87
11344: PUSH
11345: LD_STRING Karamazov
11347: PPUSH
11348: CALL_OW 25
11352: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11353: LD_STRING 13_Lipshchin_1
11355: PPUSH
11356: LD_INT 0
11358: PPUSH
11359: CALL_OW 30
11363: IFFALSE 11378
// Lipshchin := NewCharacter ( Lipshchin ) ;
11365: LD_ADDR_EXP 81
11369: PUSH
11370: LD_STRING Lipshchin
11372: PPUSH
11373: CALL_OW 25
11377: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11378: LD_STRING 13_Titov_1
11380: PPUSH
11381: LD_INT 0
11383: PPUSH
11384: CALL_OW 30
11388: IFFALSE 11403
// Titov := NewCharacter ( Titov ) ;
11390: LD_ADDR_EXP 83
11394: PUSH
11395: LD_STRING Titov
11397: PPUSH
11398: CALL_OW 25
11402: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11403: LD_STRING 13_Gnyevko_1
11405: PPUSH
11406: LD_INT 0
11408: PPUSH
11409: CALL_OW 30
11413: IFFALSE 11428
// Gnyevko := NewCharacter ( Gnyevko ) ;
11415: LD_ADDR_EXP 82
11419: PUSH
11420: LD_STRING Gnyevko
11422: PPUSH
11423: CALL_OW 25
11427: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11428: LD_STRING 13_Xavier_1
11430: PPUSH
11431: LD_INT 0
11433: PPUSH
11434: CALL_OW 30
11438: IFFALSE 11453
// Xavier := NewCharacter ( Xavier2 ) ;
11440: LD_ADDR_EXP 84
11444: PUSH
11445: LD_STRING Xavier2
11447: PPUSH
11448: CALL_OW 25
11452: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11453: LD_STRING 13_Belkov_1
11455: PPUSH
11456: LD_INT 0
11458: PPUSH
11459: CALL_OW 30
11463: IFFALSE 11478
// Belkov := NewCharacter ( Belkov ) ;
11465: LD_ADDR_EXP 85
11469: PUSH
11470: LD_STRING Belkov
11472: PPUSH
11473: CALL_OW 25
11477: ST_TO_ADDR
// if not BurlakStatus then
11478: LD_EXP 9
11482: NOT
11483: IFFALSE 11498
// Burlak = NewCharacter ( Burlak ) ;
11485: LD_ADDR_EXP 86
11489: PUSH
11490: LD_STRING Burlak
11492: PPUSH
11493: CALL_OW 25
11497: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11498: LD_ADDR_VAR 0 3
11502: PUSH
11503: LD_EXP 74
11507: PUSH
11508: LD_EXP 76
11512: PUSH
11513: LD_EXP 90
11517: PUSH
11518: LD_EXP 77
11522: PUSH
11523: LD_EXP 78
11527: PUSH
11528: LD_EXP 89
11532: PUSH
11533: LD_EXP 88
11537: PUSH
11538: LD_EXP 79
11542: PUSH
11543: LD_EXP 80
11547: PUSH
11548: LD_EXP 87
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: LIST
11562: LIST
11563: LIST
11564: ST_TO_ADDR
// if Simms then
11565: LD_EXP 75
11569: IFFALSE 11587
// tmp := tmp ^ Simms ;
11571: LD_ADDR_VAR 0 3
11575: PUSH
11576: LD_VAR 0 3
11580: PUSH
11581: LD_EXP 75
11585: ADD
11586: ST_TO_ADDR
// if Titov then
11587: LD_EXP 83
11591: IFFALSE 11609
// tmp := tmp ^ Titov ;
11593: LD_ADDR_VAR 0 3
11597: PUSH
11598: LD_VAR 0 3
11602: PUSH
11603: LD_EXP 83
11607: ADD
11608: ST_TO_ADDR
// if Lipshchin then
11609: LD_EXP 81
11613: IFFALSE 11631
// tmp := tmp ^ Lipshchin ;
11615: LD_ADDR_VAR 0 3
11619: PUSH
11620: LD_VAR 0 3
11624: PUSH
11625: LD_EXP 81
11629: ADD
11630: ST_TO_ADDR
// if Gnyevko then
11631: LD_EXP 82
11635: IFFALSE 11653
// tmp := tmp ^ Gnyevko ;
11637: LD_ADDR_VAR 0 3
11641: PUSH
11642: LD_VAR 0 3
11646: PUSH
11647: LD_EXP 82
11651: ADD
11652: ST_TO_ADDR
// if Xavier then
11653: LD_EXP 84
11657: IFFALSE 11675
// tmp := tmp ^ Xavier ;
11659: LD_ADDR_VAR 0 3
11663: PUSH
11664: LD_VAR 0 3
11668: PUSH
11669: LD_EXP 84
11673: ADD
11674: ST_TO_ADDR
// if Belkov then
11675: LD_EXP 85
11679: IFFALSE 11697
// tmp := tmp ^ Belkov ;
11681: LD_ADDR_VAR 0 3
11685: PUSH
11686: LD_VAR 0 3
11690: PUSH
11691: LD_EXP 85
11695: ADD
11696: ST_TO_ADDR
// if Burlak then
11697: LD_EXP 86
11701: IFFALSE 11719
// tmp := tmp ^ Burlak ;
11703: LD_ADDR_VAR 0 3
11707: PUSH
11708: LD_VAR 0 3
11712: PUSH
11713: LD_EXP 86
11717: ADD
11718: ST_TO_ADDR
// for i = 1 to 11 do
11719: LD_ADDR_VAR 0 2
11723: PUSH
11724: DOUBLE
11725: LD_INT 1
11727: DEC
11728: ST_TO_ADDR
11729: LD_INT 11
11731: PUSH
11732: FOR_TO
11733: IFFALSE 11799
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11735: LD_ADDR_OWVAR 21
11739: PUSH
11740: LD_INT 1
11742: PUSH
11743: LD_INT 3
11745: PUSH
11746: EMPTY
11747: LIST
11748: LIST
11749: PUSH
11750: LD_INT 1
11752: PPUSH
11753: LD_INT 2
11755: PPUSH
11756: CALL_OW 12
11760: ARRAY
11761: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11762: LD_INT 0
11764: PPUSH
11765: LD_VAR 0 2
11769: PUSH
11770: LD_INT 2
11772: DIV
11773: PPUSH
11774: LD_INT 10
11776: PPUSH
11777: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: CALL_OW 44
11795: ADD
11796: ST_TO_ADDR
// end ;
11797: GO 11732
11799: POP
11800: POP
// for i in tmp do
11801: LD_ADDR_VAR 0 2
11805: PUSH
11806: LD_VAR 0 3
11810: PUSH
11811: FOR_IN
11812: IFFALSE 11837
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11814: LD_VAR 0 2
11818: PPUSH
11819: LD_INT 260
11821: PPUSH
11822: LD_INT 235
11824: PPUSH
11825: LD_INT 8
11827: PPUSH
11828: LD_INT 0
11830: PPUSH
11831: CALL_OW 50
11835: GO 11811
11837: POP
11838: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11839: LD_ADDR_EXP 102
11843: PUSH
11844: LD_EXP 102
11848: PPUSH
11849: LD_INT 1
11851: PPUSH
11852: LD_INT 22
11854: PUSH
11855: LD_VAR 0 5
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PUSH
11864: LD_INT 3
11866: PUSH
11867: LD_INT 21
11869: PUSH
11870: LD_INT 2
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PUSH
11881: EMPTY
11882: LIST
11883: LIST
11884: PPUSH
11885: CALL_OW 69
11889: PUSH
11890: LD_EXP 74
11894: PUSH
11895: LD_EXP 75
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: DIFF
11904: PPUSH
11905: CALL_OW 1
11909: ST_TO_ADDR
// uc_side := 0 ;
11910: LD_ADDR_OWVAR 20
11914: PUSH
11915: LD_INT 0
11917: ST_TO_ADDR
// uc_nation := 0 ;
11918: LD_ADDR_OWVAR 21
11922: PUSH
11923: LD_INT 0
11925: ST_TO_ADDR
// for i = 1 to 5 do
11926: LD_ADDR_VAR 0 2
11930: PUSH
11931: DOUBLE
11932: LD_INT 1
11934: DEC
11935: ST_TO_ADDR
11936: LD_INT 5
11938: PUSH
11939: FOR_TO
11940: IFFALSE 11977
// begin InitHc ;
11942: CALL_OW 19
// hc_class := class_apeman ;
11946: LD_ADDR_OWVAR 28
11950: PUSH
11951: LD_INT 12
11953: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11954: CALL_OW 44
11958: PPUSH
11959: LD_INT 299
11961: PPUSH
11962: LD_INT 229
11964: PPUSH
11965: LD_INT 10
11967: PPUSH
11968: LD_INT 0
11970: PPUSH
11971: CALL_OW 50
// end ;
11975: GO 11939
11977: POP
11978: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11979: LD_EXP 74
11983: PPUSH
11984: LD_INT 259
11986: PPUSH
11987: LD_INT 235
11989: PPUSH
11990: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11994: LD_EXP 74
11998: PPUSH
11999: LD_INT 262
12001: PPUSH
12002: LD_INT 235
12004: PPUSH
12005: CALL_OW 178
// if Simms then
12009: LD_EXP 75
12013: IFFALSE 12044
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12015: LD_EXP 75
12019: PPUSH
12020: LD_INT 262
12022: PPUSH
12023: LD_INT 235
12025: PPUSH
12026: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12030: LD_EXP 75
12034: PPUSH
12035: LD_EXP 74
12039: PPUSH
12040: CALL_OW 179
// end ; end ;
12044: LD_VAR 0 1
12048: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12049: LD_EXP 31
12053: PUSH
12054: LD_EXP 23
12058: NOT
12059: AND
12060: IFFALSE 12236
12062: GO 12064
12064: DISABLE
12065: LD_INT 0
12067: PPUSH
12068: PPUSH
12069: PPUSH
// begin enable ;
12070: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12071: LD_ADDR_VAR 0 2
12075: PUSH
12076: LD_INT 81
12078: PUSH
12079: LD_INT 7
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PUSH
12086: LD_INT 2
12088: PUSH
12089: LD_INT 32
12091: PUSH
12092: LD_INT 3
12094: PUSH
12095: EMPTY
12096: LIST
12097: LIST
12098: PUSH
12099: LD_INT 30
12101: PUSH
12102: LD_INT 30
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: PUSH
12109: LD_INT 30
12111: PUSH
12112: LD_INT 28
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PUSH
12119: LD_INT 34
12121: PUSH
12122: LD_INT 49
12124: PUSH
12125: EMPTY
12126: LIST
12127: LIST
12128: PUSH
12129: LD_INT 34
12131: PUSH
12132: LD_INT 10
12134: PUSH
12135: EMPTY
12136: LIST
12137: LIST
12138: PUSH
12139: LD_INT 34
12141: PUSH
12142: LD_INT 8
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PPUSH
12162: CALL_OW 69
12166: ST_TO_ADDR
// if not tmp then
12167: LD_VAR 0 2
12171: NOT
12172: IFFALSE 12176
// exit ;
12174: GO 12236
// target := tmp [ rand ( 1 , tmp ) ] ;
12176: LD_ADDR_VAR 0 3
12180: PUSH
12181: LD_VAR 0 2
12185: PUSH
12186: LD_INT 1
12188: PPUSH
12189: LD_VAR 0 2
12193: PPUSH
12194: CALL_OW 12
12198: ARRAY
12199: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12200: LD_VAR 0 3
12204: PPUSH
12205: CALL_OW 255
12209: PUSH
12210: LD_INT 1
12212: EQUAL
12213: IFFALSE 12224
// CenterNowOnUnits ( target ) ;
12215: LD_VAR 0 3
12219: PPUSH
12220: CALL_OW 87
// SetLives ( target , 0 ) ;
12224: LD_VAR 0 3
12228: PPUSH
12229: LD_INT 0
12231: PPUSH
12232: CALL_OW 234
// end ;
12236: PPOPN 3
12238: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12239: LD_EXP 23
12243: NOT
12244: PUSH
12245: LD_EXP 31
12249: AND
12250: IFFALSE 12772
12252: GO 12254
12254: DISABLE
12255: LD_INT 0
12257: PPUSH
12258: PPUSH
12259: PPUSH
// begin uc_side := 7 ;
12260: LD_ADDR_OWVAR 20
12264: PUSH
12265: LD_INT 7
12267: ST_TO_ADDR
// uc_nation := 1 ;
12268: LD_ADDR_OWVAR 21
12272: PUSH
12273: LD_INT 1
12275: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12276: LD_ADDR_VAR 0 3
12280: PUSH
12281: LD_INT 125
12283: PUSH
12284: LD_INT 163
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: PUSH
12291: LD_INT 185
12293: PUSH
12294: LD_INT 168
12296: PUSH
12297: EMPTY
12298: LIST
12299: LIST
12300: PUSH
12301: LD_INT 111
12303: PUSH
12304: LD_INT 97
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: LIST
12315: PPUSH
12316: CALL 107744 0 1
12320: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12321: LD_ADDR_EXP 91
12325: PUSH
12326: EMPTY
12327: ST_TO_ADDR
// for i = 1 to Difficulty do
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: DOUBLE
12334: LD_INT 1
12336: DEC
12337: ST_TO_ADDR
12338: LD_OWVAR 67
12342: PUSH
12343: FOR_TO
12344: IFFALSE 12502
// begin InitHc ;
12346: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12350: LD_INT 0
12352: PPUSH
12353: LD_INT 8
12355: PPUSH
12356: CALL_OW 381
// un := CreateHuman ;
12360: LD_ADDR_VAR 0 2
12364: PUSH
12365: CALL_OW 44
12369: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12370: LD_VAR 0 2
12374: PPUSH
12375: LD_INT 258
12377: PPUSH
12378: LD_INT 267
12380: PPUSH
12381: LD_INT 4
12383: PPUSH
12384: LD_INT 0
12386: PPUSH
12387: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12391: LD_ADDR_EXP 91
12395: PUSH
12396: LD_EXP 91
12400: PUSH
12401: LD_VAR 0 2
12405: UNION
12406: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12407: LD_VAR 0 2
12411: PPUSH
12412: LD_VAR 0 3
12416: PUSH
12417: LD_VAR 0 1
12421: ARRAY
12422: PUSH
12423: LD_INT 1
12425: ARRAY
12426: PPUSH
12427: LD_VAR 0 3
12431: PUSH
12432: LD_VAR 0 1
12436: ARRAY
12437: PUSH
12438: LD_INT 2
12440: ARRAY
12441: PPUSH
12442: LD_INT 4
12444: PPUSH
12445: LD_INT 1
12447: PPUSH
12448: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12452: LD_VAR 0 2
12456: PPUSH
12457: LD_VAR 0 3
12461: PUSH
12462: LD_VAR 0 1
12466: ARRAY
12467: PUSH
12468: LD_INT 1
12470: ARRAY
12471: PPUSH
12472: LD_VAR 0 3
12476: PUSH
12477: LD_VAR 0 1
12481: ARRAY
12482: PUSH
12483: LD_INT 2
12485: ARRAY
12486: PPUSH
12487: CALL_OW 171
// AddComInvisible ( un ) ;
12491: LD_VAR 0 2
12495: PPUSH
12496: CALL_OW 212
// end ;
12500: GO 12343
12502: POP
12503: POP
// repeat wait ( 0 0$20 ) ;
12504: LD_INT 700
12506: PPUSH
12507: CALL_OW 67
// for i in allianceSpecialForce do
12511: LD_ADDR_VAR 0 1
12515: PUSH
12516: LD_EXP 91
12520: PUSH
12521: FOR_IN
12522: IFFALSE 12757
// begin if IsInvisible ( i ) then
12524: LD_VAR 0 1
12528: PPUSH
12529: CALL_OW 571
12533: IFFALSE 12726
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12535: LD_ADDR_VAR 0 3
12539: PUSH
12540: LD_INT 22
12542: PUSH
12543: LD_INT 1
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 50
12552: PUSH
12553: EMPTY
12554: LIST
12555: PUSH
12556: LD_INT 56
12558: PUSH
12559: EMPTY
12560: LIST
12561: PUSH
12562: LD_INT 91
12564: PUSH
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 25
12572: PUSH
12573: LD_INT 30
12575: PUSH
12576: LD_INT 35
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: PUSH
12584: LD_OWVAR 67
12588: ARRAY
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: LD_INT 25
12600: PUSH
12601: LD_INT 1
12603: PUSH
12604: EMPTY
12605: LIST
12606: LIST
12607: PUSH
12608: LD_INT 25
12610: PUSH
12611: LD_INT 2
12613: PUSH
12614: EMPTY
12615: LIST
12616: LIST
12617: PUSH
12618: LD_INT 25
12620: PUSH
12621: LD_INT 3
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: PUSH
12628: LD_INT 25
12630: PUSH
12631: LD_INT 4
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: PUSH
12638: LD_INT 25
12640: PUSH
12641: LD_INT 5
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: LD_INT 25
12650: PUSH
12651: LD_INT 8
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: LIST
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: PPUSH
12674: CALL_OW 69
12678: ST_TO_ADDR
// if not tmp then
12679: LD_VAR 0 3
12683: NOT
12684: IFFALSE 12688
// continue ;
12686: GO 12521
// if Prob ( 30 * Difficulty ) then
12688: LD_INT 30
12690: PUSH
12691: LD_OWVAR 67
12695: MUL
12696: PPUSH
12697: CALL_OW 13
12701: IFFALSE 12726
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12703: LD_VAR 0 3
12707: PUSH
12708: LD_INT 1
12710: PPUSH
12711: LD_VAR 0 3
12715: PPUSH
12716: CALL_OW 12
12720: ARRAY
12721: PPUSH
12722: CALL 30888 0 1
// end ; if IsDead ( i ) then
12726: LD_VAR 0 1
12730: PPUSH
12731: CALL_OW 301
12735: IFFALSE 12755
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12737: LD_ADDR_EXP 91
12741: PUSH
12742: LD_EXP 91
12746: PUSH
12747: LD_VAR 0 1
12751: DIFF
12752: ST_TO_ADDR
// continue ;
12753: GO 12521
// end ; end ;
12755: GO 12521
12757: POP
12758: POP
// until allianceDestroyed or not allianceSpecialForce ;
12759: LD_EXP 23
12763: PUSH
12764: LD_EXP 91
12768: NOT
12769: OR
12770: IFFALSE 12504
// end ;
12772: PPOPN 3
12774: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12775: LD_EXP 23
12779: NOT
12780: PUSH
12781: LD_EXP 31
12785: AND
12786: IFFALSE 13753
12788: GO 12790
12790: DISABLE
12791: LD_INT 0
12793: PPUSH
12794: PPUSH
12795: PPUSH
12796: PPUSH
// begin enable ;
12797: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12798: LD_INT 22
12800: PUSH
12801: LD_INT 7
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 30
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: NOT
12827: IFFALSE 12831
// exit ;
12829: GO 13753
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12831: LD_ADDR_VAR 0 4
12835: PUSH
12836: LD_INT 22
12838: PUSH
12839: LD_INT 7
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: LD_INT 30
12848: PUSH
12849: LD_INT 34
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PPUSH
12860: CALL_OW 69
12864: ST_TO_ADDR
// if Prob ( 40 ) then
12865: LD_INT 40
12867: PPUSH
12868: CALL_OW 13
12872: IFFALSE 12999
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12874: LD_INT 1
12876: PPUSH
12877: LD_INT 5
12879: PUSH
12880: LD_INT 3
12882: PUSH
12883: LD_INT 2
12885: PUSH
12886: LD_INT 6
12888: PUSH
12889: EMPTY
12890: LIST
12891: LIST
12892: LIST
12893: LIST
12894: PUSH
12895: LD_INT 5
12897: PUSH
12898: LD_INT 3
12900: PUSH
12901: LD_INT 2
12903: PUSH
12904: LD_INT 6
12906: PUSH
12907: EMPTY
12908: LIST
12909: LIST
12910: LIST
12911: LIST
12912: PUSH
12913: LD_INT 5
12915: PUSH
12916: LD_INT 3
12918: PUSH
12919: LD_INT 2
12921: PUSH
12922: LD_INT 6
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: LIST
12929: LIST
12930: PUSH
12931: LD_INT 24
12933: PUSH
12934: LD_INT 3
12936: PUSH
12937: LD_INT 3
12939: PUSH
12940: LD_INT 45
12942: PUSH
12943: EMPTY
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: PUSH
12949: LD_INT 24
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 3
12957: PUSH
12958: LD_INT 47
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: PUSH
12967: LD_INT 24
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 3
12975: PUSH
12976: LD_INT 45
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: PPUSH
12993: CALL 58438 0 2
// end else
12997: GO 13122
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12999: LD_INT 1
13001: PPUSH
13002: LD_INT 24
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 3
13010: PUSH
13011: LD_INT 47
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 24
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 3
13028: PUSH
13029: LD_INT 47
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 5
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 2
13046: PUSH
13047: LD_INT 9
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 5
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 2
13064: PUSH
13065: LD_INT 9
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 1
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: LD_INT 24
13094: PUSH
13095: LD_INT 1
13097: PUSH
13098: LD_INT 3
13100: PUSH
13101: LD_INT 45
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL 58438 0 2
// end ; if Difficulty > 1 then
13122: LD_OWVAR 67
13126: PUSH
13127: LD_INT 1
13129: GREATER
13130: IFFALSE 13160
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13132: LD_INT 1
13134: PPUSH
13135: LD_INT 24
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: LD_INT 3
13143: PUSH
13144: LD_INT 47
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: PUSH
13153: EMPTY
13154: LIST
13155: PPUSH
13156: CALL 58438 0 2
// repeat wait ( 0 0$1 ) ;
13160: LD_INT 35
13162: PPUSH
13163: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13167: LD_INT 1
13169: PPUSH
13170: LD_INT 1
13172: PPUSH
13173: CALL 59856 0 2
13177: PUSH
13178: LD_INT 6
13180: PUSH
13181: LD_INT 7
13183: PUSH
13184: LD_INT 7
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: LIST
13191: PUSH
13192: LD_OWVAR 67
13196: ARRAY
13197: GREATEREQUAL
13198: IFFALSE 13160
// wait ( 0 0$40 ) ;
13200: LD_INT 1400
13202: PPUSH
13203: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13207: LD_ADDR_VAR 0 2
13211: PUSH
13212: LD_INT 1
13214: PPUSH
13215: LD_INT 1
13217: PPUSH
13218: CALL 59856 0 2
13222: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13223: LD_ADDR_EXP 121
13227: PUSH
13228: LD_EXP 121
13232: PPUSH
13233: LD_INT 1
13235: PPUSH
13236: LD_EXP 121
13240: PUSH
13241: LD_INT 1
13243: ARRAY
13244: PUSH
13245: LD_VAR 0 2
13249: DIFF
13250: PPUSH
13251: CALL_OW 1
13255: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13256: LD_ADDR_VAR 0 3
13260: PUSH
13261: LD_INT 0
13263: PPUSH
13264: LD_INT 1
13266: PPUSH
13267: CALL_OW 12
13271: ST_TO_ADDR
// if target then
13272: LD_VAR 0 3
13276: IFFALSE 13442
// begin for i in tmp do
13278: LD_ADDR_VAR 0 1
13282: PUSH
13283: LD_VAR 0 2
13287: PUSH
13288: FOR_IN
13289: IFFALSE 13314
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13291: LD_VAR 0 1
13295: PPUSH
13296: LD_INT 179
13298: PPUSH
13299: LD_INT 209
13301: PPUSH
13302: LD_INT 8
13304: PPUSH
13305: LD_INT 1
13307: PPUSH
13308: CALL_OW 483
13312: GO 13288
13314: POP
13315: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13316: LD_ADDR_VAR 0 2
13320: PUSH
13321: LD_VAR 0 2
13325: PPUSH
13326: LD_INT 24
13328: PUSH
13329: LD_INT 250
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: PPUSH
13336: CALL_OW 72
13340: ST_TO_ADDR
// for i in tmp do
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: LD_VAR 0 2
13350: PUSH
13351: FOR_IN
13352: IFFALSE 13392
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13354: LD_VAR 0 1
13358: PPUSH
13359: LD_INT 179
13361: PPUSH
13362: LD_INT 209
13364: PPUSH
13365: CALL_OW 297
13369: PUSH
13370: LD_INT 9
13372: GREATER
13373: IFFALSE 13390
// ComMoveXY ( i , 179 , 209 ) ;
13375: LD_VAR 0 1
13379: PPUSH
13380: LD_INT 179
13382: PPUSH
13383: LD_INT 209
13385: PPUSH
13386: CALL_OW 111
13390: GO 13351
13392: POP
13393: POP
// wait ( 0 0$1 ) ;
13394: LD_INT 35
13396: PPUSH
13397: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13401: LD_VAR 0 2
13405: PPUSH
13406: LD_INT 92
13408: PUSH
13409: LD_INT 179
13411: PUSH
13412: LD_INT 209
13414: PUSH
13415: LD_INT 9
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: PPUSH
13424: CALL_OW 72
13428: PUSH
13429: LD_VAR 0 2
13433: PUSH
13434: LD_INT 1
13436: MINUS
13437: GREATEREQUAL
13438: IFFALSE 13316
// end else
13440: GO 13604
// begin for i in tmp do
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_VAR 0 2
13451: PUSH
13452: FOR_IN
13453: IFFALSE 13478
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_INT 285
13462: PPUSH
13463: LD_INT 163
13465: PPUSH
13466: LD_INT 8
13468: PPUSH
13469: LD_INT 1
13471: PPUSH
13472: CALL_OW 483
13476: GO 13452
13478: POP
13479: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13480: LD_ADDR_VAR 0 2
13484: PUSH
13485: LD_VAR 0 2
13489: PPUSH
13490: LD_INT 24
13492: PUSH
13493: LD_INT 250
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PPUSH
13500: CALL_OW 72
13504: ST_TO_ADDR
// for i in tmp do
13505: LD_ADDR_VAR 0 1
13509: PUSH
13510: LD_VAR 0 2
13514: PUSH
13515: FOR_IN
13516: IFFALSE 13556
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13518: LD_VAR 0 1
13522: PPUSH
13523: LD_INT 285
13525: PPUSH
13526: LD_INT 163
13528: PPUSH
13529: CALL_OW 297
13533: PUSH
13534: LD_INT 9
13536: GREATER
13537: IFFALSE 13554
// ComMoveXY ( i , 285 , 163 ) ;
13539: LD_VAR 0 1
13543: PPUSH
13544: LD_INT 285
13546: PPUSH
13547: LD_INT 163
13549: PPUSH
13550: CALL_OW 111
13554: GO 13515
13556: POP
13557: POP
// wait ( 0 0$1 ) ;
13558: LD_INT 35
13560: PPUSH
13561: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13565: LD_VAR 0 2
13569: PPUSH
13570: LD_INT 92
13572: PUSH
13573: LD_INT 285
13575: PUSH
13576: LD_INT 163
13578: PUSH
13579: LD_INT 9
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: PPUSH
13588: CALL_OW 72
13592: PUSH
13593: LD_VAR 0 2
13597: PUSH
13598: LD_INT 1
13600: MINUS
13601: GREATEREQUAL
13602: IFFALSE 13480
// end ; repeat wait ( 0 0$1 ) ;
13604: LD_INT 35
13606: PPUSH
13607: CALL_OW 67
// for i in tmp do
13611: LD_ADDR_VAR 0 1
13615: PUSH
13616: LD_VAR 0 2
13620: PUSH
13621: FOR_IN
13622: IFFALSE 13744
// if GetLives ( i ) > 251 then
13624: LD_VAR 0 1
13628: PPUSH
13629: CALL_OW 256
13633: PUSH
13634: LD_INT 251
13636: GREATER
13637: IFFALSE 13726
// begin if GetWeapon ( i ) = ru_time_lapser then
13639: LD_VAR 0 1
13643: PPUSH
13644: CALL_OW 264
13648: PUSH
13649: LD_INT 49
13651: EQUAL
13652: IFFALSE 13690
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13654: LD_VAR 0 1
13658: PPUSH
13659: LD_INT 81
13661: PUSH
13662: LD_INT 7
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: PPUSH
13669: CALL_OW 69
13673: PPUSH
13674: LD_VAR 0 1
13678: PPUSH
13679: CALL_OW 74
13683: PPUSH
13684: CALL_OW 112
13688: GO 13724
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13690: LD_VAR 0 1
13694: PPUSH
13695: LD_INT 81
13697: PUSH
13698: LD_INT 7
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: PPUSH
13705: CALL_OW 69
13709: PPUSH
13710: LD_VAR 0 1
13714: PPUSH
13715: CALL_OW 74
13719: PPUSH
13720: CALL_OW 115
// end else
13724: GO 13742
// tmp := tmp diff i ;
13726: LD_ADDR_VAR 0 2
13730: PUSH
13731: LD_VAR 0 2
13735: PUSH
13736: LD_VAR 0 1
13740: DIFF
13741: ST_TO_ADDR
13742: GO 13621
13744: POP
13745: POP
// until not tmp ;
13746: LD_VAR 0 2
13750: NOT
13751: IFFALSE 13604
// end ; end_of_file
13753: PPOPN 4
13755: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13756: LD_INT 0
13758: PPUSH
13759: PPUSH
13760: PPUSH
13761: PPUSH
// missionStage := 13 ;
13762: LD_ADDR_EXP 15
13766: PUSH
13767: LD_INT 13
13769: ST_TO_ADDR
// uc_side := 2 ;
13770: LD_ADDR_OWVAR 20
13774: PUSH
13775: LD_INT 2
13777: ST_TO_ADDR
// uc_nation := 2 ;
13778: LD_ADDR_OWVAR 21
13782: PUSH
13783: LD_INT 2
13785: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13786: LD_ADDR_EXP 92
13790: PUSH
13791: LD_STRING Omar
13793: PPUSH
13794: CALL_OW 25
13798: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13799: LD_EXP 92
13803: PPUSH
13804: LD_INT 4
13806: PPUSH
13807: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13811: LD_EXP 92
13815: PPUSH
13816: LD_INT 242
13818: PPUSH
13819: LD_INT 75
13821: PPUSH
13822: LD_INT 0
13824: PPUSH
13825: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13829: LD_ADDR_EXP 93
13833: PUSH
13834: LD_STRING Heike
13836: PPUSH
13837: CALL_OW 25
13841: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13842: LD_INT 14
13844: PPUSH
13845: LD_INT 3
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: LD_INT 27
13853: PPUSH
13854: LD_INT 100
13856: PPUSH
13857: CALL 71897 0 5
// veh := CreateVehicle ;
13861: LD_ADDR_VAR 0 3
13865: PUSH
13866: CALL_OW 45
13870: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13871: LD_VAR 0 3
13875: PPUSH
13876: LD_INT 1
13878: PPUSH
13879: CALL_OW 242
// SetDir ( veh , 4 ) ;
13883: LD_VAR 0 3
13887: PPUSH
13888: LD_INT 4
13890: PPUSH
13891: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13895: LD_VAR 0 3
13899: PPUSH
13900: LD_INT 241
13902: PPUSH
13903: LD_INT 72
13905: PPUSH
13906: LD_INT 0
13908: PPUSH
13909: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13913: LD_EXP 93
13917: PPUSH
13918: LD_VAR 0 3
13922: PPUSH
13923: CALL_OW 52
// if KhatamStatus then
13927: LD_EXP 8
13931: IFFALSE 13982
// begin Khatam := NewCharacter ( Khatam ) ;
13933: LD_ADDR_EXP 94
13937: PUSH
13938: LD_STRING Khatam
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13946: LD_EXP 94
13950: PPUSH
13951: LD_INT 245
13953: PPUSH
13954: LD_INT 78
13956: PPUSH
13957: LD_INT 3
13959: PPUSH
13960: LD_INT 0
13962: PPUSH
13963: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13967: LD_EXP 94
13971: PPUSH
13972: LD_INT 4
13974: PPUSH
13975: LD_INT 10
13977: PPUSH
13978: CALL_OW 237
// end ; for i = 1 to Difficulty do
13982: LD_ADDR_VAR 0 2
13986: PUSH
13987: DOUBLE
13988: LD_INT 1
13990: DEC
13991: ST_TO_ADDR
13992: LD_OWVAR 67
13996: PUSH
13997: FOR_TO
13998: IFFALSE 14064
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14000: LD_INT 0
14002: PPUSH
14003: LD_INT 7
14005: PUSH
14006: LD_OWVAR 67
14010: PLUS
14011: PPUSH
14012: CALL_OW 384
// un := CreateHuman ;
14016: LD_ADDR_VAR 0 4
14020: PUSH
14021: CALL_OW 44
14025: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14026: LD_VAR 0 4
14030: PPUSH
14031: LD_INT 28
14033: PUSH
14034: LD_INT 29
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_VAR 0 2
14045: PUSH
14046: LD_INT 2
14048: MOD
14049: PUSH
14050: LD_INT 1
14052: PLUS
14053: ARRAY
14054: PPUSH
14055: LD_INT 0
14057: PPUSH
14058: CALL_OW 49
// end ;
14062: GO 13997
14064: POP
14065: POP
// for i = 1 to 6 do
14066: LD_ADDR_VAR 0 2
14070: PUSH
14071: DOUBLE
14072: LD_INT 1
14074: DEC
14075: ST_TO_ADDR
14076: LD_INT 6
14078: PUSH
14079: FOR_TO
14080: IFFALSE 14125
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14082: LD_INT 0
14084: PPUSH
14085: LD_INT 7
14087: PUSH
14088: LD_OWVAR 67
14092: PLUS
14093: PPUSH
14094: CALL_OW 381
// un := CreateHuman ;
14098: LD_ADDR_VAR 0 4
14102: PUSH
14103: CALL_OW 44
14107: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14108: LD_VAR 0 4
14112: PPUSH
14113: LD_INT 28
14115: PPUSH
14116: LD_INT 0
14118: PPUSH
14119: CALL_OW 49
// end ;
14123: GO 14079
14125: POP
14126: POP
// for i = 1 to 3 do
14127: LD_ADDR_VAR 0 2
14131: PUSH
14132: DOUBLE
14133: LD_INT 1
14135: DEC
14136: ST_TO_ADDR
14137: LD_INT 3
14139: PUSH
14140: FOR_TO
14141: IFFALSE 14189
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14143: LD_INT 0
14145: PPUSH
14146: LD_INT 8
14148: PPUSH
14149: LD_INT 7
14151: PUSH
14152: LD_OWVAR 67
14156: PLUS
14157: PPUSH
14158: CALL_OW 380
// un := CreateHuman ;
14162: LD_ADDR_VAR 0 4
14166: PUSH
14167: CALL_OW 44
14171: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14172: LD_VAR 0 4
14176: PPUSH
14177: LD_INT 28
14179: PPUSH
14180: LD_INT 0
14182: PPUSH
14183: CALL_OW 49
// end ;
14187: GO 14140
14189: POP
14190: POP
// for i = 1 to 3 do
14191: LD_ADDR_VAR 0 2
14195: PUSH
14196: DOUBLE
14197: LD_INT 1
14199: DEC
14200: ST_TO_ADDR
14201: LD_INT 3
14203: PUSH
14204: FOR_TO
14205: IFFALSE 14295
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14207: LD_INT 14
14209: PPUSH
14210: LD_INT 2
14212: PPUSH
14213: LD_INT 1
14215: PPUSH
14216: LD_INT 28
14218: PPUSH
14219: LD_INT 80
14221: PPUSH
14222: CALL 71897 0 5
// veh := CreateVehicle ;
14226: LD_ADDR_VAR 0 3
14230: PUSH
14231: CALL_OW 45
14235: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14236: LD_VAR 0 3
14240: PPUSH
14241: LD_INT 3
14243: PPUSH
14244: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14248: LD_VAR 0 3
14252: PPUSH
14253: LD_INT 29
14255: PPUSH
14256: LD_INT 0
14258: PPUSH
14259: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14263: LD_INT 0
14265: PPUSH
14266: LD_INT 7
14268: PUSH
14269: LD_OWVAR 67
14273: PLUS
14274: PPUSH
14275: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14279: CALL_OW 44
14283: PPUSH
14284: LD_VAR 0 3
14288: PPUSH
14289: CALL_OW 52
// end ;
14293: GO 14204
14295: POP
14296: POP
// for i = 1 to 5 + Difficulty do
14297: LD_ADDR_VAR 0 2
14301: PUSH
14302: DOUBLE
14303: LD_INT 1
14305: DEC
14306: ST_TO_ADDR
14307: LD_INT 5
14309: PUSH
14310: LD_OWVAR 67
14314: PLUS
14315: PUSH
14316: FOR_TO
14317: IFFALSE 14444
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14319: LD_INT 14
14321: PPUSH
14322: LD_INT 1
14324: PPUSH
14325: LD_INT 3
14327: PPUSH
14328: CALL_OW 12
14332: PPUSH
14333: LD_INT 1
14335: PPUSH
14336: LD_INT 28
14338: PUSH
14339: LD_INT 26
14341: PUSH
14342: LD_INT 27
14344: PUSH
14345: LD_INT 25
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: PUSH
14354: LD_VAR 0 2
14358: PUSH
14359: LD_INT 4
14361: MOD
14362: PUSH
14363: LD_INT 1
14365: PLUS
14366: ARRAY
14367: PPUSH
14368: LD_INT 80
14370: PPUSH
14371: CALL 71897 0 5
// veh := CreateVehicle ;
14375: LD_ADDR_VAR 0 3
14379: PUSH
14380: CALL_OW 45
14384: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14385: LD_VAR 0 3
14389: PPUSH
14390: LD_INT 4
14392: PPUSH
14393: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14397: LD_VAR 0 3
14401: PPUSH
14402: LD_INT 28
14404: PPUSH
14405: LD_INT 0
14407: PPUSH
14408: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14412: LD_INT 0
14414: PPUSH
14415: LD_INT 7
14417: PUSH
14418: LD_OWVAR 67
14422: PLUS
14423: PPUSH
14424: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14428: CALL_OW 44
14432: PPUSH
14433: LD_VAR 0 3
14437: PPUSH
14438: CALL_OW 52
// end ;
14442: GO 14316
14444: POP
14445: POP
// for i = 1 to 3 do
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: DOUBLE
14452: LD_INT 1
14454: DEC
14455: ST_TO_ADDR
14456: LD_INT 3
14458: PUSH
14459: FOR_TO
14460: IFFALSE 14520
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14462: LD_INT 14
14464: PPUSH
14465: LD_INT 3
14467: PPUSH
14468: LD_INT 5
14470: PPUSH
14471: LD_INT 29
14473: PPUSH
14474: LD_INT 80
14476: PPUSH
14477: CALL 71897 0 5
// veh := CreateVehicle ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: CALL_OW 45
14490: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14491: LD_VAR 0 3
14495: PPUSH
14496: LD_INT 4
14498: PPUSH
14499: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14503: LD_VAR 0 3
14507: PPUSH
14508: LD_INT 28
14510: PPUSH
14511: LD_INT 0
14513: PPUSH
14514: CALL_OW 49
// end ;
14518: GO 14459
14520: POP
14521: POP
// end ;
14522: LD_VAR 0 1
14526: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14527: LD_INT 22
14529: PUSH
14530: LD_INT 2
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PPUSH
14537: CALL_OW 69
14541: IFFALSE 14841
14543: GO 14545
14545: DISABLE
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
14550: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14551: LD_ADDR_VAR 0 3
14555: PUSH
14556: LD_INT 22
14558: PUSH
14559: LD_INT 2
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PUSH
14566: LD_INT 25
14568: PUSH
14569: LD_INT 4
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: PUSH
14576: EMPTY
14577: LIST
14578: LIST
14579: PPUSH
14580: CALL_OW 69
14584: PUSH
14585: LD_EXP 94
14589: DIFF
14590: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14591: LD_ADDR_VAR 0 2
14595: PUSH
14596: LD_INT 22
14598: PUSH
14599: LD_INT 2
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PPUSH
14606: CALL_OW 69
14610: PUSH
14611: LD_EXP 94
14615: PUSH
14616: LD_VAR 0 3
14620: UNION
14621: DIFF
14622: ST_TO_ADDR
// if Khatam then
14623: LD_EXP 94
14627: IFFALSE 14644
// ComMoveXY ( Khatam , 211 , 92 ) ;
14629: LD_EXP 94
14633: PPUSH
14634: LD_INT 211
14636: PPUSH
14637: LD_INT 92
14639: PPUSH
14640: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14644: LD_INT 197
14646: PPUSH
14647: LD_INT 80
14649: PPUSH
14650: LD_INT 2
14652: PPUSH
14653: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14657: LD_INT 213
14659: PPUSH
14660: LD_INT 90
14662: PPUSH
14663: LD_INT 2
14665: PPUSH
14666: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14670: LD_INT 215
14672: PPUSH
14673: LD_INT 129
14675: PPUSH
14676: LD_INT 2
14678: PPUSH
14679: CALL_OW 441
// if sci then
14683: LD_VAR 0 3
14687: IFFALSE 14708
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14689: LD_VAR 0 3
14693: PUSH
14694: LD_INT 1
14696: ARRAY
14697: PPUSH
14698: LD_INT 197
14700: PPUSH
14701: LD_INT 80
14703: PPUSH
14704: CALL_OW 158
// if sci > 1 then
14708: LD_VAR 0 3
14712: PUSH
14713: LD_INT 1
14715: GREATER
14716: IFFALSE 14737
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14718: LD_VAR 0 3
14722: PUSH
14723: LD_INT 2
14725: ARRAY
14726: PPUSH
14727: LD_INT 213
14729: PPUSH
14730: LD_INT 90
14732: PPUSH
14733: CALL_OW 158
// if sci > 2 then
14737: LD_VAR 0 3
14741: PUSH
14742: LD_INT 2
14744: GREATER
14745: IFFALSE 14766
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14747: LD_VAR 0 3
14751: PUSH
14752: LD_INT 3
14754: ARRAY
14755: PPUSH
14756: LD_INT 215
14758: PPUSH
14759: LD_INT 129
14761: PPUSH
14762: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14766: LD_INT 35
14768: PPUSH
14769: CALL_OW 67
// for i in tmp do
14773: LD_ADDR_VAR 0 1
14777: PUSH
14778: LD_VAR 0 2
14782: PUSH
14783: FOR_IN
14784: IFFALSE 14822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14786: LD_VAR 0 1
14790: PPUSH
14791: LD_INT 81
14793: PUSH
14794: LD_INT 2
14796: PUSH
14797: EMPTY
14798: LIST
14799: LIST
14800: PPUSH
14801: CALL_OW 69
14805: PPUSH
14806: LD_VAR 0 1
14810: PPUSH
14811: CALL_OW 74
14815: PPUSH
14816: CALL_OW 115
14820: GO 14783
14822: POP
14823: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14824: LD_INT 22
14826: PUSH
14827: LD_INT 2
14829: PUSH
14830: EMPTY
14831: LIST
14832: LIST
14833: PPUSH
14834: CALL_OW 69
14838: NOT
14839: IFFALSE 14766
// end ; end_of_file
14841: PPOPN 3
14843: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14844: LD_INT 0
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
14851: PPUSH
14852: PPUSH
14853: PPUSH
14854: PPUSH
// Video ( true ) ;
14855: LD_INT 1
14857: PPUSH
14858: CALL 107624 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14862: LD_ADDR_VAR 0 5
14866: PUSH
14867: LD_INT 7
14869: PPUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL_OW 517
14877: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14878: LD_ADDR_VAR 0 2
14882: PUSH
14883: DOUBLE
14884: LD_INT 1
14886: DEC
14887: ST_TO_ADDR
14888: LD_VAR 0 5
14892: PUSH
14893: LD_INT 1
14895: ARRAY
14896: PUSH
14897: FOR_TO
14898: IFFALSE 14943
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14900: LD_VAR 0 5
14904: PUSH
14905: LD_INT 1
14907: ARRAY
14908: PUSH
14909: LD_VAR 0 2
14913: ARRAY
14914: PPUSH
14915: LD_VAR 0 5
14919: PUSH
14920: LD_INT 2
14922: ARRAY
14923: PUSH
14924: LD_VAR 0 2
14928: ARRAY
14929: PPUSH
14930: LD_INT 1
14932: PPUSH
14933: LD_INT 15
14935: NEG
14936: PPUSH
14937: CALL 107538 0 4
14941: GO 14897
14943: POP
14944: POP
// CenterNowOnUnits ( Powell ) ;
14945: LD_EXP 58
14949: PPUSH
14950: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14954: LD_ADDR_VAR 0 5
14958: PUSH
14959: LD_EXP 56
14963: PUSH
14964: EMPTY
14965: LIST
14966: ST_TO_ADDR
// if GirlNewVeh then
14967: LD_EXP 57
14971: IFFALSE 14989
// tmp := tmp ^ GirlNewVeh ;
14973: LD_ADDR_VAR 0 5
14977: PUSH
14978: LD_VAR 0 5
14982: PUSH
14983: LD_EXP 57
14987: ADD
14988: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14989: LD_VAR 0 5
14993: PPUSH
14994: LD_INT 60
14996: PPUSH
14997: LD_INT 109
14999: PPUSH
15000: CALL_OW 111
// if KappaStatus then
15004: LD_EXP 2
15008: IFFALSE 15060
// begin Say ( JMM , D1nT-JMM-1 ) ;
15010: LD_EXP 39
15014: PPUSH
15015: LD_STRING D1nT-JMM-1
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15022: LD_EXP 58
15026: PPUSH
15027: LD_STRING D1T-Pow-1
15029: PPUSH
15030: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15034: LD_EXP 39
15038: PPUSH
15039: LD_STRING D1T-JMM-2
15041: PPUSH
15042: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15046: LD_EXP 58
15050: PPUSH
15051: LD_STRING D1T-Pow-2
15053: PPUSH
15054: CALL_OW 88
// end else
15058: GO 15266
// if JMMGirlStatus then
15060: LD_EXP 6
15064: IFFALSE 15209
// begin Say ( JMM , D1T-JMM-1 ) ;
15066: LD_EXP 39
15070: PPUSH
15071: LD_STRING D1T-JMM-1
15073: PPUSH
15074: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15078: LD_EXP 58
15082: PPUSH
15083: LD_STRING D1T-Pow-1
15085: PPUSH
15086: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15090: LD_EXP 39
15094: PPUSH
15095: LD_STRING D1T-JMM-3
15097: PPUSH
15098: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15102: LD_EXP 58
15106: PPUSH
15107: LD_STRING D1T-Pow-3
15109: PPUSH
15110: CALL_OW 88
// if JMMGirl then
15114: LD_EXP 7
15118: IFFALSE 15207
// begin case JMMGirl of 1 :
15120: LD_EXP 7
15124: PUSH
15125: LD_INT 1
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15148
15133: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15134: LD_EXP 40
15138: PPUSH
15139: LD_STRING D1T-Joan-3
15141: PPUSH
15142: CALL_OW 88
15146: GO 15195
15148: LD_INT 2
15150: DOUBLE
15151: EQUAL
15152: IFTRUE 15156
15154: GO 15171
15156: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15157: LD_EXP 42
15161: PPUSH
15162: LD_STRING D1T-Lisa-3
15164: PPUSH
15165: CALL_OW 88
15169: GO 15195
15171: LD_INT 3
15173: DOUBLE
15174: EQUAL
15175: IFTRUE 15179
15177: GO 15194
15179: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15180: LD_EXP 54
15184: PPUSH
15185: LD_STRING D1T-Con-3
15187: PPUSH
15188: CALL_OW 88
15192: GO 15195
15194: POP
// Say ( Powell , D1T-Pow-4 ) ;
15195: LD_EXP 58
15199: PPUSH
15200: LD_STRING D1T-Pow-4
15202: PPUSH
15203: CALL_OW 88
// end ; end else
15207: GO 15266
// if not FastEnd then
15209: LD_EXP 11
15213: NOT
15214: IFFALSE 15242
// begin Say ( JMM , D1T-JMM-4 ) ;
15216: LD_EXP 39
15220: PPUSH
15221: LD_STRING D1T-JMM-4
15223: PPUSH
15224: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15228: LD_EXP 58
15232: PPUSH
15233: LD_STRING D1T-Pow-5
15235: PPUSH
15236: CALL_OW 88
// end else
15240: GO 15266
// begin Say ( JMM , D1nT-JMM-1 ) ;
15242: LD_EXP 39
15246: PPUSH
15247: LD_STRING D1nT-JMM-1
15249: PPUSH
15250: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15254: LD_EXP 58
15258: PPUSH
15259: LD_STRING D1nT-Pow-1
15261: PPUSH
15262: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15266: LD_INT 35
15268: PPUSH
15269: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15273: LD_EXP 56
15277: PPUSH
15278: CALL_OW 314
15282: NOT
15283: IFFALSE 15266
// ComExitVehicle ( JMM ) ;
15285: LD_EXP 39
15289: PPUSH
15290: CALL_OW 121
// wait ( 3 ) ;
15294: LD_INT 3
15296: PPUSH
15297: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15301: LD_EXP 39
15305: PPUSH
15306: LD_INT 60
15308: PPUSH
15309: LD_INT 94
15311: PPUSH
15312: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15316: LD_EXP 39
15320: PPUSH
15321: LD_EXP 58
15325: PPUSH
15326: CALL_OW 179
// if Joan then
15330: LD_EXP 40
15334: IFFALSE 15388
// begin ComExitVehicle ( Joan ) ;
15336: LD_EXP 40
15340: PPUSH
15341: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15345: LD_EXP 40
15349: PPUSH
15350: LD_INT 35
15352: PPUSH
15353: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15357: LD_EXP 40
15361: PPUSH
15362: LD_INT 65
15364: PPUSH
15365: LD_INT 104
15367: PPUSH
15368: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15372: LD_EXP 40
15376: PPUSH
15377: LD_EXP 39
15381: PPUSH
15382: CALL_OW 179
// end else
15386: GO 15522
// if Lisa and JMMGirl = 2 then
15388: LD_EXP 42
15392: PUSH
15393: LD_EXP 7
15397: PUSH
15398: LD_INT 2
15400: EQUAL
15401: AND
15402: IFFALSE 15456
// begin ComExitVehicle ( Lisa ) ;
15404: LD_EXP 42
15408: PPUSH
15409: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15413: LD_EXP 42
15417: PPUSH
15418: LD_INT 35
15420: PPUSH
15421: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15425: LD_EXP 42
15429: PPUSH
15430: LD_INT 65
15432: PPUSH
15433: LD_INT 104
15435: PPUSH
15436: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15440: LD_EXP 42
15444: PPUSH
15445: LD_EXP 39
15449: PPUSH
15450: CALL_OW 179
// end else
15454: GO 15522
// if Connie and JMMGirl = 3 then
15456: LD_EXP 54
15460: PUSH
15461: LD_EXP 7
15465: PUSH
15466: LD_INT 3
15468: EQUAL
15469: AND
15470: IFFALSE 15522
// begin ComExitVehicle ( Connie ) ;
15472: LD_EXP 54
15476: PPUSH
15477: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15481: LD_EXP 54
15485: PPUSH
15486: LD_INT 35
15488: PPUSH
15489: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15493: LD_EXP 54
15497: PPUSH
15498: LD_INT 65
15500: PPUSH
15501: LD_INT 104
15503: PPUSH
15504: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15508: LD_EXP 54
15512: PPUSH
15513: LD_EXP 39
15517: PPUSH
15518: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15522: LD_INT 35
15524: PPUSH
15525: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15529: LD_EXP 39
15533: PPUSH
15534: LD_EXP 58
15538: PPUSH
15539: CALL_OW 296
15543: PUSH
15544: LD_INT 6
15546: LESS
15547: IFFALSE 15522
// wait ( 0 0$0.5 ) ;
15549: LD_INT 18
15551: PPUSH
15552: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15556: LD_EXP 39
15560: PPUSH
15561: LD_STRING D1-JMM-1
15563: PPUSH
15564: CALL_OW 88
// async ;
15568: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15569: LD_EXP 58
15573: PPUSH
15574: LD_STRING D1-Pow-1
15576: PPUSH
15577: CALL_OW 88
// if not dialogue_skipped then
15581: LD_OWVAR 59
15585: NOT
15586: IFFALSE 15595
// wait ( 0 0$2 ) ;
15588: LD_INT 70
15590: PPUSH
15591: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15595: LD_INT 170
15597: PPUSH
15598: LD_INT 99
15600: PPUSH
15601: LD_INT 1
15603: PPUSH
15604: LD_INT 6
15606: NEG
15607: PPUSH
15608: CALL 107538 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15612: LD_INT 174
15614: PPUSH
15615: LD_INT 115
15617: PPUSH
15618: LD_INT 1
15620: PPUSH
15621: LD_INT 6
15623: NEG
15624: PPUSH
15625: CALL 107538 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15629: LD_INT 169
15631: PPUSH
15632: LD_INT 71
15634: PPUSH
15635: LD_INT 1
15637: PPUSH
15638: LD_INT 6
15640: NEG
15641: PPUSH
15642: CALL 107538 0 4
// if not dialogue_skipped then
15646: LD_OWVAR 59
15650: NOT
15651: IFFALSE 15670
// begin CenterOnXY ( 170 , 99 ) ;
15653: LD_INT 170
15655: PPUSH
15656: LD_INT 99
15658: PPUSH
15659: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15663: LD_INT 80
15665: PPUSH
15666: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15670: LD_INT 75
15672: PPUSH
15673: LD_INT 53
15675: PPUSH
15676: LD_INT 1
15678: PPUSH
15679: LD_INT 9
15681: NEG
15682: PPUSH
15683: CALL 107538 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15687: LD_INT 54
15689: PPUSH
15690: LD_INT 42
15692: PPUSH
15693: LD_INT 1
15695: PPUSH
15696: LD_INT 9
15698: NEG
15699: PPUSH
15700: CALL 107538 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15704: LD_INT 62
15706: PPUSH
15707: LD_INT 51
15709: PPUSH
15710: LD_INT 1
15712: PPUSH
15713: LD_INT 9
15715: NEG
15716: PPUSH
15717: CALL 107538 0 4
// if not dialogue_skipped then
15721: LD_OWVAR 59
15725: NOT
15726: IFFALSE 15745
// begin CenterOnXY ( 75 , 53 ) ;
15728: LD_INT 75
15730: PPUSH
15731: LD_INT 53
15733: PPUSH
15734: CALL_OW 84
// wait ( 0 0$4 ) ;
15738: LD_INT 140
15740: PPUSH
15741: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15745: LD_EXP 58
15749: PPUSH
15750: CALL_OW 87
// if not dialogue_skipped then
15754: LD_OWVAR 59
15758: NOT
15759: IFFALSE 15768
// wait ( 0 0$2 ) ;
15761: LD_INT 70
15763: PPUSH
15764: CALL_OW 67
// sync ;
15768: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15769: LD_EXP 39
15773: PPUSH
15774: LD_STRING D1-JMM-2
15776: PPUSH
15777: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15781: LD_EXP 58
15785: PPUSH
15786: LD_STRING D1-Pow-2
15788: PPUSH
15789: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15793: LD_EXP 39
15797: PPUSH
15798: LD_STRING D1-JMM-3
15800: PPUSH
15801: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15805: LD_EXP 58
15809: PPUSH
15810: LD_STRING D1-Pow-3
15812: PPUSH
15813: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15817: LD_EXP 39
15821: PPUSH
15822: LD_STRING D1-JMM-4
15824: PPUSH
15825: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15829: LD_EXP 58
15833: PPUSH
15834: LD_STRING D1-Pow-4
15836: PPUSH
15837: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15841: LD_EXP 39
15845: PPUSH
15846: LD_STRING D1-JMM-5
15848: PPUSH
15849: CALL_OW 88
// async ;
15853: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15854: LD_EXP 58
15858: PPUSH
15859: LD_STRING D1-Pow-5
15861: PPUSH
15862: CALL_OW 88
// if not dialogue_skipped then
15866: LD_OWVAR 59
15870: NOT
15871: IFFALSE 15880
// wait ( 0 0$3.6 ) ;
15873: LD_INT 126
15875: PPUSH
15876: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15880: LD_INT 134
15882: PPUSH
15883: LD_INT 210
15885: PPUSH
15886: LD_INT 1
15888: PPUSH
15889: LD_INT 11
15891: NEG
15892: PPUSH
15893: CALL 107538 0 4
// if not dialogue_skipped then
15897: LD_OWVAR 59
15901: NOT
15902: IFFALSE 15921
// begin CenterOnXY ( 134 , 210 ) ;
15904: LD_INT 134
15906: PPUSH
15907: LD_INT 210
15909: PPUSH
15910: CALL_OW 84
// wait ( 0 0$2 ) ;
15914: LD_INT 70
15916: PPUSH
15917: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15921: LD_INT 101
15923: PPUSH
15924: LD_INT 159
15926: PPUSH
15927: LD_INT 1
15929: PPUSH
15930: LD_INT 10
15932: NEG
15933: PPUSH
15934: CALL 107538 0 4
// if not dialogue_skipped then
15938: LD_OWVAR 59
15942: NOT
15943: IFFALSE 15962
// begin CenterOnXY ( 101 , 159 ) ;
15945: LD_INT 101
15947: PPUSH
15948: LD_INT 159
15950: PPUSH
15951: CALL_OW 84
// wait ( 0 0$2 ) ;
15955: LD_INT 70
15957: PPUSH
15958: CALL_OW 67
// end ; sync ;
15962: SYNC
// CenterNowOnUnits ( Powell ) ;
15963: LD_EXP 58
15967: PPUSH
15968: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15972: LD_ADDR_VAR 0 6
15976: PUSH
15977: LD_INT 1
15979: PUSH
15980: LD_INT 2
15982: PUSH
15983: LD_INT 3
15985: PUSH
15986: LD_INT 4
15988: PUSH
15989: LD_INT 5
15991: PUSH
15992: LD_INT 6
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: ST_TO_ADDR
// if not dialogue_skipped then
16003: LD_OWVAR 59
16007: NOT
16008: IFFALSE 16177
// begin game_speed := 4 ;
16010: LD_ADDR_OWVAR 65
16014: PUSH
16015: LD_INT 4
16017: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16018: LD_INT 210
16020: PPUSH
16021: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16025: LD_ADDR_VAR 0 7
16029: PUSH
16030: LD_STRING Q1
16032: PPUSH
16033: LD_VAR 0 6
16037: PPUSH
16038: CALL_OW 98
16042: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16043: LD_ADDR_VAR 0 7
16047: PUSH
16048: LD_STRING Q1
16050: PPUSH
16051: LD_VAR 0 6
16055: PPUSH
16056: CALL_OW 98
16060: ST_TO_ADDR
// options = options diff dec ;
16061: LD_ADDR_VAR 0 6
16065: PUSH
16066: LD_VAR 0 6
16070: PUSH
16071: LD_VAR 0 7
16075: DIFF
16076: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16077: LD_VAR 0 7
16081: PPUSH
16082: LD_VAR 0 6
16086: PPUSH
16087: CALL 17649 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16091: LD_VAR 0 7
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: IN
16106: PUSH
16107: LD_VAR 0 6
16111: PUSH
16112: LD_INT 2
16114: EQUAL
16115: OR
16116: IFFALSE 16043
// if not ( dec in [ 5 , 6 ] ) then
16118: LD_VAR 0 7
16122: PUSH
16123: LD_INT 5
16125: PUSH
16126: LD_INT 6
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: IN
16133: NOT
16134: IFFALSE 16177
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16136: LD_ADDR_VAR 0 7
16140: PUSH
16141: LD_STRING Q1a
16143: PPUSH
16144: LD_INT 1
16146: PUSH
16147: LD_INT 2
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL_OW 98
16158: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16159: LD_VAR 0 7
16163: PUSH
16164: LD_INT 4
16166: PLUS
16167: PPUSH
16168: LD_VAR 0 6
16172: PPUSH
16173: CALL 17649 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16177: LD_INT 81
16179: PPUSH
16180: LD_INT 127
16182: PPUSH
16183: CALL_OW 84
// amount := 5 ;
16187: LD_ADDR_VAR 0 8
16191: PUSH
16192: LD_INT 5
16194: ST_TO_ADDR
// macmilan_squad := [ ] ;
16195: LD_ADDR_VAR 0 9
16199: PUSH
16200: EMPTY
16201: ST_TO_ADDR
// if vip < amount then
16202: LD_EXP 59
16206: PUSH
16207: LD_VAR 0 8
16211: LESS
16212: IFFALSE 16256
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16214: LD_ADDR_VAR 0 5
16218: PUSH
16219: LD_EXP 59
16223: PUSH
16224: LD_INT 22
16226: PUSH
16227: LD_INT 4
16229: PUSH
16230: EMPTY
16231: LIST
16232: LIST
16233: PUSH
16234: LD_INT 21
16236: PUSH
16237: LD_INT 1
16239: PUSH
16240: EMPTY
16241: LIST
16242: LIST
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: PPUSH
16248: CALL_OW 69
16252: UNION
16253: ST_TO_ADDR
16254: GO 16266
// tmp := vip ;
16256: LD_ADDR_VAR 0 5
16260: PUSH
16261: LD_EXP 59
16265: ST_TO_ADDR
// tmp := tmp diff Powell ;
16266: LD_ADDR_VAR 0 5
16270: PUSH
16271: LD_VAR 0 5
16275: PUSH
16276: LD_EXP 58
16280: DIFF
16281: ST_TO_ADDR
// if tmp < amount then
16282: LD_VAR 0 5
16286: PUSH
16287: LD_VAR 0 8
16291: LESS
16292: IFFALSE 16304
// amount := tmp ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_VAR 0 5
16303: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16304: LD_VAR 0 5
16308: PUSH
16309: LD_INT 1
16311: ARRAY
16312: PPUSH
16313: CALL_OW 257
16317: PUSH
16318: LD_INT 2
16320: NONEQUAL
16321: IFFALSE 16383
// begin if IsInUnit ( tmp [ 1 ] ) then
16323: LD_VAR 0 5
16327: PUSH
16328: LD_INT 1
16330: ARRAY
16331: PPUSH
16332: CALL_OW 310
16336: IFFALSE 16351
// ComExitBuilding ( tmp [ 1 ] ) ;
16338: LD_VAR 0 5
16342: PUSH
16343: LD_INT 1
16345: ARRAY
16346: PPUSH
16347: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16351: LD_VAR 0 5
16355: PUSH
16356: LD_INT 1
16358: ARRAY
16359: PPUSH
16360: LD_INT 387
16362: PPUSH
16363: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16367: LD_VAR 0 5
16371: PUSH
16372: LD_INT 1
16374: ARRAY
16375: PPUSH
16376: LD_INT 2
16378: PPUSH
16379: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16383: LD_EXP 39
16387: PPUSH
16388: LD_INT 82
16390: PPUSH
16391: LD_INT 129
16393: PPUSH
16394: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16398: LD_EXP 39
16402: PPUSH
16403: LD_EXP 58
16407: PPUSH
16408: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16412: LD_INT 22
16414: PUSH
16415: LD_INT 1
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PPUSH
16422: CALL_OW 69
16426: PUSH
16427: LD_EXP 39
16431: DIFF
16432: PPUSH
16433: LD_INT 84
16435: PPUSH
16436: LD_INT 128
16438: PPUSH
16439: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16443: LD_INT 22
16445: PUSH
16446: LD_INT 1
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PPUSH
16453: CALL_OW 69
16457: PUSH
16458: LD_EXP 39
16462: DIFF
16463: PPUSH
16464: LD_EXP 39
16468: PPUSH
16469: CALL_OW 179
// for i = 1 to amount do
16473: LD_ADDR_VAR 0 2
16477: PUSH
16478: DOUBLE
16479: LD_INT 1
16481: DEC
16482: ST_TO_ADDR
16483: LD_VAR 0 8
16487: PUSH
16488: FOR_TO
16489: IFFALSE 16657
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16491: LD_ADDR_VAR 0 9
16495: PUSH
16496: LD_VAR 0 9
16500: PUSH
16501: LD_VAR 0 5
16505: PUSH
16506: LD_VAR 0 2
16510: ARRAY
16511: ADD
16512: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16513: LD_VAR 0 5
16517: PUSH
16518: LD_VAR 0 2
16522: ARRAY
16523: PPUSH
16524: CALL_OW 310
16528: IFFALSE 16545
// AddComExitBuilding ( tmp [ i ] ) ;
16530: LD_VAR 0 5
16534: PUSH
16535: LD_VAR 0 2
16539: ARRAY
16540: PPUSH
16541: CALL_OW 182
// if i = 2 and JMMNewVeh then
16545: LD_VAR 0 2
16549: PUSH
16550: LD_INT 2
16552: EQUAL
16553: PUSH
16554: LD_EXP 56
16558: AND
16559: IFFALSE 16617
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 2
16570: ARRAY
16571: PPUSH
16572: LD_EXP 56
16576: PPUSH
16577: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16581: LD_VAR 0 5
16585: PUSH
16586: LD_VAR 0 2
16590: ARRAY
16591: PPUSH
16592: LD_INT 86
16594: PPUSH
16595: LD_INT 133
16597: PPUSH
16598: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16602: LD_VAR 0 5
16606: PUSH
16607: LD_VAR 0 2
16611: ARRAY
16612: PPUSH
16613: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16617: LD_VAR 0 5
16621: PUSH
16622: LD_VAR 0 2
16626: ARRAY
16627: PPUSH
16628: LD_INT 8
16630: PPUSH
16631: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: LD_EXP 39
16650: PPUSH
16651: CALL_OW 179
// end ;
16655: GO 16488
16657: POP
16658: POP
// if GirlNewVeh then
16659: LD_EXP 57
16663: IFFALSE 16677
// SetSide ( GirlNewVeh , 4 ) ;
16665: LD_EXP 57
16669: PPUSH
16670: LD_INT 4
16672: PPUSH
16673: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16677: LD_INT 35
16679: PPUSH
16680: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16684: LD_VAR 0 9
16688: PPUSH
16689: LD_INT 95
16691: PUSH
16692: LD_INT 9
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PPUSH
16699: CALL_OW 72
16703: PUSH
16704: LD_INT 0
16706: EQUAL
16707: PUSH
16708: LD_EXP 39
16712: PPUSH
16713: LD_INT 9
16715: PPUSH
16716: CALL_OW 308
16720: NOT
16721: AND
16722: IFFALSE 16677
// wait ( 0 0$2 ) ;
16724: LD_INT 70
16726: PPUSH
16727: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16731: LD_VAR 0 9
16735: PPUSH
16736: LD_INT 1
16738: PPUSH
16739: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16743: LD_INT 21
16745: PUSH
16746: LD_INT 2
16748: PUSH
16749: EMPTY
16750: LIST
16751: LIST
16752: PUSH
16753: LD_INT 92
16755: PUSH
16756: LD_INT 83
16758: PUSH
16759: LD_INT 130
16761: PUSH
16762: LD_INT 10
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: PUSH
16771: EMPTY
16772: LIST
16773: LIST
16774: PPUSH
16775: CALL_OW 69
16779: PPUSH
16780: LD_INT 1
16782: PPUSH
16783: CALL_OW 235
// Video ( false ) ;
16787: LD_INT 0
16789: PPUSH
16790: CALL 107624 0 1
// ChangeMissionObjectives ( M1 ) ;
16794: LD_STRING M1
16796: PPUSH
16797: CALL_OW 337
// SaveForQuickRestart ;
16801: CALL_OW 22
// missionStart := true ;
16805: LD_ADDR_EXP 13
16809: PUSH
16810: LD_INT 1
16812: ST_TO_ADDR
// missionStage := 2 ;
16813: LD_ADDR_EXP 15
16817: PUSH
16818: LD_INT 2
16820: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16821: LD_INT 105
16823: PPUSH
16824: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16828: LD_ADDR_VAR 0 5
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 4
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 1
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: PUSH
16862: LD_EXP 58
16866: DIFF
16867: ST_TO_ADDR
// if not tmp then
16868: LD_VAR 0 5
16872: NOT
16873: IFFALSE 16888
// tmp := [ Powell ] ;
16875: LD_ADDR_VAR 0 5
16879: PUSH
16880: LD_EXP 58
16884: PUSH
16885: EMPTY
16886: LIST
16887: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16888: LD_ADDR_EXP 102
16892: PUSH
16893: LD_EXP 102
16897: PPUSH
16898: LD_INT 4
16900: PPUSH
16901: LD_INT 22
16903: PUSH
16904: LD_INT 4
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: PUSH
16911: LD_INT 23
16913: PUSH
16914: LD_INT 1
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: PUSH
16921: LD_INT 3
16923: PUSH
16924: LD_INT 21
16926: PUSH
16927: LD_INT 2
16929: PUSH
16930: EMPTY
16931: LIST
16932: LIST
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: LIST
16942: PPUSH
16943: CALL_OW 69
16947: PUSH
16948: LD_EXP 58
16952: DIFF
16953: PPUSH
16954: CALL_OW 1
16958: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16959: LD_ADDR_VAR 0 4
16963: PUSH
16964: LD_INT 22
16966: PUSH
16967: LD_INT 4
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: PUSH
16974: LD_INT 34
16976: PUSH
16977: LD_INT 12
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PPUSH
16988: CALL_OW 69
16992: PUSH
16993: LD_INT 1
16995: ARRAY
16996: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16997: LD_VAR 0 5
17001: PUSH
17002: LD_INT 1
17004: ARRAY
17005: PPUSH
17006: CALL_OW 310
17010: IFFALSE 17025
// ComExitBuilding ( tmp [ 1 ] ) ;
17012: LD_VAR 0 5
17016: PUSH
17017: LD_INT 1
17019: ARRAY
17020: PPUSH
17021: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17025: LD_VAR 0 5
17029: PUSH
17030: LD_INT 1
17032: ARRAY
17033: PPUSH
17034: LD_VAR 0 4
17038: PPUSH
17039: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17043: LD_VAR 0 5
17047: PUSH
17048: LD_INT 1
17050: ARRAY
17051: PPUSH
17052: LD_INT 80
17054: PPUSH
17055: LD_INT 136
17057: PPUSH
17058: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17062: LD_VAR 0 5
17066: PUSH
17067: LD_INT 1
17069: ARRAY
17070: PPUSH
17071: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17075: LD_VAR 0 5
17079: PUSH
17080: LD_INT 1
17082: ARRAY
17083: PPUSH
17084: LD_INT 59
17086: PPUSH
17087: LD_INT 112
17089: PPUSH
17090: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17094: LD_VAR 0 5
17098: PUSH
17099: LD_INT 1
17101: ARRAY
17102: PPUSH
17103: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17107: LD_EXP 40
17111: PUSH
17112: LD_EXP 40
17116: PPUSH
17117: CALL_OW 255
17121: PUSH
17122: LD_INT 1
17124: EQUAL
17125: AND
17126: IFFALSE 17152
// begin Say ( Joan , D3W-Joan-1 ) ;
17128: LD_EXP 40
17132: PPUSH
17133: LD_STRING D3W-Joan-1
17135: PPUSH
17136: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17140: LD_EXP 39
17144: PPUSH
17145: LD_STRING D3W-JMM-1
17147: PPUSH
17148: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17152: LD_EXP 42
17156: PUSH
17157: LD_EXP 42
17161: PPUSH
17162: CALL_OW 255
17166: PUSH
17167: LD_INT 1
17169: EQUAL
17170: AND
17171: PUSH
17172: LD_EXP 42
17176: PUSH
17177: LD_EXP 59
17181: IN
17182: NOT
17183: AND
17184: IFFALSE 17210
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17186: LD_EXP 42
17190: PPUSH
17191: LD_STRING D3W-Lisa-1
17193: PPUSH
17194: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17198: LD_EXP 39
17202: PPUSH
17203: LD_STRING D3W-JMM-1
17205: PPUSH
17206: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17210: LD_EXP 54
17214: PUSH
17215: LD_EXP 54
17219: PPUSH
17220: CALL_OW 255
17224: PUSH
17225: LD_INT 1
17227: EQUAL
17228: AND
17229: IFFALSE 17255
// begin Say ( Connie , D3W-Con-1 ) ;
17231: LD_EXP 54
17235: PPUSH
17236: LD_STRING D3W-Con-1
17238: PPUSH
17239: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17243: LD_EXP 39
17247: PPUSH
17248: LD_STRING D3W-JMM-1
17250: PPUSH
17251: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17255: LD_EXP 42
17259: PUSH
17260: LD_EXP 59
17264: IN
17265: PUSH
17266: LD_EXP 42
17270: PPUSH
17271: CALL_OW 255
17275: PUSH
17276: LD_INT 1
17278: EQUAL
17279: AND
17280: IFFALSE 17296
// Say ( Lisa , D3nW-Lisa-1 ) else
17282: LD_EXP 42
17286: PPUSH
17287: LD_STRING D3nW-Lisa-1
17289: PPUSH
17290: CALL_OW 88
17294: GO 17540
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17296: LD_EXP 45
17300: PUSH
17301: LD_EXP 59
17305: IN
17306: PUSH
17307: LD_EXP 45
17311: PPUSH
17312: CALL_OW 255
17316: PUSH
17317: LD_INT 1
17319: EQUAL
17320: AND
17321: IFFALSE 17337
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17323: LD_EXP 45
17327: PPUSH
17328: LD_STRING D3nW-Cyrus-1
17330: PPUSH
17331: CALL_OW 88
17335: GO 17540
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17337: LD_EXP 44
17341: PUSH
17342: LD_EXP 59
17346: IN
17347: PUSH
17348: LD_EXP 44
17352: PPUSH
17353: CALL_OW 255
17357: PUSH
17358: LD_INT 1
17360: EQUAL
17361: AND
17362: IFFALSE 17378
// Say ( Bobby , D3nW-Bobby-1 ) else
17364: LD_EXP 44
17368: PPUSH
17369: LD_STRING D3nW-Bobby-1
17371: PPUSH
17372: CALL_OW 88
17376: GO 17540
// if Gary in vip and GetSide ( Gary ) = 1 then
17378: LD_EXP 51
17382: PUSH
17383: LD_EXP 59
17387: IN
17388: PUSH
17389: LD_EXP 51
17393: PPUSH
17394: CALL_OW 255
17398: PUSH
17399: LD_INT 1
17401: EQUAL
17402: AND
17403: IFFALSE 17419
// Say ( Gary , D3nW-Gary-1 ) else
17405: LD_EXP 51
17409: PPUSH
17410: LD_STRING D3nW-Gary-1
17412: PPUSH
17413: CALL_OW 88
17417: GO 17540
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17419: LD_EXP 43
17423: PUSH
17424: LD_EXP 59
17428: IN
17429: PUSH
17430: LD_EXP 43
17434: PPUSH
17435: CALL_OW 255
17439: PUSH
17440: LD_INT 1
17442: EQUAL
17443: AND
17444: IFFALSE 17460
// Say ( Donaldson , D3nW-Don-1 ) else
17446: LD_EXP 43
17450: PPUSH
17451: LD_STRING D3nW-Don-1
17453: PPUSH
17454: CALL_OW 88
17458: GO 17540
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17460: LD_EXP 50
17464: PUSH
17465: LD_EXP 59
17469: IN
17470: PUSH
17471: LD_EXP 50
17475: PPUSH
17476: CALL_OW 255
17480: PUSH
17481: LD_INT 1
17483: EQUAL
17484: AND
17485: IFFALSE 17501
// Say ( Cornel , D3nW-Corn-1 ) else
17487: LD_EXP 50
17491: PPUSH
17492: LD_STRING D3nW-Corn-1
17494: PPUSH
17495: CALL_OW 88
17499: GO 17540
// if Frank in vip and GetSide ( Frank ) = 1 then
17501: LD_EXP 52
17505: PUSH
17506: LD_EXP 59
17510: IN
17511: PUSH
17512: LD_EXP 52
17516: PPUSH
17517: CALL_OW 255
17521: PUSH
17522: LD_INT 1
17524: EQUAL
17525: AND
17526: IFFALSE 17540
// Say ( Frank , D3nW-Frank-1 ) ;
17528: LD_EXP 52
17532: PPUSH
17533: LD_STRING D3nW-Frank-1
17535: PPUSH
17536: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17540: LD_EXP 59
17544: PPUSH
17545: LD_INT 22
17547: PUSH
17548: LD_INT 1
17550: PUSH
17551: EMPTY
17552: LIST
17553: LIST
17554: PPUSH
17555: CALL_OW 72
17559: IFFALSE 17585
// begin Say ( JMM , D3nW-JMM-1 ) ;
17561: LD_EXP 39
17565: PPUSH
17566: LD_STRING D3nW-JMM-1
17568: PPUSH
17569: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17573: LD_EXP 39
17577: PPUSH
17578: LD_STRING D3nW-JMM-1a
17580: PPUSH
17581: CALL_OW 88
// end ; t := 0 0$00 ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_INT 0
17592: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17593: LD_INT 35
17595: PPUSH
17596: CALL_OW 67
// t := t + 0 0$1 ;
17600: LD_ADDR_VAR 0 3
17604: PUSH
17605: LD_VAR 0 3
17609: PUSH
17610: LD_INT 35
17612: PLUS
17613: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17614: LD_INT 59
17616: PPUSH
17617: LD_INT 112
17619: PPUSH
17620: CALL_OW 428
17624: PUSH
17625: LD_VAR 0 3
17629: PUSH
17630: LD_INT 2100
17632: GREATER
17633: OR
17634: IFFALSE 17593
// activeAttacks := true ;
17636: LD_ADDR_EXP 16
17640: PUSH
17641: LD_INT 1
17643: ST_TO_ADDR
// end ;
17644: LD_VAR 0 1
17648: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17649: LD_INT 0
17651: PPUSH
// case question of 1 :
17652: LD_VAR 0 1
17656: PUSH
17657: LD_INT 1
17659: DOUBLE
17660: EQUAL
17661: IFTRUE 17665
17663: GO 17716
17665: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17666: LD_EXP 39
17670: PPUSH
17671: LD_STRING D2Mot-JMM-1
17673: PPUSH
17674: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17678: LD_EXP 58
17682: PPUSH
17683: LD_STRING D2Mot-Pow-1
17685: PPUSH
17686: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17690: LD_EXP 39
17694: PPUSH
17695: LD_STRING D2Mot-JMM-2
17697: PPUSH
17698: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17702: LD_EXP 58
17706: PPUSH
17707: LD_STRING D2Mot-Pow-2
17709: PPUSH
17710: CALL_OW 88
// end ; 2 :
17714: GO 18067
17716: LD_INT 2
17718: DOUBLE
17719: EQUAL
17720: IFTRUE 17724
17722: GO 17800
17724: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17725: LD_EXP 39
17729: PPUSH
17730: LD_STRING D2Rus-JMM-1
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17737: LD_EXP 58
17741: PPUSH
17742: LD_STRING D2Rus-Pow-1
17744: PPUSH
17745: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17749: LD_EXP 39
17753: PPUSH
17754: LD_STRING D2Rus-JMM-2
17756: PPUSH
17757: CALL_OW 88
// if not ( 3 in list_of_q ) then
17761: LD_INT 3
17763: PUSH
17764: LD_VAR 0 2
17768: IN
17769: NOT
17770: IFFALSE 17786
// Say ( Powell , D2Rus-Pow-2 ) else
17772: LD_EXP 58
17776: PPUSH
17777: LD_STRING D2Rus-Pow-2
17779: PPUSH
17780: CALL_OW 88
17784: GO 17798
// Say ( Powell , D2Rus-Pow-2a ) ;
17786: LD_EXP 58
17790: PPUSH
17791: LD_STRING D2Rus-Pow-2a
17793: PPUSH
17794: CALL_OW 88
// end ; 3 :
17798: GO 18067
17800: LD_INT 3
17802: DOUBLE
17803: EQUAL
17804: IFTRUE 17808
17806: GO 17893
17808: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17809: LD_EXP 39
17813: PPUSH
17814: LD_STRING D2Leg-JMM-1
17816: PPUSH
17817: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17821: LD_EXP 58
17825: PPUSH
17826: LD_STRING D2Leg-Pow-1
17828: PPUSH
17829: CALL_OW 88
// if 2 in list_of_q then
17833: LD_INT 2
17835: PUSH
17836: LD_VAR 0 2
17840: IN
17841: IFFALSE 17867
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17843: LD_EXP 39
17847: PPUSH
17848: LD_STRING D2Leg-JMM-2
17850: PPUSH
17851: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17855: LD_EXP 58
17859: PPUSH
17860: LD_STRING D2Leg-Pow-2
17862: PPUSH
17863: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17867: LD_EXP 39
17871: PPUSH
17872: LD_STRING D2Leg-JMM-3
17874: PPUSH
17875: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Leg-Pow-3
17886: PPUSH
17887: CALL_OW 88
// end ; 4 :
17891: GO 18067
17893: LD_INT 4
17895: DOUBLE
17896: EQUAL
17897: IFTRUE 17901
17899: GO 17976
17901: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17902: LD_EXP 39
17906: PPUSH
17907: LD_STRING D2Ar-JMM-1
17909: PPUSH
17910: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17914: LD_EXP 58
17918: PPUSH
17919: LD_STRING D2Ar-Pow-1
17921: PPUSH
17922: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17926: LD_EXP 39
17930: PPUSH
17931: LD_STRING D2Ar-JMM-2
17933: PPUSH
17934: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17938: LD_EXP 58
17942: PPUSH
17943: LD_STRING D2Ar-Pow-2
17945: PPUSH
17946: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Ar-JMM-3
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Ar-Pow-3
17969: PPUSH
17970: CALL_OW 88
// end ; 5 :
17974: GO 18067
17976: LD_INT 5
17978: DOUBLE
17979: EQUAL
17980: IFTRUE 17984
17982: GO 17999
17984: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17985: LD_EXP 39
17989: PPUSH
17990: LD_STRING D2Conf-JMM-1
17992: PPUSH
17993: CALL_OW 88
17997: GO 18067
17999: LD_INT 6
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18066
18007: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18008: LD_EXP 39
18012: PPUSH
18013: LD_STRING D2Com-JMM-1
18015: PPUSH
18016: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18020: LD_EXP 58
18024: PPUSH
18025: LD_STRING D2Com-Pow-1
18027: PPUSH
18028: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18032: LD_EXP 39
18036: PPUSH
18037: LD_STRING D2Com-JMM-2
18039: PPUSH
18040: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18044: LD_EXP 58
18048: PPUSH
18049: LD_STRING D2Com-Pow-2
18051: PPUSH
18052: CALL_OW 88
// powellAngerQuery := true ;
18056: LD_ADDR_EXP 36
18060: PUSH
18061: LD_INT 1
18063: ST_TO_ADDR
// end ; end ;
18064: GO 18067
18066: POP
// end ;
18067: LD_VAR 0 3
18071: RET
// every 0 0$5 trigger missionStart do var tmp ;
18072: LD_EXP 13
18076: IFFALSE 18359
18078: GO 18080
18080: DISABLE
18081: LD_INT 0
18083: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18084: LD_INT 35
18086: PPUSH
18087: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18091: LD_INT 14
18093: PPUSH
18094: LD_INT 22
18096: PUSH
18097: LD_INT 1
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 70
18108: PUSH
18109: LD_EXP 15
18113: PUSH
18114: LD_INT 2
18116: PUSH
18117: LD_INT 3
18119: PUSH
18120: LD_INT 4
18122: PUSH
18123: LD_INT 5
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: LIST
18130: LIST
18131: IN
18132: AND
18133: IFFALSE 18349
// begin powellAnger := powellAnger + 1 ;
18135: LD_ADDR_EXP 17
18139: PUSH
18140: LD_EXP 17
18144: PUSH
18145: LD_INT 1
18147: PLUS
18148: ST_TO_ADDR
// Video ( true ) ;
18149: LD_INT 1
18151: PPUSH
18152: CALL 107624 0 1
// CenterNowOnUnits ( tmp ) ;
18156: LD_VAR 0 1
18160: PPUSH
18161: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18165: LD_INT 14
18167: PPUSH
18168: LD_INT 22
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: PPUSH
18178: CALL_OW 70
18182: PPUSH
18183: LD_INT 86
18185: PPUSH
18186: LD_INT 133
18188: PPUSH
18189: CALL_OW 111
// async ;
18193: ASYNC
// case powellAnger of 1 :
18194: LD_EXP 17
18198: PUSH
18199: LD_INT 1
18201: DOUBLE
18202: EQUAL
18203: IFTRUE 18207
18205: GO 18222
18207: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18208: LD_EXP 58
18212: PPUSH
18213: LD_STRING DBack1-Pow-1
18215: PPUSH
18216: CALL_OW 88
18220: GO 18269
18222: LD_INT 2
18224: DOUBLE
18225: EQUAL
18226: IFTRUE 18230
18228: GO 18245
18230: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18231: LD_EXP 58
18235: PPUSH
18236: LD_STRING DBack2-Pow-1
18238: PPUSH
18239: CALL_OW 88
18243: GO 18269
18245: LD_INT 3
18247: DOUBLE
18248: EQUAL
18249: IFTRUE 18253
18251: GO 18268
18253: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18254: LD_EXP 58
18258: PPUSH
18259: LD_STRING DBack3-Pow-1
18261: PPUSH
18262: CALL_OW 88
18266: GO 18269
18268: POP
// sync ;
18269: SYNC
// repeat wait ( 0 0$1 ) ;
18270: LD_INT 35
18272: PPUSH
18273: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18277: LD_INT 14
18279: PPUSH
18280: LD_INT 22
18282: PUSH
18283: LD_INT 1
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: PPUSH
18290: CALL_OW 70
18294: PPUSH
18295: LD_INT 86
18297: PPUSH
18298: LD_INT 133
18300: PPUSH
18301: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18305: LD_INT 14
18307: PPUSH
18308: LD_INT 22
18310: PUSH
18311: LD_INT 1
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: PPUSH
18318: CALL_OW 70
18322: NOT
18323: IFFALSE 18270
// if powellAnger >= 3 then
18325: LD_EXP 17
18329: PUSH
18330: LD_INT 3
18332: GREATEREQUAL
18333: IFFALSE 18342
// YouLost ( Dismissed ) ;
18335: LD_STRING Dismissed
18337: PPUSH
18338: CALL_OW 104
// Video ( false ) ;
18342: LD_INT 0
18344: PPUSH
18345: CALL 107624 0 1
// end ; until missionStage > 5 ;
18349: LD_EXP 15
18353: PUSH
18354: LD_INT 5
18356: GREATER
18357: IFFALSE 18084
// end ;
18359: PPOPN 1
18361: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18362: LD_EXP 13
18366: PUSH
18367: LD_INT 22
18369: PUSH
18370: LD_INT 4
18372: PUSH
18373: EMPTY
18374: LIST
18375: LIST
18376: PUSH
18377: LD_INT 21
18379: PUSH
18380: LD_INT 2
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: PPUSH
18391: CALL_OW 69
18395: PUSH
18396: LD_INT 4
18398: GREATEREQUAL
18399: AND
18400: PUSH
18401: LD_EXP 15
18405: PUSH
18406: LD_INT 2
18408: EQUAL
18409: AND
18410: IFFALSE 20233
18412: GO 18414
18414: DISABLE
18415: LD_INT 0
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
18421: PPUSH
18422: PPUSH
18423: PPUSH
18424: PPUSH
// begin missionStage := 3 ;
18425: LD_ADDR_EXP 15
18429: PUSH
18430: LD_INT 3
18432: ST_TO_ADDR
// retreat := false ;
18433: LD_ADDR_VAR 0 4
18437: PUSH
18438: LD_INT 0
18440: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18441: LD_ADDR_VAR 0 5
18445: PUSH
18446: LD_INT 22
18448: PUSH
18449: LD_INT 4
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: PUSH
18456: LD_INT 30
18458: PUSH
18459: LD_INT 4
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PUSH
18466: EMPTY
18467: LIST
18468: LIST
18469: PPUSH
18470: CALL_OW 69
18474: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18475: LD_ADDR_VAR 0 6
18479: PUSH
18480: LD_INT 22
18482: PUSH
18483: LD_INT 4
18485: PUSH
18486: EMPTY
18487: LIST
18488: LIST
18489: PUSH
18490: LD_INT 30
18492: PUSH
18493: LD_INT 5
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: PPUSH
18504: CALL_OW 69
18508: ST_TO_ADDR
// if not bar then
18509: LD_VAR 0 6
18513: NOT
18514: IFFALSE 18567
// begin repeat wait ( 0 0$1 ) ;
18516: LD_INT 35
18518: PPUSH
18519: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18523: LD_INT 22
18525: PUSH
18526: LD_INT 4
18528: PUSH
18529: EMPTY
18530: LIST
18531: LIST
18532: PUSH
18533: LD_INT 3
18535: PUSH
18536: LD_INT 57
18538: PUSH
18539: EMPTY
18540: LIST
18541: PUSH
18542: EMPTY
18543: LIST
18544: LIST
18545: PUSH
18546: LD_INT 30
18548: PUSH
18549: LD_INT 5
18551: PUSH
18552: EMPTY
18553: LIST
18554: LIST
18555: PUSH
18556: EMPTY
18557: LIST
18558: LIST
18559: LIST
18560: PPUSH
18561: CALL_OW 69
18565: IFFALSE 18516
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18567: LD_ADDR_VAR 0 6
18571: PUSH
18572: LD_INT 22
18574: PUSH
18575: LD_INT 4
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: PUSH
18582: LD_INT 30
18584: PUSH
18585: LD_INT 5
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PUSH
18592: EMPTY
18593: LIST
18594: LIST
18595: PPUSH
18596: CALL_OW 69
18600: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18601: LD_INT 35
18603: PPUSH
18604: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18608: LD_EXP 121
18612: PUSH
18613: LD_INT 4
18615: ARRAY
18616: PUSH
18617: LD_INT 4
18619: GREATEREQUAL
18620: IFFALSE 18601
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18622: LD_ADDR_VAR 0 2
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 2
18639: PUSH
18640: LD_INT 25
18642: PUSH
18643: LD_INT 1
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: LD_INT 25
18652: PUSH
18653: LD_INT 2
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PUSH
18660: LD_INT 25
18662: PUSH
18663: LD_INT 3
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: LD_INT 25
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 25
18682: PUSH
18683: LD_INT 5
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: PUSH
18690: EMPTY
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PPUSH
18702: CALL_OW 69
18706: PUSH
18707: LD_EXP 58
18711: PUSH
18712: LD_EXP 59
18716: ADD
18717: DIFF
18718: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18719: LD_ADDR_VAR 0 3
18723: PUSH
18724: LD_VAR 0 2
18728: PPUSH
18729: LD_INT 26
18731: PUSH
18732: LD_INT 1
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PPUSH
18739: CALL_OW 72
18743: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_VAR 0 2
18753: PUSH
18754: LD_VAR 0 3
18758: DIFF
18759: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18760: LD_ADDR_VAR 0 2
18764: PUSH
18765: LD_VAR 0 2
18769: PPUSH
18770: LD_INT 1
18772: PPUSH
18773: CALL 106277 0 2
18777: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18778: LD_ADDR_VAR 0 3
18782: PUSH
18783: LD_VAR 0 3
18787: PPUSH
18788: LD_INT 1
18790: PPUSH
18791: CALL 106277 0 2
18795: ST_TO_ADDR
// for i = 1 to 4 do
18796: LD_ADDR_VAR 0 1
18800: PUSH
18801: DOUBLE
18802: LD_INT 1
18804: DEC
18805: ST_TO_ADDR
18806: LD_INT 4
18808: PUSH
18809: FOR_TO
18810: IFFALSE 18976
// begin if tmp2 then
18812: LD_VAR 0 3
18816: IFFALSE 18897
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18818: LD_ADDR_EXP 18
18822: PUSH
18823: LD_EXP 18
18827: PPUSH
18828: LD_INT 1
18830: PPUSH
18831: LD_EXP 18
18835: PUSH
18836: LD_INT 1
18838: ARRAY
18839: PUSH
18840: LD_VAR 0 3
18844: PUSH
18845: LD_VAR 0 3
18849: ARRAY
18850: ADD
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18857: LD_VAR 0 3
18861: PUSH
18862: LD_VAR 0 3
18866: ARRAY
18867: PPUSH
18868: LD_INT 1
18870: PPUSH
18871: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18875: LD_ADDR_VAR 0 3
18879: PUSH
18880: LD_VAR 0 3
18884: PPUSH
18885: LD_VAR 0 3
18889: PPUSH
18890: CALL_OW 3
18894: ST_TO_ADDR
// end else
18895: GO 18974
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18897: LD_ADDR_EXP 18
18901: PUSH
18902: LD_EXP 18
18906: PPUSH
18907: LD_INT 1
18909: PPUSH
18910: LD_EXP 18
18914: PUSH
18915: LD_INT 1
18917: ARRAY
18918: PUSH
18919: LD_VAR 0 2
18923: PUSH
18924: LD_VAR 0 2
18928: ARRAY
18929: ADD
18930: PPUSH
18931: CALL_OW 1
18935: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18936: LD_VAR 0 2
18940: PUSH
18941: LD_VAR 0 2
18945: ARRAY
18946: PPUSH
18947: LD_INT 1
18949: PPUSH
18950: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18954: LD_ADDR_VAR 0 2
18958: PUSH
18959: LD_VAR 0 2
18963: PPUSH
18964: LD_VAR 0 2
18968: PPUSH
18969: CALL_OW 3
18973: ST_TO_ADDR
// end ; end ;
18974: GO 18809
18976: POP
18977: POP
// if tmp2 then
18978: LD_VAR 0 3
18982: IFFALSE 19000
// tmp := tmp union tmp2 ;
18984: LD_ADDR_VAR 0 2
18988: PUSH
18989: LD_VAR 0 2
18993: PUSH
18994: LD_VAR 0 3
18998: UNION
18999: ST_TO_ADDR
// for i = 1 to 4 do
19000: LD_ADDR_VAR 0 1
19004: PUSH
19005: DOUBLE
19006: LD_INT 1
19008: DEC
19009: ST_TO_ADDR
19010: LD_INT 4
19012: PUSH
19013: FOR_TO
19014: IFFALSE 19063
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19016: LD_ADDR_EXP 18
19020: PUSH
19021: LD_EXP 18
19025: PPUSH
19026: LD_INT 2
19028: PPUSH
19029: LD_EXP 18
19033: PUSH
19034: LD_INT 2
19036: ARRAY
19037: PUSH
19038: LD_VAR 0 2
19042: PUSH
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 1
19052: MINUS
19053: ARRAY
19054: ADD
19055: PPUSH
19056: CALL_OW 1
19060: ST_TO_ADDR
19061: GO 19013
19063: POP
19064: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19065: LD_ADDR_EXP 102
19069: PUSH
19070: LD_EXP 102
19074: PPUSH
19075: LD_INT 4
19077: PPUSH
19078: LD_EXP 102
19082: PUSH
19083: LD_INT 4
19085: ARRAY
19086: PUSH
19087: LD_EXP 18
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: DIFF
19096: PPUSH
19097: CALL_OW 1
19101: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19102: LD_VAR 0 5
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: CALL_OW 313
19115: IFFALSE 19170
// begin for i in UnitsInside ( arm [ 1 ] ) do
19117: LD_ADDR_VAR 0 1
19121: PUSH
19122: LD_VAR 0 5
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: CALL_OW 313
19135: PUSH
19136: FOR_IN
19137: IFFALSE 19168
// begin ComExitBuilding ( i ) ;
19139: LD_VAR 0 1
19143: PPUSH
19144: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19148: LD_VAR 0 1
19152: PPUSH
19153: LD_VAR 0 6
19157: PUSH
19158: LD_INT 1
19160: ARRAY
19161: PPUSH
19162: CALL_OW 180
// end ;
19166: GO 19136
19168: POP
19169: POP
// end ; wait ( 0 0$3 ) ;
19170: LD_INT 105
19172: PPUSH
19173: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19177: LD_ADDR_VAR 0 1
19181: PUSH
19182: LD_EXP 18
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: PUSH
19191: FOR_IN
19192: IFFALSE 19299
// begin if IsInUnit ( i ) then
19194: LD_VAR 0 1
19198: PPUSH
19199: CALL_OW 310
19203: IFFALSE 19214
// ComExitBuilding ( i ) ;
19205: LD_VAR 0 1
19209: PPUSH
19210: CALL_OW 122
// if GetClass ( i ) <> 1 then
19214: LD_VAR 0 1
19218: PPUSH
19219: CALL_OW 257
19223: PUSH
19224: LD_INT 1
19226: NONEQUAL
19227: IFFALSE 19268
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19229: LD_VAR 0 1
19233: PPUSH
19234: LD_VAR 0 5
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: PPUSH
19243: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19247: LD_VAR 0 1
19251: PPUSH
19252: LD_INT 1
19254: PPUSH
19255: CALL_OW 183
// AddComExitBuilding ( i ) ;
19259: LD_VAR 0 1
19263: PPUSH
19264: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19268: LD_VAR 0 1
19272: PPUSH
19273: LD_INT 60
19275: PPUSH
19276: LD_INT 94
19278: PPUSH
19279: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19283: LD_VAR 0 1
19287: PPUSH
19288: LD_EXP 58
19292: PPUSH
19293: CALL_OW 179
// end ;
19297: GO 19191
19299: POP
19300: POP
// wait ( 0 0$15 ) ;
19301: LD_INT 525
19303: PPUSH
19304: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19308: LD_EXP 58
19312: PPUSH
19313: LD_STRING D4-Pow-1
19315: PPUSH
19316: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19320: LD_ADDR_VAR 0 2
19324: PUSH
19325: LD_EXP 18
19329: PUSH
19330: LD_INT 1
19332: ARRAY
19333: PPUSH
19334: LD_INT 26
19336: PUSH
19337: LD_INT 1
19339: PUSH
19340: EMPTY
19341: LIST
19342: LIST
19343: PPUSH
19344: CALL_OW 72
19348: ST_TO_ADDR
// if tmp then
19349: LD_VAR 0 2
19353: IFFALSE 19371
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19355: LD_VAR 0 2
19359: PUSH
19360: LD_INT 1
19362: ARRAY
19363: PPUSH
19364: LD_STRING D4-Sol1-1
19366: PPUSH
19367: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19371: LD_EXP 58
19375: PPUSH
19376: LD_STRING D4-Pow-2
19378: PPUSH
19379: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19383: LD_ADDR_VAR 0 1
19387: PUSH
19388: DOUBLE
19389: LD_INT 1
19391: DEC
19392: ST_TO_ADDR
19393: LD_EXP 18
19397: PUSH
19398: LD_INT 1
19400: ARRAY
19401: PUSH
19402: FOR_TO
19403: IFFALSE 19496
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19405: LD_EXP 18
19409: PUSH
19410: LD_INT 1
19412: ARRAY
19413: PUSH
19414: LD_VAR 0 1
19418: ARRAY
19419: PPUSH
19420: LD_EXP 121
19424: PUSH
19425: LD_INT 4
19427: ARRAY
19428: PUSH
19429: LD_INT 1
19431: ARRAY
19432: PPUSH
19433: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19437: LD_ADDR_EXP 121
19441: PUSH
19442: LD_EXP 121
19446: PPUSH
19447: LD_INT 4
19449: PPUSH
19450: LD_EXP 121
19454: PUSH
19455: LD_INT 4
19457: ARRAY
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 3
19466: PPUSH
19467: CALL_OW 1
19471: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19472: LD_INT 8
19474: PPUSH
19475: LD_EXP 18
19479: PUSH
19480: LD_INT 1
19482: ARRAY
19483: PUSH
19484: LD_VAR 0 1
19488: ARRAY
19489: PPUSH
19490: CALL_OW 471
// end ;
19494: GO 19402
19496: POP
19497: POP
// repeat wait ( 0 0$1 ) ;
19498: LD_INT 35
19500: PPUSH
19501: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19505: LD_EXP 18
19509: PUSH
19510: LD_INT 1
19512: ARRAY
19513: PPUSH
19514: LD_INT 55
19516: PUSH
19517: EMPTY
19518: LIST
19519: PPUSH
19520: CALL_OW 72
19524: PUSH
19525: LD_INT 4
19527: GREATEREQUAL
19528: IFFALSE 19498
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19530: LD_EXP 18
19534: PUSH
19535: LD_INT 1
19537: ARRAY
19538: PPUSH
19539: LD_INT 69
19541: PPUSH
19542: LD_INT 94
19544: PPUSH
19545: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19549: LD_EXP 18
19553: PUSH
19554: LD_INT 1
19556: ARRAY
19557: PPUSH
19558: LD_INT 82
19560: PPUSH
19561: LD_INT 83
19563: PPUSH
19564: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19568: LD_EXP 18
19572: PUSH
19573: LD_INT 1
19575: ARRAY
19576: PPUSH
19577: LD_INT 77
19579: PPUSH
19580: LD_INT 69
19582: PPUSH
19583: CALL_OW 174
// repeat wait ( 3 ) ;
19587: LD_INT 3
19589: PPUSH
19590: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19594: LD_ADDR_VAR 0 1
19598: PUSH
19599: LD_EXP 18
19603: PUSH
19604: LD_INT 1
19606: ARRAY
19607: PUSH
19608: FOR_IN
19609: IFFALSE 19745
// begin if GetLives ( i ) < 990 then
19611: LD_VAR 0 1
19615: PPUSH
19616: CALL_OW 256
19620: PUSH
19621: LD_INT 990
19623: LESS
19624: IFFALSE 19638
// SetLives ( i , 1000 ) ;
19626: LD_VAR 0 1
19630: PPUSH
19631: LD_INT 1000
19633: PPUSH
19634: CALL_OW 234
// if not IsInUnit ( i ) then
19638: LD_VAR 0 1
19642: PPUSH
19643: CALL_OW 310
19647: NOT
19648: IFFALSE 19743
// begin if not HasTask ( i ) then
19650: LD_VAR 0 1
19654: PPUSH
19655: CALL_OW 314
19659: NOT
19660: IFFALSE 19677
// ComMoveXY ( i , 64 , 93 ) ;
19662: LD_VAR 0 1
19666: PPUSH
19667: LD_INT 64
19669: PPUSH
19670: LD_INT 93
19672: PPUSH
19673: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19677: LD_VAR 0 4
19681: NOT
19682: PUSH
19683: LD_VAR 0 1
19687: PPUSH
19688: CALL_OW 258
19692: PUSH
19693: LD_INT 1
19695: EQUAL
19696: AND
19697: IFFALSE 19743
// begin retreat := true ;
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: LD_INT 1
19706: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19707: LD_VAR 0 1
19711: PPUSH
19712: LD_INT 2
19714: PPUSH
19715: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19719: LD_VAR 0 1
19723: PPUSH
19724: LD_STRING D4a-Sol1-1
19726: PPUSH
19727: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19731: LD_EXP 58
19735: PPUSH
19736: LD_STRING D4a-Pow-1
19738: PPUSH
19739: CALL_OW 88
// end ; end ; end ;
19743: GO 19608
19745: POP
19746: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19747: LD_EXP 18
19751: PUSH
19752: LD_INT 1
19754: ARRAY
19755: PPUSH
19756: LD_INT 95
19758: PUSH
19759: LD_INT 9
19761: PUSH
19762: EMPTY
19763: LIST
19764: LIST
19765: PUSH
19766: LD_INT 3
19768: PUSH
19769: LD_INT 55
19771: PUSH
19772: EMPTY
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: PUSH
19779: EMPTY
19780: LIST
19781: LIST
19782: PPUSH
19783: CALL_OW 72
19787: PUSH
19788: LD_INT 4
19790: GREATEREQUAL
19791: IFFALSE 19587
// for i in powellSquadAttack [ 1 ] do
19793: LD_ADDR_VAR 0 1
19797: PUSH
19798: LD_EXP 18
19802: PUSH
19803: LD_INT 1
19805: ARRAY
19806: PUSH
19807: FOR_IN
19808: IFFALSE 19944
// begin if GetTag ( i ) = 2 then
19810: LD_VAR 0 1
19814: PPUSH
19815: CALL_OW 110
19819: PUSH
19820: LD_INT 2
19822: EQUAL
19823: IFFALSE 19885
// begin ComMoveXY ( i , 60 , 94 ) ;
19825: LD_VAR 0 1
19829: PPUSH
19830: LD_INT 60
19832: PPUSH
19833: LD_INT 94
19835: PPUSH
19836: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19840: LD_VAR 0 1
19844: PPUSH
19845: LD_EXP 58
19849: PPUSH
19850: CALL_OW 179
// wait ( 0 0$3 ) ;
19854: LD_INT 105
19856: PPUSH
19857: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19861: LD_VAR 0 1
19865: PPUSH
19866: LD_STRING D4a-Sol1-2
19868: PPUSH
19869: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19873: LD_EXP 58
19877: PPUSH
19878: LD_STRING D4a-Pow-2
19880: PPUSH
19881: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19885: LD_VAR 0 1
19889: PPUSH
19890: LD_INT 0
19892: PPUSH
19893: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19897: LD_ADDR_EXP 102
19901: PUSH
19902: LD_EXP 102
19906: PPUSH
19907: LD_INT 4
19909: PPUSH
19910: LD_EXP 102
19914: PUSH
19915: LD_INT 4
19917: ARRAY
19918: PUSH
19919: LD_VAR 0 1
19923: UNION
19924: PPUSH
19925: CALL_OW 1
19929: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19930: LD_INT 8
19932: PPUSH
19933: LD_VAR 0 1
19937: PPUSH
19938: CALL_OW 472
// end ;
19942: GO 19807
19944: POP
19945: POP
// wait ( 4 4$00 ) ;
19946: LD_INT 8400
19948: PPUSH
19949: CALL_OW 67
// uc_side := 6 ;
19953: LD_ADDR_OWVAR 20
19957: PUSH
19958: LD_INT 6
19960: ST_TO_ADDR
// uc_nation := 3 ;
19961: LD_ADDR_OWVAR 21
19965: PUSH
19966: LD_INT 3
19968: ST_TO_ADDR
// ru := [ ] ;
19969: LD_ADDR_VAR 0 7
19973: PUSH
19974: EMPTY
19975: ST_TO_ADDR
// for i = 1 to 4 do
19976: LD_ADDR_VAR 0 1
19980: PUSH
19981: DOUBLE
19982: LD_INT 1
19984: DEC
19985: ST_TO_ADDR
19986: LD_INT 4
19988: PUSH
19989: FOR_TO
19990: IFFALSE 20091
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19992: LD_INT 22
19994: PPUSH
19995: LD_INT 1
19997: PPUSH
19998: LD_INT 3
20000: PPUSH
20001: LD_INT 43
20003: PUSH
20004: LD_INT 44
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: PUSH
20011: LD_INT 1
20013: PPUSH
20014: LD_INT 2
20016: PPUSH
20017: CALL_OW 12
20021: ARRAY
20022: PPUSH
20023: LD_INT 89
20025: PPUSH
20026: CALL 71897 0 5
// un := CreateVehicle ;
20030: LD_ADDR_VAR 0 8
20034: PUSH
20035: CALL_OW 45
20039: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20040: LD_VAR 0 8
20044: PPUSH
20045: LD_INT 4
20047: PPUSH
20048: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20052: LD_VAR 0 8
20056: PPUSH
20057: LD_INT 136
20059: PPUSH
20060: LD_INT 90
20062: PPUSH
20063: LD_INT 8
20065: PPUSH
20066: LD_INT 0
20068: PPUSH
20069: CALL_OW 50
// ru := ru ^ un ;
20073: LD_ADDR_VAR 0 7
20077: PUSH
20078: LD_VAR 0 7
20082: PUSH
20083: LD_VAR 0 8
20087: ADD
20088: ST_TO_ADDR
// end ;
20089: GO 19989
20091: POP
20092: POP
// if ru then
20093: LD_VAR 0 7
20097: IFFALSE 20114
// ComAgressiveMove ( ru , 80 , 92 ) ;
20099: LD_VAR 0 7
20103: PPUSH
20104: LD_INT 80
20106: PPUSH
20107: LD_INT 92
20109: PPUSH
20110: CALL_OW 114
// wait ( 8 8$00 ) ;
20114: LD_INT 16800
20116: PPUSH
20117: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20121: LD_INT 4
20123: PPUSH
20124: LD_INT 3
20126: PUSH
20127: LD_INT 1
20129: PUSH
20130: LD_INT 1
20132: PUSH
20133: LD_INT 5
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: LIST
20140: LIST
20141: PUSH
20142: LD_INT 4
20144: PUSH
20145: LD_INT 1
20147: PUSH
20148: LD_INT 1
20150: PUSH
20151: LD_INT 6
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 4
20162: PUSH
20163: LD_INT 1
20165: PUSH
20166: LD_INT 1
20168: PUSH
20169: LD_INT 7
20171: PUSH
20172: EMPTY
20173: LIST
20174: LIST
20175: LIST
20176: LIST
20177: PUSH
20178: LD_INT 3
20180: PUSH
20181: LD_INT 1
20183: PUSH
20184: LD_INT 1
20186: PUSH
20187: LD_INT 7
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: PUSH
20196: LD_INT 3
20198: PUSH
20199: LD_INT 1
20201: PUSH
20202: LD_INT 1
20204: PUSH
20205: LD_INT 5
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: LIST
20212: LIST
20213: PUSH
20214: EMPTY
20215: LIST
20216: LIST
20217: LIST
20218: LIST
20219: LIST
20220: PPUSH
20221: CALL 58390 0 2
// missionStage := 4 ;
20225: LD_ADDR_EXP 15
20229: PUSH
20230: LD_INT 4
20232: ST_TO_ADDR
// end ;
20233: PPOPN 8
20235: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20236: LD_EXP 15
20240: PUSH
20241: LD_INT 4
20243: EQUAL
20244: PUSH
20245: LD_INT 22
20247: PUSH
20248: LD_INT 4
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PUSH
20255: LD_INT 21
20257: PUSH
20258: LD_INT 2
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: PPUSH
20269: CALL_OW 69
20273: PUSH
20274: LD_INT 5
20276: GREATEREQUAL
20277: AND
20278: IFFALSE 24383
20280: GO 20282
20282: DISABLE
20283: LD_INT 0
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
20295: PPUSH
20296: PPUSH
20297: PPUSH
// begin missionStage := 5 ;
20298: LD_ADDR_EXP 15
20302: PUSH
20303: LD_INT 5
20305: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20306: LD_ADDR_VAR 0 10
20310: PUSH
20311: LD_INT 22
20313: PUSH
20314: LD_INT 4
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: PUSH
20321: LD_INT 2
20323: PUSH
20324: LD_INT 30
20326: PUSH
20327: LD_INT 4
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: PUSH
20334: LD_INT 30
20336: PUSH
20337: LD_INT 5
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: LIST
20348: PUSH
20349: EMPTY
20350: LIST
20351: LIST
20352: PPUSH
20353: CALL_OW 69
20357: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20358: LD_ADDR_VAR 0 6
20362: PUSH
20363: LD_INT 22
20365: PUSH
20366: LD_INT 4
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: PUSH
20373: LD_INT 21
20375: PUSH
20376: LD_INT 1
20378: PUSH
20379: EMPTY
20380: LIST
20381: LIST
20382: PUSH
20383: LD_INT 3
20385: PUSH
20386: LD_INT 25
20388: PUSH
20389: LD_INT 16
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: PUSH
20400: LD_INT 3
20402: PUSH
20403: LD_INT 25
20405: PUSH
20406: LD_INT 12
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: PPUSH
20423: CALL_OW 69
20427: PUSH
20428: LD_EXP 58
20432: DIFF
20433: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20434: LD_ADDR_VAR 0 9
20438: PUSH
20439: LD_INT 22
20441: PUSH
20442: LD_INT 4
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: PUSH
20449: LD_INT 30
20451: PUSH
20452: LD_INT 3
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PPUSH
20463: CALL_OW 69
20467: PUSH
20468: LD_INT 1
20470: ARRAY
20471: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20472: LD_INT 35
20474: PPUSH
20475: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20479: LD_EXP 121
20483: PUSH
20484: LD_INT 4
20486: ARRAY
20487: PUSH
20488: LD_INT 5
20490: GREATEREQUAL
20491: PUSH
20492: LD_EXP 121
20496: PUSH
20497: LD_INT 4
20499: ARRAY
20500: PPUSH
20501: LD_INT 58
20503: PUSH
20504: EMPTY
20505: LIST
20506: PPUSH
20507: CALL_OW 72
20511: PUSH
20512: LD_INT 5
20514: GREATEREQUAL
20515: AND
20516: IFFALSE 20472
// powellAllowRetreat := false ;
20518: LD_ADDR_EXP 19
20522: PUSH
20523: LD_INT 0
20525: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20526: LD_INT 700
20528: PPUSH
20529: CALL_OW 67
// activeAttacks := false ;
20533: LD_ADDR_EXP 16
20537: PUSH
20538: LD_INT 0
20540: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20541: LD_INT 35
20543: PPUSH
20544: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20548: LD_INT 22
20550: PUSH
20551: LD_INT 6
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PPUSH
20558: CALL_OW 69
20562: PUSH
20563: LD_INT 0
20565: EQUAL
20566: IFFALSE 20541
// tmp := mc_vehicles [ 4 ] ;
20568: LD_ADDR_VAR 0 3
20572: PUSH
20573: LD_EXP 121
20577: PUSH
20578: LD_INT 4
20580: ARRAY
20581: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20582: LD_ADDR_VAR 0 1
20586: PUSH
20587: DOUBLE
20588: LD_INT 1
20590: DEC
20591: ST_TO_ADDR
20592: LD_EXP 18
20596: PUSH
20597: FOR_TO
20598: IFFALSE 20859
// begin for j in powellSquadAttack [ i ] do
20600: LD_ADDR_VAR 0 2
20604: PUSH
20605: LD_EXP 18
20609: PUSH
20610: LD_VAR 0 1
20614: ARRAY
20615: PUSH
20616: FOR_IN
20617: IFFALSE 20855
// begin forces := forces diff j ;
20619: LD_ADDR_VAR 0 6
20623: PUSH
20624: LD_VAR 0 6
20628: PUSH
20629: LD_VAR 0 2
20633: DIFF
20634: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20635: LD_VAR 0 2
20639: PPUSH
20640: LD_INT 1
20642: PPUSH
20643: CALL_OW 109
// wait ( 0 0$2 ) ;
20647: LD_INT 70
20649: PPUSH
20650: CALL_OW 67
// if IsInUnit ( j ) then
20654: LD_VAR 0 2
20658: PPUSH
20659: CALL_OW 310
20663: IFFALSE 20674
// ComExitBuilding ( j ) ;
20665: LD_VAR 0 2
20669: PPUSH
20670: CALL_OW 122
// if GetClass ( j ) <> 1 then
20674: LD_VAR 0 2
20678: PPUSH
20679: CALL_OW 257
20683: PUSH
20684: LD_INT 1
20686: NONEQUAL
20687: IFFALSE 20767
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20689: LD_VAR 0 10
20693: PUSH
20694: LD_INT 1
20696: ARRAY
20697: PPUSH
20698: CALL_OW 313
20702: PUSH
20703: LD_INT 5
20705: GREATEREQUAL
20706: IFFALSE 20728
// AddComEnterUnit ( j , arm [ 2 ] ) else
20708: LD_VAR 0 2
20712: PPUSH
20713: LD_VAR 0 10
20717: PUSH
20718: LD_INT 2
20720: ARRAY
20721: PPUSH
20722: CALL_OW 180
20726: GO 20746
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20728: LD_VAR 0 2
20732: PPUSH
20733: LD_VAR 0 10
20737: PUSH
20738: LD_INT 1
20740: ARRAY
20741: PPUSH
20742: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_INT 1
20753: PPUSH
20754: CALL_OW 183
// AddComExitBuilding ( j ) ;
20758: LD_VAR 0 2
20762: PPUSH
20763: CALL_OW 182
// end ; if i = 2 then
20767: LD_VAR 0 1
20771: PUSH
20772: LD_INT 2
20774: EQUAL
20775: IFFALSE 20792
// AddComMoveXY ( j , 61 , 93 ) ;
20777: LD_VAR 0 2
20781: PPUSH
20782: LD_INT 61
20784: PPUSH
20785: LD_INT 93
20787: PPUSH
20788: CALL_OW 171
// if i = 1 then
20792: LD_VAR 0 1
20796: PUSH
20797: LD_INT 1
20799: EQUAL
20800: IFFALSE 20853
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20802: LD_VAR 0 2
20806: PPUSH
20807: LD_VAR 0 3
20811: PUSH
20812: LD_INT 1
20814: ARRAY
20815: PPUSH
20816: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20820: LD_ADDR_VAR 0 3
20824: PUSH
20825: LD_VAR 0 3
20829: PPUSH
20830: LD_INT 1
20832: PPUSH
20833: CALL_OW 3
20837: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20838: LD_VAR 0 2
20842: PPUSH
20843: LD_INT 69
20845: PPUSH
20846: LD_INT 94
20848: PPUSH
20849: CALL_OW 171
// end ; end ;
20853: GO 20616
20855: POP
20856: POP
// end ;
20857: GO 20597
20859: POP
20860: POP
// wait ( 0 0$55 ) ;
20861: LD_INT 1925
20863: PPUSH
20864: CALL_OW 67
// MC_Kill ( 4 ) ;
20868: LD_INT 4
20870: PPUSH
20871: CALL 34978 0 1
// tmp := UnitsInside ( fac ) ;
20875: LD_ADDR_VAR 0 3
20879: PUSH
20880: LD_VAR 0 9
20884: PPUSH
20885: CALL_OW 313
20889: ST_TO_ADDR
// if tmp then
20890: LD_VAR 0 3
20894: IFFALSE 21015
// for i in tmp do
20896: LD_ADDR_VAR 0 1
20900: PUSH
20901: LD_VAR 0 3
20905: PUSH
20906: FOR_IN
20907: IFFALSE 21013
// begin ComExitBuilding ( i ) ;
20909: LD_VAR 0 1
20913: PPUSH
20914: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20918: LD_VAR 0 10
20922: PUSH
20923: LD_INT 2
20925: ARRAY
20926: PPUSH
20927: CALL_OW 313
20931: PUSH
20932: LD_INT 6
20934: LESS
20935: IFFALSE 20957
// AddComEnterUnit ( i , arm [ 2 ] ) else
20937: LD_VAR 0 1
20941: PPUSH
20942: LD_VAR 0 10
20946: PUSH
20947: LD_INT 2
20949: ARRAY
20950: PPUSH
20951: CALL_OW 180
20955: GO 21011
// if UnitsInside ( arm [ 1 ] ) < 6 then
20957: LD_VAR 0 10
20961: PUSH
20962: LD_INT 1
20964: ARRAY
20965: PPUSH
20966: CALL_OW 313
20970: PUSH
20971: LD_INT 6
20973: LESS
20974: IFFALSE 20996
// AddComEnterUnit ( i , arm [ 1 ] ) else
20976: LD_VAR 0 1
20980: PPUSH
20981: LD_VAR 0 10
20985: PUSH
20986: LD_INT 1
20988: ARRAY
20989: PPUSH
20990: CALL_OW 180
20994: GO 21011
// AddComMoveXY ( i , 37 , 68 ) ;
20996: LD_VAR 0 1
21000: PPUSH
21001: LD_INT 37
21003: PPUSH
21004: LD_INT 68
21006: PPUSH
21007: CALL_OW 171
// end ;
21011: GO 20906
21013: POP
21014: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21015: LD_ADDR_VAR 0 11
21019: PUSH
21020: LD_VAR 0 6
21024: PPUSH
21025: LD_INT 26
21027: PUSH
21028: LD_INT 1
21030: PUSH
21031: EMPTY
21032: LIST
21033: LIST
21034: PPUSH
21035: CALL_OW 72
21039: PUSH
21040: LD_EXP 59
21044: DIFF
21045: ST_TO_ADDR
// if not speaker then
21046: LD_VAR 0 11
21050: NOT
21051: IFFALSE 21078
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21053: LD_ADDR_VAR 0 11
21057: PUSH
21058: LD_VAR 0 6
21062: PPUSH
21063: LD_INT 26
21065: PUSH
21066: LD_INT 1
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: PPUSH
21073: CALL_OW 72
21077: ST_TO_ADDR
// if speaker then
21078: LD_VAR 0 11
21082: IFFALSE 21098
// speaker := speaker [ 1 ] ;
21084: LD_ADDR_VAR 0 11
21088: PUSH
21089: LD_VAR 0 11
21093: PUSH
21094: LD_INT 1
21096: ARRAY
21097: ST_TO_ADDR
// Video ( true ) ;
21098: LD_INT 1
21100: PPUSH
21101: CALL 107624 0 1
// CenterNowOnUnits ( Powell ) ;
21105: LD_EXP 58
21109: PPUSH
21110: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21114: LD_ADDR_VAR 0 3
21118: PUSH
21119: LD_VAR 0 6
21123: PPUSH
21124: LD_INT 3
21126: PUSH
21127: LD_INT 25
21129: PUSH
21130: LD_INT 1
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PUSH
21137: EMPTY
21138: LIST
21139: LIST
21140: PPUSH
21141: CALL_OW 72
21145: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21146: LD_ADDR_VAR 0 12
21150: PUSH
21151: LD_INT 22
21153: PUSH
21154: LD_INT 4
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PUSH
21161: LD_INT 30
21163: PUSH
21164: LD_INT 32
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: PUSH
21171: LD_INT 58
21173: PUSH
21174: EMPTY
21175: LIST
21176: PUSH
21177: EMPTY
21178: LIST
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 69
21186: ST_TO_ADDR
// for i = 1 to 6 do
21187: LD_ADDR_VAR 0 1
21191: PUSH
21192: DOUBLE
21193: LD_INT 1
21195: DEC
21196: ST_TO_ADDR
21197: LD_INT 6
21199: PUSH
21200: FOR_TO
21201: IFFALSE 21342
// begin if IsInUnit ( tmp [ i ] ) then
21203: LD_VAR 0 3
21207: PUSH
21208: LD_VAR 0 1
21212: ARRAY
21213: PPUSH
21214: CALL_OW 310
21218: IFFALSE 21235
// ComExitBuilding ( tmp [ i ] ) ;
21220: LD_VAR 0 3
21224: PUSH
21225: LD_VAR 0 1
21229: ARRAY
21230: PPUSH
21231: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21235: LD_VAR 0 3
21239: PUSH
21240: LD_VAR 0 1
21244: ARRAY
21245: PPUSH
21246: LD_VAR 0 10
21250: PUSH
21251: LD_INT 1
21253: ARRAY
21254: PPUSH
21255: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21259: LD_VAR 0 3
21263: PUSH
21264: LD_VAR 0 1
21268: ARRAY
21269: PPUSH
21270: LD_INT 1
21272: PPUSH
21273: CALL_OW 183
// if emp_towers then
21277: LD_VAR 0 12
21281: IFFALSE 21340
// begin AddComExitBuilding ( tmp [ i ] ) ;
21283: LD_VAR 0 3
21287: PUSH
21288: LD_VAR 0 1
21292: ARRAY
21293: PPUSH
21294: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21298: LD_VAR 0 3
21302: PUSH
21303: LD_VAR 0 1
21307: ARRAY
21308: PPUSH
21309: LD_VAR 0 12
21313: PUSH
21314: LD_INT 1
21316: ARRAY
21317: PPUSH
21318: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21322: LD_ADDR_VAR 0 12
21326: PUSH
21327: LD_VAR 0 12
21331: PPUSH
21332: LD_INT 1
21334: PPUSH
21335: CALL_OW 3
21339: ST_TO_ADDR
// end ; end ;
21340: GO 21200
21342: POP
21343: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21344: LD_ADDR_VAR 0 3
21348: PUSH
21349: LD_EXP 18
21353: PUSH
21354: LD_INT 1
21356: ARRAY
21357: PUSH
21358: LD_EXP 18
21362: PUSH
21363: LD_INT 2
21365: ARRAY
21366: ADD
21367: PPUSH
21368: LD_INT 26
21370: PUSH
21371: LD_INT 1
21373: PUSH
21374: EMPTY
21375: LIST
21376: LIST
21377: PPUSH
21378: CALL_OW 72
21382: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21383: LD_ADDR_VAR 0 1
21387: PUSH
21388: LD_EXP 18
21392: PUSH
21393: LD_INT 2
21395: ARRAY
21396: PUSH
21397: FOR_IN
21398: IFFALSE 21416
// ComTurnUnit ( i , Powell ) ;
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_EXP 58
21409: PPUSH
21410: CALL_OW 119
21414: GO 21397
21416: POP
21417: POP
// Say ( Powell , D5-Pow-1 ) ;
21418: LD_EXP 58
21422: PPUSH
21423: LD_STRING D5-Pow-1
21425: PPUSH
21426: CALL_OW 88
// if tmp then
21430: LD_VAR 0 3
21434: IFFALSE 21452
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21436: LD_VAR 0 3
21440: PUSH
21441: LD_INT 1
21443: ARRAY
21444: PPUSH
21445: LD_STRING D5-Sol2-1
21447: PPUSH
21448: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21452: LD_EXP 58
21456: PPUSH
21457: LD_STRING D5-Pow-2
21459: PPUSH
21460: CALL_OW 88
// if tmp > 1 then
21464: LD_VAR 0 3
21468: PUSH
21469: LD_INT 1
21471: GREATER
21472: IFFALSE 21490
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21474: LD_VAR 0 3
21478: PUSH
21479: LD_INT 2
21481: ARRAY
21482: PPUSH
21483: LD_STRING D5-Sol2-2
21485: PPUSH
21486: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21490: LD_EXP 58
21494: PPUSH
21495: LD_STRING D5-Pow-3
21497: PPUSH
21498: CALL_OW 88
// wait ( 0 0$1 ) ;
21502: LD_INT 35
21504: PPUSH
21505: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21509: LD_ADDR_VAR 0 3
21513: PUSH
21514: LD_EXP 18
21518: PUSH
21519: LD_INT 1
21521: ARRAY
21522: PUSH
21523: LD_EXP 18
21527: PUSH
21528: LD_INT 2
21530: ARRAY
21531: UNION
21532: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21533: LD_VAR 0 3
21537: PPUSH
21538: LD_INT 80
21540: PPUSH
21541: LD_INT 67
21543: PPUSH
21544: CALL_OW 114
// wait ( 0 0$2 ) ;
21548: LD_INT 70
21550: PPUSH
21551: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21555: LD_INT 79
21557: PPUSH
21558: LD_INT 72
21560: PPUSH
21561: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21565: LD_INT 35
21567: PPUSH
21568: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21572: LD_VAR 0 3
21576: PPUSH
21577: LD_INT 3
21579: PUSH
21580: LD_INT 24
21582: PUSH
21583: LD_INT 1000
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: PPUSH
21594: CALL_OW 72
21598: IFFALSE 21565
// Say ( Powell , D5a-Pow-1 ) ;
21600: LD_EXP 58
21604: PPUSH
21605: LD_STRING D5a-Pow-1
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5a-Pow-1a
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21624: LD_INT 10
21626: PPUSH
21627: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21631: LD_EXP 58
21635: PPUSH
21636: LD_STRING D5a-Pow-1b
21638: PPUSH
21639: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21643: LD_EXP 58
21647: PPUSH
21648: LD_STRING D5a-Pow-1c
21650: PPUSH
21651: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21655: LD_EXP 58
21659: PPUSH
21660: LD_STRING D5a-Pow-1d
21662: PPUSH
21663: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21667: LD_INT 35
21669: PPUSH
21670: CALL_OW 67
// if not HasTask ( tmp ) then
21674: LD_VAR 0 3
21678: PPUSH
21679: CALL_OW 314
21683: NOT
21684: IFFALSE 21701
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21686: LD_VAR 0 3
21690: PPUSH
21691: LD_INT 80
21693: PPUSH
21694: LD_INT 67
21696: PPUSH
21697: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21701: LD_VAR 0 3
21705: PPUSH
21706: LD_INT 24
21708: PUSH
21709: LD_INT 1
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: NOT
21721: IFFALSE 21667
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21723: LD_ADDR_VAR 0 3
21727: PUSH
21728: LD_INT 22
21730: PUSH
21731: LD_INT 4
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: PUSH
21738: LD_INT 92
21740: PUSH
21741: LD_INT 60
21743: PUSH
21744: LD_INT 93
21746: PUSH
21747: LD_INT 10
21749: PUSH
21750: EMPTY
21751: LIST
21752: LIST
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 3
21758: PUSH
21759: LD_INT 54
21761: PUSH
21762: EMPTY
21763: LIST
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: EMPTY
21770: LIST
21771: LIST
21772: LIST
21773: PPUSH
21774: CALL_OW 69
21778: PUSH
21779: LD_EXP 58
21783: DIFF
21784: ST_TO_ADDR
// if tmp then
21785: LD_VAR 0 3
21789: IFFALSE 21823
// for i in tmp do
21791: LD_ADDR_VAR 0 1
21795: PUSH
21796: LD_VAR 0 3
21800: PUSH
21801: FOR_IN
21802: IFFALSE 21821
// ComMoveXY ( i , 36 , 67 ) ;
21804: LD_VAR 0 1
21808: PPUSH
21809: LD_INT 36
21811: PPUSH
21812: LD_INT 67
21814: PPUSH
21815: CALL_OW 111
21819: GO 21801
21821: POP
21822: POP
// wait ( 0 0$3 ) ;
21823: LD_INT 105
21825: PPUSH
21826: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21830: LD_VAR 0 11
21834: PPUSH
21835: LD_STRING D6-Sol3-1
21837: PPUSH
21838: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21842: LD_EXP 58
21846: PPUSH
21847: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21851: LD_EXP 58
21855: PPUSH
21856: LD_STRING D6-Pow-1
21858: PPUSH
21859: CALL_OW 88
// tmp := [ ] ;
21863: LD_ADDR_VAR 0 3
21867: PUSH
21868: EMPTY
21869: ST_TO_ADDR
// for i = 1 to 2 do
21870: LD_ADDR_VAR 0 1
21874: PUSH
21875: DOUBLE
21876: LD_INT 1
21878: DEC
21879: ST_TO_ADDR
21880: LD_INT 2
21882: PUSH
21883: FOR_TO
21884: IFFALSE 21998
// begin uc_side := 8 ;
21886: LD_ADDR_OWVAR 20
21890: PUSH
21891: LD_INT 8
21893: ST_TO_ADDR
// uc_nation := 2 ;
21894: LD_ADDR_OWVAR 21
21898: PUSH
21899: LD_INT 2
21901: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21902: LD_INT 14
21904: PPUSH
21905: LD_INT 3
21907: PPUSH
21908: LD_INT 2
21910: PPUSH
21911: LD_INT 29
21913: PPUSH
21914: LD_INT 100
21916: PPUSH
21917: CALL 71897 0 5
// veh := CreateVehicle ;
21921: LD_ADDR_VAR 0 13
21925: PUSH
21926: CALL_OW 45
21930: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21931: LD_VAR 0 13
21935: PPUSH
21936: LD_INT 4
21938: PPUSH
21939: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21943: LD_VAR 0 13
21947: PPUSH
21948: LD_INT 99
21950: PPUSH
21951: LD_INT 83
21953: PPUSH
21954: LD_INT 6
21956: PPUSH
21957: LD_INT 0
21959: PPUSH
21960: CALL_OW 50
// wait ( 3 ) ;
21964: LD_INT 3
21966: PPUSH
21967: CALL_OW 67
// Connect ( veh ) ;
21971: LD_VAR 0 13
21975: PPUSH
21976: CALL 74952 0 1
// tmp := tmp ^ veh ;
21980: LD_ADDR_VAR 0 3
21984: PUSH
21985: LD_VAR 0 3
21989: PUSH
21990: LD_VAR 0 13
21994: ADD
21995: ST_TO_ADDR
// end ;
21996: GO 21883
21998: POP
21999: POP
// wait ( 0 0$1 ) ;
22000: LD_INT 35
22002: PPUSH
22003: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22007: LD_INT 99
22009: PPUSH
22010: LD_INT 83
22012: PPUSH
22013: LD_INT 1
22015: PPUSH
22016: LD_INT 10
22018: PPUSH
22019: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22023: LD_INT 99
22025: PPUSH
22026: LD_INT 83
22028: PPUSH
22029: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22033: LD_VAR 0 11
22037: PPUSH
22038: LD_STRING D6-Sol3-2
22040: PPUSH
22041: CALL_OW 88
// async ;
22045: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22046: LD_EXP 58
22050: PPUSH
22051: LD_STRING D6-Pow-2
22053: PPUSH
22054: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22058: LD_VAR 0 3
22062: PUSH
22063: LD_INT 1
22065: ARRAY
22066: PPUSH
22067: LD_VAR 0 9
22071: PPUSH
22072: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22076: LD_VAR 0 3
22080: PUSH
22081: LD_INT 2
22083: ARRAY
22084: PPUSH
22085: LD_INT 22
22087: PUSH
22088: LD_INT 4
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: LD_INT 21
22097: PUSH
22098: LD_INT 3
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PUSH
22105: EMPTY
22106: LIST
22107: LIST
22108: PPUSH
22109: CALL_OW 69
22113: PPUSH
22114: LD_VAR 0 3
22118: PUSH
22119: LD_INT 2
22121: ARRAY
22122: PPUSH
22123: CALL_OW 74
22127: PPUSH
22128: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22132: LD_EXP 58
22136: PPUSH
22137: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22141: LD_INT 99
22143: PPUSH
22144: LD_INT 83
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: CALL_OW 331
// repeat wait ( 4 ) ;
22154: LD_INT 4
22156: PPUSH
22157: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22161: LD_VAR 0 3
22165: PUSH
22166: LD_INT 1
22168: ARRAY
22169: PPUSH
22170: CALL_OW 256
22174: PUSH
22175: LD_INT 1000
22177: LESS
22178: IFFALSE 22196
// SetLives ( tmp [ 1 ] , 1000 ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_INT 1000
22191: PPUSH
22192: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22196: LD_INT 22
22198: PUSH
22199: LD_INT 4
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: LD_INT 30
22208: PUSH
22209: LD_INT 3
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PUSH
22216: EMPTY
22217: LIST
22218: LIST
22219: PPUSH
22220: CALL_OW 69
22224: PUSH
22225: LD_INT 0
22227: EQUAL
22228: IFFALSE 22154
// sync ;
22230: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22231: LD_EXP 58
22235: PPUSH
22236: LD_STRING D6a-Pow-1
22238: PPUSH
22239: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22243: LD_VAR 0 11
22247: PPUSH
22248: LD_STRING D6a-Sol3-1
22250: PPUSH
22251: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22255: LD_EXP 58
22259: PPUSH
22260: LD_STRING D6a-Pow-2
22262: PPUSH
22263: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22267: LD_VAR 0 11
22271: PPUSH
22272: LD_STRING D6a-Sol3-2
22274: PPUSH
22275: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22279: LD_EXP 58
22283: PPUSH
22284: LD_STRING D6a-Pow-3
22286: PPUSH
22287: CALL_OW 88
// powellCenterCameraMode := true ;
22291: LD_ADDR_EXP 20
22295: PUSH
22296: LD_INT 1
22298: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22299: LD_ADDR_VAR 0 1
22303: PUSH
22304: LD_INT 22
22306: PUSH
22307: LD_INT 8
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 25
22316: PUSH
22317: LD_INT 2
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PPUSH
22328: CALL_OW 69
22332: PUSH
22333: FOR_IN
22334: IFFALSE 22389
// begin SetTag ( i , 1 ) ;
22336: LD_VAR 0 1
22340: PPUSH
22341: LD_INT 1
22343: PPUSH
22344: CALL_OW 109
// ComExitBuilding ( i ) ;
22348: LD_VAR 0 1
22352: PPUSH
22353: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22357: LD_VAR 0 1
22361: PPUSH
22362: LD_INT 35
22364: PPUSH
22365: LD_INT 6
22367: PPUSH
22368: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22372: LD_VAR 0 1
22376: PPUSH
22377: LD_INT 53
22379: PPUSH
22380: LD_INT 4
22382: PPUSH
22383: CALL_OW 171
// end ;
22387: GO 22333
22389: POP
22390: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22391: LD_ADDR_VAR 0 3
22395: PUSH
22396: LD_INT 22
22398: PUSH
22399: LD_INT 4
22401: PUSH
22402: EMPTY
22403: LIST
22404: LIST
22405: PUSH
22406: LD_INT 21
22408: PUSH
22409: LD_INT 2
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: PUSH
22416: LD_INT 3
22418: PUSH
22419: LD_INT 34
22421: PUSH
22422: LD_INT 12
22424: PUSH
22425: EMPTY
22426: LIST
22427: LIST
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: LIST
22437: PPUSH
22438: CALL_OW 69
22442: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22443: LD_EXP 58
22447: PPUSH
22448: LD_VAR 0 3
22452: PPUSH
22453: LD_EXP 58
22457: PPUSH
22458: CALL_OW 74
22462: PPUSH
22463: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22467: LD_EXP 58
22471: PPUSH
22472: LD_INT 100
22474: PPUSH
22475: LD_INT 88
22477: PPUSH
22478: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22482: LD_EXP 58
22486: PPUSH
22487: LD_INT 100
22489: PPUSH
22490: LD_INT 75
22492: PPUSH
22493: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22497: LD_EXP 58
22501: PPUSH
22502: LD_INT 88
22504: PPUSH
22505: LD_INT 53
22507: PPUSH
22508: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22512: LD_INT 8
22514: PPUSH
22515: LD_EXP 58
22519: PPUSH
22520: CALL_OW 471
// repeat wait ( 3 ) ;
22524: LD_INT 3
22526: PPUSH
22527: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22531: LD_INT 22
22533: PUSH
22534: LD_INT 4
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: PUSH
22541: LD_INT 92
22543: PUSH
22544: LD_INT 100
22546: PUSH
22547: LD_INT 75
22549: PUSH
22550: LD_INT 6
22552: PUSH
22553: EMPTY
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 69
22567: IFFALSE 22524
// async ;
22569: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22570: LD_EXP 58
22574: PPUSH
22575: LD_STRING D6b-Pow-1
22577: PPUSH
22578: CALL_OW 88
// repeat wait ( 3 ) ;
22582: LD_INT 3
22584: PPUSH
22585: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22589: LD_EXP 58
22593: PPUSH
22594: CALL_OW 310
22598: PPUSH
22599: CALL_OW 256
22603: PUSH
22604: LD_INT 1000
22606: LESS
22607: IFFALSE 22626
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22609: LD_EXP 58
22613: PPUSH
22614: CALL_OW 310
22618: PPUSH
22619: LD_INT 1000
22621: PPUSH
22622: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22626: LD_EXP 58
22630: PPUSH
22631: CALL_OW 256
22635: PUSH
22636: LD_INT 1000
22638: LESS
22639: IFFALSE 22653
// SetLives ( Powell , 1000 ) ;
22641: LD_EXP 58
22645: PPUSH
22646: LD_INT 1000
22648: PPUSH
22649: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22653: LD_EXP 58
22657: PPUSH
22658: LD_EXP 63
22662: PPUSH
22663: CALL_OW 296
22667: PUSH
22668: LD_INT 5
22670: LESS
22671: PUSH
22672: LD_EXP 58
22676: PPUSH
22677: CALL_OW 310
22681: PPUSH
22682: LD_EXP 63
22686: PPUSH
22687: CALL_OW 296
22691: PUSH
22692: LD_INT 5
22694: LESS
22695: OR
22696: IFFALSE 22715
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22698: LD_EXP 58
22702: PPUSH
22703: CALL_OW 310
22707: PPUSH
22708: LD_INT 100
22710: PPUSH
22711: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22715: LD_EXP 58
22719: PPUSH
22720: CALL_OW 310
22724: NOT
22725: IFFALSE 22582
// DoNotAttack ( 8 , powellBomb ) ;
22727: LD_INT 8
22729: PPUSH
22730: LD_EXP 63
22734: PPUSH
22735: CALL_OW 471
// game_speed := 4 ;
22739: LD_ADDR_OWVAR 65
22743: PUSH
22744: LD_INT 4
22746: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22747: LD_EXP 58
22751: PPUSH
22752: LD_STRING D6b-Pow-1a
22754: PPUSH
22755: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22759: LD_EXP 58
22763: PPUSH
22764: LD_EXP 63
22768: PPUSH
22769: CALL_OW 180
// sync ;
22773: SYNC
// repeat wait ( 0 0$1 ) ;
22774: LD_INT 35
22776: PPUSH
22777: CALL_OW 67
// until IsInUnit ( Powell ) ;
22781: LD_EXP 58
22785: PPUSH
22786: CALL_OW 310
22790: IFFALSE 22774
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22792: LD_INT 8
22794: PPUSH
22795: LD_EXP 58
22799: PPUSH
22800: CALL_OW 310
22804: PPUSH
22805: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22809: LD_EXP 58
22813: PPUSH
22814: LD_INT 91
22816: PPUSH
22817: LD_INT 44
22819: PPUSH
22820: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22824: LD_EXP 58
22828: PPUSH
22829: LD_INT 96
22831: PPUSH
22832: LD_INT 44
22834: PPUSH
22835: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22839: LD_EXP 58
22843: PPUSH
22844: LD_INT 96
22846: PPUSH
22847: LD_INT 41
22849: PPUSH
22850: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_INT 92
22861: PPUSH
22862: LD_INT 39
22864: PPUSH
22865: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_INT 88
22876: PPUSH
22877: LD_INT 41
22879: PPUSH
22880: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22884: LD_EXP 58
22888: PPUSH
22889: LD_INT 91
22891: PPUSH
22892: LD_INT 44
22894: PPUSH
22895: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22899: LD_EXP 58
22903: PPUSH
22904: LD_INT 96
22906: PPUSH
22907: LD_INT 44
22909: PPUSH
22910: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22914: LD_EXP 58
22918: PPUSH
22919: LD_INT 96
22921: PPUSH
22922: LD_INT 41
22924: PPUSH
22925: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22929: LD_EXP 58
22933: PPUSH
22934: LD_INT 92
22936: PPUSH
22937: LD_INT 39
22939: PPUSH
22940: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22944: LD_EXP 58
22948: PPUSH
22949: LD_INT 88
22951: PPUSH
22952: LD_INT 41
22954: PPUSH
22955: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22959: LD_EXP 58
22963: PPUSH
22964: LD_INT 91
22966: PPUSH
22967: LD_INT 44
22969: PPUSH
22970: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22974: LD_EXP 58
22978: PPUSH
22979: LD_INT 93
22981: PPUSH
22982: LD_INT 39
22984: PPUSH
22985: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22989: LD_EXP 58
22993: PPUSH
22994: LD_INT 93
22996: PPUSH
22997: LD_INT 36
22999: PPUSH
23000: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23004: LD_INT 122
23006: PPUSH
23007: CALL_OW 67
// game_speed := 4 ;
23011: LD_ADDR_OWVAR 65
23015: PUSH
23016: LD_INT 4
23018: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23019: LD_EXP 58
23023: PPUSH
23024: LD_STRING D6b-Pow-1b
23026: PPUSH
23027: CALL_OW 88
// tmp := [ ] ;
23031: LD_ADDR_VAR 0 3
23035: PUSH
23036: EMPTY
23037: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23038: LD_ADDR_VAR 0 5
23042: PUSH
23043: LD_INT 78
23045: PUSH
23046: LD_INT 47
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: LD_INT 106
23055: PUSH
23056: LD_INT 53
23058: PUSH
23059: EMPTY
23060: LIST
23061: LIST
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23067: LD_ADDR_VAR 0 1
23071: PUSH
23072: LD_INT 22
23074: PUSH
23075: LD_INT 8
23077: PUSH
23078: EMPTY
23079: LIST
23080: LIST
23081: PUSH
23082: LD_INT 21
23084: PUSH
23085: LD_INT 3
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: LD_INT 92
23094: PUSH
23095: LD_INT 90
23097: PUSH
23098: LD_INT 52
23100: PUSH
23101: LD_INT 12
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: PUSH
23110: EMPTY
23111: LIST
23112: LIST
23113: LIST
23114: PPUSH
23115: CALL_OW 69
23119: PUSH
23120: FOR_IN
23121: IFFALSE 23146
// tmp := tmp ^ UnitsInside ( i ) ;
23123: LD_ADDR_VAR 0 3
23127: PUSH
23128: LD_VAR 0 3
23132: PUSH
23133: LD_VAR 0 1
23137: PPUSH
23138: CALL_OW 313
23142: ADD
23143: ST_TO_ADDR
23144: GO 23120
23146: POP
23147: POP
// for i in tmp do
23148: LD_ADDR_VAR 0 1
23152: PUSH
23153: LD_VAR 0 3
23157: PUSH
23158: FOR_IN
23159: IFFALSE 23321
// begin dist := 9999 ;
23161: LD_ADDR_VAR 0 8
23165: PUSH
23166: LD_INT 9999
23168: ST_TO_ADDR
// _xy := [ ] ;
23169: LD_ADDR_VAR 0 7
23173: PUSH
23174: EMPTY
23175: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23176: LD_VAR 0 1
23180: PPUSH
23181: LD_INT 1
23183: PPUSH
23184: CALL_OW 109
// ComExitBuilding ( i ) ;
23188: LD_VAR 0 1
23192: PPUSH
23193: CALL_OW 122
// for j in xy do
23197: LD_ADDR_VAR 0 2
23201: PUSH
23202: LD_VAR 0 5
23206: PUSH
23207: FOR_IN
23208: IFFALSE 23290
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23210: LD_VAR 0 1
23214: PPUSH
23215: LD_VAR 0 2
23219: PUSH
23220: LD_INT 1
23222: ARRAY
23223: PPUSH
23224: LD_VAR 0 2
23228: PUSH
23229: LD_INT 2
23231: ARRAY
23232: PPUSH
23233: CALL_OW 297
23237: PUSH
23238: LD_VAR 0 8
23242: LESS
23243: IFFALSE 23288
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23245: LD_ADDR_VAR 0 8
23249: PUSH
23250: LD_VAR 0 1
23254: PPUSH
23255: LD_VAR 0 2
23259: PUSH
23260: LD_INT 1
23262: ARRAY
23263: PPUSH
23264: LD_VAR 0 2
23268: PUSH
23269: LD_INT 2
23271: ARRAY
23272: PPUSH
23273: CALL_OW 297
23277: ST_TO_ADDR
// _xy := j ;
23278: LD_ADDR_VAR 0 7
23282: PUSH
23283: LD_VAR 0 2
23287: ST_TO_ADDR
// end ;
23288: GO 23207
23290: POP
23291: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23292: LD_VAR 0 1
23296: PPUSH
23297: LD_VAR 0 7
23301: PUSH
23302: LD_INT 1
23304: ARRAY
23305: PPUSH
23306: LD_VAR 0 7
23310: PUSH
23311: LD_INT 2
23313: ARRAY
23314: PPUSH
23315: CALL_OW 171
// end ;
23319: GO 23158
23321: POP
23322: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23323: LD_ADDR_VAR 0 4
23327: PUSH
23328: LD_VAR 0 3
23332: PPUSH
23333: LD_INT 26
23335: PUSH
23336: LD_INT 1
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: PUSH
23343: LD_INT 25
23345: PUSH
23346: LD_INT 1
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: PPUSH
23357: CALL_OW 72
23361: ST_TO_ADDR
// if tmp2 < 2 then
23362: LD_VAR 0 4
23366: PUSH
23367: LD_INT 2
23369: LESS
23370: IFFALSE 23439
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23372: LD_ADDR_VAR 0 4
23376: PUSH
23377: LD_INT 22
23379: PUSH
23380: LD_INT 8
23382: PUSH
23383: EMPTY
23384: LIST
23385: LIST
23386: PUSH
23387: LD_INT 26
23389: PUSH
23390: LD_INT 1
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PUSH
23397: LD_INT 3
23399: PUSH
23400: LD_INT 25
23402: PUSH
23403: LD_INT 15
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: EMPTY
23411: LIST
23412: LIST
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: LIST
23418: PPUSH
23419: CALL_OW 69
23423: PUSH
23424: LD_EXP 60
23428: PUSH
23429: LD_EXP 61
23433: PUSH
23434: EMPTY
23435: LIST
23436: LIST
23437: DIFF
23438: ST_TO_ADDR
// if tmp2 then
23439: LD_VAR 0 4
23443: IFFALSE 23461
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23445: LD_VAR 0 4
23449: PUSH
23450: LD_INT 1
23452: ARRAY
23453: PPUSH
23454: LD_STRING D6b-ArSol1-1
23456: PPUSH
23457: CALL_OW 88
// async ;
23461: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23462: LD_EXP 58
23466: PPUSH
23467: LD_STRING D6b-Pow-2
23469: PPUSH
23470: CALL_OW 88
// wait ( 0 0$1 ) ;
23474: LD_INT 35
23476: PPUSH
23477: CALL_OW 67
// if tmp2 > 1 then
23481: LD_VAR 0 4
23485: PUSH
23486: LD_INT 1
23488: GREATER
23489: IFFALSE 23507
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23491: LD_VAR 0 4
23495: PUSH
23496: LD_INT 2
23498: ARRAY
23499: PPUSH
23500: LD_STRING D6b-ArSol2-1
23502: PPUSH
23503: CALL_OW 88
// sync ;
23507: SYNC
// repeat wait ( 5 ) ;
23508: LD_INT 5
23510: PPUSH
23511: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23515: LD_INT 93
23517: PPUSH
23518: LD_INT 36
23520: PPUSH
23521: CALL_OW 428
23525: PPUSH
23526: CALL_OW 255
23530: PUSH
23531: LD_INT 4
23533: EQUAL
23534: IFFALSE 23508
// DialogueOn ;
23536: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23540: LD_INT 10
23542: PPUSH
23543: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23547: LD_EXP 58
23551: PPUSH
23552: LD_STRING D6b-Pow-2a
23554: PPUSH
23555: CALL_OW 88
// DialogueOff ;
23559: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23563: LD_EXP 58
23567: PPUSH
23568: CALL_OW 310
23572: PPUSH
23573: LD_INT 332
23575: PPUSH
23576: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23580: LD_INT 93
23582: PPUSH
23583: LD_INT 35
23585: PPUSH
23586: LD_INT 1
23588: PPUSH
23589: LD_INT 6
23591: NEG
23592: PPUSH
23593: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23597: LD_INT 35
23599: PPUSH
23600: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23604: LD_INT 332
23606: PPUSH
23607: CALL_OW 256
23611: PUSH
23612: LD_INT 1000
23614: LESS
23615: PUSH
23616: LD_INT 332
23618: PPUSH
23619: CALL_OW 300
23623: AND
23624: IFFALSE 23636
// SetLives ( kozlov_fac , 0 ) ;
23626: LD_INT 332
23628: PPUSH
23629: LD_INT 0
23631: PPUSH
23632: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23636: LD_INT 332
23638: PPUSH
23639: CALL_OW 301
23643: PUSH
23644: LD_EXP 58
23648: PPUSH
23649: CALL_OW 301
23653: OR
23654: IFFALSE 23597
// game_speed := 4 ;
23656: LD_ADDR_OWVAR 65
23660: PUSH
23661: LD_INT 4
23663: ST_TO_ADDR
// powellCenterCameraMode := false ;
23664: LD_ADDR_EXP 20
23668: PUSH
23669: LD_INT 0
23671: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23672: LD_ADDR_VAR 0 1
23676: PUSH
23677: LD_VAR 0 3
23681: PUSH
23682: LD_INT 22
23684: PUSH
23685: LD_INT 8
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: LD_INT 25
23694: PUSH
23695: LD_INT 2
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: EMPTY
23703: LIST
23704: LIST
23705: PPUSH
23706: CALL_OW 69
23710: UNION
23711: PUSH
23712: FOR_IN
23713: IFFALSE 23729
// SetTag ( i , 0 ) ;
23715: LD_VAR 0 1
23719: PPUSH
23720: LD_INT 0
23722: PPUSH
23723: CALL_OW 109
23727: GO 23712
23729: POP
23730: POP
// wait ( 0 0$3 ) ;
23731: LD_INT 105
23733: PPUSH
23734: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23738: LD_INT 93
23740: PPUSH
23741: LD_INT 35
23743: PPUSH
23744: LD_INT 1
23746: PPUSH
23747: CALL_OW 331
// DialogueOn ;
23751: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23755: LD_VAR 0 11
23759: PPUSH
23760: LD_STRING D6c-Sol3-1
23762: PPUSH
23763: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23767: LD_INT 10
23769: PPUSH
23770: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23774: LD_EXP 39
23778: PPUSH
23779: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23783: LD_EXP 39
23787: PPUSH
23788: LD_STRING D6c-JMM-1
23790: PPUSH
23791: CALL_OW 88
// if Cyrus then
23795: LD_EXP 45
23799: IFFALSE 23813
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23801: LD_EXP 45
23805: PPUSH
23806: LD_STRING D6c-Cyrus-1
23808: PPUSH
23809: CALL_OW 88
// if Bobby then
23813: LD_EXP 44
23817: IFFALSE 23831
// Say ( Bobby , D6c-Bobby-1 ) ;
23819: LD_EXP 44
23823: PPUSH
23824: LD_STRING D6c-Bobby-1
23826: PPUSH
23827: CALL_OW 88
// if Cornel then
23831: LD_EXP 50
23835: IFFALSE 23849
// Say ( Cornel , D6c-Corn-1 ) ;
23837: LD_EXP 50
23841: PPUSH
23842: LD_STRING D6c-Corn-1
23844: PPUSH
23845: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23849: LD_ADDR_VAR 0 4
23853: PUSH
23854: LD_INT 2
23856: PUSH
23857: LD_INT 22
23859: PUSH
23860: LD_INT 1
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PUSH
23867: LD_INT 22
23869: PUSH
23870: LD_INT 4
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: PUSH
23882: LD_INT 26
23884: PUSH
23885: LD_INT 1
23887: PUSH
23888: EMPTY
23889: LIST
23890: LIST
23891: PUSH
23892: LD_INT 3
23894: PUSH
23895: LD_INT 25
23897: PUSH
23898: LD_INT 16
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PUSH
23905: LD_INT 25
23907: PUSH
23908: LD_INT 12
23910: PUSH
23911: EMPTY
23912: LIST
23913: LIST
23914: PUSH
23915: EMPTY
23916: LIST
23917: LIST
23918: LIST
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: LIST
23924: PPUSH
23925: CALL_OW 69
23929: PUSH
23930: LD_VAR 0 11
23934: PUSH
23935: LD_EXP 39
23939: UNION
23940: PUSH
23941: LD_EXP 59
23945: UNION
23946: PUSH
23947: EMPTY
23948: LIST
23949: DIFF
23950: ST_TO_ADDR
// if tmp2 then
23951: LD_VAR 0 4
23955: IFFALSE 23973
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23957: LD_VAR 0 4
23961: PUSH
23962: LD_INT 1
23964: ARRAY
23965: PPUSH
23966: LD_STRING D6c-Sol1-1
23968: PPUSH
23969: CALL_OW 88
// if Lisa then
23973: LD_EXP 42
23977: IFFALSE 23991
// Say ( Lisa , D6c-Lisa-1 ) ;
23979: LD_EXP 42
23983: PPUSH
23984: LD_STRING D6c-Lisa-1
23986: PPUSH
23987: CALL_OW 88
// if Gary then
23991: LD_EXP 51
23995: IFFALSE 24009
// Say ( Gary , D6c-Gary-1 ) ;
23997: LD_EXP 51
24001: PPUSH
24002: LD_STRING D6c-Gary-1
24004: PPUSH
24005: CALL_OW 88
// if Donaldson then
24009: LD_EXP 43
24013: IFFALSE 24027
// Say ( Donaldson , D6c-Don-1 ) ;
24015: LD_EXP 43
24019: PPUSH
24020: LD_STRING D6c-Don-1
24022: PPUSH
24023: CALL_OW 88
// if tmp2 > 1 then
24027: LD_VAR 0 4
24031: PUSH
24032: LD_INT 1
24034: GREATER
24035: IFFALSE 24053
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24037: LD_VAR 0 4
24041: PUSH
24042: LD_INT 2
24044: ARRAY
24045: PPUSH
24046: LD_STRING D6c-Sol2-1
24048: PPUSH
24049: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24053: LD_VAR 0 11
24057: PPUSH
24058: LD_STRING D6c-Sol3-2
24060: PPUSH
24061: CALL_OW 88
// dwait ( 0 0$1 ) ;
24065: LD_INT 35
24067: PPUSH
24068: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24072: LD_EXP 39
24076: PPUSH
24077: LD_STRING D6c-JMM-2
24079: PPUSH
24080: CALL_OW 88
// DialogueOff ;
24084: CALL_OW 7
// Video ( false ) ;
24088: LD_INT 0
24090: PPUSH
24091: CALL 107624 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24095: LD_INT 22
24097: PUSH
24098: LD_INT 4
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PPUSH
24105: CALL_OW 69
24109: PPUSH
24110: LD_INT 1
24112: PPUSH
24113: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24117: LD_INT 4
24119: PPUSH
24120: LD_INT 4
24122: PPUSH
24123: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24127: LD_ADDR_VAR 0 1
24131: PUSH
24132: LD_INT 4
24134: PPUSH
24135: LD_INT 1
24137: PPUSH
24138: LD_INT 2
24140: PPUSH
24141: CALL 64845 0 3
24145: PUSH
24146: FOR_IN
24147: IFFALSE 24184
// if GetTech ( i , 1 ) <> state_researched then
24149: LD_VAR 0 1
24153: PPUSH
24154: LD_INT 1
24156: PPUSH
24157: CALL_OW 321
24161: PUSH
24162: LD_INT 2
24164: NONEQUAL
24165: IFFALSE 24182
// SetTech ( i , 1 , state_researched ) ;
24167: LD_VAR 0 1
24171: PPUSH
24172: LD_INT 1
24174: PPUSH
24175: LD_INT 2
24177: PPUSH
24178: CALL_OW 322
24182: GO 24146
24184: POP
24185: POP
// missionStage := 6 ;
24186: LD_ADDR_EXP 15
24190: PUSH
24191: LD_INT 6
24193: ST_TO_ADDR
// activeAttacks := true ;
24194: LD_ADDR_EXP 16
24198: PUSH
24199: LD_INT 1
24201: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24202: LD_STRING M2
24204: PPUSH
24205: CALL_OW 337
// SaveForQuickRestart ;
24209: CALL_OW 22
// wait ( 0 0$40 ) ;
24213: LD_INT 1400
24215: PPUSH
24216: CALL_OW 67
// DialogueOn ;
24220: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24224: LD_EXP 62
24228: PPUSH
24229: LD_STRING D7-Friend-1
24231: PPUSH
24232: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24236: LD_EXP 39
24240: PPUSH
24241: LD_STRING D7-JMM-1
24243: PPUSH
24244: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24248: LD_EXP 62
24252: PPUSH
24253: LD_STRING D7-Friend-2
24255: PPUSH
24256: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24260: LD_EXP 39
24264: PPUSH
24265: LD_STRING D7-JMM-2
24267: PPUSH
24268: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24272: LD_EXP 62
24276: PPUSH
24277: LD_STRING D7-Friend-3
24279: PPUSH
24280: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24284: LD_EXP 39
24288: PPUSH
24289: LD_STRING D7-JMM-3
24291: PPUSH
24292: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24296: LD_EXP 62
24300: PPUSH
24301: LD_STRING D7-Friend-4
24303: PPUSH
24304: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24308: LD_EXP 39
24312: PPUSH
24313: LD_STRING D7-JMM-4
24315: PPUSH
24316: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24320: LD_EXP 62
24324: PPUSH
24325: LD_STRING D7-Friend-5
24327: PPUSH
24328: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24332: LD_EXP 39
24336: PPUSH
24337: LD_STRING D7-JMM-5
24339: PPUSH
24340: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24344: LD_EXP 62
24348: PPUSH
24349: LD_STRING D7-Friend-6
24351: PPUSH
24352: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24356: LD_EXP 39
24360: PPUSH
24361: LD_STRING D7-JMM-6
24363: PPUSH
24364: CALL_OW 88
// DialogueOff ;
24368: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24372: LD_STRING Mlegion
24374: PPUSH
24375: CALL_OW 337
// RebuildKozlovFactory ;
24379: CALL 4823 0 0
// end ;
24383: PPOPN 13
24385: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24386: LD_EXP 20
24390: PUSH
24391: LD_EXP 58
24395: PPUSH
24396: CALL_OW 300
24400: AND
24401: IFFALSE 24443
24403: GO 24405
24405: DISABLE
// begin enable ;
24406: ENABLE
// if IsInUnit ( Powell ) then
24407: LD_EXP 58
24411: PPUSH
24412: CALL_OW 310
24416: IFFALSE 24434
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24418: LD_EXP 58
24422: PPUSH
24423: CALL_OW 310
24427: PPUSH
24428: CALL_OW 85
24432: GO 24443
// CenterOnUnits ( Powell ) ;
24434: LD_EXP 58
24438: PPUSH
24439: CALL_OW 85
// end ;
24443: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24444: LD_INT 22
24446: PUSH
24447: LD_INT 8
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: PUSH
24454: LD_INT 34
24456: PUSH
24457: LD_INT 48
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PUSH
24464: EMPTY
24465: LIST
24466: LIST
24467: PPUSH
24468: CALL_OW 69
24472: IFFALSE 24746
24474: GO 24476
24476: DISABLE
24477: LD_INT 0
24479: PPUSH
24480: PPUSH
// begin if missionStage < 9 then
24481: LD_EXP 15
24485: PUSH
24486: LD_INT 9
24488: LESS
24489: IFFALSE 24499
// missionStage := 9 ;
24491: LD_ADDR_EXP 15
24495: PUSH
24496: LD_INT 9
24498: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24499: LD_ADDR_VAR 0 1
24503: PUSH
24504: LD_INT 22
24506: PUSH
24507: LD_INT 8
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 34
24516: PUSH
24517: LD_INT 48
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: PPUSH
24528: CALL_OW 69
24532: PUSH
24533: LD_INT 1
24535: ARRAY
24536: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24537: LD_INT 175
24539: PPUSH
24540: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24544: LD_EXP 12
24548: PUSH
24549: LD_EXP 3
24553: PUSH
24554: LD_INT 0
24556: PUSH
24557: LD_INT 2
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: IN
24564: OR
24565: IFFALSE 24588
// target := [ 68 , 108 , 1 ] else
24567: LD_ADDR_VAR 0 2
24571: PUSH
24572: LD_INT 68
24574: PUSH
24575: LD_INT 108
24577: PUSH
24578: LD_INT 1
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: LIST
24585: ST_TO_ADDR
24586: GO 24607
// target := [ 181 , 88 , 2 ] ;
24588: LD_ADDR_VAR 0 2
24592: PUSH
24593: LD_INT 181
24595: PUSH
24596: LD_INT 88
24598: PUSH
24599: LD_INT 2
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: LIST
24606: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24607: LD_VAR 0 1
24611: PPUSH
24612: LD_VAR 0 2
24616: PUSH
24617: LD_INT 1
24619: ARRAY
24620: PPUSH
24621: LD_VAR 0 2
24625: PUSH
24626: LD_INT 2
24628: ARRAY
24629: PPUSH
24630: CALL_OW 176
// if target [ 3 ] = 1 then
24634: LD_VAR 0 2
24638: PUSH
24639: LD_INT 3
24641: ARRAY
24642: PUSH
24643: LD_INT 1
24645: EQUAL
24646: IFFALSE 24662
// SayRadio ( Kurt , D12-Kurt-1 ) else
24648: LD_EXP 60
24652: PPUSH
24653: LD_STRING D12-Kurt-1
24655: PPUSH
24656: CALL_OW 94
24660: GO 24686
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24662: LD_EXP 60
24666: PPUSH
24667: LD_STRING D12a-Kurt-1
24669: PPUSH
24670: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24674: LD_EXP 74
24678: PPUSH
24679: LD_STRING D12a-Roth-1
24681: PPUSH
24682: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24686: LD_INT 350
24688: PPUSH
24689: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24693: LD_VAR 0 1
24697: PPUSH
24698: LD_INT 22
24700: PUSH
24701: LD_INT 8
24703: PUSH
24704: EMPTY
24705: LIST
24706: LIST
24707: PUSH
24708: LD_INT 23
24710: PUSH
24711: LD_INT 2
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 30
24720: PUSH
24721: LD_INT 3
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: PPUSH
24733: CALL_OW 69
24737: PUSH
24738: LD_INT 1
24740: ARRAY
24741: PPUSH
24742: CALL_OW 228
// end ;
24746: PPOPN 2
24748: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24749: LD_EXP 60
24753: PPUSH
24754: CALL_OW 256
24758: PUSH
24759: LD_INT 999
24761: LESS
24762: PUSH
24763: LD_INT 22
24765: PUSH
24766: LD_INT 8
24768: PUSH
24769: EMPTY
24770: LIST
24771: LIST
24772: PUSH
24773: LD_INT 21
24775: PUSH
24776: LD_INT 1
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 23
24785: PUSH
24786: LD_INT 2
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: LIST
24797: PPUSH
24798: CALL_OW 69
24802: PUSH
24803: LD_INT 9
24805: PUSH
24806: LD_INT 8
24808: PUSH
24809: LD_INT 7
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: LIST
24816: PUSH
24817: LD_OWVAR 67
24821: ARRAY
24822: LESSEQUAL
24823: OR
24824: PUSH
24825: LD_INT 22
24827: PUSH
24828: LD_INT 8
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: LD_INT 34
24837: PUSH
24838: LD_INT 48
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: PPUSH
24849: CALL_OW 69
24853: NOT
24854: AND
24855: PUSH
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 302
24865: AND
24866: PUSH
24867: LD_INT 5
24869: PPUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 1
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 70
24884: AND
24885: IFFALSE 25554
24887: GO 24889
24889: DISABLE
24890: LD_INT 0
24892: PPUSH
24893: PPUSH
24894: PPUSH
// begin DialogueOn ;
24895: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24899: LD_EXP 39
24903: PPUSH
24904: LD_STRING D13-JMM-1
24906: PPUSH
24907: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24911: LD_EXP 60
24915: PPUSH
24916: LD_STRING D13-Kurt-1
24918: PPUSH
24919: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24923: LD_EXP 39
24927: PPUSH
24928: LD_STRING D13-JMM-2
24930: PPUSH
24931: CALL_OW 88
// if FakeInfo then
24935: LD_EXP 12
24939: IFFALSE 24959
// begin Say ( Kurt , D13-Kurt-2 ) ;
24941: LD_EXP 60
24945: PPUSH
24946: LD_STRING D13-Kurt-2
24948: PPUSH
24949: CALL_OW 88
// DialogueOff ;
24953: CALL_OW 7
// exit ;
24957: GO 25554
// end ; if not KurtStatus then
24959: LD_EXP 3
24963: NOT
24964: IFFALSE 24980
// Say ( Kurt , D13-Kurt-2b ) else
24966: LD_EXP 60
24970: PPUSH
24971: LD_STRING D13-Kurt-2b
24973: PPUSH
24974: CALL_OW 88
24978: GO 24992
// Say ( Kurt , D13-Kurt-2a ) ;
24980: LD_EXP 60
24984: PPUSH
24985: LD_STRING D13-Kurt-2a
24987: PPUSH
24988: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24992: LD_EXP 39
24996: PPUSH
24997: LD_STRING D13-JMM-3
24999: PPUSH
25000: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25004: LD_EXP 60
25008: PPUSH
25009: LD_STRING D13-Kurt-3
25011: PPUSH
25012: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25016: LD_EXP 39
25020: PPUSH
25021: LD_STRING D13-JMM-4
25023: PPUSH
25024: CALL_OW 88
// DialogueOff ;
25028: CALL_OW 7
// MC_Kill ( 3 ) ;
25032: LD_INT 3
25034: PPUSH
25035: CALL 34978 0 1
// KillUnit ( Kozlov ) ;
25039: LD_EXP 61
25043: PPUSH
25044: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
25048: LD_INT 22
25050: PUSH
25051: LD_INT 8
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 21
25060: PUSH
25061: LD_INT 3
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: LD_INT 23
25070: PUSH
25071: LD_INT 3
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: PUSH
25078: LD_INT 30
25080: PUSH
25081: LD_INT 3
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: PPUSH
25094: CALL_OW 69
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: PPUSH
25103: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25107: LD_INT 8
25109: PPUSH
25110: LD_INT 1
25112: PPUSH
25113: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25117: LD_ADDR_VAR 0 2
25121: PUSH
25122: LD_INT 22
25124: PUSH
25125: LD_INT 8
25127: PUSH
25128: EMPTY
25129: LIST
25130: LIST
25131: PUSH
25132: LD_INT 21
25134: PUSH
25135: LD_INT 1
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PPUSH
25146: CALL_OW 69
25150: PUSH
25151: LD_EXP 61
25155: PUSH
25156: LD_EXP 60
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: DIFF
25165: ST_TO_ADDR
// if tmp >= [ 9 , 8 , 7 ] [ Difficulty ] then
25166: LD_VAR 0 2
25170: PUSH
25171: LD_INT 9
25173: PUSH
25174: LD_INT 8
25176: PUSH
25177: LD_INT 7
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: LIST
25184: PUSH
25185: LD_OWVAR 67
25189: ARRAY
25190: GREATEREQUAL
25191: IFFALSE 25353
// begin x := [ 9 , 8 , 7 ] [ Difficulty ] ;
25193: LD_ADDR_VAR 0 3
25197: PUSH
25198: LD_INT 9
25200: PUSH
25201: LD_INT 8
25203: PUSH
25204: LD_INT 7
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: LIST
25211: PUSH
25212: LD_OWVAR 67
25216: ARRAY
25217: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25218: LD_ADDR_VAR 0 1
25222: PUSH
25223: DOUBLE
25224: LD_VAR 0 2
25228: PUSH
25229: LD_VAR 0 3
25233: PUSH
25234: LD_INT 1
25236: PLUS
25237: MINUS
25238: INC
25239: ST_TO_ADDR
25240: LD_INT 1
25242: PUSH
25243: FOR_DOWNTO
25244: IFFALSE 25349
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25246: LD_ADDR_EXP 38
25250: PUSH
25251: LD_EXP 38
25255: PUSH
25256: LD_VAR 0 2
25260: PUSH
25261: LD_VAR 0 1
25265: ARRAY
25266: ADD
25267: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25268: LD_VAR 0 2
25272: PUSH
25273: LD_VAR 0 1
25277: ARRAY
25278: PPUSH
25279: CALL_OW 310
25283: IFFALSE 25300
// ComExitBuilding ( tmp [ i ] ) ;
25285: LD_VAR 0 2
25289: PUSH
25290: LD_VAR 0 1
25294: ARRAY
25295: PPUSH
25296: CALL_OW 122
// if IsInUnit ( i ) then
25300: LD_VAR 0 1
25304: PPUSH
25305: CALL_OW 310
25309: IFFALSE 25326
// ComExitVehicle ( tmp [ i ] ) ;
25311: LD_VAR 0 2
25315: PUSH
25316: LD_VAR 0 1
25320: ARRAY
25321: PPUSH
25322: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 37 , 1 ) ;
25326: LD_VAR 0 2
25330: PUSH
25331: LD_VAR 0 1
25335: ARRAY
25336: PPUSH
25337: LD_INT 37
25339: PPUSH
25340: LD_INT 1
25342: PPUSH
25343: CALL_OW 171
// end ;
25347: GO 25243
25349: POP
25350: POP
// end else
25351: GO 25363
// x := tmp ;
25353: LD_ADDR_VAR 0 3
25357: PUSH
25358: LD_VAR 0 2
25362: ST_TO_ADDR
// for i := tmp downto tmp - x do
25363: LD_ADDR_VAR 0 1
25367: PUSH
25368: DOUBLE
25369: LD_VAR 0 2
25373: INC
25374: ST_TO_ADDR
25375: LD_VAR 0 2
25379: PUSH
25380: LD_VAR 0 3
25384: MINUS
25385: PUSH
25386: FOR_DOWNTO
25387: IFFALSE 25441
// begin if IsInUnit ( tmp [ i ] ) then
25389: LD_VAR 0 2
25393: PUSH
25394: LD_VAR 0 1
25398: ARRAY
25399: PPUSH
25400: CALL_OW 310
25404: IFFALSE 25421
// ComExitVehicle ( tmp [ i ] ) ;
25406: LD_VAR 0 2
25410: PUSH
25411: LD_VAR 0 1
25415: ARRAY
25416: PPUSH
25417: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25421: LD_VAR 0 2
25425: PUSH
25426: LD_VAR 0 1
25430: ARRAY
25431: PPUSH
25432: LD_INT 1
25434: PPUSH
25435: CALL_OW 235
// end ;
25439: GO 25386
25441: POP
25442: POP
// SetSide ( Kurt , 1 ) ;
25443: LD_EXP 60
25447: PPUSH
25448: LD_INT 1
25450: PPUSH
25451: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25455: LD_INT 22
25457: PUSH
25458: LD_INT 8
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 21
25467: PUSH
25468: LD_INT 3
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PPUSH
25479: CALL_OW 69
25483: PPUSH
25484: LD_INT 1
25486: PPUSH
25487: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25491: LD_INT 8
25493: PPUSH
25494: LD_INT 1
25496: PPUSH
25497: LD_INT 1
25499: PPUSH
25500: LD_INT 1
25502: PPUSH
25503: CALL_OW 80
// wait ( 0 0$40 ) ;
25507: LD_INT 1400
25509: PPUSH
25510: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25514: LD_EXP 62
25518: PPUSH
25519: LD_INT 37
25521: PPUSH
25522: LD_INT 1
25524: PPUSH
25525: LD_INT 0
25527: PPUSH
25528: CALL_OW 48
// wait ( 0 0$1 ) ;
25532: LD_INT 35
25534: PPUSH
25535: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25539: LD_EXP 62
25543: PPUSH
25544: LD_INT 60
25546: PPUSH
25547: LD_INT 95
25549: PPUSH
25550: CALL_OW 111
// end ;
25554: PPOPN 3
25556: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25557: LD_EXP 38
25561: IFFALSE 25636
25563: GO 25565
25565: DISABLE
25566: LD_INT 0
25568: PPUSH
// begin enable ;
25569: ENABLE
// for i in legionEscapeUnits do
25570: LD_ADDR_VAR 0 1
25574: PUSH
25575: LD_EXP 38
25579: PUSH
25580: FOR_IN
25581: IFFALSE 25634
// begin if IsInArea ( i , legionEscapeArea ) then
25583: LD_VAR 0 1
25587: PPUSH
25588: LD_INT 31
25590: PPUSH
25591: CALL_OW 308
25595: IFFALSE 25608
// RemoveUnit ( i ) else
25597: LD_VAR 0 1
25601: PPUSH
25602: CALL_OW 64
25606: GO 25632
// if not HasTask ( i ) then
25608: LD_VAR 0 1
25612: PPUSH
25613: CALL_OW 314
25617: NOT
25618: IFFALSE 25632
// ComMoveToArea ( i , legionEscapeArea ) ;
25620: LD_VAR 0 1
25624: PPUSH
25625: LD_INT 31
25627: PPUSH
25628: CALL_OW 113
// end ;
25632: GO 25580
25634: POP
25635: POP
// end ;
25636: PPOPN 1
25638: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25639: LD_INT 22
25641: PUSH
25642: LD_INT 8
25644: PUSH
25645: EMPTY
25646: LIST
25647: LIST
25648: PUSH
25649: LD_INT 21
25651: PUSH
25652: LD_INT 1
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PPUSH
25663: CALL_OW 69
25667: PUSH
25668: LD_INT 0
25670: EQUAL
25671: IFFALSE 25691
25673: GO 25675
25675: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25676: LD_STRING MlegionOut
25678: PPUSH
25679: CALL_OW 337
// legionDestroyed := true ;
25683: LD_ADDR_EXP 22
25687: PUSH
25688: LD_INT 1
25690: ST_TO_ADDR
// end ;
25691: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25692: LD_INT 1
25694: PPUSH
25695: LD_EXP 62
25699: PPUSH
25700: CALL_OW 292
25704: IFFALSE 26018
25706: GO 25708
25708: DISABLE
25709: LD_INT 0
25711: PPUSH
// begin wait ( 0 0$2 ) ;
25712: LD_INT 70
25714: PPUSH
25715: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25719: LD_EXP 62
25723: PPUSH
25724: CALL_OW 87
// DialogueOn ;
25728: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25732: LD_EXP 39
25736: PPUSH
25737: LD_STRING D14-JMM-1
25739: PPUSH
25740: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25744: LD_EXP 62
25748: PPUSH
25749: LD_STRING D14-Friend-1
25751: PPUSH
25752: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25756: LD_EXP 39
25760: PPUSH
25761: LD_STRING D14-JMM-2
25763: PPUSH
25764: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25768: LD_EXP 62
25772: PPUSH
25773: LD_STRING D14-Friend-2
25775: PPUSH
25776: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25780: LD_EXP 39
25784: PPUSH
25785: LD_STRING D14-JMM-3
25787: PPUSH
25788: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25792: LD_EXP 62
25796: PPUSH
25797: LD_STRING D14-Friend-3
25799: PPUSH
25800: CALL_OW 88
// DialogueOff ;
25804: CALL_OW 7
// dec = Query ( Q14 ) ;
25808: LD_ADDR_VAR 0 1
25812: PUSH
25813: LD_STRING Q14
25815: PPUSH
25816: CALL_OW 97
25820: ST_TO_ADDR
// if dec = 1 then
25821: LD_VAR 0 1
25825: PUSH
25826: LD_INT 1
25828: EQUAL
25829: IFFALSE 25863
// begin DialogueOn ;
25831: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25835: LD_EXP 39
25839: PPUSH
25840: LD_STRING D14a-JMM-1
25842: PPUSH
25843: CALL_OW 88
// DialogueOff ;
25847: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25851: LD_EXP 62
25855: PPUSH
25856: LD_INT 1
25858: PPUSH
25859: CALL_OW 235
// end ; if dec = 2 then
25863: LD_VAR 0 1
25867: PUSH
25868: LD_INT 2
25870: EQUAL
25871: IFFALSE 25924
// begin DialogueOn ;
25873: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25877: LD_EXP 39
25881: PPUSH
25882: LD_STRING D14b-JMM-1
25884: PPUSH
25885: CALL_OW 88
// DialogueOff ;
25889: CALL_OW 7
// wait ( 0 0$1 ) ;
25893: LD_INT 35
25895: PPUSH
25896: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
25900: LD_EXP 62
25904: PPUSH
25905: LD_INT 9
25907: PPUSH
25908: LD_INT 2
25910: PPUSH
25911: CALL_OW 111
// AddComHold ( Friend ) ;
25915: LD_EXP 62
25919: PPUSH
25920: CALL_OW 200
// end ; if dec = 3 then
25924: LD_VAR 0 1
25928: PUSH
25929: LD_INT 3
25931: EQUAL
25932: IFFALSE 26018
// begin DialogueOn ;
25934: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25938: LD_EXP 39
25942: PPUSH
25943: LD_STRING D14c-JMM-1
25945: PPUSH
25946: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25950: LD_EXP 62
25954: PPUSH
25955: LD_STRING D14c-Friend-1
25957: PPUSH
25958: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25962: LD_EXP 39
25966: PPUSH
25967: LD_STRING D14c-JMM-2
25969: PPUSH
25970: CALL_OW 88
// DialogueOff ;
25974: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25978: LD_INT 8
25980: PPUSH
25981: LD_INT 1
25983: PPUSH
25984: LD_INT 2
25986: PPUSH
25987: LD_INT 1
25989: PPUSH
25990: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25994: LD_EXP 62
25998: PPUSH
25999: LD_INT 9
26001: PPUSH
26002: LD_INT 2
26004: PPUSH
26005: CALL_OW 111
// AddComHold ( Friend ) ;
26009: LD_EXP 62
26013: PPUSH
26014: CALL_OW 200
// end ; end ;
26018: PPOPN 1
26020: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26021: LD_INT 9
26023: PPUSH
26024: LD_INT 2
26026: PPUSH
26027: CALL_OW 428
26031: PUSH
26032: LD_EXP 62
26036: EQUAL
26037: PUSH
26038: LD_EXP 62
26042: PPUSH
26043: CALL_OW 255
26047: PUSH
26048: LD_INT 8
26050: EQUAL
26051: AND
26052: IFFALSE 26066
26054: GO 26056
26056: DISABLE
// RemoveUnit ( Friend ) ;
26057: LD_EXP 62
26061: PPUSH
26062: CALL_OW 64
26066: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26067: LD_EXP 14
26071: PUSH
26072: LD_INT 31500
26074: GREATEREQUAL
26075: PUSH
26076: LD_EXP 7
26080: AND
26081: PUSH
26082: LD_EXP 2
26086: AND
26087: IFFALSE 26517
26089: GO 26091
26091: DISABLE
26092: LD_INT 0
26094: PPUSH
26095: PPUSH
26096: PPUSH
// begin missionStage := 7 ;
26097: LD_ADDR_EXP 15
26101: PUSH
26102: LD_INT 7
26104: ST_TO_ADDR
// uc_side = 1 ;
26105: LD_ADDR_OWVAR 20
26109: PUSH
26110: LD_INT 1
26112: ST_TO_ADDR
// uc_nation = 1 ;
26113: LD_ADDR_OWVAR 21
26117: PUSH
26118: LD_INT 1
26120: ST_TO_ADDR
// for i = 1 to 5 do
26121: LD_ADDR_VAR 0 1
26125: PUSH
26126: DOUBLE
26127: LD_INT 1
26129: DEC
26130: ST_TO_ADDR
26131: LD_INT 5
26133: PUSH
26134: FOR_TO
26135: IFFALSE 26231
// begin vc_engine = 3 ;
26137: LD_ADDR_OWVAR 39
26141: PUSH
26142: LD_INT 3
26144: ST_TO_ADDR
// vc_control = 3 ;
26145: LD_ADDR_OWVAR 38
26149: PUSH
26150: LD_INT 3
26152: ST_TO_ADDR
// vc_chassis = 3 ;
26153: LD_ADDR_OWVAR 37
26157: PUSH
26158: LD_INT 3
26160: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26161: LD_ADDR_OWVAR 40
26165: PUSH
26166: LD_INT 5
26168: PUSH
26169: LD_INT 9
26171: PUSH
26172: LD_INT 7
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: LIST
26179: PUSH
26180: LD_INT 1
26182: PPUSH
26183: LD_INT 3
26185: PPUSH
26186: CALL_OW 12
26190: ARRAY
26191: ST_TO_ADDR
// veh = CreateVehicle ;
26192: LD_ADDR_VAR 0 2
26196: PUSH
26197: CALL_OW 45
26201: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26202: LD_VAR 0 2
26206: PPUSH
26207: LD_INT 1
26209: PPUSH
26210: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26214: LD_VAR 0 2
26218: PPUSH
26219: LD_INT 19
26221: PPUSH
26222: LD_INT 0
26224: PPUSH
26225: CALL_OW 49
// end ;
26229: GO 26134
26231: POP
26232: POP
// vc_engine = 3 ;
26233: LD_ADDR_OWVAR 39
26237: PUSH
26238: LD_INT 3
26240: ST_TO_ADDR
// vc_control = 1 ;
26241: LD_ADDR_OWVAR 38
26245: PUSH
26246: LD_INT 1
26248: ST_TO_ADDR
// vc_chassis = 3 ;
26249: LD_ADDR_OWVAR 37
26253: PUSH
26254: LD_INT 3
26256: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26257: LD_ADDR_OWVAR 40
26261: PUSH
26262: LD_INT 5
26264: PUSH
26265: LD_INT 9
26267: PUSH
26268: LD_INT 7
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 1
26278: PPUSH
26279: LD_INT 3
26281: PPUSH
26282: CALL_OW 12
26286: ARRAY
26287: ST_TO_ADDR
// vehG = CreateVehicle ;
26288: LD_ADDR_VAR 0 3
26292: PUSH
26293: CALL_OW 45
26297: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26298: LD_VAR 0 3
26302: PPUSH
26303: LD_INT 1
26305: PPUSH
26306: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26310: LD_VAR 0 3
26314: PPUSH
26315: LD_INT 19
26317: PPUSH
26318: LD_INT 0
26320: PPUSH
26321: CALL_OW 49
// if JMMGirl = 1 then
26325: LD_EXP 7
26329: PUSH
26330: LD_INT 1
26332: EQUAL
26333: IFFALSE 26389
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26335: LD_ADDR_EXP 40
26339: PUSH
26340: LD_STRING Joan
26342: PPUSH
26343: LD_INT 1
26345: PPUSH
26346: LD_STRING 14_
26348: PPUSH
26349: CALL 64782 0 3
26353: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26354: LD_EXP 40
26358: PPUSH
26359: LD_VAR 0 3
26363: PPUSH
26364: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26368: LD_VAR 0 3
26372: PPUSH
26373: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26377: LD_EXP 40
26381: PPUSH
26382: LD_STRING D10BW-Joan-1
26384: PPUSH
26385: CALL_OW 94
// end ; if JMMGirl = 2 then
26389: LD_EXP 7
26393: PUSH
26394: LD_INT 2
26396: EQUAL
26397: IFFALSE 26453
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26399: LD_ADDR_EXP 42
26403: PUSH
26404: LD_STRING Lisa
26406: PPUSH
26407: LD_INT 1
26409: PPUSH
26410: LD_STRING 14_
26412: PPUSH
26413: CALL 64782 0 3
26417: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26418: LD_EXP 42
26422: PPUSH
26423: LD_VAR 0 3
26427: PPUSH
26428: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26432: LD_VAR 0 3
26436: PPUSH
26437: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26441: LD_EXP 42
26445: PPUSH
26446: LD_STRING D10BW-Lisa-1
26448: PPUSH
26449: CALL_OW 94
// end ; if JMMGirl = 3 then
26453: LD_EXP 7
26457: PUSH
26458: LD_INT 3
26460: EQUAL
26461: IFFALSE 26517
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26463: LD_ADDR_EXP 54
26467: PUSH
26468: LD_STRING Connie
26470: PPUSH
26471: LD_INT 1
26473: PPUSH
26474: LD_STRING 14_
26476: PPUSH
26477: CALL 64782 0 3
26481: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26482: LD_EXP 54
26486: PPUSH
26487: LD_VAR 0 3
26491: PPUSH
26492: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26496: LD_VAR 0 3
26500: PPUSH
26501: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26505: LD_EXP 54
26509: PPUSH
26510: LD_STRING D10BW-Con-1
26512: PPUSH
26513: CALL_OW 94
// end ; end ;
26517: PPOPN 3
26519: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26520: LD_EXP 14
26524: PUSH
26525: LD_INT 94500
26527: GREATEREQUAL
26528: IFFALSE 26940
26530: GO 26532
26532: DISABLE
26533: LD_INT 0
26535: PPUSH
26536: PPUSH
26537: PPUSH
// begin tmp := PrepareStevensSquad ;
26538: LD_ADDR_VAR 0 3
26542: PUSH
26543: CALL 2197 0 0
26547: ST_TO_ADDR
// if not tmp then
26548: LD_VAR 0 3
26552: NOT
26553: IFFALSE 26557
// exit ;
26555: GO 26940
// uc_side := 1 ;
26557: LD_ADDR_OWVAR 20
26561: PUSH
26562: LD_INT 1
26564: ST_TO_ADDR
// uc_nation := 1 ;
26565: LD_ADDR_OWVAR 21
26569: PUSH
26570: LD_INT 1
26572: ST_TO_ADDR
// for i in tmp do
26573: LD_ADDR_VAR 0 1
26577: PUSH
26578: LD_VAR 0 3
26582: PUSH
26583: FOR_IN
26584: IFFALSE 26681
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26586: LD_INT 3
26588: PPUSH
26589: LD_INT 3
26591: PPUSH
26592: LD_INT 1
26594: PPUSH
26595: LD_INT 5
26597: PUSH
26598: LD_INT 9
26600: PUSH
26601: LD_INT 7
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 1
26611: PPUSH
26612: LD_INT 3
26614: PPUSH
26615: CALL_OW 12
26619: ARRAY
26620: PPUSH
26621: LD_INT 40
26623: PPUSH
26624: CALL 71897 0 5
// veh := CreateVehicle ;
26628: LD_ADDR_VAR 0 2
26632: PUSH
26633: CALL_OW 45
26637: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26638: LD_VAR 0 2
26642: PPUSH
26643: LD_INT 1
26645: PPUSH
26646: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26650: LD_VAR 0 2
26654: PPUSH
26655: LD_INT 19
26657: PPUSH
26658: LD_INT 0
26660: PPUSH
26661: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26665: LD_VAR 0 1
26669: PPUSH
26670: LD_VAR 0 2
26674: PPUSH
26675: CALL_OW 52
// end ;
26679: GO 26583
26681: POP
26682: POP
// missionStage := 8 ;
26683: LD_ADDR_EXP 15
26687: PUSH
26688: LD_INT 8
26690: ST_TO_ADDR
// DialogueOn ;
26691: CALL_OW 6
// if Stevens then
26695: LD_EXP 41
26699: IFFALSE 26813
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26701: LD_EXP 41
26705: PPUSH
26706: CALL_OW 310
26710: PPUSH
26711: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26715: LD_EXP 41
26719: PPUSH
26720: LD_STRING D8-Huck-1
26722: PPUSH
26723: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26727: LD_EXP 39
26731: PPUSH
26732: LD_STRING D8-JMM-1
26734: PPUSH
26735: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26739: LD_EXP 41
26743: PPUSH
26744: LD_STRING D8-Huck-2
26746: PPUSH
26747: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26751: LD_EXP 39
26755: PPUSH
26756: LD_STRING D8-JMM-2
26758: PPUSH
26759: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26763: LD_EXP 41
26767: PPUSH
26768: LD_STRING D8-Huck-3
26770: PPUSH
26771: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26775: LD_EXP 39
26779: PPUSH
26780: LD_STRING D8-JMM-3
26782: PPUSH
26783: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26787: LD_EXP 41
26791: PPUSH
26792: LD_STRING D8-Huck-4
26794: PPUSH
26795: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26799: LD_EXP 39
26803: PPUSH
26804: LD_STRING D8-JMM-4
26806: PPUSH
26807: CALL_OW 88
// end else
26811: GO 26923
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26813: LD_EXP 55
26817: PPUSH
26818: CALL_OW 310
26822: PPUSH
26823: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26827: LD_EXP 55
26831: PPUSH
26832: LD_STRING D8-Huck-1
26834: PPUSH
26835: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26839: LD_EXP 39
26843: PPUSH
26844: LD_STRING D8-JMM-1a
26846: PPUSH
26847: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26851: LD_EXP 55
26855: PPUSH
26856: LD_STRING D8-Huck-2
26858: PPUSH
26859: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26863: LD_EXP 39
26867: PPUSH
26868: LD_STRING D8-JMM-2
26870: PPUSH
26871: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26875: LD_EXP 55
26879: PPUSH
26880: LD_STRING D8-Huck-3
26882: PPUSH
26883: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26887: LD_EXP 39
26891: PPUSH
26892: LD_STRING D8-JMM-3
26894: PPUSH
26895: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26899: LD_EXP 55
26903: PPUSH
26904: LD_STRING D8-Huck-4
26906: PPUSH
26907: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26911: LD_EXP 39
26915: PPUSH
26916: LD_STRING D8-JMM-4
26918: PPUSH
26919: CALL_OW 88
// end ; DialogueOff ;
26923: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26927: LD_INT 25
26929: PPUSH
26930: LD_INT 1
26932: PPUSH
26933: LD_INT 1
26935: PPUSH
26936: CALL_OW 322
// end ;
26940: PPOPN 3
26942: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26943: LD_INT 1
26945: PPUSH
26946: LD_EXP 71
26950: PPUSH
26951: CALL_OW 292
26955: IFFALSE 27206
26957: GO 26959
26959: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26960: LD_EXP 71
26964: PPUSH
26965: CALL_OW 87
// DialogueOn ;
26969: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D10nB-JMM-1
26980: PPUSH
26981: CALL_OW 88
// if BurlakStatus = 1 then
26985: LD_EXP 9
26989: PUSH
26990: LD_INT 1
26992: EQUAL
26993: IFFALSE 27007
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26995: LD_EXP 70
26999: PPUSH
27000: LD_STRING D10nB-Vse-1a
27002: PPUSH
27003: CALL_OW 94
// end ; if BurlakStatus = 0 then
27007: LD_EXP 9
27011: PUSH
27012: LD_INT 0
27014: EQUAL
27015: IFFALSE 27029
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27017: LD_EXP 70
27021: PPUSH
27022: LD_STRING D10nB-Vse-1
27024: PPUSH
27025: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27029: LD_EXP 39
27033: PPUSH
27034: LD_STRING D10nB-JMM-2
27036: PPUSH
27037: CALL_OW 88
// if KappaStatus then
27041: LD_EXP 2
27045: IFFALSE 27059
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27047: LD_EXP 70
27051: PPUSH
27052: LD_STRING D10nB-Vse-5a
27054: PPUSH
27055: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27059: LD_EXP 2
27063: NOT
27064: PUSH
27065: LD_EXP 6
27069: PUSH
27070: LD_INT 0
27072: EQUAL
27073: AND
27074: IFFALSE 27202
// begin if JMMGirl = 1 then
27076: LD_EXP 7
27080: PUSH
27081: LD_INT 1
27083: EQUAL
27084: IFFALSE 27134
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27086: LD_EXP 70
27090: PPUSH
27091: LD_STRING D10nB-Vse-2
27093: PPUSH
27094: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27098: LD_EXP 39
27102: PPUSH
27103: LD_STRING D10nB-JMM-3
27105: PPUSH
27106: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27110: LD_EXP 70
27114: PPUSH
27115: LD_STRING D10nB-Vse-3
27117: PPUSH
27118: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-4
27129: PPUSH
27130: CALL_OW 88
// end ; if JMMGirl = 2 then
27134: LD_EXP 7
27138: PUSH
27139: LD_INT 2
27141: EQUAL
27142: IFFALSE 27168
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-4
27151: PPUSH
27152: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27156: LD_EXP 39
27160: PPUSH
27161: LD_STRING D10nB-JMM-5
27163: PPUSH
27164: CALL_OW 88
// end ; if JMMGirl = 3 then
27168: LD_EXP 7
27172: PUSH
27173: LD_INT 3
27175: EQUAL
27176: IFFALSE 27202
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27178: LD_EXP 70
27182: PPUSH
27183: LD_STRING D10nB-Vse-5
27185: PPUSH
27186: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27190: LD_EXP 39
27194: PPUSH
27195: LD_STRING D10nB-JMM-6
27197: PPUSH
27198: CALL_OW 88
// end ; end ; DialogueOff ;
27202: CALL_OW 7
// end ;
27206: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27207: LD_EXP 14
27211: PUSH
27212: LD_INT 115500
27214: GREATEREQUAL
27215: IFFALSE 27591
27217: GO 27219
27219: DISABLE
27220: LD_INT 0
27222: PPUSH
// begin missionStage := 10 ;
27223: LD_ADDR_EXP 15
27227: PUSH
27228: LD_INT 10
27230: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27231: LD_ADDR_VAR 0 1
27235: PUSH
27236: LD_INT 22
27238: PUSH
27239: LD_INT 1
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 23
27248: PUSH
27249: LD_INT 1
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 26
27258: PUSH
27259: LD_INT 1
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 3
27268: PUSH
27269: LD_INT 25
27271: PUSH
27272: LD_INT 12
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: LD_INT 3
27285: PUSH
27286: LD_INT 25
27288: PUSH
27289: LD_INT 16
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: PPUSH
27307: CALL_OW 69
27311: PUSH
27312: LD_EXP 39
27316: PUSH
27317: LD_EXP 60
27321: PUSH
27322: LD_EXP 41
27326: PUSH
27327: LD_EXP 55
27331: PUSH
27332: LD_EXP 42
27336: PUSH
27337: LD_EXP 43
27341: PUSH
27342: LD_EXP 44
27346: PUSH
27347: LD_EXP 45
27351: PUSH
27352: LD_EXP 46
27356: PUSH
27357: LD_EXP 47
27361: PUSH
27362: LD_EXP 48
27366: PUSH
27367: LD_EXP 49
27371: PUSH
27372: LD_EXP 50
27376: PUSH
27377: LD_EXP 51
27381: PUSH
27382: LD_EXP 52
27386: PUSH
27387: LD_EXP 53
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: LIST
27406: LIST
27407: LIST
27408: LIST
27409: DIFF
27410: ST_TO_ADDR
// if not tmp and Brown then
27411: LD_VAR 0 1
27415: NOT
27416: PUSH
27417: LD_EXP 47
27421: AND
27422: IFFALSE 27437
// tmp := [ Brown ] ;
27424: LD_ADDR_VAR 0 1
27428: PUSH
27429: LD_EXP 47
27433: PUSH
27434: EMPTY
27435: LIST
27436: ST_TO_ADDR
// DialogueOn ;
27437: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27441: LD_VAR 0 1
27445: PUSH
27446: LD_INT 1
27448: ARRAY
27449: PPUSH
27450: LD_STRING D11-Sol1-1
27452: PPUSH
27453: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27457: LD_EXP 64
27461: PPUSH
27462: LD_STRING D11-Pla-1
27464: PPUSH
27465: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27469: LD_EXP 65
27473: PPUSH
27474: LD_STRING D11-Kov-1
27476: PPUSH
27477: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27481: LD_EXP 64
27485: PPUSH
27486: LD_STRING D11-Pla-2
27488: PPUSH
27489: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27493: LD_VAR 0 1
27497: PUSH
27498: LD_INT 1
27500: ARRAY
27501: PPUSH
27502: LD_STRING D11-Sol1-2
27504: PPUSH
27505: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27509: LD_EXP 39
27513: PPUSH
27514: LD_STRING D11-JMM-2
27516: PPUSH
27517: CALL_OW 88
// DialogueOff ;
27521: CALL_OW 7
// allowBehemothConstruct := true ;
27525: LD_ADDR_EXP 25
27529: PUSH
27530: LD_INT 1
27532: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27533: LD_STRING M4
27535: PPUSH
27536: CALL_OW 337
// BuildBehemoths ;
27540: CALL 7636 0 0
// repeat wait ( 15 15$00 ) ;
27544: LD_INT 31500
27546: PPUSH
27547: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27551: LD_EXP 27
27555: IFFALSE 27559
// break ;
27557: GO 27591
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27559: LD_INT 267
27561: PPUSH
27562: CALL_OW 274
27566: PPUSH
27567: LD_INT 1
27569: PPUSH
27570: CALL_OW 275
27574: PUSH
27575: LD_INT 1000
27577: GREATEREQUAL
27578: IFFALSE 27584
// BuildBehemoths ;
27580: CALL 7636 0 0
// until not behemothBuilders ;
27584: LD_EXP 73
27588: NOT
27589: IFFALSE 27544
// end ;
27591: PPOPN 1
27593: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27594: LD_EXP 73
27598: NOT
27599: PUSH
27600: LD_EXP 28
27604: NOT
27605: AND
27606: PUSH
27607: LD_EXP 25
27611: AND
27612: IFFALSE 27632
27614: GO 27616
27616: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27617: LD_STRING M4a
27619: PPUSH
27620: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27624: LD_ADDR_EXP 27
27628: PUSH
27629: LD_INT 1
27631: ST_TO_ADDR
// end ;
27632: END
// every 0 0$1 trigger behemothDone do
27633: LD_EXP 28
27637: IFFALSE 27649
27639: GO 27641
27641: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27642: LD_STRING M4b
27644: PPUSH
27645: CALL_OW 337
27649: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27650: LD_EXP 29
27654: NOT
27655: IFFALSE 27851
27657: GO 27659
27659: DISABLE
27660: LD_INT 0
27662: PPUSH
27663: PPUSH
// begin enable ;
27664: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27665: LD_ADDR_VAR 0 1
27669: PUSH
27670: LD_INT 3
27672: PPUSH
27673: CALL 107700 0 1
27677: ST_TO_ADDR
// if not tmp and not behemothDone then
27678: LD_VAR 0 1
27682: NOT
27683: PUSH
27684: LD_EXP 28
27688: NOT
27689: AND
27690: IFFALSE 27726
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27692: LD_ADDR_VAR 0 1
27696: PUSH
27697: LD_INT 22
27699: PUSH
27700: LD_INT 3
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 30
27709: PUSH
27710: LD_INT 37
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PPUSH
27721: CALL_OW 69
27725: ST_TO_ADDR
// if not tmp then
27726: LD_VAR 0 1
27730: NOT
27731: IFFALSE 27735
// exit ;
27733: GO 27851
// for i in tmp do
27735: LD_ADDR_VAR 0 2
27739: PUSH
27740: LD_VAR 0 1
27744: PUSH
27745: FOR_IN
27746: IFFALSE 27849
// if See ( 1 , i ) then
27748: LD_INT 1
27750: PPUSH
27751: LD_VAR 0 2
27755: PPUSH
27756: CALL_OW 292
27760: IFFALSE 27847
// begin if GetType ( i ) = unit_building then
27762: LD_VAR 0 2
27766: PPUSH
27767: CALL_OW 247
27771: PUSH
27772: LD_INT 3
27774: EQUAL
27775: IFFALSE 27813
// begin CenterNowOnUnits ( i ) ;
27777: LD_VAR 0 2
27781: PPUSH
27782: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27786: LD_EXP 39
27790: PPUSH
27791: LD_STRING D17a-JMM-1
27793: PPUSH
27794: CALL_OW 88
// seeBehemoth := true ;
27798: LD_ADDR_EXP 29
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// disable ;
27806: DISABLE
// exit ;
27807: POP
27808: POP
27809: GO 27851
// end else
27811: GO 27847
// begin CenterNowOnUnits ( i ) ;
27813: LD_VAR 0 2
27817: PPUSH
27818: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27822: LD_EXP 39
27826: PPUSH
27827: LD_STRING D17b-JMM-1
27829: PPUSH
27830: CALL_OW 88
// seeBehemoth := true ;
27834: LD_ADDR_EXP 29
27838: PUSH
27839: LD_INT 1
27841: ST_TO_ADDR
// disable ;
27842: DISABLE
// exit ;
27843: POP
27844: POP
27845: GO 27851
// end ; end ;
27847: GO 27745
27849: POP
27850: POP
// end ;
27851: PPOPN 2
27853: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27854: LD_EXP 14
27858: PUSH
27859: LD_INT 116550
27861: GREATEREQUAL
27862: IFFALSE 29038
27864: GO 27866
27866: DISABLE
27867: LD_INT 0
27869: PPUSH
27870: PPUSH
27871: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27872: LD_INT 2
27874: PPUSH
27875: LD_INT 23
27877: PUSH
27878: LD_INT 3
27880: PUSH
27881: LD_INT 3
27883: PUSH
27884: LD_INT 48
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: PPUSH
27896: CALL 58438 0 2
// repeat wait ( 0 0$1 ) ;
27900: LD_INT 35
27902: PPUSH
27903: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27907: LD_INT 22
27909: PUSH
27910: LD_INT 3
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 34
27919: PUSH
27920: LD_INT 48
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PPUSH
27931: CALL_OW 69
27935: IFFALSE 27900
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27937: LD_ADDR_VAR 0 1
27941: PUSH
27942: LD_INT 22
27944: PUSH
27945: LD_INT 3
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PUSH
27952: LD_INT 34
27954: PUSH
27955: LD_INT 48
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PPUSH
27966: CALL_OW 69
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: ST_TO_ADDR
// missionStage := 12 ;
27975: LD_ADDR_EXP 15
27979: PUSH
27980: LD_INT 12
27982: ST_TO_ADDR
// platonovHasBomb := true ;
27983: LD_ADDR_EXP 30
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27991: LD_VAR 0 1
27995: PPUSH
27996: LD_INT 181
27998: PPUSH
27999: LD_INT 86
28001: PPUSH
28002: CALL_OW 171
// AddComHold ( bomb ) ;
28006: LD_VAR 0 1
28010: PPUSH
28011: CALL_OW 200
// wait ( 0 0$10 ) ;
28015: LD_INT 350
28017: PPUSH
28018: CALL_OW 67
// DialogueOn ;
28022: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28026: LD_EXP 64
28030: PPUSH
28031: LD_STRING D15-Pla-1
28033: PPUSH
28034: CALL_OW 94
// dec = Query ( Q15a ) ;
28038: LD_ADDR_VAR 0 2
28042: PUSH
28043: LD_STRING Q15a
28045: PPUSH
28046: CALL_OW 97
28050: ST_TO_ADDR
// if dec = 1 then
28051: LD_VAR 0 2
28055: PUSH
28056: LD_INT 1
28058: EQUAL
28059: IFFALSE 28082
// begin Say ( JMM , D15a-JMM-1 ) ;
28061: LD_EXP 39
28065: PPUSH
28066: LD_STRING D15a-JMM-1
28068: PPUSH
28069: CALL_OW 88
// YouLost ( Surrender ) ;
28073: LD_STRING Surrender
28075: PPUSH
28076: CALL_OW 104
// exit ;
28080: GO 29038
// end ; if dec = 2 then
28082: LD_VAR 0 2
28086: PUSH
28087: LD_INT 2
28089: EQUAL
28090: IFFALSE 28159
// begin Say ( JMM , D15b-JMM-1 ) ;
28092: LD_EXP 39
28096: PPUSH
28097: LD_STRING D15b-JMM-1
28099: PPUSH
28100: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28104: LD_EXP 64
28108: PPUSH
28109: LD_STRING D15b-Pla-1
28111: PPUSH
28112: CALL_OW 94
// DialogueOff ;
28116: CALL_OW 7
// wait ( 3 3$00 ) ;
28120: LD_INT 6300
28122: PPUSH
28123: CALL_OW 67
// DialogueOn ;
28127: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28131: LD_EXP 39
28135: PPUSH
28136: LD_STRING D15d-JMM-1a
28138: PPUSH
28139: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28143: LD_EXP 64
28147: PPUSH
28148: LD_STRING D15d-Pla-1
28150: PPUSH
28151: CALL_OW 94
// DialogueOff ;
28155: CALL_OW 7
// end ; if dec = 3 then
28159: LD_VAR 0 2
28163: PUSH
28164: LD_INT 3
28166: EQUAL
28167: IFFALSE 28221
// begin Say ( JMM , D15c-JMM-1 ) ;
28169: LD_EXP 39
28173: PPUSH
28174: LD_STRING D15c-JMM-1
28176: PPUSH
28177: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28181: LD_EXP 64
28185: PPUSH
28186: LD_STRING D15c-Pla-1
28188: PPUSH
28189: CALL_OW 94
// DialogueOff ;
28193: CALL_OW 7
// wait ( 0 0$15 ) ;
28197: LD_INT 525
28199: PPUSH
28200: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28204: LD_VAR 0 1
28208: PPUSH
28209: LD_INT 60
28211: PPUSH
28212: LD_INT 95
28214: PPUSH
28215: CALL_OW 116
// exit ;
28219: GO 29038
// end ; if dec = 4 then
28221: LD_VAR 0 2
28225: PUSH
28226: LD_INT 4
28228: EQUAL
28229: IFFALSE 28259
// begin Say ( JMM , D15d-JMM-1 ) ;
28231: LD_EXP 39
28235: PPUSH
28236: LD_STRING D15d-JMM-1
28238: PPUSH
28239: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28243: LD_EXP 64
28247: PPUSH
28248: LD_STRING D15d-Pla-1
28250: PPUSH
28251: CALL_OW 94
// DialogueOff ;
28255: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28259: LD_EXP 62
28263: PPUSH
28264: CALL_OW 302
28268: PUSH
28269: LD_EXP 62
28273: PPUSH
28274: CALL_OW 255
28278: PUSH
28279: LD_INT 1
28281: EQUAL
28282: AND
28283: PUSH
28284: LD_INT 22
28286: PUSH
28287: LD_INT 1
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 34
28296: PUSH
28297: LD_INT 8
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: PPUSH
28308: CALL_OW 69
28312: NOT
28313: AND
28314: IFFALSE 28939
// begin SetSide ( Friend , 8 ) ;
28316: LD_EXP 62
28320: PPUSH
28321: LD_INT 8
28323: PPUSH
28324: CALL_OW 235
// if IsInUnit ( Friend ) then
28328: LD_EXP 62
28332: PPUSH
28333: CALL_OW 310
28337: IFFALSE 28348
// ComExitBuilding ( Friend ) ;
28339: LD_EXP 62
28343: PPUSH
28344: CALL_OW 122
// if IsDriver ( Friend ) then
28348: LD_EXP 62
28352: PPUSH
28353: CALL 105377 0 1
28357: IFFALSE 28368
// ComExitVehicle ( Friend ) ;
28359: LD_EXP 62
28363: PPUSH
28364: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28368: LD_EXP 62
28372: PPUSH
28373: LD_INT 9
28375: PPUSH
28376: LD_INT 2
28378: PPUSH
28379: CALL_OW 171
// wait ( 0 0$05 ) ;
28383: LD_INT 175
28385: PPUSH
28386: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28390: LD_EXP 62
28394: PPUSH
28395: CALL_OW 87
// DialogueOn ;
28399: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28403: LD_EXP 39
28407: PPUSH
28408: LD_STRING D16-JMM-1
28410: PPUSH
28411: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28415: LD_EXP 62
28419: PPUSH
28420: LD_STRING D16-Friend-1
28422: PPUSH
28423: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28427: LD_EXP 39
28431: PPUSH
28432: LD_STRING D16-JMM-2
28434: PPUSH
28435: CALL_OW 88
// DialogueOff ;
28439: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28443: LD_EXP 62
28447: PPUSH
28448: LD_INT 1
28450: PPUSH
28451: CALL_OW 235
// ComHold ( Friend ) ;
28455: LD_EXP 62
28459: PPUSH
28460: CALL_OW 140
// wait ( 0 0$20 ) ;
28464: LD_INT 700
28466: PPUSH
28467: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28471: LD_EXP 62
28475: PPUSH
28476: LD_INT 9
28478: PPUSH
28479: LD_INT 2
28481: PPUSH
28482: CALL_OW 297
28486: PUSH
28487: LD_INT 30
28489: LESS
28490: IFFALSE 28559
// begin SetSide ( Friend , 8 ) ;
28492: LD_EXP 62
28496: PPUSH
28497: LD_INT 8
28499: PPUSH
28500: CALL_OW 235
// if IsInUnit ( Friend ) then
28504: LD_EXP 62
28508: PPUSH
28509: CALL_OW 310
28513: IFFALSE 28524
// ComExitBuilding ( Friend ) ;
28515: LD_EXP 62
28519: PPUSH
28520: CALL_OW 122
// if IsDriver ( Friend ) then
28524: LD_EXP 62
28528: PPUSH
28529: CALL 105377 0 1
28533: IFFALSE 28544
// ComExitVehicle ( Friend ) ;
28535: LD_EXP 62
28539: PPUSH
28540: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28544: LD_EXP 62
28548: PPUSH
28549: LD_INT 9
28551: PPUSH
28552: LD_INT 2
28554: PPUSH
28555: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28559: LD_INT 1050
28561: PPUSH
28562: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28566: LD_INT 22
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 34
28578: PUSH
28579: LD_INT 8
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PPUSH
28590: CALL_OW 69
28594: NOT
28595: IFFALSE 28917
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28597: LD_ADDR_VAR 0 3
28601: PUSH
28602: LD_INT 22
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 26
28614: PUSH
28615: LD_INT 1
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 3
28624: PUSH
28625: LD_INT 25
28627: PUSH
28628: LD_INT 12
28630: PUSH
28631: EMPTY
28632: LIST
28633: LIST
28634: PUSH
28635: LD_INT 25
28637: PUSH
28638: LD_INT 16
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: EMPTY
28646: LIST
28647: LIST
28648: LIST
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: LIST
28654: PPUSH
28655: CALL_OW 69
28659: PUSH
28660: LD_EXP 39
28664: PUSH
28665: LD_EXP 41
28669: PUSH
28670: LD_EXP 55
28674: PUSH
28675: LD_EXP 42
28679: PUSH
28680: LD_EXP 43
28684: PUSH
28685: LD_EXP 44
28689: PUSH
28690: LD_EXP 45
28694: PUSH
28695: LD_EXP 46
28699: PUSH
28700: LD_EXP 47
28704: PUSH
28705: LD_EXP 48
28709: PUSH
28710: LD_EXP 49
28714: PUSH
28715: LD_EXP 50
28719: PUSH
28720: LD_EXP 51
28724: PUSH
28725: LD_EXP 52
28729: PUSH
28730: LD_EXP 53
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: LIST
28739: LIST
28740: LIST
28741: LIST
28742: LIST
28743: LIST
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: LIST
28750: LIST
28751: DIFF
28752: ST_TO_ADDR
// DialogueOn ;
28753: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28757: LD_EXP 64
28761: PPUSH
28762: LD_STRING D16a-Pla-1
28764: PPUSH
28765: CALL_OW 94
// if Stevens then
28769: LD_EXP 41
28773: IFFALSE 28789
// Say ( Stevens , D16a-Huck-1 ) else
28775: LD_EXP 41
28779: PPUSH
28780: LD_STRING D16a-Huck-1
28782: PPUSH
28783: CALL_OW 88
28787: GO 28831
// if Baker then
28789: LD_EXP 55
28793: IFFALSE 28809
// Say ( Baker , D16a-Huck-1 ) else
28795: LD_EXP 55
28799: PPUSH
28800: LD_STRING D16a-Huck-1
28802: PPUSH
28803: CALL_OW 88
28807: GO 28831
// if tmp then
28809: LD_VAR 0 3
28813: IFFALSE 28831
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28815: LD_VAR 0 3
28819: PUSH
28820: LD_INT 1
28822: ARRAY
28823: PPUSH
28824: LD_STRING D16a-Sol1-1
28826: PPUSH
28827: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28831: LD_EXP 62
28835: PPUSH
28836: CALL_OW 255
28840: PUSH
28841: LD_INT 8
28843: EQUAL
28844: IFFALSE 28860
// Say ( JMM , D16a-JMM-1 ) else
28846: LD_EXP 39
28850: PPUSH
28851: LD_STRING D16a-JMM-1
28853: PPUSH
28854: CALL_OW 88
28858: GO 28896
// begin Say ( JMM , D16a-JMM-1a ) ;
28860: LD_EXP 39
28864: PPUSH
28865: LD_STRING D16a-JMM-1a
28867: PPUSH
28868: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28872: LD_EXP 62
28876: PPUSH
28877: LD_STRING D16a-Friend-1
28879: PPUSH
28880: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28884: LD_EXP 62
28888: PPUSH
28889: LD_INT 3
28891: PPUSH
28892: CALL_OW 235
// end ; DialogueOff ;
28896: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28900: LD_VAR 0 1
28904: PPUSH
28905: LD_INT 60
28907: PPUSH
28908: LD_INT 95
28910: PPUSH
28911: CALL_OW 116
// end else
28915: GO 28937
// begin DialogueOn ;
28917: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28921: LD_EXP 64
28925: PPUSH
28926: LD_STRING D16c-Pla-
28928: PPUSH
28929: CALL_OW 94
// DialogueOff ;
28933: CALL_OW 7
// end ; end else
28937: GO 29038
// begin wait ( 3 3$00 ) ;
28939: LD_INT 6300
28941: PPUSH
28942: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28946: LD_INT 22
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 34
28958: PUSH
28959: LD_INT 8
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PPUSH
28970: CALL_OW 69
28974: NOT
28975: IFFALSE 29018
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28977: LD_EXP 64
28981: PPUSH
28982: LD_STRING D16b-Pla-1
28984: PPUSH
28985: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28989: LD_EXP 39
28993: PPUSH
28994: LD_STRING D16b-JMM-
28996: PPUSH
28997: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29001: LD_VAR 0 1
29005: PPUSH
29006: LD_INT 60
29008: PPUSH
29009: LD_INT 95
29011: PPUSH
29012: CALL_OW 116
// end else
29016: GO 29038
// begin DialogueOn ;
29018: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29022: LD_EXP 64
29026: PPUSH
29027: LD_STRING D16c-Pla-
29029: PPUSH
29030: CALL_OW 94
// DialogueOff ;
29034: CALL_OW 7
// end ; end ; end ;
29038: PPOPN 3
29040: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29041: LD_EXP 14
29045: PUSH
29046: LD_INT 126000
29048: GREATEREQUAL
29049: PUSH
29050: LD_EXP 23
29054: NOT
29055: AND
29056: PUSH
29057: LD_EXP 74
29061: PPUSH
29062: CALL_OW 302
29066: AND
29067: IFFALSE 29425
29069: GO 29071
29071: DISABLE
29072: LD_INT 0
29074: PPUSH
// begin missionStage = 11 ;
29075: LD_ADDR_EXP 15
29079: PUSH
29080: LD_INT 11
29082: ST_TO_ADDR
// DialogueOn ;
29083: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29087: LD_EXP 74
29091: PPUSH
29092: LD_STRING D9-Roth-1
29094: PPUSH
29095: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29099: LD_EXP 39
29103: PPUSH
29104: LD_STRING D9-JMM-1
29106: PPUSH
29107: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29111: LD_EXP 74
29115: PPUSH
29116: LD_STRING D9-Roth-2
29118: PPUSH
29119: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29123: LD_EXP 74
29127: PPUSH
29128: LD_STRING D9-Roth-2a
29130: PPUSH
29131: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29135: LD_EXP 64
29139: PPUSH
29140: LD_STRING D9-Pla-2
29142: PPUSH
29143: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29147: LD_EXP 74
29151: PPUSH
29152: LD_STRING D9-Roth-3
29154: PPUSH
29155: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29159: LD_EXP 64
29163: PPUSH
29164: LD_STRING D9-Pla-3
29166: PPUSH
29167: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29171: LD_EXP 74
29175: PPUSH
29176: LD_STRING D9-Roth-4
29178: PPUSH
29179: CALL_OW 94
// dec = Query ( Q9 ) ;
29183: LD_ADDR_VAR 0 1
29187: PUSH
29188: LD_STRING Q9
29190: PPUSH
29191: CALL_OW 97
29195: ST_TO_ADDR
// if dec = 1 then
29196: LD_VAR 0 1
29200: PUSH
29201: LD_INT 1
29203: EQUAL
29204: IFFALSE 29218
// SayRadio ( Roth , D9a-Roth-1 ) ;
29206: LD_EXP 74
29210: PPUSH
29211: LD_STRING D9a-Roth-1
29213: PPUSH
29214: CALL_OW 94
// if dec = 2 then
29218: LD_VAR 0 1
29222: PUSH
29223: LD_INT 2
29225: EQUAL
29226: IFFALSE 29252
// begin Say ( JMM , D9b-JMM-1 ) ;
29228: LD_EXP 39
29232: PPUSH
29233: LD_STRING D9b-JMM-1
29235: PPUSH
29236: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29240: LD_EXP 74
29244: PPUSH
29245: LD_STRING D9b-Roth-1
29247: PPUSH
29248: CALL_OW 94
// end ; if dec = 3 then
29252: LD_VAR 0 1
29256: PUSH
29257: LD_INT 3
29259: EQUAL
29260: IFFALSE 29322
// begin Say ( JMM , D9c-JMM-1 ) ;
29262: LD_EXP 39
29266: PPUSH
29267: LD_STRING D9c-JMM-1
29269: PPUSH
29270: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29274: LD_EXP 74
29278: PPUSH
29279: LD_STRING D9c-Roth-1
29281: PPUSH
29282: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29286: LD_EXP 39
29290: PPUSH
29291: LD_STRING D9c-JMM-2
29293: PPUSH
29294: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29298: LD_EXP 74
29302: PPUSH
29303: LD_STRING D9c-Roth-2
29305: PPUSH
29306: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29310: LD_EXP 39
29314: PPUSH
29315: LD_STRING D9c-JMM-3
29317: PPUSH
29318: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29322: LD_EXP 74
29326: PPUSH
29327: LD_STRING D9c-Roth-3
29329: PPUSH
29330: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29334: LD_EXP 74
29338: PPUSH
29339: LD_STRING D9cont-Roth-1
29341: PPUSH
29342: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29346: LD_EXP 39
29350: PPUSH
29351: LD_STRING D9cont-JMM-1
29353: PPUSH
29354: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29358: LD_EXP 74
29362: PPUSH
29363: LD_STRING D9cont-Roth-2
29365: PPUSH
29366: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29370: LD_EXP 39
29374: PPUSH
29375: LD_STRING D9cont-JMM-2
29377: PPUSH
29378: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29382: LD_EXP 74
29386: PPUSH
29387: LD_STRING D9cont-Roth-3
29389: PPUSH
29390: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29394: LD_EXP 39
29398: PPUSH
29399: LD_STRING D9cont-JMM-3
29401: PPUSH
29402: CALL_OW 88
// DialogueOff ;
29406: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29410: LD_STRING M3
29412: PPUSH
29413: CALL_OW 337
// allianceActive := true ;
29417: LD_ADDR_EXP 31
29421: PUSH
29422: LD_INT 1
29424: ST_TO_ADDR
// end ;
29425: PPOPN 1
29427: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29428: LD_EXP 64
29432: PPUSH
29433: CALL_OW 301
29437: PUSH
29438: LD_EXP 67
29442: PPUSH
29443: CALL_OW 301
29447: AND
29448: PUSH
29449: LD_INT 22
29451: PUSH
29452: LD_INT 3
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 21
29461: PUSH
29462: LD_INT 1
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 50
29471: PUSH
29472: EMPTY
29473: LIST
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: LIST
29479: PPUSH
29480: CALL_OW 69
29484: PUSH
29485: LD_INT 7
29487: PUSH
29488: LD_INT 8
29490: PUSH
29491: LD_INT 9
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: LIST
29498: PUSH
29499: LD_OWVAR 67
29503: ARRAY
29504: LESS
29505: AND
29506: IFFALSE 30277
29508: GO 29510
29510: DISABLE
29511: LD_INT 0
29513: PPUSH
29514: PPUSH
29515: PPUSH
29516: PPUSH
// begin MC_Kill ( 1 ) ;
29517: LD_INT 1
29519: PPUSH
29520: CALL 34978 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29524: LD_INT 1
29526: PPUSH
29527: LD_INT 3
29529: PPUSH
29530: LD_INT 1
29532: PPUSH
29533: LD_INT 1
29535: PPUSH
29536: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29540: LD_ADDR_VAR 0 1
29544: PUSH
29545: LD_INT 22
29547: PUSH
29548: LD_INT 3
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 21
29557: PUSH
29558: LD_INT 1
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 24
29567: PUSH
29568: LD_INT 900
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL_OW 69
29584: PUSH
29585: FOR_IN
29586: IFFALSE 29617
// if GetSex ( i ) = sex_male then
29588: LD_VAR 0 1
29592: PPUSH
29593: CALL_OW 258
29597: PUSH
29598: LD_INT 1
29600: EQUAL
29601: IFFALSE 29615
// begin tmp = i ;
29603: LD_ADDR_VAR 0 2
29607: PUSH
29608: LD_VAR 0 1
29612: ST_TO_ADDR
// break ;
29613: GO 29617
// end ;
29615: GO 29585
29617: POP
29618: POP
// if tmp = 0 then
29619: LD_VAR 0 2
29623: PUSH
29624: LD_INT 0
29626: EQUAL
29627: IFFALSE 29681
// begin uc_side = 3 ;
29629: LD_ADDR_OWVAR 20
29633: PUSH
29634: LD_INT 3
29636: ST_TO_ADDR
// uc_nation = 3 ;
29637: LD_ADDR_OWVAR 21
29641: PUSH
29642: LD_INT 3
29644: ST_TO_ADDR
// hc_name =  ;
29645: LD_ADDR_OWVAR 26
29649: PUSH
29650: LD_STRING 
29652: ST_TO_ADDR
// hc_gallery =  ;
29653: LD_ADDR_OWVAR 33
29657: PUSH
29658: LD_STRING 
29660: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29661: LD_INT 1
29663: PPUSH
29664: LD_INT 10
29666: PPUSH
29667: CALL_OW 381
// tmp = CreateHuman ;
29671: LD_ADDR_VAR 0 2
29675: PUSH
29676: CALL_OW 44
29680: ST_TO_ADDR
// end ; DialogueOn ;
29681: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29685: LD_VAR 0 2
29689: PPUSH
29690: LD_STRING DSurrenderRussians-RSol1-1a
29692: PPUSH
29693: CALL_OW 94
// DialogueOff ;
29697: CALL_OW 7
// russianDestroyed := true ;
29701: LD_ADDR_EXP 21
29705: PUSH
29706: LD_INT 1
29708: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29709: LD_INT 22
29711: PUSH
29712: LD_INT 3
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 21
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PPUSH
29738: CALL_OW 122
// wait ( 0 0$1 ) ;
29742: LD_INT 35
29744: PPUSH
29745: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29749: LD_INT 22
29751: PUSH
29752: LD_INT 3
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 21
29761: PUSH
29762: LD_INT 1
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PPUSH
29773: CALL_OW 69
29777: PPUSH
29778: LD_INT 25
29780: PPUSH
29781: CALL_OW 173
// wait ( 0 0$10 ) ;
29785: LD_INT 350
29787: PPUSH
29788: CALL_OW 67
// PrepareOmarInvasion ;
29792: CALL 13756 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29796: LD_ADDR_VAR 0 2
29800: PUSH
29801: LD_EXP 92
29805: PPUSH
29806: CALL_OW 250
29810: PUSH
29811: LD_EXP 92
29815: PPUSH
29816: CALL_OW 251
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29825: LD_VAR 0 2
29829: PUSH
29830: LD_INT 1
29832: ARRAY
29833: PPUSH
29834: LD_VAR 0 2
29838: PUSH
29839: LD_INT 2
29841: ARRAY
29842: PPUSH
29843: LD_INT 1
29845: PPUSH
29846: LD_INT 8
29848: NEG
29849: PPUSH
29850: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29854: LD_EXP 92
29858: PPUSH
29859: CALL_OW 87
// DialogueOn ;
29863: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29867: LD_EXP 39
29871: PPUSH
29872: LD_STRING D19-JMM-1
29874: PPUSH
29875: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29879: LD_ADDR_VAR 0 3
29883: PUSH
29884: LD_INT 22
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 26
29896: PUSH
29897: LD_INT 1
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 2
29906: PUSH
29907: LD_INT 25
29909: PUSH
29910: LD_INT 1
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 25
29919: PUSH
29920: LD_INT 2
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 25
29929: PUSH
29930: LD_INT 3
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 25
29939: PUSH
29940: LD_INT 4
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 25
29949: PUSH
29950: LD_INT 5
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 25
29959: PUSH
29960: LD_INT 8
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: LIST
29980: PPUSH
29981: CALL_OW 69
29985: PUSH
29986: LD_EXP 39
29990: PUSH
29991: LD_EXP 40
29995: PUSH
29996: LD_EXP 41
30000: PUSH
30001: LD_EXP 42
30005: PUSH
30006: LD_EXP 43
30010: PUSH
30011: LD_EXP 44
30015: PUSH
30016: LD_EXP 45
30020: PUSH
30021: LD_EXP 46
30025: PUSH
30026: LD_EXP 47
30030: PUSH
30031: LD_EXP 48
30035: PUSH
30036: LD_EXP 49
30040: PUSH
30041: LD_EXP 50
30045: PUSH
30046: LD_EXP 51
30050: PUSH
30051: LD_EXP 52
30055: PUSH
30056: LD_EXP 53
30060: PUSH
30061: LD_EXP 54
30065: PUSH
30066: LD_EXP 55
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: DIFF
30090: ST_TO_ADDR
// if tmp2 then
30091: LD_VAR 0 3
30095: IFFALSE 30113
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30097: LD_VAR 0 3
30101: PUSH
30102: LD_INT 1
30104: ARRAY
30105: PPUSH
30106: LD_STRING D19-Sol1-1
30108: PPUSH
30109: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30113: LD_EXP 39
30117: PPUSH
30118: LD_STRING D19-JMM-2
30120: PPUSH
30121: CALL_OW 88
// DialogueOff ;
30125: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30129: LD_VAR 0 2
30133: PUSH
30134: LD_INT 1
30136: ARRAY
30137: PPUSH
30138: LD_VAR 0 2
30142: PUSH
30143: LD_INT 2
30145: ARRAY
30146: PPUSH
30147: LD_INT 1
30149: PPUSH
30150: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30154: LD_STRING M5
30156: PPUSH
30157: CALL_OW 337
// omarOnMotherLode := false ;
30161: LD_ADDR_VAR 0 4
30165: PUSH
30166: LD_INT 0
30168: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30169: LD_INT 35
30171: PPUSH
30172: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30176: LD_EXP 92
30180: PPUSH
30181: LD_INT 215
30183: PPUSH
30184: LD_INT 100
30186: PPUSH
30187: CALL_OW 297
30191: PUSH
30192: LD_INT 10
30194: LESS
30195: PUSH
30196: LD_VAR 0 4
30200: NOT
30201: AND
30202: IFFALSE 30236
// begin omarOnMotherLode := true ;
30204: LD_ADDR_VAR 0 4
30208: PUSH
30209: LD_INT 1
30211: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30212: LD_EXP 39
30216: PPUSH
30217: LD_STRING D19b-JMM-1
30219: PPUSH
30220: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30224: LD_EXP 92
30228: PPUSH
30229: LD_STRING DOmarContam-Omar-1
30231: PPUSH
30232: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30236: LD_EXP 92
30240: PPUSH
30241: CALL_OW 301
30245: IFFALSE 30169
// Say ( JMM , D19a-JMM-1 ) ;
30247: LD_EXP 39
30251: PPUSH
30252: LD_STRING D19a-JMM-1
30254: PPUSH
30255: CALL_OW 88
// if Heike then
30259: LD_EXP 93
30263: IFFALSE 30277
// Say ( Heike , D19a-Hke-1 ) ;
30265: LD_EXP 93
30269: PPUSH
30270: LD_STRING D19a-Hke-1
30272: PPUSH
30273: CALL_OW 88
// end ;
30277: PPOPN 4
30279: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30280: LD_INT 22
30282: PUSH
30283: LD_INT 3
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 21
30292: PUSH
30293: LD_INT 1
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PPUSH
30304: CALL_OW 69
30308: PUSH
30309: LD_EXP 21
30313: AND
30314: IFFALSE 30382
30316: GO 30318
30318: DISABLE
30319: LD_INT 0
30321: PPUSH
30322: PPUSH
// begin enable ;
30323: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30324: LD_ADDR_VAR 0 2
30328: PUSH
30329: LD_INT 25
30331: PPUSH
30332: LD_INT 22
30334: PUSH
30335: LD_INT 3
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PPUSH
30342: CALL_OW 70
30346: ST_TO_ADDR
// if not tmp then
30347: LD_VAR 0 2
30351: NOT
30352: IFFALSE 30356
// exit ;
30354: GO 30382
// for i in tmp do
30356: LD_ADDR_VAR 0 1
30360: PUSH
30361: LD_VAR 0 2
30365: PUSH
30366: FOR_IN
30367: IFFALSE 30380
// RemoveUnit ( i ) ;
30369: LD_VAR 0 1
30373: PPUSH
30374: CALL_OW 64
30378: GO 30366
30380: POP
30381: POP
// end ;
30382: PPOPN 2
30384: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30385: LD_INT 22
30387: PUSH
30388: LD_INT 7
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 21
30397: PUSH
30398: LD_INT 1
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PPUSH
30409: CALL_OW 69
30413: PUSH
30414: LD_INT 6
30416: LESS
30417: IFFALSE 30885
30419: GO 30421
30421: DISABLE
30422: LD_INT 0
30424: PPUSH
30425: PPUSH
// begin MC_Kill ( 1 ) ;
30426: LD_INT 1
30428: PPUSH
30429: CALL 34978 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30433: LD_INT 7
30435: PPUSH
30436: LD_INT 1
30438: PPUSH
30439: LD_INT 1
30441: PPUSH
30442: LD_INT 1
30444: PPUSH
30445: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30449: LD_ADDR_VAR 0 1
30453: PUSH
30454: LD_INT 22
30456: PUSH
30457: LD_INT 7
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 26
30466: PUSH
30467: LD_INT 1
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PPUSH
30478: CALL_OW 69
30482: PUSH
30483: LD_EXP 74
30487: DIFF
30488: ST_TO_ADDR
// if tmp then
30489: LD_VAR 0 1
30493: IFFALSE 30511
// tmp := tmp [ 1 ] else
30495: LD_ADDR_VAR 0 1
30499: PUSH
30500: LD_VAR 0 1
30504: PUSH
30505: LD_INT 1
30507: ARRAY
30508: ST_TO_ADDR
30509: GO 30547
// begin uc_side := 7 ;
30511: LD_ADDR_OWVAR 20
30515: PUSH
30516: LD_INT 7
30518: ST_TO_ADDR
// uc_nation := 1 ;
30519: LD_ADDR_OWVAR 21
30523: PUSH
30524: LD_INT 1
30526: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30527: LD_INT 1
30529: PPUSH
30530: LD_INT 8
30532: PPUSH
30533: CALL_OW 384
// tmp := CreateHuman ;
30537: LD_ADDR_VAR 0 1
30541: PUSH
30542: CALL_OW 44
30546: ST_TO_ADDR
// end ; DialogueOn ;
30547: CALL_OW 6
// if IsOK ( Roth ) then
30551: LD_EXP 74
30555: PPUSH
30556: CALL_OW 302
30560: IFFALSE 30574
// Say ( JMM , DAb-JMM-1 ) ;
30562: LD_EXP 39
30566: PPUSH
30567: LD_STRING DAb-JMM-1
30569: PPUSH
30570: CALL_OW 88
// if IsOK ( Roth ) then
30574: LD_EXP 74
30578: PPUSH
30579: CALL_OW 302
30583: IFFALSE 30607
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30585: LD_EXP 74
30589: PPUSH
30590: LD_STRING DSurrenderAlliance-Roth-1
30592: PPUSH
30593: CALL_OW 88
// RothCaptured := true ;
30597: LD_ADDR_EXP 33
30601: PUSH
30602: LD_INT 1
30604: ST_TO_ADDR
// end else
30605: GO 30619
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30607: LD_VAR 0 1
30611: PPUSH
30612: LD_STRING DSurrenderAlliance-Sci1-1
30614: PPUSH
30615: CALL_OW 88
// DialogueOff ;
30619: CALL_OW 7
// allianceDestroyed := true ;
30623: LD_ADDR_EXP 23
30627: PUSH
30628: LD_INT 1
30630: ST_TO_ADDR
// if capturedUnit = 0 then
30631: LD_EXP 34
30635: PUSH
30636: LD_INT 0
30638: EQUAL
30639: IFFALSE 30648
// SetAchievement ( ACH_ALLIANCE ) ;
30641: LD_STRING ACH_ALLIANCE
30643: PPUSH
30644: CALL_OW 543
// if trueAmericans then
30648: LD_EXP 35
30652: IFFALSE 30728
// begin if trueAmericans = 1 then
30654: LD_EXP 35
30658: PUSH
30659: LD_INT 1
30661: EQUAL
30662: IFFALSE 30678
// Say ( JMM , DAb-JMM-1a ) else
30664: LD_EXP 39
30668: PPUSH
30669: LD_STRING DAb-JMM-1a
30671: PPUSH
30672: CALL_OW 88
30676: GO 30690
// Say ( JMM , DAb-JMM-1b ) ;
30678: LD_EXP 39
30682: PPUSH
30683: LD_STRING DAb-JMM-1b
30685: PPUSH
30686: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30690: LD_EXP 35
30694: PPUSH
30695: CALL_OW 87
// for i in trueAmericans do
30699: LD_ADDR_VAR 0 2
30703: PUSH
30704: LD_EXP 35
30708: PUSH
30709: FOR_IN
30710: IFFALSE 30726
// SetSide ( i , 1 ) ;
30712: LD_VAR 0 2
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: CALL_OW 235
30724: GO 30709
30726: POP
30727: POP
// end ; repeat wait ( 0 0$1 ) ;
30728: LD_INT 35
30730: PPUSH
30731: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30735: LD_ADDR_VAR 0 2
30739: PUSH
30740: LD_INT 22
30742: PUSH
30743: LD_INT 7
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 21
30752: PUSH
30753: LD_INT 1
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PPUSH
30764: CALL_OW 69
30768: PUSH
30769: FOR_IN
30770: IFFALSE 30852
// begin if IsInUnit ( i ) then
30772: LD_VAR 0 2
30776: PPUSH
30777: CALL_OW 310
30781: IFFALSE 30792
// ComExitBuilding ( i ) ;
30783: LD_VAR 0 2
30787: PPUSH
30788: CALL_OW 122
// if IsDriver ( i ) then
30792: LD_VAR 0 2
30796: PPUSH
30797: CALL 105377 0 1
30801: IFFALSE 30812
// ComExitVehicle ( i ) ;
30803: LD_VAR 0 2
30807: PPUSH
30808: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30812: LD_VAR 0 2
30816: PPUSH
30817: LD_INT 26
30819: PPUSH
30820: CALL_OW 308
30824: NOT
30825: IFFALSE 30841
// AddComMoveToArea ( i , allianceEscapeArea ) else
30827: LD_VAR 0 2
30831: PPUSH
30832: LD_INT 26
30834: PPUSH
30835: CALL_OW 173
30839: GO 30850
// RemoveUnit ( i ) ;
30841: LD_VAR 0 2
30845: PPUSH
30846: CALL_OW 64
// end ;
30850: GO 30769
30852: POP
30853: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30854: LD_INT 22
30856: PUSH
30857: LD_INT 7
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: LD_INT 21
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: EMPTY
30871: LIST
30872: LIST
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PPUSH
30878: CALL_OW 69
30882: NOT
30883: IFFALSE 30728
// end ;
30885: PPOPN 2
30887: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30888: LD_INT 0
30890: PPUSH
30891: PPUSH
// if not unit then
30892: LD_VAR 0 1
30896: NOT
30897: IFFALSE 30901
// exit ;
30899: GO 32399
// DoNotAttack ( 7 , unit ) ;
30901: LD_INT 7
30903: PPUSH
30904: LD_VAR 0 1
30908: PPUSH
30909: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30913: LD_VAR 0 1
30917: PPUSH
30918: LD_INT 260
30920: PPUSH
30921: LD_INT 235
30923: PPUSH
30924: LD_INT 3
30926: PPUSH
30927: LD_INT 1
30929: PPUSH
30930: CALL_OW 483
// SetSide ( unit , 4 ) ;
30934: LD_VAR 0 1
30938: PPUSH
30939: LD_INT 4
30941: PPUSH
30942: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30946: LD_ADDR_EXP 34
30950: PUSH
30951: LD_EXP 34
30955: PUSH
30956: LD_INT 1
30958: PLUS
30959: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30960: LD_INT 70
30962: PPUSH
30963: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30967: LD_INT 260
30969: PPUSH
30970: LD_INT 235
30972: PPUSH
30973: LD_INT 1
30975: PPUSH
30976: LD_INT 8
30978: NEG
30979: PPUSH
30980: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30984: LD_VAR 0 1
30988: PPUSH
30989: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30993: LD_VAR 0 1
30997: PPUSH
30998: LD_EXP 74
31002: PPUSH
31003: CALL_OW 119
// DialogueOn ;
31007: CALL_OW 6
// case unit of JMM :
31011: LD_VAR 0 1
31015: PUSH
31016: LD_EXP 39
31020: DOUBLE
31021: EQUAL
31022: IFTRUE 31026
31024: GO 31041
31026: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31027: LD_EXP 39
31031: PPUSH
31032: LD_STRING DA1-JMM-1
31034: PPUSH
31035: CALL_OW 91
31039: GO 31483
31041: LD_EXP 40
31045: DOUBLE
31046: EQUAL
31047: IFTRUE 31051
31049: GO 31066
31051: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31052: LD_EXP 40
31056: PPUSH
31057: LD_STRING DA1-Joan-1
31059: PPUSH
31060: CALL_OW 91
31064: GO 31483
31066: LD_EXP 42
31070: DOUBLE
31071: EQUAL
31072: IFTRUE 31076
31074: GO 31091
31076: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31077: LD_EXP 42
31081: PPUSH
31082: LD_STRING DA1-Lisa-1
31084: PPUSH
31085: CALL_OW 91
31089: GO 31483
31091: LD_EXP 43
31095: DOUBLE
31096: EQUAL
31097: IFTRUE 31101
31099: GO 31116
31101: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31102: LD_EXP 43
31106: PPUSH
31107: LD_STRING DA1-Don-1
31109: PPUSH
31110: CALL_OW 91
31114: GO 31483
31116: LD_EXP 50
31120: DOUBLE
31121: EQUAL
31122: IFTRUE 31126
31124: GO 31141
31126: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31127: LD_EXP 50
31131: PPUSH
31132: LD_STRING DA1-Corn-1
31134: PPUSH
31135: CALL_OW 91
31139: GO 31483
31141: LD_EXP 46
31145: DOUBLE
31146: EQUAL
31147: IFTRUE 31151
31149: GO 31166
31151: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31152: LD_EXP 46
31156: PPUSH
31157: LD_STRING DA1-Den-1
31159: PPUSH
31160: CALL_OW 91
31164: GO 31483
31166: LD_EXP 44
31170: DOUBLE
31171: EQUAL
31172: IFTRUE 31176
31174: GO 31191
31176: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31177: LD_EXP 44
31181: PPUSH
31182: LD_STRING DA1-Bobby-1
31184: PPUSH
31185: CALL_OW 91
31189: GO 31483
31191: LD_EXP 48
31195: DOUBLE
31196: EQUAL
31197: IFTRUE 31201
31199: GO 31216
31201: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31202: LD_EXP 48
31206: PPUSH
31207: LD_STRING DA1-Glad-1
31209: PPUSH
31210: CALL_OW 91
31214: GO 31483
31216: LD_EXP 45
31220: DOUBLE
31221: EQUAL
31222: IFTRUE 31226
31224: GO 31241
31226: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31227: LD_EXP 45
31231: PPUSH
31232: LD_STRING DA1-Cyrus-1
31234: PPUSH
31235: CALL_OW 91
31239: GO 31483
31241: LD_EXP 41
31245: DOUBLE
31246: EQUAL
31247: IFTRUE 31251
31249: GO 31266
31251: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31252: LD_EXP 41
31256: PPUSH
31257: LD_STRING DA1-Huck-1
31259: PPUSH
31260: CALL_OW 91
31264: GO 31483
31266: LD_EXP 55
31270: DOUBLE
31271: EQUAL
31272: IFTRUE 31276
31274: GO 31291
31276: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31277: LD_EXP 55
31281: PPUSH
31282: LD_STRING DA1-Huck-1
31284: PPUSH
31285: CALL_OW 91
31289: GO 31483
31291: LD_EXP 47
31295: DOUBLE
31296: EQUAL
31297: IFTRUE 31301
31299: GO 31316
31301: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31302: LD_EXP 47
31306: PPUSH
31307: LD_STRING DA1-Brown-1
31309: PPUSH
31310: CALL_OW 91
31314: GO 31483
31316: LD_EXP 51
31320: DOUBLE
31321: EQUAL
31322: IFTRUE 31326
31324: GO 31341
31326: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31327: LD_EXP 51
31331: PPUSH
31332: LD_STRING DA1-Gary-1
31334: PPUSH
31335: CALL_OW 91
31339: GO 31483
31341: LD_EXP 54
31345: DOUBLE
31346: EQUAL
31347: IFTRUE 31351
31349: GO 31366
31351: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31352: LD_EXP 54
31356: PPUSH
31357: LD_STRING DA1-Con-1
31359: PPUSH
31360: CALL_OW 91
31364: GO 31483
31366: LD_EXP 60
31370: DOUBLE
31371: EQUAL
31372: IFTRUE 31376
31374: GO 31391
31376: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31377: LD_EXP 60
31381: PPUSH
31382: LD_STRING DA1-Kurt-1
31384: PPUSH
31385: CALL_OW 91
31389: GO 31483
31391: LD_EXP 53
31395: DOUBLE
31396: EQUAL
31397: IFTRUE 31401
31399: GO 31416
31401: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31402: LD_EXP 53
31406: PPUSH
31407: LD_STRING DA1-Yam-1
31409: PPUSH
31410: CALL_OW 91
31414: GO 31483
31416: LD_EXP 52
31420: DOUBLE
31421: EQUAL
31422: IFTRUE 31426
31424: GO 31441
31426: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31427: LD_EXP 52
31431: PPUSH
31432: LD_STRING DA1-Frank-1
31434: PPUSH
31435: CALL_OW 91
31439: GO 31483
31441: POP
// begin if GetSex ( unit ) = sex_male then
31442: LD_VAR 0 1
31446: PPUSH
31447: CALL_OW 258
31451: PUSH
31452: LD_INT 1
31454: EQUAL
31455: IFFALSE 31471
// ForceSay ( unit , DA1-Sol1-1 ) else
31457: LD_VAR 0 1
31461: PPUSH
31462: LD_STRING DA1-Sol1-1
31464: PPUSH
31465: CALL_OW 91
31469: GO 31483
// ForceSay ( unit , DA1-FSol1-1 ) ;
31471: LD_VAR 0 1
31475: PPUSH
31476: LD_STRING DA1-FSol1-1
31478: PPUSH
31479: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31483: LD_EXP 74
31487: PPUSH
31488: LD_STRING DA-Roth-1
31490: PPUSH
31491: CALL_OW 88
// if capturedUnit = 1 then
31495: LD_EXP 34
31499: PUSH
31500: LD_INT 1
31502: EQUAL
31503: IFFALSE 31531
// begin Say ( Simms , DA-Sim-1 ) ;
31505: LD_EXP 75
31509: PPUSH
31510: LD_STRING DA-Sim-1
31512: PPUSH
31513: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31517: LD_EXP 74
31521: PPUSH
31522: LD_STRING DA-Roth-2
31524: PPUSH
31525: CALL_OW 88
// end else
31529: GO 31543
// Say ( Simms , DA-Sim-2 ) ;
31531: LD_EXP 75
31535: PPUSH
31536: LD_STRING DA-Sim-2
31538: PPUSH
31539: CALL_OW 88
// case unit of JMM :
31543: LD_VAR 0 1
31547: PUSH
31548: LD_EXP 39
31552: DOUBLE
31553: EQUAL
31554: IFTRUE 31558
31556: GO 31573
31558: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31559: LD_EXP 39
31563: PPUSH
31564: LD_STRING DA1-JMM-1a
31566: PPUSH
31567: CALL_OW 91
31571: GO 32080
31573: LD_EXP 40
31577: DOUBLE
31578: EQUAL
31579: IFTRUE 31583
31581: GO 31598
31583: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31584: LD_EXP 40
31588: PPUSH
31589: LD_STRING DA1-Joan-1a
31591: PPUSH
31592: CALL_OW 91
31596: GO 32080
31598: LD_EXP 42
31602: DOUBLE
31603: EQUAL
31604: IFTRUE 31608
31606: GO 31623
31608: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31609: LD_EXP 42
31613: PPUSH
31614: LD_STRING DA1-Lisa-1a
31616: PPUSH
31617: CALL_OW 91
31621: GO 32080
31623: LD_EXP 43
31627: DOUBLE
31628: EQUAL
31629: IFTRUE 31633
31631: GO 31648
31633: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31634: LD_EXP 43
31638: PPUSH
31639: LD_STRING DA1-Don-1a
31641: PPUSH
31642: CALL_OW 91
31646: GO 32080
31648: LD_EXP 50
31652: DOUBLE
31653: EQUAL
31654: IFTRUE 31658
31656: GO 31673
31658: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31659: LD_EXP 50
31663: PPUSH
31664: LD_STRING DA1-Corn-1a
31666: PPUSH
31667: CALL_OW 91
31671: GO 32080
31673: LD_EXP 46
31677: DOUBLE
31678: EQUAL
31679: IFTRUE 31683
31681: GO 31698
31683: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31684: LD_EXP 46
31688: PPUSH
31689: LD_STRING DA1-Den-1a
31691: PPUSH
31692: CALL_OW 91
31696: GO 32080
31698: LD_EXP 44
31702: DOUBLE
31703: EQUAL
31704: IFTRUE 31708
31706: GO 31723
31708: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31709: LD_EXP 44
31713: PPUSH
31714: LD_STRING DA1-Bobby-1a
31716: PPUSH
31717: CALL_OW 91
31721: GO 32080
31723: LD_EXP 48
31727: DOUBLE
31728: EQUAL
31729: IFTRUE 31733
31731: GO 31748
31733: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31734: LD_EXP 48
31738: PPUSH
31739: LD_STRING DA1-Glad-1a
31741: PPUSH
31742: CALL_OW 91
31746: GO 32080
31748: LD_EXP 45
31752: DOUBLE
31753: EQUAL
31754: IFTRUE 31758
31756: GO 31773
31758: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31759: LD_EXP 45
31763: PPUSH
31764: LD_STRING DA1-Cyrus-1a
31766: PPUSH
31767: CALL_OW 91
31771: GO 32080
31773: LD_EXP 41
31777: DOUBLE
31778: EQUAL
31779: IFTRUE 31783
31781: GO 31798
31783: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31784: LD_EXP 41
31788: PPUSH
31789: LD_STRING DA1-Huck-1a
31791: PPUSH
31792: CALL_OW 91
31796: GO 32080
31798: LD_EXP 55
31802: DOUBLE
31803: EQUAL
31804: IFTRUE 31808
31806: GO 31823
31808: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31809: LD_EXP 55
31813: PPUSH
31814: LD_STRING DA1-Huck-1a
31816: PPUSH
31817: CALL_OW 91
31821: GO 32080
31823: LD_EXP 47
31827: DOUBLE
31828: EQUAL
31829: IFTRUE 31833
31831: GO 31848
31833: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31834: LD_EXP 47
31838: PPUSH
31839: LD_STRING DA1-Brown-1a
31841: PPUSH
31842: CALL_OW 91
31846: GO 32080
31848: LD_EXP 51
31852: DOUBLE
31853: EQUAL
31854: IFTRUE 31858
31856: GO 31873
31858: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31859: LD_EXP 51
31863: PPUSH
31864: LD_STRING DA1-Gary-1a
31866: PPUSH
31867: CALL_OW 91
31871: GO 32080
31873: LD_EXP 54
31877: DOUBLE
31878: EQUAL
31879: IFTRUE 31883
31881: GO 31898
31883: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31884: LD_EXP 54
31888: PPUSH
31889: LD_STRING DA1-Con-1a
31891: PPUSH
31892: CALL_OW 91
31896: GO 32080
31898: LD_EXP 60
31902: DOUBLE
31903: EQUAL
31904: IFTRUE 31908
31906: GO 31923
31908: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31909: LD_EXP 60
31913: PPUSH
31914: LD_STRING DA1-Kurt-1a
31916: PPUSH
31917: CALL_OW 91
31921: GO 32080
31923: LD_EXP 53
31927: DOUBLE
31928: EQUAL
31929: IFTRUE 31933
31931: GO 31948
31933: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31934: LD_EXP 53
31938: PPUSH
31939: LD_STRING DA1-Yam-1a
31941: PPUSH
31942: CALL_OW 91
31946: GO 32080
31948: LD_EXP 52
31952: DOUBLE
31953: EQUAL
31954: IFTRUE 31958
31956: GO 31973
31958: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31959: LD_EXP 52
31963: PPUSH
31964: LD_STRING DA1-Frank-1a
31966: PPUSH
31967: CALL_OW 91
31971: GO 32080
31973: POP
// begin join := rand ( 0 , 1 ) ;
31974: LD_ADDR_VAR 0 3
31978: PUSH
31979: LD_INT 0
31981: PPUSH
31982: LD_INT 1
31984: PPUSH
31985: CALL_OW 12
31989: ST_TO_ADDR
// if join then
31990: LD_VAR 0 3
31994: IFFALSE 32039
// begin if GetSex ( unit ) = sex_male then
31996: LD_VAR 0 1
32000: PPUSH
32001: CALL_OW 258
32005: PUSH
32006: LD_INT 1
32008: EQUAL
32009: IFFALSE 32025
// ForceSay ( unit , DA1-Sol1-1b ) else
32011: LD_VAR 0 1
32015: PPUSH
32016: LD_STRING DA1-Sol1-1b
32018: PPUSH
32019: CALL_OW 91
32023: GO 32037
// ForceSay ( unit , DA1-FSol1-1b ) ;
32025: LD_VAR 0 1
32029: PPUSH
32030: LD_STRING DA1-FSol1-1b
32032: PPUSH
32033: CALL_OW 91
// end else
32037: GO 32080
// begin if GetSex ( unit ) = sex_male then
32039: LD_VAR 0 1
32043: PPUSH
32044: CALL_OW 258
32048: PUSH
32049: LD_INT 1
32051: EQUAL
32052: IFFALSE 32068
// ForceSay ( unit , DA1-Sol1-1a ) else
32054: LD_VAR 0 1
32058: PPUSH
32059: LD_STRING DA1-Sol1-1a
32061: PPUSH
32062: CALL_OW 91
32066: GO 32080
// ForceSay ( unit , DA1-FSol1-1a ) ;
32068: LD_VAR 0 1
32072: PPUSH
32073: LD_STRING DA1-FSol1-1a
32075: PPUSH
32076: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32080: LD_VAR 0 1
32084: PUSH
32085: LD_EXP 39
32089: EQUAL
32090: IFFALSE 32101
// begin YouLost ( JMMCaptured ) ;
32092: LD_STRING JMMCaptured
32094: PPUSH
32095: CALL_OW 104
// exit ;
32099: GO 32399
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32101: LD_VAR 0 1
32105: PUSH
32106: LD_EXP 43
32110: PUSH
32111: LD_EXP 46
32115: PUSH
32116: LD_EXP 44
32120: PUSH
32121: LD_EXP 41
32125: PUSH
32126: LD_EXP 55
32130: PUSH
32131: LD_EXP 47
32135: PUSH
32136: LD_EXP 53
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: IN
32150: PUSH
32151: LD_VAR 0 3
32155: OR
32156: IFFALSE 32255
// begin Say ( Roth , DA-Roth-3 ) ;
32158: LD_EXP 74
32162: PPUSH
32163: LD_STRING DA-Roth-3
32165: PPUSH
32166: CALL_OW 88
// SetSide ( unit , 7 ) ;
32170: LD_VAR 0 1
32174: PPUSH
32175: LD_INT 7
32177: PPUSH
32178: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32182: LD_ADDR_EXP 102
32186: PUSH
32187: LD_EXP 102
32191: PPUSH
32192: LD_INT 1
32194: PPUSH
32195: LD_EXP 102
32199: PUSH
32200: LD_INT 1
32202: ARRAY
32203: PUSH
32204: LD_VAR 0 1
32208: ADD
32209: PPUSH
32210: CALL_OW 1
32214: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32215: LD_INT 260
32217: PPUSH
32218: LD_INT 235
32220: PPUSH
32221: LD_INT 1
32223: PPUSH
32224: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32228: LD_VAR 0 1
32232: PPUSH
32233: LD_INT 1000
32235: PPUSH
32236: CALL_OW 234
// DialogueOff ;
32240: CALL_OW 7
// ComFree ( unit ) ;
32244: LD_VAR 0 1
32248: PPUSH
32249: CALL_OW 139
// end else
32253: GO 32336
// begin Say ( Roth , DA-Roth-3a ) ;
32255: LD_EXP 74
32259: PPUSH
32260: LD_STRING DA-Roth-3a
32262: PPUSH
32263: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32267: LD_ADDR_EXP 35
32271: PUSH
32272: LD_EXP 35
32276: PUSH
32277: LD_VAR 0 1
32281: ADD
32282: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32283: LD_INT 260
32285: PPUSH
32286: LD_INT 235
32288: PPUSH
32289: LD_INT 1
32291: PPUSH
32292: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32296: LD_VAR 0 1
32300: PPUSH
32301: LD_INT 1000
32303: PPUSH
32304: CALL_OW 234
// DialogueOff ;
32308: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32312: LD_VAR 0 1
32316: PPUSH
32317: LD_INT 272
32319: PPUSH
32320: LD_INT 254
32322: PPUSH
32323: CALL_OW 111
// AddComHold ( unit ) ;
32327: LD_VAR 0 1
32331: PPUSH
32332: CALL_OW 200
// end ; if capturedUnit = 1 then
32336: LD_EXP 34
32340: PUSH
32341: LD_INT 1
32343: EQUAL
32344: IFFALSE 32399
// begin DialogueOn ;
32346: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32350: LD_EXP 39
32354: PPUSH
32355: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32359: LD_EXP 39
32363: PPUSH
32364: LD_STRING DAa-JMM-1
32366: PPUSH
32367: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32371: LD_EXP 39
32375: PPUSH
32376: LD_STRING DAa-JMM-1a
32378: PPUSH
32379: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32383: LD_EXP 39
32387: PPUSH
32388: LD_STRING DAa-JMM-1b
32390: PPUSH
32391: CALL_OW 88
// DialogueOff ;
32395: CALL_OW 7
// end ; end ;
32399: LD_VAR 0 2
32403: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32404: LD_EXP 15
32408: PUSH
32409: LD_INT 13
32411: GREATEREQUAL
32412: PUSH
32413: LD_INT 22
32415: PUSH
32416: LD_INT 2
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 21
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PPUSH
32437: CALL_OW 69
32441: PUSH
32442: LD_INT 0
32444: EQUAL
32445: AND
32446: PUSH
32447: LD_INT 22
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 21
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 50
32469: PUSH
32470: EMPTY
32471: LIST
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: LIST
32477: PPUSH
32478: CALL_OW 69
32482: PUSH
32483: LD_INT 0
32485: EQUAL
32486: AND
32487: PUSH
32488: LD_EXP 21
32492: AND
32493: PUSH
32494: LD_EXP 22
32498: AND
32499: PUSH
32500: LD_EXP 23
32504: AND
32505: IFFALSE 33147
32507: GO 32509
32509: DISABLE
32510: LD_INT 0
32512: PPUSH
32513: PPUSH
32514: PPUSH
// begin m1 := false ;
32515: LD_ADDR_VAR 0 1
32519: PUSH
32520: LD_INT 0
32522: ST_TO_ADDR
// m2 := false ;
32523: LD_ADDR_VAR 0 2
32527: PUSH
32528: LD_INT 0
32530: ST_TO_ADDR
// m3 := false ;
32531: LD_ADDR_VAR 0 3
32535: PUSH
32536: LD_INT 0
32538: ST_TO_ADDR
// if not bombExploded then
32539: LD_EXP 37
32543: NOT
32544: IFFALSE 32553
// SetAchievement ( ACH_SIBROCKET ) ;
32546: LD_STRING ACH_SIBROCKET
32548: PPUSH
32549: CALL_OW 543
// if tick <= 120 120$00 then
32553: LD_OWVAR 1
32557: PUSH
32558: LD_INT 252000
32560: LESSEQUAL
32561: IFFALSE 32577
// begin wait ( 3 ) ;
32563: LD_INT 3
32565: PPUSH
32566: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32570: LD_STRING ACH_ASPEED_15
32572: PPUSH
32573: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32577: LD_EXP 39
32581: PPUSH
32582: CALL_OW 87
// music_class := 5 ;
32586: LD_ADDR_OWVAR 72
32590: PUSH
32591: LD_INT 5
32593: ST_TO_ADDR
// music_nat := 5 ;
32594: LD_ADDR_OWVAR 71
32598: PUSH
32599: LD_INT 5
32601: ST_TO_ADDR
// DialogueOn ;
32602: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32606: LD_EXP 39
32610: PPUSH
32611: LD_STRING D20-JMM-1
32613: PPUSH
32614: CALL_OW 88
// if IsOK ( Joan ) then
32618: LD_EXP 40
32622: PPUSH
32623: CALL_OW 302
32627: IFFALSE 32641
// Say ( Joan , D20-Joan-1 ) ;
32629: LD_EXP 40
32633: PPUSH
32634: LD_STRING D20-Joan-1
32636: PPUSH
32637: CALL_OW 88
// if IsOk ( Lisa ) then
32641: LD_EXP 42
32645: PPUSH
32646: CALL_OW 302
32650: IFFALSE 32664
// Say ( Lisa , D20-Lisa-1 ) ;
32652: LD_EXP 42
32656: PPUSH
32657: LD_STRING D20-Lisa-1
32659: PPUSH
32660: CALL_OW 88
// if IsOk ( Donaldson ) then
32664: LD_EXP 43
32668: PPUSH
32669: CALL_OW 302
32673: IFFALSE 32687
// Say ( Donaldson , D20-Don-1 ) ;
32675: LD_EXP 43
32679: PPUSH
32680: LD_STRING D20-Don-1
32682: PPUSH
32683: CALL_OW 88
// if IsOK ( Cornel ) then
32687: LD_EXP 50
32691: PPUSH
32692: CALL_OW 302
32696: IFFALSE 32710
// Say ( Cornel , D20-Corn-1 ) ;
32698: LD_EXP 50
32702: PPUSH
32703: LD_STRING D20-Corn-1
32705: PPUSH
32706: CALL_OW 88
// if IsOk ( Denis ) then
32710: LD_EXP 46
32714: PPUSH
32715: CALL_OW 302
32719: IFFALSE 32733
// Say ( Denis , D20-Den-1 ) ;
32721: LD_EXP 46
32725: PPUSH
32726: LD_STRING D20-Den-1
32728: PPUSH
32729: CALL_OW 88
// if IsOk ( Bobby ) then
32733: LD_EXP 44
32737: PPUSH
32738: CALL_OW 302
32742: IFFALSE 32756
// Say ( Bobby , D20-Bobby-1 ) ;
32744: LD_EXP 44
32748: PPUSH
32749: LD_STRING D20-Bobby-1
32751: PPUSH
32752: CALL_OW 88
// if IsOk ( Gladstone ) then
32756: LD_EXP 48
32760: PPUSH
32761: CALL_OW 302
32765: IFFALSE 32779
// Say ( Gladstone , D20-Glad-1 ) ;
32767: LD_EXP 48
32771: PPUSH
32772: LD_STRING D20-Glad-1
32774: PPUSH
32775: CALL_OW 88
// if IsOk ( Cyrus ) then
32779: LD_EXP 45
32783: PPUSH
32784: CALL_OW 302
32788: IFFALSE 32802
// Say ( Cyrus , D20-Cyrus-1 ) ;
32790: LD_EXP 45
32794: PPUSH
32795: LD_STRING D20-Cyrus-1
32797: PPUSH
32798: CALL_OW 88
// if IsOk ( Stevens ) then
32802: LD_EXP 41
32806: PPUSH
32807: CALL_OW 302
32811: IFFALSE 32825
// Say ( Stevens , D20-Huck-1 ) ;
32813: LD_EXP 41
32817: PPUSH
32818: LD_STRING D20-Huck-1
32820: PPUSH
32821: CALL_OW 88
// if IsOk ( Brown ) then
32825: LD_EXP 47
32829: PPUSH
32830: CALL_OW 302
32834: IFFALSE 32848
// Say ( Brown , D20-Brown-1 ) ;
32836: LD_EXP 47
32840: PPUSH
32841: LD_STRING D20-Brown-1
32843: PPUSH
32844: CALL_OW 88
// if IsOk ( Gary ) then
32848: LD_EXP 51
32852: PPUSH
32853: CALL_OW 302
32857: IFFALSE 32871
// Say ( Gary , D20-Gary-1 ) ;
32859: LD_EXP 51
32863: PPUSH
32864: LD_STRING D20-Gary-1
32866: PPUSH
32867: CALL_OW 88
// if IsOk ( Connie ) then
32871: LD_EXP 54
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Connie , D20-Con-1 ) ;
32882: LD_EXP 54
32886: PPUSH
32887: LD_STRING D20-Con-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Kurt ) then
32894: LD_EXP 60
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Kurt , D20-Kurt-1 ) ;
32905: LD_EXP 60
32909: PPUSH
32910: LD_STRING D20-Kurt-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Kikuchi ) then
32917: LD_EXP 53
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Kikuchi , D20-Yam-1 ) ;
32928: LD_EXP 53
32932: PPUSH
32933: LD_STRING D20-Yam-1
32935: PPUSH
32936: CALL_OW 88
// if IsOk ( Frank ) then
32940: LD_EXP 52
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Frank , D20-Frank-1 ) ;
32951: LD_EXP 52
32955: PPUSH
32956: LD_STRING D20-Frank-1
32958: PPUSH
32959: CALL_OW 88
// DialogueOff ;
32963: CALL_OW 7
// if RothCaptured then
32967: LD_EXP 33
32971: IFFALSE 32993
// begin m1 := true ;
32973: LD_ADDR_VAR 0 1
32977: PUSH
32978: LD_INT 1
32980: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32981: LD_STRING Roth
32983: PPUSH
32984: LD_INT 1
32986: PPUSH
32987: CALL_OW 101
// end else
32991: GO 33004
// AddMedal ( Roth , - 1 ) ;
32993: LD_STRING Roth
32995: PPUSH
32996: LD_INT 1
32998: NEG
32999: PPUSH
33000: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33004: LD_EXP 27
33008: IFFALSE 33030
// begin m2 := true ;
33010: LD_ADDR_VAR 0 2
33014: PUSH
33015: LD_INT 1
33017: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33018: LD_STRING Project
33020: PPUSH
33021: LD_INT 1
33023: PPUSH
33024: CALL_OW 101
// end else
33028: GO 33041
// AddMedal ( Project , - 1 ) ;
33030: LD_STRING Project
33032: PPUSH
33033: LD_INT 1
33035: NEG
33036: PPUSH
33037: CALL_OW 101
// if lostCounter = 0 then
33041: LD_EXP 32
33045: PUSH
33046: LD_INT 0
33048: EQUAL
33049: IFFALSE 33071
// begin m3 := true ;
33051: LD_ADDR_VAR 0 3
33055: PUSH
33056: LD_INT 1
33058: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33059: LD_STRING NoLosses
33061: PPUSH
33062: LD_INT 1
33064: PPUSH
33065: CALL_OW 101
// end else
33069: GO 33082
// AddMedal ( NoLosses , - 1 ) ;
33071: LD_STRING NoLosses
33073: PPUSH
33074: LD_INT 1
33076: NEG
33077: PPUSH
33078: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33082: LD_VAR 0 1
33086: PUSH
33087: LD_VAR 0 2
33091: AND
33092: PUSH
33093: LD_VAR 0 3
33097: AND
33098: PUSH
33099: LD_OWVAR 67
33103: PUSH
33104: LD_INT 3
33106: EQUAL
33107: AND
33108: IFFALSE 33120
// SetAchievementEX ( ACH_AMER , 15 ) ;
33110: LD_STRING ACH_AMER
33112: PPUSH
33113: LD_INT 15
33115: PPUSH
33116: CALL_OW 564
// GiveMedals ( MAIN ) ;
33120: LD_STRING MAIN
33122: PPUSH
33123: CALL_OW 102
// music_class := 4 ;
33127: LD_ADDR_OWVAR 72
33131: PUSH
33132: LD_INT 4
33134: ST_TO_ADDR
// music_nat := 1 ;
33135: LD_ADDR_OWVAR 71
33139: PUSH
33140: LD_INT 1
33142: ST_TO_ADDR
// YouWin ;
33143: CALL_OW 103
// end ; end_of_file
33147: PPOPN 3
33149: END
// export function CustomEvent ( event ) ; begin
33150: LD_INT 0
33152: PPUSH
// end ;
33153: LD_VAR 0 2
33157: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33158: LD_VAR 0 1
33162: PUSH
33163: LD_INT 1
33165: EQUAL
33166: PUSH
33167: LD_VAR 0 2
33171: PUSH
33172: LD_INT 4
33174: EQUAL
33175: AND
33176: PUSH
33177: LD_EXP 58
33181: PPUSH
33182: CALL_OW 300
33186: AND
33187: IFFALSE 33203
// begin wait ( 0 0$2 ) ;
33189: LD_INT 70
33191: PPUSH
33192: CALL_OW 67
// YouLost ( Dismissed ) ;
33196: LD_STRING Dismissed
33198: PPUSH
33199: CALL_OW 104
// end ; end ;
33203: PPOPN 2
33205: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33206: LD_VAR 0 2
33210: PPUSH
33211: LD_VAR 0 3
33215: PPUSH
33216: LD_INT 18
33218: PPUSH
33219: CALL_OW 309
33223: IFFALSE 33232
// YouLost ( Motherlode3 ) ;
33225: LD_STRING Motherlode3
33227: PPUSH
33228: CALL_OW 104
// end ;
33232: PPOPN 3
33234: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33235: LD_EXP 27
33239: NOT
33240: IFFALSE 33250
// behemothDone := true ;
33242: LD_ADDR_EXP 28
33246: PUSH
33247: LD_INT 1
33249: ST_TO_ADDR
// end ;
33250: PPOPN 1
33252: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33253: LD_VAR 0 1
33257: PPUSH
33258: CALL_OW 255
33262: PUSH
33263: LD_INT 1
33265: EQUAL
33266: IFFALSE 33276
// bombExploded := true ;
33268: LD_ADDR_EXP 37
33272: PUSH
33273: LD_INT 1
33275: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33276: LD_VAR 0 1
33280: PPUSH
33281: CALL_OW 255
33285: PUSH
33286: LD_INT 1
33288: EQUAL
33289: PUSH
33290: LD_EXP 30
33294: AND
33295: PUSH
33296: LD_INT 22
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 34
33308: PUSH
33309: LD_INT 48
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PPUSH
33320: CALL_OW 69
33324: AND
33325: PUSH
33326: LD_INT 22
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 34
33338: PUSH
33339: LD_INT 8
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PPUSH
33350: CALL_OW 69
33354: NOT
33355: AND
33356: IFFALSE 33408
// begin wait ( 0 0$5 ) ;
33358: LD_INT 175
33360: PPUSH
33361: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33365: LD_INT 22
33367: PUSH
33368: LD_INT 3
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 34
33377: PUSH
33378: LD_INT 48
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PPUSH
33389: CALL_OW 69
33393: PUSH
33394: LD_INT 1
33396: ARRAY
33397: PPUSH
33398: LD_INT 60
33400: PPUSH
33401: LD_INT 95
33403: PPUSH
33404: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33408: LD_VAR 0 2
33412: PPUSH
33413: LD_VAR 0 3
33417: PPUSH
33418: LD_INT 18
33420: PPUSH
33421: CALL_OW 309
33425: IFFALSE 33485
// begin if GetSide ( unit ) = 1 then
33427: LD_VAR 0 1
33431: PPUSH
33432: CALL_OW 255
33436: PUSH
33437: LD_INT 1
33439: EQUAL
33440: IFFALSE 33456
// begin wait ( 0 0$6 ) ;
33442: LD_INT 210
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33449: LD_STRING Motherlode2
33451: PPUSH
33452: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33456: LD_VAR 0 1
33460: PPUSH
33461: CALL_OW 255
33465: PUSH
33466: LD_INT 8
33468: EQUAL
33469: IFFALSE 33485
// begin wait ( 0 0$6 ) ;
33471: LD_INT 210
33473: PPUSH
33474: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33478: LD_STRING Motherlode1
33480: PPUSH
33481: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33485: LD_VAR 0 1
33489: PPUSH
33490: CALL_OW 255
33494: PUSH
33495: LD_INT 3
33497: EQUAL
33498: IFFALSE 33519
// begin wait ( 0 0$5 ) ;
33500: LD_INT 175
33502: PPUSH
33503: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33507: LD_EXP 64
33511: PPUSH
33512: LD_STRING D18-Pla-1
33514: PPUSH
33515: CALL_OW 94
// end ; end ;
33519: PPOPN 3
33521: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33522: LD_VAR 0 1
33526: PUSH
33527: LD_EXP 73
33531: IN
33532: IFFALSE 33552
// begin behemothBuilders := behemothBuilders diff un ;
33534: LD_ADDR_EXP 73
33538: PUSH
33539: LD_EXP 73
33543: PUSH
33544: LD_VAR 0 1
33548: DIFF
33549: ST_TO_ADDR
// exit ;
33550: GO 33650
// end ; if un = JMM then
33552: LD_VAR 0 1
33556: PUSH
33557: LD_EXP 39
33561: EQUAL
33562: IFFALSE 33573
// begin YouLost ( JMM ) ;
33564: LD_STRING JMM
33566: PPUSH
33567: CALL_OW 104
// exit ;
33571: GO 33650
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33573: LD_VAR 0 1
33577: PUSH
33578: LD_INT 22
33580: PUSH
33581: LD_INT 1
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 3
33590: PUSH
33591: LD_INT 25
33593: PUSH
33594: LD_INT 16
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 25
33603: PUSH
33604: LD_INT 12
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: LIST
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PPUSH
33620: CALL_OW 69
33624: IN
33625: IFFALSE 33641
// lostCounter := lostCounter + 1 ;
33627: LD_ADDR_EXP 32
33631: PUSH
33632: LD_EXP 32
33636: PUSH
33637: LD_INT 1
33639: PLUS
33640: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33641: LD_VAR 0 1
33645: PPUSH
33646: CALL 61830 0 1
// end ;
33650: PPOPN 1
33652: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33653: LD_VAR 0 1
33657: PPUSH
33658: LD_VAR 0 2
33662: PPUSH
33663: CALL 64164 0 2
// end ;
33667: PPOPN 2
33669: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33670: LD_VAR 0 1
33674: PPUSH
33675: CALL 63232 0 1
// end ;
33679: PPOPN 1
33681: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33682: LD_VAR 0 1
33686: PUSH
33687: LD_INT 22
33689: PUSH
33690: LD_INT 8
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 30
33699: PUSH
33700: LD_INT 2
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 23
33709: PUSH
33710: LD_INT 3
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: LIST
33721: PPUSH
33722: CALL_OW 69
33726: IN
33727: IFFALSE 33754
// begin ComUpgrade ( building ) ;
33729: LD_VAR 0 1
33733: PPUSH
33734: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33738: LD_EXP 61
33742: PPUSH
33743: LD_VAR 0 1
33747: PPUSH
33748: CALL 74870 0 2
// exit ;
33752: GO 33763
// end ; MCE_BuildingComplete ( building ) ;
33754: LD_VAR 0 1
33758: PPUSH
33759: CALL 63473 0 1
// end ;
33763: PPOPN 1
33765: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33766: LD_VAR 0 1
33770: PPUSH
33771: LD_VAR 0 2
33775: PPUSH
33776: CALL 61526 0 2
// end ;
33780: PPOPN 2
33782: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33783: LD_VAR 0 1
33787: PPUSH
33788: LD_VAR 0 2
33792: PPUSH
33793: LD_VAR 0 3
33797: PPUSH
33798: LD_VAR 0 4
33802: PPUSH
33803: LD_VAR 0 5
33807: PPUSH
33808: CALL 61146 0 5
// end ;
33812: PPOPN 5
33814: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33815: LD_VAR 0 1
33819: PPUSH
33820: LD_VAR 0 2
33824: PPUSH
33825: CALL 60742 0 2
// end ;
33829: PPOPN 2
33831: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33832: LD_VAR 0 1
33836: PPUSH
33837: LD_VAR 0 2
33841: PPUSH
33842: LD_VAR 0 3
33846: PPUSH
33847: LD_VAR 0 4
33851: PPUSH
33852: CALL 60580 0 4
// end ;
33856: PPOPN 4
33858: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33859: LD_VAR 0 1
33863: PPUSH
33864: LD_VAR 0 2
33868: PPUSH
33869: LD_VAR 0 3
33873: PPUSH
33874: CALL 60355 0 3
// end ;
33878: PPOPN 3
33880: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33881: LD_VAR 0 1
33885: PPUSH
33886: LD_VAR 0 2
33890: PPUSH
33891: CALL 60240 0 2
// end ;
33895: PPOPN 2
33897: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33898: LD_VAR 0 1
33902: PPUSH
33903: LD_VAR 0 2
33907: PPUSH
33908: CALL 64425 0 2
// end ;
33912: PPOPN 2
33914: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33915: LD_VAR 0 1
33919: PPUSH
33920: CALL_OW 255
33924: PUSH
33925: LD_INT 4
33927: EQUAL
33928: PUSH
33929: LD_VAR 0 1
33933: PUSH
33934: LD_EXP 18
33938: PUSH
33939: LD_INT 1
33941: ARRAY
33942: IN
33943: AND
33944: PUSH
33945: LD_EXP 19
33949: AND
33950: IFFALSE 33969
// begin ComMoveXY ( driver , 61 , 93 ) ;
33952: LD_VAR 0 1
33956: PPUSH
33957: LD_INT 61
33959: PPUSH
33960: LD_INT 93
33962: PPUSH
33963: CALL_OW 111
// exit ;
33967: GO 33993
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33969: LD_VAR 0 1
33973: PPUSH
33974: LD_VAR 0 2
33978: PPUSH
33979: LD_VAR 0 3
33983: PPUSH
33984: LD_VAR 0 4
33988: PPUSH
33989: CALL 64641 0 4
// end ;
33993: PPOPN 4
33995: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33996: LD_VAR 0 1
34000: PPUSH
34001: LD_VAR 0 2
34005: PPUSH
34006: CALL 60049 0 2
// end ;
34010: PPOPN 2
34012: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34013: LD_VAR 0 1
34017: PPUSH
34018: CALL 108052 0 1
// end ; end_of_file
34022: PPOPN 1
34024: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34025: LD_EXP 15
34029: PUSH
34030: LD_INT 2
34032: EQUAL
34033: IFFALSE 34512
34035: GO 34037
34037: DISABLE
34038: LD_INT 0
34040: PPUSH
// begin time := 0 0$40 ;
34041: LD_ADDR_VAR 0 1
34045: PUSH
34046: LD_INT 1400
34048: ST_TO_ADDR
// repeat wait ( time ) ;
34049: LD_VAR 0 1
34053: PPUSH
34054: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34058: LD_INT 1
34060: PPUSH
34061: LD_INT 5
34063: PPUSH
34064: CALL_OW 12
34068: PPUSH
34069: LD_INT 106
34071: PPUSH
34072: LD_INT 150
34074: PPUSH
34075: LD_INT 19
34077: PPUSH
34078: LD_INT 1
34080: PPUSH
34081: CALL_OW 56
// time := time + 0 0$9 ;
34085: LD_ADDR_VAR 0 1
34089: PUSH
34090: LD_VAR 0 1
34094: PUSH
34095: LD_INT 315
34097: PLUS
34098: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34099: LD_INT 455
34101: PPUSH
34102: LD_INT 840
34104: PPUSH
34105: CALL_OW 12
34109: PPUSH
34110: CALL_OW 67
// if Prob ( 50 ) then
34114: LD_INT 50
34116: PPUSH
34117: CALL_OW 13
34121: IFFALSE 34150
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34123: LD_INT 1
34125: PPUSH
34126: LD_INT 5
34128: PPUSH
34129: CALL_OW 12
34133: PPUSH
34134: LD_INT 62
34136: PPUSH
34137: LD_INT 108
34139: PPUSH
34140: LD_INT 10
34142: PPUSH
34143: LD_INT 1
34145: PPUSH
34146: CALL_OW 56
// until missionStage > 4 ;
34150: LD_EXP 15
34154: PUSH
34155: LD_INT 4
34157: GREATER
34158: IFFALSE 34049
// repeat wait ( 0 0$1 ) ;
34160: LD_INT 35
34162: PPUSH
34163: CALL_OW 67
// until missionStage = 6 ;
34167: LD_EXP 15
34171: PUSH
34172: LD_INT 6
34174: EQUAL
34175: IFFALSE 34160
// time := 0 0$50 ;
34177: LD_ADDR_VAR 0 1
34181: PUSH
34182: LD_INT 1750
34184: ST_TO_ADDR
// repeat wait ( time ) ;
34185: LD_VAR 0 1
34189: PPUSH
34190: CALL_OW 67
// if Prob ( 50 ) then
34194: LD_INT 50
34196: PPUSH
34197: CALL_OW 13
34201: IFFALSE 34230
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34203: LD_INT 1
34205: PPUSH
34206: LD_INT 5
34208: PPUSH
34209: CALL_OW 12
34213: PPUSH
34214: LD_INT 106
34216: PPUSH
34217: LD_INT 89
34219: PPUSH
34220: LD_INT 45
34222: PPUSH
34223: LD_INT 1
34225: PPUSH
34226: CALL_OW 56
// time := time + 0 0$3 ;
34230: LD_ADDR_VAR 0 1
34234: PUSH
34235: LD_VAR 0 1
34239: PUSH
34240: LD_INT 105
34242: PLUS
34243: ST_TO_ADDR
// if Prob ( 30 ) then
34244: LD_INT 30
34246: PPUSH
34247: CALL_OW 13
34251: IFFALSE 34297
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
34253: LD_INT 525
34255: PPUSH
34256: LD_INT 735
34258: PPUSH
34259: CALL_OW 12
34263: PPUSH
34264: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34268: LD_INT 1
34270: PPUSH
34271: LD_INT 5
34273: PPUSH
34274: CALL_OW 12
34278: PPUSH
34279: LD_INT 21
34281: PPUSH
34282: LD_INT 26
34284: PPUSH
34285: LD_INT 12
34287: PPUSH
34288: LD_INT 1
34290: PPUSH
34291: CALL_OW 56
// end else
34295: GO 34333
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34297: LD_INT 700
34299: PPUSH
34300: LD_INT 1225
34302: PPUSH
34303: CALL_OW 12
34307: PPUSH
34308: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34312: LD_INT 1
34314: PPUSH
34315: LD_INT 5
34317: PPUSH
34318: CALL_OW 12
34322: PPUSH
34323: LD_INT 16
34325: PPUSH
34326: LD_INT 1
34328: PPUSH
34329: CALL_OW 55
// end ; if Prob ( 50 ) then
34333: LD_INT 50
34335: PPUSH
34336: CALL_OW 13
34340: IFFALSE 34386
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34342: LD_INT 700
34344: PPUSH
34345: LD_INT 1050
34347: PPUSH
34348: CALL_OW 12
34352: PPUSH
34353: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34357: LD_INT 1
34359: PPUSH
34360: LD_INT 5
34362: PPUSH
34363: CALL_OW 12
34367: PPUSH
34368: LD_INT 181
34370: PPUSH
34371: LD_INT 218
34373: PPUSH
34374: LD_INT 16
34376: PPUSH
34377: LD_INT 1
34379: PPUSH
34380: CALL_OW 56
// end else
34384: GO 34422
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34386: LD_INT 350
34388: PPUSH
34389: LD_INT 525
34391: PPUSH
34392: CALL_OW 12
34396: PPUSH
34397: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34401: LD_INT 1
34403: PPUSH
34404: LD_INT 5
34406: PPUSH
34407: CALL_OW 12
34411: PPUSH
34412: LD_INT 15
34414: PPUSH
34415: LD_INT 1
34417: PPUSH
34418: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34422: LD_INT 45
34424: PUSH
34425: LD_INT 32
34427: PUSH
34428: LD_INT 25
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: LIST
34435: PUSH
34436: LD_OWVAR 67
34440: ARRAY
34441: PPUSH
34442: CALL_OW 13
34446: IFFALSE 34490
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
34448: LD_INT 525
34450: PPUSH
34451: LD_INT 875
34453: PPUSH
34454: CALL_OW 12
34458: PPUSH
34459: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34463: LD_INT 1
34465: PPUSH
34466: LD_INT 5
34468: PPUSH
34469: CALL_OW 12
34473: PPUSH
34474: LD_INT 103
34476: PPUSH
34477: LD_INT 140
34479: PPUSH
34480: LD_INT 20
34482: PPUSH
34483: LD_INT 1
34485: PPUSH
34486: CALL_OW 56
// end ; if time > 1 1$40 then
34490: LD_VAR 0 1
34494: PUSH
34495: LD_INT 3500
34497: GREATER
34498: IFFALSE 34508
// time := 0 0$50 ;
34500: LD_ADDR_VAR 0 1
34504: PUSH
34505: LD_INT 1750
34507: ST_TO_ADDR
// until false ;
34508: LD_INT 0
34510: IFFALSE 34185
// end ; end_of_file
34512: PPOPN 1
34514: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34515: LD_EXP 13
34519: PUSH
34520: LD_EXP 15
34524: PUSH
34525: LD_INT 6
34527: GREATEREQUAL
34528: AND
34529: IFFALSE 34566
34531: GO 34533
34533: DISABLE
// begin enable ;
34534: ENABLE
// missionTime := missionTime + 0 0$1 ;
34535: LD_ADDR_EXP 14
34539: PUSH
34540: LD_EXP 14
34544: PUSH
34545: LD_INT 35
34547: PLUS
34548: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34549: LD_ADDR_OWVAR 47
34553: PUSH
34554: LD_STRING #Am15-1
34556: PUSH
34557: LD_EXP 14
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: ST_TO_ADDR
// end ; end_of_file
34566: END
// export function InitNature ; begin
34567: LD_INT 0
34569: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34570: LD_INT 3
34572: PPUSH
34573: LD_INT 3
34575: PPUSH
34576: LD_INT 2
34578: PPUSH
34579: LD_INT 1
34581: PPUSH
34582: LD_INT 1
34584: PPUSH
34585: LD_INT 0
34587: PPUSH
34588: LD_INT 0
34590: PPUSH
34591: LD_INT 20
34593: PPUSH
34594: LD_INT 0
34596: PPUSH
34597: CALL 99688 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34601: LD_INT 2
34603: PPUSH
34604: LD_INT 1
34606: PPUSH
34607: LD_INT 1
34609: PPUSH
34610: LD_INT 1
34612: PPUSH
34613: LD_INT 1
34615: PPUSH
34616: LD_INT 0
34618: PPUSH
34619: LD_INT 0
34621: PPUSH
34622: LD_INT 21
34624: PPUSH
34625: LD_INT 0
34627: PPUSH
34628: CALL 99688 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34632: LD_INT 4
34634: PPUSH
34635: LD_INT 1
34637: PPUSH
34638: LD_INT 2
34640: PPUSH
34641: LD_INT 4
34643: PPUSH
34644: LD_INT 2
34646: PPUSH
34647: LD_INT 1
34649: PPUSH
34650: LD_INT 0
34652: PPUSH
34653: LD_INT 22
34655: PPUSH
34656: LD_INT 0
34658: PPUSH
34659: CALL 99688 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34663: LD_INT 0
34665: PPUSH
34666: LD_INT 0
34668: PPUSH
34669: LD_INT 0
34671: PPUSH
34672: LD_INT 0
34674: PPUSH
34675: LD_INT 0
34677: PPUSH
34678: LD_INT 0
34680: PPUSH
34681: LD_INT 9
34683: PPUSH
34684: LD_INT 0
34686: PPUSH
34687: LD_INT 23
34689: PPUSH
34690: CALL 99688 0 9
// end ; end_of_file
34694: LD_VAR 0 1
34698: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34699: GO 34701
34701: DISABLE
// begin ru_radar := 98 ;
34702: LD_ADDR_EXP 95
34706: PUSH
34707: LD_INT 98
34709: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34710: LD_ADDR_EXP 96
34714: PUSH
34715: LD_INT 89
34717: ST_TO_ADDR
// us_hack := 99 ;
34718: LD_ADDR_EXP 97
34722: PUSH
34723: LD_INT 99
34725: ST_TO_ADDR
// us_artillery := 97 ;
34726: LD_ADDR_EXP 98
34730: PUSH
34731: LD_INT 97
34733: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34734: LD_ADDR_EXP 99
34738: PUSH
34739: LD_INT 91
34741: ST_TO_ADDR
// end ; end_of_file
34742: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34743: LD_INT 0
34745: PPUSH
34746: PPUSH
// skirmish := false ;
34747: LD_ADDR_EXP 100
34751: PUSH
34752: LD_INT 0
34754: ST_TO_ADDR
// debug_mc := false ;
34755: LD_ADDR_EXP 101
34759: PUSH
34760: LD_INT 0
34762: ST_TO_ADDR
// mc_bases := [ ] ;
34763: LD_ADDR_EXP 102
34767: PUSH
34768: EMPTY
34769: ST_TO_ADDR
// mc_sides := [ ] ;
34770: LD_ADDR_EXP 128
34774: PUSH
34775: EMPTY
34776: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34777: LD_ADDR_EXP 103
34781: PUSH
34782: EMPTY
34783: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34784: LD_ADDR_EXP 104
34788: PUSH
34789: EMPTY
34790: ST_TO_ADDR
// mc_need_heal := [ ] ;
34791: LD_ADDR_EXP 105
34795: PUSH
34796: EMPTY
34797: ST_TO_ADDR
// mc_healers := [ ] ;
34798: LD_ADDR_EXP 106
34802: PUSH
34803: EMPTY
34804: ST_TO_ADDR
// mc_build_list := [ ] ;
34805: LD_ADDR_EXP 107
34809: PUSH
34810: EMPTY
34811: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34812: LD_ADDR_EXP 134
34816: PUSH
34817: EMPTY
34818: ST_TO_ADDR
// mc_builders := [ ] ;
34819: LD_ADDR_EXP 108
34823: PUSH
34824: EMPTY
34825: ST_TO_ADDR
// mc_construct_list := [ ] ;
34826: LD_ADDR_EXP 109
34830: PUSH
34831: EMPTY
34832: ST_TO_ADDR
// mc_turret_list := [ ] ;
34833: LD_ADDR_EXP 110
34837: PUSH
34838: EMPTY
34839: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34840: LD_ADDR_EXP 111
34844: PUSH
34845: EMPTY
34846: ST_TO_ADDR
// mc_miners := [ ] ;
34847: LD_ADDR_EXP 116
34851: PUSH
34852: EMPTY
34853: ST_TO_ADDR
// mc_mines := [ ] ;
34854: LD_ADDR_EXP 115
34858: PUSH
34859: EMPTY
34860: ST_TO_ADDR
// mc_minefields := [ ] ;
34861: LD_ADDR_EXP 117
34865: PUSH
34866: EMPTY
34867: ST_TO_ADDR
// mc_crates := [ ] ;
34868: LD_ADDR_EXP 118
34872: PUSH
34873: EMPTY
34874: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34875: LD_ADDR_EXP 119
34879: PUSH
34880: EMPTY
34881: ST_TO_ADDR
// mc_crates_area := [ ] ;
34882: LD_ADDR_EXP 120
34886: PUSH
34887: EMPTY
34888: ST_TO_ADDR
// mc_vehicles := [ ] ;
34889: LD_ADDR_EXP 121
34893: PUSH
34894: EMPTY
34895: ST_TO_ADDR
// mc_attack := [ ] ;
34896: LD_ADDR_EXP 122
34900: PUSH
34901: EMPTY
34902: ST_TO_ADDR
// mc_produce := [ ] ;
34903: LD_ADDR_EXP 123
34907: PUSH
34908: EMPTY
34909: ST_TO_ADDR
// mc_defender := [ ] ;
34910: LD_ADDR_EXP 124
34914: PUSH
34915: EMPTY
34916: ST_TO_ADDR
// mc_parking := [ ] ;
34917: LD_ADDR_EXP 126
34921: PUSH
34922: EMPTY
34923: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34924: LD_ADDR_EXP 112
34928: PUSH
34929: EMPTY
34930: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34931: LD_ADDR_EXP 114
34935: PUSH
34936: EMPTY
34937: ST_TO_ADDR
// mc_scan := [ ] ;
34938: LD_ADDR_EXP 125
34942: PUSH
34943: EMPTY
34944: ST_TO_ADDR
// mc_scan_area := [ ] ;
34945: LD_ADDR_EXP 127
34949: PUSH
34950: EMPTY
34951: ST_TO_ADDR
// mc_tech := [ ] ;
34952: LD_ADDR_EXP 129
34956: PUSH
34957: EMPTY
34958: ST_TO_ADDR
// mc_class := [ ] ;
34959: LD_ADDR_EXP 143
34963: PUSH
34964: EMPTY
34965: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34966: LD_ADDR_EXP 144
34970: PUSH
34971: EMPTY
34972: ST_TO_ADDR
// end ;
34973: LD_VAR 0 1
34977: RET
// export function MC_Kill ( base ) ; begin
34978: LD_INT 0
34980: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34981: LD_ADDR_EXP 102
34985: PUSH
34986: LD_EXP 102
34990: PPUSH
34991: LD_VAR 0 1
34995: PPUSH
34996: EMPTY
34997: PPUSH
34998: CALL_OW 1
35002: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35003: LD_ADDR_EXP 103
35007: PUSH
35008: LD_EXP 103
35012: PPUSH
35013: LD_VAR 0 1
35017: PPUSH
35018: EMPTY
35019: PPUSH
35020: CALL_OW 1
35024: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35025: LD_ADDR_EXP 104
35029: PUSH
35030: LD_EXP 104
35034: PPUSH
35035: LD_VAR 0 1
35039: PPUSH
35040: EMPTY
35041: PPUSH
35042: CALL_OW 1
35046: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35047: LD_ADDR_EXP 105
35051: PUSH
35052: LD_EXP 105
35056: PPUSH
35057: LD_VAR 0 1
35061: PPUSH
35062: EMPTY
35063: PPUSH
35064: CALL_OW 1
35068: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35069: LD_ADDR_EXP 106
35073: PUSH
35074: LD_EXP 106
35078: PPUSH
35079: LD_VAR 0 1
35083: PPUSH
35084: EMPTY
35085: PPUSH
35086: CALL_OW 1
35090: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35091: LD_ADDR_EXP 107
35095: PUSH
35096: LD_EXP 107
35100: PPUSH
35101: LD_VAR 0 1
35105: PPUSH
35106: EMPTY
35107: PPUSH
35108: CALL_OW 1
35112: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35113: LD_ADDR_EXP 108
35117: PUSH
35118: LD_EXP 108
35122: PPUSH
35123: LD_VAR 0 1
35127: PPUSH
35128: EMPTY
35129: PPUSH
35130: CALL_OW 1
35134: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35135: LD_ADDR_EXP 109
35139: PUSH
35140: LD_EXP 109
35144: PPUSH
35145: LD_VAR 0 1
35149: PPUSH
35150: EMPTY
35151: PPUSH
35152: CALL_OW 1
35156: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35157: LD_ADDR_EXP 110
35161: PUSH
35162: LD_EXP 110
35166: PPUSH
35167: LD_VAR 0 1
35171: PPUSH
35172: EMPTY
35173: PPUSH
35174: CALL_OW 1
35178: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35179: LD_ADDR_EXP 111
35183: PUSH
35184: LD_EXP 111
35188: PPUSH
35189: LD_VAR 0 1
35193: PPUSH
35194: EMPTY
35195: PPUSH
35196: CALL_OW 1
35200: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35201: LD_ADDR_EXP 112
35205: PUSH
35206: LD_EXP 112
35210: PPUSH
35211: LD_VAR 0 1
35215: PPUSH
35216: EMPTY
35217: PPUSH
35218: CALL_OW 1
35222: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35223: LD_ADDR_EXP 113
35227: PUSH
35228: LD_EXP 113
35232: PPUSH
35233: LD_VAR 0 1
35237: PPUSH
35238: LD_INT 0
35240: PPUSH
35241: CALL_OW 1
35245: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35246: LD_ADDR_EXP 114
35250: PUSH
35251: LD_EXP 114
35255: PPUSH
35256: LD_VAR 0 1
35260: PPUSH
35261: EMPTY
35262: PPUSH
35263: CALL_OW 1
35267: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35268: LD_ADDR_EXP 115
35272: PUSH
35273: LD_EXP 115
35277: PPUSH
35278: LD_VAR 0 1
35282: PPUSH
35283: EMPTY
35284: PPUSH
35285: CALL_OW 1
35289: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35290: LD_ADDR_EXP 116
35294: PUSH
35295: LD_EXP 116
35299: PPUSH
35300: LD_VAR 0 1
35304: PPUSH
35305: EMPTY
35306: PPUSH
35307: CALL_OW 1
35311: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35312: LD_ADDR_EXP 117
35316: PUSH
35317: LD_EXP 117
35321: PPUSH
35322: LD_VAR 0 1
35326: PPUSH
35327: EMPTY
35328: PPUSH
35329: CALL_OW 1
35333: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35334: LD_ADDR_EXP 118
35338: PUSH
35339: LD_EXP 118
35343: PPUSH
35344: LD_VAR 0 1
35348: PPUSH
35349: EMPTY
35350: PPUSH
35351: CALL_OW 1
35355: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35356: LD_ADDR_EXP 119
35360: PUSH
35361: LD_EXP 119
35365: PPUSH
35366: LD_VAR 0 1
35370: PPUSH
35371: EMPTY
35372: PPUSH
35373: CALL_OW 1
35377: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35378: LD_ADDR_EXP 120
35382: PUSH
35383: LD_EXP 120
35387: PPUSH
35388: LD_VAR 0 1
35392: PPUSH
35393: EMPTY
35394: PPUSH
35395: CALL_OW 1
35399: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35400: LD_ADDR_EXP 121
35404: PUSH
35405: LD_EXP 121
35409: PPUSH
35410: LD_VAR 0 1
35414: PPUSH
35415: EMPTY
35416: PPUSH
35417: CALL_OW 1
35421: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35422: LD_ADDR_EXP 122
35426: PUSH
35427: LD_EXP 122
35431: PPUSH
35432: LD_VAR 0 1
35436: PPUSH
35437: EMPTY
35438: PPUSH
35439: CALL_OW 1
35443: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35444: LD_ADDR_EXP 123
35448: PUSH
35449: LD_EXP 123
35453: PPUSH
35454: LD_VAR 0 1
35458: PPUSH
35459: EMPTY
35460: PPUSH
35461: CALL_OW 1
35465: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35466: LD_ADDR_EXP 124
35470: PUSH
35471: LD_EXP 124
35475: PPUSH
35476: LD_VAR 0 1
35480: PPUSH
35481: EMPTY
35482: PPUSH
35483: CALL_OW 1
35487: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35488: LD_ADDR_EXP 125
35492: PUSH
35493: LD_EXP 125
35497: PPUSH
35498: LD_VAR 0 1
35502: PPUSH
35503: EMPTY
35504: PPUSH
35505: CALL_OW 1
35509: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35510: LD_ADDR_EXP 126
35514: PUSH
35515: LD_EXP 126
35519: PPUSH
35520: LD_VAR 0 1
35524: PPUSH
35525: EMPTY
35526: PPUSH
35527: CALL_OW 1
35531: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35532: LD_ADDR_EXP 127
35536: PUSH
35537: LD_EXP 127
35541: PPUSH
35542: LD_VAR 0 1
35546: PPUSH
35547: EMPTY
35548: PPUSH
35549: CALL_OW 1
35553: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35554: LD_ADDR_EXP 129
35558: PUSH
35559: LD_EXP 129
35563: PPUSH
35564: LD_VAR 0 1
35568: PPUSH
35569: EMPTY
35570: PPUSH
35571: CALL_OW 1
35575: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35576: LD_ADDR_EXP 131
35580: PUSH
35581: LD_EXP 131
35585: PPUSH
35586: LD_VAR 0 1
35590: PPUSH
35591: EMPTY
35592: PPUSH
35593: CALL_OW 1
35597: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35598: LD_ADDR_EXP 132
35602: PUSH
35603: LD_EXP 132
35607: PPUSH
35608: LD_VAR 0 1
35612: PPUSH
35613: EMPTY
35614: PPUSH
35615: CALL_OW 1
35619: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35620: LD_ADDR_EXP 133
35624: PUSH
35625: LD_EXP 133
35629: PPUSH
35630: LD_VAR 0 1
35634: PPUSH
35635: EMPTY
35636: PPUSH
35637: CALL_OW 1
35641: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35642: LD_ADDR_EXP 134
35646: PUSH
35647: LD_EXP 134
35651: PPUSH
35652: LD_VAR 0 1
35656: PPUSH
35657: EMPTY
35658: PPUSH
35659: CALL_OW 1
35663: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35664: LD_ADDR_EXP 135
35668: PUSH
35669: LD_EXP 135
35673: PPUSH
35674: LD_VAR 0 1
35678: PPUSH
35679: EMPTY
35680: PPUSH
35681: CALL_OW 1
35685: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35686: LD_ADDR_EXP 136
35690: PUSH
35691: LD_EXP 136
35695: PPUSH
35696: LD_VAR 0 1
35700: PPUSH
35701: EMPTY
35702: PPUSH
35703: CALL_OW 1
35707: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35708: LD_ADDR_EXP 137
35712: PUSH
35713: LD_EXP 137
35717: PPUSH
35718: LD_VAR 0 1
35722: PPUSH
35723: EMPTY
35724: PPUSH
35725: CALL_OW 1
35729: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35730: LD_ADDR_EXP 138
35734: PUSH
35735: LD_EXP 138
35739: PPUSH
35740: LD_VAR 0 1
35744: PPUSH
35745: EMPTY
35746: PPUSH
35747: CALL_OW 1
35751: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35752: LD_ADDR_EXP 139
35756: PUSH
35757: LD_EXP 139
35761: PPUSH
35762: LD_VAR 0 1
35766: PPUSH
35767: EMPTY
35768: PPUSH
35769: CALL_OW 1
35773: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35774: LD_ADDR_EXP 140
35778: PUSH
35779: LD_EXP 140
35783: PPUSH
35784: LD_VAR 0 1
35788: PPUSH
35789: EMPTY
35790: PPUSH
35791: CALL_OW 1
35795: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35796: LD_ADDR_EXP 141
35800: PUSH
35801: LD_EXP 141
35805: PPUSH
35806: LD_VAR 0 1
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35818: LD_ADDR_EXP 142
35822: PUSH
35823: LD_EXP 142
35827: PPUSH
35828: LD_VAR 0 1
35832: PPUSH
35833: EMPTY
35834: PPUSH
35835: CALL_OW 1
35839: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35840: LD_ADDR_EXP 143
35844: PUSH
35845: LD_EXP 143
35849: PPUSH
35850: LD_VAR 0 1
35854: PPUSH
35855: EMPTY
35856: PPUSH
35857: CALL_OW 1
35861: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35862: LD_ADDR_EXP 144
35866: PUSH
35867: LD_EXP 144
35871: PPUSH
35872: LD_VAR 0 1
35876: PPUSH
35877: LD_INT 0
35879: PPUSH
35880: CALL_OW 1
35884: ST_TO_ADDR
// end ;
35885: LD_VAR 0 2
35889: RET
// export function MC_Add ( side , units ) ; var base ; begin
35890: LD_INT 0
35892: PPUSH
35893: PPUSH
// base := mc_bases + 1 ;
35894: LD_ADDR_VAR 0 4
35898: PUSH
35899: LD_EXP 102
35903: PUSH
35904: LD_INT 1
35906: PLUS
35907: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35908: LD_ADDR_EXP 128
35912: PUSH
35913: LD_EXP 128
35917: PPUSH
35918: LD_VAR 0 4
35922: PPUSH
35923: LD_VAR 0 1
35927: PPUSH
35928: CALL_OW 1
35932: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35933: LD_ADDR_EXP 102
35937: PUSH
35938: LD_EXP 102
35942: PPUSH
35943: LD_VAR 0 4
35947: PPUSH
35948: LD_VAR 0 2
35952: PPUSH
35953: CALL_OW 1
35957: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35958: LD_ADDR_EXP 103
35962: PUSH
35963: LD_EXP 103
35967: PPUSH
35968: LD_VAR 0 4
35972: PPUSH
35973: EMPTY
35974: PPUSH
35975: CALL_OW 1
35979: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35980: LD_ADDR_EXP 104
35984: PUSH
35985: LD_EXP 104
35989: PPUSH
35990: LD_VAR 0 4
35994: PPUSH
35995: EMPTY
35996: PPUSH
35997: CALL_OW 1
36001: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36002: LD_ADDR_EXP 105
36006: PUSH
36007: LD_EXP 105
36011: PPUSH
36012: LD_VAR 0 4
36016: PPUSH
36017: EMPTY
36018: PPUSH
36019: CALL_OW 1
36023: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36024: LD_ADDR_EXP 106
36028: PUSH
36029: LD_EXP 106
36033: PPUSH
36034: LD_VAR 0 4
36038: PPUSH
36039: EMPTY
36040: PPUSH
36041: CALL_OW 1
36045: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36046: LD_ADDR_EXP 107
36050: PUSH
36051: LD_EXP 107
36055: PPUSH
36056: LD_VAR 0 4
36060: PPUSH
36061: EMPTY
36062: PPUSH
36063: CALL_OW 1
36067: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36068: LD_ADDR_EXP 108
36072: PUSH
36073: LD_EXP 108
36077: PPUSH
36078: LD_VAR 0 4
36082: PPUSH
36083: EMPTY
36084: PPUSH
36085: CALL_OW 1
36089: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36090: LD_ADDR_EXP 109
36094: PUSH
36095: LD_EXP 109
36099: PPUSH
36100: LD_VAR 0 4
36104: PPUSH
36105: EMPTY
36106: PPUSH
36107: CALL_OW 1
36111: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36112: LD_ADDR_EXP 110
36116: PUSH
36117: LD_EXP 110
36121: PPUSH
36122: LD_VAR 0 4
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL_OW 1
36133: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36134: LD_ADDR_EXP 111
36138: PUSH
36139: LD_EXP 111
36143: PPUSH
36144: LD_VAR 0 4
36148: PPUSH
36149: EMPTY
36150: PPUSH
36151: CALL_OW 1
36155: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36156: LD_ADDR_EXP 112
36160: PUSH
36161: LD_EXP 112
36165: PPUSH
36166: LD_VAR 0 4
36170: PPUSH
36171: EMPTY
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36178: LD_ADDR_EXP 113
36182: PUSH
36183: LD_EXP 113
36187: PPUSH
36188: LD_VAR 0 4
36192: PPUSH
36193: LD_INT 0
36195: PPUSH
36196: CALL_OW 1
36200: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36201: LD_ADDR_EXP 114
36205: PUSH
36206: LD_EXP 114
36210: PPUSH
36211: LD_VAR 0 4
36215: PPUSH
36216: EMPTY
36217: PPUSH
36218: CALL_OW 1
36222: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36223: LD_ADDR_EXP 115
36227: PUSH
36228: LD_EXP 115
36232: PPUSH
36233: LD_VAR 0 4
36237: PPUSH
36238: EMPTY
36239: PPUSH
36240: CALL_OW 1
36244: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36245: LD_ADDR_EXP 116
36249: PUSH
36250: LD_EXP 116
36254: PPUSH
36255: LD_VAR 0 4
36259: PPUSH
36260: EMPTY
36261: PPUSH
36262: CALL_OW 1
36266: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36267: LD_ADDR_EXP 117
36271: PUSH
36272: LD_EXP 117
36276: PPUSH
36277: LD_VAR 0 4
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL_OW 1
36288: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36289: LD_ADDR_EXP 118
36293: PUSH
36294: LD_EXP 118
36298: PPUSH
36299: LD_VAR 0 4
36303: PPUSH
36304: EMPTY
36305: PPUSH
36306: CALL_OW 1
36310: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36311: LD_ADDR_EXP 119
36315: PUSH
36316: LD_EXP 119
36320: PPUSH
36321: LD_VAR 0 4
36325: PPUSH
36326: EMPTY
36327: PPUSH
36328: CALL_OW 1
36332: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36333: LD_ADDR_EXP 120
36337: PUSH
36338: LD_EXP 120
36342: PPUSH
36343: LD_VAR 0 4
36347: PPUSH
36348: EMPTY
36349: PPUSH
36350: CALL_OW 1
36354: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36355: LD_ADDR_EXP 121
36359: PUSH
36360: LD_EXP 121
36364: PPUSH
36365: LD_VAR 0 4
36369: PPUSH
36370: EMPTY
36371: PPUSH
36372: CALL_OW 1
36376: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36377: LD_ADDR_EXP 122
36381: PUSH
36382: LD_EXP 122
36386: PPUSH
36387: LD_VAR 0 4
36391: PPUSH
36392: EMPTY
36393: PPUSH
36394: CALL_OW 1
36398: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36399: LD_ADDR_EXP 123
36403: PUSH
36404: LD_EXP 123
36408: PPUSH
36409: LD_VAR 0 4
36413: PPUSH
36414: EMPTY
36415: PPUSH
36416: CALL_OW 1
36420: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36421: LD_ADDR_EXP 124
36425: PUSH
36426: LD_EXP 124
36430: PPUSH
36431: LD_VAR 0 4
36435: PPUSH
36436: EMPTY
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36443: LD_ADDR_EXP 125
36447: PUSH
36448: LD_EXP 125
36452: PPUSH
36453: LD_VAR 0 4
36457: PPUSH
36458: EMPTY
36459: PPUSH
36460: CALL_OW 1
36464: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36465: LD_ADDR_EXP 126
36469: PUSH
36470: LD_EXP 126
36474: PPUSH
36475: LD_VAR 0 4
36479: PPUSH
36480: EMPTY
36481: PPUSH
36482: CALL_OW 1
36486: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36487: LD_ADDR_EXP 127
36491: PUSH
36492: LD_EXP 127
36496: PPUSH
36497: LD_VAR 0 4
36501: PPUSH
36502: EMPTY
36503: PPUSH
36504: CALL_OW 1
36508: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36509: LD_ADDR_EXP 129
36513: PUSH
36514: LD_EXP 129
36518: PPUSH
36519: LD_VAR 0 4
36523: PPUSH
36524: EMPTY
36525: PPUSH
36526: CALL_OW 1
36530: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36531: LD_ADDR_EXP 131
36535: PUSH
36536: LD_EXP 131
36540: PPUSH
36541: LD_VAR 0 4
36545: PPUSH
36546: EMPTY
36547: PPUSH
36548: CALL_OW 1
36552: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36553: LD_ADDR_EXP 132
36557: PUSH
36558: LD_EXP 132
36562: PPUSH
36563: LD_VAR 0 4
36567: PPUSH
36568: EMPTY
36569: PPUSH
36570: CALL_OW 1
36574: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36575: LD_ADDR_EXP 133
36579: PUSH
36580: LD_EXP 133
36584: PPUSH
36585: LD_VAR 0 4
36589: PPUSH
36590: EMPTY
36591: PPUSH
36592: CALL_OW 1
36596: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36597: LD_ADDR_EXP 134
36601: PUSH
36602: LD_EXP 134
36606: PPUSH
36607: LD_VAR 0 4
36611: PPUSH
36612: EMPTY
36613: PPUSH
36614: CALL_OW 1
36618: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36619: LD_ADDR_EXP 135
36623: PUSH
36624: LD_EXP 135
36628: PPUSH
36629: LD_VAR 0 4
36633: PPUSH
36634: EMPTY
36635: PPUSH
36636: CALL_OW 1
36640: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36641: LD_ADDR_EXP 136
36645: PUSH
36646: LD_EXP 136
36650: PPUSH
36651: LD_VAR 0 4
36655: PPUSH
36656: EMPTY
36657: PPUSH
36658: CALL_OW 1
36662: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36663: LD_ADDR_EXP 137
36667: PUSH
36668: LD_EXP 137
36672: PPUSH
36673: LD_VAR 0 4
36677: PPUSH
36678: EMPTY
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36685: LD_ADDR_EXP 138
36689: PUSH
36690: LD_EXP 138
36694: PPUSH
36695: LD_VAR 0 4
36699: PPUSH
36700: EMPTY
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36707: LD_ADDR_EXP 139
36711: PUSH
36712: LD_EXP 139
36716: PPUSH
36717: LD_VAR 0 4
36721: PPUSH
36722: EMPTY
36723: PPUSH
36724: CALL_OW 1
36728: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36729: LD_ADDR_EXP 140
36733: PUSH
36734: LD_EXP 140
36738: PPUSH
36739: LD_VAR 0 4
36743: PPUSH
36744: EMPTY
36745: PPUSH
36746: CALL_OW 1
36750: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36751: LD_ADDR_EXP 141
36755: PUSH
36756: LD_EXP 141
36760: PPUSH
36761: LD_VAR 0 4
36765: PPUSH
36766: EMPTY
36767: PPUSH
36768: CALL_OW 1
36772: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36773: LD_ADDR_EXP 142
36777: PUSH
36778: LD_EXP 142
36782: PPUSH
36783: LD_VAR 0 4
36787: PPUSH
36788: EMPTY
36789: PPUSH
36790: CALL_OW 1
36794: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36795: LD_ADDR_EXP 143
36799: PUSH
36800: LD_EXP 143
36804: PPUSH
36805: LD_VAR 0 4
36809: PPUSH
36810: EMPTY
36811: PPUSH
36812: CALL_OW 1
36816: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36817: LD_ADDR_EXP 144
36821: PUSH
36822: LD_EXP 144
36826: PPUSH
36827: LD_VAR 0 4
36831: PPUSH
36832: LD_INT 0
36834: PPUSH
36835: CALL_OW 1
36839: ST_TO_ADDR
// result := base ;
36840: LD_ADDR_VAR 0 3
36844: PUSH
36845: LD_VAR 0 4
36849: ST_TO_ADDR
// end ;
36850: LD_VAR 0 3
36854: RET
// export function MC_Start ( ) ; var i ; begin
36855: LD_INT 0
36857: PPUSH
36858: PPUSH
// for i = 1 to mc_bases do
36859: LD_ADDR_VAR 0 2
36863: PUSH
36864: DOUBLE
36865: LD_INT 1
36867: DEC
36868: ST_TO_ADDR
36869: LD_EXP 102
36873: PUSH
36874: FOR_TO
36875: IFFALSE 37952
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36877: LD_ADDR_EXP 102
36881: PUSH
36882: LD_EXP 102
36886: PPUSH
36887: LD_VAR 0 2
36891: PPUSH
36892: LD_EXP 102
36896: PUSH
36897: LD_VAR 0 2
36901: ARRAY
36902: PUSH
36903: LD_INT 0
36905: DIFF
36906: PPUSH
36907: CALL_OW 1
36911: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36912: LD_ADDR_EXP 103
36916: PUSH
36917: LD_EXP 103
36921: PPUSH
36922: LD_VAR 0 2
36926: PPUSH
36927: EMPTY
36928: PPUSH
36929: CALL_OW 1
36933: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36934: LD_ADDR_EXP 104
36938: PUSH
36939: LD_EXP 104
36943: PPUSH
36944: LD_VAR 0 2
36948: PPUSH
36949: EMPTY
36950: PPUSH
36951: CALL_OW 1
36955: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36956: LD_ADDR_EXP 105
36960: PUSH
36961: LD_EXP 105
36965: PPUSH
36966: LD_VAR 0 2
36970: PPUSH
36971: EMPTY
36972: PPUSH
36973: CALL_OW 1
36977: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36978: LD_ADDR_EXP 106
36982: PUSH
36983: LD_EXP 106
36987: PPUSH
36988: LD_VAR 0 2
36992: PPUSH
36993: EMPTY
36994: PUSH
36995: EMPTY
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PPUSH
37001: CALL_OW 1
37005: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37006: LD_ADDR_EXP 107
37010: PUSH
37011: LD_EXP 107
37015: PPUSH
37016: LD_VAR 0 2
37020: PPUSH
37021: EMPTY
37022: PPUSH
37023: CALL_OW 1
37027: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37028: LD_ADDR_EXP 134
37032: PUSH
37033: LD_EXP 134
37037: PPUSH
37038: LD_VAR 0 2
37042: PPUSH
37043: EMPTY
37044: PPUSH
37045: CALL_OW 1
37049: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37050: LD_ADDR_EXP 108
37054: PUSH
37055: LD_EXP 108
37059: PPUSH
37060: LD_VAR 0 2
37064: PPUSH
37065: EMPTY
37066: PPUSH
37067: CALL_OW 1
37071: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37072: LD_ADDR_EXP 109
37076: PUSH
37077: LD_EXP 109
37081: PPUSH
37082: LD_VAR 0 2
37086: PPUSH
37087: EMPTY
37088: PPUSH
37089: CALL_OW 1
37093: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37094: LD_ADDR_EXP 110
37098: PUSH
37099: LD_EXP 110
37103: PPUSH
37104: LD_VAR 0 2
37108: PPUSH
37109: LD_EXP 102
37113: PUSH
37114: LD_VAR 0 2
37118: ARRAY
37119: PPUSH
37120: LD_INT 2
37122: PUSH
37123: LD_INT 30
37125: PUSH
37126: LD_INT 32
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 30
37135: PUSH
37136: LD_INT 33
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: LIST
37147: PPUSH
37148: CALL_OW 72
37152: PPUSH
37153: CALL_OW 1
37157: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37158: LD_ADDR_EXP 111
37162: PUSH
37163: LD_EXP 111
37167: PPUSH
37168: LD_VAR 0 2
37172: PPUSH
37173: LD_EXP 102
37177: PUSH
37178: LD_VAR 0 2
37182: ARRAY
37183: PPUSH
37184: LD_INT 2
37186: PUSH
37187: LD_INT 30
37189: PUSH
37190: LD_INT 32
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 30
37199: PUSH
37200: LD_INT 31
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 58
37214: PUSH
37215: EMPTY
37216: LIST
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PPUSH
37222: CALL_OW 72
37226: PPUSH
37227: CALL_OW 1
37231: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37232: LD_ADDR_EXP 112
37236: PUSH
37237: LD_EXP 112
37241: PPUSH
37242: LD_VAR 0 2
37246: PPUSH
37247: EMPTY
37248: PPUSH
37249: CALL_OW 1
37253: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37254: LD_ADDR_EXP 116
37258: PUSH
37259: LD_EXP 116
37263: PPUSH
37264: LD_VAR 0 2
37268: PPUSH
37269: EMPTY
37270: PPUSH
37271: CALL_OW 1
37275: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37276: LD_ADDR_EXP 115
37280: PUSH
37281: LD_EXP 115
37285: PPUSH
37286: LD_VAR 0 2
37290: PPUSH
37291: EMPTY
37292: PPUSH
37293: CALL_OW 1
37297: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37298: LD_ADDR_EXP 117
37302: PUSH
37303: LD_EXP 117
37307: PPUSH
37308: LD_VAR 0 2
37312: PPUSH
37313: EMPTY
37314: PPUSH
37315: CALL_OW 1
37319: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37320: LD_ADDR_EXP 118
37324: PUSH
37325: LD_EXP 118
37329: PPUSH
37330: LD_VAR 0 2
37334: PPUSH
37335: EMPTY
37336: PPUSH
37337: CALL_OW 1
37341: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37342: LD_ADDR_EXP 119
37346: PUSH
37347: LD_EXP 119
37351: PPUSH
37352: LD_VAR 0 2
37356: PPUSH
37357: EMPTY
37358: PPUSH
37359: CALL_OW 1
37363: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37364: LD_ADDR_EXP 120
37368: PUSH
37369: LD_EXP 120
37373: PPUSH
37374: LD_VAR 0 2
37378: PPUSH
37379: EMPTY
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37386: LD_ADDR_EXP 121
37390: PUSH
37391: LD_EXP 121
37395: PPUSH
37396: LD_VAR 0 2
37400: PPUSH
37401: EMPTY
37402: PPUSH
37403: CALL_OW 1
37407: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37408: LD_ADDR_EXP 122
37412: PUSH
37413: LD_EXP 122
37417: PPUSH
37418: LD_VAR 0 2
37422: PPUSH
37423: EMPTY
37424: PPUSH
37425: CALL_OW 1
37429: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37430: LD_ADDR_EXP 123
37434: PUSH
37435: LD_EXP 123
37439: PPUSH
37440: LD_VAR 0 2
37444: PPUSH
37445: EMPTY
37446: PPUSH
37447: CALL_OW 1
37451: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37452: LD_ADDR_EXP 124
37456: PUSH
37457: LD_EXP 124
37461: PPUSH
37462: LD_VAR 0 2
37466: PPUSH
37467: EMPTY
37468: PPUSH
37469: CALL_OW 1
37473: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37474: LD_ADDR_EXP 113
37478: PUSH
37479: LD_EXP 113
37483: PPUSH
37484: LD_VAR 0 2
37488: PPUSH
37489: LD_INT 0
37491: PPUSH
37492: CALL_OW 1
37496: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37497: LD_ADDR_EXP 126
37501: PUSH
37502: LD_EXP 126
37506: PPUSH
37507: LD_VAR 0 2
37511: PPUSH
37512: LD_INT 0
37514: PPUSH
37515: CALL_OW 1
37519: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37520: LD_ADDR_EXP 114
37524: PUSH
37525: LD_EXP 114
37529: PPUSH
37530: LD_VAR 0 2
37534: PPUSH
37535: EMPTY
37536: PPUSH
37537: CALL_OW 1
37541: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37542: LD_ADDR_EXP 125
37546: PUSH
37547: LD_EXP 125
37551: PPUSH
37552: LD_VAR 0 2
37556: PPUSH
37557: LD_INT 0
37559: PPUSH
37560: CALL_OW 1
37564: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37565: LD_ADDR_EXP 127
37569: PUSH
37570: LD_EXP 127
37574: PPUSH
37575: LD_VAR 0 2
37579: PPUSH
37580: EMPTY
37581: PPUSH
37582: CALL_OW 1
37586: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37587: LD_ADDR_EXP 130
37591: PUSH
37592: LD_EXP 130
37596: PPUSH
37597: LD_VAR 0 2
37601: PPUSH
37602: LD_INT 0
37604: PPUSH
37605: CALL_OW 1
37609: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37610: LD_ADDR_EXP 131
37614: PUSH
37615: LD_EXP 131
37619: PPUSH
37620: LD_VAR 0 2
37624: PPUSH
37625: EMPTY
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37632: LD_ADDR_EXP 132
37636: PUSH
37637: LD_EXP 132
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37654: LD_ADDR_EXP 133
37658: PUSH
37659: LD_EXP 133
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL_OW 1
37675: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37676: LD_ADDR_EXP 135
37680: PUSH
37681: LD_EXP 135
37685: PPUSH
37686: LD_VAR 0 2
37690: PPUSH
37691: LD_EXP 102
37695: PUSH
37696: LD_VAR 0 2
37700: ARRAY
37701: PPUSH
37702: LD_INT 2
37704: PUSH
37705: LD_INT 30
37707: PUSH
37708: LD_INT 6
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 30
37717: PUSH
37718: LD_INT 7
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 30
37727: PUSH
37728: LD_INT 8
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: PPUSH
37741: CALL_OW 72
37745: PPUSH
37746: CALL_OW 1
37750: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37751: LD_ADDR_EXP 136
37755: PUSH
37756: LD_EXP 136
37760: PPUSH
37761: LD_VAR 0 2
37765: PPUSH
37766: EMPTY
37767: PPUSH
37768: CALL_OW 1
37772: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37773: LD_ADDR_EXP 137
37777: PUSH
37778: LD_EXP 137
37782: PPUSH
37783: LD_VAR 0 2
37787: PPUSH
37788: EMPTY
37789: PPUSH
37790: CALL_OW 1
37794: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37795: LD_ADDR_EXP 138
37799: PUSH
37800: LD_EXP 138
37804: PPUSH
37805: LD_VAR 0 2
37809: PPUSH
37810: EMPTY
37811: PPUSH
37812: CALL_OW 1
37816: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37817: LD_ADDR_EXP 139
37821: PUSH
37822: LD_EXP 139
37826: PPUSH
37827: LD_VAR 0 2
37831: PPUSH
37832: EMPTY
37833: PPUSH
37834: CALL_OW 1
37838: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37839: LD_ADDR_EXP 140
37843: PUSH
37844: LD_EXP 140
37848: PPUSH
37849: LD_VAR 0 2
37853: PPUSH
37854: EMPTY
37855: PPUSH
37856: CALL_OW 1
37860: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37861: LD_ADDR_EXP 141
37865: PUSH
37866: LD_EXP 141
37870: PPUSH
37871: LD_VAR 0 2
37875: PPUSH
37876: EMPTY
37877: PPUSH
37878: CALL_OW 1
37882: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37883: LD_ADDR_EXP 142
37887: PUSH
37888: LD_EXP 142
37892: PPUSH
37893: LD_VAR 0 2
37897: PPUSH
37898: EMPTY
37899: PPUSH
37900: CALL_OW 1
37904: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37905: LD_ADDR_EXP 143
37909: PUSH
37910: LD_EXP 143
37914: PPUSH
37915: LD_VAR 0 2
37919: PPUSH
37920: EMPTY
37921: PPUSH
37922: CALL_OW 1
37926: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37927: LD_ADDR_EXP 144
37931: PUSH
37932: LD_EXP 144
37936: PPUSH
37937: LD_VAR 0 2
37941: PPUSH
37942: LD_INT 0
37944: PPUSH
37945: CALL_OW 1
37949: ST_TO_ADDR
// end ;
37950: GO 36874
37952: POP
37953: POP
// MC_InitSides ( ) ;
37954: CALL 38240 0 0
// MC_InitResearch ( ) ;
37958: CALL 37979 0 0
// CustomInitMacro ( ) ;
37962: CALL 467 0 0
// skirmish := true ;
37966: LD_ADDR_EXP 100
37970: PUSH
37971: LD_INT 1
37973: ST_TO_ADDR
// end ;
37974: LD_VAR 0 1
37978: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37979: LD_INT 0
37981: PPUSH
37982: PPUSH
37983: PPUSH
37984: PPUSH
37985: PPUSH
37986: PPUSH
// if not mc_bases then
37987: LD_EXP 102
37991: NOT
37992: IFFALSE 37996
// exit ;
37994: GO 38235
// for i = 1 to 8 do
37996: LD_ADDR_VAR 0 2
38000: PUSH
38001: DOUBLE
38002: LD_INT 1
38004: DEC
38005: ST_TO_ADDR
38006: LD_INT 8
38008: PUSH
38009: FOR_TO
38010: IFFALSE 38036
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38012: LD_ADDR_EXP 129
38016: PUSH
38017: LD_EXP 129
38021: PPUSH
38022: LD_VAR 0 2
38026: PPUSH
38027: EMPTY
38028: PPUSH
38029: CALL_OW 1
38033: ST_TO_ADDR
38034: GO 38009
38036: POP
38037: POP
// tmp := [ ] ;
38038: LD_ADDR_VAR 0 5
38042: PUSH
38043: EMPTY
38044: ST_TO_ADDR
// for i = 1 to mc_sides do
38045: LD_ADDR_VAR 0 2
38049: PUSH
38050: DOUBLE
38051: LD_INT 1
38053: DEC
38054: ST_TO_ADDR
38055: LD_EXP 128
38059: PUSH
38060: FOR_TO
38061: IFFALSE 38119
// if not mc_sides [ i ] in tmp then
38063: LD_EXP 128
38067: PUSH
38068: LD_VAR 0 2
38072: ARRAY
38073: PUSH
38074: LD_VAR 0 5
38078: IN
38079: NOT
38080: IFFALSE 38117
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38082: LD_ADDR_VAR 0 5
38086: PUSH
38087: LD_VAR 0 5
38091: PPUSH
38092: LD_VAR 0 5
38096: PUSH
38097: LD_INT 1
38099: PLUS
38100: PPUSH
38101: LD_EXP 128
38105: PUSH
38106: LD_VAR 0 2
38110: ARRAY
38111: PPUSH
38112: CALL_OW 2
38116: ST_TO_ADDR
38117: GO 38060
38119: POP
38120: POP
// if not tmp then
38121: LD_VAR 0 5
38125: NOT
38126: IFFALSE 38130
// exit ;
38128: GO 38235
// for j in tmp do
38130: LD_ADDR_VAR 0 3
38134: PUSH
38135: LD_VAR 0 5
38139: PUSH
38140: FOR_IN
38141: IFFALSE 38233
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38143: LD_ADDR_VAR 0 6
38147: PUSH
38148: LD_INT 22
38150: PUSH
38151: LD_VAR 0 3
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PPUSH
38160: CALL_OW 69
38164: ST_TO_ADDR
// if not un then
38165: LD_VAR 0 6
38169: NOT
38170: IFFALSE 38174
// continue ;
38172: GO 38140
// nation := GetNation ( un [ 1 ] ) ;
38174: LD_ADDR_VAR 0 4
38178: PUSH
38179: LD_VAR 0 6
38183: PUSH
38184: LD_INT 1
38186: ARRAY
38187: PPUSH
38188: CALL_OW 248
38192: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38193: LD_ADDR_EXP 129
38197: PUSH
38198: LD_EXP 129
38202: PPUSH
38203: LD_VAR 0 3
38207: PPUSH
38208: LD_VAR 0 3
38212: PPUSH
38213: LD_VAR 0 4
38217: PPUSH
38218: LD_INT 1
38220: PPUSH
38221: CALL 64845 0 3
38225: PPUSH
38226: CALL_OW 1
38230: ST_TO_ADDR
// end ;
38231: GO 38140
38233: POP
38234: POP
// end ;
38235: LD_VAR 0 1
38239: RET
// export function MC_InitSides ( ) ; var i ; begin
38240: LD_INT 0
38242: PPUSH
38243: PPUSH
// if not mc_bases then
38244: LD_EXP 102
38248: NOT
38249: IFFALSE 38253
// exit ;
38251: GO 38327
// for i = 1 to mc_bases do
38253: LD_ADDR_VAR 0 2
38257: PUSH
38258: DOUBLE
38259: LD_INT 1
38261: DEC
38262: ST_TO_ADDR
38263: LD_EXP 102
38267: PUSH
38268: FOR_TO
38269: IFFALSE 38325
// if mc_bases [ i ] then
38271: LD_EXP 102
38275: PUSH
38276: LD_VAR 0 2
38280: ARRAY
38281: IFFALSE 38323
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38283: LD_ADDR_EXP 128
38287: PUSH
38288: LD_EXP 128
38292: PPUSH
38293: LD_VAR 0 2
38297: PPUSH
38298: LD_EXP 102
38302: PUSH
38303: LD_VAR 0 2
38307: ARRAY
38308: PUSH
38309: LD_INT 1
38311: ARRAY
38312: PPUSH
38313: CALL_OW 255
38317: PPUSH
38318: CALL_OW 1
38322: ST_TO_ADDR
38323: GO 38268
38325: POP
38326: POP
// end ;
38327: LD_VAR 0 1
38331: RET
// every 0 0$01 trigger skirmish do
38332: LD_EXP 100
38336: IFFALSE 38490
38338: GO 38340
38340: DISABLE
// begin enable ;
38341: ENABLE
// MC_CheckBuildings ( ) ;
38342: CALL 42988 0 0
// MC_CheckPeopleLife ( ) ;
38346: CALL 43113 0 0
// RaiseSailEvent ( 100 ) ;
38350: LD_INT 100
38352: PPUSH
38353: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38357: LD_INT 103
38359: PPUSH
38360: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38364: LD_INT 104
38366: PPUSH
38367: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38371: LD_INT 105
38373: PPUSH
38374: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38378: LD_INT 106
38380: PPUSH
38381: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38385: LD_INT 107
38387: PPUSH
38388: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38392: LD_INT 108
38394: PPUSH
38395: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38399: LD_INT 109
38401: PPUSH
38402: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38406: LD_INT 110
38408: PPUSH
38409: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38413: LD_INT 111
38415: PPUSH
38416: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38420: LD_INT 112
38422: PPUSH
38423: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38427: LD_INT 113
38429: PPUSH
38430: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38434: LD_INT 120
38436: PPUSH
38437: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38441: LD_INT 121
38443: PPUSH
38444: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38448: LD_INT 122
38450: PPUSH
38451: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38455: LD_INT 123
38457: PPUSH
38458: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38462: LD_INT 124
38464: PPUSH
38465: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38469: LD_INT 125
38471: PPUSH
38472: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38476: LD_INT 126
38478: PPUSH
38479: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38483: LD_INT 200
38485: PPUSH
38486: CALL_OW 427
// end ;
38490: END
// on SailEvent ( event ) do begin if event < 100 then
38491: LD_VAR 0 1
38495: PUSH
38496: LD_INT 100
38498: LESS
38499: IFFALSE 38510
// CustomEvent ( event ) ;
38501: LD_VAR 0 1
38505: PPUSH
38506: CALL 33150 0 1
// if event = 100 then
38510: LD_VAR 0 1
38514: PUSH
38515: LD_INT 100
38517: EQUAL
38518: IFFALSE 38524
// MC_ClassManager ( ) ;
38520: CALL 38916 0 0
// if event = 101 then
38524: LD_VAR 0 1
38528: PUSH
38529: LD_INT 101
38531: EQUAL
38532: IFFALSE 38538
// MC_RepairBuildings ( ) ;
38534: CALL 43709 0 0
// if event = 102 then
38538: LD_VAR 0 1
38542: PUSH
38543: LD_INT 102
38545: EQUAL
38546: IFFALSE 38552
// MC_Heal ( ) ;
38548: CALL 44573 0 0
// if event = 103 then
38552: LD_VAR 0 1
38556: PUSH
38557: LD_INT 103
38559: EQUAL
38560: IFFALSE 38566
// MC_Build ( ) ;
38562: CALL 44995 0 0
// if event = 104 then
38566: LD_VAR 0 1
38570: PUSH
38571: LD_INT 104
38573: EQUAL
38574: IFFALSE 38580
// MC_TurretWeapon ( ) ;
38576: CALL 46608 0 0
// if event = 105 then
38580: LD_VAR 0 1
38584: PUSH
38585: LD_INT 105
38587: EQUAL
38588: IFFALSE 38594
// MC_BuildUpgrade ( ) ;
38590: CALL 46159 0 0
// if event = 106 then
38594: LD_VAR 0 1
38598: PUSH
38599: LD_INT 106
38601: EQUAL
38602: IFFALSE 38608
// MC_PlantMines ( ) ;
38604: CALL 47038 0 0
// if event = 107 then
38608: LD_VAR 0 1
38612: PUSH
38613: LD_INT 107
38615: EQUAL
38616: IFFALSE 38622
// MC_CollectCrates ( ) ;
38618: CALL 47836 0 0
// if event = 108 then
38622: LD_VAR 0 1
38626: PUSH
38627: LD_INT 108
38629: EQUAL
38630: IFFALSE 38636
// MC_LinkRemoteControl ( ) ;
38632: CALL 49612 0 0
// if event = 109 then
38636: LD_VAR 0 1
38640: PUSH
38641: LD_INT 109
38643: EQUAL
38644: IFFALSE 38650
// MC_ProduceVehicle ( ) ;
38646: CALL 49793 0 0
// if event = 110 then
38650: LD_VAR 0 1
38654: PUSH
38655: LD_INT 110
38657: EQUAL
38658: IFFALSE 38664
// MC_SendAttack ( ) ;
38660: CALL 50259 0 0
// if event = 111 then
38664: LD_VAR 0 1
38668: PUSH
38669: LD_INT 111
38671: EQUAL
38672: IFFALSE 38678
// MC_Defend ( ) ;
38674: CALL 50367 0 0
// if event = 112 then
38678: LD_VAR 0 1
38682: PUSH
38683: LD_INT 112
38685: EQUAL
38686: IFFALSE 38692
// MC_Research ( ) ;
38688: CALL 50972 0 0
// if event = 113 then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 113
38699: EQUAL
38700: IFFALSE 38706
// MC_MinesTrigger ( ) ;
38702: CALL 52086 0 0
// if event = 120 then
38706: LD_VAR 0 1
38710: PUSH
38711: LD_INT 120
38713: EQUAL
38714: IFFALSE 38720
// MC_RepairVehicle ( ) ;
38716: CALL 52185 0 0
// if event = 121 then
38720: LD_VAR 0 1
38724: PUSH
38725: LD_INT 121
38727: EQUAL
38728: IFFALSE 38734
// MC_TameApe ( ) ;
38730: CALL 52915 0 0
// if event = 122 then
38734: LD_VAR 0 1
38738: PUSH
38739: LD_INT 122
38741: EQUAL
38742: IFFALSE 38748
// MC_ChangeApeClass ( ) ;
38744: CALL 53744 0 0
// if event = 123 then
38748: LD_VAR 0 1
38752: PUSH
38753: LD_INT 123
38755: EQUAL
38756: IFFALSE 38762
// MC_Bazooka ( ) ;
38758: CALL 54394 0 0
// if event = 124 then
38762: LD_VAR 0 1
38766: PUSH
38767: LD_INT 124
38769: EQUAL
38770: IFFALSE 38776
// MC_TeleportExit ( ) ;
38772: CALL 54592 0 0
// if event = 125 then
38776: LD_VAR 0 1
38780: PUSH
38781: LD_INT 125
38783: EQUAL
38784: IFFALSE 38790
// MC_Deposits ( ) ;
38786: CALL 55239 0 0
// if event = 126 then
38790: LD_VAR 0 1
38794: PUSH
38795: LD_INT 126
38797: EQUAL
38798: IFFALSE 38804
// MC_RemoteDriver ( ) ;
38800: CALL 55864 0 0
// if event = 200 then
38804: LD_VAR 0 1
38808: PUSH
38809: LD_INT 200
38811: EQUAL
38812: IFFALSE 38818
// MC_Idle ( ) ;
38814: CALL 57813 0 0
// end ;
38818: PPOPN 1
38820: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38821: LD_INT 0
38823: PPUSH
38824: PPUSH
// if not mc_bases [ base ] or not tag then
38825: LD_EXP 102
38829: PUSH
38830: LD_VAR 0 1
38834: ARRAY
38835: NOT
38836: PUSH
38837: LD_VAR 0 2
38841: NOT
38842: OR
38843: IFFALSE 38847
// exit ;
38845: GO 38911
// for i in mc_bases [ base ] union mc_ape [ base ] do
38847: LD_ADDR_VAR 0 4
38851: PUSH
38852: LD_EXP 102
38856: PUSH
38857: LD_VAR 0 1
38861: ARRAY
38862: PUSH
38863: LD_EXP 131
38867: PUSH
38868: LD_VAR 0 1
38872: ARRAY
38873: UNION
38874: PUSH
38875: FOR_IN
38876: IFFALSE 38909
// if GetTag ( i ) = tag then
38878: LD_VAR 0 4
38882: PPUSH
38883: CALL_OW 110
38887: PUSH
38888: LD_VAR 0 2
38892: EQUAL
38893: IFFALSE 38907
// SetTag ( i , 0 ) ;
38895: LD_VAR 0 4
38899: PPUSH
38900: LD_INT 0
38902: PPUSH
38903: CALL_OW 109
38907: GO 38875
38909: POP
38910: POP
// end ;
38911: LD_VAR 0 3
38915: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38916: LD_INT 0
38918: PPUSH
38919: PPUSH
38920: PPUSH
38921: PPUSH
38922: PPUSH
38923: PPUSH
38924: PPUSH
38925: PPUSH
// if not mc_bases then
38926: LD_EXP 102
38930: NOT
38931: IFFALSE 38935
// exit ;
38933: GO 39393
// for i = 1 to mc_bases do
38935: LD_ADDR_VAR 0 2
38939: PUSH
38940: DOUBLE
38941: LD_INT 1
38943: DEC
38944: ST_TO_ADDR
38945: LD_EXP 102
38949: PUSH
38950: FOR_TO
38951: IFFALSE 39391
// begin tmp := MC_ClassCheckReq ( i ) ;
38953: LD_ADDR_VAR 0 4
38957: PUSH
38958: LD_VAR 0 2
38962: PPUSH
38963: CALL 39398 0 1
38967: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38968: LD_ADDR_EXP 143
38972: PUSH
38973: LD_EXP 143
38977: PPUSH
38978: LD_VAR 0 2
38982: PPUSH
38983: LD_VAR 0 4
38987: PPUSH
38988: CALL_OW 1
38992: ST_TO_ADDR
// if not tmp then
38993: LD_VAR 0 4
38997: NOT
38998: IFFALSE 39002
// continue ;
39000: GO 38950
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39002: LD_ADDR_VAR 0 6
39006: PUSH
39007: LD_EXP 102
39011: PUSH
39012: LD_VAR 0 2
39016: ARRAY
39017: PPUSH
39018: LD_INT 2
39020: PUSH
39021: LD_INT 30
39023: PUSH
39024: LD_INT 4
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 30
39033: PUSH
39034: LD_INT 5
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: LIST
39045: PPUSH
39046: CALL_OW 72
39050: PUSH
39051: LD_EXP 102
39055: PUSH
39056: LD_VAR 0 2
39060: ARRAY
39061: PPUSH
39062: LD_INT 2
39064: PUSH
39065: LD_INT 30
39067: PUSH
39068: LD_INT 0
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 30
39077: PUSH
39078: LD_INT 1
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: LIST
39089: PPUSH
39090: CALL_OW 72
39094: PUSH
39095: LD_EXP 102
39099: PUSH
39100: LD_VAR 0 2
39104: ARRAY
39105: PPUSH
39106: LD_INT 30
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PPUSH
39116: CALL_OW 72
39120: PUSH
39121: LD_EXP 102
39125: PUSH
39126: LD_VAR 0 2
39130: ARRAY
39131: PPUSH
39132: LD_INT 2
39134: PUSH
39135: LD_INT 30
39137: PUSH
39138: LD_INT 6
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 30
39147: PUSH
39148: LD_INT 7
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 30
39157: PUSH
39158: LD_INT 8
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: PPUSH
39171: CALL_OW 72
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: ST_TO_ADDR
// for j = 1 to 4 do
39182: LD_ADDR_VAR 0 3
39186: PUSH
39187: DOUBLE
39188: LD_INT 1
39190: DEC
39191: ST_TO_ADDR
39192: LD_INT 4
39194: PUSH
39195: FOR_TO
39196: IFFALSE 39387
// begin if not tmp [ j ] then
39198: LD_VAR 0 4
39202: PUSH
39203: LD_VAR 0 3
39207: ARRAY
39208: NOT
39209: IFFALSE 39213
// continue ;
39211: GO 39195
// for p in tmp [ j ] do
39213: LD_ADDR_VAR 0 5
39217: PUSH
39218: LD_VAR 0 4
39222: PUSH
39223: LD_VAR 0 3
39227: ARRAY
39228: PUSH
39229: FOR_IN
39230: IFFALSE 39383
// begin if not b [ j ] then
39232: LD_VAR 0 6
39236: PUSH
39237: LD_VAR 0 3
39241: ARRAY
39242: NOT
39243: IFFALSE 39247
// break ;
39245: GO 39383
// e := 0 ;
39247: LD_ADDR_VAR 0 7
39251: PUSH
39252: LD_INT 0
39254: ST_TO_ADDR
// for k in b [ j ] do
39255: LD_ADDR_VAR 0 8
39259: PUSH
39260: LD_VAR 0 6
39264: PUSH
39265: LD_VAR 0 3
39269: ARRAY
39270: PUSH
39271: FOR_IN
39272: IFFALSE 39299
// if IsNotFull ( k ) then
39274: LD_VAR 0 8
39278: PPUSH
39279: CALL 69285 0 1
39283: IFFALSE 39297
// begin e := k ;
39285: LD_ADDR_VAR 0 7
39289: PUSH
39290: LD_VAR 0 8
39294: ST_TO_ADDR
// break ;
39295: GO 39299
// end ;
39297: GO 39271
39299: POP
39300: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39301: LD_VAR 0 7
39305: PUSH
39306: LD_VAR 0 5
39310: PPUSH
39311: LD_VAR 0 7
39315: PPUSH
39316: CALL 106414 0 2
39320: NOT
39321: AND
39322: IFFALSE 39381
// begin if IsInUnit ( p ) then
39324: LD_VAR 0 5
39328: PPUSH
39329: CALL_OW 310
39333: IFFALSE 39344
// ComExitBuilding ( p ) ;
39335: LD_VAR 0 5
39339: PPUSH
39340: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39344: LD_VAR 0 5
39348: PPUSH
39349: LD_VAR 0 7
39353: PPUSH
39354: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39358: LD_VAR 0 5
39362: PPUSH
39363: LD_VAR 0 3
39367: PPUSH
39368: CALL_OW 183
// AddComExitBuilding ( p ) ;
39372: LD_VAR 0 5
39376: PPUSH
39377: CALL_OW 182
// end ; end ;
39381: GO 39229
39383: POP
39384: POP
// end ;
39385: GO 39195
39387: POP
39388: POP
// end ;
39389: GO 38950
39391: POP
39392: POP
// end ;
39393: LD_VAR 0 1
39397: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39398: LD_INT 0
39400: PPUSH
39401: PPUSH
39402: PPUSH
39403: PPUSH
39404: PPUSH
39405: PPUSH
39406: PPUSH
39407: PPUSH
39408: PPUSH
39409: PPUSH
39410: PPUSH
39411: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39412: LD_VAR 0 1
39416: NOT
39417: PUSH
39418: LD_EXP 102
39422: PUSH
39423: LD_VAR 0 1
39427: ARRAY
39428: NOT
39429: OR
39430: PUSH
39431: LD_EXP 102
39435: PUSH
39436: LD_VAR 0 1
39440: ARRAY
39441: PPUSH
39442: LD_INT 2
39444: PUSH
39445: LD_INT 30
39447: PUSH
39448: LD_INT 0
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 30
39457: PUSH
39458: LD_INT 1
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: LIST
39469: PPUSH
39470: CALL_OW 72
39474: NOT
39475: OR
39476: IFFALSE 39480
// exit ;
39478: GO 42983
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39480: LD_ADDR_VAR 0 4
39484: PUSH
39485: LD_EXP 102
39489: PUSH
39490: LD_VAR 0 1
39494: ARRAY
39495: PPUSH
39496: LD_INT 2
39498: PUSH
39499: LD_INT 25
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 25
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 25
39521: PUSH
39522: LD_INT 3
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 25
39531: PUSH
39532: LD_INT 4
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 25
39541: PUSH
39542: LD_INT 5
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 25
39551: PUSH
39552: LD_INT 8
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: LD_INT 25
39561: PUSH
39562: LD_INT 9
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: PPUSH
39579: CALL_OW 72
39583: ST_TO_ADDR
// if not tmp then
39584: LD_VAR 0 4
39588: NOT
39589: IFFALSE 39593
// exit ;
39591: GO 42983
// for i in tmp do
39593: LD_ADDR_VAR 0 3
39597: PUSH
39598: LD_VAR 0 4
39602: PUSH
39603: FOR_IN
39604: IFFALSE 39635
// if GetTag ( i ) then
39606: LD_VAR 0 3
39610: PPUSH
39611: CALL_OW 110
39615: IFFALSE 39633
// tmp := tmp diff i ;
39617: LD_ADDR_VAR 0 4
39621: PUSH
39622: LD_VAR 0 4
39626: PUSH
39627: LD_VAR 0 3
39631: DIFF
39632: ST_TO_ADDR
39633: GO 39603
39635: POP
39636: POP
// if not tmp then
39637: LD_VAR 0 4
39641: NOT
39642: IFFALSE 39646
// exit ;
39644: GO 42983
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39646: LD_ADDR_VAR 0 5
39650: PUSH
39651: LD_EXP 102
39655: PUSH
39656: LD_VAR 0 1
39660: ARRAY
39661: PPUSH
39662: LD_INT 2
39664: PUSH
39665: LD_INT 25
39667: PUSH
39668: LD_INT 1
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 25
39677: PUSH
39678: LD_INT 5
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: LD_INT 25
39687: PUSH
39688: LD_INT 8
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 25
39697: PUSH
39698: LD_INT 9
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: PPUSH
39712: CALL_OW 72
39716: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39717: LD_ADDR_VAR 0 6
39721: PUSH
39722: LD_EXP 102
39726: PUSH
39727: LD_VAR 0 1
39731: ARRAY
39732: PPUSH
39733: LD_INT 25
39735: PUSH
39736: LD_INT 2
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PPUSH
39743: CALL_OW 72
39747: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39748: LD_ADDR_VAR 0 7
39752: PUSH
39753: LD_EXP 102
39757: PUSH
39758: LD_VAR 0 1
39762: ARRAY
39763: PPUSH
39764: LD_INT 25
39766: PUSH
39767: LD_INT 3
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PPUSH
39774: CALL_OW 72
39778: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39779: LD_ADDR_VAR 0 8
39783: PUSH
39784: LD_EXP 102
39788: PUSH
39789: LD_VAR 0 1
39793: ARRAY
39794: PPUSH
39795: LD_INT 25
39797: PUSH
39798: LD_INT 4
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 24
39807: PUSH
39808: LD_INT 251
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PPUSH
39819: CALL_OW 72
39823: ST_TO_ADDR
// if mc_scan [ base ] then
39824: LD_EXP 125
39828: PUSH
39829: LD_VAR 0 1
39833: ARRAY
39834: IFFALSE 40295
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39836: LD_ADDR_EXP 144
39840: PUSH
39841: LD_EXP 144
39845: PPUSH
39846: LD_VAR 0 1
39850: PPUSH
39851: LD_INT 4
39853: PPUSH
39854: CALL_OW 1
39858: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39859: LD_ADDR_VAR 0 12
39863: PUSH
39864: LD_EXP 102
39868: PUSH
39869: LD_VAR 0 1
39873: ARRAY
39874: PPUSH
39875: LD_INT 2
39877: PUSH
39878: LD_INT 30
39880: PUSH
39881: LD_INT 4
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 30
39890: PUSH
39891: LD_INT 5
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: LIST
39902: PPUSH
39903: CALL_OW 72
39907: ST_TO_ADDR
// if not b then
39908: LD_VAR 0 12
39912: NOT
39913: IFFALSE 39917
// exit ;
39915: GO 42983
// p := [ ] ;
39917: LD_ADDR_VAR 0 11
39921: PUSH
39922: EMPTY
39923: ST_TO_ADDR
// if sci >= 2 then
39924: LD_VAR 0 8
39928: PUSH
39929: LD_INT 2
39931: GREATEREQUAL
39932: IFFALSE 39963
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39934: LD_ADDR_VAR 0 8
39938: PUSH
39939: LD_VAR 0 8
39943: PUSH
39944: LD_INT 1
39946: ARRAY
39947: PUSH
39948: LD_VAR 0 8
39952: PUSH
39953: LD_INT 2
39955: ARRAY
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: ST_TO_ADDR
39961: GO 40024
// if sci = 1 then
39963: LD_VAR 0 8
39967: PUSH
39968: LD_INT 1
39970: EQUAL
39971: IFFALSE 39992
// sci := [ sci [ 1 ] ] else
39973: LD_ADDR_VAR 0 8
39977: PUSH
39978: LD_VAR 0 8
39982: PUSH
39983: LD_INT 1
39985: ARRAY
39986: PUSH
39987: EMPTY
39988: LIST
39989: ST_TO_ADDR
39990: GO 40024
// if sci = 0 then
39992: LD_VAR 0 8
39996: PUSH
39997: LD_INT 0
39999: EQUAL
40000: IFFALSE 40024
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40002: LD_ADDR_VAR 0 11
40006: PUSH
40007: LD_VAR 0 4
40011: PPUSH
40012: LD_INT 4
40014: PPUSH
40015: CALL 106277 0 2
40019: PUSH
40020: LD_INT 1
40022: ARRAY
40023: ST_TO_ADDR
// if eng > 4 then
40024: LD_VAR 0 6
40028: PUSH
40029: LD_INT 4
40031: GREATER
40032: IFFALSE 40078
// for i = eng downto 4 do
40034: LD_ADDR_VAR 0 3
40038: PUSH
40039: DOUBLE
40040: LD_VAR 0 6
40044: INC
40045: ST_TO_ADDR
40046: LD_INT 4
40048: PUSH
40049: FOR_DOWNTO
40050: IFFALSE 40076
// eng := eng diff eng [ i ] ;
40052: LD_ADDR_VAR 0 6
40056: PUSH
40057: LD_VAR 0 6
40061: PUSH
40062: LD_VAR 0 6
40066: PUSH
40067: LD_VAR 0 3
40071: ARRAY
40072: DIFF
40073: ST_TO_ADDR
40074: GO 40049
40076: POP
40077: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40078: LD_ADDR_VAR 0 4
40082: PUSH
40083: LD_VAR 0 4
40087: PUSH
40088: LD_VAR 0 5
40092: PUSH
40093: LD_VAR 0 6
40097: UNION
40098: PUSH
40099: LD_VAR 0 7
40103: UNION
40104: PUSH
40105: LD_VAR 0 8
40109: UNION
40110: DIFF
40111: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40112: LD_ADDR_VAR 0 13
40116: PUSH
40117: LD_EXP 102
40121: PUSH
40122: LD_VAR 0 1
40126: ARRAY
40127: PPUSH
40128: LD_INT 2
40130: PUSH
40131: LD_INT 30
40133: PUSH
40134: LD_INT 32
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 30
40143: PUSH
40144: LD_INT 31
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: LIST
40155: PPUSH
40156: CALL_OW 72
40160: PUSH
40161: LD_EXP 102
40165: PUSH
40166: LD_VAR 0 1
40170: ARRAY
40171: PPUSH
40172: LD_INT 2
40174: PUSH
40175: LD_INT 30
40177: PUSH
40178: LD_INT 4
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 30
40187: PUSH
40188: LD_INT 5
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: LIST
40199: PPUSH
40200: CALL_OW 72
40204: PUSH
40205: LD_INT 6
40207: MUL
40208: PLUS
40209: ST_TO_ADDR
// if bcount < tmp then
40210: LD_VAR 0 13
40214: PUSH
40215: LD_VAR 0 4
40219: LESS
40220: IFFALSE 40266
// for i = tmp downto bcount do
40222: LD_ADDR_VAR 0 3
40226: PUSH
40227: DOUBLE
40228: LD_VAR 0 4
40232: INC
40233: ST_TO_ADDR
40234: LD_VAR 0 13
40238: PUSH
40239: FOR_DOWNTO
40240: IFFALSE 40264
// tmp := Delete ( tmp , tmp ) ;
40242: LD_ADDR_VAR 0 4
40246: PUSH
40247: LD_VAR 0 4
40251: PPUSH
40252: LD_VAR 0 4
40256: PPUSH
40257: CALL_OW 3
40261: ST_TO_ADDR
40262: GO 40239
40264: POP
40265: POP
// result := [ tmp , 0 , 0 , p ] ;
40266: LD_ADDR_VAR 0 2
40270: PUSH
40271: LD_VAR 0 4
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: LD_VAR 0 11
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: ST_TO_ADDR
// exit ;
40293: GO 42983
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40295: LD_EXP 102
40299: PUSH
40300: LD_VAR 0 1
40304: ARRAY
40305: PPUSH
40306: LD_INT 2
40308: PUSH
40309: LD_INT 30
40311: PUSH
40312: LD_INT 6
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 30
40321: PUSH
40322: LD_INT 7
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 30
40331: PUSH
40332: LD_INT 8
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: PPUSH
40345: CALL_OW 72
40349: NOT
40350: PUSH
40351: LD_EXP 102
40355: PUSH
40356: LD_VAR 0 1
40360: ARRAY
40361: PPUSH
40362: LD_INT 30
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PPUSH
40372: CALL_OW 72
40376: NOT
40377: AND
40378: IFFALSE 40450
// begin if eng = tmp then
40380: LD_VAR 0 6
40384: PUSH
40385: LD_VAR 0 4
40389: EQUAL
40390: IFFALSE 40394
// exit ;
40392: GO 42983
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40394: LD_ADDR_EXP 144
40398: PUSH
40399: LD_EXP 144
40403: PPUSH
40404: LD_VAR 0 1
40408: PPUSH
40409: LD_INT 1
40411: PPUSH
40412: CALL_OW 1
40416: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40417: LD_ADDR_VAR 0 2
40421: PUSH
40422: LD_INT 0
40424: PUSH
40425: LD_VAR 0 4
40429: PUSH
40430: LD_VAR 0 6
40434: DIFF
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: ST_TO_ADDR
// exit ;
40448: GO 42983
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40450: LD_EXP 129
40454: PUSH
40455: LD_EXP 128
40459: PUSH
40460: LD_VAR 0 1
40464: ARRAY
40465: ARRAY
40466: PUSH
40467: LD_EXP 102
40471: PUSH
40472: LD_VAR 0 1
40476: ARRAY
40477: PPUSH
40478: LD_INT 2
40480: PUSH
40481: LD_INT 30
40483: PUSH
40484: LD_INT 6
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 30
40493: PUSH
40494: LD_INT 7
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 30
40503: PUSH
40504: LD_INT 8
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: PPUSH
40517: CALL_OW 72
40521: AND
40522: PUSH
40523: LD_EXP 102
40527: PUSH
40528: LD_VAR 0 1
40532: ARRAY
40533: PPUSH
40534: LD_INT 30
40536: PUSH
40537: LD_INT 3
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PPUSH
40544: CALL_OW 72
40548: NOT
40549: AND
40550: IFFALSE 40764
// begin if sci >= 6 then
40552: LD_VAR 0 8
40556: PUSH
40557: LD_INT 6
40559: GREATEREQUAL
40560: IFFALSE 40564
// exit ;
40562: GO 42983
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40564: LD_ADDR_EXP 144
40568: PUSH
40569: LD_EXP 144
40573: PPUSH
40574: LD_VAR 0 1
40578: PPUSH
40579: LD_INT 2
40581: PPUSH
40582: CALL_OW 1
40586: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40587: LD_ADDR_VAR 0 9
40591: PUSH
40592: LD_VAR 0 4
40596: PUSH
40597: LD_VAR 0 8
40601: DIFF
40602: PPUSH
40603: LD_INT 4
40605: PPUSH
40606: CALL 106277 0 2
40610: ST_TO_ADDR
// p := [ ] ;
40611: LD_ADDR_VAR 0 11
40615: PUSH
40616: EMPTY
40617: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40618: LD_VAR 0 8
40622: PUSH
40623: LD_INT 6
40625: LESS
40626: PUSH
40627: LD_VAR 0 9
40631: PUSH
40632: LD_INT 6
40634: GREATER
40635: AND
40636: IFFALSE 40717
// begin for i = 1 to 6 - sci do
40638: LD_ADDR_VAR 0 3
40642: PUSH
40643: DOUBLE
40644: LD_INT 1
40646: DEC
40647: ST_TO_ADDR
40648: LD_INT 6
40650: PUSH
40651: LD_VAR 0 8
40655: MINUS
40656: PUSH
40657: FOR_TO
40658: IFFALSE 40713
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40660: LD_ADDR_VAR 0 11
40664: PUSH
40665: LD_VAR 0 11
40669: PPUSH
40670: LD_VAR 0 11
40674: PUSH
40675: LD_INT 1
40677: PLUS
40678: PPUSH
40679: LD_VAR 0 9
40683: PUSH
40684: LD_INT 1
40686: ARRAY
40687: PPUSH
40688: CALL_OW 2
40692: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40693: LD_ADDR_VAR 0 9
40697: PUSH
40698: LD_VAR 0 9
40702: PPUSH
40703: LD_INT 1
40705: PPUSH
40706: CALL_OW 3
40710: ST_TO_ADDR
// end ;
40711: GO 40657
40713: POP
40714: POP
// end else
40715: GO 40737
// if sort then
40717: LD_VAR 0 9
40721: IFFALSE 40737
// p := sort [ 1 ] ;
40723: LD_ADDR_VAR 0 11
40727: PUSH
40728: LD_VAR 0 9
40732: PUSH
40733: LD_INT 1
40735: ARRAY
40736: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40737: LD_ADDR_VAR 0 2
40741: PUSH
40742: LD_INT 0
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: LD_INT 0
40750: PUSH
40751: LD_VAR 0 11
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: LIST
40760: LIST
40761: ST_TO_ADDR
// exit ;
40762: GO 42983
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40764: LD_EXP 129
40768: PUSH
40769: LD_EXP 128
40773: PUSH
40774: LD_VAR 0 1
40778: ARRAY
40779: ARRAY
40780: PUSH
40781: LD_EXP 102
40785: PUSH
40786: LD_VAR 0 1
40790: ARRAY
40791: PPUSH
40792: LD_INT 2
40794: PUSH
40795: LD_INT 30
40797: PUSH
40798: LD_INT 6
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 30
40807: PUSH
40808: LD_INT 7
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 30
40817: PUSH
40818: LD_INT 8
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: LIST
40829: LIST
40830: PPUSH
40831: CALL_OW 72
40835: AND
40836: PUSH
40837: LD_EXP 102
40841: PUSH
40842: LD_VAR 0 1
40846: ARRAY
40847: PPUSH
40848: LD_INT 30
40850: PUSH
40851: LD_INT 3
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PPUSH
40858: CALL_OW 72
40862: AND
40863: IFFALSE 41597
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40865: LD_ADDR_EXP 144
40869: PUSH
40870: LD_EXP 144
40874: PPUSH
40875: LD_VAR 0 1
40879: PPUSH
40880: LD_INT 3
40882: PPUSH
40883: CALL_OW 1
40887: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40888: LD_ADDR_VAR 0 2
40892: PUSH
40893: LD_INT 0
40895: PUSH
40896: LD_INT 0
40898: PUSH
40899: LD_INT 0
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: ST_TO_ADDR
// if not eng then
40911: LD_VAR 0 6
40915: NOT
40916: IFFALSE 40979
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40918: LD_ADDR_VAR 0 11
40922: PUSH
40923: LD_VAR 0 4
40927: PPUSH
40928: LD_INT 2
40930: PPUSH
40931: CALL 106277 0 2
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40940: LD_ADDR_VAR 0 2
40944: PUSH
40945: LD_VAR 0 2
40949: PPUSH
40950: LD_INT 2
40952: PPUSH
40953: LD_VAR 0 11
40957: PPUSH
40958: CALL_OW 1
40962: ST_TO_ADDR
// tmp := tmp diff p ;
40963: LD_ADDR_VAR 0 4
40967: PUSH
40968: LD_VAR 0 4
40972: PUSH
40973: LD_VAR 0 11
40977: DIFF
40978: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40979: LD_VAR 0 4
40983: PUSH
40984: LD_VAR 0 8
40988: PUSH
40989: LD_INT 6
40991: LESS
40992: AND
40993: IFFALSE 41181
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40995: LD_ADDR_VAR 0 9
40999: PUSH
41000: LD_VAR 0 4
41004: PUSH
41005: LD_VAR 0 8
41009: PUSH
41010: LD_VAR 0 7
41014: UNION
41015: DIFF
41016: PPUSH
41017: LD_INT 4
41019: PPUSH
41020: CALL 106277 0 2
41024: ST_TO_ADDR
// p := [ ] ;
41025: LD_ADDR_VAR 0 11
41029: PUSH
41030: EMPTY
41031: ST_TO_ADDR
// if sort then
41032: LD_VAR 0 9
41036: IFFALSE 41152
// for i = 1 to 6 - sci do
41038: LD_ADDR_VAR 0 3
41042: PUSH
41043: DOUBLE
41044: LD_INT 1
41046: DEC
41047: ST_TO_ADDR
41048: LD_INT 6
41050: PUSH
41051: LD_VAR 0 8
41055: MINUS
41056: PUSH
41057: FOR_TO
41058: IFFALSE 41150
// begin if i = sort then
41060: LD_VAR 0 3
41064: PUSH
41065: LD_VAR 0 9
41069: EQUAL
41070: IFFALSE 41074
// break ;
41072: GO 41150
// if GetClass ( i ) = 4 then
41074: LD_VAR 0 3
41078: PPUSH
41079: CALL_OW 257
41083: PUSH
41084: LD_INT 4
41086: EQUAL
41087: IFFALSE 41091
// continue ;
41089: GO 41057
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41091: LD_ADDR_VAR 0 11
41095: PUSH
41096: LD_VAR 0 11
41100: PPUSH
41101: LD_VAR 0 11
41105: PUSH
41106: LD_INT 1
41108: PLUS
41109: PPUSH
41110: LD_VAR 0 9
41114: PUSH
41115: LD_VAR 0 3
41119: ARRAY
41120: PPUSH
41121: CALL_OW 2
41125: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41126: LD_ADDR_VAR 0 4
41130: PUSH
41131: LD_VAR 0 4
41135: PUSH
41136: LD_VAR 0 9
41140: PUSH
41141: LD_VAR 0 3
41145: ARRAY
41146: DIFF
41147: ST_TO_ADDR
// end ;
41148: GO 41057
41150: POP
41151: POP
// if p then
41152: LD_VAR 0 11
41156: IFFALSE 41181
// result := Replace ( result , 4 , p ) ;
41158: LD_ADDR_VAR 0 2
41162: PUSH
41163: LD_VAR 0 2
41167: PPUSH
41168: LD_INT 4
41170: PPUSH
41171: LD_VAR 0 11
41175: PPUSH
41176: CALL_OW 1
41180: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41181: LD_VAR 0 4
41185: PUSH
41186: LD_VAR 0 7
41190: PUSH
41191: LD_INT 6
41193: LESS
41194: AND
41195: IFFALSE 41383
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41197: LD_ADDR_VAR 0 9
41201: PUSH
41202: LD_VAR 0 4
41206: PUSH
41207: LD_VAR 0 8
41211: PUSH
41212: LD_VAR 0 7
41216: UNION
41217: DIFF
41218: PPUSH
41219: LD_INT 3
41221: PPUSH
41222: CALL 106277 0 2
41226: ST_TO_ADDR
// p := [ ] ;
41227: LD_ADDR_VAR 0 11
41231: PUSH
41232: EMPTY
41233: ST_TO_ADDR
// if sort then
41234: LD_VAR 0 9
41238: IFFALSE 41354
// for i = 1 to 6 - mech do
41240: LD_ADDR_VAR 0 3
41244: PUSH
41245: DOUBLE
41246: LD_INT 1
41248: DEC
41249: ST_TO_ADDR
41250: LD_INT 6
41252: PUSH
41253: LD_VAR 0 7
41257: MINUS
41258: PUSH
41259: FOR_TO
41260: IFFALSE 41352
// begin if i = sort then
41262: LD_VAR 0 3
41266: PUSH
41267: LD_VAR 0 9
41271: EQUAL
41272: IFFALSE 41276
// break ;
41274: GO 41352
// if GetClass ( i ) = 3 then
41276: LD_VAR 0 3
41280: PPUSH
41281: CALL_OW 257
41285: PUSH
41286: LD_INT 3
41288: EQUAL
41289: IFFALSE 41293
// continue ;
41291: GO 41259
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41293: LD_ADDR_VAR 0 11
41297: PUSH
41298: LD_VAR 0 11
41302: PPUSH
41303: LD_VAR 0 11
41307: PUSH
41308: LD_INT 1
41310: PLUS
41311: PPUSH
41312: LD_VAR 0 9
41316: PUSH
41317: LD_VAR 0 3
41321: ARRAY
41322: PPUSH
41323: CALL_OW 2
41327: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41328: LD_ADDR_VAR 0 4
41332: PUSH
41333: LD_VAR 0 4
41337: PUSH
41338: LD_VAR 0 9
41342: PUSH
41343: LD_VAR 0 3
41347: ARRAY
41348: DIFF
41349: ST_TO_ADDR
// end ;
41350: GO 41259
41352: POP
41353: POP
// if p then
41354: LD_VAR 0 11
41358: IFFALSE 41383
// result := Replace ( result , 3 , p ) ;
41360: LD_ADDR_VAR 0 2
41364: PUSH
41365: LD_VAR 0 2
41369: PPUSH
41370: LD_INT 3
41372: PPUSH
41373: LD_VAR 0 11
41377: PPUSH
41378: CALL_OW 1
41382: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41383: LD_VAR 0 4
41387: PUSH
41388: LD_INT 6
41390: GREATER
41391: PUSH
41392: LD_VAR 0 6
41396: PUSH
41397: LD_INT 6
41399: LESS
41400: AND
41401: IFFALSE 41595
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41403: LD_ADDR_VAR 0 9
41407: PUSH
41408: LD_VAR 0 4
41412: PUSH
41413: LD_VAR 0 8
41417: PUSH
41418: LD_VAR 0 7
41422: UNION
41423: PUSH
41424: LD_VAR 0 6
41428: UNION
41429: DIFF
41430: PPUSH
41431: LD_INT 2
41433: PPUSH
41434: CALL 106277 0 2
41438: ST_TO_ADDR
// p := [ ] ;
41439: LD_ADDR_VAR 0 11
41443: PUSH
41444: EMPTY
41445: ST_TO_ADDR
// if sort then
41446: LD_VAR 0 9
41450: IFFALSE 41566
// for i = 1 to 6 - eng do
41452: LD_ADDR_VAR 0 3
41456: PUSH
41457: DOUBLE
41458: LD_INT 1
41460: DEC
41461: ST_TO_ADDR
41462: LD_INT 6
41464: PUSH
41465: LD_VAR 0 6
41469: MINUS
41470: PUSH
41471: FOR_TO
41472: IFFALSE 41564
// begin if i = sort then
41474: LD_VAR 0 3
41478: PUSH
41479: LD_VAR 0 9
41483: EQUAL
41484: IFFALSE 41488
// break ;
41486: GO 41564
// if GetClass ( i ) = 2 then
41488: LD_VAR 0 3
41492: PPUSH
41493: CALL_OW 257
41497: PUSH
41498: LD_INT 2
41500: EQUAL
41501: IFFALSE 41505
// continue ;
41503: GO 41471
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41505: LD_ADDR_VAR 0 11
41509: PUSH
41510: LD_VAR 0 11
41514: PPUSH
41515: LD_VAR 0 11
41519: PUSH
41520: LD_INT 1
41522: PLUS
41523: PPUSH
41524: LD_VAR 0 9
41528: PUSH
41529: LD_VAR 0 3
41533: ARRAY
41534: PPUSH
41535: CALL_OW 2
41539: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41540: LD_ADDR_VAR 0 4
41544: PUSH
41545: LD_VAR 0 4
41549: PUSH
41550: LD_VAR 0 9
41554: PUSH
41555: LD_VAR 0 3
41559: ARRAY
41560: DIFF
41561: ST_TO_ADDR
// end ;
41562: GO 41471
41564: POP
41565: POP
// if p then
41566: LD_VAR 0 11
41570: IFFALSE 41595
// result := Replace ( result , 2 , p ) ;
41572: LD_ADDR_VAR 0 2
41576: PUSH
41577: LD_VAR 0 2
41581: PPUSH
41582: LD_INT 2
41584: PPUSH
41585: LD_VAR 0 11
41589: PPUSH
41590: CALL_OW 1
41594: ST_TO_ADDR
// end ; exit ;
41595: GO 42983
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41597: LD_EXP 129
41601: PUSH
41602: LD_EXP 128
41606: PUSH
41607: LD_VAR 0 1
41611: ARRAY
41612: ARRAY
41613: NOT
41614: PUSH
41615: LD_EXP 102
41619: PUSH
41620: LD_VAR 0 1
41624: ARRAY
41625: PPUSH
41626: LD_INT 30
41628: PUSH
41629: LD_INT 3
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PPUSH
41636: CALL_OW 72
41640: AND
41641: PUSH
41642: LD_EXP 107
41646: PUSH
41647: LD_VAR 0 1
41651: ARRAY
41652: AND
41653: IFFALSE 42261
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41655: LD_ADDR_EXP 144
41659: PUSH
41660: LD_EXP 144
41664: PPUSH
41665: LD_VAR 0 1
41669: PPUSH
41670: LD_INT 5
41672: PPUSH
41673: CALL_OW 1
41677: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41678: LD_ADDR_VAR 0 2
41682: PUSH
41683: LD_INT 0
41685: PUSH
41686: LD_INT 0
41688: PUSH
41689: LD_INT 0
41691: PUSH
41692: LD_INT 0
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: ST_TO_ADDR
// if sci > 1 then
41701: LD_VAR 0 8
41705: PUSH
41706: LD_INT 1
41708: GREATER
41709: IFFALSE 41737
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41711: LD_ADDR_VAR 0 4
41715: PUSH
41716: LD_VAR 0 4
41720: PUSH
41721: LD_VAR 0 8
41725: PUSH
41726: LD_VAR 0 8
41730: PUSH
41731: LD_INT 1
41733: ARRAY
41734: DIFF
41735: DIFF
41736: ST_TO_ADDR
// if tmp and not sci then
41737: LD_VAR 0 4
41741: PUSH
41742: LD_VAR 0 8
41746: NOT
41747: AND
41748: IFFALSE 41817
// begin sort := SortBySkill ( tmp , 4 ) ;
41750: LD_ADDR_VAR 0 9
41754: PUSH
41755: LD_VAR 0 4
41759: PPUSH
41760: LD_INT 4
41762: PPUSH
41763: CALL 106277 0 2
41767: ST_TO_ADDR
// if sort then
41768: LD_VAR 0 9
41772: IFFALSE 41788
// p := sort [ 1 ] ;
41774: LD_ADDR_VAR 0 11
41778: PUSH
41779: LD_VAR 0 9
41783: PUSH
41784: LD_INT 1
41786: ARRAY
41787: ST_TO_ADDR
// if p then
41788: LD_VAR 0 11
41792: IFFALSE 41817
// result := Replace ( result , 4 , p ) ;
41794: LD_ADDR_VAR 0 2
41798: PUSH
41799: LD_VAR 0 2
41803: PPUSH
41804: LD_INT 4
41806: PPUSH
41807: LD_VAR 0 11
41811: PPUSH
41812: CALL_OW 1
41816: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41817: LD_ADDR_VAR 0 4
41821: PUSH
41822: LD_VAR 0 4
41826: PUSH
41827: LD_VAR 0 7
41831: DIFF
41832: ST_TO_ADDR
// if tmp and mech < 6 then
41833: LD_VAR 0 4
41837: PUSH
41838: LD_VAR 0 7
41842: PUSH
41843: LD_INT 6
41845: LESS
41846: AND
41847: IFFALSE 42035
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41849: LD_ADDR_VAR 0 9
41853: PUSH
41854: LD_VAR 0 4
41858: PUSH
41859: LD_VAR 0 8
41863: PUSH
41864: LD_VAR 0 7
41868: UNION
41869: DIFF
41870: PPUSH
41871: LD_INT 3
41873: PPUSH
41874: CALL 106277 0 2
41878: ST_TO_ADDR
// p := [ ] ;
41879: LD_ADDR_VAR 0 11
41883: PUSH
41884: EMPTY
41885: ST_TO_ADDR
// if sort then
41886: LD_VAR 0 9
41890: IFFALSE 42006
// for i = 1 to 6 - mech do
41892: LD_ADDR_VAR 0 3
41896: PUSH
41897: DOUBLE
41898: LD_INT 1
41900: DEC
41901: ST_TO_ADDR
41902: LD_INT 6
41904: PUSH
41905: LD_VAR 0 7
41909: MINUS
41910: PUSH
41911: FOR_TO
41912: IFFALSE 42004
// begin if i = sort then
41914: LD_VAR 0 3
41918: PUSH
41919: LD_VAR 0 9
41923: EQUAL
41924: IFFALSE 41928
// break ;
41926: GO 42004
// if GetClass ( i ) = 3 then
41928: LD_VAR 0 3
41932: PPUSH
41933: CALL_OW 257
41937: PUSH
41938: LD_INT 3
41940: EQUAL
41941: IFFALSE 41945
// continue ;
41943: GO 41911
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41945: LD_ADDR_VAR 0 11
41949: PUSH
41950: LD_VAR 0 11
41954: PPUSH
41955: LD_VAR 0 11
41959: PUSH
41960: LD_INT 1
41962: PLUS
41963: PPUSH
41964: LD_VAR 0 9
41968: PUSH
41969: LD_VAR 0 3
41973: ARRAY
41974: PPUSH
41975: CALL_OW 2
41979: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41980: LD_ADDR_VAR 0 4
41984: PUSH
41985: LD_VAR 0 4
41989: PUSH
41990: LD_VAR 0 9
41994: PUSH
41995: LD_VAR 0 3
41999: ARRAY
42000: DIFF
42001: ST_TO_ADDR
// end ;
42002: GO 41911
42004: POP
42005: POP
// if p then
42006: LD_VAR 0 11
42010: IFFALSE 42035
// result := Replace ( result , 3 , p ) ;
42012: LD_ADDR_VAR 0 2
42016: PUSH
42017: LD_VAR 0 2
42021: PPUSH
42022: LD_INT 3
42024: PPUSH
42025: LD_VAR 0 11
42029: PPUSH
42030: CALL_OW 1
42034: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42035: LD_ADDR_VAR 0 4
42039: PUSH
42040: LD_VAR 0 4
42044: PUSH
42045: LD_VAR 0 6
42049: DIFF
42050: ST_TO_ADDR
// if tmp and eng < 6 then
42051: LD_VAR 0 4
42055: PUSH
42056: LD_VAR 0 6
42060: PUSH
42061: LD_INT 6
42063: LESS
42064: AND
42065: IFFALSE 42259
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42067: LD_ADDR_VAR 0 9
42071: PUSH
42072: LD_VAR 0 4
42076: PUSH
42077: LD_VAR 0 8
42081: PUSH
42082: LD_VAR 0 7
42086: UNION
42087: PUSH
42088: LD_VAR 0 6
42092: UNION
42093: DIFF
42094: PPUSH
42095: LD_INT 2
42097: PPUSH
42098: CALL 106277 0 2
42102: ST_TO_ADDR
// p := [ ] ;
42103: LD_ADDR_VAR 0 11
42107: PUSH
42108: EMPTY
42109: ST_TO_ADDR
// if sort then
42110: LD_VAR 0 9
42114: IFFALSE 42230
// for i = 1 to 6 - eng do
42116: LD_ADDR_VAR 0 3
42120: PUSH
42121: DOUBLE
42122: LD_INT 1
42124: DEC
42125: ST_TO_ADDR
42126: LD_INT 6
42128: PUSH
42129: LD_VAR 0 6
42133: MINUS
42134: PUSH
42135: FOR_TO
42136: IFFALSE 42228
// begin if i = sort then
42138: LD_VAR 0 3
42142: PUSH
42143: LD_VAR 0 9
42147: EQUAL
42148: IFFALSE 42152
// break ;
42150: GO 42228
// if GetClass ( i ) = 2 then
42152: LD_VAR 0 3
42156: PPUSH
42157: CALL_OW 257
42161: PUSH
42162: LD_INT 2
42164: EQUAL
42165: IFFALSE 42169
// continue ;
42167: GO 42135
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42169: LD_ADDR_VAR 0 11
42173: PUSH
42174: LD_VAR 0 11
42178: PPUSH
42179: LD_VAR 0 11
42183: PUSH
42184: LD_INT 1
42186: PLUS
42187: PPUSH
42188: LD_VAR 0 9
42192: PUSH
42193: LD_VAR 0 3
42197: ARRAY
42198: PPUSH
42199: CALL_OW 2
42203: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42204: LD_ADDR_VAR 0 4
42208: PUSH
42209: LD_VAR 0 4
42213: PUSH
42214: LD_VAR 0 9
42218: PUSH
42219: LD_VAR 0 3
42223: ARRAY
42224: DIFF
42225: ST_TO_ADDR
// end ;
42226: GO 42135
42228: POP
42229: POP
// if p then
42230: LD_VAR 0 11
42234: IFFALSE 42259
// result := Replace ( result , 2 , p ) ;
42236: LD_ADDR_VAR 0 2
42240: PUSH
42241: LD_VAR 0 2
42245: PPUSH
42246: LD_INT 2
42248: PPUSH
42249: LD_VAR 0 11
42253: PPUSH
42254: CALL_OW 1
42258: ST_TO_ADDR
// end ; exit ;
42259: GO 42983
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42261: LD_EXP 129
42265: PUSH
42266: LD_EXP 128
42270: PUSH
42271: LD_VAR 0 1
42275: ARRAY
42276: ARRAY
42277: NOT
42278: PUSH
42279: LD_EXP 102
42283: PUSH
42284: LD_VAR 0 1
42288: ARRAY
42289: PPUSH
42290: LD_INT 30
42292: PUSH
42293: LD_INT 3
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PPUSH
42300: CALL_OW 72
42304: AND
42305: PUSH
42306: LD_EXP 107
42310: PUSH
42311: LD_VAR 0 1
42315: ARRAY
42316: NOT
42317: AND
42318: IFFALSE 42983
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42320: LD_ADDR_EXP 144
42324: PUSH
42325: LD_EXP 144
42329: PPUSH
42330: LD_VAR 0 1
42334: PPUSH
42335: LD_INT 6
42337: PPUSH
42338: CALL_OW 1
42342: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42343: LD_ADDR_VAR 0 2
42347: PUSH
42348: LD_INT 0
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: LD_INT 0
42356: PUSH
42357: LD_INT 0
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: ST_TO_ADDR
// if sci >= 1 then
42366: LD_VAR 0 8
42370: PUSH
42371: LD_INT 1
42373: GREATEREQUAL
42374: IFFALSE 42396
// tmp := tmp diff sci [ 1 ] ;
42376: LD_ADDR_VAR 0 4
42380: PUSH
42381: LD_VAR 0 4
42385: PUSH
42386: LD_VAR 0 8
42390: PUSH
42391: LD_INT 1
42393: ARRAY
42394: DIFF
42395: ST_TO_ADDR
// if tmp and not sci then
42396: LD_VAR 0 4
42400: PUSH
42401: LD_VAR 0 8
42405: NOT
42406: AND
42407: IFFALSE 42476
// begin sort := SortBySkill ( tmp , 4 ) ;
42409: LD_ADDR_VAR 0 9
42413: PUSH
42414: LD_VAR 0 4
42418: PPUSH
42419: LD_INT 4
42421: PPUSH
42422: CALL 106277 0 2
42426: ST_TO_ADDR
// if sort then
42427: LD_VAR 0 9
42431: IFFALSE 42447
// p := sort [ 1 ] ;
42433: LD_ADDR_VAR 0 11
42437: PUSH
42438: LD_VAR 0 9
42442: PUSH
42443: LD_INT 1
42445: ARRAY
42446: ST_TO_ADDR
// if p then
42447: LD_VAR 0 11
42451: IFFALSE 42476
// result := Replace ( result , 4 , p ) ;
42453: LD_ADDR_VAR 0 2
42457: PUSH
42458: LD_VAR 0 2
42462: PPUSH
42463: LD_INT 4
42465: PPUSH
42466: LD_VAR 0 11
42470: PPUSH
42471: CALL_OW 1
42475: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42476: LD_ADDR_VAR 0 4
42480: PUSH
42481: LD_VAR 0 4
42485: PUSH
42486: LD_VAR 0 7
42490: DIFF
42491: ST_TO_ADDR
// if tmp and mech < 6 then
42492: LD_VAR 0 4
42496: PUSH
42497: LD_VAR 0 7
42501: PUSH
42502: LD_INT 6
42504: LESS
42505: AND
42506: IFFALSE 42688
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42508: LD_ADDR_VAR 0 9
42512: PUSH
42513: LD_VAR 0 4
42517: PUSH
42518: LD_VAR 0 7
42522: DIFF
42523: PPUSH
42524: LD_INT 3
42526: PPUSH
42527: CALL 106277 0 2
42531: ST_TO_ADDR
// p := [ ] ;
42532: LD_ADDR_VAR 0 11
42536: PUSH
42537: EMPTY
42538: ST_TO_ADDR
// if sort then
42539: LD_VAR 0 9
42543: IFFALSE 42659
// for i = 1 to 6 - mech do
42545: LD_ADDR_VAR 0 3
42549: PUSH
42550: DOUBLE
42551: LD_INT 1
42553: DEC
42554: ST_TO_ADDR
42555: LD_INT 6
42557: PUSH
42558: LD_VAR 0 7
42562: MINUS
42563: PUSH
42564: FOR_TO
42565: IFFALSE 42657
// begin if i = sort then
42567: LD_VAR 0 3
42571: PUSH
42572: LD_VAR 0 9
42576: EQUAL
42577: IFFALSE 42581
// break ;
42579: GO 42657
// if GetClass ( i ) = 3 then
42581: LD_VAR 0 3
42585: PPUSH
42586: CALL_OW 257
42590: PUSH
42591: LD_INT 3
42593: EQUAL
42594: IFFALSE 42598
// continue ;
42596: GO 42564
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42598: LD_ADDR_VAR 0 11
42602: PUSH
42603: LD_VAR 0 11
42607: PPUSH
42608: LD_VAR 0 11
42612: PUSH
42613: LD_INT 1
42615: PLUS
42616: PPUSH
42617: LD_VAR 0 9
42621: PUSH
42622: LD_VAR 0 3
42626: ARRAY
42627: PPUSH
42628: CALL_OW 2
42632: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42633: LD_ADDR_VAR 0 4
42637: PUSH
42638: LD_VAR 0 4
42642: PUSH
42643: LD_VAR 0 9
42647: PUSH
42648: LD_VAR 0 3
42652: ARRAY
42653: DIFF
42654: ST_TO_ADDR
// end ;
42655: GO 42564
42657: POP
42658: POP
// if p then
42659: LD_VAR 0 11
42663: IFFALSE 42688
// result := Replace ( result , 3 , p ) ;
42665: LD_ADDR_VAR 0 2
42669: PUSH
42670: LD_VAR 0 2
42674: PPUSH
42675: LD_INT 3
42677: PPUSH
42678: LD_VAR 0 11
42682: PPUSH
42683: CALL_OW 1
42687: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42688: LD_ADDR_VAR 0 4
42692: PUSH
42693: LD_VAR 0 4
42697: PUSH
42698: LD_VAR 0 6
42702: DIFF
42703: ST_TO_ADDR
// if tmp and eng < 4 then
42704: LD_VAR 0 4
42708: PUSH
42709: LD_VAR 0 6
42713: PUSH
42714: LD_INT 4
42716: LESS
42717: AND
42718: IFFALSE 42908
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42720: LD_ADDR_VAR 0 9
42724: PUSH
42725: LD_VAR 0 4
42729: PUSH
42730: LD_VAR 0 7
42734: PUSH
42735: LD_VAR 0 6
42739: UNION
42740: DIFF
42741: PPUSH
42742: LD_INT 2
42744: PPUSH
42745: CALL 106277 0 2
42749: ST_TO_ADDR
// p := [ ] ;
42750: LD_ADDR_VAR 0 11
42754: PUSH
42755: EMPTY
42756: ST_TO_ADDR
// if sort then
42757: LD_VAR 0 9
42761: IFFALSE 42877
// for i = 1 to 4 - eng do
42763: LD_ADDR_VAR 0 3
42767: PUSH
42768: DOUBLE
42769: LD_INT 1
42771: DEC
42772: ST_TO_ADDR
42773: LD_INT 4
42775: PUSH
42776: LD_VAR 0 6
42780: MINUS
42781: PUSH
42782: FOR_TO
42783: IFFALSE 42875
// begin if i = sort then
42785: LD_VAR 0 3
42789: PUSH
42790: LD_VAR 0 9
42794: EQUAL
42795: IFFALSE 42799
// break ;
42797: GO 42875
// if GetClass ( i ) = 2 then
42799: LD_VAR 0 3
42803: PPUSH
42804: CALL_OW 257
42808: PUSH
42809: LD_INT 2
42811: EQUAL
42812: IFFALSE 42816
// continue ;
42814: GO 42782
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42816: LD_ADDR_VAR 0 11
42820: PUSH
42821: LD_VAR 0 11
42825: PPUSH
42826: LD_VAR 0 11
42830: PUSH
42831: LD_INT 1
42833: PLUS
42834: PPUSH
42835: LD_VAR 0 9
42839: PUSH
42840: LD_VAR 0 3
42844: ARRAY
42845: PPUSH
42846: CALL_OW 2
42850: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42851: LD_ADDR_VAR 0 4
42855: PUSH
42856: LD_VAR 0 4
42860: PUSH
42861: LD_VAR 0 9
42865: PUSH
42866: LD_VAR 0 3
42870: ARRAY
42871: DIFF
42872: ST_TO_ADDR
// end ;
42873: GO 42782
42875: POP
42876: POP
// if p then
42877: LD_VAR 0 11
42881: IFFALSE 42906
// result := Replace ( result , 2 , p ) ;
42883: LD_ADDR_VAR 0 2
42887: PUSH
42888: LD_VAR 0 2
42892: PPUSH
42893: LD_INT 2
42895: PPUSH
42896: LD_VAR 0 11
42900: PPUSH
42901: CALL_OW 1
42905: ST_TO_ADDR
// end else
42906: GO 42952
// for i = eng downto 5 do
42908: LD_ADDR_VAR 0 3
42912: PUSH
42913: DOUBLE
42914: LD_VAR 0 6
42918: INC
42919: ST_TO_ADDR
42920: LD_INT 5
42922: PUSH
42923: FOR_DOWNTO
42924: IFFALSE 42950
// tmp := tmp union eng [ i ] ;
42926: LD_ADDR_VAR 0 4
42930: PUSH
42931: LD_VAR 0 4
42935: PUSH
42936: LD_VAR 0 6
42940: PUSH
42941: LD_VAR 0 3
42945: ARRAY
42946: UNION
42947: ST_TO_ADDR
42948: GO 42923
42950: POP
42951: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42952: LD_ADDR_VAR 0 2
42956: PUSH
42957: LD_VAR 0 2
42961: PPUSH
42962: LD_INT 1
42964: PPUSH
42965: LD_VAR 0 4
42969: PUSH
42970: LD_VAR 0 5
42974: DIFF
42975: PPUSH
42976: CALL_OW 1
42980: ST_TO_ADDR
// exit ;
42981: GO 42983
// end ; end ;
42983: LD_VAR 0 2
42987: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42988: LD_INT 0
42990: PPUSH
42991: PPUSH
42992: PPUSH
// if not mc_bases then
42993: LD_EXP 102
42997: NOT
42998: IFFALSE 43002
// exit ;
43000: GO 43108
// for i = 1 to mc_bases do
43002: LD_ADDR_VAR 0 2
43006: PUSH
43007: DOUBLE
43008: LD_INT 1
43010: DEC
43011: ST_TO_ADDR
43012: LD_EXP 102
43016: PUSH
43017: FOR_TO
43018: IFFALSE 43099
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43020: LD_ADDR_VAR 0 3
43024: PUSH
43025: LD_EXP 102
43029: PUSH
43030: LD_VAR 0 2
43034: ARRAY
43035: PPUSH
43036: LD_INT 21
43038: PUSH
43039: LD_INT 3
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: LD_INT 3
43048: PUSH
43049: LD_INT 24
43051: PUSH
43052: LD_INT 1000
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PPUSH
43067: CALL_OW 72
43071: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43072: LD_ADDR_EXP 103
43076: PUSH
43077: LD_EXP 103
43081: PPUSH
43082: LD_VAR 0 2
43086: PPUSH
43087: LD_VAR 0 3
43091: PPUSH
43092: CALL_OW 1
43096: ST_TO_ADDR
// end ;
43097: GO 43017
43099: POP
43100: POP
// RaiseSailEvent ( 101 ) ;
43101: LD_INT 101
43103: PPUSH
43104: CALL_OW 427
// end ;
43108: LD_VAR 0 1
43112: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43113: LD_INT 0
43115: PPUSH
43116: PPUSH
43117: PPUSH
43118: PPUSH
43119: PPUSH
43120: PPUSH
43121: PPUSH
// if not mc_bases then
43122: LD_EXP 102
43126: NOT
43127: IFFALSE 43131
// exit ;
43129: GO 43704
// for i = 1 to mc_bases do
43131: LD_ADDR_VAR 0 2
43135: PUSH
43136: DOUBLE
43137: LD_INT 1
43139: DEC
43140: ST_TO_ADDR
43141: LD_EXP 102
43145: PUSH
43146: FOR_TO
43147: IFFALSE 43695
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43149: LD_ADDR_VAR 0 5
43153: PUSH
43154: LD_EXP 102
43158: PUSH
43159: LD_VAR 0 2
43163: ARRAY
43164: PUSH
43165: LD_EXP 131
43169: PUSH
43170: LD_VAR 0 2
43174: ARRAY
43175: UNION
43176: PPUSH
43177: LD_INT 21
43179: PUSH
43180: LD_INT 1
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 1
43189: PUSH
43190: LD_INT 3
43192: PUSH
43193: LD_INT 54
43195: PUSH
43196: EMPTY
43197: LIST
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 3
43205: PUSH
43206: LD_INT 24
43208: PUSH
43209: LD_INT 800
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: LIST
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PPUSH
43229: CALL_OW 72
43233: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43234: LD_ADDR_VAR 0 6
43238: PUSH
43239: LD_EXP 102
43243: PUSH
43244: LD_VAR 0 2
43248: ARRAY
43249: PPUSH
43250: LD_INT 21
43252: PUSH
43253: LD_INT 1
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 1
43262: PUSH
43263: LD_INT 3
43265: PUSH
43266: LD_INT 54
43268: PUSH
43269: EMPTY
43270: LIST
43271: PUSH
43272: EMPTY
43273: LIST
43274: LIST
43275: PUSH
43276: LD_INT 3
43278: PUSH
43279: LD_INT 24
43281: PUSH
43282: LD_INT 250
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: LIST
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PPUSH
43302: CALL_OW 72
43306: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43307: LD_ADDR_VAR 0 7
43311: PUSH
43312: LD_VAR 0 5
43316: PUSH
43317: LD_VAR 0 6
43321: DIFF
43322: ST_TO_ADDR
// if not need_heal_1 then
43323: LD_VAR 0 6
43327: NOT
43328: IFFALSE 43361
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43330: LD_ADDR_EXP 105
43334: PUSH
43335: LD_EXP 105
43339: PPUSH
43340: LD_VAR 0 2
43344: PUSH
43345: LD_INT 1
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PPUSH
43352: EMPTY
43353: PPUSH
43354: CALL 72019 0 3
43358: ST_TO_ADDR
43359: GO 43431
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43361: LD_ADDR_EXP 105
43365: PUSH
43366: LD_EXP 105
43370: PPUSH
43371: LD_VAR 0 2
43375: PUSH
43376: LD_INT 1
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PPUSH
43383: LD_EXP 105
43387: PUSH
43388: LD_VAR 0 2
43392: ARRAY
43393: PUSH
43394: LD_INT 1
43396: ARRAY
43397: PPUSH
43398: LD_INT 3
43400: PUSH
43401: LD_INT 24
43403: PUSH
43404: LD_INT 1000
43406: PUSH
43407: EMPTY
43408: LIST
43409: LIST
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PPUSH
43415: CALL_OW 72
43419: PUSH
43420: LD_VAR 0 6
43424: UNION
43425: PPUSH
43426: CALL 72019 0 3
43430: ST_TO_ADDR
// if not need_heal_2 then
43431: LD_VAR 0 7
43435: NOT
43436: IFFALSE 43469
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43438: LD_ADDR_EXP 105
43442: PUSH
43443: LD_EXP 105
43447: PPUSH
43448: LD_VAR 0 2
43452: PUSH
43453: LD_INT 2
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PPUSH
43460: EMPTY
43461: PPUSH
43462: CALL 72019 0 3
43466: ST_TO_ADDR
43467: GO 43501
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43469: LD_ADDR_EXP 105
43473: PUSH
43474: LD_EXP 105
43478: PPUSH
43479: LD_VAR 0 2
43483: PUSH
43484: LD_INT 2
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PPUSH
43491: LD_VAR 0 7
43495: PPUSH
43496: CALL 72019 0 3
43500: ST_TO_ADDR
// if need_heal_2 then
43501: LD_VAR 0 7
43505: IFFALSE 43677
// for j in need_heal_2 do
43507: LD_ADDR_VAR 0 3
43511: PUSH
43512: LD_VAR 0 7
43516: PUSH
43517: FOR_IN
43518: IFFALSE 43675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43520: LD_ADDR_VAR 0 5
43524: PUSH
43525: LD_EXP 102
43529: PUSH
43530: LD_VAR 0 2
43534: ARRAY
43535: PPUSH
43536: LD_INT 2
43538: PUSH
43539: LD_INT 30
43541: PUSH
43542: LD_INT 6
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 30
43551: PUSH
43552: LD_INT 7
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 30
43561: PUSH
43562: LD_INT 8
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 30
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 30
43581: PUSH
43582: LD_INT 1
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 25
43591: PUSH
43592: LD_INT 4
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: LIST
43603: LIST
43604: LIST
43605: LIST
43606: LIST
43607: PPUSH
43608: CALL_OW 72
43612: ST_TO_ADDR
// if tmp then
43613: LD_VAR 0 5
43617: IFFALSE 43673
// begin k := NearestUnitToUnit ( tmp , j ) ;
43619: LD_ADDR_VAR 0 4
43623: PUSH
43624: LD_VAR 0 5
43628: PPUSH
43629: LD_VAR 0 3
43633: PPUSH
43634: CALL_OW 74
43638: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43639: LD_VAR 0 3
43643: PPUSH
43644: LD_VAR 0 4
43648: PPUSH
43649: CALL_OW 296
43653: PUSH
43654: LD_INT 7
43656: GREATER
43657: IFFALSE 43673
// ComMoveUnit ( j , k ) ;
43659: LD_VAR 0 3
43663: PPUSH
43664: LD_VAR 0 4
43668: PPUSH
43669: CALL_OW 112
// end ; end ;
43673: GO 43517
43675: POP
43676: POP
// if not need_heal_1 and not need_heal_2 then
43677: LD_VAR 0 6
43681: NOT
43682: PUSH
43683: LD_VAR 0 7
43687: NOT
43688: AND
43689: IFFALSE 43693
// continue ;
43691: GO 43146
// end ;
43693: GO 43146
43695: POP
43696: POP
// RaiseSailEvent ( 102 ) ;
43697: LD_INT 102
43699: PPUSH
43700: CALL_OW 427
// end ;
43704: LD_VAR 0 1
43708: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43709: LD_INT 0
43711: PPUSH
43712: PPUSH
43713: PPUSH
43714: PPUSH
43715: PPUSH
43716: PPUSH
43717: PPUSH
43718: PPUSH
// if not mc_bases then
43719: LD_EXP 102
43723: NOT
43724: IFFALSE 43728
// exit ;
43726: GO 44568
// for i = 1 to mc_bases do
43728: LD_ADDR_VAR 0 2
43732: PUSH
43733: DOUBLE
43734: LD_INT 1
43736: DEC
43737: ST_TO_ADDR
43738: LD_EXP 102
43742: PUSH
43743: FOR_TO
43744: IFFALSE 44566
// begin if not mc_building_need_repair [ i ] then
43746: LD_EXP 103
43750: PUSH
43751: LD_VAR 0 2
43755: ARRAY
43756: NOT
43757: IFFALSE 43931
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43759: LD_ADDR_VAR 0 6
43763: PUSH
43764: LD_EXP 121
43768: PUSH
43769: LD_VAR 0 2
43773: ARRAY
43774: PPUSH
43775: LD_INT 3
43777: PUSH
43778: LD_INT 24
43780: PUSH
43781: LD_INT 1000
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: EMPTY
43789: LIST
43790: LIST
43791: PUSH
43792: LD_INT 2
43794: PUSH
43795: LD_INT 34
43797: PUSH
43798: LD_INT 13
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 34
43807: PUSH
43808: LD_INT 52
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: LIST
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PPUSH
43824: CALL_OW 72
43828: ST_TO_ADDR
// if cranes then
43829: LD_VAR 0 6
43833: IFFALSE 43895
// for j in cranes do
43835: LD_ADDR_VAR 0 3
43839: PUSH
43840: LD_VAR 0 6
43844: PUSH
43845: FOR_IN
43846: IFFALSE 43893
// if not IsInArea ( j , mc_parking [ i ] ) then
43848: LD_VAR 0 3
43852: PPUSH
43853: LD_EXP 126
43857: PUSH
43858: LD_VAR 0 2
43862: ARRAY
43863: PPUSH
43864: CALL_OW 308
43868: NOT
43869: IFFALSE 43891
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43871: LD_VAR 0 3
43875: PPUSH
43876: LD_EXP 126
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: PPUSH
43887: CALL_OW 113
43891: GO 43845
43893: POP
43894: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43895: LD_ADDR_EXP 104
43899: PUSH
43900: LD_EXP 104
43904: PPUSH
43905: LD_VAR 0 2
43909: PPUSH
43910: EMPTY
43911: PPUSH
43912: CALL_OW 1
43916: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43917: LD_VAR 0 2
43921: PPUSH
43922: LD_INT 101
43924: PPUSH
43925: CALL 38821 0 2
// continue ;
43929: GO 43743
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43931: LD_ADDR_EXP 108
43935: PUSH
43936: LD_EXP 108
43940: PPUSH
43941: LD_VAR 0 2
43945: PPUSH
43946: EMPTY
43947: PPUSH
43948: CALL_OW 1
43952: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43953: LD_VAR 0 2
43957: PPUSH
43958: LD_INT 103
43960: PPUSH
43961: CALL 38821 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43965: LD_ADDR_VAR 0 5
43969: PUSH
43970: LD_EXP 102
43974: PUSH
43975: LD_VAR 0 2
43979: ARRAY
43980: PUSH
43981: LD_EXP 131
43985: PUSH
43986: LD_VAR 0 2
43990: ARRAY
43991: UNION
43992: PPUSH
43993: LD_INT 2
43995: PUSH
43996: LD_INT 25
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 25
44008: PUSH
44009: LD_INT 16
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: LIST
44020: PUSH
44021: EMPTY
44022: LIST
44023: PPUSH
44024: CALL_OW 72
44028: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44029: LD_ADDR_VAR 0 6
44033: PUSH
44034: LD_EXP 121
44038: PUSH
44039: LD_VAR 0 2
44043: ARRAY
44044: PPUSH
44045: LD_INT 2
44047: PUSH
44048: LD_INT 34
44050: PUSH
44051: LD_INT 13
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 34
44060: PUSH
44061: LD_INT 52
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: LIST
44072: PPUSH
44073: CALL_OW 72
44077: ST_TO_ADDR
// if cranes then
44078: LD_VAR 0 6
44082: IFFALSE 44218
// begin for j in cranes do
44084: LD_ADDR_VAR 0 3
44088: PUSH
44089: LD_VAR 0 6
44093: PUSH
44094: FOR_IN
44095: IFFALSE 44216
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44097: LD_VAR 0 3
44101: PPUSH
44102: CALL_OW 256
44106: PUSH
44107: LD_INT 500
44109: GREATEREQUAL
44110: PUSH
44111: LD_VAR 0 3
44115: PPUSH
44116: CALL_OW 314
44120: NOT
44121: AND
44122: IFFALSE 44156
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44124: LD_VAR 0 3
44128: PPUSH
44129: LD_EXP 103
44133: PUSH
44134: LD_VAR 0 2
44138: ARRAY
44139: PPUSH
44140: LD_VAR 0 3
44144: PPUSH
44145: CALL_OW 74
44149: PPUSH
44150: CALL_OW 130
44154: GO 44214
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44156: LD_VAR 0 3
44160: PPUSH
44161: CALL_OW 256
44165: PUSH
44166: LD_INT 500
44168: LESS
44169: PUSH
44170: LD_VAR 0 3
44174: PPUSH
44175: LD_EXP 126
44179: PUSH
44180: LD_VAR 0 2
44184: ARRAY
44185: PPUSH
44186: CALL_OW 308
44190: NOT
44191: AND
44192: IFFALSE 44214
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44194: LD_VAR 0 3
44198: PPUSH
44199: LD_EXP 126
44203: PUSH
44204: LD_VAR 0 2
44208: ARRAY
44209: PPUSH
44210: CALL_OW 113
44214: GO 44094
44216: POP
44217: POP
// end ; if not tmp then
44218: LD_VAR 0 5
44222: NOT
44223: IFFALSE 44227
// continue ;
44225: GO 43743
// for j in tmp do
44227: LD_ADDR_VAR 0 3
44231: PUSH
44232: LD_VAR 0 5
44236: PUSH
44237: FOR_IN
44238: IFFALSE 44562
// begin if mc_need_heal [ i ] then
44240: LD_EXP 105
44244: PUSH
44245: LD_VAR 0 2
44249: ARRAY
44250: IFFALSE 44298
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44252: LD_VAR 0 3
44256: PUSH
44257: LD_EXP 105
44261: PUSH
44262: LD_VAR 0 2
44266: ARRAY
44267: PUSH
44268: LD_INT 1
44270: ARRAY
44271: IN
44272: PUSH
44273: LD_VAR 0 3
44277: PUSH
44278: LD_EXP 105
44282: PUSH
44283: LD_VAR 0 2
44287: ARRAY
44288: PUSH
44289: LD_INT 2
44291: ARRAY
44292: IN
44293: OR
44294: IFFALSE 44298
// continue ;
44296: GO 44237
// if IsInUnit ( j ) then
44298: LD_VAR 0 3
44302: PPUSH
44303: CALL_OW 310
44307: IFFALSE 44318
// ComExitBuilding ( j ) ;
44309: LD_VAR 0 3
44313: PPUSH
44314: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44318: LD_VAR 0 3
44322: PUSH
44323: LD_EXP 104
44327: PUSH
44328: LD_VAR 0 2
44332: ARRAY
44333: IN
44334: NOT
44335: IFFALSE 44393
// begin SetTag ( j , 101 ) ;
44337: LD_VAR 0 3
44341: PPUSH
44342: LD_INT 101
44344: PPUSH
44345: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44349: LD_ADDR_EXP 104
44353: PUSH
44354: LD_EXP 104
44358: PPUSH
44359: LD_VAR 0 2
44363: PUSH
44364: LD_EXP 104
44368: PUSH
44369: LD_VAR 0 2
44373: ARRAY
44374: PUSH
44375: LD_INT 1
44377: PLUS
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PPUSH
44383: LD_VAR 0 3
44387: PPUSH
44388: CALL 72019 0 3
44392: ST_TO_ADDR
// end ; wait ( 1 ) ;
44393: LD_INT 1
44395: PPUSH
44396: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44400: LD_ADDR_VAR 0 7
44404: PUSH
44405: LD_EXP 103
44409: PUSH
44410: LD_VAR 0 2
44414: ARRAY
44415: ST_TO_ADDR
// if mc_scan [ i ] then
44416: LD_EXP 125
44420: PUSH
44421: LD_VAR 0 2
44425: ARRAY
44426: IFFALSE 44495
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44428: LD_ADDR_VAR 0 7
44432: PUSH
44433: LD_EXP 103
44437: PUSH
44438: LD_VAR 0 2
44442: ARRAY
44443: PPUSH
44444: LD_INT 3
44446: PUSH
44447: LD_INT 2
44449: PUSH
44450: LD_INT 30
44452: PUSH
44453: LD_INT 32
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 30
44462: PUSH
44463: LD_INT 33
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 30
44472: PUSH
44473: LD_INT 31
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: LIST
44484: LIST
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PPUSH
44490: CALL_OW 72
44494: ST_TO_ADDR
// if not to_repair_tmp then
44495: LD_VAR 0 7
44499: NOT
44500: IFFALSE 44504
// continue ;
44502: GO 44237
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44504: LD_ADDR_VAR 0 8
44508: PUSH
44509: LD_VAR 0 7
44513: PPUSH
44514: LD_VAR 0 3
44518: PPUSH
44519: CALL_OW 74
44523: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44524: LD_VAR 0 8
44528: PPUSH
44529: LD_INT 14
44531: PPUSH
44532: CALL 74612 0 2
44536: PUSH
44537: LD_INT 4
44539: ARRAY
44540: PUSH
44541: LD_INT 5
44543: LESS
44544: IFFALSE 44560
// ComRepairBuilding ( j , to_repair ) ;
44546: LD_VAR 0 3
44550: PPUSH
44551: LD_VAR 0 8
44555: PPUSH
44556: CALL_OW 130
// end ;
44560: GO 44237
44562: POP
44563: POP
// end ;
44564: GO 43743
44566: POP
44567: POP
// end ;
44568: LD_VAR 0 1
44572: RET
// export function MC_Heal ; var i , j , tmp ; begin
44573: LD_INT 0
44575: PPUSH
44576: PPUSH
44577: PPUSH
44578: PPUSH
// if not mc_bases then
44579: LD_EXP 102
44583: NOT
44584: IFFALSE 44588
// exit ;
44586: GO 44990
// for i = 1 to mc_bases do
44588: LD_ADDR_VAR 0 2
44592: PUSH
44593: DOUBLE
44594: LD_INT 1
44596: DEC
44597: ST_TO_ADDR
44598: LD_EXP 102
44602: PUSH
44603: FOR_TO
44604: IFFALSE 44988
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44606: LD_EXP 105
44610: PUSH
44611: LD_VAR 0 2
44615: ARRAY
44616: PUSH
44617: LD_INT 1
44619: ARRAY
44620: NOT
44621: PUSH
44622: LD_EXP 105
44626: PUSH
44627: LD_VAR 0 2
44631: ARRAY
44632: PUSH
44633: LD_INT 2
44635: ARRAY
44636: NOT
44637: AND
44638: IFFALSE 44676
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44640: LD_ADDR_EXP 106
44644: PUSH
44645: LD_EXP 106
44649: PPUSH
44650: LD_VAR 0 2
44654: PPUSH
44655: EMPTY
44656: PPUSH
44657: CALL_OW 1
44661: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44662: LD_VAR 0 2
44666: PPUSH
44667: LD_INT 102
44669: PPUSH
44670: CALL 38821 0 2
// continue ;
44674: GO 44603
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44676: LD_ADDR_VAR 0 4
44680: PUSH
44681: LD_EXP 102
44685: PUSH
44686: LD_VAR 0 2
44690: ARRAY
44691: PPUSH
44692: LD_INT 25
44694: PUSH
44695: LD_INT 4
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PPUSH
44702: CALL_OW 72
44706: ST_TO_ADDR
// if not tmp then
44707: LD_VAR 0 4
44711: NOT
44712: IFFALSE 44716
// continue ;
44714: GO 44603
// if mc_taming [ i ] then
44716: LD_EXP 133
44720: PUSH
44721: LD_VAR 0 2
44725: ARRAY
44726: IFFALSE 44750
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44728: LD_ADDR_EXP 133
44732: PUSH
44733: LD_EXP 133
44737: PPUSH
44738: LD_VAR 0 2
44742: PPUSH
44743: EMPTY
44744: PPUSH
44745: CALL_OW 1
44749: ST_TO_ADDR
// for j in tmp do
44750: LD_ADDR_VAR 0 3
44754: PUSH
44755: LD_VAR 0 4
44759: PUSH
44760: FOR_IN
44761: IFFALSE 44984
// begin if IsInUnit ( j ) then
44763: LD_VAR 0 3
44767: PPUSH
44768: CALL_OW 310
44772: IFFALSE 44783
// ComExitBuilding ( j ) ;
44774: LD_VAR 0 3
44778: PPUSH
44779: CALL_OW 122
// if not j in mc_healers [ i ] then
44783: LD_VAR 0 3
44787: PUSH
44788: LD_EXP 106
44792: PUSH
44793: LD_VAR 0 2
44797: ARRAY
44798: IN
44799: NOT
44800: IFFALSE 44846
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44802: LD_ADDR_EXP 106
44806: PUSH
44807: LD_EXP 106
44811: PPUSH
44812: LD_VAR 0 2
44816: PUSH
44817: LD_EXP 106
44821: PUSH
44822: LD_VAR 0 2
44826: ARRAY
44827: PUSH
44828: LD_INT 1
44830: PLUS
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PPUSH
44836: LD_VAR 0 3
44840: PPUSH
44841: CALL 72019 0 3
44845: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44846: LD_VAR 0 3
44850: PPUSH
44851: CALL_OW 110
44855: PUSH
44856: LD_INT 102
44858: NONEQUAL
44859: IFFALSE 44873
// SetTag ( j , 102 ) ;
44861: LD_VAR 0 3
44865: PPUSH
44866: LD_INT 102
44868: PPUSH
44869: CALL_OW 109
// Wait ( 3 ) ;
44873: LD_INT 3
44875: PPUSH
44876: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44880: LD_EXP 105
44884: PUSH
44885: LD_VAR 0 2
44889: ARRAY
44890: PUSH
44891: LD_INT 1
44893: ARRAY
44894: IFFALSE 44926
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44896: LD_VAR 0 3
44900: PPUSH
44901: LD_EXP 105
44905: PUSH
44906: LD_VAR 0 2
44910: ARRAY
44911: PUSH
44912: LD_INT 1
44914: ARRAY
44915: PUSH
44916: LD_INT 1
44918: ARRAY
44919: PPUSH
44920: CALL_OW 128
44924: GO 44982
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44926: LD_VAR 0 3
44930: PPUSH
44931: CALL_OW 314
44935: NOT
44936: PUSH
44937: LD_EXP 105
44941: PUSH
44942: LD_VAR 0 2
44946: ARRAY
44947: PUSH
44948: LD_INT 2
44950: ARRAY
44951: AND
44952: IFFALSE 44982
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44954: LD_VAR 0 3
44958: PPUSH
44959: LD_EXP 105
44963: PUSH
44964: LD_VAR 0 2
44968: ARRAY
44969: PUSH
44970: LD_INT 2
44972: ARRAY
44973: PUSH
44974: LD_INT 1
44976: ARRAY
44977: PPUSH
44978: CALL_OW 128
// end ;
44982: GO 44760
44984: POP
44985: POP
// end ;
44986: GO 44603
44988: POP
44989: POP
// end ;
44990: LD_VAR 0 1
44994: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44995: LD_INT 0
44997: PPUSH
44998: PPUSH
44999: PPUSH
45000: PPUSH
45001: PPUSH
// if not mc_bases then
45002: LD_EXP 102
45006: NOT
45007: IFFALSE 45011
// exit ;
45009: GO 46154
// for i = 1 to mc_bases do
45011: LD_ADDR_VAR 0 2
45015: PUSH
45016: DOUBLE
45017: LD_INT 1
45019: DEC
45020: ST_TO_ADDR
45021: LD_EXP 102
45025: PUSH
45026: FOR_TO
45027: IFFALSE 46152
// begin if mc_scan [ i ] then
45029: LD_EXP 125
45033: PUSH
45034: LD_VAR 0 2
45038: ARRAY
45039: IFFALSE 45043
// continue ;
45041: GO 45026
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45043: LD_EXP 107
45047: PUSH
45048: LD_VAR 0 2
45052: ARRAY
45053: NOT
45054: PUSH
45055: LD_EXP 109
45059: PUSH
45060: LD_VAR 0 2
45064: ARRAY
45065: NOT
45066: AND
45067: PUSH
45068: LD_EXP 108
45072: PUSH
45073: LD_VAR 0 2
45077: ARRAY
45078: AND
45079: IFFALSE 45117
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45081: LD_ADDR_EXP 108
45085: PUSH
45086: LD_EXP 108
45090: PPUSH
45091: LD_VAR 0 2
45095: PPUSH
45096: EMPTY
45097: PPUSH
45098: CALL_OW 1
45102: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45103: LD_VAR 0 2
45107: PPUSH
45108: LD_INT 103
45110: PPUSH
45111: CALL 38821 0 2
// continue ;
45115: GO 45026
// end ; if mc_construct_list [ i ] then
45117: LD_EXP 109
45121: PUSH
45122: LD_VAR 0 2
45126: ARRAY
45127: IFFALSE 45347
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45129: LD_ADDR_VAR 0 4
45133: PUSH
45134: LD_EXP 102
45138: PUSH
45139: LD_VAR 0 2
45143: ARRAY
45144: PPUSH
45145: LD_INT 25
45147: PUSH
45148: LD_INT 2
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PPUSH
45155: CALL_OW 72
45159: PUSH
45160: LD_EXP 104
45164: PUSH
45165: LD_VAR 0 2
45169: ARRAY
45170: DIFF
45171: ST_TO_ADDR
// if not tmp then
45172: LD_VAR 0 4
45176: NOT
45177: IFFALSE 45181
// continue ;
45179: GO 45026
// for j in tmp do
45181: LD_ADDR_VAR 0 3
45185: PUSH
45186: LD_VAR 0 4
45190: PUSH
45191: FOR_IN
45192: IFFALSE 45343
// begin if not mc_builders [ i ] then
45194: LD_EXP 108
45198: PUSH
45199: LD_VAR 0 2
45203: ARRAY
45204: NOT
45205: IFFALSE 45263
// begin SetTag ( j , 103 ) ;
45207: LD_VAR 0 3
45211: PPUSH
45212: LD_INT 103
45214: PPUSH
45215: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45219: LD_ADDR_EXP 108
45223: PUSH
45224: LD_EXP 108
45228: PPUSH
45229: LD_VAR 0 2
45233: PUSH
45234: LD_EXP 108
45238: PUSH
45239: LD_VAR 0 2
45243: ARRAY
45244: PUSH
45245: LD_INT 1
45247: PLUS
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PPUSH
45253: LD_VAR 0 3
45257: PPUSH
45258: CALL 72019 0 3
45262: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45263: LD_VAR 0 3
45267: PPUSH
45268: CALL_OW 310
45272: IFFALSE 45283
// ComExitBuilding ( j ) ;
45274: LD_VAR 0 3
45278: PPUSH
45279: CALL_OW 122
// wait ( 3 ) ;
45283: LD_INT 3
45285: PPUSH
45286: CALL_OW 67
// if not mc_construct_list [ i ] then
45290: LD_EXP 109
45294: PUSH
45295: LD_VAR 0 2
45299: ARRAY
45300: NOT
45301: IFFALSE 45305
// break ;
45303: GO 45343
// if not HasTask ( j ) then
45305: LD_VAR 0 3
45309: PPUSH
45310: CALL_OW 314
45314: NOT
45315: IFFALSE 45341
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45317: LD_VAR 0 3
45321: PPUSH
45322: LD_EXP 109
45326: PUSH
45327: LD_VAR 0 2
45331: ARRAY
45332: PUSH
45333: LD_INT 1
45335: ARRAY
45336: PPUSH
45337: CALL 74870 0 2
// end ;
45341: GO 45191
45343: POP
45344: POP
// end else
45345: GO 46150
// if mc_build_list [ i ] then
45347: LD_EXP 107
45351: PUSH
45352: LD_VAR 0 2
45356: ARRAY
45357: IFFALSE 46150
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45359: LD_ADDR_VAR 0 5
45363: PUSH
45364: LD_EXP 102
45368: PUSH
45369: LD_VAR 0 2
45373: ARRAY
45374: PPUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 30
45380: PUSH
45381: LD_INT 0
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 30
45390: PUSH
45391: LD_INT 1
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: PPUSH
45403: CALL_OW 72
45407: ST_TO_ADDR
// if depot then
45408: LD_VAR 0 5
45412: IFFALSE 45430
// depot := depot [ 1 ] else
45414: LD_ADDR_VAR 0 5
45418: PUSH
45419: LD_VAR 0 5
45423: PUSH
45424: LD_INT 1
45426: ARRAY
45427: ST_TO_ADDR
45428: GO 45438
// depot := 0 ;
45430: LD_ADDR_VAR 0 5
45434: PUSH
45435: LD_INT 0
45437: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45438: LD_EXP 107
45442: PUSH
45443: LD_VAR 0 2
45447: ARRAY
45448: PUSH
45449: LD_INT 1
45451: ARRAY
45452: PUSH
45453: LD_INT 1
45455: ARRAY
45456: PPUSH
45457: CALL 74700 0 1
45461: PUSH
45462: LD_EXP 102
45466: PUSH
45467: LD_VAR 0 2
45471: ARRAY
45472: PPUSH
45473: LD_INT 2
45475: PUSH
45476: LD_INT 30
45478: PUSH
45479: LD_INT 2
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 30
45488: PUSH
45489: LD_INT 3
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: LIST
45500: PPUSH
45501: CALL_OW 72
45505: NOT
45506: AND
45507: IFFALSE 45612
// begin for j = 1 to mc_build_list [ i ] do
45509: LD_ADDR_VAR 0 3
45513: PUSH
45514: DOUBLE
45515: LD_INT 1
45517: DEC
45518: ST_TO_ADDR
45519: LD_EXP 107
45523: PUSH
45524: LD_VAR 0 2
45528: ARRAY
45529: PUSH
45530: FOR_TO
45531: IFFALSE 45610
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45533: LD_EXP 107
45537: PUSH
45538: LD_VAR 0 2
45542: ARRAY
45543: PUSH
45544: LD_VAR 0 3
45548: ARRAY
45549: PUSH
45550: LD_INT 1
45552: ARRAY
45553: PUSH
45554: LD_INT 2
45556: EQUAL
45557: IFFALSE 45608
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45559: LD_ADDR_EXP 107
45563: PUSH
45564: LD_EXP 107
45568: PPUSH
45569: LD_VAR 0 2
45573: PPUSH
45574: LD_EXP 107
45578: PUSH
45579: LD_VAR 0 2
45583: ARRAY
45584: PPUSH
45585: LD_VAR 0 3
45589: PPUSH
45590: LD_INT 1
45592: PPUSH
45593: LD_INT 0
45595: PPUSH
45596: CALL 71437 0 4
45600: PPUSH
45601: CALL_OW 1
45605: ST_TO_ADDR
// break ;
45606: GO 45610
// end ;
45608: GO 45530
45610: POP
45611: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45612: LD_EXP 107
45616: PUSH
45617: LD_VAR 0 2
45621: ARRAY
45622: PUSH
45623: LD_INT 1
45625: ARRAY
45626: PUSH
45627: LD_INT 1
45629: ARRAY
45630: PUSH
45631: LD_INT 0
45633: EQUAL
45634: PUSH
45635: LD_VAR 0 5
45639: PUSH
45640: LD_VAR 0 5
45644: PPUSH
45645: LD_EXP 107
45649: PUSH
45650: LD_VAR 0 2
45654: ARRAY
45655: PUSH
45656: LD_INT 1
45658: ARRAY
45659: PUSH
45660: LD_INT 1
45662: ARRAY
45663: PPUSH
45664: LD_EXP 107
45668: PUSH
45669: LD_VAR 0 2
45673: ARRAY
45674: PUSH
45675: LD_INT 1
45677: ARRAY
45678: PUSH
45679: LD_INT 2
45681: ARRAY
45682: PPUSH
45683: LD_EXP 107
45687: PUSH
45688: LD_VAR 0 2
45692: ARRAY
45693: PUSH
45694: LD_INT 1
45696: ARRAY
45697: PUSH
45698: LD_INT 3
45700: ARRAY
45701: PPUSH
45702: LD_EXP 107
45706: PUSH
45707: LD_VAR 0 2
45711: ARRAY
45712: PUSH
45713: LD_INT 1
45715: ARRAY
45716: PUSH
45717: LD_INT 4
45719: ARRAY
45720: PPUSH
45721: CALL 79434 0 5
45725: AND
45726: OR
45727: IFFALSE 46008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45729: LD_ADDR_VAR 0 4
45733: PUSH
45734: LD_EXP 102
45738: PUSH
45739: LD_VAR 0 2
45743: ARRAY
45744: PPUSH
45745: LD_INT 25
45747: PUSH
45748: LD_INT 2
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PPUSH
45755: CALL_OW 72
45759: PUSH
45760: LD_EXP 104
45764: PUSH
45765: LD_VAR 0 2
45769: ARRAY
45770: DIFF
45771: ST_TO_ADDR
// if not tmp then
45772: LD_VAR 0 4
45776: NOT
45777: IFFALSE 45781
// continue ;
45779: GO 45026
// for j in tmp do
45781: LD_ADDR_VAR 0 3
45785: PUSH
45786: LD_VAR 0 4
45790: PUSH
45791: FOR_IN
45792: IFFALSE 46004
// begin if not mc_builders [ i ] then
45794: LD_EXP 108
45798: PUSH
45799: LD_VAR 0 2
45803: ARRAY
45804: NOT
45805: IFFALSE 45863
// begin SetTag ( j , 103 ) ;
45807: LD_VAR 0 3
45811: PPUSH
45812: LD_INT 103
45814: PPUSH
45815: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45819: LD_ADDR_EXP 108
45823: PUSH
45824: LD_EXP 108
45828: PPUSH
45829: LD_VAR 0 2
45833: PUSH
45834: LD_EXP 108
45838: PUSH
45839: LD_VAR 0 2
45843: ARRAY
45844: PUSH
45845: LD_INT 1
45847: PLUS
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PPUSH
45853: LD_VAR 0 3
45857: PPUSH
45858: CALL 72019 0 3
45862: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45863: LD_VAR 0 3
45867: PPUSH
45868: CALL_OW 310
45872: IFFALSE 45883
// ComExitBuilding ( j ) ;
45874: LD_VAR 0 3
45878: PPUSH
45879: CALL_OW 122
// wait ( 3 ) ;
45883: LD_INT 3
45885: PPUSH
45886: CALL_OW 67
// if not mc_build_list [ i ] then
45890: LD_EXP 107
45894: PUSH
45895: LD_VAR 0 2
45899: ARRAY
45900: NOT
45901: IFFALSE 45905
// break ;
45903: GO 46004
// if not HasTask ( j ) then
45905: LD_VAR 0 3
45909: PPUSH
45910: CALL_OW 314
45914: NOT
45915: IFFALSE 46002
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45917: LD_VAR 0 3
45921: PPUSH
45922: LD_EXP 107
45926: PUSH
45927: LD_VAR 0 2
45931: ARRAY
45932: PUSH
45933: LD_INT 1
45935: ARRAY
45936: PUSH
45937: LD_INT 1
45939: ARRAY
45940: PPUSH
45941: LD_EXP 107
45945: PUSH
45946: LD_VAR 0 2
45950: ARRAY
45951: PUSH
45952: LD_INT 1
45954: ARRAY
45955: PUSH
45956: LD_INT 2
45958: ARRAY
45959: PPUSH
45960: LD_EXP 107
45964: PUSH
45965: LD_VAR 0 2
45969: ARRAY
45970: PUSH
45971: LD_INT 1
45973: ARRAY
45974: PUSH
45975: LD_INT 3
45977: ARRAY
45978: PPUSH
45979: LD_EXP 107
45983: PUSH
45984: LD_VAR 0 2
45988: ARRAY
45989: PUSH
45990: LD_INT 1
45992: ARRAY
45993: PUSH
45994: LD_INT 4
45996: ARRAY
45997: PPUSH
45998: CALL_OW 145
// end ;
46002: GO 45791
46004: POP
46005: POP
// end else
46006: GO 46150
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46008: LD_EXP 102
46012: PUSH
46013: LD_VAR 0 2
46017: ARRAY
46018: PPUSH
46019: LD_EXP 107
46023: PUSH
46024: LD_VAR 0 2
46028: ARRAY
46029: PUSH
46030: LD_INT 1
46032: ARRAY
46033: PUSH
46034: LD_INT 1
46036: ARRAY
46037: PPUSH
46038: LD_EXP 107
46042: PUSH
46043: LD_VAR 0 2
46047: ARRAY
46048: PUSH
46049: LD_INT 1
46051: ARRAY
46052: PUSH
46053: LD_INT 2
46055: ARRAY
46056: PPUSH
46057: LD_EXP 107
46061: PUSH
46062: LD_VAR 0 2
46066: ARRAY
46067: PUSH
46068: LD_INT 1
46070: ARRAY
46071: PUSH
46072: LD_INT 3
46074: ARRAY
46075: PPUSH
46076: LD_EXP 107
46080: PUSH
46081: LD_VAR 0 2
46085: ARRAY
46086: PUSH
46087: LD_INT 1
46089: ARRAY
46090: PUSH
46091: LD_INT 4
46093: ARRAY
46094: PPUSH
46095: CALL 78770 0 5
46099: NOT
46100: IFFALSE 46150
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46102: LD_ADDR_EXP 107
46106: PUSH
46107: LD_EXP 107
46111: PPUSH
46112: LD_VAR 0 2
46116: PPUSH
46117: LD_EXP 107
46121: PUSH
46122: LD_VAR 0 2
46126: ARRAY
46127: PPUSH
46128: LD_INT 1
46130: PPUSH
46131: LD_INT 1
46133: NEG
46134: PPUSH
46135: LD_INT 0
46137: PPUSH
46138: CALL 71437 0 4
46142: PPUSH
46143: CALL_OW 1
46147: ST_TO_ADDR
// continue ;
46148: GO 45026
// end ; end ; end ;
46150: GO 45026
46152: POP
46153: POP
// end ;
46154: LD_VAR 0 1
46158: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46159: LD_INT 0
46161: PPUSH
46162: PPUSH
46163: PPUSH
46164: PPUSH
46165: PPUSH
46166: PPUSH
// if not mc_bases then
46167: LD_EXP 102
46171: NOT
46172: IFFALSE 46176
// exit ;
46174: GO 46603
// for i = 1 to mc_bases do
46176: LD_ADDR_VAR 0 2
46180: PUSH
46181: DOUBLE
46182: LD_INT 1
46184: DEC
46185: ST_TO_ADDR
46186: LD_EXP 102
46190: PUSH
46191: FOR_TO
46192: IFFALSE 46601
// begin tmp := mc_build_upgrade [ i ] ;
46194: LD_ADDR_VAR 0 4
46198: PUSH
46199: LD_EXP 134
46203: PUSH
46204: LD_VAR 0 2
46208: ARRAY
46209: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46210: LD_ADDR_VAR 0 6
46214: PUSH
46215: LD_EXP 135
46219: PUSH
46220: LD_VAR 0 2
46224: ARRAY
46225: PPUSH
46226: LD_INT 2
46228: PUSH
46229: LD_INT 30
46231: PUSH
46232: LD_INT 6
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: PUSH
46239: LD_INT 30
46241: PUSH
46242: LD_INT 7
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: LIST
46253: PPUSH
46254: CALL_OW 72
46258: ST_TO_ADDR
// if not tmp and not lab then
46259: LD_VAR 0 4
46263: NOT
46264: PUSH
46265: LD_VAR 0 6
46269: NOT
46270: AND
46271: IFFALSE 46275
// continue ;
46273: GO 46191
// if tmp then
46275: LD_VAR 0 4
46279: IFFALSE 46399
// for j in tmp do
46281: LD_ADDR_VAR 0 3
46285: PUSH
46286: LD_VAR 0 4
46290: PUSH
46291: FOR_IN
46292: IFFALSE 46397
// begin if UpgradeCost ( j ) then
46294: LD_VAR 0 3
46298: PPUSH
46299: CALL 78430 0 1
46303: IFFALSE 46395
// begin ComUpgrade ( j ) ;
46305: LD_VAR 0 3
46309: PPUSH
46310: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46314: LD_ADDR_EXP 134
46318: PUSH
46319: LD_EXP 134
46323: PPUSH
46324: LD_VAR 0 2
46328: PPUSH
46329: LD_EXP 134
46333: PUSH
46334: LD_VAR 0 2
46338: ARRAY
46339: PUSH
46340: LD_VAR 0 3
46344: DIFF
46345: PPUSH
46346: CALL_OW 1
46350: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46351: LD_ADDR_EXP 109
46355: PUSH
46356: LD_EXP 109
46360: PPUSH
46361: LD_VAR 0 2
46365: PUSH
46366: LD_EXP 109
46370: PUSH
46371: LD_VAR 0 2
46375: ARRAY
46376: PUSH
46377: LD_INT 1
46379: PLUS
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PPUSH
46385: LD_VAR 0 3
46389: PPUSH
46390: CALL 72019 0 3
46394: ST_TO_ADDR
// end ; end ;
46395: GO 46291
46397: POP
46398: POP
// if not lab or not mc_lab_upgrade [ i ] then
46399: LD_VAR 0 6
46403: NOT
46404: PUSH
46405: LD_EXP 136
46409: PUSH
46410: LD_VAR 0 2
46414: ARRAY
46415: NOT
46416: OR
46417: IFFALSE 46421
// continue ;
46419: GO 46191
// for j in lab do
46421: LD_ADDR_VAR 0 3
46425: PUSH
46426: LD_VAR 0 6
46430: PUSH
46431: FOR_IN
46432: IFFALSE 46597
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46434: LD_VAR 0 3
46438: PPUSH
46439: CALL_OW 266
46443: PUSH
46444: LD_INT 6
46446: PUSH
46447: LD_INT 7
46449: PUSH
46450: EMPTY
46451: LIST
46452: LIST
46453: IN
46454: PUSH
46455: LD_VAR 0 3
46459: PPUSH
46460: CALL_OW 461
46464: PUSH
46465: LD_INT 1
46467: NONEQUAL
46468: AND
46469: IFFALSE 46595
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46471: LD_VAR 0 3
46475: PPUSH
46476: LD_EXP 136
46480: PUSH
46481: LD_VAR 0 2
46485: ARRAY
46486: PUSH
46487: LD_INT 1
46489: ARRAY
46490: PPUSH
46491: CALL 78635 0 2
46495: IFFALSE 46595
// begin ComCancel ( j ) ;
46497: LD_VAR 0 3
46501: PPUSH
46502: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46506: LD_VAR 0 3
46510: PPUSH
46511: LD_EXP 136
46515: PUSH
46516: LD_VAR 0 2
46520: ARRAY
46521: PUSH
46522: LD_INT 1
46524: ARRAY
46525: PPUSH
46526: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46530: LD_VAR 0 3
46534: PUSH
46535: LD_EXP 109
46539: PUSH
46540: LD_VAR 0 2
46544: ARRAY
46545: IN
46546: NOT
46547: IFFALSE 46593
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46549: LD_ADDR_EXP 109
46553: PUSH
46554: LD_EXP 109
46558: PPUSH
46559: LD_VAR 0 2
46563: PUSH
46564: LD_EXP 109
46568: PUSH
46569: LD_VAR 0 2
46573: ARRAY
46574: PUSH
46575: LD_INT 1
46577: PLUS
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: PPUSH
46583: LD_VAR 0 3
46587: PPUSH
46588: CALL 72019 0 3
46592: ST_TO_ADDR
// break ;
46593: GO 46597
// end ; end ; end ;
46595: GO 46431
46597: POP
46598: POP
// end ;
46599: GO 46191
46601: POP
46602: POP
// end ;
46603: LD_VAR 0 1
46607: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46608: LD_INT 0
46610: PPUSH
46611: PPUSH
46612: PPUSH
46613: PPUSH
46614: PPUSH
46615: PPUSH
46616: PPUSH
46617: PPUSH
46618: PPUSH
// if not mc_bases then
46619: LD_EXP 102
46623: NOT
46624: IFFALSE 46628
// exit ;
46626: GO 47033
// for i = 1 to mc_bases do
46628: LD_ADDR_VAR 0 2
46632: PUSH
46633: DOUBLE
46634: LD_INT 1
46636: DEC
46637: ST_TO_ADDR
46638: LD_EXP 102
46642: PUSH
46643: FOR_TO
46644: IFFALSE 47031
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46646: LD_EXP 110
46650: PUSH
46651: LD_VAR 0 2
46655: ARRAY
46656: NOT
46657: PUSH
46658: LD_EXP 102
46662: PUSH
46663: LD_VAR 0 2
46667: ARRAY
46668: PPUSH
46669: LD_INT 30
46671: PUSH
46672: LD_INT 3
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PPUSH
46679: CALL_OW 72
46683: NOT
46684: OR
46685: IFFALSE 46689
// continue ;
46687: GO 46643
// busy := false ;
46689: LD_ADDR_VAR 0 8
46693: PUSH
46694: LD_INT 0
46696: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46697: LD_ADDR_VAR 0 4
46701: PUSH
46702: LD_EXP 102
46706: PUSH
46707: LD_VAR 0 2
46711: ARRAY
46712: PPUSH
46713: LD_INT 30
46715: PUSH
46716: LD_INT 3
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PPUSH
46723: CALL_OW 72
46727: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46728: LD_ADDR_VAR 0 6
46732: PUSH
46733: LD_EXP 110
46737: PUSH
46738: LD_VAR 0 2
46742: ARRAY
46743: PPUSH
46744: LD_INT 2
46746: PUSH
46747: LD_INT 30
46749: PUSH
46750: LD_INT 32
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: LD_INT 30
46759: PUSH
46760: LD_INT 33
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: LIST
46771: PPUSH
46772: CALL_OW 72
46776: ST_TO_ADDR
// if not t then
46777: LD_VAR 0 6
46781: NOT
46782: IFFALSE 46786
// continue ;
46784: GO 46643
// for j in tmp do
46786: LD_ADDR_VAR 0 3
46790: PUSH
46791: LD_VAR 0 4
46795: PUSH
46796: FOR_IN
46797: IFFALSE 46827
// if not BuildingStatus ( j ) = bs_idle then
46799: LD_VAR 0 3
46803: PPUSH
46804: CALL_OW 461
46808: PUSH
46809: LD_INT 2
46811: EQUAL
46812: NOT
46813: IFFALSE 46825
// begin busy := true ;
46815: LD_ADDR_VAR 0 8
46819: PUSH
46820: LD_INT 1
46822: ST_TO_ADDR
// break ;
46823: GO 46827
// end ;
46825: GO 46796
46827: POP
46828: POP
// if busy then
46829: LD_VAR 0 8
46833: IFFALSE 46837
// continue ;
46835: GO 46643
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46837: LD_ADDR_VAR 0 7
46841: PUSH
46842: LD_VAR 0 6
46846: PPUSH
46847: LD_INT 35
46849: PUSH
46850: LD_INT 0
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PPUSH
46857: CALL_OW 72
46861: ST_TO_ADDR
// if tw then
46862: LD_VAR 0 7
46866: IFFALSE 46943
// begin tw := tw [ 1 ] ;
46868: LD_ADDR_VAR 0 7
46872: PUSH
46873: LD_VAR 0 7
46877: PUSH
46878: LD_INT 1
46880: ARRAY
46881: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46882: LD_ADDR_VAR 0 9
46886: PUSH
46887: LD_VAR 0 7
46891: PPUSH
46892: LD_EXP 127
46896: PUSH
46897: LD_VAR 0 2
46901: ARRAY
46902: PPUSH
46903: CALL 76989 0 2
46907: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46908: LD_EXP 141
46912: PUSH
46913: LD_VAR 0 2
46917: ARRAY
46918: IFFALSE 46941
// if not weapon in mc_allowed_tower_weapons [ i ] then
46920: LD_VAR 0 9
46924: PUSH
46925: LD_EXP 141
46929: PUSH
46930: LD_VAR 0 2
46934: ARRAY
46935: IN
46936: NOT
46937: IFFALSE 46941
// continue ;
46939: GO 46643
// end else
46941: GO 47006
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46943: LD_ADDR_VAR 0 5
46947: PUSH
46948: LD_EXP 110
46952: PUSH
46953: LD_VAR 0 2
46957: ARRAY
46958: PPUSH
46959: LD_VAR 0 4
46963: PPUSH
46964: CALL 107200 0 2
46968: ST_TO_ADDR
// if not tmp2 then
46969: LD_VAR 0 5
46973: NOT
46974: IFFALSE 46978
// continue ;
46976: GO 46643
// tw := tmp2 [ 1 ] ;
46978: LD_ADDR_VAR 0 7
46982: PUSH
46983: LD_VAR 0 5
46987: PUSH
46988: LD_INT 1
46990: ARRAY
46991: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46992: LD_ADDR_VAR 0 9
46996: PUSH
46997: LD_VAR 0 5
47001: PUSH
47002: LD_INT 2
47004: ARRAY
47005: ST_TO_ADDR
// end ; if not weapon then
47006: LD_VAR 0 9
47010: NOT
47011: IFFALSE 47015
// continue ;
47013: GO 46643
// ComPlaceWeapon ( tw , weapon ) ;
47015: LD_VAR 0 7
47019: PPUSH
47020: LD_VAR 0 9
47024: PPUSH
47025: CALL_OW 148
// end ;
47029: GO 46643
47031: POP
47032: POP
// end ;
47033: LD_VAR 0 1
47037: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47038: LD_INT 0
47040: PPUSH
47041: PPUSH
47042: PPUSH
47043: PPUSH
47044: PPUSH
47045: PPUSH
// if not mc_bases then
47046: LD_EXP 102
47050: NOT
47051: IFFALSE 47055
// exit ;
47053: GO 47831
// for i = 1 to mc_bases do
47055: LD_ADDR_VAR 0 2
47059: PUSH
47060: DOUBLE
47061: LD_INT 1
47063: DEC
47064: ST_TO_ADDR
47065: LD_EXP 102
47069: PUSH
47070: FOR_TO
47071: IFFALSE 47829
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47073: LD_EXP 115
47077: PUSH
47078: LD_VAR 0 2
47082: ARRAY
47083: NOT
47084: PUSH
47085: LD_EXP 115
47089: PUSH
47090: LD_VAR 0 2
47094: ARRAY
47095: PUSH
47096: LD_EXP 116
47100: PUSH
47101: LD_VAR 0 2
47105: ARRAY
47106: EQUAL
47107: OR
47108: PUSH
47109: LD_EXP 125
47113: PUSH
47114: LD_VAR 0 2
47118: ARRAY
47119: OR
47120: IFFALSE 47124
// continue ;
47122: GO 47070
// if mc_miners [ i ] then
47124: LD_EXP 116
47128: PUSH
47129: LD_VAR 0 2
47133: ARRAY
47134: IFFALSE 47516
// begin for j = mc_miners [ i ] downto 1 do
47136: LD_ADDR_VAR 0 3
47140: PUSH
47141: DOUBLE
47142: LD_EXP 116
47146: PUSH
47147: LD_VAR 0 2
47151: ARRAY
47152: INC
47153: ST_TO_ADDR
47154: LD_INT 1
47156: PUSH
47157: FOR_DOWNTO
47158: IFFALSE 47514
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47160: LD_EXP 116
47164: PUSH
47165: LD_VAR 0 2
47169: ARRAY
47170: PUSH
47171: LD_VAR 0 3
47175: ARRAY
47176: PPUSH
47177: CALL_OW 301
47181: PUSH
47182: LD_EXP 116
47186: PUSH
47187: LD_VAR 0 2
47191: ARRAY
47192: PUSH
47193: LD_VAR 0 3
47197: ARRAY
47198: PPUSH
47199: CALL_OW 257
47203: PUSH
47204: LD_INT 1
47206: NONEQUAL
47207: OR
47208: IFFALSE 47271
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47210: LD_ADDR_VAR 0 5
47214: PUSH
47215: LD_EXP 116
47219: PUSH
47220: LD_VAR 0 2
47224: ARRAY
47225: PUSH
47226: LD_EXP 116
47230: PUSH
47231: LD_VAR 0 2
47235: ARRAY
47236: PUSH
47237: LD_VAR 0 3
47241: ARRAY
47242: DIFF
47243: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47244: LD_ADDR_EXP 116
47248: PUSH
47249: LD_EXP 116
47253: PPUSH
47254: LD_VAR 0 2
47258: PPUSH
47259: LD_VAR 0 5
47263: PPUSH
47264: CALL_OW 1
47268: ST_TO_ADDR
// continue ;
47269: GO 47157
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47271: LD_EXP 116
47275: PUSH
47276: LD_VAR 0 2
47280: ARRAY
47281: PUSH
47282: LD_VAR 0 3
47286: ARRAY
47287: PPUSH
47288: CALL_OW 257
47292: PUSH
47293: LD_INT 1
47295: EQUAL
47296: PUSH
47297: LD_EXP 116
47301: PUSH
47302: LD_VAR 0 2
47306: ARRAY
47307: PUSH
47308: LD_VAR 0 3
47312: ARRAY
47313: PPUSH
47314: CALL_OW 459
47318: NOT
47319: AND
47320: PUSH
47321: LD_EXP 116
47325: PUSH
47326: LD_VAR 0 2
47330: ARRAY
47331: PUSH
47332: LD_VAR 0 3
47336: ARRAY
47337: PPUSH
47338: CALL_OW 314
47342: NOT
47343: AND
47344: IFFALSE 47512
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47346: LD_EXP 116
47350: PUSH
47351: LD_VAR 0 2
47355: ARRAY
47356: PUSH
47357: LD_VAR 0 3
47361: ARRAY
47362: PPUSH
47363: CALL_OW 310
47367: IFFALSE 47390
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47369: LD_EXP 116
47373: PUSH
47374: LD_VAR 0 2
47378: ARRAY
47379: PUSH
47380: LD_VAR 0 3
47384: ARRAY
47385: PPUSH
47386: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47390: LD_EXP 116
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PUSH
47401: LD_VAR 0 3
47405: ARRAY
47406: PPUSH
47407: CALL_OW 314
47411: NOT
47412: IFFALSE 47512
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47414: LD_EXP 116
47418: PUSH
47419: LD_VAR 0 2
47423: ARRAY
47424: PUSH
47425: LD_VAR 0 3
47429: ARRAY
47430: PPUSH
47431: LD_EXP 115
47435: PUSH
47436: LD_VAR 0 2
47440: ARRAY
47441: PUSH
47442: LD_VAR 0 3
47446: PUSH
47447: LD_EXP 115
47451: PUSH
47452: LD_VAR 0 2
47456: ARRAY
47457: MOD
47458: PUSH
47459: LD_INT 1
47461: PLUS
47462: ARRAY
47463: PUSH
47464: LD_INT 1
47466: ARRAY
47467: PPUSH
47468: LD_EXP 115
47472: PUSH
47473: LD_VAR 0 2
47477: ARRAY
47478: PUSH
47479: LD_VAR 0 3
47483: PUSH
47484: LD_EXP 115
47488: PUSH
47489: LD_VAR 0 2
47493: ARRAY
47494: MOD
47495: PUSH
47496: LD_INT 1
47498: PLUS
47499: ARRAY
47500: PUSH
47501: LD_INT 2
47503: ARRAY
47504: PPUSH
47505: LD_INT 0
47507: PPUSH
47508: CALL_OW 193
// end ; end ;
47512: GO 47157
47514: POP
47515: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47516: LD_ADDR_VAR 0 5
47520: PUSH
47521: LD_EXP 102
47525: PUSH
47526: LD_VAR 0 2
47530: ARRAY
47531: PPUSH
47532: LD_INT 2
47534: PUSH
47535: LD_INT 30
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PUSH
47545: LD_INT 30
47547: PUSH
47548: LD_INT 5
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 30
47557: PUSH
47558: LD_INT 32
47560: PUSH
47561: EMPTY
47562: LIST
47563: LIST
47564: PUSH
47565: EMPTY
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: PPUSH
47571: CALL_OW 72
47575: ST_TO_ADDR
// if not tmp then
47576: LD_VAR 0 5
47580: NOT
47581: IFFALSE 47585
// continue ;
47583: GO 47070
// list := [ ] ;
47585: LD_ADDR_VAR 0 6
47589: PUSH
47590: EMPTY
47591: ST_TO_ADDR
// for j in tmp do
47592: LD_ADDR_VAR 0 3
47596: PUSH
47597: LD_VAR 0 5
47601: PUSH
47602: FOR_IN
47603: IFFALSE 47672
// begin for k in UnitsInside ( j ) do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: LD_VAR 0 3
47614: PPUSH
47615: CALL_OW 313
47619: PUSH
47620: FOR_IN
47621: IFFALSE 47668
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47623: LD_VAR 0 4
47627: PPUSH
47628: CALL_OW 257
47632: PUSH
47633: LD_INT 1
47635: EQUAL
47636: PUSH
47637: LD_VAR 0 4
47641: PPUSH
47642: CALL_OW 459
47646: NOT
47647: AND
47648: IFFALSE 47666
// list := list ^ k ;
47650: LD_ADDR_VAR 0 6
47654: PUSH
47655: LD_VAR 0 6
47659: PUSH
47660: LD_VAR 0 4
47664: ADD
47665: ST_TO_ADDR
47666: GO 47620
47668: POP
47669: POP
// end ;
47670: GO 47602
47672: POP
47673: POP
// list := list diff mc_miners [ i ] ;
47674: LD_ADDR_VAR 0 6
47678: PUSH
47679: LD_VAR 0 6
47683: PUSH
47684: LD_EXP 116
47688: PUSH
47689: LD_VAR 0 2
47693: ARRAY
47694: DIFF
47695: ST_TO_ADDR
// if not list then
47696: LD_VAR 0 6
47700: NOT
47701: IFFALSE 47705
// continue ;
47703: GO 47070
// k := mc_mines [ i ] - mc_miners [ i ] ;
47705: LD_ADDR_VAR 0 4
47709: PUSH
47710: LD_EXP 115
47714: PUSH
47715: LD_VAR 0 2
47719: ARRAY
47720: PUSH
47721: LD_EXP 116
47725: PUSH
47726: LD_VAR 0 2
47730: ARRAY
47731: MINUS
47732: ST_TO_ADDR
// if k > list then
47733: LD_VAR 0 4
47737: PUSH
47738: LD_VAR 0 6
47742: GREATER
47743: IFFALSE 47755
// k := list ;
47745: LD_ADDR_VAR 0 4
47749: PUSH
47750: LD_VAR 0 6
47754: ST_TO_ADDR
// for j = 1 to k do
47755: LD_ADDR_VAR 0 3
47759: PUSH
47760: DOUBLE
47761: LD_INT 1
47763: DEC
47764: ST_TO_ADDR
47765: LD_VAR 0 4
47769: PUSH
47770: FOR_TO
47771: IFFALSE 47825
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47773: LD_ADDR_EXP 116
47777: PUSH
47778: LD_EXP 116
47782: PPUSH
47783: LD_VAR 0 2
47787: PUSH
47788: LD_EXP 116
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PUSH
47799: LD_INT 1
47801: PLUS
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PPUSH
47807: LD_VAR 0 6
47811: PUSH
47812: LD_VAR 0 3
47816: ARRAY
47817: PPUSH
47818: CALL 72019 0 3
47822: ST_TO_ADDR
47823: GO 47770
47825: POP
47826: POP
// end ;
47827: GO 47070
47829: POP
47830: POP
// end ;
47831: LD_VAR 0 1
47835: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47836: LD_INT 0
47838: PPUSH
47839: PPUSH
47840: PPUSH
47841: PPUSH
47842: PPUSH
47843: PPUSH
47844: PPUSH
47845: PPUSH
47846: PPUSH
47847: PPUSH
// if not mc_bases then
47848: LD_EXP 102
47852: NOT
47853: IFFALSE 47857
// exit ;
47855: GO 49607
// for i = 1 to mc_bases do
47857: LD_ADDR_VAR 0 2
47861: PUSH
47862: DOUBLE
47863: LD_INT 1
47865: DEC
47866: ST_TO_ADDR
47867: LD_EXP 102
47871: PUSH
47872: FOR_TO
47873: IFFALSE 49605
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47875: LD_EXP 102
47879: PUSH
47880: LD_VAR 0 2
47884: ARRAY
47885: NOT
47886: PUSH
47887: LD_EXP 109
47891: PUSH
47892: LD_VAR 0 2
47896: ARRAY
47897: OR
47898: IFFALSE 47902
// continue ;
47900: GO 47872
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47902: LD_EXP 118
47906: PUSH
47907: LD_VAR 0 2
47911: ARRAY
47912: NOT
47913: PUSH
47914: LD_EXP 119
47918: PUSH
47919: LD_VAR 0 2
47923: ARRAY
47924: AND
47925: IFFALSE 47963
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47927: LD_ADDR_EXP 119
47931: PUSH
47932: LD_EXP 119
47936: PPUSH
47937: LD_VAR 0 2
47941: PPUSH
47942: EMPTY
47943: PPUSH
47944: CALL_OW 1
47948: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47949: LD_VAR 0 2
47953: PPUSH
47954: LD_INT 107
47956: PPUSH
47957: CALL 38821 0 2
// continue ;
47961: GO 47872
// end ; target := [ ] ;
47963: LD_ADDR_VAR 0 6
47967: PUSH
47968: EMPTY
47969: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47970: LD_ADDR_VAR 0 3
47974: PUSH
47975: DOUBLE
47976: LD_EXP 118
47980: PUSH
47981: LD_VAR 0 2
47985: ARRAY
47986: INC
47987: ST_TO_ADDR
47988: LD_INT 1
47990: PUSH
47991: FOR_DOWNTO
47992: IFFALSE 48252
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47994: LD_EXP 118
47998: PUSH
47999: LD_VAR 0 2
48003: ARRAY
48004: PUSH
48005: LD_VAR 0 3
48009: ARRAY
48010: PUSH
48011: LD_INT 2
48013: ARRAY
48014: PPUSH
48015: LD_EXP 118
48019: PUSH
48020: LD_VAR 0 2
48024: ARRAY
48025: PUSH
48026: LD_VAR 0 3
48030: ARRAY
48031: PUSH
48032: LD_INT 3
48034: ARRAY
48035: PPUSH
48036: CALL_OW 488
48040: PUSH
48041: LD_EXP 118
48045: PUSH
48046: LD_VAR 0 2
48050: ARRAY
48051: PUSH
48052: LD_VAR 0 3
48056: ARRAY
48057: PUSH
48058: LD_INT 2
48060: ARRAY
48061: PPUSH
48062: LD_EXP 118
48066: PUSH
48067: LD_VAR 0 2
48071: ARRAY
48072: PUSH
48073: LD_VAR 0 3
48077: ARRAY
48078: PUSH
48079: LD_INT 3
48081: ARRAY
48082: PPUSH
48083: CALL_OW 284
48087: PUSH
48088: LD_INT 0
48090: EQUAL
48091: AND
48092: IFFALSE 48147
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48094: LD_ADDR_VAR 0 5
48098: PUSH
48099: LD_EXP 118
48103: PUSH
48104: LD_VAR 0 2
48108: ARRAY
48109: PPUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: CALL_OW 3
48119: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48120: LD_ADDR_EXP 118
48124: PUSH
48125: LD_EXP 118
48129: PPUSH
48130: LD_VAR 0 2
48134: PPUSH
48135: LD_VAR 0 5
48139: PPUSH
48140: CALL_OW 1
48144: ST_TO_ADDR
// continue ;
48145: GO 47991
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48147: LD_EXP 102
48151: PUSH
48152: LD_VAR 0 2
48156: ARRAY
48157: PUSH
48158: LD_INT 1
48160: ARRAY
48161: PPUSH
48162: CALL_OW 255
48166: PPUSH
48167: LD_EXP 118
48171: PUSH
48172: LD_VAR 0 2
48176: ARRAY
48177: PUSH
48178: LD_VAR 0 3
48182: ARRAY
48183: PUSH
48184: LD_INT 2
48186: ARRAY
48187: PPUSH
48188: LD_EXP 118
48192: PUSH
48193: LD_VAR 0 2
48197: ARRAY
48198: PUSH
48199: LD_VAR 0 3
48203: ARRAY
48204: PUSH
48205: LD_INT 3
48207: ARRAY
48208: PPUSH
48209: LD_INT 30
48211: PPUSH
48212: CALL 72915 0 4
48216: PUSH
48217: LD_INT 4
48219: ARRAY
48220: PUSH
48221: LD_INT 0
48223: EQUAL
48224: IFFALSE 48250
// begin target := mc_crates [ i ] [ j ] ;
48226: LD_ADDR_VAR 0 6
48230: PUSH
48231: LD_EXP 118
48235: PUSH
48236: LD_VAR 0 2
48240: ARRAY
48241: PUSH
48242: LD_VAR 0 3
48246: ARRAY
48247: ST_TO_ADDR
// break ;
48248: GO 48252
// end ; end ;
48250: GO 47991
48252: POP
48253: POP
// if not target then
48254: LD_VAR 0 6
48258: NOT
48259: IFFALSE 48263
// continue ;
48261: GO 47872
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48263: LD_ADDR_VAR 0 7
48267: PUSH
48268: LD_EXP 121
48272: PUSH
48273: LD_VAR 0 2
48277: ARRAY
48278: PPUSH
48279: LD_INT 2
48281: PUSH
48282: LD_INT 3
48284: PUSH
48285: LD_INT 58
48287: PUSH
48288: EMPTY
48289: LIST
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: PUSH
48295: LD_INT 61
48297: PUSH
48298: EMPTY
48299: LIST
48300: PUSH
48301: LD_INT 33
48303: PUSH
48304: LD_INT 5
48306: PUSH
48307: EMPTY
48308: LIST
48309: LIST
48310: PUSH
48311: LD_INT 33
48313: PUSH
48314: LD_INT 3
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: LIST
48325: LIST
48326: LIST
48327: PUSH
48328: LD_INT 2
48330: PUSH
48331: LD_INT 34
48333: PUSH
48334: LD_INT 32
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 34
48343: PUSH
48344: LD_INT 51
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: LD_INT 34
48353: PUSH
48354: LD_INT 12
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: EMPTY
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PPUSH
48371: CALL_OW 72
48375: ST_TO_ADDR
// if not cargo then
48376: LD_VAR 0 7
48380: NOT
48381: IFFALSE 49024
// begin if mc_crates_collector [ i ] < 5 then
48383: LD_EXP 119
48387: PUSH
48388: LD_VAR 0 2
48392: ARRAY
48393: PUSH
48394: LD_INT 5
48396: LESS
48397: IFFALSE 48763
// begin if mc_ape [ i ] then
48399: LD_EXP 131
48403: PUSH
48404: LD_VAR 0 2
48408: ARRAY
48409: IFFALSE 48456
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48411: LD_ADDR_VAR 0 5
48415: PUSH
48416: LD_EXP 131
48420: PUSH
48421: LD_VAR 0 2
48425: ARRAY
48426: PPUSH
48427: LD_INT 25
48429: PUSH
48430: LD_INT 16
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: PUSH
48437: LD_INT 24
48439: PUSH
48440: LD_INT 750
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: PPUSH
48451: CALL_OW 72
48455: ST_TO_ADDR
// if not tmp then
48456: LD_VAR 0 5
48460: NOT
48461: IFFALSE 48508
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48463: LD_ADDR_VAR 0 5
48467: PUSH
48468: LD_EXP 102
48472: PUSH
48473: LD_VAR 0 2
48477: ARRAY
48478: PPUSH
48479: LD_INT 25
48481: PUSH
48482: LD_INT 2
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 24
48491: PUSH
48492: LD_INT 750
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: PUSH
48499: EMPTY
48500: LIST
48501: LIST
48502: PPUSH
48503: CALL_OW 72
48507: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48508: LD_EXP 131
48512: PUSH
48513: LD_VAR 0 2
48517: ARRAY
48518: PUSH
48519: LD_EXP 102
48523: PUSH
48524: LD_VAR 0 2
48528: ARRAY
48529: PPUSH
48530: LD_INT 25
48532: PUSH
48533: LD_INT 2
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 24
48542: PUSH
48543: LD_INT 750
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: PPUSH
48554: CALL_OW 72
48558: AND
48559: PUSH
48560: LD_VAR 0 5
48564: PUSH
48565: LD_INT 5
48567: LESS
48568: AND
48569: IFFALSE 48651
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48571: LD_ADDR_VAR 0 3
48575: PUSH
48576: LD_EXP 102
48580: PUSH
48581: LD_VAR 0 2
48585: ARRAY
48586: PPUSH
48587: LD_INT 25
48589: PUSH
48590: LD_INT 2
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 24
48599: PUSH
48600: LD_INT 750
48602: PUSH
48603: EMPTY
48604: LIST
48605: LIST
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PPUSH
48611: CALL_OW 72
48615: PUSH
48616: FOR_IN
48617: IFFALSE 48649
// begin tmp := tmp union j ;
48619: LD_ADDR_VAR 0 5
48623: PUSH
48624: LD_VAR 0 5
48628: PUSH
48629: LD_VAR 0 3
48633: UNION
48634: ST_TO_ADDR
// if tmp >= 5 then
48635: LD_VAR 0 5
48639: PUSH
48640: LD_INT 5
48642: GREATEREQUAL
48643: IFFALSE 48647
// break ;
48645: GO 48649
// end ;
48647: GO 48616
48649: POP
48650: POP
// end ; if not tmp then
48651: LD_VAR 0 5
48655: NOT
48656: IFFALSE 48660
// continue ;
48658: GO 47872
// for j in tmp do
48660: LD_ADDR_VAR 0 3
48664: PUSH
48665: LD_VAR 0 5
48669: PUSH
48670: FOR_IN
48671: IFFALSE 48761
// if not GetTag ( j ) then
48673: LD_VAR 0 3
48677: PPUSH
48678: CALL_OW 110
48682: NOT
48683: IFFALSE 48759
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48685: LD_ADDR_EXP 119
48689: PUSH
48690: LD_EXP 119
48694: PPUSH
48695: LD_VAR 0 2
48699: PUSH
48700: LD_EXP 119
48704: PUSH
48705: LD_VAR 0 2
48709: ARRAY
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PPUSH
48719: LD_VAR 0 3
48723: PPUSH
48724: CALL 72019 0 3
48728: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48729: LD_VAR 0 3
48733: PPUSH
48734: LD_INT 107
48736: PPUSH
48737: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48741: LD_EXP 119
48745: PUSH
48746: LD_VAR 0 2
48750: ARRAY
48751: PUSH
48752: LD_INT 5
48754: GREATEREQUAL
48755: IFFALSE 48759
// break ;
48757: GO 48761
// end ;
48759: GO 48670
48761: POP
48762: POP
// end ; if mc_crates_collector [ i ] and target then
48763: LD_EXP 119
48767: PUSH
48768: LD_VAR 0 2
48772: ARRAY
48773: PUSH
48774: LD_VAR 0 6
48778: AND
48779: IFFALSE 49022
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48781: LD_EXP 119
48785: PUSH
48786: LD_VAR 0 2
48790: ARRAY
48791: PUSH
48792: LD_VAR 0 6
48796: PUSH
48797: LD_INT 1
48799: ARRAY
48800: LESS
48801: IFFALSE 48821
// tmp := mc_crates_collector [ i ] else
48803: LD_ADDR_VAR 0 5
48807: PUSH
48808: LD_EXP 119
48812: PUSH
48813: LD_VAR 0 2
48817: ARRAY
48818: ST_TO_ADDR
48819: GO 48835
// tmp := target [ 1 ] ;
48821: LD_ADDR_VAR 0 5
48825: PUSH
48826: LD_VAR 0 6
48830: PUSH
48831: LD_INT 1
48833: ARRAY
48834: ST_TO_ADDR
// k := 0 ;
48835: LD_ADDR_VAR 0 4
48839: PUSH
48840: LD_INT 0
48842: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48843: LD_ADDR_VAR 0 3
48847: PUSH
48848: LD_EXP 119
48852: PUSH
48853: LD_VAR 0 2
48857: ARRAY
48858: PUSH
48859: FOR_IN
48860: IFFALSE 49020
// begin k := k + 1 ;
48862: LD_ADDR_VAR 0 4
48866: PUSH
48867: LD_VAR 0 4
48871: PUSH
48872: LD_INT 1
48874: PLUS
48875: ST_TO_ADDR
// if k > tmp then
48876: LD_VAR 0 4
48880: PUSH
48881: LD_VAR 0 5
48885: GREATER
48886: IFFALSE 48890
// break ;
48888: GO 49020
// if not GetClass ( j ) in [ 2 , 16 ] then
48890: LD_VAR 0 3
48894: PPUSH
48895: CALL_OW 257
48899: PUSH
48900: LD_INT 2
48902: PUSH
48903: LD_INT 16
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: IN
48910: NOT
48911: IFFALSE 48964
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48913: LD_ADDR_EXP 119
48917: PUSH
48918: LD_EXP 119
48922: PPUSH
48923: LD_VAR 0 2
48927: PPUSH
48928: LD_EXP 119
48932: PUSH
48933: LD_VAR 0 2
48937: ARRAY
48938: PUSH
48939: LD_VAR 0 3
48943: DIFF
48944: PPUSH
48945: CALL_OW 1
48949: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48950: LD_VAR 0 3
48954: PPUSH
48955: LD_INT 0
48957: PPUSH
48958: CALL_OW 109
// continue ;
48962: GO 48859
// end ; if IsInUnit ( j ) then
48964: LD_VAR 0 3
48968: PPUSH
48969: CALL_OW 310
48973: IFFALSE 48984
// ComExitBuilding ( j ) ;
48975: LD_VAR 0 3
48979: PPUSH
48980: CALL_OW 122
// wait ( 3 ) ;
48984: LD_INT 3
48986: PPUSH
48987: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48991: LD_VAR 0 3
48995: PPUSH
48996: LD_VAR 0 6
49000: PUSH
49001: LD_INT 2
49003: ARRAY
49004: PPUSH
49005: LD_VAR 0 6
49009: PUSH
49010: LD_INT 3
49012: ARRAY
49013: PPUSH
49014: CALL_OW 117
// end ;
49018: GO 48859
49020: POP
49021: POP
// end ; end else
49022: GO 49603
// begin for j in cargo do
49024: LD_ADDR_VAR 0 3
49028: PUSH
49029: LD_VAR 0 7
49033: PUSH
49034: FOR_IN
49035: IFFALSE 49601
// begin if GetTag ( j ) <> 0 then
49037: LD_VAR 0 3
49041: PPUSH
49042: CALL_OW 110
49046: PUSH
49047: LD_INT 0
49049: NONEQUAL
49050: IFFALSE 49054
// continue ;
49052: GO 49034
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49054: LD_VAR 0 3
49058: PPUSH
49059: CALL_OW 256
49063: PUSH
49064: LD_INT 1000
49066: LESS
49067: PUSH
49068: LD_VAR 0 3
49072: PPUSH
49073: LD_EXP 126
49077: PUSH
49078: LD_VAR 0 2
49082: ARRAY
49083: PPUSH
49084: CALL_OW 308
49088: NOT
49089: AND
49090: IFFALSE 49112
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49092: LD_VAR 0 3
49096: PPUSH
49097: LD_EXP 126
49101: PUSH
49102: LD_VAR 0 2
49106: ARRAY
49107: PPUSH
49108: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49112: LD_VAR 0 3
49116: PPUSH
49117: CALL_OW 256
49121: PUSH
49122: LD_INT 1000
49124: LESS
49125: PUSH
49126: LD_VAR 0 3
49130: PPUSH
49131: LD_EXP 126
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: PPUSH
49142: CALL_OW 308
49146: AND
49147: IFFALSE 49151
// continue ;
49149: GO 49034
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49151: LD_VAR 0 3
49155: PPUSH
49156: CALL_OW 262
49160: PUSH
49161: LD_INT 2
49163: EQUAL
49164: PUSH
49165: LD_VAR 0 3
49169: PPUSH
49170: CALL_OW 261
49174: PUSH
49175: LD_INT 15
49177: LESS
49178: AND
49179: IFFALSE 49183
// continue ;
49181: GO 49034
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49183: LD_VAR 0 3
49187: PPUSH
49188: CALL_OW 262
49192: PUSH
49193: LD_INT 1
49195: EQUAL
49196: PUSH
49197: LD_VAR 0 3
49201: PPUSH
49202: CALL_OW 261
49206: PUSH
49207: LD_INT 10
49209: LESS
49210: AND
49211: IFFALSE 49540
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49213: LD_ADDR_VAR 0 8
49217: PUSH
49218: LD_EXP 102
49222: PUSH
49223: LD_VAR 0 2
49227: ARRAY
49228: PPUSH
49229: LD_INT 2
49231: PUSH
49232: LD_INT 30
49234: PUSH
49235: LD_INT 0
49237: PUSH
49238: EMPTY
49239: LIST
49240: LIST
49241: PUSH
49242: LD_INT 30
49244: PUSH
49245: LD_INT 1
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: LIST
49256: PPUSH
49257: CALL_OW 72
49261: ST_TO_ADDR
// if not depot then
49262: LD_VAR 0 8
49266: NOT
49267: IFFALSE 49271
// continue ;
49269: GO 49034
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49271: LD_VAR 0 3
49275: PPUSH
49276: LD_VAR 0 8
49280: PPUSH
49281: LD_VAR 0 3
49285: PPUSH
49286: CALL_OW 74
49290: PPUSH
49291: CALL_OW 296
49295: PUSH
49296: LD_INT 6
49298: LESS
49299: IFFALSE 49315
// SetFuel ( j , 100 ) else
49301: LD_VAR 0 3
49305: PPUSH
49306: LD_INT 100
49308: PPUSH
49309: CALL_OW 240
49313: GO 49540
// if GetFuel ( j ) = 0 then
49315: LD_VAR 0 3
49319: PPUSH
49320: CALL_OW 261
49324: PUSH
49325: LD_INT 0
49327: EQUAL
49328: IFFALSE 49540
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49330: LD_ADDR_EXP 121
49334: PUSH
49335: LD_EXP 121
49339: PPUSH
49340: LD_VAR 0 2
49344: PPUSH
49345: LD_EXP 121
49349: PUSH
49350: LD_VAR 0 2
49354: ARRAY
49355: PUSH
49356: LD_VAR 0 3
49360: DIFF
49361: PPUSH
49362: CALL_OW 1
49366: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 263
49376: PUSH
49377: LD_INT 1
49379: EQUAL
49380: IFFALSE 49396
// ComExitVehicle ( IsInUnit ( j ) ) ;
49382: LD_VAR 0 3
49386: PPUSH
49387: CALL_OW 310
49391: PPUSH
49392: CALL_OW 121
// if GetControl ( j ) = control_remote then
49396: LD_VAR 0 3
49400: PPUSH
49401: CALL_OW 263
49405: PUSH
49406: LD_INT 2
49408: EQUAL
49409: IFFALSE 49420
// ComUnlink ( j ) ;
49411: LD_VAR 0 3
49415: PPUSH
49416: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49420: LD_ADDR_VAR 0 9
49424: PUSH
49425: LD_VAR 0 2
49429: PPUSH
49430: LD_INT 3
49432: PPUSH
49433: CALL 58893 0 2
49437: ST_TO_ADDR
// if fac then
49438: LD_VAR 0 9
49442: IFFALSE 49538
// begin for k in fac do
49444: LD_ADDR_VAR 0 4
49448: PUSH
49449: LD_VAR 0 9
49453: PUSH
49454: FOR_IN
49455: IFFALSE 49536
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49457: LD_ADDR_VAR 0 10
49461: PUSH
49462: LD_VAR 0 9
49466: PPUSH
49467: LD_VAR 0 3
49471: PPUSH
49472: CALL_OW 265
49476: PPUSH
49477: LD_VAR 0 3
49481: PPUSH
49482: CALL_OW 262
49486: PPUSH
49487: LD_VAR 0 3
49491: PPUSH
49492: CALL_OW 263
49496: PPUSH
49497: LD_VAR 0 3
49501: PPUSH
49502: CALL_OW 264
49506: PPUSH
49507: CALL 69551 0 5
49511: ST_TO_ADDR
// if components then
49512: LD_VAR 0 10
49516: IFFALSE 49534
// begin MC_InsertProduceList ( i , components ) ;
49518: LD_VAR 0 2
49522: PPUSH
49523: LD_VAR 0 10
49527: PPUSH
49528: CALL 58438 0 2
// break ;
49532: GO 49536
// end ; end ;
49534: GO 49454
49536: POP
49537: POP
// end ; continue ;
49538: GO 49034
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49540: LD_VAR 0 3
49544: PPUSH
49545: LD_INT 1
49547: PPUSH
49548: CALL_OW 289
49552: PUSH
49553: LD_INT 100
49555: LESS
49556: PUSH
49557: LD_VAR 0 3
49561: PPUSH
49562: CALL_OW 314
49566: NOT
49567: AND
49568: IFFALSE 49597
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49570: LD_VAR 0 3
49574: PPUSH
49575: LD_VAR 0 6
49579: PUSH
49580: LD_INT 2
49582: ARRAY
49583: PPUSH
49584: LD_VAR 0 6
49588: PUSH
49589: LD_INT 3
49591: ARRAY
49592: PPUSH
49593: CALL_OW 117
// break ;
49597: GO 49601
// end ;
49599: GO 49034
49601: POP
49602: POP
// end ; end ;
49603: GO 47872
49605: POP
49606: POP
// end ;
49607: LD_VAR 0 1
49611: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49612: LD_INT 0
49614: PPUSH
49615: PPUSH
49616: PPUSH
49617: PPUSH
// if not mc_bases then
49618: LD_EXP 102
49622: NOT
49623: IFFALSE 49627
// exit ;
49625: GO 49788
// for i = 1 to mc_bases do
49627: LD_ADDR_VAR 0 2
49631: PUSH
49632: DOUBLE
49633: LD_INT 1
49635: DEC
49636: ST_TO_ADDR
49637: LD_EXP 102
49641: PUSH
49642: FOR_TO
49643: IFFALSE 49786
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49645: LD_ADDR_VAR 0 4
49649: PUSH
49650: LD_EXP 121
49654: PUSH
49655: LD_VAR 0 2
49659: ARRAY
49660: PUSH
49661: LD_EXP 124
49665: PUSH
49666: LD_VAR 0 2
49670: ARRAY
49671: UNION
49672: PPUSH
49673: LD_INT 33
49675: PUSH
49676: LD_INT 2
49678: PUSH
49679: EMPTY
49680: LIST
49681: LIST
49682: PPUSH
49683: CALL_OW 72
49687: ST_TO_ADDR
// if tmp then
49688: LD_VAR 0 4
49692: IFFALSE 49784
// for j in tmp do
49694: LD_ADDR_VAR 0 3
49698: PUSH
49699: LD_VAR 0 4
49703: PUSH
49704: FOR_IN
49705: IFFALSE 49782
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49707: LD_VAR 0 3
49711: PPUSH
49712: CALL_OW 312
49716: NOT
49717: PUSH
49718: LD_VAR 0 3
49722: PPUSH
49723: CALL_OW 256
49727: PUSH
49728: LD_INT 250
49730: GREATEREQUAL
49731: AND
49732: IFFALSE 49745
// Connect ( j ) else
49734: LD_VAR 0 3
49738: PPUSH
49739: CALL 74952 0 1
49743: GO 49780
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49745: LD_VAR 0 3
49749: PPUSH
49750: CALL_OW 256
49754: PUSH
49755: LD_INT 250
49757: LESS
49758: PUSH
49759: LD_VAR 0 3
49763: PPUSH
49764: CALL_OW 312
49768: AND
49769: IFFALSE 49780
// ComUnlink ( j ) ;
49771: LD_VAR 0 3
49775: PPUSH
49776: CALL_OW 136
49780: GO 49704
49782: POP
49783: POP
// end ;
49784: GO 49642
49786: POP
49787: POP
// end ;
49788: LD_VAR 0 1
49792: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49793: LD_INT 0
49795: PPUSH
49796: PPUSH
49797: PPUSH
49798: PPUSH
49799: PPUSH
// if not mc_bases then
49800: LD_EXP 102
49804: NOT
49805: IFFALSE 49809
// exit ;
49807: GO 50254
// for i = 1 to mc_bases do
49809: LD_ADDR_VAR 0 2
49813: PUSH
49814: DOUBLE
49815: LD_INT 1
49817: DEC
49818: ST_TO_ADDR
49819: LD_EXP 102
49823: PUSH
49824: FOR_TO
49825: IFFALSE 50252
// begin if not mc_produce [ i ] then
49827: LD_EXP 123
49831: PUSH
49832: LD_VAR 0 2
49836: ARRAY
49837: NOT
49838: IFFALSE 49842
// continue ;
49840: GO 49824
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49842: LD_ADDR_VAR 0 5
49846: PUSH
49847: LD_EXP 102
49851: PUSH
49852: LD_VAR 0 2
49856: ARRAY
49857: PPUSH
49858: LD_INT 30
49860: PUSH
49861: LD_INT 3
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PPUSH
49868: CALL_OW 72
49872: ST_TO_ADDR
// if not fac then
49873: LD_VAR 0 5
49877: NOT
49878: IFFALSE 49882
// continue ;
49880: GO 49824
// for j in fac do
49882: LD_ADDR_VAR 0 3
49886: PUSH
49887: LD_VAR 0 5
49891: PUSH
49892: FOR_IN
49893: IFFALSE 50248
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49895: LD_VAR 0 3
49899: PPUSH
49900: CALL_OW 461
49904: PUSH
49905: LD_INT 2
49907: NONEQUAL
49908: PUSH
49909: LD_VAR 0 3
49913: PPUSH
49914: LD_INT 15
49916: PPUSH
49917: CALL 74612 0 2
49921: PUSH
49922: LD_INT 4
49924: ARRAY
49925: OR
49926: IFFALSE 49930
// continue ;
49928: GO 49892
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49930: LD_VAR 0 3
49934: PPUSH
49935: LD_EXP 123
49939: PUSH
49940: LD_VAR 0 2
49944: ARRAY
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PUSH
49950: LD_INT 1
49952: ARRAY
49953: PPUSH
49954: LD_EXP 123
49958: PUSH
49959: LD_VAR 0 2
49963: ARRAY
49964: PUSH
49965: LD_INT 1
49967: ARRAY
49968: PUSH
49969: LD_INT 2
49971: ARRAY
49972: PPUSH
49973: LD_EXP 123
49977: PUSH
49978: LD_VAR 0 2
49982: ARRAY
49983: PUSH
49984: LD_INT 1
49986: ARRAY
49987: PUSH
49988: LD_INT 3
49990: ARRAY
49991: PPUSH
49992: LD_EXP 123
49996: PUSH
49997: LD_VAR 0 2
50001: ARRAY
50002: PUSH
50003: LD_INT 1
50005: ARRAY
50006: PUSH
50007: LD_INT 4
50009: ARRAY
50010: PPUSH
50011: CALL_OW 448
50015: PUSH
50016: LD_VAR 0 3
50020: PPUSH
50021: LD_EXP 123
50025: PUSH
50026: LD_VAR 0 2
50030: ARRAY
50031: PUSH
50032: LD_INT 1
50034: ARRAY
50035: PUSH
50036: LD_INT 1
50038: ARRAY
50039: PUSH
50040: LD_EXP 123
50044: PUSH
50045: LD_VAR 0 2
50049: ARRAY
50050: PUSH
50051: LD_INT 1
50053: ARRAY
50054: PUSH
50055: LD_INT 2
50057: ARRAY
50058: PUSH
50059: LD_EXP 123
50063: PUSH
50064: LD_VAR 0 2
50068: ARRAY
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PUSH
50074: LD_INT 3
50076: ARRAY
50077: PUSH
50078: LD_EXP 123
50082: PUSH
50083: LD_VAR 0 2
50087: ARRAY
50088: PUSH
50089: LD_INT 1
50091: ARRAY
50092: PUSH
50093: LD_INT 4
50095: ARRAY
50096: PUSH
50097: EMPTY
50098: LIST
50099: LIST
50100: LIST
50101: LIST
50102: PPUSH
50103: CALL 78283 0 2
50107: AND
50108: IFFALSE 50246
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50110: LD_VAR 0 3
50114: PPUSH
50115: LD_EXP 123
50119: PUSH
50120: LD_VAR 0 2
50124: ARRAY
50125: PUSH
50126: LD_INT 1
50128: ARRAY
50129: PUSH
50130: LD_INT 1
50132: ARRAY
50133: PPUSH
50134: LD_EXP 123
50138: PUSH
50139: LD_VAR 0 2
50143: ARRAY
50144: PUSH
50145: LD_INT 1
50147: ARRAY
50148: PUSH
50149: LD_INT 2
50151: ARRAY
50152: PPUSH
50153: LD_EXP 123
50157: PUSH
50158: LD_VAR 0 2
50162: ARRAY
50163: PUSH
50164: LD_INT 1
50166: ARRAY
50167: PUSH
50168: LD_INT 3
50170: ARRAY
50171: PPUSH
50172: LD_EXP 123
50176: PUSH
50177: LD_VAR 0 2
50181: ARRAY
50182: PUSH
50183: LD_INT 1
50185: ARRAY
50186: PUSH
50187: LD_INT 4
50189: ARRAY
50190: PPUSH
50191: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50195: LD_ADDR_VAR 0 4
50199: PUSH
50200: LD_EXP 123
50204: PUSH
50205: LD_VAR 0 2
50209: ARRAY
50210: PPUSH
50211: LD_INT 1
50213: PPUSH
50214: CALL_OW 3
50218: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50219: LD_ADDR_EXP 123
50223: PUSH
50224: LD_EXP 123
50228: PPUSH
50229: LD_VAR 0 2
50233: PPUSH
50234: LD_VAR 0 4
50238: PPUSH
50239: CALL_OW 1
50243: ST_TO_ADDR
// break ;
50244: GO 50248
// end ; end ;
50246: GO 49892
50248: POP
50249: POP
// end ;
50250: GO 49824
50252: POP
50253: POP
// end ;
50254: LD_VAR 0 1
50258: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50259: LD_INT 0
50261: PPUSH
50262: PPUSH
50263: PPUSH
// if not mc_bases then
50264: LD_EXP 102
50268: NOT
50269: IFFALSE 50273
// exit ;
50271: GO 50362
// for i = 1 to mc_bases do
50273: LD_ADDR_VAR 0 2
50277: PUSH
50278: DOUBLE
50279: LD_INT 1
50281: DEC
50282: ST_TO_ADDR
50283: LD_EXP 102
50287: PUSH
50288: FOR_TO
50289: IFFALSE 50360
// begin if mc_attack [ i ] then
50291: LD_EXP 122
50295: PUSH
50296: LD_VAR 0 2
50300: ARRAY
50301: IFFALSE 50358
// begin tmp := mc_attack [ i ] [ 1 ] ;
50303: LD_ADDR_VAR 0 3
50307: PUSH
50308: LD_EXP 122
50312: PUSH
50313: LD_VAR 0 2
50317: ARRAY
50318: PUSH
50319: LD_INT 1
50321: ARRAY
50322: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50323: LD_ADDR_EXP 122
50327: PUSH
50328: LD_EXP 122
50332: PPUSH
50333: LD_VAR 0 2
50337: PPUSH
50338: EMPTY
50339: PPUSH
50340: CALL_OW 1
50344: ST_TO_ADDR
// Attack ( tmp ) ;
50345: LD_VAR 0 3
50349: PPUSH
50350: CALL 100473 0 1
// exit ;
50354: POP
50355: POP
50356: GO 50362
// end ; end ;
50358: GO 50288
50360: POP
50361: POP
// end ;
50362: LD_VAR 0 1
50366: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50367: LD_INT 0
50369: PPUSH
50370: PPUSH
50371: PPUSH
50372: PPUSH
50373: PPUSH
50374: PPUSH
50375: PPUSH
// if not mc_bases then
50376: LD_EXP 102
50380: NOT
50381: IFFALSE 50385
// exit ;
50383: GO 50967
// for i = 1 to mc_bases do
50385: LD_ADDR_VAR 0 2
50389: PUSH
50390: DOUBLE
50391: LD_INT 1
50393: DEC
50394: ST_TO_ADDR
50395: LD_EXP 102
50399: PUSH
50400: FOR_TO
50401: IFFALSE 50965
// begin if not mc_bases [ i ] then
50403: LD_EXP 102
50407: PUSH
50408: LD_VAR 0 2
50412: ARRAY
50413: NOT
50414: IFFALSE 50418
// continue ;
50416: GO 50400
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50418: LD_ADDR_VAR 0 7
50422: PUSH
50423: LD_EXP 102
50427: PUSH
50428: LD_VAR 0 2
50432: ARRAY
50433: PUSH
50434: LD_INT 1
50436: ARRAY
50437: PPUSH
50438: CALL 68855 0 1
50442: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50443: LD_ADDR_EXP 125
50447: PUSH
50448: LD_EXP 125
50452: PPUSH
50453: LD_VAR 0 2
50457: PPUSH
50458: LD_EXP 102
50462: PUSH
50463: LD_VAR 0 2
50467: ARRAY
50468: PUSH
50469: LD_INT 1
50471: ARRAY
50472: PPUSH
50473: CALL_OW 255
50477: PPUSH
50478: LD_EXP 127
50482: PUSH
50483: LD_VAR 0 2
50487: ARRAY
50488: PPUSH
50489: CALL 66409 0 2
50493: PPUSH
50494: CALL_OW 1
50498: ST_TO_ADDR
// if not mc_scan [ i ] then
50499: LD_EXP 125
50503: PUSH
50504: LD_VAR 0 2
50508: ARRAY
50509: NOT
50510: IFFALSE 50665
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50512: LD_ADDR_VAR 0 4
50516: PUSH
50517: LD_EXP 102
50521: PUSH
50522: LD_VAR 0 2
50526: ARRAY
50527: PPUSH
50528: LD_INT 2
50530: PUSH
50531: LD_INT 25
50533: PUSH
50534: LD_INT 5
50536: PUSH
50537: EMPTY
50538: LIST
50539: LIST
50540: PUSH
50541: LD_INT 25
50543: PUSH
50544: LD_INT 8
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PUSH
50551: LD_INT 25
50553: PUSH
50554: LD_INT 9
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: LIST
50565: LIST
50566: PPUSH
50567: CALL_OW 72
50571: ST_TO_ADDR
// if not tmp then
50572: LD_VAR 0 4
50576: NOT
50577: IFFALSE 50581
// continue ;
50579: GO 50400
// for j in tmp do
50581: LD_ADDR_VAR 0 3
50585: PUSH
50586: LD_VAR 0 4
50590: PUSH
50591: FOR_IN
50592: IFFALSE 50663
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50594: LD_VAR 0 3
50598: PPUSH
50599: CALL_OW 310
50603: PPUSH
50604: CALL_OW 266
50608: PUSH
50609: LD_INT 5
50611: EQUAL
50612: PUSH
50613: LD_VAR 0 3
50617: PPUSH
50618: CALL_OW 257
50622: PUSH
50623: LD_INT 1
50625: EQUAL
50626: AND
50627: PUSH
50628: LD_VAR 0 3
50632: PPUSH
50633: CALL_OW 459
50637: NOT
50638: AND
50639: PUSH
50640: LD_VAR 0 7
50644: AND
50645: IFFALSE 50661
// ComChangeProfession ( j , class ) ;
50647: LD_VAR 0 3
50651: PPUSH
50652: LD_VAR 0 7
50656: PPUSH
50657: CALL_OW 123
50661: GO 50591
50663: POP
50664: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50665: LD_EXP 125
50669: PUSH
50670: LD_VAR 0 2
50674: ARRAY
50675: PUSH
50676: LD_EXP 124
50680: PUSH
50681: LD_VAR 0 2
50685: ARRAY
50686: NOT
50687: AND
50688: PUSH
50689: LD_EXP 102
50693: PUSH
50694: LD_VAR 0 2
50698: ARRAY
50699: PPUSH
50700: LD_INT 30
50702: PUSH
50703: LD_INT 32
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: PPUSH
50710: CALL_OW 72
50714: NOT
50715: AND
50716: PUSH
50717: LD_EXP 102
50721: PUSH
50722: LD_VAR 0 2
50726: ARRAY
50727: PPUSH
50728: LD_INT 2
50730: PUSH
50731: LD_INT 30
50733: PUSH
50734: LD_INT 4
50736: PUSH
50737: EMPTY
50738: LIST
50739: LIST
50740: PUSH
50741: LD_INT 30
50743: PUSH
50744: LD_INT 5
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: EMPTY
50752: LIST
50753: LIST
50754: LIST
50755: PPUSH
50756: CALL_OW 72
50760: NOT
50761: AND
50762: IFFALSE 50894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50764: LD_ADDR_VAR 0 4
50768: PUSH
50769: LD_EXP 102
50773: PUSH
50774: LD_VAR 0 2
50778: ARRAY
50779: PPUSH
50780: LD_INT 2
50782: PUSH
50783: LD_INT 25
50785: PUSH
50786: LD_INT 1
50788: PUSH
50789: EMPTY
50790: LIST
50791: LIST
50792: PUSH
50793: LD_INT 25
50795: PUSH
50796: LD_INT 5
50798: PUSH
50799: EMPTY
50800: LIST
50801: LIST
50802: PUSH
50803: LD_INT 25
50805: PUSH
50806: LD_INT 8
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 25
50815: PUSH
50816: LD_INT 9
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: PPUSH
50830: CALL_OW 72
50834: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50835: LD_ADDR_VAR 0 4
50839: PUSH
50840: LD_VAR 0 4
50844: PUSH
50845: LD_VAR 0 4
50849: PPUSH
50850: LD_INT 18
50852: PPUSH
50853: CALL 105289 0 2
50857: DIFF
50858: ST_TO_ADDR
// if tmp then
50859: LD_VAR 0 4
50863: IFFALSE 50894
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50865: LD_VAR 0 2
50869: PPUSH
50870: LD_VAR 0 4
50874: PPUSH
50875: LD_EXP 127
50879: PUSH
50880: LD_VAR 0 2
50884: ARRAY
50885: PPUSH
50886: CALL 66444 0 3
// exit ;
50890: POP
50891: POP
50892: GO 50967
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50894: LD_EXP 125
50898: PUSH
50899: LD_VAR 0 2
50903: ARRAY
50904: PUSH
50905: LD_EXP 124
50909: PUSH
50910: LD_VAR 0 2
50914: ARRAY
50915: AND
50916: IFFALSE 50963
// begin tmp := mc_defender [ i ] ;
50918: LD_ADDR_VAR 0 4
50922: PUSH
50923: LD_EXP 124
50927: PUSH
50928: LD_VAR 0 2
50932: ARRAY
50933: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50934: LD_VAR 0 2
50938: PPUSH
50939: LD_VAR 0 4
50943: PPUSH
50944: LD_EXP 125
50948: PUSH
50949: LD_VAR 0 2
50953: ARRAY
50954: PPUSH
50955: CALL 67005 0 3
// exit ;
50959: POP
50960: POP
50961: GO 50967
// end ; end ;
50963: GO 50400
50965: POP
50966: POP
// end ;
50967: LD_VAR 0 1
50971: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50972: LD_INT 0
50974: PPUSH
50975: PPUSH
50976: PPUSH
50977: PPUSH
50978: PPUSH
50979: PPUSH
50980: PPUSH
50981: PPUSH
50982: PPUSH
50983: PPUSH
50984: PPUSH
// if not mc_bases then
50985: LD_EXP 102
50989: NOT
50990: IFFALSE 50994
// exit ;
50992: GO 52081
// for i = 1 to mc_bases do
50994: LD_ADDR_VAR 0 2
50998: PUSH
50999: DOUBLE
51000: LD_INT 1
51002: DEC
51003: ST_TO_ADDR
51004: LD_EXP 102
51008: PUSH
51009: FOR_TO
51010: IFFALSE 52079
// begin tmp := mc_lab [ i ] ;
51012: LD_ADDR_VAR 0 6
51016: PUSH
51017: LD_EXP 135
51021: PUSH
51022: LD_VAR 0 2
51026: ARRAY
51027: ST_TO_ADDR
// if not tmp then
51028: LD_VAR 0 6
51032: NOT
51033: IFFALSE 51037
// continue ;
51035: GO 51009
// idle_lab := 0 ;
51037: LD_ADDR_VAR 0 11
51041: PUSH
51042: LD_INT 0
51044: ST_TO_ADDR
// for j in tmp do
51045: LD_ADDR_VAR 0 3
51049: PUSH
51050: LD_VAR 0 6
51054: PUSH
51055: FOR_IN
51056: IFFALSE 52075
// begin researching := false ;
51058: LD_ADDR_VAR 0 10
51062: PUSH
51063: LD_INT 0
51065: ST_TO_ADDR
// side := GetSide ( j ) ;
51066: LD_ADDR_VAR 0 4
51070: PUSH
51071: LD_VAR 0 3
51075: PPUSH
51076: CALL_OW 255
51080: ST_TO_ADDR
// if not mc_tech [ side ] then
51081: LD_EXP 129
51085: PUSH
51086: LD_VAR 0 4
51090: ARRAY
51091: NOT
51092: IFFALSE 51096
// continue ;
51094: GO 51055
// if BuildingStatus ( j ) = bs_idle then
51096: LD_VAR 0 3
51100: PPUSH
51101: CALL_OW 461
51105: PUSH
51106: LD_INT 2
51108: EQUAL
51109: IFFALSE 51297
// begin if idle_lab and UnitsInside ( j ) < 6 then
51111: LD_VAR 0 11
51115: PUSH
51116: LD_VAR 0 3
51120: PPUSH
51121: CALL_OW 313
51125: PUSH
51126: LD_INT 6
51128: LESS
51129: AND
51130: IFFALSE 51201
// begin tmp2 := UnitsInside ( idle_lab ) ;
51132: LD_ADDR_VAR 0 9
51136: PUSH
51137: LD_VAR 0 11
51141: PPUSH
51142: CALL_OW 313
51146: ST_TO_ADDR
// if tmp2 then
51147: LD_VAR 0 9
51151: IFFALSE 51193
// for x in tmp2 do
51153: LD_ADDR_VAR 0 7
51157: PUSH
51158: LD_VAR 0 9
51162: PUSH
51163: FOR_IN
51164: IFFALSE 51191
// begin ComExitBuilding ( x ) ;
51166: LD_VAR 0 7
51170: PPUSH
51171: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51175: LD_VAR 0 7
51179: PPUSH
51180: LD_VAR 0 3
51184: PPUSH
51185: CALL_OW 180
// end ;
51189: GO 51163
51191: POP
51192: POP
// idle_lab := 0 ;
51193: LD_ADDR_VAR 0 11
51197: PUSH
51198: LD_INT 0
51200: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51201: LD_ADDR_VAR 0 5
51205: PUSH
51206: LD_EXP 129
51210: PUSH
51211: LD_VAR 0 4
51215: ARRAY
51216: PUSH
51217: FOR_IN
51218: IFFALSE 51278
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51220: LD_VAR 0 3
51224: PPUSH
51225: LD_VAR 0 5
51229: PPUSH
51230: CALL_OW 430
51234: PUSH
51235: LD_VAR 0 4
51239: PPUSH
51240: LD_VAR 0 5
51244: PPUSH
51245: CALL 65514 0 2
51249: AND
51250: IFFALSE 51276
// begin researching := true ;
51252: LD_ADDR_VAR 0 10
51256: PUSH
51257: LD_INT 1
51259: ST_TO_ADDR
// ComResearch ( j , t ) ;
51260: LD_VAR 0 3
51264: PPUSH
51265: LD_VAR 0 5
51269: PPUSH
51270: CALL_OW 124
// break ;
51274: GO 51278
// end ;
51276: GO 51217
51278: POP
51279: POP
// if not researching then
51280: LD_VAR 0 10
51284: NOT
51285: IFFALSE 51297
// idle_lab := j ;
51287: LD_ADDR_VAR 0 11
51291: PUSH
51292: LD_VAR 0 3
51296: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51297: LD_VAR 0 3
51301: PPUSH
51302: CALL_OW 461
51306: PUSH
51307: LD_INT 10
51309: EQUAL
51310: IFFALSE 51898
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51312: LD_EXP 131
51316: PUSH
51317: LD_VAR 0 2
51321: ARRAY
51322: NOT
51323: PUSH
51324: LD_EXP 132
51328: PUSH
51329: LD_VAR 0 2
51333: ARRAY
51334: NOT
51335: AND
51336: PUSH
51337: LD_EXP 129
51341: PUSH
51342: LD_VAR 0 4
51346: ARRAY
51347: PUSH
51348: LD_INT 1
51350: GREATER
51351: AND
51352: IFFALSE 51483
// begin ComCancel ( j ) ;
51354: LD_VAR 0 3
51358: PPUSH
51359: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51363: LD_ADDR_EXP 129
51367: PUSH
51368: LD_EXP 129
51372: PPUSH
51373: LD_VAR 0 4
51377: PPUSH
51378: LD_EXP 129
51382: PUSH
51383: LD_VAR 0 4
51387: ARRAY
51388: PPUSH
51389: LD_EXP 129
51393: PUSH
51394: LD_VAR 0 4
51398: ARRAY
51399: PUSH
51400: LD_INT 1
51402: MINUS
51403: PPUSH
51404: LD_EXP 129
51408: PUSH
51409: LD_VAR 0 4
51413: ARRAY
51414: PPUSH
51415: LD_INT 0
51417: PPUSH
51418: CALL 71437 0 4
51422: PPUSH
51423: CALL_OW 1
51427: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51428: LD_ADDR_EXP 129
51432: PUSH
51433: LD_EXP 129
51437: PPUSH
51438: LD_VAR 0 4
51442: PPUSH
51443: LD_EXP 129
51447: PUSH
51448: LD_VAR 0 4
51452: ARRAY
51453: PPUSH
51454: LD_EXP 129
51458: PUSH
51459: LD_VAR 0 4
51463: ARRAY
51464: PPUSH
51465: LD_INT 1
51467: PPUSH
51468: LD_INT 0
51470: PPUSH
51471: CALL 71437 0 4
51475: PPUSH
51476: CALL_OW 1
51480: ST_TO_ADDR
// continue ;
51481: GO 51055
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51483: LD_EXP 131
51487: PUSH
51488: LD_VAR 0 2
51492: ARRAY
51493: PUSH
51494: LD_EXP 132
51498: PUSH
51499: LD_VAR 0 2
51503: ARRAY
51504: NOT
51505: AND
51506: IFFALSE 51633
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51508: LD_ADDR_EXP 132
51512: PUSH
51513: LD_EXP 132
51517: PPUSH
51518: LD_VAR 0 2
51522: PUSH
51523: LD_EXP 132
51527: PUSH
51528: LD_VAR 0 2
51532: ARRAY
51533: PUSH
51534: LD_INT 1
51536: PLUS
51537: PUSH
51538: EMPTY
51539: LIST
51540: LIST
51541: PPUSH
51542: LD_EXP 131
51546: PUSH
51547: LD_VAR 0 2
51551: ARRAY
51552: PUSH
51553: LD_INT 1
51555: ARRAY
51556: PPUSH
51557: CALL 72019 0 3
51561: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51562: LD_EXP 131
51566: PUSH
51567: LD_VAR 0 2
51571: ARRAY
51572: PUSH
51573: LD_INT 1
51575: ARRAY
51576: PPUSH
51577: LD_INT 112
51579: PPUSH
51580: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51584: LD_ADDR_VAR 0 9
51588: PUSH
51589: LD_EXP 131
51593: PUSH
51594: LD_VAR 0 2
51598: ARRAY
51599: PPUSH
51600: LD_INT 1
51602: PPUSH
51603: CALL_OW 3
51607: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51608: LD_ADDR_EXP 131
51612: PUSH
51613: LD_EXP 131
51617: PPUSH
51618: LD_VAR 0 2
51622: PPUSH
51623: LD_VAR 0 9
51627: PPUSH
51628: CALL_OW 1
51632: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51633: LD_EXP 131
51637: PUSH
51638: LD_VAR 0 2
51642: ARRAY
51643: PUSH
51644: LD_EXP 132
51648: PUSH
51649: LD_VAR 0 2
51653: ARRAY
51654: AND
51655: PUSH
51656: LD_EXP 132
51660: PUSH
51661: LD_VAR 0 2
51665: ARRAY
51666: PUSH
51667: LD_INT 1
51669: ARRAY
51670: PPUSH
51671: CALL_OW 310
51675: NOT
51676: AND
51677: PUSH
51678: LD_VAR 0 3
51682: PPUSH
51683: CALL_OW 313
51687: PUSH
51688: LD_INT 6
51690: EQUAL
51691: AND
51692: IFFALSE 51748
// begin tmp2 := UnitsInside ( j ) ;
51694: LD_ADDR_VAR 0 9
51698: PUSH
51699: LD_VAR 0 3
51703: PPUSH
51704: CALL_OW 313
51708: ST_TO_ADDR
// if tmp2 = 6 then
51709: LD_VAR 0 9
51713: PUSH
51714: LD_INT 6
51716: EQUAL
51717: IFFALSE 51748
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51719: LD_VAR 0 9
51723: PUSH
51724: LD_INT 1
51726: ARRAY
51727: PPUSH
51728: LD_INT 112
51730: PPUSH
51731: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51735: LD_VAR 0 9
51739: PUSH
51740: LD_INT 1
51742: ARRAY
51743: PPUSH
51744: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51748: LD_EXP 132
51752: PUSH
51753: LD_VAR 0 2
51757: ARRAY
51758: PUSH
51759: LD_EXP 132
51763: PUSH
51764: LD_VAR 0 2
51768: ARRAY
51769: PUSH
51770: LD_INT 1
51772: ARRAY
51773: PPUSH
51774: CALL_OW 314
51778: NOT
51779: AND
51780: PUSH
51781: LD_EXP 132
51785: PUSH
51786: LD_VAR 0 2
51790: ARRAY
51791: PUSH
51792: LD_INT 1
51794: ARRAY
51795: PPUSH
51796: CALL_OW 310
51800: NOT
51801: AND
51802: IFFALSE 51828
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51804: LD_EXP 132
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PUSH
51815: LD_INT 1
51817: ARRAY
51818: PPUSH
51819: LD_VAR 0 3
51823: PPUSH
51824: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51828: LD_EXP 132
51832: PUSH
51833: LD_VAR 0 2
51837: ARRAY
51838: PUSH
51839: LD_INT 1
51841: ARRAY
51842: PPUSH
51843: CALL_OW 310
51847: PUSH
51848: LD_EXP 132
51852: PUSH
51853: LD_VAR 0 2
51857: ARRAY
51858: PUSH
51859: LD_INT 1
51861: ARRAY
51862: PPUSH
51863: CALL_OW 310
51867: PPUSH
51868: CALL_OW 461
51872: PUSH
51873: LD_INT 3
51875: NONEQUAL
51876: AND
51877: IFFALSE 51898
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51879: LD_EXP 132
51883: PUSH
51884: LD_VAR 0 2
51888: ARRAY
51889: PUSH
51890: LD_INT 1
51892: ARRAY
51893: PPUSH
51894: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51898: LD_VAR 0 3
51902: PPUSH
51903: CALL_OW 461
51907: PUSH
51908: LD_INT 6
51910: EQUAL
51911: PUSH
51912: LD_VAR 0 6
51916: PUSH
51917: LD_INT 1
51919: GREATER
51920: AND
51921: IFFALSE 52073
// begin sci := [ ] ;
51923: LD_ADDR_VAR 0 8
51927: PUSH
51928: EMPTY
51929: ST_TO_ADDR
// for x in ( tmp diff j ) do
51930: LD_ADDR_VAR 0 7
51934: PUSH
51935: LD_VAR 0 6
51939: PUSH
51940: LD_VAR 0 3
51944: DIFF
51945: PUSH
51946: FOR_IN
51947: IFFALSE 51999
// begin if sci = 6 then
51949: LD_VAR 0 8
51953: PUSH
51954: LD_INT 6
51956: EQUAL
51957: IFFALSE 51961
// break ;
51959: GO 51999
// if BuildingStatus ( x ) = bs_idle then
51961: LD_VAR 0 7
51965: PPUSH
51966: CALL_OW 461
51970: PUSH
51971: LD_INT 2
51973: EQUAL
51974: IFFALSE 51997
// sci := sci ^ UnitsInside ( x ) ;
51976: LD_ADDR_VAR 0 8
51980: PUSH
51981: LD_VAR 0 8
51985: PUSH
51986: LD_VAR 0 7
51990: PPUSH
51991: CALL_OW 313
51995: ADD
51996: ST_TO_ADDR
// end ;
51997: GO 51946
51999: POP
52000: POP
// if not sci then
52001: LD_VAR 0 8
52005: NOT
52006: IFFALSE 52010
// continue ;
52008: GO 51055
// for x in sci do
52010: LD_ADDR_VAR 0 7
52014: PUSH
52015: LD_VAR 0 8
52019: PUSH
52020: FOR_IN
52021: IFFALSE 52071
// if IsInUnit ( x ) and not HasTask ( x ) then
52023: LD_VAR 0 7
52027: PPUSH
52028: CALL_OW 310
52032: PUSH
52033: LD_VAR 0 7
52037: PPUSH
52038: CALL_OW 314
52042: NOT
52043: AND
52044: IFFALSE 52069
// begin ComExitBuilding ( x ) ;
52046: LD_VAR 0 7
52050: PPUSH
52051: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52055: LD_VAR 0 7
52059: PPUSH
52060: LD_VAR 0 3
52064: PPUSH
52065: CALL_OW 180
// end ;
52069: GO 52020
52071: POP
52072: POP
// end ; end ;
52073: GO 51055
52075: POP
52076: POP
// end ;
52077: GO 51009
52079: POP
52080: POP
// end ;
52081: LD_VAR 0 1
52085: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52086: LD_INT 0
52088: PPUSH
52089: PPUSH
// if not mc_bases then
52090: LD_EXP 102
52094: NOT
52095: IFFALSE 52099
// exit ;
52097: GO 52180
// for i = 1 to mc_bases do
52099: LD_ADDR_VAR 0 2
52103: PUSH
52104: DOUBLE
52105: LD_INT 1
52107: DEC
52108: ST_TO_ADDR
52109: LD_EXP 102
52113: PUSH
52114: FOR_TO
52115: IFFALSE 52178
// if mc_mines [ i ] and mc_miners [ i ] then
52117: LD_EXP 115
52121: PUSH
52122: LD_VAR 0 2
52126: ARRAY
52127: PUSH
52128: LD_EXP 116
52132: PUSH
52133: LD_VAR 0 2
52137: ARRAY
52138: AND
52139: IFFALSE 52176
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52141: LD_EXP 116
52145: PUSH
52146: LD_VAR 0 2
52150: ARRAY
52151: PUSH
52152: LD_INT 1
52154: ARRAY
52155: PPUSH
52156: CALL_OW 255
52160: PPUSH
52161: LD_EXP 115
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PPUSH
52172: CALL 69008 0 2
52176: GO 52114
52178: POP
52179: POP
// end ;
52180: LD_VAR 0 1
52184: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52185: LD_INT 0
52187: PPUSH
52188: PPUSH
52189: PPUSH
52190: PPUSH
52191: PPUSH
52192: PPUSH
52193: PPUSH
52194: PPUSH
// if not mc_bases or not mc_parking then
52195: LD_EXP 102
52199: NOT
52200: PUSH
52201: LD_EXP 126
52205: NOT
52206: OR
52207: IFFALSE 52211
// exit ;
52209: GO 52910
// for i = 1 to mc_bases do
52211: LD_ADDR_VAR 0 2
52215: PUSH
52216: DOUBLE
52217: LD_INT 1
52219: DEC
52220: ST_TO_ADDR
52221: LD_EXP 102
52225: PUSH
52226: FOR_TO
52227: IFFALSE 52908
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52229: LD_EXP 102
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: NOT
52240: PUSH
52241: LD_EXP 126
52245: PUSH
52246: LD_VAR 0 2
52250: ARRAY
52251: NOT
52252: OR
52253: IFFALSE 52257
// continue ;
52255: GO 52226
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52257: LD_ADDR_VAR 0 5
52261: PUSH
52262: LD_EXP 102
52266: PUSH
52267: LD_VAR 0 2
52271: ARRAY
52272: PUSH
52273: LD_INT 1
52275: ARRAY
52276: PPUSH
52277: CALL_OW 255
52281: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52282: LD_ADDR_VAR 0 6
52286: PUSH
52287: LD_EXP 102
52291: PUSH
52292: LD_VAR 0 2
52296: ARRAY
52297: PPUSH
52298: LD_INT 30
52300: PUSH
52301: LD_INT 3
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: PPUSH
52308: CALL_OW 72
52312: ST_TO_ADDR
// if not fac then
52313: LD_VAR 0 6
52317: NOT
52318: IFFALSE 52369
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52320: LD_ADDR_VAR 0 6
52324: PUSH
52325: LD_EXP 102
52329: PUSH
52330: LD_VAR 0 2
52334: ARRAY
52335: PPUSH
52336: LD_INT 2
52338: PUSH
52339: LD_INT 30
52341: PUSH
52342: LD_INT 0
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: LD_INT 30
52351: PUSH
52352: LD_INT 1
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: PUSH
52359: EMPTY
52360: LIST
52361: LIST
52362: LIST
52363: PPUSH
52364: CALL_OW 72
52368: ST_TO_ADDR
// if not fac then
52369: LD_VAR 0 6
52373: NOT
52374: IFFALSE 52378
// continue ;
52376: GO 52226
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52378: LD_ADDR_VAR 0 7
52382: PUSH
52383: LD_EXP 126
52387: PUSH
52388: LD_VAR 0 2
52392: ARRAY
52393: PPUSH
52394: LD_INT 22
52396: PUSH
52397: LD_VAR 0 5
52401: PUSH
52402: EMPTY
52403: LIST
52404: LIST
52405: PUSH
52406: LD_INT 21
52408: PUSH
52409: LD_INT 2
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: PUSH
52416: LD_INT 3
52418: PUSH
52419: LD_INT 24
52421: PUSH
52422: LD_INT 1000
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: PUSH
52429: EMPTY
52430: LIST
52431: LIST
52432: PUSH
52433: EMPTY
52434: LIST
52435: LIST
52436: LIST
52437: PPUSH
52438: CALL_OW 70
52442: ST_TO_ADDR
// for j in fac do
52443: LD_ADDR_VAR 0 3
52447: PUSH
52448: LD_VAR 0 6
52452: PUSH
52453: FOR_IN
52454: IFFALSE 52535
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52456: LD_ADDR_VAR 0 7
52460: PUSH
52461: LD_VAR 0 7
52465: PUSH
52466: LD_INT 22
52468: PUSH
52469: LD_VAR 0 5
52473: PUSH
52474: EMPTY
52475: LIST
52476: LIST
52477: PUSH
52478: LD_INT 91
52480: PUSH
52481: LD_VAR 0 3
52485: PUSH
52486: LD_INT 15
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: LIST
52493: PUSH
52494: LD_INT 21
52496: PUSH
52497: LD_INT 2
52499: PUSH
52500: EMPTY
52501: LIST
52502: LIST
52503: PUSH
52504: LD_INT 3
52506: PUSH
52507: LD_INT 24
52509: PUSH
52510: LD_INT 1000
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: PUSH
52517: EMPTY
52518: LIST
52519: LIST
52520: PUSH
52521: EMPTY
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: PPUSH
52527: CALL_OW 69
52531: UNION
52532: ST_TO_ADDR
52533: GO 52453
52535: POP
52536: POP
// if not vehs then
52537: LD_VAR 0 7
52541: NOT
52542: IFFALSE 52568
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52544: LD_ADDR_EXP 114
52548: PUSH
52549: LD_EXP 114
52553: PPUSH
52554: LD_VAR 0 2
52558: PPUSH
52559: EMPTY
52560: PPUSH
52561: CALL_OW 1
52565: ST_TO_ADDR
// continue ;
52566: GO 52226
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52568: LD_ADDR_VAR 0 8
52572: PUSH
52573: LD_EXP 102
52577: PUSH
52578: LD_VAR 0 2
52582: ARRAY
52583: PPUSH
52584: LD_INT 30
52586: PUSH
52587: LD_INT 3
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: PPUSH
52594: CALL_OW 72
52598: ST_TO_ADDR
// if tmp then
52599: LD_VAR 0 8
52603: IFFALSE 52706
// begin for j in tmp do
52605: LD_ADDR_VAR 0 3
52609: PUSH
52610: LD_VAR 0 8
52614: PUSH
52615: FOR_IN
52616: IFFALSE 52704
// for k in UnitsInside ( j ) do
52618: LD_ADDR_VAR 0 4
52622: PUSH
52623: LD_VAR 0 3
52627: PPUSH
52628: CALL_OW 313
52632: PUSH
52633: FOR_IN
52634: IFFALSE 52700
// if k then
52636: LD_VAR 0 4
52640: IFFALSE 52698
// if not k in mc_repair_vehicle [ i ] then
52642: LD_VAR 0 4
52646: PUSH
52647: LD_EXP 114
52651: PUSH
52652: LD_VAR 0 2
52656: ARRAY
52657: IN
52658: NOT
52659: IFFALSE 52698
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52661: LD_ADDR_EXP 114
52665: PUSH
52666: LD_EXP 114
52670: PPUSH
52671: LD_VAR 0 2
52675: PPUSH
52676: LD_EXP 114
52680: PUSH
52681: LD_VAR 0 2
52685: ARRAY
52686: PUSH
52687: LD_VAR 0 4
52691: UNION
52692: PPUSH
52693: CALL_OW 1
52697: ST_TO_ADDR
52698: GO 52633
52700: POP
52701: POP
52702: GO 52615
52704: POP
52705: POP
// end ; if not mc_repair_vehicle [ i ] then
52706: LD_EXP 114
52710: PUSH
52711: LD_VAR 0 2
52715: ARRAY
52716: NOT
52717: IFFALSE 52721
// continue ;
52719: GO 52226
// for j in mc_repair_vehicle [ i ] do
52721: LD_ADDR_VAR 0 3
52725: PUSH
52726: LD_EXP 114
52730: PUSH
52731: LD_VAR 0 2
52735: ARRAY
52736: PUSH
52737: FOR_IN
52738: IFFALSE 52904
// begin if GetClass ( j ) <> 3 then
52740: LD_VAR 0 3
52744: PPUSH
52745: CALL_OW 257
52749: PUSH
52750: LD_INT 3
52752: NONEQUAL
52753: IFFALSE 52794
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52755: LD_ADDR_EXP 114
52759: PUSH
52760: LD_EXP 114
52764: PPUSH
52765: LD_VAR 0 2
52769: PPUSH
52770: LD_EXP 114
52774: PUSH
52775: LD_VAR 0 2
52779: ARRAY
52780: PUSH
52781: LD_VAR 0 3
52785: DIFF
52786: PPUSH
52787: CALL_OW 1
52791: ST_TO_ADDR
// continue ;
52792: GO 52737
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52794: LD_VAR 0 3
52798: PPUSH
52799: CALL_OW 311
52803: NOT
52804: PUSH
52805: LD_VAR 0 3
52809: PUSH
52810: LD_EXP 105
52814: PUSH
52815: LD_VAR 0 2
52819: ARRAY
52820: PUSH
52821: LD_INT 1
52823: ARRAY
52824: IN
52825: NOT
52826: AND
52827: PUSH
52828: LD_VAR 0 3
52832: PUSH
52833: LD_EXP 105
52837: PUSH
52838: LD_VAR 0 2
52842: ARRAY
52843: PUSH
52844: LD_INT 2
52846: ARRAY
52847: IN
52848: NOT
52849: AND
52850: IFFALSE 52902
// begin if IsInUnit ( j ) then
52852: LD_VAR 0 3
52856: PPUSH
52857: CALL_OW 310
52861: IFFALSE 52872
// ComExitBuilding ( j ) ;
52863: LD_VAR 0 3
52867: PPUSH
52868: CALL_OW 122
// if not HasTask ( j ) then
52872: LD_VAR 0 3
52876: PPUSH
52877: CALL_OW 314
52881: NOT
52882: IFFALSE 52902
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52884: LD_VAR 0 3
52888: PPUSH
52889: LD_VAR 0 7
52893: PUSH
52894: LD_INT 1
52896: ARRAY
52897: PPUSH
52898: CALL_OW 189
// end ; end ;
52902: GO 52737
52904: POP
52905: POP
// end ;
52906: GO 52226
52908: POP
52909: POP
// end ;
52910: LD_VAR 0 1
52914: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52915: LD_INT 0
52917: PPUSH
52918: PPUSH
52919: PPUSH
52920: PPUSH
52921: PPUSH
52922: PPUSH
52923: PPUSH
52924: PPUSH
52925: PPUSH
52926: PPUSH
52927: PPUSH
// if not mc_bases then
52928: LD_EXP 102
52932: NOT
52933: IFFALSE 52937
// exit ;
52935: GO 53739
// for i = 1 to mc_bases do
52937: LD_ADDR_VAR 0 2
52941: PUSH
52942: DOUBLE
52943: LD_INT 1
52945: DEC
52946: ST_TO_ADDR
52947: LD_EXP 102
52951: PUSH
52952: FOR_TO
52953: IFFALSE 53737
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52955: LD_EXP 130
52959: PUSH
52960: LD_VAR 0 2
52964: ARRAY
52965: NOT
52966: PUSH
52967: LD_EXP 105
52971: PUSH
52972: LD_VAR 0 2
52976: ARRAY
52977: PUSH
52978: LD_INT 1
52980: ARRAY
52981: OR
52982: PUSH
52983: LD_EXP 105
52987: PUSH
52988: LD_VAR 0 2
52992: ARRAY
52993: PUSH
52994: LD_INT 2
52996: ARRAY
52997: OR
52998: PUSH
52999: LD_EXP 128
53003: PUSH
53004: LD_VAR 0 2
53008: ARRAY
53009: PPUSH
53010: LD_INT 1
53012: PPUSH
53013: CALL_OW 325
53017: NOT
53018: OR
53019: PUSH
53020: LD_EXP 125
53024: PUSH
53025: LD_VAR 0 2
53029: ARRAY
53030: OR
53031: IFFALSE 53035
// continue ;
53033: GO 52952
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53035: LD_ADDR_VAR 0 8
53039: PUSH
53040: LD_EXP 102
53044: PUSH
53045: LD_VAR 0 2
53049: ARRAY
53050: PPUSH
53051: LD_INT 25
53053: PUSH
53054: LD_INT 4
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: PUSH
53061: LD_INT 50
53063: PUSH
53064: EMPTY
53065: LIST
53066: PUSH
53067: LD_INT 3
53069: PUSH
53070: LD_INT 60
53072: PUSH
53073: EMPTY
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: PUSH
53080: EMPTY
53081: LIST
53082: LIST
53083: LIST
53084: PPUSH
53085: CALL_OW 72
53089: PUSH
53090: LD_EXP 106
53094: PUSH
53095: LD_VAR 0 2
53099: ARRAY
53100: DIFF
53101: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53102: LD_ADDR_VAR 0 9
53106: PUSH
53107: LD_EXP 102
53111: PUSH
53112: LD_VAR 0 2
53116: ARRAY
53117: PPUSH
53118: LD_INT 2
53120: PUSH
53121: LD_INT 30
53123: PUSH
53124: LD_INT 0
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: PUSH
53131: LD_INT 30
53133: PUSH
53134: LD_INT 1
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: LIST
53145: PPUSH
53146: CALL_OW 72
53150: ST_TO_ADDR
// if not tmp or not dep then
53151: LD_VAR 0 8
53155: NOT
53156: PUSH
53157: LD_VAR 0 9
53161: NOT
53162: OR
53163: IFFALSE 53167
// continue ;
53165: GO 52952
// side := GetSide ( tmp [ 1 ] ) ;
53167: LD_ADDR_VAR 0 11
53171: PUSH
53172: LD_VAR 0 8
53176: PUSH
53177: LD_INT 1
53179: ARRAY
53180: PPUSH
53181: CALL_OW 255
53185: ST_TO_ADDR
// dep := dep [ 1 ] ;
53186: LD_ADDR_VAR 0 9
53190: PUSH
53191: LD_VAR 0 9
53195: PUSH
53196: LD_INT 1
53198: ARRAY
53199: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53200: LD_ADDR_VAR 0 7
53204: PUSH
53205: LD_EXP 130
53209: PUSH
53210: LD_VAR 0 2
53214: ARRAY
53215: PPUSH
53216: LD_INT 22
53218: PUSH
53219: LD_INT 0
53221: PUSH
53222: EMPTY
53223: LIST
53224: LIST
53225: PUSH
53226: LD_INT 25
53228: PUSH
53229: LD_INT 12
53231: PUSH
53232: EMPTY
53233: LIST
53234: LIST
53235: PUSH
53236: EMPTY
53237: LIST
53238: LIST
53239: PPUSH
53240: CALL_OW 70
53244: PUSH
53245: LD_INT 22
53247: PUSH
53248: LD_INT 0
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: LD_INT 25
53257: PUSH
53258: LD_INT 12
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PUSH
53265: LD_INT 91
53267: PUSH
53268: LD_VAR 0 9
53272: PUSH
53273: LD_INT 20
53275: PUSH
53276: EMPTY
53277: LIST
53278: LIST
53279: LIST
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: LIST
53285: PPUSH
53286: CALL_OW 69
53290: UNION
53291: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53292: LD_ADDR_VAR 0 10
53296: PUSH
53297: LD_EXP 130
53301: PUSH
53302: LD_VAR 0 2
53306: ARRAY
53307: PPUSH
53308: LD_INT 81
53310: PUSH
53311: LD_VAR 0 11
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: PPUSH
53320: CALL_OW 70
53324: ST_TO_ADDR
// if not apes or danger_at_area then
53325: LD_VAR 0 7
53329: NOT
53330: PUSH
53331: LD_VAR 0 10
53335: OR
53336: IFFALSE 53386
// begin if mc_taming [ i ] then
53338: LD_EXP 133
53342: PUSH
53343: LD_VAR 0 2
53347: ARRAY
53348: IFFALSE 53384
// begin MC_Reset ( i , 121 ) ;
53350: LD_VAR 0 2
53354: PPUSH
53355: LD_INT 121
53357: PPUSH
53358: CALL 38821 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53362: LD_ADDR_EXP 133
53366: PUSH
53367: LD_EXP 133
53371: PPUSH
53372: LD_VAR 0 2
53376: PPUSH
53377: EMPTY
53378: PPUSH
53379: CALL_OW 1
53383: ST_TO_ADDR
// end ; continue ;
53384: GO 52952
// end ; for j in tmp do
53386: LD_ADDR_VAR 0 3
53390: PUSH
53391: LD_VAR 0 8
53395: PUSH
53396: FOR_IN
53397: IFFALSE 53733
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53399: LD_VAR 0 3
53403: PUSH
53404: LD_EXP 133
53408: PUSH
53409: LD_VAR 0 2
53413: ARRAY
53414: IN
53415: NOT
53416: PUSH
53417: LD_EXP 133
53421: PUSH
53422: LD_VAR 0 2
53426: ARRAY
53427: PUSH
53428: LD_INT 3
53430: LESS
53431: AND
53432: IFFALSE 53490
// begin SetTag ( j , 121 ) ;
53434: LD_VAR 0 3
53438: PPUSH
53439: LD_INT 121
53441: PPUSH
53442: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53446: LD_ADDR_EXP 133
53450: PUSH
53451: LD_EXP 133
53455: PPUSH
53456: LD_VAR 0 2
53460: PUSH
53461: LD_EXP 133
53465: PUSH
53466: LD_VAR 0 2
53470: ARRAY
53471: PUSH
53472: LD_INT 1
53474: PLUS
53475: PUSH
53476: EMPTY
53477: LIST
53478: LIST
53479: PPUSH
53480: LD_VAR 0 3
53484: PPUSH
53485: CALL 72019 0 3
53489: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53490: LD_VAR 0 3
53494: PUSH
53495: LD_EXP 133
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: IN
53506: IFFALSE 53731
// begin if GetClass ( j ) <> 4 then
53508: LD_VAR 0 3
53512: PPUSH
53513: CALL_OW 257
53517: PUSH
53518: LD_INT 4
53520: NONEQUAL
53521: IFFALSE 53574
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53523: LD_ADDR_EXP 133
53527: PUSH
53528: LD_EXP 133
53532: PPUSH
53533: LD_VAR 0 2
53537: PPUSH
53538: LD_EXP 133
53542: PUSH
53543: LD_VAR 0 2
53547: ARRAY
53548: PUSH
53549: LD_VAR 0 3
53553: DIFF
53554: PPUSH
53555: CALL_OW 1
53559: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53560: LD_VAR 0 3
53564: PPUSH
53565: LD_INT 0
53567: PPUSH
53568: CALL_OW 109
// continue ;
53572: GO 53396
// end ; if IsInUnit ( j ) then
53574: LD_VAR 0 3
53578: PPUSH
53579: CALL_OW 310
53583: IFFALSE 53594
// ComExitBuilding ( j ) ;
53585: LD_VAR 0 3
53589: PPUSH
53590: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53594: LD_ADDR_VAR 0 6
53598: PUSH
53599: LD_VAR 0 7
53603: PPUSH
53604: LD_VAR 0 3
53608: PPUSH
53609: CALL_OW 74
53613: ST_TO_ADDR
// if not ape then
53614: LD_VAR 0 6
53618: NOT
53619: IFFALSE 53623
// break ;
53621: GO 53733
// x := GetX ( ape ) ;
53623: LD_ADDR_VAR 0 4
53627: PUSH
53628: LD_VAR 0 6
53632: PPUSH
53633: CALL_OW 250
53637: ST_TO_ADDR
// y := GetY ( ape ) ;
53638: LD_ADDR_VAR 0 5
53642: PUSH
53643: LD_VAR 0 6
53647: PPUSH
53648: CALL_OW 251
53652: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53653: LD_VAR 0 4
53657: PPUSH
53658: LD_VAR 0 5
53662: PPUSH
53663: CALL_OW 488
53667: NOT
53668: PUSH
53669: LD_VAR 0 11
53673: PPUSH
53674: LD_VAR 0 4
53678: PPUSH
53679: LD_VAR 0 5
53683: PPUSH
53684: LD_INT 20
53686: PPUSH
53687: CALL 72915 0 4
53691: PUSH
53692: LD_INT 4
53694: ARRAY
53695: OR
53696: IFFALSE 53700
// break ;
53698: GO 53733
// if not HasTask ( j ) then
53700: LD_VAR 0 3
53704: PPUSH
53705: CALL_OW 314
53709: NOT
53710: IFFALSE 53731
// ComTameXY ( j , x , y ) ;
53712: LD_VAR 0 3
53716: PPUSH
53717: LD_VAR 0 4
53721: PPUSH
53722: LD_VAR 0 5
53726: PPUSH
53727: CALL_OW 131
// end ; end ;
53731: GO 53396
53733: POP
53734: POP
// end ;
53735: GO 52952
53737: POP
53738: POP
// end ;
53739: LD_VAR 0 1
53743: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53744: LD_INT 0
53746: PPUSH
53747: PPUSH
53748: PPUSH
53749: PPUSH
53750: PPUSH
53751: PPUSH
53752: PPUSH
53753: PPUSH
// if not mc_bases then
53754: LD_EXP 102
53758: NOT
53759: IFFALSE 53763
// exit ;
53761: GO 54389
// for i = 1 to mc_bases do
53763: LD_ADDR_VAR 0 2
53767: PUSH
53768: DOUBLE
53769: LD_INT 1
53771: DEC
53772: ST_TO_ADDR
53773: LD_EXP 102
53777: PUSH
53778: FOR_TO
53779: IFFALSE 54387
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53781: LD_EXP 131
53785: PUSH
53786: LD_VAR 0 2
53790: ARRAY
53791: NOT
53792: PUSH
53793: LD_EXP 131
53797: PUSH
53798: LD_VAR 0 2
53802: ARRAY
53803: PPUSH
53804: LD_INT 25
53806: PUSH
53807: LD_INT 12
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PPUSH
53814: CALL_OW 72
53818: NOT
53819: OR
53820: IFFALSE 53824
// continue ;
53822: GO 53778
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53824: LD_ADDR_VAR 0 5
53828: PUSH
53829: LD_EXP 131
53833: PUSH
53834: LD_VAR 0 2
53838: ARRAY
53839: PUSH
53840: LD_INT 1
53842: ARRAY
53843: PPUSH
53844: CALL_OW 255
53848: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53849: LD_VAR 0 5
53853: PPUSH
53854: LD_INT 2
53856: PPUSH
53857: CALL_OW 325
53861: IFFALSE 54114
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53863: LD_ADDR_VAR 0 4
53867: PUSH
53868: LD_EXP 131
53872: PUSH
53873: LD_VAR 0 2
53877: ARRAY
53878: PPUSH
53879: LD_INT 25
53881: PUSH
53882: LD_INT 16
53884: PUSH
53885: EMPTY
53886: LIST
53887: LIST
53888: PPUSH
53889: CALL_OW 72
53893: ST_TO_ADDR
// if tmp < 6 then
53894: LD_VAR 0 4
53898: PUSH
53899: LD_INT 6
53901: LESS
53902: IFFALSE 54114
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53904: LD_ADDR_VAR 0 6
53908: PUSH
53909: LD_EXP 102
53913: PUSH
53914: LD_VAR 0 2
53918: ARRAY
53919: PPUSH
53920: LD_INT 2
53922: PUSH
53923: LD_INT 30
53925: PUSH
53926: LD_INT 0
53928: PUSH
53929: EMPTY
53930: LIST
53931: LIST
53932: PUSH
53933: LD_INT 30
53935: PUSH
53936: LD_INT 1
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PUSH
53943: EMPTY
53944: LIST
53945: LIST
53946: LIST
53947: PPUSH
53948: CALL_OW 72
53952: ST_TO_ADDR
// if depot then
53953: LD_VAR 0 6
53957: IFFALSE 54114
// begin selected := 0 ;
53959: LD_ADDR_VAR 0 7
53963: PUSH
53964: LD_INT 0
53966: ST_TO_ADDR
// for j in depot do
53967: LD_ADDR_VAR 0 3
53971: PUSH
53972: LD_VAR 0 6
53976: PUSH
53977: FOR_IN
53978: IFFALSE 54009
// begin if UnitsInside ( j ) < 6 then
53980: LD_VAR 0 3
53984: PPUSH
53985: CALL_OW 313
53989: PUSH
53990: LD_INT 6
53992: LESS
53993: IFFALSE 54007
// begin selected := j ;
53995: LD_ADDR_VAR 0 7
53999: PUSH
54000: LD_VAR 0 3
54004: ST_TO_ADDR
// break ;
54005: GO 54009
// end ; end ;
54007: GO 53977
54009: POP
54010: POP
// if selected then
54011: LD_VAR 0 7
54015: IFFALSE 54114
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54017: LD_ADDR_VAR 0 3
54021: PUSH
54022: LD_EXP 131
54026: PUSH
54027: LD_VAR 0 2
54031: ARRAY
54032: PPUSH
54033: LD_INT 25
54035: PUSH
54036: LD_INT 12
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PPUSH
54043: CALL_OW 72
54047: PUSH
54048: FOR_IN
54049: IFFALSE 54112
// if not HasTask ( j ) then
54051: LD_VAR 0 3
54055: PPUSH
54056: CALL_OW 314
54060: NOT
54061: IFFALSE 54110
// begin if not IsInUnit ( j ) then
54063: LD_VAR 0 3
54067: PPUSH
54068: CALL_OW 310
54072: NOT
54073: IFFALSE 54089
// ComEnterUnit ( j , selected ) ;
54075: LD_VAR 0 3
54079: PPUSH
54080: LD_VAR 0 7
54084: PPUSH
54085: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54089: LD_VAR 0 3
54093: PPUSH
54094: LD_INT 16
54096: PPUSH
54097: CALL_OW 183
// AddComExitBuilding ( j ) ;
54101: LD_VAR 0 3
54105: PPUSH
54106: CALL_OW 182
// end ;
54110: GO 54048
54112: POP
54113: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54114: LD_VAR 0 5
54118: PPUSH
54119: LD_INT 11
54121: PPUSH
54122: CALL_OW 325
54126: IFFALSE 54385
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54128: LD_ADDR_VAR 0 4
54132: PUSH
54133: LD_EXP 131
54137: PUSH
54138: LD_VAR 0 2
54142: ARRAY
54143: PPUSH
54144: LD_INT 25
54146: PUSH
54147: LD_INT 16
54149: PUSH
54150: EMPTY
54151: LIST
54152: LIST
54153: PPUSH
54154: CALL_OW 72
54158: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54159: LD_VAR 0 4
54163: PUSH
54164: LD_INT 6
54166: GREATEREQUAL
54167: PUSH
54168: LD_VAR 0 5
54172: PPUSH
54173: LD_INT 2
54175: PPUSH
54176: CALL_OW 325
54180: NOT
54181: OR
54182: IFFALSE 54385
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54184: LD_ADDR_VAR 0 8
54188: PUSH
54189: LD_EXP 102
54193: PUSH
54194: LD_VAR 0 2
54198: ARRAY
54199: PPUSH
54200: LD_INT 2
54202: PUSH
54203: LD_INT 30
54205: PUSH
54206: LD_INT 4
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PUSH
54213: LD_INT 30
54215: PUSH
54216: LD_INT 5
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: LIST
54227: PPUSH
54228: CALL_OW 72
54232: ST_TO_ADDR
// if barracks then
54233: LD_VAR 0 8
54237: IFFALSE 54385
// begin selected := 0 ;
54239: LD_ADDR_VAR 0 7
54243: PUSH
54244: LD_INT 0
54246: ST_TO_ADDR
// for j in barracks do
54247: LD_ADDR_VAR 0 3
54251: PUSH
54252: LD_VAR 0 8
54256: PUSH
54257: FOR_IN
54258: IFFALSE 54289
// begin if UnitsInside ( j ) < 6 then
54260: LD_VAR 0 3
54264: PPUSH
54265: CALL_OW 313
54269: PUSH
54270: LD_INT 6
54272: LESS
54273: IFFALSE 54287
// begin selected := j ;
54275: LD_ADDR_VAR 0 7
54279: PUSH
54280: LD_VAR 0 3
54284: ST_TO_ADDR
// break ;
54285: GO 54289
// end ; end ;
54287: GO 54257
54289: POP
54290: POP
// if selected then
54291: LD_VAR 0 7
54295: IFFALSE 54385
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54297: LD_ADDR_VAR 0 3
54301: PUSH
54302: LD_EXP 131
54306: PUSH
54307: LD_VAR 0 2
54311: ARRAY
54312: PPUSH
54313: LD_INT 25
54315: PUSH
54316: LD_INT 12
54318: PUSH
54319: EMPTY
54320: LIST
54321: LIST
54322: PPUSH
54323: CALL_OW 72
54327: PUSH
54328: FOR_IN
54329: IFFALSE 54383
// if not IsInUnit ( j ) and not HasTask ( j ) then
54331: LD_VAR 0 3
54335: PPUSH
54336: CALL_OW 310
54340: NOT
54341: PUSH
54342: LD_VAR 0 3
54346: PPUSH
54347: CALL_OW 314
54351: NOT
54352: AND
54353: IFFALSE 54381
// begin ComEnterUnit ( j , selected ) ;
54355: LD_VAR 0 3
54359: PPUSH
54360: LD_VAR 0 7
54364: PPUSH
54365: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54369: LD_VAR 0 3
54373: PPUSH
54374: LD_INT 15
54376: PPUSH
54377: CALL_OW 183
// end ;
54381: GO 54328
54383: POP
54384: POP
// end ; end ; end ; end ; end ;
54385: GO 53778
54387: POP
54388: POP
// end ;
54389: LD_VAR 0 1
54393: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54394: LD_INT 0
54396: PPUSH
54397: PPUSH
54398: PPUSH
54399: PPUSH
// if not mc_bases then
54400: LD_EXP 102
54404: NOT
54405: IFFALSE 54409
// exit ;
54407: GO 54587
// for i = 1 to mc_bases do
54409: LD_ADDR_VAR 0 2
54413: PUSH
54414: DOUBLE
54415: LD_INT 1
54417: DEC
54418: ST_TO_ADDR
54419: LD_EXP 102
54423: PUSH
54424: FOR_TO
54425: IFFALSE 54585
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54427: LD_ADDR_VAR 0 4
54431: PUSH
54432: LD_EXP 102
54436: PUSH
54437: LD_VAR 0 2
54441: ARRAY
54442: PPUSH
54443: LD_INT 25
54445: PUSH
54446: LD_INT 9
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PPUSH
54453: CALL_OW 72
54457: ST_TO_ADDR
// if not tmp then
54458: LD_VAR 0 4
54462: NOT
54463: IFFALSE 54467
// continue ;
54465: GO 54424
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54467: LD_EXP 128
54471: PUSH
54472: LD_VAR 0 2
54476: ARRAY
54477: PPUSH
54478: LD_INT 29
54480: PPUSH
54481: CALL_OW 325
54485: NOT
54486: PUSH
54487: LD_EXP 128
54491: PUSH
54492: LD_VAR 0 2
54496: ARRAY
54497: PPUSH
54498: LD_INT 28
54500: PPUSH
54501: CALL_OW 325
54505: NOT
54506: AND
54507: IFFALSE 54511
// continue ;
54509: GO 54424
// for j in tmp do
54511: LD_ADDR_VAR 0 3
54515: PUSH
54516: LD_VAR 0 4
54520: PUSH
54521: FOR_IN
54522: IFFALSE 54581
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54524: LD_VAR 0 3
54528: PUSH
54529: LD_EXP 105
54533: PUSH
54534: LD_VAR 0 2
54538: ARRAY
54539: PUSH
54540: LD_INT 1
54542: ARRAY
54543: IN
54544: NOT
54545: PUSH
54546: LD_VAR 0 3
54550: PUSH
54551: LD_EXP 105
54555: PUSH
54556: LD_VAR 0 2
54560: ARRAY
54561: PUSH
54562: LD_INT 2
54564: ARRAY
54565: IN
54566: NOT
54567: AND
54568: IFFALSE 54579
// ComSpaceTimeShoot ( j ) ;
54570: LD_VAR 0 3
54574: PPUSH
54575: CALL 65605 0 1
54579: GO 54521
54581: POP
54582: POP
// end ;
54583: GO 54424
54585: POP
54586: POP
// end ;
54587: LD_VAR 0 1
54591: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
54598: PPUSH
54599: PPUSH
54600: PPUSH
54601: PPUSH
54602: PPUSH
// if not mc_bases then
54603: LD_EXP 102
54607: NOT
54608: IFFALSE 54612
// exit ;
54610: GO 55234
// for i = 1 to mc_bases do
54612: LD_ADDR_VAR 0 2
54616: PUSH
54617: DOUBLE
54618: LD_INT 1
54620: DEC
54621: ST_TO_ADDR
54622: LD_EXP 102
54626: PUSH
54627: FOR_TO
54628: IFFALSE 55232
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54630: LD_EXP 137
54634: PUSH
54635: LD_VAR 0 2
54639: ARRAY
54640: NOT
54641: PUSH
54642: LD_INT 38
54644: PPUSH
54645: LD_EXP 128
54649: PUSH
54650: LD_VAR 0 2
54654: ARRAY
54655: PPUSH
54656: CALL_OW 321
54660: PUSH
54661: LD_INT 2
54663: NONEQUAL
54664: OR
54665: IFFALSE 54669
// continue ;
54667: GO 54627
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54669: LD_ADDR_VAR 0 8
54673: PUSH
54674: LD_EXP 102
54678: PUSH
54679: LD_VAR 0 2
54683: ARRAY
54684: PPUSH
54685: LD_INT 30
54687: PUSH
54688: LD_INT 34
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: PPUSH
54695: CALL_OW 72
54699: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54700: LD_ADDR_VAR 0 9
54704: PUSH
54705: LD_EXP 102
54709: PUSH
54710: LD_VAR 0 2
54714: ARRAY
54715: PPUSH
54716: LD_INT 25
54718: PUSH
54719: LD_INT 4
54721: PUSH
54722: EMPTY
54723: LIST
54724: LIST
54725: PPUSH
54726: CALL_OW 72
54730: PPUSH
54731: LD_INT 0
54733: PPUSH
54734: CALL 105289 0 2
54738: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54739: LD_VAR 0 9
54743: NOT
54744: PUSH
54745: LD_VAR 0 8
54749: NOT
54750: OR
54751: PUSH
54752: LD_EXP 102
54756: PUSH
54757: LD_VAR 0 2
54761: ARRAY
54762: PPUSH
54763: LD_INT 124
54765: PPUSH
54766: CALL 105289 0 2
54770: OR
54771: IFFALSE 54775
// continue ;
54773: GO 54627
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54775: LD_EXP 138
54779: PUSH
54780: LD_VAR 0 2
54784: ARRAY
54785: PUSH
54786: LD_EXP 137
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: LESS
54797: PUSH
54798: LD_EXP 138
54802: PUSH
54803: LD_VAR 0 2
54807: ARRAY
54808: PUSH
54809: LD_VAR 0 8
54813: LESS
54814: AND
54815: IFFALSE 55230
// begin tmp := sci [ 1 ] ;
54817: LD_ADDR_VAR 0 7
54821: PUSH
54822: LD_VAR 0 9
54826: PUSH
54827: LD_INT 1
54829: ARRAY
54830: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54831: LD_VAR 0 7
54835: PPUSH
54836: LD_INT 124
54838: PPUSH
54839: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54843: LD_ADDR_VAR 0 3
54847: PUSH
54848: DOUBLE
54849: LD_EXP 137
54853: PUSH
54854: LD_VAR 0 2
54858: ARRAY
54859: INC
54860: ST_TO_ADDR
54861: LD_EXP 137
54865: PUSH
54866: LD_VAR 0 2
54870: ARRAY
54871: PUSH
54872: FOR_DOWNTO
54873: IFFALSE 55216
// begin if IsInUnit ( tmp ) then
54875: LD_VAR 0 7
54879: PPUSH
54880: CALL_OW 310
54884: IFFALSE 54895
// ComExitBuilding ( tmp ) ;
54886: LD_VAR 0 7
54890: PPUSH
54891: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54895: LD_INT 35
54897: PPUSH
54898: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54902: LD_VAR 0 7
54906: PPUSH
54907: CALL_OW 310
54911: NOT
54912: PUSH
54913: LD_VAR 0 7
54917: PPUSH
54918: CALL_OW 314
54922: NOT
54923: AND
54924: IFFALSE 54895
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54926: LD_ADDR_VAR 0 6
54930: PUSH
54931: LD_VAR 0 7
54935: PPUSH
54936: CALL_OW 250
54940: PUSH
54941: LD_VAR 0 7
54945: PPUSH
54946: CALL_OW 251
54950: PUSH
54951: EMPTY
54952: LIST
54953: LIST
54954: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54955: LD_INT 35
54957: PPUSH
54958: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54962: LD_ADDR_VAR 0 4
54966: PUSH
54967: LD_EXP 137
54971: PUSH
54972: LD_VAR 0 2
54976: ARRAY
54977: PUSH
54978: LD_VAR 0 3
54982: ARRAY
54983: PUSH
54984: LD_INT 1
54986: ARRAY
54987: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54988: LD_ADDR_VAR 0 5
54992: PUSH
54993: LD_EXP 137
54997: PUSH
54998: LD_VAR 0 2
55002: ARRAY
55003: PUSH
55004: LD_VAR 0 3
55008: ARRAY
55009: PUSH
55010: LD_INT 2
55012: ARRAY
55013: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55014: LD_VAR 0 7
55018: PPUSH
55019: LD_INT 10
55021: PPUSH
55022: CALL 74612 0 2
55026: PUSH
55027: LD_INT 4
55029: ARRAY
55030: IFFALSE 55068
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55032: LD_VAR 0 7
55036: PPUSH
55037: LD_VAR 0 6
55041: PUSH
55042: LD_INT 1
55044: ARRAY
55045: PPUSH
55046: LD_VAR 0 6
55050: PUSH
55051: LD_INT 2
55053: ARRAY
55054: PPUSH
55055: CALL_OW 111
// wait ( 0 0$10 ) ;
55059: LD_INT 350
55061: PPUSH
55062: CALL_OW 67
// end else
55066: GO 55094
// begin ComMoveXY ( tmp , x , y ) ;
55068: LD_VAR 0 7
55072: PPUSH
55073: LD_VAR 0 4
55077: PPUSH
55078: LD_VAR 0 5
55082: PPUSH
55083: CALL_OW 111
// wait ( 0 0$3 ) ;
55087: LD_INT 105
55089: PPUSH
55090: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55094: LD_VAR 0 7
55098: PPUSH
55099: LD_VAR 0 4
55103: PPUSH
55104: LD_VAR 0 5
55108: PPUSH
55109: CALL_OW 307
55113: IFFALSE 54955
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55115: LD_VAR 0 7
55119: PPUSH
55120: LD_VAR 0 4
55124: PPUSH
55125: LD_VAR 0 5
55129: PPUSH
55130: LD_VAR 0 8
55134: PUSH
55135: LD_VAR 0 3
55139: ARRAY
55140: PPUSH
55141: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55145: LD_INT 35
55147: PPUSH
55148: CALL_OW 67
// until not HasTask ( tmp ) ;
55152: LD_VAR 0 7
55156: PPUSH
55157: CALL_OW 314
55161: NOT
55162: IFFALSE 55145
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55164: LD_ADDR_EXP 138
55168: PUSH
55169: LD_EXP 138
55173: PPUSH
55174: LD_VAR 0 2
55178: PUSH
55179: LD_EXP 138
55183: PUSH
55184: LD_VAR 0 2
55188: ARRAY
55189: PUSH
55190: LD_INT 1
55192: PLUS
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: PPUSH
55198: LD_VAR 0 8
55202: PUSH
55203: LD_VAR 0 3
55207: ARRAY
55208: PPUSH
55209: CALL 72019 0 3
55213: ST_TO_ADDR
// end ;
55214: GO 54872
55216: POP
55217: POP
// MC_Reset ( i , 124 ) ;
55218: LD_VAR 0 2
55222: PPUSH
55223: LD_INT 124
55225: PPUSH
55226: CALL 38821 0 2
// end ; end ;
55230: GO 54627
55232: POP
55233: POP
// end ;
55234: LD_VAR 0 1
55238: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55239: LD_INT 0
55241: PPUSH
55242: PPUSH
55243: PPUSH
// if not mc_bases then
55244: LD_EXP 102
55248: NOT
55249: IFFALSE 55253
// exit ;
55251: GO 55859
// for i = 1 to mc_bases do
55253: LD_ADDR_VAR 0 2
55257: PUSH
55258: DOUBLE
55259: LD_INT 1
55261: DEC
55262: ST_TO_ADDR
55263: LD_EXP 102
55267: PUSH
55268: FOR_TO
55269: IFFALSE 55857
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55271: LD_ADDR_VAR 0 3
55275: PUSH
55276: LD_EXP 102
55280: PUSH
55281: LD_VAR 0 2
55285: ARRAY
55286: PPUSH
55287: LD_INT 25
55289: PUSH
55290: LD_INT 4
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: PPUSH
55297: CALL_OW 72
55301: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55302: LD_VAR 0 3
55306: NOT
55307: PUSH
55308: LD_EXP 139
55312: PUSH
55313: LD_VAR 0 2
55317: ARRAY
55318: NOT
55319: OR
55320: PUSH
55321: LD_EXP 102
55325: PUSH
55326: LD_VAR 0 2
55330: ARRAY
55331: PPUSH
55332: LD_INT 2
55334: PUSH
55335: LD_INT 30
55337: PUSH
55338: LD_INT 0
55340: PUSH
55341: EMPTY
55342: LIST
55343: LIST
55344: PUSH
55345: LD_INT 30
55347: PUSH
55348: LD_INT 1
55350: PUSH
55351: EMPTY
55352: LIST
55353: LIST
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: LIST
55359: PPUSH
55360: CALL_OW 72
55364: NOT
55365: OR
55366: IFFALSE 55416
// begin if mc_deposits_finder [ i ] then
55368: LD_EXP 140
55372: PUSH
55373: LD_VAR 0 2
55377: ARRAY
55378: IFFALSE 55414
// begin MC_Reset ( i , 125 ) ;
55380: LD_VAR 0 2
55384: PPUSH
55385: LD_INT 125
55387: PPUSH
55388: CALL 38821 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55392: LD_ADDR_EXP 140
55396: PUSH
55397: LD_EXP 140
55401: PPUSH
55402: LD_VAR 0 2
55406: PPUSH
55407: EMPTY
55408: PPUSH
55409: CALL_OW 1
55413: ST_TO_ADDR
// end ; continue ;
55414: GO 55268
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55416: LD_EXP 139
55420: PUSH
55421: LD_VAR 0 2
55425: ARRAY
55426: PUSH
55427: LD_INT 1
55429: ARRAY
55430: PUSH
55431: LD_INT 3
55433: ARRAY
55434: PUSH
55435: LD_INT 1
55437: EQUAL
55438: PUSH
55439: LD_INT 20
55441: PPUSH
55442: LD_EXP 128
55446: PUSH
55447: LD_VAR 0 2
55451: ARRAY
55452: PPUSH
55453: CALL_OW 321
55457: PUSH
55458: LD_INT 2
55460: NONEQUAL
55461: AND
55462: IFFALSE 55512
// begin if mc_deposits_finder [ i ] then
55464: LD_EXP 140
55468: PUSH
55469: LD_VAR 0 2
55473: ARRAY
55474: IFFALSE 55510
// begin MC_Reset ( i , 125 ) ;
55476: LD_VAR 0 2
55480: PPUSH
55481: LD_INT 125
55483: PPUSH
55484: CALL 38821 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55488: LD_ADDR_EXP 140
55492: PUSH
55493: LD_EXP 140
55497: PPUSH
55498: LD_VAR 0 2
55502: PPUSH
55503: EMPTY
55504: PPUSH
55505: CALL_OW 1
55509: ST_TO_ADDR
// end ; continue ;
55510: GO 55268
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55512: LD_EXP 139
55516: PUSH
55517: LD_VAR 0 2
55521: ARRAY
55522: PUSH
55523: LD_INT 1
55525: ARRAY
55526: PUSH
55527: LD_INT 1
55529: ARRAY
55530: PPUSH
55531: LD_EXP 139
55535: PUSH
55536: LD_VAR 0 2
55540: ARRAY
55541: PUSH
55542: LD_INT 1
55544: ARRAY
55545: PUSH
55546: LD_INT 2
55548: ARRAY
55549: PPUSH
55550: LD_EXP 128
55554: PUSH
55555: LD_VAR 0 2
55559: ARRAY
55560: PPUSH
55561: CALL_OW 440
55565: IFFALSE 55608
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55567: LD_ADDR_EXP 139
55571: PUSH
55572: LD_EXP 139
55576: PPUSH
55577: LD_VAR 0 2
55581: PPUSH
55582: LD_EXP 139
55586: PUSH
55587: LD_VAR 0 2
55591: ARRAY
55592: PPUSH
55593: LD_INT 1
55595: PPUSH
55596: CALL_OW 3
55600: PPUSH
55601: CALL_OW 1
55605: ST_TO_ADDR
55606: GO 55855
// begin if not mc_deposits_finder [ i ] then
55608: LD_EXP 140
55612: PUSH
55613: LD_VAR 0 2
55617: ARRAY
55618: NOT
55619: IFFALSE 55671
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55621: LD_ADDR_EXP 140
55625: PUSH
55626: LD_EXP 140
55630: PPUSH
55631: LD_VAR 0 2
55635: PPUSH
55636: LD_VAR 0 3
55640: PUSH
55641: LD_INT 1
55643: ARRAY
55644: PUSH
55645: EMPTY
55646: LIST
55647: PPUSH
55648: CALL_OW 1
55652: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55653: LD_VAR 0 3
55657: PUSH
55658: LD_INT 1
55660: ARRAY
55661: PPUSH
55662: LD_INT 125
55664: PPUSH
55665: CALL_OW 109
// end else
55669: GO 55855
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55671: LD_EXP 140
55675: PUSH
55676: LD_VAR 0 2
55680: ARRAY
55681: PUSH
55682: LD_INT 1
55684: ARRAY
55685: PPUSH
55686: CALL_OW 310
55690: IFFALSE 55713
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55692: LD_EXP 140
55696: PUSH
55697: LD_VAR 0 2
55701: ARRAY
55702: PUSH
55703: LD_INT 1
55705: ARRAY
55706: PPUSH
55707: CALL_OW 122
55711: GO 55855
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55713: LD_EXP 140
55717: PUSH
55718: LD_VAR 0 2
55722: ARRAY
55723: PUSH
55724: LD_INT 1
55726: ARRAY
55727: PPUSH
55728: CALL_OW 314
55732: NOT
55733: PUSH
55734: LD_EXP 140
55738: PUSH
55739: LD_VAR 0 2
55743: ARRAY
55744: PUSH
55745: LD_INT 1
55747: ARRAY
55748: PPUSH
55749: LD_EXP 139
55753: PUSH
55754: LD_VAR 0 2
55758: ARRAY
55759: PUSH
55760: LD_INT 1
55762: ARRAY
55763: PUSH
55764: LD_INT 1
55766: ARRAY
55767: PPUSH
55768: LD_EXP 139
55772: PUSH
55773: LD_VAR 0 2
55777: ARRAY
55778: PUSH
55779: LD_INT 1
55781: ARRAY
55782: PUSH
55783: LD_INT 2
55785: ARRAY
55786: PPUSH
55787: CALL_OW 297
55791: PUSH
55792: LD_INT 6
55794: GREATER
55795: AND
55796: IFFALSE 55855
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55798: LD_EXP 140
55802: PUSH
55803: LD_VAR 0 2
55807: ARRAY
55808: PUSH
55809: LD_INT 1
55811: ARRAY
55812: PPUSH
55813: LD_EXP 139
55817: PUSH
55818: LD_VAR 0 2
55822: ARRAY
55823: PUSH
55824: LD_INT 1
55826: ARRAY
55827: PUSH
55828: LD_INT 1
55830: ARRAY
55831: PPUSH
55832: LD_EXP 139
55836: PUSH
55837: LD_VAR 0 2
55841: ARRAY
55842: PUSH
55843: LD_INT 1
55845: ARRAY
55846: PUSH
55847: LD_INT 2
55849: ARRAY
55850: PPUSH
55851: CALL_OW 111
// end ; end ; end ;
55855: GO 55268
55857: POP
55858: POP
// end ;
55859: LD_VAR 0 1
55863: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55864: LD_INT 0
55866: PPUSH
55867: PPUSH
55868: PPUSH
55869: PPUSH
55870: PPUSH
55871: PPUSH
55872: PPUSH
55873: PPUSH
55874: PPUSH
55875: PPUSH
55876: PPUSH
// if not mc_bases then
55877: LD_EXP 102
55881: NOT
55882: IFFALSE 55886
// exit ;
55884: GO 56826
// for i = 1 to mc_bases do
55886: LD_ADDR_VAR 0 2
55890: PUSH
55891: DOUBLE
55892: LD_INT 1
55894: DEC
55895: ST_TO_ADDR
55896: LD_EXP 102
55900: PUSH
55901: FOR_TO
55902: IFFALSE 56824
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55904: LD_EXP 102
55908: PUSH
55909: LD_VAR 0 2
55913: ARRAY
55914: NOT
55915: PUSH
55916: LD_EXP 125
55920: PUSH
55921: LD_VAR 0 2
55925: ARRAY
55926: OR
55927: IFFALSE 55931
// continue ;
55929: GO 55901
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55931: LD_ADDR_VAR 0 7
55935: PUSH
55936: LD_EXP 102
55940: PUSH
55941: LD_VAR 0 2
55945: ARRAY
55946: PUSH
55947: LD_INT 1
55949: ARRAY
55950: PPUSH
55951: CALL_OW 248
55955: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55956: LD_VAR 0 7
55960: PUSH
55961: LD_INT 3
55963: EQUAL
55964: PUSH
55965: LD_EXP 121
55969: PUSH
55970: LD_VAR 0 2
55974: ARRAY
55975: PUSH
55976: LD_EXP 124
55980: PUSH
55981: LD_VAR 0 2
55985: ARRAY
55986: UNION
55987: PPUSH
55988: LD_INT 33
55990: PUSH
55991: LD_INT 2
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: PPUSH
55998: CALL_OW 72
56002: NOT
56003: OR
56004: IFFALSE 56008
// continue ;
56006: GO 55901
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56008: LD_ADDR_VAR 0 9
56012: PUSH
56013: LD_EXP 102
56017: PUSH
56018: LD_VAR 0 2
56022: ARRAY
56023: PPUSH
56024: LD_INT 30
56026: PUSH
56027: LD_INT 36
56029: PUSH
56030: EMPTY
56031: LIST
56032: LIST
56033: PPUSH
56034: CALL_OW 72
56038: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56039: LD_ADDR_VAR 0 10
56043: PUSH
56044: LD_EXP 121
56048: PUSH
56049: LD_VAR 0 2
56053: ARRAY
56054: PPUSH
56055: LD_INT 34
56057: PUSH
56058: LD_INT 31
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: PPUSH
56065: CALL_OW 72
56069: ST_TO_ADDR
// if not cts and not mcts then
56070: LD_VAR 0 9
56074: NOT
56075: PUSH
56076: LD_VAR 0 10
56080: NOT
56081: AND
56082: IFFALSE 56086
// continue ;
56084: GO 55901
// x := cts ;
56086: LD_ADDR_VAR 0 11
56090: PUSH
56091: LD_VAR 0 9
56095: ST_TO_ADDR
// if not x then
56096: LD_VAR 0 11
56100: NOT
56101: IFFALSE 56113
// x := mcts ;
56103: LD_ADDR_VAR 0 11
56107: PUSH
56108: LD_VAR 0 10
56112: ST_TO_ADDR
// if not x then
56113: LD_VAR 0 11
56117: NOT
56118: IFFALSE 56122
// continue ;
56120: GO 55901
// if mc_remote_driver [ i ] then
56122: LD_EXP 142
56126: PUSH
56127: LD_VAR 0 2
56131: ARRAY
56132: IFFALSE 56519
// for j in mc_remote_driver [ i ] do
56134: LD_ADDR_VAR 0 3
56138: PUSH
56139: LD_EXP 142
56143: PUSH
56144: LD_VAR 0 2
56148: ARRAY
56149: PUSH
56150: FOR_IN
56151: IFFALSE 56517
// begin if GetClass ( j ) <> 3 then
56153: LD_VAR 0 3
56157: PPUSH
56158: CALL_OW 257
56162: PUSH
56163: LD_INT 3
56165: NONEQUAL
56166: IFFALSE 56219
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56168: LD_ADDR_EXP 142
56172: PUSH
56173: LD_EXP 142
56177: PPUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: LD_EXP 142
56187: PUSH
56188: LD_VAR 0 2
56192: ARRAY
56193: PUSH
56194: LD_VAR 0 3
56198: DIFF
56199: PPUSH
56200: CALL_OW 1
56204: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56205: LD_VAR 0 3
56209: PPUSH
56210: LD_INT 0
56212: PPUSH
56213: CALL_OW 109
// continue ;
56217: GO 56150
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56219: LD_EXP 121
56223: PUSH
56224: LD_VAR 0 2
56228: ARRAY
56229: PPUSH
56230: LD_INT 34
56232: PUSH
56233: LD_INT 31
56235: PUSH
56236: EMPTY
56237: LIST
56238: LIST
56239: PUSH
56240: LD_INT 58
56242: PUSH
56243: EMPTY
56244: LIST
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: PPUSH
56250: CALL_OW 72
56254: PUSH
56255: LD_VAR 0 3
56259: PPUSH
56260: CALL 105377 0 1
56264: NOT
56265: AND
56266: IFFALSE 56337
// begin if IsInUnit ( j ) then
56268: LD_VAR 0 3
56272: PPUSH
56273: CALL_OW 310
56277: IFFALSE 56288
// ComExitBuilding ( j ) ;
56279: LD_VAR 0 3
56283: PPUSH
56284: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56288: LD_VAR 0 3
56292: PPUSH
56293: LD_EXP 121
56297: PUSH
56298: LD_VAR 0 2
56302: ARRAY
56303: PPUSH
56304: LD_INT 34
56306: PUSH
56307: LD_INT 31
56309: PUSH
56310: EMPTY
56311: LIST
56312: LIST
56313: PUSH
56314: LD_INT 58
56316: PUSH
56317: EMPTY
56318: LIST
56319: PUSH
56320: EMPTY
56321: LIST
56322: LIST
56323: PPUSH
56324: CALL_OW 72
56328: PUSH
56329: LD_INT 1
56331: ARRAY
56332: PPUSH
56333: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56337: LD_VAR 0 3
56341: PPUSH
56342: CALL_OW 310
56346: NOT
56347: PUSH
56348: LD_VAR 0 3
56352: PPUSH
56353: CALL_OW 310
56357: PPUSH
56358: CALL_OW 266
56362: PUSH
56363: LD_INT 36
56365: NONEQUAL
56366: PUSH
56367: LD_VAR 0 3
56371: PPUSH
56372: CALL 105377 0 1
56376: NOT
56377: AND
56378: OR
56379: IFFALSE 56515
// begin if IsInUnit ( j ) then
56381: LD_VAR 0 3
56385: PPUSH
56386: CALL_OW 310
56390: IFFALSE 56401
// ComExitBuilding ( j ) ;
56392: LD_VAR 0 3
56396: PPUSH
56397: CALL_OW 122
// ct := 0 ;
56401: LD_ADDR_VAR 0 8
56405: PUSH
56406: LD_INT 0
56408: ST_TO_ADDR
// for k in x do
56409: LD_ADDR_VAR 0 4
56413: PUSH
56414: LD_VAR 0 11
56418: PUSH
56419: FOR_IN
56420: IFFALSE 56493
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56422: LD_VAR 0 4
56426: PPUSH
56427: CALL_OW 264
56431: PUSH
56432: LD_INT 31
56434: EQUAL
56435: PUSH
56436: LD_VAR 0 4
56440: PPUSH
56441: CALL_OW 311
56445: NOT
56446: AND
56447: PUSH
56448: LD_VAR 0 4
56452: PPUSH
56453: CALL_OW 266
56457: PUSH
56458: LD_INT 36
56460: EQUAL
56461: PUSH
56462: LD_VAR 0 4
56466: PPUSH
56467: CALL_OW 313
56471: PUSH
56472: LD_INT 3
56474: LESS
56475: AND
56476: OR
56477: IFFALSE 56491
// begin ct := k ;
56479: LD_ADDR_VAR 0 8
56483: PUSH
56484: LD_VAR 0 4
56488: ST_TO_ADDR
// break ;
56489: GO 56493
// end ;
56491: GO 56419
56493: POP
56494: POP
// if ct then
56495: LD_VAR 0 8
56499: IFFALSE 56515
// ComEnterUnit ( j , ct ) ;
56501: LD_VAR 0 3
56505: PPUSH
56506: LD_VAR 0 8
56510: PPUSH
56511: CALL_OW 120
// end ; end ;
56515: GO 56150
56517: POP
56518: POP
// places := 0 ;
56519: LD_ADDR_VAR 0 5
56523: PUSH
56524: LD_INT 0
56526: ST_TO_ADDR
// for j = 1 to x do
56527: LD_ADDR_VAR 0 3
56531: PUSH
56532: DOUBLE
56533: LD_INT 1
56535: DEC
56536: ST_TO_ADDR
56537: LD_VAR 0 11
56541: PUSH
56542: FOR_TO
56543: IFFALSE 56619
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56545: LD_VAR 0 11
56549: PUSH
56550: LD_VAR 0 3
56554: ARRAY
56555: PPUSH
56556: CALL_OW 264
56560: PUSH
56561: LD_INT 31
56563: EQUAL
56564: IFFALSE 56582
// places := places + 1 else
56566: LD_ADDR_VAR 0 5
56570: PUSH
56571: LD_VAR 0 5
56575: PUSH
56576: LD_INT 1
56578: PLUS
56579: ST_TO_ADDR
56580: GO 56617
// if GetBType ( x [ j ] ) = b_control_tower then
56582: LD_VAR 0 11
56586: PUSH
56587: LD_VAR 0 3
56591: ARRAY
56592: PPUSH
56593: CALL_OW 266
56597: PUSH
56598: LD_INT 36
56600: EQUAL
56601: IFFALSE 56617
// places := places + 3 ;
56603: LD_ADDR_VAR 0 5
56607: PUSH
56608: LD_VAR 0 5
56612: PUSH
56613: LD_INT 3
56615: PLUS
56616: ST_TO_ADDR
56617: GO 56542
56619: POP
56620: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56621: LD_VAR 0 5
56625: PUSH
56626: LD_INT 0
56628: EQUAL
56629: PUSH
56630: LD_VAR 0 5
56634: PUSH
56635: LD_EXP 142
56639: PUSH
56640: LD_VAR 0 2
56644: ARRAY
56645: LESSEQUAL
56646: OR
56647: IFFALSE 56651
// continue ;
56649: GO 55901
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56651: LD_ADDR_VAR 0 6
56655: PUSH
56656: LD_EXP 102
56660: PUSH
56661: LD_VAR 0 2
56665: ARRAY
56666: PPUSH
56667: LD_INT 25
56669: PUSH
56670: LD_INT 3
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: PPUSH
56677: CALL_OW 72
56681: PUSH
56682: LD_EXP 142
56686: PUSH
56687: LD_VAR 0 2
56691: ARRAY
56692: DIFF
56693: PPUSH
56694: LD_INT 3
56696: PPUSH
56697: CALL 106277 0 2
56701: ST_TO_ADDR
// for j in tmp do
56702: LD_ADDR_VAR 0 3
56706: PUSH
56707: LD_VAR 0 6
56711: PUSH
56712: FOR_IN
56713: IFFALSE 56748
// if GetTag ( j ) > 0 then
56715: LD_VAR 0 3
56719: PPUSH
56720: CALL_OW 110
56724: PUSH
56725: LD_INT 0
56727: GREATER
56728: IFFALSE 56746
// tmp := tmp diff j ;
56730: LD_ADDR_VAR 0 6
56734: PUSH
56735: LD_VAR 0 6
56739: PUSH
56740: LD_VAR 0 3
56744: DIFF
56745: ST_TO_ADDR
56746: GO 56712
56748: POP
56749: POP
// if not tmp then
56750: LD_VAR 0 6
56754: NOT
56755: IFFALSE 56759
// continue ;
56757: GO 55901
// if places then
56759: LD_VAR 0 5
56763: IFFALSE 56822
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56765: LD_ADDR_EXP 142
56769: PUSH
56770: LD_EXP 142
56774: PPUSH
56775: LD_VAR 0 2
56779: PPUSH
56780: LD_EXP 142
56784: PUSH
56785: LD_VAR 0 2
56789: ARRAY
56790: PUSH
56791: LD_VAR 0 6
56795: PUSH
56796: LD_INT 1
56798: ARRAY
56799: UNION
56800: PPUSH
56801: CALL_OW 1
56805: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56806: LD_VAR 0 6
56810: PUSH
56811: LD_INT 1
56813: ARRAY
56814: PPUSH
56815: LD_INT 126
56817: PPUSH
56818: CALL_OW 109
// end ; end ;
56822: GO 55901
56824: POP
56825: POP
// end ;
56826: LD_VAR 0 1
56830: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56831: LD_INT 0
56833: PPUSH
56834: PPUSH
56835: PPUSH
56836: PPUSH
56837: PPUSH
56838: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56839: LD_VAR 0 1
56843: NOT
56844: PUSH
56845: LD_VAR 0 2
56849: NOT
56850: OR
56851: PUSH
56852: LD_VAR 0 3
56856: NOT
56857: OR
56858: PUSH
56859: LD_VAR 0 4
56863: PUSH
56864: LD_INT 1
56866: PUSH
56867: LD_INT 2
56869: PUSH
56870: LD_INT 3
56872: PUSH
56873: LD_INT 4
56875: PUSH
56876: LD_INT 5
56878: PUSH
56879: LD_INT 8
56881: PUSH
56882: LD_INT 9
56884: PUSH
56885: LD_INT 15
56887: PUSH
56888: LD_INT 16
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: IN
56902: NOT
56903: OR
56904: IFFALSE 56908
// exit ;
56906: GO 57808
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56908: LD_ADDR_VAR 0 2
56912: PUSH
56913: LD_VAR 0 2
56917: PPUSH
56918: LD_INT 21
56920: PUSH
56921: LD_INT 3
56923: PUSH
56924: EMPTY
56925: LIST
56926: LIST
56927: PUSH
56928: LD_INT 24
56930: PUSH
56931: LD_INT 250
56933: PUSH
56934: EMPTY
56935: LIST
56936: LIST
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: PPUSH
56942: CALL_OW 72
56946: ST_TO_ADDR
// case class of 1 , 15 :
56947: LD_VAR 0 4
56951: PUSH
56952: LD_INT 1
56954: DOUBLE
56955: EQUAL
56956: IFTRUE 56966
56958: LD_INT 15
56960: DOUBLE
56961: EQUAL
56962: IFTRUE 56966
56964: GO 57051
56966: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56967: LD_ADDR_VAR 0 8
56971: PUSH
56972: LD_VAR 0 2
56976: PPUSH
56977: LD_INT 2
56979: PUSH
56980: LD_INT 30
56982: PUSH
56983: LD_INT 32
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: LD_INT 30
56992: PUSH
56993: LD_INT 31
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: LIST
57004: PPUSH
57005: CALL_OW 72
57009: PUSH
57010: LD_VAR 0 2
57014: PPUSH
57015: LD_INT 2
57017: PUSH
57018: LD_INT 30
57020: PUSH
57021: LD_INT 4
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PUSH
57028: LD_INT 30
57030: PUSH
57031: LD_INT 5
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: PUSH
57038: EMPTY
57039: LIST
57040: LIST
57041: LIST
57042: PPUSH
57043: CALL_OW 72
57047: ADD
57048: ST_TO_ADDR
57049: GO 57297
57051: LD_INT 2
57053: DOUBLE
57054: EQUAL
57055: IFTRUE 57065
57057: LD_INT 16
57059: DOUBLE
57060: EQUAL
57061: IFTRUE 57065
57063: GO 57111
57065: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57066: LD_ADDR_VAR 0 8
57070: PUSH
57071: LD_VAR 0 2
57075: PPUSH
57076: LD_INT 2
57078: PUSH
57079: LD_INT 30
57081: PUSH
57082: LD_INT 0
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: PUSH
57089: LD_INT 30
57091: PUSH
57092: LD_INT 1
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: PUSH
57099: EMPTY
57100: LIST
57101: LIST
57102: LIST
57103: PPUSH
57104: CALL_OW 72
57108: ST_TO_ADDR
57109: GO 57297
57111: LD_INT 3
57113: DOUBLE
57114: EQUAL
57115: IFTRUE 57119
57117: GO 57165
57119: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57120: LD_ADDR_VAR 0 8
57124: PUSH
57125: LD_VAR 0 2
57129: PPUSH
57130: LD_INT 2
57132: PUSH
57133: LD_INT 30
57135: PUSH
57136: LD_INT 2
57138: PUSH
57139: EMPTY
57140: LIST
57141: LIST
57142: PUSH
57143: LD_INT 30
57145: PUSH
57146: LD_INT 3
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: LIST
57157: PPUSH
57158: CALL_OW 72
57162: ST_TO_ADDR
57163: GO 57297
57165: LD_INT 4
57167: DOUBLE
57168: EQUAL
57169: IFTRUE 57173
57171: GO 57230
57173: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57174: LD_ADDR_VAR 0 8
57178: PUSH
57179: LD_VAR 0 2
57183: PPUSH
57184: LD_INT 2
57186: PUSH
57187: LD_INT 30
57189: PUSH
57190: LD_INT 6
57192: PUSH
57193: EMPTY
57194: LIST
57195: LIST
57196: PUSH
57197: LD_INT 30
57199: PUSH
57200: LD_INT 7
57202: PUSH
57203: EMPTY
57204: LIST
57205: LIST
57206: PUSH
57207: LD_INT 30
57209: PUSH
57210: LD_INT 8
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: PUSH
57217: EMPTY
57218: LIST
57219: LIST
57220: LIST
57221: LIST
57222: PPUSH
57223: CALL_OW 72
57227: ST_TO_ADDR
57228: GO 57297
57230: LD_INT 5
57232: DOUBLE
57233: EQUAL
57234: IFTRUE 57250
57236: LD_INT 8
57238: DOUBLE
57239: EQUAL
57240: IFTRUE 57250
57242: LD_INT 9
57244: DOUBLE
57245: EQUAL
57246: IFTRUE 57250
57248: GO 57296
57250: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57251: LD_ADDR_VAR 0 8
57255: PUSH
57256: LD_VAR 0 2
57260: PPUSH
57261: LD_INT 2
57263: PUSH
57264: LD_INT 30
57266: PUSH
57267: LD_INT 4
57269: PUSH
57270: EMPTY
57271: LIST
57272: LIST
57273: PUSH
57274: LD_INT 30
57276: PUSH
57277: LD_INT 5
57279: PUSH
57280: EMPTY
57281: LIST
57282: LIST
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: LIST
57288: PPUSH
57289: CALL_OW 72
57293: ST_TO_ADDR
57294: GO 57297
57296: POP
// if not tmp then
57297: LD_VAR 0 8
57301: NOT
57302: IFFALSE 57306
// exit ;
57304: GO 57808
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57306: LD_VAR 0 4
57310: PUSH
57311: LD_INT 1
57313: PUSH
57314: LD_INT 15
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: IN
57321: PUSH
57322: LD_EXP 111
57326: PUSH
57327: LD_VAR 0 1
57331: ARRAY
57332: AND
57333: IFFALSE 57489
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57335: LD_ADDR_VAR 0 9
57339: PUSH
57340: LD_EXP 111
57344: PUSH
57345: LD_VAR 0 1
57349: ARRAY
57350: PUSH
57351: LD_INT 1
57353: ARRAY
57354: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57355: LD_VAR 0 9
57359: PUSH
57360: LD_EXP 112
57364: PUSH
57365: LD_VAR 0 1
57369: ARRAY
57370: IN
57371: NOT
57372: IFFALSE 57487
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57374: LD_ADDR_EXP 112
57378: PUSH
57379: LD_EXP 112
57383: PPUSH
57384: LD_VAR 0 1
57388: PUSH
57389: LD_EXP 112
57393: PUSH
57394: LD_VAR 0 1
57398: ARRAY
57399: PUSH
57400: LD_INT 1
57402: PLUS
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: PPUSH
57408: LD_VAR 0 9
57412: PPUSH
57413: CALL 72019 0 3
57417: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57418: LD_ADDR_EXP 111
57422: PUSH
57423: LD_EXP 111
57427: PPUSH
57428: LD_VAR 0 1
57432: PPUSH
57433: LD_EXP 111
57437: PUSH
57438: LD_VAR 0 1
57442: ARRAY
57443: PUSH
57444: LD_VAR 0 9
57448: DIFF
57449: PPUSH
57450: CALL_OW 1
57454: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57455: LD_VAR 0 3
57459: PPUSH
57460: LD_EXP 112
57464: PUSH
57465: LD_VAR 0 1
57469: ARRAY
57470: PUSH
57471: LD_EXP 112
57475: PUSH
57476: LD_VAR 0 1
57480: ARRAY
57481: ARRAY
57482: PPUSH
57483: CALL_OW 120
// end ; exit ;
57487: GO 57808
// end ; if tmp > 1 then
57489: LD_VAR 0 8
57493: PUSH
57494: LD_INT 1
57496: GREATER
57497: IFFALSE 57601
// for i = 2 to tmp do
57499: LD_ADDR_VAR 0 6
57503: PUSH
57504: DOUBLE
57505: LD_INT 2
57507: DEC
57508: ST_TO_ADDR
57509: LD_VAR 0 8
57513: PUSH
57514: FOR_TO
57515: IFFALSE 57599
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57517: LD_VAR 0 8
57521: PUSH
57522: LD_VAR 0 6
57526: ARRAY
57527: PPUSH
57528: CALL_OW 461
57532: PUSH
57533: LD_INT 6
57535: EQUAL
57536: IFFALSE 57597
// begin x := tmp [ i ] ;
57538: LD_ADDR_VAR 0 9
57542: PUSH
57543: LD_VAR 0 8
57547: PUSH
57548: LD_VAR 0 6
57552: ARRAY
57553: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57554: LD_ADDR_VAR 0 8
57558: PUSH
57559: LD_VAR 0 8
57563: PPUSH
57564: LD_VAR 0 6
57568: PPUSH
57569: CALL_OW 3
57573: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57574: LD_ADDR_VAR 0 8
57578: PUSH
57579: LD_VAR 0 8
57583: PPUSH
57584: LD_INT 1
57586: PPUSH
57587: LD_VAR 0 9
57591: PPUSH
57592: CALL_OW 2
57596: ST_TO_ADDR
// end ;
57597: GO 57514
57599: POP
57600: POP
// for i in tmp do
57601: LD_ADDR_VAR 0 6
57605: PUSH
57606: LD_VAR 0 8
57610: PUSH
57611: FOR_IN
57612: IFFALSE 57681
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57614: LD_VAR 0 6
57618: PPUSH
57619: CALL_OW 313
57623: PUSH
57624: LD_INT 6
57626: LESS
57627: PUSH
57628: LD_VAR 0 6
57632: PPUSH
57633: CALL_OW 266
57637: PUSH
57638: LD_INT 31
57640: PUSH
57641: LD_INT 32
57643: PUSH
57644: EMPTY
57645: LIST
57646: LIST
57647: IN
57648: NOT
57649: AND
57650: PUSH
57651: LD_VAR 0 6
57655: PPUSH
57656: CALL_OW 313
57660: PUSH
57661: LD_INT 0
57663: EQUAL
57664: OR
57665: IFFALSE 57679
// begin j := i ;
57667: LD_ADDR_VAR 0 7
57671: PUSH
57672: LD_VAR 0 6
57676: ST_TO_ADDR
// break ;
57677: GO 57681
// end ; end ;
57679: GO 57611
57681: POP
57682: POP
// if j then
57683: LD_VAR 0 7
57687: IFFALSE 57705
// ComEnterUnit ( unit , j ) else
57689: LD_VAR 0 3
57693: PPUSH
57694: LD_VAR 0 7
57698: PPUSH
57699: CALL_OW 120
57703: GO 57808
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57705: LD_ADDR_VAR 0 10
57709: PUSH
57710: LD_VAR 0 2
57714: PPUSH
57715: LD_INT 2
57717: PUSH
57718: LD_INT 30
57720: PUSH
57721: LD_INT 0
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: PUSH
57728: LD_INT 30
57730: PUSH
57731: LD_INT 1
57733: PUSH
57734: EMPTY
57735: LIST
57736: LIST
57737: PUSH
57738: EMPTY
57739: LIST
57740: LIST
57741: LIST
57742: PPUSH
57743: CALL_OW 72
57747: ST_TO_ADDR
// if depot then
57748: LD_VAR 0 10
57752: IFFALSE 57808
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57754: LD_ADDR_VAR 0 10
57758: PUSH
57759: LD_VAR 0 10
57763: PPUSH
57764: LD_VAR 0 3
57768: PPUSH
57769: CALL_OW 74
57773: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57774: LD_VAR 0 3
57778: PPUSH
57779: LD_VAR 0 10
57783: PPUSH
57784: CALL_OW 296
57788: PUSH
57789: LD_INT 10
57791: GREATER
57792: IFFALSE 57808
// ComStandNearbyBuilding ( unit , depot ) ;
57794: LD_VAR 0 3
57798: PPUSH
57799: LD_VAR 0 10
57803: PPUSH
57804: CALL 66222 0 2
// end ; end ; end ;
57808: LD_VAR 0 5
57812: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57813: LD_INT 0
57815: PPUSH
57816: PPUSH
57817: PPUSH
57818: PPUSH
// if not mc_bases then
57819: LD_EXP 102
57823: NOT
57824: IFFALSE 57828
// exit ;
57826: GO 58067
// for i = 1 to mc_bases do
57828: LD_ADDR_VAR 0 2
57832: PUSH
57833: DOUBLE
57834: LD_INT 1
57836: DEC
57837: ST_TO_ADDR
57838: LD_EXP 102
57842: PUSH
57843: FOR_TO
57844: IFFALSE 58065
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57846: LD_ADDR_VAR 0 4
57850: PUSH
57851: LD_EXP 102
57855: PUSH
57856: LD_VAR 0 2
57860: ARRAY
57861: PPUSH
57862: LD_INT 21
57864: PUSH
57865: LD_INT 1
57867: PUSH
57868: EMPTY
57869: LIST
57870: LIST
57871: PPUSH
57872: CALL_OW 72
57876: PUSH
57877: LD_EXP 131
57881: PUSH
57882: LD_VAR 0 2
57886: ARRAY
57887: UNION
57888: ST_TO_ADDR
// if not tmp then
57889: LD_VAR 0 4
57893: NOT
57894: IFFALSE 57898
// continue ;
57896: GO 57843
// for j in tmp do
57898: LD_ADDR_VAR 0 3
57902: PUSH
57903: LD_VAR 0 4
57907: PUSH
57908: FOR_IN
57909: IFFALSE 58061
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57911: LD_VAR 0 3
57915: PPUSH
57916: CALL_OW 110
57920: NOT
57921: PUSH
57922: LD_VAR 0 3
57926: PPUSH
57927: CALL_OW 314
57931: NOT
57932: AND
57933: PUSH
57934: LD_VAR 0 3
57938: PPUSH
57939: CALL_OW 311
57943: NOT
57944: AND
57945: PUSH
57946: LD_VAR 0 3
57950: PPUSH
57951: CALL_OW 310
57955: NOT
57956: AND
57957: PUSH
57958: LD_VAR 0 3
57962: PUSH
57963: LD_EXP 105
57967: PUSH
57968: LD_VAR 0 2
57972: ARRAY
57973: PUSH
57974: LD_INT 1
57976: ARRAY
57977: IN
57978: NOT
57979: AND
57980: PUSH
57981: LD_VAR 0 3
57985: PUSH
57986: LD_EXP 105
57990: PUSH
57991: LD_VAR 0 2
57995: ARRAY
57996: PUSH
57997: LD_INT 2
57999: ARRAY
58000: IN
58001: NOT
58002: AND
58003: PUSH
58004: LD_VAR 0 3
58008: PUSH
58009: LD_EXP 114
58013: PUSH
58014: LD_VAR 0 2
58018: ARRAY
58019: IN
58020: NOT
58021: AND
58022: IFFALSE 58059
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58024: LD_VAR 0 2
58028: PPUSH
58029: LD_EXP 102
58033: PUSH
58034: LD_VAR 0 2
58038: ARRAY
58039: PPUSH
58040: LD_VAR 0 3
58044: PPUSH
58045: LD_VAR 0 3
58049: PPUSH
58050: CALL_OW 257
58054: PPUSH
58055: CALL 56831 0 4
// end ;
58059: GO 57908
58061: POP
58062: POP
// end ;
58063: GO 57843
58065: POP
58066: POP
// end ;
58067: LD_VAR 0 1
58071: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58072: LD_INT 0
58074: PPUSH
58075: PPUSH
58076: PPUSH
58077: PPUSH
58078: PPUSH
58079: PPUSH
// if not mc_bases [ base ] then
58080: LD_EXP 102
58084: PUSH
58085: LD_VAR 0 1
58089: ARRAY
58090: NOT
58091: IFFALSE 58095
// exit ;
58093: GO 58277
// tmp := [ ] ;
58095: LD_ADDR_VAR 0 6
58099: PUSH
58100: EMPTY
58101: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58102: LD_ADDR_VAR 0 7
58106: PUSH
58107: LD_VAR 0 3
58111: PPUSH
58112: LD_INT 0
58114: PPUSH
58115: CALL_OW 517
58119: ST_TO_ADDR
// if not list then
58120: LD_VAR 0 7
58124: NOT
58125: IFFALSE 58129
// exit ;
58127: GO 58277
// for i = 1 to amount do
58129: LD_ADDR_VAR 0 5
58133: PUSH
58134: DOUBLE
58135: LD_INT 1
58137: DEC
58138: ST_TO_ADDR
58139: LD_VAR 0 2
58143: PUSH
58144: FOR_TO
58145: IFFALSE 58225
// begin x := rand ( 1 , list [ 1 ] ) ;
58147: LD_ADDR_VAR 0 8
58151: PUSH
58152: LD_INT 1
58154: PPUSH
58155: LD_VAR 0 7
58159: PUSH
58160: LD_INT 1
58162: ARRAY
58163: PPUSH
58164: CALL_OW 12
58168: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58169: LD_ADDR_VAR 0 6
58173: PUSH
58174: LD_VAR 0 6
58178: PPUSH
58179: LD_VAR 0 5
58183: PPUSH
58184: LD_VAR 0 7
58188: PUSH
58189: LD_INT 1
58191: ARRAY
58192: PUSH
58193: LD_VAR 0 8
58197: ARRAY
58198: PUSH
58199: LD_VAR 0 7
58203: PUSH
58204: LD_INT 2
58206: ARRAY
58207: PUSH
58208: LD_VAR 0 8
58212: ARRAY
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: PPUSH
58218: CALL_OW 1
58222: ST_TO_ADDR
// end ;
58223: GO 58144
58225: POP
58226: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58227: LD_ADDR_EXP 115
58231: PUSH
58232: LD_EXP 115
58236: PPUSH
58237: LD_VAR 0 1
58241: PPUSH
58242: LD_VAR 0 6
58246: PPUSH
58247: CALL_OW 1
58251: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58252: LD_ADDR_EXP 117
58256: PUSH
58257: LD_EXP 117
58261: PPUSH
58262: LD_VAR 0 1
58266: PPUSH
58267: LD_VAR 0 3
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
// end ;
58277: LD_VAR 0 4
58281: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58282: LD_INT 0
58284: PPUSH
// if not mc_bases [ base ] then
58285: LD_EXP 102
58289: PUSH
58290: LD_VAR 0 1
58294: ARRAY
58295: NOT
58296: IFFALSE 58300
// exit ;
58298: GO 58325
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58300: LD_ADDR_EXP 107
58304: PUSH
58305: LD_EXP 107
58309: PPUSH
58310: LD_VAR 0 1
58314: PPUSH
58315: LD_VAR 0 2
58319: PPUSH
58320: CALL_OW 1
58324: ST_TO_ADDR
// end ;
58325: LD_VAR 0 3
58329: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58330: LD_INT 0
58332: PPUSH
// if not mc_bases [ base ] then
58333: LD_EXP 102
58337: PUSH
58338: LD_VAR 0 1
58342: ARRAY
58343: NOT
58344: IFFALSE 58348
// exit ;
58346: GO 58385
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58348: LD_ADDR_EXP 107
58352: PUSH
58353: LD_EXP 107
58357: PPUSH
58358: LD_VAR 0 1
58362: PPUSH
58363: LD_EXP 107
58367: PUSH
58368: LD_VAR 0 1
58372: ARRAY
58373: PUSH
58374: LD_VAR 0 2
58378: UNION
58379: PPUSH
58380: CALL_OW 1
58384: ST_TO_ADDR
// end ;
58385: LD_VAR 0 3
58389: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58390: LD_INT 0
58392: PPUSH
// if not mc_bases [ base ] then
58393: LD_EXP 102
58397: PUSH
58398: LD_VAR 0 1
58402: ARRAY
58403: NOT
58404: IFFALSE 58408
// exit ;
58406: GO 58433
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58408: LD_ADDR_EXP 123
58412: PUSH
58413: LD_EXP 123
58417: PPUSH
58418: LD_VAR 0 1
58422: PPUSH
58423: LD_VAR 0 2
58427: PPUSH
58428: CALL_OW 1
58432: ST_TO_ADDR
// end ;
58433: LD_VAR 0 3
58437: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58438: LD_INT 0
58440: PPUSH
// if not mc_bases [ base ] then
58441: LD_EXP 102
58445: PUSH
58446: LD_VAR 0 1
58450: ARRAY
58451: NOT
58452: IFFALSE 58456
// exit ;
58454: GO 58493
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58456: LD_ADDR_EXP 123
58460: PUSH
58461: LD_EXP 123
58465: PPUSH
58466: LD_VAR 0 1
58470: PPUSH
58471: LD_EXP 123
58475: PUSH
58476: LD_VAR 0 1
58480: ARRAY
58481: PUSH
58482: LD_VAR 0 2
58486: ADD
58487: PPUSH
58488: CALL_OW 1
58492: ST_TO_ADDR
// end ;
58493: LD_VAR 0 3
58497: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58498: LD_INT 0
58500: PPUSH
// if not mc_bases [ base ] then
58501: LD_EXP 102
58505: PUSH
58506: LD_VAR 0 1
58510: ARRAY
58511: NOT
58512: IFFALSE 58516
// exit ;
58514: GO 58570
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58516: LD_ADDR_EXP 124
58520: PUSH
58521: LD_EXP 124
58525: PPUSH
58526: LD_VAR 0 1
58530: PPUSH
58531: LD_VAR 0 2
58535: PPUSH
58536: CALL_OW 1
58540: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58541: LD_ADDR_EXP 113
58545: PUSH
58546: LD_EXP 113
58550: PPUSH
58551: LD_VAR 0 1
58555: PPUSH
58556: LD_VAR 0 2
58560: PUSH
58561: LD_INT 0
58563: PLUS
58564: PPUSH
58565: CALL_OW 1
58569: ST_TO_ADDR
// end ;
58570: LD_VAR 0 3
58574: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58575: LD_INT 0
58577: PPUSH
// if not mc_bases [ base ] then
58578: LD_EXP 102
58582: PUSH
58583: LD_VAR 0 1
58587: ARRAY
58588: NOT
58589: IFFALSE 58593
// exit ;
58591: GO 58618
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58593: LD_ADDR_EXP 113
58597: PUSH
58598: LD_EXP 113
58602: PPUSH
58603: LD_VAR 0 1
58607: PPUSH
58608: LD_VAR 0 2
58612: PPUSH
58613: CALL_OW 1
58617: ST_TO_ADDR
// end ;
58618: LD_VAR 0 3
58622: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58623: LD_INT 0
58625: PPUSH
58626: PPUSH
58627: PPUSH
58628: PPUSH
// if not mc_bases [ base ] then
58629: LD_EXP 102
58633: PUSH
58634: LD_VAR 0 1
58638: ARRAY
58639: NOT
58640: IFFALSE 58644
// exit ;
58642: GO 58709
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58644: LD_ADDR_EXP 122
58648: PUSH
58649: LD_EXP 122
58653: PPUSH
58654: LD_VAR 0 1
58658: PUSH
58659: LD_EXP 122
58663: PUSH
58664: LD_VAR 0 1
58668: ARRAY
58669: PUSH
58670: LD_INT 1
58672: PLUS
58673: PUSH
58674: EMPTY
58675: LIST
58676: LIST
58677: PPUSH
58678: LD_VAR 0 1
58682: PUSH
58683: LD_VAR 0 2
58687: PUSH
58688: LD_VAR 0 3
58692: PUSH
58693: LD_VAR 0 4
58697: PUSH
58698: EMPTY
58699: LIST
58700: LIST
58701: LIST
58702: LIST
58703: PPUSH
58704: CALL 72019 0 3
58708: ST_TO_ADDR
// end ;
58709: LD_VAR 0 5
58713: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58714: LD_INT 0
58716: PPUSH
// if not mc_bases [ base ] then
58717: LD_EXP 102
58721: PUSH
58722: LD_VAR 0 1
58726: ARRAY
58727: NOT
58728: IFFALSE 58732
// exit ;
58730: GO 58757
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58732: LD_ADDR_EXP 139
58736: PUSH
58737: LD_EXP 139
58741: PPUSH
58742: LD_VAR 0 1
58746: PPUSH
58747: LD_VAR 0 2
58751: PPUSH
58752: CALL_OW 1
58756: ST_TO_ADDR
// end ;
58757: LD_VAR 0 3
58761: RET
// export function MC_GetMinesField ( base ) ; begin
58762: LD_INT 0
58764: PPUSH
// result := mc_mines [ base ] ;
58765: LD_ADDR_VAR 0 2
58769: PUSH
58770: LD_EXP 115
58774: PUSH
58775: LD_VAR 0 1
58779: ARRAY
58780: ST_TO_ADDR
// end ;
58781: LD_VAR 0 2
58785: RET
// export function MC_GetProduceList ( base ) ; begin
58786: LD_INT 0
58788: PPUSH
// result := mc_produce [ base ] ;
58789: LD_ADDR_VAR 0 2
58793: PUSH
58794: LD_EXP 123
58798: PUSH
58799: LD_VAR 0 1
58803: ARRAY
58804: ST_TO_ADDR
// end ;
58805: LD_VAR 0 2
58809: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58810: LD_INT 0
58812: PPUSH
58813: PPUSH
// if not mc_bases then
58814: LD_EXP 102
58818: NOT
58819: IFFALSE 58823
// exit ;
58821: GO 58888
// if mc_bases [ base ] then
58823: LD_EXP 102
58827: PUSH
58828: LD_VAR 0 1
58832: ARRAY
58833: IFFALSE 58888
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58835: LD_ADDR_VAR 0 3
58839: PUSH
58840: LD_EXP 102
58844: PUSH
58845: LD_VAR 0 1
58849: ARRAY
58850: PPUSH
58851: LD_INT 30
58853: PUSH
58854: LD_VAR 0 2
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PPUSH
58863: CALL_OW 72
58867: ST_TO_ADDR
// if result then
58868: LD_VAR 0 3
58872: IFFALSE 58888
// result := result [ 1 ] ;
58874: LD_ADDR_VAR 0 3
58878: PUSH
58879: LD_VAR 0 3
58883: PUSH
58884: LD_INT 1
58886: ARRAY
58887: ST_TO_ADDR
// end ; end ;
58888: LD_VAR 0 3
58892: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58893: LD_INT 0
58895: PPUSH
58896: PPUSH
// if not mc_bases then
58897: LD_EXP 102
58901: NOT
58902: IFFALSE 58906
// exit ;
58904: GO 58951
// if mc_bases [ base ] then
58906: LD_EXP 102
58910: PUSH
58911: LD_VAR 0 1
58915: ARRAY
58916: IFFALSE 58951
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58918: LD_ADDR_VAR 0 3
58922: PUSH
58923: LD_EXP 102
58927: PUSH
58928: LD_VAR 0 1
58932: ARRAY
58933: PPUSH
58934: LD_INT 30
58936: PUSH
58937: LD_VAR 0 2
58941: PUSH
58942: EMPTY
58943: LIST
58944: LIST
58945: PPUSH
58946: CALL_OW 72
58950: ST_TO_ADDR
// end ;
58951: LD_VAR 0 3
58955: RET
// export function MC_SetTame ( base , area ) ; begin
58956: LD_INT 0
58958: PPUSH
// if not mc_bases or not base then
58959: LD_EXP 102
58963: NOT
58964: PUSH
58965: LD_VAR 0 1
58969: NOT
58970: OR
58971: IFFALSE 58975
// exit ;
58973: GO 59000
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58975: LD_ADDR_EXP 130
58979: PUSH
58980: LD_EXP 130
58984: PPUSH
58985: LD_VAR 0 1
58989: PPUSH
58990: LD_VAR 0 2
58994: PPUSH
58995: CALL_OW 1
58999: ST_TO_ADDR
// end ;
59000: LD_VAR 0 3
59004: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59005: LD_INT 0
59007: PPUSH
59008: PPUSH
// if not mc_bases or not base then
59009: LD_EXP 102
59013: NOT
59014: PUSH
59015: LD_VAR 0 1
59019: NOT
59020: OR
59021: IFFALSE 59025
// exit ;
59023: GO 59127
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59025: LD_ADDR_VAR 0 4
59029: PUSH
59030: LD_EXP 102
59034: PUSH
59035: LD_VAR 0 1
59039: ARRAY
59040: PPUSH
59041: LD_INT 30
59043: PUSH
59044: LD_VAR 0 2
59048: PUSH
59049: EMPTY
59050: LIST
59051: LIST
59052: PPUSH
59053: CALL_OW 72
59057: ST_TO_ADDR
// if not tmp then
59058: LD_VAR 0 4
59062: NOT
59063: IFFALSE 59067
// exit ;
59065: GO 59127
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59067: LD_ADDR_EXP 134
59071: PUSH
59072: LD_EXP 134
59076: PPUSH
59077: LD_VAR 0 1
59081: PPUSH
59082: LD_EXP 134
59086: PUSH
59087: LD_VAR 0 1
59091: ARRAY
59092: PPUSH
59093: LD_EXP 134
59097: PUSH
59098: LD_VAR 0 1
59102: ARRAY
59103: PUSH
59104: LD_INT 1
59106: PLUS
59107: PPUSH
59108: LD_VAR 0 4
59112: PUSH
59113: LD_INT 1
59115: ARRAY
59116: PPUSH
59117: CALL_OW 2
59121: PPUSH
59122: CALL_OW 1
59126: ST_TO_ADDR
// end ;
59127: LD_VAR 0 3
59131: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59132: LD_INT 0
59134: PPUSH
59135: PPUSH
// if not mc_bases or not base or not kinds then
59136: LD_EXP 102
59140: NOT
59141: PUSH
59142: LD_VAR 0 1
59146: NOT
59147: OR
59148: PUSH
59149: LD_VAR 0 2
59153: NOT
59154: OR
59155: IFFALSE 59159
// exit ;
59157: GO 59220
// for i in kinds do
59159: LD_ADDR_VAR 0 4
59163: PUSH
59164: LD_VAR 0 2
59168: PUSH
59169: FOR_IN
59170: IFFALSE 59218
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59172: LD_ADDR_EXP 136
59176: PUSH
59177: LD_EXP 136
59181: PPUSH
59182: LD_VAR 0 1
59186: PUSH
59187: LD_EXP 136
59191: PUSH
59192: LD_VAR 0 1
59196: ARRAY
59197: PUSH
59198: LD_INT 1
59200: PLUS
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: PPUSH
59206: LD_VAR 0 4
59210: PPUSH
59211: CALL 72019 0 3
59215: ST_TO_ADDR
59216: GO 59169
59218: POP
59219: POP
// end ;
59220: LD_VAR 0 3
59224: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59225: LD_INT 0
59227: PPUSH
// if not mc_bases or not base or not areas then
59228: LD_EXP 102
59232: NOT
59233: PUSH
59234: LD_VAR 0 1
59238: NOT
59239: OR
59240: PUSH
59241: LD_VAR 0 2
59245: NOT
59246: OR
59247: IFFALSE 59251
// exit ;
59249: GO 59276
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59251: LD_ADDR_EXP 120
59255: PUSH
59256: LD_EXP 120
59260: PPUSH
59261: LD_VAR 0 1
59265: PPUSH
59266: LD_VAR 0 2
59270: PPUSH
59271: CALL_OW 1
59275: ST_TO_ADDR
// end ;
59276: LD_VAR 0 3
59280: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59281: LD_INT 0
59283: PPUSH
// if not mc_bases or not base or not teleports_exit then
59284: LD_EXP 102
59288: NOT
59289: PUSH
59290: LD_VAR 0 1
59294: NOT
59295: OR
59296: PUSH
59297: LD_VAR 0 2
59301: NOT
59302: OR
59303: IFFALSE 59307
// exit ;
59305: GO 59332
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59307: LD_ADDR_EXP 137
59311: PUSH
59312: LD_EXP 137
59316: PPUSH
59317: LD_VAR 0 1
59321: PPUSH
59322: LD_VAR 0 2
59326: PPUSH
59327: CALL_OW 1
59331: ST_TO_ADDR
// end ;
59332: LD_VAR 0 3
59336: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59337: LD_INT 0
59339: PPUSH
59340: PPUSH
59341: PPUSH
// if not mc_bases or not base or not ext_list then
59342: LD_EXP 102
59346: NOT
59347: PUSH
59348: LD_VAR 0 1
59352: NOT
59353: OR
59354: PUSH
59355: LD_VAR 0 5
59359: NOT
59360: OR
59361: IFFALSE 59365
// exit ;
59363: GO 59538
// tmp := GetFacExtXYD ( x , y , d ) ;
59365: LD_ADDR_VAR 0 8
59369: PUSH
59370: LD_VAR 0 2
59374: PPUSH
59375: LD_VAR 0 3
59379: PPUSH
59380: LD_VAR 0 4
59384: PPUSH
59385: CALL 105407 0 3
59389: ST_TO_ADDR
// if not tmp then
59390: LD_VAR 0 8
59394: NOT
59395: IFFALSE 59399
// exit ;
59397: GO 59538
// for i in tmp do
59399: LD_ADDR_VAR 0 7
59403: PUSH
59404: LD_VAR 0 8
59408: PUSH
59409: FOR_IN
59410: IFFALSE 59536
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59412: LD_ADDR_EXP 107
59416: PUSH
59417: LD_EXP 107
59421: PPUSH
59422: LD_VAR 0 1
59426: PPUSH
59427: LD_EXP 107
59431: PUSH
59432: LD_VAR 0 1
59436: ARRAY
59437: PPUSH
59438: LD_EXP 107
59442: PUSH
59443: LD_VAR 0 1
59447: ARRAY
59448: PUSH
59449: LD_INT 1
59451: PLUS
59452: PPUSH
59453: LD_VAR 0 5
59457: PUSH
59458: LD_INT 1
59460: ARRAY
59461: PUSH
59462: LD_VAR 0 7
59466: PUSH
59467: LD_INT 1
59469: ARRAY
59470: PUSH
59471: LD_VAR 0 7
59475: PUSH
59476: LD_INT 2
59478: ARRAY
59479: PUSH
59480: LD_VAR 0 7
59484: PUSH
59485: LD_INT 3
59487: ARRAY
59488: PUSH
59489: EMPTY
59490: LIST
59491: LIST
59492: LIST
59493: LIST
59494: PPUSH
59495: CALL_OW 2
59499: PPUSH
59500: CALL_OW 1
59504: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59505: LD_ADDR_VAR 0 5
59509: PUSH
59510: LD_VAR 0 5
59514: PPUSH
59515: LD_INT 1
59517: PPUSH
59518: CALL_OW 3
59522: ST_TO_ADDR
// if not ext_list then
59523: LD_VAR 0 5
59527: NOT
59528: IFFALSE 59534
// exit ;
59530: POP
59531: POP
59532: GO 59538
// end ;
59534: GO 59409
59536: POP
59537: POP
// end ;
59538: LD_VAR 0 6
59542: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59543: LD_INT 0
59545: PPUSH
// if not mc_bases or not base or not weapon_list then
59546: LD_EXP 102
59550: NOT
59551: PUSH
59552: LD_VAR 0 1
59556: NOT
59557: OR
59558: PUSH
59559: LD_VAR 0 2
59563: NOT
59564: OR
59565: IFFALSE 59569
// exit ;
59567: GO 59594
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59569: LD_ADDR_EXP 141
59573: PUSH
59574: LD_EXP 141
59578: PPUSH
59579: LD_VAR 0 1
59583: PPUSH
59584: LD_VAR 0 2
59588: PPUSH
59589: CALL_OW 1
59593: ST_TO_ADDR
// end ;
59594: LD_VAR 0 3
59598: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59599: LD_INT 0
59601: PPUSH
// if not mc_bases or not base or not tech_list then
59602: LD_EXP 102
59606: NOT
59607: PUSH
59608: LD_VAR 0 1
59612: NOT
59613: OR
59614: PUSH
59615: LD_VAR 0 2
59619: NOT
59620: OR
59621: IFFALSE 59625
// exit ;
59623: GO 59650
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59625: LD_ADDR_EXP 129
59629: PUSH
59630: LD_EXP 129
59634: PPUSH
59635: LD_VAR 0 1
59639: PPUSH
59640: LD_VAR 0 2
59644: PPUSH
59645: CALL_OW 1
59649: ST_TO_ADDR
// end ;
59650: LD_VAR 0 3
59654: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59655: LD_INT 0
59657: PPUSH
// if not mc_bases or not parking_area or not base then
59658: LD_EXP 102
59662: NOT
59663: PUSH
59664: LD_VAR 0 2
59668: NOT
59669: OR
59670: PUSH
59671: LD_VAR 0 1
59675: NOT
59676: OR
59677: IFFALSE 59681
// exit ;
59679: GO 59706
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59681: LD_ADDR_EXP 126
59685: PUSH
59686: LD_EXP 126
59690: PPUSH
59691: LD_VAR 0 1
59695: PPUSH
59696: LD_VAR 0 2
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// end ;
59706: LD_VAR 0 3
59710: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59711: LD_INT 0
59713: PPUSH
// if not mc_bases or not base or not scan_area then
59714: LD_EXP 102
59718: NOT
59719: PUSH
59720: LD_VAR 0 1
59724: NOT
59725: OR
59726: PUSH
59727: LD_VAR 0 2
59731: NOT
59732: OR
59733: IFFALSE 59737
// exit ;
59735: GO 59762
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59737: LD_ADDR_EXP 127
59741: PUSH
59742: LD_EXP 127
59746: PPUSH
59747: LD_VAR 0 1
59751: PPUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: CALL_OW 1
59761: ST_TO_ADDR
// end ;
59762: LD_VAR 0 3
59766: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59767: LD_INT 0
59769: PPUSH
59770: PPUSH
// if not mc_bases or not base then
59771: LD_EXP 102
59775: NOT
59776: PUSH
59777: LD_VAR 0 1
59781: NOT
59782: OR
59783: IFFALSE 59787
// exit ;
59785: GO 59851
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59787: LD_ADDR_VAR 0 3
59791: PUSH
59792: LD_INT 1
59794: PUSH
59795: LD_INT 2
59797: PUSH
59798: LD_INT 3
59800: PUSH
59801: LD_INT 4
59803: PUSH
59804: LD_INT 11
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: LIST
59811: LIST
59812: LIST
59813: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59814: LD_ADDR_EXP 129
59818: PUSH
59819: LD_EXP 129
59823: PPUSH
59824: LD_VAR 0 1
59828: PPUSH
59829: LD_EXP 129
59833: PUSH
59834: LD_VAR 0 1
59838: ARRAY
59839: PUSH
59840: LD_VAR 0 3
59844: DIFF
59845: PPUSH
59846: CALL_OW 1
59850: ST_TO_ADDR
// end ;
59851: LD_VAR 0 2
59855: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59856: LD_INT 0
59858: PPUSH
// result := mc_vehicles [ base ] ;
59859: LD_ADDR_VAR 0 3
59863: PUSH
59864: LD_EXP 121
59868: PUSH
59869: LD_VAR 0 1
59873: ARRAY
59874: ST_TO_ADDR
// if onlyCombat then
59875: LD_VAR 0 2
59879: IFFALSE 60044
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59881: LD_ADDR_VAR 0 3
59885: PUSH
59886: LD_VAR 0 3
59890: PUSH
59891: LD_VAR 0 3
59895: PPUSH
59896: LD_INT 2
59898: PUSH
59899: LD_INT 34
59901: PUSH
59902: LD_INT 12
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: LD_INT 34
59911: PUSH
59912: LD_INT 51
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 34
59921: PUSH
59922: LD_EXP 96
59926: PUSH
59927: EMPTY
59928: LIST
59929: LIST
59930: PUSH
59931: LD_INT 34
59933: PUSH
59934: LD_INT 32
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 34
59943: PUSH
59944: LD_INT 13
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PUSH
59951: LD_INT 34
59953: PUSH
59954: LD_INT 52
59956: PUSH
59957: EMPTY
59958: LIST
59959: LIST
59960: PUSH
59961: LD_INT 34
59963: PUSH
59964: LD_INT 14
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: PUSH
59971: LD_INT 34
59973: PUSH
59974: LD_INT 53
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PUSH
59981: LD_INT 34
59983: PUSH
59984: LD_EXP 95
59988: PUSH
59989: EMPTY
59990: LIST
59991: LIST
59992: PUSH
59993: LD_INT 34
59995: PUSH
59996: LD_INT 31
59998: PUSH
59999: EMPTY
60000: LIST
60001: LIST
60002: PUSH
60003: LD_INT 34
60005: PUSH
60006: LD_INT 48
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PUSH
60013: LD_INT 34
60015: PUSH
60016: LD_INT 8
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: PUSH
60023: EMPTY
60024: LIST
60025: LIST
60026: LIST
60027: LIST
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: LIST
60033: LIST
60034: LIST
60035: LIST
60036: LIST
60037: PPUSH
60038: CALL_OW 72
60042: DIFF
60043: ST_TO_ADDR
// end ; end_of_file
60044: LD_VAR 0 3
60048: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60049: LD_INT 0
60051: PPUSH
60052: PPUSH
60053: PPUSH
// if not mc_bases or not skirmish then
60054: LD_EXP 102
60058: NOT
60059: PUSH
60060: LD_EXP 100
60064: NOT
60065: OR
60066: IFFALSE 60070
// exit ;
60068: GO 60235
// for i = 1 to mc_bases do
60070: LD_ADDR_VAR 0 4
60074: PUSH
60075: DOUBLE
60076: LD_INT 1
60078: DEC
60079: ST_TO_ADDR
60080: LD_EXP 102
60084: PUSH
60085: FOR_TO
60086: IFFALSE 60233
// begin if sci in mc_bases [ i ] then
60088: LD_VAR 0 2
60092: PUSH
60093: LD_EXP 102
60097: PUSH
60098: LD_VAR 0 4
60102: ARRAY
60103: IN
60104: IFFALSE 60231
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60106: LD_ADDR_EXP 131
60110: PUSH
60111: LD_EXP 131
60115: PPUSH
60116: LD_VAR 0 4
60120: PUSH
60121: LD_EXP 131
60125: PUSH
60126: LD_VAR 0 4
60130: ARRAY
60131: PUSH
60132: LD_INT 1
60134: PLUS
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: PPUSH
60140: LD_VAR 0 1
60144: PPUSH
60145: CALL 72019 0 3
60149: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60150: LD_ADDR_VAR 0 5
60154: PUSH
60155: LD_EXP 102
60159: PUSH
60160: LD_VAR 0 4
60164: ARRAY
60165: PPUSH
60166: LD_INT 2
60168: PUSH
60169: LD_INT 30
60171: PUSH
60172: LD_INT 0
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PUSH
60179: LD_INT 30
60181: PUSH
60182: LD_INT 1
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: LIST
60193: PPUSH
60194: CALL_OW 72
60198: PPUSH
60199: LD_VAR 0 1
60203: PPUSH
60204: CALL_OW 74
60208: ST_TO_ADDR
// if tmp then
60209: LD_VAR 0 5
60213: IFFALSE 60229
// ComStandNearbyBuilding ( ape , tmp ) ;
60215: LD_VAR 0 1
60219: PPUSH
60220: LD_VAR 0 5
60224: PPUSH
60225: CALL 66222 0 2
// break ;
60229: GO 60233
// end ; end ;
60231: GO 60085
60233: POP
60234: POP
// end ;
60235: LD_VAR 0 3
60239: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60240: LD_INT 0
60242: PPUSH
60243: PPUSH
60244: PPUSH
// if not mc_bases or not skirmish then
60245: LD_EXP 102
60249: NOT
60250: PUSH
60251: LD_EXP 100
60255: NOT
60256: OR
60257: IFFALSE 60261
// exit ;
60259: GO 60350
// for i = 1 to mc_bases do
60261: LD_ADDR_VAR 0 4
60265: PUSH
60266: DOUBLE
60267: LD_INT 1
60269: DEC
60270: ST_TO_ADDR
60271: LD_EXP 102
60275: PUSH
60276: FOR_TO
60277: IFFALSE 60348
// begin if building in mc_busy_turret_list [ i ] then
60279: LD_VAR 0 1
60283: PUSH
60284: LD_EXP 112
60288: PUSH
60289: LD_VAR 0 4
60293: ARRAY
60294: IN
60295: IFFALSE 60346
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60297: LD_ADDR_VAR 0 5
60301: PUSH
60302: LD_EXP 112
60306: PUSH
60307: LD_VAR 0 4
60311: ARRAY
60312: PUSH
60313: LD_VAR 0 1
60317: DIFF
60318: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60319: LD_ADDR_EXP 112
60323: PUSH
60324: LD_EXP 112
60328: PPUSH
60329: LD_VAR 0 4
60333: PPUSH
60334: LD_VAR 0 5
60338: PPUSH
60339: CALL_OW 1
60343: ST_TO_ADDR
// break ;
60344: GO 60348
// end ; end ;
60346: GO 60276
60348: POP
60349: POP
// end ;
60350: LD_VAR 0 3
60354: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60355: LD_INT 0
60357: PPUSH
60358: PPUSH
60359: PPUSH
// if not mc_bases or not skirmish then
60360: LD_EXP 102
60364: NOT
60365: PUSH
60366: LD_EXP 100
60370: NOT
60371: OR
60372: IFFALSE 60376
// exit ;
60374: GO 60575
// for i = 1 to mc_bases do
60376: LD_ADDR_VAR 0 5
60380: PUSH
60381: DOUBLE
60382: LD_INT 1
60384: DEC
60385: ST_TO_ADDR
60386: LD_EXP 102
60390: PUSH
60391: FOR_TO
60392: IFFALSE 60573
// if building in mc_bases [ i ] then
60394: LD_VAR 0 1
60398: PUSH
60399: LD_EXP 102
60403: PUSH
60404: LD_VAR 0 5
60408: ARRAY
60409: IN
60410: IFFALSE 60571
// begin tmp := mc_bases [ i ] diff building ;
60412: LD_ADDR_VAR 0 6
60416: PUSH
60417: LD_EXP 102
60421: PUSH
60422: LD_VAR 0 5
60426: ARRAY
60427: PUSH
60428: LD_VAR 0 1
60432: DIFF
60433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60434: LD_ADDR_EXP 102
60438: PUSH
60439: LD_EXP 102
60443: PPUSH
60444: LD_VAR 0 5
60448: PPUSH
60449: LD_VAR 0 6
60453: PPUSH
60454: CALL_OW 1
60458: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60459: LD_VAR 0 1
60463: PUSH
60464: LD_EXP 110
60468: PUSH
60469: LD_VAR 0 5
60473: ARRAY
60474: IN
60475: IFFALSE 60514
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60477: LD_ADDR_EXP 110
60481: PUSH
60482: LD_EXP 110
60486: PPUSH
60487: LD_VAR 0 5
60491: PPUSH
60492: LD_EXP 110
60496: PUSH
60497: LD_VAR 0 5
60501: ARRAY
60502: PUSH
60503: LD_VAR 0 1
60507: DIFF
60508: PPUSH
60509: CALL_OW 1
60513: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60514: LD_VAR 0 1
60518: PUSH
60519: LD_EXP 111
60523: PUSH
60524: LD_VAR 0 5
60528: ARRAY
60529: IN
60530: IFFALSE 60569
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60532: LD_ADDR_EXP 111
60536: PUSH
60537: LD_EXP 111
60541: PPUSH
60542: LD_VAR 0 5
60546: PPUSH
60547: LD_EXP 111
60551: PUSH
60552: LD_VAR 0 5
60556: ARRAY
60557: PUSH
60558: LD_VAR 0 1
60562: DIFF
60563: PPUSH
60564: CALL_OW 1
60568: ST_TO_ADDR
// break ;
60569: GO 60573
// end ;
60571: GO 60391
60573: POP
60574: POP
// end ;
60575: LD_VAR 0 4
60579: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60580: LD_INT 0
60582: PPUSH
60583: PPUSH
60584: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60585: LD_EXP 102
60589: NOT
60590: PUSH
60591: LD_EXP 100
60595: NOT
60596: OR
60597: PUSH
60598: LD_VAR 0 3
60602: PUSH
60603: LD_EXP 128
60607: IN
60608: NOT
60609: OR
60610: IFFALSE 60614
// exit ;
60612: GO 60737
// for i = 1 to mc_vehicles do
60614: LD_ADDR_VAR 0 6
60618: PUSH
60619: DOUBLE
60620: LD_INT 1
60622: DEC
60623: ST_TO_ADDR
60624: LD_EXP 121
60628: PUSH
60629: FOR_TO
60630: IFFALSE 60735
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60632: LD_VAR 0 2
60636: PUSH
60637: LD_EXP 121
60641: PUSH
60642: LD_VAR 0 6
60646: ARRAY
60647: IN
60648: PUSH
60649: LD_VAR 0 1
60653: PUSH
60654: LD_EXP 121
60658: PUSH
60659: LD_VAR 0 6
60663: ARRAY
60664: IN
60665: OR
60666: IFFALSE 60733
// begin tmp := mc_vehicles [ i ] diff old ;
60668: LD_ADDR_VAR 0 7
60672: PUSH
60673: LD_EXP 121
60677: PUSH
60678: LD_VAR 0 6
60682: ARRAY
60683: PUSH
60684: LD_VAR 0 2
60688: DIFF
60689: ST_TO_ADDR
// tmp := tmp diff new ;
60690: LD_ADDR_VAR 0 7
60694: PUSH
60695: LD_VAR 0 7
60699: PUSH
60700: LD_VAR 0 1
60704: DIFF
60705: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60706: LD_ADDR_EXP 121
60710: PUSH
60711: LD_EXP 121
60715: PPUSH
60716: LD_VAR 0 6
60720: PPUSH
60721: LD_VAR 0 7
60725: PPUSH
60726: CALL_OW 1
60730: ST_TO_ADDR
// break ;
60731: GO 60735
// end ;
60733: GO 60629
60735: POP
60736: POP
// end ;
60737: LD_VAR 0 5
60741: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60742: LD_INT 0
60744: PPUSH
60745: PPUSH
60746: PPUSH
60747: PPUSH
// if not mc_bases or not skirmish then
60748: LD_EXP 102
60752: NOT
60753: PUSH
60754: LD_EXP 100
60758: NOT
60759: OR
60760: IFFALSE 60764
// exit ;
60762: GO 61141
// side := GetSide ( vehicle ) ;
60764: LD_ADDR_VAR 0 5
60768: PUSH
60769: LD_VAR 0 1
60773: PPUSH
60774: CALL_OW 255
60778: ST_TO_ADDR
// for i = 1 to mc_bases do
60779: LD_ADDR_VAR 0 4
60783: PUSH
60784: DOUBLE
60785: LD_INT 1
60787: DEC
60788: ST_TO_ADDR
60789: LD_EXP 102
60793: PUSH
60794: FOR_TO
60795: IFFALSE 61139
// begin if factory in mc_bases [ i ] then
60797: LD_VAR 0 2
60801: PUSH
60802: LD_EXP 102
60806: PUSH
60807: LD_VAR 0 4
60811: ARRAY
60812: IN
60813: IFFALSE 61137
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60815: LD_EXP 124
60819: PUSH
60820: LD_VAR 0 4
60824: ARRAY
60825: PUSH
60826: LD_EXP 113
60830: PUSH
60831: LD_VAR 0 4
60835: ARRAY
60836: LESS
60837: PUSH
60838: LD_VAR 0 1
60842: PPUSH
60843: CALL_OW 264
60847: PUSH
60848: LD_INT 31
60850: PUSH
60851: LD_INT 32
60853: PUSH
60854: LD_INT 51
60856: PUSH
60857: LD_EXP 96
60861: PUSH
60862: LD_INT 12
60864: PUSH
60865: LD_INT 30
60867: PUSH
60868: LD_EXP 95
60872: PUSH
60873: LD_INT 11
60875: PUSH
60876: LD_INT 53
60878: PUSH
60879: LD_INT 14
60881: PUSH
60882: LD_EXP 99
60886: PUSH
60887: LD_INT 29
60889: PUSH
60890: LD_EXP 97
60894: PUSH
60895: LD_INT 13
60897: PUSH
60898: LD_INT 52
60900: PUSH
60901: LD_INT 48
60903: PUSH
60904: LD_INT 8
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: LIST
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: LIST
60922: LIST
60923: LIST
60924: LIST
60925: IN
60926: NOT
60927: AND
60928: IFFALSE 60976
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60930: LD_ADDR_EXP 124
60934: PUSH
60935: LD_EXP 124
60939: PPUSH
60940: LD_VAR 0 4
60944: PUSH
60945: LD_EXP 124
60949: PUSH
60950: LD_VAR 0 4
60954: ARRAY
60955: PUSH
60956: LD_INT 1
60958: PLUS
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PPUSH
60964: LD_VAR 0 1
60968: PPUSH
60969: CALL 72019 0 3
60973: ST_TO_ADDR
60974: GO 61020
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60976: LD_ADDR_EXP 121
60980: PUSH
60981: LD_EXP 121
60985: PPUSH
60986: LD_VAR 0 4
60990: PUSH
60991: LD_EXP 121
60995: PUSH
60996: LD_VAR 0 4
61000: ARRAY
61001: PUSH
61002: LD_INT 1
61004: PLUS
61005: PUSH
61006: EMPTY
61007: LIST
61008: LIST
61009: PPUSH
61010: LD_VAR 0 1
61014: PPUSH
61015: CALL 72019 0 3
61019: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61020: LD_VAR 0 1
61024: PPUSH
61025: CALL_OW 263
61029: PUSH
61030: LD_INT 2
61032: EQUAL
61033: IFFALSE 61053
// begin repeat wait ( 0 0$1 ) ;
61035: LD_INT 35
61037: PPUSH
61038: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61042: LD_VAR 0 1
61046: PPUSH
61047: CALL_OW 312
61051: IFFALSE 61035
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61053: LD_VAR 0 1
61057: PPUSH
61058: LD_EXP 126
61062: PUSH
61063: LD_VAR 0 4
61067: ARRAY
61068: PPUSH
61069: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61073: LD_VAR 0 1
61077: PPUSH
61078: CALL_OW 263
61082: PUSH
61083: LD_INT 1
61085: NONEQUAL
61086: IFFALSE 61090
// break ;
61088: GO 61139
// repeat wait ( 0 0$1 ) ;
61090: LD_INT 35
61092: PPUSH
61093: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61097: LD_VAR 0 1
61101: PPUSH
61102: LD_EXP 126
61106: PUSH
61107: LD_VAR 0 4
61111: ARRAY
61112: PPUSH
61113: CALL_OW 308
61117: IFFALSE 61090
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61119: LD_VAR 0 1
61123: PPUSH
61124: CALL_OW 311
61128: PPUSH
61129: CALL_OW 121
// exit ;
61133: POP
61134: POP
61135: GO 61141
// end ; end ;
61137: GO 60794
61139: POP
61140: POP
// end ;
61141: LD_VAR 0 3
61145: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61146: LD_INT 0
61148: PPUSH
61149: PPUSH
61150: PPUSH
61151: PPUSH
// if not mc_bases or not skirmish then
61152: LD_EXP 102
61156: NOT
61157: PUSH
61158: LD_EXP 100
61162: NOT
61163: OR
61164: IFFALSE 61168
// exit ;
61166: GO 61521
// repeat wait ( 0 0$1 ) ;
61168: LD_INT 35
61170: PPUSH
61171: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61175: LD_VAR 0 2
61179: PPUSH
61180: LD_VAR 0 3
61184: PPUSH
61185: CALL_OW 284
61189: IFFALSE 61168
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61191: LD_VAR 0 2
61195: PPUSH
61196: LD_VAR 0 3
61200: PPUSH
61201: CALL_OW 283
61205: PUSH
61206: LD_INT 4
61208: EQUAL
61209: IFFALSE 61213
// exit ;
61211: GO 61521
// for i = 1 to mc_bases do
61213: LD_ADDR_VAR 0 7
61217: PUSH
61218: DOUBLE
61219: LD_INT 1
61221: DEC
61222: ST_TO_ADDR
61223: LD_EXP 102
61227: PUSH
61228: FOR_TO
61229: IFFALSE 61519
// begin if mc_crates_area [ i ] then
61231: LD_EXP 120
61235: PUSH
61236: LD_VAR 0 7
61240: ARRAY
61241: IFFALSE 61352
// for j in mc_crates_area [ i ] do
61243: LD_ADDR_VAR 0 8
61247: PUSH
61248: LD_EXP 120
61252: PUSH
61253: LD_VAR 0 7
61257: ARRAY
61258: PUSH
61259: FOR_IN
61260: IFFALSE 61350
// if InArea ( x , y , j ) then
61262: LD_VAR 0 2
61266: PPUSH
61267: LD_VAR 0 3
61271: PPUSH
61272: LD_VAR 0 8
61276: PPUSH
61277: CALL_OW 309
61281: IFFALSE 61348
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61283: LD_ADDR_EXP 118
61287: PUSH
61288: LD_EXP 118
61292: PPUSH
61293: LD_VAR 0 7
61297: PUSH
61298: LD_EXP 118
61302: PUSH
61303: LD_VAR 0 7
61307: ARRAY
61308: PUSH
61309: LD_INT 1
61311: PLUS
61312: PUSH
61313: EMPTY
61314: LIST
61315: LIST
61316: PPUSH
61317: LD_VAR 0 4
61321: PUSH
61322: LD_VAR 0 2
61326: PUSH
61327: LD_VAR 0 3
61331: PUSH
61332: EMPTY
61333: LIST
61334: LIST
61335: LIST
61336: PPUSH
61337: CALL 72019 0 3
61341: ST_TO_ADDR
// exit ;
61342: POP
61343: POP
61344: POP
61345: POP
61346: GO 61521
// end ;
61348: GO 61259
61350: POP
61351: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61352: LD_ADDR_VAR 0 9
61356: PUSH
61357: LD_EXP 102
61361: PUSH
61362: LD_VAR 0 7
61366: ARRAY
61367: PPUSH
61368: LD_INT 2
61370: PUSH
61371: LD_INT 30
61373: PUSH
61374: LD_INT 0
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PUSH
61381: LD_INT 30
61383: PUSH
61384: LD_INT 1
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: LIST
61395: PPUSH
61396: CALL_OW 72
61400: ST_TO_ADDR
// if not depot then
61401: LD_VAR 0 9
61405: NOT
61406: IFFALSE 61410
// continue ;
61408: GO 61228
// for j in depot do
61410: LD_ADDR_VAR 0 8
61414: PUSH
61415: LD_VAR 0 9
61419: PUSH
61420: FOR_IN
61421: IFFALSE 61515
// if GetDistUnitXY ( j , x , y ) < 30 then
61423: LD_VAR 0 8
61427: PPUSH
61428: LD_VAR 0 2
61432: PPUSH
61433: LD_VAR 0 3
61437: PPUSH
61438: CALL_OW 297
61442: PUSH
61443: LD_INT 30
61445: LESS
61446: IFFALSE 61513
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61448: LD_ADDR_EXP 118
61452: PUSH
61453: LD_EXP 118
61457: PPUSH
61458: LD_VAR 0 7
61462: PUSH
61463: LD_EXP 118
61467: PUSH
61468: LD_VAR 0 7
61472: ARRAY
61473: PUSH
61474: LD_INT 1
61476: PLUS
61477: PUSH
61478: EMPTY
61479: LIST
61480: LIST
61481: PPUSH
61482: LD_VAR 0 4
61486: PUSH
61487: LD_VAR 0 2
61491: PUSH
61492: LD_VAR 0 3
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: LIST
61501: PPUSH
61502: CALL 72019 0 3
61506: ST_TO_ADDR
// exit ;
61507: POP
61508: POP
61509: POP
61510: POP
61511: GO 61521
// end ;
61513: GO 61420
61515: POP
61516: POP
// end ;
61517: GO 61228
61519: POP
61520: POP
// end ;
61521: LD_VAR 0 6
61525: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61526: LD_INT 0
61528: PPUSH
61529: PPUSH
61530: PPUSH
61531: PPUSH
// if not mc_bases or not skirmish then
61532: LD_EXP 102
61536: NOT
61537: PUSH
61538: LD_EXP 100
61542: NOT
61543: OR
61544: IFFALSE 61548
// exit ;
61546: GO 61825
// side := GetSide ( lab ) ;
61548: LD_ADDR_VAR 0 4
61552: PUSH
61553: LD_VAR 0 2
61557: PPUSH
61558: CALL_OW 255
61562: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61563: LD_VAR 0 4
61567: PUSH
61568: LD_EXP 128
61572: IN
61573: NOT
61574: PUSH
61575: LD_EXP 129
61579: NOT
61580: OR
61581: PUSH
61582: LD_EXP 102
61586: NOT
61587: OR
61588: IFFALSE 61592
// exit ;
61590: GO 61825
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61592: LD_ADDR_EXP 129
61596: PUSH
61597: LD_EXP 129
61601: PPUSH
61602: LD_VAR 0 4
61606: PPUSH
61607: LD_EXP 129
61611: PUSH
61612: LD_VAR 0 4
61616: ARRAY
61617: PUSH
61618: LD_VAR 0 1
61622: DIFF
61623: PPUSH
61624: CALL_OW 1
61628: ST_TO_ADDR
// for i = 1 to mc_bases do
61629: LD_ADDR_VAR 0 5
61633: PUSH
61634: DOUBLE
61635: LD_INT 1
61637: DEC
61638: ST_TO_ADDR
61639: LD_EXP 102
61643: PUSH
61644: FOR_TO
61645: IFFALSE 61823
// begin if lab in mc_bases [ i ] then
61647: LD_VAR 0 2
61651: PUSH
61652: LD_EXP 102
61656: PUSH
61657: LD_VAR 0 5
61661: ARRAY
61662: IN
61663: IFFALSE 61821
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61665: LD_VAR 0 1
61669: PUSH
61670: LD_INT 11
61672: PUSH
61673: LD_INT 4
61675: PUSH
61676: LD_INT 3
61678: PUSH
61679: LD_INT 2
61681: PUSH
61682: EMPTY
61683: LIST
61684: LIST
61685: LIST
61686: LIST
61687: IN
61688: PUSH
61689: LD_EXP 132
61693: PUSH
61694: LD_VAR 0 5
61698: ARRAY
61699: AND
61700: IFFALSE 61821
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61702: LD_ADDR_VAR 0 6
61706: PUSH
61707: LD_EXP 132
61711: PUSH
61712: LD_VAR 0 5
61716: ARRAY
61717: PUSH
61718: LD_INT 1
61720: ARRAY
61721: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61722: LD_ADDR_EXP 132
61726: PUSH
61727: LD_EXP 132
61731: PPUSH
61732: LD_VAR 0 5
61736: PPUSH
61737: EMPTY
61738: PPUSH
61739: CALL_OW 1
61743: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61744: LD_VAR 0 6
61748: PPUSH
61749: LD_INT 0
61751: PPUSH
61752: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61756: LD_VAR 0 6
61760: PPUSH
61761: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61765: LD_ADDR_EXP 131
61769: PUSH
61770: LD_EXP 131
61774: PPUSH
61775: LD_VAR 0 5
61779: PPUSH
61780: LD_EXP 131
61784: PUSH
61785: LD_VAR 0 5
61789: ARRAY
61790: PPUSH
61791: LD_INT 1
61793: PPUSH
61794: LD_VAR 0 6
61798: PPUSH
61799: CALL_OW 2
61803: PPUSH
61804: CALL_OW 1
61808: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61809: LD_VAR 0 5
61813: PPUSH
61814: LD_INT 112
61816: PPUSH
61817: CALL 38821 0 2
// end ; end ; end ;
61821: GO 61644
61823: POP
61824: POP
// end ;
61825: LD_VAR 0 3
61829: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61830: LD_INT 0
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
61836: PPUSH
61837: PPUSH
61838: PPUSH
61839: PPUSH
// if not mc_bases or not skirmish then
61840: LD_EXP 102
61844: NOT
61845: PUSH
61846: LD_EXP 100
61850: NOT
61851: OR
61852: IFFALSE 61856
// exit ;
61854: GO 63227
// for i = 1 to mc_bases do
61856: LD_ADDR_VAR 0 3
61860: PUSH
61861: DOUBLE
61862: LD_INT 1
61864: DEC
61865: ST_TO_ADDR
61866: LD_EXP 102
61870: PUSH
61871: FOR_TO
61872: IFFALSE 63225
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61874: LD_VAR 0 1
61878: PUSH
61879: LD_EXP 102
61883: PUSH
61884: LD_VAR 0 3
61888: ARRAY
61889: IN
61890: PUSH
61891: LD_VAR 0 1
61895: PUSH
61896: LD_EXP 109
61900: PUSH
61901: LD_VAR 0 3
61905: ARRAY
61906: IN
61907: OR
61908: PUSH
61909: LD_VAR 0 1
61913: PUSH
61914: LD_EXP 124
61918: PUSH
61919: LD_VAR 0 3
61923: ARRAY
61924: IN
61925: OR
61926: PUSH
61927: LD_VAR 0 1
61931: PUSH
61932: LD_EXP 121
61936: PUSH
61937: LD_VAR 0 3
61941: ARRAY
61942: IN
61943: OR
61944: PUSH
61945: LD_VAR 0 1
61949: PUSH
61950: LD_EXP 131
61954: PUSH
61955: LD_VAR 0 3
61959: ARRAY
61960: IN
61961: OR
61962: PUSH
61963: LD_VAR 0 1
61967: PUSH
61968: LD_EXP 132
61972: PUSH
61973: LD_VAR 0 3
61977: ARRAY
61978: IN
61979: OR
61980: IFFALSE 63223
// begin if un in mc_ape [ i ] then
61982: LD_VAR 0 1
61986: PUSH
61987: LD_EXP 131
61991: PUSH
61992: LD_VAR 0 3
61996: ARRAY
61997: IN
61998: IFFALSE 62037
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62000: LD_ADDR_EXP 131
62004: PUSH
62005: LD_EXP 131
62009: PPUSH
62010: LD_VAR 0 3
62014: PPUSH
62015: LD_EXP 131
62019: PUSH
62020: LD_VAR 0 3
62024: ARRAY
62025: PUSH
62026: LD_VAR 0 1
62030: DIFF
62031: PPUSH
62032: CALL_OW 1
62036: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62037: LD_VAR 0 1
62041: PUSH
62042: LD_EXP 132
62046: PUSH
62047: LD_VAR 0 3
62051: ARRAY
62052: IN
62053: IFFALSE 62077
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62055: LD_ADDR_EXP 132
62059: PUSH
62060: LD_EXP 132
62064: PPUSH
62065: LD_VAR 0 3
62069: PPUSH
62070: EMPTY
62071: PPUSH
62072: CALL_OW 1
62076: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62077: LD_VAR 0 1
62081: PPUSH
62082: CALL_OW 247
62086: PUSH
62087: LD_INT 2
62089: EQUAL
62090: PUSH
62091: LD_VAR 0 1
62095: PPUSH
62096: CALL_OW 110
62100: PUSH
62101: LD_INT 20
62103: EQUAL
62104: PUSH
62105: LD_VAR 0 1
62109: PUSH
62110: LD_EXP 124
62114: PUSH
62115: LD_VAR 0 3
62119: ARRAY
62120: IN
62121: OR
62122: PUSH
62123: LD_VAR 0 1
62127: PPUSH
62128: CALL_OW 264
62132: PUSH
62133: LD_INT 12
62135: PUSH
62136: LD_INT 51
62138: PUSH
62139: LD_EXP 96
62143: PUSH
62144: LD_INT 32
62146: PUSH
62147: LD_INT 13
62149: PUSH
62150: LD_INT 52
62152: PUSH
62153: LD_INT 31
62155: PUSH
62156: EMPTY
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: IN
62165: OR
62166: AND
62167: IFFALSE 62475
// begin if un in mc_defender [ i ] then
62169: LD_VAR 0 1
62173: PUSH
62174: LD_EXP 124
62178: PUSH
62179: LD_VAR 0 3
62183: ARRAY
62184: IN
62185: IFFALSE 62224
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62187: LD_ADDR_EXP 124
62191: PUSH
62192: LD_EXP 124
62196: PPUSH
62197: LD_VAR 0 3
62201: PPUSH
62202: LD_EXP 124
62206: PUSH
62207: LD_VAR 0 3
62211: ARRAY
62212: PUSH
62213: LD_VAR 0 1
62217: DIFF
62218: PPUSH
62219: CALL_OW 1
62223: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62224: LD_ADDR_VAR 0 8
62228: PUSH
62229: LD_VAR 0 3
62233: PPUSH
62234: LD_INT 3
62236: PPUSH
62237: CALL 58893 0 2
62241: ST_TO_ADDR
// if fac then
62242: LD_VAR 0 8
62246: IFFALSE 62475
// begin for j in fac do
62248: LD_ADDR_VAR 0 4
62252: PUSH
62253: LD_VAR 0 8
62257: PUSH
62258: FOR_IN
62259: IFFALSE 62473
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62261: LD_ADDR_VAR 0 9
62265: PUSH
62266: LD_VAR 0 8
62270: PPUSH
62271: LD_VAR 0 1
62275: PPUSH
62276: CALL_OW 265
62280: PPUSH
62281: LD_VAR 0 1
62285: PPUSH
62286: CALL_OW 262
62290: PPUSH
62291: LD_VAR 0 1
62295: PPUSH
62296: CALL_OW 263
62300: PPUSH
62301: LD_VAR 0 1
62305: PPUSH
62306: CALL_OW 264
62310: PPUSH
62311: CALL 69551 0 5
62315: ST_TO_ADDR
// if components then
62316: LD_VAR 0 9
62320: IFFALSE 62471
// begin if GetWeapon ( un ) = ar_control_tower then
62322: LD_VAR 0 1
62326: PPUSH
62327: CALL_OW 264
62331: PUSH
62332: LD_INT 31
62334: EQUAL
62335: IFFALSE 62452
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62337: LD_VAR 0 1
62341: PPUSH
62342: CALL_OW 311
62346: PPUSH
62347: LD_INT 0
62349: PPUSH
62350: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62354: LD_ADDR_EXP 142
62358: PUSH
62359: LD_EXP 142
62363: PPUSH
62364: LD_VAR 0 3
62368: PPUSH
62369: LD_EXP 142
62373: PUSH
62374: LD_VAR 0 3
62378: ARRAY
62379: PUSH
62380: LD_VAR 0 1
62384: PPUSH
62385: CALL_OW 311
62389: DIFF
62390: PPUSH
62391: CALL_OW 1
62395: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62396: LD_ADDR_VAR 0 7
62400: PUSH
62401: LD_EXP 123
62405: PUSH
62406: LD_VAR 0 3
62410: ARRAY
62411: PPUSH
62412: LD_INT 1
62414: PPUSH
62415: LD_VAR 0 9
62419: PPUSH
62420: CALL_OW 2
62424: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62425: LD_ADDR_EXP 123
62429: PUSH
62430: LD_EXP 123
62434: PPUSH
62435: LD_VAR 0 3
62439: PPUSH
62440: LD_VAR 0 7
62444: PPUSH
62445: CALL_OW 1
62449: ST_TO_ADDR
// end else
62450: GO 62469
// MC_InsertProduceList ( i , [ components ] ) ;
62452: LD_VAR 0 3
62456: PPUSH
62457: LD_VAR 0 9
62461: PUSH
62462: EMPTY
62463: LIST
62464: PPUSH
62465: CALL 58438 0 2
// break ;
62469: GO 62473
// end ; end ;
62471: GO 62258
62473: POP
62474: POP
// end ; end ; if GetType ( un ) = unit_building then
62475: LD_VAR 0 1
62479: PPUSH
62480: CALL_OW 247
62484: PUSH
62485: LD_INT 3
62487: EQUAL
62488: IFFALSE 62891
// begin btype := GetBType ( un ) ;
62490: LD_ADDR_VAR 0 5
62494: PUSH
62495: LD_VAR 0 1
62499: PPUSH
62500: CALL_OW 266
62504: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62505: LD_VAR 0 5
62509: PUSH
62510: LD_INT 29
62512: PUSH
62513: LD_INT 30
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: IN
62520: IFFALSE 62593
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62522: LD_VAR 0 1
62526: PPUSH
62527: CALL_OW 250
62531: PPUSH
62532: LD_VAR 0 1
62536: PPUSH
62537: CALL_OW 251
62541: PPUSH
62542: LD_VAR 0 1
62546: PPUSH
62547: CALL_OW 255
62551: PPUSH
62552: CALL_OW 440
62556: NOT
62557: IFFALSE 62593
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62559: LD_VAR 0 1
62563: PPUSH
62564: CALL_OW 250
62568: PPUSH
62569: LD_VAR 0 1
62573: PPUSH
62574: CALL_OW 251
62578: PPUSH
62579: LD_VAR 0 1
62583: PPUSH
62584: CALL_OW 255
62588: PPUSH
62589: CALL_OW 441
// end ; if btype = b_warehouse then
62593: LD_VAR 0 5
62597: PUSH
62598: LD_INT 1
62600: EQUAL
62601: IFFALSE 62619
// begin btype := b_depot ;
62603: LD_ADDR_VAR 0 5
62607: PUSH
62608: LD_INT 0
62610: ST_TO_ADDR
// pos := 1 ;
62611: LD_ADDR_VAR 0 6
62615: PUSH
62616: LD_INT 1
62618: ST_TO_ADDR
// end ; if btype = b_factory then
62619: LD_VAR 0 5
62623: PUSH
62624: LD_INT 3
62626: EQUAL
62627: IFFALSE 62645
// begin btype := b_workshop ;
62629: LD_ADDR_VAR 0 5
62633: PUSH
62634: LD_INT 2
62636: ST_TO_ADDR
// pos := 1 ;
62637: LD_ADDR_VAR 0 6
62641: PUSH
62642: LD_INT 1
62644: ST_TO_ADDR
// end ; if btype = b_barracks then
62645: LD_VAR 0 5
62649: PUSH
62650: LD_INT 5
62652: EQUAL
62653: IFFALSE 62663
// btype := b_armoury ;
62655: LD_ADDR_VAR 0 5
62659: PUSH
62660: LD_INT 4
62662: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62663: LD_VAR 0 5
62667: PUSH
62668: LD_INT 7
62670: PUSH
62671: LD_INT 8
62673: PUSH
62674: EMPTY
62675: LIST
62676: LIST
62677: IN
62678: IFFALSE 62688
// btype := b_lab ;
62680: LD_ADDR_VAR 0 5
62684: PUSH
62685: LD_INT 6
62687: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62688: LD_ADDR_EXP 107
62692: PUSH
62693: LD_EXP 107
62697: PPUSH
62698: LD_VAR 0 3
62702: PUSH
62703: LD_EXP 107
62707: PUSH
62708: LD_VAR 0 3
62712: ARRAY
62713: PUSH
62714: LD_INT 1
62716: PLUS
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: PPUSH
62722: LD_VAR 0 5
62726: PUSH
62727: LD_VAR 0 1
62731: PPUSH
62732: CALL_OW 250
62736: PUSH
62737: LD_VAR 0 1
62741: PPUSH
62742: CALL_OW 251
62746: PUSH
62747: LD_VAR 0 1
62751: PPUSH
62752: CALL_OW 254
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: LIST
62761: LIST
62762: PPUSH
62763: CALL 72019 0 3
62767: ST_TO_ADDR
// if pos = 1 then
62768: LD_VAR 0 6
62772: PUSH
62773: LD_INT 1
62775: EQUAL
62776: IFFALSE 62891
// begin tmp := mc_build_list [ i ] ;
62778: LD_ADDR_VAR 0 7
62782: PUSH
62783: LD_EXP 107
62787: PUSH
62788: LD_VAR 0 3
62792: ARRAY
62793: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62794: LD_VAR 0 7
62798: PPUSH
62799: LD_INT 2
62801: PUSH
62802: LD_INT 30
62804: PUSH
62805: LD_INT 0
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: PUSH
62812: LD_INT 30
62814: PUSH
62815: LD_INT 1
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: LIST
62826: PPUSH
62827: CALL_OW 72
62831: IFFALSE 62841
// pos := 2 ;
62833: LD_ADDR_VAR 0 6
62837: PUSH
62838: LD_INT 2
62840: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62841: LD_ADDR_VAR 0 7
62845: PUSH
62846: LD_VAR 0 7
62850: PPUSH
62851: LD_VAR 0 6
62855: PPUSH
62856: LD_VAR 0 7
62860: PPUSH
62861: CALL 72345 0 3
62865: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62866: LD_ADDR_EXP 107
62870: PUSH
62871: LD_EXP 107
62875: PPUSH
62876: LD_VAR 0 3
62880: PPUSH
62881: LD_VAR 0 7
62885: PPUSH
62886: CALL_OW 1
62890: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62891: LD_VAR 0 1
62895: PUSH
62896: LD_EXP 102
62900: PUSH
62901: LD_VAR 0 3
62905: ARRAY
62906: IN
62907: IFFALSE 62946
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62909: LD_ADDR_EXP 102
62913: PUSH
62914: LD_EXP 102
62918: PPUSH
62919: LD_VAR 0 3
62923: PPUSH
62924: LD_EXP 102
62928: PUSH
62929: LD_VAR 0 3
62933: ARRAY
62934: PUSH
62935: LD_VAR 0 1
62939: DIFF
62940: PPUSH
62941: CALL_OW 1
62945: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62946: LD_VAR 0 1
62950: PUSH
62951: LD_EXP 109
62955: PUSH
62956: LD_VAR 0 3
62960: ARRAY
62961: IN
62962: IFFALSE 63001
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62964: LD_ADDR_EXP 109
62968: PUSH
62969: LD_EXP 109
62973: PPUSH
62974: LD_VAR 0 3
62978: PPUSH
62979: LD_EXP 109
62983: PUSH
62984: LD_VAR 0 3
62988: ARRAY
62989: PUSH
62990: LD_VAR 0 1
62994: DIFF
62995: PPUSH
62996: CALL_OW 1
63000: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63001: LD_VAR 0 1
63005: PUSH
63006: LD_EXP 121
63010: PUSH
63011: LD_VAR 0 3
63015: ARRAY
63016: IN
63017: IFFALSE 63056
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63019: LD_ADDR_EXP 121
63023: PUSH
63024: LD_EXP 121
63028: PPUSH
63029: LD_VAR 0 3
63033: PPUSH
63034: LD_EXP 121
63038: PUSH
63039: LD_VAR 0 3
63043: ARRAY
63044: PUSH
63045: LD_VAR 0 1
63049: DIFF
63050: PPUSH
63051: CALL_OW 1
63055: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63056: LD_VAR 0 1
63060: PUSH
63061: LD_EXP 124
63065: PUSH
63066: LD_VAR 0 3
63070: ARRAY
63071: IN
63072: IFFALSE 63111
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63074: LD_ADDR_EXP 124
63078: PUSH
63079: LD_EXP 124
63083: PPUSH
63084: LD_VAR 0 3
63088: PPUSH
63089: LD_EXP 124
63093: PUSH
63094: LD_VAR 0 3
63098: ARRAY
63099: PUSH
63100: LD_VAR 0 1
63104: DIFF
63105: PPUSH
63106: CALL_OW 1
63110: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63111: LD_VAR 0 1
63115: PUSH
63116: LD_EXP 111
63120: PUSH
63121: LD_VAR 0 3
63125: ARRAY
63126: IN
63127: IFFALSE 63166
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63129: LD_ADDR_EXP 111
63133: PUSH
63134: LD_EXP 111
63138: PPUSH
63139: LD_VAR 0 3
63143: PPUSH
63144: LD_EXP 111
63148: PUSH
63149: LD_VAR 0 3
63153: ARRAY
63154: PUSH
63155: LD_VAR 0 1
63159: DIFF
63160: PPUSH
63161: CALL_OW 1
63165: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63166: LD_VAR 0 1
63170: PUSH
63171: LD_EXP 110
63175: PUSH
63176: LD_VAR 0 3
63180: ARRAY
63181: IN
63182: IFFALSE 63221
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63184: LD_ADDR_EXP 110
63188: PUSH
63189: LD_EXP 110
63193: PPUSH
63194: LD_VAR 0 3
63198: PPUSH
63199: LD_EXP 110
63203: PUSH
63204: LD_VAR 0 3
63208: ARRAY
63209: PUSH
63210: LD_VAR 0 1
63214: DIFF
63215: PPUSH
63216: CALL_OW 1
63220: ST_TO_ADDR
// end ; break ;
63221: GO 63225
// end ;
63223: GO 61871
63225: POP
63226: POP
// end ;
63227: LD_VAR 0 2
63231: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63232: LD_INT 0
63234: PPUSH
63235: PPUSH
63236: PPUSH
// if not mc_bases or not skirmish then
63237: LD_EXP 102
63241: NOT
63242: PUSH
63243: LD_EXP 100
63247: NOT
63248: OR
63249: IFFALSE 63253
// exit ;
63251: GO 63468
// for i = 1 to mc_bases do
63253: LD_ADDR_VAR 0 3
63257: PUSH
63258: DOUBLE
63259: LD_INT 1
63261: DEC
63262: ST_TO_ADDR
63263: LD_EXP 102
63267: PUSH
63268: FOR_TO
63269: IFFALSE 63466
// begin if building in mc_construct_list [ i ] then
63271: LD_VAR 0 1
63275: PUSH
63276: LD_EXP 109
63280: PUSH
63281: LD_VAR 0 3
63285: ARRAY
63286: IN
63287: IFFALSE 63464
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63289: LD_ADDR_EXP 109
63293: PUSH
63294: LD_EXP 109
63298: PPUSH
63299: LD_VAR 0 3
63303: PPUSH
63304: LD_EXP 109
63308: PUSH
63309: LD_VAR 0 3
63313: ARRAY
63314: PUSH
63315: LD_VAR 0 1
63319: DIFF
63320: PPUSH
63321: CALL_OW 1
63325: ST_TO_ADDR
// if building in mc_lab [ i ] then
63326: LD_VAR 0 1
63330: PUSH
63331: LD_EXP 135
63335: PUSH
63336: LD_VAR 0 3
63340: ARRAY
63341: IN
63342: IFFALSE 63397
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63344: LD_ADDR_EXP 136
63348: PUSH
63349: LD_EXP 136
63353: PPUSH
63354: LD_VAR 0 3
63358: PPUSH
63359: LD_EXP 136
63363: PUSH
63364: LD_VAR 0 3
63368: ARRAY
63369: PPUSH
63370: LD_INT 1
63372: PPUSH
63373: LD_EXP 136
63377: PUSH
63378: LD_VAR 0 3
63382: ARRAY
63383: PPUSH
63384: LD_INT 0
63386: PPUSH
63387: CALL 71437 0 4
63391: PPUSH
63392: CALL_OW 1
63396: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63397: LD_VAR 0 1
63401: PUSH
63402: LD_EXP 102
63406: PUSH
63407: LD_VAR 0 3
63411: ARRAY
63412: IN
63413: NOT
63414: IFFALSE 63460
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63416: LD_ADDR_EXP 102
63420: PUSH
63421: LD_EXP 102
63425: PPUSH
63426: LD_VAR 0 3
63430: PUSH
63431: LD_EXP 102
63435: PUSH
63436: LD_VAR 0 3
63440: ARRAY
63441: PUSH
63442: LD_INT 1
63444: PLUS
63445: PUSH
63446: EMPTY
63447: LIST
63448: LIST
63449: PPUSH
63450: LD_VAR 0 1
63454: PPUSH
63455: CALL 72019 0 3
63459: ST_TO_ADDR
// exit ;
63460: POP
63461: POP
63462: GO 63468
// end ; end ;
63464: GO 63268
63466: POP
63467: POP
// end ;
63468: LD_VAR 0 2
63472: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63473: LD_INT 0
63475: PPUSH
63476: PPUSH
63477: PPUSH
63478: PPUSH
63479: PPUSH
63480: PPUSH
63481: PPUSH
// if not mc_bases or not skirmish then
63482: LD_EXP 102
63486: NOT
63487: PUSH
63488: LD_EXP 100
63492: NOT
63493: OR
63494: IFFALSE 63498
// exit ;
63496: GO 64159
// for i = 1 to mc_bases do
63498: LD_ADDR_VAR 0 3
63502: PUSH
63503: DOUBLE
63504: LD_INT 1
63506: DEC
63507: ST_TO_ADDR
63508: LD_EXP 102
63512: PUSH
63513: FOR_TO
63514: IFFALSE 64157
// begin if building in mc_construct_list [ i ] then
63516: LD_VAR 0 1
63520: PUSH
63521: LD_EXP 109
63525: PUSH
63526: LD_VAR 0 3
63530: ARRAY
63531: IN
63532: IFFALSE 64155
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63534: LD_ADDR_EXP 109
63538: PUSH
63539: LD_EXP 109
63543: PPUSH
63544: LD_VAR 0 3
63548: PPUSH
63549: LD_EXP 109
63553: PUSH
63554: LD_VAR 0 3
63558: ARRAY
63559: PUSH
63560: LD_VAR 0 1
63564: DIFF
63565: PPUSH
63566: CALL_OW 1
63570: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63571: LD_ADDR_EXP 102
63575: PUSH
63576: LD_EXP 102
63580: PPUSH
63581: LD_VAR 0 3
63585: PUSH
63586: LD_EXP 102
63590: PUSH
63591: LD_VAR 0 3
63595: ARRAY
63596: PUSH
63597: LD_INT 1
63599: PLUS
63600: PUSH
63601: EMPTY
63602: LIST
63603: LIST
63604: PPUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: CALL 72019 0 3
63614: ST_TO_ADDR
// btype := GetBType ( building ) ;
63615: LD_ADDR_VAR 0 5
63619: PUSH
63620: LD_VAR 0 1
63624: PPUSH
63625: CALL_OW 266
63629: ST_TO_ADDR
// side := GetSide ( building ) ;
63630: LD_ADDR_VAR 0 8
63634: PUSH
63635: LD_VAR 0 1
63639: PPUSH
63640: CALL_OW 255
63644: ST_TO_ADDR
// if btype = b_lab then
63645: LD_VAR 0 5
63649: PUSH
63650: LD_INT 6
63652: EQUAL
63653: IFFALSE 63703
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63655: LD_ADDR_EXP 135
63659: PUSH
63660: LD_EXP 135
63664: PPUSH
63665: LD_VAR 0 3
63669: PUSH
63670: LD_EXP 135
63674: PUSH
63675: LD_VAR 0 3
63679: ARRAY
63680: PUSH
63681: LD_INT 1
63683: PLUS
63684: PUSH
63685: EMPTY
63686: LIST
63687: LIST
63688: PPUSH
63689: LD_VAR 0 1
63693: PPUSH
63694: CALL 72019 0 3
63698: ST_TO_ADDR
// exit ;
63699: POP
63700: POP
63701: GO 64159
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63703: LD_VAR 0 5
63707: PUSH
63708: LD_INT 0
63710: PUSH
63711: LD_INT 2
63713: PUSH
63714: LD_INT 4
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: LIST
63721: IN
63722: IFFALSE 63846
// begin if btype = b_armoury then
63724: LD_VAR 0 5
63728: PUSH
63729: LD_INT 4
63731: EQUAL
63732: IFFALSE 63742
// btype := b_barracks ;
63734: LD_ADDR_VAR 0 5
63738: PUSH
63739: LD_INT 5
63741: ST_TO_ADDR
// if btype = b_depot then
63742: LD_VAR 0 5
63746: PUSH
63747: LD_INT 0
63749: EQUAL
63750: IFFALSE 63760
// btype := b_warehouse ;
63752: LD_ADDR_VAR 0 5
63756: PUSH
63757: LD_INT 1
63759: ST_TO_ADDR
// if btype = b_workshop then
63760: LD_VAR 0 5
63764: PUSH
63765: LD_INT 2
63767: EQUAL
63768: IFFALSE 63778
// btype := b_factory ;
63770: LD_ADDR_VAR 0 5
63774: PUSH
63775: LD_INT 3
63777: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63778: LD_VAR 0 5
63782: PPUSH
63783: LD_VAR 0 8
63787: PPUSH
63788: CALL_OW 323
63792: PUSH
63793: LD_INT 1
63795: EQUAL
63796: IFFALSE 63842
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63798: LD_ADDR_EXP 134
63802: PUSH
63803: LD_EXP 134
63807: PPUSH
63808: LD_VAR 0 3
63812: PUSH
63813: LD_EXP 134
63817: PUSH
63818: LD_VAR 0 3
63822: ARRAY
63823: PUSH
63824: LD_INT 1
63826: PLUS
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: PPUSH
63832: LD_VAR 0 1
63836: PPUSH
63837: CALL 72019 0 3
63841: ST_TO_ADDR
// exit ;
63842: POP
63843: POP
63844: GO 64159
// end ; if btype in [ b_bunker , b_turret ] then
63846: LD_VAR 0 5
63850: PUSH
63851: LD_INT 32
63853: PUSH
63854: LD_INT 33
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: IN
63861: IFFALSE 64151
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63863: LD_ADDR_EXP 110
63867: PUSH
63868: LD_EXP 110
63872: PPUSH
63873: LD_VAR 0 3
63877: PUSH
63878: LD_EXP 110
63882: PUSH
63883: LD_VAR 0 3
63887: ARRAY
63888: PUSH
63889: LD_INT 1
63891: PLUS
63892: PUSH
63893: EMPTY
63894: LIST
63895: LIST
63896: PPUSH
63897: LD_VAR 0 1
63901: PPUSH
63902: CALL 72019 0 3
63906: ST_TO_ADDR
// if btype = b_bunker then
63907: LD_VAR 0 5
63911: PUSH
63912: LD_INT 32
63914: EQUAL
63915: IFFALSE 64151
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63917: LD_ADDR_EXP 111
63921: PUSH
63922: LD_EXP 111
63926: PPUSH
63927: LD_VAR 0 3
63931: PUSH
63932: LD_EXP 111
63936: PUSH
63937: LD_VAR 0 3
63941: ARRAY
63942: PUSH
63943: LD_INT 1
63945: PLUS
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PPUSH
63951: LD_VAR 0 1
63955: PPUSH
63956: CALL 72019 0 3
63960: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63961: LD_ADDR_VAR 0 6
63965: PUSH
63966: LD_EXP 102
63970: PUSH
63971: LD_VAR 0 3
63975: ARRAY
63976: PPUSH
63977: LD_INT 25
63979: PUSH
63980: LD_INT 1
63982: PUSH
63983: EMPTY
63984: LIST
63985: LIST
63986: PUSH
63987: LD_INT 3
63989: PUSH
63990: LD_INT 54
63992: PUSH
63993: EMPTY
63994: LIST
63995: PUSH
63996: EMPTY
63997: LIST
63998: LIST
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PPUSH
64004: CALL_OW 72
64008: ST_TO_ADDR
// if tmp then
64009: LD_VAR 0 6
64013: IFFALSE 64019
// exit ;
64015: POP
64016: POP
64017: GO 64159
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64019: LD_ADDR_VAR 0 6
64023: PUSH
64024: LD_EXP 102
64028: PUSH
64029: LD_VAR 0 3
64033: ARRAY
64034: PPUSH
64035: LD_INT 2
64037: PUSH
64038: LD_INT 30
64040: PUSH
64041: LD_INT 4
64043: PUSH
64044: EMPTY
64045: LIST
64046: LIST
64047: PUSH
64048: LD_INT 30
64050: PUSH
64051: LD_INT 5
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: LIST
64062: PPUSH
64063: CALL_OW 72
64067: ST_TO_ADDR
// if not tmp then
64068: LD_VAR 0 6
64072: NOT
64073: IFFALSE 64079
// exit ;
64075: POP
64076: POP
64077: GO 64159
// for j in tmp do
64079: LD_ADDR_VAR 0 4
64083: PUSH
64084: LD_VAR 0 6
64088: PUSH
64089: FOR_IN
64090: IFFALSE 64149
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64092: LD_ADDR_VAR 0 7
64096: PUSH
64097: LD_VAR 0 4
64101: PPUSH
64102: CALL_OW 313
64106: PPUSH
64107: LD_INT 25
64109: PUSH
64110: LD_INT 1
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PPUSH
64117: CALL_OW 72
64121: ST_TO_ADDR
// if units then
64122: LD_VAR 0 7
64126: IFFALSE 64147
// begin ComExitBuilding ( units [ 1 ] ) ;
64128: LD_VAR 0 7
64132: PUSH
64133: LD_INT 1
64135: ARRAY
64136: PPUSH
64137: CALL_OW 122
// exit ;
64141: POP
64142: POP
64143: POP
64144: POP
64145: GO 64159
// end ; end ;
64147: GO 64089
64149: POP
64150: POP
// end ; end ; exit ;
64151: POP
64152: POP
64153: GO 64159
// end ; end ;
64155: GO 63513
64157: POP
64158: POP
// end ;
64159: LD_VAR 0 2
64163: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64164: LD_INT 0
64166: PPUSH
64167: PPUSH
64168: PPUSH
64169: PPUSH
64170: PPUSH
64171: PPUSH
64172: PPUSH
// if not mc_bases or not skirmish then
64173: LD_EXP 102
64177: NOT
64178: PUSH
64179: LD_EXP 100
64183: NOT
64184: OR
64185: IFFALSE 64189
// exit ;
64187: GO 64420
// btype := GetBType ( building ) ;
64189: LD_ADDR_VAR 0 6
64193: PUSH
64194: LD_VAR 0 1
64198: PPUSH
64199: CALL_OW 266
64203: ST_TO_ADDR
// x := GetX ( building ) ;
64204: LD_ADDR_VAR 0 7
64208: PUSH
64209: LD_VAR 0 1
64213: PPUSH
64214: CALL_OW 250
64218: ST_TO_ADDR
// y := GetY ( building ) ;
64219: LD_ADDR_VAR 0 8
64223: PUSH
64224: LD_VAR 0 1
64228: PPUSH
64229: CALL_OW 251
64233: ST_TO_ADDR
// d := GetDir ( building ) ;
64234: LD_ADDR_VAR 0 9
64238: PUSH
64239: LD_VAR 0 1
64243: PPUSH
64244: CALL_OW 254
64248: ST_TO_ADDR
// for i = 1 to mc_bases do
64249: LD_ADDR_VAR 0 4
64253: PUSH
64254: DOUBLE
64255: LD_INT 1
64257: DEC
64258: ST_TO_ADDR
64259: LD_EXP 102
64263: PUSH
64264: FOR_TO
64265: IFFALSE 64418
// begin if not mc_build_list [ i ] then
64267: LD_EXP 107
64271: PUSH
64272: LD_VAR 0 4
64276: ARRAY
64277: NOT
64278: IFFALSE 64282
// continue ;
64280: GO 64264
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64282: LD_VAR 0 6
64286: PUSH
64287: LD_VAR 0 7
64291: PUSH
64292: LD_VAR 0 8
64296: PUSH
64297: LD_VAR 0 9
64301: PUSH
64302: EMPTY
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: PPUSH
64308: LD_EXP 107
64312: PUSH
64313: LD_VAR 0 4
64317: ARRAY
64318: PUSH
64319: LD_INT 1
64321: ARRAY
64322: PPUSH
64323: CALL 78188 0 2
64327: IFFALSE 64416
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64329: LD_ADDR_EXP 107
64333: PUSH
64334: LD_EXP 107
64338: PPUSH
64339: LD_VAR 0 4
64343: PPUSH
64344: LD_EXP 107
64348: PUSH
64349: LD_VAR 0 4
64353: ARRAY
64354: PPUSH
64355: LD_INT 1
64357: PPUSH
64358: CALL_OW 3
64362: PPUSH
64363: CALL_OW 1
64367: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64368: LD_ADDR_EXP 109
64372: PUSH
64373: LD_EXP 109
64377: PPUSH
64378: LD_VAR 0 4
64382: PUSH
64383: LD_EXP 109
64387: PUSH
64388: LD_VAR 0 4
64392: ARRAY
64393: PUSH
64394: LD_INT 1
64396: PLUS
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: PPUSH
64402: LD_VAR 0 1
64406: PPUSH
64407: CALL 72019 0 3
64411: ST_TO_ADDR
// exit ;
64412: POP
64413: POP
64414: GO 64420
// end ; end ;
64416: GO 64264
64418: POP
64419: POP
// end ;
64420: LD_VAR 0 3
64424: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64425: LD_INT 0
64427: PPUSH
64428: PPUSH
64429: PPUSH
// if not mc_bases or not skirmish then
64430: LD_EXP 102
64434: NOT
64435: PUSH
64436: LD_EXP 100
64440: NOT
64441: OR
64442: IFFALSE 64446
// exit ;
64444: GO 64636
// for i = 1 to mc_bases do
64446: LD_ADDR_VAR 0 4
64450: PUSH
64451: DOUBLE
64452: LD_INT 1
64454: DEC
64455: ST_TO_ADDR
64456: LD_EXP 102
64460: PUSH
64461: FOR_TO
64462: IFFALSE 64549
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64464: LD_VAR 0 1
64468: PUSH
64469: LD_EXP 110
64473: PUSH
64474: LD_VAR 0 4
64478: ARRAY
64479: IN
64480: PUSH
64481: LD_VAR 0 1
64485: PUSH
64486: LD_EXP 111
64490: PUSH
64491: LD_VAR 0 4
64495: ARRAY
64496: IN
64497: NOT
64498: AND
64499: IFFALSE 64547
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64501: LD_ADDR_EXP 111
64505: PUSH
64506: LD_EXP 111
64510: PPUSH
64511: LD_VAR 0 4
64515: PUSH
64516: LD_EXP 111
64520: PUSH
64521: LD_VAR 0 4
64525: ARRAY
64526: PUSH
64527: LD_INT 1
64529: PLUS
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PPUSH
64535: LD_VAR 0 1
64539: PPUSH
64540: CALL 72019 0 3
64544: ST_TO_ADDR
// break ;
64545: GO 64549
// end ; end ;
64547: GO 64461
64549: POP
64550: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64551: LD_VAR 0 1
64555: PPUSH
64556: CALL_OW 257
64560: PUSH
64561: LD_EXP 128
64565: IN
64566: PUSH
64567: LD_VAR 0 1
64571: PPUSH
64572: CALL_OW 266
64576: PUSH
64577: LD_INT 5
64579: EQUAL
64580: AND
64581: PUSH
64582: LD_VAR 0 2
64586: PPUSH
64587: CALL_OW 110
64591: PUSH
64592: LD_INT 18
64594: NONEQUAL
64595: AND
64596: IFFALSE 64636
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64598: LD_VAR 0 2
64602: PPUSH
64603: CALL_OW 257
64607: PUSH
64608: LD_INT 5
64610: PUSH
64611: LD_INT 8
64613: PUSH
64614: LD_INT 9
64616: PUSH
64617: EMPTY
64618: LIST
64619: LIST
64620: LIST
64621: IN
64622: IFFALSE 64636
// SetClass ( unit , 1 ) ;
64624: LD_VAR 0 2
64628: PPUSH
64629: LD_INT 1
64631: PPUSH
64632: CALL_OW 336
// end ;
64636: LD_VAR 0 3
64640: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64641: LD_INT 0
64643: PPUSH
64644: PPUSH
// if not mc_bases or not skirmish then
64645: LD_EXP 102
64649: NOT
64650: PUSH
64651: LD_EXP 100
64655: NOT
64656: OR
64657: IFFALSE 64661
// exit ;
64659: GO 64777
// if GetLives ( abandoned_vehicle ) > 250 then
64661: LD_VAR 0 2
64665: PPUSH
64666: CALL_OW 256
64670: PUSH
64671: LD_INT 250
64673: GREATER
64674: IFFALSE 64678
// exit ;
64676: GO 64777
// for i = 1 to mc_bases do
64678: LD_ADDR_VAR 0 6
64682: PUSH
64683: DOUBLE
64684: LD_INT 1
64686: DEC
64687: ST_TO_ADDR
64688: LD_EXP 102
64692: PUSH
64693: FOR_TO
64694: IFFALSE 64775
// begin if driver in mc_bases [ i ] then
64696: LD_VAR 0 1
64700: PUSH
64701: LD_EXP 102
64705: PUSH
64706: LD_VAR 0 6
64710: ARRAY
64711: IN
64712: IFFALSE 64773
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64714: LD_VAR 0 1
64718: PPUSH
64719: LD_EXP 102
64723: PUSH
64724: LD_VAR 0 6
64728: ARRAY
64729: PPUSH
64730: LD_INT 2
64732: PUSH
64733: LD_INT 30
64735: PUSH
64736: LD_INT 0
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 30
64745: PUSH
64746: LD_INT 1
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: LIST
64757: PPUSH
64758: CALL_OW 72
64762: PUSH
64763: LD_INT 1
64765: ARRAY
64766: PPUSH
64767: CALL_OW 112
// break ;
64771: GO 64775
// end ; end ;
64773: GO 64693
64775: POP
64776: POP
// end ; end_of_file
64777: LD_VAR 0 5
64781: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64782: LD_INT 0
64784: PPUSH
64785: PPUSH
// if exist_mode then
64786: LD_VAR 0 2
64790: IFFALSE 64815
// unit := CreateCharacter ( prefix & ident ) else
64792: LD_ADDR_VAR 0 5
64796: PUSH
64797: LD_VAR 0 3
64801: PUSH
64802: LD_VAR 0 1
64806: STR
64807: PPUSH
64808: CALL_OW 34
64812: ST_TO_ADDR
64813: GO 64830
// unit := NewCharacter ( ident ) ;
64815: LD_ADDR_VAR 0 5
64819: PUSH
64820: LD_VAR 0 1
64824: PPUSH
64825: CALL_OW 25
64829: ST_TO_ADDR
// result := unit ;
64830: LD_ADDR_VAR 0 4
64834: PUSH
64835: LD_VAR 0 5
64839: ST_TO_ADDR
// end ;
64840: LD_VAR 0 4
64844: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64845: LD_INT 0
64847: PPUSH
64848: PPUSH
// if not side or not nation then
64849: LD_VAR 0 1
64853: NOT
64854: PUSH
64855: LD_VAR 0 2
64859: NOT
64860: OR
64861: IFFALSE 64865
// exit ;
64863: GO 65509
// case nation of nation_american :
64865: LD_VAR 0 2
64869: PUSH
64870: LD_INT 1
64872: DOUBLE
64873: EQUAL
64874: IFTRUE 64878
64876: GO 65052
64878: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64879: LD_ADDR_VAR 0 4
64883: PUSH
64884: LD_INT 35
64886: PUSH
64887: LD_INT 45
64889: PUSH
64890: LD_INT 46
64892: PUSH
64893: LD_INT 47
64895: PUSH
64896: LD_INT 1
64898: PUSH
64899: LD_INT 2
64901: PUSH
64902: LD_INT 6
64904: PUSH
64905: LD_INT 15
64907: PUSH
64908: LD_INT 16
64910: PUSH
64911: LD_INT 7
64913: PUSH
64914: LD_INT 12
64916: PUSH
64917: LD_INT 13
64919: PUSH
64920: LD_INT 10
64922: PUSH
64923: LD_INT 14
64925: PUSH
64926: LD_INT 20
64928: PUSH
64929: LD_INT 21
64931: PUSH
64932: LD_INT 22
64934: PUSH
64935: LD_INT 25
64937: PUSH
64938: LD_INT 32
64940: PUSH
64941: LD_INT 27
64943: PUSH
64944: LD_INT 36
64946: PUSH
64947: LD_INT 69
64949: PUSH
64950: LD_INT 39
64952: PUSH
64953: LD_INT 34
64955: PUSH
64956: LD_INT 40
64958: PUSH
64959: LD_INT 48
64961: PUSH
64962: LD_INT 49
64964: PUSH
64965: LD_INT 50
64967: PUSH
64968: LD_INT 51
64970: PUSH
64971: LD_INT 52
64973: PUSH
64974: LD_INT 53
64976: PUSH
64977: LD_INT 54
64979: PUSH
64980: LD_INT 55
64982: PUSH
64983: LD_INT 56
64985: PUSH
64986: LD_INT 57
64988: PUSH
64989: LD_INT 58
64991: PUSH
64992: LD_INT 59
64994: PUSH
64995: LD_INT 60
64997: PUSH
64998: LD_INT 61
65000: PUSH
65001: LD_INT 62
65003: PUSH
65004: LD_INT 80
65006: PUSH
65007: EMPTY
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: LIST
65013: LIST
65014: LIST
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: LIST
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: LIST
65046: LIST
65047: LIST
65048: LIST
65049: ST_TO_ADDR
65050: GO 65433
65052: LD_INT 2
65054: DOUBLE
65055: EQUAL
65056: IFTRUE 65060
65058: GO 65242
65060: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65061: LD_ADDR_VAR 0 4
65065: PUSH
65066: LD_INT 35
65068: PUSH
65069: LD_INT 45
65071: PUSH
65072: LD_INT 46
65074: PUSH
65075: LD_INT 47
65077: PUSH
65078: LD_INT 70
65080: PUSH
65081: LD_INT 1
65083: PUSH
65084: LD_INT 11
65086: PUSH
65087: LD_INT 3
65089: PUSH
65090: LD_INT 4
65092: PUSH
65093: LD_INT 5
65095: PUSH
65096: LD_INT 6
65098: PUSH
65099: LD_INT 15
65101: PUSH
65102: LD_INT 18
65104: PUSH
65105: LD_INT 7
65107: PUSH
65108: LD_INT 17
65110: PUSH
65111: LD_INT 8
65113: PUSH
65114: LD_INT 20
65116: PUSH
65117: LD_INT 21
65119: PUSH
65120: LD_INT 22
65122: PUSH
65123: LD_INT 72
65125: PUSH
65126: LD_INT 26
65128: PUSH
65129: LD_INT 69
65131: PUSH
65132: LD_INT 39
65134: PUSH
65135: LD_INT 40
65137: PUSH
65138: LD_INT 41
65140: PUSH
65141: LD_INT 42
65143: PUSH
65144: LD_INT 43
65146: PUSH
65147: LD_INT 48
65149: PUSH
65150: LD_INT 49
65152: PUSH
65153: LD_INT 50
65155: PUSH
65156: LD_INT 51
65158: PUSH
65159: LD_INT 52
65161: PUSH
65162: LD_INT 53
65164: PUSH
65165: LD_INT 54
65167: PUSH
65168: LD_INT 55
65170: PUSH
65171: LD_INT 56
65173: PUSH
65174: LD_INT 60
65176: PUSH
65177: LD_INT 61
65179: PUSH
65180: LD_INT 62
65182: PUSH
65183: LD_INT 66
65185: PUSH
65186: LD_INT 67
65188: PUSH
65189: LD_INT 68
65191: PUSH
65192: LD_INT 81
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: LIST
65207: LIST
65208: LIST
65209: LIST
65210: LIST
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: ST_TO_ADDR
65240: GO 65433
65242: LD_INT 3
65244: DOUBLE
65245: EQUAL
65246: IFTRUE 65250
65248: GO 65432
65250: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65251: LD_ADDR_VAR 0 4
65255: PUSH
65256: LD_INT 46
65258: PUSH
65259: LD_INT 47
65261: PUSH
65262: LD_INT 1
65264: PUSH
65265: LD_INT 2
65267: PUSH
65268: LD_INT 11
65270: PUSH
65271: LD_INT 9
65273: PUSH
65274: LD_INT 20
65276: PUSH
65277: LD_INT 19
65279: PUSH
65280: LD_INT 21
65282: PUSH
65283: LD_INT 24
65285: PUSH
65286: LD_INT 22
65288: PUSH
65289: LD_INT 25
65291: PUSH
65292: LD_INT 28
65294: PUSH
65295: LD_INT 29
65297: PUSH
65298: LD_INT 30
65300: PUSH
65301: LD_INT 31
65303: PUSH
65304: LD_INT 37
65306: PUSH
65307: LD_INT 38
65309: PUSH
65310: LD_INT 32
65312: PUSH
65313: LD_INT 27
65315: PUSH
65316: LD_INT 33
65318: PUSH
65319: LD_INT 69
65321: PUSH
65322: LD_INT 39
65324: PUSH
65325: LD_INT 34
65327: PUSH
65328: LD_INT 40
65330: PUSH
65331: LD_INT 71
65333: PUSH
65334: LD_INT 23
65336: PUSH
65337: LD_INT 44
65339: PUSH
65340: LD_INT 48
65342: PUSH
65343: LD_INT 49
65345: PUSH
65346: LD_INT 50
65348: PUSH
65349: LD_INT 51
65351: PUSH
65352: LD_INT 52
65354: PUSH
65355: LD_INT 53
65357: PUSH
65358: LD_INT 54
65360: PUSH
65361: LD_INT 55
65363: PUSH
65364: LD_INT 56
65366: PUSH
65367: LD_INT 57
65369: PUSH
65370: LD_INT 58
65372: PUSH
65373: LD_INT 59
65375: PUSH
65376: LD_INT 63
65378: PUSH
65379: LD_INT 64
65381: PUSH
65382: LD_INT 65
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: LIST
65414: LIST
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: ST_TO_ADDR
65430: GO 65433
65432: POP
// if state > - 1 and state < 3 then
65433: LD_VAR 0 3
65437: PUSH
65438: LD_INT 1
65440: NEG
65441: GREATER
65442: PUSH
65443: LD_VAR 0 3
65447: PUSH
65448: LD_INT 3
65450: LESS
65451: AND
65452: IFFALSE 65509
// for i in result do
65454: LD_ADDR_VAR 0 5
65458: PUSH
65459: LD_VAR 0 4
65463: PUSH
65464: FOR_IN
65465: IFFALSE 65507
// if GetTech ( i , side ) <> state then
65467: LD_VAR 0 5
65471: PPUSH
65472: LD_VAR 0 1
65476: PPUSH
65477: CALL_OW 321
65481: PUSH
65482: LD_VAR 0 3
65486: NONEQUAL
65487: IFFALSE 65505
// result := result diff i ;
65489: LD_ADDR_VAR 0 4
65493: PUSH
65494: LD_VAR 0 4
65498: PUSH
65499: LD_VAR 0 5
65503: DIFF
65504: ST_TO_ADDR
65505: GO 65464
65507: POP
65508: POP
// end ;
65509: LD_VAR 0 4
65513: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65514: LD_INT 0
65516: PPUSH
65517: PPUSH
65518: PPUSH
// result := true ;
65519: LD_ADDR_VAR 0 3
65523: PUSH
65524: LD_INT 1
65526: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65527: LD_ADDR_VAR 0 5
65531: PUSH
65532: LD_VAR 0 2
65536: PPUSH
65537: CALL_OW 480
65541: ST_TO_ADDR
// if not tmp then
65542: LD_VAR 0 5
65546: NOT
65547: IFFALSE 65551
// exit ;
65549: GO 65600
// for i in tmp do
65551: LD_ADDR_VAR 0 4
65555: PUSH
65556: LD_VAR 0 5
65560: PUSH
65561: FOR_IN
65562: IFFALSE 65598
// if GetTech ( i , side ) <> state_researched then
65564: LD_VAR 0 4
65568: PPUSH
65569: LD_VAR 0 1
65573: PPUSH
65574: CALL_OW 321
65578: PUSH
65579: LD_INT 2
65581: NONEQUAL
65582: IFFALSE 65596
// begin result := false ;
65584: LD_ADDR_VAR 0 3
65588: PUSH
65589: LD_INT 0
65591: ST_TO_ADDR
// exit ;
65592: POP
65593: POP
65594: GO 65600
// end ;
65596: GO 65561
65598: POP
65599: POP
// end ;
65600: LD_VAR 0 3
65604: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65605: LD_INT 0
65607: PPUSH
65608: PPUSH
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
65614: PPUSH
65615: PPUSH
65616: PPUSH
65617: PPUSH
65618: PPUSH
65619: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65620: LD_VAR 0 1
65624: NOT
65625: PUSH
65626: LD_VAR 0 1
65630: PPUSH
65631: CALL_OW 257
65635: PUSH
65636: LD_INT 9
65638: NONEQUAL
65639: OR
65640: IFFALSE 65644
// exit ;
65642: GO 66217
// side := GetSide ( unit ) ;
65644: LD_ADDR_VAR 0 9
65648: PUSH
65649: LD_VAR 0 1
65653: PPUSH
65654: CALL_OW 255
65658: ST_TO_ADDR
// tech_space := tech_spacanom ;
65659: LD_ADDR_VAR 0 12
65663: PUSH
65664: LD_INT 29
65666: ST_TO_ADDR
// tech_time := tech_taurad ;
65667: LD_ADDR_VAR 0 13
65671: PUSH
65672: LD_INT 28
65674: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65675: LD_ADDR_VAR 0 11
65679: PUSH
65680: LD_VAR 0 1
65684: PPUSH
65685: CALL_OW 310
65689: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65690: LD_VAR 0 11
65694: PPUSH
65695: CALL_OW 247
65699: PUSH
65700: LD_INT 2
65702: EQUAL
65703: IFFALSE 65707
// exit ;
65705: GO 66217
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65707: LD_ADDR_VAR 0 8
65711: PUSH
65712: LD_INT 81
65714: PUSH
65715: LD_VAR 0 9
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: PUSH
65724: LD_INT 3
65726: PUSH
65727: LD_INT 21
65729: PUSH
65730: LD_INT 3
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: EMPTY
65738: LIST
65739: LIST
65740: PUSH
65741: EMPTY
65742: LIST
65743: LIST
65744: PPUSH
65745: CALL_OW 69
65749: ST_TO_ADDR
// if not tmp then
65750: LD_VAR 0 8
65754: NOT
65755: IFFALSE 65759
// exit ;
65757: GO 66217
// if in_unit then
65759: LD_VAR 0 11
65763: IFFALSE 65787
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65765: LD_ADDR_VAR 0 10
65769: PUSH
65770: LD_VAR 0 8
65774: PPUSH
65775: LD_VAR 0 11
65779: PPUSH
65780: CALL_OW 74
65784: ST_TO_ADDR
65785: GO 65807
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65787: LD_ADDR_VAR 0 10
65791: PUSH
65792: LD_VAR 0 8
65796: PPUSH
65797: LD_VAR 0 1
65801: PPUSH
65802: CALL_OW 74
65806: ST_TO_ADDR
// if not enemy then
65807: LD_VAR 0 10
65811: NOT
65812: IFFALSE 65816
// exit ;
65814: GO 66217
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65816: LD_VAR 0 11
65820: PUSH
65821: LD_VAR 0 11
65825: PPUSH
65826: LD_VAR 0 10
65830: PPUSH
65831: CALL_OW 296
65835: PUSH
65836: LD_INT 13
65838: GREATER
65839: AND
65840: PUSH
65841: LD_VAR 0 1
65845: PPUSH
65846: LD_VAR 0 10
65850: PPUSH
65851: CALL_OW 296
65855: PUSH
65856: LD_INT 12
65858: GREATER
65859: OR
65860: IFFALSE 65864
// exit ;
65862: GO 66217
// missile := [ 1 ] ;
65864: LD_ADDR_VAR 0 14
65868: PUSH
65869: LD_INT 1
65871: PUSH
65872: EMPTY
65873: LIST
65874: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65875: LD_VAR 0 9
65879: PPUSH
65880: LD_VAR 0 12
65884: PPUSH
65885: CALL_OW 325
65889: IFFALSE 65918
// missile := Insert ( missile , missile + 1 , 2 ) ;
65891: LD_ADDR_VAR 0 14
65895: PUSH
65896: LD_VAR 0 14
65900: PPUSH
65901: LD_VAR 0 14
65905: PUSH
65906: LD_INT 1
65908: PLUS
65909: PPUSH
65910: LD_INT 2
65912: PPUSH
65913: CALL_OW 2
65917: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65918: LD_VAR 0 9
65922: PPUSH
65923: LD_VAR 0 13
65927: PPUSH
65928: CALL_OW 325
65932: PUSH
65933: LD_VAR 0 10
65937: PPUSH
65938: CALL_OW 255
65942: PPUSH
65943: LD_VAR 0 13
65947: PPUSH
65948: CALL_OW 325
65952: NOT
65953: AND
65954: IFFALSE 65983
// missile := Insert ( missile , missile + 1 , 3 ) ;
65956: LD_ADDR_VAR 0 14
65960: PUSH
65961: LD_VAR 0 14
65965: PPUSH
65966: LD_VAR 0 14
65970: PUSH
65971: LD_INT 1
65973: PLUS
65974: PPUSH
65975: LD_INT 3
65977: PPUSH
65978: CALL_OW 2
65982: ST_TO_ADDR
// if missile < 2 then
65983: LD_VAR 0 14
65987: PUSH
65988: LD_INT 2
65990: LESS
65991: IFFALSE 65995
// exit ;
65993: GO 66217
// x := GetX ( enemy ) ;
65995: LD_ADDR_VAR 0 4
65999: PUSH
66000: LD_VAR 0 10
66004: PPUSH
66005: CALL_OW 250
66009: ST_TO_ADDR
// y := GetY ( enemy ) ;
66010: LD_ADDR_VAR 0 5
66014: PUSH
66015: LD_VAR 0 10
66019: PPUSH
66020: CALL_OW 251
66024: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66025: LD_ADDR_VAR 0 6
66029: PUSH
66030: LD_VAR 0 4
66034: PUSH
66035: LD_INT 1
66037: NEG
66038: PPUSH
66039: LD_INT 1
66041: PPUSH
66042: CALL_OW 12
66046: PLUS
66047: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66048: LD_ADDR_VAR 0 7
66052: PUSH
66053: LD_VAR 0 5
66057: PUSH
66058: LD_INT 1
66060: NEG
66061: PPUSH
66062: LD_INT 1
66064: PPUSH
66065: CALL_OW 12
66069: PLUS
66070: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66071: LD_VAR 0 6
66075: PPUSH
66076: LD_VAR 0 7
66080: PPUSH
66081: CALL_OW 488
66085: NOT
66086: IFFALSE 66108
// begin _x := x ;
66088: LD_ADDR_VAR 0 6
66092: PUSH
66093: LD_VAR 0 4
66097: ST_TO_ADDR
// _y := y ;
66098: LD_ADDR_VAR 0 7
66102: PUSH
66103: LD_VAR 0 5
66107: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66108: LD_ADDR_VAR 0 3
66112: PUSH
66113: LD_INT 1
66115: PPUSH
66116: LD_VAR 0 14
66120: PPUSH
66121: CALL_OW 12
66125: ST_TO_ADDR
// case i of 1 :
66126: LD_VAR 0 3
66130: PUSH
66131: LD_INT 1
66133: DOUBLE
66134: EQUAL
66135: IFTRUE 66139
66137: GO 66156
66139: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66140: LD_VAR 0 1
66144: PPUSH
66145: LD_VAR 0 10
66149: PPUSH
66150: CALL_OW 115
66154: GO 66217
66156: LD_INT 2
66158: DOUBLE
66159: EQUAL
66160: IFTRUE 66164
66162: GO 66186
66164: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66165: LD_VAR 0 1
66169: PPUSH
66170: LD_VAR 0 6
66174: PPUSH
66175: LD_VAR 0 7
66179: PPUSH
66180: CALL_OW 153
66184: GO 66217
66186: LD_INT 3
66188: DOUBLE
66189: EQUAL
66190: IFTRUE 66194
66192: GO 66216
66194: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66195: LD_VAR 0 1
66199: PPUSH
66200: LD_VAR 0 6
66204: PPUSH
66205: LD_VAR 0 7
66209: PPUSH
66210: CALL_OW 154
66214: GO 66217
66216: POP
// end ;
66217: LD_VAR 0 2
66221: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66222: LD_INT 0
66224: PPUSH
66225: PPUSH
66226: PPUSH
66227: PPUSH
66228: PPUSH
66229: PPUSH
// if not unit or not building then
66230: LD_VAR 0 1
66234: NOT
66235: PUSH
66236: LD_VAR 0 2
66240: NOT
66241: OR
66242: IFFALSE 66246
// exit ;
66244: GO 66404
// x := GetX ( building ) ;
66246: LD_ADDR_VAR 0 5
66250: PUSH
66251: LD_VAR 0 2
66255: PPUSH
66256: CALL_OW 250
66260: ST_TO_ADDR
// y := GetY ( building ) ;
66261: LD_ADDR_VAR 0 6
66265: PUSH
66266: LD_VAR 0 2
66270: PPUSH
66271: CALL_OW 251
66275: ST_TO_ADDR
// for i = 0 to 5 do
66276: LD_ADDR_VAR 0 4
66280: PUSH
66281: DOUBLE
66282: LD_INT 0
66284: DEC
66285: ST_TO_ADDR
66286: LD_INT 5
66288: PUSH
66289: FOR_TO
66290: IFFALSE 66402
// begin _x := ShiftX ( x , i , 3 ) ;
66292: LD_ADDR_VAR 0 7
66296: PUSH
66297: LD_VAR 0 5
66301: PPUSH
66302: LD_VAR 0 4
66306: PPUSH
66307: LD_INT 3
66309: PPUSH
66310: CALL_OW 272
66314: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66315: LD_ADDR_VAR 0 8
66319: PUSH
66320: LD_VAR 0 6
66324: PPUSH
66325: LD_VAR 0 4
66329: PPUSH
66330: LD_INT 3
66332: PPUSH
66333: CALL_OW 273
66337: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66338: LD_VAR 0 7
66342: PPUSH
66343: LD_VAR 0 8
66347: PPUSH
66348: CALL_OW 488
66352: NOT
66353: IFFALSE 66357
// continue ;
66355: GO 66289
// if HexInfo ( _x , _y ) = 0 then
66357: LD_VAR 0 7
66361: PPUSH
66362: LD_VAR 0 8
66366: PPUSH
66367: CALL_OW 428
66371: PUSH
66372: LD_INT 0
66374: EQUAL
66375: IFFALSE 66400
// begin ComMoveXY ( unit , _x , _y ) ;
66377: LD_VAR 0 1
66381: PPUSH
66382: LD_VAR 0 7
66386: PPUSH
66387: LD_VAR 0 8
66391: PPUSH
66392: CALL_OW 111
// exit ;
66396: POP
66397: POP
66398: GO 66404
// end ; end ;
66400: GO 66289
66402: POP
66403: POP
// end ;
66404: LD_VAR 0 3
66408: RET
// export function ScanBase ( side , base_area ) ; begin
66409: LD_INT 0
66411: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66412: LD_ADDR_VAR 0 3
66416: PUSH
66417: LD_VAR 0 2
66421: PPUSH
66422: LD_INT 81
66424: PUSH
66425: LD_VAR 0 1
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PPUSH
66434: CALL_OW 70
66438: ST_TO_ADDR
// end ;
66439: LD_VAR 0 3
66443: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66444: LD_INT 0
66446: PPUSH
66447: PPUSH
66448: PPUSH
66449: PPUSH
66450: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66451: LD_VAR 0 1
66455: NOT
66456: PUSH
66457: LD_EXP 102
66461: PUSH
66462: LD_VAR 0 1
66466: ARRAY
66467: NOT
66468: OR
66469: PUSH
66470: LD_VAR 0 2
66474: NOT
66475: OR
66476: PUSH
66477: LD_VAR 0 3
66481: NOT
66482: OR
66483: IFFALSE 66487
// exit ;
66485: GO 67000
// side := mc_sides [ base ] ;
66487: LD_ADDR_VAR 0 6
66491: PUSH
66492: LD_EXP 128
66496: PUSH
66497: LD_VAR 0 1
66501: ARRAY
66502: ST_TO_ADDR
// if not side then
66503: LD_VAR 0 6
66507: NOT
66508: IFFALSE 66512
// exit ;
66510: GO 67000
// for i in solds do
66512: LD_ADDR_VAR 0 7
66516: PUSH
66517: LD_VAR 0 2
66521: PUSH
66522: FOR_IN
66523: IFFALSE 66584
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66525: LD_VAR 0 7
66529: PPUSH
66530: CALL_OW 310
66534: PPUSH
66535: CALL_OW 266
66539: PUSH
66540: LD_INT 32
66542: PUSH
66543: LD_INT 31
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: IN
66550: IFFALSE 66570
// solds := solds diff i else
66552: LD_ADDR_VAR 0 2
66556: PUSH
66557: LD_VAR 0 2
66561: PUSH
66562: LD_VAR 0 7
66566: DIFF
66567: ST_TO_ADDR
66568: GO 66582
// SetTag ( i , 18 ) ;
66570: LD_VAR 0 7
66574: PPUSH
66575: LD_INT 18
66577: PPUSH
66578: CALL_OW 109
66582: GO 66522
66584: POP
66585: POP
// if not solds then
66586: LD_VAR 0 2
66590: NOT
66591: IFFALSE 66595
// exit ;
66593: GO 67000
// repeat wait ( 0 0$1 ) ;
66595: LD_INT 35
66597: PPUSH
66598: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66602: LD_ADDR_VAR 0 5
66606: PUSH
66607: LD_VAR 0 6
66611: PPUSH
66612: LD_VAR 0 3
66616: PPUSH
66617: CALL 66409 0 2
66621: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66622: LD_EXP 102
66626: PUSH
66627: LD_VAR 0 1
66631: ARRAY
66632: NOT
66633: PUSH
66634: LD_EXP 102
66638: PUSH
66639: LD_VAR 0 1
66643: ARRAY
66644: PUSH
66645: EMPTY
66646: EQUAL
66647: OR
66648: IFFALSE 66685
// begin for i in solds do
66650: LD_ADDR_VAR 0 7
66654: PUSH
66655: LD_VAR 0 2
66659: PUSH
66660: FOR_IN
66661: IFFALSE 66674
// ComStop ( i ) ;
66663: LD_VAR 0 7
66667: PPUSH
66668: CALL_OW 141
66672: GO 66660
66674: POP
66675: POP
// solds := [ ] ;
66676: LD_ADDR_VAR 0 2
66680: PUSH
66681: EMPTY
66682: ST_TO_ADDR
// exit ;
66683: GO 67000
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66685: LD_VAR 0 5
66689: NOT
66690: PUSH
66691: LD_VAR 0 5
66695: PUSH
66696: LD_INT 3
66698: GREATER
66699: OR
66700: PUSH
66701: LD_EXP 124
66705: PUSH
66706: LD_VAR 0 1
66710: ARRAY
66711: OR
66712: IFFALSE 66753
// begin for i in solds do
66714: LD_ADDR_VAR 0 7
66718: PUSH
66719: LD_VAR 0 2
66723: PUSH
66724: FOR_IN
66725: IFFALSE 66749
// if HasTask ( i ) then
66727: LD_VAR 0 7
66731: PPUSH
66732: CALL_OW 314
66736: IFFALSE 66747
// ComStop ( i ) ;
66738: LD_VAR 0 7
66742: PPUSH
66743: CALL_OW 141
66747: GO 66724
66749: POP
66750: POP
// break ;
66751: GO 66988
// end ; for i in solds do
66753: LD_ADDR_VAR 0 7
66757: PUSH
66758: LD_VAR 0 2
66762: PUSH
66763: FOR_IN
66764: IFFALSE 66980
// begin if IsInUnit ( i ) then
66766: LD_VAR 0 7
66770: PPUSH
66771: CALL_OW 310
66775: IFFALSE 66786
// ComExitBuilding ( i ) ;
66777: LD_VAR 0 7
66781: PPUSH
66782: CALL_OW 122
// if GetLives ( i ) > 333 then
66786: LD_VAR 0 7
66790: PPUSH
66791: CALL_OW 256
66795: PUSH
66796: LD_INT 333
66798: GREATER
66799: IFFALSE 66827
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66801: LD_VAR 0 7
66805: PPUSH
66806: LD_VAR 0 5
66810: PPUSH
66811: LD_VAR 0 7
66815: PPUSH
66816: CALL_OW 74
66820: PPUSH
66821: CALL_OW 115
66825: GO 66978
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66827: LD_ADDR_VAR 0 8
66831: PUSH
66832: LD_EXP 102
66836: PUSH
66837: LD_VAR 0 1
66841: ARRAY
66842: PPUSH
66843: LD_INT 2
66845: PUSH
66846: LD_INT 30
66848: PUSH
66849: LD_INT 0
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 30
66858: PUSH
66859: LD_INT 1
66861: PUSH
66862: EMPTY
66863: LIST
66864: LIST
66865: PUSH
66866: LD_INT 30
66868: PUSH
66869: LD_INT 6
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: PPUSH
66882: CALL_OW 72
66886: PPUSH
66887: LD_VAR 0 7
66891: PPUSH
66892: CALL_OW 74
66896: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66897: LD_VAR 0 7
66901: PPUSH
66902: LD_VAR 0 8
66906: PPUSH
66907: CALL_OW 250
66911: PPUSH
66912: LD_INT 3
66914: PPUSH
66915: LD_INT 5
66917: PPUSH
66918: CALL_OW 272
66922: PPUSH
66923: LD_VAR 0 8
66927: PPUSH
66928: CALL_OW 251
66932: PPUSH
66933: LD_INT 3
66935: PPUSH
66936: LD_INT 5
66938: PPUSH
66939: CALL_OW 273
66943: PPUSH
66944: CALL_OW 111
// SetTag ( i , 0 ) ;
66948: LD_VAR 0 7
66952: PPUSH
66953: LD_INT 0
66955: PPUSH
66956: CALL_OW 109
// solds := solds diff i ;
66960: LD_ADDR_VAR 0 2
66964: PUSH
66965: LD_VAR 0 2
66969: PUSH
66970: LD_VAR 0 7
66974: DIFF
66975: ST_TO_ADDR
// continue ;
66976: GO 66763
// end ; end ;
66978: GO 66763
66980: POP
66981: POP
// until solds ;
66982: LD_VAR 0 2
66986: IFFALSE 66595
// MC_Reset ( base , 18 ) ;
66988: LD_VAR 0 1
66992: PPUSH
66993: LD_INT 18
66995: PPUSH
66996: CALL 38821 0 2
// end ;
67000: LD_VAR 0 4
67004: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67005: LD_INT 0
67007: PPUSH
67008: PPUSH
67009: PPUSH
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
67018: PPUSH
67019: PPUSH
67020: PPUSH
67021: PPUSH
67022: PPUSH
67023: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67024: LD_ADDR_VAR 0 13
67028: PUSH
67029: LD_EXP 102
67033: PUSH
67034: LD_VAR 0 1
67038: ARRAY
67039: PPUSH
67040: LD_INT 25
67042: PUSH
67043: LD_INT 3
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PPUSH
67050: CALL_OW 72
67054: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67055: LD_EXP 142
67059: PUSH
67060: LD_VAR 0 1
67064: ARRAY
67065: IFFALSE 67089
// mechs := mechs diff mc_remote_driver [ base ] ;
67067: LD_ADDR_VAR 0 13
67071: PUSH
67072: LD_VAR 0 13
67076: PUSH
67077: LD_EXP 142
67081: PUSH
67082: LD_VAR 0 1
67086: ARRAY
67087: DIFF
67088: ST_TO_ADDR
// for i in mechs do
67089: LD_ADDR_VAR 0 5
67093: PUSH
67094: LD_VAR 0 13
67098: PUSH
67099: FOR_IN
67100: IFFALSE 67135
// if GetTag ( i ) > 0 then
67102: LD_VAR 0 5
67106: PPUSH
67107: CALL_OW 110
67111: PUSH
67112: LD_INT 0
67114: GREATER
67115: IFFALSE 67133
// mechs := mechs diff i ;
67117: LD_ADDR_VAR 0 13
67121: PUSH
67122: LD_VAR 0 13
67126: PUSH
67127: LD_VAR 0 5
67131: DIFF
67132: ST_TO_ADDR
67133: GO 67099
67135: POP
67136: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67137: LD_ADDR_VAR 0 9
67141: PUSH
67142: LD_EXP 102
67146: PUSH
67147: LD_VAR 0 1
67151: ARRAY
67152: PPUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 25
67158: PUSH
67159: LD_INT 1
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 25
67168: PUSH
67169: LD_INT 5
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 25
67178: PUSH
67179: LD_INT 8
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 25
67188: PUSH
67189: LD_INT 9
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PUSH
67196: EMPTY
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: PPUSH
67203: CALL_OW 72
67207: ST_TO_ADDR
// if not defenders and not solds then
67208: LD_VAR 0 2
67212: NOT
67213: PUSH
67214: LD_VAR 0 9
67218: NOT
67219: AND
67220: IFFALSE 67224
// exit ;
67222: GO 68850
// depot_under_attack := false ;
67224: LD_ADDR_VAR 0 17
67228: PUSH
67229: LD_INT 0
67231: ST_TO_ADDR
// sold_defenders := [ ] ;
67232: LD_ADDR_VAR 0 18
67236: PUSH
67237: EMPTY
67238: ST_TO_ADDR
// if mechs then
67239: LD_VAR 0 13
67243: IFFALSE 67372
// for i in defenders do
67245: LD_ADDR_VAR 0 5
67249: PUSH
67250: LD_VAR 0 2
67254: PUSH
67255: FOR_IN
67256: IFFALSE 67370
// begin SetTag ( i , 20 ) ;
67258: LD_VAR 0 5
67262: PPUSH
67263: LD_INT 20
67265: PPUSH
67266: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67270: LD_VAR 0 5
67274: PPUSH
67275: CALL_OW 263
67279: PUSH
67280: LD_INT 1
67282: EQUAL
67283: PUSH
67284: LD_VAR 0 5
67288: PPUSH
67289: CALL_OW 311
67293: NOT
67294: AND
67295: PUSH
67296: LD_VAR 0 13
67300: AND
67301: IFFALSE 67368
// begin un := mechs [ 1 ] ;
67303: LD_ADDR_VAR 0 11
67307: PUSH
67308: LD_VAR 0 13
67312: PUSH
67313: LD_INT 1
67315: ARRAY
67316: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67317: LD_VAR 0 11
67321: PPUSH
67322: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67326: LD_VAR 0 11
67330: PPUSH
67331: LD_VAR 0 5
67335: PPUSH
67336: CALL_OW 180
// SetTag ( un , 19 ) ;
67340: LD_VAR 0 11
67344: PPUSH
67345: LD_INT 19
67347: PPUSH
67348: CALL_OW 109
// mechs := mechs diff un ;
67352: LD_ADDR_VAR 0 13
67356: PUSH
67357: LD_VAR 0 13
67361: PUSH
67362: LD_VAR 0 11
67366: DIFF
67367: ST_TO_ADDR
// end ; end ;
67368: GO 67255
67370: POP
67371: POP
// if solds then
67372: LD_VAR 0 9
67376: IFFALSE 67435
// for i in solds do
67378: LD_ADDR_VAR 0 5
67382: PUSH
67383: LD_VAR 0 9
67387: PUSH
67388: FOR_IN
67389: IFFALSE 67433
// if not GetTag ( i ) then
67391: LD_VAR 0 5
67395: PPUSH
67396: CALL_OW 110
67400: NOT
67401: IFFALSE 67431
// begin defenders := defenders union i ;
67403: LD_ADDR_VAR 0 2
67407: PUSH
67408: LD_VAR 0 2
67412: PUSH
67413: LD_VAR 0 5
67417: UNION
67418: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67419: LD_VAR 0 5
67423: PPUSH
67424: LD_INT 18
67426: PPUSH
67427: CALL_OW 109
// end ;
67431: GO 67388
67433: POP
67434: POP
// repeat wait ( 0 0$1 ) ;
67435: LD_INT 35
67437: PPUSH
67438: CALL_OW 67
// enemy := mc_scan [ base ] ;
67442: LD_ADDR_VAR 0 3
67446: PUSH
67447: LD_EXP 125
67451: PUSH
67452: LD_VAR 0 1
67456: ARRAY
67457: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67458: LD_EXP 102
67462: PUSH
67463: LD_VAR 0 1
67467: ARRAY
67468: NOT
67469: PUSH
67470: LD_EXP 102
67474: PUSH
67475: LD_VAR 0 1
67479: ARRAY
67480: PUSH
67481: EMPTY
67482: EQUAL
67483: OR
67484: IFFALSE 67521
// begin for i in defenders do
67486: LD_ADDR_VAR 0 5
67490: PUSH
67491: LD_VAR 0 2
67495: PUSH
67496: FOR_IN
67497: IFFALSE 67510
// ComStop ( i ) ;
67499: LD_VAR 0 5
67503: PPUSH
67504: CALL_OW 141
67508: GO 67496
67510: POP
67511: POP
// defenders := [ ] ;
67512: LD_ADDR_VAR 0 2
67516: PUSH
67517: EMPTY
67518: ST_TO_ADDR
// exit ;
67519: GO 68850
// end ; for i in defenders do
67521: LD_ADDR_VAR 0 5
67525: PUSH
67526: LD_VAR 0 2
67530: PUSH
67531: FOR_IN
67532: IFFALSE 68350
// begin e := NearestUnitToUnit ( enemy , i ) ;
67534: LD_ADDR_VAR 0 14
67538: PUSH
67539: LD_VAR 0 3
67543: PPUSH
67544: LD_VAR 0 5
67548: PPUSH
67549: CALL_OW 74
67553: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67554: LD_ADDR_VAR 0 8
67558: PUSH
67559: LD_EXP 102
67563: PUSH
67564: LD_VAR 0 1
67568: ARRAY
67569: PPUSH
67570: LD_INT 2
67572: PUSH
67573: LD_INT 30
67575: PUSH
67576: LD_INT 0
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 30
67585: PUSH
67586: LD_INT 1
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: LIST
67597: PPUSH
67598: CALL_OW 72
67602: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67603: LD_ADDR_VAR 0 17
67607: PUSH
67608: LD_VAR 0 8
67612: NOT
67613: PUSH
67614: LD_VAR 0 8
67618: PPUSH
67619: LD_INT 3
67621: PUSH
67622: LD_INT 24
67624: PUSH
67625: LD_INT 600
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PUSH
67632: EMPTY
67633: LIST
67634: LIST
67635: PPUSH
67636: CALL_OW 72
67640: OR
67641: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67642: LD_VAR 0 5
67646: PPUSH
67647: CALL_OW 247
67651: PUSH
67652: LD_INT 2
67654: DOUBLE
67655: EQUAL
67656: IFTRUE 67660
67658: GO 68056
67660: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67661: LD_VAR 0 5
67665: PPUSH
67666: CALL_OW 256
67670: PUSH
67671: LD_INT 650
67673: GREATER
67674: PUSH
67675: LD_VAR 0 5
67679: PPUSH
67680: LD_VAR 0 14
67684: PPUSH
67685: CALL_OW 296
67689: PUSH
67690: LD_INT 40
67692: LESS
67693: PUSH
67694: LD_VAR 0 14
67698: PPUSH
67699: LD_EXP 127
67703: PUSH
67704: LD_VAR 0 1
67708: ARRAY
67709: PPUSH
67710: CALL_OW 308
67714: OR
67715: AND
67716: IFFALSE 67838
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67718: LD_VAR 0 5
67722: PPUSH
67723: CALL_OW 262
67727: PUSH
67728: LD_INT 1
67730: EQUAL
67731: PUSH
67732: LD_VAR 0 5
67736: PPUSH
67737: CALL_OW 261
67741: PUSH
67742: LD_INT 30
67744: LESS
67745: AND
67746: PUSH
67747: LD_VAR 0 8
67751: AND
67752: IFFALSE 67822
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67754: LD_VAR 0 5
67758: PPUSH
67759: LD_VAR 0 8
67763: PPUSH
67764: LD_VAR 0 5
67768: PPUSH
67769: CALL_OW 74
67773: PPUSH
67774: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67778: LD_VAR 0 5
67782: PPUSH
67783: LD_VAR 0 8
67787: PPUSH
67788: LD_VAR 0 5
67792: PPUSH
67793: CALL_OW 74
67797: PPUSH
67798: CALL_OW 296
67802: PUSH
67803: LD_INT 6
67805: LESS
67806: IFFALSE 67820
// SetFuel ( i , 100 ) ;
67808: LD_VAR 0 5
67812: PPUSH
67813: LD_INT 100
67815: PPUSH
67816: CALL_OW 240
// end else
67820: GO 67836
// ComAttackUnit ( i , e ) ;
67822: LD_VAR 0 5
67826: PPUSH
67827: LD_VAR 0 14
67831: PPUSH
67832: CALL_OW 115
// end else
67836: GO 67939
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67838: LD_VAR 0 14
67842: PPUSH
67843: LD_EXP 127
67847: PUSH
67848: LD_VAR 0 1
67852: ARRAY
67853: PPUSH
67854: CALL_OW 308
67858: NOT
67859: PUSH
67860: LD_VAR 0 5
67864: PPUSH
67865: LD_VAR 0 14
67869: PPUSH
67870: CALL_OW 296
67874: PUSH
67875: LD_INT 40
67877: GREATEREQUAL
67878: AND
67879: PUSH
67880: LD_VAR 0 5
67884: PPUSH
67885: CALL_OW 256
67889: PUSH
67890: LD_INT 650
67892: LESSEQUAL
67893: OR
67894: PUSH
67895: LD_VAR 0 5
67899: PPUSH
67900: LD_EXP 126
67904: PUSH
67905: LD_VAR 0 1
67909: ARRAY
67910: PPUSH
67911: CALL_OW 308
67915: NOT
67916: AND
67917: IFFALSE 67939
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67919: LD_VAR 0 5
67923: PPUSH
67924: LD_EXP 126
67928: PUSH
67929: LD_VAR 0 1
67933: ARRAY
67934: PPUSH
67935: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67939: LD_VAR 0 5
67943: PPUSH
67944: CALL_OW 256
67948: PUSH
67949: LD_INT 998
67951: LESS
67952: PUSH
67953: LD_VAR 0 5
67957: PPUSH
67958: CALL_OW 263
67962: PUSH
67963: LD_INT 1
67965: EQUAL
67966: AND
67967: PUSH
67968: LD_VAR 0 5
67972: PPUSH
67973: CALL_OW 311
67977: AND
67978: PUSH
67979: LD_VAR 0 5
67983: PPUSH
67984: LD_EXP 126
67988: PUSH
67989: LD_VAR 0 1
67993: ARRAY
67994: PPUSH
67995: CALL_OW 308
67999: AND
68000: IFFALSE 68054
// begin mech := IsDrivenBy ( i ) ;
68002: LD_ADDR_VAR 0 10
68006: PUSH
68007: LD_VAR 0 5
68011: PPUSH
68012: CALL_OW 311
68016: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68017: LD_VAR 0 10
68021: PPUSH
68022: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68026: LD_VAR 0 10
68030: PPUSH
68031: LD_VAR 0 5
68035: PPUSH
68036: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68040: LD_VAR 0 10
68044: PPUSH
68045: LD_VAR 0 5
68049: PPUSH
68050: CALL_OW 180
// end ; end ; unit_human :
68054: GO 68321
68056: LD_INT 1
68058: DOUBLE
68059: EQUAL
68060: IFTRUE 68064
68062: GO 68320
68064: POP
// begin b := IsInUnit ( i ) ;
68065: LD_ADDR_VAR 0 19
68069: PUSH
68070: LD_VAR 0 5
68074: PPUSH
68075: CALL_OW 310
68079: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68080: LD_ADDR_VAR 0 20
68084: PUSH
68085: LD_VAR 0 19
68089: NOT
68090: PUSH
68091: LD_VAR 0 19
68095: PPUSH
68096: CALL_OW 266
68100: PUSH
68101: LD_INT 32
68103: PUSH
68104: LD_INT 31
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: IN
68111: OR
68112: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68113: LD_VAR 0 17
68117: PUSH
68118: LD_VAR 0 2
68122: PPUSH
68123: LD_INT 21
68125: PUSH
68126: LD_INT 2
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PPUSH
68133: CALL_OW 72
68137: PUSH
68138: LD_INT 1
68140: LESSEQUAL
68141: OR
68142: PUSH
68143: LD_VAR 0 20
68147: AND
68148: PUSH
68149: LD_VAR 0 5
68153: PUSH
68154: LD_VAR 0 18
68158: IN
68159: NOT
68160: AND
68161: IFFALSE 68254
// begin if b then
68163: LD_VAR 0 19
68167: IFFALSE 68216
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68169: LD_VAR 0 19
68173: PPUSH
68174: LD_VAR 0 3
68178: PPUSH
68179: LD_VAR 0 19
68183: PPUSH
68184: CALL_OW 74
68188: PPUSH
68189: CALL_OW 296
68193: PUSH
68194: LD_INT 10
68196: LESS
68197: PUSH
68198: LD_VAR 0 19
68202: PPUSH
68203: CALL_OW 461
68207: PUSH
68208: LD_INT 7
68210: NONEQUAL
68211: AND
68212: IFFALSE 68216
// continue ;
68214: GO 67531
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68216: LD_ADDR_VAR 0 18
68220: PUSH
68221: LD_VAR 0 18
68225: PPUSH
68226: LD_VAR 0 18
68230: PUSH
68231: LD_INT 1
68233: PLUS
68234: PPUSH
68235: LD_VAR 0 5
68239: PPUSH
68240: CALL_OW 1
68244: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68245: LD_VAR 0 5
68249: PPUSH
68250: CALL_OW 122
// end ; if sold_defenders then
68254: LD_VAR 0 18
68258: IFFALSE 68318
// if i in sold_defenders then
68260: LD_VAR 0 5
68264: PUSH
68265: LD_VAR 0 18
68269: IN
68270: IFFALSE 68318
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68272: LD_VAR 0 5
68276: PPUSH
68277: CALL_OW 314
68281: NOT
68282: PUSH
68283: LD_VAR 0 5
68287: PPUSH
68288: LD_VAR 0 14
68292: PPUSH
68293: CALL_OW 296
68297: PUSH
68298: LD_INT 30
68300: LESS
68301: AND
68302: IFFALSE 68318
// ComAttackUnit ( i , e ) ;
68304: LD_VAR 0 5
68308: PPUSH
68309: LD_VAR 0 14
68313: PPUSH
68314: CALL_OW 115
// end ; end ; end ;
68318: GO 68321
68320: POP
// if IsDead ( i ) then
68321: LD_VAR 0 5
68325: PPUSH
68326: CALL_OW 301
68330: IFFALSE 68348
// defenders := defenders diff i ;
68332: LD_ADDR_VAR 0 2
68336: PUSH
68337: LD_VAR 0 2
68341: PUSH
68342: LD_VAR 0 5
68346: DIFF
68347: ST_TO_ADDR
// end ;
68348: GO 67531
68350: POP
68351: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68352: LD_VAR 0 3
68356: NOT
68357: PUSH
68358: LD_VAR 0 2
68362: NOT
68363: OR
68364: PUSH
68365: LD_EXP 102
68369: PUSH
68370: LD_VAR 0 1
68374: ARRAY
68375: NOT
68376: OR
68377: IFFALSE 67435
// MC_Reset ( base , 18 ) ;
68379: LD_VAR 0 1
68383: PPUSH
68384: LD_INT 18
68386: PPUSH
68387: CALL 38821 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68391: LD_ADDR_VAR 0 2
68395: PUSH
68396: LD_VAR 0 2
68400: PUSH
68401: LD_VAR 0 2
68405: PPUSH
68406: LD_INT 2
68408: PUSH
68409: LD_INT 25
68411: PUSH
68412: LD_INT 1
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 25
68421: PUSH
68422: LD_INT 5
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 25
68431: PUSH
68432: LD_INT 8
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: LD_INT 25
68441: PUSH
68442: LD_INT 9
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: PPUSH
68456: CALL_OW 72
68460: DIFF
68461: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68462: LD_VAR 0 3
68466: NOT
68467: PUSH
68468: LD_VAR 0 2
68472: PPUSH
68473: LD_INT 21
68475: PUSH
68476: LD_INT 2
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PPUSH
68483: CALL_OW 72
68487: AND
68488: IFFALSE 68826
// begin tmp := FilterByTag ( defenders , 19 ) ;
68490: LD_ADDR_VAR 0 12
68494: PUSH
68495: LD_VAR 0 2
68499: PPUSH
68500: LD_INT 19
68502: PPUSH
68503: CALL 105289 0 2
68507: ST_TO_ADDR
// if tmp then
68508: LD_VAR 0 12
68512: IFFALSE 68582
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68514: LD_ADDR_VAR 0 12
68518: PUSH
68519: LD_VAR 0 12
68523: PPUSH
68524: LD_INT 25
68526: PUSH
68527: LD_INT 3
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PPUSH
68534: CALL_OW 72
68538: ST_TO_ADDR
// if tmp then
68539: LD_VAR 0 12
68543: IFFALSE 68582
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68545: LD_ADDR_EXP 114
68549: PUSH
68550: LD_EXP 114
68554: PPUSH
68555: LD_VAR 0 1
68559: PPUSH
68560: LD_EXP 114
68564: PUSH
68565: LD_VAR 0 1
68569: ARRAY
68570: PUSH
68571: LD_VAR 0 12
68575: UNION
68576: PPUSH
68577: CALL_OW 1
68581: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68582: LD_VAR 0 1
68586: PPUSH
68587: LD_INT 19
68589: PPUSH
68590: CALL 38821 0 2
// repeat wait ( 0 0$1 ) ;
68594: LD_INT 35
68596: PPUSH
68597: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68601: LD_EXP 102
68605: PUSH
68606: LD_VAR 0 1
68610: ARRAY
68611: NOT
68612: PUSH
68613: LD_EXP 102
68617: PUSH
68618: LD_VAR 0 1
68622: ARRAY
68623: PUSH
68624: EMPTY
68625: EQUAL
68626: OR
68627: IFFALSE 68664
// begin for i in defenders do
68629: LD_ADDR_VAR 0 5
68633: PUSH
68634: LD_VAR 0 2
68638: PUSH
68639: FOR_IN
68640: IFFALSE 68653
// ComStop ( i ) ;
68642: LD_VAR 0 5
68646: PPUSH
68647: CALL_OW 141
68651: GO 68639
68653: POP
68654: POP
// defenders := [ ] ;
68655: LD_ADDR_VAR 0 2
68659: PUSH
68660: EMPTY
68661: ST_TO_ADDR
// exit ;
68662: GO 68850
// end ; for i in defenders do
68664: LD_ADDR_VAR 0 5
68668: PUSH
68669: LD_VAR 0 2
68673: PUSH
68674: FOR_IN
68675: IFFALSE 68764
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68677: LD_VAR 0 5
68681: PPUSH
68682: LD_EXP 126
68686: PUSH
68687: LD_VAR 0 1
68691: ARRAY
68692: PPUSH
68693: CALL_OW 308
68697: NOT
68698: IFFALSE 68722
// ComMoveToArea ( i , mc_parking [ base ] ) else
68700: LD_VAR 0 5
68704: PPUSH
68705: LD_EXP 126
68709: PUSH
68710: LD_VAR 0 1
68714: ARRAY
68715: PPUSH
68716: CALL_OW 113
68720: GO 68762
// if GetControl ( i ) = control_manual then
68722: LD_VAR 0 5
68726: PPUSH
68727: CALL_OW 263
68731: PUSH
68732: LD_INT 1
68734: EQUAL
68735: IFFALSE 68762
// if IsDrivenBy ( i ) then
68737: LD_VAR 0 5
68741: PPUSH
68742: CALL_OW 311
68746: IFFALSE 68762
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68748: LD_VAR 0 5
68752: PPUSH
68753: CALL_OW 311
68757: PPUSH
68758: CALL_OW 121
// end ;
68762: GO 68674
68764: POP
68765: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68766: LD_VAR 0 2
68770: PPUSH
68771: LD_INT 95
68773: PUSH
68774: LD_EXP 126
68778: PUSH
68779: LD_VAR 0 1
68783: ARRAY
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PPUSH
68789: CALL_OW 72
68793: PUSH
68794: LD_VAR 0 2
68798: EQUAL
68799: PUSH
68800: LD_EXP 125
68804: PUSH
68805: LD_VAR 0 1
68809: ARRAY
68810: OR
68811: PUSH
68812: LD_EXP 102
68816: PUSH
68817: LD_VAR 0 1
68821: ARRAY
68822: NOT
68823: OR
68824: IFFALSE 68594
// end ; MC_Reset ( base , 19 ) ;
68826: LD_VAR 0 1
68830: PPUSH
68831: LD_INT 19
68833: PPUSH
68834: CALL 38821 0 2
// MC_Reset ( base , 20 ) ;
68838: LD_VAR 0 1
68842: PPUSH
68843: LD_INT 20
68845: PPUSH
68846: CALL 38821 0 2
// end ;
68850: LD_VAR 0 4
68854: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68855: LD_INT 0
68857: PPUSH
68858: PPUSH
68859: PPUSH
68860: PPUSH
// result := false ;
68861: LD_ADDR_VAR 0 2
68865: PUSH
68866: LD_INT 0
68868: ST_TO_ADDR
// side := GetSide ( unit ) ;
68869: LD_ADDR_VAR 0 3
68873: PUSH
68874: LD_VAR 0 1
68878: PPUSH
68879: CALL_OW 255
68883: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68884: LD_ADDR_VAR 0 4
68888: PUSH
68889: LD_VAR 0 1
68893: PPUSH
68894: CALL_OW 248
68898: ST_TO_ADDR
// case nat of 1 :
68899: LD_VAR 0 4
68903: PUSH
68904: LD_INT 1
68906: DOUBLE
68907: EQUAL
68908: IFTRUE 68912
68910: GO 68923
68912: POP
// tech := tech_lassight ; 2 :
68913: LD_ADDR_VAR 0 5
68917: PUSH
68918: LD_INT 12
68920: ST_TO_ADDR
68921: GO 68962
68923: LD_INT 2
68925: DOUBLE
68926: EQUAL
68927: IFTRUE 68931
68929: GO 68942
68931: POP
// tech := tech_mortar ; 3 :
68932: LD_ADDR_VAR 0 5
68936: PUSH
68937: LD_INT 41
68939: ST_TO_ADDR
68940: GO 68962
68942: LD_INT 3
68944: DOUBLE
68945: EQUAL
68946: IFTRUE 68950
68948: GO 68961
68950: POP
// tech := tech_bazooka ; end ;
68951: LD_ADDR_VAR 0 5
68955: PUSH
68956: LD_INT 44
68958: ST_TO_ADDR
68959: GO 68962
68961: POP
// if Researched ( side , tech ) then
68962: LD_VAR 0 3
68966: PPUSH
68967: LD_VAR 0 5
68971: PPUSH
68972: CALL_OW 325
68976: IFFALSE 69003
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68978: LD_ADDR_VAR 0 2
68982: PUSH
68983: LD_INT 5
68985: PUSH
68986: LD_INT 8
68988: PUSH
68989: LD_INT 9
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: LIST
68996: PUSH
68997: LD_VAR 0 4
69001: ARRAY
69002: ST_TO_ADDR
// end ;
69003: LD_VAR 0 2
69007: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69008: LD_INT 0
69010: PPUSH
69011: PPUSH
69012: PPUSH
// if not mines then
69013: LD_VAR 0 2
69017: NOT
69018: IFFALSE 69022
// exit ;
69020: GO 69166
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69022: LD_ADDR_VAR 0 5
69026: PUSH
69027: LD_INT 81
69029: PUSH
69030: LD_VAR 0 1
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: LD_INT 21
69044: PUSH
69045: LD_INT 3
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: EMPTY
69053: LIST
69054: LIST
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PPUSH
69060: CALL_OW 69
69064: ST_TO_ADDR
// for i in mines do
69065: LD_ADDR_VAR 0 4
69069: PUSH
69070: LD_VAR 0 2
69074: PUSH
69075: FOR_IN
69076: IFFALSE 69164
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69078: LD_VAR 0 4
69082: PUSH
69083: LD_INT 1
69085: ARRAY
69086: PPUSH
69087: LD_VAR 0 4
69091: PUSH
69092: LD_INT 2
69094: ARRAY
69095: PPUSH
69096: CALL_OW 458
69100: NOT
69101: IFFALSE 69105
// continue ;
69103: GO 69075
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69105: LD_VAR 0 4
69109: PUSH
69110: LD_INT 1
69112: ARRAY
69113: PPUSH
69114: LD_VAR 0 4
69118: PUSH
69119: LD_INT 2
69121: ARRAY
69122: PPUSH
69123: CALL_OW 428
69127: PUSH
69128: LD_VAR 0 5
69132: IN
69133: IFFALSE 69162
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69135: LD_VAR 0 4
69139: PUSH
69140: LD_INT 1
69142: ARRAY
69143: PPUSH
69144: LD_VAR 0 4
69148: PUSH
69149: LD_INT 2
69151: ARRAY
69152: PPUSH
69153: LD_VAR 0 1
69157: PPUSH
69158: CALL_OW 456
// end ;
69162: GO 69075
69164: POP
69165: POP
// end ;
69166: LD_VAR 0 3
69170: RET
// export function Count ( array ) ; var i ; begin
69171: LD_INT 0
69173: PPUSH
69174: PPUSH
// result := 0 ;
69175: LD_ADDR_VAR 0 2
69179: PUSH
69180: LD_INT 0
69182: ST_TO_ADDR
// for i in array do
69183: LD_ADDR_VAR 0 3
69187: PUSH
69188: LD_VAR 0 1
69192: PUSH
69193: FOR_IN
69194: IFFALSE 69218
// if i then
69196: LD_VAR 0 3
69200: IFFALSE 69216
// result := result + 1 ;
69202: LD_ADDR_VAR 0 2
69206: PUSH
69207: LD_VAR 0 2
69211: PUSH
69212: LD_INT 1
69214: PLUS
69215: ST_TO_ADDR
69216: GO 69193
69218: POP
69219: POP
// end ;
69220: LD_VAR 0 2
69224: RET
// export function IsEmpty ( building ) ; begin
69225: LD_INT 0
69227: PPUSH
// if not building then
69228: LD_VAR 0 1
69232: NOT
69233: IFFALSE 69237
// exit ;
69235: GO 69280
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69237: LD_ADDR_VAR 0 2
69241: PUSH
69242: LD_VAR 0 1
69246: PUSH
69247: LD_INT 22
69249: PUSH
69250: LD_VAR 0 1
69254: PPUSH
69255: CALL_OW 255
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 58
69266: PUSH
69267: EMPTY
69268: LIST
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PPUSH
69274: CALL_OW 69
69278: IN
69279: ST_TO_ADDR
// end ;
69280: LD_VAR 0 2
69284: RET
// export function IsNotFull ( building ) ; begin
69285: LD_INT 0
69287: PPUSH
// if not building then
69288: LD_VAR 0 1
69292: NOT
69293: IFFALSE 69297
// exit ;
69295: GO 69316
// result := UnitsInside ( building ) < 6 ;
69297: LD_ADDR_VAR 0 2
69301: PUSH
69302: LD_VAR 0 1
69306: PPUSH
69307: CALL_OW 313
69311: PUSH
69312: LD_INT 6
69314: LESS
69315: ST_TO_ADDR
// end ;
69316: LD_VAR 0 2
69320: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69321: LD_INT 0
69323: PPUSH
69324: PPUSH
69325: PPUSH
69326: PPUSH
// tmp := [ ] ;
69327: LD_ADDR_VAR 0 3
69331: PUSH
69332: EMPTY
69333: ST_TO_ADDR
// list := [ ] ;
69334: LD_ADDR_VAR 0 5
69338: PUSH
69339: EMPTY
69340: ST_TO_ADDR
// for i = 16 to 25 do
69341: LD_ADDR_VAR 0 4
69345: PUSH
69346: DOUBLE
69347: LD_INT 16
69349: DEC
69350: ST_TO_ADDR
69351: LD_INT 25
69353: PUSH
69354: FOR_TO
69355: IFFALSE 69428
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69357: LD_ADDR_VAR 0 3
69361: PUSH
69362: LD_VAR 0 3
69366: PUSH
69367: LD_INT 22
69369: PUSH
69370: LD_VAR 0 1
69374: PPUSH
69375: CALL_OW 255
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 91
69386: PUSH
69387: LD_VAR 0 1
69391: PUSH
69392: LD_INT 6
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 30
69402: PUSH
69403: LD_VAR 0 4
69407: PUSH
69408: EMPTY
69409: LIST
69410: LIST
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: LIST
69416: PUSH
69417: EMPTY
69418: LIST
69419: PPUSH
69420: CALL_OW 69
69424: ADD
69425: ST_TO_ADDR
69426: GO 69354
69428: POP
69429: POP
// for i = 1 to tmp do
69430: LD_ADDR_VAR 0 4
69434: PUSH
69435: DOUBLE
69436: LD_INT 1
69438: DEC
69439: ST_TO_ADDR
69440: LD_VAR 0 3
69444: PUSH
69445: FOR_TO
69446: IFFALSE 69534
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69448: LD_ADDR_VAR 0 5
69452: PUSH
69453: LD_VAR 0 5
69457: PUSH
69458: LD_VAR 0 3
69462: PUSH
69463: LD_VAR 0 4
69467: ARRAY
69468: PPUSH
69469: CALL_OW 266
69473: PUSH
69474: LD_VAR 0 3
69478: PUSH
69479: LD_VAR 0 4
69483: ARRAY
69484: PPUSH
69485: CALL_OW 250
69489: PUSH
69490: LD_VAR 0 3
69494: PUSH
69495: LD_VAR 0 4
69499: ARRAY
69500: PPUSH
69501: CALL_OW 251
69505: PUSH
69506: LD_VAR 0 3
69510: PUSH
69511: LD_VAR 0 4
69515: ARRAY
69516: PPUSH
69517: CALL_OW 254
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: LIST
69526: LIST
69527: PUSH
69528: EMPTY
69529: LIST
69530: ADD
69531: ST_TO_ADDR
69532: GO 69445
69534: POP
69535: POP
// result := list ;
69536: LD_ADDR_VAR 0 2
69540: PUSH
69541: LD_VAR 0 5
69545: ST_TO_ADDR
// end ;
69546: LD_VAR 0 2
69550: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69551: LD_INT 0
69553: PPUSH
69554: PPUSH
69555: PPUSH
69556: PPUSH
69557: PPUSH
69558: PPUSH
69559: PPUSH
// if not factory then
69560: LD_VAR 0 1
69564: NOT
69565: IFFALSE 69569
// exit ;
69567: GO 70162
// if control = control_apeman then
69569: LD_VAR 0 4
69573: PUSH
69574: LD_INT 5
69576: EQUAL
69577: IFFALSE 69686
// begin tmp := UnitsInside ( factory ) ;
69579: LD_ADDR_VAR 0 8
69583: PUSH
69584: LD_VAR 0 1
69588: PPUSH
69589: CALL_OW 313
69593: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69594: LD_VAR 0 8
69598: PPUSH
69599: LD_INT 25
69601: PUSH
69602: LD_INT 12
69604: PUSH
69605: EMPTY
69606: LIST
69607: LIST
69608: PPUSH
69609: CALL_OW 72
69613: NOT
69614: IFFALSE 69624
// control := control_manual ;
69616: LD_ADDR_VAR 0 4
69620: PUSH
69621: LD_INT 1
69623: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69624: LD_ADDR_VAR 0 8
69628: PUSH
69629: LD_VAR 0 1
69633: PPUSH
69634: CALL 69321 0 1
69638: ST_TO_ADDR
// if tmp then
69639: LD_VAR 0 8
69643: IFFALSE 69686
// begin for i in tmp do
69645: LD_ADDR_VAR 0 7
69649: PUSH
69650: LD_VAR 0 8
69654: PUSH
69655: FOR_IN
69656: IFFALSE 69684
// if i [ 1 ] = b_ext_radio then
69658: LD_VAR 0 7
69662: PUSH
69663: LD_INT 1
69665: ARRAY
69666: PUSH
69667: LD_INT 22
69669: EQUAL
69670: IFFALSE 69682
// begin control := control_remote ;
69672: LD_ADDR_VAR 0 4
69676: PUSH
69677: LD_INT 2
69679: ST_TO_ADDR
// break ;
69680: GO 69684
// end ;
69682: GO 69655
69684: POP
69685: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69686: LD_VAR 0 1
69690: PPUSH
69691: LD_VAR 0 2
69695: PPUSH
69696: LD_VAR 0 3
69700: PPUSH
69701: LD_VAR 0 4
69705: PPUSH
69706: LD_VAR 0 5
69710: PPUSH
69711: CALL_OW 448
69715: IFFALSE 69750
// begin result := [ chassis , engine , control , weapon ] ;
69717: LD_ADDR_VAR 0 6
69721: PUSH
69722: LD_VAR 0 2
69726: PUSH
69727: LD_VAR 0 3
69731: PUSH
69732: LD_VAR 0 4
69736: PUSH
69737: LD_VAR 0 5
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: ST_TO_ADDR
// exit ;
69748: GO 70162
// end ; _chassis := AvailableChassisList ( factory ) ;
69750: LD_ADDR_VAR 0 9
69754: PUSH
69755: LD_VAR 0 1
69759: PPUSH
69760: CALL_OW 475
69764: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69765: LD_ADDR_VAR 0 11
69769: PUSH
69770: LD_VAR 0 1
69774: PPUSH
69775: CALL_OW 476
69779: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69780: LD_ADDR_VAR 0 12
69784: PUSH
69785: LD_VAR 0 1
69789: PPUSH
69790: CALL_OW 477
69794: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69795: LD_ADDR_VAR 0 10
69799: PUSH
69800: LD_VAR 0 1
69804: PPUSH
69805: CALL_OW 478
69809: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69810: LD_VAR 0 9
69814: NOT
69815: PUSH
69816: LD_VAR 0 11
69820: NOT
69821: OR
69822: PUSH
69823: LD_VAR 0 12
69827: NOT
69828: OR
69829: PUSH
69830: LD_VAR 0 10
69834: NOT
69835: OR
69836: IFFALSE 69871
// begin result := [ chassis , engine , control , weapon ] ;
69838: LD_ADDR_VAR 0 6
69842: PUSH
69843: LD_VAR 0 2
69847: PUSH
69848: LD_VAR 0 3
69852: PUSH
69853: LD_VAR 0 4
69857: PUSH
69858: LD_VAR 0 5
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: ST_TO_ADDR
// exit ;
69869: GO 70162
// end ; if not chassis in _chassis then
69871: LD_VAR 0 2
69875: PUSH
69876: LD_VAR 0 9
69880: IN
69881: NOT
69882: IFFALSE 69908
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69884: LD_ADDR_VAR 0 2
69888: PUSH
69889: LD_VAR 0 9
69893: PUSH
69894: LD_INT 1
69896: PPUSH
69897: LD_VAR 0 9
69901: PPUSH
69902: CALL_OW 12
69906: ARRAY
69907: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69908: LD_VAR 0 2
69912: PPUSH
69913: LD_VAR 0 3
69917: PPUSH
69918: CALL 70167 0 2
69922: NOT
69923: IFFALSE 69982
// repeat engine := _engine [ 1 ] ;
69925: LD_ADDR_VAR 0 3
69929: PUSH
69930: LD_VAR 0 11
69934: PUSH
69935: LD_INT 1
69937: ARRAY
69938: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69939: LD_ADDR_VAR 0 11
69943: PUSH
69944: LD_VAR 0 11
69948: PPUSH
69949: LD_INT 1
69951: PPUSH
69952: CALL_OW 3
69956: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69957: LD_VAR 0 2
69961: PPUSH
69962: LD_VAR 0 3
69966: PPUSH
69967: CALL 70167 0 2
69971: PUSH
69972: LD_VAR 0 11
69976: PUSH
69977: EMPTY
69978: EQUAL
69979: OR
69980: IFFALSE 69925
// if not control in _control then
69982: LD_VAR 0 4
69986: PUSH
69987: LD_VAR 0 12
69991: IN
69992: NOT
69993: IFFALSE 70019
// control := _control [ rand ( 1 , _control ) ] ;
69995: LD_ADDR_VAR 0 4
69999: PUSH
70000: LD_VAR 0 12
70004: PUSH
70005: LD_INT 1
70007: PPUSH
70008: LD_VAR 0 12
70012: PPUSH
70013: CALL_OW 12
70017: ARRAY
70018: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70019: LD_VAR 0 2
70023: PPUSH
70024: LD_VAR 0 5
70028: PPUSH
70029: CALL 70387 0 2
70033: NOT
70034: IFFALSE 70093
// repeat weapon := _weapon [ 1 ] ;
70036: LD_ADDR_VAR 0 5
70040: PUSH
70041: LD_VAR 0 10
70045: PUSH
70046: LD_INT 1
70048: ARRAY
70049: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70050: LD_ADDR_VAR 0 10
70054: PUSH
70055: LD_VAR 0 10
70059: PPUSH
70060: LD_INT 1
70062: PPUSH
70063: CALL_OW 3
70067: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70068: LD_VAR 0 2
70072: PPUSH
70073: LD_VAR 0 5
70077: PPUSH
70078: CALL 70387 0 2
70082: PUSH
70083: LD_VAR 0 10
70087: PUSH
70088: EMPTY
70089: EQUAL
70090: OR
70091: IFFALSE 70036
// result := [ ] ;
70093: LD_ADDR_VAR 0 6
70097: PUSH
70098: EMPTY
70099: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70100: LD_VAR 0 1
70104: PPUSH
70105: LD_VAR 0 2
70109: PPUSH
70110: LD_VAR 0 3
70114: PPUSH
70115: LD_VAR 0 4
70119: PPUSH
70120: LD_VAR 0 5
70124: PPUSH
70125: CALL_OW 448
70129: IFFALSE 70162
// result := [ chassis , engine , control , weapon ] ;
70131: LD_ADDR_VAR 0 6
70135: PUSH
70136: LD_VAR 0 2
70140: PUSH
70141: LD_VAR 0 3
70145: PUSH
70146: LD_VAR 0 4
70150: PUSH
70151: LD_VAR 0 5
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: ST_TO_ADDR
// end ;
70162: LD_VAR 0 6
70166: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70167: LD_INT 0
70169: PPUSH
// if not chassis or not engine then
70170: LD_VAR 0 1
70174: NOT
70175: PUSH
70176: LD_VAR 0 2
70180: NOT
70181: OR
70182: IFFALSE 70186
// exit ;
70184: GO 70382
// case engine of engine_solar :
70186: LD_VAR 0 2
70190: PUSH
70191: LD_INT 2
70193: DOUBLE
70194: EQUAL
70195: IFTRUE 70199
70197: GO 70237
70199: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70200: LD_ADDR_VAR 0 3
70204: PUSH
70205: LD_INT 11
70207: PUSH
70208: LD_INT 12
70210: PUSH
70211: LD_INT 13
70213: PUSH
70214: LD_INT 14
70216: PUSH
70217: LD_INT 1
70219: PUSH
70220: LD_INT 2
70222: PUSH
70223: LD_INT 3
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: ST_TO_ADDR
70235: GO 70366
70237: LD_INT 1
70239: DOUBLE
70240: EQUAL
70241: IFTRUE 70245
70243: GO 70307
70245: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70246: LD_ADDR_VAR 0 3
70250: PUSH
70251: LD_INT 11
70253: PUSH
70254: LD_INT 12
70256: PUSH
70257: LD_INT 13
70259: PUSH
70260: LD_INT 14
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: LD_INT 2
70268: PUSH
70269: LD_INT 3
70271: PUSH
70272: LD_INT 4
70274: PUSH
70275: LD_INT 5
70277: PUSH
70278: LD_INT 21
70280: PUSH
70281: LD_INT 23
70283: PUSH
70284: LD_INT 22
70286: PUSH
70287: LD_INT 24
70289: PUSH
70290: EMPTY
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: ST_TO_ADDR
70305: GO 70366
70307: LD_INT 3
70309: DOUBLE
70310: EQUAL
70311: IFTRUE 70315
70313: GO 70365
70315: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70316: LD_ADDR_VAR 0 3
70320: PUSH
70321: LD_INT 13
70323: PUSH
70324: LD_INT 14
70326: PUSH
70327: LD_INT 2
70329: PUSH
70330: LD_INT 3
70332: PUSH
70333: LD_INT 4
70335: PUSH
70336: LD_INT 5
70338: PUSH
70339: LD_INT 21
70341: PUSH
70342: LD_INT 22
70344: PUSH
70345: LD_INT 23
70347: PUSH
70348: LD_INT 24
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: LIST
70355: LIST
70356: LIST
70357: LIST
70358: LIST
70359: LIST
70360: LIST
70361: LIST
70362: ST_TO_ADDR
70363: GO 70366
70365: POP
// result := ( chassis in result ) ;
70366: LD_ADDR_VAR 0 3
70370: PUSH
70371: LD_VAR 0 1
70375: PUSH
70376: LD_VAR 0 3
70380: IN
70381: ST_TO_ADDR
// end ;
70382: LD_VAR 0 3
70386: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70387: LD_INT 0
70389: PPUSH
// if not chassis or not weapon then
70390: LD_VAR 0 1
70394: NOT
70395: PUSH
70396: LD_VAR 0 2
70400: NOT
70401: OR
70402: IFFALSE 70406
// exit ;
70404: GO 71432
// case weapon of us_machine_gun :
70406: LD_VAR 0 2
70410: PUSH
70411: LD_INT 2
70413: DOUBLE
70414: EQUAL
70415: IFTRUE 70419
70417: GO 70449
70419: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70420: LD_ADDR_VAR 0 3
70424: PUSH
70425: LD_INT 1
70427: PUSH
70428: LD_INT 2
70430: PUSH
70431: LD_INT 3
70433: PUSH
70434: LD_INT 4
70436: PUSH
70437: LD_INT 5
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: ST_TO_ADDR
70447: GO 71416
70449: LD_INT 3
70451: DOUBLE
70452: EQUAL
70453: IFTRUE 70457
70455: GO 70487
70457: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70458: LD_ADDR_VAR 0 3
70462: PUSH
70463: LD_INT 1
70465: PUSH
70466: LD_INT 2
70468: PUSH
70469: LD_INT 3
70471: PUSH
70472: LD_INT 4
70474: PUSH
70475: LD_INT 5
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: ST_TO_ADDR
70485: GO 71416
70487: LD_INT 11
70489: DOUBLE
70490: EQUAL
70491: IFTRUE 70495
70493: GO 70525
70495: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70496: LD_ADDR_VAR 0 3
70500: PUSH
70501: LD_INT 1
70503: PUSH
70504: LD_INT 2
70506: PUSH
70507: LD_INT 3
70509: PUSH
70510: LD_INT 4
70512: PUSH
70513: LD_INT 5
70515: PUSH
70516: EMPTY
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: ST_TO_ADDR
70523: GO 71416
70525: LD_INT 4
70527: DOUBLE
70528: EQUAL
70529: IFTRUE 70533
70531: GO 70559
70533: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70534: LD_ADDR_VAR 0 3
70538: PUSH
70539: LD_INT 2
70541: PUSH
70542: LD_INT 3
70544: PUSH
70545: LD_INT 4
70547: PUSH
70548: LD_INT 5
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: ST_TO_ADDR
70557: GO 71416
70559: LD_INT 5
70561: DOUBLE
70562: EQUAL
70563: IFTRUE 70567
70565: GO 70593
70567: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70568: LD_ADDR_VAR 0 3
70572: PUSH
70573: LD_INT 2
70575: PUSH
70576: LD_INT 3
70578: PUSH
70579: LD_INT 4
70581: PUSH
70582: LD_INT 5
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: ST_TO_ADDR
70591: GO 71416
70593: LD_INT 9
70595: DOUBLE
70596: EQUAL
70597: IFTRUE 70601
70599: GO 70627
70601: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70602: LD_ADDR_VAR 0 3
70606: PUSH
70607: LD_INT 2
70609: PUSH
70610: LD_INT 3
70612: PUSH
70613: LD_INT 4
70615: PUSH
70616: LD_INT 5
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: ST_TO_ADDR
70625: GO 71416
70627: LD_INT 7
70629: DOUBLE
70630: EQUAL
70631: IFTRUE 70635
70633: GO 70661
70635: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70636: LD_ADDR_VAR 0 3
70640: PUSH
70641: LD_INT 2
70643: PUSH
70644: LD_INT 3
70646: PUSH
70647: LD_INT 4
70649: PUSH
70650: LD_INT 5
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: ST_TO_ADDR
70659: GO 71416
70661: LD_INT 12
70663: DOUBLE
70664: EQUAL
70665: IFTRUE 70669
70667: GO 70695
70669: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70670: LD_ADDR_VAR 0 3
70674: PUSH
70675: LD_INT 2
70677: PUSH
70678: LD_INT 3
70680: PUSH
70681: LD_INT 4
70683: PUSH
70684: LD_INT 5
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: ST_TO_ADDR
70693: GO 71416
70695: LD_INT 13
70697: DOUBLE
70698: EQUAL
70699: IFTRUE 70703
70701: GO 70729
70703: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70704: LD_ADDR_VAR 0 3
70708: PUSH
70709: LD_INT 2
70711: PUSH
70712: LD_INT 3
70714: PUSH
70715: LD_INT 4
70717: PUSH
70718: LD_INT 5
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: ST_TO_ADDR
70727: GO 71416
70729: LD_INT 14
70731: DOUBLE
70732: EQUAL
70733: IFTRUE 70737
70735: GO 70755
70737: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70738: LD_ADDR_VAR 0 3
70742: PUSH
70743: LD_INT 4
70745: PUSH
70746: LD_INT 5
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: ST_TO_ADDR
70753: GO 71416
70755: LD_INT 6
70757: DOUBLE
70758: EQUAL
70759: IFTRUE 70763
70761: GO 70781
70763: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70764: LD_ADDR_VAR 0 3
70768: PUSH
70769: LD_INT 4
70771: PUSH
70772: LD_INT 5
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: ST_TO_ADDR
70779: GO 71416
70781: LD_INT 10
70783: DOUBLE
70784: EQUAL
70785: IFTRUE 70789
70787: GO 70807
70789: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70790: LD_ADDR_VAR 0 3
70794: PUSH
70795: LD_INT 4
70797: PUSH
70798: LD_INT 5
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: ST_TO_ADDR
70805: GO 71416
70807: LD_INT 22
70809: DOUBLE
70810: EQUAL
70811: IFTRUE 70815
70813: GO 70841
70815: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70816: LD_ADDR_VAR 0 3
70820: PUSH
70821: LD_INT 11
70823: PUSH
70824: LD_INT 12
70826: PUSH
70827: LD_INT 13
70829: PUSH
70830: LD_INT 14
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: LIST
70837: LIST
70838: ST_TO_ADDR
70839: GO 71416
70841: LD_INT 23
70843: DOUBLE
70844: EQUAL
70845: IFTRUE 70849
70847: GO 70875
70849: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70850: LD_ADDR_VAR 0 3
70854: PUSH
70855: LD_INT 11
70857: PUSH
70858: LD_INT 12
70860: PUSH
70861: LD_INT 13
70863: PUSH
70864: LD_INT 14
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: ST_TO_ADDR
70873: GO 71416
70875: LD_INT 24
70877: DOUBLE
70878: EQUAL
70879: IFTRUE 70883
70881: GO 70909
70883: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70884: LD_ADDR_VAR 0 3
70888: PUSH
70889: LD_INT 11
70891: PUSH
70892: LD_INT 12
70894: PUSH
70895: LD_INT 13
70897: PUSH
70898: LD_INT 14
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: ST_TO_ADDR
70907: GO 71416
70909: LD_INT 30
70911: DOUBLE
70912: EQUAL
70913: IFTRUE 70917
70915: GO 70943
70917: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70918: LD_ADDR_VAR 0 3
70922: PUSH
70923: LD_INT 11
70925: PUSH
70926: LD_INT 12
70928: PUSH
70929: LD_INT 13
70931: PUSH
70932: LD_INT 14
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: ST_TO_ADDR
70941: GO 71416
70943: LD_INT 25
70945: DOUBLE
70946: EQUAL
70947: IFTRUE 70951
70949: GO 70969
70951: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70952: LD_ADDR_VAR 0 3
70956: PUSH
70957: LD_INT 13
70959: PUSH
70960: LD_INT 14
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: ST_TO_ADDR
70967: GO 71416
70969: LD_INT 27
70971: DOUBLE
70972: EQUAL
70973: IFTRUE 70977
70975: GO 70995
70977: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70978: LD_ADDR_VAR 0 3
70982: PUSH
70983: LD_INT 13
70985: PUSH
70986: LD_INT 14
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: ST_TO_ADDR
70993: GO 71416
70995: LD_INT 28
70997: DOUBLE
70998: EQUAL
70999: IFTRUE 71003
71001: GO 71021
71003: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71004: LD_ADDR_VAR 0 3
71008: PUSH
71009: LD_INT 13
71011: PUSH
71012: LD_INT 14
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: ST_TO_ADDR
71019: GO 71416
71021: LD_INT 29
71023: DOUBLE
71024: EQUAL
71025: IFTRUE 71029
71027: GO 71047
71029: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71030: LD_ADDR_VAR 0 3
71034: PUSH
71035: LD_INT 13
71037: PUSH
71038: LD_INT 14
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: ST_TO_ADDR
71045: GO 71416
71047: LD_INT 31
71049: DOUBLE
71050: EQUAL
71051: IFTRUE 71055
71053: GO 71073
71055: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71056: LD_ADDR_VAR 0 3
71060: PUSH
71061: LD_INT 13
71063: PUSH
71064: LD_INT 14
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: ST_TO_ADDR
71071: GO 71416
71073: LD_INT 26
71075: DOUBLE
71076: EQUAL
71077: IFTRUE 71081
71079: GO 71099
71081: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71082: LD_ADDR_VAR 0 3
71086: PUSH
71087: LD_INT 13
71089: PUSH
71090: LD_INT 14
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: ST_TO_ADDR
71097: GO 71416
71099: LD_INT 42
71101: DOUBLE
71102: EQUAL
71103: IFTRUE 71107
71105: GO 71133
71107: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71108: LD_ADDR_VAR 0 3
71112: PUSH
71113: LD_INT 21
71115: PUSH
71116: LD_INT 22
71118: PUSH
71119: LD_INT 23
71121: PUSH
71122: LD_INT 24
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: ST_TO_ADDR
71131: GO 71416
71133: LD_INT 43
71135: DOUBLE
71136: EQUAL
71137: IFTRUE 71141
71139: GO 71167
71141: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71142: LD_ADDR_VAR 0 3
71146: PUSH
71147: LD_INT 21
71149: PUSH
71150: LD_INT 22
71152: PUSH
71153: LD_INT 23
71155: PUSH
71156: LD_INT 24
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: ST_TO_ADDR
71165: GO 71416
71167: LD_INT 44
71169: DOUBLE
71170: EQUAL
71171: IFTRUE 71175
71173: GO 71201
71175: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71176: LD_ADDR_VAR 0 3
71180: PUSH
71181: LD_INT 21
71183: PUSH
71184: LD_INT 22
71186: PUSH
71187: LD_INT 23
71189: PUSH
71190: LD_INT 24
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: LIST
71197: LIST
71198: ST_TO_ADDR
71199: GO 71416
71201: LD_INT 45
71203: DOUBLE
71204: EQUAL
71205: IFTRUE 71209
71207: GO 71235
71209: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71210: LD_ADDR_VAR 0 3
71214: PUSH
71215: LD_INT 21
71217: PUSH
71218: LD_INT 22
71220: PUSH
71221: LD_INT 23
71223: PUSH
71224: LD_INT 24
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: LIST
71231: LIST
71232: ST_TO_ADDR
71233: GO 71416
71235: LD_INT 49
71237: DOUBLE
71238: EQUAL
71239: IFTRUE 71243
71241: GO 71269
71243: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71244: LD_ADDR_VAR 0 3
71248: PUSH
71249: LD_INT 21
71251: PUSH
71252: LD_INT 22
71254: PUSH
71255: LD_INT 23
71257: PUSH
71258: LD_INT 24
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: ST_TO_ADDR
71267: GO 71416
71269: LD_INT 51
71271: DOUBLE
71272: EQUAL
71273: IFTRUE 71277
71275: GO 71303
71277: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71278: LD_ADDR_VAR 0 3
71282: PUSH
71283: LD_INT 21
71285: PUSH
71286: LD_INT 22
71288: PUSH
71289: LD_INT 23
71291: PUSH
71292: LD_INT 24
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: ST_TO_ADDR
71301: GO 71416
71303: LD_INT 52
71305: DOUBLE
71306: EQUAL
71307: IFTRUE 71311
71309: GO 71337
71311: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71312: LD_ADDR_VAR 0 3
71316: PUSH
71317: LD_INT 21
71319: PUSH
71320: LD_INT 22
71322: PUSH
71323: LD_INT 23
71325: PUSH
71326: LD_INT 24
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: ST_TO_ADDR
71335: GO 71416
71337: LD_INT 53
71339: DOUBLE
71340: EQUAL
71341: IFTRUE 71345
71343: GO 71363
71345: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71346: LD_ADDR_VAR 0 3
71350: PUSH
71351: LD_INT 23
71353: PUSH
71354: LD_INT 24
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: ST_TO_ADDR
71361: GO 71416
71363: LD_INT 46
71365: DOUBLE
71366: EQUAL
71367: IFTRUE 71371
71369: GO 71389
71371: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71372: LD_ADDR_VAR 0 3
71376: PUSH
71377: LD_INT 23
71379: PUSH
71380: LD_INT 24
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: ST_TO_ADDR
71387: GO 71416
71389: LD_INT 47
71391: DOUBLE
71392: EQUAL
71393: IFTRUE 71397
71395: GO 71415
71397: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71398: LD_ADDR_VAR 0 3
71402: PUSH
71403: LD_INT 23
71405: PUSH
71406: LD_INT 24
71408: PUSH
71409: EMPTY
71410: LIST
71411: LIST
71412: ST_TO_ADDR
71413: GO 71416
71415: POP
// result := ( chassis in result ) ;
71416: LD_ADDR_VAR 0 3
71420: PUSH
71421: LD_VAR 0 1
71425: PUSH
71426: LD_VAR 0 3
71430: IN
71431: ST_TO_ADDR
// end ;
71432: LD_VAR 0 3
71436: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71437: LD_INT 0
71439: PPUSH
71440: PPUSH
71441: PPUSH
71442: PPUSH
71443: PPUSH
71444: PPUSH
71445: PPUSH
// result := array ;
71446: LD_ADDR_VAR 0 5
71450: PUSH
71451: LD_VAR 0 1
71455: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71456: LD_VAR 0 1
71460: NOT
71461: PUSH
71462: LD_VAR 0 2
71466: NOT
71467: OR
71468: PUSH
71469: LD_VAR 0 3
71473: NOT
71474: OR
71475: PUSH
71476: LD_VAR 0 2
71480: PUSH
71481: LD_VAR 0 1
71485: GREATER
71486: OR
71487: PUSH
71488: LD_VAR 0 3
71492: PUSH
71493: LD_VAR 0 1
71497: GREATER
71498: OR
71499: IFFALSE 71503
// exit ;
71501: GO 71799
// if direction then
71503: LD_VAR 0 4
71507: IFFALSE 71571
// begin d := 1 ;
71509: LD_ADDR_VAR 0 9
71513: PUSH
71514: LD_INT 1
71516: ST_TO_ADDR
// if i_from > i_to then
71517: LD_VAR 0 2
71521: PUSH
71522: LD_VAR 0 3
71526: GREATER
71527: IFFALSE 71553
// length := ( array - i_from ) + i_to else
71529: LD_ADDR_VAR 0 11
71533: PUSH
71534: LD_VAR 0 1
71538: PUSH
71539: LD_VAR 0 2
71543: MINUS
71544: PUSH
71545: LD_VAR 0 3
71549: PLUS
71550: ST_TO_ADDR
71551: GO 71569
// length := i_to - i_from ;
71553: LD_ADDR_VAR 0 11
71557: PUSH
71558: LD_VAR 0 3
71562: PUSH
71563: LD_VAR 0 2
71567: MINUS
71568: ST_TO_ADDR
// end else
71569: GO 71632
// begin d := - 1 ;
71571: LD_ADDR_VAR 0 9
71575: PUSH
71576: LD_INT 1
71578: NEG
71579: ST_TO_ADDR
// if i_from > i_to then
71580: LD_VAR 0 2
71584: PUSH
71585: LD_VAR 0 3
71589: GREATER
71590: IFFALSE 71610
// length := i_from - i_to else
71592: LD_ADDR_VAR 0 11
71596: PUSH
71597: LD_VAR 0 2
71601: PUSH
71602: LD_VAR 0 3
71606: MINUS
71607: ST_TO_ADDR
71608: GO 71632
// length := ( array - i_to ) + i_from ;
71610: LD_ADDR_VAR 0 11
71614: PUSH
71615: LD_VAR 0 1
71619: PUSH
71620: LD_VAR 0 3
71624: MINUS
71625: PUSH
71626: LD_VAR 0 2
71630: PLUS
71631: ST_TO_ADDR
// end ; if not length then
71632: LD_VAR 0 11
71636: NOT
71637: IFFALSE 71641
// exit ;
71639: GO 71799
// tmp := array ;
71641: LD_ADDR_VAR 0 10
71645: PUSH
71646: LD_VAR 0 1
71650: ST_TO_ADDR
// for i = 1 to length do
71651: LD_ADDR_VAR 0 6
71655: PUSH
71656: DOUBLE
71657: LD_INT 1
71659: DEC
71660: ST_TO_ADDR
71661: LD_VAR 0 11
71665: PUSH
71666: FOR_TO
71667: IFFALSE 71787
// begin for j = 1 to array do
71669: LD_ADDR_VAR 0 7
71673: PUSH
71674: DOUBLE
71675: LD_INT 1
71677: DEC
71678: ST_TO_ADDR
71679: LD_VAR 0 1
71683: PUSH
71684: FOR_TO
71685: IFFALSE 71773
// begin k := j + d ;
71687: LD_ADDR_VAR 0 8
71691: PUSH
71692: LD_VAR 0 7
71696: PUSH
71697: LD_VAR 0 9
71701: PLUS
71702: ST_TO_ADDR
// if k > array then
71703: LD_VAR 0 8
71707: PUSH
71708: LD_VAR 0 1
71712: GREATER
71713: IFFALSE 71723
// k := 1 ;
71715: LD_ADDR_VAR 0 8
71719: PUSH
71720: LD_INT 1
71722: ST_TO_ADDR
// if not k then
71723: LD_VAR 0 8
71727: NOT
71728: IFFALSE 71740
// k := array ;
71730: LD_ADDR_VAR 0 8
71734: PUSH
71735: LD_VAR 0 1
71739: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71740: LD_ADDR_VAR 0 10
71744: PUSH
71745: LD_VAR 0 10
71749: PPUSH
71750: LD_VAR 0 8
71754: PPUSH
71755: LD_VAR 0 1
71759: PUSH
71760: LD_VAR 0 7
71764: ARRAY
71765: PPUSH
71766: CALL_OW 1
71770: ST_TO_ADDR
// end ;
71771: GO 71684
71773: POP
71774: POP
// array := tmp ;
71775: LD_ADDR_VAR 0 1
71779: PUSH
71780: LD_VAR 0 10
71784: ST_TO_ADDR
// end ;
71785: GO 71666
71787: POP
71788: POP
// result := array ;
71789: LD_ADDR_VAR 0 5
71793: PUSH
71794: LD_VAR 0 1
71798: ST_TO_ADDR
// end ;
71799: LD_VAR 0 5
71803: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71804: LD_INT 0
71806: PPUSH
71807: PPUSH
// result := 0 ;
71808: LD_ADDR_VAR 0 3
71812: PUSH
71813: LD_INT 0
71815: ST_TO_ADDR
// if not array or not value in array then
71816: LD_VAR 0 1
71820: NOT
71821: PUSH
71822: LD_VAR 0 2
71826: PUSH
71827: LD_VAR 0 1
71831: IN
71832: NOT
71833: OR
71834: IFFALSE 71838
// exit ;
71836: GO 71892
// for i = 1 to array do
71838: LD_ADDR_VAR 0 4
71842: PUSH
71843: DOUBLE
71844: LD_INT 1
71846: DEC
71847: ST_TO_ADDR
71848: LD_VAR 0 1
71852: PUSH
71853: FOR_TO
71854: IFFALSE 71890
// if value = array [ i ] then
71856: LD_VAR 0 2
71860: PUSH
71861: LD_VAR 0 1
71865: PUSH
71866: LD_VAR 0 4
71870: ARRAY
71871: EQUAL
71872: IFFALSE 71888
// begin result := i ;
71874: LD_ADDR_VAR 0 3
71878: PUSH
71879: LD_VAR 0 4
71883: ST_TO_ADDR
// exit ;
71884: POP
71885: POP
71886: GO 71892
// end ;
71888: GO 71853
71890: POP
71891: POP
// end ;
71892: LD_VAR 0 3
71896: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71897: LD_INT 0
71899: PPUSH
// vc_chassis := chassis ;
71900: LD_ADDR_OWVAR 37
71904: PUSH
71905: LD_VAR 0 1
71909: ST_TO_ADDR
// vc_engine := engine ;
71910: LD_ADDR_OWVAR 39
71914: PUSH
71915: LD_VAR 0 2
71919: ST_TO_ADDR
// vc_control := control ;
71920: LD_ADDR_OWVAR 38
71924: PUSH
71925: LD_VAR 0 3
71929: ST_TO_ADDR
// vc_weapon := weapon ;
71930: LD_ADDR_OWVAR 40
71934: PUSH
71935: LD_VAR 0 4
71939: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71940: LD_ADDR_OWVAR 41
71944: PUSH
71945: LD_VAR 0 5
71949: ST_TO_ADDR
// end ;
71950: LD_VAR 0 6
71954: RET
// export function WantPlant ( unit ) ; var task ; begin
71955: LD_INT 0
71957: PPUSH
71958: PPUSH
// result := false ;
71959: LD_ADDR_VAR 0 2
71963: PUSH
71964: LD_INT 0
71966: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71967: LD_ADDR_VAR 0 3
71971: PUSH
71972: LD_VAR 0 1
71976: PPUSH
71977: CALL_OW 437
71981: ST_TO_ADDR
// if task then
71982: LD_VAR 0 3
71986: IFFALSE 72014
// if task [ 1 ] [ 1 ] = p then
71988: LD_VAR 0 3
71992: PUSH
71993: LD_INT 1
71995: ARRAY
71996: PUSH
71997: LD_INT 1
71999: ARRAY
72000: PUSH
72001: LD_STRING p
72003: EQUAL
72004: IFFALSE 72014
// result := true ;
72006: LD_ADDR_VAR 0 2
72010: PUSH
72011: LD_INT 1
72013: ST_TO_ADDR
// end ;
72014: LD_VAR 0 2
72018: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72019: LD_INT 0
72021: PPUSH
72022: PPUSH
72023: PPUSH
72024: PPUSH
// if pos < 1 then
72025: LD_VAR 0 2
72029: PUSH
72030: LD_INT 1
72032: LESS
72033: IFFALSE 72037
// exit ;
72035: GO 72340
// if pos = 1 then
72037: LD_VAR 0 2
72041: PUSH
72042: LD_INT 1
72044: EQUAL
72045: IFFALSE 72078
// result := Replace ( arr , pos [ 1 ] , value ) else
72047: LD_ADDR_VAR 0 4
72051: PUSH
72052: LD_VAR 0 1
72056: PPUSH
72057: LD_VAR 0 2
72061: PUSH
72062: LD_INT 1
72064: ARRAY
72065: PPUSH
72066: LD_VAR 0 3
72070: PPUSH
72071: CALL_OW 1
72075: ST_TO_ADDR
72076: GO 72340
// begin tmp := arr ;
72078: LD_ADDR_VAR 0 6
72082: PUSH
72083: LD_VAR 0 1
72087: ST_TO_ADDR
// s_arr := [ tmp ] ;
72088: LD_ADDR_VAR 0 7
72092: PUSH
72093: LD_VAR 0 6
72097: PUSH
72098: EMPTY
72099: LIST
72100: ST_TO_ADDR
// for i = 1 to pos - 1 do
72101: LD_ADDR_VAR 0 5
72105: PUSH
72106: DOUBLE
72107: LD_INT 1
72109: DEC
72110: ST_TO_ADDR
72111: LD_VAR 0 2
72115: PUSH
72116: LD_INT 1
72118: MINUS
72119: PUSH
72120: FOR_TO
72121: IFFALSE 72166
// begin tmp := tmp [ pos [ i ] ] ;
72123: LD_ADDR_VAR 0 6
72127: PUSH
72128: LD_VAR 0 6
72132: PUSH
72133: LD_VAR 0 2
72137: PUSH
72138: LD_VAR 0 5
72142: ARRAY
72143: ARRAY
72144: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72145: LD_ADDR_VAR 0 7
72149: PUSH
72150: LD_VAR 0 7
72154: PUSH
72155: LD_VAR 0 6
72159: PUSH
72160: EMPTY
72161: LIST
72162: ADD
72163: ST_TO_ADDR
// end ;
72164: GO 72120
72166: POP
72167: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72168: LD_ADDR_VAR 0 6
72172: PUSH
72173: LD_VAR 0 6
72177: PPUSH
72178: LD_VAR 0 2
72182: PUSH
72183: LD_VAR 0 2
72187: ARRAY
72188: PPUSH
72189: LD_VAR 0 3
72193: PPUSH
72194: CALL_OW 1
72198: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72199: LD_ADDR_VAR 0 7
72203: PUSH
72204: LD_VAR 0 7
72208: PPUSH
72209: LD_VAR 0 7
72213: PPUSH
72214: LD_VAR 0 6
72218: PPUSH
72219: CALL_OW 1
72223: ST_TO_ADDR
// for i = s_arr downto 2 do
72224: LD_ADDR_VAR 0 5
72228: PUSH
72229: DOUBLE
72230: LD_VAR 0 7
72234: INC
72235: ST_TO_ADDR
72236: LD_INT 2
72238: PUSH
72239: FOR_DOWNTO
72240: IFFALSE 72324
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72242: LD_ADDR_VAR 0 6
72246: PUSH
72247: LD_VAR 0 7
72251: PUSH
72252: LD_VAR 0 5
72256: PUSH
72257: LD_INT 1
72259: MINUS
72260: ARRAY
72261: PPUSH
72262: LD_VAR 0 2
72266: PUSH
72267: LD_VAR 0 5
72271: PUSH
72272: LD_INT 1
72274: MINUS
72275: ARRAY
72276: PPUSH
72277: LD_VAR 0 7
72281: PUSH
72282: LD_VAR 0 5
72286: ARRAY
72287: PPUSH
72288: CALL_OW 1
72292: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72293: LD_ADDR_VAR 0 7
72297: PUSH
72298: LD_VAR 0 7
72302: PPUSH
72303: LD_VAR 0 5
72307: PUSH
72308: LD_INT 1
72310: MINUS
72311: PPUSH
72312: LD_VAR 0 6
72316: PPUSH
72317: CALL_OW 1
72321: ST_TO_ADDR
// end ;
72322: GO 72239
72324: POP
72325: POP
// result := s_arr [ 1 ] ;
72326: LD_ADDR_VAR 0 4
72330: PUSH
72331: LD_VAR 0 7
72335: PUSH
72336: LD_INT 1
72338: ARRAY
72339: ST_TO_ADDR
// end ; end ;
72340: LD_VAR 0 4
72344: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72345: LD_INT 0
72347: PPUSH
72348: PPUSH
// if not list then
72349: LD_VAR 0 1
72353: NOT
72354: IFFALSE 72358
// exit ;
72356: GO 72449
// i := list [ pos1 ] ;
72358: LD_ADDR_VAR 0 5
72362: PUSH
72363: LD_VAR 0 1
72367: PUSH
72368: LD_VAR 0 2
72372: ARRAY
72373: ST_TO_ADDR
// if not i then
72374: LD_VAR 0 5
72378: NOT
72379: IFFALSE 72383
// exit ;
72381: GO 72449
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72383: LD_ADDR_VAR 0 1
72387: PUSH
72388: LD_VAR 0 1
72392: PPUSH
72393: LD_VAR 0 2
72397: PPUSH
72398: LD_VAR 0 1
72402: PUSH
72403: LD_VAR 0 3
72407: ARRAY
72408: PPUSH
72409: CALL_OW 1
72413: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72414: LD_ADDR_VAR 0 1
72418: PUSH
72419: LD_VAR 0 1
72423: PPUSH
72424: LD_VAR 0 3
72428: PPUSH
72429: LD_VAR 0 5
72433: PPUSH
72434: CALL_OW 1
72438: ST_TO_ADDR
// result := list ;
72439: LD_ADDR_VAR 0 4
72443: PUSH
72444: LD_VAR 0 1
72448: ST_TO_ADDR
// end ;
72449: LD_VAR 0 4
72453: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72454: LD_INT 0
72456: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72457: LD_ADDR_VAR 0 5
72461: PUSH
72462: LD_VAR 0 1
72466: PPUSH
72467: CALL_OW 250
72471: PPUSH
72472: LD_VAR 0 1
72476: PPUSH
72477: CALL_OW 251
72481: PPUSH
72482: LD_VAR 0 2
72486: PPUSH
72487: LD_VAR 0 3
72491: PPUSH
72492: LD_VAR 0 4
72496: PPUSH
72497: CALL 72507 0 5
72501: ST_TO_ADDR
// end ;
72502: LD_VAR 0 5
72506: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72507: LD_INT 0
72509: PPUSH
72510: PPUSH
72511: PPUSH
72512: PPUSH
// if not list then
72513: LD_VAR 0 3
72517: NOT
72518: IFFALSE 72522
// exit ;
72520: GO 72910
// result := [ ] ;
72522: LD_ADDR_VAR 0 6
72526: PUSH
72527: EMPTY
72528: ST_TO_ADDR
// for i in list do
72529: LD_ADDR_VAR 0 7
72533: PUSH
72534: LD_VAR 0 3
72538: PUSH
72539: FOR_IN
72540: IFFALSE 72742
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72542: LD_ADDR_VAR 0 9
72546: PUSH
72547: LD_VAR 0 7
72551: PPUSH
72552: LD_VAR 0 1
72556: PPUSH
72557: LD_VAR 0 2
72561: PPUSH
72562: CALL_OW 297
72566: ST_TO_ADDR
// if not result then
72567: LD_VAR 0 6
72571: NOT
72572: IFFALSE 72598
// result := [ [ i , tmp ] ] else
72574: LD_ADDR_VAR 0 6
72578: PUSH
72579: LD_VAR 0 7
72583: PUSH
72584: LD_VAR 0 9
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: EMPTY
72594: LIST
72595: ST_TO_ADDR
72596: GO 72740
// begin if result [ result ] [ 2 ] < tmp then
72598: LD_VAR 0 6
72602: PUSH
72603: LD_VAR 0 6
72607: ARRAY
72608: PUSH
72609: LD_INT 2
72611: ARRAY
72612: PUSH
72613: LD_VAR 0 9
72617: LESS
72618: IFFALSE 72660
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72620: LD_ADDR_VAR 0 6
72624: PUSH
72625: LD_VAR 0 6
72629: PPUSH
72630: LD_VAR 0 6
72634: PUSH
72635: LD_INT 1
72637: PLUS
72638: PPUSH
72639: LD_VAR 0 7
72643: PUSH
72644: LD_VAR 0 9
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PPUSH
72653: CALL_OW 2
72657: ST_TO_ADDR
72658: GO 72740
// for j = 1 to result do
72660: LD_ADDR_VAR 0 8
72664: PUSH
72665: DOUBLE
72666: LD_INT 1
72668: DEC
72669: ST_TO_ADDR
72670: LD_VAR 0 6
72674: PUSH
72675: FOR_TO
72676: IFFALSE 72738
// begin if tmp < result [ j ] [ 2 ] then
72678: LD_VAR 0 9
72682: PUSH
72683: LD_VAR 0 6
72687: PUSH
72688: LD_VAR 0 8
72692: ARRAY
72693: PUSH
72694: LD_INT 2
72696: ARRAY
72697: LESS
72698: IFFALSE 72736
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72700: LD_ADDR_VAR 0 6
72704: PUSH
72705: LD_VAR 0 6
72709: PPUSH
72710: LD_VAR 0 8
72714: PPUSH
72715: LD_VAR 0 7
72719: PUSH
72720: LD_VAR 0 9
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PPUSH
72729: CALL_OW 2
72733: ST_TO_ADDR
// break ;
72734: GO 72738
// end ; end ;
72736: GO 72675
72738: POP
72739: POP
// end ; end ;
72740: GO 72539
72742: POP
72743: POP
// if result and not asc then
72744: LD_VAR 0 6
72748: PUSH
72749: LD_VAR 0 4
72753: NOT
72754: AND
72755: IFFALSE 72830
// begin tmp := result ;
72757: LD_ADDR_VAR 0 9
72761: PUSH
72762: LD_VAR 0 6
72766: ST_TO_ADDR
// for i = tmp downto 1 do
72767: LD_ADDR_VAR 0 7
72771: PUSH
72772: DOUBLE
72773: LD_VAR 0 9
72777: INC
72778: ST_TO_ADDR
72779: LD_INT 1
72781: PUSH
72782: FOR_DOWNTO
72783: IFFALSE 72828
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72785: LD_ADDR_VAR 0 6
72789: PUSH
72790: LD_VAR 0 6
72794: PPUSH
72795: LD_VAR 0 9
72799: PUSH
72800: LD_VAR 0 7
72804: MINUS
72805: PUSH
72806: LD_INT 1
72808: PLUS
72809: PPUSH
72810: LD_VAR 0 9
72814: PUSH
72815: LD_VAR 0 7
72819: ARRAY
72820: PPUSH
72821: CALL_OW 1
72825: ST_TO_ADDR
72826: GO 72782
72828: POP
72829: POP
// end ; tmp := [ ] ;
72830: LD_ADDR_VAR 0 9
72834: PUSH
72835: EMPTY
72836: ST_TO_ADDR
// if mode then
72837: LD_VAR 0 5
72841: IFFALSE 72910
// begin for i = 1 to result do
72843: LD_ADDR_VAR 0 7
72847: PUSH
72848: DOUBLE
72849: LD_INT 1
72851: DEC
72852: ST_TO_ADDR
72853: LD_VAR 0 6
72857: PUSH
72858: FOR_TO
72859: IFFALSE 72898
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72861: LD_ADDR_VAR 0 9
72865: PUSH
72866: LD_VAR 0 9
72870: PPUSH
72871: LD_VAR 0 7
72875: PPUSH
72876: LD_VAR 0 6
72880: PUSH
72881: LD_VAR 0 7
72885: ARRAY
72886: PUSH
72887: LD_INT 1
72889: ARRAY
72890: PPUSH
72891: CALL_OW 1
72895: ST_TO_ADDR
72896: GO 72858
72898: POP
72899: POP
// result := tmp ;
72900: LD_ADDR_VAR 0 6
72904: PUSH
72905: LD_VAR 0 9
72909: ST_TO_ADDR
// end ; end ;
72910: LD_VAR 0 6
72914: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72915: LD_INT 0
72917: PPUSH
72918: PPUSH
72919: PPUSH
72920: PPUSH
72921: PPUSH
72922: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72923: LD_ADDR_VAR 0 5
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: LD_INT 0
72933: PUSH
72934: LD_INT 0
72936: PUSH
72937: EMPTY
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: LIST
72943: LIST
72944: ST_TO_ADDR
// if not x or not y then
72945: LD_VAR 0 2
72949: NOT
72950: PUSH
72951: LD_VAR 0 3
72955: NOT
72956: OR
72957: IFFALSE 72961
// exit ;
72959: GO 74607
// if not range then
72961: LD_VAR 0 4
72965: NOT
72966: IFFALSE 72976
// range := 10 ;
72968: LD_ADDR_VAR 0 4
72972: PUSH
72973: LD_INT 10
72975: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72976: LD_ADDR_VAR 0 8
72980: PUSH
72981: LD_INT 81
72983: PUSH
72984: LD_VAR 0 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: LD_INT 92
72995: PUSH
72996: LD_VAR 0 2
73000: PUSH
73001: LD_VAR 0 3
73005: PUSH
73006: LD_VAR 0 4
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: PUSH
73017: LD_INT 3
73019: PUSH
73020: LD_INT 21
73022: PUSH
73023: LD_INT 3
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: EMPTY
73031: LIST
73032: LIST
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: LIST
73038: PPUSH
73039: CALL_OW 69
73043: ST_TO_ADDR
// if not tmp then
73044: LD_VAR 0 8
73048: NOT
73049: IFFALSE 73053
// exit ;
73051: GO 74607
// for i in tmp do
73053: LD_ADDR_VAR 0 6
73057: PUSH
73058: LD_VAR 0 8
73062: PUSH
73063: FOR_IN
73064: IFFALSE 74582
// begin points := [ 0 , 0 , 0 ] ;
73066: LD_ADDR_VAR 0 9
73070: PUSH
73071: LD_INT 0
73073: PUSH
73074: LD_INT 0
73076: PUSH
73077: LD_INT 0
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: LIST
73084: ST_TO_ADDR
// bpoints := 1 ;
73085: LD_ADDR_VAR 0 10
73089: PUSH
73090: LD_INT 1
73092: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73093: LD_VAR 0 6
73097: PPUSH
73098: CALL_OW 247
73102: PUSH
73103: LD_INT 1
73105: DOUBLE
73106: EQUAL
73107: IFTRUE 73111
73109: GO 73689
73111: POP
// begin if GetClass ( i ) = 1 then
73112: LD_VAR 0 6
73116: PPUSH
73117: CALL_OW 257
73121: PUSH
73122: LD_INT 1
73124: EQUAL
73125: IFFALSE 73146
// points := [ 10 , 5 , 3 ] ;
73127: LD_ADDR_VAR 0 9
73131: PUSH
73132: LD_INT 10
73134: PUSH
73135: LD_INT 5
73137: PUSH
73138: LD_INT 3
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: LIST
73145: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73146: LD_VAR 0 6
73150: PPUSH
73151: CALL_OW 257
73155: PUSH
73156: LD_INT 2
73158: PUSH
73159: LD_INT 3
73161: PUSH
73162: LD_INT 4
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: LIST
73169: IN
73170: IFFALSE 73191
// points := [ 3 , 2 , 1 ] ;
73172: LD_ADDR_VAR 0 9
73176: PUSH
73177: LD_INT 3
73179: PUSH
73180: LD_INT 2
73182: PUSH
73183: LD_INT 1
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: LIST
73190: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73191: LD_VAR 0 6
73195: PPUSH
73196: CALL_OW 257
73200: PUSH
73201: LD_INT 5
73203: EQUAL
73204: IFFALSE 73225
// points := [ 130 , 5 , 2 ] ;
73206: LD_ADDR_VAR 0 9
73210: PUSH
73211: LD_INT 130
73213: PUSH
73214: LD_INT 5
73216: PUSH
73217: LD_INT 2
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: LIST
73224: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73225: LD_VAR 0 6
73229: PPUSH
73230: CALL_OW 257
73234: PUSH
73235: LD_INT 8
73237: EQUAL
73238: IFFALSE 73259
// points := [ 35 , 35 , 30 ] ;
73240: LD_ADDR_VAR 0 9
73244: PUSH
73245: LD_INT 35
73247: PUSH
73248: LD_INT 35
73250: PUSH
73251: LD_INT 30
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: LIST
73258: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73259: LD_VAR 0 6
73263: PPUSH
73264: CALL_OW 257
73268: PUSH
73269: LD_INT 9
73271: EQUAL
73272: IFFALSE 73293
// points := [ 20 , 55 , 40 ] ;
73274: LD_ADDR_VAR 0 9
73278: PUSH
73279: LD_INT 20
73281: PUSH
73282: LD_INT 55
73284: PUSH
73285: LD_INT 40
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73293: LD_VAR 0 6
73297: PPUSH
73298: CALL_OW 257
73302: PUSH
73303: LD_INT 12
73305: PUSH
73306: LD_INT 16
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: IN
73313: IFFALSE 73334
// points := [ 5 , 3 , 2 ] ;
73315: LD_ADDR_VAR 0 9
73319: PUSH
73320: LD_INT 5
73322: PUSH
73323: LD_INT 3
73325: PUSH
73326: LD_INT 2
73328: PUSH
73329: EMPTY
73330: LIST
73331: LIST
73332: LIST
73333: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73334: LD_VAR 0 6
73338: PPUSH
73339: CALL_OW 257
73343: PUSH
73344: LD_INT 17
73346: EQUAL
73347: IFFALSE 73368
// points := [ 100 , 50 , 75 ] ;
73349: LD_ADDR_VAR 0 9
73353: PUSH
73354: LD_INT 100
73356: PUSH
73357: LD_INT 50
73359: PUSH
73360: LD_INT 75
73362: PUSH
73363: EMPTY
73364: LIST
73365: LIST
73366: LIST
73367: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73368: LD_VAR 0 6
73372: PPUSH
73373: CALL_OW 257
73377: PUSH
73378: LD_INT 15
73380: EQUAL
73381: IFFALSE 73402
// points := [ 10 , 5 , 3 ] ;
73383: LD_ADDR_VAR 0 9
73387: PUSH
73388: LD_INT 10
73390: PUSH
73391: LD_INT 5
73393: PUSH
73394: LD_INT 3
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: LIST
73401: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73402: LD_VAR 0 6
73406: PPUSH
73407: CALL_OW 257
73411: PUSH
73412: LD_INT 14
73414: EQUAL
73415: IFFALSE 73436
// points := [ 10 , 0 , 0 ] ;
73417: LD_ADDR_VAR 0 9
73421: PUSH
73422: LD_INT 10
73424: PUSH
73425: LD_INT 0
73427: PUSH
73428: LD_INT 0
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: LIST
73435: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73436: LD_VAR 0 6
73440: PPUSH
73441: CALL_OW 257
73445: PUSH
73446: LD_INT 11
73448: EQUAL
73449: IFFALSE 73470
// points := [ 30 , 10 , 5 ] ;
73451: LD_ADDR_VAR 0 9
73455: PUSH
73456: LD_INT 30
73458: PUSH
73459: LD_INT 10
73461: PUSH
73462: LD_INT 5
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: LIST
73469: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73470: LD_VAR 0 1
73474: PPUSH
73475: LD_INT 5
73477: PPUSH
73478: CALL_OW 321
73482: PUSH
73483: LD_INT 2
73485: EQUAL
73486: IFFALSE 73503
// bpoints := bpoints * 1.8 ;
73488: LD_ADDR_VAR 0 10
73492: PUSH
73493: LD_VAR 0 10
73497: PUSH
73498: LD_REAL  1.80000000000000E+0000
73501: MUL
73502: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73503: LD_VAR 0 6
73507: PPUSH
73508: CALL_OW 257
73512: PUSH
73513: LD_INT 1
73515: PUSH
73516: LD_INT 2
73518: PUSH
73519: LD_INT 3
73521: PUSH
73522: LD_INT 4
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: IN
73531: PUSH
73532: LD_VAR 0 1
73536: PPUSH
73537: LD_INT 51
73539: PPUSH
73540: CALL_OW 321
73544: PUSH
73545: LD_INT 2
73547: EQUAL
73548: AND
73549: IFFALSE 73566
// bpoints := bpoints * 1.2 ;
73551: LD_ADDR_VAR 0 10
73555: PUSH
73556: LD_VAR 0 10
73560: PUSH
73561: LD_REAL  1.20000000000000E+0000
73564: MUL
73565: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73566: LD_VAR 0 6
73570: PPUSH
73571: CALL_OW 257
73575: PUSH
73576: LD_INT 5
73578: PUSH
73579: LD_INT 7
73581: PUSH
73582: LD_INT 9
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: LIST
73589: IN
73590: PUSH
73591: LD_VAR 0 1
73595: PPUSH
73596: LD_INT 52
73598: PPUSH
73599: CALL_OW 321
73603: PUSH
73604: LD_INT 2
73606: EQUAL
73607: AND
73608: IFFALSE 73625
// bpoints := bpoints * 1.5 ;
73610: LD_ADDR_VAR 0 10
73614: PUSH
73615: LD_VAR 0 10
73619: PUSH
73620: LD_REAL  1.50000000000000E+0000
73623: MUL
73624: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73625: LD_VAR 0 1
73629: PPUSH
73630: LD_INT 66
73632: PPUSH
73633: CALL_OW 321
73637: PUSH
73638: LD_INT 2
73640: EQUAL
73641: IFFALSE 73658
// bpoints := bpoints * 1.1 ;
73643: LD_ADDR_VAR 0 10
73647: PUSH
73648: LD_VAR 0 10
73652: PUSH
73653: LD_REAL  1.10000000000000E+0000
73656: MUL
73657: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73658: LD_ADDR_VAR 0 10
73662: PUSH
73663: LD_VAR 0 10
73667: PUSH
73668: LD_VAR 0 6
73672: PPUSH
73673: LD_INT 1
73675: PPUSH
73676: CALL_OW 259
73680: PUSH
73681: LD_REAL  1.15000000000000E+0000
73684: MUL
73685: MUL
73686: ST_TO_ADDR
// end ; unit_vehicle :
73687: GO 74511
73689: LD_INT 2
73691: DOUBLE
73692: EQUAL
73693: IFTRUE 73697
73695: GO 74499
73697: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73698: LD_VAR 0 6
73702: PPUSH
73703: CALL_OW 264
73707: PUSH
73708: LD_INT 2
73710: PUSH
73711: LD_INT 42
73713: PUSH
73714: LD_INT 24
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: LIST
73721: IN
73722: IFFALSE 73743
// points := [ 25 , 5 , 3 ] ;
73724: LD_ADDR_VAR 0 9
73728: PUSH
73729: LD_INT 25
73731: PUSH
73732: LD_INT 5
73734: PUSH
73735: LD_INT 3
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: LIST
73742: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73743: LD_VAR 0 6
73747: PPUSH
73748: CALL_OW 264
73752: PUSH
73753: LD_INT 4
73755: PUSH
73756: LD_INT 43
73758: PUSH
73759: LD_INT 25
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: LIST
73766: IN
73767: IFFALSE 73788
// points := [ 40 , 15 , 5 ] ;
73769: LD_ADDR_VAR 0 9
73773: PUSH
73774: LD_INT 40
73776: PUSH
73777: LD_INT 15
73779: PUSH
73780: LD_INT 5
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73788: LD_VAR 0 6
73792: PPUSH
73793: CALL_OW 264
73797: PUSH
73798: LD_INT 3
73800: PUSH
73801: LD_INT 23
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: IN
73808: IFFALSE 73829
// points := [ 7 , 25 , 8 ] ;
73810: LD_ADDR_VAR 0 9
73814: PUSH
73815: LD_INT 7
73817: PUSH
73818: LD_INT 25
73820: PUSH
73821: LD_INT 8
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: LIST
73828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73829: LD_VAR 0 6
73833: PPUSH
73834: CALL_OW 264
73838: PUSH
73839: LD_INT 5
73841: PUSH
73842: LD_INT 27
73844: PUSH
73845: LD_INT 44
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: LIST
73852: IN
73853: IFFALSE 73874
// points := [ 14 , 50 , 16 ] ;
73855: LD_ADDR_VAR 0 9
73859: PUSH
73860: LD_INT 14
73862: PUSH
73863: LD_INT 50
73865: PUSH
73866: LD_INT 16
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: LIST
73873: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73874: LD_VAR 0 6
73878: PPUSH
73879: CALL_OW 264
73883: PUSH
73884: LD_INT 6
73886: PUSH
73887: LD_INT 46
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: IN
73894: IFFALSE 73915
// points := [ 32 , 120 , 70 ] ;
73896: LD_ADDR_VAR 0 9
73900: PUSH
73901: LD_INT 32
73903: PUSH
73904: LD_INT 120
73906: PUSH
73907: LD_INT 70
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: LIST
73914: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73915: LD_VAR 0 6
73919: PPUSH
73920: CALL_OW 264
73924: PUSH
73925: LD_INT 7
73927: PUSH
73928: LD_INT 28
73930: PUSH
73931: LD_INT 45
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: LIST
73938: IN
73939: IFFALSE 73960
// points := [ 35 , 20 , 45 ] ;
73941: LD_ADDR_VAR 0 9
73945: PUSH
73946: LD_INT 35
73948: PUSH
73949: LD_INT 20
73951: PUSH
73952: LD_INT 45
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: LIST
73959: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73960: LD_VAR 0 6
73964: PPUSH
73965: CALL_OW 264
73969: PUSH
73970: LD_INT 47
73972: PUSH
73973: EMPTY
73974: LIST
73975: IN
73976: IFFALSE 73997
// points := [ 67 , 45 , 75 ] ;
73978: LD_ADDR_VAR 0 9
73982: PUSH
73983: LD_INT 67
73985: PUSH
73986: LD_INT 45
73988: PUSH
73989: LD_INT 75
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: LIST
73996: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73997: LD_VAR 0 6
74001: PPUSH
74002: CALL_OW 264
74006: PUSH
74007: LD_INT 26
74009: PUSH
74010: EMPTY
74011: LIST
74012: IN
74013: IFFALSE 74034
// points := [ 120 , 30 , 80 ] ;
74015: LD_ADDR_VAR 0 9
74019: PUSH
74020: LD_INT 120
74022: PUSH
74023: LD_INT 30
74025: PUSH
74026: LD_INT 80
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74034: LD_VAR 0 6
74038: PPUSH
74039: CALL_OW 264
74043: PUSH
74044: LD_INT 22
74046: PUSH
74047: EMPTY
74048: LIST
74049: IN
74050: IFFALSE 74071
// points := [ 40 , 1 , 1 ] ;
74052: LD_ADDR_VAR 0 9
74056: PUSH
74057: LD_INT 40
74059: PUSH
74060: LD_INT 1
74062: PUSH
74063: LD_INT 1
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: LIST
74070: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74071: LD_VAR 0 6
74075: PPUSH
74076: CALL_OW 264
74080: PUSH
74081: LD_INT 29
74083: PUSH
74084: EMPTY
74085: LIST
74086: IN
74087: IFFALSE 74108
// points := [ 70 , 200 , 400 ] ;
74089: LD_ADDR_VAR 0 9
74093: PUSH
74094: LD_INT 70
74096: PUSH
74097: LD_INT 200
74099: PUSH
74100: LD_INT 400
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: LIST
74107: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74108: LD_VAR 0 6
74112: PPUSH
74113: CALL_OW 264
74117: PUSH
74118: LD_INT 14
74120: PUSH
74121: LD_INT 53
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: IN
74128: IFFALSE 74149
// points := [ 40 , 10 , 20 ] ;
74130: LD_ADDR_VAR 0 9
74134: PUSH
74135: LD_INT 40
74137: PUSH
74138: LD_INT 10
74140: PUSH
74141: LD_INT 20
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: LIST
74148: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74149: LD_VAR 0 6
74153: PPUSH
74154: CALL_OW 264
74158: PUSH
74159: LD_INT 9
74161: PUSH
74162: EMPTY
74163: LIST
74164: IN
74165: IFFALSE 74186
// points := [ 5 , 70 , 20 ] ;
74167: LD_ADDR_VAR 0 9
74171: PUSH
74172: LD_INT 5
74174: PUSH
74175: LD_INT 70
74177: PUSH
74178: LD_INT 20
74180: PUSH
74181: EMPTY
74182: LIST
74183: LIST
74184: LIST
74185: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74186: LD_VAR 0 6
74190: PPUSH
74191: CALL_OW 264
74195: PUSH
74196: LD_INT 10
74198: PUSH
74199: EMPTY
74200: LIST
74201: IN
74202: IFFALSE 74223
// points := [ 35 , 110 , 70 ] ;
74204: LD_ADDR_VAR 0 9
74208: PUSH
74209: LD_INT 35
74211: PUSH
74212: LD_INT 110
74214: PUSH
74215: LD_INT 70
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: LIST
74222: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74223: LD_VAR 0 6
74227: PPUSH
74228: CALL_OW 265
74232: PUSH
74233: LD_INT 25
74235: EQUAL
74236: IFFALSE 74257
// points := [ 80 , 65 , 100 ] ;
74238: LD_ADDR_VAR 0 9
74242: PUSH
74243: LD_INT 80
74245: PUSH
74246: LD_INT 65
74248: PUSH
74249: LD_INT 100
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: LIST
74256: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74257: LD_VAR 0 6
74261: PPUSH
74262: CALL_OW 263
74266: PUSH
74267: LD_INT 1
74269: EQUAL
74270: IFFALSE 74305
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74272: LD_ADDR_VAR 0 10
74276: PUSH
74277: LD_VAR 0 10
74281: PUSH
74282: LD_VAR 0 6
74286: PPUSH
74287: CALL_OW 311
74291: PPUSH
74292: LD_INT 3
74294: PPUSH
74295: CALL_OW 259
74299: PUSH
74300: LD_INT 4
74302: MUL
74303: MUL
74304: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74305: LD_VAR 0 6
74309: PPUSH
74310: CALL_OW 263
74314: PUSH
74315: LD_INT 2
74317: EQUAL
74318: IFFALSE 74369
// begin j := IsControledBy ( i ) ;
74320: LD_ADDR_VAR 0 7
74324: PUSH
74325: LD_VAR 0 6
74329: PPUSH
74330: CALL_OW 312
74334: ST_TO_ADDR
// if j then
74335: LD_VAR 0 7
74339: IFFALSE 74369
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74341: LD_ADDR_VAR 0 10
74345: PUSH
74346: LD_VAR 0 10
74350: PUSH
74351: LD_VAR 0 7
74355: PPUSH
74356: LD_INT 3
74358: PPUSH
74359: CALL_OW 259
74363: PUSH
74364: LD_INT 3
74366: MUL
74367: MUL
74368: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74369: LD_VAR 0 6
74373: PPUSH
74374: CALL_OW 264
74378: PUSH
74379: LD_INT 5
74381: PUSH
74382: LD_INT 6
74384: PUSH
74385: LD_INT 46
74387: PUSH
74388: LD_INT 44
74390: PUSH
74391: LD_INT 47
74393: PUSH
74394: LD_INT 45
74396: PUSH
74397: LD_INT 28
74399: PUSH
74400: LD_INT 7
74402: PUSH
74403: LD_INT 27
74405: PUSH
74406: LD_INT 29
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: LIST
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: LIST
74418: LIST
74419: LIST
74420: IN
74421: PUSH
74422: LD_VAR 0 1
74426: PPUSH
74427: LD_INT 52
74429: PPUSH
74430: CALL_OW 321
74434: PUSH
74435: LD_INT 2
74437: EQUAL
74438: AND
74439: IFFALSE 74456
// bpoints := bpoints * 1.2 ;
74441: LD_ADDR_VAR 0 10
74445: PUSH
74446: LD_VAR 0 10
74450: PUSH
74451: LD_REAL  1.20000000000000E+0000
74454: MUL
74455: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74456: LD_VAR 0 6
74460: PPUSH
74461: CALL_OW 264
74465: PUSH
74466: LD_INT 6
74468: PUSH
74469: LD_INT 46
74471: PUSH
74472: LD_INT 47
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: LIST
74479: IN
74480: IFFALSE 74497
// bpoints := bpoints * 1.2 ;
74482: LD_ADDR_VAR 0 10
74486: PUSH
74487: LD_VAR 0 10
74491: PUSH
74492: LD_REAL  1.20000000000000E+0000
74495: MUL
74496: ST_TO_ADDR
// end ; unit_building :
74497: GO 74511
74499: LD_INT 3
74501: DOUBLE
74502: EQUAL
74503: IFTRUE 74507
74505: GO 74510
74507: POP
// ; end ;
74508: GO 74511
74510: POP
// for j = 1 to 3 do
74511: LD_ADDR_VAR 0 7
74515: PUSH
74516: DOUBLE
74517: LD_INT 1
74519: DEC
74520: ST_TO_ADDR
74521: LD_INT 3
74523: PUSH
74524: FOR_TO
74525: IFFALSE 74578
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74527: LD_ADDR_VAR 0 5
74531: PUSH
74532: LD_VAR 0 5
74536: PPUSH
74537: LD_VAR 0 7
74541: PPUSH
74542: LD_VAR 0 5
74546: PUSH
74547: LD_VAR 0 7
74551: ARRAY
74552: PUSH
74553: LD_VAR 0 9
74557: PUSH
74558: LD_VAR 0 7
74562: ARRAY
74563: PUSH
74564: LD_VAR 0 10
74568: MUL
74569: PLUS
74570: PPUSH
74571: CALL_OW 1
74575: ST_TO_ADDR
74576: GO 74524
74578: POP
74579: POP
// end ;
74580: GO 73063
74582: POP
74583: POP
// result := Replace ( result , 4 , tmp ) ;
74584: LD_ADDR_VAR 0 5
74588: PUSH
74589: LD_VAR 0 5
74593: PPUSH
74594: LD_INT 4
74596: PPUSH
74597: LD_VAR 0 8
74601: PPUSH
74602: CALL_OW 1
74606: ST_TO_ADDR
// end ;
74607: LD_VAR 0 5
74611: RET
// export function DangerAtRange ( unit , range ) ; begin
74612: LD_INT 0
74614: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74615: LD_ADDR_VAR 0 3
74619: PUSH
74620: LD_VAR 0 1
74624: PPUSH
74625: CALL_OW 255
74629: PPUSH
74630: LD_VAR 0 1
74634: PPUSH
74635: CALL_OW 250
74639: PPUSH
74640: LD_VAR 0 1
74644: PPUSH
74645: CALL_OW 251
74649: PPUSH
74650: LD_VAR 0 2
74654: PPUSH
74655: CALL 72915 0 4
74659: ST_TO_ADDR
// end ;
74660: LD_VAR 0 3
74664: RET
// export function DangerInArea ( side , area ) ; begin
74665: LD_INT 0
74667: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74668: LD_ADDR_VAR 0 3
74672: PUSH
74673: LD_VAR 0 2
74677: PPUSH
74678: LD_INT 81
74680: PUSH
74681: LD_VAR 0 1
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PPUSH
74690: CALL_OW 70
74694: ST_TO_ADDR
// end ;
74695: LD_VAR 0 3
74699: RET
// export function IsExtension ( b ) ; begin
74700: LD_INT 0
74702: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74703: LD_ADDR_VAR 0 2
74707: PUSH
74708: LD_VAR 0 1
74712: PUSH
74713: LD_INT 23
74715: PUSH
74716: LD_INT 20
74718: PUSH
74719: LD_INT 22
74721: PUSH
74722: LD_INT 17
74724: PUSH
74725: LD_INT 24
74727: PUSH
74728: LD_INT 21
74730: PUSH
74731: LD_INT 19
74733: PUSH
74734: LD_INT 16
74736: PUSH
74737: LD_INT 25
74739: PUSH
74740: LD_INT 18
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: IN
74755: ST_TO_ADDR
// end ;
74756: LD_VAR 0 2
74760: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74761: LD_INT 0
74763: PPUSH
74764: PPUSH
74765: PPUSH
// result := [ ] ;
74766: LD_ADDR_VAR 0 3
74770: PUSH
74771: EMPTY
74772: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74773: LD_ADDR_VAR 0 4
74777: PUSH
74778: LD_VAR 0 2
74782: PPUSH
74783: LD_INT 21
74785: PUSH
74786: LD_INT 3
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PPUSH
74793: CALL_OW 70
74797: ST_TO_ADDR
// if not tmp then
74798: LD_VAR 0 4
74802: NOT
74803: IFFALSE 74807
// exit ;
74805: GO 74865
// for i in tmp do
74807: LD_ADDR_VAR 0 5
74811: PUSH
74812: LD_VAR 0 4
74816: PUSH
74817: FOR_IN
74818: IFFALSE 74853
// if GetBase ( i ) <> base then
74820: LD_VAR 0 5
74824: PPUSH
74825: CALL_OW 274
74829: PUSH
74830: LD_VAR 0 1
74834: NONEQUAL
74835: IFFALSE 74851
// ComLinkToBase ( base , i ) ;
74837: LD_VAR 0 1
74841: PPUSH
74842: LD_VAR 0 5
74846: PPUSH
74847: CALL_OW 169
74851: GO 74817
74853: POP
74854: POP
// result := tmp ;
74855: LD_ADDR_VAR 0 3
74859: PUSH
74860: LD_VAR 0 4
74864: ST_TO_ADDR
// end ;
74865: LD_VAR 0 3
74869: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74870: LD_INT 0
74872: PPUSH
74873: PPUSH
// if BuildingStatus ( b ) = bs_build then
74874: LD_VAR 0 2
74878: PPUSH
74879: CALL_OW 461
74883: PUSH
74884: LD_INT 1
74886: EQUAL
74887: IFFALSE 74947
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74889: LD_VAR 0 1
74893: PPUSH
74894: LD_STRING h
74896: PUSH
74897: LD_VAR 0 2
74901: PPUSH
74902: CALL_OW 250
74906: PUSH
74907: LD_VAR 0 2
74911: PPUSH
74912: CALL_OW 251
74916: PUSH
74917: LD_VAR 0 2
74921: PUSH
74922: LD_INT 0
74924: PUSH
74925: LD_INT 0
74927: PUSH
74928: LD_INT 0
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: PUSH
74940: EMPTY
74941: LIST
74942: PPUSH
74943: CALL_OW 446
// end ;
74947: LD_VAR 0 3
74951: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74952: LD_INT 0
74954: PPUSH
74955: PPUSH
74956: PPUSH
74957: PPUSH
74958: PPUSH
74959: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74960: LD_VAR 0 1
74964: NOT
74965: PUSH
74966: LD_VAR 0 1
74970: PPUSH
74971: CALL_OW 263
74975: PUSH
74976: LD_INT 2
74978: EQUAL
74979: NOT
74980: OR
74981: IFFALSE 74985
// exit ;
74983: GO 75301
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74985: LD_ADDR_VAR 0 6
74989: PUSH
74990: LD_INT 22
74992: PUSH
74993: LD_VAR 0 1
74997: PPUSH
74998: CALL_OW 255
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 2
75009: PUSH
75010: LD_INT 30
75012: PUSH
75013: LD_INT 36
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 34
75022: PUSH
75023: LD_INT 31
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: LIST
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PPUSH
75039: CALL_OW 69
75043: ST_TO_ADDR
// if not tmp then
75044: LD_VAR 0 6
75048: NOT
75049: IFFALSE 75053
// exit ;
75051: GO 75301
// result := [ ] ;
75053: LD_ADDR_VAR 0 2
75057: PUSH
75058: EMPTY
75059: ST_TO_ADDR
// for i in tmp do
75060: LD_ADDR_VAR 0 3
75064: PUSH
75065: LD_VAR 0 6
75069: PUSH
75070: FOR_IN
75071: IFFALSE 75142
// begin t := UnitsInside ( i ) ;
75073: LD_ADDR_VAR 0 4
75077: PUSH
75078: LD_VAR 0 3
75082: PPUSH
75083: CALL_OW 313
75087: ST_TO_ADDR
// if t then
75088: LD_VAR 0 4
75092: IFFALSE 75140
// for j in t do
75094: LD_ADDR_VAR 0 7
75098: PUSH
75099: LD_VAR 0 4
75103: PUSH
75104: FOR_IN
75105: IFFALSE 75138
// result := Insert ( result , result + 1 , j ) ;
75107: LD_ADDR_VAR 0 2
75111: PUSH
75112: LD_VAR 0 2
75116: PPUSH
75117: LD_VAR 0 2
75121: PUSH
75122: LD_INT 1
75124: PLUS
75125: PPUSH
75126: LD_VAR 0 7
75130: PPUSH
75131: CALL_OW 2
75135: ST_TO_ADDR
75136: GO 75104
75138: POP
75139: POP
// end ;
75140: GO 75070
75142: POP
75143: POP
// if not result then
75144: LD_VAR 0 2
75148: NOT
75149: IFFALSE 75153
// exit ;
75151: GO 75301
// mech := result [ 1 ] ;
75153: LD_ADDR_VAR 0 5
75157: PUSH
75158: LD_VAR 0 2
75162: PUSH
75163: LD_INT 1
75165: ARRAY
75166: ST_TO_ADDR
// if result > 1 then
75167: LD_VAR 0 2
75171: PUSH
75172: LD_INT 1
75174: GREATER
75175: IFFALSE 75287
// for i = 2 to result do
75177: LD_ADDR_VAR 0 3
75181: PUSH
75182: DOUBLE
75183: LD_INT 2
75185: DEC
75186: ST_TO_ADDR
75187: LD_VAR 0 2
75191: PUSH
75192: FOR_TO
75193: IFFALSE 75285
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75195: LD_ADDR_VAR 0 4
75199: PUSH
75200: LD_VAR 0 2
75204: PUSH
75205: LD_VAR 0 3
75209: ARRAY
75210: PPUSH
75211: LD_INT 3
75213: PPUSH
75214: CALL_OW 259
75218: PUSH
75219: LD_VAR 0 2
75223: PUSH
75224: LD_VAR 0 3
75228: ARRAY
75229: PPUSH
75230: CALL_OW 432
75234: MINUS
75235: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75236: LD_VAR 0 4
75240: PUSH
75241: LD_VAR 0 5
75245: PPUSH
75246: LD_INT 3
75248: PPUSH
75249: CALL_OW 259
75253: PUSH
75254: LD_VAR 0 5
75258: PPUSH
75259: CALL_OW 432
75263: MINUS
75264: GREATEREQUAL
75265: IFFALSE 75283
// mech := result [ i ] ;
75267: LD_ADDR_VAR 0 5
75271: PUSH
75272: LD_VAR 0 2
75276: PUSH
75277: LD_VAR 0 3
75281: ARRAY
75282: ST_TO_ADDR
// end ;
75283: GO 75192
75285: POP
75286: POP
// ComLinkTo ( vehicle , mech ) ;
75287: LD_VAR 0 1
75291: PPUSH
75292: LD_VAR 0 5
75296: PPUSH
75297: CALL_OW 135
// end ;
75301: LD_VAR 0 2
75305: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75306: LD_INT 0
75308: PPUSH
75309: PPUSH
75310: PPUSH
75311: PPUSH
75312: PPUSH
75313: PPUSH
75314: PPUSH
75315: PPUSH
75316: PPUSH
75317: PPUSH
75318: PPUSH
75319: PPUSH
75320: PPUSH
// result := [ ] ;
75321: LD_ADDR_VAR 0 7
75325: PUSH
75326: EMPTY
75327: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75328: LD_VAR 0 1
75332: PPUSH
75333: CALL_OW 266
75337: PUSH
75338: LD_INT 0
75340: PUSH
75341: LD_INT 1
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: IN
75348: NOT
75349: IFFALSE 75353
// exit ;
75351: GO 76984
// if name then
75353: LD_VAR 0 3
75357: IFFALSE 75373
// SetBName ( base_dep , name ) ;
75359: LD_VAR 0 1
75363: PPUSH
75364: LD_VAR 0 3
75368: PPUSH
75369: CALL_OW 500
// base := GetBase ( base_dep ) ;
75373: LD_ADDR_VAR 0 15
75377: PUSH
75378: LD_VAR 0 1
75382: PPUSH
75383: CALL_OW 274
75387: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75388: LD_ADDR_VAR 0 16
75392: PUSH
75393: LD_VAR 0 1
75397: PPUSH
75398: CALL_OW 255
75402: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75403: LD_ADDR_VAR 0 17
75407: PUSH
75408: LD_VAR 0 1
75412: PPUSH
75413: CALL_OW 248
75417: ST_TO_ADDR
// if sources then
75418: LD_VAR 0 5
75422: IFFALSE 75469
// for i = 1 to 3 do
75424: LD_ADDR_VAR 0 8
75428: PUSH
75429: DOUBLE
75430: LD_INT 1
75432: DEC
75433: ST_TO_ADDR
75434: LD_INT 3
75436: PUSH
75437: FOR_TO
75438: IFFALSE 75467
// AddResourceType ( base , i , sources [ i ] ) ;
75440: LD_VAR 0 15
75444: PPUSH
75445: LD_VAR 0 8
75449: PPUSH
75450: LD_VAR 0 5
75454: PUSH
75455: LD_VAR 0 8
75459: ARRAY
75460: PPUSH
75461: CALL_OW 276
75465: GO 75437
75467: POP
75468: POP
// buildings := GetBaseBuildings ( base , area ) ;
75469: LD_ADDR_VAR 0 18
75473: PUSH
75474: LD_VAR 0 15
75478: PPUSH
75479: LD_VAR 0 2
75483: PPUSH
75484: CALL 74761 0 2
75488: ST_TO_ADDR
// InitHc ;
75489: CALL_OW 19
// InitUc ;
75493: CALL_OW 18
// uc_side := side ;
75497: LD_ADDR_OWVAR 20
75501: PUSH
75502: LD_VAR 0 16
75506: ST_TO_ADDR
// uc_nation := nation ;
75507: LD_ADDR_OWVAR 21
75511: PUSH
75512: LD_VAR 0 17
75516: ST_TO_ADDR
// if buildings then
75517: LD_VAR 0 18
75521: IFFALSE 76843
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75523: LD_ADDR_VAR 0 19
75527: PUSH
75528: LD_VAR 0 18
75532: PPUSH
75533: LD_INT 2
75535: PUSH
75536: LD_INT 30
75538: PUSH
75539: LD_INT 29
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 30
75548: PUSH
75549: LD_INT 30
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: LIST
75560: PPUSH
75561: CALL_OW 72
75565: ST_TO_ADDR
// if tmp then
75566: LD_VAR 0 19
75570: IFFALSE 75618
// for i in tmp do
75572: LD_ADDR_VAR 0 8
75576: PUSH
75577: LD_VAR 0 19
75581: PUSH
75582: FOR_IN
75583: IFFALSE 75616
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75585: LD_VAR 0 8
75589: PPUSH
75590: CALL_OW 250
75594: PPUSH
75595: LD_VAR 0 8
75599: PPUSH
75600: CALL_OW 251
75604: PPUSH
75605: LD_VAR 0 16
75609: PPUSH
75610: CALL_OW 441
75614: GO 75582
75616: POP
75617: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75618: LD_VAR 0 18
75622: PPUSH
75623: LD_INT 2
75625: PUSH
75626: LD_INT 30
75628: PUSH
75629: LD_INT 32
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 30
75638: PUSH
75639: LD_INT 33
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: EMPTY
75647: LIST
75648: LIST
75649: LIST
75650: PPUSH
75651: CALL_OW 72
75655: IFFALSE 75743
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75657: LD_ADDR_VAR 0 8
75661: PUSH
75662: LD_VAR 0 18
75666: PPUSH
75667: LD_INT 2
75669: PUSH
75670: LD_INT 30
75672: PUSH
75673: LD_INT 32
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 30
75682: PUSH
75683: LD_INT 33
75685: PUSH
75686: EMPTY
75687: LIST
75688: LIST
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: LIST
75694: PPUSH
75695: CALL_OW 72
75699: PUSH
75700: FOR_IN
75701: IFFALSE 75741
// begin if not GetBWeapon ( i ) then
75703: LD_VAR 0 8
75707: PPUSH
75708: CALL_OW 269
75712: NOT
75713: IFFALSE 75739
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75715: LD_VAR 0 8
75719: PPUSH
75720: LD_VAR 0 8
75724: PPUSH
75725: LD_VAR 0 2
75729: PPUSH
75730: CALL 76989 0 2
75734: PPUSH
75735: CALL_OW 431
// end ;
75739: GO 75700
75741: POP
75742: POP
// end ; for i = 1 to personel do
75743: LD_ADDR_VAR 0 8
75747: PUSH
75748: DOUBLE
75749: LD_INT 1
75751: DEC
75752: ST_TO_ADDR
75753: LD_VAR 0 6
75757: PUSH
75758: FOR_TO
75759: IFFALSE 76823
// begin if i > 4 then
75761: LD_VAR 0 8
75765: PUSH
75766: LD_INT 4
75768: GREATER
75769: IFFALSE 75773
// break ;
75771: GO 76823
// case i of 1 :
75773: LD_VAR 0 8
75777: PUSH
75778: LD_INT 1
75780: DOUBLE
75781: EQUAL
75782: IFTRUE 75786
75784: GO 75866
75786: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75787: LD_ADDR_VAR 0 12
75791: PUSH
75792: LD_VAR 0 18
75796: PPUSH
75797: LD_INT 22
75799: PUSH
75800: LD_VAR 0 16
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 58
75811: PUSH
75812: EMPTY
75813: LIST
75814: PUSH
75815: LD_INT 2
75817: PUSH
75818: LD_INT 30
75820: PUSH
75821: LD_INT 32
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 30
75830: PUSH
75831: LD_INT 4
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 30
75840: PUSH
75841: LD_INT 5
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: LIST
75852: LIST
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: LIST
75858: PPUSH
75859: CALL_OW 72
75863: ST_TO_ADDR
75864: GO 76088
75866: LD_INT 2
75868: DOUBLE
75869: EQUAL
75870: IFTRUE 75874
75872: GO 75936
75874: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75875: LD_ADDR_VAR 0 12
75879: PUSH
75880: LD_VAR 0 18
75884: PPUSH
75885: LD_INT 22
75887: PUSH
75888: LD_VAR 0 16
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 2
75899: PUSH
75900: LD_INT 30
75902: PUSH
75903: LD_INT 0
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 30
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: EMPTY
75917: LIST
75918: LIST
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: LIST
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PPUSH
75929: CALL_OW 72
75933: ST_TO_ADDR
75934: GO 76088
75936: LD_INT 3
75938: DOUBLE
75939: EQUAL
75940: IFTRUE 75944
75942: GO 76006
75944: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75945: LD_ADDR_VAR 0 12
75949: PUSH
75950: LD_VAR 0 18
75954: PPUSH
75955: LD_INT 22
75957: PUSH
75958: LD_VAR 0 16
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 2
75969: PUSH
75970: LD_INT 30
75972: PUSH
75973: LD_INT 2
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 30
75982: PUSH
75983: LD_INT 3
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: LIST
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: PPUSH
75999: CALL_OW 72
76003: ST_TO_ADDR
76004: GO 76088
76006: LD_INT 4
76008: DOUBLE
76009: EQUAL
76010: IFTRUE 76014
76012: GO 76087
76014: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76015: LD_ADDR_VAR 0 12
76019: PUSH
76020: LD_VAR 0 18
76024: PPUSH
76025: LD_INT 22
76027: PUSH
76028: LD_VAR 0 16
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 2
76039: PUSH
76040: LD_INT 30
76042: PUSH
76043: LD_INT 6
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PUSH
76050: LD_INT 30
76052: PUSH
76053: LD_INT 7
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PUSH
76060: LD_INT 30
76062: PUSH
76063: LD_INT 8
76065: PUSH
76066: EMPTY
76067: LIST
76068: LIST
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PPUSH
76080: CALL_OW 72
76084: ST_TO_ADDR
76085: GO 76088
76087: POP
// if i = 1 then
76088: LD_VAR 0 8
76092: PUSH
76093: LD_INT 1
76095: EQUAL
76096: IFFALSE 76207
// begin tmp := [ ] ;
76098: LD_ADDR_VAR 0 19
76102: PUSH
76103: EMPTY
76104: ST_TO_ADDR
// for j in f do
76105: LD_ADDR_VAR 0 9
76109: PUSH
76110: LD_VAR 0 12
76114: PUSH
76115: FOR_IN
76116: IFFALSE 76189
// if GetBType ( j ) = b_bunker then
76118: LD_VAR 0 9
76122: PPUSH
76123: CALL_OW 266
76127: PUSH
76128: LD_INT 32
76130: EQUAL
76131: IFFALSE 76158
// tmp := Insert ( tmp , 1 , j ) else
76133: LD_ADDR_VAR 0 19
76137: PUSH
76138: LD_VAR 0 19
76142: PPUSH
76143: LD_INT 1
76145: PPUSH
76146: LD_VAR 0 9
76150: PPUSH
76151: CALL_OW 2
76155: ST_TO_ADDR
76156: GO 76187
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76158: LD_ADDR_VAR 0 19
76162: PUSH
76163: LD_VAR 0 19
76167: PPUSH
76168: LD_VAR 0 19
76172: PUSH
76173: LD_INT 1
76175: PLUS
76176: PPUSH
76177: LD_VAR 0 9
76181: PPUSH
76182: CALL_OW 2
76186: ST_TO_ADDR
76187: GO 76115
76189: POP
76190: POP
// if tmp then
76191: LD_VAR 0 19
76195: IFFALSE 76207
// f := tmp ;
76197: LD_ADDR_VAR 0 12
76201: PUSH
76202: LD_VAR 0 19
76206: ST_TO_ADDR
// end ; x := personel [ i ] ;
76207: LD_ADDR_VAR 0 13
76211: PUSH
76212: LD_VAR 0 6
76216: PUSH
76217: LD_VAR 0 8
76221: ARRAY
76222: ST_TO_ADDR
// if x = - 1 then
76223: LD_VAR 0 13
76227: PUSH
76228: LD_INT 1
76230: NEG
76231: EQUAL
76232: IFFALSE 76441
// begin for j in f do
76234: LD_ADDR_VAR 0 9
76238: PUSH
76239: LD_VAR 0 12
76243: PUSH
76244: FOR_IN
76245: IFFALSE 76437
// repeat InitHc ;
76247: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76251: LD_VAR 0 9
76255: PPUSH
76256: CALL_OW 266
76260: PUSH
76261: LD_INT 5
76263: EQUAL
76264: IFFALSE 76334
// begin if UnitsInside ( j ) < 3 then
76266: LD_VAR 0 9
76270: PPUSH
76271: CALL_OW 313
76275: PUSH
76276: LD_INT 3
76278: LESS
76279: IFFALSE 76315
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76281: LD_INT 0
76283: PPUSH
76284: LD_INT 5
76286: PUSH
76287: LD_INT 8
76289: PUSH
76290: LD_INT 9
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: LIST
76297: PUSH
76298: LD_VAR 0 17
76302: ARRAY
76303: PPUSH
76304: LD_VAR 0 4
76308: PPUSH
76309: CALL_OW 380
76313: GO 76332
// PrepareHuman ( false , i , skill ) ;
76315: LD_INT 0
76317: PPUSH
76318: LD_VAR 0 8
76322: PPUSH
76323: LD_VAR 0 4
76327: PPUSH
76328: CALL_OW 380
// end else
76332: GO 76351
// PrepareHuman ( false , i , skill ) ;
76334: LD_INT 0
76336: PPUSH
76337: LD_VAR 0 8
76341: PPUSH
76342: LD_VAR 0 4
76346: PPUSH
76347: CALL_OW 380
// un := CreateHuman ;
76351: LD_ADDR_VAR 0 14
76355: PUSH
76356: CALL_OW 44
76360: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76361: LD_ADDR_VAR 0 7
76365: PUSH
76366: LD_VAR 0 7
76370: PPUSH
76371: LD_INT 1
76373: PPUSH
76374: LD_VAR 0 14
76378: PPUSH
76379: CALL_OW 2
76383: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76384: LD_VAR 0 14
76388: PPUSH
76389: LD_VAR 0 9
76393: PPUSH
76394: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76398: LD_VAR 0 9
76402: PPUSH
76403: CALL_OW 313
76407: PUSH
76408: LD_INT 6
76410: EQUAL
76411: PUSH
76412: LD_VAR 0 9
76416: PPUSH
76417: CALL_OW 266
76421: PUSH
76422: LD_INT 32
76424: PUSH
76425: LD_INT 31
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: IN
76432: OR
76433: IFFALSE 76247
76435: GO 76244
76437: POP
76438: POP
// end else
76439: GO 76821
// for j = 1 to x do
76441: LD_ADDR_VAR 0 9
76445: PUSH
76446: DOUBLE
76447: LD_INT 1
76449: DEC
76450: ST_TO_ADDR
76451: LD_VAR 0 13
76455: PUSH
76456: FOR_TO
76457: IFFALSE 76819
// begin InitHc ;
76459: CALL_OW 19
// if not f then
76463: LD_VAR 0 12
76467: NOT
76468: IFFALSE 76557
// begin PrepareHuman ( false , i , skill ) ;
76470: LD_INT 0
76472: PPUSH
76473: LD_VAR 0 8
76477: PPUSH
76478: LD_VAR 0 4
76482: PPUSH
76483: CALL_OW 380
// un := CreateHuman ;
76487: LD_ADDR_VAR 0 14
76491: PUSH
76492: CALL_OW 44
76496: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76497: LD_ADDR_VAR 0 7
76501: PUSH
76502: LD_VAR 0 7
76506: PPUSH
76507: LD_INT 1
76509: PPUSH
76510: LD_VAR 0 14
76514: PPUSH
76515: CALL_OW 2
76519: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76520: LD_VAR 0 14
76524: PPUSH
76525: LD_VAR 0 1
76529: PPUSH
76530: CALL_OW 250
76534: PPUSH
76535: LD_VAR 0 1
76539: PPUSH
76540: CALL_OW 251
76544: PPUSH
76545: LD_INT 10
76547: PPUSH
76548: LD_INT 0
76550: PPUSH
76551: CALL_OW 50
// continue ;
76555: GO 76456
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76557: LD_VAR 0 12
76561: PUSH
76562: LD_INT 1
76564: ARRAY
76565: PPUSH
76566: CALL_OW 313
76570: PUSH
76571: LD_VAR 0 12
76575: PUSH
76576: LD_INT 1
76578: ARRAY
76579: PPUSH
76580: CALL_OW 266
76584: PUSH
76585: LD_INT 32
76587: PUSH
76588: LD_INT 31
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: IN
76595: AND
76596: PUSH
76597: LD_VAR 0 12
76601: PUSH
76602: LD_INT 1
76604: ARRAY
76605: PPUSH
76606: CALL_OW 313
76610: PUSH
76611: LD_INT 6
76613: EQUAL
76614: OR
76615: IFFALSE 76635
// f := Delete ( f , 1 ) ;
76617: LD_ADDR_VAR 0 12
76621: PUSH
76622: LD_VAR 0 12
76626: PPUSH
76627: LD_INT 1
76629: PPUSH
76630: CALL_OW 3
76634: ST_TO_ADDR
// if not f then
76635: LD_VAR 0 12
76639: NOT
76640: IFFALSE 76658
// begin x := x + 2 ;
76642: LD_ADDR_VAR 0 13
76646: PUSH
76647: LD_VAR 0 13
76651: PUSH
76652: LD_INT 2
76654: PLUS
76655: ST_TO_ADDR
// continue ;
76656: GO 76456
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76658: LD_VAR 0 12
76662: PUSH
76663: LD_INT 1
76665: ARRAY
76666: PPUSH
76667: CALL_OW 266
76671: PUSH
76672: LD_INT 5
76674: EQUAL
76675: IFFALSE 76749
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76677: LD_VAR 0 12
76681: PUSH
76682: LD_INT 1
76684: ARRAY
76685: PPUSH
76686: CALL_OW 313
76690: PUSH
76691: LD_INT 3
76693: LESS
76694: IFFALSE 76730
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76696: LD_INT 0
76698: PPUSH
76699: LD_INT 5
76701: PUSH
76702: LD_INT 8
76704: PUSH
76705: LD_INT 9
76707: PUSH
76708: EMPTY
76709: LIST
76710: LIST
76711: LIST
76712: PUSH
76713: LD_VAR 0 17
76717: ARRAY
76718: PPUSH
76719: LD_VAR 0 4
76723: PPUSH
76724: CALL_OW 380
76728: GO 76747
// PrepareHuman ( false , i , skill ) ;
76730: LD_INT 0
76732: PPUSH
76733: LD_VAR 0 8
76737: PPUSH
76738: LD_VAR 0 4
76742: PPUSH
76743: CALL_OW 380
// end else
76747: GO 76766
// PrepareHuman ( false , i , skill ) ;
76749: LD_INT 0
76751: PPUSH
76752: LD_VAR 0 8
76756: PPUSH
76757: LD_VAR 0 4
76761: PPUSH
76762: CALL_OW 380
// un := CreateHuman ;
76766: LD_ADDR_VAR 0 14
76770: PUSH
76771: CALL_OW 44
76775: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76776: LD_ADDR_VAR 0 7
76780: PUSH
76781: LD_VAR 0 7
76785: PPUSH
76786: LD_INT 1
76788: PPUSH
76789: LD_VAR 0 14
76793: PPUSH
76794: CALL_OW 2
76798: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76799: LD_VAR 0 14
76803: PPUSH
76804: LD_VAR 0 12
76808: PUSH
76809: LD_INT 1
76811: ARRAY
76812: PPUSH
76813: CALL_OW 52
// end ;
76817: GO 76456
76819: POP
76820: POP
// end ;
76821: GO 75758
76823: POP
76824: POP
// result := result ^ buildings ;
76825: LD_ADDR_VAR 0 7
76829: PUSH
76830: LD_VAR 0 7
76834: PUSH
76835: LD_VAR 0 18
76839: ADD
76840: ST_TO_ADDR
// end else
76841: GO 76984
// begin for i = 1 to personel do
76843: LD_ADDR_VAR 0 8
76847: PUSH
76848: DOUBLE
76849: LD_INT 1
76851: DEC
76852: ST_TO_ADDR
76853: LD_VAR 0 6
76857: PUSH
76858: FOR_TO
76859: IFFALSE 76982
// begin if i > 4 then
76861: LD_VAR 0 8
76865: PUSH
76866: LD_INT 4
76868: GREATER
76869: IFFALSE 76873
// break ;
76871: GO 76982
// x := personel [ i ] ;
76873: LD_ADDR_VAR 0 13
76877: PUSH
76878: LD_VAR 0 6
76882: PUSH
76883: LD_VAR 0 8
76887: ARRAY
76888: ST_TO_ADDR
// if x = - 1 then
76889: LD_VAR 0 13
76893: PUSH
76894: LD_INT 1
76896: NEG
76897: EQUAL
76898: IFFALSE 76902
// continue ;
76900: GO 76858
// PrepareHuman ( false , i , skill ) ;
76902: LD_INT 0
76904: PPUSH
76905: LD_VAR 0 8
76909: PPUSH
76910: LD_VAR 0 4
76914: PPUSH
76915: CALL_OW 380
// un := CreateHuman ;
76919: LD_ADDR_VAR 0 14
76923: PUSH
76924: CALL_OW 44
76928: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76929: LD_VAR 0 14
76933: PPUSH
76934: LD_VAR 0 1
76938: PPUSH
76939: CALL_OW 250
76943: PPUSH
76944: LD_VAR 0 1
76948: PPUSH
76949: CALL_OW 251
76953: PPUSH
76954: LD_INT 10
76956: PPUSH
76957: LD_INT 0
76959: PPUSH
76960: CALL_OW 50
// result := result ^ un ;
76964: LD_ADDR_VAR 0 7
76968: PUSH
76969: LD_VAR 0 7
76973: PUSH
76974: LD_VAR 0 14
76978: ADD
76979: ST_TO_ADDR
// end ;
76980: GO 76858
76982: POP
76983: POP
// end ; end ;
76984: LD_VAR 0 7
76988: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76989: LD_INT 0
76991: PPUSH
76992: PPUSH
76993: PPUSH
76994: PPUSH
76995: PPUSH
76996: PPUSH
76997: PPUSH
76998: PPUSH
76999: PPUSH
77000: PPUSH
77001: PPUSH
77002: PPUSH
77003: PPUSH
77004: PPUSH
77005: PPUSH
77006: PPUSH
// result := false ;
77007: LD_ADDR_VAR 0 3
77011: PUSH
77012: LD_INT 0
77014: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77015: LD_VAR 0 1
77019: NOT
77020: PUSH
77021: LD_VAR 0 1
77025: PPUSH
77026: CALL_OW 266
77030: PUSH
77031: LD_INT 32
77033: PUSH
77034: LD_INT 33
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: IN
77041: NOT
77042: OR
77043: IFFALSE 77047
// exit ;
77045: GO 78183
// nat := GetNation ( tower ) ;
77047: LD_ADDR_VAR 0 12
77051: PUSH
77052: LD_VAR 0 1
77056: PPUSH
77057: CALL_OW 248
77061: ST_TO_ADDR
// side := GetSide ( tower ) ;
77062: LD_ADDR_VAR 0 16
77066: PUSH
77067: LD_VAR 0 1
77071: PPUSH
77072: CALL_OW 255
77076: ST_TO_ADDR
// x := GetX ( tower ) ;
77077: LD_ADDR_VAR 0 10
77081: PUSH
77082: LD_VAR 0 1
77086: PPUSH
77087: CALL_OW 250
77091: ST_TO_ADDR
// y := GetY ( tower ) ;
77092: LD_ADDR_VAR 0 11
77096: PUSH
77097: LD_VAR 0 1
77101: PPUSH
77102: CALL_OW 251
77106: ST_TO_ADDR
// if not x or not y then
77107: LD_VAR 0 10
77111: NOT
77112: PUSH
77113: LD_VAR 0 11
77117: NOT
77118: OR
77119: IFFALSE 77123
// exit ;
77121: GO 78183
// weapon := 0 ;
77123: LD_ADDR_VAR 0 18
77127: PUSH
77128: LD_INT 0
77130: ST_TO_ADDR
// fac_list := [ ] ;
77131: LD_ADDR_VAR 0 17
77135: PUSH
77136: EMPTY
77137: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77138: LD_ADDR_VAR 0 6
77142: PUSH
77143: LD_VAR 0 1
77147: PPUSH
77148: CALL_OW 274
77152: PPUSH
77153: LD_VAR 0 2
77157: PPUSH
77158: CALL 74761 0 2
77162: PPUSH
77163: LD_INT 30
77165: PUSH
77166: LD_INT 3
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PPUSH
77173: CALL_OW 72
77177: ST_TO_ADDR
// if not factories then
77178: LD_VAR 0 6
77182: NOT
77183: IFFALSE 77187
// exit ;
77185: GO 78183
// for i in factories do
77187: LD_ADDR_VAR 0 8
77191: PUSH
77192: LD_VAR 0 6
77196: PUSH
77197: FOR_IN
77198: IFFALSE 77223
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77200: LD_ADDR_VAR 0 17
77204: PUSH
77205: LD_VAR 0 17
77209: PUSH
77210: LD_VAR 0 8
77214: PPUSH
77215: CALL_OW 478
77219: UNION
77220: ST_TO_ADDR
77221: GO 77197
77223: POP
77224: POP
// if not fac_list then
77225: LD_VAR 0 17
77229: NOT
77230: IFFALSE 77234
// exit ;
77232: GO 78183
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77234: LD_ADDR_VAR 0 5
77238: PUSH
77239: LD_INT 4
77241: PUSH
77242: LD_INT 5
77244: PUSH
77245: LD_INT 9
77247: PUSH
77248: LD_INT 10
77250: PUSH
77251: LD_INT 6
77253: PUSH
77254: LD_INT 7
77256: PUSH
77257: LD_INT 11
77259: PUSH
77260: EMPTY
77261: LIST
77262: LIST
77263: LIST
77264: LIST
77265: LIST
77266: LIST
77267: LIST
77268: PUSH
77269: LD_INT 27
77271: PUSH
77272: LD_INT 28
77274: PUSH
77275: LD_INT 26
77277: PUSH
77278: LD_INT 30
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: PUSH
77287: LD_INT 43
77289: PUSH
77290: LD_INT 44
77292: PUSH
77293: LD_INT 46
77295: PUSH
77296: LD_INT 45
77298: PUSH
77299: LD_INT 47
77301: PUSH
77302: LD_INT 49
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: LIST
77317: PUSH
77318: LD_VAR 0 12
77322: ARRAY
77323: ST_TO_ADDR
// for i in list do
77324: LD_ADDR_VAR 0 8
77328: PUSH
77329: LD_VAR 0 5
77333: PUSH
77334: FOR_IN
77335: IFFALSE 77368
// if not i in fac_list then
77337: LD_VAR 0 8
77341: PUSH
77342: LD_VAR 0 17
77346: IN
77347: NOT
77348: IFFALSE 77366
// list := list diff i ;
77350: LD_ADDR_VAR 0 5
77354: PUSH
77355: LD_VAR 0 5
77359: PUSH
77360: LD_VAR 0 8
77364: DIFF
77365: ST_TO_ADDR
77366: GO 77334
77368: POP
77369: POP
// if not list then
77370: LD_VAR 0 5
77374: NOT
77375: IFFALSE 77379
// exit ;
77377: GO 78183
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77379: LD_VAR 0 12
77383: PUSH
77384: LD_INT 3
77386: EQUAL
77387: PUSH
77388: LD_INT 49
77390: PUSH
77391: LD_VAR 0 5
77395: IN
77396: AND
77397: PUSH
77398: LD_INT 31
77400: PPUSH
77401: LD_VAR 0 16
77405: PPUSH
77406: CALL_OW 321
77410: PUSH
77411: LD_INT 2
77413: EQUAL
77414: AND
77415: IFFALSE 77475
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77417: LD_INT 22
77419: PUSH
77420: LD_VAR 0 16
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 35
77431: PUSH
77432: LD_INT 49
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 91
77441: PUSH
77442: LD_VAR 0 1
77446: PUSH
77447: LD_INT 10
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: LIST
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: LIST
77459: PPUSH
77460: CALL_OW 69
77464: NOT
77465: IFFALSE 77475
// weapon := ru_time_lapser ;
77467: LD_ADDR_VAR 0 18
77471: PUSH
77472: LD_INT 49
77474: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77475: LD_VAR 0 12
77479: PUSH
77480: LD_INT 1
77482: PUSH
77483: LD_INT 2
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: IN
77490: PUSH
77491: LD_INT 11
77493: PUSH
77494: LD_VAR 0 5
77498: IN
77499: PUSH
77500: LD_INT 30
77502: PUSH
77503: LD_VAR 0 5
77507: IN
77508: OR
77509: AND
77510: PUSH
77511: LD_INT 6
77513: PPUSH
77514: LD_VAR 0 16
77518: PPUSH
77519: CALL_OW 321
77523: PUSH
77524: LD_INT 2
77526: EQUAL
77527: AND
77528: IFFALSE 77693
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77530: LD_INT 22
77532: PUSH
77533: LD_VAR 0 16
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 2
77544: PUSH
77545: LD_INT 35
77547: PUSH
77548: LD_INT 11
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 35
77557: PUSH
77558: LD_INT 30
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 91
77572: PUSH
77573: LD_VAR 0 1
77577: PUSH
77578: LD_INT 18
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: LIST
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: LIST
77590: PPUSH
77591: CALL_OW 69
77595: NOT
77596: PUSH
77597: LD_INT 22
77599: PUSH
77600: LD_VAR 0 16
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: LD_INT 2
77611: PUSH
77612: LD_INT 30
77614: PUSH
77615: LD_INT 32
77617: PUSH
77618: EMPTY
77619: LIST
77620: LIST
77621: PUSH
77622: LD_INT 30
77624: PUSH
77625: LD_INT 33
77627: PUSH
77628: EMPTY
77629: LIST
77630: LIST
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 91
77639: PUSH
77640: LD_VAR 0 1
77644: PUSH
77645: LD_INT 12
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: LIST
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: LIST
77657: PUSH
77658: EMPTY
77659: LIST
77660: PPUSH
77661: CALL_OW 69
77665: PUSH
77666: LD_INT 2
77668: GREATER
77669: AND
77670: IFFALSE 77693
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77672: LD_ADDR_VAR 0 18
77676: PUSH
77677: LD_INT 11
77679: PUSH
77680: LD_INT 30
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_VAR 0 12
77691: ARRAY
77692: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77693: LD_VAR 0 18
77697: NOT
77698: PUSH
77699: LD_INT 40
77701: PPUSH
77702: LD_VAR 0 16
77706: PPUSH
77707: CALL_OW 321
77711: PUSH
77712: LD_INT 2
77714: EQUAL
77715: AND
77716: PUSH
77717: LD_INT 7
77719: PUSH
77720: LD_VAR 0 5
77724: IN
77725: PUSH
77726: LD_INT 28
77728: PUSH
77729: LD_VAR 0 5
77733: IN
77734: OR
77735: PUSH
77736: LD_INT 45
77738: PUSH
77739: LD_VAR 0 5
77743: IN
77744: OR
77745: AND
77746: IFFALSE 78000
// begin hex := GetHexInfo ( x , y ) ;
77748: LD_ADDR_VAR 0 4
77752: PUSH
77753: LD_VAR 0 10
77757: PPUSH
77758: LD_VAR 0 11
77762: PPUSH
77763: CALL_OW 546
77767: ST_TO_ADDR
// if hex [ 1 ] then
77768: LD_VAR 0 4
77772: PUSH
77773: LD_INT 1
77775: ARRAY
77776: IFFALSE 77780
// exit ;
77778: GO 78183
// height := hex [ 2 ] ;
77780: LD_ADDR_VAR 0 15
77784: PUSH
77785: LD_VAR 0 4
77789: PUSH
77790: LD_INT 2
77792: ARRAY
77793: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77794: LD_ADDR_VAR 0 14
77798: PUSH
77799: LD_INT 0
77801: PUSH
77802: LD_INT 2
77804: PUSH
77805: LD_INT 3
77807: PUSH
77808: LD_INT 5
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: ST_TO_ADDR
// for i in tmp do
77817: LD_ADDR_VAR 0 8
77821: PUSH
77822: LD_VAR 0 14
77826: PUSH
77827: FOR_IN
77828: IFFALSE 77998
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77830: LD_ADDR_VAR 0 9
77834: PUSH
77835: LD_VAR 0 10
77839: PPUSH
77840: LD_VAR 0 8
77844: PPUSH
77845: LD_INT 5
77847: PPUSH
77848: CALL_OW 272
77852: PUSH
77853: LD_VAR 0 11
77857: PPUSH
77858: LD_VAR 0 8
77862: PPUSH
77863: LD_INT 5
77865: PPUSH
77866: CALL_OW 273
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77875: LD_VAR 0 9
77879: PUSH
77880: LD_INT 1
77882: ARRAY
77883: PPUSH
77884: LD_VAR 0 9
77888: PUSH
77889: LD_INT 2
77891: ARRAY
77892: PPUSH
77893: CALL_OW 488
77897: IFFALSE 77996
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77899: LD_ADDR_VAR 0 4
77903: PUSH
77904: LD_VAR 0 9
77908: PUSH
77909: LD_INT 1
77911: ARRAY
77912: PPUSH
77913: LD_VAR 0 9
77917: PUSH
77918: LD_INT 2
77920: ARRAY
77921: PPUSH
77922: CALL_OW 546
77926: ST_TO_ADDR
// if hex [ 1 ] then
77927: LD_VAR 0 4
77931: PUSH
77932: LD_INT 1
77934: ARRAY
77935: IFFALSE 77939
// continue ;
77937: GO 77827
// h := hex [ 2 ] ;
77939: LD_ADDR_VAR 0 13
77943: PUSH
77944: LD_VAR 0 4
77948: PUSH
77949: LD_INT 2
77951: ARRAY
77952: ST_TO_ADDR
// if h + 7 < height then
77953: LD_VAR 0 13
77957: PUSH
77958: LD_INT 7
77960: PLUS
77961: PUSH
77962: LD_VAR 0 15
77966: LESS
77967: IFFALSE 77996
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77969: LD_ADDR_VAR 0 18
77973: PUSH
77974: LD_INT 7
77976: PUSH
77977: LD_INT 28
77979: PUSH
77980: LD_INT 45
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: LIST
77987: PUSH
77988: LD_VAR 0 12
77992: ARRAY
77993: ST_TO_ADDR
// break ;
77994: GO 77998
// end ; end ; end ;
77996: GO 77827
77998: POP
77999: POP
// end ; if not weapon then
78000: LD_VAR 0 18
78004: NOT
78005: IFFALSE 78065
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78007: LD_ADDR_VAR 0 5
78011: PUSH
78012: LD_VAR 0 5
78016: PUSH
78017: LD_INT 11
78019: PUSH
78020: LD_INT 30
78022: PUSH
78023: LD_INT 49
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: DIFF
78031: ST_TO_ADDR
// if not list then
78032: LD_VAR 0 5
78036: NOT
78037: IFFALSE 78041
// exit ;
78039: GO 78183
// weapon := list [ rand ( 1 , list ) ] ;
78041: LD_ADDR_VAR 0 18
78045: PUSH
78046: LD_VAR 0 5
78050: PUSH
78051: LD_INT 1
78053: PPUSH
78054: LD_VAR 0 5
78058: PPUSH
78059: CALL_OW 12
78063: ARRAY
78064: ST_TO_ADDR
// end ; if weapon then
78065: LD_VAR 0 18
78069: IFFALSE 78183
// begin tmp := CostOfWeapon ( weapon ) ;
78071: LD_ADDR_VAR 0 14
78075: PUSH
78076: LD_VAR 0 18
78080: PPUSH
78081: CALL_OW 451
78085: ST_TO_ADDR
// j := GetBase ( tower ) ;
78086: LD_ADDR_VAR 0 9
78090: PUSH
78091: LD_VAR 0 1
78095: PPUSH
78096: CALL_OW 274
78100: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78101: LD_VAR 0 9
78105: PPUSH
78106: LD_INT 1
78108: PPUSH
78109: CALL_OW 275
78113: PUSH
78114: LD_VAR 0 14
78118: PUSH
78119: LD_INT 1
78121: ARRAY
78122: GREATEREQUAL
78123: PUSH
78124: LD_VAR 0 9
78128: PPUSH
78129: LD_INT 2
78131: PPUSH
78132: CALL_OW 275
78136: PUSH
78137: LD_VAR 0 14
78141: PUSH
78142: LD_INT 2
78144: ARRAY
78145: GREATEREQUAL
78146: AND
78147: PUSH
78148: LD_VAR 0 9
78152: PPUSH
78153: LD_INT 3
78155: PPUSH
78156: CALL_OW 275
78160: PUSH
78161: LD_VAR 0 14
78165: PUSH
78166: LD_INT 3
78168: ARRAY
78169: GREATEREQUAL
78170: AND
78171: IFFALSE 78183
// result := weapon ;
78173: LD_ADDR_VAR 0 3
78177: PUSH
78178: LD_VAR 0 18
78182: ST_TO_ADDR
// end ; end ;
78183: LD_VAR 0 3
78187: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78188: LD_INT 0
78190: PPUSH
78191: PPUSH
// result := true ;
78192: LD_ADDR_VAR 0 3
78196: PUSH
78197: LD_INT 1
78199: ST_TO_ADDR
// if array1 = array2 then
78200: LD_VAR 0 1
78204: PUSH
78205: LD_VAR 0 2
78209: EQUAL
78210: IFFALSE 78270
// begin for i = 1 to array1 do
78212: LD_ADDR_VAR 0 4
78216: PUSH
78217: DOUBLE
78218: LD_INT 1
78220: DEC
78221: ST_TO_ADDR
78222: LD_VAR 0 1
78226: PUSH
78227: FOR_TO
78228: IFFALSE 78266
// if array1 [ i ] <> array2 [ i ] then
78230: LD_VAR 0 1
78234: PUSH
78235: LD_VAR 0 4
78239: ARRAY
78240: PUSH
78241: LD_VAR 0 2
78245: PUSH
78246: LD_VAR 0 4
78250: ARRAY
78251: NONEQUAL
78252: IFFALSE 78264
// begin result := false ;
78254: LD_ADDR_VAR 0 3
78258: PUSH
78259: LD_INT 0
78261: ST_TO_ADDR
// break ;
78262: GO 78266
// end ;
78264: GO 78227
78266: POP
78267: POP
// end else
78268: GO 78278
// result := false ;
78270: LD_ADDR_VAR 0 3
78274: PUSH
78275: LD_INT 0
78277: ST_TO_ADDR
// end ;
78278: LD_VAR 0 3
78282: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78283: LD_INT 0
78285: PPUSH
78286: PPUSH
78287: PPUSH
// pom := GetBase ( fac ) ;
78288: LD_ADDR_VAR 0 5
78292: PUSH
78293: LD_VAR 0 1
78297: PPUSH
78298: CALL_OW 274
78302: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78303: LD_ADDR_VAR 0 4
78307: PUSH
78308: LD_VAR 0 2
78312: PUSH
78313: LD_INT 1
78315: ARRAY
78316: PPUSH
78317: LD_VAR 0 2
78321: PUSH
78322: LD_INT 2
78324: ARRAY
78325: PPUSH
78326: LD_VAR 0 2
78330: PUSH
78331: LD_INT 3
78333: ARRAY
78334: PPUSH
78335: LD_VAR 0 2
78339: PUSH
78340: LD_INT 4
78342: ARRAY
78343: PPUSH
78344: CALL_OW 449
78348: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78349: LD_ADDR_VAR 0 3
78353: PUSH
78354: LD_VAR 0 5
78358: PPUSH
78359: LD_INT 1
78361: PPUSH
78362: CALL_OW 275
78366: PUSH
78367: LD_VAR 0 4
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: GREATEREQUAL
78376: PUSH
78377: LD_VAR 0 5
78381: PPUSH
78382: LD_INT 2
78384: PPUSH
78385: CALL_OW 275
78389: PUSH
78390: LD_VAR 0 4
78394: PUSH
78395: LD_INT 2
78397: ARRAY
78398: GREATEREQUAL
78399: AND
78400: PUSH
78401: LD_VAR 0 5
78405: PPUSH
78406: LD_INT 3
78408: PPUSH
78409: CALL_OW 275
78413: PUSH
78414: LD_VAR 0 4
78418: PUSH
78419: LD_INT 3
78421: ARRAY
78422: GREATEREQUAL
78423: AND
78424: ST_TO_ADDR
// end ;
78425: LD_VAR 0 3
78429: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78430: LD_INT 0
78432: PPUSH
78433: PPUSH
78434: PPUSH
78435: PPUSH
// pom := GetBase ( building ) ;
78436: LD_ADDR_VAR 0 3
78440: PUSH
78441: LD_VAR 0 1
78445: PPUSH
78446: CALL_OW 274
78450: ST_TO_ADDR
// if not pom then
78451: LD_VAR 0 3
78455: NOT
78456: IFFALSE 78460
// exit ;
78458: GO 78630
// btype := GetBType ( building ) ;
78460: LD_ADDR_VAR 0 5
78464: PUSH
78465: LD_VAR 0 1
78469: PPUSH
78470: CALL_OW 266
78474: ST_TO_ADDR
// if btype = b_armoury then
78475: LD_VAR 0 5
78479: PUSH
78480: LD_INT 4
78482: EQUAL
78483: IFFALSE 78493
// btype := b_barracks ;
78485: LD_ADDR_VAR 0 5
78489: PUSH
78490: LD_INT 5
78492: ST_TO_ADDR
// if btype = b_depot then
78493: LD_VAR 0 5
78497: PUSH
78498: LD_INT 0
78500: EQUAL
78501: IFFALSE 78511
// btype := b_warehouse ;
78503: LD_ADDR_VAR 0 5
78507: PUSH
78508: LD_INT 1
78510: ST_TO_ADDR
// if btype = b_workshop then
78511: LD_VAR 0 5
78515: PUSH
78516: LD_INT 2
78518: EQUAL
78519: IFFALSE 78529
// btype := b_factory ;
78521: LD_ADDR_VAR 0 5
78525: PUSH
78526: LD_INT 3
78528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78529: LD_ADDR_VAR 0 4
78533: PUSH
78534: LD_VAR 0 5
78538: PPUSH
78539: LD_VAR 0 1
78543: PPUSH
78544: CALL_OW 248
78548: PPUSH
78549: CALL_OW 450
78553: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78554: LD_ADDR_VAR 0 2
78558: PUSH
78559: LD_VAR 0 3
78563: PPUSH
78564: LD_INT 1
78566: PPUSH
78567: CALL_OW 275
78571: PUSH
78572: LD_VAR 0 4
78576: PUSH
78577: LD_INT 1
78579: ARRAY
78580: GREATEREQUAL
78581: PUSH
78582: LD_VAR 0 3
78586: PPUSH
78587: LD_INT 2
78589: PPUSH
78590: CALL_OW 275
78594: PUSH
78595: LD_VAR 0 4
78599: PUSH
78600: LD_INT 2
78602: ARRAY
78603: GREATEREQUAL
78604: AND
78605: PUSH
78606: LD_VAR 0 3
78610: PPUSH
78611: LD_INT 3
78613: PPUSH
78614: CALL_OW 275
78618: PUSH
78619: LD_VAR 0 4
78623: PUSH
78624: LD_INT 3
78626: ARRAY
78627: GREATEREQUAL
78628: AND
78629: ST_TO_ADDR
// end ;
78630: LD_VAR 0 2
78634: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78635: LD_INT 0
78637: PPUSH
78638: PPUSH
78639: PPUSH
// pom := GetBase ( building ) ;
78640: LD_ADDR_VAR 0 4
78644: PUSH
78645: LD_VAR 0 1
78649: PPUSH
78650: CALL_OW 274
78654: ST_TO_ADDR
// if not pom then
78655: LD_VAR 0 4
78659: NOT
78660: IFFALSE 78664
// exit ;
78662: GO 78765
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78664: LD_ADDR_VAR 0 5
78668: PUSH
78669: LD_VAR 0 2
78673: PPUSH
78674: LD_VAR 0 1
78678: PPUSH
78679: CALL_OW 248
78683: PPUSH
78684: CALL_OW 450
78688: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78689: LD_ADDR_VAR 0 3
78693: PUSH
78694: LD_VAR 0 4
78698: PPUSH
78699: LD_INT 1
78701: PPUSH
78702: CALL_OW 275
78706: PUSH
78707: LD_VAR 0 5
78711: PUSH
78712: LD_INT 1
78714: ARRAY
78715: GREATEREQUAL
78716: PUSH
78717: LD_VAR 0 4
78721: PPUSH
78722: LD_INT 2
78724: PPUSH
78725: CALL_OW 275
78729: PUSH
78730: LD_VAR 0 5
78734: PUSH
78735: LD_INT 2
78737: ARRAY
78738: GREATEREQUAL
78739: AND
78740: PUSH
78741: LD_VAR 0 4
78745: PPUSH
78746: LD_INT 3
78748: PPUSH
78749: CALL_OW 275
78753: PUSH
78754: LD_VAR 0 5
78758: PUSH
78759: LD_INT 3
78761: ARRAY
78762: GREATEREQUAL
78763: AND
78764: ST_TO_ADDR
// end ;
78765: LD_VAR 0 3
78769: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78770: LD_INT 0
78772: PPUSH
78773: PPUSH
78774: PPUSH
78775: PPUSH
78776: PPUSH
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
// result := false ;
78782: LD_ADDR_VAR 0 6
78786: PUSH
78787: LD_INT 0
78789: ST_TO_ADDR
// if not base or not btype or not x or not y then
78790: LD_VAR 0 1
78794: NOT
78795: PUSH
78796: LD_VAR 0 2
78800: NOT
78801: OR
78802: PUSH
78803: LD_VAR 0 3
78807: NOT
78808: OR
78809: PUSH
78810: LD_VAR 0 4
78814: NOT
78815: OR
78816: IFFALSE 78820
// exit ;
78818: GO 79429
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78820: LD_ADDR_VAR 0 12
78824: PUSH
78825: LD_VAR 0 2
78829: PPUSH
78830: LD_VAR 0 3
78834: PPUSH
78835: LD_VAR 0 4
78839: PPUSH
78840: LD_VAR 0 5
78844: PPUSH
78845: LD_VAR 0 1
78849: PUSH
78850: LD_INT 1
78852: ARRAY
78853: PPUSH
78854: CALL_OW 248
78858: PPUSH
78859: LD_INT 0
78861: PPUSH
78862: CALL 80266 0 6
78866: ST_TO_ADDR
// if not hexes then
78867: LD_VAR 0 12
78871: NOT
78872: IFFALSE 78876
// exit ;
78874: GO 79429
// for i = 1 to hexes do
78876: LD_ADDR_VAR 0 7
78880: PUSH
78881: DOUBLE
78882: LD_INT 1
78884: DEC
78885: ST_TO_ADDR
78886: LD_VAR 0 12
78890: PUSH
78891: FOR_TO
78892: IFFALSE 79427
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78894: LD_ADDR_VAR 0 11
78898: PUSH
78899: LD_VAR 0 12
78903: PUSH
78904: LD_VAR 0 7
78908: ARRAY
78909: PUSH
78910: LD_INT 1
78912: ARRAY
78913: PPUSH
78914: LD_VAR 0 12
78918: PUSH
78919: LD_VAR 0 7
78923: ARRAY
78924: PUSH
78925: LD_INT 2
78927: ARRAY
78928: PPUSH
78929: CALL_OW 428
78933: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78934: LD_VAR 0 12
78938: PUSH
78939: LD_VAR 0 7
78943: ARRAY
78944: PUSH
78945: LD_INT 1
78947: ARRAY
78948: PPUSH
78949: LD_VAR 0 12
78953: PUSH
78954: LD_VAR 0 7
78958: ARRAY
78959: PUSH
78960: LD_INT 2
78962: ARRAY
78963: PPUSH
78964: CALL_OW 351
78968: PUSH
78969: LD_VAR 0 12
78973: PUSH
78974: LD_VAR 0 7
78978: ARRAY
78979: PUSH
78980: LD_INT 1
78982: ARRAY
78983: PPUSH
78984: LD_VAR 0 12
78988: PUSH
78989: LD_VAR 0 7
78993: ARRAY
78994: PUSH
78995: LD_INT 2
78997: ARRAY
78998: PPUSH
78999: CALL_OW 488
79003: NOT
79004: OR
79005: PUSH
79006: LD_VAR 0 11
79010: PPUSH
79011: CALL_OW 247
79015: PUSH
79016: LD_INT 3
79018: EQUAL
79019: OR
79020: IFFALSE 79026
// exit ;
79022: POP
79023: POP
79024: GO 79429
// if not tmp or not tmp in base then
79026: LD_VAR 0 11
79030: NOT
79031: PUSH
79032: LD_VAR 0 11
79036: PUSH
79037: LD_VAR 0 1
79041: IN
79042: NOT
79043: OR
79044: IFFALSE 79048
// continue ;
79046: GO 78891
// result := true ;
79048: LD_ADDR_VAR 0 6
79052: PUSH
79053: LD_INT 1
79055: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79056: LD_ADDR_VAR 0 15
79060: PUSH
79061: LD_VAR 0 1
79065: PPUSH
79066: LD_INT 22
79068: PUSH
79069: LD_VAR 0 11
79073: PPUSH
79074: CALL_OW 255
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 2
79085: PUSH
79086: LD_INT 30
79088: PUSH
79089: LD_INT 0
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 30
79098: PUSH
79099: LD_INT 1
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: LIST
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PPUSH
79115: CALL_OW 72
79119: ST_TO_ADDR
// if dep then
79120: LD_VAR 0 15
79124: IFFALSE 79260
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79126: LD_ADDR_VAR 0 14
79130: PUSH
79131: LD_VAR 0 15
79135: PUSH
79136: LD_INT 1
79138: ARRAY
79139: PPUSH
79140: CALL_OW 250
79144: PPUSH
79145: LD_VAR 0 15
79149: PUSH
79150: LD_INT 1
79152: ARRAY
79153: PPUSH
79154: CALL_OW 254
79158: PPUSH
79159: LD_INT 5
79161: PPUSH
79162: CALL_OW 272
79166: PUSH
79167: LD_VAR 0 15
79171: PUSH
79172: LD_INT 1
79174: ARRAY
79175: PPUSH
79176: CALL_OW 251
79180: PPUSH
79181: LD_VAR 0 15
79185: PUSH
79186: LD_INT 1
79188: ARRAY
79189: PPUSH
79190: CALL_OW 254
79194: PPUSH
79195: LD_INT 5
79197: PPUSH
79198: CALL_OW 273
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79207: LD_VAR 0 14
79211: PUSH
79212: LD_INT 1
79214: ARRAY
79215: PPUSH
79216: LD_VAR 0 14
79220: PUSH
79221: LD_INT 2
79223: ARRAY
79224: PPUSH
79225: CALL_OW 488
79229: IFFALSE 79260
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79231: LD_VAR 0 11
79235: PPUSH
79236: LD_VAR 0 14
79240: PUSH
79241: LD_INT 1
79243: ARRAY
79244: PPUSH
79245: LD_VAR 0 14
79249: PUSH
79250: LD_INT 2
79252: ARRAY
79253: PPUSH
79254: CALL_OW 111
// continue ;
79258: GO 78891
// end ; end ; r := GetDir ( tmp ) ;
79260: LD_ADDR_VAR 0 13
79264: PUSH
79265: LD_VAR 0 11
79269: PPUSH
79270: CALL_OW 254
79274: ST_TO_ADDR
// if r = 5 then
79275: LD_VAR 0 13
79279: PUSH
79280: LD_INT 5
79282: EQUAL
79283: IFFALSE 79293
// r := 0 ;
79285: LD_ADDR_VAR 0 13
79289: PUSH
79290: LD_INT 0
79292: ST_TO_ADDR
// for j = r to 5 do
79293: LD_ADDR_VAR 0 8
79297: PUSH
79298: DOUBLE
79299: LD_VAR 0 13
79303: DEC
79304: ST_TO_ADDR
79305: LD_INT 5
79307: PUSH
79308: FOR_TO
79309: IFFALSE 79423
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79311: LD_ADDR_VAR 0 9
79315: PUSH
79316: LD_VAR 0 11
79320: PPUSH
79321: CALL_OW 250
79325: PPUSH
79326: LD_VAR 0 8
79330: PPUSH
79331: LD_INT 2
79333: PPUSH
79334: CALL_OW 272
79338: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79339: LD_ADDR_VAR 0 10
79343: PUSH
79344: LD_VAR 0 11
79348: PPUSH
79349: CALL_OW 251
79353: PPUSH
79354: LD_VAR 0 8
79358: PPUSH
79359: LD_INT 2
79361: PPUSH
79362: CALL_OW 273
79366: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79367: LD_VAR 0 9
79371: PPUSH
79372: LD_VAR 0 10
79376: PPUSH
79377: CALL_OW 488
79381: PUSH
79382: LD_VAR 0 9
79386: PPUSH
79387: LD_VAR 0 10
79391: PPUSH
79392: CALL_OW 428
79396: NOT
79397: AND
79398: IFFALSE 79421
// begin ComMoveXY ( tmp , _x , _y ) ;
79400: LD_VAR 0 11
79404: PPUSH
79405: LD_VAR 0 9
79409: PPUSH
79410: LD_VAR 0 10
79414: PPUSH
79415: CALL_OW 111
// break ;
79419: GO 79423
// end ; end ;
79421: GO 79308
79423: POP
79424: POP
// end ;
79425: GO 78891
79427: POP
79428: POP
// end ;
79429: LD_VAR 0 6
79433: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79434: LD_INT 0
79436: PPUSH
79437: PPUSH
79438: PPUSH
79439: PPUSH
79440: PPUSH
79441: PPUSH
79442: PPUSH
79443: PPUSH
79444: PPUSH
79445: PPUSH
// result := false ;
79446: LD_ADDR_VAR 0 6
79450: PUSH
79451: LD_INT 0
79453: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79454: LD_VAR 0 1
79458: NOT
79459: PUSH
79460: LD_VAR 0 1
79464: PPUSH
79465: CALL_OW 266
79469: PUSH
79470: LD_INT 0
79472: PUSH
79473: LD_INT 1
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: IN
79480: NOT
79481: OR
79482: PUSH
79483: LD_VAR 0 2
79487: NOT
79488: OR
79489: PUSH
79490: LD_VAR 0 5
79494: PUSH
79495: LD_INT 0
79497: PUSH
79498: LD_INT 1
79500: PUSH
79501: LD_INT 2
79503: PUSH
79504: LD_INT 3
79506: PUSH
79507: LD_INT 4
79509: PUSH
79510: LD_INT 5
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: IN
79521: NOT
79522: OR
79523: PUSH
79524: LD_VAR 0 3
79528: PPUSH
79529: LD_VAR 0 4
79533: PPUSH
79534: CALL_OW 488
79538: NOT
79539: OR
79540: IFFALSE 79544
// exit ;
79542: GO 80261
// pom := GetBase ( depot ) ;
79544: LD_ADDR_VAR 0 10
79548: PUSH
79549: LD_VAR 0 1
79553: PPUSH
79554: CALL_OW 274
79558: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79559: LD_ADDR_VAR 0 11
79563: PUSH
79564: LD_VAR 0 2
79568: PPUSH
79569: LD_VAR 0 1
79573: PPUSH
79574: CALL_OW 248
79578: PPUSH
79579: CALL_OW 450
79583: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79584: LD_VAR 0 10
79588: PPUSH
79589: LD_INT 1
79591: PPUSH
79592: CALL_OW 275
79596: PUSH
79597: LD_VAR 0 11
79601: PUSH
79602: LD_INT 1
79604: ARRAY
79605: GREATEREQUAL
79606: PUSH
79607: LD_VAR 0 10
79611: PPUSH
79612: LD_INT 2
79614: PPUSH
79615: CALL_OW 275
79619: PUSH
79620: LD_VAR 0 11
79624: PUSH
79625: LD_INT 2
79627: ARRAY
79628: GREATEREQUAL
79629: AND
79630: PUSH
79631: LD_VAR 0 10
79635: PPUSH
79636: LD_INT 3
79638: PPUSH
79639: CALL_OW 275
79643: PUSH
79644: LD_VAR 0 11
79648: PUSH
79649: LD_INT 3
79651: ARRAY
79652: GREATEREQUAL
79653: AND
79654: NOT
79655: IFFALSE 79659
// exit ;
79657: GO 80261
// if GetBType ( depot ) = b_depot then
79659: LD_VAR 0 1
79663: PPUSH
79664: CALL_OW 266
79668: PUSH
79669: LD_INT 0
79671: EQUAL
79672: IFFALSE 79684
// dist := 28 else
79674: LD_ADDR_VAR 0 14
79678: PUSH
79679: LD_INT 28
79681: ST_TO_ADDR
79682: GO 79692
// dist := 36 ;
79684: LD_ADDR_VAR 0 14
79688: PUSH
79689: LD_INT 36
79691: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79692: LD_VAR 0 1
79696: PPUSH
79697: LD_VAR 0 3
79701: PPUSH
79702: LD_VAR 0 4
79706: PPUSH
79707: CALL_OW 297
79711: PUSH
79712: LD_VAR 0 14
79716: GREATER
79717: IFFALSE 79721
// exit ;
79719: GO 80261
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79721: LD_ADDR_VAR 0 12
79725: PUSH
79726: LD_VAR 0 2
79730: PPUSH
79731: LD_VAR 0 3
79735: PPUSH
79736: LD_VAR 0 4
79740: PPUSH
79741: LD_VAR 0 5
79745: PPUSH
79746: LD_VAR 0 1
79750: PPUSH
79751: CALL_OW 248
79755: PPUSH
79756: LD_INT 0
79758: PPUSH
79759: CALL 80266 0 6
79763: ST_TO_ADDR
// if not hexes then
79764: LD_VAR 0 12
79768: NOT
79769: IFFALSE 79773
// exit ;
79771: GO 80261
// hex := GetHexInfo ( x , y ) ;
79773: LD_ADDR_VAR 0 15
79777: PUSH
79778: LD_VAR 0 3
79782: PPUSH
79783: LD_VAR 0 4
79787: PPUSH
79788: CALL_OW 546
79792: ST_TO_ADDR
// if hex [ 1 ] then
79793: LD_VAR 0 15
79797: PUSH
79798: LD_INT 1
79800: ARRAY
79801: IFFALSE 79805
// exit ;
79803: GO 80261
// height := hex [ 2 ] ;
79805: LD_ADDR_VAR 0 13
79809: PUSH
79810: LD_VAR 0 15
79814: PUSH
79815: LD_INT 2
79817: ARRAY
79818: ST_TO_ADDR
// for i = 1 to hexes do
79819: LD_ADDR_VAR 0 7
79823: PUSH
79824: DOUBLE
79825: LD_INT 1
79827: DEC
79828: ST_TO_ADDR
79829: LD_VAR 0 12
79833: PUSH
79834: FOR_TO
79835: IFFALSE 80165
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79837: LD_VAR 0 12
79841: PUSH
79842: LD_VAR 0 7
79846: ARRAY
79847: PUSH
79848: LD_INT 1
79850: ARRAY
79851: PPUSH
79852: LD_VAR 0 12
79856: PUSH
79857: LD_VAR 0 7
79861: ARRAY
79862: PUSH
79863: LD_INT 2
79865: ARRAY
79866: PPUSH
79867: CALL_OW 488
79871: NOT
79872: PUSH
79873: LD_VAR 0 12
79877: PUSH
79878: LD_VAR 0 7
79882: ARRAY
79883: PUSH
79884: LD_INT 1
79886: ARRAY
79887: PPUSH
79888: LD_VAR 0 12
79892: PUSH
79893: LD_VAR 0 7
79897: ARRAY
79898: PUSH
79899: LD_INT 2
79901: ARRAY
79902: PPUSH
79903: CALL_OW 428
79907: PUSH
79908: LD_INT 0
79910: GREATER
79911: OR
79912: PUSH
79913: LD_VAR 0 12
79917: PUSH
79918: LD_VAR 0 7
79922: ARRAY
79923: PUSH
79924: LD_INT 1
79926: ARRAY
79927: PPUSH
79928: LD_VAR 0 12
79932: PUSH
79933: LD_VAR 0 7
79937: ARRAY
79938: PUSH
79939: LD_INT 2
79941: ARRAY
79942: PPUSH
79943: CALL_OW 351
79947: OR
79948: IFFALSE 79954
// exit ;
79950: POP
79951: POP
79952: GO 80261
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79954: LD_ADDR_VAR 0 8
79958: PUSH
79959: LD_VAR 0 12
79963: PUSH
79964: LD_VAR 0 7
79968: ARRAY
79969: PUSH
79970: LD_INT 1
79972: ARRAY
79973: PPUSH
79974: LD_VAR 0 12
79978: PUSH
79979: LD_VAR 0 7
79983: ARRAY
79984: PUSH
79985: LD_INT 2
79987: ARRAY
79988: PPUSH
79989: CALL_OW 546
79993: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79994: LD_VAR 0 8
79998: PUSH
79999: LD_INT 1
80001: ARRAY
80002: PUSH
80003: LD_VAR 0 8
80007: PUSH
80008: LD_INT 2
80010: ARRAY
80011: PUSH
80012: LD_VAR 0 13
80016: PUSH
80017: LD_INT 2
80019: PLUS
80020: GREATER
80021: OR
80022: PUSH
80023: LD_VAR 0 8
80027: PUSH
80028: LD_INT 2
80030: ARRAY
80031: PUSH
80032: LD_VAR 0 13
80036: PUSH
80037: LD_INT 2
80039: MINUS
80040: LESS
80041: OR
80042: PUSH
80043: LD_VAR 0 8
80047: PUSH
80048: LD_INT 3
80050: ARRAY
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: LD_INT 8
80057: PUSH
80058: LD_INT 9
80060: PUSH
80061: LD_INT 10
80063: PUSH
80064: LD_INT 11
80066: PUSH
80067: LD_INT 12
80069: PUSH
80070: LD_INT 13
80072: PUSH
80073: LD_INT 16
80075: PUSH
80076: LD_INT 17
80078: PUSH
80079: LD_INT 18
80081: PUSH
80082: LD_INT 19
80084: PUSH
80085: LD_INT 20
80087: PUSH
80088: LD_INT 21
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: IN
80106: NOT
80107: OR
80108: PUSH
80109: LD_VAR 0 8
80113: PUSH
80114: LD_INT 5
80116: ARRAY
80117: NOT
80118: OR
80119: PUSH
80120: LD_VAR 0 8
80124: PUSH
80125: LD_INT 6
80127: ARRAY
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: LD_INT 2
80134: PUSH
80135: LD_INT 7
80137: PUSH
80138: LD_INT 9
80140: PUSH
80141: LD_INT 10
80143: PUSH
80144: LD_INT 11
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: IN
80155: NOT
80156: OR
80157: IFFALSE 80163
// exit ;
80159: POP
80160: POP
80161: GO 80261
// end ;
80163: GO 79834
80165: POP
80166: POP
// side := GetSide ( depot ) ;
80167: LD_ADDR_VAR 0 9
80171: PUSH
80172: LD_VAR 0 1
80176: PPUSH
80177: CALL_OW 255
80181: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80182: LD_VAR 0 9
80186: PPUSH
80187: LD_VAR 0 3
80191: PPUSH
80192: LD_VAR 0 4
80196: PPUSH
80197: LD_INT 20
80199: PPUSH
80200: CALL 72915 0 4
80204: PUSH
80205: LD_INT 4
80207: ARRAY
80208: IFFALSE 80212
// exit ;
80210: GO 80261
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80212: LD_VAR 0 2
80216: PUSH
80217: LD_INT 29
80219: PUSH
80220: LD_INT 30
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: IN
80227: PUSH
80228: LD_VAR 0 3
80232: PPUSH
80233: LD_VAR 0 4
80237: PPUSH
80238: LD_VAR 0 9
80242: PPUSH
80243: CALL_OW 440
80247: NOT
80248: AND
80249: IFFALSE 80253
// exit ;
80251: GO 80261
// result := true ;
80253: LD_ADDR_VAR 0 6
80257: PUSH
80258: LD_INT 1
80260: ST_TO_ADDR
// end ;
80261: LD_VAR 0 6
80265: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80266: LD_INT 0
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
80274: PPUSH
80275: PPUSH
80276: PPUSH
80277: PPUSH
80278: PPUSH
80279: PPUSH
80280: PPUSH
80281: PPUSH
80282: PPUSH
80283: PPUSH
80284: PPUSH
80285: PPUSH
80286: PPUSH
80287: PPUSH
80288: PPUSH
80289: PPUSH
80290: PPUSH
80291: PPUSH
80292: PPUSH
80293: PPUSH
80294: PPUSH
80295: PPUSH
80296: PPUSH
80297: PPUSH
80298: PPUSH
80299: PPUSH
80300: PPUSH
80301: PPUSH
80302: PPUSH
80303: PPUSH
80304: PPUSH
80305: PPUSH
80306: PPUSH
80307: PPUSH
80308: PPUSH
80309: PPUSH
80310: PPUSH
80311: PPUSH
80312: PPUSH
80313: PPUSH
80314: PPUSH
80315: PPUSH
80316: PPUSH
80317: PPUSH
80318: PPUSH
80319: PPUSH
80320: PPUSH
80321: PPUSH
80322: PPUSH
80323: PPUSH
80324: PPUSH
80325: PPUSH
// result = [ ] ;
80326: LD_ADDR_VAR 0 7
80330: PUSH
80331: EMPTY
80332: ST_TO_ADDR
// temp_list = [ ] ;
80333: LD_ADDR_VAR 0 9
80337: PUSH
80338: EMPTY
80339: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80340: LD_VAR 0 4
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: LD_INT 2
80353: PUSH
80354: LD_INT 3
80356: PUSH
80357: LD_INT 4
80359: PUSH
80360: LD_INT 5
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: IN
80371: NOT
80372: PUSH
80373: LD_VAR 0 1
80377: PUSH
80378: LD_INT 0
80380: PUSH
80381: LD_INT 1
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: IN
80388: PUSH
80389: LD_VAR 0 5
80393: PUSH
80394: LD_INT 1
80396: PUSH
80397: LD_INT 2
80399: PUSH
80400: LD_INT 3
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: LIST
80407: IN
80408: NOT
80409: AND
80410: OR
80411: IFFALSE 80415
// exit ;
80413: GO 98806
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80415: LD_VAR 0 1
80419: PUSH
80420: LD_INT 6
80422: PUSH
80423: LD_INT 7
80425: PUSH
80426: LD_INT 8
80428: PUSH
80429: LD_INT 13
80431: PUSH
80432: LD_INT 12
80434: PUSH
80435: LD_INT 15
80437: PUSH
80438: LD_INT 11
80440: PUSH
80441: LD_INT 14
80443: PUSH
80444: LD_INT 10
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: IN
80458: IFFALSE 80468
// btype = b_lab ;
80460: LD_ADDR_VAR 0 1
80464: PUSH
80465: LD_INT 6
80467: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80468: LD_VAR 0 6
80472: PUSH
80473: LD_INT 0
80475: PUSH
80476: LD_INT 1
80478: PUSH
80479: LD_INT 2
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: LIST
80486: IN
80487: NOT
80488: PUSH
80489: LD_VAR 0 1
80493: PUSH
80494: LD_INT 0
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: LD_INT 2
80502: PUSH
80503: LD_INT 3
80505: PUSH
80506: LD_INT 6
80508: PUSH
80509: LD_INT 36
80511: PUSH
80512: LD_INT 4
80514: PUSH
80515: LD_INT 5
80517: PUSH
80518: LD_INT 31
80520: PUSH
80521: LD_INT 32
80523: PUSH
80524: LD_INT 33
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: IN
80540: NOT
80541: PUSH
80542: LD_VAR 0 6
80546: PUSH
80547: LD_INT 1
80549: EQUAL
80550: AND
80551: OR
80552: PUSH
80553: LD_VAR 0 1
80557: PUSH
80558: LD_INT 2
80560: PUSH
80561: LD_INT 3
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: IN
80568: NOT
80569: PUSH
80570: LD_VAR 0 6
80574: PUSH
80575: LD_INT 2
80577: EQUAL
80578: AND
80579: OR
80580: IFFALSE 80590
// mode = 0 ;
80582: LD_ADDR_VAR 0 6
80586: PUSH
80587: LD_INT 0
80589: ST_TO_ADDR
// case mode of 0 :
80590: LD_VAR 0 6
80594: PUSH
80595: LD_INT 0
80597: DOUBLE
80598: EQUAL
80599: IFTRUE 80603
80601: GO 92056
80603: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80604: LD_ADDR_VAR 0 11
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: LD_INT 0
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 0
80621: PUSH
80622: LD_INT 1
80624: NEG
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 1
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 1
80642: PUSH
80643: LD_INT 1
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: PUSH
80650: LD_INT 0
80652: PUSH
80653: LD_INT 1
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 1
80662: NEG
80663: PUSH
80664: LD_INT 0
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 1
80673: NEG
80674: PUSH
80675: LD_INT 1
80677: NEG
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 1
80685: NEG
80686: PUSH
80687: LD_INT 2
80689: NEG
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 2
80700: NEG
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 1
80708: PUSH
80709: LD_INT 1
80711: NEG
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 1
80719: PUSH
80720: LD_INT 2
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 0
80729: PUSH
80730: LD_INT 2
80732: PUSH
80733: EMPTY
80734: LIST
80735: LIST
80736: PUSH
80737: LD_INT 1
80739: NEG
80740: PUSH
80741: LD_INT 1
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 1
80750: PUSH
80751: LD_INT 3
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 0
80760: PUSH
80761: LD_INT 3
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 1
80770: NEG
80771: PUSH
80772: LD_INT 2
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80797: LD_ADDR_VAR 0 12
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: LD_INT 0
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: PUSH
80826: LD_INT 0
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 1
80835: PUSH
80836: LD_INT 1
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: LD_INT 1
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: LD_INT 0
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 1
80866: NEG
80867: PUSH
80868: LD_INT 1
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 1
80878: PUSH
80879: LD_INT 1
80881: NEG
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 2
80889: PUSH
80890: LD_INT 0
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 2
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 1
80909: NEG
80910: PUSH
80911: LD_INT 1
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 2
80920: NEG
80921: PUSH
80922: LD_INT 0
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 2
80931: NEG
80932: PUSH
80933: LD_INT 1
80935: NEG
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 2
80943: NEG
80944: PUSH
80945: LD_INT 1
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 3
80954: NEG
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 3
80965: NEG
80966: PUSH
80967: LD_INT 1
80969: NEG
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80993: LD_ADDR_VAR 0 13
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: LD_INT 0
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PUSH
81008: LD_INT 0
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: LD_INT 1
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: LD_INT 0
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 1
81051: NEG
81052: PUSH
81053: LD_INT 0
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 1
81062: NEG
81063: PUSH
81064: LD_INT 1
81066: NEG
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 1
81074: NEG
81075: PUSH
81076: LD_INT 2
81078: NEG
81079: PUSH
81080: EMPTY
81081: LIST
81082: LIST
81083: PUSH
81084: LD_INT 2
81086: PUSH
81087: LD_INT 1
81089: PUSH
81090: EMPTY
81091: LIST
81092: LIST
81093: PUSH
81094: LD_INT 2
81096: PUSH
81097: LD_INT 2
81099: PUSH
81100: EMPTY
81101: LIST
81102: LIST
81103: PUSH
81104: LD_INT 1
81106: PUSH
81107: LD_INT 2
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 2
81116: NEG
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: LD_INT 2
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 2
81140: NEG
81141: PUSH
81142: LD_INT 3
81144: NEG
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 3
81152: NEG
81153: PUSH
81154: LD_INT 2
81156: NEG
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 3
81164: NEG
81165: PUSH
81166: LD_INT 3
81168: NEG
81169: PUSH
81170: EMPTY
81171: LIST
81172: LIST
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81192: LD_ADDR_VAR 0 14
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 0
81209: PUSH
81210: LD_INT 1
81212: NEG
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: PUSH
81221: LD_INT 0
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: PUSH
81228: LD_INT 1
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 0
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 1
81250: NEG
81251: PUSH
81252: LD_INT 0
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 1
81261: NEG
81262: PUSH
81263: LD_INT 1
81265: NEG
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: LD_INT 2
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 0
81285: PUSH
81286: LD_INT 2
81288: NEG
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 1
81296: PUSH
81297: LD_INT 1
81299: NEG
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 1
81307: PUSH
81308: LD_INT 2
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 0
81317: PUSH
81318: LD_INT 2
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: NEG
81328: PUSH
81329: LD_INT 1
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 1
81338: NEG
81339: PUSH
81340: LD_INT 3
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: LD_INT 3
81353: NEG
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 1
81361: PUSH
81362: LD_INT 2
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81388: LD_ADDR_VAR 0 15
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: LD_INT 0
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 0
81405: PUSH
81406: LD_INT 1
81408: NEG
81409: PUSH
81410: EMPTY
81411: LIST
81412: LIST
81413: PUSH
81414: LD_INT 1
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PUSH
81424: LD_INT 1
81426: PUSH
81427: LD_INT 1
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 0
81436: PUSH
81437: LD_INT 1
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 1
81446: NEG
81447: PUSH
81448: LD_INT 0
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: LD_INT 1
81461: NEG
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 1
81469: PUSH
81470: LD_INT 1
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 2
81490: PUSH
81491: LD_INT 1
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 1
81500: NEG
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 2
81511: NEG
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 2
81522: NEG
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 2
81534: PUSH
81535: LD_INT 1
81537: NEG
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 3
81545: PUSH
81546: LD_INT 0
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 3
81555: PUSH
81556: LD_INT 1
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81581: LD_ADDR_VAR 0 16
81585: PUSH
81586: LD_INT 0
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 0
81598: PUSH
81599: LD_INT 1
81601: NEG
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 1
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 1
81619: PUSH
81620: LD_INT 1
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 0
81629: PUSH
81630: LD_INT 1
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 1
81639: NEG
81640: PUSH
81641: LD_INT 0
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 1
81650: NEG
81651: PUSH
81652: LD_INT 1
81654: NEG
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 1
81662: NEG
81663: PUSH
81664: LD_INT 2
81666: NEG
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 2
81674: PUSH
81675: LD_INT 1
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 2
81684: PUSH
81685: LD_INT 2
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 1
81694: PUSH
81695: LD_INT 2
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 2
81704: NEG
81705: PUSH
81706: LD_INT 1
81708: NEG
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 2
81716: NEG
81717: PUSH
81718: LD_INT 2
81720: NEG
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 3
81728: PUSH
81729: LD_INT 2
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 3
81738: PUSH
81739: LD_INT 3
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: LD_INT 2
81748: PUSH
81749: LD_INT 3
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81774: LD_ADDR_VAR 0 17
81778: PUSH
81779: LD_INT 0
81781: PUSH
81782: LD_INT 0
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 0
81791: PUSH
81792: LD_INT 1
81794: NEG
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PUSH
81800: LD_INT 1
81802: PUSH
81803: LD_INT 0
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PUSH
81810: LD_INT 1
81812: PUSH
81813: LD_INT 1
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 0
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 1
81832: NEG
81833: PUSH
81834: LD_INT 0
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 1
81843: NEG
81844: PUSH
81845: LD_INT 1
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 1
81855: NEG
81856: PUSH
81857: LD_INT 2
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 2
81870: NEG
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 1
81878: PUSH
81879: LD_INT 1
81881: NEG
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 2
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: LD_INT 1
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 2
81909: PUSH
81910: LD_INT 2
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: LD_INT 2
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 0
81929: PUSH
81930: LD_INT 2
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 1
81939: NEG
81940: PUSH
81941: LD_INT 1
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 2
81950: NEG
81951: PUSH
81952: LD_INT 0
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: PUSH
81959: LD_INT 2
81961: NEG
81962: PUSH
81963: LD_INT 1
81965: NEG
81966: PUSH
81967: EMPTY
81968: LIST
81969: LIST
81970: PUSH
81971: LD_INT 2
81973: NEG
81974: PUSH
81975: LD_INT 2
81977: NEG
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82004: LD_ADDR_VAR 0 18
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: LD_INT 1
82024: NEG
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 1
82032: PUSH
82033: LD_INT 0
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 1
82042: PUSH
82043: LD_INT 1
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 0
82052: PUSH
82053: LD_INT 1
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 1
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 1
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: NEG
82086: PUSH
82087: LD_INT 2
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 0
82097: PUSH
82098: LD_INT 2
82100: NEG
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 1
82108: PUSH
82109: LD_INT 1
82111: NEG
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 2
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 2
82129: PUSH
82130: LD_INT 1
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: LD_INT 2
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 1
82149: PUSH
82150: LD_INT 2
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 0
82159: PUSH
82160: LD_INT 2
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 1
82169: NEG
82170: PUSH
82171: LD_INT 1
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 2
82180: NEG
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: NEG
82192: PUSH
82193: LD_INT 1
82195: NEG
82196: PUSH
82197: EMPTY
82198: LIST
82199: LIST
82200: PUSH
82201: LD_INT 2
82203: NEG
82204: PUSH
82205: LD_INT 2
82207: NEG
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82234: LD_ADDR_VAR 0 19
82238: PUSH
82239: LD_INT 0
82241: PUSH
82242: LD_INT 0
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 0
82251: PUSH
82252: LD_INT 1
82254: NEG
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: PUSH
82263: LD_INT 0
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 1
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 0
82282: PUSH
82283: LD_INT 1
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 1
82292: NEG
82293: PUSH
82294: LD_INT 0
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 1
82303: NEG
82304: PUSH
82305: LD_INT 1
82307: NEG
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: NEG
82316: PUSH
82317: LD_INT 2
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 0
82327: PUSH
82328: LD_INT 2
82330: NEG
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PUSH
82336: LD_INT 1
82338: PUSH
82339: LD_INT 1
82341: NEG
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 2
82349: PUSH
82350: LD_INT 0
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 2
82359: PUSH
82360: LD_INT 1
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: PUSH
82370: LD_INT 2
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 1
82379: PUSH
82380: LD_INT 2
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 0
82389: PUSH
82390: LD_INT 2
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: LD_INT 1
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 2
82410: NEG
82411: PUSH
82412: LD_INT 0
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 2
82421: NEG
82422: PUSH
82423: LD_INT 1
82425: NEG
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 2
82433: NEG
82434: PUSH
82435: LD_INT 2
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: LIST
82453: LIST
82454: LIST
82455: LIST
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82464: LD_ADDR_VAR 0 20
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: LD_INT 0
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 0
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: PUSH
82490: LD_INT 1
82492: PUSH
82493: LD_INT 0
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: PUSH
82503: LD_INT 1
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 0
82512: PUSH
82513: LD_INT 1
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 1
82522: NEG
82523: PUSH
82524: LD_INT 0
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 1
82533: NEG
82534: PUSH
82535: LD_INT 1
82537: NEG
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 1
82545: NEG
82546: PUSH
82547: LD_INT 2
82549: NEG
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 0
82557: PUSH
82558: LD_INT 2
82560: NEG
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 1
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 2
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 2
82589: PUSH
82590: LD_INT 1
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: LD_INT 2
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: PUSH
82610: LD_INT 2
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: LD_INT 2
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: LD_INT 1
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 2
82640: NEG
82641: PUSH
82642: LD_INT 0
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 2
82651: NEG
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 2
82663: NEG
82664: PUSH
82665: LD_INT 2
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82694: LD_ADDR_VAR 0 21
82698: PUSH
82699: LD_INT 0
82701: PUSH
82702: LD_INT 0
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 0
82711: PUSH
82712: LD_INT 1
82714: NEG
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: LD_INT 0
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: LD_INT 1
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: LD_INT 1
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: LD_INT 0
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 1
82763: NEG
82764: PUSH
82765: LD_INT 1
82767: NEG
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: NEG
82776: PUSH
82777: LD_INT 2
82779: NEG
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: PUSH
82785: LD_INT 0
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 1
82798: PUSH
82799: LD_INT 1
82801: NEG
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 2
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 2
82819: PUSH
82820: LD_INT 1
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: LD_INT 2
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 1
82839: PUSH
82840: LD_INT 2
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 0
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 1
82859: NEG
82860: PUSH
82861: LD_INT 1
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 2
82870: NEG
82871: PUSH
82872: LD_INT 0
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 2
82881: NEG
82882: PUSH
82883: LD_INT 1
82885: NEG
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 2
82893: NEG
82894: PUSH
82895: LD_INT 2
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: LIST
82914: LIST
82915: LIST
82916: LIST
82917: LIST
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82924: LD_ADDR_VAR 0 22
82928: PUSH
82929: LD_INT 0
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 0
82941: PUSH
82942: LD_INT 1
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 1
82952: PUSH
82953: LD_INT 0
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 1
82962: PUSH
82963: LD_INT 1
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 0
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 1
82982: NEG
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 1
83005: NEG
83006: PUSH
83007: LD_INT 2
83009: NEG
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 0
83017: PUSH
83018: LD_INT 2
83020: NEG
83021: PUSH
83022: EMPTY
83023: LIST
83024: LIST
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 2
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 2
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 2
83059: PUSH
83060: LD_INT 2
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: LD_INT 2
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 0
83079: PUSH
83080: LD_INT 2
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 1
83089: NEG
83090: PUSH
83091: LD_INT 1
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 2
83100: NEG
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: NEG
83112: PUSH
83113: LD_INT 1
83115: NEG
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 2
83123: NEG
83124: PUSH
83125: LD_INT 2
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83154: LD_ADDR_VAR 0 23
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: LD_INT 0
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: LD_INT 1
83174: NEG
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 1
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: LD_INT 1
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 1
83212: NEG
83213: PUSH
83214: LD_INT 0
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 1
83223: NEG
83224: PUSH
83225: LD_INT 1
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 1
83235: NEG
83236: PUSH
83237: LD_INT 2
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 0
83247: PUSH
83248: LD_INT 2
83250: NEG
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: LD_INT 1
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 2
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: LD_INT 1
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: LD_INT 2
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: LD_INT 2
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 0
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 1
83319: NEG
83320: PUSH
83321: LD_INT 1
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: NEG
83331: PUSH
83332: LD_INT 0
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 2
83341: NEG
83342: PUSH
83343: LD_INT 1
83345: NEG
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 2
83353: NEG
83354: PUSH
83355: LD_INT 2
83357: NEG
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 2
83365: NEG
83366: PUSH
83367: LD_INT 3
83369: NEG
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 1
83377: NEG
83378: PUSH
83379: LD_INT 3
83381: NEG
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 1
83389: PUSH
83390: LD_INT 2
83392: NEG
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: LD_INT 1
83403: NEG
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: LIST
83417: LIST
83418: LIST
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83434: LD_ADDR_VAR 0 24
83438: PUSH
83439: LD_INT 0
83441: PUSH
83442: LD_INT 0
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 0
83451: PUSH
83452: LD_INT 1
83454: NEG
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 1
83462: PUSH
83463: LD_INT 0
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 1
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: LD_INT 1
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 1
83492: NEG
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 1
83503: NEG
83504: PUSH
83505: LD_INT 1
83507: NEG
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 1
83515: NEG
83516: PUSH
83517: LD_INT 2
83519: NEG
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: LD_INT 2
83530: NEG
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: LD_INT 1
83538: PUSH
83539: LD_INT 1
83541: NEG
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PUSH
83547: LD_INT 2
83549: PUSH
83550: LD_INT 0
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 2
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 1
83579: PUSH
83580: LD_INT 2
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: PUSH
83587: LD_INT 0
83589: PUSH
83590: LD_INT 2
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 1
83599: NEG
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 2
83610: NEG
83611: PUSH
83612: LD_INT 0
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: LD_INT 2
83621: NEG
83622: PUSH
83623: LD_INT 1
83625: NEG
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 2
83633: NEG
83634: PUSH
83635: LD_INT 2
83637: NEG
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 1
83645: PUSH
83646: LD_INT 2
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 2
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 3
83667: PUSH
83668: LD_INT 1
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 3
83677: PUSH
83678: LD_INT 2
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: EMPTY
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83710: LD_ADDR_VAR 0 25
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: LD_INT 0
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 1
83738: PUSH
83739: LD_INT 0
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 1
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 0
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 1
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: NEG
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 1
83791: NEG
83792: PUSH
83793: LD_INT 2
83795: NEG
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 0
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: LD_INT 1
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 2
83825: PUSH
83826: LD_INT 0
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 2
83835: PUSH
83836: LD_INT 1
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: PUSH
83846: LD_INT 2
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 1
83855: PUSH
83856: LD_INT 2
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 0
83865: PUSH
83866: LD_INT 2
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: NEG
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 2
83886: NEG
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 2
83897: NEG
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 2
83909: NEG
83910: PUSH
83911: LD_INT 2
83913: NEG
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PUSH
83919: LD_INT 3
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 3
83931: PUSH
83932: LD_INT 2
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 2
83941: PUSH
83942: LD_INT 3
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 1
83951: PUSH
83952: LD_INT 3
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83984: LD_ADDR_VAR 0 26
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: LD_INT 0
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: LD_INT 1
84004: NEG
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: LD_INT 0
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 1
84022: PUSH
84023: LD_INT 1
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 0
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 1
84042: NEG
84043: PUSH
84044: LD_INT 0
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 1
84053: NEG
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 1
84065: NEG
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 0
84077: PUSH
84078: LD_INT 2
84080: NEG
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 1
84091: NEG
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 2
84099: PUSH
84100: LD_INT 0
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 2
84109: PUSH
84110: LD_INT 1
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 2
84119: PUSH
84120: LD_INT 2
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 1
84129: PUSH
84130: LD_INT 2
84132: PUSH
84133: EMPTY
84134: LIST
84135: LIST
84136: PUSH
84137: LD_INT 0
84139: PUSH
84140: LD_INT 2
84142: PUSH
84143: EMPTY
84144: LIST
84145: LIST
84146: PUSH
84147: LD_INT 1
84149: NEG
84150: PUSH
84151: LD_INT 1
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 2
84160: NEG
84161: PUSH
84162: LD_INT 0
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 2
84171: NEG
84172: PUSH
84173: LD_INT 1
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 2
84183: NEG
84184: PUSH
84185: LD_INT 2
84187: NEG
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 2
84195: PUSH
84196: LD_INT 3
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 1
84205: PUSH
84206: LD_INT 3
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 1
84215: NEG
84216: PUSH
84217: LD_INT 2
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 2
84226: NEG
84227: PUSH
84228: LD_INT 1
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: LIST
84253: LIST
84254: LIST
84255: LIST
84256: LIST
84257: LIST
84258: LIST
84259: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84260: LD_ADDR_VAR 0 27
84264: PUSH
84265: LD_INT 0
84267: PUSH
84268: LD_INT 0
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 0
84277: PUSH
84278: LD_INT 1
84280: NEG
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 1
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: PUSH
84296: LD_INT 1
84298: PUSH
84299: LD_INT 1
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 0
84308: PUSH
84309: LD_INT 1
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 0
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: NEG
84330: PUSH
84331: LD_INT 1
84333: NEG
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 1
84341: NEG
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 0
84353: PUSH
84354: LD_INT 2
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 1
84367: NEG
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PUSH
84373: LD_INT 2
84375: PUSH
84376: LD_INT 0
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PUSH
84383: LD_INT 2
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 2
84395: PUSH
84396: LD_INT 2
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 1
84405: PUSH
84406: LD_INT 2
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 0
84415: PUSH
84416: LD_INT 2
84418: PUSH
84419: EMPTY
84420: LIST
84421: LIST
84422: PUSH
84423: LD_INT 1
84425: NEG
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 2
84436: NEG
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: NEG
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: LD_INT 2
84463: NEG
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 1
84471: NEG
84472: PUSH
84473: LD_INT 2
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 2
84482: NEG
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 3
84493: NEG
84494: PUSH
84495: LD_INT 1
84497: NEG
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 3
84505: NEG
84506: PUSH
84507: LD_INT 2
84509: NEG
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84540: LD_ADDR_VAR 0 28
84544: PUSH
84545: LD_INT 0
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: LD_INT 1
84560: NEG
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: PUSH
84569: LD_INT 0
84571: PUSH
84572: EMPTY
84573: LIST
84574: LIST
84575: PUSH
84576: LD_INT 1
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: LD_INT 1
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 1
84598: NEG
84599: PUSH
84600: LD_INT 0
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 1
84609: NEG
84610: PUSH
84611: LD_INT 1
84613: NEG
84614: PUSH
84615: EMPTY
84616: LIST
84617: LIST
84618: PUSH
84619: LD_INT 1
84621: NEG
84622: PUSH
84623: LD_INT 2
84625: NEG
84626: PUSH
84627: EMPTY
84628: LIST
84629: LIST
84630: PUSH
84631: LD_INT 0
84633: PUSH
84634: LD_INT 2
84636: NEG
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: LD_INT 1
84647: NEG
84648: PUSH
84649: EMPTY
84650: LIST
84651: LIST
84652: PUSH
84653: LD_INT 2
84655: PUSH
84656: LD_INT 0
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 2
84665: PUSH
84666: LD_INT 1
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 2
84675: PUSH
84676: LD_INT 2
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: LD_INT 2
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 0
84695: PUSH
84696: LD_INT 2
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 1
84705: NEG
84706: PUSH
84707: LD_INT 1
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: LD_INT 0
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: LD_INT 1
84731: NEG
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 2
84739: NEG
84740: PUSH
84741: LD_INT 2
84743: NEG
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 2
84751: NEG
84752: PUSH
84753: LD_INT 3
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 1
84763: NEG
84764: PUSH
84765: LD_INT 3
84767: NEG
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 3
84775: NEG
84776: PUSH
84777: LD_INT 1
84779: NEG
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 3
84787: NEG
84788: PUSH
84789: LD_INT 2
84791: NEG
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: LIST
84806: LIST
84807: LIST
84808: LIST
84809: LIST
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84822: LD_ADDR_VAR 0 29
84826: PUSH
84827: LD_INT 0
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 0
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 1
84860: PUSH
84861: LD_INT 1
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 0
84870: PUSH
84871: LD_INT 1
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 1
84891: NEG
84892: PUSH
84893: LD_INT 1
84895: NEG
84896: PUSH
84897: EMPTY
84898: LIST
84899: LIST
84900: PUSH
84901: LD_INT 1
84903: NEG
84904: PUSH
84905: LD_INT 2
84907: NEG
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: PUSH
84913: LD_INT 0
84915: PUSH
84916: LD_INT 2
84918: NEG
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 1
84926: PUSH
84927: LD_INT 1
84929: NEG
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 2
84937: PUSH
84938: LD_INT 0
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 2
84947: PUSH
84948: LD_INT 1
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: PUSH
84955: LD_INT 1
84957: PUSH
84958: LD_INT 2
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 0
84967: PUSH
84968: LD_INT 2
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: NEG
84978: PUSH
84979: LD_INT 1
84981: PUSH
84982: EMPTY
84983: LIST
84984: LIST
84985: PUSH
84986: LD_INT 2
84988: NEG
84989: PUSH
84990: LD_INT 1
84992: NEG
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: LD_INT 2
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 2
85012: NEG
85013: PUSH
85014: LD_INT 3
85016: NEG
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 2
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 3
85035: PUSH
85036: LD_INT 1
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: LD_INT 3
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 1
85055: NEG
85056: PUSH
85057: LD_INT 2
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 3
85066: NEG
85067: PUSH
85068: LD_INT 2
85070: NEG
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85101: LD_ADDR_VAR 0 30
85105: PUSH
85106: LD_INT 0
85108: PUSH
85109: LD_INT 0
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 0
85118: PUSH
85119: LD_INT 1
85121: NEG
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 1
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 1
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 0
85149: PUSH
85150: LD_INT 1
85152: PUSH
85153: EMPTY
85154: LIST
85155: LIST
85156: PUSH
85157: LD_INT 1
85159: NEG
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: LD_INT 1
85174: NEG
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 1
85182: NEG
85183: PUSH
85184: LD_INT 2
85186: NEG
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: LD_INT 2
85197: NEG
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: PUSH
85206: LD_INT 1
85208: NEG
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 2
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 2
85226: PUSH
85227: LD_INT 1
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: PUSH
85234: LD_INT 2
85236: PUSH
85237: LD_INT 2
85239: PUSH
85240: EMPTY
85241: LIST
85242: LIST
85243: PUSH
85244: LD_INT 1
85246: PUSH
85247: LD_INT 2
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 1
85256: NEG
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 2
85267: NEG
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 2
85278: NEG
85279: PUSH
85280: LD_INT 1
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: LD_INT 3
85294: NEG
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: LD_INT 2
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 3
85313: PUSH
85314: LD_INT 2
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 2
85323: PUSH
85324: LD_INT 3
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 2
85333: NEG
85334: PUSH
85335: LD_INT 1
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 3
85344: NEG
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85379: LD_ADDR_VAR 0 31
85383: PUSH
85384: LD_INT 0
85386: PUSH
85387: LD_INT 0
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: LD_INT 1
85399: NEG
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 1
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 1
85417: PUSH
85418: LD_INT 1
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: PUSH
85425: LD_INT 0
85427: PUSH
85428: LD_INT 1
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: LD_INT 0
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: LD_INT 1
85452: NEG
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 1
85460: NEG
85461: PUSH
85462: LD_INT 2
85464: NEG
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 1
85472: PUSH
85473: LD_INT 1
85475: NEG
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: PUSH
85481: LD_INT 2
85483: PUSH
85484: LD_INT 0
85486: PUSH
85487: EMPTY
85488: LIST
85489: LIST
85490: PUSH
85491: LD_INT 2
85493: PUSH
85494: LD_INT 1
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: PUSH
85501: LD_INT 2
85503: PUSH
85504: LD_INT 2
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 1
85513: PUSH
85514: LD_INT 2
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 0
85523: PUSH
85524: LD_INT 2
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 1
85533: NEG
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 2
85544: NEG
85545: PUSH
85546: LD_INT 1
85548: NEG
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 2
85556: NEG
85557: PUSH
85558: LD_INT 2
85560: NEG
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 2
85568: NEG
85569: PUSH
85570: LD_INT 3
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 2
85580: PUSH
85581: LD_INT 1
85583: NEG
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 3
85591: PUSH
85592: LD_INT 1
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 1
85601: PUSH
85602: LD_INT 3
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: NEG
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 3
85622: NEG
85623: PUSH
85624: LD_INT 2
85626: NEG
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85657: LD_ADDR_VAR 0 32
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: LD_INT 0
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 0
85674: PUSH
85675: LD_INT 1
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 0
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: LD_INT 1
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 0
85705: PUSH
85706: LD_INT 1
85708: PUSH
85709: EMPTY
85710: LIST
85711: LIST
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 1
85726: NEG
85727: PUSH
85728: LD_INT 1
85730: NEG
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: NEG
85739: PUSH
85740: LD_INT 2
85742: NEG
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 0
85750: PUSH
85751: LD_INT 2
85753: NEG
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: LD_INT 1
85764: NEG
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 2
85772: PUSH
85773: LD_INT 1
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 2
85782: PUSH
85783: LD_INT 2
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: PUSH
85793: LD_INT 2
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 0
85802: PUSH
85803: LD_INT 2
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 1
85812: NEG
85813: PUSH
85814: LD_INT 1
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: LD_INT 2
85823: NEG
85824: PUSH
85825: LD_INT 0
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 2
85834: NEG
85835: PUSH
85836: LD_INT 1
85838: NEG
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 1
85846: NEG
85847: PUSH
85848: LD_INT 3
85850: NEG
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 1
85858: PUSH
85859: LD_INT 2
85861: NEG
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 3
85869: PUSH
85870: LD_INT 2
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 2
85879: PUSH
85880: LD_INT 3
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 2
85889: NEG
85890: PUSH
85891: LD_INT 1
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 3
85900: NEG
85901: PUSH
85902: LD_INT 1
85904: NEG
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85935: LD_ADDR_VAR 0 33
85939: PUSH
85940: LD_INT 0
85942: PUSH
85943: LD_INT 0
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 0
85952: PUSH
85953: LD_INT 1
85955: NEG
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 1
85963: PUSH
85964: LD_INT 0
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 1
85973: PUSH
85974: LD_INT 1
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 0
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 1
85993: NEG
85994: PUSH
85995: LD_INT 0
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: PUSH
86006: LD_INT 1
86008: NEG
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 1
86016: NEG
86017: PUSH
86018: LD_INT 2
86020: NEG
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: LD_INT 1
86031: NEG
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 2
86039: PUSH
86040: LD_INT 0
86042: PUSH
86043: EMPTY
86044: LIST
86045: LIST
86046: PUSH
86047: LD_INT 2
86049: PUSH
86050: LD_INT 1
86052: PUSH
86053: EMPTY
86054: LIST
86055: LIST
86056: PUSH
86057: LD_INT 1
86059: PUSH
86060: LD_INT 2
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 0
86069: PUSH
86070: LD_INT 2
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 1
86079: NEG
86080: PUSH
86081: LD_INT 1
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 2
86090: NEG
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 2
86101: NEG
86102: PUSH
86103: LD_INT 1
86105: NEG
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 2
86113: NEG
86114: PUSH
86115: LD_INT 2
86117: NEG
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 2
86125: NEG
86126: PUSH
86127: LD_INT 3
86129: NEG
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 2
86137: PUSH
86138: LD_INT 1
86140: NEG
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: LD_INT 3
86148: PUSH
86149: LD_INT 1
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 1
86158: PUSH
86159: LD_INT 3
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 1
86168: NEG
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 3
86179: NEG
86180: PUSH
86181: LD_INT 2
86183: NEG
86184: PUSH
86185: EMPTY
86186: LIST
86187: LIST
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86214: LD_ADDR_VAR 0 34
86218: PUSH
86219: LD_INT 0
86221: PUSH
86222: LD_INT 0
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 1
86234: NEG
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 1
86242: PUSH
86243: LD_INT 0
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 0
86262: PUSH
86263: LD_INT 1
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 1
86272: NEG
86273: PUSH
86274: LD_INT 0
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: LD_INT 1
86283: NEG
86284: PUSH
86285: LD_INT 1
86287: NEG
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 1
86295: NEG
86296: PUSH
86297: LD_INT 2
86299: NEG
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 0
86307: PUSH
86308: LD_INT 2
86310: NEG
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 1
86318: PUSH
86319: LD_INT 1
86321: NEG
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 2
86329: PUSH
86330: LD_INT 1
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 2
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 1
86349: PUSH
86350: LD_INT 2
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: NEG
86360: PUSH
86361: LD_INT 1
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 2
86370: NEG
86371: PUSH
86372: LD_INT 0
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 2
86381: NEG
86382: PUSH
86383: LD_INT 1
86385: NEG
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 2
86393: NEG
86394: PUSH
86395: LD_INT 2
86397: NEG
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: PUSH
86403: LD_INT 1
86405: NEG
86406: PUSH
86407: LD_INT 3
86409: NEG
86410: PUSH
86411: EMPTY
86412: LIST
86413: LIST
86414: PUSH
86415: LD_INT 1
86417: PUSH
86418: LD_INT 2
86420: NEG
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 3
86428: PUSH
86429: LD_INT 2
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 2
86438: PUSH
86439: LD_INT 3
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 2
86448: NEG
86449: PUSH
86450: LD_INT 1
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 3
86459: NEG
86460: PUSH
86461: LD_INT 1
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86494: LD_ADDR_VAR 0 35
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 0
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: LD_INT 1
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 1
86522: PUSH
86523: LD_INT 0
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: LD_INT 1
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 2
86575: PUSH
86576: LD_INT 1
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 2
86585: NEG
86586: PUSH
86587: LD_INT 1
86589: NEG
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86606: LD_ADDR_VAR 0 36
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: LD_INT 1
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: NEG
86676: PUSH
86677: LD_INT 1
86679: NEG
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: LD_INT 2
86691: NEG
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: PUSH
86700: LD_INT 2
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86718: LD_ADDR_VAR 0 37
86722: PUSH
86723: LD_INT 0
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 1
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: PUSH
86800: LD_INT 1
86802: NEG
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 1
86810: NEG
86811: PUSH
86812: LD_INT 1
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: LIST
86825: LIST
86826: LIST
86827: LIST
86828: LIST
86829: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86830: LD_ADDR_VAR 0 38
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 0
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 1
86858: PUSH
86859: LD_INT 0
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 1
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 0
86878: PUSH
86879: LD_INT 1
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 1
86888: NEG
86889: PUSH
86890: LD_INT 0
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 1
86899: NEG
86900: PUSH
86901: LD_INT 1
86903: NEG
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 2
86911: PUSH
86912: LD_INT 1
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 2
86921: NEG
86922: PUSH
86923: LD_INT 1
86925: NEG
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86942: LD_ADDR_VAR 0 39
86946: PUSH
86947: LD_INT 0
86949: PUSH
86950: LD_INT 0
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 0
86959: PUSH
86960: LD_INT 1
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: LD_INT 1
86980: PUSH
86981: LD_INT 1
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 0
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 1
87000: NEG
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 1
87011: NEG
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 1
87023: NEG
87024: PUSH
87025: LD_INT 2
87027: NEG
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 1
87035: PUSH
87036: LD_INT 2
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87054: LD_ADDR_VAR 0 40
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 0
87071: PUSH
87072: LD_INT 1
87074: NEG
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: PUSH
87093: LD_INT 1
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 0
87102: PUSH
87103: LD_INT 1
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: NEG
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: LD_INT 1
87123: NEG
87124: PUSH
87125: LD_INT 1
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 1
87146: NEG
87147: PUSH
87148: LD_INT 1
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87166: LD_ADDR_VAR 0 41
87170: PUSH
87171: LD_INT 0
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 0
87183: PUSH
87184: LD_INT 1
87186: NEG
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 0
87214: PUSH
87215: LD_INT 1
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 1
87224: NEG
87225: PUSH
87226: LD_INT 0
87228: PUSH
87229: EMPTY
87230: LIST
87231: LIST
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: LD_INT 1
87239: NEG
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: NEG
87248: PUSH
87249: LD_INT 2
87251: NEG
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: LD_INT 1
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 2
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 2
87280: PUSH
87281: LD_INT 1
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 2
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 2
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 1
87310: NEG
87311: PUSH
87312: LD_INT 1
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 2
87321: NEG
87322: PUSH
87323: LD_INT 0
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 2
87332: NEG
87333: PUSH
87334: LD_INT 1
87336: NEG
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: NEG
87345: PUSH
87346: LD_INT 2
87348: NEG
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 2
87356: NEG
87357: PUSH
87358: LD_INT 3
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 2
87368: PUSH
87369: LD_INT 1
87371: NEG
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 3
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: EMPTY
87384: LIST
87385: LIST
87386: PUSH
87387: LD_INT 3
87389: PUSH
87390: LD_INT 1
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 3
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: PUSH
87407: LD_INT 3
87409: PUSH
87410: LD_INT 3
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 2
87419: PUSH
87420: LD_INT 3
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 2
87429: NEG
87430: PUSH
87431: LD_INT 1
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 3
87440: NEG
87441: PUSH
87442: LD_INT 0
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 3
87451: NEG
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 3
87463: NEG
87464: PUSH
87465: LD_INT 2
87467: NEG
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: PUSH
87473: LD_INT 3
87475: NEG
87476: PUSH
87477: LD_INT 3
87479: NEG
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87516: LD_ADDR_VAR 0 42
87520: PUSH
87521: LD_INT 0
87523: PUSH
87524: LD_INT 0
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 0
87533: PUSH
87534: LD_INT 1
87536: NEG
87537: PUSH
87538: EMPTY
87539: LIST
87540: LIST
87541: PUSH
87542: LD_INT 1
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PUSH
87552: LD_INT 1
87554: PUSH
87555: LD_INT 1
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 0
87564: PUSH
87565: LD_INT 1
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 1
87574: NEG
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 1
87585: NEG
87586: PUSH
87587: LD_INT 1
87589: NEG
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: PUSH
87595: LD_INT 1
87597: NEG
87598: PUSH
87599: LD_INT 2
87601: NEG
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 0
87609: PUSH
87610: LD_INT 2
87612: NEG
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 1
87620: PUSH
87621: LD_INT 1
87623: NEG
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 2
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 2
87641: PUSH
87642: LD_INT 2
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: PUSH
87652: LD_INT 2
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: LD_INT 2
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 1
87671: NEG
87672: PUSH
87673: LD_INT 1
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 2
87682: NEG
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 2
87694: NEG
87695: PUSH
87696: LD_INT 2
87698: NEG
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 2
87706: NEG
87707: PUSH
87708: LD_INT 3
87710: NEG
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 1
87718: NEG
87719: PUSH
87720: LD_INT 3
87722: NEG
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 0
87730: PUSH
87731: LD_INT 3
87733: NEG
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 1
87741: PUSH
87742: LD_INT 2
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 3
87752: PUSH
87753: LD_INT 2
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 3
87762: PUSH
87763: LD_INT 3
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 2
87772: PUSH
87773: LD_INT 3
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: LD_INT 3
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 0
87792: PUSH
87793: LD_INT 3
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 3
87813: NEG
87814: PUSH
87815: LD_INT 2
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 3
87825: NEG
87826: PUSH
87827: LD_INT 3
87829: NEG
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87866: LD_ADDR_VAR 0 43
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: LD_INT 1
87886: NEG
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 1
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: PUSH
87902: LD_INT 1
87904: PUSH
87905: LD_INT 1
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 0
87914: PUSH
87915: LD_INT 1
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 1
87924: NEG
87925: PUSH
87926: LD_INT 0
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 1
87935: NEG
87936: PUSH
87937: LD_INT 1
87939: NEG
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 1
87947: NEG
87948: PUSH
87949: LD_INT 2
87951: NEG
87952: PUSH
87953: EMPTY
87954: LIST
87955: LIST
87956: PUSH
87957: LD_INT 0
87959: PUSH
87960: LD_INT 2
87962: NEG
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 1
87970: PUSH
87971: LD_INT 1
87973: NEG
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 2
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 1
88001: PUSH
88002: LD_INT 2
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: LD_INT 2
88014: PUSH
88015: EMPTY
88016: LIST
88017: LIST
88018: PUSH
88019: LD_INT 1
88021: NEG
88022: PUSH
88023: LD_INT 1
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 2
88032: NEG
88033: PUSH
88034: LD_INT 0
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 2
88043: NEG
88044: PUSH
88045: LD_INT 1
88047: NEG
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 1
88055: NEG
88056: PUSH
88057: LD_INT 3
88059: NEG
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 0
88067: PUSH
88068: LD_INT 3
88070: NEG
88071: PUSH
88072: EMPTY
88073: LIST
88074: LIST
88075: PUSH
88076: LD_INT 1
88078: PUSH
88079: LD_INT 2
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 2
88089: PUSH
88090: LD_INT 1
88092: NEG
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 3
88100: PUSH
88101: LD_INT 0
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 3
88110: PUSH
88111: LD_INT 1
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: LD_INT 1
88120: PUSH
88121: LD_INT 3
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: LD_INT 3
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 1
88140: NEG
88141: PUSH
88142: LD_INT 2
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 2
88151: NEG
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 3
88162: NEG
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 3
88173: NEG
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88214: LD_ADDR_VAR 0 44
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 0
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: LD_INT 1
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 1
88242: PUSH
88243: LD_INT 0
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 1
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 0
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 1
88272: NEG
88273: PUSH
88274: LD_INT 0
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 1
88283: NEG
88284: PUSH
88285: LD_INT 1
88287: NEG
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PUSH
88293: LD_INT 1
88295: NEG
88296: PUSH
88297: LD_INT 2
88299: NEG
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: PUSH
88305: LD_INT 1
88307: PUSH
88308: LD_INT 1
88310: NEG
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: LD_INT 2
88318: PUSH
88319: LD_INT 0
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 2
88328: PUSH
88329: LD_INT 1
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 2
88338: PUSH
88339: LD_INT 2
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 1
88348: PUSH
88349: LD_INT 2
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: NEG
88359: PUSH
88360: LD_INT 1
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 2
88369: NEG
88370: PUSH
88371: LD_INT 0
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 2
88380: NEG
88381: PUSH
88382: LD_INT 1
88384: NEG
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 2
88392: NEG
88393: PUSH
88394: LD_INT 2
88396: NEG
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: LD_INT 2
88404: NEG
88405: PUSH
88406: LD_INT 3
88408: NEG
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: LD_INT 2
88416: PUSH
88417: LD_INT 1
88419: NEG
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 3
88427: PUSH
88428: LD_INT 0
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 3
88437: PUSH
88438: LD_INT 1
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 3
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: PUSH
88455: LD_INT 3
88457: PUSH
88458: LD_INT 3
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 2
88467: PUSH
88468: LD_INT 3
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: LD_INT 2
88477: NEG
88478: PUSH
88479: LD_INT 1
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 3
88488: NEG
88489: PUSH
88490: LD_INT 0
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 3
88499: NEG
88500: PUSH
88501: LD_INT 1
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 3
88511: NEG
88512: PUSH
88513: LD_INT 2
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 3
88523: NEG
88524: PUSH
88525: LD_INT 3
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88564: LD_ADDR_VAR 0 45
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: LD_INT 0
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 0
88581: PUSH
88582: LD_INT 1
88584: NEG
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 1
88592: PUSH
88593: LD_INT 0
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: LD_INT 1
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: NEG
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: LD_INT 1
88637: NEG
88638: PUSH
88639: EMPTY
88640: LIST
88641: LIST
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: PUSH
88647: LD_INT 2
88649: NEG
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: PUSH
88655: LD_INT 0
88657: PUSH
88658: LD_INT 2
88660: NEG
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 1
88668: PUSH
88669: LD_INT 1
88671: NEG
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: LD_INT 2
88679: PUSH
88680: LD_INT 1
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PUSH
88687: LD_INT 2
88689: PUSH
88690: LD_INT 2
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: PUSH
88700: LD_INT 2
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 0
88709: PUSH
88710: LD_INT 2
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 1
88719: NEG
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 2
88730: NEG
88731: PUSH
88732: LD_INT 1
88734: NEG
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 2
88742: NEG
88743: PUSH
88744: LD_INT 2
88746: NEG
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 2
88754: NEG
88755: PUSH
88756: LD_INT 3
88758: NEG
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: LD_INT 3
88770: NEG
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 0
88778: PUSH
88779: LD_INT 3
88781: NEG
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: LD_INT 2
88792: NEG
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 3
88800: PUSH
88801: LD_INT 2
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 3
88810: PUSH
88811: LD_INT 3
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: LD_INT 3
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 1
88830: PUSH
88831: LD_INT 3
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 0
88840: PUSH
88841: LD_INT 3
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 1
88850: NEG
88851: PUSH
88852: LD_INT 2
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 3
88861: NEG
88862: PUSH
88863: LD_INT 2
88865: NEG
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 3
88873: NEG
88874: PUSH
88875: LD_INT 3
88877: NEG
88878: PUSH
88879: EMPTY
88880: LIST
88881: LIST
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88914: LD_ADDR_VAR 0 46
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 1
88952: PUSH
88953: LD_INT 1
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: LD_INT 1
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 1
88972: NEG
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: NEG
88996: PUSH
88997: LD_INT 2
88999: NEG
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 2
89010: NEG
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 2
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 2
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 1
89049: PUSH
89050: LD_INT 2
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 0
89059: PUSH
89060: LD_INT 2
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 1
89069: NEG
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: NEG
89081: PUSH
89082: LD_INT 0
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 2
89091: NEG
89092: PUSH
89093: LD_INT 1
89095: NEG
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 1
89103: NEG
89104: PUSH
89105: LD_INT 3
89107: NEG
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: LD_INT 3
89118: NEG
89119: PUSH
89120: EMPTY
89121: LIST
89122: LIST
89123: PUSH
89124: LD_INT 1
89126: PUSH
89127: LD_INT 2
89129: NEG
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 2
89137: PUSH
89138: LD_INT 1
89140: NEG
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 3
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 3
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 1
89168: PUSH
89169: LD_INT 3
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 0
89178: PUSH
89179: LD_INT 3
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 1
89188: NEG
89189: PUSH
89190: LD_INT 2
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 2
89199: NEG
89200: PUSH
89201: LD_INT 1
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 3
89210: NEG
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 3
89221: NEG
89222: PUSH
89223: LD_INT 1
89225: NEG
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89262: LD_ADDR_VAR 0 47
89266: PUSH
89267: LD_INT 0
89269: PUSH
89270: LD_INT 0
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 0
89279: PUSH
89280: LD_INT 1
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: PUSH
89291: LD_INT 0
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 1
89300: PUSH
89301: LD_INT 1
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: LD_INT 0
89310: PUSH
89311: LD_INT 1
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 1
89320: NEG
89321: PUSH
89322: LD_INT 0
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 1
89331: NEG
89332: PUSH
89333: LD_INT 1
89335: NEG
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 1
89343: NEG
89344: PUSH
89345: LD_INT 2
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 0
89355: PUSH
89356: LD_INT 2
89358: NEG
89359: PUSH
89360: EMPTY
89361: LIST
89362: LIST
89363: PUSH
89364: LD_INT 1
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 2
89377: NEG
89378: PUSH
89379: LD_INT 1
89381: NEG
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 2
89389: NEG
89390: PUSH
89391: LD_INT 2
89393: NEG
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89413: LD_ADDR_VAR 0 48
89417: PUSH
89418: LD_INT 0
89420: PUSH
89421: LD_INT 0
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: LD_INT 1
89433: NEG
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 1
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 1
89451: PUSH
89452: LD_INT 1
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 0
89461: PUSH
89462: LD_INT 1
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 1
89471: NEG
89472: PUSH
89473: LD_INT 0
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 1
89482: NEG
89483: PUSH
89484: LD_INT 1
89486: NEG
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: LD_INT 2
89498: NEG
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: LD_INT 2
89509: NEG
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 1
89517: PUSH
89518: LD_INT 1
89520: NEG
89521: PUSH
89522: EMPTY
89523: LIST
89524: LIST
89525: PUSH
89526: LD_INT 2
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 2
89538: PUSH
89539: LD_INT 1
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89560: LD_ADDR_VAR 0 49
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 0
89577: PUSH
89578: LD_INT 1
89580: NEG
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 1
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: EMPTY
89593: LIST
89594: LIST
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: LD_INT 1
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 0
89608: PUSH
89609: LD_INT 1
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: LD_INT 0
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 1
89629: NEG
89630: PUSH
89631: LD_INT 1
89633: NEG
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 1
89641: PUSH
89642: LD_INT 1
89644: NEG
89645: PUSH
89646: EMPTY
89647: LIST
89648: LIST
89649: PUSH
89650: LD_INT 2
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 2
89662: PUSH
89663: LD_INT 1
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 2
89672: PUSH
89673: LD_INT 2
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 1
89682: PUSH
89683: LD_INT 2
89685: PUSH
89686: EMPTY
89687: LIST
89688: LIST
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89704: LD_ADDR_VAR 0 50
89708: PUSH
89709: LD_INT 0
89711: PUSH
89712: LD_INT 0
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 1
89724: NEG
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 1
89732: PUSH
89733: LD_INT 0
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: PUSH
89743: LD_INT 1
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 0
89752: PUSH
89753: LD_INT 1
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 1
89762: NEG
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 1
89773: NEG
89774: PUSH
89775: LD_INT 1
89777: NEG
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 2
89785: PUSH
89786: LD_INT 1
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 2
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 1
89805: PUSH
89806: LD_INT 2
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 0
89815: PUSH
89816: LD_INT 2
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 1
89825: NEG
89826: PUSH
89827: LD_INT 1
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89848: LD_ADDR_VAR 0 51
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 0
89865: PUSH
89866: LD_INT 1
89868: NEG
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 1
89876: PUSH
89877: LD_INT 0
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: LD_INT 1
89886: PUSH
89887: LD_INT 1
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 0
89896: PUSH
89897: LD_INT 1
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 1
89906: NEG
89907: PUSH
89908: LD_INT 0
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 1
89917: NEG
89918: PUSH
89919: LD_INT 1
89921: NEG
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 1
89929: PUSH
89930: LD_INT 2
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: LD_INT 2
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: LD_INT 1
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 2
89960: NEG
89961: PUSH
89962: LD_INT 0
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 2
89971: NEG
89972: PUSH
89973: LD_INT 1
89975: NEG
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89995: LD_ADDR_VAR 0 52
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: LD_INT 1
90015: NEG
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 1
90023: PUSH
90024: LD_INT 0
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 0
90043: PUSH
90044: LD_INT 1
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: LD_INT 1
90068: NEG
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 1
90076: NEG
90077: PUSH
90078: LD_INT 2
90080: NEG
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 1
90088: NEG
90089: PUSH
90090: LD_INT 1
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 2
90099: NEG
90100: PUSH
90101: LD_INT 0
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 2
90110: NEG
90111: PUSH
90112: LD_INT 1
90114: NEG
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: LD_INT 2
90126: NEG
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90146: LD_ADDR_VAR 0 53
90150: PUSH
90151: LD_INT 0
90153: PUSH
90154: LD_INT 0
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 0
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: LD_INT 1
90174: PUSH
90175: LD_INT 0
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: LD_INT 1
90184: PUSH
90185: LD_INT 1
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 0
90194: PUSH
90195: LD_INT 1
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: NEG
90205: PUSH
90206: LD_INT 0
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 1
90215: NEG
90216: PUSH
90217: LD_INT 1
90219: NEG
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: NEG
90228: PUSH
90229: LD_INT 2
90231: NEG
90232: PUSH
90233: EMPTY
90234: LIST
90235: LIST
90236: PUSH
90237: LD_INT 0
90239: PUSH
90240: LD_INT 2
90242: NEG
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 1
90250: PUSH
90251: LD_INT 1
90253: NEG
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 2
90261: PUSH
90262: LD_INT 0
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 2
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 2
90281: PUSH
90282: LD_INT 2
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 1
90291: PUSH
90292: LD_INT 2
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: LD_INT 2
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 1
90311: NEG
90312: PUSH
90313: LD_INT 1
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 2
90322: NEG
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 2
90333: NEG
90334: PUSH
90335: LD_INT 1
90337: NEG
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 2
90345: NEG
90346: PUSH
90347: LD_INT 2
90349: NEG
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90376: LD_ADDR_VAR 0 54
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: LD_INT 0
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: LD_INT 0
90393: PUSH
90394: LD_INT 1
90396: NEG
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 1
90404: PUSH
90405: LD_INT 0
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 1
90414: PUSH
90415: LD_INT 1
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 0
90424: PUSH
90425: LD_INT 1
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 1
90434: NEG
90435: PUSH
90436: LD_INT 0
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 1
90445: NEG
90446: PUSH
90447: LD_INT 1
90449: NEG
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: LD_INT 2
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 0
90469: PUSH
90470: LD_INT 2
90472: NEG
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: PUSH
90481: LD_INT 1
90483: NEG
90484: PUSH
90485: EMPTY
90486: LIST
90487: LIST
90488: PUSH
90489: LD_INT 2
90491: PUSH
90492: LD_INT 0
90494: PUSH
90495: EMPTY
90496: LIST
90497: LIST
90498: PUSH
90499: LD_INT 2
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 2
90511: PUSH
90512: LD_INT 2
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 1
90521: PUSH
90522: LD_INT 2
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 0
90531: PUSH
90532: LD_INT 2
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 1
90541: NEG
90542: PUSH
90543: LD_INT 1
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: LD_INT 2
90552: NEG
90553: PUSH
90554: LD_INT 0
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: LD_INT 2
90563: NEG
90564: PUSH
90565: LD_INT 1
90567: NEG
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 2
90575: NEG
90576: PUSH
90577: LD_INT 2
90579: NEG
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90606: LD_ADDR_VAR 0 55
90610: PUSH
90611: LD_INT 0
90613: PUSH
90614: LD_INT 0
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: LD_INT 1
90626: NEG
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 1
90634: PUSH
90635: LD_INT 0
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 1
90644: PUSH
90645: LD_INT 1
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 0
90654: PUSH
90655: LD_INT 1
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 1
90664: NEG
90665: PUSH
90666: LD_INT 0
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 1
90675: NEG
90676: PUSH
90677: LD_INT 1
90679: NEG
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: NEG
90688: PUSH
90689: LD_INT 2
90691: NEG
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 0
90699: PUSH
90700: LD_INT 2
90702: NEG
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: PUSH
90711: LD_INT 1
90713: NEG
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 2
90721: PUSH
90722: LD_INT 0
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 2
90731: PUSH
90732: LD_INT 1
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: LD_INT 2
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 1
90751: PUSH
90752: LD_INT 2
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 0
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: LD_INT 1
90775: PUSH
90776: EMPTY
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 2
90782: NEG
90783: PUSH
90784: LD_INT 0
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 2
90793: NEG
90794: PUSH
90795: LD_INT 1
90797: NEG
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 2
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: LIST
90824: LIST
90825: LIST
90826: LIST
90827: LIST
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90836: LD_ADDR_VAR 0 56
90840: PUSH
90841: LD_INT 0
90843: PUSH
90844: LD_INT 0
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 0
90853: PUSH
90854: LD_INT 1
90856: NEG
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: PUSH
90862: LD_INT 1
90864: PUSH
90865: LD_INT 0
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: LD_INT 1
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 0
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 1
90894: NEG
90895: PUSH
90896: LD_INT 0
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 1
90905: NEG
90906: PUSH
90907: LD_INT 1
90909: NEG
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 1
90917: NEG
90918: PUSH
90919: LD_INT 2
90921: NEG
90922: PUSH
90923: EMPTY
90924: LIST
90925: LIST
90926: PUSH
90927: LD_INT 0
90929: PUSH
90930: LD_INT 2
90932: NEG
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: PUSH
90941: LD_INT 1
90943: NEG
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 2
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 2
90961: PUSH
90962: LD_INT 1
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 2
90971: PUSH
90972: LD_INT 2
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PUSH
90979: LD_INT 1
90981: PUSH
90982: LD_INT 2
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 0
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 1
91001: NEG
91002: PUSH
91003: LD_INT 1
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 2
91012: NEG
91013: PUSH
91014: LD_INT 0
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: LD_INT 2
91023: NEG
91024: PUSH
91025: LD_INT 1
91027: NEG
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 2
91035: NEG
91036: PUSH
91037: LD_INT 2
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91066: LD_ADDR_VAR 0 57
91070: PUSH
91071: LD_INT 0
91073: PUSH
91074: LD_INT 0
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 0
91083: PUSH
91084: LD_INT 1
91086: NEG
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 1
91094: PUSH
91095: LD_INT 0
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 1
91104: PUSH
91105: LD_INT 1
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 0
91114: PUSH
91115: LD_INT 1
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 1
91124: NEG
91125: PUSH
91126: LD_INT 0
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: NEG
91136: PUSH
91137: LD_INT 1
91139: NEG
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 1
91147: NEG
91148: PUSH
91149: LD_INT 2
91151: NEG
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: LD_INT 0
91159: PUSH
91160: LD_INT 2
91162: NEG
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 1
91170: PUSH
91171: LD_INT 1
91173: NEG
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 2
91181: PUSH
91182: LD_INT 0
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 2
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 2
91201: PUSH
91202: LD_INT 2
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 1
91211: PUSH
91212: LD_INT 2
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 0
91221: PUSH
91222: LD_INT 2
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 1
91231: NEG
91232: PUSH
91233: LD_INT 1
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 2
91242: NEG
91243: PUSH
91244: LD_INT 0
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 2
91253: NEG
91254: PUSH
91255: LD_INT 1
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 2
91265: NEG
91266: PUSH
91267: LD_INT 2
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91296: LD_ADDR_VAR 0 58
91300: PUSH
91301: LD_INT 0
91303: PUSH
91304: LD_INT 0
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: LD_INT 1
91316: NEG
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: PUSH
91322: LD_INT 1
91324: PUSH
91325: LD_INT 0
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: PUSH
91332: LD_INT 1
91334: PUSH
91335: LD_INT 1
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: PUSH
91342: LD_INT 0
91344: PUSH
91345: LD_INT 1
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 1
91354: NEG
91355: PUSH
91356: LD_INT 0
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: LD_INT 1
91369: NEG
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: PUSH
91375: LD_INT 1
91377: NEG
91378: PUSH
91379: LD_INT 2
91381: NEG
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 0
91389: PUSH
91390: LD_INT 2
91392: NEG
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 1
91400: PUSH
91401: LD_INT 1
91403: NEG
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 2
91411: PUSH
91412: LD_INT 0
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 2
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 2
91431: PUSH
91432: LD_INT 2
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 1
91441: PUSH
91442: LD_INT 2
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 0
91451: PUSH
91452: LD_INT 2
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 1
91461: NEG
91462: PUSH
91463: LD_INT 1
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: LD_INT 2
91472: NEG
91473: PUSH
91474: LD_INT 0
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 2
91483: NEG
91484: PUSH
91485: LD_INT 1
91487: NEG
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 2
91495: NEG
91496: PUSH
91497: LD_INT 2
91499: NEG
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91526: LD_ADDR_VAR 0 59
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: LD_INT 0
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 0
91543: PUSH
91544: LD_INT 1
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 1
91554: PUSH
91555: LD_INT 0
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: LD_INT 1
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: LD_INT 1
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: NEG
91596: PUSH
91597: LD_INT 1
91599: NEG
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91614: LD_ADDR_VAR 0 60
91618: PUSH
91619: LD_INT 0
91621: PUSH
91622: LD_INT 0
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 0
91662: PUSH
91663: LD_INT 1
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 1
91672: NEG
91673: PUSH
91674: LD_INT 0
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 1
91683: NEG
91684: PUSH
91685: LD_INT 1
91687: NEG
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91702: LD_ADDR_VAR 0 61
91706: PUSH
91707: LD_INT 0
91709: PUSH
91710: LD_INT 0
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 0
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 1
91730: PUSH
91731: LD_INT 0
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 1
91740: PUSH
91741: LD_INT 1
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 0
91750: PUSH
91751: LD_INT 1
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 1
91760: NEG
91761: PUSH
91762: LD_INT 0
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: LD_INT 1
91775: NEG
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91790: LD_ADDR_VAR 0 62
91794: PUSH
91795: LD_INT 0
91797: PUSH
91798: LD_INT 0
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 0
91807: PUSH
91808: LD_INT 1
91810: NEG
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 1
91818: PUSH
91819: LD_INT 0
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: LD_INT 1
91828: PUSH
91829: LD_INT 1
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 0
91838: PUSH
91839: LD_INT 1
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 1
91848: NEG
91849: PUSH
91850: LD_INT 0
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 1
91859: NEG
91860: PUSH
91861: LD_INT 1
91863: NEG
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91878: LD_ADDR_VAR 0 63
91882: PUSH
91883: LD_INT 0
91885: PUSH
91886: LD_INT 0
91888: PUSH
91889: EMPTY
91890: LIST
91891: LIST
91892: PUSH
91893: LD_INT 0
91895: PUSH
91896: LD_INT 1
91898: NEG
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 1
91906: PUSH
91907: LD_INT 0
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 1
91916: PUSH
91917: LD_INT 1
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 0
91926: PUSH
91927: LD_INT 1
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PUSH
91934: LD_INT 1
91936: NEG
91937: PUSH
91938: LD_INT 0
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: LD_INT 1
91951: NEG
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91966: LD_ADDR_VAR 0 64
91970: PUSH
91971: LD_INT 0
91973: PUSH
91974: LD_INT 0
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 0
91983: PUSH
91984: LD_INT 1
91986: NEG
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: LD_INT 0
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 1
92004: PUSH
92005: LD_INT 1
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 0
92014: PUSH
92015: LD_INT 1
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 1
92024: NEG
92025: PUSH
92026: LD_INT 0
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: LD_INT 1
92039: NEG
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: PUSH
92045: EMPTY
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: ST_TO_ADDR
// end ; 1 :
92054: GO 97951
92056: LD_INT 1
92058: DOUBLE
92059: EQUAL
92060: IFTRUE 92064
92062: GO 94687
92064: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92065: LD_ADDR_VAR 0 11
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: LD_INT 3
92076: NEG
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 0
92084: PUSH
92085: LD_INT 3
92087: NEG
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: PUSH
92093: LD_INT 1
92095: PUSH
92096: LD_INT 2
92098: NEG
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: LIST
92108: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92109: LD_ADDR_VAR 0 12
92113: PUSH
92114: LD_INT 2
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 3
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 3
92137: PUSH
92138: LD_INT 1
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: LIST
92149: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92150: LD_ADDR_VAR 0 13
92154: PUSH
92155: LD_INT 3
92157: PUSH
92158: LD_INT 2
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 3
92167: PUSH
92168: LD_INT 3
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 2
92177: PUSH
92178: LD_INT 3
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: LIST
92189: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92190: LD_ADDR_VAR 0 14
92194: PUSH
92195: LD_INT 1
92197: PUSH
92198: LD_INT 3
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 0
92207: PUSH
92208: LD_INT 3
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: LD_INT 2
92221: PUSH
92222: EMPTY
92223: LIST
92224: LIST
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: LIST
92230: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92231: LD_ADDR_VAR 0 15
92235: PUSH
92236: LD_INT 2
92238: NEG
92239: PUSH
92240: LD_INT 1
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 3
92249: NEG
92250: PUSH
92251: LD_INT 0
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 3
92260: NEG
92261: PUSH
92262: LD_INT 1
92264: NEG
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: LIST
92274: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92275: LD_ADDR_VAR 0 16
92279: PUSH
92280: LD_INT 2
92282: NEG
92283: PUSH
92284: LD_INT 3
92286: NEG
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 3
92294: NEG
92295: PUSH
92296: LD_INT 2
92298: NEG
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 3
92306: NEG
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: LIST
92320: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92321: LD_ADDR_VAR 0 17
92325: PUSH
92326: LD_INT 1
92328: NEG
92329: PUSH
92330: LD_INT 3
92332: NEG
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: PUSH
92338: LD_INT 0
92340: PUSH
92341: LD_INT 3
92343: NEG
92344: PUSH
92345: EMPTY
92346: LIST
92347: LIST
92348: PUSH
92349: LD_INT 1
92351: PUSH
92352: LD_INT 2
92354: NEG
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: LIST
92364: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92365: LD_ADDR_VAR 0 18
92369: PUSH
92370: LD_INT 2
92372: PUSH
92373: LD_INT 1
92375: NEG
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 3
92383: PUSH
92384: LD_INT 0
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 3
92393: PUSH
92394: LD_INT 1
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: LIST
92405: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92406: LD_ADDR_VAR 0 19
92410: PUSH
92411: LD_INT 3
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 3
92423: PUSH
92424: LD_INT 3
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 2
92433: PUSH
92434: LD_INT 3
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: EMPTY
92442: LIST
92443: LIST
92444: LIST
92445: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92446: LD_ADDR_VAR 0 20
92450: PUSH
92451: LD_INT 1
92453: PUSH
92454: LD_INT 3
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 0
92463: PUSH
92464: LD_INT 3
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 1
92473: NEG
92474: PUSH
92475: LD_INT 2
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: LIST
92486: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92487: LD_ADDR_VAR 0 21
92491: PUSH
92492: LD_INT 2
92494: NEG
92495: PUSH
92496: LD_INT 1
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 3
92505: NEG
92506: PUSH
92507: LD_INT 0
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 3
92516: NEG
92517: PUSH
92518: LD_INT 1
92520: NEG
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: LIST
92530: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92531: LD_ADDR_VAR 0 22
92535: PUSH
92536: LD_INT 2
92538: NEG
92539: PUSH
92540: LD_INT 3
92542: NEG
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 3
92550: NEG
92551: PUSH
92552: LD_INT 2
92554: NEG
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 3
92562: NEG
92563: PUSH
92564: LD_INT 3
92566: NEG
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: LIST
92576: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92577: LD_ADDR_VAR 0 23
92581: PUSH
92582: LD_INT 0
92584: PUSH
92585: LD_INT 3
92587: NEG
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 1
92595: NEG
92596: PUSH
92597: LD_INT 4
92599: NEG
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 1
92607: PUSH
92608: LD_INT 3
92610: NEG
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: LIST
92620: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92621: LD_ADDR_VAR 0 24
92625: PUSH
92626: LD_INT 3
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 3
92638: PUSH
92639: LD_INT 1
92641: NEG
92642: PUSH
92643: EMPTY
92644: LIST
92645: LIST
92646: PUSH
92647: LD_INT 4
92649: PUSH
92650: LD_INT 1
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: LIST
92661: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92662: LD_ADDR_VAR 0 25
92666: PUSH
92667: LD_INT 3
92669: PUSH
92670: LD_INT 3
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 4
92679: PUSH
92680: LD_INT 3
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 3
92689: PUSH
92690: LD_INT 4
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: LIST
92701: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92702: LD_ADDR_VAR 0 26
92706: PUSH
92707: LD_INT 0
92709: PUSH
92710: LD_INT 3
92712: PUSH
92713: EMPTY
92714: LIST
92715: LIST
92716: PUSH
92717: LD_INT 1
92719: PUSH
92720: LD_INT 4
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 1
92729: NEG
92730: PUSH
92731: LD_INT 3
92733: PUSH
92734: EMPTY
92735: LIST
92736: LIST
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: LIST
92742: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92743: LD_ADDR_VAR 0 27
92747: PUSH
92748: LD_INT 3
92750: NEG
92751: PUSH
92752: LD_INT 0
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 3
92761: NEG
92762: PUSH
92763: LD_INT 1
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: PUSH
92770: LD_INT 4
92772: NEG
92773: PUSH
92774: LD_INT 1
92776: NEG
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: LIST
92786: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92787: LD_ADDR_VAR 0 28
92791: PUSH
92792: LD_INT 3
92794: NEG
92795: PUSH
92796: LD_INT 3
92798: NEG
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 3
92806: NEG
92807: PUSH
92808: LD_INT 4
92810: NEG
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 4
92818: NEG
92819: PUSH
92820: LD_INT 3
92822: NEG
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: LIST
92832: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92833: LD_ADDR_VAR 0 29
92837: PUSH
92838: LD_INT 1
92840: NEG
92841: PUSH
92842: LD_INT 3
92844: NEG
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 0
92852: PUSH
92853: LD_INT 3
92855: NEG
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: PUSH
92864: LD_INT 2
92866: NEG
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 1
92874: NEG
92875: PUSH
92876: LD_INT 4
92878: NEG
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 0
92886: PUSH
92887: LD_INT 4
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 1
92897: PUSH
92898: LD_INT 3
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 1
92908: NEG
92909: PUSH
92910: LD_INT 5
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 0
92920: PUSH
92921: LD_INT 5
92923: NEG
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 1
92931: PUSH
92932: LD_INT 4
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 1
92942: NEG
92943: PUSH
92944: LD_INT 6
92946: NEG
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 0
92954: PUSH
92955: LD_INT 6
92957: NEG
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 1
92965: PUSH
92966: LD_INT 5
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92988: LD_ADDR_VAR 0 30
92992: PUSH
92993: LD_INT 2
92995: PUSH
92996: LD_INT 1
92998: NEG
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: PUSH
93004: LD_INT 3
93006: PUSH
93007: LD_INT 0
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 3
93016: PUSH
93017: LD_INT 1
93019: PUSH
93020: EMPTY
93021: LIST
93022: LIST
93023: PUSH
93024: LD_INT 3
93026: PUSH
93027: LD_INT 1
93029: NEG
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 4
93037: PUSH
93038: LD_INT 0
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 4
93047: PUSH
93048: LD_INT 1
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 4
93057: PUSH
93058: LD_INT 1
93060: NEG
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 5
93068: PUSH
93069: LD_INT 0
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PUSH
93076: LD_INT 5
93078: PUSH
93079: LD_INT 1
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 5
93088: PUSH
93089: LD_INT 1
93091: NEG
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 6
93099: PUSH
93100: LD_INT 0
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 6
93109: PUSH
93110: LD_INT 1
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: PUSH
93117: EMPTY
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93131: LD_ADDR_VAR 0 31
93135: PUSH
93136: LD_INT 3
93138: PUSH
93139: LD_INT 2
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 3
93148: PUSH
93149: LD_INT 3
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 2
93158: PUSH
93159: LD_INT 3
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 4
93168: PUSH
93169: LD_INT 3
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 4
93178: PUSH
93179: LD_INT 4
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 3
93188: PUSH
93189: LD_INT 4
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 5
93198: PUSH
93199: LD_INT 4
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 5
93208: PUSH
93209: LD_INT 5
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 4
93218: PUSH
93219: LD_INT 5
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 6
93228: PUSH
93229: LD_INT 5
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 6
93238: PUSH
93239: LD_INT 6
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 5
93248: PUSH
93249: LD_INT 6
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: LIST
93268: LIST
93269: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93270: LD_ADDR_VAR 0 32
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: LD_INT 3
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 0
93287: PUSH
93288: LD_INT 3
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 1
93297: NEG
93298: PUSH
93299: LD_INT 2
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: LD_INT 4
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 0
93318: PUSH
93319: LD_INT 4
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: PUSH
93326: LD_INT 1
93328: NEG
93329: PUSH
93330: LD_INT 3
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 1
93339: PUSH
93340: LD_INT 5
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 0
93349: PUSH
93350: LD_INT 5
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: PUSH
93357: LD_INT 1
93359: NEG
93360: PUSH
93361: LD_INT 4
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 1
93370: PUSH
93371: LD_INT 6
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: LD_INT 6
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: LD_INT 5
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93413: LD_ADDR_VAR 0 33
93417: PUSH
93418: LD_INT 2
93420: NEG
93421: PUSH
93422: LD_INT 1
93424: PUSH
93425: EMPTY
93426: LIST
93427: LIST
93428: PUSH
93429: LD_INT 3
93431: NEG
93432: PUSH
93433: LD_INT 0
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 3
93442: NEG
93443: PUSH
93444: LD_INT 1
93446: NEG
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 3
93454: NEG
93455: PUSH
93456: LD_INT 1
93458: PUSH
93459: EMPTY
93460: LIST
93461: LIST
93462: PUSH
93463: LD_INT 4
93465: NEG
93466: PUSH
93467: LD_INT 0
93469: PUSH
93470: EMPTY
93471: LIST
93472: LIST
93473: PUSH
93474: LD_INT 4
93476: NEG
93477: PUSH
93478: LD_INT 1
93480: NEG
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 4
93488: NEG
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 5
93499: NEG
93500: PUSH
93501: LD_INT 0
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 5
93510: NEG
93511: PUSH
93512: LD_INT 1
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 5
93522: NEG
93523: PUSH
93524: LD_INT 1
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 6
93533: NEG
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 6
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: NEG
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93568: LD_ADDR_VAR 0 34
93572: PUSH
93573: LD_INT 2
93575: NEG
93576: PUSH
93577: LD_INT 3
93579: NEG
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PUSH
93585: LD_INT 3
93587: NEG
93588: PUSH
93589: LD_INT 2
93591: NEG
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 3
93599: NEG
93600: PUSH
93601: LD_INT 3
93603: NEG
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 3
93611: NEG
93612: PUSH
93613: LD_INT 4
93615: NEG
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 4
93623: NEG
93624: PUSH
93625: LD_INT 3
93627: NEG
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 4
93635: NEG
93636: PUSH
93637: LD_INT 4
93639: NEG
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 4
93647: NEG
93648: PUSH
93649: LD_INT 5
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 5
93659: NEG
93660: PUSH
93661: LD_INT 4
93663: NEG
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 5
93671: NEG
93672: PUSH
93673: LD_INT 5
93675: NEG
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 5
93683: NEG
93684: PUSH
93685: LD_INT 6
93687: NEG
93688: PUSH
93689: EMPTY
93690: LIST
93691: LIST
93692: PUSH
93693: LD_INT 6
93695: NEG
93696: PUSH
93697: LD_INT 5
93699: NEG
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: PUSH
93705: LD_INT 6
93707: NEG
93708: PUSH
93709: LD_INT 6
93711: NEG
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93731: LD_ADDR_VAR 0 41
93735: PUSH
93736: LD_INT 0
93738: PUSH
93739: LD_INT 2
93741: NEG
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 1
93749: NEG
93750: PUSH
93751: LD_INT 3
93753: NEG
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 1
93761: PUSH
93762: LD_INT 2
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: LIST
93774: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93775: LD_ADDR_VAR 0 42
93779: PUSH
93780: LD_INT 2
93782: PUSH
93783: LD_INT 0
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: PUSH
93790: LD_INT 2
93792: PUSH
93793: LD_INT 1
93795: NEG
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 3
93803: PUSH
93804: LD_INT 1
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: LIST
93815: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93816: LD_ADDR_VAR 0 43
93820: PUSH
93821: LD_INT 2
93823: PUSH
93824: LD_INT 2
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 3
93833: PUSH
93834: LD_INT 2
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: LD_INT 2
93843: PUSH
93844: LD_INT 3
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: LIST
93855: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93856: LD_ADDR_VAR 0 44
93860: PUSH
93861: LD_INT 0
93863: PUSH
93864: LD_INT 2
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 1
93873: PUSH
93874: LD_INT 3
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 1
93883: NEG
93884: PUSH
93885: LD_INT 2
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: LIST
93896: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93897: LD_ADDR_VAR 0 45
93901: PUSH
93902: LD_INT 2
93904: NEG
93905: PUSH
93906: LD_INT 0
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 2
93915: NEG
93916: PUSH
93917: LD_INT 1
93919: PUSH
93920: EMPTY
93921: LIST
93922: LIST
93923: PUSH
93924: LD_INT 3
93926: NEG
93927: PUSH
93928: LD_INT 1
93930: NEG
93931: PUSH
93932: EMPTY
93933: LIST
93934: LIST
93935: PUSH
93936: EMPTY
93937: LIST
93938: LIST
93939: LIST
93940: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93941: LD_ADDR_VAR 0 46
93945: PUSH
93946: LD_INT 2
93948: NEG
93949: PUSH
93950: LD_INT 2
93952: NEG
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 2
93960: NEG
93961: PUSH
93962: LD_INT 3
93964: NEG
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: PUSH
93970: LD_INT 3
93972: NEG
93973: PUSH
93974: LD_INT 2
93976: NEG
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: LIST
93986: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93987: LD_ADDR_VAR 0 47
93991: PUSH
93992: LD_INT 2
93994: NEG
93995: PUSH
93996: LD_INT 3
93998: NEG
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 1
94006: NEG
94007: PUSH
94008: LD_INT 3
94010: NEG
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: PUSH
94016: EMPTY
94017: LIST
94018: LIST
94019: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94020: LD_ADDR_VAR 0 48
94024: PUSH
94025: LD_INT 1
94027: PUSH
94028: LD_INT 2
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 2
94038: PUSH
94039: LD_INT 1
94041: NEG
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94051: LD_ADDR_VAR 0 49
94055: PUSH
94056: LD_INT 3
94058: PUSH
94059: LD_INT 1
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 3
94068: PUSH
94069: LD_INT 2
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94080: LD_ADDR_VAR 0 50
94084: PUSH
94085: LD_INT 2
94087: PUSH
94088: LD_INT 3
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 1
94097: PUSH
94098: LD_INT 3
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94109: LD_ADDR_VAR 0 51
94113: PUSH
94114: LD_INT 1
94116: NEG
94117: PUSH
94118: LD_INT 2
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 2
94127: NEG
94128: PUSH
94129: LD_INT 1
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94140: LD_ADDR_VAR 0 52
94144: PUSH
94145: LD_INT 3
94147: NEG
94148: PUSH
94149: LD_INT 1
94151: NEG
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: PUSH
94157: LD_INT 3
94159: NEG
94160: PUSH
94161: LD_INT 2
94163: NEG
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94173: LD_ADDR_VAR 0 53
94177: PUSH
94178: LD_INT 1
94180: NEG
94181: PUSH
94182: LD_INT 3
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 0
94192: PUSH
94193: LD_INT 3
94195: NEG
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 1
94203: PUSH
94204: LD_INT 2
94206: NEG
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: LIST
94216: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94217: LD_ADDR_VAR 0 54
94221: PUSH
94222: LD_INT 2
94224: PUSH
94225: LD_INT 1
94227: NEG
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 3
94235: PUSH
94236: LD_INT 0
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 3
94245: PUSH
94246: LD_INT 1
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: EMPTY
94254: LIST
94255: LIST
94256: LIST
94257: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94258: LD_ADDR_VAR 0 55
94262: PUSH
94263: LD_INT 3
94265: PUSH
94266: LD_INT 2
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 3
94275: PUSH
94276: LD_INT 3
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 2
94285: PUSH
94286: LD_INT 3
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: LIST
94297: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94298: LD_ADDR_VAR 0 56
94302: PUSH
94303: LD_INT 1
94305: PUSH
94306: LD_INT 3
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: PUSH
94313: LD_INT 0
94315: PUSH
94316: LD_INT 3
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 1
94325: NEG
94326: PUSH
94327: LD_INT 2
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: LIST
94338: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94339: LD_ADDR_VAR 0 57
94343: PUSH
94344: LD_INT 2
94346: NEG
94347: PUSH
94348: LD_INT 1
94350: PUSH
94351: EMPTY
94352: LIST
94353: LIST
94354: PUSH
94355: LD_INT 3
94357: NEG
94358: PUSH
94359: LD_INT 0
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 3
94368: NEG
94369: PUSH
94370: LD_INT 1
94372: NEG
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: LIST
94382: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94383: LD_ADDR_VAR 0 58
94387: PUSH
94388: LD_INT 2
94390: NEG
94391: PUSH
94392: LD_INT 3
94394: NEG
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 3
94402: NEG
94403: PUSH
94404: LD_INT 2
94406: NEG
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 3
94414: NEG
94415: PUSH
94416: LD_INT 3
94418: NEG
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: LIST
94428: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94429: LD_ADDR_VAR 0 59
94433: PUSH
94434: LD_INT 1
94436: NEG
94437: PUSH
94438: LD_INT 2
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: LD_INT 2
94451: NEG
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 1
94459: PUSH
94460: LD_INT 1
94462: NEG
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: LIST
94472: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94473: LD_ADDR_VAR 0 60
94477: PUSH
94478: LD_INT 1
94480: PUSH
94481: LD_INT 1
94483: NEG
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 2
94491: PUSH
94492: LD_INT 0
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 2
94501: PUSH
94502: LD_INT 1
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: LIST
94513: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94514: LD_ADDR_VAR 0 61
94518: PUSH
94519: LD_INT 2
94521: PUSH
94522: LD_INT 1
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 2
94531: PUSH
94532: LD_INT 2
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 1
94541: PUSH
94542: LD_INT 2
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: LIST
94553: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94554: LD_ADDR_VAR 0 62
94558: PUSH
94559: LD_INT 1
94561: PUSH
94562: LD_INT 2
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 0
94571: PUSH
94572: LD_INT 2
94574: PUSH
94575: EMPTY
94576: LIST
94577: LIST
94578: PUSH
94579: LD_INT 1
94581: NEG
94582: PUSH
94583: LD_INT 1
94585: PUSH
94586: EMPTY
94587: LIST
94588: LIST
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: LIST
94594: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94595: LD_ADDR_VAR 0 63
94599: PUSH
94600: LD_INT 1
94602: NEG
94603: PUSH
94604: LD_INT 1
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: PUSH
94611: LD_INT 2
94613: NEG
94614: PUSH
94615: LD_INT 0
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 2
94624: NEG
94625: PUSH
94626: LD_INT 1
94628: NEG
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: LIST
94638: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94639: LD_ADDR_VAR 0 64
94643: PUSH
94644: LD_INT 1
94646: NEG
94647: PUSH
94648: LD_INT 2
94650: NEG
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 2
94658: NEG
94659: PUSH
94660: LD_INT 1
94662: NEG
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 2
94670: NEG
94671: PUSH
94672: LD_INT 2
94674: NEG
94675: PUSH
94676: EMPTY
94677: LIST
94678: LIST
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: LIST
94684: ST_TO_ADDR
// end ; 2 :
94685: GO 97951
94687: LD_INT 2
94689: DOUBLE
94690: EQUAL
94691: IFTRUE 94695
94693: GO 97950
94695: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94696: LD_ADDR_VAR 0 29
94700: PUSH
94701: LD_INT 4
94703: PUSH
94704: LD_INT 0
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 4
94713: PUSH
94714: LD_INT 1
94716: NEG
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PUSH
94722: LD_INT 5
94724: PUSH
94725: LD_INT 0
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 5
94734: PUSH
94735: LD_INT 1
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 4
94744: PUSH
94745: LD_INT 1
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 3
94754: PUSH
94755: LD_INT 0
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 3
94764: PUSH
94765: LD_INT 1
94767: NEG
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 3
94775: PUSH
94776: LD_INT 2
94778: NEG
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: LD_INT 5
94786: PUSH
94787: LD_INT 2
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 3
94796: PUSH
94797: LD_INT 3
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: LD_INT 2
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 4
94816: PUSH
94817: LD_INT 3
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 4
94826: PUSH
94827: LD_INT 4
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 3
94836: PUSH
94837: LD_INT 4
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 2
94846: PUSH
94847: LD_INT 3
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: LD_INT 2
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 4
94866: PUSH
94867: LD_INT 2
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 2
94876: PUSH
94877: LD_INT 4
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 0
94886: PUSH
94887: LD_INT 4
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 0
94896: PUSH
94897: LD_INT 3
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 1
94906: PUSH
94907: LD_INT 4
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: PUSH
94917: LD_INT 5
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 0
94926: PUSH
94927: LD_INT 5
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 1
94936: NEG
94937: PUSH
94938: LD_INT 4
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 1
94947: NEG
94948: PUSH
94949: LD_INT 3
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 2
94958: PUSH
94959: LD_INT 5
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 2
94968: NEG
94969: PUSH
94970: LD_INT 3
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 3
94979: NEG
94980: PUSH
94981: LD_INT 0
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 3
94990: NEG
94991: PUSH
94992: LD_INT 1
94994: NEG
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 2
95002: NEG
95003: PUSH
95004: LD_INT 0
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 2
95013: NEG
95014: PUSH
95015: LD_INT 1
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 3
95024: NEG
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 4
95035: NEG
95036: PUSH
95037: LD_INT 0
95039: PUSH
95040: EMPTY
95041: LIST
95042: LIST
95043: PUSH
95044: LD_INT 4
95046: NEG
95047: PUSH
95048: LD_INT 1
95050: NEG
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 4
95058: NEG
95059: PUSH
95060: LD_INT 2
95062: NEG
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 2
95070: NEG
95071: PUSH
95072: LD_INT 2
95074: PUSH
95075: EMPTY
95076: LIST
95077: LIST
95078: PUSH
95079: LD_INT 4
95081: NEG
95082: PUSH
95083: LD_INT 4
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 4
95093: NEG
95094: PUSH
95095: LD_INT 5
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 3
95105: NEG
95106: PUSH
95107: LD_INT 4
95109: NEG
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: LD_INT 3
95117: NEG
95118: PUSH
95119: LD_INT 3
95121: NEG
95122: PUSH
95123: EMPTY
95124: LIST
95125: LIST
95126: PUSH
95127: LD_INT 4
95129: NEG
95130: PUSH
95131: LD_INT 3
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 5
95141: NEG
95142: PUSH
95143: LD_INT 4
95145: NEG
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 5
95153: NEG
95154: PUSH
95155: LD_INT 5
95157: NEG
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 3
95165: NEG
95166: PUSH
95167: LD_INT 5
95169: NEG
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 5
95177: NEG
95178: PUSH
95179: LD_INT 3
95181: NEG
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95234: LD_ADDR_VAR 0 30
95238: PUSH
95239: LD_INT 4
95241: PUSH
95242: LD_INT 4
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: PUSH
95249: LD_INT 4
95251: PUSH
95252: LD_INT 3
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 5
95261: PUSH
95262: LD_INT 4
95264: PUSH
95265: EMPTY
95266: LIST
95267: LIST
95268: PUSH
95269: LD_INT 5
95271: PUSH
95272: LD_INT 5
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 4
95281: PUSH
95282: LD_INT 5
95284: PUSH
95285: EMPTY
95286: LIST
95287: LIST
95288: PUSH
95289: LD_INT 3
95291: PUSH
95292: LD_INT 4
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 3
95301: PUSH
95302: LD_INT 3
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 5
95311: PUSH
95312: LD_INT 3
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PUSH
95319: LD_INT 3
95321: PUSH
95322: LD_INT 5
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: PUSH
95329: LD_INT 0
95331: PUSH
95332: LD_INT 3
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: PUSH
95339: LD_INT 0
95341: PUSH
95342: LD_INT 2
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 1
95351: PUSH
95352: LD_INT 3
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 1
95361: PUSH
95362: LD_INT 4
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 0
95371: PUSH
95372: LD_INT 4
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 1
95381: NEG
95382: PUSH
95383: LD_INT 3
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: PUSH
95390: LD_INT 1
95392: NEG
95393: PUSH
95394: LD_INT 2
95396: PUSH
95397: EMPTY
95398: LIST
95399: LIST
95400: PUSH
95401: LD_INT 2
95403: PUSH
95404: LD_INT 4
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: PUSH
95411: LD_INT 2
95413: NEG
95414: PUSH
95415: LD_INT 2
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 4
95424: NEG
95425: PUSH
95426: LD_INT 0
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: PUSH
95433: LD_INT 4
95435: NEG
95436: PUSH
95437: LD_INT 1
95439: NEG
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: PUSH
95445: LD_INT 3
95447: NEG
95448: PUSH
95449: LD_INT 0
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 3
95458: NEG
95459: PUSH
95460: LD_INT 1
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: PUSH
95467: LD_INT 4
95469: NEG
95470: PUSH
95471: LD_INT 1
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: LD_INT 5
95480: NEG
95481: PUSH
95482: LD_INT 0
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: PUSH
95489: LD_INT 5
95491: NEG
95492: PUSH
95493: LD_INT 1
95495: NEG
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 5
95503: NEG
95504: PUSH
95505: LD_INT 2
95507: NEG
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 3
95515: NEG
95516: PUSH
95517: LD_INT 2
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 3
95526: NEG
95527: PUSH
95528: LD_INT 3
95530: NEG
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: PUSH
95536: LD_INT 3
95538: NEG
95539: PUSH
95540: LD_INT 4
95542: NEG
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 2
95550: NEG
95551: PUSH
95552: LD_INT 3
95554: NEG
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 2
95562: NEG
95563: PUSH
95564: LD_INT 2
95566: NEG
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 3
95574: NEG
95575: PUSH
95576: LD_INT 2
95578: NEG
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 4
95586: NEG
95587: PUSH
95588: LD_INT 3
95590: NEG
95591: PUSH
95592: EMPTY
95593: LIST
95594: LIST
95595: PUSH
95596: LD_INT 4
95598: NEG
95599: PUSH
95600: LD_INT 4
95602: NEG
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: PUSH
95608: LD_INT 2
95610: NEG
95611: PUSH
95612: LD_INT 4
95614: NEG
95615: PUSH
95616: EMPTY
95617: LIST
95618: LIST
95619: PUSH
95620: LD_INT 4
95622: NEG
95623: PUSH
95624: LD_INT 2
95626: NEG
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 0
95634: PUSH
95635: LD_INT 4
95637: NEG
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: LD_INT 0
95645: PUSH
95646: LD_INT 5
95648: NEG
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 1
95656: PUSH
95657: LD_INT 4
95659: NEG
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 1
95667: PUSH
95668: LD_INT 3
95670: NEG
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 0
95678: PUSH
95679: LD_INT 3
95681: NEG
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 1
95689: NEG
95690: PUSH
95691: LD_INT 4
95693: NEG
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 1
95701: NEG
95702: PUSH
95703: LD_INT 5
95705: NEG
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: LD_INT 2
95713: PUSH
95714: LD_INT 3
95716: NEG
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 2
95724: NEG
95725: PUSH
95726: LD_INT 5
95728: NEG
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95781: LD_ADDR_VAR 0 31
95785: PUSH
95786: LD_INT 0
95788: PUSH
95789: LD_INT 4
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 0
95798: PUSH
95799: LD_INT 3
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 1
95808: PUSH
95809: LD_INT 4
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 1
95818: PUSH
95819: LD_INT 5
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 0
95828: PUSH
95829: LD_INT 5
95831: PUSH
95832: EMPTY
95833: LIST
95834: LIST
95835: PUSH
95836: LD_INT 1
95838: NEG
95839: PUSH
95840: LD_INT 4
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 1
95849: NEG
95850: PUSH
95851: LD_INT 3
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PUSH
95858: LD_INT 2
95860: PUSH
95861: LD_INT 5
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: PUSH
95868: LD_INT 2
95870: NEG
95871: PUSH
95872: LD_INT 3
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 3
95881: NEG
95882: PUSH
95883: LD_INT 0
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: PUSH
95890: LD_INT 3
95892: NEG
95893: PUSH
95894: LD_INT 1
95896: NEG
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: PUSH
95902: LD_INT 2
95904: NEG
95905: PUSH
95906: LD_INT 0
95908: PUSH
95909: EMPTY
95910: LIST
95911: LIST
95912: PUSH
95913: LD_INT 2
95915: NEG
95916: PUSH
95917: LD_INT 1
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: PUSH
95924: LD_INT 3
95926: NEG
95927: PUSH
95928: LD_INT 1
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 4
95937: NEG
95938: PUSH
95939: LD_INT 0
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: LD_INT 4
95948: NEG
95949: PUSH
95950: LD_INT 1
95952: NEG
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: PUSH
95958: LD_INT 4
95960: NEG
95961: PUSH
95962: LD_INT 2
95964: NEG
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 2
95972: NEG
95973: PUSH
95974: LD_INT 2
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 4
95983: NEG
95984: PUSH
95985: LD_INT 4
95987: NEG
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 4
95995: NEG
95996: PUSH
95997: LD_INT 5
95999: NEG
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 3
96007: NEG
96008: PUSH
96009: LD_INT 4
96011: NEG
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 3
96019: NEG
96020: PUSH
96021: LD_INT 3
96023: NEG
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 4
96031: NEG
96032: PUSH
96033: LD_INT 3
96035: NEG
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 5
96043: NEG
96044: PUSH
96045: LD_INT 4
96047: NEG
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 5
96055: NEG
96056: PUSH
96057: LD_INT 5
96059: NEG
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 3
96067: NEG
96068: PUSH
96069: LD_INT 5
96071: NEG
96072: PUSH
96073: EMPTY
96074: LIST
96075: LIST
96076: PUSH
96077: LD_INT 5
96079: NEG
96080: PUSH
96081: LD_INT 3
96083: NEG
96084: PUSH
96085: EMPTY
96086: LIST
96087: LIST
96088: PUSH
96089: LD_INT 0
96091: PUSH
96092: LD_INT 3
96094: NEG
96095: PUSH
96096: EMPTY
96097: LIST
96098: LIST
96099: PUSH
96100: LD_INT 0
96102: PUSH
96103: LD_INT 4
96105: NEG
96106: PUSH
96107: EMPTY
96108: LIST
96109: LIST
96110: PUSH
96111: LD_INT 1
96113: PUSH
96114: LD_INT 3
96116: NEG
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: PUSH
96122: LD_INT 1
96124: PUSH
96125: LD_INT 2
96127: NEG
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 0
96135: PUSH
96136: LD_INT 2
96138: NEG
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: PUSH
96144: LD_INT 1
96146: NEG
96147: PUSH
96148: LD_INT 3
96150: NEG
96151: PUSH
96152: EMPTY
96153: LIST
96154: LIST
96155: PUSH
96156: LD_INT 1
96158: NEG
96159: PUSH
96160: LD_INT 4
96162: NEG
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: PUSH
96168: LD_INT 2
96170: PUSH
96171: LD_INT 2
96173: NEG
96174: PUSH
96175: EMPTY
96176: LIST
96177: LIST
96178: PUSH
96179: LD_INT 2
96181: NEG
96182: PUSH
96183: LD_INT 4
96185: NEG
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 4
96193: PUSH
96194: LD_INT 0
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 4
96203: PUSH
96204: LD_INT 1
96206: NEG
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PUSH
96212: LD_INT 5
96214: PUSH
96215: LD_INT 0
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PUSH
96222: LD_INT 5
96224: PUSH
96225: LD_INT 1
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 4
96234: PUSH
96235: LD_INT 1
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 3
96244: PUSH
96245: LD_INT 0
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 3
96254: PUSH
96255: LD_INT 1
96257: NEG
96258: PUSH
96259: EMPTY
96260: LIST
96261: LIST
96262: PUSH
96263: LD_INT 3
96265: PUSH
96266: LD_INT 2
96268: NEG
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 5
96276: PUSH
96277: LD_INT 2
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96331: LD_ADDR_VAR 0 32
96335: PUSH
96336: LD_INT 4
96338: NEG
96339: PUSH
96340: LD_INT 0
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 4
96349: NEG
96350: PUSH
96351: LD_INT 1
96353: NEG
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 3
96361: NEG
96362: PUSH
96363: LD_INT 0
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PUSH
96370: LD_INT 3
96372: NEG
96373: PUSH
96374: LD_INT 1
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 4
96383: NEG
96384: PUSH
96385: LD_INT 1
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 5
96394: NEG
96395: PUSH
96396: LD_INT 0
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 5
96405: NEG
96406: PUSH
96407: LD_INT 1
96409: NEG
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: LD_INT 5
96417: NEG
96418: PUSH
96419: LD_INT 2
96421: NEG
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: PUSH
96427: LD_INT 3
96429: NEG
96430: PUSH
96431: LD_INT 2
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: LD_INT 3
96440: NEG
96441: PUSH
96442: LD_INT 3
96444: NEG
96445: PUSH
96446: EMPTY
96447: LIST
96448: LIST
96449: PUSH
96450: LD_INT 3
96452: NEG
96453: PUSH
96454: LD_INT 4
96456: NEG
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 2
96464: NEG
96465: PUSH
96466: LD_INT 3
96468: NEG
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 2
96476: NEG
96477: PUSH
96478: LD_INT 2
96480: NEG
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 3
96488: NEG
96489: PUSH
96490: LD_INT 2
96492: NEG
96493: PUSH
96494: EMPTY
96495: LIST
96496: LIST
96497: PUSH
96498: LD_INT 4
96500: NEG
96501: PUSH
96502: LD_INT 3
96504: NEG
96505: PUSH
96506: EMPTY
96507: LIST
96508: LIST
96509: PUSH
96510: LD_INT 4
96512: NEG
96513: PUSH
96514: LD_INT 4
96516: NEG
96517: PUSH
96518: EMPTY
96519: LIST
96520: LIST
96521: PUSH
96522: LD_INT 2
96524: NEG
96525: PUSH
96526: LD_INT 4
96528: NEG
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: PUSH
96534: LD_INT 4
96536: NEG
96537: PUSH
96538: LD_INT 2
96540: NEG
96541: PUSH
96542: EMPTY
96543: LIST
96544: LIST
96545: PUSH
96546: LD_INT 0
96548: PUSH
96549: LD_INT 4
96551: NEG
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 0
96559: PUSH
96560: LD_INT 5
96562: NEG
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: PUSH
96568: LD_INT 1
96570: PUSH
96571: LD_INT 4
96573: NEG
96574: PUSH
96575: EMPTY
96576: LIST
96577: LIST
96578: PUSH
96579: LD_INT 1
96581: PUSH
96582: LD_INT 3
96584: NEG
96585: PUSH
96586: EMPTY
96587: LIST
96588: LIST
96589: PUSH
96590: LD_INT 0
96592: PUSH
96593: LD_INT 3
96595: NEG
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: LD_INT 1
96603: NEG
96604: PUSH
96605: LD_INT 4
96607: NEG
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: LD_INT 1
96615: NEG
96616: PUSH
96617: LD_INT 5
96619: NEG
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: LD_INT 3
96630: NEG
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 2
96638: NEG
96639: PUSH
96640: LD_INT 5
96642: NEG
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 3
96650: PUSH
96651: LD_INT 0
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 3
96660: PUSH
96661: LD_INT 1
96663: NEG
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 4
96671: PUSH
96672: LD_INT 0
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: LD_INT 4
96681: PUSH
96682: LD_INT 1
96684: PUSH
96685: EMPTY
96686: LIST
96687: LIST
96688: PUSH
96689: LD_INT 3
96691: PUSH
96692: LD_INT 1
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: PUSH
96699: LD_INT 2
96701: PUSH
96702: LD_INT 0
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: PUSH
96709: LD_INT 2
96711: PUSH
96712: LD_INT 1
96714: NEG
96715: PUSH
96716: EMPTY
96717: LIST
96718: LIST
96719: PUSH
96720: LD_INT 2
96722: PUSH
96723: LD_INT 2
96725: NEG
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 4
96733: PUSH
96734: LD_INT 2
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 4
96743: PUSH
96744: LD_INT 4
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 4
96753: PUSH
96754: LD_INT 3
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: PUSH
96761: LD_INT 5
96763: PUSH
96764: LD_INT 4
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 5
96773: PUSH
96774: LD_INT 5
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 4
96783: PUSH
96784: LD_INT 5
96786: PUSH
96787: EMPTY
96788: LIST
96789: LIST
96790: PUSH
96791: LD_INT 3
96793: PUSH
96794: LD_INT 4
96796: PUSH
96797: EMPTY
96798: LIST
96799: LIST
96800: PUSH
96801: LD_INT 3
96803: PUSH
96804: LD_INT 3
96806: PUSH
96807: EMPTY
96808: LIST
96809: LIST
96810: PUSH
96811: LD_INT 5
96813: PUSH
96814: LD_INT 3
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 3
96823: PUSH
96824: LD_INT 5
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96878: LD_ADDR_VAR 0 33
96882: PUSH
96883: LD_INT 4
96885: NEG
96886: PUSH
96887: LD_INT 4
96889: NEG
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 4
96897: NEG
96898: PUSH
96899: LD_INT 5
96901: NEG
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 3
96909: NEG
96910: PUSH
96911: LD_INT 4
96913: NEG
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 3
96921: NEG
96922: PUSH
96923: LD_INT 3
96925: NEG
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 4
96933: NEG
96934: PUSH
96935: LD_INT 3
96937: NEG
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 5
96945: NEG
96946: PUSH
96947: LD_INT 4
96949: NEG
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 5
96957: NEG
96958: PUSH
96959: LD_INT 5
96961: NEG
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: LD_INT 3
96969: NEG
96970: PUSH
96971: LD_INT 5
96973: NEG
96974: PUSH
96975: EMPTY
96976: LIST
96977: LIST
96978: PUSH
96979: LD_INT 5
96981: NEG
96982: PUSH
96983: LD_INT 3
96985: NEG
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 0
96993: PUSH
96994: LD_INT 3
96996: NEG
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: PUSH
97002: LD_INT 0
97004: PUSH
97005: LD_INT 4
97007: NEG
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: LD_INT 1
97015: PUSH
97016: LD_INT 3
97018: NEG
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: LD_INT 1
97026: PUSH
97027: LD_INT 2
97029: NEG
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PUSH
97035: LD_INT 0
97037: PUSH
97038: LD_INT 2
97040: NEG
97041: PUSH
97042: EMPTY
97043: LIST
97044: LIST
97045: PUSH
97046: LD_INT 1
97048: NEG
97049: PUSH
97050: LD_INT 3
97052: NEG
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: PUSH
97058: LD_INT 1
97060: NEG
97061: PUSH
97062: LD_INT 4
97064: NEG
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_INT 2
97072: PUSH
97073: LD_INT 2
97075: NEG
97076: PUSH
97077: EMPTY
97078: LIST
97079: LIST
97080: PUSH
97081: LD_INT 2
97083: NEG
97084: PUSH
97085: LD_INT 4
97087: NEG
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PUSH
97093: LD_INT 4
97095: PUSH
97096: LD_INT 0
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PUSH
97103: LD_INT 4
97105: PUSH
97106: LD_INT 1
97108: NEG
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 5
97116: PUSH
97117: LD_INT 0
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 5
97126: PUSH
97127: LD_INT 1
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: PUSH
97134: LD_INT 4
97136: PUSH
97137: LD_INT 1
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PUSH
97144: LD_INT 3
97146: PUSH
97147: LD_INT 0
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PUSH
97154: LD_INT 3
97156: PUSH
97157: LD_INT 1
97159: NEG
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 3
97167: PUSH
97168: LD_INT 2
97170: NEG
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 5
97178: PUSH
97179: LD_INT 2
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 3
97188: PUSH
97189: LD_INT 3
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 3
97198: PUSH
97199: LD_INT 2
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 4
97208: PUSH
97209: LD_INT 3
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 4
97218: PUSH
97219: LD_INT 4
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 3
97228: PUSH
97229: LD_INT 4
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 2
97238: PUSH
97239: LD_INT 3
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 2
97248: PUSH
97249: LD_INT 2
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 4
97258: PUSH
97259: LD_INT 2
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 2
97268: PUSH
97269: LD_INT 4
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 0
97278: PUSH
97279: LD_INT 4
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 0
97288: PUSH
97289: LD_INT 3
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 1
97298: PUSH
97299: LD_INT 4
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 1
97308: PUSH
97309: LD_INT 5
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 0
97318: PUSH
97319: LD_INT 5
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 1
97328: NEG
97329: PUSH
97330: LD_INT 4
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 1
97339: NEG
97340: PUSH
97341: LD_INT 3
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 2
97350: PUSH
97351: LD_INT 5
97353: PUSH
97354: EMPTY
97355: LIST
97356: LIST
97357: PUSH
97358: LD_INT 2
97360: NEG
97361: PUSH
97362: LD_INT 3
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97416: LD_ADDR_VAR 0 34
97420: PUSH
97421: LD_INT 0
97423: PUSH
97424: LD_INT 4
97426: NEG
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: PUSH
97432: LD_INT 0
97434: PUSH
97435: LD_INT 5
97437: NEG
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: PUSH
97443: LD_INT 1
97445: PUSH
97446: LD_INT 4
97448: NEG
97449: PUSH
97450: EMPTY
97451: LIST
97452: LIST
97453: PUSH
97454: LD_INT 1
97456: PUSH
97457: LD_INT 3
97459: NEG
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: PUSH
97465: LD_INT 0
97467: PUSH
97468: LD_INT 3
97470: NEG
97471: PUSH
97472: EMPTY
97473: LIST
97474: LIST
97475: PUSH
97476: LD_INT 1
97478: NEG
97479: PUSH
97480: LD_INT 4
97482: NEG
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 1
97490: NEG
97491: PUSH
97492: LD_INT 5
97494: NEG
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 2
97502: PUSH
97503: LD_INT 3
97505: NEG
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 2
97513: NEG
97514: PUSH
97515: LD_INT 5
97517: NEG
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: LD_INT 3
97525: PUSH
97526: LD_INT 0
97528: PUSH
97529: EMPTY
97530: LIST
97531: LIST
97532: PUSH
97533: LD_INT 3
97535: PUSH
97536: LD_INT 1
97538: NEG
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: PUSH
97544: LD_INT 4
97546: PUSH
97547: LD_INT 0
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 4
97556: PUSH
97557: LD_INT 1
97559: PUSH
97560: EMPTY
97561: LIST
97562: LIST
97563: PUSH
97564: LD_INT 3
97566: PUSH
97567: LD_INT 1
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: PUSH
97574: LD_INT 2
97576: PUSH
97577: LD_INT 0
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: PUSH
97584: LD_INT 2
97586: PUSH
97587: LD_INT 1
97589: NEG
97590: PUSH
97591: EMPTY
97592: LIST
97593: LIST
97594: PUSH
97595: LD_INT 2
97597: PUSH
97598: LD_INT 2
97600: NEG
97601: PUSH
97602: EMPTY
97603: LIST
97604: LIST
97605: PUSH
97606: LD_INT 4
97608: PUSH
97609: LD_INT 2
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 4
97618: PUSH
97619: LD_INT 4
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: PUSH
97626: LD_INT 4
97628: PUSH
97629: LD_INT 3
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: PUSH
97636: LD_INT 5
97638: PUSH
97639: LD_INT 4
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: PUSH
97646: LD_INT 5
97648: PUSH
97649: LD_INT 5
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PUSH
97656: LD_INT 4
97658: PUSH
97659: LD_INT 5
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PUSH
97666: LD_INT 3
97668: PUSH
97669: LD_INT 4
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 3
97678: PUSH
97679: LD_INT 3
97681: PUSH
97682: EMPTY
97683: LIST
97684: LIST
97685: PUSH
97686: LD_INT 5
97688: PUSH
97689: LD_INT 3
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 3
97698: PUSH
97699: LD_INT 5
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: LD_INT 0
97708: PUSH
97709: LD_INT 3
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: PUSH
97716: LD_INT 0
97718: PUSH
97719: LD_INT 2
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 1
97728: PUSH
97729: LD_INT 3
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: PUSH
97736: LD_INT 1
97738: PUSH
97739: LD_INT 4
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: PUSH
97746: LD_INT 0
97748: PUSH
97749: LD_INT 4
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 1
97758: NEG
97759: PUSH
97760: LD_INT 3
97762: PUSH
97763: EMPTY
97764: LIST
97765: LIST
97766: PUSH
97767: LD_INT 1
97769: NEG
97770: PUSH
97771: LD_INT 2
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 2
97780: PUSH
97781: LD_INT 4
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 2
97790: NEG
97791: PUSH
97792: LD_INT 2
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PUSH
97799: LD_INT 4
97801: NEG
97802: PUSH
97803: LD_INT 0
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 4
97812: NEG
97813: PUSH
97814: LD_INT 1
97816: NEG
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: LD_INT 3
97824: NEG
97825: PUSH
97826: LD_INT 0
97828: PUSH
97829: EMPTY
97830: LIST
97831: LIST
97832: PUSH
97833: LD_INT 3
97835: NEG
97836: PUSH
97837: LD_INT 1
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: PUSH
97844: LD_INT 4
97846: NEG
97847: PUSH
97848: LD_INT 1
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 5
97857: NEG
97858: PUSH
97859: LD_INT 0
97861: PUSH
97862: EMPTY
97863: LIST
97864: LIST
97865: PUSH
97866: LD_INT 5
97868: NEG
97869: PUSH
97870: LD_INT 1
97872: NEG
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: LD_INT 5
97880: NEG
97881: PUSH
97882: LD_INT 2
97884: NEG
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 3
97892: NEG
97893: PUSH
97894: LD_INT 2
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: PUSH
97901: EMPTY
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: ST_TO_ADDR
// end ; end ;
97948: GO 97951
97950: POP
// case btype of b_depot , b_warehouse :
97951: LD_VAR 0 1
97955: PUSH
97956: LD_INT 0
97958: DOUBLE
97959: EQUAL
97960: IFTRUE 97970
97962: LD_INT 1
97964: DOUBLE
97965: EQUAL
97966: IFTRUE 97970
97968: GO 98171
97970: POP
// case nation of nation_american :
97971: LD_VAR 0 5
97975: PUSH
97976: LD_INT 1
97978: DOUBLE
97979: EQUAL
97980: IFTRUE 97984
97982: GO 98040
97984: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97985: LD_ADDR_VAR 0 9
97989: PUSH
97990: LD_VAR 0 11
97994: PUSH
97995: LD_VAR 0 12
97999: PUSH
98000: LD_VAR 0 13
98004: PUSH
98005: LD_VAR 0 14
98009: PUSH
98010: LD_VAR 0 15
98014: PUSH
98015: LD_VAR 0 16
98019: PUSH
98020: EMPTY
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: PUSH
98028: LD_VAR 0 4
98032: PUSH
98033: LD_INT 1
98035: PLUS
98036: ARRAY
98037: ST_TO_ADDR
98038: GO 98169
98040: LD_INT 2
98042: DOUBLE
98043: EQUAL
98044: IFTRUE 98048
98046: GO 98104
98048: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98049: LD_ADDR_VAR 0 9
98053: PUSH
98054: LD_VAR 0 17
98058: PUSH
98059: LD_VAR 0 18
98063: PUSH
98064: LD_VAR 0 19
98068: PUSH
98069: LD_VAR 0 20
98073: PUSH
98074: LD_VAR 0 21
98078: PUSH
98079: LD_VAR 0 22
98083: PUSH
98084: EMPTY
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: PUSH
98092: LD_VAR 0 4
98096: PUSH
98097: LD_INT 1
98099: PLUS
98100: ARRAY
98101: ST_TO_ADDR
98102: GO 98169
98104: LD_INT 3
98106: DOUBLE
98107: EQUAL
98108: IFTRUE 98112
98110: GO 98168
98112: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98113: LD_ADDR_VAR 0 9
98117: PUSH
98118: LD_VAR 0 23
98122: PUSH
98123: LD_VAR 0 24
98127: PUSH
98128: LD_VAR 0 25
98132: PUSH
98133: LD_VAR 0 26
98137: PUSH
98138: LD_VAR 0 27
98142: PUSH
98143: LD_VAR 0 28
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: PUSH
98156: LD_VAR 0 4
98160: PUSH
98161: LD_INT 1
98163: PLUS
98164: ARRAY
98165: ST_TO_ADDR
98166: GO 98169
98168: POP
98169: GO 98724
98171: LD_INT 2
98173: DOUBLE
98174: EQUAL
98175: IFTRUE 98185
98177: LD_INT 3
98179: DOUBLE
98180: EQUAL
98181: IFTRUE 98185
98183: GO 98241
98185: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98186: LD_ADDR_VAR 0 9
98190: PUSH
98191: LD_VAR 0 29
98195: PUSH
98196: LD_VAR 0 30
98200: PUSH
98201: LD_VAR 0 31
98205: PUSH
98206: LD_VAR 0 32
98210: PUSH
98211: LD_VAR 0 33
98215: PUSH
98216: LD_VAR 0 34
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: LIST
98225: LIST
98226: LIST
98227: LIST
98228: PUSH
98229: LD_VAR 0 4
98233: PUSH
98234: LD_INT 1
98236: PLUS
98237: ARRAY
98238: ST_TO_ADDR
98239: GO 98724
98241: LD_INT 16
98243: DOUBLE
98244: EQUAL
98245: IFTRUE 98303
98247: LD_INT 17
98249: DOUBLE
98250: EQUAL
98251: IFTRUE 98303
98253: LD_INT 18
98255: DOUBLE
98256: EQUAL
98257: IFTRUE 98303
98259: LD_INT 19
98261: DOUBLE
98262: EQUAL
98263: IFTRUE 98303
98265: LD_INT 22
98267: DOUBLE
98268: EQUAL
98269: IFTRUE 98303
98271: LD_INT 20
98273: DOUBLE
98274: EQUAL
98275: IFTRUE 98303
98277: LD_INT 21
98279: DOUBLE
98280: EQUAL
98281: IFTRUE 98303
98283: LD_INT 23
98285: DOUBLE
98286: EQUAL
98287: IFTRUE 98303
98289: LD_INT 24
98291: DOUBLE
98292: EQUAL
98293: IFTRUE 98303
98295: LD_INT 25
98297: DOUBLE
98298: EQUAL
98299: IFTRUE 98303
98301: GO 98359
98303: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98304: LD_ADDR_VAR 0 9
98308: PUSH
98309: LD_VAR 0 35
98313: PUSH
98314: LD_VAR 0 36
98318: PUSH
98319: LD_VAR 0 37
98323: PUSH
98324: LD_VAR 0 38
98328: PUSH
98329: LD_VAR 0 39
98333: PUSH
98334: LD_VAR 0 40
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: PUSH
98347: LD_VAR 0 4
98351: PUSH
98352: LD_INT 1
98354: PLUS
98355: ARRAY
98356: ST_TO_ADDR
98357: GO 98724
98359: LD_INT 6
98361: DOUBLE
98362: EQUAL
98363: IFTRUE 98415
98365: LD_INT 7
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98415
98371: LD_INT 8
98373: DOUBLE
98374: EQUAL
98375: IFTRUE 98415
98377: LD_INT 13
98379: DOUBLE
98380: EQUAL
98381: IFTRUE 98415
98383: LD_INT 12
98385: DOUBLE
98386: EQUAL
98387: IFTRUE 98415
98389: LD_INT 15
98391: DOUBLE
98392: EQUAL
98393: IFTRUE 98415
98395: LD_INT 11
98397: DOUBLE
98398: EQUAL
98399: IFTRUE 98415
98401: LD_INT 14
98403: DOUBLE
98404: EQUAL
98405: IFTRUE 98415
98407: LD_INT 10
98409: DOUBLE
98410: EQUAL
98411: IFTRUE 98415
98413: GO 98471
98415: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98416: LD_ADDR_VAR 0 9
98420: PUSH
98421: LD_VAR 0 41
98425: PUSH
98426: LD_VAR 0 42
98430: PUSH
98431: LD_VAR 0 43
98435: PUSH
98436: LD_VAR 0 44
98440: PUSH
98441: LD_VAR 0 45
98445: PUSH
98446: LD_VAR 0 46
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: PUSH
98459: LD_VAR 0 4
98463: PUSH
98464: LD_INT 1
98466: PLUS
98467: ARRAY
98468: ST_TO_ADDR
98469: GO 98724
98471: LD_INT 36
98473: DOUBLE
98474: EQUAL
98475: IFTRUE 98479
98477: GO 98535
98479: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98480: LD_ADDR_VAR 0 9
98484: PUSH
98485: LD_VAR 0 47
98489: PUSH
98490: LD_VAR 0 48
98494: PUSH
98495: LD_VAR 0 49
98499: PUSH
98500: LD_VAR 0 50
98504: PUSH
98505: LD_VAR 0 51
98509: PUSH
98510: LD_VAR 0 52
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: PUSH
98523: LD_VAR 0 4
98527: PUSH
98528: LD_INT 1
98530: PLUS
98531: ARRAY
98532: ST_TO_ADDR
98533: GO 98724
98535: LD_INT 4
98537: DOUBLE
98538: EQUAL
98539: IFTRUE 98561
98541: LD_INT 5
98543: DOUBLE
98544: EQUAL
98545: IFTRUE 98561
98547: LD_INT 34
98549: DOUBLE
98550: EQUAL
98551: IFTRUE 98561
98553: LD_INT 37
98555: DOUBLE
98556: EQUAL
98557: IFTRUE 98561
98559: GO 98617
98561: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98562: LD_ADDR_VAR 0 9
98566: PUSH
98567: LD_VAR 0 53
98571: PUSH
98572: LD_VAR 0 54
98576: PUSH
98577: LD_VAR 0 55
98581: PUSH
98582: LD_VAR 0 56
98586: PUSH
98587: LD_VAR 0 57
98591: PUSH
98592: LD_VAR 0 58
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: PUSH
98605: LD_VAR 0 4
98609: PUSH
98610: LD_INT 1
98612: PLUS
98613: ARRAY
98614: ST_TO_ADDR
98615: GO 98724
98617: LD_INT 31
98619: DOUBLE
98620: EQUAL
98621: IFTRUE 98667
98623: LD_INT 32
98625: DOUBLE
98626: EQUAL
98627: IFTRUE 98667
98629: LD_INT 33
98631: DOUBLE
98632: EQUAL
98633: IFTRUE 98667
98635: LD_INT 27
98637: DOUBLE
98638: EQUAL
98639: IFTRUE 98667
98641: LD_INT 26
98643: DOUBLE
98644: EQUAL
98645: IFTRUE 98667
98647: LD_INT 28
98649: DOUBLE
98650: EQUAL
98651: IFTRUE 98667
98653: LD_INT 29
98655: DOUBLE
98656: EQUAL
98657: IFTRUE 98667
98659: LD_INT 30
98661: DOUBLE
98662: EQUAL
98663: IFTRUE 98667
98665: GO 98723
98667: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98668: LD_ADDR_VAR 0 9
98672: PUSH
98673: LD_VAR 0 59
98677: PUSH
98678: LD_VAR 0 60
98682: PUSH
98683: LD_VAR 0 61
98687: PUSH
98688: LD_VAR 0 62
98692: PUSH
98693: LD_VAR 0 63
98697: PUSH
98698: LD_VAR 0 64
98702: PUSH
98703: EMPTY
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: PUSH
98711: LD_VAR 0 4
98715: PUSH
98716: LD_INT 1
98718: PLUS
98719: ARRAY
98720: ST_TO_ADDR
98721: GO 98724
98723: POP
// temp_list2 = [ ] ;
98724: LD_ADDR_VAR 0 10
98728: PUSH
98729: EMPTY
98730: ST_TO_ADDR
// for i in temp_list do
98731: LD_ADDR_VAR 0 8
98735: PUSH
98736: LD_VAR 0 9
98740: PUSH
98741: FOR_IN
98742: IFFALSE 98794
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98744: LD_ADDR_VAR 0 10
98748: PUSH
98749: LD_VAR 0 10
98753: PUSH
98754: LD_VAR 0 8
98758: PUSH
98759: LD_INT 1
98761: ARRAY
98762: PUSH
98763: LD_VAR 0 2
98767: PLUS
98768: PUSH
98769: LD_VAR 0 8
98773: PUSH
98774: LD_INT 2
98776: ARRAY
98777: PUSH
98778: LD_VAR 0 3
98782: PLUS
98783: PUSH
98784: EMPTY
98785: LIST
98786: LIST
98787: PUSH
98788: EMPTY
98789: LIST
98790: ADD
98791: ST_TO_ADDR
98792: GO 98741
98794: POP
98795: POP
// result = temp_list2 ;
98796: LD_ADDR_VAR 0 7
98800: PUSH
98801: LD_VAR 0 10
98805: ST_TO_ADDR
// end ;
98806: LD_VAR 0 7
98810: RET
// export function EnemyInRange ( unit , dist ) ; begin
98811: LD_INT 0
98813: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98814: LD_ADDR_VAR 0 3
98818: PUSH
98819: LD_VAR 0 1
98823: PPUSH
98824: CALL_OW 255
98828: PPUSH
98829: LD_VAR 0 1
98833: PPUSH
98834: CALL_OW 250
98838: PPUSH
98839: LD_VAR 0 1
98843: PPUSH
98844: CALL_OW 251
98848: PPUSH
98849: LD_VAR 0 2
98853: PPUSH
98854: CALL 72915 0 4
98858: PUSH
98859: LD_INT 4
98861: ARRAY
98862: ST_TO_ADDR
// end ;
98863: LD_VAR 0 3
98867: RET
// export function PlayerSeeMe ( unit ) ; begin
98868: LD_INT 0
98870: PPUSH
// result := See ( your_side , unit ) ;
98871: LD_ADDR_VAR 0 2
98875: PUSH
98876: LD_OWVAR 2
98880: PPUSH
98881: LD_VAR 0 1
98885: PPUSH
98886: CALL_OW 292
98890: ST_TO_ADDR
// end ;
98891: LD_VAR 0 2
98895: RET
// export function ReverseDir ( unit ) ; begin
98896: LD_INT 0
98898: PPUSH
// if not unit then
98899: LD_VAR 0 1
98903: NOT
98904: IFFALSE 98908
// exit ;
98906: GO 98931
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98908: LD_ADDR_VAR 0 2
98912: PUSH
98913: LD_VAR 0 1
98917: PPUSH
98918: CALL_OW 254
98922: PUSH
98923: LD_INT 3
98925: PLUS
98926: PUSH
98927: LD_INT 6
98929: MOD
98930: ST_TO_ADDR
// end ;
98931: LD_VAR 0 2
98935: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98936: LD_INT 0
98938: PPUSH
98939: PPUSH
98940: PPUSH
98941: PPUSH
98942: PPUSH
// if not hexes then
98943: LD_VAR 0 2
98947: NOT
98948: IFFALSE 98952
// exit ;
98950: GO 99100
// dist := 9999 ;
98952: LD_ADDR_VAR 0 5
98956: PUSH
98957: LD_INT 9999
98959: ST_TO_ADDR
// for i = 1 to hexes do
98960: LD_ADDR_VAR 0 4
98964: PUSH
98965: DOUBLE
98966: LD_INT 1
98968: DEC
98969: ST_TO_ADDR
98970: LD_VAR 0 2
98974: PUSH
98975: FOR_TO
98976: IFFALSE 99088
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98978: LD_VAR 0 1
98982: PPUSH
98983: LD_VAR 0 2
98987: PUSH
98988: LD_VAR 0 4
98992: ARRAY
98993: PUSH
98994: LD_INT 1
98996: ARRAY
98997: PPUSH
98998: LD_VAR 0 2
99002: PUSH
99003: LD_VAR 0 4
99007: ARRAY
99008: PUSH
99009: LD_INT 2
99011: ARRAY
99012: PPUSH
99013: CALL_OW 297
99017: PUSH
99018: LD_VAR 0 5
99022: LESS
99023: IFFALSE 99086
// begin hex := hexes [ i ] ;
99025: LD_ADDR_VAR 0 7
99029: PUSH
99030: LD_VAR 0 2
99034: PUSH
99035: LD_VAR 0 4
99039: ARRAY
99040: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99041: LD_ADDR_VAR 0 5
99045: PUSH
99046: LD_VAR 0 1
99050: PPUSH
99051: LD_VAR 0 2
99055: PUSH
99056: LD_VAR 0 4
99060: ARRAY
99061: PUSH
99062: LD_INT 1
99064: ARRAY
99065: PPUSH
99066: LD_VAR 0 2
99070: PUSH
99071: LD_VAR 0 4
99075: ARRAY
99076: PUSH
99077: LD_INT 2
99079: ARRAY
99080: PPUSH
99081: CALL_OW 297
99085: ST_TO_ADDR
// end ; end ;
99086: GO 98975
99088: POP
99089: POP
// result := hex ;
99090: LD_ADDR_VAR 0 3
99094: PUSH
99095: LD_VAR 0 7
99099: ST_TO_ADDR
// end ;
99100: LD_VAR 0 3
99104: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99105: LD_INT 0
99107: PPUSH
99108: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99109: LD_VAR 0 1
99113: NOT
99114: PUSH
99115: LD_VAR 0 1
99119: PUSH
99120: LD_INT 21
99122: PUSH
99123: LD_INT 2
99125: PUSH
99126: EMPTY
99127: LIST
99128: LIST
99129: PUSH
99130: LD_INT 23
99132: PUSH
99133: LD_INT 2
99135: PUSH
99136: EMPTY
99137: LIST
99138: LIST
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PPUSH
99144: CALL_OW 69
99148: IN
99149: NOT
99150: OR
99151: IFFALSE 99155
// exit ;
99153: GO 99202
// for i = 1 to 3 do
99155: LD_ADDR_VAR 0 3
99159: PUSH
99160: DOUBLE
99161: LD_INT 1
99163: DEC
99164: ST_TO_ADDR
99165: LD_INT 3
99167: PUSH
99168: FOR_TO
99169: IFFALSE 99200
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99171: LD_VAR 0 1
99175: PPUSH
99176: CALL_OW 250
99180: PPUSH
99181: LD_VAR 0 1
99185: PPUSH
99186: CALL_OW 251
99190: PPUSH
99191: LD_INT 1
99193: PPUSH
99194: CALL_OW 453
99198: GO 99168
99200: POP
99201: POP
// end ;
99202: LD_VAR 0 2
99206: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99207: LD_INT 0
99209: PPUSH
99210: PPUSH
99211: PPUSH
99212: PPUSH
99213: PPUSH
99214: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99215: LD_VAR 0 1
99219: NOT
99220: PUSH
99221: LD_VAR 0 2
99225: NOT
99226: OR
99227: PUSH
99228: LD_VAR 0 1
99232: PPUSH
99233: CALL_OW 314
99237: OR
99238: IFFALSE 99242
// exit ;
99240: GO 99683
// x := GetX ( enemy_unit ) ;
99242: LD_ADDR_VAR 0 7
99246: PUSH
99247: LD_VAR 0 2
99251: PPUSH
99252: CALL_OW 250
99256: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99257: LD_ADDR_VAR 0 8
99261: PUSH
99262: LD_VAR 0 2
99266: PPUSH
99267: CALL_OW 251
99271: ST_TO_ADDR
// if not x or not y then
99272: LD_VAR 0 7
99276: NOT
99277: PUSH
99278: LD_VAR 0 8
99282: NOT
99283: OR
99284: IFFALSE 99288
// exit ;
99286: GO 99683
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99288: LD_ADDR_VAR 0 6
99292: PUSH
99293: LD_VAR 0 7
99297: PPUSH
99298: LD_INT 0
99300: PPUSH
99301: LD_INT 4
99303: PPUSH
99304: CALL_OW 272
99308: PUSH
99309: LD_VAR 0 8
99313: PPUSH
99314: LD_INT 0
99316: PPUSH
99317: LD_INT 4
99319: PPUSH
99320: CALL_OW 273
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: PUSH
99329: LD_VAR 0 7
99333: PPUSH
99334: LD_INT 1
99336: PPUSH
99337: LD_INT 4
99339: PPUSH
99340: CALL_OW 272
99344: PUSH
99345: LD_VAR 0 8
99349: PPUSH
99350: LD_INT 1
99352: PPUSH
99353: LD_INT 4
99355: PPUSH
99356: CALL_OW 273
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: PUSH
99365: LD_VAR 0 7
99369: PPUSH
99370: LD_INT 2
99372: PPUSH
99373: LD_INT 4
99375: PPUSH
99376: CALL_OW 272
99380: PUSH
99381: LD_VAR 0 8
99385: PPUSH
99386: LD_INT 2
99388: PPUSH
99389: LD_INT 4
99391: PPUSH
99392: CALL_OW 273
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: PUSH
99401: LD_VAR 0 7
99405: PPUSH
99406: LD_INT 3
99408: PPUSH
99409: LD_INT 4
99411: PPUSH
99412: CALL_OW 272
99416: PUSH
99417: LD_VAR 0 8
99421: PPUSH
99422: LD_INT 3
99424: PPUSH
99425: LD_INT 4
99427: PPUSH
99428: CALL_OW 273
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: LD_VAR 0 7
99441: PPUSH
99442: LD_INT 4
99444: PPUSH
99445: LD_INT 4
99447: PPUSH
99448: CALL_OW 272
99452: PUSH
99453: LD_VAR 0 8
99457: PPUSH
99458: LD_INT 4
99460: PPUSH
99461: LD_INT 4
99463: PPUSH
99464: CALL_OW 273
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: PUSH
99473: LD_VAR 0 7
99477: PPUSH
99478: LD_INT 5
99480: PPUSH
99481: LD_INT 4
99483: PPUSH
99484: CALL_OW 272
99488: PUSH
99489: LD_VAR 0 8
99493: PPUSH
99494: LD_INT 5
99496: PPUSH
99497: LD_INT 4
99499: PPUSH
99500: CALL_OW 273
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: ST_TO_ADDR
// for i = tmp downto 1 do
99517: LD_ADDR_VAR 0 4
99521: PUSH
99522: DOUBLE
99523: LD_VAR 0 6
99527: INC
99528: ST_TO_ADDR
99529: LD_INT 1
99531: PUSH
99532: FOR_DOWNTO
99533: IFFALSE 99634
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99535: LD_VAR 0 6
99539: PUSH
99540: LD_VAR 0 4
99544: ARRAY
99545: PUSH
99546: LD_INT 1
99548: ARRAY
99549: PPUSH
99550: LD_VAR 0 6
99554: PUSH
99555: LD_VAR 0 4
99559: ARRAY
99560: PUSH
99561: LD_INT 2
99563: ARRAY
99564: PPUSH
99565: CALL_OW 488
99569: NOT
99570: PUSH
99571: LD_VAR 0 6
99575: PUSH
99576: LD_VAR 0 4
99580: ARRAY
99581: PUSH
99582: LD_INT 1
99584: ARRAY
99585: PPUSH
99586: LD_VAR 0 6
99590: PUSH
99591: LD_VAR 0 4
99595: ARRAY
99596: PUSH
99597: LD_INT 2
99599: ARRAY
99600: PPUSH
99601: CALL_OW 428
99605: PUSH
99606: LD_INT 0
99608: NONEQUAL
99609: OR
99610: IFFALSE 99632
// tmp := Delete ( tmp , i ) ;
99612: LD_ADDR_VAR 0 6
99616: PUSH
99617: LD_VAR 0 6
99621: PPUSH
99622: LD_VAR 0 4
99626: PPUSH
99627: CALL_OW 3
99631: ST_TO_ADDR
99632: GO 99532
99634: POP
99635: POP
// j := GetClosestHex ( unit , tmp ) ;
99636: LD_ADDR_VAR 0 5
99640: PUSH
99641: LD_VAR 0 1
99645: PPUSH
99646: LD_VAR 0 6
99650: PPUSH
99651: CALL 98936 0 2
99655: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99656: LD_VAR 0 1
99660: PPUSH
99661: LD_VAR 0 5
99665: PUSH
99666: LD_INT 1
99668: ARRAY
99669: PPUSH
99670: LD_VAR 0 5
99674: PUSH
99675: LD_INT 2
99677: ARRAY
99678: PPUSH
99679: CALL_OW 111
// end ;
99683: LD_VAR 0 3
99687: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99688: LD_INT 0
99690: PPUSH
99691: PPUSH
99692: PPUSH
// uc_side = 0 ;
99693: LD_ADDR_OWVAR 20
99697: PUSH
99698: LD_INT 0
99700: ST_TO_ADDR
// uc_nation = 0 ;
99701: LD_ADDR_OWVAR 21
99705: PUSH
99706: LD_INT 0
99708: ST_TO_ADDR
// InitHc ;
99709: CALL_OW 19
// InitVc ;
99713: CALL_OW 20
// if mastodonts then
99717: LD_VAR 0 6
99721: IFFALSE 99788
// for i = 1 to mastodonts do
99723: LD_ADDR_VAR 0 11
99727: PUSH
99728: DOUBLE
99729: LD_INT 1
99731: DEC
99732: ST_TO_ADDR
99733: LD_VAR 0 6
99737: PUSH
99738: FOR_TO
99739: IFFALSE 99786
// begin vc_chassis := 31 ;
99741: LD_ADDR_OWVAR 37
99745: PUSH
99746: LD_INT 31
99748: ST_TO_ADDR
// vc_control := control_rider ;
99749: LD_ADDR_OWVAR 38
99753: PUSH
99754: LD_INT 4
99756: ST_TO_ADDR
// animal := CreateVehicle ;
99757: LD_ADDR_VAR 0 12
99761: PUSH
99762: CALL_OW 45
99766: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99767: LD_VAR 0 12
99771: PPUSH
99772: LD_VAR 0 8
99776: PPUSH
99777: LD_INT 0
99779: PPUSH
99780: CALL 106566 0 3
// end ;
99784: GO 99738
99786: POP
99787: POP
// if horses then
99788: LD_VAR 0 5
99792: IFFALSE 99859
// for i = 1 to horses do
99794: LD_ADDR_VAR 0 11
99798: PUSH
99799: DOUBLE
99800: LD_INT 1
99802: DEC
99803: ST_TO_ADDR
99804: LD_VAR 0 5
99808: PUSH
99809: FOR_TO
99810: IFFALSE 99857
// begin hc_class := 21 ;
99812: LD_ADDR_OWVAR 28
99816: PUSH
99817: LD_INT 21
99819: ST_TO_ADDR
// hc_gallery :=  ;
99820: LD_ADDR_OWVAR 33
99824: PUSH
99825: LD_STRING 
99827: ST_TO_ADDR
// animal := CreateHuman ;
99828: LD_ADDR_VAR 0 12
99832: PUSH
99833: CALL_OW 44
99837: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99838: LD_VAR 0 12
99842: PPUSH
99843: LD_VAR 0 8
99847: PPUSH
99848: LD_INT 0
99850: PPUSH
99851: CALL 106566 0 3
// end ;
99855: GO 99809
99857: POP
99858: POP
// if birds then
99859: LD_VAR 0 1
99863: IFFALSE 99930
// for i = 1 to birds do
99865: LD_ADDR_VAR 0 11
99869: PUSH
99870: DOUBLE
99871: LD_INT 1
99873: DEC
99874: ST_TO_ADDR
99875: LD_VAR 0 1
99879: PUSH
99880: FOR_TO
99881: IFFALSE 99928
// begin hc_class = 18 ;
99883: LD_ADDR_OWVAR 28
99887: PUSH
99888: LD_INT 18
99890: ST_TO_ADDR
// hc_gallery =  ;
99891: LD_ADDR_OWVAR 33
99895: PUSH
99896: LD_STRING 
99898: ST_TO_ADDR
// animal := CreateHuman ;
99899: LD_ADDR_VAR 0 12
99903: PUSH
99904: CALL_OW 44
99908: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99909: LD_VAR 0 12
99913: PPUSH
99914: LD_VAR 0 8
99918: PPUSH
99919: LD_INT 0
99921: PPUSH
99922: CALL 106566 0 3
// end ;
99926: GO 99880
99928: POP
99929: POP
// if tigers then
99930: LD_VAR 0 2
99934: IFFALSE 100018
// for i = 1 to tigers do
99936: LD_ADDR_VAR 0 11
99940: PUSH
99941: DOUBLE
99942: LD_INT 1
99944: DEC
99945: ST_TO_ADDR
99946: LD_VAR 0 2
99950: PUSH
99951: FOR_TO
99952: IFFALSE 100016
// begin hc_class = class_tiger ;
99954: LD_ADDR_OWVAR 28
99958: PUSH
99959: LD_INT 14
99961: ST_TO_ADDR
// hc_gallery =  ;
99962: LD_ADDR_OWVAR 33
99966: PUSH
99967: LD_STRING 
99969: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99970: LD_ADDR_OWVAR 35
99974: PUSH
99975: LD_INT 7
99977: NEG
99978: PPUSH
99979: LD_INT 7
99981: PPUSH
99982: CALL_OW 12
99986: ST_TO_ADDR
// animal := CreateHuman ;
99987: LD_ADDR_VAR 0 12
99991: PUSH
99992: CALL_OW 44
99996: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99997: LD_VAR 0 12
100001: PPUSH
100002: LD_VAR 0 8
100006: PPUSH
100007: LD_INT 0
100009: PPUSH
100010: CALL 106566 0 3
// end ;
100014: GO 99951
100016: POP
100017: POP
// if apemans then
100018: LD_VAR 0 3
100022: IFFALSE 100145
// for i = 1 to apemans do
100024: LD_ADDR_VAR 0 11
100028: PUSH
100029: DOUBLE
100030: LD_INT 1
100032: DEC
100033: ST_TO_ADDR
100034: LD_VAR 0 3
100038: PUSH
100039: FOR_TO
100040: IFFALSE 100143
// begin hc_class = class_apeman ;
100042: LD_ADDR_OWVAR 28
100046: PUSH
100047: LD_INT 12
100049: ST_TO_ADDR
// hc_gallery =  ;
100050: LD_ADDR_OWVAR 33
100054: PUSH
100055: LD_STRING 
100057: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100058: LD_ADDR_OWVAR 35
100062: PUSH
100063: LD_INT 5
100065: NEG
100066: PPUSH
100067: LD_INT 5
100069: PPUSH
100070: CALL_OW 12
100074: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100075: LD_ADDR_OWVAR 31
100079: PUSH
100080: LD_INT 1
100082: PPUSH
100083: LD_INT 3
100085: PPUSH
100086: CALL_OW 12
100090: PUSH
100091: LD_INT 1
100093: PPUSH
100094: LD_INT 3
100096: PPUSH
100097: CALL_OW 12
100101: PUSH
100102: LD_INT 0
100104: PUSH
100105: LD_INT 0
100107: PUSH
100108: EMPTY
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: ST_TO_ADDR
// animal := CreateHuman ;
100114: LD_ADDR_VAR 0 12
100118: PUSH
100119: CALL_OW 44
100123: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100124: LD_VAR 0 12
100128: PPUSH
100129: LD_VAR 0 8
100133: PPUSH
100134: LD_INT 0
100136: PPUSH
100137: CALL 106566 0 3
// end ;
100141: GO 100039
100143: POP
100144: POP
// if enchidnas then
100145: LD_VAR 0 4
100149: IFFALSE 100216
// for i = 1 to enchidnas do
100151: LD_ADDR_VAR 0 11
100155: PUSH
100156: DOUBLE
100157: LD_INT 1
100159: DEC
100160: ST_TO_ADDR
100161: LD_VAR 0 4
100165: PUSH
100166: FOR_TO
100167: IFFALSE 100214
// begin hc_class = 13 ;
100169: LD_ADDR_OWVAR 28
100173: PUSH
100174: LD_INT 13
100176: ST_TO_ADDR
// hc_gallery =  ;
100177: LD_ADDR_OWVAR 33
100181: PUSH
100182: LD_STRING 
100184: ST_TO_ADDR
// animal := CreateHuman ;
100185: LD_ADDR_VAR 0 12
100189: PUSH
100190: CALL_OW 44
100194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100195: LD_VAR 0 12
100199: PPUSH
100200: LD_VAR 0 8
100204: PPUSH
100205: LD_INT 0
100207: PPUSH
100208: CALL 106566 0 3
// end ;
100212: GO 100166
100214: POP
100215: POP
// if fishes then
100216: LD_VAR 0 7
100220: IFFALSE 100287
// for i = 1 to fishes do
100222: LD_ADDR_VAR 0 11
100226: PUSH
100227: DOUBLE
100228: LD_INT 1
100230: DEC
100231: ST_TO_ADDR
100232: LD_VAR 0 7
100236: PUSH
100237: FOR_TO
100238: IFFALSE 100285
// begin hc_class = 20 ;
100240: LD_ADDR_OWVAR 28
100244: PUSH
100245: LD_INT 20
100247: ST_TO_ADDR
// hc_gallery =  ;
100248: LD_ADDR_OWVAR 33
100252: PUSH
100253: LD_STRING 
100255: ST_TO_ADDR
// animal := CreateHuman ;
100256: LD_ADDR_VAR 0 12
100260: PUSH
100261: CALL_OW 44
100265: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100266: LD_VAR 0 12
100270: PPUSH
100271: LD_VAR 0 9
100275: PPUSH
100276: LD_INT 0
100278: PPUSH
100279: CALL 106566 0 3
// end ;
100283: GO 100237
100285: POP
100286: POP
// end ;
100287: LD_VAR 0 10
100291: RET
// export function WantHeal ( sci , unit ) ; begin
100292: LD_INT 0
100294: PPUSH
// if GetTaskList ( sci ) > 0 then
100295: LD_VAR 0 1
100299: PPUSH
100300: CALL_OW 437
100304: PUSH
100305: LD_INT 0
100307: GREATER
100308: IFFALSE 100378
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100310: LD_VAR 0 1
100314: PPUSH
100315: CALL_OW 437
100319: PUSH
100320: LD_INT 1
100322: ARRAY
100323: PUSH
100324: LD_INT 1
100326: ARRAY
100327: PUSH
100328: LD_STRING l
100330: EQUAL
100331: PUSH
100332: LD_VAR 0 1
100336: PPUSH
100337: CALL_OW 437
100341: PUSH
100342: LD_INT 1
100344: ARRAY
100345: PUSH
100346: LD_INT 4
100348: ARRAY
100349: PUSH
100350: LD_VAR 0 2
100354: EQUAL
100355: AND
100356: IFFALSE 100368
// result := true else
100358: LD_ADDR_VAR 0 3
100362: PUSH
100363: LD_INT 1
100365: ST_TO_ADDR
100366: GO 100376
// result := false ;
100368: LD_ADDR_VAR 0 3
100372: PUSH
100373: LD_INT 0
100375: ST_TO_ADDR
// end else
100376: GO 100386
// result := false ;
100378: LD_ADDR_VAR 0 3
100382: PUSH
100383: LD_INT 0
100385: ST_TO_ADDR
// end ;
100386: LD_VAR 0 3
100390: RET
// export function HealTarget ( sci ) ; begin
100391: LD_INT 0
100393: PPUSH
// if not sci then
100394: LD_VAR 0 1
100398: NOT
100399: IFFALSE 100403
// exit ;
100401: GO 100468
// result := 0 ;
100403: LD_ADDR_VAR 0 2
100407: PUSH
100408: LD_INT 0
100410: ST_TO_ADDR
// if GetTaskList ( sci ) then
100411: LD_VAR 0 1
100415: PPUSH
100416: CALL_OW 437
100420: IFFALSE 100468
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100422: LD_VAR 0 1
100426: PPUSH
100427: CALL_OW 437
100431: PUSH
100432: LD_INT 1
100434: ARRAY
100435: PUSH
100436: LD_INT 1
100438: ARRAY
100439: PUSH
100440: LD_STRING l
100442: EQUAL
100443: IFFALSE 100468
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100445: LD_ADDR_VAR 0 2
100449: PUSH
100450: LD_VAR 0 1
100454: PPUSH
100455: CALL_OW 437
100459: PUSH
100460: LD_INT 1
100462: ARRAY
100463: PUSH
100464: LD_INT 4
100466: ARRAY
100467: ST_TO_ADDR
// end ;
100468: LD_VAR 0 2
100472: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100473: LD_INT 0
100475: PPUSH
100476: PPUSH
100477: PPUSH
100478: PPUSH
100479: PPUSH
100480: PPUSH
100481: PPUSH
100482: PPUSH
100483: PPUSH
100484: PPUSH
100485: PPUSH
100486: PPUSH
100487: PPUSH
100488: PPUSH
100489: PPUSH
100490: PPUSH
100491: PPUSH
100492: PPUSH
100493: PPUSH
100494: PPUSH
100495: PPUSH
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
100500: PPUSH
100501: PPUSH
100502: PPUSH
100503: PPUSH
100504: PPUSH
100505: PPUSH
100506: PPUSH
100507: PPUSH
100508: PPUSH
// if not list then
100509: LD_VAR 0 1
100513: NOT
100514: IFFALSE 100518
// exit ;
100516: GO 105177
// base := list [ 1 ] ;
100518: LD_ADDR_VAR 0 3
100522: PUSH
100523: LD_VAR 0 1
100527: PUSH
100528: LD_INT 1
100530: ARRAY
100531: ST_TO_ADDR
// group := list [ 2 ] ;
100532: LD_ADDR_VAR 0 4
100536: PUSH
100537: LD_VAR 0 1
100541: PUSH
100542: LD_INT 2
100544: ARRAY
100545: ST_TO_ADDR
// path := list [ 3 ] ;
100546: LD_ADDR_VAR 0 5
100550: PUSH
100551: LD_VAR 0 1
100555: PUSH
100556: LD_INT 3
100558: ARRAY
100559: ST_TO_ADDR
// flags := list [ 4 ] ;
100560: LD_ADDR_VAR 0 6
100564: PUSH
100565: LD_VAR 0 1
100569: PUSH
100570: LD_INT 4
100572: ARRAY
100573: ST_TO_ADDR
// mined := [ ] ;
100574: LD_ADDR_VAR 0 27
100578: PUSH
100579: EMPTY
100580: ST_TO_ADDR
// bombed := [ ] ;
100581: LD_ADDR_VAR 0 28
100585: PUSH
100586: EMPTY
100587: ST_TO_ADDR
// healers := [ ] ;
100588: LD_ADDR_VAR 0 31
100592: PUSH
100593: EMPTY
100594: ST_TO_ADDR
// to_heal := [ ] ;
100595: LD_ADDR_VAR 0 30
100599: PUSH
100600: EMPTY
100601: ST_TO_ADDR
// repairs := [ ] ;
100602: LD_ADDR_VAR 0 33
100606: PUSH
100607: EMPTY
100608: ST_TO_ADDR
// to_repair := [ ] ;
100609: LD_ADDR_VAR 0 32
100613: PUSH
100614: EMPTY
100615: ST_TO_ADDR
// if not group or not path then
100616: LD_VAR 0 4
100620: NOT
100621: PUSH
100622: LD_VAR 0 5
100626: NOT
100627: OR
100628: IFFALSE 100632
// exit ;
100630: GO 105177
// side := GetSide ( group [ 1 ] ) ;
100632: LD_ADDR_VAR 0 35
100636: PUSH
100637: LD_VAR 0 4
100641: PUSH
100642: LD_INT 1
100644: ARRAY
100645: PPUSH
100646: CALL_OW 255
100650: ST_TO_ADDR
// if flags then
100651: LD_VAR 0 6
100655: IFFALSE 100799
// begin f_ignore_area := flags [ 1 ] ;
100657: LD_ADDR_VAR 0 17
100661: PUSH
100662: LD_VAR 0 6
100666: PUSH
100667: LD_INT 1
100669: ARRAY
100670: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100671: LD_ADDR_VAR 0 18
100675: PUSH
100676: LD_VAR 0 6
100680: PUSH
100681: LD_INT 2
100683: ARRAY
100684: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100685: LD_ADDR_VAR 0 19
100689: PUSH
100690: LD_VAR 0 6
100694: PUSH
100695: LD_INT 3
100697: ARRAY
100698: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100699: LD_ADDR_VAR 0 20
100703: PUSH
100704: LD_VAR 0 6
100708: PUSH
100709: LD_INT 4
100711: ARRAY
100712: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100713: LD_ADDR_VAR 0 21
100717: PUSH
100718: LD_VAR 0 6
100722: PUSH
100723: LD_INT 5
100725: ARRAY
100726: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100727: LD_ADDR_VAR 0 22
100731: PUSH
100732: LD_VAR 0 6
100736: PUSH
100737: LD_INT 6
100739: ARRAY
100740: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100741: LD_ADDR_VAR 0 23
100745: PUSH
100746: LD_VAR 0 6
100750: PUSH
100751: LD_INT 7
100753: ARRAY
100754: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100755: LD_ADDR_VAR 0 24
100759: PUSH
100760: LD_VAR 0 6
100764: PUSH
100765: LD_INT 8
100767: ARRAY
100768: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100769: LD_ADDR_VAR 0 25
100773: PUSH
100774: LD_VAR 0 6
100778: PUSH
100779: LD_INT 9
100781: ARRAY
100782: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100783: LD_ADDR_VAR 0 26
100787: PUSH
100788: LD_VAR 0 6
100792: PUSH
100793: LD_INT 10
100795: ARRAY
100796: ST_TO_ADDR
// end else
100797: GO 100879
// begin f_ignore_area := false ;
100799: LD_ADDR_VAR 0 17
100803: PUSH
100804: LD_INT 0
100806: ST_TO_ADDR
// f_capture := false ;
100807: LD_ADDR_VAR 0 18
100811: PUSH
100812: LD_INT 0
100814: ST_TO_ADDR
// f_ignore_civ := false ;
100815: LD_ADDR_VAR 0 19
100819: PUSH
100820: LD_INT 0
100822: ST_TO_ADDR
// f_murder := false ;
100823: LD_ADDR_VAR 0 20
100827: PUSH
100828: LD_INT 0
100830: ST_TO_ADDR
// f_mines := false ;
100831: LD_ADDR_VAR 0 21
100835: PUSH
100836: LD_INT 0
100838: ST_TO_ADDR
// f_repair := false ;
100839: LD_ADDR_VAR 0 22
100843: PUSH
100844: LD_INT 0
100846: ST_TO_ADDR
// f_heal := false ;
100847: LD_ADDR_VAR 0 23
100851: PUSH
100852: LD_INT 0
100854: ST_TO_ADDR
// f_spacetime := false ;
100855: LD_ADDR_VAR 0 24
100859: PUSH
100860: LD_INT 0
100862: ST_TO_ADDR
// f_attack_depot := false ;
100863: LD_ADDR_VAR 0 25
100867: PUSH
100868: LD_INT 0
100870: ST_TO_ADDR
// f_crawl := false ;
100871: LD_ADDR_VAR 0 26
100875: PUSH
100876: LD_INT 0
100878: ST_TO_ADDR
// end ; if f_heal then
100879: LD_VAR 0 23
100883: IFFALSE 100910
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100885: LD_ADDR_VAR 0 31
100889: PUSH
100890: LD_VAR 0 4
100894: PPUSH
100895: LD_INT 25
100897: PUSH
100898: LD_INT 4
100900: PUSH
100901: EMPTY
100902: LIST
100903: LIST
100904: PPUSH
100905: CALL_OW 72
100909: ST_TO_ADDR
// if f_repair then
100910: LD_VAR 0 22
100914: IFFALSE 100941
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100916: LD_ADDR_VAR 0 33
100920: PUSH
100921: LD_VAR 0 4
100925: PPUSH
100926: LD_INT 25
100928: PUSH
100929: LD_INT 3
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PPUSH
100936: CALL_OW 72
100940: ST_TO_ADDR
// units_path := [ ] ;
100941: LD_ADDR_VAR 0 16
100945: PUSH
100946: EMPTY
100947: ST_TO_ADDR
// for i = 1 to group do
100948: LD_ADDR_VAR 0 7
100952: PUSH
100953: DOUBLE
100954: LD_INT 1
100956: DEC
100957: ST_TO_ADDR
100958: LD_VAR 0 4
100962: PUSH
100963: FOR_TO
100964: IFFALSE 100993
// units_path := Replace ( units_path , i , path ) ;
100966: LD_ADDR_VAR 0 16
100970: PUSH
100971: LD_VAR 0 16
100975: PPUSH
100976: LD_VAR 0 7
100980: PPUSH
100981: LD_VAR 0 5
100985: PPUSH
100986: CALL_OW 1
100990: ST_TO_ADDR
100991: GO 100963
100993: POP
100994: POP
// repeat for i = group downto 1 do
100995: LD_ADDR_VAR 0 7
100999: PUSH
101000: DOUBLE
101001: LD_VAR 0 4
101005: INC
101006: ST_TO_ADDR
101007: LD_INT 1
101009: PUSH
101010: FOR_DOWNTO
101011: IFFALSE 105133
// begin wait ( 5 ) ;
101013: LD_INT 5
101015: PPUSH
101016: CALL_OW 67
// tmp := [ ] ;
101020: LD_ADDR_VAR 0 14
101024: PUSH
101025: EMPTY
101026: ST_TO_ADDR
// attacking := false ;
101027: LD_ADDR_VAR 0 29
101031: PUSH
101032: LD_INT 0
101034: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101035: LD_VAR 0 4
101039: PUSH
101040: LD_VAR 0 7
101044: ARRAY
101045: PPUSH
101046: CALL_OW 301
101050: PUSH
101051: LD_VAR 0 4
101055: PUSH
101056: LD_VAR 0 7
101060: ARRAY
101061: NOT
101062: OR
101063: IFFALSE 101172
// begin if GetType ( group [ i ] ) = unit_human then
101065: LD_VAR 0 4
101069: PUSH
101070: LD_VAR 0 7
101074: ARRAY
101075: PPUSH
101076: CALL_OW 247
101080: PUSH
101081: LD_INT 1
101083: EQUAL
101084: IFFALSE 101130
// begin to_heal := to_heal diff group [ i ] ;
101086: LD_ADDR_VAR 0 30
101090: PUSH
101091: LD_VAR 0 30
101095: PUSH
101096: LD_VAR 0 4
101100: PUSH
101101: LD_VAR 0 7
101105: ARRAY
101106: DIFF
101107: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101108: LD_ADDR_VAR 0 31
101112: PUSH
101113: LD_VAR 0 31
101117: PUSH
101118: LD_VAR 0 4
101122: PUSH
101123: LD_VAR 0 7
101127: ARRAY
101128: DIFF
101129: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101130: LD_ADDR_VAR 0 4
101134: PUSH
101135: LD_VAR 0 4
101139: PPUSH
101140: LD_VAR 0 7
101144: PPUSH
101145: CALL_OW 3
101149: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101150: LD_ADDR_VAR 0 16
101154: PUSH
101155: LD_VAR 0 16
101159: PPUSH
101160: LD_VAR 0 7
101164: PPUSH
101165: CALL_OW 3
101169: ST_TO_ADDR
// continue ;
101170: GO 101010
// end ; if f_repair then
101172: LD_VAR 0 22
101176: IFFALSE 101665
// begin if GetType ( group [ i ] ) = unit_vehicle then
101178: LD_VAR 0 4
101182: PUSH
101183: LD_VAR 0 7
101187: ARRAY
101188: PPUSH
101189: CALL_OW 247
101193: PUSH
101194: LD_INT 2
101196: EQUAL
101197: IFFALSE 101387
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101199: LD_VAR 0 4
101203: PUSH
101204: LD_VAR 0 7
101208: ARRAY
101209: PPUSH
101210: CALL_OW 256
101214: PUSH
101215: LD_INT 700
101217: LESS
101218: PUSH
101219: LD_VAR 0 4
101223: PUSH
101224: LD_VAR 0 7
101228: ARRAY
101229: PUSH
101230: LD_VAR 0 32
101234: IN
101235: NOT
101236: AND
101237: IFFALSE 101261
// to_repair := to_repair union group [ i ] ;
101239: LD_ADDR_VAR 0 32
101243: PUSH
101244: LD_VAR 0 32
101248: PUSH
101249: LD_VAR 0 4
101253: PUSH
101254: LD_VAR 0 7
101258: ARRAY
101259: UNION
101260: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101261: LD_VAR 0 4
101265: PUSH
101266: LD_VAR 0 7
101270: ARRAY
101271: PPUSH
101272: CALL_OW 256
101276: PUSH
101277: LD_INT 1000
101279: EQUAL
101280: PUSH
101281: LD_VAR 0 4
101285: PUSH
101286: LD_VAR 0 7
101290: ARRAY
101291: PUSH
101292: LD_VAR 0 32
101296: IN
101297: AND
101298: IFFALSE 101322
// to_repair := to_repair diff group [ i ] ;
101300: LD_ADDR_VAR 0 32
101304: PUSH
101305: LD_VAR 0 32
101309: PUSH
101310: LD_VAR 0 4
101314: PUSH
101315: LD_VAR 0 7
101319: ARRAY
101320: DIFF
101321: ST_TO_ADDR
// if group [ i ] in to_repair then
101322: LD_VAR 0 4
101326: PUSH
101327: LD_VAR 0 7
101331: ARRAY
101332: PUSH
101333: LD_VAR 0 32
101337: IN
101338: IFFALSE 101385
// begin if not IsInArea ( group [ i ] , f_repair ) then
101340: LD_VAR 0 4
101344: PUSH
101345: LD_VAR 0 7
101349: ARRAY
101350: PPUSH
101351: LD_VAR 0 22
101355: PPUSH
101356: CALL_OW 308
101360: NOT
101361: IFFALSE 101383
// ComMoveToArea ( group [ i ] , f_repair ) ;
101363: LD_VAR 0 4
101367: PUSH
101368: LD_VAR 0 7
101372: ARRAY
101373: PPUSH
101374: LD_VAR 0 22
101378: PPUSH
101379: CALL_OW 113
// continue ;
101383: GO 101010
// end ; end else
101385: GO 101665
// if group [ i ] in repairs then
101387: LD_VAR 0 4
101391: PUSH
101392: LD_VAR 0 7
101396: ARRAY
101397: PUSH
101398: LD_VAR 0 33
101402: IN
101403: IFFALSE 101665
// begin if IsInUnit ( group [ i ] ) then
101405: LD_VAR 0 4
101409: PUSH
101410: LD_VAR 0 7
101414: ARRAY
101415: PPUSH
101416: CALL_OW 310
101420: IFFALSE 101488
// begin z := IsInUnit ( group [ i ] ) ;
101422: LD_ADDR_VAR 0 13
101426: PUSH
101427: LD_VAR 0 4
101431: PUSH
101432: LD_VAR 0 7
101436: ARRAY
101437: PPUSH
101438: CALL_OW 310
101442: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101443: LD_VAR 0 13
101447: PUSH
101448: LD_VAR 0 32
101452: IN
101453: PUSH
101454: LD_VAR 0 13
101458: PPUSH
101459: LD_VAR 0 22
101463: PPUSH
101464: CALL_OW 308
101468: AND
101469: IFFALSE 101486
// ComExitVehicle ( group [ i ] ) ;
101471: LD_VAR 0 4
101475: PUSH
101476: LD_VAR 0 7
101480: ARRAY
101481: PPUSH
101482: CALL_OW 121
// end else
101486: GO 101665
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101488: LD_ADDR_VAR 0 13
101492: PUSH
101493: LD_VAR 0 4
101497: PPUSH
101498: LD_INT 95
101500: PUSH
101501: LD_VAR 0 22
101505: PUSH
101506: EMPTY
101507: LIST
101508: LIST
101509: PUSH
101510: LD_INT 58
101512: PUSH
101513: EMPTY
101514: LIST
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: PPUSH
101520: CALL_OW 72
101524: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101525: LD_VAR 0 4
101529: PUSH
101530: LD_VAR 0 7
101534: ARRAY
101535: PPUSH
101536: CALL_OW 314
101540: NOT
101541: IFFALSE 101663
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101543: LD_ADDR_VAR 0 10
101547: PUSH
101548: LD_VAR 0 13
101552: PPUSH
101553: LD_VAR 0 4
101557: PUSH
101558: LD_VAR 0 7
101562: ARRAY
101563: PPUSH
101564: CALL_OW 74
101568: ST_TO_ADDR
// if not x then
101569: LD_VAR 0 10
101573: NOT
101574: IFFALSE 101578
// continue ;
101576: GO 101010
// if GetLives ( x ) < 1000 then
101578: LD_VAR 0 10
101582: PPUSH
101583: CALL_OW 256
101587: PUSH
101588: LD_INT 1000
101590: LESS
101591: IFFALSE 101615
// ComRepairVehicle ( group [ i ] , x ) else
101593: LD_VAR 0 4
101597: PUSH
101598: LD_VAR 0 7
101602: ARRAY
101603: PPUSH
101604: LD_VAR 0 10
101608: PPUSH
101609: CALL_OW 129
101613: GO 101663
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101615: LD_VAR 0 23
101619: PUSH
101620: LD_VAR 0 4
101624: PUSH
101625: LD_VAR 0 7
101629: ARRAY
101630: PPUSH
101631: CALL_OW 256
101635: PUSH
101636: LD_INT 1000
101638: LESS
101639: AND
101640: NOT
101641: IFFALSE 101663
// ComEnterUnit ( group [ i ] , x ) ;
101643: LD_VAR 0 4
101647: PUSH
101648: LD_VAR 0 7
101652: ARRAY
101653: PPUSH
101654: LD_VAR 0 10
101658: PPUSH
101659: CALL_OW 120
// end ; continue ;
101663: GO 101010
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101665: LD_VAR 0 23
101669: PUSH
101670: LD_VAR 0 4
101674: PUSH
101675: LD_VAR 0 7
101679: ARRAY
101680: PPUSH
101681: CALL_OW 247
101685: PUSH
101686: LD_INT 1
101688: EQUAL
101689: AND
101690: IFFALSE 102168
// begin if group [ i ] in healers then
101692: LD_VAR 0 4
101696: PUSH
101697: LD_VAR 0 7
101701: ARRAY
101702: PUSH
101703: LD_VAR 0 31
101707: IN
101708: IFFALSE 101981
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101710: LD_VAR 0 4
101714: PUSH
101715: LD_VAR 0 7
101719: ARRAY
101720: PPUSH
101721: LD_VAR 0 23
101725: PPUSH
101726: CALL_OW 308
101730: NOT
101731: PUSH
101732: LD_VAR 0 4
101736: PUSH
101737: LD_VAR 0 7
101741: ARRAY
101742: PPUSH
101743: CALL_OW 314
101747: NOT
101748: AND
101749: IFFALSE 101773
// ComMoveToArea ( group [ i ] , f_heal ) else
101751: LD_VAR 0 4
101755: PUSH
101756: LD_VAR 0 7
101760: ARRAY
101761: PPUSH
101762: LD_VAR 0 23
101766: PPUSH
101767: CALL_OW 113
101771: GO 101979
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101773: LD_VAR 0 4
101777: PUSH
101778: LD_VAR 0 7
101782: ARRAY
101783: PPUSH
101784: CALL 100391 0 1
101788: PPUSH
101789: CALL_OW 256
101793: PUSH
101794: LD_INT 1000
101796: EQUAL
101797: IFFALSE 101816
// ComStop ( group [ i ] ) else
101799: LD_VAR 0 4
101803: PUSH
101804: LD_VAR 0 7
101808: ARRAY
101809: PPUSH
101810: CALL_OW 141
101814: GO 101979
// if not HasTask ( group [ i ] ) and to_heal then
101816: LD_VAR 0 4
101820: PUSH
101821: LD_VAR 0 7
101825: ARRAY
101826: PPUSH
101827: CALL_OW 314
101831: NOT
101832: PUSH
101833: LD_VAR 0 30
101837: AND
101838: IFFALSE 101979
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101840: LD_ADDR_VAR 0 13
101844: PUSH
101845: LD_VAR 0 30
101849: PPUSH
101850: LD_INT 3
101852: PUSH
101853: LD_INT 54
101855: PUSH
101856: EMPTY
101857: LIST
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: PPUSH
101863: CALL_OW 72
101867: PPUSH
101868: LD_VAR 0 4
101872: PUSH
101873: LD_VAR 0 7
101877: ARRAY
101878: PPUSH
101879: CALL_OW 74
101883: ST_TO_ADDR
// if z then
101884: LD_VAR 0 13
101888: IFFALSE 101979
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101890: LD_INT 91
101892: PUSH
101893: LD_VAR 0 13
101897: PUSH
101898: LD_INT 10
101900: PUSH
101901: EMPTY
101902: LIST
101903: LIST
101904: LIST
101905: PUSH
101906: LD_INT 81
101908: PUSH
101909: LD_VAR 0 13
101913: PPUSH
101914: CALL_OW 255
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: PUSH
101923: EMPTY
101924: LIST
101925: LIST
101926: PPUSH
101927: CALL_OW 69
101931: PUSH
101932: LD_INT 0
101934: EQUAL
101935: IFFALSE 101959
// ComHeal ( group [ i ] , z ) else
101937: LD_VAR 0 4
101941: PUSH
101942: LD_VAR 0 7
101946: ARRAY
101947: PPUSH
101948: LD_VAR 0 13
101952: PPUSH
101953: CALL_OW 128
101957: GO 101979
// ComMoveToArea ( group [ i ] , f_heal ) ;
101959: LD_VAR 0 4
101963: PUSH
101964: LD_VAR 0 7
101968: ARRAY
101969: PPUSH
101970: LD_VAR 0 23
101974: PPUSH
101975: CALL_OW 113
// end ; continue ;
101979: GO 101010
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101981: LD_VAR 0 4
101985: PUSH
101986: LD_VAR 0 7
101990: ARRAY
101991: PPUSH
101992: CALL_OW 256
101996: PUSH
101997: LD_INT 700
101999: LESS
102000: PUSH
102001: LD_VAR 0 4
102005: PUSH
102006: LD_VAR 0 7
102010: ARRAY
102011: PUSH
102012: LD_VAR 0 30
102016: IN
102017: NOT
102018: AND
102019: IFFALSE 102043
// to_heal := to_heal union group [ i ] ;
102021: LD_ADDR_VAR 0 30
102025: PUSH
102026: LD_VAR 0 30
102030: PUSH
102031: LD_VAR 0 4
102035: PUSH
102036: LD_VAR 0 7
102040: ARRAY
102041: UNION
102042: ST_TO_ADDR
// if group [ i ] in to_heal then
102043: LD_VAR 0 4
102047: PUSH
102048: LD_VAR 0 7
102052: ARRAY
102053: PUSH
102054: LD_VAR 0 30
102058: IN
102059: IFFALSE 102168
// begin if GetLives ( group [ i ] ) = 1000 then
102061: LD_VAR 0 4
102065: PUSH
102066: LD_VAR 0 7
102070: ARRAY
102071: PPUSH
102072: CALL_OW 256
102076: PUSH
102077: LD_INT 1000
102079: EQUAL
102080: IFFALSE 102106
// to_heal := to_heal diff group [ i ] else
102082: LD_ADDR_VAR 0 30
102086: PUSH
102087: LD_VAR 0 30
102091: PUSH
102092: LD_VAR 0 4
102096: PUSH
102097: LD_VAR 0 7
102101: ARRAY
102102: DIFF
102103: ST_TO_ADDR
102104: GO 102168
// begin if not IsInArea ( group [ i ] , to_heal ) then
102106: LD_VAR 0 4
102110: PUSH
102111: LD_VAR 0 7
102115: ARRAY
102116: PPUSH
102117: LD_VAR 0 30
102121: PPUSH
102122: CALL_OW 308
102126: NOT
102127: IFFALSE 102151
// ComMoveToArea ( group [ i ] , f_heal ) else
102129: LD_VAR 0 4
102133: PUSH
102134: LD_VAR 0 7
102138: ARRAY
102139: PPUSH
102140: LD_VAR 0 23
102144: PPUSH
102145: CALL_OW 113
102149: GO 102166
// ComHold ( group [ i ] ) ;
102151: LD_VAR 0 4
102155: PUSH
102156: LD_VAR 0 7
102160: ARRAY
102161: PPUSH
102162: CALL_OW 140
// continue ;
102166: GO 101010
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102168: LD_VAR 0 4
102172: PUSH
102173: LD_VAR 0 7
102177: ARRAY
102178: PPUSH
102179: LD_INT 10
102181: PPUSH
102182: CALL 98811 0 2
102186: NOT
102187: PUSH
102188: LD_VAR 0 16
102192: PUSH
102193: LD_VAR 0 7
102197: ARRAY
102198: PUSH
102199: EMPTY
102200: EQUAL
102201: NOT
102202: AND
102203: IFFALSE 102469
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102205: LD_VAR 0 4
102209: PUSH
102210: LD_VAR 0 7
102214: ARRAY
102215: PPUSH
102216: CALL_OW 262
102220: PUSH
102221: LD_INT 1
102223: PUSH
102224: LD_INT 2
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: IN
102231: IFFALSE 102272
// if GetFuel ( group [ i ] ) < 10 then
102233: LD_VAR 0 4
102237: PUSH
102238: LD_VAR 0 7
102242: ARRAY
102243: PPUSH
102244: CALL_OW 261
102248: PUSH
102249: LD_INT 10
102251: LESS
102252: IFFALSE 102272
// SetFuel ( group [ i ] , 12 ) ;
102254: LD_VAR 0 4
102258: PUSH
102259: LD_VAR 0 7
102263: ARRAY
102264: PPUSH
102265: LD_INT 12
102267: PPUSH
102268: CALL_OW 240
// if units_path [ i ] then
102272: LD_VAR 0 16
102276: PUSH
102277: LD_VAR 0 7
102281: ARRAY
102282: IFFALSE 102467
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102284: LD_VAR 0 4
102288: PUSH
102289: LD_VAR 0 7
102293: ARRAY
102294: PPUSH
102295: LD_VAR 0 16
102299: PUSH
102300: LD_VAR 0 7
102304: ARRAY
102305: PUSH
102306: LD_INT 1
102308: ARRAY
102309: PUSH
102310: LD_INT 1
102312: ARRAY
102313: PPUSH
102314: LD_VAR 0 16
102318: PUSH
102319: LD_VAR 0 7
102323: ARRAY
102324: PUSH
102325: LD_INT 1
102327: ARRAY
102328: PUSH
102329: LD_INT 2
102331: ARRAY
102332: PPUSH
102333: CALL_OW 297
102337: PUSH
102338: LD_INT 6
102340: GREATER
102341: IFFALSE 102416
// begin if not HasTask ( group [ i ] ) then
102343: LD_VAR 0 4
102347: PUSH
102348: LD_VAR 0 7
102352: ARRAY
102353: PPUSH
102354: CALL_OW 314
102358: NOT
102359: IFFALSE 102414
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102361: LD_VAR 0 4
102365: PUSH
102366: LD_VAR 0 7
102370: ARRAY
102371: PPUSH
102372: LD_VAR 0 16
102376: PUSH
102377: LD_VAR 0 7
102381: ARRAY
102382: PUSH
102383: LD_INT 1
102385: ARRAY
102386: PUSH
102387: LD_INT 1
102389: ARRAY
102390: PPUSH
102391: LD_VAR 0 16
102395: PUSH
102396: LD_VAR 0 7
102400: ARRAY
102401: PUSH
102402: LD_INT 1
102404: ARRAY
102405: PUSH
102406: LD_INT 2
102408: ARRAY
102409: PPUSH
102410: CALL_OW 114
// end else
102414: GO 102467
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102416: LD_ADDR_VAR 0 15
102420: PUSH
102421: LD_VAR 0 16
102425: PUSH
102426: LD_VAR 0 7
102430: ARRAY
102431: PPUSH
102432: LD_INT 1
102434: PPUSH
102435: CALL_OW 3
102439: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102440: LD_ADDR_VAR 0 16
102444: PUSH
102445: LD_VAR 0 16
102449: PPUSH
102450: LD_VAR 0 7
102454: PPUSH
102455: LD_VAR 0 15
102459: PPUSH
102460: CALL_OW 1
102464: ST_TO_ADDR
// continue ;
102465: GO 101010
// end ; end ; end else
102467: GO 105131
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102469: LD_ADDR_VAR 0 14
102473: PUSH
102474: LD_INT 81
102476: PUSH
102477: LD_VAR 0 4
102481: PUSH
102482: LD_VAR 0 7
102486: ARRAY
102487: PPUSH
102488: CALL_OW 255
102492: PUSH
102493: EMPTY
102494: LIST
102495: LIST
102496: PPUSH
102497: CALL_OW 69
102501: ST_TO_ADDR
// if not tmp then
102502: LD_VAR 0 14
102506: NOT
102507: IFFALSE 102511
// continue ;
102509: GO 101010
// if f_ignore_area then
102511: LD_VAR 0 17
102515: IFFALSE 102603
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102517: LD_ADDR_VAR 0 15
102521: PUSH
102522: LD_VAR 0 14
102526: PPUSH
102527: LD_INT 3
102529: PUSH
102530: LD_INT 92
102532: PUSH
102533: LD_VAR 0 17
102537: PUSH
102538: LD_INT 1
102540: ARRAY
102541: PUSH
102542: LD_VAR 0 17
102546: PUSH
102547: LD_INT 2
102549: ARRAY
102550: PUSH
102551: LD_VAR 0 17
102555: PUSH
102556: LD_INT 3
102558: ARRAY
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: LIST
102564: LIST
102565: PUSH
102566: EMPTY
102567: LIST
102568: LIST
102569: PPUSH
102570: CALL_OW 72
102574: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102575: LD_VAR 0 14
102579: PUSH
102580: LD_VAR 0 15
102584: DIFF
102585: IFFALSE 102603
// tmp := tmp diff tmp2 ;
102587: LD_ADDR_VAR 0 14
102591: PUSH
102592: LD_VAR 0 14
102596: PUSH
102597: LD_VAR 0 15
102601: DIFF
102602: ST_TO_ADDR
// end ; if not f_murder then
102603: LD_VAR 0 20
102607: NOT
102608: IFFALSE 102666
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102610: LD_ADDR_VAR 0 15
102614: PUSH
102615: LD_VAR 0 14
102619: PPUSH
102620: LD_INT 3
102622: PUSH
102623: LD_INT 50
102625: PUSH
102626: EMPTY
102627: LIST
102628: PUSH
102629: EMPTY
102630: LIST
102631: LIST
102632: PPUSH
102633: CALL_OW 72
102637: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102638: LD_VAR 0 14
102642: PUSH
102643: LD_VAR 0 15
102647: DIFF
102648: IFFALSE 102666
// tmp := tmp diff tmp2 ;
102650: LD_ADDR_VAR 0 14
102654: PUSH
102655: LD_VAR 0 14
102659: PUSH
102660: LD_VAR 0 15
102664: DIFF
102665: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102666: LD_ADDR_VAR 0 14
102670: PUSH
102671: LD_VAR 0 4
102675: PUSH
102676: LD_VAR 0 7
102680: ARRAY
102681: PPUSH
102682: LD_VAR 0 14
102686: PPUSH
102687: LD_INT 1
102689: PPUSH
102690: LD_INT 1
102692: PPUSH
102693: CALL 72454 0 4
102697: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102698: LD_VAR 0 4
102702: PUSH
102703: LD_VAR 0 7
102707: ARRAY
102708: PPUSH
102709: CALL_OW 257
102713: PUSH
102714: LD_INT 1
102716: EQUAL
102717: IFFALSE 103165
// begin if WantPlant ( group [ i ] ) then
102719: LD_VAR 0 4
102723: PUSH
102724: LD_VAR 0 7
102728: ARRAY
102729: PPUSH
102730: CALL 71955 0 1
102734: IFFALSE 102738
// continue ;
102736: GO 101010
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102738: LD_VAR 0 18
102742: PUSH
102743: LD_VAR 0 4
102747: PUSH
102748: LD_VAR 0 7
102752: ARRAY
102753: PPUSH
102754: CALL_OW 310
102758: NOT
102759: AND
102760: PUSH
102761: LD_VAR 0 14
102765: PUSH
102766: LD_INT 1
102768: ARRAY
102769: PUSH
102770: LD_VAR 0 14
102774: PPUSH
102775: LD_INT 21
102777: PUSH
102778: LD_INT 2
102780: PUSH
102781: EMPTY
102782: LIST
102783: LIST
102784: PUSH
102785: LD_INT 58
102787: PUSH
102788: EMPTY
102789: LIST
102790: PUSH
102791: EMPTY
102792: LIST
102793: LIST
102794: PPUSH
102795: CALL_OW 72
102799: IN
102800: AND
102801: IFFALSE 102837
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102803: LD_VAR 0 4
102807: PUSH
102808: LD_VAR 0 7
102812: ARRAY
102813: PPUSH
102814: LD_VAR 0 14
102818: PUSH
102819: LD_INT 1
102821: ARRAY
102822: PPUSH
102823: CALL_OW 120
// attacking := true ;
102827: LD_ADDR_VAR 0 29
102831: PUSH
102832: LD_INT 1
102834: ST_TO_ADDR
// continue ;
102835: GO 101010
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102837: LD_VAR 0 26
102841: PUSH
102842: LD_VAR 0 4
102846: PUSH
102847: LD_VAR 0 7
102851: ARRAY
102852: PPUSH
102853: CALL_OW 257
102857: PUSH
102858: LD_INT 1
102860: EQUAL
102861: AND
102862: PUSH
102863: LD_VAR 0 4
102867: PUSH
102868: LD_VAR 0 7
102872: ARRAY
102873: PPUSH
102874: CALL_OW 256
102878: PUSH
102879: LD_INT 800
102881: LESS
102882: AND
102883: PUSH
102884: LD_VAR 0 4
102888: PUSH
102889: LD_VAR 0 7
102893: ARRAY
102894: PPUSH
102895: CALL_OW 318
102899: NOT
102900: AND
102901: IFFALSE 102918
// ComCrawl ( group [ i ] ) ;
102903: LD_VAR 0 4
102907: PUSH
102908: LD_VAR 0 7
102912: ARRAY
102913: PPUSH
102914: CALL_OW 137
// if f_mines then
102918: LD_VAR 0 21
102922: IFFALSE 103165
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102924: LD_VAR 0 14
102928: PUSH
102929: LD_INT 1
102931: ARRAY
102932: PPUSH
102933: CALL_OW 247
102937: PUSH
102938: LD_INT 3
102940: EQUAL
102941: PUSH
102942: LD_VAR 0 14
102946: PUSH
102947: LD_INT 1
102949: ARRAY
102950: PUSH
102951: LD_VAR 0 27
102955: IN
102956: NOT
102957: AND
102958: IFFALSE 103165
// begin x := GetX ( tmp [ 1 ] ) ;
102960: LD_ADDR_VAR 0 10
102964: PUSH
102965: LD_VAR 0 14
102969: PUSH
102970: LD_INT 1
102972: ARRAY
102973: PPUSH
102974: CALL_OW 250
102978: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102979: LD_ADDR_VAR 0 11
102983: PUSH
102984: LD_VAR 0 14
102988: PUSH
102989: LD_INT 1
102991: ARRAY
102992: PPUSH
102993: CALL_OW 251
102997: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102998: LD_ADDR_VAR 0 12
103002: PUSH
103003: LD_VAR 0 4
103007: PUSH
103008: LD_VAR 0 7
103012: ARRAY
103013: PPUSH
103014: CALL 98896 0 1
103018: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103019: LD_VAR 0 4
103023: PUSH
103024: LD_VAR 0 7
103028: ARRAY
103029: PPUSH
103030: LD_VAR 0 10
103034: PPUSH
103035: LD_VAR 0 11
103039: PPUSH
103040: LD_VAR 0 14
103044: PUSH
103045: LD_INT 1
103047: ARRAY
103048: PPUSH
103049: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103053: LD_VAR 0 4
103057: PUSH
103058: LD_VAR 0 7
103062: ARRAY
103063: PPUSH
103064: LD_VAR 0 10
103068: PPUSH
103069: LD_VAR 0 12
103073: PPUSH
103074: LD_INT 7
103076: PPUSH
103077: CALL_OW 272
103081: PPUSH
103082: LD_VAR 0 11
103086: PPUSH
103087: LD_VAR 0 12
103091: PPUSH
103092: LD_INT 7
103094: PPUSH
103095: CALL_OW 273
103099: PPUSH
103100: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103104: LD_VAR 0 4
103108: PUSH
103109: LD_VAR 0 7
103113: ARRAY
103114: PPUSH
103115: LD_INT 71
103117: PPUSH
103118: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103122: LD_ADDR_VAR 0 27
103126: PUSH
103127: LD_VAR 0 27
103131: PPUSH
103132: LD_VAR 0 27
103136: PUSH
103137: LD_INT 1
103139: PLUS
103140: PPUSH
103141: LD_VAR 0 14
103145: PUSH
103146: LD_INT 1
103148: ARRAY
103149: PPUSH
103150: CALL_OW 1
103154: ST_TO_ADDR
// attacking := true ;
103155: LD_ADDR_VAR 0 29
103159: PUSH
103160: LD_INT 1
103162: ST_TO_ADDR
// continue ;
103163: GO 101010
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103165: LD_VAR 0 4
103169: PUSH
103170: LD_VAR 0 7
103174: ARRAY
103175: PPUSH
103176: CALL_OW 257
103180: PUSH
103181: LD_INT 17
103183: EQUAL
103184: PUSH
103185: LD_VAR 0 4
103189: PUSH
103190: LD_VAR 0 7
103194: ARRAY
103195: PPUSH
103196: CALL_OW 110
103200: PUSH
103201: LD_INT 71
103203: EQUAL
103204: NOT
103205: AND
103206: IFFALSE 103352
// begin attacking := false ;
103208: LD_ADDR_VAR 0 29
103212: PUSH
103213: LD_INT 0
103215: ST_TO_ADDR
// k := 5 ;
103216: LD_ADDR_VAR 0 9
103220: PUSH
103221: LD_INT 5
103223: ST_TO_ADDR
// if tmp < k then
103224: LD_VAR 0 14
103228: PUSH
103229: LD_VAR 0 9
103233: LESS
103234: IFFALSE 103246
// k := tmp ;
103236: LD_ADDR_VAR 0 9
103240: PUSH
103241: LD_VAR 0 14
103245: ST_TO_ADDR
// for j = 1 to k do
103246: LD_ADDR_VAR 0 8
103250: PUSH
103251: DOUBLE
103252: LD_INT 1
103254: DEC
103255: ST_TO_ADDR
103256: LD_VAR 0 9
103260: PUSH
103261: FOR_TO
103262: IFFALSE 103350
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103264: LD_VAR 0 14
103268: PUSH
103269: LD_VAR 0 8
103273: ARRAY
103274: PUSH
103275: LD_VAR 0 14
103279: PPUSH
103280: LD_INT 58
103282: PUSH
103283: EMPTY
103284: LIST
103285: PPUSH
103286: CALL_OW 72
103290: IN
103291: NOT
103292: IFFALSE 103348
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103294: LD_VAR 0 4
103298: PUSH
103299: LD_VAR 0 7
103303: ARRAY
103304: PPUSH
103305: LD_VAR 0 14
103309: PUSH
103310: LD_VAR 0 8
103314: ARRAY
103315: PPUSH
103316: CALL_OW 115
// attacking := true ;
103320: LD_ADDR_VAR 0 29
103324: PUSH
103325: LD_INT 1
103327: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103328: LD_VAR 0 4
103332: PUSH
103333: LD_VAR 0 7
103337: ARRAY
103338: PPUSH
103339: LD_INT 71
103341: PPUSH
103342: CALL_OW 109
// continue ;
103346: GO 103261
// end ; end ;
103348: GO 103261
103350: POP
103351: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103352: LD_VAR 0 4
103356: PUSH
103357: LD_VAR 0 7
103361: ARRAY
103362: PPUSH
103363: CALL_OW 257
103367: PUSH
103368: LD_INT 8
103370: EQUAL
103371: PUSH
103372: LD_VAR 0 4
103376: PUSH
103377: LD_VAR 0 7
103381: ARRAY
103382: PPUSH
103383: CALL_OW 264
103387: PUSH
103388: LD_INT 28
103390: PUSH
103391: LD_INT 45
103393: PUSH
103394: LD_INT 7
103396: PUSH
103397: LD_INT 47
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: IN
103406: OR
103407: IFFALSE 103663
// begin attacking := false ;
103409: LD_ADDR_VAR 0 29
103413: PUSH
103414: LD_INT 0
103416: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103417: LD_VAR 0 14
103421: PUSH
103422: LD_INT 1
103424: ARRAY
103425: PPUSH
103426: CALL_OW 266
103430: PUSH
103431: LD_INT 32
103433: PUSH
103434: LD_INT 31
103436: PUSH
103437: LD_INT 33
103439: PUSH
103440: LD_INT 4
103442: PUSH
103443: LD_INT 5
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: LIST
103450: LIST
103451: LIST
103452: IN
103453: IFFALSE 103639
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103455: LD_ADDR_VAR 0 9
103459: PUSH
103460: LD_VAR 0 14
103464: PUSH
103465: LD_INT 1
103467: ARRAY
103468: PPUSH
103469: CALL_OW 266
103473: PPUSH
103474: LD_VAR 0 14
103478: PUSH
103479: LD_INT 1
103481: ARRAY
103482: PPUSH
103483: CALL_OW 250
103487: PPUSH
103488: LD_VAR 0 14
103492: PUSH
103493: LD_INT 1
103495: ARRAY
103496: PPUSH
103497: CALL_OW 251
103501: PPUSH
103502: LD_VAR 0 14
103506: PUSH
103507: LD_INT 1
103509: ARRAY
103510: PPUSH
103511: CALL_OW 254
103515: PPUSH
103516: LD_VAR 0 14
103520: PUSH
103521: LD_INT 1
103523: ARRAY
103524: PPUSH
103525: CALL_OW 248
103529: PPUSH
103530: LD_INT 0
103532: PPUSH
103533: CALL 80266 0 6
103537: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103538: LD_ADDR_VAR 0 8
103542: PUSH
103543: LD_VAR 0 4
103547: PUSH
103548: LD_VAR 0 7
103552: ARRAY
103553: PPUSH
103554: LD_VAR 0 9
103558: PPUSH
103559: CALL 98936 0 2
103563: ST_TO_ADDR
// if j then
103564: LD_VAR 0 8
103568: IFFALSE 103637
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103570: LD_VAR 0 8
103574: PUSH
103575: LD_INT 1
103577: ARRAY
103578: PPUSH
103579: LD_VAR 0 8
103583: PUSH
103584: LD_INT 2
103586: ARRAY
103587: PPUSH
103588: CALL_OW 488
103592: IFFALSE 103637
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103594: LD_VAR 0 4
103598: PUSH
103599: LD_VAR 0 7
103603: ARRAY
103604: PPUSH
103605: LD_VAR 0 8
103609: PUSH
103610: LD_INT 1
103612: ARRAY
103613: PPUSH
103614: LD_VAR 0 8
103618: PUSH
103619: LD_INT 2
103621: ARRAY
103622: PPUSH
103623: CALL_OW 116
// attacking := true ;
103627: LD_ADDR_VAR 0 29
103631: PUSH
103632: LD_INT 1
103634: ST_TO_ADDR
// continue ;
103635: GO 101010
// end ; end else
103637: GO 103663
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103639: LD_VAR 0 4
103643: PUSH
103644: LD_VAR 0 7
103648: ARRAY
103649: PPUSH
103650: LD_VAR 0 14
103654: PUSH
103655: LD_INT 1
103657: ARRAY
103658: PPUSH
103659: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103663: LD_VAR 0 4
103667: PUSH
103668: LD_VAR 0 7
103672: ARRAY
103673: PPUSH
103674: CALL_OW 265
103678: PUSH
103679: LD_INT 11
103681: EQUAL
103682: IFFALSE 103960
// begin k := 10 ;
103684: LD_ADDR_VAR 0 9
103688: PUSH
103689: LD_INT 10
103691: ST_TO_ADDR
// x := 0 ;
103692: LD_ADDR_VAR 0 10
103696: PUSH
103697: LD_INT 0
103699: ST_TO_ADDR
// if tmp < k then
103700: LD_VAR 0 14
103704: PUSH
103705: LD_VAR 0 9
103709: LESS
103710: IFFALSE 103722
// k := tmp ;
103712: LD_ADDR_VAR 0 9
103716: PUSH
103717: LD_VAR 0 14
103721: ST_TO_ADDR
// for j = k downto 1 do
103722: LD_ADDR_VAR 0 8
103726: PUSH
103727: DOUBLE
103728: LD_VAR 0 9
103732: INC
103733: ST_TO_ADDR
103734: LD_INT 1
103736: PUSH
103737: FOR_DOWNTO
103738: IFFALSE 103813
// begin if GetType ( tmp [ j ] ) = unit_human then
103740: LD_VAR 0 14
103744: PUSH
103745: LD_VAR 0 8
103749: ARRAY
103750: PPUSH
103751: CALL_OW 247
103755: PUSH
103756: LD_INT 1
103758: EQUAL
103759: IFFALSE 103811
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103761: LD_VAR 0 4
103765: PUSH
103766: LD_VAR 0 7
103770: ARRAY
103771: PPUSH
103772: LD_VAR 0 14
103776: PUSH
103777: LD_VAR 0 8
103781: ARRAY
103782: PPUSH
103783: CALL 99207 0 2
// x := tmp [ j ] ;
103787: LD_ADDR_VAR 0 10
103791: PUSH
103792: LD_VAR 0 14
103796: PUSH
103797: LD_VAR 0 8
103801: ARRAY
103802: ST_TO_ADDR
// attacking := true ;
103803: LD_ADDR_VAR 0 29
103807: PUSH
103808: LD_INT 1
103810: ST_TO_ADDR
// end ; end ;
103811: GO 103737
103813: POP
103814: POP
// if not x then
103815: LD_VAR 0 10
103819: NOT
103820: IFFALSE 103960
// begin attacking := true ;
103822: LD_ADDR_VAR 0 29
103826: PUSH
103827: LD_INT 1
103829: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103830: LD_VAR 0 4
103834: PUSH
103835: LD_VAR 0 7
103839: ARRAY
103840: PPUSH
103841: CALL_OW 250
103845: PPUSH
103846: LD_VAR 0 4
103850: PUSH
103851: LD_VAR 0 7
103855: ARRAY
103856: PPUSH
103857: CALL_OW 251
103861: PPUSH
103862: CALL_OW 546
103866: PUSH
103867: LD_INT 2
103869: ARRAY
103870: PUSH
103871: LD_VAR 0 14
103875: PUSH
103876: LD_INT 1
103878: ARRAY
103879: PPUSH
103880: CALL_OW 250
103884: PPUSH
103885: LD_VAR 0 14
103889: PUSH
103890: LD_INT 1
103892: ARRAY
103893: PPUSH
103894: CALL_OW 251
103898: PPUSH
103899: CALL_OW 546
103903: PUSH
103904: LD_INT 2
103906: ARRAY
103907: EQUAL
103908: IFFALSE 103936
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103910: LD_VAR 0 4
103914: PUSH
103915: LD_VAR 0 7
103919: ARRAY
103920: PPUSH
103921: LD_VAR 0 14
103925: PUSH
103926: LD_INT 1
103928: ARRAY
103929: PPUSH
103930: CALL 99207 0 2
103934: GO 103960
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103936: LD_VAR 0 4
103940: PUSH
103941: LD_VAR 0 7
103945: ARRAY
103946: PPUSH
103947: LD_VAR 0 14
103951: PUSH
103952: LD_INT 1
103954: ARRAY
103955: PPUSH
103956: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103960: LD_VAR 0 4
103964: PUSH
103965: LD_VAR 0 7
103969: ARRAY
103970: PPUSH
103971: CALL_OW 264
103975: PUSH
103976: LD_INT 29
103978: EQUAL
103979: IFFALSE 104345
// begin if WantsToAttack ( group [ i ] ) in bombed then
103981: LD_VAR 0 4
103985: PUSH
103986: LD_VAR 0 7
103990: ARRAY
103991: PPUSH
103992: CALL_OW 319
103996: PUSH
103997: LD_VAR 0 28
104001: IN
104002: IFFALSE 104006
// continue ;
104004: GO 101010
// k := 8 ;
104006: LD_ADDR_VAR 0 9
104010: PUSH
104011: LD_INT 8
104013: ST_TO_ADDR
// x := 0 ;
104014: LD_ADDR_VAR 0 10
104018: PUSH
104019: LD_INT 0
104021: ST_TO_ADDR
// if tmp < k then
104022: LD_VAR 0 14
104026: PUSH
104027: LD_VAR 0 9
104031: LESS
104032: IFFALSE 104044
// k := tmp ;
104034: LD_ADDR_VAR 0 9
104038: PUSH
104039: LD_VAR 0 14
104043: ST_TO_ADDR
// for j = 1 to k do
104044: LD_ADDR_VAR 0 8
104048: PUSH
104049: DOUBLE
104050: LD_INT 1
104052: DEC
104053: ST_TO_ADDR
104054: LD_VAR 0 9
104058: PUSH
104059: FOR_TO
104060: IFFALSE 104192
// begin if GetType ( tmp [ j ] ) = unit_building then
104062: LD_VAR 0 14
104066: PUSH
104067: LD_VAR 0 8
104071: ARRAY
104072: PPUSH
104073: CALL_OW 247
104077: PUSH
104078: LD_INT 3
104080: EQUAL
104081: IFFALSE 104190
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104083: LD_VAR 0 14
104087: PUSH
104088: LD_VAR 0 8
104092: ARRAY
104093: PUSH
104094: LD_VAR 0 28
104098: IN
104099: NOT
104100: PUSH
104101: LD_VAR 0 14
104105: PUSH
104106: LD_VAR 0 8
104110: ARRAY
104111: PPUSH
104112: CALL_OW 313
104116: AND
104117: IFFALSE 104190
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104119: LD_VAR 0 4
104123: PUSH
104124: LD_VAR 0 7
104128: ARRAY
104129: PPUSH
104130: LD_VAR 0 14
104134: PUSH
104135: LD_VAR 0 8
104139: ARRAY
104140: PPUSH
104141: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104145: LD_ADDR_VAR 0 28
104149: PUSH
104150: LD_VAR 0 28
104154: PPUSH
104155: LD_VAR 0 28
104159: PUSH
104160: LD_INT 1
104162: PLUS
104163: PPUSH
104164: LD_VAR 0 14
104168: PUSH
104169: LD_VAR 0 8
104173: ARRAY
104174: PPUSH
104175: CALL_OW 1
104179: ST_TO_ADDR
// attacking := true ;
104180: LD_ADDR_VAR 0 29
104184: PUSH
104185: LD_INT 1
104187: ST_TO_ADDR
// break ;
104188: GO 104192
// end ; end ;
104190: GO 104059
104192: POP
104193: POP
// if not attacking and f_attack_depot then
104194: LD_VAR 0 29
104198: NOT
104199: PUSH
104200: LD_VAR 0 25
104204: AND
104205: IFFALSE 104300
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104207: LD_ADDR_VAR 0 13
104211: PUSH
104212: LD_VAR 0 14
104216: PPUSH
104217: LD_INT 2
104219: PUSH
104220: LD_INT 30
104222: PUSH
104223: LD_INT 0
104225: PUSH
104226: EMPTY
104227: LIST
104228: LIST
104229: PUSH
104230: LD_INT 30
104232: PUSH
104233: LD_INT 1
104235: PUSH
104236: EMPTY
104237: LIST
104238: LIST
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: LIST
104244: PPUSH
104245: CALL_OW 72
104249: ST_TO_ADDR
// if z then
104250: LD_VAR 0 13
104254: IFFALSE 104300
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104256: LD_VAR 0 4
104260: PUSH
104261: LD_VAR 0 7
104265: ARRAY
104266: PPUSH
104267: LD_VAR 0 13
104271: PPUSH
104272: LD_VAR 0 4
104276: PUSH
104277: LD_VAR 0 7
104281: ARRAY
104282: PPUSH
104283: CALL_OW 74
104287: PPUSH
104288: CALL_OW 115
// attacking := true ;
104292: LD_ADDR_VAR 0 29
104296: PUSH
104297: LD_INT 1
104299: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104300: LD_VAR 0 4
104304: PUSH
104305: LD_VAR 0 7
104309: ARRAY
104310: PPUSH
104311: CALL_OW 256
104315: PUSH
104316: LD_INT 500
104318: LESS
104319: IFFALSE 104345
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104321: LD_VAR 0 4
104325: PUSH
104326: LD_VAR 0 7
104330: ARRAY
104331: PPUSH
104332: LD_VAR 0 14
104336: PUSH
104337: LD_INT 1
104339: ARRAY
104340: PPUSH
104341: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104345: LD_VAR 0 4
104349: PUSH
104350: LD_VAR 0 7
104354: ARRAY
104355: PPUSH
104356: CALL_OW 264
104360: PUSH
104361: LD_INT 49
104363: EQUAL
104364: IFFALSE 104485
// begin if not HasTask ( group [ i ] ) then
104366: LD_VAR 0 4
104370: PUSH
104371: LD_VAR 0 7
104375: ARRAY
104376: PPUSH
104377: CALL_OW 314
104381: NOT
104382: IFFALSE 104485
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104384: LD_ADDR_VAR 0 9
104388: PUSH
104389: LD_INT 81
104391: PUSH
104392: LD_VAR 0 4
104396: PUSH
104397: LD_VAR 0 7
104401: ARRAY
104402: PPUSH
104403: CALL_OW 255
104407: PUSH
104408: EMPTY
104409: LIST
104410: LIST
104411: PPUSH
104412: CALL_OW 69
104416: PPUSH
104417: LD_VAR 0 4
104421: PUSH
104422: LD_VAR 0 7
104426: ARRAY
104427: PPUSH
104428: CALL_OW 74
104432: ST_TO_ADDR
// if k then
104433: LD_VAR 0 9
104437: IFFALSE 104485
// if GetDistUnits ( group [ i ] , k ) > 10 then
104439: LD_VAR 0 4
104443: PUSH
104444: LD_VAR 0 7
104448: ARRAY
104449: PPUSH
104450: LD_VAR 0 9
104454: PPUSH
104455: CALL_OW 296
104459: PUSH
104460: LD_INT 10
104462: GREATER
104463: IFFALSE 104485
// ComMoveUnit ( group [ i ] , k ) ;
104465: LD_VAR 0 4
104469: PUSH
104470: LD_VAR 0 7
104474: ARRAY
104475: PPUSH
104476: LD_VAR 0 9
104480: PPUSH
104481: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104485: LD_VAR 0 4
104489: PUSH
104490: LD_VAR 0 7
104494: ARRAY
104495: PPUSH
104496: CALL_OW 256
104500: PUSH
104501: LD_INT 250
104503: LESS
104504: PUSH
104505: LD_VAR 0 4
104509: PUSH
104510: LD_VAR 0 7
104514: ARRAY
104515: PUSH
104516: LD_INT 21
104518: PUSH
104519: LD_INT 2
104521: PUSH
104522: EMPTY
104523: LIST
104524: LIST
104525: PUSH
104526: LD_INT 23
104528: PUSH
104529: LD_INT 2
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: PUSH
104536: EMPTY
104537: LIST
104538: LIST
104539: PPUSH
104540: CALL_OW 69
104544: IN
104545: AND
104546: IFFALSE 104671
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104548: LD_ADDR_VAR 0 9
104552: PUSH
104553: LD_OWVAR 3
104557: PUSH
104558: LD_VAR 0 4
104562: PUSH
104563: LD_VAR 0 7
104567: ARRAY
104568: DIFF
104569: PPUSH
104570: LD_VAR 0 4
104574: PUSH
104575: LD_VAR 0 7
104579: ARRAY
104580: PPUSH
104581: CALL_OW 74
104585: ST_TO_ADDR
// if not k then
104586: LD_VAR 0 9
104590: NOT
104591: IFFALSE 104595
// continue ;
104593: GO 101010
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104595: LD_VAR 0 9
104599: PUSH
104600: LD_INT 81
104602: PUSH
104603: LD_VAR 0 4
104607: PUSH
104608: LD_VAR 0 7
104612: ARRAY
104613: PPUSH
104614: CALL_OW 255
104618: PUSH
104619: EMPTY
104620: LIST
104621: LIST
104622: PPUSH
104623: CALL_OW 69
104627: IN
104628: PUSH
104629: LD_VAR 0 9
104633: PPUSH
104634: LD_VAR 0 4
104638: PUSH
104639: LD_VAR 0 7
104643: ARRAY
104644: PPUSH
104645: CALL_OW 296
104649: PUSH
104650: LD_INT 5
104652: LESS
104653: AND
104654: IFFALSE 104671
// ComAutodestruct ( group [ i ] ) ;
104656: LD_VAR 0 4
104660: PUSH
104661: LD_VAR 0 7
104665: ARRAY
104666: PPUSH
104667: CALL 99105 0 1
// end ; if f_attack_depot then
104671: LD_VAR 0 25
104675: IFFALSE 104787
// begin k := 6 ;
104677: LD_ADDR_VAR 0 9
104681: PUSH
104682: LD_INT 6
104684: ST_TO_ADDR
// if tmp < k then
104685: LD_VAR 0 14
104689: PUSH
104690: LD_VAR 0 9
104694: LESS
104695: IFFALSE 104707
// k := tmp ;
104697: LD_ADDR_VAR 0 9
104701: PUSH
104702: LD_VAR 0 14
104706: ST_TO_ADDR
// for j = 1 to k do
104707: LD_ADDR_VAR 0 8
104711: PUSH
104712: DOUBLE
104713: LD_INT 1
104715: DEC
104716: ST_TO_ADDR
104717: LD_VAR 0 9
104721: PUSH
104722: FOR_TO
104723: IFFALSE 104785
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104725: LD_VAR 0 8
104729: PPUSH
104730: CALL_OW 266
104734: PUSH
104735: LD_INT 0
104737: PUSH
104738: LD_INT 1
104740: PUSH
104741: EMPTY
104742: LIST
104743: LIST
104744: IN
104745: IFFALSE 104783
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104747: LD_VAR 0 4
104751: PUSH
104752: LD_VAR 0 7
104756: ARRAY
104757: PPUSH
104758: LD_VAR 0 14
104762: PUSH
104763: LD_VAR 0 8
104767: ARRAY
104768: PPUSH
104769: CALL_OW 115
// attacking := true ;
104773: LD_ADDR_VAR 0 29
104777: PUSH
104778: LD_INT 1
104780: ST_TO_ADDR
// break ;
104781: GO 104785
// end ;
104783: GO 104722
104785: POP
104786: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104787: LD_VAR 0 4
104791: PUSH
104792: LD_VAR 0 7
104796: ARRAY
104797: PPUSH
104798: CALL_OW 302
104802: PUSH
104803: LD_VAR 0 29
104807: NOT
104808: AND
104809: IFFALSE 105131
// begin if GetTag ( group [ i ] ) = 71 then
104811: LD_VAR 0 4
104815: PUSH
104816: LD_VAR 0 7
104820: ARRAY
104821: PPUSH
104822: CALL_OW 110
104826: PUSH
104827: LD_INT 71
104829: EQUAL
104830: IFFALSE 104871
// begin if HasTask ( group [ i ] ) then
104832: LD_VAR 0 4
104836: PUSH
104837: LD_VAR 0 7
104841: ARRAY
104842: PPUSH
104843: CALL_OW 314
104847: IFFALSE 104853
// continue else
104849: GO 101010
104851: GO 104871
// SetTag ( group [ i ] , 0 ) ;
104853: LD_VAR 0 4
104857: PUSH
104858: LD_VAR 0 7
104862: ARRAY
104863: PPUSH
104864: LD_INT 0
104866: PPUSH
104867: CALL_OW 109
// end ; k := 8 ;
104871: LD_ADDR_VAR 0 9
104875: PUSH
104876: LD_INT 8
104878: ST_TO_ADDR
// x := 0 ;
104879: LD_ADDR_VAR 0 10
104883: PUSH
104884: LD_INT 0
104886: ST_TO_ADDR
// if tmp < k then
104887: LD_VAR 0 14
104891: PUSH
104892: LD_VAR 0 9
104896: LESS
104897: IFFALSE 104909
// k := tmp ;
104899: LD_ADDR_VAR 0 9
104903: PUSH
104904: LD_VAR 0 14
104908: ST_TO_ADDR
// for j = 1 to k do
104909: LD_ADDR_VAR 0 8
104913: PUSH
104914: DOUBLE
104915: LD_INT 1
104917: DEC
104918: ST_TO_ADDR
104919: LD_VAR 0 9
104923: PUSH
104924: FOR_TO
104925: IFFALSE 105023
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104927: LD_VAR 0 14
104931: PUSH
104932: LD_VAR 0 8
104936: ARRAY
104937: PPUSH
104938: CALL_OW 247
104942: PUSH
104943: LD_INT 1
104945: EQUAL
104946: PUSH
104947: LD_VAR 0 14
104951: PUSH
104952: LD_VAR 0 8
104956: ARRAY
104957: PPUSH
104958: CALL_OW 256
104962: PUSH
104963: LD_INT 250
104965: LESS
104966: PUSH
104967: LD_VAR 0 20
104971: AND
104972: PUSH
104973: LD_VAR 0 20
104977: NOT
104978: PUSH
104979: LD_VAR 0 14
104983: PUSH
104984: LD_VAR 0 8
104988: ARRAY
104989: PPUSH
104990: CALL_OW 256
104994: PUSH
104995: LD_INT 250
104997: GREATEREQUAL
104998: AND
104999: OR
105000: AND
105001: IFFALSE 105021
// begin x := tmp [ j ] ;
105003: LD_ADDR_VAR 0 10
105007: PUSH
105008: LD_VAR 0 14
105012: PUSH
105013: LD_VAR 0 8
105017: ARRAY
105018: ST_TO_ADDR
// break ;
105019: GO 105023
// end ;
105021: GO 104924
105023: POP
105024: POP
// if x then
105025: LD_VAR 0 10
105029: IFFALSE 105053
// ComAttackUnit ( group [ i ] , x ) else
105031: LD_VAR 0 4
105035: PUSH
105036: LD_VAR 0 7
105040: ARRAY
105041: PPUSH
105042: LD_VAR 0 10
105046: PPUSH
105047: CALL_OW 115
105051: GO 105077
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105053: LD_VAR 0 4
105057: PUSH
105058: LD_VAR 0 7
105062: ARRAY
105063: PPUSH
105064: LD_VAR 0 14
105068: PUSH
105069: LD_INT 1
105071: ARRAY
105072: PPUSH
105073: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105077: LD_VAR 0 4
105081: PUSH
105082: LD_VAR 0 7
105086: ARRAY
105087: PPUSH
105088: CALL_OW 314
105092: NOT
105093: IFFALSE 105131
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105095: LD_VAR 0 4
105099: PUSH
105100: LD_VAR 0 7
105104: ARRAY
105105: PPUSH
105106: LD_VAR 0 14
105110: PPUSH
105111: LD_VAR 0 4
105115: PUSH
105116: LD_VAR 0 7
105120: ARRAY
105121: PPUSH
105122: CALL_OW 74
105126: PPUSH
105127: CALL_OW 115
// end ; end ; end ;
105131: GO 101010
105133: POP
105134: POP
// wait ( 0 0$2 ) ;
105135: LD_INT 70
105137: PPUSH
105138: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105142: LD_VAR 0 4
105146: NOT
105147: PUSH
105148: LD_VAR 0 4
105152: PUSH
105153: EMPTY
105154: EQUAL
105155: OR
105156: PUSH
105157: LD_INT 81
105159: PUSH
105160: LD_VAR 0 35
105164: PUSH
105165: EMPTY
105166: LIST
105167: LIST
105168: PPUSH
105169: CALL_OW 69
105173: NOT
105174: OR
105175: IFFALSE 100995
// end ;
105177: LD_VAR 0 2
105181: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105182: LD_INT 0
105184: PPUSH
105185: PPUSH
105186: PPUSH
105187: PPUSH
// if not base_units then
105188: LD_VAR 0 1
105192: NOT
105193: IFFALSE 105197
// exit ;
105195: GO 105284
// result := false ;
105197: LD_ADDR_VAR 0 2
105201: PUSH
105202: LD_INT 0
105204: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105205: LD_ADDR_VAR 0 5
105209: PUSH
105210: LD_VAR 0 1
105214: PPUSH
105215: LD_INT 21
105217: PUSH
105218: LD_INT 3
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: PPUSH
105225: CALL_OW 72
105229: ST_TO_ADDR
// if not tmp then
105230: LD_VAR 0 5
105234: NOT
105235: IFFALSE 105239
// exit ;
105237: GO 105284
// for i in tmp do
105239: LD_ADDR_VAR 0 3
105243: PUSH
105244: LD_VAR 0 5
105248: PUSH
105249: FOR_IN
105250: IFFALSE 105282
// begin result := EnemyInRange ( i , 22 ) ;
105252: LD_ADDR_VAR 0 2
105256: PUSH
105257: LD_VAR 0 3
105261: PPUSH
105262: LD_INT 22
105264: PPUSH
105265: CALL 98811 0 2
105269: ST_TO_ADDR
// if result then
105270: LD_VAR 0 2
105274: IFFALSE 105280
// exit ;
105276: POP
105277: POP
105278: GO 105284
// end ;
105280: GO 105249
105282: POP
105283: POP
// end ;
105284: LD_VAR 0 2
105288: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105289: LD_INT 0
105291: PPUSH
105292: PPUSH
// if not units then
105293: LD_VAR 0 1
105297: NOT
105298: IFFALSE 105302
// exit ;
105300: GO 105372
// result := [ ] ;
105302: LD_ADDR_VAR 0 3
105306: PUSH
105307: EMPTY
105308: ST_TO_ADDR
// for i in units do
105309: LD_ADDR_VAR 0 4
105313: PUSH
105314: LD_VAR 0 1
105318: PUSH
105319: FOR_IN
105320: IFFALSE 105370
// if GetTag ( i ) = tag then
105322: LD_VAR 0 4
105326: PPUSH
105327: CALL_OW 110
105331: PUSH
105332: LD_VAR 0 2
105336: EQUAL
105337: IFFALSE 105368
// result := Insert ( result , result + 1 , i ) ;
105339: LD_ADDR_VAR 0 3
105343: PUSH
105344: LD_VAR 0 3
105348: PPUSH
105349: LD_VAR 0 3
105353: PUSH
105354: LD_INT 1
105356: PLUS
105357: PPUSH
105358: LD_VAR 0 4
105362: PPUSH
105363: CALL_OW 2
105367: ST_TO_ADDR
105368: GO 105319
105370: POP
105371: POP
// end ;
105372: LD_VAR 0 3
105376: RET
// export function IsDriver ( un ) ; begin
105377: LD_INT 0
105379: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105380: LD_ADDR_VAR 0 2
105384: PUSH
105385: LD_VAR 0 1
105389: PUSH
105390: LD_INT 55
105392: PUSH
105393: EMPTY
105394: LIST
105395: PPUSH
105396: CALL_OW 69
105400: IN
105401: ST_TO_ADDR
// end ;
105402: LD_VAR 0 2
105406: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105407: LD_INT 0
105409: PPUSH
105410: PPUSH
// list := [ ] ;
105411: LD_ADDR_VAR 0 5
105415: PUSH
105416: EMPTY
105417: ST_TO_ADDR
// case d of 0 :
105418: LD_VAR 0 3
105422: PUSH
105423: LD_INT 0
105425: DOUBLE
105426: EQUAL
105427: IFTRUE 105431
105429: GO 105564
105431: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105432: LD_ADDR_VAR 0 5
105436: PUSH
105437: LD_VAR 0 1
105441: PUSH
105442: LD_INT 4
105444: MINUS
105445: PUSH
105446: LD_VAR 0 2
105450: PUSH
105451: LD_INT 4
105453: MINUS
105454: PUSH
105455: LD_INT 2
105457: PUSH
105458: EMPTY
105459: LIST
105460: LIST
105461: LIST
105462: PUSH
105463: LD_VAR 0 1
105467: PUSH
105468: LD_INT 3
105470: MINUS
105471: PUSH
105472: LD_VAR 0 2
105476: PUSH
105477: LD_INT 1
105479: PUSH
105480: EMPTY
105481: LIST
105482: LIST
105483: LIST
105484: PUSH
105485: LD_VAR 0 1
105489: PUSH
105490: LD_INT 4
105492: PLUS
105493: PUSH
105494: LD_VAR 0 2
105498: PUSH
105499: LD_INT 4
105501: PUSH
105502: EMPTY
105503: LIST
105504: LIST
105505: LIST
105506: PUSH
105507: LD_VAR 0 1
105511: PUSH
105512: LD_INT 3
105514: PLUS
105515: PUSH
105516: LD_VAR 0 2
105520: PUSH
105521: LD_INT 3
105523: PLUS
105524: PUSH
105525: LD_INT 5
105527: PUSH
105528: EMPTY
105529: LIST
105530: LIST
105531: LIST
105532: PUSH
105533: LD_VAR 0 1
105537: PUSH
105538: LD_VAR 0 2
105542: PUSH
105543: LD_INT 4
105545: PLUS
105546: PUSH
105547: LD_INT 0
105549: PUSH
105550: EMPTY
105551: LIST
105552: LIST
105553: LIST
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: LIST
105559: LIST
105560: LIST
105561: ST_TO_ADDR
// end ; 1 :
105562: GO 106262
105564: LD_INT 1
105566: DOUBLE
105567: EQUAL
105568: IFTRUE 105572
105570: GO 105705
105572: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105573: LD_ADDR_VAR 0 5
105577: PUSH
105578: LD_VAR 0 1
105582: PUSH
105583: LD_VAR 0 2
105587: PUSH
105588: LD_INT 4
105590: MINUS
105591: PUSH
105592: LD_INT 3
105594: PUSH
105595: EMPTY
105596: LIST
105597: LIST
105598: LIST
105599: PUSH
105600: LD_VAR 0 1
105604: PUSH
105605: LD_INT 3
105607: MINUS
105608: PUSH
105609: LD_VAR 0 2
105613: PUSH
105614: LD_INT 3
105616: MINUS
105617: PUSH
105618: LD_INT 2
105620: PUSH
105621: EMPTY
105622: LIST
105623: LIST
105624: LIST
105625: PUSH
105626: LD_VAR 0 1
105630: PUSH
105631: LD_INT 4
105633: MINUS
105634: PUSH
105635: LD_VAR 0 2
105639: PUSH
105640: LD_INT 1
105642: PUSH
105643: EMPTY
105644: LIST
105645: LIST
105646: LIST
105647: PUSH
105648: LD_VAR 0 1
105652: PUSH
105653: LD_VAR 0 2
105657: PUSH
105658: LD_INT 3
105660: PLUS
105661: PUSH
105662: LD_INT 0
105664: PUSH
105665: EMPTY
105666: LIST
105667: LIST
105668: LIST
105669: PUSH
105670: LD_VAR 0 1
105674: PUSH
105675: LD_INT 4
105677: PLUS
105678: PUSH
105679: LD_VAR 0 2
105683: PUSH
105684: LD_INT 4
105686: PLUS
105687: PUSH
105688: LD_INT 5
105690: PUSH
105691: EMPTY
105692: LIST
105693: LIST
105694: LIST
105695: PUSH
105696: EMPTY
105697: LIST
105698: LIST
105699: LIST
105700: LIST
105701: LIST
105702: ST_TO_ADDR
// end ; 2 :
105703: GO 106262
105705: LD_INT 2
105707: DOUBLE
105708: EQUAL
105709: IFTRUE 105713
105711: GO 105842
105713: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105714: LD_ADDR_VAR 0 5
105718: PUSH
105719: LD_VAR 0 1
105723: PUSH
105724: LD_VAR 0 2
105728: PUSH
105729: LD_INT 3
105731: MINUS
105732: PUSH
105733: LD_INT 3
105735: PUSH
105736: EMPTY
105737: LIST
105738: LIST
105739: LIST
105740: PUSH
105741: LD_VAR 0 1
105745: PUSH
105746: LD_INT 4
105748: PLUS
105749: PUSH
105750: LD_VAR 0 2
105754: PUSH
105755: LD_INT 4
105757: PUSH
105758: EMPTY
105759: LIST
105760: LIST
105761: LIST
105762: PUSH
105763: LD_VAR 0 1
105767: PUSH
105768: LD_VAR 0 2
105772: PUSH
105773: LD_INT 4
105775: PLUS
105776: PUSH
105777: LD_INT 0
105779: PUSH
105780: EMPTY
105781: LIST
105782: LIST
105783: LIST
105784: PUSH
105785: LD_VAR 0 1
105789: PUSH
105790: LD_INT 3
105792: MINUS
105793: PUSH
105794: LD_VAR 0 2
105798: PUSH
105799: LD_INT 1
105801: PUSH
105802: EMPTY
105803: LIST
105804: LIST
105805: LIST
105806: PUSH
105807: LD_VAR 0 1
105811: PUSH
105812: LD_INT 4
105814: MINUS
105815: PUSH
105816: LD_VAR 0 2
105820: PUSH
105821: LD_INT 4
105823: MINUS
105824: PUSH
105825: LD_INT 2
105827: PUSH
105828: EMPTY
105829: LIST
105830: LIST
105831: LIST
105832: PUSH
105833: EMPTY
105834: LIST
105835: LIST
105836: LIST
105837: LIST
105838: LIST
105839: ST_TO_ADDR
// end ; 3 :
105840: GO 106262
105842: LD_INT 3
105844: DOUBLE
105845: EQUAL
105846: IFTRUE 105850
105848: GO 105983
105850: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105851: LD_ADDR_VAR 0 5
105855: PUSH
105856: LD_VAR 0 1
105860: PUSH
105861: LD_INT 3
105863: PLUS
105864: PUSH
105865: LD_VAR 0 2
105869: PUSH
105870: LD_INT 4
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: LIST
105877: PUSH
105878: LD_VAR 0 1
105882: PUSH
105883: LD_INT 4
105885: PLUS
105886: PUSH
105887: LD_VAR 0 2
105891: PUSH
105892: LD_INT 4
105894: PLUS
105895: PUSH
105896: LD_INT 5
105898: PUSH
105899: EMPTY
105900: LIST
105901: LIST
105902: LIST
105903: PUSH
105904: LD_VAR 0 1
105908: PUSH
105909: LD_INT 4
105911: MINUS
105912: PUSH
105913: LD_VAR 0 2
105917: PUSH
105918: LD_INT 1
105920: PUSH
105921: EMPTY
105922: LIST
105923: LIST
105924: LIST
105925: PUSH
105926: LD_VAR 0 1
105930: PUSH
105931: LD_VAR 0 2
105935: PUSH
105936: LD_INT 4
105938: MINUS
105939: PUSH
105940: LD_INT 3
105942: PUSH
105943: EMPTY
105944: LIST
105945: LIST
105946: LIST
105947: PUSH
105948: LD_VAR 0 1
105952: PUSH
105953: LD_INT 3
105955: MINUS
105956: PUSH
105957: LD_VAR 0 2
105961: PUSH
105962: LD_INT 3
105964: MINUS
105965: PUSH
105966: LD_INT 2
105968: PUSH
105969: EMPTY
105970: LIST
105971: LIST
105972: LIST
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: LIST
105978: LIST
105979: LIST
105980: ST_TO_ADDR
// end ; 4 :
105981: GO 106262
105983: LD_INT 4
105985: DOUBLE
105986: EQUAL
105987: IFTRUE 105991
105989: GO 106124
105991: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105992: LD_ADDR_VAR 0 5
105996: PUSH
105997: LD_VAR 0 1
106001: PUSH
106002: LD_VAR 0 2
106006: PUSH
106007: LD_INT 4
106009: PLUS
106010: PUSH
106011: LD_INT 0
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: LIST
106018: PUSH
106019: LD_VAR 0 1
106023: PUSH
106024: LD_INT 3
106026: PLUS
106027: PUSH
106028: LD_VAR 0 2
106032: PUSH
106033: LD_INT 3
106035: PLUS
106036: PUSH
106037: LD_INT 5
106039: PUSH
106040: EMPTY
106041: LIST
106042: LIST
106043: LIST
106044: PUSH
106045: LD_VAR 0 1
106049: PUSH
106050: LD_INT 4
106052: PLUS
106053: PUSH
106054: LD_VAR 0 2
106058: PUSH
106059: LD_INT 4
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: LIST
106066: PUSH
106067: LD_VAR 0 1
106071: PUSH
106072: LD_VAR 0 2
106076: PUSH
106077: LD_INT 3
106079: MINUS
106080: PUSH
106081: LD_INT 3
106083: PUSH
106084: EMPTY
106085: LIST
106086: LIST
106087: LIST
106088: PUSH
106089: LD_VAR 0 1
106093: PUSH
106094: LD_INT 4
106096: MINUS
106097: PUSH
106098: LD_VAR 0 2
106102: PUSH
106103: LD_INT 4
106105: MINUS
106106: PUSH
106107: LD_INT 2
106109: PUSH
106110: EMPTY
106111: LIST
106112: LIST
106113: LIST
106114: PUSH
106115: EMPTY
106116: LIST
106117: LIST
106118: LIST
106119: LIST
106120: LIST
106121: ST_TO_ADDR
// end ; 5 :
106122: GO 106262
106124: LD_INT 5
106126: DOUBLE
106127: EQUAL
106128: IFTRUE 106132
106130: GO 106261
106132: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106133: LD_ADDR_VAR 0 5
106137: PUSH
106138: LD_VAR 0 1
106142: PUSH
106143: LD_INT 4
106145: MINUS
106146: PUSH
106147: LD_VAR 0 2
106151: PUSH
106152: LD_INT 1
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: LIST
106159: PUSH
106160: LD_VAR 0 1
106164: PUSH
106165: LD_VAR 0 2
106169: PUSH
106170: LD_INT 4
106172: MINUS
106173: PUSH
106174: LD_INT 3
106176: PUSH
106177: EMPTY
106178: LIST
106179: LIST
106180: LIST
106181: PUSH
106182: LD_VAR 0 1
106186: PUSH
106187: LD_INT 4
106189: PLUS
106190: PUSH
106191: LD_VAR 0 2
106195: PUSH
106196: LD_INT 4
106198: PLUS
106199: PUSH
106200: LD_INT 5
106202: PUSH
106203: EMPTY
106204: LIST
106205: LIST
106206: LIST
106207: PUSH
106208: LD_VAR 0 1
106212: PUSH
106213: LD_INT 3
106215: PLUS
106216: PUSH
106217: LD_VAR 0 2
106221: PUSH
106222: LD_INT 4
106224: PUSH
106225: EMPTY
106226: LIST
106227: LIST
106228: LIST
106229: PUSH
106230: LD_VAR 0 1
106234: PUSH
106235: LD_VAR 0 2
106239: PUSH
106240: LD_INT 3
106242: PLUS
106243: PUSH
106244: LD_INT 0
106246: PUSH
106247: EMPTY
106248: LIST
106249: LIST
106250: LIST
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: LIST
106256: LIST
106257: LIST
106258: ST_TO_ADDR
// end ; end ;
106259: GO 106262
106261: POP
// result := list ;
106262: LD_ADDR_VAR 0 4
106266: PUSH
106267: LD_VAR 0 5
106271: ST_TO_ADDR
// end ;
106272: LD_VAR 0 4
106276: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106277: LD_INT 0
106279: PPUSH
106280: PPUSH
106281: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106282: LD_VAR 0 1
106286: NOT
106287: PUSH
106288: LD_VAR 0 2
106292: PUSH
106293: LD_INT 1
106295: PUSH
106296: LD_INT 2
106298: PUSH
106299: LD_INT 3
106301: PUSH
106302: LD_INT 4
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: LIST
106309: LIST
106310: IN
106311: NOT
106312: OR
106313: IFFALSE 106317
// exit ;
106315: GO 106409
// tmp := [ ] ;
106317: LD_ADDR_VAR 0 5
106321: PUSH
106322: EMPTY
106323: ST_TO_ADDR
// for i in units do
106324: LD_ADDR_VAR 0 4
106328: PUSH
106329: LD_VAR 0 1
106333: PUSH
106334: FOR_IN
106335: IFFALSE 106378
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106337: LD_ADDR_VAR 0 5
106341: PUSH
106342: LD_VAR 0 5
106346: PPUSH
106347: LD_VAR 0 5
106351: PUSH
106352: LD_INT 1
106354: PLUS
106355: PPUSH
106356: LD_VAR 0 4
106360: PPUSH
106361: LD_VAR 0 2
106365: PPUSH
106366: CALL_OW 259
106370: PPUSH
106371: CALL_OW 2
106375: ST_TO_ADDR
106376: GO 106334
106378: POP
106379: POP
// if not tmp then
106380: LD_VAR 0 5
106384: NOT
106385: IFFALSE 106389
// exit ;
106387: GO 106409
// result := SortListByListDesc ( units , tmp ) ;
106389: LD_ADDR_VAR 0 3
106393: PUSH
106394: LD_VAR 0 1
106398: PPUSH
106399: LD_VAR 0 5
106403: PPUSH
106404: CALL_OW 77
106408: ST_TO_ADDR
// end ;
106409: LD_VAR 0 3
106413: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106414: LD_INT 0
106416: PPUSH
106417: PPUSH
106418: PPUSH
// x := GetX ( building ) ;
106419: LD_ADDR_VAR 0 4
106423: PUSH
106424: LD_VAR 0 2
106428: PPUSH
106429: CALL_OW 250
106433: ST_TO_ADDR
// y := GetY ( building ) ;
106434: LD_ADDR_VAR 0 5
106438: PUSH
106439: LD_VAR 0 2
106443: PPUSH
106444: CALL_OW 251
106448: ST_TO_ADDR
// if GetTaskList ( unit ) then
106449: LD_VAR 0 1
106453: PPUSH
106454: CALL_OW 437
106458: IFFALSE 106553
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106460: LD_STRING e
106462: PUSH
106463: LD_VAR 0 1
106467: PPUSH
106468: CALL_OW 437
106472: PUSH
106473: LD_INT 1
106475: ARRAY
106476: PUSH
106477: LD_INT 1
106479: ARRAY
106480: EQUAL
106481: PUSH
106482: LD_VAR 0 4
106486: PUSH
106487: LD_VAR 0 1
106491: PPUSH
106492: CALL_OW 437
106496: PUSH
106497: LD_INT 1
106499: ARRAY
106500: PUSH
106501: LD_INT 2
106503: ARRAY
106504: EQUAL
106505: AND
106506: PUSH
106507: LD_VAR 0 5
106511: PUSH
106512: LD_VAR 0 1
106516: PPUSH
106517: CALL_OW 437
106521: PUSH
106522: LD_INT 1
106524: ARRAY
106525: PUSH
106526: LD_INT 3
106528: ARRAY
106529: EQUAL
106530: AND
106531: IFFALSE 106543
// result := true else
106533: LD_ADDR_VAR 0 3
106537: PUSH
106538: LD_INT 1
106540: ST_TO_ADDR
106541: GO 106551
// result := false ;
106543: LD_ADDR_VAR 0 3
106547: PUSH
106548: LD_INT 0
106550: ST_TO_ADDR
// end else
106551: GO 106561
// result := false ;
106553: LD_ADDR_VAR 0 3
106557: PUSH
106558: LD_INT 0
106560: ST_TO_ADDR
// end ;
106561: LD_VAR 0 3
106565: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106566: LD_INT 0
106568: PPUSH
106569: PPUSH
106570: PPUSH
106571: PPUSH
// if not unit or not area then
106572: LD_VAR 0 1
106576: NOT
106577: PUSH
106578: LD_VAR 0 2
106582: NOT
106583: OR
106584: IFFALSE 106588
// exit ;
106586: GO 106752
// tmp := AreaToList ( area , i ) ;
106588: LD_ADDR_VAR 0 6
106592: PUSH
106593: LD_VAR 0 2
106597: PPUSH
106598: LD_VAR 0 5
106602: PPUSH
106603: CALL_OW 517
106607: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106608: LD_ADDR_VAR 0 5
106612: PUSH
106613: DOUBLE
106614: LD_INT 1
106616: DEC
106617: ST_TO_ADDR
106618: LD_VAR 0 6
106622: PUSH
106623: LD_INT 1
106625: ARRAY
106626: PUSH
106627: FOR_TO
106628: IFFALSE 106750
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106630: LD_ADDR_VAR 0 7
106634: PUSH
106635: LD_VAR 0 6
106639: PUSH
106640: LD_INT 1
106642: ARRAY
106643: PUSH
106644: LD_VAR 0 5
106648: ARRAY
106649: PUSH
106650: LD_VAR 0 6
106654: PUSH
106655: LD_INT 2
106657: ARRAY
106658: PUSH
106659: LD_VAR 0 5
106663: ARRAY
106664: PUSH
106665: EMPTY
106666: LIST
106667: LIST
106668: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106669: LD_VAR 0 7
106673: PUSH
106674: LD_INT 1
106676: ARRAY
106677: PPUSH
106678: LD_VAR 0 7
106682: PUSH
106683: LD_INT 2
106685: ARRAY
106686: PPUSH
106687: CALL_OW 428
106691: PUSH
106692: LD_INT 0
106694: EQUAL
106695: IFFALSE 106748
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106697: LD_VAR 0 1
106701: PPUSH
106702: LD_VAR 0 7
106706: PUSH
106707: LD_INT 1
106709: ARRAY
106710: PPUSH
106711: LD_VAR 0 7
106715: PUSH
106716: LD_INT 2
106718: ARRAY
106719: PPUSH
106720: LD_VAR 0 3
106724: PPUSH
106725: CALL_OW 48
// result := IsPlaced ( unit ) ;
106729: LD_ADDR_VAR 0 4
106733: PUSH
106734: LD_VAR 0 1
106738: PPUSH
106739: CALL_OW 305
106743: ST_TO_ADDR
// exit ;
106744: POP
106745: POP
106746: GO 106752
// end ; end ;
106748: GO 106627
106750: POP
106751: POP
// end ;
106752: LD_VAR 0 4
106756: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106757: LD_INT 0
106759: PPUSH
106760: PPUSH
106761: PPUSH
// if not side or side > 8 then
106762: LD_VAR 0 1
106766: NOT
106767: PUSH
106768: LD_VAR 0 1
106772: PUSH
106773: LD_INT 8
106775: GREATER
106776: OR
106777: IFFALSE 106781
// exit ;
106779: GO 106968
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106781: LD_ADDR_VAR 0 4
106785: PUSH
106786: LD_INT 22
106788: PUSH
106789: LD_VAR 0 1
106793: PUSH
106794: EMPTY
106795: LIST
106796: LIST
106797: PUSH
106798: LD_INT 21
106800: PUSH
106801: LD_INT 3
106803: PUSH
106804: EMPTY
106805: LIST
106806: LIST
106807: PUSH
106808: EMPTY
106809: LIST
106810: LIST
106811: PPUSH
106812: CALL_OW 69
106816: ST_TO_ADDR
// if not tmp then
106817: LD_VAR 0 4
106821: NOT
106822: IFFALSE 106826
// exit ;
106824: GO 106968
// enable_addtolog := true ;
106826: LD_ADDR_OWVAR 81
106830: PUSH
106831: LD_INT 1
106833: ST_TO_ADDR
// AddToLog ( [ ) ;
106834: LD_STRING [
106836: PPUSH
106837: CALL_OW 561
// for i in tmp do
106841: LD_ADDR_VAR 0 3
106845: PUSH
106846: LD_VAR 0 4
106850: PUSH
106851: FOR_IN
106852: IFFALSE 106959
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106854: LD_STRING [
106856: PUSH
106857: LD_VAR 0 3
106861: PPUSH
106862: CALL_OW 266
106866: STR
106867: PUSH
106868: LD_STRING , 
106870: STR
106871: PUSH
106872: LD_VAR 0 3
106876: PPUSH
106877: CALL_OW 250
106881: STR
106882: PUSH
106883: LD_STRING , 
106885: STR
106886: PUSH
106887: LD_VAR 0 3
106891: PPUSH
106892: CALL_OW 251
106896: STR
106897: PUSH
106898: LD_STRING , 
106900: STR
106901: PUSH
106902: LD_VAR 0 3
106906: PPUSH
106907: CALL_OW 254
106911: STR
106912: PUSH
106913: LD_STRING , 
106915: STR
106916: PUSH
106917: LD_VAR 0 3
106921: PPUSH
106922: LD_INT 1
106924: PPUSH
106925: CALL_OW 268
106929: STR
106930: PUSH
106931: LD_STRING , 
106933: STR
106934: PUSH
106935: LD_VAR 0 3
106939: PPUSH
106940: LD_INT 2
106942: PPUSH
106943: CALL_OW 268
106947: STR
106948: PUSH
106949: LD_STRING ],
106951: STR
106952: PPUSH
106953: CALL_OW 561
// end ;
106957: GO 106851
106959: POP
106960: POP
// AddToLog ( ]; ) ;
106961: LD_STRING ];
106963: PPUSH
106964: CALL_OW 561
// end ;
106968: LD_VAR 0 2
106972: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106973: LD_INT 0
106975: PPUSH
106976: PPUSH
106977: PPUSH
106978: PPUSH
106979: PPUSH
// if not area or not rate or not max then
106980: LD_VAR 0 1
106984: NOT
106985: PUSH
106986: LD_VAR 0 2
106990: NOT
106991: OR
106992: PUSH
106993: LD_VAR 0 4
106997: NOT
106998: OR
106999: IFFALSE 107003
// exit ;
107001: GO 107195
// while 1 do
107003: LD_INT 1
107005: IFFALSE 107195
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107007: LD_ADDR_VAR 0 9
107011: PUSH
107012: LD_VAR 0 1
107016: PPUSH
107017: LD_INT 1
107019: PPUSH
107020: CALL_OW 287
107024: PUSH
107025: LD_INT 10
107027: MUL
107028: ST_TO_ADDR
// r := rate / 10 ;
107029: LD_ADDR_VAR 0 7
107033: PUSH
107034: LD_VAR 0 2
107038: PUSH
107039: LD_INT 10
107041: DIVREAL
107042: ST_TO_ADDR
// time := 1 1$00 ;
107043: LD_ADDR_VAR 0 8
107047: PUSH
107048: LD_INT 2100
107050: ST_TO_ADDR
// if amount < min then
107051: LD_VAR 0 9
107055: PUSH
107056: LD_VAR 0 3
107060: LESS
107061: IFFALSE 107079
// r := r * 2 else
107063: LD_ADDR_VAR 0 7
107067: PUSH
107068: LD_VAR 0 7
107072: PUSH
107073: LD_INT 2
107075: MUL
107076: ST_TO_ADDR
107077: GO 107105
// if amount > max then
107079: LD_VAR 0 9
107083: PUSH
107084: LD_VAR 0 4
107088: GREATER
107089: IFFALSE 107105
// r := r / 2 ;
107091: LD_ADDR_VAR 0 7
107095: PUSH
107096: LD_VAR 0 7
107100: PUSH
107101: LD_INT 2
107103: DIVREAL
107104: ST_TO_ADDR
// time := time / r ;
107105: LD_ADDR_VAR 0 8
107109: PUSH
107110: LD_VAR 0 8
107114: PUSH
107115: LD_VAR 0 7
107119: DIVREAL
107120: ST_TO_ADDR
// if time < 0 then
107121: LD_VAR 0 8
107125: PUSH
107126: LD_INT 0
107128: LESS
107129: IFFALSE 107146
// time := time * - 1 ;
107131: LD_ADDR_VAR 0 8
107135: PUSH
107136: LD_VAR 0 8
107140: PUSH
107141: LD_INT 1
107143: NEG
107144: MUL
107145: ST_TO_ADDR
// wait ( time ) ;
107146: LD_VAR 0 8
107150: PPUSH
107151: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107155: LD_INT 35
107157: PPUSH
107158: LD_INT 875
107160: PPUSH
107161: CALL_OW 12
107165: PPUSH
107166: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107170: LD_INT 1
107172: PPUSH
107173: LD_INT 5
107175: PPUSH
107176: CALL_OW 12
107180: PPUSH
107181: LD_VAR 0 1
107185: PPUSH
107186: LD_INT 1
107188: PPUSH
107189: CALL_OW 55
// end ;
107193: GO 107003
// end ;
107195: LD_VAR 0 5
107199: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107200: LD_INT 0
107202: PPUSH
107203: PPUSH
107204: PPUSH
107205: PPUSH
107206: PPUSH
107207: PPUSH
107208: PPUSH
107209: PPUSH
// if not turrets or not factories then
107210: LD_VAR 0 1
107214: NOT
107215: PUSH
107216: LD_VAR 0 2
107220: NOT
107221: OR
107222: IFFALSE 107226
// exit ;
107224: GO 107533
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107226: LD_ADDR_VAR 0 10
107230: PUSH
107231: LD_INT 5
107233: PUSH
107234: LD_INT 6
107236: PUSH
107237: EMPTY
107238: LIST
107239: LIST
107240: PUSH
107241: LD_INT 2
107243: PUSH
107244: LD_INT 4
107246: PUSH
107247: EMPTY
107248: LIST
107249: LIST
107250: PUSH
107251: LD_INT 3
107253: PUSH
107254: LD_INT 5
107256: PUSH
107257: EMPTY
107258: LIST
107259: LIST
107260: PUSH
107261: EMPTY
107262: LIST
107263: LIST
107264: LIST
107265: PUSH
107266: LD_INT 24
107268: PUSH
107269: LD_INT 25
107271: PUSH
107272: EMPTY
107273: LIST
107274: LIST
107275: PUSH
107276: LD_INT 23
107278: PUSH
107279: LD_INT 27
107281: PUSH
107282: EMPTY
107283: LIST
107284: LIST
107285: PUSH
107286: EMPTY
107287: LIST
107288: LIST
107289: PUSH
107290: LD_INT 42
107292: PUSH
107293: LD_INT 43
107295: PUSH
107296: EMPTY
107297: LIST
107298: LIST
107299: PUSH
107300: LD_INT 44
107302: PUSH
107303: LD_INT 46
107305: PUSH
107306: EMPTY
107307: LIST
107308: LIST
107309: PUSH
107310: LD_INT 45
107312: PUSH
107313: LD_INT 47
107315: PUSH
107316: EMPTY
107317: LIST
107318: LIST
107319: PUSH
107320: EMPTY
107321: LIST
107322: LIST
107323: LIST
107324: PUSH
107325: EMPTY
107326: LIST
107327: LIST
107328: LIST
107329: ST_TO_ADDR
// result := [ ] ;
107330: LD_ADDR_VAR 0 3
107334: PUSH
107335: EMPTY
107336: ST_TO_ADDR
// for i in turrets do
107337: LD_ADDR_VAR 0 4
107341: PUSH
107342: LD_VAR 0 1
107346: PUSH
107347: FOR_IN
107348: IFFALSE 107531
// begin nat := GetNation ( i ) ;
107350: LD_ADDR_VAR 0 7
107354: PUSH
107355: LD_VAR 0 4
107359: PPUSH
107360: CALL_OW 248
107364: ST_TO_ADDR
// weapon := 0 ;
107365: LD_ADDR_VAR 0 8
107369: PUSH
107370: LD_INT 0
107372: ST_TO_ADDR
// if not nat then
107373: LD_VAR 0 7
107377: NOT
107378: IFFALSE 107382
// continue ;
107380: GO 107347
// for j in list [ nat ] do
107382: LD_ADDR_VAR 0 5
107386: PUSH
107387: LD_VAR 0 10
107391: PUSH
107392: LD_VAR 0 7
107396: ARRAY
107397: PUSH
107398: FOR_IN
107399: IFFALSE 107440
// if GetBWeapon ( i ) = j [ 1 ] then
107401: LD_VAR 0 4
107405: PPUSH
107406: CALL_OW 269
107410: PUSH
107411: LD_VAR 0 5
107415: PUSH
107416: LD_INT 1
107418: ARRAY
107419: EQUAL
107420: IFFALSE 107438
// begin weapon := j [ 2 ] ;
107422: LD_ADDR_VAR 0 8
107426: PUSH
107427: LD_VAR 0 5
107431: PUSH
107432: LD_INT 2
107434: ARRAY
107435: ST_TO_ADDR
// break ;
107436: GO 107440
// end ;
107438: GO 107398
107440: POP
107441: POP
// if not weapon then
107442: LD_VAR 0 8
107446: NOT
107447: IFFALSE 107451
// continue ;
107449: GO 107347
// for k in factories do
107451: LD_ADDR_VAR 0 6
107455: PUSH
107456: LD_VAR 0 2
107460: PUSH
107461: FOR_IN
107462: IFFALSE 107527
// begin weapons := AvailableWeaponList ( k ) ;
107464: LD_ADDR_VAR 0 9
107468: PUSH
107469: LD_VAR 0 6
107473: PPUSH
107474: CALL_OW 478
107478: ST_TO_ADDR
// if not weapons then
107479: LD_VAR 0 9
107483: NOT
107484: IFFALSE 107488
// continue ;
107486: GO 107461
// if weapon in weapons then
107488: LD_VAR 0 8
107492: PUSH
107493: LD_VAR 0 9
107497: IN
107498: IFFALSE 107525
// begin result := [ i , weapon ] ;
107500: LD_ADDR_VAR 0 3
107504: PUSH
107505: LD_VAR 0 4
107509: PUSH
107510: LD_VAR 0 8
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: ST_TO_ADDR
// exit ;
107519: POP
107520: POP
107521: POP
107522: POP
107523: GO 107533
// end ; end ;
107525: GO 107461
107527: POP
107528: POP
// end ;
107529: GO 107347
107531: POP
107532: POP
// end ;
107533: LD_VAR 0 3
107537: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107538: LD_INT 0
107540: PPUSH
// if not side or side > 8 then
107541: LD_VAR 0 3
107545: NOT
107546: PUSH
107547: LD_VAR 0 3
107551: PUSH
107552: LD_INT 8
107554: GREATER
107555: OR
107556: IFFALSE 107560
// exit ;
107558: GO 107619
// if not range then
107560: LD_VAR 0 4
107564: NOT
107565: IFFALSE 107576
// range := - 12 ;
107567: LD_ADDR_VAR 0 4
107571: PUSH
107572: LD_INT 12
107574: NEG
107575: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107576: LD_VAR 0 1
107580: PPUSH
107581: LD_VAR 0 2
107585: PPUSH
107586: LD_VAR 0 3
107590: PPUSH
107591: LD_VAR 0 4
107595: PPUSH
107596: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107600: LD_VAR 0 1
107604: PPUSH
107605: LD_VAR 0 2
107609: PPUSH
107610: LD_VAR 0 3
107614: PPUSH
107615: CALL_OW 331
// end ;
107619: LD_VAR 0 5
107623: RET
// export function Video ( mode ) ; begin
107624: LD_INT 0
107626: PPUSH
// ingame_video = mode ;
107627: LD_ADDR_OWVAR 52
107631: PUSH
107632: LD_VAR 0 1
107636: ST_TO_ADDR
// interface_hidden = mode ;
107637: LD_ADDR_OWVAR 54
107641: PUSH
107642: LD_VAR 0 1
107646: ST_TO_ADDR
// end ;
107647: LD_VAR 0 2
107651: RET
// export function Join ( array , element ) ; begin
107652: LD_INT 0
107654: PPUSH
// result := array ^ element ;
107655: LD_ADDR_VAR 0 3
107659: PUSH
107660: LD_VAR 0 1
107664: PUSH
107665: LD_VAR 0 2
107669: ADD
107670: ST_TO_ADDR
// end ;
107671: LD_VAR 0 3
107675: RET
// export function JoinUnion ( array , element ) ; begin
107676: LD_INT 0
107678: PPUSH
// result := array union element ;
107679: LD_ADDR_VAR 0 3
107683: PUSH
107684: LD_VAR 0 1
107688: PUSH
107689: LD_VAR 0 2
107693: UNION
107694: ST_TO_ADDR
// end ;
107695: LD_VAR 0 3
107699: RET
// export function GetBehemoths ( side ) ; begin
107700: LD_INT 0
107702: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107703: LD_ADDR_VAR 0 2
107707: PUSH
107708: LD_INT 22
107710: PUSH
107711: LD_VAR 0 1
107715: PUSH
107716: EMPTY
107717: LIST
107718: LIST
107719: PUSH
107720: LD_INT 31
107722: PUSH
107723: LD_INT 25
107725: PUSH
107726: EMPTY
107727: LIST
107728: LIST
107729: PUSH
107730: EMPTY
107731: LIST
107732: LIST
107733: PPUSH
107734: CALL_OW 69
107738: ST_TO_ADDR
// end ;
107739: LD_VAR 0 2
107743: RET
// export function Shuffle ( array ) ; var i , index ; begin
107744: LD_INT 0
107746: PPUSH
107747: PPUSH
107748: PPUSH
// result := [ ] ;
107749: LD_ADDR_VAR 0 2
107753: PUSH
107754: EMPTY
107755: ST_TO_ADDR
// if not array then
107756: LD_VAR 0 1
107760: NOT
107761: IFFALSE 107765
// exit ;
107763: GO 107864
// Randomize ;
107765: CALL_OW 10
// for i = array downto 1 do
107769: LD_ADDR_VAR 0 3
107773: PUSH
107774: DOUBLE
107775: LD_VAR 0 1
107779: INC
107780: ST_TO_ADDR
107781: LD_INT 1
107783: PUSH
107784: FOR_DOWNTO
107785: IFFALSE 107862
// begin index := rand ( 1 , array ) ;
107787: LD_ADDR_VAR 0 4
107791: PUSH
107792: LD_INT 1
107794: PPUSH
107795: LD_VAR 0 1
107799: PPUSH
107800: CALL_OW 12
107804: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107805: LD_ADDR_VAR 0 2
107809: PUSH
107810: LD_VAR 0 2
107814: PPUSH
107815: LD_VAR 0 2
107819: PUSH
107820: LD_INT 1
107822: PLUS
107823: PPUSH
107824: LD_VAR 0 1
107828: PUSH
107829: LD_VAR 0 4
107833: ARRAY
107834: PPUSH
107835: CALL_OW 2
107839: ST_TO_ADDR
// array := Delete ( array , index ) ;
107840: LD_ADDR_VAR 0 1
107844: PUSH
107845: LD_VAR 0 1
107849: PPUSH
107850: LD_VAR 0 4
107854: PPUSH
107855: CALL_OW 3
107859: ST_TO_ADDR
// end ;
107860: GO 107784
107862: POP
107863: POP
// end ;
107864: LD_VAR 0 2
107868: RET
// export function GetBaseMaterials ( base ) ; begin
107869: LD_INT 0
107871: PPUSH
// result := [ 0 , 0 , 0 ] ;
107872: LD_ADDR_VAR 0 2
107876: PUSH
107877: LD_INT 0
107879: PUSH
107880: LD_INT 0
107882: PUSH
107883: LD_INT 0
107885: PUSH
107886: EMPTY
107887: LIST
107888: LIST
107889: LIST
107890: ST_TO_ADDR
// if not base then
107891: LD_VAR 0 1
107895: NOT
107896: IFFALSE 107900
// exit ;
107898: GO 107949
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107900: LD_ADDR_VAR 0 2
107904: PUSH
107905: LD_VAR 0 1
107909: PPUSH
107910: LD_INT 1
107912: PPUSH
107913: CALL_OW 275
107917: PUSH
107918: LD_VAR 0 1
107922: PPUSH
107923: LD_INT 2
107925: PPUSH
107926: CALL_OW 275
107930: PUSH
107931: LD_VAR 0 1
107935: PPUSH
107936: LD_INT 3
107938: PPUSH
107939: CALL_OW 275
107943: PUSH
107944: EMPTY
107945: LIST
107946: LIST
107947: LIST
107948: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107949: LD_VAR 0 2
107953: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107954: LD_INT 0
107956: PPUSH
107957: PPUSH
107958: PPUSH
107959: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107960: LD_VAR 0 1
107964: PPUSH
107965: CALL_OW 264
107969: PUSH
107970: LD_EXP 99
107974: EQUAL
107975: IFFALSE 108047
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107977: LD_INT 68
107979: PPUSH
107980: LD_VAR 0 1
107984: PPUSH
107985: CALL_OW 255
107989: PPUSH
107990: CALL_OW 321
107994: PUSH
107995: LD_INT 2
107997: EQUAL
107998: IFFALSE 108010
// eff := 70 else
108000: LD_ADDR_VAR 0 6
108004: PUSH
108005: LD_INT 70
108007: ST_TO_ADDR
108008: GO 108018
// eff := 30 ;
108010: LD_ADDR_VAR 0 6
108014: PUSH
108015: LD_INT 30
108017: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
108018: LD_VAR 0 1
108022: PPUSH
108023: CALL_OW 250
108027: PPUSH
108028: LD_VAR 0 1
108032: PPUSH
108033: CALL_OW 251
108037: PPUSH
108038: LD_VAR 0 6
108042: PPUSH
108043: CALL_OW 495
// end ; end ;
108047: LD_VAR 0 4
108051: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
108052: LD_INT 0
108054: PPUSH
108055: PPUSH
108056: PPUSH
108057: PPUSH
108058: PPUSH
108059: PPUSH
// if cmd = 124 then
108060: LD_VAR 0 1
108064: PUSH
108065: LD_INT 124
108067: EQUAL
108068: IFFALSE 108274
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
108070: LD_ADDR_VAR 0 5
108074: PUSH
108075: LD_INT 2
108077: PUSH
108078: LD_INT 34
108080: PUSH
108081: LD_INT 53
108083: PUSH
108084: EMPTY
108085: LIST
108086: LIST
108087: PUSH
108088: LD_INT 34
108090: PUSH
108091: LD_INT 14
108093: PUSH
108094: EMPTY
108095: LIST
108096: LIST
108097: PUSH
108098: EMPTY
108099: LIST
108100: LIST
108101: LIST
108102: PPUSH
108103: CALL_OW 69
108107: ST_TO_ADDR
// if not tmp then
108108: LD_VAR 0 5
108112: NOT
108113: IFFALSE 108117
// exit ;
108115: GO 108274
// for i in tmp do
108117: LD_ADDR_VAR 0 3
108121: PUSH
108122: LD_VAR 0 5
108126: PUSH
108127: FOR_IN
108128: IFFALSE 108272
// begin taskList := GetTaskList ( i ) ;
108130: LD_ADDR_VAR 0 6
108134: PUSH
108135: LD_VAR 0 3
108139: PPUSH
108140: CALL_OW 437
108144: ST_TO_ADDR
// if not taskList then
108145: LD_VAR 0 6
108149: NOT
108150: IFFALSE 108154
// continue ;
108152: GO 108127
// for j = 1 to taskList do
108154: LD_ADDR_VAR 0 4
108158: PUSH
108159: DOUBLE
108160: LD_INT 1
108162: DEC
108163: ST_TO_ADDR
108164: LD_VAR 0 6
108168: PUSH
108169: FOR_TO
108170: IFFALSE 108268
// if taskList [ j ] [ 1 ] = | then
108172: LD_VAR 0 6
108176: PUSH
108177: LD_VAR 0 4
108181: ARRAY
108182: PUSH
108183: LD_INT 1
108185: ARRAY
108186: PUSH
108187: LD_STRING |
108189: EQUAL
108190: IFFALSE 108266
// begin _taskList := Delete ( taskList , 1 ) ;
108192: LD_ADDR_VAR 0 7
108196: PUSH
108197: LD_VAR 0 6
108201: PPUSH
108202: LD_INT 1
108204: PPUSH
108205: CALL_OW 3
108209: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
108210: LD_VAR 0 3
108214: PPUSH
108215: LD_VAR 0 7
108219: PPUSH
108220: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
108224: LD_VAR 0 3
108228: PPUSH
108229: LD_VAR 0 6
108233: PUSH
108234: LD_VAR 0 4
108238: ARRAY
108239: PUSH
108240: LD_INT 2
108242: ARRAY
108243: PPUSH
108244: LD_VAR 0 6
108248: PUSH
108249: LD_VAR 0 4
108253: ARRAY
108254: PUSH
108255: LD_INT 3
108257: ARRAY
108258: PPUSH
108259: LD_INT 8
108261: PPUSH
108262: CALL 108279 0 4
// end ;
108266: GO 108169
108268: POP
108269: POP
// end ;
108270: GO 108127
108272: POP
108273: POP
// end ; end ;
108274: LD_VAR 0 2
108278: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108279: LD_INT 0
108281: PPUSH
108282: PPUSH
108283: PPUSH
108284: PPUSH
108285: PPUSH
108286: PPUSH
108287: PPUSH
108288: PPUSH
108289: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
108290: LD_VAR 0 1
108294: NOT
108295: PUSH
108296: LD_VAR 0 2
108300: PPUSH
108301: LD_VAR 0 3
108305: PPUSH
108306: CALL_OW 488
108310: NOT
108311: OR
108312: PUSH
108313: LD_VAR 0 4
108317: NOT
108318: OR
108319: IFFALSE 108323
// exit ;
108321: GO 108663
// list := [ ] ;
108323: LD_ADDR_VAR 0 13
108327: PUSH
108328: EMPTY
108329: ST_TO_ADDR
// if x - r < 0 then
108330: LD_VAR 0 2
108334: PUSH
108335: LD_VAR 0 4
108339: MINUS
108340: PUSH
108341: LD_INT 0
108343: LESS
108344: IFFALSE 108356
// min_x := 0 else
108346: LD_ADDR_VAR 0 7
108350: PUSH
108351: LD_INT 0
108353: ST_TO_ADDR
108354: GO 108372
// min_x := x - r ;
108356: LD_ADDR_VAR 0 7
108360: PUSH
108361: LD_VAR 0 2
108365: PUSH
108366: LD_VAR 0 4
108370: MINUS
108371: ST_TO_ADDR
// if y - r < 0 then
108372: LD_VAR 0 3
108376: PUSH
108377: LD_VAR 0 4
108381: MINUS
108382: PUSH
108383: LD_INT 0
108385: LESS
108386: IFFALSE 108398
// min_y := 0 else
108388: LD_ADDR_VAR 0 8
108392: PUSH
108393: LD_INT 0
108395: ST_TO_ADDR
108396: GO 108414
// min_y := y - r ;
108398: LD_ADDR_VAR 0 8
108402: PUSH
108403: LD_VAR 0 3
108407: PUSH
108408: LD_VAR 0 4
108412: MINUS
108413: ST_TO_ADDR
// max_x := x + r ;
108414: LD_ADDR_VAR 0 9
108418: PUSH
108419: LD_VAR 0 2
108423: PUSH
108424: LD_VAR 0 4
108428: PLUS
108429: ST_TO_ADDR
// max_y := y + r ;
108430: LD_ADDR_VAR 0 10
108434: PUSH
108435: LD_VAR 0 3
108439: PUSH
108440: LD_VAR 0 4
108444: PLUS
108445: ST_TO_ADDR
// for _x = min_x to max_x do
108446: LD_ADDR_VAR 0 11
108450: PUSH
108451: DOUBLE
108452: LD_VAR 0 7
108456: DEC
108457: ST_TO_ADDR
108458: LD_VAR 0 9
108462: PUSH
108463: FOR_TO
108464: IFFALSE 108581
// for _y = min_y to max_y do
108466: LD_ADDR_VAR 0 12
108470: PUSH
108471: DOUBLE
108472: LD_VAR 0 8
108476: DEC
108477: ST_TO_ADDR
108478: LD_VAR 0 10
108482: PUSH
108483: FOR_TO
108484: IFFALSE 108577
// begin if not ValidHex ( _x , _y ) then
108486: LD_VAR 0 11
108490: PPUSH
108491: LD_VAR 0 12
108495: PPUSH
108496: CALL_OW 488
108500: NOT
108501: IFFALSE 108505
// continue ;
108503: GO 108483
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108505: LD_VAR 0 11
108509: PPUSH
108510: LD_VAR 0 12
108514: PPUSH
108515: CALL_OW 351
108519: PUSH
108520: LD_VAR 0 11
108524: PPUSH
108525: LD_VAR 0 12
108529: PPUSH
108530: CALL_OW 554
108534: AND
108535: IFFALSE 108575
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108537: LD_ADDR_VAR 0 13
108541: PUSH
108542: LD_VAR 0 13
108546: PPUSH
108547: LD_VAR 0 13
108551: PUSH
108552: LD_INT 1
108554: PLUS
108555: PPUSH
108556: LD_VAR 0 11
108560: PUSH
108561: LD_VAR 0 12
108565: PUSH
108566: EMPTY
108567: LIST
108568: LIST
108569: PPUSH
108570: CALL_OW 2
108574: ST_TO_ADDR
// end ;
108575: GO 108483
108577: POP
108578: POP
108579: GO 108463
108581: POP
108582: POP
// if not list then
108583: LD_VAR 0 13
108587: NOT
108588: IFFALSE 108592
// exit ;
108590: GO 108663
// for i in list do
108592: LD_ADDR_VAR 0 6
108596: PUSH
108597: LD_VAR 0 13
108601: PUSH
108602: FOR_IN
108603: IFFALSE 108661
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108605: LD_VAR 0 1
108609: PPUSH
108610: LD_STRING M
108612: PUSH
108613: LD_VAR 0 6
108617: PUSH
108618: LD_INT 1
108620: ARRAY
108621: PUSH
108622: LD_VAR 0 6
108626: PUSH
108627: LD_INT 2
108629: ARRAY
108630: PUSH
108631: LD_INT 0
108633: PUSH
108634: LD_INT 0
108636: PUSH
108637: LD_INT 0
108639: PUSH
108640: LD_INT 0
108642: PUSH
108643: EMPTY
108644: LIST
108645: LIST
108646: LIST
108647: LIST
108648: LIST
108649: LIST
108650: LIST
108651: PUSH
108652: EMPTY
108653: LIST
108654: PPUSH
108655: CALL_OW 447
108659: GO 108602
108661: POP
108662: POP
// end ;
108663: LD_VAR 0 5
108667: RET
