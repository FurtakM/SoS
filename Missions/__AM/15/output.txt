// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39601 0 0
// InitNature ;
  19: CALL 39469 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12660 0 0
// PrepareRussian ;
  40: CALL 7610 0 0
// PrepareLegion ;
  44: CALL 4678 0 0
// PreparePowell ;
  48: CALL 3212 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17590 0 0
// MC_Start ( ) ;
  60: CALL 41781 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 64577 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 64670 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 64020 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63835 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 64577 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 64670 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63835 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 64020 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64450 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 63498 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 64577 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 64670 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63835 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 64577 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 64670 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 63727 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64988 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64159 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64450 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64450 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64782 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63835 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64401 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 70309 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1942
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1879: LD_INT 5
1881: PUSH
1882: LD_INT 5
1884: PUSH
1885: LD_INT 3
1887: PUSH
1888: LD_INT 3
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: PUSH
1897: LD_OWVAR 67
1901: ARRAY
1902: PPUSH
1903: LD_INT 3
1905: PPUSH
1906: LD_INT 1
1908: PPUSH
1909: LD_INT 9
1911: PUSH
1912: LD_INT 9
1914: PUSH
1915: LD_INT 5
1917: PUSH
1918: LD_INT 5
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: PUSH
1927: LD_OWVAR 67
1931: ARRAY
1932: PPUSH
1933: LD_INT 100
1935: PPUSH
1936: CALL 75233 0 5
1940: GO 2001
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1942: LD_EXP 4
1946: PUSH
1947: LD_INT 1
1949: ARRAY
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PPUSH
1955: LD_EXP 4
1959: PUSH
1960: LD_INT 2
1962: ARRAY
1963: PUSH
1964: LD_INT 1
1966: ARRAY
1967: PPUSH
1968: LD_EXP 4
1972: PUSH
1973: LD_INT 3
1975: ARRAY
1976: PUSH
1977: LD_INT 1
1979: ARRAY
1980: PPUSH
1981: LD_EXP 4
1985: PUSH
1986: LD_INT 4
1988: ARRAY
1989: PUSH
1990: LD_INT 1
1992: ARRAY
1993: PPUSH
1994: LD_INT 30
1996: PPUSH
1997: CALL 75233 0 5
// JMMNewVeh := CreateVehicle ;
2001: LD_ADDR_EXP 59
2005: PUSH
2006: CALL_OW 45
2010: ST_TO_ADDR
// if not JMMNewVeh then
2011: LD_EXP 59
2015: NOT
2016: IFFALSE 2047
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2018: LD_INT 5
2020: PPUSH
2021: LD_INT 3
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: LD_INT 9
2029: PPUSH
2030: LD_INT 100
2032: PPUSH
2033: CALL 75233 0 5
// JMMNewVeh := CreateVehicle ;
2037: LD_ADDR_EXP 59
2041: PUSH
2042: CALL_OW 45
2046: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2047: LD_EXP 59
2051: PPUSH
2052: LD_INT 4
2054: PPUSH
2055: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2059: LD_EXP 59
2063: PPUSH
2064: LD_INT 1
2066: NEG
2067: PPUSH
2068: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2072: LD_EXP 59
2076: PPUSH
2077: LD_INT 79
2079: PPUSH
2080: LD_INT 91
2082: PPUSH
2083: LD_INT 0
2085: PPUSH
2086: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2090: LD_EXP 40
2094: PPUSH
2095: LD_EXP 59
2099: PPUSH
2100: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2104: LD_EXP 6
2108: PUSH
2109: LD_EXP 2
2113: NOT
2114: AND
2115: IFFALSE 2373
// begin if not JMMGirlVeh then
2117: LD_EXP 5
2121: NOT
2122: IFFALSE 2145
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2124: LD_INT 3
2126: PPUSH
2127: LD_INT 3
2129: PPUSH
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 9
2135: PPUSH
2136: LD_INT 100
2138: PPUSH
2139: CALL 75233 0 5
2143: GO 2204
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2145: LD_EXP 5
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 1
2156: ARRAY
2157: PPUSH
2158: LD_EXP 5
2162: PUSH
2163: LD_INT 2
2165: ARRAY
2166: PUSH
2167: LD_INT 1
2169: ARRAY
2170: PPUSH
2171: LD_EXP 5
2175: PUSH
2176: LD_INT 3
2178: ARRAY
2179: PUSH
2180: LD_INT 1
2182: ARRAY
2183: PPUSH
2184: LD_EXP 5
2188: PUSH
2189: LD_INT 4
2191: ARRAY
2192: PUSH
2193: LD_INT 1
2195: ARRAY
2196: PPUSH
2197: LD_INT 30
2199: PPUSH
2200: CALL 75233 0 5
// GirlNewVeh := CreateVehicle ;
2204: LD_ADDR_EXP 60
2208: PUSH
2209: CALL_OW 45
2213: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2214: LD_EXP 60
2218: PPUSH
2219: LD_INT 4
2221: PPUSH
2222: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2226: LD_EXP 60
2230: PPUSH
2231: LD_INT 82
2233: PPUSH
2234: LD_INT 96
2236: PPUSH
2237: LD_INT 0
2239: PPUSH
2240: CALL_OW 48
// if JMMGirl = 1 then
2244: LD_EXP 7
2248: PUSH
2249: LD_INT 1
2251: EQUAL
2252: IFFALSE 2287
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2254: LD_ADDR_EXP 41
2258: PUSH
2259: LD_STRING Joan
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_STRING 14_
2267: PPUSH
2268: CALL 70309 0 3
2272: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2273: LD_EXP 41
2277: PPUSH
2278: LD_EXP 60
2282: PPUSH
2283: CALL_OW 52
// end ; if JMMGirl = 2 then
2287: LD_EXP 7
2291: PUSH
2292: LD_INT 2
2294: EQUAL
2295: IFFALSE 2330
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2297: LD_ADDR_EXP 43
2301: PUSH
2302: LD_STRING Lisa
2304: PPUSH
2305: LD_INT 1
2307: PPUSH
2308: LD_STRING 14_
2310: PPUSH
2311: CALL 70309 0 3
2315: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2316: LD_EXP 43
2320: PPUSH
2321: LD_EXP 60
2325: PPUSH
2326: CALL_OW 52
// end ; if JMMGirl = 3 then
2330: LD_EXP 7
2334: PUSH
2335: LD_INT 3
2337: EQUAL
2338: IFFALSE 2373
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2340: LD_ADDR_EXP 55
2344: PUSH
2345: LD_STRING Connie
2347: PPUSH
2348: LD_INT 1
2350: PPUSH
2351: LD_STRING 14_
2353: PPUSH
2354: CALL 70309 0 3
2358: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2359: LD_EXP 55
2363: PPUSH
2364: LD_EXP 60
2368: PPUSH
2369: CALL_OW 52
// end ; end ; end ;
2373: LD_VAR 0 1
2377: RET
// export function PrepareStevensSquad ; var tmp ; begin
2378: LD_INT 0
2380: PPUSH
2381: PPUSH
// uc_side := 1 ;
2382: LD_ADDR_OWVAR 20
2386: PUSH
2387: LD_INT 1
2389: ST_TO_ADDR
// uc_nation := 1 ;
2390: LD_ADDR_OWVAR 21
2394: PUSH
2395: LD_INT 1
2397: ST_TO_ADDR
// tmp := [ ] ;
2398: LD_ADDR_VAR 0 2
2402: PUSH
2403: EMPTY
2404: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2405: LD_ADDR_EXP 42
2409: PUSH
2410: LD_STRING Stevens
2412: PPUSH
2413: LD_EXP 1
2417: NOT
2418: PPUSH
2419: LD_STRING 13f_
2421: PPUSH
2422: CALL 70309 0 3
2426: ST_TO_ADDR
// if not Stevens then
2427: LD_EXP 42
2431: NOT
2432: IFFALSE 2546
// begin hc_name = Baker Smith ;
2434: LD_ADDR_OWVAR 26
2438: PUSH
2439: LD_STRING Baker Smith
2441: ST_TO_ADDR
// hc_gallery = us ;
2442: LD_ADDR_OWVAR 33
2446: PUSH
2447: LD_STRING us
2449: ST_TO_ADDR
// hc_face_number := 29 ;
2450: LD_ADDR_OWVAR 34
2454: PUSH
2455: LD_INT 29
2457: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2458: LD_INT 1
2460: PPUSH
2461: LD_INT 10
2463: PPUSH
2464: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2468: LD_ADDR_OWVAR 30
2472: PUSH
2473: LD_INT 2
2475: PUSH
2476: LD_INT 2
2478: PUSH
2479: LD_INT 0
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: EMPTY
2486: LIST
2487: LIST
2488: LIST
2489: LIST
2490: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2491: LD_ADDR_OWVAR 31
2495: PUSH
2496: LD_INT 4
2498: PUSH
2499: LD_INT 5
2501: PUSH
2502: LD_INT 2
2504: PUSH
2505: LD_INT 10
2507: PUSH
2508: EMPTY
2509: LIST
2510: LIST
2511: LIST
2512: LIST
2513: ST_TO_ADDR
// Baker := CreateHuman ;
2514: LD_ADDR_EXP 56
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2524: LD_ADDR_VAR 0 2
2528: PUSH
2529: LD_VAR 0 2
2533: PUSH
2534: LD_EXP 56
2538: ADD
2539: ST_TO_ADDR
// InitHc ;
2540: CALL_OW 19
// end else
2544: GO 2562
// tmp := tmp ^ Stevens ;
2546: LD_ADDR_VAR 0 2
2550: PUSH
2551: LD_VAR 0 2
2555: PUSH
2556: LD_EXP 42
2560: ADD
2561: ST_TO_ADDR
// if not Lisa then
2562: LD_EXP 43
2566: NOT
2567: IFFALSE 2613
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2569: LD_ADDR_EXP 43
2573: PUSH
2574: LD_STRING Lisa
2576: PPUSH
2577: LD_EXP 1
2581: NOT
2582: PPUSH
2583: LD_STRING 13f_
2585: PPUSH
2586: CALL 70309 0 3
2590: ST_TO_ADDR
// if Lisa then
2591: LD_EXP 43
2595: IFFALSE 2613
// tmp := tmp ^ Lisa ;
2597: LD_ADDR_VAR 0 2
2601: PUSH
2602: LD_VAR 0 2
2606: PUSH
2607: LD_EXP 43
2611: ADD
2612: ST_TO_ADDR
// end ; if not Donaldson then
2613: LD_EXP 44
2617: NOT
2618: IFFALSE 2664
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2620: LD_ADDR_EXP 44
2624: PUSH
2625: LD_STRING Donaldson
2627: PPUSH
2628: LD_EXP 1
2632: NOT
2633: PPUSH
2634: LD_STRING 13f_
2636: PPUSH
2637: CALL 70309 0 3
2641: ST_TO_ADDR
// if Donaldson then
2642: LD_EXP 44
2646: IFFALSE 2664
// tmp := tmp ^ Donaldson ;
2648: LD_ADDR_VAR 0 2
2652: PUSH
2653: LD_VAR 0 2
2657: PUSH
2658: LD_EXP 44
2662: ADD
2663: ST_TO_ADDR
// end ; if not Bobby then
2664: LD_EXP 45
2668: NOT
2669: IFFALSE 2715
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2671: LD_ADDR_EXP 45
2675: PUSH
2676: LD_STRING Bobby
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_STRING 13f_
2687: PPUSH
2688: CALL 70309 0 3
2692: ST_TO_ADDR
// if Bobby then
2693: LD_EXP 45
2697: IFFALSE 2715
// tmp := tmp ^ Bobby ;
2699: LD_ADDR_VAR 0 2
2703: PUSH
2704: LD_VAR 0 2
2708: PUSH
2709: LD_EXP 45
2713: ADD
2714: ST_TO_ADDR
// end ; if not Cyrus then
2715: LD_EXP 46
2719: NOT
2720: IFFALSE 2766
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2722: LD_ADDR_EXP 46
2726: PUSH
2727: LD_STRING Cyrus
2729: PPUSH
2730: LD_EXP 1
2734: NOT
2735: PPUSH
2736: LD_STRING 13f_
2738: PPUSH
2739: CALL 70309 0 3
2743: ST_TO_ADDR
// if Cyrus then
2744: LD_EXP 46
2748: IFFALSE 2766
// tmp := tmp ^ Cyrus ;
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_VAR 0 2
2759: PUSH
2760: LD_EXP 46
2764: ADD
2765: ST_TO_ADDR
// end ; if not Brown then
2766: LD_EXP 48
2770: NOT
2771: IFFALSE 2817
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2773: LD_ADDR_EXP 48
2777: PUSH
2778: LD_STRING Brown
2780: PPUSH
2781: LD_EXP 1
2785: NOT
2786: PPUSH
2787: LD_STRING 13f_
2789: PPUSH
2790: CALL 70309 0 3
2794: ST_TO_ADDR
// if Brown then
2795: LD_EXP 48
2799: IFFALSE 2817
// tmp := tmp ^ Brown ;
2801: LD_ADDR_VAR 0 2
2805: PUSH
2806: LD_VAR 0 2
2810: PUSH
2811: LD_EXP 48
2815: ADD
2816: ST_TO_ADDR
// end ; if not Gladstone then
2817: LD_EXP 49
2821: NOT
2822: IFFALSE 2868
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2824: LD_ADDR_EXP 49
2828: PUSH
2829: LD_STRING Gladstone
2831: PPUSH
2832: LD_EXP 1
2836: NOT
2837: PPUSH
2838: LD_STRING 13f_
2840: PPUSH
2841: CALL 70309 0 3
2845: ST_TO_ADDR
// if Gladstone then
2846: LD_EXP 49
2850: IFFALSE 2868
// tmp := tmp ^ Gladstone ;
2852: LD_ADDR_VAR 0 2
2856: PUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_EXP 49
2866: ADD
2867: ST_TO_ADDR
// end ; if not Houten then
2868: LD_EXP 50
2872: NOT
2873: IFFALSE 2919
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2875: LD_ADDR_EXP 50
2879: PUSH
2880: LD_STRING Houten
2882: PPUSH
2883: LD_EXP 1
2887: NOT
2888: PPUSH
2889: LD_STRING 13f_
2891: PPUSH
2892: CALL 70309 0 3
2896: ST_TO_ADDR
// if Houten then
2897: LD_EXP 50
2901: IFFALSE 2919
// tmp := tmp ^ Houten ;
2903: LD_ADDR_VAR 0 2
2907: PUSH
2908: LD_VAR 0 2
2912: PUSH
2913: LD_EXP 50
2917: ADD
2918: ST_TO_ADDR
// end ; if not Cornel then
2919: LD_EXP 51
2923: NOT
2924: IFFALSE 2970
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2926: LD_ADDR_EXP 51
2930: PUSH
2931: LD_STRING Cornell
2933: PPUSH
2934: LD_EXP 1
2938: NOT
2939: PPUSH
2940: LD_STRING 13f_
2942: PPUSH
2943: CALL 70309 0 3
2947: ST_TO_ADDR
// if Cornel then
2948: LD_EXP 51
2952: IFFALSE 2970
// tmp := tmp ^ Cornel ;
2954: LD_ADDR_VAR 0 2
2958: PUSH
2959: LD_VAR 0 2
2963: PUSH
2964: LD_EXP 51
2968: ADD
2969: ST_TO_ADDR
// end ; if not Gary then
2970: LD_EXP 52
2974: NOT
2975: IFFALSE 3021
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2977: LD_ADDR_EXP 52
2981: PUSH
2982: LD_STRING Gary
2984: PPUSH
2985: LD_EXP 1
2989: NOT
2990: PPUSH
2991: LD_STRING 13f_
2993: PPUSH
2994: CALL 70309 0 3
2998: ST_TO_ADDR
// if Gary then
2999: LD_EXP 52
3003: IFFALSE 3021
// tmp := tmp ^ Gary ;
3005: LD_ADDR_VAR 0 2
3009: PUSH
3010: LD_VAR 0 2
3014: PUSH
3015: LD_EXP 52
3019: ADD
3020: ST_TO_ADDR
// end ; if not Frank then
3021: LD_EXP 53
3025: NOT
3026: IFFALSE 3072
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3028: LD_ADDR_EXP 53
3032: PUSH
3033: LD_STRING Frank
3035: PPUSH
3036: LD_EXP 1
3040: NOT
3041: PPUSH
3042: LD_STRING 13f_
3044: PPUSH
3045: CALL 70309 0 3
3049: ST_TO_ADDR
// if Frank then
3050: LD_EXP 53
3054: IFFALSE 3072
// tmp := tmp ^ Frank ;
3056: LD_ADDR_VAR 0 2
3060: PUSH
3061: LD_VAR 0 2
3065: PUSH
3066: LD_EXP 53
3070: ADD
3071: ST_TO_ADDR
// end ; if not Kikuchi then
3072: LD_EXP 54
3076: NOT
3077: IFFALSE 3123
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3079: LD_ADDR_EXP 54
3083: PUSH
3084: LD_STRING Kikuchi
3086: PPUSH
3087: LD_EXP 1
3091: NOT
3092: PPUSH
3093: LD_STRING 13f_
3095: PPUSH
3096: CALL 70309 0 3
3100: ST_TO_ADDR
// if Kikuchi then
3101: LD_EXP 54
3105: IFFALSE 3123
// tmp := tmp ^ Kikuchi ;
3107: LD_ADDR_VAR 0 2
3111: PUSH
3112: LD_VAR 0 2
3116: PUSH
3117: LD_EXP 54
3121: ADD
3122: ST_TO_ADDR
// end ; if not DeltaDoctor then
3123: LD_EXP 58
3127: NOT
3128: IFFALSE 3174
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3130: LD_ADDR_EXP 58
3134: PUSH
3135: LD_STRING DeltaDoctor
3137: PPUSH
3138: LD_EXP 1
3142: NOT
3143: PPUSH
3144: LD_STRING 13f_
3146: PPUSH
3147: CALL 70309 0 3
3151: ST_TO_ADDR
// if Bobby then
3152: LD_EXP 45
3156: IFFALSE 3174
// tmp := tmp ^ DeltaDoctor ;
3158: LD_ADDR_VAR 0 2
3162: PUSH
3163: LD_VAR 0 2
3167: PUSH
3168: LD_EXP 58
3172: ADD
3173: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3174: LD_ADDR_VAR 0 2
3178: PUSH
3179: LD_VAR 0 2
3183: PUSH
3184: LD_STRING 13_other_survivors
3186: PPUSH
3187: CALL_OW 31
3191: UNION
3192: ST_TO_ADDR
// result := tmp diff 0 ;
3193: LD_ADDR_VAR 0 1
3197: PUSH
3198: LD_VAR 0 2
3202: PUSH
3203: LD_INT 0
3205: DIFF
3206: ST_TO_ADDR
// end ; end_of_file
3207: LD_VAR 0 1
3211: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
// uc_side := 4 ;
3224: LD_ADDR_OWVAR 20
3228: PUSH
3229: LD_INT 4
3231: ST_TO_ADDR
// uc_nation := 1 ;
3232: LD_ADDR_OWVAR 21
3236: PUSH
3237: LD_INT 1
3239: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3240: LD_INT 387
3242: PPUSH
3243: CALL_OW 274
3247: PPUSH
3248: LD_INT 1
3250: PPUSH
3251: LD_INT 3500
3253: PUSH
3254: LD_INT 3000
3256: PUSH
3257: LD_INT 2500
3259: PUSH
3260: LD_INT 2000
3262: PUSH
3263: EMPTY
3264: LIST
3265: LIST
3266: LIST
3267: LIST
3268: PUSH
3269: LD_OWVAR 67
3273: ARRAY
3274: PPUSH
3275: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3279: LD_INT 387
3281: PPUSH
3282: CALL_OW 274
3286: PPUSH
3287: LD_INT 2
3289: PPUSH
3290: LD_INT 400
3292: PPUSH
3293: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3297: LD_INT 387
3299: PPUSH
3300: CALL_OW 274
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 10
3310: PPUSH
3311: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3315: LD_INT 387
3317: PPUSH
3318: LD_STRING sigma
3320: PPUSH
3321: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3325: LD_ADDR_EXP 61
3329: PUSH
3330: LD_STRING Powell
3332: PPUSH
3333: CALL_OW 25
3337: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3338: LD_EXP 61
3342: PPUSH
3343: LD_INT 57
3345: PPUSH
3346: LD_INT 94
3348: PPUSH
3349: LD_INT 0
3351: PPUSH
3352: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3356: LD_EXP 61
3360: PPUSH
3361: LD_INT 58
3363: PPUSH
3364: LD_INT 94
3366: PPUSH
3367: CALL_OW 118
// vip := [ ] ;
3371: LD_ADDR_EXP 62
3375: PUSH
3376: EMPTY
3377: ST_TO_ADDR
// extraSquad := [ ] ;
3378: LD_ADDR_EXP 63
3382: PUSH
3383: EMPTY
3384: ST_TO_ADDR
// tmp := [ ] ;
3385: LD_ADDR_VAR 0 5
3389: PUSH
3390: EMPTY
3391: ST_TO_ADDR
// if JMMGirl <> 2 then
3392: LD_EXP 7
3396: PUSH
3397: LD_INT 2
3399: NONEQUAL
3400: IFFALSE 3424
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3402: LD_ADDR_EXP 43
3406: PUSH
3407: LD_STRING Lisa
3409: PPUSH
3410: LD_EXP 1
3414: NOT
3415: PPUSH
3416: LD_STRING 13s_
3418: PPUSH
3419: CALL 70309 0 3
3423: ST_TO_ADDR
// if Lisa then
3424: LD_EXP 43
3428: IFFALSE 3446
// tmp := tmp ^ Lisa ;
3430: LD_ADDR_VAR 0 5
3434: PUSH
3435: LD_VAR 0 5
3439: PUSH
3440: LD_EXP 43
3444: ADD
3445: ST_TO_ADDR
// if JMMGirl < 3 then
3446: LD_EXP 7
3450: PUSH
3451: LD_INT 3
3453: LESS
3454: IFFALSE 3485
// begin Connie := NewCharacter ( Coonie ) ;
3456: LD_ADDR_EXP 55
3460: PUSH
3461: LD_STRING Coonie
3463: PPUSH
3464: CALL_OW 25
3468: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3469: LD_ADDR_VAR 0 5
3473: PUSH
3474: LD_VAR 0 5
3478: PUSH
3479: LD_EXP 55
3483: ADD
3484: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3485: LD_ADDR_EXP 44
3489: PUSH
3490: LD_STRING Donaldson
3492: PPUSH
3493: LD_EXP 1
3497: NOT
3498: PPUSH
3499: LD_STRING 13s_
3501: PPUSH
3502: CALL 70309 0 3
3506: ST_TO_ADDR
// if Donaldson then
3507: LD_EXP 44
3511: IFFALSE 3529
// tmp := tmp ^ Donaldson ;
3513: LD_ADDR_VAR 0 5
3517: PUSH
3518: LD_VAR 0 5
3522: PUSH
3523: LD_EXP 44
3527: ADD
3528: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3529: LD_ADDR_EXP 45
3533: PUSH
3534: LD_STRING Bobby
3536: PPUSH
3537: LD_EXP 1
3541: NOT
3542: PPUSH
3543: LD_STRING 13s_
3545: PPUSH
3546: CALL 70309 0 3
3550: ST_TO_ADDR
// if Bobby then
3551: LD_EXP 45
3555: IFFALSE 3573
// tmp := tmp ^ Bobby ;
3557: LD_ADDR_VAR 0 5
3561: PUSH
3562: LD_VAR 0 5
3566: PUSH
3567: LD_EXP 45
3571: ADD
3572: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3573: LD_ADDR_EXP 46
3577: PUSH
3578: LD_STRING Cyrus
3580: PPUSH
3581: LD_EXP 1
3585: NOT
3586: PPUSH
3587: LD_STRING 13s_
3589: PPUSH
3590: CALL 70309 0 3
3594: ST_TO_ADDR
// if Cyrus then
3595: LD_EXP 46
3599: IFFALSE 3617
// tmp := tmp ^ Cyrus ;
3601: LD_ADDR_VAR 0 5
3605: PUSH
3606: LD_VAR 0 5
3610: PUSH
3611: LD_EXP 46
3615: ADD
3616: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3617: LD_ADDR_EXP 47
3621: PUSH
3622: LD_STRING Denis
3624: PPUSH
3625: LD_EXP 1
3629: NOT
3630: PPUSH
3631: LD_STRING 13s_
3633: PPUSH
3634: CALL 70309 0 3
3638: ST_TO_ADDR
// if not Denis then
3639: LD_EXP 47
3643: NOT
3644: IFFALSE 3668
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3646: LD_ADDR_EXP 47
3650: PUSH
3651: LD_STRING Denis
3653: PPUSH
3654: LD_EXP 1
3658: NOT
3659: PPUSH
3660: LD_STRING 13f_
3662: PPUSH
3663: CALL 70309 0 3
3667: ST_TO_ADDR
// if Denis then
3668: LD_EXP 47
3672: IFFALSE 3690
// tmp := tmp ^ Denis ;
3674: LD_ADDR_VAR 0 5
3678: PUSH
3679: LD_VAR 0 5
3683: PUSH
3684: LD_EXP 47
3688: ADD
3689: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3690: LD_ADDR_EXP 48
3694: PUSH
3695: LD_STRING Brown
3697: PPUSH
3698: LD_EXP 1
3702: NOT
3703: PPUSH
3704: LD_STRING 13s_
3706: PPUSH
3707: CALL 70309 0 3
3711: ST_TO_ADDR
// if Brown then
3712: LD_EXP 48
3716: IFFALSE 3734
// tmp := tmp ^ Brown ;
3718: LD_ADDR_VAR 0 5
3722: PUSH
3723: LD_VAR 0 5
3727: PUSH
3728: LD_EXP 48
3732: ADD
3733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3734: LD_ADDR_EXP 49
3738: PUSH
3739: LD_STRING Gladstone
3741: PPUSH
3742: LD_EXP 1
3746: NOT
3747: PPUSH
3748: LD_STRING 13s_
3750: PPUSH
3751: CALL 70309 0 3
3755: ST_TO_ADDR
// if Gladstone then
3756: LD_EXP 49
3760: IFFALSE 3778
// tmp := tmp ^ Gladstone ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_VAR 0 5
3771: PUSH
3772: LD_EXP 49
3776: ADD
3777: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3778: LD_ADDR_EXP 50
3782: PUSH
3783: LD_STRING Houten
3785: PPUSH
3786: LD_EXP 1
3790: NOT
3791: PPUSH
3792: LD_STRING 13s_
3794: PPUSH
3795: CALL 70309 0 3
3799: ST_TO_ADDR
// if Houten then
3800: LD_EXP 50
3804: IFFALSE 3822
// tmp := tmp ^ Houten ;
3806: LD_ADDR_VAR 0 5
3810: PUSH
3811: LD_VAR 0 5
3815: PUSH
3816: LD_EXP 50
3820: ADD
3821: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3822: LD_ADDR_EXP 51
3826: PUSH
3827: LD_STRING Cornel
3829: PPUSH
3830: LD_EXP 1
3834: NOT
3835: PPUSH
3836: LD_STRING 13s_
3838: PPUSH
3839: CALL 70309 0 3
3843: ST_TO_ADDR
// if Cornel then
3844: LD_EXP 51
3848: IFFALSE 3866
// tmp := tmp ^ Cornel ;
3850: LD_ADDR_VAR 0 5
3854: PUSH
3855: LD_VAR 0 5
3859: PUSH
3860: LD_EXP 51
3864: ADD
3865: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3866: LD_ADDR_EXP 52
3870: PUSH
3871: LD_STRING Gary
3873: PPUSH
3874: LD_EXP 1
3878: NOT
3879: PPUSH
3880: LD_STRING 13s_
3882: PPUSH
3883: CALL 70309 0 3
3887: ST_TO_ADDR
// if Gary then
3888: LD_EXP 52
3892: IFFALSE 3910
// tmp := tmp ^ Gary ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_EXP 52
3908: ADD
3909: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3910: LD_ADDR_EXP 53
3914: PUSH
3915: LD_STRING Frank
3917: PPUSH
3918: LD_EXP 1
3922: NOT
3923: PPUSH
3924: LD_STRING 13s_
3926: PPUSH
3927: CALL 70309 0 3
3931: ST_TO_ADDR
// if Frank then
3932: LD_EXP 53
3936: IFFALSE 3954
// tmp := tmp ^ Frank ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 5
3947: PUSH
3948: LD_EXP 53
3952: ADD
3953: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3954: LD_ADDR_EXP 54
3958: PUSH
3959: LD_STRING Kikuchi
3961: PPUSH
3962: LD_EXP 1
3966: NOT
3967: PPUSH
3968: LD_STRING 13s_
3970: PPUSH
3971: CALL 70309 0 3
3975: ST_TO_ADDR
// if Kikuchi then
3976: LD_EXP 54
3980: IFFALSE 3998
// tmp := tmp ^ Kikuchi ;
3982: LD_ADDR_VAR 0 5
3986: PUSH
3987: LD_VAR 0 5
3991: PUSH
3992: LD_EXP 54
3996: ADD
3997: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3998: LD_ADDR_EXP 58
4002: PUSH
4003: LD_STRING DeltaDoctor
4005: PPUSH
4006: LD_EXP 1
4010: NOT
4011: PPUSH
4012: LD_STRING 13s_
4014: PPUSH
4015: CALL 70309 0 3
4019: ST_TO_ADDR
// if DeltaDoctor then
4020: LD_EXP 58
4024: IFFALSE 4042
// tmp := tmp ^ DeltaDoctor ;
4026: LD_ADDR_VAR 0 5
4030: PUSH
4031: LD_VAR 0 5
4035: PUSH
4036: LD_EXP 58
4040: ADD
4041: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: LD_STRING Mike
4049: PPUSH
4050: LD_EXP 1
4054: NOT
4055: PPUSH
4056: LD_STRING 10c_
4058: PPUSH
4059: CALL 70309 0 3
4063: ST_TO_ADDR
// if Mike then
4064: LD_EXP 57
4068: IFFALSE 4091
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4070: LD_EXP 57
4074: PPUSH
4075: LD_INT 61
4077: PPUSH
4078: LD_INT 89
4080: PPUSH
4081: LD_INT 8
4083: PPUSH
4084: LD_INT 0
4086: PPUSH
4087: CALL_OW 50
// vip := tmp ;
4091: LD_ADDR_EXP 62
4095: PUSH
4096: LD_VAR 0 5
4100: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4101: LD_ADDR_VAR 0 5
4105: PUSH
4106: LD_VAR 0 5
4110: PUSH
4111: LD_STRING 13s_others
4113: PPUSH
4114: CALL_OW 31
4118: UNION
4119: ST_TO_ADDR
// if tmp < 18 then
4120: LD_VAR 0 5
4124: PUSH
4125: LD_INT 18
4127: LESS
4128: IFFALSE 4233
// begin InitHC_All ( ) ;
4130: CALL_OW 584
// for i = 1 to 18 - tmp do
4134: LD_ADDR_VAR 0 2
4138: PUSH
4139: DOUBLE
4140: LD_INT 1
4142: DEC
4143: ST_TO_ADDR
4144: LD_INT 18
4146: PUSH
4147: LD_VAR 0 5
4151: MINUS
4152: PUSH
4153: FOR_TO
4154: IFFALSE 4231
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4156: LD_INT 1
4158: PPUSH
4159: LD_VAR 0 2
4163: PUSH
4164: LD_INT 4
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: PPUSH
4172: LD_INT 4
4174: PPUSH
4175: CALL_OW 380
// un := CreateHuman ;
4179: LD_ADDR_VAR 0 10
4183: PUSH
4184: CALL_OW 44
4188: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4189: LD_ADDR_VAR 0 5
4193: PUSH
4194: LD_VAR 0 5
4198: PPUSH
4199: LD_VAR 0 10
4203: PPUSH
4204: CALL 108104 0 2
4208: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4209: LD_ADDR_EXP 63
4213: PUSH
4214: LD_EXP 63
4218: PPUSH
4219: LD_VAR 0 10
4223: PPUSH
4224: CALL 108104 0 2
4228: ST_TO_ADDR
// end ;
4229: GO 4153
4231: POP
4232: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4233: LD_ADDR_VAR 0 6
4237: PUSH
4238: LD_INT 53
4240: PPUSH
4241: LD_INT 94
4243: PPUSH
4244: CALL_OW 428
4248: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4249: LD_ADDR_VAR 0 7
4253: PUSH
4254: LD_INT 56
4256: PPUSH
4257: LD_INT 101
4259: PPUSH
4260: CALL_OW 428
4264: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4265: LD_ADDR_VAR 0 8
4269: PUSH
4270: LD_INT 67
4272: PPUSH
4273: LD_INT 101
4275: PPUSH
4276: CALL_OW 428
4280: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4281: LD_ADDR_VAR 0 9
4285: PUSH
4286: LD_INT 54
4288: PPUSH
4289: LD_INT 85
4291: PPUSH
4292: CALL_OW 428
4296: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4297: LD_ADDR_VAR 0 3
4301: PUSH
4302: LD_VAR 0 8
4306: PUSH
4307: LD_VAR 0 6
4311: PUSH
4312: LD_VAR 0 9
4316: PUSH
4317: LD_VAR 0 7
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: LIST
4326: LIST
4327: ST_TO_ADDR
// for i in tmp do
4328: LD_ADDR_VAR 0 2
4332: PUSH
4333: LD_VAR 0 5
4337: PUSH
4338: FOR_IN
4339: IFFALSE 4534
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4341: LD_VAR 0 3
4345: PUSH
4346: LD_INT 1
4348: ARRAY
4349: PPUSH
4350: CALL_OW 266
4354: PUSH
4355: LD_INT 4
4357: DOUBLE
4358: EQUAL
4359: IFTRUE 4363
4361: GO 4378
4363: POP
// SetClass ( i , class_soldier ) ; b_depot :
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 1
4371: PPUSH
4372: CALL_OW 336
4376: GO 4448
4378: LD_INT 0
4380: DOUBLE
4381: EQUAL
4382: IFTRUE 4386
4384: GO 4401
4386: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: CALL_OW 336
4399: GO 4448
4401: LD_INT 2
4403: DOUBLE
4404: EQUAL
4405: IFTRUE 4409
4407: GO 4424
4409: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 3
4417: PPUSH
4418: CALL_OW 336
4422: GO 4448
4424: LD_INT 6
4426: DOUBLE
4427: EQUAL
4428: IFTRUE 4432
4430: GO 4447
4432: POP
// SetClass ( i , class_scientistic ) ; end ;
4433: LD_VAR 0 2
4437: PPUSH
4438: LD_INT 4
4440: PPUSH
4441: CALL_OW 336
4445: GO 4448
4447: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4448: LD_VAR 0 3
4452: PUSH
4453: LD_INT 1
4455: ARRAY
4456: PPUSH
4457: CALL_OW 313
4461: PUSH
4462: LD_INT 6
4464: EQUAL
4465: IFFALSE 4485
// b := Delete ( b , 1 ) ;
4467: LD_ADDR_VAR 0 3
4471: PUSH
4472: LD_VAR 0 3
4476: PPUSH
4477: LD_INT 1
4479: PPUSH
4480: CALL_OW 3
4484: ST_TO_ADDR
// if b then
4485: LD_VAR 0 3
4489: IFFALSE 4511
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4491: LD_VAR 0 2
4495: PPUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_INT 1
4503: ARRAY
4504: PPUSH
4505: CALL_OW 52
4509: GO 4532
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4511: LD_VAR 0 2
4515: PPUSH
4516: LD_INT 61
4518: PPUSH
4519: LD_INT 89
4521: PPUSH
4522: LD_INT 8
4524: PPUSH
4525: LD_INT 0
4527: PPUSH
4528: CALL_OW 50
// end ;
4532: GO 4338
4534: POP
4535: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4536: LD_INT 2
4538: PPUSH
4539: LD_INT 1
4541: PPUSH
4542: LD_INT 1
4544: PPUSH
4545: LD_INT 12
4547: PPUSH
4548: LD_INT 100
4550: PPUSH
4551: CALL 75233 0 5
// veh := CreateVehicle ;
4555: LD_ADDR_VAR 0 4
4559: PUSH
4560: CALL_OW 45
4564: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4565: LD_VAR 0 4
4569: PPUSH
4570: LD_INT 4
4572: PPUSH
4573: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4577: LD_VAR 0 4
4581: PPUSH
4582: LD_INT 49
4584: PPUSH
4585: LD_INT 88
4587: PPUSH
4588: LD_INT 0
4590: PPUSH
4591: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4595: LD_VAR 0 4
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 100
4605: PPUSH
4606: CALL_OW 290
// uc_side := 0 ;
4610: LD_ADDR_OWVAR 20
4614: PUSH
4615: LD_INT 0
4617: ST_TO_ADDR
// uc_nation := 0 ;
4618: LD_ADDR_OWVAR 21
4622: PUSH
4623: LD_INT 0
4625: ST_TO_ADDR
// for i := 1 to 3 do
4626: LD_ADDR_VAR 0 2
4630: PUSH
4631: DOUBLE
4632: LD_INT 1
4634: DEC
4635: ST_TO_ADDR
4636: LD_INT 3
4638: PUSH
4639: FOR_TO
4640: IFFALSE 4671
// begin InitHc ;
4642: CALL_OW 19
// hc_class := class_apeman ;
4646: LD_ADDR_OWVAR 28
4650: PUSH
4651: LD_INT 12
4653: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4654: CALL_OW 44
4658: PPUSH
4659: LD_INT 13
4661: PPUSH
4662: LD_INT 0
4664: PPUSH
4665: CALL_OW 49
// end ;
4669: GO 4639
4671: POP
4672: POP
// end ; end_of_file
4673: LD_VAR 0 1
4677: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// side := 8 ;
4685: LD_ADDR_VAR 0 3
4689: PUSH
4690: LD_INT 8
4692: ST_TO_ADDR
// uc_side := side ;
4693: LD_ADDR_OWVAR 20
4697: PUSH
4698: LD_VAR 0 3
4702: ST_TO_ADDR
// uc_nation := 2 ;
4703: LD_ADDR_OWVAR 21
4707: PUSH
4708: LD_INT 2
4710: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4711: LD_ADDR_VAR 0 2
4715: PUSH
4716: LD_INT 22
4718: PUSH
4719: LD_VAR 0 3
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: PUSH
4728: LD_INT 21
4730: PUSH
4731: LD_INT 3
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: EMPTY
4739: LIST
4740: LIST
4741: PPUSH
4742: CALL_OW 69
4746: PUSH
4747: FOR_IN
4748: IFFALSE 4764
// SetBLevel ( i , 10 ) ;
4750: LD_VAR 0 2
4754: PPUSH
4755: LD_INT 10
4757: PPUSH
4758: CALL_OW 241
4762: GO 4747
4764: POP
4765: POP
// if KurtStatus then
4766: LD_EXP 3
4770: IFFALSE 4793
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4772: LD_ADDR_EXP 64
4776: PUSH
4777: LD_STRING Kurt
4779: PPUSH
4780: LD_INT 0
4782: PPUSH
4783: LD_STRING 
4785: PPUSH
4786: CALL 70309 0 3
4790: ST_TO_ADDR
4791: GO 4815
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4793: LD_ADDR_EXP 64
4797: PUSH
4798: LD_STRING AltKurt
4800: PPUSH
4801: LD_EXP 1
4805: NOT
4806: PPUSH
4807: LD_STRING 
4809: PPUSH
4810: CALL 70309 0 3
4814: ST_TO_ADDR
// if not Kurt then
4815: LD_EXP 64
4819: NOT
4820: IFFALSE 4846
// begin InitHc ;
4822: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4826: LD_INT 1
4828: PPUSH
4829: LD_INT 10
4831: PPUSH
4832: CALL_OW 381
// Kurt := CreateHuman ;
4836: LD_ADDR_EXP 64
4840: PUSH
4841: CALL_OW 44
4845: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4846: LD_EXP 64
4850: PPUSH
4851: LD_INT 324
4853: PPUSH
4854: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4858: LD_ADDR_EXP 65
4862: PUSH
4863: LD_STRING Kozlov
4865: PPUSH
4866: LD_INT 0
4868: PPUSH
4869: LD_STRING 
4871: PPUSH
4872: CALL 70309 0 3
4876: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4877: LD_EXP 65
4881: PPUSH
4882: LD_INT 22
4884: PUSH
4885: LD_INT 8
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 23
4894: PUSH
4895: LD_INT 3
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 30
4904: PUSH
4905: LD_INT 8
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: PPUSH
4917: CALL_OW 69
4921: PUSH
4922: LD_INT 1
4924: ARRAY
4925: PPUSH
4926: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4930: LD_EXP 65
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 10
4940: PPUSH
4941: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4945: LD_EXP 65
4949: PPUSH
4950: LD_INT 4
4952: PPUSH
4953: LD_INT 10
4955: PPUSH
4956: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4960: LD_ADDR_VAR 0 5
4964: PUSH
4965: LD_INT 22
4967: PUSH
4968: LD_VAR 0 3
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: LD_INT 30
4979: PUSH
4980: LD_INT 32
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 58
4989: PUSH
4990: EMPTY
4991: LIST
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: ST_TO_ADDR
// for i = 1 to 10 do
5003: LD_ADDR_VAR 0 2
5007: PUSH
5008: DOUBLE
5009: LD_INT 1
5011: DEC
5012: ST_TO_ADDR
5013: LD_INT 10
5015: PUSH
5016: FOR_TO
5017: IFFALSE 5089
// begin uc_nation := nation_nature ;
5019: LD_ADDR_OWVAR 21
5023: PUSH
5024: LD_INT 0
5026: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5027: LD_ADDR_OWVAR 28
5031: PUSH
5032: LD_INT 15
5034: ST_TO_ADDR
// hc_gallery :=  ;
5035: LD_ADDR_OWVAR 33
5039: PUSH
5040: LD_STRING 
5042: ST_TO_ADDR
// hc_name :=  ;
5043: LD_ADDR_OWVAR 26
5047: PUSH
5048: LD_STRING 
5050: ST_TO_ADDR
// un := CreateHuman ;
5051: LD_ADDR_VAR 0 4
5055: PUSH
5056: CALL_OW 44
5060: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5061: LD_VAR 0 4
5065: PPUSH
5066: LD_VAR 0 5
5070: PUSH
5071: LD_VAR 0 5
5075: PUSH
5076: LD_VAR 0 2
5080: MINUS
5081: ARRAY
5082: PPUSH
5083: CALL_OW 52
// end ;
5087: GO 5016
5089: POP
5090: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5091: LD_ADDR_VAR 0 5
5095: PUSH
5096: LD_STRING 12_kurt_squad
5098: PPUSH
5099: CALL_OW 31
5103: ST_TO_ADDR
// if tmp then
5104: LD_VAR 0 5
5108: IFFALSE 5142
// for i in tmp do
5110: LD_ADDR_VAR 0 2
5114: PUSH
5115: LD_VAR 0 5
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5140
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5123: LD_VAR 0 2
5127: PPUSH
5128: LD_INT 5
5130: PPUSH
5131: LD_INT 0
5133: PPUSH
5134: CALL_OW 49
5138: GO 5120
5140: POP
5141: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5142: LD_INT 324
5144: PPUSH
5145: LD_INT 5
5147: PPUSH
5148: LD_STRING 
5150: PPUSH
5151: LD_INT 8
5153: PUSH
5154: LD_INT 9
5156: PUSH
5157: LD_INT 10
5159: PUSH
5160: LD_INT 10
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: PUSH
5169: LD_OWVAR 67
5173: ARRAY
5174: PPUSH
5175: LD_INT 3000
5177: PUSH
5178: LD_INT 500
5180: PUSH
5181: LD_INT 150
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_INT 16
5191: PUSH
5192: LD_INT 6
5194: PUSH
5195: LD_INT 6
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: PPUSH
5207: CALL 79054 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5211: LD_ADDR_EXP 102
5215: PUSH
5216: LD_EXP 102
5220: PPUSH
5221: LD_INT 3
5223: PPUSH
5224: LD_INT 22
5226: PUSH
5227: LD_VAR 0 3
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 23
5238: PUSH
5239: LD_INT 2
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: LD_INT 21
5251: PUSH
5252: LD_INT 2
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 69
5272: PUSH
5273: LD_EXP 64
5277: DIFF
5278: PPUSH
5279: CALL_OW 1
5283: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5284: LD_INT 1
5286: PPUSH
5287: LD_INT 7
5289: PPUSH
5290: CALL_OW 383
// hc_name := Ali Hadrach ;
5294: LD_ADDR_OWVAR 26
5298: PUSH
5299: LD_STRING Ali Hadrach
5301: ST_TO_ADDR
// hc_gallery := us ;
5302: LD_ADDR_OWVAR 33
5306: PUSH
5307: LD_STRING us
5309: ST_TO_ADDR
// hc_face_number := 31 ;
5310: LD_ADDR_OWVAR 34
5314: PUSH
5315: LD_INT 31
5317: ST_TO_ADDR
// Friend := CreateHuman ;
5318: LD_ADDR_EXP 66
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5328: LD_INT 14
5330: PPUSH
5331: LD_INT 3
5333: PPUSH
5334: LD_INT 1
5336: PPUSH
5337: LD_INT 29
5339: PPUSH
5340: LD_INT 100
5342: PPUSH
5343: CALL 75233 0 5
// powellBomb := CreateVehicle ;
5347: LD_ADDR_EXP 67
5351: PUSH
5352: CALL_OW 45
5356: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5357: LD_EXP 67
5361: PPUSH
5362: LD_INT 90
5364: PPUSH
5365: LD_INT 51
5367: PPUSH
5368: LD_INT 0
5370: PPUSH
5371: CALL_OW 48
// end ;
5375: LD_VAR 0 1
5379: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5380: LD_INT 0
5382: PPUSH
5383: PPUSH
5384: PPUSH
// if IsLive ( kozlov_fac ) then
5385: LD_INT 332
5387: PPUSH
5388: CALL_OW 300
5392: IFFALSE 5396
// exit ;
5394: GO 5963
// ComExitBuilding ( Kozlov ) ;
5396: LD_EXP 65
5400: PPUSH
5401: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5405: LD_EXP 65
5409: PPUSH
5410: CALL_OW 257
5414: PUSH
5415: LD_INT 2
5417: NONEQUAL
5418: IFFALSE 5453
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5420: LD_EXP 65
5424: PPUSH
5425: LD_INT 324
5427: PPUSH
5428: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5432: LD_EXP 65
5436: PPUSH
5437: LD_INT 2
5439: PPUSH
5440: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5444: LD_EXP 65
5448: PPUSH
5449: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5453: LD_EXP 65
5457: PPUSH
5458: LD_INT 2
5460: PPUSH
5461: LD_INT 93
5463: PPUSH
5464: LD_INT 32
5466: PPUSH
5467: LD_INT 3
5469: PPUSH
5470: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5481: LD_INT 22
5483: PUSH
5484: LD_INT 8
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 30
5493: PUSH
5494: LD_INT 3
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 23
5503: PUSH
5504: LD_INT 3
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: PUSH
5511: LD_INT 57
5513: PUSH
5514: EMPTY
5515: LIST
5516: PUSH
5517: EMPTY
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: IFFALSE 5474
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5529: LD_ADDR_VAR 0 2
5533: PUSH
5534: LD_INT 22
5536: PUSH
5537: LD_INT 8
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 30
5546: PUSH
5547: LD_INT 3
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 23
5556: PUSH
5557: LD_INT 3
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 57
5566: PUSH
5567: EMPTY
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PPUSH
5576: CALL_OW 69
5580: PUSH
5581: LD_INT 1
5583: ARRAY
5584: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5585: LD_INT 22
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 23
5597: PUSH
5598: LD_INT 3
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: LD_INT 30
5607: PUSH
5608: LD_INT 21
5610: PUSH
5611: EMPTY
5612: LIST
5613: LIST
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 69
5624: NOT
5625: IFFALSE 5703
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5627: LD_EXP 65
5631: PPUSH
5632: LD_INT 21
5634: PPUSH
5635: LD_INT 97
5637: PPUSH
5638: LD_INT 36
5640: PPUSH
5641: LD_INT 5
5643: PPUSH
5644: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5648: LD_INT 35
5650: PPUSH
5651: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5655: LD_INT 22
5657: PUSH
5658: LD_INT 8
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 23
5667: PUSH
5668: LD_INT 3
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 30
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 57
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: LIST
5695: LIST
5696: PPUSH
5697: CALL_OW 69
5701: IFFALSE 5648
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5703: LD_INT 22
5705: PUSH
5706: LD_INT 8
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 23
5715: PUSH
5716: LD_INT 3
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 30
5725: PUSH
5726: LD_INT 18
5728: PUSH
5729: EMPTY
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 69
5742: NOT
5743: IFFALSE 5821
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5745: LD_EXP 65
5749: PPUSH
5750: LD_INT 18
5752: PPUSH
5753: LD_INT 89
5755: PPUSH
5756: LD_INT 32
5758: PPUSH
5759: LD_INT 1
5761: PPUSH
5762: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5766: LD_INT 35
5768: PPUSH
5769: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5773: LD_INT 22
5775: PUSH
5776: LD_INT 8
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 23
5785: PUSH
5786: LD_INT 3
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: PUSH
5793: LD_INT 30
5795: PUSH
5796: LD_INT 18
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: PUSH
5803: LD_INT 57
5805: PUSH
5806: EMPTY
5807: LIST
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PPUSH
5815: CALL_OW 69
5819: IFFALSE 5766
// end ; lab := kozlov_lab ;
5821: LD_ADDR_VAR 0 3
5825: PUSH
5826: LD_INT 336
5828: ST_TO_ADDR
// if not lab then
5829: LD_VAR 0 3
5833: NOT
5834: IFFALSE 5838
// exit ;
5836: GO 5963
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5838: LD_EXP 65
5842: PPUSH
5843: LD_VAR 0 3
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5856: LD_EXP 65
5860: PPUSH
5861: LD_INT 4
5863: PPUSH
5864: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5868: LD_VAR 0 3
5872: PUSH
5873: LD_INT 1
5875: ARRAY
5876: PPUSH
5877: LD_INT 25
5879: PPUSH
5880: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5884: LD_INT 35
5886: PPUSH
5887: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5891: LD_INT 25
5893: PPUSH
5894: LD_INT 8
5896: PPUSH
5897: CALL_OW 321
5901: PUSH
5902: LD_INT 2
5904: EQUAL
5905: IFFALSE 5884
// ComExitBuilding ( Kozlov ) ;
5907: LD_EXP 65
5911: PPUSH
5912: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5916: LD_EXP 65
5920: PPUSH
5921: LD_VAR 0 2
5925: PPUSH
5926: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5930: LD_EXP 65
5934: PPUSH
5935: LD_INT 3
5937: PPUSH
5938: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5942: LD_VAR 0 2
5946: PPUSH
5947: LD_INT 23
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: LD_INT 1
5955: PPUSH
5956: LD_INT 48
5958: PPUSH
5959: CALL_OW 125
// end ;
5963: LD_VAR 0 1
5967: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5968: LD_EXP 22
5972: NOT
5973: PUSH
5974: LD_EXP 15
5978: PUSH
5979: LD_INT 6
5981: GREATEREQUAL
5982: AND
5983: IFFALSE 6064
5985: GO 5987
5987: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 3
5993: PPUSH
5994: CALL 64020 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5998: LD_INT 3
6000: PPUSH
6001: LD_INT 14
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 28
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 1
6027: PUSH
6028: LD_INT 28
6030: PUSH
6031: EMPTY
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: LD_INT 14
6039: PUSH
6040: LD_INT 1
6042: PUSH
6043: LD_INT 1
6045: PUSH
6046: LD_INT 28
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: LIST
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL 63883 0 2
// end ;
6064: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6065: LD_EXP 22
6069: NOT
6070: PUSH
6071: LD_EXP 15
6075: PUSH
6076: LD_INT 6
6078: GREATEREQUAL
6079: AND
6080: PUSH
6081: LD_INT 3
6083: PPUSH
6084: LD_INT 1
6086: PPUSH
6087: CALL 65301 0 2
6091: NOT
6092: AND
6093: IFFALSE 7046
6095: GO 6097
6097: DISABLE
6098: LD_INT 0
6100: PPUSH
6101: PPUSH
6102: PPUSH
6103: PPUSH
// begin enable ;
6104: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6105: LD_INT 22
6107: PUSH
6108: LD_INT 8
6110: PUSH
6111: EMPTY
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 23
6117: PUSH
6118: LD_INT 2
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 30
6127: PUSH
6128: LD_INT 3
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: LIST
6139: PPUSH
6140: CALL_OW 69
6144: NOT
6145: IFFALSE 6149
// exit ;
6147: GO 7046
// if Prob ( 40 ) then
6149: LD_INT 40
6151: PPUSH
6152: CALL_OW 13
6156: IFFALSE 6283
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6158: LD_INT 3
6160: PPUSH
6161: LD_INT 14
6163: PUSH
6164: LD_INT 1
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: LD_INT 28
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_INT 14
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 14
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 14
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 28
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 14
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 28
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: LIST
6276: PPUSH
6277: CALL 63883 0 2
// end else
6281: GO 6490
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6283: LD_INT 3
6285: PPUSH
6286: LD_INT 14
6288: PUSH
6289: LD_INT 1
6291: PUSH
6292: LD_INT 2
6294: PUSH
6295: LD_INT 27
6297: PUSH
6298: LD_INT 26
6300: PUSH
6301: LD_INT 26
6303: PUSH
6304: LD_INT 28
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: LIST
6311: LIST
6312: PUSH
6313: LD_OWVAR 67
6317: ARRAY
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_INT 14
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 27
6336: PUSH
6337: LD_INT 26
6339: PUSH
6340: LD_INT 26
6342: PUSH
6343: LD_INT 26
6345: PUSH
6346: EMPTY
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: PUSH
6352: LD_OWVAR 67
6356: ARRAY
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 14
6366: PUSH
6367: LD_INT 1
6369: PUSH
6370: LD_INT 2
6372: PUSH
6373: LD_INT 26
6375: PUSH
6376: LD_INT 26
6378: PUSH
6379: LD_INT 29
6381: PUSH
6382: LD_INT 29
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: PUSH
6391: LD_OWVAR 67
6395: ARRAY
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_INT 13
6405: PUSH
6406: LD_INT 1
6408: PUSH
6409: LD_INT 2
6411: PUSH
6412: LD_INT 26
6414: PUSH
6415: LD_INT 29
6417: PUSH
6418: LD_INT 29
6420: PUSH
6421: LD_INT 29
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: PUSH
6430: LD_OWVAR 67
6434: ARRAY
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 13
6444: PUSH
6445: LD_INT 1
6447: PUSH
6448: LD_INT 2
6450: PUSH
6451: LD_INT 29
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 14
6462: PUSH
6463: LD_INT 1
6465: PUSH
6466: LD_INT 2
6468: PUSH
6469: LD_INT 26
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PPUSH
6486: CALL 63883 0 2
// end ; wait ( 2 2$00 ) ;
6490: LD_INT 4200
6492: PPUSH
6493: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6497: LD_ADDR_VAR 0 2
6501: PUSH
6502: LD_INT 22
6504: PUSH
6505: LD_INT 8
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 2
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 34
6527: PUSH
6528: LD_INT 31
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 3
6541: PUSH
6542: LD_INT 34
6544: PUSH
6545: LD_INT 32
6547: PUSH
6548: EMPTY
6549: LIST
6550: LIST
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 3
6558: PUSH
6559: LD_INT 34
6561: PUSH
6562: LD_INT 88
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PUSH
6573: EMPTY
6574: LIST
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PPUSH
6580: CALL_OW 69
6584: PUSH
6585: LD_EXP 124
6589: PUSH
6590: LD_INT 3
6592: ARRAY
6593: DIFF
6594: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6595: LD_ADDR_EXP 121
6599: PUSH
6600: LD_EXP 121
6604: PPUSH
6605: LD_INT 3
6607: PPUSH
6608: LD_EXP 121
6612: PUSH
6613: LD_INT 3
6615: ARRAY
6616: PUSH
6617: LD_VAR 0 2
6621: DIFF
6622: PPUSH
6623: CALL_OW 1
6627: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6628: LD_ADDR_VAR 0 3
6632: PUSH
6633: LD_INT 0
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ST_TO_ADDR
// if target then
6644: LD_VAR 0 3
6648: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6650: LD_ADDR_VAR 0 2
6654: PUSH
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 50
6662: PUSH
6663: EMPTY
6664: LIST
6665: PPUSH
6666: CALL_OW 72
6670: ST_TO_ADDR
// if not tmp then
6671: LD_VAR 0 2
6675: NOT
6676: IFFALSE 6680
// break ;
6678: GO 6804
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 89
6700: PPUSH
6701: LD_INT 71
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 89 , 71 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 89
6721: PPUSH
6722: LD_INT 71
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 109465 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 89
6765: PUSH
6766: LD_INT 71
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6650
// end else
6804: GO 6960
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 50
6818: PUSH
6819: EMPTY
6820: LIST
6821: PPUSH
6822: CALL_OW 72
6826: ST_TO_ADDR
// if not tmp then
6827: LD_VAR 0 2
6831: NOT
6832: IFFALSE 6836
// break ;
6834: GO 6960
// for i in tmp do
6836: LD_ADDR_VAR 0 1
6840: PUSH
6841: LD_VAR 0 2
6845: PUSH
6846: FOR_IN
6847: IFFALSE 6887
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6849: LD_VAR 0 1
6853: PPUSH
6854: LD_INT 125
6856: PPUSH
6857: LD_INT 129
6859: PPUSH
6860: CALL_OW 297
6864: PUSH
6865: LD_INT 9
6867: GREATER
6868: IFFALSE 6885
// ComMoveXY ( i , 125 , 129 ) ;
6870: LD_VAR 0 1
6874: PPUSH
6875: LD_INT 125
6877: PPUSH
6878: LD_INT 129
6880: PPUSH
6881: CALL_OW 111
6885: GO 6846
6887: POP
6888: POP
// wait ( 0 0$1 ) ;
6889: LD_INT 35
6891: PPUSH
6892: CALL_OW 67
// p := Inc ( p ) ;
6896: LD_ADDR_VAR 0 4
6900: PUSH
6901: LD_VAR 0 4
6905: PPUSH
6906: CALL 109465 0 1
6910: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6911: LD_VAR 0 2
6915: PPUSH
6916: LD_INT 92
6918: PUSH
6919: LD_INT 125
6921: PUSH
6922: LD_INT 129
6924: PUSH
6925: LD_INT 9
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 72
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: LD_INT 1
6946: MINUS
6947: GREATEREQUAL
6948: PUSH
6949: LD_VAR 0 4
6953: PUSH
6954: LD_INT 30
6956: GREATER
6957: OR
6958: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6960: LD_INT 35
6962: PPUSH
6963: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6967: LD_ADDR_VAR 0 2
6971: PUSH
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 50
6979: PUSH
6980: EMPTY
6981: LIST
6982: PPUSH
6983: CALL_OW 72
6987: ST_TO_ADDR
// for i in tmp do
6988: LD_ADDR_VAR 0 1
6992: PUSH
6993: LD_VAR 0 2
6997: PUSH
6998: FOR_IN
6999: IFFALSE 7037
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7001: LD_VAR 0 1
7005: PPUSH
7006: LD_INT 81
7008: PUSH
7009: LD_INT 8
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PPUSH
7016: CALL_OW 69
7020: PPUSH
7021: LD_VAR 0 1
7025: PPUSH
7026: CALL_OW 74
7030: PPUSH
7031: CALL_OW 115
7035: GO 6998
7037: POP
7038: POP
// until not tmp ;
7039: LD_VAR 0 2
7043: NOT
7044: IFFALSE 6960
// end ;
7046: PPOPN 4
7048: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7049: LD_EXP 22
7053: NOT
7054: PUSH
7055: LD_EXP 15
7059: PUSH
7060: LD_INT 6
7062: GREATEREQUAL
7063: AND
7064: PUSH
7065: LD_OWVAR 67
7069: PUSH
7070: LD_INT 1
7072: GREATER
7073: AND
7074: IFFALSE 7607
7076: GO 7078
7078: DISABLE
7079: LD_INT 0
7081: PPUSH
7082: PPUSH
7083: PPUSH
// begin enable ;
7084: ENABLE
// tmp := [ ] ;
7085: LD_ADDR_VAR 0 3
7089: PUSH
7090: EMPTY
7091: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7092: LD_ADDR_VAR 0 1
7096: PUSH
7097: DOUBLE
7098: LD_INT 1
7100: DEC
7101: ST_TO_ADDR
7102: LD_INT 4
7104: PUSH
7105: LD_INT 6
7107: PUSH
7108: LD_INT 7
7110: PUSH
7111: LD_INT 8
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: PUSH
7120: LD_OWVAR 67
7124: ARRAY
7125: PUSH
7126: FOR_TO
7127: IFFALSE 7287
// begin uc_side := 8 ;
7129: LD_ADDR_OWVAR 20
7133: PUSH
7134: LD_INT 8
7136: ST_TO_ADDR
// uc_nation := 2 ;
7137: LD_ADDR_OWVAR 21
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7145: LD_INT 13
7147: PUSH
7148: LD_INT 14
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 1
7157: PPUSH
7158: LD_INT 2
7160: PPUSH
7161: CALL_OW 12
7165: ARRAY
7166: PPUSH
7167: LD_INT 1
7169: PPUSH
7170: LD_INT 5
7172: PPUSH
7173: LD_INT 27
7175: PUSH
7176: LD_INT 28
7178: PUSH
7179: LD_INT 26
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 4
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: PPUSH
7203: LD_INT 88
7205: PPUSH
7206: CALL 75233 0 5
// un := CreateVehicle ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: CALL_OW 45
7219: ST_TO_ADDR
// tmp := tmp ^ un ;
7220: LD_ADDR_VAR 0 3
7224: PUSH
7225: LD_VAR 0 3
7229: PUSH
7230: LD_VAR 0 2
7234: ADD
7235: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7248: LD_VAR 0 2
7252: PPUSH
7253: LD_INT 30
7255: PPUSH
7256: LD_INT 0
7258: PPUSH
7259: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 16
7270: PPUSH
7271: LD_INT 11
7273: PPUSH
7274: CALL_OW 111
// wait ( 0 0$2 ) ;
7278: LD_INT 70
7280: PPUSH
7281: CALL_OW 67
// end ;
7285: GO 7126
7287: POP
7288: POP
// for i = 1 to Difficulty do
7289: LD_ADDR_VAR 0 1
7293: PUSH
7294: DOUBLE
7295: LD_INT 1
7297: DEC
7298: ST_TO_ADDR
7299: LD_OWVAR 67
7303: PUSH
7304: FOR_TO
7305: IFFALSE 7434
// begin uc_side := 8 ;
7307: LD_ADDR_OWVAR 20
7311: PUSH
7312: LD_INT 8
7314: ST_TO_ADDR
// uc_nation := 2 ;
7315: LD_ADDR_OWVAR 21
7319: PUSH
7320: LD_INT 2
7322: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7323: LD_INT 0
7325: PPUSH
7326: LD_INT 8
7328: PPUSH
7329: LD_INT 8
7331: PUSH
7332: LD_INT 8
7334: PUSH
7335: LD_INT 9
7337: PUSH
7338: LD_INT 10
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: PUSH
7347: LD_OWVAR 67
7351: ARRAY
7352: PPUSH
7353: CALL_OW 380
// un := CreateHuman ;
7357: LD_ADDR_VAR 0 2
7361: PUSH
7362: CALL_OW 44
7366: ST_TO_ADDR
// tmp := tmp ^ un ;
7367: LD_ADDR_VAR 0 3
7371: PUSH
7372: LD_VAR 0 3
7376: PUSH
7377: LD_VAR 0 2
7381: ADD
7382: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7383: LD_VAR 0 2
7387: PPUSH
7388: LD_INT 3
7390: PPUSH
7391: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7395: LD_VAR 0 2
7399: PPUSH
7400: LD_INT 30
7402: PPUSH
7403: LD_INT 0
7405: PPUSH
7406: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7410: LD_VAR 0 2
7414: PPUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 11
7420: PPUSH
7421: CALL_OW 111
// wait ( 0 0$2 ) ;
7425: LD_INT 70
7427: PPUSH
7428: CALL_OW 67
// end ;
7432: GO 7304
7434: POP
7435: POP
// repeat wait ( 0 0$1 ) ;
7436: LD_INT 35
7438: PPUSH
7439: CALL_OW 67
// if legionDestroyed then
7443: LD_EXP 22
7447: IFFALSE 7451
// exit ;
7449: GO 7607
// for i in tmp do
7451: LD_ADDR_VAR 0 1
7455: PUSH
7456: LD_VAR 0 3
7460: PUSH
7461: FOR_IN
7462: IFFALSE 7598
// begin if GetLives ( i ) > 250 then
7464: LD_VAR 0 1
7468: PPUSH
7469: CALL_OW 256
7473: PUSH
7474: LD_INT 250
7476: GREATER
7477: IFFALSE 7569
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7479: LD_INT 81
7481: PUSH
7482: LD_INT 8
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 91
7491: PUSH
7492: LD_VAR 0 1
7496: PUSH
7497: LD_INT 10
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: LIST
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PPUSH
7509: CALL_OW 69
7513: NOT
7514: IFFALSE 7533
// ComAgressiveMove ( i , 67 , 110 ) else
7516: LD_VAR 0 1
7520: PPUSH
7521: LD_INT 67
7523: PPUSH
7524: LD_INT 110
7526: PPUSH
7527: CALL_OW 114
7531: GO 7567
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7533: LD_VAR 0 1
7537: PPUSH
7538: LD_INT 81
7540: PUSH
7541: LD_INT 8
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL_OW 69
7552: PPUSH
7553: LD_VAR 0 1
7557: PPUSH
7558: CALL_OW 74
7562: PPUSH
7563: CALL_OW 115
// end else
7567: GO 7596
// if IsDead ( i ) then
7569: LD_VAR 0 1
7573: PPUSH
7574: CALL_OW 301
7578: IFFALSE 7596
// tmp := tmp diff i ;
7580: LD_ADDR_VAR 0 3
7584: PUSH
7585: LD_VAR 0 3
7589: PUSH
7590: LD_VAR 0 1
7594: DIFF
7595: ST_TO_ADDR
// end ;
7596: GO 7461
7598: POP
7599: POP
// until not tmp ;
7600: LD_VAR 0 3
7604: NOT
7605: IFFALSE 7436
// end ; end_of_file
7607: PPOPN 3
7609: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7610: LD_INT 0
7612: PPUSH
7613: PPUSH
7614: PPUSH
7615: PPUSH
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
7621: PPUSH
// side := 3 ;
7622: LD_ADDR_VAR 0 6
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// uc_side := side ;
7630: LD_ADDR_OWVAR 20
7634: PUSH
7635: LD_VAR 0 6
7639: ST_TO_ADDR
// uc_nation := 3 ;
7640: LD_ADDR_OWVAR 21
7644: PUSH
7645: LD_INT 3
7647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7648: LD_ADDR_VAR 0 2
7652: PUSH
7653: LD_INT 22
7655: PUSH
7656: LD_VAR 0 6
7660: PUSH
7661: EMPTY
7662: LIST
7663: LIST
7664: PUSH
7665: LD_INT 21
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: EMPTY
7676: LIST
7677: LIST
7678: PPUSH
7679: CALL_OW 69
7683: PUSH
7684: FOR_IN
7685: IFFALSE 7701
// SetBLevel ( i , 10 ) ;
7687: LD_VAR 0 2
7691: PPUSH
7692: LD_INT 10
7694: PPUSH
7695: CALL_OW 241
7699: GO 7684
7701: POP
7702: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7703: LD_ADDR_VAR 0 10
7707: PUSH
7708: LD_INT 22
7710: PUSH
7711: LD_VAR 0 6
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 34
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL_OW 69
7738: ST_TO_ADDR
// if teleport then
7739: LD_VAR 0 10
7743: IFFALSE 7764
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7745: LD_VAR 0 10
7749: PUSH
7750: LD_INT 1
7752: ARRAY
7753: PPUSH
7754: LD_INT 123
7756: PPUSH
7757: LD_INT 122
7759: PPUSH
7760: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7764: LD_ADDR_EXP 68
7768: PUSH
7769: LD_STRING Platonov
7771: PPUSH
7772: CALL_OW 25
7776: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7777: LD_ADDR_EXP 69
7781: PUSH
7782: LD_STRING Kovalyuk
7784: PPUSH
7785: CALL_OW 25
7789: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7790: LD_ADDR_EXP 71
7794: PUSH
7795: LD_STRING Yakotich
7797: PPUSH
7798: LD_EXP 1
7802: NOT
7803: PPUSH
7804: LD_STRING 09_
7806: PPUSH
7807: CALL 70309 0 3
7811: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7812: LD_ADDR_EXP 70
7816: PUSH
7817: LD_STRING Bystrov
7819: PPUSH
7820: CALL_OW 25
7824: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7825: LD_ADDR_EXP 72
7829: PUSH
7830: LD_STRING Gleb
7832: PPUSH
7833: CALL_OW 25
7837: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7838: LD_STRING 03_Cornel
7840: PPUSH
7841: CALL_OW 28
7845: IFFALSE 7893
// begin Bierezov := NewCharacter ( Mikhail ) ;
7847: LD_ADDR_EXP 73
7851: PUSH
7852: LD_STRING Mikhail
7854: PPUSH
7855: CALL_OW 25
7859: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7860: LD_EXP 73
7864: PPUSH
7865: LD_INT 197
7867: PPUSH
7868: LD_INT 111
7870: PPUSH
7871: LD_INT 9
7873: PPUSH
7874: LD_INT 0
7876: PPUSH
7877: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7881: LD_EXP 73
7885: PPUSH
7886: LD_INT 3
7888: PPUSH
7889: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7893: LD_EXP 68
7897: PPUSH
7898: LD_INT 126
7900: PPUSH
7901: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7905: LD_EXP 69
7909: PPUSH
7910: LD_INT 134
7912: PPUSH
7913: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7917: LD_EXP 71
7921: PPUSH
7922: LD_INT 197
7924: PPUSH
7925: LD_INT 111
7927: PPUSH
7928: LD_INT 9
7930: PPUSH
7931: LD_INT 0
7933: PPUSH
7934: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7938: LD_EXP 70
7942: PPUSH
7943: LD_INT 197
7945: PPUSH
7946: LD_INT 111
7948: PPUSH
7949: LD_INT 9
7951: PPUSH
7952: LD_INT 0
7954: PPUSH
7955: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7959: LD_EXP 72
7963: PPUSH
7964: LD_INT 197
7966: PPUSH
7967: LD_INT 111
7969: PPUSH
7970: LD_INT 9
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7980: LD_ADDR_VAR 0 5
7984: PUSH
7985: LD_INT 126
7987: PPUSH
7988: LD_INT 4
7990: PPUSH
7991: LD_STRING zhukov
7993: PPUSH
7994: LD_INT 9
7996: PUSH
7997: LD_INT 10
7999: PUSH
8000: LD_INT 10
8002: PUSH
8003: LD_INT 10
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: LIST
8010: LIST
8011: PUSH
8012: LD_OWVAR 67
8016: ARRAY
8017: PPUSH
8018: LD_INT 90000
8020: PUSH
8021: LD_INT 1000
8023: PUSH
8024: LD_INT 300
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: PPUSH
8032: LD_INT 18
8034: PUSH
8035: LD_INT 8
8037: PUSH
8038: LD_INT 12
8040: PUSH
8041: LD_INT 6
8043: PUSH
8044: EMPTY
8045: LIST
8046: LIST
8047: LIST
8048: LIST
8049: PPUSH
8050: CALL 79054 0 6
8054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8055: LD_ADDR_EXP 102
8059: PUSH
8060: LD_EXP 102
8064: PPUSH
8065: LD_INT 2
8067: PPUSH
8068: LD_VAR 0 5
8072: PUSH
8073: LD_EXP 71
8077: PUSH
8078: LD_EXP 70
8082: PUSH
8083: LD_EXP 72
8087: PUSH
8088: LD_EXP 73
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: UNION
8099: PPUSH
8100: CALL_OW 1
8104: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8105: LD_ADDR_VAR 0 4
8109: PUSH
8110: LD_INT 267
8112: PPUSH
8113: CALL_OW 274
8117: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8118: LD_VAR 0 4
8122: PPUSH
8123: LD_INT 1
8125: PPUSH
8126: LD_INT 5000
8128: PPUSH
8129: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8133: LD_VAR 0 4
8137: PPUSH
8138: LD_INT 2
8140: PPUSH
8141: LD_INT 200
8143: PPUSH
8144: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8148: LD_VAR 0 4
8152: PPUSH
8153: LD_INT 3
8155: PPUSH
8156: LD_INT 200
8158: PPUSH
8159: CALL_OW 277
// for i := 1 to 6 do
8163: LD_ADDR_VAR 0 2
8167: PUSH
8168: DOUBLE
8169: LD_INT 1
8171: DEC
8172: ST_TO_ADDR
8173: LD_INT 6
8175: PUSH
8176: FOR_TO
8177: IFFALSE 8260
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8179: LD_INT 0
8181: PPUSH
8182: LD_INT 8
8184: PUSH
8185: LD_INT 9
8187: PUSH
8188: LD_INT 10
8190: PUSH
8191: LD_INT 10
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_OWVAR 67
8204: ARRAY
8205: PPUSH
8206: CALL_OW 381
// un := CreateHuman ;
8210: LD_ADDR_VAR 0 8
8214: PUSH
8215: CALL_OW 44
8219: ST_TO_ADDR
// if i mod 2 = 0 then
8220: LD_VAR 0 2
8224: PUSH
8225: LD_INT 2
8227: MOD
8228: PUSH
8229: LD_INT 0
8231: EQUAL
8232: IFFALSE 8246
// SetClass ( un , class_bazooker ) ;
8234: LD_VAR 0 8
8238: PPUSH
8239: LD_INT 9
8241: PPUSH
8242: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8246: LD_VAR 0 8
8250: PPUSH
8251: LD_INT 460
8253: PPUSH
8254: CALL_OW 52
// end ;
8258: GO 8176
8260: POP
8261: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8262: LD_INT 21
8264: PPUSH
8265: LD_INT 3
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: LD_INT 52
8273: PPUSH
8274: LD_INT 100
8276: PPUSH
8277: CALL 75233 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8281: CALL_OW 45
8285: PPUSH
8286: LD_INT 259
8288: PPUSH
8289: LD_INT 145
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 0
8297: PPUSH
8298: CALL 110244 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8302: CALL_OW 45
8306: PPUSH
8307: LD_INT 245
8309: PPUSH
8310: LD_INT 139
8312: PPUSH
8313: LD_INT 3
8315: PPUSH
8316: LD_INT 0
8318: PPUSH
8319: CALL 110244 0 5
// behemoths := [ ] ;
8323: LD_ADDR_EXP 76
8327: PUSH
8328: EMPTY
8329: ST_TO_ADDR
// behemothBuilders := [ ] ;
8330: LD_ADDR_EXP 77
8334: PUSH
8335: EMPTY
8336: ST_TO_ADDR
// if Kovalyuk then
8337: LD_EXP 69
8341: IFFALSE 8363
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8343: LD_ADDR_EXP 77
8347: PUSH
8348: LD_EXP 77
8352: PPUSH
8353: LD_EXP 69
8357: PPUSH
8358: CALL 108104 0 2
8362: ST_TO_ADDR
// end ;
8363: LD_VAR 0 1
8367: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8368: LD_INT 0
8370: PPUSH
8371: PPUSH
8372: PPUSH
8373: PPUSH
8374: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8375: LD_ADDR_VAR 0 4
8379: PUSH
8380: LD_INT 221
8382: PUSH
8383: LD_INT 154
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 223
8392: PUSH
8393: LD_INT 149
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: LD_INT 228
8402: PUSH
8403: LD_INT 147
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 232
8412: PUSH
8413: LD_INT 155
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: ST_TO_ADDR
// if not behemothBuilders then
8426: LD_EXP 77
8430: NOT
8431: IFFALSE 8435
// exit ;
8433: GO 8566
// j := 1 ;
8435: LD_ADDR_VAR 0 3
8439: PUSH
8440: LD_INT 1
8442: ST_TO_ADDR
// for i in behemothBuilders do
8443: LD_ADDR_VAR 0 2
8447: PUSH
8448: LD_EXP 77
8452: PUSH
8453: FOR_IN
8454: IFFALSE 8564
// begin if GetClass ( i ) <> class_mechanic then
8456: LD_VAR 0 2
8460: PPUSH
8461: CALL_OW 257
8465: PUSH
8466: LD_INT 3
8468: NONEQUAL
8469: IFFALSE 8483
// SetClass ( i , class_mechanic ) ;
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 3
8478: PPUSH
8479: CALL_OW 336
// if IsInUnit ( i ) then
8483: LD_VAR 0 2
8487: PPUSH
8488: CALL_OW 310
8492: IFFALSE 8503
// ComExitBuilding ( i ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8503: LD_VAR 0 2
8507: PPUSH
8508: LD_INT 37
8510: PPUSH
8511: LD_VAR 0 4
8515: PUSH
8516: LD_VAR 0 3
8520: ARRAY
8521: PUSH
8522: LD_INT 1
8524: ARRAY
8525: PPUSH
8526: LD_VAR 0 4
8530: PUSH
8531: LD_VAR 0 3
8535: ARRAY
8536: PUSH
8537: LD_INT 2
8539: ARRAY
8540: PPUSH
8541: LD_INT 0
8543: PPUSH
8544: CALL_OW 230
// j := j + 1 ;
8548: LD_ADDR_VAR 0 3
8552: PUSH
8553: LD_VAR 0 3
8557: PUSH
8558: LD_INT 1
8560: PLUS
8561: ST_TO_ADDR
// end ;
8562: GO 8453
8564: POP
8565: POP
// end ;
8566: LD_VAR 0 1
8570: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8571: LD_INT 24
8573: PPUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 37
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PPUSH
8584: CALL_OW 70
8588: IFFALSE 8601
8590: GO 8592
8592: DISABLE
// behemothUnderConstruct := true ;
8593: LD_ADDR_EXP 26
8597: PUSH
8598: LD_INT 1
8600: ST_TO_ADDR
8601: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8602: LD_INT 3
8604: PPUSH
8605: CALL 108165 0 1
8609: PUSH
8610: LD_INT 22
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: EMPTY
8617: LIST
8618: LIST
8619: PUSH
8620: LD_INT 30
8622: PUSH
8623: LD_INT 37
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 69
8638: NOT
8639: AND
8640: IFFALSE 8826
8642: GO 8644
8644: DISABLE
8645: LD_INT 0
8647: PPUSH
8648: PPUSH
// begin enable ;
8649: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8650: LD_ADDR_VAR 0 2
8654: PUSH
8655: LD_INT 3
8657: PPUSH
8658: CALL 108165 0 1
8662: ST_TO_ADDR
// for i in tmp do
8663: LD_ADDR_VAR 0 1
8667: PUSH
8668: LD_VAR 0 2
8672: PUSH
8673: FOR_IN
8674: IFFALSE 8824
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8676: LD_VAR 0 1
8680: PPUSH
8681: LD_INT 9
8683: PPUSH
8684: CALL_OW 308
8688: PUSH
8689: LD_VAR 0 1
8693: PPUSH
8694: CALL_OW 110
8698: PUSH
8699: LD_INT 2
8701: EQUAL
8702: NOT
8703: AND
8704: IFFALSE 8718
// SetTag ( i , 2 ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: LD_INT 2
8713: PPUSH
8714: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8718: LD_INT 81
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: LD_INT 91
8730: PUSH
8731: LD_VAR 0 1
8735: PUSH
8736: LD_INT 12
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: NOT
8753: PUSH
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 110
8763: PUSH
8764: LD_INT 2
8766: EQUAL
8767: NOT
8768: AND
8769: IFFALSE 8788
// ComAgressiveMove ( i , 64 , 93 ) else
8771: LD_VAR 0 1
8775: PPUSH
8776: LD_INT 64
8778: PPUSH
8779: LD_INT 93
8781: PPUSH
8782: CALL_OW 114
8786: GO 8822
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8788: LD_VAR 0 1
8792: PPUSH
8793: LD_INT 81
8795: PUSH
8796: LD_INT 3
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PPUSH
8803: CALL_OW 69
8807: PPUSH
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 74
8817: PPUSH
8818: CALL_OW 115
// end ;
8822: GO 8673
8824: POP
8825: POP
// end ;
8826: PPOPN 2
8828: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8829: LD_INT 0
8831: PPUSH
8832: PPUSH
8833: PPUSH
// result := [ ] ;
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: EMPTY
8840: ST_TO_ADDR
// uc_side := 6 ;
8841: LD_ADDR_OWVAR 20
8845: PUSH
8846: LD_INT 6
8848: ST_TO_ADDR
// uc_nation := 3 ;
8849: LD_ADDR_OWVAR 21
8853: PUSH
8854: LD_INT 3
8856: ST_TO_ADDR
// case strength of 1 :
8857: LD_VAR 0 1
8861: PUSH
8862: LD_INT 1
8864: DOUBLE
8865: EQUAL
8866: IFTRUE 8870
8868: GO 9012
8870: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8871: LD_ADDR_VAR 0 3
8875: PUSH
8876: DOUBLE
8877: LD_INT 1
8879: DEC
8880: ST_TO_ADDR
8881: LD_INT 4
8883: PUSH
8884: LD_INT 5
8886: PUSH
8887: LD_INT 6
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: PUSH
8899: LD_OWVAR 67
8903: ARRAY
8904: PUSH
8905: FOR_TO
8906: IFFALSE 9008
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8908: LD_INT 22
8910: PUSH
8911: LD_INT 24
8913: PUSH
8914: EMPTY
8915: LIST
8916: LIST
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_INT 2
8925: MOD
8926: PUSH
8927: LD_INT 1
8929: PLUS
8930: ARRAY
8931: PPUSH
8932: LD_INT 1
8934: PUSH
8935: LD_INT 3
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: LD_INT 1
8944: PPUSH
8945: LD_INT 2
8947: PPUSH
8948: CALL_OW 12
8952: ARRAY
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: LD_INT 43
8959: PUSH
8960: LD_INT 44
8962: PUSH
8963: LD_INT 45
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 1
8973: PPUSH
8974: LD_INT 3
8976: PPUSH
8977: CALL_OW 12
8981: ARRAY
8982: PPUSH
8983: LD_INT 80
8985: PPUSH
8986: CALL 75233 0 5
// result := result union CreateVehicle ;
8990: LD_ADDR_VAR 0 2
8994: PUSH
8995: LD_VAR 0 2
8999: PUSH
9000: CALL_OW 45
9004: UNION
9005: ST_TO_ADDR
// end ;
9006: GO 8905
9008: POP
9009: POP
// end ; 2 :
9010: GO 10007
9012: LD_INT 2
9014: DOUBLE
9015: EQUAL
9016: IFTRUE 9020
9018: GO 9188
9020: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9021: LD_ADDR_VAR 0 3
9025: PUSH
9026: DOUBLE
9027: LD_INT 1
9029: DEC
9030: ST_TO_ADDR
9031: LD_INT 5
9033: PUSH
9034: LD_INT 6
9036: PUSH
9037: LD_INT 7
9039: PUSH
9040: LD_INT 8
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: PUSH
9049: LD_OWVAR 67
9053: ARRAY
9054: PUSH
9055: FOR_TO
9056: IFFALSE 9184
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9058: LD_INT 22
9060: PUSH
9061: LD_INT 24
9063: PUSH
9064: LD_INT 24
9066: PUSH
9067: EMPTY
9068: LIST
9069: LIST
9070: LIST
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: LD_INT 3
9079: MOD
9080: PUSH
9081: LD_INT 1
9083: PLUS
9084: ARRAY
9085: PPUSH
9086: LD_INT 1
9088: PUSH
9089: LD_INT 3
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: PUSH
9096: LD_INT 1
9098: PPUSH
9099: LD_INT 2
9101: PPUSH
9102: CALL_OW 12
9106: ARRAY
9107: PPUSH
9108: LD_INT 3
9110: PPUSH
9111: LD_INT 43
9113: PUSH
9114: LD_INT 44
9116: PUSH
9117: LD_INT 45
9119: PUSH
9120: LD_INT 44
9122: PUSH
9123: LD_INT 46
9125: PUSH
9126: LD_INT 46
9128: PUSH
9129: LD_INT 49
9131: PUSH
9132: LD_INT 49
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_VAR 0 3
9149: PUSH
9150: LD_INT 8
9152: MOD
9153: PUSH
9154: LD_INT 1
9156: PLUS
9157: ARRAY
9158: PPUSH
9159: LD_INT 80
9161: PPUSH
9162: CALL 75233 0 5
// result := result union CreateVehicle ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: CALL_OW 45
9180: UNION
9181: ST_TO_ADDR
// end ;
9182: GO 9055
9184: POP
9185: POP
// end ; 3 :
9186: GO 10007
9188: LD_INT 3
9190: DOUBLE
9191: EQUAL
9192: IFTRUE 9196
9194: GO 9368
9196: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9197: LD_ADDR_VAR 0 3
9201: PUSH
9202: DOUBLE
9203: LD_INT 1
9205: DEC
9206: ST_TO_ADDR
9207: LD_INT 6
9209: PUSH
9210: LD_INT 7
9212: PUSH
9213: LD_INT 8
9215: PUSH
9216: LD_INT 9
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: LIST
9223: LIST
9224: PUSH
9225: LD_OWVAR 67
9229: ARRAY
9230: PUSH
9231: FOR_TO
9232: IFFALSE 9364
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9234: LD_INT 22
9236: PUSH
9237: LD_INT 24
9239: PUSH
9240: LD_INT 24
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_VAR 0 3
9252: PUSH
9253: LD_INT 3
9255: MOD
9256: PUSH
9257: LD_INT 1
9259: PLUS
9260: ARRAY
9261: PPUSH
9262: LD_INT 1
9264: PUSH
9265: LD_INT 3
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: PUSH
9272: LD_INT 1
9274: PPUSH
9275: LD_INT 2
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 43
9289: PUSH
9290: LD_INT 47
9292: PUSH
9293: LD_INT 45
9295: PUSH
9296: LD_INT 45
9298: PUSH
9299: LD_INT 46
9301: PUSH
9302: LD_INT 46
9304: PUSH
9305: LD_INT 49
9307: PUSH
9308: LD_INT 49
9310: PUSH
9311: LD_INT 49
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: LIST
9319: LIST
9320: LIST
9321: LIST
9322: LIST
9323: LIST
9324: PUSH
9325: LD_VAR 0 3
9329: PUSH
9330: LD_INT 9
9332: MOD
9333: PUSH
9334: LD_INT 1
9336: PLUS
9337: ARRAY
9338: PPUSH
9339: LD_INT 80
9341: PPUSH
9342: CALL 75233 0 5
// result := result union CreateVehicle ;
9346: LD_ADDR_VAR 0 2
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: CALL_OW 45
9360: UNION
9361: ST_TO_ADDR
// end ;
9362: GO 9231
9364: POP
9365: POP
// end ; 4 :
9366: GO 10007
9368: LD_INT 4
9370: DOUBLE
9371: EQUAL
9372: IFTRUE 9376
9374: GO 10006
9376: POP
// begin uc_nation := 3 ;
9377: LD_ADDR_OWVAR 21
9381: PUSH
9382: LD_INT 3
9384: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9385: LD_ADDR_VAR 0 3
9389: PUSH
9390: DOUBLE
9391: LD_INT 1
9393: DEC
9394: ST_TO_ADDR
9395: LD_INT 6
9397: PUSH
9398: LD_INT 8
9400: PUSH
9401: LD_INT 9
9403: PUSH
9404: LD_INT 10
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: LIST
9412: PUSH
9413: LD_OWVAR 67
9417: ARRAY
9418: PUSH
9419: FOR_TO
9420: IFFALSE 9552
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9422: LD_INT 22
9424: PUSH
9425: LD_INT 24
9427: PUSH
9428: LD_INT 24
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PUSH
9436: LD_VAR 0 3
9440: PUSH
9441: LD_INT 3
9443: MOD
9444: PUSH
9445: LD_INT 1
9447: PLUS
9448: ARRAY
9449: PPUSH
9450: LD_INT 1
9452: PUSH
9453: LD_INT 3
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 12
9470: ARRAY
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: LD_INT 45
9477: PUSH
9478: LD_INT 47
9480: PUSH
9481: LD_INT 47
9483: PUSH
9484: LD_INT 45
9486: PUSH
9487: LD_INT 46
9489: PUSH
9490: LD_INT 46
9492: PUSH
9493: LD_INT 49
9495: PUSH
9496: LD_INT 49
9498: PUSH
9499: LD_INT 49
9501: PUSH
9502: EMPTY
9503: LIST
9504: LIST
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_VAR 0 3
9517: PUSH
9518: LD_INT 9
9520: MOD
9521: PUSH
9522: LD_INT 1
9524: PLUS
9525: ARRAY
9526: PPUSH
9527: LD_INT 80
9529: PPUSH
9530: CALL 75233 0 5
// result := result union CreateVehicle ;
9534: LD_ADDR_VAR 0 2
9538: PUSH
9539: LD_VAR 0 2
9543: PUSH
9544: CALL_OW 45
9548: UNION
9549: ST_TO_ADDR
// end ;
9550: GO 9419
9552: POP
9553: POP
// if not KappaStatus then
9554: LD_EXP 2
9558: NOT
9559: IFFALSE 9794
// begin uc_nation := 1 ;
9561: LD_ADDR_OWVAR 21
9565: PUSH
9566: LD_INT 1
9568: ST_TO_ADDR
// for i = 1 to 3 do
9569: LD_ADDR_VAR 0 3
9573: PUSH
9574: DOUBLE
9575: LD_INT 1
9577: DEC
9578: ST_TO_ADDR
9579: LD_INT 3
9581: PUSH
9582: FOR_TO
9583: IFFALSE 9719
// begin j := rand ( 0 , 1 ) ;
9585: LD_ADDR_VAR 0 4
9589: PUSH
9590: LD_INT 0
9592: PPUSH
9593: LD_INT 1
9595: PPUSH
9596: CALL_OW 12
9600: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9601: LD_INT 3
9603: PUSH
9604: LD_INT 5
9606: PUSH
9607: LD_INT 5
9609: PUSH
9610: LD_INT 4
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: LIST
9617: LIST
9618: PUSH
9619: LD_VAR 0 4
9623: PUSH
9624: LD_INT 1
9626: PPUSH
9627: LD_INT 3
9629: PPUSH
9630: CALL_OW 12
9634: PLUS
9635: ARRAY
9636: PPUSH
9637: LD_INT 1
9639: PUSH
9640: LD_INT 3
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 1
9649: PPUSH
9650: LD_INT 2
9652: PPUSH
9653: CALL_OW 12
9657: ARRAY
9658: PPUSH
9659: LD_INT 3
9661: PPUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 7
9667: PUSH
9668: LD_INT 6
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: PUSH
9676: LD_VAR 0 4
9680: PUSH
9681: LD_INT 1
9683: PPUSH
9684: LD_INT 2
9686: PPUSH
9687: CALL_OW 12
9691: PLUS
9692: ARRAY
9693: PPUSH
9694: LD_INT 85
9696: PPUSH
9697: CALL 75233 0 5
// result := result union CreateVehicle ;
9701: LD_ADDR_VAR 0 2
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: CALL_OW 45
9715: UNION
9716: ST_TO_ADDR
// end ;
9717: GO 9582
9719: POP
9720: POP
// if vsevolodFirstAttack then
9721: LD_EXP 24
9725: IFFALSE 9792
// begin vsevolodFirstAttack := false ;
9727: LD_ADDR_EXP 24
9731: PUSH
9732: LD_INT 0
9734: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9735: LD_INT 5
9737: PPUSH
9738: LD_INT 3
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: LD_INT 6
9746: PPUSH
9747: LD_INT 100
9749: PPUSH
9750: CALL 75233 0 5
// sewiVeh := CreateVehicle ;
9754: LD_ADDR_EXP 75
9758: PUSH
9759: CALL_OW 45
9763: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9764: LD_EXP 75
9768: PPUSH
9769: LD_INT 1
9771: PPUSH
9772: CALL_OW 242
// result := result union sewiVeh ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_VAR 0 2
9785: PUSH
9786: LD_EXP 75
9790: UNION
9791: ST_TO_ADDR
// end ; end else
9792: GO 10004
// if vsevolodFirstAttack then
9794: LD_EXP 24
9798: IFFALSE 10004
// begin vsevolodFirstAttack := false ;
9800: LD_ADDR_EXP 24
9804: PUSH
9805: LD_INT 0
9807: ST_TO_ADDR
// uc_nation := 3 ;
9808: LD_ADDR_OWVAR 21
9812: PUSH
9813: LD_INT 3
9815: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9816: LD_ADDR_VAR 0 3
9820: PUSH
9821: DOUBLE
9822: LD_INT 1
9824: DEC
9825: ST_TO_ADDR
9826: LD_INT 2
9828: PUSH
9829: LD_OWVAR 67
9833: PLUS
9834: PUSH
9835: FOR_TO
9836: IFFALSE 9944
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9838: LD_INT 22
9840: PUSH
9841: LD_INT 24
9843: PUSH
9844: LD_INT 24
9846: PUSH
9847: EMPTY
9848: LIST
9849: LIST
9850: LIST
9851: PUSH
9852: LD_VAR 0 3
9856: PUSH
9857: LD_INT 3
9859: MOD
9860: PUSH
9861: LD_INT 1
9863: PLUS
9864: ARRAY
9865: PPUSH
9866: LD_INT 1
9868: PUSH
9869: LD_INT 3
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 1
9878: PPUSH
9879: LD_INT 2
9881: PPUSH
9882: CALL_OW 12
9886: ARRAY
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: LD_INT 45
9893: PUSH
9894: LD_INT 47
9896: PUSH
9897: LD_INT 47
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PUSH
9905: LD_VAR 0 3
9909: PUSH
9910: LD_INT 3
9912: MOD
9913: PUSH
9914: LD_INT 1
9916: PLUS
9917: ARRAY
9918: PPUSH
9919: LD_INT 80
9921: PPUSH
9922: CALL 75233 0 5
// result := result union CreateVehicle ;
9926: LD_ADDR_VAR 0 2
9930: PUSH
9931: LD_VAR 0 2
9935: PUSH
9936: CALL_OW 45
9940: UNION
9941: ST_TO_ADDR
// end ;
9942: GO 9835
9944: POP
9945: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9946: LD_INT 24
9948: PPUSH
9949: LD_INT 3
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 47
9957: PPUSH
9958: LD_INT 100
9960: PPUSH
9961: CALL 75233 0 5
// sewiVeh := CreateVehicle ;
9965: LD_ADDR_EXP 75
9969: PUSH
9970: CALL_OW 45
9974: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9975: LD_EXP 75
9979: PPUSH
9980: LD_INT 6
9982: NEG
9983: PPUSH
9984: CALL_OW 242
// result := result union sewiVeh ;
9988: LD_ADDR_VAR 0 2
9992: PUSH
9993: LD_VAR 0 2
9997: PUSH
9998: LD_EXP 75
10002: UNION
10003: ST_TO_ADDR
// end ; end ; end ;
10004: GO 10007
10006: POP
// end ;
10007: LD_VAR 0 2
10011: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10012: LD_EXP 16
10016: IFFALSE 10773
10018: GO 10020
10020: DISABLE
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10029: LD_ADDR_VAR 0 4
10033: PUSH
10034: LD_INT 11
10036: PUSH
10037: LD_INT 12
10039: PUSH
10040: EMPTY
10041: LIST
10042: LIST
10043: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10044: LD_ADDR_VAR 0 3
10048: PUSH
10049: LD_INT 11550
10051: PUSH
10052: LD_INT 10150
10054: PUSH
10055: LD_INT 9800
10057: PUSH
10058: LD_INT 9450
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_OWVAR 67
10071: ARRAY
10072: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10073: LD_ADDR_VAR 0 6
10077: PUSH
10078: LD_INT 70
10080: PUSH
10081: LD_INT 118
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: LD_INT 78
10090: PUSH
10091: LD_INT 31
10093: PUSH
10094: EMPTY
10095: LIST
10096: LIST
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: ST_TO_ADDR
// repeat if missionStage = 2 then
10102: LD_EXP 15
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10121
// wait ( 1 1$30 ) else
10112: LD_INT 3150
10114: PPUSH
10115: CALL_OW 67
10119: GO 10130
// wait ( time ) ;
10121: LD_VAR 0 3
10125: PPUSH
10126: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10130: LD_EXP 15
10134: PUSH
10135: LD_INT 6
10137: EQUAL
10138: PUSH
10139: LD_OWVAR 67
10143: PUSH
10144: LD_INT 2
10146: GREATER
10147: OR
10148: IFFALSE 10176
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_INT 6
10155: PPUSH
10156: LD_INT 2
10158: PPUSH
10159: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10163: LD_INT 57
10165: PPUSH
10166: LD_INT 6
10168: PPUSH
10169: LD_INT 2
10171: PPUSH
10172: CALL_OW 322
// end ; if missionStage = 8 then
10176: LD_EXP 15
10180: PUSH
10181: LD_INT 8
10183: EQUAL
10184: IFFALSE 10212
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10186: LD_INT 52
10188: PPUSH
10189: LD_INT 6
10191: PPUSH
10192: LD_INT 2
10194: PPUSH
10195: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10199: LD_INT 58
10201: PPUSH
10202: LD_INT 6
10204: PPUSH
10205: LD_INT 2
10207: PPUSH
10208: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10212: LD_OWVAR 67
10216: PUSH
10217: LD_INT 4
10219: EQUAL
10220: PUSH
10221: LD_EXP 15
10225: PUSH
10226: LD_INT 10
10228: EQUAL
10229: OR
10230: IFFALSE 10258
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10232: LD_INT 53
10234: PPUSH
10235: LD_INT 6
10237: PPUSH
10238: LD_INT 2
10240: PPUSH
10241: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10245: LD_INT 59
10247: PPUSH
10248: LD_INT 6
10250: PPUSH
10251: LD_INT 2
10253: PPUSH
10254: CALL_OW 322
// end ; if activeAttacks then
10258: LD_EXP 16
10262: IFFALSE 10767
// begin if missionStage = 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: EQUAL
10272: IFFALSE 10282
// strength := 1 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 1
10281: ST_TO_ADDR
// if missionStage > 2 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 2
10289: GREATER
10290: IFFALSE 10300
// strength := 2 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 2
10299: ST_TO_ADDR
// if missionStage > 6 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 6
10307: GREATER
10308: IFFALSE 10318
// strength := 3 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
// if missionStage > 10 then
10318: LD_EXP 15
10322: PUSH
10323: LD_INT 10
10325: GREATER
10326: IFFALSE 10336
// strength := 4 ;
10328: LD_ADDR_VAR 0 5
10332: PUSH
10333: LD_INT 4
10335: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: LD_VAR 0 5
10345: PPUSH
10346: CALL 8829 0 1
10350: ST_TO_ADDR
// for i in tmp do
10351: LD_ADDR_VAR 0 1
10355: PUSH
10356: LD_VAR 0 2
10360: PUSH
10361: FOR_IN
10362: IFFALSE 10636
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10364: LD_VAR 0 1
10368: PPUSH
10369: LD_VAR 0 4
10373: PUSH
10374: LD_INT 1
10376: PPUSH
10377: LD_INT 2
10379: PPUSH
10380: CALL_OW 12
10384: ARRAY
10385: PPUSH
10386: LD_INT 0
10388: PPUSH
10389: CALL_OW 49
// if i = sewiVeh then
10393: LD_VAR 0 1
10397: PUSH
10398: LD_EXP 75
10402: EQUAL
10403: IFFALSE 10456
// begin uc_side := 6 ;
10405: LD_ADDR_OWVAR 20
10409: PUSH
10410: LD_INT 6
10412: ST_TO_ADDR
// uc_nation := nation_russian ;
10413: LD_ADDR_OWVAR 21
10417: PUSH
10418: LD_INT 3
10420: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10421: LD_ADDR_EXP 74
10425: PUSH
10426: LD_STRING Vsevolod
10428: PPUSH
10429: LD_INT 0
10431: PPUSH
10432: LD_STRING 
10434: PPUSH
10435: CALL 70309 0 3
10439: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10440: LD_EXP 74
10444: PPUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 52
// end else
10454: GO 10537
// if GetControl ( i ) = control_manual then
10456: LD_VAR 0 1
10460: PPUSH
10461: CALL_OW 263
10465: PUSH
10466: LD_INT 1
10468: EQUAL
10469: IFFALSE 10537
// begin uc_side := 6 ;
10471: LD_ADDR_OWVAR 20
10475: PUSH
10476: LD_INT 6
10478: ST_TO_ADDR
// uc_nation := 3 ;
10479: LD_ADDR_OWVAR 21
10483: PUSH
10484: LD_INT 3
10486: ST_TO_ADDR
// hc_gallery :=  ;
10487: LD_ADDR_OWVAR 33
10491: PUSH
10492: LD_STRING 
10494: ST_TO_ADDR
// hc_name :=  ;
10495: LD_ADDR_OWVAR 26
10499: PUSH
10500: LD_STRING 
10502: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10503: LD_INT 0
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: LD_INT 10
10511: PPUSH
10512: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10516: CALL_OW 44
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10530: LD_INT 10
10532: PPUSH
10533: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 3
10542: PPUSH
10543: CALL_OW 12
10547: PUSH
10548: LD_INT 1
10550: DOUBLE
10551: EQUAL
10552: IFTRUE 10556
10554: GO 10574
10556: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10557: LD_VAR 0 1
10561: PPUSH
10562: LD_INT 111
10564: PPUSH
10565: LD_INT 197
10567: PPUSH
10568: CALL_OW 111
10572: GO 10627
10574: LD_INT 2
10576: DOUBLE
10577: EQUAL
10578: IFTRUE 10582
10580: GO 10600
10582: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10583: LD_VAR 0 1
10587: PPUSH
10588: LD_INT 91
10590: PPUSH
10591: LD_INT 165
10593: PPUSH
10594: CALL_OW 111
10598: GO 10627
10600: LD_INT 3
10602: DOUBLE
10603: EQUAL
10604: IFTRUE 10608
10606: GO 10626
10608: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10609: LD_VAR 0 1
10613: PPUSH
10614: LD_INT 137
10616: PPUSH
10617: LD_INT 157
10619: PPUSH
10620: CALL_OW 111
10624: GO 10627
10626: POP
// wait ( 0 0$2 ) ;
10627: LD_INT 70
10629: PPUSH
10630: CALL_OW 67
// end ;
10634: GO 10361
10636: POP
10637: POP
// repeat wait ( 0 0$1 ) ;
10638: LD_INT 35
10640: PPUSH
10641: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10645: LD_ADDR_VAR 0 1
10649: PUSH
10650: LD_VAR 0 2
10654: PPUSH
10655: LD_INT 50
10657: PUSH
10658: EMPTY
10659: LIST
10660: PPUSH
10661: CALL_OW 72
10665: PUSH
10666: FOR_IN
10667: IFFALSE 10726
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_INT 108
10676: PUSH
10677: LD_INT 153
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 105
10686: PUSH
10687: LD_INT 149
10689: PUSH
10690: EMPTY
10691: LIST
10692: LIST
10693: PUSH
10694: LD_INT 85
10696: PUSH
10697: LD_INT 131
10699: PUSH
10700: EMPTY
10701: LIST
10702: LIST
10703: PUSH
10704: LD_INT 64
10706: PUSH
10707: LD_INT 105
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL 110714 0 2
10724: GO 10666
10726: POP
10727: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10728: LD_VAR 0 2
10732: PPUSH
10733: LD_INT 3
10735: PUSH
10736: LD_INT 34
10738: PUSH
10739: LD_INT 49
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 50
10752: PUSH
10753: EMPTY
10754: LIST
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PPUSH
10760: CALL_OW 72
10764: NOT
10765: IFFALSE 10638
// end ; until russianDestroyed ;
10767: LD_EXP 21
10771: IFFALSE 10102
// end ;
10773: PPOPN 6
10775: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10776: LD_EXP 21
10780: NOT
10781: PUSH
10782: LD_EXP 15
10786: PUSH
10787: LD_INT 6
10789: GREATEREQUAL
10790: AND
10791: IFFALSE 11828
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
// begin enable ;
10803: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10804: LD_INT 22
10806: PUSH
10807: LD_INT 3
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 30
10816: PUSH
10817: LD_INT 3
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PPUSH
10828: CALL_OW 69
10832: NOT
10833: IFFALSE 10837
// exit ;
10835: GO 11828
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10837: LD_ADDR_VAR 0 4
10841: PUSH
10842: LD_INT 22
10844: PUSH
10845: LD_INT 3
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PUSH
10852: LD_INT 30
10854: PUSH
10855: LD_INT 34
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 69
10870: ST_TO_ADDR
// if Prob ( 40 ) then
10871: LD_INT 40
10873: PPUSH
10874: CALL_OW 13
10878: IFFALSE 11024
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10880: LD_INT 2
10882: PPUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 3
10888: PUSH
10889: LD_INT 3
10891: PUSH
10892: LD_INT 49
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 22
10903: PUSH
10904: LD_INT 3
10906: PUSH
10907: LD_INT 3
10909: PUSH
10910: LD_INT 49
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 22
10921: PUSH
10922: LD_INT 3
10924: PUSH
10925: LD_INT 3
10927: PUSH
10928: LD_INT 49
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: LIST
10935: LIST
10936: PUSH
10937: LD_INT 24
10939: PUSH
10940: LD_INT 3
10942: PUSH
10943: LD_INT 3
10945: PUSH
10946: LD_INT 46
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 24
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: LD_INT 3
10963: PUSH
10964: LD_INT 46
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: LIST
10971: LIST
10972: PUSH
10973: LD_INT 24
10975: PUSH
10976: LD_INT 3
10978: PUSH
10979: LD_INT 3
10981: PUSH
10982: LD_INT 46
10984: PUSH
10985: EMPTY
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 24
10993: PUSH
10994: LD_INT 3
10996: PUSH
10997: LD_INT 3
10999: PUSH
11000: LD_INT 46
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: PUSH
11009: EMPTY
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: PPUSH
11018: CALL 63883 0 2
// end else
11022: GO 11166
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11024: LD_INT 2
11026: PPUSH
11027: LD_INT 24
11029: PUSH
11030: LD_INT 3
11032: PUSH
11033: LD_INT 3
11035: PUSH
11036: LD_INT 47
11038: PUSH
11039: EMPTY
11040: LIST
11041: LIST
11042: LIST
11043: LIST
11044: PUSH
11045: LD_INT 24
11047: PUSH
11048: LD_INT 3
11050: PUSH
11051: LD_INT 3
11053: PUSH
11054: LD_INT 47
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 24
11065: PUSH
11066: LD_INT 3
11068: PUSH
11069: LD_INT 3
11071: PUSH
11072: LD_INT 47
11074: PUSH
11075: EMPTY
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: PUSH
11081: LD_INT 24
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 3
11089: PUSH
11090: LD_INT 46
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PUSH
11099: LD_INT 24
11101: PUSH
11102: LD_INT 3
11104: PUSH
11105: LD_INT 3
11107: PUSH
11108: LD_INT 46
11110: PUSH
11111: EMPTY
11112: LIST
11113: LIST
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 24
11119: PUSH
11120: LD_INT 3
11122: PUSH
11123: LD_INT 3
11125: PUSH
11126: LD_INT 46
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: LD_INT 24
11137: PUSH
11138: LD_INT 3
11140: PUSH
11141: LD_INT 3
11143: PUSH
11144: LD_INT 46
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL 63883 0 2
// end ; wait ( 2 2$00 ) ;
11166: LD_INT 4200
11168: PPUSH
11169: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11173: LD_ADDR_VAR 0 2
11177: PUSH
11178: LD_INT 22
11180: PUSH
11181: LD_INT 3
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: LD_INT 21
11200: PUSH
11201: LD_INT 2
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: PUSH
11208: LD_INT 3
11210: PUSH
11211: LD_INT 34
11213: PUSH
11214: LD_INT 48
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: LD_INT 3
11227: PUSH
11228: LD_INT 34
11230: PUSH
11231: LD_INT 51
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PUSH
11242: LD_INT 3
11244: PUSH
11245: LD_INT 34
11247: PUSH
11248: LD_INT 52
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: PUSH
11272: LD_EXP 124
11276: PUSH
11277: LD_INT 2
11279: ARRAY
11280: DIFF
11281: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11282: LD_ADDR_EXP 121
11286: PUSH
11287: LD_EXP 121
11291: PPUSH
11292: LD_INT 2
11294: PPUSH
11295: LD_EXP 121
11299: PUSH
11300: LD_INT 2
11302: ARRAY
11303: PUSH
11304: LD_VAR 0 2
11308: DIFF
11309: PPUSH
11310: CALL_OW 1
11314: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: LD_INT 0
11322: PPUSH
11323: LD_INT 1
11325: PPUSH
11326: CALL_OW 12
11330: ST_TO_ADDR
// p := 0 ;
11331: LD_ADDR_VAR 0 5
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// if target then
11339: LD_VAR 0 3
11343: IFFALSE 11492
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11345: LD_ADDR_VAR 0 2
11349: PUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: LD_INT 50
11357: PUSH
11358: EMPTY
11359: LIST
11360: PPUSH
11361: CALL_OW 72
11365: ST_TO_ADDR
// for i in tmp do
11366: LD_ADDR_VAR 0 1
11370: PUSH
11371: LD_VAR 0 2
11375: PUSH
11376: FOR_IN
11377: IFFALSE 11417
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11379: LD_VAR 0 1
11383: PPUSH
11384: LD_INT 139
11386: PPUSH
11387: LD_INT 89
11389: PPUSH
11390: CALL_OW 297
11394: PUSH
11395: LD_INT 9
11397: GREATER
11398: IFFALSE 11415
// ComMoveXY ( i , 139 , 89 ) ;
11400: LD_VAR 0 1
11404: PPUSH
11405: LD_INT 139
11407: PPUSH
11408: LD_INT 89
11410: PPUSH
11411: CALL_OW 111
11415: GO 11376
11417: POP
11418: POP
// wait ( 0 0$1 ) ;
11419: LD_INT 35
11421: PPUSH
11422: CALL_OW 67
// p := Inc ( p ) ;
11426: LD_ADDR_VAR 0 5
11430: PUSH
11431: LD_VAR 0 5
11435: PPUSH
11436: CALL 109465 0 1
11440: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11441: LD_VAR 0 2
11445: PPUSH
11446: LD_INT 92
11448: PUSH
11449: LD_INT 139
11451: PUSH
11452: LD_INT 89
11454: PUSH
11455: LD_INT 9
11457: PUSH
11458: EMPTY
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PPUSH
11464: CALL_OW 72
11468: PUSH
11469: LD_VAR 0 2
11473: PUSH
11474: LD_INT 1
11476: MINUS
11477: GREATEREQUAL
11478: PUSH
11479: LD_VAR 0 5
11483: PUSH
11484: LD_INT 60
11486: GREATER
11487: OR
11488: IFFALSE 11345
// end else
11490: GO 11655
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11492: LD_VAR 0 2
11496: PPUSH
11497: LD_VAR 0 4
11501: PUSH
11502: LD_INT 1
11504: ARRAY
11505: PPUSH
11506: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11510: LD_ADDR_VAR 0 2
11514: PUSH
11515: LD_VAR 0 2
11519: PPUSH
11520: LD_INT 50
11522: PUSH
11523: EMPTY
11524: LIST
11525: PPUSH
11526: CALL_OW 72
11530: ST_TO_ADDR
// for i in tmp do
11531: LD_ADDR_VAR 0 1
11535: PUSH
11536: LD_VAR 0 2
11540: PUSH
11541: FOR_IN
11542: IFFALSE 11582
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11544: LD_VAR 0 1
11548: PPUSH
11549: LD_INT 124
11551: PPUSH
11552: LD_INT 139
11554: PPUSH
11555: CALL_OW 297
11559: PUSH
11560: LD_INT 9
11562: GREATER
11563: IFFALSE 11580
// ComMoveXY ( i , 124 , 139 ) ;
11565: LD_VAR 0 1
11569: PPUSH
11570: LD_INT 124
11572: PPUSH
11573: LD_INT 139
11575: PPUSH
11576: CALL_OW 111
11580: GO 11541
11582: POP
11583: POP
// wait ( 0 0$1 ) ;
11584: LD_INT 35
11586: PPUSH
11587: CALL_OW 67
// p := Inc ( p ) ;
11591: LD_ADDR_VAR 0 5
11595: PUSH
11596: LD_VAR 0 5
11600: PPUSH
11601: CALL 109465 0 1
11605: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11606: LD_VAR 0 2
11610: PPUSH
11611: LD_INT 92
11613: PUSH
11614: LD_INT 124
11616: PUSH
11617: LD_INT 139
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PPUSH
11629: CALL_OW 72
11633: PUSH
11634: LD_VAR 0 2
11638: PUSH
11639: LD_INT 1
11641: MINUS
11642: GREATEREQUAL
11643: PUSH
11644: LD_VAR 0 5
11648: PUSH
11649: LD_INT 60
11651: GREATER
11652: OR
11653: IFFALSE 11510
// end ; repeat wait ( 0 0$1 ) ;
11655: LD_INT 35
11657: PPUSH
11658: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11662: LD_ADDR_VAR 0 2
11666: PUSH
11667: LD_VAR 0 2
11671: PPUSH
11672: LD_INT 50
11674: PUSH
11675: EMPTY
11676: LIST
11677: PPUSH
11678: CALL_OW 72
11682: ST_TO_ADDR
// for i in tmp do
11683: LD_ADDR_VAR 0 1
11687: PUSH
11688: LD_VAR 0 2
11692: PUSH
11693: FOR_IN
11694: IFFALSE 11819
// begin if GetWeapon ( i ) = ru_time_lapser then
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL_OW 264
11705: PUSH
11706: LD_INT 49
11708: EQUAL
11709: IFFALSE 11765
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11711: LD_VAR 0 1
11715: PPUSH
11716: LD_INT 2
11718: PUSH
11719: LD_INT 22
11721: PUSH
11722: LD_INT 1
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: PUSH
11729: LD_INT 22
11731: PUSH
11732: LD_INT 8
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: PPUSH
11744: CALL_OW 69
11748: PPUSH
11749: LD_VAR 0 1
11753: PPUSH
11754: CALL_OW 74
11758: PPUSH
11759: CALL_OW 112
11763: GO 11817
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11765: LD_VAR 0 1
11769: PPUSH
11770: LD_INT 2
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 22
11785: PUSH
11786: LD_INT 8
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: PPUSH
11798: CALL_OW 69
11802: PPUSH
11803: LD_VAR 0 1
11807: PPUSH
11808: CALL_OW 74
11812: PPUSH
11813: CALL_OW 115
// end ;
11817: GO 11693
11819: POP
11820: POP
// until not tmp ;
11821: LD_VAR 0 2
11825: NOT
11826: IFFALSE 11655
// end ;
11828: PPOPN 5
11830: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11831: LD_EXP 15
11835: PUSH
11836: LD_INT 7
11838: GREATEREQUAL
11839: PUSH
11840: LD_OWVAR 67
11844: PUSH
11845: LD_INT 1
11847: GREATER
11848: AND
11849: IFFALSE 12141
11851: GO 11853
11853: DISABLE
11854: LD_INT 0
11856: PPUSH
11857: PPUSH
11858: PPUSH
// begin ruMobile := [ ] ;
11859: LD_ADDR_EXP 78
11863: PUSH
11864: EMPTY
11865: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 4
11878: PUSH
11879: LD_INT 5
11881: PUSH
11882: LD_INT 6
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: PUSH
11890: LD_OWVAR 67
11894: PUSH
11895: LD_INT 1
11897: MINUS
11898: ARRAY
11899: PUSH
11900: FOR_TO
11901: IFFALSE 12139
// begin uc_side := 3 ;
11903: LD_ADDR_OWVAR 20
11907: PUSH
11908: LD_INT 3
11910: ST_TO_ADDR
// uc_nation := 1 ;
11911: LD_ADDR_OWVAR 21
11915: PUSH
11916: LD_INT 1
11918: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11919: LD_INT 5
11921: PPUSH
11922: LD_INT 3
11924: PPUSH
11925: LD_INT 1
11927: PPUSH
11928: LD_INT 9
11930: PUSH
11931: LD_INT 7
11933: PUSH
11934: EMPTY
11935: LIST
11936: LIST
11937: PUSH
11938: LD_VAR 0 1
11942: PUSH
11943: LD_INT 2
11945: MOD
11946: PUSH
11947: LD_INT 1
11949: PLUS
11950: ARRAY
11951: PPUSH
11952: LD_INT 100
11954: PPUSH
11955: CALL 75233 0 5
// veh := CreateVehicle ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: CALL_OW 45
11968: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11969: LD_VAR 0 2
11973: PPUSH
11974: LD_INT 3
11976: PPUSH
11977: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11981: LD_VAR 0 2
11985: PPUSH
11986: LD_INT 29
11988: PPUSH
11989: LD_INT 0
11991: PPUSH
11992: CALL_OW 49
// uc_nation := 3 ;
11996: LD_ADDR_OWVAR 21
12000: PUSH
12001: LD_INT 3
12003: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12004: LD_INT 0
12006: PPUSH
12007: LD_INT 10
12009: PPUSH
12010: CALL_OW 383
// un := CreateHuman ;
12014: LD_ADDR_VAR 0 3
12018: PUSH
12019: CALL_OW 44
12023: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12024: LD_VAR 0 3
12028: PPUSH
12029: LD_INT 105
12031: PPUSH
12032: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12036: LD_VAR 0 3
12040: PPUSH
12041: LD_INT 3
12043: PPUSH
12044: CALL_OW 259
12048: PUSH
12049: LD_INT 8
12051: PUSH
12052: LD_INT 9
12054: PUSH
12055: LD_INT 10
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PUSH
12063: LD_OWVAR 67
12067: ARRAY
12068: LESS
12069: IFFALSE 12103
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12071: LD_VAR 0 3
12075: PPUSH
12076: LD_INT 3
12078: PPUSH
12079: LD_INT 8
12081: PUSH
12082: LD_INT 9
12084: PUSH
12085: LD_INT 10
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PUSH
12093: LD_OWVAR 67
12097: ARRAY
12098: PPUSH
12099: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12103: LD_VAR 0 3
12107: PPUSH
12108: LD_VAR 0 2
12112: PPUSH
12113: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12117: LD_ADDR_EXP 78
12121: PUSH
12122: LD_EXP 78
12126: PPUSH
12127: LD_VAR 0 2
12131: PPUSH
12132: CALL 108104 0 2
12136: ST_TO_ADDR
// end ;
12137: GO 11900
12139: POP
12140: POP
// end ;
12141: PPOPN 3
12143: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12144: LD_EXP 78
12148: IFFALSE 12657
12150: GO 12152
12152: DISABLE
12153: LD_INT 0
12155: PPUSH
12156: PPUSH
12157: PPUSH
// begin enable ;
12158: ENABLE
// if not ruMobile then
12159: LD_EXP 78
12163: NOT
12164: IFFALSE 12169
// begin disable ;
12166: DISABLE
// exit ;
12167: GO 12657
// end ; for i in ruMobile do
12169: LD_ADDR_VAR 0 1
12173: PUSH
12174: LD_EXP 78
12178: PUSH
12179: FOR_IN
12180: IFFALSE 12655
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL_OW 302
12191: NOT
12192: PUSH
12193: LD_VAR 0 1
12197: PPUSH
12198: CALL_OW 255
12202: PUSH
12203: LD_INT 3
12205: NONEQUAL
12206: OR
12207: IFFALSE 12227
// begin ruMobile := ruMobile diff i ;
12209: LD_ADDR_EXP 78
12213: PUSH
12214: LD_EXP 78
12218: PUSH
12219: LD_VAR 0 1
12223: DIFF
12224: ST_TO_ADDR
// continue ;
12225: GO 12179
// end ; if GetTag ( i ) = 300 then
12227: LD_VAR 0 1
12231: PPUSH
12232: CALL_OW 110
12236: PUSH
12237: LD_INT 300
12239: EQUAL
12240: IFFALSE 12290
// begin ComMoveXY ( i , 160 , 81 ) ;
12242: LD_VAR 0 1
12246: PPUSH
12247: LD_INT 160
12249: PPUSH
12250: LD_INT 81
12252: PPUSH
12253: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12257: LD_VAR 0 1
12261: PPUSH
12262: LD_INT 160
12264: PPUSH
12265: LD_INT 81
12267: PPUSH
12268: CALL_OW 297
12272: PUSH
12273: LD_INT 8
12275: LESS
12276: IFFALSE 12290
// SetTag ( i , 301 ) ;
12278: LD_VAR 0 1
12282: PPUSH
12283: LD_INT 301
12285: PPUSH
12286: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12290: LD_VAR 0 1
12294: PPUSH
12295: CALL_OW 110
12299: PUSH
12300: LD_INT 301
12302: EQUAL
12303: IFFALSE 12346
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_INT 33
12312: PPUSH
12313: CALL_OW 308
12317: NOT
12318: IFFALSE 12334
// ComMoveToArea ( i , ruMobileParkingArea ) else
12320: LD_VAR 0 1
12324: PPUSH
12325: LD_INT 33
12327: PPUSH
12328: CALL_OW 113
12332: GO 12346
// SetTag ( i , 302 ) ;
12334: LD_VAR 0 1
12338: PPUSH
12339: LD_INT 302
12341: PPUSH
12342: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 110
12355: PUSH
12356: LD_INT 302
12358: EQUAL
12359: IFFALSE 12489
// begin if GetLives ( i ) < 1000 then
12361: LD_VAR 0 1
12365: PPUSH
12366: CALL_OW 256
12370: PUSH
12371: LD_INT 1000
12373: LESS
12374: IFFALSE 12466
// begin if not IsDrivenBy ( i ) then
12376: LD_VAR 0 1
12380: PPUSH
12381: CALL_OW 311
12385: NOT
12386: IFFALSE 12390
// continue ;
12388: GO 12179
// mech := IsDrivenBy ( i ) ;
12390: LD_ADDR_VAR 0 2
12394: PUSH
12395: LD_VAR 0 1
12399: PPUSH
12400: CALL_OW 311
12404: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12405: LD_VAR 0 2
12409: PPUSH
12410: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12414: LD_VAR 0 2
12418: PPUSH
12419: LD_VAR 0 1
12423: PPUSH
12424: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12428: LD_INT 35
12430: PPUSH
12431: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 256
12444: PUSH
12445: LD_INT 1000
12447: EQUAL
12448: IFFALSE 12428
// ComEnterUnit ( mech , i ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 120
// end else
12464: GO 12489
// if IsDrivenBy ( i ) then
12466: LD_VAR 0 1
12470: PPUSH
12471: CALL_OW 311
12475: IFFALSE 12489
// SetTag ( i , 0 ) ;
12477: LD_VAR 0 1
12481: PPUSH
12482: LD_INT 0
12484: PPUSH
12485: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 110
12498: PUSH
12499: LD_INT 300
12501: LESS
12502: IFFALSE 12653
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12504: LD_ADDR_VAR 0 3
12508: PUSH
12509: LD_INT 4
12511: PPUSH
12512: LD_INT 81
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PPUSH
12522: CALL_OW 70
12526: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12527: LD_VAR 0 1
12531: PPUSH
12532: CALL_OW 256
12536: PUSH
12537: LD_INT 650
12539: LESS
12540: IFFALSE 12565
// begin ComStop ( i ) ;
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 141
// SetTag ( i , 300 ) ;
12551: LD_VAR 0 1
12555: PPUSH
12556: LD_INT 300
12558: PPUSH
12559: CALL_OW 109
// continue ;
12563: GO 12179
// end ; if enemy then
12565: LD_VAR 0 3
12569: IFFALSE 12609
// begin if not HasTask ( i ) then
12571: LD_VAR 0 1
12575: PPUSH
12576: CALL_OW 314
12580: NOT
12581: IFFALSE 12607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12583: LD_VAR 0 1
12587: PPUSH
12588: LD_VAR 0 3
12592: PPUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 74
12602: PPUSH
12603: CALL_OW 115
// end else
12607: GO 12653
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12609: LD_VAR 0 1
12613: PPUSH
12614: LD_INT 158
12616: PUSH
12617: LD_INT 61
12619: PUSH
12620: EMPTY
12621: LIST
12622: LIST
12623: PUSH
12624: LD_INT 98
12626: PUSH
12627: LD_INT 100
12629: PUSH
12630: EMPTY
12631: LIST
12632: LIST
12633: PUSH
12634: LD_INT 78
12636: PUSH
12637: LD_INT 93
12639: PUSH
12640: EMPTY
12641: LIST
12642: LIST
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: LIST
12648: PPUSH
12649: CALL 110714 0 2
// end ; end ;
12653: GO 12179
12655: POP
12656: POP
// end ; end_of_file
12657: PPOPN 3
12659: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12660: LD_INT 0
12662: PPUSH
12663: PPUSH
12664: PPUSH
12665: PPUSH
12666: PPUSH
12667: PPUSH
12668: PPUSH
// if Difficulty = 1 then
12669: LD_OWVAR 67
12673: PUSH
12674: LD_INT 1
12676: EQUAL
12677: IFFALSE 12715
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_INT 95
12686: PUSH
12687: LD_INT 34
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PPUSH
12694: CALL_OW 69
12698: PUSH
12699: FOR_IN
12700: IFFALSE 12713
// RemoveUnit ( i ) ;
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 64
12711: GO 12699
12713: POP
12714: POP
// SetInvulnrability ( alien , true ) ;
12715: LD_INT 1
12717: PPUSH
12718: LD_INT 1
12720: PPUSH
12721: CALL_OW 607
// side := 7 ;
12725: LD_ADDR_VAR 0 5
12729: PUSH
12730: LD_INT 7
12732: ST_TO_ADDR
// uc_side := side ;
12733: LD_ADDR_OWVAR 20
12737: PUSH
12738: LD_VAR 0 5
12742: ST_TO_ADDR
// uc_nation := 1 ;
12743: LD_ADDR_OWVAR 21
12747: PUSH
12748: LD_INT 1
12750: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12751: LD_ADDR_VAR 0 2
12755: PUSH
12756: LD_INT 22
12758: PUSH
12759: LD_VAR 0 5
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 21
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: FOR_IN
12788: IFFALSE 12804
// SetBLevel ( i , 10 ) ;
12790: LD_VAR 0 2
12794: PPUSH
12795: LD_INT 10
12797: PPUSH
12798: CALL_OW 241
12802: GO 12787
12804: POP
12805: POP
// base := GetBase ( al_depot ) ;
12806: LD_ADDR_VAR 0 4
12810: PUSH
12811: LD_INT 2
12813: PPUSH
12814: CALL_OW 274
12818: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12819: LD_ADDR_VAR 0 6
12823: PUSH
12824: LD_INT 22
12826: PUSH
12827: LD_VAR 0 5
12831: PUSH
12832: EMPTY
12833: LIST
12834: LIST
12835: PUSH
12836: LD_INT 30
12838: PUSH
12839: LD_INT 34
12841: PUSH
12842: EMPTY
12843: LIST
12844: LIST
12845: PUSH
12846: EMPTY
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 69
12854: ST_TO_ADDR
// if teleport then
12855: LD_VAR 0 6
12859: IFFALSE 12880
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12861: LD_VAR 0 6
12865: PUSH
12866: LD_INT 1
12868: ARRAY
12869: PPUSH
12870: LD_INT 262
12872: PPUSH
12873: LD_INT 119
12875: PPUSH
12876: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12880: LD_VAR 0 4
12884: PPUSH
12885: LD_INT 1
12887: PPUSH
12888: LD_INT 19500
12890: PPUSH
12891: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12895: LD_VAR 0 4
12899: PPUSH
12900: LD_INT 2
12902: PPUSH
12903: LD_INT 200
12905: PPUSH
12906: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12910: LD_VAR 0 4
12914: PPUSH
12915: LD_INT 3
12917: PPUSH
12918: LD_INT 650
12920: PPUSH
12921: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12925: LD_ADDR_EXP 79
12929: PUSH
12930: LD_STRING Roth
12932: PPUSH
12933: CALL_OW 25
12937: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12938: LD_ADDR_EXP 80
12942: PUSH
12943: LD_STRING Simms
12945: PPUSH
12946: LD_EXP 1
12950: NOT
12951: PPUSH
12952: LD_STRING 10c_
12954: PPUSH
12955: CALL 70309 0 3
12959: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12960: LD_EXP 80
12964: PPUSH
12965: LD_INT 4
12967: PPUSH
12968: CALL_OW 336
// if not Simms then
12972: LD_EXP 80
12976: NOT
12977: IFFALSE 13007
// begin uc_nation := 1 ;
12979: LD_ADDR_OWVAR 21
12983: PUSH
12984: LD_INT 1
12986: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12987: LD_INT 2
12989: PPUSH
12990: LD_INT 10
12992: PPUSH
12993: CALL_OW 384
// Simms := CreateHuman ;
12997: LD_ADDR_EXP 80
13001: PUSH
13002: CALL_OW 44
13006: ST_TO_ADDR
// end ; uc_nation := 3 ;
13007: LD_ADDR_OWVAR 21
13011: PUSH
13012: LD_INT 3
13014: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13015: LD_ADDR_EXP 81
13019: PUSH
13020: LD_STRING Kirilenkova
13022: PPUSH
13023: CALL_OW 25
13027: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13028: LD_ADDR_EXP 95
13032: PUSH
13033: LD_STRING Oblukov
13035: PPUSH
13036: CALL_OW 25
13040: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13041: LD_ADDR_EXP 82
13045: PUSH
13046: LD_STRING Dolgov
13048: PPUSH
13049: CALL_OW 25
13053: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13054: LD_ADDR_EXP 83
13058: PUSH
13059: LD_STRING Petrosyan
13061: PPUSH
13062: CALL_OW 25
13066: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13067: LD_ADDR_EXP 94
13071: PUSH
13072: LD_STRING Scholtze
13074: PPUSH
13075: CALL_OW 25
13079: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13080: LD_ADDR_EXP 93
13084: PUSH
13085: LD_STRING Kapitsova
13087: PPUSH
13088: CALL_OW 25
13092: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13093: LD_ADDR_EXP 84
13097: PUSH
13098: LD_STRING Petrovova
13100: PPUSH
13101: CALL_OW 25
13105: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13106: LD_ADDR_EXP 85
13110: PUSH
13111: LD_STRING Kuzmov
13113: PPUSH
13114: CALL_OW 25
13118: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13119: LD_ADDR_EXP 92
13123: PUSH
13124: LD_STRING Karamazov
13126: PPUSH
13127: CALL_OW 25
13131: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13132: LD_STRING 13_Lipshchin_1
13134: PPUSH
13135: LD_INT 0
13137: PPUSH
13138: CALL_OW 30
13142: IFFALSE 13157
// Lipshchin := NewCharacter ( Lipshchin ) ;
13144: LD_ADDR_EXP 86
13148: PUSH
13149: LD_STRING Lipshchin
13151: PPUSH
13152: CALL_OW 25
13156: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13157: LD_STRING 13_Titov_1
13159: PPUSH
13160: LD_INT 0
13162: PPUSH
13163: CALL_OW 30
13167: IFFALSE 13182
// Titov := NewCharacter ( Titov ) ;
13169: LD_ADDR_EXP 88
13173: PUSH
13174: LD_STRING Titov
13176: PPUSH
13177: CALL_OW 25
13181: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13182: LD_STRING 13_Gnyevko_1
13184: PPUSH
13185: LD_INT 0
13187: PPUSH
13188: CALL_OW 30
13192: IFFALSE 13207
// Gnyevko := NewCharacter ( Gnyevko ) ;
13194: LD_ADDR_EXP 87
13198: PUSH
13199: LD_STRING Gnyevko
13201: PPUSH
13202: CALL_OW 25
13206: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13207: LD_STRING 13_Xavier_1
13209: PPUSH
13210: LD_INT 0
13212: PPUSH
13213: CALL_OW 30
13217: IFFALSE 13232
// Xavier := NewCharacter ( Xavier2 ) ;
13219: LD_ADDR_EXP 89
13223: PUSH
13224: LD_STRING Xavier2
13226: PPUSH
13227: CALL_OW 25
13231: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13232: LD_STRING 13_Belkov_1
13234: PPUSH
13235: LD_INT 0
13237: PPUSH
13238: CALL_OW 30
13242: IFFALSE 13257
// Belkov := NewCharacter ( Belkov ) ;
13244: LD_ADDR_EXP 90
13248: PUSH
13249: LD_STRING Belkov
13251: PPUSH
13252: CALL_OW 25
13256: ST_TO_ADDR
// if not BurlakStatus then
13257: LD_EXP 9
13261: NOT
13262: IFFALSE 13277
// Burlak = NewCharacter ( Burlak ) ;
13264: LD_ADDR_EXP 91
13268: PUSH
13269: LD_STRING Burlak
13271: PPUSH
13272: CALL_OW 25
13276: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13277: LD_ADDR_VAR 0 3
13281: PUSH
13282: LD_EXP 79
13286: PUSH
13287: LD_EXP 81
13291: PUSH
13292: LD_EXP 95
13296: PUSH
13297: LD_EXP 82
13301: PUSH
13302: LD_EXP 83
13306: PUSH
13307: LD_EXP 94
13311: PUSH
13312: LD_EXP 93
13316: PUSH
13317: LD_EXP 84
13321: PUSH
13322: LD_EXP 85
13326: PUSH
13327: LD_EXP 92
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: ST_TO_ADDR
// if Simms then
13344: LD_EXP 80
13348: IFFALSE 13366
// tmp := tmp ^ Simms ;
13350: LD_ADDR_VAR 0 3
13354: PUSH
13355: LD_VAR 0 3
13359: PUSH
13360: LD_EXP 80
13364: ADD
13365: ST_TO_ADDR
// if Titov then
13366: LD_EXP 88
13370: IFFALSE 13388
// tmp := tmp ^ Titov ;
13372: LD_ADDR_VAR 0 3
13376: PUSH
13377: LD_VAR 0 3
13381: PUSH
13382: LD_EXP 88
13386: ADD
13387: ST_TO_ADDR
// if Lipshchin then
13388: LD_EXP 86
13392: IFFALSE 13410
// tmp := tmp ^ Lipshchin ;
13394: LD_ADDR_VAR 0 3
13398: PUSH
13399: LD_VAR 0 3
13403: PUSH
13404: LD_EXP 86
13408: ADD
13409: ST_TO_ADDR
// if Gnyevko then
13410: LD_EXP 87
13414: IFFALSE 13432
// tmp := tmp ^ Gnyevko ;
13416: LD_ADDR_VAR 0 3
13420: PUSH
13421: LD_VAR 0 3
13425: PUSH
13426: LD_EXP 87
13430: ADD
13431: ST_TO_ADDR
// if Xavier then
13432: LD_EXP 89
13436: IFFALSE 13454
// tmp := tmp ^ Xavier ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: LD_VAR 0 3
13447: PUSH
13448: LD_EXP 89
13452: ADD
13453: ST_TO_ADDR
// if Belkov then
13454: LD_EXP 90
13458: IFFALSE 13476
// tmp := tmp ^ Belkov ;
13460: LD_ADDR_VAR 0 3
13464: PUSH
13465: LD_VAR 0 3
13469: PUSH
13470: LD_EXP 90
13474: ADD
13475: ST_TO_ADDR
// if Burlak then
13476: LD_EXP 91
13480: IFFALSE 13498
// tmp := tmp ^ Burlak ;
13482: LD_ADDR_VAR 0 3
13486: PUSH
13487: LD_VAR 0 3
13491: PUSH
13492: LD_EXP 91
13496: ADD
13497: ST_TO_ADDR
// for i = 1 to 11 do
13498: LD_ADDR_VAR 0 2
13502: PUSH
13503: DOUBLE
13504: LD_INT 1
13506: DEC
13507: ST_TO_ADDR
13508: LD_INT 11
13510: PUSH
13511: FOR_TO
13512: IFFALSE 13580
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13514: LD_ADDR_OWVAR 21
13518: PUSH
13519: LD_INT 1
13521: PUSH
13522: LD_INT 3
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: PUSH
13529: LD_INT 1
13531: PPUSH
13532: LD_INT 2
13534: PPUSH
13535: CALL_OW 12
13539: ARRAY
13540: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13541: LD_INT 0
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: LD_INT 4
13549: PPUSH
13550: CALL_OW 12
13554: PPUSH
13555: LD_INT 10
13557: PPUSH
13558: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13562: LD_ADDR_VAR 0 3
13566: PUSH
13567: LD_VAR 0 3
13571: PUSH
13572: CALL_OW 44
13576: ADD
13577: ST_TO_ADDR
// end ;
13578: GO 13511
13580: POP
13581: POP
// for i in tmp do
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 3
13591: PUSH
13592: FOR_IN
13593: IFFALSE 13618
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13595: LD_VAR 0 2
13599: PPUSH
13600: LD_INT 260
13602: PPUSH
13603: LD_INT 235
13605: PPUSH
13606: LD_INT 8
13608: PPUSH
13609: LD_INT 0
13611: PPUSH
13612: CALL_OW 50
13616: GO 13592
13618: POP
13619: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13620: LD_ADDR_EXP 102
13624: PUSH
13625: LD_EXP 102
13629: PPUSH
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 22
13635: PUSH
13636: LD_VAR 0 5
13640: PUSH
13641: EMPTY
13642: LIST
13643: LIST
13644: PUSH
13645: LD_INT 3
13647: PUSH
13648: LD_INT 21
13650: PUSH
13651: LD_INT 2
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PUSH
13671: LD_EXP 79
13675: PUSH
13676: LD_EXP 80
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: DIFF
13685: PPUSH
13686: CALL_OW 1
13690: ST_TO_ADDR
// uc_side := 0 ;
13691: LD_ADDR_OWVAR 20
13695: PUSH
13696: LD_INT 0
13698: ST_TO_ADDR
// uc_nation := 0 ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_INT 0
13706: ST_TO_ADDR
// for i = 1 to 5 do
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: DOUBLE
13713: LD_INT 1
13715: DEC
13716: ST_TO_ADDR
13717: LD_INT 5
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13758
// begin InitHc ;
13723: CALL_OW 19
// hc_class := class_apeman ;
13727: LD_ADDR_OWVAR 28
13731: PUSH
13732: LD_INT 12
13734: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13735: CALL_OW 44
13739: PPUSH
13740: LD_INT 299
13742: PPUSH
13743: LD_INT 229
13745: PPUSH
13746: LD_INT 10
13748: PPUSH
13749: LD_INT 0
13751: PPUSH
13752: CALL_OW 50
// end ;
13756: GO 13720
13758: POP
13759: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13760: LD_EXP 79
13764: PPUSH
13765: LD_INT 259
13767: PPUSH
13768: LD_INT 235
13770: PPUSH
13771: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13775: LD_EXP 79
13779: PPUSH
13780: LD_INT 262
13782: PPUSH
13783: LD_INT 235
13785: PPUSH
13786: CALL_OW 178
// if Simms then
13790: LD_EXP 80
13794: IFFALSE 13825
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13796: LD_EXP 80
13800: PPUSH
13801: LD_INT 262
13803: PPUSH
13804: LD_INT 235
13806: PPUSH
13807: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13811: LD_EXP 80
13815: PPUSH
13816: LD_EXP 79
13820: PPUSH
13821: CALL_OW 179
// end ; uc_side := 7 ;
13825: LD_ADDR_OWVAR 20
13829: PUSH
13830: LD_INT 7
13832: ST_TO_ADDR
// uc_nation := 1 ;
13833: LD_ADDR_OWVAR 21
13837: PUSH
13838: LD_INT 1
13840: ST_TO_ADDR
// bc_type := b_control_tower ;
13841: LD_ADDR_OWVAR 42
13845: PUSH
13846: LD_INT 36
13848: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13849: LD_ADDR_VAR 0 7
13853: PUSH
13854: LD_INT 268
13856: PPUSH
13857: LD_INT 251
13859: PPUSH
13860: LD_INT 4
13862: PPUSH
13863: CALL_OW 47
13867: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13868: LD_INT 0
13870: PPUSH
13871: LD_INT 10
13873: PPUSH
13874: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13878: CALL_OW 44
13882: PPUSH
13883: LD_VAR 0 7
13887: PPUSH
13888: CALL_OW 52
// end ;
13892: LD_VAR 0 1
13896: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13897: LD_EXP 31
13901: PUSH
13902: LD_EXP 23
13906: NOT
13907: AND
13908: PUSH
13909: LD_INT 22
13911: PUSH
13912: LD_INT 7
13914: PUSH
13915: EMPTY
13916: LIST
13917: LIST
13918: PUSH
13919: LD_INT 30
13921: PUSH
13922: LD_INT 8
13924: PUSH
13925: EMPTY
13926: LIST
13927: LIST
13928: PUSH
13929: EMPTY
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: AND
13938: IFFALSE 14166
13940: GO 13942
13942: DISABLE
13943: LD_INT 0
13945: PPUSH
13946: PPUSH
13947: PPUSH
// begin enable ;
13948: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13949: LD_ADDR_VAR 0 2
13953: PUSH
13954: LD_INT 81
13956: PUSH
13957: LD_INT 7
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 2
13966: PUSH
13967: LD_INT 32
13969: PUSH
13970: LD_INT 3
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 30
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PUSH
13987: LD_INT 30
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: EMPTY
13994: LIST
13995: LIST
13996: PUSH
13997: LD_INT 34
13999: PUSH
14000: LD_INT 49
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 34
14009: PUSH
14010: LD_INT 10
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PUSH
14017: LD_INT 34
14019: PUSH
14020: LD_INT 8
14022: PUSH
14023: EMPTY
14024: LIST
14025: LIST
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: PPUSH
14040: CALL_OW 69
14044: ST_TO_ADDR
// if not tmp then
14045: LD_VAR 0 2
14049: NOT
14050: IFFALSE 14054
// exit ;
14052: GO 14166
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14054: LD_VAR 0 2
14058: PPUSH
14059: LD_INT 34
14061: PUSH
14062: LD_INT 8
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PPUSH
14069: CALL_OW 72
14073: IFFALSE 14106
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14075: LD_ADDR_VAR 0 3
14079: PUSH
14080: LD_VAR 0 2
14084: PPUSH
14085: LD_INT 34
14087: PUSH
14088: LD_INT 8
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: PPUSH
14095: CALL_OW 72
14099: PUSH
14100: LD_INT 1
14102: ARRAY
14103: ST_TO_ADDR
14104: GO 14130
// target := tmp [ rand ( 1 , tmp ) ] ;
14106: LD_ADDR_VAR 0 3
14110: PUSH
14111: LD_VAR 0 2
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 2
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14130: LD_VAR 0 3
14134: PPUSH
14135: CALL_OW 255
14139: PUSH
14140: LD_INT 1
14142: EQUAL
14143: IFFALSE 14154
// CenterNowOnUnits ( target ) ;
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 87
// SetLives ( target , 0 ) ;
14154: LD_VAR 0 3
14158: PPUSH
14159: LD_INT 0
14161: PPUSH
14162: CALL_OW 234
// end ;
14166: PPOPN 3
14168: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14169: LD_EXP 23
14173: NOT
14174: PUSH
14175: LD_EXP 31
14179: AND
14180: IFFALSE 14696
14182: GO 14184
14184: DISABLE
14185: LD_INT 0
14187: PPUSH
14188: PPUSH
14189: PPUSH
// begin uc_side := 7 ;
14190: LD_ADDR_OWVAR 20
14194: PUSH
14195: LD_INT 7
14197: ST_TO_ADDR
// uc_nation := 1 ;
14198: LD_ADDR_OWVAR 21
14202: PUSH
14203: LD_INT 1
14205: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14206: LD_ADDR_VAR 0 3
14210: PUSH
14211: LD_INT 125
14213: PUSH
14214: LD_INT 163
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: PUSH
14221: LD_INT 185
14223: PUSH
14224: LD_INT 168
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: PUSH
14231: LD_INT 111
14233: PUSH
14234: LD_INT 97
14236: PUSH
14237: EMPTY
14238: LIST
14239: LIST
14240: PUSH
14241: LD_INT 94
14243: PUSH
14244: LD_INT 114
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PPUSH
14257: CALL 108209 0 1
14261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14262: LD_ADDR_EXP 96
14266: PUSH
14267: EMPTY
14268: ST_TO_ADDR
// for i = 1 to Difficulty do
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: DOUBLE
14275: LD_INT 1
14277: DEC
14278: ST_TO_ADDR
14279: LD_OWVAR 67
14283: PUSH
14284: FOR_TO
14285: IFFALSE 14443
// begin InitHc ;
14287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14291: LD_INT 0
14293: PPUSH
14294: LD_INT 8
14296: PPUSH
14297: CALL_OW 381
// un := CreateHuman ;
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: CALL_OW 44
14310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14311: LD_VAR 0 2
14315: PPUSH
14316: LD_INT 258
14318: PPUSH
14319: LD_INT 267
14321: PPUSH
14322: LD_INT 4
14324: PPUSH
14325: LD_INT 0
14327: PPUSH
14328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14332: LD_ADDR_EXP 96
14336: PUSH
14337: LD_EXP 96
14341: PUSH
14342: LD_VAR 0 2
14346: UNION
14347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14348: LD_VAR 0 2
14352: PPUSH
14353: LD_VAR 0 3
14357: PUSH
14358: LD_VAR 0 1
14362: ARRAY
14363: PUSH
14364: LD_INT 1
14366: ARRAY
14367: PPUSH
14368: LD_VAR 0 3
14372: PUSH
14373: LD_VAR 0 1
14377: ARRAY
14378: PUSH
14379: LD_INT 2
14381: ARRAY
14382: PPUSH
14383: LD_INT 4
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 3
14402: PUSH
14403: LD_VAR 0 1
14407: ARRAY
14408: PUSH
14409: LD_INT 1
14411: ARRAY
14412: PPUSH
14413: LD_VAR 0 3
14417: PUSH
14418: LD_VAR 0 1
14422: ARRAY
14423: PUSH
14424: LD_INT 2
14426: ARRAY
14427: PPUSH
14428: CALL_OW 171
// AddComInvisible ( un ) ;
14432: LD_VAR 0 2
14436: PPUSH
14437: CALL_OW 212
// end ;
14441: GO 14284
14443: POP
14444: POP
// repeat wait ( 0 0$45 ) ;
14445: LD_INT 1575
14447: PPUSH
14448: CALL_OW 67
// for i in allianceSpecialForce do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_EXP 96
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14681
// begin if IsInvisible ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 571
14474: IFFALSE 14650
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14476: LD_ADDR_VAR 0 3
14480: PUSH
14481: LD_INT 22
14483: PUSH
14484: LD_INT 1
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PUSH
14491: LD_INT 50
14493: PUSH
14494: EMPTY
14495: LIST
14496: PUSH
14497: LD_INT 56
14499: PUSH
14500: EMPTY
14501: LIST
14502: PUSH
14503: LD_INT 91
14505: PUSH
14506: LD_VAR 0 1
14510: PUSH
14511: LD_INT 25
14513: PUSH
14514: EMPTY
14515: LIST
14516: LIST
14517: LIST
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: LD_INT 25
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PUSH
14532: LD_INT 25
14534: PUSH
14535: LD_INT 2
14537: PUSH
14538: EMPTY
14539: LIST
14540: LIST
14541: PUSH
14542: LD_INT 25
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: EMPTY
14549: LIST
14550: LIST
14551: PUSH
14552: LD_INT 25
14554: PUSH
14555: LD_INT 4
14557: PUSH
14558: EMPTY
14559: LIST
14560: LIST
14561: PUSH
14562: LD_INT 25
14564: PUSH
14565: LD_INT 5
14567: PUSH
14568: EMPTY
14569: LIST
14570: LIST
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: LD_INT 8
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: EMPTY
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: PUSH
14591: EMPTY
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: PPUSH
14598: CALL_OW 69
14602: ST_TO_ADDR
// if not tmp then
14603: LD_VAR 0 3
14607: NOT
14608: IFFALSE 14612
// continue ;
14610: GO 14462
// if Prob ( 30 * Difficulty ) then
14612: LD_INT 30
14614: PUSH
14615: LD_OWVAR 67
14619: MUL
14620: PPUSH
14621: CALL_OW 13
14625: IFFALSE 14650
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 1
14634: PPUSH
14635: LD_VAR 0 3
14639: PPUSH
14640: CALL_OW 12
14644: ARRAY
14645: PPUSH
14646: CALL 35399 0 1
// end ; if IsDead ( i ) then
14650: LD_VAR 0 1
14654: PPUSH
14655: CALL_OW 301
14659: IFFALSE 14679
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14661: LD_ADDR_EXP 96
14665: PUSH
14666: LD_EXP 96
14670: PUSH
14671: LD_VAR 0 1
14675: DIFF
14676: ST_TO_ADDR
// continue ;
14677: GO 14462
// end ; end ;
14679: GO 14462
14681: POP
14682: POP
// until allianceDestroyed or not allianceSpecialForce ;
14683: LD_EXP 23
14687: PUSH
14688: LD_EXP 96
14692: NOT
14693: OR
14694: IFFALSE 14445
// end ;
14696: PPOPN 3
14698: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14699: LD_EXP 31
14703: PUSH
14704: LD_INT 22
14706: PUSH
14707: LD_INT 1
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: PUSH
14714: LD_INT 2
14716: PUSH
14717: LD_INT 35
14719: PUSH
14720: LD_INT 8
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PUSH
14727: LD_INT 34
14729: PUSH
14730: LD_INT 8
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PPUSH
14746: CALL_OW 69
14750: AND
14751: IFFALSE 15151
14753: GO 14755
14755: DISABLE
14756: LD_INT 0
14758: PPUSH
14759: PPUSH
14760: PPUSH
14761: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14762: LD_ADDR_VAR 0 1
14766: PUSH
14767: DOUBLE
14768: LD_INT 1
14770: DEC
14771: ST_TO_ADDR
14772: LD_INT 6
14774: PUSH
14775: LD_INT 8
14777: PUSH
14778: LD_INT 10
14780: PUSH
14781: LD_INT 12
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: PUSH
14790: LD_OWVAR 67
14794: ARRAY
14795: PUSH
14796: FOR_TO
14797: IFFALSE 14989
// begin uc_side := 7 ;
14799: LD_ADDR_OWVAR 20
14803: PUSH
14804: LD_INT 7
14806: ST_TO_ADDR
// uc_nation := 1 ;
14807: LD_ADDR_OWVAR 21
14811: PUSH
14812: LD_INT 1
14814: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14815: LD_INT 5
14817: PPUSH
14818: LD_INT 3
14820: PPUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 3
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PUSH
14831: LD_INT 1
14833: PPUSH
14834: LD_INT 2
14836: PPUSH
14837: CALL_OW 12
14841: ARRAY
14842: PPUSH
14843: LD_INT 6
14845: PUSH
14846: LD_INT 9
14848: PUSH
14849: EMPTY
14850: LIST
14851: LIST
14852: PUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 2
14858: PPUSH
14859: CALL_OW 12
14863: ARRAY
14864: PPUSH
14865: LD_INT 100
14867: PPUSH
14868: CALL 75233 0 5
// un := CreateVehicle ;
14872: LD_ADDR_VAR 0 2
14876: PUSH
14877: CALL_OW 45
14881: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14882: LD_VAR 0 2
14886: PPUSH
14887: LD_INT 4
14889: PPUSH
14890: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14894: LD_VAR 0 2
14898: PPUSH
14899: LD_INT 307
14901: PPUSH
14902: LD_INT 219
14904: PPUSH
14905: LD_INT 6
14907: PPUSH
14908: LD_INT 0
14910: PPUSH
14911: CALL_OW 50
// if GetControl ( un ) = control_remote then
14915: LD_VAR 0 2
14919: PPUSH
14920: CALL_OW 263
14924: PUSH
14925: LD_INT 2
14927: EQUAL
14928: IFFALSE 14939
// Connect ( un ) ;
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 78701 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14939: LD_VAR 0 2
14943: PPUSH
14944: LD_INT 124
14946: PPUSH
14947: LD_INT 92
14949: PPUSH
14950: LD_INT 12
14952: PPUSH
14953: LD_INT 1
14955: PPUSH
14956: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14960: LD_ADDR_VAR 0 3
14964: PUSH
14965: LD_VAR 0 3
14969: PPUSH
14970: LD_VAR 0 2
14974: PPUSH
14975: CALL 108104 0 2
14979: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14980: LD_INT 10
14982: PPUSH
14983: CALL_OW 67
// end ;
14987: GO 14796
14989: POP
14990: POP
// repeat wait ( 0 0$2 ) ;
14991: LD_INT 70
14993: PPUSH
14994: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14998: LD_ADDR_VAR 0 4
15002: PUSH
15003: LD_INT 22
15005: PUSH
15006: LD_INT 1
15008: PUSH
15009: EMPTY
15010: LIST
15011: LIST
15012: PUSH
15013: LD_INT 34
15015: PUSH
15016: LD_INT 8
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: EMPTY
15024: LIST
15025: LIST
15026: PPUSH
15027: CALL_OW 69
15031: ST_TO_ADDR
// if not e then
15032: LD_VAR 0 4
15036: NOT
15037: IFFALSE 15073
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15039: LD_ADDR_VAR 0 4
15043: PUSH
15044: LD_INT 22
15046: PUSH
15047: LD_INT 1
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: PUSH
15054: LD_INT 21
15056: PUSH
15057: LD_INT 2
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PPUSH
15068: CALL_OW 69
15072: ST_TO_ADDR
// for i in tmp do
15073: LD_ADDR_VAR 0 1
15077: PUSH
15078: LD_VAR 0 3
15082: PUSH
15083: FOR_IN
15084: IFFALSE 15142
// if not IsOK ( i ) then
15086: LD_VAR 0 1
15090: PPUSH
15091: CALL_OW 302
15095: NOT
15096: IFFALSE 15116
// tmp := tmp diff i else
15098: LD_ADDR_VAR 0 3
15102: PUSH
15103: LD_VAR 0 3
15107: PUSH
15108: LD_VAR 0 1
15112: DIFF
15113: ST_TO_ADDR
15114: GO 15140
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_VAR 0 4
15125: PPUSH
15126: LD_VAR 0 1
15130: PPUSH
15131: CALL_OW 74
15135: PPUSH
15136: CALL_OW 115
15140: GO 15083
15142: POP
15143: POP
// until not tmp ;
15144: LD_VAR 0 3
15148: NOT
15149: IFFALSE 14991
// end ;
15151: PPOPN 4
15153: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15154: LD_EXP 23
15158: NOT
15159: PUSH
15160: LD_EXP 31
15164: AND
15165: IFFALSE 16239
15167: GO 15169
15169: DISABLE
15170: LD_INT 0
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
15176: PPUSH
// begin enable ;
15177: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15178: LD_INT 22
15180: PUSH
15181: LD_INT 7
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: PUSH
15188: LD_INT 30
15190: PUSH
15191: LD_INT 3
15193: PUSH
15194: EMPTY
15195: LIST
15196: LIST
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: PPUSH
15202: CALL_OW 69
15206: NOT
15207: IFFALSE 15211
// exit ;
15209: GO 16239
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 22
15218: PUSH
15219: LD_INT 7
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 30
15228: PUSH
15229: LD_INT 34
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PPUSH
15240: CALL_OW 69
15244: ST_TO_ADDR
// if Prob ( 40 ) then
15245: LD_INT 40
15247: PPUSH
15248: CALL_OW 13
15252: IFFALSE 15398
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15254: LD_INT 1
15256: PPUSH
15257: LD_INT 5
15259: PUSH
15260: LD_INT 3
15262: PUSH
15263: LD_INT 2
15265: PUSH
15266: LD_INT 6
15268: PUSH
15269: EMPTY
15270: LIST
15271: LIST
15272: LIST
15273: LIST
15274: PUSH
15275: LD_INT 5
15277: PUSH
15278: LD_INT 3
15280: PUSH
15281: LD_INT 2
15283: PUSH
15284: LD_INT 6
15286: PUSH
15287: EMPTY
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: PUSH
15293: LD_INT 5
15295: PUSH
15296: LD_INT 3
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 5
15313: PUSH
15314: LD_INT 3
15316: PUSH
15317: LD_INT 2
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PUSH
15329: LD_INT 24
15331: PUSH
15332: LD_INT 3
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 45
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 24
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: LD_INT 3
15355: PUSH
15356: LD_INT 47
15358: PUSH
15359: EMPTY
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 24
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: LD_INT 3
15373: PUSH
15374: LD_INT 45
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: PPUSH
15392: CALL 63883 0 2
// end else
15396: GO 15540
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15398: LD_INT 1
15400: PPUSH
15401: LD_INT 24
15403: PUSH
15404: LD_INT 3
15406: PUSH
15407: LD_INT 3
15409: PUSH
15410: LD_INT 47
15412: PUSH
15413: EMPTY
15414: LIST
15415: LIST
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 24
15421: PUSH
15422: LD_INT 3
15424: PUSH
15425: LD_INT 3
15427: PUSH
15428: LD_INT 47
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 5
15439: PUSH
15440: LD_INT 3
15442: PUSH
15443: LD_INT 2
15445: PUSH
15446: LD_INT 9
15448: PUSH
15449: EMPTY
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: PUSH
15455: LD_INT 5
15457: PUSH
15458: LD_INT 3
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 9
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: PUSH
15473: LD_INT 5
15475: PUSH
15476: LD_INT 3
15478: PUSH
15479: LD_INT 2
15481: PUSH
15482: LD_INT 9
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: LIST
15489: LIST
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: LD_INT 1
15496: PUSH
15497: LD_INT 3
15499: PUSH
15500: LD_INT 45
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: LIST
15507: LIST
15508: PUSH
15509: LD_INT 24
15511: PUSH
15512: LD_INT 1
15514: PUSH
15515: LD_INT 3
15517: PUSH
15518: LD_INT 45
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: PUSH
15527: EMPTY
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL 63883 0 2
// end ; wait ( 2 2$00 ) ;
15540: LD_INT 4200
15542: PPUSH
15543: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15547: LD_ADDR_VAR 0 2
15551: PUSH
15552: LD_INT 22
15554: PUSH
15555: LD_INT 7
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 2
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PUSH
15572: LD_INT 3
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 13
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 3
15591: PUSH
15592: LD_INT 34
15594: PUSH
15595: LD_INT 12
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 3
15608: PUSH
15609: LD_INT 34
15611: PUSH
15612: LD_INT 51
15614: PUSH
15615: EMPTY
15616: LIST
15617: LIST
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 3
15625: PUSH
15626: LD_INT 34
15628: PUSH
15629: LD_INT 52
15631: PUSH
15632: EMPTY
15633: LIST
15634: LIST
15635: PUSH
15636: EMPTY
15637: LIST
15638: LIST
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: LIST
15644: LIST
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: PUSH
15653: LD_EXP 124
15657: PUSH
15658: LD_INT 1
15660: ARRAY
15661: DIFF
15662: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15663: LD_ADDR_EXP 121
15667: PUSH
15668: LD_EXP 121
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_EXP 121
15680: PUSH
15681: LD_INT 1
15683: ARRAY
15684: PUSH
15685: LD_VAR 0 2
15689: DIFF
15690: PPUSH
15691: CALL_OW 1
15695: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15696: LD_ADDR_VAR 0 3
15700: PUSH
15701: LD_INT 0
15703: PPUSH
15704: LD_INT 1
15706: PPUSH
15707: CALL_OW 12
15711: ST_TO_ADDR
// p := 0 ;
15712: LD_ADDR_VAR 0 5
15716: PUSH
15717: LD_INT 0
15719: ST_TO_ADDR
// if target then
15720: LD_VAR 0 3
15724: IFFALSE 15915
// begin for i in tmp do
15726: LD_ADDR_VAR 0 1
15730: PUSH
15731: LD_VAR 0 2
15735: PUSH
15736: FOR_IN
15737: IFFALSE 15762
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_INT 179
15746: PPUSH
15747: LD_INT 209
15749: PPUSH
15750: LD_INT 8
15752: PPUSH
15753: LD_INT 1
15755: PPUSH
15756: CALL_OW 483
15760: GO 15736
15762: POP
15763: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15764: LD_ADDR_VAR 0 2
15768: PUSH
15769: LD_VAR 0 2
15773: PPUSH
15774: LD_INT 24
15776: PUSH
15777: LD_INT 250
15779: PUSH
15780: EMPTY
15781: LIST
15782: LIST
15783: PPUSH
15784: CALL_OW 72
15788: ST_TO_ADDR
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15840
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 179
15809: PPUSH
15810: LD_INT 209
15812: PPUSH
15813: CALL_OW 297
15817: PUSH
15818: LD_INT 9
15820: GREATER
15821: IFFALSE 15838
// ComMoveXY ( i , 179 , 209 ) ;
15823: LD_VAR 0 1
15827: PPUSH
15828: LD_INT 179
15830: PPUSH
15831: LD_INT 209
15833: PPUSH
15834: CALL_OW 111
15838: GO 15799
15840: POP
15841: POP
// wait ( 0 0$1 ) ;
15842: LD_INT 35
15844: PPUSH
15845: CALL_OW 67
// p := Inc ( p ) ;
15849: LD_ADDR_VAR 0 5
15853: PUSH
15854: LD_VAR 0 5
15858: PPUSH
15859: CALL 109465 0 1
15863: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15864: LD_VAR 0 2
15868: PPUSH
15869: LD_INT 92
15871: PUSH
15872: LD_INT 179
15874: PUSH
15875: LD_INT 209
15877: PUSH
15878: LD_INT 9
15880: PUSH
15881: EMPTY
15882: LIST
15883: LIST
15884: LIST
15885: LIST
15886: PPUSH
15887: CALL_OW 72
15891: PUSH
15892: LD_VAR 0 2
15896: PUSH
15897: LD_INT 1
15899: MINUS
15900: GREATEREQUAL
15901: PUSH
15902: LD_VAR 0 5
15906: PUSH
15907: LD_INT 30
15909: GREATER
15910: OR
15911: IFFALSE 15764
// end else
15913: GO 16102
// begin for i in tmp do
15915: LD_ADDR_VAR 0 1
15919: PUSH
15920: LD_VAR 0 2
15924: PUSH
15925: FOR_IN
15926: IFFALSE 15951
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_INT 285
15935: PPUSH
15936: LD_INT 163
15938: PPUSH
15939: LD_INT 8
15941: PPUSH
15942: LD_INT 1
15944: PPUSH
15945: CALL_OW 483
15949: GO 15925
15951: POP
15952: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15953: LD_ADDR_VAR 0 2
15957: PUSH
15958: LD_VAR 0 2
15962: PPUSH
15963: LD_INT 24
15965: PUSH
15966: LD_INT 250
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PPUSH
15973: CALL_OW 72
15977: ST_TO_ADDR
// for i in tmp do
15978: LD_ADDR_VAR 0 1
15982: PUSH
15983: LD_VAR 0 2
15987: PUSH
15988: FOR_IN
15989: IFFALSE 16029
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15991: LD_VAR 0 1
15995: PPUSH
15996: LD_INT 285
15998: PPUSH
15999: LD_INT 163
16001: PPUSH
16002: CALL_OW 297
16006: PUSH
16007: LD_INT 9
16009: GREATER
16010: IFFALSE 16027
// ComMoveXY ( i , 285 , 163 ) ;
16012: LD_VAR 0 1
16016: PPUSH
16017: LD_INT 285
16019: PPUSH
16020: LD_INT 163
16022: PPUSH
16023: CALL_OW 111
16027: GO 15988
16029: POP
16030: POP
// wait ( 0 0$1 ) ;
16031: LD_INT 35
16033: PPUSH
16034: CALL_OW 67
// p := Inc ( p ) ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_VAR 0 5
16047: PPUSH
16048: CALL 109465 0 1
16052: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16053: LD_VAR 0 2
16057: PPUSH
16058: LD_INT 92
16060: PUSH
16061: LD_INT 285
16063: PUSH
16064: LD_INT 163
16066: PUSH
16067: LD_INT 9
16069: PUSH
16070: EMPTY
16071: LIST
16072: LIST
16073: LIST
16074: LIST
16075: PPUSH
16076: CALL_OW 72
16080: PUSH
16081: LD_VAR 0 2
16085: PUSH
16086: LD_INT 1
16088: MINUS
16089: GREATEREQUAL
16090: PUSH
16091: LD_VAR 0 5
16095: PUSH
16096: LD_INT 30
16098: GREATER
16099: OR
16100: IFFALSE 15953
// end ; repeat wait ( 0 0$1 ) ;
16102: LD_INT 35
16104: PPUSH
16105: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16109: LD_ADDR_VAR 0 2
16113: PUSH
16114: LD_VAR 0 2
16118: PPUSH
16119: LD_INT 50
16121: PUSH
16122: EMPTY
16123: LIST
16124: PPUSH
16125: CALL_OW 72
16129: ST_TO_ADDR
// for i in tmp do
16130: LD_ADDR_VAR 0 1
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: FOR_IN
16141: IFFALSE 16230
// if GetWeapon ( i ) = ru_time_lapser then
16143: LD_VAR 0 1
16147: PPUSH
16148: CALL_OW 264
16152: PUSH
16153: LD_INT 49
16155: EQUAL
16156: IFFALSE 16194
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16158: LD_VAR 0 1
16162: PPUSH
16163: LD_INT 81
16165: PUSH
16166: LD_INT 7
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PPUSH
16173: CALL_OW 69
16177: PPUSH
16178: LD_VAR 0 1
16182: PPUSH
16183: CALL_OW 74
16187: PPUSH
16188: CALL_OW 112
16192: GO 16228
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16194: LD_VAR 0 1
16198: PPUSH
16199: LD_INT 81
16201: PUSH
16202: LD_INT 7
16204: PUSH
16205: EMPTY
16206: LIST
16207: LIST
16208: PPUSH
16209: CALL_OW 69
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 74
16223: PPUSH
16224: CALL_OW 115
16228: GO 16140
16230: POP
16231: POP
// until not tmp ;
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16102
// end ;
16239: PPOPN 5
16241: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16242: LD_EXP 31
16246: PUSH
16247: LD_EXP 79
16251: PPUSH
16252: CALL_OW 302
16256: AND
16257: PUSH
16258: LD_OWVAR 67
16262: PUSH
16263: LD_INT 2
16265: GREATER
16266: AND
16267: IFFALSE 16367
16269: GO 16271
16271: DISABLE
// begin enable ;
16272: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16273: LD_EXP 79
16277: PPUSH
16278: LD_INT 245
16280: PPUSH
16281: LD_INT 234
16283: PPUSH
16284: CALL_OW 297
16288: PUSH
16289: LD_INT 6
16291: GREATER
16292: IFFALSE 16311
// ComMoveXY ( Roth , 245 , 234 ) else
16294: LD_EXP 79
16298: PPUSH
16299: LD_INT 245
16301: PPUSH
16302: LD_INT 234
16304: PPUSH
16305: CALL_OW 111
16309: GO 16367
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16311: LD_EXP 79
16315: PPUSH
16316: LD_INT 259
16318: PUSH
16319: LD_INT 235
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 252
16328: PUSH
16329: LD_INT 209
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: LD_INT 275
16338: PUSH
16339: LD_INT 235
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: PUSH
16346: EMPTY
16347: LIST
16348: LIST
16349: LIST
16350: PUSH
16351: LD_INT 1
16353: PPUSH
16354: LD_INT 3
16356: PPUSH
16357: CALL_OW 12
16361: ARRAY
16362: PPUSH
16363: CALL 112262 0 2
// end ; end_of_file
16367: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
// missionStage := 13 ;
16374: LD_ADDR_EXP 15
16378: PUSH
16379: LD_INT 13
16381: ST_TO_ADDR
// uc_side := 2 ;
16382: LD_ADDR_OWVAR 20
16386: PUSH
16387: LD_INT 2
16389: ST_TO_ADDR
// uc_nation := 2 ;
16390: LD_ADDR_OWVAR 21
16394: PUSH
16395: LD_INT 2
16397: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16398: LD_ADDR_EXP 97
16402: PUSH
16403: LD_STRING Omar
16405: PPUSH
16406: CALL_OW 25
16410: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16411: LD_EXP 97
16415: PPUSH
16416: LD_INT 4
16418: PPUSH
16419: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16423: LD_EXP 97
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: LD_INT 75
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16441: LD_ADDR_EXP 98
16445: PUSH
16446: LD_STRING Heike
16448: PPUSH
16449: CALL_OW 25
16453: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16454: LD_INT 14
16456: PPUSH
16457: LD_INT 3
16459: PPUSH
16460: LD_INT 1
16462: PPUSH
16463: LD_INT 27
16465: PPUSH
16466: LD_INT 100
16468: PPUSH
16469: CALL 75233 0 5
// veh := CreateVehicle ;
16473: LD_ADDR_VAR 0 3
16477: PUSH
16478: CALL_OW 45
16482: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16483: LD_VAR 0 3
16487: PPUSH
16488: LD_INT 2
16490: NEG
16491: PPUSH
16492: CALL_OW 242
// SetDir ( veh , 4 ) ;
16496: LD_VAR 0 3
16500: PPUSH
16501: LD_INT 4
16503: PPUSH
16504: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16508: LD_VAR 0 3
16512: PPUSH
16513: LD_INT 241
16515: PPUSH
16516: LD_INT 72
16518: PPUSH
16519: LD_INT 0
16521: PPUSH
16522: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16526: LD_EXP 98
16530: PPUSH
16531: LD_VAR 0 3
16535: PPUSH
16536: CALL_OW 52
// if KhatamStatus then
16540: LD_EXP 8
16544: IFFALSE 16607
// begin Khatam := NewCharacter ( Khatam ) ;
16546: LD_ADDR_EXP 99
16550: PUSH
16551: LD_STRING Khatam
16553: PPUSH
16554: CALL_OW 25
16558: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16559: LD_EXP 99
16563: PPUSH
16564: LD_INT 245
16566: PPUSH
16567: LD_INT 78
16569: PPUSH
16570: LD_INT 3
16572: PPUSH
16573: LD_INT 0
16575: PPUSH
16576: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16580: LD_EXP 99
16584: PPUSH
16585: LD_INT 4
16587: PPUSH
16588: LD_INT 10
16590: PPUSH
16591: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16595: LD_EXP 99
16599: PPUSH
16600: LD_INT 4
16602: PPUSH
16603: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: DOUBLE
16613: LD_INT 1
16615: DEC
16616: ST_TO_ADDR
16617: LD_INT 2
16619: PUSH
16620: LD_INT 2
16622: PUSH
16623: LD_INT 3
16625: PUSH
16626: LD_INT 3
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: LIST
16633: LIST
16634: PUSH
16635: LD_OWVAR 67
16639: ARRAY
16640: PUSH
16641: FOR_TO
16642: IFFALSE 16708
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16644: LD_INT 0
16646: PPUSH
16647: LD_INT 6
16649: PUSH
16650: LD_OWVAR 67
16654: PLUS
16655: PPUSH
16656: CALL_OW 384
// un := CreateHuman ;
16660: LD_ADDR_VAR 0 4
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16670: LD_VAR 0 4
16674: PPUSH
16675: LD_INT 28
16677: PUSH
16678: LD_INT 29
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: LD_VAR 0 2
16689: PUSH
16690: LD_INT 2
16692: MOD
16693: PUSH
16694: LD_INT 1
16696: PLUS
16697: ARRAY
16698: PPUSH
16699: LD_INT 0
16701: PPUSH
16702: CALL_OW 49
// end ;
16706: GO 16641
16708: POP
16709: POP
// for i = 1 to 6 do
16710: LD_ADDR_VAR 0 2
16714: PUSH
16715: DOUBLE
16716: LD_INT 1
16718: DEC
16719: ST_TO_ADDR
16720: LD_INT 6
16722: PUSH
16723: FOR_TO
16724: IFFALSE 16769
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16726: LD_INT 0
16728: PPUSH
16729: LD_INT 6
16731: PUSH
16732: LD_OWVAR 67
16736: PLUS
16737: PPUSH
16738: CALL_OW 381
// un := CreateHuman ;
16742: LD_ADDR_VAR 0 4
16746: PUSH
16747: CALL_OW 44
16751: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16752: LD_VAR 0 4
16756: PPUSH
16757: LD_INT 32
16759: PPUSH
16760: LD_INT 0
16762: PPUSH
16763: CALL_OW 49
// end ;
16767: GO 16723
16769: POP
16770: POP
// for i = 1 to 3 do
16771: LD_ADDR_VAR 0 2
16775: PUSH
16776: DOUBLE
16777: LD_INT 1
16779: DEC
16780: ST_TO_ADDR
16781: LD_INT 3
16783: PUSH
16784: FOR_TO
16785: IFFALSE 16833
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16787: LD_INT 0
16789: PPUSH
16790: LD_INT 8
16792: PPUSH
16793: LD_INT 6
16795: PUSH
16796: LD_OWVAR 67
16800: PLUS
16801: PPUSH
16802: CALL_OW 380
// un := CreateHuman ;
16806: LD_ADDR_VAR 0 4
16810: PUSH
16811: CALL_OW 44
16815: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16816: LD_VAR 0 4
16820: PPUSH
16821: LD_INT 32
16823: PPUSH
16824: LD_INT 0
16826: PPUSH
16827: CALL_OW 49
// end ;
16831: GO 16784
16833: POP
16834: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16835: LD_ADDR_VAR 0 2
16839: PUSH
16840: DOUBLE
16841: LD_INT 1
16843: DEC
16844: ST_TO_ADDR
16845: LD_INT 2
16847: PUSH
16848: LD_INT 3
16850: PUSH
16851: LD_INT 4
16853: PUSH
16854: LD_INT 4
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: LIST
16862: PUSH
16863: LD_OWVAR 67
16867: ARRAY
16868: PUSH
16869: FOR_TO
16870: IFFALSE 16960
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16872: LD_INT 14
16874: PPUSH
16875: LD_INT 2
16877: PPUSH
16878: LD_INT 1
16880: PPUSH
16881: LD_INT 28
16883: PPUSH
16884: LD_INT 80
16886: PPUSH
16887: CALL 75233 0 5
// veh := CreateVehicle ;
16891: LD_ADDR_VAR 0 3
16895: PUSH
16896: CALL_OW 45
16900: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16901: LD_VAR 0 3
16905: PPUSH
16906: LD_INT 3
16908: PPUSH
16909: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16913: LD_VAR 0 3
16917: PPUSH
16918: LD_INT 29
16920: PPUSH
16921: LD_INT 0
16923: PPUSH
16924: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16928: LD_INT 0
16930: PPUSH
16931: LD_INT 6
16933: PUSH
16934: LD_OWVAR 67
16938: PLUS
16939: PPUSH
16940: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16944: CALL_OW 44
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 52
// end ;
16958: GO 16869
16960: POP
16961: POP
// for i = 1 to 5 + Difficulty do
16962: LD_ADDR_VAR 0 2
16966: PUSH
16967: DOUBLE
16968: LD_INT 1
16970: DEC
16971: ST_TO_ADDR
16972: LD_INT 5
16974: PUSH
16975: LD_OWVAR 67
16979: PLUS
16980: PUSH
16981: FOR_TO
16982: IFFALSE 17109
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16984: LD_INT 14
16986: PPUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 3
16992: PPUSH
16993: CALL_OW 12
16997: PPUSH
16998: LD_INT 1
17000: PPUSH
17001: LD_INT 28
17003: PUSH
17004: LD_INT 26
17006: PUSH
17007: LD_INT 27
17009: PUSH
17010: LD_INT 25
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: PUSH
17019: LD_VAR 0 2
17023: PUSH
17024: LD_INT 4
17026: MOD
17027: PUSH
17028: LD_INT 1
17030: PLUS
17031: ARRAY
17032: PPUSH
17033: LD_INT 80
17035: PPUSH
17036: CALL 75233 0 5
// veh := CreateVehicle ;
17040: LD_ADDR_VAR 0 3
17044: PUSH
17045: CALL_OW 45
17049: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17050: LD_VAR 0 3
17054: PPUSH
17055: LD_INT 4
17057: PPUSH
17058: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17062: LD_VAR 0 3
17066: PPUSH
17067: LD_INT 28
17069: PPUSH
17070: LD_INT 0
17072: PPUSH
17073: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17077: LD_INT 0
17079: PPUSH
17080: LD_INT 6
17082: PUSH
17083: LD_OWVAR 67
17087: PLUS
17088: PPUSH
17089: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17093: CALL_OW 44
17097: PPUSH
17098: LD_VAR 0 3
17102: PPUSH
17103: CALL_OW 52
// end ;
17107: GO 16981
17109: POP
17110: POP
// for i = 1 to Difficulty do
17111: LD_ADDR_VAR 0 2
17115: PUSH
17116: DOUBLE
17117: LD_INT 1
17119: DEC
17120: ST_TO_ADDR
17121: LD_OWVAR 67
17125: PUSH
17126: FOR_TO
17127: IFFALSE 17187
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17129: LD_INT 14
17131: PPUSH
17132: LD_INT 3
17134: PPUSH
17135: LD_INT 5
17137: PPUSH
17138: LD_INT 29
17140: PPUSH
17141: LD_INT 80
17143: PPUSH
17144: CALL 75233 0 5
// veh := CreateVehicle ;
17148: LD_ADDR_VAR 0 3
17152: PUSH
17153: CALL_OW 45
17157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17158: LD_VAR 0 3
17162: PPUSH
17163: LD_INT 4
17165: PPUSH
17166: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17170: LD_VAR 0 3
17174: PPUSH
17175: LD_INT 28
17177: PPUSH
17178: LD_INT 0
17180: PPUSH
17181: CALL_OW 49
// end ;
17185: GO 17126
17187: POP
17188: POP
// end ;
17189: LD_VAR 0 1
17193: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17194: LD_INT 22
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PPUSH
17204: CALL_OW 69
17208: IFFALSE 17587
17210: GO 17212
17212: DISABLE
17213: LD_INT 0
17215: PPUSH
17216: PPUSH
17217: PPUSH
17218: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17219: LD_ADDR_VAR 0 3
17223: PUSH
17224: LD_INT 22
17226: PUSH
17227: LD_INT 2
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: LD_INT 25
17236: PUSH
17237: LD_INT 4
17239: PUSH
17240: EMPTY
17241: LIST
17242: LIST
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 69
17252: PUSH
17253: LD_EXP 99
17257: DIFF
17258: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17259: LD_ADDR_VAR 0 2
17263: PUSH
17264: LD_INT 22
17266: PUSH
17267: LD_INT 2
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: PUSH
17279: LD_EXP 99
17283: PUSH
17284: LD_VAR 0 3
17288: UNION
17289: DIFF
17290: ST_TO_ADDR
// if Khatam then
17291: LD_EXP 99
17295: IFFALSE 17312
// ComMoveXY ( Khatam , 211 , 92 ) ;
17297: LD_EXP 99
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 92
17307: PPUSH
17308: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17312: LD_INT 197
17314: PPUSH
17315: LD_INT 80
17317: PPUSH
17318: LD_INT 2
17320: PPUSH
17321: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17325: LD_INT 213
17327: PPUSH
17328: LD_INT 90
17330: PPUSH
17331: LD_INT 2
17333: PPUSH
17334: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17338: LD_INT 215
17340: PPUSH
17341: LD_INT 129
17343: PPUSH
17344: LD_INT 2
17346: PPUSH
17347: CALL_OW 441
// if sci then
17351: LD_VAR 0 3
17355: IFFALSE 17376
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17357: LD_VAR 0 3
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: LD_INT 197
17368: PPUSH
17369: LD_INT 80
17371: PPUSH
17372: CALL_OW 158
// if sci > 1 then
17376: LD_VAR 0 3
17380: PUSH
17381: LD_INT 1
17383: GREATER
17384: IFFALSE 17405
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17386: LD_VAR 0 3
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: LD_INT 213
17397: PPUSH
17398: LD_INT 90
17400: PPUSH
17401: CALL_OW 158
// if sci > 2 then
17405: LD_VAR 0 3
17409: PUSH
17410: LD_INT 2
17412: GREATER
17413: IFFALSE 17434
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17415: LD_VAR 0 3
17419: PUSH
17420: LD_INT 3
17422: ARRAY
17423: PPUSH
17424: LD_INT 215
17426: PPUSH
17427: LD_INT 129
17429: PPUSH
17430: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17434: LD_VAR 0 2
17438: PPUSH
17439: LD_INT 195
17441: PPUSH
17442: LD_INT 102
17444: PPUSH
17445: CALL_OW 114
// wait ( 0 0$5 ) ;
17449: LD_INT 175
17451: PPUSH
17452: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17456: LD_INT 70
17458: PPUSH
17459: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17463: LD_ADDR_VAR 0 4
17467: PUSH
17468: LD_INT 92
17470: PUSH
17471: LD_INT 195
17473: PUSH
17474: LD_INT 102
17476: PUSH
17477: LD_INT 36
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 22
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: ST_TO_ADDR
// for i in tmp do
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_VAR 0 2
17514: PUSH
17515: FOR_IN
17516: IFFALSE 17567
// if enemy then
17518: LD_VAR 0 4
17522: IFFALSE 17550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17524: LD_VAR 0 1
17528: PPUSH
17529: LD_VAR 0 4
17533: PPUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 74
17543: PPUSH
17544: CALL_OW 115
17548: GO 17565
// ComAgressiveMove ( i , 195 , 102 ) ;
17550: LD_VAR 0 1
17554: PPUSH
17555: LD_INT 195
17557: PPUSH
17558: LD_INT 102
17560: PPUSH
17561: CALL_OW 114
17565: GO 17515
17567: POP
17568: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17569: LD_VAR 0 2
17573: PPUSH
17574: LD_INT 50
17576: PUSH
17577: EMPTY
17578: LIST
17579: PPUSH
17580: CALL_OW 72
17584: NOT
17585: IFFALSE 17456
// end ; end_of_file
17587: PPOPN 4
17589: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17590: LD_INT 0
17592: PPUSH
17593: PPUSH
17594: PPUSH
17595: PPUSH
17596: PPUSH
17597: PPUSH
17598: PPUSH
17599: PPUSH
17600: PPUSH
// Video ( true ) ;
17601: LD_INT 1
17603: PPUSH
17604: CALL 108076 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17608: LD_ADDR_VAR 0 5
17612: PUSH
17613: LD_INT 7
17615: PPUSH
17616: LD_INT 0
17618: PPUSH
17619: CALL_OW 517
17623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17624: LD_ADDR_VAR 0 2
17628: PUSH
17629: DOUBLE
17630: LD_INT 1
17632: DEC
17633: ST_TO_ADDR
17634: LD_VAR 0 5
17638: PUSH
17639: LD_INT 1
17641: ARRAY
17642: PUSH
17643: FOR_TO
17644: IFFALSE 17689
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17646: LD_VAR 0 5
17650: PUSH
17651: LD_INT 1
17653: ARRAY
17654: PUSH
17655: LD_VAR 0 2
17659: ARRAY
17660: PPUSH
17661: LD_VAR 0 5
17665: PUSH
17666: LD_INT 2
17668: ARRAY
17669: PUSH
17670: LD_VAR 0 2
17674: ARRAY
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: LD_INT 15
17681: NEG
17682: PPUSH
17683: CALL 107990 0 4
17687: GO 17643
17689: POP
17690: POP
// CenterNowOnUnits ( Powell ) ;
17691: LD_EXP 61
17695: PPUSH
17696: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17700: LD_ADDR_VAR 0 5
17704: PUSH
17705: LD_EXP 59
17709: PUSH
17710: EMPTY
17711: LIST
17712: ST_TO_ADDR
// if GirlNewVeh then
17713: LD_EXP 60
17717: IFFALSE 17735
// tmp := tmp ^ GirlNewVeh ;
17719: LD_ADDR_VAR 0 5
17723: PUSH
17724: LD_VAR 0 5
17728: PUSH
17729: LD_EXP 60
17733: ADD
17734: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17735: LD_VAR 0 5
17739: PPUSH
17740: LD_INT 60
17742: PPUSH
17743: LD_INT 109
17745: PPUSH
17746: CALL_OW 111
// if KappaStatus then
17750: LD_EXP 2
17754: IFFALSE 17806
// begin Say ( JMM , D1nT-JMM-1 ) ;
17756: LD_EXP 40
17760: PPUSH
17761: LD_STRING D1nT-JMM-1
17763: PPUSH
17764: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17768: LD_EXP 61
17772: PPUSH
17773: LD_STRING D1T-Pow-1
17775: PPUSH
17776: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17780: LD_EXP 40
17784: PPUSH
17785: LD_STRING D1T-JMM-2
17787: PPUSH
17788: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17792: LD_EXP 61
17796: PPUSH
17797: LD_STRING D1T-Pow-2
17799: PPUSH
17800: CALL_OW 88
// end else
17804: GO 18012
// if JMMGirlStatus then
17806: LD_EXP 6
17810: IFFALSE 17955
// begin Say ( JMM , D1T-JMM-1 ) ;
17812: LD_EXP 40
17816: PPUSH
17817: LD_STRING D1T-JMM-1
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17824: LD_EXP 61
17828: PPUSH
17829: LD_STRING D1T-Pow-1
17831: PPUSH
17832: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17836: LD_EXP 40
17840: PPUSH
17841: LD_STRING D1T-JMM-3
17843: PPUSH
17844: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17848: LD_EXP 61
17852: PPUSH
17853: LD_STRING D1T-Pow-3
17855: PPUSH
17856: CALL_OW 88
// if JMMGirl then
17860: LD_EXP 7
17864: IFFALSE 17953
// begin case JMMGirl of 1 :
17866: LD_EXP 7
17870: PUSH
17871: LD_INT 1
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17894
17879: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17880: LD_EXP 41
17884: PPUSH
17885: LD_STRING D1T-Joan-3
17887: PPUSH
17888: CALL_OW 88
17892: GO 17941
17894: LD_INT 2
17896: DOUBLE
17897: EQUAL
17898: IFTRUE 17902
17900: GO 17917
17902: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17903: LD_EXP 43
17907: PPUSH
17908: LD_STRING D1T-Lisa-3
17910: PPUSH
17911: CALL_OW 88
17915: GO 17941
17917: LD_INT 3
17919: DOUBLE
17920: EQUAL
17921: IFTRUE 17925
17923: GO 17940
17925: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17926: LD_EXP 55
17930: PPUSH
17931: LD_STRING D1T-Con-3
17933: PPUSH
17934: CALL_OW 88
17938: GO 17941
17940: POP
// Say ( Powell , D1T-Pow-4 ) ;
17941: LD_EXP 61
17945: PPUSH
17946: LD_STRING D1T-Pow-4
17948: PPUSH
17949: CALL_OW 88
// end ; end else
17953: GO 18012
// if not FastEnd then
17955: LD_EXP 11
17959: NOT
17960: IFFALSE 17988
// begin Say ( JMM , D1T-JMM-4 ) ;
17962: LD_EXP 40
17966: PPUSH
17967: LD_STRING D1T-JMM-4
17969: PPUSH
17970: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17974: LD_EXP 61
17978: PPUSH
17979: LD_STRING D1T-Pow-5
17981: PPUSH
17982: CALL_OW 88
// end else
17986: GO 18012
// begin Say ( JMM , D1nT-JMM-1 ) ;
17988: LD_EXP 40
17992: PPUSH
17993: LD_STRING D1nT-JMM-1
17995: PPUSH
17996: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18000: LD_EXP 61
18004: PPUSH
18005: LD_STRING D1nT-Pow-1
18007: PPUSH
18008: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18012: LD_INT 3
18014: PPUSH
18015: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18019: LD_EXP 59
18023: PPUSH
18024: CALL_OW 314
18028: NOT
18029: IFFALSE 18012
// ComExitVehicle ( JMM ) ;
18031: LD_EXP 40
18035: PPUSH
18036: CALL_OW 121
// repeat wait ( 3 ) ;
18040: LD_INT 3
18042: PPUSH
18043: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18047: LD_EXP 40
18051: PPUSH
18052: CALL_OW 310
18056: NOT
18057: IFFALSE 18040
// ComMoveXY ( JMM , 60 , 94 ) ;
18059: LD_EXP 40
18063: PPUSH
18064: LD_INT 60
18066: PPUSH
18067: LD_INT 94
18069: PPUSH
18070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18074: LD_EXP 40
18078: PPUSH
18079: LD_EXP 61
18083: PPUSH
18084: CALL_OW 179
// if Joan then
18088: LD_EXP 41
18092: IFFALSE 18146
// begin ComExitVehicle ( Joan ) ;
18094: LD_EXP 41
18098: PPUSH
18099: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18103: LD_EXP 41
18107: PPUSH
18108: LD_INT 35
18110: PPUSH
18111: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18115: LD_EXP 41
18119: PPUSH
18120: LD_INT 65
18122: PPUSH
18123: LD_INT 104
18125: PPUSH
18126: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18130: LD_EXP 41
18134: PPUSH
18135: LD_EXP 40
18139: PPUSH
18140: CALL_OW 179
// end else
18144: GO 18280
// if Lisa and JMMGirl = 2 then
18146: LD_EXP 43
18150: PUSH
18151: LD_EXP 7
18155: PUSH
18156: LD_INT 2
18158: EQUAL
18159: AND
18160: IFFALSE 18214
// begin ComExitVehicle ( Lisa ) ;
18162: LD_EXP 43
18166: PPUSH
18167: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18171: LD_EXP 43
18175: PPUSH
18176: LD_INT 35
18178: PPUSH
18179: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18183: LD_EXP 43
18187: PPUSH
18188: LD_INT 65
18190: PPUSH
18191: LD_INT 104
18193: PPUSH
18194: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18198: LD_EXP 43
18202: PPUSH
18203: LD_EXP 40
18207: PPUSH
18208: CALL_OW 179
// end else
18212: GO 18280
// if Connie and JMMGirl = 3 then
18214: LD_EXP 55
18218: PUSH
18219: LD_EXP 7
18223: PUSH
18224: LD_INT 3
18226: EQUAL
18227: AND
18228: IFFALSE 18280
// begin ComExitVehicle ( Connie ) ;
18230: LD_EXP 55
18234: PPUSH
18235: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18239: LD_EXP 55
18243: PPUSH
18244: LD_INT 35
18246: PPUSH
18247: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18251: LD_EXP 55
18255: PPUSH
18256: LD_INT 65
18258: PPUSH
18259: LD_INT 104
18261: PPUSH
18262: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18266: LD_EXP 55
18270: PPUSH
18271: LD_EXP 40
18275: PPUSH
18276: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18280: LD_INT 35
18282: PPUSH
18283: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18287: LD_EXP 40
18291: PPUSH
18292: LD_EXP 61
18296: PPUSH
18297: CALL_OW 296
18301: PUSH
18302: LD_INT 8
18304: LESS
18305: IFFALSE 18280
// wait ( 0 0$0.5 ) ;
18307: LD_INT 18
18309: PPUSH
18310: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18314: LD_EXP 40
18318: PPUSH
18319: LD_STRING D1-JMM-1
18321: PPUSH
18322: CALL_OW 88
// async ;
18326: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18327: LD_EXP 61
18331: PPUSH
18332: LD_STRING D1-Pow-1
18334: PPUSH
18335: CALL_OW 88
// if not dialogue_skipped then
18339: LD_OWVAR 59
18343: NOT
18344: IFFALSE 18353
// wait ( 0 0$2 ) ;
18346: LD_INT 70
18348: PPUSH
18349: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18353: LD_INT 170
18355: PPUSH
18356: LD_INT 99
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: LD_INT 6
18364: NEG
18365: PPUSH
18366: CALL 107990 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18370: LD_INT 174
18372: PPUSH
18373: LD_INT 115
18375: PPUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 6
18381: NEG
18382: PPUSH
18383: CALL 107990 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18387: LD_INT 169
18389: PPUSH
18390: LD_INT 71
18392: PPUSH
18393: LD_INT 1
18395: PPUSH
18396: LD_INT 6
18398: NEG
18399: PPUSH
18400: CALL 107990 0 4
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18428
// begin CenterOnXY ( 170 , 99 ) ;
18411: LD_INT 170
18413: PPUSH
18414: LD_INT 99
18416: PPUSH
18417: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18421: LD_INT 80
18423: PPUSH
18424: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18428: LD_INT 75
18430: PPUSH
18431: LD_INT 53
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 9
18439: NEG
18440: PPUSH
18441: CALL 107990 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18445: LD_INT 54
18447: PPUSH
18448: LD_INT 42
18450: PPUSH
18451: LD_INT 1
18453: PPUSH
18454: LD_INT 9
18456: NEG
18457: PPUSH
18458: CALL 107990 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18462: LD_INT 62
18464: PPUSH
18465: LD_INT 51
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 9
18473: NEG
18474: PPUSH
18475: CALL 107990 0 4
// if not dialogue_skipped then
18479: LD_OWVAR 59
18483: NOT
18484: IFFALSE 18503
// begin CenterOnXY ( 75 , 53 ) ;
18486: LD_INT 75
18488: PPUSH
18489: LD_INT 53
18491: PPUSH
18492: CALL_OW 84
// wait ( 0 0$4 ) ;
18496: LD_INT 140
18498: PPUSH
18499: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18503: LD_EXP 61
18507: PPUSH
18508: CALL_OW 87
// if not dialogue_skipped then
18512: LD_OWVAR 59
18516: NOT
18517: IFFALSE 18526
// wait ( 0 0$2 ) ;
18519: LD_INT 70
18521: PPUSH
18522: CALL_OW 67
// sync ;
18526: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18527: LD_EXP 40
18531: PPUSH
18532: LD_STRING D1-JMM-2
18534: PPUSH
18535: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18539: LD_EXP 61
18543: PPUSH
18544: LD_STRING D1-Pow-2
18546: PPUSH
18547: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18551: LD_EXP 40
18555: PPUSH
18556: LD_STRING D1-JMM-3
18558: PPUSH
18559: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18563: LD_EXP 61
18567: PPUSH
18568: LD_STRING D1-Pow-3
18570: PPUSH
18571: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_STRING D1-JMM-4
18582: PPUSH
18583: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18587: LD_EXP 61
18591: PPUSH
18592: LD_STRING D1-Pow-4
18594: PPUSH
18595: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18599: LD_EXP 40
18603: PPUSH
18604: LD_STRING D1-JMM-5
18606: PPUSH
18607: CALL_OW 88
// async ;
18611: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18612: LD_EXP 61
18616: PPUSH
18617: LD_STRING D1-Pow-5
18619: PPUSH
18620: CALL_OW 88
// if not dialogue_skipped then
18624: LD_OWVAR 59
18628: NOT
18629: IFFALSE 18638
// wait ( 0 0$3.6 ) ;
18631: LD_INT 126
18633: PPUSH
18634: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18638: LD_INT 134
18640: PPUSH
18641: LD_INT 210
18643: PPUSH
18644: LD_INT 1
18646: PPUSH
18647: LD_INT 11
18649: NEG
18650: PPUSH
18651: CALL 107990 0 4
// if not dialogue_skipped then
18655: LD_OWVAR 59
18659: NOT
18660: IFFALSE 18679
// begin CenterOnXY ( 134 , 210 ) ;
18662: LD_INT 134
18664: PPUSH
18665: LD_INT 210
18667: PPUSH
18668: CALL_OW 84
// wait ( 0 0$2 ) ;
18672: LD_INT 70
18674: PPUSH
18675: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18679: LD_INT 101
18681: PPUSH
18682: LD_INT 159
18684: PPUSH
18685: LD_INT 1
18687: PPUSH
18688: LD_INT 10
18690: NEG
18691: PPUSH
18692: CALL 107990 0 4
// if not dialogue_skipped then
18696: LD_OWVAR 59
18700: NOT
18701: IFFALSE 18720
// begin CenterOnXY ( 101 , 159 ) ;
18703: LD_INT 101
18705: PPUSH
18706: LD_INT 159
18708: PPUSH
18709: CALL_OW 84
// wait ( 0 0$2 ) ;
18713: LD_INT 70
18715: PPUSH
18716: CALL_OW 67
// end ; sync ;
18720: SYNC
// CenterNowOnUnits ( Powell ) ;
18721: LD_EXP 61
18725: PPUSH
18726: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18730: LD_ADDR_VAR 0 6
18734: PUSH
18735: LD_INT 1
18737: PUSH
18738: LD_INT 2
18740: PUSH
18741: LD_INT 3
18743: PUSH
18744: LD_INT 4
18746: PUSH
18747: LD_INT 5
18749: PUSH
18750: LD_INT 6
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18935
// begin game_speed := 4 ;
18768: LD_ADDR_OWVAR 65
18772: PUSH
18773: LD_INT 4
18775: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18776: LD_INT 210
18778: PPUSH
18779: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18783: LD_ADDR_VAR 0 7
18787: PUSH
18788: LD_STRING Q1
18790: PPUSH
18791: LD_VAR 0 6
18795: PPUSH
18796: CALL_OW 98
18800: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18801: LD_ADDR_VAR 0 7
18805: PUSH
18806: LD_STRING Q1
18808: PPUSH
18809: LD_VAR 0 6
18813: PPUSH
18814: CALL_OW 98
18818: ST_TO_ADDR
// options := options diff dec ;
18819: LD_ADDR_VAR 0 6
18823: PUSH
18824: LD_VAR 0 6
18828: PUSH
18829: LD_VAR 0 7
18833: DIFF
18834: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18835: LD_VAR 0 7
18839: PPUSH
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL 20529 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18849: LD_VAR 0 7
18853: PUSH
18854: LD_INT 5
18856: PUSH
18857: LD_INT 6
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: IN
18864: PUSH
18865: LD_VAR 0 6
18869: PUSH
18870: LD_INT 2
18872: EQUAL
18873: OR
18874: IFFALSE 18801
// if not ( dec in [ 5 , 6 ] ) then
18876: LD_VAR 0 7
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: LD_INT 6
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: IN
18891: NOT
18892: IFFALSE 18935
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18894: LD_ADDR_VAR 0 7
18898: PUSH
18899: LD_STRING Q1a
18901: PPUSH
18902: LD_INT 1
18904: PUSH
18905: LD_INT 2
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PPUSH
18912: CALL_OW 98
18916: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18917: LD_VAR 0 7
18921: PUSH
18922: LD_INT 4
18924: PLUS
18925: PPUSH
18926: LD_VAR 0 6
18930: PPUSH
18931: CALL 20529 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18935: LD_INT 81
18937: PPUSH
18938: LD_INT 127
18940: PPUSH
18941: CALL_OW 84
// amount := 8 ;
18945: LD_ADDR_VAR 0 8
18949: PUSH
18950: LD_INT 8
18952: ST_TO_ADDR
// macmilan_squad := [ ] ;
18953: LD_ADDR_VAR 0 9
18957: PUSH
18958: EMPTY
18959: ST_TO_ADDR
// if vip < amount then
18960: LD_EXP 62
18964: PUSH
18965: LD_VAR 0 8
18969: LESS
18970: IFFALSE 19014
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18972: LD_ADDR_VAR 0 5
18976: PUSH
18977: LD_EXP 62
18981: PUSH
18982: LD_INT 22
18984: PUSH
18985: LD_INT 4
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 1
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 69
19010: UNION
19011: ST_TO_ADDR
19012: GO 19024
// tmp := vip ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_EXP 62
19023: ST_TO_ADDR
// tmp := tmp diff Powell ;
19024: LD_ADDR_VAR 0 5
19028: PUSH
19029: LD_VAR 0 5
19033: PUSH
19034: LD_EXP 61
19038: DIFF
19039: ST_TO_ADDR
// if tmp < amount then
19040: LD_VAR 0 5
19044: PUSH
19045: LD_VAR 0 8
19049: LESS
19050: IFFALSE 19062
// amount := tmp ;
19052: LD_ADDR_VAR 0 8
19056: PUSH
19057: LD_VAR 0 5
19061: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19062: LD_VAR 0 5
19066: PUSH
19067: LD_INT 1
19069: ARRAY
19070: PPUSH
19071: CALL_OW 257
19075: PUSH
19076: LD_INT 2
19078: NONEQUAL
19079: IFFALSE 19177
// begin if IsInUnit ( tmp [ 1 ] ) then
19081: LD_VAR 0 5
19085: PUSH
19086: LD_INT 1
19088: ARRAY
19089: PPUSH
19090: CALL_OW 310
19094: IFFALSE 19109
// ComExitBuilding ( tmp [ 1 ] ) ;
19096: LD_VAR 0 5
19100: PUSH
19101: LD_INT 1
19103: ARRAY
19104: PPUSH
19105: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19109: LD_INT 387
19111: PPUSH
19112: CALL_OW 313
19116: PUSH
19117: LD_INT 6
19119: EQUAL
19120: IFFALSE 19145
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19122: LD_INT 387
19124: PPUSH
19125: CALL_OW 313
19129: PUSH
19130: LD_INT 1
19132: ARRAY
19133: PPUSH
19134: CALL_OW 122
// wait ( 3 ) ;
19138: LD_INT 3
19140: PPUSH
19141: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19145: LD_VAR 0 5
19149: PUSH
19150: LD_INT 1
19152: ARRAY
19153: PPUSH
19154: LD_INT 387
19156: PPUSH
19157: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19161: LD_VAR 0 5
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_INT 2
19172: PPUSH
19173: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19177: LD_EXP 40
19181: PPUSH
19182: LD_INT 82
19184: PPUSH
19185: LD_INT 129
19187: PPUSH
19188: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19192: LD_EXP 40
19196: PPUSH
19197: LD_EXP 61
19201: PPUSH
19202: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19206: LD_INT 22
19208: PUSH
19209: LD_INT 1
19211: PUSH
19212: EMPTY
19213: LIST
19214: LIST
19215: PPUSH
19216: CALL_OW 69
19220: PUSH
19221: LD_EXP 40
19225: DIFF
19226: PPUSH
19227: LD_INT 84
19229: PPUSH
19230: LD_INT 128
19232: PPUSH
19233: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19237: LD_INT 22
19239: PUSH
19240: LD_INT 1
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: PPUSH
19247: CALL_OW 69
19251: PUSH
19252: LD_EXP 40
19256: DIFF
19257: PPUSH
19258: LD_EXP 40
19262: PPUSH
19263: CALL_OW 179
// for i = 1 to amount do
19267: LD_ADDR_VAR 0 2
19271: PUSH
19272: DOUBLE
19273: LD_INT 1
19275: DEC
19276: ST_TO_ADDR
19277: LD_VAR 0 8
19281: PUSH
19282: FOR_TO
19283: IFFALSE 19451
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19285: LD_ADDR_VAR 0 9
19289: PUSH
19290: LD_VAR 0 9
19294: PUSH
19295: LD_VAR 0 5
19299: PUSH
19300: LD_VAR 0 2
19304: ARRAY
19305: ADD
19306: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19307: LD_VAR 0 5
19311: PUSH
19312: LD_VAR 0 2
19316: ARRAY
19317: PPUSH
19318: CALL_OW 310
19322: IFFALSE 19339
// AddComExitBuilding ( tmp [ i ] ) ;
19324: LD_VAR 0 5
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: CALL_OW 182
// if i = 2 and JMMNewVeh then
19339: LD_VAR 0 2
19343: PUSH
19344: LD_INT 2
19346: EQUAL
19347: PUSH
19348: LD_EXP 59
19352: AND
19353: IFFALSE 19411
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19355: LD_VAR 0 5
19359: PUSH
19360: LD_VAR 0 2
19364: ARRAY
19365: PPUSH
19366: LD_EXP 59
19370: PPUSH
19371: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19375: LD_VAR 0 5
19379: PUSH
19380: LD_VAR 0 2
19384: ARRAY
19385: PPUSH
19386: LD_INT 86
19388: PPUSH
19389: LD_INT 133
19391: PPUSH
19392: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19396: LD_VAR 0 5
19400: PUSH
19401: LD_VAR 0 2
19405: ARRAY
19406: PPUSH
19407: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19411: LD_VAR 0 5
19415: PUSH
19416: LD_VAR 0 2
19420: ARRAY
19421: PPUSH
19422: LD_INT 8
19424: PPUSH
19425: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19429: LD_VAR 0 5
19433: PUSH
19434: LD_VAR 0 2
19438: ARRAY
19439: PPUSH
19440: LD_EXP 40
19444: PPUSH
19445: CALL_OW 179
// end ;
19449: GO 19282
19451: POP
19452: POP
// if GirlNewVeh then
19453: LD_EXP 60
19457: IFFALSE 19471
// SetSide ( GirlNewVeh , 4 ) ;
19459: LD_EXP 60
19463: PPUSH
19464: LD_INT 4
19466: PPUSH
19467: CALL_OW 235
// if Mike then
19471: LD_EXP 57
19475: IFFALSE 19512
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19477: LD_ADDR_VAR 0 9
19481: PUSH
19482: LD_VAR 0 9
19486: PPUSH
19487: LD_EXP 57
19491: PPUSH
19492: CALL 108104 0 2
19496: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19497: LD_EXP 57
19501: PPUSH
19502: LD_INT 86
19504: PPUSH
19505: LD_INT 133
19507: PPUSH
19508: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19512: LD_INT 35
19514: PPUSH
19515: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19519: LD_VAR 0 9
19523: PPUSH
19524: LD_INT 95
19526: PUSH
19527: LD_INT 9
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PPUSH
19534: CALL_OW 72
19538: PUSH
19539: LD_INT 0
19541: EQUAL
19542: PUSH
19543: LD_EXP 40
19547: PPUSH
19548: LD_INT 9
19550: PPUSH
19551: CALL_OW 308
19555: NOT
19556: AND
19557: IFFALSE 19512
// wait ( 0 0$2 ) ;
19559: LD_INT 70
19561: PPUSH
19562: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19566: LD_VAR 0 9
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19578: LD_INT 21
19580: PUSH
19581: LD_INT 2
19583: PUSH
19584: EMPTY
19585: LIST
19586: LIST
19587: PUSH
19588: LD_INT 92
19590: PUSH
19591: LD_INT 83
19593: PUSH
19594: LD_INT 130
19596: PUSH
19597: LD_INT 10
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: LIST
19604: LIST
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PPUSH
19610: CALL_OW 69
19614: PPUSH
19615: LD_INT 1
19617: PPUSH
19618: CALL_OW 235
// tick := 0 ;
19622: LD_ADDR_OWVAR 1
19626: PUSH
19627: LD_INT 0
19629: ST_TO_ADDR
// Video ( false ) ;
19630: LD_INT 0
19632: PPUSH
19633: CALL 108076 0 1
// ChangeMissionObjectives ( M1 ) ;
19637: LD_STRING M1
19639: PPUSH
19640: CALL_OW 337
// SaveForQuickRestart ;
19644: CALL_OW 22
// missionStart := true ;
19648: LD_ADDR_EXP 13
19652: PUSH
19653: LD_INT 1
19655: ST_TO_ADDR
// missionStage := 2 ;
19656: LD_ADDR_EXP 15
19660: PUSH
19661: LD_INT 2
19663: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19664: LD_INT 35
19666: PPUSH
19667: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19671: LD_ADDR_VAR 0 5
19675: PUSH
19676: LD_INT 22
19678: PUSH
19679: LD_INT 4
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: PUSH
19686: LD_INT 21
19688: PUSH
19689: LD_INT 1
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PPUSH
19700: CALL_OW 69
19704: PUSH
19705: LD_EXP 61
19709: DIFF
19710: ST_TO_ADDR
// if not tmp then
19711: LD_VAR 0 5
19715: NOT
19716: IFFALSE 19731
// tmp := [ Powell ] ;
19718: LD_ADDR_VAR 0 5
19722: PUSH
19723: LD_EXP 61
19727: PUSH
19728: EMPTY
19729: LIST
19730: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19731: LD_ADDR_VAR 0 4
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 34
19748: PUSH
19749: LD_INT 12
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: PUSH
19765: LD_INT 1
19767: ARRAY
19768: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19769: LD_VAR 0 5
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: CALL_OW 310
19782: IFFALSE 19797
// ComExitBuilding ( tmp [ 1 ] ) ;
19784: LD_VAR 0 5
19788: PUSH
19789: LD_INT 1
19791: ARRAY
19792: PPUSH
19793: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19797: LD_VAR 0 5
19801: PUSH
19802: LD_INT 1
19804: ARRAY
19805: PPUSH
19806: LD_VAR 0 4
19810: PPUSH
19811: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19815: LD_VAR 0 5
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: LD_INT 80
19826: PPUSH
19827: LD_INT 136
19829: PPUSH
19830: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19834: LD_VAR 0 5
19838: PUSH
19839: LD_INT 1
19841: ARRAY
19842: PPUSH
19843: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19847: LD_VAR 0 5
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: LD_INT 59
19858: PPUSH
19859: LD_INT 112
19861: PPUSH
19862: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 and JMMGirl = 1 then
19879: LD_EXP 41
19883: PUSH
19884: LD_EXP 41
19888: PPUSH
19889: CALL_OW 255
19893: PUSH
19894: LD_INT 1
19896: EQUAL
19897: AND
19898: PUSH
19899: LD_EXP 7
19903: PUSH
19904: LD_INT 1
19906: EQUAL
19907: AND
19908: IFFALSE 19934
// begin Say ( Joan , D3W-Joan-1 ) ;
19910: LD_EXP 41
19914: PPUSH
19915: LD_STRING D3W-Joan-1
19917: PPUSH
19918: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19922: LD_EXP 40
19926: PPUSH
19927: LD_STRING D3W-JMM-1
19929: PPUSH
19930: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip and JMMGirl = 2 then
19934: LD_EXP 43
19938: PUSH
19939: LD_EXP 43
19943: PPUSH
19944: CALL_OW 255
19948: PUSH
19949: LD_INT 1
19951: EQUAL
19952: AND
19953: PUSH
19954: LD_EXP 43
19958: PUSH
19959: LD_EXP 62
19963: IN
19964: NOT
19965: AND
19966: PUSH
19967: LD_EXP 7
19971: PUSH
19972: LD_INT 2
19974: EQUAL
19975: AND
19976: IFFALSE 20002
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19978: LD_EXP 43
19982: PPUSH
19983: LD_STRING D3W-Lisa-1
19985: PPUSH
19986: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19990: LD_EXP 40
19994: PPUSH
19995: LD_STRING D3W-JMM-1
19997: PPUSH
19998: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 and JMMGirl = 3 then
20002: LD_EXP 55
20006: PUSH
20007: LD_EXP 55
20011: PPUSH
20012: CALL_OW 255
20016: PUSH
20017: LD_INT 1
20019: EQUAL
20020: AND
20021: PUSH
20022: LD_EXP 7
20026: PUSH
20027: LD_INT 3
20029: EQUAL
20030: AND
20031: IFFALSE 20057
// begin Say ( Connie , D3W-Con-1 ) ;
20033: LD_EXP 55
20037: PPUSH
20038: LD_STRING D3W-Con-1
20040: PPUSH
20041: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20045: LD_EXP 40
20049: PPUSH
20050: LD_STRING D3W-JMM-1
20052: PPUSH
20053: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20057: LD_INT 18
20059: PPUSH
20060: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20064: LD_EXP 43
20068: PUSH
20069: LD_EXP 62
20073: IN
20074: PUSH
20075: LD_EXP 43
20079: PPUSH
20080: CALL_OW 255
20084: PUSH
20085: LD_INT 1
20087: EQUAL
20088: AND
20089: IFFALSE 20105
// Say ( Lisa , D3nW-Lisa-1 ) else
20091: LD_EXP 43
20095: PPUSH
20096: LD_STRING D3nW-Lisa-1
20098: PPUSH
20099: CALL_OW 88
20103: GO 20349
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20105: LD_EXP 46
20109: PUSH
20110: LD_EXP 62
20114: IN
20115: PUSH
20116: LD_EXP 46
20120: PPUSH
20121: CALL_OW 255
20125: PUSH
20126: LD_INT 1
20128: EQUAL
20129: AND
20130: IFFALSE 20146
// Say ( Cyrus , D3nW-Cyrus-1 ) else
20132: LD_EXP 46
20136: PPUSH
20137: LD_STRING D3nW-Cyrus-1
20139: PPUSH
20140: CALL_OW 88
20144: GO 20349
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20146: LD_EXP 45
20150: PUSH
20151: LD_EXP 62
20155: IN
20156: PUSH
20157: LD_EXP 45
20161: PPUSH
20162: CALL_OW 255
20166: PUSH
20167: LD_INT 1
20169: EQUAL
20170: AND
20171: IFFALSE 20187
// Say ( Bobby , D3nW-Bobby-1 ) else
20173: LD_EXP 45
20177: PPUSH
20178: LD_STRING D3nW-Bobby-1
20180: PPUSH
20181: CALL_OW 88
20185: GO 20349
// if Gary in vip and GetSide ( Gary ) = 1 then
20187: LD_EXP 52
20191: PUSH
20192: LD_EXP 62
20196: IN
20197: PUSH
20198: LD_EXP 52
20202: PPUSH
20203: CALL_OW 255
20207: PUSH
20208: LD_INT 1
20210: EQUAL
20211: AND
20212: IFFALSE 20228
// Say ( Gary , D3nW-Gary-1 ) else
20214: LD_EXP 52
20218: PPUSH
20219: LD_STRING D3nW-Gary-1
20221: PPUSH
20222: CALL_OW 88
20226: GO 20349
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20228: LD_EXP 44
20232: PUSH
20233: LD_EXP 62
20237: IN
20238: PUSH
20239: LD_EXP 44
20243: PPUSH
20244: CALL_OW 255
20248: PUSH
20249: LD_INT 1
20251: EQUAL
20252: AND
20253: IFFALSE 20269
// Say ( Donaldson , D3nW-Don-1 ) else
20255: LD_EXP 44
20259: PPUSH
20260: LD_STRING D3nW-Don-1
20262: PPUSH
20263: CALL_OW 88
20267: GO 20349
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20269: LD_EXP 51
20273: PUSH
20274: LD_EXP 62
20278: IN
20279: PUSH
20280: LD_EXP 51
20284: PPUSH
20285: CALL_OW 255
20289: PUSH
20290: LD_INT 1
20292: EQUAL
20293: AND
20294: IFFALSE 20310
// Say ( Cornel , D3nW-Corn-1 ) else
20296: LD_EXP 51
20300: PPUSH
20301: LD_STRING D3nW-Corn-1
20303: PPUSH
20304: CALL_OW 88
20308: GO 20349
// if Frank in vip and GetSide ( Frank ) = 1 then
20310: LD_EXP 53
20314: PUSH
20315: LD_EXP 62
20319: IN
20320: PUSH
20321: LD_EXP 53
20325: PPUSH
20326: CALL_OW 255
20330: PUSH
20331: LD_INT 1
20333: EQUAL
20334: AND
20335: IFFALSE 20349
// Say ( Frank , D3nW-Frank-1 ) ;
20337: LD_EXP 53
20341: PPUSH
20342: LD_STRING D3nW-Frank-1
20344: PPUSH
20345: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20349: LD_EXP 62
20353: PPUSH
20354: LD_INT 22
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PPUSH
20364: CALL_OW 72
20368: IFFALSE 20394
// begin Say ( JMM , D3nW-JMM-1 ) ;
20370: LD_EXP 40
20374: PPUSH
20375: LD_STRING D3nW-JMM-1
20377: PPUSH
20378: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20382: LD_EXP 40
20386: PPUSH
20387: LD_STRING D3nW-JMM-1a
20389: PPUSH
20390: CALL_OW 88
// end ; t := 0 0$00 ;
20394: LD_ADDR_VAR 0 3
20398: PUSH
20399: LD_INT 0
20401: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20402: LD_INT 35
20404: PPUSH
20405: CALL_OW 67
// t := t + 0 0$1 ;
20409: LD_ADDR_VAR 0 3
20413: PUSH
20414: LD_VAR 0 3
20418: PUSH
20419: LD_INT 35
20421: PLUS
20422: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20423: LD_INT 59
20425: PPUSH
20426: LD_INT 112
20428: PPUSH
20429: CALL_OW 428
20433: PUSH
20434: LD_VAR 0 3
20438: PUSH
20439: LD_INT 2100
20441: GREATER
20442: OR
20443: IFFALSE 20402
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20445: LD_ADDR_EXP 102
20449: PUSH
20450: LD_EXP 102
20454: PPUSH
20455: LD_INT 4
20457: PPUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 23
20470: PUSH
20471: LD_INT 1
20473: PUSH
20474: EMPTY
20475: LIST
20476: LIST
20477: PUSH
20478: LD_INT 3
20480: PUSH
20481: LD_INT 21
20483: PUSH
20484: LD_INT 2
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: PUSH
20505: LD_EXP 61
20509: DIFF
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// activeAttacks := true ;
20516: LD_ADDR_EXP 16
20520: PUSH
20521: LD_INT 1
20523: ST_TO_ADDR
// end ;
20524: LD_VAR 0 1
20528: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20529: LD_INT 0
20531: PPUSH
// case question of 1 :
20532: LD_VAR 0 1
20536: PUSH
20537: LD_INT 1
20539: DOUBLE
20540: EQUAL
20541: IFTRUE 20545
20543: GO 20596
20545: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20546: LD_EXP 40
20550: PPUSH
20551: LD_STRING D2Mot-JMM-1
20553: PPUSH
20554: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20558: LD_EXP 61
20562: PPUSH
20563: LD_STRING D2Mot-Pow-1
20565: PPUSH
20566: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20570: LD_EXP 40
20574: PPUSH
20575: LD_STRING D2Mot-JMM-2
20577: PPUSH
20578: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20582: LD_EXP 61
20586: PPUSH
20587: LD_STRING D2Mot-Pow-2
20589: PPUSH
20590: CALL_OW 88
// end ; 2 :
20594: GO 20947
20596: LD_INT 2
20598: DOUBLE
20599: EQUAL
20600: IFTRUE 20604
20602: GO 20680
20604: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20605: LD_EXP 40
20609: PPUSH
20610: LD_STRING D2Rus-JMM-1
20612: PPUSH
20613: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20617: LD_EXP 61
20621: PPUSH
20622: LD_STRING D2Rus-Pow-1
20624: PPUSH
20625: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20629: LD_EXP 40
20633: PPUSH
20634: LD_STRING D2Rus-JMM-2
20636: PPUSH
20637: CALL_OW 88
// if not ( 3 in list_of_q ) then
20641: LD_INT 3
20643: PUSH
20644: LD_VAR 0 2
20648: IN
20649: NOT
20650: IFFALSE 20666
// Say ( Powell , D2Rus-Pow-2 ) else
20652: LD_EXP 61
20656: PPUSH
20657: LD_STRING D2Rus-Pow-2
20659: PPUSH
20660: CALL_OW 88
20664: GO 20678
// Say ( Powell , D2Rus-Pow-2a ) ;
20666: LD_EXP 61
20670: PPUSH
20671: LD_STRING D2Rus-Pow-2a
20673: PPUSH
20674: CALL_OW 88
// end ; 3 :
20678: GO 20947
20680: LD_INT 3
20682: DOUBLE
20683: EQUAL
20684: IFTRUE 20688
20686: GO 20773
20688: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20689: LD_EXP 40
20693: PPUSH
20694: LD_STRING D2Leg-JMM-1
20696: PPUSH
20697: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20701: LD_EXP 61
20705: PPUSH
20706: LD_STRING D2Leg-Pow-1
20708: PPUSH
20709: CALL_OW 88
// if 2 in list_of_q then
20713: LD_INT 2
20715: PUSH
20716: LD_VAR 0 2
20720: IN
20721: IFFALSE 20747
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20723: LD_EXP 40
20727: PPUSH
20728: LD_STRING D2Leg-JMM-2
20730: PPUSH
20731: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20735: LD_EXP 61
20739: PPUSH
20740: LD_STRING D2Leg-Pow-2
20742: PPUSH
20743: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20747: LD_EXP 40
20751: PPUSH
20752: LD_STRING D2Leg-JMM-3
20754: PPUSH
20755: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20759: LD_EXP 61
20763: PPUSH
20764: LD_STRING D2Leg-Pow-3
20766: PPUSH
20767: CALL_OW 88
// end ; 4 :
20771: GO 20947
20773: LD_INT 4
20775: DOUBLE
20776: EQUAL
20777: IFTRUE 20781
20779: GO 20856
20781: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20782: LD_EXP 40
20786: PPUSH
20787: LD_STRING D2Ar-JMM-1
20789: PPUSH
20790: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20794: LD_EXP 61
20798: PPUSH
20799: LD_STRING D2Ar-Pow-1
20801: PPUSH
20802: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20806: LD_EXP 40
20810: PPUSH
20811: LD_STRING D2Ar-JMM-2
20813: PPUSH
20814: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20818: LD_EXP 61
20822: PPUSH
20823: LD_STRING D2Ar-Pow-2
20825: PPUSH
20826: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20830: LD_EXP 40
20834: PPUSH
20835: LD_STRING D2Ar-JMM-3
20837: PPUSH
20838: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20842: LD_EXP 61
20846: PPUSH
20847: LD_STRING D2Ar-Pow-3
20849: PPUSH
20850: CALL_OW 88
// end ; 5 :
20854: GO 20947
20856: LD_INT 5
20858: DOUBLE
20859: EQUAL
20860: IFTRUE 20864
20862: GO 20879
20864: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20865: LD_EXP 40
20869: PPUSH
20870: LD_STRING D2Conf-JMM-1
20872: PPUSH
20873: CALL_OW 88
20877: GO 20947
20879: LD_INT 6
20881: DOUBLE
20882: EQUAL
20883: IFTRUE 20887
20885: GO 20946
20887: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20888: LD_EXP 40
20892: PPUSH
20893: LD_STRING D2Com-JMM-1
20895: PPUSH
20896: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20900: LD_EXP 61
20904: PPUSH
20905: LD_STRING D2Com-Pow-1
20907: PPUSH
20908: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20912: LD_EXP 40
20916: PPUSH
20917: LD_STRING D2Com-JMM-2
20919: PPUSH
20920: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20924: LD_EXP 61
20928: PPUSH
20929: LD_STRING D2Com-Pow-2
20931: PPUSH
20932: CALL_OW 88
// powellAngerQuery := true ;
20936: LD_ADDR_EXP 36
20940: PUSH
20941: LD_INT 1
20943: ST_TO_ADDR
// end ; end ;
20944: GO 20947
20946: POP
// end ;
20947: LD_VAR 0 3
20951: RET
// every 0 0$5 trigger missionStart do var tmp ;
20952: LD_EXP 13
20956: IFFALSE 21281
20958: GO 20960
20960: DISABLE
20961: LD_INT 0
20963: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20964: LD_INT 35
20966: PPUSH
20967: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20971: LD_INT 14
20973: PPUSH
20974: LD_INT 22
20976: PUSH
20977: LD_INT 1
20979: PUSH
20980: EMPTY
20981: LIST
20982: LIST
20983: PUSH
20984: LD_INT 3
20986: PUSH
20987: LD_INT 21
20989: PUSH
20990: LD_INT 3
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PPUSH
21005: CALL_OW 70
21009: PUSH
21010: LD_EXP 15
21014: PUSH
21015: LD_INT 2
21017: PUSH
21018: LD_INT 3
21020: PUSH
21021: LD_INT 4
21023: PUSH
21024: LD_INT 5
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: LIST
21031: LIST
21032: IN
21033: AND
21034: IFFALSE 21271
// begin powellAnger := powellAnger + 1 ;
21036: LD_ADDR_EXP 17
21040: PUSH
21041: LD_EXP 17
21045: PUSH
21046: LD_INT 1
21048: PLUS
21049: ST_TO_ADDR
// Video ( true ) ;
21050: LD_INT 1
21052: PPUSH
21053: CALL 108076 0 1
// CenterNowOnUnits ( tmp ) ;
21057: LD_VAR 0 1
21061: PPUSH
21062: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21066: LD_INT 14
21068: PPUSH
21069: LD_INT 22
21071: PUSH
21072: LD_INT 1
21074: PUSH
21075: EMPTY
21076: LIST
21077: LIST
21078: PPUSH
21079: CALL_OW 70
21083: PPUSH
21084: LD_INT 86
21086: PPUSH
21087: LD_INT 133
21089: PPUSH
21090: CALL_OW 111
// async ;
21094: ASYNC
// case powellAnger of 1 :
21095: LD_EXP 17
21099: PUSH
21100: LD_INT 1
21102: DOUBLE
21103: EQUAL
21104: IFTRUE 21108
21106: GO 21123
21108: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21109: LD_EXP 61
21113: PPUSH
21114: LD_STRING DBack1-Pow-1
21116: PPUSH
21117: CALL_OW 88
21121: GO 21170
21123: LD_INT 2
21125: DOUBLE
21126: EQUAL
21127: IFTRUE 21131
21129: GO 21146
21131: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21132: LD_EXP 61
21136: PPUSH
21137: LD_STRING DBack2-Pow-1
21139: PPUSH
21140: CALL_OW 88
21144: GO 21170
21146: LD_INT 3
21148: DOUBLE
21149: EQUAL
21150: IFTRUE 21154
21152: GO 21169
21154: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21155: LD_EXP 61
21159: PPUSH
21160: LD_STRING DBack3-Pow-1
21162: PPUSH
21163: CALL_OW 88
21167: GO 21170
21169: POP
// sync ;
21170: SYNC
// repeat wait ( 0 0$1 ) ;
21171: LD_INT 35
21173: PPUSH
21174: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21178: LD_INT 14
21180: PPUSH
21181: LD_INT 22
21183: PUSH
21184: LD_INT 1
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: PPUSH
21191: CALL_OW 70
21195: PPUSH
21196: LD_INT 86
21198: PPUSH
21199: LD_INT 133
21201: PPUSH
21202: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21206: LD_INT 14
21208: PPUSH
21209: LD_INT 22
21211: PUSH
21212: LD_INT 1
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: PUSH
21219: LD_INT 3
21221: PUSH
21222: LD_INT 21
21224: PUSH
21225: LD_INT 3
21227: PUSH
21228: EMPTY
21229: LIST
21230: LIST
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PPUSH
21240: CALL_OW 70
21244: NOT
21245: IFFALSE 21171
// if powellAnger >= 3 then
21247: LD_EXP 17
21251: PUSH
21252: LD_INT 3
21254: GREATEREQUAL
21255: IFFALSE 21264
// YouLost ( Dismissed ) ;
21257: LD_STRING Dismissed
21259: PPUSH
21260: CALL_OW 104
// Video ( false ) ;
21264: LD_INT 0
21266: PPUSH
21267: CALL 108076 0 1
// end ; until missionStage > 5 ;
21271: LD_EXP 15
21275: PUSH
21276: LD_INT 5
21278: GREATER
21279: IFFALSE 20964
// end ;
21281: PPOPN 1
21283: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21284: LD_EXP 13
21288: PUSH
21289: LD_INT 22
21291: PUSH
21292: LD_INT 4
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PUSH
21299: LD_INT 21
21301: PUSH
21302: LD_INT 2
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: PUSH
21309: EMPTY
21310: LIST
21311: LIST
21312: PPUSH
21313: CALL_OW 69
21317: PUSH
21318: LD_INT 4
21320: GREATEREQUAL
21321: AND
21322: PUSH
21323: LD_EXP 15
21327: PUSH
21328: LD_INT 2
21330: EQUAL
21331: AND
21332: IFFALSE 23956
21334: GO 21336
21336: DISABLE
21337: LD_INT 0
21339: PPUSH
21340: PPUSH
21341: PPUSH
21342: PPUSH
21343: PPUSH
21344: PPUSH
21345: PPUSH
21346: PPUSH
21347: PPUSH
21348: PPUSH
21349: PPUSH
// begin missionStage := 3 ;
21350: LD_ADDR_EXP 15
21354: PUSH
21355: LD_INT 3
21357: ST_TO_ADDR
// retreat := false ;
21358: LD_ADDR_VAR 0 4
21362: PUSH
21363: LD_INT 0
21365: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: LD_INT 22
21373: PUSH
21374: LD_INT 4
21376: PUSH
21377: EMPTY
21378: LIST
21379: LIST
21380: PUSH
21381: LD_INT 30
21383: PUSH
21384: LD_INT 4
21386: PUSH
21387: EMPTY
21388: LIST
21389: LIST
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PPUSH
21395: CALL_OW 69
21399: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21400: LD_ADDR_VAR 0 6
21404: PUSH
21405: LD_INT 22
21407: PUSH
21408: LD_INT 4
21410: PUSH
21411: EMPTY
21412: LIST
21413: LIST
21414: PUSH
21415: LD_INT 30
21417: PUSH
21418: LD_INT 5
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: PPUSH
21429: CALL_OW 69
21433: ST_TO_ADDR
// if not bar then
21434: LD_VAR 0 6
21438: NOT
21439: IFFALSE 21492
// begin repeat wait ( 0 0$1 ) ;
21441: LD_INT 35
21443: PPUSH
21444: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21448: LD_INT 22
21450: PUSH
21451: LD_INT 4
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: PUSH
21458: LD_INT 3
21460: PUSH
21461: LD_INT 57
21463: PUSH
21464: EMPTY
21465: LIST
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 30
21473: PUSH
21474: LD_INT 5
21476: PUSH
21477: EMPTY
21478: LIST
21479: LIST
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: LIST
21485: PPUSH
21486: CALL_OW 69
21490: IFFALSE 21441
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21492: LD_ADDR_VAR 0 6
21496: PUSH
21497: LD_INT 22
21499: PUSH
21500: LD_INT 4
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 5
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: PPUSH
21521: CALL_OW 69
21525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21526: LD_INT 35
21528: PPUSH
21529: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21533: LD_EXP 121
21537: PUSH
21538: LD_INT 4
21540: ARRAY
21541: PUSH
21542: LD_INT 4
21544: GREATEREQUAL
21545: IFFALSE 21526
// tmp := [ ] ;
21547: LD_ADDR_VAR 0 2
21551: PUSH
21552: EMPTY
21553: ST_TO_ADDR
// tmp2 := [ ] ;
21554: LD_ADDR_VAR 0 3
21558: PUSH
21559: EMPTY
21560: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21561: LD_ADDR_VAR 0 1
21565: PUSH
21566: LD_INT 22
21568: PUSH
21569: LD_INT 4
21571: PUSH
21572: EMPTY
21573: LIST
21574: LIST
21575: PUSH
21576: LD_INT 2
21578: PUSH
21579: LD_INT 25
21581: PUSH
21582: LD_INT 1
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 2
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 25
21601: PUSH
21602: LD_INT 3
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: PUSH
21609: LD_INT 25
21611: PUSH
21612: LD_INT 4
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: PUSH
21619: LD_INT 25
21621: PUSH
21622: LD_INT 5
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: PPUSH
21641: CALL_OW 69
21645: PUSH
21646: LD_EXP 61
21650: PUSH
21651: LD_EXP 62
21655: UNION
21656: DIFF
21657: PUSH
21658: FOR_IN
21659: IFFALSE 21721
// if not i in extraSquad then
21661: LD_VAR 0 1
21665: PUSH
21666: LD_EXP 63
21670: IN
21671: NOT
21672: IFFALSE 21696
// tmp := Join ( tmp , i ) else
21674: LD_ADDR_VAR 0 2
21678: PUSH
21679: LD_VAR 0 2
21683: PPUSH
21684: LD_VAR 0 1
21688: PPUSH
21689: CALL 108104 0 2
21693: ST_TO_ADDR
21694: GO 21719
// tmp := Insert ( tmp , 1 , i ) ;
21696: LD_ADDR_VAR 0 2
21700: PUSH
21701: LD_VAR 0 2
21705: PPUSH
21706: LD_INT 1
21708: PPUSH
21709: LD_VAR 0 1
21713: PPUSH
21714: CALL_OW 2
21718: ST_TO_ADDR
21719: GO 21658
21721: POP
21722: POP
// tmp := tmp diff 0 ;
21723: LD_ADDR_VAR 0 2
21727: PUSH
21728: LD_VAR 0 2
21732: PUSH
21733: LD_INT 0
21735: DIFF
21736: ST_TO_ADDR
// p := 0 ;
21737: LD_ADDR_VAR 0 11
21741: PUSH
21742: LD_INT 0
21744: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21745: LD_ADDR_VAR 0 1
21749: PUSH
21750: LD_VAR 0 2
21754: PPUSH
21755: LD_INT 26
21757: PUSH
21758: LD_INT 1
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PPUSH
21765: CALL_OW 72
21769: PUSH
21770: FOR_IN
21771: IFFALSE 21822
// begin p := Inc ( p ) ;
21773: LD_ADDR_VAR 0 11
21777: PUSH
21778: LD_VAR 0 11
21782: PPUSH
21783: CALL 109465 0 1
21787: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21788: LD_ADDR_VAR 0 3
21792: PUSH
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_VAR 0 1
21802: PPUSH
21803: CALL 108104 0 2
21807: ST_TO_ADDR
// if p = 4 then
21808: LD_VAR 0 11
21812: PUSH
21813: LD_INT 4
21815: EQUAL
21816: IFFALSE 21820
// break ;
21818: GO 21822
// end ;
21820: GO 21770
21822: POP
21823: POP
// tmp := tmp diff tmp2 ;
21824: LD_ADDR_VAR 0 2
21828: PUSH
21829: LD_VAR 0 2
21833: PUSH
21834: LD_VAR 0 3
21838: DIFF
21839: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21840: LD_ADDR_VAR 0 2
21844: PUSH
21845: LD_VAR 0 2
21849: PPUSH
21850: LD_INT 3
21852: PPUSH
21853: CALL 106608 0 2
21857: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21858: LD_ADDR_VAR 0 3
21862: PUSH
21863: LD_VAR 0 3
21867: PPUSH
21868: LD_INT 3
21870: PPUSH
21871: CALL 106608 0 2
21875: ST_TO_ADDR
// for i := 1 to 4 do
21876: LD_ADDR_VAR 0 1
21880: PUSH
21881: DOUBLE
21882: LD_INT 1
21884: DEC
21885: ST_TO_ADDR
21886: LD_INT 4
21888: PUSH
21889: FOR_TO
21890: IFFALSE 22056
// begin if tmp2 then
21892: LD_VAR 0 3
21896: IFFALSE 21977
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21898: LD_ADDR_EXP 18
21902: PUSH
21903: LD_EXP 18
21907: PPUSH
21908: LD_INT 1
21910: PPUSH
21911: LD_EXP 18
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: PUSH
21920: LD_VAR 0 3
21924: PUSH
21925: LD_VAR 0 3
21929: ARRAY
21930: ADD
21931: PPUSH
21932: CALL_OW 1
21936: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21937: LD_VAR 0 3
21941: PUSH
21942: LD_VAR 0 3
21946: ARRAY
21947: PPUSH
21948: LD_INT 1
21950: PPUSH
21951: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 3
21964: PPUSH
21965: LD_VAR 0 3
21969: PPUSH
21970: CALL_OW 3
21974: ST_TO_ADDR
// end else
21975: GO 22054
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21977: LD_ADDR_EXP 18
21981: PUSH
21982: LD_EXP 18
21986: PPUSH
21987: LD_INT 1
21989: PPUSH
21990: LD_EXP 18
21994: PUSH
21995: LD_INT 1
21997: ARRAY
21998: PUSH
21999: LD_VAR 0 2
22003: PUSH
22004: LD_VAR 0 2
22008: ARRAY
22009: ADD
22010: PPUSH
22011: CALL_OW 1
22015: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
22016: LD_VAR 0 2
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: PPUSH
22027: LD_INT 1
22029: PPUSH
22030: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22034: LD_ADDR_VAR 0 2
22038: PUSH
22039: LD_VAR 0 2
22043: PPUSH
22044: LD_VAR 0 2
22048: PPUSH
22049: CALL_OW 3
22053: ST_TO_ADDR
// end ; end ;
22054: GO 21889
22056: POP
22057: POP
// if tmp2 then
22058: LD_VAR 0 3
22062: IFFALSE 22080
// tmp := tmp union tmp2 ;
22064: LD_ADDR_VAR 0 2
22068: PUSH
22069: LD_VAR 0 2
22073: PUSH
22074: LD_VAR 0 3
22078: UNION
22079: ST_TO_ADDR
// for i := 0 to 3 do
22080: LD_ADDR_VAR 0 1
22084: PUSH
22085: DOUBLE
22086: LD_INT 0
22088: DEC
22089: ST_TO_ADDR
22090: LD_INT 3
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22257
// begin if not tmp [ tmp - i ] then
22096: LD_VAR 0 2
22100: PUSH
22101: LD_VAR 0 2
22105: PUSH
22106: LD_VAR 0 1
22110: MINUS
22111: ARRAY
22112: NOT
22113: IFFALSE 22210
// begin uc_side := 4 ;
22115: LD_ADDR_OWVAR 20
22119: PUSH
22120: LD_INT 4
22122: ST_TO_ADDR
// uc_nation := 1 ;
22123: LD_ADDR_OWVAR 21
22127: PUSH
22128: LD_INT 1
22130: ST_TO_ADDR
// InitHc ;
22131: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 3
22140: PPUSH
22141: CALL_OW 381
// un := CreateHuman ;
22145: LD_ADDR_VAR 0 8
22149: PUSH
22150: CALL_OW 44
22154: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22155: LD_VAR 0 8
22159: PPUSH
22160: LD_INT 39
22162: PPUSH
22163: LD_INT 61
22165: PPUSH
22166: CALL_OW 428
22170: PPUSH
22171: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22175: LD_ADDR_EXP 18
22179: PUSH
22180: LD_EXP 18
22184: PPUSH
22185: LD_INT 2
22187: PPUSH
22188: LD_EXP 18
22192: PUSH
22193: LD_INT 2
22195: ARRAY
22196: PUSH
22197: LD_VAR 0 8
22201: ADD
22202: PPUSH
22203: CALL_OW 1
22207: ST_TO_ADDR
// end else
22208: GO 22255
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22210: LD_ADDR_EXP 18
22214: PUSH
22215: LD_EXP 18
22219: PPUSH
22220: LD_INT 2
22222: PPUSH
22223: LD_EXP 18
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PUSH
22232: LD_VAR 0 2
22236: PUSH
22237: LD_VAR 0 2
22241: PUSH
22242: LD_VAR 0 1
22246: MINUS
22247: ARRAY
22248: ADD
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// end ;
22255: GO 22093
22257: POP
22258: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22259: LD_ADDR_EXP 102
22263: PUSH
22264: LD_EXP 102
22268: PPUSH
22269: LD_INT 4
22271: PPUSH
22272: LD_EXP 102
22276: PUSH
22277: LD_INT 4
22279: ARRAY
22280: PUSH
22281: LD_EXP 18
22285: PUSH
22286: LD_INT 1
22288: ARRAY
22289: DIFF
22290: PPUSH
22291: CALL_OW 1
22295: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22296: LD_VAR 0 5
22300: PUSH
22301: LD_INT 1
22303: ARRAY
22304: PPUSH
22305: CALL_OW 313
22309: IFFALSE 22364
// begin for i in UnitsInside ( arm [ 1 ] ) do
22311: LD_ADDR_VAR 0 1
22315: PUSH
22316: LD_VAR 0 5
22320: PUSH
22321: LD_INT 1
22323: ARRAY
22324: PPUSH
22325: CALL_OW 313
22329: PUSH
22330: FOR_IN
22331: IFFALSE 22362
// begin ComExitBuilding ( i ) ;
22333: LD_VAR 0 1
22337: PPUSH
22338: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 6
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: CALL_OW 180
// end ;
22360: GO 22330
22362: POP
22363: POP
// end ; wait ( 0 0$5 ) ;
22364: LD_INT 175
22366: PPUSH
22367: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22371: LD_INT 35
22373: PPUSH
22374: CALL_OW 67
22378: LD_EXP 18
22382: PUSH
22383: LD_INT 1
22385: ARRAY
22386: PPUSH
22387: LD_INT 55
22389: PUSH
22390: EMPTY
22391: LIST
22392: PPUSH
22393: CALL_OW 72
22397: NOT
22398: IFFALSE 22371
// for i in powellSquadAttack [ 1 ] do
22400: LD_ADDR_VAR 0 1
22404: PUSH
22405: LD_EXP 18
22409: PUSH
22410: LD_INT 1
22412: ARRAY
22413: PUSH
22414: FOR_IN
22415: IFFALSE 22522
// begin if IsInUnit ( i ) then
22417: LD_VAR 0 1
22421: PPUSH
22422: CALL_OW 310
22426: IFFALSE 22437
// ComExitBuilding ( i ) ;
22428: LD_VAR 0 1
22432: PPUSH
22433: CALL_OW 122
// if GetClass ( i ) <> 1 then
22437: LD_VAR 0 1
22441: PPUSH
22442: CALL_OW 257
22446: PUSH
22447: LD_INT 1
22449: NONEQUAL
22450: IFFALSE 22491
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22452: LD_VAR 0 1
22456: PPUSH
22457: LD_VAR 0 5
22461: PUSH
22462: LD_INT 1
22464: ARRAY
22465: PPUSH
22466: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: LD_INT 1
22477: PPUSH
22478: CALL_OW 183
// AddComExitBuilding ( i ) ;
22482: LD_VAR 0 1
22486: PPUSH
22487: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22491: LD_VAR 0 1
22495: PPUSH
22496: LD_INT 60
22498: PPUSH
22499: LD_INT 94
22501: PPUSH
22502: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_EXP 61
22515: PPUSH
22516: CALL_OW 179
// end ;
22520: GO 22414
22522: POP
22523: POP
// wait ( 0 0$45 ) ;
22524: LD_INT 1575
22526: PPUSH
22527: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22531: LD_EXP 61
22535: PPUSH
22536: LD_STRING D4-Pow-1
22538: PPUSH
22539: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22543: LD_ADDR_VAR 0 2
22547: PUSH
22548: LD_EXP 18
22552: PUSH
22553: LD_INT 1
22555: ARRAY
22556: PPUSH
22557: LD_INT 26
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: PPUSH
22567: CALL_OW 72
22571: ST_TO_ADDR
// if tmp then
22572: LD_VAR 0 2
22576: IFFALSE 22594
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22578: LD_VAR 0 2
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: PPUSH
22587: LD_STRING D4-Sol1-1
22589: PPUSH
22590: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22594: LD_EXP 61
22598: PPUSH
22599: LD_STRING D4-Pow-2
22601: PPUSH
22602: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22606: LD_ADDR_VAR 0 1
22610: PUSH
22611: DOUBLE
22612: LD_INT 1
22614: DEC
22615: ST_TO_ADDR
22616: LD_EXP 18
22620: PUSH
22621: LD_INT 1
22623: ARRAY
22624: PUSH
22625: FOR_TO
22626: IFFALSE 22719
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22628: LD_EXP 18
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PUSH
22637: LD_VAR 0 1
22641: ARRAY
22642: PPUSH
22643: LD_EXP 121
22647: PUSH
22648: LD_INT 4
22650: ARRAY
22651: PUSH
22652: LD_INT 1
22654: ARRAY
22655: PPUSH
22656: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22660: LD_ADDR_EXP 121
22664: PUSH
22665: LD_EXP 121
22669: PPUSH
22670: LD_INT 4
22672: PPUSH
22673: LD_EXP 121
22677: PUSH
22678: LD_INT 4
22680: ARRAY
22681: PPUSH
22682: LD_INT 1
22684: PPUSH
22685: CALL_OW 3
22689: PPUSH
22690: CALL_OW 1
22694: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22695: LD_INT 8
22697: PPUSH
22698: LD_EXP 18
22702: PUSH
22703: LD_INT 1
22705: ARRAY
22706: PUSH
22707: LD_VAR 0 1
22711: ARRAY
22712: PPUSH
22713: CALL_OW 471
// end ;
22717: GO 22625
22719: POP
22720: POP
// repeat wait ( 0 0$1 ) ;
22721: LD_INT 35
22723: PPUSH
22724: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22728: LD_EXP 18
22732: PUSH
22733: LD_INT 1
22735: ARRAY
22736: PPUSH
22737: LD_INT 55
22739: PUSH
22740: EMPTY
22741: LIST
22742: PPUSH
22743: CALL_OW 72
22747: PUSH
22748: LD_INT 4
22750: GREATEREQUAL
22751: IFFALSE 22721
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22753: LD_EXP 18
22757: PUSH
22758: LD_INT 1
22760: ARRAY
22761: PPUSH
22762: LD_INT 69
22764: PPUSH
22765: LD_INT 94
22767: PPUSH
22768: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22772: LD_EXP 18
22776: PUSH
22777: LD_INT 1
22779: ARRAY
22780: PPUSH
22781: LD_INT 82
22783: PPUSH
22784: LD_INT 83
22786: PPUSH
22787: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22791: LD_EXP 18
22795: PUSH
22796: LD_INT 1
22798: ARRAY
22799: PPUSH
22800: LD_INT 77
22802: PPUSH
22803: LD_INT 69
22805: PPUSH
22806: CALL_OW 174
// wait ( 0 0$30 ) ;
22810: LD_INT 1050
22812: PPUSH
22813: CALL_OW 67
// repeat wait ( 3 ) ;
22817: LD_INT 3
22819: PPUSH
22820: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22824: LD_ADDR_VAR 0 1
22828: PUSH
22829: LD_EXP 18
22833: PUSH
22834: LD_INT 1
22836: ARRAY
22837: PUSH
22838: FOR_IN
22839: IFFALSE 22975
// begin if GetLives ( i ) < 990 then
22841: LD_VAR 0 1
22845: PPUSH
22846: CALL_OW 256
22850: PUSH
22851: LD_INT 990
22853: LESS
22854: IFFALSE 22868
// SetLives ( i , 1000 ) ;
22856: LD_VAR 0 1
22860: PPUSH
22861: LD_INT 1000
22863: PPUSH
22864: CALL_OW 234
// if not IsInUnit ( i ) then
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 310
22877: NOT
22878: IFFALSE 22973
// begin if not HasTask ( i ) then
22880: LD_VAR 0 1
22884: PPUSH
22885: CALL_OW 314
22889: NOT
22890: IFFALSE 22907
// ComMoveXY ( i , 64 , 93 ) ;
22892: LD_VAR 0 1
22896: PPUSH
22897: LD_INT 64
22899: PPUSH
22900: LD_INT 93
22902: PPUSH
22903: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22907: LD_VAR 0 4
22911: NOT
22912: PUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 258
22922: PUSH
22923: LD_INT 1
22925: EQUAL
22926: AND
22927: IFFALSE 22973
// begin retreat := true ;
22929: LD_ADDR_VAR 0 4
22933: PUSH
22934: LD_INT 1
22936: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22937: LD_VAR 0 1
22941: PPUSH
22942: LD_INT 2
22944: PPUSH
22945: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22949: LD_VAR 0 1
22953: PPUSH
22954: LD_STRING D4a-Sol1-1
22956: PPUSH
22957: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22961: LD_EXP 61
22965: PPUSH
22966: LD_STRING D4a-Pow-1
22968: PPUSH
22969: CALL_OW 88
// end ; end ; end ;
22973: GO 22838
22975: POP
22976: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
22977: LD_EXP 18
22981: PUSH
22982: LD_INT 1
22984: ARRAY
22985: PPUSH
22986: LD_INT 95
22988: PUSH
22989: LD_INT 9
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: PPUSH
22996: CALL_OW 72
23000: PUSH
23001: LD_INT 4
23003: GREATEREQUAL
23004: IFFALSE 22817
// for i in powellSquadAttack [ 1 ] do
23006: LD_ADDR_VAR 0 1
23010: PUSH
23011: LD_EXP 18
23015: PUSH
23016: LD_INT 1
23018: ARRAY
23019: PUSH
23020: FOR_IN
23021: IFFALSE 23157
// begin if GetTag ( i ) = 2 then
23023: LD_VAR 0 1
23027: PPUSH
23028: CALL_OW 110
23032: PUSH
23033: LD_INT 2
23035: EQUAL
23036: IFFALSE 23098
// begin ComMoveXY ( i , 60 , 94 ) ;
23038: LD_VAR 0 1
23042: PPUSH
23043: LD_INT 60
23045: PPUSH
23046: LD_INT 94
23048: PPUSH
23049: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23053: LD_VAR 0 1
23057: PPUSH
23058: LD_EXP 61
23062: PPUSH
23063: CALL_OW 179
// wait ( 0 0$3 ) ;
23067: LD_INT 105
23069: PPUSH
23070: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23074: LD_VAR 0 1
23078: PPUSH
23079: LD_STRING D4a-Sol1-2
23081: PPUSH
23082: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23086: LD_EXP 61
23090: PPUSH
23091: LD_STRING D4a-Pow-2
23093: PPUSH
23094: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23098: LD_VAR 0 1
23102: PPUSH
23103: LD_INT 0
23105: PPUSH
23106: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23110: LD_ADDR_EXP 102
23114: PUSH
23115: LD_EXP 102
23119: PPUSH
23120: LD_INT 4
23122: PPUSH
23123: LD_EXP 102
23127: PUSH
23128: LD_INT 4
23130: ARRAY
23131: PUSH
23132: LD_VAR 0 1
23136: UNION
23137: PPUSH
23138: CALL_OW 1
23142: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23143: LD_INT 8
23145: PPUSH
23146: LD_VAR 0 1
23150: PPUSH
23151: CALL_OW 472
// end ;
23155: GO 23020
23157: POP
23158: POP
// wait ( 1 1$00 ) ;
23159: LD_INT 2100
23161: PPUSH
23162: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23166: LD_ADDR_VAR 0 9
23170: PUSH
23171: LD_INT 22
23173: PUSH
23174: LD_INT 4
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: PUSH
23181: LD_INT 30
23183: PUSH
23184: LD_INT 32
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: PUSH
23191: LD_INT 58
23193: PUSH
23194: EMPTY
23195: LIST
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: LIST
23201: PPUSH
23202: CALL_OW 69
23206: ST_TO_ADDR
// if tmp then
23207: LD_VAR 0 2
23211: IFFALSE 23451
// begin for i := 1 to tmp do
23213: LD_ADDR_VAR 0 1
23217: PUSH
23218: DOUBLE
23219: LD_INT 1
23221: DEC
23222: ST_TO_ADDR
23223: LD_VAR 0 2
23227: PUSH
23228: FOR_TO
23229: IFFALSE 23442
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23231: LD_ADDR_EXP 102
23235: PUSH
23236: LD_EXP 102
23240: PPUSH
23241: LD_INT 4
23243: PPUSH
23244: LD_EXP 102
23248: PUSH
23249: LD_INT 4
23251: ARRAY
23252: PUSH
23253: LD_VAR 0 2
23257: PUSH
23258: LD_VAR 0 1
23262: ARRAY
23263: DIFF
23264: PPUSH
23265: CALL_OW 1
23269: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23270: LD_ADDR_VAR 0 10
23274: PUSH
23275: LD_VAR 0 2
23279: PUSH
23280: LD_VAR 0 1
23284: ARRAY
23285: PPUSH
23286: CALL_OW 310
23290: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23291: LD_VAR 0 10
23295: PUSH
23296: LD_VAR 0 10
23300: PPUSH
23301: CALL_OW 266
23305: PUSH
23306: LD_INT 32
23308: EQUAL
23309: AND
23310: IFFALSE 23314
// continue ;
23312: GO 23228
// if t then
23314: LD_VAR 0 10
23318: IFFALSE 23335
// ComExitBuilding ( tmp [ i ] ) ;
23320: LD_VAR 0 2
23324: PUSH
23325: LD_VAR 0 1
23329: ARRAY
23330: PPUSH
23331: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23335: LD_VAR 0 2
23339: PUSH
23340: LD_VAR 0 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 5
23350: PUSH
23351: LD_INT 1
23353: ARRAY
23354: PPUSH
23355: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23359: LD_VAR 0 2
23363: PUSH
23364: LD_VAR 0 1
23368: ARRAY
23369: PPUSH
23370: LD_INT 1
23372: PPUSH
23373: CALL_OW 183
// if emptyTowers then
23377: LD_VAR 0 9
23381: IFFALSE 23440
// begin AddComExitBuilding ( tmp [ i ] ) ;
23383: LD_VAR 0 2
23387: PUSH
23388: LD_VAR 0 1
23392: ARRAY
23393: PPUSH
23394: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23398: LD_VAR 0 2
23402: PUSH
23403: LD_VAR 0 1
23407: ARRAY
23408: PPUSH
23409: LD_VAR 0 9
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: PPUSH
23418: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23422: LD_ADDR_VAR 0 9
23426: PUSH
23427: LD_VAR 0 9
23431: PPUSH
23432: LD_INT 1
23434: PPUSH
23435: CALL_OW 3
23439: ST_TO_ADDR
// end ; end ;
23440: GO 23228
23442: POP
23443: POP
// wait ( 0 0$30 ) ;
23444: LD_INT 1050
23446: PPUSH
23447: CALL_OW 67
// end ; uc_side := 6 ;
23451: LD_ADDR_OWVAR 20
23455: PUSH
23456: LD_INT 6
23458: ST_TO_ADDR
// uc_nation := 3 ;
23459: LD_ADDR_OWVAR 21
23463: PUSH
23464: LD_INT 3
23466: ST_TO_ADDR
// ru := [ ] ;
23467: LD_ADDR_VAR 0 7
23471: PUSH
23472: EMPTY
23473: ST_TO_ADDR
// for i = 1 to 5 do
23474: LD_ADDR_VAR 0 1
23478: PUSH
23479: DOUBLE
23480: LD_INT 1
23482: DEC
23483: ST_TO_ADDR
23484: LD_INT 5
23486: PUSH
23487: FOR_TO
23488: IFFALSE 23608
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23490: LD_INT 22
23492: PUSH
23493: LD_INT 23
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: LD_INT 1
23502: PPUSH
23503: LD_INT 2
23505: PPUSH
23506: CALL_OW 12
23510: ARRAY
23511: PPUSH
23512: LD_INT 1
23514: PPUSH
23515: LD_INT 3
23517: PPUSH
23518: LD_INT 43
23520: PUSH
23521: LD_INT 44
23523: PUSH
23524: EMPTY
23525: LIST
23526: LIST
23527: PUSH
23528: LD_INT 1
23530: PPUSH
23531: LD_INT 2
23533: PPUSH
23534: CALL_OW 12
23538: ARRAY
23539: PPUSH
23540: LD_INT 89
23542: PPUSH
23543: CALL 75233 0 5
// un := CreateVehicle ;
23547: LD_ADDR_VAR 0 8
23551: PUSH
23552: CALL_OW 45
23556: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23557: LD_VAR 0 8
23561: PPUSH
23562: LD_INT 4
23564: PPUSH
23565: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23569: LD_VAR 0 8
23573: PPUSH
23574: LD_INT 136
23576: PPUSH
23577: LD_INT 90
23579: PPUSH
23580: LD_INT 8
23582: PPUSH
23583: LD_INT 0
23585: PPUSH
23586: CALL_OW 50
// ru := ru ^ un ;
23590: LD_ADDR_VAR 0 7
23594: PUSH
23595: LD_VAR 0 7
23599: PUSH
23600: LD_VAR 0 8
23604: ADD
23605: ST_TO_ADDR
// end ;
23606: GO 23487
23608: POP
23609: POP
// if ru then
23610: LD_VAR 0 7
23614: IFFALSE 23631
// ComAgressiveMove ( ru , 57 , 94 ) ;
23616: LD_VAR 0 7
23620: PPUSH
23621: LD_INT 57
23623: PPUSH
23624: LD_INT 94
23626: PPUSH
23627: CALL_OW 114
// wait ( 3 3$00 ) ;
23631: LD_INT 6300
23633: PPUSH
23634: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23638: LD_ADDR_VAR 0 11
23642: PUSH
23643: LD_INT 54
23645: PPUSH
23646: LD_INT 85
23648: PPUSH
23649: CALL_OW 428
23653: PPUSH
23654: CALL_OW 313
23658: ST_TO_ADDR
// t := 0 ;
23659: LD_ADDR_VAR 0 10
23663: PUSH
23664: LD_INT 0
23666: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23667: LD_ADDR_VAR 0 1
23671: PUSH
23672: LD_INT 22
23674: PUSH
23675: LD_INT 4
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 3
23684: PUSH
23685: LD_INT 58
23687: PUSH
23688: EMPTY
23689: LIST
23690: PUSH
23691: EMPTY
23692: LIST
23693: LIST
23694: PUSH
23695: LD_INT 30
23697: PUSH
23698: LD_INT 32
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: PPUSH
23710: CALL_OW 69
23714: PUSH
23715: FOR_IN
23716: IFFALSE 23842
// begin if p + t > 5 then
23718: LD_VAR 0 11
23722: PUSH
23723: LD_VAR 0 10
23727: PLUS
23728: PUSH
23729: LD_INT 5
23731: GREATER
23732: IFFALSE 23736
// break ;
23734: GO 23842
// un := UnitsInside ( i ) ;
23736: LD_ADDR_VAR 0 8
23740: PUSH
23741: LD_VAR 0 1
23745: PPUSH
23746: CALL_OW 313
23750: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23751: LD_VAR 0 8
23755: PPUSH
23756: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23760: LD_VAR 0 8
23764: PPUSH
23765: LD_INT 54
23767: PPUSH
23768: LD_INT 85
23770: PPUSH
23771: CALL_OW 428
23775: PPUSH
23776: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23780: LD_VAR 0 8
23784: PPUSH
23785: LD_INT 3
23787: PPUSH
23788: CALL_OW 183
// t := Inc ( t ) ;
23792: LD_ADDR_VAR 0 10
23796: PUSH
23797: LD_VAR 0 10
23801: PPUSH
23802: CALL 109465 0 1
23806: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23807: LD_ADDR_EXP 102
23811: PUSH
23812: LD_EXP 102
23816: PPUSH
23817: LD_INT 4
23819: PPUSH
23820: LD_EXP 102
23824: PUSH
23825: LD_INT 4
23827: ARRAY
23828: PUSH
23829: LD_VAR 0 8
23833: ADD
23834: PPUSH
23835: CALL_OW 1
23839: ST_TO_ADDR
// end ;
23840: GO 23715
23842: POP
23843: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23844: LD_INT 4
23846: PPUSH
23847: LD_INT 3
23849: PUSH
23850: LD_INT 1
23852: PUSH
23853: LD_INT 1
23855: PUSH
23856: LD_INT 5
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 4
23867: PUSH
23868: LD_INT 1
23870: PUSH
23871: LD_INT 1
23873: PUSH
23874: LD_INT 6
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: PUSH
23883: LD_INT 4
23885: PUSH
23886: LD_INT 1
23888: PUSH
23889: LD_INT 1
23891: PUSH
23892: LD_INT 7
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: PUSH
23901: LD_INT 3
23903: PUSH
23904: LD_INT 1
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: LD_INT 7
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: LIST
23917: LIST
23918: PUSH
23919: LD_INT 3
23921: PUSH
23922: LD_INT 1
23924: PUSH
23925: LD_INT 1
23927: PUSH
23928: LD_INT 5
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: PPUSH
23944: CALL 63835 0 2
// missionStage := 4 ;
23948: LD_ADDR_EXP 15
23952: PUSH
23953: LD_INT 4
23955: ST_TO_ADDR
// end ;
23956: PPOPN 11
23958: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23959: LD_EXP 15
23963: PUSH
23964: LD_INT 4
23966: EQUAL
23967: PUSH
23968: LD_INT 22
23970: PUSH
23971: LD_INT 4
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PUSH
23978: LD_INT 21
23980: PUSH
23981: LD_INT 2
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PPUSH
23992: CALL_OW 69
23996: PUSH
23997: LD_INT 5
23999: GREATEREQUAL
24000: AND
24001: IFFALSE 28365
24003: GO 24005
24005: DISABLE
24006: LD_INT 0
24008: PPUSH
24009: PPUSH
24010: PPUSH
24011: PPUSH
24012: PPUSH
24013: PPUSH
24014: PPUSH
24015: PPUSH
24016: PPUSH
24017: PPUSH
24018: PPUSH
24019: PPUSH
24020: PPUSH
24021: PPUSH
// begin wait ( 0 0$10 ) ;
24022: LD_INT 350
24024: PPUSH
24025: CALL_OW 67
// missionStage := 5 ;
24029: LD_ADDR_EXP 15
24033: PUSH
24034: LD_INT 5
24036: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24037: LD_ADDR_VAR 0 11
24041: PUSH
24042: LD_INT 22
24044: PUSH
24045: LD_INT 4
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 2
24054: PUSH
24055: LD_INT 30
24057: PUSH
24058: LD_INT 4
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: LD_INT 30
24067: PUSH
24068: LD_INT 5
24070: PUSH
24071: EMPTY
24072: LIST
24073: LIST
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: LIST
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PPUSH
24084: CALL_OW 69
24088: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24089: LD_ADDR_VAR 0 6
24093: PUSH
24094: LD_INT 22
24096: PUSH
24097: LD_INT 4
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PUSH
24104: LD_INT 21
24106: PUSH
24107: LD_INT 1
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: LD_INT 3
24116: PUSH
24117: LD_INT 25
24119: PUSH
24120: LD_INT 16
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 25
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: LIST
24153: PPUSH
24154: CALL_OW 69
24158: PUSH
24159: LD_EXP 61
24163: DIFF
24164: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24165: LD_ADDR_VAR 0 10
24169: PUSH
24170: LD_INT 22
24172: PUSH
24173: LD_INT 4
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PUSH
24180: LD_INT 30
24182: PUSH
24183: LD_INT 3
24185: PUSH
24186: EMPTY
24187: LIST
24188: LIST
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PPUSH
24194: CALL_OW 69
24198: PUSH
24199: LD_INT 1
24201: ARRAY
24202: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24203: LD_INT 350
24205: PPUSH
24206: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24210: LD_EXP 121
24214: PUSH
24215: LD_INT 4
24217: ARRAY
24218: PUSH
24219: LD_INT 5
24221: LESS
24222: PUSH
24223: LD_VAR 0 10
24227: PPUSH
24228: CALL_OW 461
24232: PUSH
24233: LD_INT 2
24235: EQUAL
24236: AND
24237: IFFALSE 24267
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 3
24244: PUSH
24245: LD_INT 1
24247: PUSH
24248: LD_INT 1
24250: PUSH
24251: LD_INT 5
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: PUSH
24260: EMPTY
24261: LIST
24262: PPUSH
24263: CALL 63883 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24267: LD_EXP 121
24271: PUSH
24272: LD_INT 4
24274: ARRAY
24275: PUSH
24276: LD_INT 5
24278: GREATEREQUAL
24279: PUSH
24280: LD_EXP 121
24284: PUSH
24285: LD_INT 4
24287: ARRAY
24288: PPUSH
24289: LD_INT 58
24291: PUSH
24292: EMPTY
24293: LIST
24294: PPUSH
24295: CALL_OW 72
24299: PUSH
24300: LD_INT 5
24302: GREATEREQUAL
24303: AND
24304: IFFALSE 24203
// powellAllowRetreat := false ;
24306: LD_ADDR_EXP 19
24310: PUSH
24311: LD_INT 0
24313: ST_TO_ADDR
// activeAttacks := false ;
24314: LD_ADDR_EXP 16
24318: PUSH
24319: LD_INT 0
24321: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24322: LD_INT 35
24324: PPUSH
24325: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24329: LD_INT 22
24331: PUSH
24332: LD_INT 6
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PPUSH
24339: CALL_OW 69
24343: PUSH
24344: LD_INT 0
24346: EQUAL
24347: IFFALSE 24322
// tmp := mc_vehicles [ 4 ] ;
24349: LD_ADDR_VAR 0 3
24353: PUSH
24354: LD_EXP 121
24358: PUSH
24359: LD_INT 4
24361: ARRAY
24362: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24363: LD_ADDR_VAR 0 1
24367: PUSH
24368: DOUBLE
24369: LD_INT 1
24371: DEC
24372: ST_TO_ADDR
24373: LD_EXP 18
24377: PUSH
24378: FOR_TO
24379: IFFALSE 24701
// begin for j in powellSquadAttack [ i ] do
24381: LD_ADDR_VAR 0 2
24385: PUSH
24386: LD_EXP 18
24390: PUSH
24391: LD_VAR 0 1
24395: ARRAY
24396: PUSH
24397: FOR_IN
24398: IFFALSE 24697
// begin if j in mc_bases [ 4 ] then
24400: LD_VAR 0 2
24404: PUSH
24405: LD_EXP 102
24409: PUSH
24410: LD_INT 4
24412: ARRAY
24413: IN
24414: IFFALSE 24449
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24416: LD_ADDR_EXP 102
24420: PUSH
24421: LD_EXP 102
24425: PPUSH
24426: LD_INT 4
24428: PPUSH
24429: LD_EXP 102
24433: PUSH
24434: LD_INT 4
24436: ARRAY
24437: PUSH
24438: LD_VAR 0 2
24442: DIFF
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// forces := forces diff j ;
24449: LD_ADDR_VAR 0 6
24453: PUSH
24454: LD_VAR 0 6
24458: PUSH
24459: LD_VAR 0 2
24463: DIFF
24464: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24465: LD_VAR 0 2
24469: PPUSH
24470: LD_INT 1
24472: PPUSH
24473: CALL_OW 109
// wait ( 0 0$2 ) ;
24477: LD_INT 70
24479: PPUSH
24480: CALL_OW 67
// if IsInUnit ( j ) then
24484: LD_VAR 0 2
24488: PPUSH
24489: CALL_OW 310
24493: IFFALSE 24504
// ComExitBuilding ( j ) ;
24495: LD_VAR 0 2
24499: PPUSH
24500: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24504: LD_VAR 0 2
24508: PPUSH
24509: CALL_OW 257
24513: PUSH
24514: LD_INT 1
24516: NONEQUAL
24517: PUSH
24518: LD_VAR 0 2
24522: PPUSH
24523: CALL_OW 314
24527: NOT
24528: AND
24529: IFFALSE 24609
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24531: LD_VAR 0 11
24535: PUSH
24536: LD_INT 1
24538: ARRAY
24539: PPUSH
24540: CALL_OW 313
24544: PUSH
24545: LD_INT 5
24547: GREATEREQUAL
24548: IFFALSE 24570
// ComEnterUnit ( j , arm [ 2 ] ) else
24550: LD_VAR 0 2
24554: PPUSH
24555: LD_VAR 0 11
24559: PUSH
24560: LD_INT 2
24562: ARRAY
24563: PPUSH
24564: CALL_OW 120
24568: GO 24588
// ComEnterUnit ( j , arm [ 1 ] ) ;
24570: LD_VAR 0 2
24574: PPUSH
24575: LD_VAR 0 11
24579: PUSH
24580: LD_INT 1
24582: ARRAY
24583: PPUSH
24584: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24588: LD_VAR 0 2
24592: PPUSH
24593: LD_INT 1
24595: PPUSH
24596: CALL_OW 183
// AddComExitBuilding ( j ) ;
24600: LD_VAR 0 2
24604: PPUSH
24605: CALL_OW 182
// end ; if i = 2 then
24609: LD_VAR 0 1
24613: PUSH
24614: LD_INT 2
24616: EQUAL
24617: IFFALSE 24634
// AddComMoveXY ( j , 61 , 93 ) ;
24619: LD_VAR 0 2
24623: PPUSH
24624: LD_INT 61
24626: PPUSH
24627: LD_INT 93
24629: PPUSH
24630: CALL_OW 171
// if i = 1 then
24634: LD_VAR 0 1
24638: PUSH
24639: LD_INT 1
24641: EQUAL
24642: IFFALSE 24695
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24644: LD_VAR 0 2
24648: PPUSH
24649: LD_VAR 0 3
24653: PUSH
24654: LD_INT 1
24656: ARRAY
24657: PPUSH
24658: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24662: LD_ADDR_VAR 0 3
24666: PUSH
24667: LD_VAR 0 3
24671: PPUSH
24672: LD_INT 1
24674: PPUSH
24675: CALL_OW 3
24679: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24680: LD_VAR 0 2
24684: PPUSH
24685: LD_INT 69
24687: PPUSH
24688: LD_INT 94
24690: PPUSH
24691: CALL_OW 171
// end ; end ;
24695: GO 24397
24697: POP
24698: POP
// end ;
24699: GO 24378
24701: POP
24702: POP
// wait ( 0 0$30 ) ;
24703: LD_INT 1050
24705: PPUSH
24706: CALL_OW 67
// MC_Kill ( 4 ) ;
24710: LD_INT 4
24712: PPUSH
24713: CALL 39858 0 1
// tmp := UnitsInside ( fac ) ;
24717: LD_ADDR_VAR 0 3
24721: PUSH
24722: LD_VAR 0 10
24726: PPUSH
24727: CALL_OW 313
24731: ST_TO_ADDR
// if tmp then
24732: LD_VAR 0 3
24736: IFFALSE 24857
// for i in tmp do
24738: LD_ADDR_VAR 0 1
24742: PUSH
24743: LD_VAR 0 3
24747: PUSH
24748: FOR_IN
24749: IFFALSE 24855
// begin ComExitBuilding ( i ) ;
24751: LD_VAR 0 1
24755: PPUSH
24756: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24760: LD_VAR 0 11
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PPUSH
24769: CALL_OW 313
24773: PUSH
24774: LD_INT 6
24776: LESS
24777: IFFALSE 24799
// AddComEnterUnit ( i , arm [ 2 ] ) else
24779: LD_VAR 0 1
24783: PPUSH
24784: LD_VAR 0 11
24788: PUSH
24789: LD_INT 2
24791: ARRAY
24792: PPUSH
24793: CALL_OW 180
24797: GO 24853
// if UnitsInside ( arm [ 1 ] ) < 6 then
24799: LD_VAR 0 11
24803: PUSH
24804: LD_INT 1
24806: ARRAY
24807: PPUSH
24808: CALL_OW 313
24812: PUSH
24813: LD_INT 6
24815: LESS
24816: IFFALSE 24838
// AddComEnterUnit ( i , arm [ 1 ] ) else
24818: LD_VAR 0 1
24822: PPUSH
24823: LD_VAR 0 11
24827: PUSH
24828: LD_INT 1
24830: ARRAY
24831: PPUSH
24832: CALL_OW 180
24836: GO 24853
// AddComMoveXY ( i , 37 , 68 ) ;
24838: LD_VAR 0 1
24842: PPUSH
24843: LD_INT 37
24845: PPUSH
24846: LD_INT 68
24848: PPUSH
24849: CALL_OW 171
// end ;
24853: GO 24748
24855: POP
24856: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24857: LD_ADDR_VAR 0 12
24861: PUSH
24862: LD_VAR 0 6
24866: PPUSH
24867: LD_INT 26
24869: PUSH
24870: LD_INT 1
24872: PUSH
24873: EMPTY
24874: LIST
24875: LIST
24876: PPUSH
24877: CALL_OW 72
24881: PUSH
24882: LD_EXP 62
24886: DIFF
24887: ST_TO_ADDR
// if not speaker then
24888: LD_VAR 0 12
24892: NOT
24893: IFFALSE 24920
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24895: LD_ADDR_VAR 0 12
24899: PUSH
24900: LD_VAR 0 6
24904: PPUSH
24905: LD_INT 26
24907: PUSH
24908: LD_INT 1
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PPUSH
24915: CALL_OW 72
24919: ST_TO_ADDR
// if speaker then
24920: LD_VAR 0 12
24924: IFFALSE 24940
// speaker := speaker [ 1 ] ;
24926: LD_ADDR_VAR 0 12
24930: PUSH
24931: LD_VAR 0 12
24935: PUSH
24936: LD_INT 1
24938: ARRAY
24939: ST_TO_ADDR
// Video ( true ) ;
24940: LD_INT 1
24942: PPUSH
24943: CALL 108076 0 1
// CenterNowOnUnits ( Powell ) ;
24947: LD_EXP 61
24951: PPUSH
24952: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24956: LD_ADDR_VAR 0 3
24960: PUSH
24961: LD_VAR 0 6
24965: PPUSH
24966: LD_INT 3
24968: PUSH
24969: LD_INT 25
24971: PUSH
24972: LD_INT 1
24974: PUSH
24975: EMPTY
24976: LIST
24977: LIST
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: PPUSH
24983: CALL_OW 72
24987: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24988: LD_ADDR_VAR 0 13
24992: PUSH
24993: LD_INT 22
24995: PUSH
24996: LD_INT 4
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 30
25005: PUSH
25006: LD_INT 32
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 58
25015: PUSH
25016: EMPTY
25017: LIST
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: LIST
25023: PPUSH
25024: CALL_OW 69
25028: ST_TO_ADDR
// t := Count ( tmp ) ;
25029: LD_ADDR_VAR 0 7
25033: PUSH
25034: LD_VAR 0 3
25038: PPUSH
25039: CALL 72495 0 1
25043: ST_TO_ADDR
// if t > 4 then
25044: LD_VAR 0 7
25048: PUSH
25049: LD_INT 4
25051: GREATER
25052: IFFALSE 25062
// t := 4 ;
25054: LD_ADDR_VAR 0 7
25058: PUSH
25059: LD_INT 4
25061: ST_TO_ADDR
// for i := 1 to t do
25062: LD_ADDR_VAR 0 1
25066: PUSH
25067: DOUBLE
25068: LD_INT 1
25070: DEC
25071: ST_TO_ADDR
25072: LD_VAR 0 7
25076: PUSH
25077: FOR_TO
25078: IFFALSE 25224
// begin if IsInUnit ( tmp [ i ] ) then
25080: LD_VAR 0 3
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PPUSH
25091: CALL_OW 310
25095: IFFALSE 25112
// ComExitBuilding ( tmp [ i ] ) ;
25097: LD_VAR 0 3
25101: PUSH
25102: LD_VAR 0 1
25106: ARRAY
25107: PPUSH
25108: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25112: LD_VAR 0 3
25116: PUSH
25117: LD_VAR 0 1
25121: ARRAY
25122: PPUSH
25123: LD_VAR 0 11
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25136: LD_VAR 0 3
25140: PUSH
25141: LD_VAR 0 1
25145: ARRAY
25146: PPUSH
25147: LD_INT 1
25149: PPUSH
25150: CALL_OW 183
// if Count ( emp_towers ) then
25154: LD_VAR 0 13
25158: PPUSH
25159: CALL 72495 0 1
25163: IFFALSE 25222
// begin AddComExitBuilding ( tmp [ i ] ) ;
25165: LD_VAR 0 3
25169: PUSH
25170: LD_VAR 0 1
25174: ARRAY
25175: PPUSH
25176: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25180: LD_VAR 0 3
25184: PUSH
25185: LD_VAR 0 1
25189: ARRAY
25190: PPUSH
25191: LD_VAR 0 13
25195: PUSH
25196: LD_INT 1
25198: ARRAY
25199: PPUSH
25200: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25204: LD_ADDR_VAR 0 13
25208: PUSH
25209: LD_VAR 0 13
25213: PPUSH
25214: LD_INT 1
25216: PPUSH
25217: CALL_OW 3
25221: ST_TO_ADDR
// end ; end ;
25222: GO 25077
25224: POP
25225: POP
// wait ( 0 0$5 ) ;
25226: LD_INT 175
25228: PPUSH
25229: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25233: LD_VAR 0 3
25237: PPUSH
25238: LD_INT 3
25240: PUSH
25241: LD_INT 54
25243: PUSH
25244: EMPTY
25245: LIST
25246: PUSH
25247: EMPTY
25248: LIST
25249: LIST
25250: PPUSH
25251: CALL_OW 72
25255: IFFALSE 25275
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25257: LD_VAR 0 3
25261: PPUSH
25262: LD_VAR 0 11
25266: PUSH
25267: LD_INT 1
25269: ARRAY
25270: PPUSH
25271: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25275: LD_ADDR_VAR 0 3
25279: PUSH
25280: LD_EXP 18
25284: PUSH
25285: LD_INT 1
25287: ARRAY
25288: PUSH
25289: LD_EXP 18
25293: PUSH
25294: LD_INT 2
25296: ARRAY
25297: ADD
25298: PPUSH
25299: LD_INT 26
25301: PUSH
25302: LD_INT 1
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PPUSH
25309: CALL_OW 72
25313: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25314: LD_ADDR_VAR 0 1
25318: PUSH
25319: LD_EXP 18
25323: PUSH
25324: LD_INT 2
25326: ARRAY
25327: PUSH
25328: FOR_IN
25329: IFFALSE 25347
// ComTurnUnit ( i , Powell ) ;
25331: LD_VAR 0 1
25335: PPUSH
25336: LD_EXP 61
25340: PPUSH
25341: CALL_OW 119
25345: GO 25328
25347: POP
25348: POP
// Say ( Powell , D5-Pow-1 ) ;
25349: LD_EXP 61
25353: PPUSH
25354: LD_STRING D5-Pow-1
25356: PPUSH
25357: CALL_OW 88
// if tmp then
25361: LD_VAR 0 3
25365: IFFALSE 25383
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25367: LD_VAR 0 3
25371: PUSH
25372: LD_INT 1
25374: ARRAY
25375: PPUSH
25376: LD_STRING D5-Sol2-1
25378: PPUSH
25379: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25383: LD_EXP 61
25387: PPUSH
25388: LD_STRING D5-Pow-2
25390: PPUSH
25391: CALL_OW 88
// if tmp > 1 then
25395: LD_VAR 0 3
25399: PUSH
25400: LD_INT 1
25402: GREATER
25403: IFFALSE 25421
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25405: LD_VAR 0 3
25409: PUSH
25410: LD_INT 2
25412: ARRAY
25413: PPUSH
25414: LD_STRING D5-Sol2-2
25416: PPUSH
25417: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25421: LD_EXP 61
25425: PPUSH
25426: LD_STRING D5-Pow-3
25428: PPUSH
25429: CALL_OW 88
// wait ( 0 0$1 ) ;
25433: LD_INT 35
25435: PPUSH
25436: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25440: LD_ADDR_VAR 0 3
25444: PUSH
25445: LD_EXP 18
25449: PUSH
25450: LD_INT 1
25452: ARRAY
25453: PUSH
25454: LD_EXP 18
25458: PUSH
25459: LD_INT 2
25461: ARRAY
25462: UNION
25463: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25464: LD_VAR 0 3
25468: PPUSH
25469: LD_INT 80
25471: PPUSH
25472: LD_INT 67
25474: PPUSH
25475: CALL_OW 114
// wait ( 0 0$2 ) ;
25479: LD_INT 70
25481: PPUSH
25482: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25486: LD_INT 79
25488: PPUSH
25489: LD_INT 72
25491: PPUSH
25492: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25496: LD_INT 70
25498: PPUSH
25499: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25503: LD_VAR 0 3
25507: PPUSH
25508: LD_INT 3
25510: PUSH
25511: LD_INT 24
25513: PUSH
25514: LD_INT 1000
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: PPUSH
25525: CALL_OW 72
25529: IFFALSE 25496
// Say ( Powell , D5a-Pow-1 ) ;
25531: LD_EXP 61
25535: PPUSH
25536: LD_STRING D5a-Pow-1
25538: PPUSH
25539: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25543: LD_EXP 61
25547: PPUSH
25548: LD_STRING D5a-Pow-1a
25550: PPUSH
25551: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25555: LD_INT 24
25557: PPUSH
25558: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25562: LD_EXP 61
25566: PPUSH
25567: LD_STRING D5a-Pow-1b
25569: PPUSH
25570: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25574: LD_INT 10
25576: PPUSH
25577: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25581: LD_EXP 61
25585: PPUSH
25586: LD_STRING D5a-Pow-1c
25588: PPUSH
25589: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25593: LD_VAR 0 3
25597: PPUSH
25598: LD_INT 68
25600: PPUSH
25601: LD_INT 63
25603: PPUSH
25604: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25608: LD_INT 18
25610: PPUSH
25611: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25615: LD_EXP 61
25619: PPUSH
25620: LD_STRING D5a-Pow-1d
25622: PPUSH
25623: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25627: LD_INT 35
25629: PPUSH
25630: CALL_OW 67
// if not HasTask ( tmp ) then
25634: LD_VAR 0 3
25638: PPUSH
25639: CALL_OW 314
25643: NOT
25644: IFFALSE 25661
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25646: LD_VAR 0 3
25650: PPUSH
25651: LD_INT 68
25653: PPUSH
25654: LD_INT 63
25656: PPUSH
25657: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25661: LD_VAR 0 3
25665: PPUSH
25666: LD_INT 24
25668: PUSH
25669: LD_INT 1
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PPUSH
25676: CALL_OW 72
25680: NOT
25681: IFFALSE 25627
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25683: LD_ADDR_VAR 0 3
25687: PUSH
25688: LD_INT 22
25690: PUSH
25691: LD_INT 4
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 92
25700: PUSH
25701: LD_INT 60
25703: PUSH
25704: LD_INT 93
25706: PUSH
25707: LD_INT 10
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 3
25718: PUSH
25719: LD_INT 54
25721: PUSH
25722: EMPTY
25723: LIST
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: EMPTY
25730: LIST
25731: LIST
25732: LIST
25733: PPUSH
25734: CALL_OW 69
25738: PUSH
25739: LD_EXP 61
25743: DIFF
25744: ST_TO_ADDR
// if tmp then
25745: LD_VAR 0 3
25749: IFFALSE 25783
// for i in tmp do
25751: LD_ADDR_VAR 0 1
25755: PUSH
25756: LD_VAR 0 3
25760: PUSH
25761: FOR_IN
25762: IFFALSE 25781
// ComMoveXY ( i , 36 , 67 ) ;
25764: LD_VAR 0 1
25768: PPUSH
25769: LD_INT 36
25771: PPUSH
25772: LD_INT 67
25774: PPUSH
25775: CALL_OW 111
25779: GO 25761
25781: POP
25782: POP
// wait ( 0 0$3 ) ;
25783: LD_INT 105
25785: PPUSH
25786: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25790: LD_VAR 0 12
25794: PPUSH
25795: LD_STRING D6-Sol3-1
25797: PPUSH
25798: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25802: LD_EXP 61
25806: PPUSH
25807: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25811: LD_EXP 61
25815: PPUSH
25816: LD_STRING D6-Pow-1
25818: PPUSH
25819: CALL_OW 88
// tmp := [ ] ;
25823: LD_ADDR_VAR 0 3
25827: PUSH
25828: EMPTY
25829: ST_TO_ADDR
// for i = 1 to 2 do
25830: LD_ADDR_VAR 0 1
25834: PUSH
25835: DOUBLE
25836: LD_INT 1
25838: DEC
25839: ST_TO_ADDR
25840: LD_INT 2
25842: PUSH
25843: FOR_TO
25844: IFFALSE 25958
// begin uc_side := 8 ;
25846: LD_ADDR_OWVAR 20
25850: PUSH
25851: LD_INT 8
25853: ST_TO_ADDR
// uc_nation := 2 ;
25854: LD_ADDR_OWVAR 21
25858: PUSH
25859: LD_INT 2
25861: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25862: LD_INT 14
25864: PPUSH
25865: LD_INT 3
25867: PPUSH
25868: LD_INT 2
25870: PPUSH
25871: LD_INT 29
25873: PPUSH
25874: LD_INT 100
25876: PPUSH
25877: CALL 75233 0 5
// veh := CreateVehicle ;
25881: LD_ADDR_VAR 0 14
25885: PUSH
25886: CALL_OW 45
25890: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25891: LD_VAR 0 14
25895: PPUSH
25896: LD_INT 4
25898: PPUSH
25899: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25903: LD_VAR 0 14
25907: PPUSH
25908: LD_INT 99
25910: PPUSH
25911: LD_INT 83
25913: PPUSH
25914: LD_INT 3
25916: PPUSH
25917: LD_INT 0
25919: PPUSH
25920: CALL_OW 50
// wait ( 3 ) ;
25924: LD_INT 3
25926: PPUSH
25927: CALL_OW 67
// Connect ( veh ) ;
25931: LD_VAR 0 14
25935: PPUSH
25936: CALL 78701 0 1
// tmp := tmp ^ veh ;
25940: LD_ADDR_VAR 0 3
25944: PUSH
25945: LD_VAR 0 3
25949: PUSH
25950: LD_VAR 0 14
25954: ADD
25955: ST_TO_ADDR
// end ;
25956: GO 25843
25958: POP
25959: POP
// wait ( 0 0$1 ) ;
25960: LD_INT 35
25962: PPUSH
25963: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25967: LD_INT 99
25969: PPUSH
25970: LD_INT 83
25972: PPUSH
25973: LD_INT 1
25975: PPUSH
25976: LD_INT 10
25978: PPUSH
25979: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25983: LD_INT 99
25985: PPUSH
25986: LD_INT 83
25988: PPUSH
25989: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25993: LD_VAR 0 12
25997: PPUSH
25998: LD_STRING D6-Sol3-2
26000: PPUSH
26001: CALL_OW 88
// async ;
26005: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
26006: LD_EXP 61
26010: PPUSH
26011: LD_STRING D6-Pow-2
26013: PPUSH
26014: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
26018: LD_VAR 0 3
26022: PUSH
26023: LD_INT 1
26025: ARRAY
26026: PPUSH
26027: LD_VAR 0 10
26031: PPUSH
26032: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26036: LD_VAR 0 3
26040: PUSH
26041: LD_INT 2
26043: ARRAY
26044: PPUSH
26045: LD_INT 22
26047: PUSH
26048: LD_INT 4
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 21
26057: PUSH
26058: LD_INT 3
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PPUSH
26069: CALL_OW 69
26073: PPUSH
26074: LD_VAR 0 3
26078: PUSH
26079: LD_INT 2
26081: ARRAY
26082: PPUSH
26083: CALL_OW 74
26087: PPUSH
26088: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26092: LD_EXP 61
26096: PPUSH
26097: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26101: LD_INT 99
26103: PPUSH
26104: LD_INT 83
26106: PPUSH
26107: LD_INT 1
26109: PPUSH
26110: CALL_OW 331
// repeat wait ( 4 ) ;
26114: LD_INT 4
26116: PPUSH
26117: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26121: LD_VAR 0 3
26125: PUSH
26126: LD_INT 1
26128: ARRAY
26129: PPUSH
26130: CALL_OW 256
26134: PUSH
26135: LD_INT 1000
26137: LESS
26138: IFFALSE 26156
// SetLives ( tmp [ 1 ] , 1000 ) ;
26140: LD_VAR 0 3
26144: PUSH
26145: LD_INT 1
26147: ARRAY
26148: PPUSH
26149: LD_INT 1000
26151: PPUSH
26152: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26156: LD_INT 22
26158: PUSH
26159: LD_INT 4
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 30
26168: PUSH
26169: LD_INT 3
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PPUSH
26180: CALL_OW 69
26184: PUSH
26185: LD_INT 0
26187: EQUAL
26188: IFFALSE 26114
// skirmish := false ;
26190: LD_ADDR_EXP 100
26194: PUSH
26195: LD_INT 0
26197: ST_TO_ADDR
// sync ;
26198: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26199: LD_EXP 61
26203: PPUSH
26204: LD_STRING D6a-Pow-1
26206: PPUSH
26207: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26211: LD_VAR 0 12
26215: PPUSH
26216: LD_STRING D6a-Sol3-1
26218: PPUSH
26219: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26223: LD_EXP 61
26227: PPUSH
26228: LD_STRING D6a-Pow-2
26230: PPUSH
26231: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26235: LD_VAR 0 12
26239: PPUSH
26240: LD_STRING D6a-Sol3-2
26242: PPUSH
26243: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26247: LD_EXP 61
26251: PPUSH
26252: LD_STRING D6a-Pow-3
26254: PPUSH
26255: CALL_OW 88
// powellCenterCameraMode := true ;
26259: LD_ADDR_EXP 20
26263: PUSH
26264: LD_INT 1
26266: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26267: LD_ADDR_VAR 0 1
26271: PUSH
26272: LD_INT 22
26274: PUSH
26275: LD_INT 8
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 25
26284: PUSH
26285: LD_INT 2
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PPUSH
26296: CALL_OW 69
26300: PUSH
26301: FOR_IN
26302: IFFALSE 26357
// begin SetTag ( i , 1 ) ;
26304: LD_VAR 0 1
26308: PPUSH
26309: LD_INT 1
26311: PPUSH
26312: CALL_OW 109
// ComExitBuilding ( i ) ;
26316: LD_VAR 0 1
26320: PPUSH
26321: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26325: LD_VAR 0 1
26329: PPUSH
26330: LD_INT 35
26332: PPUSH
26333: LD_INT 6
26335: PPUSH
26336: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26340: LD_VAR 0 1
26344: PPUSH
26345: LD_INT 53
26347: PPUSH
26348: LD_INT 4
26350: PPUSH
26351: CALL_OW 171
// end ;
26355: GO 26301
26357: POP
26358: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26359: LD_ADDR_VAR 0 3
26363: PUSH
26364: LD_INT 22
26366: PUSH
26367: LD_INT 4
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 21
26376: PUSH
26377: LD_INT 2
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 3
26386: PUSH
26387: LD_INT 34
26389: PUSH
26390: LD_INT 12
26392: PUSH
26393: EMPTY
26394: LIST
26395: LIST
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: LIST
26405: PPUSH
26406: CALL_OW 69
26410: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26411: LD_EXP 61
26415: PPUSH
26416: LD_VAR 0 3
26420: PPUSH
26421: LD_EXP 61
26425: PPUSH
26426: CALL_OW 74
26430: PPUSH
26431: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26435: LD_EXP 61
26439: PPUSH
26440: LD_INT 100
26442: PPUSH
26443: LD_INT 88
26445: PPUSH
26446: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26450: LD_EXP 61
26454: PPUSH
26455: LD_INT 100
26457: PPUSH
26458: LD_INT 75
26460: PPUSH
26461: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26465: LD_EXP 61
26469: PPUSH
26470: LD_INT 88
26472: PPUSH
26473: LD_INT 53
26475: PPUSH
26476: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26480: LD_INT 8
26482: PPUSH
26483: LD_EXP 61
26487: PPUSH
26488: CALL_OW 471
// repeat wait ( 3 ) ;
26492: LD_INT 3
26494: PPUSH
26495: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26499: LD_INT 22
26501: PUSH
26502: LD_INT 4
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 92
26511: PUSH
26512: LD_INT 100
26514: PUSH
26515: LD_INT 75
26517: PUSH
26518: LD_INT 6
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PPUSH
26531: CALL_OW 69
26535: IFFALSE 26492
// async ;
26537: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26538: LD_EXP 61
26542: PPUSH
26543: LD_STRING D6b-Pow-1
26545: PPUSH
26546: CALL_OW 88
// repeat wait ( 3 ) ;
26550: LD_INT 3
26552: PPUSH
26553: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26557: LD_EXP 61
26561: PPUSH
26562: CALL_OW 310
26566: PPUSH
26567: CALL_OW 256
26571: PUSH
26572: LD_INT 1000
26574: LESS
26575: IFFALSE 26594
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26577: LD_EXP 61
26581: PPUSH
26582: CALL_OW 310
26586: PPUSH
26587: LD_INT 1000
26589: PPUSH
26590: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26594: LD_EXP 61
26598: PPUSH
26599: CALL_OW 256
26603: PUSH
26604: LD_INT 1000
26606: LESS
26607: IFFALSE 26621
// SetLives ( Powell , 1000 ) ;
26609: LD_EXP 61
26613: PPUSH
26614: LD_INT 1000
26616: PPUSH
26617: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26621: LD_EXP 61
26625: PPUSH
26626: LD_EXP 67
26630: PPUSH
26631: CALL_OW 296
26635: PUSH
26636: LD_INT 5
26638: LESS
26639: PUSH
26640: LD_EXP 61
26644: PPUSH
26645: CALL_OW 310
26649: PPUSH
26650: LD_EXP 67
26654: PPUSH
26655: CALL_OW 296
26659: PUSH
26660: LD_INT 5
26662: LESS
26663: OR
26664: IFFALSE 26683
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26666: LD_EXP 61
26670: PPUSH
26671: CALL_OW 310
26675: PPUSH
26676: LD_INT 100
26678: PPUSH
26679: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26683: LD_EXP 61
26687: PPUSH
26688: CALL_OW 310
26692: NOT
26693: IFFALSE 26550
// DoNotAttack ( 8 , powellBomb ) ;
26695: LD_INT 8
26697: PPUSH
26698: LD_EXP 67
26702: PPUSH
26703: CALL_OW 471
// game_speed := 4 ;
26707: LD_ADDR_OWVAR 65
26711: PUSH
26712: LD_INT 4
26714: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26715: LD_EXP 61
26719: PPUSH
26720: LD_STRING D6b-Pow-1a
26722: PPUSH
26723: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26727: LD_EXP 61
26731: PPUSH
26732: LD_EXP 67
26736: PPUSH
26737: CALL_OW 180
// sync ;
26741: SYNC
// repeat wait ( 0 0$1 ) ;
26742: LD_INT 35
26744: PPUSH
26745: CALL_OW 67
// until IsInUnit ( Powell ) ;
26749: LD_EXP 61
26753: PPUSH
26754: CALL_OW 310
26758: IFFALSE 26742
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26760: LD_INT 8
26762: PPUSH
26763: LD_EXP 61
26767: PPUSH
26768: CALL_OW 310
26772: PPUSH
26773: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26777: LD_EXP 61
26781: PPUSH
26782: LD_INT 91
26784: PPUSH
26785: LD_INT 44
26787: PPUSH
26788: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26792: LD_EXP 61
26796: PPUSH
26797: LD_INT 96
26799: PPUSH
26800: LD_INT 44
26802: PPUSH
26803: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26807: LD_EXP 61
26811: PPUSH
26812: LD_INT 96
26814: PPUSH
26815: LD_INT 41
26817: PPUSH
26818: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26822: LD_EXP 61
26826: PPUSH
26827: LD_INT 92
26829: PPUSH
26830: LD_INT 39
26832: PPUSH
26833: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26837: LD_EXP 61
26841: PPUSH
26842: LD_INT 88
26844: PPUSH
26845: LD_INT 41
26847: PPUSH
26848: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26852: LD_EXP 61
26856: PPUSH
26857: LD_INT 91
26859: PPUSH
26860: LD_INT 44
26862: PPUSH
26863: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26867: LD_EXP 61
26871: PPUSH
26872: LD_INT 96
26874: PPUSH
26875: LD_INT 44
26877: PPUSH
26878: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26882: LD_EXP 61
26886: PPUSH
26887: LD_INT 96
26889: PPUSH
26890: LD_INT 41
26892: PPUSH
26893: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26897: LD_EXP 61
26901: PPUSH
26902: LD_INT 92
26904: PPUSH
26905: LD_INT 39
26907: PPUSH
26908: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26912: LD_EXP 61
26916: PPUSH
26917: LD_INT 88
26919: PPUSH
26920: LD_INT 41
26922: PPUSH
26923: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26927: LD_EXP 61
26931: PPUSH
26932: LD_INT 91
26934: PPUSH
26935: LD_INT 44
26937: PPUSH
26938: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26942: LD_EXP 61
26946: PPUSH
26947: LD_INT 93
26949: PPUSH
26950: LD_INT 39
26952: PPUSH
26953: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26957: LD_EXP 61
26961: PPUSH
26962: LD_INT 93
26964: PPUSH
26965: LD_INT 36
26967: PPUSH
26968: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26972: LD_INT 122
26974: PPUSH
26975: CALL_OW 67
// game_speed := 4 ;
26979: LD_ADDR_OWVAR 65
26983: PUSH
26984: LD_INT 4
26986: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26987: LD_EXP 61
26991: PPUSH
26992: LD_STRING D6b-Pow-1b
26994: PPUSH
26995: CALL_OW 88
// tmp := [ ] ;
26999: LD_ADDR_VAR 0 3
27003: PUSH
27004: EMPTY
27005: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
27006: LD_ADDR_VAR 0 5
27010: PUSH
27011: LD_INT 78
27013: PUSH
27014: LD_INT 47
27016: PUSH
27017: EMPTY
27018: LIST
27019: LIST
27020: PUSH
27021: LD_INT 106
27023: PUSH
27024: LD_INT 53
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27035: LD_ADDR_VAR 0 1
27039: PUSH
27040: LD_INT 22
27042: PUSH
27043: LD_INT 8
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 21
27052: PUSH
27053: LD_INT 3
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 92
27062: PUSH
27063: LD_INT 90
27065: PUSH
27066: LD_INT 52
27068: PUSH
27069: LD_INT 12
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: LIST
27082: PPUSH
27083: CALL_OW 69
27087: PUSH
27088: FOR_IN
27089: IFFALSE 27114
// tmp := tmp ^ UnitsInside ( i ) ;
27091: LD_ADDR_VAR 0 3
27095: PUSH
27096: LD_VAR 0 3
27100: PUSH
27101: LD_VAR 0 1
27105: PPUSH
27106: CALL_OW 313
27110: ADD
27111: ST_TO_ADDR
27112: GO 27088
27114: POP
27115: POP
// for i in tmp do
27116: LD_ADDR_VAR 0 1
27120: PUSH
27121: LD_VAR 0 3
27125: PUSH
27126: FOR_IN
27127: IFFALSE 27289
// begin dist := 9999 ;
27129: LD_ADDR_VAR 0 9
27133: PUSH
27134: LD_INT 9999
27136: ST_TO_ADDR
// _xy := [ ] ;
27137: LD_ADDR_VAR 0 8
27141: PUSH
27142: EMPTY
27143: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27144: LD_VAR 0 1
27148: PPUSH
27149: LD_INT 1
27151: PPUSH
27152: CALL_OW 109
// ComExitBuilding ( i ) ;
27156: LD_VAR 0 1
27160: PPUSH
27161: CALL_OW 122
// for j in xy do
27165: LD_ADDR_VAR 0 2
27169: PUSH
27170: LD_VAR 0 5
27174: PUSH
27175: FOR_IN
27176: IFFALSE 27258
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27178: LD_VAR 0 1
27182: PPUSH
27183: LD_VAR 0 2
27187: PUSH
27188: LD_INT 1
27190: ARRAY
27191: PPUSH
27192: LD_VAR 0 2
27196: PUSH
27197: LD_INT 2
27199: ARRAY
27200: PPUSH
27201: CALL_OW 297
27205: PUSH
27206: LD_VAR 0 9
27210: LESS
27211: IFFALSE 27256
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27213: LD_ADDR_VAR 0 9
27217: PUSH
27218: LD_VAR 0 1
27222: PPUSH
27223: LD_VAR 0 2
27227: PUSH
27228: LD_INT 1
27230: ARRAY
27231: PPUSH
27232: LD_VAR 0 2
27236: PUSH
27237: LD_INT 2
27239: ARRAY
27240: PPUSH
27241: CALL_OW 297
27245: ST_TO_ADDR
// _xy := j ;
27246: LD_ADDR_VAR 0 8
27250: PUSH
27251: LD_VAR 0 2
27255: ST_TO_ADDR
// end ;
27256: GO 27175
27258: POP
27259: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27260: LD_VAR 0 1
27264: PPUSH
27265: LD_VAR 0 8
27269: PUSH
27270: LD_INT 1
27272: ARRAY
27273: PPUSH
27274: LD_VAR 0 8
27278: PUSH
27279: LD_INT 2
27281: ARRAY
27282: PPUSH
27283: CALL_OW 171
// end ;
27287: GO 27126
27289: POP
27290: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27291: LD_ADDR_VAR 0 4
27295: PUSH
27296: LD_VAR 0 3
27300: PPUSH
27301: LD_INT 26
27303: PUSH
27304: LD_INT 1
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: PUSH
27311: LD_INT 25
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PPUSH
27325: CALL_OW 72
27329: ST_TO_ADDR
// if tmp2 < 2 then
27330: LD_VAR 0 4
27334: PUSH
27335: LD_INT 2
27337: LESS
27338: IFFALSE 27407
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27340: LD_ADDR_VAR 0 4
27344: PUSH
27345: LD_INT 22
27347: PUSH
27348: LD_INT 8
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 26
27357: PUSH
27358: LD_INT 1
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: PUSH
27365: LD_INT 3
27367: PUSH
27368: LD_INT 25
27370: PUSH
27371: LD_INT 15
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: LIST
27386: PPUSH
27387: CALL_OW 69
27391: PUSH
27392: LD_EXP 64
27396: PUSH
27397: LD_EXP 65
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: DIFF
27406: ST_TO_ADDR
// if tmp2 then
27407: LD_VAR 0 4
27411: IFFALSE 27429
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27413: LD_VAR 0 4
27417: PUSH
27418: LD_INT 1
27420: ARRAY
27421: PPUSH
27422: LD_STRING D6b-ArSol1-1
27424: PPUSH
27425: CALL_OW 88
// async ;
27429: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27430: LD_EXP 61
27434: PPUSH
27435: LD_STRING D6b-Pow-2
27437: PPUSH
27438: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27442: LD_INT 18
27444: PPUSH
27445: CALL_OW 67
// if tmp2 > 1 then
27449: LD_VAR 0 4
27453: PUSH
27454: LD_INT 1
27456: GREATER
27457: IFFALSE 27475
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27459: LD_VAR 0 4
27463: PUSH
27464: LD_INT 2
27466: ARRAY
27467: PPUSH
27468: LD_STRING D6b-ArSol2-1
27470: PPUSH
27471: CALL_OW 88
// sync ;
27475: SYNC
// repeat wait ( 5 ) ;
27476: LD_INT 5
27478: PPUSH
27479: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27483: LD_INT 93
27485: PPUSH
27486: LD_INT 36
27488: PPUSH
27489: CALL_OW 428
27493: PPUSH
27494: CALL_OW 255
27498: PUSH
27499: LD_INT 4
27501: EQUAL
27502: IFFALSE 27476
// DialogueOn ;
27504: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27508: LD_INT 10
27510: PPUSH
27511: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27515: LD_EXP 61
27519: PPUSH
27520: LD_STRING D6b-Pow-2a
27522: PPUSH
27523: CALL_OW 88
// DialogueOff ;
27527: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27531: LD_EXP 61
27535: PPUSH
27536: CALL_OW 310
27540: PPUSH
27541: LD_INT 332
27543: PPUSH
27544: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27548: LD_INT 93
27550: PPUSH
27551: LD_INT 35
27553: PPUSH
27554: LD_INT 1
27556: PPUSH
27557: LD_INT 6
27559: NEG
27560: PPUSH
27561: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27565: LD_INT 35
27567: PPUSH
27568: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27572: LD_INT 332
27574: PPUSH
27575: CALL_OW 256
27579: PUSH
27580: LD_INT 1000
27582: LESS
27583: PUSH
27584: LD_INT 332
27586: PPUSH
27587: CALL_OW 300
27591: AND
27592: IFFALSE 27604
// SetLives ( kozlov_fac , 0 ) ;
27594: LD_INT 332
27596: PPUSH
27597: LD_INT 0
27599: PPUSH
27600: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27604: LD_INT 332
27606: PPUSH
27607: CALL_OW 301
27611: PUSH
27612: LD_EXP 61
27616: PPUSH
27617: CALL_OW 301
27621: OR
27622: IFFALSE 27565
// game_speed := 4 ;
27624: LD_ADDR_OWVAR 65
27628: PUSH
27629: LD_INT 4
27631: ST_TO_ADDR
// powellCenterCameraMode := false ;
27632: LD_ADDR_EXP 20
27636: PUSH
27637: LD_INT 0
27639: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27640: LD_ADDR_VAR 0 1
27644: PUSH
27645: LD_VAR 0 3
27649: PUSH
27650: LD_INT 22
27652: PUSH
27653: LD_INT 8
27655: PUSH
27656: EMPTY
27657: LIST
27658: LIST
27659: PUSH
27660: LD_INT 25
27662: PUSH
27663: LD_INT 2
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PPUSH
27674: CALL_OW 69
27678: UNION
27679: PUSH
27680: FOR_IN
27681: IFFALSE 27697
// SetTag ( i , 0 ) ;
27683: LD_VAR 0 1
27687: PPUSH
27688: LD_INT 0
27690: PPUSH
27691: CALL_OW 109
27695: GO 27680
27697: POP
27698: POP
// wait ( 0 0$3 ) ;
27699: LD_INT 105
27701: PPUSH
27702: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27706: LD_INT 93
27708: PPUSH
27709: LD_INT 35
27711: PPUSH
27712: LD_INT 1
27714: PPUSH
27715: CALL_OW 331
// DialogueOn ;
27719: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27723: LD_VAR 0 12
27727: PPUSH
27728: LD_STRING D6c-Sol3-1
27730: PPUSH
27731: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27735: LD_INT 10
27737: PPUSH
27738: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27742: LD_EXP 40
27746: PPUSH
27747: LD_STRING D6c-JMM-1
27749: PPUSH
27750: CALL_OW 88
// if Cyrus then
27754: LD_EXP 46
27758: IFFALSE 27772
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27760: LD_EXP 46
27764: PPUSH
27765: LD_STRING D6c-Cyrus-1
27767: PPUSH
27768: CALL_OW 88
// if Bobby then
27772: LD_EXP 45
27776: IFFALSE 27790
// Say ( Bobby , D6c-Bobby-1 ) ;
27778: LD_EXP 45
27782: PPUSH
27783: LD_STRING D6c-Bobby-1
27785: PPUSH
27786: CALL_OW 88
// if Cornel then
27790: LD_EXP 51
27794: IFFALSE 27808
// Say ( Cornel , D6c-Corn-1 ) ;
27796: LD_EXP 51
27800: PPUSH
27801: LD_STRING D6c-Corn-1
27803: PPUSH
27804: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27808: LD_ADDR_VAR 0 4
27812: PUSH
27813: LD_INT 2
27815: PUSH
27816: LD_INT 22
27818: PUSH
27819: LD_INT 1
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 22
27828: PUSH
27829: LD_INT 4
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 26
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: LD_INT 23
27853: PUSH
27854: LD_INT 1
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: LIST
27865: PPUSH
27866: CALL_OW 69
27870: PUSH
27871: LD_VAR 0 12
27875: PUSH
27876: LD_EXP 40
27880: UNION
27881: PUSH
27882: LD_EXP 62
27886: UNION
27887: DIFF
27888: ST_TO_ADDR
// if tmp2 then
27889: LD_VAR 0 4
27893: IFFALSE 27911
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27895: LD_VAR 0 4
27899: PUSH
27900: LD_INT 1
27902: ARRAY
27903: PPUSH
27904: LD_STRING D6c-Sol1-1
27906: PPUSH
27907: CALL_OW 88
// if Lisa then
27911: LD_EXP 43
27915: IFFALSE 27929
// Say ( Lisa , D6c-Lisa-1 ) ;
27917: LD_EXP 43
27921: PPUSH
27922: LD_STRING D6c-Lisa-1
27924: PPUSH
27925: CALL_OW 88
// if Gary then
27929: LD_EXP 52
27933: IFFALSE 27947
// Say ( Gary , D6c-Gary-1 ) ;
27935: LD_EXP 52
27939: PPUSH
27940: LD_STRING D6c-Gary-1
27942: PPUSH
27943: CALL_OW 88
// if Donaldson then
27947: LD_EXP 44
27951: IFFALSE 27965
// Say ( Donaldson , D6c-Don-1 ) ;
27953: LD_EXP 44
27957: PPUSH
27958: LD_STRING D6c-Don-1
27960: PPUSH
27961: CALL_OW 88
// if tmp2 > 1 then
27965: LD_VAR 0 4
27969: PUSH
27970: LD_INT 1
27972: GREATER
27973: IFFALSE 27991
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27975: LD_VAR 0 4
27979: PUSH
27980: LD_INT 2
27982: ARRAY
27983: PPUSH
27984: LD_STRING D6c-Sol2-1
27986: PPUSH
27987: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27991: LD_VAR 0 12
27995: PPUSH
27996: LD_STRING D6c-Sol3-2
27998: PPUSH
27999: CALL_OW 88
// if IsInUnit ( JMM ) then
28003: LD_EXP 40
28007: PPUSH
28008: CALL_OW 310
28012: IFFALSE 28030
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
28014: LD_EXP 40
28018: PPUSH
28019: CALL_OW 310
28023: PPUSH
28024: CALL_OW 87
28028: GO 28039
// CenterNowOnUnits ( JMM ) ;
28030: LD_EXP 40
28034: PPUSH
28035: CALL_OW 87
// dwait ( 0 0$2 ) ;
28039: LD_INT 70
28041: PPUSH
28042: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28046: LD_EXP 40
28050: PPUSH
28051: LD_STRING D6c-JMM-2
28053: PPUSH
28054: CALL_OW 88
// DialogueOff ;
28058: CALL_OW 7
// Video ( false ) ;
28062: LD_INT 0
28064: PPUSH
28065: CALL 108076 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28069: LD_INT 22
28071: PUSH
28072: LD_INT 4
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PPUSH
28079: CALL_OW 69
28083: PPUSH
28084: LD_INT 1
28086: PPUSH
28087: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28091: LD_INT 4
28093: PPUSH
28094: LD_INT 4
28096: PPUSH
28097: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28101: LD_ADDR_VAR 0 1
28105: PUSH
28106: LD_INT 4
28108: PPUSH
28109: LD_INT 1
28111: PPUSH
28112: LD_INT 2
28114: PPUSH
28115: CALL 70456 0 3
28119: PUSH
28120: FOR_IN
28121: IFFALSE 28158
// if GetTech ( i , 1 ) <> state_researched then
28123: LD_VAR 0 1
28127: PPUSH
28128: LD_INT 1
28130: PPUSH
28131: CALL_OW 321
28135: PUSH
28136: LD_INT 2
28138: NONEQUAL
28139: IFFALSE 28156
// SetTech ( i , 1 , state_researched ) ;
28141: LD_VAR 0 1
28145: PPUSH
28146: LD_INT 1
28148: PPUSH
28149: LD_INT 2
28151: PPUSH
28152: CALL_OW 322
28156: GO 28120
28158: POP
28159: POP
// missionStage := 6 ;
28160: LD_ADDR_EXP 15
28164: PUSH
28165: LD_INT 6
28167: ST_TO_ADDR
// activeAttacks := true ;
28168: LD_ADDR_EXP 16
28172: PUSH
28173: LD_INT 1
28175: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28176: LD_STRING M2
28178: PPUSH
28179: CALL_OW 337
// SaveForQuickRestart ;
28183: CALL_OW 22
// wait ( 0 0$40 ) ;
28187: LD_INT 1400
28189: PPUSH
28190: CALL_OW 67
// DialogueOn ;
28194: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28198: LD_EXP 66
28202: PPUSH
28203: LD_STRING D7-Friend-1
28205: PPUSH
28206: CALL 112179 0 2
// Say ( JMM , D7-JMM-1 ) ;
28210: LD_EXP 40
28214: PPUSH
28215: LD_STRING D7-JMM-1
28217: PPUSH
28218: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28222: LD_EXP 66
28226: PPUSH
28227: LD_STRING D7-Friend-2
28229: PPUSH
28230: CALL 112179 0 2
// Say ( JMM , D7-JMM-2 ) ;
28234: LD_EXP 40
28238: PPUSH
28239: LD_STRING D7-JMM-2
28241: PPUSH
28242: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28246: LD_EXP 66
28250: PPUSH
28251: LD_STRING D7-Friend-3
28253: PPUSH
28254: CALL 112179 0 2
// Say ( JMM , D7-JMM-3 ) ;
28258: LD_EXP 40
28262: PPUSH
28263: LD_STRING D7-JMM-3
28265: PPUSH
28266: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28270: LD_EXP 66
28274: PPUSH
28275: LD_STRING D7-Friend-4
28277: PPUSH
28278: CALL 112179 0 2
// Say ( JMM , D7-JMM-4 ) ;
28282: LD_EXP 40
28286: PPUSH
28287: LD_STRING D7-JMM-4
28289: PPUSH
28290: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28294: LD_EXP 66
28298: PPUSH
28299: LD_STRING D7-Friend-5
28301: PPUSH
28302: CALL 112179 0 2
// Say ( JMM , D7-JMM-5 ) ;
28306: LD_EXP 40
28310: PPUSH
28311: LD_STRING D7-JMM-5
28313: PPUSH
28314: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28318: LD_EXP 66
28322: PPUSH
28323: LD_STRING D7-Friend-6
28325: PPUSH
28326: CALL 112179 0 2
// Say ( JMM , D7-JMM-6 ) ;
28330: LD_EXP 40
28334: PPUSH
28335: LD_STRING D7-JMM-6
28337: PPUSH
28338: CALL_OW 88
// DialogueOff ;
28342: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28346: LD_STRING Mlegion
28348: PPUSH
28349: CALL_OW 337
// skirmish := true ;
28353: LD_ADDR_EXP 100
28357: PUSH
28358: LD_INT 1
28360: ST_TO_ADDR
// RebuildKozlovFactory ;
28361: CALL 5380 0 0
// end ;
28365: PPOPN 14
28367: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28368: LD_EXP 20
28372: PUSH
28373: LD_EXP 61
28377: PPUSH
28378: CALL_OW 300
28382: AND
28383: IFFALSE 28425
28385: GO 28387
28387: DISABLE
// begin enable ;
28388: ENABLE
// if IsInUnit ( Powell ) then
28389: LD_EXP 61
28393: PPUSH
28394: CALL_OW 310
28398: IFFALSE 28416
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28400: LD_EXP 61
28404: PPUSH
28405: CALL_OW 310
28409: PPUSH
28410: CALL_OW 85
28414: GO 28425
// CenterOnUnits ( Powell ) ;
28416: LD_EXP 61
28420: PPUSH
28421: CALL_OW 85
// end ;
28425: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28426: LD_INT 22
28428: PUSH
28429: LD_INT 8
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 34
28438: PUSH
28439: LD_INT 48
28441: PUSH
28442: EMPTY
28443: LIST
28444: LIST
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PPUSH
28450: CALL_OW 69
28454: IFFALSE 28728
28456: GO 28458
28458: DISABLE
28459: LD_INT 0
28461: PPUSH
28462: PPUSH
// begin if missionStage < 9 then
28463: LD_EXP 15
28467: PUSH
28468: LD_INT 9
28470: LESS
28471: IFFALSE 28481
// missionStage := 9 ;
28473: LD_ADDR_EXP 15
28477: PUSH
28478: LD_INT 9
28480: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28481: LD_ADDR_VAR 0 1
28485: PUSH
28486: LD_INT 22
28488: PUSH
28489: LD_INT 8
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 34
28498: PUSH
28499: LD_INT 48
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PPUSH
28510: CALL_OW 69
28514: PUSH
28515: LD_INT 1
28517: ARRAY
28518: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28519: LD_INT 175
28521: PPUSH
28522: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28526: LD_EXP 12
28530: PUSH
28531: LD_EXP 3
28535: PUSH
28536: LD_INT 0
28538: PUSH
28539: LD_INT 2
28541: PUSH
28542: EMPTY
28543: LIST
28544: LIST
28545: IN
28546: OR
28547: IFFALSE 28570
// target := [ 68 , 108 , 1 ] else
28549: LD_ADDR_VAR 0 2
28553: PUSH
28554: LD_INT 68
28556: PUSH
28557: LD_INT 108
28559: PUSH
28560: LD_INT 1
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: LIST
28567: ST_TO_ADDR
28568: GO 28589
// target := [ 181 , 88 , 2 ] ;
28570: LD_ADDR_VAR 0 2
28574: PUSH
28575: LD_INT 181
28577: PUSH
28578: LD_INT 88
28580: PUSH
28581: LD_INT 2
28583: PUSH
28584: EMPTY
28585: LIST
28586: LIST
28587: LIST
28588: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28589: LD_VAR 0 1
28593: PPUSH
28594: LD_VAR 0 2
28598: PUSH
28599: LD_INT 1
28601: ARRAY
28602: PPUSH
28603: LD_VAR 0 2
28607: PUSH
28608: LD_INT 2
28610: ARRAY
28611: PPUSH
28612: CALL_OW 176
// if target [ 3 ] = 1 then
28616: LD_VAR 0 2
28620: PUSH
28621: LD_INT 3
28623: ARRAY
28624: PUSH
28625: LD_INT 1
28627: EQUAL
28628: IFFALSE 28644
// SayRadio ( Kurt , D12-Kurt-1 ) else
28630: LD_EXP 64
28634: PPUSH
28635: LD_STRING D12-Kurt-1
28637: PPUSH
28638: CALL_OW 94
28642: GO 28668
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28644: LD_EXP 64
28648: PPUSH
28649: LD_STRING D12a-Kurt-1
28651: PPUSH
28652: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28656: LD_EXP 79
28660: PPUSH
28661: LD_STRING D12a-Roth-1
28663: PPUSH
28664: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28668: LD_INT 350
28670: PPUSH
28671: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28675: LD_VAR 0 1
28679: PPUSH
28680: LD_INT 22
28682: PUSH
28683: LD_INT 8
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 23
28692: PUSH
28693: LD_INT 2
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 30
28702: PUSH
28703: LD_INT 3
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: LIST
28714: PPUSH
28715: CALL_OW 69
28719: PUSH
28720: LD_INT 1
28722: ARRAY
28723: PPUSH
28724: CALL_OW 228
// end ;
28728: PPOPN 2
28730: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28731: LD_EXP 64
28735: PPUSH
28736: CALL_OW 256
28740: PUSH
28741: LD_INT 999
28743: LESS
28744: PUSH
28745: LD_INT 22
28747: PUSH
28748: LD_INT 8
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 21
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 23
28767: PUSH
28768: LD_INT 2
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: LIST
28779: PPUSH
28780: CALL_OW 69
28784: PUSH
28785: LD_INT 9
28787: PUSH
28788: LD_INT 8
28790: PUSH
28791: LD_INT 7
28793: PUSH
28794: LD_INT 6
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: PUSH
28803: LD_OWVAR 67
28807: ARRAY
28808: LESSEQUAL
28809: OR
28810: PUSH
28811: LD_INT 22
28813: PUSH
28814: LD_INT 8
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 34
28823: PUSH
28824: LD_INT 48
28826: PUSH
28827: EMPTY
28828: LIST
28829: LIST
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PPUSH
28835: CALL_OW 69
28839: NOT
28840: AND
28841: PUSH
28842: LD_EXP 64
28846: PPUSH
28847: CALL_OW 302
28851: AND
28852: PUSH
28853: LD_INT 5
28855: PPUSH
28856: LD_INT 22
28858: PUSH
28859: LD_INT 1
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PPUSH
28866: CALL_OW 70
28870: AND
28871: IFFALSE 29633
28873: GO 28875
28875: DISABLE
28876: LD_INT 0
28878: PPUSH
28879: PPUSH
28880: PPUSH
// begin legionDestroyed := true ;
28881: LD_ADDR_EXP 22
28885: PUSH
28886: LD_INT 1
28888: ST_TO_ADDR
// DialogueOn ;
28889: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28893: LD_EXP 40
28897: PPUSH
28898: LD_STRING D13-JMM-1
28900: PPUSH
28901: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28905: LD_EXP 64
28909: PPUSH
28910: LD_STRING D13-Kurt-1
28912: PPUSH
28913: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28917: LD_EXP 40
28921: PPUSH
28922: LD_STRING D13-JMM-2
28924: PPUSH
28925: CALL_OW 88
// if FakeInfo then
28929: LD_EXP 12
28933: IFFALSE 28953
// begin Say ( Kurt , D13-Kurt-2 ) ;
28935: LD_EXP 64
28939: PPUSH
28940: LD_STRING D13-Kurt-2
28942: PPUSH
28943: CALL_OW 88
// DialogueOff ;
28947: CALL_OW 7
// exit ;
28951: GO 29633
// end ; if not KurtStatus then
28953: LD_EXP 3
28957: NOT
28958: IFFALSE 28974
// Say ( Kurt , D13-Kurt-2b ) else
28960: LD_EXP 64
28964: PPUSH
28965: LD_STRING D13-Kurt-2b
28967: PPUSH
28968: CALL_OW 88
28972: GO 28986
// Say ( Kurt , D13-Kurt-2a ) ;
28974: LD_EXP 64
28978: PPUSH
28979: LD_STRING D13-Kurt-2a
28981: PPUSH
28982: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28986: LD_EXP 40
28990: PPUSH
28991: LD_STRING D13-JMM-3
28993: PPUSH
28994: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28998: LD_EXP 64
29002: PPUSH
29003: LD_STRING D13-Kurt-3
29005: PPUSH
29006: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
29010: LD_EXP 40
29014: PPUSH
29015: LD_STRING D13-JMM-4
29017: PPUSH
29018: CALL_OW 88
// DialogueOff ;
29022: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29026: LD_STRING MlegionOut
29028: PPUSH
29029: CALL_OW 337
// MC_Kill ( 3 ) ;
29033: LD_INT 3
29035: PPUSH
29036: CALL 39858 0 1
// KillUnit ( Kozlov ) ;
29040: LD_EXP 65
29044: PPUSH
29045: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29049: LD_ADDR_VAR 0 1
29053: PUSH
29054: LD_INT 22
29056: PUSH
29057: LD_INT 8
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 23
29066: PUSH
29067: LD_INT 3
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 3
29076: PUSH
29077: LD_INT 21
29079: PUSH
29080: LD_INT 33
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: LIST
29095: PPUSH
29096: CALL_OW 69
29100: PUSH
29101: FOR_IN
29102: IFFALSE 29115
// KillUnit ( i ) ;
29104: LD_VAR 0 1
29108: PPUSH
29109: CALL_OW 66
29113: GO 29101
29115: POP
29116: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29117: LD_ADDR_VAR 0 1
29121: PUSH
29122: LD_INT 22
29124: PUSH
29125: LD_INT 8
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 21
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PPUSH
29146: CALL_OW 69
29150: PUSH
29151: FOR_IN
29152: IFFALSE 29165
// KillUnit ( i ) ;
29154: LD_VAR 0 1
29158: PPUSH
29159: CALL_OW 66
29163: GO 29151
29165: POP
29166: POP
// wait ( 0 0$0.6 ) ;
29167: LD_INT 21
29169: PPUSH
29170: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29174: LD_INT 8
29176: PPUSH
29177: LD_INT 1
29179: PPUSH
29180: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29184: LD_ADDR_VAR 0 2
29188: PUSH
29189: LD_INT 22
29191: PUSH
29192: LD_INT 8
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 21
29201: PUSH
29202: LD_INT 1
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PPUSH
29213: CALL_OW 69
29217: PUSH
29218: LD_EXP 65
29222: PUSH
29223: LD_EXP 64
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: DIFF
29232: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29233: LD_VAR 0 2
29237: PUSH
29238: LD_INT 6
29240: PUSH
29241: LD_INT 5
29243: PUSH
29244: LD_INT 4
29246: PUSH
29247: LD_INT 3
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: PUSH
29256: LD_OWVAR 67
29260: ARRAY
29261: GREATEREQUAL
29262: IFFALSE 29414
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29264: LD_ADDR_VAR 0 3
29268: PUSH
29269: LD_INT 6
29271: PUSH
29272: LD_INT 5
29274: PUSH
29275: LD_INT 4
29277: PUSH
29278: LD_INT 3
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: PUSH
29287: LD_OWVAR 67
29291: ARRAY
29292: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29293: LD_ADDR_VAR 0 1
29297: PUSH
29298: DOUBLE
29299: LD_VAR 0 2
29303: PUSH
29304: LD_VAR 0 3
29308: PUSH
29309: LD_INT 1
29311: PLUS
29312: MINUS
29313: INC
29314: ST_TO_ADDR
29315: LD_INT 1
29317: PUSH
29318: FOR_DOWNTO
29319: IFFALSE 29410
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29321: LD_ADDR_EXP 38
29325: PUSH
29326: LD_EXP 38
29330: PUSH
29331: LD_VAR 0 2
29335: PUSH
29336: LD_VAR 0 1
29340: ARRAY
29341: ADD
29342: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29343: LD_VAR 0 2
29347: PUSH
29348: LD_VAR 0 1
29352: ARRAY
29353: PPUSH
29354: CALL_OW 310
29358: IFFALSE 29375
// ComExit ( tmp [ i ] ) ;
29360: LD_VAR 0 2
29364: PUSH
29365: LD_VAR 0 1
29369: ARRAY
29370: PPUSH
29371: CALL 108502 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29375: LD_VAR 0 2
29379: PUSH
29380: LD_VAR 0 1
29384: ARRAY
29385: PPUSH
29386: LD_INT 34
29388: PUSH
29389: LD_INT 0
29391: PPUSH
29392: LD_INT 6
29394: PPUSH
29395: CALL_OW 12
29399: PLUS
29400: PPUSH
29401: LD_INT 1
29403: PPUSH
29404: CALL_OW 171
// end ;
29408: GO 29318
29410: POP
29411: POP
// end else
29412: GO 29424
// x := tmp ;
29414: LD_ADDR_VAR 0 3
29418: PUSH
29419: LD_VAR 0 2
29423: ST_TO_ADDR
// for i := tmp downto tmp - x do
29424: LD_ADDR_VAR 0 1
29428: PUSH
29429: DOUBLE
29430: LD_VAR 0 2
29434: INC
29435: ST_TO_ADDR
29436: LD_VAR 0 2
29440: PUSH
29441: LD_VAR 0 3
29445: MINUS
29446: PUSH
29447: FOR_DOWNTO
29448: IFFALSE 29520
// begin if IsInUnit ( tmp [ i ] ) then
29450: LD_VAR 0 2
29454: PUSH
29455: LD_VAR 0 1
29459: ARRAY
29460: PPUSH
29461: CALL_OW 310
29465: IFFALSE 29482
// ComExit ( tmp [ i ] ) ;
29467: LD_VAR 0 2
29471: PUSH
29472: LD_VAR 0 1
29476: ARRAY
29477: PPUSH
29478: CALL 108502 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29482: LD_VAR 0 2
29486: PUSH
29487: LD_VAR 0 1
29491: ARRAY
29492: PPUSH
29493: LD_INT 1
29495: PPUSH
29496: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29500: LD_VAR 0 2
29504: PUSH
29505: LD_VAR 0 1
29509: ARRAY
29510: PPUSH
29511: LD_INT 1000
29513: PPUSH
29514: CALL_OW 234
// end ;
29518: GO 29447
29520: POP
29521: POP
// SetSide ( Kurt , 1 ) ;
29522: LD_EXP 64
29526: PPUSH
29527: LD_INT 1
29529: PPUSH
29530: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29534: LD_INT 22
29536: PUSH
29537: LD_INT 8
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 21
29546: PUSH
29547: LD_INT 3
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PPUSH
29558: CALL_OW 69
29562: PPUSH
29563: LD_INT 1
29565: PPUSH
29566: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29570: LD_INT 8
29572: PPUSH
29573: LD_INT 1
29575: PPUSH
29576: LD_INT 1
29578: PPUSH
29579: LD_INT 1
29581: PPUSH
29582: CALL_OW 80
// wait ( 1 1$20 ) ;
29586: LD_INT 2800
29588: PPUSH
29589: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29593: LD_EXP 66
29597: PPUSH
29598: LD_INT 37
29600: PPUSH
29601: LD_INT 1
29603: PPUSH
29604: LD_INT 0
29606: PPUSH
29607: CALL_OW 48
// wait ( 0 0$1 ) ;
29611: LD_INT 35
29613: PPUSH
29614: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29618: LD_EXP 66
29622: PPUSH
29623: LD_INT 60
29625: PPUSH
29626: LD_INT 95
29628: PPUSH
29629: CALL_OW 111
// end ;
29633: PPOPN 3
29635: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29636: LD_EXP 22
29640: NOT
29641: PUSH
29642: LD_INT 22
29644: PUSH
29645: LD_INT 8
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 21
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PPUSH
29666: CALL_OW 69
29670: PUSH
29671: LD_INT 0
29673: EQUAL
29674: AND
29675: IFFALSE 29695
29677: GO 29679
29679: DISABLE
// begin legionDestroyed := true ;
29680: LD_ADDR_EXP 22
29684: PUSH
29685: LD_INT 1
29687: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29688: LD_STRING MlegionOut
29690: PPUSH
29691: CALL_OW 337
// end ;
29695: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29696: LD_EXP 38
29700: IFFALSE 29775
29702: GO 29704
29704: DISABLE
29705: LD_INT 0
29707: PPUSH
// begin enable ;
29708: ENABLE
// for i in legionEscapeUnits do
29709: LD_ADDR_VAR 0 1
29713: PUSH
29714: LD_EXP 38
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29773
// begin if IsInArea ( i , legionEscapeArea ) then
29722: LD_VAR 0 1
29726: PPUSH
29727: LD_INT 31
29729: PPUSH
29730: CALL_OW 308
29734: IFFALSE 29747
// RemoveUnit ( i ) else
29736: LD_VAR 0 1
29740: PPUSH
29741: CALL_OW 64
29745: GO 29771
// if not HasTask ( i ) then
29747: LD_VAR 0 1
29751: PPUSH
29752: CALL_OW 314
29756: NOT
29757: IFFALSE 29771
// ComMoveToArea ( i , legionEscapeArea ) ;
29759: LD_VAR 0 1
29763: PPUSH
29764: LD_INT 31
29766: PPUSH
29767: CALL_OW 113
// end ;
29771: GO 29719
29773: POP
29774: POP
// end ;
29775: PPOPN 1
29777: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29778: LD_INT 1
29780: PPUSH
29781: LD_EXP 66
29785: PPUSH
29786: CALL_OW 292
29790: IFFALSE 30088
29792: GO 29794
29794: DISABLE
29795: LD_INT 0
29797: PPUSH
// begin wait ( 0 0$2 ) ;
29798: LD_INT 70
29800: PPUSH
29801: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29805: LD_EXP 66
29809: PPUSH
29810: CALL_OW 87
// DialogueOn ;
29814: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29818: LD_EXP 40
29822: PPUSH
29823: LD_STRING D14-JMM-1
29825: PPUSH
29826: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29830: LD_EXP 66
29834: PPUSH
29835: LD_STRING D14-Friend-1
29837: PPUSH
29838: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29842: LD_EXP 40
29846: PPUSH
29847: LD_STRING D14-JMM-2
29849: PPUSH
29850: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29854: LD_EXP 66
29858: PPUSH
29859: LD_STRING D14-Friend-2
29861: PPUSH
29862: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29866: LD_EXP 40
29870: PPUSH
29871: LD_STRING D14-JMM-3
29873: PPUSH
29874: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29878: LD_EXP 66
29882: PPUSH
29883: LD_STRING D14-Friend-3
29885: PPUSH
29886: CALL_OW 88
// DialogueOff ;
29890: CALL_OW 7
// dec := Query ( Q14 ) ;
29894: LD_ADDR_VAR 0 1
29898: PUSH
29899: LD_STRING Q14
29901: PPUSH
29902: CALL_OW 97
29906: ST_TO_ADDR
// if dec = 1 then
29907: LD_VAR 0 1
29911: PUSH
29912: LD_INT 1
29914: EQUAL
29915: IFFALSE 29949
// begin DialogueOn ;
29917: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29921: LD_EXP 40
29925: PPUSH
29926: LD_STRING D14a-JMM-1
29928: PPUSH
29929: CALL_OW 88
// DialogueOff ;
29933: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29937: LD_EXP 66
29941: PPUSH
29942: LD_INT 1
29944: PPUSH
29945: CALL_OW 235
// end ; if dec = 2 then
29949: LD_VAR 0 1
29953: PUSH
29954: LD_INT 2
29956: EQUAL
29957: IFFALSE 30010
// begin DialogueOn ;
29959: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29963: LD_EXP 40
29967: PPUSH
29968: LD_STRING D14b-JMM-1
29970: PPUSH
29971: CALL_OW 88
// DialogueOff ;
29975: CALL_OW 7
// wait ( 0 0$1 ) ;
29979: LD_INT 35
29981: PPUSH
29982: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29986: LD_EXP 66
29990: PPUSH
29991: LD_INT 9
29993: PPUSH
29994: LD_INT 2
29996: PPUSH
29997: CALL_OW 111
// AddComHold ( Friend ) ;
30001: LD_EXP 66
30005: PPUSH
30006: CALL_OW 200
// end ; if dec = 3 then
30010: LD_VAR 0 1
30014: PUSH
30015: LD_INT 3
30017: EQUAL
30018: IFFALSE 30088
// begin DialogueOn ;
30020: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30024: LD_EXP 40
30028: PPUSH
30029: LD_STRING D14c-JMM-1
30031: PPUSH
30032: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30036: LD_EXP 66
30040: PPUSH
30041: LD_STRING D14c-Friend-1
30043: PPUSH
30044: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30048: LD_EXP 40
30052: PPUSH
30053: LD_STRING D14c-JMM-2
30055: PPUSH
30056: CALL_OW 88
// DialogueOff ;
30060: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30064: LD_EXP 66
30068: PPUSH
30069: LD_INT 9
30071: PPUSH
30072: LD_INT 2
30074: PPUSH
30075: CALL_OW 111
// AddComHold ( Friend ) ;
30079: LD_EXP 66
30083: PPUSH
30084: CALL_OW 200
// end ; end ;
30088: PPOPN 1
30090: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30091: LD_INT 9
30093: PPUSH
30094: LD_INT 2
30096: PPUSH
30097: CALL_OW 428
30101: PUSH
30102: LD_EXP 66
30106: EQUAL
30107: PUSH
30108: LD_EXP 66
30112: PPUSH
30113: CALL_OW 255
30117: PUSH
30118: LD_INT 8
30120: EQUAL
30121: AND
30122: IFFALSE 30136
30124: GO 30126
30126: DISABLE
// RemoveUnit ( Friend ) ;
30127: LD_EXP 66
30131: PPUSH
30132: CALL_OW 64
30136: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30137: LD_EXP 14
30141: PUSH
30142: LD_INT 31500
30144: GREATEREQUAL
30145: PUSH
30146: LD_EXP 7
30150: AND
30151: PUSH
30152: LD_EXP 2
30156: AND
30157: IFFALSE 30603
30159: GO 30161
30161: DISABLE
30162: LD_INT 0
30164: PPUSH
30165: PPUSH
30166: PPUSH
// begin missionStage := 7 ;
30167: LD_ADDR_EXP 15
30171: PUSH
30172: LD_INT 7
30174: ST_TO_ADDR
// for i := 1 to 5 do
30175: LD_ADDR_VAR 0 1
30179: PUSH
30180: DOUBLE
30181: LD_INT 1
30183: DEC
30184: ST_TO_ADDR
30185: LD_INT 5
30187: PUSH
30188: FOR_TO
30189: IFFALSE 30301
// begin uc_side = 1 ;
30191: LD_ADDR_OWVAR 20
30195: PUSH
30196: LD_INT 1
30198: ST_TO_ADDR
// uc_nation = 1 ;
30199: LD_ADDR_OWVAR 21
30203: PUSH
30204: LD_INT 1
30206: ST_TO_ADDR
// vc_engine = engine_siberite ;
30207: LD_ADDR_OWVAR 39
30211: PUSH
30212: LD_INT 3
30214: ST_TO_ADDR
// vc_control = control_computer ;
30215: LD_ADDR_OWVAR 38
30219: PUSH
30220: LD_INT 3
30222: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30223: LD_ADDR_OWVAR 37
30227: PUSH
30228: LD_INT 3
30230: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30231: LD_ADDR_OWVAR 40
30235: PUSH
30236: LD_INT 5
30238: PUSH
30239: LD_INT 9
30241: PUSH
30242: LD_INT 7
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PPUSH
30253: LD_INT 3
30255: PPUSH
30256: CALL_OW 12
30260: ARRAY
30261: ST_TO_ADDR
// veh = CreateVehicle ;
30262: LD_ADDR_VAR 0 2
30266: PUSH
30267: CALL_OW 45
30271: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30272: LD_VAR 0 2
30276: PPUSH
30277: LD_INT 1
30279: PPUSH
30280: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30284: LD_VAR 0 2
30288: PPUSH
30289: LD_INT 19
30291: PPUSH
30292: LD_INT 0
30294: PPUSH
30295: CALL_OW 49
// end ;
30299: GO 30188
30301: POP
30302: POP
// uc_side = 1 ;
30303: LD_ADDR_OWVAR 20
30307: PUSH
30308: LD_INT 1
30310: ST_TO_ADDR
// uc_nation = 1 ;
30311: LD_ADDR_OWVAR 21
30315: PUSH
30316: LD_INT 1
30318: ST_TO_ADDR
// vc_engine = 3 ;
30319: LD_ADDR_OWVAR 39
30323: PUSH
30324: LD_INT 3
30326: ST_TO_ADDR
// vc_control = 1 ;
30327: LD_ADDR_OWVAR 38
30331: PUSH
30332: LD_INT 1
30334: ST_TO_ADDR
// vc_chassis = 3 ;
30335: LD_ADDR_OWVAR 37
30339: PUSH
30340: LD_INT 3
30342: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30343: LD_ADDR_OWVAR 40
30347: PUSH
30348: LD_INT 5
30350: PUSH
30351: LD_INT 9
30353: PUSH
30354: LD_INT 7
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PPUSH
30365: LD_INT 3
30367: PPUSH
30368: CALL_OW 12
30372: ARRAY
30373: ST_TO_ADDR
// vehG = CreateVehicle ;
30374: LD_ADDR_VAR 0 3
30378: PUSH
30379: CALL_OW 45
30383: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30384: LD_VAR 0 3
30388: PPUSH
30389: LD_INT 1
30391: PPUSH
30392: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30396: LD_VAR 0 3
30400: PPUSH
30401: LD_INT 19
30403: PPUSH
30404: LD_INT 0
30406: PPUSH
30407: CALL_OW 49
// if JMMGirl = 1 then
30411: LD_EXP 7
30415: PUSH
30416: LD_INT 1
30418: EQUAL
30419: IFFALSE 30475
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30421: LD_ADDR_EXP 41
30425: PUSH
30426: LD_STRING Joan
30428: PPUSH
30429: LD_INT 1
30431: PPUSH
30432: LD_STRING 14_
30434: PPUSH
30435: CALL 70309 0 3
30439: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30440: LD_EXP 41
30444: PPUSH
30445: LD_VAR 0 3
30449: PPUSH
30450: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30454: LD_VAR 0 3
30458: PPUSH
30459: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30463: LD_EXP 41
30467: PPUSH
30468: LD_STRING D10BW-Joan-1
30470: PPUSH
30471: CALL_OW 94
// end ; if JMMGirl = 2 then
30475: LD_EXP 7
30479: PUSH
30480: LD_INT 2
30482: EQUAL
30483: IFFALSE 30539
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30485: LD_ADDR_EXP 43
30489: PUSH
30490: LD_STRING Lisa
30492: PPUSH
30493: LD_INT 1
30495: PPUSH
30496: LD_STRING 14_
30498: PPUSH
30499: CALL 70309 0 3
30503: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30504: LD_EXP 43
30508: PPUSH
30509: LD_VAR 0 3
30513: PPUSH
30514: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30518: LD_VAR 0 3
30522: PPUSH
30523: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30527: LD_EXP 43
30531: PPUSH
30532: LD_STRING D10BW-Lisa-1
30534: PPUSH
30535: CALL_OW 94
// end ; if JMMGirl = 3 then
30539: LD_EXP 7
30543: PUSH
30544: LD_INT 3
30546: EQUAL
30547: IFFALSE 30603
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30549: LD_ADDR_EXP 55
30553: PUSH
30554: LD_STRING Connie
30556: PPUSH
30557: LD_INT 1
30559: PPUSH
30560: LD_STRING 14_
30562: PPUSH
30563: CALL 70309 0 3
30567: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30568: LD_EXP 55
30572: PPUSH
30573: LD_VAR 0 3
30577: PPUSH
30578: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30582: LD_VAR 0 3
30586: PPUSH
30587: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30591: LD_EXP 55
30595: PPUSH
30596: LD_STRING D10BW-Con-1
30598: PPUSH
30599: CALL_OW 94
// end ; end ;
30603: PPOPN 3
30605: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30606: LD_EXP 14
30610: PUSH
30611: LD_INT 94500
30613: GREATEREQUAL
30614: IFFALSE 31026
30616: GO 30618
30618: DISABLE
30619: LD_INT 0
30621: PPUSH
30622: PPUSH
30623: PPUSH
// begin tmp := PrepareStevensSquad ;
30624: LD_ADDR_VAR 0 3
30628: PUSH
30629: CALL 2378 0 0
30633: ST_TO_ADDR
// if not tmp then
30634: LD_VAR 0 3
30638: NOT
30639: IFFALSE 30643
// exit ;
30641: GO 31026
// uc_side := 1 ;
30643: LD_ADDR_OWVAR 20
30647: PUSH
30648: LD_INT 1
30650: ST_TO_ADDR
// uc_nation := 1 ;
30651: LD_ADDR_OWVAR 21
30655: PUSH
30656: LD_INT 1
30658: ST_TO_ADDR
// for i in tmp do
30659: LD_ADDR_VAR 0 1
30663: PUSH
30664: LD_VAR 0 3
30668: PUSH
30669: FOR_IN
30670: IFFALSE 30767
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30672: LD_INT 3
30674: PPUSH
30675: LD_INT 3
30677: PPUSH
30678: LD_INT 1
30680: PPUSH
30681: LD_INT 5
30683: PUSH
30684: LD_INT 9
30686: PUSH
30687: LD_INT 7
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: PPUSH
30698: LD_INT 3
30700: PPUSH
30701: CALL_OW 12
30705: ARRAY
30706: PPUSH
30707: LD_INT 40
30709: PPUSH
30710: CALL 75233 0 5
// veh := CreateVehicle ;
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: CALL_OW 45
30723: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30724: LD_VAR 0 2
30728: PPUSH
30729: LD_INT 1
30731: PPUSH
30732: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30736: LD_VAR 0 2
30740: PPUSH
30741: LD_INT 19
30743: PPUSH
30744: LD_INT 0
30746: PPUSH
30747: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30751: LD_VAR 0 1
30755: PPUSH
30756: LD_VAR 0 2
30760: PPUSH
30761: CALL_OW 52
// end ;
30765: GO 30669
30767: POP
30768: POP
// missionStage := 8 ;
30769: LD_ADDR_EXP 15
30773: PUSH
30774: LD_INT 8
30776: ST_TO_ADDR
// DialogueOn ;
30777: CALL_OW 6
// if Stevens then
30781: LD_EXP 42
30785: IFFALSE 30899
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30787: LD_EXP 42
30791: PPUSH
30792: CALL_OW 310
30796: PPUSH
30797: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30801: LD_EXP 42
30805: PPUSH
30806: LD_STRING D8-Huck-1
30808: PPUSH
30809: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30813: LD_EXP 40
30817: PPUSH
30818: LD_STRING D8-JMM-1
30820: PPUSH
30821: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30825: LD_EXP 42
30829: PPUSH
30830: LD_STRING D8-Huck-2
30832: PPUSH
30833: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30837: LD_EXP 40
30841: PPUSH
30842: LD_STRING D8-JMM-2
30844: PPUSH
30845: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30849: LD_EXP 42
30853: PPUSH
30854: LD_STRING D8-Huck-3
30856: PPUSH
30857: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30861: LD_EXP 40
30865: PPUSH
30866: LD_STRING D8-JMM-3
30868: PPUSH
30869: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30873: LD_EXP 42
30877: PPUSH
30878: LD_STRING D8-Huck-4
30880: PPUSH
30881: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30885: LD_EXP 40
30889: PPUSH
30890: LD_STRING D8-JMM-4
30892: PPUSH
30893: CALL_OW 88
// end else
30897: GO 31009
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30899: LD_EXP 56
30903: PPUSH
30904: CALL_OW 310
30908: PPUSH
30909: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30913: LD_EXP 56
30917: PPUSH
30918: LD_STRING D8-Huck-1
30920: PPUSH
30921: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30925: LD_EXP 40
30929: PPUSH
30930: LD_STRING D8-JMM-1a
30932: PPUSH
30933: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30937: LD_EXP 56
30941: PPUSH
30942: LD_STRING D8-Huck-2
30944: PPUSH
30945: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30949: LD_EXP 40
30953: PPUSH
30954: LD_STRING D8-JMM-2
30956: PPUSH
30957: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30961: LD_EXP 56
30965: PPUSH
30966: LD_STRING D8-Huck-3
30968: PPUSH
30969: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30973: LD_EXP 40
30977: PPUSH
30978: LD_STRING D8-JMM-3
30980: PPUSH
30981: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30985: LD_EXP 56
30989: PPUSH
30990: LD_STRING D8-Huck-4
30992: PPUSH
30993: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30997: LD_EXP 40
31001: PPUSH
31002: LD_STRING D8-JMM-4
31004: PPUSH
31005: CALL_OW 88
// end ; DialogueOff ;
31009: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
31013: LD_INT 25
31015: PPUSH
31016: LD_INT 1
31018: PPUSH
31019: LD_INT 1
31021: PPUSH
31022: CALL_OW 322
// end ;
31026: PPOPN 3
31028: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31029: LD_EXP 75
31033: PPUSH
31034: CALL_OW 302
31038: PUSH
31039: LD_INT 1
31041: PPUSH
31042: LD_EXP 75
31046: PPUSH
31047: CALL_OW 292
31051: AND
31052: IFFALSE 31303
31054: GO 31056
31056: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31057: LD_EXP 75
31061: PPUSH
31062: CALL_OW 87
// DialogueOn ;
31066: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31070: LD_EXP 40
31074: PPUSH
31075: LD_STRING D10nB-JMM-1
31077: PPUSH
31078: CALL_OW 88
// if BurlakStatus = 1 then
31082: LD_EXP 9
31086: PUSH
31087: LD_INT 1
31089: EQUAL
31090: IFFALSE 31104
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
31092: LD_EXP 74
31096: PPUSH
31097: LD_STRING D10nB-Vse-1a
31099: PPUSH
31100: CALL_OW 94
// end ; if BurlakStatus = 0 then
31104: LD_EXP 9
31108: PUSH
31109: LD_INT 0
31111: EQUAL
31112: IFFALSE 31126
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31114: LD_EXP 74
31118: PPUSH
31119: LD_STRING D10nB-Vse-1
31121: PPUSH
31122: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31126: LD_EXP 40
31130: PPUSH
31131: LD_STRING D10nB-JMM-2
31133: PPUSH
31134: CALL_OW 88
// if KappaStatus then
31138: LD_EXP 2
31142: IFFALSE 31156
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
31144: LD_EXP 74
31148: PPUSH
31149: LD_STRING D10nB-Vse-5a
31151: PPUSH
31152: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
31156: LD_EXP 2
31160: NOT
31161: PUSH
31162: LD_EXP 6
31166: PUSH
31167: LD_INT 0
31169: EQUAL
31170: AND
31171: IFFALSE 31299
// begin if JMMGirl = 1 then
31173: LD_EXP 7
31177: PUSH
31178: LD_INT 1
31180: EQUAL
31181: IFFALSE 31231
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31183: LD_EXP 74
31187: PPUSH
31188: LD_STRING D10nB-Vse-2
31190: PPUSH
31191: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31195: LD_EXP 40
31199: PPUSH
31200: LD_STRING D10nB-JMM-3
31202: PPUSH
31203: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31207: LD_EXP 74
31211: PPUSH
31212: LD_STRING D10nB-Vse-3
31214: PPUSH
31215: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31219: LD_EXP 40
31223: PPUSH
31224: LD_STRING D10nB-JMM-4
31226: PPUSH
31227: CALL_OW 88
// end ; if JMMGirl = 2 then
31231: LD_EXP 7
31235: PUSH
31236: LD_INT 2
31238: EQUAL
31239: IFFALSE 31265
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31241: LD_EXP 74
31245: PPUSH
31246: LD_STRING D10nB-Vse-4
31248: PPUSH
31249: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31253: LD_EXP 40
31257: PPUSH
31258: LD_STRING D10nB-JMM-5
31260: PPUSH
31261: CALL_OW 88
// end ; if JMMGirl = 3 then
31265: LD_EXP 7
31269: PUSH
31270: LD_INT 3
31272: EQUAL
31273: IFFALSE 31299
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31275: LD_EXP 74
31279: PPUSH
31280: LD_STRING D10nB-Vse-5
31282: PPUSH
31283: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31287: LD_EXP 40
31291: PPUSH
31292: LD_STRING D10nB-JMM-6
31294: PPUSH
31295: CALL_OW 88
// end ; end ; DialogueOff ;
31299: CALL_OW 7
// end ;
31303: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31304: LD_EXP 14
31308: PUSH
31309: LD_INT 115500
31311: GREATEREQUAL
31312: PUSH
31313: LD_EXP 69
31317: PPUSH
31318: CALL_OW 302
31322: AND
31323: PUSH
31324: LD_INT 267
31326: PPUSH
31327: CALL_OW 302
31331: AND
31332: IFFALSE 31846
31334: GO 31336
31336: DISABLE
31337: LD_INT 0
31339: PPUSH
31340: PPUSH
31341: PPUSH
// begin missionStage := 10 ;
31342: LD_ADDR_EXP 15
31346: PUSH
31347: LD_INT 10
31349: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31350: LD_ADDR_VAR 0 3
31354: PUSH
31355: LD_INT 22
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 23
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 26
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 3
31387: PUSH
31388: LD_INT 25
31390: PUSH
31391: LD_INT 12
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 3
31404: PUSH
31405: LD_INT 25
31407: PUSH
31408: LD_INT 16
31410: PUSH
31411: EMPTY
31412: LIST
31413: LIST
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: PPUSH
31426: CALL_OW 69
31430: PUSH
31431: LD_EXP 40
31435: PUSH
31436: LD_EXP 64
31440: PUSH
31441: LD_EXP 42
31445: PUSH
31446: LD_EXP 56
31450: PUSH
31451: LD_EXP 43
31455: PUSH
31456: LD_EXP 44
31460: PUSH
31461: LD_EXP 45
31465: PUSH
31466: LD_EXP 46
31470: PUSH
31471: LD_EXP 47
31475: PUSH
31476: LD_EXP 48
31480: PUSH
31481: LD_EXP 49
31485: PUSH
31486: LD_EXP 50
31490: PUSH
31491: LD_EXP 51
31495: PUSH
31496: LD_EXP 52
31500: PUSH
31501: LD_EXP 53
31505: PUSH
31506: LD_EXP 54
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: DIFF
31529: ST_TO_ADDR
// if not tmp and Brown then
31530: LD_VAR 0 3
31534: NOT
31535: PUSH
31536: LD_EXP 48
31540: AND
31541: IFFALSE 31556
// tmp := [ Brown ] ;
31543: LD_ADDR_VAR 0 3
31547: PUSH
31548: LD_EXP 48
31552: PUSH
31553: EMPTY
31554: LIST
31555: ST_TO_ADDR
// DialogueOn ;
31556: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31560: LD_VAR 0 3
31564: PUSH
31565: LD_INT 1
31567: ARRAY
31568: PPUSH
31569: LD_STRING D11-Sol1-1
31571: PPUSH
31572: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31576: LD_EXP 68
31580: PPUSH
31581: LD_STRING D11-Pla-1
31583: PPUSH
31584: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31588: LD_EXP 69
31592: PPUSH
31593: LD_STRING D11-Kov-1
31595: PPUSH
31596: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31600: LD_EXP 68
31604: PPUSH
31605: LD_STRING D11-Pla-2
31607: PPUSH
31608: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31612: LD_VAR 0 3
31616: PUSH
31617: LD_INT 1
31619: ARRAY
31620: PPUSH
31621: LD_STRING D11-Sol1-2
31623: PPUSH
31624: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31628: LD_EXP 40
31632: PPUSH
31633: LD_STRING D11-JMM-2
31635: PPUSH
31636: CALL_OW 88
// DialogueOff ;
31640: CALL_OW 7
// allowBehemothConstruct := true ;
31644: LD_ADDR_EXP 25
31648: PUSH
31649: LD_INT 1
31651: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31652: LD_STRING M4
31654: PPUSH
31655: CALL_OW 337
// j := 3 ;
31659: LD_ADDR_VAR 0 2
31663: PUSH
31664: LD_INT 3
31666: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31667: LD_ADDR_VAR 0 3
31671: PUSH
31672: LD_INT 22
31674: PUSH
31675: LD_INT 3
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 50
31684: PUSH
31685: EMPTY
31686: LIST
31687: PUSH
31688: LD_INT 3
31690: PUSH
31691: LD_INT 120
31693: PUSH
31694: LD_INT 105
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 25
31707: PUSH
31708: LD_INT 3
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: PPUSH
31721: CALL_OW 69
31725: PUSH
31726: LD_EXP 69
31730: DIFF
31731: ST_TO_ADDR
// for i in tmp do
31732: LD_ADDR_VAR 0 1
31736: PUSH
31737: LD_VAR 0 3
31741: PUSH
31742: FOR_IN
31743: IFFALSE 31793
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31745: LD_ADDR_EXP 77
31749: PUSH
31750: LD_EXP 77
31754: PPUSH
31755: LD_VAR 0 1
31759: PPUSH
31760: CALL 108104 0 2
31764: ST_TO_ADDR
// j := j - 1 ;
31765: LD_ADDR_VAR 0 2
31769: PUSH
31770: LD_VAR 0 2
31774: PUSH
31775: LD_INT 1
31777: MINUS
31778: ST_TO_ADDR
// if j = 0 then
31779: LD_VAR 0 2
31783: PUSH
31784: LD_INT 0
31786: EQUAL
31787: IFFALSE 31791
// break ;
31789: GO 31793
// end ;
31791: GO 31742
31793: POP
31794: POP
// BuildBehemoths ;
31795: CALL 8368 0 0
// repeat wait ( 15 15$00 ) ;
31799: LD_INT 31500
31801: PPUSH
31802: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31806: LD_EXP 27
31810: IFFALSE 31814
// break ;
31812: GO 31846
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31814: LD_INT 267
31816: PPUSH
31817: CALL_OW 274
31821: PPUSH
31822: LD_INT 1
31824: PPUSH
31825: CALL_OW 275
31829: PUSH
31830: LD_INT 1000
31832: GREATEREQUAL
31833: IFFALSE 31839
// BuildBehemoths ;
31835: CALL 8368 0 0
// until not behemothBuilders ;
31839: LD_EXP 77
31843: NOT
31844: IFFALSE 31799
// end ;
31846: PPOPN 3
31848: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31849: LD_EXP 77
31853: NOT
31854: PUSH
31855: LD_EXP 28
31859: NOT
31860: AND
31861: PUSH
31862: LD_EXP 25
31866: AND
31867: IFFALSE 31887
31869: GO 31871
31871: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31872: LD_STRING M4a
31874: PPUSH
31875: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31879: LD_ADDR_EXP 27
31883: PUSH
31884: LD_INT 1
31886: ST_TO_ADDR
// end ;
31887: END
// every 0 0$1 trigger behemothDone do
31888: LD_EXP 28
31892: IFFALSE 31904
31894: GO 31896
31896: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31897: LD_STRING M4b
31899: PPUSH
31900: CALL_OW 337
31904: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31905: LD_EXP 29
31909: NOT
31910: IFFALSE 32106
31912: GO 31914
31914: DISABLE
31915: LD_INT 0
31917: PPUSH
31918: PPUSH
// begin enable ;
31919: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31920: LD_ADDR_VAR 0 1
31924: PUSH
31925: LD_INT 3
31927: PPUSH
31928: CALL 108165 0 1
31932: ST_TO_ADDR
// if not tmp and not behemothDone then
31933: LD_VAR 0 1
31937: NOT
31938: PUSH
31939: LD_EXP 28
31943: NOT
31944: AND
31945: IFFALSE 31981
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31947: LD_ADDR_VAR 0 1
31951: PUSH
31952: LD_INT 22
31954: PUSH
31955: LD_INT 3
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 30
31964: PUSH
31965: LD_INT 37
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PPUSH
31976: CALL_OW 69
31980: ST_TO_ADDR
// if not tmp then
31981: LD_VAR 0 1
31985: NOT
31986: IFFALSE 31990
// exit ;
31988: GO 32106
// for i in tmp do
31990: LD_ADDR_VAR 0 2
31994: PUSH
31995: LD_VAR 0 1
31999: PUSH
32000: FOR_IN
32001: IFFALSE 32104
// if See ( 1 , i ) then
32003: LD_INT 1
32005: PPUSH
32006: LD_VAR 0 2
32010: PPUSH
32011: CALL_OW 292
32015: IFFALSE 32102
// begin if GetType ( i ) = unit_building then
32017: LD_VAR 0 2
32021: PPUSH
32022: CALL_OW 247
32026: PUSH
32027: LD_INT 3
32029: EQUAL
32030: IFFALSE 32068
// begin disable ;
32032: DISABLE
// CenterNowOnUnits ( i ) ;
32033: LD_VAR 0 2
32037: PPUSH
32038: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32042: LD_EXP 40
32046: PPUSH
32047: LD_STRING D17a-JMM-1
32049: PPUSH
32050: CALL_OW 88
// seeBehemoth := true ;
32054: LD_ADDR_EXP 29
32058: PUSH
32059: LD_INT 1
32061: ST_TO_ADDR
// exit ;
32062: POP
32063: POP
32064: GO 32106
// end else
32066: GO 32102
// begin disable ;
32068: DISABLE
// CenterNowOnUnits ( i ) ;
32069: LD_VAR 0 2
32073: PPUSH
32074: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32078: LD_EXP 40
32082: PPUSH
32083: LD_STRING D17b-JMM-1
32085: PPUSH
32086: CALL_OW 88
// seeBehemoth := true ;
32090: LD_ADDR_EXP 29
32094: PUSH
32095: LD_INT 1
32097: ST_TO_ADDR
// exit ;
32098: POP
32099: POP
32100: GO 32106
// end ; end ;
32102: GO 32000
32104: POP
32105: POP
// end ;
32106: PPOPN 2
32108: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32109: LD_EXP 14
32113: PUSH
32114: LD_INT 123200
32116: GREATEREQUAL
32117: IFFALSE 33324
32119: GO 32121
32121: DISABLE
32122: LD_INT 0
32124: PPUSH
32125: PPUSH
32126: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32127: LD_INT 2
32129: PPUSH
32130: LD_INT 23
32132: PUSH
32133: LD_INT 3
32135: PUSH
32136: LD_INT 3
32138: PUSH
32139: LD_INT 48
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: PUSH
32148: EMPTY
32149: LIST
32150: PPUSH
32151: CALL 63883 0 2
// repeat wait ( 0 0$1 ) ;
32155: LD_INT 35
32157: PPUSH
32158: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32162: LD_INT 22
32164: PUSH
32165: LD_INT 3
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 34
32174: PUSH
32175: LD_INT 48
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: EMPTY
32183: LIST
32184: LIST
32185: PPUSH
32186: CALL_OW 69
32190: IFFALSE 32155
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32192: LD_ADDR_VAR 0 1
32196: PUSH
32197: LD_INT 22
32199: PUSH
32200: LD_INT 3
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 34
32209: PUSH
32210: LD_INT 48
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PPUSH
32221: CALL_OW 69
32225: PUSH
32226: LD_INT 1
32228: ARRAY
32229: ST_TO_ADDR
// missionStage := 12 ;
32230: LD_ADDR_EXP 15
32234: PUSH
32235: LD_INT 12
32237: ST_TO_ADDR
// platonovHasBomb := true ;
32238: LD_ADDR_EXP 30
32242: PUSH
32243: LD_INT 1
32245: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32246: LD_VAR 0 1
32250: PPUSH
32251: LD_INT 181
32253: PPUSH
32254: LD_INT 86
32256: PPUSH
32257: CALL_OW 171
// AddComHold ( bomb ) ;
32261: LD_VAR 0 1
32265: PPUSH
32266: CALL_OW 200
// wait ( 0 0$10 ) ;
32270: LD_INT 350
32272: PPUSH
32273: CALL_OW 67
// DialogueOn ;
32277: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32281: LD_EXP 68
32285: PPUSH
32286: LD_STRING D15-Pla-1
32288: PPUSH
32289: CALL_OW 94
// dec := Query ( Q15a ) ;
32293: LD_ADDR_VAR 0 2
32297: PUSH
32298: LD_STRING Q15a
32300: PPUSH
32301: CALL_OW 97
32305: ST_TO_ADDR
// if dec = 1 then
32306: LD_VAR 0 2
32310: PUSH
32311: LD_INT 1
32313: EQUAL
32314: IFFALSE 32337
// begin Say ( JMM , D15a-JMM-1 ) ;
32316: LD_EXP 40
32320: PPUSH
32321: LD_STRING D15a-JMM-1
32323: PPUSH
32324: CALL_OW 88
// YouLost ( Surrender ) ;
32328: LD_STRING Surrender
32330: PPUSH
32331: CALL_OW 104
// exit ;
32335: GO 33324
// end ; if dec = 2 then
32337: LD_VAR 0 2
32341: PUSH
32342: LD_INT 2
32344: EQUAL
32345: IFFALSE 32414
// begin Say ( JMM , D15b-JMM-1 ) ;
32347: LD_EXP 40
32351: PPUSH
32352: LD_STRING D15b-JMM-1
32354: PPUSH
32355: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32359: LD_EXP 68
32363: PPUSH
32364: LD_STRING D15b-Pla-1
32366: PPUSH
32367: CALL_OW 94
// DialogueOff ;
32371: CALL_OW 7
// wait ( 3 3$00 ) ;
32375: LD_INT 6300
32377: PPUSH
32378: CALL_OW 67
// DialogueOn ;
32382: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32386: LD_EXP 40
32390: PPUSH
32391: LD_STRING D15d-JMM-1a
32393: PPUSH
32394: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32398: LD_EXP 68
32402: PPUSH
32403: LD_STRING D15d-Pla-1
32405: PPUSH
32406: CALL_OW 94
// DialogueOff ;
32410: CALL_OW 7
// end ; if dec = 3 then
32414: LD_VAR 0 2
32418: PUSH
32419: LD_INT 3
32421: EQUAL
32422: IFFALSE 32476
// begin Say ( JMM , D15c-JMM-1 ) ;
32424: LD_EXP 40
32428: PPUSH
32429: LD_STRING D15c-JMM-1
32431: PPUSH
32432: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32436: LD_EXP 68
32440: PPUSH
32441: LD_STRING D15c-Pla-1
32443: PPUSH
32444: CALL_OW 94
// DialogueOff ;
32448: CALL_OW 7
// wait ( 0 0$15 ) ;
32452: LD_INT 525
32454: PPUSH
32455: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32459: LD_VAR 0 1
32463: PPUSH
32464: LD_INT 60
32466: PPUSH
32467: LD_INT 95
32469: PPUSH
32470: CALL_OW 116
// exit ;
32474: GO 33324
// end ; if dec = 4 then
32476: LD_VAR 0 2
32480: PUSH
32481: LD_INT 4
32483: EQUAL
32484: IFFALSE 32514
// begin Say ( JMM , D15d-JMM-1 ) ;
32486: LD_EXP 40
32490: PPUSH
32491: LD_STRING D15d-JMM-1
32493: PPUSH
32494: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32498: LD_EXP 68
32502: PPUSH
32503: LD_STRING D15d-Pla-1
32505: PPUSH
32506: CALL_OW 94
// DialogueOff ;
32510: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32514: LD_EXP 66
32518: PPUSH
32519: CALL_OW 302
32523: PUSH
32524: LD_EXP 66
32528: PPUSH
32529: CALL_OW 255
32533: PUSH
32534: LD_INT 1
32536: EQUAL
32537: AND
32538: PUSH
32539: LD_INT 22
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 34
32551: PUSH
32552: LD_INT 8
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PPUSH
32563: CALL_OW 69
32567: NOT
32568: AND
32569: IFFALSE 33218
// begin SetSide ( Friend , 8 ) ;
32571: LD_EXP 66
32575: PPUSH
32576: LD_INT 8
32578: PPUSH
32579: CALL_OW 235
// if IsInUnit ( Friend ) then
32583: LD_EXP 66
32587: PPUSH
32588: CALL_OW 310
32592: IFFALSE 32603
// ComExitBuilding ( Friend ) ;
32594: LD_EXP 66
32598: PPUSH
32599: CALL_OW 122
// if IsDriver ( Friend ) then
32603: LD_EXP 66
32607: PPUSH
32608: CALL 105708 0 1
32612: IFFALSE 32623
// ComExitVehicle ( Friend ) ;
32614: LD_EXP 66
32618: PPUSH
32619: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32623: LD_EXP 66
32627: PPUSH
32628: LD_INT 9
32630: PPUSH
32631: LD_INT 2
32633: PPUSH
32634: CALL_OW 171
// wait ( 0 0$05 ) ;
32638: LD_INT 175
32640: PPUSH
32641: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32645: LD_EXP 66
32649: PPUSH
32650: CALL_OW 87
// DialogueOn ;
32654: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32658: LD_EXP 40
32662: PPUSH
32663: LD_STRING D16-JMM-1
32665: PPUSH
32666: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32670: LD_EXP 66
32674: PPUSH
32675: LD_STRING D16-Friend-1
32677: PPUSH
32678: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32682: LD_EXP 40
32686: PPUSH
32687: LD_STRING D16-JMM-2
32689: PPUSH
32690: CALL_OW 88
// DialogueOff ;
32694: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32698: LD_EXP 66
32702: PPUSH
32703: LD_INT 1
32705: PPUSH
32706: CALL_OW 235
// ComHold ( Friend ) ;
32710: LD_EXP 66
32714: PPUSH
32715: CALL_OW 140
// wait ( 0 0$20 ) ;
32719: LD_INT 700
32721: PPUSH
32722: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32726: LD_EXP 66
32730: PPUSH
32731: LD_INT 9
32733: PPUSH
32734: LD_INT 2
32736: PPUSH
32737: CALL_OW 297
32741: PUSH
32742: LD_INT 30
32744: LESS
32745: IFFALSE 32814
// begin SetSide ( Friend , 8 ) ;
32747: LD_EXP 66
32751: PPUSH
32752: LD_INT 8
32754: PPUSH
32755: CALL_OW 235
// if IsInUnit ( Friend ) then
32759: LD_EXP 66
32763: PPUSH
32764: CALL_OW 310
32768: IFFALSE 32779
// ComExitBuilding ( Friend ) ;
32770: LD_EXP 66
32774: PPUSH
32775: CALL_OW 122
// if IsDriver ( Friend ) then
32779: LD_EXP 66
32783: PPUSH
32784: CALL 105708 0 1
32788: IFFALSE 32799
// ComExitVehicle ( Friend ) ;
32790: LD_EXP 66
32794: PPUSH
32795: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32799: LD_EXP 66
32803: PPUSH
32804: LD_INT 9
32806: PPUSH
32807: LD_INT 2
32809: PPUSH
32810: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32814: LD_INT 1050
32816: PPUSH
32817: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32821: LD_INT 22
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 34
32833: PUSH
32834: LD_INT 8
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PPUSH
32845: CALL_OW 69
32849: NOT
32850: IFFALSE 33196
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32852: LD_ADDR_VAR 0 3
32856: PUSH
32857: LD_INT 22
32859: PUSH
32860: LD_INT 1
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 26
32869: PUSH
32870: LD_INT 1
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 3
32879: PUSH
32880: LD_INT 25
32882: PUSH
32883: LD_INT 12
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 25
32892: PUSH
32893: LD_INT 16
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: LIST
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: LIST
32909: PPUSH
32910: CALL_OW 69
32914: PUSH
32915: LD_EXP 40
32919: PUSH
32920: LD_EXP 42
32924: PUSH
32925: LD_EXP 56
32929: PUSH
32930: LD_EXP 43
32934: PUSH
32935: LD_EXP 44
32939: PUSH
32940: LD_EXP 45
32944: PUSH
32945: LD_EXP 46
32949: PUSH
32950: LD_EXP 47
32954: PUSH
32955: LD_EXP 48
32959: PUSH
32960: LD_EXP 49
32964: PUSH
32965: LD_EXP 50
32969: PUSH
32970: LD_EXP 51
32974: PUSH
32975: LD_EXP 52
32979: PUSH
32980: LD_EXP 53
32984: PUSH
32985: LD_EXP 54
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: DIFF
33007: ST_TO_ADDR
// DialogueOn ;
33008: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
33012: LD_EXP 68
33016: PPUSH
33017: LD_STRING D16a-Pla-1
33019: PPUSH
33020: CALL_OW 94
// if Stevens then
33024: LD_EXP 42
33028: IFFALSE 33044
// Say ( Stevens , D16a-Huck-1 ) else
33030: LD_EXP 42
33034: PPUSH
33035: LD_STRING D16a-Huck-1
33037: PPUSH
33038: CALL_OW 88
33042: GO 33086
// if Baker then
33044: LD_EXP 56
33048: IFFALSE 33064
// Say ( Baker , D16a-Huck-1 ) else
33050: LD_EXP 56
33054: PPUSH
33055: LD_STRING D16a-Huck-1
33057: PPUSH
33058: CALL_OW 88
33062: GO 33086
// if tmp then
33064: LD_VAR 0 3
33068: IFFALSE 33086
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33070: LD_VAR 0 3
33074: PUSH
33075: LD_INT 1
33077: ARRAY
33078: PPUSH
33079: LD_STRING D16a-Sol1-1
33081: PPUSH
33082: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33086: LD_EXP 66
33090: PPUSH
33091: CALL_OW 255
33095: PUSH
33096: LD_INT 8
33098: EQUAL
33099: IFFALSE 33115
// Say ( JMM , D16a-JMM-1 ) else
33101: LD_EXP 40
33105: PPUSH
33106: LD_STRING D16a-JMM-1
33108: PPUSH
33109: CALL_OW 88
33113: GO 33175
// begin Say ( JMM , D16a-JMM-1a ) ;
33115: LD_EXP 40
33119: PPUSH
33120: LD_STRING D16a-JMM-1a
33122: PPUSH
33123: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33127: LD_EXP 66
33131: PPUSH
33132: LD_STRING D16a-Friend-1
33134: PPUSH
33135: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33139: LD_EXP 66
33143: PPUSH
33144: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33148: LD_EXP 66
33152: PPUSH
33153: LD_INT 191
33155: PPUSH
33156: LD_INT 103
33158: PPUSH
33159: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33163: LD_EXP 66
33167: PPUSH
33168: LD_INT 3
33170: PPUSH
33171: CALL_OW 235
// end ; DialogueOff ;
33175: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33179: LD_VAR 0 1
33183: PPUSH
33184: LD_INT 60
33186: PPUSH
33187: LD_INT 95
33189: PPUSH
33190: CALL_OW 116
// end else
33194: GO 33216
// begin DialogueOn ;
33196: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33200: LD_EXP 68
33204: PPUSH
33205: LD_STRING D16c-Pla-1
33207: PPUSH
33208: CALL_OW 94
// DialogueOff ;
33212: CALL_OW 7
// end ; end else
33216: GO 33324
// begin wait ( 3 3$00 ) ;
33218: LD_INT 6300
33220: PPUSH
33221: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) and not bombExploded then
33225: LD_INT 22
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 34
33237: PUSH
33238: LD_INT 8
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PPUSH
33249: CALL_OW 69
33253: NOT
33254: PUSH
33255: LD_EXP 37
33259: NOT
33260: AND
33261: IFFALSE 33304
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33263: LD_EXP 68
33267: PPUSH
33268: LD_STRING D16b-Pla-1
33270: PPUSH
33271: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33275: LD_EXP 40
33279: PPUSH
33280: LD_STRING D16b-JMM-1
33282: PPUSH
33283: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33287: LD_VAR 0 1
33291: PPUSH
33292: LD_INT 60
33294: PPUSH
33295: LD_INT 95
33297: PPUSH
33298: CALL_OW 116
// end else
33302: GO 33324
// begin DialogueOn ;
33304: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33308: LD_EXP 68
33312: PPUSH
33313: LD_STRING D16c-Pla-1
33315: PPUSH
33316: CALL_OW 94
// DialogueOff ;
33320: CALL_OW 7
// end ; end ; end ;
33324: PPOPN 3
33326: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33327: LD_INT 25
33329: PPUSH
33330: LD_INT 1
33332: PPUSH
33333: CALL_OW 321
33337: PUSH
33338: LD_INT 2
33340: EQUAL
33341: PUSH
33342: LD_EXP 14
33346: PUSH
33347: LD_INT 126000
33349: GREATEREQUAL
33350: OR
33351: PUSH
33352: LD_EXP 23
33356: NOT
33357: AND
33358: PUSH
33359: LD_EXP 79
33363: PPUSH
33364: CALL_OW 302
33368: AND
33369: IFFALSE 33727
33371: GO 33373
33373: DISABLE
33374: LD_INT 0
33376: PPUSH
// begin missionStage := 11 ;
33377: LD_ADDR_EXP 15
33381: PUSH
33382: LD_INT 11
33384: ST_TO_ADDR
// DialogueOn ;
33385: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33389: LD_EXP 79
33393: PPUSH
33394: LD_STRING D9-Roth-1
33396: PPUSH
33397: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33401: LD_EXP 40
33405: PPUSH
33406: LD_STRING D9-JMM-1
33408: PPUSH
33409: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33413: LD_EXP 79
33417: PPUSH
33418: LD_STRING D9-Roth-2
33420: PPUSH
33421: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33425: LD_EXP 79
33429: PPUSH
33430: LD_STRING D9-Roth-2a
33432: PPUSH
33433: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33437: LD_EXP 68
33441: PPUSH
33442: LD_STRING D9-Pla-2
33444: PPUSH
33445: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33449: LD_EXP 79
33453: PPUSH
33454: LD_STRING D9-Roth-3
33456: PPUSH
33457: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33461: LD_EXP 68
33465: PPUSH
33466: LD_STRING D9-Pla-3
33468: PPUSH
33469: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33473: LD_EXP 79
33477: PPUSH
33478: LD_STRING D9-Roth-4
33480: PPUSH
33481: CALL_OW 94
// dec := Query ( Q9 ) ;
33485: LD_ADDR_VAR 0 1
33489: PUSH
33490: LD_STRING Q9
33492: PPUSH
33493: CALL_OW 97
33497: ST_TO_ADDR
// if dec = 1 then
33498: LD_VAR 0 1
33502: PUSH
33503: LD_INT 1
33505: EQUAL
33506: IFFALSE 33520
// SayRadio ( Roth , D9a-Roth-1 ) ;
33508: LD_EXP 79
33512: PPUSH
33513: LD_STRING D9a-Roth-1
33515: PPUSH
33516: CALL_OW 94
// if dec = 2 then
33520: LD_VAR 0 1
33524: PUSH
33525: LD_INT 2
33527: EQUAL
33528: IFFALSE 33554
// begin Say ( JMM , D9b-JMM-1 ) ;
33530: LD_EXP 40
33534: PPUSH
33535: LD_STRING D9b-JMM-1
33537: PPUSH
33538: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33542: LD_EXP 79
33546: PPUSH
33547: LD_STRING D9b-Roth-1
33549: PPUSH
33550: CALL_OW 94
// end ; if dec = 3 then
33554: LD_VAR 0 1
33558: PUSH
33559: LD_INT 3
33561: EQUAL
33562: IFFALSE 33624
// begin Say ( JMM , D9c-JMM-1 ) ;
33564: LD_EXP 40
33568: PPUSH
33569: LD_STRING D9c-JMM-1
33571: PPUSH
33572: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33576: LD_EXP 79
33580: PPUSH
33581: LD_STRING D9c-Roth-1
33583: PPUSH
33584: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33588: LD_EXP 40
33592: PPUSH
33593: LD_STRING D9c-JMM-2
33595: PPUSH
33596: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33600: LD_EXP 79
33604: PPUSH
33605: LD_STRING D9c-Roth-2
33607: PPUSH
33608: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33612: LD_EXP 40
33616: PPUSH
33617: LD_STRING D9c-JMM-3
33619: PPUSH
33620: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33624: LD_EXP 79
33628: PPUSH
33629: LD_STRING D9c-Roth-3
33631: PPUSH
33632: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33636: LD_EXP 79
33640: PPUSH
33641: LD_STRING D9cont-Roth-1
33643: PPUSH
33644: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33648: LD_EXP 40
33652: PPUSH
33653: LD_STRING D9cont-JMM-1
33655: PPUSH
33656: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33660: LD_EXP 79
33664: PPUSH
33665: LD_STRING D9cont-Roth-2
33667: PPUSH
33668: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33672: LD_EXP 40
33676: PPUSH
33677: LD_STRING D9cont-JMM-2
33679: PPUSH
33680: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33684: LD_EXP 79
33688: PPUSH
33689: LD_STRING D9cont-Roth-3
33691: PPUSH
33692: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33696: LD_EXP 40
33700: PPUSH
33701: LD_STRING D9cont-JMM-3
33703: PPUSH
33704: CALL_OW 88
// DialogueOff ;
33708: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33712: LD_STRING M3
33714: PPUSH
33715: CALL_OW 337
// allianceActive := true ;
33719: LD_ADDR_EXP 31
33723: PUSH
33724: LD_INT 1
33726: ST_TO_ADDR
// end ;
33727: PPOPN 1
33729: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33730: LD_INT 1
33732: PPUSH
33733: LD_INT 126
33735: PPUSH
33736: CALL_OW 292
33740: PUSH
33741: LD_EXP 68
33745: PPUSH
33746: CALL_OW 310
33750: AND
33751: IFFALSE 33904
33753: GO 33755
33755: DISABLE
33756: LD_INT 0
33758: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33759: LD_EXP 68
33763: PPUSH
33764: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33768: LD_ADDR_VAR 0 1
33772: PUSH
33773: LD_INT 4
33775: PPUSH
33776: LD_INT 22
33778: PUSH
33779: LD_INT 1
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PPUSH
33786: CALL_OW 70
33790: PPUSH
33791: LD_EXP 68
33795: PPUSH
33796: CALL_OW 74
33800: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33801: LD_EXP 68
33805: PPUSH
33806: LD_VAR 0 1
33810: PUSH
33811: LD_INT 1
33813: ARRAY
33814: PPUSH
33815: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33819: LD_EXP 68
33823: PPUSH
33824: LD_STRING D18-Pla-1
33826: PPUSH
33827: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33831: LD_INT 22
33833: PUSH
33834: LD_INT 3
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 34
33843: PUSH
33844: LD_INT 48
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PPUSH
33855: CALL_OW 69
33859: IFFALSE 33904
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33861: LD_INT 22
33863: PUSH
33864: LD_INT 3
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 34
33873: PUSH
33874: LD_INT 48
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PPUSH
33885: CALL_OW 69
33889: PUSH
33890: LD_INT 1
33892: ARRAY
33893: PPUSH
33894: LD_INT 111
33896: PPUSH
33897: LD_INT 97
33899: PPUSH
33900: CALL_OW 116
// end ;
33904: PPOPN 1
33906: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33907: LD_EXP 68
33911: PPUSH
33912: CALL_OW 301
33916: PUSH
33917: LD_EXP 71
33921: PPUSH
33922: CALL_OW 301
33926: AND
33927: PUSH
33928: LD_INT 22
33930: PUSH
33931: LD_INT 3
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 21
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 50
33950: PUSH
33951: EMPTY
33952: LIST
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: LIST
33958: PPUSH
33959: CALL_OW 69
33963: PUSH
33964: LD_INT 14
33966: PUSH
33967: LD_INT 13
33969: PUSH
33970: LD_INT 12
33972: PUSH
33973: LD_INT 10
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: PUSH
33982: LD_OWVAR 67
33986: ARRAY
33987: LESS
33988: AND
33989: IFFALSE 34788
33991: GO 33993
33993: DISABLE
33994: LD_INT 0
33996: PPUSH
33997: PPUSH
33998: PPUSH
33999: PPUSH
// begin MC_Kill ( 2 ) ;
34000: LD_INT 2
34002: PPUSH
34003: CALL 39858 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
34007: LD_INT 1
34009: PPUSH
34010: LD_INT 3
34012: PPUSH
34013: LD_INT 1
34015: PPUSH
34016: LD_INT 1
34018: PPUSH
34019: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
34023: LD_ADDR_VAR 0 2
34027: PUSH
34028: LD_INT 22
34030: PUSH
34031: LD_INT 3
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 21
34040: PUSH
34041: LD_INT 1
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 50
34050: PUSH
34051: EMPTY
34052: LIST
34053: PUSH
34054: LD_INT 26
34056: PUSH
34057: LD_INT 1
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: PPUSH
34070: CALL_OW 69
34074: ST_TO_ADDR
// if not tmp then
34075: LD_VAR 0 2
34079: NOT
34080: IFFALSE 34136
// begin uc_side = 3 ;
34082: LD_ADDR_OWVAR 20
34086: PUSH
34087: LD_INT 3
34089: ST_TO_ADDR
// uc_nation = 3 ;
34090: LD_ADDR_OWVAR 21
34094: PUSH
34095: LD_INT 3
34097: ST_TO_ADDR
// hc_name =  ;
34098: LD_ADDR_OWVAR 26
34102: PUSH
34103: LD_STRING 
34105: ST_TO_ADDR
// hc_gallery =  ;
34106: LD_ADDR_OWVAR 33
34110: PUSH
34111: LD_STRING 
34113: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34114: LD_INT 1
34116: PPUSH
34117: LD_INT 10
34119: PPUSH
34120: CALL_OW 381
// tmp = CreateHuman ;
34124: LD_ADDR_VAR 0 2
34128: PUSH
34129: CALL_OW 44
34133: ST_TO_ADDR
// end else
34134: GO 34150
// tmp := tmp [ 1 ] ;
34136: LD_ADDR_VAR 0 2
34140: PUSH
34141: LD_VAR 0 2
34145: PUSH
34146: LD_INT 1
34148: ARRAY
34149: ST_TO_ADDR
// DialogueOn ;
34150: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34154: LD_VAR 0 2
34158: PPUSH
34159: LD_STRING DSurrenderRussians-RSol1-1a
34161: PPUSH
34162: CALL_OW 94
// DialogueOff ;
34166: CALL_OW 7
// russianDestroyed := true ;
34170: LD_ADDR_EXP 21
34174: PUSH
34175: LD_INT 1
34177: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34178: LD_ADDR_VAR 0 1
34182: PUSH
34183: LD_INT 22
34185: PUSH
34186: LD_INT 6
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PPUSH
34193: CALL_OW 69
34197: PUSH
34198: FOR_IN
34199: IFFALSE 34212
// KillUnit ( i ) ;
34201: LD_VAR 0 1
34205: PPUSH
34206: CALL_OW 66
34210: GO 34198
34212: POP
34213: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34214: LD_INT 22
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 21
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PPUSH
34238: CALL_OW 69
34242: PPUSH
34243: CALL_OW 122
// wait ( 0 0$1 ) ;
34247: LD_INT 35
34249: PPUSH
34250: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34254: LD_INT 22
34256: PUSH
34257: LD_INT 3
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 21
34266: PUSH
34267: LD_INT 1
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PPUSH
34278: CALL_OW 69
34282: PPUSH
34283: LD_INT 25
34285: PPUSH
34286: CALL_OW 173
// wait ( 0 0$35 ) ;
34290: LD_INT 1225
34292: PPUSH
34293: CALL_OW 67
// PrepareOmarInvasion ;
34297: CALL 16368 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34301: LD_ADDR_VAR 0 2
34305: PUSH
34306: LD_EXP 97
34310: PPUSH
34311: CALL_OW 250
34315: PUSH
34316: LD_EXP 97
34320: PPUSH
34321: CALL_OW 251
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34330: LD_VAR 0 2
34334: PUSH
34335: LD_INT 1
34337: ARRAY
34338: PPUSH
34339: LD_VAR 0 2
34343: PUSH
34344: LD_INT 2
34346: ARRAY
34347: PPUSH
34348: LD_INT 1
34350: PPUSH
34351: LD_INT 8
34353: NEG
34354: PPUSH
34355: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34359: LD_EXP 97
34363: PPUSH
34364: CALL_OW 87
// DialogueOn ;
34368: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34372: LD_EXP 40
34376: PPUSH
34377: LD_STRING D19-JMM-1
34379: PPUSH
34380: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34384: LD_ADDR_VAR 0 3
34388: PUSH
34389: LD_INT 22
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 26
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: LD_INT 25
34414: PUSH
34415: LD_INT 1
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 25
34424: PUSH
34425: LD_INT 2
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 25
34434: PUSH
34435: LD_INT 3
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PUSH
34442: LD_INT 25
34444: PUSH
34445: LD_INT 4
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 25
34454: PUSH
34455: LD_INT 5
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 25
34464: PUSH
34465: LD_INT 8
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: LIST
34476: LIST
34477: LIST
34478: LIST
34479: LIST
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: LIST
34485: PPUSH
34486: CALL_OW 69
34490: PUSH
34491: LD_EXP 40
34495: PUSH
34496: LD_EXP 41
34500: PUSH
34501: LD_EXP 64
34505: PUSH
34506: LD_EXP 42
34510: PUSH
34511: LD_EXP 43
34515: PUSH
34516: LD_EXP 44
34520: PUSH
34521: LD_EXP 45
34525: PUSH
34526: LD_EXP 46
34530: PUSH
34531: LD_EXP 47
34535: PUSH
34536: LD_EXP 48
34540: PUSH
34541: LD_EXP 49
34545: PUSH
34546: LD_EXP 50
34550: PUSH
34551: LD_EXP 51
34555: PUSH
34556: LD_EXP 52
34560: PUSH
34561: LD_EXP 53
34565: PUSH
34566: LD_EXP 54
34570: PUSH
34571: LD_EXP 55
34575: PUSH
34576: LD_EXP 56
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: DIFF
34601: ST_TO_ADDR
// if tmp2 then
34602: LD_VAR 0 3
34606: IFFALSE 34624
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34608: LD_VAR 0 3
34612: PUSH
34613: LD_INT 1
34615: ARRAY
34616: PPUSH
34617: LD_STRING D19-Sol1-1
34619: PPUSH
34620: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34624: LD_EXP 40
34628: PPUSH
34629: LD_STRING D19-JMM-2
34631: PPUSH
34632: CALL_OW 88
// DialogueOff ;
34636: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34640: LD_VAR 0 2
34644: PUSH
34645: LD_INT 1
34647: ARRAY
34648: PPUSH
34649: LD_VAR 0 2
34653: PUSH
34654: LD_INT 2
34656: ARRAY
34657: PPUSH
34658: LD_INT 1
34660: PPUSH
34661: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34665: LD_STRING M5
34667: PPUSH
34668: CALL_OW 337
// omarOnMotherLode := false ;
34672: LD_ADDR_VAR 0 4
34676: PUSH
34677: LD_INT 0
34679: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34680: LD_INT 35
34682: PPUSH
34683: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34687: LD_EXP 97
34691: PPUSH
34692: LD_INT 215
34694: PPUSH
34695: LD_INT 100
34697: PPUSH
34698: CALL_OW 297
34702: PUSH
34703: LD_INT 10
34705: LESS
34706: PUSH
34707: LD_VAR 0 4
34711: NOT
34712: AND
34713: IFFALSE 34747
// begin omarOnMotherLode := true ;
34715: LD_ADDR_VAR 0 4
34719: PUSH
34720: LD_INT 1
34722: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34723: LD_EXP 40
34727: PPUSH
34728: LD_STRING D19b-JMM-1
34730: PPUSH
34731: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34735: LD_EXP 97
34739: PPUSH
34740: LD_STRING DOmarContam-Omar-1
34742: PPUSH
34743: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34747: LD_EXP 97
34751: PPUSH
34752: CALL_OW 301
34756: IFFALSE 34680
// Say ( JMM , D19a-JMM-1 ) ;
34758: LD_EXP 40
34762: PPUSH
34763: LD_STRING D19a-JMM-1
34765: PPUSH
34766: CALL_OW 88
// if Heike then
34770: LD_EXP 98
34774: IFFALSE 34788
// Say ( Heike , D19a-Hke-1 ) ;
34776: LD_EXP 98
34780: PPUSH
34781: LD_STRING D19a-Hke-1
34783: PPUSH
34784: CALL_OW 88
// end ;
34788: PPOPN 4
34790: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34791: LD_INT 22
34793: PUSH
34794: LD_INT 3
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 21
34803: PUSH
34804: LD_INT 1
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PPUSH
34815: CALL_OW 69
34819: PUSH
34820: LD_EXP 21
34824: AND
34825: IFFALSE 34893
34827: GO 34829
34829: DISABLE
34830: LD_INT 0
34832: PPUSH
34833: PPUSH
// begin enable ;
34834: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34835: LD_ADDR_VAR 0 2
34839: PUSH
34840: LD_INT 25
34842: PPUSH
34843: LD_INT 22
34845: PUSH
34846: LD_INT 3
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PPUSH
34853: CALL_OW 70
34857: ST_TO_ADDR
// if not tmp then
34858: LD_VAR 0 2
34862: NOT
34863: IFFALSE 34867
// exit ;
34865: GO 34893
// for i in tmp do
34867: LD_ADDR_VAR 0 1
34871: PUSH
34872: LD_VAR 0 2
34876: PUSH
34877: FOR_IN
34878: IFFALSE 34891
// RemoveUnit ( i ) ;
34880: LD_VAR 0 1
34884: PPUSH
34885: CALL_OW 64
34889: GO 34877
34891: POP
34892: POP
// end ;
34893: PPOPN 2
34895: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34896: LD_INT 22
34898: PUSH
34899: LD_INT 7
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 21
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PPUSH
34920: CALL_OW 69
34924: PUSH
34925: LD_INT 6
34927: LESS
34928: IFFALSE 35396
34930: GO 34932
34932: DISABLE
34933: LD_INT 0
34935: PPUSH
34936: PPUSH
// begin MC_Kill ( 1 ) ;
34937: LD_INT 1
34939: PPUSH
34940: CALL 39858 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34944: LD_INT 7
34946: PPUSH
34947: LD_INT 1
34949: PPUSH
34950: LD_INT 1
34952: PPUSH
34953: LD_INT 1
34955: PPUSH
34956: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34960: LD_ADDR_VAR 0 1
34964: PUSH
34965: LD_INT 22
34967: PUSH
34968: LD_INT 7
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 26
34977: PUSH
34978: LD_INT 1
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PPUSH
34989: CALL_OW 69
34993: PUSH
34994: LD_EXP 79
34998: DIFF
34999: ST_TO_ADDR
// if tmp then
35000: LD_VAR 0 1
35004: IFFALSE 35022
// tmp := tmp [ 1 ] else
35006: LD_ADDR_VAR 0 1
35010: PUSH
35011: LD_VAR 0 1
35015: PUSH
35016: LD_INT 1
35018: ARRAY
35019: ST_TO_ADDR
35020: GO 35058
// begin uc_side := 7 ;
35022: LD_ADDR_OWVAR 20
35026: PUSH
35027: LD_INT 7
35029: ST_TO_ADDR
// uc_nation := 1 ;
35030: LD_ADDR_OWVAR 21
35034: PUSH
35035: LD_INT 1
35037: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35038: LD_INT 1
35040: PPUSH
35041: LD_INT 8
35043: PPUSH
35044: CALL_OW 384
// tmp := CreateHuman ;
35048: LD_ADDR_VAR 0 1
35052: PUSH
35053: CALL_OW 44
35057: ST_TO_ADDR
// end ; DialogueOn ;
35058: CALL_OW 6
// if IsOK ( Roth ) then
35062: LD_EXP 79
35066: PPUSH
35067: CALL_OW 302
35071: IFFALSE 35085
// Say ( JMM , DAb-JMM-1 ) ;
35073: LD_EXP 40
35077: PPUSH
35078: LD_STRING DAb-JMM-1
35080: PPUSH
35081: CALL_OW 88
// if IsOK ( Roth ) then
35085: LD_EXP 79
35089: PPUSH
35090: CALL_OW 302
35094: IFFALSE 35118
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35096: LD_EXP 79
35100: PPUSH
35101: LD_STRING DSurrenderAlliance-Roth-1
35103: PPUSH
35104: CALL_OW 88
// RothCaptured := true ;
35108: LD_ADDR_EXP 33
35112: PUSH
35113: LD_INT 1
35115: ST_TO_ADDR
// end else
35116: GO 35130
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35118: LD_VAR 0 1
35122: PPUSH
35123: LD_STRING DSurrenderAlliance-Sci1-1
35125: PPUSH
35126: CALL_OW 88
// DialogueOff ;
35130: CALL_OW 7
// allianceDestroyed := true ;
35134: LD_ADDR_EXP 23
35138: PUSH
35139: LD_INT 1
35141: ST_TO_ADDR
// if capturedUnit = 0 then
35142: LD_EXP 34
35146: PUSH
35147: LD_INT 0
35149: EQUAL
35150: IFFALSE 35159
// SetAchievement ( ACH_ALLIANCE ) ;
35152: LD_STRING ACH_ALLIANCE
35154: PPUSH
35155: CALL_OW 543
// if trueAmericans then
35159: LD_EXP 35
35163: IFFALSE 35239
// begin if trueAmericans = 1 then
35165: LD_EXP 35
35169: PUSH
35170: LD_INT 1
35172: EQUAL
35173: IFFALSE 35189
// Say ( JMM , DAb-JMM-1a ) else
35175: LD_EXP 40
35179: PPUSH
35180: LD_STRING DAb-JMM-1a
35182: PPUSH
35183: CALL_OW 88
35187: GO 35201
// Say ( JMM , DAb-JMM-1b ) ;
35189: LD_EXP 40
35193: PPUSH
35194: LD_STRING DAb-JMM-1b
35196: PPUSH
35197: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35201: LD_EXP 35
35205: PPUSH
35206: CALL_OW 87
// for i in trueAmericans do
35210: LD_ADDR_VAR 0 2
35214: PUSH
35215: LD_EXP 35
35219: PUSH
35220: FOR_IN
35221: IFFALSE 35237
// SetSide ( i , 1 ) ;
35223: LD_VAR 0 2
35227: PPUSH
35228: LD_INT 1
35230: PPUSH
35231: CALL_OW 235
35235: GO 35220
35237: POP
35238: POP
// end ; repeat wait ( 0 0$1 ) ;
35239: LD_INT 35
35241: PPUSH
35242: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35246: LD_ADDR_VAR 0 2
35250: PUSH
35251: LD_INT 22
35253: PUSH
35254: LD_INT 7
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 21
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PPUSH
35275: CALL_OW 69
35279: PUSH
35280: FOR_IN
35281: IFFALSE 35363
// begin if IsInUnit ( i ) then
35283: LD_VAR 0 2
35287: PPUSH
35288: CALL_OW 310
35292: IFFALSE 35303
// ComExitBuilding ( i ) ;
35294: LD_VAR 0 2
35298: PPUSH
35299: CALL_OW 122
// if IsDriver ( i ) then
35303: LD_VAR 0 2
35307: PPUSH
35308: CALL 105708 0 1
35312: IFFALSE 35323
// ComExitVehicle ( i ) ;
35314: LD_VAR 0 2
35318: PPUSH
35319: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35323: LD_VAR 0 2
35327: PPUSH
35328: LD_INT 26
35330: PPUSH
35331: CALL_OW 308
35335: NOT
35336: IFFALSE 35352
// AddComMoveToArea ( i , allianceEscapeArea ) else
35338: LD_VAR 0 2
35342: PPUSH
35343: LD_INT 26
35345: PPUSH
35346: CALL_OW 173
35350: GO 35361
// RemoveUnit ( i ) ;
35352: LD_VAR 0 2
35356: PPUSH
35357: CALL_OW 64
// end ;
35361: GO 35280
35363: POP
35364: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35365: LD_INT 22
35367: PUSH
35368: LD_INT 7
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 21
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PPUSH
35389: CALL_OW 69
35393: NOT
35394: IFFALSE 35239
// end ;
35396: PPOPN 2
35398: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35399: LD_INT 0
35401: PPUSH
35402: PPUSH
// if not unit then
35403: LD_VAR 0 1
35407: NOT
35408: IFFALSE 35412
// exit ;
35410: GO 36926
// DoNotAttack ( 7 , unit ) ;
35412: LD_INT 7
35414: PPUSH
35415: LD_VAR 0 1
35419: PPUSH
35420: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35424: LD_VAR 0 1
35428: PPUSH
35429: LD_INT 260
35431: PPUSH
35432: LD_INT 235
35434: PPUSH
35435: LD_INT 3
35437: PPUSH
35438: LD_INT 1
35440: PPUSH
35441: CALL_OW 483
// SetSide ( unit , 4 ) ;
35445: LD_VAR 0 1
35449: PPUSH
35450: LD_INT 4
35452: PPUSH
35453: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35457: LD_ADDR_EXP 34
35461: PUSH
35462: LD_EXP 34
35466: PUSH
35467: LD_INT 1
35469: PLUS
35470: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35471: LD_INT 70
35473: PPUSH
35474: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35478: LD_INT 260
35480: PPUSH
35481: LD_INT 235
35483: PPUSH
35484: LD_INT 1
35486: PPUSH
35487: LD_INT 8
35489: NEG
35490: PPUSH
35491: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35495: LD_VAR 0 1
35499: PPUSH
35500: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35504: LD_VAR 0 1
35508: PPUSH
35509: LD_EXP 79
35513: PPUSH
35514: CALL_OW 119
// DialogueOn ;
35518: CALL_OW 6
// case unit of JMM :
35522: LD_VAR 0 1
35526: PUSH
35527: LD_EXP 40
35531: DOUBLE
35532: EQUAL
35533: IFTRUE 35537
35535: GO 35552
35537: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35538: LD_EXP 40
35542: PPUSH
35543: LD_STRING DA1-JMM-1
35545: PPUSH
35546: CALL_OW 91
35550: GO 35994
35552: LD_EXP 41
35556: DOUBLE
35557: EQUAL
35558: IFTRUE 35562
35560: GO 35577
35562: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35563: LD_EXP 41
35567: PPUSH
35568: LD_STRING DA1-Joan-1
35570: PPUSH
35571: CALL_OW 91
35575: GO 35994
35577: LD_EXP 43
35581: DOUBLE
35582: EQUAL
35583: IFTRUE 35587
35585: GO 35602
35587: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35588: LD_EXP 43
35592: PPUSH
35593: LD_STRING DA1-Lisa-1
35595: PPUSH
35596: CALL_OW 91
35600: GO 35994
35602: LD_EXP 44
35606: DOUBLE
35607: EQUAL
35608: IFTRUE 35612
35610: GO 35627
35612: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35613: LD_EXP 44
35617: PPUSH
35618: LD_STRING DA1-Don-1
35620: PPUSH
35621: CALL_OW 91
35625: GO 35994
35627: LD_EXP 51
35631: DOUBLE
35632: EQUAL
35633: IFTRUE 35637
35635: GO 35652
35637: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35638: LD_EXP 51
35642: PPUSH
35643: LD_STRING DA1-Corn-1
35645: PPUSH
35646: CALL_OW 91
35650: GO 35994
35652: LD_EXP 47
35656: DOUBLE
35657: EQUAL
35658: IFTRUE 35662
35660: GO 35677
35662: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35663: LD_EXP 47
35667: PPUSH
35668: LD_STRING DA1-Den-1
35670: PPUSH
35671: CALL_OW 91
35675: GO 35994
35677: LD_EXP 45
35681: DOUBLE
35682: EQUAL
35683: IFTRUE 35687
35685: GO 35702
35687: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35688: LD_EXP 45
35692: PPUSH
35693: LD_STRING DA1-Bobby-1
35695: PPUSH
35696: CALL_OW 91
35700: GO 35994
35702: LD_EXP 49
35706: DOUBLE
35707: EQUAL
35708: IFTRUE 35712
35710: GO 35727
35712: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35713: LD_EXP 49
35717: PPUSH
35718: LD_STRING DA1-Glad-1
35720: PPUSH
35721: CALL_OW 91
35725: GO 35994
35727: LD_EXP 46
35731: DOUBLE
35732: EQUAL
35733: IFTRUE 35737
35735: GO 35752
35737: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35738: LD_EXP 46
35742: PPUSH
35743: LD_STRING DA1-Cyrus-1
35745: PPUSH
35746: CALL_OW 91
35750: GO 35994
35752: LD_EXP 42
35756: DOUBLE
35757: EQUAL
35758: IFTRUE 35762
35760: GO 35777
35762: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35763: LD_EXP 42
35767: PPUSH
35768: LD_STRING DA1-Huck-1
35770: PPUSH
35771: CALL_OW 91
35775: GO 35994
35777: LD_EXP 56
35781: DOUBLE
35782: EQUAL
35783: IFTRUE 35787
35785: GO 35802
35787: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35788: LD_EXP 56
35792: PPUSH
35793: LD_STRING DA1-Huck-1
35795: PPUSH
35796: CALL_OW 91
35800: GO 35994
35802: LD_EXP 48
35806: DOUBLE
35807: EQUAL
35808: IFTRUE 35812
35810: GO 35827
35812: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35813: LD_EXP 48
35817: PPUSH
35818: LD_STRING DA1-Brown-1
35820: PPUSH
35821: CALL_OW 91
35825: GO 35994
35827: LD_EXP 52
35831: DOUBLE
35832: EQUAL
35833: IFTRUE 35837
35835: GO 35852
35837: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35838: LD_EXP 52
35842: PPUSH
35843: LD_STRING DA1-Gary-1
35845: PPUSH
35846: CALL_OW 91
35850: GO 35994
35852: LD_EXP 55
35856: DOUBLE
35857: EQUAL
35858: IFTRUE 35862
35860: GO 35877
35862: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35863: LD_EXP 55
35867: PPUSH
35868: LD_STRING DA1-Con-1
35870: PPUSH
35871: CALL_OW 91
35875: GO 35994
35877: LD_EXP 64
35881: DOUBLE
35882: EQUAL
35883: IFTRUE 35887
35885: GO 35902
35887: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35888: LD_EXP 64
35892: PPUSH
35893: LD_STRING DA1-Kurt-1
35895: PPUSH
35896: CALL_OW 91
35900: GO 35994
35902: LD_EXP 54
35906: DOUBLE
35907: EQUAL
35908: IFTRUE 35912
35910: GO 35927
35912: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35913: LD_EXP 54
35917: PPUSH
35918: LD_STRING DA1-Yam-1
35920: PPUSH
35921: CALL_OW 91
35925: GO 35994
35927: LD_EXP 53
35931: DOUBLE
35932: EQUAL
35933: IFTRUE 35937
35935: GO 35952
35937: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35938: LD_EXP 53
35942: PPUSH
35943: LD_STRING DA1-Frank-1
35945: PPUSH
35946: CALL_OW 91
35950: GO 35994
35952: POP
// begin if GetSex ( unit ) = sex_male then
35953: LD_VAR 0 1
35957: PPUSH
35958: CALL_OW 258
35962: PUSH
35963: LD_INT 1
35965: EQUAL
35966: IFFALSE 35982
// ForceSay ( unit , DA1-Sol1-1 ) else
35968: LD_VAR 0 1
35972: PPUSH
35973: LD_STRING DA1-Sol1-1
35975: PPUSH
35976: CALL_OW 91
35980: GO 35994
// ForceSay ( unit , DA1-FSol1-1 ) ;
35982: LD_VAR 0 1
35986: PPUSH
35987: LD_STRING DA1-FSol1-1
35989: PPUSH
35990: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35994: LD_EXP 79
35998: PPUSH
35999: LD_STRING DA-Roth-1
36001: PPUSH
36002: CALL_OW 88
// if capturedUnit = 1 then
36006: LD_EXP 34
36010: PUSH
36011: LD_INT 1
36013: EQUAL
36014: IFFALSE 36042
// begin Say ( Simms , DA-Sim-1 ) ;
36016: LD_EXP 80
36020: PPUSH
36021: LD_STRING DA-Sim-1
36023: PPUSH
36024: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36028: LD_EXP 79
36032: PPUSH
36033: LD_STRING DA-Roth-2
36035: PPUSH
36036: CALL_OW 88
// end else
36040: GO 36054
// Say ( Simms , DA-Sim-2 ) ;
36042: LD_EXP 80
36046: PPUSH
36047: LD_STRING DA-Sim-2
36049: PPUSH
36050: CALL_OW 88
// case unit of JMM :
36054: LD_VAR 0 1
36058: PUSH
36059: LD_EXP 40
36063: DOUBLE
36064: EQUAL
36065: IFTRUE 36069
36067: GO 36084
36069: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36070: LD_EXP 40
36074: PPUSH
36075: LD_STRING DA1-JMM-1a
36077: PPUSH
36078: CALL_OW 91
36082: GO 36601
36084: LD_EXP 41
36088: DOUBLE
36089: EQUAL
36090: IFTRUE 36094
36092: GO 36109
36094: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36095: LD_EXP 41
36099: PPUSH
36100: LD_STRING DA1-Joan-1a
36102: PPUSH
36103: CALL_OW 91
36107: GO 36601
36109: LD_EXP 43
36113: DOUBLE
36114: EQUAL
36115: IFTRUE 36119
36117: GO 36134
36119: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36120: LD_EXP 43
36124: PPUSH
36125: LD_STRING DA1-Lisa-1a
36127: PPUSH
36128: CALL_OW 91
36132: GO 36601
36134: LD_EXP 44
36138: DOUBLE
36139: EQUAL
36140: IFTRUE 36144
36142: GO 36159
36144: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36145: LD_EXP 44
36149: PPUSH
36150: LD_STRING DA1-Don-1a
36152: PPUSH
36153: CALL_OW 91
36157: GO 36601
36159: LD_EXP 51
36163: DOUBLE
36164: EQUAL
36165: IFTRUE 36169
36167: GO 36184
36169: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36170: LD_EXP 51
36174: PPUSH
36175: LD_STRING DA1-Corn-1a
36177: PPUSH
36178: CALL_OW 91
36182: GO 36601
36184: LD_EXP 47
36188: DOUBLE
36189: EQUAL
36190: IFTRUE 36194
36192: GO 36209
36194: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36195: LD_EXP 47
36199: PPUSH
36200: LD_STRING DA1-Den-1a
36202: PPUSH
36203: CALL_OW 91
36207: GO 36601
36209: LD_EXP 45
36213: DOUBLE
36214: EQUAL
36215: IFTRUE 36219
36217: GO 36234
36219: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36220: LD_EXP 45
36224: PPUSH
36225: LD_STRING DA1-Bobby-1a
36227: PPUSH
36228: CALL_OW 91
36232: GO 36601
36234: LD_EXP 49
36238: DOUBLE
36239: EQUAL
36240: IFTRUE 36244
36242: GO 36259
36244: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36245: LD_EXP 49
36249: PPUSH
36250: LD_STRING DA1-Glad-1a
36252: PPUSH
36253: CALL_OW 91
36257: GO 36601
36259: LD_EXP 46
36263: DOUBLE
36264: EQUAL
36265: IFTRUE 36269
36267: GO 36284
36269: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36270: LD_EXP 46
36274: PPUSH
36275: LD_STRING DA1-Cyrus-1a
36277: PPUSH
36278: CALL_OW 91
36282: GO 36601
36284: LD_EXP 42
36288: DOUBLE
36289: EQUAL
36290: IFTRUE 36294
36292: GO 36309
36294: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36295: LD_EXP 42
36299: PPUSH
36300: LD_STRING DA1-Huck-1a
36302: PPUSH
36303: CALL_OW 91
36307: GO 36601
36309: LD_EXP 56
36313: DOUBLE
36314: EQUAL
36315: IFTRUE 36319
36317: GO 36334
36319: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36320: LD_EXP 56
36324: PPUSH
36325: LD_STRING DA1-Huck-1a
36327: PPUSH
36328: CALL_OW 91
36332: GO 36601
36334: LD_EXP 48
36338: DOUBLE
36339: EQUAL
36340: IFTRUE 36344
36342: GO 36359
36344: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36345: LD_EXP 48
36349: PPUSH
36350: LD_STRING DA1-Brown-1a
36352: PPUSH
36353: CALL_OW 91
36357: GO 36601
36359: LD_EXP 52
36363: DOUBLE
36364: EQUAL
36365: IFTRUE 36369
36367: GO 36384
36369: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36370: LD_EXP 52
36374: PPUSH
36375: LD_STRING DA1-Gary-1a
36377: PPUSH
36378: CALL_OW 91
36382: GO 36601
36384: LD_EXP 55
36388: DOUBLE
36389: EQUAL
36390: IFTRUE 36394
36392: GO 36419
36394: POP
// if JMMGirl = 3 then
36395: LD_EXP 7
36399: PUSH
36400: LD_INT 3
36402: EQUAL
36403: IFFALSE 36417
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36405: LD_EXP 55
36409: PPUSH
36410: LD_STRING DA1-Con-1a
36412: PPUSH
36413: CALL_OW 91
36417: GO 36601
36419: LD_EXP 64
36423: DOUBLE
36424: EQUAL
36425: IFTRUE 36429
36427: GO 36444
36429: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36430: LD_EXP 64
36434: PPUSH
36435: LD_STRING DA1-Kurt-1a
36437: PPUSH
36438: CALL_OW 91
36442: GO 36601
36444: LD_EXP 54
36448: DOUBLE
36449: EQUAL
36450: IFTRUE 36454
36452: GO 36469
36454: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36455: LD_EXP 54
36459: PPUSH
36460: LD_STRING DA1-Yam-1a
36462: PPUSH
36463: CALL_OW 91
36467: GO 36601
36469: LD_EXP 53
36473: DOUBLE
36474: EQUAL
36475: IFTRUE 36479
36477: GO 36494
36479: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36480: LD_EXP 53
36484: PPUSH
36485: LD_STRING DA1-Frank-1a
36487: PPUSH
36488: CALL_OW 91
36492: GO 36601
36494: POP
// begin join := rand ( 0 , 1 ) ;
36495: LD_ADDR_VAR 0 3
36499: PUSH
36500: LD_INT 0
36502: PPUSH
36503: LD_INT 1
36505: PPUSH
36506: CALL_OW 12
36510: ST_TO_ADDR
// if join then
36511: LD_VAR 0 3
36515: IFFALSE 36560
// begin if GetSex ( unit ) = sex_male then
36517: LD_VAR 0 1
36521: PPUSH
36522: CALL_OW 258
36526: PUSH
36527: LD_INT 1
36529: EQUAL
36530: IFFALSE 36546
// ForceSay ( unit , DA1-Sol1-1b ) else
36532: LD_VAR 0 1
36536: PPUSH
36537: LD_STRING DA1-Sol1-1b
36539: PPUSH
36540: CALL_OW 91
36544: GO 36558
// ForceSay ( unit , DA1-FSol1-1b ) ;
36546: LD_VAR 0 1
36550: PPUSH
36551: LD_STRING DA1-FSol1-1b
36553: PPUSH
36554: CALL_OW 91
// end else
36558: GO 36601
// begin if GetSex ( unit ) = sex_male then
36560: LD_VAR 0 1
36564: PPUSH
36565: CALL_OW 258
36569: PUSH
36570: LD_INT 1
36572: EQUAL
36573: IFFALSE 36589
// ForceSay ( unit , DA1-Sol1-1a ) else
36575: LD_VAR 0 1
36579: PPUSH
36580: LD_STRING DA1-Sol1-1a
36582: PPUSH
36583: CALL_OW 91
36587: GO 36601
// ForceSay ( unit , DA1-FSol1-1a ) ;
36589: LD_VAR 0 1
36593: PPUSH
36594: LD_STRING DA1-FSol1-1a
36596: PPUSH
36597: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36601: LD_VAR 0 1
36605: PUSH
36606: LD_EXP 40
36610: EQUAL
36611: IFFALSE 36622
// begin YouLost ( JMMCaptured ) ;
36613: LD_STRING JMMCaptured
36615: PPUSH
36616: CALL_OW 104
// exit ;
36620: GO 36926
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36622: LD_VAR 0 1
36626: PUSH
36627: LD_EXP 44
36631: PUSH
36632: LD_EXP 47
36636: PUSH
36637: LD_EXP 45
36641: PUSH
36642: LD_EXP 42
36646: PUSH
36647: LD_EXP 56
36651: PUSH
36652: LD_EXP 48
36656: PUSH
36657: LD_EXP 54
36661: PUSH
36662: LD_EXP 58
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: IN
36677: PUSH
36678: LD_VAR 0 3
36682: OR
36683: IFFALSE 36782
// begin Say ( Roth , DA-Roth-3 ) ;
36685: LD_EXP 79
36689: PPUSH
36690: LD_STRING DA-Roth-3
36692: PPUSH
36693: CALL_OW 88
// SetSide ( unit , 7 ) ;
36697: LD_VAR 0 1
36701: PPUSH
36702: LD_INT 7
36704: PPUSH
36705: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36709: LD_ADDR_EXP 102
36713: PUSH
36714: LD_EXP 102
36718: PPUSH
36719: LD_INT 1
36721: PPUSH
36722: LD_EXP 102
36726: PUSH
36727: LD_INT 1
36729: ARRAY
36730: PUSH
36731: LD_VAR 0 1
36735: ADD
36736: PPUSH
36737: CALL_OW 1
36741: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36742: LD_INT 260
36744: PPUSH
36745: LD_INT 235
36747: PPUSH
36748: LD_INT 1
36750: PPUSH
36751: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36755: LD_VAR 0 1
36759: PPUSH
36760: LD_INT 1000
36762: PPUSH
36763: CALL_OW 234
// DialogueOff ;
36767: CALL_OW 7
// ComFree ( unit ) ;
36771: LD_VAR 0 1
36775: PPUSH
36776: CALL_OW 139
// end else
36780: GO 36863
// begin Say ( Roth , DA-Roth-3a ) ;
36782: LD_EXP 79
36786: PPUSH
36787: LD_STRING DA-Roth-3a
36789: PPUSH
36790: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36794: LD_ADDR_EXP 35
36798: PUSH
36799: LD_EXP 35
36803: PUSH
36804: LD_VAR 0 1
36808: ADD
36809: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36810: LD_INT 260
36812: PPUSH
36813: LD_INT 235
36815: PPUSH
36816: LD_INT 1
36818: PPUSH
36819: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36823: LD_VAR 0 1
36827: PPUSH
36828: LD_INT 1000
36830: PPUSH
36831: CALL_OW 234
// DialogueOff ;
36835: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36839: LD_VAR 0 1
36843: PPUSH
36844: LD_INT 272
36846: PPUSH
36847: LD_INT 254
36849: PPUSH
36850: CALL_OW 111
// AddComHold ( unit ) ;
36854: LD_VAR 0 1
36858: PPUSH
36859: CALL_OW 200
// end ; if capturedUnit = 1 then
36863: LD_EXP 34
36867: PUSH
36868: LD_INT 1
36870: EQUAL
36871: IFFALSE 36926
// begin DialogueOn ;
36873: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36877: LD_EXP 40
36881: PPUSH
36882: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36886: LD_EXP 40
36890: PPUSH
36891: LD_STRING DAa-JMM-1
36893: PPUSH
36894: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36898: LD_EXP 40
36902: PPUSH
36903: LD_STRING DAa-JMM-1a
36905: PPUSH
36906: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36910: LD_EXP 40
36914: PPUSH
36915: LD_STRING DAa-JMM-1b
36917: PPUSH
36918: CALL_OW 88
// DialogueOff ;
36922: CALL_OW 7
// end ; end ;
36926: LD_VAR 0 2
36930: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36931: LD_EXP 15
36935: PUSH
36936: LD_INT 13
36938: GREATEREQUAL
36939: PUSH
36940: LD_INT 22
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 21
36952: PUSH
36953: LD_INT 1
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PPUSH
36964: CALL_OW 69
36968: PUSH
36969: LD_INT 0
36971: EQUAL
36972: AND
36973: PUSH
36974: LD_INT 22
36976: PUSH
36977: LD_INT 2
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 33
36986: PUSH
36987: LD_INT 5
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 21
36996: PUSH
36997: LD_INT 2
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 50
37006: PUSH
37007: EMPTY
37008: LIST
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: PPUSH
37016: CALL_OW 69
37020: PUSH
37021: LD_INT 0
37023: EQUAL
37024: AND
37025: PUSH
37026: LD_EXP 21
37030: AND
37031: PUSH
37032: LD_EXP 22
37036: AND
37037: PUSH
37038: LD_EXP 23
37042: AND
37043: IFFALSE 37812
37045: GO 37047
37047: DISABLE
37048: LD_INT 0
37050: PPUSH
37051: PPUSH
37052: PPUSH
// begin wait ( 0 0$05 ) ;
37053: LD_INT 175
37055: PPUSH
37056: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37060: LD_INT 22
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 21
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 23
37082: PUSH
37083: LD_INT 1
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 50
37092: PUSH
37093: EMPTY
37094: LIST
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: LIST
37100: LIST
37101: PPUSH
37102: CALL_OW 69
37106: PPUSH
37107: CALL 72495 0 1
37111: PUSH
37112: LD_INT 2
37114: LESS
37115: IFFALSE 37126
// begin YouLost ( LostVictory ) ;
37117: LD_STRING LostVictory
37119: PPUSH
37120: CALL_OW 104
// exit ;
37124: GO 37812
// end ; m1 := false ;
37126: LD_ADDR_VAR 0 1
37130: PUSH
37131: LD_INT 0
37133: ST_TO_ADDR
// m2 := false ;
37134: LD_ADDR_VAR 0 2
37138: PUSH
37139: LD_INT 0
37141: ST_TO_ADDR
// m3 := false ;
37142: LD_ADDR_VAR 0 3
37146: PUSH
37147: LD_INT 0
37149: ST_TO_ADDR
// if not bombExploded then
37150: LD_EXP 37
37154: NOT
37155: IFFALSE 37164
// SetAchievement ( ACH_SIBROCKET ) ;
37157: LD_STRING ACH_SIBROCKET
37159: PPUSH
37160: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37164: LD_EXP 66
37168: PPUSH
37169: CALL_OW 255
37173: PUSH
37174: LD_INT 1
37176: EQUAL
37177: PUSH
37178: LD_EXP 66
37182: PPUSH
37183: CALL_OW 302
37187: AND
37188: IFFALSE 37204
// begin wait ( 3 ) ;
37190: LD_INT 3
37192: PPUSH
37193: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37197: LD_STRING ACH_OPO
37199: PPUSH
37200: CALL_OW 543
// end ; if tick <= 120 120$00 then
37204: LD_OWVAR 1
37208: PUSH
37209: LD_INT 252000
37211: LESSEQUAL
37212: IFFALSE 37228
// begin wait ( 3 ) ;
37214: LD_INT 3
37216: PPUSH
37217: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37221: LD_STRING ACH_ASPEED_15
37223: PPUSH
37224: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37228: LD_EXP 40
37232: PPUSH
37233: CALL_OW 87
// music_class := 5 ;
37237: LD_ADDR_OWVAR 72
37241: PUSH
37242: LD_INT 5
37244: ST_TO_ADDR
// music_nat := 5 ;
37245: LD_ADDR_OWVAR 71
37249: PUSH
37250: LD_INT 5
37252: ST_TO_ADDR
// DialogueOn ;
37253: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37257: LD_EXP 40
37261: PPUSH
37262: LD_STRING D20-JMM-1
37264: PPUSH
37265: CALL_OW 88
// if IsOK ( Joan ) then
37269: LD_EXP 41
37273: PPUSH
37274: CALL_OW 302
37278: IFFALSE 37292
// Say ( Joan , D20-Joan-1 ) ;
37280: LD_EXP 41
37284: PPUSH
37285: LD_STRING D20-Joan-1
37287: PPUSH
37288: CALL_OW 88
// if IsOk ( Lisa ) then
37292: LD_EXP 43
37296: PPUSH
37297: CALL_OW 302
37301: IFFALSE 37315
// Say ( Lisa , D20-Lisa-1 ) ;
37303: LD_EXP 43
37307: PPUSH
37308: LD_STRING D20-Lisa-1
37310: PPUSH
37311: CALL_OW 88
// if IsOk ( Donaldson ) then
37315: LD_EXP 44
37319: PPUSH
37320: CALL_OW 302
37324: IFFALSE 37338
// Say ( Donaldson , D20-Don-1 ) ;
37326: LD_EXP 44
37330: PPUSH
37331: LD_STRING D20-Don-1
37333: PPUSH
37334: CALL_OW 88
// if IsOK ( Cornel ) then
37338: LD_EXP 51
37342: PPUSH
37343: CALL_OW 302
37347: IFFALSE 37361
// Say ( Cornel , D20-Corn-1 ) ;
37349: LD_EXP 51
37353: PPUSH
37354: LD_STRING D20-Corn-1
37356: PPUSH
37357: CALL_OW 88
// if IsOk ( Denis ) then
37361: LD_EXP 47
37365: PPUSH
37366: CALL_OW 302
37370: IFFALSE 37384
// Say ( Denis , D20-Den-1 ) ;
37372: LD_EXP 47
37376: PPUSH
37377: LD_STRING D20-Den-1
37379: PPUSH
37380: CALL_OW 88
// if IsOk ( Bobby ) then
37384: LD_EXP 45
37388: PPUSH
37389: CALL_OW 302
37393: IFFALSE 37407
// Say ( Bobby , D20-Bobby-1 ) ;
37395: LD_EXP 45
37399: PPUSH
37400: LD_STRING D20-Bobby-1
37402: PPUSH
37403: CALL_OW 88
// if IsOk ( Gladstone ) then
37407: LD_EXP 49
37411: PPUSH
37412: CALL_OW 302
37416: IFFALSE 37430
// Say ( Gladstone , D20-Glad-1 ) ;
37418: LD_EXP 49
37422: PPUSH
37423: LD_STRING D20-Glad-1
37425: PPUSH
37426: CALL_OW 88
// if IsOk ( Cyrus ) then
37430: LD_EXP 46
37434: PPUSH
37435: CALL_OW 302
37439: IFFALSE 37453
// Say ( Cyrus , D20-Cyrus-1 ) ;
37441: LD_EXP 46
37445: PPUSH
37446: LD_STRING D20-Cyrus-1
37448: PPUSH
37449: CALL_OW 88
// if IsOk ( Stevens ) then
37453: LD_EXP 42
37457: PPUSH
37458: CALL_OW 302
37462: IFFALSE 37476
// Say ( Stevens , D20-Huck-1 ) ;
37464: LD_EXP 42
37468: PPUSH
37469: LD_STRING D20-Huck-1
37471: PPUSH
37472: CALL_OW 88
// if IsOk ( Brown ) then
37476: LD_EXP 48
37480: PPUSH
37481: CALL_OW 302
37485: IFFALSE 37499
// Say ( Brown , D20-Brown-1 ) ;
37487: LD_EXP 48
37491: PPUSH
37492: LD_STRING D20-Brown-1
37494: PPUSH
37495: CALL_OW 88
// if IsOk ( Gary ) then
37499: LD_EXP 52
37503: PPUSH
37504: CALL_OW 302
37508: IFFALSE 37522
// Say ( Gary , D20-Gary-1 ) ;
37510: LD_EXP 52
37514: PPUSH
37515: LD_STRING D20-Gary-1
37517: PPUSH
37518: CALL_OW 88
// if IsOk ( Connie ) then
37522: LD_EXP 55
37526: PPUSH
37527: CALL_OW 302
37531: IFFALSE 37545
// Say ( Connie , D20-Con-1 ) ;
37533: LD_EXP 55
37537: PPUSH
37538: LD_STRING D20-Con-1
37540: PPUSH
37541: CALL_OW 88
// if IsOk ( Kurt ) then
37545: LD_EXP 64
37549: PPUSH
37550: CALL_OW 302
37554: IFFALSE 37568
// Say ( Kurt , D20-Kurt-1 ) ;
37556: LD_EXP 64
37560: PPUSH
37561: LD_STRING D20-Kurt-1
37563: PPUSH
37564: CALL_OW 88
// if IsOk ( Kikuchi ) then
37568: LD_EXP 54
37572: PPUSH
37573: CALL_OW 302
37577: IFFALSE 37591
// Say ( Kikuchi , D20-Yam-1 ) ;
37579: LD_EXP 54
37583: PPUSH
37584: LD_STRING D20-Yam-1
37586: PPUSH
37587: CALL_OW 88
// if IsOk ( Frank ) then
37591: LD_EXP 53
37595: PPUSH
37596: CALL_OW 302
37600: IFFALSE 37614
// Say ( Frank , D20-Frank-1 ) ;
37602: LD_EXP 53
37606: PPUSH
37607: LD_STRING D20-Frank-1
37609: PPUSH
37610: CALL_OW 88
// DialogueOff ;
37614: CALL_OW 7
// if RothCaptured then
37618: LD_EXP 33
37622: IFFALSE 37644
// begin m1 := true ;
37624: LD_ADDR_VAR 0 1
37628: PUSH
37629: LD_INT 1
37631: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37632: LD_STRING Roth
37634: PPUSH
37635: LD_INT 1
37637: PPUSH
37638: CALL_OW 101
// end else
37642: GO 37655
// AddMedal ( Roth , - 1 ) ;
37644: LD_STRING Roth
37646: PPUSH
37647: LD_INT 1
37649: NEG
37650: PPUSH
37651: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37655: LD_EXP 25
37659: NOT
37660: PUSH
37661: LD_EXP 27
37665: OR
37666: PUSH
37667: LD_EXP 28
37671: NOT
37672: OR
37673: IFFALSE 37695
// begin m2 := true ;
37675: LD_ADDR_VAR 0 2
37679: PUSH
37680: LD_INT 1
37682: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37683: LD_STRING Project
37685: PPUSH
37686: LD_INT 1
37688: PPUSH
37689: CALL_OW 101
// end else
37693: GO 37706
// AddMedal ( Project , - 1 ) ;
37695: LD_STRING Project
37697: PPUSH
37698: LD_INT 1
37700: NEG
37701: PPUSH
37702: CALL_OW 101
// if lostCounter = 0 then
37706: LD_EXP 32
37710: PUSH
37711: LD_INT 0
37713: EQUAL
37714: IFFALSE 37736
// begin m3 := true ;
37716: LD_ADDR_VAR 0 3
37720: PUSH
37721: LD_INT 1
37723: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37724: LD_STRING NoLosses
37726: PPUSH
37727: LD_INT 1
37729: PPUSH
37730: CALL_OW 101
// end else
37734: GO 37747
// AddMedal ( NoLosses , - 1 ) ;
37736: LD_STRING NoLosses
37738: PPUSH
37739: LD_INT 1
37741: NEG
37742: PPUSH
37743: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37747: LD_VAR 0 1
37751: PUSH
37752: LD_VAR 0 2
37756: AND
37757: PUSH
37758: LD_VAR 0 3
37762: AND
37763: PUSH
37764: LD_OWVAR 67
37768: PUSH
37769: LD_INT 3
37771: GREATEREQUAL
37772: AND
37773: IFFALSE 37785
// SetAchievementEX ( ACH_AMER , 15 ) ;
37775: LD_STRING ACH_AMER
37777: PPUSH
37778: LD_INT 15
37780: PPUSH
37781: CALL_OW 564
// GiveMedals ( MAIN ) ;
37785: LD_STRING MAIN
37787: PPUSH
37788: CALL_OW 102
// music_class := 4 ;
37792: LD_ADDR_OWVAR 72
37796: PUSH
37797: LD_INT 4
37799: ST_TO_ADDR
// music_nat := 1 ;
37800: LD_ADDR_OWVAR 71
37804: PUSH
37805: LD_INT 1
37807: ST_TO_ADDR
// YouWin ;
37808: CALL_OW 103
// end ; end_of_file
37812: PPOPN 3
37814: END
// export function CustomEvent ( event ) ; begin
37815: LD_INT 0
37817: PPUSH
// end ;
37818: LD_VAR 0 2
37822: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37823: LD_VAR 0 1
37827: PUSH
37828: LD_INT 1
37830: EQUAL
37831: PUSH
37832: LD_VAR 0 2
37836: PUSH
37837: LD_INT 4
37839: EQUAL
37840: AND
37841: PUSH
37842: LD_EXP 61
37846: PPUSH
37847: CALL_OW 300
37851: AND
37852: IFFALSE 37868
// begin wait ( 0 0$2 ) ;
37854: LD_INT 70
37856: PPUSH
37857: CALL_OW 67
// YouLost ( Dismissed ) ;
37861: LD_STRING Dismissed
37863: PPUSH
37864: CALL_OW 104
// end ; end ;
37868: PPOPN 2
37870: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37871: LD_VAR 0 2
37875: PPUSH
37876: LD_VAR 0 3
37880: PPUSH
37881: LD_INT 18
37883: PPUSH
37884: CALL_OW 309
37888: IFFALSE 37897
// YouLost ( Motherlode3 ) ;
37890: LD_STRING Motherlode3
37892: PPUSH
37893: CALL_OW 104
// end ;
37897: PPOPN 3
37899: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37900: LD_EXP 27
37904: NOT
37905: IFFALSE 37915
// behemothDone := true ;
37907: LD_ADDR_EXP 28
37911: PUSH
37912: LD_INT 1
37914: ST_TO_ADDR
// end ;
37915: PPOPN 1
37917: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37918: LD_VAR 0 1
37922: PPUSH
37923: CALL_OW 255
37927: PUSH
37928: LD_INT 1
37930: EQUAL
37931: IFFALSE 37941
// bombExploded := true ;
37933: LD_ADDR_EXP 37
37937: PUSH
37938: LD_INT 1
37940: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37941: LD_VAR 0 1
37945: PPUSH
37946: CALL_OW 255
37950: PUSH
37951: LD_INT 3
37953: EQUAL
37954: IFFALSE 37984
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37956: LD_INT 2
37958: PPUSH
37959: LD_INT 23
37961: PUSH
37962: LD_INT 3
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: LD_INT 48
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: PUSH
37977: EMPTY
37978: LIST
37979: PPUSH
37980: CALL 63883 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37984: LD_VAR 0 1
37988: PPUSH
37989: CALL_OW 255
37993: PUSH
37994: LD_INT 1
37996: EQUAL
37997: PUSH
37998: LD_EXP 66
38002: PPUSH
38003: CALL_OW 255
38007: PUSH
38008: LD_INT 1
38010: EQUAL
38011: AND
38012: PUSH
38013: LD_EXP 66
38017: PPUSH
38018: CALL_OW 302
38022: AND
38023: PUSH
38024: LD_EXP 30
38028: AND
38029: PUSH
38030: LD_INT 22
38032: PUSH
38033: LD_INT 3
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 34
38042: PUSH
38043: LD_INT 48
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PPUSH
38054: CALL_OW 69
38058: AND
38059: PUSH
38060: LD_INT 22
38062: PUSH
38063: LD_INT 1
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 34
38072: PUSH
38073: LD_INT 8
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PPUSH
38084: CALL_OW 69
38088: NOT
38089: AND
38090: IFFALSE 38142
// begin wait ( 0 0$5 ) ;
38092: LD_INT 175
38094: PPUSH
38095: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38099: LD_INT 22
38101: PUSH
38102: LD_INT 3
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 34
38111: PUSH
38112: LD_INT 48
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PPUSH
38123: CALL_OW 69
38127: PUSH
38128: LD_INT 1
38130: ARRAY
38131: PPUSH
38132: LD_INT 60
38134: PPUSH
38135: LD_INT 95
38137: PPUSH
38138: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38142: LD_VAR 0 2
38146: PPUSH
38147: LD_VAR 0 3
38151: PPUSH
38152: LD_INT 18
38154: PPUSH
38155: CALL_OW 309
38159: PUSH
38160: LD_VAR 0 2
38164: PPUSH
38165: LD_VAR 0 3
38169: PPUSH
38170: LD_INT 18
38172: PPUSH
38173: CALL 111923 0 3
38177: OR
38178: IFFALSE 38225
// begin if GetSide ( unit ) = 1 then
38180: LD_VAR 0 1
38184: PPUSH
38185: CALL_OW 255
38189: PUSH
38190: LD_INT 1
38192: EQUAL
38193: IFFALSE 38211
// begin wait ( 0 0$6 ) ;
38195: LD_INT 210
38197: PPUSH
38198: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38202: LD_STRING Motherlode2
38204: PPUSH
38205: CALL_OW 104
// end else
38209: GO 38225
// begin wait ( 0 0$6 ) ;
38211: LD_INT 210
38213: PPUSH
38214: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38218: LD_STRING Motherlode1
38220: PPUSH
38221: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38225: LD_VAR 0 1
38229: PPUSH
38230: CALL_OW 255
38234: PUSH
38235: LD_INT 3
38237: EQUAL
38238: IFFALSE 38259
// begin wait ( 0 0$5 ) ;
38240: LD_INT 175
38242: PPUSH
38243: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38247: LD_EXP 68
38251: PPUSH
38252: LD_STRING D18-Pla-1
38254: PPUSH
38255: CALL_OW 94
// end ; end ;
38259: PPOPN 3
38261: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38262: LD_VAR 0 1
38266: PPUSH
38267: CALL 129141 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38271: LD_VAR 0 1
38275: PUSH
38276: LD_INT 22
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 21
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 23
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: LIST
38310: PPUSH
38311: CALL_OW 69
38315: IN
38316: IFFALSE 38332
// lostCounter := lostCounter + 1 ;
38318: LD_ADDR_EXP 32
38322: PUSH
38323: LD_EXP 32
38327: PUSH
38328: LD_INT 1
38330: PLUS
38331: ST_TO_ADDR
// if un in behemothBuilders then
38332: LD_VAR 0 1
38336: PUSH
38337: LD_EXP 77
38341: IN
38342: IFFALSE 38362
// begin behemothBuilders := behemothBuilders diff un ;
38344: LD_ADDR_EXP 77
38348: PUSH
38349: LD_EXP 77
38353: PUSH
38354: LD_VAR 0 1
38358: DIFF
38359: ST_TO_ADDR
// exit ;
38360: GO 38392
// end ; if un = JMM then
38362: LD_VAR 0 1
38366: PUSH
38367: LD_EXP 40
38371: EQUAL
38372: IFFALSE 38383
// begin YouLost ( JMM ) ;
38374: LD_STRING JMM
38376: PPUSH
38377: CALL_OW 104
// exit ;
38381: GO 38392
// end ; MCE_UnitDestroyed ( un ) ;
38383: LD_VAR 0 1
38387: PPUSH
38388: CALL 67325 0 1
// end ;
38392: PPOPN 1
38394: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38395: LD_VAR 0 1
38399: PPUSH
38400: LD_VAR 0 2
38404: PPUSH
38405: CALL 69657 0 2
// end ;
38409: PPOPN 2
38411: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38412: LD_VAR 0 1
38416: PPUSH
38417: CALL 68725 0 1
// end ;
38421: PPOPN 1
38423: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38424: LD_VAR 0 1
38428: PUSH
38429: LD_INT 22
38431: PUSH
38432: LD_INT 8
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 30
38441: PUSH
38442: LD_INT 2
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 23
38451: PUSH
38452: LD_INT 3
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: LIST
38463: PPUSH
38464: CALL_OW 69
38468: IN
38469: IFFALSE 38496
// begin ComUpgrade ( building ) ;
38471: LD_VAR 0 1
38475: PPUSH
38476: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38480: LD_EXP 65
38484: PPUSH
38485: LD_VAR 0 1
38489: PPUSH
38490: CALL 78593 0 2
// exit ;
38494: GO 38505
// end ; MCE_BuildingComplete ( building ) ;
38496: LD_VAR 0 1
38500: PPUSH
38501: CALL 68966 0 1
// end ;
38505: PPOPN 1
38507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38508: LD_VAR 0 1
38512: PPUSH
38513: LD_VAR 0 2
38517: PPUSH
38518: CALL 67021 0 2
// end ;
38522: PPOPN 2
38524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38525: LD_VAR 0 1
38529: PPUSH
38530: LD_VAR 0 2
38534: PPUSH
38535: LD_VAR 0 3
38539: PPUSH
38540: LD_VAR 0 4
38544: PPUSH
38545: LD_VAR 0 5
38549: PPUSH
38550: CALL 66641 0 5
// end ;
38554: PPOPN 5
38556: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38557: LD_VAR 0 1
38561: PPUSH
38562: CALL_OW 255
38566: PUSH
38567: LD_INT 1
38569: EQUAL
38570: IFFALSE 38587
// amConstructCounter := Inc ( amConstructCounter ) ;
38572: LD_ADDR_EXP 39
38576: PUSH
38577: LD_EXP 39
38581: PPUSH
38582: CALL 109465 0 1
38586: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38587: LD_VAR 0 1
38591: PPUSH
38592: LD_VAR 0 2
38596: PPUSH
38597: CALL 129199 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38601: LD_VAR 0 1
38605: PPUSH
38606: LD_VAR 0 2
38610: PPUSH
38611: CALL 66194 0 2
// end ;
38615: PPOPN 2
38617: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38618: LD_VAR 0 1
38622: PPUSH
38623: LD_VAR 0 2
38627: PPUSH
38628: LD_VAR 0 3
38632: PPUSH
38633: LD_VAR 0 4
38637: PPUSH
38638: CALL 66032 0 4
// end ;
38642: PPOPN 4
38644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38645: LD_VAR 0 1
38649: PPUSH
38650: LD_VAR 0 2
38654: PPUSH
38655: LD_VAR 0 3
38659: PPUSH
38660: CALL 65807 0 3
// end ;
38664: PPOPN 3
38666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38667: LD_VAR 0 1
38671: PPUSH
38672: LD_VAR 0 2
38676: PPUSH
38677: CALL 65692 0 2
// end ;
38681: PPOPN 2
38683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38684: LD_VAR 0 1
38688: PPUSH
38689: LD_VAR 0 2
38693: PPUSH
38694: CALL 69952 0 2
// end ;
38698: PPOPN 2
38700: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38701: LD_VAR 0 1
38705: PUSH
38706: LD_INT 460
38708: EQUAL
38709: IFFALSE 38731
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38711: LD_VAR 0 2
38715: PPUSH
38716: LD_INT 227
38718: PPUSH
38719: LD_INT 136
38721: PPUSH
38722: CALL_OW 428
38726: PPUSH
38727: CALL_OW 120
// end ;
38731: PPOPN 2
38733: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
38734: LD_VAR 0 1
38738: PPUSH
38739: CALL_OW 255
38743: PUSH
38744: LD_INT 4
38746: EQUAL
38747: PUSH
38748: LD_VAR 0 1
38752: PUSH
38753: LD_EXP 18
38757: PUSH
38758: LD_INT 1
38760: ARRAY
38761: IN
38762: AND
38763: PUSH
38764: LD_EXP 19
38768: AND
38769: IFFALSE 38788
// begin ComMoveXY ( driver , 61 , 93 ) ;
38771: LD_VAR 0 1
38775: PPUSH
38776: LD_INT 61
38778: PPUSH
38779: LD_INT 93
38781: PPUSH
38782: CALL_OW 111
// exit ;
38786: GO 38857
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38788: LD_VAR 0 1
38792: PPUSH
38793: CALL_OW 255
38797: PUSH
38798: LD_INT 3
38800: EQUAL
38801: PUSH
38802: LD_VAR 0 1
38806: PPUSH
38807: CALL_OW 110
38811: PUSH
38812: LD_INT 105
38814: EQUAL
38815: AND
38816: IFFALSE 38833
// begin ComMoveXY ( driver , 187 , 92 ) ;
38818: LD_VAR 0 1
38822: PPUSH
38823: LD_INT 187
38825: PPUSH
38826: LD_INT 92
38828: PPUSH
38829: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38833: LD_VAR 0 1
38837: PPUSH
38838: LD_VAR 0 2
38842: PPUSH
38843: LD_VAR 0 3
38847: PPUSH
38848: LD_VAR 0 4
38852: PPUSH
38853: CALL 70168 0 4
// end ;
38857: PPOPN 4
38859: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38860: LD_VAR 0 1
38864: PPUSH
38865: LD_VAR 0 2
38869: PPUSH
38870: CALL 65501 0 2
// end ;
38874: PPOPN 2
38876: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38877: LD_VAR 0 1
38881: PPUSH
38882: CALL 129183 0 1
// end ; end_of_file
38886: PPOPN 1
38888: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38889: LD_EXP 15
38893: PUSH
38894: LD_INT 2
38896: EQUAL
38897: IFFALSE 39414
38899: GO 38901
38901: DISABLE
38902: LD_INT 0
38904: PPUSH
38905: PPUSH
// begin time := 0 0$35 ;
38906: LD_ADDR_VAR 0 2
38910: PUSH
38911: LD_INT 1225
38913: ST_TO_ADDR
// repeat wait ( time ) ;
38914: LD_VAR 0 2
38918: PPUSH
38919: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38923: LD_INT 1
38925: PPUSH
38926: LD_INT 5
38928: PPUSH
38929: CALL_OW 12
38933: PPUSH
38934: LD_INT 106
38936: PPUSH
38937: LD_INT 150
38939: PPUSH
38940: LD_INT 19
38942: PPUSH
38943: LD_INT 1
38945: PPUSH
38946: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38950: LD_INT 455
38952: PPUSH
38953: LD_INT 770
38955: PPUSH
38956: CALL_OW 12
38960: PPUSH
38961: CALL_OW 67
// if Prob ( 50 ) then
38965: LD_INT 50
38967: PPUSH
38968: CALL_OW 13
38972: IFFALSE 39001
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38974: LD_INT 1
38976: PPUSH
38977: LD_INT 5
38979: PPUSH
38980: CALL_OW 12
38984: PPUSH
38985: LD_INT 62
38987: PPUSH
38988: LD_INT 108
38990: PPUSH
38991: LD_INT 10
38993: PPUSH
38994: LD_INT 1
38996: PPUSH
38997: CALL_OW 56
// until missionStage > 4 ;
39001: LD_EXP 15
39005: PUSH
39006: LD_INT 4
39008: GREATER
39009: IFFALSE 38914
// repeat wait ( 0 0$1 ) ;
39011: LD_INT 35
39013: PPUSH
39014: CALL_OW 67
// until missionStage = 6 ;
39018: LD_EXP 15
39022: PUSH
39023: LD_INT 6
39025: EQUAL
39026: IFFALSE 39011
// time := 0 0$20 ;
39028: LD_ADDR_VAR 0 2
39032: PUSH
39033: LD_INT 700
39035: ST_TO_ADDR
// repeat wait ( time ) ;
39036: LD_VAR 0 2
39040: PPUSH
39041: CALL_OW 67
// if Prob ( 90 ) then
39045: LD_INT 90
39047: PPUSH
39048: CALL_OW 13
39052: IFFALSE 39095
// begin time := time + 0 0$2 ;
39054: LD_ADDR_VAR 0 2
39058: PUSH
39059: LD_VAR 0 2
39063: PUSH
39064: LD_INT 70
39066: PLUS
39067: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39068: LD_INT 1
39070: PPUSH
39071: LD_INT 5
39073: PPUSH
39074: CALL_OW 12
39078: PPUSH
39079: LD_INT 106
39081: PPUSH
39082: LD_INT 89
39084: PPUSH
39085: LD_INT 45
39087: PPUSH
39088: LD_INT 1
39090: PPUSH
39091: CALL_OW 56
// end ; if Prob ( 45 ) then
39095: LD_INT 45
39097: PPUSH
39098: CALL_OW 13
39102: IFFALSE 39158
// begin for i := 1 to 4 do
39104: LD_ADDR_VAR 0 1
39108: PUSH
39109: DOUBLE
39110: LD_INT 1
39112: DEC
39113: ST_TO_ADDR
39114: LD_INT 4
39116: PUSH
39117: FOR_TO
39118: IFFALSE 39156
// begin wait ( 0 0$5 ) ;
39120: LD_INT 175
39122: PPUSH
39123: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39127: LD_INT 1
39129: PPUSH
39130: LD_INT 5
39132: PPUSH
39133: CALL_OW 12
39137: PPUSH
39138: LD_INT 113
39140: PPUSH
39141: LD_INT 117
39143: PPUSH
39144: LD_INT 25
39146: PPUSH
39147: LD_INT 1
39149: PPUSH
39150: CALL_OW 56
// end ;
39154: GO 39117
39156: POP
39157: POP
// end ; if Prob ( 40 ) then
39158: LD_INT 40
39160: PPUSH
39161: CALL_OW 13
39165: IFFALSE 39211
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39167: LD_INT 385
39169: PPUSH
39170: LD_INT 945
39172: PPUSH
39173: CALL_OW 12
39177: PPUSH
39178: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39182: LD_INT 1
39184: PPUSH
39185: LD_INT 5
39187: PPUSH
39188: CALL_OW 12
39192: PPUSH
39193: LD_INT 21
39195: PPUSH
39196: LD_INT 26
39198: PPUSH
39199: LD_INT 12
39201: PPUSH
39202: LD_INT 1
39204: PPUSH
39205: CALL_OW 56
// end else
39209: GO 39247
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39211: LD_INT 700
39213: PPUSH
39214: LD_INT 1225
39216: PPUSH
39217: CALL_OW 12
39221: PPUSH
39222: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39226: LD_INT 1
39228: PPUSH
39229: LD_INT 5
39231: PPUSH
39232: CALL_OW 12
39236: PPUSH
39237: LD_INT 16
39239: PPUSH
39240: LD_INT 1
39242: PPUSH
39243: CALL_OW 55
// end ; if Prob ( 50 ) then
39247: LD_INT 50
39249: PPUSH
39250: CALL_OW 13
39254: IFFALSE 39300
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39256: LD_INT 700
39258: PPUSH
39259: LD_INT 1050
39261: PPUSH
39262: CALL_OW 12
39266: PPUSH
39267: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39271: LD_INT 1
39273: PPUSH
39274: LD_INT 5
39276: PPUSH
39277: CALL_OW 12
39281: PPUSH
39282: LD_INT 168
39284: PPUSH
39285: LD_INT 168
39287: PPUSH
39288: LD_INT 16
39290: PPUSH
39291: LD_INT 1
39293: PPUSH
39294: CALL_OW 56
// end else
39298: GO 39336
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39300: LD_INT 350
39302: PPUSH
39303: LD_INT 525
39305: PPUSH
39306: CALL_OW 12
39310: PPUSH
39311: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39315: LD_INT 1
39317: PPUSH
39318: LD_INT 5
39320: PPUSH
39321: CALL_OW 12
39325: PPUSH
39326: LD_INT 15
39328: PPUSH
39329: LD_INT 1
39331: PPUSH
39332: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39336: LD_INT 175
39338: PPUSH
39339: LD_INT 315
39341: PPUSH
39342: CALL_OW 12
39346: PPUSH
39347: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39351: LD_INT 1
39353: PPUSH
39354: LD_INT 5
39356: PPUSH
39357: CALL_OW 12
39361: PPUSH
39362: LD_INT 103
39364: PPUSH
39365: LD_INT 140
39367: PPUSH
39368: LD_INT 20
39370: PPUSH
39371: LD_INT 1
39373: PPUSH
39374: CALL_OW 56
// time := time + 0 0$2 ;
39378: LD_ADDR_VAR 0 2
39382: PUSH
39383: LD_VAR 0 2
39387: PUSH
39388: LD_INT 70
39390: PLUS
39391: ST_TO_ADDR
// if time > 1 1$20 then
39392: LD_VAR 0 2
39396: PUSH
39397: LD_INT 2800
39399: GREATER
39400: IFFALSE 39410
// time := 0 0$30 ;
39402: LD_ADDR_VAR 0 2
39406: PUSH
39407: LD_INT 1050
39409: ST_TO_ADDR
// until false ;
39410: LD_INT 0
39412: IFFALSE 39036
// end ; end_of_file
39414: PPOPN 2
39416: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39417: LD_EXP 13
39421: PUSH
39422: LD_EXP 15
39426: PUSH
39427: LD_INT 6
39429: GREATEREQUAL
39430: AND
39431: IFFALSE 39468
39433: GO 39435
39435: DISABLE
// begin enable ;
39436: ENABLE
// missionTime := missionTime + 0 0$1 ;
39437: LD_ADDR_EXP 14
39441: PUSH
39442: LD_EXP 14
39446: PUSH
39447: LD_INT 35
39449: PLUS
39450: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39451: LD_ADDR_OWVAR 47
39455: PUSH
39456: LD_STRING #Am15-1
39458: PUSH
39459: LD_EXP 14
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: ST_TO_ADDR
// end ; end_of_file
39468: END
// export function InitNature ; begin
39469: LD_INT 0
39471: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39472: LD_INT 3
39474: PPUSH
39475: LD_INT 3
39477: PPUSH
39478: LD_INT 2
39480: PPUSH
39481: LD_INT 1
39483: PPUSH
39484: LD_INT 1
39486: PPUSH
39487: LD_INT 0
39489: PPUSH
39490: LD_INT 0
39492: PPUSH
39493: LD_INT 20
39495: PPUSH
39496: LD_INT 0
39498: PPUSH
39499: CALL 104781 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39503: LD_INT 2
39505: PPUSH
39506: LD_INT 1
39508: PPUSH
39509: LD_INT 1
39511: PPUSH
39512: LD_INT 1
39514: PPUSH
39515: LD_INT 1
39517: PPUSH
39518: LD_INT 0
39520: PPUSH
39521: LD_INT 0
39523: PPUSH
39524: LD_INT 21
39526: PPUSH
39527: LD_INT 0
39529: PPUSH
39530: CALL 104781 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39534: LD_INT 4
39536: PPUSH
39537: LD_INT 1
39539: PPUSH
39540: LD_INT 2
39542: PPUSH
39543: LD_INT 4
39545: PPUSH
39546: LD_INT 2
39548: PPUSH
39549: LD_INT 1
39551: PPUSH
39552: LD_INT 0
39554: PPUSH
39555: LD_INT 22
39557: PPUSH
39558: LD_INT 0
39560: PPUSH
39561: CALL 104781 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39565: LD_INT 0
39567: PPUSH
39568: LD_INT 0
39570: PPUSH
39571: LD_INT 0
39573: PPUSH
39574: LD_INT 0
39576: PPUSH
39577: LD_INT 0
39579: PPUSH
39580: LD_INT 0
39582: PPUSH
39583: LD_INT 9
39585: PPUSH
39586: LD_INT 0
39588: PPUSH
39589: LD_INT 23
39591: PPUSH
39592: CALL 104781 0 9
// end ; end_of_file
39596: LD_VAR 0 1
39600: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39601: LD_INT 0
39603: PPUSH
39604: PPUSH
// skirmish := false ;
39605: LD_ADDR_EXP 100
39609: PUSH
39610: LD_INT 0
39612: ST_TO_ADDR
// debug_mc := false ;
39613: LD_ADDR_EXP 101
39617: PUSH
39618: LD_INT 0
39620: ST_TO_ADDR
// mc_bases := [ ] ;
39621: LD_ADDR_EXP 102
39625: PUSH
39626: EMPTY
39627: ST_TO_ADDR
// mc_sides := [ ] ;
39628: LD_ADDR_EXP 128
39632: PUSH
39633: EMPTY
39634: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39635: LD_ADDR_EXP 103
39639: PUSH
39640: EMPTY
39641: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39642: LD_ADDR_EXP 104
39646: PUSH
39647: EMPTY
39648: ST_TO_ADDR
// mc_need_heal := [ ] ;
39649: LD_ADDR_EXP 105
39653: PUSH
39654: EMPTY
39655: ST_TO_ADDR
// mc_healers := [ ] ;
39656: LD_ADDR_EXP 106
39660: PUSH
39661: EMPTY
39662: ST_TO_ADDR
// mc_build_list := [ ] ;
39663: LD_ADDR_EXP 107
39667: PUSH
39668: EMPTY
39669: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39670: LD_ADDR_EXP 134
39674: PUSH
39675: EMPTY
39676: ST_TO_ADDR
// mc_builders := [ ] ;
39677: LD_ADDR_EXP 108
39681: PUSH
39682: EMPTY
39683: ST_TO_ADDR
// mc_construct_list := [ ] ;
39684: LD_ADDR_EXP 109
39688: PUSH
39689: EMPTY
39690: ST_TO_ADDR
// mc_turret_list := [ ] ;
39691: LD_ADDR_EXP 110
39695: PUSH
39696: EMPTY
39697: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39698: LD_ADDR_EXP 111
39702: PUSH
39703: EMPTY
39704: ST_TO_ADDR
// mc_miners := [ ] ;
39705: LD_ADDR_EXP 116
39709: PUSH
39710: EMPTY
39711: ST_TO_ADDR
// mc_mines := [ ] ;
39712: LD_ADDR_EXP 115
39716: PUSH
39717: EMPTY
39718: ST_TO_ADDR
// mc_minefields := [ ] ;
39719: LD_ADDR_EXP 117
39723: PUSH
39724: EMPTY
39725: ST_TO_ADDR
// mc_crates := [ ] ;
39726: LD_ADDR_EXP 118
39730: PUSH
39731: EMPTY
39732: ST_TO_ADDR
// mc_crates_collector := [ ] ;
39733: LD_ADDR_EXP 119
39737: PUSH
39738: EMPTY
39739: ST_TO_ADDR
// mc_crates_area := [ ] ;
39740: LD_ADDR_EXP 120
39744: PUSH
39745: EMPTY
39746: ST_TO_ADDR
// mc_vehicles := [ ] ;
39747: LD_ADDR_EXP 121
39751: PUSH
39752: EMPTY
39753: ST_TO_ADDR
// mc_attack := [ ] ;
39754: LD_ADDR_EXP 122
39758: PUSH
39759: EMPTY
39760: ST_TO_ADDR
// mc_produce := [ ] ;
39761: LD_ADDR_EXP 123
39765: PUSH
39766: EMPTY
39767: ST_TO_ADDR
// mc_defender := [ ] ;
39768: LD_ADDR_EXP 124
39772: PUSH
39773: EMPTY
39774: ST_TO_ADDR
// mc_parking := [ ] ;
39775: LD_ADDR_EXP 126
39779: PUSH
39780: EMPTY
39781: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39782: LD_ADDR_EXP 112
39786: PUSH
39787: EMPTY
39788: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39789: LD_ADDR_EXP 114
39793: PUSH
39794: EMPTY
39795: ST_TO_ADDR
// mc_scan := [ ] ;
39796: LD_ADDR_EXP 125
39800: PUSH
39801: EMPTY
39802: ST_TO_ADDR
// mc_scan_area := [ ] ;
39803: LD_ADDR_EXP 127
39807: PUSH
39808: EMPTY
39809: ST_TO_ADDR
// mc_tech := [ ] ;
39810: LD_ADDR_EXP 129
39814: PUSH
39815: EMPTY
39816: ST_TO_ADDR
// mc_class := [ ] ;
39817: LD_ADDR_EXP 143
39821: PUSH
39822: EMPTY
39823: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39824: LD_ADDR_EXP 144
39828: PUSH
39829: EMPTY
39830: ST_TO_ADDR
// mc_is_defending := [ ] ;
39831: LD_ADDR_EXP 145
39835: PUSH
39836: EMPTY
39837: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39838: LD_ADDR_EXP 136
39842: PUSH
39843: EMPTY
39844: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39845: LD_ADDR_EXP 146
39849: PUSH
39850: LD_INT 0
39852: ST_TO_ADDR
// end ;
39853: LD_VAR 0 1
39857: RET
// export function MC_Kill ( base ) ; begin
39858: LD_INT 0
39860: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39861: LD_ADDR_EXP 102
39865: PUSH
39866: LD_EXP 102
39870: PPUSH
39871: LD_VAR 0 1
39875: PPUSH
39876: EMPTY
39877: PPUSH
39878: CALL_OW 1
39882: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39883: LD_ADDR_EXP 103
39887: PUSH
39888: LD_EXP 103
39892: PPUSH
39893: LD_VAR 0 1
39897: PPUSH
39898: EMPTY
39899: PPUSH
39900: CALL_OW 1
39904: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39905: LD_ADDR_EXP 104
39909: PUSH
39910: LD_EXP 104
39914: PPUSH
39915: LD_VAR 0 1
39919: PPUSH
39920: EMPTY
39921: PPUSH
39922: CALL_OW 1
39926: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39927: LD_ADDR_EXP 105
39931: PUSH
39932: LD_EXP 105
39936: PPUSH
39937: LD_VAR 0 1
39941: PPUSH
39942: EMPTY
39943: PPUSH
39944: CALL_OW 1
39948: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39949: LD_ADDR_EXP 106
39953: PUSH
39954: LD_EXP 106
39958: PPUSH
39959: LD_VAR 0 1
39963: PPUSH
39964: EMPTY
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39971: LD_ADDR_EXP 107
39975: PUSH
39976: LD_EXP 107
39980: PPUSH
39981: LD_VAR 0 1
39985: PPUSH
39986: EMPTY
39987: PPUSH
39988: CALL_OW 1
39992: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39993: LD_ADDR_EXP 108
39997: PUSH
39998: LD_EXP 108
40002: PPUSH
40003: LD_VAR 0 1
40007: PPUSH
40008: EMPTY
40009: PPUSH
40010: CALL_OW 1
40014: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40015: LD_ADDR_EXP 109
40019: PUSH
40020: LD_EXP 109
40024: PPUSH
40025: LD_VAR 0 1
40029: PPUSH
40030: EMPTY
40031: PPUSH
40032: CALL_OW 1
40036: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40037: LD_ADDR_EXP 110
40041: PUSH
40042: LD_EXP 110
40046: PPUSH
40047: LD_VAR 0 1
40051: PPUSH
40052: EMPTY
40053: PPUSH
40054: CALL_OW 1
40058: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40059: LD_ADDR_EXP 111
40063: PUSH
40064: LD_EXP 111
40068: PPUSH
40069: LD_VAR 0 1
40073: PPUSH
40074: EMPTY
40075: PPUSH
40076: CALL_OW 1
40080: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40081: LD_ADDR_EXP 112
40085: PUSH
40086: LD_EXP 112
40090: PPUSH
40091: LD_VAR 0 1
40095: PPUSH
40096: EMPTY
40097: PPUSH
40098: CALL_OW 1
40102: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40103: LD_ADDR_EXP 113
40107: PUSH
40108: LD_EXP 113
40112: PPUSH
40113: LD_VAR 0 1
40117: PPUSH
40118: LD_INT 0
40120: PPUSH
40121: CALL_OW 1
40125: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40126: LD_ADDR_EXP 114
40130: PUSH
40131: LD_EXP 114
40135: PPUSH
40136: LD_VAR 0 1
40140: PPUSH
40141: EMPTY
40142: PPUSH
40143: CALL_OW 1
40147: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40148: LD_ADDR_EXP 115
40152: PUSH
40153: LD_EXP 115
40157: PPUSH
40158: LD_VAR 0 1
40162: PPUSH
40163: EMPTY
40164: PPUSH
40165: CALL_OW 1
40169: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40170: LD_ADDR_EXP 116
40174: PUSH
40175: LD_EXP 116
40179: PPUSH
40180: LD_VAR 0 1
40184: PPUSH
40185: EMPTY
40186: PPUSH
40187: CALL_OW 1
40191: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40192: LD_ADDR_EXP 117
40196: PUSH
40197: LD_EXP 117
40201: PPUSH
40202: LD_VAR 0 1
40206: PPUSH
40207: EMPTY
40208: PPUSH
40209: CALL_OW 1
40213: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40214: LD_ADDR_EXP 118
40218: PUSH
40219: LD_EXP 118
40223: PPUSH
40224: LD_VAR 0 1
40228: PPUSH
40229: EMPTY
40230: PPUSH
40231: CALL_OW 1
40235: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40236: LD_ADDR_EXP 119
40240: PUSH
40241: LD_EXP 119
40245: PPUSH
40246: LD_VAR 0 1
40250: PPUSH
40251: EMPTY
40252: PPUSH
40253: CALL_OW 1
40257: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40258: LD_ADDR_EXP 120
40262: PUSH
40263: LD_EXP 120
40267: PPUSH
40268: LD_VAR 0 1
40272: PPUSH
40273: EMPTY
40274: PPUSH
40275: CALL_OW 1
40279: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40280: LD_ADDR_EXP 121
40284: PUSH
40285: LD_EXP 121
40289: PPUSH
40290: LD_VAR 0 1
40294: PPUSH
40295: EMPTY
40296: PPUSH
40297: CALL_OW 1
40301: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40302: LD_ADDR_EXP 122
40306: PUSH
40307: LD_EXP 122
40311: PPUSH
40312: LD_VAR 0 1
40316: PPUSH
40317: EMPTY
40318: PPUSH
40319: CALL_OW 1
40323: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40324: LD_ADDR_EXP 123
40328: PUSH
40329: LD_EXP 123
40333: PPUSH
40334: LD_VAR 0 1
40338: PPUSH
40339: EMPTY
40340: PPUSH
40341: CALL_OW 1
40345: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40346: LD_ADDR_EXP 124
40350: PUSH
40351: LD_EXP 124
40355: PPUSH
40356: LD_VAR 0 1
40360: PPUSH
40361: EMPTY
40362: PPUSH
40363: CALL_OW 1
40367: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40368: LD_ADDR_EXP 125
40372: PUSH
40373: LD_EXP 125
40377: PPUSH
40378: LD_VAR 0 1
40382: PPUSH
40383: EMPTY
40384: PPUSH
40385: CALL_OW 1
40389: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40390: LD_ADDR_EXP 126
40394: PUSH
40395: LD_EXP 126
40399: PPUSH
40400: LD_VAR 0 1
40404: PPUSH
40405: EMPTY
40406: PPUSH
40407: CALL_OW 1
40411: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40412: LD_ADDR_EXP 127
40416: PUSH
40417: LD_EXP 127
40421: PPUSH
40422: LD_VAR 0 1
40426: PPUSH
40427: EMPTY
40428: PPUSH
40429: CALL_OW 1
40433: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40434: LD_ADDR_EXP 129
40438: PUSH
40439: LD_EXP 129
40443: PPUSH
40444: LD_VAR 0 1
40448: PPUSH
40449: EMPTY
40450: PPUSH
40451: CALL_OW 1
40455: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40456: LD_ADDR_EXP 131
40460: PUSH
40461: LD_EXP 131
40465: PPUSH
40466: LD_VAR 0 1
40470: PPUSH
40471: EMPTY
40472: PPUSH
40473: CALL_OW 1
40477: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40478: LD_ADDR_EXP 132
40482: PUSH
40483: LD_EXP 132
40487: PPUSH
40488: LD_VAR 0 1
40492: PPUSH
40493: EMPTY
40494: PPUSH
40495: CALL_OW 1
40499: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40500: LD_ADDR_EXP 133
40504: PUSH
40505: LD_EXP 133
40509: PPUSH
40510: LD_VAR 0 1
40514: PPUSH
40515: EMPTY
40516: PPUSH
40517: CALL_OW 1
40521: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40522: LD_ADDR_EXP 134
40526: PUSH
40527: LD_EXP 134
40531: PPUSH
40532: LD_VAR 0 1
40536: PPUSH
40537: EMPTY
40538: PPUSH
40539: CALL_OW 1
40543: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40544: LD_ADDR_EXP 135
40548: PUSH
40549: LD_EXP 135
40553: PPUSH
40554: LD_VAR 0 1
40558: PPUSH
40559: EMPTY
40560: PPUSH
40561: CALL_OW 1
40565: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40566: LD_ADDR_EXP 136
40570: PUSH
40571: LD_EXP 136
40575: PPUSH
40576: LD_VAR 0 1
40580: PPUSH
40581: EMPTY
40582: PPUSH
40583: CALL_OW 1
40587: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40588: LD_ADDR_EXP 137
40592: PUSH
40593: LD_EXP 137
40597: PPUSH
40598: LD_VAR 0 1
40602: PPUSH
40603: EMPTY
40604: PPUSH
40605: CALL_OW 1
40609: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40610: LD_ADDR_EXP 138
40614: PUSH
40615: LD_EXP 138
40619: PPUSH
40620: LD_VAR 0 1
40624: PPUSH
40625: EMPTY
40626: PPUSH
40627: CALL_OW 1
40631: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40632: LD_ADDR_EXP 139
40636: PUSH
40637: LD_EXP 139
40641: PPUSH
40642: LD_VAR 0 1
40646: PPUSH
40647: EMPTY
40648: PPUSH
40649: CALL_OW 1
40653: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40654: LD_ADDR_EXP 140
40658: PUSH
40659: LD_EXP 140
40663: PPUSH
40664: LD_VAR 0 1
40668: PPUSH
40669: EMPTY
40670: PPUSH
40671: CALL_OW 1
40675: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40676: LD_ADDR_EXP 141
40680: PUSH
40681: LD_EXP 141
40685: PPUSH
40686: LD_VAR 0 1
40690: PPUSH
40691: EMPTY
40692: PPUSH
40693: CALL_OW 1
40697: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40698: LD_ADDR_EXP 142
40702: PUSH
40703: LD_EXP 142
40707: PPUSH
40708: LD_VAR 0 1
40712: PPUSH
40713: EMPTY
40714: PPUSH
40715: CALL_OW 1
40719: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40720: LD_ADDR_EXP 143
40724: PUSH
40725: LD_EXP 143
40729: PPUSH
40730: LD_VAR 0 1
40734: PPUSH
40735: EMPTY
40736: PPUSH
40737: CALL_OW 1
40741: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40742: LD_ADDR_EXP 144
40746: PUSH
40747: LD_EXP 144
40751: PPUSH
40752: LD_VAR 0 1
40756: PPUSH
40757: LD_INT 0
40759: PPUSH
40760: CALL_OW 1
40764: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40765: LD_ADDR_EXP 145
40769: PUSH
40770: LD_EXP 145
40774: PPUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 0
40782: PPUSH
40783: CALL_OW 1
40787: ST_TO_ADDR
// end ;
40788: LD_VAR 0 2
40792: RET
// export function MC_Add ( side , units ) ; var base ; begin
40793: LD_INT 0
40795: PPUSH
40796: PPUSH
// base := mc_bases + 1 ;
40797: LD_ADDR_VAR 0 4
40801: PUSH
40802: LD_EXP 102
40806: PUSH
40807: LD_INT 1
40809: PLUS
40810: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40811: LD_ADDR_EXP 128
40815: PUSH
40816: LD_EXP 128
40820: PPUSH
40821: LD_VAR 0 4
40825: PPUSH
40826: LD_VAR 0 1
40830: PPUSH
40831: CALL_OW 1
40835: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40836: LD_ADDR_EXP 102
40840: PUSH
40841: LD_EXP 102
40845: PPUSH
40846: LD_VAR 0 4
40850: PPUSH
40851: LD_VAR 0 2
40855: PPUSH
40856: CALL_OW 1
40860: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40861: LD_ADDR_EXP 103
40865: PUSH
40866: LD_EXP 103
40870: PPUSH
40871: LD_VAR 0 4
40875: PPUSH
40876: EMPTY
40877: PPUSH
40878: CALL_OW 1
40882: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40883: LD_ADDR_EXP 104
40887: PUSH
40888: LD_EXP 104
40892: PPUSH
40893: LD_VAR 0 4
40897: PPUSH
40898: EMPTY
40899: PPUSH
40900: CALL_OW 1
40904: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40905: LD_ADDR_EXP 105
40909: PUSH
40910: LD_EXP 105
40914: PPUSH
40915: LD_VAR 0 4
40919: PPUSH
40920: EMPTY
40921: PPUSH
40922: CALL_OW 1
40926: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40927: LD_ADDR_EXP 106
40931: PUSH
40932: LD_EXP 106
40936: PPUSH
40937: LD_VAR 0 4
40941: PPUSH
40942: EMPTY
40943: PPUSH
40944: CALL_OW 1
40948: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40949: LD_ADDR_EXP 107
40953: PUSH
40954: LD_EXP 107
40958: PPUSH
40959: LD_VAR 0 4
40963: PPUSH
40964: EMPTY
40965: PPUSH
40966: CALL_OW 1
40970: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40971: LD_ADDR_EXP 108
40975: PUSH
40976: LD_EXP 108
40980: PPUSH
40981: LD_VAR 0 4
40985: PPUSH
40986: EMPTY
40987: PPUSH
40988: CALL_OW 1
40992: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40993: LD_ADDR_EXP 109
40997: PUSH
40998: LD_EXP 109
41002: PPUSH
41003: LD_VAR 0 4
41007: PPUSH
41008: EMPTY
41009: PPUSH
41010: CALL_OW 1
41014: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41015: LD_ADDR_EXP 110
41019: PUSH
41020: LD_EXP 110
41024: PPUSH
41025: LD_VAR 0 4
41029: PPUSH
41030: EMPTY
41031: PPUSH
41032: CALL_OW 1
41036: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41037: LD_ADDR_EXP 111
41041: PUSH
41042: LD_EXP 111
41046: PPUSH
41047: LD_VAR 0 4
41051: PPUSH
41052: EMPTY
41053: PPUSH
41054: CALL_OW 1
41058: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41059: LD_ADDR_EXP 112
41063: PUSH
41064: LD_EXP 112
41068: PPUSH
41069: LD_VAR 0 4
41073: PPUSH
41074: EMPTY
41075: PPUSH
41076: CALL_OW 1
41080: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41081: LD_ADDR_EXP 113
41085: PUSH
41086: LD_EXP 113
41090: PPUSH
41091: LD_VAR 0 4
41095: PPUSH
41096: LD_INT 0
41098: PPUSH
41099: CALL_OW 1
41103: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41104: LD_ADDR_EXP 114
41108: PUSH
41109: LD_EXP 114
41113: PPUSH
41114: LD_VAR 0 4
41118: PPUSH
41119: EMPTY
41120: PPUSH
41121: CALL_OW 1
41125: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41126: LD_ADDR_EXP 115
41130: PUSH
41131: LD_EXP 115
41135: PPUSH
41136: LD_VAR 0 4
41140: PPUSH
41141: EMPTY
41142: PPUSH
41143: CALL_OW 1
41147: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41148: LD_ADDR_EXP 116
41152: PUSH
41153: LD_EXP 116
41157: PPUSH
41158: LD_VAR 0 4
41162: PPUSH
41163: EMPTY
41164: PPUSH
41165: CALL_OW 1
41169: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41170: LD_ADDR_EXP 117
41174: PUSH
41175: LD_EXP 117
41179: PPUSH
41180: LD_VAR 0 4
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL_OW 1
41191: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41192: LD_ADDR_EXP 118
41196: PUSH
41197: LD_EXP 118
41201: PPUSH
41202: LD_VAR 0 4
41206: PPUSH
41207: EMPTY
41208: PPUSH
41209: CALL_OW 1
41213: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41214: LD_ADDR_EXP 119
41218: PUSH
41219: LD_EXP 119
41223: PPUSH
41224: LD_VAR 0 4
41228: PPUSH
41229: EMPTY
41230: PPUSH
41231: CALL_OW 1
41235: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41236: LD_ADDR_EXP 120
41240: PUSH
41241: LD_EXP 120
41245: PPUSH
41246: LD_VAR 0 4
41250: PPUSH
41251: EMPTY
41252: PPUSH
41253: CALL_OW 1
41257: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41258: LD_ADDR_EXP 121
41262: PUSH
41263: LD_EXP 121
41267: PPUSH
41268: LD_VAR 0 4
41272: PPUSH
41273: EMPTY
41274: PPUSH
41275: CALL_OW 1
41279: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41280: LD_ADDR_EXP 122
41284: PUSH
41285: LD_EXP 122
41289: PPUSH
41290: LD_VAR 0 4
41294: PPUSH
41295: EMPTY
41296: PPUSH
41297: CALL_OW 1
41301: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41302: LD_ADDR_EXP 123
41306: PUSH
41307: LD_EXP 123
41311: PPUSH
41312: LD_VAR 0 4
41316: PPUSH
41317: EMPTY
41318: PPUSH
41319: CALL_OW 1
41323: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41324: LD_ADDR_EXP 124
41328: PUSH
41329: LD_EXP 124
41333: PPUSH
41334: LD_VAR 0 4
41338: PPUSH
41339: EMPTY
41340: PPUSH
41341: CALL_OW 1
41345: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41346: LD_ADDR_EXP 125
41350: PUSH
41351: LD_EXP 125
41355: PPUSH
41356: LD_VAR 0 4
41360: PPUSH
41361: EMPTY
41362: PPUSH
41363: CALL_OW 1
41367: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41368: LD_ADDR_EXP 126
41372: PUSH
41373: LD_EXP 126
41377: PPUSH
41378: LD_VAR 0 4
41382: PPUSH
41383: EMPTY
41384: PPUSH
41385: CALL_OW 1
41389: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41390: LD_ADDR_EXP 127
41394: PUSH
41395: LD_EXP 127
41399: PPUSH
41400: LD_VAR 0 4
41404: PPUSH
41405: EMPTY
41406: PPUSH
41407: CALL_OW 1
41411: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41412: LD_ADDR_EXP 129
41416: PUSH
41417: LD_EXP 129
41421: PPUSH
41422: LD_VAR 0 4
41426: PPUSH
41427: EMPTY
41428: PPUSH
41429: CALL_OW 1
41433: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41434: LD_ADDR_EXP 131
41438: PUSH
41439: LD_EXP 131
41443: PPUSH
41444: LD_VAR 0 4
41448: PPUSH
41449: EMPTY
41450: PPUSH
41451: CALL_OW 1
41455: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41456: LD_ADDR_EXP 132
41460: PUSH
41461: LD_EXP 132
41465: PPUSH
41466: LD_VAR 0 4
41470: PPUSH
41471: EMPTY
41472: PPUSH
41473: CALL_OW 1
41477: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41478: LD_ADDR_EXP 133
41482: PUSH
41483: LD_EXP 133
41487: PPUSH
41488: LD_VAR 0 4
41492: PPUSH
41493: EMPTY
41494: PPUSH
41495: CALL_OW 1
41499: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41500: LD_ADDR_EXP 134
41504: PUSH
41505: LD_EXP 134
41509: PPUSH
41510: LD_VAR 0 4
41514: PPUSH
41515: EMPTY
41516: PPUSH
41517: CALL_OW 1
41521: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41522: LD_ADDR_EXP 135
41526: PUSH
41527: LD_EXP 135
41531: PPUSH
41532: LD_VAR 0 4
41536: PPUSH
41537: EMPTY
41538: PPUSH
41539: CALL_OW 1
41543: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41544: LD_ADDR_EXP 136
41548: PUSH
41549: LD_EXP 136
41553: PPUSH
41554: LD_VAR 0 4
41558: PPUSH
41559: EMPTY
41560: PPUSH
41561: CALL_OW 1
41565: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41566: LD_ADDR_EXP 137
41570: PUSH
41571: LD_EXP 137
41575: PPUSH
41576: LD_VAR 0 4
41580: PPUSH
41581: EMPTY
41582: PPUSH
41583: CALL_OW 1
41587: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41588: LD_ADDR_EXP 138
41592: PUSH
41593: LD_EXP 138
41597: PPUSH
41598: LD_VAR 0 4
41602: PPUSH
41603: EMPTY
41604: PPUSH
41605: CALL_OW 1
41609: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41610: LD_ADDR_EXP 139
41614: PUSH
41615: LD_EXP 139
41619: PPUSH
41620: LD_VAR 0 4
41624: PPUSH
41625: EMPTY
41626: PPUSH
41627: CALL_OW 1
41631: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41632: LD_ADDR_EXP 140
41636: PUSH
41637: LD_EXP 140
41641: PPUSH
41642: LD_VAR 0 4
41646: PPUSH
41647: EMPTY
41648: PPUSH
41649: CALL_OW 1
41653: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41654: LD_ADDR_EXP 141
41658: PUSH
41659: LD_EXP 141
41663: PPUSH
41664: LD_VAR 0 4
41668: PPUSH
41669: EMPTY
41670: PPUSH
41671: CALL_OW 1
41675: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41676: LD_ADDR_EXP 142
41680: PUSH
41681: LD_EXP 142
41685: PPUSH
41686: LD_VAR 0 4
41690: PPUSH
41691: EMPTY
41692: PPUSH
41693: CALL_OW 1
41697: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41698: LD_ADDR_EXP 143
41702: PUSH
41703: LD_EXP 143
41707: PPUSH
41708: LD_VAR 0 4
41712: PPUSH
41713: EMPTY
41714: PPUSH
41715: CALL_OW 1
41719: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41720: LD_ADDR_EXP 144
41724: PUSH
41725: LD_EXP 144
41729: PPUSH
41730: LD_VAR 0 4
41734: PPUSH
41735: LD_INT 0
41737: PPUSH
41738: CALL_OW 1
41742: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41743: LD_ADDR_EXP 145
41747: PUSH
41748: LD_EXP 145
41752: PPUSH
41753: LD_VAR 0 4
41757: PPUSH
41758: LD_INT 0
41760: PPUSH
41761: CALL_OW 1
41765: ST_TO_ADDR
// result := base ;
41766: LD_ADDR_VAR 0 3
41770: PUSH
41771: LD_VAR 0 4
41775: ST_TO_ADDR
// end ;
41776: LD_VAR 0 3
41780: RET
// export function MC_Start ( ) ; var i ; begin
41781: LD_INT 0
41783: PPUSH
41784: PPUSH
// for i = 1 to mc_bases do
41785: LD_ADDR_VAR 0 2
41789: PUSH
41790: DOUBLE
41791: LD_INT 1
41793: DEC
41794: ST_TO_ADDR
41795: LD_EXP 102
41799: PUSH
41800: FOR_TO
41801: IFFALSE 42901
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41803: LD_ADDR_EXP 102
41807: PUSH
41808: LD_EXP 102
41812: PPUSH
41813: LD_VAR 0 2
41817: PPUSH
41818: LD_EXP 102
41822: PUSH
41823: LD_VAR 0 2
41827: ARRAY
41828: PUSH
41829: LD_INT 0
41831: DIFF
41832: PPUSH
41833: CALL_OW 1
41837: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41838: LD_ADDR_EXP 103
41842: PUSH
41843: LD_EXP 103
41847: PPUSH
41848: LD_VAR 0 2
41852: PPUSH
41853: EMPTY
41854: PPUSH
41855: CALL_OW 1
41859: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41860: LD_ADDR_EXP 104
41864: PUSH
41865: LD_EXP 104
41869: PPUSH
41870: LD_VAR 0 2
41874: PPUSH
41875: EMPTY
41876: PPUSH
41877: CALL_OW 1
41881: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41882: LD_ADDR_EXP 105
41886: PUSH
41887: LD_EXP 105
41891: PPUSH
41892: LD_VAR 0 2
41896: PPUSH
41897: EMPTY
41898: PPUSH
41899: CALL_OW 1
41903: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41904: LD_ADDR_EXP 106
41908: PUSH
41909: LD_EXP 106
41913: PPUSH
41914: LD_VAR 0 2
41918: PPUSH
41919: EMPTY
41920: PUSH
41921: EMPTY
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PPUSH
41927: CALL_OW 1
41931: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41932: LD_ADDR_EXP 107
41936: PUSH
41937: LD_EXP 107
41941: PPUSH
41942: LD_VAR 0 2
41946: PPUSH
41947: EMPTY
41948: PPUSH
41949: CALL_OW 1
41953: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41954: LD_ADDR_EXP 134
41958: PUSH
41959: LD_EXP 134
41963: PPUSH
41964: LD_VAR 0 2
41968: PPUSH
41969: EMPTY
41970: PPUSH
41971: CALL_OW 1
41975: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41976: LD_ADDR_EXP 108
41980: PUSH
41981: LD_EXP 108
41985: PPUSH
41986: LD_VAR 0 2
41990: PPUSH
41991: EMPTY
41992: PPUSH
41993: CALL_OW 1
41997: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41998: LD_ADDR_EXP 109
42002: PUSH
42003: LD_EXP 109
42007: PPUSH
42008: LD_VAR 0 2
42012: PPUSH
42013: EMPTY
42014: PPUSH
42015: CALL_OW 1
42019: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
42020: LD_ADDR_EXP 110
42024: PUSH
42025: LD_EXP 110
42029: PPUSH
42030: LD_VAR 0 2
42034: PPUSH
42035: LD_EXP 102
42039: PUSH
42040: LD_VAR 0 2
42044: ARRAY
42045: PPUSH
42046: LD_INT 2
42048: PUSH
42049: LD_INT 30
42051: PUSH
42052: LD_INT 32
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 30
42061: PUSH
42062: LD_INT 33
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PPUSH
42074: CALL_OW 72
42078: PPUSH
42079: CALL_OW 1
42083: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42084: LD_ADDR_EXP 111
42088: PUSH
42089: LD_EXP 111
42093: PPUSH
42094: LD_VAR 0 2
42098: PPUSH
42099: LD_EXP 102
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: PPUSH
42110: LD_INT 2
42112: PUSH
42113: LD_INT 30
42115: PUSH
42116: LD_INT 32
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 30
42125: PUSH
42126: LD_INT 31
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 58
42140: PUSH
42141: EMPTY
42142: LIST
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PPUSH
42148: CALL_OW 72
42152: PPUSH
42153: CALL_OW 1
42157: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42158: LD_ADDR_EXP 112
42162: PUSH
42163: LD_EXP 112
42167: PPUSH
42168: LD_VAR 0 2
42172: PPUSH
42173: EMPTY
42174: PPUSH
42175: CALL_OW 1
42179: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42180: LD_ADDR_EXP 116
42184: PUSH
42185: LD_EXP 116
42189: PPUSH
42190: LD_VAR 0 2
42194: PPUSH
42195: EMPTY
42196: PPUSH
42197: CALL_OW 1
42201: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42202: LD_ADDR_EXP 115
42206: PUSH
42207: LD_EXP 115
42211: PPUSH
42212: LD_VAR 0 2
42216: PPUSH
42217: EMPTY
42218: PPUSH
42219: CALL_OW 1
42223: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42224: LD_ADDR_EXP 117
42228: PUSH
42229: LD_EXP 117
42233: PPUSH
42234: LD_VAR 0 2
42238: PPUSH
42239: EMPTY
42240: PPUSH
42241: CALL_OW 1
42245: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42246: LD_ADDR_EXP 118
42250: PUSH
42251: LD_EXP 118
42255: PPUSH
42256: LD_VAR 0 2
42260: PPUSH
42261: EMPTY
42262: PPUSH
42263: CALL_OW 1
42267: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42268: LD_ADDR_EXP 119
42272: PUSH
42273: LD_EXP 119
42277: PPUSH
42278: LD_VAR 0 2
42282: PPUSH
42283: EMPTY
42284: PPUSH
42285: CALL_OW 1
42289: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42290: LD_ADDR_EXP 120
42294: PUSH
42295: LD_EXP 120
42299: PPUSH
42300: LD_VAR 0 2
42304: PPUSH
42305: EMPTY
42306: PPUSH
42307: CALL_OW 1
42311: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42312: LD_ADDR_EXP 121
42316: PUSH
42317: LD_EXP 121
42321: PPUSH
42322: LD_VAR 0 2
42326: PPUSH
42327: EMPTY
42328: PPUSH
42329: CALL_OW 1
42333: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42334: LD_ADDR_EXP 122
42338: PUSH
42339: LD_EXP 122
42343: PPUSH
42344: LD_VAR 0 2
42348: PPUSH
42349: EMPTY
42350: PPUSH
42351: CALL_OW 1
42355: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42356: LD_ADDR_EXP 123
42360: PUSH
42361: LD_EXP 123
42365: PPUSH
42366: LD_VAR 0 2
42370: PPUSH
42371: EMPTY
42372: PPUSH
42373: CALL_OW 1
42377: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42378: LD_ADDR_EXP 124
42382: PUSH
42383: LD_EXP 124
42387: PPUSH
42388: LD_VAR 0 2
42392: PPUSH
42393: EMPTY
42394: PPUSH
42395: CALL_OW 1
42399: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42400: LD_ADDR_EXP 113
42404: PUSH
42405: LD_EXP 113
42409: PPUSH
42410: LD_VAR 0 2
42414: PPUSH
42415: LD_INT 0
42417: PPUSH
42418: CALL_OW 1
42422: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42423: LD_ADDR_EXP 126
42427: PUSH
42428: LD_EXP 126
42432: PPUSH
42433: LD_VAR 0 2
42437: PPUSH
42438: LD_INT 0
42440: PPUSH
42441: CALL_OW 1
42445: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42446: LD_ADDR_EXP 114
42450: PUSH
42451: LD_EXP 114
42455: PPUSH
42456: LD_VAR 0 2
42460: PPUSH
42461: EMPTY
42462: PPUSH
42463: CALL_OW 1
42467: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42468: LD_ADDR_EXP 125
42472: PUSH
42473: LD_EXP 125
42477: PPUSH
42478: LD_VAR 0 2
42482: PPUSH
42483: LD_INT 0
42485: PPUSH
42486: CALL_OW 1
42490: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42491: LD_ADDR_EXP 127
42495: PUSH
42496: LD_EXP 127
42500: PPUSH
42501: LD_VAR 0 2
42505: PPUSH
42506: EMPTY
42507: PPUSH
42508: CALL_OW 1
42512: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42513: LD_ADDR_EXP 130
42517: PUSH
42518: LD_EXP 130
42522: PPUSH
42523: LD_VAR 0 2
42527: PPUSH
42528: LD_INT 0
42530: PPUSH
42531: CALL_OW 1
42535: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42536: LD_ADDR_EXP 131
42540: PUSH
42541: LD_EXP 131
42545: PPUSH
42546: LD_VAR 0 2
42550: PPUSH
42551: EMPTY
42552: PPUSH
42553: CALL_OW 1
42557: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42558: LD_ADDR_EXP 132
42562: PUSH
42563: LD_EXP 132
42567: PPUSH
42568: LD_VAR 0 2
42572: PPUSH
42573: EMPTY
42574: PPUSH
42575: CALL_OW 1
42579: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42580: LD_ADDR_EXP 133
42584: PUSH
42585: LD_EXP 133
42589: PPUSH
42590: LD_VAR 0 2
42594: PPUSH
42595: EMPTY
42596: PPUSH
42597: CALL_OW 1
42601: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42602: LD_ADDR_EXP 135
42606: PUSH
42607: LD_EXP 135
42611: PPUSH
42612: LD_VAR 0 2
42616: PPUSH
42617: LD_EXP 102
42621: PUSH
42622: LD_VAR 0 2
42626: ARRAY
42627: PPUSH
42628: LD_INT 2
42630: PUSH
42631: LD_INT 30
42633: PUSH
42634: LD_INT 6
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 30
42643: PUSH
42644: LD_INT 7
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 30
42653: PUSH
42654: LD_INT 8
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: PPUSH
42667: CALL_OW 72
42671: PPUSH
42672: CALL_OW 1
42676: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42677: LD_ADDR_EXP 136
42681: PUSH
42682: LD_EXP 136
42686: PPUSH
42687: LD_VAR 0 2
42691: PPUSH
42692: EMPTY
42693: PPUSH
42694: CALL_OW 1
42698: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42699: LD_ADDR_EXP 137
42703: PUSH
42704: LD_EXP 137
42708: PPUSH
42709: LD_VAR 0 2
42713: PPUSH
42714: EMPTY
42715: PPUSH
42716: CALL_OW 1
42720: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42721: LD_ADDR_EXP 138
42725: PUSH
42726: LD_EXP 138
42730: PPUSH
42731: LD_VAR 0 2
42735: PPUSH
42736: EMPTY
42737: PPUSH
42738: CALL_OW 1
42742: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
42743: LD_ADDR_EXP 139
42747: PUSH
42748: LD_EXP 139
42752: PPUSH
42753: LD_VAR 0 2
42757: PPUSH
42758: EMPTY
42759: PPUSH
42760: CALL_OW 1
42764: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42765: LD_ADDR_EXP 140
42769: PUSH
42770: LD_EXP 140
42774: PPUSH
42775: LD_VAR 0 2
42779: PPUSH
42780: EMPTY
42781: PPUSH
42782: CALL_OW 1
42786: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42787: LD_ADDR_EXP 141
42791: PUSH
42792: LD_EXP 141
42796: PPUSH
42797: LD_VAR 0 2
42801: PPUSH
42802: EMPTY
42803: PPUSH
42804: CALL_OW 1
42808: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42809: LD_ADDR_EXP 142
42813: PUSH
42814: LD_EXP 142
42818: PPUSH
42819: LD_VAR 0 2
42823: PPUSH
42824: EMPTY
42825: PPUSH
42826: CALL_OW 1
42830: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42831: LD_ADDR_EXP 143
42835: PUSH
42836: LD_EXP 143
42840: PPUSH
42841: LD_VAR 0 2
42845: PPUSH
42846: EMPTY
42847: PPUSH
42848: CALL_OW 1
42852: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42853: LD_ADDR_EXP 144
42857: PUSH
42858: LD_EXP 144
42862: PPUSH
42863: LD_VAR 0 2
42867: PPUSH
42868: LD_INT 0
42870: PPUSH
42871: CALL_OW 1
42875: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42876: LD_ADDR_EXP 145
42880: PUSH
42881: LD_EXP 145
42885: PPUSH
42886: LD_VAR 0 2
42890: PPUSH
42891: LD_INT 0
42893: PPUSH
42894: CALL_OW 1
42898: ST_TO_ADDR
// end ;
42899: GO 41800
42901: POP
42902: POP
// MC_InitSides ( ) ;
42903: CALL 43189 0 0
// MC_InitResearch ( ) ;
42907: CALL 42928 0 0
// CustomInitMacro ( ) ;
42911: CALL 475 0 0
// skirmish := true ;
42915: LD_ADDR_EXP 100
42919: PUSH
42920: LD_INT 1
42922: ST_TO_ADDR
// end ;
42923: LD_VAR 0 1
42927: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42928: LD_INT 0
42930: PPUSH
42931: PPUSH
42932: PPUSH
42933: PPUSH
42934: PPUSH
42935: PPUSH
// if not mc_bases then
42936: LD_EXP 102
42940: NOT
42941: IFFALSE 42945
// exit ;
42943: GO 43184
// for i = 1 to 8 do
42945: LD_ADDR_VAR 0 2
42949: PUSH
42950: DOUBLE
42951: LD_INT 1
42953: DEC
42954: ST_TO_ADDR
42955: LD_INT 8
42957: PUSH
42958: FOR_TO
42959: IFFALSE 42985
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42961: LD_ADDR_EXP 129
42965: PUSH
42966: LD_EXP 129
42970: PPUSH
42971: LD_VAR 0 2
42975: PPUSH
42976: EMPTY
42977: PPUSH
42978: CALL_OW 1
42982: ST_TO_ADDR
42983: GO 42958
42985: POP
42986: POP
// tmp := [ ] ;
42987: LD_ADDR_VAR 0 5
42991: PUSH
42992: EMPTY
42993: ST_TO_ADDR
// for i = 1 to mc_sides do
42994: LD_ADDR_VAR 0 2
42998: PUSH
42999: DOUBLE
43000: LD_INT 1
43002: DEC
43003: ST_TO_ADDR
43004: LD_EXP 128
43008: PUSH
43009: FOR_TO
43010: IFFALSE 43068
// if not mc_sides [ i ] in tmp then
43012: LD_EXP 128
43016: PUSH
43017: LD_VAR 0 2
43021: ARRAY
43022: PUSH
43023: LD_VAR 0 5
43027: IN
43028: NOT
43029: IFFALSE 43066
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43031: LD_ADDR_VAR 0 5
43035: PUSH
43036: LD_VAR 0 5
43040: PPUSH
43041: LD_VAR 0 5
43045: PUSH
43046: LD_INT 1
43048: PLUS
43049: PPUSH
43050: LD_EXP 128
43054: PUSH
43055: LD_VAR 0 2
43059: ARRAY
43060: PPUSH
43061: CALL_OW 2
43065: ST_TO_ADDR
43066: GO 43009
43068: POP
43069: POP
// if not tmp then
43070: LD_VAR 0 5
43074: NOT
43075: IFFALSE 43079
// exit ;
43077: GO 43184
// for j in tmp do
43079: LD_ADDR_VAR 0 3
43083: PUSH
43084: LD_VAR 0 5
43088: PUSH
43089: FOR_IN
43090: IFFALSE 43182
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43092: LD_ADDR_VAR 0 6
43096: PUSH
43097: LD_INT 22
43099: PUSH
43100: LD_VAR 0 3
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PPUSH
43109: CALL_OW 69
43113: ST_TO_ADDR
// if not un then
43114: LD_VAR 0 6
43118: NOT
43119: IFFALSE 43123
// continue ;
43121: GO 43089
// nation := GetNation ( un [ 1 ] ) ;
43123: LD_ADDR_VAR 0 4
43127: PUSH
43128: LD_VAR 0 6
43132: PUSH
43133: LD_INT 1
43135: ARRAY
43136: PPUSH
43137: CALL_OW 248
43141: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43142: LD_ADDR_EXP 129
43146: PUSH
43147: LD_EXP 129
43151: PPUSH
43152: LD_VAR 0 3
43156: PPUSH
43157: LD_VAR 0 3
43161: PPUSH
43162: LD_VAR 0 4
43166: PPUSH
43167: LD_INT 1
43169: PPUSH
43170: CALL 70456 0 3
43174: PPUSH
43175: CALL_OW 1
43179: ST_TO_ADDR
// end ;
43180: GO 43089
43182: POP
43183: POP
// end ;
43184: LD_VAR 0 1
43188: RET
// export function MC_InitSides ( ) ; var i ; begin
43189: LD_INT 0
43191: PPUSH
43192: PPUSH
// if not mc_bases then
43193: LD_EXP 102
43197: NOT
43198: IFFALSE 43202
// exit ;
43200: GO 43276
// for i = 1 to mc_bases do
43202: LD_ADDR_VAR 0 2
43206: PUSH
43207: DOUBLE
43208: LD_INT 1
43210: DEC
43211: ST_TO_ADDR
43212: LD_EXP 102
43216: PUSH
43217: FOR_TO
43218: IFFALSE 43274
// if mc_bases [ i ] then
43220: LD_EXP 102
43224: PUSH
43225: LD_VAR 0 2
43229: ARRAY
43230: IFFALSE 43272
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43232: LD_ADDR_EXP 128
43236: PUSH
43237: LD_EXP 128
43241: PPUSH
43242: LD_VAR 0 2
43246: PPUSH
43247: LD_EXP 102
43251: PUSH
43252: LD_VAR 0 2
43256: ARRAY
43257: PUSH
43258: LD_INT 1
43260: ARRAY
43261: PPUSH
43262: CALL_OW 255
43266: PPUSH
43267: CALL_OW 1
43271: ST_TO_ADDR
43272: GO 43217
43274: POP
43275: POP
// end ;
43276: LD_VAR 0 1
43280: RET
// every 0 0$03 trigger skirmish do
43281: LD_EXP 100
43285: IFFALSE 43439
43287: GO 43289
43289: DISABLE
// begin enable ;
43290: ENABLE
// MC_CheckBuildings ( ) ;
43291: CALL 47951 0 0
// MC_CheckPeopleLife ( ) ;
43295: CALL 48112 0 0
// RaiseSailEvent ( 100 ) ;
43299: LD_INT 100
43301: PPUSH
43302: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43306: LD_INT 103
43308: PPUSH
43309: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43313: LD_INT 104
43315: PPUSH
43316: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43320: LD_INT 105
43322: PPUSH
43323: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43327: LD_INT 106
43329: PPUSH
43330: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43334: LD_INT 107
43336: PPUSH
43337: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43341: LD_INT 108
43343: PPUSH
43344: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43348: LD_INT 109
43350: PPUSH
43351: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43355: LD_INT 110
43357: PPUSH
43358: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43362: LD_INT 111
43364: PPUSH
43365: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43369: LD_INT 112
43371: PPUSH
43372: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43376: LD_INT 113
43378: PPUSH
43379: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43383: LD_INT 120
43385: PPUSH
43386: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43390: LD_INT 121
43392: PPUSH
43393: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43397: LD_INT 122
43399: PPUSH
43400: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43404: LD_INT 123
43406: PPUSH
43407: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43411: LD_INT 124
43413: PPUSH
43414: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43418: LD_INT 125
43420: PPUSH
43421: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43425: LD_INT 126
43427: PPUSH
43428: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43432: LD_INT 200
43434: PPUSH
43435: CALL_OW 427
// end ;
43439: END
// on SailEvent ( event ) do begin if event < 100 then
43440: LD_VAR 0 1
43444: PUSH
43445: LD_INT 100
43447: LESS
43448: IFFALSE 43459
// CustomEvent ( event ) ;
43450: LD_VAR 0 1
43454: PPUSH
43455: CALL 37815 0 1
// if event = 100 then
43459: LD_VAR 0 1
43463: PUSH
43464: LD_INT 100
43466: EQUAL
43467: IFFALSE 43473
// MC_ClassManager ( ) ;
43469: CALL 43865 0 0
// if event = 101 then
43473: LD_VAR 0 1
43477: PUSH
43478: LD_INT 101
43480: EQUAL
43481: IFFALSE 43487
// MC_RepairBuildings ( ) ;
43483: CALL 48697 0 0
// if event = 102 then
43487: LD_VAR 0 1
43491: PUSH
43492: LD_INT 102
43494: EQUAL
43495: IFFALSE 43501
// MC_Heal ( ) ;
43497: CALL 49632 0 0
// if event = 103 then
43501: LD_VAR 0 1
43505: PUSH
43506: LD_INT 103
43508: EQUAL
43509: IFFALSE 43515
// MC_Build ( ) ;
43511: CALL 50054 0 0
// if event = 104 then
43515: LD_VAR 0 1
43519: PUSH
43520: LD_INT 104
43522: EQUAL
43523: IFFALSE 43529
// MC_TurretWeapon ( ) ;
43525: CALL 51688 0 0
// if event = 105 then
43529: LD_VAR 0 1
43533: PUSH
43534: LD_INT 105
43536: EQUAL
43537: IFFALSE 43543
// MC_BuildUpgrade ( ) ;
43539: CALL 51239 0 0
// if event = 106 then
43543: LD_VAR 0 1
43547: PUSH
43548: LD_INT 106
43550: EQUAL
43551: IFFALSE 43557
// MC_PlantMines ( ) ;
43553: CALL 52118 0 0
// if event = 107 then
43557: LD_VAR 0 1
43561: PUSH
43562: LD_INT 107
43564: EQUAL
43565: IFFALSE 43571
// MC_CollectCrates ( ) ;
43567: CALL 52916 0 0
// if event = 108 then
43571: LD_VAR 0 1
43575: PUSH
43576: LD_INT 108
43578: EQUAL
43579: IFFALSE 43585
// MC_LinkRemoteControl ( ) ;
43581: CALL 54766 0 0
// if event = 109 then
43585: LD_VAR 0 1
43589: PUSH
43590: LD_INT 109
43592: EQUAL
43593: IFFALSE 43599
// MC_ProduceVehicle ( ) ;
43595: CALL 54947 0 0
// if event = 110 then
43599: LD_VAR 0 1
43603: PUSH
43604: LD_INT 110
43606: EQUAL
43607: IFFALSE 43613
// MC_SendAttack ( ) ;
43609: CALL 55413 0 0
// if event = 111 then
43613: LD_VAR 0 1
43617: PUSH
43618: LD_INT 111
43620: EQUAL
43621: IFFALSE 43627
// MC_Defend ( ) ;
43623: CALL 55521 0 0
// if event = 112 then
43627: LD_VAR 0 1
43631: PUSH
43632: LD_INT 112
43634: EQUAL
43635: IFFALSE 43641
// MC_Research ( ) ;
43637: CALL 56401 0 0
// if event = 113 then
43641: LD_VAR 0 1
43645: PUSH
43646: LD_INT 113
43648: EQUAL
43649: IFFALSE 43655
// MC_MinesTrigger ( ) ;
43651: CALL 57515 0 0
// if event = 120 then
43655: LD_VAR 0 1
43659: PUSH
43660: LD_INT 120
43662: EQUAL
43663: IFFALSE 43669
// MC_RepairVehicle ( ) ;
43665: CALL 57614 0 0
// if event = 121 then
43669: LD_VAR 0 1
43673: PUSH
43674: LD_INT 121
43676: EQUAL
43677: IFFALSE 43683
// MC_TameApe ( ) ;
43679: CALL 58383 0 0
// if event = 122 then
43683: LD_VAR 0 1
43687: PUSH
43688: LD_INT 122
43690: EQUAL
43691: IFFALSE 43697
// MC_ChangeApeClass ( ) ;
43693: CALL 59212 0 0
// if event = 123 then
43697: LD_VAR 0 1
43701: PUSH
43702: LD_INT 123
43704: EQUAL
43705: IFFALSE 43711
// MC_Bazooka ( ) ;
43707: CALL 59862 0 0
// if event = 124 then
43711: LD_VAR 0 1
43715: PUSH
43716: LD_INT 124
43718: EQUAL
43719: IFFALSE 43725
// MC_TeleportExit ( ) ;
43721: CALL 60060 0 0
// if event = 125 then
43725: LD_VAR 0 1
43729: PUSH
43730: LD_INT 125
43732: EQUAL
43733: IFFALSE 43739
// MC_Deposits ( ) ;
43735: CALL 60707 0 0
// if event = 126 then
43739: LD_VAR 0 1
43743: PUSH
43744: LD_INT 126
43746: EQUAL
43747: IFFALSE 43753
// MC_RemoteDriver ( ) ;
43749: CALL 61332 0 0
// if event = 200 then
43753: LD_VAR 0 1
43757: PUSH
43758: LD_INT 200
43760: EQUAL
43761: IFFALSE 43767
// MC_Idle ( ) ;
43763: CALL 63239 0 0
// end ;
43767: PPOPN 1
43769: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43770: LD_INT 0
43772: PPUSH
43773: PPUSH
// if not mc_bases [ base ] or not tag then
43774: LD_EXP 102
43778: PUSH
43779: LD_VAR 0 1
43783: ARRAY
43784: NOT
43785: PUSH
43786: LD_VAR 0 2
43790: NOT
43791: OR
43792: IFFALSE 43796
// exit ;
43794: GO 43860
// for i in mc_bases [ base ] union mc_ape [ base ] do
43796: LD_ADDR_VAR 0 4
43800: PUSH
43801: LD_EXP 102
43805: PUSH
43806: LD_VAR 0 1
43810: ARRAY
43811: PUSH
43812: LD_EXP 131
43816: PUSH
43817: LD_VAR 0 1
43821: ARRAY
43822: UNION
43823: PUSH
43824: FOR_IN
43825: IFFALSE 43858
// if GetTag ( i ) = tag then
43827: LD_VAR 0 4
43831: PPUSH
43832: CALL_OW 110
43836: PUSH
43837: LD_VAR 0 2
43841: EQUAL
43842: IFFALSE 43856
// SetTag ( i , 0 ) ;
43844: LD_VAR 0 4
43848: PPUSH
43849: LD_INT 0
43851: PPUSH
43852: CALL_OW 109
43856: GO 43824
43858: POP
43859: POP
// end ;
43860: LD_VAR 0 3
43864: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43865: LD_INT 0
43867: PPUSH
43868: PPUSH
43869: PPUSH
43870: PPUSH
43871: PPUSH
43872: PPUSH
43873: PPUSH
43874: PPUSH
// if not mc_bases then
43875: LD_EXP 102
43879: NOT
43880: IFFALSE 43884
// exit ;
43882: GO 44333
// for i = 1 to mc_bases do
43884: LD_ADDR_VAR 0 2
43888: PUSH
43889: DOUBLE
43890: LD_INT 1
43892: DEC
43893: ST_TO_ADDR
43894: LD_EXP 102
43898: PUSH
43899: FOR_TO
43900: IFFALSE 44331
// begin tmp := MC_ClassCheckReq ( i ) ;
43902: LD_ADDR_VAR 0 4
43906: PUSH
43907: LD_VAR 0 2
43911: PPUSH
43912: CALL 44338 0 1
43916: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43917: LD_ADDR_EXP 143
43921: PUSH
43922: LD_EXP 143
43926: PPUSH
43927: LD_VAR 0 2
43931: PPUSH
43932: LD_VAR 0 4
43936: PPUSH
43937: CALL_OW 1
43941: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43942: LD_ADDR_VAR 0 6
43946: PUSH
43947: LD_EXP 102
43951: PUSH
43952: LD_VAR 0 2
43956: ARRAY
43957: PPUSH
43958: LD_INT 2
43960: PUSH
43961: LD_INT 30
43963: PUSH
43964: LD_INT 4
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 30
43973: PUSH
43974: LD_INT 5
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: LIST
43985: PPUSH
43986: CALL_OW 72
43990: PUSH
43991: LD_EXP 102
43995: PUSH
43996: LD_VAR 0 2
44000: ARRAY
44001: PPUSH
44002: LD_INT 2
44004: PUSH
44005: LD_INT 30
44007: PUSH
44008: LD_INT 0
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 30
44017: PUSH
44018: LD_INT 1
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: LIST
44029: PPUSH
44030: CALL_OW 72
44034: PUSH
44035: LD_EXP 102
44039: PUSH
44040: LD_VAR 0 2
44044: ARRAY
44045: PPUSH
44046: LD_INT 30
44048: PUSH
44049: LD_INT 3
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PPUSH
44056: CALL_OW 72
44060: PUSH
44061: LD_EXP 102
44065: PUSH
44066: LD_VAR 0 2
44070: ARRAY
44071: PPUSH
44072: LD_INT 2
44074: PUSH
44075: LD_INT 30
44077: PUSH
44078: LD_INT 6
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PUSH
44085: LD_INT 30
44087: PUSH
44088: LD_INT 7
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 30
44097: PUSH
44098: LD_INT 8
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: PPUSH
44111: CALL_OW 72
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: ST_TO_ADDR
// for j := 1 to 4 do
44122: LD_ADDR_VAR 0 3
44126: PUSH
44127: DOUBLE
44128: LD_INT 1
44130: DEC
44131: ST_TO_ADDR
44132: LD_INT 4
44134: PUSH
44135: FOR_TO
44136: IFFALSE 44327
// begin if not tmp [ j ] then
44138: LD_VAR 0 4
44142: PUSH
44143: LD_VAR 0 3
44147: ARRAY
44148: NOT
44149: IFFALSE 44153
// continue ;
44151: GO 44135
// for p in tmp [ j ] do
44153: LD_ADDR_VAR 0 5
44157: PUSH
44158: LD_VAR 0 4
44162: PUSH
44163: LD_VAR 0 3
44167: ARRAY
44168: PUSH
44169: FOR_IN
44170: IFFALSE 44323
// begin if not b [ j ] then
44172: LD_VAR 0 6
44176: PUSH
44177: LD_VAR 0 3
44181: ARRAY
44182: NOT
44183: IFFALSE 44187
// break ;
44185: GO 44323
// e := 0 ;
44187: LD_ADDR_VAR 0 7
44191: PUSH
44192: LD_INT 0
44194: ST_TO_ADDR
// for k in b [ j ] do
44195: LD_ADDR_VAR 0 8
44199: PUSH
44200: LD_VAR 0 6
44204: PUSH
44205: LD_VAR 0 3
44209: ARRAY
44210: PUSH
44211: FOR_IN
44212: IFFALSE 44239
// if IsNotFull ( k ) then
44214: LD_VAR 0 8
44218: PPUSH
44219: CALL 72577 0 1
44223: IFFALSE 44237
// begin e := k ;
44225: LD_ADDR_VAR 0 7
44229: PUSH
44230: LD_VAR 0 8
44234: ST_TO_ADDR
// break ;
44235: GO 44239
// end ;
44237: GO 44211
44239: POP
44240: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44241: LD_VAR 0 7
44245: PUSH
44246: LD_VAR 0 5
44250: PPUSH
44251: LD_VAR 0 7
44255: PPUSH
44256: CALL 106736 0 2
44260: NOT
44261: AND
44262: IFFALSE 44321
// begin if IsInUnit ( p ) then
44264: LD_VAR 0 5
44268: PPUSH
44269: CALL_OW 310
44273: IFFALSE 44284
// ComExitBuilding ( p ) ;
44275: LD_VAR 0 5
44279: PPUSH
44280: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44284: LD_VAR 0 5
44288: PPUSH
44289: LD_VAR 0 7
44293: PPUSH
44294: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44298: LD_VAR 0 5
44302: PPUSH
44303: LD_VAR 0 3
44307: PPUSH
44308: CALL_OW 183
// AddComExitBuilding ( p ) ;
44312: LD_VAR 0 5
44316: PPUSH
44317: CALL_OW 182
// end ; end ;
44321: GO 44169
44323: POP
44324: POP
// end ;
44325: GO 44135
44327: POP
44328: POP
// end ;
44329: GO 43899
44331: POP
44332: POP
// end ;
44333: LD_VAR 0 1
44337: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44338: LD_INT 0
44340: PPUSH
44341: PPUSH
44342: PPUSH
44343: PPUSH
44344: PPUSH
44345: PPUSH
44346: PPUSH
44347: PPUSH
44348: PPUSH
44349: PPUSH
44350: PPUSH
44351: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44352: LD_ADDR_VAR 0 2
44356: PUSH
44357: LD_INT 0
44359: PUSH
44360: LD_INT 0
44362: PUSH
44363: LD_INT 0
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44375: LD_VAR 0 1
44379: NOT
44380: PUSH
44381: LD_EXP 102
44385: PUSH
44386: LD_VAR 0 1
44390: ARRAY
44391: NOT
44392: OR
44393: PUSH
44394: LD_EXP 102
44398: PUSH
44399: LD_VAR 0 1
44403: ARRAY
44404: PPUSH
44405: LD_INT 2
44407: PUSH
44408: LD_INT 30
44410: PUSH
44411: LD_INT 0
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 30
44420: PUSH
44421: LD_INT 1
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: PPUSH
44433: CALL_OW 72
44437: NOT
44438: OR
44439: IFFALSE 44443
// exit ;
44441: GO 47946
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44443: LD_ADDR_VAR 0 4
44447: PUSH
44448: LD_EXP 102
44452: PUSH
44453: LD_VAR 0 1
44457: ARRAY
44458: PPUSH
44459: LD_INT 2
44461: PUSH
44462: LD_INT 25
44464: PUSH
44465: LD_INT 1
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: LD_INT 25
44474: PUSH
44475: LD_INT 2
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: LD_INT 25
44484: PUSH
44485: LD_INT 3
44487: PUSH
44488: EMPTY
44489: LIST
44490: LIST
44491: PUSH
44492: LD_INT 25
44494: PUSH
44495: LD_INT 4
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 25
44504: PUSH
44505: LD_INT 5
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 25
44514: PUSH
44515: LD_INT 8
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 25
44524: PUSH
44525: LD_INT 9
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: PPUSH
44542: CALL_OW 72
44546: ST_TO_ADDR
// if not tmp then
44547: LD_VAR 0 4
44551: NOT
44552: IFFALSE 44556
// exit ;
44554: GO 47946
// for i in tmp do
44556: LD_ADDR_VAR 0 3
44560: PUSH
44561: LD_VAR 0 4
44565: PUSH
44566: FOR_IN
44567: IFFALSE 44598
// if GetTag ( i ) then
44569: LD_VAR 0 3
44573: PPUSH
44574: CALL_OW 110
44578: IFFALSE 44596
// tmp := tmp diff i ;
44580: LD_ADDR_VAR 0 4
44584: PUSH
44585: LD_VAR 0 4
44589: PUSH
44590: LD_VAR 0 3
44594: DIFF
44595: ST_TO_ADDR
44596: GO 44566
44598: POP
44599: POP
// if not tmp then
44600: LD_VAR 0 4
44604: NOT
44605: IFFALSE 44609
// exit ;
44607: GO 47946
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44609: LD_ADDR_VAR 0 5
44613: PUSH
44614: LD_EXP 102
44618: PUSH
44619: LD_VAR 0 1
44623: ARRAY
44624: PPUSH
44625: LD_INT 2
44627: PUSH
44628: LD_INT 25
44630: PUSH
44631: LD_INT 1
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 25
44640: PUSH
44641: LD_INT 5
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 25
44650: PUSH
44651: LD_INT 8
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 25
44660: PUSH
44661: LD_INT 9
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: LIST
44672: LIST
44673: LIST
44674: PPUSH
44675: CALL_OW 72
44679: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44680: LD_ADDR_VAR 0 6
44684: PUSH
44685: LD_EXP 102
44689: PUSH
44690: LD_VAR 0 1
44694: ARRAY
44695: PPUSH
44696: LD_INT 25
44698: PUSH
44699: LD_INT 2
44701: PUSH
44702: EMPTY
44703: LIST
44704: LIST
44705: PPUSH
44706: CALL_OW 72
44710: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44711: LD_ADDR_VAR 0 7
44715: PUSH
44716: LD_EXP 102
44720: PUSH
44721: LD_VAR 0 1
44725: ARRAY
44726: PPUSH
44727: LD_INT 25
44729: PUSH
44730: LD_INT 3
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PPUSH
44737: CALL_OW 72
44741: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
44742: LD_ADDR_VAR 0 8
44746: PUSH
44747: LD_EXP 102
44751: PUSH
44752: LD_VAR 0 1
44756: ARRAY
44757: PPUSH
44758: LD_INT 25
44760: PUSH
44761: LD_INT 4
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 24
44770: PUSH
44771: LD_INT 251
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PPUSH
44782: CALL_OW 72
44786: ST_TO_ADDR
// if mc_is_defending [ base ] then
44787: LD_EXP 145
44791: PUSH
44792: LD_VAR 0 1
44796: ARRAY
44797: IFFALSE 45258
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44799: LD_ADDR_EXP 144
44803: PUSH
44804: LD_EXP 144
44808: PPUSH
44809: LD_VAR 0 1
44813: PPUSH
44814: LD_INT 4
44816: PPUSH
44817: CALL_OW 1
44821: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44822: LD_ADDR_VAR 0 12
44826: PUSH
44827: LD_EXP 102
44831: PUSH
44832: LD_VAR 0 1
44836: ARRAY
44837: PPUSH
44838: LD_INT 2
44840: PUSH
44841: LD_INT 30
44843: PUSH
44844: LD_INT 4
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 30
44853: PUSH
44854: LD_INT 5
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: LIST
44865: PPUSH
44866: CALL_OW 72
44870: ST_TO_ADDR
// if not b then
44871: LD_VAR 0 12
44875: NOT
44876: IFFALSE 44880
// exit ;
44878: GO 47946
// p := [ ] ;
44880: LD_ADDR_VAR 0 11
44884: PUSH
44885: EMPTY
44886: ST_TO_ADDR
// if sci >= 2 then
44887: LD_VAR 0 8
44891: PUSH
44892: LD_INT 2
44894: GREATEREQUAL
44895: IFFALSE 44926
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44897: LD_ADDR_VAR 0 8
44901: PUSH
44902: LD_VAR 0 8
44906: PUSH
44907: LD_INT 1
44909: ARRAY
44910: PUSH
44911: LD_VAR 0 8
44915: PUSH
44916: LD_INT 2
44918: ARRAY
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: ST_TO_ADDR
44924: GO 44987
// if sci = 1 then
44926: LD_VAR 0 8
44930: PUSH
44931: LD_INT 1
44933: EQUAL
44934: IFFALSE 44955
// sci := [ sci [ 1 ] ] else
44936: LD_ADDR_VAR 0 8
44940: PUSH
44941: LD_VAR 0 8
44945: PUSH
44946: LD_INT 1
44948: ARRAY
44949: PUSH
44950: EMPTY
44951: LIST
44952: ST_TO_ADDR
44953: GO 44987
// if sci = 0 then
44955: LD_VAR 0 8
44959: PUSH
44960: LD_INT 0
44962: EQUAL
44963: IFFALSE 44987
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44965: LD_ADDR_VAR 0 11
44969: PUSH
44970: LD_VAR 0 4
44974: PPUSH
44975: LD_INT 4
44977: PPUSH
44978: CALL 106608 0 2
44982: PUSH
44983: LD_INT 1
44985: ARRAY
44986: ST_TO_ADDR
// if eng > 4 then
44987: LD_VAR 0 6
44991: PUSH
44992: LD_INT 4
44994: GREATER
44995: IFFALSE 45041
// for i = eng downto 4 do
44997: LD_ADDR_VAR 0 3
45001: PUSH
45002: DOUBLE
45003: LD_VAR 0 6
45007: INC
45008: ST_TO_ADDR
45009: LD_INT 4
45011: PUSH
45012: FOR_DOWNTO
45013: IFFALSE 45039
// eng := eng diff eng [ i ] ;
45015: LD_ADDR_VAR 0 6
45019: PUSH
45020: LD_VAR 0 6
45024: PUSH
45025: LD_VAR 0 6
45029: PUSH
45030: LD_VAR 0 3
45034: ARRAY
45035: DIFF
45036: ST_TO_ADDR
45037: GO 45012
45039: POP
45040: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45041: LD_ADDR_VAR 0 4
45045: PUSH
45046: LD_VAR 0 4
45050: PUSH
45051: LD_VAR 0 5
45055: PUSH
45056: LD_VAR 0 6
45060: UNION
45061: PUSH
45062: LD_VAR 0 7
45066: UNION
45067: PUSH
45068: LD_VAR 0 8
45072: UNION
45073: DIFF
45074: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45075: LD_ADDR_VAR 0 13
45079: PUSH
45080: LD_EXP 102
45084: PUSH
45085: LD_VAR 0 1
45089: ARRAY
45090: PPUSH
45091: LD_INT 2
45093: PUSH
45094: LD_INT 30
45096: PUSH
45097: LD_INT 32
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 30
45106: PUSH
45107: LD_INT 31
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: LIST
45118: PPUSH
45119: CALL_OW 72
45123: PUSH
45124: LD_EXP 102
45128: PUSH
45129: LD_VAR 0 1
45133: ARRAY
45134: PPUSH
45135: LD_INT 2
45137: PUSH
45138: LD_INT 30
45140: PUSH
45141: LD_INT 4
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 30
45150: PUSH
45151: LD_INT 5
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: LIST
45162: PPUSH
45163: CALL_OW 72
45167: PUSH
45168: LD_INT 6
45170: MUL
45171: PLUS
45172: ST_TO_ADDR
// if bcount < tmp then
45173: LD_VAR 0 13
45177: PUSH
45178: LD_VAR 0 4
45182: LESS
45183: IFFALSE 45229
// for i = tmp downto bcount do
45185: LD_ADDR_VAR 0 3
45189: PUSH
45190: DOUBLE
45191: LD_VAR 0 4
45195: INC
45196: ST_TO_ADDR
45197: LD_VAR 0 13
45201: PUSH
45202: FOR_DOWNTO
45203: IFFALSE 45227
// tmp := Delete ( tmp , tmp ) ;
45205: LD_ADDR_VAR 0 4
45209: PUSH
45210: LD_VAR 0 4
45214: PPUSH
45215: LD_VAR 0 4
45219: PPUSH
45220: CALL_OW 3
45224: ST_TO_ADDR
45225: GO 45202
45227: POP
45228: POP
// result := [ tmp , 0 , 0 , p ] ;
45229: LD_ADDR_VAR 0 2
45233: PUSH
45234: LD_VAR 0 4
45238: PUSH
45239: LD_INT 0
45241: PUSH
45242: LD_INT 0
45244: PUSH
45245: LD_VAR 0 11
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: LIST
45254: LIST
45255: ST_TO_ADDR
// exit ;
45256: GO 47946
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45258: LD_EXP 102
45262: PUSH
45263: LD_VAR 0 1
45267: ARRAY
45268: PPUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 30
45274: PUSH
45275: LD_INT 6
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 30
45284: PUSH
45285: LD_INT 7
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 30
45294: PUSH
45295: LD_INT 8
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: PPUSH
45308: CALL_OW 72
45312: NOT
45313: PUSH
45314: LD_EXP 102
45318: PUSH
45319: LD_VAR 0 1
45323: ARRAY
45324: PPUSH
45325: LD_INT 30
45327: PUSH
45328: LD_INT 3
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: PPUSH
45335: CALL_OW 72
45339: NOT
45340: AND
45341: IFFALSE 45413
// begin if eng = tmp then
45343: LD_VAR 0 6
45347: PUSH
45348: LD_VAR 0 4
45352: EQUAL
45353: IFFALSE 45357
// exit ;
45355: GO 47946
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45357: LD_ADDR_EXP 144
45361: PUSH
45362: LD_EXP 144
45366: PPUSH
45367: LD_VAR 0 1
45371: PPUSH
45372: LD_INT 1
45374: PPUSH
45375: CALL_OW 1
45379: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45380: LD_ADDR_VAR 0 2
45384: PUSH
45385: LD_INT 0
45387: PUSH
45388: LD_VAR 0 4
45392: PUSH
45393: LD_VAR 0 6
45397: DIFF
45398: PUSH
45399: LD_INT 0
45401: PUSH
45402: LD_INT 0
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: ST_TO_ADDR
// exit ;
45411: GO 47946
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45413: LD_EXP 129
45417: PUSH
45418: LD_EXP 128
45422: PUSH
45423: LD_VAR 0 1
45427: ARRAY
45428: ARRAY
45429: PUSH
45430: LD_EXP 102
45434: PUSH
45435: LD_VAR 0 1
45439: ARRAY
45440: PPUSH
45441: LD_INT 2
45443: PUSH
45444: LD_INT 30
45446: PUSH
45447: LD_INT 6
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 30
45456: PUSH
45457: LD_INT 7
45459: PUSH
45460: EMPTY
45461: LIST
45462: LIST
45463: PUSH
45464: LD_INT 30
45466: PUSH
45467: LD_INT 8
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: PPUSH
45480: CALL_OW 72
45484: AND
45485: PUSH
45486: LD_EXP 102
45490: PUSH
45491: LD_VAR 0 1
45495: ARRAY
45496: PPUSH
45497: LD_INT 30
45499: PUSH
45500: LD_INT 3
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PPUSH
45507: CALL_OW 72
45511: NOT
45512: AND
45513: IFFALSE 45727
// begin if sci >= 6 then
45515: LD_VAR 0 8
45519: PUSH
45520: LD_INT 6
45522: GREATEREQUAL
45523: IFFALSE 45527
// exit ;
45525: GO 47946
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45527: LD_ADDR_EXP 144
45531: PUSH
45532: LD_EXP 144
45536: PPUSH
45537: LD_VAR 0 1
45541: PPUSH
45542: LD_INT 2
45544: PPUSH
45545: CALL_OW 1
45549: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45550: LD_ADDR_VAR 0 9
45554: PUSH
45555: LD_VAR 0 4
45559: PUSH
45560: LD_VAR 0 8
45564: DIFF
45565: PPUSH
45566: LD_INT 4
45568: PPUSH
45569: CALL 106608 0 2
45573: ST_TO_ADDR
// p := [ ] ;
45574: LD_ADDR_VAR 0 11
45578: PUSH
45579: EMPTY
45580: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45581: LD_VAR 0 8
45585: PUSH
45586: LD_INT 6
45588: LESS
45589: PUSH
45590: LD_VAR 0 9
45594: PUSH
45595: LD_INT 6
45597: GREATER
45598: AND
45599: IFFALSE 45680
// begin for i = 1 to 6 - sci do
45601: LD_ADDR_VAR 0 3
45605: PUSH
45606: DOUBLE
45607: LD_INT 1
45609: DEC
45610: ST_TO_ADDR
45611: LD_INT 6
45613: PUSH
45614: LD_VAR 0 8
45618: MINUS
45619: PUSH
45620: FOR_TO
45621: IFFALSE 45676
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45623: LD_ADDR_VAR 0 11
45627: PUSH
45628: LD_VAR 0 11
45632: PPUSH
45633: LD_VAR 0 11
45637: PUSH
45638: LD_INT 1
45640: PLUS
45641: PPUSH
45642: LD_VAR 0 9
45646: PUSH
45647: LD_INT 1
45649: ARRAY
45650: PPUSH
45651: CALL_OW 2
45655: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45656: LD_ADDR_VAR 0 9
45660: PUSH
45661: LD_VAR 0 9
45665: PPUSH
45666: LD_INT 1
45668: PPUSH
45669: CALL_OW 3
45673: ST_TO_ADDR
// end ;
45674: GO 45620
45676: POP
45677: POP
// end else
45678: GO 45700
// if sort then
45680: LD_VAR 0 9
45684: IFFALSE 45700
// p := sort [ 1 ] ;
45686: LD_ADDR_VAR 0 11
45690: PUSH
45691: LD_VAR 0 9
45695: PUSH
45696: LD_INT 1
45698: ARRAY
45699: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45700: LD_ADDR_VAR 0 2
45704: PUSH
45705: LD_INT 0
45707: PUSH
45708: LD_INT 0
45710: PUSH
45711: LD_INT 0
45713: PUSH
45714: LD_VAR 0 11
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: ST_TO_ADDR
// exit ;
45725: GO 47946
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45727: LD_EXP 129
45731: PUSH
45732: LD_EXP 128
45736: PUSH
45737: LD_VAR 0 1
45741: ARRAY
45742: ARRAY
45743: PUSH
45744: LD_EXP 102
45748: PUSH
45749: LD_VAR 0 1
45753: ARRAY
45754: PPUSH
45755: LD_INT 2
45757: PUSH
45758: LD_INT 30
45760: PUSH
45761: LD_INT 6
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PUSH
45768: LD_INT 30
45770: PUSH
45771: LD_INT 7
45773: PUSH
45774: EMPTY
45775: LIST
45776: LIST
45777: PUSH
45778: LD_INT 30
45780: PUSH
45781: LD_INT 8
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: PPUSH
45794: CALL_OW 72
45798: AND
45799: PUSH
45800: LD_EXP 102
45804: PUSH
45805: LD_VAR 0 1
45809: ARRAY
45810: PPUSH
45811: LD_INT 30
45813: PUSH
45814: LD_INT 3
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PPUSH
45821: CALL_OW 72
45825: AND
45826: IFFALSE 46560
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45828: LD_ADDR_EXP 144
45832: PUSH
45833: LD_EXP 144
45837: PPUSH
45838: LD_VAR 0 1
45842: PPUSH
45843: LD_INT 3
45845: PPUSH
45846: CALL_OW 1
45850: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45851: LD_ADDR_VAR 0 2
45855: PUSH
45856: LD_INT 0
45858: PUSH
45859: LD_INT 0
45861: PUSH
45862: LD_INT 0
45864: PUSH
45865: LD_INT 0
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: ST_TO_ADDR
// if not eng then
45874: LD_VAR 0 6
45878: NOT
45879: IFFALSE 45942
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45881: LD_ADDR_VAR 0 11
45885: PUSH
45886: LD_VAR 0 4
45890: PPUSH
45891: LD_INT 2
45893: PPUSH
45894: CALL 106608 0 2
45898: PUSH
45899: LD_INT 1
45901: ARRAY
45902: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45903: LD_ADDR_VAR 0 2
45907: PUSH
45908: LD_VAR 0 2
45912: PPUSH
45913: LD_INT 2
45915: PPUSH
45916: LD_VAR 0 11
45920: PPUSH
45921: CALL_OW 1
45925: ST_TO_ADDR
// tmp := tmp diff p ;
45926: LD_ADDR_VAR 0 4
45930: PUSH
45931: LD_VAR 0 4
45935: PUSH
45936: LD_VAR 0 11
45940: DIFF
45941: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45942: LD_VAR 0 4
45946: PUSH
45947: LD_VAR 0 8
45951: PUSH
45952: LD_INT 6
45954: LESS
45955: AND
45956: IFFALSE 46144
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45958: LD_ADDR_VAR 0 9
45962: PUSH
45963: LD_VAR 0 4
45967: PUSH
45968: LD_VAR 0 8
45972: PUSH
45973: LD_VAR 0 7
45977: UNION
45978: DIFF
45979: PPUSH
45980: LD_INT 4
45982: PPUSH
45983: CALL 106608 0 2
45987: ST_TO_ADDR
// p := [ ] ;
45988: LD_ADDR_VAR 0 11
45992: PUSH
45993: EMPTY
45994: ST_TO_ADDR
// if sort then
45995: LD_VAR 0 9
45999: IFFALSE 46115
// for i = 1 to 6 - sci do
46001: LD_ADDR_VAR 0 3
46005: PUSH
46006: DOUBLE
46007: LD_INT 1
46009: DEC
46010: ST_TO_ADDR
46011: LD_INT 6
46013: PUSH
46014: LD_VAR 0 8
46018: MINUS
46019: PUSH
46020: FOR_TO
46021: IFFALSE 46113
// begin if i = sort then
46023: LD_VAR 0 3
46027: PUSH
46028: LD_VAR 0 9
46032: EQUAL
46033: IFFALSE 46037
// break ;
46035: GO 46113
// if GetClass ( i ) = 4 then
46037: LD_VAR 0 3
46041: PPUSH
46042: CALL_OW 257
46046: PUSH
46047: LD_INT 4
46049: EQUAL
46050: IFFALSE 46054
// continue ;
46052: GO 46020
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46054: LD_ADDR_VAR 0 11
46058: PUSH
46059: LD_VAR 0 11
46063: PPUSH
46064: LD_VAR 0 11
46068: PUSH
46069: LD_INT 1
46071: PLUS
46072: PPUSH
46073: LD_VAR 0 9
46077: PUSH
46078: LD_VAR 0 3
46082: ARRAY
46083: PPUSH
46084: CALL_OW 2
46088: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46089: LD_ADDR_VAR 0 4
46093: PUSH
46094: LD_VAR 0 4
46098: PUSH
46099: LD_VAR 0 9
46103: PUSH
46104: LD_VAR 0 3
46108: ARRAY
46109: DIFF
46110: ST_TO_ADDR
// end ;
46111: GO 46020
46113: POP
46114: POP
// if p then
46115: LD_VAR 0 11
46119: IFFALSE 46144
// result := Replace ( result , 4 , p ) ;
46121: LD_ADDR_VAR 0 2
46125: PUSH
46126: LD_VAR 0 2
46130: PPUSH
46131: LD_INT 4
46133: PPUSH
46134: LD_VAR 0 11
46138: PPUSH
46139: CALL_OW 1
46143: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46144: LD_VAR 0 4
46148: PUSH
46149: LD_VAR 0 7
46153: PUSH
46154: LD_INT 6
46156: LESS
46157: AND
46158: IFFALSE 46346
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46160: LD_ADDR_VAR 0 9
46164: PUSH
46165: LD_VAR 0 4
46169: PUSH
46170: LD_VAR 0 8
46174: PUSH
46175: LD_VAR 0 7
46179: UNION
46180: DIFF
46181: PPUSH
46182: LD_INT 3
46184: PPUSH
46185: CALL 106608 0 2
46189: ST_TO_ADDR
// p := [ ] ;
46190: LD_ADDR_VAR 0 11
46194: PUSH
46195: EMPTY
46196: ST_TO_ADDR
// if sort then
46197: LD_VAR 0 9
46201: IFFALSE 46317
// for i = 1 to 6 - mech do
46203: LD_ADDR_VAR 0 3
46207: PUSH
46208: DOUBLE
46209: LD_INT 1
46211: DEC
46212: ST_TO_ADDR
46213: LD_INT 6
46215: PUSH
46216: LD_VAR 0 7
46220: MINUS
46221: PUSH
46222: FOR_TO
46223: IFFALSE 46315
// begin if i = sort then
46225: LD_VAR 0 3
46229: PUSH
46230: LD_VAR 0 9
46234: EQUAL
46235: IFFALSE 46239
// break ;
46237: GO 46315
// if GetClass ( i ) = 3 then
46239: LD_VAR 0 3
46243: PPUSH
46244: CALL_OW 257
46248: PUSH
46249: LD_INT 3
46251: EQUAL
46252: IFFALSE 46256
// continue ;
46254: GO 46222
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46256: LD_ADDR_VAR 0 11
46260: PUSH
46261: LD_VAR 0 11
46265: PPUSH
46266: LD_VAR 0 11
46270: PUSH
46271: LD_INT 1
46273: PLUS
46274: PPUSH
46275: LD_VAR 0 9
46279: PUSH
46280: LD_VAR 0 3
46284: ARRAY
46285: PPUSH
46286: CALL_OW 2
46290: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46291: LD_ADDR_VAR 0 4
46295: PUSH
46296: LD_VAR 0 4
46300: PUSH
46301: LD_VAR 0 9
46305: PUSH
46306: LD_VAR 0 3
46310: ARRAY
46311: DIFF
46312: ST_TO_ADDR
// end ;
46313: GO 46222
46315: POP
46316: POP
// if p then
46317: LD_VAR 0 11
46321: IFFALSE 46346
// result := Replace ( result , 3 , p ) ;
46323: LD_ADDR_VAR 0 2
46327: PUSH
46328: LD_VAR 0 2
46332: PPUSH
46333: LD_INT 3
46335: PPUSH
46336: LD_VAR 0 11
46340: PPUSH
46341: CALL_OW 1
46345: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46346: LD_VAR 0 4
46350: PUSH
46351: LD_INT 6
46353: GREATER
46354: PUSH
46355: LD_VAR 0 6
46359: PUSH
46360: LD_INT 6
46362: LESS
46363: AND
46364: IFFALSE 46558
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46366: LD_ADDR_VAR 0 9
46370: PUSH
46371: LD_VAR 0 4
46375: PUSH
46376: LD_VAR 0 8
46380: PUSH
46381: LD_VAR 0 7
46385: UNION
46386: PUSH
46387: LD_VAR 0 6
46391: UNION
46392: DIFF
46393: PPUSH
46394: LD_INT 2
46396: PPUSH
46397: CALL 106608 0 2
46401: ST_TO_ADDR
// p := [ ] ;
46402: LD_ADDR_VAR 0 11
46406: PUSH
46407: EMPTY
46408: ST_TO_ADDR
// if sort then
46409: LD_VAR 0 9
46413: IFFALSE 46529
// for i = 1 to 6 - eng do
46415: LD_ADDR_VAR 0 3
46419: PUSH
46420: DOUBLE
46421: LD_INT 1
46423: DEC
46424: ST_TO_ADDR
46425: LD_INT 6
46427: PUSH
46428: LD_VAR 0 6
46432: MINUS
46433: PUSH
46434: FOR_TO
46435: IFFALSE 46527
// begin if i = sort then
46437: LD_VAR 0 3
46441: PUSH
46442: LD_VAR 0 9
46446: EQUAL
46447: IFFALSE 46451
// break ;
46449: GO 46527
// if GetClass ( i ) = 2 then
46451: LD_VAR 0 3
46455: PPUSH
46456: CALL_OW 257
46460: PUSH
46461: LD_INT 2
46463: EQUAL
46464: IFFALSE 46468
// continue ;
46466: GO 46434
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46468: LD_ADDR_VAR 0 11
46472: PUSH
46473: LD_VAR 0 11
46477: PPUSH
46478: LD_VAR 0 11
46482: PUSH
46483: LD_INT 1
46485: PLUS
46486: PPUSH
46487: LD_VAR 0 9
46491: PUSH
46492: LD_VAR 0 3
46496: ARRAY
46497: PPUSH
46498: CALL_OW 2
46502: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46503: LD_ADDR_VAR 0 4
46507: PUSH
46508: LD_VAR 0 4
46512: PUSH
46513: LD_VAR 0 9
46517: PUSH
46518: LD_VAR 0 3
46522: ARRAY
46523: DIFF
46524: ST_TO_ADDR
// end ;
46525: GO 46434
46527: POP
46528: POP
// if p then
46529: LD_VAR 0 11
46533: IFFALSE 46558
// result := Replace ( result , 2 , p ) ;
46535: LD_ADDR_VAR 0 2
46539: PUSH
46540: LD_VAR 0 2
46544: PPUSH
46545: LD_INT 2
46547: PPUSH
46548: LD_VAR 0 11
46552: PPUSH
46553: CALL_OW 1
46557: ST_TO_ADDR
// end ; exit ;
46558: GO 47946
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46560: LD_EXP 129
46564: PUSH
46565: LD_EXP 128
46569: PUSH
46570: LD_VAR 0 1
46574: ARRAY
46575: ARRAY
46576: NOT
46577: PUSH
46578: LD_EXP 102
46582: PUSH
46583: LD_VAR 0 1
46587: ARRAY
46588: PPUSH
46589: LD_INT 30
46591: PUSH
46592: LD_INT 3
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PPUSH
46599: CALL_OW 72
46603: AND
46604: PUSH
46605: LD_EXP 107
46609: PUSH
46610: LD_VAR 0 1
46614: ARRAY
46615: AND
46616: IFFALSE 47224
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46618: LD_ADDR_EXP 144
46622: PUSH
46623: LD_EXP 144
46627: PPUSH
46628: LD_VAR 0 1
46632: PPUSH
46633: LD_INT 5
46635: PPUSH
46636: CALL_OW 1
46640: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46641: LD_ADDR_VAR 0 2
46645: PUSH
46646: LD_INT 0
46648: PUSH
46649: LD_INT 0
46651: PUSH
46652: LD_INT 0
46654: PUSH
46655: LD_INT 0
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: ST_TO_ADDR
// if sci > 1 then
46664: LD_VAR 0 8
46668: PUSH
46669: LD_INT 1
46671: GREATER
46672: IFFALSE 46700
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46674: LD_ADDR_VAR 0 4
46678: PUSH
46679: LD_VAR 0 4
46683: PUSH
46684: LD_VAR 0 8
46688: PUSH
46689: LD_VAR 0 8
46693: PUSH
46694: LD_INT 1
46696: ARRAY
46697: DIFF
46698: DIFF
46699: ST_TO_ADDR
// if tmp and not sci then
46700: LD_VAR 0 4
46704: PUSH
46705: LD_VAR 0 8
46709: NOT
46710: AND
46711: IFFALSE 46780
// begin sort := SortBySkill ( tmp , 4 ) ;
46713: LD_ADDR_VAR 0 9
46717: PUSH
46718: LD_VAR 0 4
46722: PPUSH
46723: LD_INT 4
46725: PPUSH
46726: CALL 106608 0 2
46730: ST_TO_ADDR
// if sort then
46731: LD_VAR 0 9
46735: IFFALSE 46751
// p := sort [ 1 ] ;
46737: LD_ADDR_VAR 0 11
46741: PUSH
46742: LD_VAR 0 9
46746: PUSH
46747: LD_INT 1
46749: ARRAY
46750: ST_TO_ADDR
// if p then
46751: LD_VAR 0 11
46755: IFFALSE 46780
// result := Replace ( result , 4 , p ) ;
46757: LD_ADDR_VAR 0 2
46761: PUSH
46762: LD_VAR 0 2
46766: PPUSH
46767: LD_INT 4
46769: PPUSH
46770: LD_VAR 0 11
46774: PPUSH
46775: CALL_OW 1
46779: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46780: LD_ADDR_VAR 0 4
46784: PUSH
46785: LD_VAR 0 4
46789: PUSH
46790: LD_VAR 0 7
46794: DIFF
46795: ST_TO_ADDR
// if tmp and mech < 6 then
46796: LD_VAR 0 4
46800: PUSH
46801: LD_VAR 0 7
46805: PUSH
46806: LD_INT 6
46808: LESS
46809: AND
46810: IFFALSE 46998
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46812: LD_ADDR_VAR 0 9
46816: PUSH
46817: LD_VAR 0 4
46821: PUSH
46822: LD_VAR 0 8
46826: PUSH
46827: LD_VAR 0 7
46831: UNION
46832: DIFF
46833: PPUSH
46834: LD_INT 3
46836: PPUSH
46837: CALL 106608 0 2
46841: ST_TO_ADDR
// p := [ ] ;
46842: LD_ADDR_VAR 0 11
46846: PUSH
46847: EMPTY
46848: ST_TO_ADDR
// if sort then
46849: LD_VAR 0 9
46853: IFFALSE 46969
// for i = 1 to 6 - mech do
46855: LD_ADDR_VAR 0 3
46859: PUSH
46860: DOUBLE
46861: LD_INT 1
46863: DEC
46864: ST_TO_ADDR
46865: LD_INT 6
46867: PUSH
46868: LD_VAR 0 7
46872: MINUS
46873: PUSH
46874: FOR_TO
46875: IFFALSE 46967
// begin if i = sort then
46877: LD_VAR 0 3
46881: PUSH
46882: LD_VAR 0 9
46886: EQUAL
46887: IFFALSE 46891
// break ;
46889: GO 46967
// if GetClass ( i ) = 3 then
46891: LD_VAR 0 3
46895: PPUSH
46896: CALL_OW 257
46900: PUSH
46901: LD_INT 3
46903: EQUAL
46904: IFFALSE 46908
// continue ;
46906: GO 46874
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46908: LD_ADDR_VAR 0 11
46912: PUSH
46913: LD_VAR 0 11
46917: PPUSH
46918: LD_VAR 0 11
46922: PUSH
46923: LD_INT 1
46925: PLUS
46926: PPUSH
46927: LD_VAR 0 9
46931: PUSH
46932: LD_VAR 0 3
46936: ARRAY
46937: PPUSH
46938: CALL_OW 2
46942: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46943: LD_ADDR_VAR 0 4
46947: PUSH
46948: LD_VAR 0 4
46952: PUSH
46953: LD_VAR 0 9
46957: PUSH
46958: LD_VAR 0 3
46962: ARRAY
46963: DIFF
46964: ST_TO_ADDR
// end ;
46965: GO 46874
46967: POP
46968: POP
// if p then
46969: LD_VAR 0 11
46973: IFFALSE 46998
// result := Replace ( result , 3 , p ) ;
46975: LD_ADDR_VAR 0 2
46979: PUSH
46980: LD_VAR 0 2
46984: PPUSH
46985: LD_INT 3
46987: PPUSH
46988: LD_VAR 0 11
46992: PPUSH
46993: CALL_OW 1
46997: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46998: LD_ADDR_VAR 0 4
47002: PUSH
47003: LD_VAR 0 4
47007: PUSH
47008: LD_VAR 0 6
47012: DIFF
47013: ST_TO_ADDR
// if tmp and eng < 6 then
47014: LD_VAR 0 4
47018: PUSH
47019: LD_VAR 0 6
47023: PUSH
47024: LD_INT 6
47026: LESS
47027: AND
47028: IFFALSE 47222
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47030: LD_ADDR_VAR 0 9
47034: PUSH
47035: LD_VAR 0 4
47039: PUSH
47040: LD_VAR 0 8
47044: PUSH
47045: LD_VAR 0 7
47049: UNION
47050: PUSH
47051: LD_VAR 0 6
47055: UNION
47056: DIFF
47057: PPUSH
47058: LD_INT 2
47060: PPUSH
47061: CALL 106608 0 2
47065: ST_TO_ADDR
// p := [ ] ;
47066: LD_ADDR_VAR 0 11
47070: PUSH
47071: EMPTY
47072: ST_TO_ADDR
// if sort then
47073: LD_VAR 0 9
47077: IFFALSE 47193
// for i = 1 to 6 - eng do
47079: LD_ADDR_VAR 0 3
47083: PUSH
47084: DOUBLE
47085: LD_INT 1
47087: DEC
47088: ST_TO_ADDR
47089: LD_INT 6
47091: PUSH
47092: LD_VAR 0 6
47096: MINUS
47097: PUSH
47098: FOR_TO
47099: IFFALSE 47191
// begin if i = sort then
47101: LD_VAR 0 3
47105: PUSH
47106: LD_VAR 0 9
47110: EQUAL
47111: IFFALSE 47115
// break ;
47113: GO 47191
// if GetClass ( i ) = 2 then
47115: LD_VAR 0 3
47119: PPUSH
47120: CALL_OW 257
47124: PUSH
47125: LD_INT 2
47127: EQUAL
47128: IFFALSE 47132
// continue ;
47130: GO 47098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47132: LD_ADDR_VAR 0 11
47136: PUSH
47137: LD_VAR 0 11
47141: PPUSH
47142: LD_VAR 0 11
47146: PUSH
47147: LD_INT 1
47149: PLUS
47150: PPUSH
47151: LD_VAR 0 9
47155: PUSH
47156: LD_VAR 0 3
47160: ARRAY
47161: PPUSH
47162: CALL_OW 2
47166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47167: LD_ADDR_VAR 0 4
47171: PUSH
47172: LD_VAR 0 4
47176: PUSH
47177: LD_VAR 0 9
47181: PUSH
47182: LD_VAR 0 3
47186: ARRAY
47187: DIFF
47188: ST_TO_ADDR
// end ;
47189: GO 47098
47191: POP
47192: POP
// if p then
47193: LD_VAR 0 11
47197: IFFALSE 47222
// result := Replace ( result , 2 , p ) ;
47199: LD_ADDR_VAR 0 2
47203: PUSH
47204: LD_VAR 0 2
47208: PPUSH
47209: LD_INT 2
47211: PPUSH
47212: LD_VAR 0 11
47216: PPUSH
47217: CALL_OW 1
47221: ST_TO_ADDR
// end ; exit ;
47222: GO 47946
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47224: LD_EXP 129
47228: PUSH
47229: LD_EXP 128
47233: PUSH
47234: LD_VAR 0 1
47238: ARRAY
47239: ARRAY
47240: NOT
47241: PUSH
47242: LD_EXP 102
47246: PUSH
47247: LD_VAR 0 1
47251: ARRAY
47252: PPUSH
47253: LD_INT 30
47255: PUSH
47256: LD_INT 3
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PPUSH
47263: CALL_OW 72
47267: AND
47268: PUSH
47269: LD_EXP 107
47273: PUSH
47274: LD_VAR 0 1
47278: ARRAY
47279: NOT
47280: AND
47281: IFFALSE 47946
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47283: LD_ADDR_EXP 144
47287: PUSH
47288: LD_EXP 144
47292: PPUSH
47293: LD_VAR 0 1
47297: PPUSH
47298: LD_INT 6
47300: PPUSH
47301: CALL_OW 1
47305: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47306: LD_ADDR_VAR 0 2
47310: PUSH
47311: LD_INT 0
47313: PUSH
47314: LD_INT 0
47316: PUSH
47317: LD_INT 0
47319: PUSH
47320: LD_INT 0
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: ST_TO_ADDR
// if sci >= 1 then
47329: LD_VAR 0 8
47333: PUSH
47334: LD_INT 1
47336: GREATEREQUAL
47337: IFFALSE 47359
// tmp := tmp diff sci [ 1 ] ;
47339: LD_ADDR_VAR 0 4
47343: PUSH
47344: LD_VAR 0 4
47348: PUSH
47349: LD_VAR 0 8
47353: PUSH
47354: LD_INT 1
47356: ARRAY
47357: DIFF
47358: ST_TO_ADDR
// if tmp and not sci then
47359: LD_VAR 0 4
47363: PUSH
47364: LD_VAR 0 8
47368: NOT
47369: AND
47370: IFFALSE 47439
// begin sort := SortBySkill ( tmp , 4 ) ;
47372: LD_ADDR_VAR 0 9
47376: PUSH
47377: LD_VAR 0 4
47381: PPUSH
47382: LD_INT 4
47384: PPUSH
47385: CALL 106608 0 2
47389: ST_TO_ADDR
// if sort then
47390: LD_VAR 0 9
47394: IFFALSE 47410
// p := sort [ 1 ] ;
47396: LD_ADDR_VAR 0 11
47400: PUSH
47401: LD_VAR 0 9
47405: PUSH
47406: LD_INT 1
47408: ARRAY
47409: ST_TO_ADDR
// if p then
47410: LD_VAR 0 11
47414: IFFALSE 47439
// result := Replace ( result , 4 , p ) ;
47416: LD_ADDR_VAR 0 2
47420: PUSH
47421: LD_VAR 0 2
47425: PPUSH
47426: LD_INT 4
47428: PPUSH
47429: LD_VAR 0 11
47433: PPUSH
47434: CALL_OW 1
47438: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47439: LD_ADDR_VAR 0 4
47443: PUSH
47444: LD_VAR 0 4
47448: PUSH
47449: LD_VAR 0 7
47453: DIFF
47454: ST_TO_ADDR
// if tmp and mech < 6 then
47455: LD_VAR 0 4
47459: PUSH
47460: LD_VAR 0 7
47464: PUSH
47465: LD_INT 6
47467: LESS
47468: AND
47469: IFFALSE 47651
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47471: LD_ADDR_VAR 0 9
47475: PUSH
47476: LD_VAR 0 4
47480: PUSH
47481: LD_VAR 0 7
47485: DIFF
47486: PPUSH
47487: LD_INT 3
47489: PPUSH
47490: CALL 106608 0 2
47494: ST_TO_ADDR
// p := [ ] ;
47495: LD_ADDR_VAR 0 11
47499: PUSH
47500: EMPTY
47501: ST_TO_ADDR
// if sort then
47502: LD_VAR 0 9
47506: IFFALSE 47622
// for i = 1 to 6 - mech do
47508: LD_ADDR_VAR 0 3
47512: PUSH
47513: DOUBLE
47514: LD_INT 1
47516: DEC
47517: ST_TO_ADDR
47518: LD_INT 6
47520: PUSH
47521: LD_VAR 0 7
47525: MINUS
47526: PUSH
47527: FOR_TO
47528: IFFALSE 47620
// begin if i = sort then
47530: LD_VAR 0 3
47534: PUSH
47535: LD_VAR 0 9
47539: EQUAL
47540: IFFALSE 47544
// break ;
47542: GO 47620
// if GetClass ( i ) = 3 then
47544: LD_VAR 0 3
47548: PPUSH
47549: CALL_OW 257
47553: PUSH
47554: LD_INT 3
47556: EQUAL
47557: IFFALSE 47561
// continue ;
47559: GO 47527
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47561: LD_ADDR_VAR 0 11
47565: PUSH
47566: LD_VAR 0 11
47570: PPUSH
47571: LD_VAR 0 11
47575: PUSH
47576: LD_INT 1
47578: PLUS
47579: PPUSH
47580: LD_VAR 0 9
47584: PUSH
47585: LD_VAR 0 3
47589: ARRAY
47590: PPUSH
47591: CALL_OW 2
47595: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47596: LD_ADDR_VAR 0 4
47600: PUSH
47601: LD_VAR 0 4
47605: PUSH
47606: LD_VAR 0 9
47610: PUSH
47611: LD_VAR 0 3
47615: ARRAY
47616: DIFF
47617: ST_TO_ADDR
// end ;
47618: GO 47527
47620: POP
47621: POP
// if p then
47622: LD_VAR 0 11
47626: IFFALSE 47651
// result := Replace ( result , 3 , p ) ;
47628: LD_ADDR_VAR 0 2
47632: PUSH
47633: LD_VAR 0 2
47637: PPUSH
47638: LD_INT 3
47640: PPUSH
47641: LD_VAR 0 11
47645: PPUSH
47646: CALL_OW 1
47650: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47651: LD_ADDR_VAR 0 4
47655: PUSH
47656: LD_VAR 0 4
47660: PUSH
47661: LD_VAR 0 6
47665: DIFF
47666: ST_TO_ADDR
// if tmp and eng < 4 then
47667: LD_VAR 0 4
47671: PUSH
47672: LD_VAR 0 6
47676: PUSH
47677: LD_INT 4
47679: LESS
47680: AND
47681: IFFALSE 47871
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
47683: LD_ADDR_VAR 0 9
47687: PUSH
47688: LD_VAR 0 4
47692: PUSH
47693: LD_VAR 0 7
47697: PUSH
47698: LD_VAR 0 6
47702: UNION
47703: DIFF
47704: PPUSH
47705: LD_INT 2
47707: PPUSH
47708: CALL 106608 0 2
47712: ST_TO_ADDR
// p := [ ] ;
47713: LD_ADDR_VAR 0 11
47717: PUSH
47718: EMPTY
47719: ST_TO_ADDR
// if sort then
47720: LD_VAR 0 9
47724: IFFALSE 47840
// for i = 1 to 4 - eng do
47726: LD_ADDR_VAR 0 3
47730: PUSH
47731: DOUBLE
47732: LD_INT 1
47734: DEC
47735: ST_TO_ADDR
47736: LD_INT 4
47738: PUSH
47739: LD_VAR 0 6
47743: MINUS
47744: PUSH
47745: FOR_TO
47746: IFFALSE 47838
// begin if i = sort then
47748: LD_VAR 0 3
47752: PUSH
47753: LD_VAR 0 9
47757: EQUAL
47758: IFFALSE 47762
// break ;
47760: GO 47838
// if GetClass ( i ) = 2 then
47762: LD_VAR 0 3
47766: PPUSH
47767: CALL_OW 257
47771: PUSH
47772: LD_INT 2
47774: EQUAL
47775: IFFALSE 47779
// continue ;
47777: GO 47745
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47779: LD_ADDR_VAR 0 11
47783: PUSH
47784: LD_VAR 0 11
47788: PPUSH
47789: LD_VAR 0 11
47793: PUSH
47794: LD_INT 1
47796: PLUS
47797: PPUSH
47798: LD_VAR 0 9
47802: PUSH
47803: LD_VAR 0 3
47807: ARRAY
47808: PPUSH
47809: CALL_OW 2
47813: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47814: LD_ADDR_VAR 0 4
47818: PUSH
47819: LD_VAR 0 4
47823: PUSH
47824: LD_VAR 0 9
47828: PUSH
47829: LD_VAR 0 3
47833: ARRAY
47834: DIFF
47835: ST_TO_ADDR
// end ;
47836: GO 47745
47838: POP
47839: POP
// if p then
47840: LD_VAR 0 11
47844: IFFALSE 47869
// result := Replace ( result , 2 , p ) ;
47846: LD_ADDR_VAR 0 2
47850: PUSH
47851: LD_VAR 0 2
47855: PPUSH
47856: LD_INT 2
47858: PPUSH
47859: LD_VAR 0 11
47863: PPUSH
47864: CALL_OW 1
47868: ST_TO_ADDR
// end else
47869: GO 47915
// for i = eng downto 5 do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: DOUBLE
47877: LD_VAR 0 6
47881: INC
47882: ST_TO_ADDR
47883: LD_INT 5
47885: PUSH
47886: FOR_DOWNTO
47887: IFFALSE 47913
// tmp := tmp union eng [ i ] ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_VAR 0 4
47898: PUSH
47899: LD_VAR 0 6
47903: PUSH
47904: LD_VAR 0 3
47908: ARRAY
47909: UNION
47910: ST_TO_ADDR
47911: GO 47886
47913: POP
47914: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47915: LD_ADDR_VAR 0 2
47919: PUSH
47920: LD_VAR 0 2
47924: PPUSH
47925: LD_INT 1
47927: PPUSH
47928: LD_VAR 0 4
47932: PUSH
47933: LD_VAR 0 5
47937: DIFF
47938: PPUSH
47939: CALL_OW 1
47943: ST_TO_ADDR
// exit ;
47944: GO 47946
// end ; end ;
47946: LD_VAR 0 2
47950: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47951: LD_INT 0
47953: PPUSH
47954: PPUSH
47955: PPUSH
// if not mc_bases then
47956: LD_EXP 102
47960: NOT
47961: IFFALSE 47965
// exit ;
47963: GO 48107
// for i = 1 to mc_bases do
47965: LD_ADDR_VAR 0 2
47969: PUSH
47970: DOUBLE
47971: LD_INT 1
47973: DEC
47974: ST_TO_ADDR
47975: LD_EXP 102
47979: PUSH
47980: FOR_TO
47981: IFFALSE 48098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47983: LD_ADDR_VAR 0 3
47987: PUSH
47988: LD_EXP 102
47992: PUSH
47993: LD_VAR 0 2
47997: ARRAY
47998: PPUSH
47999: LD_INT 21
48001: PUSH
48002: LD_INT 3
48004: PUSH
48005: EMPTY
48006: LIST
48007: LIST
48008: PUSH
48009: LD_INT 3
48011: PUSH
48012: LD_INT 2
48014: PUSH
48015: LD_INT 30
48017: PUSH
48018: LD_INT 29
48020: PUSH
48021: EMPTY
48022: LIST
48023: LIST
48024: PUSH
48025: LD_INT 30
48027: PUSH
48028: LD_INT 30
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: PUSH
48035: EMPTY
48036: LIST
48037: LIST
48038: LIST
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 3
48046: PUSH
48047: LD_INT 24
48049: PUSH
48050: LD_INT 1000
48052: PUSH
48053: EMPTY
48054: LIST
48055: LIST
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: LIST
48065: PPUSH
48066: CALL_OW 72
48070: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48071: LD_ADDR_EXP 103
48075: PUSH
48076: LD_EXP 103
48080: PPUSH
48081: LD_VAR 0 2
48085: PPUSH
48086: LD_VAR 0 3
48090: PPUSH
48091: CALL_OW 1
48095: ST_TO_ADDR
// end ;
48096: GO 47980
48098: POP
48099: POP
// RaiseSailEvent ( 101 ) ;
48100: LD_INT 101
48102: PPUSH
48103: CALL_OW 427
// end ;
48107: LD_VAR 0 1
48111: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48112: LD_INT 0
48114: PPUSH
48115: PPUSH
48116: PPUSH
48117: PPUSH
48118: PPUSH
48119: PPUSH
48120: PPUSH
// if not mc_bases then
48121: LD_EXP 102
48125: NOT
48126: IFFALSE 48130
// exit ;
48128: GO 48692
// for i = 1 to mc_bases do
48130: LD_ADDR_VAR 0 2
48134: PUSH
48135: DOUBLE
48136: LD_INT 1
48138: DEC
48139: ST_TO_ADDR
48140: LD_EXP 102
48144: PUSH
48145: FOR_TO
48146: IFFALSE 48683
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48148: LD_ADDR_VAR 0 5
48152: PUSH
48153: LD_EXP 102
48157: PUSH
48158: LD_VAR 0 2
48162: ARRAY
48163: PUSH
48164: LD_EXP 131
48168: PUSH
48169: LD_VAR 0 2
48173: ARRAY
48174: UNION
48175: PPUSH
48176: LD_INT 21
48178: PUSH
48179: LD_INT 1
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PUSH
48186: LD_INT 1
48188: PUSH
48189: LD_INT 3
48191: PUSH
48192: LD_INT 54
48194: PUSH
48195: EMPTY
48196: LIST
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: LD_INT 3
48204: PUSH
48205: LD_INT 24
48207: PUSH
48208: LD_INT 1000
48210: PUSH
48211: EMPTY
48212: LIST
48213: LIST
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: LIST
48223: PUSH
48224: EMPTY
48225: LIST
48226: LIST
48227: PPUSH
48228: CALL_OW 72
48232: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48233: LD_ADDR_VAR 0 6
48237: PUSH
48238: LD_EXP 102
48242: PUSH
48243: LD_VAR 0 2
48247: ARRAY
48248: PPUSH
48249: LD_INT 21
48251: PUSH
48252: LD_INT 1
48254: PUSH
48255: EMPTY
48256: LIST
48257: LIST
48258: PUSH
48259: LD_INT 1
48261: PUSH
48262: LD_INT 3
48264: PUSH
48265: LD_INT 54
48267: PUSH
48268: EMPTY
48269: LIST
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: PUSH
48275: LD_INT 3
48277: PUSH
48278: LD_INT 24
48280: PUSH
48281: LD_INT 250
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PUSH
48288: EMPTY
48289: LIST
48290: LIST
48291: PUSH
48292: EMPTY
48293: LIST
48294: LIST
48295: LIST
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: PPUSH
48301: CALL_OW 72
48305: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48306: LD_ADDR_VAR 0 7
48310: PUSH
48311: LD_VAR 0 5
48315: PUSH
48316: LD_VAR 0 6
48320: DIFF
48321: ST_TO_ADDR
// if not need_heal_1 then
48322: LD_VAR 0 6
48326: NOT
48327: IFFALSE 48360
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48329: LD_ADDR_EXP 105
48333: PUSH
48334: LD_EXP 105
48338: PPUSH
48339: LD_VAR 0 2
48343: PUSH
48344: LD_INT 1
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PPUSH
48351: EMPTY
48352: PPUSH
48353: CALL 75355 0 3
48357: ST_TO_ADDR
48358: GO 48430
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48360: LD_ADDR_EXP 105
48364: PUSH
48365: LD_EXP 105
48369: PPUSH
48370: LD_VAR 0 2
48374: PUSH
48375: LD_INT 1
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: PPUSH
48382: LD_EXP 105
48386: PUSH
48387: LD_VAR 0 2
48391: ARRAY
48392: PUSH
48393: LD_INT 1
48395: ARRAY
48396: PPUSH
48397: LD_INT 3
48399: PUSH
48400: LD_INT 24
48402: PUSH
48403: LD_INT 1000
48405: PUSH
48406: EMPTY
48407: LIST
48408: LIST
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: PPUSH
48414: CALL_OW 72
48418: PUSH
48419: LD_VAR 0 6
48423: UNION
48424: PPUSH
48425: CALL 75355 0 3
48429: ST_TO_ADDR
// if not need_heal_2 then
48430: LD_VAR 0 7
48434: NOT
48435: IFFALSE 48468
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48437: LD_ADDR_EXP 105
48441: PUSH
48442: LD_EXP 105
48446: PPUSH
48447: LD_VAR 0 2
48451: PUSH
48452: LD_INT 2
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PPUSH
48459: EMPTY
48460: PPUSH
48461: CALL 75355 0 3
48465: ST_TO_ADDR
48466: GO 48500
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48468: LD_ADDR_EXP 105
48472: PUSH
48473: LD_EXP 105
48477: PPUSH
48478: LD_VAR 0 2
48482: PUSH
48483: LD_INT 2
48485: PUSH
48486: EMPTY
48487: LIST
48488: LIST
48489: PPUSH
48490: LD_VAR 0 7
48494: PPUSH
48495: CALL 75355 0 3
48499: ST_TO_ADDR
// if need_heal_2 then
48500: LD_VAR 0 7
48504: IFFALSE 48665
// for j in need_heal_2 do
48506: LD_ADDR_VAR 0 3
48510: PUSH
48511: LD_VAR 0 7
48515: PUSH
48516: FOR_IN
48517: IFFALSE 48663
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48519: LD_ADDR_VAR 0 5
48523: PUSH
48524: LD_EXP 102
48528: PUSH
48529: LD_VAR 0 2
48533: ARRAY
48534: PPUSH
48535: LD_INT 2
48537: PUSH
48538: LD_INT 30
48540: PUSH
48541: LD_INT 6
48543: PUSH
48544: EMPTY
48545: LIST
48546: LIST
48547: PUSH
48548: LD_INT 30
48550: PUSH
48551: LD_INT 7
48553: PUSH
48554: EMPTY
48555: LIST
48556: LIST
48557: PUSH
48558: LD_INT 30
48560: PUSH
48561: LD_INT 8
48563: PUSH
48564: EMPTY
48565: LIST
48566: LIST
48567: PUSH
48568: LD_INT 30
48570: PUSH
48571: LD_INT 0
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 30
48580: PUSH
48581: LD_INT 1
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: EMPTY
48589: LIST
48590: LIST
48591: LIST
48592: LIST
48593: LIST
48594: LIST
48595: PPUSH
48596: CALL_OW 72
48600: ST_TO_ADDR
// if tmp then
48601: LD_VAR 0 5
48605: IFFALSE 48661
// begin k := NearestUnitToUnit ( tmp , j ) ;
48607: LD_ADDR_VAR 0 4
48611: PUSH
48612: LD_VAR 0 5
48616: PPUSH
48617: LD_VAR 0 3
48621: PPUSH
48622: CALL_OW 74
48626: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48627: LD_VAR 0 3
48631: PPUSH
48632: LD_VAR 0 4
48636: PPUSH
48637: CALL_OW 296
48641: PUSH
48642: LD_INT 5
48644: GREATER
48645: IFFALSE 48661
// ComMoveToNearbyEntrance ( j , k ) ;
48647: LD_VAR 0 3
48651: PPUSH
48652: LD_VAR 0 4
48656: PPUSH
48657: CALL 108981 0 2
// end ; end ;
48661: GO 48516
48663: POP
48664: POP
// if not need_heal_1 and not need_heal_2 then
48665: LD_VAR 0 6
48669: NOT
48670: PUSH
48671: LD_VAR 0 7
48675: NOT
48676: AND
48677: IFFALSE 48681
// continue ;
48679: GO 48145
// end ;
48681: GO 48145
48683: POP
48684: POP
// RaiseSailEvent ( 102 ) ;
48685: LD_INT 102
48687: PPUSH
48688: CALL_OW 427
// end ;
48692: LD_VAR 0 1
48696: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
48697: LD_INT 0
48699: PPUSH
48700: PPUSH
48701: PPUSH
48702: PPUSH
48703: PPUSH
48704: PPUSH
48705: PPUSH
48706: PPUSH
// if not mc_bases then
48707: LD_EXP 102
48711: NOT
48712: IFFALSE 48716
// exit ;
48714: GO 49627
// for i = 1 to mc_bases do
48716: LD_ADDR_VAR 0 2
48720: PUSH
48721: DOUBLE
48722: LD_INT 1
48724: DEC
48725: ST_TO_ADDR
48726: LD_EXP 102
48730: PUSH
48731: FOR_TO
48732: IFFALSE 49625
// begin if not mc_building_need_repair [ i ] then
48734: LD_EXP 103
48738: PUSH
48739: LD_VAR 0 2
48743: ARRAY
48744: NOT
48745: IFFALSE 48930
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
48747: LD_ADDR_VAR 0 6
48751: PUSH
48752: LD_EXP 121
48756: PUSH
48757: LD_VAR 0 2
48761: ARRAY
48762: PPUSH
48763: LD_INT 3
48765: PUSH
48766: LD_INT 24
48768: PUSH
48769: LD_INT 1000
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 2
48782: PUSH
48783: LD_INT 34
48785: PUSH
48786: LD_INT 13
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PUSH
48793: LD_INT 34
48795: PUSH
48796: LD_INT 52
48798: PUSH
48799: EMPTY
48800: LIST
48801: LIST
48802: PUSH
48803: LD_INT 34
48805: PUSH
48806: LD_INT 88
48808: PUSH
48809: EMPTY
48810: LIST
48811: LIST
48812: PUSH
48813: EMPTY
48814: LIST
48815: LIST
48816: LIST
48817: LIST
48818: PUSH
48819: EMPTY
48820: LIST
48821: LIST
48822: PPUSH
48823: CALL_OW 72
48827: ST_TO_ADDR
// if cranes then
48828: LD_VAR 0 6
48832: IFFALSE 48894
// for j in cranes do
48834: LD_ADDR_VAR 0 3
48838: PUSH
48839: LD_VAR 0 6
48843: PUSH
48844: FOR_IN
48845: IFFALSE 48892
// if not IsInArea ( j , mc_parking [ i ] ) then
48847: LD_VAR 0 3
48851: PPUSH
48852: LD_EXP 126
48856: PUSH
48857: LD_VAR 0 2
48861: ARRAY
48862: PPUSH
48863: CALL_OW 308
48867: NOT
48868: IFFALSE 48890
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48870: LD_VAR 0 3
48874: PPUSH
48875: LD_EXP 126
48879: PUSH
48880: LD_VAR 0 2
48884: ARRAY
48885: PPUSH
48886: CALL_OW 113
48890: GO 48844
48892: POP
48893: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48894: LD_ADDR_EXP 104
48898: PUSH
48899: LD_EXP 104
48903: PPUSH
48904: LD_VAR 0 2
48908: PPUSH
48909: EMPTY
48910: PPUSH
48911: CALL_OW 1
48915: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48916: LD_VAR 0 2
48920: PPUSH
48921: LD_INT 101
48923: PPUSH
48924: CALL 43770 0 2
// continue ;
48928: GO 48731
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48930: LD_ADDR_EXP 108
48934: PUSH
48935: LD_EXP 108
48939: PPUSH
48940: LD_VAR 0 2
48944: PPUSH
48945: EMPTY
48946: PPUSH
48947: CALL_OW 1
48951: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48952: LD_VAR 0 2
48956: PPUSH
48957: LD_INT 103
48959: PPUSH
48960: CALL 43770 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48964: LD_ADDR_VAR 0 5
48968: PUSH
48969: LD_EXP 102
48973: PUSH
48974: LD_VAR 0 2
48978: ARRAY
48979: PUSH
48980: LD_EXP 131
48984: PUSH
48985: LD_VAR 0 2
48989: ARRAY
48990: UNION
48991: PPUSH
48992: LD_INT 2
48994: PUSH
48995: LD_INT 25
48997: PUSH
48998: LD_INT 2
49000: PUSH
49001: EMPTY
49002: LIST
49003: LIST
49004: PUSH
49005: LD_INT 25
49007: PUSH
49008: LD_INT 16
49010: PUSH
49011: EMPTY
49012: LIST
49013: LIST
49014: PUSH
49015: EMPTY
49016: LIST
49017: LIST
49018: LIST
49019: PUSH
49020: EMPTY
49021: LIST
49022: PPUSH
49023: CALL_OW 72
49027: ST_TO_ADDR
// if mc_need_heal [ i ] then
49028: LD_EXP 105
49032: PUSH
49033: LD_VAR 0 2
49037: ARRAY
49038: IFFALSE 49082
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49040: LD_ADDR_VAR 0 5
49044: PUSH
49045: LD_VAR 0 5
49049: PUSH
49050: LD_EXP 105
49054: PUSH
49055: LD_VAR 0 2
49059: ARRAY
49060: PUSH
49061: LD_INT 1
49063: ARRAY
49064: PUSH
49065: LD_EXP 105
49069: PUSH
49070: LD_VAR 0 2
49074: ARRAY
49075: PUSH
49076: LD_INT 2
49078: ARRAY
49079: UNION
49080: DIFF
49081: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49082: LD_ADDR_VAR 0 6
49086: PUSH
49087: LD_EXP 121
49091: PUSH
49092: LD_VAR 0 2
49096: ARRAY
49097: PPUSH
49098: LD_INT 2
49100: PUSH
49101: LD_INT 34
49103: PUSH
49104: LD_INT 13
49106: PUSH
49107: EMPTY
49108: LIST
49109: LIST
49110: PUSH
49111: LD_INT 34
49113: PUSH
49114: LD_INT 52
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: PUSH
49121: LD_INT 34
49123: PUSH
49124: LD_INT 88
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: EMPTY
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: PPUSH
49137: CALL_OW 72
49141: ST_TO_ADDR
// if cranes then
49142: LD_VAR 0 6
49146: IFFALSE 49314
// begin for j in cranes do
49148: LD_ADDR_VAR 0 3
49152: PUSH
49153: LD_VAR 0 6
49157: PUSH
49158: FOR_IN
49159: IFFALSE 49312
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49161: LD_VAR 0 3
49165: PPUSH
49166: CALL_OW 256
49170: PUSH
49171: LD_INT 1000
49173: EQUAL
49174: PUSH
49175: LD_VAR 0 3
49179: PPUSH
49180: CALL_OW 314
49184: NOT
49185: AND
49186: IFFALSE 49252
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49188: LD_ADDR_VAR 0 8
49192: PUSH
49193: LD_EXP 103
49197: PUSH
49198: LD_VAR 0 2
49202: ARRAY
49203: PPUSH
49204: LD_VAR 0 3
49208: PPUSH
49209: CALL_OW 74
49213: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49214: LD_VAR 0 8
49218: PPUSH
49219: LD_INT 16
49221: PPUSH
49222: CALL 78320 0 2
49226: PUSH
49227: LD_INT 4
49229: ARRAY
49230: PUSH
49231: LD_INT 10
49233: LESS
49234: IFFALSE 49250
// ComRepairBuilding ( j , to_repair ) ;
49236: LD_VAR 0 3
49240: PPUSH
49241: LD_VAR 0 8
49245: PPUSH
49246: CALL_OW 130
// end else
49250: GO 49310
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49252: LD_VAR 0 3
49256: PPUSH
49257: CALL_OW 256
49261: PUSH
49262: LD_INT 500
49264: LESS
49265: PUSH
49266: LD_VAR 0 3
49270: PPUSH
49271: LD_EXP 126
49275: PUSH
49276: LD_VAR 0 2
49280: ARRAY
49281: PPUSH
49282: CALL_OW 308
49286: NOT
49287: AND
49288: IFFALSE 49310
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49290: LD_VAR 0 3
49294: PPUSH
49295: LD_EXP 126
49299: PUSH
49300: LD_VAR 0 2
49304: ARRAY
49305: PPUSH
49306: CALL_OW 113
// end ;
49310: GO 49158
49312: POP
49313: POP
// end ; if tmp > 3 then
49314: LD_VAR 0 5
49318: PUSH
49319: LD_INT 3
49321: GREATER
49322: IFFALSE 49342
// tmp := ShrinkArray ( tmp , 4 ) ;
49324: LD_ADDR_VAR 0 5
49328: PUSH
49329: LD_VAR 0 5
49333: PPUSH
49334: LD_INT 4
49336: PPUSH
49337: CALL 108419 0 2
49341: ST_TO_ADDR
// if not tmp then
49342: LD_VAR 0 5
49346: NOT
49347: IFFALSE 49351
// continue ;
49349: GO 48731
// for j in tmp do
49351: LD_ADDR_VAR 0 3
49355: PUSH
49356: LD_VAR 0 5
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49621
// begin if IsInUnit ( j ) then
49364: LD_VAR 0 3
49368: PPUSH
49369: CALL_OW 310
49373: IFFALSE 49384
// ComExitBuilding ( j ) ;
49375: LD_VAR 0 3
49379: PPUSH
49380: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49384: LD_VAR 0 3
49388: PUSH
49389: LD_EXP 104
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: IN
49400: NOT
49401: IFFALSE 49459
// begin SetTag ( j , 101 ) ;
49403: LD_VAR 0 3
49407: PPUSH
49408: LD_INT 101
49410: PPUSH
49411: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49415: LD_ADDR_EXP 104
49419: PUSH
49420: LD_EXP 104
49424: PPUSH
49425: LD_VAR 0 2
49429: PUSH
49430: LD_EXP 104
49434: PUSH
49435: LD_VAR 0 2
49439: ARRAY
49440: PUSH
49441: LD_INT 1
49443: PLUS
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PPUSH
49449: LD_VAR 0 3
49453: PPUSH
49454: CALL 75355 0 3
49458: ST_TO_ADDR
// end ; wait ( 1 ) ;
49459: LD_INT 1
49461: PPUSH
49462: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49466: LD_ADDR_VAR 0 7
49470: PUSH
49471: LD_EXP 103
49475: PUSH
49476: LD_VAR 0 2
49480: ARRAY
49481: ST_TO_ADDR
// if mc_scan [ i ] then
49482: LD_EXP 125
49486: PUSH
49487: LD_VAR 0 2
49491: ARRAY
49492: IFFALSE 49554
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49494: LD_ADDR_VAR 0 7
49498: PUSH
49499: LD_EXP 103
49503: PUSH
49504: LD_VAR 0 2
49508: ARRAY
49509: PPUSH
49510: LD_INT 3
49512: PUSH
49513: LD_INT 30
49515: PUSH
49516: LD_INT 32
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: LD_INT 30
49525: PUSH
49526: LD_INT 33
49528: PUSH
49529: EMPTY
49530: LIST
49531: LIST
49532: PUSH
49533: LD_INT 30
49535: PUSH
49536: LD_INT 31
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: PUSH
49543: EMPTY
49544: LIST
49545: LIST
49546: LIST
49547: LIST
49548: PPUSH
49549: CALL_OW 72
49553: ST_TO_ADDR
// if not to_repair_tmp then
49554: LD_VAR 0 7
49558: NOT
49559: IFFALSE 49563
// continue ;
49561: GO 49361
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49563: LD_ADDR_VAR 0 8
49567: PUSH
49568: LD_VAR 0 7
49572: PPUSH
49573: LD_VAR 0 3
49577: PPUSH
49578: CALL_OW 74
49582: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49583: LD_VAR 0 8
49587: PPUSH
49588: LD_INT 16
49590: PPUSH
49591: CALL 78320 0 2
49595: PUSH
49596: LD_INT 4
49598: ARRAY
49599: PUSH
49600: LD_INT 14
49602: LESS
49603: IFFALSE 49619
// ComRepairBuilding ( j , to_repair ) ;
49605: LD_VAR 0 3
49609: PPUSH
49610: LD_VAR 0 8
49614: PPUSH
49615: CALL_OW 130
// end ;
49619: GO 49361
49621: POP
49622: POP
// end ;
49623: GO 48731
49625: POP
49626: POP
// end ;
49627: LD_VAR 0 1
49631: RET
// export function MC_Heal ; var i , j , tmp ; begin
49632: LD_INT 0
49634: PPUSH
49635: PPUSH
49636: PPUSH
49637: PPUSH
// if not mc_bases then
49638: LD_EXP 102
49642: NOT
49643: IFFALSE 49647
// exit ;
49645: GO 50049
// for i = 1 to mc_bases do
49647: LD_ADDR_VAR 0 2
49651: PUSH
49652: DOUBLE
49653: LD_INT 1
49655: DEC
49656: ST_TO_ADDR
49657: LD_EXP 102
49661: PUSH
49662: FOR_TO
49663: IFFALSE 50047
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49665: LD_EXP 105
49669: PUSH
49670: LD_VAR 0 2
49674: ARRAY
49675: PUSH
49676: LD_INT 1
49678: ARRAY
49679: NOT
49680: PUSH
49681: LD_EXP 105
49685: PUSH
49686: LD_VAR 0 2
49690: ARRAY
49691: PUSH
49692: LD_INT 2
49694: ARRAY
49695: NOT
49696: AND
49697: IFFALSE 49735
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
49699: LD_ADDR_EXP 106
49703: PUSH
49704: LD_EXP 106
49708: PPUSH
49709: LD_VAR 0 2
49713: PPUSH
49714: EMPTY
49715: PPUSH
49716: CALL_OW 1
49720: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
49721: LD_VAR 0 2
49725: PPUSH
49726: LD_INT 102
49728: PPUSH
49729: CALL 43770 0 2
// continue ;
49733: GO 49662
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
49735: LD_ADDR_VAR 0 4
49739: PUSH
49740: LD_EXP 102
49744: PUSH
49745: LD_VAR 0 2
49749: ARRAY
49750: PPUSH
49751: LD_INT 25
49753: PUSH
49754: LD_INT 4
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PPUSH
49761: CALL_OW 72
49765: ST_TO_ADDR
// if not tmp then
49766: LD_VAR 0 4
49770: NOT
49771: IFFALSE 49775
// continue ;
49773: GO 49662
// if mc_taming [ i ] then
49775: LD_EXP 133
49779: PUSH
49780: LD_VAR 0 2
49784: ARRAY
49785: IFFALSE 49809
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49787: LD_ADDR_EXP 133
49791: PUSH
49792: LD_EXP 133
49796: PPUSH
49797: LD_VAR 0 2
49801: PPUSH
49802: EMPTY
49803: PPUSH
49804: CALL_OW 1
49808: ST_TO_ADDR
// for j in tmp do
49809: LD_ADDR_VAR 0 3
49813: PUSH
49814: LD_VAR 0 4
49818: PUSH
49819: FOR_IN
49820: IFFALSE 50043
// begin if IsInUnit ( j ) then
49822: LD_VAR 0 3
49826: PPUSH
49827: CALL_OW 310
49831: IFFALSE 49842
// ComExitBuilding ( j ) ;
49833: LD_VAR 0 3
49837: PPUSH
49838: CALL_OW 122
// if not j in mc_healers [ i ] then
49842: LD_VAR 0 3
49846: PUSH
49847: LD_EXP 106
49851: PUSH
49852: LD_VAR 0 2
49856: ARRAY
49857: IN
49858: NOT
49859: IFFALSE 49905
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49861: LD_ADDR_EXP 106
49865: PUSH
49866: LD_EXP 106
49870: PPUSH
49871: LD_VAR 0 2
49875: PUSH
49876: LD_EXP 106
49880: PUSH
49881: LD_VAR 0 2
49885: ARRAY
49886: PUSH
49887: LD_INT 1
49889: PLUS
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PPUSH
49895: LD_VAR 0 3
49899: PPUSH
49900: CALL 75355 0 3
49904: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49905: LD_VAR 0 3
49909: PPUSH
49910: CALL_OW 110
49914: PUSH
49915: LD_INT 102
49917: NONEQUAL
49918: IFFALSE 49932
// SetTag ( j , 102 ) ;
49920: LD_VAR 0 3
49924: PPUSH
49925: LD_INT 102
49927: PPUSH
49928: CALL_OW 109
// Wait ( 3 ) ;
49932: LD_INT 3
49934: PPUSH
49935: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49939: LD_EXP 105
49943: PUSH
49944: LD_VAR 0 2
49948: ARRAY
49949: PUSH
49950: LD_INT 1
49952: ARRAY
49953: IFFALSE 49985
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49955: LD_VAR 0 3
49959: PPUSH
49960: LD_EXP 105
49964: PUSH
49965: LD_VAR 0 2
49969: ARRAY
49970: PUSH
49971: LD_INT 1
49973: ARRAY
49974: PUSH
49975: LD_INT 1
49977: ARRAY
49978: PPUSH
49979: CALL_OW 128
49983: GO 50041
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49985: LD_VAR 0 3
49989: PPUSH
49990: CALL_OW 314
49994: NOT
49995: PUSH
49996: LD_EXP 105
50000: PUSH
50001: LD_VAR 0 2
50005: ARRAY
50006: PUSH
50007: LD_INT 2
50009: ARRAY
50010: AND
50011: IFFALSE 50041
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
50013: LD_VAR 0 3
50017: PPUSH
50018: LD_EXP 105
50022: PUSH
50023: LD_VAR 0 2
50027: ARRAY
50028: PUSH
50029: LD_INT 2
50031: ARRAY
50032: PUSH
50033: LD_INT 1
50035: ARRAY
50036: PPUSH
50037: CALL_OW 128
// end ;
50041: GO 49819
50043: POP
50044: POP
// end ;
50045: GO 49662
50047: POP
50048: POP
// end ;
50049: LD_VAR 0 1
50053: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50054: LD_INT 0
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
// if not mc_bases then
50062: LD_EXP 102
50066: NOT
50067: IFFALSE 50071
// exit ;
50069: GO 51234
// for i = 1 to mc_bases do
50071: LD_ADDR_VAR 0 2
50075: PUSH
50076: DOUBLE
50077: LD_INT 1
50079: DEC
50080: ST_TO_ADDR
50081: LD_EXP 102
50085: PUSH
50086: FOR_TO
50087: IFFALSE 51232
// begin if mc_scan [ i ] then
50089: LD_EXP 125
50093: PUSH
50094: LD_VAR 0 2
50098: ARRAY
50099: IFFALSE 50103
// continue ;
50101: GO 50086
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50103: LD_EXP 107
50107: PUSH
50108: LD_VAR 0 2
50112: ARRAY
50113: NOT
50114: PUSH
50115: LD_EXP 109
50119: PUSH
50120: LD_VAR 0 2
50124: ARRAY
50125: NOT
50126: AND
50127: PUSH
50128: LD_EXP 108
50132: PUSH
50133: LD_VAR 0 2
50137: ARRAY
50138: AND
50139: IFFALSE 50177
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50141: LD_ADDR_EXP 108
50145: PUSH
50146: LD_EXP 108
50150: PPUSH
50151: LD_VAR 0 2
50155: PPUSH
50156: EMPTY
50157: PPUSH
50158: CALL_OW 1
50162: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50163: LD_VAR 0 2
50167: PPUSH
50168: LD_INT 103
50170: PPUSH
50171: CALL 43770 0 2
// continue ;
50175: GO 50086
// end ; if mc_construct_list [ i ] then
50177: LD_EXP 109
50181: PUSH
50182: LD_VAR 0 2
50186: ARRAY
50187: IFFALSE 50407
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50189: LD_ADDR_VAR 0 5
50193: PUSH
50194: LD_EXP 102
50198: PUSH
50199: LD_VAR 0 2
50203: ARRAY
50204: PPUSH
50205: LD_INT 25
50207: PUSH
50208: LD_INT 2
50210: PUSH
50211: EMPTY
50212: LIST
50213: LIST
50214: PPUSH
50215: CALL_OW 72
50219: PUSH
50220: LD_EXP 104
50224: PUSH
50225: LD_VAR 0 2
50229: ARRAY
50230: DIFF
50231: ST_TO_ADDR
// if not tmp then
50232: LD_VAR 0 5
50236: NOT
50237: IFFALSE 50241
// continue ;
50239: GO 50086
// for j in tmp do
50241: LD_ADDR_VAR 0 3
50245: PUSH
50246: LD_VAR 0 5
50250: PUSH
50251: FOR_IN
50252: IFFALSE 50403
// begin if not mc_builders [ i ] then
50254: LD_EXP 108
50258: PUSH
50259: LD_VAR 0 2
50263: ARRAY
50264: NOT
50265: IFFALSE 50323
// begin SetTag ( j , 103 ) ;
50267: LD_VAR 0 3
50271: PPUSH
50272: LD_INT 103
50274: PPUSH
50275: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50279: LD_ADDR_EXP 108
50283: PUSH
50284: LD_EXP 108
50288: PPUSH
50289: LD_VAR 0 2
50293: PUSH
50294: LD_EXP 108
50298: PUSH
50299: LD_VAR 0 2
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: PLUS
50308: PUSH
50309: EMPTY
50310: LIST
50311: LIST
50312: PPUSH
50313: LD_VAR 0 3
50317: PPUSH
50318: CALL 75355 0 3
50322: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50323: LD_VAR 0 3
50327: PPUSH
50328: CALL_OW 310
50332: IFFALSE 50343
// ComExitBuilding ( j ) ;
50334: LD_VAR 0 3
50338: PPUSH
50339: CALL_OW 122
// wait ( 3 ) ;
50343: LD_INT 3
50345: PPUSH
50346: CALL_OW 67
// if not mc_construct_list [ i ] then
50350: LD_EXP 109
50354: PUSH
50355: LD_VAR 0 2
50359: ARRAY
50360: NOT
50361: IFFALSE 50365
// break ;
50363: GO 50403
// if not HasTask ( j ) then
50365: LD_VAR 0 3
50369: PPUSH
50370: CALL_OW 314
50374: NOT
50375: IFFALSE 50401
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50377: LD_VAR 0 3
50381: PPUSH
50382: LD_EXP 109
50386: PUSH
50387: LD_VAR 0 2
50391: ARRAY
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PPUSH
50397: CALL 78593 0 2
// end ;
50401: GO 50251
50403: POP
50404: POP
// end else
50405: GO 51230
// if mc_build_list [ i ] then
50407: LD_EXP 107
50411: PUSH
50412: LD_VAR 0 2
50416: ARRAY
50417: IFFALSE 51230
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50419: LD_EXP 107
50423: PUSH
50424: LD_VAR 0 2
50428: ARRAY
50429: PUSH
50430: LD_INT 1
50432: ARRAY
50433: PUSH
50434: LD_INT 1
50436: ARRAY
50437: PPUSH
50438: CALL 78417 0 1
50442: PUSH
50443: LD_EXP 102
50447: PUSH
50448: LD_VAR 0 2
50452: ARRAY
50453: PPUSH
50454: LD_INT 2
50456: PUSH
50457: LD_INT 30
50459: PUSH
50460: LD_INT 2
50462: PUSH
50463: EMPTY
50464: LIST
50465: LIST
50466: PUSH
50467: LD_INT 30
50469: PUSH
50470: LD_INT 3
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: PUSH
50477: EMPTY
50478: LIST
50479: LIST
50480: LIST
50481: PPUSH
50482: CALL_OW 72
50486: NOT
50487: AND
50488: IFFALSE 50593
// begin for j = 1 to mc_build_list [ i ] do
50490: LD_ADDR_VAR 0 3
50494: PUSH
50495: DOUBLE
50496: LD_INT 1
50498: DEC
50499: ST_TO_ADDR
50500: LD_EXP 107
50504: PUSH
50505: LD_VAR 0 2
50509: ARRAY
50510: PUSH
50511: FOR_TO
50512: IFFALSE 50591
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50514: LD_EXP 107
50518: PUSH
50519: LD_VAR 0 2
50523: ARRAY
50524: PUSH
50525: LD_VAR 0 3
50529: ARRAY
50530: PUSH
50531: LD_INT 1
50533: ARRAY
50534: PUSH
50535: LD_INT 2
50537: EQUAL
50538: IFFALSE 50589
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50540: LD_ADDR_EXP 107
50544: PUSH
50545: LD_EXP 107
50549: PPUSH
50550: LD_VAR 0 2
50554: PPUSH
50555: LD_EXP 107
50559: PUSH
50560: LD_VAR 0 2
50564: ARRAY
50565: PPUSH
50566: LD_VAR 0 3
50570: PPUSH
50571: LD_INT 1
50573: PPUSH
50574: LD_INT 0
50576: PPUSH
50577: CALL 74773 0 4
50581: PPUSH
50582: CALL_OW 1
50586: ST_TO_ADDR
// break ;
50587: GO 50591
// end ;
50589: GO 50511
50591: POP
50592: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50593: LD_ADDR_VAR 0 6
50597: PUSH
50598: LD_EXP 102
50602: PUSH
50603: LD_VAR 0 2
50607: ARRAY
50608: PPUSH
50609: LD_INT 2
50611: PUSH
50612: LD_INT 30
50614: PUSH
50615: LD_INT 0
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: LD_INT 30
50624: PUSH
50625: LD_INT 1
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: LIST
50636: PPUSH
50637: CALL_OW 72
50641: ST_TO_ADDR
// for k := 1 to depot do
50642: LD_ADDR_VAR 0 4
50646: PUSH
50647: DOUBLE
50648: LD_INT 1
50650: DEC
50651: ST_TO_ADDR
50652: LD_VAR 0 6
50656: PUSH
50657: FOR_TO
50658: IFFALSE 51228
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50660: LD_EXP 107
50664: PUSH
50665: LD_VAR 0 2
50669: ARRAY
50670: PUSH
50671: LD_INT 1
50673: ARRAY
50674: PUSH
50675: LD_INT 1
50677: ARRAY
50678: PUSH
50679: LD_INT 0
50681: EQUAL
50682: PUSH
50683: LD_VAR 0 6
50687: PUSH
50688: LD_VAR 0 4
50692: ARRAY
50693: PPUSH
50694: LD_EXP 107
50698: PUSH
50699: LD_VAR 0 2
50703: ARRAY
50704: PUSH
50705: LD_INT 1
50707: ARRAY
50708: PUSH
50709: LD_INT 1
50711: ARRAY
50712: PPUSH
50713: LD_EXP 107
50717: PUSH
50718: LD_VAR 0 2
50722: ARRAY
50723: PUSH
50724: LD_INT 1
50726: ARRAY
50727: PUSH
50728: LD_INT 2
50730: ARRAY
50731: PPUSH
50732: LD_EXP 107
50736: PUSH
50737: LD_VAR 0 2
50741: ARRAY
50742: PUSH
50743: LD_INT 1
50745: ARRAY
50746: PUSH
50747: LD_INT 3
50749: ARRAY
50750: PPUSH
50751: LD_EXP 107
50755: PUSH
50756: LD_VAR 0 2
50760: ARRAY
50761: PUSH
50762: LD_INT 1
50764: ARRAY
50765: PUSH
50766: LD_INT 4
50768: ARRAY
50769: PPUSH
50770: CALL 83829 0 5
50774: OR
50775: IFFALSE 51056
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50777: LD_ADDR_VAR 0 5
50781: PUSH
50782: LD_EXP 102
50786: PUSH
50787: LD_VAR 0 2
50791: ARRAY
50792: PPUSH
50793: LD_INT 25
50795: PUSH
50796: LD_INT 2
50798: PUSH
50799: EMPTY
50800: LIST
50801: LIST
50802: PPUSH
50803: CALL_OW 72
50807: PUSH
50808: LD_EXP 104
50812: PUSH
50813: LD_VAR 0 2
50817: ARRAY
50818: DIFF
50819: ST_TO_ADDR
// if not tmp then
50820: LD_VAR 0 5
50824: NOT
50825: IFFALSE 50829
// continue ;
50827: GO 50657
// for j in tmp do
50829: LD_ADDR_VAR 0 3
50833: PUSH
50834: LD_VAR 0 5
50838: PUSH
50839: FOR_IN
50840: IFFALSE 51052
// begin if not mc_builders [ i ] then
50842: LD_EXP 108
50846: PUSH
50847: LD_VAR 0 2
50851: ARRAY
50852: NOT
50853: IFFALSE 50911
// begin SetTag ( j , 103 ) ;
50855: LD_VAR 0 3
50859: PPUSH
50860: LD_INT 103
50862: PPUSH
50863: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50867: LD_ADDR_EXP 108
50871: PUSH
50872: LD_EXP 108
50876: PPUSH
50877: LD_VAR 0 2
50881: PUSH
50882: LD_EXP 108
50886: PUSH
50887: LD_VAR 0 2
50891: ARRAY
50892: PUSH
50893: LD_INT 1
50895: PLUS
50896: PUSH
50897: EMPTY
50898: LIST
50899: LIST
50900: PPUSH
50901: LD_VAR 0 3
50905: PPUSH
50906: CALL 75355 0 3
50910: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50911: LD_VAR 0 3
50915: PPUSH
50916: CALL_OW 310
50920: IFFALSE 50931
// ComExitBuilding ( j ) ;
50922: LD_VAR 0 3
50926: PPUSH
50927: CALL_OW 122
// wait ( 3 ) ;
50931: LD_INT 3
50933: PPUSH
50934: CALL_OW 67
// if not mc_build_list [ i ] then
50938: LD_EXP 107
50942: PUSH
50943: LD_VAR 0 2
50947: ARRAY
50948: NOT
50949: IFFALSE 50953
// break ;
50951: GO 51052
// if not HasTask ( j ) then
50953: LD_VAR 0 3
50957: PPUSH
50958: CALL_OW 314
50962: NOT
50963: IFFALSE 51050
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50965: LD_VAR 0 3
50969: PPUSH
50970: LD_EXP 107
50974: PUSH
50975: LD_VAR 0 2
50979: ARRAY
50980: PUSH
50981: LD_INT 1
50983: ARRAY
50984: PUSH
50985: LD_INT 1
50987: ARRAY
50988: PPUSH
50989: LD_EXP 107
50993: PUSH
50994: LD_VAR 0 2
50998: ARRAY
50999: PUSH
51000: LD_INT 1
51002: ARRAY
51003: PUSH
51004: LD_INT 2
51006: ARRAY
51007: PPUSH
51008: LD_EXP 107
51012: PUSH
51013: LD_VAR 0 2
51017: ARRAY
51018: PUSH
51019: LD_INT 1
51021: ARRAY
51022: PUSH
51023: LD_INT 3
51025: ARRAY
51026: PPUSH
51027: LD_EXP 107
51031: PUSH
51032: LD_VAR 0 2
51036: ARRAY
51037: PUSH
51038: LD_INT 1
51040: ARRAY
51041: PUSH
51042: LD_INT 4
51044: ARRAY
51045: PPUSH
51046: CALL_OW 145
// end ;
51050: GO 50839
51052: POP
51053: POP
// end else
51054: GO 51226
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51056: LD_EXP 102
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PPUSH
51067: LD_EXP 107
51071: PUSH
51072: LD_VAR 0 2
51076: ARRAY
51077: PUSH
51078: LD_INT 1
51080: ARRAY
51081: PUSH
51082: LD_INT 1
51084: ARRAY
51085: PPUSH
51086: LD_EXP 107
51090: PUSH
51091: LD_VAR 0 2
51095: ARRAY
51096: PUSH
51097: LD_INT 1
51099: ARRAY
51100: PUSH
51101: LD_INT 2
51103: ARRAY
51104: PPUSH
51105: LD_EXP 107
51109: PUSH
51110: LD_VAR 0 2
51114: ARRAY
51115: PUSH
51116: LD_INT 1
51118: ARRAY
51119: PUSH
51120: LD_INT 3
51122: ARRAY
51123: PPUSH
51124: LD_EXP 107
51128: PUSH
51129: LD_VAR 0 2
51133: ARRAY
51134: PUSH
51135: LD_INT 1
51137: ARRAY
51138: PUSH
51139: LD_INT 4
51141: ARRAY
51142: PPUSH
51143: LD_EXP 102
51147: PUSH
51148: LD_VAR 0 2
51152: ARRAY
51153: PPUSH
51154: LD_INT 21
51156: PUSH
51157: LD_INT 3
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PPUSH
51164: CALL_OW 72
51168: PPUSH
51169: EMPTY
51170: PPUSH
51171: CALL 82583 0 7
51175: NOT
51176: IFFALSE 51226
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51178: LD_ADDR_EXP 107
51182: PUSH
51183: LD_EXP 107
51187: PPUSH
51188: LD_VAR 0 2
51192: PPUSH
51193: LD_EXP 107
51197: PUSH
51198: LD_VAR 0 2
51202: ARRAY
51203: PPUSH
51204: LD_INT 1
51206: PPUSH
51207: LD_INT 1
51209: NEG
51210: PPUSH
51211: LD_INT 0
51213: PPUSH
51214: CALL 74773 0 4
51218: PPUSH
51219: CALL_OW 1
51223: ST_TO_ADDR
// continue ;
51224: GO 50657
// end ; end ;
51226: GO 50657
51228: POP
51229: POP
// end ; end ;
51230: GO 50086
51232: POP
51233: POP
// end ;
51234: LD_VAR 0 1
51238: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51239: LD_INT 0
51241: PPUSH
51242: PPUSH
51243: PPUSH
51244: PPUSH
51245: PPUSH
51246: PPUSH
// if not mc_bases then
51247: LD_EXP 102
51251: NOT
51252: IFFALSE 51256
// exit ;
51254: GO 51683
// for i = 1 to mc_bases do
51256: LD_ADDR_VAR 0 2
51260: PUSH
51261: DOUBLE
51262: LD_INT 1
51264: DEC
51265: ST_TO_ADDR
51266: LD_EXP 102
51270: PUSH
51271: FOR_TO
51272: IFFALSE 51681
// begin tmp := mc_build_upgrade [ i ] ;
51274: LD_ADDR_VAR 0 4
51278: PUSH
51279: LD_EXP 134
51283: PUSH
51284: LD_VAR 0 2
51288: ARRAY
51289: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51290: LD_ADDR_VAR 0 6
51294: PUSH
51295: LD_EXP 135
51299: PUSH
51300: LD_VAR 0 2
51304: ARRAY
51305: PPUSH
51306: LD_INT 2
51308: PUSH
51309: LD_INT 30
51311: PUSH
51312: LD_INT 6
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: PUSH
51319: LD_INT 30
51321: PUSH
51322: LD_INT 7
51324: PUSH
51325: EMPTY
51326: LIST
51327: LIST
51328: PUSH
51329: EMPTY
51330: LIST
51331: LIST
51332: LIST
51333: PPUSH
51334: CALL_OW 72
51338: ST_TO_ADDR
// if not tmp and not lab then
51339: LD_VAR 0 4
51343: NOT
51344: PUSH
51345: LD_VAR 0 6
51349: NOT
51350: AND
51351: IFFALSE 51355
// continue ;
51353: GO 51271
// if tmp then
51355: LD_VAR 0 4
51359: IFFALSE 51479
// for j in tmp do
51361: LD_ADDR_VAR 0 3
51365: PUSH
51366: LD_VAR 0 4
51370: PUSH
51371: FOR_IN
51372: IFFALSE 51477
// begin if UpgradeCost ( j ) then
51374: LD_VAR 0 3
51378: PPUSH
51379: CALL 82243 0 1
51383: IFFALSE 51475
// begin ComUpgrade ( j ) ;
51385: LD_VAR 0 3
51389: PPUSH
51390: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51394: LD_ADDR_EXP 134
51398: PUSH
51399: LD_EXP 134
51403: PPUSH
51404: LD_VAR 0 2
51408: PPUSH
51409: LD_EXP 134
51413: PUSH
51414: LD_VAR 0 2
51418: ARRAY
51419: PUSH
51420: LD_VAR 0 3
51424: DIFF
51425: PPUSH
51426: CALL_OW 1
51430: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51431: LD_ADDR_EXP 109
51435: PUSH
51436: LD_EXP 109
51440: PPUSH
51441: LD_VAR 0 2
51445: PUSH
51446: LD_EXP 109
51450: PUSH
51451: LD_VAR 0 2
51455: ARRAY
51456: PUSH
51457: LD_INT 1
51459: PLUS
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PPUSH
51465: LD_VAR 0 3
51469: PPUSH
51470: CALL 75355 0 3
51474: ST_TO_ADDR
// end ; end ;
51475: GO 51371
51477: POP
51478: POP
// if not lab or not mc_lab_upgrade [ i ] then
51479: LD_VAR 0 6
51483: NOT
51484: PUSH
51485: LD_EXP 136
51489: PUSH
51490: LD_VAR 0 2
51494: ARRAY
51495: NOT
51496: OR
51497: IFFALSE 51501
// continue ;
51499: GO 51271
// for j in lab do
51501: LD_ADDR_VAR 0 3
51505: PUSH
51506: LD_VAR 0 6
51510: PUSH
51511: FOR_IN
51512: IFFALSE 51677
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51514: LD_VAR 0 3
51518: PPUSH
51519: CALL_OW 266
51523: PUSH
51524: LD_INT 6
51526: PUSH
51527: LD_INT 7
51529: PUSH
51530: EMPTY
51531: LIST
51532: LIST
51533: IN
51534: PUSH
51535: LD_VAR 0 3
51539: PPUSH
51540: CALL_OW 461
51544: PUSH
51545: LD_INT 1
51547: NONEQUAL
51548: AND
51549: IFFALSE 51675
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51551: LD_VAR 0 3
51555: PPUSH
51556: LD_EXP 136
51560: PUSH
51561: LD_VAR 0 2
51565: ARRAY
51566: PUSH
51567: LD_INT 1
51569: ARRAY
51570: PPUSH
51571: CALL 82448 0 2
51575: IFFALSE 51675
// begin ComCancel ( j ) ;
51577: LD_VAR 0 3
51581: PPUSH
51582: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51586: LD_VAR 0 3
51590: PPUSH
51591: LD_EXP 136
51595: PUSH
51596: LD_VAR 0 2
51600: ARRAY
51601: PUSH
51602: LD_INT 1
51604: ARRAY
51605: PPUSH
51606: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51610: LD_VAR 0 3
51614: PUSH
51615: LD_EXP 109
51619: PUSH
51620: LD_VAR 0 2
51624: ARRAY
51625: IN
51626: NOT
51627: IFFALSE 51673
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51629: LD_ADDR_EXP 109
51633: PUSH
51634: LD_EXP 109
51638: PPUSH
51639: LD_VAR 0 2
51643: PUSH
51644: LD_EXP 109
51648: PUSH
51649: LD_VAR 0 2
51653: ARRAY
51654: PUSH
51655: LD_INT 1
51657: PLUS
51658: PUSH
51659: EMPTY
51660: LIST
51661: LIST
51662: PPUSH
51663: LD_VAR 0 3
51667: PPUSH
51668: CALL 75355 0 3
51672: ST_TO_ADDR
// break ;
51673: GO 51677
// end ; end ; end ;
51675: GO 51511
51677: POP
51678: POP
// end ;
51679: GO 51271
51681: POP
51682: POP
// end ;
51683: LD_VAR 0 1
51687: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
51688: LD_INT 0
51690: PPUSH
51691: PPUSH
51692: PPUSH
51693: PPUSH
51694: PPUSH
51695: PPUSH
51696: PPUSH
51697: PPUSH
51698: PPUSH
// if not mc_bases then
51699: LD_EXP 102
51703: NOT
51704: IFFALSE 51708
// exit ;
51706: GO 52113
// for i = 1 to mc_bases do
51708: LD_ADDR_VAR 0 2
51712: PUSH
51713: DOUBLE
51714: LD_INT 1
51716: DEC
51717: ST_TO_ADDR
51718: LD_EXP 102
51722: PUSH
51723: FOR_TO
51724: IFFALSE 52111
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
51726: LD_EXP 110
51730: PUSH
51731: LD_VAR 0 2
51735: ARRAY
51736: NOT
51737: PUSH
51738: LD_EXP 102
51742: PUSH
51743: LD_VAR 0 2
51747: ARRAY
51748: PPUSH
51749: LD_INT 30
51751: PUSH
51752: LD_INT 3
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: PPUSH
51759: CALL_OW 72
51763: NOT
51764: OR
51765: IFFALSE 51769
// continue ;
51767: GO 51723
// busy := false ;
51769: LD_ADDR_VAR 0 8
51773: PUSH
51774: LD_INT 0
51776: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51777: LD_ADDR_VAR 0 4
51781: PUSH
51782: LD_EXP 102
51786: PUSH
51787: LD_VAR 0 2
51791: ARRAY
51792: PPUSH
51793: LD_INT 30
51795: PUSH
51796: LD_INT 3
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: PPUSH
51803: CALL_OW 72
51807: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51808: LD_ADDR_VAR 0 6
51812: PUSH
51813: LD_EXP 110
51817: PUSH
51818: LD_VAR 0 2
51822: ARRAY
51823: PPUSH
51824: LD_INT 2
51826: PUSH
51827: LD_INT 30
51829: PUSH
51830: LD_INT 32
51832: PUSH
51833: EMPTY
51834: LIST
51835: LIST
51836: PUSH
51837: LD_INT 30
51839: PUSH
51840: LD_INT 33
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: LIST
51851: PPUSH
51852: CALL_OW 72
51856: ST_TO_ADDR
// if not t then
51857: LD_VAR 0 6
51861: NOT
51862: IFFALSE 51866
// continue ;
51864: GO 51723
// for j in tmp do
51866: LD_ADDR_VAR 0 3
51870: PUSH
51871: LD_VAR 0 4
51875: PUSH
51876: FOR_IN
51877: IFFALSE 51907
// if not BuildingStatus ( j ) = bs_idle then
51879: LD_VAR 0 3
51883: PPUSH
51884: CALL_OW 461
51888: PUSH
51889: LD_INT 2
51891: EQUAL
51892: NOT
51893: IFFALSE 51905
// begin busy := true ;
51895: LD_ADDR_VAR 0 8
51899: PUSH
51900: LD_INT 1
51902: ST_TO_ADDR
// break ;
51903: GO 51907
// end ;
51905: GO 51876
51907: POP
51908: POP
// if busy then
51909: LD_VAR 0 8
51913: IFFALSE 51917
// continue ;
51915: GO 51723
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51917: LD_ADDR_VAR 0 7
51921: PUSH
51922: LD_VAR 0 6
51926: PPUSH
51927: LD_INT 35
51929: PUSH
51930: LD_INT 0
51932: PUSH
51933: EMPTY
51934: LIST
51935: LIST
51936: PPUSH
51937: CALL_OW 72
51941: ST_TO_ADDR
// if tw then
51942: LD_VAR 0 7
51946: IFFALSE 52023
// begin tw := tw [ 1 ] ;
51948: LD_ADDR_VAR 0 7
51952: PUSH
51953: LD_VAR 0 7
51957: PUSH
51958: LD_INT 1
51960: ARRAY
51961: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51962: LD_ADDR_VAR 0 9
51966: PUSH
51967: LD_VAR 0 7
51971: PPUSH
51972: LD_EXP 127
51976: PUSH
51977: LD_VAR 0 2
51981: ARRAY
51982: PPUSH
51983: CALL 80740 0 2
51987: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51988: LD_EXP 141
51992: PUSH
51993: LD_VAR 0 2
51997: ARRAY
51998: IFFALSE 52021
// if not weapon in mc_allowed_tower_weapons [ i ] then
52000: LD_VAR 0 9
52004: PUSH
52005: LD_EXP 141
52009: PUSH
52010: LD_VAR 0 2
52014: ARRAY
52015: IN
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 51723
// end else
52021: GO 52086
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
52023: LD_ADDR_VAR 0 5
52027: PUSH
52028: LD_EXP 110
52032: PUSH
52033: LD_VAR 0 2
52037: ARRAY
52038: PPUSH
52039: LD_VAR 0 4
52043: PPUSH
52044: CALL 107652 0 2
52048: ST_TO_ADDR
// if not tmp2 then
52049: LD_VAR 0 5
52053: NOT
52054: IFFALSE 52058
// continue ;
52056: GO 51723
// tw := tmp2 [ 1 ] ;
52058: LD_ADDR_VAR 0 7
52062: PUSH
52063: LD_VAR 0 5
52067: PUSH
52068: LD_INT 1
52070: ARRAY
52071: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52072: LD_ADDR_VAR 0 9
52076: PUSH
52077: LD_VAR 0 5
52081: PUSH
52082: LD_INT 2
52084: ARRAY
52085: ST_TO_ADDR
// end ; if not weapon then
52086: LD_VAR 0 9
52090: NOT
52091: IFFALSE 52095
// continue ;
52093: GO 51723
// ComPlaceWeapon ( tw , weapon ) ;
52095: LD_VAR 0 7
52099: PPUSH
52100: LD_VAR 0 9
52104: PPUSH
52105: CALL_OW 148
// end ;
52109: GO 51723
52111: POP
52112: POP
// end ;
52113: LD_VAR 0 1
52117: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52118: LD_INT 0
52120: PPUSH
52121: PPUSH
52122: PPUSH
52123: PPUSH
52124: PPUSH
52125: PPUSH
52126: PPUSH
// if not mc_bases then
52127: LD_EXP 102
52131: NOT
52132: IFFALSE 52136
// exit ;
52134: GO 52911
// for i = 1 to mc_bases do
52136: LD_ADDR_VAR 0 2
52140: PUSH
52141: DOUBLE
52142: LD_INT 1
52144: DEC
52145: ST_TO_ADDR
52146: LD_EXP 102
52150: PUSH
52151: FOR_TO
52152: IFFALSE 52909
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52154: LD_EXP 115
52158: PUSH
52159: LD_VAR 0 2
52163: ARRAY
52164: NOT
52165: PUSH
52166: LD_EXP 115
52170: PUSH
52171: LD_VAR 0 2
52175: ARRAY
52176: PUSH
52177: LD_EXP 116
52181: PUSH
52182: LD_VAR 0 2
52186: ARRAY
52187: EQUAL
52188: OR
52189: PUSH
52190: LD_EXP 125
52194: PUSH
52195: LD_VAR 0 2
52199: ARRAY
52200: OR
52201: IFFALSE 52205
// continue ;
52203: GO 52151
// if mc_miners [ i ] then
52205: LD_EXP 116
52209: PUSH
52210: LD_VAR 0 2
52214: ARRAY
52215: IFFALSE 52596
// begin for j = mc_miners [ i ] downto 1 do
52217: LD_ADDR_VAR 0 3
52221: PUSH
52222: DOUBLE
52223: LD_EXP 116
52227: PUSH
52228: LD_VAR 0 2
52232: ARRAY
52233: INC
52234: ST_TO_ADDR
52235: LD_INT 1
52237: PUSH
52238: FOR_DOWNTO
52239: IFFALSE 52594
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52241: LD_EXP 116
52245: PUSH
52246: LD_VAR 0 2
52250: ARRAY
52251: PUSH
52252: LD_VAR 0 3
52256: ARRAY
52257: PPUSH
52258: CALL_OW 301
52262: PUSH
52263: LD_EXP 116
52267: PUSH
52268: LD_VAR 0 2
52272: ARRAY
52273: PUSH
52274: LD_VAR 0 3
52278: ARRAY
52279: PPUSH
52280: CALL_OW 257
52284: PUSH
52285: LD_INT 1
52287: NONEQUAL
52288: OR
52289: IFFALSE 52352
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52291: LD_ADDR_VAR 0 5
52295: PUSH
52296: LD_EXP 116
52300: PUSH
52301: LD_VAR 0 2
52305: ARRAY
52306: PUSH
52307: LD_EXP 116
52311: PUSH
52312: LD_VAR 0 2
52316: ARRAY
52317: PUSH
52318: LD_VAR 0 3
52322: ARRAY
52323: DIFF
52324: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52325: LD_ADDR_EXP 116
52329: PUSH
52330: LD_EXP 116
52334: PPUSH
52335: LD_VAR 0 2
52339: PPUSH
52340: LD_VAR 0 5
52344: PPUSH
52345: CALL_OW 1
52349: ST_TO_ADDR
// continue ;
52350: GO 52238
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52352: LD_EXP 116
52356: PUSH
52357: LD_VAR 0 2
52361: ARRAY
52362: PUSH
52363: LD_VAR 0 3
52367: ARRAY
52368: PPUSH
52369: CALL_OW 257
52373: PUSH
52374: LD_INT 1
52376: EQUAL
52377: PUSH
52378: LD_EXP 116
52382: PUSH
52383: LD_VAR 0 2
52387: ARRAY
52388: PUSH
52389: LD_VAR 0 3
52393: ARRAY
52394: PPUSH
52395: CALL_OW 459
52399: NOT
52400: AND
52401: PUSH
52402: LD_EXP 116
52406: PUSH
52407: LD_VAR 0 2
52411: ARRAY
52412: PUSH
52413: LD_VAR 0 3
52417: ARRAY
52418: PPUSH
52419: CALL_OW 314
52423: NOT
52424: AND
52425: IFFALSE 52592
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52427: LD_EXP 116
52431: PUSH
52432: LD_VAR 0 2
52436: ARRAY
52437: PUSH
52438: LD_VAR 0 3
52442: ARRAY
52443: PPUSH
52444: CALL_OW 310
52448: IFFALSE 52471
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52450: LD_EXP 116
52454: PUSH
52455: LD_VAR 0 2
52459: ARRAY
52460: PUSH
52461: LD_VAR 0 3
52465: ARRAY
52466: PPUSH
52467: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52471: LD_EXP 116
52475: PUSH
52476: LD_VAR 0 2
52480: ARRAY
52481: PUSH
52482: LD_VAR 0 3
52486: ARRAY
52487: PPUSH
52488: CALL_OW 314
52492: NOT
52493: IFFALSE 52592
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52495: LD_ADDR_VAR 0 7
52499: PUSH
52500: LD_VAR 0 3
52504: PUSH
52505: LD_EXP 115
52509: PUSH
52510: LD_VAR 0 2
52514: ARRAY
52515: PPUSH
52516: CALL 72495 0 1
52520: MOD
52521: PUSH
52522: LD_INT 1
52524: PLUS
52525: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52526: LD_EXP 116
52530: PUSH
52531: LD_VAR 0 2
52535: ARRAY
52536: PUSH
52537: LD_VAR 0 3
52541: ARRAY
52542: PPUSH
52543: LD_EXP 115
52547: PUSH
52548: LD_VAR 0 2
52552: ARRAY
52553: PUSH
52554: LD_VAR 0 7
52558: ARRAY
52559: PUSH
52560: LD_INT 1
52562: ARRAY
52563: PPUSH
52564: LD_EXP 115
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PUSH
52575: LD_VAR 0 7
52579: ARRAY
52580: PUSH
52581: LD_INT 2
52583: ARRAY
52584: PPUSH
52585: LD_INT 0
52587: PPUSH
52588: CALL_OW 193
// end ; end ; end ;
52592: GO 52238
52594: POP
52595: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52596: LD_ADDR_VAR 0 5
52600: PUSH
52601: LD_EXP 102
52605: PUSH
52606: LD_VAR 0 2
52610: ARRAY
52611: PPUSH
52612: LD_INT 2
52614: PUSH
52615: LD_INT 30
52617: PUSH
52618: LD_INT 4
52620: PUSH
52621: EMPTY
52622: LIST
52623: LIST
52624: PUSH
52625: LD_INT 30
52627: PUSH
52628: LD_INT 5
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PUSH
52635: LD_INT 30
52637: PUSH
52638: LD_INT 32
52640: PUSH
52641: EMPTY
52642: LIST
52643: LIST
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: LIST
52649: LIST
52650: PPUSH
52651: CALL_OW 72
52655: ST_TO_ADDR
// if not tmp then
52656: LD_VAR 0 5
52660: NOT
52661: IFFALSE 52665
// continue ;
52663: GO 52151
// list := [ ] ;
52665: LD_ADDR_VAR 0 6
52669: PUSH
52670: EMPTY
52671: ST_TO_ADDR
// for j in tmp do
52672: LD_ADDR_VAR 0 3
52676: PUSH
52677: LD_VAR 0 5
52681: PUSH
52682: FOR_IN
52683: IFFALSE 52752
// begin for k in UnitsInside ( j ) do
52685: LD_ADDR_VAR 0 4
52689: PUSH
52690: LD_VAR 0 3
52694: PPUSH
52695: CALL_OW 313
52699: PUSH
52700: FOR_IN
52701: IFFALSE 52748
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
52703: LD_VAR 0 4
52707: PPUSH
52708: CALL_OW 257
52712: PUSH
52713: LD_INT 1
52715: EQUAL
52716: PUSH
52717: LD_VAR 0 4
52721: PPUSH
52722: CALL_OW 459
52726: NOT
52727: AND
52728: IFFALSE 52746
// list := list ^ k ;
52730: LD_ADDR_VAR 0 6
52734: PUSH
52735: LD_VAR 0 6
52739: PUSH
52740: LD_VAR 0 4
52744: ADD
52745: ST_TO_ADDR
52746: GO 52700
52748: POP
52749: POP
// end ;
52750: GO 52682
52752: POP
52753: POP
// list := list diff mc_miners [ i ] ;
52754: LD_ADDR_VAR 0 6
52758: PUSH
52759: LD_VAR 0 6
52763: PUSH
52764: LD_EXP 116
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: DIFF
52775: ST_TO_ADDR
// if not list then
52776: LD_VAR 0 6
52780: NOT
52781: IFFALSE 52785
// continue ;
52783: GO 52151
// k := mc_mines [ i ] - mc_miners [ i ] ;
52785: LD_ADDR_VAR 0 4
52789: PUSH
52790: LD_EXP 115
52794: PUSH
52795: LD_VAR 0 2
52799: ARRAY
52800: PUSH
52801: LD_EXP 116
52805: PUSH
52806: LD_VAR 0 2
52810: ARRAY
52811: MINUS
52812: ST_TO_ADDR
// if k > list then
52813: LD_VAR 0 4
52817: PUSH
52818: LD_VAR 0 6
52822: GREATER
52823: IFFALSE 52835
// k := list ;
52825: LD_ADDR_VAR 0 4
52829: PUSH
52830: LD_VAR 0 6
52834: ST_TO_ADDR
// for j = 1 to k do
52835: LD_ADDR_VAR 0 3
52839: PUSH
52840: DOUBLE
52841: LD_INT 1
52843: DEC
52844: ST_TO_ADDR
52845: LD_VAR 0 4
52849: PUSH
52850: FOR_TO
52851: IFFALSE 52905
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52853: LD_ADDR_EXP 116
52857: PUSH
52858: LD_EXP 116
52862: PPUSH
52863: LD_VAR 0 2
52867: PUSH
52868: LD_EXP 116
52872: PUSH
52873: LD_VAR 0 2
52877: ARRAY
52878: PUSH
52879: LD_INT 1
52881: PLUS
52882: PUSH
52883: EMPTY
52884: LIST
52885: LIST
52886: PPUSH
52887: LD_VAR 0 6
52891: PUSH
52892: LD_VAR 0 3
52896: ARRAY
52897: PPUSH
52898: CALL 75355 0 3
52902: ST_TO_ADDR
52903: GO 52850
52905: POP
52906: POP
// end ;
52907: GO 52151
52909: POP
52910: POP
// end ;
52911: LD_VAR 0 1
52915: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52916: LD_INT 0
52918: PPUSH
52919: PPUSH
52920: PPUSH
52921: PPUSH
52922: PPUSH
52923: PPUSH
52924: PPUSH
52925: PPUSH
52926: PPUSH
52927: PPUSH
52928: PPUSH
// if not mc_bases then
52929: LD_EXP 102
52933: NOT
52934: IFFALSE 52938
// exit ;
52936: GO 54761
// for i = 1 to mc_bases do
52938: LD_ADDR_VAR 0 2
52942: PUSH
52943: DOUBLE
52944: LD_INT 1
52946: DEC
52947: ST_TO_ADDR
52948: LD_EXP 102
52952: PUSH
52953: FOR_TO
52954: IFFALSE 54759
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52956: LD_EXP 102
52960: PUSH
52961: LD_VAR 0 2
52965: ARRAY
52966: NOT
52967: PUSH
52968: LD_EXP 109
52972: PUSH
52973: LD_VAR 0 2
52977: ARRAY
52978: OR
52979: IFFALSE 52983
// continue ;
52981: GO 52953
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52983: LD_EXP 118
52987: PUSH
52988: LD_VAR 0 2
52992: ARRAY
52993: NOT
52994: PUSH
52995: LD_EXP 119
52999: PUSH
53000: LD_VAR 0 2
53004: ARRAY
53005: AND
53006: IFFALSE 53044
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53008: LD_ADDR_EXP 119
53012: PUSH
53013: LD_EXP 119
53017: PPUSH
53018: LD_VAR 0 2
53022: PPUSH
53023: EMPTY
53024: PPUSH
53025: CALL_OW 1
53029: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53030: LD_VAR 0 2
53034: PPUSH
53035: LD_INT 107
53037: PPUSH
53038: CALL 43770 0 2
// continue ;
53042: GO 52953
// end ; target := [ ] ;
53044: LD_ADDR_VAR 0 7
53048: PUSH
53049: EMPTY
53050: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53051: LD_ADDR_VAR 0 6
53055: PUSH
53056: LD_EXP 102
53060: PUSH
53061: LD_VAR 0 2
53065: ARRAY
53066: PUSH
53067: LD_INT 1
53069: ARRAY
53070: PPUSH
53071: CALL_OW 255
53075: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53076: LD_ADDR_VAR 0 9
53080: PUSH
53081: LD_EXP 102
53085: PUSH
53086: LD_VAR 0 2
53090: ARRAY
53091: PPUSH
53092: LD_INT 2
53094: PUSH
53095: LD_INT 30
53097: PUSH
53098: LD_INT 0
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: LD_INT 30
53107: PUSH
53108: LD_INT 1
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: LIST
53119: PPUSH
53120: CALL_OW 72
53124: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53125: LD_ADDR_VAR 0 3
53129: PUSH
53130: DOUBLE
53131: LD_EXP 118
53135: PUSH
53136: LD_VAR 0 2
53140: ARRAY
53141: INC
53142: ST_TO_ADDR
53143: LD_INT 1
53145: PUSH
53146: FOR_DOWNTO
53147: IFFALSE 53392
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53149: LD_EXP 118
53153: PUSH
53154: LD_VAR 0 2
53158: ARRAY
53159: PUSH
53160: LD_VAR 0 3
53164: ARRAY
53165: PUSH
53166: LD_INT 2
53168: ARRAY
53169: PPUSH
53170: LD_EXP 118
53174: PUSH
53175: LD_VAR 0 2
53179: ARRAY
53180: PUSH
53181: LD_VAR 0 3
53185: ARRAY
53186: PUSH
53187: LD_INT 3
53189: ARRAY
53190: PPUSH
53191: CALL_OW 488
53195: PUSH
53196: LD_EXP 118
53200: PUSH
53201: LD_VAR 0 2
53205: ARRAY
53206: PUSH
53207: LD_VAR 0 3
53211: ARRAY
53212: PUSH
53213: LD_INT 2
53215: ARRAY
53216: PPUSH
53217: LD_EXP 118
53221: PUSH
53222: LD_VAR 0 2
53226: ARRAY
53227: PUSH
53228: LD_VAR 0 3
53232: ARRAY
53233: PUSH
53234: LD_INT 3
53236: ARRAY
53237: PPUSH
53238: CALL_OW 284
53242: PUSH
53243: LD_INT 0
53245: EQUAL
53246: AND
53247: IFFALSE 53302
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53249: LD_ADDR_VAR 0 5
53253: PUSH
53254: LD_EXP 118
53258: PUSH
53259: LD_VAR 0 2
53263: ARRAY
53264: PPUSH
53265: LD_VAR 0 3
53269: PPUSH
53270: CALL_OW 3
53274: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53275: LD_ADDR_EXP 118
53279: PUSH
53280: LD_EXP 118
53284: PPUSH
53285: LD_VAR 0 2
53289: PPUSH
53290: LD_VAR 0 5
53294: PPUSH
53295: CALL_OW 1
53299: ST_TO_ADDR
// continue ;
53300: GO 53146
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53302: LD_VAR 0 6
53306: PPUSH
53307: LD_EXP 118
53311: PUSH
53312: LD_VAR 0 2
53316: ARRAY
53317: PUSH
53318: LD_VAR 0 3
53322: ARRAY
53323: PUSH
53324: LD_INT 2
53326: ARRAY
53327: PPUSH
53328: LD_EXP 118
53332: PUSH
53333: LD_VAR 0 2
53337: ARRAY
53338: PUSH
53339: LD_VAR 0 3
53343: ARRAY
53344: PUSH
53345: LD_INT 3
53347: ARRAY
53348: PPUSH
53349: LD_INT 30
53351: PPUSH
53352: CALL 76619 0 4
53356: PUSH
53357: LD_INT 4
53359: ARRAY
53360: PUSH
53361: LD_INT 0
53363: EQUAL
53364: IFFALSE 53390
// begin target := mc_crates [ i ] [ j ] ;
53366: LD_ADDR_VAR 0 7
53370: PUSH
53371: LD_EXP 118
53375: PUSH
53376: LD_VAR 0 2
53380: ARRAY
53381: PUSH
53382: LD_VAR 0 3
53386: ARRAY
53387: ST_TO_ADDR
// break ;
53388: GO 53392
// end ; end ;
53390: GO 53146
53392: POP
53393: POP
// if not target then
53394: LD_VAR 0 7
53398: NOT
53399: IFFALSE 53403
// continue ;
53401: GO 52953
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53403: LD_ADDR_VAR 0 8
53407: PUSH
53408: LD_EXP 121
53412: PUSH
53413: LD_VAR 0 2
53417: ARRAY
53418: PPUSH
53419: LD_INT 2
53421: PUSH
53422: LD_INT 3
53424: PUSH
53425: LD_INT 58
53427: PUSH
53428: EMPTY
53429: LIST
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PUSH
53435: LD_INT 61
53437: PUSH
53438: EMPTY
53439: LIST
53440: PUSH
53441: LD_INT 33
53443: PUSH
53444: LD_INT 5
53446: PUSH
53447: EMPTY
53448: LIST
53449: LIST
53450: PUSH
53451: LD_INT 33
53453: PUSH
53454: LD_INT 3
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: LIST
53465: LIST
53466: LIST
53467: PUSH
53468: LD_INT 2
53470: PUSH
53471: LD_INT 34
53473: PUSH
53474: LD_INT 32
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: PUSH
53481: LD_INT 34
53483: PUSH
53484: LD_INT 51
53486: PUSH
53487: EMPTY
53488: LIST
53489: LIST
53490: PUSH
53491: LD_INT 34
53493: PUSH
53494: LD_INT 12
53496: PUSH
53497: EMPTY
53498: LIST
53499: LIST
53500: PUSH
53501: EMPTY
53502: LIST
53503: LIST
53504: LIST
53505: LIST
53506: PUSH
53507: EMPTY
53508: LIST
53509: LIST
53510: PPUSH
53511: CALL_OW 72
53515: ST_TO_ADDR
// if not cargo then
53516: LD_VAR 0 8
53520: NOT
53521: IFFALSE 54227
// begin if mc_crates_collector [ i ] < 5 then
53523: LD_EXP 119
53527: PUSH
53528: LD_VAR 0 2
53532: ARRAY
53533: PUSH
53534: LD_INT 5
53536: LESS
53537: IFFALSE 53903
// begin if mc_ape [ i ] then
53539: LD_EXP 131
53543: PUSH
53544: LD_VAR 0 2
53548: ARRAY
53549: IFFALSE 53596
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53551: LD_ADDR_VAR 0 5
53555: PUSH
53556: LD_EXP 131
53560: PUSH
53561: LD_VAR 0 2
53565: ARRAY
53566: PPUSH
53567: LD_INT 25
53569: PUSH
53570: LD_INT 16
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: PUSH
53577: LD_INT 24
53579: PUSH
53580: LD_INT 750
53582: PUSH
53583: EMPTY
53584: LIST
53585: LIST
53586: PUSH
53587: EMPTY
53588: LIST
53589: LIST
53590: PPUSH
53591: CALL_OW 72
53595: ST_TO_ADDR
// if not tmp then
53596: LD_VAR 0 5
53600: NOT
53601: IFFALSE 53648
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53603: LD_ADDR_VAR 0 5
53607: PUSH
53608: LD_EXP 102
53612: PUSH
53613: LD_VAR 0 2
53617: ARRAY
53618: PPUSH
53619: LD_INT 25
53621: PUSH
53622: LD_INT 2
53624: PUSH
53625: EMPTY
53626: LIST
53627: LIST
53628: PUSH
53629: LD_INT 24
53631: PUSH
53632: LD_INT 750
53634: PUSH
53635: EMPTY
53636: LIST
53637: LIST
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: PPUSH
53643: CALL_OW 72
53647: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
53648: LD_EXP 131
53652: PUSH
53653: LD_VAR 0 2
53657: ARRAY
53658: PUSH
53659: LD_EXP 102
53663: PUSH
53664: LD_VAR 0 2
53668: ARRAY
53669: PPUSH
53670: LD_INT 25
53672: PUSH
53673: LD_INT 2
53675: PUSH
53676: EMPTY
53677: LIST
53678: LIST
53679: PUSH
53680: LD_INT 24
53682: PUSH
53683: LD_INT 750
53685: PUSH
53686: EMPTY
53687: LIST
53688: LIST
53689: PUSH
53690: EMPTY
53691: LIST
53692: LIST
53693: PPUSH
53694: CALL_OW 72
53698: AND
53699: PUSH
53700: LD_VAR 0 5
53704: PUSH
53705: LD_INT 5
53707: LESS
53708: AND
53709: IFFALSE 53791
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
53711: LD_ADDR_VAR 0 3
53715: PUSH
53716: LD_EXP 102
53720: PUSH
53721: LD_VAR 0 2
53725: ARRAY
53726: PPUSH
53727: LD_INT 25
53729: PUSH
53730: LD_INT 2
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: PUSH
53737: LD_INT 24
53739: PUSH
53740: LD_INT 750
53742: PUSH
53743: EMPTY
53744: LIST
53745: LIST
53746: PUSH
53747: EMPTY
53748: LIST
53749: LIST
53750: PPUSH
53751: CALL_OW 72
53755: PUSH
53756: FOR_IN
53757: IFFALSE 53789
// begin tmp := tmp union j ;
53759: LD_ADDR_VAR 0 5
53763: PUSH
53764: LD_VAR 0 5
53768: PUSH
53769: LD_VAR 0 3
53773: UNION
53774: ST_TO_ADDR
// if tmp >= 5 then
53775: LD_VAR 0 5
53779: PUSH
53780: LD_INT 5
53782: GREATEREQUAL
53783: IFFALSE 53787
// break ;
53785: GO 53789
// end ;
53787: GO 53756
53789: POP
53790: POP
// end ; if not tmp then
53791: LD_VAR 0 5
53795: NOT
53796: IFFALSE 53800
// continue ;
53798: GO 52953
// for j in tmp do
53800: LD_ADDR_VAR 0 3
53804: PUSH
53805: LD_VAR 0 5
53809: PUSH
53810: FOR_IN
53811: IFFALSE 53901
// if not GetTag ( j ) then
53813: LD_VAR 0 3
53817: PPUSH
53818: CALL_OW 110
53822: NOT
53823: IFFALSE 53899
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53825: LD_ADDR_EXP 119
53829: PUSH
53830: LD_EXP 119
53834: PPUSH
53835: LD_VAR 0 2
53839: PUSH
53840: LD_EXP 119
53844: PUSH
53845: LD_VAR 0 2
53849: ARRAY
53850: PUSH
53851: LD_INT 1
53853: PLUS
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: PPUSH
53859: LD_VAR 0 3
53863: PPUSH
53864: CALL 75355 0 3
53868: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53869: LD_VAR 0 3
53873: PPUSH
53874: LD_INT 107
53876: PPUSH
53877: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53881: LD_EXP 119
53885: PUSH
53886: LD_VAR 0 2
53890: ARRAY
53891: PUSH
53892: LD_INT 5
53894: GREATEREQUAL
53895: IFFALSE 53899
// break ;
53897: GO 53901
// end ;
53899: GO 53810
53901: POP
53902: POP
// end ; if mc_crates_collector [ i ] and target then
53903: LD_EXP 119
53907: PUSH
53908: LD_VAR 0 2
53912: ARRAY
53913: PUSH
53914: LD_VAR 0 7
53918: AND
53919: IFFALSE 54225
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53921: LD_EXP 119
53925: PUSH
53926: LD_VAR 0 2
53930: ARRAY
53931: PUSH
53932: LD_VAR 0 7
53936: PUSH
53937: LD_INT 1
53939: ARRAY
53940: LESS
53941: IFFALSE 53961
// tmp := mc_crates_collector [ i ] else
53943: LD_ADDR_VAR 0 5
53947: PUSH
53948: LD_EXP 119
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: ST_TO_ADDR
53959: GO 53975
// tmp := target [ 1 ] ;
53961: LD_ADDR_VAR 0 5
53965: PUSH
53966: LD_VAR 0 7
53970: PUSH
53971: LD_INT 1
53973: ARRAY
53974: ST_TO_ADDR
// k := 0 ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_INT 0
53982: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53983: LD_ADDR_VAR 0 3
53987: PUSH
53988: LD_EXP 119
53992: PUSH
53993: LD_VAR 0 2
53997: ARRAY
53998: PUSH
53999: FOR_IN
54000: IFFALSE 54223
// begin k := k + 1 ;
54002: LD_ADDR_VAR 0 4
54006: PUSH
54007: LD_VAR 0 4
54011: PUSH
54012: LD_INT 1
54014: PLUS
54015: ST_TO_ADDR
// if k > tmp then
54016: LD_VAR 0 4
54020: PUSH
54021: LD_VAR 0 5
54025: GREATER
54026: IFFALSE 54030
// break ;
54028: GO 54223
// if not GetClass ( j ) in [ 2 , 16 ] then
54030: LD_VAR 0 3
54034: PPUSH
54035: CALL_OW 257
54039: PUSH
54040: LD_INT 2
54042: PUSH
54043: LD_INT 16
54045: PUSH
54046: EMPTY
54047: LIST
54048: LIST
54049: IN
54050: NOT
54051: IFFALSE 54104
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54053: LD_ADDR_EXP 119
54057: PUSH
54058: LD_EXP 119
54062: PPUSH
54063: LD_VAR 0 2
54067: PPUSH
54068: LD_EXP 119
54072: PUSH
54073: LD_VAR 0 2
54077: ARRAY
54078: PUSH
54079: LD_VAR 0 3
54083: DIFF
54084: PPUSH
54085: CALL_OW 1
54089: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54090: LD_VAR 0 3
54094: PPUSH
54095: LD_INT 0
54097: PPUSH
54098: CALL_OW 109
// continue ;
54102: GO 53999
// end ; if IsInUnit ( j ) then
54104: LD_VAR 0 3
54108: PPUSH
54109: CALL_OW 310
54113: IFFALSE 54124
// ComExitBuilding ( j ) ;
54115: LD_VAR 0 3
54119: PPUSH
54120: CALL_OW 122
// wait ( 3 ) ;
54124: LD_INT 3
54126: PPUSH
54127: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54131: LD_VAR 0 3
54135: PPUSH
54136: CALL_OW 314
54140: PUSH
54141: LD_VAR 0 6
54145: PPUSH
54146: LD_VAR 0 7
54150: PUSH
54151: LD_INT 2
54153: ARRAY
54154: PPUSH
54155: LD_VAR 0 7
54159: PUSH
54160: LD_INT 3
54162: ARRAY
54163: PPUSH
54164: LD_INT 30
54166: PPUSH
54167: CALL 76619 0 4
54171: PUSH
54172: LD_INT 4
54174: ARRAY
54175: AND
54176: IFFALSE 54194
// ComStandNearbyBuilding ( j , depot ) else
54178: LD_VAR 0 3
54182: PPUSH
54183: LD_VAR 0 9
54187: PPUSH
54188: CALL 71957 0 2
54192: GO 54221
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54194: LD_VAR 0 3
54198: PPUSH
54199: LD_VAR 0 7
54203: PUSH
54204: LD_INT 2
54206: ARRAY
54207: PPUSH
54208: LD_VAR 0 7
54212: PUSH
54213: LD_INT 3
54215: ARRAY
54216: PPUSH
54217: CALL_OW 117
// end ;
54221: GO 53999
54223: POP
54224: POP
// end ; end else
54225: GO 54757
// begin for j in cargo do
54227: LD_ADDR_VAR 0 3
54231: PUSH
54232: LD_VAR 0 8
54236: PUSH
54237: FOR_IN
54238: IFFALSE 54755
// begin if GetTag ( j ) <> 0 then
54240: LD_VAR 0 3
54244: PPUSH
54245: CALL_OW 110
54249: PUSH
54250: LD_INT 0
54252: NONEQUAL
54253: IFFALSE 54257
// continue ;
54255: GO 54237
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54257: LD_VAR 0 3
54261: PPUSH
54262: CALL_OW 256
54266: PUSH
54267: LD_INT 1000
54269: LESS
54270: PUSH
54271: LD_VAR 0 3
54275: PPUSH
54276: LD_EXP 126
54280: PUSH
54281: LD_VAR 0 2
54285: ARRAY
54286: PPUSH
54287: CALL_OW 308
54291: NOT
54292: AND
54293: IFFALSE 54315
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54295: LD_VAR 0 3
54299: PPUSH
54300: LD_EXP 126
54304: PUSH
54305: LD_VAR 0 2
54309: ARRAY
54310: PPUSH
54311: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54315: LD_VAR 0 3
54319: PPUSH
54320: CALL_OW 256
54324: PUSH
54325: LD_INT 1000
54327: LESS
54328: PUSH
54329: LD_VAR 0 3
54333: PPUSH
54334: LD_EXP 126
54338: PUSH
54339: LD_VAR 0 2
54343: ARRAY
54344: PPUSH
54345: CALL_OW 308
54349: AND
54350: IFFALSE 54354
// continue ;
54352: GO 54237
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54354: LD_VAR 0 3
54358: PPUSH
54359: CALL_OW 262
54363: PUSH
54364: LD_INT 2
54366: EQUAL
54367: PUSH
54368: LD_VAR 0 3
54372: PPUSH
54373: CALL_OW 261
54377: PUSH
54378: LD_INT 15
54380: LESS
54381: AND
54382: IFFALSE 54386
// continue ;
54384: GO 54237
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54386: LD_VAR 0 3
54390: PPUSH
54391: CALL_OW 262
54395: PUSH
54396: LD_INT 1
54398: EQUAL
54399: PUSH
54400: LD_VAR 0 3
54404: PPUSH
54405: CALL_OW 261
54409: PUSH
54410: LD_INT 10
54412: LESS
54413: AND
54414: IFFALSE 54694
// begin if not depot then
54416: LD_VAR 0 9
54420: NOT
54421: IFFALSE 54425
// continue ;
54423: GO 54237
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54425: LD_VAR 0 3
54429: PPUSH
54430: LD_VAR 0 9
54434: PPUSH
54435: LD_VAR 0 3
54439: PPUSH
54440: CALL_OW 74
54444: PPUSH
54445: CALL_OW 296
54449: PUSH
54450: LD_INT 6
54452: LESS
54453: IFFALSE 54469
// SetFuel ( j , 100 ) else
54455: LD_VAR 0 3
54459: PPUSH
54460: LD_INT 100
54462: PPUSH
54463: CALL_OW 240
54467: GO 54694
// if GetFuel ( j ) = 0 then
54469: LD_VAR 0 3
54473: PPUSH
54474: CALL_OW 261
54478: PUSH
54479: LD_INT 0
54481: EQUAL
54482: IFFALSE 54694
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54484: LD_ADDR_EXP 121
54488: PUSH
54489: LD_EXP 121
54493: PPUSH
54494: LD_VAR 0 2
54498: PPUSH
54499: LD_EXP 121
54503: PUSH
54504: LD_VAR 0 2
54508: ARRAY
54509: PUSH
54510: LD_VAR 0 3
54514: DIFF
54515: PPUSH
54516: CALL_OW 1
54520: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54521: LD_VAR 0 3
54525: PPUSH
54526: CALL_OW 263
54530: PUSH
54531: LD_INT 1
54533: EQUAL
54534: IFFALSE 54550
// ComExitVehicle ( IsInUnit ( j ) ) ;
54536: LD_VAR 0 3
54540: PPUSH
54541: CALL_OW 310
54545: PPUSH
54546: CALL_OW 121
// if GetControl ( j ) = control_remote then
54550: LD_VAR 0 3
54554: PPUSH
54555: CALL_OW 263
54559: PUSH
54560: LD_INT 2
54562: EQUAL
54563: IFFALSE 54574
// ComUnlink ( j ) ;
54565: LD_VAR 0 3
54569: PPUSH
54570: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54574: LD_ADDR_VAR 0 10
54578: PUSH
54579: LD_VAR 0 2
54583: PPUSH
54584: LD_INT 3
54586: PPUSH
54587: CALL 64338 0 2
54591: ST_TO_ADDR
// if fac then
54592: LD_VAR 0 10
54596: IFFALSE 54692
// begin for k in fac do
54598: LD_ADDR_VAR 0 4
54602: PUSH
54603: LD_VAR 0 10
54607: PUSH
54608: FOR_IN
54609: IFFALSE 54690
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54611: LD_ADDR_VAR 0 11
54615: PUSH
54616: LD_VAR 0 10
54620: PPUSH
54621: LD_VAR 0 3
54625: PPUSH
54626: CALL_OW 265
54630: PPUSH
54631: LD_VAR 0 3
54635: PPUSH
54636: CALL_OW 262
54640: PPUSH
54641: LD_VAR 0 3
54645: PPUSH
54646: CALL_OW 263
54650: PPUSH
54651: LD_VAR 0 3
54655: PPUSH
54656: CALL_OW 264
54660: PPUSH
54661: CALL 72853 0 5
54665: ST_TO_ADDR
// if components then
54666: LD_VAR 0 11
54670: IFFALSE 54688
// begin MC_InsertProduceList ( i , components ) ;
54672: LD_VAR 0 2
54676: PPUSH
54677: LD_VAR 0 11
54681: PPUSH
54682: CALL 63883 0 2
// break ;
54686: GO 54690
// end ; end ;
54688: GO 54608
54690: POP
54691: POP
// end ; continue ;
54692: GO 54237
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
54694: LD_VAR 0 3
54698: PPUSH
54699: LD_INT 1
54701: PPUSH
54702: CALL_OW 289
54706: PUSH
54707: LD_INT 100
54709: LESS
54710: PUSH
54711: LD_VAR 0 3
54715: PPUSH
54716: CALL_OW 314
54720: NOT
54721: AND
54722: IFFALSE 54751
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54724: LD_VAR 0 3
54728: PPUSH
54729: LD_VAR 0 7
54733: PUSH
54734: LD_INT 2
54736: ARRAY
54737: PPUSH
54738: LD_VAR 0 7
54742: PUSH
54743: LD_INT 3
54745: ARRAY
54746: PPUSH
54747: CALL_OW 117
// break ;
54751: GO 54755
// end ;
54753: GO 54237
54755: POP
54756: POP
// end ; end ;
54757: GO 52953
54759: POP
54760: POP
// end ;
54761: LD_VAR 0 1
54765: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54766: LD_INT 0
54768: PPUSH
54769: PPUSH
54770: PPUSH
54771: PPUSH
// if not mc_bases then
54772: LD_EXP 102
54776: NOT
54777: IFFALSE 54781
// exit ;
54779: GO 54942
// for i = 1 to mc_bases do
54781: LD_ADDR_VAR 0 2
54785: PUSH
54786: DOUBLE
54787: LD_INT 1
54789: DEC
54790: ST_TO_ADDR
54791: LD_EXP 102
54795: PUSH
54796: FOR_TO
54797: IFFALSE 54940
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54799: LD_ADDR_VAR 0 4
54803: PUSH
54804: LD_EXP 121
54808: PUSH
54809: LD_VAR 0 2
54813: ARRAY
54814: PUSH
54815: LD_EXP 124
54819: PUSH
54820: LD_VAR 0 2
54824: ARRAY
54825: UNION
54826: PPUSH
54827: LD_INT 33
54829: PUSH
54830: LD_INT 2
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: PPUSH
54837: CALL_OW 72
54841: ST_TO_ADDR
// if tmp then
54842: LD_VAR 0 4
54846: IFFALSE 54938
// for j in tmp do
54848: LD_ADDR_VAR 0 3
54852: PUSH
54853: LD_VAR 0 4
54857: PUSH
54858: FOR_IN
54859: IFFALSE 54936
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54861: LD_VAR 0 3
54865: PPUSH
54866: CALL_OW 312
54870: NOT
54871: PUSH
54872: LD_VAR 0 3
54876: PPUSH
54877: CALL_OW 256
54881: PUSH
54882: LD_INT 250
54884: GREATEREQUAL
54885: AND
54886: IFFALSE 54899
// Connect ( j ) else
54888: LD_VAR 0 3
54892: PPUSH
54893: CALL 78701 0 1
54897: GO 54934
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54899: LD_VAR 0 3
54903: PPUSH
54904: CALL_OW 256
54908: PUSH
54909: LD_INT 250
54911: LESS
54912: PUSH
54913: LD_VAR 0 3
54917: PPUSH
54918: CALL_OW 312
54922: AND
54923: IFFALSE 54934
// ComUnlink ( j ) ;
54925: LD_VAR 0 3
54929: PPUSH
54930: CALL_OW 136
54934: GO 54858
54936: POP
54937: POP
// end ;
54938: GO 54796
54940: POP
54941: POP
// end ;
54942: LD_VAR 0 1
54946: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54947: LD_INT 0
54949: PPUSH
54950: PPUSH
54951: PPUSH
54952: PPUSH
54953: PPUSH
// if not mc_bases then
54954: LD_EXP 102
54958: NOT
54959: IFFALSE 54963
// exit ;
54961: GO 55408
// for i = 1 to mc_bases do
54963: LD_ADDR_VAR 0 2
54967: PUSH
54968: DOUBLE
54969: LD_INT 1
54971: DEC
54972: ST_TO_ADDR
54973: LD_EXP 102
54977: PUSH
54978: FOR_TO
54979: IFFALSE 55406
// begin if not mc_produce [ i ] then
54981: LD_EXP 123
54985: PUSH
54986: LD_VAR 0 2
54990: ARRAY
54991: NOT
54992: IFFALSE 54996
// continue ;
54994: GO 54978
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54996: LD_ADDR_VAR 0 5
55000: PUSH
55001: LD_EXP 102
55005: PUSH
55006: LD_VAR 0 2
55010: ARRAY
55011: PPUSH
55012: LD_INT 30
55014: PUSH
55015: LD_INT 3
55017: PUSH
55018: EMPTY
55019: LIST
55020: LIST
55021: PPUSH
55022: CALL_OW 72
55026: ST_TO_ADDR
// if not fac then
55027: LD_VAR 0 5
55031: NOT
55032: IFFALSE 55036
// continue ;
55034: GO 54978
// for j in fac do
55036: LD_ADDR_VAR 0 3
55040: PUSH
55041: LD_VAR 0 5
55045: PUSH
55046: FOR_IN
55047: IFFALSE 55402
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55049: LD_VAR 0 3
55053: PPUSH
55054: CALL_OW 461
55058: PUSH
55059: LD_INT 2
55061: NONEQUAL
55062: PUSH
55063: LD_VAR 0 3
55067: PPUSH
55068: LD_INT 15
55070: PPUSH
55071: CALL 78320 0 2
55075: PUSH
55076: LD_INT 4
55078: ARRAY
55079: OR
55080: IFFALSE 55084
// continue ;
55082: GO 55046
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55084: LD_VAR 0 3
55088: PPUSH
55089: LD_EXP 123
55093: PUSH
55094: LD_VAR 0 2
55098: ARRAY
55099: PUSH
55100: LD_INT 1
55102: ARRAY
55103: PUSH
55104: LD_INT 1
55106: ARRAY
55107: PPUSH
55108: LD_EXP 123
55112: PUSH
55113: LD_VAR 0 2
55117: ARRAY
55118: PUSH
55119: LD_INT 1
55121: ARRAY
55122: PUSH
55123: LD_INT 2
55125: ARRAY
55126: PPUSH
55127: LD_EXP 123
55131: PUSH
55132: LD_VAR 0 2
55136: ARRAY
55137: PUSH
55138: LD_INT 1
55140: ARRAY
55141: PUSH
55142: LD_INT 3
55144: ARRAY
55145: PPUSH
55146: LD_EXP 123
55150: PUSH
55151: LD_VAR 0 2
55155: ARRAY
55156: PUSH
55157: LD_INT 1
55159: ARRAY
55160: PUSH
55161: LD_INT 4
55163: ARRAY
55164: PPUSH
55165: CALL_OW 448
55169: PUSH
55170: LD_VAR 0 3
55174: PPUSH
55175: LD_EXP 123
55179: PUSH
55180: LD_VAR 0 2
55184: ARRAY
55185: PUSH
55186: LD_INT 1
55188: ARRAY
55189: PUSH
55190: LD_INT 1
55192: ARRAY
55193: PUSH
55194: LD_EXP 123
55198: PUSH
55199: LD_VAR 0 2
55203: ARRAY
55204: PUSH
55205: LD_INT 1
55207: ARRAY
55208: PUSH
55209: LD_INT 2
55211: ARRAY
55212: PUSH
55213: LD_EXP 123
55217: PUSH
55218: LD_VAR 0 2
55222: ARRAY
55223: PUSH
55224: LD_INT 1
55226: ARRAY
55227: PUSH
55228: LD_INT 3
55230: ARRAY
55231: PUSH
55232: LD_EXP 123
55236: PUSH
55237: LD_VAR 0 2
55241: ARRAY
55242: PUSH
55243: LD_INT 1
55245: ARRAY
55246: PUSH
55247: LD_INT 4
55249: ARRAY
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: LIST
55255: LIST
55256: PPUSH
55257: CALL 82096 0 2
55261: AND
55262: IFFALSE 55400
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55264: LD_VAR 0 3
55268: PPUSH
55269: LD_EXP 123
55273: PUSH
55274: LD_VAR 0 2
55278: ARRAY
55279: PUSH
55280: LD_INT 1
55282: ARRAY
55283: PUSH
55284: LD_INT 1
55286: ARRAY
55287: PPUSH
55288: LD_EXP 123
55292: PUSH
55293: LD_VAR 0 2
55297: ARRAY
55298: PUSH
55299: LD_INT 1
55301: ARRAY
55302: PUSH
55303: LD_INT 2
55305: ARRAY
55306: PPUSH
55307: LD_EXP 123
55311: PUSH
55312: LD_VAR 0 2
55316: ARRAY
55317: PUSH
55318: LD_INT 1
55320: ARRAY
55321: PUSH
55322: LD_INT 3
55324: ARRAY
55325: PPUSH
55326: LD_EXP 123
55330: PUSH
55331: LD_VAR 0 2
55335: ARRAY
55336: PUSH
55337: LD_INT 1
55339: ARRAY
55340: PUSH
55341: LD_INT 4
55343: ARRAY
55344: PPUSH
55345: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55349: LD_ADDR_VAR 0 4
55353: PUSH
55354: LD_EXP 123
55358: PUSH
55359: LD_VAR 0 2
55363: ARRAY
55364: PPUSH
55365: LD_INT 1
55367: PPUSH
55368: CALL_OW 3
55372: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55373: LD_ADDR_EXP 123
55377: PUSH
55378: LD_EXP 123
55382: PPUSH
55383: LD_VAR 0 2
55387: PPUSH
55388: LD_VAR 0 4
55392: PPUSH
55393: CALL_OW 1
55397: ST_TO_ADDR
// break ;
55398: GO 55402
// end ; end ;
55400: GO 55046
55402: POP
55403: POP
// end ;
55404: GO 54978
55406: POP
55407: POP
// end ;
55408: LD_VAR 0 1
55412: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55413: LD_INT 0
55415: PPUSH
55416: PPUSH
55417: PPUSH
// if not mc_bases then
55418: LD_EXP 102
55422: NOT
55423: IFFALSE 55427
// exit ;
55425: GO 55516
// for i = 1 to mc_bases do
55427: LD_ADDR_VAR 0 2
55431: PUSH
55432: DOUBLE
55433: LD_INT 1
55435: DEC
55436: ST_TO_ADDR
55437: LD_EXP 102
55441: PUSH
55442: FOR_TO
55443: IFFALSE 55514
// begin if mc_attack [ i ] then
55445: LD_EXP 122
55449: PUSH
55450: LD_VAR 0 2
55454: ARRAY
55455: IFFALSE 55512
// begin tmp := mc_attack [ i ] [ 1 ] ;
55457: LD_ADDR_VAR 0 3
55461: PUSH
55462: LD_EXP 122
55466: PUSH
55467: LD_VAR 0 2
55471: ARRAY
55472: PUSH
55473: LD_INT 1
55475: ARRAY
55476: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55477: LD_ADDR_EXP 122
55481: PUSH
55482: LD_EXP 122
55486: PPUSH
55487: LD_VAR 0 2
55491: PPUSH
55492: EMPTY
55493: PPUSH
55494: CALL_OW 1
55498: ST_TO_ADDR
// Attack ( tmp ) ;
55499: LD_VAR 0 3
55503: PPUSH
55504: CALL 134475 0 1
// exit ;
55508: POP
55509: POP
55510: GO 55516
// end ; end ;
55512: GO 55442
55514: POP
55515: POP
// end ;
55516: LD_VAR 0 1
55520: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55521: LD_INT 0
55523: PPUSH
55524: PPUSH
55525: PPUSH
55526: PPUSH
55527: PPUSH
55528: PPUSH
55529: PPUSH
// if not mc_bases then
55530: LD_EXP 102
55534: NOT
55535: IFFALSE 55539
// exit ;
55537: GO 56396
// for i = 1 to mc_bases do
55539: LD_ADDR_VAR 0 2
55543: PUSH
55544: DOUBLE
55545: LD_INT 1
55547: DEC
55548: ST_TO_ADDR
55549: LD_EXP 102
55553: PUSH
55554: FOR_TO
55555: IFFALSE 56394
// begin if not mc_bases [ i ] then
55557: LD_EXP 102
55561: PUSH
55562: LD_VAR 0 2
55566: ARRAY
55567: NOT
55568: IFFALSE 55572
// continue ;
55570: GO 55554
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55572: LD_ADDR_VAR 0 7
55576: PUSH
55577: LD_EXP 102
55581: PUSH
55582: LD_VAR 0 2
55586: ARRAY
55587: PUSH
55588: LD_INT 1
55590: ARRAY
55591: PPUSH
55592: CALL 72179 0 1
55596: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55597: LD_ADDR_EXP 125
55601: PUSH
55602: LD_EXP 125
55606: PPUSH
55607: LD_VAR 0 2
55611: PPUSH
55612: LD_EXP 102
55616: PUSH
55617: LD_VAR 0 2
55621: ARRAY
55622: PUSH
55623: LD_INT 1
55625: ARRAY
55626: PPUSH
55627: CALL_OW 255
55631: PPUSH
55632: LD_EXP 127
55636: PUSH
55637: LD_VAR 0 2
55641: ARRAY
55642: PPUSH
55643: CALL 72144 0 2
55647: PPUSH
55648: CALL_OW 1
55652: ST_TO_ADDR
// if not mc_scan [ i ] then
55653: LD_EXP 125
55657: PUSH
55658: LD_VAR 0 2
55662: ARRAY
55663: NOT
55664: IFFALSE 55842
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55666: LD_ADDR_EXP 145
55670: PUSH
55671: LD_EXP 145
55675: PPUSH
55676: LD_VAR 0 2
55680: PPUSH
55681: LD_INT 0
55683: PPUSH
55684: CALL_OW 1
55688: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55689: LD_ADDR_VAR 0 4
55693: PUSH
55694: LD_EXP 102
55698: PUSH
55699: LD_VAR 0 2
55703: ARRAY
55704: PPUSH
55705: LD_INT 2
55707: PUSH
55708: LD_INT 25
55710: PUSH
55711: LD_INT 5
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: PUSH
55718: LD_INT 25
55720: PUSH
55721: LD_INT 8
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PUSH
55728: LD_INT 25
55730: PUSH
55731: LD_INT 9
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: LIST
55742: LIST
55743: PPUSH
55744: CALL_OW 72
55748: ST_TO_ADDR
// if not tmp then
55749: LD_VAR 0 4
55753: NOT
55754: IFFALSE 55758
// continue ;
55756: GO 55554
// for j in tmp do
55758: LD_ADDR_VAR 0 3
55762: PUSH
55763: LD_VAR 0 4
55767: PUSH
55768: FOR_IN
55769: IFFALSE 55840
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55771: LD_VAR 0 3
55775: PPUSH
55776: CALL_OW 310
55780: PPUSH
55781: CALL_OW 266
55785: PUSH
55786: LD_INT 5
55788: EQUAL
55789: PUSH
55790: LD_VAR 0 3
55794: PPUSH
55795: CALL_OW 257
55799: PUSH
55800: LD_INT 1
55802: EQUAL
55803: AND
55804: PUSH
55805: LD_VAR 0 3
55809: PPUSH
55810: CALL_OW 459
55814: NOT
55815: AND
55816: PUSH
55817: LD_VAR 0 7
55821: AND
55822: IFFALSE 55838
// ComChangeProfession ( j , class ) ;
55824: LD_VAR 0 3
55828: PPUSH
55829: LD_VAR 0 7
55833: PPUSH
55834: CALL_OW 123
55838: GO 55768
55840: POP
55841: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55842: LD_EXP 125
55846: PUSH
55847: LD_VAR 0 2
55851: ARRAY
55852: PUSH
55853: LD_EXP 145
55857: PUSH
55858: LD_VAR 0 2
55862: ARRAY
55863: NOT
55864: AND
55865: PUSH
55866: LD_EXP 124
55870: PUSH
55871: LD_VAR 0 2
55875: ARRAY
55876: NOT
55877: AND
55878: PUSH
55879: LD_EXP 102
55883: PUSH
55884: LD_VAR 0 2
55888: ARRAY
55889: PPUSH
55890: LD_INT 50
55892: PUSH
55893: EMPTY
55894: LIST
55895: PUSH
55896: LD_INT 2
55898: PUSH
55899: LD_INT 30
55901: PUSH
55902: LD_INT 32
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: PUSH
55909: LD_INT 30
55911: PUSH
55912: LD_INT 33
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: LD_INT 30
55921: PUSH
55922: LD_INT 4
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PUSH
55929: LD_INT 30
55931: PUSH
55932: LD_INT 5
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: EMPTY
55940: LIST
55941: LIST
55942: LIST
55943: LIST
55944: LIST
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PPUSH
55950: CALL_OW 72
55954: PUSH
55955: LD_INT 4
55957: LESS
55958: PUSH
55959: LD_EXP 102
55963: PUSH
55964: LD_VAR 0 2
55968: ARRAY
55969: PPUSH
55970: LD_INT 3
55972: PUSH
55973: LD_INT 24
55975: PUSH
55976: LD_INT 1000
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: PUSH
55983: EMPTY
55984: LIST
55985: LIST
55986: PUSH
55987: LD_INT 2
55989: PUSH
55990: LD_INT 30
55992: PUSH
55993: LD_INT 0
55995: PUSH
55996: EMPTY
55997: LIST
55998: LIST
55999: PUSH
56000: LD_INT 30
56002: PUSH
56003: LD_INT 1
56005: PUSH
56006: EMPTY
56007: LIST
56008: LIST
56009: PUSH
56010: EMPTY
56011: LIST
56012: LIST
56013: LIST
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: PPUSH
56019: CALL_OW 72
56023: OR
56024: AND
56025: IFFALSE 56276
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56027: LD_ADDR_EXP 145
56031: PUSH
56032: LD_EXP 145
56036: PPUSH
56037: LD_VAR 0 2
56041: PPUSH
56042: LD_INT 1
56044: PPUSH
56045: CALL_OW 1
56049: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56050: LD_ADDR_VAR 0 4
56054: PUSH
56055: LD_EXP 102
56059: PUSH
56060: LD_VAR 0 2
56064: ARRAY
56065: PPUSH
56066: LD_INT 2
56068: PUSH
56069: LD_INT 25
56071: PUSH
56072: LD_INT 1
56074: PUSH
56075: EMPTY
56076: LIST
56077: LIST
56078: PUSH
56079: LD_INT 25
56081: PUSH
56082: LD_INT 5
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: PUSH
56089: LD_INT 25
56091: PUSH
56092: LD_INT 8
56094: PUSH
56095: EMPTY
56096: LIST
56097: LIST
56098: PUSH
56099: LD_INT 25
56101: PUSH
56102: LD_INT 9
56104: PUSH
56105: EMPTY
56106: LIST
56107: LIST
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: LIST
56113: LIST
56114: LIST
56115: PPUSH
56116: CALL_OW 72
56120: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56121: LD_ADDR_VAR 0 4
56125: PUSH
56126: LD_VAR 0 4
56130: PUSH
56131: LD_VAR 0 4
56135: PPUSH
56136: LD_INT 18
56138: PPUSH
56139: CALL 105673 0 2
56143: DIFF
56144: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56145: LD_VAR 0 4
56149: NOT
56150: PUSH
56151: LD_EXP 102
56155: PUSH
56156: LD_VAR 0 2
56160: ARRAY
56161: PPUSH
56162: LD_INT 2
56164: PUSH
56165: LD_INT 30
56167: PUSH
56168: LD_INT 4
56170: PUSH
56171: EMPTY
56172: LIST
56173: LIST
56174: PUSH
56175: LD_INT 30
56177: PUSH
56178: LD_INT 5
56180: PUSH
56181: EMPTY
56182: LIST
56183: LIST
56184: PUSH
56185: EMPTY
56186: LIST
56187: LIST
56188: LIST
56189: PPUSH
56190: CALL_OW 72
56194: NOT
56195: AND
56196: IFFALSE 56258
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56198: LD_ADDR_VAR 0 4
56202: PUSH
56203: LD_EXP 102
56207: PUSH
56208: LD_VAR 0 2
56212: ARRAY
56213: PPUSH
56214: LD_INT 2
56216: PUSH
56217: LD_INT 25
56219: PUSH
56220: LD_INT 2
56222: PUSH
56223: EMPTY
56224: LIST
56225: LIST
56226: PUSH
56227: LD_INT 25
56229: PUSH
56230: LD_INT 3
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: PUSH
56237: LD_INT 25
56239: PUSH
56240: LD_INT 4
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: LIST
56251: LIST
56252: PPUSH
56253: CALL_OW 72
56257: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56258: LD_VAR 0 2
56262: PPUSH
56263: LD_VAR 0 4
56267: PPUSH
56268: CALL 139184 0 2
// exit ;
56272: POP
56273: POP
56274: GO 56396
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56276: LD_EXP 125
56280: PUSH
56281: LD_VAR 0 2
56285: ARRAY
56286: PUSH
56287: LD_EXP 145
56291: PUSH
56292: LD_VAR 0 2
56296: ARRAY
56297: NOT
56298: AND
56299: PUSH
56300: LD_EXP 124
56304: PUSH
56305: LD_VAR 0 2
56309: ARRAY
56310: AND
56311: IFFALSE 56392
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56313: LD_ADDR_EXP 145
56317: PUSH
56318: LD_EXP 145
56322: PPUSH
56323: LD_VAR 0 2
56327: PPUSH
56328: LD_INT 1
56330: PPUSH
56331: CALL_OW 1
56335: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56336: LD_ADDR_VAR 0 4
56340: PUSH
56341: LD_EXP 124
56345: PUSH
56346: LD_VAR 0 2
56350: ARRAY
56351: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56352: LD_ADDR_EXP 124
56356: PUSH
56357: LD_EXP 124
56361: PPUSH
56362: LD_VAR 0 2
56366: PPUSH
56367: EMPTY
56368: PPUSH
56369: CALL_OW 1
56373: ST_TO_ADDR
// Defend ( i , tmp ) ;
56374: LD_VAR 0 2
56378: PPUSH
56379: LD_VAR 0 4
56383: PPUSH
56384: CALL 139780 0 2
// exit ;
56388: POP
56389: POP
56390: GO 56396
// end ; end ;
56392: GO 55554
56394: POP
56395: POP
// end ;
56396: LD_VAR 0 1
56400: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56401: LD_INT 0
56403: PPUSH
56404: PPUSH
56405: PPUSH
56406: PPUSH
56407: PPUSH
56408: PPUSH
56409: PPUSH
56410: PPUSH
56411: PPUSH
56412: PPUSH
56413: PPUSH
// if not mc_bases then
56414: LD_EXP 102
56418: NOT
56419: IFFALSE 56423
// exit ;
56421: GO 57510
// for i = 1 to mc_bases do
56423: LD_ADDR_VAR 0 2
56427: PUSH
56428: DOUBLE
56429: LD_INT 1
56431: DEC
56432: ST_TO_ADDR
56433: LD_EXP 102
56437: PUSH
56438: FOR_TO
56439: IFFALSE 57508
// begin tmp := mc_lab [ i ] ;
56441: LD_ADDR_VAR 0 6
56445: PUSH
56446: LD_EXP 135
56450: PUSH
56451: LD_VAR 0 2
56455: ARRAY
56456: ST_TO_ADDR
// if not tmp then
56457: LD_VAR 0 6
56461: NOT
56462: IFFALSE 56466
// continue ;
56464: GO 56438
// idle_lab := 0 ;
56466: LD_ADDR_VAR 0 11
56470: PUSH
56471: LD_INT 0
56473: ST_TO_ADDR
// for j in tmp do
56474: LD_ADDR_VAR 0 3
56478: PUSH
56479: LD_VAR 0 6
56483: PUSH
56484: FOR_IN
56485: IFFALSE 57504
// begin researching := false ;
56487: LD_ADDR_VAR 0 10
56491: PUSH
56492: LD_INT 0
56494: ST_TO_ADDR
// side := GetSide ( j ) ;
56495: LD_ADDR_VAR 0 4
56499: PUSH
56500: LD_VAR 0 3
56504: PPUSH
56505: CALL_OW 255
56509: ST_TO_ADDR
// if not mc_tech [ side ] then
56510: LD_EXP 129
56514: PUSH
56515: LD_VAR 0 4
56519: ARRAY
56520: NOT
56521: IFFALSE 56525
// continue ;
56523: GO 56484
// if BuildingStatus ( j ) = bs_idle then
56525: LD_VAR 0 3
56529: PPUSH
56530: CALL_OW 461
56534: PUSH
56535: LD_INT 2
56537: EQUAL
56538: IFFALSE 56726
// begin if idle_lab and UnitsInside ( j ) < 6 then
56540: LD_VAR 0 11
56544: PUSH
56545: LD_VAR 0 3
56549: PPUSH
56550: CALL_OW 313
56554: PUSH
56555: LD_INT 6
56557: LESS
56558: AND
56559: IFFALSE 56630
// begin tmp2 := UnitsInside ( idle_lab ) ;
56561: LD_ADDR_VAR 0 9
56565: PUSH
56566: LD_VAR 0 11
56570: PPUSH
56571: CALL_OW 313
56575: ST_TO_ADDR
// if tmp2 then
56576: LD_VAR 0 9
56580: IFFALSE 56622
// for x in tmp2 do
56582: LD_ADDR_VAR 0 7
56586: PUSH
56587: LD_VAR 0 9
56591: PUSH
56592: FOR_IN
56593: IFFALSE 56620
// begin ComExitBuilding ( x ) ;
56595: LD_VAR 0 7
56599: PPUSH
56600: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56604: LD_VAR 0 7
56608: PPUSH
56609: LD_VAR 0 3
56613: PPUSH
56614: CALL_OW 180
// end ;
56618: GO 56592
56620: POP
56621: POP
// idle_lab := 0 ;
56622: LD_ADDR_VAR 0 11
56626: PUSH
56627: LD_INT 0
56629: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
56630: LD_ADDR_VAR 0 5
56634: PUSH
56635: LD_EXP 129
56639: PUSH
56640: LD_VAR 0 4
56644: ARRAY
56645: PUSH
56646: FOR_IN
56647: IFFALSE 56707
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
56649: LD_VAR 0 3
56653: PPUSH
56654: LD_VAR 0 5
56658: PPUSH
56659: CALL_OW 430
56663: PUSH
56664: LD_VAR 0 4
56668: PPUSH
56669: LD_VAR 0 5
56673: PPUSH
56674: CALL 71249 0 2
56678: AND
56679: IFFALSE 56705
// begin researching := true ;
56681: LD_ADDR_VAR 0 10
56685: PUSH
56686: LD_INT 1
56688: ST_TO_ADDR
// ComResearch ( j , t ) ;
56689: LD_VAR 0 3
56693: PPUSH
56694: LD_VAR 0 5
56698: PPUSH
56699: CALL_OW 124
// break ;
56703: GO 56707
// end ;
56705: GO 56646
56707: POP
56708: POP
// if not researching then
56709: LD_VAR 0 10
56713: NOT
56714: IFFALSE 56726
// idle_lab := j ;
56716: LD_ADDR_VAR 0 11
56720: PUSH
56721: LD_VAR 0 3
56725: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
56726: LD_VAR 0 3
56730: PPUSH
56731: CALL_OW 461
56735: PUSH
56736: LD_INT 10
56738: EQUAL
56739: IFFALSE 57327
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
56741: LD_EXP 131
56745: PUSH
56746: LD_VAR 0 2
56750: ARRAY
56751: NOT
56752: PUSH
56753: LD_EXP 132
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: NOT
56764: AND
56765: PUSH
56766: LD_EXP 129
56770: PUSH
56771: LD_VAR 0 4
56775: ARRAY
56776: PUSH
56777: LD_INT 1
56779: GREATER
56780: AND
56781: IFFALSE 56912
// begin ComCancel ( j ) ;
56783: LD_VAR 0 3
56787: PPUSH
56788: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56792: LD_ADDR_EXP 129
56796: PUSH
56797: LD_EXP 129
56801: PPUSH
56802: LD_VAR 0 4
56806: PPUSH
56807: LD_EXP 129
56811: PUSH
56812: LD_VAR 0 4
56816: ARRAY
56817: PPUSH
56818: LD_EXP 129
56822: PUSH
56823: LD_VAR 0 4
56827: ARRAY
56828: PUSH
56829: LD_INT 1
56831: MINUS
56832: PPUSH
56833: LD_EXP 129
56837: PUSH
56838: LD_VAR 0 4
56842: ARRAY
56843: PPUSH
56844: LD_INT 0
56846: PPUSH
56847: CALL 74773 0 4
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56857: LD_ADDR_EXP 129
56861: PUSH
56862: LD_EXP 129
56866: PPUSH
56867: LD_VAR 0 4
56871: PPUSH
56872: LD_EXP 129
56876: PUSH
56877: LD_VAR 0 4
56881: ARRAY
56882: PPUSH
56883: LD_EXP 129
56887: PUSH
56888: LD_VAR 0 4
56892: ARRAY
56893: PPUSH
56894: LD_INT 1
56896: PPUSH
56897: LD_INT 0
56899: PPUSH
56900: CALL 74773 0 4
56904: PPUSH
56905: CALL_OW 1
56909: ST_TO_ADDR
// continue ;
56910: GO 56484
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56912: LD_EXP 131
56916: PUSH
56917: LD_VAR 0 2
56921: ARRAY
56922: PUSH
56923: LD_EXP 132
56927: PUSH
56928: LD_VAR 0 2
56932: ARRAY
56933: NOT
56934: AND
56935: IFFALSE 57062
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56937: LD_ADDR_EXP 132
56941: PUSH
56942: LD_EXP 132
56946: PPUSH
56947: LD_VAR 0 2
56951: PUSH
56952: LD_EXP 132
56956: PUSH
56957: LD_VAR 0 2
56961: ARRAY
56962: PUSH
56963: LD_INT 1
56965: PLUS
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PPUSH
56971: LD_EXP 131
56975: PUSH
56976: LD_VAR 0 2
56980: ARRAY
56981: PUSH
56982: LD_INT 1
56984: ARRAY
56985: PPUSH
56986: CALL 75355 0 3
56990: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56991: LD_EXP 131
56995: PUSH
56996: LD_VAR 0 2
57000: ARRAY
57001: PUSH
57002: LD_INT 1
57004: ARRAY
57005: PPUSH
57006: LD_INT 112
57008: PPUSH
57009: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
57013: LD_ADDR_VAR 0 9
57017: PUSH
57018: LD_EXP 131
57022: PUSH
57023: LD_VAR 0 2
57027: ARRAY
57028: PPUSH
57029: LD_INT 1
57031: PPUSH
57032: CALL_OW 3
57036: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57037: LD_ADDR_EXP 131
57041: PUSH
57042: LD_EXP 131
57046: PPUSH
57047: LD_VAR 0 2
57051: PPUSH
57052: LD_VAR 0 9
57056: PPUSH
57057: CALL_OW 1
57061: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57062: LD_EXP 131
57066: PUSH
57067: LD_VAR 0 2
57071: ARRAY
57072: PUSH
57073: LD_EXP 132
57077: PUSH
57078: LD_VAR 0 2
57082: ARRAY
57083: AND
57084: PUSH
57085: LD_EXP 132
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: PUSH
57096: LD_INT 1
57098: ARRAY
57099: PPUSH
57100: CALL_OW 310
57104: NOT
57105: AND
57106: PUSH
57107: LD_VAR 0 3
57111: PPUSH
57112: CALL_OW 313
57116: PUSH
57117: LD_INT 6
57119: EQUAL
57120: AND
57121: IFFALSE 57177
// begin tmp2 := UnitsInside ( j ) ;
57123: LD_ADDR_VAR 0 9
57127: PUSH
57128: LD_VAR 0 3
57132: PPUSH
57133: CALL_OW 313
57137: ST_TO_ADDR
// if tmp2 = 6 then
57138: LD_VAR 0 9
57142: PUSH
57143: LD_INT 6
57145: EQUAL
57146: IFFALSE 57177
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57148: LD_VAR 0 9
57152: PUSH
57153: LD_INT 1
57155: ARRAY
57156: PPUSH
57157: LD_INT 112
57159: PPUSH
57160: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57164: LD_VAR 0 9
57168: PUSH
57169: LD_INT 1
57171: ARRAY
57172: PPUSH
57173: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57177: LD_EXP 132
57181: PUSH
57182: LD_VAR 0 2
57186: ARRAY
57187: PUSH
57188: LD_EXP 132
57192: PUSH
57193: LD_VAR 0 2
57197: ARRAY
57198: PUSH
57199: LD_INT 1
57201: ARRAY
57202: PPUSH
57203: CALL_OW 314
57207: NOT
57208: AND
57209: PUSH
57210: LD_EXP 132
57214: PUSH
57215: LD_VAR 0 2
57219: ARRAY
57220: PUSH
57221: LD_INT 1
57223: ARRAY
57224: PPUSH
57225: CALL_OW 310
57229: NOT
57230: AND
57231: IFFALSE 57257
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57233: LD_EXP 132
57237: PUSH
57238: LD_VAR 0 2
57242: ARRAY
57243: PUSH
57244: LD_INT 1
57246: ARRAY
57247: PPUSH
57248: LD_VAR 0 3
57252: PPUSH
57253: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57257: LD_EXP 132
57261: PUSH
57262: LD_VAR 0 2
57266: ARRAY
57267: PUSH
57268: LD_INT 1
57270: ARRAY
57271: PPUSH
57272: CALL_OW 310
57276: PUSH
57277: LD_EXP 132
57281: PUSH
57282: LD_VAR 0 2
57286: ARRAY
57287: PUSH
57288: LD_INT 1
57290: ARRAY
57291: PPUSH
57292: CALL_OW 310
57296: PPUSH
57297: CALL_OW 461
57301: PUSH
57302: LD_INT 3
57304: NONEQUAL
57305: AND
57306: IFFALSE 57327
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57308: LD_EXP 132
57312: PUSH
57313: LD_VAR 0 2
57317: ARRAY
57318: PUSH
57319: LD_INT 1
57321: ARRAY
57322: PPUSH
57323: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57327: LD_VAR 0 3
57331: PPUSH
57332: CALL_OW 461
57336: PUSH
57337: LD_INT 6
57339: EQUAL
57340: PUSH
57341: LD_VAR 0 6
57345: PUSH
57346: LD_INT 1
57348: GREATER
57349: AND
57350: IFFALSE 57502
// begin sci := [ ] ;
57352: LD_ADDR_VAR 0 8
57356: PUSH
57357: EMPTY
57358: ST_TO_ADDR
// for x in ( tmp diff j ) do
57359: LD_ADDR_VAR 0 7
57363: PUSH
57364: LD_VAR 0 6
57368: PUSH
57369: LD_VAR 0 3
57373: DIFF
57374: PUSH
57375: FOR_IN
57376: IFFALSE 57428
// begin if sci = 6 then
57378: LD_VAR 0 8
57382: PUSH
57383: LD_INT 6
57385: EQUAL
57386: IFFALSE 57390
// break ;
57388: GO 57428
// if BuildingStatus ( x ) = bs_idle then
57390: LD_VAR 0 7
57394: PPUSH
57395: CALL_OW 461
57399: PUSH
57400: LD_INT 2
57402: EQUAL
57403: IFFALSE 57426
// sci := sci ^ UnitsInside ( x ) ;
57405: LD_ADDR_VAR 0 8
57409: PUSH
57410: LD_VAR 0 8
57414: PUSH
57415: LD_VAR 0 7
57419: PPUSH
57420: CALL_OW 313
57424: ADD
57425: ST_TO_ADDR
// end ;
57426: GO 57375
57428: POP
57429: POP
// if not sci then
57430: LD_VAR 0 8
57434: NOT
57435: IFFALSE 57439
// continue ;
57437: GO 56484
// for x in sci do
57439: LD_ADDR_VAR 0 7
57443: PUSH
57444: LD_VAR 0 8
57448: PUSH
57449: FOR_IN
57450: IFFALSE 57500
// if IsInUnit ( x ) and not HasTask ( x ) then
57452: LD_VAR 0 7
57456: PPUSH
57457: CALL_OW 310
57461: PUSH
57462: LD_VAR 0 7
57466: PPUSH
57467: CALL_OW 314
57471: NOT
57472: AND
57473: IFFALSE 57498
// begin ComExitBuilding ( x ) ;
57475: LD_VAR 0 7
57479: PPUSH
57480: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57484: LD_VAR 0 7
57488: PPUSH
57489: LD_VAR 0 3
57493: PPUSH
57494: CALL_OW 180
// end ;
57498: GO 57449
57500: POP
57501: POP
// end ; end ;
57502: GO 56484
57504: POP
57505: POP
// end ;
57506: GO 56438
57508: POP
57509: POP
// end ;
57510: LD_VAR 0 1
57514: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57515: LD_INT 0
57517: PPUSH
57518: PPUSH
// if not mc_bases then
57519: LD_EXP 102
57523: NOT
57524: IFFALSE 57528
// exit ;
57526: GO 57609
// for i = 1 to mc_bases do
57528: LD_ADDR_VAR 0 2
57532: PUSH
57533: DOUBLE
57534: LD_INT 1
57536: DEC
57537: ST_TO_ADDR
57538: LD_EXP 102
57542: PUSH
57543: FOR_TO
57544: IFFALSE 57607
// if mc_mines [ i ] and mc_miners [ i ] then
57546: LD_EXP 115
57550: PUSH
57551: LD_VAR 0 2
57555: ARRAY
57556: PUSH
57557: LD_EXP 116
57561: PUSH
57562: LD_VAR 0 2
57566: ARRAY
57567: AND
57568: IFFALSE 57605
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
57570: LD_EXP 116
57574: PUSH
57575: LD_VAR 0 2
57579: ARRAY
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: PPUSH
57585: CALL_OW 255
57589: PPUSH
57590: LD_EXP 115
57594: PUSH
57595: LD_VAR 0 2
57599: ARRAY
57600: PPUSH
57601: CALL 72332 0 2
57605: GO 57543
57607: POP
57608: POP
// end ;
57609: LD_VAR 0 1
57613: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
57614: LD_INT 0
57616: PPUSH
57617: PPUSH
57618: PPUSH
57619: PPUSH
57620: PPUSH
57621: PPUSH
57622: PPUSH
57623: PPUSH
// if not mc_bases or not mc_parking then
57624: LD_EXP 102
57628: NOT
57629: PUSH
57630: LD_EXP 126
57634: NOT
57635: OR
57636: IFFALSE 57640
// exit ;
57638: GO 58378
// for i = 1 to mc_bases do
57640: LD_ADDR_VAR 0 2
57644: PUSH
57645: DOUBLE
57646: LD_INT 1
57648: DEC
57649: ST_TO_ADDR
57650: LD_EXP 102
57654: PUSH
57655: FOR_TO
57656: IFFALSE 58376
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
57658: LD_EXP 102
57662: PUSH
57663: LD_VAR 0 2
57667: ARRAY
57668: NOT
57669: PUSH
57670: LD_EXP 126
57674: PUSH
57675: LD_VAR 0 2
57679: ARRAY
57680: NOT
57681: OR
57682: IFFALSE 57686
// continue ;
57684: GO 57655
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
57686: LD_ADDR_VAR 0 5
57690: PUSH
57691: LD_EXP 102
57695: PUSH
57696: LD_VAR 0 2
57700: ARRAY
57701: PUSH
57702: LD_INT 1
57704: ARRAY
57705: PPUSH
57706: CALL_OW 255
57710: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57711: LD_ADDR_VAR 0 6
57715: PUSH
57716: LD_EXP 102
57720: PUSH
57721: LD_VAR 0 2
57725: ARRAY
57726: PPUSH
57727: LD_INT 30
57729: PUSH
57730: LD_INT 3
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: PPUSH
57737: CALL_OW 72
57741: ST_TO_ADDR
// if not fac then
57742: LD_VAR 0 6
57746: NOT
57747: IFFALSE 57798
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57749: LD_ADDR_VAR 0 6
57753: PUSH
57754: LD_EXP 102
57758: PUSH
57759: LD_VAR 0 2
57763: ARRAY
57764: PPUSH
57765: LD_INT 2
57767: PUSH
57768: LD_INT 30
57770: PUSH
57771: LD_INT 0
57773: PUSH
57774: EMPTY
57775: LIST
57776: LIST
57777: PUSH
57778: LD_INT 30
57780: PUSH
57781: LD_INT 1
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: PUSH
57788: EMPTY
57789: LIST
57790: LIST
57791: LIST
57792: PPUSH
57793: CALL_OW 72
57797: ST_TO_ADDR
// if not fac then
57798: LD_VAR 0 6
57802: NOT
57803: IFFALSE 57807
// continue ;
57805: GO 57655
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57807: LD_ADDR_VAR 0 7
57811: PUSH
57812: LD_EXP 126
57816: PUSH
57817: LD_VAR 0 2
57821: ARRAY
57822: PPUSH
57823: LD_INT 22
57825: PUSH
57826: LD_VAR 0 5
57830: PUSH
57831: EMPTY
57832: LIST
57833: LIST
57834: PUSH
57835: LD_INT 21
57837: PUSH
57838: LD_INT 2
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: LD_INT 3
57847: PUSH
57848: LD_INT 60
57850: PUSH
57851: EMPTY
57852: LIST
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: LD_INT 3
57860: PUSH
57861: LD_INT 24
57863: PUSH
57864: LD_INT 1000
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: PUSH
57875: EMPTY
57876: LIST
57877: LIST
57878: LIST
57879: LIST
57880: PPUSH
57881: CALL_OW 70
57885: ST_TO_ADDR
// for j in fac do
57886: LD_ADDR_VAR 0 3
57890: PUSH
57891: LD_VAR 0 6
57895: PUSH
57896: FOR_IN
57897: IFFALSE 57992
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57899: LD_ADDR_VAR 0 7
57903: PUSH
57904: LD_VAR 0 7
57908: PUSH
57909: LD_INT 22
57911: PUSH
57912: LD_VAR 0 5
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PUSH
57921: LD_INT 91
57923: PUSH
57924: LD_VAR 0 3
57928: PUSH
57929: LD_INT 15
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: LIST
57936: PUSH
57937: LD_INT 21
57939: PUSH
57940: LD_INT 2
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: PUSH
57947: LD_INT 3
57949: PUSH
57950: LD_INT 60
57952: PUSH
57953: EMPTY
57954: LIST
57955: PUSH
57956: EMPTY
57957: LIST
57958: LIST
57959: PUSH
57960: LD_INT 3
57962: PUSH
57963: LD_INT 24
57965: PUSH
57966: LD_INT 1000
57968: PUSH
57969: EMPTY
57970: LIST
57971: LIST
57972: PUSH
57973: EMPTY
57974: LIST
57975: LIST
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: LIST
57981: LIST
57982: LIST
57983: PPUSH
57984: CALL_OW 69
57988: UNION
57989: ST_TO_ADDR
57990: GO 57896
57992: POP
57993: POP
// if not vehs then
57994: LD_VAR 0 7
57998: NOT
57999: IFFALSE 58025
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58001: LD_ADDR_EXP 114
58005: PUSH
58006: LD_EXP 114
58010: PPUSH
58011: LD_VAR 0 2
58015: PPUSH
58016: EMPTY
58017: PPUSH
58018: CALL_OW 1
58022: ST_TO_ADDR
// continue ;
58023: GO 57655
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58025: LD_ADDR_VAR 0 8
58029: PUSH
58030: LD_EXP 102
58034: PUSH
58035: LD_VAR 0 2
58039: ARRAY
58040: PPUSH
58041: LD_INT 30
58043: PUSH
58044: LD_INT 3
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: PPUSH
58051: CALL_OW 72
58055: ST_TO_ADDR
// if tmp then
58056: LD_VAR 0 8
58060: IFFALSE 58163
// begin for j in tmp do
58062: LD_ADDR_VAR 0 3
58066: PUSH
58067: LD_VAR 0 8
58071: PUSH
58072: FOR_IN
58073: IFFALSE 58161
// for k in UnitsInside ( j ) do
58075: LD_ADDR_VAR 0 4
58079: PUSH
58080: LD_VAR 0 3
58084: PPUSH
58085: CALL_OW 313
58089: PUSH
58090: FOR_IN
58091: IFFALSE 58157
// if k then
58093: LD_VAR 0 4
58097: IFFALSE 58155
// if not k in mc_repair_vehicle [ i ] then
58099: LD_VAR 0 4
58103: PUSH
58104: LD_EXP 114
58108: PUSH
58109: LD_VAR 0 2
58113: ARRAY
58114: IN
58115: NOT
58116: IFFALSE 58155
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58118: LD_ADDR_EXP 114
58122: PUSH
58123: LD_EXP 114
58127: PPUSH
58128: LD_VAR 0 2
58132: PPUSH
58133: LD_EXP 114
58137: PUSH
58138: LD_VAR 0 2
58142: ARRAY
58143: PUSH
58144: LD_VAR 0 4
58148: UNION
58149: PPUSH
58150: CALL_OW 1
58154: ST_TO_ADDR
58155: GO 58090
58157: POP
58158: POP
58159: GO 58072
58161: POP
58162: POP
// end ; if not mc_repair_vehicle [ i ] then
58163: LD_EXP 114
58167: PUSH
58168: LD_VAR 0 2
58172: ARRAY
58173: NOT
58174: IFFALSE 58178
// continue ;
58176: GO 57655
// for j in mc_repair_vehicle [ i ] do
58178: LD_ADDR_VAR 0 3
58182: PUSH
58183: LD_EXP 114
58187: PUSH
58188: LD_VAR 0 2
58192: ARRAY
58193: PUSH
58194: FOR_IN
58195: IFFALSE 58372
// begin if GetClass ( j ) <> 3 then
58197: LD_VAR 0 3
58201: PPUSH
58202: CALL_OW 257
58206: PUSH
58207: LD_INT 3
58209: NONEQUAL
58210: IFFALSE 58251
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58212: LD_ADDR_EXP 114
58216: PUSH
58217: LD_EXP 114
58221: PPUSH
58222: LD_VAR 0 2
58226: PPUSH
58227: LD_EXP 114
58231: PUSH
58232: LD_VAR 0 2
58236: ARRAY
58237: PUSH
58238: LD_VAR 0 3
58242: DIFF
58243: PPUSH
58244: CALL_OW 1
58248: ST_TO_ADDR
// continue ;
58249: GO 58194
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58251: LD_VAR 0 3
58255: PPUSH
58256: CALL_OW 311
58260: NOT
58261: PUSH
58262: LD_VAR 0 3
58266: PUSH
58267: LD_EXP 105
58271: PUSH
58272: LD_VAR 0 2
58276: ARRAY
58277: PUSH
58278: LD_INT 1
58280: ARRAY
58281: IN
58282: NOT
58283: AND
58284: PUSH
58285: LD_VAR 0 3
58289: PUSH
58290: LD_EXP 105
58294: PUSH
58295: LD_VAR 0 2
58299: ARRAY
58300: PUSH
58301: LD_INT 2
58303: ARRAY
58304: IN
58305: NOT
58306: AND
58307: IFFALSE 58370
// begin if IsInUnit ( j ) then
58309: LD_VAR 0 3
58313: PPUSH
58314: CALL_OW 310
58318: IFFALSE 58331
// ComExitBuilding ( j ) else
58320: LD_VAR 0 3
58324: PPUSH
58325: CALL_OW 122
58329: GO 58370
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58331: LD_VAR 0 3
58335: PPUSH
58336: LD_VAR 0 7
58340: PUSH
58341: LD_INT 1
58343: ARRAY
58344: PPUSH
58345: CALL 110169 0 2
58349: NOT
58350: IFFALSE 58370
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58352: LD_VAR 0 3
58356: PPUSH
58357: LD_VAR 0 7
58361: PUSH
58362: LD_INT 1
58364: ARRAY
58365: PPUSH
58366: CALL_OW 129
// end ; end ;
58370: GO 58194
58372: POP
58373: POP
// end ;
58374: GO 57655
58376: POP
58377: POP
// end ;
58378: LD_VAR 0 1
58382: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58383: LD_INT 0
58385: PPUSH
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
58390: PPUSH
58391: PPUSH
58392: PPUSH
58393: PPUSH
58394: PPUSH
58395: PPUSH
// if not mc_bases then
58396: LD_EXP 102
58400: NOT
58401: IFFALSE 58405
// exit ;
58403: GO 59207
// for i = 1 to mc_bases do
58405: LD_ADDR_VAR 0 2
58409: PUSH
58410: DOUBLE
58411: LD_INT 1
58413: DEC
58414: ST_TO_ADDR
58415: LD_EXP 102
58419: PUSH
58420: FOR_TO
58421: IFFALSE 59205
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58423: LD_EXP 130
58427: PUSH
58428: LD_VAR 0 2
58432: ARRAY
58433: NOT
58434: PUSH
58435: LD_EXP 105
58439: PUSH
58440: LD_VAR 0 2
58444: ARRAY
58445: PUSH
58446: LD_INT 1
58448: ARRAY
58449: OR
58450: PUSH
58451: LD_EXP 105
58455: PUSH
58456: LD_VAR 0 2
58460: ARRAY
58461: PUSH
58462: LD_INT 2
58464: ARRAY
58465: OR
58466: PUSH
58467: LD_EXP 128
58471: PUSH
58472: LD_VAR 0 2
58476: ARRAY
58477: PPUSH
58478: LD_INT 1
58480: PPUSH
58481: CALL_OW 325
58485: NOT
58486: OR
58487: PUSH
58488: LD_EXP 125
58492: PUSH
58493: LD_VAR 0 2
58497: ARRAY
58498: OR
58499: IFFALSE 58503
// continue ;
58501: GO 58420
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58503: LD_ADDR_VAR 0 8
58507: PUSH
58508: LD_EXP 102
58512: PUSH
58513: LD_VAR 0 2
58517: ARRAY
58518: PPUSH
58519: LD_INT 25
58521: PUSH
58522: LD_INT 4
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: PUSH
58529: LD_INT 50
58531: PUSH
58532: EMPTY
58533: LIST
58534: PUSH
58535: LD_INT 3
58537: PUSH
58538: LD_INT 60
58540: PUSH
58541: EMPTY
58542: LIST
58543: PUSH
58544: EMPTY
58545: LIST
58546: LIST
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: LIST
58552: PPUSH
58553: CALL_OW 72
58557: PUSH
58558: LD_EXP 106
58562: PUSH
58563: LD_VAR 0 2
58567: ARRAY
58568: DIFF
58569: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58570: LD_ADDR_VAR 0 9
58574: PUSH
58575: LD_EXP 102
58579: PUSH
58580: LD_VAR 0 2
58584: ARRAY
58585: PPUSH
58586: LD_INT 2
58588: PUSH
58589: LD_INT 30
58591: PUSH
58592: LD_INT 0
58594: PUSH
58595: EMPTY
58596: LIST
58597: LIST
58598: PUSH
58599: LD_INT 30
58601: PUSH
58602: LD_INT 1
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: PUSH
58609: EMPTY
58610: LIST
58611: LIST
58612: LIST
58613: PPUSH
58614: CALL_OW 72
58618: ST_TO_ADDR
// if not tmp or not dep then
58619: LD_VAR 0 8
58623: NOT
58624: PUSH
58625: LD_VAR 0 9
58629: NOT
58630: OR
58631: IFFALSE 58635
// continue ;
58633: GO 58420
// side := GetSide ( tmp [ 1 ] ) ;
58635: LD_ADDR_VAR 0 11
58639: PUSH
58640: LD_VAR 0 8
58644: PUSH
58645: LD_INT 1
58647: ARRAY
58648: PPUSH
58649: CALL_OW 255
58653: ST_TO_ADDR
// dep := dep [ 1 ] ;
58654: LD_ADDR_VAR 0 9
58658: PUSH
58659: LD_VAR 0 9
58663: PUSH
58664: LD_INT 1
58666: ARRAY
58667: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
58668: LD_ADDR_VAR 0 7
58672: PUSH
58673: LD_EXP 130
58677: PUSH
58678: LD_VAR 0 2
58682: ARRAY
58683: PPUSH
58684: LD_INT 22
58686: PUSH
58687: LD_INT 0
58689: PUSH
58690: EMPTY
58691: LIST
58692: LIST
58693: PUSH
58694: LD_INT 25
58696: PUSH
58697: LD_INT 12
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: PPUSH
58708: CALL_OW 70
58712: PUSH
58713: LD_INT 22
58715: PUSH
58716: LD_INT 0
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: PUSH
58723: LD_INT 25
58725: PUSH
58726: LD_INT 12
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: PUSH
58733: LD_INT 91
58735: PUSH
58736: LD_VAR 0 9
58740: PUSH
58741: LD_INT 20
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: LIST
58748: PUSH
58749: EMPTY
58750: LIST
58751: LIST
58752: LIST
58753: PPUSH
58754: CALL_OW 69
58758: UNION
58759: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
58760: LD_ADDR_VAR 0 10
58764: PUSH
58765: LD_EXP 130
58769: PUSH
58770: LD_VAR 0 2
58774: ARRAY
58775: PPUSH
58776: LD_INT 81
58778: PUSH
58779: LD_VAR 0 11
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PPUSH
58788: CALL_OW 70
58792: ST_TO_ADDR
// if not apes or danger_at_area then
58793: LD_VAR 0 7
58797: NOT
58798: PUSH
58799: LD_VAR 0 10
58803: OR
58804: IFFALSE 58854
// begin if mc_taming [ i ] then
58806: LD_EXP 133
58810: PUSH
58811: LD_VAR 0 2
58815: ARRAY
58816: IFFALSE 58852
// begin MC_Reset ( i , 121 ) ;
58818: LD_VAR 0 2
58822: PPUSH
58823: LD_INT 121
58825: PPUSH
58826: CALL 43770 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58830: LD_ADDR_EXP 133
58834: PUSH
58835: LD_EXP 133
58839: PPUSH
58840: LD_VAR 0 2
58844: PPUSH
58845: EMPTY
58846: PPUSH
58847: CALL_OW 1
58851: ST_TO_ADDR
// end ; continue ;
58852: GO 58420
// end ; for j in tmp do
58854: LD_ADDR_VAR 0 3
58858: PUSH
58859: LD_VAR 0 8
58863: PUSH
58864: FOR_IN
58865: IFFALSE 59201
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58867: LD_VAR 0 3
58871: PUSH
58872: LD_EXP 133
58876: PUSH
58877: LD_VAR 0 2
58881: ARRAY
58882: IN
58883: NOT
58884: PUSH
58885: LD_EXP 133
58889: PUSH
58890: LD_VAR 0 2
58894: ARRAY
58895: PUSH
58896: LD_INT 3
58898: LESS
58899: AND
58900: IFFALSE 58958
// begin SetTag ( j , 121 ) ;
58902: LD_VAR 0 3
58906: PPUSH
58907: LD_INT 121
58909: PPUSH
58910: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58914: LD_ADDR_EXP 133
58918: PUSH
58919: LD_EXP 133
58923: PPUSH
58924: LD_VAR 0 2
58928: PUSH
58929: LD_EXP 133
58933: PUSH
58934: LD_VAR 0 2
58938: ARRAY
58939: PUSH
58940: LD_INT 1
58942: PLUS
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: PPUSH
58948: LD_VAR 0 3
58952: PPUSH
58953: CALL 75355 0 3
58957: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58958: LD_VAR 0 3
58962: PUSH
58963: LD_EXP 133
58967: PUSH
58968: LD_VAR 0 2
58972: ARRAY
58973: IN
58974: IFFALSE 59199
// begin if GetClass ( j ) <> 4 then
58976: LD_VAR 0 3
58980: PPUSH
58981: CALL_OW 257
58985: PUSH
58986: LD_INT 4
58988: NONEQUAL
58989: IFFALSE 59042
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58991: LD_ADDR_EXP 133
58995: PUSH
58996: LD_EXP 133
59000: PPUSH
59001: LD_VAR 0 2
59005: PPUSH
59006: LD_EXP 133
59010: PUSH
59011: LD_VAR 0 2
59015: ARRAY
59016: PUSH
59017: LD_VAR 0 3
59021: DIFF
59022: PPUSH
59023: CALL_OW 1
59027: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59028: LD_VAR 0 3
59032: PPUSH
59033: LD_INT 0
59035: PPUSH
59036: CALL_OW 109
// continue ;
59040: GO 58864
// end ; if IsInUnit ( j ) then
59042: LD_VAR 0 3
59046: PPUSH
59047: CALL_OW 310
59051: IFFALSE 59062
// ComExitBuilding ( j ) ;
59053: LD_VAR 0 3
59057: PPUSH
59058: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59062: LD_ADDR_VAR 0 6
59066: PUSH
59067: LD_VAR 0 7
59071: PPUSH
59072: LD_VAR 0 3
59076: PPUSH
59077: CALL_OW 74
59081: ST_TO_ADDR
// if not ape then
59082: LD_VAR 0 6
59086: NOT
59087: IFFALSE 59091
// break ;
59089: GO 59201
// x := GetX ( ape ) ;
59091: LD_ADDR_VAR 0 4
59095: PUSH
59096: LD_VAR 0 6
59100: PPUSH
59101: CALL_OW 250
59105: ST_TO_ADDR
// y := GetY ( ape ) ;
59106: LD_ADDR_VAR 0 5
59110: PUSH
59111: LD_VAR 0 6
59115: PPUSH
59116: CALL_OW 251
59120: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59121: LD_VAR 0 4
59125: PPUSH
59126: LD_VAR 0 5
59130: PPUSH
59131: CALL_OW 488
59135: NOT
59136: PUSH
59137: LD_VAR 0 11
59141: PPUSH
59142: LD_VAR 0 4
59146: PPUSH
59147: LD_VAR 0 5
59151: PPUSH
59152: LD_INT 20
59154: PPUSH
59155: CALL 76619 0 4
59159: PUSH
59160: LD_INT 4
59162: ARRAY
59163: OR
59164: IFFALSE 59168
// break ;
59166: GO 59201
// if not HasTask ( j ) then
59168: LD_VAR 0 3
59172: PPUSH
59173: CALL_OW 314
59177: NOT
59178: IFFALSE 59199
// ComTameXY ( j , x , y ) ;
59180: LD_VAR 0 3
59184: PPUSH
59185: LD_VAR 0 4
59189: PPUSH
59190: LD_VAR 0 5
59194: PPUSH
59195: CALL_OW 131
// end ; end ;
59199: GO 58864
59201: POP
59202: POP
// end ;
59203: GO 58420
59205: POP
59206: POP
// end ;
59207: LD_VAR 0 1
59211: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59212: LD_INT 0
59214: PPUSH
59215: PPUSH
59216: PPUSH
59217: PPUSH
59218: PPUSH
59219: PPUSH
59220: PPUSH
59221: PPUSH
// if not mc_bases then
59222: LD_EXP 102
59226: NOT
59227: IFFALSE 59231
// exit ;
59229: GO 59857
// for i = 1 to mc_bases do
59231: LD_ADDR_VAR 0 2
59235: PUSH
59236: DOUBLE
59237: LD_INT 1
59239: DEC
59240: ST_TO_ADDR
59241: LD_EXP 102
59245: PUSH
59246: FOR_TO
59247: IFFALSE 59855
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59249: LD_EXP 131
59253: PUSH
59254: LD_VAR 0 2
59258: ARRAY
59259: NOT
59260: PUSH
59261: LD_EXP 131
59265: PUSH
59266: LD_VAR 0 2
59270: ARRAY
59271: PPUSH
59272: LD_INT 25
59274: PUSH
59275: LD_INT 12
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: PPUSH
59282: CALL_OW 72
59286: NOT
59287: OR
59288: IFFALSE 59292
// continue ;
59290: GO 59246
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59292: LD_ADDR_VAR 0 5
59296: PUSH
59297: LD_EXP 131
59301: PUSH
59302: LD_VAR 0 2
59306: ARRAY
59307: PUSH
59308: LD_INT 1
59310: ARRAY
59311: PPUSH
59312: CALL_OW 255
59316: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59317: LD_VAR 0 5
59321: PPUSH
59322: LD_INT 2
59324: PPUSH
59325: CALL_OW 325
59329: IFFALSE 59582
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59331: LD_ADDR_VAR 0 4
59335: PUSH
59336: LD_EXP 131
59340: PUSH
59341: LD_VAR 0 2
59345: ARRAY
59346: PPUSH
59347: LD_INT 25
59349: PUSH
59350: LD_INT 16
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PPUSH
59357: CALL_OW 72
59361: ST_TO_ADDR
// if tmp < 6 then
59362: LD_VAR 0 4
59366: PUSH
59367: LD_INT 6
59369: LESS
59370: IFFALSE 59582
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59372: LD_ADDR_VAR 0 6
59376: PUSH
59377: LD_EXP 102
59381: PUSH
59382: LD_VAR 0 2
59386: ARRAY
59387: PPUSH
59388: LD_INT 2
59390: PUSH
59391: LD_INT 30
59393: PUSH
59394: LD_INT 0
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: PUSH
59401: LD_INT 30
59403: PUSH
59404: LD_INT 1
59406: PUSH
59407: EMPTY
59408: LIST
59409: LIST
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: LIST
59415: PPUSH
59416: CALL_OW 72
59420: ST_TO_ADDR
// if depot then
59421: LD_VAR 0 6
59425: IFFALSE 59582
// begin selected := 0 ;
59427: LD_ADDR_VAR 0 7
59431: PUSH
59432: LD_INT 0
59434: ST_TO_ADDR
// for j in depot do
59435: LD_ADDR_VAR 0 3
59439: PUSH
59440: LD_VAR 0 6
59444: PUSH
59445: FOR_IN
59446: IFFALSE 59477
// begin if UnitsInside ( j ) < 6 then
59448: LD_VAR 0 3
59452: PPUSH
59453: CALL_OW 313
59457: PUSH
59458: LD_INT 6
59460: LESS
59461: IFFALSE 59475
// begin selected := j ;
59463: LD_ADDR_VAR 0 7
59467: PUSH
59468: LD_VAR 0 3
59472: ST_TO_ADDR
// break ;
59473: GO 59477
// end ; end ;
59475: GO 59445
59477: POP
59478: POP
// if selected then
59479: LD_VAR 0 7
59483: IFFALSE 59582
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59485: LD_ADDR_VAR 0 3
59489: PUSH
59490: LD_EXP 131
59494: PUSH
59495: LD_VAR 0 2
59499: ARRAY
59500: PPUSH
59501: LD_INT 25
59503: PUSH
59504: LD_INT 12
59506: PUSH
59507: EMPTY
59508: LIST
59509: LIST
59510: PPUSH
59511: CALL_OW 72
59515: PUSH
59516: FOR_IN
59517: IFFALSE 59580
// if not HasTask ( j ) then
59519: LD_VAR 0 3
59523: PPUSH
59524: CALL_OW 314
59528: NOT
59529: IFFALSE 59578
// begin if not IsInUnit ( j ) then
59531: LD_VAR 0 3
59535: PPUSH
59536: CALL_OW 310
59540: NOT
59541: IFFALSE 59557
// ComEnterUnit ( j , selected ) ;
59543: LD_VAR 0 3
59547: PPUSH
59548: LD_VAR 0 7
59552: PPUSH
59553: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
59557: LD_VAR 0 3
59561: PPUSH
59562: LD_INT 16
59564: PPUSH
59565: CALL_OW 183
// AddComExitBuilding ( j ) ;
59569: LD_VAR 0 3
59573: PPUSH
59574: CALL_OW 182
// end ;
59578: GO 59516
59580: POP
59581: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
59582: LD_VAR 0 5
59586: PPUSH
59587: LD_INT 11
59589: PPUSH
59590: CALL_OW 325
59594: IFFALSE 59853
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59596: LD_ADDR_VAR 0 4
59600: PUSH
59601: LD_EXP 131
59605: PUSH
59606: LD_VAR 0 2
59610: ARRAY
59611: PPUSH
59612: LD_INT 25
59614: PUSH
59615: LD_INT 16
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PPUSH
59622: CALL_OW 72
59626: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
59627: LD_VAR 0 4
59631: PUSH
59632: LD_INT 6
59634: GREATEREQUAL
59635: PUSH
59636: LD_VAR 0 5
59640: PPUSH
59641: LD_INT 2
59643: PPUSH
59644: CALL_OW 325
59648: NOT
59649: OR
59650: IFFALSE 59853
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59652: LD_ADDR_VAR 0 8
59656: PUSH
59657: LD_EXP 102
59661: PUSH
59662: LD_VAR 0 2
59666: ARRAY
59667: PPUSH
59668: LD_INT 2
59670: PUSH
59671: LD_INT 30
59673: PUSH
59674: LD_INT 4
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PUSH
59681: LD_INT 30
59683: PUSH
59684: LD_INT 5
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: LIST
59695: PPUSH
59696: CALL_OW 72
59700: ST_TO_ADDR
// if barracks then
59701: LD_VAR 0 8
59705: IFFALSE 59853
// begin selected := 0 ;
59707: LD_ADDR_VAR 0 7
59711: PUSH
59712: LD_INT 0
59714: ST_TO_ADDR
// for j in barracks do
59715: LD_ADDR_VAR 0 3
59719: PUSH
59720: LD_VAR 0 8
59724: PUSH
59725: FOR_IN
59726: IFFALSE 59757
// begin if UnitsInside ( j ) < 6 then
59728: LD_VAR 0 3
59732: PPUSH
59733: CALL_OW 313
59737: PUSH
59738: LD_INT 6
59740: LESS
59741: IFFALSE 59755
// begin selected := j ;
59743: LD_ADDR_VAR 0 7
59747: PUSH
59748: LD_VAR 0 3
59752: ST_TO_ADDR
// break ;
59753: GO 59757
// end ; end ;
59755: GO 59725
59757: POP
59758: POP
// if selected then
59759: LD_VAR 0 7
59763: IFFALSE 59853
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59765: LD_ADDR_VAR 0 3
59769: PUSH
59770: LD_EXP 131
59774: PUSH
59775: LD_VAR 0 2
59779: ARRAY
59780: PPUSH
59781: LD_INT 25
59783: PUSH
59784: LD_INT 12
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: PPUSH
59791: CALL_OW 72
59795: PUSH
59796: FOR_IN
59797: IFFALSE 59851
// if not IsInUnit ( j ) and not HasTask ( j ) then
59799: LD_VAR 0 3
59803: PPUSH
59804: CALL_OW 310
59808: NOT
59809: PUSH
59810: LD_VAR 0 3
59814: PPUSH
59815: CALL_OW 314
59819: NOT
59820: AND
59821: IFFALSE 59849
// begin ComEnterUnit ( j , selected ) ;
59823: LD_VAR 0 3
59827: PPUSH
59828: LD_VAR 0 7
59832: PPUSH
59833: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59837: LD_VAR 0 3
59841: PPUSH
59842: LD_INT 15
59844: PPUSH
59845: CALL_OW 183
// end ;
59849: GO 59796
59851: POP
59852: POP
// end ; end ; end ; end ; end ;
59853: GO 59246
59855: POP
59856: POP
// end ;
59857: LD_VAR 0 1
59861: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59862: LD_INT 0
59864: PPUSH
59865: PPUSH
59866: PPUSH
59867: PPUSH
// if not mc_bases then
59868: LD_EXP 102
59872: NOT
59873: IFFALSE 59877
// exit ;
59875: GO 60055
// for i = 1 to mc_bases do
59877: LD_ADDR_VAR 0 2
59881: PUSH
59882: DOUBLE
59883: LD_INT 1
59885: DEC
59886: ST_TO_ADDR
59887: LD_EXP 102
59891: PUSH
59892: FOR_TO
59893: IFFALSE 60053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59895: LD_ADDR_VAR 0 4
59899: PUSH
59900: LD_EXP 102
59904: PUSH
59905: LD_VAR 0 2
59909: ARRAY
59910: PPUSH
59911: LD_INT 25
59913: PUSH
59914: LD_INT 9
59916: PUSH
59917: EMPTY
59918: LIST
59919: LIST
59920: PPUSH
59921: CALL_OW 72
59925: ST_TO_ADDR
// if not tmp then
59926: LD_VAR 0 4
59930: NOT
59931: IFFALSE 59935
// continue ;
59933: GO 59892
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59935: LD_EXP 128
59939: PUSH
59940: LD_VAR 0 2
59944: ARRAY
59945: PPUSH
59946: LD_INT 29
59948: PPUSH
59949: CALL_OW 325
59953: NOT
59954: PUSH
59955: LD_EXP 128
59959: PUSH
59960: LD_VAR 0 2
59964: ARRAY
59965: PPUSH
59966: LD_INT 28
59968: PPUSH
59969: CALL_OW 325
59973: NOT
59974: AND
59975: IFFALSE 59979
// continue ;
59977: GO 59892
// for j in tmp do
59979: LD_ADDR_VAR 0 3
59983: PUSH
59984: LD_VAR 0 4
59988: PUSH
59989: FOR_IN
59990: IFFALSE 60049
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59992: LD_VAR 0 3
59996: PUSH
59997: LD_EXP 105
60001: PUSH
60002: LD_VAR 0 2
60006: ARRAY
60007: PUSH
60008: LD_INT 1
60010: ARRAY
60011: IN
60012: NOT
60013: PUSH
60014: LD_VAR 0 3
60018: PUSH
60019: LD_EXP 105
60023: PUSH
60024: LD_VAR 0 2
60028: ARRAY
60029: PUSH
60030: LD_INT 2
60032: ARRAY
60033: IN
60034: NOT
60035: AND
60036: IFFALSE 60047
// ComSpaceTimeShoot ( j ) ;
60038: LD_VAR 0 3
60042: PPUSH
60043: CALL 71340 0 1
60047: GO 59989
60049: POP
60050: POP
// end ;
60051: GO 59892
60053: POP
60054: POP
// end ;
60055: LD_VAR 0 1
60059: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60060: LD_INT 0
60062: PPUSH
60063: PPUSH
60064: PPUSH
60065: PPUSH
60066: PPUSH
60067: PPUSH
60068: PPUSH
60069: PPUSH
60070: PPUSH
// if not mc_bases then
60071: LD_EXP 102
60075: NOT
60076: IFFALSE 60080
// exit ;
60078: GO 60702
// for i = 1 to mc_bases do
60080: LD_ADDR_VAR 0 2
60084: PUSH
60085: DOUBLE
60086: LD_INT 1
60088: DEC
60089: ST_TO_ADDR
60090: LD_EXP 102
60094: PUSH
60095: FOR_TO
60096: IFFALSE 60700
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60098: LD_EXP 137
60102: PUSH
60103: LD_VAR 0 2
60107: ARRAY
60108: NOT
60109: PUSH
60110: LD_INT 38
60112: PPUSH
60113: LD_EXP 128
60117: PUSH
60118: LD_VAR 0 2
60122: ARRAY
60123: PPUSH
60124: CALL_OW 321
60128: PUSH
60129: LD_INT 2
60131: NONEQUAL
60132: OR
60133: IFFALSE 60137
// continue ;
60135: GO 60095
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60137: LD_ADDR_VAR 0 8
60141: PUSH
60142: LD_EXP 102
60146: PUSH
60147: LD_VAR 0 2
60151: ARRAY
60152: PPUSH
60153: LD_INT 30
60155: PUSH
60156: LD_INT 34
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: PPUSH
60163: CALL_OW 72
60167: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60168: LD_ADDR_VAR 0 9
60172: PUSH
60173: LD_EXP 102
60177: PUSH
60178: LD_VAR 0 2
60182: ARRAY
60183: PPUSH
60184: LD_INT 25
60186: PUSH
60187: LD_INT 4
60189: PUSH
60190: EMPTY
60191: LIST
60192: LIST
60193: PPUSH
60194: CALL_OW 72
60198: PPUSH
60199: LD_INT 0
60201: PPUSH
60202: CALL 105673 0 2
60206: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60207: LD_VAR 0 9
60211: NOT
60212: PUSH
60213: LD_VAR 0 8
60217: NOT
60218: OR
60219: PUSH
60220: LD_EXP 102
60224: PUSH
60225: LD_VAR 0 2
60229: ARRAY
60230: PPUSH
60231: LD_INT 124
60233: PPUSH
60234: CALL 105673 0 2
60238: OR
60239: IFFALSE 60243
// continue ;
60241: GO 60095
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60243: LD_EXP 138
60247: PUSH
60248: LD_VAR 0 2
60252: ARRAY
60253: PUSH
60254: LD_EXP 137
60258: PUSH
60259: LD_VAR 0 2
60263: ARRAY
60264: LESS
60265: PUSH
60266: LD_EXP 138
60270: PUSH
60271: LD_VAR 0 2
60275: ARRAY
60276: PUSH
60277: LD_VAR 0 8
60281: LESS
60282: AND
60283: IFFALSE 60698
// begin tmp := sci [ 1 ] ;
60285: LD_ADDR_VAR 0 7
60289: PUSH
60290: LD_VAR 0 9
60294: PUSH
60295: LD_INT 1
60297: ARRAY
60298: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60299: LD_VAR 0 7
60303: PPUSH
60304: LD_INT 124
60306: PPUSH
60307: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60311: LD_ADDR_VAR 0 3
60315: PUSH
60316: DOUBLE
60317: LD_EXP 137
60321: PUSH
60322: LD_VAR 0 2
60326: ARRAY
60327: INC
60328: ST_TO_ADDR
60329: LD_EXP 137
60333: PUSH
60334: LD_VAR 0 2
60338: ARRAY
60339: PUSH
60340: FOR_DOWNTO
60341: IFFALSE 60684
// begin if IsInUnit ( tmp ) then
60343: LD_VAR 0 7
60347: PPUSH
60348: CALL_OW 310
60352: IFFALSE 60363
// ComExitBuilding ( tmp ) ;
60354: LD_VAR 0 7
60358: PPUSH
60359: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60363: LD_INT 35
60365: PPUSH
60366: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60370: LD_VAR 0 7
60374: PPUSH
60375: CALL_OW 310
60379: NOT
60380: PUSH
60381: LD_VAR 0 7
60385: PPUSH
60386: CALL_OW 314
60390: NOT
60391: AND
60392: IFFALSE 60363
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60394: LD_ADDR_VAR 0 6
60398: PUSH
60399: LD_VAR 0 7
60403: PPUSH
60404: CALL_OW 250
60408: PUSH
60409: LD_VAR 0 7
60413: PPUSH
60414: CALL_OW 251
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60423: LD_INT 35
60425: PPUSH
60426: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60430: LD_ADDR_VAR 0 4
60434: PUSH
60435: LD_EXP 137
60439: PUSH
60440: LD_VAR 0 2
60444: ARRAY
60445: PUSH
60446: LD_VAR 0 3
60450: ARRAY
60451: PUSH
60452: LD_INT 1
60454: ARRAY
60455: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60456: LD_ADDR_VAR 0 5
60460: PUSH
60461: LD_EXP 137
60465: PUSH
60466: LD_VAR 0 2
60470: ARRAY
60471: PUSH
60472: LD_VAR 0 3
60476: ARRAY
60477: PUSH
60478: LD_INT 2
60480: ARRAY
60481: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60482: LD_VAR 0 7
60486: PPUSH
60487: LD_INT 10
60489: PPUSH
60490: CALL 78320 0 2
60494: PUSH
60495: LD_INT 4
60497: ARRAY
60498: IFFALSE 60536
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60500: LD_VAR 0 7
60504: PPUSH
60505: LD_VAR 0 6
60509: PUSH
60510: LD_INT 1
60512: ARRAY
60513: PPUSH
60514: LD_VAR 0 6
60518: PUSH
60519: LD_INT 2
60521: ARRAY
60522: PPUSH
60523: CALL_OW 111
// wait ( 0 0$10 ) ;
60527: LD_INT 350
60529: PPUSH
60530: CALL_OW 67
// end else
60534: GO 60562
// begin ComMoveXY ( tmp , x , y ) ;
60536: LD_VAR 0 7
60540: PPUSH
60541: LD_VAR 0 4
60545: PPUSH
60546: LD_VAR 0 5
60550: PPUSH
60551: CALL_OW 111
// wait ( 0 0$3 ) ;
60555: LD_INT 105
60557: PPUSH
60558: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
60562: LD_VAR 0 7
60566: PPUSH
60567: LD_VAR 0 4
60571: PPUSH
60572: LD_VAR 0 5
60576: PPUSH
60577: CALL_OW 307
60581: IFFALSE 60423
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
60583: LD_VAR 0 7
60587: PPUSH
60588: LD_VAR 0 4
60592: PPUSH
60593: LD_VAR 0 5
60597: PPUSH
60598: LD_VAR 0 8
60602: PUSH
60603: LD_VAR 0 3
60607: ARRAY
60608: PPUSH
60609: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
60613: LD_INT 35
60615: PPUSH
60616: CALL_OW 67
// until not HasTask ( tmp ) ;
60620: LD_VAR 0 7
60624: PPUSH
60625: CALL_OW 314
60629: NOT
60630: IFFALSE 60613
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
60632: LD_ADDR_EXP 138
60636: PUSH
60637: LD_EXP 138
60641: PPUSH
60642: LD_VAR 0 2
60646: PUSH
60647: LD_EXP 138
60651: PUSH
60652: LD_VAR 0 2
60656: ARRAY
60657: PUSH
60658: LD_INT 1
60660: PLUS
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: PPUSH
60666: LD_VAR 0 8
60670: PUSH
60671: LD_VAR 0 3
60675: ARRAY
60676: PPUSH
60677: CALL 75355 0 3
60681: ST_TO_ADDR
// end ;
60682: GO 60340
60684: POP
60685: POP
// MC_Reset ( i , 124 ) ;
60686: LD_VAR 0 2
60690: PPUSH
60691: LD_INT 124
60693: PPUSH
60694: CALL 43770 0 2
// end ; end ;
60698: GO 60095
60700: POP
60701: POP
// end ;
60702: LD_VAR 0 1
60706: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
60707: LD_INT 0
60709: PPUSH
60710: PPUSH
60711: PPUSH
// if not mc_bases then
60712: LD_EXP 102
60716: NOT
60717: IFFALSE 60721
// exit ;
60719: GO 61327
// for i = 1 to mc_bases do
60721: LD_ADDR_VAR 0 2
60725: PUSH
60726: DOUBLE
60727: LD_INT 1
60729: DEC
60730: ST_TO_ADDR
60731: LD_EXP 102
60735: PUSH
60736: FOR_TO
60737: IFFALSE 61325
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60739: LD_ADDR_VAR 0 3
60743: PUSH
60744: LD_EXP 102
60748: PUSH
60749: LD_VAR 0 2
60753: ARRAY
60754: PPUSH
60755: LD_INT 25
60757: PUSH
60758: LD_INT 4
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PPUSH
60765: CALL_OW 72
60769: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60770: LD_VAR 0 3
60774: NOT
60775: PUSH
60776: LD_EXP 139
60780: PUSH
60781: LD_VAR 0 2
60785: ARRAY
60786: NOT
60787: OR
60788: PUSH
60789: LD_EXP 102
60793: PUSH
60794: LD_VAR 0 2
60798: ARRAY
60799: PPUSH
60800: LD_INT 2
60802: PUSH
60803: LD_INT 30
60805: PUSH
60806: LD_INT 0
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: PUSH
60813: LD_INT 30
60815: PUSH
60816: LD_INT 1
60818: PUSH
60819: EMPTY
60820: LIST
60821: LIST
60822: PUSH
60823: EMPTY
60824: LIST
60825: LIST
60826: LIST
60827: PPUSH
60828: CALL_OW 72
60832: NOT
60833: OR
60834: IFFALSE 60884
// begin if mc_deposits_finder [ i ] then
60836: LD_EXP 140
60840: PUSH
60841: LD_VAR 0 2
60845: ARRAY
60846: IFFALSE 60882
// begin MC_Reset ( i , 125 ) ;
60848: LD_VAR 0 2
60852: PPUSH
60853: LD_INT 125
60855: PPUSH
60856: CALL 43770 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60860: LD_ADDR_EXP 140
60864: PUSH
60865: LD_EXP 140
60869: PPUSH
60870: LD_VAR 0 2
60874: PPUSH
60875: EMPTY
60876: PPUSH
60877: CALL_OW 1
60881: ST_TO_ADDR
// end ; continue ;
60882: GO 60736
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60884: LD_EXP 139
60888: PUSH
60889: LD_VAR 0 2
60893: ARRAY
60894: PUSH
60895: LD_INT 1
60897: ARRAY
60898: PUSH
60899: LD_INT 3
60901: ARRAY
60902: PUSH
60903: LD_INT 1
60905: EQUAL
60906: PUSH
60907: LD_INT 20
60909: PPUSH
60910: LD_EXP 128
60914: PUSH
60915: LD_VAR 0 2
60919: ARRAY
60920: PPUSH
60921: CALL_OW 321
60925: PUSH
60926: LD_INT 2
60928: NONEQUAL
60929: AND
60930: IFFALSE 60980
// begin if mc_deposits_finder [ i ] then
60932: LD_EXP 140
60936: PUSH
60937: LD_VAR 0 2
60941: ARRAY
60942: IFFALSE 60978
// begin MC_Reset ( i , 125 ) ;
60944: LD_VAR 0 2
60948: PPUSH
60949: LD_INT 125
60951: PPUSH
60952: CALL 43770 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60956: LD_ADDR_EXP 140
60960: PUSH
60961: LD_EXP 140
60965: PPUSH
60966: LD_VAR 0 2
60970: PPUSH
60971: EMPTY
60972: PPUSH
60973: CALL_OW 1
60977: ST_TO_ADDR
// end ; continue ;
60978: GO 60736
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60980: LD_EXP 139
60984: PUSH
60985: LD_VAR 0 2
60989: ARRAY
60990: PUSH
60991: LD_INT 1
60993: ARRAY
60994: PUSH
60995: LD_INT 1
60997: ARRAY
60998: PPUSH
60999: LD_EXP 139
61003: PUSH
61004: LD_VAR 0 2
61008: ARRAY
61009: PUSH
61010: LD_INT 1
61012: ARRAY
61013: PUSH
61014: LD_INT 2
61016: ARRAY
61017: PPUSH
61018: LD_EXP 128
61022: PUSH
61023: LD_VAR 0 2
61027: ARRAY
61028: PPUSH
61029: CALL_OW 440
61033: IFFALSE 61076
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61035: LD_ADDR_EXP 139
61039: PUSH
61040: LD_EXP 139
61044: PPUSH
61045: LD_VAR 0 2
61049: PPUSH
61050: LD_EXP 139
61054: PUSH
61055: LD_VAR 0 2
61059: ARRAY
61060: PPUSH
61061: LD_INT 1
61063: PPUSH
61064: CALL_OW 3
61068: PPUSH
61069: CALL_OW 1
61073: ST_TO_ADDR
61074: GO 61323
// begin if not mc_deposits_finder [ i ] then
61076: LD_EXP 140
61080: PUSH
61081: LD_VAR 0 2
61085: ARRAY
61086: NOT
61087: IFFALSE 61139
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61089: LD_ADDR_EXP 140
61093: PUSH
61094: LD_EXP 140
61098: PPUSH
61099: LD_VAR 0 2
61103: PPUSH
61104: LD_VAR 0 3
61108: PUSH
61109: LD_INT 1
61111: ARRAY
61112: PUSH
61113: EMPTY
61114: LIST
61115: PPUSH
61116: CALL_OW 1
61120: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61121: LD_VAR 0 3
61125: PUSH
61126: LD_INT 1
61128: ARRAY
61129: PPUSH
61130: LD_INT 125
61132: PPUSH
61133: CALL_OW 109
// end else
61137: GO 61323
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61139: LD_EXP 140
61143: PUSH
61144: LD_VAR 0 2
61148: ARRAY
61149: PUSH
61150: LD_INT 1
61152: ARRAY
61153: PPUSH
61154: CALL_OW 310
61158: IFFALSE 61181
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61160: LD_EXP 140
61164: PUSH
61165: LD_VAR 0 2
61169: ARRAY
61170: PUSH
61171: LD_INT 1
61173: ARRAY
61174: PPUSH
61175: CALL_OW 122
61179: GO 61323
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61181: LD_EXP 140
61185: PUSH
61186: LD_VAR 0 2
61190: ARRAY
61191: PUSH
61192: LD_INT 1
61194: ARRAY
61195: PPUSH
61196: CALL_OW 314
61200: NOT
61201: PUSH
61202: LD_EXP 140
61206: PUSH
61207: LD_VAR 0 2
61211: ARRAY
61212: PUSH
61213: LD_INT 1
61215: ARRAY
61216: PPUSH
61217: LD_EXP 139
61221: PUSH
61222: LD_VAR 0 2
61226: ARRAY
61227: PUSH
61228: LD_INT 1
61230: ARRAY
61231: PUSH
61232: LD_INT 1
61234: ARRAY
61235: PPUSH
61236: LD_EXP 139
61240: PUSH
61241: LD_VAR 0 2
61245: ARRAY
61246: PUSH
61247: LD_INT 1
61249: ARRAY
61250: PUSH
61251: LD_INT 2
61253: ARRAY
61254: PPUSH
61255: CALL_OW 297
61259: PUSH
61260: LD_INT 6
61262: GREATER
61263: AND
61264: IFFALSE 61323
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61266: LD_EXP 140
61270: PUSH
61271: LD_VAR 0 2
61275: ARRAY
61276: PUSH
61277: LD_INT 1
61279: ARRAY
61280: PPUSH
61281: LD_EXP 139
61285: PUSH
61286: LD_VAR 0 2
61290: ARRAY
61291: PUSH
61292: LD_INT 1
61294: ARRAY
61295: PUSH
61296: LD_INT 1
61298: ARRAY
61299: PPUSH
61300: LD_EXP 139
61304: PUSH
61305: LD_VAR 0 2
61309: ARRAY
61310: PUSH
61311: LD_INT 1
61313: ARRAY
61314: PUSH
61315: LD_INT 2
61317: ARRAY
61318: PPUSH
61319: CALL_OW 111
// end ; end ; end ;
61323: GO 60736
61325: POP
61326: POP
// end ;
61327: LD_VAR 0 1
61331: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61332: LD_INT 0
61334: PPUSH
61335: PPUSH
61336: PPUSH
61337: PPUSH
61338: PPUSH
61339: PPUSH
61340: PPUSH
61341: PPUSH
61342: PPUSH
61343: PPUSH
61344: PPUSH
// if not mc_bases then
61345: LD_EXP 102
61349: NOT
61350: IFFALSE 61354
// exit ;
61352: GO 62294
// for i = 1 to mc_bases do
61354: LD_ADDR_VAR 0 2
61358: PUSH
61359: DOUBLE
61360: LD_INT 1
61362: DEC
61363: ST_TO_ADDR
61364: LD_EXP 102
61368: PUSH
61369: FOR_TO
61370: IFFALSE 62292
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61372: LD_EXP 102
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: NOT
61383: PUSH
61384: LD_EXP 125
61388: PUSH
61389: LD_VAR 0 2
61393: ARRAY
61394: OR
61395: IFFALSE 61399
// continue ;
61397: GO 61369
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61399: LD_ADDR_VAR 0 7
61403: PUSH
61404: LD_EXP 102
61408: PUSH
61409: LD_VAR 0 2
61413: ARRAY
61414: PUSH
61415: LD_INT 1
61417: ARRAY
61418: PPUSH
61419: CALL_OW 248
61423: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61424: LD_VAR 0 7
61428: PUSH
61429: LD_INT 3
61431: EQUAL
61432: PUSH
61433: LD_EXP 121
61437: PUSH
61438: LD_VAR 0 2
61442: ARRAY
61443: PUSH
61444: LD_EXP 124
61448: PUSH
61449: LD_VAR 0 2
61453: ARRAY
61454: UNION
61455: PPUSH
61456: LD_INT 33
61458: PUSH
61459: LD_INT 2
61461: PUSH
61462: EMPTY
61463: LIST
61464: LIST
61465: PPUSH
61466: CALL_OW 72
61470: NOT
61471: OR
61472: IFFALSE 61476
// continue ;
61474: GO 61369
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61476: LD_ADDR_VAR 0 9
61480: PUSH
61481: LD_EXP 102
61485: PUSH
61486: LD_VAR 0 2
61490: ARRAY
61491: PPUSH
61492: LD_INT 30
61494: PUSH
61495: LD_INT 36
61497: PUSH
61498: EMPTY
61499: LIST
61500: LIST
61501: PPUSH
61502: CALL_OW 72
61506: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
61507: LD_ADDR_VAR 0 10
61511: PUSH
61512: LD_EXP 121
61516: PUSH
61517: LD_VAR 0 2
61521: ARRAY
61522: PPUSH
61523: LD_INT 34
61525: PUSH
61526: LD_INT 31
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: PPUSH
61533: CALL_OW 72
61537: ST_TO_ADDR
// if not cts and not mcts then
61538: LD_VAR 0 9
61542: NOT
61543: PUSH
61544: LD_VAR 0 10
61548: NOT
61549: AND
61550: IFFALSE 61554
// continue ;
61552: GO 61369
// x := cts ;
61554: LD_ADDR_VAR 0 11
61558: PUSH
61559: LD_VAR 0 9
61563: ST_TO_ADDR
// if not x then
61564: LD_VAR 0 11
61568: NOT
61569: IFFALSE 61581
// x := mcts ;
61571: LD_ADDR_VAR 0 11
61575: PUSH
61576: LD_VAR 0 10
61580: ST_TO_ADDR
// if not x then
61581: LD_VAR 0 11
61585: NOT
61586: IFFALSE 61590
// continue ;
61588: GO 61369
// if mc_remote_driver [ i ] then
61590: LD_EXP 142
61594: PUSH
61595: LD_VAR 0 2
61599: ARRAY
61600: IFFALSE 61987
// for j in mc_remote_driver [ i ] do
61602: LD_ADDR_VAR 0 3
61606: PUSH
61607: LD_EXP 142
61611: PUSH
61612: LD_VAR 0 2
61616: ARRAY
61617: PUSH
61618: FOR_IN
61619: IFFALSE 61985
// begin if GetClass ( j ) <> 3 then
61621: LD_VAR 0 3
61625: PPUSH
61626: CALL_OW 257
61630: PUSH
61631: LD_INT 3
61633: NONEQUAL
61634: IFFALSE 61687
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
61636: LD_ADDR_EXP 142
61640: PUSH
61641: LD_EXP 142
61645: PPUSH
61646: LD_VAR 0 2
61650: PPUSH
61651: LD_EXP 142
61655: PUSH
61656: LD_VAR 0 2
61660: ARRAY
61661: PUSH
61662: LD_VAR 0 3
61666: DIFF
61667: PPUSH
61668: CALL_OW 1
61672: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61673: LD_VAR 0 3
61677: PPUSH
61678: LD_INT 0
61680: PPUSH
61681: CALL_OW 109
// continue ;
61685: GO 61618
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
61687: LD_EXP 121
61691: PUSH
61692: LD_VAR 0 2
61696: ARRAY
61697: PPUSH
61698: LD_INT 34
61700: PUSH
61701: LD_INT 31
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PUSH
61708: LD_INT 58
61710: PUSH
61711: EMPTY
61712: LIST
61713: PUSH
61714: EMPTY
61715: LIST
61716: LIST
61717: PPUSH
61718: CALL_OW 72
61722: PUSH
61723: LD_VAR 0 3
61727: PPUSH
61728: CALL 105708 0 1
61732: NOT
61733: AND
61734: IFFALSE 61805
// begin if IsInUnit ( j ) then
61736: LD_VAR 0 3
61740: PPUSH
61741: CALL_OW 310
61745: IFFALSE 61756
// ComExitBuilding ( j ) ;
61747: LD_VAR 0 3
61751: PPUSH
61752: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
61756: LD_VAR 0 3
61760: PPUSH
61761: LD_EXP 121
61765: PUSH
61766: LD_VAR 0 2
61770: ARRAY
61771: PPUSH
61772: LD_INT 34
61774: PUSH
61775: LD_INT 31
61777: PUSH
61778: EMPTY
61779: LIST
61780: LIST
61781: PUSH
61782: LD_INT 58
61784: PUSH
61785: EMPTY
61786: LIST
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: PPUSH
61792: CALL_OW 72
61796: PUSH
61797: LD_INT 1
61799: ARRAY
61800: PPUSH
61801: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61805: LD_VAR 0 3
61809: PPUSH
61810: CALL_OW 310
61814: NOT
61815: PUSH
61816: LD_VAR 0 3
61820: PPUSH
61821: CALL_OW 310
61825: PPUSH
61826: CALL_OW 266
61830: PUSH
61831: LD_INT 36
61833: NONEQUAL
61834: PUSH
61835: LD_VAR 0 3
61839: PPUSH
61840: CALL 105708 0 1
61844: NOT
61845: AND
61846: OR
61847: IFFALSE 61983
// begin if IsInUnit ( j ) then
61849: LD_VAR 0 3
61853: PPUSH
61854: CALL_OW 310
61858: IFFALSE 61869
// ComExitBuilding ( j ) ;
61860: LD_VAR 0 3
61864: PPUSH
61865: CALL_OW 122
// ct := 0 ;
61869: LD_ADDR_VAR 0 8
61873: PUSH
61874: LD_INT 0
61876: ST_TO_ADDR
// for k in x do
61877: LD_ADDR_VAR 0 4
61881: PUSH
61882: LD_VAR 0 11
61886: PUSH
61887: FOR_IN
61888: IFFALSE 61961
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61890: LD_VAR 0 4
61894: PPUSH
61895: CALL_OW 264
61899: PUSH
61900: LD_INT 31
61902: EQUAL
61903: PUSH
61904: LD_VAR 0 4
61908: PPUSH
61909: CALL_OW 311
61913: NOT
61914: AND
61915: PUSH
61916: LD_VAR 0 4
61920: PPUSH
61921: CALL_OW 266
61925: PUSH
61926: LD_INT 36
61928: EQUAL
61929: PUSH
61930: LD_VAR 0 4
61934: PPUSH
61935: CALL_OW 313
61939: PUSH
61940: LD_INT 3
61942: LESS
61943: AND
61944: OR
61945: IFFALSE 61959
// begin ct := k ;
61947: LD_ADDR_VAR 0 8
61951: PUSH
61952: LD_VAR 0 4
61956: ST_TO_ADDR
// break ;
61957: GO 61961
// end ;
61959: GO 61887
61961: POP
61962: POP
// if ct then
61963: LD_VAR 0 8
61967: IFFALSE 61983
// ComEnterUnit ( j , ct ) ;
61969: LD_VAR 0 3
61973: PPUSH
61974: LD_VAR 0 8
61978: PPUSH
61979: CALL_OW 120
// end ; end ;
61983: GO 61618
61985: POP
61986: POP
// places := 0 ;
61987: LD_ADDR_VAR 0 5
61991: PUSH
61992: LD_INT 0
61994: ST_TO_ADDR
// for j = 1 to x do
61995: LD_ADDR_VAR 0 3
61999: PUSH
62000: DOUBLE
62001: LD_INT 1
62003: DEC
62004: ST_TO_ADDR
62005: LD_VAR 0 11
62009: PUSH
62010: FOR_TO
62011: IFFALSE 62087
// if GetWeapon ( x [ j ] ) = ar_control_tower then
62013: LD_VAR 0 11
62017: PUSH
62018: LD_VAR 0 3
62022: ARRAY
62023: PPUSH
62024: CALL_OW 264
62028: PUSH
62029: LD_INT 31
62031: EQUAL
62032: IFFALSE 62050
// places := places + 1 else
62034: LD_ADDR_VAR 0 5
62038: PUSH
62039: LD_VAR 0 5
62043: PUSH
62044: LD_INT 1
62046: PLUS
62047: ST_TO_ADDR
62048: GO 62085
// if GetBType ( x [ j ] ) = b_control_tower then
62050: LD_VAR 0 11
62054: PUSH
62055: LD_VAR 0 3
62059: ARRAY
62060: PPUSH
62061: CALL_OW 266
62065: PUSH
62066: LD_INT 36
62068: EQUAL
62069: IFFALSE 62085
// places := places + 3 ;
62071: LD_ADDR_VAR 0 5
62075: PUSH
62076: LD_VAR 0 5
62080: PUSH
62081: LD_INT 3
62083: PLUS
62084: ST_TO_ADDR
62085: GO 62010
62087: POP
62088: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62089: LD_VAR 0 5
62093: PUSH
62094: LD_INT 0
62096: EQUAL
62097: PUSH
62098: LD_VAR 0 5
62102: PUSH
62103: LD_EXP 142
62107: PUSH
62108: LD_VAR 0 2
62112: ARRAY
62113: LESSEQUAL
62114: OR
62115: IFFALSE 62119
// continue ;
62117: GO 61369
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62119: LD_ADDR_VAR 0 6
62123: PUSH
62124: LD_EXP 102
62128: PUSH
62129: LD_VAR 0 2
62133: ARRAY
62134: PPUSH
62135: LD_INT 25
62137: PUSH
62138: LD_INT 3
62140: PUSH
62141: EMPTY
62142: LIST
62143: LIST
62144: PPUSH
62145: CALL_OW 72
62149: PUSH
62150: LD_EXP 142
62154: PUSH
62155: LD_VAR 0 2
62159: ARRAY
62160: DIFF
62161: PPUSH
62162: LD_INT 3
62164: PPUSH
62165: CALL 106608 0 2
62169: ST_TO_ADDR
// for j in tmp do
62170: LD_ADDR_VAR 0 3
62174: PUSH
62175: LD_VAR 0 6
62179: PUSH
62180: FOR_IN
62181: IFFALSE 62216
// if GetTag ( j ) > 0 then
62183: LD_VAR 0 3
62187: PPUSH
62188: CALL_OW 110
62192: PUSH
62193: LD_INT 0
62195: GREATER
62196: IFFALSE 62214
// tmp := tmp diff j ;
62198: LD_ADDR_VAR 0 6
62202: PUSH
62203: LD_VAR 0 6
62207: PUSH
62208: LD_VAR 0 3
62212: DIFF
62213: ST_TO_ADDR
62214: GO 62180
62216: POP
62217: POP
// if not tmp then
62218: LD_VAR 0 6
62222: NOT
62223: IFFALSE 62227
// continue ;
62225: GO 61369
// if places then
62227: LD_VAR 0 5
62231: IFFALSE 62290
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62233: LD_ADDR_EXP 142
62237: PUSH
62238: LD_EXP 142
62242: PPUSH
62243: LD_VAR 0 2
62247: PPUSH
62248: LD_EXP 142
62252: PUSH
62253: LD_VAR 0 2
62257: ARRAY
62258: PUSH
62259: LD_VAR 0 6
62263: PUSH
62264: LD_INT 1
62266: ARRAY
62267: UNION
62268: PPUSH
62269: CALL_OW 1
62273: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62274: LD_VAR 0 6
62278: PUSH
62279: LD_INT 1
62281: ARRAY
62282: PPUSH
62283: LD_INT 126
62285: PPUSH
62286: CALL_OW 109
// end ; end ;
62290: GO 61369
62292: POP
62293: POP
// end ;
62294: LD_VAR 0 1
62298: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62299: LD_INT 0
62301: PPUSH
62302: PPUSH
62303: PPUSH
62304: PPUSH
62305: PPUSH
62306: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62307: LD_VAR 0 1
62311: NOT
62312: PUSH
62313: LD_VAR 0 2
62317: NOT
62318: OR
62319: PUSH
62320: LD_VAR 0 3
62324: NOT
62325: OR
62326: PUSH
62327: LD_VAR 0 4
62331: PUSH
62332: LD_INT 1
62334: PUSH
62335: LD_INT 2
62337: PUSH
62338: LD_INT 3
62340: PUSH
62341: LD_INT 4
62343: PUSH
62344: LD_INT 5
62346: PUSH
62347: LD_INT 8
62349: PUSH
62350: LD_INT 9
62352: PUSH
62353: LD_INT 15
62355: PUSH
62356: LD_INT 16
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: LIST
62366: LIST
62367: LIST
62368: LIST
62369: IN
62370: NOT
62371: OR
62372: IFFALSE 62376
// exit ;
62374: GO 63234
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62376: LD_ADDR_VAR 0 2
62380: PUSH
62381: LD_VAR 0 2
62385: PPUSH
62386: LD_INT 21
62388: PUSH
62389: LD_INT 3
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: PUSH
62396: LD_INT 24
62398: PUSH
62399: LD_INT 250
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: PUSH
62406: EMPTY
62407: LIST
62408: LIST
62409: PPUSH
62410: CALL_OW 72
62414: ST_TO_ADDR
// case class of 1 , 15 :
62415: LD_VAR 0 4
62419: PUSH
62420: LD_INT 1
62422: DOUBLE
62423: EQUAL
62424: IFTRUE 62434
62426: LD_INT 15
62428: DOUBLE
62429: EQUAL
62430: IFTRUE 62434
62432: GO 62519
62434: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62435: LD_ADDR_VAR 0 8
62439: PUSH
62440: LD_VAR 0 2
62444: PPUSH
62445: LD_INT 2
62447: PUSH
62448: LD_INT 30
62450: PUSH
62451: LD_INT 32
62453: PUSH
62454: EMPTY
62455: LIST
62456: LIST
62457: PUSH
62458: LD_INT 30
62460: PUSH
62461: LD_INT 31
62463: PUSH
62464: EMPTY
62465: LIST
62466: LIST
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: LIST
62472: PPUSH
62473: CALL_OW 72
62477: PUSH
62478: LD_VAR 0 2
62482: PPUSH
62483: LD_INT 2
62485: PUSH
62486: LD_INT 30
62488: PUSH
62489: LD_INT 4
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: PUSH
62496: LD_INT 30
62498: PUSH
62499: LD_INT 5
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: LIST
62510: PPUSH
62511: CALL_OW 72
62515: ADD
62516: ST_TO_ADDR
62517: GO 62765
62519: LD_INT 2
62521: DOUBLE
62522: EQUAL
62523: IFTRUE 62533
62525: LD_INT 16
62527: DOUBLE
62528: EQUAL
62529: IFTRUE 62533
62531: GO 62579
62533: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
62534: LD_ADDR_VAR 0 8
62538: PUSH
62539: LD_VAR 0 2
62543: PPUSH
62544: LD_INT 2
62546: PUSH
62547: LD_INT 30
62549: PUSH
62550: LD_INT 0
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PUSH
62557: LD_INT 30
62559: PUSH
62560: LD_INT 1
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: LIST
62571: PPUSH
62572: CALL_OW 72
62576: ST_TO_ADDR
62577: GO 62765
62579: LD_INT 3
62581: DOUBLE
62582: EQUAL
62583: IFTRUE 62587
62585: GO 62633
62587: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
62588: LD_ADDR_VAR 0 8
62592: PUSH
62593: LD_VAR 0 2
62597: PPUSH
62598: LD_INT 2
62600: PUSH
62601: LD_INT 30
62603: PUSH
62604: LD_INT 2
62606: PUSH
62607: EMPTY
62608: LIST
62609: LIST
62610: PUSH
62611: LD_INT 30
62613: PUSH
62614: LD_INT 3
62616: PUSH
62617: EMPTY
62618: LIST
62619: LIST
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: LIST
62625: PPUSH
62626: CALL_OW 72
62630: ST_TO_ADDR
62631: GO 62765
62633: LD_INT 4
62635: DOUBLE
62636: EQUAL
62637: IFTRUE 62641
62639: GO 62698
62641: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
62642: LD_ADDR_VAR 0 8
62646: PUSH
62647: LD_VAR 0 2
62651: PPUSH
62652: LD_INT 2
62654: PUSH
62655: LD_INT 30
62657: PUSH
62658: LD_INT 6
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: PUSH
62665: LD_INT 30
62667: PUSH
62668: LD_INT 7
62670: PUSH
62671: EMPTY
62672: LIST
62673: LIST
62674: PUSH
62675: LD_INT 30
62677: PUSH
62678: LD_INT 8
62680: PUSH
62681: EMPTY
62682: LIST
62683: LIST
62684: PUSH
62685: EMPTY
62686: LIST
62687: LIST
62688: LIST
62689: LIST
62690: PPUSH
62691: CALL_OW 72
62695: ST_TO_ADDR
62696: GO 62765
62698: LD_INT 5
62700: DOUBLE
62701: EQUAL
62702: IFTRUE 62718
62704: LD_INT 8
62706: DOUBLE
62707: EQUAL
62708: IFTRUE 62718
62710: LD_INT 9
62712: DOUBLE
62713: EQUAL
62714: IFTRUE 62718
62716: GO 62764
62718: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
62719: LD_ADDR_VAR 0 8
62723: PUSH
62724: LD_VAR 0 2
62728: PPUSH
62729: LD_INT 2
62731: PUSH
62732: LD_INT 30
62734: PUSH
62735: LD_INT 4
62737: PUSH
62738: EMPTY
62739: LIST
62740: LIST
62741: PUSH
62742: LD_INT 30
62744: PUSH
62745: LD_INT 5
62747: PUSH
62748: EMPTY
62749: LIST
62750: LIST
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: LIST
62756: PPUSH
62757: CALL_OW 72
62761: ST_TO_ADDR
62762: GO 62765
62764: POP
// if not tmp then
62765: LD_VAR 0 8
62769: NOT
62770: IFFALSE 62774
// exit ;
62772: GO 63234
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62774: LD_VAR 0 4
62778: PUSH
62779: LD_INT 1
62781: PUSH
62782: LD_INT 15
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: IN
62789: PUSH
62790: LD_EXP 111
62794: PUSH
62795: LD_VAR 0 1
62799: ARRAY
62800: AND
62801: IFFALSE 62957
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62803: LD_ADDR_VAR 0 9
62807: PUSH
62808: LD_EXP 111
62812: PUSH
62813: LD_VAR 0 1
62817: ARRAY
62818: PUSH
62819: LD_INT 1
62821: ARRAY
62822: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62823: LD_VAR 0 9
62827: PUSH
62828: LD_EXP 112
62832: PUSH
62833: LD_VAR 0 1
62837: ARRAY
62838: IN
62839: NOT
62840: IFFALSE 62955
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62842: LD_ADDR_EXP 112
62846: PUSH
62847: LD_EXP 112
62851: PPUSH
62852: LD_VAR 0 1
62856: PUSH
62857: LD_EXP 112
62861: PUSH
62862: LD_VAR 0 1
62866: ARRAY
62867: PUSH
62868: LD_INT 1
62870: PLUS
62871: PUSH
62872: EMPTY
62873: LIST
62874: LIST
62875: PPUSH
62876: LD_VAR 0 9
62880: PPUSH
62881: CALL 75355 0 3
62885: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62886: LD_ADDR_EXP 111
62890: PUSH
62891: LD_EXP 111
62895: PPUSH
62896: LD_VAR 0 1
62900: PPUSH
62901: LD_EXP 111
62905: PUSH
62906: LD_VAR 0 1
62910: ARRAY
62911: PUSH
62912: LD_VAR 0 9
62916: DIFF
62917: PPUSH
62918: CALL_OW 1
62922: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62923: LD_VAR 0 3
62927: PPUSH
62928: LD_EXP 112
62932: PUSH
62933: LD_VAR 0 1
62937: ARRAY
62938: PUSH
62939: LD_EXP 112
62943: PUSH
62944: LD_VAR 0 1
62948: ARRAY
62949: ARRAY
62950: PPUSH
62951: CALL_OW 120
// end ; exit ;
62955: GO 63234
// end ; if tmp > 1 then
62957: LD_VAR 0 8
62961: PUSH
62962: LD_INT 1
62964: GREATER
62965: IFFALSE 63069
// for i = 2 to tmp do
62967: LD_ADDR_VAR 0 6
62971: PUSH
62972: DOUBLE
62973: LD_INT 2
62975: DEC
62976: ST_TO_ADDR
62977: LD_VAR 0 8
62981: PUSH
62982: FOR_TO
62983: IFFALSE 63067
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62985: LD_VAR 0 8
62989: PUSH
62990: LD_VAR 0 6
62994: ARRAY
62995: PPUSH
62996: CALL_OW 461
63000: PUSH
63001: LD_INT 6
63003: EQUAL
63004: IFFALSE 63065
// begin x := tmp [ i ] ;
63006: LD_ADDR_VAR 0 9
63010: PUSH
63011: LD_VAR 0 8
63015: PUSH
63016: LD_VAR 0 6
63020: ARRAY
63021: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
63022: LD_ADDR_VAR 0 8
63026: PUSH
63027: LD_VAR 0 8
63031: PPUSH
63032: LD_VAR 0 6
63036: PPUSH
63037: CALL_OW 3
63041: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63042: LD_ADDR_VAR 0 8
63046: PUSH
63047: LD_VAR 0 8
63051: PPUSH
63052: LD_INT 1
63054: PPUSH
63055: LD_VAR 0 9
63059: PPUSH
63060: CALL_OW 2
63064: ST_TO_ADDR
// end ;
63065: GO 62982
63067: POP
63068: POP
// for i in tmp do
63069: LD_ADDR_VAR 0 6
63073: PUSH
63074: LD_VAR 0 8
63078: PUSH
63079: FOR_IN
63080: IFFALSE 63107
// begin if IsNotFull ( i ) then
63082: LD_VAR 0 6
63086: PPUSH
63087: CALL 72577 0 1
63091: IFFALSE 63105
// begin j := i ;
63093: LD_ADDR_VAR 0 7
63097: PUSH
63098: LD_VAR 0 6
63102: ST_TO_ADDR
// break ;
63103: GO 63107
// end ; end ;
63105: GO 63079
63107: POP
63108: POP
// if j then
63109: LD_VAR 0 7
63113: IFFALSE 63131
// ComEnterUnit ( unit , j ) else
63115: LD_VAR 0 3
63119: PPUSH
63120: LD_VAR 0 7
63124: PPUSH
63125: CALL_OW 120
63129: GO 63234
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63131: LD_ADDR_VAR 0 10
63135: PUSH
63136: LD_VAR 0 2
63140: PPUSH
63141: LD_INT 2
63143: PUSH
63144: LD_INT 30
63146: PUSH
63147: LD_INT 0
63149: PUSH
63150: EMPTY
63151: LIST
63152: LIST
63153: PUSH
63154: LD_INT 30
63156: PUSH
63157: LD_INT 1
63159: PUSH
63160: EMPTY
63161: LIST
63162: LIST
63163: PUSH
63164: EMPTY
63165: LIST
63166: LIST
63167: LIST
63168: PPUSH
63169: CALL_OW 72
63173: ST_TO_ADDR
// if depot then
63174: LD_VAR 0 10
63178: IFFALSE 63234
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63180: LD_ADDR_VAR 0 10
63184: PUSH
63185: LD_VAR 0 10
63189: PPUSH
63190: LD_VAR 0 3
63194: PPUSH
63195: CALL_OW 74
63199: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63200: LD_VAR 0 3
63204: PPUSH
63205: LD_VAR 0 10
63209: PPUSH
63210: CALL_OW 296
63214: PUSH
63215: LD_INT 10
63217: GREATER
63218: IFFALSE 63234
// ComStandNearbyBuilding ( unit , depot ) ;
63220: LD_VAR 0 3
63224: PPUSH
63225: LD_VAR 0 10
63229: PPUSH
63230: CALL 71957 0 2
// end ; end ; end ;
63234: LD_VAR 0 5
63238: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63239: LD_INT 0
63241: PPUSH
63242: PPUSH
63243: PPUSH
63244: PPUSH
// if not mc_bases then
63245: LD_EXP 102
63249: NOT
63250: IFFALSE 63254
// exit ;
63252: GO 63493
// for i = 1 to mc_bases do
63254: LD_ADDR_VAR 0 2
63258: PUSH
63259: DOUBLE
63260: LD_INT 1
63262: DEC
63263: ST_TO_ADDR
63264: LD_EXP 102
63268: PUSH
63269: FOR_TO
63270: IFFALSE 63491
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63272: LD_ADDR_VAR 0 4
63276: PUSH
63277: LD_EXP 102
63281: PUSH
63282: LD_VAR 0 2
63286: ARRAY
63287: PPUSH
63288: LD_INT 21
63290: PUSH
63291: LD_INT 1
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PPUSH
63298: CALL_OW 72
63302: PUSH
63303: LD_EXP 131
63307: PUSH
63308: LD_VAR 0 2
63312: ARRAY
63313: UNION
63314: ST_TO_ADDR
// if not tmp then
63315: LD_VAR 0 4
63319: NOT
63320: IFFALSE 63324
// continue ;
63322: GO 63269
// for j in tmp do
63324: LD_ADDR_VAR 0 3
63328: PUSH
63329: LD_VAR 0 4
63333: PUSH
63334: FOR_IN
63335: IFFALSE 63487
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63337: LD_VAR 0 3
63341: PPUSH
63342: CALL_OW 110
63346: NOT
63347: PUSH
63348: LD_VAR 0 3
63352: PPUSH
63353: CALL_OW 314
63357: NOT
63358: AND
63359: PUSH
63360: LD_VAR 0 3
63364: PPUSH
63365: CALL_OW 311
63369: NOT
63370: AND
63371: PUSH
63372: LD_VAR 0 3
63376: PPUSH
63377: CALL_OW 310
63381: NOT
63382: AND
63383: PUSH
63384: LD_VAR 0 3
63388: PUSH
63389: LD_EXP 105
63393: PUSH
63394: LD_VAR 0 2
63398: ARRAY
63399: PUSH
63400: LD_INT 1
63402: ARRAY
63403: IN
63404: NOT
63405: AND
63406: PUSH
63407: LD_VAR 0 3
63411: PUSH
63412: LD_EXP 105
63416: PUSH
63417: LD_VAR 0 2
63421: ARRAY
63422: PUSH
63423: LD_INT 2
63425: ARRAY
63426: IN
63427: NOT
63428: AND
63429: PUSH
63430: LD_VAR 0 3
63434: PUSH
63435: LD_EXP 114
63439: PUSH
63440: LD_VAR 0 2
63444: ARRAY
63445: IN
63446: NOT
63447: AND
63448: IFFALSE 63485
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63450: LD_VAR 0 2
63454: PPUSH
63455: LD_EXP 102
63459: PUSH
63460: LD_VAR 0 2
63464: ARRAY
63465: PPUSH
63466: LD_VAR 0 3
63470: PPUSH
63471: LD_VAR 0 3
63475: PPUSH
63476: CALL_OW 257
63480: PPUSH
63481: CALL 62299 0 4
// end ;
63485: GO 63334
63487: POP
63488: POP
// end ;
63489: GO 63269
63491: POP
63492: POP
// end ;
63493: LD_VAR 0 1
63497: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
63498: LD_INT 0
63500: PPUSH
63501: PPUSH
63502: PPUSH
63503: PPUSH
63504: PPUSH
63505: PPUSH
// if not mc_bases [ base ] then
63506: LD_EXP 102
63510: PUSH
63511: LD_VAR 0 1
63515: ARRAY
63516: NOT
63517: IFFALSE 63521
// exit ;
63519: GO 63722
// tmp := [ ] ;
63521: LD_ADDR_VAR 0 6
63525: PUSH
63526: EMPTY
63527: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
63528: LD_ADDR_VAR 0 7
63532: PUSH
63533: LD_VAR 0 3
63537: PPUSH
63538: LD_INT 0
63540: PPUSH
63541: CALL_OW 517
63545: ST_TO_ADDR
// if not list then
63546: LD_VAR 0 7
63550: NOT
63551: IFFALSE 63555
// exit ;
63553: GO 63722
// c := Count ( list [ 1 ] ) ;
63555: LD_ADDR_VAR 0 9
63559: PUSH
63560: LD_VAR 0 7
63564: PUSH
63565: LD_INT 1
63567: ARRAY
63568: PPUSH
63569: CALL 72495 0 1
63573: ST_TO_ADDR
// if amount > c then
63574: LD_VAR 0 2
63578: PUSH
63579: LD_VAR 0 9
63583: GREATER
63584: IFFALSE 63596
// amount := c ;
63586: LD_ADDR_VAR 0 2
63590: PUSH
63591: LD_VAR 0 9
63595: ST_TO_ADDR
// for i := 1 to amount do
63596: LD_ADDR_VAR 0 5
63600: PUSH
63601: DOUBLE
63602: LD_INT 1
63604: DEC
63605: ST_TO_ADDR
63606: LD_VAR 0 2
63610: PUSH
63611: FOR_TO
63612: IFFALSE 63670
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
63614: LD_ADDR_VAR 0 6
63618: PUSH
63619: LD_VAR 0 6
63623: PPUSH
63624: LD_VAR 0 5
63628: PPUSH
63629: LD_VAR 0 7
63633: PUSH
63634: LD_INT 1
63636: ARRAY
63637: PUSH
63638: LD_VAR 0 5
63642: ARRAY
63643: PUSH
63644: LD_VAR 0 7
63648: PUSH
63649: LD_INT 2
63651: ARRAY
63652: PUSH
63653: LD_VAR 0 5
63657: ARRAY
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PPUSH
63663: CALL_OW 1
63667: ST_TO_ADDR
63668: GO 63611
63670: POP
63671: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
63672: LD_ADDR_EXP 115
63676: PUSH
63677: LD_EXP 115
63681: PPUSH
63682: LD_VAR 0 1
63686: PPUSH
63687: LD_VAR 0 6
63691: PPUSH
63692: CALL_OW 1
63696: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
63697: LD_ADDR_EXP 117
63701: PUSH
63702: LD_EXP 117
63706: PPUSH
63707: LD_VAR 0 1
63711: PPUSH
63712: LD_VAR 0 3
63716: PPUSH
63717: CALL_OW 1
63721: ST_TO_ADDR
// end ;
63722: LD_VAR 0 4
63726: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
63727: LD_INT 0
63729: PPUSH
// if not mc_bases [ base ] then
63730: LD_EXP 102
63734: PUSH
63735: LD_VAR 0 1
63739: ARRAY
63740: NOT
63741: IFFALSE 63745
// exit ;
63743: GO 63770
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
63745: LD_ADDR_EXP 107
63749: PUSH
63750: LD_EXP 107
63754: PPUSH
63755: LD_VAR 0 1
63759: PPUSH
63760: LD_VAR 0 2
63764: PPUSH
63765: CALL_OW 1
63769: ST_TO_ADDR
// end ;
63770: LD_VAR 0 3
63774: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63775: LD_INT 0
63777: PPUSH
// if not mc_bases [ base ] then
63778: LD_EXP 102
63782: PUSH
63783: LD_VAR 0 1
63787: ARRAY
63788: NOT
63789: IFFALSE 63793
// exit ;
63791: GO 63830
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63793: LD_ADDR_EXP 107
63797: PUSH
63798: LD_EXP 107
63802: PPUSH
63803: LD_VAR 0 1
63807: PPUSH
63808: LD_EXP 107
63812: PUSH
63813: LD_VAR 0 1
63817: ARRAY
63818: PUSH
63819: LD_VAR 0 2
63823: UNION
63824: PPUSH
63825: CALL_OW 1
63829: ST_TO_ADDR
// end ;
63830: LD_VAR 0 3
63834: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63835: LD_INT 0
63837: PPUSH
// if not mc_bases [ base ] then
63838: LD_EXP 102
63842: PUSH
63843: LD_VAR 0 1
63847: ARRAY
63848: NOT
63849: IFFALSE 63853
// exit ;
63851: GO 63878
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63853: LD_ADDR_EXP 123
63857: PUSH
63858: LD_EXP 123
63862: PPUSH
63863: LD_VAR 0 1
63867: PPUSH
63868: LD_VAR 0 2
63872: PPUSH
63873: CALL_OW 1
63877: ST_TO_ADDR
// end ;
63878: LD_VAR 0 3
63882: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63883: LD_INT 0
63885: PPUSH
// if not mc_bases [ base ] then
63886: LD_EXP 102
63890: PUSH
63891: LD_VAR 0 1
63895: ARRAY
63896: NOT
63897: IFFALSE 63901
// exit ;
63899: GO 63938
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63901: LD_ADDR_EXP 123
63905: PUSH
63906: LD_EXP 123
63910: PPUSH
63911: LD_VAR 0 1
63915: PPUSH
63916: LD_EXP 123
63920: PUSH
63921: LD_VAR 0 1
63925: ARRAY
63926: PUSH
63927: LD_VAR 0 2
63931: ADD
63932: PPUSH
63933: CALL_OW 1
63937: ST_TO_ADDR
// end ;
63938: LD_VAR 0 3
63942: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63943: LD_INT 0
63945: PPUSH
// if not mc_bases [ base ] then
63946: LD_EXP 102
63950: PUSH
63951: LD_VAR 0 1
63955: ARRAY
63956: NOT
63957: IFFALSE 63961
// exit ;
63959: GO 64015
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63961: LD_ADDR_EXP 124
63965: PUSH
63966: LD_EXP 124
63970: PPUSH
63971: LD_VAR 0 1
63975: PPUSH
63976: LD_VAR 0 2
63980: PPUSH
63981: CALL_OW 1
63985: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63986: LD_ADDR_EXP 113
63990: PUSH
63991: LD_EXP 113
63995: PPUSH
63996: LD_VAR 0 1
64000: PPUSH
64001: LD_VAR 0 2
64005: PUSH
64006: LD_INT 0
64008: PLUS
64009: PPUSH
64010: CALL_OW 1
64014: ST_TO_ADDR
// end ;
64015: LD_VAR 0 3
64019: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
64020: LD_INT 0
64022: PPUSH
// if not mc_bases [ base ] then
64023: LD_EXP 102
64027: PUSH
64028: LD_VAR 0 1
64032: ARRAY
64033: NOT
64034: IFFALSE 64038
// exit ;
64036: GO 64063
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64038: LD_ADDR_EXP 113
64042: PUSH
64043: LD_EXP 113
64047: PPUSH
64048: LD_VAR 0 1
64052: PPUSH
64053: LD_VAR 0 2
64057: PPUSH
64058: CALL_OW 1
64062: ST_TO_ADDR
// end ;
64063: LD_VAR 0 3
64067: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64068: LD_INT 0
64070: PPUSH
64071: PPUSH
64072: PPUSH
64073: PPUSH
// if not mc_bases [ base ] then
64074: LD_EXP 102
64078: PUSH
64079: LD_VAR 0 1
64083: ARRAY
64084: NOT
64085: IFFALSE 64089
// exit ;
64087: GO 64154
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64089: LD_ADDR_EXP 122
64093: PUSH
64094: LD_EXP 122
64098: PPUSH
64099: LD_VAR 0 1
64103: PUSH
64104: LD_EXP 122
64108: PUSH
64109: LD_VAR 0 1
64113: ARRAY
64114: PUSH
64115: LD_INT 1
64117: PLUS
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PPUSH
64123: LD_VAR 0 1
64127: PUSH
64128: LD_VAR 0 2
64132: PUSH
64133: LD_VAR 0 3
64137: PUSH
64138: LD_VAR 0 4
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: PPUSH
64149: CALL 75355 0 3
64153: ST_TO_ADDR
// end ;
64154: LD_VAR 0 5
64158: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64159: LD_INT 0
64161: PPUSH
// if not mc_bases [ base ] then
64162: LD_EXP 102
64166: PUSH
64167: LD_VAR 0 1
64171: ARRAY
64172: NOT
64173: IFFALSE 64177
// exit ;
64175: GO 64202
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64177: LD_ADDR_EXP 139
64181: PUSH
64182: LD_EXP 139
64186: PPUSH
64187: LD_VAR 0 1
64191: PPUSH
64192: LD_VAR 0 2
64196: PPUSH
64197: CALL_OW 1
64201: ST_TO_ADDR
// end ;
64202: LD_VAR 0 3
64206: RET
// export function MC_GetMinesField ( base ) ; begin
64207: LD_INT 0
64209: PPUSH
// result := mc_mines [ base ] ;
64210: LD_ADDR_VAR 0 2
64214: PUSH
64215: LD_EXP 115
64219: PUSH
64220: LD_VAR 0 1
64224: ARRAY
64225: ST_TO_ADDR
// end ;
64226: LD_VAR 0 2
64230: RET
// export function MC_GetProduceList ( base ) ; begin
64231: LD_INT 0
64233: PPUSH
// result := mc_produce [ base ] ;
64234: LD_ADDR_VAR 0 2
64238: PUSH
64239: LD_EXP 123
64243: PUSH
64244: LD_VAR 0 1
64248: ARRAY
64249: ST_TO_ADDR
// end ;
64250: LD_VAR 0 2
64254: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64255: LD_INT 0
64257: PPUSH
64258: PPUSH
// if not mc_bases then
64259: LD_EXP 102
64263: NOT
64264: IFFALSE 64268
// exit ;
64266: GO 64333
// if mc_bases [ base ] then
64268: LD_EXP 102
64272: PUSH
64273: LD_VAR 0 1
64277: ARRAY
64278: IFFALSE 64333
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64280: LD_ADDR_VAR 0 3
64284: PUSH
64285: LD_EXP 102
64289: PUSH
64290: LD_VAR 0 1
64294: ARRAY
64295: PPUSH
64296: LD_INT 30
64298: PUSH
64299: LD_VAR 0 2
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PPUSH
64308: CALL_OW 72
64312: ST_TO_ADDR
// if result then
64313: LD_VAR 0 3
64317: IFFALSE 64333
// result := result [ 1 ] ;
64319: LD_ADDR_VAR 0 3
64323: PUSH
64324: LD_VAR 0 3
64328: PUSH
64329: LD_INT 1
64331: ARRAY
64332: ST_TO_ADDR
// end ; end ;
64333: LD_VAR 0 3
64337: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64338: LD_INT 0
64340: PPUSH
64341: PPUSH
// if not mc_bases then
64342: LD_EXP 102
64346: NOT
64347: IFFALSE 64351
// exit ;
64349: GO 64396
// if mc_bases [ base ] then
64351: LD_EXP 102
64355: PUSH
64356: LD_VAR 0 1
64360: ARRAY
64361: IFFALSE 64396
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64363: LD_ADDR_VAR 0 3
64367: PUSH
64368: LD_EXP 102
64372: PUSH
64373: LD_VAR 0 1
64377: ARRAY
64378: PPUSH
64379: LD_INT 30
64381: PUSH
64382: LD_VAR 0 2
64386: PUSH
64387: EMPTY
64388: LIST
64389: LIST
64390: PPUSH
64391: CALL_OW 72
64395: ST_TO_ADDR
// end ;
64396: LD_VAR 0 3
64400: RET
// export function MC_SetTame ( base , area ) ; begin
64401: LD_INT 0
64403: PPUSH
// if not mc_bases or not base then
64404: LD_EXP 102
64408: NOT
64409: PUSH
64410: LD_VAR 0 1
64414: NOT
64415: OR
64416: IFFALSE 64420
// exit ;
64418: GO 64445
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64420: LD_ADDR_EXP 130
64424: PUSH
64425: LD_EXP 130
64429: PPUSH
64430: LD_VAR 0 1
64434: PPUSH
64435: LD_VAR 0 2
64439: PPUSH
64440: CALL_OW 1
64444: ST_TO_ADDR
// end ;
64445: LD_VAR 0 3
64449: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64450: LD_INT 0
64452: PPUSH
64453: PPUSH
// if not mc_bases or not base then
64454: LD_EXP 102
64458: NOT
64459: PUSH
64460: LD_VAR 0 1
64464: NOT
64465: OR
64466: IFFALSE 64470
// exit ;
64468: GO 64572
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64470: LD_ADDR_VAR 0 4
64474: PUSH
64475: LD_EXP 102
64479: PUSH
64480: LD_VAR 0 1
64484: ARRAY
64485: PPUSH
64486: LD_INT 30
64488: PUSH
64489: LD_VAR 0 2
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PPUSH
64498: CALL_OW 72
64502: ST_TO_ADDR
// if not tmp then
64503: LD_VAR 0 4
64507: NOT
64508: IFFALSE 64512
// exit ;
64510: GO 64572
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
64512: LD_ADDR_EXP 134
64516: PUSH
64517: LD_EXP 134
64521: PPUSH
64522: LD_VAR 0 1
64526: PPUSH
64527: LD_EXP 134
64531: PUSH
64532: LD_VAR 0 1
64536: ARRAY
64537: PPUSH
64538: LD_EXP 134
64542: PUSH
64543: LD_VAR 0 1
64547: ARRAY
64548: PUSH
64549: LD_INT 1
64551: PLUS
64552: PPUSH
64553: LD_VAR 0 4
64557: PUSH
64558: LD_INT 1
64560: ARRAY
64561: PPUSH
64562: CALL_OW 2
64566: PPUSH
64567: CALL_OW 1
64571: ST_TO_ADDR
// end ;
64572: LD_VAR 0 3
64576: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
64577: LD_INT 0
64579: PPUSH
64580: PPUSH
// if not mc_bases or not base or not kinds then
64581: LD_EXP 102
64585: NOT
64586: PUSH
64587: LD_VAR 0 1
64591: NOT
64592: OR
64593: PUSH
64594: LD_VAR 0 2
64598: NOT
64599: OR
64600: IFFALSE 64604
// exit ;
64602: GO 64665
// for i in kinds do
64604: LD_ADDR_VAR 0 4
64608: PUSH
64609: LD_VAR 0 2
64613: PUSH
64614: FOR_IN
64615: IFFALSE 64663
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
64617: LD_ADDR_EXP 136
64621: PUSH
64622: LD_EXP 136
64626: PPUSH
64627: LD_VAR 0 1
64631: PUSH
64632: LD_EXP 136
64636: PUSH
64637: LD_VAR 0 1
64641: ARRAY
64642: PUSH
64643: LD_INT 1
64645: PLUS
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PPUSH
64651: LD_VAR 0 4
64655: PPUSH
64656: CALL 75355 0 3
64660: ST_TO_ADDR
64661: GO 64614
64663: POP
64664: POP
// end ;
64665: LD_VAR 0 3
64669: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
64670: LD_INT 0
64672: PPUSH
// if not mc_bases or not base or not areas then
64673: LD_EXP 102
64677: NOT
64678: PUSH
64679: LD_VAR 0 1
64683: NOT
64684: OR
64685: PUSH
64686: LD_VAR 0 2
64690: NOT
64691: OR
64692: IFFALSE 64696
// exit ;
64694: GO 64721
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
64696: LD_ADDR_EXP 120
64700: PUSH
64701: LD_EXP 120
64705: PPUSH
64706: LD_VAR 0 1
64710: PPUSH
64711: LD_VAR 0 2
64715: PPUSH
64716: CALL_OW 1
64720: ST_TO_ADDR
// end ;
64721: LD_VAR 0 3
64725: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
64726: LD_INT 0
64728: PPUSH
// if not mc_bases or not base or not teleports_exit then
64729: LD_EXP 102
64733: NOT
64734: PUSH
64735: LD_VAR 0 1
64739: NOT
64740: OR
64741: PUSH
64742: LD_VAR 0 2
64746: NOT
64747: OR
64748: IFFALSE 64752
// exit ;
64750: GO 64777
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
64752: LD_ADDR_EXP 137
64756: PUSH
64757: LD_EXP 137
64761: PPUSH
64762: LD_VAR 0 1
64766: PPUSH
64767: LD_VAR 0 2
64771: PPUSH
64772: CALL_OW 1
64776: ST_TO_ADDR
// end ;
64777: LD_VAR 0 3
64781: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64782: LD_INT 0
64784: PPUSH
64785: PPUSH
64786: PPUSH
// if not mc_bases or not base or not ext_list then
64787: LD_EXP 102
64791: NOT
64792: PUSH
64793: LD_VAR 0 1
64797: NOT
64798: OR
64799: PUSH
64800: LD_VAR 0 5
64804: NOT
64805: OR
64806: IFFALSE 64810
// exit ;
64808: GO 64983
// tmp := GetFacExtXYD ( x , y , d ) ;
64810: LD_ADDR_VAR 0 8
64814: PUSH
64815: LD_VAR 0 2
64819: PPUSH
64820: LD_VAR 0 3
64824: PPUSH
64825: LD_VAR 0 4
64829: PPUSH
64830: CALL 105738 0 3
64834: ST_TO_ADDR
// if not tmp then
64835: LD_VAR 0 8
64839: NOT
64840: IFFALSE 64844
// exit ;
64842: GO 64983
// for i in tmp do
64844: LD_ADDR_VAR 0 7
64848: PUSH
64849: LD_VAR 0 8
64853: PUSH
64854: FOR_IN
64855: IFFALSE 64981
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64857: LD_ADDR_EXP 107
64861: PUSH
64862: LD_EXP 107
64866: PPUSH
64867: LD_VAR 0 1
64871: PPUSH
64872: LD_EXP 107
64876: PUSH
64877: LD_VAR 0 1
64881: ARRAY
64882: PPUSH
64883: LD_EXP 107
64887: PUSH
64888: LD_VAR 0 1
64892: ARRAY
64893: PUSH
64894: LD_INT 1
64896: PLUS
64897: PPUSH
64898: LD_VAR 0 5
64902: PUSH
64903: LD_INT 1
64905: ARRAY
64906: PUSH
64907: LD_VAR 0 7
64911: PUSH
64912: LD_INT 1
64914: ARRAY
64915: PUSH
64916: LD_VAR 0 7
64920: PUSH
64921: LD_INT 2
64923: ARRAY
64924: PUSH
64925: LD_VAR 0 7
64929: PUSH
64930: LD_INT 3
64932: ARRAY
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: LIST
64938: LIST
64939: PPUSH
64940: CALL_OW 2
64944: PPUSH
64945: CALL_OW 1
64949: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64950: LD_ADDR_VAR 0 5
64954: PUSH
64955: LD_VAR 0 5
64959: PPUSH
64960: LD_INT 1
64962: PPUSH
64963: CALL_OW 3
64967: ST_TO_ADDR
// if not ext_list then
64968: LD_VAR 0 5
64972: NOT
64973: IFFALSE 64979
// exit ;
64975: POP
64976: POP
64977: GO 64983
// end ;
64979: GO 64854
64981: POP
64982: POP
// end ;
64983: LD_VAR 0 6
64987: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64988: LD_INT 0
64990: PPUSH
// if not mc_bases or not base or not weapon_list then
64991: LD_EXP 102
64995: NOT
64996: PUSH
64997: LD_VAR 0 1
65001: NOT
65002: OR
65003: PUSH
65004: LD_VAR 0 2
65008: NOT
65009: OR
65010: IFFALSE 65014
// exit ;
65012: GO 65039
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
65014: LD_ADDR_EXP 141
65018: PUSH
65019: LD_EXP 141
65023: PPUSH
65024: LD_VAR 0 1
65028: PPUSH
65029: LD_VAR 0 2
65033: PPUSH
65034: CALL_OW 1
65038: ST_TO_ADDR
// end ;
65039: LD_VAR 0 3
65043: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65044: LD_INT 0
65046: PPUSH
// if not mc_bases or not base or not tech_list then
65047: LD_EXP 102
65051: NOT
65052: PUSH
65053: LD_VAR 0 1
65057: NOT
65058: OR
65059: PUSH
65060: LD_VAR 0 2
65064: NOT
65065: OR
65066: IFFALSE 65070
// exit ;
65068: GO 65095
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65070: LD_ADDR_EXP 129
65074: PUSH
65075: LD_EXP 129
65079: PPUSH
65080: LD_VAR 0 1
65084: PPUSH
65085: LD_VAR 0 2
65089: PPUSH
65090: CALL_OW 1
65094: ST_TO_ADDR
// end ;
65095: LD_VAR 0 3
65099: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65100: LD_INT 0
65102: PPUSH
// if not mc_bases or not parking_area or not base then
65103: LD_EXP 102
65107: NOT
65108: PUSH
65109: LD_VAR 0 2
65113: NOT
65114: OR
65115: PUSH
65116: LD_VAR 0 1
65120: NOT
65121: OR
65122: IFFALSE 65126
// exit ;
65124: GO 65151
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65126: LD_ADDR_EXP 126
65130: PUSH
65131: LD_EXP 126
65135: PPUSH
65136: LD_VAR 0 1
65140: PPUSH
65141: LD_VAR 0 2
65145: PPUSH
65146: CALL_OW 1
65150: ST_TO_ADDR
// end ;
65151: LD_VAR 0 3
65155: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65156: LD_INT 0
65158: PPUSH
// if not mc_bases or not base or not scan_area then
65159: LD_EXP 102
65163: NOT
65164: PUSH
65165: LD_VAR 0 1
65169: NOT
65170: OR
65171: PUSH
65172: LD_VAR 0 2
65176: NOT
65177: OR
65178: IFFALSE 65182
// exit ;
65180: GO 65207
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65182: LD_ADDR_EXP 127
65186: PUSH
65187: LD_EXP 127
65191: PPUSH
65192: LD_VAR 0 1
65196: PPUSH
65197: LD_VAR 0 2
65201: PPUSH
65202: CALL_OW 1
65206: ST_TO_ADDR
// end ;
65207: LD_VAR 0 3
65211: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65212: LD_INT 0
65214: PPUSH
65215: PPUSH
// if not mc_bases or not base then
65216: LD_EXP 102
65220: NOT
65221: PUSH
65222: LD_VAR 0 1
65226: NOT
65227: OR
65228: IFFALSE 65232
// exit ;
65230: GO 65296
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65232: LD_ADDR_VAR 0 3
65236: PUSH
65237: LD_INT 1
65239: PUSH
65240: LD_INT 2
65242: PUSH
65243: LD_INT 3
65245: PUSH
65246: LD_INT 4
65248: PUSH
65249: LD_INT 11
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65259: LD_ADDR_EXP 129
65263: PUSH
65264: LD_EXP 129
65268: PPUSH
65269: LD_VAR 0 1
65273: PPUSH
65274: LD_EXP 129
65278: PUSH
65279: LD_VAR 0 1
65283: ARRAY
65284: PUSH
65285: LD_VAR 0 3
65289: DIFF
65290: PPUSH
65291: CALL_OW 1
65295: ST_TO_ADDR
// end ;
65296: LD_VAR 0 2
65300: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65301: LD_INT 0
65303: PPUSH
// result := mc_vehicles [ base ] ;
65304: LD_ADDR_VAR 0 3
65308: PUSH
65309: LD_EXP 121
65313: PUSH
65314: LD_VAR 0 1
65318: ARRAY
65319: ST_TO_ADDR
// if onlyCombat then
65320: LD_VAR 0 2
65324: IFFALSE 65496
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65326: LD_ADDR_VAR 0 3
65330: PUSH
65331: LD_VAR 0 3
65335: PUSH
65336: LD_VAR 0 3
65340: PPUSH
65341: LD_INT 2
65343: PUSH
65344: LD_INT 34
65346: PUSH
65347: LD_INT 12
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 34
65356: PUSH
65357: LD_INT 51
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 34
65366: PUSH
65367: LD_INT 89
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: LD_INT 34
65376: PUSH
65377: LD_INT 32
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: LD_INT 34
65386: PUSH
65387: LD_INT 13
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: LD_INT 34
65396: PUSH
65397: LD_INT 52
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 34
65406: PUSH
65407: LD_INT 88
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: LD_INT 34
65416: PUSH
65417: LD_INT 14
65419: PUSH
65420: EMPTY
65421: LIST
65422: LIST
65423: PUSH
65424: LD_INT 34
65426: PUSH
65427: LD_INT 53
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 34
65436: PUSH
65437: LD_INT 98
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 34
65446: PUSH
65447: LD_INT 31
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: PUSH
65454: LD_INT 34
65456: PUSH
65457: LD_INT 48
65459: PUSH
65460: EMPTY
65461: LIST
65462: LIST
65463: PUSH
65464: LD_INT 34
65466: PUSH
65467: LD_INT 8
65469: PUSH
65470: EMPTY
65471: LIST
65472: LIST
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: PPUSH
65490: CALL_OW 72
65494: DIFF
65495: ST_TO_ADDR
// end ; end_of_file
65496: LD_VAR 0 3
65500: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
65501: LD_INT 0
65503: PPUSH
65504: PPUSH
65505: PPUSH
// if not mc_bases or not skirmish then
65506: LD_EXP 102
65510: NOT
65511: PUSH
65512: LD_EXP 100
65516: NOT
65517: OR
65518: IFFALSE 65522
// exit ;
65520: GO 65687
// for i = 1 to mc_bases do
65522: LD_ADDR_VAR 0 4
65526: PUSH
65527: DOUBLE
65528: LD_INT 1
65530: DEC
65531: ST_TO_ADDR
65532: LD_EXP 102
65536: PUSH
65537: FOR_TO
65538: IFFALSE 65685
// begin if sci in mc_bases [ i ] then
65540: LD_VAR 0 2
65544: PUSH
65545: LD_EXP 102
65549: PUSH
65550: LD_VAR 0 4
65554: ARRAY
65555: IN
65556: IFFALSE 65683
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
65558: LD_ADDR_EXP 131
65562: PUSH
65563: LD_EXP 131
65567: PPUSH
65568: LD_VAR 0 4
65572: PUSH
65573: LD_EXP 131
65577: PUSH
65578: LD_VAR 0 4
65582: ARRAY
65583: PUSH
65584: LD_INT 1
65586: PLUS
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: PPUSH
65592: LD_VAR 0 1
65596: PPUSH
65597: CALL 75355 0 3
65601: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
65602: LD_ADDR_VAR 0 5
65606: PUSH
65607: LD_EXP 102
65611: PUSH
65612: LD_VAR 0 4
65616: ARRAY
65617: PPUSH
65618: LD_INT 2
65620: PUSH
65621: LD_INT 30
65623: PUSH
65624: LD_INT 0
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: PUSH
65631: LD_INT 30
65633: PUSH
65634: LD_INT 1
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: LIST
65645: PPUSH
65646: CALL_OW 72
65650: PPUSH
65651: LD_VAR 0 1
65655: PPUSH
65656: CALL_OW 74
65660: ST_TO_ADDR
// if tmp then
65661: LD_VAR 0 5
65665: IFFALSE 65681
// ComStandNearbyBuilding ( ape , tmp ) ;
65667: LD_VAR 0 1
65671: PPUSH
65672: LD_VAR 0 5
65676: PPUSH
65677: CALL 71957 0 2
// break ;
65681: GO 65685
// end ; end ;
65683: GO 65537
65685: POP
65686: POP
// end ;
65687: LD_VAR 0 3
65691: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
65692: LD_INT 0
65694: PPUSH
65695: PPUSH
65696: PPUSH
// if not mc_bases or not skirmish then
65697: LD_EXP 102
65701: NOT
65702: PUSH
65703: LD_EXP 100
65707: NOT
65708: OR
65709: IFFALSE 65713
// exit ;
65711: GO 65802
// for i = 1 to mc_bases do
65713: LD_ADDR_VAR 0 4
65717: PUSH
65718: DOUBLE
65719: LD_INT 1
65721: DEC
65722: ST_TO_ADDR
65723: LD_EXP 102
65727: PUSH
65728: FOR_TO
65729: IFFALSE 65800
// begin if building in mc_busy_turret_list [ i ] then
65731: LD_VAR 0 1
65735: PUSH
65736: LD_EXP 112
65740: PUSH
65741: LD_VAR 0 4
65745: ARRAY
65746: IN
65747: IFFALSE 65798
// begin tmp := mc_busy_turret_list [ i ] diff building ;
65749: LD_ADDR_VAR 0 5
65753: PUSH
65754: LD_EXP 112
65758: PUSH
65759: LD_VAR 0 4
65763: ARRAY
65764: PUSH
65765: LD_VAR 0 1
65769: DIFF
65770: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65771: LD_ADDR_EXP 112
65775: PUSH
65776: LD_EXP 112
65780: PPUSH
65781: LD_VAR 0 4
65785: PPUSH
65786: LD_VAR 0 5
65790: PPUSH
65791: CALL_OW 1
65795: ST_TO_ADDR
// break ;
65796: GO 65800
// end ; end ;
65798: GO 65728
65800: POP
65801: POP
// end ;
65802: LD_VAR 0 3
65806: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65807: LD_INT 0
65809: PPUSH
65810: PPUSH
65811: PPUSH
// if not mc_bases or not skirmish then
65812: LD_EXP 102
65816: NOT
65817: PUSH
65818: LD_EXP 100
65822: NOT
65823: OR
65824: IFFALSE 65828
// exit ;
65826: GO 66027
// for i = 1 to mc_bases do
65828: LD_ADDR_VAR 0 5
65832: PUSH
65833: DOUBLE
65834: LD_INT 1
65836: DEC
65837: ST_TO_ADDR
65838: LD_EXP 102
65842: PUSH
65843: FOR_TO
65844: IFFALSE 66025
// if building in mc_bases [ i ] then
65846: LD_VAR 0 1
65850: PUSH
65851: LD_EXP 102
65855: PUSH
65856: LD_VAR 0 5
65860: ARRAY
65861: IN
65862: IFFALSE 66023
// begin tmp := mc_bases [ i ] diff building ;
65864: LD_ADDR_VAR 0 6
65868: PUSH
65869: LD_EXP 102
65873: PUSH
65874: LD_VAR 0 5
65878: ARRAY
65879: PUSH
65880: LD_VAR 0 1
65884: DIFF
65885: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65886: LD_ADDR_EXP 102
65890: PUSH
65891: LD_EXP 102
65895: PPUSH
65896: LD_VAR 0 5
65900: PPUSH
65901: LD_VAR 0 6
65905: PPUSH
65906: CALL_OW 1
65910: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65911: LD_VAR 0 1
65915: PUSH
65916: LD_EXP 110
65920: PUSH
65921: LD_VAR 0 5
65925: ARRAY
65926: IN
65927: IFFALSE 65966
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65929: LD_ADDR_EXP 110
65933: PUSH
65934: LD_EXP 110
65938: PPUSH
65939: LD_VAR 0 5
65943: PPUSH
65944: LD_EXP 110
65948: PUSH
65949: LD_VAR 0 5
65953: ARRAY
65954: PUSH
65955: LD_VAR 0 1
65959: DIFF
65960: PPUSH
65961: CALL_OW 1
65965: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65966: LD_VAR 0 1
65970: PUSH
65971: LD_EXP 111
65975: PUSH
65976: LD_VAR 0 5
65980: ARRAY
65981: IN
65982: IFFALSE 66021
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65984: LD_ADDR_EXP 111
65988: PUSH
65989: LD_EXP 111
65993: PPUSH
65994: LD_VAR 0 5
65998: PPUSH
65999: LD_EXP 111
66003: PUSH
66004: LD_VAR 0 5
66008: ARRAY
66009: PUSH
66010: LD_VAR 0 1
66014: DIFF
66015: PPUSH
66016: CALL_OW 1
66020: ST_TO_ADDR
// break ;
66021: GO 66025
// end ;
66023: GO 65843
66025: POP
66026: POP
// end ;
66027: LD_VAR 0 4
66031: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66032: LD_INT 0
66034: PPUSH
66035: PPUSH
66036: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66037: LD_EXP 102
66041: NOT
66042: PUSH
66043: LD_EXP 100
66047: NOT
66048: OR
66049: PUSH
66050: LD_VAR 0 3
66054: PUSH
66055: LD_EXP 128
66059: IN
66060: NOT
66061: OR
66062: IFFALSE 66066
// exit ;
66064: GO 66189
// for i = 1 to mc_vehicles do
66066: LD_ADDR_VAR 0 6
66070: PUSH
66071: DOUBLE
66072: LD_INT 1
66074: DEC
66075: ST_TO_ADDR
66076: LD_EXP 121
66080: PUSH
66081: FOR_TO
66082: IFFALSE 66187
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66084: LD_VAR 0 2
66088: PUSH
66089: LD_EXP 121
66093: PUSH
66094: LD_VAR 0 6
66098: ARRAY
66099: IN
66100: PUSH
66101: LD_VAR 0 1
66105: PUSH
66106: LD_EXP 121
66110: PUSH
66111: LD_VAR 0 6
66115: ARRAY
66116: IN
66117: OR
66118: IFFALSE 66185
// begin tmp := mc_vehicles [ i ] diff old ;
66120: LD_ADDR_VAR 0 7
66124: PUSH
66125: LD_EXP 121
66129: PUSH
66130: LD_VAR 0 6
66134: ARRAY
66135: PUSH
66136: LD_VAR 0 2
66140: DIFF
66141: ST_TO_ADDR
// tmp := tmp diff new ;
66142: LD_ADDR_VAR 0 7
66146: PUSH
66147: LD_VAR 0 7
66151: PUSH
66152: LD_VAR 0 1
66156: DIFF
66157: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66158: LD_ADDR_EXP 121
66162: PUSH
66163: LD_EXP 121
66167: PPUSH
66168: LD_VAR 0 6
66172: PPUSH
66173: LD_VAR 0 7
66177: PPUSH
66178: CALL_OW 1
66182: ST_TO_ADDR
// break ;
66183: GO 66187
// end ;
66185: GO 66081
66187: POP
66188: POP
// end ;
66189: LD_VAR 0 5
66193: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66194: LD_INT 0
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
// if not mc_bases or not skirmish then
66200: LD_EXP 102
66204: NOT
66205: PUSH
66206: LD_EXP 100
66210: NOT
66211: OR
66212: IFFALSE 66216
// exit ;
66214: GO 66636
// repeat wait ( 0 0$1 ) ;
66216: LD_INT 35
66218: PPUSH
66219: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66223: LD_EXP 146
66227: NOT
66228: IFFALSE 66216
// mc_block_vehicle_constructed_thread := true ;
66230: LD_ADDR_EXP 146
66234: PUSH
66235: LD_INT 1
66237: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66238: LD_ADDR_VAR 0 5
66242: PUSH
66243: LD_VAR 0 1
66247: PPUSH
66248: CALL_OW 255
66252: ST_TO_ADDR
// for i = 1 to mc_bases do
66253: LD_ADDR_VAR 0 4
66257: PUSH
66258: DOUBLE
66259: LD_INT 1
66261: DEC
66262: ST_TO_ADDR
66263: LD_EXP 102
66267: PUSH
66268: FOR_TO
66269: IFFALSE 66626
// begin if factory in mc_bases [ i ] then
66271: LD_VAR 0 2
66275: PUSH
66276: LD_EXP 102
66280: PUSH
66281: LD_VAR 0 4
66285: ARRAY
66286: IN
66287: IFFALSE 66624
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66289: LD_EXP 124
66293: PUSH
66294: LD_VAR 0 4
66298: ARRAY
66299: PUSH
66300: LD_EXP 113
66304: PUSH
66305: LD_VAR 0 4
66309: ARRAY
66310: LESS
66311: PUSH
66312: LD_VAR 0 1
66316: PPUSH
66317: CALL_OW 264
66321: PUSH
66322: LD_INT 31
66324: PUSH
66325: LD_INT 32
66327: PUSH
66328: LD_INT 51
66330: PUSH
66331: LD_INT 89
66333: PUSH
66334: LD_INT 12
66336: PUSH
66337: LD_INT 30
66339: PUSH
66340: LD_INT 98
66342: PUSH
66343: LD_INT 11
66345: PUSH
66346: LD_INT 53
66348: PUSH
66349: LD_INT 14
66351: PUSH
66352: LD_INT 91
66354: PUSH
66355: LD_INT 29
66357: PUSH
66358: LD_INT 99
66360: PUSH
66361: LD_INT 13
66363: PUSH
66364: LD_INT 52
66366: PUSH
66367: LD_INT 88
66369: PUSH
66370: LD_INT 48
66372: PUSH
66373: LD_INT 8
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: IN
66396: NOT
66397: AND
66398: IFFALSE 66446
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66400: LD_ADDR_EXP 124
66404: PUSH
66405: LD_EXP 124
66409: PPUSH
66410: LD_VAR 0 4
66414: PUSH
66415: LD_EXP 124
66419: PUSH
66420: LD_VAR 0 4
66424: ARRAY
66425: PUSH
66426: LD_INT 1
66428: PLUS
66429: PUSH
66430: EMPTY
66431: LIST
66432: LIST
66433: PPUSH
66434: LD_VAR 0 1
66438: PPUSH
66439: CALL 75355 0 3
66443: ST_TO_ADDR
66444: GO 66490
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
66446: LD_ADDR_EXP 121
66450: PUSH
66451: LD_EXP 121
66455: PPUSH
66456: LD_VAR 0 4
66460: PUSH
66461: LD_EXP 121
66465: PUSH
66466: LD_VAR 0 4
66470: ARRAY
66471: PUSH
66472: LD_INT 1
66474: PLUS
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PPUSH
66480: LD_VAR 0 1
66484: PPUSH
66485: CALL 75355 0 3
66489: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
66490: LD_ADDR_EXP 146
66494: PUSH
66495: LD_INT 0
66497: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
66498: LD_VAR 0 1
66502: PPUSH
66503: CALL_OW 263
66507: PUSH
66508: LD_INT 2
66510: EQUAL
66511: IFFALSE 66540
// begin repeat wait ( 0 0$3 ) ;
66513: LD_INT 105
66515: PPUSH
66516: CALL_OW 67
// Connect ( vehicle ) ;
66520: LD_VAR 0 1
66524: PPUSH
66525: CALL 78701 0 1
// until IsControledBy ( vehicle ) ;
66529: LD_VAR 0 1
66533: PPUSH
66534: CALL_OW 312
66538: IFFALSE 66513
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
66540: LD_VAR 0 1
66544: PPUSH
66545: LD_EXP 126
66549: PUSH
66550: LD_VAR 0 4
66554: ARRAY
66555: PPUSH
66556: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
66560: LD_VAR 0 1
66564: PPUSH
66565: CALL_OW 263
66569: PUSH
66570: LD_INT 1
66572: NONEQUAL
66573: IFFALSE 66577
// break ;
66575: GO 66626
// repeat wait ( 0 0$1 ) ;
66577: LD_INT 35
66579: PPUSH
66580: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
66584: LD_VAR 0 1
66588: PPUSH
66589: LD_EXP 126
66593: PUSH
66594: LD_VAR 0 4
66598: ARRAY
66599: PPUSH
66600: CALL_OW 308
66604: IFFALSE 66577
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
66606: LD_VAR 0 1
66610: PPUSH
66611: CALL_OW 311
66615: PPUSH
66616: CALL_OW 121
// exit ;
66620: POP
66621: POP
66622: GO 66636
// end ; end ;
66624: GO 66268
66626: POP
66627: POP
// mc_block_vehicle_constructed_thread := false ;
66628: LD_ADDR_EXP 146
66632: PUSH
66633: LD_INT 0
66635: ST_TO_ADDR
// end ;
66636: LD_VAR 0 3
66640: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
66641: LD_INT 0
66643: PPUSH
66644: PPUSH
66645: PPUSH
66646: PPUSH
// if not mc_bases or not skirmish then
66647: LD_EXP 102
66651: NOT
66652: PUSH
66653: LD_EXP 100
66657: NOT
66658: OR
66659: IFFALSE 66663
// exit ;
66661: GO 67016
// repeat wait ( 0 0$1 ) ;
66663: LD_INT 35
66665: PPUSH
66666: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
66670: LD_VAR 0 2
66674: PPUSH
66675: LD_VAR 0 3
66679: PPUSH
66680: CALL_OW 284
66684: IFFALSE 66663
// if GetResourceTypeXY ( x , y ) = mat_artefact then
66686: LD_VAR 0 2
66690: PPUSH
66691: LD_VAR 0 3
66695: PPUSH
66696: CALL_OW 283
66700: PUSH
66701: LD_INT 4
66703: EQUAL
66704: IFFALSE 66708
// exit ;
66706: GO 67016
// for i = 1 to mc_bases do
66708: LD_ADDR_VAR 0 7
66712: PUSH
66713: DOUBLE
66714: LD_INT 1
66716: DEC
66717: ST_TO_ADDR
66718: LD_EXP 102
66722: PUSH
66723: FOR_TO
66724: IFFALSE 67014
// begin if mc_crates_area [ i ] then
66726: LD_EXP 120
66730: PUSH
66731: LD_VAR 0 7
66735: ARRAY
66736: IFFALSE 66847
// for j in mc_crates_area [ i ] do
66738: LD_ADDR_VAR 0 8
66742: PUSH
66743: LD_EXP 120
66747: PUSH
66748: LD_VAR 0 7
66752: ARRAY
66753: PUSH
66754: FOR_IN
66755: IFFALSE 66845
// if InArea ( x , y , j ) then
66757: LD_VAR 0 2
66761: PPUSH
66762: LD_VAR 0 3
66766: PPUSH
66767: LD_VAR 0 8
66771: PPUSH
66772: CALL_OW 309
66776: IFFALSE 66843
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66778: LD_ADDR_EXP 118
66782: PUSH
66783: LD_EXP 118
66787: PPUSH
66788: LD_VAR 0 7
66792: PUSH
66793: LD_EXP 118
66797: PUSH
66798: LD_VAR 0 7
66802: ARRAY
66803: PUSH
66804: LD_INT 1
66806: PLUS
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PPUSH
66812: LD_VAR 0 4
66816: PUSH
66817: LD_VAR 0 2
66821: PUSH
66822: LD_VAR 0 3
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: LIST
66831: PPUSH
66832: CALL 75355 0 3
66836: ST_TO_ADDR
// exit ;
66837: POP
66838: POP
66839: POP
66840: POP
66841: GO 67016
// end ;
66843: GO 66754
66845: POP
66846: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66847: LD_ADDR_VAR 0 9
66851: PUSH
66852: LD_EXP 102
66856: PUSH
66857: LD_VAR 0 7
66861: ARRAY
66862: PPUSH
66863: LD_INT 2
66865: PUSH
66866: LD_INT 30
66868: PUSH
66869: LD_INT 0
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 30
66878: PUSH
66879: LD_INT 1
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: LIST
66890: PPUSH
66891: CALL_OW 72
66895: ST_TO_ADDR
// if not depot then
66896: LD_VAR 0 9
66900: NOT
66901: IFFALSE 66905
// continue ;
66903: GO 66723
// for j in depot do
66905: LD_ADDR_VAR 0 8
66909: PUSH
66910: LD_VAR 0 9
66914: PUSH
66915: FOR_IN
66916: IFFALSE 67010
// if GetDistUnitXY ( j , x , y ) < 30 then
66918: LD_VAR 0 8
66922: PPUSH
66923: LD_VAR 0 2
66927: PPUSH
66928: LD_VAR 0 3
66932: PPUSH
66933: CALL_OW 297
66937: PUSH
66938: LD_INT 30
66940: LESS
66941: IFFALSE 67008
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66943: LD_ADDR_EXP 118
66947: PUSH
66948: LD_EXP 118
66952: PPUSH
66953: LD_VAR 0 7
66957: PUSH
66958: LD_EXP 118
66962: PUSH
66963: LD_VAR 0 7
66967: ARRAY
66968: PUSH
66969: LD_INT 1
66971: PLUS
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PPUSH
66977: LD_VAR 0 4
66981: PUSH
66982: LD_VAR 0 2
66986: PUSH
66987: LD_VAR 0 3
66991: PUSH
66992: EMPTY
66993: LIST
66994: LIST
66995: LIST
66996: PPUSH
66997: CALL 75355 0 3
67001: ST_TO_ADDR
// exit ;
67002: POP
67003: POP
67004: POP
67005: POP
67006: GO 67016
// end ;
67008: GO 66915
67010: POP
67011: POP
// end ;
67012: GO 66723
67014: POP
67015: POP
// end ;
67016: LD_VAR 0 6
67020: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
67021: LD_INT 0
67023: PPUSH
67024: PPUSH
67025: PPUSH
67026: PPUSH
// if not mc_bases or not skirmish then
67027: LD_EXP 102
67031: NOT
67032: PUSH
67033: LD_EXP 100
67037: NOT
67038: OR
67039: IFFALSE 67043
// exit ;
67041: GO 67320
// side := GetSide ( lab ) ;
67043: LD_ADDR_VAR 0 4
67047: PUSH
67048: LD_VAR 0 2
67052: PPUSH
67053: CALL_OW 255
67057: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67058: LD_VAR 0 4
67062: PUSH
67063: LD_EXP 128
67067: IN
67068: NOT
67069: PUSH
67070: LD_EXP 129
67074: NOT
67075: OR
67076: PUSH
67077: LD_EXP 102
67081: NOT
67082: OR
67083: IFFALSE 67087
// exit ;
67085: GO 67320
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67087: LD_ADDR_EXP 129
67091: PUSH
67092: LD_EXP 129
67096: PPUSH
67097: LD_VAR 0 4
67101: PPUSH
67102: LD_EXP 129
67106: PUSH
67107: LD_VAR 0 4
67111: ARRAY
67112: PUSH
67113: LD_VAR 0 1
67117: DIFF
67118: PPUSH
67119: CALL_OW 1
67123: ST_TO_ADDR
// for i = 1 to mc_bases do
67124: LD_ADDR_VAR 0 5
67128: PUSH
67129: DOUBLE
67130: LD_INT 1
67132: DEC
67133: ST_TO_ADDR
67134: LD_EXP 102
67138: PUSH
67139: FOR_TO
67140: IFFALSE 67318
// begin if lab in mc_bases [ i ] then
67142: LD_VAR 0 2
67146: PUSH
67147: LD_EXP 102
67151: PUSH
67152: LD_VAR 0 5
67156: ARRAY
67157: IN
67158: IFFALSE 67316
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67160: LD_VAR 0 1
67164: PUSH
67165: LD_INT 11
67167: PUSH
67168: LD_INT 4
67170: PUSH
67171: LD_INT 3
67173: PUSH
67174: LD_INT 2
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: IN
67183: PUSH
67184: LD_EXP 132
67188: PUSH
67189: LD_VAR 0 5
67193: ARRAY
67194: AND
67195: IFFALSE 67316
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67197: LD_ADDR_VAR 0 6
67201: PUSH
67202: LD_EXP 132
67206: PUSH
67207: LD_VAR 0 5
67211: ARRAY
67212: PUSH
67213: LD_INT 1
67215: ARRAY
67216: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67217: LD_ADDR_EXP 132
67221: PUSH
67222: LD_EXP 132
67226: PPUSH
67227: LD_VAR 0 5
67231: PPUSH
67232: EMPTY
67233: PPUSH
67234: CALL_OW 1
67238: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67239: LD_VAR 0 6
67243: PPUSH
67244: LD_INT 0
67246: PPUSH
67247: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67251: LD_VAR 0 6
67255: PPUSH
67256: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67260: LD_ADDR_EXP 131
67264: PUSH
67265: LD_EXP 131
67269: PPUSH
67270: LD_VAR 0 5
67274: PPUSH
67275: LD_EXP 131
67279: PUSH
67280: LD_VAR 0 5
67284: ARRAY
67285: PPUSH
67286: LD_INT 1
67288: PPUSH
67289: LD_VAR 0 6
67293: PPUSH
67294: CALL_OW 2
67298: PPUSH
67299: CALL_OW 1
67303: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67304: LD_VAR 0 5
67308: PPUSH
67309: LD_INT 112
67311: PPUSH
67312: CALL 43770 0 2
// end ; end ; end ;
67316: GO 67139
67318: POP
67319: POP
// end ;
67320: LD_VAR 0 3
67324: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67325: LD_INT 0
67327: PPUSH
67328: PPUSH
67329: PPUSH
67330: PPUSH
67331: PPUSH
67332: PPUSH
67333: PPUSH
67334: PPUSH
// if not mc_bases or not skirmish then
67335: LD_EXP 102
67339: NOT
67340: PUSH
67341: LD_EXP 100
67345: NOT
67346: OR
67347: IFFALSE 67351
// exit ;
67349: GO 68720
// for i = 1 to mc_bases do
67351: LD_ADDR_VAR 0 3
67355: PUSH
67356: DOUBLE
67357: LD_INT 1
67359: DEC
67360: ST_TO_ADDR
67361: LD_EXP 102
67365: PUSH
67366: FOR_TO
67367: IFFALSE 68718
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67369: LD_VAR 0 1
67373: PUSH
67374: LD_EXP 102
67378: PUSH
67379: LD_VAR 0 3
67383: ARRAY
67384: IN
67385: PUSH
67386: LD_VAR 0 1
67390: PUSH
67391: LD_EXP 109
67395: PUSH
67396: LD_VAR 0 3
67400: ARRAY
67401: IN
67402: OR
67403: PUSH
67404: LD_VAR 0 1
67408: PUSH
67409: LD_EXP 124
67413: PUSH
67414: LD_VAR 0 3
67418: ARRAY
67419: IN
67420: OR
67421: PUSH
67422: LD_VAR 0 1
67426: PUSH
67427: LD_EXP 121
67431: PUSH
67432: LD_VAR 0 3
67436: ARRAY
67437: IN
67438: OR
67439: PUSH
67440: LD_VAR 0 1
67444: PUSH
67445: LD_EXP 131
67449: PUSH
67450: LD_VAR 0 3
67454: ARRAY
67455: IN
67456: OR
67457: PUSH
67458: LD_VAR 0 1
67462: PUSH
67463: LD_EXP 132
67467: PUSH
67468: LD_VAR 0 3
67472: ARRAY
67473: IN
67474: OR
67475: IFFALSE 68716
// begin if un in mc_ape [ i ] then
67477: LD_VAR 0 1
67481: PUSH
67482: LD_EXP 131
67486: PUSH
67487: LD_VAR 0 3
67491: ARRAY
67492: IN
67493: IFFALSE 67532
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
67495: LD_ADDR_EXP 131
67499: PUSH
67500: LD_EXP 131
67504: PPUSH
67505: LD_VAR 0 3
67509: PPUSH
67510: LD_EXP 131
67514: PUSH
67515: LD_VAR 0 3
67519: ARRAY
67520: PUSH
67521: LD_VAR 0 1
67525: DIFF
67526: PPUSH
67527: CALL_OW 1
67531: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
67532: LD_VAR 0 1
67536: PUSH
67537: LD_EXP 132
67541: PUSH
67542: LD_VAR 0 3
67546: ARRAY
67547: IN
67548: IFFALSE 67572
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67550: LD_ADDR_EXP 132
67554: PUSH
67555: LD_EXP 132
67559: PPUSH
67560: LD_VAR 0 3
67564: PPUSH
67565: EMPTY
67566: PPUSH
67567: CALL_OW 1
67571: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
67572: LD_VAR 0 1
67576: PPUSH
67577: CALL_OW 247
67581: PUSH
67582: LD_INT 2
67584: EQUAL
67585: PUSH
67586: LD_VAR 0 1
67590: PPUSH
67591: CALL_OW 110
67595: PUSH
67596: LD_INT 20
67598: EQUAL
67599: PUSH
67600: LD_VAR 0 1
67604: PUSH
67605: LD_EXP 124
67609: PUSH
67610: LD_VAR 0 3
67614: ARRAY
67615: IN
67616: OR
67617: PUSH
67618: LD_VAR 0 1
67622: PPUSH
67623: CALL_OW 264
67627: PUSH
67628: LD_INT 12
67630: PUSH
67631: LD_INT 51
67633: PUSH
67634: LD_INT 89
67636: PUSH
67637: LD_INT 32
67639: PUSH
67640: LD_INT 13
67642: PUSH
67643: LD_INT 52
67645: PUSH
67646: LD_INT 31
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: IN
67658: OR
67659: AND
67660: IFFALSE 67968
// begin if un in mc_defender [ i ] then
67662: LD_VAR 0 1
67666: PUSH
67667: LD_EXP 124
67671: PUSH
67672: LD_VAR 0 3
67676: ARRAY
67677: IN
67678: IFFALSE 67717
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67680: LD_ADDR_EXP 124
67684: PUSH
67685: LD_EXP 124
67689: PPUSH
67690: LD_VAR 0 3
67694: PPUSH
67695: LD_EXP 124
67699: PUSH
67700: LD_VAR 0 3
67704: ARRAY
67705: PUSH
67706: LD_VAR 0 1
67710: DIFF
67711: PPUSH
67712: CALL_OW 1
67716: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
67717: LD_ADDR_VAR 0 8
67721: PUSH
67722: LD_VAR 0 3
67726: PPUSH
67727: LD_INT 3
67729: PPUSH
67730: CALL 64338 0 2
67734: ST_TO_ADDR
// if fac then
67735: LD_VAR 0 8
67739: IFFALSE 67968
// begin for j in fac do
67741: LD_ADDR_VAR 0 4
67745: PUSH
67746: LD_VAR 0 8
67750: PUSH
67751: FOR_IN
67752: IFFALSE 67966
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
67754: LD_ADDR_VAR 0 9
67758: PUSH
67759: LD_VAR 0 8
67763: PPUSH
67764: LD_VAR 0 1
67768: PPUSH
67769: CALL_OW 265
67773: PPUSH
67774: LD_VAR 0 1
67778: PPUSH
67779: CALL_OW 262
67783: PPUSH
67784: LD_VAR 0 1
67788: PPUSH
67789: CALL_OW 263
67793: PPUSH
67794: LD_VAR 0 1
67798: PPUSH
67799: CALL_OW 264
67803: PPUSH
67804: CALL 72853 0 5
67808: ST_TO_ADDR
// if components then
67809: LD_VAR 0 9
67813: IFFALSE 67964
// begin if GetWeapon ( un ) = ar_control_tower then
67815: LD_VAR 0 1
67819: PPUSH
67820: CALL_OW 264
67824: PUSH
67825: LD_INT 31
67827: EQUAL
67828: IFFALSE 67945
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67830: LD_VAR 0 1
67834: PPUSH
67835: CALL_OW 311
67839: PPUSH
67840: LD_INT 0
67842: PPUSH
67843: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67847: LD_ADDR_EXP 142
67851: PUSH
67852: LD_EXP 142
67856: PPUSH
67857: LD_VAR 0 3
67861: PPUSH
67862: LD_EXP 142
67866: PUSH
67867: LD_VAR 0 3
67871: ARRAY
67872: PUSH
67873: LD_VAR 0 1
67877: PPUSH
67878: CALL_OW 311
67882: DIFF
67883: PPUSH
67884: CALL_OW 1
67888: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67889: LD_ADDR_VAR 0 7
67893: PUSH
67894: LD_EXP 123
67898: PUSH
67899: LD_VAR 0 3
67903: ARRAY
67904: PPUSH
67905: LD_INT 1
67907: PPUSH
67908: LD_VAR 0 9
67912: PPUSH
67913: CALL_OW 2
67917: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67918: LD_ADDR_EXP 123
67922: PUSH
67923: LD_EXP 123
67927: PPUSH
67928: LD_VAR 0 3
67932: PPUSH
67933: LD_VAR 0 7
67937: PPUSH
67938: CALL_OW 1
67942: ST_TO_ADDR
// end else
67943: GO 67962
// MC_InsertProduceList ( i , [ components ] ) ;
67945: LD_VAR 0 3
67949: PPUSH
67950: LD_VAR 0 9
67954: PUSH
67955: EMPTY
67956: LIST
67957: PPUSH
67958: CALL 63883 0 2
// break ;
67962: GO 67966
// end ; end ;
67964: GO 67751
67966: POP
67967: POP
// end ; end ; if GetType ( un ) = unit_building then
67968: LD_VAR 0 1
67972: PPUSH
67973: CALL_OW 247
67977: PUSH
67978: LD_INT 3
67980: EQUAL
67981: IFFALSE 68384
// begin btype := GetBType ( un ) ;
67983: LD_ADDR_VAR 0 5
67987: PUSH
67988: LD_VAR 0 1
67992: PPUSH
67993: CALL_OW 266
67997: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67998: LD_VAR 0 5
68002: PUSH
68003: LD_INT 29
68005: PUSH
68006: LD_INT 30
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: IN
68013: IFFALSE 68086
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
68015: LD_VAR 0 1
68019: PPUSH
68020: CALL_OW 250
68024: PPUSH
68025: LD_VAR 0 1
68029: PPUSH
68030: CALL_OW 251
68034: PPUSH
68035: LD_VAR 0 1
68039: PPUSH
68040: CALL_OW 255
68044: PPUSH
68045: CALL_OW 440
68049: NOT
68050: IFFALSE 68086
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68052: LD_VAR 0 1
68056: PPUSH
68057: CALL_OW 250
68061: PPUSH
68062: LD_VAR 0 1
68066: PPUSH
68067: CALL_OW 251
68071: PPUSH
68072: LD_VAR 0 1
68076: PPUSH
68077: CALL_OW 255
68081: PPUSH
68082: CALL_OW 441
// end ; if btype = b_warehouse then
68086: LD_VAR 0 5
68090: PUSH
68091: LD_INT 1
68093: EQUAL
68094: IFFALSE 68112
// begin btype := b_depot ;
68096: LD_ADDR_VAR 0 5
68100: PUSH
68101: LD_INT 0
68103: ST_TO_ADDR
// pos := 1 ;
68104: LD_ADDR_VAR 0 6
68108: PUSH
68109: LD_INT 1
68111: ST_TO_ADDR
// end ; if btype = b_factory then
68112: LD_VAR 0 5
68116: PUSH
68117: LD_INT 3
68119: EQUAL
68120: IFFALSE 68138
// begin btype := b_workshop ;
68122: LD_ADDR_VAR 0 5
68126: PUSH
68127: LD_INT 2
68129: ST_TO_ADDR
// pos := 1 ;
68130: LD_ADDR_VAR 0 6
68134: PUSH
68135: LD_INT 1
68137: ST_TO_ADDR
// end ; if btype = b_barracks then
68138: LD_VAR 0 5
68142: PUSH
68143: LD_INT 5
68145: EQUAL
68146: IFFALSE 68156
// btype := b_armoury ;
68148: LD_ADDR_VAR 0 5
68152: PUSH
68153: LD_INT 4
68155: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68156: LD_VAR 0 5
68160: PUSH
68161: LD_INT 7
68163: PUSH
68164: LD_INT 8
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: IN
68171: IFFALSE 68181
// btype := b_lab ;
68173: LD_ADDR_VAR 0 5
68177: PUSH
68178: LD_INT 6
68180: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68181: LD_ADDR_EXP 107
68185: PUSH
68186: LD_EXP 107
68190: PPUSH
68191: LD_VAR 0 3
68195: PUSH
68196: LD_EXP 107
68200: PUSH
68201: LD_VAR 0 3
68205: ARRAY
68206: PUSH
68207: LD_INT 1
68209: PLUS
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PPUSH
68215: LD_VAR 0 5
68219: PUSH
68220: LD_VAR 0 1
68224: PPUSH
68225: CALL_OW 250
68229: PUSH
68230: LD_VAR 0 1
68234: PPUSH
68235: CALL_OW 251
68239: PUSH
68240: LD_VAR 0 1
68244: PPUSH
68245: CALL_OW 254
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: LIST
68254: LIST
68255: PPUSH
68256: CALL 75355 0 3
68260: ST_TO_ADDR
// if pos = 1 then
68261: LD_VAR 0 6
68265: PUSH
68266: LD_INT 1
68268: EQUAL
68269: IFFALSE 68384
// begin tmp := mc_build_list [ i ] ;
68271: LD_ADDR_VAR 0 7
68275: PUSH
68276: LD_EXP 107
68280: PUSH
68281: LD_VAR 0 3
68285: ARRAY
68286: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68287: LD_VAR 0 7
68291: PPUSH
68292: LD_INT 2
68294: PUSH
68295: LD_INT 30
68297: PUSH
68298: LD_INT 0
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PUSH
68305: LD_INT 30
68307: PUSH
68308: LD_INT 1
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: LIST
68319: PPUSH
68320: CALL_OW 72
68324: IFFALSE 68334
// pos := 2 ;
68326: LD_ADDR_VAR 0 6
68330: PUSH
68331: LD_INT 2
68333: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68334: LD_ADDR_VAR 0 7
68338: PUSH
68339: LD_VAR 0 7
68343: PPUSH
68344: LD_VAR 0 6
68348: PPUSH
68349: LD_VAR 0 7
68353: PPUSH
68354: CALL 75681 0 3
68358: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68359: LD_ADDR_EXP 107
68363: PUSH
68364: LD_EXP 107
68368: PPUSH
68369: LD_VAR 0 3
68373: PPUSH
68374: LD_VAR 0 7
68378: PPUSH
68379: CALL_OW 1
68383: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68384: LD_VAR 0 1
68388: PUSH
68389: LD_EXP 102
68393: PUSH
68394: LD_VAR 0 3
68398: ARRAY
68399: IN
68400: IFFALSE 68439
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
68402: LD_ADDR_EXP 102
68406: PUSH
68407: LD_EXP 102
68411: PPUSH
68412: LD_VAR 0 3
68416: PPUSH
68417: LD_EXP 102
68421: PUSH
68422: LD_VAR 0 3
68426: ARRAY
68427: PUSH
68428: LD_VAR 0 1
68432: DIFF
68433: PPUSH
68434: CALL_OW 1
68438: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
68439: LD_VAR 0 1
68443: PUSH
68444: LD_EXP 109
68448: PUSH
68449: LD_VAR 0 3
68453: ARRAY
68454: IN
68455: IFFALSE 68494
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
68457: LD_ADDR_EXP 109
68461: PUSH
68462: LD_EXP 109
68466: PPUSH
68467: LD_VAR 0 3
68471: PPUSH
68472: LD_EXP 109
68476: PUSH
68477: LD_VAR 0 3
68481: ARRAY
68482: PUSH
68483: LD_VAR 0 1
68487: DIFF
68488: PPUSH
68489: CALL_OW 1
68493: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
68494: LD_VAR 0 1
68498: PUSH
68499: LD_EXP 121
68503: PUSH
68504: LD_VAR 0 3
68508: ARRAY
68509: IN
68510: IFFALSE 68549
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
68512: LD_ADDR_EXP 121
68516: PUSH
68517: LD_EXP 121
68521: PPUSH
68522: LD_VAR 0 3
68526: PPUSH
68527: LD_EXP 121
68531: PUSH
68532: LD_VAR 0 3
68536: ARRAY
68537: PUSH
68538: LD_VAR 0 1
68542: DIFF
68543: PPUSH
68544: CALL_OW 1
68548: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
68549: LD_VAR 0 1
68553: PUSH
68554: LD_EXP 124
68558: PUSH
68559: LD_VAR 0 3
68563: ARRAY
68564: IN
68565: IFFALSE 68604
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68567: LD_ADDR_EXP 124
68571: PUSH
68572: LD_EXP 124
68576: PPUSH
68577: LD_VAR 0 3
68581: PPUSH
68582: LD_EXP 124
68586: PUSH
68587: LD_VAR 0 3
68591: ARRAY
68592: PUSH
68593: LD_VAR 0 1
68597: DIFF
68598: PPUSH
68599: CALL_OW 1
68603: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
68604: LD_VAR 0 1
68608: PUSH
68609: LD_EXP 111
68613: PUSH
68614: LD_VAR 0 3
68618: ARRAY
68619: IN
68620: IFFALSE 68659
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
68622: LD_ADDR_EXP 111
68626: PUSH
68627: LD_EXP 111
68631: PPUSH
68632: LD_VAR 0 3
68636: PPUSH
68637: LD_EXP 111
68641: PUSH
68642: LD_VAR 0 3
68646: ARRAY
68647: PUSH
68648: LD_VAR 0 1
68652: DIFF
68653: PPUSH
68654: CALL_OW 1
68658: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
68659: LD_VAR 0 1
68663: PUSH
68664: LD_EXP 110
68668: PUSH
68669: LD_VAR 0 3
68673: ARRAY
68674: IN
68675: IFFALSE 68714
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
68677: LD_ADDR_EXP 110
68681: PUSH
68682: LD_EXP 110
68686: PPUSH
68687: LD_VAR 0 3
68691: PPUSH
68692: LD_EXP 110
68696: PUSH
68697: LD_VAR 0 3
68701: ARRAY
68702: PUSH
68703: LD_VAR 0 1
68707: DIFF
68708: PPUSH
68709: CALL_OW 1
68713: ST_TO_ADDR
// end ; break ;
68714: GO 68718
// end ;
68716: GO 67366
68718: POP
68719: POP
// end ;
68720: LD_VAR 0 2
68724: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
68725: LD_INT 0
68727: PPUSH
68728: PPUSH
68729: PPUSH
// if not mc_bases or not skirmish then
68730: LD_EXP 102
68734: NOT
68735: PUSH
68736: LD_EXP 100
68740: NOT
68741: OR
68742: IFFALSE 68746
// exit ;
68744: GO 68961
// for i = 1 to mc_bases do
68746: LD_ADDR_VAR 0 3
68750: PUSH
68751: DOUBLE
68752: LD_INT 1
68754: DEC
68755: ST_TO_ADDR
68756: LD_EXP 102
68760: PUSH
68761: FOR_TO
68762: IFFALSE 68959
// begin if building in mc_construct_list [ i ] then
68764: LD_VAR 0 1
68768: PUSH
68769: LD_EXP 109
68773: PUSH
68774: LD_VAR 0 3
68778: ARRAY
68779: IN
68780: IFFALSE 68957
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68782: LD_ADDR_EXP 109
68786: PUSH
68787: LD_EXP 109
68791: PPUSH
68792: LD_VAR 0 3
68796: PPUSH
68797: LD_EXP 109
68801: PUSH
68802: LD_VAR 0 3
68806: ARRAY
68807: PUSH
68808: LD_VAR 0 1
68812: DIFF
68813: PPUSH
68814: CALL_OW 1
68818: ST_TO_ADDR
// if building in mc_lab [ i ] then
68819: LD_VAR 0 1
68823: PUSH
68824: LD_EXP 135
68828: PUSH
68829: LD_VAR 0 3
68833: ARRAY
68834: IN
68835: IFFALSE 68890
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68837: LD_ADDR_EXP 136
68841: PUSH
68842: LD_EXP 136
68846: PPUSH
68847: LD_VAR 0 3
68851: PPUSH
68852: LD_EXP 136
68856: PUSH
68857: LD_VAR 0 3
68861: ARRAY
68862: PPUSH
68863: LD_INT 1
68865: PPUSH
68866: LD_EXP 136
68870: PUSH
68871: LD_VAR 0 3
68875: ARRAY
68876: PPUSH
68877: LD_INT 0
68879: PPUSH
68880: CALL 74773 0 4
68884: PPUSH
68885: CALL_OW 1
68889: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68890: LD_VAR 0 1
68894: PUSH
68895: LD_EXP 102
68899: PUSH
68900: LD_VAR 0 3
68904: ARRAY
68905: IN
68906: NOT
68907: IFFALSE 68953
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68909: LD_ADDR_EXP 102
68913: PUSH
68914: LD_EXP 102
68918: PPUSH
68919: LD_VAR 0 3
68923: PUSH
68924: LD_EXP 102
68928: PUSH
68929: LD_VAR 0 3
68933: ARRAY
68934: PUSH
68935: LD_INT 1
68937: PLUS
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PPUSH
68943: LD_VAR 0 1
68947: PPUSH
68948: CALL 75355 0 3
68952: ST_TO_ADDR
// exit ;
68953: POP
68954: POP
68955: GO 68961
// end ; end ;
68957: GO 68761
68959: POP
68960: POP
// end ;
68961: LD_VAR 0 2
68965: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68966: LD_INT 0
68968: PPUSH
68969: PPUSH
68970: PPUSH
68971: PPUSH
68972: PPUSH
68973: PPUSH
68974: PPUSH
// if not mc_bases or not skirmish then
68975: LD_EXP 102
68979: NOT
68980: PUSH
68981: LD_EXP 100
68985: NOT
68986: OR
68987: IFFALSE 68991
// exit ;
68989: GO 69652
// for i = 1 to mc_bases do
68991: LD_ADDR_VAR 0 3
68995: PUSH
68996: DOUBLE
68997: LD_INT 1
68999: DEC
69000: ST_TO_ADDR
69001: LD_EXP 102
69005: PUSH
69006: FOR_TO
69007: IFFALSE 69650
// begin if building in mc_construct_list [ i ] then
69009: LD_VAR 0 1
69013: PUSH
69014: LD_EXP 109
69018: PUSH
69019: LD_VAR 0 3
69023: ARRAY
69024: IN
69025: IFFALSE 69648
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69027: LD_ADDR_EXP 109
69031: PUSH
69032: LD_EXP 109
69036: PPUSH
69037: LD_VAR 0 3
69041: PPUSH
69042: LD_EXP 109
69046: PUSH
69047: LD_VAR 0 3
69051: ARRAY
69052: PUSH
69053: LD_VAR 0 1
69057: DIFF
69058: PPUSH
69059: CALL_OW 1
69063: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69064: LD_ADDR_EXP 102
69068: PUSH
69069: LD_EXP 102
69073: PPUSH
69074: LD_VAR 0 3
69078: PUSH
69079: LD_EXP 102
69083: PUSH
69084: LD_VAR 0 3
69088: ARRAY
69089: PUSH
69090: LD_INT 1
69092: PLUS
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PPUSH
69098: LD_VAR 0 1
69102: PPUSH
69103: CALL 75355 0 3
69107: ST_TO_ADDR
// btype := GetBType ( building ) ;
69108: LD_ADDR_VAR 0 5
69112: PUSH
69113: LD_VAR 0 1
69117: PPUSH
69118: CALL_OW 266
69122: ST_TO_ADDR
// side := GetSide ( building ) ;
69123: LD_ADDR_VAR 0 8
69127: PUSH
69128: LD_VAR 0 1
69132: PPUSH
69133: CALL_OW 255
69137: ST_TO_ADDR
// if btype = b_lab then
69138: LD_VAR 0 5
69142: PUSH
69143: LD_INT 6
69145: EQUAL
69146: IFFALSE 69196
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69148: LD_ADDR_EXP 135
69152: PUSH
69153: LD_EXP 135
69157: PPUSH
69158: LD_VAR 0 3
69162: PUSH
69163: LD_EXP 135
69167: PUSH
69168: LD_VAR 0 3
69172: ARRAY
69173: PUSH
69174: LD_INT 1
69176: PLUS
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PPUSH
69182: LD_VAR 0 1
69186: PPUSH
69187: CALL 75355 0 3
69191: ST_TO_ADDR
// exit ;
69192: POP
69193: POP
69194: GO 69652
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69196: LD_VAR 0 5
69200: PUSH
69201: LD_INT 0
69203: PUSH
69204: LD_INT 2
69206: PUSH
69207: LD_INT 4
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: LIST
69214: IN
69215: IFFALSE 69339
// begin if btype = b_armoury then
69217: LD_VAR 0 5
69221: PUSH
69222: LD_INT 4
69224: EQUAL
69225: IFFALSE 69235
// btype := b_barracks ;
69227: LD_ADDR_VAR 0 5
69231: PUSH
69232: LD_INT 5
69234: ST_TO_ADDR
// if btype = b_depot then
69235: LD_VAR 0 5
69239: PUSH
69240: LD_INT 0
69242: EQUAL
69243: IFFALSE 69253
// btype := b_warehouse ;
69245: LD_ADDR_VAR 0 5
69249: PUSH
69250: LD_INT 1
69252: ST_TO_ADDR
// if btype = b_workshop then
69253: LD_VAR 0 5
69257: PUSH
69258: LD_INT 2
69260: EQUAL
69261: IFFALSE 69271
// btype := b_factory ;
69263: LD_ADDR_VAR 0 5
69267: PUSH
69268: LD_INT 3
69270: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69271: LD_VAR 0 5
69275: PPUSH
69276: LD_VAR 0 8
69280: PPUSH
69281: CALL_OW 323
69285: PUSH
69286: LD_INT 1
69288: EQUAL
69289: IFFALSE 69335
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69291: LD_ADDR_EXP 134
69295: PUSH
69296: LD_EXP 134
69300: PPUSH
69301: LD_VAR 0 3
69305: PUSH
69306: LD_EXP 134
69310: PUSH
69311: LD_VAR 0 3
69315: ARRAY
69316: PUSH
69317: LD_INT 1
69319: PLUS
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PPUSH
69325: LD_VAR 0 1
69329: PPUSH
69330: CALL 75355 0 3
69334: ST_TO_ADDR
// exit ;
69335: POP
69336: POP
69337: GO 69652
// end ; if btype in [ b_bunker , b_turret ] then
69339: LD_VAR 0 5
69343: PUSH
69344: LD_INT 32
69346: PUSH
69347: LD_INT 33
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: IN
69354: IFFALSE 69644
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69356: LD_ADDR_EXP 110
69360: PUSH
69361: LD_EXP 110
69365: PPUSH
69366: LD_VAR 0 3
69370: PUSH
69371: LD_EXP 110
69375: PUSH
69376: LD_VAR 0 3
69380: ARRAY
69381: PUSH
69382: LD_INT 1
69384: PLUS
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PPUSH
69390: LD_VAR 0 1
69394: PPUSH
69395: CALL 75355 0 3
69399: ST_TO_ADDR
// if btype = b_bunker then
69400: LD_VAR 0 5
69404: PUSH
69405: LD_INT 32
69407: EQUAL
69408: IFFALSE 69644
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69410: LD_ADDR_EXP 111
69414: PUSH
69415: LD_EXP 111
69419: PPUSH
69420: LD_VAR 0 3
69424: PUSH
69425: LD_EXP 111
69429: PUSH
69430: LD_VAR 0 3
69434: ARRAY
69435: PUSH
69436: LD_INT 1
69438: PLUS
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: PPUSH
69444: LD_VAR 0 1
69448: PPUSH
69449: CALL 75355 0 3
69453: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
69454: LD_ADDR_VAR 0 6
69458: PUSH
69459: LD_EXP 102
69463: PUSH
69464: LD_VAR 0 3
69468: ARRAY
69469: PPUSH
69470: LD_INT 25
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 3
69482: PUSH
69483: LD_INT 54
69485: PUSH
69486: EMPTY
69487: LIST
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PPUSH
69497: CALL_OW 72
69501: ST_TO_ADDR
// if tmp then
69502: LD_VAR 0 6
69506: IFFALSE 69512
// exit ;
69508: POP
69509: POP
69510: GO 69652
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69512: LD_ADDR_VAR 0 6
69516: PUSH
69517: LD_EXP 102
69521: PUSH
69522: LD_VAR 0 3
69526: ARRAY
69527: PPUSH
69528: LD_INT 2
69530: PUSH
69531: LD_INT 30
69533: PUSH
69534: LD_INT 4
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 30
69543: PUSH
69544: LD_INT 5
69546: PUSH
69547: EMPTY
69548: LIST
69549: LIST
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: LIST
69555: PPUSH
69556: CALL_OW 72
69560: ST_TO_ADDR
// if not tmp then
69561: LD_VAR 0 6
69565: NOT
69566: IFFALSE 69572
// exit ;
69568: POP
69569: POP
69570: GO 69652
// for j in tmp do
69572: LD_ADDR_VAR 0 4
69576: PUSH
69577: LD_VAR 0 6
69581: PUSH
69582: FOR_IN
69583: IFFALSE 69642
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
69585: LD_ADDR_VAR 0 7
69589: PUSH
69590: LD_VAR 0 4
69594: PPUSH
69595: CALL_OW 313
69599: PPUSH
69600: LD_INT 25
69602: PUSH
69603: LD_INT 1
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PPUSH
69610: CALL_OW 72
69614: ST_TO_ADDR
// if units then
69615: LD_VAR 0 7
69619: IFFALSE 69640
// begin ComExitBuilding ( units [ 1 ] ) ;
69621: LD_VAR 0 7
69625: PUSH
69626: LD_INT 1
69628: ARRAY
69629: PPUSH
69630: CALL_OW 122
// exit ;
69634: POP
69635: POP
69636: POP
69637: POP
69638: GO 69652
// end ; end ;
69640: GO 69582
69642: POP
69643: POP
// end ; end ; exit ;
69644: POP
69645: POP
69646: GO 69652
// end ; end ;
69648: GO 69006
69650: POP
69651: POP
// end ;
69652: LD_VAR 0 2
69656: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
69657: LD_INT 0
69659: PPUSH
69660: PPUSH
69661: PPUSH
69662: PPUSH
69663: PPUSH
69664: PPUSH
69665: PPUSH
// if not mc_bases or not skirmish then
69666: LD_EXP 102
69670: NOT
69671: PUSH
69672: LD_EXP 100
69676: NOT
69677: OR
69678: IFFALSE 69682
// exit ;
69680: GO 69947
// btype := GetBType ( building ) ;
69682: LD_ADDR_VAR 0 6
69686: PUSH
69687: LD_VAR 0 1
69691: PPUSH
69692: CALL_OW 266
69696: ST_TO_ADDR
// x := GetX ( building ) ;
69697: LD_ADDR_VAR 0 7
69701: PUSH
69702: LD_VAR 0 1
69706: PPUSH
69707: CALL_OW 250
69711: ST_TO_ADDR
// y := GetY ( building ) ;
69712: LD_ADDR_VAR 0 8
69716: PUSH
69717: LD_VAR 0 1
69721: PPUSH
69722: CALL_OW 251
69726: ST_TO_ADDR
// d := GetDir ( building ) ;
69727: LD_ADDR_VAR 0 9
69731: PUSH
69732: LD_VAR 0 1
69736: PPUSH
69737: CALL_OW 254
69741: ST_TO_ADDR
// for i = 1 to mc_bases do
69742: LD_ADDR_VAR 0 4
69746: PUSH
69747: DOUBLE
69748: LD_INT 1
69750: DEC
69751: ST_TO_ADDR
69752: LD_EXP 102
69756: PUSH
69757: FOR_TO
69758: IFFALSE 69945
// begin if not mc_build_list [ i ] then
69760: LD_EXP 107
69764: PUSH
69765: LD_VAR 0 4
69769: ARRAY
69770: NOT
69771: IFFALSE 69775
// continue ;
69773: GO 69757
// for j := 1 to mc_build_list [ i ] do
69775: LD_ADDR_VAR 0 5
69779: PUSH
69780: DOUBLE
69781: LD_INT 1
69783: DEC
69784: ST_TO_ADDR
69785: LD_EXP 107
69789: PUSH
69790: LD_VAR 0 4
69794: ARRAY
69795: PUSH
69796: FOR_TO
69797: IFFALSE 69941
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69799: LD_VAR 0 6
69803: PUSH
69804: LD_VAR 0 7
69808: PUSH
69809: LD_VAR 0 8
69813: PUSH
69814: LD_VAR 0 9
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: PPUSH
69825: LD_EXP 107
69829: PUSH
69830: LD_VAR 0 4
69834: ARRAY
69835: PUSH
69836: LD_VAR 0 5
69840: ARRAY
69841: PPUSH
69842: CALL 81912 0 2
69846: IFFALSE 69939
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69848: LD_ADDR_EXP 107
69852: PUSH
69853: LD_EXP 107
69857: PPUSH
69858: LD_VAR 0 4
69862: PPUSH
69863: LD_EXP 107
69867: PUSH
69868: LD_VAR 0 4
69872: ARRAY
69873: PPUSH
69874: LD_VAR 0 5
69878: PPUSH
69879: CALL_OW 3
69883: PPUSH
69884: CALL_OW 1
69888: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69889: LD_ADDR_EXP 109
69893: PUSH
69894: LD_EXP 109
69898: PPUSH
69899: LD_VAR 0 4
69903: PUSH
69904: LD_EXP 109
69908: PUSH
69909: LD_VAR 0 4
69913: ARRAY
69914: PUSH
69915: LD_INT 1
69917: PLUS
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PPUSH
69923: LD_VAR 0 1
69927: PPUSH
69928: CALL 75355 0 3
69932: ST_TO_ADDR
// exit ;
69933: POP
69934: POP
69935: POP
69936: POP
69937: GO 69947
// end ;
69939: GO 69796
69941: POP
69942: POP
// end ;
69943: GO 69757
69945: POP
69946: POP
// end ;
69947: LD_VAR 0 3
69951: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69952: LD_INT 0
69954: PPUSH
69955: PPUSH
69956: PPUSH
// if not mc_bases or not skirmish then
69957: LD_EXP 102
69961: NOT
69962: PUSH
69963: LD_EXP 100
69967: NOT
69968: OR
69969: IFFALSE 69973
// exit ;
69971: GO 70163
// for i = 1 to mc_bases do
69973: LD_ADDR_VAR 0 4
69977: PUSH
69978: DOUBLE
69979: LD_INT 1
69981: DEC
69982: ST_TO_ADDR
69983: LD_EXP 102
69987: PUSH
69988: FOR_TO
69989: IFFALSE 70076
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69991: LD_VAR 0 1
69995: PUSH
69996: LD_EXP 110
70000: PUSH
70001: LD_VAR 0 4
70005: ARRAY
70006: IN
70007: PUSH
70008: LD_VAR 0 1
70012: PUSH
70013: LD_EXP 111
70017: PUSH
70018: LD_VAR 0 4
70022: ARRAY
70023: IN
70024: NOT
70025: AND
70026: IFFALSE 70074
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70028: LD_ADDR_EXP 111
70032: PUSH
70033: LD_EXP 111
70037: PPUSH
70038: LD_VAR 0 4
70042: PUSH
70043: LD_EXP 111
70047: PUSH
70048: LD_VAR 0 4
70052: ARRAY
70053: PUSH
70054: LD_INT 1
70056: PLUS
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PPUSH
70062: LD_VAR 0 1
70066: PPUSH
70067: CALL 75355 0 3
70071: ST_TO_ADDR
// break ;
70072: GO 70076
// end ; end ;
70074: GO 69988
70076: POP
70077: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70078: LD_VAR 0 1
70082: PPUSH
70083: CALL_OW 257
70087: PUSH
70088: LD_EXP 128
70092: IN
70093: PUSH
70094: LD_VAR 0 1
70098: PPUSH
70099: CALL_OW 266
70103: PUSH
70104: LD_INT 5
70106: EQUAL
70107: AND
70108: PUSH
70109: LD_VAR 0 2
70113: PPUSH
70114: CALL_OW 110
70118: PUSH
70119: LD_INT 18
70121: NONEQUAL
70122: AND
70123: IFFALSE 70163
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70125: LD_VAR 0 2
70129: PPUSH
70130: CALL_OW 257
70134: PUSH
70135: LD_INT 5
70137: PUSH
70138: LD_INT 8
70140: PUSH
70141: LD_INT 9
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: LIST
70148: IN
70149: IFFALSE 70163
// SetClass ( unit , 1 ) ;
70151: LD_VAR 0 2
70155: PPUSH
70156: LD_INT 1
70158: PPUSH
70159: CALL_OW 336
// end ;
70163: LD_VAR 0 3
70167: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70168: LD_INT 0
70170: PPUSH
70171: PPUSH
// if not mc_bases or not skirmish then
70172: LD_EXP 102
70176: NOT
70177: PUSH
70178: LD_EXP 100
70182: NOT
70183: OR
70184: IFFALSE 70188
// exit ;
70186: GO 70304
// if GetLives ( abandoned_vehicle ) > 250 then
70188: LD_VAR 0 2
70192: PPUSH
70193: CALL_OW 256
70197: PUSH
70198: LD_INT 250
70200: GREATER
70201: IFFALSE 70205
// exit ;
70203: GO 70304
// for i = 1 to mc_bases do
70205: LD_ADDR_VAR 0 6
70209: PUSH
70210: DOUBLE
70211: LD_INT 1
70213: DEC
70214: ST_TO_ADDR
70215: LD_EXP 102
70219: PUSH
70220: FOR_TO
70221: IFFALSE 70302
// begin if driver in mc_bases [ i ] then
70223: LD_VAR 0 1
70227: PUSH
70228: LD_EXP 102
70232: PUSH
70233: LD_VAR 0 6
70237: ARRAY
70238: IN
70239: IFFALSE 70300
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70241: LD_VAR 0 1
70245: PPUSH
70246: LD_EXP 102
70250: PUSH
70251: LD_VAR 0 6
70255: ARRAY
70256: PPUSH
70257: LD_INT 2
70259: PUSH
70260: LD_INT 30
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 30
70272: PUSH
70273: LD_INT 1
70275: PUSH
70276: EMPTY
70277: LIST
70278: LIST
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: LIST
70284: PPUSH
70285: CALL_OW 72
70289: PUSH
70290: LD_INT 1
70292: ARRAY
70293: PPUSH
70294: CALL 108981 0 2
// break ;
70298: GO 70302
// end ; end ;
70300: GO 70220
70302: POP
70303: POP
// end ; end_of_file
70304: LD_VAR 0 5
70308: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70309: LD_INT 0
70311: PPUSH
70312: PPUSH
// if exist_mode then
70313: LD_VAR 0 2
70317: IFFALSE 70363
// begin unit := CreateCharacter ( prefix & ident ) ;
70319: LD_ADDR_VAR 0 5
70323: PUSH
70324: LD_VAR 0 3
70328: PUSH
70329: LD_VAR 0 1
70333: STR
70334: PPUSH
70335: CALL_OW 34
70339: ST_TO_ADDR
// if unit then
70340: LD_VAR 0 5
70344: IFFALSE 70361
// DeleteCharacters ( prefix & ident ) ;
70346: LD_VAR 0 3
70350: PUSH
70351: LD_VAR 0 1
70355: STR
70356: PPUSH
70357: CALL_OW 40
// end else
70361: GO 70378
// unit := NewCharacter ( ident ) ;
70363: LD_ADDR_VAR 0 5
70367: PUSH
70368: LD_VAR 0 1
70372: PPUSH
70373: CALL_OW 25
70377: ST_TO_ADDR
// result := unit ;
70378: LD_ADDR_VAR 0 4
70382: PUSH
70383: LD_VAR 0 5
70387: ST_TO_ADDR
// end ;
70388: LD_VAR 0 4
70392: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
70393: LD_INT 0
70395: PPUSH
70396: PPUSH
// if exist_mode then
70397: LD_VAR 0 2
70401: IFFALSE 70426
// unit := CreateCharacter ( prefix & ident ) else
70403: LD_ADDR_VAR 0 5
70407: PUSH
70408: LD_VAR 0 3
70412: PUSH
70413: LD_VAR 0 1
70417: STR
70418: PPUSH
70419: CALL_OW 34
70423: ST_TO_ADDR
70424: GO 70441
// unit := NewCharacter ( ident ) ;
70426: LD_ADDR_VAR 0 5
70430: PUSH
70431: LD_VAR 0 1
70435: PPUSH
70436: CALL_OW 25
70440: ST_TO_ADDR
// result := unit ;
70441: LD_ADDR_VAR 0 4
70445: PUSH
70446: LD_VAR 0 5
70450: ST_TO_ADDR
// end ;
70451: LD_VAR 0 4
70455: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
70456: LD_INT 0
70458: PPUSH
70459: PPUSH
// if not side or not nation then
70460: LD_VAR 0 1
70464: NOT
70465: PUSH
70466: LD_VAR 0 2
70470: NOT
70471: OR
70472: IFFALSE 70476
// exit ;
70474: GO 71244
// case nation of nation_american :
70476: LD_VAR 0 2
70480: PUSH
70481: LD_INT 1
70483: DOUBLE
70484: EQUAL
70485: IFTRUE 70489
70487: GO 70703
70489: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
70490: LD_ADDR_VAR 0 4
70494: PUSH
70495: LD_INT 35
70497: PUSH
70498: LD_INT 45
70500: PUSH
70501: LD_INT 46
70503: PUSH
70504: LD_INT 47
70506: PUSH
70507: LD_INT 82
70509: PUSH
70510: LD_INT 83
70512: PUSH
70513: LD_INT 84
70515: PUSH
70516: LD_INT 85
70518: PUSH
70519: LD_INT 86
70521: PUSH
70522: LD_INT 1
70524: PUSH
70525: LD_INT 2
70527: PUSH
70528: LD_INT 6
70530: PUSH
70531: LD_INT 15
70533: PUSH
70534: LD_INT 16
70536: PUSH
70537: LD_INT 7
70539: PUSH
70540: LD_INT 12
70542: PUSH
70543: LD_INT 13
70545: PUSH
70546: LD_INT 10
70548: PUSH
70549: LD_INT 14
70551: PUSH
70552: LD_INT 20
70554: PUSH
70555: LD_INT 21
70557: PUSH
70558: LD_INT 22
70560: PUSH
70561: LD_INT 25
70563: PUSH
70564: LD_INT 32
70566: PUSH
70567: LD_INT 27
70569: PUSH
70570: LD_INT 36
70572: PUSH
70573: LD_INT 69
70575: PUSH
70576: LD_INT 39
70578: PUSH
70579: LD_INT 34
70581: PUSH
70582: LD_INT 40
70584: PUSH
70585: LD_INT 48
70587: PUSH
70588: LD_INT 49
70590: PUSH
70591: LD_INT 50
70593: PUSH
70594: LD_INT 51
70596: PUSH
70597: LD_INT 52
70599: PUSH
70600: LD_INT 53
70602: PUSH
70603: LD_INT 54
70605: PUSH
70606: LD_INT 55
70608: PUSH
70609: LD_INT 56
70611: PUSH
70612: LD_INT 57
70614: PUSH
70615: LD_INT 58
70617: PUSH
70618: LD_INT 59
70620: PUSH
70621: LD_INT 60
70623: PUSH
70624: LD_INT 61
70626: PUSH
70627: LD_INT 62
70629: PUSH
70630: LD_INT 80
70632: PUSH
70633: LD_INT 82
70635: PUSH
70636: LD_INT 83
70638: PUSH
70639: LD_INT 84
70641: PUSH
70642: LD_INT 85
70644: PUSH
70645: LD_INT 86
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: LIST
70686: LIST
70687: LIST
70688: LIST
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: LIST
70695: LIST
70696: LIST
70697: LIST
70698: LIST
70699: LIST
70700: ST_TO_ADDR
70701: GO 71168
70703: LD_INT 2
70705: DOUBLE
70706: EQUAL
70707: IFTRUE 70711
70709: GO 70937
70711: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
70712: LD_ADDR_VAR 0 4
70716: PUSH
70717: LD_INT 35
70719: PUSH
70720: LD_INT 45
70722: PUSH
70723: LD_INT 46
70725: PUSH
70726: LD_INT 47
70728: PUSH
70729: LD_INT 82
70731: PUSH
70732: LD_INT 83
70734: PUSH
70735: LD_INT 84
70737: PUSH
70738: LD_INT 85
70740: PUSH
70741: LD_INT 87
70743: PUSH
70744: LD_INT 70
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: LD_INT 11
70752: PUSH
70753: LD_INT 3
70755: PUSH
70756: LD_INT 4
70758: PUSH
70759: LD_INT 5
70761: PUSH
70762: LD_INT 6
70764: PUSH
70765: LD_INT 15
70767: PUSH
70768: LD_INT 18
70770: PUSH
70771: LD_INT 7
70773: PUSH
70774: LD_INT 17
70776: PUSH
70777: LD_INT 8
70779: PUSH
70780: LD_INT 20
70782: PUSH
70783: LD_INT 21
70785: PUSH
70786: LD_INT 22
70788: PUSH
70789: LD_INT 72
70791: PUSH
70792: LD_INT 26
70794: PUSH
70795: LD_INT 69
70797: PUSH
70798: LD_INT 39
70800: PUSH
70801: LD_INT 40
70803: PUSH
70804: LD_INT 41
70806: PUSH
70807: LD_INT 42
70809: PUSH
70810: LD_INT 43
70812: PUSH
70813: LD_INT 48
70815: PUSH
70816: LD_INT 49
70818: PUSH
70819: LD_INT 50
70821: PUSH
70822: LD_INT 51
70824: PUSH
70825: LD_INT 52
70827: PUSH
70828: LD_INT 53
70830: PUSH
70831: LD_INT 54
70833: PUSH
70834: LD_INT 55
70836: PUSH
70837: LD_INT 56
70839: PUSH
70840: LD_INT 60
70842: PUSH
70843: LD_INT 61
70845: PUSH
70846: LD_INT 62
70848: PUSH
70849: LD_INT 66
70851: PUSH
70852: LD_INT 67
70854: PUSH
70855: LD_INT 68
70857: PUSH
70858: LD_INT 81
70860: PUSH
70861: LD_INT 82
70863: PUSH
70864: LD_INT 83
70866: PUSH
70867: LD_INT 84
70869: PUSH
70870: LD_INT 85
70872: PUSH
70873: LD_INT 87
70875: PUSH
70876: LD_INT 88
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: LIST
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: ST_TO_ADDR
70935: GO 71168
70937: LD_INT 3
70939: DOUBLE
70940: EQUAL
70941: IFTRUE 70945
70943: GO 71167
70945: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70946: LD_ADDR_VAR 0 4
70950: PUSH
70951: LD_INT 46
70953: PUSH
70954: LD_INT 47
70956: PUSH
70957: LD_INT 1
70959: PUSH
70960: LD_INT 2
70962: PUSH
70963: LD_INT 82
70965: PUSH
70966: LD_INT 83
70968: PUSH
70969: LD_INT 84
70971: PUSH
70972: LD_INT 85
70974: PUSH
70975: LD_INT 86
70977: PUSH
70978: LD_INT 11
70980: PUSH
70981: LD_INT 9
70983: PUSH
70984: LD_INT 20
70986: PUSH
70987: LD_INT 19
70989: PUSH
70990: LD_INT 21
70992: PUSH
70993: LD_INT 24
70995: PUSH
70996: LD_INT 22
70998: PUSH
70999: LD_INT 25
71001: PUSH
71002: LD_INT 28
71004: PUSH
71005: LD_INT 29
71007: PUSH
71008: LD_INT 30
71010: PUSH
71011: LD_INT 31
71013: PUSH
71014: LD_INT 37
71016: PUSH
71017: LD_INT 38
71019: PUSH
71020: LD_INT 32
71022: PUSH
71023: LD_INT 27
71025: PUSH
71026: LD_INT 33
71028: PUSH
71029: LD_INT 69
71031: PUSH
71032: LD_INT 39
71034: PUSH
71035: LD_INT 34
71037: PUSH
71038: LD_INT 40
71040: PUSH
71041: LD_INT 71
71043: PUSH
71044: LD_INT 23
71046: PUSH
71047: LD_INT 44
71049: PUSH
71050: LD_INT 48
71052: PUSH
71053: LD_INT 49
71055: PUSH
71056: LD_INT 50
71058: PUSH
71059: LD_INT 51
71061: PUSH
71062: LD_INT 52
71064: PUSH
71065: LD_INT 53
71067: PUSH
71068: LD_INT 54
71070: PUSH
71071: LD_INT 55
71073: PUSH
71074: LD_INT 56
71076: PUSH
71077: LD_INT 57
71079: PUSH
71080: LD_INT 58
71082: PUSH
71083: LD_INT 59
71085: PUSH
71086: LD_INT 63
71088: PUSH
71089: LD_INT 64
71091: PUSH
71092: LD_INT 65
71094: PUSH
71095: LD_INT 82
71097: PUSH
71098: LD_INT 83
71100: PUSH
71101: LD_INT 84
71103: PUSH
71104: LD_INT 85
71106: PUSH
71107: LD_INT 86
71109: PUSH
71110: EMPTY
71111: LIST
71112: LIST
71113: LIST
71114: LIST
71115: LIST
71116: LIST
71117: LIST
71118: LIST
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: LIST
71162: LIST
71163: LIST
71164: ST_TO_ADDR
71165: GO 71168
71167: POP
// if state > - 1 and state < 3 then
71168: LD_VAR 0 3
71172: PUSH
71173: LD_INT 1
71175: NEG
71176: GREATER
71177: PUSH
71178: LD_VAR 0 3
71182: PUSH
71183: LD_INT 3
71185: LESS
71186: AND
71187: IFFALSE 71244
// for i in result do
71189: LD_ADDR_VAR 0 5
71193: PUSH
71194: LD_VAR 0 4
71198: PUSH
71199: FOR_IN
71200: IFFALSE 71242
// if GetTech ( i , side ) <> state then
71202: LD_VAR 0 5
71206: PPUSH
71207: LD_VAR 0 1
71211: PPUSH
71212: CALL_OW 321
71216: PUSH
71217: LD_VAR 0 3
71221: NONEQUAL
71222: IFFALSE 71240
// result := result diff i ;
71224: LD_ADDR_VAR 0 4
71228: PUSH
71229: LD_VAR 0 4
71233: PUSH
71234: LD_VAR 0 5
71238: DIFF
71239: ST_TO_ADDR
71240: GO 71199
71242: POP
71243: POP
// end ;
71244: LD_VAR 0 4
71248: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71249: LD_INT 0
71251: PPUSH
71252: PPUSH
71253: PPUSH
// result := true ;
71254: LD_ADDR_VAR 0 3
71258: PUSH
71259: LD_INT 1
71261: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71262: LD_ADDR_VAR 0 5
71266: PUSH
71267: LD_VAR 0 2
71271: PPUSH
71272: CALL_OW 480
71276: ST_TO_ADDR
// if not tmp then
71277: LD_VAR 0 5
71281: NOT
71282: IFFALSE 71286
// exit ;
71284: GO 71335
// for i in tmp do
71286: LD_ADDR_VAR 0 4
71290: PUSH
71291: LD_VAR 0 5
71295: PUSH
71296: FOR_IN
71297: IFFALSE 71333
// if GetTech ( i , side ) <> state_researched then
71299: LD_VAR 0 4
71303: PPUSH
71304: LD_VAR 0 1
71308: PPUSH
71309: CALL_OW 321
71313: PUSH
71314: LD_INT 2
71316: NONEQUAL
71317: IFFALSE 71331
// begin result := false ;
71319: LD_ADDR_VAR 0 3
71323: PUSH
71324: LD_INT 0
71326: ST_TO_ADDR
// exit ;
71327: POP
71328: POP
71329: GO 71335
// end ;
71331: GO 71296
71333: POP
71334: POP
// end ;
71335: LD_VAR 0 3
71339: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71340: LD_INT 0
71342: PPUSH
71343: PPUSH
71344: PPUSH
71345: PPUSH
71346: PPUSH
71347: PPUSH
71348: PPUSH
71349: PPUSH
71350: PPUSH
71351: PPUSH
71352: PPUSH
71353: PPUSH
71354: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71355: LD_VAR 0 1
71359: NOT
71360: PUSH
71361: LD_VAR 0 1
71365: PPUSH
71366: CALL_OW 257
71370: PUSH
71371: LD_INT 9
71373: NONEQUAL
71374: OR
71375: IFFALSE 71379
// exit ;
71377: GO 71952
// side := GetSide ( unit ) ;
71379: LD_ADDR_VAR 0 9
71383: PUSH
71384: LD_VAR 0 1
71388: PPUSH
71389: CALL_OW 255
71393: ST_TO_ADDR
// tech_space := tech_spacanom ;
71394: LD_ADDR_VAR 0 12
71398: PUSH
71399: LD_INT 29
71401: ST_TO_ADDR
// tech_time := tech_taurad ;
71402: LD_ADDR_VAR 0 13
71406: PUSH
71407: LD_INT 28
71409: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
71410: LD_ADDR_VAR 0 11
71414: PUSH
71415: LD_VAR 0 1
71419: PPUSH
71420: CALL_OW 310
71424: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
71425: LD_VAR 0 11
71429: PPUSH
71430: CALL_OW 247
71434: PUSH
71435: LD_INT 2
71437: EQUAL
71438: IFFALSE 71442
// exit ;
71440: GO 71952
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71442: LD_ADDR_VAR 0 8
71446: PUSH
71447: LD_INT 81
71449: PUSH
71450: LD_VAR 0 9
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 3
71461: PUSH
71462: LD_INT 21
71464: PUSH
71465: LD_INT 3
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PPUSH
71480: CALL_OW 69
71484: ST_TO_ADDR
// if not tmp then
71485: LD_VAR 0 8
71489: NOT
71490: IFFALSE 71494
// exit ;
71492: GO 71952
// if in_unit then
71494: LD_VAR 0 11
71498: IFFALSE 71522
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
71500: LD_ADDR_VAR 0 10
71504: PUSH
71505: LD_VAR 0 8
71509: PPUSH
71510: LD_VAR 0 11
71514: PPUSH
71515: CALL_OW 74
71519: ST_TO_ADDR
71520: GO 71542
// enemy := NearestUnitToUnit ( tmp , unit ) ;
71522: LD_ADDR_VAR 0 10
71526: PUSH
71527: LD_VAR 0 8
71531: PPUSH
71532: LD_VAR 0 1
71536: PPUSH
71537: CALL_OW 74
71541: ST_TO_ADDR
// if not enemy then
71542: LD_VAR 0 10
71546: NOT
71547: IFFALSE 71551
// exit ;
71549: GO 71952
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
71551: LD_VAR 0 11
71555: PUSH
71556: LD_VAR 0 11
71560: PPUSH
71561: LD_VAR 0 10
71565: PPUSH
71566: CALL_OW 296
71570: PUSH
71571: LD_INT 13
71573: GREATER
71574: AND
71575: PUSH
71576: LD_VAR 0 1
71580: PPUSH
71581: LD_VAR 0 10
71585: PPUSH
71586: CALL_OW 296
71590: PUSH
71591: LD_INT 12
71593: GREATER
71594: OR
71595: IFFALSE 71599
// exit ;
71597: GO 71952
// missile := [ 1 ] ;
71599: LD_ADDR_VAR 0 14
71603: PUSH
71604: LD_INT 1
71606: PUSH
71607: EMPTY
71608: LIST
71609: ST_TO_ADDR
// if Researched ( side , tech_space ) then
71610: LD_VAR 0 9
71614: PPUSH
71615: LD_VAR 0 12
71619: PPUSH
71620: CALL_OW 325
71624: IFFALSE 71653
// missile := Replace ( missile , missile + 1 , 2 ) ;
71626: LD_ADDR_VAR 0 14
71630: PUSH
71631: LD_VAR 0 14
71635: PPUSH
71636: LD_VAR 0 14
71640: PUSH
71641: LD_INT 1
71643: PLUS
71644: PPUSH
71645: LD_INT 2
71647: PPUSH
71648: CALL_OW 1
71652: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
71653: LD_VAR 0 9
71657: PPUSH
71658: LD_VAR 0 13
71662: PPUSH
71663: CALL_OW 325
71667: PUSH
71668: LD_VAR 0 10
71672: PPUSH
71673: CALL_OW 255
71677: PPUSH
71678: LD_VAR 0 13
71682: PPUSH
71683: CALL_OW 325
71687: NOT
71688: AND
71689: IFFALSE 71718
// missile := Replace ( missile , missile + 1 , 3 ) ;
71691: LD_ADDR_VAR 0 14
71695: PUSH
71696: LD_VAR 0 14
71700: PPUSH
71701: LD_VAR 0 14
71705: PUSH
71706: LD_INT 1
71708: PLUS
71709: PPUSH
71710: LD_INT 3
71712: PPUSH
71713: CALL_OW 1
71717: ST_TO_ADDR
// if missile < 2 then
71718: LD_VAR 0 14
71722: PUSH
71723: LD_INT 2
71725: LESS
71726: IFFALSE 71730
// exit ;
71728: GO 71952
// x := GetX ( enemy ) ;
71730: LD_ADDR_VAR 0 4
71734: PUSH
71735: LD_VAR 0 10
71739: PPUSH
71740: CALL_OW 250
71744: ST_TO_ADDR
// y := GetY ( enemy ) ;
71745: LD_ADDR_VAR 0 5
71749: PUSH
71750: LD_VAR 0 10
71754: PPUSH
71755: CALL_OW 251
71759: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
71760: LD_ADDR_VAR 0 6
71764: PUSH
71765: LD_VAR 0 4
71769: PUSH
71770: LD_INT 1
71772: NEG
71773: PPUSH
71774: LD_INT 1
71776: PPUSH
71777: CALL_OW 12
71781: PLUS
71782: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
71783: LD_ADDR_VAR 0 7
71787: PUSH
71788: LD_VAR 0 5
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PPUSH
71797: LD_INT 1
71799: PPUSH
71800: CALL_OW 12
71804: PLUS
71805: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71806: LD_VAR 0 6
71810: PPUSH
71811: LD_VAR 0 7
71815: PPUSH
71816: CALL_OW 488
71820: NOT
71821: IFFALSE 71843
// begin _x := x ;
71823: LD_ADDR_VAR 0 6
71827: PUSH
71828: LD_VAR 0 4
71832: ST_TO_ADDR
// _y := y ;
71833: LD_ADDR_VAR 0 7
71837: PUSH
71838: LD_VAR 0 5
71842: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
71843: LD_ADDR_VAR 0 3
71847: PUSH
71848: LD_INT 1
71850: PPUSH
71851: LD_VAR 0 14
71855: PPUSH
71856: CALL_OW 12
71860: ST_TO_ADDR
// case i of 1 :
71861: LD_VAR 0 3
71865: PUSH
71866: LD_INT 1
71868: DOUBLE
71869: EQUAL
71870: IFTRUE 71874
71872: GO 71891
71874: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71875: LD_VAR 0 1
71879: PPUSH
71880: LD_VAR 0 10
71884: PPUSH
71885: CALL_OW 115
71889: GO 71952
71891: LD_INT 2
71893: DOUBLE
71894: EQUAL
71895: IFTRUE 71899
71897: GO 71921
71899: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71900: LD_VAR 0 1
71904: PPUSH
71905: LD_VAR 0 6
71909: PPUSH
71910: LD_VAR 0 7
71914: PPUSH
71915: CALL_OW 153
71919: GO 71952
71921: LD_INT 3
71923: DOUBLE
71924: EQUAL
71925: IFTRUE 71929
71927: GO 71951
71929: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71930: LD_VAR 0 1
71934: PPUSH
71935: LD_VAR 0 6
71939: PPUSH
71940: LD_VAR 0 7
71944: PPUSH
71945: CALL_OW 154
71949: GO 71952
71951: POP
// end ;
71952: LD_VAR 0 2
71956: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71957: LD_INT 0
71959: PPUSH
71960: PPUSH
71961: PPUSH
71962: PPUSH
71963: PPUSH
71964: PPUSH
// if not unit or not building then
71965: LD_VAR 0 1
71969: NOT
71970: PUSH
71971: LD_VAR 0 2
71975: NOT
71976: OR
71977: IFFALSE 71981
// exit ;
71979: GO 72139
// x := GetX ( building ) ;
71981: LD_ADDR_VAR 0 5
71985: PUSH
71986: LD_VAR 0 2
71990: PPUSH
71991: CALL_OW 250
71995: ST_TO_ADDR
// y := GetY ( building ) ;
71996: LD_ADDR_VAR 0 6
72000: PUSH
72001: LD_VAR 0 2
72005: PPUSH
72006: CALL_OW 251
72010: ST_TO_ADDR
// for i = 0 to 5 do
72011: LD_ADDR_VAR 0 4
72015: PUSH
72016: DOUBLE
72017: LD_INT 0
72019: DEC
72020: ST_TO_ADDR
72021: LD_INT 5
72023: PUSH
72024: FOR_TO
72025: IFFALSE 72137
// begin _x := ShiftX ( x , i , 3 ) ;
72027: LD_ADDR_VAR 0 7
72031: PUSH
72032: LD_VAR 0 5
72036: PPUSH
72037: LD_VAR 0 4
72041: PPUSH
72042: LD_INT 3
72044: PPUSH
72045: CALL_OW 272
72049: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
72050: LD_ADDR_VAR 0 8
72054: PUSH
72055: LD_VAR 0 6
72059: PPUSH
72060: LD_VAR 0 4
72064: PPUSH
72065: LD_INT 3
72067: PPUSH
72068: CALL_OW 273
72072: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72073: LD_VAR 0 7
72077: PPUSH
72078: LD_VAR 0 8
72082: PPUSH
72083: CALL_OW 488
72087: NOT
72088: IFFALSE 72092
// continue ;
72090: GO 72024
// if HexInfo ( _x , _y ) = 0 then
72092: LD_VAR 0 7
72096: PPUSH
72097: LD_VAR 0 8
72101: PPUSH
72102: CALL_OW 428
72106: PUSH
72107: LD_INT 0
72109: EQUAL
72110: IFFALSE 72135
// begin ComMoveXY ( unit , _x , _y ) ;
72112: LD_VAR 0 1
72116: PPUSH
72117: LD_VAR 0 7
72121: PPUSH
72122: LD_VAR 0 8
72126: PPUSH
72127: CALL_OW 111
// exit ;
72131: POP
72132: POP
72133: GO 72139
// end ; end ;
72135: GO 72024
72137: POP
72138: POP
// end ;
72139: LD_VAR 0 3
72143: RET
// export function ScanBase ( side , base_area ) ; begin
72144: LD_INT 0
72146: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72147: LD_ADDR_VAR 0 3
72151: PUSH
72152: LD_VAR 0 2
72156: PPUSH
72157: LD_INT 81
72159: PUSH
72160: LD_VAR 0 1
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PPUSH
72169: CALL_OW 70
72173: ST_TO_ADDR
// end ;
72174: LD_VAR 0 3
72178: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72179: LD_INT 0
72181: PPUSH
72182: PPUSH
72183: PPUSH
72184: PPUSH
// result := false ;
72185: LD_ADDR_VAR 0 2
72189: PUSH
72190: LD_INT 0
72192: ST_TO_ADDR
// side := GetSide ( unit ) ;
72193: LD_ADDR_VAR 0 3
72197: PUSH
72198: LD_VAR 0 1
72202: PPUSH
72203: CALL_OW 255
72207: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72208: LD_ADDR_VAR 0 4
72212: PUSH
72213: LD_VAR 0 1
72217: PPUSH
72218: CALL_OW 248
72222: ST_TO_ADDR
// case nat of 1 :
72223: LD_VAR 0 4
72227: PUSH
72228: LD_INT 1
72230: DOUBLE
72231: EQUAL
72232: IFTRUE 72236
72234: GO 72247
72236: POP
// tech := tech_lassight ; 2 :
72237: LD_ADDR_VAR 0 5
72241: PUSH
72242: LD_INT 12
72244: ST_TO_ADDR
72245: GO 72286
72247: LD_INT 2
72249: DOUBLE
72250: EQUAL
72251: IFTRUE 72255
72253: GO 72266
72255: POP
// tech := tech_mortar ; 3 :
72256: LD_ADDR_VAR 0 5
72260: PUSH
72261: LD_INT 41
72263: ST_TO_ADDR
72264: GO 72286
72266: LD_INT 3
72268: DOUBLE
72269: EQUAL
72270: IFTRUE 72274
72272: GO 72285
72274: POP
// tech := tech_bazooka ; end ;
72275: LD_ADDR_VAR 0 5
72279: PUSH
72280: LD_INT 44
72282: ST_TO_ADDR
72283: GO 72286
72285: POP
// if Researched ( side , tech ) then
72286: LD_VAR 0 3
72290: PPUSH
72291: LD_VAR 0 5
72295: PPUSH
72296: CALL_OW 325
72300: IFFALSE 72327
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72302: LD_ADDR_VAR 0 2
72306: PUSH
72307: LD_INT 5
72309: PUSH
72310: LD_INT 8
72312: PUSH
72313: LD_INT 9
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: LIST
72320: PUSH
72321: LD_VAR 0 4
72325: ARRAY
72326: ST_TO_ADDR
// end ;
72327: LD_VAR 0 2
72331: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72332: LD_INT 0
72334: PPUSH
72335: PPUSH
72336: PPUSH
// if not mines then
72337: LD_VAR 0 2
72341: NOT
72342: IFFALSE 72346
// exit ;
72344: GO 72490
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72346: LD_ADDR_VAR 0 5
72350: PUSH
72351: LD_INT 81
72353: PUSH
72354: LD_VAR 0 1
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 3
72365: PUSH
72366: LD_INT 21
72368: PUSH
72369: LD_INT 3
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: PPUSH
72384: CALL_OW 69
72388: ST_TO_ADDR
// for i in mines do
72389: LD_ADDR_VAR 0 4
72393: PUSH
72394: LD_VAR 0 2
72398: PUSH
72399: FOR_IN
72400: IFFALSE 72488
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
72402: LD_VAR 0 4
72406: PUSH
72407: LD_INT 1
72409: ARRAY
72410: PPUSH
72411: LD_VAR 0 4
72415: PUSH
72416: LD_INT 2
72418: ARRAY
72419: PPUSH
72420: CALL_OW 458
72424: NOT
72425: IFFALSE 72429
// continue ;
72427: GO 72399
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
72429: LD_VAR 0 4
72433: PUSH
72434: LD_INT 1
72436: ARRAY
72437: PPUSH
72438: LD_VAR 0 4
72442: PUSH
72443: LD_INT 2
72445: ARRAY
72446: PPUSH
72447: CALL_OW 428
72451: PUSH
72452: LD_VAR 0 5
72456: IN
72457: IFFALSE 72486
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
72459: LD_VAR 0 4
72463: PUSH
72464: LD_INT 1
72466: ARRAY
72467: PPUSH
72468: LD_VAR 0 4
72472: PUSH
72473: LD_INT 2
72475: ARRAY
72476: PPUSH
72477: LD_VAR 0 1
72481: PPUSH
72482: CALL_OW 456
// end ;
72486: GO 72399
72488: POP
72489: POP
// end ;
72490: LD_VAR 0 3
72494: RET
// export function Count ( array ) ; begin
72495: LD_INT 0
72497: PPUSH
// result := array + 0 ;
72498: LD_ADDR_VAR 0 2
72502: PUSH
72503: LD_VAR 0 1
72507: PUSH
72508: LD_INT 0
72510: PLUS
72511: ST_TO_ADDR
// end ;
72512: LD_VAR 0 2
72516: RET
// export function IsEmpty ( building ) ; begin
72517: LD_INT 0
72519: PPUSH
// if not building then
72520: LD_VAR 0 1
72524: NOT
72525: IFFALSE 72529
// exit ;
72527: GO 72572
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
72529: LD_ADDR_VAR 0 2
72533: PUSH
72534: LD_VAR 0 1
72538: PUSH
72539: LD_INT 22
72541: PUSH
72542: LD_VAR 0 1
72546: PPUSH
72547: CALL_OW 255
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 58
72558: PUSH
72559: EMPTY
72560: LIST
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PPUSH
72566: CALL_OW 69
72570: IN
72571: ST_TO_ADDR
// end ;
72572: LD_VAR 0 2
72576: RET
// export function IsNotFull ( building ) ; var places ; begin
72577: LD_INT 0
72579: PPUSH
72580: PPUSH
// if not building then
72581: LD_VAR 0 1
72585: NOT
72586: IFFALSE 72590
// exit ;
72588: GO 72618
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
72590: LD_ADDR_VAR 0 2
72594: PUSH
72595: LD_VAR 0 1
72599: PPUSH
72600: LD_INT 3
72602: PUSH
72603: LD_INT 62
72605: PUSH
72606: EMPTY
72607: LIST
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PPUSH
72613: CALL_OW 72
72617: ST_TO_ADDR
// end ;
72618: LD_VAR 0 2
72622: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
72623: LD_INT 0
72625: PPUSH
72626: PPUSH
72627: PPUSH
72628: PPUSH
// tmp := [ ] ;
72629: LD_ADDR_VAR 0 3
72633: PUSH
72634: EMPTY
72635: ST_TO_ADDR
// list := [ ] ;
72636: LD_ADDR_VAR 0 5
72640: PUSH
72641: EMPTY
72642: ST_TO_ADDR
// for i = 16 to 25 do
72643: LD_ADDR_VAR 0 4
72647: PUSH
72648: DOUBLE
72649: LD_INT 16
72651: DEC
72652: ST_TO_ADDR
72653: LD_INT 25
72655: PUSH
72656: FOR_TO
72657: IFFALSE 72730
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
72659: LD_ADDR_VAR 0 3
72663: PUSH
72664: LD_VAR 0 3
72668: PUSH
72669: LD_INT 22
72671: PUSH
72672: LD_VAR 0 1
72676: PPUSH
72677: CALL_OW 255
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 91
72688: PUSH
72689: LD_VAR 0 1
72693: PUSH
72694: LD_INT 6
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 30
72704: PUSH
72705: LD_VAR 0 4
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: LIST
72718: PUSH
72719: EMPTY
72720: LIST
72721: PPUSH
72722: CALL_OW 69
72726: ADD
72727: ST_TO_ADDR
72728: GO 72656
72730: POP
72731: POP
// for i = 1 to tmp do
72732: LD_ADDR_VAR 0 4
72736: PUSH
72737: DOUBLE
72738: LD_INT 1
72740: DEC
72741: ST_TO_ADDR
72742: LD_VAR 0 3
72746: PUSH
72747: FOR_TO
72748: IFFALSE 72836
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
72750: LD_ADDR_VAR 0 5
72754: PUSH
72755: LD_VAR 0 5
72759: PUSH
72760: LD_VAR 0 3
72764: PUSH
72765: LD_VAR 0 4
72769: ARRAY
72770: PPUSH
72771: CALL_OW 266
72775: PUSH
72776: LD_VAR 0 3
72780: PUSH
72781: LD_VAR 0 4
72785: ARRAY
72786: PPUSH
72787: CALL_OW 250
72791: PUSH
72792: LD_VAR 0 3
72796: PUSH
72797: LD_VAR 0 4
72801: ARRAY
72802: PPUSH
72803: CALL_OW 251
72807: PUSH
72808: LD_VAR 0 3
72812: PUSH
72813: LD_VAR 0 4
72817: ARRAY
72818: PPUSH
72819: CALL_OW 254
72823: PUSH
72824: EMPTY
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: PUSH
72830: EMPTY
72831: LIST
72832: ADD
72833: ST_TO_ADDR
72834: GO 72747
72836: POP
72837: POP
// result := list ;
72838: LD_ADDR_VAR 0 2
72842: PUSH
72843: LD_VAR 0 5
72847: ST_TO_ADDR
// end ;
72848: LD_VAR 0 2
72852: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72853: LD_INT 0
72855: PPUSH
72856: PPUSH
72857: PPUSH
72858: PPUSH
72859: PPUSH
72860: PPUSH
72861: PPUSH
// if not factory then
72862: LD_VAR 0 1
72866: NOT
72867: IFFALSE 72871
// exit ;
72869: GO 73464
// if control = control_apeman then
72871: LD_VAR 0 4
72875: PUSH
72876: LD_INT 5
72878: EQUAL
72879: IFFALSE 72988
// begin tmp := UnitsInside ( factory ) ;
72881: LD_ADDR_VAR 0 8
72885: PUSH
72886: LD_VAR 0 1
72890: PPUSH
72891: CALL_OW 313
72895: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72896: LD_VAR 0 8
72900: PPUSH
72901: LD_INT 25
72903: PUSH
72904: LD_INT 12
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PPUSH
72911: CALL_OW 72
72915: NOT
72916: IFFALSE 72926
// control := control_manual ;
72918: LD_ADDR_VAR 0 4
72922: PUSH
72923: LD_INT 1
72925: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72926: LD_ADDR_VAR 0 8
72930: PUSH
72931: LD_VAR 0 1
72935: PPUSH
72936: CALL 72623 0 1
72940: ST_TO_ADDR
// if tmp then
72941: LD_VAR 0 8
72945: IFFALSE 72988
// begin for i in tmp do
72947: LD_ADDR_VAR 0 7
72951: PUSH
72952: LD_VAR 0 8
72956: PUSH
72957: FOR_IN
72958: IFFALSE 72986
// if i [ 1 ] = b_ext_radio then
72960: LD_VAR 0 7
72964: PUSH
72965: LD_INT 1
72967: ARRAY
72968: PUSH
72969: LD_INT 22
72971: EQUAL
72972: IFFALSE 72984
// begin control := control_remote ;
72974: LD_ADDR_VAR 0 4
72978: PUSH
72979: LD_INT 2
72981: ST_TO_ADDR
// break ;
72982: GO 72986
// end ;
72984: GO 72957
72986: POP
72987: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72988: LD_VAR 0 1
72992: PPUSH
72993: LD_VAR 0 2
72997: PPUSH
72998: LD_VAR 0 3
73002: PPUSH
73003: LD_VAR 0 4
73007: PPUSH
73008: LD_VAR 0 5
73012: PPUSH
73013: CALL_OW 448
73017: IFFALSE 73052
// begin result := [ chassis , engine , control , weapon ] ;
73019: LD_ADDR_VAR 0 6
73023: PUSH
73024: LD_VAR 0 2
73028: PUSH
73029: LD_VAR 0 3
73033: PUSH
73034: LD_VAR 0 4
73038: PUSH
73039: LD_VAR 0 5
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: LIST
73048: LIST
73049: ST_TO_ADDR
// exit ;
73050: GO 73464
// end ; _chassis := AvailableChassisList ( factory ) ;
73052: LD_ADDR_VAR 0 9
73056: PUSH
73057: LD_VAR 0 1
73061: PPUSH
73062: CALL_OW 475
73066: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
73067: LD_ADDR_VAR 0 11
73071: PUSH
73072: LD_VAR 0 1
73076: PPUSH
73077: CALL_OW 476
73081: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
73082: LD_ADDR_VAR 0 12
73086: PUSH
73087: LD_VAR 0 1
73091: PPUSH
73092: CALL_OW 477
73096: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
73097: LD_ADDR_VAR 0 10
73101: PUSH
73102: LD_VAR 0 1
73106: PPUSH
73107: CALL_OW 478
73111: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73112: LD_VAR 0 9
73116: NOT
73117: PUSH
73118: LD_VAR 0 11
73122: NOT
73123: OR
73124: PUSH
73125: LD_VAR 0 12
73129: NOT
73130: OR
73131: PUSH
73132: LD_VAR 0 10
73136: NOT
73137: OR
73138: IFFALSE 73173
// begin result := [ chassis , engine , control , weapon ] ;
73140: LD_ADDR_VAR 0 6
73144: PUSH
73145: LD_VAR 0 2
73149: PUSH
73150: LD_VAR 0 3
73154: PUSH
73155: LD_VAR 0 4
73159: PUSH
73160: LD_VAR 0 5
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: ST_TO_ADDR
// exit ;
73171: GO 73464
// end ; if not chassis in _chassis then
73173: LD_VAR 0 2
73177: PUSH
73178: LD_VAR 0 9
73182: IN
73183: NOT
73184: IFFALSE 73210
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73186: LD_ADDR_VAR 0 2
73190: PUSH
73191: LD_VAR 0 9
73195: PUSH
73196: LD_INT 1
73198: PPUSH
73199: LD_VAR 0 9
73203: PPUSH
73204: CALL_OW 12
73208: ARRAY
73209: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73210: LD_VAR 0 2
73214: PPUSH
73215: LD_VAR 0 3
73219: PPUSH
73220: CALL 73469 0 2
73224: NOT
73225: IFFALSE 73284
// repeat engine := _engine [ 1 ] ;
73227: LD_ADDR_VAR 0 3
73231: PUSH
73232: LD_VAR 0 11
73236: PUSH
73237: LD_INT 1
73239: ARRAY
73240: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73241: LD_ADDR_VAR 0 11
73245: PUSH
73246: LD_VAR 0 11
73250: PPUSH
73251: LD_INT 1
73253: PPUSH
73254: CALL_OW 3
73258: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73259: LD_VAR 0 2
73263: PPUSH
73264: LD_VAR 0 3
73268: PPUSH
73269: CALL 73469 0 2
73273: PUSH
73274: LD_VAR 0 11
73278: PUSH
73279: EMPTY
73280: EQUAL
73281: OR
73282: IFFALSE 73227
// if not control in _control then
73284: LD_VAR 0 4
73288: PUSH
73289: LD_VAR 0 12
73293: IN
73294: NOT
73295: IFFALSE 73321
// control := _control [ rand ( 1 , _control ) ] ;
73297: LD_ADDR_VAR 0 4
73301: PUSH
73302: LD_VAR 0 12
73306: PUSH
73307: LD_INT 1
73309: PPUSH
73310: LD_VAR 0 12
73314: PPUSH
73315: CALL_OW 12
73319: ARRAY
73320: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73321: LD_VAR 0 2
73325: PPUSH
73326: LD_VAR 0 5
73330: PPUSH
73331: CALL 73689 0 2
73335: NOT
73336: IFFALSE 73395
// repeat weapon := _weapon [ 1 ] ;
73338: LD_ADDR_VAR 0 5
73342: PUSH
73343: LD_VAR 0 10
73347: PUSH
73348: LD_INT 1
73350: ARRAY
73351: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
73352: LD_ADDR_VAR 0 10
73356: PUSH
73357: LD_VAR 0 10
73361: PPUSH
73362: LD_INT 1
73364: PPUSH
73365: CALL_OW 3
73369: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
73370: LD_VAR 0 2
73374: PPUSH
73375: LD_VAR 0 5
73379: PPUSH
73380: CALL 73689 0 2
73384: PUSH
73385: LD_VAR 0 10
73389: PUSH
73390: EMPTY
73391: EQUAL
73392: OR
73393: IFFALSE 73338
// result := [ ] ;
73395: LD_ADDR_VAR 0 6
73399: PUSH
73400: EMPTY
73401: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73402: LD_VAR 0 1
73406: PPUSH
73407: LD_VAR 0 2
73411: PPUSH
73412: LD_VAR 0 3
73416: PPUSH
73417: LD_VAR 0 4
73421: PPUSH
73422: LD_VAR 0 5
73426: PPUSH
73427: CALL_OW 448
73431: IFFALSE 73464
// result := [ chassis , engine , control , weapon ] ;
73433: LD_ADDR_VAR 0 6
73437: PUSH
73438: LD_VAR 0 2
73442: PUSH
73443: LD_VAR 0 3
73447: PUSH
73448: LD_VAR 0 4
73452: PUSH
73453: LD_VAR 0 5
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: LIST
73462: LIST
73463: ST_TO_ADDR
// end ;
73464: LD_VAR 0 6
73468: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
73469: LD_INT 0
73471: PPUSH
// if not chassis or not engine then
73472: LD_VAR 0 1
73476: NOT
73477: PUSH
73478: LD_VAR 0 2
73482: NOT
73483: OR
73484: IFFALSE 73488
// exit ;
73486: GO 73684
// case engine of engine_solar :
73488: LD_VAR 0 2
73492: PUSH
73493: LD_INT 2
73495: DOUBLE
73496: EQUAL
73497: IFTRUE 73501
73499: GO 73539
73501: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
73502: LD_ADDR_VAR 0 3
73506: PUSH
73507: LD_INT 11
73509: PUSH
73510: LD_INT 12
73512: PUSH
73513: LD_INT 13
73515: PUSH
73516: LD_INT 14
73518: PUSH
73519: LD_INT 1
73521: PUSH
73522: LD_INT 2
73524: PUSH
73525: LD_INT 3
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: ST_TO_ADDR
73537: GO 73668
73539: LD_INT 1
73541: DOUBLE
73542: EQUAL
73543: IFTRUE 73547
73545: GO 73609
73547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
73548: LD_ADDR_VAR 0 3
73552: PUSH
73553: LD_INT 11
73555: PUSH
73556: LD_INT 12
73558: PUSH
73559: LD_INT 13
73561: PUSH
73562: LD_INT 14
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: LD_INT 2
73570: PUSH
73571: LD_INT 3
73573: PUSH
73574: LD_INT 4
73576: PUSH
73577: LD_INT 5
73579: PUSH
73580: LD_INT 21
73582: PUSH
73583: LD_INT 23
73585: PUSH
73586: LD_INT 22
73588: PUSH
73589: LD_INT 24
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: ST_TO_ADDR
73607: GO 73668
73609: LD_INT 3
73611: DOUBLE
73612: EQUAL
73613: IFTRUE 73617
73615: GO 73667
73617: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73618: LD_ADDR_VAR 0 3
73622: PUSH
73623: LD_INT 13
73625: PUSH
73626: LD_INT 14
73628: PUSH
73629: LD_INT 2
73631: PUSH
73632: LD_INT 3
73634: PUSH
73635: LD_INT 4
73637: PUSH
73638: LD_INT 5
73640: PUSH
73641: LD_INT 21
73643: PUSH
73644: LD_INT 22
73646: PUSH
73647: LD_INT 23
73649: PUSH
73650: LD_INT 24
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: ST_TO_ADDR
73665: GO 73668
73667: POP
// result := ( chassis in result ) ;
73668: LD_ADDR_VAR 0 3
73672: PUSH
73673: LD_VAR 0 1
73677: PUSH
73678: LD_VAR 0 3
73682: IN
73683: ST_TO_ADDR
// end ;
73684: LD_VAR 0 3
73688: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
73689: LD_INT 0
73691: PPUSH
// if not chassis or not weapon then
73692: LD_VAR 0 1
73696: NOT
73697: PUSH
73698: LD_VAR 0 2
73702: NOT
73703: OR
73704: IFFALSE 73708
// exit ;
73706: GO 74768
// case weapon of us_machine_gun :
73708: LD_VAR 0 2
73712: PUSH
73713: LD_INT 2
73715: DOUBLE
73716: EQUAL
73717: IFTRUE 73721
73719: GO 73751
73721: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
73722: LD_ADDR_VAR 0 3
73726: PUSH
73727: LD_INT 1
73729: PUSH
73730: LD_INT 2
73732: PUSH
73733: LD_INT 3
73735: PUSH
73736: LD_INT 4
73738: PUSH
73739: LD_INT 5
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: LIST
73746: LIST
73747: LIST
73748: ST_TO_ADDR
73749: GO 74752
73751: LD_INT 3
73753: DOUBLE
73754: EQUAL
73755: IFTRUE 73759
73757: GO 73789
73759: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
73760: LD_ADDR_VAR 0 3
73764: PUSH
73765: LD_INT 1
73767: PUSH
73768: LD_INT 2
73770: PUSH
73771: LD_INT 3
73773: PUSH
73774: LD_INT 4
73776: PUSH
73777: LD_INT 5
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: LIST
73784: LIST
73785: LIST
73786: ST_TO_ADDR
73787: GO 74752
73789: LD_INT 11
73791: DOUBLE
73792: EQUAL
73793: IFTRUE 73797
73795: GO 73827
73797: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
73798: LD_ADDR_VAR 0 3
73802: PUSH
73803: LD_INT 1
73805: PUSH
73806: LD_INT 2
73808: PUSH
73809: LD_INT 3
73811: PUSH
73812: LD_INT 4
73814: PUSH
73815: LD_INT 5
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: ST_TO_ADDR
73825: GO 74752
73827: LD_INT 4
73829: DOUBLE
73830: EQUAL
73831: IFTRUE 73835
73833: GO 73861
73835: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
73836: LD_ADDR_VAR 0 3
73840: PUSH
73841: LD_INT 2
73843: PUSH
73844: LD_INT 3
73846: PUSH
73847: LD_INT 4
73849: PUSH
73850: LD_INT 5
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: LIST
73857: LIST
73858: ST_TO_ADDR
73859: GO 74752
73861: LD_INT 5
73863: DOUBLE
73864: EQUAL
73865: IFTRUE 73869
73867: GO 73895
73869: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73870: LD_ADDR_VAR 0 3
73874: PUSH
73875: LD_INT 2
73877: PUSH
73878: LD_INT 3
73880: PUSH
73881: LD_INT 4
73883: PUSH
73884: LD_INT 5
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: ST_TO_ADDR
73893: GO 74752
73895: LD_INT 9
73897: DOUBLE
73898: EQUAL
73899: IFTRUE 73903
73901: GO 73929
73903: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73904: LD_ADDR_VAR 0 3
73908: PUSH
73909: LD_INT 2
73911: PUSH
73912: LD_INT 3
73914: PUSH
73915: LD_INT 4
73917: PUSH
73918: LD_INT 5
73920: PUSH
73921: EMPTY
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: ST_TO_ADDR
73927: GO 74752
73929: LD_INT 7
73931: DOUBLE
73932: EQUAL
73933: IFTRUE 73937
73935: GO 73963
73937: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73938: LD_ADDR_VAR 0 3
73942: PUSH
73943: LD_INT 2
73945: PUSH
73946: LD_INT 3
73948: PUSH
73949: LD_INT 4
73951: PUSH
73952: LD_INT 5
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: ST_TO_ADDR
73961: GO 74752
73963: LD_INT 12
73965: DOUBLE
73966: EQUAL
73967: IFTRUE 73971
73969: GO 73997
73971: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73972: LD_ADDR_VAR 0 3
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: LD_INT 3
73982: PUSH
73983: LD_INT 4
73985: PUSH
73986: LD_INT 5
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: ST_TO_ADDR
73995: GO 74752
73997: LD_INT 13
73999: DOUBLE
74000: EQUAL
74001: IFTRUE 74005
74003: GO 74031
74005: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
74006: LD_ADDR_VAR 0 3
74010: PUSH
74011: LD_INT 2
74013: PUSH
74014: LD_INT 3
74016: PUSH
74017: LD_INT 4
74019: PUSH
74020: LD_INT 5
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: LIST
74027: LIST
74028: ST_TO_ADDR
74029: GO 74752
74031: LD_INT 14
74033: DOUBLE
74034: EQUAL
74035: IFTRUE 74039
74037: GO 74057
74039: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
74040: LD_ADDR_VAR 0 3
74044: PUSH
74045: LD_INT 4
74047: PUSH
74048: LD_INT 5
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: ST_TO_ADDR
74055: GO 74752
74057: LD_INT 6
74059: DOUBLE
74060: EQUAL
74061: IFTRUE 74065
74063: GO 74083
74065: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
74066: LD_ADDR_VAR 0 3
74070: PUSH
74071: LD_INT 4
74073: PUSH
74074: LD_INT 5
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: ST_TO_ADDR
74081: GO 74752
74083: LD_INT 10
74085: DOUBLE
74086: EQUAL
74087: IFTRUE 74091
74089: GO 74109
74091: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
74092: LD_ADDR_VAR 0 3
74096: PUSH
74097: LD_INT 4
74099: PUSH
74100: LD_INT 5
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: ST_TO_ADDR
74107: GO 74752
74109: LD_INT 22
74111: DOUBLE
74112: EQUAL
74113: IFTRUE 74117
74115: GO 74143
74117: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74118: LD_ADDR_VAR 0 3
74122: PUSH
74123: LD_INT 11
74125: PUSH
74126: LD_INT 12
74128: PUSH
74129: LD_INT 13
74131: PUSH
74132: LD_INT 14
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: ST_TO_ADDR
74141: GO 74752
74143: LD_INT 23
74145: DOUBLE
74146: EQUAL
74147: IFTRUE 74151
74149: GO 74177
74151: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74152: LD_ADDR_VAR 0 3
74156: PUSH
74157: LD_INT 11
74159: PUSH
74160: LD_INT 12
74162: PUSH
74163: LD_INT 13
74165: PUSH
74166: LD_INT 14
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: ST_TO_ADDR
74175: GO 74752
74177: LD_INT 24
74179: DOUBLE
74180: EQUAL
74181: IFTRUE 74185
74183: GO 74211
74185: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74186: LD_ADDR_VAR 0 3
74190: PUSH
74191: LD_INT 11
74193: PUSH
74194: LD_INT 12
74196: PUSH
74197: LD_INT 13
74199: PUSH
74200: LD_INT 14
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: LIST
74207: LIST
74208: ST_TO_ADDR
74209: GO 74752
74211: LD_INT 30
74213: DOUBLE
74214: EQUAL
74215: IFTRUE 74219
74217: GO 74245
74219: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74220: LD_ADDR_VAR 0 3
74224: PUSH
74225: LD_INT 11
74227: PUSH
74228: LD_INT 12
74230: PUSH
74231: LD_INT 13
74233: PUSH
74234: LD_INT 14
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: ST_TO_ADDR
74243: GO 74752
74245: LD_INT 25
74247: DOUBLE
74248: EQUAL
74249: IFTRUE 74253
74251: GO 74271
74253: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74254: LD_ADDR_VAR 0 3
74258: PUSH
74259: LD_INT 13
74261: PUSH
74262: LD_INT 14
74264: PUSH
74265: EMPTY
74266: LIST
74267: LIST
74268: ST_TO_ADDR
74269: GO 74752
74271: LD_INT 27
74273: DOUBLE
74274: EQUAL
74275: IFTRUE 74279
74277: GO 74297
74279: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74280: LD_ADDR_VAR 0 3
74284: PUSH
74285: LD_INT 13
74287: PUSH
74288: LD_INT 14
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: ST_TO_ADDR
74295: GO 74752
74297: LD_INT 92
74299: DOUBLE
74300: EQUAL
74301: IFTRUE 74305
74303: GO 74331
74305: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74306: LD_ADDR_VAR 0 3
74310: PUSH
74311: LD_INT 11
74313: PUSH
74314: LD_INT 12
74316: PUSH
74317: LD_INT 13
74319: PUSH
74320: LD_INT 14
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: LIST
74327: LIST
74328: ST_TO_ADDR
74329: GO 74752
74331: LD_INT 28
74333: DOUBLE
74334: EQUAL
74335: IFTRUE 74339
74337: GO 74357
74339: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74340: LD_ADDR_VAR 0 3
74344: PUSH
74345: LD_INT 13
74347: PUSH
74348: LD_INT 14
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: ST_TO_ADDR
74355: GO 74752
74357: LD_INT 29
74359: DOUBLE
74360: EQUAL
74361: IFTRUE 74365
74363: GO 74383
74365: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
74366: LD_ADDR_VAR 0 3
74370: PUSH
74371: LD_INT 13
74373: PUSH
74374: LD_INT 14
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: ST_TO_ADDR
74381: GO 74752
74383: LD_INT 31
74385: DOUBLE
74386: EQUAL
74387: IFTRUE 74391
74389: GO 74409
74391: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
74392: LD_ADDR_VAR 0 3
74396: PUSH
74397: LD_INT 13
74399: PUSH
74400: LD_INT 14
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: ST_TO_ADDR
74407: GO 74752
74409: LD_INT 26
74411: DOUBLE
74412: EQUAL
74413: IFTRUE 74417
74415: GO 74435
74417: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
74418: LD_ADDR_VAR 0 3
74422: PUSH
74423: LD_INT 13
74425: PUSH
74426: LD_INT 14
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: ST_TO_ADDR
74433: GO 74752
74435: LD_INT 42
74437: DOUBLE
74438: EQUAL
74439: IFTRUE 74443
74441: GO 74469
74443: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
74444: LD_ADDR_VAR 0 3
74448: PUSH
74449: LD_INT 21
74451: PUSH
74452: LD_INT 22
74454: PUSH
74455: LD_INT 23
74457: PUSH
74458: LD_INT 24
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: LIST
74465: LIST
74466: ST_TO_ADDR
74467: GO 74752
74469: LD_INT 43
74471: DOUBLE
74472: EQUAL
74473: IFTRUE 74477
74475: GO 74503
74477: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
74478: LD_ADDR_VAR 0 3
74482: PUSH
74483: LD_INT 21
74485: PUSH
74486: LD_INT 22
74488: PUSH
74489: LD_INT 23
74491: PUSH
74492: LD_INT 24
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: ST_TO_ADDR
74501: GO 74752
74503: LD_INT 44
74505: DOUBLE
74506: EQUAL
74507: IFTRUE 74511
74509: GO 74537
74511: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
74512: LD_ADDR_VAR 0 3
74516: PUSH
74517: LD_INT 21
74519: PUSH
74520: LD_INT 22
74522: PUSH
74523: LD_INT 23
74525: PUSH
74526: LD_INT 24
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: ST_TO_ADDR
74535: GO 74752
74537: LD_INT 45
74539: DOUBLE
74540: EQUAL
74541: IFTRUE 74545
74543: GO 74571
74545: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
74546: LD_ADDR_VAR 0 3
74550: PUSH
74551: LD_INT 21
74553: PUSH
74554: LD_INT 22
74556: PUSH
74557: LD_INT 23
74559: PUSH
74560: LD_INT 24
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
74569: GO 74752
74571: LD_INT 49
74573: DOUBLE
74574: EQUAL
74575: IFTRUE 74579
74577: GO 74605
74579: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
74580: LD_ADDR_VAR 0 3
74584: PUSH
74585: LD_INT 21
74587: PUSH
74588: LD_INT 22
74590: PUSH
74591: LD_INT 23
74593: PUSH
74594: LD_INT 24
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: ST_TO_ADDR
74603: GO 74752
74605: LD_INT 51
74607: DOUBLE
74608: EQUAL
74609: IFTRUE 74613
74611: GO 74639
74613: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
74614: LD_ADDR_VAR 0 3
74618: PUSH
74619: LD_INT 21
74621: PUSH
74622: LD_INT 22
74624: PUSH
74625: LD_INT 23
74627: PUSH
74628: LD_INT 24
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: ST_TO_ADDR
74637: GO 74752
74639: LD_INT 52
74641: DOUBLE
74642: EQUAL
74643: IFTRUE 74647
74645: GO 74673
74647: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
74648: LD_ADDR_VAR 0 3
74652: PUSH
74653: LD_INT 21
74655: PUSH
74656: LD_INT 22
74658: PUSH
74659: LD_INT 23
74661: PUSH
74662: LD_INT 24
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: ST_TO_ADDR
74671: GO 74752
74673: LD_INT 53
74675: DOUBLE
74676: EQUAL
74677: IFTRUE 74681
74679: GO 74699
74681: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
74682: LD_ADDR_VAR 0 3
74686: PUSH
74687: LD_INT 23
74689: PUSH
74690: LD_INT 24
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: ST_TO_ADDR
74697: GO 74752
74699: LD_INT 46
74701: DOUBLE
74702: EQUAL
74703: IFTRUE 74707
74705: GO 74725
74707: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
74708: LD_ADDR_VAR 0 3
74712: PUSH
74713: LD_INT 23
74715: PUSH
74716: LD_INT 24
74718: PUSH
74719: EMPTY
74720: LIST
74721: LIST
74722: ST_TO_ADDR
74723: GO 74752
74725: LD_INT 47
74727: DOUBLE
74728: EQUAL
74729: IFTRUE 74733
74731: GO 74751
74733: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74734: LD_ADDR_VAR 0 3
74738: PUSH
74739: LD_INT 23
74741: PUSH
74742: LD_INT 24
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: ST_TO_ADDR
74749: GO 74752
74751: POP
// result := ( chassis in result ) ;
74752: LD_ADDR_VAR 0 3
74756: PUSH
74757: LD_VAR 0 1
74761: PUSH
74762: LD_VAR 0 3
74766: IN
74767: ST_TO_ADDR
// end ;
74768: LD_VAR 0 3
74772: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
74773: LD_INT 0
74775: PPUSH
74776: PPUSH
74777: PPUSH
74778: PPUSH
74779: PPUSH
74780: PPUSH
74781: PPUSH
// result := array ;
74782: LD_ADDR_VAR 0 5
74786: PUSH
74787: LD_VAR 0 1
74791: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
74792: LD_VAR 0 1
74796: NOT
74797: PUSH
74798: LD_VAR 0 2
74802: NOT
74803: OR
74804: PUSH
74805: LD_VAR 0 3
74809: NOT
74810: OR
74811: PUSH
74812: LD_VAR 0 2
74816: PUSH
74817: LD_VAR 0 1
74821: GREATER
74822: OR
74823: PUSH
74824: LD_VAR 0 3
74828: PUSH
74829: LD_VAR 0 1
74833: GREATER
74834: OR
74835: IFFALSE 74839
// exit ;
74837: GO 75135
// if direction then
74839: LD_VAR 0 4
74843: IFFALSE 74907
// begin d := 1 ;
74845: LD_ADDR_VAR 0 9
74849: PUSH
74850: LD_INT 1
74852: ST_TO_ADDR
// if i_from > i_to then
74853: LD_VAR 0 2
74857: PUSH
74858: LD_VAR 0 3
74862: GREATER
74863: IFFALSE 74889
// length := ( array - i_from ) + i_to else
74865: LD_ADDR_VAR 0 11
74869: PUSH
74870: LD_VAR 0 1
74874: PUSH
74875: LD_VAR 0 2
74879: MINUS
74880: PUSH
74881: LD_VAR 0 3
74885: PLUS
74886: ST_TO_ADDR
74887: GO 74905
// length := i_to - i_from ;
74889: LD_ADDR_VAR 0 11
74893: PUSH
74894: LD_VAR 0 3
74898: PUSH
74899: LD_VAR 0 2
74903: MINUS
74904: ST_TO_ADDR
// end else
74905: GO 74968
// begin d := - 1 ;
74907: LD_ADDR_VAR 0 9
74911: PUSH
74912: LD_INT 1
74914: NEG
74915: ST_TO_ADDR
// if i_from > i_to then
74916: LD_VAR 0 2
74920: PUSH
74921: LD_VAR 0 3
74925: GREATER
74926: IFFALSE 74946
// length := i_from - i_to else
74928: LD_ADDR_VAR 0 11
74932: PUSH
74933: LD_VAR 0 2
74937: PUSH
74938: LD_VAR 0 3
74942: MINUS
74943: ST_TO_ADDR
74944: GO 74968
// length := ( array - i_to ) + i_from ;
74946: LD_ADDR_VAR 0 11
74950: PUSH
74951: LD_VAR 0 1
74955: PUSH
74956: LD_VAR 0 3
74960: MINUS
74961: PUSH
74962: LD_VAR 0 2
74966: PLUS
74967: ST_TO_ADDR
// end ; if not length then
74968: LD_VAR 0 11
74972: NOT
74973: IFFALSE 74977
// exit ;
74975: GO 75135
// tmp := array ;
74977: LD_ADDR_VAR 0 10
74981: PUSH
74982: LD_VAR 0 1
74986: ST_TO_ADDR
// for i = 1 to length do
74987: LD_ADDR_VAR 0 6
74991: PUSH
74992: DOUBLE
74993: LD_INT 1
74995: DEC
74996: ST_TO_ADDR
74997: LD_VAR 0 11
75001: PUSH
75002: FOR_TO
75003: IFFALSE 75123
// begin for j = 1 to array do
75005: LD_ADDR_VAR 0 7
75009: PUSH
75010: DOUBLE
75011: LD_INT 1
75013: DEC
75014: ST_TO_ADDR
75015: LD_VAR 0 1
75019: PUSH
75020: FOR_TO
75021: IFFALSE 75109
// begin k := j + d ;
75023: LD_ADDR_VAR 0 8
75027: PUSH
75028: LD_VAR 0 7
75032: PUSH
75033: LD_VAR 0 9
75037: PLUS
75038: ST_TO_ADDR
// if k > array then
75039: LD_VAR 0 8
75043: PUSH
75044: LD_VAR 0 1
75048: GREATER
75049: IFFALSE 75059
// k := 1 ;
75051: LD_ADDR_VAR 0 8
75055: PUSH
75056: LD_INT 1
75058: ST_TO_ADDR
// if not k then
75059: LD_VAR 0 8
75063: NOT
75064: IFFALSE 75076
// k := array ;
75066: LD_ADDR_VAR 0 8
75070: PUSH
75071: LD_VAR 0 1
75075: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
75076: LD_ADDR_VAR 0 10
75080: PUSH
75081: LD_VAR 0 10
75085: PPUSH
75086: LD_VAR 0 8
75090: PPUSH
75091: LD_VAR 0 1
75095: PUSH
75096: LD_VAR 0 7
75100: ARRAY
75101: PPUSH
75102: CALL_OW 1
75106: ST_TO_ADDR
// end ;
75107: GO 75020
75109: POP
75110: POP
// array := tmp ;
75111: LD_ADDR_VAR 0 1
75115: PUSH
75116: LD_VAR 0 10
75120: ST_TO_ADDR
// end ;
75121: GO 75002
75123: POP
75124: POP
// result := array ;
75125: LD_ADDR_VAR 0 5
75129: PUSH
75130: LD_VAR 0 1
75134: ST_TO_ADDR
// end ;
75135: LD_VAR 0 5
75139: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75140: LD_INT 0
75142: PPUSH
75143: PPUSH
// result := 0 ;
75144: LD_ADDR_VAR 0 3
75148: PUSH
75149: LD_INT 0
75151: ST_TO_ADDR
// if not array or not value in array then
75152: LD_VAR 0 1
75156: NOT
75157: PUSH
75158: LD_VAR 0 2
75162: PUSH
75163: LD_VAR 0 1
75167: IN
75168: NOT
75169: OR
75170: IFFALSE 75174
// exit ;
75172: GO 75228
// for i = 1 to array do
75174: LD_ADDR_VAR 0 4
75178: PUSH
75179: DOUBLE
75180: LD_INT 1
75182: DEC
75183: ST_TO_ADDR
75184: LD_VAR 0 1
75188: PUSH
75189: FOR_TO
75190: IFFALSE 75226
// if value = array [ i ] then
75192: LD_VAR 0 2
75196: PUSH
75197: LD_VAR 0 1
75201: PUSH
75202: LD_VAR 0 4
75206: ARRAY
75207: EQUAL
75208: IFFALSE 75224
// begin result := i ;
75210: LD_ADDR_VAR 0 3
75214: PUSH
75215: LD_VAR 0 4
75219: ST_TO_ADDR
// exit ;
75220: POP
75221: POP
75222: GO 75228
// end ;
75224: GO 75189
75226: POP
75227: POP
// end ;
75228: LD_VAR 0 3
75232: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75233: LD_INT 0
75235: PPUSH
// vc_chassis := chassis ;
75236: LD_ADDR_OWVAR 37
75240: PUSH
75241: LD_VAR 0 1
75245: ST_TO_ADDR
// vc_engine := engine ;
75246: LD_ADDR_OWVAR 39
75250: PUSH
75251: LD_VAR 0 2
75255: ST_TO_ADDR
// vc_control := control ;
75256: LD_ADDR_OWVAR 38
75260: PUSH
75261: LD_VAR 0 3
75265: ST_TO_ADDR
// vc_weapon := weapon ;
75266: LD_ADDR_OWVAR 40
75270: PUSH
75271: LD_VAR 0 4
75275: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75276: LD_ADDR_OWVAR 41
75280: PUSH
75281: LD_VAR 0 5
75285: ST_TO_ADDR
// end ;
75286: LD_VAR 0 6
75290: RET
// export function WantPlant ( unit ) ; var task ; begin
75291: LD_INT 0
75293: PPUSH
75294: PPUSH
// result := false ;
75295: LD_ADDR_VAR 0 2
75299: PUSH
75300: LD_INT 0
75302: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75303: LD_ADDR_VAR 0 3
75307: PUSH
75308: LD_VAR 0 1
75312: PPUSH
75313: CALL_OW 437
75317: ST_TO_ADDR
// if task then
75318: LD_VAR 0 3
75322: IFFALSE 75350
// if task [ 1 ] [ 1 ] = p then
75324: LD_VAR 0 3
75328: PUSH
75329: LD_INT 1
75331: ARRAY
75332: PUSH
75333: LD_INT 1
75335: ARRAY
75336: PUSH
75337: LD_STRING p
75339: EQUAL
75340: IFFALSE 75350
// result := true ;
75342: LD_ADDR_VAR 0 2
75346: PUSH
75347: LD_INT 1
75349: ST_TO_ADDR
// end ;
75350: LD_VAR 0 2
75354: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
75355: LD_INT 0
75357: PPUSH
75358: PPUSH
75359: PPUSH
75360: PPUSH
// if pos < 1 then
75361: LD_VAR 0 2
75365: PUSH
75366: LD_INT 1
75368: LESS
75369: IFFALSE 75373
// exit ;
75371: GO 75676
// if pos = 1 then
75373: LD_VAR 0 2
75377: PUSH
75378: LD_INT 1
75380: EQUAL
75381: IFFALSE 75414
// result := Replace ( arr , pos [ 1 ] , value ) else
75383: LD_ADDR_VAR 0 4
75387: PUSH
75388: LD_VAR 0 1
75392: PPUSH
75393: LD_VAR 0 2
75397: PUSH
75398: LD_INT 1
75400: ARRAY
75401: PPUSH
75402: LD_VAR 0 3
75406: PPUSH
75407: CALL_OW 1
75411: ST_TO_ADDR
75412: GO 75676
// begin tmp := arr ;
75414: LD_ADDR_VAR 0 6
75418: PUSH
75419: LD_VAR 0 1
75423: ST_TO_ADDR
// s_arr := [ tmp ] ;
75424: LD_ADDR_VAR 0 7
75428: PUSH
75429: LD_VAR 0 6
75433: PUSH
75434: EMPTY
75435: LIST
75436: ST_TO_ADDR
// for i = 1 to pos - 1 do
75437: LD_ADDR_VAR 0 5
75441: PUSH
75442: DOUBLE
75443: LD_INT 1
75445: DEC
75446: ST_TO_ADDR
75447: LD_VAR 0 2
75451: PUSH
75452: LD_INT 1
75454: MINUS
75455: PUSH
75456: FOR_TO
75457: IFFALSE 75502
// begin tmp := tmp [ pos [ i ] ] ;
75459: LD_ADDR_VAR 0 6
75463: PUSH
75464: LD_VAR 0 6
75468: PUSH
75469: LD_VAR 0 2
75473: PUSH
75474: LD_VAR 0 5
75478: ARRAY
75479: ARRAY
75480: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
75481: LD_ADDR_VAR 0 7
75485: PUSH
75486: LD_VAR 0 7
75490: PUSH
75491: LD_VAR 0 6
75495: PUSH
75496: EMPTY
75497: LIST
75498: ADD
75499: ST_TO_ADDR
// end ;
75500: GO 75456
75502: POP
75503: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
75504: LD_ADDR_VAR 0 6
75508: PUSH
75509: LD_VAR 0 6
75513: PPUSH
75514: LD_VAR 0 2
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: PPUSH
75525: LD_VAR 0 3
75529: PPUSH
75530: CALL_OW 1
75534: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
75535: LD_ADDR_VAR 0 7
75539: PUSH
75540: LD_VAR 0 7
75544: PPUSH
75545: LD_VAR 0 7
75549: PPUSH
75550: LD_VAR 0 6
75554: PPUSH
75555: CALL_OW 1
75559: ST_TO_ADDR
// for i = s_arr downto 2 do
75560: LD_ADDR_VAR 0 5
75564: PUSH
75565: DOUBLE
75566: LD_VAR 0 7
75570: INC
75571: ST_TO_ADDR
75572: LD_INT 2
75574: PUSH
75575: FOR_DOWNTO
75576: IFFALSE 75660
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
75578: LD_ADDR_VAR 0 6
75582: PUSH
75583: LD_VAR 0 7
75587: PUSH
75588: LD_VAR 0 5
75592: PUSH
75593: LD_INT 1
75595: MINUS
75596: ARRAY
75597: PPUSH
75598: LD_VAR 0 2
75602: PUSH
75603: LD_VAR 0 5
75607: PUSH
75608: LD_INT 1
75610: MINUS
75611: ARRAY
75612: PPUSH
75613: LD_VAR 0 7
75617: PUSH
75618: LD_VAR 0 5
75622: ARRAY
75623: PPUSH
75624: CALL_OW 1
75628: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
75629: LD_ADDR_VAR 0 7
75633: PUSH
75634: LD_VAR 0 7
75638: PPUSH
75639: LD_VAR 0 5
75643: PUSH
75644: LD_INT 1
75646: MINUS
75647: PPUSH
75648: LD_VAR 0 6
75652: PPUSH
75653: CALL_OW 1
75657: ST_TO_ADDR
// end ;
75658: GO 75575
75660: POP
75661: POP
// result := s_arr [ 1 ] ;
75662: LD_ADDR_VAR 0 4
75666: PUSH
75667: LD_VAR 0 7
75671: PUSH
75672: LD_INT 1
75674: ARRAY
75675: ST_TO_ADDR
// end ; end ;
75676: LD_VAR 0 4
75680: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
75681: LD_INT 0
75683: PPUSH
75684: PPUSH
// if not list then
75685: LD_VAR 0 1
75689: NOT
75690: IFFALSE 75694
// exit ;
75692: GO 75785
// i := list [ pos1 ] ;
75694: LD_ADDR_VAR 0 5
75698: PUSH
75699: LD_VAR 0 1
75703: PUSH
75704: LD_VAR 0 2
75708: ARRAY
75709: ST_TO_ADDR
// if not i then
75710: LD_VAR 0 5
75714: NOT
75715: IFFALSE 75719
// exit ;
75717: GO 75785
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
75719: LD_ADDR_VAR 0 1
75723: PUSH
75724: LD_VAR 0 1
75728: PPUSH
75729: LD_VAR 0 2
75733: PPUSH
75734: LD_VAR 0 1
75738: PUSH
75739: LD_VAR 0 3
75743: ARRAY
75744: PPUSH
75745: CALL_OW 1
75749: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
75750: LD_ADDR_VAR 0 1
75754: PUSH
75755: LD_VAR 0 1
75759: PPUSH
75760: LD_VAR 0 3
75764: PPUSH
75765: LD_VAR 0 5
75769: PPUSH
75770: CALL_OW 1
75774: ST_TO_ADDR
// result := list ;
75775: LD_ADDR_VAR 0 4
75779: PUSH
75780: LD_VAR 0 1
75784: ST_TO_ADDR
// end ;
75785: LD_VAR 0 4
75789: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
75790: LD_INT 0
75792: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
75793: LD_ADDR_VAR 0 5
75797: PUSH
75798: LD_VAR 0 1
75802: PPUSH
75803: CALL_OW 250
75807: PPUSH
75808: LD_VAR 0 1
75812: PPUSH
75813: CALL_OW 251
75817: PPUSH
75818: LD_VAR 0 2
75822: PPUSH
75823: LD_VAR 0 3
75827: PPUSH
75828: LD_VAR 0 4
75832: PPUSH
75833: CALL 76211 0 5
75837: ST_TO_ADDR
// end ;
75838: LD_VAR 0 5
75842: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
75843: LD_INT 0
75845: PPUSH
75846: PPUSH
75847: PPUSH
75848: PPUSH
// if not list or not unit then
75849: LD_VAR 0 2
75853: NOT
75854: PUSH
75855: LD_VAR 0 1
75859: NOT
75860: OR
75861: IFFALSE 75865
// exit ;
75863: GO 76206
// result := [ ] ;
75865: LD_ADDR_VAR 0 5
75869: PUSH
75870: EMPTY
75871: ST_TO_ADDR
// for i in list do
75872: LD_ADDR_VAR 0 6
75876: PUSH
75877: LD_VAR 0 2
75881: PUSH
75882: FOR_IN
75883: IFFALSE 76101
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75885: LD_ADDR_VAR 0 8
75889: PUSH
75890: LD_VAR 0 1
75894: PPUSH
75895: LD_VAR 0 6
75899: PUSH
75900: LD_INT 1
75902: ARRAY
75903: PPUSH
75904: LD_VAR 0 6
75908: PUSH
75909: LD_INT 2
75911: ARRAY
75912: PPUSH
75913: CALL_OW 297
75917: ST_TO_ADDR
// if not Count ( result ) then
75918: LD_VAR 0 5
75922: PPUSH
75923: CALL 72495 0 1
75927: NOT
75928: IFFALSE 75961
// begin result := Join ( result , [ i , tmp ] ) ;
75930: LD_ADDR_VAR 0 5
75934: PUSH
75935: LD_VAR 0 5
75939: PPUSH
75940: LD_VAR 0 6
75944: PUSH
75945: LD_VAR 0 8
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PPUSH
75954: CALL 108104 0 2
75958: ST_TO_ADDR
// continue ;
75959: GO 75882
// end ; if result [ result ] [ 2 ] <= tmp then
75961: LD_VAR 0 5
75965: PUSH
75966: LD_VAR 0 5
75970: ARRAY
75971: PUSH
75972: LD_INT 2
75974: ARRAY
75975: PUSH
75976: LD_VAR 0 8
75980: LESSEQUAL
75981: IFFALSE 76014
// result := Join ( result , [ i , tmp ] ) else
75983: LD_ADDR_VAR 0 5
75987: PUSH
75988: LD_VAR 0 5
75992: PPUSH
75993: LD_VAR 0 6
75997: PUSH
75998: LD_VAR 0 8
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PPUSH
76007: CALL 108104 0 2
76011: ST_TO_ADDR
76012: GO 76099
// begin for j := 1 to Count ( result ) do
76014: LD_ADDR_VAR 0 7
76018: PUSH
76019: DOUBLE
76020: LD_INT 1
76022: DEC
76023: ST_TO_ADDR
76024: LD_VAR 0 5
76028: PPUSH
76029: CALL 72495 0 1
76033: PUSH
76034: FOR_TO
76035: IFFALSE 76097
// begin if tmp < result [ j ] [ 2 ] then
76037: LD_VAR 0 8
76041: PUSH
76042: LD_VAR 0 5
76046: PUSH
76047: LD_VAR 0 7
76051: ARRAY
76052: PUSH
76053: LD_INT 2
76055: ARRAY
76056: LESS
76057: IFFALSE 76095
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76059: LD_ADDR_VAR 0 5
76063: PUSH
76064: LD_VAR 0 5
76068: PPUSH
76069: LD_VAR 0 7
76073: PPUSH
76074: LD_VAR 0 6
76078: PUSH
76079: LD_VAR 0 8
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: PPUSH
76088: CALL_OW 2
76092: ST_TO_ADDR
// break ;
76093: GO 76097
// end ; end ;
76095: GO 76034
76097: POP
76098: POP
// end ; end ;
76099: GO 75882
76101: POP
76102: POP
// if result and not asc then
76103: LD_VAR 0 5
76107: PUSH
76108: LD_VAR 0 3
76112: NOT
76113: AND
76114: IFFALSE 76131
// result := ReverseArray ( result ) ;
76116: LD_ADDR_VAR 0 5
76120: PUSH
76121: LD_VAR 0 5
76125: PPUSH
76126: CALL 103371 0 1
76130: ST_TO_ADDR
// tmp := [ ] ;
76131: LD_ADDR_VAR 0 8
76135: PUSH
76136: EMPTY
76137: ST_TO_ADDR
// if mode then
76138: LD_VAR 0 4
76142: IFFALSE 76206
// begin for i := 1 to result do
76144: LD_ADDR_VAR 0 6
76148: PUSH
76149: DOUBLE
76150: LD_INT 1
76152: DEC
76153: ST_TO_ADDR
76154: LD_VAR 0 5
76158: PUSH
76159: FOR_TO
76160: IFFALSE 76194
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76162: LD_ADDR_VAR 0 8
76166: PUSH
76167: LD_VAR 0 8
76171: PPUSH
76172: LD_VAR 0 5
76176: PUSH
76177: LD_VAR 0 6
76181: ARRAY
76182: PUSH
76183: LD_INT 1
76185: ARRAY
76186: PPUSH
76187: CALL 108104 0 2
76191: ST_TO_ADDR
76192: GO 76159
76194: POP
76195: POP
// result := tmp ;
76196: LD_ADDR_VAR 0 5
76200: PUSH
76201: LD_VAR 0 8
76205: ST_TO_ADDR
// end ; end ;
76206: LD_VAR 0 5
76210: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76211: LD_INT 0
76213: PPUSH
76214: PPUSH
76215: PPUSH
76216: PPUSH
// if not list then
76217: LD_VAR 0 3
76221: NOT
76222: IFFALSE 76226
// exit ;
76224: GO 76614
// result := [ ] ;
76226: LD_ADDR_VAR 0 6
76230: PUSH
76231: EMPTY
76232: ST_TO_ADDR
// for i in list do
76233: LD_ADDR_VAR 0 7
76237: PUSH
76238: LD_VAR 0 3
76242: PUSH
76243: FOR_IN
76244: IFFALSE 76446
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76246: LD_ADDR_VAR 0 9
76250: PUSH
76251: LD_VAR 0 7
76255: PPUSH
76256: LD_VAR 0 1
76260: PPUSH
76261: LD_VAR 0 2
76265: PPUSH
76266: CALL_OW 297
76270: ST_TO_ADDR
// if not result then
76271: LD_VAR 0 6
76275: NOT
76276: IFFALSE 76302
// result := [ [ i , tmp ] ] else
76278: LD_ADDR_VAR 0 6
76282: PUSH
76283: LD_VAR 0 7
76287: PUSH
76288: LD_VAR 0 9
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: EMPTY
76298: LIST
76299: ST_TO_ADDR
76300: GO 76444
// begin if result [ result ] [ 2 ] <= tmp then
76302: LD_VAR 0 6
76306: PUSH
76307: LD_VAR 0 6
76311: ARRAY
76312: PUSH
76313: LD_INT 2
76315: ARRAY
76316: PUSH
76317: LD_VAR 0 9
76321: LESSEQUAL
76322: IFFALSE 76364
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76324: LD_ADDR_VAR 0 6
76328: PUSH
76329: LD_VAR 0 6
76333: PPUSH
76334: LD_VAR 0 6
76338: PUSH
76339: LD_INT 1
76341: PLUS
76342: PPUSH
76343: LD_VAR 0 7
76347: PUSH
76348: LD_VAR 0 9
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PPUSH
76357: CALL_OW 2
76361: ST_TO_ADDR
76362: GO 76444
// for j := 1 to result do
76364: LD_ADDR_VAR 0 8
76368: PUSH
76369: DOUBLE
76370: LD_INT 1
76372: DEC
76373: ST_TO_ADDR
76374: LD_VAR 0 6
76378: PUSH
76379: FOR_TO
76380: IFFALSE 76442
// begin if tmp < result [ j ] [ 2 ] then
76382: LD_VAR 0 9
76386: PUSH
76387: LD_VAR 0 6
76391: PUSH
76392: LD_VAR 0 8
76396: ARRAY
76397: PUSH
76398: LD_INT 2
76400: ARRAY
76401: LESS
76402: IFFALSE 76440
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76404: LD_ADDR_VAR 0 6
76408: PUSH
76409: LD_VAR 0 6
76413: PPUSH
76414: LD_VAR 0 8
76418: PPUSH
76419: LD_VAR 0 7
76423: PUSH
76424: LD_VAR 0 9
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PPUSH
76433: CALL_OW 2
76437: ST_TO_ADDR
// break ;
76438: GO 76442
// end ; end ;
76440: GO 76379
76442: POP
76443: POP
// end ; end ;
76444: GO 76243
76446: POP
76447: POP
// if result and not asc then
76448: LD_VAR 0 6
76452: PUSH
76453: LD_VAR 0 4
76457: NOT
76458: AND
76459: IFFALSE 76534
// begin tmp := result ;
76461: LD_ADDR_VAR 0 9
76465: PUSH
76466: LD_VAR 0 6
76470: ST_TO_ADDR
// for i = tmp downto 1 do
76471: LD_ADDR_VAR 0 7
76475: PUSH
76476: DOUBLE
76477: LD_VAR 0 9
76481: INC
76482: ST_TO_ADDR
76483: LD_INT 1
76485: PUSH
76486: FOR_DOWNTO
76487: IFFALSE 76532
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
76489: LD_ADDR_VAR 0 6
76493: PUSH
76494: LD_VAR 0 6
76498: PPUSH
76499: LD_VAR 0 9
76503: PUSH
76504: LD_VAR 0 7
76508: MINUS
76509: PUSH
76510: LD_INT 1
76512: PLUS
76513: PPUSH
76514: LD_VAR 0 9
76518: PUSH
76519: LD_VAR 0 7
76523: ARRAY
76524: PPUSH
76525: CALL_OW 1
76529: ST_TO_ADDR
76530: GO 76486
76532: POP
76533: POP
// end ; tmp := [ ] ;
76534: LD_ADDR_VAR 0 9
76538: PUSH
76539: EMPTY
76540: ST_TO_ADDR
// if mode then
76541: LD_VAR 0 5
76545: IFFALSE 76614
// begin for i = 1 to result do
76547: LD_ADDR_VAR 0 7
76551: PUSH
76552: DOUBLE
76553: LD_INT 1
76555: DEC
76556: ST_TO_ADDR
76557: LD_VAR 0 6
76561: PUSH
76562: FOR_TO
76563: IFFALSE 76602
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
76565: LD_ADDR_VAR 0 9
76569: PUSH
76570: LD_VAR 0 9
76574: PPUSH
76575: LD_VAR 0 7
76579: PPUSH
76580: LD_VAR 0 6
76584: PUSH
76585: LD_VAR 0 7
76589: ARRAY
76590: PUSH
76591: LD_INT 1
76593: ARRAY
76594: PPUSH
76595: CALL_OW 1
76599: ST_TO_ADDR
76600: GO 76562
76602: POP
76603: POP
// result := tmp ;
76604: LD_ADDR_VAR 0 6
76608: PUSH
76609: LD_VAR 0 9
76613: ST_TO_ADDR
// end ; end ;
76614: LD_VAR 0 6
76618: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
76619: LD_INT 0
76621: PPUSH
76622: PPUSH
76623: PPUSH
76624: PPUSH
76625: PPUSH
76626: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
76627: LD_ADDR_VAR 0 5
76631: PUSH
76632: LD_INT 0
76634: PUSH
76635: LD_INT 0
76637: PUSH
76638: LD_INT 0
76640: PUSH
76641: EMPTY
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: LIST
76647: LIST
76648: ST_TO_ADDR
// if not x or not y then
76649: LD_VAR 0 2
76653: NOT
76654: PUSH
76655: LD_VAR 0 3
76659: NOT
76660: OR
76661: IFFALSE 76665
// exit ;
76663: GO 78315
// if not range then
76665: LD_VAR 0 4
76669: NOT
76670: IFFALSE 76680
// range := 10 ;
76672: LD_ADDR_VAR 0 4
76676: PUSH
76677: LD_INT 10
76679: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
76680: LD_ADDR_VAR 0 8
76684: PUSH
76685: LD_INT 81
76687: PUSH
76688: LD_VAR 0 1
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 92
76699: PUSH
76700: LD_VAR 0 2
76704: PUSH
76705: LD_VAR 0 3
76709: PUSH
76710: LD_VAR 0 4
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: PUSH
76721: LD_INT 3
76723: PUSH
76724: LD_INT 21
76726: PUSH
76727: LD_INT 3
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: EMPTY
76735: LIST
76736: LIST
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: LIST
76742: PPUSH
76743: CALL_OW 69
76747: ST_TO_ADDR
// if not tmp then
76748: LD_VAR 0 8
76752: NOT
76753: IFFALSE 76757
// exit ;
76755: GO 78315
// for i in tmp do
76757: LD_ADDR_VAR 0 6
76761: PUSH
76762: LD_VAR 0 8
76766: PUSH
76767: FOR_IN
76768: IFFALSE 78290
// begin points := [ 0 , 0 , 0 ] ;
76770: LD_ADDR_VAR 0 9
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: LD_INT 0
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: LIST
76788: ST_TO_ADDR
// bpoints := 1 ;
76789: LD_ADDR_VAR 0 10
76793: PUSH
76794: LD_INT 1
76796: ST_TO_ADDR
// case GetType ( i ) of unit_human :
76797: LD_VAR 0 6
76801: PPUSH
76802: CALL_OW 247
76806: PUSH
76807: LD_INT 1
76809: DOUBLE
76810: EQUAL
76811: IFTRUE 76815
76813: GO 77393
76815: POP
// begin if GetClass ( i ) = 1 then
76816: LD_VAR 0 6
76820: PPUSH
76821: CALL_OW 257
76825: PUSH
76826: LD_INT 1
76828: EQUAL
76829: IFFALSE 76850
// points := [ 10 , 5 , 3 ] ;
76831: LD_ADDR_VAR 0 9
76835: PUSH
76836: LD_INT 10
76838: PUSH
76839: LD_INT 5
76841: PUSH
76842: LD_INT 3
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: LIST
76849: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76850: LD_VAR 0 6
76854: PPUSH
76855: CALL_OW 257
76859: PUSH
76860: LD_INT 2
76862: PUSH
76863: LD_INT 3
76865: PUSH
76866: LD_INT 4
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: LIST
76873: IN
76874: IFFALSE 76895
// points := [ 3 , 2 , 1 ] ;
76876: LD_ADDR_VAR 0 9
76880: PUSH
76881: LD_INT 3
76883: PUSH
76884: LD_INT 2
76886: PUSH
76887: LD_INT 1
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: LIST
76894: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76895: LD_VAR 0 6
76899: PPUSH
76900: CALL_OW 257
76904: PUSH
76905: LD_INT 5
76907: EQUAL
76908: IFFALSE 76929
// points := [ 130 , 5 , 2 ] ;
76910: LD_ADDR_VAR 0 9
76914: PUSH
76915: LD_INT 130
76917: PUSH
76918: LD_INT 5
76920: PUSH
76921: LD_INT 2
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: LIST
76928: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76929: LD_VAR 0 6
76933: PPUSH
76934: CALL_OW 257
76938: PUSH
76939: LD_INT 8
76941: EQUAL
76942: IFFALSE 76963
// points := [ 35 , 35 , 30 ] ;
76944: LD_ADDR_VAR 0 9
76948: PUSH
76949: LD_INT 35
76951: PUSH
76952: LD_INT 35
76954: PUSH
76955: LD_INT 30
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: LIST
76962: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76963: LD_VAR 0 6
76967: PPUSH
76968: CALL_OW 257
76972: PUSH
76973: LD_INT 9
76975: EQUAL
76976: IFFALSE 76997
// points := [ 20 , 55 , 40 ] ;
76978: LD_ADDR_VAR 0 9
76982: PUSH
76983: LD_INT 20
76985: PUSH
76986: LD_INT 55
76988: PUSH
76989: LD_INT 40
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76997: LD_VAR 0 6
77001: PPUSH
77002: CALL_OW 257
77006: PUSH
77007: LD_INT 12
77009: PUSH
77010: LD_INT 16
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: IN
77017: IFFALSE 77038
// points := [ 5 , 3 , 2 ] ;
77019: LD_ADDR_VAR 0 9
77023: PUSH
77024: LD_INT 5
77026: PUSH
77027: LD_INT 3
77029: PUSH
77030: LD_INT 2
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: LIST
77037: ST_TO_ADDR
// if GetClass ( i ) = 17 then
77038: LD_VAR 0 6
77042: PPUSH
77043: CALL_OW 257
77047: PUSH
77048: LD_INT 17
77050: EQUAL
77051: IFFALSE 77072
// points := [ 100 , 50 , 75 ] ;
77053: LD_ADDR_VAR 0 9
77057: PUSH
77058: LD_INT 100
77060: PUSH
77061: LD_INT 50
77063: PUSH
77064: LD_INT 75
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: LIST
77071: ST_TO_ADDR
// if GetClass ( i ) = 15 then
77072: LD_VAR 0 6
77076: PPUSH
77077: CALL_OW 257
77081: PUSH
77082: LD_INT 15
77084: EQUAL
77085: IFFALSE 77106
// points := [ 10 , 5 , 3 ] ;
77087: LD_ADDR_VAR 0 9
77091: PUSH
77092: LD_INT 10
77094: PUSH
77095: LD_INT 5
77097: PUSH
77098: LD_INT 3
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: LIST
77105: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77106: LD_VAR 0 6
77110: PPUSH
77111: CALL_OW 257
77115: PUSH
77116: LD_INT 14
77118: EQUAL
77119: IFFALSE 77140
// points := [ 10 , 0 , 0 ] ;
77121: LD_ADDR_VAR 0 9
77125: PUSH
77126: LD_INT 10
77128: PUSH
77129: LD_INT 0
77131: PUSH
77132: LD_INT 0
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: LIST
77139: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77140: LD_VAR 0 6
77144: PPUSH
77145: CALL_OW 257
77149: PUSH
77150: LD_INT 11
77152: EQUAL
77153: IFFALSE 77174
// points := [ 30 , 10 , 5 ] ;
77155: LD_ADDR_VAR 0 9
77159: PUSH
77160: LD_INT 30
77162: PUSH
77163: LD_INT 10
77165: PUSH
77166: LD_INT 5
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: LIST
77173: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77174: LD_VAR 0 1
77178: PPUSH
77179: LD_INT 5
77181: PPUSH
77182: CALL_OW 321
77186: PUSH
77187: LD_INT 2
77189: EQUAL
77190: IFFALSE 77207
// bpoints := bpoints * 1.8 ;
77192: LD_ADDR_VAR 0 10
77196: PUSH
77197: LD_VAR 0 10
77201: PUSH
77202: LD_REAL  1.80000000000000E+0000
77205: MUL
77206: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77207: LD_VAR 0 6
77211: PPUSH
77212: CALL_OW 257
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: LD_INT 2
77222: PUSH
77223: LD_INT 3
77225: PUSH
77226: LD_INT 4
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: IN
77235: PUSH
77236: LD_VAR 0 1
77240: PPUSH
77241: LD_INT 51
77243: PPUSH
77244: CALL_OW 321
77248: PUSH
77249: LD_INT 2
77251: EQUAL
77252: AND
77253: IFFALSE 77270
// bpoints := bpoints * 1.2 ;
77255: LD_ADDR_VAR 0 10
77259: PUSH
77260: LD_VAR 0 10
77264: PUSH
77265: LD_REAL  1.20000000000000E+0000
77268: MUL
77269: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77270: LD_VAR 0 6
77274: PPUSH
77275: CALL_OW 257
77279: PUSH
77280: LD_INT 5
77282: PUSH
77283: LD_INT 7
77285: PUSH
77286: LD_INT 9
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: LIST
77293: IN
77294: PUSH
77295: LD_VAR 0 1
77299: PPUSH
77300: LD_INT 52
77302: PPUSH
77303: CALL_OW 321
77307: PUSH
77308: LD_INT 2
77310: EQUAL
77311: AND
77312: IFFALSE 77329
// bpoints := bpoints * 1.5 ;
77314: LD_ADDR_VAR 0 10
77318: PUSH
77319: LD_VAR 0 10
77323: PUSH
77324: LD_REAL  1.50000000000000E+0000
77327: MUL
77328: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
77329: LD_VAR 0 1
77333: PPUSH
77334: LD_INT 66
77336: PPUSH
77337: CALL_OW 321
77341: PUSH
77342: LD_INT 2
77344: EQUAL
77345: IFFALSE 77362
// bpoints := bpoints * 1.1 ;
77347: LD_ADDR_VAR 0 10
77351: PUSH
77352: LD_VAR 0 10
77356: PUSH
77357: LD_REAL  1.10000000000000E+0000
77360: MUL
77361: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
77362: LD_ADDR_VAR 0 10
77366: PUSH
77367: LD_VAR 0 10
77371: PUSH
77372: LD_VAR 0 6
77376: PPUSH
77377: LD_INT 1
77379: PPUSH
77380: CALL_OW 259
77384: PUSH
77385: LD_REAL  1.15000000000000E+0000
77388: MUL
77389: MUL
77390: ST_TO_ADDR
// end ; unit_vehicle :
77391: GO 78219
77393: LD_INT 2
77395: DOUBLE
77396: EQUAL
77397: IFTRUE 77401
77399: GO 78207
77401: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
77402: LD_VAR 0 6
77406: PPUSH
77407: CALL_OW 264
77411: PUSH
77412: LD_INT 2
77414: PUSH
77415: LD_INT 42
77417: PUSH
77418: LD_INT 24
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: LIST
77425: IN
77426: IFFALSE 77447
// points := [ 25 , 5 , 3 ] ;
77428: LD_ADDR_VAR 0 9
77432: PUSH
77433: LD_INT 25
77435: PUSH
77436: LD_INT 5
77438: PUSH
77439: LD_INT 3
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: LIST
77446: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
77447: LD_VAR 0 6
77451: PPUSH
77452: CALL_OW 264
77456: PUSH
77457: LD_INT 4
77459: PUSH
77460: LD_INT 43
77462: PUSH
77463: LD_INT 25
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: LIST
77470: IN
77471: IFFALSE 77492
// points := [ 40 , 15 , 5 ] ;
77473: LD_ADDR_VAR 0 9
77477: PUSH
77478: LD_INT 40
77480: PUSH
77481: LD_INT 15
77483: PUSH
77484: LD_INT 5
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: LIST
77491: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
77492: LD_VAR 0 6
77496: PPUSH
77497: CALL_OW 264
77501: PUSH
77502: LD_INT 3
77504: PUSH
77505: LD_INT 23
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: IN
77512: IFFALSE 77533
// points := [ 7 , 25 , 8 ] ;
77514: LD_ADDR_VAR 0 9
77518: PUSH
77519: LD_INT 7
77521: PUSH
77522: LD_INT 25
77524: PUSH
77525: LD_INT 8
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: LIST
77532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
77533: LD_VAR 0 6
77537: PPUSH
77538: CALL_OW 264
77542: PUSH
77543: LD_INT 5
77545: PUSH
77546: LD_INT 27
77548: PUSH
77549: LD_INT 44
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: LIST
77556: IN
77557: IFFALSE 77578
// points := [ 14 , 50 , 16 ] ;
77559: LD_ADDR_VAR 0 9
77563: PUSH
77564: LD_INT 14
77566: PUSH
77567: LD_INT 50
77569: PUSH
77570: LD_INT 16
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: LIST
77577: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
77578: LD_VAR 0 6
77582: PPUSH
77583: CALL_OW 264
77587: PUSH
77588: LD_INT 6
77590: PUSH
77591: LD_INT 46
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: IN
77598: IFFALSE 77619
// points := [ 32 , 120 , 70 ] ;
77600: LD_ADDR_VAR 0 9
77604: PUSH
77605: LD_INT 32
77607: PUSH
77608: LD_INT 120
77610: PUSH
77611: LD_INT 70
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
77619: LD_VAR 0 6
77623: PPUSH
77624: CALL_OW 264
77628: PUSH
77629: LD_INT 7
77631: PUSH
77632: LD_INT 28
77634: PUSH
77635: LD_INT 45
77637: PUSH
77638: LD_INT 92
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: IN
77647: IFFALSE 77668
// points := [ 35 , 20 , 45 ] ;
77649: LD_ADDR_VAR 0 9
77653: PUSH
77654: LD_INT 35
77656: PUSH
77657: LD_INT 20
77659: PUSH
77660: LD_INT 45
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
77668: LD_VAR 0 6
77672: PPUSH
77673: CALL_OW 264
77677: PUSH
77678: LD_INT 47
77680: PUSH
77681: EMPTY
77682: LIST
77683: IN
77684: IFFALSE 77705
// points := [ 67 , 45 , 75 ] ;
77686: LD_ADDR_VAR 0 9
77690: PUSH
77691: LD_INT 67
77693: PUSH
77694: LD_INT 45
77696: PUSH
77697: LD_INT 75
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: LIST
77704: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
77705: LD_VAR 0 6
77709: PPUSH
77710: CALL_OW 264
77714: PUSH
77715: LD_INT 26
77717: PUSH
77718: EMPTY
77719: LIST
77720: IN
77721: IFFALSE 77742
// points := [ 120 , 30 , 80 ] ;
77723: LD_ADDR_VAR 0 9
77727: PUSH
77728: LD_INT 120
77730: PUSH
77731: LD_INT 30
77733: PUSH
77734: LD_INT 80
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
77742: LD_VAR 0 6
77746: PPUSH
77747: CALL_OW 264
77751: PUSH
77752: LD_INT 22
77754: PUSH
77755: EMPTY
77756: LIST
77757: IN
77758: IFFALSE 77779
// points := [ 40 , 1 , 1 ] ;
77760: LD_ADDR_VAR 0 9
77764: PUSH
77765: LD_INT 40
77767: PUSH
77768: LD_INT 1
77770: PUSH
77771: LD_INT 1
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: LIST
77778: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
77779: LD_VAR 0 6
77783: PPUSH
77784: CALL_OW 264
77788: PUSH
77789: LD_INT 29
77791: PUSH
77792: EMPTY
77793: LIST
77794: IN
77795: IFFALSE 77816
// points := [ 70 , 200 , 400 ] ;
77797: LD_ADDR_VAR 0 9
77801: PUSH
77802: LD_INT 70
77804: PUSH
77805: LD_INT 200
77807: PUSH
77808: LD_INT 400
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: LIST
77815: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
77816: LD_VAR 0 6
77820: PPUSH
77821: CALL_OW 264
77825: PUSH
77826: LD_INT 14
77828: PUSH
77829: LD_INT 53
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: IN
77836: IFFALSE 77857
// points := [ 40 , 10 , 20 ] ;
77838: LD_ADDR_VAR 0 9
77842: PUSH
77843: LD_INT 40
77845: PUSH
77846: LD_INT 10
77848: PUSH
77849: LD_INT 20
77851: PUSH
77852: EMPTY
77853: LIST
77854: LIST
77855: LIST
77856: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77857: LD_VAR 0 6
77861: PPUSH
77862: CALL_OW 264
77866: PUSH
77867: LD_INT 9
77869: PUSH
77870: EMPTY
77871: LIST
77872: IN
77873: IFFALSE 77894
// points := [ 5 , 70 , 20 ] ;
77875: LD_ADDR_VAR 0 9
77879: PUSH
77880: LD_INT 5
77882: PUSH
77883: LD_INT 70
77885: PUSH
77886: LD_INT 20
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: LIST
77893: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77894: LD_VAR 0 6
77898: PPUSH
77899: CALL_OW 264
77903: PUSH
77904: LD_INT 10
77906: PUSH
77907: EMPTY
77908: LIST
77909: IN
77910: IFFALSE 77931
// points := [ 35 , 110 , 70 ] ;
77912: LD_ADDR_VAR 0 9
77916: PUSH
77917: LD_INT 35
77919: PUSH
77920: LD_INT 110
77922: PUSH
77923: LD_INT 70
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: LIST
77930: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77931: LD_VAR 0 6
77935: PPUSH
77936: CALL_OW 265
77940: PUSH
77941: LD_INT 25
77943: EQUAL
77944: IFFALSE 77965
// points := [ 80 , 65 , 100 ] ;
77946: LD_ADDR_VAR 0 9
77950: PUSH
77951: LD_INT 80
77953: PUSH
77954: LD_INT 65
77956: PUSH
77957: LD_INT 100
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: LIST
77964: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77965: LD_VAR 0 6
77969: PPUSH
77970: CALL_OW 263
77974: PUSH
77975: LD_INT 1
77977: EQUAL
77978: IFFALSE 78013
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77980: LD_ADDR_VAR 0 10
77984: PUSH
77985: LD_VAR 0 10
77989: PUSH
77990: LD_VAR 0 6
77994: PPUSH
77995: CALL_OW 311
77999: PPUSH
78000: LD_INT 3
78002: PPUSH
78003: CALL_OW 259
78007: PUSH
78008: LD_INT 4
78010: MUL
78011: MUL
78012: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
78013: LD_VAR 0 6
78017: PPUSH
78018: CALL_OW 263
78022: PUSH
78023: LD_INT 2
78025: EQUAL
78026: IFFALSE 78077
// begin j := IsControledBy ( i ) ;
78028: LD_ADDR_VAR 0 7
78032: PUSH
78033: LD_VAR 0 6
78037: PPUSH
78038: CALL_OW 312
78042: ST_TO_ADDR
// if j then
78043: LD_VAR 0 7
78047: IFFALSE 78077
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
78049: LD_ADDR_VAR 0 10
78053: PUSH
78054: LD_VAR 0 10
78058: PUSH
78059: LD_VAR 0 7
78063: PPUSH
78064: LD_INT 3
78066: PPUSH
78067: CALL_OW 259
78071: PUSH
78072: LD_INT 3
78074: MUL
78075: MUL
78076: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
78077: LD_VAR 0 6
78081: PPUSH
78082: CALL_OW 264
78086: PUSH
78087: LD_INT 5
78089: PUSH
78090: LD_INT 6
78092: PUSH
78093: LD_INT 46
78095: PUSH
78096: LD_INT 44
78098: PUSH
78099: LD_INT 47
78101: PUSH
78102: LD_INT 45
78104: PUSH
78105: LD_INT 28
78107: PUSH
78108: LD_INT 7
78110: PUSH
78111: LD_INT 27
78113: PUSH
78114: LD_INT 29
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: IN
78129: PUSH
78130: LD_VAR 0 1
78134: PPUSH
78135: LD_INT 52
78137: PPUSH
78138: CALL_OW 321
78142: PUSH
78143: LD_INT 2
78145: EQUAL
78146: AND
78147: IFFALSE 78164
// bpoints := bpoints * 1.2 ;
78149: LD_ADDR_VAR 0 10
78153: PUSH
78154: LD_VAR 0 10
78158: PUSH
78159: LD_REAL  1.20000000000000E+0000
78162: MUL
78163: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78164: LD_VAR 0 6
78168: PPUSH
78169: CALL_OW 264
78173: PUSH
78174: LD_INT 6
78176: PUSH
78177: LD_INT 46
78179: PUSH
78180: LD_INT 47
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: LIST
78187: IN
78188: IFFALSE 78205
// bpoints := bpoints * 1.2 ;
78190: LD_ADDR_VAR 0 10
78194: PUSH
78195: LD_VAR 0 10
78199: PUSH
78200: LD_REAL  1.20000000000000E+0000
78203: MUL
78204: ST_TO_ADDR
// end ; unit_building :
78205: GO 78219
78207: LD_INT 3
78209: DOUBLE
78210: EQUAL
78211: IFTRUE 78215
78213: GO 78218
78215: POP
// ; end ;
78216: GO 78219
78218: POP
// for j = 1 to 3 do
78219: LD_ADDR_VAR 0 7
78223: PUSH
78224: DOUBLE
78225: LD_INT 1
78227: DEC
78228: ST_TO_ADDR
78229: LD_INT 3
78231: PUSH
78232: FOR_TO
78233: IFFALSE 78286
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78235: LD_ADDR_VAR 0 5
78239: PUSH
78240: LD_VAR 0 5
78244: PPUSH
78245: LD_VAR 0 7
78249: PPUSH
78250: LD_VAR 0 5
78254: PUSH
78255: LD_VAR 0 7
78259: ARRAY
78260: PUSH
78261: LD_VAR 0 9
78265: PUSH
78266: LD_VAR 0 7
78270: ARRAY
78271: PUSH
78272: LD_VAR 0 10
78276: MUL
78277: PLUS
78278: PPUSH
78279: CALL_OW 1
78283: ST_TO_ADDR
78284: GO 78232
78286: POP
78287: POP
// end ;
78288: GO 76767
78290: POP
78291: POP
// result := Replace ( result , 4 , tmp ) ;
78292: LD_ADDR_VAR 0 5
78296: PUSH
78297: LD_VAR 0 5
78301: PPUSH
78302: LD_INT 4
78304: PPUSH
78305: LD_VAR 0 8
78309: PPUSH
78310: CALL_OW 1
78314: ST_TO_ADDR
// end ;
78315: LD_VAR 0 5
78319: RET
// export function DangerAtRange ( unit , range ) ; begin
78320: LD_INT 0
78322: PPUSH
// if not unit then
78323: LD_VAR 0 1
78327: NOT
78328: IFFALSE 78332
// exit ;
78330: GO 78377
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
78332: LD_ADDR_VAR 0 3
78336: PUSH
78337: LD_VAR 0 1
78341: PPUSH
78342: CALL_OW 255
78346: PPUSH
78347: LD_VAR 0 1
78351: PPUSH
78352: CALL_OW 250
78356: PPUSH
78357: LD_VAR 0 1
78361: PPUSH
78362: CALL_OW 251
78366: PPUSH
78367: LD_VAR 0 2
78371: PPUSH
78372: CALL 76619 0 4
78376: ST_TO_ADDR
// end ;
78377: LD_VAR 0 3
78381: RET
// export function DangerInArea ( side , area ) ; begin
78382: LD_INT 0
78384: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
78385: LD_ADDR_VAR 0 3
78389: PUSH
78390: LD_VAR 0 2
78394: PPUSH
78395: LD_INT 81
78397: PUSH
78398: LD_VAR 0 1
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PPUSH
78407: CALL_OW 70
78411: ST_TO_ADDR
// end ;
78412: LD_VAR 0 3
78416: RET
// export function IsExtension ( b ) ; begin
78417: LD_INT 0
78419: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
78420: LD_ADDR_VAR 0 2
78424: PUSH
78425: LD_VAR 0 1
78429: PUSH
78430: LD_INT 23
78432: PUSH
78433: LD_INT 20
78435: PUSH
78436: LD_INT 22
78438: PUSH
78439: LD_INT 17
78441: PUSH
78442: LD_INT 24
78444: PUSH
78445: LD_INT 21
78447: PUSH
78448: LD_INT 19
78450: PUSH
78451: LD_INT 16
78453: PUSH
78454: LD_INT 25
78456: PUSH
78457: LD_INT 18
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: LIST
78464: LIST
78465: LIST
78466: LIST
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: IN
78472: ST_TO_ADDR
// end ;
78473: LD_VAR 0 2
78477: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
78478: LD_INT 0
78480: PPUSH
78481: PPUSH
78482: PPUSH
// result := [ ] ;
78483: LD_ADDR_VAR 0 4
78487: PUSH
78488: EMPTY
78489: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
78490: LD_ADDR_VAR 0 5
78494: PUSH
78495: LD_VAR 0 2
78499: PPUSH
78500: LD_INT 21
78502: PUSH
78503: LD_INT 3
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PPUSH
78510: CALL_OW 70
78514: ST_TO_ADDR
// if not tmp then
78515: LD_VAR 0 5
78519: NOT
78520: IFFALSE 78524
// exit ;
78522: GO 78588
// if checkLink then
78524: LD_VAR 0 3
78528: IFFALSE 78578
// begin for i in tmp do
78530: LD_ADDR_VAR 0 6
78534: PUSH
78535: LD_VAR 0 5
78539: PUSH
78540: FOR_IN
78541: IFFALSE 78576
// if GetBase ( i ) <> base then
78543: LD_VAR 0 6
78547: PPUSH
78548: CALL_OW 274
78552: PUSH
78553: LD_VAR 0 1
78557: NONEQUAL
78558: IFFALSE 78574
// ComLinkToBase ( base , i ) ;
78560: LD_VAR 0 1
78564: PPUSH
78565: LD_VAR 0 6
78569: PPUSH
78570: CALL_OW 169
78574: GO 78540
78576: POP
78577: POP
// end ; result := tmp ;
78578: LD_ADDR_VAR 0 4
78582: PUSH
78583: LD_VAR 0 5
78587: ST_TO_ADDR
// end ;
78588: LD_VAR 0 4
78592: RET
// export function ComComplete ( units , b ) ; var i ; begin
78593: LD_INT 0
78595: PPUSH
78596: PPUSH
// if not units then
78597: LD_VAR 0 1
78601: NOT
78602: IFFALSE 78606
// exit ;
78604: GO 78696
// for i in units do
78606: LD_ADDR_VAR 0 4
78610: PUSH
78611: LD_VAR 0 1
78615: PUSH
78616: FOR_IN
78617: IFFALSE 78694
// if BuildingStatus ( b ) = bs_build then
78619: LD_VAR 0 2
78623: PPUSH
78624: CALL_OW 461
78628: PUSH
78629: LD_INT 1
78631: EQUAL
78632: IFFALSE 78692
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
78634: LD_VAR 0 4
78638: PPUSH
78639: LD_STRING h
78641: PUSH
78642: LD_VAR 0 2
78646: PPUSH
78647: CALL_OW 250
78651: PUSH
78652: LD_VAR 0 2
78656: PPUSH
78657: CALL_OW 251
78661: PUSH
78662: LD_VAR 0 2
78666: PUSH
78667: LD_INT 0
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: LD_INT 0
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: PUSH
78685: EMPTY
78686: LIST
78687: PPUSH
78688: CALL_OW 446
78692: GO 78616
78694: POP
78695: POP
// end ;
78696: LD_VAR 0 3
78700: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
78701: LD_INT 0
78703: PPUSH
78704: PPUSH
78705: PPUSH
78706: PPUSH
78707: PPUSH
78708: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
78709: LD_VAR 0 1
78713: NOT
78714: PUSH
78715: LD_VAR 0 1
78719: PPUSH
78720: CALL_OW 263
78724: PUSH
78725: LD_INT 2
78727: NONEQUAL
78728: OR
78729: IFFALSE 78733
// exit ;
78731: GO 79049
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
78733: LD_ADDR_VAR 0 6
78737: PUSH
78738: LD_INT 22
78740: PUSH
78741: LD_VAR 0 1
78745: PPUSH
78746: CALL_OW 255
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: PUSH
78755: LD_INT 2
78757: PUSH
78758: LD_INT 30
78760: PUSH
78761: LD_INT 36
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 34
78770: PUSH
78771: LD_INT 31
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: LIST
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PPUSH
78787: CALL_OW 69
78791: ST_TO_ADDR
// if not tmp then
78792: LD_VAR 0 6
78796: NOT
78797: IFFALSE 78801
// exit ;
78799: GO 79049
// result := [ ] ;
78801: LD_ADDR_VAR 0 2
78805: PUSH
78806: EMPTY
78807: ST_TO_ADDR
// for i in tmp do
78808: LD_ADDR_VAR 0 3
78812: PUSH
78813: LD_VAR 0 6
78817: PUSH
78818: FOR_IN
78819: IFFALSE 78890
// begin t := UnitsInside ( i ) ;
78821: LD_ADDR_VAR 0 4
78825: PUSH
78826: LD_VAR 0 3
78830: PPUSH
78831: CALL_OW 313
78835: ST_TO_ADDR
// if t then
78836: LD_VAR 0 4
78840: IFFALSE 78888
// for j in t do
78842: LD_ADDR_VAR 0 7
78846: PUSH
78847: LD_VAR 0 4
78851: PUSH
78852: FOR_IN
78853: IFFALSE 78886
// result := Replace ( result , result + 1 , j ) ;
78855: LD_ADDR_VAR 0 2
78859: PUSH
78860: LD_VAR 0 2
78864: PPUSH
78865: LD_VAR 0 2
78869: PUSH
78870: LD_INT 1
78872: PLUS
78873: PPUSH
78874: LD_VAR 0 7
78878: PPUSH
78879: CALL_OW 1
78883: ST_TO_ADDR
78884: GO 78852
78886: POP
78887: POP
// end ;
78888: GO 78818
78890: POP
78891: POP
// if not result then
78892: LD_VAR 0 2
78896: NOT
78897: IFFALSE 78901
// exit ;
78899: GO 79049
// mech := result [ 1 ] ;
78901: LD_ADDR_VAR 0 5
78905: PUSH
78906: LD_VAR 0 2
78910: PUSH
78911: LD_INT 1
78913: ARRAY
78914: ST_TO_ADDR
// if result > 1 then
78915: LD_VAR 0 2
78919: PUSH
78920: LD_INT 1
78922: GREATER
78923: IFFALSE 79035
// begin for i = 2 to result do
78925: LD_ADDR_VAR 0 3
78929: PUSH
78930: DOUBLE
78931: LD_INT 2
78933: DEC
78934: ST_TO_ADDR
78935: LD_VAR 0 2
78939: PUSH
78940: FOR_TO
78941: IFFALSE 79033
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78943: LD_ADDR_VAR 0 4
78947: PUSH
78948: LD_VAR 0 2
78952: PUSH
78953: LD_VAR 0 3
78957: ARRAY
78958: PPUSH
78959: LD_INT 3
78961: PPUSH
78962: CALL_OW 259
78966: PUSH
78967: LD_VAR 0 2
78971: PUSH
78972: LD_VAR 0 3
78976: ARRAY
78977: PPUSH
78978: CALL_OW 432
78982: MINUS
78983: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78984: LD_VAR 0 4
78988: PUSH
78989: LD_VAR 0 5
78993: PPUSH
78994: LD_INT 3
78996: PPUSH
78997: CALL_OW 259
79001: PUSH
79002: LD_VAR 0 5
79006: PPUSH
79007: CALL_OW 432
79011: MINUS
79012: GREATEREQUAL
79013: IFFALSE 79031
// mech := result [ i ] ;
79015: LD_ADDR_VAR 0 5
79019: PUSH
79020: LD_VAR 0 2
79024: PUSH
79025: LD_VAR 0 3
79029: ARRAY
79030: ST_TO_ADDR
// end ;
79031: GO 78940
79033: POP
79034: POP
// end ; ComLinkTo ( vehicle , mech ) ;
79035: LD_VAR 0 1
79039: PPUSH
79040: LD_VAR 0 5
79044: PPUSH
79045: CALL_OW 135
// end ;
79049: LD_VAR 0 2
79053: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
79054: LD_INT 0
79056: PPUSH
79057: PPUSH
79058: PPUSH
79059: PPUSH
79060: PPUSH
79061: PPUSH
79062: PPUSH
79063: PPUSH
79064: PPUSH
79065: PPUSH
79066: PPUSH
79067: PPUSH
79068: PPUSH
// result := [ ] ;
79069: LD_ADDR_VAR 0 7
79073: PUSH
79074: EMPTY
79075: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
79076: LD_VAR 0 1
79080: PPUSH
79081: CALL_OW 266
79085: PUSH
79086: LD_INT 0
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: IN
79096: NOT
79097: IFFALSE 79101
// exit ;
79099: GO 80735
// if name then
79101: LD_VAR 0 3
79105: IFFALSE 79121
// SetBName ( base_dep , name ) ;
79107: LD_VAR 0 1
79111: PPUSH
79112: LD_VAR 0 3
79116: PPUSH
79117: CALL_OW 500
// base := GetBase ( base_dep ) ;
79121: LD_ADDR_VAR 0 15
79125: PUSH
79126: LD_VAR 0 1
79130: PPUSH
79131: CALL_OW 274
79135: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79136: LD_ADDR_VAR 0 16
79140: PUSH
79141: LD_VAR 0 1
79145: PPUSH
79146: CALL_OW 255
79150: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79151: LD_ADDR_VAR 0 17
79155: PUSH
79156: LD_VAR 0 1
79160: PPUSH
79161: CALL_OW 248
79165: ST_TO_ADDR
// if sources then
79166: LD_VAR 0 5
79170: IFFALSE 79217
// for i = 1 to 3 do
79172: LD_ADDR_VAR 0 8
79176: PUSH
79177: DOUBLE
79178: LD_INT 1
79180: DEC
79181: ST_TO_ADDR
79182: LD_INT 3
79184: PUSH
79185: FOR_TO
79186: IFFALSE 79215
// AddResourceType ( base , i , sources [ i ] ) ;
79188: LD_VAR 0 15
79192: PPUSH
79193: LD_VAR 0 8
79197: PPUSH
79198: LD_VAR 0 5
79202: PUSH
79203: LD_VAR 0 8
79207: ARRAY
79208: PPUSH
79209: CALL_OW 276
79213: GO 79185
79215: POP
79216: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79217: LD_ADDR_VAR 0 18
79221: PUSH
79222: LD_VAR 0 15
79226: PPUSH
79227: LD_VAR 0 2
79231: PPUSH
79232: LD_INT 1
79234: PPUSH
79235: CALL 78478 0 3
79239: ST_TO_ADDR
// InitHc ;
79240: CALL_OW 19
// InitUc ;
79244: CALL_OW 18
// uc_side := side ;
79248: LD_ADDR_OWVAR 20
79252: PUSH
79253: LD_VAR 0 16
79257: ST_TO_ADDR
// uc_nation := nation ;
79258: LD_ADDR_OWVAR 21
79262: PUSH
79263: LD_VAR 0 17
79267: ST_TO_ADDR
// if buildings then
79268: LD_VAR 0 18
79272: IFFALSE 80594
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79274: LD_ADDR_VAR 0 19
79278: PUSH
79279: LD_VAR 0 18
79283: PPUSH
79284: LD_INT 2
79286: PUSH
79287: LD_INT 30
79289: PUSH
79290: LD_INT 29
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 30
79299: PUSH
79300: LD_INT 30
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: LIST
79311: PPUSH
79312: CALL_OW 72
79316: ST_TO_ADDR
// if tmp then
79317: LD_VAR 0 19
79321: IFFALSE 79369
// for i in tmp do
79323: LD_ADDR_VAR 0 8
79327: PUSH
79328: LD_VAR 0 19
79332: PUSH
79333: FOR_IN
79334: IFFALSE 79367
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
79336: LD_VAR 0 8
79340: PPUSH
79341: CALL_OW 250
79345: PPUSH
79346: LD_VAR 0 8
79350: PPUSH
79351: CALL_OW 251
79355: PPUSH
79356: LD_VAR 0 16
79360: PPUSH
79361: CALL_OW 441
79365: GO 79333
79367: POP
79368: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
79369: LD_VAR 0 18
79373: PPUSH
79374: LD_INT 2
79376: PUSH
79377: LD_INT 30
79379: PUSH
79380: LD_INT 32
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 30
79389: PUSH
79390: LD_INT 33
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: LIST
79401: PPUSH
79402: CALL_OW 72
79406: IFFALSE 79494
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
79408: LD_ADDR_VAR 0 8
79412: PUSH
79413: LD_VAR 0 18
79417: PPUSH
79418: LD_INT 2
79420: PUSH
79421: LD_INT 30
79423: PUSH
79424: LD_INT 32
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 30
79433: PUSH
79434: LD_INT 33
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: LIST
79445: PPUSH
79446: CALL_OW 72
79450: PUSH
79451: FOR_IN
79452: IFFALSE 79492
// begin if not GetBWeapon ( i ) then
79454: LD_VAR 0 8
79458: PPUSH
79459: CALL_OW 269
79463: NOT
79464: IFFALSE 79490
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
79466: LD_VAR 0 8
79470: PPUSH
79471: LD_VAR 0 8
79475: PPUSH
79476: LD_VAR 0 2
79480: PPUSH
79481: CALL 80740 0 2
79485: PPUSH
79486: CALL_OW 431
// end ;
79490: GO 79451
79492: POP
79493: POP
// end ; for i = 1 to personel do
79494: LD_ADDR_VAR 0 8
79498: PUSH
79499: DOUBLE
79500: LD_INT 1
79502: DEC
79503: ST_TO_ADDR
79504: LD_VAR 0 6
79508: PUSH
79509: FOR_TO
79510: IFFALSE 80574
// begin if i > 4 then
79512: LD_VAR 0 8
79516: PUSH
79517: LD_INT 4
79519: GREATER
79520: IFFALSE 79524
// break ;
79522: GO 80574
// case i of 1 :
79524: LD_VAR 0 8
79528: PUSH
79529: LD_INT 1
79531: DOUBLE
79532: EQUAL
79533: IFTRUE 79537
79535: GO 79617
79537: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
79538: LD_ADDR_VAR 0 12
79542: PUSH
79543: LD_VAR 0 18
79547: PPUSH
79548: LD_INT 22
79550: PUSH
79551: LD_VAR 0 16
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 58
79562: PUSH
79563: EMPTY
79564: LIST
79565: PUSH
79566: LD_INT 2
79568: PUSH
79569: LD_INT 30
79571: PUSH
79572: LD_INT 32
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: PUSH
79579: LD_INT 30
79581: PUSH
79582: LD_INT 4
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 30
79591: PUSH
79592: LD_INT 5
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: LIST
79609: PPUSH
79610: CALL_OW 72
79614: ST_TO_ADDR
79615: GO 79839
79617: LD_INT 2
79619: DOUBLE
79620: EQUAL
79621: IFTRUE 79625
79623: GO 79687
79625: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
79626: LD_ADDR_VAR 0 12
79630: PUSH
79631: LD_VAR 0 18
79635: PPUSH
79636: LD_INT 22
79638: PUSH
79639: LD_VAR 0 16
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: LD_INT 30
79653: PUSH
79654: LD_INT 0
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 30
79663: PUSH
79664: LD_INT 1
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: LIST
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PPUSH
79680: CALL_OW 72
79684: ST_TO_ADDR
79685: GO 79839
79687: LD_INT 3
79689: DOUBLE
79690: EQUAL
79691: IFTRUE 79695
79693: GO 79757
79695: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
79696: LD_ADDR_VAR 0 12
79700: PUSH
79701: LD_VAR 0 18
79705: PPUSH
79706: LD_INT 22
79708: PUSH
79709: LD_VAR 0 16
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 2
79720: PUSH
79721: LD_INT 30
79723: PUSH
79724: LD_INT 2
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 30
79733: PUSH
79734: LD_INT 3
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: LIST
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PPUSH
79750: CALL_OW 72
79754: ST_TO_ADDR
79755: GO 79839
79757: LD_INT 4
79759: DOUBLE
79760: EQUAL
79761: IFTRUE 79765
79763: GO 79838
79765: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
79766: LD_ADDR_VAR 0 12
79770: PUSH
79771: LD_VAR 0 18
79775: PPUSH
79776: LD_INT 22
79778: PUSH
79779: LD_VAR 0 16
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 2
79790: PUSH
79791: LD_INT 30
79793: PUSH
79794: LD_INT 6
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 30
79803: PUSH
79804: LD_INT 7
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 30
79813: PUSH
79814: LD_INT 8
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: LIST
79825: LIST
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PPUSH
79831: CALL_OW 72
79835: ST_TO_ADDR
79836: GO 79839
79838: POP
// if i = 1 then
79839: LD_VAR 0 8
79843: PUSH
79844: LD_INT 1
79846: EQUAL
79847: IFFALSE 79958
// begin tmp := [ ] ;
79849: LD_ADDR_VAR 0 19
79853: PUSH
79854: EMPTY
79855: ST_TO_ADDR
// for j in f do
79856: LD_ADDR_VAR 0 9
79860: PUSH
79861: LD_VAR 0 12
79865: PUSH
79866: FOR_IN
79867: IFFALSE 79940
// if GetBType ( j ) = b_bunker then
79869: LD_VAR 0 9
79873: PPUSH
79874: CALL_OW 266
79878: PUSH
79879: LD_INT 32
79881: EQUAL
79882: IFFALSE 79909
// tmp := Insert ( tmp , 1 , j ) else
79884: LD_ADDR_VAR 0 19
79888: PUSH
79889: LD_VAR 0 19
79893: PPUSH
79894: LD_INT 1
79896: PPUSH
79897: LD_VAR 0 9
79901: PPUSH
79902: CALL_OW 2
79906: ST_TO_ADDR
79907: GO 79938
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79909: LD_ADDR_VAR 0 19
79913: PUSH
79914: LD_VAR 0 19
79918: PPUSH
79919: LD_VAR 0 19
79923: PUSH
79924: LD_INT 1
79926: PLUS
79927: PPUSH
79928: LD_VAR 0 9
79932: PPUSH
79933: CALL_OW 2
79937: ST_TO_ADDR
79938: GO 79866
79940: POP
79941: POP
// if tmp then
79942: LD_VAR 0 19
79946: IFFALSE 79958
// f := tmp ;
79948: LD_ADDR_VAR 0 12
79952: PUSH
79953: LD_VAR 0 19
79957: ST_TO_ADDR
// end ; x := personel [ i ] ;
79958: LD_ADDR_VAR 0 13
79962: PUSH
79963: LD_VAR 0 6
79967: PUSH
79968: LD_VAR 0 8
79972: ARRAY
79973: ST_TO_ADDR
// if x = - 1 then
79974: LD_VAR 0 13
79978: PUSH
79979: LD_INT 1
79981: NEG
79982: EQUAL
79983: IFFALSE 80192
// begin for j in f do
79985: LD_ADDR_VAR 0 9
79989: PUSH
79990: LD_VAR 0 12
79994: PUSH
79995: FOR_IN
79996: IFFALSE 80188
// repeat InitHc ;
79998: CALL_OW 19
// if GetBType ( j ) = b_barracks then
80002: LD_VAR 0 9
80006: PPUSH
80007: CALL_OW 266
80011: PUSH
80012: LD_INT 5
80014: EQUAL
80015: IFFALSE 80085
// begin if UnitsInside ( j ) < 3 then
80017: LD_VAR 0 9
80021: PPUSH
80022: CALL_OW 313
80026: PUSH
80027: LD_INT 3
80029: LESS
80030: IFFALSE 80066
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80032: LD_INT 0
80034: PPUSH
80035: LD_INT 5
80037: PUSH
80038: LD_INT 8
80040: PUSH
80041: LD_INT 9
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: LIST
80048: PUSH
80049: LD_VAR 0 17
80053: ARRAY
80054: PPUSH
80055: LD_VAR 0 4
80059: PPUSH
80060: CALL_OW 380
80064: GO 80083
// PrepareHuman ( false , i , skill ) ;
80066: LD_INT 0
80068: PPUSH
80069: LD_VAR 0 8
80073: PPUSH
80074: LD_VAR 0 4
80078: PPUSH
80079: CALL_OW 380
// end else
80083: GO 80102
// PrepareHuman ( false , i , skill ) ;
80085: LD_INT 0
80087: PPUSH
80088: LD_VAR 0 8
80092: PPUSH
80093: LD_VAR 0 4
80097: PPUSH
80098: CALL_OW 380
// un := CreateHuman ;
80102: LD_ADDR_VAR 0 14
80106: PUSH
80107: CALL_OW 44
80111: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80112: LD_ADDR_VAR 0 7
80116: PUSH
80117: LD_VAR 0 7
80121: PPUSH
80122: LD_INT 1
80124: PPUSH
80125: LD_VAR 0 14
80129: PPUSH
80130: CALL_OW 2
80134: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80135: LD_VAR 0 14
80139: PPUSH
80140: LD_VAR 0 9
80144: PPUSH
80145: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80149: LD_VAR 0 9
80153: PPUSH
80154: CALL_OW 313
80158: PUSH
80159: LD_INT 6
80161: EQUAL
80162: PUSH
80163: LD_VAR 0 9
80167: PPUSH
80168: CALL_OW 266
80172: PUSH
80173: LD_INT 32
80175: PUSH
80176: LD_INT 31
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: IN
80183: OR
80184: IFFALSE 79998
80186: GO 79995
80188: POP
80189: POP
// end else
80190: GO 80572
// for j = 1 to x do
80192: LD_ADDR_VAR 0 9
80196: PUSH
80197: DOUBLE
80198: LD_INT 1
80200: DEC
80201: ST_TO_ADDR
80202: LD_VAR 0 13
80206: PUSH
80207: FOR_TO
80208: IFFALSE 80570
// begin InitHc ;
80210: CALL_OW 19
// if not f then
80214: LD_VAR 0 12
80218: NOT
80219: IFFALSE 80308
// begin PrepareHuman ( false , i , skill ) ;
80221: LD_INT 0
80223: PPUSH
80224: LD_VAR 0 8
80228: PPUSH
80229: LD_VAR 0 4
80233: PPUSH
80234: CALL_OW 380
// un := CreateHuman ;
80238: LD_ADDR_VAR 0 14
80242: PUSH
80243: CALL_OW 44
80247: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80248: LD_ADDR_VAR 0 7
80252: PUSH
80253: LD_VAR 0 7
80257: PPUSH
80258: LD_INT 1
80260: PPUSH
80261: LD_VAR 0 14
80265: PPUSH
80266: CALL_OW 2
80270: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80271: LD_VAR 0 14
80275: PPUSH
80276: LD_VAR 0 1
80280: PPUSH
80281: CALL_OW 250
80285: PPUSH
80286: LD_VAR 0 1
80290: PPUSH
80291: CALL_OW 251
80295: PPUSH
80296: LD_INT 10
80298: PPUSH
80299: LD_INT 0
80301: PPUSH
80302: CALL_OW 50
// continue ;
80306: GO 80207
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80308: LD_VAR 0 12
80312: PUSH
80313: LD_INT 1
80315: ARRAY
80316: PPUSH
80317: CALL_OW 313
80321: PUSH
80322: LD_VAR 0 12
80326: PUSH
80327: LD_INT 1
80329: ARRAY
80330: PPUSH
80331: CALL_OW 266
80335: PUSH
80336: LD_INT 32
80338: PUSH
80339: LD_INT 31
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: IN
80346: AND
80347: PUSH
80348: LD_VAR 0 12
80352: PUSH
80353: LD_INT 1
80355: ARRAY
80356: PPUSH
80357: CALL_OW 313
80361: PUSH
80362: LD_INT 6
80364: EQUAL
80365: OR
80366: IFFALSE 80386
// f := Delete ( f , 1 ) ;
80368: LD_ADDR_VAR 0 12
80372: PUSH
80373: LD_VAR 0 12
80377: PPUSH
80378: LD_INT 1
80380: PPUSH
80381: CALL_OW 3
80385: ST_TO_ADDR
// if not f then
80386: LD_VAR 0 12
80390: NOT
80391: IFFALSE 80409
// begin x := x + 2 ;
80393: LD_ADDR_VAR 0 13
80397: PUSH
80398: LD_VAR 0 13
80402: PUSH
80403: LD_INT 2
80405: PLUS
80406: ST_TO_ADDR
// continue ;
80407: GO 80207
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
80409: LD_VAR 0 12
80413: PUSH
80414: LD_INT 1
80416: ARRAY
80417: PPUSH
80418: CALL_OW 266
80422: PUSH
80423: LD_INT 5
80425: EQUAL
80426: IFFALSE 80500
// begin if UnitsInside ( f [ 1 ] ) < 3 then
80428: LD_VAR 0 12
80432: PUSH
80433: LD_INT 1
80435: ARRAY
80436: PPUSH
80437: CALL_OW 313
80441: PUSH
80442: LD_INT 3
80444: LESS
80445: IFFALSE 80481
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80447: LD_INT 0
80449: PPUSH
80450: LD_INT 5
80452: PUSH
80453: LD_INT 8
80455: PUSH
80456: LD_INT 9
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: LIST
80463: PUSH
80464: LD_VAR 0 17
80468: ARRAY
80469: PPUSH
80470: LD_VAR 0 4
80474: PPUSH
80475: CALL_OW 380
80479: GO 80498
// PrepareHuman ( false , i , skill ) ;
80481: LD_INT 0
80483: PPUSH
80484: LD_VAR 0 8
80488: PPUSH
80489: LD_VAR 0 4
80493: PPUSH
80494: CALL_OW 380
// end else
80498: GO 80517
// PrepareHuman ( false , i , skill ) ;
80500: LD_INT 0
80502: PPUSH
80503: LD_VAR 0 8
80507: PPUSH
80508: LD_VAR 0 4
80512: PPUSH
80513: CALL_OW 380
// un := CreateHuman ;
80517: LD_ADDR_VAR 0 14
80521: PUSH
80522: CALL_OW 44
80526: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80527: LD_ADDR_VAR 0 7
80531: PUSH
80532: LD_VAR 0 7
80536: PPUSH
80537: LD_INT 1
80539: PPUSH
80540: LD_VAR 0 14
80544: PPUSH
80545: CALL_OW 2
80549: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
80550: LD_VAR 0 14
80554: PPUSH
80555: LD_VAR 0 12
80559: PUSH
80560: LD_INT 1
80562: ARRAY
80563: PPUSH
80564: CALL_OW 52
// end ;
80568: GO 80207
80570: POP
80571: POP
// end ;
80572: GO 79509
80574: POP
80575: POP
// result := result ^ buildings ;
80576: LD_ADDR_VAR 0 7
80580: PUSH
80581: LD_VAR 0 7
80585: PUSH
80586: LD_VAR 0 18
80590: ADD
80591: ST_TO_ADDR
// end else
80592: GO 80735
// begin for i = 1 to personel do
80594: LD_ADDR_VAR 0 8
80598: PUSH
80599: DOUBLE
80600: LD_INT 1
80602: DEC
80603: ST_TO_ADDR
80604: LD_VAR 0 6
80608: PUSH
80609: FOR_TO
80610: IFFALSE 80733
// begin if i > 4 then
80612: LD_VAR 0 8
80616: PUSH
80617: LD_INT 4
80619: GREATER
80620: IFFALSE 80624
// break ;
80622: GO 80733
// x := personel [ i ] ;
80624: LD_ADDR_VAR 0 13
80628: PUSH
80629: LD_VAR 0 6
80633: PUSH
80634: LD_VAR 0 8
80638: ARRAY
80639: ST_TO_ADDR
// if x = - 1 then
80640: LD_VAR 0 13
80644: PUSH
80645: LD_INT 1
80647: NEG
80648: EQUAL
80649: IFFALSE 80653
// continue ;
80651: GO 80609
// PrepareHuman ( false , i , skill ) ;
80653: LD_INT 0
80655: PPUSH
80656: LD_VAR 0 8
80660: PPUSH
80661: LD_VAR 0 4
80665: PPUSH
80666: CALL_OW 380
// un := CreateHuman ;
80670: LD_ADDR_VAR 0 14
80674: PUSH
80675: CALL_OW 44
80679: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80680: LD_VAR 0 14
80684: PPUSH
80685: LD_VAR 0 1
80689: PPUSH
80690: CALL_OW 250
80694: PPUSH
80695: LD_VAR 0 1
80699: PPUSH
80700: CALL_OW 251
80704: PPUSH
80705: LD_INT 10
80707: PPUSH
80708: LD_INT 0
80710: PPUSH
80711: CALL_OW 50
// result := result ^ un ;
80715: LD_ADDR_VAR 0 7
80719: PUSH
80720: LD_VAR 0 7
80724: PUSH
80725: LD_VAR 0 14
80729: ADD
80730: ST_TO_ADDR
// end ;
80731: GO 80609
80733: POP
80734: POP
// end ; end ;
80735: LD_VAR 0 7
80739: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
80740: LD_INT 0
80742: PPUSH
80743: PPUSH
80744: PPUSH
80745: PPUSH
80746: PPUSH
80747: PPUSH
80748: PPUSH
80749: PPUSH
80750: PPUSH
80751: PPUSH
80752: PPUSH
80753: PPUSH
80754: PPUSH
80755: PPUSH
80756: PPUSH
80757: PPUSH
// result := false ;
80758: LD_ADDR_VAR 0 3
80762: PUSH
80763: LD_INT 0
80765: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
80766: LD_VAR 0 1
80770: NOT
80771: PUSH
80772: LD_VAR 0 1
80776: PPUSH
80777: CALL_OW 266
80781: PUSH
80782: LD_INT 32
80784: PUSH
80785: LD_INT 33
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: IN
80792: NOT
80793: OR
80794: IFFALSE 80798
// exit ;
80796: GO 81907
// nat := GetNation ( tower ) ;
80798: LD_ADDR_VAR 0 12
80802: PUSH
80803: LD_VAR 0 1
80807: PPUSH
80808: CALL_OW 248
80812: ST_TO_ADDR
// side := GetSide ( tower ) ;
80813: LD_ADDR_VAR 0 16
80817: PUSH
80818: LD_VAR 0 1
80822: PPUSH
80823: CALL_OW 255
80827: ST_TO_ADDR
// x := GetX ( tower ) ;
80828: LD_ADDR_VAR 0 10
80832: PUSH
80833: LD_VAR 0 1
80837: PPUSH
80838: CALL_OW 250
80842: ST_TO_ADDR
// y := GetY ( tower ) ;
80843: LD_ADDR_VAR 0 11
80847: PUSH
80848: LD_VAR 0 1
80852: PPUSH
80853: CALL_OW 251
80857: ST_TO_ADDR
// if not x or not y then
80858: LD_VAR 0 10
80862: NOT
80863: PUSH
80864: LD_VAR 0 11
80868: NOT
80869: OR
80870: IFFALSE 80874
// exit ;
80872: GO 81907
// weapon := 0 ;
80874: LD_ADDR_VAR 0 18
80878: PUSH
80879: LD_INT 0
80881: ST_TO_ADDR
// fac_list := [ ] ;
80882: LD_ADDR_VAR 0 17
80886: PUSH
80887: EMPTY
80888: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80889: LD_ADDR_VAR 0 6
80893: PUSH
80894: LD_VAR 0 1
80898: PPUSH
80899: CALL_OW 274
80903: PPUSH
80904: LD_VAR 0 2
80908: PPUSH
80909: LD_INT 0
80911: PPUSH
80912: CALL 78478 0 3
80916: PPUSH
80917: LD_INT 30
80919: PUSH
80920: LD_INT 3
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PPUSH
80927: CALL_OW 72
80931: ST_TO_ADDR
// if not factories then
80932: LD_VAR 0 6
80936: NOT
80937: IFFALSE 80941
// exit ;
80939: GO 81907
// for i in factories do
80941: LD_ADDR_VAR 0 8
80945: PUSH
80946: LD_VAR 0 6
80950: PUSH
80951: FOR_IN
80952: IFFALSE 80977
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80954: LD_ADDR_VAR 0 17
80958: PUSH
80959: LD_VAR 0 17
80963: PUSH
80964: LD_VAR 0 8
80968: PPUSH
80969: CALL_OW 478
80973: UNION
80974: ST_TO_ADDR
80975: GO 80951
80977: POP
80978: POP
// if not fac_list then
80979: LD_VAR 0 17
80983: NOT
80984: IFFALSE 80988
// exit ;
80986: GO 81907
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80988: LD_ADDR_VAR 0 5
80992: PUSH
80993: LD_INT 4
80995: PUSH
80996: LD_INT 5
80998: PUSH
80999: LD_INT 9
81001: PUSH
81002: LD_INT 10
81004: PUSH
81005: LD_INT 6
81007: PUSH
81008: LD_INT 7
81010: PUSH
81011: LD_INT 11
81013: PUSH
81014: EMPTY
81015: LIST
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 27
81025: PUSH
81026: LD_INT 28
81028: PUSH
81029: LD_INT 26
81031: PUSH
81032: LD_INT 30
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: PUSH
81041: LD_INT 43
81043: PUSH
81044: LD_INT 44
81046: PUSH
81047: LD_INT 46
81049: PUSH
81050: LD_INT 45
81052: PUSH
81053: LD_INT 47
81055: PUSH
81056: LD_INT 49
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: LIST
81071: PUSH
81072: LD_VAR 0 12
81076: ARRAY
81077: ST_TO_ADDR
// list := list isect fac_list ;
81078: LD_ADDR_VAR 0 5
81082: PUSH
81083: LD_VAR 0 5
81087: PUSH
81088: LD_VAR 0 17
81092: ISECT
81093: ST_TO_ADDR
// if not list then
81094: LD_VAR 0 5
81098: NOT
81099: IFFALSE 81103
// exit ;
81101: GO 81907
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81103: LD_VAR 0 12
81107: PUSH
81108: LD_INT 3
81110: EQUAL
81111: PUSH
81112: LD_INT 49
81114: PUSH
81115: LD_VAR 0 5
81119: IN
81120: AND
81121: PUSH
81122: LD_INT 31
81124: PPUSH
81125: LD_VAR 0 16
81129: PPUSH
81130: CALL_OW 321
81134: PUSH
81135: LD_INT 2
81137: EQUAL
81138: AND
81139: IFFALSE 81199
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81141: LD_INT 22
81143: PUSH
81144: LD_VAR 0 16
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 35
81155: PUSH
81156: LD_INT 49
81158: PUSH
81159: EMPTY
81160: LIST
81161: LIST
81162: PUSH
81163: LD_INT 91
81165: PUSH
81166: LD_VAR 0 1
81170: PUSH
81171: LD_INT 10
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: LIST
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: LIST
81183: PPUSH
81184: CALL_OW 69
81188: NOT
81189: IFFALSE 81199
// weapon := ru_time_lapser ;
81191: LD_ADDR_VAR 0 18
81195: PUSH
81196: LD_INT 49
81198: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81199: LD_VAR 0 12
81203: PUSH
81204: LD_INT 1
81206: PUSH
81207: LD_INT 2
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: IN
81214: PUSH
81215: LD_INT 11
81217: PUSH
81218: LD_VAR 0 5
81222: IN
81223: PUSH
81224: LD_INT 30
81226: PUSH
81227: LD_VAR 0 5
81231: IN
81232: OR
81233: AND
81234: PUSH
81235: LD_INT 6
81237: PPUSH
81238: LD_VAR 0 16
81242: PPUSH
81243: CALL_OW 321
81247: PUSH
81248: LD_INT 2
81250: EQUAL
81251: AND
81252: IFFALSE 81417
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81254: LD_INT 22
81256: PUSH
81257: LD_VAR 0 16
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: PUSH
81269: LD_INT 35
81271: PUSH
81272: LD_INT 11
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 35
81281: PUSH
81282: LD_INT 30
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 91
81296: PUSH
81297: LD_VAR 0 1
81301: PUSH
81302: LD_INT 18
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: LIST
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: LIST
81314: PPUSH
81315: CALL_OW 69
81319: NOT
81320: PUSH
81321: LD_INT 22
81323: PUSH
81324: LD_VAR 0 16
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 2
81335: PUSH
81336: LD_INT 30
81338: PUSH
81339: LD_INT 32
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: LD_INT 30
81348: PUSH
81349: LD_INT 33
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 91
81363: PUSH
81364: LD_VAR 0 1
81368: PUSH
81369: LD_INT 12
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: LIST
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: LIST
81381: PUSH
81382: EMPTY
81383: LIST
81384: PPUSH
81385: CALL_OW 69
81389: PUSH
81390: LD_INT 2
81392: GREATER
81393: AND
81394: IFFALSE 81417
// weapon := [ us_radar , ar_radar ] [ nat ] ;
81396: LD_ADDR_VAR 0 18
81400: PUSH
81401: LD_INT 11
81403: PUSH
81404: LD_INT 30
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_VAR 0 12
81415: ARRAY
81416: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
81417: LD_VAR 0 18
81421: NOT
81422: PUSH
81423: LD_INT 40
81425: PPUSH
81426: LD_VAR 0 16
81430: PPUSH
81431: CALL_OW 321
81435: PUSH
81436: LD_INT 2
81438: EQUAL
81439: AND
81440: PUSH
81441: LD_INT 7
81443: PUSH
81444: LD_VAR 0 5
81448: IN
81449: PUSH
81450: LD_INT 28
81452: PUSH
81453: LD_VAR 0 5
81457: IN
81458: OR
81459: PUSH
81460: LD_INT 45
81462: PUSH
81463: LD_VAR 0 5
81467: IN
81468: OR
81469: AND
81470: IFFALSE 81724
// begin hex := GetHexInfo ( x , y ) ;
81472: LD_ADDR_VAR 0 4
81476: PUSH
81477: LD_VAR 0 10
81481: PPUSH
81482: LD_VAR 0 11
81486: PPUSH
81487: CALL_OW 546
81491: ST_TO_ADDR
// if hex [ 1 ] then
81492: LD_VAR 0 4
81496: PUSH
81497: LD_INT 1
81499: ARRAY
81500: IFFALSE 81504
// exit ;
81502: GO 81907
// height := hex [ 2 ] ;
81504: LD_ADDR_VAR 0 15
81508: PUSH
81509: LD_VAR 0 4
81513: PUSH
81514: LD_INT 2
81516: ARRAY
81517: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
81518: LD_ADDR_VAR 0 14
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: LD_INT 2
81528: PUSH
81529: LD_INT 3
81531: PUSH
81532: LD_INT 5
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: ST_TO_ADDR
// for i in tmp do
81541: LD_ADDR_VAR 0 8
81545: PUSH
81546: LD_VAR 0 14
81550: PUSH
81551: FOR_IN
81552: IFFALSE 81722
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
81554: LD_ADDR_VAR 0 9
81558: PUSH
81559: LD_VAR 0 10
81563: PPUSH
81564: LD_VAR 0 8
81568: PPUSH
81569: LD_INT 5
81571: PPUSH
81572: CALL_OW 272
81576: PUSH
81577: LD_VAR 0 11
81581: PPUSH
81582: LD_VAR 0 8
81586: PPUSH
81587: LD_INT 5
81589: PPUSH
81590: CALL_OW 273
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81599: LD_VAR 0 9
81603: PUSH
81604: LD_INT 1
81606: ARRAY
81607: PPUSH
81608: LD_VAR 0 9
81612: PUSH
81613: LD_INT 2
81615: ARRAY
81616: PPUSH
81617: CALL_OW 488
81621: IFFALSE 81720
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
81623: LD_ADDR_VAR 0 4
81627: PUSH
81628: LD_VAR 0 9
81632: PUSH
81633: LD_INT 1
81635: ARRAY
81636: PPUSH
81637: LD_VAR 0 9
81641: PUSH
81642: LD_INT 2
81644: ARRAY
81645: PPUSH
81646: CALL_OW 546
81650: ST_TO_ADDR
// if hex [ 1 ] then
81651: LD_VAR 0 4
81655: PUSH
81656: LD_INT 1
81658: ARRAY
81659: IFFALSE 81663
// continue ;
81661: GO 81551
// h := hex [ 2 ] ;
81663: LD_ADDR_VAR 0 13
81667: PUSH
81668: LD_VAR 0 4
81672: PUSH
81673: LD_INT 2
81675: ARRAY
81676: ST_TO_ADDR
// if h + 7 < height then
81677: LD_VAR 0 13
81681: PUSH
81682: LD_INT 7
81684: PLUS
81685: PUSH
81686: LD_VAR 0 15
81690: LESS
81691: IFFALSE 81720
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
81693: LD_ADDR_VAR 0 18
81697: PUSH
81698: LD_INT 7
81700: PUSH
81701: LD_INT 28
81703: PUSH
81704: LD_INT 45
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: LIST
81711: PUSH
81712: LD_VAR 0 12
81716: ARRAY
81717: ST_TO_ADDR
// break ;
81718: GO 81722
// end ; end ; end ;
81720: GO 81551
81722: POP
81723: POP
// end ; if not weapon then
81724: LD_VAR 0 18
81728: NOT
81729: IFFALSE 81789
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
81731: LD_ADDR_VAR 0 5
81735: PUSH
81736: LD_VAR 0 5
81740: PUSH
81741: LD_INT 11
81743: PUSH
81744: LD_INT 30
81746: PUSH
81747: LD_INT 49
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: LIST
81754: DIFF
81755: ST_TO_ADDR
// if not list then
81756: LD_VAR 0 5
81760: NOT
81761: IFFALSE 81765
// exit ;
81763: GO 81907
// weapon := list [ rand ( 1 , list ) ] ;
81765: LD_ADDR_VAR 0 18
81769: PUSH
81770: LD_VAR 0 5
81774: PUSH
81775: LD_INT 1
81777: PPUSH
81778: LD_VAR 0 5
81782: PPUSH
81783: CALL_OW 12
81787: ARRAY
81788: ST_TO_ADDR
// end ; if weapon then
81789: LD_VAR 0 18
81793: IFFALSE 81907
// begin tmp := CostOfWeapon ( weapon ) ;
81795: LD_ADDR_VAR 0 14
81799: PUSH
81800: LD_VAR 0 18
81804: PPUSH
81805: CALL_OW 451
81809: ST_TO_ADDR
// j := GetBase ( tower ) ;
81810: LD_ADDR_VAR 0 9
81814: PUSH
81815: LD_VAR 0 1
81819: PPUSH
81820: CALL_OW 274
81824: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
81825: LD_VAR 0 9
81829: PPUSH
81830: LD_INT 1
81832: PPUSH
81833: CALL_OW 275
81837: PUSH
81838: LD_VAR 0 14
81842: PUSH
81843: LD_INT 1
81845: ARRAY
81846: GREATEREQUAL
81847: PUSH
81848: LD_VAR 0 9
81852: PPUSH
81853: LD_INT 2
81855: PPUSH
81856: CALL_OW 275
81860: PUSH
81861: LD_VAR 0 14
81865: PUSH
81866: LD_INT 2
81868: ARRAY
81869: GREATEREQUAL
81870: AND
81871: PUSH
81872: LD_VAR 0 9
81876: PPUSH
81877: LD_INT 3
81879: PPUSH
81880: CALL_OW 275
81884: PUSH
81885: LD_VAR 0 14
81889: PUSH
81890: LD_INT 3
81892: ARRAY
81893: GREATEREQUAL
81894: AND
81895: IFFALSE 81907
// result := weapon ;
81897: LD_ADDR_VAR 0 3
81901: PUSH
81902: LD_VAR 0 18
81906: ST_TO_ADDR
// end ; end ;
81907: LD_VAR 0 3
81911: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81912: LD_INT 0
81914: PPUSH
81915: PPUSH
// result := true ;
81916: LD_ADDR_VAR 0 3
81920: PUSH
81921: LD_INT 1
81923: ST_TO_ADDR
// if array1 = array2 then
81924: LD_VAR 0 1
81928: PUSH
81929: LD_VAR 0 2
81933: EQUAL
81934: IFFALSE 81994
// begin for i = 1 to array1 do
81936: LD_ADDR_VAR 0 4
81940: PUSH
81941: DOUBLE
81942: LD_INT 1
81944: DEC
81945: ST_TO_ADDR
81946: LD_VAR 0 1
81950: PUSH
81951: FOR_TO
81952: IFFALSE 81990
// if array1 [ i ] <> array2 [ i ] then
81954: LD_VAR 0 1
81958: PUSH
81959: LD_VAR 0 4
81963: ARRAY
81964: PUSH
81965: LD_VAR 0 2
81969: PUSH
81970: LD_VAR 0 4
81974: ARRAY
81975: NONEQUAL
81976: IFFALSE 81988
// begin result := false ;
81978: LD_ADDR_VAR 0 3
81982: PUSH
81983: LD_INT 0
81985: ST_TO_ADDR
// break ;
81986: GO 81990
// end ;
81988: GO 81951
81990: POP
81991: POP
// end else
81992: GO 82002
// result := false ;
81994: LD_ADDR_VAR 0 3
81998: PUSH
81999: LD_INT 0
82001: ST_TO_ADDR
// end ;
82002: LD_VAR 0 3
82006: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
82007: LD_INT 0
82009: PPUSH
82010: PPUSH
// if not array1 or not array2 then
82011: LD_VAR 0 1
82015: NOT
82016: PUSH
82017: LD_VAR 0 2
82021: NOT
82022: OR
82023: IFFALSE 82027
// exit ;
82025: GO 82091
// result := true ;
82027: LD_ADDR_VAR 0 3
82031: PUSH
82032: LD_INT 1
82034: ST_TO_ADDR
// for i = 1 to array1 do
82035: LD_ADDR_VAR 0 4
82039: PUSH
82040: DOUBLE
82041: LD_INT 1
82043: DEC
82044: ST_TO_ADDR
82045: LD_VAR 0 1
82049: PUSH
82050: FOR_TO
82051: IFFALSE 82089
// if array1 [ i ] <> array2 [ i ] then
82053: LD_VAR 0 1
82057: PUSH
82058: LD_VAR 0 4
82062: ARRAY
82063: PUSH
82064: LD_VAR 0 2
82068: PUSH
82069: LD_VAR 0 4
82073: ARRAY
82074: NONEQUAL
82075: IFFALSE 82087
// begin result := false ;
82077: LD_ADDR_VAR 0 3
82081: PUSH
82082: LD_INT 0
82084: ST_TO_ADDR
// break ;
82085: GO 82089
// end ;
82087: GO 82050
82089: POP
82090: POP
// end ;
82091: LD_VAR 0 3
82095: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
82096: LD_INT 0
82098: PPUSH
82099: PPUSH
82100: PPUSH
// pom := GetBase ( fac ) ;
82101: LD_ADDR_VAR 0 5
82105: PUSH
82106: LD_VAR 0 1
82110: PPUSH
82111: CALL_OW 274
82115: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82116: LD_ADDR_VAR 0 4
82120: PUSH
82121: LD_VAR 0 2
82125: PUSH
82126: LD_INT 1
82128: ARRAY
82129: PPUSH
82130: LD_VAR 0 2
82134: PUSH
82135: LD_INT 2
82137: ARRAY
82138: PPUSH
82139: LD_VAR 0 2
82143: PUSH
82144: LD_INT 3
82146: ARRAY
82147: PPUSH
82148: LD_VAR 0 2
82152: PUSH
82153: LD_INT 4
82155: ARRAY
82156: PPUSH
82157: CALL_OW 449
82161: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82162: LD_ADDR_VAR 0 3
82166: PUSH
82167: LD_VAR 0 5
82171: PPUSH
82172: LD_INT 1
82174: PPUSH
82175: CALL_OW 275
82179: PUSH
82180: LD_VAR 0 4
82184: PUSH
82185: LD_INT 1
82187: ARRAY
82188: GREATEREQUAL
82189: PUSH
82190: LD_VAR 0 5
82194: PPUSH
82195: LD_INT 2
82197: PPUSH
82198: CALL_OW 275
82202: PUSH
82203: LD_VAR 0 4
82207: PUSH
82208: LD_INT 2
82210: ARRAY
82211: GREATEREQUAL
82212: AND
82213: PUSH
82214: LD_VAR 0 5
82218: PPUSH
82219: LD_INT 3
82221: PPUSH
82222: CALL_OW 275
82226: PUSH
82227: LD_VAR 0 4
82231: PUSH
82232: LD_INT 3
82234: ARRAY
82235: GREATEREQUAL
82236: AND
82237: ST_TO_ADDR
// end ;
82238: LD_VAR 0 3
82242: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82243: LD_INT 0
82245: PPUSH
82246: PPUSH
82247: PPUSH
82248: PPUSH
// pom := GetBase ( building ) ;
82249: LD_ADDR_VAR 0 3
82253: PUSH
82254: LD_VAR 0 1
82258: PPUSH
82259: CALL_OW 274
82263: ST_TO_ADDR
// if not pom then
82264: LD_VAR 0 3
82268: NOT
82269: IFFALSE 82273
// exit ;
82271: GO 82443
// btype := GetBType ( building ) ;
82273: LD_ADDR_VAR 0 5
82277: PUSH
82278: LD_VAR 0 1
82282: PPUSH
82283: CALL_OW 266
82287: ST_TO_ADDR
// if btype = b_armoury then
82288: LD_VAR 0 5
82292: PUSH
82293: LD_INT 4
82295: EQUAL
82296: IFFALSE 82306
// btype := b_barracks ;
82298: LD_ADDR_VAR 0 5
82302: PUSH
82303: LD_INT 5
82305: ST_TO_ADDR
// if btype = b_depot then
82306: LD_VAR 0 5
82310: PUSH
82311: LD_INT 0
82313: EQUAL
82314: IFFALSE 82324
// btype := b_warehouse ;
82316: LD_ADDR_VAR 0 5
82320: PUSH
82321: LD_INT 1
82323: ST_TO_ADDR
// if btype = b_workshop then
82324: LD_VAR 0 5
82328: PUSH
82329: LD_INT 2
82331: EQUAL
82332: IFFALSE 82342
// btype := b_factory ;
82334: LD_ADDR_VAR 0 5
82338: PUSH
82339: LD_INT 3
82341: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82342: LD_ADDR_VAR 0 4
82346: PUSH
82347: LD_VAR 0 5
82351: PPUSH
82352: LD_VAR 0 1
82356: PPUSH
82357: CALL_OW 248
82361: PPUSH
82362: CALL_OW 450
82366: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82367: LD_ADDR_VAR 0 2
82371: PUSH
82372: LD_VAR 0 3
82376: PPUSH
82377: LD_INT 1
82379: PPUSH
82380: CALL_OW 275
82384: PUSH
82385: LD_VAR 0 4
82389: PUSH
82390: LD_INT 1
82392: ARRAY
82393: GREATEREQUAL
82394: PUSH
82395: LD_VAR 0 3
82399: PPUSH
82400: LD_INT 2
82402: PPUSH
82403: CALL_OW 275
82407: PUSH
82408: LD_VAR 0 4
82412: PUSH
82413: LD_INT 2
82415: ARRAY
82416: GREATEREQUAL
82417: AND
82418: PUSH
82419: LD_VAR 0 3
82423: PPUSH
82424: LD_INT 3
82426: PPUSH
82427: CALL_OW 275
82431: PUSH
82432: LD_VAR 0 4
82436: PUSH
82437: LD_INT 3
82439: ARRAY
82440: GREATEREQUAL
82441: AND
82442: ST_TO_ADDR
// end ;
82443: LD_VAR 0 2
82447: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
82448: LD_INT 0
82450: PPUSH
82451: PPUSH
82452: PPUSH
// pom := GetBase ( building ) ;
82453: LD_ADDR_VAR 0 4
82457: PUSH
82458: LD_VAR 0 1
82462: PPUSH
82463: CALL_OW 274
82467: ST_TO_ADDR
// if not pom then
82468: LD_VAR 0 4
82472: NOT
82473: IFFALSE 82477
// exit ;
82475: GO 82578
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
82477: LD_ADDR_VAR 0 5
82481: PUSH
82482: LD_VAR 0 2
82486: PPUSH
82487: LD_VAR 0 1
82491: PPUSH
82492: CALL_OW 248
82496: PPUSH
82497: CALL_OW 450
82501: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82502: LD_ADDR_VAR 0 3
82506: PUSH
82507: LD_VAR 0 4
82511: PPUSH
82512: LD_INT 1
82514: PPUSH
82515: CALL_OW 275
82519: PUSH
82520: LD_VAR 0 5
82524: PUSH
82525: LD_INT 1
82527: ARRAY
82528: GREATEREQUAL
82529: PUSH
82530: LD_VAR 0 4
82534: PPUSH
82535: LD_INT 2
82537: PPUSH
82538: CALL_OW 275
82542: PUSH
82543: LD_VAR 0 5
82547: PUSH
82548: LD_INT 2
82550: ARRAY
82551: GREATEREQUAL
82552: AND
82553: PUSH
82554: LD_VAR 0 4
82558: PPUSH
82559: LD_INT 3
82561: PPUSH
82562: CALL_OW 275
82566: PUSH
82567: LD_VAR 0 5
82571: PUSH
82572: LD_INT 3
82574: ARRAY
82575: GREATEREQUAL
82576: AND
82577: ST_TO_ADDR
// end ;
82578: LD_VAR 0 3
82582: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
82583: LD_INT 0
82585: PPUSH
82586: PPUSH
82587: PPUSH
82588: PPUSH
82589: PPUSH
82590: PPUSH
82591: PPUSH
82592: PPUSH
82593: PPUSH
82594: PPUSH
82595: PPUSH
// result := false ;
82596: LD_ADDR_VAR 0 8
82600: PUSH
82601: LD_INT 0
82603: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
82604: LD_VAR 0 5
82608: NOT
82609: PUSH
82610: LD_VAR 0 1
82614: NOT
82615: OR
82616: PUSH
82617: LD_VAR 0 2
82621: NOT
82622: OR
82623: PUSH
82624: LD_VAR 0 3
82628: NOT
82629: OR
82630: IFFALSE 82634
// exit ;
82632: GO 83448
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
82634: LD_ADDR_VAR 0 14
82638: PUSH
82639: LD_VAR 0 1
82643: PPUSH
82644: LD_VAR 0 2
82648: PPUSH
82649: LD_VAR 0 3
82653: PPUSH
82654: LD_VAR 0 4
82658: PPUSH
82659: LD_VAR 0 5
82663: PUSH
82664: LD_INT 1
82666: ARRAY
82667: PPUSH
82668: CALL_OW 248
82672: PPUSH
82673: LD_INT 0
82675: PPUSH
82676: CALL 84701 0 6
82680: ST_TO_ADDR
// if not hexes then
82681: LD_VAR 0 14
82685: NOT
82686: IFFALSE 82690
// exit ;
82688: GO 83448
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
82690: LD_ADDR_VAR 0 17
82694: PUSH
82695: LD_VAR 0 5
82699: PPUSH
82700: LD_INT 22
82702: PUSH
82703: LD_VAR 0 13
82707: PPUSH
82708: CALL_OW 255
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 2
82719: PUSH
82720: LD_INT 30
82722: PUSH
82723: LD_INT 0
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 30
82732: PUSH
82733: LD_INT 1
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: LIST
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PPUSH
82749: CALL_OW 72
82753: ST_TO_ADDR
// for i = 1 to hexes do
82754: LD_ADDR_VAR 0 9
82758: PUSH
82759: DOUBLE
82760: LD_INT 1
82762: DEC
82763: ST_TO_ADDR
82764: LD_VAR 0 14
82768: PUSH
82769: FOR_TO
82770: IFFALSE 83446
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82772: LD_ADDR_VAR 0 13
82776: PUSH
82777: LD_VAR 0 14
82781: PUSH
82782: LD_VAR 0 9
82786: ARRAY
82787: PUSH
82788: LD_INT 1
82790: ARRAY
82791: PPUSH
82792: LD_VAR 0 14
82796: PUSH
82797: LD_VAR 0 9
82801: ARRAY
82802: PUSH
82803: LD_INT 2
82805: ARRAY
82806: PPUSH
82807: CALL_OW 428
82811: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
82812: LD_VAR 0 14
82816: PUSH
82817: LD_VAR 0 9
82821: ARRAY
82822: PUSH
82823: LD_INT 1
82825: ARRAY
82826: PPUSH
82827: LD_VAR 0 14
82831: PUSH
82832: LD_VAR 0 9
82836: ARRAY
82837: PUSH
82838: LD_INT 2
82840: ARRAY
82841: PPUSH
82842: CALL_OW 351
82846: PUSH
82847: LD_VAR 0 14
82851: PUSH
82852: LD_VAR 0 9
82856: ARRAY
82857: PUSH
82858: LD_INT 1
82860: ARRAY
82861: PPUSH
82862: LD_VAR 0 14
82866: PUSH
82867: LD_VAR 0 9
82871: ARRAY
82872: PUSH
82873: LD_INT 2
82875: ARRAY
82876: PPUSH
82877: CALL_OW 488
82881: NOT
82882: OR
82883: PUSH
82884: LD_VAR 0 13
82888: PPUSH
82889: CALL_OW 247
82893: PUSH
82894: LD_INT 3
82896: EQUAL
82897: OR
82898: IFFALSE 82904
// exit ;
82900: POP
82901: POP
82902: GO 83448
// if not tmp then
82904: LD_VAR 0 13
82908: NOT
82909: IFFALSE 82913
// continue ;
82911: GO 82769
// result := true ;
82913: LD_ADDR_VAR 0 8
82917: PUSH
82918: LD_INT 1
82920: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82921: LD_VAR 0 6
82925: PUSH
82926: LD_VAR 0 13
82930: PPUSH
82931: CALL_OW 247
82935: PUSH
82936: LD_INT 2
82938: EQUAL
82939: AND
82940: PUSH
82941: LD_VAR 0 13
82945: PPUSH
82946: CALL_OW 263
82950: PUSH
82951: LD_INT 1
82953: EQUAL
82954: AND
82955: IFFALSE 83119
// begin if IsDrivenBy ( tmp ) then
82957: LD_VAR 0 13
82961: PPUSH
82962: CALL_OW 311
82966: IFFALSE 82970
// continue ;
82968: GO 82769
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82970: LD_VAR 0 6
82974: PPUSH
82975: LD_INT 3
82977: PUSH
82978: LD_INT 60
82980: PUSH
82981: EMPTY
82982: LIST
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 3
82990: PUSH
82991: LD_INT 55
82993: PUSH
82994: EMPTY
82995: LIST
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PPUSH
83005: CALL_OW 72
83009: IFFALSE 83117
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
83011: LD_ADDR_VAR 0 18
83015: PUSH
83016: LD_VAR 0 6
83020: PPUSH
83021: LD_INT 3
83023: PUSH
83024: LD_INT 60
83026: PUSH
83027: EMPTY
83028: LIST
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 3
83036: PUSH
83037: LD_INT 55
83039: PUSH
83040: EMPTY
83041: LIST
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PPUSH
83051: CALL_OW 72
83055: PUSH
83056: LD_INT 1
83058: ARRAY
83059: ST_TO_ADDR
// if IsInUnit ( driver ) then
83060: LD_VAR 0 18
83064: PPUSH
83065: CALL_OW 310
83069: IFFALSE 83080
// ComExit ( driver ) ;
83071: LD_VAR 0 18
83075: PPUSH
83076: CALL 108502 0 1
// AddComEnterUnit ( driver , tmp ) ;
83080: LD_VAR 0 18
83084: PPUSH
83085: LD_VAR 0 13
83089: PPUSH
83090: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
83094: LD_VAR 0 18
83098: PPUSH
83099: LD_VAR 0 7
83103: PPUSH
83104: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83108: LD_VAR 0 18
83112: PPUSH
83113: CALL_OW 181
// end ; continue ;
83117: GO 82769
// end ; if not cleaners or not tmp in cleaners then
83119: LD_VAR 0 6
83123: NOT
83124: PUSH
83125: LD_VAR 0 13
83129: PUSH
83130: LD_VAR 0 6
83134: IN
83135: NOT
83136: OR
83137: IFFALSE 83444
// begin if dep then
83139: LD_VAR 0 17
83143: IFFALSE 83279
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83145: LD_ADDR_VAR 0 16
83149: PUSH
83150: LD_VAR 0 17
83154: PUSH
83155: LD_INT 1
83157: ARRAY
83158: PPUSH
83159: CALL_OW 250
83163: PPUSH
83164: LD_VAR 0 17
83168: PUSH
83169: LD_INT 1
83171: ARRAY
83172: PPUSH
83173: CALL_OW 254
83177: PPUSH
83178: LD_INT 5
83180: PPUSH
83181: CALL_OW 272
83185: PUSH
83186: LD_VAR 0 17
83190: PUSH
83191: LD_INT 1
83193: ARRAY
83194: PPUSH
83195: CALL_OW 251
83199: PPUSH
83200: LD_VAR 0 17
83204: PUSH
83205: LD_INT 1
83207: ARRAY
83208: PPUSH
83209: CALL_OW 254
83213: PPUSH
83214: LD_INT 5
83216: PPUSH
83217: CALL_OW 273
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83226: LD_VAR 0 16
83230: PUSH
83231: LD_INT 1
83233: ARRAY
83234: PPUSH
83235: LD_VAR 0 16
83239: PUSH
83240: LD_INT 2
83242: ARRAY
83243: PPUSH
83244: CALL_OW 488
83248: IFFALSE 83279
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83250: LD_VAR 0 13
83254: PPUSH
83255: LD_VAR 0 16
83259: PUSH
83260: LD_INT 1
83262: ARRAY
83263: PPUSH
83264: LD_VAR 0 16
83268: PUSH
83269: LD_INT 2
83271: ARRAY
83272: PPUSH
83273: CALL_OW 111
// continue ;
83277: GO 82769
// end ; end ; r := GetDir ( tmp ) ;
83279: LD_ADDR_VAR 0 15
83283: PUSH
83284: LD_VAR 0 13
83288: PPUSH
83289: CALL_OW 254
83293: ST_TO_ADDR
// if r = 5 then
83294: LD_VAR 0 15
83298: PUSH
83299: LD_INT 5
83301: EQUAL
83302: IFFALSE 83312
// r := 0 ;
83304: LD_ADDR_VAR 0 15
83308: PUSH
83309: LD_INT 0
83311: ST_TO_ADDR
// for j = r to 5 do
83312: LD_ADDR_VAR 0 10
83316: PUSH
83317: DOUBLE
83318: LD_VAR 0 15
83322: DEC
83323: ST_TO_ADDR
83324: LD_INT 5
83326: PUSH
83327: FOR_TO
83328: IFFALSE 83442
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
83330: LD_ADDR_VAR 0 11
83334: PUSH
83335: LD_VAR 0 13
83339: PPUSH
83340: CALL_OW 250
83344: PPUSH
83345: LD_VAR 0 10
83349: PPUSH
83350: LD_INT 2
83352: PPUSH
83353: CALL_OW 272
83357: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
83358: LD_ADDR_VAR 0 12
83362: PUSH
83363: LD_VAR 0 13
83367: PPUSH
83368: CALL_OW 251
83372: PPUSH
83373: LD_VAR 0 10
83377: PPUSH
83378: LD_INT 2
83380: PPUSH
83381: CALL_OW 273
83385: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
83386: LD_VAR 0 11
83390: PPUSH
83391: LD_VAR 0 12
83395: PPUSH
83396: CALL_OW 488
83400: PUSH
83401: LD_VAR 0 11
83405: PPUSH
83406: LD_VAR 0 12
83410: PPUSH
83411: CALL_OW 428
83415: NOT
83416: AND
83417: IFFALSE 83440
// begin ComMoveXY ( tmp , _x , _y ) ;
83419: LD_VAR 0 13
83423: PPUSH
83424: LD_VAR 0 11
83428: PPUSH
83429: LD_VAR 0 12
83433: PPUSH
83434: CALL_OW 111
// break ;
83438: GO 83442
// end ; end ;
83440: GO 83327
83442: POP
83443: POP
// end ; end ;
83444: GO 82769
83446: POP
83447: POP
// end ;
83448: LD_VAR 0 8
83452: RET
// export function BuildingTechInvented ( side , btype ) ; begin
83453: LD_INT 0
83455: PPUSH
// result := true ;
83456: LD_ADDR_VAR 0 3
83460: PUSH
83461: LD_INT 1
83463: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
83464: LD_VAR 0 2
83468: PUSH
83469: LD_INT 24
83471: DOUBLE
83472: EQUAL
83473: IFTRUE 83483
83475: LD_INT 33
83477: DOUBLE
83478: EQUAL
83479: IFTRUE 83483
83481: GO 83508
83483: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
83484: LD_ADDR_VAR 0 3
83488: PUSH
83489: LD_INT 32
83491: PPUSH
83492: LD_VAR 0 1
83496: PPUSH
83497: CALL_OW 321
83501: PUSH
83502: LD_INT 2
83504: EQUAL
83505: ST_TO_ADDR
83506: GO 83824
83508: LD_INT 20
83510: DOUBLE
83511: EQUAL
83512: IFTRUE 83516
83514: GO 83541
83516: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
83517: LD_ADDR_VAR 0 3
83521: PUSH
83522: LD_INT 6
83524: PPUSH
83525: LD_VAR 0 1
83529: PPUSH
83530: CALL_OW 321
83534: PUSH
83535: LD_INT 2
83537: EQUAL
83538: ST_TO_ADDR
83539: GO 83824
83541: LD_INT 22
83543: DOUBLE
83544: EQUAL
83545: IFTRUE 83555
83547: LD_INT 36
83549: DOUBLE
83550: EQUAL
83551: IFTRUE 83555
83553: GO 83580
83555: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
83556: LD_ADDR_VAR 0 3
83560: PUSH
83561: LD_INT 15
83563: PPUSH
83564: LD_VAR 0 1
83568: PPUSH
83569: CALL_OW 321
83573: PUSH
83574: LD_INT 2
83576: EQUAL
83577: ST_TO_ADDR
83578: GO 83824
83580: LD_INT 30
83582: DOUBLE
83583: EQUAL
83584: IFTRUE 83588
83586: GO 83613
83588: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
83589: LD_ADDR_VAR 0 3
83593: PUSH
83594: LD_INT 20
83596: PPUSH
83597: LD_VAR 0 1
83601: PPUSH
83602: CALL_OW 321
83606: PUSH
83607: LD_INT 2
83609: EQUAL
83610: ST_TO_ADDR
83611: GO 83824
83613: LD_INT 28
83615: DOUBLE
83616: EQUAL
83617: IFTRUE 83627
83619: LD_INT 21
83621: DOUBLE
83622: EQUAL
83623: IFTRUE 83627
83625: GO 83652
83627: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
83628: LD_ADDR_VAR 0 3
83632: PUSH
83633: LD_INT 21
83635: PPUSH
83636: LD_VAR 0 1
83640: PPUSH
83641: CALL_OW 321
83645: PUSH
83646: LD_INT 2
83648: EQUAL
83649: ST_TO_ADDR
83650: GO 83824
83652: LD_INT 16
83654: DOUBLE
83655: EQUAL
83656: IFTRUE 83660
83658: GO 83685
83660: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
83661: LD_ADDR_VAR 0 3
83665: PUSH
83666: LD_INT 84
83668: PPUSH
83669: LD_VAR 0 1
83673: PPUSH
83674: CALL_OW 321
83678: PUSH
83679: LD_INT 2
83681: EQUAL
83682: ST_TO_ADDR
83683: GO 83824
83685: LD_INT 19
83687: DOUBLE
83688: EQUAL
83689: IFTRUE 83699
83691: LD_INT 23
83693: DOUBLE
83694: EQUAL
83695: IFTRUE 83699
83697: GO 83724
83699: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
83700: LD_ADDR_VAR 0 3
83704: PUSH
83705: LD_INT 83
83707: PPUSH
83708: LD_VAR 0 1
83712: PPUSH
83713: CALL_OW 321
83717: PUSH
83718: LD_INT 2
83720: EQUAL
83721: ST_TO_ADDR
83722: GO 83824
83724: LD_INT 17
83726: DOUBLE
83727: EQUAL
83728: IFTRUE 83732
83730: GO 83757
83732: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
83733: LD_ADDR_VAR 0 3
83737: PUSH
83738: LD_INT 39
83740: PPUSH
83741: LD_VAR 0 1
83745: PPUSH
83746: CALL_OW 321
83750: PUSH
83751: LD_INT 2
83753: EQUAL
83754: ST_TO_ADDR
83755: GO 83824
83757: LD_INT 18
83759: DOUBLE
83760: EQUAL
83761: IFTRUE 83765
83763: GO 83790
83765: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
83766: LD_ADDR_VAR 0 3
83770: PUSH
83771: LD_INT 40
83773: PPUSH
83774: LD_VAR 0 1
83778: PPUSH
83779: CALL_OW 321
83783: PUSH
83784: LD_INT 2
83786: EQUAL
83787: ST_TO_ADDR
83788: GO 83824
83790: LD_INT 27
83792: DOUBLE
83793: EQUAL
83794: IFTRUE 83798
83796: GO 83823
83798: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
83799: LD_ADDR_VAR 0 3
83803: PUSH
83804: LD_INT 35
83806: PPUSH
83807: LD_VAR 0 1
83811: PPUSH
83812: CALL_OW 321
83816: PUSH
83817: LD_INT 2
83819: EQUAL
83820: ST_TO_ADDR
83821: GO 83824
83823: POP
// end ;
83824: LD_VAR 0 3
83828: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
83829: LD_INT 0
83831: PPUSH
83832: PPUSH
83833: PPUSH
83834: PPUSH
83835: PPUSH
83836: PPUSH
83837: PPUSH
83838: PPUSH
83839: PPUSH
83840: PPUSH
83841: PPUSH
// result := false ;
83842: LD_ADDR_VAR 0 6
83846: PUSH
83847: LD_INT 0
83849: ST_TO_ADDR
// if btype = b_depot then
83850: LD_VAR 0 2
83854: PUSH
83855: LD_INT 0
83857: EQUAL
83858: IFFALSE 83870
// begin result := true ;
83860: LD_ADDR_VAR 0 6
83864: PUSH
83865: LD_INT 1
83867: ST_TO_ADDR
// exit ;
83868: GO 84696
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83870: LD_VAR 0 1
83874: NOT
83875: PUSH
83876: LD_VAR 0 1
83880: PPUSH
83881: CALL_OW 266
83885: PUSH
83886: LD_INT 0
83888: PUSH
83889: LD_INT 1
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: IN
83896: NOT
83897: OR
83898: PUSH
83899: LD_VAR 0 2
83903: NOT
83904: OR
83905: PUSH
83906: LD_VAR 0 5
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 1
83916: PUSH
83917: LD_INT 2
83919: PUSH
83920: LD_INT 3
83922: PUSH
83923: LD_INT 4
83925: PUSH
83926: LD_INT 5
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: IN
83937: NOT
83938: OR
83939: PUSH
83940: LD_VAR 0 3
83944: PPUSH
83945: LD_VAR 0 4
83949: PPUSH
83950: CALL_OW 488
83954: NOT
83955: OR
83956: IFFALSE 83960
// exit ;
83958: GO 84696
// side := GetSide ( depot ) ;
83960: LD_ADDR_VAR 0 9
83964: PUSH
83965: LD_VAR 0 1
83969: PPUSH
83970: CALL_OW 255
83974: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83975: LD_VAR 0 9
83979: PPUSH
83980: LD_VAR 0 2
83984: PPUSH
83985: CALL 83453 0 2
83989: NOT
83990: IFFALSE 83994
// exit ;
83992: GO 84696
// pom := GetBase ( depot ) ;
83994: LD_ADDR_VAR 0 10
83998: PUSH
83999: LD_VAR 0 1
84003: PPUSH
84004: CALL_OW 274
84008: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
84009: LD_ADDR_VAR 0 11
84013: PUSH
84014: LD_VAR 0 2
84018: PPUSH
84019: LD_VAR 0 1
84023: PPUSH
84024: CALL_OW 248
84028: PPUSH
84029: CALL_OW 450
84033: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
84034: LD_VAR 0 10
84038: PPUSH
84039: LD_INT 1
84041: PPUSH
84042: CALL_OW 275
84046: PUSH
84047: LD_VAR 0 11
84051: PUSH
84052: LD_INT 1
84054: ARRAY
84055: GREATEREQUAL
84056: PUSH
84057: LD_VAR 0 10
84061: PPUSH
84062: LD_INT 2
84064: PPUSH
84065: CALL_OW 275
84069: PUSH
84070: LD_VAR 0 11
84074: PUSH
84075: LD_INT 2
84077: ARRAY
84078: GREATEREQUAL
84079: AND
84080: PUSH
84081: LD_VAR 0 10
84085: PPUSH
84086: LD_INT 3
84088: PPUSH
84089: CALL_OW 275
84093: PUSH
84094: LD_VAR 0 11
84098: PUSH
84099: LD_INT 3
84101: ARRAY
84102: GREATEREQUAL
84103: AND
84104: NOT
84105: IFFALSE 84109
// exit ;
84107: GO 84696
// if GetBType ( depot ) = b_depot then
84109: LD_VAR 0 1
84113: PPUSH
84114: CALL_OW 266
84118: PUSH
84119: LD_INT 0
84121: EQUAL
84122: IFFALSE 84134
// dist := 28 else
84124: LD_ADDR_VAR 0 14
84128: PUSH
84129: LD_INT 28
84131: ST_TO_ADDR
84132: GO 84142
// dist := 36 ;
84134: LD_ADDR_VAR 0 14
84138: PUSH
84139: LD_INT 36
84141: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84142: LD_VAR 0 1
84146: PPUSH
84147: LD_VAR 0 3
84151: PPUSH
84152: LD_VAR 0 4
84156: PPUSH
84157: CALL_OW 297
84161: PUSH
84162: LD_VAR 0 14
84166: GREATER
84167: IFFALSE 84171
// exit ;
84169: GO 84696
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84171: LD_ADDR_VAR 0 12
84175: PUSH
84176: LD_VAR 0 2
84180: PPUSH
84181: LD_VAR 0 3
84185: PPUSH
84186: LD_VAR 0 4
84190: PPUSH
84191: LD_VAR 0 5
84195: PPUSH
84196: LD_VAR 0 1
84200: PPUSH
84201: CALL_OW 248
84205: PPUSH
84206: LD_INT 0
84208: PPUSH
84209: CALL 84701 0 6
84213: ST_TO_ADDR
// if not hexes then
84214: LD_VAR 0 12
84218: NOT
84219: IFFALSE 84223
// exit ;
84221: GO 84696
// hex := GetHexInfo ( x , y ) ;
84223: LD_ADDR_VAR 0 15
84227: PUSH
84228: LD_VAR 0 3
84232: PPUSH
84233: LD_VAR 0 4
84237: PPUSH
84238: CALL_OW 546
84242: ST_TO_ADDR
// if hex [ 1 ] then
84243: LD_VAR 0 15
84247: PUSH
84248: LD_INT 1
84250: ARRAY
84251: IFFALSE 84255
// exit ;
84253: GO 84696
// height := hex [ 2 ] ;
84255: LD_ADDR_VAR 0 13
84259: PUSH
84260: LD_VAR 0 15
84264: PUSH
84265: LD_INT 2
84267: ARRAY
84268: ST_TO_ADDR
// for i = 1 to hexes do
84269: LD_ADDR_VAR 0 7
84273: PUSH
84274: DOUBLE
84275: LD_INT 1
84277: DEC
84278: ST_TO_ADDR
84279: LD_VAR 0 12
84283: PUSH
84284: FOR_TO
84285: IFFALSE 84615
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
84287: LD_VAR 0 12
84291: PUSH
84292: LD_VAR 0 7
84296: ARRAY
84297: PUSH
84298: LD_INT 1
84300: ARRAY
84301: PPUSH
84302: LD_VAR 0 12
84306: PUSH
84307: LD_VAR 0 7
84311: ARRAY
84312: PUSH
84313: LD_INT 2
84315: ARRAY
84316: PPUSH
84317: CALL_OW 488
84321: NOT
84322: PUSH
84323: LD_VAR 0 12
84327: PUSH
84328: LD_VAR 0 7
84332: ARRAY
84333: PUSH
84334: LD_INT 1
84336: ARRAY
84337: PPUSH
84338: LD_VAR 0 12
84342: PUSH
84343: LD_VAR 0 7
84347: ARRAY
84348: PUSH
84349: LD_INT 2
84351: ARRAY
84352: PPUSH
84353: CALL_OW 428
84357: PUSH
84358: LD_INT 0
84360: GREATER
84361: OR
84362: PUSH
84363: LD_VAR 0 12
84367: PUSH
84368: LD_VAR 0 7
84372: ARRAY
84373: PUSH
84374: LD_INT 1
84376: ARRAY
84377: PPUSH
84378: LD_VAR 0 12
84382: PUSH
84383: LD_VAR 0 7
84387: ARRAY
84388: PUSH
84389: LD_INT 2
84391: ARRAY
84392: PPUSH
84393: CALL_OW 351
84397: OR
84398: IFFALSE 84404
// exit ;
84400: POP
84401: POP
84402: GO 84696
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84404: LD_ADDR_VAR 0 8
84408: PUSH
84409: LD_VAR 0 12
84413: PUSH
84414: LD_VAR 0 7
84418: ARRAY
84419: PUSH
84420: LD_INT 1
84422: ARRAY
84423: PPUSH
84424: LD_VAR 0 12
84428: PUSH
84429: LD_VAR 0 7
84433: ARRAY
84434: PUSH
84435: LD_INT 2
84437: ARRAY
84438: PPUSH
84439: CALL_OW 546
84443: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
84444: LD_VAR 0 8
84448: PUSH
84449: LD_INT 1
84451: ARRAY
84452: PUSH
84453: LD_VAR 0 8
84457: PUSH
84458: LD_INT 2
84460: ARRAY
84461: PUSH
84462: LD_VAR 0 13
84466: PUSH
84467: LD_INT 2
84469: PLUS
84470: GREATER
84471: OR
84472: PUSH
84473: LD_VAR 0 8
84477: PUSH
84478: LD_INT 2
84480: ARRAY
84481: PUSH
84482: LD_VAR 0 13
84486: PUSH
84487: LD_INT 2
84489: MINUS
84490: LESS
84491: OR
84492: PUSH
84493: LD_VAR 0 8
84497: PUSH
84498: LD_INT 3
84500: ARRAY
84501: PUSH
84502: LD_INT 0
84504: PUSH
84505: LD_INT 8
84507: PUSH
84508: LD_INT 9
84510: PUSH
84511: LD_INT 10
84513: PUSH
84514: LD_INT 11
84516: PUSH
84517: LD_INT 12
84519: PUSH
84520: LD_INT 13
84522: PUSH
84523: LD_INT 16
84525: PUSH
84526: LD_INT 17
84528: PUSH
84529: LD_INT 18
84531: PUSH
84532: LD_INT 19
84534: PUSH
84535: LD_INT 20
84537: PUSH
84538: LD_INT 21
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: IN
84556: NOT
84557: OR
84558: PUSH
84559: LD_VAR 0 8
84563: PUSH
84564: LD_INT 5
84566: ARRAY
84567: NOT
84568: OR
84569: PUSH
84570: LD_VAR 0 8
84574: PUSH
84575: LD_INT 6
84577: ARRAY
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: LD_INT 7
84587: PUSH
84588: LD_INT 9
84590: PUSH
84591: LD_INT 10
84593: PUSH
84594: LD_INT 11
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: IN
84605: NOT
84606: OR
84607: IFFALSE 84613
// exit ;
84609: POP
84610: POP
84611: GO 84696
// end ;
84613: GO 84284
84615: POP
84616: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
84617: LD_VAR 0 9
84621: PPUSH
84622: LD_VAR 0 3
84626: PPUSH
84627: LD_VAR 0 4
84631: PPUSH
84632: LD_INT 20
84634: PPUSH
84635: CALL 76619 0 4
84639: PUSH
84640: LD_INT 4
84642: ARRAY
84643: IFFALSE 84647
// exit ;
84645: GO 84696
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
84647: LD_VAR 0 2
84651: PUSH
84652: LD_INT 29
84654: PUSH
84655: LD_INT 30
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: IN
84662: PUSH
84663: LD_VAR 0 3
84667: PPUSH
84668: LD_VAR 0 4
84672: PPUSH
84673: LD_VAR 0 9
84677: PPUSH
84678: CALL_OW 440
84682: NOT
84683: AND
84684: IFFALSE 84688
// exit ;
84686: GO 84696
// result := true ;
84688: LD_ADDR_VAR 0 6
84692: PUSH
84693: LD_INT 1
84695: ST_TO_ADDR
// end ;
84696: LD_VAR 0 6
84700: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
84701: LD_INT 0
84703: PPUSH
84704: PPUSH
84705: PPUSH
84706: PPUSH
84707: PPUSH
84708: PPUSH
84709: PPUSH
84710: PPUSH
84711: PPUSH
84712: PPUSH
84713: PPUSH
84714: PPUSH
84715: PPUSH
84716: PPUSH
84717: PPUSH
84718: PPUSH
84719: PPUSH
84720: PPUSH
84721: PPUSH
84722: PPUSH
84723: PPUSH
84724: PPUSH
84725: PPUSH
84726: PPUSH
84727: PPUSH
84728: PPUSH
84729: PPUSH
84730: PPUSH
84731: PPUSH
84732: PPUSH
84733: PPUSH
84734: PPUSH
84735: PPUSH
84736: PPUSH
84737: PPUSH
84738: PPUSH
84739: PPUSH
84740: PPUSH
84741: PPUSH
84742: PPUSH
84743: PPUSH
84744: PPUSH
84745: PPUSH
84746: PPUSH
84747: PPUSH
84748: PPUSH
84749: PPUSH
84750: PPUSH
84751: PPUSH
84752: PPUSH
84753: PPUSH
84754: PPUSH
84755: PPUSH
84756: PPUSH
84757: PPUSH
84758: PPUSH
84759: PPUSH
84760: PPUSH
// result = [ ] ;
84761: LD_ADDR_VAR 0 7
84765: PUSH
84766: EMPTY
84767: ST_TO_ADDR
// temp_list = [ ] ;
84768: LD_ADDR_VAR 0 9
84772: PUSH
84773: EMPTY
84774: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
84775: LD_VAR 0 4
84779: PUSH
84780: LD_INT 0
84782: PUSH
84783: LD_INT 1
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 3
84791: PUSH
84792: LD_INT 4
84794: PUSH
84795: LD_INT 5
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: IN
84806: NOT
84807: PUSH
84808: LD_VAR 0 1
84812: PUSH
84813: LD_INT 0
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: IN
84823: PUSH
84824: LD_VAR 0 5
84828: PUSH
84829: LD_INT 1
84831: PUSH
84832: LD_INT 2
84834: PUSH
84835: LD_INT 3
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: IN
84843: NOT
84844: AND
84845: OR
84846: IFFALSE 84850
// exit ;
84848: GO 103241
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84850: LD_VAR 0 1
84854: PUSH
84855: LD_INT 6
84857: PUSH
84858: LD_INT 7
84860: PUSH
84861: LD_INT 8
84863: PUSH
84864: LD_INT 13
84866: PUSH
84867: LD_INT 12
84869: PUSH
84870: LD_INT 15
84872: PUSH
84873: LD_INT 11
84875: PUSH
84876: LD_INT 14
84878: PUSH
84879: LD_INT 10
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: IN
84893: IFFALSE 84903
// btype = b_lab ;
84895: LD_ADDR_VAR 0 1
84899: PUSH
84900: LD_INT 6
84902: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84903: LD_VAR 0 6
84907: PUSH
84908: LD_INT 0
84910: PUSH
84911: LD_INT 1
84913: PUSH
84914: LD_INT 2
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: LIST
84921: IN
84922: NOT
84923: PUSH
84924: LD_VAR 0 1
84928: PUSH
84929: LD_INT 0
84931: PUSH
84932: LD_INT 1
84934: PUSH
84935: LD_INT 2
84937: PUSH
84938: LD_INT 3
84940: PUSH
84941: LD_INT 6
84943: PUSH
84944: LD_INT 36
84946: PUSH
84947: LD_INT 4
84949: PUSH
84950: LD_INT 5
84952: PUSH
84953: LD_INT 31
84955: PUSH
84956: LD_INT 32
84958: PUSH
84959: LD_INT 33
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: IN
84975: NOT
84976: PUSH
84977: LD_VAR 0 6
84981: PUSH
84982: LD_INT 1
84984: EQUAL
84985: AND
84986: OR
84987: PUSH
84988: LD_VAR 0 1
84992: PUSH
84993: LD_INT 2
84995: PUSH
84996: LD_INT 3
84998: PUSH
84999: EMPTY
85000: LIST
85001: LIST
85002: IN
85003: NOT
85004: PUSH
85005: LD_VAR 0 6
85009: PUSH
85010: LD_INT 2
85012: EQUAL
85013: AND
85014: OR
85015: IFFALSE 85025
// mode = 0 ;
85017: LD_ADDR_VAR 0 6
85021: PUSH
85022: LD_INT 0
85024: ST_TO_ADDR
// case mode of 0 :
85025: LD_VAR 0 6
85029: PUSH
85030: LD_INT 0
85032: DOUBLE
85033: EQUAL
85034: IFTRUE 85038
85036: GO 96491
85038: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85039: LD_ADDR_VAR 0 11
85043: PUSH
85044: LD_INT 0
85046: PUSH
85047: LD_INT 0
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: LD_INT 1
85059: NEG
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: LD_INT 1
85067: PUSH
85068: LD_INT 0
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 1
85077: PUSH
85078: LD_INT 1
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 0
85087: PUSH
85088: LD_INT 1
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 1
85097: NEG
85098: PUSH
85099: LD_INT 0
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 1
85108: NEG
85109: PUSH
85110: LD_INT 1
85112: NEG
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 1
85120: NEG
85121: PUSH
85122: LD_INT 2
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: LD_INT 2
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: PUSH
85155: LD_INT 2
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 0
85164: PUSH
85165: LD_INT 2
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 1
85174: NEG
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: LD_INT 3
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: LD_INT 3
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: LD_INT 2
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85232: LD_ADDR_VAR 0 12
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: LD_INT 0
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 0
85249: PUSH
85250: LD_INT 1
85252: NEG
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 1
85260: PUSH
85261: LD_INT 0
85263: PUSH
85264: EMPTY
85265: LIST
85266: LIST
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: LD_INT 1
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: LD_INT 1
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: PUSH
85325: LD_INT 0
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: LD_INT 1
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 2
85355: NEG
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 2
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 2
85378: NEG
85379: PUSH
85380: LD_INT 1
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 3
85389: NEG
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 3
85400: NEG
85401: PUSH
85402: LD_INT 1
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: LIST
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85428: LD_ADDR_VAR 0 13
85432: PUSH
85433: LD_INT 0
85435: PUSH
85436: LD_INT 0
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 0
85445: PUSH
85446: LD_INT 1
85448: NEG
85449: PUSH
85450: EMPTY
85451: LIST
85452: LIST
85453: PUSH
85454: LD_INT 1
85456: PUSH
85457: LD_INT 0
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: LD_INT 1
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 0
85476: PUSH
85477: LD_INT 1
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 1
85486: NEG
85487: PUSH
85488: LD_INT 0
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 1
85497: NEG
85498: PUSH
85499: LD_INT 1
85501: NEG
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: PUSH
85507: LD_INT 1
85509: NEG
85510: PUSH
85511: LD_INT 2
85513: NEG
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: PUSH
85519: LD_INT 2
85521: PUSH
85522: LD_INT 1
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: LD_INT 2
85531: PUSH
85532: LD_INT 2
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 1
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 2
85551: NEG
85552: PUSH
85553: LD_INT 1
85555: NEG
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 2
85563: NEG
85564: PUSH
85565: LD_INT 2
85567: NEG
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 2
85575: NEG
85576: PUSH
85577: LD_INT 3
85579: NEG
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 3
85587: NEG
85588: PUSH
85589: LD_INT 2
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 3
85599: NEG
85600: PUSH
85601: LD_INT 3
85603: NEG
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: EMPTY
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85627: LD_ADDR_VAR 0 14
85631: PUSH
85632: LD_INT 0
85634: PUSH
85635: LD_INT 0
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 0
85644: PUSH
85645: LD_INT 1
85647: NEG
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: LD_INT 0
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: LD_INT 1
85665: PUSH
85666: LD_INT 1
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 0
85675: PUSH
85676: LD_INT 1
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: NEG
85686: PUSH
85687: LD_INT 0
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 1
85696: NEG
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 1
85708: NEG
85709: PUSH
85710: LD_INT 2
85712: NEG
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 0
85720: PUSH
85721: LD_INT 2
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: LD_INT 1
85734: NEG
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PUSH
85740: LD_INT 1
85742: PUSH
85743: LD_INT 2
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 0
85752: PUSH
85753: LD_INT 2
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 1
85762: NEG
85763: PUSH
85764: LD_INT 1
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PUSH
85771: LD_INT 1
85773: NEG
85774: PUSH
85775: LD_INT 3
85777: NEG
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: LD_INT 3
85788: NEG
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: PUSH
85794: LD_INT 1
85796: PUSH
85797: LD_INT 2
85799: NEG
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85823: LD_ADDR_VAR 0 15
85827: PUSH
85828: LD_INT 0
85830: PUSH
85831: LD_INT 0
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 0
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 1
85851: PUSH
85852: LD_INT 0
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 1
85861: PUSH
85862: LD_INT 1
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 0
85871: PUSH
85872: LD_INT 1
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: LD_INT 0
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 1
85892: NEG
85893: PUSH
85894: LD_INT 1
85896: NEG
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: LD_INT 1
85907: NEG
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 2
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 2
85925: PUSH
85926: LD_INT 1
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 1
85935: NEG
85936: PUSH
85937: LD_INT 1
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 2
85946: NEG
85947: PUSH
85948: LD_INT 0
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 2
85957: NEG
85958: PUSH
85959: LD_INT 1
85961: NEG
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 2
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 3
85980: PUSH
85981: LD_INT 0
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 3
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86016: LD_ADDR_VAR 0 16
86020: PUSH
86021: LD_INT 0
86023: PUSH
86024: LD_INT 0
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 0
86033: PUSH
86034: LD_INT 1
86036: NEG
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: LD_INT 0
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: LD_INT 1
86054: PUSH
86055: LD_INT 1
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: LD_INT 1
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 1
86074: NEG
86075: PUSH
86076: LD_INT 0
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 1
86085: NEG
86086: PUSH
86087: LD_INT 1
86089: NEG
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: NEG
86098: PUSH
86099: LD_INT 2
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 2
86109: PUSH
86110: LD_INT 1
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 2
86119: PUSH
86120: LD_INT 2
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 1
86129: PUSH
86130: LD_INT 2
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 2
86139: NEG
86140: PUSH
86141: LD_INT 1
86143: NEG
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: PUSH
86149: LD_INT 2
86151: NEG
86152: PUSH
86153: LD_INT 2
86155: NEG
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 3
86163: PUSH
86164: LD_INT 2
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 3
86173: PUSH
86174: LD_INT 3
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 2
86183: PUSH
86184: LD_INT 3
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86209: LD_ADDR_VAR 0 17
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 1
86229: NEG
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: PUSH
86248: LD_INT 1
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: LD_INT 0
86257: PUSH
86258: LD_INT 1
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 1
86267: NEG
86268: PUSH
86269: LD_INT 0
86271: PUSH
86272: EMPTY
86273: LIST
86274: LIST
86275: PUSH
86276: LD_INT 1
86278: NEG
86279: PUSH
86280: LD_INT 1
86282: NEG
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 1
86290: NEG
86291: PUSH
86292: LD_INT 2
86294: NEG
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 0
86302: PUSH
86303: LD_INT 2
86305: NEG
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 1
86313: PUSH
86314: LD_INT 1
86316: NEG
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 2
86324: PUSH
86325: LD_INT 0
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 2
86344: PUSH
86345: LD_INT 2
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: PUSH
86352: LD_INT 1
86354: PUSH
86355: LD_INT 2
86357: PUSH
86358: EMPTY
86359: LIST
86360: LIST
86361: PUSH
86362: LD_INT 0
86364: PUSH
86365: LD_INT 2
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 1
86374: NEG
86375: PUSH
86376: LD_INT 1
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 2
86385: NEG
86386: PUSH
86387: LD_INT 0
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 2
86396: NEG
86397: PUSH
86398: LD_INT 1
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 2
86408: NEG
86409: PUSH
86410: LD_INT 2
86412: NEG
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86439: LD_ADDR_VAR 0 18
86443: PUSH
86444: LD_INT 0
86446: PUSH
86447: LD_INT 0
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 1
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: PUSH
86478: LD_INT 1
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 0
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: PUSH
86495: LD_INT 1
86497: NEG
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: PUSH
86506: LD_INT 1
86508: NEG
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 1
86520: NEG
86521: PUSH
86522: LD_INT 2
86524: NEG
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 0
86532: PUSH
86533: LD_INT 2
86535: NEG
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: LD_INT 1
86546: NEG
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 2
86554: PUSH
86555: LD_INT 0
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: PUSH
86562: LD_INT 2
86564: PUSH
86565: LD_INT 1
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: PUSH
86572: LD_INT 2
86574: PUSH
86575: LD_INT 2
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: LD_INT 2
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: LD_INT 2
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 1
86604: NEG
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 2
86615: NEG
86616: PUSH
86617: LD_INT 0
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 2
86626: NEG
86627: PUSH
86628: LD_INT 1
86630: NEG
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 2
86638: NEG
86639: PUSH
86640: LD_INT 2
86642: NEG
86643: PUSH
86644: EMPTY
86645: LIST
86646: LIST
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86669: LD_ADDR_VAR 0 19
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: LD_INT 0
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: PUSH
86684: LD_INT 0
86686: PUSH
86687: LD_INT 1
86689: NEG
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 1
86697: PUSH
86698: LD_INT 0
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 1
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 0
86717: PUSH
86718: LD_INT 1
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PUSH
86725: LD_INT 1
86727: NEG
86728: PUSH
86729: LD_INT 0
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: LD_INT 1
86742: NEG
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 1
86750: NEG
86751: PUSH
86752: LD_INT 2
86754: NEG
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: PUSH
86760: LD_INT 0
86762: PUSH
86763: LD_INT 2
86765: NEG
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: LD_INT 1
86776: NEG
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 2
86784: PUSH
86785: LD_INT 0
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 2
86794: PUSH
86795: LD_INT 1
86797: PUSH
86798: EMPTY
86799: LIST
86800: LIST
86801: PUSH
86802: LD_INT 2
86804: PUSH
86805: LD_INT 2
86807: PUSH
86808: EMPTY
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 1
86814: PUSH
86815: LD_INT 2
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: PUSH
86822: LD_INT 0
86824: PUSH
86825: LD_INT 2
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 1
86834: NEG
86835: PUSH
86836: LD_INT 1
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 2
86845: NEG
86846: PUSH
86847: LD_INT 0
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: PUSH
86854: LD_INT 2
86856: NEG
86857: PUSH
86858: LD_INT 1
86860: NEG
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: PUSH
86866: LD_INT 2
86868: NEG
86869: PUSH
86870: LD_INT 2
86872: NEG
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86899: LD_ADDR_VAR 0 20
86903: PUSH
86904: LD_INT 0
86906: PUSH
86907: LD_INT 0
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: LD_INT 1
86919: NEG
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: LD_INT 0
86930: PUSH
86931: EMPTY
86932: LIST
86933: LIST
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: LD_INT 1
86940: PUSH
86941: EMPTY
86942: LIST
86943: LIST
86944: PUSH
86945: LD_INT 0
86947: PUSH
86948: LD_INT 1
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 1
86957: NEG
86958: PUSH
86959: LD_INT 0
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 1
86968: NEG
86969: PUSH
86970: LD_INT 1
86972: NEG
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: LD_INT 1
86980: NEG
86981: PUSH
86982: LD_INT 2
86984: NEG
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 0
86992: PUSH
86993: LD_INT 2
86995: NEG
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 1
87003: PUSH
87004: LD_INT 1
87006: NEG
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 2
87014: PUSH
87015: LD_INT 0
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 2
87024: PUSH
87025: LD_INT 1
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: LD_INT 2
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: PUSH
87042: LD_INT 1
87044: PUSH
87045: LD_INT 2
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 0
87054: PUSH
87055: LD_INT 2
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 1
87064: NEG
87065: PUSH
87066: LD_INT 1
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 2
87075: NEG
87076: PUSH
87077: LD_INT 0
87079: PUSH
87080: EMPTY
87081: LIST
87082: LIST
87083: PUSH
87084: LD_INT 2
87086: NEG
87087: PUSH
87088: LD_INT 1
87090: NEG
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 2
87098: NEG
87099: PUSH
87100: LD_INT 2
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87129: LD_ADDR_VAR 0 21
87133: PUSH
87134: LD_INT 0
87136: PUSH
87137: LD_INT 0
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: LD_INT 0
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 1
87167: PUSH
87168: LD_INT 1
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: LD_INT 0
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 1
87198: NEG
87199: PUSH
87200: LD_INT 1
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 1
87210: NEG
87211: PUSH
87212: LD_INT 2
87214: NEG
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 0
87222: PUSH
87223: LD_INT 2
87225: NEG
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 1
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 2
87244: PUSH
87245: LD_INT 0
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 2
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 2
87264: PUSH
87265: LD_INT 2
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: LD_INT 1
87274: PUSH
87275: LD_INT 2
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 0
87284: PUSH
87285: LD_INT 2
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 1
87294: NEG
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: LD_INT 2
87305: NEG
87306: PUSH
87307: LD_INT 0
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 2
87316: NEG
87317: PUSH
87318: LD_INT 1
87320: NEG
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 2
87328: NEG
87329: PUSH
87330: LD_INT 2
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87359: LD_ADDR_VAR 0 22
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: LD_INT 0
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 0
87376: PUSH
87377: LD_INT 1
87379: NEG
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 1
87387: PUSH
87388: LD_INT 0
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 1
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: LD_INT 1
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: NEG
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 1
87428: NEG
87429: PUSH
87430: LD_INT 1
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: LD_INT 1
87440: NEG
87441: PUSH
87442: LD_INT 2
87444: NEG
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: LD_INT 2
87455: NEG
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 2
87474: PUSH
87475: LD_INT 0
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 2
87494: PUSH
87495: LD_INT 2
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 2
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 0
87514: PUSH
87515: LD_INT 2
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 1
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 2
87535: NEG
87536: PUSH
87537: LD_INT 0
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: PUSH
87544: LD_INT 2
87546: NEG
87547: PUSH
87548: LD_INT 1
87550: NEG
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 2
87558: NEG
87559: PUSH
87560: LD_INT 2
87562: NEG
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87589: LD_ADDR_VAR 0 23
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: LD_INT 0
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: LD_INT 1
87609: NEG
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 1
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 1
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: LD_INT 1
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: NEG
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 1
87658: NEG
87659: PUSH
87660: LD_INT 1
87662: NEG
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: LD_INT 1
87670: NEG
87671: PUSH
87672: LD_INT 2
87674: NEG
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: LD_INT 2
87685: NEG
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: LD_INT 1
87696: NEG
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 2
87704: PUSH
87705: LD_INT 0
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 2
87714: PUSH
87715: LD_INT 1
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 2
87724: PUSH
87725: LD_INT 2
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: LD_INT 2
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 0
87744: PUSH
87745: LD_INT 2
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: LD_INT 1
87754: NEG
87755: PUSH
87756: LD_INT 1
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 2
87765: NEG
87766: PUSH
87767: LD_INT 0
87769: PUSH
87770: EMPTY
87771: LIST
87772: LIST
87773: PUSH
87774: LD_INT 2
87776: NEG
87777: PUSH
87778: LD_INT 1
87780: NEG
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 2
87788: NEG
87789: PUSH
87790: LD_INT 2
87792: NEG
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PUSH
87798: LD_INT 2
87800: NEG
87801: PUSH
87802: LD_INT 3
87804: NEG
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: NEG
87813: PUSH
87814: LD_INT 3
87816: NEG
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: PUSH
87825: LD_INT 2
87827: NEG
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 2
87835: PUSH
87836: LD_INT 1
87838: NEG
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87869: LD_ADDR_VAR 0 24
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: LD_INT 0
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 0
87886: PUSH
87887: LD_INT 1
87889: NEG
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: LD_INT 0
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 1
87907: PUSH
87908: LD_INT 1
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 0
87917: PUSH
87918: LD_INT 1
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 1
87927: NEG
87928: PUSH
87929: LD_INT 0
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: NEG
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 1
87950: NEG
87951: PUSH
87952: LD_INT 2
87954: NEG
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 0
87962: PUSH
87963: LD_INT 2
87965: NEG
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 1
87973: PUSH
87974: LD_INT 1
87976: NEG
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 2
87984: PUSH
87985: LD_INT 0
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: LD_INT 1
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 2
88004: PUSH
88005: LD_INT 2
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 1
88014: PUSH
88015: LD_INT 2
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 0
88024: PUSH
88025: LD_INT 2
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 1
88034: NEG
88035: PUSH
88036: LD_INT 1
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PUSH
88043: LD_INT 2
88045: NEG
88046: PUSH
88047: LD_INT 0
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 2
88056: NEG
88057: PUSH
88058: LD_INT 1
88060: NEG
88061: PUSH
88062: EMPTY
88063: LIST
88064: LIST
88065: PUSH
88066: LD_INT 2
88068: NEG
88069: PUSH
88070: LD_INT 2
88072: NEG
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 1
88080: PUSH
88081: LD_INT 2
88083: NEG
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: PUSH
88092: LD_INT 1
88094: NEG
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 3
88102: PUSH
88103: LD_INT 1
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 3
88112: PUSH
88113: LD_INT 2
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88145: LD_ADDR_VAR 0 25
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 0
88162: PUSH
88163: LD_INT 1
88165: NEG
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: LD_INT 0
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 1
88183: PUSH
88184: LD_INT 1
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 0
88193: PUSH
88194: LD_INT 1
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 1
88203: NEG
88204: PUSH
88205: LD_INT 0
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: LD_INT 1
88214: NEG
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 1
88226: NEG
88227: PUSH
88228: LD_INT 2
88230: NEG
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 0
88238: PUSH
88239: LD_INT 2
88241: NEG
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 2
88260: PUSH
88261: LD_INT 0
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 2
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: LD_INT 2
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 1
88290: PUSH
88291: LD_INT 2
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: LD_INT 2
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 1
88310: NEG
88311: PUSH
88312: LD_INT 1
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: LD_INT 2
88321: NEG
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 2
88332: NEG
88333: PUSH
88334: LD_INT 1
88336: NEG
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 2
88344: NEG
88345: PUSH
88346: LD_INT 2
88348: NEG
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 3
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 3
88366: PUSH
88367: LD_INT 2
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 2
88376: PUSH
88377: LD_INT 3
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: LD_INT 1
88386: PUSH
88387: LD_INT 3
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88419: LD_ADDR_VAR 0 26
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: LD_INT 0
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: LD_INT 1
88439: NEG
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: LD_INT 0
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: PUSH
88455: LD_INT 1
88457: PUSH
88458: LD_INT 1
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 0
88467: PUSH
88468: LD_INT 1
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: LD_INT 1
88477: NEG
88478: PUSH
88479: LD_INT 0
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: LD_INT 1
88492: NEG
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 1
88500: NEG
88501: PUSH
88502: LD_INT 2
88504: NEG
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 0
88512: PUSH
88513: LD_INT 2
88515: NEG
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: PUSH
88524: LD_INT 1
88526: NEG
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 2
88534: PUSH
88535: LD_INT 0
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 2
88544: PUSH
88545: LD_INT 1
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: LD_INT 2
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: LD_INT 2
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 0
88574: PUSH
88575: LD_INT 2
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 1
88584: NEG
88585: PUSH
88586: LD_INT 1
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 2
88595: NEG
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 2
88606: NEG
88607: PUSH
88608: LD_INT 1
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 2
88618: NEG
88619: PUSH
88620: LD_INT 2
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 2
88630: PUSH
88631: LD_INT 3
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 1
88640: PUSH
88641: LD_INT 3
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 1
88650: NEG
88651: PUSH
88652: LD_INT 2
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 2
88661: NEG
88662: PUSH
88663: LD_INT 1
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88695: LD_ADDR_VAR 0 27
88699: PUSH
88700: LD_INT 0
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 0
88712: PUSH
88713: LD_INT 1
88715: NEG
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: LD_INT 0
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: PUSH
88731: LD_INT 1
88733: PUSH
88734: LD_INT 1
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: PUSH
88741: LD_INT 0
88743: PUSH
88744: LD_INT 1
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: NEG
88754: PUSH
88755: LD_INT 0
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 1
88764: NEG
88765: PUSH
88766: LD_INT 1
88768: NEG
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 1
88776: NEG
88777: PUSH
88778: LD_INT 2
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: LD_INT 2
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 1
88799: PUSH
88800: LD_INT 1
88802: NEG
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 2
88810: PUSH
88811: LD_INT 0
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: LD_INT 1
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 2
88830: PUSH
88831: LD_INT 2
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: LD_INT 2
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: LD_INT 2
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 1
88860: NEG
88861: PUSH
88862: LD_INT 1
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 2
88871: NEG
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 2
88882: NEG
88883: PUSH
88884: LD_INT 1
88886: NEG
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 2
88894: NEG
88895: PUSH
88896: LD_INT 2
88898: NEG
88899: PUSH
88900: EMPTY
88901: LIST
88902: LIST
88903: PUSH
88904: LD_INT 1
88906: NEG
88907: PUSH
88908: LD_INT 2
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 2
88917: NEG
88918: PUSH
88919: LD_INT 1
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 3
88928: NEG
88929: PUSH
88930: LD_INT 1
88932: NEG
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 3
88940: NEG
88941: PUSH
88942: LD_INT 2
88944: NEG
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88975: LD_ADDR_VAR 0 28
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: LD_INT 0
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 0
88992: PUSH
88993: LD_INT 1
88995: NEG
88996: PUSH
88997: EMPTY
88998: LIST
88999: LIST
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 1
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 0
89023: PUSH
89024: LD_INT 1
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 1
89033: NEG
89034: PUSH
89035: LD_INT 0
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 1
89044: NEG
89045: PUSH
89046: LD_INT 1
89048: NEG
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: PUSH
89054: LD_INT 1
89056: NEG
89057: PUSH
89058: LD_INT 2
89060: NEG
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: LD_INT 2
89071: NEG
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: PUSH
89080: LD_INT 1
89082: NEG
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: PUSH
89091: LD_INT 0
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 2
89100: PUSH
89101: LD_INT 1
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 2
89110: PUSH
89111: LD_INT 2
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 1
89120: PUSH
89121: LD_INT 2
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: PUSH
89128: LD_INT 0
89130: PUSH
89131: LD_INT 2
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 1
89140: NEG
89141: PUSH
89142: LD_INT 1
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: PUSH
89149: LD_INT 2
89151: NEG
89152: PUSH
89153: LD_INT 0
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: PUSH
89160: LD_INT 2
89162: NEG
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 2
89174: NEG
89175: PUSH
89176: LD_INT 2
89178: NEG
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 2
89186: NEG
89187: PUSH
89188: LD_INT 3
89190: NEG
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 1
89198: NEG
89199: PUSH
89200: LD_INT 3
89202: NEG
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 3
89210: NEG
89211: PUSH
89212: LD_INT 1
89214: NEG
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 3
89222: NEG
89223: PUSH
89224: LD_INT 2
89226: NEG
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: EMPTY
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89257: LD_ADDR_VAR 0 29
89261: PUSH
89262: LD_INT 0
89264: PUSH
89265: LD_INT 0
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: LD_INT 1
89277: NEG
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 1
89285: PUSH
89286: LD_INT 0
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: LD_INT 1
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 0
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 1
89315: NEG
89316: PUSH
89317: LD_INT 0
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: NEG
89327: PUSH
89328: LD_INT 1
89330: NEG
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 1
89338: NEG
89339: PUSH
89340: LD_INT 2
89342: NEG
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 0
89350: PUSH
89351: LD_INT 2
89353: NEG
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: LD_INT 1
89364: NEG
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 2
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 2
89382: PUSH
89383: LD_INT 1
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 1
89392: PUSH
89393: LD_INT 2
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 0
89402: PUSH
89403: LD_INT 2
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: NEG
89413: PUSH
89414: LD_INT 1
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 2
89423: NEG
89424: PUSH
89425: LD_INT 1
89427: NEG
89428: PUSH
89429: EMPTY
89430: LIST
89431: LIST
89432: PUSH
89433: LD_INT 2
89435: NEG
89436: PUSH
89437: LD_INT 2
89439: NEG
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 2
89447: NEG
89448: PUSH
89449: LD_INT 3
89451: NEG
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 2
89459: PUSH
89460: LD_INT 1
89462: NEG
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 3
89470: PUSH
89471: LD_INT 1
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: LD_INT 3
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 1
89490: NEG
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 3
89501: NEG
89502: PUSH
89503: LD_INT 2
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89536: LD_ADDR_VAR 0 30
89540: PUSH
89541: LD_INT 0
89543: PUSH
89544: LD_INT 0
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 0
89553: PUSH
89554: LD_INT 1
89556: NEG
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 1
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 1
89574: PUSH
89575: LD_INT 1
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 0
89584: PUSH
89585: LD_INT 1
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 1
89594: NEG
89595: PUSH
89596: LD_INT 0
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: LD_INT 1
89609: NEG
89610: PUSH
89611: EMPTY
89612: LIST
89613: LIST
89614: PUSH
89615: LD_INT 1
89617: NEG
89618: PUSH
89619: LD_INT 2
89621: NEG
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 0
89629: PUSH
89630: LD_INT 2
89632: NEG
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 1
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 2
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 2
89661: PUSH
89662: LD_INT 1
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 2
89671: PUSH
89672: LD_INT 2
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 1
89681: PUSH
89682: LD_INT 2
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 1
89691: NEG
89692: PUSH
89693: LD_INT 1
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 2
89702: NEG
89703: PUSH
89704: LD_INT 0
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 2
89713: NEG
89714: PUSH
89715: LD_INT 1
89717: NEG
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 1
89725: NEG
89726: PUSH
89727: LD_INT 3
89729: NEG
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 1
89737: PUSH
89738: LD_INT 2
89740: NEG
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 3
89748: PUSH
89749: LD_INT 2
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 2
89758: PUSH
89759: LD_INT 3
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: PUSH
89766: LD_INT 2
89768: NEG
89769: PUSH
89770: LD_INT 1
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 3
89779: NEG
89780: PUSH
89781: LD_INT 1
89783: NEG
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89814: LD_ADDR_VAR 0 31
89818: PUSH
89819: LD_INT 0
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: PUSH
89829: LD_INT 0
89831: PUSH
89832: LD_INT 1
89834: NEG
89835: PUSH
89836: EMPTY
89837: LIST
89838: LIST
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: LD_INT 0
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: PUSH
89850: LD_INT 1
89852: PUSH
89853: LD_INT 1
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: PUSH
89860: LD_INT 0
89862: PUSH
89863: LD_INT 1
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: LD_INT 1
89872: NEG
89873: PUSH
89874: LD_INT 0
89876: PUSH
89877: EMPTY
89878: LIST
89879: LIST
89880: PUSH
89881: LD_INT 1
89883: NEG
89884: PUSH
89885: LD_INT 1
89887: NEG
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 1
89895: NEG
89896: PUSH
89897: LD_INT 2
89899: NEG
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: LD_INT 1
89907: PUSH
89908: LD_INT 1
89910: NEG
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PUSH
89916: LD_INT 2
89918: PUSH
89919: LD_INT 0
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 2
89928: PUSH
89929: LD_INT 1
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 2
89938: PUSH
89939: LD_INT 2
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 1
89948: PUSH
89949: LD_INT 2
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_INT 2
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 1
89968: NEG
89969: PUSH
89970: LD_INT 1
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 2
89979: NEG
89980: PUSH
89981: LD_INT 1
89983: NEG
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 2
89991: NEG
89992: PUSH
89993: LD_INT 2
89995: NEG
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: LD_INT 2
90003: NEG
90004: PUSH
90005: LD_INT 3
90007: NEG
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 2
90015: PUSH
90016: LD_INT 1
90018: NEG
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 3
90026: PUSH
90027: LD_INT 1
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: LD_INT 3
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: LD_INT 2
90050: PUSH
90051: EMPTY
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 3
90057: NEG
90058: PUSH
90059: LD_INT 2
90061: NEG
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90092: LD_ADDR_VAR 0 32
90096: PUSH
90097: LD_INT 0
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: LD_INT 1
90112: NEG
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 1
90120: PUSH
90121: LD_INT 0
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: LD_INT 1
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 0
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: LD_INT 0
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 1
90161: NEG
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: LD_INT 2
90177: NEG
90178: PUSH
90179: EMPTY
90180: LIST
90181: LIST
90182: PUSH
90183: LD_INT 0
90185: PUSH
90186: LD_INT 2
90188: NEG
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: LD_INT 1
90199: NEG
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: LD_INT 1
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: LD_INT 2
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: PUSH
90228: LD_INT 2
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: LD_INT 2
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: NEG
90248: PUSH
90249: LD_INT 1
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 2
90258: NEG
90259: PUSH
90260: LD_INT 0
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: LD_INT 1
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 1
90281: NEG
90282: PUSH
90283: LD_INT 3
90285: NEG
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 1
90293: PUSH
90294: LD_INT 2
90296: NEG
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 3
90304: PUSH
90305: LD_INT 2
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: LD_INT 3
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: PUSH
90322: LD_INT 2
90324: NEG
90325: PUSH
90326: LD_INT 1
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 3
90335: NEG
90336: PUSH
90337: LD_INT 1
90339: NEG
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90370: LD_ADDR_VAR 0 33
90374: PUSH
90375: LD_INT 0
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 0
90387: PUSH
90388: LD_INT 1
90390: NEG
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 1
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: PUSH
90409: LD_INT 1
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 0
90418: PUSH
90419: LD_INT 1
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 1
90428: NEG
90429: PUSH
90430: LD_INT 0
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: LD_INT 1
90439: NEG
90440: PUSH
90441: LD_INT 1
90443: NEG
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 1
90451: NEG
90452: PUSH
90453: LD_INT 2
90455: NEG
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: PUSH
90461: LD_INT 1
90463: PUSH
90464: LD_INT 1
90466: NEG
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 2
90474: PUSH
90475: LD_INT 0
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: PUSH
90482: LD_INT 2
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 1
90494: PUSH
90495: LD_INT 2
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 2
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 1
90514: NEG
90515: PUSH
90516: LD_INT 1
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 2
90525: NEG
90526: PUSH
90527: LD_INT 0
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 2
90536: NEG
90537: PUSH
90538: LD_INT 1
90540: NEG
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 2
90548: NEG
90549: PUSH
90550: LD_INT 2
90552: NEG
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 2
90560: NEG
90561: PUSH
90562: LD_INT 3
90564: NEG
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 2
90572: PUSH
90573: LD_INT 1
90575: NEG
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 3
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 1
90593: PUSH
90594: LD_INT 3
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: NEG
90604: PUSH
90605: LD_INT 2
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 3
90614: NEG
90615: PUSH
90616: LD_INT 2
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90649: LD_ADDR_VAR 0 34
90653: PUSH
90654: LD_INT 0
90656: PUSH
90657: LD_INT 0
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: NEG
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 0
90697: PUSH
90698: LD_INT 1
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: NEG
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 1
90718: NEG
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: NEG
90731: PUSH
90732: LD_INT 2
90734: NEG
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 0
90742: PUSH
90743: LD_INT 2
90745: NEG
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: LD_INT 1
90756: NEG
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: LD_INT 1
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: LD_INT 2
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 1
90784: PUSH
90785: LD_INT 2
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: NEG
90795: PUSH
90796: LD_INT 1
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 2
90816: NEG
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 2
90828: NEG
90829: PUSH
90830: LD_INT 2
90832: NEG
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 1
90840: NEG
90841: PUSH
90842: LD_INT 3
90844: NEG
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 1
90852: PUSH
90853: LD_INT 2
90855: NEG
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 3
90863: PUSH
90864: LD_INT 2
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 2
90873: PUSH
90874: LD_INT 3
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 2
90883: NEG
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 3
90894: NEG
90895: PUSH
90896: LD_INT 1
90898: NEG
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: LIST
90908: LIST
90909: LIST
90910: LIST
90911: LIST
90912: LIST
90913: LIST
90914: LIST
90915: LIST
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90929: LD_ADDR_VAR 0 35
90933: PUSH
90934: LD_INT 0
90936: PUSH
90937: LD_INT 0
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 0
90946: PUSH
90947: LD_INT 1
90949: NEG
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: LD_INT 0
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: LD_INT 1
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: LD_INT 1
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 1
90987: NEG
90988: PUSH
90989: LD_INT 0
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 1
90998: NEG
90999: PUSH
91000: LD_INT 1
91002: NEG
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: LD_INT 1
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 2
91020: NEG
91021: PUSH
91022: LD_INT 1
91024: NEG
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91041: LD_ADDR_VAR 0 36
91045: PUSH
91046: LD_INT 0
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 0
91058: PUSH
91059: LD_INT 1
91061: NEG
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 1
91069: PUSH
91070: LD_INT 0
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 1
91079: PUSH
91080: LD_INT 1
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PUSH
91087: LD_INT 0
91089: PUSH
91090: LD_INT 1
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 1
91110: NEG
91111: PUSH
91112: LD_INT 1
91114: NEG
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 1
91122: NEG
91123: PUSH
91124: LD_INT 2
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: LD_INT 2
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91153: LD_ADDR_VAR 0 37
91157: PUSH
91158: LD_INT 0
91160: PUSH
91161: LD_INT 0
91163: PUSH
91164: EMPTY
91165: LIST
91166: LIST
91167: PUSH
91168: LD_INT 0
91170: PUSH
91171: LD_INT 1
91173: NEG
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 1
91181: PUSH
91182: LD_INT 0
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 1
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 0
91201: PUSH
91202: LD_INT 1
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 1
91211: NEG
91212: PUSH
91213: LD_INT 0
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 1
91222: NEG
91223: PUSH
91224: LD_INT 1
91226: NEG
91227: PUSH
91228: EMPTY
91229: LIST
91230: LIST
91231: PUSH
91232: LD_INT 1
91234: PUSH
91235: LD_INT 1
91237: NEG
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 1
91245: NEG
91246: PUSH
91247: LD_INT 1
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91265: LD_ADDR_VAR 0 38
91269: PUSH
91270: LD_INT 0
91272: PUSH
91273: LD_INT 0
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 0
91282: PUSH
91283: LD_INT 1
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 1
91293: PUSH
91294: LD_INT 0
91296: PUSH
91297: EMPTY
91298: LIST
91299: LIST
91300: PUSH
91301: LD_INT 1
91303: PUSH
91304: LD_INT 1
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: LD_INT 1
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: LD_INT 0
91327: PUSH
91328: EMPTY
91329: LIST
91330: LIST
91331: PUSH
91332: LD_INT 1
91334: NEG
91335: PUSH
91336: LD_INT 1
91338: NEG
91339: PUSH
91340: EMPTY
91341: LIST
91342: LIST
91343: PUSH
91344: LD_INT 2
91346: PUSH
91347: LD_INT 1
91349: PUSH
91350: EMPTY
91351: LIST
91352: LIST
91353: PUSH
91354: LD_INT 2
91356: NEG
91357: PUSH
91358: LD_INT 1
91360: NEG
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91377: LD_ADDR_VAR 0 39
91381: PUSH
91382: LD_INT 0
91384: PUSH
91385: LD_INT 0
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PUSH
91392: LD_INT 0
91394: PUSH
91395: LD_INT 1
91397: NEG
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: LD_INT 0
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: LD_INT 1
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 0
91425: PUSH
91426: LD_INT 1
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 1
91435: NEG
91436: PUSH
91437: LD_INT 0
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: PUSH
91444: LD_INT 1
91446: NEG
91447: PUSH
91448: LD_INT 1
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: LD_INT 2
91462: NEG
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 1
91470: PUSH
91471: LD_INT 2
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91489: LD_ADDR_VAR 0 40
91493: PUSH
91494: LD_INT 0
91496: PUSH
91497: LD_INT 0
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 0
91506: PUSH
91507: LD_INT 1
91509: NEG
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: PUSH
91515: LD_INT 1
91517: PUSH
91518: LD_INT 0
91520: PUSH
91521: EMPTY
91522: LIST
91523: LIST
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: LD_INT 1
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 0
91537: PUSH
91538: LD_INT 1
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: LD_INT 1
91547: NEG
91548: PUSH
91549: LD_INT 0
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: PUSH
91556: LD_INT 1
91558: NEG
91559: PUSH
91560: LD_INT 1
91562: NEG
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 1
91570: PUSH
91571: LD_INT 1
91573: NEG
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 1
91581: NEG
91582: PUSH
91583: LD_INT 1
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91601: LD_ADDR_VAR 0 41
91605: PUSH
91606: LD_INT 0
91608: PUSH
91609: LD_INT 0
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 0
91618: PUSH
91619: LD_INT 1
91621: NEG
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 1
91629: PUSH
91630: LD_INT 0
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 1
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: LD_INT 0
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 1
91659: NEG
91660: PUSH
91661: LD_INT 0
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 1
91670: NEG
91671: PUSH
91672: LD_INT 1
91674: NEG
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 1
91682: NEG
91683: PUSH
91684: LD_INT 2
91686: NEG
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 1
91694: PUSH
91695: LD_INT 1
91697: NEG
91698: PUSH
91699: EMPTY
91700: LIST
91701: LIST
91702: PUSH
91703: LD_INT 2
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 2
91715: PUSH
91716: LD_INT 1
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: LD_INT 2
91725: PUSH
91726: LD_INT 2
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 1
91735: PUSH
91736: LD_INT 2
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 1
91745: NEG
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 2
91756: NEG
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 2
91767: NEG
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 2
91779: NEG
91780: PUSH
91781: LD_INT 2
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 2
91791: NEG
91792: PUSH
91793: LD_INT 3
91795: NEG
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 2
91803: PUSH
91804: LD_INT 1
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 3
91814: PUSH
91815: LD_INT 0
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 3
91824: PUSH
91825: LD_INT 1
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 3
91834: PUSH
91835: LD_INT 2
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: LD_INT 3
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 2
91864: NEG
91865: PUSH
91866: LD_INT 1
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 3
91875: NEG
91876: PUSH
91877: LD_INT 0
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 3
91886: NEG
91887: PUSH
91888: LD_INT 1
91890: NEG
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 3
91898: NEG
91899: PUSH
91900: LD_INT 2
91902: NEG
91903: PUSH
91904: EMPTY
91905: LIST
91906: LIST
91907: PUSH
91908: LD_INT 3
91910: NEG
91911: PUSH
91912: LD_INT 3
91914: NEG
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91951: LD_ADDR_VAR 0 42
91955: PUSH
91956: LD_INT 0
91958: PUSH
91959: LD_INT 0
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: LD_INT 0
91968: PUSH
91969: LD_INT 1
91971: NEG
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 1
91979: PUSH
91980: LD_INT 0
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: LD_INT 1
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: PUSH
91997: LD_INT 0
91999: PUSH
92000: LD_INT 1
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: PUSH
92007: LD_INT 1
92009: NEG
92010: PUSH
92011: LD_INT 0
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 1
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 1
92032: NEG
92033: PUSH
92034: LD_INT 2
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: LD_INT 0
92044: PUSH
92045: LD_INT 2
92047: NEG
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 1
92055: PUSH
92056: LD_INT 1
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 2
92066: PUSH
92067: LD_INT 1
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 2
92076: PUSH
92077: LD_INT 2
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 1
92086: PUSH
92087: LD_INT 2
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 0
92096: PUSH
92097: LD_INT 2
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 1
92106: NEG
92107: PUSH
92108: LD_INT 1
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 2
92117: NEG
92118: PUSH
92119: LD_INT 1
92121: NEG
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 2
92129: NEG
92130: PUSH
92131: LD_INT 2
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 2
92141: NEG
92142: PUSH
92143: LD_INT 3
92145: NEG
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 1
92153: NEG
92154: PUSH
92155: LD_INT 3
92157: NEG
92158: PUSH
92159: EMPTY
92160: LIST
92161: LIST
92162: PUSH
92163: LD_INT 0
92165: PUSH
92166: LD_INT 3
92168: NEG
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 1
92176: PUSH
92177: LD_INT 2
92179: NEG
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: LD_INT 3
92187: PUSH
92188: LD_INT 2
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 3
92197: PUSH
92198: LD_INT 3
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 2
92207: PUSH
92208: LD_INT 3
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 1
92217: PUSH
92218: LD_INT 3
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 0
92227: PUSH
92228: LD_INT 3
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 1
92237: NEG
92238: PUSH
92239: LD_INT 2
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 3
92248: NEG
92249: PUSH
92250: LD_INT 2
92252: NEG
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 3
92260: NEG
92261: PUSH
92262: LD_INT 3
92264: NEG
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92301: LD_ADDR_VAR 0 43
92305: PUSH
92306: LD_INT 0
92308: PUSH
92309: LD_INT 0
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 0
92318: PUSH
92319: LD_INT 1
92321: NEG
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 1
92329: PUSH
92330: LD_INT 0
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 1
92339: PUSH
92340: LD_INT 1
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 0
92349: PUSH
92350: LD_INT 1
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 1
92359: NEG
92360: PUSH
92361: LD_INT 0
92363: PUSH
92364: EMPTY
92365: LIST
92366: LIST
92367: PUSH
92368: LD_INT 1
92370: NEG
92371: PUSH
92372: LD_INT 1
92374: NEG
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 1
92382: NEG
92383: PUSH
92384: LD_INT 2
92386: NEG
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 0
92394: PUSH
92395: LD_INT 2
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 1
92405: PUSH
92406: LD_INT 1
92408: NEG
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 2
92416: PUSH
92417: LD_INT 0
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 2
92426: PUSH
92427: LD_INT 1
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 2
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: NEG
92457: PUSH
92458: LD_INT 1
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 2
92467: NEG
92468: PUSH
92469: LD_INT 0
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 2
92478: NEG
92479: PUSH
92480: LD_INT 1
92482: NEG
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: PUSH
92488: LD_INT 1
92490: NEG
92491: PUSH
92492: LD_INT 3
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 0
92502: PUSH
92503: LD_INT 3
92505: NEG
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 1
92513: PUSH
92514: LD_INT 2
92516: NEG
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 2
92524: PUSH
92525: LD_INT 1
92527: NEG
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 3
92535: PUSH
92536: LD_INT 0
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 3
92545: PUSH
92546: LD_INT 1
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 1
92555: PUSH
92556: LD_INT 3
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 0
92565: PUSH
92566: LD_INT 3
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 1
92575: NEG
92576: PUSH
92577: LD_INT 2
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 2
92586: NEG
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: NEG
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 3
92608: NEG
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: LIST
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92649: LD_ADDR_VAR 0 44
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: LD_INT 0
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: LD_INT 0
92666: PUSH
92667: LD_INT 1
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 1
92677: PUSH
92678: LD_INT 0
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 1
92687: PUSH
92688: LD_INT 1
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: LD_INT 0
92697: PUSH
92698: LD_INT 1
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 1
92707: NEG
92708: PUSH
92709: LD_INT 0
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 1
92718: NEG
92719: PUSH
92720: LD_INT 1
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 1
92730: NEG
92731: PUSH
92732: LD_INT 2
92734: NEG
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 1
92742: PUSH
92743: LD_INT 1
92745: NEG
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 2
92753: PUSH
92754: LD_INT 0
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 2
92763: PUSH
92764: LD_INT 1
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 2
92773: PUSH
92774: LD_INT 2
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 1
92783: PUSH
92784: LD_INT 2
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 1
92793: NEG
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 2
92804: NEG
92805: PUSH
92806: LD_INT 0
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 2
92815: NEG
92816: PUSH
92817: LD_INT 1
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 2
92827: NEG
92828: PUSH
92829: LD_INT 2
92831: NEG
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 2
92839: NEG
92840: PUSH
92841: LD_INT 3
92843: NEG
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 2
92851: PUSH
92852: LD_INT 1
92854: NEG
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: PUSH
92860: LD_INT 3
92862: PUSH
92863: LD_INT 0
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 3
92872: PUSH
92873: LD_INT 1
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 3
92882: PUSH
92883: LD_INT 2
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 3
92892: PUSH
92893: LD_INT 3
92895: PUSH
92896: EMPTY
92897: LIST
92898: LIST
92899: PUSH
92900: LD_INT 2
92902: PUSH
92903: LD_INT 3
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: LD_INT 2
92912: NEG
92913: PUSH
92914: LD_INT 1
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PUSH
92921: LD_INT 3
92923: NEG
92924: PUSH
92925: LD_INT 0
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: LD_INT 3
92934: NEG
92935: PUSH
92936: LD_INT 1
92938: NEG
92939: PUSH
92940: EMPTY
92941: LIST
92942: LIST
92943: PUSH
92944: LD_INT 3
92946: NEG
92947: PUSH
92948: LD_INT 2
92950: NEG
92951: PUSH
92952: EMPTY
92953: LIST
92954: LIST
92955: PUSH
92956: LD_INT 3
92958: NEG
92959: PUSH
92960: LD_INT 3
92962: NEG
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92999: LD_ADDR_VAR 0 45
93003: PUSH
93004: LD_INT 0
93006: PUSH
93007: LD_INT 0
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 0
93016: PUSH
93017: LD_INT 1
93019: NEG
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 1
93027: PUSH
93028: LD_INT 0
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 1
93037: PUSH
93038: LD_INT 1
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: LD_INT 0
93047: PUSH
93048: LD_INT 1
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 1
93057: NEG
93058: PUSH
93059: LD_INT 0
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 1
93068: NEG
93069: PUSH
93070: LD_INT 1
93072: NEG
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: LD_INT 2
93084: NEG
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_INT 2
93095: NEG
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 1
93103: PUSH
93104: LD_INT 1
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 2
93114: PUSH
93115: LD_INT 1
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 2
93124: PUSH
93125: LD_INT 2
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 1
93134: PUSH
93135: LD_INT 2
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 0
93144: PUSH
93145: LD_INT 2
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 1
93154: NEG
93155: PUSH
93156: LD_INT 1
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: PUSH
93163: LD_INT 2
93165: NEG
93166: PUSH
93167: LD_INT 1
93169: NEG
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 2
93177: NEG
93178: PUSH
93179: LD_INT 2
93181: NEG
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: PUSH
93187: LD_INT 2
93189: NEG
93190: PUSH
93191: LD_INT 3
93193: NEG
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: PUSH
93199: LD_INT 1
93201: NEG
93202: PUSH
93203: LD_INT 3
93205: NEG
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 0
93213: PUSH
93214: LD_INT 3
93216: NEG
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: PUSH
93222: LD_INT 1
93224: PUSH
93225: LD_INT 2
93227: NEG
93228: PUSH
93229: EMPTY
93230: LIST
93231: LIST
93232: PUSH
93233: LD_INT 3
93235: PUSH
93236: LD_INT 2
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 3
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 2
93255: PUSH
93256: LD_INT 3
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: PUSH
93263: LD_INT 1
93265: PUSH
93266: LD_INT 3
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 0
93275: PUSH
93276: LD_INT 3
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 1
93285: NEG
93286: PUSH
93287: LD_INT 2
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 3
93296: NEG
93297: PUSH
93298: LD_INT 2
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 3
93308: NEG
93309: PUSH
93310: LD_INT 3
93312: NEG
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93349: LD_ADDR_VAR 0 46
93353: PUSH
93354: LD_INT 0
93356: PUSH
93357: LD_INT 0
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 0
93366: PUSH
93367: LD_INT 1
93369: NEG
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: LD_INT 1
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 1
93387: PUSH
93388: LD_INT 1
93390: PUSH
93391: EMPTY
93392: LIST
93393: LIST
93394: PUSH
93395: LD_INT 0
93397: PUSH
93398: LD_INT 1
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 1
93407: NEG
93408: PUSH
93409: LD_INT 0
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: LD_INT 1
93418: NEG
93419: PUSH
93420: LD_INT 1
93422: NEG
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: LD_INT 1
93430: NEG
93431: PUSH
93432: LD_INT 2
93434: NEG
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 0
93442: PUSH
93443: LD_INT 2
93445: NEG
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: PUSH
93451: LD_INT 1
93453: PUSH
93454: LD_INT 1
93456: NEG
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 2
93464: PUSH
93465: LD_INT 0
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 2
93474: PUSH
93475: LD_INT 1
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: LD_INT 1
93484: PUSH
93485: LD_INT 2
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PUSH
93492: LD_INT 0
93494: PUSH
93495: LD_INT 2
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 1
93504: NEG
93505: PUSH
93506: LD_INT 1
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PUSH
93513: LD_INT 2
93515: NEG
93516: PUSH
93517: LD_INT 0
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 2
93526: NEG
93527: PUSH
93528: LD_INT 1
93530: NEG
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 1
93538: NEG
93539: PUSH
93540: LD_INT 3
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 0
93550: PUSH
93551: LD_INT 3
93553: NEG
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PUSH
93559: LD_INT 1
93561: PUSH
93562: LD_INT 2
93564: NEG
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 2
93572: PUSH
93573: LD_INT 1
93575: NEG
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 3
93583: PUSH
93584: LD_INT 0
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 3
93593: PUSH
93594: LD_INT 1
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 1
93603: PUSH
93604: LD_INT 3
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 0
93613: PUSH
93614: LD_INT 3
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 1
93623: NEG
93624: PUSH
93625: LD_INT 2
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: PUSH
93632: LD_INT 2
93634: NEG
93635: PUSH
93636: LD_INT 1
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: PUSH
93643: LD_INT 3
93645: NEG
93646: PUSH
93647: LD_INT 0
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 3
93656: NEG
93657: PUSH
93658: LD_INT 1
93660: NEG
93661: PUSH
93662: EMPTY
93663: LIST
93664: LIST
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93697: LD_ADDR_VAR 0 47
93701: PUSH
93702: LD_INT 0
93704: PUSH
93705: LD_INT 0
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: PUSH
93712: LD_INT 0
93714: PUSH
93715: LD_INT 1
93717: NEG
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: PUSH
93723: LD_INT 1
93725: PUSH
93726: LD_INT 0
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: PUSH
93733: LD_INT 1
93735: PUSH
93736: LD_INT 1
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 0
93745: PUSH
93746: LD_INT 1
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 1
93755: NEG
93756: PUSH
93757: LD_INT 0
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 1
93766: NEG
93767: PUSH
93768: LD_INT 1
93770: NEG
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 1
93778: NEG
93779: PUSH
93780: LD_INT 2
93782: NEG
93783: PUSH
93784: EMPTY
93785: LIST
93786: LIST
93787: PUSH
93788: LD_INT 0
93790: PUSH
93791: LD_INT 2
93793: NEG
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: PUSH
93799: LD_INT 1
93801: PUSH
93802: LD_INT 1
93804: NEG
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: PUSH
93810: LD_INT 2
93812: NEG
93813: PUSH
93814: LD_INT 1
93816: NEG
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: PUSH
93822: LD_INT 2
93824: NEG
93825: PUSH
93826: LD_INT 2
93828: NEG
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: LIST
93847: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93848: LD_ADDR_VAR 0 48
93852: PUSH
93853: LD_INT 0
93855: PUSH
93856: LD_INT 0
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: LD_INT 1
93868: NEG
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: PUSH
93874: LD_INT 1
93876: PUSH
93877: LD_INT 0
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: LD_INT 1
93886: PUSH
93887: LD_INT 1
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: LD_INT 0
93896: PUSH
93897: LD_INT 1
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 1
93906: NEG
93907: PUSH
93908: LD_INT 0
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 1
93917: NEG
93918: PUSH
93919: LD_INT 1
93921: NEG
93922: PUSH
93923: EMPTY
93924: LIST
93925: LIST
93926: PUSH
93927: LD_INT 1
93929: NEG
93930: PUSH
93931: LD_INT 2
93933: NEG
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PUSH
93939: LD_INT 0
93941: PUSH
93942: LD_INT 2
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 1
93952: PUSH
93953: LD_INT 1
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 2
93963: PUSH
93964: LD_INT 0
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 2
93973: PUSH
93974: LD_INT 1
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93995: LD_ADDR_VAR 0 49
93999: PUSH
94000: LD_INT 0
94002: PUSH
94003: LD_INT 0
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 0
94012: PUSH
94013: LD_INT 1
94015: NEG
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 1
94023: PUSH
94024: LD_INT 0
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: PUSH
94031: LD_INT 1
94033: PUSH
94034: LD_INT 1
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 0
94043: PUSH
94044: LD_INT 1
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 1
94053: NEG
94054: PUSH
94055: LD_INT 0
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 1
94064: NEG
94065: PUSH
94066: LD_INT 1
94068: NEG
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 1
94076: PUSH
94077: LD_INT 1
94079: NEG
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 2
94087: PUSH
94088: LD_INT 0
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 2
94097: PUSH
94098: LD_INT 1
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: LD_INT 2
94107: PUSH
94108: LD_INT 2
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 1
94117: PUSH
94118: LD_INT 2
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94139: LD_ADDR_VAR 0 50
94143: PUSH
94144: LD_INT 0
94146: PUSH
94147: LD_INT 0
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 0
94156: PUSH
94157: LD_INT 1
94159: NEG
94160: PUSH
94161: EMPTY
94162: LIST
94163: LIST
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: LD_INT 0
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: LD_INT 1
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 0
94187: PUSH
94188: LD_INT 1
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 1
94197: NEG
94198: PUSH
94199: LD_INT 0
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 1
94208: NEG
94209: PUSH
94210: LD_INT 1
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 2
94220: PUSH
94221: LD_INT 1
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 2
94230: PUSH
94231: LD_INT 2
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 1
94240: PUSH
94241: LD_INT 2
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 0
94250: PUSH
94251: LD_INT 2
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 1
94260: NEG
94261: PUSH
94262: LD_INT 1
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94283: LD_ADDR_VAR 0 51
94287: PUSH
94288: LD_INT 0
94290: PUSH
94291: LD_INT 0
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: LD_INT 0
94300: PUSH
94301: LD_INT 1
94303: NEG
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PUSH
94309: LD_INT 1
94311: PUSH
94312: LD_INT 0
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: LD_INT 1
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 0
94331: PUSH
94332: LD_INT 1
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 1
94341: NEG
94342: PUSH
94343: LD_INT 0
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 1
94352: NEG
94353: PUSH
94354: LD_INT 1
94356: NEG
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 1
94364: PUSH
94365: LD_INT 2
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 0
94374: PUSH
94375: LD_INT 2
94377: PUSH
94378: EMPTY
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 1
94384: NEG
94385: PUSH
94386: LD_INT 1
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 2
94395: NEG
94396: PUSH
94397: LD_INT 0
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 2
94406: NEG
94407: PUSH
94408: LD_INT 1
94410: NEG
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: EMPTY
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94430: LD_ADDR_VAR 0 52
94434: PUSH
94435: LD_INT 0
94437: PUSH
94438: LD_INT 0
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 0
94447: PUSH
94448: LD_INT 1
94450: NEG
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 1
94458: PUSH
94459: LD_INT 0
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 1
94468: PUSH
94469: LD_INT 1
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 0
94478: PUSH
94479: LD_INT 1
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: NEG
94489: PUSH
94490: LD_INT 0
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 1
94499: NEG
94500: PUSH
94501: LD_INT 1
94503: NEG
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 1
94511: NEG
94512: PUSH
94513: LD_INT 2
94515: NEG
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: LD_INT 1
94523: NEG
94524: PUSH
94525: LD_INT 1
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 2
94534: NEG
94535: PUSH
94536: LD_INT 0
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 2
94545: NEG
94546: PUSH
94547: LD_INT 1
94549: NEG
94550: PUSH
94551: EMPTY
94552: LIST
94553: LIST
94554: PUSH
94555: LD_INT 2
94557: NEG
94558: PUSH
94559: LD_INT 2
94561: NEG
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94581: LD_ADDR_VAR 0 53
94585: PUSH
94586: LD_INT 0
94588: PUSH
94589: LD_INT 0
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 0
94598: PUSH
94599: LD_INT 1
94601: NEG
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: PUSH
94607: LD_INT 1
94609: PUSH
94610: LD_INT 0
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 1
94619: PUSH
94620: LD_INT 1
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 0
94629: PUSH
94630: LD_INT 1
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 1
94639: NEG
94640: PUSH
94641: LD_INT 0
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 1
94650: NEG
94651: PUSH
94652: LD_INT 1
94654: NEG
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 1
94662: NEG
94663: PUSH
94664: LD_INT 2
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: LD_INT 2
94677: NEG
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 1
94685: PUSH
94686: LD_INT 1
94688: NEG
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 2
94696: PUSH
94697: LD_INT 0
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: LD_INT 1
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: LD_INT 2
94716: PUSH
94717: LD_INT 2
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 1
94726: PUSH
94727: LD_INT 2
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 0
94736: PUSH
94737: LD_INT 2
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 1
94746: NEG
94747: PUSH
94748: LD_INT 1
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 2
94757: NEG
94758: PUSH
94759: LD_INT 0
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: LD_INT 2
94768: NEG
94769: PUSH
94770: LD_INT 1
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 2
94780: NEG
94781: PUSH
94782: LD_INT 2
94784: NEG
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94811: LD_ADDR_VAR 0 54
94815: PUSH
94816: LD_INT 0
94818: PUSH
94819: LD_INT 0
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 0
94828: PUSH
94829: LD_INT 1
94831: NEG
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 1
94839: PUSH
94840: LD_INT 0
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 1
94849: PUSH
94850: LD_INT 1
94852: PUSH
94853: EMPTY
94854: LIST
94855: LIST
94856: PUSH
94857: LD_INT 0
94859: PUSH
94860: LD_INT 1
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: PUSH
94867: LD_INT 1
94869: NEG
94870: PUSH
94871: LD_INT 0
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 1
94880: NEG
94881: PUSH
94882: LD_INT 1
94884: NEG
94885: PUSH
94886: EMPTY
94887: LIST
94888: LIST
94889: PUSH
94890: LD_INT 1
94892: NEG
94893: PUSH
94894: LD_INT 2
94896: NEG
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 0
94904: PUSH
94905: LD_INT 2
94907: NEG
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 1
94915: PUSH
94916: LD_INT 1
94918: NEG
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 2
94926: PUSH
94927: LD_INT 0
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 2
94936: PUSH
94937: LD_INT 1
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 2
94946: PUSH
94947: LD_INT 2
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PUSH
94954: LD_INT 1
94956: PUSH
94957: LD_INT 2
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PUSH
94964: LD_INT 0
94966: PUSH
94967: LD_INT 2
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 1
94976: NEG
94977: PUSH
94978: LD_INT 1
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 2
94987: NEG
94988: PUSH
94989: LD_INT 0
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 2
94998: NEG
94999: PUSH
95000: LD_INT 1
95002: NEG
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 2
95010: NEG
95011: PUSH
95012: LD_INT 2
95014: NEG
95015: PUSH
95016: EMPTY
95017: LIST
95018: LIST
95019: PUSH
95020: EMPTY
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95041: LD_ADDR_VAR 0 55
95045: PUSH
95046: LD_INT 0
95048: PUSH
95049: LD_INT 0
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 0
95058: PUSH
95059: LD_INT 1
95061: NEG
95062: PUSH
95063: EMPTY
95064: LIST
95065: LIST
95066: PUSH
95067: LD_INT 1
95069: PUSH
95070: LD_INT 0
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 1
95079: PUSH
95080: LD_INT 1
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: PUSH
95087: LD_INT 0
95089: PUSH
95090: LD_INT 1
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 1
95099: NEG
95100: PUSH
95101: LD_INT 0
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 1
95110: NEG
95111: PUSH
95112: LD_INT 1
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 1
95122: NEG
95123: PUSH
95124: LD_INT 2
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 0
95134: PUSH
95135: LD_INT 2
95137: NEG
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 1
95145: PUSH
95146: LD_INT 1
95148: NEG
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PUSH
95154: LD_INT 2
95156: PUSH
95157: LD_INT 0
95159: PUSH
95160: EMPTY
95161: LIST
95162: LIST
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: LD_INT 1
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: PUSH
95174: LD_INT 2
95176: PUSH
95177: LD_INT 2
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 1
95186: PUSH
95187: LD_INT 2
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 0
95196: PUSH
95197: LD_INT 2
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 1
95206: NEG
95207: PUSH
95208: LD_INT 1
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 2
95217: NEG
95218: PUSH
95219: LD_INT 0
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 2
95228: NEG
95229: PUSH
95230: LD_INT 1
95232: NEG
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 2
95240: NEG
95241: PUSH
95242: LD_INT 2
95244: NEG
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95271: LD_ADDR_VAR 0 56
95275: PUSH
95276: LD_INT 0
95278: PUSH
95279: LD_INT 0
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: PUSH
95286: LD_INT 0
95288: PUSH
95289: LD_INT 1
95291: NEG
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 1
95299: PUSH
95300: LD_INT 0
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 1
95309: PUSH
95310: LD_INT 1
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 0
95319: PUSH
95320: LD_INT 1
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 1
95329: NEG
95330: PUSH
95331: LD_INT 0
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 1
95340: NEG
95341: PUSH
95342: LD_INT 1
95344: NEG
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 1
95352: NEG
95353: PUSH
95354: LD_INT 2
95356: NEG
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 0
95364: PUSH
95365: LD_INT 2
95367: NEG
95368: PUSH
95369: EMPTY
95370: LIST
95371: LIST
95372: PUSH
95373: LD_INT 1
95375: PUSH
95376: LD_INT 1
95378: NEG
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: PUSH
95384: LD_INT 2
95386: PUSH
95387: LD_INT 0
95389: PUSH
95390: EMPTY
95391: LIST
95392: LIST
95393: PUSH
95394: LD_INT 2
95396: PUSH
95397: LD_INT 1
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 2
95406: PUSH
95407: LD_INT 2
95409: PUSH
95410: EMPTY
95411: LIST
95412: LIST
95413: PUSH
95414: LD_INT 1
95416: PUSH
95417: LD_INT 2
95419: PUSH
95420: EMPTY
95421: LIST
95422: LIST
95423: PUSH
95424: LD_INT 0
95426: PUSH
95427: LD_INT 2
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: PUSH
95434: LD_INT 1
95436: NEG
95437: PUSH
95438: LD_INT 1
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: PUSH
95445: LD_INT 2
95447: NEG
95448: PUSH
95449: LD_INT 0
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 2
95458: NEG
95459: PUSH
95460: LD_INT 1
95462: NEG
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 2
95470: NEG
95471: PUSH
95472: LD_INT 2
95474: NEG
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95501: LD_ADDR_VAR 0 57
95505: PUSH
95506: LD_INT 0
95508: PUSH
95509: LD_INT 0
95511: PUSH
95512: EMPTY
95513: LIST
95514: LIST
95515: PUSH
95516: LD_INT 0
95518: PUSH
95519: LD_INT 1
95521: NEG
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 1
95529: PUSH
95530: LD_INT 0
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 1
95539: PUSH
95540: LD_INT 1
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 0
95549: PUSH
95550: LD_INT 1
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 1
95559: NEG
95560: PUSH
95561: LD_INT 0
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 1
95570: NEG
95571: PUSH
95572: LD_INT 1
95574: NEG
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 1
95582: NEG
95583: PUSH
95584: LD_INT 2
95586: NEG
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 0
95594: PUSH
95595: LD_INT 2
95597: NEG
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 1
95605: PUSH
95606: LD_INT 1
95608: NEG
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 2
95616: PUSH
95617: LD_INT 0
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 2
95626: PUSH
95627: LD_INT 1
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: LD_INT 2
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 1
95646: PUSH
95647: LD_INT 2
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 0
95656: PUSH
95657: LD_INT 2
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 1
95666: NEG
95667: PUSH
95668: LD_INT 1
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 2
95677: NEG
95678: PUSH
95679: LD_INT 0
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: PUSH
95686: LD_INT 2
95688: NEG
95689: PUSH
95690: LD_INT 1
95692: NEG
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PUSH
95698: LD_INT 2
95700: NEG
95701: PUSH
95702: LD_INT 2
95704: NEG
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95731: LD_ADDR_VAR 0 58
95735: PUSH
95736: LD_INT 0
95738: PUSH
95739: LD_INT 0
95741: PUSH
95742: EMPTY
95743: LIST
95744: LIST
95745: PUSH
95746: LD_INT 0
95748: PUSH
95749: LD_INT 1
95751: NEG
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 1
95759: PUSH
95760: LD_INT 0
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 1
95769: PUSH
95770: LD_INT 1
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 0
95779: PUSH
95780: LD_INT 1
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 1
95789: NEG
95790: PUSH
95791: LD_INT 0
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: LD_INT 1
95800: NEG
95801: PUSH
95802: LD_INT 1
95804: NEG
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: LD_INT 1
95812: NEG
95813: PUSH
95814: LD_INT 2
95816: NEG
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: LD_INT 2
95827: NEG
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 1
95835: PUSH
95836: LD_INT 1
95838: NEG
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: LD_INT 2
95846: PUSH
95847: LD_INT 0
95849: PUSH
95850: EMPTY
95851: LIST
95852: LIST
95853: PUSH
95854: LD_INT 2
95856: PUSH
95857: LD_INT 1
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 2
95866: PUSH
95867: LD_INT 2
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: LD_INT 1
95876: PUSH
95877: LD_INT 2
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: PUSH
95884: LD_INT 0
95886: PUSH
95887: LD_INT 2
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 1
95896: NEG
95897: PUSH
95898: LD_INT 1
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 2
95907: NEG
95908: PUSH
95909: LD_INT 0
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 2
95918: NEG
95919: PUSH
95920: LD_INT 1
95922: NEG
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 2
95930: NEG
95931: PUSH
95932: LD_INT 2
95934: NEG
95935: PUSH
95936: EMPTY
95937: LIST
95938: LIST
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95961: LD_ADDR_VAR 0 59
95965: PUSH
95966: LD_INT 0
95968: PUSH
95969: LD_INT 0
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 0
95978: PUSH
95979: LD_INT 1
95981: NEG
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 1
95989: PUSH
95990: LD_INT 0
95992: PUSH
95993: EMPTY
95994: LIST
95995: LIST
95996: PUSH
95997: LD_INT 1
95999: PUSH
96000: LD_INT 1
96002: PUSH
96003: EMPTY
96004: LIST
96005: LIST
96006: PUSH
96007: LD_INT 0
96009: PUSH
96010: LD_INT 1
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 1
96019: NEG
96020: PUSH
96021: LD_INT 0
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 1
96030: NEG
96031: PUSH
96032: LD_INT 1
96034: NEG
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96049: LD_ADDR_VAR 0 60
96053: PUSH
96054: LD_INT 0
96056: PUSH
96057: LD_INT 0
96059: PUSH
96060: EMPTY
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 0
96066: PUSH
96067: LD_INT 1
96069: NEG
96070: PUSH
96071: EMPTY
96072: LIST
96073: LIST
96074: PUSH
96075: LD_INT 1
96077: PUSH
96078: LD_INT 0
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 1
96087: PUSH
96088: LD_INT 1
96090: PUSH
96091: EMPTY
96092: LIST
96093: LIST
96094: PUSH
96095: LD_INT 0
96097: PUSH
96098: LD_INT 1
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: LD_INT 1
96107: NEG
96108: PUSH
96109: LD_INT 0
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: PUSH
96116: LD_INT 1
96118: NEG
96119: PUSH
96120: LD_INT 1
96122: NEG
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96137: LD_ADDR_VAR 0 61
96141: PUSH
96142: LD_INT 0
96144: PUSH
96145: LD_INT 0
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 0
96154: PUSH
96155: LD_INT 1
96157: NEG
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 1
96165: PUSH
96166: LD_INT 0
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 1
96175: PUSH
96176: LD_INT 1
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: LD_INT 0
96185: PUSH
96186: LD_INT 1
96188: PUSH
96189: EMPTY
96190: LIST
96191: LIST
96192: PUSH
96193: LD_INT 1
96195: NEG
96196: PUSH
96197: LD_INT 0
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 1
96206: NEG
96207: PUSH
96208: LD_INT 1
96210: NEG
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96225: LD_ADDR_VAR 0 62
96229: PUSH
96230: LD_INT 0
96232: PUSH
96233: LD_INT 0
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 0
96242: PUSH
96243: LD_INT 1
96245: NEG
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: LD_INT 1
96253: PUSH
96254: LD_INT 0
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 1
96263: PUSH
96264: LD_INT 1
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: LD_INT 0
96273: PUSH
96274: LD_INT 1
96276: PUSH
96277: EMPTY
96278: LIST
96279: LIST
96280: PUSH
96281: LD_INT 1
96283: NEG
96284: PUSH
96285: LD_INT 0
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: LD_INT 1
96294: NEG
96295: PUSH
96296: LD_INT 1
96298: NEG
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: EMPTY
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96313: LD_ADDR_VAR 0 63
96317: PUSH
96318: LD_INT 0
96320: PUSH
96321: LD_INT 0
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: LD_INT 0
96330: PUSH
96331: LD_INT 1
96333: NEG
96334: PUSH
96335: EMPTY
96336: LIST
96337: LIST
96338: PUSH
96339: LD_INT 1
96341: PUSH
96342: LD_INT 0
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: PUSH
96349: LD_INT 1
96351: PUSH
96352: LD_INT 1
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 0
96361: PUSH
96362: LD_INT 1
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: PUSH
96369: LD_INT 1
96371: NEG
96372: PUSH
96373: LD_INT 0
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: PUSH
96380: LD_INT 1
96382: NEG
96383: PUSH
96384: LD_INT 1
96386: NEG
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96401: LD_ADDR_VAR 0 64
96405: PUSH
96406: LD_INT 0
96408: PUSH
96409: LD_INT 0
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 0
96418: PUSH
96419: LD_INT 1
96421: NEG
96422: PUSH
96423: EMPTY
96424: LIST
96425: LIST
96426: PUSH
96427: LD_INT 1
96429: PUSH
96430: LD_INT 0
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 1
96439: PUSH
96440: LD_INT 1
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: PUSH
96447: LD_INT 0
96449: PUSH
96450: LD_INT 1
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 1
96459: NEG
96460: PUSH
96461: LD_INT 0
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 1
96470: NEG
96471: PUSH
96472: LD_INT 1
96474: NEG
96475: PUSH
96476: EMPTY
96477: LIST
96478: LIST
96479: PUSH
96480: EMPTY
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: ST_TO_ADDR
// end ; 1 :
96489: GO 102386
96491: LD_INT 1
96493: DOUBLE
96494: EQUAL
96495: IFTRUE 96499
96497: GO 99122
96499: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96500: LD_ADDR_VAR 0 11
96504: PUSH
96505: LD_INT 1
96507: NEG
96508: PUSH
96509: LD_INT 3
96511: NEG
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 0
96519: PUSH
96520: LD_INT 3
96522: NEG
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 1
96530: PUSH
96531: LD_INT 2
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: LIST
96543: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96544: LD_ADDR_VAR 0 12
96548: PUSH
96549: LD_INT 2
96551: PUSH
96552: LD_INT 1
96554: NEG
96555: PUSH
96556: EMPTY
96557: LIST
96558: LIST
96559: PUSH
96560: LD_INT 3
96562: PUSH
96563: LD_INT 0
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: PUSH
96570: LD_INT 3
96572: PUSH
96573: LD_INT 1
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: LIST
96584: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96585: LD_ADDR_VAR 0 13
96589: PUSH
96590: LD_INT 3
96592: PUSH
96593: LD_INT 2
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 3
96602: PUSH
96603: LD_INT 3
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 2
96612: PUSH
96613: LD_INT 3
96615: PUSH
96616: EMPTY
96617: LIST
96618: LIST
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: LIST
96624: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96625: LD_ADDR_VAR 0 14
96629: PUSH
96630: LD_INT 1
96632: PUSH
96633: LD_INT 3
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 0
96642: PUSH
96643: LD_INT 3
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: LD_INT 1
96652: NEG
96653: PUSH
96654: LD_INT 2
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: LIST
96665: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96666: LD_ADDR_VAR 0 15
96670: PUSH
96671: LD_INT 2
96673: NEG
96674: PUSH
96675: LD_INT 1
96677: PUSH
96678: EMPTY
96679: LIST
96680: LIST
96681: PUSH
96682: LD_INT 3
96684: NEG
96685: PUSH
96686: LD_INT 0
96688: PUSH
96689: EMPTY
96690: LIST
96691: LIST
96692: PUSH
96693: LD_INT 3
96695: NEG
96696: PUSH
96697: LD_INT 1
96699: NEG
96700: PUSH
96701: EMPTY
96702: LIST
96703: LIST
96704: PUSH
96705: EMPTY
96706: LIST
96707: LIST
96708: LIST
96709: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96710: LD_ADDR_VAR 0 16
96714: PUSH
96715: LD_INT 2
96717: NEG
96718: PUSH
96719: LD_INT 3
96721: NEG
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 3
96729: NEG
96730: PUSH
96731: LD_INT 2
96733: NEG
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: LD_INT 3
96741: NEG
96742: PUSH
96743: LD_INT 3
96745: NEG
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: LIST
96755: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96756: LD_ADDR_VAR 0 17
96760: PUSH
96761: LD_INT 1
96763: NEG
96764: PUSH
96765: LD_INT 3
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 0
96775: PUSH
96776: LD_INT 3
96778: NEG
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 1
96786: PUSH
96787: LD_INT 2
96789: NEG
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: LIST
96799: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96800: LD_ADDR_VAR 0 18
96804: PUSH
96805: LD_INT 2
96807: PUSH
96808: LD_INT 1
96810: NEG
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 3
96818: PUSH
96819: LD_INT 0
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 3
96828: PUSH
96829: LD_INT 1
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: LIST
96840: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96841: LD_ADDR_VAR 0 19
96845: PUSH
96846: LD_INT 3
96848: PUSH
96849: LD_INT 2
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 3
96858: PUSH
96859: LD_INT 3
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 2
96868: PUSH
96869: LD_INT 3
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: LIST
96880: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96881: LD_ADDR_VAR 0 20
96885: PUSH
96886: LD_INT 1
96888: PUSH
96889: LD_INT 3
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: LD_INT 3
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 1
96908: NEG
96909: PUSH
96910: LD_INT 2
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: LIST
96921: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96922: LD_ADDR_VAR 0 21
96926: PUSH
96927: LD_INT 2
96929: NEG
96930: PUSH
96931: LD_INT 1
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 3
96940: NEG
96941: PUSH
96942: LD_INT 0
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: PUSH
96949: LD_INT 3
96951: NEG
96952: PUSH
96953: LD_INT 1
96955: NEG
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: LIST
96965: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96966: LD_ADDR_VAR 0 22
96970: PUSH
96971: LD_INT 2
96973: NEG
96974: PUSH
96975: LD_INT 3
96977: NEG
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 3
96985: NEG
96986: PUSH
96987: LD_INT 2
96989: NEG
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 3
96997: NEG
96998: PUSH
96999: LD_INT 3
97001: NEG
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: LIST
97011: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
97012: LD_ADDR_VAR 0 23
97016: PUSH
97017: LD_INT 0
97019: PUSH
97020: LD_INT 3
97022: NEG
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: PUSH
97028: LD_INT 1
97030: NEG
97031: PUSH
97032: LD_INT 4
97034: NEG
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: LD_INT 1
97042: PUSH
97043: LD_INT 3
97045: NEG
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: EMPTY
97052: LIST
97053: LIST
97054: LIST
97055: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
97056: LD_ADDR_VAR 0 24
97060: PUSH
97061: LD_INT 3
97063: PUSH
97064: LD_INT 0
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 3
97073: PUSH
97074: LD_INT 1
97076: NEG
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: PUSH
97082: LD_INT 4
97084: PUSH
97085: LD_INT 1
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: LIST
97096: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
97097: LD_ADDR_VAR 0 25
97101: PUSH
97102: LD_INT 3
97104: PUSH
97105: LD_INT 3
97107: PUSH
97108: EMPTY
97109: LIST
97110: LIST
97111: PUSH
97112: LD_INT 4
97114: PUSH
97115: LD_INT 3
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 3
97124: PUSH
97125: LD_INT 4
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: LIST
97136: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97137: LD_ADDR_VAR 0 26
97141: PUSH
97142: LD_INT 0
97144: PUSH
97145: LD_INT 3
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: LD_INT 1
97154: PUSH
97155: LD_INT 4
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 1
97164: NEG
97165: PUSH
97166: LD_INT 3
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: LIST
97177: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97178: LD_ADDR_VAR 0 27
97182: PUSH
97183: LD_INT 3
97185: NEG
97186: PUSH
97187: LD_INT 0
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: LD_INT 3
97196: NEG
97197: PUSH
97198: LD_INT 1
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: LD_INT 4
97207: NEG
97208: PUSH
97209: LD_INT 1
97211: NEG
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: LIST
97221: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
97222: LD_ADDR_VAR 0 28
97226: PUSH
97227: LD_INT 3
97229: NEG
97230: PUSH
97231: LD_INT 3
97233: NEG
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: PUSH
97239: LD_INT 3
97241: NEG
97242: PUSH
97243: LD_INT 4
97245: NEG
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: PUSH
97251: LD_INT 4
97253: NEG
97254: PUSH
97255: LD_INT 3
97257: NEG
97258: PUSH
97259: EMPTY
97260: LIST
97261: LIST
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: LIST
97267: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
97268: LD_ADDR_VAR 0 29
97272: PUSH
97273: LD_INT 1
97275: NEG
97276: PUSH
97277: LD_INT 3
97279: NEG
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 0
97287: PUSH
97288: LD_INT 3
97290: NEG
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 1
97298: PUSH
97299: LD_INT 2
97301: NEG
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 1
97309: NEG
97310: PUSH
97311: LD_INT 4
97313: NEG
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 0
97321: PUSH
97322: LD_INT 4
97324: NEG
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: PUSH
97330: LD_INT 1
97332: PUSH
97333: LD_INT 3
97335: NEG
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: PUSH
97341: LD_INT 1
97343: NEG
97344: PUSH
97345: LD_INT 5
97347: NEG
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: LD_INT 0
97355: PUSH
97356: LD_INT 5
97358: NEG
97359: PUSH
97360: EMPTY
97361: LIST
97362: LIST
97363: PUSH
97364: LD_INT 1
97366: PUSH
97367: LD_INT 4
97369: NEG
97370: PUSH
97371: EMPTY
97372: LIST
97373: LIST
97374: PUSH
97375: LD_INT 1
97377: NEG
97378: PUSH
97379: LD_INT 6
97381: NEG
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: LD_INT 0
97389: PUSH
97390: LD_INT 6
97392: NEG
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: LD_INT 1
97400: PUSH
97401: LD_INT 5
97403: NEG
97404: PUSH
97405: EMPTY
97406: LIST
97407: LIST
97408: PUSH
97409: EMPTY
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
97423: LD_ADDR_VAR 0 30
97427: PUSH
97428: LD_INT 2
97430: PUSH
97431: LD_INT 1
97433: NEG
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: LD_INT 3
97441: PUSH
97442: LD_INT 0
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: PUSH
97449: LD_INT 3
97451: PUSH
97452: LD_INT 1
97454: PUSH
97455: EMPTY
97456: LIST
97457: LIST
97458: PUSH
97459: LD_INT 3
97461: PUSH
97462: LD_INT 1
97464: NEG
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 4
97472: PUSH
97473: LD_INT 0
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 4
97482: PUSH
97483: LD_INT 1
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 4
97492: PUSH
97493: LD_INT 1
97495: NEG
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 5
97503: PUSH
97504: LD_INT 0
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 5
97513: PUSH
97514: LD_INT 1
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 5
97523: PUSH
97524: LD_INT 1
97526: NEG
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: LD_INT 6
97534: PUSH
97535: LD_INT 0
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: PUSH
97542: LD_INT 6
97544: PUSH
97545: LD_INT 1
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
97566: LD_ADDR_VAR 0 31
97570: PUSH
97571: LD_INT 3
97573: PUSH
97574: LD_INT 2
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 3
97583: PUSH
97584: LD_INT 3
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 2
97593: PUSH
97594: LD_INT 3
97596: PUSH
97597: EMPTY
97598: LIST
97599: LIST
97600: PUSH
97601: LD_INT 4
97603: PUSH
97604: LD_INT 3
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 4
97613: PUSH
97614: LD_INT 4
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PUSH
97621: LD_INT 3
97623: PUSH
97624: LD_INT 4
97626: PUSH
97627: EMPTY
97628: LIST
97629: LIST
97630: PUSH
97631: LD_INT 5
97633: PUSH
97634: LD_INT 4
97636: PUSH
97637: EMPTY
97638: LIST
97639: LIST
97640: PUSH
97641: LD_INT 5
97643: PUSH
97644: LD_INT 5
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 4
97653: PUSH
97654: LD_INT 5
97656: PUSH
97657: EMPTY
97658: LIST
97659: LIST
97660: PUSH
97661: LD_INT 6
97663: PUSH
97664: LD_INT 5
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: PUSH
97671: LD_INT 6
97673: PUSH
97674: LD_INT 6
97676: PUSH
97677: EMPTY
97678: LIST
97679: LIST
97680: PUSH
97681: LD_INT 5
97683: PUSH
97684: LD_INT 6
97686: PUSH
97687: EMPTY
97688: LIST
97689: LIST
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
97705: LD_ADDR_VAR 0 32
97709: PUSH
97710: LD_INT 1
97712: PUSH
97713: LD_INT 3
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: LD_INT 0
97722: PUSH
97723: LD_INT 3
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: LD_INT 1
97732: NEG
97733: PUSH
97734: LD_INT 2
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: PUSH
97741: LD_INT 1
97743: PUSH
97744: LD_INT 4
97746: PUSH
97747: EMPTY
97748: LIST
97749: LIST
97750: PUSH
97751: LD_INT 0
97753: PUSH
97754: LD_INT 4
97756: PUSH
97757: EMPTY
97758: LIST
97759: LIST
97760: PUSH
97761: LD_INT 1
97763: NEG
97764: PUSH
97765: LD_INT 3
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: PUSH
97772: LD_INT 1
97774: PUSH
97775: LD_INT 5
97777: PUSH
97778: EMPTY
97779: LIST
97780: LIST
97781: PUSH
97782: LD_INT 0
97784: PUSH
97785: LD_INT 5
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: PUSH
97792: LD_INT 1
97794: NEG
97795: PUSH
97796: LD_INT 4
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: PUSH
97803: LD_INT 1
97805: PUSH
97806: LD_INT 6
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: PUSH
97813: LD_INT 0
97815: PUSH
97816: LD_INT 6
97818: PUSH
97819: EMPTY
97820: LIST
97821: LIST
97822: PUSH
97823: LD_INT 1
97825: NEG
97826: PUSH
97827: LD_INT 5
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97848: LD_ADDR_VAR 0 33
97852: PUSH
97853: LD_INT 2
97855: NEG
97856: PUSH
97857: LD_INT 1
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: PUSH
97864: LD_INT 3
97866: NEG
97867: PUSH
97868: LD_INT 0
97870: PUSH
97871: EMPTY
97872: LIST
97873: LIST
97874: PUSH
97875: LD_INT 3
97877: NEG
97878: PUSH
97879: LD_INT 1
97881: NEG
97882: PUSH
97883: EMPTY
97884: LIST
97885: LIST
97886: PUSH
97887: LD_INT 3
97889: NEG
97890: PUSH
97891: LD_INT 1
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 4
97900: NEG
97901: PUSH
97902: LD_INT 0
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: PUSH
97909: LD_INT 4
97911: NEG
97912: PUSH
97913: LD_INT 1
97915: NEG
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PUSH
97921: LD_INT 4
97923: NEG
97924: PUSH
97925: LD_INT 1
97927: PUSH
97928: EMPTY
97929: LIST
97930: LIST
97931: PUSH
97932: LD_INT 5
97934: NEG
97935: PUSH
97936: LD_INT 0
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PUSH
97943: LD_INT 5
97945: NEG
97946: PUSH
97947: LD_INT 1
97949: NEG
97950: PUSH
97951: EMPTY
97952: LIST
97953: LIST
97954: PUSH
97955: LD_INT 5
97957: NEG
97958: PUSH
97959: LD_INT 1
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: PUSH
97966: LD_INT 6
97968: NEG
97969: PUSH
97970: LD_INT 0
97972: PUSH
97973: EMPTY
97974: LIST
97975: LIST
97976: PUSH
97977: LD_INT 6
97979: NEG
97980: PUSH
97981: LD_INT 1
97983: NEG
97984: PUSH
97985: EMPTY
97986: LIST
97987: LIST
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: LIST
97997: LIST
97998: LIST
97999: LIST
98000: LIST
98001: LIST
98002: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
98003: LD_ADDR_VAR 0 34
98007: PUSH
98008: LD_INT 2
98010: NEG
98011: PUSH
98012: LD_INT 3
98014: NEG
98015: PUSH
98016: EMPTY
98017: LIST
98018: LIST
98019: PUSH
98020: LD_INT 3
98022: NEG
98023: PUSH
98024: LD_INT 2
98026: NEG
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: PUSH
98032: LD_INT 3
98034: NEG
98035: PUSH
98036: LD_INT 3
98038: NEG
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: LD_INT 3
98046: NEG
98047: PUSH
98048: LD_INT 4
98050: NEG
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 4
98058: NEG
98059: PUSH
98060: LD_INT 3
98062: NEG
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: PUSH
98068: LD_INT 4
98070: NEG
98071: PUSH
98072: LD_INT 4
98074: NEG
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: PUSH
98080: LD_INT 4
98082: NEG
98083: PUSH
98084: LD_INT 5
98086: NEG
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 5
98094: NEG
98095: PUSH
98096: LD_INT 4
98098: NEG
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_INT 5
98106: NEG
98107: PUSH
98108: LD_INT 5
98110: NEG
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 5
98118: NEG
98119: PUSH
98120: LD_INT 6
98122: NEG
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 6
98130: NEG
98131: PUSH
98132: LD_INT 5
98134: NEG
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 6
98142: NEG
98143: PUSH
98144: LD_INT 6
98146: NEG
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: PUSH
98152: EMPTY
98153: LIST
98154: LIST
98155: LIST
98156: LIST
98157: LIST
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: LIST
98163: LIST
98164: LIST
98165: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98166: LD_ADDR_VAR 0 41
98170: PUSH
98171: LD_INT 0
98173: PUSH
98174: LD_INT 2
98176: NEG
98177: PUSH
98178: EMPTY
98179: LIST
98180: LIST
98181: PUSH
98182: LD_INT 1
98184: NEG
98185: PUSH
98186: LD_INT 3
98188: NEG
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PUSH
98194: LD_INT 1
98196: PUSH
98197: LD_INT 2
98199: NEG
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: LIST
98209: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
98210: LD_ADDR_VAR 0 42
98214: PUSH
98215: LD_INT 2
98217: PUSH
98218: LD_INT 0
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 2
98227: PUSH
98228: LD_INT 1
98230: NEG
98231: PUSH
98232: EMPTY
98233: LIST
98234: LIST
98235: PUSH
98236: LD_INT 3
98238: PUSH
98239: LD_INT 1
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: LIST
98250: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
98251: LD_ADDR_VAR 0 43
98255: PUSH
98256: LD_INT 2
98258: PUSH
98259: LD_INT 2
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: PUSH
98266: LD_INT 3
98268: PUSH
98269: LD_INT 2
98271: PUSH
98272: EMPTY
98273: LIST
98274: LIST
98275: PUSH
98276: LD_INT 2
98278: PUSH
98279: LD_INT 3
98281: PUSH
98282: EMPTY
98283: LIST
98284: LIST
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: LIST
98290: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
98291: LD_ADDR_VAR 0 44
98295: PUSH
98296: LD_INT 0
98298: PUSH
98299: LD_INT 2
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: PUSH
98306: LD_INT 1
98308: PUSH
98309: LD_INT 3
98311: PUSH
98312: EMPTY
98313: LIST
98314: LIST
98315: PUSH
98316: LD_INT 1
98318: NEG
98319: PUSH
98320: LD_INT 2
98322: PUSH
98323: EMPTY
98324: LIST
98325: LIST
98326: PUSH
98327: EMPTY
98328: LIST
98329: LIST
98330: LIST
98331: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
98332: LD_ADDR_VAR 0 45
98336: PUSH
98337: LD_INT 2
98339: NEG
98340: PUSH
98341: LD_INT 0
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: LD_INT 2
98350: NEG
98351: PUSH
98352: LD_INT 1
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 3
98361: NEG
98362: PUSH
98363: LD_INT 1
98365: NEG
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: EMPTY
98372: LIST
98373: LIST
98374: LIST
98375: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
98376: LD_ADDR_VAR 0 46
98380: PUSH
98381: LD_INT 2
98383: NEG
98384: PUSH
98385: LD_INT 2
98387: NEG
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: PUSH
98393: LD_INT 2
98395: NEG
98396: PUSH
98397: LD_INT 3
98399: NEG
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: PUSH
98405: LD_INT 3
98407: NEG
98408: PUSH
98409: LD_INT 2
98411: NEG
98412: PUSH
98413: EMPTY
98414: LIST
98415: LIST
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: LIST
98421: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
98422: LD_ADDR_VAR 0 47
98426: PUSH
98427: LD_INT 2
98429: NEG
98430: PUSH
98431: LD_INT 3
98433: NEG
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: LD_INT 1
98441: NEG
98442: PUSH
98443: LD_INT 3
98445: NEG
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: PUSH
98451: EMPTY
98452: LIST
98453: LIST
98454: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
98455: LD_ADDR_VAR 0 48
98459: PUSH
98460: LD_INT 1
98462: PUSH
98463: LD_INT 2
98465: NEG
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 2
98473: PUSH
98474: LD_INT 1
98476: NEG
98477: PUSH
98478: EMPTY
98479: LIST
98480: LIST
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
98486: LD_ADDR_VAR 0 49
98490: PUSH
98491: LD_INT 3
98493: PUSH
98494: LD_INT 1
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PUSH
98501: LD_INT 3
98503: PUSH
98504: LD_INT 2
98506: PUSH
98507: EMPTY
98508: LIST
98509: LIST
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
98515: LD_ADDR_VAR 0 50
98519: PUSH
98520: LD_INT 2
98522: PUSH
98523: LD_INT 3
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: PUSH
98530: LD_INT 1
98532: PUSH
98533: LD_INT 3
98535: PUSH
98536: EMPTY
98537: LIST
98538: LIST
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
98544: LD_ADDR_VAR 0 51
98548: PUSH
98549: LD_INT 1
98551: NEG
98552: PUSH
98553: LD_INT 2
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: PUSH
98560: LD_INT 2
98562: NEG
98563: PUSH
98564: LD_INT 1
98566: PUSH
98567: EMPTY
98568: LIST
98569: LIST
98570: PUSH
98571: EMPTY
98572: LIST
98573: LIST
98574: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
98575: LD_ADDR_VAR 0 52
98579: PUSH
98580: LD_INT 3
98582: NEG
98583: PUSH
98584: LD_INT 1
98586: NEG
98587: PUSH
98588: EMPTY
98589: LIST
98590: LIST
98591: PUSH
98592: LD_INT 3
98594: NEG
98595: PUSH
98596: LD_INT 2
98598: NEG
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
98608: LD_ADDR_VAR 0 53
98612: PUSH
98613: LD_INT 1
98615: NEG
98616: PUSH
98617: LD_INT 3
98619: NEG
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PUSH
98625: LD_INT 0
98627: PUSH
98628: LD_INT 3
98630: NEG
98631: PUSH
98632: EMPTY
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 1
98638: PUSH
98639: LD_INT 2
98641: NEG
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PUSH
98647: EMPTY
98648: LIST
98649: LIST
98650: LIST
98651: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
98652: LD_ADDR_VAR 0 54
98656: PUSH
98657: LD_INT 2
98659: PUSH
98660: LD_INT 1
98662: NEG
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PUSH
98668: LD_INT 3
98670: PUSH
98671: LD_INT 0
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 3
98680: PUSH
98681: LD_INT 1
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: EMPTY
98689: LIST
98690: LIST
98691: LIST
98692: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
98693: LD_ADDR_VAR 0 55
98697: PUSH
98698: LD_INT 3
98700: PUSH
98701: LD_INT 2
98703: PUSH
98704: EMPTY
98705: LIST
98706: LIST
98707: PUSH
98708: LD_INT 3
98710: PUSH
98711: LD_INT 3
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PUSH
98718: LD_INT 2
98720: PUSH
98721: LD_INT 3
98723: PUSH
98724: EMPTY
98725: LIST
98726: LIST
98727: PUSH
98728: EMPTY
98729: LIST
98730: LIST
98731: LIST
98732: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
98733: LD_ADDR_VAR 0 56
98737: PUSH
98738: LD_INT 1
98740: PUSH
98741: LD_INT 3
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: LD_INT 0
98750: PUSH
98751: LD_INT 3
98753: PUSH
98754: EMPTY
98755: LIST
98756: LIST
98757: PUSH
98758: LD_INT 1
98760: NEG
98761: PUSH
98762: LD_INT 2
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: LIST
98773: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
98774: LD_ADDR_VAR 0 57
98778: PUSH
98779: LD_INT 2
98781: NEG
98782: PUSH
98783: LD_INT 1
98785: PUSH
98786: EMPTY
98787: LIST
98788: LIST
98789: PUSH
98790: LD_INT 3
98792: NEG
98793: PUSH
98794: LD_INT 0
98796: PUSH
98797: EMPTY
98798: LIST
98799: LIST
98800: PUSH
98801: LD_INT 3
98803: NEG
98804: PUSH
98805: LD_INT 1
98807: NEG
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: LIST
98817: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
98818: LD_ADDR_VAR 0 58
98822: PUSH
98823: LD_INT 2
98825: NEG
98826: PUSH
98827: LD_INT 3
98829: NEG
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 3
98837: NEG
98838: PUSH
98839: LD_INT 2
98841: NEG
98842: PUSH
98843: EMPTY
98844: LIST
98845: LIST
98846: PUSH
98847: LD_INT 3
98849: NEG
98850: PUSH
98851: LD_INT 3
98853: NEG
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: LIST
98863: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98864: LD_ADDR_VAR 0 59
98868: PUSH
98869: LD_INT 1
98871: NEG
98872: PUSH
98873: LD_INT 2
98875: NEG
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_INT 0
98883: PUSH
98884: LD_INT 2
98886: NEG
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 1
98894: PUSH
98895: LD_INT 1
98897: NEG
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PUSH
98903: EMPTY
98904: LIST
98905: LIST
98906: LIST
98907: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98908: LD_ADDR_VAR 0 60
98912: PUSH
98913: LD_INT 1
98915: PUSH
98916: LD_INT 1
98918: NEG
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: PUSH
98924: LD_INT 2
98926: PUSH
98927: LD_INT 0
98929: PUSH
98930: EMPTY
98931: LIST
98932: LIST
98933: PUSH
98934: LD_INT 2
98936: PUSH
98937: LD_INT 1
98939: PUSH
98940: EMPTY
98941: LIST
98942: LIST
98943: PUSH
98944: EMPTY
98945: LIST
98946: LIST
98947: LIST
98948: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98949: LD_ADDR_VAR 0 61
98953: PUSH
98954: LD_INT 2
98956: PUSH
98957: LD_INT 1
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: PUSH
98964: LD_INT 2
98966: PUSH
98967: LD_INT 2
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PUSH
98974: LD_INT 1
98976: PUSH
98977: LD_INT 2
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: LIST
98988: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98989: LD_ADDR_VAR 0 62
98993: PUSH
98994: LD_INT 1
98996: PUSH
98997: LD_INT 2
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: PUSH
99004: LD_INT 0
99006: PUSH
99007: LD_INT 2
99009: PUSH
99010: EMPTY
99011: LIST
99012: LIST
99013: PUSH
99014: LD_INT 1
99016: NEG
99017: PUSH
99018: LD_INT 1
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: LIST
99029: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
99030: LD_ADDR_VAR 0 63
99034: PUSH
99035: LD_INT 1
99037: NEG
99038: PUSH
99039: LD_INT 1
99041: PUSH
99042: EMPTY
99043: LIST
99044: LIST
99045: PUSH
99046: LD_INT 2
99048: NEG
99049: PUSH
99050: LD_INT 0
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: PUSH
99057: LD_INT 2
99059: NEG
99060: PUSH
99061: LD_INT 1
99063: NEG
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: PUSH
99069: EMPTY
99070: LIST
99071: LIST
99072: LIST
99073: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
99074: LD_ADDR_VAR 0 64
99078: PUSH
99079: LD_INT 1
99081: NEG
99082: PUSH
99083: LD_INT 2
99085: NEG
99086: PUSH
99087: EMPTY
99088: LIST
99089: LIST
99090: PUSH
99091: LD_INT 2
99093: NEG
99094: PUSH
99095: LD_INT 1
99097: NEG
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: PUSH
99103: LD_INT 2
99105: NEG
99106: PUSH
99107: LD_INT 2
99109: NEG
99110: PUSH
99111: EMPTY
99112: LIST
99113: LIST
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: LIST
99119: ST_TO_ADDR
// end ; 2 :
99120: GO 102386
99122: LD_INT 2
99124: DOUBLE
99125: EQUAL
99126: IFTRUE 99130
99128: GO 102385
99130: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99131: LD_ADDR_VAR 0 29
99135: PUSH
99136: LD_INT 4
99138: PUSH
99139: LD_INT 0
99141: PUSH
99142: EMPTY
99143: LIST
99144: LIST
99145: PUSH
99146: LD_INT 4
99148: PUSH
99149: LD_INT 1
99151: NEG
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PUSH
99157: LD_INT 5
99159: PUSH
99160: LD_INT 0
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: PUSH
99167: LD_INT 5
99169: PUSH
99170: LD_INT 1
99172: PUSH
99173: EMPTY
99174: LIST
99175: LIST
99176: PUSH
99177: LD_INT 4
99179: PUSH
99180: LD_INT 1
99182: PUSH
99183: EMPTY
99184: LIST
99185: LIST
99186: PUSH
99187: LD_INT 3
99189: PUSH
99190: LD_INT 0
99192: PUSH
99193: EMPTY
99194: LIST
99195: LIST
99196: PUSH
99197: LD_INT 3
99199: PUSH
99200: LD_INT 1
99202: NEG
99203: PUSH
99204: EMPTY
99205: LIST
99206: LIST
99207: PUSH
99208: LD_INT 3
99210: PUSH
99211: LD_INT 2
99213: NEG
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: LD_INT 5
99221: PUSH
99222: LD_INT 2
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 3
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: EMPTY
99236: LIST
99237: LIST
99238: PUSH
99239: LD_INT 3
99241: PUSH
99242: LD_INT 2
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: LD_INT 4
99251: PUSH
99252: LD_INT 3
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: PUSH
99259: LD_INT 4
99261: PUSH
99262: LD_INT 4
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: PUSH
99269: LD_INT 3
99271: PUSH
99272: LD_INT 4
99274: PUSH
99275: EMPTY
99276: LIST
99277: LIST
99278: PUSH
99279: LD_INT 2
99281: PUSH
99282: LD_INT 3
99284: PUSH
99285: EMPTY
99286: LIST
99287: LIST
99288: PUSH
99289: LD_INT 2
99291: PUSH
99292: LD_INT 2
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: PUSH
99299: LD_INT 4
99301: PUSH
99302: LD_INT 2
99304: PUSH
99305: EMPTY
99306: LIST
99307: LIST
99308: PUSH
99309: LD_INT 2
99311: PUSH
99312: LD_INT 4
99314: PUSH
99315: EMPTY
99316: LIST
99317: LIST
99318: PUSH
99319: LD_INT 0
99321: PUSH
99322: LD_INT 4
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: PUSH
99329: LD_INT 0
99331: PUSH
99332: LD_INT 3
99334: PUSH
99335: EMPTY
99336: LIST
99337: LIST
99338: PUSH
99339: LD_INT 1
99341: PUSH
99342: LD_INT 4
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: LD_INT 1
99351: PUSH
99352: LD_INT 5
99354: PUSH
99355: EMPTY
99356: LIST
99357: LIST
99358: PUSH
99359: LD_INT 0
99361: PUSH
99362: LD_INT 5
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: PUSH
99369: LD_INT 1
99371: NEG
99372: PUSH
99373: LD_INT 4
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PUSH
99380: LD_INT 1
99382: NEG
99383: PUSH
99384: LD_INT 3
99386: PUSH
99387: EMPTY
99388: LIST
99389: LIST
99390: PUSH
99391: LD_INT 2
99393: PUSH
99394: LD_INT 5
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: PUSH
99401: LD_INT 2
99403: NEG
99404: PUSH
99405: LD_INT 3
99407: PUSH
99408: EMPTY
99409: LIST
99410: LIST
99411: PUSH
99412: LD_INT 3
99414: NEG
99415: PUSH
99416: LD_INT 0
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: PUSH
99423: LD_INT 3
99425: NEG
99426: PUSH
99427: LD_INT 1
99429: NEG
99430: PUSH
99431: EMPTY
99432: LIST
99433: LIST
99434: PUSH
99435: LD_INT 2
99437: NEG
99438: PUSH
99439: LD_INT 0
99441: PUSH
99442: EMPTY
99443: LIST
99444: LIST
99445: PUSH
99446: LD_INT 2
99448: NEG
99449: PUSH
99450: LD_INT 1
99452: PUSH
99453: EMPTY
99454: LIST
99455: LIST
99456: PUSH
99457: LD_INT 3
99459: NEG
99460: PUSH
99461: LD_INT 1
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: PUSH
99468: LD_INT 4
99470: NEG
99471: PUSH
99472: LD_INT 0
99474: PUSH
99475: EMPTY
99476: LIST
99477: LIST
99478: PUSH
99479: LD_INT 4
99481: NEG
99482: PUSH
99483: LD_INT 1
99485: NEG
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: LD_INT 4
99493: NEG
99494: PUSH
99495: LD_INT 2
99497: NEG
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: PUSH
99503: LD_INT 2
99505: NEG
99506: PUSH
99507: LD_INT 2
99509: PUSH
99510: EMPTY
99511: LIST
99512: LIST
99513: PUSH
99514: LD_INT 4
99516: NEG
99517: PUSH
99518: LD_INT 4
99520: NEG
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PUSH
99526: LD_INT 4
99528: NEG
99529: PUSH
99530: LD_INT 5
99532: NEG
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PUSH
99538: LD_INT 3
99540: NEG
99541: PUSH
99542: LD_INT 4
99544: NEG
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: PUSH
99550: LD_INT 3
99552: NEG
99553: PUSH
99554: LD_INT 3
99556: NEG
99557: PUSH
99558: EMPTY
99559: LIST
99560: LIST
99561: PUSH
99562: LD_INT 4
99564: NEG
99565: PUSH
99566: LD_INT 3
99568: NEG
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: LD_INT 5
99576: NEG
99577: PUSH
99578: LD_INT 4
99580: NEG
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: LD_INT 5
99588: NEG
99589: PUSH
99590: LD_INT 5
99592: NEG
99593: PUSH
99594: EMPTY
99595: LIST
99596: LIST
99597: PUSH
99598: LD_INT 3
99600: NEG
99601: PUSH
99602: LD_INT 5
99604: NEG
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: PUSH
99610: LD_INT 5
99612: NEG
99613: PUSH
99614: LD_INT 3
99616: NEG
99617: PUSH
99618: EMPTY
99619: LIST
99620: LIST
99621: PUSH
99622: EMPTY
99623: LIST
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
99669: LD_ADDR_VAR 0 30
99673: PUSH
99674: LD_INT 4
99676: PUSH
99677: LD_INT 4
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: PUSH
99684: LD_INT 4
99686: PUSH
99687: LD_INT 3
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: PUSH
99694: LD_INT 5
99696: PUSH
99697: LD_INT 4
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: PUSH
99704: LD_INT 5
99706: PUSH
99707: LD_INT 5
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: PUSH
99714: LD_INT 4
99716: PUSH
99717: LD_INT 5
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PUSH
99724: LD_INT 3
99726: PUSH
99727: LD_INT 4
99729: PUSH
99730: EMPTY
99731: LIST
99732: LIST
99733: PUSH
99734: LD_INT 3
99736: PUSH
99737: LD_INT 3
99739: PUSH
99740: EMPTY
99741: LIST
99742: LIST
99743: PUSH
99744: LD_INT 5
99746: PUSH
99747: LD_INT 3
99749: PUSH
99750: EMPTY
99751: LIST
99752: LIST
99753: PUSH
99754: LD_INT 3
99756: PUSH
99757: LD_INT 5
99759: PUSH
99760: EMPTY
99761: LIST
99762: LIST
99763: PUSH
99764: LD_INT 0
99766: PUSH
99767: LD_INT 3
99769: PUSH
99770: EMPTY
99771: LIST
99772: LIST
99773: PUSH
99774: LD_INT 0
99776: PUSH
99777: LD_INT 2
99779: PUSH
99780: EMPTY
99781: LIST
99782: LIST
99783: PUSH
99784: LD_INT 1
99786: PUSH
99787: LD_INT 3
99789: PUSH
99790: EMPTY
99791: LIST
99792: LIST
99793: PUSH
99794: LD_INT 1
99796: PUSH
99797: LD_INT 4
99799: PUSH
99800: EMPTY
99801: LIST
99802: LIST
99803: PUSH
99804: LD_INT 0
99806: PUSH
99807: LD_INT 4
99809: PUSH
99810: EMPTY
99811: LIST
99812: LIST
99813: PUSH
99814: LD_INT 1
99816: NEG
99817: PUSH
99818: LD_INT 3
99820: PUSH
99821: EMPTY
99822: LIST
99823: LIST
99824: PUSH
99825: LD_INT 1
99827: NEG
99828: PUSH
99829: LD_INT 2
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: PUSH
99836: LD_INT 2
99838: PUSH
99839: LD_INT 4
99841: PUSH
99842: EMPTY
99843: LIST
99844: LIST
99845: PUSH
99846: LD_INT 2
99848: NEG
99849: PUSH
99850: LD_INT 2
99852: PUSH
99853: EMPTY
99854: LIST
99855: LIST
99856: PUSH
99857: LD_INT 4
99859: NEG
99860: PUSH
99861: LD_INT 0
99863: PUSH
99864: EMPTY
99865: LIST
99866: LIST
99867: PUSH
99868: LD_INT 4
99870: NEG
99871: PUSH
99872: LD_INT 1
99874: NEG
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 3
99882: NEG
99883: PUSH
99884: LD_INT 0
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 3
99893: NEG
99894: PUSH
99895: LD_INT 1
99897: PUSH
99898: EMPTY
99899: LIST
99900: LIST
99901: PUSH
99902: LD_INT 4
99904: NEG
99905: PUSH
99906: LD_INT 1
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: PUSH
99913: LD_INT 5
99915: NEG
99916: PUSH
99917: LD_INT 0
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: PUSH
99924: LD_INT 5
99926: NEG
99927: PUSH
99928: LD_INT 1
99930: NEG
99931: PUSH
99932: EMPTY
99933: LIST
99934: LIST
99935: PUSH
99936: LD_INT 5
99938: NEG
99939: PUSH
99940: LD_INT 2
99942: NEG
99943: PUSH
99944: EMPTY
99945: LIST
99946: LIST
99947: PUSH
99948: LD_INT 3
99950: NEG
99951: PUSH
99952: LD_INT 2
99954: PUSH
99955: EMPTY
99956: LIST
99957: LIST
99958: PUSH
99959: LD_INT 3
99961: NEG
99962: PUSH
99963: LD_INT 3
99965: NEG
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: PUSH
99971: LD_INT 3
99973: NEG
99974: PUSH
99975: LD_INT 4
99977: NEG
99978: PUSH
99979: EMPTY
99980: LIST
99981: LIST
99982: PUSH
99983: LD_INT 2
99985: NEG
99986: PUSH
99987: LD_INT 3
99989: NEG
99990: PUSH
99991: EMPTY
99992: LIST
99993: LIST
99994: PUSH
99995: LD_INT 2
99997: NEG
99998: PUSH
99999: LD_INT 2
100001: NEG
100002: PUSH
100003: EMPTY
100004: LIST
100005: LIST
100006: PUSH
100007: LD_INT 3
100009: NEG
100010: PUSH
100011: LD_INT 2
100013: NEG
100014: PUSH
100015: EMPTY
100016: LIST
100017: LIST
100018: PUSH
100019: LD_INT 4
100021: NEG
100022: PUSH
100023: LD_INT 3
100025: NEG
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: PUSH
100031: LD_INT 4
100033: NEG
100034: PUSH
100035: LD_INT 4
100037: NEG
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 2
100045: NEG
100046: PUSH
100047: LD_INT 4
100049: NEG
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PUSH
100055: LD_INT 4
100057: NEG
100058: PUSH
100059: LD_INT 2
100061: NEG
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PUSH
100067: LD_INT 0
100069: PUSH
100070: LD_INT 4
100072: NEG
100073: PUSH
100074: EMPTY
100075: LIST
100076: LIST
100077: PUSH
100078: LD_INT 0
100080: PUSH
100081: LD_INT 5
100083: NEG
100084: PUSH
100085: EMPTY
100086: LIST
100087: LIST
100088: PUSH
100089: LD_INT 1
100091: PUSH
100092: LD_INT 4
100094: NEG
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: PUSH
100100: LD_INT 1
100102: PUSH
100103: LD_INT 3
100105: NEG
100106: PUSH
100107: EMPTY
100108: LIST
100109: LIST
100110: PUSH
100111: LD_INT 0
100113: PUSH
100114: LD_INT 3
100116: NEG
100117: PUSH
100118: EMPTY
100119: LIST
100120: LIST
100121: PUSH
100122: LD_INT 1
100124: NEG
100125: PUSH
100126: LD_INT 4
100128: NEG
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PUSH
100134: LD_INT 1
100136: NEG
100137: PUSH
100138: LD_INT 5
100140: NEG
100141: PUSH
100142: EMPTY
100143: LIST
100144: LIST
100145: PUSH
100146: LD_INT 2
100148: PUSH
100149: LD_INT 3
100151: NEG
100152: PUSH
100153: EMPTY
100154: LIST
100155: LIST
100156: PUSH
100157: LD_INT 2
100159: NEG
100160: PUSH
100161: LD_INT 5
100163: NEG
100164: PUSH
100165: EMPTY
100166: LIST
100167: LIST
100168: PUSH
100169: EMPTY
100170: LIST
100171: LIST
100172: LIST
100173: LIST
100174: LIST
100175: LIST
100176: LIST
100177: LIST
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: LIST
100187: LIST
100188: LIST
100189: LIST
100190: LIST
100191: LIST
100192: LIST
100193: LIST
100194: LIST
100195: LIST
100196: LIST
100197: LIST
100198: LIST
100199: LIST
100200: LIST
100201: LIST
100202: LIST
100203: LIST
100204: LIST
100205: LIST
100206: LIST
100207: LIST
100208: LIST
100209: LIST
100210: LIST
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
100216: LD_ADDR_VAR 0 31
100220: PUSH
100221: LD_INT 0
100223: PUSH
100224: LD_INT 4
100226: PUSH
100227: EMPTY
100228: LIST
100229: LIST
100230: PUSH
100231: LD_INT 0
100233: PUSH
100234: LD_INT 3
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PUSH
100241: LD_INT 1
100243: PUSH
100244: LD_INT 4
100246: PUSH
100247: EMPTY
100248: LIST
100249: LIST
100250: PUSH
100251: LD_INT 1
100253: PUSH
100254: LD_INT 5
100256: PUSH
100257: EMPTY
100258: LIST
100259: LIST
100260: PUSH
100261: LD_INT 0
100263: PUSH
100264: LD_INT 5
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 1
100273: NEG
100274: PUSH
100275: LD_INT 4
100277: PUSH
100278: EMPTY
100279: LIST
100280: LIST
100281: PUSH
100282: LD_INT 1
100284: NEG
100285: PUSH
100286: LD_INT 3
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: LD_INT 2
100295: PUSH
100296: LD_INT 5
100298: PUSH
100299: EMPTY
100300: LIST
100301: LIST
100302: PUSH
100303: LD_INT 2
100305: NEG
100306: PUSH
100307: LD_INT 3
100309: PUSH
100310: EMPTY
100311: LIST
100312: LIST
100313: PUSH
100314: LD_INT 3
100316: NEG
100317: PUSH
100318: LD_INT 0
100320: PUSH
100321: EMPTY
100322: LIST
100323: LIST
100324: PUSH
100325: LD_INT 3
100327: NEG
100328: PUSH
100329: LD_INT 1
100331: NEG
100332: PUSH
100333: EMPTY
100334: LIST
100335: LIST
100336: PUSH
100337: LD_INT 2
100339: NEG
100340: PUSH
100341: LD_INT 0
100343: PUSH
100344: EMPTY
100345: LIST
100346: LIST
100347: PUSH
100348: LD_INT 2
100350: NEG
100351: PUSH
100352: LD_INT 1
100354: PUSH
100355: EMPTY
100356: LIST
100357: LIST
100358: PUSH
100359: LD_INT 3
100361: NEG
100362: PUSH
100363: LD_INT 1
100365: PUSH
100366: EMPTY
100367: LIST
100368: LIST
100369: PUSH
100370: LD_INT 4
100372: NEG
100373: PUSH
100374: LD_INT 0
100376: PUSH
100377: EMPTY
100378: LIST
100379: LIST
100380: PUSH
100381: LD_INT 4
100383: NEG
100384: PUSH
100385: LD_INT 1
100387: NEG
100388: PUSH
100389: EMPTY
100390: LIST
100391: LIST
100392: PUSH
100393: LD_INT 4
100395: NEG
100396: PUSH
100397: LD_INT 2
100399: NEG
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: PUSH
100405: LD_INT 2
100407: NEG
100408: PUSH
100409: LD_INT 2
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: PUSH
100416: LD_INT 4
100418: NEG
100419: PUSH
100420: LD_INT 4
100422: NEG
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: PUSH
100428: LD_INT 4
100430: NEG
100431: PUSH
100432: LD_INT 5
100434: NEG
100435: PUSH
100436: EMPTY
100437: LIST
100438: LIST
100439: PUSH
100440: LD_INT 3
100442: NEG
100443: PUSH
100444: LD_INT 4
100446: NEG
100447: PUSH
100448: EMPTY
100449: LIST
100450: LIST
100451: PUSH
100452: LD_INT 3
100454: NEG
100455: PUSH
100456: LD_INT 3
100458: NEG
100459: PUSH
100460: EMPTY
100461: LIST
100462: LIST
100463: PUSH
100464: LD_INT 4
100466: NEG
100467: PUSH
100468: LD_INT 3
100470: NEG
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: PUSH
100476: LD_INT 5
100478: NEG
100479: PUSH
100480: LD_INT 4
100482: NEG
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: LD_INT 5
100490: NEG
100491: PUSH
100492: LD_INT 5
100494: NEG
100495: PUSH
100496: EMPTY
100497: LIST
100498: LIST
100499: PUSH
100500: LD_INT 3
100502: NEG
100503: PUSH
100504: LD_INT 5
100506: NEG
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: PUSH
100512: LD_INT 5
100514: NEG
100515: PUSH
100516: LD_INT 3
100518: NEG
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PUSH
100524: LD_INT 0
100526: PUSH
100527: LD_INT 3
100529: NEG
100530: PUSH
100531: EMPTY
100532: LIST
100533: LIST
100534: PUSH
100535: LD_INT 0
100537: PUSH
100538: LD_INT 4
100540: NEG
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: PUSH
100546: LD_INT 1
100548: PUSH
100549: LD_INT 3
100551: NEG
100552: PUSH
100553: EMPTY
100554: LIST
100555: LIST
100556: PUSH
100557: LD_INT 1
100559: PUSH
100560: LD_INT 2
100562: NEG
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: LD_INT 0
100570: PUSH
100571: LD_INT 2
100573: NEG
100574: PUSH
100575: EMPTY
100576: LIST
100577: LIST
100578: PUSH
100579: LD_INT 1
100581: NEG
100582: PUSH
100583: LD_INT 3
100585: NEG
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: PUSH
100591: LD_INT 1
100593: NEG
100594: PUSH
100595: LD_INT 4
100597: NEG
100598: PUSH
100599: EMPTY
100600: LIST
100601: LIST
100602: PUSH
100603: LD_INT 2
100605: PUSH
100606: LD_INT 2
100608: NEG
100609: PUSH
100610: EMPTY
100611: LIST
100612: LIST
100613: PUSH
100614: LD_INT 2
100616: NEG
100617: PUSH
100618: LD_INT 4
100620: NEG
100621: PUSH
100622: EMPTY
100623: LIST
100624: LIST
100625: PUSH
100626: LD_INT 4
100628: PUSH
100629: LD_INT 0
100631: PUSH
100632: EMPTY
100633: LIST
100634: LIST
100635: PUSH
100636: LD_INT 4
100638: PUSH
100639: LD_INT 1
100641: NEG
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: PUSH
100647: LD_INT 5
100649: PUSH
100650: LD_INT 0
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PUSH
100657: LD_INT 5
100659: PUSH
100660: LD_INT 1
100662: PUSH
100663: EMPTY
100664: LIST
100665: LIST
100666: PUSH
100667: LD_INT 4
100669: PUSH
100670: LD_INT 1
100672: PUSH
100673: EMPTY
100674: LIST
100675: LIST
100676: PUSH
100677: LD_INT 3
100679: PUSH
100680: LD_INT 0
100682: PUSH
100683: EMPTY
100684: LIST
100685: LIST
100686: PUSH
100687: LD_INT 3
100689: PUSH
100690: LD_INT 1
100692: NEG
100693: PUSH
100694: EMPTY
100695: LIST
100696: LIST
100697: PUSH
100698: LD_INT 3
100700: PUSH
100701: LD_INT 2
100703: NEG
100704: PUSH
100705: EMPTY
100706: LIST
100707: LIST
100708: PUSH
100709: LD_INT 5
100711: PUSH
100712: LD_INT 2
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: LIST
100723: LIST
100724: LIST
100725: LIST
100726: LIST
100727: LIST
100728: LIST
100729: LIST
100730: LIST
100731: LIST
100732: LIST
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: LIST
100740: LIST
100741: LIST
100742: LIST
100743: LIST
100744: LIST
100745: LIST
100746: LIST
100747: LIST
100748: LIST
100749: LIST
100750: LIST
100751: LIST
100752: LIST
100753: LIST
100754: LIST
100755: LIST
100756: LIST
100757: LIST
100758: LIST
100759: LIST
100760: LIST
100761: LIST
100762: LIST
100763: LIST
100764: LIST
100765: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
100766: LD_ADDR_VAR 0 32
100770: PUSH
100771: LD_INT 4
100773: NEG
100774: PUSH
100775: LD_INT 0
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PUSH
100782: LD_INT 4
100784: NEG
100785: PUSH
100786: LD_INT 1
100788: NEG
100789: PUSH
100790: EMPTY
100791: LIST
100792: LIST
100793: PUSH
100794: LD_INT 3
100796: NEG
100797: PUSH
100798: LD_INT 0
100800: PUSH
100801: EMPTY
100802: LIST
100803: LIST
100804: PUSH
100805: LD_INT 3
100807: NEG
100808: PUSH
100809: LD_INT 1
100811: PUSH
100812: EMPTY
100813: LIST
100814: LIST
100815: PUSH
100816: LD_INT 4
100818: NEG
100819: PUSH
100820: LD_INT 1
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: PUSH
100827: LD_INT 5
100829: NEG
100830: PUSH
100831: LD_INT 0
100833: PUSH
100834: EMPTY
100835: LIST
100836: LIST
100837: PUSH
100838: LD_INT 5
100840: NEG
100841: PUSH
100842: LD_INT 1
100844: NEG
100845: PUSH
100846: EMPTY
100847: LIST
100848: LIST
100849: PUSH
100850: LD_INT 5
100852: NEG
100853: PUSH
100854: LD_INT 2
100856: NEG
100857: PUSH
100858: EMPTY
100859: LIST
100860: LIST
100861: PUSH
100862: LD_INT 3
100864: NEG
100865: PUSH
100866: LD_INT 2
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: PUSH
100873: LD_INT 3
100875: NEG
100876: PUSH
100877: LD_INT 3
100879: NEG
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: LD_INT 3
100887: NEG
100888: PUSH
100889: LD_INT 4
100891: NEG
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: PUSH
100897: LD_INT 2
100899: NEG
100900: PUSH
100901: LD_INT 3
100903: NEG
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: PUSH
100909: LD_INT 2
100911: NEG
100912: PUSH
100913: LD_INT 2
100915: NEG
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: LD_INT 3
100923: NEG
100924: PUSH
100925: LD_INT 2
100927: NEG
100928: PUSH
100929: EMPTY
100930: LIST
100931: LIST
100932: PUSH
100933: LD_INT 4
100935: NEG
100936: PUSH
100937: LD_INT 3
100939: NEG
100940: PUSH
100941: EMPTY
100942: LIST
100943: LIST
100944: PUSH
100945: LD_INT 4
100947: NEG
100948: PUSH
100949: LD_INT 4
100951: NEG
100952: PUSH
100953: EMPTY
100954: LIST
100955: LIST
100956: PUSH
100957: LD_INT 2
100959: NEG
100960: PUSH
100961: LD_INT 4
100963: NEG
100964: PUSH
100965: EMPTY
100966: LIST
100967: LIST
100968: PUSH
100969: LD_INT 4
100971: NEG
100972: PUSH
100973: LD_INT 2
100975: NEG
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: PUSH
100981: LD_INT 0
100983: PUSH
100984: LD_INT 4
100986: NEG
100987: PUSH
100988: EMPTY
100989: LIST
100990: LIST
100991: PUSH
100992: LD_INT 0
100994: PUSH
100995: LD_INT 5
100997: NEG
100998: PUSH
100999: EMPTY
101000: LIST
101001: LIST
101002: PUSH
101003: LD_INT 1
101005: PUSH
101006: LD_INT 4
101008: NEG
101009: PUSH
101010: EMPTY
101011: LIST
101012: LIST
101013: PUSH
101014: LD_INT 1
101016: PUSH
101017: LD_INT 3
101019: NEG
101020: PUSH
101021: EMPTY
101022: LIST
101023: LIST
101024: PUSH
101025: LD_INT 0
101027: PUSH
101028: LD_INT 3
101030: NEG
101031: PUSH
101032: EMPTY
101033: LIST
101034: LIST
101035: PUSH
101036: LD_INT 1
101038: NEG
101039: PUSH
101040: LD_INT 4
101042: NEG
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: PUSH
101048: LD_INT 1
101050: NEG
101051: PUSH
101052: LD_INT 5
101054: NEG
101055: PUSH
101056: EMPTY
101057: LIST
101058: LIST
101059: PUSH
101060: LD_INT 2
101062: PUSH
101063: LD_INT 3
101065: NEG
101066: PUSH
101067: EMPTY
101068: LIST
101069: LIST
101070: PUSH
101071: LD_INT 2
101073: NEG
101074: PUSH
101075: LD_INT 5
101077: NEG
101078: PUSH
101079: EMPTY
101080: LIST
101081: LIST
101082: PUSH
101083: LD_INT 3
101085: PUSH
101086: LD_INT 0
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: PUSH
101093: LD_INT 3
101095: PUSH
101096: LD_INT 1
101098: NEG
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: PUSH
101104: LD_INT 4
101106: PUSH
101107: LD_INT 0
101109: PUSH
101110: EMPTY
101111: LIST
101112: LIST
101113: PUSH
101114: LD_INT 4
101116: PUSH
101117: LD_INT 1
101119: PUSH
101120: EMPTY
101121: LIST
101122: LIST
101123: PUSH
101124: LD_INT 3
101126: PUSH
101127: LD_INT 1
101129: PUSH
101130: EMPTY
101131: LIST
101132: LIST
101133: PUSH
101134: LD_INT 2
101136: PUSH
101137: LD_INT 0
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 2
101146: PUSH
101147: LD_INT 1
101149: NEG
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: LD_INT 2
101157: PUSH
101158: LD_INT 2
101160: NEG
101161: PUSH
101162: EMPTY
101163: LIST
101164: LIST
101165: PUSH
101166: LD_INT 4
101168: PUSH
101169: LD_INT 2
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: PUSH
101176: LD_INT 4
101178: PUSH
101179: LD_INT 4
101181: PUSH
101182: EMPTY
101183: LIST
101184: LIST
101185: PUSH
101186: LD_INT 4
101188: PUSH
101189: LD_INT 3
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 5
101198: PUSH
101199: LD_INT 4
101201: PUSH
101202: EMPTY
101203: LIST
101204: LIST
101205: PUSH
101206: LD_INT 5
101208: PUSH
101209: LD_INT 5
101211: PUSH
101212: EMPTY
101213: LIST
101214: LIST
101215: PUSH
101216: LD_INT 4
101218: PUSH
101219: LD_INT 5
101221: PUSH
101222: EMPTY
101223: LIST
101224: LIST
101225: PUSH
101226: LD_INT 3
101228: PUSH
101229: LD_INT 4
101231: PUSH
101232: EMPTY
101233: LIST
101234: LIST
101235: PUSH
101236: LD_INT 3
101238: PUSH
101239: LD_INT 3
101241: PUSH
101242: EMPTY
101243: LIST
101244: LIST
101245: PUSH
101246: LD_INT 5
101248: PUSH
101249: LD_INT 3
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: PUSH
101256: LD_INT 3
101258: PUSH
101259: LD_INT 5
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: EMPTY
101267: LIST
101268: LIST
101269: LIST
101270: LIST
101271: LIST
101272: LIST
101273: LIST
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: LIST
101284: LIST
101285: LIST
101286: LIST
101287: LIST
101288: LIST
101289: LIST
101290: LIST
101291: LIST
101292: LIST
101293: LIST
101294: LIST
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
101313: LD_ADDR_VAR 0 33
101317: PUSH
101318: LD_INT 4
101320: NEG
101321: PUSH
101322: LD_INT 4
101324: NEG
101325: PUSH
101326: EMPTY
101327: LIST
101328: LIST
101329: PUSH
101330: LD_INT 4
101332: NEG
101333: PUSH
101334: LD_INT 5
101336: NEG
101337: PUSH
101338: EMPTY
101339: LIST
101340: LIST
101341: PUSH
101342: LD_INT 3
101344: NEG
101345: PUSH
101346: LD_INT 4
101348: NEG
101349: PUSH
101350: EMPTY
101351: LIST
101352: LIST
101353: PUSH
101354: LD_INT 3
101356: NEG
101357: PUSH
101358: LD_INT 3
101360: NEG
101361: PUSH
101362: EMPTY
101363: LIST
101364: LIST
101365: PUSH
101366: LD_INT 4
101368: NEG
101369: PUSH
101370: LD_INT 3
101372: NEG
101373: PUSH
101374: EMPTY
101375: LIST
101376: LIST
101377: PUSH
101378: LD_INT 5
101380: NEG
101381: PUSH
101382: LD_INT 4
101384: NEG
101385: PUSH
101386: EMPTY
101387: LIST
101388: LIST
101389: PUSH
101390: LD_INT 5
101392: NEG
101393: PUSH
101394: LD_INT 5
101396: NEG
101397: PUSH
101398: EMPTY
101399: LIST
101400: LIST
101401: PUSH
101402: LD_INT 3
101404: NEG
101405: PUSH
101406: LD_INT 5
101408: NEG
101409: PUSH
101410: EMPTY
101411: LIST
101412: LIST
101413: PUSH
101414: LD_INT 5
101416: NEG
101417: PUSH
101418: LD_INT 3
101420: NEG
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PUSH
101426: LD_INT 0
101428: PUSH
101429: LD_INT 3
101431: NEG
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PUSH
101437: LD_INT 0
101439: PUSH
101440: LD_INT 4
101442: NEG
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: LD_INT 1
101450: PUSH
101451: LD_INT 3
101453: NEG
101454: PUSH
101455: EMPTY
101456: LIST
101457: LIST
101458: PUSH
101459: LD_INT 1
101461: PUSH
101462: LD_INT 2
101464: NEG
101465: PUSH
101466: EMPTY
101467: LIST
101468: LIST
101469: PUSH
101470: LD_INT 0
101472: PUSH
101473: LD_INT 2
101475: NEG
101476: PUSH
101477: EMPTY
101478: LIST
101479: LIST
101480: PUSH
101481: LD_INT 1
101483: NEG
101484: PUSH
101485: LD_INT 3
101487: NEG
101488: PUSH
101489: EMPTY
101490: LIST
101491: LIST
101492: PUSH
101493: LD_INT 1
101495: NEG
101496: PUSH
101497: LD_INT 4
101499: NEG
101500: PUSH
101501: EMPTY
101502: LIST
101503: LIST
101504: PUSH
101505: LD_INT 2
101507: PUSH
101508: LD_INT 2
101510: NEG
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PUSH
101516: LD_INT 2
101518: NEG
101519: PUSH
101520: LD_INT 4
101522: NEG
101523: PUSH
101524: EMPTY
101525: LIST
101526: LIST
101527: PUSH
101528: LD_INT 4
101530: PUSH
101531: LD_INT 0
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PUSH
101538: LD_INT 4
101540: PUSH
101541: LD_INT 1
101543: NEG
101544: PUSH
101545: EMPTY
101546: LIST
101547: LIST
101548: PUSH
101549: LD_INT 5
101551: PUSH
101552: LD_INT 0
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: PUSH
101559: LD_INT 5
101561: PUSH
101562: LD_INT 1
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: PUSH
101569: LD_INT 4
101571: PUSH
101572: LD_INT 1
101574: PUSH
101575: EMPTY
101576: LIST
101577: LIST
101578: PUSH
101579: LD_INT 3
101581: PUSH
101582: LD_INT 0
101584: PUSH
101585: EMPTY
101586: LIST
101587: LIST
101588: PUSH
101589: LD_INT 3
101591: PUSH
101592: LD_INT 1
101594: NEG
101595: PUSH
101596: EMPTY
101597: LIST
101598: LIST
101599: PUSH
101600: LD_INT 3
101602: PUSH
101603: LD_INT 2
101605: NEG
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: PUSH
101611: LD_INT 5
101613: PUSH
101614: LD_INT 2
101616: PUSH
101617: EMPTY
101618: LIST
101619: LIST
101620: PUSH
101621: LD_INT 3
101623: PUSH
101624: LD_INT 3
101626: PUSH
101627: EMPTY
101628: LIST
101629: LIST
101630: PUSH
101631: LD_INT 3
101633: PUSH
101634: LD_INT 2
101636: PUSH
101637: EMPTY
101638: LIST
101639: LIST
101640: PUSH
101641: LD_INT 4
101643: PUSH
101644: LD_INT 3
101646: PUSH
101647: EMPTY
101648: LIST
101649: LIST
101650: PUSH
101651: LD_INT 4
101653: PUSH
101654: LD_INT 4
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: PUSH
101661: LD_INT 3
101663: PUSH
101664: LD_INT 4
101666: PUSH
101667: EMPTY
101668: LIST
101669: LIST
101670: PUSH
101671: LD_INT 2
101673: PUSH
101674: LD_INT 3
101676: PUSH
101677: EMPTY
101678: LIST
101679: LIST
101680: PUSH
101681: LD_INT 2
101683: PUSH
101684: LD_INT 2
101686: PUSH
101687: EMPTY
101688: LIST
101689: LIST
101690: PUSH
101691: LD_INT 4
101693: PUSH
101694: LD_INT 2
101696: PUSH
101697: EMPTY
101698: LIST
101699: LIST
101700: PUSH
101701: LD_INT 2
101703: PUSH
101704: LD_INT 4
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: PUSH
101711: LD_INT 0
101713: PUSH
101714: LD_INT 4
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PUSH
101721: LD_INT 0
101723: PUSH
101724: LD_INT 3
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: PUSH
101731: LD_INT 1
101733: PUSH
101734: LD_INT 4
101736: PUSH
101737: EMPTY
101738: LIST
101739: LIST
101740: PUSH
101741: LD_INT 1
101743: PUSH
101744: LD_INT 5
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: PUSH
101751: LD_INT 0
101753: PUSH
101754: LD_INT 5
101756: PUSH
101757: EMPTY
101758: LIST
101759: LIST
101760: PUSH
101761: LD_INT 1
101763: NEG
101764: PUSH
101765: LD_INT 4
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: PUSH
101772: LD_INT 1
101774: NEG
101775: PUSH
101776: LD_INT 3
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: PUSH
101783: LD_INT 2
101785: PUSH
101786: LD_INT 5
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: PUSH
101793: LD_INT 2
101795: NEG
101796: PUSH
101797: LD_INT 3
101799: PUSH
101800: EMPTY
101801: LIST
101802: LIST
101803: PUSH
101804: EMPTY
101805: LIST
101806: LIST
101807: LIST
101808: LIST
101809: LIST
101810: LIST
101811: LIST
101812: LIST
101813: LIST
101814: LIST
101815: LIST
101816: LIST
101817: LIST
101818: LIST
101819: LIST
101820: LIST
101821: LIST
101822: LIST
101823: LIST
101824: LIST
101825: LIST
101826: LIST
101827: LIST
101828: LIST
101829: LIST
101830: LIST
101831: LIST
101832: LIST
101833: LIST
101834: LIST
101835: LIST
101836: LIST
101837: LIST
101838: LIST
101839: LIST
101840: LIST
101841: LIST
101842: LIST
101843: LIST
101844: LIST
101845: LIST
101846: LIST
101847: LIST
101848: LIST
101849: LIST
101850: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101851: LD_ADDR_VAR 0 34
101855: PUSH
101856: LD_INT 0
101858: PUSH
101859: LD_INT 4
101861: NEG
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: PUSH
101867: LD_INT 0
101869: PUSH
101870: LD_INT 5
101872: NEG
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: LD_INT 1
101880: PUSH
101881: LD_INT 4
101883: NEG
101884: PUSH
101885: EMPTY
101886: LIST
101887: LIST
101888: PUSH
101889: LD_INT 1
101891: PUSH
101892: LD_INT 3
101894: NEG
101895: PUSH
101896: EMPTY
101897: LIST
101898: LIST
101899: PUSH
101900: LD_INT 0
101902: PUSH
101903: LD_INT 3
101905: NEG
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: PUSH
101911: LD_INT 1
101913: NEG
101914: PUSH
101915: LD_INT 4
101917: NEG
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: PUSH
101923: LD_INT 1
101925: NEG
101926: PUSH
101927: LD_INT 5
101929: NEG
101930: PUSH
101931: EMPTY
101932: LIST
101933: LIST
101934: PUSH
101935: LD_INT 2
101937: PUSH
101938: LD_INT 3
101940: NEG
101941: PUSH
101942: EMPTY
101943: LIST
101944: LIST
101945: PUSH
101946: LD_INT 2
101948: NEG
101949: PUSH
101950: LD_INT 5
101952: NEG
101953: PUSH
101954: EMPTY
101955: LIST
101956: LIST
101957: PUSH
101958: LD_INT 3
101960: PUSH
101961: LD_INT 0
101963: PUSH
101964: EMPTY
101965: LIST
101966: LIST
101967: PUSH
101968: LD_INT 3
101970: PUSH
101971: LD_INT 1
101973: NEG
101974: PUSH
101975: EMPTY
101976: LIST
101977: LIST
101978: PUSH
101979: LD_INT 4
101981: PUSH
101982: LD_INT 0
101984: PUSH
101985: EMPTY
101986: LIST
101987: LIST
101988: PUSH
101989: LD_INT 4
101991: PUSH
101992: LD_INT 1
101994: PUSH
101995: EMPTY
101996: LIST
101997: LIST
101998: PUSH
101999: LD_INT 3
102001: PUSH
102002: LD_INT 1
102004: PUSH
102005: EMPTY
102006: LIST
102007: LIST
102008: PUSH
102009: LD_INT 2
102011: PUSH
102012: LD_INT 0
102014: PUSH
102015: EMPTY
102016: LIST
102017: LIST
102018: PUSH
102019: LD_INT 2
102021: PUSH
102022: LD_INT 1
102024: NEG
102025: PUSH
102026: EMPTY
102027: LIST
102028: LIST
102029: PUSH
102030: LD_INT 2
102032: PUSH
102033: LD_INT 2
102035: NEG
102036: PUSH
102037: EMPTY
102038: LIST
102039: LIST
102040: PUSH
102041: LD_INT 4
102043: PUSH
102044: LD_INT 2
102046: PUSH
102047: EMPTY
102048: LIST
102049: LIST
102050: PUSH
102051: LD_INT 4
102053: PUSH
102054: LD_INT 4
102056: PUSH
102057: EMPTY
102058: LIST
102059: LIST
102060: PUSH
102061: LD_INT 4
102063: PUSH
102064: LD_INT 3
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: PUSH
102071: LD_INT 5
102073: PUSH
102074: LD_INT 4
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: PUSH
102081: LD_INT 5
102083: PUSH
102084: LD_INT 5
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: PUSH
102091: LD_INT 4
102093: PUSH
102094: LD_INT 5
102096: PUSH
102097: EMPTY
102098: LIST
102099: LIST
102100: PUSH
102101: LD_INT 3
102103: PUSH
102104: LD_INT 4
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PUSH
102111: LD_INT 3
102113: PUSH
102114: LD_INT 3
102116: PUSH
102117: EMPTY
102118: LIST
102119: LIST
102120: PUSH
102121: LD_INT 5
102123: PUSH
102124: LD_INT 3
102126: PUSH
102127: EMPTY
102128: LIST
102129: LIST
102130: PUSH
102131: LD_INT 3
102133: PUSH
102134: LD_INT 5
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: PUSH
102141: LD_INT 0
102143: PUSH
102144: LD_INT 3
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: PUSH
102151: LD_INT 0
102153: PUSH
102154: LD_INT 2
102156: PUSH
102157: EMPTY
102158: LIST
102159: LIST
102160: PUSH
102161: LD_INT 1
102163: PUSH
102164: LD_INT 3
102166: PUSH
102167: EMPTY
102168: LIST
102169: LIST
102170: PUSH
102171: LD_INT 1
102173: PUSH
102174: LD_INT 4
102176: PUSH
102177: EMPTY
102178: LIST
102179: LIST
102180: PUSH
102181: LD_INT 0
102183: PUSH
102184: LD_INT 4
102186: PUSH
102187: EMPTY
102188: LIST
102189: LIST
102190: PUSH
102191: LD_INT 1
102193: NEG
102194: PUSH
102195: LD_INT 3
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 1
102204: NEG
102205: PUSH
102206: LD_INT 2
102208: PUSH
102209: EMPTY
102210: LIST
102211: LIST
102212: PUSH
102213: LD_INT 2
102215: PUSH
102216: LD_INT 4
102218: PUSH
102219: EMPTY
102220: LIST
102221: LIST
102222: PUSH
102223: LD_INT 2
102225: NEG
102226: PUSH
102227: LD_INT 2
102229: PUSH
102230: EMPTY
102231: LIST
102232: LIST
102233: PUSH
102234: LD_INT 4
102236: NEG
102237: PUSH
102238: LD_INT 0
102240: PUSH
102241: EMPTY
102242: LIST
102243: LIST
102244: PUSH
102245: LD_INT 4
102247: NEG
102248: PUSH
102249: LD_INT 1
102251: NEG
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PUSH
102257: LD_INT 3
102259: NEG
102260: PUSH
102261: LD_INT 0
102263: PUSH
102264: EMPTY
102265: LIST
102266: LIST
102267: PUSH
102268: LD_INT 3
102270: NEG
102271: PUSH
102272: LD_INT 1
102274: PUSH
102275: EMPTY
102276: LIST
102277: LIST
102278: PUSH
102279: LD_INT 4
102281: NEG
102282: PUSH
102283: LD_INT 1
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: LD_INT 5
102292: NEG
102293: PUSH
102294: LD_INT 0
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: PUSH
102301: LD_INT 5
102303: NEG
102304: PUSH
102305: LD_INT 1
102307: NEG
102308: PUSH
102309: EMPTY
102310: LIST
102311: LIST
102312: PUSH
102313: LD_INT 5
102315: NEG
102316: PUSH
102317: LD_INT 2
102319: NEG
102320: PUSH
102321: EMPTY
102322: LIST
102323: LIST
102324: PUSH
102325: LD_INT 3
102327: NEG
102328: PUSH
102329: LD_INT 2
102331: PUSH
102332: EMPTY
102333: LIST
102334: LIST
102335: PUSH
102336: EMPTY
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: LIST
102342: LIST
102343: LIST
102344: LIST
102345: LIST
102346: LIST
102347: LIST
102348: LIST
102349: LIST
102350: LIST
102351: LIST
102352: LIST
102353: LIST
102354: LIST
102355: LIST
102356: LIST
102357: LIST
102358: LIST
102359: LIST
102360: LIST
102361: LIST
102362: LIST
102363: LIST
102364: LIST
102365: LIST
102366: LIST
102367: LIST
102368: LIST
102369: LIST
102370: LIST
102371: LIST
102372: LIST
102373: LIST
102374: LIST
102375: LIST
102376: LIST
102377: LIST
102378: LIST
102379: LIST
102380: LIST
102381: LIST
102382: ST_TO_ADDR
// end ; end ;
102383: GO 102386
102385: POP
// case btype of b_depot , b_warehouse :
102386: LD_VAR 0 1
102390: PUSH
102391: LD_INT 0
102393: DOUBLE
102394: EQUAL
102395: IFTRUE 102405
102397: LD_INT 1
102399: DOUBLE
102400: EQUAL
102401: IFTRUE 102405
102403: GO 102606
102405: POP
// case nation of nation_american :
102406: LD_VAR 0 5
102410: PUSH
102411: LD_INT 1
102413: DOUBLE
102414: EQUAL
102415: IFTRUE 102419
102417: GO 102475
102419: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
102420: LD_ADDR_VAR 0 9
102424: PUSH
102425: LD_VAR 0 11
102429: PUSH
102430: LD_VAR 0 12
102434: PUSH
102435: LD_VAR 0 13
102439: PUSH
102440: LD_VAR 0 14
102444: PUSH
102445: LD_VAR 0 15
102449: PUSH
102450: LD_VAR 0 16
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: LIST
102459: LIST
102460: LIST
102461: LIST
102462: PUSH
102463: LD_VAR 0 4
102467: PUSH
102468: LD_INT 1
102470: PLUS
102471: ARRAY
102472: ST_TO_ADDR
102473: GO 102604
102475: LD_INT 2
102477: DOUBLE
102478: EQUAL
102479: IFTRUE 102483
102481: GO 102539
102483: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
102484: LD_ADDR_VAR 0 9
102488: PUSH
102489: LD_VAR 0 17
102493: PUSH
102494: LD_VAR 0 18
102498: PUSH
102499: LD_VAR 0 19
102503: PUSH
102504: LD_VAR 0 20
102508: PUSH
102509: LD_VAR 0 21
102513: PUSH
102514: LD_VAR 0 22
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: LIST
102523: LIST
102524: LIST
102525: LIST
102526: PUSH
102527: LD_VAR 0 4
102531: PUSH
102532: LD_INT 1
102534: PLUS
102535: ARRAY
102536: ST_TO_ADDR
102537: GO 102604
102539: LD_INT 3
102541: DOUBLE
102542: EQUAL
102543: IFTRUE 102547
102545: GO 102603
102547: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
102548: LD_ADDR_VAR 0 9
102552: PUSH
102553: LD_VAR 0 23
102557: PUSH
102558: LD_VAR 0 24
102562: PUSH
102563: LD_VAR 0 25
102567: PUSH
102568: LD_VAR 0 26
102572: PUSH
102573: LD_VAR 0 27
102577: PUSH
102578: LD_VAR 0 28
102582: PUSH
102583: EMPTY
102584: LIST
102585: LIST
102586: LIST
102587: LIST
102588: LIST
102589: LIST
102590: PUSH
102591: LD_VAR 0 4
102595: PUSH
102596: LD_INT 1
102598: PLUS
102599: ARRAY
102600: ST_TO_ADDR
102601: GO 102604
102603: POP
102604: GO 103159
102606: LD_INT 2
102608: DOUBLE
102609: EQUAL
102610: IFTRUE 102620
102612: LD_INT 3
102614: DOUBLE
102615: EQUAL
102616: IFTRUE 102620
102618: GO 102676
102620: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
102621: LD_ADDR_VAR 0 9
102625: PUSH
102626: LD_VAR 0 29
102630: PUSH
102631: LD_VAR 0 30
102635: PUSH
102636: LD_VAR 0 31
102640: PUSH
102641: LD_VAR 0 32
102645: PUSH
102646: LD_VAR 0 33
102650: PUSH
102651: LD_VAR 0 34
102655: PUSH
102656: EMPTY
102657: LIST
102658: LIST
102659: LIST
102660: LIST
102661: LIST
102662: LIST
102663: PUSH
102664: LD_VAR 0 4
102668: PUSH
102669: LD_INT 1
102671: PLUS
102672: ARRAY
102673: ST_TO_ADDR
102674: GO 103159
102676: LD_INT 16
102678: DOUBLE
102679: EQUAL
102680: IFTRUE 102738
102682: LD_INT 17
102684: DOUBLE
102685: EQUAL
102686: IFTRUE 102738
102688: LD_INT 18
102690: DOUBLE
102691: EQUAL
102692: IFTRUE 102738
102694: LD_INT 19
102696: DOUBLE
102697: EQUAL
102698: IFTRUE 102738
102700: LD_INT 22
102702: DOUBLE
102703: EQUAL
102704: IFTRUE 102738
102706: LD_INT 20
102708: DOUBLE
102709: EQUAL
102710: IFTRUE 102738
102712: LD_INT 21
102714: DOUBLE
102715: EQUAL
102716: IFTRUE 102738
102718: LD_INT 23
102720: DOUBLE
102721: EQUAL
102722: IFTRUE 102738
102724: LD_INT 24
102726: DOUBLE
102727: EQUAL
102728: IFTRUE 102738
102730: LD_INT 25
102732: DOUBLE
102733: EQUAL
102734: IFTRUE 102738
102736: GO 102794
102738: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
102739: LD_ADDR_VAR 0 9
102743: PUSH
102744: LD_VAR 0 35
102748: PUSH
102749: LD_VAR 0 36
102753: PUSH
102754: LD_VAR 0 37
102758: PUSH
102759: LD_VAR 0 38
102763: PUSH
102764: LD_VAR 0 39
102768: PUSH
102769: LD_VAR 0 40
102773: PUSH
102774: EMPTY
102775: LIST
102776: LIST
102777: LIST
102778: LIST
102779: LIST
102780: LIST
102781: PUSH
102782: LD_VAR 0 4
102786: PUSH
102787: LD_INT 1
102789: PLUS
102790: ARRAY
102791: ST_TO_ADDR
102792: GO 103159
102794: LD_INT 6
102796: DOUBLE
102797: EQUAL
102798: IFTRUE 102850
102800: LD_INT 7
102802: DOUBLE
102803: EQUAL
102804: IFTRUE 102850
102806: LD_INT 8
102808: DOUBLE
102809: EQUAL
102810: IFTRUE 102850
102812: LD_INT 13
102814: DOUBLE
102815: EQUAL
102816: IFTRUE 102850
102818: LD_INT 12
102820: DOUBLE
102821: EQUAL
102822: IFTRUE 102850
102824: LD_INT 15
102826: DOUBLE
102827: EQUAL
102828: IFTRUE 102850
102830: LD_INT 11
102832: DOUBLE
102833: EQUAL
102834: IFTRUE 102850
102836: LD_INT 14
102838: DOUBLE
102839: EQUAL
102840: IFTRUE 102850
102842: LD_INT 10
102844: DOUBLE
102845: EQUAL
102846: IFTRUE 102850
102848: GO 102906
102850: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102851: LD_ADDR_VAR 0 9
102855: PUSH
102856: LD_VAR 0 41
102860: PUSH
102861: LD_VAR 0 42
102865: PUSH
102866: LD_VAR 0 43
102870: PUSH
102871: LD_VAR 0 44
102875: PUSH
102876: LD_VAR 0 45
102880: PUSH
102881: LD_VAR 0 46
102885: PUSH
102886: EMPTY
102887: LIST
102888: LIST
102889: LIST
102890: LIST
102891: LIST
102892: LIST
102893: PUSH
102894: LD_VAR 0 4
102898: PUSH
102899: LD_INT 1
102901: PLUS
102902: ARRAY
102903: ST_TO_ADDR
102904: GO 103159
102906: LD_INT 36
102908: DOUBLE
102909: EQUAL
102910: IFTRUE 102914
102912: GO 102970
102914: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102915: LD_ADDR_VAR 0 9
102919: PUSH
102920: LD_VAR 0 47
102924: PUSH
102925: LD_VAR 0 48
102929: PUSH
102930: LD_VAR 0 49
102934: PUSH
102935: LD_VAR 0 50
102939: PUSH
102940: LD_VAR 0 51
102944: PUSH
102945: LD_VAR 0 52
102949: PUSH
102950: EMPTY
102951: LIST
102952: LIST
102953: LIST
102954: LIST
102955: LIST
102956: LIST
102957: PUSH
102958: LD_VAR 0 4
102962: PUSH
102963: LD_INT 1
102965: PLUS
102966: ARRAY
102967: ST_TO_ADDR
102968: GO 103159
102970: LD_INT 4
102972: DOUBLE
102973: EQUAL
102974: IFTRUE 102996
102976: LD_INT 5
102978: DOUBLE
102979: EQUAL
102980: IFTRUE 102996
102982: LD_INT 34
102984: DOUBLE
102985: EQUAL
102986: IFTRUE 102996
102988: LD_INT 37
102990: DOUBLE
102991: EQUAL
102992: IFTRUE 102996
102994: GO 103052
102996: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102997: LD_ADDR_VAR 0 9
103001: PUSH
103002: LD_VAR 0 53
103006: PUSH
103007: LD_VAR 0 54
103011: PUSH
103012: LD_VAR 0 55
103016: PUSH
103017: LD_VAR 0 56
103021: PUSH
103022: LD_VAR 0 57
103026: PUSH
103027: LD_VAR 0 58
103031: PUSH
103032: EMPTY
103033: LIST
103034: LIST
103035: LIST
103036: LIST
103037: LIST
103038: LIST
103039: PUSH
103040: LD_VAR 0 4
103044: PUSH
103045: LD_INT 1
103047: PLUS
103048: ARRAY
103049: ST_TO_ADDR
103050: GO 103159
103052: LD_INT 31
103054: DOUBLE
103055: EQUAL
103056: IFTRUE 103102
103058: LD_INT 32
103060: DOUBLE
103061: EQUAL
103062: IFTRUE 103102
103064: LD_INT 33
103066: DOUBLE
103067: EQUAL
103068: IFTRUE 103102
103070: LD_INT 27
103072: DOUBLE
103073: EQUAL
103074: IFTRUE 103102
103076: LD_INT 26
103078: DOUBLE
103079: EQUAL
103080: IFTRUE 103102
103082: LD_INT 28
103084: DOUBLE
103085: EQUAL
103086: IFTRUE 103102
103088: LD_INT 29
103090: DOUBLE
103091: EQUAL
103092: IFTRUE 103102
103094: LD_INT 30
103096: DOUBLE
103097: EQUAL
103098: IFTRUE 103102
103100: GO 103158
103102: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103103: LD_ADDR_VAR 0 9
103107: PUSH
103108: LD_VAR 0 59
103112: PUSH
103113: LD_VAR 0 60
103117: PUSH
103118: LD_VAR 0 61
103122: PUSH
103123: LD_VAR 0 62
103127: PUSH
103128: LD_VAR 0 63
103132: PUSH
103133: LD_VAR 0 64
103137: PUSH
103138: EMPTY
103139: LIST
103140: LIST
103141: LIST
103142: LIST
103143: LIST
103144: LIST
103145: PUSH
103146: LD_VAR 0 4
103150: PUSH
103151: LD_INT 1
103153: PLUS
103154: ARRAY
103155: ST_TO_ADDR
103156: GO 103159
103158: POP
// temp_list2 = [ ] ;
103159: LD_ADDR_VAR 0 10
103163: PUSH
103164: EMPTY
103165: ST_TO_ADDR
// for i in temp_list do
103166: LD_ADDR_VAR 0 8
103170: PUSH
103171: LD_VAR 0 9
103175: PUSH
103176: FOR_IN
103177: IFFALSE 103229
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103179: LD_ADDR_VAR 0 10
103183: PUSH
103184: LD_VAR 0 10
103188: PUSH
103189: LD_VAR 0 8
103193: PUSH
103194: LD_INT 1
103196: ARRAY
103197: PUSH
103198: LD_VAR 0 2
103202: PLUS
103203: PUSH
103204: LD_VAR 0 8
103208: PUSH
103209: LD_INT 2
103211: ARRAY
103212: PUSH
103213: LD_VAR 0 3
103217: PLUS
103218: PUSH
103219: EMPTY
103220: LIST
103221: LIST
103222: PUSH
103223: EMPTY
103224: LIST
103225: ADD
103226: ST_TO_ADDR
103227: GO 103176
103229: POP
103230: POP
// result = temp_list2 ;
103231: LD_ADDR_VAR 0 7
103235: PUSH
103236: LD_VAR 0 10
103240: ST_TO_ADDR
// end ;
103241: LD_VAR 0 7
103245: RET
// export function EnemyInRange ( unit , dist ) ; begin
103246: LD_INT 0
103248: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
103249: LD_ADDR_VAR 0 3
103253: PUSH
103254: LD_VAR 0 1
103258: PPUSH
103259: CALL_OW 255
103263: PPUSH
103264: LD_VAR 0 1
103268: PPUSH
103269: CALL_OW 250
103273: PPUSH
103274: LD_VAR 0 1
103278: PPUSH
103279: CALL_OW 251
103283: PPUSH
103284: LD_VAR 0 2
103288: PPUSH
103289: CALL 76619 0 4
103293: PUSH
103294: LD_INT 4
103296: ARRAY
103297: ST_TO_ADDR
// end ;
103298: LD_VAR 0 3
103302: RET
// export function PlayerSeeMe ( unit ) ; begin
103303: LD_INT 0
103305: PPUSH
// result := See ( your_side , unit ) ;
103306: LD_ADDR_VAR 0 2
103310: PUSH
103311: LD_OWVAR 2
103315: PPUSH
103316: LD_VAR 0 1
103320: PPUSH
103321: CALL_OW 292
103325: ST_TO_ADDR
// end ;
103326: LD_VAR 0 2
103330: RET
// export function ReverseDir ( unit ) ; begin
103331: LD_INT 0
103333: PPUSH
// if not unit then
103334: LD_VAR 0 1
103338: NOT
103339: IFFALSE 103343
// exit ;
103341: GO 103366
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
103343: LD_ADDR_VAR 0 2
103347: PUSH
103348: LD_VAR 0 1
103352: PPUSH
103353: CALL_OW 254
103357: PUSH
103358: LD_INT 3
103360: PLUS
103361: PUSH
103362: LD_INT 6
103364: MOD
103365: ST_TO_ADDR
// end ;
103366: LD_VAR 0 2
103370: RET
// export function ReverseArray ( array ) ; var i ; begin
103371: LD_INT 0
103373: PPUSH
103374: PPUSH
// if not array then
103375: LD_VAR 0 1
103379: NOT
103380: IFFALSE 103384
// exit ;
103382: GO 103439
// result := [ ] ;
103384: LD_ADDR_VAR 0 2
103388: PUSH
103389: EMPTY
103390: ST_TO_ADDR
// for i := array downto 1 do
103391: LD_ADDR_VAR 0 3
103395: PUSH
103396: DOUBLE
103397: LD_VAR 0 1
103401: INC
103402: ST_TO_ADDR
103403: LD_INT 1
103405: PUSH
103406: FOR_DOWNTO
103407: IFFALSE 103437
// result := Join ( result , array [ i ] ) ;
103409: LD_ADDR_VAR 0 2
103413: PUSH
103414: LD_VAR 0 2
103418: PPUSH
103419: LD_VAR 0 1
103423: PUSH
103424: LD_VAR 0 3
103428: ARRAY
103429: PPUSH
103430: CALL 108104 0 2
103434: ST_TO_ADDR
103435: GO 103406
103437: POP
103438: POP
// end ;
103439: LD_VAR 0 2
103443: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
103444: LD_INT 0
103446: PPUSH
103447: PPUSH
103448: PPUSH
103449: PPUSH
103450: PPUSH
103451: PPUSH
// if not unit or not hexes then
103452: LD_VAR 0 1
103456: NOT
103457: PUSH
103458: LD_VAR 0 2
103462: NOT
103463: OR
103464: IFFALSE 103468
// exit ;
103466: GO 103591
// dist := 9999 ;
103468: LD_ADDR_VAR 0 5
103472: PUSH
103473: LD_INT 9999
103475: ST_TO_ADDR
// for i = 1 to hexes do
103476: LD_ADDR_VAR 0 4
103480: PUSH
103481: DOUBLE
103482: LD_INT 1
103484: DEC
103485: ST_TO_ADDR
103486: LD_VAR 0 2
103490: PUSH
103491: FOR_TO
103492: IFFALSE 103579
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
103494: LD_ADDR_VAR 0 6
103498: PUSH
103499: LD_VAR 0 1
103503: PPUSH
103504: LD_VAR 0 2
103508: PUSH
103509: LD_VAR 0 4
103513: ARRAY
103514: PUSH
103515: LD_INT 1
103517: ARRAY
103518: PPUSH
103519: LD_VAR 0 2
103523: PUSH
103524: LD_VAR 0 4
103528: ARRAY
103529: PUSH
103530: LD_INT 2
103532: ARRAY
103533: PPUSH
103534: CALL_OW 297
103538: ST_TO_ADDR
// if tdist < dist then
103539: LD_VAR 0 6
103543: PUSH
103544: LD_VAR 0 5
103548: LESS
103549: IFFALSE 103577
// begin hex := hexes [ i ] ;
103551: LD_ADDR_VAR 0 8
103555: PUSH
103556: LD_VAR 0 2
103560: PUSH
103561: LD_VAR 0 4
103565: ARRAY
103566: ST_TO_ADDR
// dist := tdist ;
103567: LD_ADDR_VAR 0 5
103571: PUSH
103572: LD_VAR 0 6
103576: ST_TO_ADDR
// end ; end ;
103577: GO 103491
103579: POP
103580: POP
// result := hex ;
103581: LD_ADDR_VAR 0 3
103585: PUSH
103586: LD_VAR 0 8
103590: ST_TO_ADDR
// end ;
103591: LD_VAR 0 3
103595: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
103596: LD_INT 0
103598: PPUSH
103599: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103600: LD_VAR 0 1
103604: NOT
103605: PUSH
103606: LD_VAR 0 1
103610: PUSH
103611: LD_INT 21
103613: PUSH
103614: LD_INT 2
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: PUSH
103621: LD_INT 23
103623: PUSH
103624: LD_INT 2
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: PUSH
103631: EMPTY
103632: LIST
103633: LIST
103634: PPUSH
103635: CALL_OW 69
103639: IN
103640: NOT
103641: OR
103642: IFFALSE 103646
// exit ;
103644: GO 103693
// for i = 1 to 3 do
103646: LD_ADDR_VAR 0 3
103650: PUSH
103651: DOUBLE
103652: LD_INT 1
103654: DEC
103655: ST_TO_ADDR
103656: LD_INT 3
103658: PUSH
103659: FOR_TO
103660: IFFALSE 103691
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
103662: LD_VAR 0 1
103666: PPUSH
103667: CALL_OW 250
103671: PPUSH
103672: LD_VAR 0 1
103676: PPUSH
103677: CALL_OW 251
103681: PPUSH
103682: LD_INT 1
103684: PPUSH
103685: CALL_OW 453
103689: GO 103659
103691: POP
103692: POP
// end ;
103693: LD_VAR 0 2
103697: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
103698: LD_INT 0
103700: PPUSH
103701: PPUSH
103702: PPUSH
103703: PPUSH
103704: PPUSH
103705: PPUSH
// if not unit or not enemy_unit then
103706: LD_VAR 0 1
103710: NOT
103711: PUSH
103712: LD_VAR 0 2
103716: NOT
103717: OR
103718: IFFALSE 103722
// exit ;
103720: GO 104189
// if GetLives ( i ) < 250 then
103722: LD_VAR 0 4
103726: PPUSH
103727: CALL_OW 256
103731: PUSH
103732: LD_INT 250
103734: LESS
103735: IFFALSE 103748
// begin ComAutodestruct ( i ) ;
103737: LD_VAR 0 4
103741: PPUSH
103742: CALL 103596 0 1
// exit ;
103746: GO 104189
// end ; x := GetX ( enemy_unit ) ;
103748: LD_ADDR_VAR 0 7
103752: PUSH
103753: LD_VAR 0 2
103757: PPUSH
103758: CALL_OW 250
103762: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
103763: LD_ADDR_VAR 0 8
103767: PUSH
103768: LD_VAR 0 2
103772: PPUSH
103773: CALL_OW 251
103777: ST_TO_ADDR
// if not x or not y then
103778: LD_VAR 0 7
103782: NOT
103783: PUSH
103784: LD_VAR 0 8
103788: NOT
103789: OR
103790: IFFALSE 103794
// exit ;
103792: GO 104189
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
103794: LD_ADDR_VAR 0 6
103798: PUSH
103799: LD_VAR 0 7
103803: PPUSH
103804: LD_INT 0
103806: PPUSH
103807: LD_INT 4
103809: PPUSH
103810: CALL_OW 272
103814: PUSH
103815: LD_VAR 0 8
103819: PPUSH
103820: LD_INT 0
103822: PPUSH
103823: LD_INT 4
103825: PPUSH
103826: CALL_OW 273
103830: PUSH
103831: EMPTY
103832: LIST
103833: LIST
103834: PUSH
103835: LD_VAR 0 7
103839: PPUSH
103840: LD_INT 1
103842: PPUSH
103843: LD_INT 4
103845: PPUSH
103846: CALL_OW 272
103850: PUSH
103851: LD_VAR 0 8
103855: PPUSH
103856: LD_INT 1
103858: PPUSH
103859: LD_INT 4
103861: PPUSH
103862: CALL_OW 273
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: PUSH
103871: LD_VAR 0 7
103875: PPUSH
103876: LD_INT 2
103878: PPUSH
103879: LD_INT 4
103881: PPUSH
103882: CALL_OW 272
103886: PUSH
103887: LD_VAR 0 8
103891: PPUSH
103892: LD_INT 2
103894: PPUSH
103895: LD_INT 4
103897: PPUSH
103898: CALL_OW 273
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PUSH
103907: LD_VAR 0 7
103911: PPUSH
103912: LD_INT 3
103914: PPUSH
103915: LD_INT 4
103917: PPUSH
103918: CALL_OW 272
103922: PUSH
103923: LD_VAR 0 8
103927: PPUSH
103928: LD_INT 3
103930: PPUSH
103931: LD_INT 4
103933: PPUSH
103934: CALL_OW 273
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: PUSH
103943: LD_VAR 0 7
103947: PPUSH
103948: LD_INT 4
103950: PPUSH
103951: LD_INT 4
103953: PPUSH
103954: CALL_OW 272
103958: PUSH
103959: LD_VAR 0 8
103963: PPUSH
103964: LD_INT 4
103966: PPUSH
103967: LD_INT 4
103969: PPUSH
103970: CALL_OW 273
103974: PUSH
103975: EMPTY
103976: LIST
103977: LIST
103978: PUSH
103979: LD_VAR 0 7
103983: PPUSH
103984: LD_INT 5
103986: PPUSH
103987: LD_INT 4
103989: PPUSH
103990: CALL_OW 272
103994: PUSH
103995: LD_VAR 0 8
103999: PPUSH
104000: LD_INT 5
104002: PPUSH
104003: LD_INT 4
104005: PPUSH
104006: CALL_OW 273
104010: PUSH
104011: EMPTY
104012: LIST
104013: LIST
104014: PUSH
104015: EMPTY
104016: LIST
104017: LIST
104018: LIST
104019: LIST
104020: LIST
104021: LIST
104022: ST_TO_ADDR
// for i = tmp downto 1 do
104023: LD_ADDR_VAR 0 4
104027: PUSH
104028: DOUBLE
104029: LD_VAR 0 6
104033: INC
104034: ST_TO_ADDR
104035: LD_INT 1
104037: PUSH
104038: FOR_DOWNTO
104039: IFFALSE 104140
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
104041: LD_VAR 0 6
104045: PUSH
104046: LD_VAR 0 4
104050: ARRAY
104051: PUSH
104052: LD_INT 1
104054: ARRAY
104055: PPUSH
104056: LD_VAR 0 6
104060: PUSH
104061: LD_VAR 0 4
104065: ARRAY
104066: PUSH
104067: LD_INT 2
104069: ARRAY
104070: PPUSH
104071: CALL_OW 488
104075: NOT
104076: PUSH
104077: LD_VAR 0 6
104081: PUSH
104082: LD_VAR 0 4
104086: ARRAY
104087: PUSH
104088: LD_INT 1
104090: ARRAY
104091: PPUSH
104092: LD_VAR 0 6
104096: PUSH
104097: LD_VAR 0 4
104101: ARRAY
104102: PUSH
104103: LD_INT 2
104105: ARRAY
104106: PPUSH
104107: CALL_OW 428
104111: PUSH
104112: LD_INT 0
104114: NONEQUAL
104115: OR
104116: IFFALSE 104138
// tmp := Delete ( tmp , i ) ;
104118: LD_ADDR_VAR 0 6
104122: PUSH
104123: LD_VAR 0 6
104127: PPUSH
104128: LD_VAR 0 4
104132: PPUSH
104133: CALL_OW 3
104137: ST_TO_ADDR
104138: GO 104038
104140: POP
104141: POP
// j := GetClosestHex ( unit , tmp ) ;
104142: LD_ADDR_VAR 0 5
104146: PUSH
104147: LD_VAR 0 1
104151: PPUSH
104152: LD_VAR 0 6
104156: PPUSH
104157: CALL 103444 0 2
104161: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104162: LD_VAR 0 1
104166: PPUSH
104167: LD_VAR 0 5
104171: PUSH
104172: LD_INT 1
104174: ARRAY
104175: PPUSH
104176: LD_VAR 0 5
104180: PUSH
104181: LD_INT 2
104183: ARRAY
104184: PPUSH
104185: CALL_OW 111
// end ;
104189: LD_VAR 0 3
104193: RET
// export function PrepareApemanSoldier ( ) ; begin
104194: LD_INT 0
104196: PPUSH
// uc_nation := 0 ;
104197: LD_ADDR_OWVAR 21
104201: PUSH
104202: LD_INT 0
104204: ST_TO_ADDR
// hc_sex := sex_male ;
104205: LD_ADDR_OWVAR 27
104209: PUSH
104210: LD_INT 1
104212: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
104213: LD_ADDR_OWVAR 28
104217: PUSH
104218: LD_INT 15
104220: ST_TO_ADDR
// hc_gallery :=  ;
104221: LD_ADDR_OWVAR 33
104225: PUSH
104226: LD_STRING 
104228: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104229: LD_ADDR_OWVAR 31
104233: PUSH
104234: LD_INT 0
104236: PPUSH
104237: LD_INT 3
104239: PPUSH
104240: CALL_OW 12
104244: PUSH
104245: LD_INT 0
104247: PPUSH
104248: LD_INT 3
104250: PPUSH
104251: CALL_OW 12
104255: PUSH
104256: LD_INT 0
104258: PUSH
104259: LD_INT 0
104261: PUSH
104262: EMPTY
104263: LIST
104264: LIST
104265: LIST
104266: LIST
104267: ST_TO_ADDR
// end ;
104268: LD_VAR 0 1
104272: RET
// export function PrepareApemanEngineer ( ) ; begin
104273: LD_INT 0
104275: PPUSH
// uc_nation := 0 ;
104276: LD_ADDR_OWVAR 21
104280: PUSH
104281: LD_INT 0
104283: ST_TO_ADDR
// hc_sex := sex_male ;
104284: LD_ADDR_OWVAR 27
104288: PUSH
104289: LD_INT 1
104291: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
104292: LD_ADDR_OWVAR 28
104296: PUSH
104297: LD_INT 16
104299: ST_TO_ADDR
// hc_gallery :=  ;
104300: LD_ADDR_OWVAR 33
104304: PUSH
104305: LD_STRING 
104307: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104308: LD_ADDR_OWVAR 31
104312: PUSH
104313: LD_INT 0
104315: PPUSH
104316: LD_INT 3
104318: PPUSH
104319: CALL_OW 12
104323: PUSH
104324: LD_INT 0
104326: PPUSH
104327: LD_INT 3
104329: PPUSH
104330: CALL_OW 12
104334: PUSH
104335: LD_INT 0
104337: PUSH
104338: LD_INT 0
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: LIST
104345: LIST
104346: ST_TO_ADDR
// end ;
104347: LD_VAR 0 1
104351: RET
// export function PrepareApeman ( agressivity ) ; begin
104352: LD_INT 0
104354: PPUSH
// uc_side := 0 ;
104355: LD_ADDR_OWVAR 20
104359: PUSH
104360: LD_INT 0
104362: ST_TO_ADDR
// uc_nation := 0 ;
104363: LD_ADDR_OWVAR 21
104367: PUSH
104368: LD_INT 0
104370: ST_TO_ADDR
// hc_sex := sex_male ;
104371: LD_ADDR_OWVAR 27
104375: PUSH
104376: LD_INT 1
104378: ST_TO_ADDR
// hc_class := class_apeman ;
104379: LD_ADDR_OWVAR 28
104383: PUSH
104384: LD_INT 12
104386: ST_TO_ADDR
// hc_gallery :=  ;
104387: LD_ADDR_OWVAR 33
104391: PUSH
104392: LD_STRING 
104394: ST_TO_ADDR
// if agressivity = 0 then
104395: LD_VAR 0 1
104399: PUSH
104400: LD_INT 0
104402: EQUAL
104403: IFFALSE 104415
// hc_agressivity := 0 else
104405: LD_ADDR_OWVAR 35
104409: PUSH
104410: LD_INT 0
104412: ST_TO_ADDR
104413: GO 104436
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104415: LD_ADDR_OWVAR 35
104419: PUSH
104420: LD_VAR 0 1
104424: NEG
104425: PPUSH
104426: LD_VAR 0 1
104430: PPUSH
104431: CALL_OW 12
104435: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
104436: LD_ADDR_OWVAR 31
104440: PUSH
104441: LD_INT 0
104443: PPUSH
104444: LD_INT 3
104446: PPUSH
104447: CALL_OW 12
104451: PUSH
104452: LD_INT 0
104454: PPUSH
104455: LD_INT 3
104457: PPUSH
104458: CALL_OW 12
104462: PUSH
104463: LD_INT 0
104465: PUSH
104466: LD_INT 0
104468: PUSH
104469: EMPTY
104470: LIST
104471: LIST
104472: LIST
104473: LIST
104474: ST_TO_ADDR
// end ;
104475: LD_VAR 0 2
104479: RET
// export function PrepareTiger ( agressivity ) ; begin
104480: LD_INT 0
104482: PPUSH
// uc_side := 0 ;
104483: LD_ADDR_OWVAR 20
104487: PUSH
104488: LD_INT 0
104490: ST_TO_ADDR
// uc_nation := 0 ;
104491: LD_ADDR_OWVAR 21
104495: PUSH
104496: LD_INT 0
104498: ST_TO_ADDR
// hc_class := class_tiger ;
104499: LD_ADDR_OWVAR 28
104503: PUSH
104504: LD_INT 14
104506: ST_TO_ADDR
// hc_gallery :=  ;
104507: LD_ADDR_OWVAR 33
104511: PUSH
104512: LD_STRING 
104514: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
104515: LD_ADDR_OWVAR 35
104519: PUSH
104520: LD_VAR 0 1
104524: NEG
104525: PPUSH
104526: LD_VAR 0 1
104530: PPUSH
104531: CALL_OW 12
104535: ST_TO_ADDR
// end ;
104536: LD_VAR 0 2
104540: RET
// export function PrepareEnchidna ( ) ; begin
104541: LD_INT 0
104543: PPUSH
// uc_side := 0 ;
104544: LD_ADDR_OWVAR 20
104548: PUSH
104549: LD_INT 0
104551: ST_TO_ADDR
// uc_nation := 0 ;
104552: LD_ADDR_OWVAR 21
104556: PUSH
104557: LD_INT 0
104559: ST_TO_ADDR
// hc_class := class_baggie ;
104560: LD_ADDR_OWVAR 28
104564: PUSH
104565: LD_INT 13
104567: ST_TO_ADDR
// hc_gallery :=  ;
104568: LD_ADDR_OWVAR 33
104572: PUSH
104573: LD_STRING 
104575: ST_TO_ADDR
// end ;
104576: LD_VAR 0 1
104580: RET
// export function PrepareFrog ( ) ; begin
104581: LD_INT 0
104583: PPUSH
// uc_side := 0 ;
104584: LD_ADDR_OWVAR 20
104588: PUSH
104589: LD_INT 0
104591: ST_TO_ADDR
// uc_nation := 0 ;
104592: LD_ADDR_OWVAR 21
104596: PUSH
104597: LD_INT 0
104599: ST_TO_ADDR
// hc_class := class_frog ;
104600: LD_ADDR_OWVAR 28
104604: PUSH
104605: LD_INT 19
104607: ST_TO_ADDR
// hc_gallery :=  ;
104608: LD_ADDR_OWVAR 33
104612: PUSH
104613: LD_STRING 
104615: ST_TO_ADDR
// end ;
104616: LD_VAR 0 1
104620: RET
// export function PrepareFish ( ) ; begin
104621: LD_INT 0
104623: PPUSH
// uc_side := 0 ;
104624: LD_ADDR_OWVAR 20
104628: PUSH
104629: LD_INT 0
104631: ST_TO_ADDR
// uc_nation := 0 ;
104632: LD_ADDR_OWVAR 21
104636: PUSH
104637: LD_INT 0
104639: ST_TO_ADDR
// hc_class := class_fish ;
104640: LD_ADDR_OWVAR 28
104644: PUSH
104645: LD_INT 20
104647: ST_TO_ADDR
// hc_gallery :=  ;
104648: LD_ADDR_OWVAR 33
104652: PUSH
104653: LD_STRING 
104655: ST_TO_ADDR
// end ;
104656: LD_VAR 0 1
104660: RET
// export function PrepareBird ( ) ; begin
104661: LD_INT 0
104663: PPUSH
// uc_side := 0 ;
104664: LD_ADDR_OWVAR 20
104668: PUSH
104669: LD_INT 0
104671: ST_TO_ADDR
// uc_nation := 0 ;
104672: LD_ADDR_OWVAR 21
104676: PUSH
104677: LD_INT 0
104679: ST_TO_ADDR
// hc_class := class_phororhacos ;
104680: LD_ADDR_OWVAR 28
104684: PUSH
104685: LD_INT 18
104687: ST_TO_ADDR
// hc_gallery :=  ;
104688: LD_ADDR_OWVAR 33
104692: PUSH
104693: LD_STRING 
104695: ST_TO_ADDR
// end ;
104696: LD_VAR 0 1
104700: RET
// export function PrepareHorse ( ) ; begin
104701: LD_INT 0
104703: PPUSH
// uc_side := 0 ;
104704: LD_ADDR_OWVAR 20
104708: PUSH
104709: LD_INT 0
104711: ST_TO_ADDR
// uc_nation := 0 ;
104712: LD_ADDR_OWVAR 21
104716: PUSH
104717: LD_INT 0
104719: ST_TO_ADDR
// hc_class := class_horse ;
104720: LD_ADDR_OWVAR 28
104724: PUSH
104725: LD_INT 21
104727: ST_TO_ADDR
// hc_gallery :=  ;
104728: LD_ADDR_OWVAR 33
104732: PUSH
104733: LD_STRING 
104735: ST_TO_ADDR
// end ;
104736: LD_VAR 0 1
104740: RET
// export function PrepareMastodont ( ) ; begin
104741: LD_INT 0
104743: PPUSH
// uc_side := 0 ;
104744: LD_ADDR_OWVAR 20
104748: PUSH
104749: LD_INT 0
104751: ST_TO_ADDR
// uc_nation := 0 ;
104752: LD_ADDR_OWVAR 21
104756: PUSH
104757: LD_INT 0
104759: ST_TO_ADDR
// vc_chassis := class_mastodont ;
104760: LD_ADDR_OWVAR 37
104764: PUSH
104765: LD_INT 31
104767: ST_TO_ADDR
// vc_control := control_rider ;
104768: LD_ADDR_OWVAR 38
104772: PUSH
104773: LD_INT 4
104775: ST_TO_ADDR
// end ;
104776: LD_VAR 0 1
104780: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
104781: LD_INT 0
104783: PPUSH
104784: PPUSH
104785: PPUSH
// uc_side = 0 ;
104786: LD_ADDR_OWVAR 20
104790: PUSH
104791: LD_INT 0
104793: ST_TO_ADDR
// uc_nation = 0 ;
104794: LD_ADDR_OWVAR 21
104798: PUSH
104799: LD_INT 0
104801: ST_TO_ADDR
// InitHc_All ( ) ;
104802: CALL_OW 584
// InitVc ;
104806: CALL_OW 20
// if mastodonts then
104810: LD_VAR 0 6
104814: IFFALSE 104881
// for i = 1 to mastodonts do
104816: LD_ADDR_VAR 0 11
104820: PUSH
104821: DOUBLE
104822: LD_INT 1
104824: DEC
104825: ST_TO_ADDR
104826: LD_VAR 0 6
104830: PUSH
104831: FOR_TO
104832: IFFALSE 104879
// begin vc_chassis := 31 ;
104834: LD_ADDR_OWVAR 37
104838: PUSH
104839: LD_INT 31
104841: ST_TO_ADDR
// vc_control := control_rider ;
104842: LD_ADDR_OWVAR 38
104846: PUSH
104847: LD_INT 4
104849: ST_TO_ADDR
// animal := CreateVehicle ;
104850: LD_ADDR_VAR 0 12
104854: PUSH
104855: CALL_OW 45
104859: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104860: LD_VAR 0 12
104864: PPUSH
104865: LD_VAR 0 8
104869: PPUSH
104870: LD_INT 0
104872: PPUSH
104873: CALL 107009 0 3
// end ;
104877: GO 104831
104879: POP
104880: POP
// if horses then
104881: LD_VAR 0 5
104885: IFFALSE 104952
// for i = 1 to horses do
104887: LD_ADDR_VAR 0 11
104891: PUSH
104892: DOUBLE
104893: LD_INT 1
104895: DEC
104896: ST_TO_ADDR
104897: LD_VAR 0 5
104901: PUSH
104902: FOR_TO
104903: IFFALSE 104950
// begin hc_class := 21 ;
104905: LD_ADDR_OWVAR 28
104909: PUSH
104910: LD_INT 21
104912: ST_TO_ADDR
// hc_gallery :=  ;
104913: LD_ADDR_OWVAR 33
104917: PUSH
104918: LD_STRING 
104920: ST_TO_ADDR
// animal := CreateHuman ;
104921: LD_ADDR_VAR 0 12
104925: PUSH
104926: CALL_OW 44
104930: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104931: LD_VAR 0 12
104935: PPUSH
104936: LD_VAR 0 8
104940: PPUSH
104941: LD_INT 0
104943: PPUSH
104944: CALL 107009 0 3
// end ;
104948: GO 104902
104950: POP
104951: POP
// if birds then
104952: LD_VAR 0 1
104956: IFFALSE 105023
// for i = 1 to birds do
104958: LD_ADDR_VAR 0 11
104962: PUSH
104963: DOUBLE
104964: LD_INT 1
104966: DEC
104967: ST_TO_ADDR
104968: LD_VAR 0 1
104972: PUSH
104973: FOR_TO
104974: IFFALSE 105021
// begin hc_class := 18 ;
104976: LD_ADDR_OWVAR 28
104980: PUSH
104981: LD_INT 18
104983: ST_TO_ADDR
// hc_gallery =  ;
104984: LD_ADDR_OWVAR 33
104988: PUSH
104989: LD_STRING 
104991: ST_TO_ADDR
// animal := CreateHuman ;
104992: LD_ADDR_VAR 0 12
104996: PUSH
104997: CALL_OW 44
105001: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105002: LD_VAR 0 12
105006: PPUSH
105007: LD_VAR 0 8
105011: PPUSH
105012: LD_INT 0
105014: PPUSH
105015: CALL 107009 0 3
// end ;
105019: GO 104973
105021: POP
105022: POP
// if tigers then
105023: LD_VAR 0 2
105027: IFFALSE 105111
// for i = 1 to tigers do
105029: LD_ADDR_VAR 0 11
105033: PUSH
105034: DOUBLE
105035: LD_INT 1
105037: DEC
105038: ST_TO_ADDR
105039: LD_VAR 0 2
105043: PUSH
105044: FOR_TO
105045: IFFALSE 105109
// begin hc_class = class_tiger ;
105047: LD_ADDR_OWVAR 28
105051: PUSH
105052: LD_INT 14
105054: ST_TO_ADDR
// hc_gallery =  ;
105055: LD_ADDR_OWVAR 33
105059: PUSH
105060: LD_STRING 
105062: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
105063: LD_ADDR_OWVAR 35
105067: PUSH
105068: LD_INT 7
105070: NEG
105071: PPUSH
105072: LD_INT 7
105074: PPUSH
105075: CALL_OW 12
105079: ST_TO_ADDR
// animal := CreateHuman ;
105080: LD_ADDR_VAR 0 12
105084: PUSH
105085: CALL_OW 44
105089: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105090: LD_VAR 0 12
105094: PPUSH
105095: LD_VAR 0 8
105099: PPUSH
105100: LD_INT 0
105102: PPUSH
105103: CALL 107009 0 3
// end ;
105107: GO 105044
105109: POP
105110: POP
// if apemans then
105111: LD_VAR 0 3
105115: IFFALSE 105238
// for i = 1 to apemans do
105117: LD_ADDR_VAR 0 11
105121: PUSH
105122: DOUBLE
105123: LD_INT 1
105125: DEC
105126: ST_TO_ADDR
105127: LD_VAR 0 3
105131: PUSH
105132: FOR_TO
105133: IFFALSE 105236
// begin hc_class = class_apeman ;
105135: LD_ADDR_OWVAR 28
105139: PUSH
105140: LD_INT 12
105142: ST_TO_ADDR
// hc_gallery =  ;
105143: LD_ADDR_OWVAR 33
105147: PUSH
105148: LD_STRING 
105150: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
105151: LD_ADDR_OWVAR 35
105155: PUSH
105156: LD_INT 2
105158: NEG
105159: PPUSH
105160: LD_INT 2
105162: PPUSH
105163: CALL_OW 12
105167: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
105168: LD_ADDR_OWVAR 31
105172: PUSH
105173: LD_INT 1
105175: PPUSH
105176: LD_INT 3
105178: PPUSH
105179: CALL_OW 12
105183: PUSH
105184: LD_INT 1
105186: PPUSH
105187: LD_INT 3
105189: PPUSH
105190: CALL_OW 12
105194: PUSH
105195: LD_INT 0
105197: PUSH
105198: LD_INT 0
105200: PUSH
105201: EMPTY
105202: LIST
105203: LIST
105204: LIST
105205: LIST
105206: ST_TO_ADDR
// animal := CreateHuman ;
105207: LD_ADDR_VAR 0 12
105211: PUSH
105212: CALL_OW 44
105216: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105217: LD_VAR 0 12
105221: PPUSH
105222: LD_VAR 0 8
105226: PPUSH
105227: LD_INT 0
105229: PPUSH
105230: CALL 107009 0 3
// end ;
105234: GO 105132
105236: POP
105237: POP
// if enchidnas then
105238: LD_VAR 0 4
105242: IFFALSE 105309
// for i = 1 to enchidnas do
105244: LD_ADDR_VAR 0 11
105248: PUSH
105249: DOUBLE
105250: LD_INT 1
105252: DEC
105253: ST_TO_ADDR
105254: LD_VAR 0 4
105258: PUSH
105259: FOR_TO
105260: IFFALSE 105307
// begin hc_class = 13 ;
105262: LD_ADDR_OWVAR 28
105266: PUSH
105267: LD_INT 13
105269: ST_TO_ADDR
// hc_gallery =  ;
105270: LD_ADDR_OWVAR 33
105274: PUSH
105275: LD_STRING 
105277: ST_TO_ADDR
// animal := CreateHuman ;
105278: LD_ADDR_VAR 0 12
105282: PUSH
105283: CALL_OW 44
105287: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105288: LD_VAR 0 12
105292: PPUSH
105293: LD_VAR 0 8
105297: PPUSH
105298: LD_INT 0
105300: PPUSH
105301: CALL 107009 0 3
// end ;
105305: GO 105259
105307: POP
105308: POP
// if fishes then
105309: LD_VAR 0 7
105313: IFFALSE 105380
// for i = 1 to fishes do
105315: LD_ADDR_VAR 0 11
105319: PUSH
105320: DOUBLE
105321: LD_INT 1
105323: DEC
105324: ST_TO_ADDR
105325: LD_VAR 0 7
105329: PUSH
105330: FOR_TO
105331: IFFALSE 105378
// begin hc_class = 20 ;
105333: LD_ADDR_OWVAR 28
105337: PUSH
105338: LD_INT 20
105340: ST_TO_ADDR
// hc_gallery =  ;
105341: LD_ADDR_OWVAR 33
105345: PUSH
105346: LD_STRING 
105348: ST_TO_ADDR
// animal := CreateHuman ;
105349: LD_ADDR_VAR 0 12
105353: PUSH
105354: CALL_OW 44
105358: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
105359: LD_VAR 0 12
105363: PPUSH
105364: LD_VAR 0 9
105368: PPUSH
105369: LD_INT 0
105371: PPUSH
105372: CALL 107009 0 3
// end ;
105376: GO 105330
105378: POP
105379: POP
// end ;
105380: LD_VAR 0 10
105384: RET
// export function WantHeal ( sci , unit ) ; begin
105385: LD_INT 0
105387: PPUSH
// if GetTaskList ( sci ) > 0 then
105388: LD_VAR 0 1
105392: PPUSH
105393: CALL_OW 437
105397: PUSH
105398: LD_INT 0
105400: GREATER
105401: IFFALSE 105471
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
105403: LD_VAR 0 1
105407: PPUSH
105408: CALL_OW 437
105412: PUSH
105413: LD_INT 1
105415: ARRAY
105416: PUSH
105417: LD_INT 1
105419: ARRAY
105420: PUSH
105421: LD_STRING l
105423: EQUAL
105424: PUSH
105425: LD_VAR 0 1
105429: PPUSH
105430: CALL_OW 437
105434: PUSH
105435: LD_INT 1
105437: ARRAY
105438: PUSH
105439: LD_INT 4
105441: ARRAY
105442: PUSH
105443: LD_VAR 0 2
105447: EQUAL
105448: AND
105449: IFFALSE 105461
// result := true else
105451: LD_ADDR_VAR 0 3
105455: PUSH
105456: LD_INT 1
105458: ST_TO_ADDR
105459: GO 105469
// result := false ;
105461: LD_ADDR_VAR 0 3
105465: PUSH
105466: LD_INT 0
105468: ST_TO_ADDR
// end else
105469: GO 105479
// result := false ;
105471: LD_ADDR_VAR 0 3
105475: PUSH
105476: LD_INT 0
105478: ST_TO_ADDR
// end ;
105479: LD_VAR 0 3
105483: RET
// export function HealTarget ( sci ) ; begin
105484: LD_INT 0
105486: PPUSH
// if not sci then
105487: LD_VAR 0 1
105491: NOT
105492: IFFALSE 105496
// exit ;
105494: GO 105561
// result := 0 ;
105496: LD_ADDR_VAR 0 2
105500: PUSH
105501: LD_INT 0
105503: ST_TO_ADDR
// if GetTaskList ( sci ) then
105504: LD_VAR 0 1
105508: PPUSH
105509: CALL_OW 437
105513: IFFALSE 105561
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
105515: LD_VAR 0 1
105519: PPUSH
105520: CALL_OW 437
105524: PUSH
105525: LD_INT 1
105527: ARRAY
105528: PUSH
105529: LD_INT 1
105531: ARRAY
105532: PUSH
105533: LD_STRING l
105535: EQUAL
105536: IFFALSE 105561
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
105538: LD_ADDR_VAR 0 2
105542: PUSH
105543: LD_VAR 0 1
105547: PPUSH
105548: CALL_OW 437
105552: PUSH
105553: LD_INT 1
105555: ARRAY
105556: PUSH
105557: LD_INT 4
105559: ARRAY
105560: ST_TO_ADDR
// end ;
105561: LD_VAR 0 2
105565: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105566: LD_INT 0
105568: PPUSH
105569: PPUSH
105570: PPUSH
105571: PPUSH
// if not base_units then
105572: LD_VAR 0 1
105576: NOT
105577: IFFALSE 105581
// exit ;
105579: GO 105668
// result := false ;
105581: LD_ADDR_VAR 0 2
105585: PUSH
105586: LD_INT 0
105588: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105589: LD_ADDR_VAR 0 5
105593: PUSH
105594: LD_VAR 0 1
105598: PPUSH
105599: LD_INT 21
105601: PUSH
105602: LD_INT 3
105604: PUSH
105605: EMPTY
105606: LIST
105607: LIST
105608: PPUSH
105609: CALL_OW 72
105613: ST_TO_ADDR
// if not tmp then
105614: LD_VAR 0 5
105618: NOT
105619: IFFALSE 105623
// exit ;
105621: GO 105668
// for i in tmp do
105623: LD_ADDR_VAR 0 3
105627: PUSH
105628: LD_VAR 0 5
105632: PUSH
105633: FOR_IN
105634: IFFALSE 105666
// begin result := EnemyInRange ( i , 22 ) ;
105636: LD_ADDR_VAR 0 2
105640: PUSH
105641: LD_VAR 0 3
105645: PPUSH
105646: LD_INT 22
105648: PPUSH
105649: CALL 103246 0 2
105653: ST_TO_ADDR
// if result then
105654: LD_VAR 0 2
105658: IFFALSE 105664
// exit ;
105660: POP
105661: POP
105662: GO 105668
// end ;
105664: GO 105633
105666: POP
105667: POP
// end ;
105668: LD_VAR 0 2
105672: RET
// export function FilterByTag ( units , tag ) ; begin
105673: LD_INT 0
105675: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
105676: LD_ADDR_VAR 0 3
105680: PUSH
105681: LD_VAR 0 1
105685: PPUSH
105686: LD_INT 120
105688: PUSH
105689: LD_VAR 0 2
105693: PUSH
105694: EMPTY
105695: LIST
105696: LIST
105697: PPUSH
105698: CALL_OW 72
105702: ST_TO_ADDR
// end ;
105703: LD_VAR 0 3
105707: RET
// export function IsDriver ( un ) ; begin
105708: LD_INT 0
105710: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105711: LD_ADDR_VAR 0 2
105715: PUSH
105716: LD_VAR 0 1
105720: PUSH
105721: LD_INT 55
105723: PUSH
105724: EMPTY
105725: LIST
105726: PPUSH
105727: CALL_OW 69
105731: IN
105732: ST_TO_ADDR
// end ;
105733: LD_VAR 0 2
105737: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105738: LD_INT 0
105740: PPUSH
105741: PPUSH
// list := [ ] ;
105742: LD_ADDR_VAR 0 5
105746: PUSH
105747: EMPTY
105748: ST_TO_ADDR
// case d of 0 :
105749: LD_VAR 0 3
105753: PUSH
105754: LD_INT 0
105756: DOUBLE
105757: EQUAL
105758: IFTRUE 105762
105760: GO 105895
105762: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105763: LD_ADDR_VAR 0 5
105767: PUSH
105768: LD_VAR 0 1
105772: PUSH
105773: LD_INT 4
105775: MINUS
105776: PUSH
105777: LD_VAR 0 2
105781: PUSH
105782: LD_INT 4
105784: MINUS
105785: PUSH
105786: LD_INT 2
105788: PUSH
105789: EMPTY
105790: LIST
105791: LIST
105792: LIST
105793: PUSH
105794: LD_VAR 0 1
105798: PUSH
105799: LD_INT 3
105801: MINUS
105802: PUSH
105803: LD_VAR 0 2
105807: PUSH
105808: LD_INT 1
105810: PUSH
105811: EMPTY
105812: LIST
105813: LIST
105814: LIST
105815: PUSH
105816: LD_VAR 0 1
105820: PUSH
105821: LD_INT 4
105823: PLUS
105824: PUSH
105825: LD_VAR 0 2
105829: PUSH
105830: LD_INT 4
105832: PUSH
105833: EMPTY
105834: LIST
105835: LIST
105836: LIST
105837: PUSH
105838: LD_VAR 0 1
105842: PUSH
105843: LD_INT 3
105845: PLUS
105846: PUSH
105847: LD_VAR 0 2
105851: PUSH
105852: LD_INT 3
105854: PLUS
105855: PUSH
105856: LD_INT 5
105858: PUSH
105859: EMPTY
105860: LIST
105861: LIST
105862: LIST
105863: PUSH
105864: LD_VAR 0 1
105868: PUSH
105869: LD_VAR 0 2
105873: PUSH
105874: LD_INT 4
105876: PLUS
105877: PUSH
105878: LD_INT 0
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: LIST
105885: PUSH
105886: EMPTY
105887: LIST
105888: LIST
105889: LIST
105890: LIST
105891: LIST
105892: ST_TO_ADDR
// end ; 1 :
105893: GO 106593
105895: LD_INT 1
105897: DOUBLE
105898: EQUAL
105899: IFTRUE 105903
105901: GO 106036
105903: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105904: LD_ADDR_VAR 0 5
105908: PUSH
105909: LD_VAR 0 1
105913: PUSH
105914: LD_VAR 0 2
105918: PUSH
105919: LD_INT 4
105921: MINUS
105922: PUSH
105923: LD_INT 3
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: LIST
105930: PUSH
105931: LD_VAR 0 1
105935: PUSH
105936: LD_INT 3
105938: MINUS
105939: PUSH
105940: LD_VAR 0 2
105944: PUSH
105945: LD_INT 3
105947: MINUS
105948: PUSH
105949: LD_INT 2
105951: PUSH
105952: EMPTY
105953: LIST
105954: LIST
105955: LIST
105956: PUSH
105957: LD_VAR 0 1
105961: PUSH
105962: LD_INT 4
105964: MINUS
105965: PUSH
105966: LD_VAR 0 2
105970: PUSH
105971: LD_INT 1
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: LIST
105978: PUSH
105979: LD_VAR 0 1
105983: PUSH
105984: LD_VAR 0 2
105988: PUSH
105989: LD_INT 3
105991: PLUS
105992: PUSH
105993: LD_INT 0
105995: PUSH
105996: EMPTY
105997: LIST
105998: LIST
105999: LIST
106000: PUSH
106001: LD_VAR 0 1
106005: PUSH
106006: LD_INT 4
106008: PLUS
106009: PUSH
106010: LD_VAR 0 2
106014: PUSH
106015: LD_INT 4
106017: PLUS
106018: PUSH
106019: LD_INT 5
106021: PUSH
106022: EMPTY
106023: LIST
106024: LIST
106025: LIST
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: LIST
106031: LIST
106032: LIST
106033: ST_TO_ADDR
// end ; 2 :
106034: GO 106593
106036: LD_INT 2
106038: DOUBLE
106039: EQUAL
106040: IFTRUE 106044
106042: GO 106173
106044: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
106045: LD_ADDR_VAR 0 5
106049: PUSH
106050: LD_VAR 0 1
106054: PUSH
106055: LD_VAR 0 2
106059: PUSH
106060: LD_INT 3
106062: MINUS
106063: PUSH
106064: LD_INT 3
106066: PUSH
106067: EMPTY
106068: LIST
106069: LIST
106070: LIST
106071: PUSH
106072: LD_VAR 0 1
106076: PUSH
106077: LD_INT 4
106079: PLUS
106080: PUSH
106081: LD_VAR 0 2
106085: PUSH
106086: LD_INT 4
106088: PUSH
106089: EMPTY
106090: LIST
106091: LIST
106092: LIST
106093: PUSH
106094: LD_VAR 0 1
106098: PUSH
106099: LD_VAR 0 2
106103: PUSH
106104: LD_INT 4
106106: PLUS
106107: PUSH
106108: LD_INT 0
106110: PUSH
106111: EMPTY
106112: LIST
106113: LIST
106114: LIST
106115: PUSH
106116: LD_VAR 0 1
106120: PUSH
106121: LD_INT 3
106123: MINUS
106124: PUSH
106125: LD_VAR 0 2
106129: PUSH
106130: LD_INT 1
106132: PUSH
106133: EMPTY
106134: LIST
106135: LIST
106136: LIST
106137: PUSH
106138: LD_VAR 0 1
106142: PUSH
106143: LD_INT 4
106145: MINUS
106146: PUSH
106147: LD_VAR 0 2
106151: PUSH
106152: LD_INT 4
106154: MINUS
106155: PUSH
106156: LD_INT 2
106158: PUSH
106159: EMPTY
106160: LIST
106161: LIST
106162: LIST
106163: PUSH
106164: EMPTY
106165: LIST
106166: LIST
106167: LIST
106168: LIST
106169: LIST
106170: ST_TO_ADDR
// end ; 3 :
106171: GO 106593
106173: LD_INT 3
106175: DOUBLE
106176: EQUAL
106177: IFTRUE 106181
106179: GO 106314
106181: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106182: LD_ADDR_VAR 0 5
106186: PUSH
106187: LD_VAR 0 1
106191: PUSH
106192: LD_INT 3
106194: PLUS
106195: PUSH
106196: LD_VAR 0 2
106200: PUSH
106201: LD_INT 4
106203: PUSH
106204: EMPTY
106205: LIST
106206: LIST
106207: LIST
106208: PUSH
106209: LD_VAR 0 1
106213: PUSH
106214: LD_INT 4
106216: PLUS
106217: PUSH
106218: LD_VAR 0 2
106222: PUSH
106223: LD_INT 4
106225: PLUS
106226: PUSH
106227: LD_INT 5
106229: PUSH
106230: EMPTY
106231: LIST
106232: LIST
106233: LIST
106234: PUSH
106235: LD_VAR 0 1
106239: PUSH
106240: LD_INT 4
106242: MINUS
106243: PUSH
106244: LD_VAR 0 2
106248: PUSH
106249: LD_INT 1
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: LIST
106256: PUSH
106257: LD_VAR 0 1
106261: PUSH
106262: LD_VAR 0 2
106266: PUSH
106267: LD_INT 4
106269: MINUS
106270: PUSH
106271: LD_INT 3
106273: PUSH
106274: EMPTY
106275: LIST
106276: LIST
106277: LIST
106278: PUSH
106279: LD_VAR 0 1
106283: PUSH
106284: LD_INT 3
106286: MINUS
106287: PUSH
106288: LD_VAR 0 2
106292: PUSH
106293: LD_INT 3
106295: MINUS
106296: PUSH
106297: LD_INT 2
106299: PUSH
106300: EMPTY
106301: LIST
106302: LIST
106303: LIST
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: LIST
106309: LIST
106310: LIST
106311: ST_TO_ADDR
// end ; 4 :
106312: GO 106593
106314: LD_INT 4
106316: DOUBLE
106317: EQUAL
106318: IFTRUE 106322
106320: GO 106455
106322: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106323: LD_ADDR_VAR 0 5
106327: PUSH
106328: LD_VAR 0 1
106332: PUSH
106333: LD_VAR 0 2
106337: PUSH
106338: LD_INT 4
106340: PLUS
106341: PUSH
106342: LD_INT 0
106344: PUSH
106345: EMPTY
106346: LIST
106347: LIST
106348: LIST
106349: PUSH
106350: LD_VAR 0 1
106354: PUSH
106355: LD_INT 3
106357: PLUS
106358: PUSH
106359: LD_VAR 0 2
106363: PUSH
106364: LD_INT 3
106366: PLUS
106367: PUSH
106368: LD_INT 5
106370: PUSH
106371: EMPTY
106372: LIST
106373: LIST
106374: LIST
106375: PUSH
106376: LD_VAR 0 1
106380: PUSH
106381: LD_INT 4
106383: PLUS
106384: PUSH
106385: LD_VAR 0 2
106389: PUSH
106390: LD_INT 4
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: LIST
106397: PUSH
106398: LD_VAR 0 1
106402: PUSH
106403: LD_VAR 0 2
106407: PUSH
106408: LD_INT 3
106410: MINUS
106411: PUSH
106412: LD_INT 3
106414: PUSH
106415: EMPTY
106416: LIST
106417: LIST
106418: LIST
106419: PUSH
106420: LD_VAR 0 1
106424: PUSH
106425: LD_INT 4
106427: MINUS
106428: PUSH
106429: LD_VAR 0 2
106433: PUSH
106434: LD_INT 4
106436: MINUS
106437: PUSH
106438: LD_INT 2
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: LIST
106445: PUSH
106446: EMPTY
106447: LIST
106448: LIST
106449: LIST
106450: LIST
106451: LIST
106452: ST_TO_ADDR
// end ; 5 :
106453: GO 106593
106455: LD_INT 5
106457: DOUBLE
106458: EQUAL
106459: IFTRUE 106463
106461: GO 106592
106463: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106464: LD_ADDR_VAR 0 5
106468: PUSH
106469: LD_VAR 0 1
106473: PUSH
106474: LD_INT 4
106476: MINUS
106477: PUSH
106478: LD_VAR 0 2
106482: PUSH
106483: LD_INT 1
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: LIST
106490: PUSH
106491: LD_VAR 0 1
106495: PUSH
106496: LD_VAR 0 2
106500: PUSH
106501: LD_INT 4
106503: MINUS
106504: PUSH
106505: LD_INT 3
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: LIST
106512: PUSH
106513: LD_VAR 0 1
106517: PUSH
106518: LD_INT 4
106520: PLUS
106521: PUSH
106522: LD_VAR 0 2
106526: PUSH
106527: LD_INT 4
106529: PLUS
106530: PUSH
106531: LD_INT 5
106533: PUSH
106534: EMPTY
106535: LIST
106536: LIST
106537: LIST
106538: PUSH
106539: LD_VAR 0 1
106543: PUSH
106544: LD_INT 3
106546: PLUS
106547: PUSH
106548: LD_VAR 0 2
106552: PUSH
106553: LD_INT 4
106555: PUSH
106556: EMPTY
106557: LIST
106558: LIST
106559: LIST
106560: PUSH
106561: LD_VAR 0 1
106565: PUSH
106566: LD_VAR 0 2
106570: PUSH
106571: LD_INT 3
106573: PLUS
106574: PUSH
106575: LD_INT 0
106577: PUSH
106578: EMPTY
106579: LIST
106580: LIST
106581: LIST
106582: PUSH
106583: EMPTY
106584: LIST
106585: LIST
106586: LIST
106587: LIST
106588: LIST
106589: ST_TO_ADDR
// end ; end ;
106590: GO 106593
106592: POP
// result := list ;
106593: LD_ADDR_VAR 0 4
106597: PUSH
106598: LD_VAR 0 5
106602: ST_TO_ADDR
// end ;
106603: LD_VAR 0 4
106607: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106608: LD_INT 0
106610: PPUSH
106611: PPUSH
106612: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106613: LD_VAR 0 1
106617: NOT
106618: PUSH
106619: LD_VAR 0 2
106623: PUSH
106624: LD_INT 1
106626: PUSH
106627: LD_INT 2
106629: PUSH
106630: LD_INT 3
106632: PUSH
106633: LD_INT 4
106635: PUSH
106636: EMPTY
106637: LIST
106638: LIST
106639: LIST
106640: LIST
106641: IN
106642: NOT
106643: OR
106644: IFFALSE 106648
// exit ;
106646: GO 106731
// tmp := [ ] ;
106648: LD_ADDR_VAR 0 5
106652: PUSH
106653: EMPTY
106654: ST_TO_ADDR
// for i in units do
106655: LD_ADDR_VAR 0 4
106659: PUSH
106660: LD_VAR 0 1
106664: PUSH
106665: FOR_IN
106666: IFFALSE 106700
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
106668: LD_ADDR_VAR 0 5
106672: PUSH
106673: LD_VAR 0 5
106677: PPUSH
106678: LD_VAR 0 4
106682: PPUSH
106683: LD_VAR 0 2
106687: PPUSH
106688: CALL_OW 259
106692: PPUSH
106693: CALL 108104 0 2
106697: ST_TO_ADDR
106698: GO 106665
106700: POP
106701: POP
// if not tmp then
106702: LD_VAR 0 5
106706: NOT
106707: IFFALSE 106711
// exit ;
106709: GO 106731
// result := SortListByListDesc ( units , tmp ) ;
106711: LD_ADDR_VAR 0 3
106715: PUSH
106716: LD_VAR 0 1
106720: PPUSH
106721: LD_VAR 0 5
106725: PPUSH
106726: CALL_OW 77
106730: ST_TO_ADDR
// end ;
106731: LD_VAR 0 3
106735: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106736: LD_INT 0
106738: PPUSH
106739: PPUSH
106740: PPUSH
// result := false ;
106741: LD_ADDR_VAR 0 3
106745: PUSH
106746: LD_INT 0
106748: ST_TO_ADDR
// if not building then
106749: LD_VAR 0 2
106753: NOT
106754: IFFALSE 106758
// exit ;
106756: GO 106896
// x := GetX ( building ) ;
106758: LD_ADDR_VAR 0 4
106762: PUSH
106763: LD_VAR 0 2
106767: PPUSH
106768: CALL_OW 250
106772: ST_TO_ADDR
// y := GetY ( building ) ;
106773: LD_ADDR_VAR 0 5
106777: PUSH
106778: LD_VAR 0 2
106782: PPUSH
106783: CALL_OW 251
106787: ST_TO_ADDR
// if not x or not y then
106788: LD_VAR 0 4
106792: NOT
106793: PUSH
106794: LD_VAR 0 5
106798: NOT
106799: OR
106800: IFFALSE 106804
// exit ;
106802: GO 106896
// if GetTaskList ( unit ) then
106804: LD_VAR 0 1
106808: PPUSH
106809: CALL_OW 437
106813: IFFALSE 106896
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106815: LD_STRING e
106817: PUSH
106818: LD_VAR 0 1
106822: PPUSH
106823: CALL_OW 437
106827: PUSH
106828: LD_INT 1
106830: ARRAY
106831: PUSH
106832: LD_INT 1
106834: ARRAY
106835: EQUAL
106836: PUSH
106837: LD_VAR 0 4
106841: PUSH
106842: LD_VAR 0 1
106846: PPUSH
106847: CALL_OW 437
106851: PUSH
106852: LD_INT 1
106854: ARRAY
106855: PUSH
106856: LD_INT 2
106858: ARRAY
106859: EQUAL
106860: AND
106861: PUSH
106862: LD_VAR 0 5
106866: PUSH
106867: LD_VAR 0 1
106871: PPUSH
106872: CALL_OW 437
106876: PUSH
106877: LD_INT 1
106879: ARRAY
106880: PUSH
106881: LD_INT 3
106883: ARRAY
106884: EQUAL
106885: AND
106886: IFFALSE 106896
// result := true end ;
106888: LD_ADDR_VAR 0 3
106892: PUSH
106893: LD_INT 1
106895: ST_TO_ADDR
// end ;
106896: LD_VAR 0 3
106900: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106901: LD_INT 0
106903: PPUSH
// result := false ;
106904: LD_ADDR_VAR 0 4
106908: PUSH
106909: LD_INT 0
106911: ST_TO_ADDR
// if GetTaskList ( unit ) then
106912: LD_VAR 0 1
106916: PPUSH
106917: CALL_OW 437
106921: IFFALSE 107004
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106923: LD_STRING M
106925: PUSH
106926: LD_VAR 0 1
106930: PPUSH
106931: CALL_OW 437
106935: PUSH
106936: LD_INT 1
106938: ARRAY
106939: PUSH
106940: LD_INT 1
106942: ARRAY
106943: EQUAL
106944: PUSH
106945: LD_VAR 0 2
106949: PUSH
106950: LD_VAR 0 1
106954: PPUSH
106955: CALL_OW 437
106959: PUSH
106960: LD_INT 1
106962: ARRAY
106963: PUSH
106964: LD_INT 2
106966: ARRAY
106967: EQUAL
106968: AND
106969: PUSH
106970: LD_VAR 0 3
106974: PUSH
106975: LD_VAR 0 1
106979: PPUSH
106980: CALL_OW 437
106984: PUSH
106985: LD_INT 1
106987: ARRAY
106988: PUSH
106989: LD_INT 3
106991: ARRAY
106992: EQUAL
106993: AND
106994: IFFALSE 107004
// result := true ;
106996: LD_ADDR_VAR 0 4
107000: PUSH
107001: LD_INT 1
107003: ST_TO_ADDR
// end ; end ;
107004: LD_VAR 0 4
107008: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
107009: LD_INT 0
107011: PPUSH
107012: PPUSH
107013: PPUSH
107014: PPUSH
// if not unit or not area then
107015: LD_VAR 0 1
107019: NOT
107020: PUSH
107021: LD_VAR 0 2
107025: NOT
107026: OR
107027: IFFALSE 107031
// exit ;
107029: GO 107207
// tmp := AreaToList ( area , i ) ;
107031: LD_ADDR_VAR 0 6
107035: PUSH
107036: LD_VAR 0 2
107040: PPUSH
107041: LD_VAR 0 5
107045: PPUSH
107046: CALL_OW 517
107050: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
107051: LD_ADDR_VAR 0 5
107055: PUSH
107056: DOUBLE
107057: LD_INT 1
107059: DEC
107060: ST_TO_ADDR
107061: LD_VAR 0 6
107065: PUSH
107066: LD_INT 1
107068: ARRAY
107069: PUSH
107070: FOR_TO
107071: IFFALSE 107205
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
107073: LD_ADDR_VAR 0 7
107077: PUSH
107078: LD_VAR 0 6
107082: PUSH
107083: LD_INT 1
107085: ARRAY
107086: PUSH
107087: LD_VAR 0 5
107091: ARRAY
107092: PUSH
107093: LD_VAR 0 6
107097: PUSH
107098: LD_INT 2
107100: ARRAY
107101: PUSH
107102: LD_VAR 0 5
107106: ARRAY
107107: PUSH
107108: EMPTY
107109: LIST
107110: LIST
107111: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
107112: LD_INT 92
107114: PUSH
107115: LD_VAR 0 7
107119: PUSH
107120: LD_INT 1
107122: ARRAY
107123: PUSH
107124: LD_VAR 0 7
107128: PUSH
107129: LD_INT 2
107131: ARRAY
107132: PUSH
107133: LD_INT 2
107135: PUSH
107136: EMPTY
107137: LIST
107138: LIST
107139: LIST
107140: LIST
107141: PPUSH
107142: CALL_OW 69
107146: PUSH
107147: LD_INT 0
107149: EQUAL
107150: IFFALSE 107203
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
107152: LD_VAR 0 1
107156: PPUSH
107157: LD_VAR 0 7
107161: PUSH
107162: LD_INT 1
107164: ARRAY
107165: PPUSH
107166: LD_VAR 0 7
107170: PUSH
107171: LD_INT 2
107173: ARRAY
107174: PPUSH
107175: LD_VAR 0 3
107179: PPUSH
107180: CALL_OW 48
// result := IsPlaced ( unit ) ;
107184: LD_ADDR_VAR 0 4
107188: PUSH
107189: LD_VAR 0 1
107193: PPUSH
107194: CALL_OW 305
107198: ST_TO_ADDR
// exit ;
107199: POP
107200: POP
107201: GO 107207
// end ; end ;
107203: GO 107070
107205: POP
107206: POP
// end ;
107207: LD_VAR 0 4
107211: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
107212: LD_INT 0
107214: PPUSH
107215: PPUSH
107216: PPUSH
// if not side or side > 8 then
107217: LD_VAR 0 1
107221: NOT
107222: PUSH
107223: LD_VAR 0 1
107227: PUSH
107228: LD_INT 8
107230: GREATER
107231: OR
107232: IFFALSE 107236
// exit ;
107234: GO 107423
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
107236: LD_ADDR_VAR 0 4
107240: PUSH
107241: LD_INT 22
107243: PUSH
107244: LD_VAR 0 1
107248: PUSH
107249: EMPTY
107250: LIST
107251: LIST
107252: PUSH
107253: LD_INT 21
107255: PUSH
107256: LD_INT 3
107258: PUSH
107259: EMPTY
107260: LIST
107261: LIST
107262: PUSH
107263: EMPTY
107264: LIST
107265: LIST
107266: PPUSH
107267: CALL_OW 69
107271: ST_TO_ADDR
// if not tmp then
107272: LD_VAR 0 4
107276: NOT
107277: IFFALSE 107281
// exit ;
107279: GO 107423
// enable_addtolog := true ;
107281: LD_ADDR_OWVAR 81
107285: PUSH
107286: LD_INT 1
107288: ST_TO_ADDR
// AddToLog ( [ ) ;
107289: LD_STRING [
107291: PPUSH
107292: CALL_OW 561
// for i in tmp do
107296: LD_ADDR_VAR 0 3
107300: PUSH
107301: LD_VAR 0 4
107305: PUSH
107306: FOR_IN
107307: IFFALSE 107414
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107309: LD_STRING [
107311: PUSH
107312: LD_VAR 0 3
107316: PPUSH
107317: CALL_OW 266
107321: STR
107322: PUSH
107323: LD_STRING , 
107325: STR
107326: PUSH
107327: LD_VAR 0 3
107331: PPUSH
107332: CALL_OW 250
107336: STR
107337: PUSH
107338: LD_STRING , 
107340: STR
107341: PUSH
107342: LD_VAR 0 3
107346: PPUSH
107347: CALL_OW 251
107351: STR
107352: PUSH
107353: LD_STRING , 
107355: STR
107356: PUSH
107357: LD_VAR 0 3
107361: PPUSH
107362: CALL_OW 254
107366: STR
107367: PUSH
107368: LD_STRING , 
107370: STR
107371: PUSH
107372: LD_VAR 0 3
107376: PPUSH
107377: LD_INT 1
107379: PPUSH
107380: CALL_OW 268
107384: STR
107385: PUSH
107386: LD_STRING , 
107388: STR
107389: PUSH
107390: LD_VAR 0 3
107394: PPUSH
107395: LD_INT 2
107397: PPUSH
107398: CALL_OW 268
107402: STR
107403: PUSH
107404: LD_STRING ],
107406: STR
107407: PPUSH
107408: CALL_OW 561
// end ;
107412: GO 107306
107414: POP
107415: POP
// AddToLog ( ]; ) ;
107416: LD_STRING ];
107418: PPUSH
107419: CALL_OW 561
// end ;
107423: LD_VAR 0 2
107427: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107428: LD_INT 0
107430: PPUSH
107431: PPUSH
107432: PPUSH
107433: PPUSH
107434: PPUSH
// if not area or not rate or not max then
107435: LD_VAR 0 1
107439: NOT
107440: PUSH
107441: LD_VAR 0 2
107445: NOT
107446: OR
107447: PUSH
107448: LD_VAR 0 4
107452: NOT
107453: OR
107454: IFFALSE 107458
// exit ;
107456: GO 107647
// while 1 do
107458: LD_INT 1
107460: IFFALSE 107647
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107462: LD_ADDR_VAR 0 9
107466: PUSH
107467: LD_VAR 0 1
107471: PPUSH
107472: LD_INT 1
107474: PPUSH
107475: CALL_OW 287
107479: PUSH
107480: LD_INT 10
107482: MUL
107483: ST_TO_ADDR
// r := rate / 10 ;
107484: LD_ADDR_VAR 0 7
107488: PUSH
107489: LD_VAR 0 2
107493: PUSH
107494: LD_INT 10
107496: DIVREAL
107497: ST_TO_ADDR
// time := 1 1$00 ;
107498: LD_ADDR_VAR 0 8
107502: PUSH
107503: LD_INT 2100
107505: ST_TO_ADDR
// if amount < min then
107506: LD_VAR 0 9
107510: PUSH
107511: LD_VAR 0 3
107515: LESS
107516: IFFALSE 107534
// r := r * 2 else
107518: LD_ADDR_VAR 0 7
107522: PUSH
107523: LD_VAR 0 7
107527: PUSH
107528: LD_INT 2
107530: MUL
107531: ST_TO_ADDR
107532: GO 107560
// if amount > max then
107534: LD_VAR 0 9
107538: PUSH
107539: LD_VAR 0 4
107543: GREATER
107544: IFFALSE 107560
// r := r / 2 ;
107546: LD_ADDR_VAR 0 7
107550: PUSH
107551: LD_VAR 0 7
107555: PUSH
107556: LD_INT 2
107558: DIVREAL
107559: ST_TO_ADDR
// time := time / r ;
107560: LD_ADDR_VAR 0 8
107564: PUSH
107565: LD_VAR 0 8
107569: PUSH
107570: LD_VAR 0 7
107574: DIVREAL
107575: ST_TO_ADDR
// if time < 0 then
107576: LD_VAR 0 8
107580: PUSH
107581: LD_INT 0
107583: LESS
107584: IFFALSE 107601
// time := time * - 1 ;
107586: LD_ADDR_VAR 0 8
107590: PUSH
107591: LD_VAR 0 8
107595: PUSH
107596: LD_INT 1
107598: NEG
107599: MUL
107600: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
107601: LD_VAR 0 8
107605: PUSH
107606: LD_INT 35
107608: PPUSH
107609: LD_INT 875
107611: PPUSH
107612: CALL_OW 12
107616: PLUS
107617: PPUSH
107618: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107622: LD_INT 1
107624: PPUSH
107625: LD_INT 5
107627: PPUSH
107628: CALL_OW 12
107632: PPUSH
107633: LD_VAR 0 1
107637: PPUSH
107638: LD_INT 1
107640: PPUSH
107641: CALL_OW 55
// end ;
107645: GO 107458
// end ;
107647: LD_VAR 0 5
107651: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107652: LD_INT 0
107654: PPUSH
107655: PPUSH
107656: PPUSH
107657: PPUSH
107658: PPUSH
107659: PPUSH
107660: PPUSH
107661: PPUSH
// if not turrets or not factories then
107662: LD_VAR 0 1
107666: NOT
107667: PUSH
107668: LD_VAR 0 2
107672: NOT
107673: OR
107674: IFFALSE 107678
// exit ;
107676: GO 107985
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107678: LD_ADDR_VAR 0 10
107682: PUSH
107683: LD_INT 5
107685: PUSH
107686: LD_INT 6
107688: PUSH
107689: EMPTY
107690: LIST
107691: LIST
107692: PUSH
107693: LD_INT 2
107695: PUSH
107696: LD_INT 4
107698: PUSH
107699: EMPTY
107700: LIST
107701: LIST
107702: PUSH
107703: LD_INT 3
107705: PUSH
107706: LD_INT 5
107708: PUSH
107709: EMPTY
107710: LIST
107711: LIST
107712: PUSH
107713: EMPTY
107714: LIST
107715: LIST
107716: LIST
107717: PUSH
107718: LD_INT 24
107720: PUSH
107721: LD_INT 25
107723: PUSH
107724: EMPTY
107725: LIST
107726: LIST
107727: PUSH
107728: LD_INT 23
107730: PUSH
107731: LD_INT 27
107733: PUSH
107734: EMPTY
107735: LIST
107736: LIST
107737: PUSH
107738: EMPTY
107739: LIST
107740: LIST
107741: PUSH
107742: LD_INT 42
107744: PUSH
107745: LD_INT 43
107747: PUSH
107748: EMPTY
107749: LIST
107750: LIST
107751: PUSH
107752: LD_INT 44
107754: PUSH
107755: LD_INT 46
107757: PUSH
107758: EMPTY
107759: LIST
107760: LIST
107761: PUSH
107762: LD_INT 45
107764: PUSH
107765: LD_INT 47
107767: PUSH
107768: EMPTY
107769: LIST
107770: LIST
107771: PUSH
107772: EMPTY
107773: LIST
107774: LIST
107775: LIST
107776: PUSH
107777: EMPTY
107778: LIST
107779: LIST
107780: LIST
107781: ST_TO_ADDR
// result := [ ] ;
107782: LD_ADDR_VAR 0 3
107786: PUSH
107787: EMPTY
107788: ST_TO_ADDR
// for i in turrets do
107789: LD_ADDR_VAR 0 4
107793: PUSH
107794: LD_VAR 0 1
107798: PUSH
107799: FOR_IN
107800: IFFALSE 107983
// begin nat := GetNation ( i ) ;
107802: LD_ADDR_VAR 0 7
107806: PUSH
107807: LD_VAR 0 4
107811: PPUSH
107812: CALL_OW 248
107816: ST_TO_ADDR
// weapon := 0 ;
107817: LD_ADDR_VAR 0 8
107821: PUSH
107822: LD_INT 0
107824: ST_TO_ADDR
// if not nat then
107825: LD_VAR 0 7
107829: NOT
107830: IFFALSE 107834
// continue ;
107832: GO 107799
// for j in list [ nat ] do
107834: LD_ADDR_VAR 0 5
107838: PUSH
107839: LD_VAR 0 10
107843: PUSH
107844: LD_VAR 0 7
107848: ARRAY
107849: PUSH
107850: FOR_IN
107851: IFFALSE 107892
// if GetBWeapon ( i ) = j [ 1 ] then
107853: LD_VAR 0 4
107857: PPUSH
107858: CALL_OW 269
107862: PUSH
107863: LD_VAR 0 5
107867: PUSH
107868: LD_INT 1
107870: ARRAY
107871: EQUAL
107872: IFFALSE 107890
// begin weapon := j [ 2 ] ;
107874: LD_ADDR_VAR 0 8
107878: PUSH
107879: LD_VAR 0 5
107883: PUSH
107884: LD_INT 2
107886: ARRAY
107887: ST_TO_ADDR
// break ;
107888: GO 107892
// end ;
107890: GO 107850
107892: POP
107893: POP
// if not weapon then
107894: LD_VAR 0 8
107898: NOT
107899: IFFALSE 107903
// continue ;
107901: GO 107799
// for k in factories do
107903: LD_ADDR_VAR 0 6
107907: PUSH
107908: LD_VAR 0 2
107912: PUSH
107913: FOR_IN
107914: IFFALSE 107979
// begin weapons := AvailableWeaponList ( k ) ;
107916: LD_ADDR_VAR 0 9
107920: PUSH
107921: LD_VAR 0 6
107925: PPUSH
107926: CALL_OW 478
107930: ST_TO_ADDR
// if not weapons then
107931: LD_VAR 0 9
107935: NOT
107936: IFFALSE 107940
// continue ;
107938: GO 107913
// if weapon in weapons then
107940: LD_VAR 0 8
107944: PUSH
107945: LD_VAR 0 9
107949: IN
107950: IFFALSE 107977
// begin result := [ i , weapon ] ;
107952: LD_ADDR_VAR 0 3
107956: PUSH
107957: LD_VAR 0 4
107961: PUSH
107962: LD_VAR 0 8
107966: PUSH
107967: EMPTY
107968: LIST
107969: LIST
107970: ST_TO_ADDR
// exit ;
107971: POP
107972: POP
107973: POP
107974: POP
107975: GO 107985
// end ; end ;
107977: GO 107913
107979: POP
107980: POP
// end ;
107981: GO 107799
107983: POP
107984: POP
// end ;
107985: LD_VAR 0 3
107989: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107990: LD_INT 0
107992: PPUSH
// if not side or side > 8 then
107993: LD_VAR 0 3
107997: NOT
107998: PUSH
107999: LD_VAR 0 3
108003: PUSH
108004: LD_INT 8
108006: GREATER
108007: OR
108008: IFFALSE 108012
// exit ;
108010: GO 108071
// if not range then
108012: LD_VAR 0 4
108016: NOT
108017: IFFALSE 108028
// range := - 12 ;
108019: LD_ADDR_VAR 0 4
108023: PUSH
108024: LD_INT 12
108026: NEG
108027: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
108028: LD_VAR 0 1
108032: PPUSH
108033: LD_VAR 0 2
108037: PPUSH
108038: LD_VAR 0 3
108042: PPUSH
108043: LD_VAR 0 4
108047: PPUSH
108048: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
108052: LD_VAR 0 1
108056: PPUSH
108057: LD_VAR 0 2
108061: PPUSH
108062: LD_VAR 0 3
108066: PPUSH
108067: CALL_OW 331
// end ;
108071: LD_VAR 0 5
108075: RET
// export function Video ( mode ) ; begin
108076: LD_INT 0
108078: PPUSH
// ingame_video = mode ;
108079: LD_ADDR_OWVAR 52
108083: PUSH
108084: LD_VAR 0 1
108088: ST_TO_ADDR
// interface_hidden = mode ;
108089: LD_ADDR_OWVAR 54
108093: PUSH
108094: LD_VAR 0 1
108098: ST_TO_ADDR
// end ;
108099: LD_VAR 0 2
108103: RET
// export function Join ( array , element ) ; begin
108104: LD_INT 0
108106: PPUSH
// result := Replace ( array , array + 1 , element ) ;
108107: LD_ADDR_VAR 0 3
108111: PUSH
108112: LD_VAR 0 1
108116: PPUSH
108117: LD_VAR 0 1
108121: PUSH
108122: LD_INT 1
108124: PLUS
108125: PPUSH
108126: LD_VAR 0 2
108130: PPUSH
108131: CALL_OW 1
108135: ST_TO_ADDR
// end ;
108136: LD_VAR 0 3
108140: RET
// export function JoinUnion ( array , element ) ; begin
108141: LD_INT 0
108143: PPUSH
// result := array union element ;
108144: LD_ADDR_VAR 0 3
108148: PUSH
108149: LD_VAR 0 1
108153: PUSH
108154: LD_VAR 0 2
108158: UNION
108159: ST_TO_ADDR
// end ;
108160: LD_VAR 0 3
108164: RET
// export function GetBehemoths ( side ) ; begin
108165: LD_INT 0
108167: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
108168: LD_ADDR_VAR 0 2
108172: PUSH
108173: LD_INT 22
108175: PUSH
108176: LD_VAR 0 1
108180: PUSH
108181: EMPTY
108182: LIST
108183: LIST
108184: PUSH
108185: LD_INT 31
108187: PUSH
108188: LD_INT 25
108190: PUSH
108191: EMPTY
108192: LIST
108193: LIST
108194: PUSH
108195: EMPTY
108196: LIST
108197: LIST
108198: PPUSH
108199: CALL_OW 69
108203: ST_TO_ADDR
// end ;
108204: LD_VAR 0 2
108208: RET
// export function Shuffle ( array ) ; var i , index ; begin
108209: LD_INT 0
108211: PPUSH
108212: PPUSH
108213: PPUSH
// result := [ ] ;
108214: LD_ADDR_VAR 0 2
108218: PUSH
108219: EMPTY
108220: ST_TO_ADDR
// if not array then
108221: LD_VAR 0 1
108225: NOT
108226: IFFALSE 108230
// exit ;
108228: GO 108329
// Randomize ;
108230: CALL_OW 10
// for i = array downto 1 do
108234: LD_ADDR_VAR 0 3
108238: PUSH
108239: DOUBLE
108240: LD_VAR 0 1
108244: INC
108245: ST_TO_ADDR
108246: LD_INT 1
108248: PUSH
108249: FOR_DOWNTO
108250: IFFALSE 108327
// begin index := rand ( 1 , array ) ;
108252: LD_ADDR_VAR 0 4
108256: PUSH
108257: LD_INT 1
108259: PPUSH
108260: LD_VAR 0 1
108264: PPUSH
108265: CALL_OW 12
108269: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
108270: LD_ADDR_VAR 0 2
108274: PUSH
108275: LD_VAR 0 2
108279: PPUSH
108280: LD_VAR 0 2
108284: PUSH
108285: LD_INT 1
108287: PLUS
108288: PPUSH
108289: LD_VAR 0 1
108293: PUSH
108294: LD_VAR 0 4
108298: ARRAY
108299: PPUSH
108300: CALL_OW 2
108304: ST_TO_ADDR
// array := Delete ( array , index ) ;
108305: LD_ADDR_VAR 0 1
108309: PUSH
108310: LD_VAR 0 1
108314: PPUSH
108315: LD_VAR 0 4
108319: PPUSH
108320: CALL_OW 3
108324: ST_TO_ADDR
// end ;
108325: GO 108249
108327: POP
108328: POP
// end ;
108329: LD_VAR 0 2
108333: RET
// export function GetBaseMaterials ( base ) ; begin
108334: LD_INT 0
108336: PPUSH
// result := [ 0 , 0 , 0 ] ;
108337: LD_ADDR_VAR 0 2
108341: PUSH
108342: LD_INT 0
108344: PUSH
108345: LD_INT 0
108347: PUSH
108348: LD_INT 0
108350: PUSH
108351: EMPTY
108352: LIST
108353: LIST
108354: LIST
108355: ST_TO_ADDR
// if not base then
108356: LD_VAR 0 1
108360: NOT
108361: IFFALSE 108365
// exit ;
108363: GO 108414
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108365: LD_ADDR_VAR 0 2
108369: PUSH
108370: LD_VAR 0 1
108374: PPUSH
108375: LD_INT 1
108377: PPUSH
108378: CALL_OW 275
108382: PUSH
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_INT 2
108390: PPUSH
108391: CALL_OW 275
108395: PUSH
108396: LD_VAR 0 1
108400: PPUSH
108401: LD_INT 3
108403: PPUSH
108404: CALL_OW 275
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: LIST
108413: ST_TO_ADDR
// end ;
108414: LD_VAR 0 2
108418: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
108419: LD_INT 0
108421: PPUSH
108422: PPUSH
// result := array ;
108423: LD_ADDR_VAR 0 3
108427: PUSH
108428: LD_VAR 0 1
108432: ST_TO_ADDR
// if size >= result then
108433: LD_VAR 0 2
108437: PUSH
108438: LD_VAR 0 3
108442: GREATEREQUAL
108443: IFFALSE 108447
// exit ;
108445: GO 108497
// if size then
108447: LD_VAR 0 2
108451: IFFALSE 108497
// for i := array downto size do
108453: LD_ADDR_VAR 0 4
108457: PUSH
108458: DOUBLE
108459: LD_VAR 0 1
108463: INC
108464: ST_TO_ADDR
108465: LD_VAR 0 2
108469: PUSH
108470: FOR_DOWNTO
108471: IFFALSE 108495
// result := Delete ( result , result ) ;
108473: LD_ADDR_VAR 0 3
108477: PUSH
108478: LD_VAR 0 3
108482: PPUSH
108483: LD_VAR 0 3
108487: PPUSH
108488: CALL_OW 3
108492: ST_TO_ADDR
108493: GO 108470
108495: POP
108496: POP
// end ;
108497: LD_VAR 0 3
108501: RET
// export function ComExit ( unit ) ; var tmp ; begin
108502: LD_INT 0
108504: PPUSH
108505: PPUSH
// if not IsInUnit ( unit ) then
108506: LD_VAR 0 1
108510: PPUSH
108511: CALL_OW 310
108515: NOT
108516: IFFALSE 108520
// exit ;
108518: GO 108580
// tmp := IsInUnit ( unit ) ;
108520: LD_ADDR_VAR 0 3
108524: PUSH
108525: LD_VAR 0 1
108529: PPUSH
108530: CALL_OW 310
108534: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
108535: LD_VAR 0 3
108539: PPUSH
108540: CALL_OW 247
108544: PUSH
108545: LD_INT 2
108547: EQUAL
108548: IFFALSE 108561
// ComExitVehicle ( unit ) else
108550: LD_VAR 0 1
108554: PPUSH
108555: CALL_OW 121
108559: GO 108570
// ComExitBuilding ( unit ) ;
108561: LD_VAR 0 1
108565: PPUSH
108566: CALL_OW 122
// result := tmp ;
108570: LD_ADDR_VAR 0 2
108574: PUSH
108575: LD_VAR 0 3
108579: ST_TO_ADDR
// end ;
108580: LD_VAR 0 2
108584: RET
// export function ComExitAll ( units ) ; var i ; begin
108585: LD_INT 0
108587: PPUSH
108588: PPUSH
// if not units then
108589: LD_VAR 0 1
108593: NOT
108594: IFFALSE 108598
// exit ;
108596: GO 108624
// for i in units do
108598: LD_ADDR_VAR 0 3
108602: PUSH
108603: LD_VAR 0 1
108607: PUSH
108608: FOR_IN
108609: IFFALSE 108622
// ComExit ( i ) ;
108611: LD_VAR 0 3
108615: PPUSH
108616: CALL 108502 0 1
108620: GO 108608
108622: POP
108623: POP
// end ;
108624: LD_VAR 0 2
108628: RET
// export function ResetHc ; begin
108629: LD_INT 0
108631: PPUSH
// InitHc ;
108632: CALL_OW 19
// hc_importance := 0 ;
108636: LD_ADDR_OWVAR 32
108640: PUSH
108641: LD_INT 0
108643: ST_TO_ADDR
// end ;
108644: LD_VAR 0 1
108648: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
108649: LD_INT 0
108651: PPUSH
108652: PPUSH
108653: PPUSH
// _x := ( x1 + x2 ) div 2 ;
108654: LD_ADDR_VAR 0 6
108658: PUSH
108659: LD_VAR 0 1
108663: PUSH
108664: LD_VAR 0 3
108668: PLUS
108669: PUSH
108670: LD_INT 2
108672: DIV
108673: ST_TO_ADDR
// if _x < 0 then
108674: LD_VAR 0 6
108678: PUSH
108679: LD_INT 0
108681: LESS
108682: IFFALSE 108699
// _x := _x * - 1 ;
108684: LD_ADDR_VAR 0 6
108688: PUSH
108689: LD_VAR 0 6
108693: PUSH
108694: LD_INT 1
108696: NEG
108697: MUL
108698: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
108699: LD_ADDR_VAR 0 7
108703: PUSH
108704: LD_VAR 0 2
108708: PUSH
108709: LD_VAR 0 4
108713: PLUS
108714: PUSH
108715: LD_INT 2
108717: DIV
108718: ST_TO_ADDR
// if _y < 0 then
108719: LD_VAR 0 7
108723: PUSH
108724: LD_INT 0
108726: LESS
108727: IFFALSE 108744
// _y := _y * - 1 ;
108729: LD_ADDR_VAR 0 7
108733: PUSH
108734: LD_VAR 0 7
108738: PUSH
108739: LD_INT 1
108741: NEG
108742: MUL
108743: ST_TO_ADDR
// result := [ _x , _y ] ;
108744: LD_ADDR_VAR 0 5
108748: PUSH
108749: LD_VAR 0 6
108753: PUSH
108754: LD_VAR 0 7
108758: PUSH
108759: EMPTY
108760: LIST
108761: LIST
108762: ST_TO_ADDR
// end ;
108763: LD_VAR 0 5
108767: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
108768: LD_INT 0
108770: PPUSH
108771: PPUSH
108772: PPUSH
108773: PPUSH
// task := GetTaskList ( unit ) ;
108774: LD_ADDR_VAR 0 7
108778: PUSH
108779: LD_VAR 0 1
108783: PPUSH
108784: CALL_OW 437
108788: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
108789: LD_VAR 0 7
108793: NOT
108794: PUSH
108795: LD_VAR 0 1
108799: PPUSH
108800: LD_VAR 0 2
108804: PPUSH
108805: CALL_OW 308
108809: NOT
108810: AND
108811: IFFALSE 108815
// exit ;
108813: GO 108933
// if IsInArea ( unit , area ) then
108815: LD_VAR 0 1
108819: PPUSH
108820: LD_VAR 0 2
108824: PPUSH
108825: CALL_OW 308
108829: IFFALSE 108847
// begin ComMoveToArea ( unit , goAway ) ;
108831: LD_VAR 0 1
108835: PPUSH
108836: LD_VAR 0 3
108840: PPUSH
108841: CALL_OW 113
// exit ;
108845: GO 108933
// end ; if task [ 1 ] [ 1 ] <> M then
108847: LD_VAR 0 7
108851: PUSH
108852: LD_INT 1
108854: ARRAY
108855: PUSH
108856: LD_INT 1
108858: ARRAY
108859: PUSH
108860: LD_STRING M
108862: NONEQUAL
108863: IFFALSE 108867
// exit ;
108865: GO 108933
// x := task [ 1 ] [ 2 ] ;
108867: LD_ADDR_VAR 0 5
108871: PUSH
108872: LD_VAR 0 7
108876: PUSH
108877: LD_INT 1
108879: ARRAY
108880: PUSH
108881: LD_INT 2
108883: ARRAY
108884: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108885: LD_ADDR_VAR 0 6
108889: PUSH
108890: LD_VAR 0 7
108894: PUSH
108895: LD_INT 1
108897: ARRAY
108898: PUSH
108899: LD_INT 3
108901: ARRAY
108902: ST_TO_ADDR
// if InArea ( x , y , area ) then
108903: LD_VAR 0 5
108907: PPUSH
108908: LD_VAR 0 6
108912: PPUSH
108913: LD_VAR 0 2
108917: PPUSH
108918: CALL_OW 309
108922: IFFALSE 108933
// ComStop ( unit ) ;
108924: LD_VAR 0 1
108928: PPUSH
108929: CALL_OW 141
// end ;
108933: LD_VAR 0 4
108937: RET
// export function Abs ( value ) ; begin
108938: LD_INT 0
108940: PPUSH
// result := value ;
108941: LD_ADDR_VAR 0 2
108945: PUSH
108946: LD_VAR 0 1
108950: ST_TO_ADDR
// if value < 0 then
108951: LD_VAR 0 1
108955: PUSH
108956: LD_INT 0
108958: LESS
108959: IFFALSE 108976
// result := value * - 1 ;
108961: LD_ADDR_VAR 0 2
108965: PUSH
108966: LD_VAR 0 1
108970: PUSH
108971: LD_INT 1
108973: NEG
108974: MUL
108975: ST_TO_ADDR
// end ;
108976: LD_VAR 0 2
108980: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108981: LD_INT 0
108983: PPUSH
108984: PPUSH
108985: PPUSH
108986: PPUSH
108987: PPUSH
108988: PPUSH
108989: PPUSH
108990: PPUSH
// if not unit or not building then
108991: LD_VAR 0 1
108995: NOT
108996: PUSH
108997: LD_VAR 0 2
109001: NOT
109002: OR
109003: IFFALSE 109007
// exit ;
109005: GO 109233
// x := GetX ( building ) ;
109007: LD_ADDR_VAR 0 4
109011: PUSH
109012: LD_VAR 0 2
109016: PPUSH
109017: CALL_OW 250
109021: ST_TO_ADDR
// y := GetY ( building ) ;
109022: LD_ADDR_VAR 0 6
109026: PUSH
109027: LD_VAR 0 2
109031: PPUSH
109032: CALL_OW 251
109036: ST_TO_ADDR
// d := GetDir ( building ) ;
109037: LD_ADDR_VAR 0 8
109041: PUSH
109042: LD_VAR 0 2
109046: PPUSH
109047: CALL_OW 254
109051: ST_TO_ADDR
// r := 4 ;
109052: LD_ADDR_VAR 0 9
109056: PUSH
109057: LD_INT 4
109059: ST_TO_ADDR
// for i := 1 to 5 do
109060: LD_ADDR_VAR 0 10
109064: PUSH
109065: DOUBLE
109066: LD_INT 1
109068: DEC
109069: ST_TO_ADDR
109070: LD_INT 5
109072: PUSH
109073: FOR_TO
109074: IFFALSE 109231
// begin _x := ShiftX ( x , d , r + i ) ;
109076: LD_ADDR_VAR 0 5
109080: PUSH
109081: LD_VAR 0 4
109085: PPUSH
109086: LD_VAR 0 8
109090: PPUSH
109091: LD_VAR 0 9
109095: PUSH
109096: LD_VAR 0 10
109100: PLUS
109101: PPUSH
109102: CALL_OW 272
109106: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
109107: LD_ADDR_VAR 0 7
109111: PUSH
109112: LD_VAR 0 6
109116: PPUSH
109117: LD_VAR 0 8
109121: PPUSH
109122: LD_VAR 0 9
109126: PUSH
109127: LD_VAR 0 10
109131: PLUS
109132: PPUSH
109133: CALL_OW 273
109137: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
109138: LD_VAR 0 5
109142: PPUSH
109143: LD_VAR 0 7
109147: PPUSH
109148: CALL_OW 488
109152: PUSH
109153: LD_VAR 0 5
109157: PPUSH
109158: LD_VAR 0 7
109162: PPUSH
109163: CALL_OW 428
109167: PPUSH
109168: CALL_OW 247
109172: PUSH
109173: LD_INT 3
109175: PUSH
109176: LD_INT 2
109178: PUSH
109179: EMPTY
109180: LIST
109181: LIST
109182: IN
109183: NOT
109184: AND
109185: IFFALSE 109229
// begin ComMoveXY ( unit , _x , _y ) ;
109187: LD_VAR 0 1
109191: PPUSH
109192: LD_VAR 0 5
109196: PPUSH
109197: LD_VAR 0 7
109201: PPUSH
109202: CALL_OW 111
// result := [ _x , _y ] ;
109206: LD_ADDR_VAR 0 3
109210: PUSH
109211: LD_VAR 0 5
109215: PUSH
109216: LD_VAR 0 7
109220: PUSH
109221: EMPTY
109222: LIST
109223: LIST
109224: ST_TO_ADDR
// exit ;
109225: POP
109226: POP
109227: GO 109233
// end ; end ;
109229: GO 109073
109231: POP
109232: POP
// end ;
109233: LD_VAR 0 3
109237: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
109238: LD_INT 0
109240: PPUSH
109241: PPUSH
109242: PPUSH
// result := 0 ;
109243: LD_ADDR_VAR 0 3
109247: PUSH
109248: LD_INT 0
109250: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
109251: LD_VAR 0 1
109255: PUSH
109256: LD_INT 0
109258: LESS
109259: PUSH
109260: LD_VAR 0 1
109264: PUSH
109265: LD_INT 8
109267: GREATER
109268: OR
109269: PUSH
109270: LD_VAR 0 2
109274: PUSH
109275: LD_INT 0
109277: LESS
109278: OR
109279: PUSH
109280: LD_VAR 0 2
109284: PUSH
109285: LD_INT 8
109287: GREATER
109288: OR
109289: IFFALSE 109293
// exit ;
109291: GO 109368
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
109293: LD_ADDR_VAR 0 4
109297: PUSH
109298: LD_INT 22
109300: PUSH
109301: LD_VAR 0 2
109305: PUSH
109306: EMPTY
109307: LIST
109308: LIST
109309: PPUSH
109310: CALL_OW 69
109314: PUSH
109315: FOR_IN
109316: IFFALSE 109366
// begin un := UnitShoot ( i ) ;
109318: LD_ADDR_VAR 0 5
109322: PUSH
109323: LD_VAR 0 4
109327: PPUSH
109328: CALL_OW 504
109332: ST_TO_ADDR
// if GetSide ( un ) = side1 then
109333: LD_VAR 0 5
109337: PPUSH
109338: CALL_OW 255
109342: PUSH
109343: LD_VAR 0 1
109347: EQUAL
109348: IFFALSE 109364
// begin result := un ;
109350: LD_ADDR_VAR 0 3
109354: PUSH
109355: LD_VAR 0 5
109359: ST_TO_ADDR
// exit ;
109360: POP
109361: POP
109362: GO 109368
// end ; end ;
109364: GO 109315
109366: POP
109367: POP
// end ;
109368: LD_VAR 0 3
109372: RET
// export function GetCargoBay ( units ) ; begin
109373: LD_INT 0
109375: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
109376: LD_ADDR_VAR 0 2
109380: PUSH
109381: LD_VAR 0 1
109385: PPUSH
109386: LD_INT 2
109388: PUSH
109389: LD_INT 34
109391: PUSH
109392: LD_INT 12
109394: PUSH
109395: EMPTY
109396: LIST
109397: LIST
109398: PUSH
109399: LD_INT 34
109401: PUSH
109402: LD_INT 51
109404: PUSH
109405: EMPTY
109406: LIST
109407: LIST
109408: PUSH
109409: LD_INT 34
109411: PUSH
109412: LD_INT 32
109414: PUSH
109415: EMPTY
109416: LIST
109417: LIST
109418: PUSH
109419: LD_INT 34
109421: PUSH
109422: LD_INT 89
109424: PUSH
109425: EMPTY
109426: LIST
109427: LIST
109428: PUSH
109429: EMPTY
109430: LIST
109431: LIST
109432: LIST
109433: LIST
109434: LIST
109435: PPUSH
109436: CALL_OW 72
109440: ST_TO_ADDR
// end ;
109441: LD_VAR 0 2
109445: RET
// export function Negate ( value ) ; begin
109446: LD_INT 0
109448: PPUSH
// result := not value ;
109449: LD_ADDR_VAR 0 2
109453: PUSH
109454: LD_VAR 0 1
109458: NOT
109459: ST_TO_ADDR
// end ;
109460: LD_VAR 0 2
109464: RET
// export function Inc ( value ) ; begin
109465: LD_INT 0
109467: PPUSH
// result := value + 1 ;
109468: LD_ADDR_VAR 0 2
109472: PUSH
109473: LD_VAR 0 1
109477: PUSH
109478: LD_INT 1
109480: PLUS
109481: ST_TO_ADDR
// end ;
109482: LD_VAR 0 2
109486: RET
// export function Dec ( value ) ; begin
109487: LD_INT 0
109489: PPUSH
// result := value - 1 ;
109490: LD_ADDR_VAR 0 2
109494: PUSH
109495: LD_VAR 0 1
109499: PUSH
109500: LD_INT 1
109502: MINUS
109503: ST_TO_ADDR
// end ;
109504: LD_VAR 0 2
109508: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
109509: LD_INT 0
109511: PPUSH
109512: PPUSH
109513: PPUSH
109514: PPUSH
109515: PPUSH
109516: PPUSH
109517: PPUSH
109518: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
109519: LD_VAR 0 1
109523: PPUSH
109524: LD_VAR 0 2
109528: PPUSH
109529: CALL_OW 488
109533: NOT
109534: PUSH
109535: LD_VAR 0 3
109539: PPUSH
109540: LD_VAR 0 4
109544: PPUSH
109545: CALL_OW 488
109549: NOT
109550: OR
109551: IFFALSE 109564
// begin result := - 1 ;
109553: LD_ADDR_VAR 0 5
109557: PUSH
109558: LD_INT 1
109560: NEG
109561: ST_TO_ADDR
// exit ;
109562: GO 109799
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
109564: LD_ADDR_VAR 0 12
109568: PUSH
109569: LD_VAR 0 1
109573: PPUSH
109574: LD_VAR 0 2
109578: PPUSH
109579: LD_VAR 0 3
109583: PPUSH
109584: LD_VAR 0 4
109588: PPUSH
109589: CALL 108649 0 4
109593: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
109594: LD_ADDR_VAR 0 11
109598: PUSH
109599: LD_VAR 0 1
109603: PPUSH
109604: LD_VAR 0 2
109608: PPUSH
109609: LD_VAR 0 12
109613: PUSH
109614: LD_INT 1
109616: ARRAY
109617: PPUSH
109618: LD_VAR 0 12
109622: PUSH
109623: LD_INT 2
109625: ARRAY
109626: PPUSH
109627: CALL_OW 298
109631: ST_TO_ADDR
// distance := 9999 ;
109632: LD_ADDR_VAR 0 10
109636: PUSH
109637: LD_INT 9999
109639: ST_TO_ADDR
// for i := 0 to 5 do
109640: LD_ADDR_VAR 0 6
109644: PUSH
109645: DOUBLE
109646: LD_INT 0
109648: DEC
109649: ST_TO_ADDR
109650: LD_INT 5
109652: PUSH
109653: FOR_TO
109654: IFFALSE 109797
// begin _x := ShiftX ( x1 , i , centerDist ) ;
109656: LD_ADDR_VAR 0 7
109660: PUSH
109661: LD_VAR 0 1
109665: PPUSH
109666: LD_VAR 0 6
109670: PPUSH
109671: LD_VAR 0 11
109675: PPUSH
109676: CALL_OW 272
109680: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
109681: LD_ADDR_VAR 0 8
109685: PUSH
109686: LD_VAR 0 2
109690: PPUSH
109691: LD_VAR 0 6
109695: PPUSH
109696: LD_VAR 0 11
109700: PPUSH
109701: CALL_OW 273
109705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109706: LD_VAR 0 7
109710: PPUSH
109711: LD_VAR 0 8
109715: PPUSH
109716: CALL_OW 488
109720: NOT
109721: IFFALSE 109725
// continue ;
109723: GO 109653
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
109725: LD_ADDR_VAR 0 9
109729: PUSH
109730: LD_VAR 0 12
109734: PUSH
109735: LD_INT 1
109737: ARRAY
109738: PPUSH
109739: LD_VAR 0 12
109743: PUSH
109744: LD_INT 2
109746: ARRAY
109747: PPUSH
109748: LD_VAR 0 7
109752: PPUSH
109753: LD_VAR 0 8
109757: PPUSH
109758: CALL_OW 298
109762: ST_TO_ADDR
// if tmp < distance then
109763: LD_VAR 0 9
109767: PUSH
109768: LD_VAR 0 10
109772: LESS
109773: IFFALSE 109795
// begin result := i ;
109775: LD_ADDR_VAR 0 5
109779: PUSH
109780: LD_VAR 0 6
109784: ST_TO_ADDR
// distance := tmp ;
109785: LD_ADDR_VAR 0 10
109789: PUSH
109790: LD_VAR 0 9
109794: ST_TO_ADDR
// end ; end ;
109795: GO 109653
109797: POP
109798: POP
// end ;
109799: LD_VAR 0 5
109803: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109804: LD_INT 0
109806: PPUSH
109807: PPUSH
// if not driver or not IsInUnit ( driver ) then
109808: LD_VAR 0 1
109812: NOT
109813: PUSH
109814: LD_VAR 0 1
109818: PPUSH
109819: CALL_OW 310
109823: NOT
109824: OR
109825: IFFALSE 109829
// exit ;
109827: GO 109919
// vehicle := IsInUnit ( driver ) ;
109829: LD_ADDR_VAR 0 3
109833: PUSH
109834: LD_VAR 0 1
109838: PPUSH
109839: CALL_OW 310
109843: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109844: LD_VAR 0 1
109848: PPUSH
109849: LD_STRING \
109851: PUSH
109852: LD_INT 0
109854: PUSH
109855: LD_INT 0
109857: PUSH
109858: LD_INT 0
109860: PUSH
109861: LD_INT 0
109863: PUSH
109864: LD_INT 0
109866: PUSH
109867: LD_INT 0
109869: PUSH
109870: EMPTY
109871: LIST
109872: LIST
109873: LIST
109874: LIST
109875: LIST
109876: LIST
109877: LIST
109878: PUSH
109879: LD_STRING E
109881: PUSH
109882: LD_INT 0
109884: PUSH
109885: LD_INT 0
109887: PUSH
109888: LD_VAR 0 3
109892: PUSH
109893: LD_INT 0
109895: PUSH
109896: LD_INT 0
109898: PUSH
109899: LD_INT 0
109901: PUSH
109902: EMPTY
109903: LIST
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: LIST
109909: LIST
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: PPUSH
109915: CALL_OW 446
// end ;
109919: LD_VAR 0 2
109923: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109924: LD_INT 0
109926: PPUSH
109927: PPUSH
// if not driver or not IsInUnit ( driver ) then
109928: LD_VAR 0 1
109932: NOT
109933: PUSH
109934: LD_VAR 0 1
109938: PPUSH
109939: CALL_OW 310
109943: NOT
109944: OR
109945: IFFALSE 109949
// exit ;
109947: GO 110039
// vehicle := IsInUnit ( driver ) ;
109949: LD_ADDR_VAR 0 3
109953: PUSH
109954: LD_VAR 0 1
109958: PPUSH
109959: CALL_OW 310
109963: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109964: LD_VAR 0 1
109968: PPUSH
109969: LD_STRING \
109971: PUSH
109972: LD_INT 0
109974: PUSH
109975: LD_INT 0
109977: PUSH
109978: LD_INT 0
109980: PUSH
109981: LD_INT 0
109983: PUSH
109984: LD_INT 0
109986: PUSH
109987: LD_INT 0
109989: PUSH
109990: EMPTY
109991: LIST
109992: LIST
109993: LIST
109994: LIST
109995: LIST
109996: LIST
109997: LIST
109998: PUSH
109999: LD_STRING E
110001: PUSH
110002: LD_INT 0
110004: PUSH
110005: LD_INT 0
110007: PUSH
110008: LD_VAR 0 3
110012: PUSH
110013: LD_INT 0
110015: PUSH
110016: LD_INT 0
110018: PUSH
110019: LD_INT 0
110021: PUSH
110022: EMPTY
110023: LIST
110024: LIST
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: PUSH
110031: EMPTY
110032: LIST
110033: LIST
110034: PPUSH
110035: CALL_OW 447
// end ;
110039: LD_VAR 0 2
110043: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
110044: LD_INT 0
110046: PPUSH
110047: PPUSH
110048: PPUSH
// tmp := [ ] ;
110049: LD_ADDR_VAR 0 5
110053: PUSH
110054: EMPTY
110055: ST_TO_ADDR
// for i in units do
110056: LD_ADDR_VAR 0 4
110060: PUSH
110061: LD_VAR 0 1
110065: PUSH
110066: FOR_IN
110067: IFFALSE 110105
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
110069: LD_ADDR_VAR 0 5
110073: PUSH
110074: LD_VAR 0 5
110078: PPUSH
110079: LD_VAR 0 5
110083: PUSH
110084: LD_INT 1
110086: PLUS
110087: PPUSH
110088: LD_VAR 0 4
110092: PPUSH
110093: CALL_OW 256
110097: PPUSH
110098: CALL_OW 2
110102: ST_TO_ADDR
110103: GO 110066
110105: POP
110106: POP
// if not tmp then
110107: LD_VAR 0 5
110111: NOT
110112: IFFALSE 110116
// exit ;
110114: GO 110164
// if asc then
110116: LD_VAR 0 2
110120: IFFALSE 110144
// result := SortListByListAsc ( units , tmp ) else
110122: LD_ADDR_VAR 0 3
110126: PUSH
110127: LD_VAR 0 1
110131: PPUSH
110132: LD_VAR 0 5
110136: PPUSH
110137: CALL_OW 76
110141: ST_TO_ADDR
110142: GO 110164
// result := SortListByListDesc ( units , tmp ) ;
110144: LD_ADDR_VAR 0 3
110148: PUSH
110149: LD_VAR 0 1
110153: PPUSH
110154: LD_VAR 0 5
110158: PPUSH
110159: CALL_OW 77
110163: ST_TO_ADDR
// end ;
110164: LD_VAR 0 3
110168: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
110169: LD_INT 0
110171: PPUSH
110172: PPUSH
// task := GetTaskList ( mech ) ;
110173: LD_ADDR_VAR 0 4
110177: PUSH
110178: LD_VAR 0 1
110182: PPUSH
110183: CALL_OW 437
110187: ST_TO_ADDR
// if not task then
110188: LD_VAR 0 4
110192: NOT
110193: IFFALSE 110197
// exit ;
110195: GO 110239
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
110197: LD_ADDR_VAR 0 3
110201: PUSH
110202: LD_VAR 0 4
110206: PUSH
110207: LD_INT 1
110209: ARRAY
110210: PUSH
110211: LD_INT 1
110213: ARRAY
110214: PUSH
110215: LD_STRING r
110217: EQUAL
110218: PUSH
110219: LD_VAR 0 4
110223: PUSH
110224: LD_INT 1
110226: ARRAY
110227: PUSH
110228: LD_INT 4
110230: ARRAY
110231: PUSH
110232: LD_VAR 0 2
110236: EQUAL
110237: AND
110238: ST_TO_ADDR
// end ;
110239: LD_VAR 0 3
110243: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
110244: LD_INT 0
110246: PPUSH
// SetDir ( unit , d ) ;
110247: LD_VAR 0 1
110251: PPUSH
110252: LD_VAR 0 4
110256: PPUSH
110257: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
110261: LD_ADDR_VAR 0 6
110265: PUSH
110266: LD_VAR 0 1
110270: PPUSH
110271: LD_VAR 0 2
110275: PPUSH
110276: LD_VAR 0 3
110280: PPUSH
110281: LD_VAR 0 5
110285: PPUSH
110286: CALL_OW 48
110290: ST_TO_ADDR
// end ;
110291: LD_VAR 0 6
110295: RET
// export function ToNaturalNumber ( number ) ; begin
110296: LD_INT 0
110298: PPUSH
// result := number div 1 ;
110299: LD_ADDR_VAR 0 2
110303: PUSH
110304: LD_VAR 0 1
110308: PUSH
110309: LD_INT 1
110311: DIV
110312: ST_TO_ADDR
// if number < 0 then
110313: LD_VAR 0 1
110317: PUSH
110318: LD_INT 0
110320: LESS
110321: IFFALSE 110331
// result := 0 ;
110323: LD_ADDR_VAR 0 2
110327: PUSH
110328: LD_INT 0
110330: ST_TO_ADDR
// end ;
110331: LD_VAR 0 2
110335: RET
// export function SortByClass ( units , class ) ; var un ; begin
110336: LD_INT 0
110338: PPUSH
110339: PPUSH
// if not units or not class then
110340: LD_VAR 0 1
110344: NOT
110345: PUSH
110346: LD_VAR 0 2
110350: NOT
110351: OR
110352: IFFALSE 110356
// exit ;
110354: GO 110451
// result := [ ] ;
110356: LD_ADDR_VAR 0 3
110360: PUSH
110361: EMPTY
110362: ST_TO_ADDR
// for un in units do
110363: LD_ADDR_VAR 0 4
110367: PUSH
110368: LD_VAR 0 1
110372: PUSH
110373: FOR_IN
110374: IFFALSE 110449
// if GetClass ( un ) = class then
110376: LD_VAR 0 4
110380: PPUSH
110381: CALL_OW 257
110385: PUSH
110386: LD_VAR 0 2
110390: EQUAL
110391: IFFALSE 110418
// result := Insert ( result , 1 , un ) else
110393: LD_ADDR_VAR 0 3
110397: PUSH
110398: LD_VAR 0 3
110402: PPUSH
110403: LD_INT 1
110405: PPUSH
110406: LD_VAR 0 4
110410: PPUSH
110411: CALL_OW 2
110415: ST_TO_ADDR
110416: GO 110447
// result := Replace ( result , result + 1 , un ) ;
110418: LD_ADDR_VAR 0 3
110422: PUSH
110423: LD_VAR 0 3
110427: PPUSH
110428: LD_VAR 0 3
110432: PUSH
110433: LD_INT 1
110435: PLUS
110436: PPUSH
110437: LD_VAR 0 4
110441: PPUSH
110442: CALL_OW 1
110446: ST_TO_ADDR
110447: GO 110373
110449: POP
110450: POP
// end ;
110451: LD_VAR 0 3
110455: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
110456: LD_INT 0
110458: PPUSH
110459: PPUSH
110460: PPUSH
110461: PPUSH
110462: PPUSH
110463: PPUSH
110464: PPUSH
// result := [ ] ;
110465: LD_ADDR_VAR 0 4
110469: PUSH
110470: EMPTY
110471: ST_TO_ADDR
// if x - r < 0 then
110472: LD_VAR 0 1
110476: PUSH
110477: LD_VAR 0 3
110481: MINUS
110482: PUSH
110483: LD_INT 0
110485: LESS
110486: IFFALSE 110498
// min_x := 0 else
110488: LD_ADDR_VAR 0 8
110492: PUSH
110493: LD_INT 0
110495: ST_TO_ADDR
110496: GO 110514
// min_x := x - r ;
110498: LD_ADDR_VAR 0 8
110502: PUSH
110503: LD_VAR 0 1
110507: PUSH
110508: LD_VAR 0 3
110512: MINUS
110513: ST_TO_ADDR
// if y - r < 0 then
110514: LD_VAR 0 2
110518: PUSH
110519: LD_VAR 0 3
110523: MINUS
110524: PUSH
110525: LD_INT 0
110527: LESS
110528: IFFALSE 110540
// min_y := 0 else
110530: LD_ADDR_VAR 0 7
110534: PUSH
110535: LD_INT 0
110537: ST_TO_ADDR
110538: GO 110556
// min_y := y - r ;
110540: LD_ADDR_VAR 0 7
110544: PUSH
110545: LD_VAR 0 2
110549: PUSH
110550: LD_VAR 0 3
110554: MINUS
110555: ST_TO_ADDR
// max_x := x + r ;
110556: LD_ADDR_VAR 0 9
110560: PUSH
110561: LD_VAR 0 1
110565: PUSH
110566: LD_VAR 0 3
110570: PLUS
110571: ST_TO_ADDR
// max_y := y + r ;
110572: LD_ADDR_VAR 0 10
110576: PUSH
110577: LD_VAR 0 2
110581: PUSH
110582: LD_VAR 0 3
110586: PLUS
110587: ST_TO_ADDR
// for _x = min_x to max_x do
110588: LD_ADDR_VAR 0 5
110592: PUSH
110593: DOUBLE
110594: LD_VAR 0 8
110598: DEC
110599: ST_TO_ADDR
110600: LD_VAR 0 9
110604: PUSH
110605: FOR_TO
110606: IFFALSE 110707
// for _y = min_y to max_y do
110608: LD_ADDR_VAR 0 6
110612: PUSH
110613: DOUBLE
110614: LD_VAR 0 7
110618: DEC
110619: ST_TO_ADDR
110620: LD_VAR 0 10
110624: PUSH
110625: FOR_TO
110626: IFFALSE 110703
// begin if not ValidHex ( _x , _y ) then
110628: LD_VAR 0 5
110632: PPUSH
110633: LD_VAR 0 6
110637: PPUSH
110638: CALL_OW 488
110642: NOT
110643: IFFALSE 110647
// continue ;
110645: GO 110625
// if GetResourceTypeXY ( _x , _y ) then
110647: LD_VAR 0 5
110651: PPUSH
110652: LD_VAR 0 6
110656: PPUSH
110657: CALL_OW 283
110661: IFFALSE 110701
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
110663: LD_ADDR_VAR 0 4
110667: PUSH
110668: LD_VAR 0 4
110672: PPUSH
110673: LD_VAR 0 4
110677: PUSH
110678: LD_INT 1
110680: PLUS
110681: PPUSH
110682: LD_VAR 0 5
110686: PUSH
110687: LD_VAR 0 6
110691: PUSH
110692: EMPTY
110693: LIST
110694: LIST
110695: PPUSH
110696: CALL_OW 1
110700: ST_TO_ADDR
// end ;
110701: GO 110625
110703: POP
110704: POP
110705: GO 110605
110707: POP
110708: POP
// end ;
110709: LD_VAR 0 4
110713: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
110714: LD_INT 0
110716: PPUSH
110717: PPUSH
110718: PPUSH
110719: PPUSH
110720: PPUSH
110721: PPUSH
110722: PPUSH
110723: PPUSH
// if not units then
110724: LD_VAR 0 1
110728: NOT
110729: IFFALSE 110733
// exit ;
110731: GO 111261
// result := UnitFilter ( units , [ f_ok ] ) ;
110733: LD_ADDR_VAR 0 3
110737: PUSH
110738: LD_VAR 0 1
110742: PPUSH
110743: LD_INT 50
110745: PUSH
110746: EMPTY
110747: LIST
110748: PPUSH
110749: CALL_OW 72
110753: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
110754: LD_ADDR_VAR 0 8
110758: PUSH
110759: LD_VAR 0 1
110763: PUSH
110764: LD_INT 1
110766: ARRAY
110767: PPUSH
110768: CALL_OW 255
110772: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
110773: LD_ADDR_VAR 0 10
110777: PUSH
110778: LD_INT 29
110780: PUSH
110781: LD_INT 91
110783: PUSH
110784: LD_INT 49
110786: PUSH
110787: EMPTY
110788: LIST
110789: LIST
110790: LIST
110791: ST_TO_ADDR
// if not result then
110792: LD_VAR 0 3
110796: NOT
110797: IFFALSE 110801
// exit ;
110799: GO 111261
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
110801: LD_ADDR_VAR 0 5
110805: PUSH
110806: LD_INT 81
110808: PUSH
110809: LD_VAR 0 8
110813: PUSH
110814: EMPTY
110815: LIST
110816: LIST
110817: PPUSH
110818: CALL_OW 69
110822: ST_TO_ADDR
// for i in result do
110823: LD_ADDR_VAR 0 4
110827: PUSH
110828: LD_VAR 0 3
110832: PUSH
110833: FOR_IN
110834: IFFALSE 111259
// begin tag := GetTag ( i ) + 1 ;
110836: LD_ADDR_VAR 0 9
110840: PUSH
110841: LD_VAR 0 4
110845: PPUSH
110846: CALL_OW 110
110850: PUSH
110851: LD_INT 1
110853: PLUS
110854: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
110855: LD_ADDR_VAR 0 7
110859: PUSH
110860: LD_VAR 0 4
110864: PPUSH
110865: CALL_OW 250
110869: PPUSH
110870: LD_VAR 0 4
110874: PPUSH
110875: CALL_OW 251
110879: PPUSH
110880: LD_INT 4
110882: PPUSH
110883: CALL 110456 0 3
110887: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
110888: LD_VAR 0 4
110892: PPUSH
110893: CALL_OW 247
110897: PUSH
110898: LD_INT 2
110900: EQUAL
110901: PUSH
110902: LD_VAR 0 7
110906: PUSH
110907: LD_INT 2
110909: GREATER
110910: AND
110911: PUSH
110912: LD_VAR 0 4
110916: PPUSH
110917: CALL_OW 264
110921: PUSH
110922: LD_VAR 0 10
110926: IN
110927: NOT
110928: AND
110929: IFFALSE 110968
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110931: LD_VAR 0 4
110935: PPUSH
110936: LD_VAR 0 7
110940: PUSH
110941: LD_INT 1
110943: ARRAY
110944: PUSH
110945: LD_INT 1
110947: ARRAY
110948: PPUSH
110949: LD_VAR 0 7
110953: PUSH
110954: LD_INT 1
110956: ARRAY
110957: PUSH
110958: LD_INT 2
110960: ARRAY
110961: PPUSH
110962: CALL_OW 116
110966: GO 111257
// if path > tag then
110968: LD_VAR 0 2
110972: PUSH
110973: LD_VAR 0 9
110977: GREATER
110978: IFFALSE 111186
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110980: LD_ADDR_VAR 0 6
110984: PUSH
110985: LD_VAR 0 5
110989: PPUSH
110990: LD_INT 91
110992: PUSH
110993: LD_VAR 0 4
110997: PUSH
110998: LD_INT 8
111000: PUSH
111001: EMPTY
111002: LIST
111003: LIST
111004: LIST
111005: PPUSH
111006: CALL_OW 72
111010: ST_TO_ADDR
// if nearEnemy then
111011: LD_VAR 0 6
111015: IFFALSE 111084
// begin if GetWeapon ( i ) = ru_time_lapser then
111017: LD_VAR 0 4
111021: PPUSH
111022: CALL_OW 264
111026: PUSH
111027: LD_INT 49
111029: EQUAL
111030: IFFALSE 111058
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
111032: LD_VAR 0 4
111036: PPUSH
111037: LD_VAR 0 6
111041: PPUSH
111042: LD_VAR 0 4
111046: PPUSH
111047: CALL_OW 74
111051: PPUSH
111052: CALL_OW 112
111056: GO 111082
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
111058: LD_VAR 0 4
111062: PPUSH
111063: LD_VAR 0 6
111067: PPUSH
111068: LD_VAR 0 4
111072: PPUSH
111073: CALL_OW 74
111077: PPUSH
111078: CALL 112332 0 2
// end else
111082: GO 111184
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
111084: LD_VAR 0 4
111088: PPUSH
111089: LD_VAR 0 2
111093: PUSH
111094: LD_VAR 0 9
111098: ARRAY
111099: PUSH
111100: LD_INT 1
111102: ARRAY
111103: PPUSH
111104: LD_VAR 0 2
111108: PUSH
111109: LD_VAR 0 9
111113: ARRAY
111114: PUSH
111115: LD_INT 2
111117: ARRAY
111118: PPUSH
111119: CALL_OW 297
111123: PUSH
111124: LD_INT 6
111126: GREATER
111127: IFFALSE 111170
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
111129: LD_VAR 0 4
111133: PPUSH
111134: LD_VAR 0 2
111138: PUSH
111139: LD_VAR 0 9
111143: ARRAY
111144: PUSH
111145: LD_INT 1
111147: ARRAY
111148: PPUSH
111149: LD_VAR 0 2
111153: PUSH
111154: LD_VAR 0 9
111158: ARRAY
111159: PUSH
111160: LD_INT 2
111162: ARRAY
111163: PPUSH
111164: CALL_OW 114
111168: GO 111184
// SetTag ( i , tag ) ;
111170: LD_VAR 0 4
111174: PPUSH
111175: LD_VAR 0 9
111179: PPUSH
111180: CALL_OW 109
// end else
111184: GO 111257
// if enemy then
111186: LD_VAR 0 5
111190: IFFALSE 111257
// begin if GetWeapon ( i ) = ru_time_lapser then
111192: LD_VAR 0 4
111196: PPUSH
111197: CALL_OW 264
111201: PUSH
111202: LD_INT 49
111204: EQUAL
111205: IFFALSE 111233
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
111207: LD_VAR 0 4
111211: PPUSH
111212: LD_VAR 0 5
111216: PPUSH
111217: LD_VAR 0 4
111221: PPUSH
111222: CALL_OW 74
111226: PPUSH
111227: CALL_OW 112
111231: GO 111257
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
111233: LD_VAR 0 4
111237: PPUSH
111238: LD_VAR 0 5
111242: PPUSH
111243: LD_VAR 0 4
111247: PPUSH
111248: CALL_OW 74
111252: PPUSH
111253: CALL 112332 0 2
// end ; end ;
111257: GO 110833
111259: POP
111260: POP
// end ;
111261: LD_VAR 0 3
111265: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
111266: LD_INT 0
111268: PPUSH
111269: PPUSH
111270: PPUSH
// if not unit or IsInUnit ( unit ) then
111271: LD_VAR 0 1
111275: NOT
111276: PUSH
111277: LD_VAR 0 1
111281: PPUSH
111282: CALL_OW 310
111286: OR
111287: IFFALSE 111291
// exit ;
111289: GO 111382
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
111291: LD_ADDR_VAR 0 4
111295: PUSH
111296: LD_VAR 0 1
111300: PPUSH
111301: CALL_OW 250
111305: PPUSH
111306: LD_VAR 0 2
111310: PPUSH
111311: LD_INT 1
111313: PPUSH
111314: CALL_OW 272
111318: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
111319: LD_ADDR_VAR 0 5
111323: PUSH
111324: LD_VAR 0 1
111328: PPUSH
111329: CALL_OW 251
111333: PPUSH
111334: LD_VAR 0 2
111338: PPUSH
111339: LD_INT 1
111341: PPUSH
111342: CALL_OW 273
111346: ST_TO_ADDR
// if ValidHex ( x , y ) then
111347: LD_VAR 0 4
111351: PPUSH
111352: LD_VAR 0 5
111356: PPUSH
111357: CALL_OW 488
111361: IFFALSE 111382
// ComTurnXY ( unit , x , y ) ;
111363: LD_VAR 0 1
111367: PPUSH
111368: LD_VAR 0 4
111372: PPUSH
111373: LD_VAR 0 5
111377: PPUSH
111378: CALL_OW 118
// end ;
111382: LD_VAR 0 3
111386: RET
// export function SeeUnits ( side , units ) ; var i ; begin
111387: LD_INT 0
111389: PPUSH
111390: PPUSH
// result := false ;
111391: LD_ADDR_VAR 0 3
111395: PUSH
111396: LD_INT 0
111398: ST_TO_ADDR
// if not units then
111399: LD_VAR 0 2
111403: NOT
111404: IFFALSE 111408
// exit ;
111406: GO 111453
// for i in units do
111408: LD_ADDR_VAR 0 4
111412: PUSH
111413: LD_VAR 0 2
111417: PUSH
111418: FOR_IN
111419: IFFALSE 111451
// if See ( side , i ) then
111421: LD_VAR 0 1
111425: PPUSH
111426: LD_VAR 0 4
111430: PPUSH
111431: CALL_OW 292
111435: IFFALSE 111449
// begin result := true ;
111437: LD_ADDR_VAR 0 3
111441: PUSH
111442: LD_INT 1
111444: ST_TO_ADDR
// exit ;
111445: POP
111446: POP
111447: GO 111453
// end ;
111449: GO 111418
111451: POP
111452: POP
// end ;
111453: LD_VAR 0 3
111457: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
111458: LD_INT 0
111460: PPUSH
111461: PPUSH
111462: PPUSH
111463: PPUSH
// if not unit or not points then
111464: LD_VAR 0 1
111468: NOT
111469: PUSH
111470: LD_VAR 0 2
111474: NOT
111475: OR
111476: IFFALSE 111480
// exit ;
111478: GO 111570
// dist := 99999 ;
111480: LD_ADDR_VAR 0 5
111484: PUSH
111485: LD_INT 99999
111487: ST_TO_ADDR
// for i in points do
111488: LD_ADDR_VAR 0 4
111492: PUSH
111493: LD_VAR 0 2
111497: PUSH
111498: FOR_IN
111499: IFFALSE 111568
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
111501: LD_ADDR_VAR 0 6
111505: PUSH
111506: LD_VAR 0 1
111510: PPUSH
111511: LD_VAR 0 4
111515: PUSH
111516: LD_INT 1
111518: ARRAY
111519: PPUSH
111520: LD_VAR 0 4
111524: PUSH
111525: LD_INT 2
111527: ARRAY
111528: PPUSH
111529: CALL_OW 297
111533: ST_TO_ADDR
// if tmpDist < dist then
111534: LD_VAR 0 6
111538: PUSH
111539: LD_VAR 0 5
111543: LESS
111544: IFFALSE 111566
// begin result := i ;
111546: LD_ADDR_VAR 0 3
111550: PUSH
111551: LD_VAR 0 4
111555: ST_TO_ADDR
// dist := tmpDist ;
111556: LD_ADDR_VAR 0 5
111560: PUSH
111561: LD_VAR 0 6
111565: ST_TO_ADDR
// end ; end ;
111566: GO 111498
111568: POP
111569: POP
// end ;
111570: LD_VAR 0 3
111574: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
111575: LD_INT 0
111577: PPUSH
// uc_side := side ;
111578: LD_ADDR_OWVAR 20
111582: PUSH
111583: LD_VAR 0 1
111587: ST_TO_ADDR
// uc_nation := 3 ;
111588: LD_ADDR_OWVAR 21
111592: PUSH
111593: LD_INT 3
111595: ST_TO_ADDR
// vc_chassis := 25 ;
111596: LD_ADDR_OWVAR 37
111600: PUSH
111601: LD_INT 25
111603: ST_TO_ADDR
// vc_engine := engine_siberite ;
111604: LD_ADDR_OWVAR 39
111608: PUSH
111609: LD_INT 3
111611: ST_TO_ADDR
// vc_control := control_computer ;
111612: LD_ADDR_OWVAR 38
111616: PUSH
111617: LD_INT 3
111619: ST_TO_ADDR
// vc_weapon := 59 ;
111620: LD_ADDR_OWVAR 40
111624: PUSH
111625: LD_INT 59
111627: ST_TO_ADDR
// result := CreateVehicle ;
111628: LD_ADDR_VAR 0 5
111632: PUSH
111633: CALL_OW 45
111637: ST_TO_ADDR
// SetDir ( result , d ) ;
111638: LD_VAR 0 5
111642: PPUSH
111643: LD_VAR 0 4
111647: PPUSH
111648: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
111652: LD_VAR 0 5
111656: PPUSH
111657: LD_VAR 0 2
111661: PPUSH
111662: LD_VAR 0 3
111666: PPUSH
111667: LD_INT 0
111669: PPUSH
111670: CALL_OW 48
// end ;
111674: LD_VAR 0 5
111678: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
111679: LD_INT 0
111681: PPUSH
111682: PPUSH
111683: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
111684: LD_ADDR_VAR 0 2
111688: PUSH
111689: LD_INT 0
111691: PUSH
111692: LD_INT 0
111694: PUSH
111695: LD_INT 0
111697: PUSH
111698: LD_INT 0
111700: PUSH
111701: EMPTY
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
111707: LD_VAR 0 1
111711: NOT
111712: PUSH
111713: LD_VAR 0 1
111717: PPUSH
111718: CALL_OW 264
111722: PUSH
111723: LD_INT 12
111725: PUSH
111726: LD_INT 51
111728: PUSH
111729: LD_INT 32
111731: PUSH
111732: LD_INT 89
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: LIST
111739: LIST
111740: IN
111741: NOT
111742: OR
111743: IFFALSE 111747
// exit ;
111745: GO 111845
// for i := 1 to 3 do
111747: LD_ADDR_VAR 0 3
111751: PUSH
111752: DOUBLE
111753: LD_INT 1
111755: DEC
111756: ST_TO_ADDR
111757: LD_INT 3
111759: PUSH
111760: FOR_TO
111761: IFFALSE 111843
// begin tmp := GetCargo ( cargo , i ) ;
111763: LD_ADDR_VAR 0 4
111767: PUSH
111768: LD_VAR 0 1
111772: PPUSH
111773: LD_VAR 0 3
111777: PPUSH
111778: CALL_OW 289
111782: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
111783: LD_ADDR_VAR 0 2
111787: PUSH
111788: LD_VAR 0 2
111792: PPUSH
111793: LD_VAR 0 3
111797: PPUSH
111798: LD_VAR 0 4
111802: PPUSH
111803: CALL_OW 1
111807: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
111808: LD_ADDR_VAR 0 2
111812: PUSH
111813: LD_VAR 0 2
111817: PPUSH
111818: LD_INT 4
111820: PPUSH
111821: LD_VAR 0 2
111825: PUSH
111826: LD_INT 4
111828: ARRAY
111829: PUSH
111830: LD_VAR 0 4
111834: PLUS
111835: PPUSH
111836: CALL_OW 1
111840: ST_TO_ADDR
// end ;
111841: GO 111760
111843: POP
111844: POP
// end ;
111845: LD_VAR 0 2
111849: RET
// export function Length ( array ) ; begin
111850: LD_INT 0
111852: PPUSH
// result := array + 0 ;
111853: LD_ADDR_VAR 0 2
111857: PUSH
111858: LD_VAR 0 1
111862: PUSH
111863: LD_INT 0
111865: PLUS
111866: ST_TO_ADDR
// end ;
111867: LD_VAR 0 2
111871: RET
// export function PrepareArray ( array ) ; begin
111872: LD_INT 0
111874: PPUSH
// result := array diff 0 ;
111875: LD_ADDR_VAR 0 2
111879: PUSH
111880: LD_VAR 0 1
111884: PUSH
111885: LD_INT 0
111887: DIFF
111888: ST_TO_ADDR
// if not result [ 1 ] then
111889: LD_VAR 0 2
111893: PUSH
111894: LD_INT 1
111896: ARRAY
111897: NOT
111898: IFFALSE 111918
// result := Delete ( result , 1 ) ;
111900: LD_ADDR_VAR 0 2
111904: PUSH
111905: LD_VAR 0 2
111909: PPUSH
111910: LD_INT 1
111912: PPUSH
111913: CALL_OW 3
111917: ST_TO_ADDR
// end ;
111918: LD_VAR 0 2
111922: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111923: LD_INT 0
111925: PPUSH
111926: PPUSH
111927: PPUSH
111928: PPUSH
// sibRocketRange := 25 ;
111929: LD_ADDR_VAR 0 6
111933: PUSH
111934: LD_INT 25
111936: ST_TO_ADDR
// result := false ;
111937: LD_ADDR_VAR 0 4
111941: PUSH
111942: LD_INT 0
111944: ST_TO_ADDR
// for i := 0 to 5 do
111945: LD_ADDR_VAR 0 5
111949: PUSH
111950: DOUBLE
111951: LD_INT 0
111953: DEC
111954: ST_TO_ADDR
111955: LD_INT 5
111957: PUSH
111958: FOR_TO
111959: IFFALSE 112026
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111961: LD_VAR 0 1
111965: PPUSH
111966: LD_VAR 0 5
111970: PPUSH
111971: LD_VAR 0 6
111975: PPUSH
111976: CALL_OW 272
111980: PPUSH
111981: LD_VAR 0 2
111985: PPUSH
111986: LD_VAR 0 5
111990: PPUSH
111991: LD_VAR 0 6
111995: PPUSH
111996: CALL_OW 273
112000: PPUSH
112001: LD_VAR 0 3
112005: PPUSH
112006: CALL_OW 309
112010: IFFALSE 112024
// begin result := true ;
112012: LD_ADDR_VAR 0 4
112016: PUSH
112017: LD_INT 1
112019: ST_TO_ADDR
// exit ;
112020: POP
112021: POP
112022: GO 112028
// end ;
112024: GO 111958
112026: POP
112027: POP
// end ;
112028: LD_VAR 0 4
112032: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
112033: LD_INT 0
112035: PPUSH
112036: PPUSH
112037: PPUSH
// if btype = b_depot then
112038: LD_VAR 0 2
112042: PUSH
112043: LD_INT 0
112045: EQUAL
112046: IFFALSE 112058
// begin result := true ;
112048: LD_ADDR_VAR 0 3
112052: PUSH
112053: LD_INT 1
112055: ST_TO_ADDR
// exit ;
112056: GO 112174
// end ; pom := GetBase ( depot ) ;
112058: LD_ADDR_VAR 0 4
112062: PUSH
112063: LD_VAR 0 1
112067: PPUSH
112068: CALL_OW 274
112072: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
112073: LD_ADDR_VAR 0 5
112077: PUSH
112078: LD_VAR 0 2
112082: PPUSH
112083: LD_VAR 0 1
112087: PPUSH
112088: CALL_OW 248
112092: PPUSH
112093: CALL_OW 450
112097: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
112098: LD_ADDR_VAR 0 3
112102: PUSH
112103: LD_VAR 0 4
112107: PPUSH
112108: LD_INT 1
112110: PPUSH
112111: CALL_OW 275
112115: PUSH
112116: LD_VAR 0 5
112120: PUSH
112121: LD_INT 1
112123: ARRAY
112124: GREATEREQUAL
112125: PUSH
112126: LD_VAR 0 4
112130: PPUSH
112131: LD_INT 2
112133: PPUSH
112134: CALL_OW 275
112138: PUSH
112139: LD_VAR 0 5
112143: PUSH
112144: LD_INT 2
112146: ARRAY
112147: GREATEREQUAL
112148: AND
112149: PUSH
112150: LD_VAR 0 4
112154: PPUSH
112155: LD_INT 3
112157: PPUSH
112158: CALL_OW 275
112162: PUSH
112163: LD_VAR 0 5
112167: PUSH
112168: LD_INT 3
112170: ARRAY
112171: GREATEREQUAL
112172: AND
112173: ST_TO_ADDR
// end ;
112174: LD_VAR 0 3
112178: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
112179: LD_INT 0
112181: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
112182: LD_VAR 0 1
112186: PPUSH
112187: LD_VAR 0 2
112191: PPUSH
112192: LD_INT 0
112194: PPUSH
112195: LD_INT 0
112197: PPUSH
112198: LD_INT 1
112200: PPUSH
112201: LD_INT 0
112203: PPUSH
112204: CALL_OW 587
// end ;
112208: LD_VAR 0 3
112212: RET
// export function CenterOnNow ( unit ) ; begin
112213: LD_INT 0
112215: PPUSH
// result := IsInUnit ( unit ) ;
112216: LD_ADDR_VAR 0 2
112220: PUSH
112221: LD_VAR 0 1
112225: PPUSH
112226: CALL_OW 310
112230: ST_TO_ADDR
// if not result then
112231: LD_VAR 0 2
112235: NOT
112236: IFFALSE 112248
// result := unit ;
112238: LD_ADDR_VAR 0 2
112242: PUSH
112243: LD_VAR 0 1
112247: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
112248: LD_VAR 0 1
112252: PPUSH
112253: CALL_OW 87
// end ;
112257: LD_VAR 0 2
112261: RET
// export function ComMoveHex ( unit , hex ) ; begin
112262: LD_INT 0
112264: PPUSH
// if not hex then
112265: LD_VAR 0 2
112269: NOT
112270: IFFALSE 112274
// exit ;
112272: GO 112327
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
112274: LD_VAR 0 2
112278: PUSH
112279: LD_INT 1
112281: ARRAY
112282: PPUSH
112283: LD_VAR 0 2
112287: PUSH
112288: LD_INT 2
112290: ARRAY
112291: PPUSH
112292: CALL_OW 428
112296: IFFALSE 112300
// exit ;
112298: GO 112327
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
112300: LD_VAR 0 1
112304: PPUSH
112305: LD_VAR 0 2
112309: PUSH
112310: LD_INT 1
112312: ARRAY
112313: PPUSH
112314: LD_VAR 0 2
112318: PUSH
112319: LD_INT 2
112321: ARRAY
112322: PPUSH
112323: CALL_OW 111
// end ;
112327: LD_VAR 0 3
112331: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
112332: LD_INT 0
112334: PPUSH
112335: PPUSH
112336: PPUSH
// if not unit or not enemy then
112337: LD_VAR 0 1
112341: NOT
112342: PUSH
112343: LD_VAR 0 2
112347: NOT
112348: OR
112349: IFFALSE 112353
// exit ;
112351: GO 112477
// x := GetX ( enemy ) ;
112353: LD_ADDR_VAR 0 4
112357: PUSH
112358: LD_VAR 0 2
112362: PPUSH
112363: CALL_OW 250
112367: ST_TO_ADDR
// y := GetY ( enemy ) ;
112368: LD_ADDR_VAR 0 5
112372: PUSH
112373: LD_VAR 0 2
112377: PPUSH
112378: CALL_OW 251
112382: ST_TO_ADDR
// if ValidHex ( x , y ) then
112383: LD_VAR 0 4
112387: PPUSH
112388: LD_VAR 0 5
112392: PPUSH
112393: CALL_OW 488
112397: IFFALSE 112477
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
112399: LD_VAR 0 2
112403: PPUSH
112404: CALL_OW 247
112408: PUSH
112409: LD_INT 3
112411: PUSH
112412: LD_INT 2
112414: PUSH
112415: EMPTY
112416: LIST
112417: LIST
112418: IN
112419: PUSH
112420: LD_VAR 0 1
112424: PPUSH
112425: CALL_OW 255
112429: PPUSH
112430: LD_VAR 0 2
112434: PPUSH
112435: CALL_OW 292
112439: OR
112440: IFFALSE 112458
// ComAttackUnit ( unit , enemy ) else
112442: LD_VAR 0 1
112446: PPUSH
112447: LD_VAR 0 2
112451: PPUSH
112452: CALL_OW 115
112456: GO 112477
// ComAgressiveMove ( unit , x , y ) ;
112458: LD_VAR 0 1
112462: PPUSH
112463: LD_VAR 0 4
112467: PPUSH
112468: LD_VAR 0 5
112472: PPUSH
112473: CALL_OW 114
// end ;
112477: LD_VAR 0 3
112481: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
112482: LD_INT 0
112484: PPUSH
112485: PPUSH
112486: PPUSH
// list := AreaToList ( area , 0 ) ;
112487: LD_ADDR_VAR 0 5
112491: PUSH
112492: LD_VAR 0 1
112496: PPUSH
112497: LD_INT 0
112499: PPUSH
112500: CALL_OW 517
112504: ST_TO_ADDR
// if not list then
112505: LD_VAR 0 5
112509: NOT
112510: IFFALSE 112514
// exit ;
112512: GO 112644
// if all then
112514: LD_VAR 0 2
112518: IFFALSE 112606
// begin for i := 1 to list [ 1 ] do
112520: LD_ADDR_VAR 0 4
112524: PUSH
112525: DOUBLE
112526: LD_INT 1
112528: DEC
112529: ST_TO_ADDR
112530: LD_VAR 0 5
112534: PUSH
112535: LD_INT 1
112537: ARRAY
112538: PUSH
112539: FOR_TO
112540: IFFALSE 112602
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
112542: LD_ADDR_VAR 0 3
112546: PUSH
112547: LD_VAR 0 3
112551: PPUSH
112552: LD_VAR 0 3
112556: PUSH
112557: LD_INT 1
112559: PLUS
112560: PPUSH
112561: LD_VAR 0 5
112565: PUSH
112566: LD_INT 1
112568: ARRAY
112569: PUSH
112570: LD_VAR 0 4
112574: ARRAY
112575: PUSH
112576: LD_VAR 0 5
112580: PUSH
112581: LD_INT 2
112583: ARRAY
112584: PUSH
112585: LD_VAR 0 4
112589: ARRAY
112590: PUSH
112591: EMPTY
112592: LIST
112593: LIST
112594: PPUSH
112595: CALL_OW 1
112599: ST_TO_ADDR
112600: GO 112539
112602: POP
112603: POP
// exit ;
112604: GO 112644
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
112606: LD_ADDR_VAR 0 3
112610: PUSH
112611: LD_VAR 0 5
112615: PUSH
112616: LD_INT 1
112618: ARRAY
112619: PUSH
112620: LD_INT 1
112622: ARRAY
112623: PUSH
112624: LD_VAR 0 5
112628: PUSH
112629: LD_INT 2
112631: ARRAY
112632: PUSH
112633: LD_INT 1
112635: ARRAY
112636: PUSH
112637: EMPTY
112638: LIST
112639: LIST
112640: PUSH
112641: EMPTY
112642: LIST
112643: ST_TO_ADDR
// end ;
112644: LD_VAR 0 3
112648: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
112649: LD_INT 0
112651: PPUSH
112652: PPUSH
// list := AreaToList ( area , 0 ) ;
112653: LD_ADDR_VAR 0 4
112657: PUSH
112658: LD_VAR 0 1
112662: PPUSH
112663: LD_INT 0
112665: PPUSH
112666: CALL_OW 517
112670: ST_TO_ADDR
// if not list then
112671: LD_VAR 0 4
112675: NOT
112676: IFFALSE 112680
// exit ;
112678: GO 112721
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
112680: LD_ADDR_VAR 0 3
112684: PUSH
112685: LD_VAR 0 4
112689: PUSH
112690: LD_INT 1
112692: ARRAY
112693: PUSH
112694: LD_INT 1
112696: ARRAY
112697: PUSH
112698: LD_VAR 0 4
112702: PUSH
112703: LD_INT 2
112705: ARRAY
112706: PUSH
112707: LD_INT 1
112709: ARRAY
112710: PUSH
112711: LD_VAR 0 2
112715: PUSH
112716: EMPTY
112717: LIST
112718: LIST
112719: LIST
112720: ST_TO_ADDR
// end ;
112721: LD_VAR 0 3
112725: RET
// export function First ( array ) ; begin
112726: LD_INT 0
112728: PPUSH
// if not array then
112729: LD_VAR 0 1
112733: NOT
112734: IFFALSE 112738
// exit ;
112736: GO 112752
// result := array [ 1 ] ;
112738: LD_ADDR_VAR 0 2
112742: PUSH
112743: LD_VAR 0 1
112747: PUSH
112748: LD_INT 1
112750: ARRAY
112751: ST_TO_ADDR
// end ;
112752: LD_VAR 0 2
112756: RET
// export function Last ( array ) ; begin
112757: LD_INT 0
112759: PPUSH
// if not array then
112760: LD_VAR 0 1
112764: NOT
112765: IFFALSE 112769
// exit ;
112767: GO 112785
// result := array [ array ] ;
112769: LD_ADDR_VAR 0 2
112773: PUSH
112774: LD_VAR 0 1
112778: PUSH
112779: LD_VAR 0 1
112783: ARRAY
112784: ST_TO_ADDR
// end ;
112785: LD_VAR 0 2
112789: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
112790: LD_INT 0
112792: PPUSH
112793: PPUSH
// result := [ ] ;
112794: LD_ADDR_VAR 0 5
112798: PUSH
112799: EMPTY
112800: ST_TO_ADDR
// if not array then
112801: LD_VAR 0 1
112805: NOT
112806: IFFALSE 112810
// exit ;
112808: GO 112922
// for i := 1 to array do
112810: LD_ADDR_VAR 0 6
112814: PUSH
112815: DOUBLE
112816: LD_INT 1
112818: DEC
112819: ST_TO_ADDR
112820: LD_VAR 0 1
112824: PUSH
112825: FOR_TO
112826: IFFALSE 112920
// if array [ i ] [ index ] = value then
112828: LD_VAR 0 1
112832: PUSH
112833: LD_VAR 0 6
112837: ARRAY
112838: PUSH
112839: LD_VAR 0 2
112843: ARRAY
112844: PUSH
112845: LD_VAR 0 3
112849: EQUAL
112850: IFFALSE 112918
// begin if indexColumn then
112852: LD_VAR 0 4
112856: IFFALSE 112892
// result := Join ( result , array [ i ] [ indexColumn ] ) else
112858: LD_ADDR_VAR 0 5
112862: PUSH
112863: LD_VAR 0 5
112867: PPUSH
112868: LD_VAR 0 1
112872: PUSH
112873: LD_VAR 0 6
112877: ARRAY
112878: PUSH
112879: LD_VAR 0 4
112883: ARRAY
112884: PPUSH
112885: CALL 108104 0 2
112889: ST_TO_ADDR
112890: GO 112918
// result := Join ( result , array [ i ] ) ;
112892: LD_ADDR_VAR 0 5
112896: PUSH
112897: LD_VAR 0 5
112901: PPUSH
112902: LD_VAR 0 1
112906: PUSH
112907: LD_VAR 0 6
112911: ARRAY
112912: PPUSH
112913: CALL 108104 0 2
112917: ST_TO_ADDR
// end ;
112918: GO 112825
112920: POP
112921: POP
// end ;
112922: LD_VAR 0 5
112926: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112927: LD_INT 0
112929: PPUSH
// if not vehicles or not parkingPoint then
112930: LD_VAR 0 1
112934: NOT
112935: PUSH
112936: LD_VAR 0 2
112940: NOT
112941: OR
112942: IFFALSE 112946
// exit ;
112944: GO 113044
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112946: LD_ADDR_VAR 0 1
112950: PUSH
112951: LD_VAR 0 1
112955: PPUSH
112956: LD_INT 50
112958: PUSH
112959: EMPTY
112960: LIST
112961: PUSH
112962: LD_INT 3
112964: PUSH
112965: LD_INT 92
112967: PUSH
112968: LD_VAR 0 2
112972: PUSH
112973: LD_INT 1
112975: ARRAY
112976: PUSH
112977: LD_VAR 0 2
112981: PUSH
112982: LD_INT 2
112984: ARRAY
112985: PUSH
112986: LD_INT 8
112988: PUSH
112989: EMPTY
112990: LIST
112991: LIST
112992: LIST
112993: LIST
112994: PUSH
112995: EMPTY
112996: LIST
112997: LIST
112998: PUSH
112999: EMPTY
113000: LIST
113001: LIST
113002: PPUSH
113003: CALL_OW 72
113007: ST_TO_ADDR
// if not vehicles then
113008: LD_VAR 0 1
113012: NOT
113013: IFFALSE 113017
// exit ;
113015: GO 113044
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
113017: LD_VAR 0 1
113021: PPUSH
113022: LD_VAR 0 2
113026: PUSH
113027: LD_INT 1
113029: ARRAY
113030: PPUSH
113031: LD_VAR 0 2
113035: PUSH
113036: LD_INT 2
113038: ARRAY
113039: PPUSH
113040: CALL_OW 111
// end ;
113044: LD_VAR 0 3
113048: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
113049: LD_INT 0
113051: PPUSH
113052: PPUSH
113053: PPUSH
// if not side or not area then
113054: LD_VAR 0 1
113058: NOT
113059: PUSH
113060: LD_VAR 0 2
113064: NOT
113065: OR
113066: IFFALSE 113070
// exit ;
113068: GO 113189
// tmp := AreaToList ( area , 0 ) ;
113070: LD_ADDR_VAR 0 5
113074: PUSH
113075: LD_VAR 0 2
113079: PPUSH
113080: LD_INT 0
113082: PPUSH
113083: CALL_OW 517
113087: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
113088: LD_ADDR_VAR 0 4
113092: PUSH
113093: DOUBLE
113094: LD_INT 1
113096: DEC
113097: ST_TO_ADDR
113098: LD_VAR 0 5
113102: PUSH
113103: LD_INT 1
113105: ARRAY
113106: PUSH
113107: FOR_TO
113108: IFFALSE 113187
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
113110: LD_VAR 0 5
113114: PUSH
113115: LD_INT 1
113117: ARRAY
113118: PUSH
113119: LD_VAR 0 4
113123: ARRAY
113124: PPUSH
113125: LD_VAR 0 5
113129: PUSH
113130: LD_INT 2
113132: ARRAY
113133: PUSH
113134: LD_VAR 0 4
113138: ARRAY
113139: PPUSH
113140: CALL_OW 351
113144: IFFALSE 113185
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
113146: LD_VAR 0 5
113150: PUSH
113151: LD_INT 1
113153: ARRAY
113154: PUSH
113155: LD_VAR 0 4
113159: ARRAY
113160: PPUSH
113161: LD_VAR 0 5
113165: PUSH
113166: LD_INT 2
113168: ARRAY
113169: PUSH
113170: LD_VAR 0 4
113174: ARRAY
113175: PPUSH
113176: LD_VAR 0 1
113180: PPUSH
113181: CALL_OW 244
// end ;
113185: GO 113107
113187: POP
113188: POP
// end ; end_of_file end_of_file
113189: LD_VAR 0 3
113193: RET
// export globalGameSaveCounter ; every 0 0$1 do
113194: GO 113196
113196: DISABLE
// begin enable ;
113197: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
113198: LD_STRING updateTimer(
113200: PUSH
113201: LD_OWVAR 1
113205: STR
113206: PUSH
113207: LD_STRING );
113209: STR
113210: PPUSH
113211: CALL_OW 559
// end ;
113215: END
// every 0 0$1 do
113216: GO 113218
113218: DISABLE
// begin globalGameSaveCounter := 0 ;
113219: LD_ADDR_EXP 147
113223: PUSH
113224: LD_INT 0
113226: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
113227: LD_STRING setGameSaveCounter(0)
113229: PPUSH
113230: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
113234: LD_STRING initStreamRollete();
113236: PPUSH
113237: CALL_OW 559
// InitStreamMode ;
113241: CALL 114584 0 0
// DefineStreamItems ( false ) ;
113245: LD_INT 0
113247: PPUSH
113248: CALL 115048 0 1
// end ;
113252: END
// export function SOS_MapStart ( ) ; begin
113253: LD_INT 0
113255: PPUSH
// if streamModeActive then
113256: LD_EXP 148
113260: IFFALSE 113269
// DefineStreamItems ( true ) ;
113262: LD_INT 1
113264: PPUSH
113265: CALL 115048 0 1
// UpdateLuaVariables ( ) ;
113269: CALL 113286 0 0
// UpdateFactoryWaypoints ( ) ;
113273: CALL 128050 0 0
// UpdateWarehouseGatheringPoints ( ) ;
113277: CALL 128302 0 0
// end ;
113281: LD_VAR 0 1
113285: RET
// function UpdateLuaVariables ( ) ; begin
113286: LD_INT 0
113288: PPUSH
// if globalGameSaveCounter then
113289: LD_EXP 147
113293: IFFALSE 113327
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
113295: LD_ADDR_EXP 147
113299: PUSH
113300: LD_EXP 147
113304: PPUSH
113305: CALL 109465 0 1
113309: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113310: LD_STRING setGameSaveCounter(
113312: PUSH
113313: LD_EXP 147
113317: STR
113318: PUSH
113319: LD_STRING )
113321: STR
113322: PPUSH
113323: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
113327: LD_STRING setGameDifficulty(
113329: PUSH
113330: LD_OWVAR 67
113334: STR
113335: PUSH
113336: LD_STRING )
113338: STR
113339: PPUSH
113340: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
113344: LD_STRING displayDifficulty(
113346: PUSH
113347: LD_OWVAR 67
113351: STR
113352: PUSH
113353: LD_STRING )
113355: STR
113356: PPUSH
113357: CALL_OW 559
// end ;
113361: LD_VAR 0 1
113365: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
113366: LD_INT 0
113368: PPUSH
// if p2 = stream_mode then
113369: LD_VAR 0 2
113373: PUSH
113374: LD_INT 100
113376: EQUAL
113377: IFFALSE 114380
// begin if not StreamModeActive then
113379: LD_EXP 148
113383: NOT
113384: IFFALSE 113394
// StreamModeActive := true ;
113386: LD_ADDR_EXP 148
113390: PUSH
113391: LD_INT 1
113393: ST_TO_ADDR
// if p3 = 0 then
113394: LD_VAR 0 3
113398: PUSH
113399: LD_INT 0
113401: EQUAL
113402: IFFALSE 113408
// InitStreamMode ;
113404: CALL 114584 0 0
// if p3 = 1 then
113408: LD_VAR 0 3
113412: PUSH
113413: LD_INT 1
113415: EQUAL
113416: IFFALSE 113426
// sRocket := true ;
113418: LD_ADDR_EXP 153
113422: PUSH
113423: LD_INT 1
113425: ST_TO_ADDR
// if p3 = 2 then
113426: LD_VAR 0 3
113430: PUSH
113431: LD_INT 2
113433: EQUAL
113434: IFFALSE 113444
// sSpeed := true ;
113436: LD_ADDR_EXP 152
113440: PUSH
113441: LD_INT 1
113443: ST_TO_ADDR
// if p3 = 3 then
113444: LD_VAR 0 3
113448: PUSH
113449: LD_INT 3
113451: EQUAL
113452: IFFALSE 113462
// sEngine := true ;
113454: LD_ADDR_EXP 154
113458: PUSH
113459: LD_INT 1
113461: ST_TO_ADDR
// if p3 = 4 then
113462: LD_VAR 0 3
113466: PUSH
113467: LD_INT 4
113469: EQUAL
113470: IFFALSE 113480
// sSpec := true ;
113472: LD_ADDR_EXP 151
113476: PUSH
113477: LD_INT 1
113479: ST_TO_ADDR
// if p3 = 5 then
113480: LD_VAR 0 3
113484: PUSH
113485: LD_INT 5
113487: EQUAL
113488: IFFALSE 113498
// sLevel := true ;
113490: LD_ADDR_EXP 155
113494: PUSH
113495: LD_INT 1
113497: ST_TO_ADDR
// if p3 = 6 then
113498: LD_VAR 0 3
113502: PUSH
113503: LD_INT 6
113505: EQUAL
113506: IFFALSE 113516
// sArmoury := true ;
113508: LD_ADDR_EXP 156
113512: PUSH
113513: LD_INT 1
113515: ST_TO_ADDR
// if p3 = 7 then
113516: LD_VAR 0 3
113520: PUSH
113521: LD_INT 7
113523: EQUAL
113524: IFFALSE 113534
// sRadar := true ;
113526: LD_ADDR_EXP 157
113530: PUSH
113531: LD_INT 1
113533: ST_TO_ADDR
// if p3 = 8 then
113534: LD_VAR 0 3
113538: PUSH
113539: LD_INT 8
113541: EQUAL
113542: IFFALSE 113552
// sBunker := true ;
113544: LD_ADDR_EXP 158
113548: PUSH
113549: LD_INT 1
113551: ST_TO_ADDR
// if p3 = 9 then
113552: LD_VAR 0 3
113556: PUSH
113557: LD_INT 9
113559: EQUAL
113560: IFFALSE 113570
// sHack := true ;
113562: LD_ADDR_EXP 159
113566: PUSH
113567: LD_INT 1
113569: ST_TO_ADDR
// if p3 = 10 then
113570: LD_VAR 0 3
113574: PUSH
113575: LD_INT 10
113577: EQUAL
113578: IFFALSE 113588
// sFire := true ;
113580: LD_ADDR_EXP 160
113584: PUSH
113585: LD_INT 1
113587: ST_TO_ADDR
// if p3 = 11 then
113588: LD_VAR 0 3
113592: PUSH
113593: LD_INT 11
113595: EQUAL
113596: IFFALSE 113606
// sRefresh := true ;
113598: LD_ADDR_EXP 161
113602: PUSH
113603: LD_INT 1
113605: ST_TO_ADDR
// if p3 = 12 then
113606: LD_VAR 0 3
113610: PUSH
113611: LD_INT 12
113613: EQUAL
113614: IFFALSE 113624
// sExp := true ;
113616: LD_ADDR_EXP 162
113620: PUSH
113621: LD_INT 1
113623: ST_TO_ADDR
// if p3 = 13 then
113624: LD_VAR 0 3
113628: PUSH
113629: LD_INT 13
113631: EQUAL
113632: IFFALSE 113642
// sDepot := true ;
113634: LD_ADDR_EXP 163
113638: PUSH
113639: LD_INT 1
113641: ST_TO_ADDR
// if p3 = 14 then
113642: LD_VAR 0 3
113646: PUSH
113647: LD_INT 14
113649: EQUAL
113650: IFFALSE 113660
// sFlag := true ;
113652: LD_ADDR_EXP 164
113656: PUSH
113657: LD_INT 1
113659: ST_TO_ADDR
// if p3 = 15 then
113660: LD_VAR 0 3
113664: PUSH
113665: LD_INT 15
113667: EQUAL
113668: IFFALSE 113678
// sKamikadze := true ;
113670: LD_ADDR_EXP 172
113674: PUSH
113675: LD_INT 1
113677: ST_TO_ADDR
// if p3 = 16 then
113678: LD_VAR 0 3
113682: PUSH
113683: LD_INT 16
113685: EQUAL
113686: IFFALSE 113696
// sTroll := true ;
113688: LD_ADDR_EXP 173
113692: PUSH
113693: LD_INT 1
113695: ST_TO_ADDR
// if p3 = 17 then
113696: LD_VAR 0 3
113700: PUSH
113701: LD_INT 17
113703: EQUAL
113704: IFFALSE 113714
// sSlow := true ;
113706: LD_ADDR_EXP 174
113710: PUSH
113711: LD_INT 1
113713: ST_TO_ADDR
// if p3 = 18 then
113714: LD_VAR 0 3
113718: PUSH
113719: LD_INT 18
113721: EQUAL
113722: IFFALSE 113732
// sLack := true ;
113724: LD_ADDR_EXP 175
113728: PUSH
113729: LD_INT 1
113731: ST_TO_ADDR
// if p3 = 19 then
113732: LD_VAR 0 3
113736: PUSH
113737: LD_INT 19
113739: EQUAL
113740: IFFALSE 113750
// sTank := true ;
113742: LD_ADDR_EXP 177
113746: PUSH
113747: LD_INT 1
113749: ST_TO_ADDR
// if p3 = 20 then
113750: LD_VAR 0 3
113754: PUSH
113755: LD_INT 20
113757: EQUAL
113758: IFFALSE 113768
// sRemote := true ;
113760: LD_ADDR_EXP 178
113764: PUSH
113765: LD_INT 1
113767: ST_TO_ADDR
// if p3 = 21 then
113768: LD_VAR 0 3
113772: PUSH
113773: LD_INT 21
113775: EQUAL
113776: IFFALSE 113786
// sPowell := true ;
113778: LD_ADDR_EXP 179
113782: PUSH
113783: LD_INT 1
113785: ST_TO_ADDR
// if p3 = 22 then
113786: LD_VAR 0 3
113790: PUSH
113791: LD_INT 22
113793: EQUAL
113794: IFFALSE 113804
// sTeleport := true ;
113796: LD_ADDR_EXP 182
113800: PUSH
113801: LD_INT 1
113803: ST_TO_ADDR
// if p3 = 23 then
113804: LD_VAR 0 3
113808: PUSH
113809: LD_INT 23
113811: EQUAL
113812: IFFALSE 113822
// sOilTower := true ;
113814: LD_ADDR_EXP 184
113818: PUSH
113819: LD_INT 1
113821: ST_TO_ADDR
// if p3 = 24 then
113822: LD_VAR 0 3
113826: PUSH
113827: LD_INT 24
113829: EQUAL
113830: IFFALSE 113840
// sShovel := true ;
113832: LD_ADDR_EXP 185
113836: PUSH
113837: LD_INT 1
113839: ST_TO_ADDR
// if p3 = 25 then
113840: LD_VAR 0 3
113844: PUSH
113845: LD_INT 25
113847: EQUAL
113848: IFFALSE 113858
// sSheik := true ;
113850: LD_ADDR_EXP 186
113854: PUSH
113855: LD_INT 1
113857: ST_TO_ADDR
// if p3 = 26 then
113858: LD_VAR 0 3
113862: PUSH
113863: LD_INT 26
113865: EQUAL
113866: IFFALSE 113876
// sEarthquake := true ;
113868: LD_ADDR_EXP 188
113872: PUSH
113873: LD_INT 1
113875: ST_TO_ADDR
// if p3 = 27 then
113876: LD_VAR 0 3
113880: PUSH
113881: LD_INT 27
113883: EQUAL
113884: IFFALSE 113894
// sAI := true ;
113886: LD_ADDR_EXP 189
113890: PUSH
113891: LD_INT 1
113893: ST_TO_ADDR
// if p3 = 28 then
113894: LD_VAR 0 3
113898: PUSH
113899: LD_INT 28
113901: EQUAL
113902: IFFALSE 113912
// sCargo := true ;
113904: LD_ADDR_EXP 192
113908: PUSH
113909: LD_INT 1
113911: ST_TO_ADDR
// if p3 = 29 then
113912: LD_VAR 0 3
113916: PUSH
113917: LD_INT 29
113919: EQUAL
113920: IFFALSE 113930
// sDLaser := true ;
113922: LD_ADDR_EXP 193
113926: PUSH
113927: LD_INT 1
113929: ST_TO_ADDR
// if p3 = 30 then
113930: LD_VAR 0 3
113934: PUSH
113935: LD_INT 30
113937: EQUAL
113938: IFFALSE 113948
// sExchange := true ;
113940: LD_ADDR_EXP 194
113944: PUSH
113945: LD_INT 1
113947: ST_TO_ADDR
// if p3 = 31 then
113948: LD_VAR 0 3
113952: PUSH
113953: LD_INT 31
113955: EQUAL
113956: IFFALSE 113966
// sFac := true ;
113958: LD_ADDR_EXP 195
113962: PUSH
113963: LD_INT 1
113965: ST_TO_ADDR
// if p3 = 32 then
113966: LD_VAR 0 3
113970: PUSH
113971: LD_INT 32
113973: EQUAL
113974: IFFALSE 113984
// sPower := true ;
113976: LD_ADDR_EXP 196
113980: PUSH
113981: LD_INT 1
113983: ST_TO_ADDR
// if p3 = 33 then
113984: LD_VAR 0 3
113988: PUSH
113989: LD_INT 33
113991: EQUAL
113992: IFFALSE 114002
// sRandom := true ;
113994: LD_ADDR_EXP 197
113998: PUSH
113999: LD_INT 1
114001: ST_TO_ADDR
// if p3 = 34 then
114002: LD_VAR 0 3
114006: PUSH
114007: LD_INT 34
114009: EQUAL
114010: IFFALSE 114020
// sShield := true ;
114012: LD_ADDR_EXP 198
114016: PUSH
114017: LD_INT 1
114019: ST_TO_ADDR
// if p3 = 35 then
114020: LD_VAR 0 3
114024: PUSH
114025: LD_INT 35
114027: EQUAL
114028: IFFALSE 114038
// sTime := true ;
114030: LD_ADDR_EXP 199
114034: PUSH
114035: LD_INT 1
114037: ST_TO_ADDR
// if p3 = 36 then
114038: LD_VAR 0 3
114042: PUSH
114043: LD_INT 36
114045: EQUAL
114046: IFFALSE 114056
// sTools := true ;
114048: LD_ADDR_EXP 200
114052: PUSH
114053: LD_INT 1
114055: ST_TO_ADDR
// if p3 = 101 then
114056: LD_VAR 0 3
114060: PUSH
114061: LD_INT 101
114063: EQUAL
114064: IFFALSE 114074
// sSold := true ;
114066: LD_ADDR_EXP 165
114070: PUSH
114071: LD_INT 1
114073: ST_TO_ADDR
// if p3 = 102 then
114074: LD_VAR 0 3
114078: PUSH
114079: LD_INT 102
114081: EQUAL
114082: IFFALSE 114092
// sDiff := true ;
114084: LD_ADDR_EXP 166
114088: PUSH
114089: LD_INT 1
114091: ST_TO_ADDR
// if p3 = 103 then
114092: LD_VAR 0 3
114096: PUSH
114097: LD_INT 103
114099: EQUAL
114100: IFFALSE 114110
// sFog := true ;
114102: LD_ADDR_EXP 169
114106: PUSH
114107: LD_INT 1
114109: ST_TO_ADDR
// if p3 = 104 then
114110: LD_VAR 0 3
114114: PUSH
114115: LD_INT 104
114117: EQUAL
114118: IFFALSE 114128
// sReset := true ;
114120: LD_ADDR_EXP 170
114124: PUSH
114125: LD_INT 1
114127: ST_TO_ADDR
// if p3 = 105 then
114128: LD_VAR 0 3
114132: PUSH
114133: LD_INT 105
114135: EQUAL
114136: IFFALSE 114146
// sSun := true ;
114138: LD_ADDR_EXP 171
114142: PUSH
114143: LD_INT 1
114145: ST_TO_ADDR
// if p3 = 106 then
114146: LD_VAR 0 3
114150: PUSH
114151: LD_INT 106
114153: EQUAL
114154: IFFALSE 114164
// sTiger := true ;
114156: LD_ADDR_EXP 167
114160: PUSH
114161: LD_INT 1
114163: ST_TO_ADDR
// if p3 = 107 then
114164: LD_VAR 0 3
114168: PUSH
114169: LD_INT 107
114171: EQUAL
114172: IFFALSE 114182
// sBomb := true ;
114174: LD_ADDR_EXP 168
114178: PUSH
114179: LD_INT 1
114181: ST_TO_ADDR
// if p3 = 108 then
114182: LD_VAR 0 3
114186: PUSH
114187: LD_INT 108
114189: EQUAL
114190: IFFALSE 114200
// sWound := true ;
114192: LD_ADDR_EXP 176
114196: PUSH
114197: LD_INT 1
114199: ST_TO_ADDR
// if p3 = 109 then
114200: LD_VAR 0 3
114204: PUSH
114205: LD_INT 109
114207: EQUAL
114208: IFFALSE 114218
// sBetray := true ;
114210: LD_ADDR_EXP 180
114214: PUSH
114215: LD_INT 1
114217: ST_TO_ADDR
// if p3 = 110 then
114218: LD_VAR 0 3
114222: PUSH
114223: LD_INT 110
114225: EQUAL
114226: IFFALSE 114236
// sContamin := true ;
114228: LD_ADDR_EXP 181
114232: PUSH
114233: LD_INT 1
114235: ST_TO_ADDR
// if p3 = 111 then
114236: LD_VAR 0 3
114240: PUSH
114241: LD_INT 111
114243: EQUAL
114244: IFFALSE 114254
// sOil := true ;
114246: LD_ADDR_EXP 183
114250: PUSH
114251: LD_INT 1
114253: ST_TO_ADDR
// if p3 = 112 then
114254: LD_VAR 0 3
114258: PUSH
114259: LD_INT 112
114261: EQUAL
114262: IFFALSE 114272
// sStu := true ;
114264: LD_ADDR_EXP 187
114268: PUSH
114269: LD_INT 1
114271: ST_TO_ADDR
// if p3 = 113 then
114272: LD_VAR 0 3
114276: PUSH
114277: LD_INT 113
114279: EQUAL
114280: IFFALSE 114290
// sBazooka := true ;
114282: LD_ADDR_EXP 190
114286: PUSH
114287: LD_INT 1
114289: ST_TO_ADDR
// if p3 = 114 then
114290: LD_VAR 0 3
114294: PUSH
114295: LD_INT 114
114297: EQUAL
114298: IFFALSE 114308
// sMortar := true ;
114300: LD_ADDR_EXP 191
114304: PUSH
114305: LD_INT 1
114307: ST_TO_ADDR
// if p3 = 115 then
114308: LD_VAR 0 3
114312: PUSH
114313: LD_INT 115
114315: EQUAL
114316: IFFALSE 114326
// sRanger := true ;
114318: LD_ADDR_EXP 201
114322: PUSH
114323: LD_INT 1
114325: ST_TO_ADDR
// if p3 = 116 then
114326: LD_VAR 0 3
114330: PUSH
114331: LD_INT 116
114333: EQUAL
114334: IFFALSE 114344
// sComputer := true ;
114336: LD_ADDR_EXP 202
114340: PUSH
114341: LD_INT 1
114343: ST_TO_ADDR
// if p3 = 117 then
114344: LD_VAR 0 3
114348: PUSH
114349: LD_INT 117
114351: EQUAL
114352: IFFALSE 114362
// s30 := true ;
114354: LD_ADDR_EXP 203
114358: PUSH
114359: LD_INT 1
114361: ST_TO_ADDR
// if p3 = 118 then
114362: LD_VAR 0 3
114366: PUSH
114367: LD_INT 118
114369: EQUAL
114370: IFFALSE 114380
// s60 := true ;
114372: LD_ADDR_EXP 204
114376: PUSH
114377: LD_INT 1
114379: ST_TO_ADDR
// end ; if p2 = hack_mode then
114380: LD_VAR 0 2
114384: PUSH
114385: LD_INT 101
114387: EQUAL
114388: IFFALSE 114516
// begin case p3 of 1 :
114390: LD_VAR 0 3
114394: PUSH
114395: LD_INT 1
114397: DOUBLE
114398: EQUAL
114399: IFTRUE 114403
114401: GO 114410
114403: POP
// hHackUnlimitedResources ; 2 :
114404: CALL 126663 0 0
114408: GO 114516
114410: LD_INT 2
114412: DOUBLE
114413: EQUAL
114414: IFTRUE 114418
114416: GO 114425
114418: POP
// hHackSetLevel10 ; 3 :
114419: CALL 126796 0 0
114423: GO 114516
114425: LD_INT 3
114427: DOUBLE
114428: EQUAL
114429: IFTRUE 114433
114431: GO 114440
114433: POP
// hHackSetLevel10YourUnits ; 4 :
114434: CALL 126881 0 0
114438: GO 114516
114440: LD_INT 4
114442: DOUBLE
114443: EQUAL
114444: IFTRUE 114448
114446: GO 114455
114448: POP
// hHackInvincible ; 5 :
114449: CALL 127329 0 0
114453: GO 114516
114455: LD_INT 5
114457: DOUBLE
114458: EQUAL
114459: IFTRUE 114463
114461: GO 114470
114463: POP
// hHackInvisible ; 6 :
114464: CALL 127440 0 0
114468: GO 114516
114470: LD_INT 6
114472: DOUBLE
114473: EQUAL
114474: IFTRUE 114478
114476: GO 114485
114478: POP
// hHackChangeYourSide ; 7 :
114479: CALL 127497 0 0
114483: GO 114516
114485: LD_INT 7
114487: DOUBLE
114488: EQUAL
114489: IFTRUE 114493
114491: GO 114500
114493: POP
// hHackChangeUnitSide ; 8 :
114494: CALL 127539 0 0
114498: GO 114516
114500: LD_INT 8
114502: DOUBLE
114503: EQUAL
114504: IFTRUE 114508
114506: GO 114515
114508: POP
// hHackFog ; end ;
114509: CALL 127640 0 0
114513: GO 114516
114515: POP
// end ; if p2 = game_save_mode then
114516: LD_VAR 0 2
114520: PUSH
114521: LD_INT 102
114523: EQUAL
114524: IFFALSE 114579
// begin if p3 = 1 then
114526: LD_VAR 0 3
114530: PUSH
114531: LD_INT 1
114533: EQUAL
114534: IFFALSE 114546
// globalGameSaveCounter := p4 ;
114536: LD_ADDR_EXP 147
114540: PUSH
114541: LD_VAR 0 4
114545: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
114546: LD_VAR 0 3
114550: PUSH
114551: LD_INT 2
114553: EQUAL
114554: PUSH
114555: LD_EXP 147
114559: AND
114560: IFFALSE 114579
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114562: LD_STRING setGameSaveCounter(
114564: PUSH
114565: LD_EXP 147
114569: STR
114570: PUSH
114571: LD_STRING )
114573: STR
114574: PPUSH
114575: CALL_OW 559
// end ; end ;
114579: LD_VAR 0 7
114583: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
114584: LD_INT 0
114586: PPUSH
// streamModeActive := false ;
114587: LD_ADDR_EXP 148
114591: PUSH
114592: LD_INT 0
114594: ST_TO_ADDR
// normalCounter := 36 ;
114595: LD_ADDR_EXP 149
114599: PUSH
114600: LD_INT 36
114602: ST_TO_ADDR
// hardcoreCounter := 18 ;
114603: LD_ADDR_EXP 150
114607: PUSH
114608: LD_INT 18
114610: ST_TO_ADDR
// sRocket := false ;
114611: LD_ADDR_EXP 153
114615: PUSH
114616: LD_INT 0
114618: ST_TO_ADDR
// sSpeed := false ;
114619: LD_ADDR_EXP 152
114623: PUSH
114624: LD_INT 0
114626: ST_TO_ADDR
// sEngine := false ;
114627: LD_ADDR_EXP 154
114631: PUSH
114632: LD_INT 0
114634: ST_TO_ADDR
// sSpec := false ;
114635: LD_ADDR_EXP 151
114639: PUSH
114640: LD_INT 0
114642: ST_TO_ADDR
// sLevel := false ;
114643: LD_ADDR_EXP 155
114647: PUSH
114648: LD_INT 0
114650: ST_TO_ADDR
// sArmoury := false ;
114651: LD_ADDR_EXP 156
114655: PUSH
114656: LD_INT 0
114658: ST_TO_ADDR
// sRadar := false ;
114659: LD_ADDR_EXP 157
114663: PUSH
114664: LD_INT 0
114666: ST_TO_ADDR
// sBunker := false ;
114667: LD_ADDR_EXP 158
114671: PUSH
114672: LD_INT 0
114674: ST_TO_ADDR
// sHack := false ;
114675: LD_ADDR_EXP 159
114679: PUSH
114680: LD_INT 0
114682: ST_TO_ADDR
// sFire := false ;
114683: LD_ADDR_EXP 160
114687: PUSH
114688: LD_INT 0
114690: ST_TO_ADDR
// sRefresh := false ;
114691: LD_ADDR_EXP 161
114695: PUSH
114696: LD_INT 0
114698: ST_TO_ADDR
// sExp := false ;
114699: LD_ADDR_EXP 162
114703: PUSH
114704: LD_INT 0
114706: ST_TO_ADDR
// sDepot := false ;
114707: LD_ADDR_EXP 163
114711: PUSH
114712: LD_INT 0
114714: ST_TO_ADDR
// sFlag := false ;
114715: LD_ADDR_EXP 164
114719: PUSH
114720: LD_INT 0
114722: ST_TO_ADDR
// sKamikadze := false ;
114723: LD_ADDR_EXP 172
114727: PUSH
114728: LD_INT 0
114730: ST_TO_ADDR
// sTroll := false ;
114731: LD_ADDR_EXP 173
114735: PUSH
114736: LD_INT 0
114738: ST_TO_ADDR
// sSlow := false ;
114739: LD_ADDR_EXP 174
114743: PUSH
114744: LD_INT 0
114746: ST_TO_ADDR
// sLack := false ;
114747: LD_ADDR_EXP 175
114751: PUSH
114752: LD_INT 0
114754: ST_TO_ADDR
// sTank := false ;
114755: LD_ADDR_EXP 177
114759: PUSH
114760: LD_INT 0
114762: ST_TO_ADDR
// sRemote := false ;
114763: LD_ADDR_EXP 178
114767: PUSH
114768: LD_INT 0
114770: ST_TO_ADDR
// sPowell := false ;
114771: LD_ADDR_EXP 179
114775: PUSH
114776: LD_INT 0
114778: ST_TO_ADDR
// sTeleport := false ;
114779: LD_ADDR_EXP 182
114783: PUSH
114784: LD_INT 0
114786: ST_TO_ADDR
// sOilTower := false ;
114787: LD_ADDR_EXP 184
114791: PUSH
114792: LD_INT 0
114794: ST_TO_ADDR
// sShovel := false ;
114795: LD_ADDR_EXP 185
114799: PUSH
114800: LD_INT 0
114802: ST_TO_ADDR
// sSheik := false ;
114803: LD_ADDR_EXP 186
114807: PUSH
114808: LD_INT 0
114810: ST_TO_ADDR
// sEarthquake := false ;
114811: LD_ADDR_EXP 188
114815: PUSH
114816: LD_INT 0
114818: ST_TO_ADDR
// sAI := false ;
114819: LD_ADDR_EXP 189
114823: PUSH
114824: LD_INT 0
114826: ST_TO_ADDR
// sCargo := false ;
114827: LD_ADDR_EXP 192
114831: PUSH
114832: LD_INT 0
114834: ST_TO_ADDR
// sDLaser := false ;
114835: LD_ADDR_EXP 193
114839: PUSH
114840: LD_INT 0
114842: ST_TO_ADDR
// sExchange := false ;
114843: LD_ADDR_EXP 194
114847: PUSH
114848: LD_INT 0
114850: ST_TO_ADDR
// sFac := false ;
114851: LD_ADDR_EXP 195
114855: PUSH
114856: LD_INT 0
114858: ST_TO_ADDR
// sPower := false ;
114859: LD_ADDR_EXP 196
114863: PUSH
114864: LD_INT 0
114866: ST_TO_ADDR
// sRandom := false ;
114867: LD_ADDR_EXP 197
114871: PUSH
114872: LD_INT 0
114874: ST_TO_ADDR
// sShield := false ;
114875: LD_ADDR_EXP 198
114879: PUSH
114880: LD_INT 0
114882: ST_TO_ADDR
// sTime := false ;
114883: LD_ADDR_EXP 199
114887: PUSH
114888: LD_INT 0
114890: ST_TO_ADDR
// sTools := false ;
114891: LD_ADDR_EXP 200
114895: PUSH
114896: LD_INT 0
114898: ST_TO_ADDR
// sSold := false ;
114899: LD_ADDR_EXP 165
114903: PUSH
114904: LD_INT 0
114906: ST_TO_ADDR
// sDiff := false ;
114907: LD_ADDR_EXP 166
114911: PUSH
114912: LD_INT 0
114914: ST_TO_ADDR
// sFog := false ;
114915: LD_ADDR_EXP 169
114919: PUSH
114920: LD_INT 0
114922: ST_TO_ADDR
// sReset := false ;
114923: LD_ADDR_EXP 170
114927: PUSH
114928: LD_INT 0
114930: ST_TO_ADDR
// sSun := false ;
114931: LD_ADDR_EXP 171
114935: PUSH
114936: LD_INT 0
114938: ST_TO_ADDR
// sTiger := false ;
114939: LD_ADDR_EXP 167
114943: PUSH
114944: LD_INT 0
114946: ST_TO_ADDR
// sBomb := false ;
114947: LD_ADDR_EXP 168
114951: PUSH
114952: LD_INT 0
114954: ST_TO_ADDR
// sWound := false ;
114955: LD_ADDR_EXP 176
114959: PUSH
114960: LD_INT 0
114962: ST_TO_ADDR
// sBetray := false ;
114963: LD_ADDR_EXP 180
114967: PUSH
114968: LD_INT 0
114970: ST_TO_ADDR
// sContamin := false ;
114971: LD_ADDR_EXP 181
114975: PUSH
114976: LD_INT 0
114978: ST_TO_ADDR
// sOil := false ;
114979: LD_ADDR_EXP 183
114983: PUSH
114984: LD_INT 0
114986: ST_TO_ADDR
// sStu := false ;
114987: LD_ADDR_EXP 187
114991: PUSH
114992: LD_INT 0
114994: ST_TO_ADDR
// sBazooka := false ;
114995: LD_ADDR_EXP 190
114999: PUSH
115000: LD_INT 0
115002: ST_TO_ADDR
// sMortar := false ;
115003: LD_ADDR_EXP 191
115007: PUSH
115008: LD_INT 0
115010: ST_TO_ADDR
// sRanger := false ;
115011: LD_ADDR_EXP 201
115015: PUSH
115016: LD_INT 0
115018: ST_TO_ADDR
// sComputer := false ;
115019: LD_ADDR_EXP 202
115023: PUSH
115024: LD_INT 0
115026: ST_TO_ADDR
// s30 := false ;
115027: LD_ADDR_EXP 203
115031: PUSH
115032: LD_INT 0
115034: ST_TO_ADDR
// s60 := false ;
115035: LD_ADDR_EXP 204
115039: PUSH
115040: LD_INT 0
115042: ST_TO_ADDR
// end ;
115043: LD_VAR 0 1
115047: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
115048: LD_INT 0
115050: PPUSH
115051: PPUSH
115052: PPUSH
115053: PPUSH
115054: PPUSH
115055: PPUSH
115056: PPUSH
// result := [ ] ;
115057: LD_ADDR_VAR 0 2
115061: PUSH
115062: EMPTY
115063: ST_TO_ADDR
// if campaign_id = 1 then
115064: LD_OWVAR 69
115068: PUSH
115069: LD_INT 1
115071: EQUAL
115072: IFFALSE 118238
// begin case mission_number of 1 :
115074: LD_OWVAR 70
115078: PUSH
115079: LD_INT 1
115081: DOUBLE
115082: EQUAL
115083: IFTRUE 115087
115085: GO 115163
115087: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
115088: LD_ADDR_VAR 0 2
115092: PUSH
115093: LD_INT 2
115095: PUSH
115096: LD_INT 4
115098: PUSH
115099: LD_INT 11
115101: PUSH
115102: LD_INT 12
115104: PUSH
115105: LD_INT 15
115107: PUSH
115108: LD_INT 16
115110: PUSH
115111: LD_INT 22
115113: PUSH
115114: LD_INT 23
115116: PUSH
115117: LD_INT 26
115119: PUSH
115120: EMPTY
115121: LIST
115122: LIST
115123: LIST
115124: LIST
115125: LIST
115126: LIST
115127: LIST
115128: LIST
115129: LIST
115130: PUSH
115131: LD_INT 101
115133: PUSH
115134: LD_INT 102
115136: PUSH
115137: LD_INT 106
115139: PUSH
115140: LD_INT 116
115142: PUSH
115143: LD_INT 117
115145: PUSH
115146: LD_INT 118
115148: PUSH
115149: EMPTY
115150: LIST
115151: LIST
115152: LIST
115153: LIST
115154: LIST
115155: LIST
115156: PUSH
115157: EMPTY
115158: LIST
115159: LIST
115160: ST_TO_ADDR
115161: GO 118236
115163: LD_INT 2
115165: DOUBLE
115166: EQUAL
115167: IFTRUE 115171
115169: GO 115255
115171: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
115172: LD_ADDR_VAR 0 2
115176: PUSH
115177: LD_INT 2
115179: PUSH
115180: LD_INT 4
115182: PUSH
115183: LD_INT 11
115185: PUSH
115186: LD_INT 12
115188: PUSH
115189: LD_INT 15
115191: PUSH
115192: LD_INT 16
115194: PUSH
115195: LD_INT 22
115197: PUSH
115198: LD_INT 23
115200: PUSH
115201: LD_INT 26
115203: PUSH
115204: EMPTY
115205: LIST
115206: LIST
115207: LIST
115208: LIST
115209: LIST
115210: LIST
115211: LIST
115212: LIST
115213: LIST
115214: PUSH
115215: LD_INT 101
115217: PUSH
115218: LD_INT 102
115220: PUSH
115221: LD_INT 105
115223: PUSH
115224: LD_INT 106
115226: PUSH
115227: LD_INT 108
115229: PUSH
115230: LD_INT 116
115232: PUSH
115233: LD_INT 117
115235: PUSH
115236: LD_INT 118
115238: PUSH
115239: EMPTY
115240: LIST
115241: LIST
115242: LIST
115243: LIST
115244: LIST
115245: LIST
115246: LIST
115247: LIST
115248: PUSH
115249: EMPTY
115250: LIST
115251: LIST
115252: ST_TO_ADDR
115253: GO 118236
115255: LD_INT 3
115257: DOUBLE
115258: EQUAL
115259: IFTRUE 115263
115261: GO 115351
115263: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
115264: LD_ADDR_VAR 0 2
115268: PUSH
115269: LD_INT 2
115271: PUSH
115272: LD_INT 4
115274: PUSH
115275: LD_INT 5
115277: PUSH
115278: LD_INT 11
115280: PUSH
115281: LD_INT 12
115283: PUSH
115284: LD_INT 15
115286: PUSH
115287: LD_INT 16
115289: PUSH
115290: LD_INT 22
115292: PUSH
115293: LD_INT 26
115295: PUSH
115296: LD_INT 36
115298: PUSH
115299: EMPTY
115300: LIST
115301: LIST
115302: LIST
115303: LIST
115304: LIST
115305: LIST
115306: LIST
115307: LIST
115308: LIST
115309: LIST
115310: PUSH
115311: LD_INT 101
115313: PUSH
115314: LD_INT 102
115316: PUSH
115317: LD_INT 105
115319: PUSH
115320: LD_INT 106
115322: PUSH
115323: LD_INT 108
115325: PUSH
115326: LD_INT 116
115328: PUSH
115329: LD_INT 117
115331: PUSH
115332: LD_INT 118
115334: PUSH
115335: EMPTY
115336: LIST
115337: LIST
115338: LIST
115339: LIST
115340: LIST
115341: LIST
115342: LIST
115343: LIST
115344: PUSH
115345: EMPTY
115346: LIST
115347: LIST
115348: ST_TO_ADDR
115349: GO 118236
115351: LD_INT 4
115353: DOUBLE
115354: EQUAL
115355: IFTRUE 115359
115357: GO 115455
115359: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
115360: LD_ADDR_VAR 0 2
115364: PUSH
115365: LD_INT 2
115367: PUSH
115368: LD_INT 4
115370: PUSH
115371: LD_INT 5
115373: PUSH
115374: LD_INT 8
115376: PUSH
115377: LD_INT 11
115379: PUSH
115380: LD_INT 12
115382: PUSH
115383: LD_INT 15
115385: PUSH
115386: LD_INT 16
115388: PUSH
115389: LD_INT 22
115391: PUSH
115392: LD_INT 23
115394: PUSH
115395: LD_INT 26
115397: PUSH
115398: LD_INT 36
115400: PUSH
115401: EMPTY
115402: LIST
115403: LIST
115404: LIST
115405: LIST
115406: LIST
115407: LIST
115408: LIST
115409: LIST
115410: LIST
115411: LIST
115412: LIST
115413: LIST
115414: PUSH
115415: LD_INT 101
115417: PUSH
115418: LD_INT 102
115420: PUSH
115421: LD_INT 105
115423: PUSH
115424: LD_INT 106
115426: PUSH
115427: LD_INT 108
115429: PUSH
115430: LD_INT 116
115432: PUSH
115433: LD_INT 117
115435: PUSH
115436: LD_INT 118
115438: PUSH
115439: EMPTY
115440: LIST
115441: LIST
115442: LIST
115443: LIST
115444: LIST
115445: LIST
115446: LIST
115447: LIST
115448: PUSH
115449: EMPTY
115450: LIST
115451: LIST
115452: ST_TO_ADDR
115453: GO 118236
115455: LD_INT 5
115457: DOUBLE
115458: EQUAL
115459: IFTRUE 115463
115461: GO 115575
115463: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
115464: LD_ADDR_VAR 0 2
115468: PUSH
115469: LD_INT 2
115471: PUSH
115472: LD_INT 4
115474: PUSH
115475: LD_INT 5
115477: PUSH
115478: LD_INT 6
115480: PUSH
115481: LD_INT 8
115483: PUSH
115484: LD_INT 11
115486: PUSH
115487: LD_INT 12
115489: PUSH
115490: LD_INT 15
115492: PUSH
115493: LD_INT 16
115495: PUSH
115496: LD_INT 22
115498: PUSH
115499: LD_INT 23
115501: PUSH
115502: LD_INT 25
115504: PUSH
115505: LD_INT 26
115507: PUSH
115508: LD_INT 36
115510: PUSH
115511: EMPTY
115512: LIST
115513: LIST
115514: LIST
115515: LIST
115516: LIST
115517: LIST
115518: LIST
115519: LIST
115520: LIST
115521: LIST
115522: LIST
115523: LIST
115524: LIST
115525: LIST
115526: PUSH
115527: LD_INT 101
115529: PUSH
115530: LD_INT 102
115532: PUSH
115533: LD_INT 105
115535: PUSH
115536: LD_INT 106
115538: PUSH
115539: LD_INT 108
115541: PUSH
115542: LD_INT 109
115544: PUSH
115545: LD_INT 112
115547: PUSH
115548: LD_INT 116
115550: PUSH
115551: LD_INT 117
115553: PUSH
115554: LD_INT 118
115556: PUSH
115557: EMPTY
115558: LIST
115559: LIST
115560: LIST
115561: LIST
115562: LIST
115563: LIST
115564: LIST
115565: LIST
115566: LIST
115567: LIST
115568: PUSH
115569: EMPTY
115570: LIST
115571: LIST
115572: ST_TO_ADDR
115573: GO 118236
115575: LD_INT 6
115577: DOUBLE
115578: EQUAL
115579: IFTRUE 115583
115581: GO 115715
115583: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
115584: LD_ADDR_VAR 0 2
115588: PUSH
115589: LD_INT 2
115591: PUSH
115592: LD_INT 4
115594: PUSH
115595: LD_INT 5
115597: PUSH
115598: LD_INT 6
115600: PUSH
115601: LD_INT 8
115603: PUSH
115604: LD_INT 11
115606: PUSH
115607: LD_INT 12
115609: PUSH
115610: LD_INT 15
115612: PUSH
115613: LD_INT 16
115615: PUSH
115616: LD_INT 20
115618: PUSH
115619: LD_INT 21
115621: PUSH
115622: LD_INT 22
115624: PUSH
115625: LD_INT 23
115627: PUSH
115628: LD_INT 25
115630: PUSH
115631: LD_INT 26
115633: PUSH
115634: LD_INT 30
115636: PUSH
115637: LD_INT 31
115639: PUSH
115640: LD_INT 32
115642: PUSH
115643: LD_INT 36
115645: PUSH
115646: EMPTY
115647: LIST
115648: LIST
115649: LIST
115650: LIST
115651: LIST
115652: LIST
115653: LIST
115654: LIST
115655: LIST
115656: LIST
115657: LIST
115658: LIST
115659: LIST
115660: LIST
115661: LIST
115662: LIST
115663: LIST
115664: LIST
115665: LIST
115666: PUSH
115667: LD_INT 101
115669: PUSH
115670: LD_INT 102
115672: PUSH
115673: LD_INT 105
115675: PUSH
115676: LD_INT 106
115678: PUSH
115679: LD_INT 108
115681: PUSH
115682: LD_INT 109
115684: PUSH
115685: LD_INT 112
115687: PUSH
115688: LD_INT 116
115690: PUSH
115691: LD_INT 117
115693: PUSH
115694: LD_INT 118
115696: PUSH
115697: EMPTY
115698: LIST
115699: LIST
115700: LIST
115701: LIST
115702: LIST
115703: LIST
115704: LIST
115705: LIST
115706: LIST
115707: LIST
115708: PUSH
115709: EMPTY
115710: LIST
115711: LIST
115712: ST_TO_ADDR
115713: GO 118236
115715: LD_INT 7
115717: DOUBLE
115718: EQUAL
115719: IFTRUE 115723
115721: GO 115835
115723: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
115724: LD_ADDR_VAR 0 2
115728: PUSH
115729: LD_INT 2
115731: PUSH
115732: LD_INT 4
115734: PUSH
115735: LD_INT 5
115737: PUSH
115738: LD_INT 7
115740: PUSH
115741: LD_INT 11
115743: PUSH
115744: LD_INT 12
115746: PUSH
115747: LD_INT 15
115749: PUSH
115750: LD_INT 16
115752: PUSH
115753: LD_INT 20
115755: PUSH
115756: LD_INT 21
115758: PUSH
115759: LD_INT 22
115761: PUSH
115762: LD_INT 23
115764: PUSH
115765: LD_INT 25
115767: PUSH
115768: LD_INT 26
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: LIST
115784: LIST
115785: LIST
115786: PUSH
115787: LD_INT 101
115789: PUSH
115790: LD_INT 102
115792: PUSH
115793: LD_INT 103
115795: PUSH
115796: LD_INT 105
115798: PUSH
115799: LD_INT 106
115801: PUSH
115802: LD_INT 108
115804: PUSH
115805: LD_INT 112
115807: PUSH
115808: LD_INT 116
115810: PUSH
115811: LD_INT 117
115813: PUSH
115814: LD_INT 118
115816: PUSH
115817: EMPTY
115818: LIST
115819: LIST
115820: LIST
115821: LIST
115822: LIST
115823: LIST
115824: LIST
115825: LIST
115826: LIST
115827: LIST
115828: PUSH
115829: EMPTY
115830: LIST
115831: LIST
115832: ST_TO_ADDR
115833: GO 118236
115835: LD_INT 8
115837: DOUBLE
115838: EQUAL
115839: IFTRUE 115843
115841: GO 115983
115843: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
115844: LD_ADDR_VAR 0 2
115848: PUSH
115849: LD_INT 2
115851: PUSH
115852: LD_INT 4
115854: PUSH
115855: LD_INT 5
115857: PUSH
115858: LD_INT 6
115860: PUSH
115861: LD_INT 7
115863: PUSH
115864: LD_INT 8
115866: PUSH
115867: LD_INT 11
115869: PUSH
115870: LD_INT 12
115872: PUSH
115873: LD_INT 15
115875: PUSH
115876: LD_INT 16
115878: PUSH
115879: LD_INT 20
115881: PUSH
115882: LD_INT 21
115884: PUSH
115885: LD_INT 22
115887: PUSH
115888: LD_INT 23
115890: PUSH
115891: LD_INT 25
115893: PUSH
115894: LD_INT 26
115896: PUSH
115897: LD_INT 30
115899: PUSH
115900: LD_INT 31
115902: PUSH
115903: LD_INT 32
115905: PUSH
115906: LD_INT 36
115908: PUSH
115909: EMPTY
115910: LIST
115911: LIST
115912: LIST
115913: LIST
115914: LIST
115915: LIST
115916: LIST
115917: LIST
115918: LIST
115919: LIST
115920: LIST
115921: LIST
115922: LIST
115923: LIST
115924: LIST
115925: LIST
115926: LIST
115927: LIST
115928: LIST
115929: LIST
115930: PUSH
115931: LD_INT 101
115933: PUSH
115934: LD_INT 102
115936: PUSH
115937: LD_INT 103
115939: PUSH
115940: LD_INT 105
115942: PUSH
115943: LD_INT 106
115945: PUSH
115946: LD_INT 108
115948: PUSH
115949: LD_INT 109
115951: PUSH
115952: LD_INT 112
115954: PUSH
115955: LD_INT 116
115957: PUSH
115958: LD_INT 117
115960: PUSH
115961: LD_INT 118
115963: PUSH
115964: EMPTY
115965: LIST
115966: LIST
115967: LIST
115968: LIST
115969: LIST
115970: LIST
115971: LIST
115972: LIST
115973: LIST
115974: LIST
115975: LIST
115976: PUSH
115977: EMPTY
115978: LIST
115979: LIST
115980: ST_TO_ADDR
115981: GO 118236
115983: LD_INT 9
115985: DOUBLE
115986: EQUAL
115987: IFTRUE 115991
115989: GO 116139
115991: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115992: LD_ADDR_VAR 0 2
115996: PUSH
115997: LD_INT 2
115999: PUSH
116000: LD_INT 4
116002: PUSH
116003: LD_INT 5
116005: PUSH
116006: LD_INT 6
116008: PUSH
116009: LD_INT 7
116011: PUSH
116012: LD_INT 8
116014: PUSH
116015: LD_INT 11
116017: PUSH
116018: LD_INT 12
116020: PUSH
116021: LD_INT 15
116023: PUSH
116024: LD_INT 16
116026: PUSH
116027: LD_INT 20
116029: PUSH
116030: LD_INT 21
116032: PUSH
116033: LD_INT 22
116035: PUSH
116036: LD_INT 23
116038: PUSH
116039: LD_INT 25
116041: PUSH
116042: LD_INT 26
116044: PUSH
116045: LD_INT 28
116047: PUSH
116048: LD_INT 30
116050: PUSH
116051: LD_INT 31
116053: PUSH
116054: LD_INT 32
116056: PUSH
116057: LD_INT 36
116059: PUSH
116060: EMPTY
116061: LIST
116062: LIST
116063: LIST
116064: LIST
116065: LIST
116066: LIST
116067: LIST
116068: LIST
116069: LIST
116070: LIST
116071: LIST
116072: LIST
116073: LIST
116074: LIST
116075: LIST
116076: LIST
116077: LIST
116078: LIST
116079: LIST
116080: LIST
116081: LIST
116082: PUSH
116083: LD_INT 101
116085: PUSH
116086: LD_INT 102
116088: PUSH
116089: LD_INT 103
116091: PUSH
116092: LD_INT 105
116094: PUSH
116095: LD_INT 106
116097: PUSH
116098: LD_INT 108
116100: PUSH
116101: LD_INT 109
116103: PUSH
116104: LD_INT 112
116106: PUSH
116107: LD_INT 114
116109: PUSH
116110: LD_INT 116
116112: PUSH
116113: LD_INT 117
116115: PUSH
116116: LD_INT 118
116118: PUSH
116119: EMPTY
116120: LIST
116121: LIST
116122: LIST
116123: LIST
116124: LIST
116125: LIST
116126: LIST
116127: LIST
116128: LIST
116129: LIST
116130: LIST
116131: LIST
116132: PUSH
116133: EMPTY
116134: LIST
116135: LIST
116136: ST_TO_ADDR
116137: GO 118236
116139: LD_INT 10
116141: DOUBLE
116142: EQUAL
116143: IFTRUE 116147
116145: GO 116343
116147: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
116148: LD_ADDR_VAR 0 2
116152: PUSH
116153: LD_INT 2
116155: PUSH
116156: LD_INT 4
116158: PUSH
116159: LD_INT 5
116161: PUSH
116162: LD_INT 6
116164: PUSH
116165: LD_INT 7
116167: PUSH
116168: LD_INT 8
116170: PUSH
116171: LD_INT 9
116173: PUSH
116174: LD_INT 10
116176: PUSH
116177: LD_INT 11
116179: PUSH
116180: LD_INT 12
116182: PUSH
116183: LD_INT 13
116185: PUSH
116186: LD_INT 14
116188: PUSH
116189: LD_INT 15
116191: PUSH
116192: LD_INT 16
116194: PUSH
116195: LD_INT 17
116197: PUSH
116198: LD_INT 18
116200: PUSH
116201: LD_INT 19
116203: PUSH
116204: LD_INT 20
116206: PUSH
116207: LD_INT 21
116209: PUSH
116210: LD_INT 22
116212: PUSH
116213: LD_INT 23
116215: PUSH
116216: LD_INT 24
116218: PUSH
116219: LD_INT 25
116221: PUSH
116222: LD_INT 26
116224: PUSH
116225: LD_INT 28
116227: PUSH
116228: LD_INT 30
116230: PUSH
116231: LD_INT 31
116233: PUSH
116234: LD_INT 32
116236: PUSH
116237: LD_INT 36
116239: PUSH
116240: EMPTY
116241: LIST
116242: LIST
116243: LIST
116244: LIST
116245: LIST
116246: LIST
116247: LIST
116248: LIST
116249: LIST
116250: LIST
116251: LIST
116252: LIST
116253: LIST
116254: LIST
116255: LIST
116256: LIST
116257: LIST
116258: LIST
116259: LIST
116260: LIST
116261: LIST
116262: LIST
116263: LIST
116264: LIST
116265: LIST
116266: LIST
116267: LIST
116268: LIST
116269: LIST
116270: PUSH
116271: LD_INT 101
116273: PUSH
116274: LD_INT 102
116276: PUSH
116277: LD_INT 103
116279: PUSH
116280: LD_INT 104
116282: PUSH
116283: LD_INT 105
116285: PUSH
116286: LD_INT 106
116288: PUSH
116289: LD_INT 107
116291: PUSH
116292: LD_INT 108
116294: PUSH
116295: LD_INT 109
116297: PUSH
116298: LD_INT 110
116300: PUSH
116301: LD_INT 111
116303: PUSH
116304: LD_INT 112
116306: PUSH
116307: LD_INT 114
116309: PUSH
116310: LD_INT 116
116312: PUSH
116313: LD_INT 117
116315: PUSH
116316: LD_INT 118
116318: PUSH
116319: EMPTY
116320: LIST
116321: LIST
116322: LIST
116323: LIST
116324: LIST
116325: LIST
116326: LIST
116327: LIST
116328: LIST
116329: LIST
116330: LIST
116331: LIST
116332: LIST
116333: LIST
116334: LIST
116335: LIST
116336: PUSH
116337: EMPTY
116338: LIST
116339: LIST
116340: ST_TO_ADDR
116341: GO 118236
116343: LD_INT 11
116345: DOUBLE
116346: EQUAL
116347: IFTRUE 116351
116349: GO 116555
116351: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
116352: LD_ADDR_VAR 0 2
116356: PUSH
116357: LD_INT 2
116359: PUSH
116360: LD_INT 3
116362: PUSH
116363: LD_INT 4
116365: PUSH
116366: LD_INT 5
116368: PUSH
116369: LD_INT 6
116371: PUSH
116372: LD_INT 7
116374: PUSH
116375: LD_INT 8
116377: PUSH
116378: LD_INT 9
116380: PUSH
116381: LD_INT 10
116383: PUSH
116384: LD_INT 11
116386: PUSH
116387: LD_INT 12
116389: PUSH
116390: LD_INT 13
116392: PUSH
116393: LD_INT 14
116395: PUSH
116396: LD_INT 15
116398: PUSH
116399: LD_INT 16
116401: PUSH
116402: LD_INT 17
116404: PUSH
116405: LD_INT 18
116407: PUSH
116408: LD_INT 19
116410: PUSH
116411: LD_INT 20
116413: PUSH
116414: LD_INT 21
116416: PUSH
116417: LD_INT 22
116419: PUSH
116420: LD_INT 23
116422: PUSH
116423: LD_INT 24
116425: PUSH
116426: LD_INT 25
116428: PUSH
116429: LD_INT 26
116431: PUSH
116432: LD_INT 28
116434: PUSH
116435: LD_INT 30
116437: PUSH
116438: LD_INT 31
116440: PUSH
116441: LD_INT 32
116443: PUSH
116444: LD_INT 34
116446: PUSH
116447: LD_INT 36
116449: PUSH
116450: EMPTY
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: LIST
116458: LIST
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: LIST
116464: LIST
116465: LIST
116466: LIST
116467: LIST
116468: LIST
116469: LIST
116470: LIST
116471: LIST
116472: LIST
116473: LIST
116474: LIST
116475: LIST
116476: LIST
116477: LIST
116478: LIST
116479: LIST
116480: LIST
116481: LIST
116482: PUSH
116483: LD_INT 101
116485: PUSH
116486: LD_INT 102
116488: PUSH
116489: LD_INT 103
116491: PUSH
116492: LD_INT 104
116494: PUSH
116495: LD_INT 105
116497: PUSH
116498: LD_INT 106
116500: PUSH
116501: LD_INT 107
116503: PUSH
116504: LD_INT 108
116506: PUSH
116507: LD_INT 109
116509: PUSH
116510: LD_INT 110
116512: PUSH
116513: LD_INT 111
116515: PUSH
116516: LD_INT 112
116518: PUSH
116519: LD_INT 114
116521: PUSH
116522: LD_INT 116
116524: PUSH
116525: LD_INT 117
116527: PUSH
116528: LD_INT 118
116530: PUSH
116531: EMPTY
116532: LIST
116533: LIST
116534: LIST
116535: LIST
116536: LIST
116537: LIST
116538: LIST
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: LIST
116545: LIST
116546: LIST
116547: LIST
116548: PUSH
116549: EMPTY
116550: LIST
116551: LIST
116552: ST_TO_ADDR
116553: GO 118236
116555: LD_INT 12
116557: DOUBLE
116558: EQUAL
116559: IFTRUE 116563
116561: GO 116783
116563: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
116564: LD_ADDR_VAR 0 2
116568: PUSH
116569: LD_INT 1
116571: PUSH
116572: LD_INT 2
116574: PUSH
116575: LD_INT 3
116577: PUSH
116578: LD_INT 4
116580: PUSH
116581: LD_INT 5
116583: PUSH
116584: LD_INT 6
116586: PUSH
116587: LD_INT 7
116589: PUSH
116590: LD_INT 8
116592: PUSH
116593: LD_INT 9
116595: PUSH
116596: LD_INT 10
116598: PUSH
116599: LD_INT 11
116601: PUSH
116602: LD_INT 12
116604: PUSH
116605: LD_INT 13
116607: PUSH
116608: LD_INT 14
116610: PUSH
116611: LD_INT 15
116613: PUSH
116614: LD_INT 16
116616: PUSH
116617: LD_INT 17
116619: PUSH
116620: LD_INT 18
116622: PUSH
116623: LD_INT 19
116625: PUSH
116626: LD_INT 20
116628: PUSH
116629: LD_INT 21
116631: PUSH
116632: LD_INT 22
116634: PUSH
116635: LD_INT 23
116637: PUSH
116638: LD_INT 24
116640: PUSH
116641: LD_INT 25
116643: PUSH
116644: LD_INT 26
116646: PUSH
116647: LD_INT 27
116649: PUSH
116650: LD_INT 28
116652: PUSH
116653: LD_INT 30
116655: PUSH
116656: LD_INT 31
116658: PUSH
116659: LD_INT 32
116661: PUSH
116662: LD_INT 33
116664: PUSH
116665: LD_INT 34
116667: PUSH
116668: LD_INT 36
116670: PUSH
116671: EMPTY
116672: LIST
116673: LIST
116674: LIST
116675: LIST
116676: LIST
116677: LIST
116678: LIST
116679: LIST
116680: LIST
116681: LIST
116682: LIST
116683: LIST
116684: LIST
116685: LIST
116686: LIST
116687: LIST
116688: LIST
116689: LIST
116690: LIST
116691: LIST
116692: LIST
116693: LIST
116694: LIST
116695: LIST
116696: LIST
116697: LIST
116698: LIST
116699: LIST
116700: LIST
116701: LIST
116702: LIST
116703: LIST
116704: LIST
116705: LIST
116706: PUSH
116707: LD_INT 101
116709: PUSH
116710: LD_INT 102
116712: PUSH
116713: LD_INT 103
116715: PUSH
116716: LD_INT 104
116718: PUSH
116719: LD_INT 105
116721: PUSH
116722: LD_INT 106
116724: PUSH
116725: LD_INT 107
116727: PUSH
116728: LD_INT 108
116730: PUSH
116731: LD_INT 109
116733: PUSH
116734: LD_INT 110
116736: PUSH
116737: LD_INT 111
116739: PUSH
116740: LD_INT 112
116742: PUSH
116743: LD_INT 113
116745: PUSH
116746: LD_INT 114
116748: PUSH
116749: LD_INT 116
116751: PUSH
116752: LD_INT 117
116754: PUSH
116755: LD_INT 118
116757: PUSH
116758: EMPTY
116759: LIST
116760: LIST
116761: LIST
116762: LIST
116763: LIST
116764: LIST
116765: LIST
116766: LIST
116767: LIST
116768: LIST
116769: LIST
116770: LIST
116771: LIST
116772: LIST
116773: LIST
116774: LIST
116775: LIST
116776: PUSH
116777: EMPTY
116778: LIST
116779: LIST
116780: ST_TO_ADDR
116781: GO 118236
116783: LD_INT 13
116785: DOUBLE
116786: EQUAL
116787: IFTRUE 116791
116789: GO 116999
116791: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
116792: LD_ADDR_VAR 0 2
116796: PUSH
116797: LD_INT 1
116799: PUSH
116800: LD_INT 2
116802: PUSH
116803: LD_INT 3
116805: PUSH
116806: LD_INT 4
116808: PUSH
116809: LD_INT 5
116811: PUSH
116812: LD_INT 8
116814: PUSH
116815: LD_INT 9
116817: PUSH
116818: LD_INT 10
116820: PUSH
116821: LD_INT 11
116823: PUSH
116824: LD_INT 12
116826: PUSH
116827: LD_INT 14
116829: PUSH
116830: LD_INT 15
116832: PUSH
116833: LD_INT 16
116835: PUSH
116836: LD_INT 17
116838: PUSH
116839: LD_INT 18
116841: PUSH
116842: LD_INT 19
116844: PUSH
116845: LD_INT 20
116847: PUSH
116848: LD_INT 21
116850: PUSH
116851: LD_INT 22
116853: PUSH
116854: LD_INT 23
116856: PUSH
116857: LD_INT 24
116859: PUSH
116860: LD_INT 25
116862: PUSH
116863: LD_INT 26
116865: PUSH
116866: LD_INT 27
116868: PUSH
116869: LD_INT 28
116871: PUSH
116872: LD_INT 30
116874: PUSH
116875: LD_INT 31
116877: PUSH
116878: LD_INT 32
116880: PUSH
116881: LD_INT 33
116883: PUSH
116884: LD_INT 34
116886: PUSH
116887: LD_INT 36
116889: PUSH
116890: EMPTY
116891: LIST
116892: LIST
116893: LIST
116894: LIST
116895: LIST
116896: LIST
116897: LIST
116898: LIST
116899: LIST
116900: LIST
116901: LIST
116902: LIST
116903: LIST
116904: LIST
116905: LIST
116906: LIST
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: LIST
116912: LIST
116913: LIST
116914: LIST
116915: LIST
116916: LIST
116917: LIST
116918: LIST
116919: LIST
116920: LIST
116921: LIST
116922: PUSH
116923: LD_INT 101
116925: PUSH
116926: LD_INT 102
116928: PUSH
116929: LD_INT 103
116931: PUSH
116932: LD_INT 104
116934: PUSH
116935: LD_INT 105
116937: PUSH
116938: LD_INT 106
116940: PUSH
116941: LD_INT 107
116943: PUSH
116944: LD_INT 108
116946: PUSH
116947: LD_INT 109
116949: PUSH
116950: LD_INT 110
116952: PUSH
116953: LD_INT 111
116955: PUSH
116956: LD_INT 112
116958: PUSH
116959: LD_INT 113
116961: PUSH
116962: LD_INT 114
116964: PUSH
116965: LD_INT 116
116967: PUSH
116968: LD_INT 117
116970: PUSH
116971: LD_INT 118
116973: PUSH
116974: EMPTY
116975: LIST
116976: LIST
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: LIST
116991: LIST
116992: PUSH
116993: EMPTY
116994: LIST
116995: LIST
116996: ST_TO_ADDR
116997: GO 118236
116999: LD_INT 14
117001: DOUBLE
117002: EQUAL
117003: IFTRUE 117007
117005: GO 117231
117007: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
117008: LD_ADDR_VAR 0 2
117012: PUSH
117013: LD_INT 1
117015: PUSH
117016: LD_INT 2
117018: PUSH
117019: LD_INT 3
117021: PUSH
117022: LD_INT 4
117024: PUSH
117025: LD_INT 5
117027: PUSH
117028: LD_INT 6
117030: PUSH
117031: LD_INT 7
117033: PUSH
117034: LD_INT 8
117036: PUSH
117037: LD_INT 9
117039: PUSH
117040: LD_INT 10
117042: PUSH
117043: LD_INT 11
117045: PUSH
117046: LD_INT 12
117048: PUSH
117049: LD_INT 13
117051: PUSH
117052: LD_INT 14
117054: PUSH
117055: LD_INT 15
117057: PUSH
117058: LD_INT 16
117060: PUSH
117061: LD_INT 17
117063: PUSH
117064: LD_INT 18
117066: PUSH
117067: LD_INT 19
117069: PUSH
117070: LD_INT 20
117072: PUSH
117073: LD_INT 21
117075: PUSH
117076: LD_INT 22
117078: PUSH
117079: LD_INT 23
117081: PUSH
117082: LD_INT 24
117084: PUSH
117085: LD_INT 25
117087: PUSH
117088: LD_INT 26
117090: PUSH
117091: LD_INT 27
117093: PUSH
117094: LD_INT 28
117096: PUSH
117097: LD_INT 29
117099: PUSH
117100: LD_INT 30
117102: PUSH
117103: LD_INT 31
117105: PUSH
117106: LD_INT 32
117108: PUSH
117109: LD_INT 33
117111: PUSH
117112: LD_INT 34
117114: PUSH
117115: LD_INT 36
117117: PUSH
117118: EMPTY
117119: LIST
117120: LIST
117121: LIST
117122: LIST
117123: LIST
117124: LIST
117125: LIST
117126: LIST
117127: LIST
117128: LIST
117129: LIST
117130: LIST
117131: LIST
117132: LIST
117133: LIST
117134: LIST
117135: LIST
117136: LIST
117137: LIST
117138: LIST
117139: LIST
117140: LIST
117141: LIST
117142: LIST
117143: LIST
117144: LIST
117145: LIST
117146: LIST
117147: LIST
117148: LIST
117149: LIST
117150: LIST
117151: LIST
117152: LIST
117153: LIST
117154: PUSH
117155: LD_INT 101
117157: PUSH
117158: LD_INT 102
117160: PUSH
117161: LD_INT 103
117163: PUSH
117164: LD_INT 104
117166: PUSH
117167: LD_INT 105
117169: PUSH
117170: LD_INT 106
117172: PUSH
117173: LD_INT 107
117175: PUSH
117176: LD_INT 108
117178: PUSH
117179: LD_INT 109
117181: PUSH
117182: LD_INT 110
117184: PUSH
117185: LD_INT 111
117187: PUSH
117188: LD_INT 112
117190: PUSH
117191: LD_INT 113
117193: PUSH
117194: LD_INT 114
117196: PUSH
117197: LD_INT 116
117199: PUSH
117200: LD_INT 117
117202: PUSH
117203: LD_INT 118
117205: PUSH
117206: EMPTY
117207: LIST
117208: LIST
117209: LIST
117210: LIST
117211: LIST
117212: LIST
117213: LIST
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: PUSH
117225: EMPTY
117226: LIST
117227: LIST
117228: ST_TO_ADDR
117229: GO 118236
117231: LD_INT 15
117233: DOUBLE
117234: EQUAL
117235: IFTRUE 117239
117237: GO 117463
117239: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
117240: LD_ADDR_VAR 0 2
117244: PUSH
117245: LD_INT 1
117247: PUSH
117248: LD_INT 2
117250: PUSH
117251: LD_INT 3
117253: PUSH
117254: LD_INT 4
117256: PUSH
117257: LD_INT 5
117259: PUSH
117260: LD_INT 6
117262: PUSH
117263: LD_INT 7
117265: PUSH
117266: LD_INT 8
117268: PUSH
117269: LD_INT 9
117271: PUSH
117272: LD_INT 10
117274: PUSH
117275: LD_INT 11
117277: PUSH
117278: LD_INT 12
117280: PUSH
117281: LD_INT 13
117283: PUSH
117284: LD_INT 14
117286: PUSH
117287: LD_INT 15
117289: PUSH
117290: LD_INT 16
117292: PUSH
117293: LD_INT 17
117295: PUSH
117296: LD_INT 18
117298: PUSH
117299: LD_INT 19
117301: PUSH
117302: LD_INT 20
117304: PUSH
117305: LD_INT 21
117307: PUSH
117308: LD_INT 22
117310: PUSH
117311: LD_INT 23
117313: PUSH
117314: LD_INT 24
117316: PUSH
117317: LD_INT 25
117319: PUSH
117320: LD_INT 26
117322: PUSH
117323: LD_INT 27
117325: PUSH
117326: LD_INT 28
117328: PUSH
117329: LD_INT 29
117331: PUSH
117332: LD_INT 30
117334: PUSH
117335: LD_INT 31
117337: PUSH
117338: LD_INT 32
117340: PUSH
117341: LD_INT 33
117343: PUSH
117344: LD_INT 34
117346: PUSH
117347: LD_INT 36
117349: PUSH
117350: EMPTY
117351: LIST
117352: LIST
117353: LIST
117354: LIST
117355: LIST
117356: LIST
117357: LIST
117358: LIST
117359: LIST
117360: LIST
117361: LIST
117362: LIST
117363: LIST
117364: LIST
117365: LIST
117366: LIST
117367: LIST
117368: LIST
117369: LIST
117370: LIST
117371: LIST
117372: LIST
117373: LIST
117374: LIST
117375: LIST
117376: LIST
117377: LIST
117378: LIST
117379: LIST
117380: LIST
117381: LIST
117382: LIST
117383: LIST
117384: LIST
117385: LIST
117386: PUSH
117387: LD_INT 101
117389: PUSH
117390: LD_INT 102
117392: PUSH
117393: LD_INT 103
117395: PUSH
117396: LD_INT 104
117398: PUSH
117399: LD_INT 105
117401: PUSH
117402: LD_INT 106
117404: PUSH
117405: LD_INT 107
117407: PUSH
117408: LD_INT 108
117410: PUSH
117411: LD_INT 109
117413: PUSH
117414: LD_INT 110
117416: PUSH
117417: LD_INT 111
117419: PUSH
117420: LD_INT 112
117422: PUSH
117423: LD_INT 113
117425: PUSH
117426: LD_INT 114
117428: PUSH
117429: LD_INT 116
117431: PUSH
117432: LD_INT 117
117434: PUSH
117435: LD_INT 118
117437: PUSH
117438: EMPTY
117439: LIST
117440: LIST
117441: LIST
117442: LIST
117443: LIST
117444: LIST
117445: LIST
117446: LIST
117447: LIST
117448: LIST
117449: LIST
117450: LIST
117451: LIST
117452: LIST
117453: LIST
117454: LIST
117455: LIST
117456: PUSH
117457: EMPTY
117458: LIST
117459: LIST
117460: ST_TO_ADDR
117461: GO 118236
117463: LD_INT 16
117465: DOUBLE
117466: EQUAL
117467: IFTRUE 117471
117469: GO 117607
117471: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
117472: LD_ADDR_VAR 0 2
117476: PUSH
117477: LD_INT 2
117479: PUSH
117480: LD_INT 4
117482: PUSH
117483: LD_INT 5
117485: PUSH
117486: LD_INT 7
117488: PUSH
117489: LD_INT 11
117491: PUSH
117492: LD_INT 12
117494: PUSH
117495: LD_INT 15
117497: PUSH
117498: LD_INT 16
117500: PUSH
117501: LD_INT 20
117503: PUSH
117504: LD_INT 21
117506: PUSH
117507: LD_INT 22
117509: PUSH
117510: LD_INT 23
117512: PUSH
117513: LD_INT 25
117515: PUSH
117516: LD_INT 26
117518: PUSH
117519: LD_INT 30
117521: PUSH
117522: LD_INT 31
117524: PUSH
117525: LD_INT 32
117527: PUSH
117528: LD_INT 33
117530: PUSH
117531: LD_INT 34
117533: PUSH
117534: EMPTY
117535: LIST
117536: LIST
117537: LIST
117538: LIST
117539: LIST
117540: LIST
117541: LIST
117542: LIST
117543: LIST
117544: LIST
117545: LIST
117546: LIST
117547: LIST
117548: LIST
117549: LIST
117550: LIST
117551: LIST
117552: LIST
117553: LIST
117554: PUSH
117555: LD_INT 101
117557: PUSH
117558: LD_INT 102
117560: PUSH
117561: LD_INT 103
117563: PUSH
117564: LD_INT 106
117566: PUSH
117567: LD_INT 108
117569: PUSH
117570: LD_INT 112
117572: PUSH
117573: LD_INT 113
117575: PUSH
117576: LD_INT 114
117578: PUSH
117579: LD_INT 116
117581: PUSH
117582: LD_INT 117
117584: PUSH
117585: LD_INT 118
117587: PUSH
117588: EMPTY
117589: LIST
117590: LIST
117591: LIST
117592: LIST
117593: LIST
117594: LIST
117595: LIST
117596: LIST
117597: LIST
117598: LIST
117599: LIST
117600: PUSH
117601: EMPTY
117602: LIST
117603: LIST
117604: ST_TO_ADDR
117605: GO 118236
117607: LD_INT 17
117609: DOUBLE
117610: EQUAL
117611: IFTRUE 117615
117613: GO 117839
117615: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
117616: LD_ADDR_VAR 0 2
117620: PUSH
117621: LD_INT 1
117623: PUSH
117624: LD_INT 2
117626: PUSH
117627: LD_INT 3
117629: PUSH
117630: LD_INT 4
117632: PUSH
117633: LD_INT 5
117635: PUSH
117636: LD_INT 6
117638: PUSH
117639: LD_INT 7
117641: PUSH
117642: LD_INT 8
117644: PUSH
117645: LD_INT 9
117647: PUSH
117648: LD_INT 10
117650: PUSH
117651: LD_INT 11
117653: PUSH
117654: LD_INT 12
117656: PUSH
117657: LD_INT 13
117659: PUSH
117660: LD_INT 14
117662: PUSH
117663: LD_INT 15
117665: PUSH
117666: LD_INT 16
117668: PUSH
117669: LD_INT 17
117671: PUSH
117672: LD_INT 18
117674: PUSH
117675: LD_INT 19
117677: PUSH
117678: LD_INT 20
117680: PUSH
117681: LD_INT 21
117683: PUSH
117684: LD_INT 22
117686: PUSH
117687: LD_INT 23
117689: PUSH
117690: LD_INT 24
117692: PUSH
117693: LD_INT 25
117695: PUSH
117696: LD_INT 26
117698: PUSH
117699: LD_INT 27
117701: PUSH
117702: LD_INT 28
117704: PUSH
117705: LD_INT 29
117707: PUSH
117708: LD_INT 30
117710: PUSH
117711: LD_INT 31
117713: PUSH
117714: LD_INT 32
117716: PUSH
117717: LD_INT 33
117719: PUSH
117720: LD_INT 34
117722: PUSH
117723: LD_INT 36
117725: PUSH
117726: EMPTY
117727: LIST
117728: LIST
117729: LIST
117730: LIST
117731: LIST
117732: LIST
117733: LIST
117734: LIST
117735: LIST
117736: LIST
117737: LIST
117738: LIST
117739: LIST
117740: LIST
117741: LIST
117742: LIST
117743: LIST
117744: LIST
117745: LIST
117746: LIST
117747: LIST
117748: LIST
117749: LIST
117750: LIST
117751: LIST
117752: LIST
117753: LIST
117754: LIST
117755: LIST
117756: LIST
117757: LIST
117758: LIST
117759: LIST
117760: LIST
117761: LIST
117762: PUSH
117763: LD_INT 101
117765: PUSH
117766: LD_INT 102
117768: PUSH
117769: LD_INT 103
117771: PUSH
117772: LD_INT 104
117774: PUSH
117775: LD_INT 105
117777: PUSH
117778: LD_INT 106
117780: PUSH
117781: LD_INT 107
117783: PUSH
117784: LD_INT 108
117786: PUSH
117787: LD_INT 109
117789: PUSH
117790: LD_INT 110
117792: PUSH
117793: LD_INT 111
117795: PUSH
117796: LD_INT 112
117798: PUSH
117799: LD_INT 113
117801: PUSH
117802: LD_INT 114
117804: PUSH
117805: LD_INT 116
117807: PUSH
117808: LD_INT 117
117810: PUSH
117811: LD_INT 118
117813: PUSH
117814: EMPTY
117815: LIST
117816: LIST
117817: LIST
117818: LIST
117819: LIST
117820: LIST
117821: LIST
117822: LIST
117823: LIST
117824: LIST
117825: LIST
117826: LIST
117827: LIST
117828: LIST
117829: LIST
117830: LIST
117831: LIST
117832: PUSH
117833: EMPTY
117834: LIST
117835: LIST
117836: ST_TO_ADDR
117837: GO 118236
117839: LD_INT 18
117841: DOUBLE
117842: EQUAL
117843: IFTRUE 117847
117845: GO 117995
117847: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
117848: LD_ADDR_VAR 0 2
117852: PUSH
117853: LD_INT 2
117855: PUSH
117856: LD_INT 4
117858: PUSH
117859: LD_INT 5
117861: PUSH
117862: LD_INT 7
117864: PUSH
117865: LD_INT 11
117867: PUSH
117868: LD_INT 12
117870: PUSH
117871: LD_INT 15
117873: PUSH
117874: LD_INT 16
117876: PUSH
117877: LD_INT 20
117879: PUSH
117880: LD_INT 21
117882: PUSH
117883: LD_INT 22
117885: PUSH
117886: LD_INT 23
117888: PUSH
117889: LD_INT 25
117891: PUSH
117892: LD_INT 26
117894: PUSH
117895: LD_INT 30
117897: PUSH
117898: LD_INT 31
117900: PUSH
117901: LD_INT 32
117903: PUSH
117904: LD_INT 33
117906: PUSH
117907: LD_INT 34
117909: PUSH
117910: LD_INT 35
117912: PUSH
117913: LD_INT 36
117915: PUSH
117916: EMPTY
117917: LIST
117918: LIST
117919: LIST
117920: LIST
117921: LIST
117922: LIST
117923: LIST
117924: LIST
117925: LIST
117926: LIST
117927: LIST
117928: LIST
117929: LIST
117930: LIST
117931: LIST
117932: LIST
117933: LIST
117934: LIST
117935: LIST
117936: LIST
117937: LIST
117938: PUSH
117939: LD_INT 101
117941: PUSH
117942: LD_INT 102
117944: PUSH
117945: LD_INT 103
117947: PUSH
117948: LD_INT 106
117950: PUSH
117951: LD_INT 108
117953: PUSH
117954: LD_INT 112
117956: PUSH
117957: LD_INT 113
117959: PUSH
117960: LD_INT 114
117962: PUSH
117963: LD_INT 115
117965: PUSH
117966: LD_INT 116
117968: PUSH
117969: LD_INT 117
117971: PUSH
117972: LD_INT 118
117974: PUSH
117975: EMPTY
117976: LIST
117977: LIST
117978: LIST
117979: LIST
117980: LIST
117981: LIST
117982: LIST
117983: LIST
117984: LIST
117985: LIST
117986: LIST
117987: LIST
117988: PUSH
117989: EMPTY
117990: LIST
117991: LIST
117992: ST_TO_ADDR
117993: GO 118236
117995: LD_INT 19
117997: DOUBLE
117998: EQUAL
117999: IFTRUE 118003
118001: GO 118235
118003: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
118004: LD_ADDR_VAR 0 2
118008: PUSH
118009: LD_INT 1
118011: PUSH
118012: LD_INT 2
118014: PUSH
118015: LD_INT 3
118017: PUSH
118018: LD_INT 4
118020: PUSH
118021: LD_INT 5
118023: PUSH
118024: LD_INT 6
118026: PUSH
118027: LD_INT 7
118029: PUSH
118030: LD_INT 8
118032: PUSH
118033: LD_INT 9
118035: PUSH
118036: LD_INT 10
118038: PUSH
118039: LD_INT 11
118041: PUSH
118042: LD_INT 12
118044: PUSH
118045: LD_INT 13
118047: PUSH
118048: LD_INT 14
118050: PUSH
118051: LD_INT 15
118053: PUSH
118054: LD_INT 16
118056: PUSH
118057: LD_INT 17
118059: PUSH
118060: LD_INT 18
118062: PUSH
118063: LD_INT 19
118065: PUSH
118066: LD_INT 20
118068: PUSH
118069: LD_INT 21
118071: PUSH
118072: LD_INT 22
118074: PUSH
118075: LD_INT 23
118077: PUSH
118078: LD_INT 24
118080: PUSH
118081: LD_INT 25
118083: PUSH
118084: LD_INT 26
118086: PUSH
118087: LD_INT 27
118089: PUSH
118090: LD_INT 28
118092: PUSH
118093: LD_INT 29
118095: PUSH
118096: LD_INT 30
118098: PUSH
118099: LD_INT 31
118101: PUSH
118102: LD_INT 32
118104: PUSH
118105: LD_INT 33
118107: PUSH
118108: LD_INT 34
118110: PUSH
118111: LD_INT 35
118113: PUSH
118114: LD_INT 36
118116: PUSH
118117: EMPTY
118118: LIST
118119: LIST
118120: LIST
118121: LIST
118122: LIST
118123: LIST
118124: LIST
118125: LIST
118126: LIST
118127: LIST
118128: LIST
118129: LIST
118130: LIST
118131: LIST
118132: LIST
118133: LIST
118134: LIST
118135: LIST
118136: LIST
118137: LIST
118138: LIST
118139: LIST
118140: LIST
118141: LIST
118142: LIST
118143: LIST
118144: LIST
118145: LIST
118146: LIST
118147: LIST
118148: LIST
118149: LIST
118150: LIST
118151: LIST
118152: LIST
118153: LIST
118154: PUSH
118155: LD_INT 101
118157: PUSH
118158: LD_INT 102
118160: PUSH
118161: LD_INT 103
118163: PUSH
118164: LD_INT 104
118166: PUSH
118167: LD_INT 105
118169: PUSH
118170: LD_INT 106
118172: PUSH
118173: LD_INT 107
118175: PUSH
118176: LD_INT 108
118178: PUSH
118179: LD_INT 109
118181: PUSH
118182: LD_INT 110
118184: PUSH
118185: LD_INT 111
118187: PUSH
118188: LD_INT 112
118190: PUSH
118191: LD_INT 113
118193: PUSH
118194: LD_INT 114
118196: PUSH
118197: LD_INT 115
118199: PUSH
118200: LD_INT 116
118202: PUSH
118203: LD_INT 117
118205: PUSH
118206: LD_INT 118
118208: PUSH
118209: EMPTY
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: LIST
118221: LIST
118222: LIST
118223: LIST
118224: LIST
118225: LIST
118226: LIST
118227: LIST
118228: PUSH
118229: EMPTY
118230: LIST
118231: LIST
118232: ST_TO_ADDR
118233: GO 118236
118235: POP
// end else
118236: GO 118467
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
118238: LD_ADDR_VAR 0 2
118242: PUSH
118243: LD_INT 1
118245: PUSH
118246: LD_INT 2
118248: PUSH
118249: LD_INT 3
118251: PUSH
118252: LD_INT 4
118254: PUSH
118255: LD_INT 5
118257: PUSH
118258: LD_INT 6
118260: PUSH
118261: LD_INT 7
118263: PUSH
118264: LD_INT 8
118266: PUSH
118267: LD_INT 9
118269: PUSH
118270: LD_INT 10
118272: PUSH
118273: LD_INT 11
118275: PUSH
118276: LD_INT 12
118278: PUSH
118279: LD_INT 13
118281: PUSH
118282: LD_INT 14
118284: PUSH
118285: LD_INT 15
118287: PUSH
118288: LD_INT 16
118290: PUSH
118291: LD_INT 17
118293: PUSH
118294: LD_INT 18
118296: PUSH
118297: LD_INT 19
118299: PUSH
118300: LD_INT 20
118302: PUSH
118303: LD_INT 21
118305: PUSH
118306: LD_INT 22
118308: PUSH
118309: LD_INT 23
118311: PUSH
118312: LD_INT 24
118314: PUSH
118315: LD_INT 25
118317: PUSH
118318: LD_INT 26
118320: PUSH
118321: LD_INT 27
118323: PUSH
118324: LD_INT 28
118326: PUSH
118327: LD_INT 29
118329: PUSH
118330: LD_INT 30
118332: PUSH
118333: LD_INT 31
118335: PUSH
118336: LD_INT 32
118338: PUSH
118339: LD_INT 33
118341: PUSH
118342: LD_INT 34
118344: PUSH
118345: LD_INT 35
118347: PUSH
118348: LD_INT 36
118350: PUSH
118351: EMPTY
118352: LIST
118353: LIST
118354: LIST
118355: LIST
118356: LIST
118357: LIST
118358: LIST
118359: LIST
118360: LIST
118361: LIST
118362: LIST
118363: LIST
118364: LIST
118365: LIST
118366: LIST
118367: LIST
118368: LIST
118369: LIST
118370: LIST
118371: LIST
118372: LIST
118373: LIST
118374: LIST
118375: LIST
118376: LIST
118377: LIST
118378: LIST
118379: LIST
118380: LIST
118381: LIST
118382: LIST
118383: LIST
118384: LIST
118385: LIST
118386: LIST
118387: LIST
118388: PUSH
118389: LD_INT 101
118391: PUSH
118392: LD_INT 102
118394: PUSH
118395: LD_INT 103
118397: PUSH
118398: LD_INT 104
118400: PUSH
118401: LD_INT 105
118403: PUSH
118404: LD_INT 106
118406: PUSH
118407: LD_INT 107
118409: PUSH
118410: LD_INT 108
118412: PUSH
118413: LD_INT 109
118415: PUSH
118416: LD_INT 110
118418: PUSH
118419: LD_INT 111
118421: PUSH
118422: LD_INT 112
118424: PUSH
118425: LD_INT 113
118427: PUSH
118428: LD_INT 114
118430: PUSH
118431: LD_INT 115
118433: PUSH
118434: LD_INT 116
118436: PUSH
118437: LD_INT 117
118439: PUSH
118440: LD_INT 118
118442: PUSH
118443: EMPTY
118444: LIST
118445: LIST
118446: LIST
118447: LIST
118448: LIST
118449: LIST
118450: LIST
118451: LIST
118452: LIST
118453: LIST
118454: LIST
118455: LIST
118456: LIST
118457: LIST
118458: LIST
118459: LIST
118460: LIST
118461: LIST
118462: PUSH
118463: EMPTY
118464: LIST
118465: LIST
118466: ST_TO_ADDR
// if result then
118467: LD_VAR 0 2
118471: IFFALSE 119257
// begin normal :=  ;
118473: LD_ADDR_VAR 0 5
118477: PUSH
118478: LD_STRING 
118480: ST_TO_ADDR
// hardcore :=  ;
118481: LD_ADDR_VAR 0 6
118485: PUSH
118486: LD_STRING 
118488: ST_TO_ADDR
// active :=  ;
118489: LD_ADDR_VAR 0 7
118493: PUSH
118494: LD_STRING 
118496: ST_TO_ADDR
// for i = 1 to normalCounter do
118497: LD_ADDR_VAR 0 8
118501: PUSH
118502: DOUBLE
118503: LD_INT 1
118505: DEC
118506: ST_TO_ADDR
118507: LD_EXP 149
118511: PUSH
118512: FOR_TO
118513: IFFALSE 118614
// begin tmp := 0 ;
118515: LD_ADDR_VAR 0 3
118519: PUSH
118520: LD_STRING 0
118522: ST_TO_ADDR
// if result [ 1 ] then
118523: LD_VAR 0 2
118527: PUSH
118528: LD_INT 1
118530: ARRAY
118531: IFFALSE 118596
// if result [ 1 ] [ 1 ] = i then
118533: LD_VAR 0 2
118537: PUSH
118538: LD_INT 1
118540: ARRAY
118541: PUSH
118542: LD_INT 1
118544: ARRAY
118545: PUSH
118546: LD_VAR 0 8
118550: EQUAL
118551: IFFALSE 118596
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
118553: LD_ADDR_VAR 0 2
118557: PUSH
118558: LD_VAR 0 2
118562: PPUSH
118563: LD_INT 1
118565: PPUSH
118566: LD_VAR 0 2
118570: PUSH
118571: LD_INT 1
118573: ARRAY
118574: PPUSH
118575: LD_INT 1
118577: PPUSH
118578: CALL_OW 3
118582: PPUSH
118583: CALL_OW 1
118587: ST_TO_ADDR
// tmp := 1 ;
118588: LD_ADDR_VAR 0 3
118592: PUSH
118593: LD_STRING 1
118595: ST_TO_ADDR
// end ; normal := normal & tmp ;
118596: LD_ADDR_VAR 0 5
118600: PUSH
118601: LD_VAR 0 5
118605: PUSH
118606: LD_VAR 0 3
118610: STR
118611: ST_TO_ADDR
// end ;
118612: GO 118512
118614: POP
118615: POP
// for i = 1 to hardcoreCounter do
118616: LD_ADDR_VAR 0 8
118620: PUSH
118621: DOUBLE
118622: LD_INT 1
118624: DEC
118625: ST_TO_ADDR
118626: LD_EXP 150
118630: PUSH
118631: FOR_TO
118632: IFFALSE 118737
// begin tmp := 0 ;
118634: LD_ADDR_VAR 0 3
118638: PUSH
118639: LD_STRING 0
118641: ST_TO_ADDR
// if result [ 2 ] then
118642: LD_VAR 0 2
118646: PUSH
118647: LD_INT 2
118649: ARRAY
118650: IFFALSE 118719
// if result [ 2 ] [ 1 ] = 100 + i then
118652: LD_VAR 0 2
118656: PUSH
118657: LD_INT 2
118659: ARRAY
118660: PUSH
118661: LD_INT 1
118663: ARRAY
118664: PUSH
118665: LD_INT 100
118667: PUSH
118668: LD_VAR 0 8
118672: PLUS
118673: EQUAL
118674: IFFALSE 118719
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
118676: LD_ADDR_VAR 0 2
118680: PUSH
118681: LD_VAR 0 2
118685: PPUSH
118686: LD_INT 2
118688: PPUSH
118689: LD_VAR 0 2
118693: PUSH
118694: LD_INT 2
118696: ARRAY
118697: PPUSH
118698: LD_INT 1
118700: PPUSH
118701: CALL_OW 3
118705: PPUSH
118706: CALL_OW 1
118710: ST_TO_ADDR
// tmp := 1 ;
118711: LD_ADDR_VAR 0 3
118715: PUSH
118716: LD_STRING 1
118718: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
118719: LD_ADDR_VAR 0 6
118723: PUSH
118724: LD_VAR 0 6
118728: PUSH
118729: LD_VAR 0 3
118733: STR
118734: ST_TO_ADDR
// end ;
118735: GO 118631
118737: POP
118738: POP
// if isGameLoad then
118739: LD_VAR 0 1
118743: IFFALSE 119218
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
118745: LD_ADDR_VAR 0 4
118749: PUSH
118750: LD_EXP 153
118754: PUSH
118755: LD_EXP 152
118759: PUSH
118760: LD_EXP 154
118764: PUSH
118765: LD_EXP 151
118769: PUSH
118770: LD_EXP 155
118774: PUSH
118775: LD_EXP 156
118779: PUSH
118780: LD_EXP 157
118784: PUSH
118785: LD_EXP 158
118789: PUSH
118790: LD_EXP 159
118794: PUSH
118795: LD_EXP 160
118799: PUSH
118800: LD_EXP 161
118804: PUSH
118805: LD_EXP 162
118809: PUSH
118810: LD_EXP 163
118814: PUSH
118815: LD_EXP 164
118819: PUSH
118820: LD_EXP 172
118824: PUSH
118825: LD_EXP 173
118829: PUSH
118830: LD_EXP 174
118834: PUSH
118835: LD_EXP 175
118839: PUSH
118840: LD_EXP 177
118844: PUSH
118845: LD_EXP 178
118849: PUSH
118850: LD_EXP 179
118854: PUSH
118855: LD_EXP 182
118859: PUSH
118860: LD_EXP 184
118864: PUSH
118865: LD_EXP 185
118869: PUSH
118870: LD_EXP 186
118874: PUSH
118875: LD_EXP 188
118879: PUSH
118880: LD_EXP 189
118884: PUSH
118885: LD_EXP 192
118889: PUSH
118890: LD_EXP 193
118894: PUSH
118895: LD_EXP 194
118899: PUSH
118900: LD_EXP 195
118904: PUSH
118905: LD_EXP 196
118909: PUSH
118910: LD_EXP 197
118914: PUSH
118915: LD_EXP 198
118919: PUSH
118920: LD_EXP 199
118924: PUSH
118925: LD_EXP 200
118929: PUSH
118930: LD_EXP 165
118934: PUSH
118935: LD_EXP 166
118939: PUSH
118940: LD_EXP 169
118944: PUSH
118945: LD_EXP 170
118949: PUSH
118950: LD_EXP 171
118954: PUSH
118955: LD_EXP 167
118959: PUSH
118960: LD_EXP 168
118964: PUSH
118965: LD_EXP 176
118969: PUSH
118970: LD_EXP 180
118974: PUSH
118975: LD_EXP 181
118979: PUSH
118980: LD_EXP 183
118984: PUSH
118985: LD_EXP 187
118989: PUSH
118990: LD_EXP 190
118994: PUSH
118995: LD_EXP 191
118999: PUSH
119000: LD_EXP 201
119004: PUSH
119005: LD_EXP 202
119009: PUSH
119010: LD_EXP 203
119014: PUSH
119015: LD_EXP 204
119019: PUSH
119020: EMPTY
119021: LIST
119022: LIST
119023: LIST
119024: LIST
119025: LIST
119026: LIST
119027: LIST
119028: LIST
119029: LIST
119030: LIST
119031: LIST
119032: LIST
119033: LIST
119034: LIST
119035: LIST
119036: LIST
119037: LIST
119038: LIST
119039: LIST
119040: LIST
119041: LIST
119042: LIST
119043: LIST
119044: LIST
119045: LIST
119046: LIST
119047: LIST
119048: LIST
119049: LIST
119050: LIST
119051: LIST
119052: LIST
119053: LIST
119054: LIST
119055: LIST
119056: LIST
119057: LIST
119058: LIST
119059: LIST
119060: LIST
119061: LIST
119062: LIST
119063: LIST
119064: LIST
119065: LIST
119066: LIST
119067: LIST
119068: LIST
119069: LIST
119070: LIST
119071: LIST
119072: LIST
119073: LIST
119074: LIST
119075: ST_TO_ADDR
// tmp :=  ;
119076: LD_ADDR_VAR 0 3
119080: PUSH
119081: LD_STRING 
119083: ST_TO_ADDR
// for i = 1 to normalCounter do
119084: LD_ADDR_VAR 0 8
119088: PUSH
119089: DOUBLE
119090: LD_INT 1
119092: DEC
119093: ST_TO_ADDR
119094: LD_EXP 149
119098: PUSH
119099: FOR_TO
119100: IFFALSE 119136
// begin if flags [ i ] then
119102: LD_VAR 0 4
119106: PUSH
119107: LD_VAR 0 8
119111: ARRAY
119112: IFFALSE 119134
// tmp := tmp & i & ; ;
119114: LD_ADDR_VAR 0 3
119118: PUSH
119119: LD_VAR 0 3
119123: PUSH
119124: LD_VAR 0 8
119128: STR
119129: PUSH
119130: LD_STRING ;
119132: STR
119133: ST_TO_ADDR
// end ;
119134: GO 119099
119136: POP
119137: POP
// for i = 1 to hardcoreCounter do
119138: LD_ADDR_VAR 0 8
119142: PUSH
119143: DOUBLE
119144: LD_INT 1
119146: DEC
119147: ST_TO_ADDR
119148: LD_EXP 150
119152: PUSH
119153: FOR_TO
119154: IFFALSE 119200
// begin if flags [ normalCounter + i ] then
119156: LD_VAR 0 4
119160: PUSH
119161: LD_EXP 149
119165: PUSH
119166: LD_VAR 0 8
119170: PLUS
119171: ARRAY
119172: IFFALSE 119198
// tmp := tmp & ( 100 + i ) & ; ;
119174: LD_ADDR_VAR 0 3
119178: PUSH
119179: LD_VAR 0 3
119183: PUSH
119184: LD_INT 100
119186: PUSH
119187: LD_VAR 0 8
119191: PLUS
119192: STR
119193: PUSH
119194: LD_STRING ;
119196: STR
119197: ST_TO_ADDR
// end ;
119198: GO 119153
119200: POP
119201: POP
// if tmp then
119202: LD_VAR 0 3
119206: IFFALSE 119218
// active := tmp ;
119208: LD_ADDR_VAR 0 7
119212: PUSH
119213: LD_VAR 0 3
119217: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
119218: LD_STRING getStreamItemsFromMission("
119220: PUSH
119221: LD_VAR 0 5
119225: STR
119226: PUSH
119227: LD_STRING ","
119229: STR
119230: PUSH
119231: LD_VAR 0 6
119235: STR
119236: PUSH
119237: LD_STRING ","
119239: STR
119240: PUSH
119241: LD_VAR 0 7
119245: STR
119246: PUSH
119247: LD_STRING ")
119249: STR
119250: PPUSH
119251: CALL_OW 559
// end else
119255: GO 119264
// ToLua ( getStreamItemsFromMission("","","") ) ;
119257: LD_STRING getStreamItemsFromMission("","","")
119259: PPUSH
119260: CALL_OW 559
// end ;
119264: LD_VAR 0 2
119268: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
119269: LD_EXP 148
119273: PUSH
119274: LD_EXP 153
119278: AND
119279: IFFALSE 119403
119281: GO 119283
119283: DISABLE
119284: LD_INT 0
119286: PPUSH
119287: PPUSH
// begin enable ;
119288: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
119289: LD_ADDR_VAR 0 2
119293: PUSH
119294: LD_INT 22
119296: PUSH
119297: LD_OWVAR 2
119301: PUSH
119302: EMPTY
119303: LIST
119304: LIST
119305: PUSH
119306: LD_INT 2
119308: PUSH
119309: LD_INT 34
119311: PUSH
119312: LD_INT 7
119314: PUSH
119315: EMPTY
119316: LIST
119317: LIST
119318: PUSH
119319: LD_INT 34
119321: PUSH
119322: LD_INT 45
119324: PUSH
119325: EMPTY
119326: LIST
119327: LIST
119328: PUSH
119329: LD_INT 34
119331: PUSH
119332: LD_INT 28
119334: PUSH
119335: EMPTY
119336: LIST
119337: LIST
119338: PUSH
119339: LD_INT 34
119341: PUSH
119342: LD_INT 47
119344: PUSH
119345: EMPTY
119346: LIST
119347: LIST
119348: PUSH
119349: EMPTY
119350: LIST
119351: LIST
119352: LIST
119353: LIST
119354: LIST
119355: PUSH
119356: EMPTY
119357: LIST
119358: LIST
119359: PPUSH
119360: CALL_OW 69
119364: ST_TO_ADDR
// if not tmp then
119365: LD_VAR 0 2
119369: NOT
119370: IFFALSE 119374
// exit ;
119372: GO 119403
// for i in tmp do
119374: LD_ADDR_VAR 0 1
119378: PUSH
119379: LD_VAR 0 2
119383: PUSH
119384: FOR_IN
119385: IFFALSE 119401
// begin SetLives ( i , 0 ) ;
119387: LD_VAR 0 1
119391: PPUSH
119392: LD_INT 0
119394: PPUSH
119395: CALL_OW 234
// end ;
119399: GO 119384
119401: POP
119402: POP
// end ;
119403: PPOPN 2
119405: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
119406: LD_EXP 148
119410: PUSH
119411: LD_EXP 154
119415: AND
119416: IFFALSE 119500
119418: GO 119420
119420: DISABLE
119421: LD_INT 0
119423: PPUSH
119424: PPUSH
// begin enable ;
119425: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
119426: LD_ADDR_VAR 0 2
119430: PUSH
119431: LD_INT 22
119433: PUSH
119434: LD_OWVAR 2
119438: PUSH
119439: EMPTY
119440: LIST
119441: LIST
119442: PUSH
119443: LD_INT 32
119445: PUSH
119446: LD_INT 3
119448: PUSH
119449: EMPTY
119450: LIST
119451: LIST
119452: PUSH
119453: EMPTY
119454: LIST
119455: LIST
119456: PPUSH
119457: CALL_OW 69
119461: ST_TO_ADDR
// if not tmp then
119462: LD_VAR 0 2
119466: NOT
119467: IFFALSE 119471
// exit ;
119469: GO 119500
// for i in tmp do
119471: LD_ADDR_VAR 0 1
119475: PUSH
119476: LD_VAR 0 2
119480: PUSH
119481: FOR_IN
119482: IFFALSE 119498
// begin SetLives ( i , 0 ) ;
119484: LD_VAR 0 1
119488: PPUSH
119489: LD_INT 0
119491: PPUSH
119492: CALL_OW 234
// end ;
119496: GO 119481
119498: POP
119499: POP
// end ;
119500: PPOPN 2
119502: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
119503: LD_EXP 148
119507: PUSH
119508: LD_EXP 151
119512: AND
119513: IFFALSE 119606
119515: GO 119517
119517: DISABLE
119518: LD_INT 0
119520: PPUSH
// begin enable ;
119521: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
119522: LD_ADDR_VAR 0 1
119526: PUSH
119527: LD_INT 22
119529: PUSH
119530: LD_OWVAR 2
119534: PUSH
119535: EMPTY
119536: LIST
119537: LIST
119538: PUSH
119539: LD_INT 2
119541: PUSH
119542: LD_INT 25
119544: PUSH
119545: LD_INT 5
119547: PUSH
119548: EMPTY
119549: LIST
119550: LIST
119551: PUSH
119552: LD_INT 25
119554: PUSH
119555: LD_INT 9
119557: PUSH
119558: EMPTY
119559: LIST
119560: LIST
119561: PUSH
119562: LD_INT 25
119564: PUSH
119565: LD_INT 8
119567: PUSH
119568: EMPTY
119569: LIST
119570: LIST
119571: PUSH
119572: EMPTY
119573: LIST
119574: LIST
119575: LIST
119576: LIST
119577: PUSH
119578: EMPTY
119579: LIST
119580: LIST
119581: PPUSH
119582: CALL_OW 69
119586: PUSH
119587: FOR_IN
119588: IFFALSE 119604
// begin SetClass ( i , 1 ) ;
119590: LD_VAR 0 1
119594: PPUSH
119595: LD_INT 1
119597: PPUSH
119598: CALL_OW 336
// end ;
119602: GO 119587
119604: POP
119605: POP
// end ;
119606: PPOPN 1
119608: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
119609: LD_EXP 148
119613: PUSH
119614: LD_EXP 152
119618: AND
119619: PUSH
119620: LD_OWVAR 65
119624: PUSH
119625: LD_INT 7
119627: LESS
119628: AND
119629: IFFALSE 119643
119631: GO 119633
119633: DISABLE
// begin enable ;
119634: ENABLE
// game_speed := 7 ;
119635: LD_ADDR_OWVAR 65
119639: PUSH
119640: LD_INT 7
119642: ST_TO_ADDR
// end ;
119643: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
119644: LD_EXP 148
119648: PUSH
119649: LD_EXP 155
119653: AND
119654: IFFALSE 119856
119656: GO 119658
119658: DISABLE
119659: LD_INT 0
119661: PPUSH
119662: PPUSH
119663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
119664: LD_ADDR_VAR 0 3
119668: PUSH
119669: LD_INT 81
119671: PUSH
119672: LD_OWVAR 2
119676: PUSH
119677: EMPTY
119678: LIST
119679: LIST
119680: PUSH
119681: LD_INT 21
119683: PUSH
119684: LD_INT 1
119686: PUSH
119687: EMPTY
119688: LIST
119689: LIST
119690: PUSH
119691: EMPTY
119692: LIST
119693: LIST
119694: PPUSH
119695: CALL_OW 69
119699: ST_TO_ADDR
// if not tmp then
119700: LD_VAR 0 3
119704: NOT
119705: IFFALSE 119709
// exit ;
119707: GO 119856
// if tmp > 5 then
119709: LD_VAR 0 3
119713: PUSH
119714: LD_INT 5
119716: GREATER
119717: IFFALSE 119729
// k := 5 else
119719: LD_ADDR_VAR 0 2
119723: PUSH
119724: LD_INT 5
119726: ST_TO_ADDR
119727: GO 119739
// k := tmp ;
119729: LD_ADDR_VAR 0 2
119733: PUSH
119734: LD_VAR 0 3
119738: ST_TO_ADDR
// for i := 1 to k do
119739: LD_ADDR_VAR 0 1
119743: PUSH
119744: DOUBLE
119745: LD_INT 1
119747: DEC
119748: ST_TO_ADDR
119749: LD_VAR 0 2
119753: PUSH
119754: FOR_TO
119755: IFFALSE 119854
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
119757: LD_VAR 0 3
119761: PUSH
119762: LD_VAR 0 1
119766: ARRAY
119767: PPUSH
119768: LD_VAR 0 1
119772: PUSH
119773: LD_INT 4
119775: MOD
119776: PUSH
119777: LD_INT 1
119779: PLUS
119780: PPUSH
119781: CALL_OW 259
119785: PUSH
119786: LD_INT 10
119788: LESS
119789: IFFALSE 119852
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
119791: LD_VAR 0 3
119795: PUSH
119796: LD_VAR 0 1
119800: ARRAY
119801: PPUSH
119802: LD_VAR 0 1
119806: PUSH
119807: LD_INT 4
119809: MOD
119810: PUSH
119811: LD_INT 1
119813: PLUS
119814: PPUSH
119815: LD_VAR 0 3
119819: PUSH
119820: LD_VAR 0 1
119824: ARRAY
119825: PPUSH
119826: LD_VAR 0 1
119830: PUSH
119831: LD_INT 4
119833: MOD
119834: PUSH
119835: LD_INT 1
119837: PLUS
119838: PPUSH
119839: CALL_OW 259
119843: PUSH
119844: LD_INT 1
119846: PLUS
119847: PPUSH
119848: CALL_OW 237
119852: GO 119754
119854: POP
119855: POP
// end ;
119856: PPOPN 3
119858: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
119859: LD_EXP 148
119863: PUSH
119864: LD_EXP 156
119868: AND
119869: IFFALSE 119889
119871: GO 119873
119873: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
119874: LD_INT 4
119876: PPUSH
119877: LD_OWVAR 2
119881: PPUSH
119882: LD_INT 0
119884: PPUSH
119885: CALL_OW 324
119889: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119890: LD_EXP 148
119894: PUSH
119895: LD_EXP 185
119899: AND
119900: IFFALSE 119920
119902: GO 119904
119904: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119905: LD_INT 19
119907: PPUSH
119908: LD_OWVAR 2
119912: PPUSH
119913: LD_INT 0
119915: PPUSH
119916: CALL_OW 324
119920: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119921: LD_EXP 148
119925: PUSH
119926: LD_EXP 157
119930: AND
119931: IFFALSE 120033
119933: GO 119935
119935: DISABLE
119936: LD_INT 0
119938: PPUSH
119939: PPUSH
// begin enable ;
119940: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119941: LD_ADDR_VAR 0 2
119945: PUSH
119946: LD_INT 22
119948: PUSH
119949: LD_OWVAR 2
119953: PUSH
119954: EMPTY
119955: LIST
119956: LIST
119957: PUSH
119958: LD_INT 2
119960: PUSH
119961: LD_INT 34
119963: PUSH
119964: LD_INT 11
119966: PUSH
119967: EMPTY
119968: LIST
119969: LIST
119970: PUSH
119971: LD_INT 34
119973: PUSH
119974: LD_INT 30
119976: PUSH
119977: EMPTY
119978: LIST
119979: LIST
119980: PUSH
119981: EMPTY
119982: LIST
119983: LIST
119984: LIST
119985: PUSH
119986: EMPTY
119987: LIST
119988: LIST
119989: PPUSH
119990: CALL_OW 69
119994: ST_TO_ADDR
// if not tmp then
119995: LD_VAR 0 2
119999: NOT
120000: IFFALSE 120004
// exit ;
120002: GO 120033
// for i in tmp do
120004: LD_ADDR_VAR 0 1
120008: PUSH
120009: LD_VAR 0 2
120013: PUSH
120014: FOR_IN
120015: IFFALSE 120031
// begin SetLives ( i , 0 ) ;
120017: LD_VAR 0 1
120021: PPUSH
120022: LD_INT 0
120024: PPUSH
120025: CALL_OW 234
// end ;
120029: GO 120014
120031: POP
120032: POP
// end ;
120033: PPOPN 2
120035: END
// every 0 0$1 trigger StreamModeActive and sBunker do
120036: LD_EXP 148
120040: PUSH
120041: LD_EXP 158
120045: AND
120046: IFFALSE 120066
120048: GO 120050
120050: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
120051: LD_INT 32
120053: PPUSH
120054: LD_OWVAR 2
120058: PPUSH
120059: LD_INT 0
120061: PPUSH
120062: CALL_OW 324
120066: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
120067: LD_EXP 148
120071: PUSH
120072: LD_EXP 159
120076: AND
120077: IFFALSE 120258
120079: GO 120081
120081: DISABLE
120082: LD_INT 0
120084: PPUSH
120085: PPUSH
120086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
120087: LD_ADDR_VAR 0 2
120091: PUSH
120092: LD_INT 22
120094: PUSH
120095: LD_OWVAR 2
120099: PUSH
120100: EMPTY
120101: LIST
120102: LIST
120103: PUSH
120104: LD_INT 33
120106: PUSH
120107: LD_INT 3
120109: PUSH
120110: EMPTY
120111: LIST
120112: LIST
120113: PUSH
120114: EMPTY
120115: LIST
120116: LIST
120117: PPUSH
120118: CALL_OW 69
120122: ST_TO_ADDR
// if not tmp then
120123: LD_VAR 0 2
120127: NOT
120128: IFFALSE 120132
// exit ;
120130: GO 120258
// side := 0 ;
120132: LD_ADDR_VAR 0 3
120136: PUSH
120137: LD_INT 0
120139: ST_TO_ADDR
// for i := 1 to 8 do
120140: LD_ADDR_VAR 0 1
120144: PUSH
120145: DOUBLE
120146: LD_INT 1
120148: DEC
120149: ST_TO_ADDR
120150: LD_INT 8
120152: PUSH
120153: FOR_TO
120154: IFFALSE 120202
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
120156: LD_OWVAR 2
120160: PUSH
120161: LD_VAR 0 1
120165: NONEQUAL
120166: PUSH
120167: LD_OWVAR 2
120171: PPUSH
120172: LD_VAR 0 1
120176: PPUSH
120177: CALL_OW 81
120181: PUSH
120182: LD_INT 2
120184: EQUAL
120185: AND
120186: IFFALSE 120200
// begin side := i ;
120188: LD_ADDR_VAR 0 3
120192: PUSH
120193: LD_VAR 0 1
120197: ST_TO_ADDR
// break ;
120198: GO 120202
// end ;
120200: GO 120153
120202: POP
120203: POP
// if not side then
120204: LD_VAR 0 3
120208: NOT
120209: IFFALSE 120213
// exit ;
120211: GO 120258
// for i := 1 to tmp do
120213: LD_ADDR_VAR 0 1
120217: PUSH
120218: DOUBLE
120219: LD_INT 1
120221: DEC
120222: ST_TO_ADDR
120223: LD_VAR 0 2
120227: PUSH
120228: FOR_TO
120229: IFFALSE 120256
// if Prob ( 60 ) then
120231: LD_INT 60
120233: PPUSH
120234: CALL_OW 13
120238: IFFALSE 120254
// SetSide ( i , side ) ;
120240: LD_VAR 0 1
120244: PPUSH
120245: LD_VAR 0 3
120249: PPUSH
120250: CALL_OW 235
120254: GO 120228
120256: POP
120257: POP
// end ;
120258: PPOPN 3
120260: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
120261: LD_EXP 148
120265: PUSH
120266: LD_EXP 161
120270: AND
120271: IFFALSE 120390
120273: GO 120275
120275: DISABLE
120276: LD_INT 0
120278: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
120279: LD_ADDR_VAR 0 1
120283: PUSH
120284: LD_INT 22
120286: PUSH
120287: LD_OWVAR 2
120291: PUSH
120292: EMPTY
120293: LIST
120294: LIST
120295: PUSH
120296: LD_INT 21
120298: PUSH
120299: LD_INT 1
120301: PUSH
120302: EMPTY
120303: LIST
120304: LIST
120305: PUSH
120306: LD_INT 3
120308: PUSH
120309: LD_INT 23
120311: PUSH
120312: LD_INT 0
120314: PUSH
120315: EMPTY
120316: LIST
120317: LIST
120318: PUSH
120319: EMPTY
120320: LIST
120321: LIST
120322: PUSH
120323: EMPTY
120324: LIST
120325: LIST
120326: LIST
120327: PPUSH
120328: CALL_OW 69
120332: PUSH
120333: FOR_IN
120334: IFFALSE 120388
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
120336: LD_VAR 0 1
120340: PPUSH
120341: CALL_OW 257
120345: PUSH
120346: LD_INT 1
120348: PUSH
120349: LD_INT 2
120351: PUSH
120352: LD_INT 3
120354: PUSH
120355: LD_INT 4
120357: PUSH
120358: EMPTY
120359: LIST
120360: LIST
120361: LIST
120362: LIST
120363: IN
120364: IFFALSE 120386
// SetClass ( un , rand ( 1 , 4 ) ) ;
120366: LD_VAR 0 1
120370: PPUSH
120371: LD_INT 1
120373: PPUSH
120374: LD_INT 4
120376: PPUSH
120377: CALL_OW 12
120381: PPUSH
120382: CALL_OW 336
120386: GO 120333
120388: POP
120389: POP
// end ;
120390: PPOPN 1
120392: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
120393: LD_EXP 148
120397: PUSH
120398: LD_EXP 160
120402: AND
120403: IFFALSE 120482
120405: GO 120407
120407: DISABLE
120408: LD_INT 0
120410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120411: LD_ADDR_VAR 0 1
120415: PUSH
120416: LD_INT 22
120418: PUSH
120419: LD_OWVAR 2
120423: PUSH
120424: EMPTY
120425: LIST
120426: LIST
120427: PUSH
120428: LD_INT 21
120430: PUSH
120431: LD_INT 3
120433: PUSH
120434: EMPTY
120435: LIST
120436: LIST
120437: PUSH
120438: EMPTY
120439: LIST
120440: LIST
120441: PPUSH
120442: CALL_OW 69
120446: ST_TO_ADDR
// if not tmp then
120447: LD_VAR 0 1
120451: NOT
120452: IFFALSE 120456
// exit ;
120454: GO 120482
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
120456: LD_VAR 0 1
120460: PUSH
120461: LD_INT 1
120463: PPUSH
120464: LD_VAR 0 1
120468: PPUSH
120469: CALL_OW 12
120473: ARRAY
120474: PPUSH
120475: LD_INT 100
120477: PPUSH
120478: CALL_OW 234
// end ;
120482: PPOPN 1
120484: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
120485: LD_EXP 148
120489: PUSH
120490: LD_EXP 162
120494: AND
120495: IFFALSE 120593
120497: GO 120499
120499: DISABLE
120500: LD_INT 0
120502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
120503: LD_ADDR_VAR 0 1
120507: PUSH
120508: LD_INT 22
120510: PUSH
120511: LD_OWVAR 2
120515: PUSH
120516: EMPTY
120517: LIST
120518: LIST
120519: PUSH
120520: LD_INT 21
120522: PUSH
120523: LD_INT 1
120525: PUSH
120526: EMPTY
120527: LIST
120528: LIST
120529: PUSH
120530: EMPTY
120531: LIST
120532: LIST
120533: PPUSH
120534: CALL_OW 69
120538: ST_TO_ADDR
// if not tmp then
120539: LD_VAR 0 1
120543: NOT
120544: IFFALSE 120548
// exit ;
120546: GO 120593
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
120548: LD_VAR 0 1
120552: PUSH
120553: LD_INT 1
120555: PPUSH
120556: LD_VAR 0 1
120560: PPUSH
120561: CALL_OW 12
120565: ARRAY
120566: PPUSH
120567: LD_INT 1
120569: PPUSH
120570: LD_INT 4
120572: PPUSH
120573: CALL_OW 12
120577: PPUSH
120578: LD_INT 3000
120580: PPUSH
120581: LD_INT 9000
120583: PPUSH
120584: CALL_OW 12
120588: PPUSH
120589: CALL_OW 492
// end ;
120593: PPOPN 1
120595: END
// every 0 0$1 trigger StreamModeActive and sDepot do
120596: LD_EXP 148
120600: PUSH
120601: LD_EXP 163
120605: AND
120606: IFFALSE 120626
120608: GO 120610
120610: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
120611: LD_INT 1
120613: PPUSH
120614: LD_OWVAR 2
120618: PPUSH
120619: LD_INT 0
120621: PPUSH
120622: CALL_OW 324
120626: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
120627: LD_EXP 148
120631: PUSH
120632: LD_EXP 164
120636: AND
120637: IFFALSE 120720
120639: GO 120641
120641: DISABLE
120642: LD_INT 0
120644: PPUSH
120645: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
120646: LD_ADDR_VAR 0 2
120650: PUSH
120651: LD_INT 22
120653: PUSH
120654: LD_OWVAR 2
120658: PUSH
120659: EMPTY
120660: LIST
120661: LIST
120662: PUSH
120663: LD_INT 21
120665: PUSH
120666: LD_INT 3
120668: PUSH
120669: EMPTY
120670: LIST
120671: LIST
120672: PUSH
120673: EMPTY
120674: LIST
120675: LIST
120676: PPUSH
120677: CALL_OW 69
120681: ST_TO_ADDR
// if not tmp then
120682: LD_VAR 0 2
120686: NOT
120687: IFFALSE 120691
// exit ;
120689: GO 120720
// for i in tmp do
120691: LD_ADDR_VAR 0 1
120695: PUSH
120696: LD_VAR 0 2
120700: PUSH
120701: FOR_IN
120702: IFFALSE 120718
// SetBLevel ( i , 10 ) ;
120704: LD_VAR 0 1
120708: PPUSH
120709: LD_INT 10
120711: PPUSH
120712: CALL_OW 241
120716: GO 120701
120718: POP
120719: POP
// end ;
120720: PPOPN 2
120722: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
120723: LD_EXP 148
120727: PUSH
120728: LD_EXP 165
120732: AND
120733: IFFALSE 120844
120735: GO 120737
120737: DISABLE
120738: LD_INT 0
120740: PPUSH
120741: PPUSH
120742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120743: LD_ADDR_VAR 0 3
120747: PUSH
120748: LD_INT 22
120750: PUSH
120751: LD_OWVAR 2
120755: PUSH
120756: EMPTY
120757: LIST
120758: LIST
120759: PUSH
120760: LD_INT 25
120762: PUSH
120763: LD_INT 1
120765: PUSH
120766: EMPTY
120767: LIST
120768: LIST
120769: PUSH
120770: EMPTY
120771: LIST
120772: LIST
120773: PPUSH
120774: CALL_OW 69
120778: ST_TO_ADDR
// if not tmp then
120779: LD_VAR 0 3
120783: NOT
120784: IFFALSE 120788
// exit ;
120786: GO 120844
// un := tmp [ rand ( 1 , tmp ) ] ;
120788: LD_ADDR_VAR 0 2
120792: PUSH
120793: LD_VAR 0 3
120797: PUSH
120798: LD_INT 1
120800: PPUSH
120801: LD_VAR 0 3
120805: PPUSH
120806: CALL_OW 12
120810: ARRAY
120811: ST_TO_ADDR
// if Crawls ( un ) then
120812: LD_VAR 0 2
120816: PPUSH
120817: CALL_OW 318
120821: IFFALSE 120832
// ComWalk ( un ) ;
120823: LD_VAR 0 2
120827: PPUSH
120828: CALL_OW 138
// SetClass ( un , class_sniper ) ;
120832: LD_VAR 0 2
120836: PPUSH
120837: LD_INT 5
120839: PPUSH
120840: CALL_OW 336
// end ;
120844: PPOPN 3
120846: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
120847: LD_EXP 148
120851: PUSH
120852: LD_EXP 166
120856: AND
120857: PUSH
120858: LD_OWVAR 67
120862: PUSH
120863: LD_INT 4
120865: LESS
120866: AND
120867: IFFALSE 120886
120869: GO 120871
120871: DISABLE
// begin Difficulty := Difficulty + 1 ;
120872: LD_ADDR_OWVAR 67
120876: PUSH
120877: LD_OWVAR 67
120881: PUSH
120882: LD_INT 1
120884: PLUS
120885: ST_TO_ADDR
// end ;
120886: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120887: LD_EXP 148
120891: PUSH
120892: LD_EXP 167
120896: AND
120897: IFFALSE 121000
120899: GO 120901
120901: DISABLE
120902: LD_INT 0
120904: PPUSH
// begin for i := 1 to 5 do
120905: LD_ADDR_VAR 0 1
120909: PUSH
120910: DOUBLE
120911: LD_INT 1
120913: DEC
120914: ST_TO_ADDR
120915: LD_INT 5
120917: PUSH
120918: FOR_TO
120919: IFFALSE 120998
// begin uc_nation := nation_nature ;
120921: LD_ADDR_OWVAR 21
120925: PUSH
120926: LD_INT 0
120928: ST_TO_ADDR
// uc_side := 0 ;
120929: LD_ADDR_OWVAR 20
120933: PUSH
120934: LD_INT 0
120936: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120937: LD_ADDR_OWVAR 29
120941: PUSH
120942: LD_INT 12
120944: PUSH
120945: LD_INT 12
120947: PUSH
120948: EMPTY
120949: LIST
120950: LIST
120951: ST_TO_ADDR
// hc_agressivity := 20 ;
120952: LD_ADDR_OWVAR 35
120956: PUSH
120957: LD_INT 20
120959: ST_TO_ADDR
// hc_class := class_tiger ;
120960: LD_ADDR_OWVAR 28
120964: PUSH
120965: LD_INT 14
120967: ST_TO_ADDR
// hc_gallery :=  ;
120968: LD_ADDR_OWVAR 33
120972: PUSH
120973: LD_STRING 
120975: ST_TO_ADDR
// hc_name :=  ;
120976: LD_ADDR_OWVAR 26
120980: PUSH
120981: LD_STRING 
120983: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120984: CALL_OW 44
120988: PPUSH
120989: LD_INT 0
120991: PPUSH
120992: CALL_OW 51
// end ;
120996: GO 120918
120998: POP
120999: POP
// end ;
121000: PPOPN 1
121002: END
// every 0 0$1 trigger StreamModeActive and sBomb do
121003: LD_EXP 148
121007: PUSH
121008: LD_EXP 168
121012: AND
121013: IFFALSE 121022
121015: GO 121017
121017: DISABLE
// StreamSibBomb ;
121018: CALL 121023 0 0
121022: END
// export function StreamSibBomb ; var i , x , y ; begin
121023: LD_INT 0
121025: PPUSH
121026: PPUSH
121027: PPUSH
121028: PPUSH
// result := false ;
121029: LD_ADDR_VAR 0 1
121033: PUSH
121034: LD_INT 0
121036: ST_TO_ADDR
// for i := 1 to 16 do
121037: LD_ADDR_VAR 0 2
121041: PUSH
121042: DOUBLE
121043: LD_INT 1
121045: DEC
121046: ST_TO_ADDR
121047: LD_INT 16
121049: PUSH
121050: FOR_TO
121051: IFFALSE 121250
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
121053: LD_ADDR_VAR 0 3
121057: PUSH
121058: LD_INT 10
121060: PUSH
121061: LD_INT 20
121063: PUSH
121064: LD_INT 30
121066: PUSH
121067: LD_INT 40
121069: PUSH
121070: LD_INT 50
121072: PUSH
121073: LD_INT 60
121075: PUSH
121076: LD_INT 70
121078: PUSH
121079: LD_INT 80
121081: PUSH
121082: LD_INT 90
121084: PUSH
121085: LD_INT 100
121087: PUSH
121088: LD_INT 110
121090: PUSH
121091: LD_INT 120
121093: PUSH
121094: LD_INT 130
121096: PUSH
121097: LD_INT 140
121099: PUSH
121100: LD_INT 150
121102: PUSH
121103: EMPTY
121104: LIST
121105: LIST
121106: LIST
121107: LIST
121108: LIST
121109: LIST
121110: LIST
121111: LIST
121112: LIST
121113: LIST
121114: LIST
121115: LIST
121116: LIST
121117: LIST
121118: LIST
121119: PUSH
121120: LD_INT 1
121122: PPUSH
121123: LD_INT 15
121125: PPUSH
121126: CALL_OW 12
121130: ARRAY
121131: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
121132: LD_ADDR_VAR 0 4
121136: PUSH
121137: LD_INT 10
121139: PUSH
121140: LD_INT 20
121142: PUSH
121143: LD_INT 30
121145: PUSH
121146: LD_INT 40
121148: PUSH
121149: LD_INT 50
121151: PUSH
121152: LD_INT 60
121154: PUSH
121155: LD_INT 70
121157: PUSH
121158: LD_INT 80
121160: PUSH
121161: LD_INT 90
121163: PUSH
121164: LD_INT 100
121166: PUSH
121167: LD_INT 110
121169: PUSH
121170: LD_INT 120
121172: PUSH
121173: LD_INT 130
121175: PUSH
121176: LD_INT 140
121178: PUSH
121179: LD_INT 150
121181: PUSH
121182: EMPTY
121183: LIST
121184: LIST
121185: LIST
121186: LIST
121187: LIST
121188: LIST
121189: LIST
121190: LIST
121191: LIST
121192: LIST
121193: LIST
121194: LIST
121195: LIST
121196: LIST
121197: LIST
121198: PUSH
121199: LD_INT 1
121201: PPUSH
121202: LD_INT 15
121204: PPUSH
121205: CALL_OW 12
121209: ARRAY
121210: ST_TO_ADDR
// if ValidHex ( x , y ) then
121211: LD_VAR 0 3
121215: PPUSH
121216: LD_VAR 0 4
121220: PPUSH
121221: CALL_OW 488
121225: IFFALSE 121248
// begin result := [ x , y ] ;
121227: LD_ADDR_VAR 0 1
121231: PUSH
121232: LD_VAR 0 3
121236: PUSH
121237: LD_VAR 0 4
121241: PUSH
121242: EMPTY
121243: LIST
121244: LIST
121245: ST_TO_ADDR
// break ;
121246: GO 121250
// end ; end ;
121248: GO 121050
121250: POP
121251: POP
// if result then
121252: LD_VAR 0 1
121256: IFFALSE 121316
// begin ToLua ( playSibBomb() ) ;
121258: LD_STRING playSibBomb()
121260: PPUSH
121261: CALL_OW 559
// wait ( 0 0$14 ) ;
121265: LD_INT 490
121267: PPUSH
121268: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
121272: LD_VAR 0 1
121276: PUSH
121277: LD_INT 1
121279: ARRAY
121280: PPUSH
121281: LD_VAR 0 1
121285: PUSH
121286: LD_INT 2
121288: ARRAY
121289: PPUSH
121290: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
121294: LD_VAR 0 1
121298: PUSH
121299: LD_INT 1
121301: ARRAY
121302: PPUSH
121303: LD_VAR 0 1
121307: PUSH
121308: LD_INT 2
121310: ARRAY
121311: PPUSH
121312: CALL_OW 429
// end ; end ;
121316: LD_VAR 0 1
121320: RET
// every 0 0$1 trigger StreamModeActive and sReset do
121321: LD_EXP 148
121325: PUSH
121326: LD_EXP 170
121330: AND
121331: IFFALSE 121343
121333: GO 121335
121335: DISABLE
// YouLost (  ) ;
121336: LD_STRING 
121338: PPUSH
121339: CALL_OW 104
121343: END
// every 0 0$1 trigger StreamModeActive and sFog do
121344: LD_EXP 148
121348: PUSH
121349: LD_EXP 169
121353: AND
121354: IFFALSE 121368
121356: GO 121358
121358: DISABLE
// FogOff ( your_side ) ;
121359: LD_OWVAR 2
121363: PPUSH
121364: CALL_OW 344
121368: END
// every 0 0$1 trigger StreamModeActive and sSun do
121369: LD_EXP 148
121373: PUSH
121374: LD_EXP 171
121378: AND
121379: IFFALSE 121407
121381: GO 121383
121383: DISABLE
// begin solar_recharge_percent := 0 ;
121384: LD_ADDR_OWVAR 79
121388: PUSH
121389: LD_INT 0
121391: ST_TO_ADDR
// wait ( 5 5$00 ) ;
121392: LD_INT 10500
121394: PPUSH
121395: CALL_OW 67
// solar_recharge_percent := 100 ;
121399: LD_ADDR_OWVAR 79
121403: PUSH
121404: LD_INT 100
121406: ST_TO_ADDR
// end ;
121407: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
121408: LD_EXP 148
121412: PUSH
121413: LD_EXP 172
121417: AND
121418: IFFALSE 121657
121420: GO 121422
121422: DISABLE
121423: LD_INT 0
121425: PPUSH
121426: PPUSH
121427: PPUSH
// begin tmp := [ ] ;
121428: LD_ADDR_VAR 0 3
121432: PUSH
121433: EMPTY
121434: ST_TO_ADDR
// for i := 1 to 6 do
121435: LD_ADDR_VAR 0 1
121439: PUSH
121440: DOUBLE
121441: LD_INT 1
121443: DEC
121444: ST_TO_ADDR
121445: LD_INT 6
121447: PUSH
121448: FOR_TO
121449: IFFALSE 121554
// begin uc_nation := nation_nature ;
121451: LD_ADDR_OWVAR 21
121455: PUSH
121456: LD_INT 0
121458: ST_TO_ADDR
// uc_side := 0 ;
121459: LD_ADDR_OWVAR 20
121463: PUSH
121464: LD_INT 0
121466: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
121467: LD_ADDR_OWVAR 29
121471: PUSH
121472: LD_INT 12
121474: PUSH
121475: LD_INT 12
121477: PUSH
121478: EMPTY
121479: LIST
121480: LIST
121481: ST_TO_ADDR
// hc_agressivity := 20 ;
121482: LD_ADDR_OWVAR 35
121486: PUSH
121487: LD_INT 20
121489: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
121490: LD_ADDR_OWVAR 28
121494: PUSH
121495: LD_INT 17
121497: ST_TO_ADDR
// hc_gallery :=  ;
121498: LD_ADDR_OWVAR 33
121502: PUSH
121503: LD_STRING 
121505: ST_TO_ADDR
// hc_name :=  ;
121506: LD_ADDR_OWVAR 26
121510: PUSH
121511: LD_STRING 
121513: ST_TO_ADDR
// un := CreateHuman ;
121514: LD_ADDR_VAR 0 2
121518: PUSH
121519: CALL_OW 44
121523: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
121524: LD_VAR 0 2
121528: PPUSH
121529: LD_INT 1
121531: PPUSH
121532: CALL_OW 51
// tmp := tmp ^ un ;
121536: LD_ADDR_VAR 0 3
121540: PUSH
121541: LD_VAR 0 3
121545: PUSH
121546: LD_VAR 0 2
121550: ADD
121551: ST_TO_ADDR
// end ;
121552: GO 121448
121554: POP
121555: POP
// repeat wait ( 0 0$1 ) ;
121556: LD_INT 35
121558: PPUSH
121559: CALL_OW 67
// for un in tmp do
121563: LD_ADDR_VAR 0 2
121567: PUSH
121568: LD_VAR 0 3
121572: PUSH
121573: FOR_IN
121574: IFFALSE 121648
// begin if IsDead ( un ) then
121576: LD_VAR 0 2
121580: PPUSH
121581: CALL_OW 301
121585: IFFALSE 121605
// begin tmp := tmp diff un ;
121587: LD_ADDR_VAR 0 3
121591: PUSH
121592: LD_VAR 0 3
121596: PUSH
121597: LD_VAR 0 2
121601: DIFF
121602: ST_TO_ADDR
// continue ;
121603: GO 121573
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
121605: LD_VAR 0 2
121609: PPUSH
121610: LD_INT 3
121612: PUSH
121613: LD_INT 22
121615: PUSH
121616: LD_INT 0
121618: PUSH
121619: EMPTY
121620: LIST
121621: LIST
121622: PUSH
121623: EMPTY
121624: LIST
121625: LIST
121626: PPUSH
121627: CALL_OW 69
121631: PPUSH
121632: LD_VAR 0 2
121636: PPUSH
121637: CALL_OW 74
121641: PPUSH
121642: CALL_OW 115
// end ;
121646: GO 121573
121648: POP
121649: POP
// until not tmp ;
121650: LD_VAR 0 3
121654: NOT
121655: IFFALSE 121556
// end ;
121657: PPOPN 3
121659: END
// every 0 0$1 trigger StreamModeActive and sTroll do
121660: LD_EXP 148
121664: PUSH
121665: LD_EXP 173
121669: AND
121670: IFFALSE 121724
121672: GO 121674
121674: DISABLE
// begin ToLua ( displayTroll(); ) ;
121675: LD_STRING displayTroll();
121677: PPUSH
121678: CALL_OW 559
// wait ( 3 3$00 ) ;
121682: LD_INT 6300
121684: PPUSH
121685: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121689: LD_STRING hideTroll();
121691: PPUSH
121692: CALL_OW 559
// wait ( 1 1$00 ) ;
121696: LD_INT 2100
121698: PPUSH
121699: CALL_OW 67
// ToLua ( displayTroll(); ) ;
121703: LD_STRING displayTroll();
121705: PPUSH
121706: CALL_OW 559
// wait ( 1 1$00 ) ;
121710: LD_INT 2100
121712: PPUSH
121713: CALL_OW 67
// ToLua ( hideTroll(); ) ;
121717: LD_STRING hideTroll();
121719: PPUSH
121720: CALL_OW 559
// end ;
121724: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
121725: LD_EXP 148
121729: PUSH
121730: LD_EXP 174
121734: AND
121735: IFFALSE 121798
121737: GO 121739
121739: DISABLE
121740: LD_INT 0
121742: PPUSH
// begin p := 0 ;
121743: LD_ADDR_VAR 0 1
121747: PUSH
121748: LD_INT 0
121750: ST_TO_ADDR
// repeat game_speed := 1 ;
121751: LD_ADDR_OWVAR 65
121755: PUSH
121756: LD_INT 1
121758: ST_TO_ADDR
// wait ( 0 0$1 ) ;
121759: LD_INT 35
121761: PPUSH
121762: CALL_OW 67
// p := p + 1 ;
121766: LD_ADDR_VAR 0 1
121770: PUSH
121771: LD_VAR 0 1
121775: PUSH
121776: LD_INT 1
121778: PLUS
121779: ST_TO_ADDR
// until p >= 60 ;
121780: LD_VAR 0 1
121784: PUSH
121785: LD_INT 60
121787: GREATEREQUAL
121788: IFFALSE 121751
// game_speed := 4 ;
121790: LD_ADDR_OWVAR 65
121794: PUSH
121795: LD_INT 4
121797: ST_TO_ADDR
// end ;
121798: PPOPN 1
121800: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
121801: LD_EXP 148
121805: PUSH
121806: LD_EXP 175
121810: AND
121811: IFFALSE 121957
121813: GO 121815
121815: DISABLE
121816: LD_INT 0
121818: PPUSH
121819: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121820: LD_ADDR_VAR 0 1
121824: PUSH
121825: LD_INT 22
121827: PUSH
121828: LD_OWVAR 2
121832: PUSH
121833: EMPTY
121834: LIST
121835: LIST
121836: PUSH
121837: LD_INT 2
121839: PUSH
121840: LD_INT 30
121842: PUSH
121843: LD_INT 0
121845: PUSH
121846: EMPTY
121847: LIST
121848: LIST
121849: PUSH
121850: LD_INT 30
121852: PUSH
121853: LD_INT 1
121855: PUSH
121856: EMPTY
121857: LIST
121858: LIST
121859: PUSH
121860: EMPTY
121861: LIST
121862: LIST
121863: LIST
121864: PUSH
121865: EMPTY
121866: LIST
121867: LIST
121868: PPUSH
121869: CALL_OW 69
121873: ST_TO_ADDR
// if not depot then
121874: LD_VAR 0 1
121878: NOT
121879: IFFALSE 121883
// exit ;
121881: GO 121957
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121883: LD_ADDR_VAR 0 2
121887: PUSH
121888: LD_VAR 0 1
121892: PUSH
121893: LD_INT 1
121895: PPUSH
121896: LD_VAR 0 1
121900: PPUSH
121901: CALL_OW 12
121905: ARRAY
121906: PPUSH
121907: CALL_OW 274
121911: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121912: LD_VAR 0 2
121916: PPUSH
121917: LD_INT 1
121919: PPUSH
121920: LD_INT 0
121922: PPUSH
121923: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121927: LD_VAR 0 2
121931: PPUSH
121932: LD_INT 2
121934: PPUSH
121935: LD_INT 0
121937: PPUSH
121938: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121942: LD_VAR 0 2
121946: PPUSH
121947: LD_INT 3
121949: PPUSH
121950: LD_INT 0
121952: PPUSH
121953: CALL_OW 277
// end ;
121957: PPOPN 2
121959: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121960: LD_EXP 148
121964: PUSH
121965: LD_EXP 176
121969: AND
121970: IFFALSE 122067
121972: GO 121974
121974: DISABLE
121975: LD_INT 0
121977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121978: LD_ADDR_VAR 0 1
121982: PUSH
121983: LD_INT 22
121985: PUSH
121986: LD_OWVAR 2
121990: PUSH
121991: EMPTY
121992: LIST
121993: LIST
121994: PUSH
121995: LD_INT 21
121997: PUSH
121998: LD_INT 1
122000: PUSH
122001: EMPTY
122002: LIST
122003: LIST
122004: PUSH
122005: LD_INT 3
122007: PUSH
122008: LD_INT 23
122010: PUSH
122011: LD_INT 0
122013: PUSH
122014: EMPTY
122015: LIST
122016: LIST
122017: PUSH
122018: EMPTY
122019: LIST
122020: LIST
122021: PUSH
122022: EMPTY
122023: LIST
122024: LIST
122025: LIST
122026: PPUSH
122027: CALL_OW 69
122031: ST_TO_ADDR
// if not tmp then
122032: LD_VAR 0 1
122036: NOT
122037: IFFALSE 122041
// exit ;
122039: GO 122067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
122041: LD_VAR 0 1
122045: PUSH
122046: LD_INT 1
122048: PPUSH
122049: LD_VAR 0 1
122053: PPUSH
122054: CALL_OW 12
122058: ARRAY
122059: PPUSH
122060: LD_INT 200
122062: PPUSH
122063: CALL_OW 234
// end ;
122067: PPOPN 1
122069: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
122070: LD_EXP 148
122074: PUSH
122075: LD_EXP 177
122079: AND
122080: IFFALSE 122159
122082: GO 122084
122084: DISABLE
122085: LD_INT 0
122087: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
122088: LD_ADDR_VAR 0 1
122092: PUSH
122093: LD_INT 22
122095: PUSH
122096: LD_OWVAR 2
122100: PUSH
122101: EMPTY
122102: LIST
122103: LIST
122104: PUSH
122105: LD_INT 21
122107: PUSH
122108: LD_INT 2
122110: PUSH
122111: EMPTY
122112: LIST
122113: LIST
122114: PUSH
122115: EMPTY
122116: LIST
122117: LIST
122118: PPUSH
122119: CALL_OW 69
122123: ST_TO_ADDR
// if not tmp then
122124: LD_VAR 0 1
122128: NOT
122129: IFFALSE 122133
// exit ;
122131: GO 122159
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
122133: LD_VAR 0 1
122137: PUSH
122138: LD_INT 1
122140: PPUSH
122141: LD_VAR 0 1
122145: PPUSH
122146: CALL_OW 12
122150: ARRAY
122151: PPUSH
122152: LD_INT 60
122154: PPUSH
122155: CALL_OW 234
// end ;
122159: PPOPN 1
122161: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
122162: LD_EXP 148
122166: PUSH
122167: LD_EXP 178
122171: AND
122172: IFFALSE 122271
122174: GO 122176
122176: DISABLE
122177: LD_INT 0
122179: PPUSH
122180: PPUSH
// begin enable ;
122181: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
122182: LD_ADDR_VAR 0 1
122186: PUSH
122187: LD_INT 22
122189: PUSH
122190: LD_OWVAR 2
122194: PUSH
122195: EMPTY
122196: LIST
122197: LIST
122198: PUSH
122199: LD_INT 61
122201: PUSH
122202: EMPTY
122203: LIST
122204: PUSH
122205: LD_INT 33
122207: PUSH
122208: LD_INT 2
122210: PUSH
122211: EMPTY
122212: LIST
122213: LIST
122214: PUSH
122215: EMPTY
122216: LIST
122217: LIST
122218: LIST
122219: PPUSH
122220: CALL_OW 69
122224: ST_TO_ADDR
// if not tmp then
122225: LD_VAR 0 1
122229: NOT
122230: IFFALSE 122234
// exit ;
122232: GO 122271
// for i in tmp do
122234: LD_ADDR_VAR 0 2
122238: PUSH
122239: LD_VAR 0 1
122243: PUSH
122244: FOR_IN
122245: IFFALSE 122269
// if IsControledBy ( i ) then
122247: LD_VAR 0 2
122251: PPUSH
122252: CALL_OW 312
122256: IFFALSE 122267
// ComUnlink ( i ) ;
122258: LD_VAR 0 2
122262: PPUSH
122263: CALL_OW 136
122267: GO 122244
122269: POP
122270: POP
// end ;
122271: PPOPN 2
122273: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
122274: LD_EXP 148
122278: PUSH
122279: LD_EXP 179
122283: AND
122284: IFFALSE 122424
122286: GO 122288
122288: DISABLE
122289: LD_INT 0
122291: PPUSH
122292: PPUSH
// begin ToLua ( displayPowell(); ) ;
122293: LD_STRING displayPowell();
122295: PPUSH
122296: CALL_OW 559
// uc_side := 0 ;
122300: LD_ADDR_OWVAR 20
122304: PUSH
122305: LD_INT 0
122307: ST_TO_ADDR
// uc_nation := 2 ;
122308: LD_ADDR_OWVAR 21
122312: PUSH
122313: LD_INT 2
122315: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
122316: LD_ADDR_OWVAR 37
122320: PUSH
122321: LD_INT 14
122323: ST_TO_ADDR
// vc_engine := engine_siberite ;
122324: LD_ADDR_OWVAR 39
122328: PUSH
122329: LD_INT 3
122331: ST_TO_ADDR
// vc_control := control_apeman ;
122332: LD_ADDR_OWVAR 38
122336: PUSH
122337: LD_INT 5
122339: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
122340: LD_ADDR_OWVAR 40
122344: PUSH
122345: LD_INT 29
122347: ST_TO_ADDR
// un := CreateVehicle ;
122348: LD_ADDR_VAR 0 2
122352: PUSH
122353: CALL_OW 45
122357: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122358: LD_VAR 0 2
122362: PPUSH
122363: LD_INT 1
122365: PPUSH
122366: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122370: LD_INT 35
122372: PPUSH
122373: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122377: LD_VAR 0 2
122381: PPUSH
122382: LD_INT 22
122384: PUSH
122385: LD_OWVAR 2
122389: PUSH
122390: EMPTY
122391: LIST
122392: LIST
122393: PPUSH
122394: CALL_OW 69
122398: PPUSH
122399: LD_VAR 0 2
122403: PPUSH
122404: CALL_OW 74
122408: PPUSH
122409: CALL_OW 115
// until IsDead ( un ) ;
122413: LD_VAR 0 2
122417: PPUSH
122418: CALL_OW 301
122422: IFFALSE 122370
// end ;
122424: PPOPN 2
122426: END
// every 0 0$1 trigger StreamModeActive and sStu do
122427: LD_EXP 148
122431: PUSH
122432: LD_EXP 187
122436: AND
122437: IFFALSE 122453
122439: GO 122441
122441: DISABLE
// begin ToLua ( displayStucuk(); ) ;
122442: LD_STRING displayStucuk();
122444: PPUSH
122445: CALL_OW 559
// ResetFog ;
122449: CALL_OW 335
// end ;
122453: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
122454: LD_EXP 148
122458: PUSH
122459: LD_EXP 180
122463: AND
122464: IFFALSE 122605
122466: GO 122468
122468: DISABLE
122469: LD_INT 0
122471: PPUSH
122472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122473: LD_ADDR_VAR 0 2
122477: PUSH
122478: LD_INT 22
122480: PUSH
122481: LD_OWVAR 2
122485: PUSH
122486: EMPTY
122487: LIST
122488: LIST
122489: PUSH
122490: LD_INT 21
122492: PUSH
122493: LD_INT 1
122495: PUSH
122496: EMPTY
122497: LIST
122498: LIST
122499: PUSH
122500: EMPTY
122501: LIST
122502: LIST
122503: PPUSH
122504: CALL_OW 69
122508: ST_TO_ADDR
// if not tmp then
122509: LD_VAR 0 2
122513: NOT
122514: IFFALSE 122518
// exit ;
122516: GO 122605
// un := tmp [ rand ( 1 , tmp ) ] ;
122518: LD_ADDR_VAR 0 1
122522: PUSH
122523: LD_VAR 0 2
122527: PUSH
122528: LD_INT 1
122530: PPUSH
122531: LD_VAR 0 2
122535: PPUSH
122536: CALL_OW 12
122540: ARRAY
122541: ST_TO_ADDR
// SetSide ( un , 0 ) ;
122542: LD_VAR 0 1
122546: PPUSH
122547: LD_INT 0
122549: PPUSH
122550: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
122554: LD_VAR 0 1
122558: PPUSH
122559: LD_OWVAR 3
122563: PUSH
122564: LD_VAR 0 1
122568: DIFF
122569: PPUSH
122570: LD_VAR 0 1
122574: PPUSH
122575: CALL_OW 74
122579: PPUSH
122580: CALL_OW 115
// wait ( 0 0$20 ) ;
122584: LD_INT 700
122586: PPUSH
122587: CALL_OW 67
// SetSide ( un , your_side ) ;
122591: LD_VAR 0 1
122595: PPUSH
122596: LD_OWVAR 2
122600: PPUSH
122601: CALL_OW 235
// end ;
122605: PPOPN 2
122607: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
122608: LD_EXP 148
122612: PUSH
122613: LD_EXP 181
122617: AND
122618: IFFALSE 122724
122620: GO 122622
122622: DISABLE
122623: LD_INT 0
122625: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122626: LD_ADDR_VAR 0 1
122630: PUSH
122631: LD_INT 22
122633: PUSH
122634: LD_OWVAR 2
122638: PUSH
122639: EMPTY
122640: LIST
122641: LIST
122642: PUSH
122643: LD_INT 2
122645: PUSH
122646: LD_INT 30
122648: PUSH
122649: LD_INT 0
122651: PUSH
122652: EMPTY
122653: LIST
122654: LIST
122655: PUSH
122656: LD_INT 30
122658: PUSH
122659: LD_INT 1
122661: PUSH
122662: EMPTY
122663: LIST
122664: LIST
122665: PUSH
122666: EMPTY
122667: LIST
122668: LIST
122669: LIST
122670: PUSH
122671: EMPTY
122672: LIST
122673: LIST
122674: PPUSH
122675: CALL_OW 69
122679: ST_TO_ADDR
// if not depot then
122680: LD_VAR 0 1
122684: NOT
122685: IFFALSE 122689
// exit ;
122687: GO 122724
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
122689: LD_VAR 0 1
122693: PUSH
122694: LD_INT 1
122696: ARRAY
122697: PPUSH
122698: CALL_OW 250
122702: PPUSH
122703: LD_VAR 0 1
122707: PUSH
122708: LD_INT 1
122710: ARRAY
122711: PPUSH
122712: CALL_OW 251
122716: PPUSH
122717: LD_INT 70
122719: PPUSH
122720: CALL_OW 495
// end ;
122724: PPOPN 1
122726: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
122727: LD_EXP 148
122731: PUSH
122732: LD_EXP 182
122736: AND
122737: IFFALSE 122948
122739: GO 122741
122741: DISABLE
122742: LD_INT 0
122744: PPUSH
122745: PPUSH
122746: PPUSH
122747: PPUSH
122748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
122749: LD_ADDR_VAR 0 5
122753: PUSH
122754: LD_INT 22
122756: PUSH
122757: LD_OWVAR 2
122761: PUSH
122762: EMPTY
122763: LIST
122764: LIST
122765: PUSH
122766: LD_INT 21
122768: PUSH
122769: LD_INT 1
122771: PUSH
122772: EMPTY
122773: LIST
122774: LIST
122775: PUSH
122776: EMPTY
122777: LIST
122778: LIST
122779: PPUSH
122780: CALL_OW 69
122784: ST_TO_ADDR
// if not tmp then
122785: LD_VAR 0 5
122789: NOT
122790: IFFALSE 122794
// exit ;
122792: GO 122948
// for i in tmp do
122794: LD_ADDR_VAR 0 1
122798: PUSH
122799: LD_VAR 0 5
122803: PUSH
122804: FOR_IN
122805: IFFALSE 122946
// begin d := rand ( 0 , 5 ) ;
122807: LD_ADDR_VAR 0 4
122811: PUSH
122812: LD_INT 0
122814: PPUSH
122815: LD_INT 5
122817: PPUSH
122818: CALL_OW 12
122822: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
122823: LD_ADDR_VAR 0 2
122827: PUSH
122828: LD_VAR 0 1
122832: PPUSH
122833: CALL_OW 250
122837: PPUSH
122838: LD_VAR 0 4
122842: PPUSH
122843: LD_INT 3
122845: PPUSH
122846: LD_INT 12
122848: PPUSH
122849: CALL_OW 12
122853: PPUSH
122854: CALL_OW 272
122858: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
122859: LD_ADDR_VAR 0 3
122863: PUSH
122864: LD_VAR 0 1
122868: PPUSH
122869: CALL_OW 251
122873: PPUSH
122874: LD_VAR 0 4
122878: PPUSH
122879: LD_INT 3
122881: PPUSH
122882: LD_INT 12
122884: PPUSH
122885: CALL_OW 12
122889: PPUSH
122890: CALL_OW 273
122894: ST_TO_ADDR
// if ValidHex ( x , y ) then
122895: LD_VAR 0 2
122899: PPUSH
122900: LD_VAR 0 3
122904: PPUSH
122905: CALL_OW 488
122909: IFFALSE 122944
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122911: LD_VAR 0 1
122915: PPUSH
122916: LD_VAR 0 2
122920: PPUSH
122921: LD_VAR 0 3
122925: PPUSH
122926: LD_INT 3
122928: PPUSH
122929: LD_INT 6
122931: PPUSH
122932: CALL_OW 12
122936: PPUSH
122937: LD_INT 1
122939: PPUSH
122940: CALL_OW 483
// end ;
122944: GO 122804
122946: POP
122947: POP
// end ;
122948: PPOPN 5
122950: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122951: LD_EXP 148
122955: PUSH
122956: LD_EXP 183
122960: AND
122961: IFFALSE 123055
122963: GO 122965
122965: DISABLE
122966: LD_INT 0
122968: PPUSH
122969: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122970: LD_ADDR_VAR 0 2
122974: PUSH
122975: LD_INT 22
122977: PUSH
122978: LD_OWVAR 2
122982: PUSH
122983: EMPTY
122984: LIST
122985: LIST
122986: PUSH
122987: LD_INT 32
122989: PUSH
122990: LD_INT 1
122992: PUSH
122993: EMPTY
122994: LIST
122995: LIST
122996: PUSH
122997: LD_INT 21
122999: PUSH
123000: LD_INT 2
123002: PUSH
123003: EMPTY
123004: LIST
123005: LIST
123006: PUSH
123007: EMPTY
123008: LIST
123009: LIST
123010: LIST
123011: PPUSH
123012: CALL_OW 69
123016: ST_TO_ADDR
// if not tmp then
123017: LD_VAR 0 2
123021: NOT
123022: IFFALSE 123026
// exit ;
123024: GO 123055
// for i in tmp do
123026: LD_ADDR_VAR 0 1
123030: PUSH
123031: LD_VAR 0 2
123035: PUSH
123036: FOR_IN
123037: IFFALSE 123053
// SetFuel ( i , 0 ) ;
123039: LD_VAR 0 1
123043: PPUSH
123044: LD_INT 0
123046: PPUSH
123047: CALL_OW 240
123051: GO 123036
123053: POP
123054: POP
// end ;
123055: PPOPN 2
123057: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
123058: LD_EXP 148
123062: PUSH
123063: LD_EXP 184
123067: AND
123068: IFFALSE 123134
123070: GO 123072
123072: DISABLE
123073: LD_INT 0
123075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123076: LD_ADDR_VAR 0 1
123080: PUSH
123081: LD_INT 22
123083: PUSH
123084: LD_OWVAR 2
123088: PUSH
123089: EMPTY
123090: LIST
123091: LIST
123092: PUSH
123093: LD_INT 30
123095: PUSH
123096: LD_INT 29
123098: PUSH
123099: EMPTY
123100: LIST
123101: LIST
123102: PUSH
123103: EMPTY
123104: LIST
123105: LIST
123106: PPUSH
123107: CALL_OW 69
123111: ST_TO_ADDR
// if not tmp then
123112: LD_VAR 0 1
123116: NOT
123117: IFFALSE 123121
// exit ;
123119: GO 123134
// DestroyUnit ( tmp [ 1 ] ) ;
123121: LD_VAR 0 1
123125: PUSH
123126: LD_INT 1
123128: ARRAY
123129: PPUSH
123130: CALL_OW 65
// end ;
123134: PPOPN 1
123136: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
123137: LD_EXP 148
123141: PUSH
123142: LD_EXP 186
123146: AND
123147: IFFALSE 123276
123149: GO 123151
123151: DISABLE
123152: LD_INT 0
123154: PPUSH
// begin uc_side := 0 ;
123155: LD_ADDR_OWVAR 20
123159: PUSH
123160: LD_INT 0
123162: ST_TO_ADDR
// uc_nation := nation_arabian ;
123163: LD_ADDR_OWVAR 21
123167: PUSH
123168: LD_INT 2
123170: ST_TO_ADDR
// hc_gallery :=  ;
123171: LD_ADDR_OWVAR 33
123175: PUSH
123176: LD_STRING 
123178: ST_TO_ADDR
// hc_name :=  ;
123179: LD_ADDR_OWVAR 26
123183: PUSH
123184: LD_STRING 
123186: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
123187: LD_INT 1
123189: PPUSH
123190: LD_INT 11
123192: PPUSH
123193: LD_INT 10
123195: PPUSH
123196: CALL_OW 380
// un := CreateHuman ;
123200: LD_ADDR_VAR 0 1
123204: PUSH
123205: CALL_OW 44
123209: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123210: LD_VAR 0 1
123214: PPUSH
123215: LD_INT 1
123217: PPUSH
123218: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123222: LD_INT 35
123224: PPUSH
123225: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123229: LD_VAR 0 1
123233: PPUSH
123234: LD_INT 22
123236: PUSH
123237: LD_OWVAR 2
123241: PUSH
123242: EMPTY
123243: LIST
123244: LIST
123245: PPUSH
123246: CALL_OW 69
123250: PPUSH
123251: LD_VAR 0 1
123255: PPUSH
123256: CALL_OW 74
123260: PPUSH
123261: CALL_OW 115
// until IsDead ( un ) ;
123265: LD_VAR 0 1
123269: PPUSH
123270: CALL_OW 301
123274: IFFALSE 123222
// end ;
123276: PPOPN 1
123278: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
123279: LD_EXP 148
123283: PUSH
123284: LD_EXP 188
123288: AND
123289: IFFALSE 123301
123291: GO 123293
123293: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
123294: LD_STRING earthquake(getX(game), 0, 32)
123296: PPUSH
123297: CALL_OW 559
123301: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
123302: LD_EXP 148
123306: PUSH
123307: LD_EXP 189
123311: AND
123312: IFFALSE 123403
123314: GO 123316
123316: DISABLE
123317: LD_INT 0
123319: PPUSH
// begin enable ;
123320: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
123321: LD_ADDR_VAR 0 1
123325: PUSH
123326: LD_INT 22
123328: PUSH
123329: LD_OWVAR 2
123333: PUSH
123334: EMPTY
123335: LIST
123336: LIST
123337: PUSH
123338: LD_INT 21
123340: PUSH
123341: LD_INT 2
123343: PUSH
123344: EMPTY
123345: LIST
123346: LIST
123347: PUSH
123348: LD_INT 33
123350: PUSH
123351: LD_INT 3
123353: PUSH
123354: EMPTY
123355: LIST
123356: LIST
123357: PUSH
123358: EMPTY
123359: LIST
123360: LIST
123361: LIST
123362: PPUSH
123363: CALL_OW 69
123367: ST_TO_ADDR
// if not tmp then
123368: LD_VAR 0 1
123372: NOT
123373: IFFALSE 123377
// exit ;
123375: GO 123403
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123377: LD_VAR 0 1
123381: PUSH
123382: LD_INT 1
123384: PPUSH
123385: LD_VAR 0 1
123389: PPUSH
123390: CALL_OW 12
123394: ARRAY
123395: PPUSH
123396: LD_INT 1
123398: PPUSH
123399: CALL_OW 234
// end ;
123403: PPOPN 1
123405: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
123406: LD_EXP 148
123410: PUSH
123411: LD_EXP 190
123415: AND
123416: IFFALSE 123557
123418: GO 123420
123420: DISABLE
123421: LD_INT 0
123423: PPUSH
123424: PPUSH
123425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123426: LD_ADDR_VAR 0 3
123430: PUSH
123431: LD_INT 22
123433: PUSH
123434: LD_OWVAR 2
123438: PUSH
123439: EMPTY
123440: LIST
123441: LIST
123442: PUSH
123443: LD_INT 25
123445: PUSH
123446: LD_INT 1
123448: PUSH
123449: EMPTY
123450: LIST
123451: LIST
123452: PUSH
123453: EMPTY
123454: LIST
123455: LIST
123456: PPUSH
123457: CALL_OW 69
123461: ST_TO_ADDR
// if not tmp then
123462: LD_VAR 0 3
123466: NOT
123467: IFFALSE 123471
// exit ;
123469: GO 123557
// un := tmp [ rand ( 1 , tmp ) ] ;
123471: LD_ADDR_VAR 0 2
123475: PUSH
123476: LD_VAR 0 3
123480: PUSH
123481: LD_INT 1
123483: PPUSH
123484: LD_VAR 0 3
123488: PPUSH
123489: CALL_OW 12
123493: ARRAY
123494: ST_TO_ADDR
// if Crawls ( un ) then
123495: LD_VAR 0 2
123499: PPUSH
123500: CALL_OW 318
123504: IFFALSE 123515
// ComWalk ( un ) ;
123506: LD_VAR 0 2
123510: PPUSH
123511: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
123515: LD_VAR 0 2
123519: PPUSH
123520: LD_INT 9
123522: PPUSH
123523: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
123527: LD_INT 28
123529: PPUSH
123530: LD_OWVAR 2
123534: PPUSH
123535: LD_INT 2
123537: PPUSH
123538: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
123542: LD_INT 29
123544: PPUSH
123545: LD_OWVAR 2
123549: PPUSH
123550: LD_INT 2
123552: PPUSH
123553: CALL_OW 322
// end ;
123557: PPOPN 3
123559: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
123560: LD_EXP 148
123564: PUSH
123565: LD_EXP 191
123569: AND
123570: IFFALSE 123681
123572: GO 123574
123574: DISABLE
123575: LD_INT 0
123577: PPUSH
123578: PPUSH
123579: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123580: LD_ADDR_VAR 0 3
123584: PUSH
123585: LD_INT 22
123587: PUSH
123588: LD_OWVAR 2
123592: PUSH
123593: EMPTY
123594: LIST
123595: LIST
123596: PUSH
123597: LD_INT 25
123599: PUSH
123600: LD_INT 1
123602: PUSH
123603: EMPTY
123604: LIST
123605: LIST
123606: PUSH
123607: EMPTY
123608: LIST
123609: LIST
123610: PPUSH
123611: CALL_OW 69
123615: ST_TO_ADDR
// if not tmp then
123616: LD_VAR 0 3
123620: NOT
123621: IFFALSE 123625
// exit ;
123623: GO 123681
// un := tmp [ rand ( 1 , tmp ) ] ;
123625: LD_ADDR_VAR 0 2
123629: PUSH
123630: LD_VAR 0 3
123634: PUSH
123635: LD_INT 1
123637: PPUSH
123638: LD_VAR 0 3
123642: PPUSH
123643: CALL_OW 12
123647: ARRAY
123648: ST_TO_ADDR
// if Crawls ( un ) then
123649: LD_VAR 0 2
123653: PPUSH
123654: CALL_OW 318
123658: IFFALSE 123669
// ComWalk ( un ) ;
123660: LD_VAR 0 2
123664: PPUSH
123665: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123669: LD_VAR 0 2
123673: PPUSH
123674: LD_INT 8
123676: PPUSH
123677: CALL_OW 336
// end ;
123681: PPOPN 3
123683: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
123684: LD_EXP 148
123688: PUSH
123689: LD_EXP 192
123693: AND
123694: IFFALSE 123838
123696: GO 123698
123698: DISABLE
123699: LD_INT 0
123701: PPUSH
123702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
123703: LD_ADDR_VAR 0 2
123707: PUSH
123708: LD_INT 22
123710: PUSH
123711: LD_OWVAR 2
123715: PUSH
123716: EMPTY
123717: LIST
123718: LIST
123719: PUSH
123720: LD_INT 21
123722: PUSH
123723: LD_INT 2
123725: PUSH
123726: EMPTY
123727: LIST
123728: LIST
123729: PUSH
123730: LD_INT 2
123732: PUSH
123733: LD_INT 34
123735: PUSH
123736: LD_INT 12
123738: PUSH
123739: EMPTY
123740: LIST
123741: LIST
123742: PUSH
123743: LD_INT 34
123745: PUSH
123746: LD_INT 51
123748: PUSH
123749: EMPTY
123750: LIST
123751: LIST
123752: PUSH
123753: LD_INT 34
123755: PUSH
123756: LD_INT 32
123758: PUSH
123759: EMPTY
123760: LIST
123761: LIST
123762: PUSH
123763: EMPTY
123764: LIST
123765: LIST
123766: LIST
123767: LIST
123768: PUSH
123769: EMPTY
123770: LIST
123771: LIST
123772: LIST
123773: PPUSH
123774: CALL_OW 69
123778: ST_TO_ADDR
// if not tmp then
123779: LD_VAR 0 2
123783: NOT
123784: IFFALSE 123788
// exit ;
123786: GO 123838
// for i in tmp do
123788: LD_ADDR_VAR 0 1
123792: PUSH
123793: LD_VAR 0 2
123797: PUSH
123798: FOR_IN
123799: IFFALSE 123836
// if GetCargo ( i , mat_artifact ) = 0 then
123801: LD_VAR 0 1
123805: PPUSH
123806: LD_INT 4
123808: PPUSH
123809: CALL_OW 289
123813: PUSH
123814: LD_INT 0
123816: EQUAL
123817: IFFALSE 123834
// SetCargo ( i , mat_siberit , 100 ) ;
123819: LD_VAR 0 1
123823: PPUSH
123824: LD_INT 3
123826: PPUSH
123827: LD_INT 100
123829: PPUSH
123830: CALL_OW 290
123834: GO 123798
123836: POP
123837: POP
// end ;
123838: PPOPN 2
123840: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
123841: LD_EXP 148
123845: PUSH
123846: LD_EXP 193
123850: AND
123851: IFFALSE 124034
123853: GO 123855
123855: DISABLE
123856: LD_INT 0
123858: PPUSH
123859: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
123860: LD_ADDR_VAR 0 2
123864: PUSH
123865: LD_INT 22
123867: PUSH
123868: LD_OWVAR 2
123872: PUSH
123873: EMPTY
123874: LIST
123875: LIST
123876: PPUSH
123877: CALL_OW 69
123881: ST_TO_ADDR
// if not tmp then
123882: LD_VAR 0 2
123886: NOT
123887: IFFALSE 123891
// exit ;
123889: GO 124034
// for i := 1 to 2 do
123891: LD_ADDR_VAR 0 1
123895: PUSH
123896: DOUBLE
123897: LD_INT 1
123899: DEC
123900: ST_TO_ADDR
123901: LD_INT 2
123903: PUSH
123904: FOR_TO
123905: IFFALSE 124032
// begin uc_side := your_side ;
123907: LD_ADDR_OWVAR 20
123911: PUSH
123912: LD_OWVAR 2
123916: ST_TO_ADDR
// uc_nation := nation_american ;
123917: LD_ADDR_OWVAR 21
123921: PUSH
123922: LD_INT 1
123924: ST_TO_ADDR
// vc_chassis := us_morphling ;
123925: LD_ADDR_OWVAR 37
123929: PUSH
123930: LD_INT 5
123932: ST_TO_ADDR
// vc_engine := engine_siberite ;
123933: LD_ADDR_OWVAR 39
123937: PUSH
123938: LD_INT 3
123940: ST_TO_ADDR
// vc_control := control_computer ;
123941: LD_ADDR_OWVAR 38
123945: PUSH
123946: LD_INT 3
123948: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123949: LD_ADDR_OWVAR 40
123953: PUSH
123954: LD_INT 10
123956: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123957: LD_VAR 0 2
123961: PUSH
123962: LD_INT 1
123964: ARRAY
123965: PPUSH
123966: CALL_OW 310
123970: NOT
123971: IFFALSE 124018
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123973: CALL_OW 45
123977: PPUSH
123978: LD_VAR 0 2
123982: PUSH
123983: LD_INT 1
123985: ARRAY
123986: PPUSH
123987: CALL_OW 250
123991: PPUSH
123992: LD_VAR 0 2
123996: PUSH
123997: LD_INT 1
123999: ARRAY
124000: PPUSH
124001: CALL_OW 251
124005: PPUSH
124006: LD_INT 12
124008: PPUSH
124009: LD_INT 1
124011: PPUSH
124012: CALL_OW 50
124016: GO 124030
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
124018: CALL_OW 45
124022: PPUSH
124023: LD_INT 1
124025: PPUSH
124026: CALL_OW 51
// end ;
124030: GO 123904
124032: POP
124033: POP
// end ;
124034: PPOPN 2
124036: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
124037: LD_EXP 148
124041: PUSH
124042: LD_EXP 194
124046: AND
124047: IFFALSE 124269
124049: GO 124051
124051: DISABLE
124052: LD_INT 0
124054: PPUSH
124055: PPUSH
124056: PPUSH
124057: PPUSH
124058: PPUSH
124059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124060: LD_ADDR_VAR 0 6
124064: PUSH
124065: LD_INT 22
124067: PUSH
124068: LD_OWVAR 2
124072: PUSH
124073: EMPTY
124074: LIST
124075: LIST
124076: PUSH
124077: LD_INT 21
124079: PUSH
124080: LD_INT 1
124082: PUSH
124083: EMPTY
124084: LIST
124085: LIST
124086: PUSH
124087: LD_INT 3
124089: PUSH
124090: LD_INT 23
124092: PUSH
124093: LD_INT 0
124095: PUSH
124096: EMPTY
124097: LIST
124098: LIST
124099: PUSH
124100: EMPTY
124101: LIST
124102: LIST
124103: PUSH
124104: EMPTY
124105: LIST
124106: LIST
124107: LIST
124108: PPUSH
124109: CALL_OW 69
124113: ST_TO_ADDR
// if not tmp then
124114: LD_VAR 0 6
124118: NOT
124119: IFFALSE 124123
// exit ;
124121: GO 124269
// s1 := rand ( 1 , 4 ) ;
124123: LD_ADDR_VAR 0 2
124127: PUSH
124128: LD_INT 1
124130: PPUSH
124131: LD_INT 4
124133: PPUSH
124134: CALL_OW 12
124138: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
124139: LD_ADDR_VAR 0 4
124143: PUSH
124144: LD_VAR 0 6
124148: PUSH
124149: LD_INT 1
124151: ARRAY
124152: PPUSH
124153: LD_VAR 0 2
124157: PPUSH
124158: CALL_OW 259
124162: ST_TO_ADDR
// if s1 = 1 then
124163: LD_VAR 0 2
124167: PUSH
124168: LD_INT 1
124170: EQUAL
124171: IFFALSE 124191
// s2 := rand ( 2 , 4 ) else
124173: LD_ADDR_VAR 0 3
124177: PUSH
124178: LD_INT 2
124180: PPUSH
124181: LD_INT 4
124183: PPUSH
124184: CALL_OW 12
124188: ST_TO_ADDR
124189: GO 124199
// s2 := 1 ;
124191: LD_ADDR_VAR 0 3
124195: PUSH
124196: LD_INT 1
124198: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
124199: LD_ADDR_VAR 0 5
124203: PUSH
124204: LD_VAR 0 6
124208: PUSH
124209: LD_INT 1
124211: ARRAY
124212: PPUSH
124213: LD_VAR 0 3
124217: PPUSH
124218: CALL_OW 259
124222: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
124223: LD_VAR 0 6
124227: PUSH
124228: LD_INT 1
124230: ARRAY
124231: PPUSH
124232: LD_VAR 0 2
124236: PPUSH
124237: LD_VAR 0 5
124241: PPUSH
124242: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
124246: LD_VAR 0 6
124250: PUSH
124251: LD_INT 1
124253: ARRAY
124254: PPUSH
124255: LD_VAR 0 3
124259: PPUSH
124260: LD_VAR 0 4
124264: PPUSH
124265: CALL_OW 237
// end ;
124269: PPOPN 6
124271: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
124272: LD_EXP 148
124276: PUSH
124277: LD_EXP 195
124281: AND
124282: IFFALSE 124361
124284: GO 124286
124286: DISABLE
124287: LD_INT 0
124289: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
124290: LD_ADDR_VAR 0 1
124294: PUSH
124295: LD_INT 22
124297: PUSH
124298: LD_OWVAR 2
124302: PUSH
124303: EMPTY
124304: LIST
124305: LIST
124306: PUSH
124307: LD_INT 30
124309: PUSH
124310: LD_INT 3
124312: PUSH
124313: EMPTY
124314: LIST
124315: LIST
124316: PUSH
124317: EMPTY
124318: LIST
124319: LIST
124320: PPUSH
124321: CALL_OW 69
124325: ST_TO_ADDR
// if not tmp then
124326: LD_VAR 0 1
124330: NOT
124331: IFFALSE 124335
// exit ;
124333: GO 124361
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124335: LD_VAR 0 1
124339: PUSH
124340: LD_INT 1
124342: PPUSH
124343: LD_VAR 0 1
124347: PPUSH
124348: CALL_OW 12
124352: ARRAY
124353: PPUSH
124354: LD_INT 1
124356: PPUSH
124357: CALL_OW 234
// end ;
124361: PPOPN 1
124363: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
124364: LD_EXP 148
124368: PUSH
124369: LD_EXP 196
124373: AND
124374: IFFALSE 124486
124376: GO 124378
124378: DISABLE
124379: LD_INT 0
124381: PPUSH
124382: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
124383: LD_ADDR_VAR 0 2
124387: PUSH
124388: LD_INT 22
124390: PUSH
124391: LD_OWVAR 2
124395: PUSH
124396: EMPTY
124397: LIST
124398: LIST
124399: PUSH
124400: LD_INT 2
124402: PUSH
124403: LD_INT 30
124405: PUSH
124406: LD_INT 27
124408: PUSH
124409: EMPTY
124410: LIST
124411: LIST
124412: PUSH
124413: LD_INT 30
124415: PUSH
124416: LD_INT 26
124418: PUSH
124419: EMPTY
124420: LIST
124421: LIST
124422: PUSH
124423: LD_INT 30
124425: PUSH
124426: LD_INT 28
124428: PUSH
124429: EMPTY
124430: LIST
124431: LIST
124432: PUSH
124433: EMPTY
124434: LIST
124435: LIST
124436: LIST
124437: LIST
124438: PUSH
124439: EMPTY
124440: LIST
124441: LIST
124442: PPUSH
124443: CALL_OW 69
124447: ST_TO_ADDR
// if not tmp then
124448: LD_VAR 0 2
124452: NOT
124453: IFFALSE 124457
// exit ;
124455: GO 124486
// for i in tmp do
124457: LD_ADDR_VAR 0 1
124461: PUSH
124462: LD_VAR 0 2
124466: PUSH
124467: FOR_IN
124468: IFFALSE 124484
// SetLives ( i , 1 ) ;
124470: LD_VAR 0 1
124474: PPUSH
124475: LD_INT 1
124477: PPUSH
124478: CALL_OW 234
124482: GO 124467
124484: POP
124485: POP
// end ;
124486: PPOPN 2
124488: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
124489: LD_EXP 148
124493: PUSH
124494: LD_EXP 197
124498: AND
124499: IFFALSE 124786
124501: GO 124503
124503: DISABLE
124504: LD_INT 0
124506: PPUSH
124507: PPUSH
124508: PPUSH
// begin i := rand ( 1 , 7 ) ;
124509: LD_ADDR_VAR 0 1
124513: PUSH
124514: LD_INT 1
124516: PPUSH
124517: LD_INT 7
124519: PPUSH
124520: CALL_OW 12
124524: ST_TO_ADDR
// case i of 1 :
124525: LD_VAR 0 1
124529: PUSH
124530: LD_INT 1
124532: DOUBLE
124533: EQUAL
124534: IFTRUE 124538
124536: GO 124548
124538: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
124539: LD_STRING earthquake(getX(game), 0, 32)
124541: PPUSH
124542: CALL_OW 559
124546: GO 124786
124548: LD_INT 2
124550: DOUBLE
124551: EQUAL
124552: IFTRUE 124556
124554: GO 124570
124556: POP
// begin ToLua ( displayStucuk(); ) ;
124557: LD_STRING displayStucuk();
124559: PPUSH
124560: CALL_OW 559
// ResetFog ;
124564: CALL_OW 335
// end ; 3 :
124568: GO 124786
124570: LD_INT 3
124572: DOUBLE
124573: EQUAL
124574: IFTRUE 124578
124576: GO 124682
124578: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124579: LD_ADDR_VAR 0 2
124583: PUSH
124584: LD_INT 22
124586: PUSH
124587: LD_OWVAR 2
124591: PUSH
124592: EMPTY
124593: LIST
124594: LIST
124595: PUSH
124596: LD_INT 25
124598: PUSH
124599: LD_INT 1
124601: PUSH
124602: EMPTY
124603: LIST
124604: LIST
124605: PUSH
124606: EMPTY
124607: LIST
124608: LIST
124609: PPUSH
124610: CALL_OW 69
124614: ST_TO_ADDR
// if not tmp then
124615: LD_VAR 0 2
124619: NOT
124620: IFFALSE 124624
// exit ;
124622: GO 124786
// un := tmp [ rand ( 1 , tmp ) ] ;
124624: LD_ADDR_VAR 0 3
124628: PUSH
124629: LD_VAR 0 2
124633: PUSH
124634: LD_INT 1
124636: PPUSH
124637: LD_VAR 0 2
124641: PPUSH
124642: CALL_OW 12
124646: ARRAY
124647: ST_TO_ADDR
// if Crawls ( un ) then
124648: LD_VAR 0 3
124652: PPUSH
124653: CALL_OW 318
124657: IFFALSE 124668
// ComWalk ( un ) ;
124659: LD_VAR 0 3
124663: PPUSH
124664: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124668: LD_VAR 0 3
124672: PPUSH
124673: LD_INT 8
124675: PPUSH
124676: CALL_OW 336
// end ; 4 :
124680: GO 124786
124682: LD_INT 4
124684: DOUBLE
124685: EQUAL
124686: IFTRUE 124690
124688: GO 124764
124690: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124691: LD_ADDR_VAR 0 2
124695: PUSH
124696: LD_INT 22
124698: PUSH
124699: LD_OWVAR 2
124703: PUSH
124704: EMPTY
124705: LIST
124706: LIST
124707: PUSH
124708: LD_INT 30
124710: PUSH
124711: LD_INT 29
124713: PUSH
124714: EMPTY
124715: LIST
124716: LIST
124717: PUSH
124718: EMPTY
124719: LIST
124720: LIST
124721: PPUSH
124722: CALL_OW 69
124726: ST_TO_ADDR
// if not tmp then
124727: LD_VAR 0 2
124731: NOT
124732: IFFALSE 124736
// exit ;
124734: GO 124786
// CenterNowOnUnits ( tmp [ 1 ] ) ;
124736: LD_VAR 0 2
124740: PUSH
124741: LD_INT 1
124743: ARRAY
124744: PPUSH
124745: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
124749: LD_VAR 0 2
124753: PUSH
124754: LD_INT 1
124756: ARRAY
124757: PPUSH
124758: CALL_OW 65
// end ; 5 .. 7 :
124762: GO 124786
124764: LD_INT 5
124766: DOUBLE
124767: GREATEREQUAL
124768: IFFALSE 124776
124770: LD_INT 7
124772: DOUBLE
124773: LESSEQUAL
124774: IFTRUE 124778
124776: GO 124785
124778: POP
// StreamSibBomb ; end ;
124779: CALL 121023 0 0
124783: GO 124786
124785: POP
// end ;
124786: PPOPN 3
124788: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
124789: LD_EXP 148
124793: PUSH
124794: LD_EXP 198
124798: AND
124799: IFFALSE 124955
124801: GO 124803
124803: DISABLE
124804: LD_INT 0
124806: PPUSH
124807: PPUSH
124808: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
124809: LD_ADDR_VAR 0 2
124813: PUSH
124814: LD_INT 81
124816: PUSH
124817: LD_OWVAR 2
124821: PUSH
124822: EMPTY
124823: LIST
124824: LIST
124825: PUSH
124826: LD_INT 2
124828: PUSH
124829: LD_INT 21
124831: PUSH
124832: LD_INT 1
124834: PUSH
124835: EMPTY
124836: LIST
124837: LIST
124838: PUSH
124839: LD_INT 21
124841: PUSH
124842: LD_INT 2
124844: PUSH
124845: EMPTY
124846: LIST
124847: LIST
124848: PUSH
124849: EMPTY
124850: LIST
124851: LIST
124852: LIST
124853: PUSH
124854: EMPTY
124855: LIST
124856: LIST
124857: PPUSH
124858: CALL_OW 69
124862: ST_TO_ADDR
// if not tmp then
124863: LD_VAR 0 2
124867: NOT
124868: IFFALSE 124872
// exit ;
124870: GO 124955
// p := 0 ;
124872: LD_ADDR_VAR 0 3
124876: PUSH
124877: LD_INT 0
124879: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124880: LD_INT 35
124882: PPUSH
124883: CALL_OW 67
// p := p + 1 ;
124887: LD_ADDR_VAR 0 3
124891: PUSH
124892: LD_VAR 0 3
124896: PUSH
124897: LD_INT 1
124899: PLUS
124900: ST_TO_ADDR
// for i in tmp do
124901: LD_ADDR_VAR 0 1
124905: PUSH
124906: LD_VAR 0 2
124910: PUSH
124911: FOR_IN
124912: IFFALSE 124943
// if GetLives ( i ) < 1000 then
124914: LD_VAR 0 1
124918: PPUSH
124919: CALL_OW 256
124923: PUSH
124924: LD_INT 1000
124926: LESS
124927: IFFALSE 124941
// SetLives ( i , 1000 ) ;
124929: LD_VAR 0 1
124933: PPUSH
124934: LD_INT 1000
124936: PPUSH
124937: CALL_OW 234
124941: GO 124911
124943: POP
124944: POP
// until p > 20 ;
124945: LD_VAR 0 3
124949: PUSH
124950: LD_INT 20
124952: GREATER
124953: IFFALSE 124880
// end ;
124955: PPOPN 3
124957: END
// every 0 0$1 trigger StreamModeActive and sTime do
124958: LD_EXP 148
124962: PUSH
124963: LD_EXP 199
124967: AND
124968: IFFALSE 125003
124970: GO 124972
124972: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124973: LD_INT 28
124975: PPUSH
124976: LD_OWVAR 2
124980: PPUSH
124981: LD_INT 2
124983: PPUSH
124984: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124988: LD_INT 30
124990: PPUSH
124991: LD_OWVAR 2
124995: PPUSH
124996: LD_INT 2
124998: PPUSH
124999: CALL_OW 322
// end ;
125003: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
125004: LD_EXP 148
125008: PUSH
125009: LD_EXP 200
125013: AND
125014: IFFALSE 125135
125016: GO 125018
125018: DISABLE
125019: LD_INT 0
125021: PPUSH
125022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
125023: LD_ADDR_VAR 0 2
125027: PUSH
125028: LD_INT 22
125030: PUSH
125031: LD_OWVAR 2
125035: PUSH
125036: EMPTY
125037: LIST
125038: LIST
125039: PUSH
125040: LD_INT 21
125042: PUSH
125043: LD_INT 1
125045: PUSH
125046: EMPTY
125047: LIST
125048: LIST
125049: PUSH
125050: LD_INT 3
125052: PUSH
125053: LD_INT 23
125055: PUSH
125056: LD_INT 0
125058: PUSH
125059: EMPTY
125060: LIST
125061: LIST
125062: PUSH
125063: EMPTY
125064: LIST
125065: LIST
125066: PUSH
125067: EMPTY
125068: LIST
125069: LIST
125070: LIST
125071: PPUSH
125072: CALL_OW 69
125076: ST_TO_ADDR
// if not tmp then
125077: LD_VAR 0 2
125081: NOT
125082: IFFALSE 125086
// exit ;
125084: GO 125135
// for i in tmp do
125086: LD_ADDR_VAR 0 1
125090: PUSH
125091: LD_VAR 0 2
125095: PUSH
125096: FOR_IN
125097: IFFALSE 125133
// begin if Crawls ( i ) then
125099: LD_VAR 0 1
125103: PPUSH
125104: CALL_OW 318
125108: IFFALSE 125119
// ComWalk ( i ) ;
125110: LD_VAR 0 1
125114: PPUSH
125115: CALL_OW 138
// SetClass ( i , 2 ) ;
125119: LD_VAR 0 1
125123: PPUSH
125124: LD_INT 2
125126: PPUSH
125127: CALL_OW 336
// end ;
125131: GO 125096
125133: POP
125134: POP
// end ;
125135: PPOPN 2
125137: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
125138: LD_EXP 148
125142: PUSH
125143: LD_EXP 201
125147: AND
125148: IFFALSE 125436
125150: GO 125152
125152: DISABLE
125153: LD_INT 0
125155: PPUSH
125156: PPUSH
125157: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
125158: LD_OWVAR 2
125162: PPUSH
125163: LD_INT 9
125165: PPUSH
125166: LD_INT 1
125168: PPUSH
125169: LD_INT 1
125171: PPUSH
125172: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
125176: LD_INT 9
125178: PPUSH
125179: LD_OWVAR 2
125183: PPUSH
125184: CALL_OW 343
// uc_side := 9 ;
125188: LD_ADDR_OWVAR 20
125192: PUSH
125193: LD_INT 9
125195: ST_TO_ADDR
// uc_nation := 2 ;
125196: LD_ADDR_OWVAR 21
125200: PUSH
125201: LD_INT 2
125203: ST_TO_ADDR
// hc_name := Dark Warrior ;
125204: LD_ADDR_OWVAR 26
125208: PUSH
125209: LD_STRING Dark Warrior
125211: ST_TO_ADDR
// hc_gallery :=  ;
125212: LD_ADDR_OWVAR 33
125216: PUSH
125217: LD_STRING 
125219: ST_TO_ADDR
// hc_noskilllimit := true ;
125220: LD_ADDR_OWVAR 76
125224: PUSH
125225: LD_INT 1
125227: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
125228: LD_ADDR_OWVAR 31
125232: PUSH
125233: LD_INT 30
125235: PUSH
125236: LD_INT 30
125238: PUSH
125239: LD_INT 30
125241: PUSH
125242: LD_INT 30
125244: PUSH
125245: EMPTY
125246: LIST
125247: LIST
125248: LIST
125249: LIST
125250: ST_TO_ADDR
// un := CreateHuman ;
125251: LD_ADDR_VAR 0 3
125255: PUSH
125256: CALL_OW 44
125260: ST_TO_ADDR
// hc_noskilllimit := false ;
125261: LD_ADDR_OWVAR 76
125265: PUSH
125266: LD_INT 0
125268: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
125269: LD_VAR 0 3
125273: PPUSH
125274: LD_INT 1
125276: PPUSH
125277: CALL_OW 51
// ToLua ( playRanger() ) ;
125281: LD_STRING playRanger()
125283: PPUSH
125284: CALL_OW 559
// p := 0 ;
125288: LD_ADDR_VAR 0 2
125292: PUSH
125293: LD_INT 0
125295: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
125296: LD_INT 35
125298: PPUSH
125299: CALL_OW 67
// p := p + 1 ;
125303: LD_ADDR_VAR 0 2
125307: PUSH
125308: LD_VAR 0 2
125312: PUSH
125313: LD_INT 1
125315: PLUS
125316: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
125317: LD_VAR 0 3
125321: PPUSH
125322: CALL_OW 256
125326: PUSH
125327: LD_INT 1000
125329: LESS
125330: IFFALSE 125344
// SetLives ( un , 1000 ) ;
125332: LD_VAR 0 3
125336: PPUSH
125337: LD_INT 1000
125339: PPUSH
125340: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
125344: LD_VAR 0 3
125348: PPUSH
125349: LD_INT 81
125351: PUSH
125352: LD_OWVAR 2
125356: PUSH
125357: EMPTY
125358: LIST
125359: LIST
125360: PUSH
125361: LD_INT 91
125363: PUSH
125364: LD_VAR 0 3
125368: PUSH
125369: LD_INT 30
125371: PUSH
125372: EMPTY
125373: LIST
125374: LIST
125375: LIST
125376: PUSH
125377: EMPTY
125378: LIST
125379: LIST
125380: PPUSH
125381: CALL_OW 69
125385: PPUSH
125386: LD_VAR 0 3
125390: PPUSH
125391: CALL_OW 74
125395: PPUSH
125396: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
125400: LD_VAR 0 2
125404: PUSH
125405: LD_INT 80
125407: GREATER
125408: PUSH
125409: LD_VAR 0 3
125413: PPUSH
125414: CALL_OW 301
125418: OR
125419: IFFALSE 125296
// if un then
125421: LD_VAR 0 3
125425: IFFALSE 125436
// RemoveUnit ( un ) ;
125427: LD_VAR 0 3
125431: PPUSH
125432: CALL_OW 64
// end ;
125436: PPOPN 3
125438: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
125439: LD_EXP 202
125443: IFFALSE 125559
125445: GO 125447
125447: DISABLE
125448: LD_INT 0
125450: PPUSH
125451: PPUSH
125452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
125453: LD_ADDR_VAR 0 2
125457: PUSH
125458: LD_INT 81
125460: PUSH
125461: LD_OWVAR 2
125465: PUSH
125466: EMPTY
125467: LIST
125468: LIST
125469: PUSH
125470: LD_INT 21
125472: PUSH
125473: LD_INT 1
125475: PUSH
125476: EMPTY
125477: LIST
125478: LIST
125479: PUSH
125480: EMPTY
125481: LIST
125482: LIST
125483: PPUSH
125484: CALL_OW 69
125488: ST_TO_ADDR
// ToLua ( playComputer() ) ;
125489: LD_STRING playComputer()
125491: PPUSH
125492: CALL_OW 559
// if not tmp then
125496: LD_VAR 0 2
125500: NOT
125501: IFFALSE 125505
// exit ;
125503: GO 125559
// for i in tmp do
125505: LD_ADDR_VAR 0 1
125509: PUSH
125510: LD_VAR 0 2
125514: PUSH
125515: FOR_IN
125516: IFFALSE 125557
// for j := 1 to 4 do
125518: LD_ADDR_VAR 0 3
125522: PUSH
125523: DOUBLE
125524: LD_INT 1
125526: DEC
125527: ST_TO_ADDR
125528: LD_INT 4
125530: PUSH
125531: FOR_TO
125532: IFFALSE 125553
// SetSkill ( i , j , 10 ) ;
125534: LD_VAR 0 1
125538: PPUSH
125539: LD_VAR 0 3
125543: PPUSH
125544: LD_INT 10
125546: PPUSH
125547: CALL_OW 237
125551: GO 125531
125553: POP
125554: POP
125555: GO 125515
125557: POP
125558: POP
// end ;
125559: PPOPN 3
125561: END
// every 0 0$1 trigger s30 do var i , tmp ;
125562: LD_EXP 203
125566: IFFALSE 125635
125568: GO 125570
125570: DISABLE
125571: LD_INT 0
125573: PPUSH
125574: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125575: LD_ADDR_VAR 0 2
125579: PUSH
125580: LD_INT 22
125582: PUSH
125583: LD_OWVAR 2
125587: PUSH
125588: EMPTY
125589: LIST
125590: LIST
125591: PPUSH
125592: CALL_OW 69
125596: ST_TO_ADDR
// if not tmp then
125597: LD_VAR 0 2
125601: NOT
125602: IFFALSE 125606
// exit ;
125604: GO 125635
// for i in tmp do
125606: LD_ADDR_VAR 0 1
125610: PUSH
125611: LD_VAR 0 2
125615: PUSH
125616: FOR_IN
125617: IFFALSE 125633
// SetLives ( i , 300 ) ;
125619: LD_VAR 0 1
125623: PPUSH
125624: LD_INT 300
125626: PPUSH
125627: CALL_OW 234
125631: GO 125616
125633: POP
125634: POP
// end ;
125635: PPOPN 2
125637: END
// every 0 0$1 trigger s60 do var i , tmp ;
125638: LD_EXP 204
125642: IFFALSE 125711
125644: GO 125646
125646: DISABLE
125647: LD_INT 0
125649: PPUSH
125650: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125651: LD_ADDR_VAR 0 2
125655: PUSH
125656: LD_INT 22
125658: PUSH
125659: LD_OWVAR 2
125663: PUSH
125664: EMPTY
125665: LIST
125666: LIST
125667: PPUSH
125668: CALL_OW 69
125672: ST_TO_ADDR
// if not tmp then
125673: LD_VAR 0 2
125677: NOT
125678: IFFALSE 125682
// exit ;
125680: GO 125711
// for i in tmp do
125682: LD_ADDR_VAR 0 1
125686: PUSH
125687: LD_VAR 0 2
125691: PUSH
125692: FOR_IN
125693: IFFALSE 125709
// SetLives ( i , 600 ) ;
125695: LD_VAR 0 1
125699: PPUSH
125700: LD_INT 600
125702: PPUSH
125703: CALL_OW 234
125707: GO 125692
125709: POP
125710: POP
// end ;
125711: PPOPN 2
125713: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
125714: LD_INT 0
125716: PPUSH
// case cmd of 301 :
125717: LD_VAR 0 1
125721: PUSH
125722: LD_INT 301
125724: DOUBLE
125725: EQUAL
125726: IFTRUE 125730
125728: GO 125762
125730: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
125731: LD_VAR 0 6
125735: PPUSH
125736: LD_VAR 0 7
125740: PPUSH
125741: LD_VAR 0 8
125745: PPUSH
125746: LD_VAR 0 4
125750: PPUSH
125751: LD_VAR 0 5
125755: PPUSH
125756: CALL 126971 0 5
125760: GO 125883
125762: LD_INT 302
125764: DOUBLE
125765: EQUAL
125766: IFTRUE 125770
125768: GO 125807
125770: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
125771: LD_VAR 0 6
125775: PPUSH
125776: LD_VAR 0 7
125780: PPUSH
125781: LD_VAR 0 8
125785: PPUSH
125786: LD_VAR 0 9
125790: PPUSH
125791: LD_VAR 0 4
125795: PPUSH
125796: LD_VAR 0 5
125800: PPUSH
125801: CALL 127062 0 6
125805: GO 125883
125807: LD_INT 303
125809: DOUBLE
125810: EQUAL
125811: IFTRUE 125815
125813: GO 125852
125815: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
125816: LD_VAR 0 6
125820: PPUSH
125821: LD_VAR 0 7
125825: PPUSH
125826: LD_VAR 0 8
125830: PPUSH
125831: LD_VAR 0 9
125835: PPUSH
125836: LD_VAR 0 4
125840: PPUSH
125841: LD_VAR 0 5
125845: PPUSH
125846: CALL 125888 0 6
125850: GO 125883
125852: LD_INT 304
125854: DOUBLE
125855: EQUAL
125856: IFTRUE 125860
125858: GO 125882
125860: POP
// hHackTeleport ( unit , x , y ) ; end ;
125861: LD_VAR 0 2
125865: PPUSH
125866: LD_VAR 0 4
125870: PPUSH
125871: LD_VAR 0 5
125875: PPUSH
125876: CALL 127655 0 3
125880: GO 125883
125882: POP
// end ;
125883: LD_VAR 0 12
125887: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125888: LD_INT 0
125890: PPUSH
125891: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125892: LD_VAR 0 1
125896: PUSH
125897: LD_INT 1
125899: LESS
125900: PUSH
125901: LD_VAR 0 1
125905: PUSH
125906: LD_INT 3
125908: GREATER
125909: OR
125910: PUSH
125911: LD_VAR 0 5
125915: PPUSH
125916: LD_VAR 0 6
125920: PPUSH
125921: CALL_OW 428
125925: OR
125926: IFFALSE 125930
// exit ;
125928: GO 126658
// uc_side := your_side ;
125930: LD_ADDR_OWVAR 20
125934: PUSH
125935: LD_OWVAR 2
125939: ST_TO_ADDR
// uc_nation := nation ;
125940: LD_ADDR_OWVAR 21
125944: PUSH
125945: LD_VAR 0 1
125949: ST_TO_ADDR
// bc_level = 1 ;
125950: LD_ADDR_OWVAR 43
125954: PUSH
125955: LD_INT 1
125957: ST_TO_ADDR
// case btype of 1 :
125958: LD_VAR 0 2
125962: PUSH
125963: LD_INT 1
125965: DOUBLE
125966: EQUAL
125967: IFTRUE 125971
125969: GO 125982
125971: POP
// bc_type := b_depot ; 2 :
125972: LD_ADDR_OWVAR 42
125976: PUSH
125977: LD_INT 0
125979: ST_TO_ADDR
125980: GO 126602
125982: LD_INT 2
125984: DOUBLE
125985: EQUAL
125986: IFTRUE 125990
125988: GO 126001
125990: POP
// bc_type := b_warehouse ; 3 :
125991: LD_ADDR_OWVAR 42
125995: PUSH
125996: LD_INT 1
125998: ST_TO_ADDR
125999: GO 126602
126001: LD_INT 3
126003: DOUBLE
126004: EQUAL
126005: IFTRUE 126009
126007: GO 126020
126009: POP
// bc_type := b_lab ; 4 .. 9 :
126010: LD_ADDR_OWVAR 42
126014: PUSH
126015: LD_INT 6
126017: ST_TO_ADDR
126018: GO 126602
126020: LD_INT 4
126022: DOUBLE
126023: GREATEREQUAL
126024: IFFALSE 126032
126026: LD_INT 9
126028: DOUBLE
126029: LESSEQUAL
126030: IFTRUE 126034
126032: GO 126094
126034: POP
// begin bc_type := b_lab_half ;
126035: LD_ADDR_OWVAR 42
126039: PUSH
126040: LD_INT 7
126042: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
126043: LD_ADDR_OWVAR 44
126047: PUSH
126048: LD_INT 10
126050: PUSH
126051: LD_INT 11
126053: PUSH
126054: LD_INT 12
126056: PUSH
126057: LD_INT 15
126059: PUSH
126060: LD_INT 14
126062: PUSH
126063: LD_INT 13
126065: PUSH
126066: EMPTY
126067: LIST
126068: LIST
126069: LIST
126070: LIST
126071: LIST
126072: LIST
126073: PUSH
126074: LD_VAR 0 2
126078: PUSH
126079: LD_INT 3
126081: MINUS
126082: ARRAY
126083: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
126084: LD_ADDR_OWVAR 45
126088: PUSH
126089: LD_INT 9
126091: ST_TO_ADDR
// end ; 10 .. 13 :
126092: GO 126602
126094: LD_INT 10
126096: DOUBLE
126097: GREATEREQUAL
126098: IFFALSE 126106
126100: LD_INT 13
126102: DOUBLE
126103: LESSEQUAL
126104: IFTRUE 126108
126106: GO 126185
126108: POP
// begin bc_type := b_lab_full ;
126109: LD_ADDR_OWVAR 42
126113: PUSH
126114: LD_INT 8
126116: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
126117: LD_ADDR_OWVAR 44
126121: PUSH
126122: LD_INT 10
126124: PUSH
126125: LD_INT 12
126127: PUSH
126128: LD_INT 14
126130: PUSH
126131: LD_INT 13
126133: PUSH
126134: EMPTY
126135: LIST
126136: LIST
126137: LIST
126138: LIST
126139: PUSH
126140: LD_VAR 0 2
126144: PUSH
126145: LD_INT 9
126147: MINUS
126148: ARRAY
126149: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
126150: LD_ADDR_OWVAR 45
126154: PUSH
126155: LD_INT 11
126157: PUSH
126158: LD_INT 15
126160: PUSH
126161: LD_INT 12
126163: PUSH
126164: LD_INT 15
126166: PUSH
126167: EMPTY
126168: LIST
126169: LIST
126170: LIST
126171: LIST
126172: PUSH
126173: LD_VAR 0 2
126177: PUSH
126178: LD_INT 9
126180: MINUS
126181: ARRAY
126182: ST_TO_ADDR
// end ; 14 :
126183: GO 126602
126185: LD_INT 14
126187: DOUBLE
126188: EQUAL
126189: IFTRUE 126193
126191: GO 126204
126193: POP
// bc_type := b_workshop ; 15 :
126194: LD_ADDR_OWVAR 42
126198: PUSH
126199: LD_INT 2
126201: ST_TO_ADDR
126202: GO 126602
126204: LD_INT 15
126206: DOUBLE
126207: EQUAL
126208: IFTRUE 126212
126210: GO 126223
126212: POP
// bc_type := b_factory ; 16 :
126213: LD_ADDR_OWVAR 42
126217: PUSH
126218: LD_INT 3
126220: ST_TO_ADDR
126221: GO 126602
126223: LD_INT 16
126225: DOUBLE
126226: EQUAL
126227: IFTRUE 126231
126229: GO 126242
126231: POP
// bc_type := b_ext_gun ; 17 :
126232: LD_ADDR_OWVAR 42
126236: PUSH
126237: LD_INT 17
126239: ST_TO_ADDR
126240: GO 126602
126242: LD_INT 17
126244: DOUBLE
126245: EQUAL
126246: IFTRUE 126250
126248: GO 126278
126250: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
126251: LD_ADDR_OWVAR 42
126255: PUSH
126256: LD_INT 19
126258: PUSH
126259: LD_INT 23
126261: PUSH
126262: LD_INT 19
126264: PUSH
126265: EMPTY
126266: LIST
126267: LIST
126268: LIST
126269: PUSH
126270: LD_VAR 0 1
126274: ARRAY
126275: ST_TO_ADDR
126276: GO 126602
126278: LD_INT 18
126280: DOUBLE
126281: EQUAL
126282: IFTRUE 126286
126284: GO 126297
126286: POP
// bc_type := b_ext_radar ; 19 :
126287: LD_ADDR_OWVAR 42
126291: PUSH
126292: LD_INT 20
126294: ST_TO_ADDR
126295: GO 126602
126297: LD_INT 19
126299: DOUBLE
126300: EQUAL
126301: IFTRUE 126305
126303: GO 126316
126305: POP
// bc_type := b_ext_radio ; 20 :
126306: LD_ADDR_OWVAR 42
126310: PUSH
126311: LD_INT 22
126313: ST_TO_ADDR
126314: GO 126602
126316: LD_INT 20
126318: DOUBLE
126319: EQUAL
126320: IFTRUE 126324
126322: GO 126335
126324: POP
// bc_type := b_ext_siberium ; 21 :
126325: LD_ADDR_OWVAR 42
126329: PUSH
126330: LD_INT 21
126332: ST_TO_ADDR
126333: GO 126602
126335: LD_INT 21
126337: DOUBLE
126338: EQUAL
126339: IFTRUE 126343
126341: GO 126354
126343: POP
// bc_type := b_ext_computer ; 22 :
126344: LD_ADDR_OWVAR 42
126348: PUSH
126349: LD_INT 24
126351: ST_TO_ADDR
126352: GO 126602
126354: LD_INT 22
126356: DOUBLE
126357: EQUAL
126358: IFTRUE 126362
126360: GO 126373
126362: POP
// bc_type := b_ext_track ; 23 :
126363: LD_ADDR_OWVAR 42
126367: PUSH
126368: LD_INT 16
126370: ST_TO_ADDR
126371: GO 126602
126373: LD_INT 23
126375: DOUBLE
126376: EQUAL
126377: IFTRUE 126381
126379: GO 126392
126381: POP
// bc_type := b_ext_laser ; 24 :
126382: LD_ADDR_OWVAR 42
126386: PUSH
126387: LD_INT 25
126389: ST_TO_ADDR
126390: GO 126602
126392: LD_INT 24
126394: DOUBLE
126395: EQUAL
126396: IFTRUE 126400
126398: GO 126411
126400: POP
// bc_type := b_control_tower ; 25 :
126401: LD_ADDR_OWVAR 42
126405: PUSH
126406: LD_INT 36
126408: ST_TO_ADDR
126409: GO 126602
126411: LD_INT 25
126413: DOUBLE
126414: EQUAL
126415: IFTRUE 126419
126417: GO 126430
126419: POP
// bc_type := b_breastwork ; 26 :
126420: LD_ADDR_OWVAR 42
126424: PUSH
126425: LD_INT 31
126427: ST_TO_ADDR
126428: GO 126602
126430: LD_INT 26
126432: DOUBLE
126433: EQUAL
126434: IFTRUE 126438
126436: GO 126449
126438: POP
// bc_type := b_bunker ; 27 :
126439: LD_ADDR_OWVAR 42
126443: PUSH
126444: LD_INT 32
126446: ST_TO_ADDR
126447: GO 126602
126449: LD_INT 27
126451: DOUBLE
126452: EQUAL
126453: IFTRUE 126457
126455: GO 126468
126457: POP
// bc_type := b_turret ; 28 :
126458: LD_ADDR_OWVAR 42
126462: PUSH
126463: LD_INT 33
126465: ST_TO_ADDR
126466: GO 126602
126468: LD_INT 28
126470: DOUBLE
126471: EQUAL
126472: IFTRUE 126476
126474: GO 126487
126476: POP
// bc_type := b_armoury ; 29 :
126477: LD_ADDR_OWVAR 42
126481: PUSH
126482: LD_INT 4
126484: ST_TO_ADDR
126485: GO 126602
126487: LD_INT 29
126489: DOUBLE
126490: EQUAL
126491: IFTRUE 126495
126493: GO 126506
126495: POP
// bc_type := b_barracks ; 30 :
126496: LD_ADDR_OWVAR 42
126500: PUSH
126501: LD_INT 5
126503: ST_TO_ADDR
126504: GO 126602
126506: LD_INT 30
126508: DOUBLE
126509: EQUAL
126510: IFTRUE 126514
126512: GO 126525
126514: POP
// bc_type := b_solar_power ; 31 :
126515: LD_ADDR_OWVAR 42
126519: PUSH
126520: LD_INT 27
126522: ST_TO_ADDR
126523: GO 126602
126525: LD_INT 31
126527: DOUBLE
126528: EQUAL
126529: IFTRUE 126533
126531: GO 126544
126533: POP
// bc_type := b_oil_power ; 32 :
126534: LD_ADDR_OWVAR 42
126538: PUSH
126539: LD_INT 26
126541: ST_TO_ADDR
126542: GO 126602
126544: LD_INT 32
126546: DOUBLE
126547: EQUAL
126548: IFTRUE 126552
126550: GO 126563
126552: POP
// bc_type := b_siberite_power ; 33 :
126553: LD_ADDR_OWVAR 42
126557: PUSH
126558: LD_INT 28
126560: ST_TO_ADDR
126561: GO 126602
126563: LD_INT 33
126565: DOUBLE
126566: EQUAL
126567: IFTRUE 126571
126569: GO 126582
126571: POP
// bc_type := b_oil_mine ; 34 :
126572: LD_ADDR_OWVAR 42
126576: PUSH
126577: LD_INT 29
126579: ST_TO_ADDR
126580: GO 126602
126582: LD_INT 34
126584: DOUBLE
126585: EQUAL
126586: IFTRUE 126590
126588: GO 126601
126590: POP
// bc_type := b_siberite_mine ; end ;
126591: LD_ADDR_OWVAR 42
126595: PUSH
126596: LD_INT 30
126598: ST_TO_ADDR
126599: GO 126602
126601: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
126602: LD_ADDR_VAR 0 8
126606: PUSH
126607: LD_VAR 0 5
126611: PPUSH
126612: LD_VAR 0 6
126616: PPUSH
126617: LD_VAR 0 3
126621: PPUSH
126622: CALL_OW 47
126626: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
126627: LD_OWVAR 42
126631: PUSH
126632: LD_INT 32
126634: PUSH
126635: LD_INT 33
126637: PUSH
126638: EMPTY
126639: LIST
126640: LIST
126641: IN
126642: IFFALSE 126658
// PlaceWeaponTurret ( b , weapon ) ;
126644: LD_VAR 0 8
126648: PPUSH
126649: LD_VAR 0 4
126653: PPUSH
126654: CALL_OW 431
// end ;
126658: LD_VAR 0 7
126662: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
126663: LD_INT 0
126665: PPUSH
126666: PPUSH
126667: PPUSH
126668: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
126669: LD_ADDR_VAR 0 4
126673: PUSH
126674: LD_INT 22
126676: PUSH
126677: LD_OWVAR 2
126681: PUSH
126682: EMPTY
126683: LIST
126684: LIST
126685: PUSH
126686: LD_INT 2
126688: PUSH
126689: LD_INT 30
126691: PUSH
126692: LD_INT 0
126694: PUSH
126695: EMPTY
126696: LIST
126697: LIST
126698: PUSH
126699: LD_INT 30
126701: PUSH
126702: LD_INT 1
126704: PUSH
126705: EMPTY
126706: LIST
126707: LIST
126708: PUSH
126709: EMPTY
126710: LIST
126711: LIST
126712: LIST
126713: PUSH
126714: EMPTY
126715: LIST
126716: LIST
126717: PPUSH
126718: CALL_OW 69
126722: ST_TO_ADDR
// if not tmp then
126723: LD_VAR 0 4
126727: NOT
126728: IFFALSE 126732
// exit ;
126730: GO 126791
// for i in tmp do
126732: LD_ADDR_VAR 0 2
126736: PUSH
126737: LD_VAR 0 4
126741: PUSH
126742: FOR_IN
126743: IFFALSE 126789
// for j = 1 to 3 do
126745: LD_ADDR_VAR 0 3
126749: PUSH
126750: DOUBLE
126751: LD_INT 1
126753: DEC
126754: ST_TO_ADDR
126755: LD_INT 3
126757: PUSH
126758: FOR_TO
126759: IFFALSE 126785
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
126761: LD_VAR 0 2
126765: PPUSH
126766: CALL_OW 274
126770: PPUSH
126771: LD_VAR 0 3
126775: PPUSH
126776: LD_INT 99999
126778: PPUSH
126779: CALL_OW 277
126783: GO 126758
126785: POP
126786: POP
126787: GO 126742
126789: POP
126790: POP
// end ;
126791: LD_VAR 0 1
126795: RET
// export function hHackSetLevel10 ; var i , j ; begin
126796: LD_INT 0
126798: PPUSH
126799: PPUSH
126800: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126801: LD_ADDR_VAR 0 2
126805: PUSH
126806: LD_INT 21
126808: PUSH
126809: LD_INT 1
126811: PUSH
126812: EMPTY
126813: LIST
126814: LIST
126815: PPUSH
126816: CALL_OW 69
126820: PUSH
126821: FOR_IN
126822: IFFALSE 126874
// if IsSelected ( i ) then
126824: LD_VAR 0 2
126828: PPUSH
126829: CALL_OW 306
126833: IFFALSE 126872
// begin for j := 1 to 4 do
126835: LD_ADDR_VAR 0 3
126839: PUSH
126840: DOUBLE
126841: LD_INT 1
126843: DEC
126844: ST_TO_ADDR
126845: LD_INT 4
126847: PUSH
126848: FOR_TO
126849: IFFALSE 126870
// SetSkill ( i , j , 10 ) ;
126851: LD_VAR 0 2
126855: PPUSH
126856: LD_VAR 0 3
126860: PPUSH
126861: LD_INT 10
126863: PPUSH
126864: CALL_OW 237
126868: GO 126848
126870: POP
126871: POP
// end ;
126872: GO 126821
126874: POP
126875: POP
// end ;
126876: LD_VAR 0 1
126880: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126881: LD_INT 0
126883: PPUSH
126884: PPUSH
126885: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126886: LD_ADDR_VAR 0 2
126890: PUSH
126891: LD_INT 22
126893: PUSH
126894: LD_OWVAR 2
126898: PUSH
126899: EMPTY
126900: LIST
126901: LIST
126902: PUSH
126903: LD_INT 21
126905: PUSH
126906: LD_INT 1
126908: PUSH
126909: EMPTY
126910: LIST
126911: LIST
126912: PUSH
126913: EMPTY
126914: LIST
126915: LIST
126916: PPUSH
126917: CALL_OW 69
126921: PUSH
126922: FOR_IN
126923: IFFALSE 126964
// begin for j := 1 to 4 do
126925: LD_ADDR_VAR 0 3
126929: PUSH
126930: DOUBLE
126931: LD_INT 1
126933: DEC
126934: ST_TO_ADDR
126935: LD_INT 4
126937: PUSH
126938: FOR_TO
126939: IFFALSE 126960
// SetSkill ( i , j , 10 ) ;
126941: LD_VAR 0 2
126945: PPUSH
126946: LD_VAR 0 3
126950: PPUSH
126951: LD_INT 10
126953: PPUSH
126954: CALL_OW 237
126958: GO 126938
126960: POP
126961: POP
// end ;
126962: GO 126922
126964: POP
126965: POP
// end ;
126966: LD_VAR 0 1
126970: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126971: LD_INT 0
126973: PPUSH
// uc_side := your_side ;
126974: LD_ADDR_OWVAR 20
126978: PUSH
126979: LD_OWVAR 2
126983: ST_TO_ADDR
// uc_nation := nation ;
126984: LD_ADDR_OWVAR 21
126988: PUSH
126989: LD_VAR 0 1
126993: ST_TO_ADDR
// InitHc ;
126994: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126998: LD_INT 0
127000: PPUSH
127001: LD_VAR 0 2
127005: PPUSH
127006: LD_VAR 0 3
127010: PPUSH
127011: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
127015: LD_VAR 0 4
127019: PPUSH
127020: LD_VAR 0 5
127024: PPUSH
127025: CALL_OW 428
127029: PUSH
127030: LD_INT 0
127032: EQUAL
127033: IFFALSE 127057
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
127035: CALL_OW 44
127039: PPUSH
127040: LD_VAR 0 4
127044: PPUSH
127045: LD_VAR 0 5
127049: PPUSH
127050: LD_INT 1
127052: PPUSH
127053: CALL_OW 48
// end ;
127057: LD_VAR 0 6
127061: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
127062: LD_INT 0
127064: PPUSH
127065: PPUSH
// uc_side := your_side ;
127066: LD_ADDR_OWVAR 20
127070: PUSH
127071: LD_OWVAR 2
127075: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
127076: LD_VAR 0 1
127080: PUSH
127081: LD_INT 1
127083: PUSH
127084: LD_INT 2
127086: PUSH
127087: LD_INT 3
127089: PUSH
127090: LD_INT 4
127092: PUSH
127093: LD_INT 5
127095: PUSH
127096: EMPTY
127097: LIST
127098: LIST
127099: LIST
127100: LIST
127101: LIST
127102: IN
127103: IFFALSE 127115
// uc_nation := nation_american else
127105: LD_ADDR_OWVAR 21
127109: PUSH
127110: LD_INT 1
127112: ST_TO_ADDR
127113: GO 127158
// if chassis in [ 11 , 12 , 13 , 14 ] then
127115: LD_VAR 0 1
127119: PUSH
127120: LD_INT 11
127122: PUSH
127123: LD_INT 12
127125: PUSH
127126: LD_INT 13
127128: PUSH
127129: LD_INT 14
127131: PUSH
127132: EMPTY
127133: LIST
127134: LIST
127135: LIST
127136: LIST
127137: IN
127138: IFFALSE 127150
// uc_nation := nation_arabian else
127140: LD_ADDR_OWVAR 21
127144: PUSH
127145: LD_INT 2
127147: ST_TO_ADDR
127148: GO 127158
// uc_nation := nation_russian ;
127150: LD_ADDR_OWVAR 21
127154: PUSH
127155: LD_INT 3
127157: ST_TO_ADDR
// vc_chassis := chassis ;
127158: LD_ADDR_OWVAR 37
127162: PUSH
127163: LD_VAR 0 1
127167: ST_TO_ADDR
// vc_engine := engine ;
127168: LD_ADDR_OWVAR 39
127172: PUSH
127173: LD_VAR 0 2
127177: ST_TO_ADDR
// vc_control := control ;
127178: LD_ADDR_OWVAR 38
127182: PUSH
127183: LD_VAR 0 3
127187: ST_TO_ADDR
// vc_weapon := weapon ;
127188: LD_ADDR_OWVAR 40
127192: PUSH
127193: LD_VAR 0 4
127197: ST_TO_ADDR
// un := CreateVehicle ;
127198: LD_ADDR_VAR 0 8
127202: PUSH
127203: CALL_OW 45
127207: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
127208: LD_VAR 0 8
127212: PPUSH
127213: LD_INT 0
127215: PPUSH
127216: LD_INT 5
127218: PPUSH
127219: CALL_OW 12
127223: PPUSH
127224: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
127228: LD_VAR 0 8
127232: PPUSH
127233: LD_VAR 0 5
127237: PPUSH
127238: LD_VAR 0 6
127242: PPUSH
127243: LD_INT 1
127245: PPUSH
127246: CALL_OW 48
// end ;
127250: LD_VAR 0 7
127254: RET
// export hInvincible ; every 1 do
127255: GO 127257
127257: DISABLE
// hInvincible := [ ] ;
127258: LD_ADDR_EXP 205
127262: PUSH
127263: EMPTY
127264: ST_TO_ADDR
127265: END
// every 10 do var i ;
127266: GO 127268
127268: DISABLE
127269: LD_INT 0
127271: PPUSH
// begin enable ;
127272: ENABLE
// if not hInvincible then
127273: LD_EXP 205
127277: NOT
127278: IFFALSE 127282
// exit ;
127280: GO 127326
// for i in hInvincible do
127282: LD_ADDR_VAR 0 1
127286: PUSH
127287: LD_EXP 205
127291: PUSH
127292: FOR_IN
127293: IFFALSE 127324
// if GetLives ( i ) < 1000 then
127295: LD_VAR 0 1
127299: PPUSH
127300: CALL_OW 256
127304: PUSH
127305: LD_INT 1000
127307: LESS
127308: IFFALSE 127322
// SetLives ( i , 1000 ) ;
127310: LD_VAR 0 1
127314: PPUSH
127315: LD_INT 1000
127317: PPUSH
127318: CALL_OW 234
127322: GO 127292
127324: POP
127325: POP
// end ;
127326: PPOPN 1
127328: END
// export function hHackInvincible ; var i ; begin
127329: LD_INT 0
127331: PPUSH
127332: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
127333: LD_ADDR_VAR 0 2
127337: PUSH
127338: LD_INT 2
127340: PUSH
127341: LD_INT 21
127343: PUSH
127344: LD_INT 1
127346: PUSH
127347: EMPTY
127348: LIST
127349: LIST
127350: PUSH
127351: LD_INT 21
127353: PUSH
127354: LD_INT 2
127356: PUSH
127357: EMPTY
127358: LIST
127359: LIST
127360: PUSH
127361: EMPTY
127362: LIST
127363: LIST
127364: LIST
127365: PPUSH
127366: CALL_OW 69
127370: PUSH
127371: FOR_IN
127372: IFFALSE 127433
// if IsSelected ( i ) then
127374: LD_VAR 0 2
127378: PPUSH
127379: CALL_OW 306
127383: IFFALSE 127431
// begin if i in hInvincible then
127385: LD_VAR 0 2
127389: PUSH
127390: LD_EXP 205
127394: IN
127395: IFFALSE 127415
// hInvincible := hInvincible diff i else
127397: LD_ADDR_EXP 205
127401: PUSH
127402: LD_EXP 205
127406: PUSH
127407: LD_VAR 0 2
127411: DIFF
127412: ST_TO_ADDR
127413: GO 127431
// hInvincible := hInvincible union i ;
127415: LD_ADDR_EXP 205
127419: PUSH
127420: LD_EXP 205
127424: PUSH
127425: LD_VAR 0 2
127429: UNION
127430: ST_TO_ADDR
// end ;
127431: GO 127371
127433: POP
127434: POP
// end ;
127435: LD_VAR 0 1
127439: RET
// export function hHackInvisible ; var i , j ; begin
127440: LD_INT 0
127442: PPUSH
127443: PPUSH
127444: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
127445: LD_ADDR_VAR 0 2
127449: PUSH
127450: LD_INT 21
127452: PUSH
127453: LD_INT 1
127455: PUSH
127456: EMPTY
127457: LIST
127458: LIST
127459: PPUSH
127460: CALL_OW 69
127464: PUSH
127465: FOR_IN
127466: IFFALSE 127490
// if IsSelected ( i ) then
127468: LD_VAR 0 2
127472: PPUSH
127473: CALL_OW 306
127477: IFFALSE 127488
// ComForceInvisible ( i ) ;
127479: LD_VAR 0 2
127483: PPUSH
127484: CALL_OW 496
127488: GO 127465
127490: POP
127491: POP
// end ;
127492: LD_VAR 0 1
127496: RET
// export function hHackChangeYourSide ; begin
127497: LD_INT 0
127499: PPUSH
// if your_side = 8 then
127500: LD_OWVAR 2
127504: PUSH
127505: LD_INT 8
127507: EQUAL
127508: IFFALSE 127520
// your_side := 0 else
127510: LD_ADDR_OWVAR 2
127514: PUSH
127515: LD_INT 0
127517: ST_TO_ADDR
127518: GO 127534
// your_side := your_side + 1 ;
127520: LD_ADDR_OWVAR 2
127524: PUSH
127525: LD_OWVAR 2
127529: PUSH
127530: LD_INT 1
127532: PLUS
127533: ST_TO_ADDR
// end ;
127534: LD_VAR 0 1
127538: RET
// export function hHackChangeUnitSide ; var i , j ; begin
127539: LD_INT 0
127541: PPUSH
127542: PPUSH
127543: PPUSH
// for i in all_units do
127544: LD_ADDR_VAR 0 2
127548: PUSH
127549: LD_OWVAR 3
127553: PUSH
127554: FOR_IN
127555: IFFALSE 127633
// if IsSelected ( i ) then
127557: LD_VAR 0 2
127561: PPUSH
127562: CALL_OW 306
127566: IFFALSE 127631
// begin j := GetSide ( i ) ;
127568: LD_ADDR_VAR 0 3
127572: PUSH
127573: LD_VAR 0 2
127577: PPUSH
127578: CALL_OW 255
127582: ST_TO_ADDR
// if j = 8 then
127583: LD_VAR 0 3
127587: PUSH
127588: LD_INT 8
127590: EQUAL
127591: IFFALSE 127603
// j := 0 else
127593: LD_ADDR_VAR 0 3
127597: PUSH
127598: LD_INT 0
127600: ST_TO_ADDR
127601: GO 127617
// j := j + 1 ;
127603: LD_ADDR_VAR 0 3
127607: PUSH
127608: LD_VAR 0 3
127612: PUSH
127613: LD_INT 1
127615: PLUS
127616: ST_TO_ADDR
// SetSide ( i , j ) ;
127617: LD_VAR 0 2
127621: PPUSH
127622: LD_VAR 0 3
127626: PPUSH
127627: CALL_OW 235
// end ;
127631: GO 127554
127633: POP
127634: POP
// end ;
127635: LD_VAR 0 1
127639: RET
// export function hHackFog ; begin
127640: LD_INT 0
127642: PPUSH
// FogOff ( true ) ;
127643: LD_INT 1
127645: PPUSH
127646: CALL_OW 344
// end ;
127650: LD_VAR 0 1
127654: RET
// export function hHackTeleport ( unit , x , y ) ; begin
127655: LD_INT 0
127657: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
127658: LD_VAR 0 1
127662: PPUSH
127663: LD_VAR 0 2
127667: PPUSH
127668: LD_VAR 0 3
127672: PPUSH
127673: LD_INT 1
127675: PPUSH
127676: LD_INT 1
127678: PPUSH
127679: CALL_OW 483
// CenterOnXY ( x , y ) ;
127683: LD_VAR 0 2
127687: PPUSH
127688: LD_VAR 0 3
127692: PPUSH
127693: CALL_OW 84
// end ;
127697: LD_VAR 0 4
127701: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
127702: LD_INT 0
127704: PPUSH
127705: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
127706: LD_VAR 0 1
127710: NOT
127711: PUSH
127712: LD_VAR 0 2
127716: PPUSH
127717: LD_VAR 0 3
127721: PPUSH
127722: CALL_OW 488
127726: NOT
127727: OR
127728: PUSH
127729: LD_VAR 0 1
127733: PPUSH
127734: CALL_OW 266
127738: PUSH
127739: LD_INT 3
127741: NONEQUAL
127742: PUSH
127743: LD_VAR 0 1
127747: PPUSH
127748: CALL_OW 247
127752: PUSH
127753: LD_INT 1
127755: EQUAL
127756: NOT
127757: AND
127758: OR
127759: IFFALSE 127763
// exit ;
127761: GO 128045
// if GetType ( factory ) = unit_human then
127763: LD_VAR 0 1
127767: PPUSH
127768: CALL_OW 247
127772: PUSH
127773: LD_INT 1
127775: EQUAL
127776: IFFALSE 127793
// factory := IsInUnit ( factory ) ;
127778: LD_ADDR_VAR 0 1
127782: PUSH
127783: LD_VAR 0 1
127787: PPUSH
127788: CALL_OW 310
127792: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
127793: LD_VAR 0 1
127797: PPUSH
127798: CALL_OW 266
127802: PUSH
127803: LD_INT 3
127805: NONEQUAL
127806: IFFALSE 127810
// exit ;
127808: GO 128045
// for i := 1 to Count ( factoryWaypoints ) do
127810: LD_ADDR_VAR 0 5
127814: PUSH
127815: DOUBLE
127816: LD_INT 1
127818: DEC
127819: ST_TO_ADDR
127820: LD_EXP 206
127824: PPUSH
127825: CALL 72495 0 1
127829: PUSH
127830: FOR_TO
127831: IFFALSE 127993
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
127833: LD_VAR 0 2
127837: PPUSH
127838: LD_VAR 0 3
127842: PPUSH
127843: CALL_OW 428
127847: PUSH
127848: LD_EXP 206
127852: PUSH
127853: LD_VAR 0 5
127857: ARRAY
127858: PUSH
127859: LD_INT 2
127861: ARRAY
127862: EQUAL
127863: IFFALSE 127895
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127865: LD_ADDR_EXP 206
127869: PUSH
127870: LD_EXP 206
127874: PPUSH
127875: LD_VAR 0 5
127879: PPUSH
127880: CALL_OW 3
127884: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127885: CALL 128050 0 0
// exit ;
127889: POP
127890: POP
127891: GO 128045
// end else
127893: GO 127991
// if factory = factoryWaypoints [ i ] [ 2 ] then
127895: LD_VAR 0 1
127899: PUSH
127900: LD_EXP 206
127904: PUSH
127905: LD_VAR 0 5
127909: ARRAY
127910: PUSH
127911: LD_INT 2
127913: ARRAY
127914: EQUAL
127915: IFFALSE 127991
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
127917: LD_ADDR_EXP 206
127921: PUSH
127922: LD_EXP 206
127926: PPUSH
127927: LD_VAR 0 5
127931: PPUSH
127932: CALL_OW 3
127936: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127937: LD_ADDR_EXP 206
127941: PUSH
127942: LD_EXP 206
127946: PPUSH
127947: LD_VAR 0 1
127951: PPUSH
127952: CALL_OW 255
127956: PUSH
127957: LD_VAR 0 1
127961: PUSH
127962: LD_VAR 0 2
127966: PUSH
127967: LD_VAR 0 3
127971: PUSH
127972: EMPTY
127973: LIST
127974: LIST
127975: LIST
127976: LIST
127977: PPUSH
127978: CALL 108104 0 2
127982: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127983: CALL 128050 0 0
// exit ;
127987: POP
127988: POP
127989: GO 128045
// end ; end ;
127991: GO 127830
127993: POP
127994: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
127995: LD_ADDR_EXP 206
127999: PUSH
128000: LD_EXP 206
128004: PPUSH
128005: LD_VAR 0 1
128009: PPUSH
128010: CALL_OW 255
128014: PUSH
128015: LD_VAR 0 1
128019: PUSH
128020: LD_VAR 0 2
128024: PUSH
128025: LD_VAR 0 3
128029: PUSH
128030: EMPTY
128031: LIST
128032: LIST
128033: LIST
128034: LIST
128035: PPUSH
128036: CALL 108104 0 2
128040: ST_TO_ADDR
// UpdateFactoryWaypoints ;
128041: CALL 128050 0 0
// end ;
128045: LD_VAR 0 4
128049: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
128050: LD_INT 0
128052: PPUSH
128053: PPUSH
128054: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
128055: LD_STRING resetFactoryWaypoint();
128057: PPUSH
128058: CALL_OW 559
// if factoryWaypoints then
128062: LD_EXP 206
128066: IFFALSE 128187
// begin list := factoryWaypoints ;
128068: LD_ADDR_VAR 0 3
128072: PUSH
128073: LD_EXP 206
128077: ST_TO_ADDR
// for i := 1 to list do
128078: LD_ADDR_VAR 0 2
128082: PUSH
128083: DOUBLE
128084: LD_INT 1
128086: DEC
128087: ST_TO_ADDR
128088: LD_VAR 0 3
128092: PUSH
128093: FOR_TO
128094: IFFALSE 128185
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128096: LD_STRING setFactoryWaypointXY(
128098: PUSH
128099: LD_VAR 0 3
128103: PUSH
128104: LD_VAR 0 2
128108: ARRAY
128109: PUSH
128110: LD_INT 1
128112: ARRAY
128113: STR
128114: PUSH
128115: LD_STRING ,
128117: STR
128118: PUSH
128119: LD_VAR 0 3
128123: PUSH
128124: LD_VAR 0 2
128128: ARRAY
128129: PUSH
128130: LD_INT 2
128132: ARRAY
128133: STR
128134: PUSH
128135: LD_STRING ,
128137: STR
128138: PUSH
128139: LD_VAR 0 3
128143: PUSH
128144: LD_VAR 0 2
128148: ARRAY
128149: PUSH
128150: LD_INT 3
128152: ARRAY
128153: STR
128154: PUSH
128155: LD_STRING ,
128157: STR
128158: PUSH
128159: LD_VAR 0 3
128163: PUSH
128164: LD_VAR 0 2
128168: ARRAY
128169: PUSH
128170: LD_INT 4
128172: ARRAY
128173: STR
128174: PUSH
128175: LD_STRING )
128177: STR
128178: PPUSH
128179: CALL_OW 559
128183: GO 128093
128185: POP
128186: POP
// end ; end ;
128187: LD_VAR 0 1
128191: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
128192: LD_INT 0
128194: PPUSH
// if HexInfo ( x , y ) = warehouse then
128195: LD_VAR 0 2
128199: PPUSH
128200: LD_VAR 0 3
128204: PPUSH
128205: CALL_OW 428
128209: PUSH
128210: LD_VAR 0 1
128214: EQUAL
128215: IFFALSE 128242
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
128217: LD_ADDR_EXP 208
128221: PUSH
128222: LD_EXP 208
128226: PPUSH
128227: LD_VAR 0 1
128231: PPUSH
128232: LD_INT 0
128234: PPUSH
128235: CALL_OW 1
128239: ST_TO_ADDR
128240: GO 128293
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
128242: LD_ADDR_EXP 208
128246: PUSH
128247: LD_EXP 208
128251: PPUSH
128252: LD_VAR 0 1
128256: PPUSH
128257: LD_VAR 0 1
128261: PPUSH
128262: CALL_OW 255
128266: PUSH
128267: LD_VAR 0 1
128271: PUSH
128272: LD_VAR 0 2
128276: PUSH
128277: LD_VAR 0 3
128281: PUSH
128282: EMPTY
128283: LIST
128284: LIST
128285: LIST
128286: LIST
128287: PPUSH
128288: CALL_OW 1
128292: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
128293: CALL 128302 0 0
// end ;
128297: LD_VAR 0 4
128301: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
128302: LD_INT 0
128304: PPUSH
128305: PPUSH
128306: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
128307: LD_STRING resetWarehouseGatheringPoints();
128309: PPUSH
128310: CALL_OW 559
// if warehouseGatheringPoints then
128314: LD_EXP 208
128318: IFFALSE 128444
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
128320: LD_ADDR_VAR 0 3
128324: PUSH
128325: LD_EXP 208
128329: PPUSH
128330: CALL 111872 0 1
128334: ST_TO_ADDR
// for i := 1 to list do
128335: LD_ADDR_VAR 0 2
128339: PUSH
128340: DOUBLE
128341: LD_INT 1
128343: DEC
128344: ST_TO_ADDR
128345: LD_VAR 0 3
128349: PUSH
128350: FOR_TO
128351: IFFALSE 128442
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
128353: LD_STRING setWarehouseGatheringPointXY(
128355: PUSH
128356: LD_VAR 0 3
128360: PUSH
128361: LD_VAR 0 2
128365: ARRAY
128366: PUSH
128367: LD_INT 1
128369: ARRAY
128370: STR
128371: PUSH
128372: LD_STRING ,
128374: STR
128375: PUSH
128376: LD_VAR 0 3
128380: PUSH
128381: LD_VAR 0 2
128385: ARRAY
128386: PUSH
128387: LD_INT 2
128389: ARRAY
128390: STR
128391: PUSH
128392: LD_STRING ,
128394: STR
128395: PUSH
128396: LD_VAR 0 3
128400: PUSH
128401: LD_VAR 0 2
128405: ARRAY
128406: PUSH
128407: LD_INT 3
128409: ARRAY
128410: STR
128411: PUSH
128412: LD_STRING ,
128414: STR
128415: PUSH
128416: LD_VAR 0 3
128420: PUSH
128421: LD_VAR 0 2
128425: ARRAY
128426: PUSH
128427: LD_INT 4
128429: ARRAY
128430: STR
128431: PUSH
128432: LD_STRING )
128434: STR
128435: PPUSH
128436: CALL_OW 559
128440: GO 128350
128442: POP
128443: POP
// end ; end ;
128444: LD_VAR 0 1
128448: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
128449: LD_EXP 208
128453: IFFALSE 129138
128455: GO 128457
128457: DISABLE
128458: LD_INT 0
128460: PPUSH
128461: PPUSH
128462: PPUSH
128463: PPUSH
128464: PPUSH
128465: PPUSH
128466: PPUSH
128467: PPUSH
128468: PPUSH
// begin enable ;
128469: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
128470: LD_ADDR_VAR 0 3
128474: PUSH
128475: LD_EXP 208
128479: PPUSH
128480: CALL 111872 0 1
128484: ST_TO_ADDR
// if not list then
128485: LD_VAR 0 3
128489: NOT
128490: IFFALSE 128494
// exit ;
128492: GO 129138
// for i := 1 to list do
128494: LD_ADDR_VAR 0 1
128498: PUSH
128499: DOUBLE
128500: LD_INT 1
128502: DEC
128503: ST_TO_ADDR
128504: LD_VAR 0 3
128508: PUSH
128509: FOR_TO
128510: IFFALSE 129136
// begin depot := list [ i ] [ 2 ] ;
128512: LD_ADDR_VAR 0 8
128516: PUSH
128517: LD_VAR 0 3
128521: PUSH
128522: LD_VAR 0 1
128526: ARRAY
128527: PUSH
128528: LD_INT 2
128530: ARRAY
128531: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
128532: LD_ADDR_VAR 0 5
128536: PUSH
128537: LD_VAR 0 3
128541: PUSH
128542: LD_VAR 0 1
128546: ARRAY
128547: PUSH
128548: LD_INT 1
128550: ARRAY
128551: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
128552: LD_VAR 0 8
128556: PPUSH
128557: CALL_OW 301
128561: PUSH
128562: LD_VAR 0 5
128566: PUSH
128567: LD_VAR 0 8
128571: PPUSH
128572: CALL_OW 255
128576: NONEQUAL
128577: OR
128578: IFFALSE 128607
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
128580: LD_ADDR_EXP 208
128584: PUSH
128585: LD_EXP 208
128589: PPUSH
128590: LD_VAR 0 8
128594: PPUSH
128595: LD_INT 0
128597: PPUSH
128598: CALL_OW 1
128602: ST_TO_ADDR
// exit ;
128603: POP
128604: POP
128605: GO 129138
// end ; x := list [ i ] [ 3 ] ;
128607: LD_ADDR_VAR 0 6
128611: PUSH
128612: LD_VAR 0 3
128616: PUSH
128617: LD_VAR 0 1
128621: ARRAY
128622: PUSH
128623: LD_INT 3
128625: ARRAY
128626: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
128627: LD_ADDR_VAR 0 7
128631: PUSH
128632: LD_VAR 0 3
128636: PUSH
128637: LD_VAR 0 1
128641: ARRAY
128642: PUSH
128643: LD_INT 4
128645: ARRAY
128646: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
128647: LD_ADDR_VAR 0 9
128651: PUSH
128652: LD_VAR 0 6
128656: PPUSH
128657: LD_VAR 0 7
128661: PPUSH
128662: LD_INT 16
128664: PPUSH
128665: CALL 110456 0 3
128669: ST_TO_ADDR
// if not cratesNearbyPoint then
128670: LD_VAR 0 9
128674: NOT
128675: IFFALSE 128681
// exit ;
128677: POP
128678: POP
128679: GO 129138
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
128681: LD_ADDR_VAR 0 4
128685: PUSH
128686: LD_INT 22
128688: PUSH
128689: LD_VAR 0 5
128693: PUSH
128694: EMPTY
128695: LIST
128696: LIST
128697: PUSH
128698: LD_INT 3
128700: PUSH
128701: LD_INT 60
128703: PUSH
128704: EMPTY
128705: LIST
128706: PUSH
128707: EMPTY
128708: LIST
128709: LIST
128710: PUSH
128711: LD_INT 91
128713: PUSH
128714: LD_VAR 0 8
128718: PUSH
128719: LD_INT 6
128721: PUSH
128722: EMPTY
128723: LIST
128724: LIST
128725: LIST
128726: PUSH
128727: LD_INT 2
128729: PUSH
128730: LD_INT 25
128732: PUSH
128733: LD_INT 2
128735: PUSH
128736: EMPTY
128737: LIST
128738: LIST
128739: PUSH
128740: LD_INT 25
128742: PUSH
128743: LD_INT 16
128745: PUSH
128746: EMPTY
128747: LIST
128748: LIST
128749: PUSH
128750: EMPTY
128751: LIST
128752: LIST
128753: LIST
128754: PUSH
128755: EMPTY
128756: LIST
128757: LIST
128758: LIST
128759: LIST
128760: PPUSH
128761: CALL_OW 69
128765: PUSH
128766: LD_VAR 0 8
128770: PPUSH
128771: CALL_OW 313
128775: PPUSH
128776: LD_INT 3
128778: PUSH
128779: LD_INT 60
128781: PUSH
128782: EMPTY
128783: LIST
128784: PUSH
128785: EMPTY
128786: LIST
128787: LIST
128788: PUSH
128789: LD_INT 2
128791: PUSH
128792: LD_INT 25
128794: PUSH
128795: LD_INT 2
128797: PUSH
128798: EMPTY
128799: LIST
128800: LIST
128801: PUSH
128802: LD_INT 25
128804: PUSH
128805: LD_INT 16
128807: PUSH
128808: EMPTY
128809: LIST
128810: LIST
128811: PUSH
128812: EMPTY
128813: LIST
128814: LIST
128815: LIST
128816: PUSH
128817: EMPTY
128818: LIST
128819: LIST
128820: PPUSH
128821: CALL_OW 72
128825: UNION
128826: ST_TO_ADDR
// if tmp then
128827: LD_VAR 0 4
128831: IFFALSE 128911
// begin tmp := ShrinkArray ( tmp , 3 ) ;
128833: LD_ADDR_VAR 0 4
128837: PUSH
128838: LD_VAR 0 4
128842: PPUSH
128843: LD_INT 3
128845: PPUSH
128846: CALL 108419 0 2
128850: ST_TO_ADDR
// for j in tmp do
128851: LD_ADDR_VAR 0 2
128855: PUSH
128856: LD_VAR 0 4
128860: PUSH
128861: FOR_IN
128862: IFFALSE 128905
// begin if IsInUnit ( j ) then
128864: LD_VAR 0 2
128868: PPUSH
128869: CALL_OW 310
128873: IFFALSE 128884
// ComExit ( j ) ;
128875: LD_VAR 0 2
128879: PPUSH
128880: CALL 108502 0 1
// AddComCollect ( j , x , y ) ;
128884: LD_VAR 0 2
128888: PPUSH
128889: LD_VAR 0 6
128893: PPUSH
128894: LD_VAR 0 7
128898: PPUSH
128899: CALL_OW 177
// end ;
128903: GO 128861
128905: POP
128906: POP
// exit ;
128907: POP
128908: POP
128909: GO 129138
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
128911: LD_ADDR_VAR 0 4
128915: PUSH
128916: LD_INT 22
128918: PUSH
128919: LD_VAR 0 5
128923: PUSH
128924: EMPTY
128925: LIST
128926: LIST
128927: PUSH
128928: LD_INT 91
128930: PUSH
128931: LD_VAR 0 8
128935: PUSH
128936: LD_INT 8
128938: PUSH
128939: EMPTY
128940: LIST
128941: LIST
128942: LIST
128943: PUSH
128944: LD_INT 2
128946: PUSH
128947: LD_INT 34
128949: PUSH
128950: LD_INT 12
128952: PUSH
128953: EMPTY
128954: LIST
128955: LIST
128956: PUSH
128957: LD_INT 34
128959: PUSH
128960: LD_INT 51
128962: PUSH
128963: EMPTY
128964: LIST
128965: LIST
128966: PUSH
128967: LD_INT 34
128969: PUSH
128970: LD_INT 32
128972: PUSH
128973: EMPTY
128974: LIST
128975: LIST
128976: PUSH
128977: LD_INT 34
128979: PUSH
128980: LD_INT 89
128982: PUSH
128983: EMPTY
128984: LIST
128985: LIST
128986: PUSH
128987: EMPTY
128988: LIST
128989: LIST
128990: LIST
128991: LIST
128992: LIST
128993: PUSH
128994: EMPTY
128995: LIST
128996: LIST
128997: LIST
128998: PPUSH
128999: CALL_OW 69
129003: ST_TO_ADDR
// if tmp then
129004: LD_VAR 0 4
129008: IFFALSE 129134
// begin for j in tmp do
129010: LD_ADDR_VAR 0 2
129014: PUSH
129015: LD_VAR 0 4
129019: PUSH
129020: FOR_IN
129021: IFFALSE 129132
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
129023: LD_VAR 0 2
129027: PPUSH
129028: CALL_OW 262
129032: PUSH
129033: LD_INT 3
129035: EQUAL
129036: PUSH
129037: LD_VAR 0 2
129041: PPUSH
129042: CALL_OW 261
129046: PUSH
129047: LD_INT 20
129049: GREATER
129050: OR
129051: PUSH
129052: LD_VAR 0 2
129056: PPUSH
129057: CALL_OW 314
129061: NOT
129062: AND
129063: PUSH
129064: LD_VAR 0 2
129068: PPUSH
129069: CALL_OW 263
129073: PUSH
129074: LD_INT 1
129076: NONEQUAL
129077: PUSH
129078: LD_VAR 0 2
129082: PPUSH
129083: CALL_OW 311
129087: OR
129088: AND
129089: IFFALSE 129130
// begin ComCollect ( j , x , y ) ;
129091: LD_VAR 0 2
129095: PPUSH
129096: LD_VAR 0 6
129100: PPUSH
129101: LD_VAR 0 7
129105: PPUSH
129106: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
129110: LD_VAR 0 2
129114: PPUSH
129115: LD_VAR 0 8
129119: PPUSH
129120: CALL_OW 172
// exit ;
129124: POP
129125: POP
129126: POP
129127: POP
129128: GO 129138
// end ;
129130: GO 129020
129132: POP
129133: POP
// end ; end ;
129134: GO 128509
129136: POP
129137: POP
// end ; end_of_file
129138: PPOPN 9
129140: END
// export function SOS_UnitDestroyed ( un ) ; begin
129141: LD_INT 0
129143: PPUSH
// ComRadiation ( un ) ;
129144: LD_VAR 0 1
129148: PPUSH
129149: CALL 130180 0 1
// end ;
129153: LD_VAR 0 2
129157: RET
// export function SOS_UnitKamikazed ( un ) ; begin
129158: LD_INT 0
129160: PPUSH
// ComRadiation ( un ) ;
129161: LD_VAR 0 1
129165: PPUSH
129166: CALL 130180 0 1
// end ;
129170: LD_VAR 0 2
129174: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
129175: LD_INT 0
129177: PPUSH
// end ;
129178: LD_VAR 0 4
129182: RET
// export function SOS_Command ( cmd ) ; begin
129183: LD_INT 0
129185: PPUSH
// end ;
129186: LD_VAR 0 2
129190: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
129191: LD_INT 0
129193: PPUSH
// end ;
129194: LD_VAR 0 6
129198: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
129199: LD_INT 0
129201: PPUSH
129202: PPUSH
129203: PPUSH
129204: PPUSH
// if not vehicle or not factory then
129205: LD_VAR 0 1
129209: NOT
129210: PUSH
129211: LD_VAR 0 2
129215: NOT
129216: OR
129217: IFFALSE 129221
// exit ;
129219: GO 129771
// if not factoryWaypoints then
129221: LD_EXP 206
129225: NOT
129226: IFFALSE 129230
// exit ;
129228: GO 129771
// for i := 1 to Count ( factoryWaypoints ) do
129230: LD_ADDR_VAR 0 4
129234: PUSH
129235: DOUBLE
129236: LD_INT 1
129238: DEC
129239: ST_TO_ADDR
129240: LD_EXP 206
129244: PPUSH
129245: CALL 72495 0 1
129249: PUSH
129250: FOR_TO
129251: IFFALSE 129769
// if factoryWaypoints [ i ] [ 2 ] = factory then
129253: LD_EXP 206
129257: PUSH
129258: LD_VAR 0 4
129262: ARRAY
129263: PUSH
129264: LD_INT 2
129266: ARRAY
129267: PUSH
129268: LD_VAR 0 2
129272: EQUAL
129273: IFFALSE 129767
// begin if GetControl ( vehicle ) = control_manual then
129275: LD_VAR 0 1
129279: PPUSH
129280: CALL_OW 263
129284: PUSH
129285: LD_INT 1
129287: EQUAL
129288: IFFALSE 129650
// begin driver := IsDrivenBy ( vehicle ) ;
129290: LD_ADDR_VAR 0 5
129294: PUSH
129295: LD_VAR 0 1
129299: PPUSH
129300: CALL_OW 311
129304: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
129305: LD_VAR 0 5
129309: PUSH
129310: LD_EXP 207
129314: IN
129315: PUSH
129316: LD_VAR 0 1
129320: PUSH
129321: LD_EXP 207
129325: IN
129326: OR
129327: IFFALSE 129333
// exit ;
129329: POP
129330: POP
129331: GO 129771
// if not HasTask ( driver ) then
129333: LD_VAR 0 5
129337: PPUSH
129338: CALL_OW 314
129342: NOT
129343: IFFALSE 129648
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
129345: LD_ADDR_EXP 207
129349: PUSH
129350: LD_EXP 207
129354: PPUSH
129355: LD_VAR 0 5
129359: PPUSH
129360: CALL 108104 0 2
129364: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
129365: LD_ADDR_EXP 207
129369: PUSH
129370: LD_EXP 207
129374: PPUSH
129375: LD_VAR 0 1
129379: PPUSH
129380: CALL 108104 0 2
129384: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129385: LD_ADDR_VAR 0 6
129389: PUSH
129390: LD_EXP 206
129394: PUSH
129395: LD_VAR 0 4
129399: ARRAY
129400: PUSH
129401: LD_INT 3
129403: ARRAY
129404: PPUSH
129405: LD_EXP 206
129409: PUSH
129410: LD_VAR 0 4
129414: ARRAY
129415: PUSH
129416: LD_INT 4
129418: ARRAY
129419: PPUSH
129420: CALL_OW 428
129424: ST_TO_ADDR
// if hex then
129425: LD_VAR 0 6
129429: IFFALSE 129447
// ComMoveUnit ( driver , hex ) else
129431: LD_VAR 0 5
129435: PPUSH
129436: LD_VAR 0 6
129440: PPUSH
129441: CALL_OW 112
129445: GO 129531
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
129447: LD_VAR 0 1
129451: PPUSH
129452: LD_EXP 206
129456: PUSH
129457: LD_VAR 0 4
129461: ARRAY
129462: PUSH
129463: LD_INT 3
129465: ARRAY
129466: PPUSH
129467: LD_EXP 206
129471: PUSH
129472: LD_VAR 0 4
129476: ARRAY
129477: PUSH
129478: LD_INT 4
129480: ARRAY
129481: PPUSH
129482: CALL_OW 297
129486: PUSH
129487: LD_INT 0
129489: GREATER
129490: IFFALSE 129531
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129492: LD_VAR 0 5
129496: PPUSH
129497: LD_EXP 206
129501: PUSH
129502: LD_VAR 0 4
129506: ARRAY
129507: PUSH
129508: LD_INT 3
129510: ARRAY
129511: PPUSH
129512: LD_EXP 206
129516: PUSH
129517: LD_VAR 0 4
129521: ARRAY
129522: PUSH
129523: LD_INT 4
129525: ARRAY
129526: PPUSH
129527: CALL_OW 111
// AddComExitVehicle ( driver ) ;
129531: LD_VAR 0 5
129535: PPUSH
129536: CALL_OW 181
// if Multiplayer then
129540: LD_OWVAR 4
129544: IFFALSE 129593
// begin repeat wait ( 10 ) ;
129546: LD_INT 10
129548: PPUSH
129549: CALL_OW 67
// until not IsInUnit ( driver ) ;
129553: LD_VAR 0 5
129557: PPUSH
129558: CALL_OW 310
129562: NOT
129563: IFFALSE 129546
// if not HasTask ( driver ) then
129565: LD_VAR 0 5
129569: PPUSH
129570: CALL_OW 314
129574: NOT
129575: IFFALSE 129591
// ComEnterUnit ( driver , factory ) ;
129577: LD_VAR 0 5
129581: PPUSH
129582: LD_VAR 0 2
129586: PPUSH
129587: CALL_OW 120
// end else
129591: GO 129607
// AddComEnterUnit ( driver , factory ) ;
129593: LD_VAR 0 5
129597: PPUSH
129598: LD_VAR 0 2
129602: PPUSH
129603: CALL_OW 180
// wait ( 0 0$1 ) ;
129607: LD_INT 35
129609: PPUSH
129610: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
129614: LD_ADDR_EXP 207
129618: PUSH
129619: LD_EXP 207
129623: PUSH
129624: LD_VAR 0 5
129628: DIFF
129629: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
129630: LD_ADDR_EXP 207
129634: PUSH
129635: LD_EXP 207
129639: PUSH
129640: LD_VAR 0 1
129644: DIFF
129645: ST_TO_ADDR
// break ;
129646: GO 129769
// end ; end else
129648: GO 129767
// if GetControl ( vehicle ) = control_remote then
129650: LD_VAR 0 1
129654: PPUSH
129655: CALL_OW 263
129659: PUSH
129660: LD_INT 2
129662: EQUAL
129663: IFFALSE 129726
// begin wait ( 0 0$2 ) ;
129665: LD_INT 70
129667: PPUSH
129668: CALL_OW 67
// if Connect ( vehicle ) then
129672: LD_VAR 0 1
129676: PPUSH
129677: CALL 78701 0 1
129681: IFFALSE 129722
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129683: LD_VAR 0 1
129687: PPUSH
129688: LD_EXP 206
129692: PUSH
129693: LD_VAR 0 4
129697: ARRAY
129698: PUSH
129699: LD_INT 3
129701: ARRAY
129702: PPUSH
129703: LD_EXP 206
129707: PUSH
129708: LD_VAR 0 4
129712: ARRAY
129713: PUSH
129714: LD_INT 4
129716: ARRAY
129717: PPUSH
129718: CALL_OW 111
// break ;
129722: GO 129769
// end else
129724: GO 129767
// begin ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
129726: LD_VAR 0 1
129730: PPUSH
129731: LD_EXP 206
129735: PUSH
129736: LD_VAR 0 4
129740: ARRAY
129741: PUSH
129742: LD_INT 3
129744: ARRAY
129745: PPUSH
129746: LD_EXP 206
129750: PUSH
129751: LD_VAR 0 4
129755: ARRAY
129756: PUSH
129757: LD_INT 4
129759: ARRAY
129760: PPUSH
129761: CALL_OW 111
// break ;
129765: GO 129769
// end ; end ;
129767: GO 129250
129769: POP
129770: POP
// end ;
129771: LD_VAR 0 3
129775: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
129776: LD_INT 0
129778: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
129779: LD_VAR 0 1
129783: PUSH
129784: LD_INT 250
129786: EQUAL
129787: PUSH
129788: LD_VAR 0 2
129792: PPUSH
129793: CALL_OW 264
129797: PUSH
129798: LD_INT 81
129800: EQUAL
129801: AND
129802: IFFALSE 129823
// MinerPlaceMine ( unit , x , y ) ;
129804: LD_VAR 0 2
129808: PPUSH
129809: LD_VAR 0 4
129813: PPUSH
129814: LD_VAR 0 5
129818: PPUSH
129819: CALL 132915 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
129823: LD_VAR 0 1
129827: PUSH
129828: LD_INT 251
129830: EQUAL
129831: PUSH
129832: LD_VAR 0 2
129836: PPUSH
129837: CALL_OW 264
129841: PUSH
129842: LD_INT 81
129844: EQUAL
129845: AND
129846: IFFALSE 129867
// MinerDetonateMine ( unit , x , y ) ;
129848: LD_VAR 0 2
129852: PPUSH
129853: LD_VAR 0 4
129857: PPUSH
129858: LD_VAR 0 5
129862: PPUSH
129863: CALL 133190 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
129867: LD_VAR 0 1
129871: PUSH
129872: LD_INT 252
129874: EQUAL
129875: PUSH
129876: LD_VAR 0 2
129880: PPUSH
129881: CALL_OW 264
129885: PUSH
129886: LD_INT 81
129888: EQUAL
129889: AND
129890: IFFALSE 129911
// MinerCreateMinefield ( unit , x , y ) ;
129892: LD_VAR 0 2
129896: PPUSH
129897: LD_VAR 0 4
129901: PPUSH
129902: LD_VAR 0 5
129906: PPUSH
129907: CALL 133607 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
129911: LD_VAR 0 1
129915: PUSH
129916: LD_INT 253
129918: EQUAL
129919: PUSH
129920: LD_VAR 0 2
129924: PPUSH
129925: CALL_OW 257
129929: PUSH
129930: LD_INT 5
129932: EQUAL
129933: AND
129934: IFFALSE 129955
// ComBinocular ( unit , x , y ) ;
129936: LD_VAR 0 2
129940: PPUSH
129941: LD_VAR 0 4
129945: PPUSH
129946: LD_VAR 0 5
129950: PPUSH
129951: CALL 133976 0 3
// if selectedUnit then
129955: LD_VAR 0 3
129959: IFFALSE 130015
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
129961: LD_VAR 0 1
129965: PUSH
129966: LD_INT 254
129968: EQUAL
129969: PUSH
129970: LD_VAR 0 2
129974: PPUSH
129975: CALL_OW 264
129979: PUSH
129980: LD_INT 99
129982: EQUAL
129983: AND
129984: PUSH
129985: LD_VAR 0 3
129989: PPUSH
129990: CALL_OW 263
129994: PUSH
129995: LD_INT 3
129997: EQUAL
129998: AND
129999: IFFALSE 130015
// HackDestroyVehicle ( unit , selectedUnit ) ;
130001: LD_VAR 0 2
130005: PPUSH
130006: LD_VAR 0 3
130010: PPUSH
130011: CALL 132279 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
130015: LD_VAR 0 1
130019: PUSH
130020: LD_INT 255
130022: EQUAL
130023: PUSH
130024: LD_VAR 0 2
130028: PPUSH
130029: CALL_OW 264
130033: PUSH
130034: LD_INT 14
130036: PUSH
130037: LD_INT 53
130039: PUSH
130040: EMPTY
130041: LIST
130042: LIST
130043: IN
130044: AND
130045: PUSH
130046: LD_VAR 0 4
130050: PPUSH
130051: LD_VAR 0 5
130055: PPUSH
130056: CALL_OW 488
130060: AND
130061: IFFALSE 130085
// CutTreeXYR ( unit , x , y , 12 ) ;
130063: LD_VAR 0 2
130067: PPUSH
130068: LD_VAR 0 4
130072: PPUSH
130073: LD_VAR 0 5
130077: PPUSH
130078: LD_INT 12
130080: PPUSH
130081: CALL 130276 0 4
// if cmd = 256 then
130085: LD_VAR 0 1
130089: PUSH
130090: LD_INT 256
130092: EQUAL
130093: IFFALSE 130114
// SetFactoryWaypoint ( unit , x , y ) ;
130095: LD_VAR 0 2
130099: PPUSH
130100: LD_VAR 0 4
130104: PPUSH
130105: LD_VAR 0 5
130109: PPUSH
130110: CALL 127702 0 3
// if cmd = 257 then
130114: LD_VAR 0 1
130118: PUSH
130119: LD_INT 257
130121: EQUAL
130122: IFFALSE 130143
// SetWarehouseGatheringPoint ( unit , x , y ) ;
130124: LD_VAR 0 2
130128: PPUSH
130129: LD_VAR 0 4
130133: PPUSH
130134: LD_VAR 0 5
130138: PPUSH
130139: CALL 128192 0 3
// if cmd = 258 then
130143: LD_VAR 0 1
130147: PUSH
130148: LD_INT 258
130150: EQUAL
130151: IFFALSE 130175
// BurnTreeXYR ( unit , x , y , 8 ) ;
130153: LD_VAR 0 2
130157: PPUSH
130158: LD_VAR 0 4
130162: PPUSH
130163: LD_VAR 0 5
130167: PPUSH
130168: LD_INT 8
130170: PPUSH
130171: CALL 130670 0 4
// end ;
130175: LD_VAR 0 6
130179: RET
// export function ComRadiation ( un ) ; var eff ; begin
130180: LD_INT 0
130182: PPUSH
130183: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
130184: LD_VAR 0 1
130188: PPUSH
130189: CALL_OW 264
130193: PUSH
130194: LD_INT 91
130196: NONEQUAL
130197: IFFALSE 130201
// exit ;
130199: GO 130271
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
130201: LD_INT 68
130203: PPUSH
130204: LD_VAR 0 1
130208: PPUSH
130209: CALL_OW 255
130213: PPUSH
130214: CALL_OW 321
130218: PUSH
130219: LD_INT 2
130221: EQUAL
130222: IFFALSE 130234
// eff := 50 else
130224: LD_ADDR_VAR 0 3
130228: PUSH
130229: LD_INT 50
130231: ST_TO_ADDR
130232: GO 130242
// eff := 25 ;
130234: LD_ADDR_VAR 0 3
130238: PUSH
130239: LD_INT 25
130241: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
130242: LD_VAR 0 1
130246: PPUSH
130247: CALL_OW 250
130251: PPUSH
130252: LD_VAR 0 1
130256: PPUSH
130257: CALL_OW 251
130261: PPUSH
130262: LD_VAR 0 3
130266: PPUSH
130267: CALL_OW 495
// end ;
130271: LD_VAR 0 2
130275: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
130276: LD_INT 0
130278: PPUSH
130279: PPUSH
130280: PPUSH
130281: PPUSH
130282: PPUSH
130283: PPUSH
130284: PPUSH
130285: PPUSH
130286: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
130287: LD_VAR 0 1
130291: PPUSH
130292: CALL_OW 302
130296: NOT
130297: PUSH
130298: LD_VAR 0 2
130302: PPUSH
130303: LD_VAR 0 3
130307: PPUSH
130308: CALL_OW 488
130312: NOT
130313: OR
130314: PUSH
130315: LD_VAR 0 4
130319: NOT
130320: OR
130321: IFFALSE 130325
// exit ;
130323: GO 130665
// list := [ ] ;
130325: LD_ADDR_VAR 0 13
130329: PUSH
130330: EMPTY
130331: ST_TO_ADDR
// if x - r < 0 then
130332: LD_VAR 0 2
130336: PUSH
130337: LD_VAR 0 4
130341: MINUS
130342: PUSH
130343: LD_INT 0
130345: LESS
130346: IFFALSE 130358
// min_x := 0 else
130348: LD_ADDR_VAR 0 7
130352: PUSH
130353: LD_INT 0
130355: ST_TO_ADDR
130356: GO 130374
// min_x := x - r ;
130358: LD_ADDR_VAR 0 7
130362: PUSH
130363: LD_VAR 0 2
130367: PUSH
130368: LD_VAR 0 4
130372: MINUS
130373: ST_TO_ADDR
// if y - r < 0 then
130374: LD_VAR 0 3
130378: PUSH
130379: LD_VAR 0 4
130383: MINUS
130384: PUSH
130385: LD_INT 0
130387: LESS
130388: IFFALSE 130400
// min_y := 0 else
130390: LD_ADDR_VAR 0 8
130394: PUSH
130395: LD_INT 0
130397: ST_TO_ADDR
130398: GO 130416
// min_y := y - r ;
130400: LD_ADDR_VAR 0 8
130404: PUSH
130405: LD_VAR 0 3
130409: PUSH
130410: LD_VAR 0 4
130414: MINUS
130415: ST_TO_ADDR
// max_x := x + r ;
130416: LD_ADDR_VAR 0 9
130420: PUSH
130421: LD_VAR 0 2
130425: PUSH
130426: LD_VAR 0 4
130430: PLUS
130431: ST_TO_ADDR
// max_y := y + r ;
130432: LD_ADDR_VAR 0 10
130436: PUSH
130437: LD_VAR 0 3
130441: PUSH
130442: LD_VAR 0 4
130446: PLUS
130447: ST_TO_ADDR
// for _x = min_x to max_x do
130448: LD_ADDR_VAR 0 11
130452: PUSH
130453: DOUBLE
130454: LD_VAR 0 7
130458: DEC
130459: ST_TO_ADDR
130460: LD_VAR 0 9
130464: PUSH
130465: FOR_TO
130466: IFFALSE 130583
// for _y = min_y to max_y do
130468: LD_ADDR_VAR 0 12
130472: PUSH
130473: DOUBLE
130474: LD_VAR 0 8
130478: DEC
130479: ST_TO_ADDR
130480: LD_VAR 0 10
130484: PUSH
130485: FOR_TO
130486: IFFALSE 130579
// begin if not ValidHex ( _x , _y ) then
130488: LD_VAR 0 11
130492: PPUSH
130493: LD_VAR 0 12
130497: PPUSH
130498: CALL_OW 488
130502: NOT
130503: IFFALSE 130507
// continue ;
130505: GO 130485
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130507: LD_VAR 0 11
130511: PPUSH
130512: LD_VAR 0 12
130516: PPUSH
130517: CALL_OW 351
130521: PUSH
130522: LD_VAR 0 11
130526: PPUSH
130527: LD_VAR 0 12
130531: PPUSH
130532: CALL_OW 554
130536: AND
130537: IFFALSE 130577
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130539: LD_ADDR_VAR 0 13
130543: PUSH
130544: LD_VAR 0 13
130548: PPUSH
130549: LD_VAR 0 13
130553: PUSH
130554: LD_INT 1
130556: PLUS
130557: PPUSH
130558: LD_VAR 0 11
130562: PUSH
130563: LD_VAR 0 12
130567: PUSH
130568: EMPTY
130569: LIST
130570: LIST
130571: PPUSH
130572: CALL_OW 2
130576: ST_TO_ADDR
// end ;
130577: GO 130485
130579: POP
130580: POP
130581: GO 130465
130583: POP
130584: POP
// if not list then
130585: LD_VAR 0 13
130589: NOT
130590: IFFALSE 130594
// exit ;
130592: GO 130665
// for i in list do
130594: LD_ADDR_VAR 0 6
130598: PUSH
130599: LD_VAR 0 13
130603: PUSH
130604: FOR_IN
130605: IFFALSE 130663
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
130607: LD_VAR 0 1
130611: PPUSH
130612: LD_STRING M
130614: PUSH
130615: LD_VAR 0 6
130619: PUSH
130620: LD_INT 1
130622: ARRAY
130623: PUSH
130624: LD_VAR 0 6
130628: PUSH
130629: LD_INT 2
130631: ARRAY
130632: PUSH
130633: LD_INT 0
130635: PUSH
130636: LD_INT 0
130638: PUSH
130639: LD_INT 0
130641: PUSH
130642: LD_INT 0
130644: PUSH
130645: EMPTY
130646: LIST
130647: LIST
130648: LIST
130649: LIST
130650: LIST
130651: LIST
130652: LIST
130653: PUSH
130654: EMPTY
130655: LIST
130656: PPUSH
130657: CALL_OW 447
130661: GO 130604
130663: POP
130664: POP
// end ;
130665: LD_VAR 0 5
130669: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
130670: LD_INT 0
130672: PPUSH
130673: PPUSH
130674: PPUSH
130675: PPUSH
130676: PPUSH
130677: PPUSH
130678: PPUSH
130679: PPUSH
130680: PPUSH
130681: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
130682: LD_VAR 0 1
130686: PPUSH
130687: CALL_OW 302
130691: NOT
130692: PUSH
130693: LD_VAR 0 2
130697: PPUSH
130698: LD_VAR 0 3
130702: PPUSH
130703: CALL_OW 488
130707: NOT
130708: OR
130709: PUSH
130710: LD_VAR 0 4
130714: NOT
130715: OR
130716: IFFALSE 130720
// exit ;
130718: GO 131233
// list := [ ] ;
130720: LD_ADDR_VAR 0 13
130724: PUSH
130725: EMPTY
130726: ST_TO_ADDR
// if x - r < 0 then
130727: LD_VAR 0 2
130731: PUSH
130732: LD_VAR 0 4
130736: MINUS
130737: PUSH
130738: LD_INT 0
130740: LESS
130741: IFFALSE 130753
// min_x := 0 else
130743: LD_ADDR_VAR 0 7
130747: PUSH
130748: LD_INT 0
130750: ST_TO_ADDR
130751: GO 130769
// min_x := x - r ;
130753: LD_ADDR_VAR 0 7
130757: PUSH
130758: LD_VAR 0 2
130762: PUSH
130763: LD_VAR 0 4
130767: MINUS
130768: ST_TO_ADDR
// if y - r < 0 then
130769: LD_VAR 0 3
130773: PUSH
130774: LD_VAR 0 4
130778: MINUS
130779: PUSH
130780: LD_INT 0
130782: LESS
130783: IFFALSE 130795
// min_y := 0 else
130785: LD_ADDR_VAR 0 8
130789: PUSH
130790: LD_INT 0
130792: ST_TO_ADDR
130793: GO 130811
// min_y := y - r ;
130795: LD_ADDR_VAR 0 8
130799: PUSH
130800: LD_VAR 0 3
130804: PUSH
130805: LD_VAR 0 4
130809: MINUS
130810: ST_TO_ADDR
// max_x := x + r ;
130811: LD_ADDR_VAR 0 9
130815: PUSH
130816: LD_VAR 0 2
130820: PUSH
130821: LD_VAR 0 4
130825: PLUS
130826: ST_TO_ADDR
// max_y := y + r ;
130827: LD_ADDR_VAR 0 10
130831: PUSH
130832: LD_VAR 0 3
130836: PUSH
130837: LD_VAR 0 4
130841: PLUS
130842: ST_TO_ADDR
// for _x = min_x to max_x do
130843: LD_ADDR_VAR 0 11
130847: PUSH
130848: DOUBLE
130849: LD_VAR 0 7
130853: DEC
130854: ST_TO_ADDR
130855: LD_VAR 0 9
130859: PUSH
130860: FOR_TO
130861: IFFALSE 130978
// for _y = min_y to max_y do
130863: LD_ADDR_VAR 0 12
130867: PUSH
130868: DOUBLE
130869: LD_VAR 0 8
130873: DEC
130874: ST_TO_ADDR
130875: LD_VAR 0 10
130879: PUSH
130880: FOR_TO
130881: IFFALSE 130974
// begin if not ValidHex ( _x , _y ) then
130883: LD_VAR 0 11
130887: PPUSH
130888: LD_VAR 0 12
130892: PPUSH
130893: CALL_OW 488
130897: NOT
130898: IFFALSE 130902
// continue ;
130900: GO 130880
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
130902: LD_VAR 0 11
130906: PPUSH
130907: LD_VAR 0 12
130911: PPUSH
130912: CALL_OW 351
130916: PUSH
130917: LD_VAR 0 11
130921: PPUSH
130922: LD_VAR 0 12
130926: PPUSH
130927: CALL_OW 554
130931: AND
130932: IFFALSE 130972
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
130934: LD_ADDR_VAR 0 13
130938: PUSH
130939: LD_VAR 0 13
130943: PPUSH
130944: LD_VAR 0 13
130948: PUSH
130949: LD_INT 1
130951: PLUS
130952: PPUSH
130953: LD_VAR 0 11
130957: PUSH
130958: LD_VAR 0 12
130962: PUSH
130963: EMPTY
130964: LIST
130965: LIST
130966: PPUSH
130967: CALL_OW 2
130971: ST_TO_ADDR
// end ;
130972: GO 130880
130974: POP
130975: POP
130976: GO 130860
130978: POP
130979: POP
// if not list then
130980: LD_VAR 0 13
130984: NOT
130985: IFFALSE 130989
// exit ;
130987: GO 131233
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
130989: LD_ADDR_VAR 0 13
130993: PUSH
130994: LD_VAR 0 1
130998: PPUSH
130999: LD_VAR 0 13
131003: PPUSH
131004: LD_INT 1
131006: PPUSH
131007: LD_INT 1
131009: PPUSH
131010: CALL 75843 0 4
131014: ST_TO_ADDR
// ComStop ( flame ) ;
131015: LD_VAR 0 1
131019: PPUSH
131020: CALL_OW 141
// for i in list do
131024: LD_ADDR_VAR 0 6
131028: PUSH
131029: LD_VAR 0 13
131033: PUSH
131034: FOR_IN
131035: IFFALSE 131066
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
131037: LD_VAR 0 1
131041: PPUSH
131042: LD_VAR 0 6
131046: PUSH
131047: LD_INT 1
131049: ARRAY
131050: PPUSH
131051: LD_VAR 0 6
131055: PUSH
131056: LD_INT 2
131058: ARRAY
131059: PPUSH
131060: CALL_OW 176
131064: GO 131034
131066: POP
131067: POP
// repeat wait ( 0 0$1 ) ;
131068: LD_INT 35
131070: PPUSH
131071: CALL_OW 67
// task := GetTaskList ( flame ) ;
131075: LD_ADDR_VAR 0 14
131079: PUSH
131080: LD_VAR 0 1
131084: PPUSH
131085: CALL_OW 437
131089: ST_TO_ADDR
// if not task then
131090: LD_VAR 0 14
131094: NOT
131095: IFFALSE 131099
// exit ;
131097: GO 131233
// if task [ 1 ] [ 1 ] <> | then
131099: LD_VAR 0 14
131103: PUSH
131104: LD_INT 1
131106: ARRAY
131107: PUSH
131108: LD_INT 1
131110: ARRAY
131111: PUSH
131112: LD_STRING |
131114: NONEQUAL
131115: IFFALSE 131119
// exit ;
131117: GO 131233
// _x := task [ 1 ] [ 2 ] ;
131119: LD_ADDR_VAR 0 11
131123: PUSH
131124: LD_VAR 0 14
131128: PUSH
131129: LD_INT 1
131131: ARRAY
131132: PUSH
131133: LD_INT 2
131135: ARRAY
131136: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
131137: LD_ADDR_VAR 0 12
131141: PUSH
131142: LD_VAR 0 14
131146: PUSH
131147: LD_INT 1
131149: ARRAY
131150: PUSH
131151: LD_INT 3
131153: ARRAY
131154: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
131155: LD_VAR 0 11
131159: PPUSH
131160: LD_VAR 0 12
131164: PPUSH
131165: CALL_OW 351
131169: NOT
131170: PUSH
131171: LD_VAR 0 11
131175: PPUSH
131176: LD_VAR 0 12
131180: PPUSH
131181: CALL_OW 554
131185: NOT
131186: OR
131187: IFFALSE 131221
// begin task := Delete ( task , 1 ) ;
131189: LD_ADDR_VAR 0 14
131193: PUSH
131194: LD_VAR 0 14
131198: PPUSH
131199: LD_INT 1
131201: PPUSH
131202: CALL_OW 3
131206: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
131207: LD_VAR 0 1
131211: PPUSH
131212: LD_VAR 0 14
131216: PPUSH
131217: CALL_OW 446
// end ; until not HasTask ( flame ) ;
131221: LD_VAR 0 1
131225: PPUSH
131226: CALL_OW 314
131230: NOT
131231: IFFALSE 131068
// end ;
131233: LD_VAR 0 5
131237: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
131238: LD_EXP 210
131242: NOT
131243: IFFALSE 131293
131245: GO 131247
131247: DISABLE
// begin initHack := true ;
131248: LD_ADDR_EXP 210
131252: PUSH
131253: LD_INT 1
131255: ST_TO_ADDR
// hackTanks := [ ] ;
131256: LD_ADDR_EXP 211
131260: PUSH
131261: EMPTY
131262: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
131263: LD_ADDR_EXP 212
131267: PUSH
131268: EMPTY
131269: ST_TO_ADDR
// hackLimit := 3 ;
131270: LD_ADDR_EXP 213
131274: PUSH
131275: LD_INT 3
131277: ST_TO_ADDR
// hackDist := 12 ;
131278: LD_ADDR_EXP 214
131282: PUSH
131283: LD_INT 12
131285: ST_TO_ADDR
// hackCounter := [ ] ;
131286: LD_ADDR_EXP 215
131290: PUSH
131291: EMPTY
131292: ST_TO_ADDR
// end ;
131293: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
131294: LD_EXP 210
131298: PUSH
131299: LD_INT 34
131301: PUSH
131302: LD_INT 99
131304: PUSH
131305: EMPTY
131306: LIST
131307: LIST
131308: PPUSH
131309: CALL_OW 69
131313: AND
131314: IFFALSE 131567
131316: GO 131318
131318: DISABLE
131319: LD_INT 0
131321: PPUSH
131322: PPUSH
// begin enable ;
131323: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
131324: LD_ADDR_VAR 0 1
131328: PUSH
131329: LD_INT 34
131331: PUSH
131332: LD_INT 99
131334: PUSH
131335: EMPTY
131336: LIST
131337: LIST
131338: PPUSH
131339: CALL_OW 69
131343: PUSH
131344: FOR_IN
131345: IFFALSE 131565
// begin if not i in hackTanks then
131347: LD_VAR 0 1
131351: PUSH
131352: LD_EXP 211
131356: IN
131357: NOT
131358: IFFALSE 131441
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
131360: LD_ADDR_EXP 211
131364: PUSH
131365: LD_EXP 211
131369: PPUSH
131370: LD_EXP 211
131374: PUSH
131375: LD_INT 1
131377: PLUS
131378: PPUSH
131379: LD_VAR 0 1
131383: PPUSH
131384: CALL_OW 1
131388: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
131389: LD_ADDR_EXP 212
131393: PUSH
131394: LD_EXP 212
131398: PPUSH
131399: LD_EXP 212
131403: PUSH
131404: LD_INT 1
131406: PLUS
131407: PPUSH
131408: EMPTY
131409: PPUSH
131410: CALL_OW 1
131414: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
131415: LD_ADDR_EXP 215
131419: PUSH
131420: LD_EXP 215
131424: PPUSH
131425: LD_EXP 215
131429: PUSH
131430: LD_INT 1
131432: PLUS
131433: PPUSH
131434: EMPTY
131435: PPUSH
131436: CALL_OW 1
131440: ST_TO_ADDR
// end ; if not IsOk ( i ) then
131441: LD_VAR 0 1
131445: PPUSH
131446: CALL_OW 302
131450: NOT
131451: IFFALSE 131464
// begin HackUnlinkAll ( i ) ;
131453: LD_VAR 0 1
131457: PPUSH
131458: CALL 131570 0 1
// continue ;
131462: GO 131344
// end ; HackCheckCapturedStatus ( i ) ;
131464: LD_VAR 0 1
131468: PPUSH
131469: CALL 132013 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
131473: LD_ADDR_VAR 0 2
131477: PUSH
131478: LD_INT 81
131480: PUSH
131481: LD_VAR 0 1
131485: PPUSH
131486: CALL_OW 255
131490: PUSH
131491: EMPTY
131492: LIST
131493: LIST
131494: PUSH
131495: LD_INT 33
131497: PUSH
131498: LD_INT 3
131500: PUSH
131501: EMPTY
131502: LIST
131503: LIST
131504: PUSH
131505: LD_INT 91
131507: PUSH
131508: LD_VAR 0 1
131512: PUSH
131513: LD_EXP 214
131517: PUSH
131518: EMPTY
131519: LIST
131520: LIST
131521: LIST
131522: PUSH
131523: LD_INT 50
131525: PUSH
131526: EMPTY
131527: LIST
131528: PUSH
131529: EMPTY
131530: LIST
131531: LIST
131532: LIST
131533: LIST
131534: PPUSH
131535: CALL_OW 69
131539: ST_TO_ADDR
// if not tmp then
131540: LD_VAR 0 2
131544: NOT
131545: IFFALSE 131549
// continue ;
131547: GO 131344
// HackLink ( i , tmp ) ;
131549: LD_VAR 0 1
131553: PPUSH
131554: LD_VAR 0 2
131558: PPUSH
131559: CALL 131706 0 2
// end ;
131563: GO 131344
131565: POP
131566: POP
// end ;
131567: PPOPN 2
131569: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
131570: LD_INT 0
131572: PPUSH
131573: PPUSH
131574: PPUSH
// if not hack in hackTanks then
131575: LD_VAR 0 1
131579: PUSH
131580: LD_EXP 211
131584: IN
131585: NOT
131586: IFFALSE 131590
// exit ;
131588: GO 131701
// index := GetElementIndex ( hackTanks , hack ) ;
131590: LD_ADDR_VAR 0 4
131594: PUSH
131595: LD_EXP 211
131599: PPUSH
131600: LD_VAR 0 1
131604: PPUSH
131605: CALL 75140 0 2
131609: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
131610: LD_EXP 212
131614: PUSH
131615: LD_VAR 0 4
131619: ARRAY
131620: IFFALSE 131701
// begin for i in hackTanksCaptured [ index ] do
131622: LD_ADDR_VAR 0 3
131626: PUSH
131627: LD_EXP 212
131631: PUSH
131632: LD_VAR 0 4
131636: ARRAY
131637: PUSH
131638: FOR_IN
131639: IFFALSE 131665
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
131641: LD_VAR 0 3
131645: PUSH
131646: LD_INT 1
131648: ARRAY
131649: PPUSH
131650: LD_VAR 0 3
131654: PUSH
131655: LD_INT 2
131657: ARRAY
131658: PPUSH
131659: CALL_OW 235
131663: GO 131638
131665: POP
131666: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
131667: LD_ADDR_EXP 212
131671: PUSH
131672: LD_EXP 212
131676: PPUSH
131677: LD_VAR 0 4
131681: PPUSH
131682: EMPTY
131683: PPUSH
131684: CALL_OW 1
131688: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
131689: LD_VAR 0 1
131693: PPUSH
131694: LD_INT 0
131696: PPUSH
131697: CALL_OW 505
// end ; end ;
131701: LD_VAR 0 2
131705: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
131706: LD_INT 0
131708: PPUSH
131709: PPUSH
131710: PPUSH
// if not hack in hackTanks or not vehicles then
131711: LD_VAR 0 1
131715: PUSH
131716: LD_EXP 211
131720: IN
131721: NOT
131722: PUSH
131723: LD_VAR 0 2
131727: NOT
131728: OR
131729: IFFALSE 131733
// exit ;
131731: GO 132008
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
131733: LD_ADDR_VAR 0 2
131737: PUSH
131738: LD_VAR 0 1
131742: PPUSH
131743: LD_VAR 0 2
131747: PPUSH
131748: LD_INT 1
131750: PPUSH
131751: LD_INT 1
131753: PPUSH
131754: CALL 75790 0 4
131758: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
131759: LD_ADDR_VAR 0 5
131763: PUSH
131764: LD_EXP 211
131768: PPUSH
131769: LD_VAR 0 1
131773: PPUSH
131774: CALL 75140 0 2
131778: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
131779: LD_EXP 212
131783: PUSH
131784: LD_VAR 0 5
131788: ARRAY
131789: PUSH
131790: LD_EXP 213
131794: LESS
131795: IFFALSE 131984
// begin for i := 1 to vehicles do
131797: LD_ADDR_VAR 0 4
131801: PUSH
131802: DOUBLE
131803: LD_INT 1
131805: DEC
131806: ST_TO_ADDR
131807: LD_VAR 0 2
131811: PUSH
131812: FOR_TO
131813: IFFALSE 131982
// begin if hackTanksCaptured [ index ] = hackLimit then
131815: LD_EXP 212
131819: PUSH
131820: LD_VAR 0 5
131824: ARRAY
131825: PUSH
131826: LD_EXP 213
131830: EQUAL
131831: IFFALSE 131835
// break ;
131833: GO 131982
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
131835: LD_ADDR_EXP 215
131839: PUSH
131840: LD_EXP 215
131844: PPUSH
131845: LD_VAR 0 5
131849: PPUSH
131850: LD_EXP 215
131854: PUSH
131855: LD_VAR 0 5
131859: ARRAY
131860: PUSH
131861: LD_INT 1
131863: PLUS
131864: PPUSH
131865: CALL_OW 1
131869: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
131870: LD_ADDR_EXP 212
131874: PUSH
131875: LD_EXP 212
131879: PPUSH
131880: LD_VAR 0 5
131884: PUSH
131885: LD_EXP 212
131889: PUSH
131890: LD_VAR 0 5
131894: ARRAY
131895: PUSH
131896: LD_INT 1
131898: PLUS
131899: PUSH
131900: EMPTY
131901: LIST
131902: LIST
131903: PPUSH
131904: LD_VAR 0 2
131908: PUSH
131909: LD_VAR 0 4
131913: ARRAY
131914: PUSH
131915: LD_VAR 0 2
131919: PUSH
131920: LD_VAR 0 4
131924: ARRAY
131925: PPUSH
131926: CALL_OW 255
131930: PUSH
131931: EMPTY
131932: LIST
131933: LIST
131934: PPUSH
131935: CALL 75355 0 3
131939: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
131940: LD_VAR 0 2
131944: PUSH
131945: LD_VAR 0 4
131949: ARRAY
131950: PPUSH
131951: LD_VAR 0 1
131955: PPUSH
131956: CALL_OW 255
131960: PPUSH
131961: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
131965: LD_VAR 0 2
131969: PUSH
131970: LD_VAR 0 4
131974: ARRAY
131975: PPUSH
131976: CALL_OW 141
// end ;
131980: GO 131812
131982: POP
131983: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
131984: LD_VAR 0 1
131988: PPUSH
131989: LD_EXP 212
131993: PUSH
131994: LD_VAR 0 5
131998: ARRAY
131999: PUSH
132000: LD_INT 0
132002: PLUS
132003: PPUSH
132004: CALL_OW 505
// end ;
132008: LD_VAR 0 3
132012: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
132013: LD_INT 0
132015: PPUSH
132016: PPUSH
132017: PPUSH
132018: PPUSH
// if not hack in hackTanks then
132019: LD_VAR 0 1
132023: PUSH
132024: LD_EXP 211
132028: IN
132029: NOT
132030: IFFALSE 132034
// exit ;
132032: GO 132274
// index := GetElementIndex ( hackTanks , hack ) ;
132034: LD_ADDR_VAR 0 4
132038: PUSH
132039: LD_EXP 211
132043: PPUSH
132044: LD_VAR 0 1
132048: PPUSH
132049: CALL 75140 0 2
132053: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
132054: LD_ADDR_VAR 0 3
132058: PUSH
132059: DOUBLE
132060: LD_EXP 212
132064: PUSH
132065: LD_VAR 0 4
132069: ARRAY
132070: INC
132071: ST_TO_ADDR
132072: LD_INT 1
132074: PUSH
132075: FOR_DOWNTO
132076: IFFALSE 132248
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
132078: LD_ADDR_VAR 0 5
132082: PUSH
132083: LD_EXP 212
132087: PUSH
132088: LD_VAR 0 4
132092: ARRAY
132093: PUSH
132094: LD_VAR 0 3
132098: ARRAY
132099: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
132100: LD_VAR 0 5
132104: PUSH
132105: LD_INT 1
132107: ARRAY
132108: PPUSH
132109: CALL_OW 302
132113: NOT
132114: PUSH
132115: LD_VAR 0 5
132119: PUSH
132120: LD_INT 1
132122: ARRAY
132123: PPUSH
132124: CALL_OW 255
132128: PUSH
132129: LD_VAR 0 1
132133: PPUSH
132134: CALL_OW 255
132138: NONEQUAL
132139: OR
132140: IFFALSE 132246
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
132142: LD_VAR 0 5
132146: PUSH
132147: LD_INT 1
132149: ARRAY
132150: PPUSH
132151: CALL_OW 305
132155: PUSH
132156: LD_VAR 0 5
132160: PUSH
132161: LD_INT 1
132163: ARRAY
132164: PPUSH
132165: CALL_OW 255
132169: PUSH
132170: LD_VAR 0 1
132174: PPUSH
132175: CALL_OW 255
132179: EQUAL
132180: AND
132181: IFFALSE 132205
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
132183: LD_VAR 0 5
132187: PUSH
132188: LD_INT 1
132190: ARRAY
132191: PPUSH
132192: LD_VAR 0 5
132196: PUSH
132197: LD_INT 2
132199: ARRAY
132200: PPUSH
132201: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
132205: LD_ADDR_EXP 212
132209: PUSH
132210: LD_EXP 212
132214: PPUSH
132215: LD_VAR 0 4
132219: PPUSH
132220: LD_EXP 212
132224: PUSH
132225: LD_VAR 0 4
132229: ARRAY
132230: PPUSH
132231: LD_VAR 0 3
132235: PPUSH
132236: CALL_OW 3
132240: PPUSH
132241: CALL_OW 1
132245: ST_TO_ADDR
// end ; end ;
132246: GO 132075
132248: POP
132249: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
132250: LD_VAR 0 1
132254: PPUSH
132255: LD_EXP 212
132259: PUSH
132260: LD_VAR 0 4
132264: ARRAY
132265: PUSH
132266: LD_INT 0
132268: PLUS
132269: PPUSH
132270: CALL_OW 505
// end ;
132274: LD_VAR 0 2
132278: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
132279: LD_INT 0
132281: PPUSH
132282: PPUSH
132283: PPUSH
132284: PPUSH
// if not hack in hackTanks then
132285: LD_VAR 0 1
132289: PUSH
132290: LD_EXP 211
132294: IN
132295: NOT
132296: IFFALSE 132300
// exit ;
132298: GO 132385
// index := GetElementIndex ( hackTanks , hack ) ;
132300: LD_ADDR_VAR 0 5
132304: PUSH
132305: LD_EXP 211
132309: PPUSH
132310: LD_VAR 0 1
132314: PPUSH
132315: CALL 75140 0 2
132319: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
132320: LD_ADDR_VAR 0 4
132324: PUSH
132325: DOUBLE
132326: LD_INT 1
132328: DEC
132329: ST_TO_ADDR
132330: LD_EXP 212
132334: PUSH
132335: LD_VAR 0 5
132339: ARRAY
132340: PUSH
132341: FOR_TO
132342: IFFALSE 132383
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
132344: LD_EXP 212
132348: PUSH
132349: LD_VAR 0 5
132353: ARRAY
132354: PUSH
132355: LD_VAR 0 4
132359: ARRAY
132360: PUSH
132361: LD_INT 1
132363: ARRAY
132364: PUSH
132365: LD_VAR 0 2
132369: EQUAL
132370: IFFALSE 132381
// KillUnit ( vehicle ) ;
132372: LD_VAR 0 2
132376: PPUSH
132377: CALL_OW 66
132381: GO 132341
132383: POP
132384: POP
// end ;
132385: LD_VAR 0 3
132389: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
132390: LD_EXP 216
132394: NOT
132395: IFFALSE 132430
132397: GO 132399
132399: DISABLE
// begin initMiner := true ;
132400: LD_ADDR_EXP 216
132404: PUSH
132405: LD_INT 1
132407: ST_TO_ADDR
// minersList := [ ] ;
132408: LD_ADDR_EXP 217
132412: PUSH
132413: EMPTY
132414: ST_TO_ADDR
// minerMinesList := [ ] ;
132415: LD_ADDR_EXP 218
132419: PUSH
132420: EMPTY
132421: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
132422: LD_ADDR_EXP 219
132426: PUSH
132427: LD_INT 5
132429: ST_TO_ADDR
// end ;
132430: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
132431: LD_EXP 216
132435: PUSH
132436: LD_INT 34
132438: PUSH
132439: LD_INT 81
132441: PUSH
132442: EMPTY
132443: LIST
132444: LIST
132445: PPUSH
132446: CALL_OW 69
132450: AND
132451: IFFALSE 132912
132453: GO 132455
132455: DISABLE
132456: LD_INT 0
132458: PPUSH
132459: PPUSH
132460: PPUSH
132461: PPUSH
// begin enable ;
132462: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
132463: LD_ADDR_VAR 0 1
132467: PUSH
132468: LD_INT 34
132470: PUSH
132471: LD_INT 81
132473: PUSH
132474: EMPTY
132475: LIST
132476: LIST
132477: PPUSH
132478: CALL_OW 69
132482: PUSH
132483: FOR_IN
132484: IFFALSE 132556
// begin if not i in minersList then
132486: LD_VAR 0 1
132490: PUSH
132491: LD_EXP 217
132495: IN
132496: NOT
132497: IFFALSE 132554
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
132499: LD_ADDR_EXP 217
132503: PUSH
132504: LD_EXP 217
132508: PPUSH
132509: LD_EXP 217
132513: PUSH
132514: LD_INT 1
132516: PLUS
132517: PPUSH
132518: LD_VAR 0 1
132522: PPUSH
132523: CALL_OW 1
132527: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
132528: LD_ADDR_EXP 218
132532: PUSH
132533: LD_EXP 218
132537: PPUSH
132538: LD_EXP 218
132542: PUSH
132543: LD_INT 1
132545: PLUS
132546: PPUSH
132547: EMPTY
132548: PPUSH
132549: CALL_OW 1
132553: ST_TO_ADDR
// end end ;
132554: GO 132483
132556: POP
132557: POP
// for i := minerMinesList downto 1 do
132558: LD_ADDR_VAR 0 1
132562: PUSH
132563: DOUBLE
132564: LD_EXP 218
132568: INC
132569: ST_TO_ADDR
132570: LD_INT 1
132572: PUSH
132573: FOR_DOWNTO
132574: IFFALSE 132910
// begin if IsLive ( minersList [ i ] ) then
132576: LD_EXP 217
132580: PUSH
132581: LD_VAR 0 1
132585: ARRAY
132586: PPUSH
132587: CALL_OW 300
132591: IFFALSE 132619
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
132593: LD_EXP 217
132597: PUSH
132598: LD_VAR 0 1
132602: ARRAY
132603: PPUSH
132604: LD_EXP 218
132608: PUSH
132609: LD_VAR 0 1
132613: ARRAY
132614: PPUSH
132615: CALL_OW 505
// if not minerMinesList [ i ] then
132619: LD_EXP 218
132623: PUSH
132624: LD_VAR 0 1
132628: ARRAY
132629: NOT
132630: IFFALSE 132634
// continue ;
132632: GO 132573
// for j := minerMinesList [ i ] downto 1 do
132634: LD_ADDR_VAR 0 2
132638: PUSH
132639: DOUBLE
132640: LD_EXP 218
132644: PUSH
132645: LD_VAR 0 1
132649: ARRAY
132650: INC
132651: ST_TO_ADDR
132652: LD_INT 1
132654: PUSH
132655: FOR_DOWNTO
132656: IFFALSE 132906
// begin side := GetSide ( minersList [ i ] ) ;
132658: LD_ADDR_VAR 0 3
132662: PUSH
132663: LD_EXP 217
132667: PUSH
132668: LD_VAR 0 1
132672: ARRAY
132673: PPUSH
132674: CALL_OW 255
132678: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
132679: LD_ADDR_VAR 0 4
132683: PUSH
132684: LD_EXP 218
132688: PUSH
132689: LD_VAR 0 1
132693: ARRAY
132694: PUSH
132695: LD_VAR 0 2
132699: ARRAY
132700: PUSH
132701: LD_INT 1
132703: ARRAY
132704: PPUSH
132705: LD_EXP 218
132709: PUSH
132710: LD_VAR 0 1
132714: ARRAY
132715: PUSH
132716: LD_VAR 0 2
132720: ARRAY
132721: PUSH
132722: LD_INT 2
132724: ARRAY
132725: PPUSH
132726: CALL_OW 428
132730: ST_TO_ADDR
// if not tmp then
132731: LD_VAR 0 4
132735: NOT
132736: IFFALSE 132740
// continue ;
132738: GO 132655
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
132740: LD_VAR 0 4
132744: PUSH
132745: LD_INT 81
132747: PUSH
132748: LD_VAR 0 3
132752: PUSH
132753: EMPTY
132754: LIST
132755: LIST
132756: PPUSH
132757: CALL_OW 69
132761: IN
132762: PUSH
132763: LD_EXP 218
132767: PUSH
132768: LD_VAR 0 1
132772: ARRAY
132773: PUSH
132774: LD_VAR 0 2
132778: ARRAY
132779: PUSH
132780: LD_INT 1
132782: ARRAY
132783: PPUSH
132784: LD_EXP 218
132788: PUSH
132789: LD_VAR 0 1
132793: ARRAY
132794: PUSH
132795: LD_VAR 0 2
132799: ARRAY
132800: PUSH
132801: LD_INT 2
132803: ARRAY
132804: PPUSH
132805: CALL_OW 458
132809: AND
132810: IFFALSE 132904
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
132812: LD_EXP 218
132816: PUSH
132817: LD_VAR 0 1
132821: ARRAY
132822: PUSH
132823: LD_VAR 0 2
132827: ARRAY
132828: PUSH
132829: LD_INT 1
132831: ARRAY
132832: PPUSH
132833: LD_EXP 218
132837: PUSH
132838: LD_VAR 0 1
132842: ARRAY
132843: PUSH
132844: LD_VAR 0 2
132848: ARRAY
132849: PUSH
132850: LD_INT 2
132852: ARRAY
132853: PPUSH
132854: LD_VAR 0 3
132858: PPUSH
132859: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
132863: LD_ADDR_EXP 218
132867: PUSH
132868: LD_EXP 218
132872: PPUSH
132873: LD_VAR 0 1
132877: PPUSH
132878: LD_EXP 218
132882: PUSH
132883: LD_VAR 0 1
132887: ARRAY
132888: PPUSH
132889: LD_VAR 0 2
132893: PPUSH
132894: CALL_OW 3
132898: PPUSH
132899: CALL_OW 1
132903: ST_TO_ADDR
// end ; end ;
132904: GO 132655
132906: POP
132907: POP
// end ;
132908: GO 132573
132910: POP
132911: POP
// end ;
132912: PPOPN 4
132914: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
132915: LD_INT 0
132917: PPUSH
132918: PPUSH
// result := false ;
132919: LD_ADDR_VAR 0 4
132923: PUSH
132924: LD_INT 0
132926: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
132927: LD_VAR 0 1
132931: PPUSH
132932: CALL_OW 264
132936: PUSH
132937: LD_INT 81
132939: EQUAL
132940: NOT
132941: IFFALSE 132945
// exit ;
132943: GO 133185
// index := GetElementIndex ( minersList , unit ) ;
132945: LD_ADDR_VAR 0 5
132949: PUSH
132950: LD_EXP 217
132954: PPUSH
132955: LD_VAR 0 1
132959: PPUSH
132960: CALL 75140 0 2
132964: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
132965: LD_EXP 218
132969: PUSH
132970: LD_VAR 0 5
132974: ARRAY
132975: PUSH
132976: LD_EXP 219
132980: GREATEREQUAL
132981: IFFALSE 132985
// exit ;
132983: GO 133185
// ComMoveXY ( unit , x , y ) ;
132985: LD_VAR 0 1
132989: PPUSH
132990: LD_VAR 0 2
132994: PPUSH
132995: LD_VAR 0 3
132999: PPUSH
133000: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
133004: LD_INT 35
133006: PPUSH
133007: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
133011: LD_VAR 0 1
133015: PPUSH
133016: LD_VAR 0 2
133020: PPUSH
133021: LD_VAR 0 3
133025: PPUSH
133026: CALL 106901 0 3
133030: NOT
133031: PUSH
133032: LD_VAR 0 1
133036: PPUSH
133037: CALL_OW 314
133041: AND
133042: IFFALSE 133046
// exit ;
133044: GO 133185
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
133046: LD_VAR 0 2
133050: PPUSH
133051: LD_VAR 0 3
133055: PPUSH
133056: CALL_OW 428
133060: PUSH
133061: LD_VAR 0 1
133065: EQUAL
133066: PUSH
133067: LD_VAR 0 1
133071: PPUSH
133072: CALL_OW 314
133076: NOT
133077: AND
133078: IFFALSE 133004
// PlaySoundXY ( x , y , PlantMine ) ;
133080: LD_VAR 0 2
133084: PPUSH
133085: LD_VAR 0 3
133089: PPUSH
133090: LD_STRING PlantMine
133092: PPUSH
133093: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
133097: LD_VAR 0 2
133101: PPUSH
133102: LD_VAR 0 3
133106: PPUSH
133107: LD_VAR 0 1
133111: PPUSH
133112: CALL_OW 255
133116: PPUSH
133117: LD_INT 0
133119: PPUSH
133120: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
133124: LD_ADDR_EXP 218
133128: PUSH
133129: LD_EXP 218
133133: PPUSH
133134: LD_VAR 0 5
133138: PUSH
133139: LD_EXP 218
133143: PUSH
133144: LD_VAR 0 5
133148: ARRAY
133149: PUSH
133150: LD_INT 1
133152: PLUS
133153: PUSH
133154: EMPTY
133155: LIST
133156: LIST
133157: PPUSH
133158: LD_VAR 0 2
133162: PUSH
133163: LD_VAR 0 3
133167: PUSH
133168: EMPTY
133169: LIST
133170: LIST
133171: PPUSH
133172: CALL 75355 0 3
133176: ST_TO_ADDR
// result := true ;
133177: LD_ADDR_VAR 0 4
133181: PUSH
133182: LD_INT 1
133184: ST_TO_ADDR
// end ;
133185: LD_VAR 0 4
133189: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
133190: LD_INT 0
133192: PPUSH
133193: PPUSH
133194: PPUSH
// if not unit in minersList then
133195: LD_VAR 0 1
133199: PUSH
133200: LD_EXP 217
133204: IN
133205: NOT
133206: IFFALSE 133210
// exit ;
133208: GO 133602
// index := GetElementIndex ( minersList , unit ) ;
133210: LD_ADDR_VAR 0 6
133214: PUSH
133215: LD_EXP 217
133219: PPUSH
133220: LD_VAR 0 1
133224: PPUSH
133225: CALL 75140 0 2
133229: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
133230: LD_ADDR_VAR 0 5
133234: PUSH
133235: DOUBLE
133236: LD_EXP 218
133240: PUSH
133241: LD_VAR 0 6
133245: ARRAY
133246: INC
133247: ST_TO_ADDR
133248: LD_INT 1
133250: PUSH
133251: FOR_DOWNTO
133252: IFFALSE 133413
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
133254: LD_EXP 218
133258: PUSH
133259: LD_VAR 0 6
133263: ARRAY
133264: PUSH
133265: LD_VAR 0 5
133269: ARRAY
133270: PUSH
133271: LD_INT 1
133273: ARRAY
133274: PUSH
133275: LD_VAR 0 2
133279: EQUAL
133280: PUSH
133281: LD_EXP 218
133285: PUSH
133286: LD_VAR 0 6
133290: ARRAY
133291: PUSH
133292: LD_VAR 0 5
133296: ARRAY
133297: PUSH
133298: LD_INT 2
133300: ARRAY
133301: PUSH
133302: LD_VAR 0 3
133306: EQUAL
133307: AND
133308: IFFALSE 133411
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133310: LD_EXP 218
133314: PUSH
133315: LD_VAR 0 6
133319: ARRAY
133320: PUSH
133321: LD_VAR 0 5
133325: ARRAY
133326: PUSH
133327: LD_INT 1
133329: ARRAY
133330: PPUSH
133331: LD_EXP 218
133335: PUSH
133336: LD_VAR 0 6
133340: ARRAY
133341: PUSH
133342: LD_VAR 0 5
133346: ARRAY
133347: PUSH
133348: LD_INT 2
133350: ARRAY
133351: PPUSH
133352: LD_VAR 0 1
133356: PPUSH
133357: CALL_OW 255
133361: PPUSH
133362: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133366: LD_ADDR_EXP 218
133370: PUSH
133371: LD_EXP 218
133375: PPUSH
133376: LD_VAR 0 6
133380: PPUSH
133381: LD_EXP 218
133385: PUSH
133386: LD_VAR 0 6
133390: ARRAY
133391: PPUSH
133392: LD_VAR 0 5
133396: PPUSH
133397: CALL_OW 3
133401: PPUSH
133402: CALL_OW 1
133406: ST_TO_ADDR
// exit ;
133407: POP
133408: POP
133409: GO 133602
// end ; end ;
133411: GO 133251
133413: POP
133414: POP
// for i := minerMinesList [ index ] downto 1 do
133415: LD_ADDR_VAR 0 5
133419: PUSH
133420: DOUBLE
133421: LD_EXP 218
133425: PUSH
133426: LD_VAR 0 6
133430: ARRAY
133431: INC
133432: ST_TO_ADDR
133433: LD_INT 1
133435: PUSH
133436: FOR_DOWNTO
133437: IFFALSE 133600
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
133439: LD_EXP 218
133443: PUSH
133444: LD_VAR 0 6
133448: ARRAY
133449: PUSH
133450: LD_VAR 0 5
133454: ARRAY
133455: PUSH
133456: LD_INT 1
133458: ARRAY
133459: PPUSH
133460: LD_EXP 218
133464: PUSH
133465: LD_VAR 0 6
133469: ARRAY
133470: PUSH
133471: LD_VAR 0 5
133475: ARRAY
133476: PUSH
133477: LD_INT 2
133479: ARRAY
133480: PPUSH
133481: LD_VAR 0 2
133485: PPUSH
133486: LD_VAR 0 3
133490: PPUSH
133491: CALL_OW 298
133495: PUSH
133496: LD_INT 6
133498: LESS
133499: IFFALSE 133598
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
133501: LD_EXP 218
133505: PUSH
133506: LD_VAR 0 6
133510: ARRAY
133511: PUSH
133512: LD_VAR 0 5
133516: ARRAY
133517: PUSH
133518: LD_INT 1
133520: ARRAY
133521: PPUSH
133522: LD_EXP 218
133526: PUSH
133527: LD_VAR 0 6
133531: ARRAY
133532: PUSH
133533: LD_VAR 0 5
133537: ARRAY
133538: PUSH
133539: LD_INT 2
133541: ARRAY
133542: PPUSH
133543: LD_VAR 0 1
133547: PPUSH
133548: CALL_OW 255
133552: PPUSH
133553: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
133557: LD_ADDR_EXP 218
133561: PUSH
133562: LD_EXP 218
133566: PPUSH
133567: LD_VAR 0 6
133571: PPUSH
133572: LD_EXP 218
133576: PUSH
133577: LD_VAR 0 6
133581: ARRAY
133582: PPUSH
133583: LD_VAR 0 5
133587: PPUSH
133588: CALL_OW 3
133592: PPUSH
133593: CALL_OW 1
133597: ST_TO_ADDR
// end ; end ;
133598: GO 133436
133600: POP
133601: POP
// end ;
133602: LD_VAR 0 4
133606: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
133607: LD_INT 0
133609: PPUSH
133610: PPUSH
133611: PPUSH
133612: PPUSH
133613: PPUSH
133614: PPUSH
133615: PPUSH
133616: PPUSH
133617: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
133618: LD_VAR 0 1
133622: PPUSH
133623: CALL_OW 264
133627: PUSH
133628: LD_INT 81
133630: EQUAL
133631: NOT
133632: PUSH
133633: LD_VAR 0 1
133637: PUSH
133638: LD_EXP 217
133642: IN
133643: NOT
133644: OR
133645: IFFALSE 133649
// exit ;
133647: GO 133971
// index := GetElementIndex ( minersList , unit ) ;
133649: LD_ADDR_VAR 0 6
133653: PUSH
133654: LD_EXP 217
133658: PPUSH
133659: LD_VAR 0 1
133663: PPUSH
133664: CALL 75140 0 2
133668: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
133669: LD_ADDR_VAR 0 8
133673: PUSH
133674: LD_EXP 219
133678: PUSH
133679: LD_EXP 218
133683: PUSH
133684: LD_VAR 0 6
133688: ARRAY
133689: MINUS
133690: ST_TO_ADDR
// if not minesFreeAmount then
133691: LD_VAR 0 8
133695: NOT
133696: IFFALSE 133700
// exit ;
133698: GO 133971
// tmp := [ ] ;
133700: LD_ADDR_VAR 0 7
133704: PUSH
133705: EMPTY
133706: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
133707: LD_ADDR_VAR 0 5
133711: PUSH
133712: DOUBLE
133713: LD_INT 1
133715: DEC
133716: ST_TO_ADDR
133717: LD_VAR 0 8
133721: PUSH
133722: FOR_TO
133723: IFFALSE 133918
// begin _d := rand ( 0 , 5 ) ;
133725: LD_ADDR_VAR 0 11
133729: PUSH
133730: LD_INT 0
133732: PPUSH
133733: LD_INT 5
133735: PPUSH
133736: CALL_OW 12
133740: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
133741: LD_ADDR_VAR 0 12
133745: PUSH
133746: LD_INT 2
133748: PPUSH
133749: LD_INT 6
133751: PPUSH
133752: CALL_OW 12
133756: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
133757: LD_ADDR_VAR 0 9
133761: PUSH
133762: LD_VAR 0 2
133766: PPUSH
133767: LD_VAR 0 11
133771: PPUSH
133772: LD_VAR 0 12
133776: PPUSH
133777: CALL_OW 272
133781: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
133782: LD_ADDR_VAR 0 10
133786: PUSH
133787: LD_VAR 0 3
133791: PPUSH
133792: LD_VAR 0 11
133796: PPUSH
133797: LD_VAR 0 12
133801: PPUSH
133802: CALL_OW 273
133806: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
133807: LD_VAR 0 9
133811: PPUSH
133812: LD_VAR 0 10
133816: PPUSH
133817: CALL_OW 488
133821: PUSH
133822: LD_VAR 0 9
133826: PUSH
133827: LD_VAR 0 10
133831: PUSH
133832: EMPTY
133833: LIST
133834: LIST
133835: PUSH
133836: LD_VAR 0 7
133840: IN
133841: NOT
133842: AND
133843: PUSH
133844: LD_VAR 0 9
133848: PPUSH
133849: LD_VAR 0 10
133853: PPUSH
133854: CALL_OW 458
133858: NOT
133859: AND
133860: IFFALSE 133902
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
133862: LD_ADDR_VAR 0 7
133866: PUSH
133867: LD_VAR 0 7
133871: PPUSH
133872: LD_VAR 0 7
133876: PUSH
133877: LD_INT 1
133879: PLUS
133880: PPUSH
133881: LD_VAR 0 9
133885: PUSH
133886: LD_VAR 0 10
133890: PUSH
133891: EMPTY
133892: LIST
133893: LIST
133894: PPUSH
133895: CALL_OW 1
133899: ST_TO_ADDR
133900: GO 133916
// i := i - 1 ;
133902: LD_ADDR_VAR 0 5
133906: PUSH
133907: LD_VAR 0 5
133911: PUSH
133912: LD_INT 1
133914: MINUS
133915: ST_TO_ADDR
// end ;
133916: GO 133722
133918: POP
133919: POP
// for i in tmp do
133920: LD_ADDR_VAR 0 5
133924: PUSH
133925: LD_VAR 0 7
133929: PUSH
133930: FOR_IN
133931: IFFALSE 133969
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
133933: LD_VAR 0 1
133937: PPUSH
133938: LD_VAR 0 5
133942: PUSH
133943: LD_INT 1
133945: ARRAY
133946: PPUSH
133947: LD_VAR 0 5
133951: PUSH
133952: LD_INT 2
133954: ARRAY
133955: PPUSH
133956: CALL 132915 0 3
133960: NOT
133961: IFFALSE 133967
// exit ;
133963: POP
133964: POP
133965: GO 133971
133967: GO 133930
133969: POP
133970: POP
// end ;
133971: LD_VAR 0 4
133975: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
133976: LD_INT 0
133978: PPUSH
133979: PPUSH
133980: PPUSH
133981: PPUSH
133982: PPUSH
133983: PPUSH
133984: PPUSH
133985: PPUSH
133986: PPUSH
// if GetClass ( unit ) <> class_sniper then
133987: LD_VAR 0 1
133991: PPUSH
133992: CALL_OW 257
133996: PUSH
133997: LD_INT 5
133999: NONEQUAL
134000: IFFALSE 134004
// exit ;
134002: GO 134470
// dist := 8 ;
134004: LD_ADDR_VAR 0 5
134008: PUSH
134009: LD_INT 8
134011: ST_TO_ADDR
// viewRange := 12 ;
134012: LD_ADDR_VAR 0 8
134016: PUSH
134017: LD_INT 12
134019: ST_TO_ADDR
// side := GetSide ( unit ) ;
134020: LD_ADDR_VAR 0 6
134024: PUSH
134025: LD_VAR 0 1
134029: PPUSH
134030: CALL_OW 255
134034: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
134035: LD_INT 61
134037: PPUSH
134038: LD_VAR 0 6
134042: PPUSH
134043: CALL_OW 321
134047: PUSH
134048: LD_INT 2
134050: EQUAL
134051: IFFALSE 134061
// viewRange := 16 ;
134053: LD_ADDR_VAR 0 8
134057: PUSH
134058: LD_INT 16
134060: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
134061: LD_VAR 0 1
134065: PPUSH
134066: LD_VAR 0 2
134070: PPUSH
134071: LD_VAR 0 3
134075: PPUSH
134076: CALL_OW 297
134080: PUSH
134081: LD_VAR 0 5
134085: GREATER
134086: IFFALSE 134165
// begin ComMoveXY ( unit , x , y ) ;
134088: LD_VAR 0 1
134092: PPUSH
134093: LD_VAR 0 2
134097: PPUSH
134098: LD_VAR 0 3
134102: PPUSH
134103: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
134107: LD_INT 35
134109: PPUSH
134110: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
134114: LD_VAR 0 1
134118: PPUSH
134119: LD_VAR 0 2
134123: PPUSH
134124: LD_VAR 0 3
134128: PPUSH
134129: CALL 106901 0 3
134133: NOT
134134: IFFALSE 134138
// exit ;
134136: GO 134470
// until GetDistUnitXY ( unit , x , y ) < dist ;
134138: LD_VAR 0 1
134142: PPUSH
134143: LD_VAR 0 2
134147: PPUSH
134148: LD_VAR 0 3
134152: PPUSH
134153: CALL_OW 297
134157: PUSH
134158: LD_VAR 0 5
134162: LESS
134163: IFFALSE 134107
// end ; ComTurnXY ( unit , x , y ) ;
134165: LD_VAR 0 1
134169: PPUSH
134170: LD_VAR 0 2
134174: PPUSH
134175: LD_VAR 0 3
134179: PPUSH
134180: CALL_OW 118
// repeat if Multiplayer then
134184: LD_OWVAR 4
134188: IFFALSE 134199
// wait ( 35 ) else
134190: LD_INT 35
134192: PPUSH
134193: CALL_OW 67
134197: GO 134206
// wait ( 5 ) ;
134199: LD_INT 5
134201: PPUSH
134202: CALL_OW 67
// _d := GetDir ( unit ) ;
134206: LD_ADDR_VAR 0 11
134210: PUSH
134211: LD_VAR 0 1
134215: PPUSH
134216: CALL_OW 254
134220: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
134221: LD_ADDR_VAR 0 7
134225: PUSH
134226: LD_VAR 0 1
134230: PPUSH
134231: CALL_OW 250
134235: PPUSH
134236: LD_VAR 0 1
134240: PPUSH
134241: CALL_OW 251
134245: PPUSH
134246: LD_VAR 0 2
134250: PPUSH
134251: LD_VAR 0 3
134255: PPUSH
134256: CALL 109509 0 4
134260: ST_TO_ADDR
// until dir = _d ;
134261: LD_VAR 0 7
134265: PUSH
134266: LD_VAR 0 11
134270: EQUAL
134271: IFFALSE 134184
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
134273: LD_ADDR_VAR 0 9
134277: PUSH
134278: LD_VAR 0 1
134282: PPUSH
134283: CALL_OW 250
134287: PPUSH
134288: LD_VAR 0 7
134292: PPUSH
134293: LD_VAR 0 5
134297: PPUSH
134298: CALL_OW 272
134302: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
134303: LD_ADDR_VAR 0 10
134307: PUSH
134308: LD_VAR 0 1
134312: PPUSH
134313: CALL_OW 251
134317: PPUSH
134318: LD_VAR 0 7
134322: PPUSH
134323: LD_VAR 0 5
134327: PPUSH
134328: CALL_OW 273
134332: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
134333: LD_VAR 0 9
134337: PPUSH
134338: LD_VAR 0 10
134342: PPUSH
134343: CALL_OW 488
134347: NOT
134348: IFFALSE 134352
// exit ;
134350: GO 134470
// ComAnimCustom ( unit , 1 ) ;
134352: LD_VAR 0 1
134356: PPUSH
134357: LD_INT 1
134359: PPUSH
134360: CALL_OW 592
// p := 0 ;
134364: LD_ADDR_VAR 0 12
134368: PUSH
134369: LD_INT 0
134371: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
134372: LD_VAR 0 9
134376: PPUSH
134377: LD_VAR 0 10
134381: PPUSH
134382: LD_VAR 0 6
134386: PPUSH
134387: LD_VAR 0 8
134391: PPUSH
134392: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
134396: LD_INT 35
134398: PPUSH
134399: CALL_OW 67
// p := Inc ( p ) ;
134403: LD_ADDR_VAR 0 12
134407: PUSH
134408: LD_VAR 0 12
134412: PPUSH
134413: CALL 109465 0 1
134417: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
134418: LD_VAR 0 12
134422: PUSH
134423: LD_INT 3
134425: EQUAL
134426: PUSH
134427: LD_VAR 0 1
134431: PPUSH
134432: CALL_OW 302
134436: NOT
134437: OR
134438: PUSH
134439: LD_VAR 0 1
134443: PPUSH
134444: CALL_OW 301
134448: OR
134449: IFFALSE 134396
// RemoveSeeing ( _x , _y , side ) ;
134451: LD_VAR 0 9
134455: PPUSH
134456: LD_VAR 0 10
134460: PPUSH
134461: LD_VAR 0 6
134465: PPUSH
134466: CALL_OW 331
// end ; end_of_file
134470: LD_VAR 0 4
134474: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
134475: LD_INT 0
134477: PPUSH
134478: PPUSH
134479: PPUSH
134480: PPUSH
134481: PPUSH
134482: PPUSH
134483: PPUSH
134484: PPUSH
134485: PPUSH
134486: PPUSH
134487: PPUSH
134488: PPUSH
134489: PPUSH
134490: PPUSH
134491: PPUSH
134492: PPUSH
134493: PPUSH
134494: PPUSH
134495: PPUSH
134496: PPUSH
134497: PPUSH
134498: PPUSH
134499: PPUSH
134500: PPUSH
134501: PPUSH
134502: PPUSH
134503: PPUSH
134504: PPUSH
134505: PPUSH
134506: PPUSH
134507: PPUSH
134508: PPUSH
134509: PPUSH
134510: PPUSH
// if not list then
134511: LD_VAR 0 1
134515: NOT
134516: IFFALSE 134520
// exit ;
134518: GO 139179
// base := list [ 1 ] ;
134520: LD_ADDR_VAR 0 3
134524: PUSH
134525: LD_VAR 0 1
134529: PUSH
134530: LD_INT 1
134532: ARRAY
134533: ST_TO_ADDR
// group := list [ 2 ] ;
134534: LD_ADDR_VAR 0 4
134538: PUSH
134539: LD_VAR 0 1
134543: PUSH
134544: LD_INT 2
134546: ARRAY
134547: ST_TO_ADDR
// path := list [ 3 ] ;
134548: LD_ADDR_VAR 0 5
134552: PUSH
134553: LD_VAR 0 1
134557: PUSH
134558: LD_INT 3
134560: ARRAY
134561: ST_TO_ADDR
// flags := list [ 4 ] ;
134562: LD_ADDR_VAR 0 6
134566: PUSH
134567: LD_VAR 0 1
134571: PUSH
134572: LD_INT 4
134574: ARRAY
134575: ST_TO_ADDR
// mined := [ ] ;
134576: LD_ADDR_VAR 0 27
134580: PUSH
134581: EMPTY
134582: ST_TO_ADDR
// bombed := [ ] ;
134583: LD_ADDR_VAR 0 28
134587: PUSH
134588: EMPTY
134589: ST_TO_ADDR
// healers := [ ] ;
134590: LD_ADDR_VAR 0 31
134594: PUSH
134595: EMPTY
134596: ST_TO_ADDR
// to_heal := [ ] ;
134597: LD_ADDR_VAR 0 30
134601: PUSH
134602: EMPTY
134603: ST_TO_ADDR
// repairs := [ ] ;
134604: LD_ADDR_VAR 0 33
134608: PUSH
134609: EMPTY
134610: ST_TO_ADDR
// to_repair := [ ] ;
134611: LD_ADDR_VAR 0 32
134615: PUSH
134616: EMPTY
134617: ST_TO_ADDR
// if not group or not path then
134618: LD_VAR 0 4
134622: NOT
134623: PUSH
134624: LD_VAR 0 5
134628: NOT
134629: OR
134630: IFFALSE 134634
// exit ;
134632: GO 139179
// side := GetSide ( group [ 1 ] ) ;
134634: LD_ADDR_VAR 0 35
134638: PUSH
134639: LD_VAR 0 4
134643: PUSH
134644: LD_INT 1
134646: ARRAY
134647: PPUSH
134648: CALL_OW 255
134652: ST_TO_ADDR
// if flags then
134653: LD_VAR 0 6
134657: IFFALSE 134801
// begin f_ignore_area := flags [ 1 ] ;
134659: LD_ADDR_VAR 0 17
134663: PUSH
134664: LD_VAR 0 6
134668: PUSH
134669: LD_INT 1
134671: ARRAY
134672: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
134673: LD_ADDR_VAR 0 18
134677: PUSH
134678: LD_VAR 0 6
134682: PUSH
134683: LD_INT 2
134685: ARRAY
134686: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
134687: LD_ADDR_VAR 0 19
134691: PUSH
134692: LD_VAR 0 6
134696: PUSH
134697: LD_INT 3
134699: ARRAY
134700: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
134701: LD_ADDR_VAR 0 20
134705: PUSH
134706: LD_VAR 0 6
134710: PUSH
134711: LD_INT 4
134713: ARRAY
134714: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
134715: LD_ADDR_VAR 0 21
134719: PUSH
134720: LD_VAR 0 6
134724: PUSH
134725: LD_INT 5
134727: ARRAY
134728: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
134729: LD_ADDR_VAR 0 22
134733: PUSH
134734: LD_VAR 0 6
134738: PUSH
134739: LD_INT 6
134741: ARRAY
134742: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
134743: LD_ADDR_VAR 0 23
134747: PUSH
134748: LD_VAR 0 6
134752: PUSH
134753: LD_INT 7
134755: ARRAY
134756: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
134757: LD_ADDR_VAR 0 24
134761: PUSH
134762: LD_VAR 0 6
134766: PUSH
134767: LD_INT 8
134769: ARRAY
134770: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
134771: LD_ADDR_VAR 0 25
134775: PUSH
134776: LD_VAR 0 6
134780: PUSH
134781: LD_INT 9
134783: ARRAY
134784: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
134785: LD_ADDR_VAR 0 26
134789: PUSH
134790: LD_VAR 0 6
134794: PUSH
134795: LD_INT 10
134797: ARRAY
134798: ST_TO_ADDR
// end else
134799: GO 134881
// begin f_ignore_area := false ;
134801: LD_ADDR_VAR 0 17
134805: PUSH
134806: LD_INT 0
134808: ST_TO_ADDR
// f_capture := false ;
134809: LD_ADDR_VAR 0 18
134813: PUSH
134814: LD_INT 0
134816: ST_TO_ADDR
// f_ignore_civ := false ;
134817: LD_ADDR_VAR 0 19
134821: PUSH
134822: LD_INT 0
134824: ST_TO_ADDR
// f_murder := false ;
134825: LD_ADDR_VAR 0 20
134829: PUSH
134830: LD_INT 0
134832: ST_TO_ADDR
// f_mines := false ;
134833: LD_ADDR_VAR 0 21
134837: PUSH
134838: LD_INT 0
134840: ST_TO_ADDR
// f_repair := false ;
134841: LD_ADDR_VAR 0 22
134845: PUSH
134846: LD_INT 0
134848: ST_TO_ADDR
// f_heal := false ;
134849: LD_ADDR_VAR 0 23
134853: PUSH
134854: LD_INT 0
134856: ST_TO_ADDR
// f_spacetime := false ;
134857: LD_ADDR_VAR 0 24
134861: PUSH
134862: LD_INT 0
134864: ST_TO_ADDR
// f_attack_depot := false ;
134865: LD_ADDR_VAR 0 25
134869: PUSH
134870: LD_INT 0
134872: ST_TO_ADDR
// f_crawl := false ;
134873: LD_ADDR_VAR 0 26
134877: PUSH
134878: LD_INT 0
134880: ST_TO_ADDR
// end ; if f_heal then
134881: LD_VAR 0 23
134885: IFFALSE 134912
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
134887: LD_ADDR_VAR 0 31
134891: PUSH
134892: LD_VAR 0 4
134896: PPUSH
134897: LD_INT 25
134899: PUSH
134900: LD_INT 4
134902: PUSH
134903: EMPTY
134904: LIST
134905: LIST
134906: PPUSH
134907: CALL_OW 72
134911: ST_TO_ADDR
// if f_repair then
134912: LD_VAR 0 22
134916: IFFALSE 134943
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
134918: LD_ADDR_VAR 0 33
134922: PUSH
134923: LD_VAR 0 4
134927: PPUSH
134928: LD_INT 25
134930: PUSH
134931: LD_INT 3
134933: PUSH
134934: EMPTY
134935: LIST
134936: LIST
134937: PPUSH
134938: CALL_OW 72
134942: ST_TO_ADDR
// units_path := [ ] ;
134943: LD_ADDR_VAR 0 16
134947: PUSH
134948: EMPTY
134949: ST_TO_ADDR
// for i = 1 to group do
134950: LD_ADDR_VAR 0 7
134954: PUSH
134955: DOUBLE
134956: LD_INT 1
134958: DEC
134959: ST_TO_ADDR
134960: LD_VAR 0 4
134964: PUSH
134965: FOR_TO
134966: IFFALSE 134995
// units_path := Replace ( units_path , i , path ) ;
134968: LD_ADDR_VAR 0 16
134972: PUSH
134973: LD_VAR 0 16
134977: PPUSH
134978: LD_VAR 0 7
134982: PPUSH
134983: LD_VAR 0 5
134987: PPUSH
134988: CALL_OW 1
134992: ST_TO_ADDR
134993: GO 134965
134995: POP
134996: POP
// repeat for i = group downto 1 do
134997: LD_ADDR_VAR 0 7
135001: PUSH
135002: DOUBLE
135003: LD_VAR 0 4
135007: INC
135008: ST_TO_ADDR
135009: LD_INT 1
135011: PUSH
135012: FOR_DOWNTO
135013: IFFALSE 139135
// begin wait ( 5 ) ;
135015: LD_INT 5
135017: PPUSH
135018: CALL_OW 67
// tmp := [ ] ;
135022: LD_ADDR_VAR 0 14
135026: PUSH
135027: EMPTY
135028: ST_TO_ADDR
// attacking := false ;
135029: LD_ADDR_VAR 0 29
135033: PUSH
135034: LD_INT 0
135036: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
135037: LD_VAR 0 4
135041: PUSH
135042: LD_VAR 0 7
135046: ARRAY
135047: PPUSH
135048: CALL_OW 301
135052: PUSH
135053: LD_VAR 0 4
135057: PUSH
135058: LD_VAR 0 7
135062: ARRAY
135063: NOT
135064: OR
135065: IFFALSE 135174
// begin if GetType ( group [ i ] ) = unit_human then
135067: LD_VAR 0 4
135071: PUSH
135072: LD_VAR 0 7
135076: ARRAY
135077: PPUSH
135078: CALL_OW 247
135082: PUSH
135083: LD_INT 1
135085: EQUAL
135086: IFFALSE 135132
// begin to_heal := to_heal diff group [ i ] ;
135088: LD_ADDR_VAR 0 30
135092: PUSH
135093: LD_VAR 0 30
135097: PUSH
135098: LD_VAR 0 4
135102: PUSH
135103: LD_VAR 0 7
135107: ARRAY
135108: DIFF
135109: ST_TO_ADDR
// healers := healers diff group [ i ] ;
135110: LD_ADDR_VAR 0 31
135114: PUSH
135115: LD_VAR 0 31
135119: PUSH
135120: LD_VAR 0 4
135124: PUSH
135125: LD_VAR 0 7
135129: ARRAY
135130: DIFF
135131: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
135132: LD_ADDR_VAR 0 4
135136: PUSH
135137: LD_VAR 0 4
135141: PPUSH
135142: LD_VAR 0 7
135146: PPUSH
135147: CALL_OW 3
135151: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
135152: LD_ADDR_VAR 0 16
135156: PUSH
135157: LD_VAR 0 16
135161: PPUSH
135162: LD_VAR 0 7
135166: PPUSH
135167: CALL_OW 3
135171: ST_TO_ADDR
// continue ;
135172: GO 135012
// end ; if f_repair then
135174: LD_VAR 0 22
135178: IFFALSE 135667
// begin if GetType ( group [ i ] ) = unit_vehicle then
135180: LD_VAR 0 4
135184: PUSH
135185: LD_VAR 0 7
135189: ARRAY
135190: PPUSH
135191: CALL_OW 247
135195: PUSH
135196: LD_INT 2
135198: EQUAL
135199: IFFALSE 135389
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
135201: LD_VAR 0 4
135205: PUSH
135206: LD_VAR 0 7
135210: ARRAY
135211: PPUSH
135212: CALL_OW 256
135216: PUSH
135217: LD_INT 700
135219: LESS
135220: PUSH
135221: LD_VAR 0 4
135225: PUSH
135226: LD_VAR 0 7
135230: ARRAY
135231: PUSH
135232: LD_VAR 0 32
135236: IN
135237: NOT
135238: AND
135239: IFFALSE 135263
// to_repair := to_repair union group [ i ] ;
135241: LD_ADDR_VAR 0 32
135245: PUSH
135246: LD_VAR 0 32
135250: PUSH
135251: LD_VAR 0 4
135255: PUSH
135256: LD_VAR 0 7
135260: ARRAY
135261: UNION
135262: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
135263: LD_VAR 0 4
135267: PUSH
135268: LD_VAR 0 7
135272: ARRAY
135273: PPUSH
135274: CALL_OW 256
135278: PUSH
135279: LD_INT 1000
135281: EQUAL
135282: PUSH
135283: LD_VAR 0 4
135287: PUSH
135288: LD_VAR 0 7
135292: ARRAY
135293: PUSH
135294: LD_VAR 0 32
135298: IN
135299: AND
135300: IFFALSE 135324
// to_repair := to_repair diff group [ i ] ;
135302: LD_ADDR_VAR 0 32
135306: PUSH
135307: LD_VAR 0 32
135311: PUSH
135312: LD_VAR 0 4
135316: PUSH
135317: LD_VAR 0 7
135321: ARRAY
135322: DIFF
135323: ST_TO_ADDR
// if group [ i ] in to_repair then
135324: LD_VAR 0 4
135328: PUSH
135329: LD_VAR 0 7
135333: ARRAY
135334: PUSH
135335: LD_VAR 0 32
135339: IN
135340: IFFALSE 135387
// begin if not IsInArea ( group [ i ] , f_repair ) then
135342: LD_VAR 0 4
135346: PUSH
135347: LD_VAR 0 7
135351: ARRAY
135352: PPUSH
135353: LD_VAR 0 22
135357: PPUSH
135358: CALL_OW 308
135362: NOT
135363: IFFALSE 135385
// ComMoveToArea ( group [ i ] , f_repair ) ;
135365: LD_VAR 0 4
135369: PUSH
135370: LD_VAR 0 7
135374: ARRAY
135375: PPUSH
135376: LD_VAR 0 22
135380: PPUSH
135381: CALL_OW 113
// continue ;
135385: GO 135012
// end ; end else
135387: GO 135667
// if group [ i ] in repairs then
135389: LD_VAR 0 4
135393: PUSH
135394: LD_VAR 0 7
135398: ARRAY
135399: PUSH
135400: LD_VAR 0 33
135404: IN
135405: IFFALSE 135667
// begin if IsInUnit ( group [ i ] ) then
135407: LD_VAR 0 4
135411: PUSH
135412: LD_VAR 0 7
135416: ARRAY
135417: PPUSH
135418: CALL_OW 310
135422: IFFALSE 135490
// begin z := IsInUnit ( group [ i ] ) ;
135424: LD_ADDR_VAR 0 13
135428: PUSH
135429: LD_VAR 0 4
135433: PUSH
135434: LD_VAR 0 7
135438: ARRAY
135439: PPUSH
135440: CALL_OW 310
135444: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
135445: LD_VAR 0 13
135449: PUSH
135450: LD_VAR 0 32
135454: IN
135455: PUSH
135456: LD_VAR 0 13
135460: PPUSH
135461: LD_VAR 0 22
135465: PPUSH
135466: CALL_OW 308
135470: AND
135471: IFFALSE 135488
// ComExitVehicle ( group [ i ] ) ;
135473: LD_VAR 0 4
135477: PUSH
135478: LD_VAR 0 7
135482: ARRAY
135483: PPUSH
135484: CALL_OW 121
// end else
135488: GO 135667
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
135490: LD_ADDR_VAR 0 13
135494: PUSH
135495: LD_VAR 0 4
135499: PPUSH
135500: LD_INT 95
135502: PUSH
135503: LD_VAR 0 22
135507: PUSH
135508: EMPTY
135509: LIST
135510: LIST
135511: PUSH
135512: LD_INT 58
135514: PUSH
135515: EMPTY
135516: LIST
135517: PUSH
135518: EMPTY
135519: LIST
135520: LIST
135521: PPUSH
135522: CALL_OW 72
135526: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
135527: LD_VAR 0 4
135531: PUSH
135532: LD_VAR 0 7
135536: ARRAY
135537: PPUSH
135538: CALL_OW 314
135542: NOT
135543: IFFALSE 135665
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
135545: LD_ADDR_VAR 0 10
135549: PUSH
135550: LD_VAR 0 13
135554: PPUSH
135555: LD_VAR 0 4
135559: PUSH
135560: LD_VAR 0 7
135564: ARRAY
135565: PPUSH
135566: CALL_OW 74
135570: ST_TO_ADDR
// if not x then
135571: LD_VAR 0 10
135575: NOT
135576: IFFALSE 135580
// continue ;
135578: GO 135012
// if GetLives ( x ) < 1000 then
135580: LD_VAR 0 10
135584: PPUSH
135585: CALL_OW 256
135589: PUSH
135590: LD_INT 1000
135592: LESS
135593: IFFALSE 135617
// ComRepairVehicle ( group [ i ] , x ) else
135595: LD_VAR 0 4
135599: PUSH
135600: LD_VAR 0 7
135604: ARRAY
135605: PPUSH
135606: LD_VAR 0 10
135610: PPUSH
135611: CALL_OW 129
135615: GO 135665
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
135617: LD_VAR 0 23
135621: PUSH
135622: LD_VAR 0 4
135626: PUSH
135627: LD_VAR 0 7
135631: ARRAY
135632: PPUSH
135633: CALL_OW 256
135637: PUSH
135638: LD_INT 1000
135640: LESS
135641: AND
135642: NOT
135643: IFFALSE 135665
// ComEnterUnit ( group [ i ] , x ) ;
135645: LD_VAR 0 4
135649: PUSH
135650: LD_VAR 0 7
135654: ARRAY
135655: PPUSH
135656: LD_VAR 0 10
135660: PPUSH
135661: CALL_OW 120
// end ; continue ;
135665: GO 135012
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
135667: LD_VAR 0 23
135671: PUSH
135672: LD_VAR 0 4
135676: PUSH
135677: LD_VAR 0 7
135681: ARRAY
135682: PPUSH
135683: CALL_OW 247
135687: PUSH
135688: LD_INT 1
135690: EQUAL
135691: AND
135692: IFFALSE 136170
// begin if group [ i ] in healers then
135694: LD_VAR 0 4
135698: PUSH
135699: LD_VAR 0 7
135703: ARRAY
135704: PUSH
135705: LD_VAR 0 31
135709: IN
135710: IFFALSE 135983
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
135712: LD_VAR 0 4
135716: PUSH
135717: LD_VAR 0 7
135721: ARRAY
135722: PPUSH
135723: LD_VAR 0 23
135727: PPUSH
135728: CALL_OW 308
135732: NOT
135733: PUSH
135734: LD_VAR 0 4
135738: PUSH
135739: LD_VAR 0 7
135743: ARRAY
135744: PPUSH
135745: CALL_OW 314
135749: NOT
135750: AND
135751: IFFALSE 135775
// ComMoveToArea ( group [ i ] , f_heal ) else
135753: LD_VAR 0 4
135757: PUSH
135758: LD_VAR 0 7
135762: ARRAY
135763: PPUSH
135764: LD_VAR 0 23
135768: PPUSH
135769: CALL_OW 113
135773: GO 135981
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
135775: LD_VAR 0 4
135779: PUSH
135780: LD_VAR 0 7
135784: ARRAY
135785: PPUSH
135786: CALL 105484 0 1
135790: PPUSH
135791: CALL_OW 256
135795: PUSH
135796: LD_INT 1000
135798: EQUAL
135799: IFFALSE 135818
// ComStop ( group [ i ] ) else
135801: LD_VAR 0 4
135805: PUSH
135806: LD_VAR 0 7
135810: ARRAY
135811: PPUSH
135812: CALL_OW 141
135816: GO 135981
// if not HasTask ( group [ i ] ) and to_heal then
135818: LD_VAR 0 4
135822: PUSH
135823: LD_VAR 0 7
135827: ARRAY
135828: PPUSH
135829: CALL_OW 314
135833: NOT
135834: PUSH
135835: LD_VAR 0 30
135839: AND
135840: IFFALSE 135981
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
135842: LD_ADDR_VAR 0 13
135846: PUSH
135847: LD_VAR 0 30
135851: PPUSH
135852: LD_INT 3
135854: PUSH
135855: LD_INT 54
135857: PUSH
135858: EMPTY
135859: LIST
135860: PUSH
135861: EMPTY
135862: LIST
135863: LIST
135864: PPUSH
135865: CALL_OW 72
135869: PPUSH
135870: LD_VAR 0 4
135874: PUSH
135875: LD_VAR 0 7
135879: ARRAY
135880: PPUSH
135881: CALL_OW 74
135885: ST_TO_ADDR
// if z then
135886: LD_VAR 0 13
135890: IFFALSE 135981
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
135892: LD_INT 91
135894: PUSH
135895: LD_VAR 0 13
135899: PUSH
135900: LD_INT 10
135902: PUSH
135903: EMPTY
135904: LIST
135905: LIST
135906: LIST
135907: PUSH
135908: LD_INT 81
135910: PUSH
135911: LD_VAR 0 13
135915: PPUSH
135916: CALL_OW 255
135920: PUSH
135921: EMPTY
135922: LIST
135923: LIST
135924: PUSH
135925: EMPTY
135926: LIST
135927: LIST
135928: PPUSH
135929: CALL_OW 69
135933: PUSH
135934: LD_INT 0
135936: EQUAL
135937: IFFALSE 135961
// ComHeal ( group [ i ] , z ) else
135939: LD_VAR 0 4
135943: PUSH
135944: LD_VAR 0 7
135948: ARRAY
135949: PPUSH
135950: LD_VAR 0 13
135954: PPUSH
135955: CALL_OW 128
135959: GO 135981
// ComMoveToArea ( group [ i ] , f_heal ) ;
135961: LD_VAR 0 4
135965: PUSH
135966: LD_VAR 0 7
135970: ARRAY
135971: PPUSH
135972: LD_VAR 0 23
135976: PPUSH
135977: CALL_OW 113
// end ; continue ;
135981: GO 135012
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
135983: LD_VAR 0 4
135987: PUSH
135988: LD_VAR 0 7
135992: ARRAY
135993: PPUSH
135994: CALL_OW 256
135998: PUSH
135999: LD_INT 700
136001: LESS
136002: PUSH
136003: LD_VAR 0 4
136007: PUSH
136008: LD_VAR 0 7
136012: ARRAY
136013: PUSH
136014: LD_VAR 0 30
136018: IN
136019: NOT
136020: AND
136021: IFFALSE 136045
// to_heal := to_heal union group [ i ] ;
136023: LD_ADDR_VAR 0 30
136027: PUSH
136028: LD_VAR 0 30
136032: PUSH
136033: LD_VAR 0 4
136037: PUSH
136038: LD_VAR 0 7
136042: ARRAY
136043: UNION
136044: ST_TO_ADDR
// if group [ i ] in to_heal then
136045: LD_VAR 0 4
136049: PUSH
136050: LD_VAR 0 7
136054: ARRAY
136055: PUSH
136056: LD_VAR 0 30
136060: IN
136061: IFFALSE 136170
// begin if GetLives ( group [ i ] ) = 1000 then
136063: LD_VAR 0 4
136067: PUSH
136068: LD_VAR 0 7
136072: ARRAY
136073: PPUSH
136074: CALL_OW 256
136078: PUSH
136079: LD_INT 1000
136081: EQUAL
136082: IFFALSE 136108
// to_heal := to_heal diff group [ i ] else
136084: LD_ADDR_VAR 0 30
136088: PUSH
136089: LD_VAR 0 30
136093: PUSH
136094: LD_VAR 0 4
136098: PUSH
136099: LD_VAR 0 7
136103: ARRAY
136104: DIFF
136105: ST_TO_ADDR
136106: GO 136170
// begin if not IsInArea ( group [ i ] , to_heal ) then
136108: LD_VAR 0 4
136112: PUSH
136113: LD_VAR 0 7
136117: ARRAY
136118: PPUSH
136119: LD_VAR 0 30
136123: PPUSH
136124: CALL_OW 308
136128: NOT
136129: IFFALSE 136153
// ComMoveToArea ( group [ i ] , f_heal ) else
136131: LD_VAR 0 4
136135: PUSH
136136: LD_VAR 0 7
136140: ARRAY
136141: PPUSH
136142: LD_VAR 0 23
136146: PPUSH
136147: CALL_OW 113
136151: GO 136168
// ComHold ( group [ i ] ) ;
136153: LD_VAR 0 4
136157: PUSH
136158: LD_VAR 0 7
136162: ARRAY
136163: PPUSH
136164: CALL_OW 140
// continue ;
136168: GO 135012
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
136170: LD_VAR 0 4
136174: PUSH
136175: LD_VAR 0 7
136179: ARRAY
136180: PPUSH
136181: LD_INT 10
136183: PPUSH
136184: CALL 103246 0 2
136188: NOT
136189: PUSH
136190: LD_VAR 0 16
136194: PUSH
136195: LD_VAR 0 7
136199: ARRAY
136200: PUSH
136201: EMPTY
136202: EQUAL
136203: NOT
136204: AND
136205: IFFALSE 136471
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
136207: LD_VAR 0 4
136211: PUSH
136212: LD_VAR 0 7
136216: ARRAY
136217: PPUSH
136218: CALL_OW 262
136222: PUSH
136223: LD_INT 1
136225: PUSH
136226: LD_INT 2
136228: PUSH
136229: EMPTY
136230: LIST
136231: LIST
136232: IN
136233: IFFALSE 136274
// if GetFuel ( group [ i ] ) < 10 then
136235: LD_VAR 0 4
136239: PUSH
136240: LD_VAR 0 7
136244: ARRAY
136245: PPUSH
136246: CALL_OW 261
136250: PUSH
136251: LD_INT 10
136253: LESS
136254: IFFALSE 136274
// SetFuel ( group [ i ] , 12 ) ;
136256: LD_VAR 0 4
136260: PUSH
136261: LD_VAR 0 7
136265: ARRAY
136266: PPUSH
136267: LD_INT 12
136269: PPUSH
136270: CALL_OW 240
// if units_path [ i ] then
136274: LD_VAR 0 16
136278: PUSH
136279: LD_VAR 0 7
136283: ARRAY
136284: IFFALSE 136469
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
136286: LD_VAR 0 4
136290: PUSH
136291: LD_VAR 0 7
136295: ARRAY
136296: PPUSH
136297: LD_VAR 0 16
136301: PUSH
136302: LD_VAR 0 7
136306: ARRAY
136307: PUSH
136308: LD_INT 1
136310: ARRAY
136311: PUSH
136312: LD_INT 1
136314: ARRAY
136315: PPUSH
136316: LD_VAR 0 16
136320: PUSH
136321: LD_VAR 0 7
136325: ARRAY
136326: PUSH
136327: LD_INT 1
136329: ARRAY
136330: PUSH
136331: LD_INT 2
136333: ARRAY
136334: PPUSH
136335: CALL_OW 297
136339: PUSH
136340: LD_INT 6
136342: GREATER
136343: IFFALSE 136418
// begin if not HasTask ( group [ i ] ) then
136345: LD_VAR 0 4
136349: PUSH
136350: LD_VAR 0 7
136354: ARRAY
136355: PPUSH
136356: CALL_OW 314
136360: NOT
136361: IFFALSE 136416
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
136363: LD_VAR 0 4
136367: PUSH
136368: LD_VAR 0 7
136372: ARRAY
136373: PPUSH
136374: LD_VAR 0 16
136378: PUSH
136379: LD_VAR 0 7
136383: ARRAY
136384: PUSH
136385: LD_INT 1
136387: ARRAY
136388: PUSH
136389: LD_INT 1
136391: ARRAY
136392: PPUSH
136393: LD_VAR 0 16
136397: PUSH
136398: LD_VAR 0 7
136402: ARRAY
136403: PUSH
136404: LD_INT 1
136406: ARRAY
136407: PUSH
136408: LD_INT 2
136410: ARRAY
136411: PPUSH
136412: CALL_OW 114
// end else
136416: GO 136469
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
136418: LD_ADDR_VAR 0 15
136422: PUSH
136423: LD_VAR 0 16
136427: PUSH
136428: LD_VAR 0 7
136432: ARRAY
136433: PPUSH
136434: LD_INT 1
136436: PPUSH
136437: CALL_OW 3
136441: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
136442: LD_ADDR_VAR 0 16
136446: PUSH
136447: LD_VAR 0 16
136451: PPUSH
136452: LD_VAR 0 7
136456: PPUSH
136457: LD_VAR 0 15
136461: PPUSH
136462: CALL_OW 1
136466: ST_TO_ADDR
// continue ;
136467: GO 135012
// end ; end ; end else
136469: GO 139133
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
136471: LD_ADDR_VAR 0 14
136475: PUSH
136476: LD_INT 81
136478: PUSH
136479: LD_VAR 0 4
136483: PUSH
136484: LD_VAR 0 7
136488: ARRAY
136489: PPUSH
136490: CALL_OW 255
136494: PUSH
136495: EMPTY
136496: LIST
136497: LIST
136498: PPUSH
136499: CALL_OW 69
136503: ST_TO_ADDR
// if not tmp then
136504: LD_VAR 0 14
136508: NOT
136509: IFFALSE 136513
// continue ;
136511: GO 135012
// if f_ignore_area then
136513: LD_VAR 0 17
136517: IFFALSE 136605
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
136519: LD_ADDR_VAR 0 15
136523: PUSH
136524: LD_VAR 0 14
136528: PPUSH
136529: LD_INT 3
136531: PUSH
136532: LD_INT 92
136534: PUSH
136535: LD_VAR 0 17
136539: PUSH
136540: LD_INT 1
136542: ARRAY
136543: PUSH
136544: LD_VAR 0 17
136548: PUSH
136549: LD_INT 2
136551: ARRAY
136552: PUSH
136553: LD_VAR 0 17
136557: PUSH
136558: LD_INT 3
136560: ARRAY
136561: PUSH
136562: EMPTY
136563: LIST
136564: LIST
136565: LIST
136566: LIST
136567: PUSH
136568: EMPTY
136569: LIST
136570: LIST
136571: PPUSH
136572: CALL_OW 72
136576: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136577: LD_VAR 0 14
136581: PUSH
136582: LD_VAR 0 15
136586: DIFF
136587: IFFALSE 136605
// tmp := tmp diff tmp2 ;
136589: LD_ADDR_VAR 0 14
136593: PUSH
136594: LD_VAR 0 14
136598: PUSH
136599: LD_VAR 0 15
136603: DIFF
136604: ST_TO_ADDR
// end ; if not f_murder then
136605: LD_VAR 0 20
136609: NOT
136610: IFFALSE 136668
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
136612: LD_ADDR_VAR 0 15
136616: PUSH
136617: LD_VAR 0 14
136621: PPUSH
136622: LD_INT 3
136624: PUSH
136625: LD_INT 50
136627: PUSH
136628: EMPTY
136629: LIST
136630: PUSH
136631: EMPTY
136632: LIST
136633: LIST
136634: PPUSH
136635: CALL_OW 72
136639: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
136640: LD_VAR 0 14
136644: PUSH
136645: LD_VAR 0 15
136649: DIFF
136650: IFFALSE 136668
// tmp := tmp diff tmp2 ;
136652: LD_ADDR_VAR 0 14
136656: PUSH
136657: LD_VAR 0 14
136661: PUSH
136662: LD_VAR 0 15
136666: DIFF
136667: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
136668: LD_ADDR_VAR 0 14
136672: PUSH
136673: LD_VAR 0 4
136677: PUSH
136678: LD_VAR 0 7
136682: ARRAY
136683: PPUSH
136684: LD_VAR 0 14
136688: PPUSH
136689: LD_INT 1
136691: PPUSH
136692: LD_INT 1
136694: PPUSH
136695: CALL 75790 0 4
136699: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
136700: LD_VAR 0 4
136704: PUSH
136705: LD_VAR 0 7
136709: ARRAY
136710: PPUSH
136711: CALL_OW 257
136715: PUSH
136716: LD_INT 1
136718: EQUAL
136719: IFFALSE 137167
// begin if WantPlant ( group [ i ] ) then
136721: LD_VAR 0 4
136725: PUSH
136726: LD_VAR 0 7
136730: ARRAY
136731: PPUSH
136732: CALL 75291 0 1
136736: IFFALSE 136740
// continue ;
136738: GO 135012
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
136740: LD_VAR 0 18
136744: PUSH
136745: LD_VAR 0 4
136749: PUSH
136750: LD_VAR 0 7
136754: ARRAY
136755: PPUSH
136756: CALL_OW 310
136760: NOT
136761: AND
136762: PUSH
136763: LD_VAR 0 14
136767: PUSH
136768: LD_INT 1
136770: ARRAY
136771: PUSH
136772: LD_VAR 0 14
136776: PPUSH
136777: LD_INT 21
136779: PUSH
136780: LD_INT 2
136782: PUSH
136783: EMPTY
136784: LIST
136785: LIST
136786: PUSH
136787: LD_INT 58
136789: PUSH
136790: EMPTY
136791: LIST
136792: PUSH
136793: EMPTY
136794: LIST
136795: LIST
136796: PPUSH
136797: CALL_OW 72
136801: IN
136802: AND
136803: IFFALSE 136839
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
136805: LD_VAR 0 4
136809: PUSH
136810: LD_VAR 0 7
136814: ARRAY
136815: PPUSH
136816: LD_VAR 0 14
136820: PUSH
136821: LD_INT 1
136823: ARRAY
136824: PPUSH
136825: CALL_OW 120
// attacking := true ;
136829: LD_ADDR_VAR 0 29
136833: PUSH
136834: LD_INT 1
136836: ST_TO_ADDR
// continue ;
136837: GO 135012
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
136839: LD_VAR 0 26
136843: PUSH
136844: LD_VAR 0 4
136848: PUSH
136849: LD_VAR 0 7
136853: ARRAY
136854: PPUSH
136855: CALL_OW 257
136859: PUSH
136860: LD_INT 1
136862: EQUAL
136863: AND
136864: PUSH
136865: LD_VAR 0 4
136869: PUSH
136870: LD_VAR 0 7
136874: ARRAY
136875: PPUSH
136876: CALL_OW 256
136880: PUSH
136881: LD_INT 800
136883: LESS
136884: AND
136885: PUSH
136886: LD_VAR 0 4
136890: PUSH
136891: LD_VAR 0 7
136895: ARRAY
136896: PPUSH
136897: CALL_OW 318
136901: NOT
136902: AND
136903: IFFALSE 136920
// ComCrawl ( group [ i ] ) ;
136905: LD_VAR 0 4
136909: PUSH
136910: LD_VAR 0 7
136914: ARRAY
136915: PPUSH
136916: CALL_OW 137
// if f_mines then
136920: LD_VAR 0 21
136924: IFFALSE 137167
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
136926: LD_VAR 0 14
136930: PUSH
136931: LD_INT 1
136933: ARRAY
136934: PPUSH
136935: CALL_OW 247
136939: PUSH
136940: LD_INT 3
136942: EQUAL
136943: PUSH
136944: LD_VAR 0 14
136948: PUSH
136949: LD_INT 1
136951: ARRAY
136952: PUSH
136953: LD_VAR 0 27
136957: IN
136958: NOT
136959: AND
136960: IFFALSE 137167
// begin x := GetX ( tmp [ 1 ] ) ;
136962: LD_ADDR_VAR 0 10
136966: PUSH
136967: LD_VAR 0 14
136971: PUSH
136972: LD_INT 1
136974: ARRAY
136975: PPUSH
136976: CALL_OW 250
136980: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
136981: LD_ADDR_VAR 0 11
136985: PUSH
136986: LD_VAR 0 14
136990: PUSH
136991: LD_INT 1
136993: ARRAY
136994: PPUSH
136995: CALL_OW 251
136999: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
137000: LD_ADDR_VAR 0 12
137004: PUSH
137005: LD_VAR 0 4
137009: PUSH
137010: LD_VAR 0 7
137014: ARRAY
137015: PPUSH
137016: CALL 103331 0 1
137020: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
137021: LD_VAR 0 4
137025: PUSH
137026: LD_VAR 0 7
137030: ARRAY
137031: PPUSH
137032: LD_VAR 0 10
137036: PPUSH
137037: LD_VAR 0 11
137041: PPUSH
137042: LD_VAR 0 14
137046: PUSH
137047: LD_INT 1
137049: ARRAY
137050: PPUSH
137051: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
137055: LD_VAR 0 4
137059: PUSH
137060: LD_VAR 0 7
137064: ARRAY
137065: PPUSH
137066: LD_VAR 0 10
137070: PPUSH
137071: LD_VAR 0 12
137075: PPUSH
137076: LD_INT 7
137078: PPUSH
137079: CALL_OW 272
137083: PPUSH
137084: LD_VAR 0 11
137088: PPUSH
137089: LD_VAR 0 12
137093: PPUSH
137094: LD_INT 7
137096: PPUSH
137097: CALL_OW 273
137101: PPUSH
137102: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
137106: LD_VAR 0 4
137110: PUSH
137111: LD_VAR 0 7
137115: ARRAY
137116: PPUSH
137117: LD_INT 71
137119: PPUSH
137120: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
137124: LD_ADDR_VAR 0 27
137128: PUSH
137129: LD_VAR 0 27
137133: PPUSH
137134: LD_VAR 0 27
137138: PUSH
137139: LD_INT 1
137141: PLUS
137142: PPUSH
137143: LD_VAR 0 14
137147: PUSH
137148: LD_INT 1
137150: ARRAY
137151: PPUSH
137152: CALL_OW 1
137156: ST_TO_ADDR
// attacking := true ;
137157: LD_ADDR_VAR 0 29
137161: PUSH
137162: LD_INT 1
137164: ST_TO_ADDR
// continue ;
137165: GO 135012
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
137167: LD_VAR 0 4
137171: PUSH
137172: LD_VAR 0 7
137176: ARRAY
137177: PPUSH
137178: CALL_OW 257
137182: PUSH
137183: LD_INT 17
137185: EQUAL
137186: PUSH
137187: LD_VAR 0 4
137191: PUSH
137192: LD_VAR 0 7
137196: ARRAY
137197: PPUSH
137198: CALL_OW 110
137202: PUSH
137203: LD_INT 71
137205: EQUAL
137206: NOT
137207: AND
137208: IFFALSE 137354
// begin attacking := false ;
137210: LD_ADDR_VAR 0 29
137214: PUSH
137215: LD_INT 0
137217: ST_TO_ADDR
// k := 5 ;
137218: LD_ADDR_VAR 0 9
137222: PUSH
137223: LD_INT 5
137225: ST_TO_ADDR
// if tmp < k then
137226: LD_VAR 0 14
137230: PUSH
137231: LD_VAR 0 9
137235: LESS
137236: IFFALSE 137248
// k := tmp ;
137238: LD_ADDR_VAR 0 9
137242: PUSH
137243: LD_VAR 0 14
137247: ST_TO_ADDR
// for j = 1 to k do
137248: LD_ADDR_VAR 0 8
137252: PUSH
137253: DOUBLE
137254: LD_INT 1
137256: DEC
137257: ST_TO_ADDR
137258: LD_VAR 0 9
137262: PUSH
137263: FOR_TO
137264: IFFALSE 137352
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
137266: LD_VAR 0 14
137270: PUSH
137271: LD_VAR 0 8
137275: ARRAY
137276: PUSH
137277: LD_VAR 0 14
137281: PPUSH
137282: LD_INT 58
137284: PUSH
137285: EMPTY
137286: LIST
137287: PPUSH
137288: CALL_OW 72
137292: IN
137293: NOT
137294: IFFALSE 137350
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137296: LD_VAR 0 4
137300: PUSH
137301: LD_VAR 0 7
137305: ARRAY
137306: PPUSH
137307: LD_VAR 0 14
137311: PUSH
137312: LD_VAR 0 8
137316: ARRAY
137317: PPUSH
137318: CALL_OW 115
// attacking := true ;
137322: LD_ADDR_VAR 0 29
137326: PUSH
137327: LD_INT 1
137329: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
137330: LD_VAR 0 4
137334: PUSH
137335: LD_VAR 0 7
137339: ARRAY
137340: PPUSH
137341: LD_INT 71
137343: PPUSH
137344: CALL_OW 109
// continue ;
137348: GO 137263
// end ; end ;
137350: GO 137263
137352: POP
137353: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
137354: LD_VAR 0 4
137358: PUSH
137359: LD_VAR 0 7
137363: ARRAY
137364: PPUSH
137365: CALL_OW 257
137369: PUSH
137370: LD_INT 8
137372: EQUAL
137373: PUSH
137374: LD_VAR 0 4
137378: PUSH
137379: LD_VAR 0 7
137383: ARRAY
137384: PPUSH
137385: CALL_OW 264
137389: PUSH
137390: LD_INT 28
137392: PUSH
137393: LD_INT 45
137395: PUSH
137396: LD_INT 7
137398: PUSH
137399: LD_INT 47
137401: PUSH
137402: EMPTY
137403: LIST
137404: LIST
137405: LIST
137406: LIST
137407: IN
137408: OR
137409: IFFALSE 137665
// begin attacking := false ;
137411: LD_ADDR_VAR 0 29
137415: PUSH
137416: LD_INT 0
137418: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
137419: LD_VAR 0 14
137423: PUSH
137424: LD_INT 1
137426: ARRAY
137427: PPUSH
137428: CALL_OW 266
137432: PUSH
137433: LD_INT 32
137435: PUSH
137436: LD_INT 31
137438: PUSH
137439: LD_INT 33
137441: PUSH
137442: LD_INT 4
137444: PUSH
137445: LD_INT 5
137447: PUSH
137448: EMPTY
137449: LIST
137450: LIST
137451: LIST
137452: LIST
137453: LIST
137454: IN
137455: IFFALSE 137641
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
137457: LD_ADDR_VAR 0 9
137461: PUSH
137462: LD_VAR 0 14
137466: PUSH
137467: LD_INT 1
137469: ARRAY
137470: PPUSH
137471: CALL_OW 266
137475: PPUSH
137476: LD_VAR 0 14
137480: PUSH
137481: LD_INT 1
137483: ARRAY
137484: PPUSH
137485: CALL_OW 250
137489: PPUSH
137490: LD_VAR 0 14
137494: PUSH
137495: LD_INT 1
137497: ARRAY
137498: PPUSH
137499: CALL_OW 251
137503: PPUSH
137504: LD_VAR 0 14
137508: PUSH
137509: LD_INT 1
137511: ARRAY
137512: PPUSH
137513: CALL_OW 254
137517: PPUSH
137518: LD_VAR 0 14
137522: PUSH
137523: LD_INT 1
137525: ARRAY
137526: PPUSH
137527: CALL_OW 248
137531: PPUSH
137532: LD_INT 0
137534: PPUSH
137535: CALL 84701 0 6
137539: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
137540: LD_ADDR_VAR 0 8
137544: PUSH
137545: LD_VAR 0 4
137549: PUSH
137550: LD_VAR 0 7
137554: ARRAY
137555: PPUSH
137556: LD_VAR 0 9
137560: PPUSH
137561: CALL 103444 0 2
137565: ST_TO_ADDR
// if j then
137566: LD_VAR 0 8
137570: IFFALSE 137639
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
137572: LD_VAR 0 8
137576: PUSH
137577: LD_INT 1
137579: ARRAY
137580: PPUSH
137581: LD_VAR 0 8
137585: PUSH
137586: LD_INT 2
137588: ARRAY
137589: PPUSH
137590: CALL_OW 488
137594: IFFALSE 137639
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
137596: LD_VAR 0 4
137600: PUSH
137601: LD_VAR 0 7
137605: ARRAY
137606: PPUSH
137607: LD_VAR 0 8
137611: PUSH
137612: LD_INT 1
137614: ARRAY
137615: PPUSH
137616: LD_VAR 0 8
137620: PUSH
137621: LD_INT 2
137623: ARRAY
137624: PPUSH
137625: CALL_OW 116
// attacking := true ;
137629: LD_ADDR_VAR 0 29
137633: PUSH
137634: LD_INT 1
137636: ST_TO_ADDR
// continue ;
137637: GO 135012
// end ; end else
137639: GO 137665
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137641: LD_VAR 0 4
137645: PUSH
137646: LD_VAR 0 7
137650: ARRAY
137651: PPUSH
137652: LD_VAR 0 14
137656: PUSH
137657: LD_INT 1
137659: ARRAY
137660: PPUSH
137661: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
137665: LD_VAR 0 4
137669: PUSH
137670: LD_VAR 0 7
137674: ARRAY
137675: PPUSH
137676: CALL_OW 265
137680: PUSH
137681: LD_INT 11
137683: EQUAL
137684: IFFALSE 137962
// begin k := 10 ;
137686: LD_ADDR_VAR 0 9
137690: PUSH
137691: LD_INT 10
137693: ST_TO_ADDR
// x := 0 ;
137694: LD_ADDR_VAR 0 10
137698: PUSH
137699: LD_INT 0
137701: ST_TO_ADDR
// if tmp < k then
137702: LD_VAR 0 14
137706: PUSH
137707: LD_VAR 0 9
137711: LESS
137712: IFFALSE 137724
// k := tmp ;
137714: LD_ADDR_VAR 0 9
137718: PUSH
137719: LD_VAR 0 14
137723: ST_TO_ADDR
// for j = k downto 1 do
137724: LD_ADDR_VAR 0 8
137728: PUSH
137729: DOUBLE
137730: LD_VAR 0 9
137734: INC
137735: ST_TO_ADDR
137736: LD_INT 1
137738: PUSH
137739: FOR_DOWNTO
137740: IFFALSE 137815
// begin if GetType ( tmp [ j ] ) = unit_human then
137742: LD_VAR 0 14
137746: PUSH
137747: LD_VAR 0 8
137751: ARRAY
137752: PPUSH
137753: CALL_OW 247
137757: PUSH
137758: LD_INT 1
137760: EQUAL
137761: IFFALSE 137813
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
137763: LD_VAR 0 4
137767: PUSH
137768: LD_VAR 0 7
137772: ARRAY
137773: PPUSH
137774: LD_VAR 0 14
137778: PUSH
137779: LD_VAR 0 8
137783: ARRAY
137784: PPUSH
137785: CALL 103698 0 2
// x := tmp [ j ] ;
137789: LD_ADDR_VAR 0 10
137793: PUSH
137794: LD_VAR 0 14
137798: PUSH
137799: LD_VAR 0 8
137803: ARRAY
137804: ST_TO_ADDR
// attacking := true ;
137805: LD_ADDR_VAR 0 29
137809: PUSH
137810: LD_INT 1
137812: ST_TO_ADDR
// end ; end ;
137813: GO 137739
137815: POP
137816: POP
// if not x then
137817: LD_VAR 0 10
137821: NOT
137822: IFFALSE 137962
// begin attacking := true ;
137824: LD_ADDR_VAR 0 29
137828: PUSH
137829: LD_INT 1
137831: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
137832: LD_VAR 0 4
137836: PUSH
137837: LD_VAR 0 7
137841: ARRAY
137842: PPUSH
137843: CALL_OW 250
137847: PPUSH
137848: LD_VAR 0 4
137852: PUSH
137853: LD_VAR 0 7
137857: ARRAY
137858: PPUSH
137859: CALL_OW 251
137863: PPUSH
137864: CALL_OW 546
137868: PUSH
137869: LD_INT 2
137871: ARRAY
137872: PUSH
137873: LD_VAR 0 14
137877: PUSH
137878: LD_INT 1
137880: ARRAY
137881: PPUSH
137882: CALL_OW 250
137886: PPUSH
137887: LD_VAR 0 14
137891: PUSH
137892: LD_INT 1
137894: ARRAY
137895: PPUSH
137896: CALL_OW 251
137900: PPUSH
137901: CALL_OW 546
137905: PUSH
137906: LD_INT 2
137908: ARRAY
137909: EQUAL
137910: IFFALSE 137938
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
137912: LD_VAR 0 4
137916: PUSH
137917: LD_VAR 0 7
137921: ARRAY
137922: PPUSH
137923: LD_VAR 0 14
137927: PUSH
137928: LD_INT 1
137930: ARRAY
137931: PPUSH
137932: CALL 103698 0 2
137936: GO 137962
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137938: LD_VAR 0 4
137942: PUSH
137943: LD_VAR 0 7
137947: ARRAY
137948: PPUSH
137949: LD_VAR 0 14
137953: PUSH
137954: LD_INT 1
137956: ARRAY
137957: PPUSH
137958: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
137962: LD_VAR 0 4
137966: PUSH
137967: LD_VAR 0 7
137971: ARRAY
137972: PPUSH
137973: CALL_OW 264
137977: PUSH
137978: LD_INT 29
137980: EQUAL
137981: IFFALSE 138347
// begin if WantsToAttack ( group [ i ] ) in bombed then
137983: LD_VAR 0 4
137987: PUSH
137988: LD_VAR 0 7
137992: ARRAY
137993: PPUSH
137994: CALL_OW 319
137998: PUSH
137999: LD_VAR 0 28
138003: IN
138004: IFFALSE 138008
// continue ;
138006: GO 135012
// k := 8 ;
138008: LD_ADDR_VAR 0 9
138012: PUSH
138013: LD_INT 8
138015: ST_TO_ADDR
// x := 0 ;
138016: LD_ADDR_VAR 0 10
138020: PUSH
138021: LD_INT 0
138023: ST_TO_ADDR
// if tmp < k then
138024: LD_VAR 0 14
138028: PUSH
138029: LD_VAR 0 9
138033: LESS
138034: IFFALSE 138046
// k := tmp ;
138036: LD_ADDR_VAR 0 9
138040: PUSH
138041: LD_VAR 0 14
138045: ST_TO_ADDR
// for j = 1 to k do
138046: LD_ADDR_VAR 0 8
138050: PUSH
138051: DOUBLE
138052: LD_INT 1
138054: DEC
138055: ST_TO_ADDR
138056: LD_VAR 0 9
138060: PUSH
138061: FOR_TO
138062: IFFALSE 138194
// begin if GetType ( tmp [ j ] ) = unit_building then
138064: LD_VAR 0 14
138068: PUSH
138069: LD_VAR 0 8
138073: ARRAY
138074: PPUSH
138075: CALL_OW 247
138079: PUSH
138080: LD_INT 3
138082: EQUAL
138083: IFFALSE 138192
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
138085: LD_VAR 0 14
138089: PUSH
138090: LD_VAR 0 8
138094: ARRAY
138095: PUSH
138096: LD_VAR 0 28
138100: IN
138101: NOT
138102: PUSH
138103: LD_VAR 0 14
138107: PUSH
138108: LD_VAR 0 8
138112: ARRAY
138113: PPUSH
138114: CALL_OW 313
138118: AND
138119: IFFALSE 138192
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138121: LD_VAR 0 4
138125: PUSH
138126: LD_VAR 0 7
138130: ARRAY
138131: PPUSH
138132: LD_VAR 0 14
138136: PUSH
138137: LD_VAR 0 8
138141: ARRAY
138142: PPUSH
138143: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
138147: LD_ADDR_VAR 0 28
138151: PUSH
138152: LD_VAR 0 28
138156: PPUSH
138157: LD_VAR 0 28
138161: PUSH
138162: LD_INT 1
138164: PLUS
138165: PPUSH
138166: LD_VAR 0 14
138170: PUSH
138171: LD_VAR 0 8
138175: ARRAY
138176: PPUSH
138177: CALL_OW 1
138181: ST_TO_ADDR
// attacking := true ;
138182: LD_ADDR_VAR 0 29
138186: PUSH
138187: LD_INT 1
138189: ST_TO_ADDR
// break ;
138190: GO 138194
// end ; end ;
138192: GO 138061
138194: POP
138195: POP
// if not attacking and f_attack_depot then
138196: LD_VAR 0 29
138200: NOT
138201: PUSH
138202: LD_VAR 0 25
138206: AND
138207: IFFALSE 138302
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138209: LD_ADDR_VAR 0 13
138213: PUSH
138214: LD_VAR 0 14
138218: PPUSH
138219: LD_INT 2
138221: PUSH
138222: LD_INT 30
138224: PUSH
138225: LD_INT 0
138227: PUSH
138228: EMPTY
138229: LIST
138230: LIST
138231: PUSH
138232: LD_INT 30
138234: PUSH
138235: LD_INT 1
138237: PUSH
138238: EMPTY
138239: LIST
138240: LIST
138241: PUSH
138242: EMPTY
138243: LIST
138244: LIST
138245: LIST
138246: PPUSH
138247: CALL_OW 72
138251: ST_TO_ADDR
// if z then
138252: LD_VAR 0 13
138256: IFFALSE 138302
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
138258: LD_VAR 0 4
138262: PUSH
138263: LD_VAR 0 7
138267: ARRAY
138268: PPUSH
138269: LD_VAR 0 13
138273: PPUSH
138274: LD_VAR 0 4
138278: PUSH
138279: LD_VAR 0 7
138283: ARRAY
138284: PPUSH
138285: CALL_OW 74
138289: PPUSH
138290: CALL_OW 115
// attacking := true ;
138294: LD_ADDR_VAR 0 29
138298: PUSH
138299: LD_INT 1
138301: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
138302: LD_VAR 0 4
138306: PUSH
138307: LD_VAR 0 7
138311: ARRAY
138312: PPUSH
138313: CALL_OW 256
138317: PUSH
138318: LD_INT 500
138320: LESS
138321: IFFALSE 138347
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
138323: LD_VAR 0 4
138327: PUSH
138328: LD_VAR 0 7
138332: ARRAY
138333: PPUSH
138334: LD_VAR 0 14
138338: PUSH
138339: LD_INT 1
138341: ARRAY
138342: PPUSH
138343: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
138347: LD_VAR 0 4
138351: PUSH
138352: LD_VAR 0 7
138356: ARRAY
138357: PPUSH
138358: CALL_OW 264
138362: PUSH
138363: LD_INT 49
138365: EQUAL
138366: IFFALSE 138487
// begin if not HasTask ( group [ i ] ) then
138368: LD_VAR 0 4
138372: PUSH
138373: LD_VAR 0 7
138377: ARRAY
138378: PPUSH
138379: CALL_OW 314
138383: NOT
138384: IFFALSE 138487
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
138386: LD_ADDR_VAR 0 9
138390: PUSH
138391: LD_INT 81
138393: PUSH
138394: LD_VAR 0 4
138398: PUSH
138399: LD_VAR 0 7
138403: ARRAY
138404: PPUSH
138405: CALL_OW 255
138409: PUSH
138410: EMPTY
138411: LIST
138412: LIST
138413: PPUSH
138414: CALL_OW 69
138418: PPUSH
138419: LD_VAR 0 4
138423: PUSH
138424: LD_VAR 0 7
138428: ARRAY
138429: PPUSH
138430: CALL_OW 74
138434: ST_TO_ADDR
// if k then
138435: LD_VAR 0 9
138439: IFFALSE 138487
// if GetDistUnits ( group [ i ] , k ) > 10 then
138441: LD_VAR 0 4
138445: PUSH
138446: LD_VAR 0 7
138450: ARRAY
138451: PPUSH
138452: LD_VAR 0 9
138456: PPUSH
138457: CALL_OW 296
138461: PUSH
138462: LD_INT 10
138464: GREATER
138465: IFFALSE 138487
// ComMoveUnit ( group [ i ] , k ) ;
138467: LD_VAR 0 4
138471: PUSH
138472: LD_VAR 0 7
138476: ARRAY
138477: PPUSH
138478: LD_VAR 0 9
138482: PPUSH
138483: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
138487: LD_VAR 0 4
138491: PUSH
138492: LD_VAR 0 7
138496: ARRAY
138497: PPUSH
138498: CALL_OW 256
138502: PUSH
138503: LD_INT 250
138505: LESS
138506: PUSH
138507: LD_VAR 0 4
138511: PUSH
138512: LD_VAR 0 7
138516: ARRAY
138517: PUSH
138518: LD_INT 21
138520: PUSH
138521: LD_INT 2
138523: PUSH
138524: EMPTY
138525: LIST
138526: LIST
138527: PUSH
138528: LD_INT 23
138530: PUSH
138531: LD_INT 2
138533: PUSH
138534: EMPTY
138535: LIST
138536: LIST
138537: PUSH
138538: EMPTY
138539: LIST
138540: LIST
138541: PPUSH
138542: CALL_OW 69
138546: IN
138547: AND
138548: IFFALSE 138673
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
138550: LD_ADDR_VAR 0 9
138554: PUSH
138555: LD_OWVAR 3
138559: PUSH
138560: LD_VAR 0 4
138564: PUSH
138565: LD_VAR 0 7
138569: ARRAY
138570: DIFF
138571: PPUSH
138572: LD_VAR 0 4
138576: PUSH
138577: LD_VAR 0 7
138581: ARRAY
138582: PPUSH
138583: CALL_OW 74
138587: ST_TO_ADDR
// if not k then
138588: LD_VAR 0 9
138592: NOT
138593: IFFALSE 138597
// continue ;
138595: GO 135012
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
138597: LD_VAR 0 9
138601: PUSH
138602: LD_INT 81
138604: PUSH
138605: LD_VAR 0 4
138609: PUSH
138610: LD_VAR 0 7
138614: ARRAY
138615: PPUSH
138616: CALL_OW 255
138620: PUSH
138621: EMPTY
138622: LIST
138623: LIST
138624: PPUSH
138625: CALL_OW 69
138629: IN
138630: PUSH
138631: LD_VAR 0 9
138635: PPUSH
138636: LD_VAR 0 4
138640: PUSH
138641: LD_VAR 0 7
138645: ARRAY
138646: PPUSH
138647: CALL_OW 296
138651: PUSH
138652: LD_INT 5
138654: LESS
138655: AND
138656: IFFALSE 138673
// ComAutodestruct ( group [ i ] ) ;
138658: LD_VAR 0 4
138662: PUSH
138663: LD_VAR 0 7
138667: ARRAY
138668: PPUSH
138669: CALL 103596 0 1
// end ; if f_attack_depot then
138673: LD_VAR 0 25
138677: IFFALSE 138789
// begin k := 6 ;
138679: LD_ADDR_VAR 0 9
138683: PUSH
138684: LD_INT 6
138686: ST_TO_ADDR
// if tmp < k then
138687: LD_VAR 0 14
138691: PUSH
138692: LD_VAR 0 9
138696: LESS
138697: IFFALSE 138709
// k := tmp ;
138699: LD_ADDR_VAR 0 9
138703: PUSH
138704: LD_VAR 0 14
138708: ST_TO_ADDR
// for j = 1 to k do
138709: LD_ADDR_VAR 0 8
138713: PUSH
138714: DOUBLE
138715: LD_INT 1
138717: DEC
138718: ST_TO_ADDR
138719: LD_VAR 0 9
138723: PUSH
138724: FOR_TO
138725: IFFALSE 138787
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
138727: LD_VAR 0 8
138731: PPUSH
138732: CALL_OW 266
138736: PUSH
138737: LD_INT 0
138739: PUSH
138740: LD_INT 1
138742: PUSH
138743: EMPTY
138744: LIST
138745: LIST
138746: IN
138747: IFFALSE 138785
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138749: LD_VAR 0 4
138753: PUSH
138754: LD_VAR 0 7
138758: ARRAY
138759: PPUSH
138760: LD_VAR 0 14
138764: PUSH
138765: LD_VAR 0 8
138769: ARRAY
138770: PPUSH
138771: CALL_OW 115
// attacking := true ;
138775: LD_ADDR_VAR 0 29
138779: PUSH
138780: LD_INT 1
138782: ST_TO_ADDR
// break ;
138783: GO 138787
// end ;
138785: GO 138724
138787: POP
138788: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
138789: LD_VAR 0 4
138793: PUSH
138794: LD_VAR 0 7
138798: ARRAY
138799: PPUSH
138800: CALL_OW 302
138804: PUSH
138805: LD_VAR 0 29
138809: NOT
138810: AND
138811: IFFALSE 139133
// begin if GetTag ( group [ i ] ) = 71 then
138813: LD_VAR 0 4
138817: PUSH
138818: LD_VAR 0 7
138822: ARRAY
138823: PPUSH
138824: CALL_OW 110
138828: PUSH
138829: LD_INT 71
138831: EQUAL
138832: IFFALSE 138873
// begin if HasTask ( group [ i ] ) then
138834: LD_VAR 0 4
138838: PUSH
138839: LD_VAR 0 7
138843: ARRAY
138844: PPUSH
138845: CALL_OW 314
138849: IFFALSE 138855
// continue else
138851: GO 135012
138853: GO 138873
// SetTag ( group [ i ] , 0 ) ;
138855: LD_VAR 0 4
138859: PUSH
138860: LD_VAR 0 7
138864: ARRAY
138865: PPUSH
138866: LD_INT 0
138868: PPUSH
138869: CALL_OW 109
// end ; k := 8 ;
138873: LD_ADDR_VAR 0 9
138877: PUSH
138878: LD_INT 8
138880: ST_TO_ADDR
// x := 0 ;
138881: LD_ADDR_VAR 0 10
138885: PUSH
138886: LD_INT 0
138888: ST_TO_ADDR
// if tmp < k then
138889: LD_VAR 0 14
138893: PUSH
138894: LD_VAR 0 9
138898: LESS
138899: IFFALSE 138911
// k := tmp ;
138901: LD_ADDR_VAR 0 9
138905: PUSH
138906: LD_VAR 0 14
138910: ST_TO_ADDR
// for j = 1 to k do
138911: LD_ADDR_VAR 0 8
138915: PUSH
138916: DOUBLE
138917: LD_INT 1
138919: DEC
138920: ST_TO_ADDR
138921: LD_VAR 0 9
138925: PUSH
138926: FOR_TO
138927: IFFALSE 139025
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
138929: LD_VAR 0 14
138933: PUSH
138934: LD_VAR 0 8
138938: ARRAY
138939: PPUSH
138940: CALL_OW 247
138944: PUSH
138945: LD_INT 1
138947: EQUAL
138948: PUSH
138949: LD_VAR 0 14
138953: PUSH
138954: LD_VAR 0 8
138958: ARRAY
138959: PPUSH
138960: CALL_OW 256
138964: PUSH
138965: LD_INT 250
138967: LESS
138968: PUSH
138969: LD_VAR 0 20
138973: AND
138974: PUSH
138975: LD_VAR 0 20
138979: NOT
138980: PUSH
138981: LD_VAR 0 14
138985: PUSH
138986: LD_VAR 0 8
138990: ARRAY
138991: PPUSH
138992: CALL_OW 256
138996: PUSH
138997: LD_INT 250
138999: GREATEREQUAL
139000: AND
139001: OR
139002: AND
139003: IFFALSE 139023
// begin x := tmp [ j ] ;
139005: LD_ADDR_VAR 0 10
139009: PUSH
139010: LD_VAR 0 14
139014: PUSH
139015: LD_VAR 0 8
139019: ARRAY
139020: ST_TO_ADDR
// break ;
139021: GO 139025
// end ;
139023: GO 138926
139025: POP
139026: POP
// if x then
139027: LD_VAR 0 10
139031: IFFALSE 139055
// ComAttackUnit ( group [ i ] , x ) else
139033: LD_VAR 0 4
139037: PUSH
139038: LD_VAR 0 7
139042: ARRAY
139043: PPUSH
139044: LD_VAR 0 10
139048: PPUSH
139049: CALL_OW 115
139053: GO 139079
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139055: LD_VAR 0 4
139059: PUSH
139060: LD_VAR 0 7
139064: ARRAY
139065: PPUSH
139066: LD_VAR 0 14
139070: PUSH
139071: LD_INT 1
139073: ARRAY
139074: PPUSH
139075: CALL_OW 115
// if not HasTask ( group [ i ] ) then
139079: LD_VAR 0 4
139083: PUSH
139084: LD_VAR 0 7
139088: ARRAY
139089: PPUSH
139090: CALL_OW 314
139094: NOT
139095: IFFALSE 139133
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
139097: LD_VAR 0 4
139101: PUSH
139102: LD_VAR 0 7
139106: ARRAY
139107: PPUSH
139108: LD_VAR 0 14
139112: PPUSH
139113: LD_VAR 0 4
139117: PUSH
139118: LD_VAR 0 7
139122: ARRAY
139123: PPUSH
139124: CALL_OW 74
139128: PPUSH
139129: CALL_OW 115
// end ; end ; end ;
139133: GO 135012
139135: POP
139136: POP
// wait ( 0 0$2 ) ;
139137: LD_INT 70
139139: PPUSH
139140: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
139144: LD_VAR 0 4
139148: NOT
139149: PUSH
139150: LD_VAR 0 4
139154: PUSH
139155: EMPTY
139156: EQUAL
139157: OR
139158: PUSH
139159: LD_INT 81
139161: PUSH
139162: LD_VAR 0 35
139166: PUSH
139167: EMPTY
139168: LIST
139169: LIST
139170: PPUSH
139171: CALL_OW 69
139175: NOT
139176: OR
139177: IFFALSE 134997
// end ;
139179: LD_VAR 0 2
139183: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
139184: LD_INT 0
139186: PPUSH
139187: PPUSH
139188: PPUSH
139189: PPUSH
139190: PPUSH
139191: PPUSH
// if not base or not mc_bases [ base ] or not solds then
139192: LD_VAR 0 1
139196: NOT
139197: PUSH
139198: LD_EXP 102
139202: PUSH
139203: LD_VAR 0 1
139207: ARRAY
139208: NOT
139209: OR
139210: PUSH
139211: LD_VAR 0 2
139215: NOT
139216: OR
139217: IFFALSE 139221
// exit ;
139219: GO 139775
// side := mc_sides [ base ] ;
139221: LD_ADDR_VAR 0 6
139225: PUSH
139226: LD_EXP 128
139230: PUSH
139231: LD_VAR 0 1
139235: ARRAY
139236: ST_TO_ADDR
// if not side then
139237: LD_VAR 0 6
139241: NOT
139242: IFFALSE 139246
// exit ;
139244: GO 139775
// for i in solds do
139246: LD_ADDR_VAR 0 7
139250: PUSH
139251: LD_VAR 0 2
139255: PUSH
139256: FOR_IN
139257: IFFALSE 139318
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
139259: LD_VAR 0 7
139263: PPUSH
139264: CALL_OW 310
139268: PPUSH
139269: CALL_OW 266
139273: PUSH
139274: LD_INT 32
139276: PUSH
139277: LD_INT 31
139279: PUSH
139280: EMPTY
139281: LIST
139282: LIST
139283: IN
139284: IFFALSE 139304
// solds := solds diff i else
139286: LD_ADDR_VAR 0 2
139290: PUSH
139291: LD_VAR 0 2
139295: PUSH
139296: LD_VAR 0 7
139300: DIFF
139301: ST_TO_ADDR
139302: GO 139316
// SetTag ( i , 18 ) ;
139304: LD_VAR 0 7
139308: PPUSH
139309: LD_INT 18
139311: PPUSH
139312: CALL_OW 109
139316: GO 139256
139318: POP
139319: POP
// if not solds then
139320: LD_VAR 0 2
139324: NOT
139325: IFFALSE 139329
// exit ;
139327: GO 139775
// repeat wait ( 0 0$2 ) ;
139329: LD_INT 70
139331: PPUSH
139332: CALL_OW 67
// enemy := mc_scan [ base ] ;
139336: LD_ADDR_VAR 0 4
139340: PUSH
139341: LD_EXP 125
139345: PUSH
139346: LD_VAR 0 1
139350: ARRAY
139351: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
139352: LD_EXP 102
139356: PUSH
139357: LD_VAR 0 1
139361: ARRAY
139362: NOT
139363: PUSH
139364: LD_EXP 102
139368: PUSH
139369: LD_VAR 0 1
139373: ARRAY
139374: PUSH
139375: EMPTY
139376: EQUAL
139377: OR
139378: IFFALSE 139415
// begin for i in solds do
139380: LD_ADDR_VAR 0 7
139384: PUSH
139385: LD_VAR 0 2
139389: PUSH
139390: FOR_IN
139391: IFFALSE 139404
// ComStop ( i ) ;
139393: LD_VAR 0 7
139397: PPUSH
139398: CALL_OW 141
139402: GO 139390
139404: POP
139405: POP
// solds := [ ] ;
139406: LD_ADDR_VAR 0 2
139410: PUSH
139411: EMPTY
139412: ST_TO_ADDR
// exit ;
139413: GO 139775
// end ; for i in solds do
139415: LD_ADDR_VAR 0 7
139419: PUSH
139420: LD_VAR 0 2
139424: PUSH
139425: FOR_IN
139426: IFFALSE 139747
// begin if IsInUnit ( i ) then
139428: LD_VAR 0 7
139432: PPUSH
139433: CALL_OW 310
139437: IFFALSE 139448
// ComExitBuilding ( i ) ;
139439: LD_VAR 0 7
139443: PPUSH
139444: CALL_OW 122
// if GetLives ( i ) > 500 then
139448: LD_VAR 0 7
139452: PPUSH
139453: CALL_OW 256
139457: PUSH
139458: LD_INT 500
139460: GREATER
139461: IFFALSE 139514
// begin e := NearestUnitToUnit ( enemy , i ) ;
139463: LD_ADDR_VAR 0 5
139467: PUSH
139468: LD_VAR 0 4
139472: PPUSH
139473: LD_VAR 0 7
139477: PPUSH
139478: CALL_OW 74
139482: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
139483: LD_VAR 0 7
139487: PPUSH
139488: LD_VAR 0 5
139492: PPUSH
139493: CALL_OW 250
139497: PPUSH
139498: LD_VAR 0 5
139502: PPUSH
139503: CALL_OW 251
139507: PPUSH
139508: CALL_OW 114
// end else
139512: GO 139745
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
139514: LD_VAR 0 7
139518: PPUSH
139519: LD_EXP 102
139523: PUSH
139524: LD_VAR 0 1
139528: ARRAY
139529: PPUSH
139530: LD_INT 2
139532: PUSH
139533: LD_INT 30
139535: PUSH
139536: LD_INT 0
139538: PUSH
139539: EMPTY
139540: LIST
139541: LIST
139542: PUSH
139543: LD_INT 30
139545: PUSH
139546: LD_INT 1
139548: PUSH
139549: EMPTY
139550: LIST
139551: LIST
139552: PUSH
139553: LD_INT 30
139555: PUSH
139556: LD_INT 6
139558: PUSH
139559: EMPTY
139560: LIST
139561: LIST
139562: PUSH
139563: EMPTY
139564: LIST
139565: LIST
139566: LIST
139567: LIST
139568: PPUSH
139569: CALL_OW 72
139573: PPUSH
139574: LD_VAR 0 7
139578: PPUSH
139579: CALL_OW 74
139583: PPUSH
139584: CALL_OW 296
139588: PUSH
139589: LD_INT 10
139591: GREATER
139592: IFFALSE 139745
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
139594: LD_ADDR_VAR 0 8
139598: PUSH
139599: LD_EXP 102
139603: PUSH
139604: LD_VAR 0 1
139608: ARRAY
139609: PPUSH
139610: LD_INT 2
139612: PUSH
139613: LD_INT 30
139615: PUSH
139616: LD_INT 0
139618: PUSH
139619: EMPTY
139620: LIST
139621: LIST
139622: PUSH
139623: LD_INT 30
139625: PUSH
139626: LD_INT 1
139628: PUSH
139629: EMPTY
139630: LIST
139631: LIST
139632: PUSH
139633: LD_INT 30
139635: PUSH
139636: LD_INT 6
139638: PUSH
139639: EMPTY
139640: LIST
139641: LIST
139642: PUSH
139643: EMPTY
139644: LIST
139645: LIST
139646: LIST
139647: LIST
139648: PPUSH
139649: CALL_OW 72
139653: PPUSH
139654: LD_VAR 0 7
139658: PPUSH
139659: CALL_OW 74
139663: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
139664: LD_VAR 0 7
139668: PPUSH
139669: LD_VAR 0 8
139673: PPUSH
139674: CALL_OW 250
139678: PPUSH
139679: LD_INT 3
139681: PPUSH
139682: LD_INT 5
139684: PPUSH
139685: CALL_OW 272
139689: PPUSH
139690: LD_VAR 0 8
139694: PPUSH
139695: CALL_OW 251
139699: PPUSH
139700: LD_INT 3
139702: PPUSH
139703: LD_INT 5
139705: PPUSH
139706: CALL_OW 273
139710: PPUSH
139711: CALL_OW 111
// SetTag ( i , 0 ) ;
139715: LD_VAR 0 7
139719: PPUSH
139720: LD_INT 0
139722: PPUSH
139723: CALL_OW 109
// solds := solds diff i ;
139727: LD_ADDR_VAR 0 2
139731: PUSH
139732: LD_VAR 0 2
139736: PUSH
139737: LD_VAR 0 7
139741: DIFF
139742: ST_TO_ADDR
// continue ;
139743: GO 139425
// end ; end ;
139745: GO 139425
139747: POP
139748: POP
// until not solds or not enemy ;
139749: LD_VAR 0 2
139753: NOT
139754: PUSH
139755: LD_VAR 0 4
139759: NOT
139760: OR
139761: IFFALSE 139329
// MC_Reset ( base , 18 ) ;
139763: LD_VAR 0 1
139767: PPUSH
139768: LD_INT 18
139770: PPUSH
139771: CALL 43770 0 2
// end ;
139775: LD_VAR 0 3
139779: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
139780: LD_INT 0
139782: PPUSH
139783: PPUSH
139784: PPUSH
139785: PPUSH
139786: PPUSH
139787: PPUSH
139788: PPUSH
139789: PPUSH
139790: PPUSH
139791: PPUSH
139792: PPUSH
139793: PPUSH
139794: PPUSH
139795: PPUSH
139796: PPUSH
139797: PPUSH
139798: PPUSH
139799: PPUSH
139800: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
139801: LD_ADDR_VAR 0 12
139805: PUSH
139806: LD_EXP 102
139810: PUSH
139811: LD_VAR 0 1
139815: ARRAY
139816: PPUSH
139817: LD_INT 25
139819: PUSH
139820: LD_INT 3
139822: PUSH
139823: EMPTY
139824: LIST
139825: LIST
139826: PPUSH
139827: CALL_OW 72
139831: ST_TO_ADDR
// if mc_remote_driver [ base ] then
139832: LD_EXP 142
139836: PUSH
139837: LD_VAR 0 1
139841: ARRAY
139842: IFFALSE 139866
// mechs := mechs diff mc_remote_driver [ base ] ;
139844: LD_ADDR_VAR 0 12
139848: PUSH
139849: LD_VAR 0 12
139853: PUSH
139854: LD_EXP 142
139858: PUSH
139859: LD_VAR 0 1
139863: ARRAY
139864: DIFF
139865: ST_TO_ADDR
// for i in mechs do
139866: LD_ADDR_VAR 0 4
139870: PUSH
139871: LD_VAR 0 12
139875: PUSH
139876: FOR_IN
139877: IFFALSE 139912
// if GetTag ( i ) > 0 then
139879: LD_VAR 0 4
139883: PPUSH
139884: CALL_OW 110
139888: PUSH
139889: LD_INT 0
139891: GREATER
139892: IFFALSE 139910
// mechs := mechs diff i ;
139894: LD_ADDR_VAR 0 12
139898: PUSH
139899: LD_VAR 0 12
139903: PUSH
139904: LD_VAR 0 4
139908: DIFF
139909: ST_TO_ADDR
139910: GO 139876
139912: POP
139913: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139914: LD_ADDR_VAR 0 8
139918: PUSH
139919: LD_EXP 102
139923: PUSH
139924: LD_VAR 0 1
139928: ARRAY
139929: PPUSH
139930: LD_INT 2
139932: PUSH
139933: LD_INT 25
139935: PUSH
139936: LD_INT 1
139938: PUSH
139939: EMPTY
139940: LIST
139941: LIST
139942: PUSH
139943: LD_INT 25
139945: PUSH
139946: LD_INT 5
139948: PUSH
139949: EMPTY
139950: LIST
139951: LIST
139952: PUSH
139953: LD_INT 25
139955: PUSH
139956: LD_INT 8
139958: PUSH
139959: EMPTY
139960: LIST
139961: LIST
139962: PUSH
139963: LD_INT 25
139965: PUSH
139966: LD_INT 9
139968: PUSH
139969: EMPTY
139970: LIST
139971: LIST
139972: PUSH
139973: EMPTY
139974: LIST
139975: LIST
139976: LIST
139977: LIST
139978: LIST
139979: PPUSH
139980: CALL_OW 72
139984: ST_TO_ADDR
// if not defenders and not solds then
139985: LD_VAR 0 2
139989: NOT
139990: PUSH
139991: LD_VAR 0 8
139995: NOT
139996: AND
139997: IFFALSE 140001
// exit ;
139999: GO 141771
// depot_under_attack := false ;
140001: LD_ADDR_VAR 0 16
140005: PUSH
140006: LD_INT 0
140008: ST_TO_ADDR
// sold_defenders := [ ] ;
140009: LD_ADDR_VAR 0 17
140013: PUSH
140014: EMPTY
140015: ST_TO_ADDR
// if mechs then
140016: LD_VAR 0 12
140020: IFFALSE 140173
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
140022: LD_ADDR_VAR 0 4
140026: PUSH
140027: LD_VAR 0 2
140031: PPUSH
140032: LD_INT 21
140034: PUSH
140035: LD_INT 2
140037: PUSH
140038: EMPTY
140039: LIST
140040: LIST
140041: PPUSH
140042: CALL_OW 72
140046: PUSH
140047: FOR_IN
140048: IFFALSE 140171
// begin if GetTag ( i ) <> 20 then
140050: LD_VAR 0 4
140054: PPUSH
140055: CALL_OW 110
140059: PUSH
140060: LD_INT 20
140062: NONEQUAL
140063: IFFALSE 140077
// SetTag ( i , 20 ) ;
140065: LD_VAR 0 4
140069: PPUSH
140070: LD_INT 20
140072: PPUSH
140073: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
140077: LD_VAR 0 4
140081: PPUSH
140082: CALL_OW 263
140086: PUSH
140087: LD_INT 1
140089: EQUAL
140090: PUSH
140091: LD_VAR 0 4
140095: PPUSH
140096: CALL_OW 311
140100: NOT
140101: AND
140102: IFFALSE 140169
// begin un := mechs [ 1 ] ;
140104: LD_ADDR_VAR 0 10
140108: PUSH
140109: LD_VAR 0 12
140113: PUSH
140114: LD_INT 1
140116: ARRAY
140117: ST_TO_ADDR
// ComExit ( un ) ;
140118: LD_VAR 0 10
140122: PPUSH
140123: CALL 108502 0 1
// AddComEnterUnit ( un , i ) ;
140127: LD_VAR 0 10
140131: PPUSH
140132: LD_VAR 0 4
140136: PPUSH
140137: CALL_OW 180
// SetTag ( un , 19 ) ;
140141: LD_VAR 0 10
140145: PPUSH
140146: LD_INT 19
140148: PPUSH
140149: CALL_OW 109
// mechs := mechs diff un ;
140153: LD_ADDR_VAR 0 12
140157: PUSH
140158: LD_VAR 0 12
140162: PUSH
140163: LD_VAR 0 10
140167: DIFF
140168: ST_TO_ADDR
// end ; end ;
140169: GO 140047
140171: POP
140172: POP
// if solds then
140173: LD_VAR 0 8
140177: IFFALSE 140236
// for i in solds do
140179: LD_ADDR_VAR 0 4
140183: PUSH
140184: LD_VAR 0 8
140188: PUSH
140189: FOR_IN
140190: IFFALSE 140234
// if not GetTag ( i ) then
140192: LD_VAR 0 4
140196: PPUSH
140197: CALL_OW 110
140201: NOT
140202: IFFALSE 140232
// begin defenders := defenders union i ;
140204: LD_ADDR_VAR 0 2
140208: PUSH
140209: LD_VAR 0 2
140213: PUSH
140214: LD_VAR 0 4
140218: UNION
140219: ST_TO_ADDR
// SetTag ( i , 18 ) ;
140220: LD_VAR 0 4
140224: PPUSH
140225: LD_INT 18
140227: PPUSH
140228: CALL_OW 109
// end ;
140232: GO 140189
140234: POP
140235: POP
// repeat wait ( 0 0$2 ) ;
140236: LD_INT 70
140238: PPUSH
140239: CALL_OW 67
// enemy := mc_scan [ base ] ;
140243: LD_ADDR_VAR 0 21
140247: PUSH
140248: LD_EXP 125
140252: PUSH
140253: LD_VAR 0 1
140257: ARRAY
140258: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140259: LD_EXP 102
140263: PUSH
140264: LD_VAR 0 1
140268: ARRAY
140269: NOT
140270: PUSH
140271: LD_EXP 102
140275: PUSH
140276: LD_VAR 0 1
140280: ARRAY
140281: PUSH
140282: EMPTY
140283: EQUAL
140284: OR
140285: IFFALSE 140322
// begin for i in defenders do
140287: LD_ADDR_VAR 0 4
140291: PUSH
140292: LD_VAR 0 2
140296: PUSH
140297: FOR_IN
140298: IFFALSE 140311
// ComStop ( i ) ;
140300: LD_VAR 0 4
140304: PPUSH
140305: CALL_OW 141
140309: GO 140297
140311: POP
140312: POP
// defenders := [ ] ;
140313: LD_ADDR_VAR 0 2
140317: PUSH
140318: EMPTY
140319: ST_TO_ADDR
// exit ;
140320: GO 141771
// end ; for i in defenders do
140322: LD_ADDR_VAR 0 4
140326: PUSH
140327: LD_VAR 0 2
140331: PUSH
140332: FOR_IN
140333: IFFALSE 141231
// begin e := NearestUnitToUnit ( enemy , i ) ;
140335: LD_ADDR_VAR 0 13
140339: PUSH
140340: LD_VAR 0 21
140344: PPUSH
140345: LD_VAR 0 4
140349: PPUSH
140350: CALL_OW 74
140354: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
140355: LD_ADDR_VAR 0 7
140359: PUSH
140360: LD_EXP 102
140364: PUSH
140365: LD_VAR 0 1
140369: ARRAY
140370: PPUSH
140371: LD_INT 2
140373: PUSH
140374: LD_INT 30
140376: PUSH
140377: LD_INT 0
140379: PUSH
140380: EMPTY
140381: LIST
140382: LIST
140383: PUSH
140384: LD_INT 30
140386: PUSH
140387: LD_INT 1
140389: PUSH
140390: EMPTY
140391: LIST
140392: LIST
140393: PUSH
140394: EMPTY
140395: LIST
140396: LIST
140397: LIST
140398: PPUSH
140399: CALL_OW 72
140403: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
140404: LD_ADDR_VAR 0 16
140408: PUSH
140409: LD_VAR 0 7
140413: NOT
140414: PUSH
140415: LD_VAR 0 7
140419: PPUSH
140420: LD_INT 3
140422: PUSH
140423: LD_INT 24
140425: PUSH
140426: LD_INT 600
140428: PUSH
140429: EMPTY
140430: LIST
140431: LIST
140432: PUSH
140433: EMPTY
140434: LIST
140435: LIST
140436: PPUSH
140437: CALL_OW 72
140441: OR
140442: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
140443: LD_VAR 0 4
140447: PPUSH
140448: CALL_OW 247
140452: PUSH
140453: LD_INT 2
140455: DOUBLE
140456: EQUAL
140457: IFTRUE 140461
140459: GO 140857
140461: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
140462: LD_VAR 0 4
140466: PPUSH
140467: CALL_OW 256
140471: PUSH
140472: LD_INT 1000
140474: EQUAL
140475: PUSH
140476: LD_VAR 0 4
140480: PPUSH
140481: LD_VAR 0 13
140485: PPUSH
140486: CALL_OW 296
140490: PUSH
140491: LD_INT 40
140493: LESS
140494: PUSH
140495: LD_VAR 0 13
140499: PPUSH
140500: LD_EXP 127
140504: PUSH
140505: LD_VAR 0 1
140509: ARRAY
140510: PPUSH
140511: CALL_OW 308
140515: OR
140516: AND
140517: IFFALSE 140639
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
140519: LD_VAR 0 4
140523: PPUSH
140524: CALL_OW 262
140528: PUSH
140529: LD_INT 1
140531: EQUAL
140532: PUSH
140533: LD_VAR 0 4
140537: PPUSH
140538: CALL_OW 261
140542: PUSH
140543: LD_INT 30
140545: LESS
140546: AND
140547: PUSH
140548: LD_VAR 0 7
140552: AND
140553: IFFALSE 140623
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
140555: LD_VAR 0 4
140559: PPUSH
140560: LD_VAR 0 7
140564: PPUSH
140565: LD_VAR 0 4
140569: PPUSH
140570: CALL_OW 74
140574: PPUSH
140575: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
140579: LD_VAR 0 4
140583: PPUSH
140584: LD_VAR 0 7
140588: PPUSH
140589: LD_VAR 0 4
140593: PPUSH
140594: CALL_OW 74
140598: PPUSH
140599: CALL_OW 296
140603: PUSH
140604: LD_INT 6
140606: LESS
140607: IFFALSE 140621
// SetFuel ( i , 100 ) ;
140609: LD_VAR 0 4
140613: PPUSH
140614: LD_INT 100
140616: PPUSH
140617: CALL_OW 240
// end else
140621: GO 140637
// ComAttackUnit ( i , e ) ;
140623: LD_VAR 0 4
140627: PPUSH
140628: LD_VAR 0 13
140632: PPUSH
140633: CALL_OW 115
// end else
140637: GO 140740
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
140639: LD_VAR 0 13
140643: PPUSH
140644: LD_EXP 127
140648: PUSH
140649: LD_VAR 0 1
140653: ARRAY
140654: PPUSH
140655: CALL_OW 308
140659: NOT
140660: PUSH
140661: LD_VAR 0 4
140665: PPUSH
140666: LD_VAR 0 13
140670: PPUSH
140671: CALL_OW 296
140675: PUSH
140676: LD_INT 40
140678: GREATEREQUAL
140679: AND
140680: PUSH
140681: LD_VAR 0 4
140685: PPUSH
140686: CALL_OW 256
140690: PUSH
140691: LD_INT 650
140693: LESSEQUAL
140694: OR
140695: PUSH
140696: LD_VAR 0 4
140700: PPUSH
140701: LD_EXP 126
140705: PUSH
140706: LD_VAR 0 1
140710: ARRAY
140711: PPUSH
140712: CALL_OW 308
140716: NOT
140717: AND
140718: IFFALSE 140740
// ComMoveToArea ( i , mc_parking [ base ] ) ;
140720: LD_VAR 0 4
140724: PPUSH
140725: LD_EXP 126
140729: PUSH
140730: LD_VAR 0 1
140734: ARRAY
140735: PPUSH
140736: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
140740: LD_VAR 0 4
140744: PPUSH
140745: CALL_OW 256
140749: PUSH
140750: LD_INT 1000
140752: LESS
140753: PUSH
140754: LD_VAR 0 4
140758: PPUSH
140759: CALL_OW 263
140763: PUSH
140764: LD_INT 1
140766: EQUAL
140767: AND
140768: PUSH
140769: LD_VAR 0 4
140773: PPUSH
140774: CALL_OW 311
140778: AND
140779: PUSH
140780: LD_VAR 0 4
140784: PPUSH
140785: LD_EXP 126
140789: PUSH
140790: LD_VAR 0 1
140794: ARRAY
140795: PPUSH
140796: CALL_OW 308
140800: AND
140801: IFFALSE 140855
// begin mech := IsDrivenBy ( i ) ;
140803: LD_ADDR_VAR 0 9
140807: PUSH
140808: LD_VAR 0 4
140812: PPUSH
140813: CALL_OW 311
140817: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
140818: LD_VAR 0 9
140822: PPUSH
140823: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
140827: LD_VAR 0 9
140831: PPUSH
140832: LD_VAR 0 4
140836: PPUSH
140837: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
140841: LD_VAR 0 9
140845: PPUSH
140846: LD_VAR 0 4
140850: PPUSH
140851: CALL_OW 180
// end ; end ; unit_human :
140855: GO 141202
140857: LD_INT 1
140859: DOUBLE
140860: EQUAL
140861: IFTRUE 140865
140863: GO 141201
140865: POP
// begin b := IsInUnit ( i ) ;
140866: LD_ADDR_VAR 0 18
140870: PUSH
140871: LD_VAR 0 4
140875: PPUSH
140876: CALL_OW 310
140880: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
140881: LD_ADDR_VAR 0 19
140885: PUSH
140886: LD_VAR 0 18
140890: NOT
140891: PUSH
140892: LD_VAR 0 18
140896: PPUSH
140897: CALL_OW 266
140901: PUSH
140902: LD_INT 32
140904: PUSH
140905: LD_INT 31
140907: PUSH
140908: EMPTY
140909: LIST
140910: LIST
140911: IN
140912: OR
140913: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
140914: LD_VAR 0 18
140918: PPUSH
140919: CALL_OW 266
140923: PUSH
140924: LD_INT 5
140926: EQUAL
140927: PUSH
140928: LD_VAR 0 4
140932: PPUSH
140933: CALL_OW 257
140937: PUSH
140938: LD_INT 1
140940: PUSH
140941: LD_INT 2
140943: PUSH
140944: LD_INT 3
140946: PUSH
140947: LD_INT 4
140949: PUSH
140950: EMPTY
140951: LIST
140952: LIST
140953: LIST
140954: LIST
140955: IN
140956: AND
140957: IFFALSE 140994
// begin class := AllowSpecClass ( i ) ;
140959: LD_ADDR_VAR 0 20
140963: PUSH
140964: LD_VAR 0 4
140968: PPUSH
140969: CALL 72179 0 1
140973: ST_TO_ADDR
// if class then
140974: LD_VAR 0 20
140978: IFFALSE 140994
// ComChangeProfession ( i , class ) ;
140980: LD_VAR 0 4
140984: PPUSH
140985: LD_VAR 0 20
140989: PPUSH
140990: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
140994: LD_VAR 0 16
140998: PUSH
140999: LD_VAR 0 2
141003: PPUSH
141004: LD_INT 21
141006: PUSH
141007: LD_INT 2
141009: PUSH
141010: EMPTY
141011: LIST
141012: LIST
141013: PPUSH
141014: CALL_OW 72
141018: PUSH
141019: LD_INT 1
141021: LESSEQUAL
141022: OR
141023: PUSH
141024: LD_VAR 0 19
141028: AND
141029: PUSH
141030: LD_VAR 0 4
141034: PUSH
141035: LD_VAR 0 17
141039: IN
141040: NOT
141041: AND
141042: IFFALSE 141135
// begin if b then
141044: LD_VAR 0 18
141048: IFFALSE 141097
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
141050: LD_VAR 0 18
141054: PPUSH
141055: LD_VAR 0 21
141059: PPUSH
141060: LD_VAR 0 18
141064: PPUSH
141065: CALL_OW 74
141069: PPUSH
141070: CALL_OW 296
141074: PUSH
141075: LD_INT 10
141077: LESS
141078: PUSH
141079: LD_VAR 0 18
141083: PPUSH
141084: CALL_OW 461
141088: PUSH
141089: LD_INT 7
141091: NONEQUAL
141092: AND
141093: IFFALSE 141097
// continue ;
141095: GO 140332
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
141097: LD_ADDR_VAR 0 17
141101: PUSH
141102: LD_VAR 0 17
141106: PPUSH
141107: LD_VAR 0 17
141111: PUSH
141112: LD_INT 1
141114: PLUS
141115: PPUSH
141116: LD_VAR 0 4
141120: PPUSH
141121: CALL_OW 1
141125: ST_TO_ADDR
// ComExitBuilding ( i ) ;
141126: LD_VAR 0 4
141130: PPUSH
141131: CALL_OW 122
// end ; if sold_defenders then
141135: LD_VAR 0 17
141139: IFFALSE 141199
// if i in sold_defenders then
141141: LD_VAR 0 4
141145: PUSH
141146: LD_VAR 0 17
141150: IN
141151: IFFALSE 141199
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
141153: LD_VAR 0 4
141157: PPUSH
141158: CALL_OW 314
141162: NOT
141163: PUSH
141164: LD_VAR 0 4
141168: PPUSH
141169: LD_VAR 0 13
141173: PPUSH
141174: CALL_OW 296
141178: PUSH
141179: LD_INT 30
141181: LESS
141182: AND
141183: IFFALSE 141199
// ComAttackUnit ( i , e ) ;
141185: LD_VAR 0 4
141189: PPUSH
141190: LD_VAR 0 13
141194: PPUSH
141195: CALL_OW 115
// end ; end ; end ;
141199: GO 141202
141201: POP
// if IsDead ( i ) then
141202: LD_VAR 0 4
141206: PPUSH
141207: CALL_OW 301
141211: IFFALSE 141229
// defenders := defenders diff i ;
141213: LD_ADDR_VAR 0 2
141217: PUSH
141218: LD_VAR 0 2
141222: PUSH
141223: LD_VAR 0 4
141227: DIFF
141228: ST_TO_ADDR
// end ;
141229: GO 140332
141231: POP
141232: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
141233: LD_VAR 0 21
141237: NOT
141238: PUSH
141239: LD_VAR 0 2
141243: NOT
141244: OR
141245: PUSH
141246: LD_EXP 102
141250: PUSH
141251: LD_VAR 0 1
141255: ARRAY
141256: NOT
141257: OR
141258: IFFALSE 140236
// MC_Reset ( base , 18 ) ;
141260: LD_VAR 0 1
141264: PPUSH
141265: LD_INT 18
141267: PPUSH
141268: CALL 43770 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
141272: LD_ADDR_VAR 0 2
141276: PUSH
141277: LD_VAR 0 2
141281: PUSH
141282: LD_VAR 0 2
141286: PPUSH
141287: LD_INT 2
141289: PUSH
141290: LD_INT 25
141292: PUSH
141293: LD_INT 1
141295: PUSH
141296: EMPTY
141297: LIST
141298: LIST
141299: PUSH
141300: LD_INT 25
141302: PUSH
141303: LD_INT 5
141305: PUSH
141306: EMPTY
141307: LIST
141308: LIST
141309: PUSH
141310: LD_INT 25
141312: PUSH
141313: LD_INT 8
141315: PUSH
141316: EMPTY
141317: LIST
141318: LIST
141319: PUSH
141320: LD_INT 25
141322: PUSH
141323: LD_INT 9
141325: PUSH
141326: EMPTY
141327: LIST
141328: LIST
141329: PUSH
141330: EMPTY
141331: LIST
141332: LIST
141333: LIST
141334: LIST
141335: LIST
141336: PPUSH
141337: CALL_OW 72
141341: DIFF
141342: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
141343: LD_VAR 0 21
141347: NOT
141348: PUSH
141349: LD_VAR 0 2
141353: PPUSH
141354: LD_INT 21
141356: PUSH
141357: LD_INT 2
141359: PUSH
141360: EMPTY
141361: LIST
141362: LIST
141363: PPUSH
141364: CALL_OW 72
141368: AND
141369: IFFALSE 141707
// begin tmp := FilterByTag ( defenders , 19 ) ;
141371: LD_ADDR_VAR 0 11
141375: PUSH
141376: LD_VAR 0 2
141380: PPUSH
141381: LD_INT 19
141383: PPUSH
141384: CALL 105673 0 2
141388: ST_TO_ADDR
// if tmp then
141389: LD_VAR 0 11
141393: IFFALSE 141463
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
141395: LD_ADDR_VAR 0 11
141399: PUSH
141400: LD_VAR 0 11
141404: PPUSH
141405: LD_INT 25
141407: PUSH
141408: LD_INT 3
141410: PUSH
141411: EMPTY
141412: LIST
141413: LIST
141414: PPUSH
141415: CALL_OW 72
141419: ST_TO_ADDR
// if tmp then
141420: LD_VAR 0 11
141424: IFFALSE 141463
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
141426: LD_ADDR_EXP 114
141430: PUSH
141431: LD_EXP 114
141435: PPUSH
141436: LD_VAR 0 1
141440: PPUSH
141441: LD_EXP 114
141445: PUSH
141446: LD_VAR 0 1
141450: ARRAY
141451: PUSH
141452: LD_VAR 0 11
141456: UNION
141457: PPUSH
141458: CALL_OW 1
141462: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
141463: LD_VAR 0 1
141467: PPUSH
141468: LD_INT 19
141470: PPUSH
141471: CALL 43770 0 2
// repeat wait ( 0 0$1 ) ;
141475: LD_INT 35
141477: PPUSH
141478: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141482: LD_EXP 102
141486: PUSH
141487: LD_VAR 0 1
141491: ARRAY
141492: NOT
141493: PUSH
141494: LD_EXP 102
141498: PUSH
141499: LD_VAR 0 1
141503: ARRAY
141504: PUSH
141505: EMPTY
141506: EQUAL
141507: OR
141508: IFFALSE 141545
// begin for i in defenders do
141510: LD_ADDR_VAR 0 4
141514: PUSH
141515: LD_VAR 0 2
141519: PUSH
141520: FOR_IN
141521: IFFALSE 141534
// ComStop ( i ) ;
141523: LD_VAR 0 4
141527: PPUSH
141528: CALL_OW 141
141532: GO 141520
141534: POP
141535: POP
// defenders := [ ] ;
141536: LD_ADDR_VAR 0 2
141540: PUSH
141541: EMPTY
141542: ST_TO_ADDR
// exit ;
141543: GO 141771
// end ; for i in defenders do
141545: LD_ADDR_VAR 0 4
141549: PUSH
141550: LD_VAR 0 2
141554: PUSH
141555: FOR_IN
141556: IFFALSE 141645
// begin if not IsInArea ( i , mc_parking [ base ] ) then
141558: LD_VAR 0 4
141562: PPUSH
141563: LD_EXP 126
141567: PUSH
141568: LD_VAR 0 1
141572: ARRAY
141573: PPUSH
141574: CALL_OW 308
141578: NOT
141579: IFFALSE 141603
// ComMoveToArea ( i , mc_parking [ base ] ) else
141581: LD_VAR 0 4
141585: PPUSH
141586: LD_EXP 126
141590: PUSH
141591: LD_VAR 0 1
141595: ARRAY
141596: PPUSH
141597: CALL_OW 113
141601: GO 141643
// if GetControl ( i ) = control_manual then
141603: LD_VAR 0 4
141607: PPUSH
141608: CALL_OW 263
141612: PUSH
141613: LD_INT 1
141615: EQUAL
141616: IFFALSE 141643
// if IsDrivenBy ( i ) then
141618: LD_VAR 0 4
141622: PPUSH
141623: CALL_OW 311
141627: IFFALSE 141643
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
141629: LD_VAR 0 4
141633: PPUSH
141634: CALL_OW 311
141638: PPUSH
141639: CALL_OW 121
// end ;
141643: GO 141555
141645: POP
141646: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
141647: LD_VAR 0 2
141651: PPUSH
141652: LD_INT 95
141654: PUSH
141655: LD_EXP 126
141659: PUSH
141660: LD_VAR 0 1
141664: ARRAY
141665: PUSH
141666: EMPTY
141667: LIST
141668: LIST
141669: PPUSH
141670: CALL_OW 72
141674: PUSH
141675: LD_VAR 0 2
141679: EQUAL
141680: PUSH
141681: LD_EXP 125
141685: PUSH
141686: LD_VAR 0 1
141690: ARRAY
141691: OR
141692: PUSH
141693: LD_EXP 102
141697: PUSH
141698: LD_VAR 0 1
141702: ARRAY
141703: NOT
141704: OR
141705: IFFALSE 141475
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
141707: LD_ADDR_EXP 124
141711: PUSH
141712: LD_EXP 124
141716: PPUSH
141717: LD_VAR 0 1
141721: PPUSH
141722: LD_VAR 0 2
141726: PPUSH
141727: LD_INT 21
141729: PUSH
141730: LD_INT 2
141732: PUSH
141733: EMPTY
141734: LIST
141735: LIST
141736: PPUSH
141737: CALL_OW 72
141741: PPUSH
141742: CALL_OW 1
141746: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
141747: LD_VAR 0 1
141751: PPUSH
141752: LD_INT 19
141754: PPUSH
141755: CALL 43770 0 2
// MC_Reset ( base , 20 ) ;
141759: LD_VAR 0 1
141763: PPUSH
141764: LD_INT 20
141766: PPUSH
141767: CALL 43770 0 2
// end ; end_of_file
141771: LD_VAR 0 3
141775: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
141776: LD_VAR 0 1
141780: PUSH
141781: LD_INT 200
141783: DOUBLE
141784: GREATEREQUAL
141785: IFFALSE 141793
141787: LD_INT 299
141789: DOUBLE
141790: LESSEQUAL
141791: IFTRUE 141795
141793: GO 141827
141795: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
141796: LD_VAR 0 1
141800: PPUSH
141801: LD_VAR 0 2
141805: PPUSH
141806: LD_VAR 0 3
141810: PPUSH
141811: LD_VAR 0 4
141815: PPUSH
141816: LD_VAR 0 5
141820: PPUSH
141821: CALL 129776 0 5
141825: GO 141904
141827: LD_INT 300
141829: DOUBLE
141830: GREATEREQUAL
141831: IFFALSE 141839
141833: LD_INT 399
141835: DOUBLE
141836: LESSEQUAL
141837: IFTRUE 141841
141839: GO 141903
141841: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
141842: LD_VAR 0 1
141846: PPUSH
141847: LD_VAR 0 2
141851: PPUSH
141852: LD_VAR 0 3
141856: PPUSH
141857: LD_VAR 0 4
141861: PPUSH
141862: LD_VAR 0 5
141866: PPUSH
141867: LD_VAR 0 6
141871: PPUSH
141872: LD_VAR 0 7
141876: PPUSH
141877: LD_VAR 0 8
141881: PPUSH
141882: LD_VAR 0 9
141886: PPUSH
141887: LD_VAR 0 10
141891: PPUSH
141892: LD_VAR 0 11
141896: PPUSH
141897: CALL 125714 0 11
141901: GO 141904
141903: POP
// end ;
141904: PPOPN 11
141906: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
141907: LD_VAR 0 1
141911: PPUSH
141912: LD_VAR 0 2
141916: PPUSH
141917: LD_VAR 0 3
141921: PPUSH
141922: LD_VAR 0 4
141926: PPUSH
141927: LD_VAR 0 5
141931: PPUSH
141932: CALL 129191 0 5
// end ; end_of_file
141936: PPOPN 5
141938: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
141939: LD_VAR 0 1
141943: PPUSH
141944: LD_VAR 0 2
141948: PPUSH
141949: LD_VAR 0 3
141953: PPUSH
141954: LD_VAR 0 4
141958: PPUSH
141959: LD_VAR 0 5
141963: PPUSH
141964: LD_VAR 0 6
141968: PPUSH
141969: CALL 113366 0 6
// end ;
141973: PPOPN 6
141975: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
141976: LD_INT 0
141978: PPUSH
// begin if not units then
141979: LD_VAR 0 1
141983: NOT
141984: IFFALSE 141988
// exit ;
141986: GO 141988
// end ;
141988: PPOPN 7
141990: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
141991: CALL 113253 0 0
// end ;
141995: PPOPN 1
141997: END
