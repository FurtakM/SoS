// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 34988 0 0
// InitMacro ;
  19: CALL 35156 0 0
// InitNature ;
  23: CALL 34856 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11097 0 0
// PrepareRussian ;
  44: CALL 6981 0 0
// PrepareLegion ;
  48: CALL 4206 0 0
// PreparePowell ;
  52: CALL 2943 0 0
// PrepareAmerican ;
  56: CALL 1715 0 0
// Action ;
  60: CALL 14991 0 0
// MC_Start ( ) ;
  64: CALL 37321 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 59769 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 59862 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59212 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59027 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 59769 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 59862 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59027 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59212 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 59642 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 15
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: PUSH
 904: LD_OWVAR 67
 908: ARRAY
 909: PPUSH
 910: LD_INT 27
 912: PPUSH
 913: CALL 58709 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 917: LD_INT 3
 919: PPUSH
 920: LD_INT 10
 922: PUSH
 923: LD_INT 11
 925: PUSH
 926: LD_INT 13
 928: PUSH
 929: LD_INT 15
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PPUSH
 938: CALL 59769 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 942: LD_INT 3
 944: PPUSH
 945: LD_INT 15
 947: PUSH
 948: EMPTY
 949: LIST
 950: PPUSH
 951: CALL 59862 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 955: LD_ADDR_EXP 145
 959: PUSH
 960: LD_EXP 145
 964: PPUSH
 965: LD_INT 3
 967: PPUSH
 968: LD_INT 22
 970: PUSH
 971: LD_INT 8
 973: PUSH
 974: EMPTY
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 25
 980: PUSH
 981: LD_INT 15
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PPUSH
 992: CALL_OW 69
 996: PPUSH
 997: CALL_OW 1
1001: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1002: LD_INT 3
1004: PPUSH
1005: LD_INT 13
1007: PUSH
1008: LD_INT 2
1010: PUSH
1011: LD_INT 1
1013: PUSH
1014: LD_INT 31
1016: PUSH
1017: EMPTY
1018: LIST
1019: LIST
1020: LIST
1021: LIST
1022: PUSH
1023: LD_INT 13
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 1
1031: PUSH
1032: LD_INT 31
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: LD_INT 13
1043: PUSH
1044: LD_INT 3
1046: PUSH
1047: LD_INT 2
1049: PUSH
1050: LD_INT 32
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PUSH
1059: LD_INT 14
1061: PUSH
1062: LD_INT 1
1064: PUSH
1065: LD_INT 2
1067: PUSH
1068: LD_EXP 101
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: PUSH
1079: EMPTY
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PPUSH
1085: CALL 59027 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 10
1094: PUSH
1095: LD_INT 12
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 59769 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 9
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 59862 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 26
1124: PUSH
1125: LD_INT 74
1127: PUSH
1128: LD_INT 107
1130: PUSH
1131: LD_INT 0
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 32
1142: PUSH
1143: LD_INT 77
1145: PUSH
1146: LD_INT 101
1148: PUSH
1149: LD_INT 4
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 32
1160: PUSH
1161: LD_INT 69
1163: PUSH
1164: LD_INT 86
1166: PUSH
1167: LD_INT 4
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 27
1178: PUSH
1179: LD_INT 77
1181: PUSH
1182: LD_INT 110
1184: PUSH
1185: LD_INT 3
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 27
1196: PUSH
1197: LD_INT 42
1199: PUSH
1200: LD_INT 79
1202: PUSH
1203: LD_INT 5
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: LD_INT 29
1214: PUSH
1215: LD_INT 86
1217: PUSH
1218: LD_INT 105
1220: PUSH
1221: LD_INT 2
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: PUSH
1230: LD_INT 30
1232: PUSH
1233: LD_INT 40
1235: PUSH
1236: LD_INT 75
1238: PUSH
1239: LD_INT 1
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: PUSH
1248: LD_INT 32
1250: PUSH
1251: LD_INT 80
1253: PUSH
1254: LD_INT 106
1256: PUSH
1257: LD_INT 4
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 32
1268: PUSH
1269: LD_INT 75
1271: PUSH
1272: LD_INT 114
1274: PUSH
1275: LD_INT 5
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: PUSH
1284: LD_INT 32
1286: PUSH
1287: LD_INT 82
1289: PUSH
1290: LD_INT 110
1292: PUSH
1293: LD_INT 5
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: PUSH
1302: LD_INT 32
1304: PUSH
1305: LD_INT 62
1307: PUSH
1308: LD_INT 78
1310: PUSH
1311: LD_INT 4
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PUSH
1320: LD_INT 4
1322: PUSH
1323: LD_INT 39
1325: PUSH
1326: LD_INT 61
1328: PUSH
1329: LD_INT 3
1331: PUSH
1332: EMPTY
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: PUSH
1338: EMPTY
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 58919 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 5
1361: PUSH
1362: LD_INT 6
1364: PUSH
1365: LD_INT 7
1367: PUSH
1368: LD_INT 9
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 60180 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1381: LD_INT 4
1383: PPUSH
1384: LD_INT 40
1386: PUSH
1387: LD_INT 75
1389: PUSH
1390: LD_INT 1
1392: PUSH
1393: EMPTY
1394: LIST
1395: LIST
1396: LIST
1397: PUSH
1398: LD_INT 86
1400: PUSH
1401: LD_INT 105
1403: PUSH
1404: LD_INT 0
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: PPUSH
1416: CALL 59351 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1420: LD_INT 4
1422: PPUSH
1423: LD_INT 2
1425: PPUSH
1426: CALL 59642 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1430: LD_INT 4
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL 59642 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1440: LD_INT 4
1442: PPUSH
1443: LD_INT 54
1445: PPUSH
1446: LD_INT 85
1448: PPUSH
1449: LD_INT 2
1451: PPUSH
1452: LD_INT 19
1454: PUSH
1455: LD_INT 16
1457: PUSH
1458: LD_INT 17
1460: PUSH
1461: LD_INT 18
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL 59974 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1474: LD_INT 4
1476: PPUSH
1477: LD_INT 3
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: LD_INT 5
1488: PUSH
1489: EMPTY
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: PUSH
1495: LD_INT 4
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 1
1503: PUSH
1504: LD_INT 6
1506: PUSH
1507: EMPTY
1508: LIST
1509: LIST
1510: LIST
1511: LIST
1512: PUSH
1513: LD_INT 4
1515: PUSH
1516: LD_INT 1
1518: PUSH
1519: LD_INT 1
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: EMPTY
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: PUSH
1531: LD_INT 4
1533: PUSH
1534: LD_INT 1
1536: PUSH
1537: LD_INT 1
1539: PUSH
1540: LD_INT 6
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: PUSH
1549: EMPTY
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: PPUSH
1555: CALL 59027 0 2
// MC_SetTame ( 4 , powellApe ) ;
1559: LD_INT 4
1561: PPUSH
1562: LD_INT 13
1564: PPUSH
1565: CALL 59593 0 2
// end ;
1569: LD_VAR 0 1
1573: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1574: LD_EXP 36
1578: PUSH
1579: LD_EXP 17
1583: PUSH
1584: LD_INT 2
1586: GREATEREQUAL
1587: AND
1588: IFFALSE 1600
1590: GO 1592
1592: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1593: LD_STRING ACH_POWELL
1595: PPUSH
1596: CALL_OW 543
1600: END
// every 0 0$1 trigger debug do var i , tmp ;
1601: LD_EXP 1
1605: IFFALSE 1712
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
// begin enable ;
1614: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1615: LD_ADDR_VAR 0 2
1619: PUSH
1620: LD_INT 22
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 3
1632: PUSH
1633: LD_INT 21
1635: PUSH
1636: LD_INT 3
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: LD_INT 3
1649: PUSH
1650: LD_INT 24
1652: PUSH
1653: LD_INT 999
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PPUSH
1669: CALL_OW 69
1673: ST_TO_ADDR
// if not tmp then
1674: LD_VAR 0 2
1678: NOT
1679: IFFALSE 1683
// exit ;
1681: GO 1712
// for i in tmp do
1683: LD_ADDR_VAR 0 1
1687: PUSH
1688: LD_VAR 0 2
1692: PUSH
1693: FOR_IN
1694: IFFALSE 1710
// SetLives ( i , 1000 ) ;
1696: LD_VAR 0 1
1700: PPUSH
1701: LD_INT 1000
1703: PPUSH
1704: CALL_OW 234
1708: GO 1693
1710: POP
1711: POP
// end ; end_of_file
1712: PPOPN 2
1714: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1715: LD_INT 0
1717: PPUSH
// uc_side := 1 ;
1718: LD_ADDR_OWVAR 20
1722: PUSH
1723: LD_INT 1
1725: ST_TO_ADDR
// uc_nation := 1 ;
1726: LD_ADDR_OWVAR 21
1730: PUSH
1731: LD_INT 1
1733: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1734: LD_ADDR_EXP 39
1738: PUSH
1739: LD_STRING JMM
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 14_
1750: PPUSH
1751: CALL 65472 0 3
1755: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1756: LD_EXP 4
1760: NOT
1761: PUSH
1762: LD_EXP 4
1766: PUSH
1767: LD_INT 1
1769: ARRAY
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: NOT
1775: OR
1776: IFFALSE 1799
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1778: LD_INT 5
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 1
1786: PPUSH
1787: LD_INT 9
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 70336 0 5
1797: GO 1858
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1799: LD_EXP 4
1803: PUSH
1804: LD_INT 1
1806: ARRAY
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PPUSH
1812: LD_EXP 4
1816: PUSH
1817: LD_INT 2
1819: ARRAY
1820: PUSH
1821: LD_INT 1
1823: ARRAY
1824: PPUSH
1825: LD_EXP 4
1829: PUSH
1830: LD_INT 3
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 4
1842: PUSH
1843: LD_INT 4
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL 70336 0 5
// JMMNewVeh := CreateVehicle ;
1858: LD_ADDR_EXP 56
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// if not JMMNewVeh then
1868: LD_EXP 56
1872: NOT
1873: IFFALSE 1904
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1875: LD_INT 5
1877: PPUSH
1878: LD_INT 3
1880: PPUSH
1881: LD_INT 1
1883: PPUSH
1884: LD_INT 9
1886: PPUSH
1887: LD_INT 100
1889: PPUSH
1890: CALL 70336 0 5
// JMMNewVeh := CreateVehicle ;
1894: LD_ADDR_EXP 56
1898: PUSH
1899: CALL_OW 45
1903: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1904: LD_EXP 56
1908: PPUSH
1909: LD_INT 4
1911: PPUSH
1912: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1916: LD_EXP 56
1920: PPUSH
1921: LD_INT 79
1923: PPUSH
1924: LD_INT 91
1926: PPUSH
1927: LD_INT 0
1929: PPUSH
1930: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1934: LD_EXP 39
1938: PPUSH
1939: LD_EXP 56
1943: PPUSH
1944: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1948: LD_EXP 6
1952: PUSH
1953: LD_EXP 2
1957: NOT
1958: AND
1959: IFFALSE 2217
// begin if not JMMGirlVeh then
1961: LD_EXP 5
1965: NOT
1966: IFFALSE 1989
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1968: LD_INT 3
1970: PPUSH
1971: LD_INT 3
1973: PPUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 9
1979: PPUSH
1980: LD_INT 100
1982: PPUSH
1983: CALL 70336 0 5
1987: GO 2048
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1989: LD_EXP 5
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PPUSH
2002: LD_EXP 5
2006: PUSH
2007: LD_INT 2
2009: ARRAY
2010: PUSH
2011: LD_INT 1
2013: ARRAY
2014: PPUSH
2015: LD_EXP 5
2019: PUSH
2020: LD_INT 3
2022: ARRAY
2023: PUSH
2024: LD_INT 1
2026: ARRAY
2027: PPUSH
2028: LD_EXP 5
2032: PUSH
2033: LD_INT 4
2035: ARRAY
2036: PUSH
2037: LD_INT 1
2039: ARRAY
2040: PPUSH
2041: LD_INT 30
2043: PPUSH
2044: CALL 70336 0 5
// GirlNewVeh := CreateVehicle ;
2048: LD_ADDR_EXP 57
2052: PUSH
2053: CALL_OW 45
2057: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2058: LD_EXP 57
2062: PPUSH
2063: LD_INT 4
2065: PPUSH
2066: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2070: LD_EXP 57
2074: PPUSH
2075: LD_INT 82
2077: PPUSH
2078: LD_INT 96
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 48
// if JMMGirl = 1 then
2088: LD_EXP 7
2092: PUSH
2093: LD_INT 1
2095: EQUAL
2096: IFFALSE 2131
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2098: LD_ADDR_EXP 40
2102: PUSH
2103: LD_STRING Joan
2105: PPUSH
2106: LD_INT 1
2108: PPUSH
2109: LD_STRING 14_
2111: PPUSH
2112: CALL 65472 0 3
2116: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2117: LD_EXP 40
2121: PPUSH
2122: LD_EXP 57
2126: PPUSH
2127: CALL_OW 52
// end ; if JMMGirl = 2 then
2131: LD_EXP 7
2135: PUSH
2136: LD_INT 2
2138: EQUAL
2139: IFFALSE 2174
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2141: LD_ADDR_EXP 42
2145: PUSH
2146: LD_STRING Lisa
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_STRING 14_
2154: PPUSH
2155: CALL 65472 0 3
2159: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2160: LD_EXP 42
2164: PPUSH
2165: LD_EXP 57
2169: PPUSH
2170: CALL_OW 52
// end ; if JMMGirl = 3 then
2174: LD_EXP 7
2178: PUSH
2179: LD_INT 3
2181: EQUAL
2182: IFFALSE 2217
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2184: LD_ADDR_EXP 54
2188: PUSH
2189: LD_STRING Connie
2191: PPUSH
2192: LD_INT 1
2194: PPUSH
2195: LD_STRING 14_
2197: PPUSH
2198: CALL 65472 0 3
2202: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2203: LD_EXP 54
2207: PPUSH
2208: LD_EXP 57
2212: PPUSH
2213: CALL_OW 52
// end ; end ; end ;
2217: LD_VAR 0 1
2221: RET
// export function PrepareStevensSquad ; var tmp ; begin
2222: LD_INT 0
2224: PPUSH
2225: PPUSH
// uc_side := 1 ;
2226: LD_ADDR_OWVAR 20
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// uc_nation := 1 ;
2234: LD_ADDR_OWVAR 21
2238: PUSH
2239: LD_INT 1
2241: ST_TO_ADDR
// tmp := [ ] ;
2242: LD_ADDR_VAR 0 2
2246: PUSH
2247: EMPTY
2248: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2249: LD_ADDR_EXP 41
2253: PUSH
2254: LD_STRING Stevens
2256: PPUSH
2257: LD_EXP 1
2261: NOT
2262: PPUSH
2263: LD_STRING 13f_
2265: PPUSH
2266: CALL 65472 0 3
2270: ST_TO_ADDR
// if not Stevens then
2271: LD_EXP 41
2275: NOT
2276: IFFALSE 2332
// begin hc_name = Baker Smith ;
2278: LD_ADDR_OWVAR 26
2282: PUSH
2283: LD_STRING Baker Smith
2285: ST_TO_ADDR
// hc_gallery =  ;
2286: LD_ADDR_OWVAR 33
2290: PUSH
2291: LD_STRING 
2293: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 10
2299: PPUSH
2300: CALL_OW 384
// Baker = CreateHuman ;
2304: LD_ADDR_EXP 55
2308: PUSH
2309: CALL_OW 44
2313: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2314: LD_ADDR_VAR 0 2
2318: PUSH
2319: LD_VAR 0 2
2323: PUSH
2324: LD_EXP 55
2328: ADD
2329: ST_TO_ADDR
// end else
2330: GO 2348
// tmp := tmp ^ Stevens ;
2332: LD_ADDR_VAR 0 2
2336: PUSH
2337: LD_VAR 0 2
2341: PUSH
2342: LD_EXP 41
2346: ADD
2347: ST_TO_ADDR
// if not Lisa then
2348: LD_EXP 42
2352: NOT
2353: IFFALSE 2399
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2355: LD_ADDR_EXP 42
2359: PUSH
2360: LD_STRING Lisa
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_STRING 13f_
2371: PPUSH
2372: CALL 65472 0 3
2376: ST_TO_ADDR
// if Lisa then
2377: LD_EXP 42
2381: IFFALSE 2399
// tmp := tmp ^ Lisa ;
2383: LD_ADDR_VAR 0 2
2387: PUSH
2388: LD_VAR 0 2
2392: PUSH
2393: LD_EXP 42
2397: ADD
2398: ST_TO_ADDR
// end ; if not Donaldson then
2399: LD_EXP 43
2403: NOT
2404: IFFALSE 2450
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2406: LD_ADDR_EXP 43
2410: PUSH
2411: LD_STRING Donaldson
2413: PPUSH
2414: LD_EXP 1
2418: NOT
2419: PPUSH
2420: LD_STRING 13f_
2422: PPUSH
2423: CALL 65472 0 3
2427: ST_TO_ADDR
// if Donaldson then
2428: LD_EXP 43
2432: IFFALSE 2450
// tmp := tmp ^ Donaldson ;
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 2
2443: PUSH
2444: LD_EXP 43
2448: ADD
2449: ST_TO_ADDR
// end ; if not Bobby then
2450: LD_EXP 44
2454: NOT
2455: IFFALSE 2501
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2457: LD_ADDR_EXP 44
2461: PUSH
2462: LD_STRING Bobby
2464: PPUSH
2465: LD_EXP 1
2469: NOT
2470: PPUSH
2471: LD_STRING 13f_
2473: PPUSH
2474: CALL 65472 0 3
2478: ST_TO_ADDR
// if Bobby then
2479: LD_EXP 44
2483: IFFALSE 2501
// tmp := tmp ^ Bobby ;
2485: LD_ADDR_VAR 0 2
2489: PUSH
2490: LD_VAR 0 2
2494: PUSH
2495: LD_EXP 44
2499: ADD
2500: ST_TO_ADDR
// end ; if not Cyrus then
2501: LD_EXP 45
2505: NOT
2506: IFFALSE 2552
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2508: LD_ADDR_EXP 45
2512: PUSH
2513: LD_STRING Cyrus
2515: PPUSH
2516: LD_EXP 1
2520: NOT
2521: PPUSH
2522: LD_STRING 13f_
2524: PPUSH
2525: CALL 65472 0 3
2529: ST_TO_ADDR
// if Cyrus then
2530: LD_EXP 45
2534: IFFALSE 2552
// tmp := tmp ^ Cyrus ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_VAR 0 2
2545: PUSH
2546: LD_EXP 45
2550: ADD
2551: ST_TO_ADDR
// end ; if not Brown then
2552: LD_EXP 47
2556: NOT
2557: IFFALSE 2603
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2559: LD_ADDR_EXP 47
2563: PUSH
2564: LD_STRING Brown
2566: PPUSH
2567: LD_EXP 1
2571: NOT
2572: PPUSH
2573: LD_STRING 13f_
2575: PPUSH
2576: CALL 65472 0 3
2580: ST_TO_ADDR
// if Brown then
2581: LD_EXP 47
2585: IFFALSE 2603
// tmp := tmp ^ Brown ;
2587: LD_ADDR_VAR 0 2
2591: PUSH
2592: LD_VAR 0 2
2596: PUSH
2597: LD_EXP 47
2601: ADD
2602: ST_TO_ADDR
// end ; if not Gladstone then
2603: LD_EXP 48
2607: NOT
2608: IFFALSE 2654
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2610: LD_ADDR_EXP 48
2614: PUSH
2615: LD_STRING Gladstone
2617: PPUSH
2618: LD_EXP 1
2622: NOT
2623: PPUSH
2624: LD_STRING 13f_
2626: PPUSH
2627: CALL 65472 0 3
2631: ST_TO_ADDR
// if Gladstone then
2632: LD_EXP 48
2636: IFFALSE 2654
// tmp := tmp ^ Gladstone ;
2638: LD_ADDR_VAR 0 2
2642: PUSH
2643: LD_VAR 0 2
2647: PUSH
2648: LD_EXP 48
2652: ADD
2653: ST_TO_ADDR
// end ; if not Houten then
2654: LD_EXP 49
2658: NOT
2659: IFFALSE 2705
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2661: LD_ADDR_EXP 49
2665: PUSH
2666: LD_STRING Houten
2668: PPUSH
2669: LD_EXP 1
2673: NOT
2674: PPUSH
2675: LD_STRING 13f_
2677: PPUSH
2678: CALL 65472 0 3
2682: ST_TO_ADDR
// if Houten then
2683: LD_EXP 49
2687: IFFALSE 2705
// tmp := tmp ^ Houten ;
2689: LD_ADDR_VAR 0 2
2693: PUSH
2694: LD_VAR 0 2
2698: PUSH
2699: LD_EXP 49
2703: ADD
2704: ST_TO_ADDR
// end ; if not Cornel then
2705: LD_EXP 50
2709: NOT
2710: IFFALSE 2756
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2712: LD_ADDR_EXP 50
2716: PUSH
2717: LD_STRING Cornell
2719: PPUSH
2720: LD_EXP 1
2724: NOT
2725: PPUSH
2726: LD_STRING 13f_
2728: PPUSH
2729: CALL 65472 0 3
2733: ST_TO_ADDR
// if Cornel then
2734: LD_EXP 50
2738: IFFALSE 2756
// tmp := tmp ^ Cornel ;
2740: LD_ADDR_VAR 0 2
2744: PUSH
2745: LD_VAR 0 2
2749: PUSH
2750: LD_EXP 50
2754: ADD
2755: ST_TO_ADDR
// end ; if not Gary then
2756: LD_EXP 51
2760: NOT
2761: IFFALSE 2807
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2763: LD_ADDR_EXP 51
2767: PUSH
2768: LD_STRING Gary
2770: PPUSH
2771: LD_EXP 1
2775: NOT
2776: PPUSH
2777: LD_STRING 13f_
2779: PPUSH
2780: CALL 65472 0 3
2784: ST_TO_ADDR
// if Gary then
2785: LD_EXP 51
2789: IFFALSE 2807
// tmp := tmp ^ Gary ;
2791: LD_ADDR_VAR 0 2
2795: PUSH
2796: LD_VAR 0 2
2800: PUSH
2801: LD_EXP 51
2805: ADD
2806: ST_TO_ADDR
// end ; if not Frank then
2807: LD_EXP 52
2811: NOT
2812: IFFALSE 2858
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2814: LD_ADDR_EXP 52
2818: PUSH
2819: LD_STRING Frank
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_STRING 13f_
2830: PPUSH
2831: CALL 65472 0 3
2835: ST_TO_ADDR
// if Frank then
2836: LD_EXP 52
2840: IFFALSE 2858
// tmp := tmp ^ Frank ;
2842: LD_ADDR_VAR 0 2
2846: PUSH
2847: LD_VAR 0 2
2851: PUSH
2852: LD_EXP 52
2856: ADD
2857: ST_TO_ADDR
// end ; if not Kikuchi then
2858: LD_EXP 53
2862: NOT
2863: IFFALSE 2909
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2865: LD_ADDR_EXP 53
2869: PUSH
2870: LD_STRING Kikuchi
2872: PPUSH
2873: LD_EXP 1
2877: NOT
2878: PPUSH
2879: LD_STRING 13f_
2881: PPUSH
2882: CALL 65472 0 3
2886: ST_TO_ADDR
// if Kikuchi then
2887: LD_EXP 53
2891: IFFALSE 2909
// tmp := tmp ^ Kikuchi ;
2893: LD_ADDR_VAR 0 2
2897: PUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_EXP 53
2907: ADD
2908: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_STRING 13_other_survivors
2921: PPUSH
2922: CALL_OW 31
2926: UNION
2927: ST_TO_ADDR
// result := tmp ;
2928: LD_ADDR_VAR 0 1
2932: PUSH
2933: LD_VAR 0 2
2937: ST_TO_ADDR
// end ; end_of_file
2938: LD_VAR 0 1
2942: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2943: LD_INT 0
2945: PPUSH
2946: PPUSH
2947: PPUSH
2948: PPUSH
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
// uc_side := 4 ;
2955: LD_ADDR_OWVAR 20
2959: PUSH
2960: LD_INT 4
2962: ST_TO_ADDR
// uc_nation := 1 ;
2963: LD_ADDR_OWVAR 21
2967: PUSH
2968: LD_INT 1
2970: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2971: LD_INT 387
2973: PPUSH
2974: CALL_OW 274
2978: PPUSH
2979: LD_INT 1
2981: PPUSH
2982: LD_INT 3500
2984: PUSH
2985: LD_INT 3000
2987: PUSH
2988: LD_INT 2500
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_OWVAR 67
3000: ARRAY
3001: PPUSH
3002: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3006: LD_INT 387
3008: PPUSH
3009: CALL_OW 274
3013: PPUSH
3014: LD_INT 2
3016: PPUSH
3017: LD_INT 400
3019: PPUSH
3020: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3024: LD_INT 387
3026: PPUSH
3027: CALL_OW 274
3031: PPUSH
3032: LD_INT 3
3034: PPUSH
3035: LD_INT 10
3037: PPUSH
3038: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3042: LD_ADDR_EXP 58
3046: PUSH
3047: LD_STRING Powell
3049: PPUSH
3050: CALL_OW 25
3054: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3055: LD_EXP 58
3059: PPUSH
3060: LD_INT 57
3062: PPUSH
3063: LD_INT 94
3065: PPUSH
3066: LD_INT 0
3068: PPUSH
3069: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3073: LD_EXP 58
3077: PPUSH
3078: LD_INT 58
3080: PPUSH
3081: LD_INT 94
3083: PPUSH
3084: CALL_OW 118
// vip := [ ] ;
3088: LD_ADDR_EXP 59
3092: PUSH
3093: EMPTY
3094: ST_TO_ADDR
// tmp := [ ] ;
3095: LD_ADDR_VAR 0 6
3099: PUSH
3100: EMPTY
3101: ST_TO_ADDR
// if JMMGirl <> 2 then
3102: LD_EXP 7
3106: PUSH
3107: LD_INT 2
3109: NONEQUAL
3110: IFFALSE 3134
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3112: LD_ADDR_EXP 42
3116: PUSH
3117: LD_STRING Lisa
3119: PPUSH
3120: LD_EXP 1
3124: NOT
3125: PPUSH
3126: LD_STRING 13s_
3128: PPUSH
3129: CALL 65472 0 3
3133: ST_TO_ADDR
// if Lisa then
3134: LD_EXP 42
3138: IFFALSE 3156
// tmp := tmp ^ Lisa ;
3140: LD_ADDR_VAR 0 6
3144: PUSH
3145: LD_VAR 0 6
3149: PUSH
3150: LD_EXP 42
3154: ADD
3155: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3156: LD_ADDR_EXP 43
3160: PUSH
3161: LD_STRING Donaldson
3163: PPUSH
3164: LD_EXP 1
3168: NOT
3169: PPUSH
3170: LD_STRING 13s_
3172: PPUSH
3173: CALL 65472 0 3
3177: ST_TO_ADDR
// if Donaldson then
3178: LD_EXP 43
3182: IFFALSE 3200
// tmp := tmp ^ Donaldson ;
3184: LD_ADDR_VAR 0 6
3188: PUSH
3189: LD_VAR 0 6
3193: PUSH
3194: LD_EXP 43
3198: ADD
3199: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3200: LD_ADDR_EXP 44
3204: PUSH
3205: LD_STRING Bobby
3207: PPUSH
3208: LD_EXP 1
3212: NOT
3213: PPUSH
3214: LD_STRING 13s_
3216: PPUSH
3217: CALL 65472 0 3
3221: ST_TO_ADDR
// if Bobby then
3222: LD_EXP 44
3226: IFFALSE 3244
// tmp := tmp ^ Bobby ;
3228: LD_ADDR_VAR 0 6
3232: PUSH
3233: LD_VAR 0 6
3237: PUSH
3238: LD_EXP 44
3242: ADD
3243: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3244: LD_ADDR_EXP 45
3248: PUSH
3249: LD_STRING Cyrus
3251: PPUSH
3252: LD_EXP 1
3256: NOT
3257: PPUSH
3258: LD_STRING 13s_
3260: PPUSH
3261: CALL 65472 0 3
3265: ST_TO_ADDR
// if Cyrus then
3266: LD_EXP 45
3270: IFFALSE 3288
// tmp := tmp ^ Cyrus ;
3272: LD_ADDR_VAR 0 6
3276: PUSH
3277: LD_VAR 0 6
3281: PUSH
3282: LD_EXP 45
3286: ADD
3287: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3288: LD_ADDR_EXP 46
3292: PUSH
3293: LD_STRING Denis
3295: PPUSH
3296: LD_EXP 1
3300: NOT
3301: PPUSH
3302: LD_STRING 13s_
3304: PPUSH
3305: CALL 65472 0 3
3309: ST_TO_ADDR
// if not Denis then
3310: LD_EXP 46
3314: NOT
3315: IFFALSE 3339
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3317: LD_ADDR_EXP 46
3321: PUSH
3322: LD_STRING Denis
3324: PPUSH
3325: LD_EXP 1
3329: NOT
3330: PPUSH
3331: LD_STRING 13f_
3333: PPUSH
3334: CALL 65472 0 3
3338: ST_TO_ADDR
// if Denis then
3339: LD_EXP 46
3343: IFFALSE 3361
// tmp := tmp ^ Denis ;
3345: LD_ADDR_VAR 0 6
3349: PUSH
3350: LD_VAR 0 6
3354: PUSH
3355: LD_EXP 46
3359: ADD
3360: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3361: LD_ADDR_EXP 47
3365: PUSH
3366: LD_STRING Brown
3368: PPUSH
3369: LD_EXP 1
3373: NOT
3374: PPUSH
3375: LD_STRING 13s_
3377: PPUSH
3378: CALL 65472 0 3
3382: ST_TO_ADDR
// if Brown then
3383: LD_EXP 47
3387: IFFALSE 3405
// tmp := tmp ^ Brown ;
3389: LD_ADDR_VAR 0 6
3393: PUSH
3394: LD_VAR 0 6
3398: PUSH
3399: LD_EXP 47
3403: ADD
3404: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3405: LD_ADDR_EXP 48
3409: PUSH
3410: LD_STRING Gladstone
3412: PPUSH
3413: LD_EXP 1
3417: NOT
3418: PPUSH
3419: LD_STRING 13s_
3421: PPUSH
3422: CALL 65472 0 3
3426: ST_TO_ADDR
// if Gladstone then
3427: LD_EXP 48
3431: IFFALSE 3449
// tmp := tmp ^ Gladstone ;
3433: LD_ADDR_VAR 0 6
3437: PUSH
3438: LD_VAR 0 6
3442: PUSH
3443: LD_EXP 48
3447: ADD
3448: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3449: LD_ADDR_EXP 49
3453: PUSH
3454: LD_STRING Houten
3456: PPUSH
3457: LD_EXP 1
3461: NOT
3462: PPUSH
3463: LD_STRING 13s_
3465: PPUSH
3466: CALL 65472 0 3
3470: ST_TO_ADDR
// if Houten then
3471: LD_EXP 49
3475: IFFALSE 3493
// tmp := tmp ^ Houten ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_VAR 0 6
3486: PUSH
3487: LD_EXP 49
3491: ADD
3492: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3493: LD_ADDR_EXP 50
3497: PUSH
3498: LD_STRING Cornel
3500: PPUSH
3501: LD_EXP 1
3505: NOT
3506: PPUSH
3507: LD_STRING 13s_
3509: PPUSH
3510: CALL 65472 0 3
3514: ST_TO_ADDR
// if Cornel then
3515: LD_EXP 50
3519: IFFALSE 3537
// tmp := tmp ^ Cornel ;
3521: LD_ADDR_VAR 0 6
3525: PUSH
3526: LD_VAR 0 6
3530: PUSH
3531: LD_EXP 50
3535: ADD
3536: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3537: LD_ADDR_EXP 51
3541: PUSH
3542: LD_STRING Gary
3544: PPUSH
3545: LD_EXP 1
3549: NOT
3550: PPUSH
3551: LD_STRING 13s_
3553: PPUSH
3554: CALL 65472 0 3
3558: ST_TO_ADDR
// if Gary then
3559: LD_EXP 51
3563: IFFALSE 3581
// tmp := tmp ^ Gary ;
3565: LD_ADDR_VAR 0 6
3569: PUSH
3570: LD_VAR 0 6
3574: PUSH
3575: LD_EXP 51
3579: ADD
3580: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3581: LD_ADDR_EXP 52
3585: PUSH
3586: LD_STRING Frank
3588: PPUSH
3589: LD_EXP 1
3593: NOT
3594: PPUSH
3595: LD_STRING 13s_
3597: PPUSH
3598: CALL 65472 0 3
3602: ST_TO_ADDR
// if Frank then
3603: LD_EXP 52
3607: IFFALSE 3625
// tmp := tmp ^ Frank ;
3609: LD_ADDR_VAR 0 6
3613: PUSH
3614: LD_VAR 0 6
3618: PUSH
3619: LD_EXP 52
3623: ADD
3624: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3625: LD_ADDR_EXP 53
3629: PUSH
3630: LD_STRING Kikuchi
3632: PPUSH
3633: LD_EXP 1
3637: NOT
3638: PPUSH
3639: LD_STRING 13s_
3641: PPUSH
3642: CALL 65472 0 3
3646: ST_TO_ADDR
// if Kikuchi then
3647: LD_EXP 53
3651: IFFALSE 3669
// tmp := tmp ^ Kikuchi ;
3653: LD_ADDR_VAR 0 6
3657: PUSH
3658: LD_VAR 0 6
3662: PUSH
3663: LD_EXP 53
3667: ADD
3668: ST_TO_ADDR
// vip := tmp ;
3669: LD_ADDR_EXP 59
3673: PUSH
3674: LD_VAR 0 6
3678: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3679: LD_ADDR_VAR 0 6
3683: PUSH
3684: LD_VAR 0 6
3688: PUSH
3689: LD_STRING 13s_others
3691: PPUSH
3692: CALL_OW 31
3696: UNION
3697: ST_TO_ADDR
// if tmp < 18 then
3698: LD_VAR 0 6
3702: PUSH
3703: LD_INT 18
3705: LESS
3706: IFFALSE 3773
// for i = 1 to 18 - tmp do
3708: LD_ADDR_VAR 0 2
3712: PUSH
3713: DOUBLE
3714: LD_INT 1
3716: DEC
3717: ST_TO_ADDR
3718: LD_INT 18
3720: PUSH
3721: LD_VAR 0 6
3725: MINUS
3726: PUSH
3727: FOR_TO
3728: IFFALSE 3771
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3730: LD_INT 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PUSH
3738: LD_INT 4
3740: MOD
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_INT 5
3748: PPUSH
3749: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3753: LD_ADDR_VAR 0 6
3757: PUSH
3758: LD_VAR 0 6
3762: PUSH
3763: CALL_OW 44
3767: ADD
3768: ST_TO_ADDR
// end ;
3769: GO 3727
3771: POP
3772: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_INT 22
3780: PUSH
3781: LD_INT 4
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 30
3790: PUSH
3791: LD_INT 0
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: PPUSH
3802: CALL_OW 69
3806: PUSH
3807: LD_INT 1
3809: ARRAY
3810: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3811: LD_ADDR_VAR 0 8
3815: PUSH
3816: LD_INT 22
3818: PUSH
3819: LD_INT 4
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PUSH
3826: LD_INT 30
3828: PUSH
3829: LD_INT 6
3831: PUSH
3832: EMPTY
3833: LIST
3834: LIST
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3849: LD_ADDR_VAR 0 9
3853: PUSH
3854: LD_INT 22
3856: PUSH
3857: LD_INT 4
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: LD_INT 30
3866: PUSH
3867: LD_INT 4
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: CALL_OW 69
3882: PUSH
3883: LD_INT 1
3885: ARRAY
3886: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3887: LD_ADDR_VAR 0 10
3891: PUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 4
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 30
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: EMPTY
3913: LIST
3914: LIST
3915: PPUSH
3916: CALL_OW 69
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: ST_TO_ADDR
// for i in tmp do
3925: LD_ADDR_VAR 0 2
3929: PUSH
3930: LD_VAR 0 6
3934: PUSH
3935: FOR_IN
3936: IFFALSE 4062
// begin cl := GetClass ( i ) ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 257
3952: ST_TO_ADDR
// if cl > 4 then
3953: LD_VAR 0 5
3957: PUSH
3958: LD_INT 4
3960: GREATER
3961: IFFALSE 3971
// cl := 1 ;
3963: LD_ADDR_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3971: LD_ADDR_VAR 0 3
3975: PUSH
3976: LD_VAR 0 9
3980: PUSH
3981: LD_VAR 0 7
3985: PUSH
3986: LD_VAR 0 10
3990: PUSH
3991: LD_VAR 0 8
3995: PUSH
3996: EMPTY
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_VAR 0 5
4006: ARRAY
4007: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4008: LD_VAR 0 3
4012: PPUSH
4013: CALL_OW 313
4017: PUSH
4018: LD_INT 6
4020: LESS
4021: IFFALSE 4039
// PlaceHumanInUnit ( i , b ) else
4023: LD_VAR 0 2
4027: PPUSH
4028: LD_VAR 0 3
4032: PPUSH
4033: CALL_OW 52
4037: GO 4060
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4039: LD_VAR 0 2
4043: PPUSH
4044: LD_INT 61
4046: PPUSH
4047: LD_INT 89
4049: PPUSH
4050: LD_INT 6
4052: PPUSH
4053: LD_INT 0
4055: PPUSH
4056: CALL_OW 50
// end ;
4060: GO 3935
4062: POP
4063: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4064: LD_INT 2
4066: PPUSH
4067: LD_INT 1
4069: PPUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 12
4075: PPUSH
4076: LD_INT 100
4078: PPUSH
4079: CALL 70336 0 5
// veh := CreateVehicle ;
4083: LD_ADDR_VAR 0 4
4087: PUSH
4088: CALL_OW 45
4092: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4093: LD_VAR 0 4
4097: PPUSH
4098: LD_INT 4
4100: PPUSH
4101: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4105: LD_VAR 0 4
4109: PPUSH
4110: LD_INT 49
4112: PPUSH
4113: LD_INT 88
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4123: LD_VAR 0 4
4127: PPUSH
4128: LD_INT 1
4130: PPUSH
4131: LD_INT 100
4133: PPUSH
4134: CALL_OW 290
// uc_side := 0 ;
4138: LD_ADDR_OWVAR 20
4142: PUSH
4143: LD_INT 0
4145: ST_TO_ADDR
// uc_nation := 0 ;
4146: LD_ADDR_OWVAR 21
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// for i = 1 to 4 do
4154: LD_ADDR_VAR 0 2
4158: PUSH
4159: DOUBLE
4160: LD_INT 1
4162: DEC
4163: ST_TO_ADDR
4164: LD_INT 4
4166: PUSH
4167: FOR_TO
4168: IFFALSE 4199
// begin InitHc ;
4170: CALL_OW 19
// hc_class := class_apeman ;
4174: LD_ADDR_OWVAR 28
4178: PUSH
4179: LD_INT 12
4181: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4182: CALL_OW 44
4186: PPUSH
4187: LD_INT 13
4189: PPUSH
4190: LD_INT 0
4192: PPUSH
4193: CALL_OW 49
// end ;
4197: GO 4167
4199: POP
4200: POP
// end ; end_of_file
4201: LD_VAR 0 1
4205: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4206: LD_INT 0
4208: PPUSH
4209: PPUSH
4210: PPUSH
4211: PPUSH
4212: PPUSH
// side := 8 ;
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: LD_INT 8
4220: ST_TO_ADDR
// uc_side := side ;
4221: LD_ADDR_OWVAR 20
4225: PUSH
4226: LD_VAR 0 3
4230: ST_TO_ADDR
// uc_nation := 2 ;
4231: LD_ADDR_OWVAR 21
4235: PUSH
4236: LD_INT 2
4238: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_VAR 0 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: PUSH
4275: FOR_IN
4276: IFFALSE 4292
// SetBLevel ( i , 10 ) ;
4278: LD_VAR 0 2
4282: PPUSH
4283: LD_INT 10
4285: PPUSH
4286: CALL_OW 241
4290: GO 4275
4292: POP
4293: POP
// if KurtStatus then
4294: LD_EXP 3
4298: IFFALSE 4321
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4300: LD_ADDR_EXP 60
4304: PUSH
4305: LD_STRING Kurt
4307: PPUSH
4308: LD_INT 0
4310: PPUSH
4311: LD_STRING 
4313: PPUSH
4314: CALL 65472 0 3
4318: ST_TO_ADDR
4319: GO 4343
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4321: LD_ADDR_EXP 60
4325: PUSH
4326: LD_STRING AltKurt
4328: PPUSH
4329: LD_EXP 1
4333: NOT
4334: PPUSH
4335: LD_STRING 
4337: PPUSH
4338: CALL 65472 0 3
4342: ST_TO_ADDR
// if not Kurt then
4343: LD_EXP 60
4347: NOT
4348: IFFALSE 4374
// begin InitHc ;
4350: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4354: LD_INT 1
4356: PPUSH
4357: LD_INT 10
4359: PPUSH
4360: CALL_OW 381
// Kurt := CreateHuman ;
4364: LD_ADDR_EXP 60
4368: PUSH
4369: CALL_OW 44
4373: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4374: LD_EXP 60
4378: PPUSH
4379: LD_INT 324
4381: PPUSH
4382: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4386: LD_ADDR_EXP 61
4390: PUSH
4391: LD_STRING Kozlov
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: LD_STRING 
4399: PPUSH
4400: CALL 65472 0 3
4404: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4405: LD_EXP 61
4409: PPUSH
4410: LD_INT 22
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 23
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 30
4432: PUSH
4433: LD_INT 8
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: LIST
4444: PPUSH
4445: CALL_OW 69
4449: PUSH
4450: LD_INT 1
4452: ARRAY
4453: PPUSH
4454: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4458: LD_EXP 61
4462: PPUSH
4463: LD_INT 3
4465: PPUSH
4466: LD_INT 10
4468: PPUSH
4469: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 4
4480: PPUSH
4481: LD_INT 10
4483: PPUSH
4484: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4488: LD_ADDR_VAR 0 5
4492: PUSH
4493: LD_INT 22
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 30
4507: PUSH
4508: LD_INT 32
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 58
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: LIST
4525: PPUSH
4526: CALL_OW 69
4530: ST_TO_ADDR
// for i = 1 to 10 do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: DOUBLE
4537: LD_INT 1
4539: DEC
4540: ST_TO_ADDR
4541: LD_INT 10
4543: PUSH
4544: FOR_TO
4545: IFFALSE 4617
// begin uc_nation := nation_nature ;
4547: LD_ADDR_OWVAR 21
4551: PUSH
4552: LD_INT 0
4554: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4555: LD_ADDR_OWVAR 28
4559: PUSH
4560: LD_INT 15
4562: ST_TO_ADDR
// hc_gallery :=  ;
4563: LD_ADDR_OWVAR 33
4567: PUSH
4568: LD_STRING 
4570: ST_TO_ADDR
// hc_name :=  ;
4571: LD_ADDR_OWVAR 26
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// un := CreateHuman ;
4579: LD_ADDR_VAR 0 4
4583: PUSH
4584: CALL_OW 44
4588: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4589: LD_VAR 0 4
4593: PPUSH
4594: LD_VAR 0 5
4598: PUSH
4599: LD_VAR 0 5
4603: PUSH
4604: LD_VAR 0 2
4608: MINUS
4609: ARRAY
4610: PPUSH
4611: CALL_OW 52
// end ;
4615: GO 4544
4617: POP
4618: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4619: LD_ADDR_VAR 0 5
4623: PUSH
4624: LD_STRING 12_kurt_squad
4626: PPUSH
4627: CALL_OW 31
4631: ST_TO_ADDR
// if tmp then
4632: LD_VAR 0 5
4636: IFFALSE 4670
// for i in tmp do
4638: LD_ADDR_VAR 0 2
4642: PUSH
4643: LD_VAR 0 5
4647: PUSH
4648: FOR_IN
4649: IFFALSE 4668
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4651: LD_VAR 0 2
4655: PPUSH
4656: LD_INT 5
4658: PPUSH
4659: LD_INT 0
4661: PPUSH
4662: CALL_OW 49
4666: GO 4648
4668: POP
4669: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4670: LD_INT 324
4672: PPUSH
4673: LD_INT 5
4675: PPUSH
4676: LD_STRING 
4678: PPUSH
4679: LD_INT 8
4681: PUSH
4682: LD_INT 9
4684: PUSH
4685: LD_INT 10
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: LIST
4692: PUSH
4693: LD_OWVAR 67
4697: ARRAY
4698: PPUSH
4699: LD_INT 3000
4701: PUSH
4702: LD_INT 500
4704: PUSH
4705: LD_INT 150
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: LIST
4712: PPUSH
4713: LD_INT 16
4715: PUSH
4716: LD_INT 6
4718: PUSH
4719: LD_INT 6
4721: PUSH
4722: LD_INT 8
4724: PUSH
4725: EMPTY
4726: LIST
4727: LIST
4728: LIST
4729: LIST
4730: PPUSH
4731: CALL 73783 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4735: LD_ADDR_EXP 116
4739: PUSH
4740: LD_EXP 116
4744: PPUSH
4745: LD_INT 3
4747: PPUSH
4748: LD_INT 22
4750: PUSH
4751: LD_VAR 0 3
4755: PUSH
4756: EMPTY
4757: LIST
4758: LIST
4759: PUSH
4760: LD_INT 23
4762: PUSH
4763: LD_INT 2
4765: PUSH
4766: EMPTY
4767: LIST
4768: LIST
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 21
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: LIST
4791: PPUSH
4792: CALL_OW 69
4796: PUSH
4797: LD_EXP 60
4801: DIFF
4802: PPUSH
4803: CALL_OW 1
4807: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 7
4813: PPUSH
4814: CALL_OW 383
// Friend := CreateHuman ;
4818: LD_ADDR_EXP 62
4822: PUSH
4823: CALL_OW 44
4827: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4828: LD_INT 14
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 29
4839: PPUSH
4840: LD_INT 100
4842: PPUSH
4843: CALL 70336 0 5
// powellBomb := CreateVehicle ;
4847: LD_ADDR_EXP 63
4851: PUSH
4852: CALL_OW 45
4856: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4857: LD_EXP 63
4861: PPUSH
4862: LD_INT 90
4864: PPUSH
4865: LD_INT 51
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// end ;
4875: LD_VAR 0 1
4879: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
4884: PPUSH
// if IsLive ( kozlov_fac ) then
4885: LD_INT 332
4887: PPUSH
4888: CALL_OW 300
4892: IFFALSE 4896
// exit ;
4894: GO 5463
// ComExitBuilding ( Kozlov ) ;
4896: LD_EXP 61
4900: PPUSH
4901: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4905: LD_EXP 61
4909: PPUSH
4910: CALL_OW 257
4914: PUSH
4915: LD_INT 2
4917: NONEQUAL
4918: IFFALSE 4953
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4920: LD_EXP 61
4924: PPUSH
4925: LD_INT 324
4927: PPUSH
4928: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 2
4939: PPUSH
4940: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4944: LD_EXP 61
4948: PPUSH
4949: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4953: LD_EXP 61
4957: PPUSH
4958: LD_INT 2
4960: PPUSH
4961: LD_INT 93
4963: PPUSH
4964: LD_INT 32
4966: PPUSH
4967: LD_INT 3
4969: PPUSH
4970: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4974: LD_INT 35
4976: PPUSH
4977: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4981: LD_INT 22
4983: PUSH
4984: LD_INT 8
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: PUSH
5001: LD_INT 23
5003: PUSH
5004: LD_INT 3
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 57
5013: PUSH
5014: EMPTY
5015: LIST
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PPUSH
5023: CALL_OW 69
5027: IFFALSE 4974
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5029: LD_ADDR_VAR 0 2
5033: PUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 8
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PUSH
5044: LD_INT 30
5046: PUSH
5047: LD_INT 3
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 23
5056: PUSH
5057: LD_INT 3
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: LD_INT 57
5066: PUSH
5067: EMPTY
5068: LIST
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 69
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5085: LD_INT 22
5087: PUSH
5088: LD_INT 8
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PUSH
5095: LD_INT 23
5097: PUSH
5098: LD_INT 3
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: PUSH
5105: LD_INT 30
5107: PUSH
5108: LD_INT 21
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 5203
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5127: LD_EXP 61
5131: PPUSH
5132: LD_INT 21
5134: PPUSH
5135: LD_INT 97
5137: PPUSH
5138: LD_INT 36
5140: PPUSH
5141: LD_INT 5
5143: PPUSH
5144: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5148: LD_INT 35
5150: PPUSH
5151: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5155: LD_INT 22
5157: PUSH
5158: LD_INT 8
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: PUSH
5165: LD_INT 23
5167: PUSH
5168: LD_INT 3
5170: PUSH
5171: EMPTY
5172: LIST
5173: LIST
5174: PUSH
5175: LD_INT 30
5177: PUSH
5178: LD_INT 21
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: PUSH
5185: LD_INT 57
5187: PUSH
5188: EMPTY
5189: LIST
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PPUSH
5197: CALL_OW 69
5201: IFFALSE 5148
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5203: LD_INT 22
5205: PUSH
5206: LD_INT 8
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PUSH
5213: LD_INT 23
5215: PUSH
5216: LD_INT 3
5218: PUSH
5219: EMPTY
5220: LIST
5221: LIST
5222: PUSH
5223: LD_INT 30
5225: PUSH
5226: LD_INT 18
5228: PUSH
5229: EMPTY
5230: LIST
5231: LIST
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 69
5242: NOT
5243: IFFALSE 5321
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5245: LD_EXP 61
5249: PPUSH
5250: LD_INT 18
5252: PPUSH
5253: LD_INT 89
5255: PPUSH
5256: LD_INT 32
5258: PPUSH
5259: LD_INT 1
5261: PPUSH
5262: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5266: LD_INT 35
5268: PPUSH
5269: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5273: LD_INT 22
5275: PUSH
5276: LD_INT 8
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: PUSH
5283: LD_INT 23
5285: PUSH
5286: LD_INT 3
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 30
5295: PUSH
5296: LD_INT 18
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 57
5305: PUSH
5306: EMPTY
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 69
5319: IFFALSE 5266
// end ; lab := kozlov_lab ;
5321: LD_ADDR_VAR 0 3
5325: PUSH
5326: LD_INT 336
5328: ST_TO_ADDR
// if not lab then
5329: LD_VAR 0 3
5333: NOT
5334: IFFALSE 5338
// exit ;
5336: GO 5463
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5338: LD_EXP 61
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5356: LD_EXP 61
5360: PPUSH
5361: LD_INT 4
5363: PPUSH
5364: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5368: LD_VAR 0 3
5372: PUSH
5373: LD_INT 1
5375: ARRAY
5376: PPUSH
5377: LD_INT 25
5379: PPUSH
5380: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5384: LD_INT 35
5386: PPUSH
5387: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5391: LD_INT 25
5393: PPUSH
5394: LD_INT 8
5396: PPUSH
5397: CALL_OW 321
5401: PUSH
5402: LD_INT 2
5404: EQUAL
5405: IFFALSE 5384
// ComExitBuilding ( Kozlov ) ;
5407: LD_EXP 61
5411: PPUSH
5412: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5416: LD_EXP 61
5420: PPUSH
5421: LD_VAR 0 2
5425: PPUSH
5426: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5430: LD_EXP 61
5434: PPUSH
5435: LD_INT 3
5437: PPUSH
5438: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5442: LD_VAR 0 2
5446: PPUSH
5447: LD_INT 23
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: LD_INT 1
5455: PPUSH
5456: LD_INT 48
5458: PPUSH
5459: CALL_OW 125
// end ;
5463: LD_VAR 0 1
5467: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5468: LD_EXP 22
5472: NOT
5473: PUSH
5474: LD_EXP 15
5478: PUSH
5479: LD_INT 6
5481: GREATEREQUAL
5482: AND
5483: IFFALSE 5564
5485: GO 5487
5487: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5488: LD_INT 3
5490: PPUSH
5491: LD_INT 3
5493: PPUSH
5494: CALL 59212 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5498: LD_INT 3
5500: PPUSH
5501: LD_INT 14
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 1
5509: PUSH
5510: LD_INT 28
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 14
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 14
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 28
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL 59075 0 2
// end ;
5564: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5565: LD_EXP 22
5569: NOT
5570: PUSH
5571: LD_EXP 15
5575: PUSH
5576: LD_INT 6
5578: GREATEREQUAL
5579: AND
5580: PUSH
5581: LD_INT 3
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: CALL 60493 0 2
5591: NOT
5592: AND
5593: IFFALSE 6433
5595: GO 5597
5597: DISABLE
5598: LD_INT 0
5600: PPUSH
5601: PPUSH
5602: PPUSH
// begin enable ;
5603: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5604: LD_INT 22
5606: PUSH
5607: LD_INT 8
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 23
5616: PUSH
5617: LD_INT 2
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 30
5626: PUSH
5627: LD_INT 3
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 69
5643: NOT
5644: IFFALSE 5648
// exit ;
5646: GO 6433
// if Prob ( 40 ) then
5648: LD_INT 40
5650: PPUSH
5651: CALL_OW 13
5655: IFFALSE 5782
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5657: LD_INT 3
5659: PPUSH
5660: LD_INT 14
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 2
5668: PUSH
5669: LD_INT 28
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 28
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: LIST
5694: LIST
5695: PUSH
5696: LD_INT 14
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 2
5704: PUSH
5705: LD_INT 28
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 14
5716: PUSH
5717: LD_INT 1
5719: PUSH
5720: LD_INT 2
5722: PUSH
5723: LD_INT 28
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 14
5734: PUSH
5735: LD_INT 1
5737: PUSH
5738: LD_INT 2
5740: PUSH
5741: LD_INT 28
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: PUSH
5750: LD_INT 14
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 26
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PPUSH
5776: CALL 59075 0 2
// end else
5780: GO 5973
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5782: LD_INT 3
5784: PPUSH
5785: LD_INT 14
5787: PUSH
5788: LD_INT 1
5790: PUSH
5791: LD_INT 2
5793: PUSH
5794: LD_INT 27
5796: PUSH
5797: LD_INT 26
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: LD_OWVAR 67
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 14
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: LD_INT 2
5828: PUSH
5829: LD_INT 27
5831: PUSH
5832: LD_INT 26
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_OWVAR 67
5847: ARRAY
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 14
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: LD_INT 26
5866: PUSH
5867: LD_INT 26
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PUSH
5878: LD_OWVAR 67
5882: ARRAY
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 13
5892: PUSH
5893: LD_INT 1
5895: PUSH
5896: LD_INT 2
5898: PUSH
5899: LD_INT 26
5901: PUSH
5902: LD_INT 29
5904: PUSH
5905: LD_INT 29
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: PUSH
5913: LD_OWVAR 67
5917: ARRAY
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 13
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 29
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 14
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 26
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PPUSH
5969: CALL 59075 0 2
// end ; repeat wait ( 0 0$1 ) ;
5973: LD_INT 35
5975: PPUSH
5976: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5980: LD_INT 3
5982: PPUSH
5983: LD_INT 1
5985: PPUSH
5986: CALL 60493 0 2
5990: PUSH
5991: LD_INT 6
5993: GREATEREQUAL
5994: IFFALSE 5973
// wait ( 0 0$30 ) ;
5996: LD_INT 1050
5998: PPUSH
5999: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6003: LD_ADDR_VAR 0 2
6007: PUSH
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60493 0 2
6018: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6019: LD_ADDR_EXP 135
6023: PUSH
6024: LD_EXP 135
6028: PPUSH
6029: LD_INT 3
6031: PPUSH
6032: LD_EXP 135
6036: PUSH
6037: LD_INT 3
6039: ARRAY
6040: PUSH
6041: LD_VAR 0 2
6045: DIFF
6046: PPUSH
6047: CALL_OW 1
6051: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6052: LD_ADDR_VAR 0 3
6056: PUSH
6057: LD_INT 0
6059: PPUSH
6060: LD_INT 2
6062: PPUSH
6063: CALL_OW 12
6067: ST_TO_ADDR
// if target then
6068: LD_VAR 0 3
6072: IFFALSE 6200
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6074: LD_ADDR_VAR 0 2
6078: PUSH
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 24
6086: PUSH
6087: LD_INT 250
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL_OW 72
6098: ST_TO_ADDR
// for i in tmp do
6099: LD_ADDR_VAR 0 1
6103: PUSH
6104: LD_VAR 0 2
6108: PUSH
6109: FOR_IN
6110: IFFALSE 6150
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6112: LD_VAR 0 1
6116: PPUSH
6117: LD_INT 89
6119: PPUSH
6120: LD_INT 71
6122: PPUSH
6123: CALL_OW 297
6127: PUSH
6128: LD_INT 9
6130: GREATER
6131: IFFALSE 6148
// ComMoveXY ( i , 89 , 71 ) ;
6133: LD_VAR 0 1
6137: PPUSH
6138: LD_INT 89
6140: PPUSH
6141: LD_INT 71
6143: PPUSH
6144: CALL_OW 111
6148: GO 6109
6150: POP
6151: POP
// wait ( 0 0$1 ) ;
6152: LD_INT 35
6154: PPUSH
6155: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6159: LD_VAR 0 2
6163: PPUSH
6164: LD_INT 92
6166: PUSH
6167: LD_INT 89
6169: PUSH
6170: LD_INT 71
6172: PUSH
6173: LD_INT 9
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 72
6186: PUSH
6187: LD_VAR 0 2
6191: PUSH
6192: LD_INT 1
6194: MINUS
6195: GREATEREQUAL
6196: IFFALSE 6074
// end else
6198: GO 6324
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PPUSH
6210: LD_INT 24
6212: PUSH
6213: LD_INT 250
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PPUSH
6220: CALL_OW 72
6224: ST_TO_ADDR
// for i in tmp do
6225: LD_ADDR_VAR 0 1
6229: PUSH
6230: LD_VAR 0 2
6234: PUSH
6235: FOR_IN
6236: IFFALSE 6276
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6238: LD_VAR 0 1
6242: PPUSH
6243: LD_INT 125
6245: PPUSH
6246: LD_INT 129
6248: PPUSH
6249: CALL_OW 297
6253: PUSH
6254: LD_INT 9
6256: GREATER
6257: IFFALSE 6274
// ComMoveXY ( i , 125 , 129 ) ;
6259: LD_VAR 0 1
6263: PPUSH
6264: LD_INT 125
6266: PPUSH
6267: LD_INT 129
6269: PPUSH
6270: CALL_OW 111
6274: GO 6235
6276: POP
6277: POP
// wait ( 0 0$1 ) ;
6278: LD_INT 35
6280: PPUSH
6281: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6285: LD_VAR 0 2
6289: PPUSH
6290: LD_INT 92
6292: PUSH
6293: LD_INT 125
6295: PUSH
6296: LD_INT 129
6298: PUSH
6299: LD_INT 9
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PPUSH
6308: CALL_OW 72
6312: PUSH
6313: LD_VAR 0 2
6317: PUSH
6318: LD_INT 1
6320: MINUS
6321: GREATEREQUAL
6322: IFFALSE 6200
// end ; repeat wait ( 0 0$1 ) ;
6324: LD_INT 35
6326: PPUSH
6327: CALL_OW 67
// for i in tmp do
6331: LD_ADDR_VAR 0 1
6335: PUSH
6336: LD_VAR 0 2
6340: PUSH
6341: FOR_IN
6342: IFFALSE 6424
// begin if GetLives ( i ) > 251 then
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 256
6353: PUSH
6354: LD_INT 251
6356: GREATER
6357: IFFALSE 6395
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6359: LD_VAR 0 1
6363: PPUSH
6364: LD_INT 81
6366: PUSH
6367: LD_INT 8
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PPUSH
6374: CALL_OW 69
6378: PPUSH
6379: LD_VAR 0 1
6383: PPUSH
6384: CALL_OW 74
6388: PPUSH
6389: CALL_OW 115
6393: GO 6422
// if IsDead ( i ) then
6395: LD_VAR 0 1
6399: PPUSH
6400: CALL_OW 301
6404: IFFALSE 6422
// tmp := tmp diff i ;
6406: LD_ADDR_VAR 0 2
6410: PUSH
6411: LD_VAR 0 2
6415: PUSH
6416: LD_VAR 0 1
6420: DIFF
6421: ST_TO_ADDR
// end ;
6422: GO 6341
6424: POP
6425: POP
// until not tmp ;
6426: LD_VAR 0 2
6430: NOT
6431: IFFALSE 6324
// end ;
6433: PPOPN 3
6435: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6436: LD_EXP 22
6440: NOT
6441: PUSH
6442: LD_EXP 15
6446: PUSH
6447: LD_INT 6
6449: GREATEREQUAL
6450: AND
6451: PUSH
6452: LD_OWVAR 67
6456: PUSH
6457: LD_INT 1
6459: GREATER
6460: AND
6461: IFFALSE 6978
6463: GO 6465
6465: DISABLE
6466: LD_INT 0
6468: PPUSH
6469: PPUSH
6470: PPUSH
// begin enable ;
6471: ENABLE
// tmp := [ ] ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: EMPTY
6478: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6479: LD_ADDR_VAR 0 1
6483: PUSH
6484: DOUBLE
6485: LD_INT 1
6487: DEC
6488: ST_TO_ADDR
6489: LD_INT 4
6491: PUSH
6492: LD_INT 6
6494: PUSH
6495: LD_INT 7
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: PUSH
6503: LD_OWVAR 67
6507: ARRAY
6508: PUSH
6509: FOR_TO
6510: IFFALSE 6670
// begin uc_side := 8 ;
6512: LD_ADDR_OWVAR 20
6516: PUSH
6517: LD_INT 8
6519: ST_TO_ADDR
// uc_nation := 2 ;
6520: LD_ADDR_OWVAR 21
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6528: LD_INT 13
6530: PUSH
6531: LD_INT 14
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 1
6540: PPUSH
6541: LD_INT 2
6543: PPUSH
6544: CALL_OW 12
6548: ARRAY
6549: PPUSH
6550: LD_INT 1
6552: PPUSH
6553: LD_INT 5
6555: PPUSH
6556: LD_INT 27
6558: PUSH
6559: LD_INT 28
6561: PUSH
6562: LD_INT 26
6564: PUSH
6565: LD_INT 25
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 1
6576: PPUSH
6577: LD_INT 4
6579: PPUSH
6580: CALL_OW 12
6584: ARRAY
6585: PPUSH
6586: LD_INT 88
6588: PPUSH
6589: CALL 70336 0 5
// un := CreateVehicle ;
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: CALL_OW 45
6602: ST_TO_ADDR
// tmp := tmp ^ un ;
6603: LD_ADDR_VAR 0 3
6607: PUSH
6608: LD_VAR 0 3
6612: PUSH
6613: LD_VAR 0 2
6617: ADD
6618: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6619: LD_VAR 0 2
6623: PPUSH
6624: LD_INT 3
6626: PPUSH
6627: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6631: LD_VAR 0 2
6635: PPUSH
6636: LD_INT 30
6638: PPUSH
6639: LD_INT 0
6641: PPUSH
6642: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6646: LD_VAR 0 2
6650: PPUSH
6651: LD_INT 16
6653: PPUSH
6654: LD_INT 11
6656: PPUSH
6657: CALL_OW 111
// wait ( 0 0$2 ) ;
6661: LD_INT 70
6663: PPUSH
6664: CALL_OW 67
// end ;
6668: GO 6509
6670: POP
6671: POP
// for i = 1 to Difficulty do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_OWVAR 67
6686: PUSH
6687: FOR_TO
6688: IFFALSE 6813
// begin uc_side := 8 ;
6690: LD_ADDR_OWVAR 20
6694: PUSH
6695: LD_INT 8
6697: ST_TO_ADDR
// uc_nation := 2 ;
6698: LD_ADDR_OWVAR 21
6702: PUSH
6703: LD_INT 2
6705: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6706: LD_INT 0
6708: PPUSH
6709: LD_INT 8
6711: PPUSH
6712: LD_INT 8
6714: PUSH
6715: LD_INT 8
6717: PUSH
6718: LD_INT 9
6720: PUSH
6721: EMPTY
6722: LIST
6723: LIST
6724: LIST
6725: PUSH
6726: LD_OWVAR 67
6730: ARRAY
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 2
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// tmp := tmp ^ un ;
6746: LD_ADDR_VAR 0 3
6750: PUSH
6751: LD_VAR 0 3
6755: PUSH
6756: LD_VAR 0 2
6760: ADD
6761: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6762: LD_VAR 0 2
6766: PPUSH
6767: LD_INT 3
6769: PPUSH
6770: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_INT 30
6781: PPUSH
6782: LD_INT 0
6784: PPUSH
6785: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6789: LD_VAR 0 2
6793: PPUSH
6794: LD_INT 16
6796: PPUSH
6797: LD_INT 11
6799: PPUSH
6800: CALL_OW 111
// wait ( 0 0$2 ) ;
6804: LD_INT 70
6806: PPUSH
6807: CALL_OW 67
// end ;
6811: GO 6687
6813: POP
6814: POP
// repeat wait ( 0 0$1 ) ;
6815: LD_INT 35
6817: PPUSH
6818: CALL_OW 67
// for i in tmp do
6822: LD_ADDR_VAR 0 1
6826: PUSH
6827: LD_VAR 0 3
6831: PUSH
6832: FOR_IN
6833: IFFALSE 6969
// begin if GetLives ( i ) > 250 then
6835: LD_VAR 0 1
6839: PPUSH
6840: CALL_OW 256
6844: PUSH
6845: LD_INT 250
6847: GREATER
6848: IFFALSE 6940
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6850: LD_INT 81
6852: PUSH
6853: LD_INT 8
6855: PUSH
6856: EMPTY
6857: LIST
6858: LIST
6859: PUSH
6860: LD_INT 91
6862: PUSH
6863: LD_VAR 0 1
6867: PUSH
6868: LD_INT 10
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: PPUSH
6880: CALL_OW 69
6884: NOT
6885: IFFALSE 6904
// ComAgressiveMove ( i , 67 , 110 ) else
6887: LD_VAR 0 1
6891: PPUSH
6892: LD_INT 67
6894: PPUSH
6895: LD_INT 110
6897: PPUSH
6898: CALL_OW 114
6902: GO 6938
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6904: LD_VAR 0 1
6908: PPUSH
6909: LD_INT 81
6911: PUSH
6912: LD_INT 8
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PPUSH
6919: CALL_OW 69
6923: PPUSH
6924: LD_VAR 0 1
6928: PPUSH
6929: CALL_OW 74
6933: PPUSH
6934: CALL_OW 115
// end else
6938: GO 6967
// if IsDead ( i ) then
6940: LD_VAR 0 1
6944: PPUSH
6945: CALL_OW 301
6949: IFFALSE 6967
// tmp := tmp diff i ;
6951: LD_ADDR_VAR 0 3
6955: PUSH
6956: LD_VAR 0 3
6960: PUSH
6961: LD_VAR 0 1
6965: DIFF
6966: ST_TO_ADDR
// end ;
6967: GO 6832
6969: POP
6970: POP
// until not tmp ;
6971: LD_VAR 0 3
6975: NOT
6976: IFFALSE 6815
// end ; end_of_file
6978: PPOPN 3
6980: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6981: LD_INT 0
6983: PPUSH
6984: PPUSH
6985: PPUSH
6986: PPUSH
6987: PPUSH
6988: PPUSH
6989: PPUSH
6990: PPUSH
6991: PPUSH
// side := 3 ;
6992: LD_ADDR_VAR 0 6
6996: PUSH
6997: LD_INT 3
6999: ST_TO_ADDR
// uc_side := side ;
7000: LD_ADDR_OWVAR 20
7004: PUSH
7005: LD_VAR 0 6
7009: ST_TO_ADDR
// uc_nation := 3 ;
7010: LD_ADDR_OWVAR 21
7014: PUSH
7015: LD_INT 3
7017: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7018: LD_ADDR_VAR 0 2
7022: PUSH
7023: LD_INT 22
7025: PUSH
7026: LD_VAR 0 6
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: PUSH
7035: LD_INT 21
7037: PUSH
7038: LD_INT 3
7040: PUSH
7041: EMPTY
7042: LIST
7043: LIST
7044: PUSH
7045: EMPTY
7046: LIST
7047: LIST
7048: PPUSH
7049: CALL_OW 69
7053: PUSH
7054: FOR_IN
7055: IFFALSE 7071
// SetBLevel ( i , 10 ) ;
7057: LD_VAR 0 2
7061: PPUSH
7062: LD_INT 10
7064: PPUSH
7065: CALL_OW 241
7069: GO 7054
7071: POP
7072: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7073: LD_ADDR_VAR 0 9
7077: PUSH
7078: LD_INT 22
7080: PUSH
7081: LD_VAR 0 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 30
7092: PUSH
7093: LD_INT 34
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: ST_TO_ADDR
// if teleport then
7109: LD_VAR 0 9
7113: IFFALSE 7134
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7115: LD_VAR 0 9
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: LD_INT 123
7126: PPUSH
7127: LD_INT 122
7129: PPUSH
7130: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7134: LD_ADDR_EXP 64
7138: PUSH
7139: LD_STRING Platonov
7141: PPUSH
7142: CALL_OW 25
7146: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7147: LD_ADDR_EXP 65
7151: PUSH
7152: LD_STRING Kovalyuk
7154: PPUSH
7155: CALL_OW 25
7159: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7160: LD_ADDR_EXP 67
7164: PUSH
7165: LD_STRING Yakotich
7167: PPUSH
7168: LD_EXP 1
7172: NOT
7173: PPUSH
7174: LD_STRING 09_
7176: PPUSH
7177: CALL 65472 0 3
7181: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7182: LD_ADDR_EXP 66
7186: PUSH
7187: LD_STRING Bystrov
7189: PPUSH
7190: CALL_OW 25
7194: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7195: LD_ADDR_EXP 68
7199: PUSH
7200: LD_STRING Gleb
7202: PPUSH
7203: CALL_OW 25
7207: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7208: LD_STRING 03_Cornel
7210: PPUSH
7211: CALL_OW 28
7215: IFFALSE 7263
// begin Bierezov := NewCharacter ( Mikhail ) ;
7217: LD_ADDR_EXP 69
7221: PUSH
7222: LD_STRING Mikhail
7224: PPUSH
7225: CALL_OW 25
7229: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7230: LD_EXP 69
7234: PPUSH
7235: LD_INT 197
7237: PPUSH
7238: LD_INT 111
7240: PPUSH
7241: LD_INT 9
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7251: LD_EXP 69
7255: PPUSH
7256: LD_INT 3
7258: PPUSH
7259: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7263: LD_EXP 64
7267: PPUSH
7268: LD_INT 126
7270: PPUSH
7271: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7275: LD_EXP 65
7279: PPUSH
7280: LD_INT 134
7282: PPUSH
7283: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7287: LD_EXP 67
7291: PPUSH
7292: LD_INT 197
7294: PPUSH
7295: LD_INT 111
7297: PPUSH
7298: LD_INT 9
7300: PPUSH
7301: LD_INT 0
7303: PPUSH
7304: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7308: LD_EXP 66
7312: PPUSH
7313: LD_INT 197
7315: PPUSH
7316: LD_INT 111
7318: PPUSH
7319: LD_INT 9
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7329: LD_EXP 68
7333: PPUSH
7334: LD_INT 197
7336: PPUSH
7337: LD_INT 111
7339: PPUSH
7340: LD_INT 9
7342: PPUSH
7343: LD_INT 0
7345: PPUSH
7346: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_INT 126
7357: PPUSH
7358: LD_INT 4
7360: PPUSH
7361: LD_STRING zhukov
7363: PPUSH
7364: LD_INT 9
7366: PUSH
7367: LD_INT 10
7369: PUSH
7370: LD_INT 10
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_OWVAR 67
7382: ARRAY
7383: PPUSH
7384: LD_INT 90000
7386: PUSH
7387: LD_INT 1000
7389: PUSH
7390: LD_INT 300
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: LIST
7397: PPUSH
7398: LD_INT 18
7400: PUSH
7401: LD_INT 8
7403: PUSH
7404: LD_INT 13
7406: PUSH
7407: LD_INT 8
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: LIST
7415: PPUSH
7416: CALL 73783 0 6
7420: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7421: LD_ADDR_VAR 0 4
7425: PUSH
7426: LD_INT 267
7428: PPUSH
7429: CALL_OW 274
7433: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7434: LD_VAR 0 4
7438: PPUSH
7439: LD_INT 1
7441: PPUSH
7442: LD_INT 5000
7444: PPUSH
7445: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7449: LD_VAR 0 4
7453: PPUSH
7454: LD_INT 2
7456: PPUSH
7457: LD_INT 200
7459: PPUSH
7460: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 3
7471: PPUSH
7472: LD_INT 200
7474: PPUSH
7475: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7479: LD_ADDR_EXP 116
7483: PUSH
7484: LD_EXP 116
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 5
7496: PUSH
7497: LD_INT 22
7499: PUSH
7500: LD_VAR 0 6
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 3
7511: PUSH
7512: LD_INT 21
7514: PUSH
7515: LD_INT 2
7517: PUSH
7518: EMPTY
7519: LIST
7520: LIST
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PPUSH
7530: CALL_OW 69
7534: UNION
7535: PUSH
7536: LD_EXP 64
7540: DIFF
7541: PPUSH
7542: CALL_OW 1
7546: ST_TO_ADDR
// behemoths := [ ] ;
7547: LD_ADDR_EXP 72
7551: PUSH
7552: EMPTY
7553: ST_TO_ADDR
// behemothBuilders := [ ] ;
7554: LD_ADDR_EXP 73
7558: PUSH
7559: EMPTY
7560: ST_TO_ADDR
// if Kovalyuk then
7561: LD_EXP 65
7565: IFFALSE 7587
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7567: LD_ADDR_EXP 73
7571: PUSH
7572: LD_EXP 73
7576: PPUSH
7577: LD_EXP 65
7581: PPUSH
7582: CALL 102210 0 2
7586: ST_TO_ADDR
// j := 3 ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: LD_INT 3
7594: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7595: LD_ADDR_VAR 0 2
7599: PUSH
7600: LD_INT 22
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: EMPTY
7607: LIST
7608: LIST
7609: PUSH
7610: LD_INT 25
7612: PUSH
7613: LD_INT 3
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: PUSH
7629: LD_EXP 65
7633: DIFF
7634: PUSH
7635: FOR_IN
7636: IFFALSE 7686
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7638: LD_ADDR_EXP 73
7642: PUSH
7643: LD_EXP 73
7647: PPUSH
7648: LD_VAR 0 2
7652: PPUSH
7653: CALL 102210 0 2
7657: ST_TO_ADDR
// j := j - 1 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_VAR 0 3
7667: PUSH
7668: LD_INT 1
7670: MINUS
7671: ST_TO_ADDR
// if j = 0 then
7672: LD_VAR 0 3
7676: PUSH
7677: LD_INT 0
7679: EQUAL
7680: IFFALSE 7684
// break ;
7682: GO 7686
// end ;
7684: GO 7635
7686: POP
7687: POP
// end ;
7688: LD_VAR 0 1
7692: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7693: LD_INT 0
7695: PPUSH
7696: PPUSH
7697: PPUSH
7698: PPUSH
7699: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7700: LD_ADDR_VAR 0 4
7704: PUSH
7705: LD_INT 209
7707: PUSH
7708: LD_INT 149
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 219
7717: PUSH
7718: LD_INT 154
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 223
7727: PUSH
7728: LD_INT 149
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: LD_INT 232
7737: PUSH
7738: LD_INT 155
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: ST_TO_ADDR
// if not behemothBuilders then
7751: LD_EXP 73
7755: NOT
7756: IFFALSE 7760
// exit ;
7758: GO 7864
// j := 1 ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 1
7767: ST_TO_ADDR
// for i in behemothBuilders do
7768: LD_ADDR_VAR 0 2
7772: PUSH
7773: LD_EXP 73
7777: PUSH
7778: FOR_IN
7779: IFFALSE 7862
// begin if IsInUnit ( i ) then
7781: LD_VAR 0 2
7785: PPUSH
7786: CALL_OW 310
7790: IFFALSE 7801
// ComExitBuilding ( i ) ;
7792: LD_VAR 0 2
7796: PPUSH
7797: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7801: LD_VAR 0 2
7805: PPUSH
7806: LD_INT 37
7808: PPUSH
7809: LD_VAR 0 4
7813: PUSH
7814: LD_VAR 0 3
7818: ARRAY
7819: PUSH
7820: LD_INT 1
7822: ARRAY
7823: PPUSH
7824: LD_VAR 0 4
7828: PUSH
7829: LD_VAR 0 3
7833: ARRAY
7834: PUSH
7835: LD_INT 2
7837: ARRAY
7838: PPUSH
7839: LD_INT 0
7841: PPUSH
7842: CALL_OW 230
// j := j + 1 ;
7846: LD_ADDR_VAR 0 3
7850: PUSH
7851: LD_VAR 0 3
7855: PUSH
7856: LD_INT 1
7858: PLUS
7859: ST_TO_ADDR
// end ;
7860: GO 7778
7862: POP
7863: POP
// end ;
7864: LD_VAR 0 1
7868: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7869: LD_INT 24
7871: PPUSH
7872: LD_INT 30
7874: PUSH
7875: LD_INT 37
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PPUSH
7882: CALL_OW 70
7886: IFFALSE 7899
7888: GO 7890
7890: DISABLE
// behemothUnderConstruct := true ;
7891: LD_ADDR_EXP 26
7895: PUSH
7896: LD_INT 1
7898: ST_TO_ADDR
7899: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7900: LD_INT 3
7902: PPUSH
7903: CALL 102271 0 1
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_INT 3
7913: PUSH
7914: EMPTY
7915: LIST
7916: LIST
7917: PUSH
7918: LD_INT 30
7920: PUSH
7921: LD_INT 37
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: AND
7938: IFFALSE 8124
7940: GO 7942
7942: DISABLE
7943: LD_INT 0
7945: PPUSH
7946: PPUSH
// begin enable ;
7947: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7948: LD_ADDR_VAR 0 2
7952: PUSH
7953: LD_INT 3
7955: PPUSH
7956: CALL 102271 0 1
7960: ST_TO_ADDR
// for i in tmp do
7961: LD_ADDR_VAR 0 1
7965: PUSH
7966: LD_VAR 0 2
7970: PUSH
7971: FOR_IN
7972: IFFALSE 8122
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 9
7981: PPUSH
7982: CALL_OW 308
7986: PUSH
7987: LD_VAR 0 1
7991: PPUSH
7992: CALL_OW 110
7996: PUSH
7997: LD_INT 2
7999: EQUAL
8000: NOT
8001: AND
8002: IFFALSE 8016
// SetTag ( i , 2 ) ;
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 2
8011: PPUSH
8012: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8016: LD_INT 81
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: LD_INT 91
8028: PUSH
8029: LD_VAR 0 1
8033: PUSH
8034: LD_INT 12
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PPUSH
8046: CALL_OW 69
8050: NOT
8051: PUSH
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 110
8061: PUSH
8062: LD_INT 2
8064: EQUAL
8065: NOT
8066: AND
8067: IFFALSE 8086
// ComAgressiveMove ( i , 64 , 93 ) else
8069: LD_VAR 0 1
8073: PPUSH
8074: LD_INT 64
8076: PPUSH
8077: LD_INT 93
8079: PPUSH
8080: CALL_OW 114
8084: GO 8120
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8086: LD_VAR 0 1
8090: PPUSH
8091: LD_INT 81
8093: PUSH
8094: LD_INT 3
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 69
8105: PPUSH
8106: LD_VAR 0 1
8110: PPUSH
8111: CALL_OW 74
8115: PPUSH
8116: CALL_OW 115
// end ;
8120: GO 7971
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8127: LD_INT 0
8129: PPUSH
8130: PPUSH
8131: PPUSH
// result := [ ] ;
8132: LD_ADDR_VAR 0 2
8136: PUSH
8137: EMPTY
8138: ST_TO_ADDR
// uc_side := 6 ;
8139: LD_ADDR_OWVAR 20
8143: PUSH
8144: LD_INT 6
8146: ST_TO_ADDR
// uc_nation := 3 ;
8147: LD_ADDR_OWVAR 21
8151: PUSH
8152: LD_INT 3
8154: ST_TO_ADDR
// case strength of 1 :
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 1
8162: DOUBLE
8163: EQUAL
8164: IFTRUE 8168
8166: GO 8306
8168: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: DOUBLE
8175: LD_INT 1
8177: DEC
8178: ST_TO_ADDR
8179: LD_INT 4
8181: PUSH
8182: LD_INT 5
8184: PUSH
8185: LD_INT 6
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: LIST
8192: PUSH
8193: LD_OWVAR 67
8197: ARRAY
8198: PUSH
8199: FOR_TO
8200: IFFALSE 8302
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8202: LD_INT 22
8204: PUSH
8205: LD_INT 24
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: PUSH
8212: LD_VAR 0 3
8216: PUSH
8217: LD_INT 2
8219: MOD
8220: PUSH
8221: LD_INT 1
8223: PLUS
8224: ARRAY
8225: PPUSH
8226: LD_INT 1
8228: PUSH
8229: LD_INT 3
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PUSH
8236: LD_INT 1
8238: PPUSH
8239: LD_INT 2
8241: PPUSH
8242: CALL_OW 12
8246: ARRAY
8247: PPUSH
8248: LD_INT 3
8250: PPUSH
8251: LD_INT 43
8253: PUSH
8254: LD_INT 44
8256: PUSH
8257: LD_INT 45
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 1
8267: PPUSH
8268: LD_INT 3
8270: PPUSH
8271: CALL_OW 12
8275: ARRAY
8276: PPUSH
8277: LD_INT 80
8279: PPUSH
8280: CALL 70336 0 5
// result := result union CreateVehicle ;
8284: LD_ADDR_VAR 0 2
8288: PUSH
8289: LD_VAR 0 2
8293: PUSH
8294: CALL_OW 45
8298: UNION
8299: ST_TO_ADDR
// end ;
8300: GO 8199
8302: POP
8303: POP
// end ; 2 :
8304: GO 9257
8306: LD_INT 2
8308: DOUBLE
8309: EQUAL
8310: IFTRUE 8314
8312: GO 8470
8314: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: DOUBLE
8321: LD_INT 1
8323: DEC
8324: ST_TO_ADDR
8325: LD_INT 5
8327: PUSH
8328: LD_INT 6
8330: PUSH
8331: LD_INT 7
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: LIST
8338: PUSH
8339: LD_OWVAR 67
8343: ARRAY
8344: PUSH
8345: FOR_TO
8346: IFFALSE 8466
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8348: LD_INT 22
8350: PUSH
8351: LD_INT 24
8353: PUSH
8354: LD_INT 24
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: LIST
8361: PUSH
8362: LD_VAR 0 3
8366: PUSH
8367: LD_INT 3
8369: MOD
8370: PUSH
8371: LD_INT 1
8373: PLUS
8374: ARRAY
8375: PPUSH
8376: LD_INT 1
8378: PUSH
8379: LD_INT 3
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PUSH
8386: LD_INT 1
8388: PPUSH
8389: LD_INT 2
8391: PPUSH
8392: CALL_OW 12
8396: ARRAY
8397: PPUSH
8398: LD_INT 3
8400: PPUSH
8401: LD_INT 43
8403: PUSH
8404: LD_INT 44
8406: PUSH
8407: LD_INT 45
8409: PUSH
8410: LD_INT 44
8412: PUSH
8413: LD_INT 46
8415: PUSH
8416: LD_INT 46
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: LIST
8423: LIST
8424: LIST
8425: LIST
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: LD_INT 6
8434: MOD
8435: PUSH
8436: LD_INT 1
8438: PLUS
8439: ARRAY
8440: PPUSH
8441: LD_INT 80
8443: PPUSH
8444: CALL 70336 0 5
// result := result union CreateVehicle ;
8448: LD_ADDR_VAR 0 2
8452: PUSH
8453: LD_VAR 0 2
8457: PUSH
8458: CALL_OW 45
8462: UNION
8463: ST_TO_ADDR
// end ;
8464: GO 8345
8466: POP
8467: POP
// end ; 3 :
8468: GO 9257
8470: LD_INT 3
8472: DOUBLE
8473: EQUAL
8474: IFTRUE 8478
8476: GO 8634
8478: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8479: LD_ADDR_VAR 0 3
8483: PUSH
8484: DOUBLE
8485: LD_INT 1
8487: DEC
8488: ST_TO_ADDR
8489: LD_INT 5
8491: PUSH
8492: LD_INT 7
8494: PUSH
8495: LD_INT 8
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: LIST
8502: PUSH
8503: LD_OWVAR 67
8507: ARRAY
8508: PUSH
8509: FOR_TO
8510: IFFALSE 8630
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8512: LD_INT 22
8514: PUSH
8515: LD_INT 24
8517: PUSH
8518: LD_INT 24
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 3
8530: PUSH
8531: LD_INT 3
8533: MOD
8534: PUSH
8535: LD_INT 1
8537: PLUS
8538: ARRAY
8539: PPUSH
8540: LD_INT 1
8542: PUSH
8543: LD_INT 3
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: LD_INT 1
8552: PPUSH
8553: LD_INT 2
8555: PPUSH
8556: CALL_OW 12
8560: ARRAY
8561: PPUSH
8562: LD_INT 3
8564: PPUSH
8565: LD_INT 43
8567: PUSH
8568: LD_INT 47
8570: PUSH
8571: LD_INT 45
8573: PUSH
8574: LD_INT 45
8576: PUSH
8577: LD_INT 46
8579: PUSH
8580: LD_INT 46
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: PUSH
8591: LD_VAR 0 3
8595: PUSH
8596: LD_INT 6
8598: MOD
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 80
8607: PPUSH
8608: CALL 70336 0 5
// result := result union CreateVehicle ;
8612: LD_ADDR_VAR 0 2
8616: PUSH
8617: LD_VAR 0 2
8621: PUSH
8622: CALL_OW 45
8626: UNION
8627: ST_TO_ADDR
// end ;
8628: GO 8509
8630: POP
8631: POP
// end ; 4 :
8632: GO 9257
8634: LD_INT 4
8636: DOUBLE
8637: EQUAL
8638: IFTRUE 8642
8640: GO 9256
8642: POP
// begin uc_nation := 3 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 3
8650: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8651: LD_ADDR_VAR 0 3
8655: PUSH
8656: DOUBLE
8657: LD_INT 1
8659: DEC
8660: ST_TO_ADDR
8661: LD_INT 6
8663: PUSH
8664: LD_INT 8
8666: PUSH
8667: LD_INT 9
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: PUSH
8675: LD_OWVAR 67
8679: ARRAY
8680: PUSH
8681: FOR_TO
8682: IFFALSE 8802
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8684: LD_INT 22
8686: PUSH
8687: LD_INT 24
8689: PUSH
8690: LD_INT 24
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: LD_VAR 0 3
8702: PUSH
8703: LD_INT 3
8705: MOD
8706: PUSH
8707: LD_INT 1
8709: PLUS
8710: ARRAY
8711: PPUSH
8712: LD_INT 1
8714: PUSH
8715: LD_INT 3
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 45
8739: PUSH
8740: LD_INT 47
8742: PUSH
8743: LD_INT 47
8745: PUSH
8746: LD_INT 45
8748: PUSH
8749: LD_INT 46
8751: PUSH
8752: LD_INT 46
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: PUSH
8763: LD_VAR 0 3
8767: PUSH
8768: LD_INT 6
8770: MOD
8771: PUSH
8772: LD_INT 1
8774: PLUS
8775: ARRAY
8776: PPUSH
8777: LD_INT 80
8779: PPUSH
8780: CALL 70336 0 5
// result := result union CreateVehicle ;
8784: LD_ADDR_VAR 0 2
8788: PUSH
8789: LD_VAR 0 2
8793: PUSH
8794: CALL_OW 45
8798: UNION
8799: ST_TO_ADDR
// end ;
8800: GO 8681
8802: POP
8803: POP
// if not KappaStatus then
8804: LD_EXP 2
8808: NOT
8809: IFFALSE 9044
// begin uc_nation := 1 ;
8811: LD_ADDR_OWVAR 21
8815: PUSH
8816: LD_INT 1
8818: ST_TO_ADDR
// for i = 1 to 3 do
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: DOUBLE
8825: LD_INT 1
8827: DEC
8828: ST_TO_ADDR
8829: LD_INT 3
8831: PUSH
8832: FOR_TO
8833: IFFALSE 8969
// begin j := rand ( 0 , 1 ) ;
8835: LD_ADDR_VAR 0 4
8839: PUSH
8840: LD_INT 0
8842: PPUSH
8843: LD_INT 1
8845: PPUSH
8846: CALL_OW 12
8850: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8851: LD_INT 3
8853: PUSH
8854: LD_INT 5
8856: PUSH
8857: LD_INT 5
8859: PUSH
8860: LD_INT 4
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: PUSH
8869: LD_VAR 0 4
8873: PUSH
8874: LD_INT 1
8876: PPUSH
8877: LD_INT 3
8879: PPUSH
8880: CALL_OW 12
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 1
8889: PUSH
8890: LD_INT 3
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 1
8899: PPUSH
8900: LD_INT 2
8902: PPUSH
8903: CALL_OW 12
8907: ARRAY
8908: PPUSH
8909: LD_INT 3
8911: PPUSH
8912: LD_INT 9
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: LD_INT 6
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: PUSH
8926: LD_VAR 0 4
8930: PUSH
8931: LD_INT 1
8933: PPUSH
8934: LD_INT 2
8936: PPUSH
8937: CALL_OW 12
8941: PLUS
8942: ARRAY
8943: PPUSH
8944: LD_INT 85
8946: PPUSH
8947: CALL 70336 0 5
// result := result union CreateVehicle ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 2
8960: PUSH
8961: CALL_OW 45
8965: UNION
8966: ST_TO_ADDR
// end ;
8967: GO 8832
8969: POP
8970: POP
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8985: LD_INT 5
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 6
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 70336 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 71
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 71
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 71
9040: UNION
9041: ST_TO_ADDR
// end ; end else
9042: GO 9254
// if vsevolodFirstAttack then
9044: LD_EXP 24
9048: IFFALSE 9254
// begin vsevolodFirstAttack := false ;
9050: LD_ADDR_EXP 24
9054: PUSH
9055: LD_INT 0
9057: ST_TO_ADDR
// uc_nation := 3 ;
9058: LD_ADDR_OWVAR 21
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9066: LD_ADDR_VAR 0 3
9070: PUSH
9071: DOUBLE
9072: LD_INT 1
9074: DEC
9075: ST_TO_ADDR
9076: LD_INT 2
9078: PUSH
9079: LD_OWVAR 67
9083: PLUS
9084: PUSH
9085: FOR_TO
9086: IFFALSE 9194
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 24
9093: PUSH
9094: LD_INT 24
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: PUSH
9102: LD_VAR 0 3
9106: PUSH
9107: LD_INT 3
9109: MOD
9110: PUSH
9111: LD_INT 1
9113: PLUS
9114: ARRAY
9115: PPUSH
9116: LD_INT 1
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 1
9128: PPUSH
9129: LD_INT 2
9131: PPUSH
9132: CALL_OW 12
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PPUSH
9141: LD_INT 45
9143: PUSH
9144: LD_INT 47
9146: PUSH
9147: LD_INT 47
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_VAR 0 3
9159: PUSH
9160: LD_INT 3
9162: MOD
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: PPUSH
9169: LD_INT 80
9171: PPUSH
9172: CALL 70336 0 5
// result := result union CreateVehicle ;
9176: LD_ADDR_VAR 0 2
9180: PUSH
9181: LD_VAR 0 2
9185: PUSH
9186: CALL_OW 45
9190: UNION
9191: ST_TO_ADDR
// end ;
9192: GO 9085
9194: POP
9195: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9196: LD_INT 24
9198: PPUSH
9199: LD_INT 3
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 47
9207: PPUSH
9208: LD_INT 100
9210: PPUSH
9211: CALL 70336 0 5
// sewiVeh := CreateVehicle ;
9215: LD_ADDR_EXP 71
9219: PUSH
9220: CALL_OW 45
9224: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9225: LD_EXP 71
9229: PPUSH
9230: LD_INT 6
9232: NEG
9233: PPUSH
9234: CALL_OW 242
// result := result union sewiVeh ;
9238: LD_ADDR_VAR 0 2
9242: PUSH
9243: LD_VAR 0 2
9247: PUSH
9248: LD_EXP 71
9252: UNION
9253: ST_TO_ADDR
// end ; end ; end ;
9254: GO 9257
9256: POP
// end ;
9257: LD_VAR 0 2
9261: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9262: LD_EXP 16
9266: IFFALSE 10107
9268: GO 9270
9270: DISABLE
9271: LD_INT 0
9273: PPUSH
9274: PPUSH
9275: PPUSH
9276: PPUSH
9277: PPUSH
9278: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9279: LD_ADDR_VAR 0 4
9283: PUSH
9284: LD_INT 11
9286: PUSH
9287: LD_INT 12
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9294: LD_ADDR_VAR 0 3
9298: PUSH
9299: LD_INT 11550
9301: PUSH
9302: LD_INT 10150
9304: PUSH
9305: LD_INT 9800
9307: PUSH
9308: EMPTY
9309: LIST
9310: LIST
9311: LIST
9312: PUSH
9313: LD_OWVAR 67
9317: ARRAY
9318: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9319: LD_ADDR_VAR 0 6
9323: PUSH
9324: LD_INT 70
9326: PUSH
9327: LD_INT 118
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: PUSH
9334: LD_INT 78
9336: PUSH
9337: LD_INT 31
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: ST_TO_ADDR
// repeat if missionStage = 2 then
9348: LD_EXP 15
9352: PUSH
9353: LD_INT 2
9355: EQUAL
9356: IFFALSE 9367
// wait ( 1 1$30 ) else
9358: LD_INT 3150
9360: PPUSH
9361: CALL_OW 67
9365: GO 9376
// wait ( time ) ;
9367: LD_VAR 0 3
9371: PPUSH
9372: CALL_OW 67
// if missionStage = 6 then
9376: LD_EXP 15
9380: PUSH
9381: LD_INT 6
9383: EQUAL
9384: IFFALSE 9412
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9386: LD_INT 51
9388: PPUSH
9389: LD_INT 6
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9399: LD_INT 57
9401: PPUSH
9402: LD_INT 6
9404: PPUSH
9405: LD_INT 2
9407: PPUSH
9408: CALL_OW 322
// end ; if missionStage = 8 then
9412: LD_EXP 15
9416: PUSH
9417: LD_INT 8
9419: EQUAL
9420: IFFALSE 9448
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9422: LD_INT 52
9424: PPUSH
9425: LD_INT 6
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9435: LD_INT 58
9437: PPUSH
9438: LD_INT 6
9440: PPUSH
9441: LD_INT 2
9443: PPUSH
9444: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9448: LD_EXP 15
9452: PUSH
9453: LD_INT 10
9455: EQUAL
9456: PUSH
9457: LD_OWVAR 67
9461: PUSH
9462: LD_INT 1
9464: GREATER
9465: AND
9466: IFFALSE 9494
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9468: LD_INT 53
9470: PPUSH
9471: LD_INT 6
9473: PPUSH
9474: LD_INT 2
9476: PPUSH
9477: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9481: LD_INT 59
9483: PPUSH
9484: LD_INT 6
9486: PPUSH
9487: LD_INT 2
9489: PPUSH
9490: CALL_OW 322
// end ; if activeAttacks then
9494: LD_EXP 16
9498: IFFALSE 10101
// begin if missionStage = 2 then
9500: LD_EXP 15
9504: PUSH
9505: LD_INT 2
9507: EQUAL
9508: IFFALSE 9518
// strength := 1 ;
9510: LD_ADDR_VAR 0 5
9514: PUSH
9515: LD_INT 1
9517: ST_TO_ADDR
// if missionStage > 2 then
9518: LD_EXP 15
9522: PUSH
9523: LD_INT 2
9525: GREATER
9526: IFFALSE 9536
// strength := 2 ;
9528: LD_ADDR_VAR 0 5
9532: PUSH
9533: LD_INT 2
9535: ST_TO_ADDR
// if missionStage > 6 then
9536: LD_EXP 15
9540: PUSH
9541: LD_INT 6
9543: GREATER
9544: IFFALSE 9554
// strength := 3 ;
9546: LD_ADDR_VAR 0 5
9550: PUSH
9551: LD_INT 3
9553: ST_TO_ADDR
// if missionStage > 10 then
9554: LD_EXP 15
9558: PUSH
9559: LD_INT 10
9561: GREATER
9562: IFFALSE 9572
// strength := 4 ;
9564: LD_ADDR_VAR 0 5
9568: PUSH
9569: LD_INT 4
9571: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9572: LD_ADDR_VAR 0 2
9576: PUSH
9577: LD_VAR 0 5
9581: PPUSH
9582: CALL 8127 0 1
9586: ST_TO_ADDR
// for i in tmp do
9587: LD_ADDR_VAR 0 1
9591: PUSH
9592: LD_VAR 0 2
9596: PUSH
9597: FOR_IN
9598: IFFALSE 9781
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9600: LD_VAR 0 1
9604: PPUSH
9605: LD_VAR 0 4
9609: PUSH
9610: LD_INT 1
9612: PPUSH
9613: LD_INT 2
9615: PPUSH
9616: CALL_OW 12
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 49
// if i = sewiVeh then
9629: LD_VAR 0 1
9633: PUSH
9634: LD_EXP 71
9638: EQUAL
9639: IFFALSE 9676
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9641: LD_ADDR_EXP 70
9645: PUSH
9646: LD_STRING Vsevolod
9648: PPUSH
9649: LD_INT 0
9651: PPUSH
9652: LD_STRING 
9654: PPUSH
9655: CALL 65472 0 3
9659: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9660: LD_EXP 70
9664: PPUSH
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 52
// end else
9674: GO 9757
// if GetControl ( i ) = control_manual then
9676: LD_VAR 0 1
9680: PPUSH
9681: CALL_OW 263
9685: PUSH
9686: LD_INT 1
9688: EQUAL
9689: IFFALSE 9757
// begin uc_side := 6 ;
9691: LD_ADDR_OWVAR 20
9695: PUSH
9696: LD_INT 6
9698: ST_TO_ADDR
// uc_nation := 3 ;
9699: LD_ADDR_OWVAR 21
9703: PUSH
9704: LD_INT 3
9706: ST_TO_ADDR
// hc_gallery :=  ;
9707: LD_ADDR_OWVAR 33
9711: PUSH
9712: LD_STRING 
9714: ST_TO_ADDR
// hc_name :=  ;
9715: LD_ADDR_OWVAR 26
9719: PUSH
9720: LD_STRING 
9722: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9723: LD_INT 0
9725: PPUSH
9726: LD_INT 3
9728: PPUSH
9729: LD_INT 10
9731: PPUSH
9732: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9736: CALL_OW 44
9740: PPUSH
9741: LD_VAR 0 1
9745: PPUSH
9746: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9750: LD_INT 10
9752: PPUSH
9753: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9757: LD_VAR 0 1
9761: PPUSH
9762: LD_INT 111
9764: PPUSH
9765: LD_INT 197
9767: PPUSH
9768: CALL_OW 111
// wait ( 0 0$2 ) ;
9772: LD_INT 70
9774: PPUSH
9775: CALL_OW 67
// end ;
9779: GO 9597
9781: POP
9782: POP
// repeat wait ( 0 0$1 ) ;
9783: LD_INT 35
9785: PPUSH
9786: CALL_OW 67
// for i in tmp do
9790: LD_ADDR_VAR 0 1
9794: PUSH
9795: LD_VAR 0 2
9799: PUSH
9800: FOR_IN
9801: IFFALSE 10082
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9803: LD_INT 81
9805: PUSH
9806: LD_INT 6
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 91
9815: PUSH
9816: LD_VAR 0 1
9820: PUSH
9821: LD_INT 12
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: LIST
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 69
9837: IFFALSE 9895
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 81
9846: PUSH
9847: LD_INT 6
9849: PUSH
9850: EMPTY
9851: LIST
9852: LIST
9853: PUSH
9854: LD_INT 91
9856: PUSH
9857: LD_VAR 0 1
9861: PUSH
9862: LD_INT 12
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: LIST
9869: PUSH
9870: EMPTY
9871: LIST
9872: LIST
9873: PPUSH
9874: CALL_OW 69
9878: PPUSH
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 74
9888: PPUSH
9889: CALL_OW 115
9893: GO 10080
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9895: LD_INT 9
9897: PPUSH
9898: LD_INT 81
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: EMPTY
9905: LIST
9906: LIST
9907: PPUSH
9908: CALL_OW 70
9912: IFFALSE 10046
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_VAR 0 6
9923: PUSH
9924: LD_INT 1
9926: ARRAY
9927: PUSH
9928: LD_INT 1
9930: ARRAY
9931: PPUSH
9932: LD_VAR 0 6
9936: PUSH
9937: LD_INT 1
9939: ARRAY
9940: PUSH
9941: LD_INT 2
9943: ARRAY
9944: PPUSH
9945: CALL_OW 297
9949: PUSH
9950: LD_INT 10
9952: GREATER
9953: PUSH
9954: LD_VAR 0 1
9958: PPUSH
9959: LD_INT 9
9961: PPUSH
9962: CALL_OW 308
9966: NOT
9967: AND
9968: IFFALSE 10007
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9970: LD_VAR 0 1
9974: PPUSH
9975: LD_VAR 0 6
9979: PUSH
9980: LD_INT 1
9982: ARRAY
9983: PUSH
9984: LD_INT 1
9986: ARRAY
9987: PPUSH
9988: LD_VAR 0 6
9992: PUSH
9993: LD_INT 1
9995: ARRAY
9996: PUSH
9997: LD_INT 2
9999: ARRAY
10000: PPUSH
10001: CALL_OW 114
10005: GO 10044
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10007: LD_VAR 0 1
10011: PPUSH
10012: LD_INT 9
10014: PPUSH
10015: LD_INT 81
10017: PUSH
10018: LD_INT 6
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 70
10029: PPUSH
10030: LD_VAR 0 1
10034: PPUSH
10035: CALL_OW 74
10039: PPUSH
10040: CALL_OW 115
// end else
10044: GO 10080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10046: LD_VAR 0 1
10050: PPUSH
10051: LD_INT 81
10053: PUSH
10054: LD_INT 6
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 69
10065: PPUSH
10066: LD_VAR 0 1
10070: PPUSH
10071: CALL_OW 74
10075: PPUSH
10076: CALL_OW 115
// end ;
10080: GO 9800
10082: POP
10083: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10084: LD_INT 22
10086: PUSH
10087: LD_INT 6
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 69
10098: NOT
10099: IFFALSE 9783
// end ; until russianDestroyed ;
10101: LD_EXP 21
10105: IFFALSE 9348
// end ;
10107: PPOPN 6
10109: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10110: LD_EXP 21
10114: NOT
10115: PUSH
10116: LD_EXP 15
10120: PUSH
10121: LD_INT 6
10123: GREATEREQUAL
10124: AND
10125: PUSH
10126: LD_INT 2
10128: PPUSH
10129: LD_INT 1
10131: PPUSH
10132: CALL 60493 0 2
10136: NOT
10137: AND
10138: IFFALSE 11094
10140: GO 10142
10142: DISABLE
10143: LD_INT 0
10145: PPUSH
10146: PPUSH
10147: PPUSH
10148: PPUSH
// begin enable ;
10149: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10150: LD_INT 22
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 30
10162: PUSH
10163: LD_INT 3
10165: PUSH
10166: EMPTY
10167: LIST
10168: LIST
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PPUSH
10174: CALL_OW 69
10178: NOT
10179: IFFALSE 10183
// exit ;
10181: GO 11094
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10183: LD_ADDR_VAR 0 4
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: PUSH
10198: LD_INT 30
10200: PUSH
10201: LD_INT 34
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PPUSH
10212: CALL_OW 69
10216: ST_TO_ADDR
// if Prob ( 40 ) then
10217: LD_INT 40
10219: PPUSH
10220: CALL_OW 13
10224: IFFALSE 10351
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10226: LD_INT 2
10228: PPUSH
10229: LD_INT 22
10231: PUSH
10232: LD_INT 3
10234: PUSH
10235: LD_INT 3
10237: PUSH
10238: LD_INT 49
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: LIST
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 3
10252: PUSH
10253: LD_INT 3
10255: PUSH
10256: LD_INT 49
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: LIST
10263: LIST
10264: PUSH
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: LD_INT 3
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: LD_INT 24
10285: PUSH
10286: LD_INT 3
10288: PUSH
10289: LD_INT 3
10291: PUSH
10292: LD_INT 46
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: LIST
10300: PUSH
10301: LD_INT 24
10303: PUSH
10304: LD_INT 3
10306: PUSH
10307: LD_INT 3
10309: PUSH
10310: LD_INT 46
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: PUSH
10319: LD_INT 24
10321: PUSH
10322: LD_INT 3
10324: PUSH
10325: LD_INT 3
10327: PUSH
10328: LD_INT 46
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL 59075 0 2
// end else
10349: GO 10474
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10351: LD_INT 2
10353: PPUSH
10354: LD_INT 24
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 3
10362: PUSH
10363: LD_INT 47
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: PUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 46
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PPUSH
10470: CALL 59075 0 2
// end ; if Difficulty > 1 then
10474: LD_OWVAR 67
10478: PUSH
10479: LD_INT 1
10481: GREATER
10482: IFFALSE 10512
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10484: LD_INT 2
10486: PPUSH
10487: LD_INT 24
10489: PUSH
10490: LD_INT 3
10492: PUSH
10493: LD_INT 3
10495: PUSH
10496: LD_INT 47
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: PUSH
10505: EMPTY
10506: LIST
10507: PPUSH
10508: CALL 59075 0 2
// repeat wait ( 0 0$1 ) ;
10512: LD_INT 35
10514: PPUSH
10515: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10519: LD_INT 2
10521: PPUSH
10522: LD_INT 1
10524: PPUSH
10525: CALL 60493 0 2
10529: PUSH
10530: LD_INT 6
10532: PUSH
10533: LD_INT 7
10535: PUSH
10536: LD_INT 7
10538: PUSH
10539: EMPTY
10540: LIST
10541: LIST
10542: LIST
10543: PUSH
10544: LD_OWVAR 67
10548: ARRAY
10549: GREATEREQUAL
10550: IFFALSE 10512
// wait ( 0 0$30 ) ;
10552: LD_INT 1050
10554: PPUSH
10555: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10559: LD_ADDR_VAR 0 2
10563: PUSH
10564: LD_INT 2
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 60493 0 2
10574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10575: LD_ADDR_EXP 135
10579: PUSH
10580: LD_EXP 135
10584: PPUSH
10585: LD_INT 2
10587: PPUSH
10588: LD_EXP 135
10592: PUSH
10593: LD_INT 2
10595: ARRAY
10596: PUSH
10597: LD_VAR 0 2
10601: DIFF
10602: PPUSH
10603: CALL_OW 1
10607: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10608: LD_ADDR_VAR 0 3
10612: PUSH
10613: LD_INT 0
10615: PPUSH
10616: LD_INT 1
10618: PPUSH
10619: CALL_OW 12
10623: ST_TO_ADDR
// if target then
10624: LD_VAR 0 3
10628: IFFALSE 10756
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10630: LD_ADDR_VAR 0 2
10634: PUSH
10635: LD_VAR 0 2
10639: PPUSH
10640: LD_INT 24
10642: PUSH
10643: LD_INT 250
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 72
10654: ST_TO_ADDR
// for i in tmp do
10655: LD_ADDR_VAR 0 1
10659: PUSH
10660: LD_VAR 0 2
10664: PUSH
10665: FOR_IN
10666: IFFALSE 10706
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10668: LD_VAR 0 1
10672: PPUSH
10673: LD_INT 139
10675: PPUSH
10676: LD_INT 89
10678: PPUSH
10679: CALL_OW 297
10683: PUSH
10684: LD_INT 9
10686: GREATER
10687: IFFALSE 10704
// ComMoveXY ( i , 139 , 89 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 139
10696: PPUSH
10697: LD_INT 89
10699: PPUSH
10700: CALL_OW 111
10704: GO 10665
10706: POP
10707: POP
// wait ( 0 0$1 ) ;
10708: LD_INT 35
10710: PPUSH
10711: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10715: LD_VAR 0 2
10719: PPUSH
10720: LD_INT 92
10722: PUSH
10723: LD_INT 139
10725: PUSH
10726: LD_INT 89
10728: PUSH
10729: LD_INT 9
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: LIST
10736: LIST
10737: PPUSH
10738: CALL_OW 72
10742: PUSH
10743: LD_VAR 0 2
10747: PUSH
10748: LD_INT 1
10750: MINUS
10751: GREATEREQUAL
10752: IFFALSE 10630
// end else
10754: GO 10898
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10756: LD_VAR 0 2
10760: PPUSH
10761: LD_VAR 0 4
10765: PUSH
10766: LD_INT 1
10768: ARRAY
10769: PPUSH
10770: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: LD_VAR 0 2
10783: PPUSH
10784: LD_INT 24
10786: PUSH
10787: LD_INT 250
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 72
10798: ST_TO_ADDR
// for i in tmp do
10799: LD_ADDR_VAR 0 1
10803: PUSH
10804: LD_VAR 0 2
10808: PUSH
10809: FOR_IN
10810: IFFALSE 10850
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_INT 124
10819: PPUSH
10820: LD_INT 139
10822: PPUSH
10823: CALL_OW 297
10827: PUSH
10828: LD_INT 9
10830: GREATER
10831: IFFALSE 10848
// ComMoveXY ( i , 124 , 139 ) ;
10833: LD_VAR 0 1
10837: PPUSH
10838: LD_INT 124
10840: PPUSH
10841: LD_INT 139
10843: PPUSH
10844: CALL_OW 111
10848: GO 10809
10850: POP
10851: POP
// wait ( 0 0$1 ) ;
10852: LD_INT 35
10854: PPUSH
10855: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10859: LD_VAR 0 2
10863: PPUSH
10864: LD_INT 92
10866: PUSH
10867: LD_INT 124
10869: PUSH
10870: LD_INT 139
10872: PUSH
10873: LD_INT 9
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_VAR 0 2
10891: PUSH
10892: LD_INT 1
10894: MINUS
10895: GREATEREQUAL
10896: IFFALSE 10774
// end ; repeat wait ( 0 0$1 ) ;
10898: LD_INT 35
10900: PPUSH
10901: CALL_OW 67
// for i in tmp do
10905: LD_ADDR_VAR 0 1
10909: PUSH
10910: LD_VAR 0 2
10914: PUSH
10915: FOR_IN
10916: IFFALSE 11085
// begin if GetLives ( i ) > 251 then
10918: LD_VAR 0 1
10922: PPUSH
10923: CALL_OW 256
10927: PUSH
10928: LD_INT 251
10930: GREATER
10931: IFFALSE 11056
// begin if GetWeapon ( i ) = ru_time_lapser then
10933: LD_VAR 0 1
10937: PPUSH
10938: CALL_OW 264
10942: PUSH
10943: LD_INT 49
10945: EQUAL
10946: IFFALSE 11002
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10948: LD_VAR 0 1
10952: PPUSH
10953: LD_INT 2
10955: PUSH
10956: LD_INT 22
10958: PUSH
10959: LD_INT 1
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 22
10968: PUSH
10969: LD_INT 8
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PPUSH
10981: CALL_OW 69
10985: PPUSH
10986: LD_VAR 0 1
10990: PPUSH
10991: CALL_OW 74
10995: PPUSH
10996: CALL_OW 112
11000: GO 11054
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11002: LD_VAR 0 1
11006: PPUSH
11007: LD_INT 2
11009: PUSH
11010: LD_INT 22
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 22
11022: PUSH
11023: LD_INT 8
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: PPUSH
11035: CALL_OW 69
11039: PPUSH
11040: LD_VAR 0 1
11044: PPUSH
11045: CALL_OW 74
11049: PPUSH
11050: CALL_OW 115
// end else
11054: GO 11083
// if IsDead ( i ) then
11056: LD_VAR 0 1
11060: PPUSH
11061: CALL_OW 301
11065: IFFALSE 11083
// tmp := tmp diff i ;
11067: LD_ADDR_VAR 0 2
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_VAR 0 1
11081: DIFF
11082: ST_TO_ADDR
// end ;
11083: GO 10915
11085: POP
11086: POP
// until not tmp ;
11087: LD_VAR 0 2
11091: NOT
11092: IFFALSE 10898
// end ; end_of_file
11094: PPOPN 4
11096: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11097: LD_INT 0
11099: PPUSH
11100: PPUSH
11101: PPUSH
11102: PPUSH
11103: PPUSH
11104: PPUSH
// side := 7 ;
11105: LD_ADDR_VAR 0 5
11109: PUSH
11110: LD_INT 7
11112: ST_TO_ADDR
// uc_side := side ;
11113: LD_ADDR_OWVAR 20
11117: PUSH
11118: LD_VAR 0 5
11122: ST_TO_ADDR
// uc_nation := 1 ;
11123: LD_ADDR_OWVAR 21
11127: PUSH
11128: LD_INT 1
11130: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11131: LD_ADDR_VAR 0 2
11135: PUSH
11136: LD_INT 22
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PUSH
11148: LD_INT 21
11150: PUSH
11151: LD_INT 3
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PUSH
11158: EMPTY
11159: LIST
11160: LIST
11161: PPUSH
11162: CALL_OW 69
11166: PUSH
11167: FOR_IN
11168: IFFALSE 11184
// SetBLevel ( i , 10 ) ;
11170: LD_VAR 0 2
11174: PPUSH
11175: LD_INT 10
11177: PPUSH
11178: CALL_OW 241
11182: GO 11167
11184: POP
11185: POP
// base := GetBase ( al_depot ) ;
11186: LD_ADDR_VAR 0 4
11190: PUSH
11191: LD_INT 2
11193: PPUSH
11194: CALL_OW 274
11198: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11199: LD_ADDR_VAR 0 6
11203: PUSH
11204: LD_INT 22
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: PUSH
11216: LD_INT 30
11218: PUSH
11219: LD_INT 34
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 69
11234: ST_TO_ADDR
// if teleport then
11235: LD_VAR 0 6
11239: IFFALSE 11260
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11241: LD_VAR 0 6
11245: PUSH
11246: LD_INT 1
11248: ARRAY
11249: PPUSH
11250: LD_INT 262
11252: PPUSH
11253: LD_INT 119
11255: PPUSH
11256: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11260: LD_VAR 0 4
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: LD_INT 19500
11270: PPUSH
11271: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11275: LD_VAR 0 4
11279: PPUSH
11280: LD_INT 2
11282: PPUSH
11283: LD_INT 200
11285: PPUSH
11286: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11290: LD_VAR 0 4
11294: PPUSH
11295: LD_INT 3
11297: PPUSH
11298: LD_INT 650
11300: PPUSH
11301: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11305: LD_ADDR_EXP 74
11309: PUSH
11310: LD_STRING Roth
11312: PPUSH
11313: CALL_OW 25
11317: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11318: LD_ADDR_EXP 75
11322: PUSH
11323: LD_STRING Simms
11325: PPUSH
11326: LD_EXP 1
11330: NOT
11331: PPUSH
11332: LD_STRING 10c_
11334: PPUSH
11335: CALL 65472 0 3
11339: ST_TO_ADDR
// if not Simms then
11340: LD_EXP 75
11344: NOT
11345: IFFALSE 11375
// begin uc_nation := 1 ;
11347: LD_ADDR_OWVAR 21
11351: PUSH
11352: LD_INT 1
11354: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11355: LD_INT 2
11357: PPUSH
11358: LD_INT 10
11360: PPUSH
11361: CALL_OW 384
// Simms := CreateHuman ;
11365: LD_ADDR_EXP 75
11369: PUSH
11370: CALL_OW 44
11374: ST_TO_ADDR
// end ; uc_nation := 3 ;
11375: LD_ADDR_OWVAR 21
11379: PUSH
11380: LD_INT 3
11382: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11383: LD_ADDR_EXP 76
11387: PUSH
11388: LD_STRING Kirilenkova
11390: PPUSH
11391: CALL_OW 25
11395: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11396: LD_ADDR_EXP 90
11400: PUSH
11401: LD_STRING Oblukov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11409: LD_ADDR_EXP 77
11413: PUSH
11414: LD_STRING Dolgov
11416: PPUSH
11417: CALL_OW 25
11421: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11422: LD_ADDR_EXP 78
11426: PUSH
11427: LD_STRING Petrosyan
11429: PPUSH
11430: CALL_OW 25
11434: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11435: LD_ADDR_EXP 89
11439: PUSH
11440: LD_STRING Scholtze
11442: PPUSH
11443: CALL_OW 25
11447: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11448: LD_ADDR_EXP 88
11452: PUSH
11453: LD_STRING Kapitsova
11455: PPUSH
11456: CALL_OW 25
11460: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11461: LD_ADDR_EXP 79
11465: PUSH
11466: LD_STRING Petrovova
11468: PPUSH
11469: CALL_OW 25
11473: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11474: LD_ADDR_EXP 80
11478: PUSH
11479: LD_STRING Kuzmov
11481: PPUSH
11482: CALL_OW 25
11486: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11487: LD_ADDR_EXP 87
11491: PUSH
11492: LD_STRING Karamazov
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11500: LD_STRING 13_Lipshchin_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Lipshchin := NewCharacter ( Lipshchin ) ;
11512: LD_ADDR_EXP 81
11516: PUSH
11517: LD_STRING Lipshchin
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11525: LD_STRING 13_Titov_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Titov := NewCharacter ( Titov ) ;
11537: LD_ADDR_EXP 83
11541: PUSH
11542: LD_STRING Titov
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11550: LD_STRING 13_Gnyevko_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Gnyevko := NewCharacter ( Gnyevko ) ;
11562: LD_ADDR_EXP 82
11566: PUSH
11567: LD_STRING Gnyevko
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11575: LD_STRING 13_Xavier_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Xavier := NewCharacter ( Xavier2 ) ;
11587: LD_ADDR_EXP 84
11591: PUSH
11592: LD_STRING Xavier2
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11600: LD_STRING 13_Belkov_1
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 30
11610: IFFALSE 11625
// Belkov := NewCharacter ( Belkov ) ;
11612: LD_ADDR_EXP 85
11616: PUSH
11617: LD_STRING Belkov
11619: PPUSH
11620: CALL_OW 25
11624: ST_TO_ADDR
// if not BurlakStatus then
11625: LD_EXP 9
11629: NOT
11630: IFFALSE 11645
// Burlak = NewCharacter ( Burlak ) ;
11632: LD_ADDR_EXP 86
11636: PUSH
11637: LD_STRING Burlak
11639: PPUSH
11640: CALL_OW 25
11644: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11645: LD_ADDR_VAR 0 3
11649: PUSH
11650: LD_EXP 74
11654: PUSH
11655: LD_EXP 76
11659: PUSH
11660: LD_EXP 90
11664: PUSH
11665: LD_EXP 77
11669: PUSH
11670: LD_EXP 78
11674: PUSH
11675: LD_EXP 89
11679: PUSH
11680: LD_EXP 88
11684: PUSH
11685: LD_EXP 79
11689: PUSH
11690: LD_EXP 80
11694: PUSH
11695: LD_EXP 87
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: ST_TO_ADDR
// if Simms then
11712: LD_EXP 75
11716: IFFALSE 11734
// tmp := tmp ^ Simms ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_EXP 75
11732: ADD
11733: ST_TO_ADDR
// if Titov then
11734: LD_EXP 83
11738: IFFALSE 11756
// tmp := tmp ^ Titov ;
11740: LD_ADDR_VAR 0 3
11744: PUSH
11745: LD_VAR 0 3
11749: PUSH
11750: LD_EXP 83
11754: ADD
11755: ST_TO_ADDR
// if Lipshchin then
11756: LD_EXP 81
11760: IFFALSE 11778
// tmp := tmp ^ Lipshchin ;
11762: LD_ADDR_VAR 0 3
11766: PUSH
11767: LD_VAR 0 3
11771: PUSH
11772: LD_EXP 81
11776: ADD
11777: ST_TO_ADDR
// if Gnyevko then
11778: LD_EXP 82
11782: IFFALSE 11800
// tmp := tmp ^ Gnyevko ;
11784: LD_ADDR_VAR 0 3
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_EXP 82
11798: ADD
11799: ST_TO_ADDR
// if Xavier then
11800: LD_EXP 84
11804: IFFALSE 11822
// tmp := tmp ^ Xavier ;
11806: LD_ADDR_VAR 0 3
11810: PUSH
11811: LD_VAR 0 3
11815: PUSH
11816: LD_EXP 84
11820: ADD
11821: ST_TO_ADDR
// if Belkov then
11822: LD_EXP 85
11826: IFFALSE 11844
// tmp := tmp ^ Belkov ;
11828: LD_ADDR_VAR 0 3
11832: PUSH
11833: LD_VAR 0 3
11837: PUSH
11838: LD_EXP 85
11842: ADD
11843: ST_TO_ADDR
// if Burlak then
11844: LD_EXP 86
11848: IFFALSE 11866
// tmp := tmp ^ Burlak ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: LD_VAR 0 3
11859: PUSH
11860: LD_EXP 86
11864: ADD
11865: ST_TO_ADDR
// for i = 1 to 11 do
11866: LD_ADDR_VAR 0 2
11870: PUSH
11871: DOUBLE
11872: LD_INT 1
11874: DEC
11875: ST_TO_ADDR
11876: LD_INT 11
11878: PUSH
11879: FOR_TO
11880: IFFALSE 11946
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11882: LD_ADDR_OWVAR 21
11886: PUSH
11887: LD_INT 1
11889: PUSH
11890: LD_INT 3
11892: PUSH
11893: EMPTY
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 1
11899: PPUSH
11900: LD_INT 2
11902: PPUSH
11903: CALL_OW 12
11907: ARRAY
11908: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11909: LD_INT 0
11911: PPUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 2
11919: DIV
11920: PPUSH
11921: LD_INT 10
11923: PPUSH
11924: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11928: LD_ADDR_VAR 0 3
11932: PUSH
11933: LD_VAR 0 3
11937: PUSH
11938: CALL_OW 44
11942: ADD
11943: ST_TO_ADDR
// end ;
11944: GO 11879
11946: POP
11947: POP
// for i in tmp do
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 3
11957: PUSH
11958: FOR_IN
11959: IFFALSE 11984
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11961: LD_VAR 0 2
11965: PPUSH
11966: LD_INT 260
11968: PPUSH
11969: LD_INT 235
11971: PPUSH
11972: LD_INT 8
11974: PPUSH
11975: LD_INT 0
11977: PPUSH
11978: CALL_OW 50
11982: GO 11958
11984: POP
11985: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11986: LD_ADDR_EXP 116
11990: PUSH
11991: LD_EXP 116
11995: PPUSH
11996: LD_INT 1
11998: PPUSH
11999: LD_INT 22
12001: PUSH
12002: LD_VAR 0 5
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: PUSH
12011: LD_INT 3
12013: PUSH
12014: LD_INT 21
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 69
12036: PUSH
12037: LD_EXP 74
12041: PUSH
12042: LD_EXP 75
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: DIFF
12051: PPUSH
12052: CALL_OW 1
12056: ST_TO_ADDR
// uc_side := 0 ;
12057: LD_ADDR_OWVAR 20
12061: PUSH
12062: LD_INT 0
12064: ST_TO_ADDR
// uc_nation := 0 ;
12065: LD_ADDR_OWVAR 21
12069: PUSH
12070: LD_INT 0
12072: ST_TO_ADDR
// for i = 1 to 5 do
12073: LD_ADDR_VAR 0 2
12077: PUSH
12078: DOUBLE
12079: LD_INT 1
12081: DEC
12082: ST_TO_ADDR
12083: LD_INT 5
12085: PUSH
12086: FOR_TO
12087: IFFALSE 12124
// begin InitHc ;
12089: CALL_OW 19
// hc_class := class_apeman ;
12093: LD_ADDR_OWVAR 28
12097: PUSH
12098: LD_INT 12
12100: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12101: CALL_OW 44
12105: PPUSH
12106: LD_INT 299
12108: PPUSH
12109: LD_INT 229
12111: PPUSH
12112: LD_INT 10
12114: PPUSH
12115: LD_INT 0
12117: PPUSH
12118: CALL_OW 50
// end ;
12122: GO 12086
12124: POP
12125: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12126: LD_EXP 74
12130: PPUSH
12131: LD_INT 259
12133: PPUSH
12134: LD_INT 235
12136: PPUSH
12137: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12141: LD_EXP 74
12145: PPUSH
12146: LD_INT 262
12148: PPUSH
12149: LD_INT 235
12151: PPUSH
12152: CALL_OW 178
// if Simms then
12156: LD_EXP 75
12160: IFFALSE 12191
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12162: LD_EXP 75
12166: PPUSH
12167: LD_INT 262
12169: PPUSH
12170: LD_INT 235
12172: PPUSH
12173: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12177: LD_EXP 75
12181: PPUSH
12182: LD_EXP 74
12186: PPUSH
12187: CALL_OW 179
// end ; end ;
12191: LD_VAR 0 1
12195: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12196: LD_EXP 31
12200: PUSH
12201: LD_EXP 23
12205: NOT
12206: AND
12207: IFFALSE 12383
12209: GO 12211
12211: DISABLE
12212: LD_INT 0
12214: PPUSH
12215: PPUSH
12216: PPUSH
// begin enable ;
12217: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12218: LD_ADDR_VAR 0 2
12222: PUSH
12223: LD_INT 81
12225: PUSH
12226: LD_INT 7
12228: PUSH
12229: EMPTY
12230: LIST
12231: LIST
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 32
12238: PUSH
12239: LD_INT 3
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 30
12248: PUSH
12249: LD_INT 30
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: LD_INT 30
12258: PUSH
12259: LD_INT 28
12261: PUSH
12262: EMPTY
12263: LIST
12264: LIST
12265: PUSH
12266: LD_INT 34
12268: PUSH
12269: LD_INT 49
12271: PUSH
12272: EMPTY
12273: LIST
12274: LIST
12275: PUSH
12276: LD_INT 34
12278: PUSH
12279: LD_INT 10
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PUSH
12286: LD_INT 34
12288: PUSH
12289: LD_INT 8
12291: PUSH
12292: EMPTY
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: PUSH
12305: EMPTY
12306: LIST
12307: LIST
12308: PPUSH
12309: CALL_OW 69
12313: ST_TO_ADDR
// if not tmp then
12314: LD_VAR 0 2
12318: NOT
12319: IFFALSE 12323
// exit ;
12321: GO 12383
// target := tmp [ rand ( 1 , tmp ) ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 2
12332: PUSH
12333: LD_INT 1
12335: PPUSH
12336: LD_VAR 0 2
12340: PPUSH
12341: CALL_OW 12
12345: ARRAY
12346: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12347: LD_VAR 0 3
12351: PPUSH
12352: CALL_OW 255
12356: PUSH
12357: LD_INT 1
12359: EQUAL
12360: IFFALSE 12371
// CenterNowOnUnits ( target ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 87
// SetLives ( target , 0 ) ;
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 234
// end ;
12383: PPOPN 3
12385: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12386: LD_EXP 23
12390: NOT
12391: PUSH
12392: LD_EXP 31
12396: AND
12397: IFFALSE 12919
12399: GO 12401
12401: DISABLE
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// begin uc_side := 7 ;
12407: LD_ADDR_OWVAR 20
12411: PUSH
12412: LD_INT 7
12414: ST_TO_ADDR
// uc_nation := 1 ;
12415: LD_ADDR_OWVAR 21
12419: PUSH
12420: LD_INT 1
12422: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 125
12430: PUSH
12431: LD_INT 163
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 185
12440: PUSH
12441: LD_INT 168
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: PUSH
12448: LD_INT 111
12450: PUSH
12451: LD_INT 97
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: PUSH
12458: EMPTY
12459: LIST
12460: LIST
12461: LIST
12462: PPUSH
12463: CALL 102315 0 1
12467: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: EMPTY
12474: ST_TO_ADDR
// for i = 1 to Difficulty do
12475: LD_ADDR_VAR 0 1
12479: PUSH
12480: DOUBLE
12481: LD_INT 1
12483: DEC
12484: ST_TO_ADDR
12485: LD_OWVAR 67
12489: PUSH
12490: FOR_TO
12491: IFFALSE 12649
// begin InitHc ;
12493: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12497: LD_INT 0
12499: PPUSH
12500: LD_INT 8
12502: PPUSH
12503: CALL_OW 381
// un := CreateHuman ;
12507: LD_ADDR_VAR 0 2
12511: PUSH
12512: CALL_OW 44
12516: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12517: LD_VAR 0 2
12521: PPUSH
12522: LD_INT 258
12524: PPUSH
12525: LD_INT 267
12527: PPUSH
12528: LD_INT 4
12530: PPUSH
12531: LD_INT 0
12533: PPUSH
12534: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12538: LD_ADDR_EXP 91
12542: PUSH
12543: LD_EXP 91
12547: PUSH
12548: LD_VAR 0 2
12552: UNION
12553: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12554: LD_VAR 0 2
12558: PPUSH
12559: LD_VAR 0 3
12563: PUSH
12564: LD_VAR 0 1
12568: ARRAY
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 3
12578: PUSH
12579: LD_VAR 0 1
12583: ARRAY
12584: PUSH
12585: LD_INT 2
12587: ARRAY
12588: PPUSH
12589: LD_INT 4
12591: PPUSH
12592: LD_INT 1
12594: PPUSH
12595: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12599: LD_VAR 0 2
12603: PPUSH
12604: LD_VAR 0 3
12608: PUSH
12609: LD_VAR 0 1
12613: ARRAY
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: PPUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_VAR 0 1
12628: ARRAY
12629: PUSH
12630: LD_INT 2
12632: ARRAY
12633: PPUSH
12634: CALL_OW 171
// AddComInvisible ( un ) ;
12638: LD_VAR 0 2
12642: PPUSH
12643: CALL_OW 212
// end ;
12647: GO 12490
12649: POP
12650: POP
// repeat wait ( 0 0$20 ) ;
12651: LD_INT 700
12653: PPUSH
12654: CALL_OW 67
// for i in allianceSpecialForce do
12658: LD_ADDR_VAR 0 1
12662: PUSH
12663: LD_EXP 91
12667: PUSH
12668: FOR_IN
12669: IFFALSE 12904
// begin if IsInvisible ( i ) then
12671: LD_VAR 0 1
12675: PPUSH
12676: CALL_OW 571
12680: IFFALSE 12873
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 22
12689: PUSH
12690: LD_INT 1
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: PUSH
12697: LD_INT 50
12699: PUSH
12700: EMPTY
12701: LIST
12702: PUSH
12703: LD_INT 56
12705: PUSH
12706: EMPTY
12707: LIST
12708: PUSH
12709: LD_INT 91
12711: PUSH
12712: LD_VAR 0 1
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 30
12722: PUSH
12723: LD_INT 35
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: PUSH
12731: LD_OWVAR 67
12735: ARRAY
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: LIST
12741: PUSH
12742: LD_INT 2
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 1
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 25
12767: PUSH
12768: LD_INT 3
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 4
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: LD_INT 25
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: LD_INT 25
12797: PUSH
12798: LD_INT 8
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: EMPTY
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: PPUSH
12821: CALL_OW 69
12825: ST_TO_ADDR
// if not tmp then
12826: LD_VAR 0 3
12830: NOT
12831: IFFALSE 12835
// continue ;
12833: GO 12668
// if Prob ( 30 * Difficulty ) then
12835: LD_INT 30
12837: PUSH
12838: LD_OWVAR 67
12842: MUL
12843: PPUSH
12844: CALL_OW 13
12848: IFFALSE 12873
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12850: LD_VAR 0 3
12854: PUSH
12855: LD_INT 1
12857: PPUSH
12858: LD_VAR 0 3
12862: PPUSH
12863: CALL_OW 12
12867: ARRAY
12868: PPUSH
12869: CALL 31166 0 1
// end ; if IsDead ( i ) then
12873: LD_VAR 0 1
12877: PPUSH
12878: CALL_OW 301
12882: IFFALSE 12902
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12884: LD_ADDR_EXP 91
12888: PUSH
12889: LD_EXP 91
12893: PUSH
12894: LD_VAR 0 1
12898: DIFF
12899: ST_TO_ADDR
// continue ;
12900: GO 12668
// end ; end ;
12902: GO 12668
12904: POP
12905: POP
// until allianceDestroyed or not allianceSpecialForce ;
12906: LD_EXP 23
12910: PUSH
12911: LD_EXP 91
12915: NOT
12916: OR
12917: IFFALSE 12651
// end ;
12919: PPOPN 3
12921: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12922: LD_EXP 23
12926: NOT
12927: PUSH
12928: LD_EXP 31
12932: AND
12933: IFFALSE 13900
12935: GO 12937
12937: DISABLE
12938: LD_INT 0
12940: PPUSH
12941: PPUSH
12942: PPUSH
12943: PPUSH
// begin enable ;
12944: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12945: LD_INT 22
12947: PUSH
12948: LD_INT 7
12950: PUSH
12951: EMPTY
12952: LIST
12953: LIST
12954: PUSH
12955: LD_INT 30
12957: PUSH
12958: LD_INT 3
12960: PUSH
12961: EMPTY
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: NOT
12974: IFFALSE 12978
// exit ;
12976: GO 13900
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12978: LD_ADDR_VAR 0 4
12982: PUSH
12983: LD_INT 22
12985: PUSH
12986: LD_INT 7
12988: PUSH
12989: EMPTY
12990: LIST
12991: LIST
12992: PUSH
12993: LD_INT 30
12995: PUSH
12996: LD_INT 34
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: PUSH
13003: EMPTY
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: ST_TO_ADDR
// if Prob ( 40 ) then
13012: LD_INT 40
13014: PPUSH
13015: CALL_OW 13
13019: IFFALSE 13146
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13021: LD_INT 1
13023: PPUSH
13024: LD_INT 5
13026: PUSH
13027: LD_INT 3
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: PUSH
13042: LD_INT 5
13044: PUSH
13045: LD_INT 3
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 6
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 3
13065: PUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 6
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 24
13080: PUSH
13081: LD_INT 3
13083: PUSH
13084: LD_INT 3
13086: PUSH
13087: LD_INT 45
13089: PUSH
13090: EMPTY
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 24
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 3
13104: PUSH
13105: LD_INT 47
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: LD_INT 24
13116: PUSH
13117: LD_INT 3
13119: PUSH
13120: LD_INT 3
13122: PUSH
13123: LD_INT 45
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: PUSH
13132: EMPTY
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: PPUSH
13140: CALL 59075 0 2
// end else
13144: GO 13269
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13146: LD_INT 1
13148: PPUSH
13149: LD_INT 24
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 3
13157: PUSH
13158: LD_INT 47
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: PUSH
13167: LD_INT 24
13169: PUSH
13170: LD_INT 3
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 47
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 5
13187: PUSH
13188: LD_INT 3
13190: PUSH
13191: LD_INT 2
13193: PUSH
13194: LD_INT 9
13196: PUSH
13197: EMPTY
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 5
13205: PUSH
13206: LD_INT 3
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: LD_INT 9
13214: PUSH
13215: EMPTY
13216: LIST
13217: LIST
13218: LIST
13219: LIST
13220: PUSH
13221: LD_INT 24
13223: PUSH
13224: LD_INT 1
13226: PUSH
13227: LD_INT 3
13229: PUSH
13230: LD_INT 45
13232: PUSH
13233: EMPTY
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 24
13241: PUSH
13242: LD_INT 1
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 45
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: PUSH
13257: EMPTY
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: PPUSH
13265: CALL 59075 0 2
// end ; if Difficulty > 1 then
13269: LD_OWVAR 67
13273: PUSH
13274: LD_INT 1
13276: GREATER
13277: IFFALSE 13307
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13279: LD_INT 1
13281: PPUSH
13282: LD_INT 24
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 3
13290: PUSH
13291: LD_INT 47
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: PUSH
13300: EMPTY
13301: LIST
13302: PPUSH
13303: CALL 59075 0 2
// repeat wait ( 0 0$1 ) ;
13307: LD_INT 35
13309: PPUSH
13310: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13314: LD_INT 1
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL 60493 0 2
13324: PUSH
13325: LD_INT 6
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: LD_INT 7
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: LIST
13338: PUSH
13339: LD_OWVAR 67
13343: ARRAY
13344: GREATEREQUAL
13345: IFFALSE 13307
// wait ( 0 0$40 ) ;
13347: LD_INT 1400
13349: PPUSH
13350: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13354: LD_ADDR_VAR 0 2
13358: PUSH
13359: LD_INT 1
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL 60493 0 2
13369: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13370: LD_ADDR_EXP 135
13374: PUSH
13375: LD_EXP 135
13379: PPUSH
13380: LD_INT 1
13382: PPUSH
13383: LD_EXP 135
13387: PUSH
13388: LD_INT 1
13390: ARRAY
13391: PUSH
13392: LD_VAR 0 2
13396: DIFF
13397: PPUSH
13398: CALL_OW 1
13402: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13403: LD_ADDR_VAR 0 3
13407: PUSH
13408: LD_INT 0
13410: PPUSH
13411: LD_INT 1
13413: PPUSH
13414: CALL_OW 12
13418: ST_TO_ADDR
// if target then
13419: LD_VAR 0 3
13423: IFFALSE 13589
// begin for i in tmp do
13425: LD_ADDR_VAR 0 1
13429: PUSH
13430: LD_VAR 0 2
13434: PUSH
13435: FOR_IN
13436: IFFALSE 13461
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_INT 179
13445: PPUSH
13446: LD_INT 209
13448: PPUSH
13449: LD_INT 8
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 483
13459: GO 13435
13461: POP
13462: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13463: LD_ADDR_VAR 0 2
13467: PUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: LD_INT 24
13475: PUSH
13476: LD_INT 250
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 72
13487: ST_TO_ADDR
// for i in tmp do
13488: LD_ADDR_VAR 0 1
13492: PUSH
13493: LD_VAR 0 2
13497: PUSH
13498: FOR_IN
13499: IFFALSE 13539
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13501: LD_VAR 0 1
13505: PPUSH
13506: LD_INT 179
13508: PPUSH
13509: LD_INT 209
13511: PPUSH
13512: CALL_OW 297
13516: PUSH
13517: LD_INT 9
13519: GREATER
13520: IFFALSE 13537
// ComMoveXY ( i , 179 , 209 ) ;
13522: LD_VAR 0 1
13526: PPUSH
13527: LD_INT 179
13529: PPUSH
13530: LD_INT 209
13532: PPUSH
13533: CALL_OW 111
13537: GO 13498
13539: POP
13540: POP
// wait ( 0 0$1 ) ;
13541: LD_INT 35
13543: PPUSH
13544: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 92
13555: PUSH
13556: LD_INT 179
13558: PUSH
13559: LD_INT 209
13561: PUSH
13562: LD_INT 9
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: PPUSH
13571: CALL_OW 72
13575: PUSH
13576: LD_VAR 0 2
13580: PUSH
13581: LD_INT 1
13583: MINUS
13584: GREATEREQUAL
13585: IFFALSE 13463
// end else
13587: GO 13751
// begin for i in tmp do
13589: LD_ADDR_VAR 0 1
13593: PUSH
13594: LD_VAR 0 2
13598: PUSH
13599: FOR_IN
13600: IFFALSE 13625
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 285
13609: PPUSH
13610: LD_INT 163
13612: PPUSH
13613: LD_INT 8
13615: PPUSH
13616: LD_INT 1
13618: PPUSH
13619: CALL_OW 483
13623: GO 13599
13625: POP
13626: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13627: LD_ADDR_VAR 0 2
13631: PUSH
13632: LD_VAR 0 2
13636: PPUSH
13637: LD_INT 24
13639: PUSH
13640: LD_INT 250
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PPUSH
13647: CALL_OW 72
13651: ST_TO_ADDR
// for i in tmp do
13652: LD_ADDR_VAR 0 1
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: FOR_IN
13663: IFFALSE 13703
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13665: LD_VAR 0 1
13669: PPUSH
13670: LD_INT 285
13672: PPUSH
13673: LD_INT 163
13675: PPUSH
13676: CALL_OW 297
13680: PUSH
13681: LD_INT 9
13683: GREATER
13684: IFFALSE 13701
// ComMoveXY ( i , 285 , 163 ) ;
13686: LD_VAR 0 1
13690: PPUSH
13691: LD_INT 285
13693: PPUSH
13694: LD_INT 163
13696: PPUSH
13697: CALL_OW 111
13701: GO 13662
13703: POP
13704: POP
// wait ( 0 0$1 ) ;
13705: LD_INT 35
13707: PPUSH
13708: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 92
13719: PUSH
13720: LD_INT 285
13722: PUSH
13723: LD_INT 163
13725: PUSH
13726: LD_INT 9
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: PPUSH
13735: CALL_OW 72
13739: PUSH
13740: LD_VAR 0 2
13744: PUSH
13745: LD_INT 1
13747: MINUS
13748: GREATEREQUAL
13749: IFFALSE 13627
// end ; repeat wait ( 0 0$1 ) ;
13751: LD_INT 35
13753: PPUSH
13754: CALL_OW 67
// for i in tmp do
13758: LD_ADDR_VAR 0 1
13762: PUSH
13763: LD_VAR 0 2
13767: PUSH
13768: FOR_IN
13769: IFFALSE 13891
// if GetLives ( i ) > 251 then
13771: LD_VAR 0 1
13775: PPUSH
13776: CALL_OW 256
13780: PUSH
13781: LD_INT 251
13783: GREATER
13784: IFFALSE 13873
// begin if GetWeapon ( i ) = ru_time_lapser then
13786: LD_VAR 0 1
13790: PPUSH
13791: CALL_OW 264
13795: PUSH
13796: LD_INT 49
13798: EQUAL
13799: IFFALSE 13837
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13801: LD_VAR 0 1
13805: PPUSH
13806: LD_INT 81
13808: PUSH
13809: LD_INT 7
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: PPUSH
13821: LD_VAR 0 1
13825: PPUSH
13826: CALL_OW 74
13830: PPUSH
13831: CALL_OW 112
13835: GO 13871
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_INT 81
13844: PUSH
13845: LD_INT 7
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PPUSH
13852: CALL_OW 69
13856: PPUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 74
13866: PPUSH
13867: CALL_OW 115
// end else
13871: GO 13889
// tmp := tmp diff i ;
13873: LD_ADDR_VAR 0 2
13877: PUSH
13878: LD_VAR 0 2
13882: PUSH
13883: LD_VAR 0 1
13887: DIFF
13888: ST_TO_ADDR
13889: GO 13768
13891: POP
13892: POP
// until not tmp ;
13893: LD_VAR 0 2
13897: NOT
13898: IFFALSE 13751
// end ; end_of_file
13900: PPOPN 4
13902: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
13908: PPUSH
// missionStage := 13 ;
13909: LD_ADDR_EXP 15
13913: PUSH
13914: LD_INT 13
13916: ST_TO_ADDR
// uc_side := 2 ;
13917: LD_ADDR_OWVAR 20
13921: PUSH
13922: LD_INT 2
13924: ST_TO_ADDR
// uc_nation := 2 ;
13925: LD_ADDR_OWVAR 21
13929: PUSH
13930: LD_INT 2
13932: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13933: LD_ADDR_EXP 92
13937: PUSH
13938: LD_STRING Omar
13940: PPUSH
13941: CALL_OW 25
13945: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13946: LD_EXP 92
13950: PPUSH
13951: LD_INT 4
13953: PPUSH
13954: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13958: LD_EXP 92
13962: PPUSH
13963: LD_INT 242
13965: PPUSH
13966: LD_INT 75
13968: PPUSH
13969: LD_INT 0
13971: PPUSH
13972: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13976: LD_ADDR_EXP 93
13980: PUSH
13981: LD_STRING Heike
13983: PPUSH
13984: CALL_OW 25
13988: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13989: LD_INT 14
13991: PPUSH
13992: LD_INT 3
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: LD_INT 27
14000: PPUSH
14001: LD_INT 100
14003: PPUSH
14004: CALL 70336 0 5
// veh := CreateVehicle ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: CALL_OW 45
14017: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14018: LD_VAR 0 3
14022: PPUSH
14023: LD_INT 1
14025: PPUSH
14026: CALL_OW 242
// SetDir ( veh , 4 ) ;
14030: LD_VAR 0 3
14034: PPUSH
14035: LD_INT 4
14037: PPUSH
14038: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14042: LD_VAR 0 3
14046: PPUSH
14047: LD_INT 241
14049: PPUSH
14050: LD_INT 72
14052: PPUSH
14053: LD_INT 0
14055: PPUSH
14056: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14060: LD_EXP 93
14064: PPUSH
14065: LD_VAR 0 3
14069: PPUSH
14070: CALL_OW 52
// if KhatamStatus then
14074: LD_EXP 8
14078: IFFALSE 14129
// begin Khatam := NewCharacter ( Khatam ) ;
14080: LD_ADDR_EXP 94
14084: PUSH
14085: LD_STRING Khatam
14087: PPUSH
14088: CALL_OW 25
14092: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14093: LD_EXP 94
14097: PPUSH
14098: LD_INT 245
14100: PPUSH
14101: LD_INT 78
14103: PPUSH
14104: LD_INT 3
14106: PPUSH
14107: LD_INT 0
14109: PPUSH
14110: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14114: LD_EXP 94
14118: PPUSH
14119: LD_INT 4
14121: PPUSH
14122: LD_INT 10
14124: PPUSH
14125: CALL_OW 237
// end ; for i = 1 to Difficulty do
14129: LD_ADDR_VAR 0 2
14133: PUSH
14134: DOUBLE
14135: LD_INT 1
14137: DEC
14138: ST_TO_ADDR
14139: LD_OWVAR 67
14143: PUSH
14144: FOR_TO
14145: IFFALSE 14211
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14147: LD_INT 0
14149: PPUSH
14150: LD_INT 7
14152: PUSH
14153: LD_OWVAR 67
14157: PLUS
14158: PPUSH
14159: CALL_OW 384
// un := CreateHuman ;
14163: LD_ADDR_VAR 0 4
14167: PUSH
14168: CALL_OW 44
14172: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14173: LD_VAR 0 4
14177: PPUSH
14178: LD_INT 28
14180: PUSH
14181: LD_INT 29
14183: PUSH
14184: EMPTY
14185: LIST
14186: LIST
14187: PUSH
14188: LD_VAR 0 2
14192: PUSH
14193: LD_INT 2
14195: MOD
14196: PUSH
14197: LD_INT 1
14199: PLUS
14200: ARRAY
14201: PPUSH
14202: LD_INT 0
14204: PPUSH
14205: CALL_OW 49
// end ;
14209: GO 14144
14211: POP
14212: POP
// for i = 1 to 6 do
14213: LD_ADDR_VAR 0 2
14217: PUSH
14218: DOUBLE
14219: LD_INT 1
14221: DEC
14222: ST_TO_ADDR
14223: LD_INT 6
14225: PUSH
14226: FOR_TO
14227: IFFALSE 14272
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14229: LD_INT 0
14231: PPUSH
14232: LD_INT 7
14234: PUSH
14235: LD_OWVAR 67
14239: PLUS
14240: PPUSH
14241: CALL_OW 381
// un := CreateHuman ;
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: CALL_OW 44
14254: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14255: LD_VAR 0 4
14259: PPUSH
14260: LD_INT 28
14262: PPUSH
14263: LD_INT 0
14265: PPUSH
14266: CALL_OW 49
// end ;
14270: GO 14226
14272: POP
14273: POP
// for i = 1 to 3 do
14274: LD_ADDR_VAR 0 2
14278: PUSH
14279: DOUBLE
14280: LD_INT 1
14282: DEC
14283: ST_TO_ADDR
14284: LD_INT 3
14286: PUSH
14287: FOR_TO
14288: IFFALSE 14336
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14290: LD_INT 0
14292: PPUSH
14293: LD_INT 8
14295: PPUSH
14296: LD_INT 7
14298: PUSH
14299: LD_OWVAR 67
14303: PLUS
14304: PPUSH
14305: CALL_OW 380
// un := CreateHuman ;
14309: LD_ADDR_VAR 0 4
14313: PUSH
14314: CALL_OW 44
14318: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14319: LD_VAR 0 4
14323: PPUSH
14324: LD_INT 28
14326: PPUSH
14327: LD_INT 0
14329: PPUSH
14330: CALL_OW 49
// end ;
14334: GO 14287
14336: POP
14337: POP
// for i = 1 to 3 do
14338: LD_ADDR_VAR 0 2
14342: PUSH
14343: DOUBLE
14344: LD_INT 1
14346: DEC
14347: ST_TO_ADDR
14348: LD_INT 3
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14442
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14354: LD_INT 14
14356: PPUSH
14357: LD_INT 2
14359: PPUSH
14360: LD_INT 1
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 80
14368: PPUSH
14369: CALL 70336 0 5
// veh := CreateVehicle ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: CALL_OW 45
14382: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14383: LD_VAR 0 3
14387: PPUSH
14388: LD_INT 3
14390: PPUSH
14391: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14395: LD_VAR 0 3
14399: PPUSH
14400: LD_INT 29
14402: PPUSH
14403: LD_INT 0
14405: PPUSH
14406: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14410: LD_INT 0
14412: PPUSH
14413: LD_INT 7
14415: PUSH
14416: LD_OWVAR 67
14420: PLUS
14421: PPUSH
14422: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14426: CALL_OW 44
14430: PPUSH
14431: LD_VAR 0 3
14435: PPUSH
14436: CALL_OW 52
// end ;
14440: GO 14351
14442: POP
14443: POP
// for i = 1 to 5 + Difficulty do
14444: LD_ADDR_VAR 0 2
14448: PUSH
14449: DOUBLE
14450: LD_INT 1
14452: DEC
14453: ST_TO_ADDR
14454: LD_INT 5
14456: PUSH
14457: LD_OWVAR 67
14461: PLUS
14462: PUSH
14463: FOR_TO
14464: IFFALSE 14591
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14466: LD_INT 14
14468: PPUSH
14469: LD_INT 1
14471: PPUSH
14472: LD_INT 3
14474: PPUSH
14475: CALL_OW 12
14479: PPUSH
14480: LD_INT 1
14482: PPUSH
14483: LD_INT 28
14485: PUSH
14486: LD_INT 26
14488: PUSH
14489: LD_INT 27
14491: PUSH
14492: LD_INT 25
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PUSH
14501: LD_VAR 0 2
14505: PUSH
14506: LD_INT 4
14508: MOD
14509: PUSH
14510: LD_INT 1
14512: PLUS
14513: ARRAY
14514: PPUSH
14515: LD_INT 80
14517: PPUSH
14518: CALL 70336 0 5
// veh := CreateVehicle ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: CALL_OW 45
14531: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14532: LD_VAR 0 3
14536: PPUSH
14537: LD_INT 4
14539: PPUSH
14540: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14544: LD_VAR 0 3
14548: PPUSH
14549: LD_INT 28
14551: PPUSH
14552: LD_INT 0
14554: PPUSH
14555: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14559: LD_INT 0
14561: PPUSH
14562: LD_INT 7
14564: PUSH
14565: LD_OWVAR 67
14569: PLUS
14570: PPUSH
14571: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14575: CALL_OW 44
14579: PPUSH
14580: LD_VAR 0 3
14584: PPUSH
14585: CALL_OW 52
// end ;
14589: GO 14463
14591: POP
14592: POP
// for i = 1 to 3 do
14593: LD_ADDR_VAR 0 2
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_INT 3
14605: PUSH
14606: FOR_TO
14607: IFFALSE 14667
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14609: LD_INT 14
14611: PPUSH
14612: LD_INT 3
14614: PPUSH
14615: LD_INT 5
14617: PPUSH
14618: LD_INT 29
14620: PPUSH
14621: LD_INT 80
14623: PPUSH
14624: CALL 70336 0 5
// veh := CreateVehicle ;
14628: LD_ADDR_VAR 0 3
14632: PUSH
14633: CALL_OW 45
14637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14638: LD_VAR 0 3
14642: PPUSH
14643: LD_INT 4
14645: PPUSH
14646: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14650: LD_VAR 0 3
14654: PPUSH
14655: LD_INT 28
14657: PPUSH
14658: LD_INT 0
14660: PPUSH
14661: CALL_OW 49
// end ;
14665: GO 14606
14667: POP
14668: POP
// end ;
14669: LD_VAR 0 1
14673: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14674: LD_INT 22
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PPUSH
14684: CALL_OW 69
14688: IFFALSE 14988
14690: GO 14692
14692: DISABLE
14693: LD_INT 0
14695: PPUSH
14696: PPUSH
14697: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14698: LD_ADDR_VAR 0 3
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PUSH
14713: LD_INT 25
14715: PUSH
14716: LD_INT 4
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: EMPTY
14724: LIST
14725: LIST
14726: PPUSH
14727: CALL_OW 69
14731: PUSH
14732: LD_EXP 94
14736: DIFF
14737: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 2
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: PUSH
14758: LD_EXP 94
14762: PUSH
14763: LD_VAR 0 3
14767: UNION
14768: DIFF
14769: ST_TO_ADDR
// if Khatam then
14770: LD_EXP 94
14774: IFFALSE 14791
// ComMoveXY ( Khatam , 211 , 92 ) ;
14776: LD_EXP 94
14780: PPUSH
14781: LD_INT 211
14783: PPUSH
14784: LD_INT 92
14786: PPUSH
14787: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14791: LD_INT 197
14793: PPUSH
14794: LD_INT 80
14796: PPUSH
14797: LD_INT 2
14799: PPUSH
14800: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14804: LD_INT 213
14806: PPUSH
14807: LD_INT 90
14809: PPUSH
14810: LD_INT 2
14812: PPUSH
14813: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14817: LD_INT 215
14819: PPUSH
14820: LD_INT 129
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 441
// if sci then
14830: LD_VAR 0 3
14834: IFFALSE 14855
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14836: LD_VAR 0 3
14840: PUSH
14841: LD_INT 1
14843: ARRAY
14844: PPUSH
14845: LD_INT 197
14847: PPUSH
14848: LD_INT 80
14850: PPUSH
14851: CALL_OW 158
// if sci > 1 then
14855: LD_VAR 0 3
14859: PUSH
14860: LD_INT 1
14862: GREATER
14863: IFFALSE 14884
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14865: LD_VAR 0 3
14869: PUSH
14870: LD_INT 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 213
14876: PPUSH
14877: LD_INT 90
14879: PPUSH
14880: CALL_OW 158
// if sci > 2 then
14884: LD_VAR 0 3
14888: PUSH
14889: LD_INT 2
14891: GREATER
14892: IFFALSE 14913
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14894: LD_VAR 0 3
14898: PUSH
14899: LD_INT 3
14901: ARRAY
14902: PPUSH
14903: LD_INT 215
14905: PPUSH
14906: LD_INT 129
14908: PPUSH
14909: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14913: LD_INT 35
14915: PPUSH
14916: CALL_OW 67
// for i in tmp do
14920: LD_ADDR_VAR 0 1
14924: PUSH
14925: LD_VAR 0 2
14929: PUSH
14930: FOR_IN
14931: IFFALSE 14969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14933: LD_VAR 0 1
14937: PPUSH
14938: LD_INT 81
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: PPUSH
14953: LD_VAR 0 1
14957: PPUSH
14958: CALL_OW 74
14962: PPUSH
14963: CALL_OW 115
14967: GO 14930
14969: POP
14970: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14971: LD_INT 22
14973: PUSH
14974: LD_INT 2
14976: PUSH
14977: EMPTY
14978: LIST
14979: LIST
14980: PPUSH
14981: CALL_OW 69
14985: NOT
14986: IFFALSE 14913
// end ; end_of_file
14988: PPOPN 3
14990: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14991: LD_INT 0
14993: PPUSH
14994: PPUSH
14995: PPUSH
14996: PPUSH
14997: PPUSH
14998: PPUSH
14999: PPUSH
15000: PPUSH
15001: PPUSH
// Video ( true ) ;
15002: LD_INT 1
15004: PPUSH
15005: CALL 102182 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: LD_INT 7
15016: PPUSH
15017: LD_INT 0
15019: PPUSH
15020: CALL_OW 517
15024: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: DOUBLE
15031: LD_INT 1
15033: DEC
15034: ST_TO_ADDR
15035: LD_VAR 0 5
15039: PUSH
15040: LD_INT 1
15042: ARRAY
15043: PUSH
15044: FOR_TO
15045: IFFALSE 15090
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15047: LD_VAR 0 5
15051: PUSH
15052: LD_INT 1
15054: ARRAY
15055: PUSH
15056: LD_VAR 0 2
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 5
15066: PUSH
15067: LD_INT 2
15069: ARRAY
15070: PUSH
15071: LD_VAR 0 2
15075: ARRAY
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: LD_INT 15
15082: NEG
15083: PPUSH
15084: CALL 102096 0 4
15088: GO 15044
15090: POP
15091: POP
// CenterNowOnUnits ( Powell ) ;
15092: LD_EXP 58
15096: PPUSH
15097: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15101: LD_ADDR_VAR 0 5
15105: PUSH
15106: LD_EXP 56
15110: PUSH
15111: EMPTY
15112: LIST
15113: ST_TO_ADDR
// if GirlNewVeh then
15114: LD_EXP 57
15118: IFFALSE 15136
// tmp := tmp ^ GirlNewVeh ;
15120: LD_ADDR_VAR 0 5
15124: PUSH
15125: LD_VAR 0 5
15129: PUSH
15130: LD_EXP 57
15134: ADD
15135: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15136: LD_VAR 0 5
15140: PPUSH
15141: LD_INT 60
15143: PPUSH
15144: LD_INT 109
15146: PPUSH
15147: CALL_OW 111
// if KappaStatus then
15151: LD_EXP 2
15155: IFFALSE 15207
// begin Say ( JMM , D1nT-JMM-1 ) ;
15157: LD_EXP 39
15161: PPUSH
15162: LD_STRING D1nT-JMM-1
15164: PPUSH
15165: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15169: LD_EXP 58
15173: PPUSH
15174: LD_STRING D1T-Pow-1
15176: PPUSH
15177: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15181: LD_EXP 39
15185: PPUSH
15186: LD_STRING D1T-JMM-2
15188: PPUSH
15189: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15193: LD_EXP 58
15197: PPUSH
15198: LD_STRING D1T-Pow-2
15200: PPUSH
15201: CALL_OW 88
// end else
15205: GO 15413
// if JMMGirlStatus then
15207: LD_EXP 6
15211: IFFALSE 15356
// begin Say ( JMM , D1T-JMM-1 ) ;
15213: LD_EXP 39
15217: PPUSH
15218: LD_STRING D1T-JMM-1
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15225: LD_EXP 58
15229: PPUSH
15230: LD_STRING D1T-Pow-1
15232: PPUSH
15233: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1T-JMM-3
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-3
15256: PPUSH
15257: CALL_OW 88
// if JMMGirl then
15261: LD_EXP 7
15265: IFFALSE 15354
// begin case JMMGirl of 1 :
15267: LD_EXP 7
15271: PUSH
15272: LD_INT 1
15274: DOUBLE
15275: EQUAL
15276: IFTRUE 15280
15278: GO 15295
15280: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15281: LD_EXP 40
15285: PPUSH
15286: LD_STRING D1T-Joan-3
15288: PPUSH
15289: CALL_OW 88
15293: GO 15342
15295: LD_INT 2
15297: DOUBLE
15298: EQUAL
15299: IFTRUE 15303
15301: GO 15318
15303: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15304: LD_EXP 42
15308: PPUSH
15309: LD_STRING D1T-Lisa-3
15311: PPUSH
15312: CALL_OW 88
15316: GO 15342
15318: LD_INT 3
15320: DOUBLE
15321: EQUAL
15322: IFTRUE 15326
15324: GO 15341
15326: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15327: LD_EXP 54
15331: PPUSH
15332: LD_STRING D1T-Con-3
15334: PPUSH
15335: CALL_OW 88
15339: GO 15342
15341: POP
// Say ( Powell , D1T-Pow-4 ) ;
15342: LD_EXP 58
15346: PPUSH
15347: LD_STRING D1T-Pow-4
15349: PPUSH
15350: CALL_OW 88
// end ; end else
15354: GO 15413
// if not FastEnd then
15356: LD_EXP 11
15360: NOT
15361: IFFALSE 15389
// begin Say ( JMM , D1T-JMM-4 ) ;
15363: LD_EXP 39
15367: PPUSH
15368: LD_STRING D1T-JMM-4
15370: PPUSH
15371: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15375: LD_EXP 58
15379: PPUSH
15380: LD_STRING D1T-Pow-5
15382: PPUSH
15383: CALL_OW 88
// end else
15387: GO 15413
// begin Say ( JMM , D1nT-JMM-1 ) ;
15389: LD_EXP 39
15393: PPUSH
15394: LD_STRING D1nT-JMM-1
15396: PPUSH
15397: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15401: LD_EXP 58
15405: PPUSH
15406: LD_STRING D1nT-Pow-1
15408: PPUSH
15409: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15413: LD_INT 35
15415: PPUSH
15416: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15420: LD_EXP 56
15424: PPUSH
15425: CALL_OW 314
15429: NOT
15430: IFFALSE 15413
// ComExitVehicle ( JMM ) ;
15432: LD_EXP 39
15436: PPUSH
15437: CALL_OW 121
// wait ( 3 ) ;
15441: LD_INT 3
15443: PPUSH
15444: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15448: LD_EXP 39
15452: PPUSH
15453: LD_INT 60
15455: PPUSH
15456: LD_INT 94
15458: PPUSH
15459: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15463: LD_EXP 39
15467: PPUSH
15468: LD_EXP 58
15472: PPUSH
15473: CALL_OW 179
// if Joan then
15477: LD_EXP 40
15481: IFFALSE 15535
// begin ComExitVehicle ( Joan ) ;
15483: LD_EXP 40
15487: PPUSH
15488: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15492: LD_EXP 40
15496: PPUSH
15497: LD_INT 35
15499: PPUSH
15500: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15504: LD_EXP 40
15508: PPUSH
15509: LD_INT 65
15511: PPUSH
15512: LD_INT 104
15514: PPUSH
15515: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15519: LD_EXP 40
15523: PPUSH
15524: LD_EXP 39
15528: PPUSH
15529: CALL_OW 179
// end else
15533: GO 15669
// if Lisa and JMMGirl = 2 then
15535: LD_EXP 42
15539: PUSH
15540: LD_EXP 7
15544: PUSH
15545: LD_INT 2
15547: EQUAL
15548: AND
15549: IFFALSE 15603
// begin ComExitVehicle ( Lisa ) ;
15551: LD_EXP 42
15555: PPUSH
15556: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15560: LD_EXP 42
15564: PPUSH
15565: LD_INT 35
15567: PPUSH
15568: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15572: LD_EXP 42
15576: PPUSH
15577: LD_INT 65
15579: PPUSH
15580: LD_INT 104
15582: PPUSH
15583: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15587: LD_EXP 42
15591: PPUSH
15592: LD_EXP 39
15596: PPUSH
15597: CALL_OW 179
// end else
15601: GO 15669
// if Connie and JMMGirl = 3 then
15603: LD_EXP 54
15607: PUSH
15608: LD_EXP 7
15612: PUSH
15613: LD_INT 3
15615: EQUAL
15616: AND
15617: IFFALSE 15669
// begin ComExitVehicle ( Connie ) ;
15619: LD_EXP 54
15623: PPUSH
15624: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15628: LD_EXP 54
15632: PPUSH
15633: LD_INT 35
15635: PPUSH
15636: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15640: LD_EXP 54
15644: PPUSH
15645: LD_INT 65
15647: PPUSH
15648: LD_INT 104
15650: PPUSH
15651: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15655: LD_EXP 54
15659: PPUSH
15660: LD_EXP 39
15664: PPUSH
15665: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15669: LD_INT 35
15671: PPUSH
15672: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15676: LD_EXP 39
15680: PPUSH
15681: LD_EXP 58
15685: PPUSH
15686: CALL_OW 296
15690: PUSH
15691: LD_INT 6
15693: LESS
15694: IFFALSE 15669
// wait ( 0 0$0.5 ) ;
15696: LD_INT 18
15698: PPUSH
15699: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15703: LD_EXP 39
15707: PPUSH
15708: LD_STRING D1-JMM-1
15710: PPUSH
15711: CALL_OW 88
// async ;
15715: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15716: LD_EXP 58
15720: PPUSH
15721: LD_STRING D1-Pow-1
15723: PPUSH
15724: CALL_OW 88
// if not dialogue_skipped then
15728: LD_OWVAR 59
15732: NOT
15733: IFFALSE 15742
// wait ( 0 0$2 ) ;
15735: LD_INT 70
15737: PPUSH
15738: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15742: LD_INT 170
15744: PPUSH
15745: LD_INT 99
15747: PPUSH
15748: LD_INT 1
15750: PPUSH
15751: LD_INT 6
15753: NEG
15754: PPUSH
15755: CALL 102096 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15759: LD_INT 174
15761: PPUSH
15762: LD_INT 115
15764: PPUSH
15765: LD_INT 1
15767: PPUSH
15768: LD_INT 6
15770: NEG
15771: PPUSH
15772: CALL 102096 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15776: LD_INT 169
15778: PPUSH
15779: LD_INT 71
15781: PPUSH
15782: LD_INT 1
15784: PPUSH
15785: LD_INT 6
15787: NEG
15788: PPUSH
15789: CALL 102096 0 4
// if not dialogue_skipped then
15793: LD_OWVAR 59
15797: NOT
15798: IFFALSE 15817
// begin CenterOnXY ( 170 , 99 ) ;
15800: LD_INT 170
15802: PPUSH
15803: LD_INT 99
15805: PPUSH
15806: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15810: LD_INT 80
15812: PPUSH
15813: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15817: LD_INT 75
15819: PPUSH
15820: LD_INT 53
15822: PPUSH
15823: LD_INT 1
15825: PPUSH
15826: LD_INT 9
15828: NEG
15829: PPUSH
15830: CALL 102096 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15834: LD_INT 54
15836: PPUSH
15837: LD_INT 42
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 9
15845: NEG
15846: PPUSH
15847: CALL 102096 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15851: LD_INT 62
15853: PPUSH
15854: LD_INT 51
15856: PPUSH
15857: LD_INT 1
15859: PPUSH
15860: LD_INT 9
15862: NEG
15863: PPUSH
15864: CALL 102096 0 4
// if not dialogue_skipped then
15868: LD_OWVAR 59
15872: NOT
15873: IFFALSE 15892
// begin CenterOnXY ( 75 , 53 ) ;
15875: LD_INT 75
15877: PPUSH
15878: LD_INT 53
15880: PPUSH
15881: CALL_OW 84
// wait ( 0 0$4 ) ;
15885: LD_INT 140
15887: PPUSH
15888: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15892: LD_EXP 58
15896: PPUSH
15897: CALL_OW 87
// if not dialogue_skipped then
15901: LD_OWVAR 59
15905: NOT
15906: IFFALSE 15915
// wait ( 0 0$2 ) ;
15908: LD_INT 70
15910: PPUSH
15911: CALL_OW 67
// sync ;
15915: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15916: LD_EXP 39
15920: PPUSH
15921: LD_STRING D1-JMM-2
15923: PPUSH
15924: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15928: LD_EXP 58
15932: PPUSH
15933: LD_STRING D1-Pow-2
15935: PPUSH
15936: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15940: LD_EXP 39
15944: PPUSH
15945: LD_STRING D1-JMM-3
15947: PPUSH
15948: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15952: LD_EXP 58
15956: PPUSH
15957: LD_STRING D1-Pow-3
15959: PPUSH
15960: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15964: LD_EXP 39
15968: PPUSH
15969: LD_STRING D1-JMM-4
15971: PPUSH
15972: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-4
15983: PPUSH
15984: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15988: LD_EXP 39
15992: PPUSH
15993: LD_STRING D1-JMM-5
15995: PPUSH
15996: CALL_OW 88
// async ;
16000: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16001: LD_EXP 58
16005: PPUSH
16006: LD_STRING D1-Pow-5
16008: PPUSH
16009: CALL_OW 88
// if not dialogue_skipped then
16013: LD_OWVAR 59
16017: NOT
16018: IFFALSE 16027
// wait ( 0 0$3.6 ) ;
16020: LD_INT 126
16022: PPUSH
16023: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16027: LD_INT 134
16029: PPUSH
16030: LD_INT 210
16032: PPUSH
16033: LD_INT 1
16035: PPUSH
16036: LD_INT 11
16038: NEG
16039: PPUSH
16040: CALL 102096 0 4
// if not dialogue_skipped then
16044: LD_OWVAR 59
16048: NOT
16049: IFFALSE 16068
// begin CenterOnXY ( 134 , 210 ) ;
16051: LD_INT 134
16053: PPUSH
16054: LD_INT 210
16056: PPUSH
16057: CALL_OW 84
// wait ( 0 0$2 ) ;
16061: LD_INT 70
16063: PPUSH
16064: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16068: LD_INT 101
16070: PPUSH
16071: LD_INT 159
16073: PPUSH
16074: LD_INT 1
16076: PPUSH
16077: LD_INT 10
16079: NEG
16080: PPUSH
16081: CALL 102096 0 4
// if not dialogue_skipped then
16085: LD_OWVAR 59
16089: NOT
16090: IFFALSE 16109
// begin CenterOnXY ( 101 , 159 ) ;
16092: LD_INT 101
16094: PPUSH
16095: LD_INT 159
16097: PPUSH
16098: CALL_OW 84
// wait ( 0 0$2 ) ;
16102: LD_INT 70
16104: PPUSH
16105: CALL_OW 67
// end ; sync ;
16109: SYNC
// CenterNowOnUnits ( Powell ) ;
16110: LD_EXP 58
16114: PPUSH
16115: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16119: LD_ADDR_VAR 0 6
16123: PUSH
16124: LD_INT 1
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: LD_INT 5
16138: PUSH
16139: LD_INT 6
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: LIST
16146: LIST
16147: LIST
16148: LIST
16149: ST_TO_ADDR
// if not dialogue_skipped then
16150: LD_OWVAR 59
16154: NOT
16155: IFFALSE 16324
// begin game_speed := 4 ;
16157: LD_ADDR_OWVAR 65
16161: PUSH
16162: LD_INT 4
16164: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16165: LD_INT 210
16167: PPUSH
16168: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16172: LD_ADDR_VAR 0 7
16176: PUSH
16177: LD_STRING Q1
16179: PPUSH
16180: LD_VAR 0 6
16184: PPUSH
16185: CALL_OW 98
16189: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16190: LD_ADDR_VAR 0 7
16194: PUSH
16195: LD_STRING Q1
16197: PPUSH
16198: LD_VAR 0 6
16202: PPUSH
16203: CALL_OW 98
16207: ST_TO_ADDR
// options = options diff dec ;
16208: LD_ADDR_VAR 0 6
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: DIFF
16223: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16224: LD_VAR 0 7
16228: PPUSH
16229: LD_VAR 0 6
16233: PPUSH
16234: CALL 17796 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16238: LD_VAR 0 7
16242: PUSH
16243: LD_INT 5
16245: PUSH
16246: LD_INT 6
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: IN
16253: PUSH
16254: LD_VAR 0 6
16258: PUSH
16259: LD_INT 2
16261: EQUAL
16262: OR
16263: IFFALSE 16190
// if not ( dec in [ 5 , 6 ] ) then
16265: LD_VAR 0 7
16269: PUSH
16270: LD_INT 5
16272: PUSH
16273: LD_INT 6
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: IN
16280: NOT
16281: IFFALSE 16324
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16283: LD_ADDR_VAR 0 7
16287: PUSH
16288: LD_STRING Q1a
16290: PPUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PPUSH
16301: CALL_OW 98
16305: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16306: LD_VAR 0 7
16310: PUSH
16311: LD_INT 4
16313: PLUS
16314: PPUSH
16315: LD_VAR 0 6
16319: PPUSH
16320: CALL 17796 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16324: LD_INT 81
16326: PPUSH
16327: LD_INT 127
16329: PPUSH
16330: CALL_OW 84
// amount := 5 ;
16334: LD_ADDR_VAR 0 8
16338: PUSH
16339: LD_INT 5
16341: ST_TO_ADDR
// macmilan_squad := [ ] ;
16342: LD_ADDR_VAR 0 9
16346: PUSH
16347: EMPTY
16348: ST_TO_ADDR
// if vip < amount then
16349: LD_EXP 59
16353: PUSH
16354: LD_VAR 0 8
16358: LESS
16359: IFFALSE 16403
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16361: LD_ADDR_VAR 0 5
16365: PUSH
16366: LD_EXP 59
16370: PUSH
16371: LD_INT 22
16373: PUSH
16374: LD_INT 4
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PPUSH
16395: CALL_OW 69
16399: UNION
16400: ST_TO_ADDR
16401: GO 16413
// tmp := vip ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_EXP 59
16412: ST_TO_ADDR
// tmp := tmp diff Powell ;
16413: LD_ADDR_VAR 0 5
16417: PUSH
16418: LD_VAR 0 5
16422: PUSH
16423: LD_EXP 58
16427: DIFF
16428: ST_TO_ADDR
// if tmp < amount then
16429: LD_VAR 0 5
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16451
// amount := tmp ;
16441: LD_ADDR_VAR 0 8
16445: PUSH
16446: LD_VAR 0 5
16450: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16451: LD_VAR 0 5
16455: PUSH
16456: LD_INT 1
16458: ARRAY
16459: PPUSH
16460: CALL_OW 257
16464: PUSH
16465: LD_INT 2
16467: NONEQUAL
16468: IFFALSE 16530
// begin if IsInUnit ( tmp [ 1 ] ) then
16470: LD_VAR 0 5
16474: PUSH
16475: LD_INT 1
16477: ARRAY
16478: PPUSH
16479: CALL_OW 310
16483: IFFALSE 16498
// ComExitBuilding ( tmp [ 1 ] ) ;
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: ARRAY
16493: PPUSH
16494: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16498: LD_VAR 0 5
16502: PUSH
16503: LD_INT 1
16505: ARRAY
16506: PPUSH
16507: LD_INT 387
16509: PPUSH
16510: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16514: LD_VAR 0 5
16518: PUSH
16519: LD_INT 1
16521: ARRAY
16522: PPUSH
16523: LD_INT 2
16525: PPUSH
16526: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16530: LD_EXP 39
16534: PPUSH
16535: LD_INT 82
16537: PPUSH
16538: LD_INT 129
16540: PPUSH
16541: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16545: LD_EXP 39
16549: PPUSH
16550: LD_EXP 58
16554: PPUSH
16555: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16559: LD_INT 22
16561: PUSH
16562: LD_INT 1
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: PPUSH
16569: CALL_OW 69
16573: PUSH
16574: LD_EXP 39
16578: DIFF
16579: PPUSH
16580: LD_INT 84
16582: PPUSH
16583: LD_INT 128
16585: PPUSH
16586: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16590: LD_INT 22
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PPUSH
16600: CALL_OW 69
16604: PUSH
16605: LD_EXP 39
16609: DIFF
16610: PPUSH
16611: LD_EXP 39
16615: PPUSH
16616: CALL_OW 179
// for i = 1 to amount do
16620: LD_ADDR_VAR 0 2
16624: PUSH
16625: DOUBLE
16626: LD_INT 1
16628: DEC
16629: ST_TO_ADDR
16630: LD_VAR 0 8
16634: PUSH
16635: FOR_TO
16636: IFFALSE 16804
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16638: LD_ADDR_VAR 0 9
16642: PUSH
16643: LD_VAR 0 9
16647: PUSH
16648: LD_VAR 0 5
16652: PUSH
16653: LD_VAR 0 2
16657: ARRAY
16658: ADD
16659: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16660: LD_VAR 0 5
16664: PUSH
16665: LD_VAR 0 2
16669: ARRAY
16670: PPUSH
16671: CALL_OW 310
16675: IFFALSE 16692
// AddComExitBuilding ( tmp [ i ] ) ;
16677: LD_VAR 0 5
16681: PUSH
16682: LD_VAR 0 2
16686: ARRAY
16687: PPUSH
16688: CALL_OW 182
// if i = 2 and JMMNewVeh then
16692: LD_VAR 0 2
16696: PUSH
16697: LD_INT 2
16699: EQUAL
16700: PUSH
16701: LD_EXP 56
16705: AND
16706: IFFALSE 16764
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16708: LD_VAR 0 5
16712: PUSH
16713: LD_VAR 0 2
16717: ARRAY
16718: PPUSH
16719: LD_EXP 56
16723: PPUSH
16724: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: PPUSH
16739: LD_INT 86
16741: PPUSH
16742: LD_INT 133
16744: PPUSH
16745: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16749: LD_VAR 0 5
16753: PUSH
16754: LD_VAR 0 2
16758: ARRAY
16759: PPUSH
16760: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 2
16773: ARRAY
16774: PPUSH
16775: LD_INT 8
16777: PPUSH
16778: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16782: LD_VAR 0 5
16786: PUSH
16787: LD_VAR 0 2
16791: ARRAY
16792: PPUSH
16793: LD_EXP 39
16797: PPUSH
16798: CALL_OW 179
// end ;
16802: GO 16635
16804: POP
16805: POP
// if GirlNewVeh then
16806: LD_EXP 57
16810: IFFALSE 16824
// SetSide ( GirlNewVeh , 4 ) ;
16812: LD_EXP 57
16816: PPUSH
16817: LD_INT 4
16819: PPUSH
16820: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16824: LD_INT 35
16826: PPUSH
16827: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16831: LD_VAR 0 9
16835: PPUSH
16836: LD_INT 95
16838: PUSH
16839: LD_INT 9
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 72
16850: PUSH
16851: LD_INT 0
16853: EQUAL
16854: PUSH
16855: LD_EXP 39
16859: PPUSH
16860: LD_INT 9
16862: PPUSH
16863: CALL_OW 308
16867: NOT
16868: AND
16869: IFFALSE 16824
// wait ( 0 0$2 ) ;
16871: LD_INT 70
16873: PPUSH
16874: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16878: LD_VAR 0 9
16882: PPUSH
16883: LD_INT 1
16885: PPUSH
16886: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16890: LD_INT 21
16892: PUSH
16893: LD_INT 2
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 92
16902: PUSH
16903: LD_INT 83
16905: PUSH
16906: LD_INT 130
16908: PUSH
16909: LD_INT 10
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PPUSH
16927: LD_INT 1
16929: PPUSH
16930: CALL_OW 235
// Video ( false ) ;
16934: LD_INT 0
16936: PPUSH
16937: CALL 102182 0 1
// ChangeMissionObjectives ( M1 ) ;
16941: LD_STRING M1
16943: PPUSH
16944: CALL_OW 337
// SaveForQuickRestart ;
16948: CALL_OW 22
// missionStart := true ;
16952: LD_ADDR_EXP 13
16956: PUSH
16957: LD_INT 1
16959: ST_TO_ADDR
// missionStage := 2 ;
16960: LD_ADDR_EXP 15
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16968: LD_INT 105
16970: PPUSH
16971: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16975: LD_ADDR_VAR 0 5
16979: PUSH
16980: LD_INT 22
16982: PUSH
16983: LD_INT 4
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 21
16992: PUSH
16993: LD_INT 1
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 69
17008: PUSH
17009: LD_EXP 58
17013: DIFF
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 5
17019: NOT
17020: IFFALSE 17035
// tmp := [ Powell ] ;
17022: LD_ADDR_VAR 0 5
17026: PUSH
17027: LD_EXP 58
17031: PUSH
17032: EMPTY
17033: LIST
17034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17035: LD_ADDR_EXP 116
17039: PUSH
17040: LD_EXP 116
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: LD_INT 22
17050: PUSH
17051: LD_INT 4
17053: PUSH
17054: EMPTY
17055: LIST
17056: LIST
17057: PUSH
17058: LD_INT 23
17060: PUSH
17061: LD_INT 1
17063: PUSH
17064: EMPTY
17065: LIST
17066: LIST
17067: PUSH
17068: LD_INT 3
17070: PUSH
17071: LD_INT 21
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: LIST
17089: PPUSH
17090: CALL_OW 69
17094: PUSH
17095: LD_EXP 58
17099: DIFF
17100: PPUSH
17101: CALL_OW 1
17105: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17106: LD_ADDR_VAR 0 4
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_INT 4
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: LD_INT 34
17123: PUSH
17124: LD_INT 12
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PUSH
17131: EMPTY
17132: LIST
17133: LIST
17134: PPUSH
17135: CALL_OW 69
17139: PUSH
17140: LD_INT 1
17142: ARRAY
17143: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17144: LD_VAR 0 5
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: CALL_OW 310
17157: IFFALSE 17172
// ComExitBuilding ( tmp [ 1 ] ) ;
17159: LD_VAR 0 5
17163: PUSH
17164: LD_INT 1
17166: ARRAY
17167: PPUSH
17168: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17172: LD_VAR 0 5
17176: PUSH
17177: LD_INT 1
17179: ARRAY
17180: PPUSH
17181: LD_VAR 0 4
17185: PPUSH
17186: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17190: LD_VAR 0 5
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: LD_INT 80
17201: PPUSH
17202: LD_INT 136
17204: PPUSH
17205: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17209: LD_VAR 0 5
17213: PUSH
17214: LD_INT 1
17216: ARRAY
17217: PPUSH
17218: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17222: LD_VAR 0 5
17226: PUSH
17227: LD_INT 1
17229: ARRAY
17230: PPUSH
17231: LD_INT 59
17233: PPUSH
17234: LD_INT 112
17236: PPUSH
17237: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17241: LD_VAR 0 5
17245: PUSH
17246: LD_INT 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17254: LD_EXP 40
17258: PUSH
17259: LD_EXP 40
17263: PPUSH
17264: CALL_OW 255
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: AND
17273: IFFALSE 17299
// begin Say ( Joan , D3W-Joan-1 ) ;
17275: LD_EXP 40
17279: PPUSH
17280: LD_STRING D3W-Joan-1
17282: PPUSH
17283: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17287: LD_EXP 39
17291: PPUSH
17292: LD_STRING D3W-JMM-1
17294: PPUSH
17295: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17299: LD_EXP 42
17303: PUSH
17304: LD_EXP 42
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: PUSH
17319: LD_EXP 42
17323: PUSH
17324: LD_EXP 59
17328: IN
17329: NOT
17330: AND
17331: IFFALSE 17357
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17333: LD_EXP 42
17337: PPUSH
17338: LD_STRING D3W-Lisa-1
17340: PPUSH
17341: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17345: LD_EXP 39
17349: PPUSH
17350: LD_STRING D3W-JMM-1
17352: PPUSH
17353: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17357: LD_EXP 54
17361: PUSH
17362: LD_EXP 54
17366: PPUSH
17367: CALL_OW 255
17371: PUSH
17372: LD_INT 1
17374: EQUAL
17375: AND
17376: IFFALSE 17402
// begin Say ( Connie , D3W-Con-1 ) ;
17378: LD_EXP 54
17382: PPUSH
17383: LD_STRING D3W-Con-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17390: LD_EXP 39
17394: PPUSH
17395: LD_STRING D3W-JMM-1
17397: PPUSH
17398: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17402: LD_EXP 42
17406: PUSH
17407: LD_EXP 59
17411: IN
17412: PUSH
17413: LD_EXP 42
17417: PPUSH
17418: CALL_OW 255
17422: PUSH
17423: LD_INT 1
17425: EQUAL
17426: AND
17427: IFFALSE 17443
// Say ( Lisa , D3nW-Lisa-1 ) else
17429: LD_EXP 42
17433: PPUSH
17434: LD_STRING D3nW-Lisa-1
17436: PPUSH
17437: CALL_OW 88
17441: GO 17687
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17443: LD_EXP 45
17447: PUSH
17448: LD_EXP 59
17452: IN
17453: PUSH
17454: LD_EXP 45
17458: PPUSH
17459: CALL_OW 255
17463: PUSH
17464: LD_INT 1
17466: EQUAL
17467: AND
17468: IFFALSE 17484
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17470: LD_EXP 45
17474: PPUSH
17475: LD_STRING D3nW-Cyrus-1
17477: PPUSH
17478: CALL_OW 88
17482: GO 17687
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17484: LD_EXP 44
17488: PUSH
17489: LD_EXP 59
17493: IN
17494: PUSH
17495: LD_EXP 44
17499: PPUSH
17500: CALL_OW 255
17504: PUSH
17505: LD_INT 1
17507: EQUAL
17508: AND
17509: IFFALSE 17525
// Say ( Bobby , D3nW-Bobby-1 ) else
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING D3nW-Bobby-1
17518: PPUSH
17519: CALL_OW 88
17523: GO 17687
// if Gary in vip and GetSide ( Gary ) = 1 then
17525: LD_EXP 51
17529: PUSH
17530: LD_EXP 59
17534: IN
17535: PUSH
17536: LD_EXP 51
17540: PPUSH
17541: CALL_OW 255
17545: PUSH
17546: LD_INT 1
17548: EQUAL
17549: AND
17550: IFFALSE 17566
// Say ( Gary , D3nW-Gary-1 ) else
17552: LD_EXP 51
17556: PPUSH
17557: LD_STRING D3nW-Gary-1
17559: PPUSH
17560: CALL_OW 88
17564: GO 17687
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17566: LD_EXP 43
17570: PUSH
17571: LD_EXP 59
17575: IN
17576: PUSH
17577: LD_EXP 43
17581: PPUSH
17582: CALL_OW 255
17586: PUSH
17587: LD_INT 1
17589: EQUAL
17590: AND
17591: IFFALSE 17607
// Say ( Donaldson , D3nW-Don-1 ) else
17593: LD_EXP 43
17597: PPUSH
17598: LD_STRING D3nW-Don-1
17600: PPUSH
17601: CALL_OW 88
17605: GO 17687
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17607: LD_EXP 50
17611: PUSH
17612: LD_EXP 59
17616: IN
17617: PUSH
17618: LD_EXP 50
17622: PPUSH
17623: CALL_OW 255
17627: PUSH
17628: LD_INT 1
17630: EQUAL
17631: AND
17632: IFFALSE 17648
// Say ( Cornel , D3nW-Corn-1 ) else
17634: LD_EXP 50
17638: PPUSH
17639: LD_STRING D3nW-Corn-1
17641: PPUSH
17642: CALL_OW 88
17646: GO 17687
// if Frank in vip and GetSide ( Frank ) = 1 then
17648: LD_EXP 52
17652: PUSH
17653: LD_EXP 59
17657: IN
17658: PUSH
17659: LD_EXP 52
17663: PPUSH
17664: CALL_OW 255
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: AND
17673: IFFALSE 17687
// Say ( Frank , D3nW-Frank-1 ) ;
17675: LD_EXP 52
17679: PPUSH
17680: LD_STRING D3nW-Frank-1
17682: PPUSH
17683: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17687: LD_EXP 59
17691: PPUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PPUSH
17702: CALL_OW 72
17706: IFFALSE 17732
// begin Say ( JMM , D3nW-JMM-1 ) ;
17708: LD_EXP 39
17712: PPUSH
17713: LD_STRING D3nW-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17720: LD_EXP 39
17724: PPUSH
17725: LD_STRING D3nW-JMM-1a
17727: PPUSH
17728: CALL_OW 88
// end ; t := 0 0$00 ;
17732: LD_ADDR_VAR 0 3
17736: PUSH
17737: LD_INT 0
17739: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17740: LD_INT 35
17742: PPUSH
17743: CALL_OW 67
// t := t + 0 0$1 ;
17747: LD_ADDR_VAR 0 3
17751: PUSH
17752: LD_VAR 0 3
17756: PUSH
17757: LD_INT 35
17759: PLUS
17760: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17761: LD_INT 59
17763: PPUSH
17764: LD_INT 112
17766: PPUSH
17767: CALL_OW 428
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 2100
17779: GREATER
17780: OR
17781: IFFALSE 17740
// activeAttacks := true ;
17783: LD_ADDR_EXP 16
17787: PUSH
17788: LD_INT 1
17790: ST_TO_ADDR
// end ;
17791: LD_VAR 0 1
17795: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17796: LD_INT 0
17798: PPUSH
// case question of 1 :
17799: LD_VAR 0 1
17803: PUSH
17804: LD_INT 1
17806: DOUBLE
17807: EQUAL
17808: IFTRUE 17812
17810: GO 17863
17812: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17813: LD_EXP 39
17817: PPUSH
17818: LD_STRING D2Mot-JMM-1
17820: PPUSH
17821: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17825: LD_EXP 58
17829: PPUSH
17830: LD_STRING D2Mot-Pow-1
17832: PPUSH
17833: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17837: LD_EXP 39
17841: PPUSH
17842: LD_STRING D2Mot-JMM-2
17844: PPUSH
17845: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17849: LD_EXP 58
17853: PPUSH
17854: LD_STRING D2Mot-Pow-2
17856: PPUSH
17857: CALL_OW 88
// end ; 2 :
17861: GO 18214
17863: LD_INT 2
17865: DOUBLE
17866: EQUAL
17867: IFTRUE 17871
17869: GO 17947
17871: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17872: LD_EXP 39
17876: PPUSH
17877: LD_STRING D2Rus-JMM-1
17879: PPUSH
17880: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17884: LD_EXP 58
17888: PPUSH
17889: LD_STRING D2Rus-Pow-1
17891: PPUSH
17892: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17896: LD_EXP 39
17900: PPUSH
17901: LD_STRING D2Rus-JMM-2
17903: PPUSH
17904: CALL_OW 88
// if not ( 3 in list_of_q ) then
17908: LD_INT 3
17910: PUSH
17911: LD_VAR 0 2
17915: IN
17916: NOT
17917: IFFALSE 17933
// Say ( Powell , D2Rus-Pow-2 ) else
17919: LD_EXP 58
17923: PPUSH
17924: LD_STRING D2Rus-Pow-2
17926: PPUSH
17927: CALL_OW 88
17931: GO 17945
// Say ( Powell , D2Rus-Pow-2a ) ;
17933: LD_EXP 58
17937: PPUSH
17938: LD_STRING D2Rus-Pow-2a
17940: PPUSH
17941: CALL_OW 88
// end ; 3 :
17945: GO 18214
17947: LD_INT 3
17949: DOUBLE
17950: EQUAL
17951: IFTRUE 17955
17953: GO 18040
17955: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17956: LD_EXP 39
17960: PPUSH
17961: LD_STRING D2Leg-JMM-1
17963: PPUSH
17964: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17968: LD_EXP 58
17972: PPUSH
17973: LD_STRING D2Leg-Pow-1
17975: PPUSH
17976: CALL_OW 88
// if 2 in list_of_q then
17980: LD_INT 2
17982: PUSH
17983: LD_VAR 0 2
17987: IN
17988: IFFALSE 18014
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17990: LD_EXP 39
17994: PPUSH
17995: LD_STRING D2Leg-JMM-2
17997: PPUSH
17998: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18002: LD_EXP 58
18006: PPUSH
18007: LD_STRING D2Leg-Pow-2
18009: PPUSH
18010: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18014: LD_EXP 39
18018: PPUSH
18019: LD_STRING D2Leg-JMM-3
18021: PPUSH
18022: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18026: LD_EXP 58
18030: PPUSH
18031: LD_STRING D2Leg-Pow-3
18033: PPUSH
18034: CALL_OW 88
// end ; 4 :
18038: GO 18214
18040: LD_INT 4
18042: DOUBLE
18043: EQUAL
18044: IFTRUE 18048
18046: GO 18123
18048: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18049: LD_EXP 39
18053: PPUSH
18054: LD_STRING D2Ar-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18061: LD_EXP 58
18065: PPUSH
18066: LD_STRING D2Ar-Pow-1
18068: PPUSH
18069: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18073: LD_EXP 39
18077: PPUSH
18078: LD_STRING D2Ar-JMM-2
18080: PPUSH
18081: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18085: LD_EXP 58
18089: PPUSH
18090: LD_STRING D2Ar-Pow-2
18092: PPUSH
18093: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18097: LD_EXP 39
18101: PPUSH
18102: LD_STRING D2Ar-JMM-3
18104: PPUSH
18105: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18109: LD_EXP 58
18113: PPUSH
18114: LD_STRING D2Ar-Pow-3
18116: PPUSH
18117: CALL_OW 88
// end ; 5 :
18121: GO 18214
18123: LD_INT 5
18125: DOUBLE
18126: EQUAL
18127: IFTRUE 18131
18129: GO 18146
18131: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18132: LD_EXP 39
18136: PPUSH
18137: LD_STRING D2Conf-JMM-1
18139: PPUSH
18140: CALL_OW 88
18144: GO 18214
18146: LD_INT 6
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18213
18154: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18155: LD_EXP 39
18159: PPUSH
18160: LD_STRING D2Com-JMM-1
18162: PPUSH
18163: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18167: LD_EXP 58
18171: PPUSH
18172: LD_STRING D2Com-Pow-1
18174: PPUSH
18175: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18179: LD_EXP 39
18183: PPUSH
18184: LD_STRING D2Com-JMM-2
18186: PPUSH
18187: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18191: LD_EXP 58
18195: PPUSH
18196: LD_STRING D2Com-Pow-2
18198: PPUSH
18199: CALL_OW 88
// powellAngerQuery := true ;
18203: LD_ADDR_EXP 36
18207: PUSH
18208: LD_INT 1
18210: ST_TO_ADDR
// end ; end ;
18211: GO 18214
18213: POP
// end ;
18214: LD_VAR 0 3
18218: RET
// every 0 0$5 trigger missionStart do var tmp ;
18219: LD_EXP 13
18223: IFFALSE 18506
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18231: LD_INT 35
18233: PPUSH
18234: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18238: LD_INT 14
18240: PPUSH
18241: LD_INT 22
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PPUSH
18251: CALL_OW 70
18255: PUSH
18256: LD_EXP 15
18260: PUSH
18261: LD_INT 2
18263: PUSH
18264: LD_INT 3
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: AND
18280: IFFALSE 18496
// begin powellAnger := powellAnger + 1 ;
18282: LD_ADDR_EXP 17
18286: PUSH
18287: LD_EXP 17
18291: PUSH
18292: LD_INT 1
18294: PLUS
18295: ST_TO_ADDR
// Video ( true ) ;
18296: LD_INT 1
18298: PPUSH
18299: CALL 102182 0 1
// CenterNowOnUnits ( tmp ) ;
18303: LD_VAR 0 1
18307: PPUSH
18308: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18312: LD_INT 14
18314: PPUSH
18315: LD_INT 22
18317: PUSH
18318: LD_INT 1
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 70
18329: PPUSH
18330: LD_INT 86
18332: PPUSH
18333: LD_INT 133
18335: PPUSH
18336: CALL_OW 111
// async ;
18340: ASYNC
// case powellAnger of 1 :
18341: LD_EXP 17
18345: PUSH
18346: LD_INT 1
18348: DOUBLE
18349: EQUAL
18350: IFTRUE 18354
18352: GO 18369
18354: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18355: LD_EXP 58
18359: PPUSH
18360: LD_STRING DBack1-Pow-1
18362: PPUSH
18363: CALL_OW 88
18367: GO 18416
18369: LD_INT 2
18371: DOUBLE
18372: EQUAL
18373: IFTRUE 18377
18375: GO 18392
18377: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18378: LD_EXP 58
18382: PPUSH
18383: LD_STRING DBack2-Pow-1
18385: PPUSH
18386: CALL_OW 88
18390: GO 18416
18392: LD_INT 3
18394: DOUBLE
18395: EQUAL
18396: IFTRUE 18400
18398: GO 18415
18400: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18401: LD_EXP 58
18405: PPUSH
18406: LD_STRING DBack3-Pow-1
18408: PPUSH
18409: CALL_OW 88
18413: GO 18416
18415: POP
// sync ;
18416: SYNC
// repeat wait ( 0 0$1 ) ;
18417: LD_INT 35
18419: PPUSH
18420: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18424: LD_INT 14
18426: PPUSH
18427: LD_INT 22
18429: PUSH
18430: LD_INT 1
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PPUSH
18437: CALL_OW 70
18441: PPUSH
18442: LD_INT 86
18444: PPUSH
18445: LD_INT 133
18447: PPUSH
18448: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18452: LD_INT 14
18454: PPUSH
18455: LD_INT 22
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PPUSH
18465: CALL_OW 70
18469: NOT
18470: IFFALSE 18417
// if powellAnger >= 3 then
18472: LD_EXP 17
18476: PUSH
18477: LD_INT 3
18479: GREATEREQUAL
18480: IFFALSE 18489
// YouLost ( Dismissed ) ;
18482: LD_STRING Dismissed
18484: PPUSH
18485: CALL_OW 104
// Video ( false ) ;
18489: LD_INT 0
18491: PPUSH
18492: CALL 102182 0 1
// end ; until missionStage > 5 ;
18496: LD_EXP 15
18500: PUSH
18501: LD_INT 5
18503: GREATER
18504: IFFALSE 18231
// end ;
18506: PPOPN 1
18508: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18509: LD_EXP 13
18513: PUSH
18514: LD_INT 22
18516: PUSH
18517: LD_INT 4
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: PUSH
18524: LD_INT 21
18526: PUSH
18527: LD_INT 2
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PPUSH
18538: CALL_OW 69
18542: PUSH
18543: LD_INT 4
18545: GREATEREQUAL
18546: AND
18547: PUSH
18548: LD_EXP 15
18552: PUSH
18553: LD_INT 2
18555: EQUAL
18556: AND
18557: IFFALSE 20380
18559: GO 18561
18561: DISABLE
18562: LD_INT 0
18564: PPUSH
18565: PPUSH
18566: PPUSH
18567: PPUSH
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// begin missionStage := 3 ;
18572: LD_ADDR_EXP 15
18576: PUSH
18577: LD_INT 3
18579: ST_TO_ADDR
// retreat := false ;
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_INT 0
18587: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18588: LD_ADDR_VAR 0 5
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 4
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PPUSH
18617: CALL_OW 69
18621: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18622: LD_ADDR_VAR 0 6
18626: PUSH
18627: LD_INT 22
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 5
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: ST_TO_ADDR
// if not bar then
18656: LD_VAR 0 6
18660: NOT
18661: IFFALSE 18714
// begin repeat wait ( 0 0$1 ) ;
18663: LD_INT 35
18665: PPUSH
18666: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18670: LD_INT 22
18672: PUSH
18673: LD_INT 4
18675: PUSH
18676: EMPTY
18677: LIST
18678: LIST
18679: PUSH
18680: LD_INT 3
18682: PUSH
18683: LD_INT 57
18685: PUSH
18686: EMPTY
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 30
18695: PUSH
18696: LD_INT 5
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PUSH
18703: EMPTY
18704: LIST
18705: LIST
18706: LIST
18707: PPUSH
18708: CALL_OW 69
18712: IFFALSE 18663
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18714: LD_ADDR_VAR 0 6
18718: PUSH
18719: LD_INT 22
18721: PUSH
18722: LD_INT 4
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 30
18731: PUSH
18732: LD_INT 5
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: PUSH
18739: EMPTY
18740: LIST
18741: LIST
18742: PPUSH
18743: CALL_OW 69
18747: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18748: LD_INT 35
18750: PPUSH
18751: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18755: LD_EXP 135
18759: PUSH
18760: LD_INT 4
18762: ARRAY
18763: PUSH
18764: LD_INT 4
18766: GREATEREQUAL
18767: IFFALSE 18748
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18769: LD_ADDR_VAR 0 2
18773: PUSH
18774: LD_INT 22
18776: PUSH
18777: LD_INT 4
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PUSH
18784: LD_INT 2
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 1
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: LD_INT 25
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: LD_INT 25
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PUSH
18817: LD_INT 25
18819: PUSH
18820: LD_INT 4
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PUSH
18827: LD_INT 25
18829: PUSH
18830: LD_INT 5
18832: PUSH
18833: EMPTY
18834: LIST
18835: LIST
18836: PUSH
18837: EMPTY
18838: LIST
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PPUSH
18849: CALL_OW 69
18853: PUSH
18854: LD_EXP 58
18858: PUSH
18859: LD_EXP 59
18863: ADD
18864: DIFF
18865: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_VAR 0 2
18875: PPUSH
18876: LD_INT 26
18878: PUSH
18879: LD_INT 1
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PPUSH
18886: CALL_OW 72
18890: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18891: LD_ADDR_VAR 0 2
18895: PUSH
18896: LD_VAR 0 2
18900: PUSH
18901: LD_VAR 0 3
18905: DIFF
18906: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18907: LD_ADDR_VAR 0 2
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: LD_INT 1
18919: PPUSH
18920: CALL 100716 0 2
18924: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18925: LD_ADDR_VAR 0 3
18929: PUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: CALL 100716 0 2
18942: ST_TO_ADDR
// for i = 1 to 4 do
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: DOUBLE
18949: LD_INT 1
18951: DEC
18952: ST_TO_ADDR
18953: LD_INT 4
18955: PUSH
18956: FOR_TO
18957: IFFALSE 19123
// begin if tmp2 then
18959: LD_VAR 0 3
18963: IFFALSE 19044
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18965: LD_ADDR_EXP 18
18969: PUSH
18970: LD_EXP 18
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: LD_EXP 18
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PUSH
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 3
18996: ARRAY
18997: ADD
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19004: LD_VAR 0 3
19008: PUSH
19009: LD_VAR 0 3
19013: ARRAY
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19022: LD_ADDR_VAR 0 3
19026: PUSH
19027: LD_VAR 0 3
19031: PPUSH
19032: LD_VAR 0 3
19036: PPUSH
19037: CALL_OW 3
19041: ST_TO_ADDR
// end else
19042: GO 19121
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19044: LD_ADDR_EXP 18
19048: PUSH
19049: LD_EXP 18
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: LD_EXP 18
19061: PUSH
19062: LD_INT 1
19064: ARRAY
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 2
19075: ARRAY
19076: ADD
19077: PPUSH
19078: CALL_OW 1
19082: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19083: LD_VAR 0 2
19087: PUSH
19088: LD_VAR 0 2
19092: ARRAY
19093: PPUSH
19094: LD_INT 1
19096: PPUSH
19097: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19101: LD_ADDR_VAR 0 2
19105: PUSH
19106: LD_VAR 0 2
19110: PPUSH
19111: LD_VAR 0 2
19115: PPUSH
19116: CALL_OW 3
19120: ST_TO_ADDR
// end ; end ;
19121: GO 18956
19123: POP
19124: POP
// if tmp2 then
19125: LD_VAR 0 3
19129: IFFALSE 19147
// tmp := tmp union tmp2 ;
19131: LD_ADDR_VAR 0 2
19135: PUSH
19136: LD_VAR 0 2
19140: PUSH
19141: LD_VAR 0 3
19145: UNION
19146: ST_TO_ADDR
// for i = 1 to 4 do
19147: LD_ADDR_VAR 0 1
19151: PUSH
19152: DOUBLE
19153: LD_INT 1
19155: DEC
19156: ST_TO_ADDR
19157: LD_INT 4
19159: PUSH
19160: FOR_TO
19161: IFFALSE 19210
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19163: LD_ADDR_EXP 18
19167: PUSH
19168: LD_EXP 18
19172: PPUSH
19173: LD_INT 2
19175: PPUSH
19176: LD_EXP 18
19180: PUSH
19181: LD_INT 2
19183: ARRAY
19184: PUSH
19185: LD_VAR 0 2
19189: PUSH
19190: LD_VAR 0 2
19194: PUSH
19195: LD_VAR 0 1
19199: MINUS
19200: ARRAY
19201: ADD
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
19208: GO 19160
19210: POP
19211: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19212: LD_ADDR_EXP 116
19216: PUSH
19217: LD_EXP 116
19221: PPUSH
19222: LD_INT 4
19224: PPUSH
19225: LD_EXP 116
19229: PUSH
19230: LD_INT 4
19232: ARRAY
19233: PUSH
19234: LD_EXP 18
19238: PUSH
19239: LD_INT 1
19241: ARRAY
19242: DIFF
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19249: LD_VAR 0 5
19253: PUSH
19254: LD_INT 1
19256: ARRAY
19257: PPUSH
19258: CALL_OW 313
19262: IFFALSE 19317
// begin for i in UnitsInside ( arm [ 1 ] ) do
19264: LD_ADDR_VAR 0 1
19268: PUSH
19269: LD_VAR 0 5
19273: PUSH
19274: LD_INT 1
19276: ARRAY
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: FOR_IN
19284: IFFALSE 19315
// begin ComExitBuilding ( i ) ;
19286: LD_VAR 0 1
19290: PPUSH
19291: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 6
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 180
// end ;
19313: GO 19283
19315: POP
19316: POP
// end ; wait ( 0 0$3 ) ;
19317: LD_INT 105
19319: PPUSH
19320: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19324: LD_ADDR_VAR 0 1
19328: PUSH
19329: LD_EXP 18
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19446
// begin if IsInUnit ( i ) then
19341: LD_VAR 0 1
19345: PPUSH
19346: CALL_OW 310
19350: IFFALSE 19361
// ComExitBuilding ( i ) ;
19352: LD_VAR 0 1
19356: PPUSH
19357: CALL_OW 122
// if GetClass ( i ) <> 1 then
19361: LD_VAR 0 1
19365: PPUSH
19366: CALL_OW 257
19370: PUSH
19371: LD_INT 1
19373: NONEQUAL
19374: IFFALSE 19415
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19376: LD_VAR 0 1
19380: PPUSH
19381: LD_VAR 0 5
19385: PUSH
19386: LD_INT 1
19388: ARRAY
19389: PPUSH
19390: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19394: LD_VAR 0 1
19398: PPUSH
19399: LD_INT 1
19401: PPUSH
19402: CALL_OW 183
// AddComExitBuilding ( i ) ;
19406: LD_VAR 0 1
19410: PPUSH
19411: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19415: LD_VAR 0 1
19419: PPUSH
19420: LD_INT 60
19422: PPUSH
19423: LD_INT 94
19425: PPUSH
19426: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_EXP 58
19439: PPUSH
19440: CALL_OW 179
// end ;
19444: GO 19338
19446: POP
19447: POP
// wait ( 0 0$15 ) ;
19448: LD_INT 525
19450: PPUSH
19451: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19455: LD_EXP 58
19459: PPUSH
19460: LD_STRING D4-Pow-1
19462: PPUSH
19463: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19467: LD_ADDR_VAR 0 2
19471: PUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PPUSH
19481: LD_INT 26
19483: PUSH
19484: LD_INT 1
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PPUSH
19491: CALL_OW 72
19495: ST_TO_ADDR
// if tmp then
19496: LD_VAR 0 2
19500: IFFALSE 19518
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19502: LD_VAR 0 2
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_STRING D4-Sol1-1
19513: PPUSH
19514: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19518: LD_EXP 58
19522: PPUSH
19523: LD_STRING D4-Pow-2
19525: PPUSH
19526: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19530: LD_ADDR_VAR 0 1
19534: PUSH
19535: DOUBLE
19536: LD_INT 1
19538: DEC
19539: ST_TO_ADDR
19540: LD_EXP 18
19544: PUSH
19545: LD_INT 1
19547: ARRAY
19548: PUSH
19549: FOR_TO
19550: IFFALSE 19643
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PUSH
19561: LD_VAR 0 1
19565: ARRAY
19566: PPUSH
19567: LD_EXP 135
19571: PUSH
19572: LD_INT 4
19574: ARRAY
19575: PUSH
19576: LD_INT 1
19578: ARRAY
19579: PPUSH
19580: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19584: LD_ADDR_EXP 135
19588: PUSH
19589: LD_EXP 135
19593: PPUSH
19594: LD_INT 4
19596: PPUSH
19597: LD_EXP 135
19601: PUSH
19602: LD_INT 4
19604: ARRAY
19605: PPUSH
19606: LD_INT 1
19608: PPUSH
19609: CALL_OW 3
19613: PPUSH
19614: CALL_OW 1
19618: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19619: LD_INT 8
19621: PPUSH
19622: LD_EXP 18
19626: PUSH
19627: LD_INT 1
19629: ARRAY
19630: PUSH
19631: LD_VAR 0 1
19635: ARRAY
19636: PPUSH
19637: CALL_OW 471
// end ;
19641: GO 19549
19643: POP
19644: POP
// repeat wait ( 0 0$1 ) ;
19645: LD_INT 35
19647: PPUSH
19648: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 55
19663: PUSH
19664: EMPTY
19665: LIST
19666: PPUSH
19667: CALL_OW 72
19671: PUSH
19672: LD_INT 4
19674: GREATEREQUAL
19675: IFFALSE 19645
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19677: LD_EXP 18
19681: PUSH
19682: LD_INT 1
19684: ARRAY
19685: PPUSH
19686: LD_INT 69
19688: PPUSH
19689: LD_INT 94
19691: PPUSH
19692: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19696: LD_EXP 18
19700: PUSH
19701: LD_INT 1
19703: ARRAY
19704: PPUSH
19705: LD_INT 82
19707: PPUSH
19708: LD_INT 83
19710: PPUSH
19711: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19715: LD_EXP 18
19719: PUSH
19720: LD_INT 1
19722: ARRAY
19723: PPUSH
19724: LD_INT 77
19726: PPUSH
19727: LD_INT 69
19729: PPUSH
19730: CALL_OW 174
// repeat wait ( 3 ) ;
19734: LD_INT 3
19736: PPUSH
19737: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19741: LD_ADDR_VAR 0 1
19745: PUSH
19746: LD_EXP 18
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: PUSH
19755: FOR_IN
19756: IFFALSE 19892
// begin if GetLives ( i ) < 990 then
19758: LD_VAR 0 1
19762: PPUSH
19763: CALL_OW 256
19767: PUSH
19768: LD_INT 990
19770: LESS
19771: IFFALSE 19785
// SetLives ( i , 1000 ) ;
19773: LD_VAR 0 1
19777: PPUSH
19778: LD_INT 1000
19780: PPUSH
19781: CALL_OW 234
// if not IsInUnit ( i ) then
19785: LD_VAR 0 1
19789: PPUSH
19790: CALL_OW 310
19794: NOT
19795: IFFALSE 19890
// begin if not HasTask ( i ) then
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 314
19806: NOT
19807: IFFALSE 19824
// ComMoveXY ( i , 64 , 93 ) ;
19809: LD_VAR 0 1
19813: PPUSH
19814: LD_INT 64
19816: PPUSH
19817: LD_INT 93
19819: PPUSH
19820: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19824: LD_VAR 0 4
19828: NOT
19829: PUSH
19830: LD_VAR 0 1
19834: PPUSH
19835: CALL_OW 258
19839: PUSH
19840: LD_INT 1
19842: EQUAL
19843: AND
19844: IFFALSE 19890
// begin retreat := true ;
19846: LD_ADDR_VAR 0 4
19850: PUSH
19851: LD_INT 1
19853: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19854: LD_VAR 0 1
19858: PPUSH
19859: LD_INT 2
19861: PPUSH
19862: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19866: LD_VAR 0 1
19870: PPUSH
19871: LD_STRING D4a-Sol1-1
19873: PPUSH
19874: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19878: LD_EXP 58
19882: PPUSH
19883: LD_STRING D4a-Pow-1
19885: PPUSH
19886: CALL_OW 88
// end ; end ; end ;
19890: GO 19755
19892: POP
19893: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19894: LD_EXP 18
19898: PUSH
19899: LD_INT 1
19901: ARRAY
19902: PPUSH
19903: LD_INT 95
19905: PUSH
19906: LD_INT 9
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 3
19915: PUSH
19916: LD_INT 55
19918: PUSH
19919: EMPTY
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PPUSH
19930: CALL_OW 72
19934: PUSH
19935: LD_INT 4
19937: GREATEREQUAL
19938: IFFALSE 19734
// for i in powellSquadAttack [ 1 ] do
19940: LD_ADDR_VAR 0 1
19944: PUSH
19945: LD_EXP 18
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PUSH
19954: FOR_IN
19955: IFFALSE 20091
// begin if GetTag ( i ) = 2 then
19957: LD_VAR 0 1
19961: PPUSH
19962: CALL_OW 110
19966: PUSH
19967: LD_INT 2
19969: EQUAL
19970: IFFALSE 20032
// begin ComMoveXY ( i , 60 , 94 ) ;
19972: LD_VAR 0 1
19976: PPUSH
19977: LD_INT 60
19979: PPUSH
19980: LD_INT 94
19982: PPUSH
19983: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19987: LD_VAR 0 1
19991: PPUSH
19992: LD_EXP 58
19996: PPUSH
19997: CALL_OW 179
// wait ( 0 0$3 ) ;
20001: LD_INT 105
20003: PPUSH
20004: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20008: LD_VAR 0 1
20012: PPUSH
20013: LD_STRING D4a-Sol1-2
20015: PPUSH
20016: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20020: LD_EXP 58
20024: PPUSH
20025: LD_STRING D4a-Pow-2
20027: PPUSH
20028: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20032: LD_VAR 0 1
20036: PPUSH
20037: LD_INT 0
20039: PPUSH
20040: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20044: LD_ADDR_EXP 116
20048: PUSH
20049: LD_EXP 116
20053: PPUSH
20054: LD_INT 4
20056: PPUSH
20057: LD_EXP 116
20061: PUSH
20062: LD_INT 4
20064: ARRAY
20065: PUSH
20066: LD_VAR 0 1
20070: UNION
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20077: LD_INT 8
20079: PPUSH
20080: LD_VAR 0 1
20084: PPUSH
20085: CALL_OW 472
// end ;
20089: GO 19954
20091: POP
20092: POP
// wait ( 4 4$00 ) ;
20093: LD_INT 8400
20095: PPUSH
20096: CALL_OW 67
// uc_side := 6 ;
20100: LD_ADDR_OWVAR 20
20104: PUSH
20105: LD_INT 6
20107: ST_TO_ADDR
// uc_nation := 3 ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 3
20115: ST_TO_ADDR
// ru := [ ] ;
20116: LD_ADDR_VAR 0 7
20120: PUSH
20121: EMPTY
20122: ST_TO_ADDR
// for i = 1 to 4 do
20123: LD_ADDR_VAR 0 1
20127: PUSH
20128: DOUBLE
20129: LD_INT 1
20131: DEC
20132: ST_TO_ADDR
20133: LD_INT 4
20135: PUSH
20136: FOR_TO
20137: IFFALSE 20238
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20139: LD_INT 22
20141: PPUSH
20142: LD_INT 1
20144: PPUSH
20145: LD_INT 3
20147: PPUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_INT 2
20163: PPUSH
20164: CALL_OW 12
20168: ARRAY
20169: PPUSH
20170: LD_INT 89
20172: PPUSH
20173: CALL 70336 0 5
// un := CreateVehicle ;
20177: LD_ADDR_VAR 0 8
20181: PUSH
20182: CALL_OW 45
20186: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20187: LD_VAR 0 8
20191: PPUSH
20192: LD_INT 4
20194: PPUSH
20195: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20199: LD_VAR 0 8
20203: PPUSH
20204: LD_INT 136
20206: PPUSH
20207: LD_INT 90
20209: PPUSH
20210: LD_INT 8
20212: PPUSH
20213: LD_INT 0
20215: PPUSH
20216: CALL_OW 50
// ru := ru ^ un ;
20220: LD_ADDR_VAR 0 7
20224: PUSH
20225: LD_VAR 0 7
20229: PUSH
20230: LD_VAR 0 8
20234: ADD
20235: ST_TO_ADDR
// end ;
20236: GO 20136
20238: POP
20239: POP
// if ru then
20240: LD_VAR 0 7
20244: IFFALSE 20261
// ComAgressiveMove ( ru , 80 , 92 ) ;
20246: LD_VAR 0 7
20250: PPUSH
20251: LD_INT 80
20253: PPUSH
20254: LD_INT 92
20256: PPUSH
20257: CALL_OW 114
// wait ( 8 8$00 ) ;
20261: LD_INT 16800
20263: PPUSH
20264: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20268: LD_INT 4
20270: PPUSH
20271: LD_INT 3
20273: PUSH
20274: LD_INT 1
20276: PUSH
20277: LD_INT 1
20279: PUSH
20280: LD_INT 5
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: LIST
20287: LIST
20288: PUSH
20289: LD_INT 4
20291: PUSH
20292: LD_INT 1
20294: PUSH
20295: LD_INT 1
20297: PUSH
20298: LD_INT 6
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 4
20309: PUSH
20310: LD_INT 1
20312: PUSH
20313: LD_INT 1
20315: PUSH
20316: LD_INT 7
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: PUSH
20325: LD_INT 3
20327: PUSH
20328: LD_INT 1
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: LD_INT 7
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PUSH
20343: LD_INT 3
20345: PUSH
20346: LD_INT 1
20348: PUSH
20349: LD_INT 1
20351: PUSH
20352: LD_INT 5
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: LIST
20366: LIST
20367: PPUSH
20368: CALL 59027 0 2
// missionStage := 4 ;
20372: LD_ADDR_EXP 15
20376: PUSH
20377: LD_INT 4
20379: ST_TO_ADDR
// end ;
20380: PPOPN 8
20382: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20383: LD_EXP 15
20387: PUSH
20388: LD_INT 4
20390: EQUAL
20391: PUSH
20392: LD_INT 22
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 21
20404: PUSH
20405: LD_INT 2
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: PPUSH
20416: CALL_OW 69
20420: PUSH
20421: LD_INT 5
20423: GREATEREQUAL
20424: AND
20425: IFFALSE 24530
20427: GO 20429
20429: DISABLE
20430: LD_INT 0
20432: PPUSH
20433: PPUSH
20434: PPUSH
20435: PPUSH
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin missionStage := 5 ;
20445: LD_ADDR_EXP 15
20449: PUSH
20450: LD_INT 5
20452: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20453: LD_ADDR_VAR 0 10
20457: PUSH
20458: LD_INT 22
20460: PUSH
20461: LD_INT 4
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 30
20473: PUSH
20474: LD_INT 4
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 30
20483: PUSH
20484: LD_INT 5
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: LIST
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 69
20504: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20505: LD_ADDR_VAR 0 6
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 4
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: LD_INT 21
20522: PUSH
20523: LD_INT 1
20525: PUSH
20526: EMPTY
20527: LIST
20528: LIST
20529: PUSH
20530: LD_INT 3
20532: PUSH
20533: LD_INT 25
20535: PUSH
20536: LD_INT 16
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: PUSH
20547: LD_INT 3
20549: PUSH
20550: LD_INT 25
20552: PUSH
20553: LD_INT 12
20555: PUSH
20556: EMPTY
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_EXP 58
20579: DIFF
20580: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20581: LD_ADDR_VAR 0 9
20585: PUSH
20586: LD_INT 22
20588: PUSH
20589: LD_INT 4
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PPUSH
20610: CALL_OW 69
20614: PUSH
20615: LD_INT 1
20617: ARRAY
20618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20619: LD_INT 35
20621: PPUSH
20622: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20626: LD_EXP 135
20630: PUSH
20631: LD_INT 4
20633: ARRAY
20634: PUSH
20635: LD_INT 5
20637: GREATEREQUAL
20638: PUSH
20639: LD_EXP 135
20643: PUSH
20644: LD_INT 4
20646: ARRAY
20647: PPUSH
20648: LD_INT 58
20650: PUSH
20651: EMPTY
20652: LIST
20653: PPUSH
20654: CALL_OW 72
20658: PUSH
20659: LD_INT 5
20661: GREATEREQUAL
20662: AND
20663: IFFALSE 20619
// powellAllowRetreat := false ;
20665: LD_ADDR_EXP 19
20669: PUSH
20670: LD_INT 0
20672: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20673: LD_INT 700
20675: PPUSH
20676: CALL_OW 67
// activeAttacks := false ;
20680: LD_ADDR_EXP 16
20684: PUSH
20685: LD_INT 0
20687: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20688: LD_INT 35
20690: PPUSH
20691: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20695: LD_INT 22
20697: PUSH
20698: LD_INT 6
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: PUSH
20710: LD_INT 0
20712: EQUAL
20713: IFFALSE 20688
// tmp := mc_vehicles [ 4 ] ;
20715: LD_ADDR_VAR 0 3
20719: PUSH
20720: LD_EXP 135
20724: PUSH
20725: LD_INT 4
20727: ARRAY
20728: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20729: LD_ADDR_VAR 0 1
20733: PUSH
20734: DOUBLE
20735: LD_INT 1
20737: DEC
20738: ST_TO_ADDR
20739: LD_EXP 18
20743: PUSH
20744: FOR_TO
20745: IFFALSE 21006
// begin for j in powellSquadAttack [ i ] do
20747: LD_ADDR_VAR 0 2
20751: PUSH
20752: LD_EXP 18
20756: PUSH
20757: LD_VAR 0 1
20761: ARRAY
20762: PUSH
20763: FOR_IN
20764: IFFALSE 21002
// begin forces := forces diff j ;
20766: LD_ADDR_VAR 0 6
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_VAR 0 2
20780: DIFF
20781: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20782: LD_VAR 0 2
20786: PPUSH
20787: LD_INT 1
20789: PPUSH
20790: CALL_OW 109
// wait ( 0 0$2 ) ;
20794: LD_INT 70
20796: PPUSH
20797: CALL_OW 67
// if IsInUnit ( j ) then
20801: LD_VAR 0 2
20805: PPUSH
20806: CALL_OW 310
20810: IFFALSE 20821
// ComExitBuilding ( j ) ;
20812: LD_VAR 0 2
20816: PPUSH
20817: CALL_OW 122
// if GetClass ( j ) <> 1 then
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 257
20830: PUSH
20831: LD_INT 1
20833: NONEQUAL
20834: IFFALSE 20914
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20836: LD_VAR 0 10
20840: PUSH
20841: LD_INT 1
20843: ARRAY
20844: PPUSH
20845: CALL_OW 313
20849: PUSH
20850: LD_INT 5
20852: GREATEREQUAL
20853: IFFALSE 20875
// AddComEnterUnit ( j , arm [ 2 ] ) else
20855: LD_VAR 0 2
20859: PPUSH
20860: LD_VAR 0 10
20864: PUSH
20865: LD_INT 2
20867: ARRAY
20868: PPUSH
20869: CALL_OW 180
20873: GO 20893
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20875: LD_VAR 0 2
20879: PPUSH
20880: LD_VAR 0 10
20884: PUSH
20885: LD_INT 1
20887: ARRAY
20888: PPUSH
20889: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 183
// AddComExitBuilding ( j ) ;
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 182
// end ; if i = 2 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 2
20921: EQUAL
20922: IFFALSE 20939
// AddComMoveXY ( j , 61 , 93 ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_INT 61
20931: PPUSH
20932: LD_INT 93
20934: PPUSH
20935: CALL_OW 171
// if i = 1 then
20939: LD_VAR 0 1
20943: PUSH
20944: LD_INT 1
20946: EQUAL
20947: IFFALSE 21000
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20949: LD_VAR 0 2
20953: PPUSH
20954: LD_VAR 0 3
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_VAR 0 3
20976: PPUSH
20977: LD_INT 1
20979: PPUSH
20980: CALL_OW 3
20984: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: LD_INT 69
20992: PPUSH
20993: LD_INT 94
20995: PPUSH
20996: CALL_OW 171
// end ; end ;
21000: GO 20763
21002: POP
21003: POP
// end ;
21004: GO 20744
21006: POP
21007: POP
// wait ( 0 0$55 ) ;
21008: LD_INT 1925
21010: PPUSH
21011: CALL_OW 67
// MC_Kill ( 4 ) ;
21015: LD_INT 4
21017: PPUSH
21018: CALL 35398 0 1
// tmp := UnitsInside ( fac ) ;
21022: LD_ADDR_VAR 0 3
21026: PUSH
21027: LD_VAR 0 9
21031: PPUSH
21032: CALL_OW 313
21036: ST_TO_ADDR
// if tmp then
21037: LD_VAR 0 3
21041: IFFALSE 21162
// for i in tmp do
21043: LD_ADDR_VAR 0 1
21047: PUSH
21048: LD_VAR 0 3
21052: PUSH
21053: FOR_IN
21054: IFFALSE 21160
// begin ComExitBuilding ( i ) ;
21056: LD_VAR 0 1
21060: PPUSH
21061: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21065: LD_VAR 0 10
21069: PUSH
21070: LD_INT 2
21072: ARRAY
21073: PPUSH
21074: CALL_OW 313
21078: PUSH
21079: LD_INT 6
21081: LESS
21082: IFFALSE 21104
// AddComEnterUnit ( i , arm [ 2 ] ) else
21084: LD_VAR 0 1
21088: PPUSH
21089: LD_VAR 0 10
21093: PUSH
21094: LD_INT 2
21096: ARRAY
21097: PPUSH
21098: CALL_OW 180
21102: GO 21158
// if UnitsInside ( arm [ 1 ] ) < 6 then
21104: LD_VAR 0 10
21108: PUSH
21109: LD_INT 1
21111: ARRAY
21112: PPUSH
21113: CALL_OW 313
21117: PUSH
21118: LD_INT 6
21120: LESS
21121: IFFALSE 21143
// AddComEnterUnit ( i , arm [ 1 ] ) else
21123: LD_VAR 0 1
21127: PPUSH
21128: LD_VAR 0 10
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: CALL_OW 180
21141: GO 21158
// AddComMoveXY ( i , 37 , 68 ) ;
21143: LD_VAR 0 1
21147: PPUSH
21148: LD_INT 37
21150: PPUSH
21151: LD_INT 68
21153: PPUSH
21154: CALL_OW 171
// end ;
21158: GO 21053
21160: POP
21161: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21162: LD_ADDR_VAR 0 11
21166: PUSH
21167: LD_VAR 0 6
21171: PPUSH
21172: LD_INT 26
21174: PUSH
21175: LD_INT 1
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: PPUSH
21182: CALL_OW 72
21186: PUSH
21187: LD_EXP 59
21191: DIFF
21192: ST_TO_ADDR
// if not speaker then
21193: LD_VAR 0 11
21197: NOT
21198: IFFALSE 21225
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21200: LD_ADDR_VAR 0 11
21204: PUSH
21205: LD_VAR 0 6
21209: PPUSH
21210: LD_INT 26
21212: PUSH
21213: LD_INT 1
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 72
21224: ST_TO_ADDR
// if speaker then
21225: LD_VAR 0 11
21229: IFFALSE 21245
// speaker := speaker [ 1 ] ;
21231: LD_ADDR_VAR 0 11
21235: PUSH
21236: LD_VAR 0 11
21240: PUSH
21241: LD_INT 1
21243: ARRAY
21244: ST_TO_ADDR
// Video ( true ) ;
21245: LD_INT 1
21247: PPUSH
21248: CALL 102182 0 1
// CenterNowOnUnits ( Powell ) ;
21252: LD_EXP 58
21256: PPUSH
21257: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21261: LD_ADDR_VAR 0 3
21265: PUSH
21266: LD_VAR 0 6
21270: PPUSH
21271: LD_INT 3
21273: PUSH
21274: LD_INT 25
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PPUSH
21288: CALL_OW 72
21292: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21293: LD_ADDR_VAR 0 12
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_INT 4
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 30
21310: PUSH
21311: LD_INT 32
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 58
21320: PUSH
21321: EMPTY
21322: LIST
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: PPUSH
21329: CALL_OW 69
21333: ST_TO_ADDR
// for i = 1 to 6 do
21334: LD_ADDR_VAR 0 1
21338: PUSH
21339: DOUBLE
21340: LD_INT 1
21342: DEC
21343: ST_TO_ADDR
21344: LD_INT 6
21346: PUSH
21347: FOR_TO
21348: IFFALSE 21489
// begin if IsInUnit ( tmp [ i ] ) then
21350: LD_VAR 0 3
21354: PUSH
21355: LD_VAR 0 1
21359: ARRAY
21360: PPUSH
21361: CALL_OW 310
21365: IFFALSE 21382
// ComExitBuilding ( tmp [ i ] ) ;
21367: LD_VAR 0 3
21371: PUSH
21372: LD_VAR 0 1
21376: ARRAY
21377: PPUSH
21378: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21382: LD_VAR 0 3
21386: PUSH
21387: LD_VAR 0 1
21391: ARRAY
21392: PPUSH
21393: LD_VAR 0 10
21397: PUSH
21398: LD_INT 1
21400: ARRAY
21401: PPUSH
21402: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21406: LD_VAR 0 3
21410: PUSH
21411: LD_VAR 0 1
21415: ARRAY
21416: PPUSH
21417: LD_INT 1
21419: PPUSH
21420: CALL_OW 183
// if emp_towers then
21424: LD_VAR 0 12
21428: IFFALSE 21487
// begin AddComExitBuilding ( tmp [ i ] ) ;
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 1
21454: ARRAY
21455: PPUSH
21456: LD_VAR 0 12
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PPUSH
21465: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21469: LD_ADDR_VAR 0 12
21473: PUSH
21474: LD_VAR 0 12
21478: PPUSH
21479: LD_INT 1
21481: PPUSH
21482: CALL_OW 3
21486: ST_TO_ADDR
// end ; end ;
21487: GO 21347
21489: POP
21490: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21491: LD_ADDR_VAR 0 3
21495: PUSH
21496: LD_EXP 18
21500: PUSH
21501: LD_INT 1
21503: ARRAY
21504: PUSH
21505: LD_EXP 18
21509: PUSH
21510: LD_INT 2
21512: ARRAY
21513: ADD
21514: PPUSH
21515: LD_INT 26
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 72
21529: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21530: LD_ADDR_VAR 0 1
21534: PUSH
21535: LD_EXP 18
21539: PUSH
21540: LD_INT 2
21542: ARRAY
21543: PUSH
21544: FOR_IN
21545: IFFALSE 21563
// ComTurnUnit ( i , Powell ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: LD_EXP 58
21556: PPUSH
21557: CALL_OW 119
21561: GO 21544
21563: POP
21564: POP
// Say ( Powell , D5-Pow-1 ) ;
21565: LD_EXP 58
21569: PPUSH
21570: LD_STRING D5-Pow-1
21572: PPUSH
21573: CALL_OW 88
// if tmp then
21577: LD_VAR 0 3
21581: IFFALSE 21599
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21583: LD_VAR 0 3
21587: PUSH
21588: LD_INT 1
21590: ARRAY
21591: PPUSH
21592: LD_STRING D5-Sol2-1
21594: PPUSH
21595: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21599: LD_EXP 58
21603: PPUSH
21604: LD_STRING D5-Pow-2
21606: PPUSH
21607: CALL_OW 88
// if tmp > 1 then
21611: LD_VAR 0 3
21615: PUSH
21616: LD_INT 1
21618: GREATER
21619: IFFALSE 21637
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21621: LD_VAR 0 3
21625: PUSH
21626: LD_INT 2
21628: ARRAY
21629: PPUSH
21630: LD_STRING D5-Sol2-2
21632: PPUSH
21633: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21637: LD_EXP 58
21641: PPUSH
21642: LD_STRING D5-Pow-3
21644: PPUSH
21645: CALL_OW 88
// wait ( 0 0$1 ) ;
21649: LD_INT 35
21651: PPUSH
21652: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21656: LD_ADDR_VAR 0 3
21660: PUSH
21661: LD_EXP 18
21665: PUSH
21666: LD_INT 1
21668: ARRAY
21669: PUSH
21670: LD_EXP 18
21674: PUSH
21675: LD_INT 2
21677: ARRAY
21678: UNION
21679: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21680: LD_VAR 0 3
21684: PPUSH
21685: LD_INT 80
21687: PPUSH
21688: LD_INT 67
21690: PPUSH
21691: CALL_OW 114
// wait ( 0 0$2 ) ;
21695: LD_INT 70
21697: PPUSH
21698: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21702: LD_INT 79
21704: PPUSH
21705: LD_INT 72
21707: PPUSH
21708: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21712: LD_INT 35
21714: PPUSH
21715: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21719: LD_VAR 0 3
21723: PPUSH
21724: LD_INT 3
21726: PUSH
21727: LD_INT 24
21729: PUSH
21730: LD_INT 1000
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: PPUSH
21741: CALL_OW 72
21745: IFFALSE 21712
// Say ( Powell , D5a-Pow-1 ) ;
21747: LD_EXP 58
21751: PPUSH
21752: LD_STRING D5a-Pow-1
21754: PPUSH
21755: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21759: LD_EXP 58
21763: PPUSH
21764: LD_STRING D5a-Pow-1a
21766: PPUSH
21767: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21771: LD_INT 10
21773: PPUSH
21774: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21778: LD_EXP 58
21782: PPUSH
21783: LD_STRING D5a-Pow-1b
21785: PPUSH
21786: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21790: LD_EXP 58
21794: PPUSH
21795: LD_STRING D5a-Pow-1c
21797: PPUSH
21798: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21802: LD_EXP 58
21806: PPUSH
21807: LD_STRING D5a-Pow-1d
21809: PPUSH
21810: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21814: LD_INT 35
21816: PPUSH
21817: CALL_OW 67
// if not HasTask ( tmp ) then
21821: LD_VAR 0 3
21825: PPUSH
21826: CALL_OW 314
21830: NOT
21831: IFFALSE 21848
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21833: LD_VAR 0 3
21837: PPUSH
21838: LD_INT 80
21840: PPUSH
21841: LD_INT 67
21843: PPUSH
21844: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21848: LD_VAR 0 3
21852: PPUSH
21853: LD_INT 24
21855: PUSH
21856: LD_INT 1
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: PPUSH
21863: CALL_OW 72
21867: NOT
21868: IFFALSE 21814
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21870: LD_ADDR_VAR 0 3
21874: PUSH
21875: LD_INT 22
21877: PUSH
21878: LD_INT 4
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 92
21887: PUSH
21888: LD_INT 60
21890: PUSH
21891: LD_INT 93
21893: PUSH
21894: LD_INT 10
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: LIST
21902: PUSH
21903: LD_INT 3
21905: PUSH
21906: LD_INT 54
21908: PUSH
21909: EMPTY
21910: LIST
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 69
21925: PUSH
21926: LD_EXP 58
21930: DIFF
21931: ST_TO_ADDR
// if tmp then
21932: LD_VAR 0 3
21936: IFFALSE 21970
// for i in tmp do
21938: LD_ADDR_VAR 0 1
21942: PUSH
21943: LD_VAR 0 3
21947: PUSH
21948: FOR_IN
21949: IFFALSE 21968
// ComMoveXY ( i , 36 , 67 ) ;
21951: LD_VAR 0 1
21955: PPUSH
21956: LD_INT 36
21958: PPUSH
21959: LD_INT 67
21961: PPUSH
21962: CALL_OW 111
21966: GO 21948
21968: POP
21969: POP
// wait ( 0 0$3 ) ;
21970: LD_INT 105
21972: PPUSH
21973: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21977: LD_VAR 0 11
21981: PPUSH
21982: LD_STRING D6-Sol3-1
21984: PPUSH
21985: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21989: LD_EXP 58
21993: PPUSH
21994: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21998: LD_EXP 58
22002: PPUSH
22003: LD_STRING D6-Pow-1
22005: PPUSH
22006: CALL_OW 88
// tmp := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// for i = 1 to 2 do
22017: LD_ADDR_VAR 0 1
22021: PUSH
22022: DOUBLE
22023: LD_INT 1
22025: DEC
22026: ST_TO_ADDR
22027: LD_INT 2
22029: PUSH
22030: FOR_TO
22031: IFFALSE 22145
// begin uc_side := 8 ;
22033: LD_ADDR_OWVAR 20
22037: PUSH
22038: LD_INT 8
22040: ST_TO_ADDR
// uc_nation := 2 ;
22041: LD_ADDR_OWVAR 21
22045: PUSH
22046: LD_INT 2
22048: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22049: LD_INT 14
22051: PPUSH
22052: LD_INT 3
22054: PPUSH
22055: LD_INT 2
22057: PPUSH
22058: LD_INT 29
22060: PPUSH
22061: LD_INT 100
22063: PPUSH
22064: CALL 70336 0 5
// veh := CreateVehicle ;
22068: LD_ADDR_VAR 0 13
22072: PUSH
22073: CALL_OW 45
22077: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: LD_INT 4
22085: PPUSH
22086: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22090: LD_VAR 0 13
22094: PPUSH
22095: LD_INT 99
22097: PPUSH
22098: LD_INT 83
22100: PPUSH
22101: LD_INT 6
22103: PPUSH
22104: LD_INT 0
22106: PPUSH
22107: CALL_OW 50
// wait ( 3 ) ;
22111: LD_INT 3
22113: PPUSH
22114: CALL_OW 67
// Connect ( veh ) ;
22118: LD_VAR 0 13
22122: PPUSH
22123: CALL 73429 0 1
// tmp := tmp ^ veh ;
22127: LD_ADDR_VAR 0 3
22131: PUSH
22132: LD_VAR 0 3
22136: PUSH
22137: LD_VAR 0 13
22141: ADD
22142: ST_TO_ADDR
// end ;
22143: GO 22030
22145: POP
22146: POP
// wait ( 0 0$1 ) ;
22147: LD_INT 35
22149: PPUSH
22150: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22154: LD_INT 99
22156: PPUSH
22157: LD_INT 83
22159: PPUSH
22160: LD_INT 1
22162: PPUSH
22163: LD_INT 10
22165: PPUSH
22166: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22170: LD_INT 99
22172: PPUSH
22173: LD_INT 83
22175: PPUSH
22176: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22180: LD_VAR 0 11
22184: PPUSH
22185: LD_STRING D6-Sol3-2
22187: PPUSH
22188: CALL_OW 88
// async ;
22192: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22193: LD_EXP 58
22197: PPUSH
22198: LD_STRING D6-Pow-2
22200: PPUSH
22201: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22205: LD_VAR 0 3
22209: PUSH
22210: LD_INT 1
22212: ARRAY
22213: PPUSH
22214: LD_VAR 0 9
22218: PPUSH
22219: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22223: LD_VAR 0 3
22227: PUSH
22228: LD_INT 2
22230: ARRAY
22231: PPUSH
22232: LD_INT 22
22234: PUSH
22235: LD_INT 4
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: PUSH
22242: LD_INT 21
22244: PUSH
22245: LD_INT 3
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PPUSH
22256: CALL_OW 69
22260: PPUSH
22261: LD_VAR 0 3
22265: PUSH
22266: LD_INT 2
22268: ARRAY
22269: PPUSH
22270: CALL_OW 74
22274: PPUSH
22275: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22279: LD_EXP 58
22283: PPUSH
22284: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22288: LD_INT 99
22290: PPUSH
22291: LD_INT 83
22293: PPUSH
22294: LD_INT 1
22296: PPUSH
22297: CALL_OW 331
// repeat wait ( 4 ) ;
22301: LD_INT 4
22303: PPUSH
22304: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22308: LD_VAR 0 3
22312: PUSH
22313: LD_INT 1
22315: ARRAY
22316: PPUSH
22317: CALL_OW 256
22321: PUSH
22322: LD_INT 1000
22324: LESS
22325: IFFALSE 22343
// SetLives ( tmp [ 1 ] , 1000 ) ;
22327: LD_VAR 0 3
22331: PUSH
22332: LD_INT 1
22334: ARRAY
22335: PPUSH
22336: LD_INT 1000
22338: PPUSH
22339: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22343: LD_INT 22
22345: PUSH
22346: LD_INT 4
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 30
22355: PUSH
22356: LD_INT 3
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: PPUSH
22367: CALL_OW 69
22371: PUSH
22372: LD_INT 0
22374: EQUAL
22375: IFFALSE 22301
// sync ;
22377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22378: LD_EXP 58
22382: PPUSH
22383: LD_STRING D6a-Pow-1
22385: PPUSH
22386: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22390: LD_VAR 0 11
22394: PPUSH
22395: LD_STRING D6a-Sol3-1
22397: PPUSH
22398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22402: LD_EXP 58
22406: PPUSH
22407: LD_STRING D6a-Pow-2
22409: PPUSH
22410: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_STRING D6a-Sol3-2
22421: PPUSH
22422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22426: LD_EXP 58
22430: PPUSH
22431: LD_STRING D6a-Pow-3
22433: PPUSH
22434: CALL_OW 88
// powellCenterCameraMode := true ;
22438: LD_ADDR_EXP 20
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22446: LD_ADDR_VAR 0 1
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_INT 8
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 25
22463: PUSH
22464: LD_INT 2
22466: PUSH
22467: EMPTY
22468: LIST
22469: LIST
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: PPUSH
22475: CALL_OW 69
22479: PUSH
22480: FOR_IN
22481: IFFALSE 22536
// begin SetTag ( i , 1 ) ;
22483: LD_VAR 0 1
22487: PPUSH
22488: LD_INT 1
22490: PPUSH
22491: CALL_OW 109
// ComExitBuilding ( i ) ;
22495: LD_VAR 0 1
22499: PPUSH
22500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22504: LD_VAR 0 1
22508: PPUSH
22509: LD_INT 35
22511: PPUSH
22512: LD_INT 6
22514: PPUSH
22515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22519: LD_VAR 0 1
22523: PPUSH
22524: LD_INT 53
22526: PPUSH
22527: LD_INT 4
22529: PPUSH
22530: CALL_OW 171
// end ;
22534: GO 22480
22536: POP
22537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22538: LD_ADDR_VAR 0 3
22542: PUSH
22543: LD_INT 22
22545: PUSH
22546: LD_INT 4
22548: PUSH
22549: EMPTY
22550: LIST
22551: LIST
22552: PUSH
22553: LD_INT 21
22555: PUSH
22556: LD_INT 2
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: LD_INT 34
22568: PUSH
22569: LD_INT 12
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: PPUSH
22585: CALL_OW 69
22589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22590: LD_EXP 58
22594: PPUSH
22595: LD_VAR 0 3
22599: PPUSH
22600: LD_EXP 58
22604: PPUSH
22605: CALL_OW 74
22609: PPUSH
22610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22614: LD_EXP 58
22618: PPUSH
22619: LD_INT 100
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22629: LD_EXP 58
22633: PPUSH
22634: LD_INT 100
22636: PPUSH
22637: LD_INT 75
22639: PPUSH
22640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22644: LD_EXP 58
22648: PPUSH
22649: LD_INT 88
22651: PPUSH
22652: LD_INT 53
22654: PPUSH
22655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22659: LD_INT 8
22661: PPUSH
22662: LD_EXP 58
22666: PPUSH
22667: CALL_OW 471
// repeat wait ( 3 ) ;
22671: LD_INT 3
22673: PPUSH
22674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22678: LD_INT 22
22680: PUSH
22681: LD_INT 4
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: PUSH
22688: LD_INT 92
22690: PUSH
22691: LD_INT 100
22693: PUSH
22694: LD_INT 75
22696: PUSH
22697: LD_INT 6
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: PUSH
22706: EMPTY
22707: LIST
22708: LIST
22709: PPUSH
22710: CALL_OW 69
22714: IFFALSE 22671
// async ;
22716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_STRING D6b-Pow-1
22724: PPUSH
22725: CALL_OW 88
// repeat wait ( 3 ) ;
22729: LD_INT 3
22731: PPUSH
22732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22736: LD_EXP 58
22740: PPUSH
22741: CALL_OW 310
22745: PPUSH
22746: CALL_OW 256
22750: PUSH
22751: LD_INT 1000
22753: LESS
22754: IFFALSE 22773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22756: LD_EXP 58
22760: PPUSH
22761: CALL_OW 310
22765: PPUSH
22766: LD_INT 1000
22768: PPUSH
22769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22773: LD_EXP 58
22777: PPUSH
22778: CALL_OW 256
22782: PUSH
22783: LD_INT 1000
22785: LESS
22786: IFFALSE 22800
// SetLives ( Powell , 1000 ) ;
22788: LD_EXP 58
22792: PPUSH
22793: LD_INT 1000
22795: PPUSH
22796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22800: LD_EXP 58
22804: PPUSH
22805: LD_EXP 63
22809: PPUSH
22810: CALL_OW 296
22814: PUSH
22815: LD_INT 5
22817: LESS
22818: PUSH
22819: LD_EXP 58
22823: PPUSH
22824: CALL_OW 310
22828: PPUSH
22829: LD_EXP 63
22833: PPUSH
22834: CALL_OW 296
22838: PUSH
22839: LD_INT 5
22841: LESS
22842: OR
22843: IFFALSE 22862
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22845: LD_EXP 58
22849: PPUSH
22850: CALL_OW 310
22854: PPUSH
22855: LD_INT 100
22857: PPUSH
22858: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22862: LD_EXP 58
22866: PPUSH
22867: CALL_OW 310
22871: NOT
22872: IFFALSE 22729
// DoNotAttack ( 8 , powellBomb ) ;
22874: LD_INT 8
22876: PPUSH
22877: LD_EXP 63
22881: PPUSH
22882: CALL_OW 471
// game_speed := 4 ;
22886: LD_ADDR_OWVAR 65
22890: PUSH
22891: LD_INT 4
22893: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22894: LD_EXP 58
22898: PPUSH
22899: LD_STRING D6b-Pow-1a
22901: PPUSH
22902: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22906: LD_EXP 58
22910: PPUSH
22911: LD_EXP 63
22915: PPUSH
22916: CALL_OW 180
// sync ;
22920: SYNC
// repeat wait ( 0 0$1 ) ;
22921: LD_INT 35
22923: PPUSH
22924: CALL_OW 67
// until IsInUnit ( Powell ) ;
22928: LD_EXP 58
22932: PPUSH
22933: CALL_OW 310
22937: IFFALSE 22921
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22939: LD_INT 8
22941: PPUSH
22942: LD_EXP 58
22946: PPUSH
22947: CALL_OW 310
22951: PPUSH
22952: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 58
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22971: LD_EXP 58
22975: PPUSH
22976: LD_INT 96
22978: PPUSH
22979: LD_INT 44
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22986: LD_EXP 58
22990: PPUSH
22991: LD_INT 96
22993: PPUSH
22994: LD_INT 41
22996: PPUSH
22997: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23001: LD_EXP 58
23005: PPUSH
23006: LD_INT 92
23008: PPUSH
23009: LD_INT 39
23011: PPUSH
23012: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23016: LD_EXP 58
23020: PPUSH
23021: LD_INT 88
23023: PPUSH
23024: LD_INT 41
23026: PPUSH
23027: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23031: LD_EXP 58
23035: PPUSH
23036: LD_INT 91
23038: PPUSH
23039: LD_INT 44
23041: PPUSH
23042: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23046: LD_EXP 58
23050: PPUSH
23051: LD_INT 96
23053: PPUSH
23054: LD_INT 44
23056: PPUSH
23057: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23061: LD_EXP 58
23065: PPUSH
23066: LD_INT 96
23068: PPUSH
23069: LD_INT 41
23071: PPUSH
23072: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23076: LD_EXP 58
23080: PPUSH
23081: LD_INT 92
23083: PPUSH
23084: LD_INT 39
23086: PPUSH
23087: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23091: LD_EXP 58
23095: PPUSH
23096: LD_INT 88
23098: PPUSH
23099: LD_INT 41
23101: PPUSH
23102: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23106: LD_EXP 58
23110: PPUSH
23111: LD_INT 91
23113: PPUSH
23114: LD_INT 44
23116: PPUSH
23117: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23121: LD_EXP 58
23125: PPUSH
23126: LD_INT 93
23128: PPUSH
23129: LD_INT 39
23131: PPUSH
23132: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23136: LD_EXP 58
23140: PPUSH
23141: LD_INT 93
23143: PPUSH
23144: LD_INT 36
23146: PPUSH
23147: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23151: LD_INT 122
23153: PPUSH
23154: CALL_OW 67
// game_speed := 4 ;
23158: LD_ADDR_OWVAR 65
23162: PUSH
23163: LD_INT 4
23165: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23166: LD_EXP 58
23170: PPUSH
23171: LD_STRING D6b-Pow-1b
23173: PPUSH
23174: CALL_OW 88
// tmp := [ ] ;
23178: LD_ADDR_VAR 0 3
23182: PUSH
23183: EMPTY
23184: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23185: LD_ADDR_VAR 0 5
23189: PUSH
23190: LD_INT 78
23192: PUSH
23193: LD_INT 47
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 106
23202: PUSH
23203: LD_INT 53
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23214: LD_ADDR_VAR 0 1
23218: PUSH
23219: LD_INT 22
23221: PUSH
23222: LD_INT 8
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 21
23231: PUSH
23232: LD_INT 3
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: PUSH
23239: LD_INT 92
23241: PUSH
23242: LD_INT 90
23244: PUSH
23245: LD_INT 52
23247: PUSH
23248: LD_INT 12
23250: PUSH
23251: EMPTY
23252: LIST
23253: LIST
23254: LIST
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PUSH
23267: FOR_IN
23268: IFFALSE 23293
// tmp := tmp ^ UnitsInside ( i ) ;
23270: LD_ADDR_VAR 0 3
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 313
23289: ADD
23290: ST_TO_ADDR
23291: GO 23267
23293: POP
23294: POP
// for i in tmp do
23295: LD_ADDR_VAR 0 1
23299: PUSH
23300: LD_VAR 0 3
23304: PUSH
23305: FOR_IN
23306: IFFALSE 23468
// begin dist := 9999 ;
23308: LD_ADDR_VAR 0 8
23312: PUSH
23313: LD_INT 9999
23315: ST_TO_ADDR
// _xy := [ ] ;
23316: LD_ADDR_VAR 0 7
23320: PUSH
23321: EMPTY
23322: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23323: LD_VAR 0 1
23327: PPUSH
23328: LD_INT 1
23330: PPUSH
23331: CALL_OW 109
// ComExitBuilding ( i ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: CALL_OW 122
// for j in xy do
23344: LD_ADDR_VAR 0 2
23348: PUSH
23349: LD_VAR 0 5
23353: PUSH
23354: FOR_IN
23355: IFFALSE 23437
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: PUSH
23385: LD_VAR 0 8
23389: LESS
23390: IFFALSE 23435
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23392: LD_ADDR_VAR 0 8
23396: PUSH
23397: LD_VAR 0 1
23401: PPUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 1
23409: ARRAY
23410: PPUSH
23411: LD_VAR 0 2
23415: PUSH
23416: LD_INT 2
23418: ARRAY
23419: PPUSH
23420: CALL_OW 297
23424: ST_TO_ADDR
// _xy := j ;
23425: LD_ADDR_VAR 0 7
23429: PUSH
23430: LD_VAR 0 2
23434: ST_TO_ADDR
// end ;
23435: GO 23354
23437: POP
23438: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23439: LD_VAR 0 1
23443: PPUSH
23444: LD_VAR 0 7
23448: PUSH
23449: LD_INT 1
23451: ARRAY
23452: PPUSH
23453: LD_VAR 0 7
23457: PUSH
23458: LD_INT 2
23460: ARRAY
23461: PPUSH
23462: CALL_OW 171
// end ;
23466: GO 23305
23468: POP
23469: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23470: LD_ADDR_VAR 0 4
23474: PUSH
23475: LD_VAR 0 3
23479: PPUSH
23480: LD_INT 26
23482: PUSH
23483: LD_INT 1
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PUSH
23490: LD_INT 25
23492: PUSH
23493: LD_INT 1
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PPUSH
23504: CALL_OW 72
23508: ST_TO_ADDR
// if tmp2 < 2 then
23509: LD_VAR 0 4
23513: PUSH
23514: LD_INT 2
23516: LESS
23517: IFFALSE 23586
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23519: LD_ADDR_VAR 0 4
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 26
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: LD_INT 3
23546: PUSH
23547: LD_INT 25
23549: PUSH
23550: LD_INT 15
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: LIST
23565: PPUSH
23566: CALL_OW 69
23570: PUSH
23571: LD_EXP 60
23575: PUSH
23576: LD_EXP 61
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: DIFF
23585: ST_TO_ADDR
// if tmp2 then
23586: LD_VAR 0 4
23590: IFFALSE 23608
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23592: LD_VAR 0 4
23596: PUSH
23597: LD_INT 1
23599: ARRAY
23600: PPUSH
23601: LD_STRING D6b-ArSol1-1
23603: PPUSH
23604: CALL_OW 88
// async ;
23608: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23609: LD_EXP 58
23613: PPUSH
23614: LD_STRING D6b-Pow-2
23616: PPUSH
23617: CALL_OW 88
// wait ( 0 0$1 ) ;
23621: LD_INT 35
23623: PPUSH
23624: CALL_OW 67
// if tmp2 > 1 then
23628: LD_VAR 0 4
23632: PUSH
23633: LD_INT 1
23635: GREATER
23636: IFFALSE 23654
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23638: LD_VAR 0 4
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: LD_STRING D6b-ArSol2-1
23649: PPUSH
23650: CALL_OW 88
// sync ;
23654: SYNC
// repeat wait ( 5 ) ;
23655: LD_INT 5
23657: PPUSH
23658: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23662: LD_INT 93
23664: PPUSH
23665: LD_INT 36
23667: PPUSH
23668: CALL_OW 428
23672: PPUSH
23673: CALL_OW 255
23677: PUSH
23678: LD_INT 4
23680: EQUAL
23681: IFFALSE 23655
// DialogueOn ;
23683: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23687: LD_INT 10
23689: PPUSH
23690: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23694: LD_EXP 58
23698: PPUSH
23699: LD_STRING D6b-Pow-2a
23701: PPUSH
23702: CALL_OW 88
// DialogueOff ;
23706: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23710: LD_EXP 58
23714: PPUSH
23715: CALL_OW 310
23719: PPUSH
23720: LD_INT 332
23722: PPUSH
23723: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23727: LD_INT 93
23729: PPUSH
23730: LD_INT 35
23732: PPUSH
23733: LD_INT 1
23735: PPUSH
23736: LD_INT 6
23738: NEG
23739: PPUSH
23740: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23744: LD_INT 35
23746: PPUSH
23747: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23751: LD_INT 332
23753: PPUSH
23754: CALL_OW 256
23758: PUSH
23759: LD_INT 1000
23761: LESS
23762: PUSH
23763: LD_INT 332
23765: PPUSH
23766: CALL_OW 300
23770: AND
23771: IFFALSE 23783
// SetLives ( kozlov_fac , 0 ) ;
23773: LD_INT 332
23775: PPUSH
23776: LD_INT 0
23778: PPUSH
23779: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23783: LD_INT 332
23785: PPUSH
23786: CALL_OW 301
23790: PUSH
23791: LD_EXP 58
23795: PPUSH
23796: CALL_OW 301
23800: OR
23801: IFFALSE 23744
// game_speed := 4 ;
23803: LD_ADDR_OWVAR 65
23807: PUSH
23808: LD_INT 4
23810: ST_TO_ADDR
// powellCenterCameraMode := false ;
23811: LD_ADDR_EXP 20
23815: PUSH
23816: LD_INT 0
23818: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: LD_INT 22
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 25
23841: PUSH
23842: LD_INT 2
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PPUSH
23853: CALL_OW 69
23857: UNION
23858: PUSH
23859: FOR_IN
23860: IFFALSE 23876
// SetTag ( i , 0 ) ;
23862: LD_VAR 0 1
23866: PPUSH
23867: LD_INT 0
23869: PPUSH
23870: CALL_OW 109
23874: GO 23859
23876: POP
23877: POP
// wait ( 0 0$3 ) ;
23878: LD_INT 105
23880: PPUSH
23881: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23885: LD_INT 93
23887: PPUSH
23888: LD_INT 35
23890: PPUSH
23891: LD_INT 1
23893: PPUSH
23894: CALL_OW 331
// DialogueOn ;
23898: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23902: LD_VAR 0 11
23906: PPUSH
23907: LD_STRING D6c-Sol3-1
23909: PPUSH
23910: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23914: LD_INT 10
23916: PPUSH
23917: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23921: LD_EXP 39
23925: PPUSH
23926: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23930: LD_EXP 39
23934: PPUSH
23935: LD_STRING D6c-JMM-1
23937: PPUSH
23938: CALL_OW 88
// if Cyrus then
23942: LD_EXP 45
23946: IFFALSE 23960
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23948: LD_EXP 45
23952: PPUSH
23953: LD_STRING D6c-Cyrus-1
23955: PPUSH
23956: CALL_OW 88
// if Bobby then
23960: LD_EXP 44
23964: IFFALSE 23978
// Say ( Bobby , D6c-Bobby-1 ) ;
23966: LD_EXP 44
23970: PPUSH
23971: LD_STRING D6c-Bobby-1
23973: PPUSH
23974: CALL_OW 88
// if Cornel then
23978: LD_EXP 50
23982: IFFALSE 23996
// Say ( Cornel , D6c-Corn-1 ) ;
23984: LD_EXP 50
23988: PPUSH
23989: LD_STRING D6c-Corn-1
23991: PPUSH
23992: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23996: LD_ADDR_VAR 0 4
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 22
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 22
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: EMPTY
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 26
24031: PUSH
24032: LD_INT 1
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 25
24044: PUSH
24045: LD_INT 16
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 25
24054: PUSH
24055: LD_INT 12
24057: PUSH
24058: EMPTY
24059: LIST
24060: LIST
24061: PUSH
24062: EMPTY
24063: LIST
24064: LIST
24065: LIST
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: PPUSH
24072: CALL_OW 69
24076: PUSH
24077: LD_VAR 0 11
24081: PUSH
24082: LD_EXP 39
24086: UNION
24087: PUSH
24088: LD_EXP 59
24092: UNION
24093: PUSH
24094: EMPTY
24095: LIST
24096: DIFF
24097: ST_TO_ADDR
// if tmp2 then
24098: LD_VAR 0 4
24102: IFFALSE 24120
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24104: LD_VAR 0 4
24108: PUSH
24109: LD_INT 1
24111: ARRAY
24112: PPUSH
24113: LD_STRING D6c-Sol1-1
24115: PPUSH
24116: CALL_OW 88
// if Lisa then
24120: LD_EXP 42
24124: IFFALSE 24138
// Say ( Lisa , D6c-Lisa-1 ) ;
24126: LD_EXP 42
24130: PPUSH
24131: LD_STRING D6c-Lisa-1
24133: PPUSH
24134: CALL_OW 88
// if Gary then
24138: LD_EXP 51
24142: IFFALSE 24156
// Say ( Gary , D6c-Gary-1 ) ;
24144: LD_EXP 51
24148: PPUSH
24149: LD_STRING D6c-Gary-1
24151: PPUSH
24152: CALL_OW 88
// if Donaldson then
24156: LD_EXP 43
24160: IFFALSE 24174
// Say ( Donaldson , D6c-Don-1 ) ;
24162: LD_EXP 43
24166: PPUSH
24167: LD_STRING D6c-Don-1
24169: PPUSH
24170: CALL_OW 88
// if tmp2 > 1 then
24174: LD_VAR 0 4
24178: PUSH
24179: LD_INT 1
24181: GREATER
24182: IFFALSE 24200
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24184: LD_VAR 0 4
24188: PUSH
24189: LD_INT 2
24191: ARRAY
24192: PPUSH
24193: LD_STRING D6c-Sol2-1
24195: PPUSH
24196: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24200: LD_VAR 0 11
24204: PPUSH
24205: LD_STRING D6c-Sol3-2
24207: PPUSH
24208: CALL_OW 88
// dwait ( 0 0$1 ) ;
24212: LD_INT 35
24214: PPUSH
24215: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24219: LD_EXP 39
24223: PPUSH
24224: LD_STRING D6c-JMM-2
24226: PPUSH
24227: CALL_OW 88
// DialogueOff ;
24231: CALL_OW 7
// Video ( false ) ;
24235: LD_INT 0
24237: PPUSH
24238: CALL 102182 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24242: LD_INT 22
24244: PUSH
24245: LD_INT 4
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PPUSH
24252: CALL_OW 69
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24264: LD_INT 4
24266: PPUSH
24267: LD_INT 4
24269: PPUSH
24270: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24274: LD_ADDR_VAR 0 1
24278: PUSH
24279: LD_INT 4
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_INT 2
24287: PPUSH
24288: CALL 65535 0 3
24292: PUSH
24293: FOR_IN
24294: IFFALSE 24331
// if GetTech ( i , 1 ) <> state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 1
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: NONEQUAL
24312: IFFALSE 24329
// SetTech ( i , 1 , state_researched ) ;
24314: LD_VAR 0 1
24318: PPUSH
24319: LD_INT 1
24321: PPUSH
24322: LD_INT 2
24324: PPUSH
24325: CALL_OW 322
24329: GO 24293
24331: POP
24332: POP
// missionStage := 6 ;
24333: LD_ADDR_EXP 15
24337: PUSH
24338: LD_INT 6
24340: ST_TO_ADDR
// activeAttacks := true ;
24341: LD_ADDR_EXP 16
24345: PUSH
24346: LD_INT 1
24348: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24349: LD_STRING M2
24351: PPUSH
24352: CALL_OW 337
// SaveForQuickRestart ;
24356: CALL_OW 22
// wait ( 0 0$40 ) ;
24360: LD_INT 1400
24362: PPUSH
24363: CALL_OW 67
// DialogueOn ;
24367: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24371: LD_EXP 62
24375: PPUSH
24376: LD_STRING D7-Friend-1
24378: PPUSH
24379: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24383: LD_EXP 39
24387: PPUSH
24388: LD_STRING D7-JMM-1
24390: PPUSH
24391: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24395: LD_EXP 62
24399: PPUSH
24400: LD_STRING D7-Friend-2
24402: PPUSH
24403: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24407: LD_EXP 39
24411: PPUSH
24412: LD_STRING D7-JMM-2
24414: PPUSH
24415: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24419: LD_EXP 62
24423: PPUSH
24424: LD_STRING D7-Friend-3
24426: PPUSH
24427: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24431: LD_EXP 39
24435: PPUSH
24436: LD_STRING D7-JMM-3
24438: PPUSH
24439: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24443: LD_EXP 62
24447: PPUSH
24448: LD_STRING D7-Friend-4
24450: PPUSH
24451: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24455: LD_EXP 39
24459: PPUSH
24460: LD_STRING D7-JMM-4
24462: PPUSH
24463: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24467: LD_EXP 62
24471: PPUSH
24472: LD_STRING D7-Friend-5
24474: PPUSH
24475: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24479: LD_EXP 39
24483: PPUSH
24484: LD_STRING D7-JMM-5
24486: PPUSH
24487: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24491: LD_EXP 62
24495: PPUSH
24496: LD_STRING D7-Friend-6
24498: PPUSH
24499: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24503: LD_EXP 39
24507: PPUSH
24508: LD_STRING D7-JMM-6
24510: PPUSH
24511: CALL_OW 88
// DialogueOff ;
24515: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24519: LD_STRING Mlegion
24521: PPUSH
24522: CALL_OW 337
// RebuildKozlovFactory ;
24526: CALL 4880 0 0
// end ;
24530: PPOPN 13
24532: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24533: LD_EXP 20
24537: PUSH
24538: LD_EXP 58
24542: PPUSH
24543: CALL_OW 300
24547: AND
24548: IFFALSE 24590
24550: GO 24552
24552: DISABLE
// begin enable ;
24553: ENABLE
// if IsInUnit ( Powell ) then
24554: LD_EXP 58
24558: PPUSH
24559: CALL_OW 310
24563: IFFALSE 24581
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24565: LD_EXP 58
24569: PPUSH
24570: CALL_OW 310
24574: PPUSH
24575: CALL_OW 85
24579: GO 24590
// CenterOnUnits ( Powell ) ;
24581: LD_EXP 58
24585: PPUSH
24586: CALL_OW 85
// end ;
24590: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24591: LD_INT 22
24593: PUSH
24594: LD_INT 8
24596: PUSH
24597: EMPTY
24598: LIST
24599: LIST
24600: PUSH
24601: LD_INT 34
24603: PUSH
24604: LD_INT 48
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PPUSH
24615: CALL_OW 69
24619: IFFALSE 24893
24621: GO 24623
24623: DISABLE
24624: LD_INT 0
24626: PPUSH
24627: PPUSH
// begin if missionStage < 9 then
24628: LD_EXP 15
24632: PUSH
24633: LD_INT 9
24635: LESS
24636: IFFALSE 24646
// missionStage := 9 ;
24638: LD_ADDR_EXP 15
24642: PUSH
24643: LD_INT 9
24645: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_INT 22
24653: PUSH
24654: LD_INT 8
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 34
24663: PUSH
24664: LD_INT 48
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: PPUSH
24675: CALL_OW 69
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24684: LD_INT 175
24686: PPUSH
24687: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24691: LD_EXP 12
24695: PUSH
24696: LD_EXP 3
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: LD_INT 2
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: IN
24711: OR
24712: IFFALSE 24735
// target := [ 68 , 108 , 1 ] else
24714: LD_ADDR_VAR 0 2
24718: PUSH
24719: LD_INT 68
24721: PUSH
24722: LD_INT 108
24724: PUSH
24725: LD_INT 1
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: LIST
24732: ST_TO_ADDR
24733: GO 24754
// target := [ 181 , 88 , 2 ] ;
24735: LD_ADDR_VAR 0 2
24739: PUSH
24740: LD_INT 181
24742: PUSH
24743: LD_INT 88
24745: PUSH
24746: LD_INT 2
24748: PUSH
24749: EMPTY
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_VAR 0 2
24763: PUSH
24764: LD_INT 1
24766: ARRAY
24767: PPUSH
24768: LD_VAR 0 2
24772: PUSH
24773: LD_INT 2
24775: ARRAY
24776: PPUSH
24777: CALL_OW 176
// if target [ 3 ] = 1 then
24781: LD_VAR 0 2
24785: PUSH
24786: LD_INT 3
24788: ARRAY
24789: PUSH
24790: LD_INT 1
24792: EQUAL
24793: IFFALSE 24809
// SayRadio ( Kurt , D12-Kurt-1 ) else
24795: LD_EXP 60
24799: PPUSH
24800: LD_STRING D12-Kurt-1
24802: PPUSH
24803: CALL_OW 94
24807: GO 24833
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24809: LD_EXP 60
24813: PPUSH
24814: LD_STRING D12a-Kurt-1
24816: PPUSH
24817: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24821: LD_EXP 74
24825: PPUSH
24826: LD_STRING D12a-Roth-1
24828: PPUSH
24829: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24833: LD_INT 350
24835: PPUSH
24836: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24840: LD_VAR 0 1
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_INT 8
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PUSH
24855: LD_INT 23
24857: PUSH
24858: LD_INT 2
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PUSH
24865: LD_INT 30
24867: PUSH
24868: LD_INT 3
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 1
24887: ARRAY
24888: PPUSH
24889: CALL_OW 228
// end ;
24893: PPOPN 2
24895: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24896: LD_EXP 60
24900: PPUSH
24901: CALL_OW 256
24905: PUSH
24906: LD_INT 999
24908: LESS
24909: PUSH
24910: LD_INT 22
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 21
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 23
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: PPUSH
24945: CALL_OW 69
24949: PUSH
24950: LD_INT 9
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 7
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_OWVAR 67
24968: ARRAY
24969: LESSEQUAL
24970: OR
24971: PUSH
24972: LD_INT 22
24974: PUSH
24975: LD_INT 8
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: LD_INT 34
24984: PUSH
24985: LD_INT 48
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PPUSH
24996: CALL_OW 69
25000: NOT
25001: AND
25002: PUSH
25003: LD_EXP 60
25007: PPUSH
25008: CALL_OW 302
25012: AND
25013: PUSH
25014: LD_INT 5
25016: PPUSH
25017: LD_INT 22
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PPUSH
25027: CALL_OW 70
25031: AND
25032: IFFALSE 25737
25034: GO 25036
25036: DISABLE
25037: LD_INT 0
25039: PPUSH
25040: PPUSH
25041: PPUSH
// begin DialogueOn ;
25042: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25046: LD_EXP 39
25050: PPUSH
25051: LD_STRING D13-JMM-1
25053: PPUSH
25054: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25058: LD_EXP 60
25062: PPUSH
25063: LD_STRING D13-Kurt-1
25065: PPUSH
25066: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25070: LD_EXP 39
25074: PPUSH
25075: LD_STRING D13-JMM-2
25077: PPUSH
25078: CALL_OW 88
// if FakeInfo then
25082: LD_EXP 12
25086: IFFALSE 25106
// begin Say ( Kurt , D13-Kurt-2 ) ;
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2
25095: PPUSH
25096: CALL_OW 88
// DialogueOff ;
25100: CALL_OW 7
// exit ;
25104: GO 25737
// end ; if not KurtStatus then
25106: LD_EXP 3
25110: NOT
25111: IFFALSE 25127
// Say ( Kurt , D13-Kurt-2b ) else
25113: LD_EXP 60
25117: PPUSH
25118: LD_STRING D13-Kurt-2b
25120: PPUSH
25121: CALL_OW 88
25125: GO 25139
// Say ( Kurt , D13-Kurt-2a ) ;
25127: LD_EXP 60
25131: PPUSH
25132: LD_STRING D13-Kurt-2a
25134: PPUSH
25135: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25139: LD_EXP 39
25143: PPUSH
25144: LD_STRING D13-JMM-3
25146: PPUSH
25147: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25151: LD_EXP 60
25155: PPUSH
25156: LD_STRING D13-Kurt-3
25158: PPUSH
25159: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25163: LD_EXP 39
25167: PPUSH
25168: LD_STRING D13-JMM-4
25170: PPUSH
25171: CALL_OW 88
// DialogueOff ;
25175: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25179: LD_STRING MlegionOut
25181: PPUSH
25182: CALL_OW 337
// legionDestroyed := true ;
25186: LD_ADDR_EXP 22
25190: PUSH
25191: LD_INT 1
25193: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25194: LD_INT 3
25196: PPUSH
25197: CALL 35398 0 1
// KillUnit ( Kozlov ) ;
25201: LD_EXP 61
25205: PPUSH
25206: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25210: LD_ADDR_VAR 0 1
25214: PUSH
25215: LD_INT 22
25217: PUSH
25218: LD_INT 8
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 23
25227: PUSH
25228: LD_INT 3
25230: PUSH
25231: EMPTY
25232: LIST
25233: LIST
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: LD_INT 21
25240: PUSH
25241: LD_INT 33
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: EMPTY
25253: LIST
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 69
25261: PUSH
25262: FOR_IN
25263: IFFALSE 25276
// KillUnit ( i ) ;
25265: LD_VAR 0 1
25269: PPUSH
25270: CALL_OW 66
25274: GO 25262
25276: POP
25277: POP
// ChangeSideFog ( 8 , 1 ) ;
25278: LD_INT 8
25280: PPUSH
25281: LD_INT 1
25283: PPUSH
25284: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25288: LD_ADDR_VAR 0 2
25292: PUSH
25293: LD_INT 22
25295: PUSH
25296: LD_INT 8
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 21
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 69
25321: PUSH
25322: LD_EXP 61
25326: PUSH
25327: LD_EXP 60
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: DIFF
25336: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25337: LD_VAR 0 2
25341: PUSH
25342: LD_INT 6
25344: PUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 4
25350: PUSH
25351: EMPTY
25352: LIST
25353: LIST
25354: LIST
25355: PUSH
25356: LD_OWVAR 67
25360: ARRAY
25361: GREATEREQUAL
25362: IFFALSE 25536
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25364: LD_ADDR_VAR 0 3
25368: PUSH
25369: LD_INT 6
25371: PUSH
25372: LD_INT 5
25374: PUSH
25375: LD_INT 4
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: LIST
25382: PUSH
25383: LD_OWVAR 67
25387: ARRAY
25388: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25389: LD_ADDR_VAR 0 1
25393: PUSH
25394: DOUBLE
25395: LD_VAR 0 2
25399: PUSH
25400: LD_VAR 0 3
25404: PUSH
25405: LD_INT 1
25407: PLUS
25408: MINUS
25409: INC
25410: ST_TO_ADDR
25411: LD_INT 1
25413: PUSH
25414: FOR_DOWNTO
25415: IFFALSE 25532
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25417: LD_ADDR_EXP 38
25421: PUSH
25422: LD_EXP 38
25426: PUSH
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: ADD
25438: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25439: LD_VAR 0 2
25443: PUSH
25444: LD_VAR 0 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 310
25454: IFFALSE 25471
// ComExitBuilding ( tmp [ i ] ) ;
25456: LD_VAR 0 2
25460: PUSH
25461: LD_VAR 0 1
25465: ARRAY
25466: PPUSH
25467: CALL_OW 122
// if IsInUnit ( i ) then
25471: LD_VAR 0 1
25475: PPUSH
25476: CALL_OW 310
25480: IFFALSE 25497
// ComExitVehicle ( tmp [ i ] ) ;
25482: LD_VAR 0 2
25486: PUSH
25487: LD_VAR 0 1
25491: ARRAY
25492: PPUSH
25493: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25497: LD_VAR 0 2
25501: PUSH
25502: LD_VAR 0 1
25506: ARRAY
25507: PPUSH
25508: LD_INT 34
25510: PUSH
25511: LD_INT 0
25513: PPUSH
25514: LD_INT 6
25516: PPUSH
25517: CALL_OW 12
25521: PLUS
25522: PPUSH
25523: LD_INT 1
25525: PPUSH
25526: CALL_OW 171
// end ;
25530: GO 25414
25532: POP
25533: POP
// end else
25534: GO 25546
// x := tmp ;
25536: LD_ADDR_VAR 0 3
25540: PUSH
25541: LD_VAR 0 2
25545: ST_TO_ADDR
// for i := tmp downto tmp - x do
25546: LD_ADDR_VAR 0 1
25550: PUSH
25551: DOUBLE
25552: LD_VAR 0 2
25556: INC
25557: ST_TO_ADDR
25558: LD_VAR 0 2
25562: PUSH
25563: LD_VAR 0 3
25567: MINUS
25568: PUSH
25569: FOR_DOWNTO
25570: IFFALSE 25624
// begin if IsInUnit ( tmp [ i ] ) then
25572: LD_VAR 0 2
25576: PUSH
25577: LD_VAR 0 1
25581: ARRAY
25582: PPUSH
25583: CALL_OW 310
25587: IFFALSE 25604
// ComExitVehicle ( tmp [ i ] ) ;
25589: LD_VAR 0 2
25593: PUSH
25594: LD_VAR 0 1
25598: ARRAY
25599: PPUSH
25600: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25604: LD_VAR 0 2
25608: PUSH
25609: LD_VAR 0 1
25613: ARRAY
25614: PPUSH
25615: LD_INT 1
25617: PPUSH
25618: CALL_OW 235
// end ;
25622: GO 25569
25624: POP
25625: POP
// SetSide ( Kurt , 1 ) ;
25626: LD_EXP 60
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25638: LD_INT 22
25640: PUSH
25641: LD_INT 8
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 21
25650: PUSH
25651: LD_INT 3
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PPUSH
25662: CALL_OW 69
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25674: LD_INT 8
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 1
25685: PPUSH
25686: CALL_OW 80
// wait ( 1 1$20 ) ;
25690: LD_INT 2800
25692: PPUSH
25693: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 37
25704: PPUSH
25705: LD_INT 1
25707: PPUSH
25708: LD_INT 0
25710: PPUSH
25711: CALL_OW 48
// wait ( 0 0$1 ) ;
25715: LD_INT 35
25717: PPUSH
25718: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25722: LD_EXP 62
25726: PPUSH
25727: LD_INT 60
25729: PPUSH
25730: LD_INT 95
25732: PPUSH
25733: CALL_OW 111
// end ;
25737: PPOPN 3
25739: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25740: LD_EXP 22
25744: NOT
25745: PUSH
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PUSH
25775: LD_INT 0
25777: EQUAL
25778: AND
25779: IFFALSE 25799
25781: GO 25783
25783: DISABLE
// begin legionDestroyed := true ;
25784: LD_ADDR_EXP 22
25788: PUSH
25789: LD_INT 1
25791: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25792: LD_STRING MlegionOut
25794: PPUSH
25795: CALL_OW 337
// end ;
25799: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25800: LD_EXP 38
25804: IFFALSE 25879
25806: GO 25808
25808: DISABLE
25809: LD_INT 0
25811: PPUSH
// begin enable ;
25812: ENABLE
// for i in legionEscapeUnits do
25813: LD_ADDR_VAR 0 1
25817: PUSH
25818: LD_EXP 38
25822: PUSH
25823: FOR_IN
25824: IFFALSE 25877
// begin if IsInArea ( i , legionEscapeArea ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: LD_INT 31
25833: PPUSH
25834: CALL_OW 308
25838: IFFALSE 25851
// RemoveUnit ( i ) else
25840: LD_VAR 0 1
25844: PPUSH
25845: CALL_OW 64
25849: GO 25875
// if not HasTask ( i ) then
25851: LD_VAR 0 1
25855: PPUSH
25856: CALL_OW 314
25860: NOT
25861: IFFALSE 25875
// ComMoveToArea ( i , legionEscapeArea ) ;
25863: LD_VAR 0 1
25867: PPUSH
25868: LD_INT 31
25870: PPUSH
25871: CALL_OW 113
// end ;
25875: GO 25823
25877: POP
25878: POP
// end ;
25879: PPOPN 1
25881: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25882: LD_INT 1
25884: PPUSH
25885: LD_EXP 62
25889: PPUSH
25890: CALL_OW 292
25894: IFFALSE 26192
25896: GO 25898
25898: DISABLE
25899: LD_INT 0
25901: PPUSH
// begin wait ( 0 0$2 ) ;
25902: LD_INT 70
25904: PPUSH
25905: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25909: LD_EXP 62
25913: PPUSH
25914: CALL_OW 87
// DialogueOn ;
25918: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25922: LD_EXP 39
25926: PPUSH
25927: LD_STRING D14-JMM-1
25929: PPUSH
25930: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25934: LD_EXP 62
25938: PPUSH
25939: LD_STRING D14-Friend-1
25941: PPUSH
25942: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25946: LD_EXP 39
25950: PPUSH
25951: LD_STRING D14-JMM-2
25953: PPUSH
25954: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25958: LD_EXP 62
25962: PPUSH
25963: LD_STRING D14-Friend-2
25965: PPUSH
25966: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25970: LD_EXP 39
25974: PPUSH
25975: LD_STRING D14-JMM-3
25977: PPUSH
25978: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25982: LD_EXP 62
25986: PPUSH
25987: LD_STRING D14-Friend-3
25989: PPUSH
25990: CALL_OW 88
// DialogueOff ;
25994: CALL_OW 7
// dec = Query ( Q14 ) ;
25998: LD_ADDR_VAR 0 1
26002: PUSH
26003: LD_STRING Q14
26005: PPUSH
26006: CALL_OW 97
26010: ST_TO_ADDR
// if dec = 1 then
26011: LD_VAR 0 1
26015: PUSH
26016: LD_INT 1
26018: EQUAL
26019: IFFALSE 26053
// begin DialogueOn ;
26021: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26025: LD_EXP 39
26029: PPUSH
26030: LD_STRING D14a-JMM-1
26032: PPUSH
26033: CALL_OW 88
// DialogueOff ;
26037: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26041: LD_EXP 62
26045: PPUSH
26046: LD_INT 1
26048: PPUSH
26049: CALL_OW 235
// end ; if dec = 2 then
26053: LD_VAR 0 1
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: IFFALSE 26114
// begin DialogueOn ;
26063: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26067: LD_EXP 39
26071: PPUSH
26072: LD_STRING D14b-JMM-1
26074: PPUSH
26075: CALL_OW 88
// DialogueOff ;
26079: CALL_OW 7
// wait ( 0 0$1 ) ;
26083: LD_INT 35
26085: PPUSH
26086: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_INT 9
26097: PPUSH
26098: LD_INT 2
26100: PPUSH
26101: CALL_OW 111
// AddComHold ( Friend ) ;
26105: LD_EXP 62
26109: PPUSH
26110: CALL_OW 200
// end ; if dec = 3 then
26114: LD_VAR 0 1
26118: PUSH
26119: LD_INT 3
26121: EQUAL
26122: IFFALSE 26192
// begin DialogueOn ;
26124: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26128: LD_EXP 39
26132: PPUSH
26133: LD_STRING D14c-JMM-1
26135: PPUSH
26136: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26140: LD_EXP 62
26144: PPUSH
26145: LD_STRING D14c-Friend-1
26147: PPUSH
26148: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26152: LD_EXP 39
26156: PPUSH
26157: LD_STRING D14c-JMM-2
26159: PPUSH
26160: CALL_OW 88
// DialogueOff ;
26164: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26168: LD_EXP 62
26172: PPUSH
26173: LD_INT 9
26175: PPUSH
26176: LD_INT 2
26178: PPUSH
26179: CALL_OW 111
// AddComHold ( Friend ) ;
26183: LD_EXP 62
26187: PPUSH
26188: CALL_OW 200
// end ; end ;
26192: PPOPN 1
26194: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26195: LD_INT 9
26197: PPUSH
26198: LD_INT 2
26200: PPUSH
26201: CALL_OW 428
26205: PUSH
26206: LD_EXP 62
26210: EQUAL
26211: PUSH
26212: LD_EXP 62
26216: PPUSH
26217: CALL_OW 255
26221: PUSH
26222: LD_INT 8
26224: EQUAL
26225: AND
26226: IFFALSE 26240
26228: GO 26230
26230: DISABLE
// RemoveUnit ( Friend ) ;
26231: LD_EXP 62
26235: PPUSH
26236: CALL_OW 64
26240: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26241: LD_EXP 14
26245: PUSH
26246: LD_INT 31500
26248: GREATEREQUAL
26249: PUSH
26250: LD_EXP 7
26254: AND
26255: PUSH
26256: LD_EXP 2
26260: AND
26261: IFFALSE 26691
26263: GO 26265
26265: DISABLE
26266: LD_INT 0
26268: PPUSH
26269: PPUSH
26270: PPUSH
// begin missionStage := 7 ;
26271: LD_ADDR_EXP 15
26275: PUSH
26276: LD_INT 7
26278: ST_TO_ADDR
// uc_side = 1 ;
26279: LD_ADDR_OWVAR 20
26283: PUSH
26284: LD_INT 1
26286: ST_TO_ADDR
// uc_nation = 1 ;
26287: LD_ADDR_OWVAR 21
26291: PUSH
26292: LD_INT 1
26294: ST_TO_ADDR
// for i = 1 to 5 do
26295: LD_ADDR_VAR 0 1
26299: PUSH
26300: DOUBLE
26301: LD_INT 1
26303: DEC
26304: ST_TO_ADDR
26305: LD_INT 5
26307: PUSH
26308: FOR_TO
26309: IFFALSE 26405
// begin vc_engine = 3 ;
26311: LD_ADDR_OWVAR 39
26315: PUSH
26316: LD_INT 3
26318: ST_TO_ADDR
// vc_control = 3 ;
26319: LD_ADDR_OWVAR 38
26323: PUSH
26324: LD_INT 3
26326: ST_TO_ADDR
// vc_chassis = 3 ;
26327: LD_ADDR_OWVAR 37
26331: PUSH
26332: LD_INT 3
26334: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26335: LD_ADDR_OWVAR 40
26339: PUSH
26340: LD_INT 5
26342: PUSH
26343: LD_INT 9
26345: PUSH
26346: LD_INT 7
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PPUSH
26357: LD_INT 3
26359: PPUSH
26360: CALL_OW 12
26364: ARRAY
26365: ST_TO_ADDR
// veh = CreateVehicle ;
26366: LD_ADDR_VAR 0 2
26370: PUSH
26371: CALL_OW 45
26375: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26376: LD_VAR 0 2
26380: PPUSH
26381: LD_INT 1
26383: PPUSH
26384: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26388: LD_VAR 0 2
26392: PPUSH
26393: LD_INT 19
26395: PPUSH
26396: LD_INT 0
26398: PPUSH
26399: CALL_OW 49
// end ;
26403: GO 26308
26405: POP
26406: POP
// vc_engine = 3 ;
26407: LD_ADDR_OWVAR 39
26411: PUSH
26412: LD_INT 3
26414: ST_TO_ADDR
// vc_control = 1 ;
26415: LD_ADDR_OWVAR 38
26419: PUSH
26420: LD_INT 1
26422: ST_TO_ADDR
// vc_chassis = 3 ;
26423: LD_ADDR_OWVAR 37
26427: PUSH
26428: LD_INT 3
26430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26431: LD_ADDR_OWVAR 40
26435: PUSH
26436: LD_INT 5
26438: PUSH
26439: LD_INT 9
26441: PUSH
26442: LD_INT 7
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 1
26452: PPUSH
26453: LD_INT 3
26455: PPUSH
26456: CALL_OW 12
26460: ARRAY
26461: ST_TO_ADDR
// vehG = CreateVehicle ;
26462: LD_ADDR_VAR 0 3
26466: PUSH
26467: CALL_OW 45
26471: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26472: LD_VAR 0 3
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26484: LD_VAR 0 3
26488: PPUSH
26489: LD_INT 19
26491: PPUSH
26492: LD_INT 0
26494: PPUSH
26495: CALL_OW 49
// if JMMGirl = 1 then
26499: LD_EXP 7
26503: PUSH
26504: LD_INT 1
26506: EQUAL
26507: IFFALSE 26563
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26509: LD_ADDR_EXP 40
26513: PUSH
26514: LD_STRING Joan
26516: PPUSH
26517: LD_INT 1
26519: PPUSH
26520: LD_STRING 14_
26522: PPUSH
26523: CALL 65472 0 3
26527: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26528: LD_EXP 40
26532: PPUSH
26533: LD_VAR 0 3
26537: PPUSH
26538: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26542: LD_VAR 0 3
26546: PPUSH
26547: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26551: LD_EXP 40
26555: PPUSH
26556: LD_STRING D10BW-Joan-1
26558: PPUSH
26559: CALL_OW 94
// end ; if JMMGirl = 2 then
26563: LD_EXP 7
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26627
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26573: LD_ADDR_EXP 42
26577: PUSH
26578: LD_STRING Lisa
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_STRING 14_
26586: PPUSH
26587: CALL 65472 0 3
26591: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26592: LD_EXP 42
26596: PPUSH
26597: LD_VAR 0 3
26601: PPUSH
26602: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26606: LD_VAR 0 3
26610: PPUSH
26611: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26615: LD_EXP 42
26619: PPUSH
26620: LD_STRING D10BW-Lisa-1
26622: PPUSH
26623: CALL_OW 94
// end ; if JMMGirl = 3 then
26627: LD_EXP 7
26631: PUSH
26632: LD_INT 3
26634: EQUAL
26635: IFFALSE 26691
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26637: LD_ADDR_EXP 54
26641: PUSH
26642: LD_STRING Connie
26644: PPUSH
26645: LD_INT 1
26647: PPUSH
26648: LD_STRING 14_
26650: PPUSH
26651: CALL 65472 0 3
26655: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26656: LD_EXP 54
26660: PPUSH
26661: LD_VAR 0 3
26665: PPUSH
26666: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26670: LD_VAR 0 3
26674: PPUSH
26675: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26679: LD_EXP 54
26683: PPUSH
26684: LD_STRING D10BW-Con-1
26686: PPUSH
26687: CALL_OW 94
// end ; end ;
26691: PPOPN 3
26693: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26694: LD_EXP 14
26698: PUSH
26699: LD_INT 94500
26701: GREATEREQUAL
26702: IFFALSE 27114
26704: GO 26706
26706: DISABLE
26707: LD_INT 0
26709: PPUSH
26710: PPUSH
26711: PPUSH
// begin tmp := PrepareStevensSquad ;
26712: LD_ADDR_VAR 0 3
26716: PUSH
26717: CALL 2222 0 0
26721: ST_TO_ADDR
// if not tmp then
26722: LD_VAR 0 3
26726: NOT
26727: IFFALSE 26731
// exit ;
26729: GO 27114
// uc_side := 1 ;
26731: LD_ADDR_OWVAR 20
26735: PUSH
26736: LD_INT 1
26738: ST_TO_ADDR
// uc_nation := 1 ;
26739: LD_ADDR_OWVAR 21
26743: PUSH
26744: LD_INT 1
26746: ST_TO_ADDR
// for i in tmp do
26747: LD_ADDR_VAR 0 1
26751: PUSH
26752: LD_VAR 0 3
26756: PUSH
26757: FOR_IN
26758: IFFALSE 26855
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26760: LD_INT 3
26762: PPUSH
26763: LD_INT 3
26765: PPUSH
26766: LD_INT 1
26768: PPUSH
26769: LD_INT 5
26771: PUSH
26772: LD_INT 9
26774: PUSH
26775: LD_INT 7
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PPUSH
26786: LD_INT 3
26788: PPUSH
26789: CALL_OW 12
26793: ARRAY
26794: PPUSH
26795: LD_INT 40
26797: PPUSH
26798: CALL 70336 0 5
// veh := CreateVehicle ;
26802: LD_ADDR_VAR 0 2
26806: PUSH
26807: CALL_OW 45
26811: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26812: LD_VAR 0 2
26816: PPUSH
26817: LD_INT 1
26819: PPUSH
26820: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26824: LD_VAR 0 2
26828: PPUSH
26829: LD_INT 19
26831: PPUSH
26832: LD_INT 0
26834: PPUSH
26835: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26839: LD_VAR 0 1
26843: PPUSH
26844: LD_VAR 0 2
26848: PPUSH
26849: CALL_OW 52
// end ;
26853: GO 26757
26855: POP
26856: POP
// missionStage := 8 ;
26857: LD_ADDR_EXP 15
26861: PUSH
26862: LD_INT 8
26864: ST_TO_ADDR
// DialogueOn ;
26865: CALL_OW 6
// if Stevens then
26869: LD_EXP 41
26873: IFFALSE 26987
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26875: LD_EXP 41
26879: PPUSH
26880: CALL_OW 310
26884: PPUSH
26885: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26889: LD_EXP 41
26893: PPUSH
26894: LD_STRING D8-Huck-1
26896: PPUSH
26897: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26901: LD_EXP 39
26905: PPUSH
26906: LD_STRING D8-JMM-1
26908: PPUSH
26909: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26913: LD_EXP 41
26917: PPUSH
26918: LD_STRING D8-Huck-2
26920: PPUSH
26921: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26925: LD_EXP 39
26929: PPUSH
26930: LD_STRING D8-JMM-2
26932: PPUSH
26933: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26937: LD_EXP 41
26941: PPUSH
26942: LD_STRING D8-Huck-3
26944: PPUSH
26945: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26949: LD_EXP 39
26953: PPUSH
26954: LD_STRING D8-JMM-3
26956: PPUSH
26957: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26961: LD_EXP 41
26965: PPUSH
26966: LD_STRING D8-Huck-4
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-4
26980: PPUSH
26981: CALL_OW 88
// end else
26985: GO 27097
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26987: LD_EXP 55
26991: PPUSH
26992: CALL_OW 310
26996: PPUSH
26997: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27001: LD_EXP 55
27005: PPUSH
27006: LD_STRING D8-Huck-1
27008: PPUSH
27009: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27013: LD_EXP 39
27017: PPUSH
27018: LD_STRING D8-JMM-1a
27020: PPUSH
27021: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27025: LD_EXP 55
27029: PPUSH
27030: LD_STRING D8-Huck-2
27032: PPUSH
27033: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27037: LD_EXP 39
27041: PPUSH
27042: LD_STRING D8-JMM-2
27044: PPUSH
27045: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27049: LD_EXP 55
27053: PPUSH
27054: LD_STRING D8-Huck-3
27056: PPUSH
27057: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27061: LD_EXP 39
27065: PPUSH
27066: LD_STRING D8-JMM-3
27068: PPUSH
27069: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27073: LD_EXP 55
27077: PPUSH
27078: LD_STRING D8-Huck-4
27080: PPUSH
27081: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D8-JMM-4
27092: PPUSH
27093: CALL_OW 88
// end ; DialogueOff ;
27097: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27101: LD_INT 25
27103: PPUSH
27104: LD_INT 1
27106: PPUSH
27107: LD_INT 1
27109: PPUSH
27110: CALL_OW 322
// end ;
27114: PPOPN 3
27116: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27117: LD_INT 1
27119: PPUSH
27120: LD_EXP 71
27124: PPUSH
27125: CALL_OW 292
27129: IFFALSE 27380
27131: GO 27133
27133: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27134: LD_EXP 71
27138: PPUSH
27139: CALL_OW 87
// DialogueOn ;
27143: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27147: LD_EXP 39
27151: PPUSH
27152: LD_STRING D10nB-JMM-1
27154: PPUSH
27155: CALL_OW 88
// if BurlakStatus = 1 then
27159: LD_EXP 9
27163: PUSH
27164: LD_INT 1
27166: EQUAL
27167: IFFALSE 27181
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27169: LD_EXP 70
27173: PPUSH
27174: LD_STRING D10nB-Vse-1a
27176: PPUSH
27177: CALL_OW 94
// end ; if BurlakStatus = 0 then
27181: LD_EXP 9
27185: PUSH
27186: LD_INT 0
27188: EQUAL
27189: IFFALSE 27203
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27191: LD_EXP 70
27195: PPUSH
27196: LD_STRING D10nB-Vse-1
27198: PPUSH
27199: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27203: LD_EXP 39
27207: PPUSH
27208: LD_STRING D10nB-JMM-2
27210: PPUSH
27211: CALL_OW 88
// if KappaStatus then
27215: LD_EXP 2
27219: IFFALSE 27233
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27221: LD_EXP 70
27225: PPUSH
27226: LD_STRING D10nB-Vse-5a
27228: PPUSH
27229: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27233: LD_EXP 2
27237: NOT
27238: PUSH
27239: LD_EXP 6
27243: PUSH
27244: LD_INT 0
27246: EQUAL
27247: AND
27248: IFFALSE 27376
// begin if JMMGirl = 1 then
27250: LD_EXP 7
27254: PUSH
27255: LD_INT 1
27257: EQUAL
27258: IFFALSE 27308
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27260: LD_EXP 70
27264: PPUSH
27265: LD_STRING D10nB-Vse-2
27267: PPUSH
27268: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27272: LD_EXP 39
27276: PPUSH
27277: LD_STRING D10nB-JMM-3
27279: PPUSH
27280: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27284: LD_EXP 70
27288: PPUSH
27289: LD_STRING D10nB-Vse-3
27291: PPUSH
27292: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27296: LD_EXP 39
27300: PPUSH
27301: LD_STRING D10nB-JMM-4
27303: PPUSH
27304: CALL_OW 88
// end ; if JMMGirl = 2 then
27308: LD_EXP 7
27312: PUSH
27313: LD_INT 2
27315: EQUAL
27316: IFFALSE 27342
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27318: LD_EXP 70
27322: PPUSH
27323: LD_STRING D10nB-Vse-4
27325: PPUSH
27326: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27330: LD_EXP 39
27334: PPUSH
27335: LD_STRING D10nB-JMM-5
27337: PPUSH
27338: CALL_OW 88
// end ; if JMMGirl = 3 then
27342: LD_EXP 7
27346: PUSH
27347: LD_INT 3
27349: EQUAL
27350: IFFALSE 27376
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27352: LD_EXP 70
27356: PPUSH
27357: LD_STRING D10nB-Vse-5
27359: PPUSH
27360: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27364: LD_EXP 39
27368: PPUSH
27369: LD_STRING D10nB-JMM-6
27371: PPUSH
27372: CALL_OW 88
// end ; end ; DialogueOff ;
27376: CALL_OW 7
// end ;
27380: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27381: LD_EXP 14
27385: PUSH
27386: LD_INT 115500
27388: GREATEREQUAL
27389: IFFALSE 27765
27391: GO 27393
27393: DISABLE
27394: LD_INT 0
27396: PPUSH
// begin missionStage := 10 ;
27397: LD_ADDR_EXP 15
27401: PUSH
27402: LD_INT 10
27404: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27405: LD_ADDR_VAR 0 1
27409: PUSH
27410: LD_INT 22
27412: PUSH
27413: LD_INT 1
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 23
27422: PUSH
27423: LD_INT 1
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 26
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 3
27442: PUSH
27443: LD_INT 25
27445: PUSH
27446: LD_INT 12
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 3
27459: PUSH
27460: LD_INT 25
27462: PUSH
27463: LD_INT 16
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: PPUSH
27481: CALL_OW 69
27485: PUSH
27486: LD_EXP 39
27490: PUSH
27491: LD_EXP 60
27495: PUSH
27496: LD_EXP 41
27500: PUSH
27501: LD_EXP 55
27505: PUSH
27506: LD_EXP 42
27510: PUSH
27511: LD_EXP 43
27515: PUSH
27516: LD_EXP 44
27520: PUSH
27521: LD_EXP 45
27525: PUSH
27526: LD_EXP 46
27530: PUSH
27531: LD_EXP 47
27535: PUSH
27536: LD_EXP 48
27540: PUSH
27541: LD_EXP 49
27545: PUSH
27546: LD_EXP 50
27550: PUSH
27551: LD_EXP 51
27555: PUSH
27556: LD_EXP 52
27560: PUSH
27561: LD_EXP 53
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: LIST
27572: LIST
27573: LIST
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: DIFF
27584: ST_TO_ADDR
// if not tmp and Brown then
27585: LD_VAR 0 1
27589: NOT
27590: PUSH
27591: LD_EXP 47
27595: AND
27596: IFFALSE 27611
// tmp := [ Brown ] ;
27598: LD_ADDR_VAR 0 1
27602: PUSH
27603: LD_EXP 47
27607: PUSH
27608: EMPTY
27609: LIST
27610: ST_TO_ADDR
// DialogueOn ;
27611: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27615: LD_VAR 0 1
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PPUSH
27624: LD_STRING D11-Sol1-1
27626: PPUSH
27627: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27631: LD_EXP 64
27635: PPUSH
27636: LD_STRING D11-Pla-1
27638: PPUSH
27639: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27643: LD_EXP 65
27647: PPUSH
27648: LD_STRING D11-Kov-1
27650: PPUSH
27651: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27655: LD_EXP 64
27659: PPUSH
27660: LD_STRING D11-Pla-2
27662: PPUSH
27663: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27667: LD_VAR 0 1
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_STRING D11-Sol1-2
27678: PPUSH
27679: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27683: LD_EXP 39
27687: PPUSH
27688: LD_STRING D11-JMM-2
27690: PPUSH
27691: CALL_OW 88
// DialogueOff ;
27695: CALL_OW 7
// allowBehemothConstruct := true ;
27699: LD_ADDR_EXP 25
27703: PUSH
27704: LD_INT 1
27706: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27707: LD_STRING M4
27709: PPUSH
27710: CALL_OW 337
// BuildBehemoths ;
27714: CALL 7693 0 0
// repeat wait ( 15 15$00 ) ;
27718: LD_INT 31500
27720: PPUSH
27721: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27725: LD_EXP 27
27729: IFFALSE 27733
// break ;
27731: GO 27765
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27733: LD_INT 267
27735: PPUSH
27736: CALL_OW 274
27740: PPUSH
27741: LD_INT 1
27743: PPUSH
27744: CALL_OW 275
27748: PUSH
27749: LD_INT 1000
27751: GREATEREQUAL
27752: IFFALSE 27758
// BuildBehemoths ;
27754: CALL 7693 0 0
// until not behemothBuilders ;
27758: LD_EXP 73
27762: NOT
27763: IFFALSE 27718
// end ;
27765: PPOPN 1
27767: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27768: LD_EXP 73
27772: NOT
27773: PUSH
27774: LD_EXP 28
27778: NOT
27779: AND
27780: PUSH
27781: LD_EXP 25
27785: AND
27786: IFFALSE 27806
27788: GO 27790
27790: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27791: LD_STRING M4a
27793: PPUSH
27794: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27798: LD_ADDR_EXP 27
27802: PUSH
27803: LD_INT 1
27805: ST_TO_ADDR
// end ;
27806: END
// every 0 0$1 trigger behemothDone do
27807: LD_EXP 28
27811: IFFALSE 27823
27813: GO 27815
27815: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27816: LD_STRING M4b
27818: PPUSH
27819: CALL_OW 337
27823: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27824: LD_EXP 29
27828: NOT
27829: IFFALSE 28025
27831: GO 27833
27833: DISABLE
27834: LD_INT 0
27836: PPUSH
27837: PPUSH
// begin enable ;
27838: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27839: LD_ADDR_VAR 0 1
27843: PUSH
27844: LD_INT 3
27846: PPUSH
27847: CALL 102271 0 1
27851: ST_TO_ADDR
// if not tmp and not behemothDone then
27852: LD_VAR 0 1
27856: NOT
27857: PUSH
27858: LD_EXP 28
27862: NOT
27863: AND
27864: IFFALSE 27900
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27866: LD_ADDR_VAR 0 1
27870: PUSH
27871: LD_INT 22
27873: PUSH
27874: LD_INT 3
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 30
27883: PUSH
27884: LD_INT 37
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PPUSH
27895: CALL_OW 69
27899: ST_TO_ADDR
// if not tmp then
27900: LD_VAR 0 1
27904: NOT
27905: IFFALSE 27909
// exit ;
27907: GO 28025
// for i in tmp do
27909: LD_ADDR_VAR 0 2
27913: PUSH
27914: LD_VAR 0 1
27918: PUSH
27919: FOR_IN
27920: IFFALSE 28023
// if See ( 1 , i ) then
27922: LD_INT 1
27924: PPUSH
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 292
27934: IFFALSE 28021
// begin if GetType ( i ) = unit_building then
27936: LD_VAR 0 2
27940: PPUSH
27941: CALL_OW 247
27945: PUSH
27946: LD_INT 3
27948: EQUAL
27949: IFFALSE 27987
// begin CenterNowOnUnits ( i ) ;
27951: LD_VAR 0 2
27955: PPUSH
27956: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27960: LD_EXP 39
27964: PPUSH
27965: LD_STRING D17a-JMM-1
27967: PPUSH
27968: CALL_OW 88
// seeBehemoth := true ;
27972: LD_ADDR_EXP 29
27976: PUSH
27977: LD_INT 1
27979: ST_TO_ADDR
// disable ;
27980: DISABLE
// exit ;
27981: POP
27982: POP
27983: GO 28025
// end else
27985: GO 28021
// begin CenterNowOnUnits ( i ) ;
27987: LD_VAR 0 2
27991: PPUSH
27992: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27996: LD_EXP 39
28000: PPUSH
28001: LD_STRING D17b-JMM-1
28003: PPUSH
28004: CALL_OW 88
// seeBehemoth := true ;
28008: LD_ADDR_EXP 29
28012: PUSH
28013: LD_INT 1
28015: ST_TO_ADDR
// disable ;
28016: DISABLE
// exit ;
28017: POP
28018: POP
28019: GO 28025
// end ; end ;
28021: GO 27919
28023: POP
28024: POP
// end ;
28025: PPOPN 2
28027: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28028: LD_EXP 14
28032: PUSH
28033: LD_INT 123200
28035: GREATEREQUAL
28036: IFFALSE 29212
28038: GO 28040
28040: DISABLE
28041: LD_INT 0
28043: PPUSH
28044: PPUSH
28045: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28046: LD_INT 2
28048: PPUSH
28049: LD_INT 23
28051: PUSH
28052: LD_INT 3
28054: PUSH
28055: LD_INT 3
28057: PUSH
28058: LD_INT 48
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: PUSH
28067: EMPTY
28068: LIST
28069: PPUSH
28070: CALL 59075 0 2
// repeat wait ( 0 0$1 ) ;
28074: LD_INT 35
28076: PPUSH
28077: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28081: LD_INT 22
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 34
28093: PUSH
28094: LD_INT 48
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PPUSH
28105: CALL_OW 69
28109: IFFALSE 28074
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28111: LD_ADDR_VAR 0 1
28115: PUSH
28116: LD_INT 22
28118: PUSH
28119: LD_INT 3
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 34
28128: PUSH
28129: LD_INT 48
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PPUSH
28140: CALL_OW 69
28144: PUSH
28145: LD_INT 1
28147: ARRAY
28148: ST_TO_ADDR
// missionStage := 12 ;
28149: LD_ADDR_EXP 15
28153: PUSH
28154: LD_INT 12
28156: ST_TO_ADDR
// platonovHasBomb := true ;
28157: LD_ADDR_EXP 30
28161: PUSH
28162: LD_INT 1
28164: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_INT 181
28172: PPUSH
28173: LD_INT 86
28175: PPUSH
28176: CALL_OW 171
// AddComHold ( bomb ) ;
28180: LD_VAR 0 1
28184: PPUSH
28185: CALL_OW 200
// wait ( 0 0$10 ) ;
28189: LD_INT 350
28191: PPUSH
28192: CALL_OW 67
// DialogueOn ;
28196: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28200: LD_EXP 64
28204: PPUSH
28205: LD_STRING D15-Pla-1
28207: PPUSH
28208: CALL_OW 94
// dec = Query ( Q15a ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_STRING Q15a
28219: PPUSH
28220: CALL_OW 97
28224: ST_TO_ADDR
// if dec = 1 then
28225: LD_VAR 0 2
28229: PUSH
28230: LD_INT 1
28232: EQUAL
28233: IFFALSE 28256
// begin Say ( JMM , D15a-JMM-1 ) ;
28235: LD_EXP 39
28239: PPUSH
28240: LD_STRING D15a-JMM-1
28242: PPUSH
28243: CALL_OW 88
// YouLost ( Surrender ) ;
28247: LD_STRING Surrender
28249: PPUSH
28250: CALL_OW 104
// exit ;
28254: GO 29212
// end ; if dec = 2 then
28256: LD_VAR 0 2
28260: PUSH
28261: LD_INT 2
28263: EQUAL
28264: IFFALSE 28333
// begin Say ( JMM , D15b-JMM-1 ) ;
28266: LD_EXP 39
28270: PPUSH
28271: LD_STRING D15b-JMM-1
28273: PPUSH
28274: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28278: LD_EXP 64
28282: PPUSH
28283: LD_STRING D15b-Pla-1
28285: PPUSH
28286: CALL_OW 94
// DialogueOff ;
28290: CALL_OW 7
// wait ( 3 3$00 ) ;
28294: LD_INT 6300
28296: PPUSH
28297: CALL_OW 67
// DialogueOn ;
28301: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28305: LD_EXP 39
28309: PPUSH
28310: LD_STRING D15d-JMM-1a
28312: PPUSH
28313: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28317: LD_EXP 64
28321: PPUSH
28322: LD_STRING D15d-Pla-1
28324: PPUSH
28325: CALL_OW 94
// DialogueOff ;
28329: CALL_OW 7
// end ; if dec = 3 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 3
28340: EQUAL
28341: IFFALSE 28395
// begin Say ( JMM , D15c-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15c-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15c-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// wait ( 0 0$15 ) ;
28371: LD_INT 525
28373: PPUSH
28374: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28378: LD_VAR 0 1
28382: PPUSH
28383: LD_INT 60
28385: PPUSH
28386: LD_INT 95
28388: PPUSH
28389: CALL_OW 116
// exit ;
28393: GO 29212
// end ; if dec = 4 then
28395: LD_VAR 0 2
28399: PUSH
28400: LD_INT 4
28402: EQUAL
28403: IFFALSE 28433
// begin Say ( JMM , D15d-JMM-1 ) ;
28405: LD_EXP 39
28409: PPUSH
28410: LD_STRING D15d-JMM-1
28412: PPUSH
28413: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28417: LD_EXP 64
28421: PPUSH
28422: LD_STRING D15d-Pla-1
28424: PPUSH
28425: CALL_OW 94
// DialogueOff ;
28429: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28433: LD_EXP 62
28437: PPUSH
28438: CALL_OW 302
28442: PUSH
28443: LD_EXP 62
28447: PPUSH
28448: CALL_OW 255
28452: PUSH
28453: LD_INT 1
28455: EQUAL
28456: AND
28457: PUSH
28458: LD_INT 22
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 34
28470: PUSH
28471: LD_INT 8
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PPUSH
28482: CALL_OW 69
28486: NOT
28487: AND
28488: IFFALSE 29113
// begin SetSide ( Friend , 8 ) ;
28490: LD_EXP 62
28494: PPUSH
28495: LD_INT 8
28497: PPUSH
28498: CALL_OW 235
// if IsInUnit ( Friend ) then
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 310
28511: IFFALSE 28522
// ComExitBuilding ( Friend ) ;
28513: LD_EXP 62
28517: PPUSH
28518: CALL_OW 122
// if IsDriver ( Friend ) then
28522: LD_EXP 62
28526: PPUSH
28527: CALL 99816 0 1
28531: IFFALSE 28542
// ComExitVehicle ( Friend ) ;
28533: LD_EXP 62
28537: PPUSH
28538: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28542: LD_EXP 62
28546: PPUSH
28547: LD_INT 9
28549: PPUSH
28550: LD_INT 2
28552: PPUSH
28553: CALL_OW 171
// wait ( 0 0$05 ) ;
28557: LD_INT 175
28559: PPUSH
28560: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28564: LD_EXP 62
28568: PPUSH
28569: CALL_OW 87
// DialogueOn ;
28573: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28577: LD_EXP 39
28581: PPUSH
28582: LD_STRING D16-JMM-1
28584: PPUSH
28585: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28589: LD_EXP 62
28593: PPUSH
28594: LD_STRING D16-Friend-1
28596: PPUSH
28597: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28601: LD_EXP 39
28605: PPUSH
28606: LD_STRING D16-JMM-2
28608: PPUSH
28609: CALL_OW 88
// DialogueOff ;
28613: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28617: LD_EXP 62
28621: PPUSH
28622: LD_INT 1
28624: PPUSH
28625: CALL_OW 235
// ComHold ( Friend ) ;
28629: LD_EXP 62
28633: PPUSH
28634: CALL_OW 140
// wait ( 0 0$20 ) ;
28638: LD_INT 700
28640: PPUSH
28641: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28645: LD_EXP 62
28649: PPUSH
28650: LD_INT 9
28652: PPUSH
28653: LD_INT 2
28655: PPUSH
28656: CALL_OW 297
28660: PUSH
28661: LD_INT 30
28663: LESS
28664: IFFALSE 28733
// begin SetSide ( Friend , 8 ) ;
28666: LD_EXP 62
28670: PPUSH
28671: LD_INT 8
28673: PPUSH
28674: CALL_OW 235
// if IsInUnit ( Friend ) then
28678: LD_EXP 62
28682: PPUSH
28683: CALL_OW 310
28687: IFFALSE 28698
// ComExitBuilding ( Friend ) ;
28689: LD_EXP 62
28693: PPUSH
28694: CALL_OW 122
// if IsDriver ( Friend ) then
28698: LD_EXP 62
28702: PPUSH
28703: CALL 99816 0 1
28707: IFFALSE 28718
// ComExitVehicle ( Friend ) ;
28709: LD_EXP 62
28713: PPUSH
28714: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28718: LD_EXP 62
28722: PPUSH
28723: LD_INT 9
28725: PPUSH
28726: LD_INT 2
28728: PPUSH
28729: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28733: LD_INT 1050
28735: PPUSH
28736: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28740: LD_INT 22
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 34
28752: PUSH
28753: LD_INT 8
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PPUSH
28764: CALL_OW 69
28768: NOT
28769: IFFALSE 29091
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28771: LD_ADDR_VAR 0 3
28775: PUSH
28776: LD_INT 22
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 26
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 3
28798: PUSH
28799: LD_INT 25
28801: PUSH
28802: LD_INT 12
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 25
28811: PUSH
28812: LD_INT 16
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: LIST
28828: PPUSH
28829: CALL_OW 69
28833: PUSH
28834: LD_EXP 39
28838: PUSH
28839: LD_EXP 41
28843: PUSH
28844: LD_EXP 55
28848: PUSH
28849: LD_EXP 42
28853: PUSH
28854: LD_EXP 43
28858: PUSH
28859: LD_EXP 44
28863: PUSH
28864: LD_EXP 45
28868: PUSH
28869: LD_EXP 46
28873: PUSH
28874: LD_EXP 47
28878: PUSH
28879: LD_EXP 48
28883: PUSH
28884: LD_EXP 49
28888: PUSH
28889: LD_EXP 50
28893: PUSH
28894: LD_EXP 51
28898: PUSH
28899: LD_EXP 52
28903: PUSH
28904: LD_EXP 53
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: DIFF
28926: ST_TO_ADDR
// DialogueOn ;
28927: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28931: LD_EXP 64
28935: PPUSH
28936: LD_STRING D16a-Pla-1
28938: PPUSH
28939: CALL_OW 94
// if Stevens then
28943: LD_EXP 41
28947: IFFALSE 28963
// Say ( Stevens , D16a-Huck-1 ) else
28949: LD_EXP 41
28953: PPUSH
28954: LD_STRING D16a-Huck-1
28956: PPUSH
28957: CALL_OW 88
28961: GO 29005
// if Baker then
28963: LD_EXP 55
28967: IFFALSE 28983
// Say ( Baker , D16a-Huck-1 ) else
28969: LD_EXP 55
28973: PPUSH
28974: LD_STRING D16a-Huck-1
28976: PPUSH
28977: CALL_OW 88
28981: GO 29005
// if tmp then
28983: LD_VAR 0 3
28987: IFFALSE 29005
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28989: LD_VAR 0 3
28993: PUSH
28994: LD_INT 1
28996: ARRAY
28997: PPUSH
28998: LD_STRING D16a-Sol1-1
29000: PPUSH
29001: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29005: LD_EXP 62
29009: PPUSH
29010: CALL_OW 255
29014: PUSH
29015: LD_INT 8
29017: EQUAL
29018: IFFALSE 29034
// Say ( JMM , D16a-JMM-1 ) else
29020: LD_EXP 39
29024: PPUSH
29025: LD_STRING D16a-JMM-1
29027: PPUSH
29028: CALL_OW 88
29032: GO 29070
// begin Say ( JMM , D16a-JMM-1a ) ;
29034: LD_EXP 39
29038: PPUSH
29039: LD_STRING D16a-JMM-1a
29041: PPUSH
29042: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29046: LD_EXP 62
29050: PPUSH
29051: LD_STRING D16a-Friend-1
29053: PPUSH
29054: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29058: LD_EXP 62
29062: PPUSH
29063: LD_INT 3
29065: PPUSH
29066: CALL_OW 235
// end ; DialogueOff ;
29070: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29074: LD_VAR 0 1
29078: PPUSH
29079: LD_INT 60
29081: PPUSH
29082: LD_INT 95
29084: PPUSH
29085: CALL_OW 116
// end else
29089: GO 29111
// begin DialogueOn ;
29091: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29095: LD_EXP 64
29099: PPUSH
29100: LD_STRING D16c-Pla-
29102: PPUSH
29103: CALL_OW 94
// DialogueOff ;
29107: CALL_OW 7
// end ; end else
29111: GO 29212
// begin wait ( 3 3$00 ) ;
29113: LD_INT 6300
29115: PPUSH
29116: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29120: LD_INT 22
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 34
29132: PUSH
29133: LD_INT 8
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PPUSH
29144: CALL_OW 69
29148: NOT
29149: IFFALSE 29192
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29151: LD_EXP 64
29155: PPUSH
29156: LD_STRING D16b-Pla-1
29158: PPUSH
29159: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29163: LD_EXP 39
29167: PPUSH
29168: LD_STRING D16b-JMM-
29170: PPUSH
29171: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29175: LD_VAR 0 1
29179: PPUSH
29180: LD_INT 60
29182: PPUSH
29183: LD_INT 95
29185: PPUSH
29186: CALL_OW 116
// end else
29190: GO 29212
// begin DialogueOn ;
29192: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29196: LD_EXP 64
29200: PPUSH
29201: LD_STRING D16c-Pla-
29203: PPUSH
29204: CALL_OW 94
// DialogueOff ;
29208: CALL_OW 7
// end ; end ; end ;
29212: PPOPN 3
29214: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29215: LD_EXP 14
29219: PUSH
29220: LD_INT 126000
29222: GREATEREQUAL
29223: PUSH
29224: LD_EXP 23
29228: NOT
29229: AND
29230: PUSH
29231: LD_EXP 74
29235: PPUSH
29236: CALL_OW 302
29240: AND
29241: IFFALSE 29599
29243: GO 29245
29245: DISABLE
29246: LD_INT 0
29248: PPUSH
// begin missionStage = 11 ;
29249: LD_ADDR_EXP 15
29253: PUSH
29254: LD_INT 11
29256: ST_TO_ADDR
// DialogueOn ;
29257: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29261: LD_EXP 74
29265: PPUSH
29266: LD_STRING D9-Roth-1
29268: PPUSH
29269: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29273: LD_EXP 39
29277: PPUSH
29278: LD_STRING D9-JMM-1
29280: PPUSH
29281: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29285: LD_EXP 74
29289: PPUSH
29290: LD_STRING D9-Roth-2
29292: PPUSH
29293: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29297: LD_EXP 74
29301: PPUSH
29302: LD_STRING D9-Roth-2a
29304: PPUSH
29305: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29309: LD_EXP 64
29313: PPUSH
29314: LD_STRING D9-Pla-2
29316: PPUSH
29317: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29321: LD_EXP 74
29325: PPUSH
29326: LD_STRING D9-Roth-3
29328: PPUSH
29329: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29333: LD_EXP 64
29337: PPUSH
29338: LD_STRING D9-Pla-3
29340: PPUSH
29341: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29345: LD_EXP 74
29349: PPUSH
29350: LD_STRING D9-Roth-4
29352: PPUSH
29353: CALL_OW 94
// dec = Query ( Q9 ) ;
29357: LD_ADDR_VAR 0 1
29361: PUSH
29362: LD_STRING Q9
29364: PPUSH
29365: CALL_OW 97
29369: ST_TO_ADDR
// if dec = 1 then
29370: LD_VAR 0 1
29374: PUSH
29375: LD_INT 1
29377: EQUAL
29378: IFFALSE 29392
// SayRadio ( Roth , D9a-Roth-1 ) ;
29380: LD_EXP 74
29384: PPUSH
29385: LD_STRING D9a-Roth-1
29387: PPUSH
29388: CALL_OW 94
// if dec = 2 then
29392: LD_VAR 0 1
29396: PUSH
29397: LD_INT 2
29399: EQUAL
29400: IFFALSE 29426
// begin Say ( JMM , D9b-JMM-1 ) ;
29402: LD_EXP 39
29406: PPUSH
29407: LD_STRING D9b-JMM-1
29409: PPUSH
29410: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29414: LD_EXP 74
29418: PPUSH
29419: LD_STRING D9b-Roth-1
29421: PPUSH
29422: CALL_OW 94
// end ; if dec = 3 then
29426: LD_VAR 0 1
29430: PUSH
29431: LD_INT 3
29433: EQUAL
29434: IFFALSE 29496
// begin Say ( JMM , D9c-JMM-1 ) ;
29436: LD_EXP 39
29440: PPUSH
29441: LD_STRING D9c-JMM-1
29443: PPUSH
29444: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29448: LD_EXP 74
29452: PPUSH
29453: LD_STRING D9c-Roth-1
29455: PPUSH
29456: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29460: LD_EXP 39
29464: PPUSH
29465: LD_STRING D9c-JMM-2
29467: PPUSH
29468: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29472: LD_EXP 74
29476: PPUSH
29477: LD_STRING D9c-Roth-2
29479: PPUSH
29480: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29484: LD_EXP 39
29488: PPUSH
29489: LD_STRING D9c-JMM-3
29491: PPUSH
29492: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29496: LD_EXP 74
29500: PPUSH
29501: LD_STRING D9c-Roth-3
29503: PPUSH
29504: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29508: LD_EXP 74
29512: PPUSH
29513: LD_STRING D9cont-Roth-1
29515: PPUSH
29516: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29520: LD_EXP 39
29524: PPUSH
29525: LD_STRING D9cont-JMM-1
29527: PPUSH
29528: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29532: LD_EXP 74
29536: PPUSH
29537: LD_STRING D9cont-Roth-2
29539: PPUSH
29540: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9cont-JMM-2
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9cont-Roth-3
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9cont-JMM-3
29575: PPUSH
29576: CALL_OW 88
// DialogueOff ;
29580: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29584: LD_STRING M3
29586: PPUSH
29587: CALL_OW 337
// allianceActive := true ;
29591: LD_ADDR_EXP 31
29595: PUSH
29596: LD_INT 1
29598: ST_TO_ADDR
// end ;
29599: PPOPN 1
29601: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29602: LD_INT 1
29604: PPUSH
29605: LD_INT 126
29607: PPUSH
29608: CALL_OW 292
29612: PUSH
29613: LD_EXP 64
29617: PPUSH
29618: CALL_OW 310
29622: AND
29623: IFFALSE 29703
29625: GO 29627
29627: DISABLE
29628: LD_INT 0
29630: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29631: LD_EXP 64
29635: PPUSH
29636: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29640: LD_ADDR_VAR 0 1
29644: PUSH
29645: LD_INT 4
29647: PPUSH
29648: LD_INT 22
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PPUSH
29658: CALL_OW 70
29662: PPUSH
29663: LD_EXP 64
29667: PPUSH
29668: CALL_OW 74
29672: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29673: LD_EXP 64
29677: PPUSH
29678: LD_VAR 0 1
29682: PUSH
29683: LD_INT 1
29685: ARRAY
29686: PPUSH
29687: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29691: LD_EXP 64
29695: PPUSH
29696: LD_STRING D18-Pla-1
29698: PPUSH
29699: CALL_OW 88
// end ;
29703: PPOPN 1
29705: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29706: LD_EXP 64
29710: PPUSH
29711: CALL_OW 301
29715: PUSH
29716: LD_EXP 67
29720: PPUSH
29721: CALL_OW 301
29725: AND
29726: PUSH
29727: LD_INT 22
29729: PUSH
29730: LD_INT 3
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: LD_INT 21
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 50
29749: PUSH
29750: EMPTY
29751: LIST
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: LIST
29757: PPUSH
29758: CALL_OW 69
29762: PUSH
29763: LD_INT 7
29765: PUSH
29766: LD_INT 8
29768: PUSH
29769: LD_INT 9
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: LIST
29776: PUSH
29777: LD_OWVAR 67
29781: ARRAY
29782: LESS
29783: AND
29784: IFFALSE 30555
29786: GO 29788
29788: DISABLE
29789: LD_INT 0
29791: PPUSH
29792: PPUSH
29793: PPUSH
29794: PPUSH
// begin MC_Kill ( 2 ) ;
29795: LD_INT 2
29797: PPUSH
29798: CALL 35398 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29802: LD_INT 1
29804: PPUSH
29805: LD_INT 3
29807: PPUSH
29808: LD_INT 1
29810: PPUSH
29811: LD_INT 1
29813: PPUSH
29814: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29818: LD_ADDR_VAR 0 1
29822: PUSH
29823: LD_INT 22
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 21
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 24
29845: PUSH
29846: LD_INT 900
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: LIST
29857: PPUSH
29858: CALL_OW 69
29862: PUSH
29863: FOR_IN
29864: IFFALSE 29895
// if GetSex ( i ) = sex_male then
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL_OW 258
29875: PUSH
29876: LD_INT 1
29878: EQUAL
29879: IFFALSE 29893
// begin tmp = i ;
29881: LD_ADDR_VAR 0 2
29885: PUSH
29886: LD_VAR 0 1
29890: ST_TO_ADDR
// break ;
29891: GO 29895
// end ;
29893: GO 29863
29895: POP
29896: POP
// if tmp = 0 then
29897: LD_VAR 0 2
29901: PUSH
29902: LD_INT 0
29904: EQUAL
29905: IFFALSE 29959
// begin uc_side = 3 ;
29907: LD_ADDR_OWVAR 20
29911: PUSH
29912: LD_INT 3
29914: ST_TO_ADDR
// uc_nation = 3 ;
29915: LD_ADDR_OWVAR 21
29919: PUSH
29920: LD_INT 3
29922: ST_TO_ADDR
// hc_name =  ;
29923: LD_ADDR_OWVAR 26
29927: PUSH
29928: LD_STRING 
29930: ST_TO_ADDR
// hc_gallery =  ;
29931: LD_ADDR_OWVAR 33
29935: PUSH
29936: LD_STRING 
29938: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29939: LD_INT 1
29941: PPUSH
29942: LD_INT 10
29944: PPUSH
29945: CALL_OW 381
// tmp = CreateHuman ;
29949: LD_ADDR_VAR 0 2
29953: PUSH
29954: CALL_OW 44
29958: ST_TO_ADDR
// end ; DialogueOn ;
29959: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29963: LD_VAR 0 2
29967: PPUSH
29968: LD_STRING DSurrenderRussians-RSol1-1a
29970: PPUSH
29971: CALL_OW 94
// DialogueOff ;
29975: CALL_OW 7
// russianDestroyed := true ;
29979: LD_ADDR_EXP 21
29983: PUSH
29984: LD_INT 1
29986: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29987: LD_INT 22
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 21
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PPUSH
30011: CALL_OW 69
30015: PPUSH
30016: CALL_OW 122
// wait ( 0 0$1 ) ;
30020: LD_INT 35
30022: PPUSH
30023: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30027: LD_INT 22
30029: PUSH
30030: LD_INT 3
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 21
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PPUSH
30051: CALL_OW 69
30055: PPUSH
30056: LD_INT 25
30058: PPUSH
30059: CALL_OW 173
// wait ( 0 0$10 ) ;
30063: LD_INT 350
30065: PPUSH
30066: CALL_OW 67
// PrepareOmarInvasion ;
30070: CALL 13903 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30074: LD_ADDR_VAR 0 2
30078: PUSH
30079: LD_EXP 92
30083: PPUSH
30084: CALL_OW 250
30088: PUSH
30089: LD_EXP 92
30093: PPUSH
30094: CALL_OW 251
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: LD_VAR 0 2
30116: PUSH
30117: LD_INT 2
30119: ARRAY
30120: PPUSH
30121: LD_INT 1
30123: PPUSH
30124: LD_INT 8
30126: NEG
30127: PPUSH
30128: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30132: LD_EXP 92
30136: PPUSH
30137: CALL_OW 87
// DialogueOn ;
30141: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30145: LD_EXP 39
30149: PPUSH
30150: LD_STRING D19-JMM-1
30152: PPUSH
30153: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_INT 22
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 26
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 25
30187: PUSH
30188: LD_INT 1
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 25
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 25
30207: PUSH
30208: LD_INT 3
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 25
30217: PUSH
30218: LD_INT 4
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 25
30227: PUSH
30228: LD_INT 5
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 25
30237: PUSH
30238: LD_INT 8
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: PPUSH
30259: CALL_OW 69
30263: PUSH
30264: LD_EXP 39
30268: PUSH
30269: LD_EXP 40
30273: PUSH
30274: LD_EXP 41
30278: PUSH
30279: LD_EXP 42
30283: PUSH
30284: LD_EXP 43
30288: PUSH
30289: LD_EXP 44
30293: PUSH
30294: LD_EXP 45
30298: PUSH
30299: LD_EXP 46
30303: PUSH
30304: LD_EXP 47
30308: PUSH
30309: LD_EXP 48
30313: PUSH
30314: LD_EXP 49
30318: PUSH
30319: LD_EXP 50
30323: PUSH
30324: LD_EXP 51
30328: PUSH
30329: LD_EXP 52
30333: PUSH
30334: LD_EXP 53
30338: PUSH
30339: LD_EXP 54
30343: PUSH
30344: LD_EXP 55
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: DIFF
30368: ST_TO_ADDR
// if tmp2 then
30369: LD_VAR 0 3
30373: IFFALSE 30391
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30375: LD_VAR 0 3
30379: PUSH
30380: LD_INT 1
30382: ARRAY
30383: PPUSH
30384: LD_STRING D19-Sol1-1
30386: PPUSH
30387: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30391: LD_EXP 39
30395: PPUSH
30396: LD_STRING D19-JMM-2
30398: PPUSH
30399: CALL_OW 88
// DialogueOff ;
30403: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30407: LD_VAR 0 2
30411: PUSH
30412: LD_INT 1
30414: ARRAY
30415: PPUSH
30416: LD_VAR 0 2
30420: PUSH
30421: LD_INT 2
30423: ARRAY
30424: PPUSH
30425: LD_INT 1
30427: PPUSH
30428: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30432: LD_STRING M5
30434: PPUSH
30435: CALL_OW 337
// omarOnMotherLode := false ;
30439: LD_ADDR_VAR 0 4
30443: PUSH
30444: LD_INT 0
30446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30447: LD_INT 35
30449: PPUSH
30450: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30454: LD_EXP 92
30458: PPUSH
30459: LD_INT 215
30461: PPUSH
30462: LD_INT 100
30464: PPUSH
30465: CALL_OW 297
30469: PUSH
30470: LD_INT 10
30472: LESS
30473: PUSH
30474: LD_VAR 0 4
30478: NOT
30479: AND
30480: IFFALSE 30514
// begin omarOnMotherLode := true ;
30482: LD_ADDR_VAR 0 4
30486: PUSH
30487: LD_INT 1
30489: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30490: LD_EXP 39
30494: PPUSH
30495: LD_STRING D19b-JMM-1
30497: PPUSH
30498: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30502: LD_EXP 92
30506: PPUSH
30507: LD_STRING DOmarContam-Omar-1
30509: PPUSH
30510: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30514: LD_EXP 92
30518: PPUSH
30519: CALL_OW 301
30523: IFFALSE 30447
// Say ( JMM , D19a-JMM-1 ) ;
30525: LD_EXP 39
30529: PPUSH
30530: LD_STRING D19a-JMM-1
30532: PPUSH
30533: CALL_OW 88
// if Heike then
30537: LD_EXP 93
30541: IFFALSE 30555
// Say ( Heike , D19a-Hke-1 ) ;
30543: LD_EXP 93
30547: PPUSH
30548: LD_STRING D19a-Hke-1
30550: PPUSH
30551: CALL_OW 88
// end ;
30555: PPOPN 4
30557: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30558: LD_INT 22
30560: PUSH
30561: LD_INT 3
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 21
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PPUSH
30582: CALL_OW 69
30586: PUSH
30587: LD_EXP 21
30591: AND
30592: IFFALSE 30660
30594: GO 30596
30596: DISABLE
30597: LD_INT 0
30599: PPUSH
30600: PPUSH
// begin enable ;
30601: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30602: LD_ADDR_VAR 0 2
30606: PUSH
30607: LD_INT 25
30609: PPUSH
30610: LD_INT 22
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PPUSH
30620: CALL_OW 70
30624: ST_TO_ADDR
// if not tmp then
30625: LD_VAR 0 2
30629: NOT
30630: IFFALSE 30634
// exit ;
30632: GO 30660
// for i in tmp do
30634: LD_ADDR_VAR 0 1
30638: PUSH
30639: LD_VAR 0 2
30643: PUSH
30644: FOR_IN
30645: IFFALSE 30658
// RemoveUnit ( i ) ;
30647: LD_VAR 0 1
30651: PPUSH
30652: CALL_OW 64
30656: GO 30644
30658: POP
30659: POP
// end ;
30660: PPOPN 2
30662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30663: LD_INT 22
30665: PUSH
30666: LD_INT 7
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 21
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PPUSH
30687: CALL_OW 69
30691: PUSH
30692: LD_INT 6
30694: LESS
30695: IFFALSE 31163
30697: GO 30699
30699: DISABLE
30700: LD_INT 0
30702: PPUSH
30703: PPUSH
// begin MC_Kill ( 1 ) ;
30704: LD_INT 1
30706: PPUSH
30707: CALL 35398 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30711: LD_INT 7
30713: PPUSH
30714: LD_INT 1
30716: PPUSH
30717: LD_INT 1
30719: PPUSH
30720: LD_INT 1
30722: PPUSH
30723: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30727: LD_ADDR_VAR 0 1
30731: PUSH
30732: LD_INT 22
30734: PUSH
30735: LD_INT 7
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 26
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PPUSH
30756: CALL_OW 69
30760: PUSH
30761: LD_EXP 74
30765: DIFF
30766: ST_TO_ADDR
// if tmp then
30767: LD_VAR 0 1
30771: IFFALSE 30789
// tmp := tmp [ 1 ] else
30773: LD_ADDR_VAR 0 1
30777: PUSH
30778: LD_VAR 0 1
30782: PUSH
30783: LD_INT 1
30785: ARRAY
30786: ST_TO_ADDR
30787: GO 30825
// begin uc_side := 7 ;
30789: LD_ADDR_OWVAR 20
30793: PUSH
30794: LD_INT 7
30796: ST_TO_ADDR
// uc_nation := 1 ;
30797: LD_ADDR_OWVAR 21
30801: PUSH
30802: LD_INT 1
30804: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 8
30810: PPUSH
30811: CALL_OW 384
// tmp := CreateHuman ;
30815: LD_ADDR_VAR 0 1
30819: PUSH
30820: CALL_OW 44
30824: ST_TO_ADDR
// end ; DialogueOn ;
30825: CALL_OW 6
// if IsOK ( Roth ) then
30829: LD_EXP 74
30833: PPUSH
30834: CALL_OW 302
30838: IFFALSE 30852
// Say ( JMM , DAb-JMM-1 ) ;
30840: LD_EXP 39
30844: PPUSH
30845: LD_STRING DAb-JMM-1
30847: PPUSH
30848: CALL_OW 88
// if IsOK ( Roth ) then
30852: LD_EXP 74
30856: PPUSH
30857: CALL_OW 302
30861: IFFALSE 30885
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30863: LD_EXP 74
30867: PPUSH
30868: LD_STRING DSurrenderAlliance-Roth-1
30870: PPUSH
30871: CALL_OW 88
// RothCaptured := true ;
30875: LD_ADDR_EXP 33
30879: PUSH
30880: LD_INT 1
30882: ST_TO_ADDR
// end else
30883: GO 30897
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30885: LD_VAR 0 1
30889: PPUSH
30890: LD_STRING DSurrenderAlliance-Sci1-1
30892: PPUSH
30893: CALL_OW 88
// DialogueOff ;
30897: CALL_OW 7
// allianceDestroyed := true ;
30901: LD_ADDR_EXP 23
30905: PUSH
30906: LD_INT 1
30908: ST_TO_ADDR
// if capturedUnit = 0 then
30909: LD_EXP 34
30913: PUSH
30914: LD_INT 0
30916: EQUAL
30917: IFFALSE 30926
// SetAchievement ( ACH_ALLIANCE ) ;
30919: LD_STRING ACH_ALLIANCE
30921: PPUSH
30922: CALL_OW 543
// if trueAmericans then
30926: LD_EXP 35
30930: IFFALSE 31006
// begin if trueAmericans = 1 then
30932: LD_EXP 35
30936: PUSH
30937: LD_INT 1
30939: EQUAL
30940: IFFALSE 30956
// Say ( JMM , DAb-JMM-1a ) else
30942: LD_EXP 39
30946: PPUSH
30947: LD_STRING DAb-JMM-1a
30949: PPUSH
30950: CALL_OW 88
30954: GO 30968
// Say ( JMM , DAb-JMM-1b ) ;
30956: LD_EXP 39
30960: PPUSH
30961: LD_STRING DAb-JMM-1b
30963: PPUSH
30964: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30968: LD_EXP 35
30972: PPUSH
30973: CALL_OW 87
// for i in trueAmericans do
30977: LD_ADDR_VAR 0 2
30981: PUSH
30982: LD_EXP 35
30986: PUSH
30987: FOR_IN
30988: IFFALSE 31004
// SetSide ( i , 1 ) ;
30990: LD_VAR 0 2
30994: PPUSH
30995: LD_INT 1
30997: PPUSH
30998: CALL_OW 235
31002: GO 30987
31004: POP
31005: POP
// end ; repeat wait ( 0 0$1 ) ;
31006: LD_INT 35
31008: PPUSH
31009: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31013: LD_ADDR_VAR 0 2
31017: PUSH
31018: LD_INT 22
31020: PUSH
31021: LD_INT 7
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 21
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL_OW 69
31046: PUSH
31047: FOR_IN
31048: IFFALSE 31130
// begin if IsInUnit ( i ) then
31050: LD_VAR 0 2
31054: PPUSH
31055: CALL_OW 310
31059: IFFALSE 31070
// ComExitBuilding ( i ) ;
31061: LD_VAR 0 2
31065: PPUSH
31066: CALL_OW 122
// if IsDriver ( i ) then
31070: LD_VAR 0 2
31074: PPUSH
31075: CALL 99816 0 1
31079: IFFALSE 31090
// ComExitVehicle ( i ) ;
31081: LD_VAR 0 2
31085: PPUSH
31086: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31090: LD_VAR 0 2
31094: PPUSH
31095: LD_INT 26
31097: PPUSH
31098: CALL_OW 308
31102: NOT
31103: IFFALSE 31119
// AddComMoveToArea ( i , allianceEscapeArea ) else
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_INT 26
31112: PPUSH
31113: CALL_OW 173
31117: GO 31128
// RemoveUnit ( i ) ;
31119: LD_VAR 0 2
31123: PPUSH
31124: CALL_OW 64
// end ;
31128: GO 31047
31130: POP
31131: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31132: LD_INT 22
31134: PUSH
31135: LD_INT 7
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 21
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PPUSH
31156: CALL_OW 69
31160: NOT
31161: IFFALSE 31006
// end ;
31163: PPOPN 2
31165: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31166: LD_INT 0
31168: PPUSH
31169: PPUSH
// if not unit then
31170: LD_VAR 0 1
31174: NOT
31175: IFFALSE 31179
// exit ;
31177: GO 32677
// DoNotAttack ( 7 , unit ) ;
31179: LD_INT 7
31181: PPUSH
31182: LD_VAR 0 1
31186: PPUSH
31187: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31191: LD_VAR 0 1
31195: PPUSH
31196: LD_INT 260
31198: PPUSH
31199: LD_INT 235
31201: PPUSH
31202: LD_INT 3
31204: PPUSH
31205: LD_INT 1
31207: PPUSH
31208: CALL_OW 483
// SetSide ( unit , 4 ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_INT 4
31219: PPUSH
31220: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31224: LD_ADDR_EXP 34
31228: PUSH
31229: LD_EXP 34
31233: PUSH
31234: LD_INT 1
31236: PLUS
31237: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31238: LD_INT 70
31240: PPUSH
31241: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31245: LD_INT 260
31247: PPUSH
31248: LD_INT 235
31250: PPUSH
31251: LD_INT 1
31253: PPUSH
31254: LD_INT 8
31256: NEG
31257: PPUSH
31258: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31262: LD_VAR 0 1
31266: PPUSH
31267: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31271: LD_VAR 0 1
31275: PPUSH
31276: LD_EXP 74
31280: PPUSH
31281: CALL_OW 119
// DialogueOn ;
31285: CALL_OW 6
// case unit of JMM :
31289: LD_VAR 0 1
31293: PUSH
31294: LD_EXP 39
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31305: LD_EXP 39
31309: PPUSH
31310: LD_STRING DA1-JMM-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31761
31319: LD_EXP 40
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31330: LD_EXP 40
31334: PPUSH
31335: LD_STRING DA1-Joan-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31761
31344: LD_EXP 42
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31355: LD_EXP 42
31359: PPUSH
31360: LD_STRING DA1-Lisa-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31761
31369: LD_EXP 43
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31380: LD_EXP 43
31384: PPUSH
31385: LD_STRING DA1-Don-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31761
31394: LD_EXP 50
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31405: LD_EXP 50
31409: PPUSH
31410: LD_STRING DA1-Corn-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31761
31419: LD_EXP 46
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31430: LD_EXP 46
31434: PPUSH
31435: LD_STRING DA1-Den-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31761
31444: LD_EXP 44
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31455: LD_EXP 44
31459: PPUSH
31460: LD_STRING DA1-Bobby-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31761
31469: LD_EXP 48
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31480: LD_EXP 48
31484: PPUSH
31485: LD_STRING DA1-Glad-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31761
31494: LD_EXP 45
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31505: LD_EXP 45
31509: PPUSH
31510: LD_STRING DA1-Cyrus-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31761
31519: LD_EXP 41
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31530: LD_EXP 41
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31761
31544: LD_EXP 55
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31555: LD_EXP 55
31559: PPUSH
31560: LD_STRING DA1-Huck-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31761
31569: LD_EXP 47
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31580: LD_EXP 47
31584: PPUSH
31585: LD_STRING DA1-Brown-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31761
31594: LD_EXP 51
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31605: LD_EXP 51
31609: PPUSH
31610: LD_STRING DA1-Gary-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31761
31619: LD_EXP 54
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31630: LD_EXP 54
31634: PPUSH
31635: LD_STRING DA1-Con-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31761
31644: LD_EXP 60
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31655: LD_EXP 60
31659: PPUSH
31660: LD_STRING DA1-Kurt-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31761
31669: LD_EXP 53
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31680: LD_EXP 53
31684: PPUSH
31685: LD_STRING DA1-Yam-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31761
31694: LD_EXP 52
31698: DOUBLE
31699: EQUAL
31700: IFTRUE 31704
31702: GO 31719
31704: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31705: LD_EXP 52
31709: PPUSH
31710: LD_STRING DA1-Frank-1
31712: PPUSH
31713: CALL_OW 91
31717: GO 31761
31719: POP
// begin if GetSex ( unit ) = sex_male then
31720: LD_VAR 0 1
31724: PPUSH
31725: CALL_OW 258
31729: PUSH
31730: LD_INT 1
31732: EQUAL
31733: IFFALSE 31749
// ForceSay ( unit , DA1-Sol1-1 ) else
31735: LD_VAR 0 1
31739: PPUSH
31740: LD_STRING DA1-Sol1-1
31742: PPUSH
31743: CALL_OW 91
31747: GO 31761
// ForceSay ( unit , DA1-FSol1-1 ) ;
31749: LD_VAR 0 1
31753: PPUSH
31754: LD_STRING DA1-FSol1-1
31756: PPUSH
31757: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31761: LD_EXP 74
31765: PPUSH
31766: LD_STRING DA-Roth-1
31768: PPUSH
31769: CALL_OW 88
// if capturedUnit = 1 then
31773: LD_EXP 34
31777: PUSH
31778: LD_INT 1
31780: EQUAL
31781: IFFALSE 31809
// begin Say ( Simms , DA-Sim-1 ) ;
31783: LD_EXP 75
31787: PPUSH
31788: LD_STRING DA-Sim-1
31790: PPUSH
31791: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31795: LD_EXP 74
31799: PPUSH
31800: LD_STRING DA-Roth-2
31802: PPUSH
31803: CALL_OW 88
// end else
31807: GO 31821
// Say ( Simms , DA-Sim-2 ) ;
31809: LD_EXP 75
31813: PPUSH
31814: LD_STRING DA-Sim-2
31816: PPUSH
31817: CALL_OW 88
// case unit of JMM :
31821: LD_VAR 0 1
31825: PUSH
31826: LD_EXP 39
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31837: LD_EXP 39
31841: PPUSH
31842: LD_STRING DA1-JMM-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32358
31851: LD_EXP 40
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31862: LD_EXP 40
31866: PPUSH
31867: LD_STRING DA1-Joan-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32358
31876: LD_EXP 42
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31887: LD_EXP 42
31891: PPUSH
31892: LD_STRING DA1-Lisa-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32358
31901: LD_EXP 43
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31912: LD_EXP 43
31916: PPUSH
31917: LD_STRING DA1-Don-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32358
31926: LD_EXP 50
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31937: LD_EXP 50
31941: PPUSH
31942: LD_STRING DA1-Corn-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32358
31951: LD_EXP 46
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31962: LD_EXP 46
31966: PPUSH
31967: LD_STRING DA1-Den-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32358
31976: LD_EXP 44
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31987: LD_EXP 44
31991: PPUSH
31992: LD_STRING DA1-Bobby-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32358
32001: LD_EXP 48
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32012: LD_EXP 48
32016: PPUSH
32017: LD_STRING DA1-Glad-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32358
32026: LD_EXP 45
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32037: LD_EXP 45
32041: PPUSH
32042: LD_STRING DA1-Cyrus-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32358
32051: LD_EXP 41
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32062: LD_EXP 41
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32358
32076: LD_EXP 55
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32087: LD_EXP 55
32091: PPUSH
32092: LD_STRING DA1-Huck-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32358
32101: LD_EXP 47
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32112: LD_EXP 47
32116: PPUSH
32117: LD_STRING DA1-Brown-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32358
32126: LD_EXP 51
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32137: LD_EXP 51
32141: PPUSH
32142: LD_STRING DA1-Gary-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32358
32151: LD_EXP 54
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32162: LD_EXP 54
32166: PPUSH
32167: LD_STRING DA1-Con-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32358
32176: LD_EXP 60
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32187: LD_EXP 60
32191: PPUSH
32192: LD_STRING DA1-Kurt-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32358
32201: LD_EXP 53
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32212: LD_EXP 53
32216: PPUSH
32217: LD_STRING DA1-Yam-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32358
32226: LD_EXP 52
32230: DOUBLE
32231: EQUAL
32232: IFTRUE 32236
32234: GO 32251
32236: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32237: LD_EXP 52
32241: PPUSH
32242: LD_STRING DA1-Frank-1a
32244: PPUSH
32245: CALL_OW 91
32249: GO 32358
32251: POP
// begin join := rand ( 0 , 1 ) ;
32252: LD_ADDR_VAR 0 3
32256: PUSH
32257: LD_INT 0
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 12
32267: ST_TO_ADDR
// if join then
32268: LD_VAR 0 3
32272: IFFALSE 32317
// begin if GetSex ( unit ) = sex_male then
32274: LD_VAR 0 1
32278: PPUSH
32279: CALL_OW 258
32283: PUSH
32284: LD_INT 1
32286: EQUAL
32287: IFFALSE 32303
// ForceSay ( unit , DA1-Sol1-1b ) else
32289: LD_VAR 0 1
32293: PPUSH
32294: LD_STRING DA1-Sol1-1b
32296: PPUSH
32297: CALL_OW 91
32301: GO 32315
// ForceSay ( unit , DA1-FSol1-1b ) ;
32303: LD_VAR 0 1
32307: PPUSH
32308: LD_STRING DA1-FSol1-1b
32310: PPUSH
32311: CALL_OW 91
// end else
32315: GO 32358
// begin if GetSex ( unit ) = sex_male then
32317: LD_VAR 0 1
32321: PPUSH
32322: CALL_OW 258
32326: PUSH
32327: LD_INT 1
32329: EQUAL
32330: IFFALSE 32346
// ForceSay ( unit , DA1-Sol1-1a ) else
32332: LD_VAR 0 1
32336: PPUSH
32337: LD_STRING DA1-Sol1-1a
32339: PPUSH
32340: CALL_OW 91
32344: GO 32358
// ForceSay ( unit , DA1-FSol1-1a ) ;
32346: LD_VAR 0 1
32350: PPUSH
32351: LD_STRING DA1-FSol1-1a
32353: PPUSH
32354: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32358: LD_VAR 0 1
32362: PUSH
32363: LD_EXP 39
32367: EQUAL
32368: IFFALSE 32379
// begin YouLost ( JMMCaptured ) ;
32370: LD_STRING JMMCaptured
32372: PPUSH
32373: CALL_OW 104
// exit ;
32377: GO 32677
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32379: LD_VAR 0 1
32383: PUSH
32384: LD_EXP 43
32388: PUSH
32389: LD_EXP 46
32393: PUSH
32394: LD_EXP 44
32398: PUSH
32399: LD_EXP 41
32403: PUSH
32404: LD_EXP 55
32408: PUSH
32409: LD_EXP 47
32413: PUSH
32414: LD_EXP 53
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: IN
32428: PUSH
32429: LD_VAR 0 3
32433: OR
32434: IFFALSE 32533
// begin Say ( Roth , DA-Roth-3 ) ;
32436: LD_EXP 74
32440: PPUSH
32441: LD_STRING DA-Roth-3
32443: PPUSH
32444: CALL_OW 88
// SetSide ( unit , 7 ) ;
32448: LD_VAR 0 1
32452: PPUSH
32453: LD_INT 7
32455: PPUSH
32456: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32460: LD_ADDR_EXP 116
32464: PUSH
32465: LD_EXP 116
32469: PPUSH
32470: LD_INT 1
32472: PPUSH
32473: LD_EXP 116
32477: PUSH
32478: LD_INT 1
32480: ARRAY
32481: PUSH
32482: LD_VAR 0 1
32486: ADD
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32493: LD_INT 260
32495: PPUSH
32496: LD_INT 235
32498: PPUSH
32499: LD_INT 1
32501: PPUSH
32502: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32506: LD_VAR 0 1
32510: PPUSH
32511: LD_INT 1000
32513: PPUSH
32514: CALL_OW 234
// DialogueOff ;
32518: CALL_OW 7
// ComFree ( unit ) ;
32522: LD_VAR 0 1
32526: PPUSH
32527: CALL_OW 139
// end else
32531: GO 32614
// begin Say ( Roth , DA-Roth-3a ) ;
32533: LD_EXP 74
32537: PPUSH
32538: LD_STRING DA-Roth-3a
32540: PPUSH
32541: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32545: LD_ADDR_EXP 35
32549: PUSH
32550: LD_EXP 35
32554: PUSH
32555: LD_VAR 0 1
32559: ADD
32560: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32561: LD_INT 260
32563: PPUSH
32564: LD_INT 235
32566: PPUSH
32567: LD_INT 1
32569: PPUSH
32570: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32574: LD_VAR 0 1
32578: PPUSH
32579: LD_INT 1000
32581: PPUSH
32582: CALL_OW 234
// DialogueOff ;
32586: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32590: LD_VAR 0 1
32594: PPUSH
32595: LD_INT 272
32597: PPUSH
32598: LD_INT 254
32600: PPUSH
32601: CALL_OW 111
// AddComHold ( unit ) ;
32605: LD_VAR 0 1
32609: PPUSH
32610: CALL_OW 200
// end ; if capturedUnit = 1 then
32614: LD_EXP 34
32618: PUSH
32619: LD_INT 1
32621: EQUAL
32622: IFFALSE 32677
// begin DialogueOn ;
32624: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32628: LD_EXP 39
32632: PPUSH
32633: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32637: LD_EXP 39
32641: PPUSH
32642: LD_STRING DAa-JMM-1
32644: PPUSH
32645: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32649: LD_EXP 39
32653: PPUSH
32654: LD_STRING DAa-JMM-1a
32656: PPUSH
32657: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32661: LD_EXP 39
32665: PPUSH
32666: LD_STRING DAa-JMM-1b
32668: PPUSH
32669: CALL_OW 88
// DialogueOff ;
32673: CALL_OW 7
// end ; end ;
32677: LD_VAR 0 2
32681: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32682: LD_EXP 15
32686: PUSH
32687: LD_INT 13
32689: GREATEREQUAL
32690: PUSH
32691: LD_INT 22
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 21
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PPUSH
32715: CALL_OW 69
32719: PUSH
32720: LD_INT 0
32722: EQUAL
32723: AND
32724: PUSH
32725: LD_INT 22
32727: PUSH
32728: LD_INT 2
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 33
32737: PUSH
32738: LD_INT 5
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 21
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 50
32757: PUSH
32758: EMPTY
32759: LIST
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: PPUSH
32767: CALL_OW 69
32771: PUSH
32772: LD_INT 0
32774: EQUAL
32775: AND
32776: PUSH
32777: LD_EXP 21
32781: AND
32782: PUSH
32783: LD_EXP 22
32787: AND
32788: PUSH
32789: LD_EXP 23
32793: AND
32794: IFFALSE 33443
32796: GO 32798
32798: DISABLE
32799: LD_INT 0
32801: PPUSH
32802: PPUSH
32803: PPUSH
// begin m1 := false ;
32804: LD_ADDR_VAR 0 1
32808: PUSH
32809: LD_INT 0
32811: ST_TO_ADDR
// m2 := false ;
32812: LD_ADDR_VAR 0 2
32816: PUSH
32817: LD_INT 0
32819: ST_TO_ADDR
// m3 := false ;
32820: LD_ADDR_VAR 0 3
32824: PUSH
32825: LD_INT 0
32827: ST_TO_ADDR
// if not bombExploded then
32828: LD_EXP 37
32832: NOT
32833: IFFALSE 32842
// SetAchievement ( ACH_SIBROCKET ) ;
32835: LD_STRING ACH_SIBROCKET
32837: PPUSH
32838: CALL_OW 543
// if tick <= 120 120$00 then
32842: LD_OWVAR 1
32846: PUSH
32847: LD_INT 252000
32849: LESSEQUAL
32850: IFFALSE 32866
// begin wait ( 3 ) ;
32852: LD_INT 3
32854: PPUSH
32855: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32859: LD_STRING ACH_ASPEED_15
32861: PPUSH
32862: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32866: LD_EXP 39
32870: PPUSH
32871: CALL_OW 87
// music_class := 5 ;
32875: LD_ADDR_OWVAR 72
32879: PUSH
32880: LD_INT 5
32882: ST_TO_ADDR
// music_nat := 5 ;
32883: LD_ADDR_OWVAR 71
32887: PUSH
32888: LD_INT 5
32890: ST_TO_ADDR
// DialogueOn ;
32891: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32895: LD_EXP 39
32899: PPUSH
32900: LD_STRING D20-JMM-1
32902: PPUSH
32903: CALL_OW 88
// if IsOK ( Joan ) then
32907: LD_EXP 40
32911: PPUSH
32912: CALL_OW 302
32916: IFFALSE 32930
// Say ( Joan , D20-Joan-1 ) ;
32918: LD_EXP 40
32922: PPUSH
32923: LD_STRING D20-Joan-1
32925: PPUSH
32926: CALL_OW 88
// if IsOk ( Lisa ) then
32930: LD_EXP 42
32934: PPUSH
32935: CALL_OW 302
32939: IFFALSE 32953
// Say ( Lisa , D20-Lisa-1 ) ;
32941: LD_EXP 42
32945: PPUSH
32946: LD_STRING D20-Lisa-1
32948: PPUSH
32949: CALL_OW 88
// if IsOk ( Donaldson ) then
32953: LD_EXP 43
32957: PPUSH
32958: CALL_OW 302
32962: IFFALSE 32976
// Say ( Donaldson , D20-Don-1 ) ;
32964: LD_EXP 43
32968: PPUSH
32969: LD_STRING D20-Don-1
32971: PPUSH
32972: CALL_OW 88
// if IsOK ( Cornel ) then
32976: LD_EXP 50
32980: PPUSH
32981: CALL_OW 302
32985: IFFALSE 32999
// Say ( Cornel , D20-Corn-1 ) ;
32987: LD_EXP 50
32991: PPUSH
32992: LD_STRING D20-Corn-1
32994: PPUSH
32995: CALL_OW 88
// if IsOk ( Denis ) then
32999: LD_EXP 46
33003: PPUSH
33004: CALL_OW 302
33008: IFFALSE 33022
// Say ( Denis , D20-Den-1 ) ;
33010: LD_EXP 46
33014: PPUSH
33015: LD_STRING D20-Den-1
33017: PPUSH
33018: CALL_OW 88
// if IsOk ( Bobby ) then
33022: LD_EXP 44
33026: PPUSH
33027: CALL_OW 302
33031: IFFALSE 33045
// Say ( Bobby , D20-Bobby-1 ) ;
33033: LD_EXP 44
33037: PPUSH
33038: LD_STRING D20-Bobby-1
33040: PPUSH
33041: CALL_OW 88
// if IsOk ( Gladstone ) then
33045: LD_EXP 48
33049: PPUSH
33050: CALL_OW 302
33054: IFFALSE 33068
// Say ( Gladstone , D20-Glad-1 ) ;
33056: LD_EXP 48
33060: PPUSH
33061: LD_STRING D20-Glad-1
33063: PPUSH
33064: CALL_OW 88
// if IsOk ( Cyrus ) then
33068: LD_EXP 45
33072: PPUSH
33073: CALL_OW 302
33077: IFFALSE 33091
// Say ( Cyrus , D20-Cyrus-1 ) ;
33079: LD_EXP 45
33083: PPUSH
33084: LD_STRING D20-Cyrus-1
33086: PPUSH
33087: CALL_OW 88
// if IsOk ( Stevens ) then
33091: LD_EXP 41
33095: PPUSH
33096: CALL_OW 302
33100: IFFALSE 33114
// Say ( Stevens , D20-Huck-1 ) ;
33102: LD_EXP 41
33106: PPUSH
33107: LD_STRING D20-Huck-1
33109: PPUSH
33110: CALL_OW 88
// if IsOk ( Brown ) then
33114: LD_EXP 47
33118: PPUSH
33119: CALL_OW 302
33123: IFFALSE 33137
// Say ( Brown , D20-Brown-1 ) ;
33125: LD_EXP 47
33129: PPUSH
33130: LD_STRING D20-Brown-1
33132: PPUSH
33133: CALL_OW 88
// if IsOk ( Gary ) then
33137: LD_EXP 51
33141: PPUSH
33142: CALL_OW 302
33146: IFFALSE 33160
// Say ( Gary , D20-Gary-1 ) ;
33148: LD_EXP 51
33152: PPUSH
33153: LD_STRING D20-Gary-1
33155: PPUSH
33156: CALL_OW 88
// if IsOk ( Connie ) then
33160: LD_EXP 54
33164: PPUSH
33165: CALL_OW 302
33169: IFFALSE 33183
// Say ( Connie , D20-Con-1 ) ;
33171: LD_EXP 54
33175: PPUSH
33176: LD_STRING D20-Con-1
33178: PPUSH
33179: CALL_OW 88
// if IsOk ( Kurt ) then
33183: LD_EXP 60
33187: PPUSH
33188: CALL_OW 302
33192: IFFALSE 33206
// Say ( Kurt , D20-Kurt-1 ) ;
33194: LD_EXP 60
33198: PPUSH
33199: LD_STRING D20-Kurt-1
33201: PPUSH
33202: CALL_OW 88
// if IsOk ( Kikuchi ) then
33206: LD_EXP 53
33210: PPUSH
33211: CALL_OW 302
33215: IFFALSE 33229
// Say ( Kikuchi , D20-Yam-1 ) ;
33217: LD_EXP 53
33221: PPUSH
33222: LD_STRING D20-Yam-1
33224: PPUSH
33225: CALL_OW 88
// if IsOk ( Frank ) then
33229: LD_EXP 52
33233: PPUSH
33234: CALL_OW 302
33238: IFFALSE 33252
// Say ( Frank , D20-Frank-1 ) ;
33240: LD_EXP 52
33244: PPUSH
33245: LD_STRING D20-Frank-1
33247: PPUSH
33248: CALL_OW 88
// DialogueOff ;
33252: CALL_OW 7
// if RothCaptured then
33256: LD_EXP 33
33260: IFFALSE 33282
// begin m1 := true ;
33262: LD_ADDR_VAR 0 1
33266: PUSH
33267: LD_INT 1
33269: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33270: LD_STRING Roth
33272: PPUSH
33273: LD_INT 1
33275: PPUSH
33276: CALL_OW 101
// end else
33280: GO 33293
// AddMedal ( Roth , - 1 ) ;
33282: LD_STRING Roth
33284: PPUSH
33285: LD_INT 1
33287: NEG
33288: PPUSH
33289: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33293: LD_EXP 25
33297: NOT
33298: PUSH
33299: LD_EXP 27
33303: OR
33304: IFFALSE 33326
// begin m2 := true ;
33306: LD_ADDR_VAR 0 2
33310: PUSH
33311: LD_INT 1
33313: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33314: LD_STRING Project
33316: PPUSH
33317: LD_INT 1
33319: PPUSH
33320: CALL_OW 101
// end else
33324: GO 33337
// AddMedal ( Project , - 1 ) ;
33326: LD_STRING Project
33328: PPUSH
33329: LD_INT 1
33331: NEG
33332: PPUSH
33333: CALL_OW 101
// if lostCounter = 0 then
33337: LD_EXP 32
33341: PUSH
33342: LD_INT 0
33344: EQUAL
33345: IFFALSE 33367
// begin m3 := true ;
33347: LD_ADDR_VAR 0 3
33351: PUSH
33352: LD_INT 1
33354: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33355: LD_STRING NoLosses
33357: PPUSH
33358: LD_INT 1
33360: PPUSH
33361: CALL_OW 101
// end else
33365: GO 33378
// AddMedal ( NoLosses , - 1 ) ;
33367: LD_STRING NoLosses
33369: PPUSH
33370: LD_INT 1
33372: NEG
33373: PPUSH
33374: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33378: LD_VAR 0 1
33382: PUSH
33383: LD_VAR 0 2
33387: AND
33388: PUSH
33389: LD_VAR 0 3
33393: AND
33394: PUSH
33395: LD_OWVAR 67
33399: PUSH
33400: LD_INT 3
33402: EQUAL
33403: AND
33404: IFFALSE 33416
// SetAchievementEX ( ACH_AMER , 15 ) ;
33406: LD_STRING ACH_AMER
33408: PPUSH
33409: LD_INT 15
33411: PPUSH
33412: CALL_OW 564
// GiveMedals ( MAIN ) ;
33416: LD_STRING MAIN
33418: PPUSH
33419: CALL_OW 102
// music_class := 4 ;
33423: LD_ADDR_OWVAR 72
33427: PUSH
33428: LD_INT 4
33430: ST_TO_ADDR
// music_nat := 1 ;
33431: LD_ADDR_OWVAR 71
33435: PUSH
33436: LD_INT 1
33438: ST_TO_ADDR
// YouWin ;
33439: CALL_OW 103
// end ; end_of_file
33443: PPOPN 3
33445: END
// export function CustomEvent ( event ) ; begin
33446: LD_INT 0
33448: PPUSH
// end ;
33449: LD_VAR 0 2
33453: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33454: LD_VAR 0 1
33458: PUSH
33459: LD_INT 1
33461: EQUAL
33462: PUSH
33463: LD_VAR 0 2
33467: PUSH
33468: LD_INT 4
33470: EQUAL
33471: AND
33472: PUSH
33473: LD_EXP 58
33477: PPUSH
33478: CALL_OW 300
33482: AND
33483: IFFALSE 33499
// begin wait ( 0 0$2 ) ;
33485: LD_INT 70
33487: PPUSH
33488: CALL_OW 67
// YouLost ( Dismissed ) ;
33492: LD_STRING Dismissed
33494: PPUSH
33495: CALL_OW 104
// end ; end ;
33499: PPOPN 2
33501: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33502: LD_VAR 0 2
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: LD_INT 18
33514: PPUSH
33515: CALL_OW 309
33519: IFFALSE 33528
// YouLost ( Motherlode3 ) ;
33521: LD_STRING Motherlode3
33523: PPUSH
33524: CALL_OW 104
// end ;
33528: PPOPN 3
33530: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33531: LD_EXP 27
33535: NOT
33536: IFFALSE 33546
// behemothDone := true ;
33538: LD_ADDR_EXP 28
33542: PUSH
33543: LD_INT 1
33545: ST_TO_ADDR
// end ;
33546: PPOPN 1
33548: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33549: LD_VAR 0 1
33553: PPUSH
33554: CALL_OW 255
33558: PUSH
33559: LD_INT 1
33561: EQUAL
33562: IFFALSE 33572
// bombExploded := true ;
33564: LD_ADDR_EXP 37
33568: PUSH
33569: LD_INT 1
33571: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33572: LD_VAR 0 1
33576: PPUSH
33577: CALL_OW 255
33581: PUSH
33582: LD_INT 1
33584: EQUAL
33585: PUSH
33586: LD_EXP 30
33590: AND
33591: PUSH
33592: LD_INT 22
33594: PUSH
33595: LD_INT 3
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 34
33604: PUSH
33605: LD_INT 48
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PPUSH
33616: CALL_OW 69
33620: AND
33621: PUSH
33622: LD_INT 22
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 34
33634: PUSH
33635: LD_INT 8
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PPUSH
33646: CALL_OW 69
33650: NOT
33651: AND
33652: IFFALSE 33704
// begin wait ( 0 0$5 ) ;
33654: LD_INT 175
33656: PPUSH
33657: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33661: LD_INT 22
33663: PUSH
33664: LD_INT 3
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 34
33673: PUSH
33674: LD_INT 48
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: EMPTY
33682: LIST
33683: LIST
33684: PPUSH
33685: CALL_OW 69
33689: PUSH
33690: LD_INT 1
33692: ARRAY
33693: PPUSH
33694: LD_INT 60
33696: PPUSH
33697: LD_INT 95
33699: PPUSH
33700: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33704: LD_VAR 0 2
33708: PPUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: LD_INT 18
33716: PPUSH
33717: CALL_OW 309
33721: IFFALSE 33781
// begin if GetSide ( unit ) = 1 then
33723: LD_VAR 0 1
33727: PPUSH
33728: CALL_OW 255
33732: PUSH
33733: LD_INT 1
33735: EQUAL
33736: IFFALSE 33752
// begin wait ( 0 0$6 ) ;
33738: LD_INT 210
33740: PPUSH
33741: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33745: LD_STRING Motherlode2
33747: PPUSH
33748: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33752: LD_VAR 0 1
33756: PPUSH
33757: CALL_OW 255
33761: PUSH
33762: LD_INT 8
33764: EQUAL
33765: IFFALSE 33781
// begin wait ( 0 0$6 ) ;
33767: LD_INT 210
33769: PPUSH
33770: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33774: LD_STRING Motherlode1
33776: PPUSH
33777: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33781: LD_VAR 0 1
33785: PPUSH
33786: CALL_OW 255
33790: PUSH
33791: LD_INT 3
33793: EQUAL
33794: IFFALSE 33815
// begin wait ( 0 0$5 ) ;
33796: LD_INT 175
33798: PPUSH
33799: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33803: LD_EXP 64
33807: PPUSH
33808: LD_STRING D18-Pla-1
33810: PPUSH
33811: CALL_OW 94
// end ; end ;
33815: PPOPN 3
33817: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33818: LD_VAR 0 1
33822: PUSH
33823: LD_INT 22
33825: PUSH
33826: LD_INT 1
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 21
33835: PUSH
33836: LD_INT 1
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 23
33845: PUSH
33846: LD_INT 1
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: LIST
33857: PPUSH
33858: CALL_OW 69
33862: IN
33863: IFFALSE 33879
// lostCounter := lostCounter + 1 ;
33865: LD_ADDR_EXP 32
33869: PUSH
33870: LD_EXP 32
33874: PUSH
33875: LD_INT 1
33877: PLUS
33878: ST_TO_ADDR
// if un in behemothBuilders then
33879: LD_VAR 0 1
33883: PUSH
33884: LD_EXP 73
33888: IN
33889: IFFALSE 33909
// begin behemothBuilders := behemothBuilders diff un ;
33891: LD_ADDR_EXP 73
33895: PUSH
33896: LD_EXP 73
33900: PUSH
33901: LD_VAR 0 1
33905: DIFF
33906: ST_TO_ADDR
// exit ;
33907: GO 33939
// end ; if un = JMM then
33909: LD_VAR 0 1
33913: PUSH
33914: LD_EXP 39
33918: EQUAL
33919: IFFALSE 33930
// begin YouLost ( JMM ) ;
33921: LD_STRING JMM
33923: PPUSH
33924: CALL_OW 104
// exit ;
33928: GO 33939
// end ; MCE_UnitDestroyed ( un ) ;
33930: LD_VAR 0 1
33934: PPUSH
33935: CALL 62486 0 1
// end ;
33939: PPOPN 1
33941: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33942: LD_VAR 0 1
33946: PPUSH
33947: LD_VAR 0 2
33951: PPUSH
33952: CALL 64820 0 2
// end ;
33956: PPOPN 2
33958: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33959: LD_VAR 0 1
33963: PPUSH
33964: CALL 63888 0 1
// end ;
33968: PPOPN 1
33970: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33971: LD_VAR 0 1
33975: PUSH
33976: LD_INT 22
33978: PUSH
33979: LD_INT 8
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 30
33988: PUSH
33989: LD_INT 2
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PUSH
33996: LD_INT 23
33998: PUSH
33999: LD_INT 3
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: LIST
34010: PPUSH
34011: CALL_OW 69
34015: IN
34016: IFFALSE 34043
// begin ComUpgrade ( building ) ;
34018: LD_VAR 0 1
34022: PPUSH
34023: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34027: LD_EXP 61
34031: PPUSH
34032: LD_VAR 0 1
34036: PPUSH
34037: CALL 73321 0 2
// exit ;
34041: GO 34052
// end ; MCE_BuildingComplete ( building ) ;
34043: LD_VAR 0 1
34047: PPUSH
34048: CALL 64129 0 1
// end ;
34052: PPOPN 1
34054: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34055: LD_VAR 0 1
34059: PPUSH
34060: LD_VAR 0 2
34064: PPUSH
34065: CALL 62182 0 2
// end ;
34069: PPOPN 2
34071: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34072: LD_VAR 0 1
34076: PPUSH
34077: LD_VAR 0 2
34081: PPUSH
34082: LD_VAR 0 3
34086: PPUSH
34087: LD_VAR 0 4
34091: PPUSH
34092: LD_VAR 0 5
34096: PPUSH
34097: CALL 61802 0 5
// end ;
34101: PPOPN 5
34103: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34104: LD_VAR 0 1
34108: PPUSH
34109: LD_VAR 0 2
34113: PPUSH
34114: CALL 61392 0 2
// end ;
34118: PPOPN 2
34120: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34121: LD_VAR 0 1
34125: PPUSH
34126: LD_VAR 0 2
34130: PPUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: LD_VAR 0 4
34140: PPUSH
34141: CALL 61230 0 4
// end ;
34145: PPOPN 4
34147: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34148: LD_VAR 0 1
34152: PPUSH
34153: LD_VAR 0 2
34157: PPUSH
34158: LD_VAR 0 3
34162: PPUSH
34163: CALL 61005 0 3
// end ;
34167: PPOPN 3
34169: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34170: LD_VAR 0 1
34174: PPUSH
34175: LD_VAR 0 2
34179: PPUSH
34180: CALL 60890 0 2
// end ;
34184: PPOPN 2
34186: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34187: LD_VAR 0 1
34191: PPUSH
34192: LD_VAR 0 2
34196: PPUSH
34197: CALL 65115 0 2
// end ;
34201: PPOPN 2
34203: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34204: LD_VAR 0 1
34208: PPUSH
34209: CALL_OW 255
34213: PUSH
34214: LD_INT 4
34216: EQUAL
34217: PUSH
34218: LD_VAR 0 1
34222: PUSH
34223: LD_EXP 18
34227: PUSH
34228: LD_INT 1
34230: ARRAY
34231: IN
34232: AND
34233: PUSH
34234: LD_EXP 19
34238: AND
34239: IFFALSE 34258
// begin ComMoveXY ( driver , 61 , 93 ) ;
34241: LD_VAR 0 1
34245: PPUSH
34246: LD_INT 61
34248: PPUSH
34249: LD_INT 93
34251: PPUSH
34252: CALL_OW 111
// exit ;
34256: GO 34282
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34258: LD_VAR 0 1
34262: PPUSH
34263: LD_VAR 0 2
34267: PPUSH
34268: LD_VAR 0 3
34272: PPUSH
34273: LD_VAR 0 4
34277: PPUSH
34278: CALL 65331 0 4
// end ;
34282: PPOPN 4
34284: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34285: LD_VAR 0 1
34289: PPUSH
34290: LD_VAR 0 2
34294: PPUSH
34295: CALL 60699 0 2
// end ;
34299: PPOPN 2
34301: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34302: LD_VAR 0 1
34306: PPUSH
34307: CALL 117224 0 1
// end ; end_of_file
34311: PPOPN 1
34313: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34314: LD_EXP 15
34318: PUSH
34319: LD_INT 2
34321: EQUAL
34322: IFFALSE 34801
34324: GO 34326
34326: DISABLE
34327: LD_INT 0
34329: PPUSH
// begin time := 0 0$40 ;
34330: LD_ADDR_VAR 0 1
34334: PUSH
34335: LD_INT 1400
34337: ST_TO_ADDR
// repeat wait ( time ) ;
34338: LD_VAR 0 1
34342: PPUSH
34343: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34347: LD_INT 1
34349: PPUSH
34350: LD_INT 5
34352: PPUSH
34353: CALL_OW 12
34357: PPUSH
34358: LD_INT 106
34360: PPUSH
34361: LD_INT 150
34363: PPUSH
34364: LD_INT 19
34366: PPUSH
34367: LD_INT 1
34369: PPUSH
34370: CALL_OW 56
// time := time + 0 0$9 ;
34374: LD_ADDR_VAR 0 1
34378: PUSH
34379: LD_VAR 0 1
34383: PUSH
34384: LD_INT 315
34386: PLUS
34387: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34388: LD_INT 455
34390: PPUSH
34391: LD_INT 840
34393: PPUSH
34394: CALL_OW 12
34398: PPUSH
34399: CALL_OW 67
// if Prob ( 50 ) then
34403: LD_INT 50
34405: PPUSH
34406: CALL_OW 13
34410: IFFALSE 34439
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34412: LD_INT 1
34414: PPUSH
34415: LD_INT 5
34417: PPUSH
34418: CALL_OW 12
34422: PPUSH
34423: LD_INT 62
34425: PPUSH
34426: LD_INT 108
34428: PPUSH
34429: LD_INT 10
34431: PPUSH
34432: LD_INT 1
34434: PPUSH
34435: CALL_OW 56
// until missionStage > 4 ;
34439: LD_EXP 15
34443: PUSH
34444: LD_INT 4
34446: GREATER
34447: IFFALSE 34338
// repeat wait ( 0 0$1 ) ;
34449: LD_INT 35
34451: PPUSH
34452: CALL_OW 67
// until missionStage = 6 ;
34456: LD_EXP 15
34460: PUSH
34461: LD_INT 6
34463: EQUAL
34464: IFFALSE 34449
// time := 0 0$50 ;
34466: LD_ADDR_VAR 0 1
34470: PUSH
34471: LD_INT 1750
34473: ST_TO_ADDR
// repeat wait ( time ) ;
34474: LD_VAR 0 1
34478: PPUSH
34479: CALL_OW 67
// if Prob ( 50 ) then
34483: LD_INT 50
34485: PPUSH
34486: CALL_OW 13
34490: IFFALSE 34519
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34492: LD_INT 1
34494: PPUSH
34495: LD_INT 5
34497: PPUSH
34498: CALL_OW 12
34502: PPUSH
34503: LD_INT 106
34505: PPUSH
34506: LD_INT 89
34508: PPUSH
34509: LD_INT 45
34511: PPUSH
34512: LD_INT 1
34514: PPUSH
34515: CALL_OW 56
// time := time + 0 0$2 ;
34519: LD_ADDR_VAR 0 1
34523: PUSH
34524: LD_VAR 0 1
34528: PUSH
34529: LD_INT 70
34531: PLUS
34532: ST_TO_ADDR
// if Prob ( 30 ) then
34533: LD_INT 30
34535: PPUSH
34536: CALL_OW 13
34540: IFFALSE 34586
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34542: LD_INT 385
34544: PPUSH
34545: LD_INT 945
34547: PPUSH
34548: CALL_OW 12
34552: PPUSH
34553: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34557: LD_INT 1
34559: PPUSH
34560: LD_INT 5
34562: PPUSH
34563: CALL_OW 12
34567: PPUSH
34568: LD_INT 21
34570: PPUSH
34571: LD_INT 26
34573: PPUSH
34574: LD_INT 12
34576: PPUSH
34577: LD_INT 1
34579: PPUSH
34580: CALL_OW 56
// end else
34584: GO 34622
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34586: LD_INT 700
34588: PPUSH
34589: LD_INT 1225
34591: PPUSH
34592: CALL_OW 12
34596: PPUSH
34597: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34601: LD_INT 1
34603: PPUSH
34604: LD_INT 5
34606: PPUSH
34607: CALL_OW 12
34611: PPUSH
34612: LD_INT 16
34614: PPUSH
34615: LD_INT 1
34617: PPUSH
34618: CALL_OW 55
// end ; if Prob ( 50 ) then
34622: LD_INT 50
34624: PPUSH
34625: CALL_OW 13
34629: IFFALSE 34675
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34631: LD_INT 700
34633: PPUSH
34634: LD_INT 1050
34636: PPUSH
34637: CALL_OW 12
34641: PPUSH
34642: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34646: LD_INT 1
34648: PPUSH
34649: LD_INT 5
34651: PPUSH
34652: CALL_OW 12
34656: PPUSH
34657: LD_INT 181
34659: PPUSH
34660: LD_INT 218
34662: PPUSH
34663: LD_INT 16
34665: PPUSH
34666: LD_INT 1
34668: PPUSH
34669: CALL_OW 56
// end else
34673: GO 34711
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34675: LD_INT 350
34677: PPUSH
34678: LD_INT 525
34680: PPUSH
34681: CALL_OW 12
34685: PPUSH
34686: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34690: LD_INT 1
34692: PPUSH
34693: LD_INT 5
34695: PPUSH
34696: CALL_OW 12
34700: PPUSH
34701: LD_INT 15
34703: PPUSH
34704: LD_INT 1
34706: PPUSH
34707: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34711: LD_INT 45
34713: PUSH
34714: LD_INT 32
34716: PUSH
34717: LD_INT 25
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: LIST
34724: PUSH
34725: LD_OWVAR 67
34729: ARRAY
34730: PPUSH
34731: CALL_OW 13
34735: IFFALSE 34779
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34737: LD_INT 175
34739: PPUSH
34740: LD_INT 315
34742: PPUSH
34743: CALL_OW 12
34747: PPUSH
34748: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34752: LD_INT 1
34754: PPUSH
34755: LD_INT 5
34757: PPUSH
34758: CALL_OW 12
34762: PPUSH
34763: LD_INT 103
34765: PPUSH
34766: LD_INT 140
34768: PPUSH
34769: LD_INT 20
34771: PPUSH
34772: LD_INT 1
34774: PPUSH
34775: CALL_OW 56
// end ; if time > 1 1$20 then
34779: LD_VAR 0 1
34783: PUSH
34784: LD_INT 2800
34786: GREATER
34787: IFFALSE 34797
// time := 0 0$30 ;
34789: LD_ADDR_VAR 0 1
34793: PUSH
34794: LD_INT 1050
34796: ST_TO_ADDR
// until false ;
34797: LD_INT 0
34799: IFFALSE 34474
// end ; end_of_file
34801: PPOPN 1
34803: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34804: LD_EXP 13
34808: PUSH
34809: LD_EXP 15
34813: PUSH
34814: LD_INT 6
34816: GREATEREQUAL
34817: AND
34818: IFFALSE 34855
34820: GO 34822
34822: DISABLE
// begin enable ;
34823: ENABLE
// missionTime := missionTime + 0 0$1 ;
34824: LD_ADDR_EXP 14
34828: PUSH
34829: LD_EXP 14
34833: PUSH
34834: LD_INT 35
34836: PLUS
34837: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34838: LD_ADDR_OWVAR 47
34842: PUSH
34843: LD_STRING #Am15-1
34845: PUSH
34846: LD_EXP 14
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: ST_TO_ADDR
// end ; end_of_file
34855: END
// export function InitNature ; begin
34856: LD_INT 0
34858: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34859: LD_INT 3
34861: PPUSH
34862: LD_INT 3
34864: PPUSH
34865: LD_INT 2
34867: PPUSH
34868: LD_INT 1
34870: PPUSH
34871: LD_INT 1
34873: PPUSH
34874: LD_INT 0
34876: PPUSH
34877: LD_INT 0
34879: PPUSH
34880: LD_INT 20
34882: PPUSH
34883: LD_INT 0
34885: PPUSH
34886: CALL 98836 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 1
34898: PPUSH
34899: LD_INT 1
34901: PPUSH
34902: LD_INT 1
34904: PPUSH
34905: LD_INT 0
34907: PPUSH
34908: LD_INT 0
34910: PPUSH
34911: LD_INT 21
34913: PPUSH
34914: LD_INT 0
34916: PPUSH
34917: CALL 98836 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34921: LD_INT 4
34923: PPUSH
34924: LD_INT 1
34926: PPUSH
34927: LD_INT 2
34929: PPUSH
34930: LD_INT 4
34932: PPUSH
34933: LD_INT 2
34935: PPUSH
34936: LD_INT 1
34938: PPUSH
34939: LD_INT 0
34941: PPUSH
34942: LD_INT 22
34944: PPUSH
34945: LD_INT 0
34947: PPUSH
34948: CALL 98836 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34952: LD_INT 0
34954: PPUSH
34955: LD_INT 0
34957: PPUSH
34958: LD_INT 0
34960: PPUSH
34961: LD_INT 0
34963: PPUSH
34964: LD_INT 0
34966: PPUSH
34967: LD_INT 0
34969: PPUSH
34970: LD_INT 9
34972: PPUSH
34973: LD_INT 0
34975: PPUSH
34976: LD_INT 23
34978: PPUSH
34979: CALL 98836 0 9
// end ; end_of_file
34983: LD_VAR 0 1
34987: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
34988: LD_INT 0
34990: PPUSH
// ar_miner := 81 ;
34991: LD_ADDR_EXP 102
34995: PUSH
34996: LD_INT 81
34998: ST_TO_ADDR
// ar_crane := 88 ;
34999: LD_ADDR_EXP 101
35003: PUSH
35004: LD_INT 88
35006: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35007: LD_ADDR_EXP 96
35011: PUSH
35012: LD_INT 89
35014: ST_TO_ADDR
// us_hack := 99 ;
35015: LD_ADDR_EXP 97
35019: PUSH
35020: LD_INT 99
35022: ST_TO_ADDR
// us_artillery := 97 ;
35023: LD_ADDR_EXP 98
35027: PUSH
35028: LD_INT 97
35030: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35031: LD_ADDR_EXP 99
35035: PUSH
35036: LD_INT 91
35038: ST_TO_ADDR
// ar_mortar := 92 ;
35039: LD_ADDR_EXP 100
35043: PUSH
35044: LD_INT 92
35046: ST_TO_ADDR
// ru_radar := 98 ;
35047: LD_ADDR_EXP 95
35051: PUSH
35052: LD_INT 98
35054: ST_TO_ADDR
// tech_Artillery := 80 ;
35055: LD_ADDR_EXP 103
35059: PUSH
35060: LD_INT 80
35062: ST_TO_ADDR
// tech_RadMat := 81 ;
35063: LD_ADDR_EXP 104
35067: PUSH
35068: LD_INT 81
35070: ST_TO_ADDR
// tech_BasicTools := 82 ;
35071: LD_ADDR_EXP 105
35075: PUSH
35076: LD_INT 82
35078: ST_TO_ADDR
// tech_Cargo := 83 ;
35079: LD_ADDR_EXP 106
35083: PUSH
35084: LD_INT 83
35086: ST_TO_ADDR
// tech_Track := 84 ;
35087: LD_ADDR_EXP 107
35091: PUSH
35092: LD_INT 84
35094: ST_TO_ADDR
// tech_Crane := 85 ;
35095: LD_ADDR_EXP 108
35099: PUSH
35100: LD_INT 85
35102: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35103: LD_ADDR_EXP 109
35107: PUSH
35108: LD_INT 86
35110: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35111: LD_ADDR_EXP 110
35115: PUSH
35116: LD_INT 87
35118: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35119: LD_ADDR_EXP 111
35123: PUSH
35124: LD_INT 88
35126: ST_TO_ADDR
// class_mastodont := 31 ;
35127: LD_ADDR_EXP 112
35131: PUSH
35132: LD_INT 31
35134: ST_TO_ADDR
// class_horse := 21 ;
35135: LD_ADDR_EXP 113
35139: PUSH
35140: LD_INT 21
35142: ST_TO_ADDR
// end ;
35143: LD_VAR 0 1
35147: RET
// every 1 do
35148: GO 35150
35150: DISABLE
// InitGlobalVariables ; end_of_file
35151: CALL 34988 0 0
35155: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35156: LD_INT 0
35158: PPUSH
35159: PPUSH
// skirmish := false ;
35160: LD_ADDR_EXP 114
35164: PUSH
35165: LD_INT 0
35167: ST_TO_ADDR
// debug_mc := false ;
35168: LD_ADDR_EXP 115
35172: PUSH
35173: LD_INT 0
35175: ST_TO_ADDR
// mc_bases := [ ] ;
35176: LD_ADDR_EXP 116
35180: PUSH
35181: EMPTY
35182: ST_TO_ADDR
// mc_sides := [ ] ;
35183: LD_ADDR_EXP 142
35187: PUSH
35188: EMPTY
35189: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35190: LD_ADDR_EXP 117
35194: PUSH
35195: EMPTY
35196: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35197: LD_ADDR_EXP 118
35201: PUSH
35202: EMPTY
35203: ST_TO_ADDR
// mc_need_heal := [ ] ;
35204: LD_ADDR_EXP 119
35208: PUSH
35209: EMPTY
35210: ST_TO_ADDR
// mc_healers := [ ] ;
35211: LD_ADDR_EXP 120
35215: PUSH
35216: EMPTY
35217: ST_TO_ADDR
// mc_build_list := [ ] ;
35218: LD_ADDR_EXP 121
35222: PUSH
35223: EMPTY
35224: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35225: LD_ADDR_EXP 148
35229: PUSH
35230: EMPTY
35231: ST_TO_ADDR
// mc_builders := [ ] ;
35232: LD_ADDR_EXP 122
35236: PUSH
35237: EMPTY
35238: ST_TO_ADDR
// mc_construct_list := [ ] ;
35239: LD_ADDR_EXP 123
35243: PUSH
35244: EMPTY
35245: ST_TO_ADDR
// mc_turret_list := [ ] ;
35246: LD_ADDR_EXP 124
35250: PUSH
35251: EMPTY
35252: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35253: LD_ADDR_EXP 125
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// mc_miners := [ ] ;
35260: LD_ADDR_EXP 130
35264: PUSH
35265: EMPTY
35266: ST_TO_ADDR
// mc_mines := [ ] ;
35267: LD_ADDR_EXP 129
35271: PUSH
35272: EMPTY
35273: ST_TO_ADDR
// mc_minefields := [ ] ;
35274: LD_ADDR_EXP 131
35278: PUSH
35279: EMPTY
35280: ST_TO_ADDR
// mc_crates := [ ] ;
35281: LD_ADDR_EXP 132
35285: PUSH
35286: EMPTY
35287: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35288: LD_ADDR_EXP 133
35292: PUSH
35293: EMPTY
35294: ST_TO_ADDR
// mc_crates_area := [ ] ;
35295: LD_ADDR_EXP 134
35299: PUSH
35300: EMPTY
35301: ST_TO_ADDR
// mc_vehicles := [ ] ;
35302: LD_ADDR_EXP 135
35306: PUSH
35307: EMPTY
35308: ST_TO_ADDR
// mc_attack := [ ] ;
35309: LD_ADDR_EXP 136
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// mc_produce := [ ] ;
35316: LD_ADDR_EXP 137
35320: PUSH
35321: EMPTY
35322: ST_TO_ADDR
// mc_defender := [ ] ;
35323: LD_ADDR_EXP 138
35327: PUSH
35328: EMPTY
35329: ST_TO_ADDR
// mc_parking := [ ] ;
35330: LD_ADDR_EXP 140
35334: PUSH
35335: EMPTY
35336: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35337: LD_ADDR_EXP 126
35341: PUSH
35342: EMPTY
35343: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35344: LD_ADDR_EXP 128
35348: PUSH
35349: EMPTY
35350: ST_TO_ADDR
// mc_scan := [ ] ;
35351: LD_ADDR_EXP 139
35355: PUSH
35356: EMPTY
35357: ST_TO_ADDR
// mc_scan_area := [ ] ;
35358: LD_ADDR_EXP 141
35362: PUSH
35363: EMPTY
35364: ST_TO_ADDR
// mc_tech := [ ] ;
35365: LD_ADDR_EXP 143
35369: PUSH
35370: EMPTY
35371: ST_TO_ADDR
// mc_class := [ ] ;
35372: LD_ADDR_EXP 157
35376: PUSH
35377: EMPTY
35378: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35379: LD_ADDR_EXP 158
35383: PUSH
35384: EMPTY
35385: ST_TO_ADDR
// mc_is_defending := [ ] ;
35386: LD_ADDR_EXP 159
35390: PUSH
35391: EMPTY
35392: ST_TO_ADDR
// end ;
35393: LD_VAR 0 1
35397: RET
// export function MC_Kill ( base ) ; begin
35398: LD_INT 0
35400: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35401: LD_ADDR_EXP 116
35405: PUSH
35406: LD_EXP 116
35410: PPUSH
35411: LD_VAR 0 1
35415: PPUSH
35416: EMPTY
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35423: LD_ADDR_EXP 117
35427: PUSH
35428: LD_EXP 117
35432: PPUSH
35433: LD_VAR 0 1
35437: PPUSH
35438: EMPTY
35439: PPUSH
35440: CALL_OW 1
35444: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35445: LD_ADDR_EXP 118
35449: PUSH
35450: LD_EXP 118
35454: PPUSH
35455: LD_VAR 0 1
35459: PPUSH
35460: EMPTY
35461: PPUSH
35462: CALL_OW 1
35466: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35467: LD_ADDR_EXP 119
35471: PUSH
35472: LD_EXP 119
35476: PPUSH
35477: LD_VAR 0 1
35481: PPUSH
35482: EMPTY
35483: PPUSH
35484: CALL_OW 1
35488: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35489: LD_ADDR_EXP 120
35493: PUSH
35494: LD_EXP 120
35498: PPUSH
35499: LD_VAR 0 1
35503: PPUSH
35504: EMPTY
35505: PPUSH
35506: CALL_OW 1
35510: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35511: LD_ADDR_EXP 121
35515: PUSH
35516: LD_EXP 121
35520: PPUSH
35521: LD_VAR 0 1
35525: PPUSH
35526: EMPTY
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35533: LD_ADDR_EXP 122
35537: PUSH
35538: LD_EXP 122
35542: PPUSH
35543: LD_VAR 0 1
35547: PPUSH
35548: EMPTY
35549: PPUSH
35550: CALL_OW 1
35554: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35555: LD_ADDR_EXP 123
35559: PUSH
35560: LD_EXP 123
35564: PPUSH
35565: LD_VAR 0 1
35569: PPUSH
35570: EMPTY
35571: PPUSH
35572: CALL_OW 1
35576: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35577: LD_ADDR_EXP 124
35581: PUSH
35582: LD_EXP 124
35586: PPUSH
35587: LD_VAR 0 1
35591: PPUSH
35592: EMPTY
35593: PPUSH
35594: CALL_OW 1
35598: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35599: LD_ADDR_EXP 125
35603: PUSH
35604: LD_EXP 125
35608: PPUSH
35609: LD_VAR 0 1
35613: PPUSH
35614: EMPTY
35615: PPUSH
35616: CALL_OW 1
35620: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35621: LD_ADDR_EXP 126
35625: PUSH
35626: LD_EXP 126
35630: PPUSH
35631: LD_VAR 0 1
35635: PPUSH
35636: EMPTY
35637: PPUSH
35638: CALL_OW 1
35642: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35643: LD_ADDR_EXP 127
35647: PUSH
35648: LD_EXP 127
35652: PPUSH
35653: LD_VAR 0 1
35657: PPUSH
35658: LD_INT 0
35660: PPUSH
35661: CALL_OW 1
35665: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35666: LD_ADDR_EXP 128
35670: PUSH
35671: LD_EXP 128
35675: PPUSH
35676: LD_VAR 0 1
35680: PPUSH
35681: EMPTY
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35688: LD_ADDR_EXP 129
35692: PUSH
35693: LD_EXP 129
35697: PPUSH
35698: LD_VAR 0 1
35702: PPUSH
35703: EMPTY
35704: PPUSH
35705: CALL_OW 1
35709: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35710: LD_ADDR_EXP 130
35714: PUSH
35715: LD_EXP 130
35719: PPUSH
35720: LD_VAR 0 1
35724: PPUSH
35725: EMPTY
35726: PPUSH
35727: CALL_OW 1
35731: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35732: LD_ADDR_EXP 131
35736: PUSH
35737: LD_EXP 131
35741: PPUSH
35742: LD_VAR 0 1
35746: PPUSH
35747: EMPTY
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35754: LD_ADDR_EXP 132
35758: PUSH
35759: LD_EXP 132
35763: PPUSH
35764: LD_VAR 0 1
35768: PPUSH
35769: EMPTY
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35776: LD_ADDR_EXP 133
35780: PUSH
35781: LD_EXP 133
35785: PPUSH
35786: LD_VAR 0 1
35790: PPUSH
35791: EMPTY
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35798: LD_ADDR_EXP 134
35802: PUSH
35803: LD_EXP 134
35807: PPUSH
35808: LD_VAR 0 1
35812: PPUSH
35813: EMPTY
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35820: LD_ADDR_EXP 135
35824: PUSH
35825: LD_EXP 135
35829: PPUSH
35830: LD_VAR 0 1
35834: PPUSH
35835: EMPTY
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35842: LD_ADDR_EXP 136
35846: PUSH
35847: LD_EXP 136
35851: PPUSH
35852: LD_VAR 0 1
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35864: LD_ADDR_EXP 137
35868: PUSH
35869: LD_EXP 137
35873: PPUSH
35874: LD_VAR 0 1
35878: PPUSH
35879: EMPTY
35880: PPUSH
35881: CALL_OW 1
35885: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35886: LD_ADDR_EXP 138
35890: PUSH
35891: LD_EXP 138
35895: PPUSH
35896: LD_VAR 0 1
35900: PPUSH
35901: EMPTY
35902: PPUSH
35903: CALL_OW 1
35907: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35908: LD_ADDR_EXP 139
35912: PUSH
35913: LD_EXP 139
35917: PPUSH
35918: LD_VAR 0 1
35922: PPUSH
35923: EMPTY
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35930: LD_ADDR_EXP 140
35934: PUSH
35935: LD_EXP 140
35939: PPUSH
35940: LD_VAR 0 1
35944: PPUSH
35945: EMPTY
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35952: LD_ADDR_EXP 141
35956: PUSH
35957: LD_EXP 141
35961: PPUSH
35962: LD_VAR 0 1
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35974: LD_ADDR_EXP 143
35978: PUSH
35979: LD_EXP 143
35983: PPUSH
35984: LD_VAR 0 1
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35996: LD_ADDR_EXP 145
36000: PUSH
36001: LD_EXP 145
36005: PPUSH
36006: LD_VAR 0 1
36010: PPUSH
36011: EMPTY
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36018: LD_ADDR_EXP 146
36022: PUSH
36023: LD_EXP 146
36027: PPUSH
36028: LD_VAR 0 1
36032: PPUSH
36033: EMPTY
36034: PPUSH
36035: CALL_OW 1
36039: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36040: LD_ADDR_EXP 147
36044: PUSH
36045: LD_EXP 147
36049: PPUSH
36050: LD_VAR 0 1
36054: PPUSH
36055: EMPTY
36056: PPUSH
36057: CALL_OW 1
36061: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36062: LD_ADDR_EXP 148
36066: PUSH
36067: LD_EXP 148
36071: PPUSH
36072: LD_VAR 0 1
36076: PPUSH
36077: EMPTY
36078: PPUSH
36079: CALL_OW 1
36083: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36084: LD_ADDR_EXP 149
36088: PUSH
36089: LD_EXP 149
36093: PPUSH
36094: LD_VAR 0 1
36098: PPUSH
36099: EMPTY
36100: PPUSH
36101: CALL_OW 1
36105: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36106: LD_ADDR_EXP 150
36110: PUSH
36111: LD_EXP 150
36115: PPUSH
36116: LD_VAR 0 1
36120: PPUSH
36121: EMPTY
36122: PPUSH
36123: CALL_OW 1
36127: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36128: LD_ADDR_EXP 151
36132: PUSH
36133: LD_EXP 151
36137: PPUSH
36138: LD_VAR 0 1
36142: PPUSH
36143: EMPTY
36144: PPUSH
36145: CALL_OW 1
36149: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36150: LD_ADDR_EXP 152
36154: PUSH
36155: LD_EXP 152
36159: PPUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: EMPTY
36166: PPUSH
36167: CALL_OW 1
36171: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36172: LD_ADDR_EXP 153
36176: PUSH
36177: LD_EXP 153
36181: PPUSH
36182: LD_VAR 0 1
36186: PPUSH
36187: EMPTY
36188: PPUSH
36189: CALL_OW 1
36193: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36194: LD_ADDR_EXP 154
36198: PUSH
36199: LD_EXP 154
36203: PPUSH
36204: LD_VAR 0 1
36208: PPUSH
36209: EMPTY
36210: PPUSH
36211: CALL_OW 1
36215: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36216: LD_ADDR_EXP 155
36220: PUSH
36221: LD_EXP 155
36225: PPUSH
36226: LD_VAR 0 1
36230: PPUSH
36231: EMPTY
36232: PPUSH
36233: CALL_OW 1
36237: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36238: LD_ADDR_EXP 156
36242: PUSH
36243: LD_EXP 156
36247: PPUSH
36248: LD_VAR 0 1
36252: PPUSH
36253: EMPTY
36254: PPUSH
36255: CALL_OW 1
36259: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36260: LD_ADDR_EXP 157
36264: PUSH
36265: LD_EXP 157
36269: PPUSH
36270: LD_VAR 0 1
36274: PPUSH
36275: EMPTY
36276: PPUSH
36277: CALL_OW 1
36281: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36282: LD_ADDR_EXP 158
36286: PUSH
36287: LD_EXP 158
36291: PPUSH
36292: LD_VAR 0 1
36296: PPUSH
36297: LD_INT 0
36299: PPUSH
36300: CALL_OW 1
36304: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36305: LD_ADDR_EXP 159
36309: PUSH
36310: LD_EXP 159
36314: PPUSH
36315: LD_VAR 0 1
36319: PPUSH
36320: LD_INT 0
36322: PPUSH
36323: CALL_OW 1
36327: ST_TO_ADDR
// end ;
36328: LD_VAR 0 2
36332: RET
// export function MC_Add ( side , units ) ; var base ; begin
36333: LD_INT 0
36335: PPUSH
36336: PPUSH
// base := mc_bases + 1 ;
36337: LD_ADDR_VAR 0 4
36341: PUSH
36342: LD_EXP 116
36346: PUSH
36347: LD_INT 1
36349: PLUS
36350: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36351: LD_ADDR_EXP 142
36355: PUSH
36356: LD_EXP 142
36360: PPUSH
36361: LD_VAR 0 4
36365: PPUSH
36366: LD_VAR 0 1
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36376: LD_ADDR_EXP 116
36380: PUSH
36381: LD_EXP 116
36385: PPUSH
36386: LD_VAR 0 4
36390: PPUSH
36391: LD_VAR 0 2
36395: PPUSH
36396: CALL_OW 1
36400: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36401: LD_ADDR_EXP 117
36405: PUSH
36406: LD_EXP 117
36410: PPUSH
36411: LD_VAR 0 4
36415: PPUSH
36416: EMPTY
36417: PPUSH
36418: CALL_OW 1
36422: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36423: LD_ADDR_EXP 118
36427: PUSH
36428: LD_EXP 118
36432: PPUSH
36433: LD_VAR 0 4
36437: PPUSH
36438: EMPTY
36439: PPUSH
36440: CALL_OW 1
36444: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36445: LD_ADDR_EXP 119
36449: PUSH
36450: LD_EXP 119
36454: PPUSH
36455: LD_VAR 0 4
36459: PPUSH
36460: EMPTY
36461: PPUSH
36462: CALL_OW 1
36466: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36467: LD_ADDR_EXP 120
36471: PUSH
36472: LD_EXP 120
36476: PPUSH
36477: LD_VAR 0 4
36481: PPUSH
36482: EMPTY
36483: PPUSH
36484: CALL_OW 1
36488: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36489: LD_ADDR_EXP 121
36493: PUSH
36494: LD_EXP 121
36498: PPUSH
36499: LD_VAR 0 4
36503: PPUSH
36504: EMPTY
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36511: LD_ADDR_EXP 122
36515: PUSH
36516: LD_EXP 122
36520: PPUSH
36521: LD_VAR 0 4
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36533: LD_ADDR_EXP 123
36537: PUSH
36538: LD_EXP 123
36542: PPUSH
36543: LD_VAR 0 4
36547: PPUSH
36548: EMPTY
36549: PPUSH
36550: CALL_OW 1
36554: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36555: LD_ADDR_EXP 124
36559: PUSH
36560: LD_EXP 124
36564: PPUSH
36565: LD_VAR 0 4
36569: PPUSH
36570: EMPTY
36571: PPUSH
36572: CALL_OW 1
36576: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36577: LD_ADDR_EXP 125
36581: PUSH
36582: LD_EXP 125
36586: PPUSH
36587: LD_VAR 0 4
36591: PPUSH
36592: EMPTY
36593: PPUSH
36594: CALL_OW 1
36598: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36599: LD_ADDR_EXP 126
36603: PUSH
36604: LD_EXP 126
36608: PPUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: EMPTY
36615: PPUSH
36616: CALL_OW 1
36620: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36621: LD_ADDR_EXP 127
36625: PUSH
36626: LD_EXP 127
36630: PPUSH
36631: LD_VAR 0 4
36635: PPUSH
36636: LD_INT 0
36638: PPUSH
36639: CALL_OW 1
36643: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36644: LD_ADDR_EXP 128
36648: PUSH
36649: LD_EXP 128
36653: PPUSH
36654: LD_VAR 0 4
36658: PPUSH
36659: EMPTY
36660: PPUSH
36661: CALL_OW 1
36665: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36666: LD_ADDR_EXP 129
36670: PUSH
36671: LD_EXP 129
36675: PPUSH
36676: LD_VAR 0 4
36680: PPUSH
36681: EMPTY
36682: PPUSH
36683: CALL_OW 1
36687: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36688: LD_ADDR_EXP 130
36692: PUSH
36693: LD_EXP 130
36697: PPUSH
36698: LD_VAR 0 4
36702: PPUSH
36703: EMPTY
36704: PPUSH
36705: CALL_OW 1
36709: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36710: LD_ADDR_EXP 131
36714: PUSH
36715: LD_EXP 131
36719: PPUSH
36720: LD_VAR 0 4
36724: PPUSH
36725: EMPTY
36726: PPUSH
36727: CALL_OW 1
36731: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36732: LD_ADDR_EXP 132
36736: PUSH
36737: LD_EXP 132
36741: PPUSH
36742: LD_VAR 0 4
36746: PPUSH
36747: EMPTY
36748: PPUSH
36749: CALL_OW 1
36753: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36754: LD_ADDR_EXP 133
36758: PUSH
36759: LD_EXP 133
36763: PPUSH
36764: LD_VAR 0 4
36768: PPUSH
36769: EMPTY
36770: PPUSH
36771: CALL_OW 1
36775: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36776: LD_ADDR_EXP 134
36780: PUSH
36781: LD_EXP 134
36785: PPUSH
36786: LD_VAR 0 4
36790: PPUSH
36791: EMPTY
36792: PPUSH
36793: CALL_OW 1
36797: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36798: LD_ADDR_EXP 135
36802: PUSH
36803: LD_EXP 135
36807: PPUSH
36808: LD_VAR 0 4
36812: PPUSH
36813: EMPTY
36814: PPUSH
36815: CALL_OW 1
36819: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36820: LD_ADDR_EXP 136
36824: PUSH
36825: LD_EXP 136
36829: PPUSH
36830: LD_VAR 0 4
36834: PPUSH
36835: EMPTY
36836: PPUSH
36837: CALL_OW 1
36841: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36842: LD_ADDR_EXP 137
36846: PUSH
36847: LD_EXP 137
36851: PPUSH
36852: LD_VAR 0 4
36856: PPUSH
36857: EMPTY
36858: PPUSH
36859: CALL_OW 1
36863: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36864: LD_ADDR_EXP 138
36868: PUSH
36869: LD_EXP 138
36873: PPUSH
36874: LD_VAR 0 4
36878: PPUSH
36879: EMPTY
36880: PPUSH
36881: CALL_OW 1
36885: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36886: LD_ADDR_EXP 139
36890: PUSH
36891: LD_EXP 139
36895: PPUSH
36896: LD_VAR 0 4
36900: PPUSH
36901: EMPTY
36902: PPUSH
36903: CALL_OW 1
36907: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36908: LD_ADDR_EXP 140
36912: PUSH
36913: LD_EXP 140
36917: PPUSH
36918: LD_VAR 0 4
36922: PPUSH
36923: EMPTY
36924: PPUSH
36925: CALL_OW 1
36929: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36930: LD_ADDR_EXP 141
36934: PUSH
36935: LD_EXP 141
36939: PPUSH
36940: LD_VAR 0 4
36944: PPUSH
36945: EMPTY
36946: PPUSH
36947: CALL_OW 1
36951: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36952: LD_ADDR_EXP 143
36956: PUSH
36957: LD_EXP 143
36961: PPUSH
36962: LD_VAR 0 4
36966: PPUSH
36967: EMPTY
36968: PPUSH
36969: CALL_OW 1
36973: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36974: LD_ADDR_EXP 145
36978: PUSH
36979: LD_EXP 145
36983: PPUSH
36984: LD_VAR 0 4
36988: PPUSH
36989: EMPTY
36990: PPUSH
36991: CALL_OW 1
36995: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36996: LD_ADDR_EXP 146
37000: PUSH
37001: LD_EXP 146
37005: PPUSH
37006: LD_VAR 0 4
37010: PPUSH
37011: EMPTY
37012: PPUSH
37013: CALL_OW 1
37017: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37018: LD_ADDR_EXP 147
37022: PUSH
37023: LD_EXP 147
37027: PPUSH
37028: LD_VAR 0 4
37032: PPUSH
37033: EMPTY
37034: PPUSH
37035: CALL_OW 1
37039: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37040: LD_ADDR_EXP 148
37044: PUSH
37045: LD_EXP 148
37049: PPUSH
37050: LD_VAR 0 4
37054: PPUSH
37055: EMPTY
37056: PPUSH
37057: CALL_OW 1
37061: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37062: LD_ADDR_EXP 149
37066: PUSH
37067: LD_EXP 149
37071: PPUSH
37072: LD_VAR 0 4
37076: PPUSH
37077: EMPTY
37078: PPUSH
37079: CALL_OW 1
37083: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37084: LD_ADDR_EXP 150
37088: PUSH
37089: LD_EXP 150
37093: PPUSH
37094: LD_VAR 0 4
37098: PPUSH
37099: EMPTY
37100: PPUSH
37101: CALL_OW 1
37105: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37106: LD_ADDR_EXP 151
37110: PUSH
37111: LD_EXP 151
37115: PPUSH
37116: LD_VAR 0 4
37120: PPUSH
37121: EMPTY
37122: PPUSH
37123: CALL_OW 1
37127: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37128: LD_ADDR_EXP 152
37132: PUSH
37133: LD_EXP 152
37137: PPUSH
37138: LD_VAR 0 4
37142: PPUSH
37143: EMPTY
37144: PPUSH
37145: CALL_OW 1
37149: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37150: LD_ADDR_EXP 153
37154: PUSH
37155: LD_EXP 153
37159: PPUSH
37160: LD_VAR 0 4
37164: PPUSH
37165: EMPTY
37166: PPUSH
37167: CALL_OW 1
37171: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37172: LD_ADDR_EXP 154
37176: PUSH
37177: LD_EXP 154
37181: PPUSH
37182: LD_VAR 0 4
37186: PPUSH
37187: EMPTY
37188: PPUSH
37189: CALL_OW 1
37193: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37194: LD_ADDR_EXP 155
37198: PUSH
37199: LD_EXP 155
37203: PPUSH
37204: LD_VAR 0 4
37208: PPUSH
37209: EMPTY
37210: PPUSH
37211: CALL_OW 1
37215: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37216: LD_ADDR_EXP 156
37220: PUSH
37221: LD_EXP 156
37225: PPUSH
37226: LD_VAR 0 4
37230: PPUSH
37231: EMPTY
37232: PPUSH
37233: CALL_OW 1
37237: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37238: LD_ADDR_EXP 157
37242: PUSH
37243: LD_EXP 157
37247: PPUSH
37248: LD_VAR 0 4
37252: PPUSH
37253: EMPTY
37254: PPUSH
37255: CALL_OW 1
37259: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37260: LD_ADDR_EXP 158
37264: PUSH
37265: LD_EXP 158
37269: PPUSH
37270: LD_VAR 0 4
37274: PPUSH
37275: LD_INT 0
37277: PPUSH
37278: CALL_OW 1
37282: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37283: LD_ADDR_EXP 159
37287: PUSH
37288: LD_EXP 159
37292: PPUSH
37293: LD_VAR 0 4
37297: PPUSH
37298: LD_INT 0
37300: PPUSH
37301: CALL_OW 1
37305: ST_TO_ADDR
// result := base ;
37306: LD_ADDR_VAR 0 3
37310: PUSH
37311: LD_VAR 0 4
37315: ST_TO_ADDR
// end ;
37316: LD_VAR 0 3
37320: RET
// export function MC_Start ( ) ; var i ; begin
37321: LD_INT 0
37323: PPUSH
37324: PPUSH
// for i = 1 to mc_bases do
37325: LD_ADDR_VAR 0 2
37329: PUSH
37330: DOUBLE
37331: LD_INT 1
37333: DEC
37334: ST_TO_ADDR
37335: LD_EXP 116
37339: PUSH
37340: FOR_TO
37341: IFFALSE 38441
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37343: LD_ADDR_EXP 116
37347: PUSH
37348: LD_EXP 116
37352: PPUSH
37353: LD_VAR 0 2
37357: PPUSH
37358: LD_EXP 116
37362: PUSH
37363: LD_VAR 0 2
37367: ARRAY
37368: PUSH
37369: LD_INT 0
37371: DIFF
37372: PPUSH
37373: CALL_OW 1
37377: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37378: LD_ADDR_EXP 117
37382: PUSH
37383: LD_EXP 117
37387: PPUSH
37388: LD_VAR 0 2
37392: PPUSH
37393: EMPTY
37394: PPUSH
37395: CALL_OW 1
37399: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37400: LD_ADDR_EXP 118
37404: PUSH
37405: LD_EXP 118
37409: PPUSH
37410: LD_VAR 0 2
37414: PPUSH
37415: EMPTY
37416: PPUSH
37417: CALL_OW 1
37421: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37422: LD_ADDR_EXP 119
37426: PUSH
37427: LD_EXP 119
37431: PPUSH
37432: LD_VAR 0 2
37436: PPUSH
37437: EMPTY
37438: PPUSH
37439: CALL_OW 1
37443: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37444: LD_ADDR_EXP 120
37448: PUSH
37449: LD_EXP 120
37453: PPUSH
37454: LD_VAR 0 2
37458: PPUSH
37459: EMPTY
37460: PUSH
37461: EMPTY
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PPUSH
37467: CALL_OW 1
37471: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37472: LD_ADDR_EXP 121
37476: PUSH
37477: LD_EXP 121
37481: PPUSH
37482: LD_VAR 0 2
37486: PPUSH
37487: EMPTY
37488: PPUSH
37489: CALL_OW 1
37493: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37494: LD_ADDR_EXP 148
37498: PUSH
37499: LD_EXP 148
37503: PPUSH
37504: LD_VAR 0 2
37508: PPUSH
37509: EMPTY
37510: PPUSH
37511: CALL_OW 1
37515: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37516: LD_ADDR_EXP 122
37520: PUSH
37521: LD_EXP 122
37525: PPUSH
37526: LD_VAR 0 2
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL_OW 1
37537: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37538: LD_ADDR_EXP 123
37542: PUSH
37543: LD_EXP 123
37547: PPUSH
37548: LD_VAR 0 2
37552: PPUSH
37553: EMPTY
37554: PPUSH
37555: CALL_OW 1
37559: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37560: LD_ADDR_EXP 124
37564: PUSH
37565: LD_EXP 124
37569: PPUSH
37570: LD_VAR 0 2
37574: PPUSH
37575: LD_EXP 116
37579: PUSH
37580: LD_VAR 0 2
37584: ARRAY
37585: PPUSH
37586: LD_INT 2
37588: PUSH
37589: LD_INT 30
37591: PUSH
37592: LD_INT 32
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 30
37601: PUSH
37602: LD_INT 33
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: LIST
37613: PPUSH
37614: CALL_OW 72
37618: PPUSH
37619: CALL_OW 1
37623: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37624: LD_ADDR_EXP 125
37628: PUSH
37629: LD_EXP 125
37633: PPUSH
37634: LD_VAR 0 2
37638: PPUSH
37639: LD_EXP 116
37643: PUSH
37644: LD_VAR 0 2
37648: ARRAY
37649: PPUSH
37650: LD_INT 2
37652: PUSH
37653: LD_INT 30
37655: PUSH
37656: LD_INT 32
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: LD_INT 30
37665: PUSH
37666: LD_INT 31
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 58
37680: PUSH
37681: EMPTY
37682: LIST
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PPUSH
37688: CALL_OW 72
37692: PPUSH
37693: CALL_OW 1
37697: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37698: LD_ADDR_EXP 126
37702: PUSH
37703: LD_EXP 126
37707: PPUSH
37708: LD_VAR 0 2
37712: PPUSH
37713: EMPTY
37714: PPUSH
37715: CALL_OW 1
37719: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37720: LD_ADDR_EXP 130
37724: PUSH
37725: LD_EXP 130
37729: PPUSH
37730: LD_VAR 0 2
37734: PPUSH
37735: EMPTY
37736: PPUSH
37737: CALL_OW 1
37741: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37742: LD_ADDR_EXP 129
37746: PUSH
37747: LD_EXP 129
37751: PPUSH
37752: LD_VAR 0 2
37756: PPUSH
37757: EMPTY
37758: PPUSH
37759: CALL_OW 1
37763: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37764: LD_ADDR_EXP 131
37768: PUSH
37769: LD_EXP 131
37773: PPUSH
37774: LD_VAR 0 2
37778: PPUSH
37779: EMPTY
37780: PPUSH
37781: CALL_OW 1
37785: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37786: LD_ADDR_EXP 132
37790: PUSH
37791: LD_EXP 132
37795: PPUSH
37796: LD_VAR 0 2
37800: PPUSH
37801: EMPTY
37802: PPUSH
37803: CALL_OW 1
37807: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37808: LD_ADDR_EXP 133
37812: PUSH
37813: LD_EXP 133
37817: PPUSH
37818: LD_VAR 0 2
37822: PPUSH
37823: EMPTY
37824: PPUSH
37825: CALL_OW 1
37829: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37830: LD_ADDR_EXP 134
37834: PUSH
37835: LD_EXP 134
37839: PPUSH
37840: LD_VAR 0 2
37844: PPUSH
37845: EMPTY
37846: PPUSH
37847: CALL_OW 1
37851: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37852: LD_ADDR_EXP 135
37856: PUSH
37857: LD_EXP 135
37861: PPUSH
37862: LD_VAR 0 2
37866: PPUSH
37867: EMPTY
37868: PPUSH
37869: CALL_OW 1
37873: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37874: LD_ADDR_EXP 136
37878: PUSH
37879: LD_EXP 136
37883: PPUSH
37884: LD_VAR 0 2
37888: PPUSH
37889: EMPTY
37890: PPUSH
37891: CALL_OW 1
37895: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37896: LD_ADDR_EXP 137
37900: PUSH
37901: LD_EXP 137
37905: PPUSH
37906: LD_VAR 0 2
37910: PPUSH
37911: EMPTY
37912: PPUSH
37913: CALL_OW 1
37917: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37918: LD_ADDR_EXP 138
37922: PUSH
37923: LD_EXP 138
37927: PPUSH
37928: LD_VAR 0 2
37932: PPUSH
37933: EMPTY
37934: PPUSH
37935: CALL_OW 1
37939: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37940: LD_ADDR_EXP 127
37944: PUSH
37945: LD_EXP 127
37949: PPUSH
37950: LD_VAR 0 2
37954: PPUSH
37955: LD_INT 0
37957: PPUSH
37958: CALL_OW 1
37962: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37963: LD_ADDR_EXP 140
37967: PUSH
37968: LD_EXP 140
37972: PPUSH
37973: LD_VAR 0 2
37977: PPUSH
37978: LD_INT 0
37980: PPUSH
37981: CALL_OW 1
37985: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37986: LD_ADDR_EXP 128
37990: PUSH
37991: LD_EXP 128
37995: PPUSH
37996: LD_VAR 0 2
38000: PPUSH
38001: EMPTY
38002: PPUSH
38003: CALL_OW 1
38007: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38008: LD_ADDR_EXP 139
38012: PUSH
38013: LD_EXP 139
38017: PPUSH
38018: LD_VAR 0 2
38022: PPUSH
38023: LD_INT 0
38025: PPUSH
38026: CALL_OW 1
38030: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38031: LD_ADDR_EXP 141
38035: PUSH
38036: LD_EXP 141
38040: PPUSH
38041: LD_VAR 0 2
38045: PPUSH
38046: EMPTY
38047: PPUSH
38048: CALL_OW 1
38052: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38053: LD_ADDR_EXP 144
38057: PUSH
38058: LD_EXP 144
38062: PPUSH
38063: LD_VAR 0 2
38067: PPUSH
38068: LD_INT 0
38070: PPUSH
38071: CALL_OW 1
38075: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38076: LD_ADDR_EXP 145
38080: PUSH
38081: LD_EXP 145
38085: PPUSH
38086: LD_VAR 0 2
38090: PPUSH
38091: EMPTY
38092: PPUSH
38093: CALL_OW 1
38097: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38098: LD_ADDR_EXP 146
38102: PUSH
38103: LD_EXP 146
38107: PPUSH
38108: LD_VAR 0 2
38112: PPUSH
38113: EMPTY
38114: PPUSH
38115: CALL_OW 1
38119: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38120: LD_ADDR_EXP 147
38124: PUSH
38125: LD_EXP 147
38129: PPUSH
38130: LD_VAR 0 2
38134: PPUSH
38135: EMPTY
38136: PPUSH
38137: CALL_OW 1
38141: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38142: LD_ADDR_EXP 149
38146: PUSH
38147: LD_EXP 149
38151: PPUSH
38152: LD_VAR 0 2
38156: PPUSH
38157: LD_EXP 116
38161: PUSH
38162: LD_VAR 0 2
38166: ARRAY
38167: PPUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 30
38173: PUSH
38174: LD_INT 6
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 30
38183: PUSH
38184: LD_INT 7
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 30
38193: PUSH
38194: LD_INT 8
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: LIST
38205: LIST
38206: PPUSH
38207: CALL_OW 72
38211: PPUSH
38212: CALL_OW 1
38216: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38217: LD_ADDR_EXP 150
38221: PUSH
38222: LD_EXP 150
38226: PPUSH
38227: LD_VAR 0 2
38231: PPUSH
38232: EMPTY
38233: PPUSH
38234: CALL_OW 1
38238: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38239: LD_ADDR_EXP 151
38243: PUSH
38244: LD_EXP 151
38248: PPUSH
38249: LD_VAR 0 2
38253: PPUSH
38254: EMPTY
38255: PPUSH
38256: CALL_OW 1
38260: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38261: LD_ADDR_EXP 152
38265: PUSH
38266: LD_EXP 152
38270: PPUSH
38271: LD_VAR 0 2
38275: PPUSH
38276: EMPTY
38277: PPUSH
38278: CALL_OW 1
38282: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38283: LD_ADDR_EXP 153
38287: PUSH
38288: LD_EXP 153
38292: PPUSH
38293: LD_VAR 0 2
38297: PPUSH
38298: EMPTY
38299: PPUSH
38300: CALL_OW 1
38304: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38305: LD_ADDR_EXP 154
38309: PUSH
38310: LD_EXP 154
38314: PPUSH
38315: LD_VAR 0 2
38319: PPUSH
38320: EMPTY
38321: PPUSH
38322: CALL_OW 1
38326: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38327: LD_ADDR_EXP 155
38331: PUSH
38332: LD_EXP 155
38336: PPUSH
38337: LD_VAR 0 2
38341: PPUSH
38342: EMPTY
38343: PPUSH
38344: CALL_OW 1
38348: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38349: LD_ADDR_EXP 156
38353: PUSH
38354: LD_EXP 156
38358: PPUSH
38359: LD_VAR 0 2
38363: PPUSH
38364: EMPTY
38365: PPUSH
38366: CALL_OW 1
38370: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38371: LD_ADDR_EXP 157
38375: PUSH
38376: LD_EXP 157
38380: PPUSH
38381: LD_VAR 0 2
38385: PPUSH
38386: EMPTY
38387: PPUSH
38388: CALL_OW 1
38392: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38393: LD_ADDR_EXP 158
38397: PUSH
38398: LD_EXP 158
38402: PPUSH
38403: LD_VAR 0 2
38407: PPUSH
38408: LD_INT 0
38410: PPUSH
38411: CALL_OW 1
38415: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38416: LD_ADDR_EXP 159
38420: PUSH
38421: LD_EXP 159
38425: PPUSH
38426: LD_VAR 0 2
38430: PPUSH
38431: LD_INT 0
38433: PPUSH
38434: CALL_OW 1
38438: ST_TO_ADDR
// end ;
38439: GO 37340
38441: POP
38442: POP
// MC_InitSides ( ) ;
38443: CALL 38729 0 0
// MC_InitResearch ( ) ;
38447: CALL 38468 0 0
// CustomInitMacro ( ) ;
38451: CALL 471 0 0
// skirmish := true ;
38455: LD_ADDR_EXP 114
38459: PUSH
38460: LD_INT 1
38462: ST_TO_ADDR
// end ;
38463: LD_VAR 0 1
38467: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38468: LD_INT 0
38470: PPUSH
38471: PPUSH
38472: PPUSH
38473: PPUSH
38474: PPUSH
38475: PPUSH
// if not mc_bases then
38476: LD_EXP 116
38480: NOT
38481: IFFALSE 38485
// exit ;
38483: GO 38724
// for i = 1 to 8 do
38485: LD_ADDR_VAR 0 2
38489: PUSH
38490: DOUBLE
38491: LD_INT 1
38493: DEC
38494: ST_TO_ADDR
38495: LD_INT 8
38497: PUSH
38498: FOR_TO
38499: IFFALSE 38525
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38501: LD_ADDR_EXP 143
38505: PUSH
38506: LD_EXP 143
38510: PPUSH
38511: LD_VAR 0 2
38515: PPUSH
38516: EMPTY
38517: PPUSH
38518: CALL_OW 1
38522: ST_TO_ADDR
38523: GO 38498
38525: POP
38526: POP
// tmp := [ ] ;
38527: LD_ADDR_VAR 0 5
38531: PUSH
38532: EMPTY
38533: ST_TO_ADDR
// for i = 1 to mc_sides do
38534: LD_ADDR_VAR 0 2
38538: PUSH
38539: DOUBLE
38540: LD_INT 1
38542: DEC
38543: ST_TO_ADDR
38544: LD_EXP 142
38548: PUSH
38549: FOR_TO
38550: IFFALSE 38608
// if not mc_sides [ i ] in tmp then
38552: LD_EXP 142
38556: PUSH
38557: LD_VAR 0 2
38561: ARRAY
38562: PUSH
38563: LD_VAR 0 5
38567: IN
38568: NOT
38569: IFFALSE 38606
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38571: LD_ADDR_VAR 0 5
38575: PUSH
38576: LD_VAR 0 5
38580: PPUSH
38581: LD_VAR 0 5
38585: PUSH
38586: LD_INT 1
38588: PLUS
38589: PPUSH
38590: LD_EXP 142
38594: PUSH
38595: LD_VAR 0 2
38599: ARRAY
38600: PPUSH
38601: CALL_OW 2
38605: ST_TO_ADDR
38606: GO 38549
38608: POP
38609: POP
// if not tmp then
38610: LD_VAR 0 5
38614: NOT
38615: IFFALSE 38619
// exit ;
38617: GO 38724
// for j in tmp do
38619: LD_ADDR_VAR 0 3
38623: PUSH
38624: LD_VAR 0 5
38628: PUSH
38629: FOR_IN
38630: IFFALSE 38722
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38632: LD_ADDR_VAR 0 6
38636: PUSH
38637: LD_INT 22
38639: PUSH
38640: LD_VAR 0 3
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PPUSH
38649: CALL_OW 69
38653: ST_TO_ADDR
// if not un then
38654: LD_VAR 0 6
38658: NOT
38659: IFFALSE 38663
// continue ;
38661: GO 38629
// nation := GetNation ( un [ 1 ] ) ;
38663: LD_ADDR_VAR 0 4
38667: PUSH
38668: LD_VAR 0 6
38672: PUSH
38673: LD_INT 1
38675: ARRAY
38676: PPUSH
38677: CALL_OW 248
38681: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38682: LD_ADDR_EXP 143
38686: PUSH
38687: LD_EXP 143
38691: PPUSH
38692: LD_VAR 0 3
38696: PPUSH
38697: LD_VAR 0 3
38701: PPUSH
38702: LD_VAR 0 4
38706: PPUSH
38707: LD_INT 1
38709: PPUSH
38710: CALL 65535 0 3
38714: PPUSH
38715: CALL_OW 1
38719: ST_TO_ADDR
// end ;
38720: GO 38629
38722: POP
38723: POP
// end ;
38724: LD_VAR 0 1
38728: RET
// export function MC_InitSides ( ) ; var i ; begin
38729: LD_INT 0
38731: PPUSH
38732: PPUSH
// if not mc_bases then
38733: LD_EXP 116
38737: NOT
38738: IFFALSE 38742
// exit ;
38740: GO 38816
// for i = 1 to mc_bases do
38742: LD_ADDR_VAR 0 2
38746: PUSH
38747: DOUBLE
38748: LD_INT 1
38750: DEC
38751: ST_TO_ADDR
38752: LD_EXP 116
38756: PUSH
38757: FOR_TO
38758: IFFALSE 38814
// if mc_bases [ i ] then
38760: LD_EXP 116
38764: PUSH
38765: LD_VAR 0 2
38769: ARRAY
38770: IFFALSE 38812
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38772: LD_ADDR_EXP 142
38776: PUSH
38777: LD_EXP 142
38781: PPUSH
38782: LD_VAR 0 2
38786: PPUSH
38787: LD_EXP 116
38791: PUSH
38792: LD_VAR 0 2
38796: ARRAY
38797: PUSH
38798: LD_INT 1
38800: ARRAY
38801: PPUSH
38802: CALL_OW 255
38806: PPUSH
38807: CALL_OW 1
38811: ST_TO_ADDR
38812: GO 38757
38814: POP
38815: POP
// end ;
38816: LD_VAR 0 1
38820: RET
// every 0 0$03 trigger skirmish do
38821: LD_EXP 114
38825: IFFALSE 38979
38827: GO 38829
38829: DISABLE
// begin enable ;
38830: ENABLE
// MC_CheckBuildings ( ) ;
38831: CALL 43477 0 0
// MC_CheckPeopleLife ( ) ;
38835: CALL 43602 0 0
// RaiseSailEvent ( 100 ) ;
38839: LD_INT 100
38841: PPUSH
38842: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38846: LD_INT 103
38848: PPUSH
38849: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38853: LD_INT 104
38855: PPUSH
38856: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38860: LD_INT 105
38862: PPUSH
38863: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38867: LD_INT 106
38869: PPUSH
38870: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38874: LD_INT 107
38876: PPUSH
38877: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38881: LD_INT 108
38883: PPUSH
38884: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38888: LD_INT 109
38890: PPUSH
38891: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38895: LD_INT 110
38897: PPUSH
38898: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38902: LD_INT 111
38904: PPUSH
38905: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38909: LD_INT 112
38911: PPUSH
38912: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38916: LD_INT 113
38918: PPUSH
38919: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38923: LD_INT 120
38925: PPUSH
38926: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38930: LD_INT 121
38932: PPUSH
38933: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38937: LD_INT 122
38939: PPUSH
38940: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38944: LD_INT 123
38946: PPUSH
38947: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38951: LD_INT 124
38953: PPUSH
38954: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38958: LD_INT 125
38960: PPUSH
38961: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38965: LD_INT 126
38967: PPUSH
38968: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38972: LD_INT 200
38974: PPUSH
38975: CALL_OW 427
// end ;
38979: END
// on SailEvent ( event ) do begin if event < 100 then
38980: LD_VAR 0 1
38984: PUSH
38985: LD_INT 100
38987: LESS
38988: IFFALSE 38999
// CustomEvent ( event ) ;
38990: LD_VAR 0 1
38994: PPUSH
38995: CALL 33446 0 1
// if event = 100 then
38999: LD_VAR 0 1
39003: PUSH
39004: LD_INT 100
39006: EQUAL
39007: IFFALSE 39013
// MC_ClassManager ( ) ;
39009: CALL 39405 0 0
// if event = 101 then
39013: LD_VAR 0 1
39017: PUSH
39018: LD_INT 101
39020: EQUAL
39021: IFFALSE 39027
// MC_RepairBuildings ( ) ;
39023: CALL 44187 0 0
// if event = 102 then
39027: LD_VAR 0 1
39031: PUSH
39032: LD_INT 102
39034: EQUAL
39035: IFFALSE 39041
// MC_Heal ( ) ;
39037: CALL 45072 0 0
// if event = 103 then
39041: LD_VAR 0 1
39045: PUSH
39046: LD_INT 103
39048: EQUAL
39049: IFFALSE 39055
// MC_Build ( ) ;
39051: CALL 45494 0 0
// if event = 104 then
39055: LD_VAR 0 1
39059: PUSH
39060: LD_INT 104
39062: EQUAL
39063: IFFALSE 39069
// MC_TurretWeapon ( ) ;
39065: CALL 47135 0 0
// if event = 105 then
39069: LD_VAR 0 1
39073: PUSH
39074: LD_INT 105
39076: EQUAL
39077: IFFALSE 39083
// MC_BuildUpgrade ( ) ;
39079: CALL 46686 0 0
// if event = 106 then
39083: LD_VAR 0 1
39087: PUSH
39088: LD_INT 106
39090: EQUAL
39091: IFFALSE 39097
// MC_PlantMines ( ) ;
39093: CALL 47565 0 0
// if event = 107 then
39097: LD_VAR 0 1
39101: PUSH
39102: LD_INT 107
39104: EQUAL
39105: IFFALSE 39111
// MC_CollectCrates ( ) ;
39107: CALL 48356 0 0
// if event = 108 then
39111: LD_VAR 0 1
39115: PUSH
39116: LD_INT 108
39118: EQUAL
39119: IFFALSE 39125
// MC_LinkRemoteControl ( ) ;
39121: CALL 50132 0 0
// if event = 109 then
39125: LD_VAR 0 1
39129: PUSH
39130: LD_INT 109
39132: EQUAL
39133: IFFALSE 39139
// MC_ProduceVehicle ( ) ;
39135: CALL 50313 0 0
// if event = 110 then
39139: LD_VAR 0 1
39143: PUSH
39144: LD_INT 110
39146: EQUAL
39147: IFFALSE 39153
// MC_SendAttack ( ) ;
39149: CALL 50779 0 0
// if event = 111 then
39153: LD_VAR 0 1
39157: PUSH
39158: LD_INT 111
39160: EQUAL
39161: IFFALSE 39167
// MC_Defend ( ) ;
39163: CALL 50887 0 0
// if event = 112 then
39167: LD_VAR 0 1
39171: PUSH
39172: LD_INT 112
39174: EQUAL
39175: IFFALSE 39181
// MC_Research ( ) ;
39177: CALL 51609 0 0
// if event = 113 then
39181: LD_VAR 0 1
39185: PUSH
39186: LD_INT 113
39188: EQUAL
39189: IFFALSE 39195
// MC_MinesTrigger ( ) ;
39191: CALL 52723 0 0
// if event = 120 then
39195: LD_VAR 0 1
39199: PUSH
39200: LD_INT 120
39202: EQUAL
39203: IFFALSE 39209
// MC_RepairVehicle ( ) ;
39205: CALL 52822 0 0
// if event = 121 then
39209: LD_VAR 0 1
39213: PUSH
39214: LD_INT 121
39216: EQUAL
39217: IFFALSE 39223
// MC_TameApe ( ) ;
39219: CALL 53552 0 0
// if event = 122 then
39223: LD_VAR 0 1
39227: PUSH
39228: LD_INT 122
39230: EQUAL
39231: IFFALSE 39237
// MC_ChangeApeClass ( ) ;
39233: CALL 54381 0 0
// if event = 123 then
39237: LD_VAR 0 1
39241: PUSH
39242: LD_INT 123
39244: EQUAL
39245: IFFALSE 39251
// MC_Bazooka ( ) ;
39247: CALL 55031 0 0
// if event = 124 then
39251: LD_VAR 0 1
39255: PUSH
39256: LD_INT 124
39258: EQUAL
39259: IFFALSE 39265
// MC_TeleportExit ( ) ;
39261: CALL 55229 0 0
// if event = 125 then
39265: LD_VAR 0 1
39269: PUSH
39270: LD_INT 125
39272: EQUAL
39273: IFFALSE 39279
// MC_Deposits ( ) ;
39275: CALL 55876 0 0
// if event = 126 then
39279: LD_VAR 0 1
39283: PUSH
39284: LD_INT 126
39286: EQUAL
39287: IFFALSE 39293
// MC_RemoteDriver ( ) ;
39289: CALL 56501 0 0
// if event = 200 then
39293: LD_VAR 0 1
39297: PUSH
39298: LD_INT 200
39300: EQUAL
39301: IFFALSE 39307
// MC_Idle ( ) ;
39303: CALL 58450 0 0
// end ;
39307: PPOPN 1
39309: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39310: LD_INT 0
39312: PPUSH
39313: PPUSH
// if not mc_bases [ base ] or not tag then
39314: LD_EXP 116
39318: PUSH
39319: LD_VAR 0 1
39323: ARRAY
39324: NOT
39325: PUSH
39326: LD_VAR 0 2
39330: NOT
39331: OR
39332: IFFALSE 39336
// exit ;
39334: GO 39400
// for i in mc_bases [ base ] union mc_ape [ base ] do
39336: LD_ADDR_VAR 0 4
39340: PUSH
39341: LD_EXP 116
39345: PUSH
39346: LD_VAR 0 1
39350: ARRAY
39351: PUSH
39352: LD_EXP 145
39356: PUSH
39357: LD_VAR 0 1
39361: ARRAY
39362: UNION
39363: PUSH
39364: FOR_IN
39365: IFFALSE 39398
// if GetTag ( i ) = tag then
39367: LD_VAR 0 4
39371: PPUSH
39372: CALL_OW 110
39376: PUSH
39377: LD_VAR 0 2
39381: EQUAL
39382: IFFALSE 39396
// SetTag ( i , 0 ) ;
39384: LD_VAR 0 4
39388: PPUSH
39389: LD_INT 0
39391: PPUSH
39392: CALL_OW 109
39396: GO 39364
39398: POP
39399: POP
// end ;
39400: LD_VAR 0 3
39404: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39405: LD_INT 0
39407: PPUSH
39408: PPUSH
39409: PPUSH
39410: PPUSH
39411: PPUSH
39412: PPUSH
39413: PPUSH
39414: PPUSH
// if not mc_bases then
39415: LD_EXP 116
39419: NOT
39420: IFFALSE 39424
// exit ;
39422: GO 39882
// for i = 1 to mc_bases do
39424: LD_ADDR_VAR 0 2
39428: PUSH
39429: DOUBLE
39430: LD_INT 1
39432: DEC
39433: ST_TO_ADDR
39434: LD_EXP 116
39438: PUSH
39439: FOR_TO
39440: IFFALSE 39880
// begin tmp := MC_ClassCheckReq ( i ) ;
39442: LD_ADDR_VAR 0 4
39446: PUSH
39447: LD_VAR 0 2
39451: PPUSH
39452: CALL 39887 0 1
39456: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39457: LD_ADDR_EXP 157
39461: PUSH
39462: LD_EXP 157
39466: PPUSH
39467: LD_VAR 0 2
39471: PPUSH
39472: LD_VAR 0 4
39476: PPUSH
39477: CALL_OW 1
39481: ST_TO_ADDR
// if not tmp then
39482: LD_VAR 0 4
39486: NOT
39487: IFFALSE 39491
// continue ;
39489: GO 39439
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39491: LD_ADDR_VAR 0 6
39495: PUSH
39496: LD_EXP 116
39500: PUSH
39501: LD_VAR 0 2
39505: ARRAY
39506: PPUSH
39507: LD_INT 2
39509: PUSH
39510: LD_INT 30
39512: PUSH
39513: LD_INT 4
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 30
39522: PUSH
39523: LD_INT 5
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: LIST
39534: PPUSH
39535: CALL_OW 72
39539: PUSH
39540: LD_EXP 116
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PPUSH
39551: LD_INT 2
39553: PUSH
39554: LD_INT 30
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 30
39566: PUSH
39567: LD_INT 1
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: LIST
39578: PPUSH
39579: CALL_OW 72
39583: PUSH
39584: LD_EXP 116
39588: PUSH
39589: LD_VAR 0 2
39593: ARRAY
39594: PPUSH
39595: LD_INT 30
39597: PUSH
39598: LD_INT 3
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PPUSH
39605: CALL_OW 72
39609: PUSH
39610: LD_EXP 116
39614: PUSH
39615: LD_VAR 0 2
39619: ARRAY
39620: PPUSH
39621: LD_INT 2
39623: PUSH
39624: LD_INT 30
39626: PUSH
39627: LD_INT 6
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 30
39636: PUSH
39637: LD_INT 7
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 30
39646: PUSH
39647: LD_INT 8
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: PPUSH
39660: CALL_OW 72
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: LIST
39669: LIST
39670: ST_TO_ADDR
// for j = 1 to 4 do
39671: LD_ADDR_VAR 0 3
39675: PUSH
39676: DOUBLE
39677: LD_INT 1
39679: DEC
39680: ST_TO_ADDR
39681: LD_INT 4
39683: PUSH
39684: FOR_TO
39685: IFFALSE 39876
// begin if not tmp [ j ] then
39687: LD_VAR 0 4
39691: PUSH
39692: LD_VAR 0 3
39696: ARRAY
39697: NOT
39698: IFFALSE 39702
// continue ;
39700: GO 39684
// for p in tmp [ j ] do
39702: LD_ADDR_VAR 0 5
39706: PUSH
39707: LD_VAR 0 4
39711: PUSH
39712: LD_VAR 0 3
39716: ARRAY
39717: PUSH
39718: FOR_IN
39719: IFFALSE 39872
// begin if not b [ j ] then
39721: LD_VAR 0 6
39725: PUSH
39726: LD_VAR 0 3
39730: ARRAY
39731: NOT
39732: IFFALSE 39736
// break ;
39734: GO 39872
// e := 0 ;
39736: LD_ADDR_VAR 0 7
39740: PUSH
39741: LD_INT 0
39743: ST_TO_ADDR
// for k in b [ j ] do
39744: LD_ADDR_VAR 0 8
39748: PUSH
39749: LD_VAR 0 6
39753: PUSH
39754: LD_VAR 0 3
39758: ARRAY
39759: PUSH
39760: FOR_IN
39761: IFFALSE 39788
// if IsNotFull ( k ) then
39763: LD_VAR 0 8
39767: PPUSH
39768: CALL 67688 0 1
39772: IFFALSE 39786
// begin e := k ;
39774: LD_ADDR_VAR 0 7
39778: PUSH
39779: LD_VAR 0 8
39783: ST_TO_ADDR
// break ;
39784: GO 39788
// end ;
39786: GO 39760
39788: POP
39789: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39790: LD_VAR 0 7
39794: PUSH
39795: LD_VAR 0 5
39799: PPUSH
39800: LD_VAR 0 7
39804: PPUSH
39805: CALL 100853 0 2
39809: NOT
39810: AND
39811: IFFALSE 39870
// begin if IsInUnit ( p ) then
39813: LD_VAR 0 5
39817: PPUSH
39818: CALL_OW 310
39822: IFFALSE 39833
// ComExitBuilding ( p ) ;
39824: LD_VAR 0 5
39828: PPUSH
39829: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39833: LD_VAR 0 5
39837: PPUSH
39838: LD_VAR 0 7
39842: PPUSH
39843: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39847: LD_VAR 0 5
39851: PPUSH
39852: LD_VAR 0 3
39856: PPUSH
39857: CALL_OW 183
// AddComExitBuilding ( p ) ;
39861: LD_VAR 0 5
39865: PPUSH
39866: CALL_OW 182
// end ; end ;
39870: GO 39718
39872: POP
39873: POP
// end ;
39874: GO 39684
39876: POP
39877: POP
// end ;
39878: GO 39439
39880: POP
39881: POP
// end ;
39882: LD_VAR 0 1
39886: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39887: LD_INT 0
39889: PPUSH
39890: PPUSH
39891: PPUSH
39892: PPUSH
39893: PPUSH
39894: PPUSH
39895: PPUSH
39896: PPUSH
39897: PPUSH
39898: PPUSH
39899: PPUSH
39900: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39901: LD_VAR 0 1
39905: NOT
39906: PUSH
39907: LD_EXP 116
39911: PUSH
39912: LD_VAR 0 1
39916: ARRAY
39917: NOT
39918: OR
39919: PUSH
39920: LD_EXP 116
39924: PUSH
39925: LD_VAR 0 1
39929: ARRAY
39930: PPUSH
39931: LD_INT 2
39933: PUSH
39934: LD_INT 30
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 30
39946: PUSH
39947: LD_INT 1
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: LIST
39958: PPUSH
39959: CALL_OW 72
39963: NOT
39964: OR
39965: IFFALSE 39969
// exit ;
39967: GO 43472
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39969: LD_ADDR_VAR 0 4
39973: PUSH
39974: LD_EXP 116
39978: PUSH
39979: LD_VAR 0 1
39983: ARRAY
39984: PPUSH
39985: LD_INT 2
39987: PUSH
39988: LD_INT 25
39990: PUSH
39991: LD_INT 1
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 25
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 25
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 25
40020: PUSH
40021: LD_INT 4
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 25
40030: PUSH
40031: LD_INT 5
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 25
40040: PUSH
40041: LD_INT 8
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 25
40050: PUSH
40051: LD_INT 9
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: PPUSH
40068: CALL_OW 72
40072: ST_TO_ADDR
// if not tmp then
40073: LD_VAR 0 4
40077: NOT
40078: IFFALSE 40082
// exit ;
40080: GO 43472
// for i in tmp do
40082: LD_ADDR_VAR 0 3
40086: PUSH
40087: LD_VAR 0 4
40091: PUSH
40092: FOR_IN
40093: IFFALSE 40124
// if GetTag ( i ) then
40095: LD_VAR 0 3
40099: PPUSH
40100: CALL_OW 110
40104: IFFALSE 40122
// tmp := tmp diff i ;
40106: LD_ADDR_VAR 0 4
40110: PUSH
40111: LD_VAR 0 4
40115: PUSH
40116: LD_VAR 0 3
40120: DIFF
40121: ST_TO_ADDR
40122: GO 40092
40124: POP
40125: POP
// if not tmp then
40126: LD_VAR 0 4
40130: NOT
40131: IFFALSE 40135
// exit ;
40133: GO 43472
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40135: LD_ADDR_VAR 0 5
40139: PUSH
40140: LD_EXP 116
40144: PUSH
40145: LD_VAR 0 1
40149: ARRAY
40150: PPUSH
40151: LD_INT 2
40153: PUSH
40154: LD_INT 25
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 25
40166: PUSH
40167: LD_INT 5
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 25
40176: PUSH
40177: LD_INT 8
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 25
40186: PUSH
40187: LD_INT 9
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: PPUSH
40201: CALL_OW 72
40205: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40206: LD_ADDR_VAR 0 6
40210: PUSH
40211: LD_EXP 116
40215: PUSH
40216: LD_VAR 0 1
40220: ARRAY
40221: PPUSH
40222: LD_INT 25
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: EMPTY
40229: LIST
40230: LIST
40231: PPUSH
40232: CALL_OW 72
40236: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40237: LD_ADDR_VAR 0 7
40241: PUSH
40242: LD_EXP 116
40246: PUSH
40247: LD_VAR 0 1
40251: ARRAY
40252: PPUSH
40253: LD_INT 25
40255: PUSH
40256: LD_INT 3
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PPUSH
40263: CALL_OW 72
40267: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40268: LD_ADDR_VAR 0 8
40272: PUSH
40273: LD_EXP 116
40277: PUSH
40278: LD_VAR 0 1
40282: ARRAY
40283: PPUSH
40284: LD_INT 25
40286: PUSH
40287: LD_INT 4
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 24
40296: PUSH
40297: LD_INT 251
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PPUSH
40308: CALL_OW 72
40312: ST_TO_ADDR
// if mc_scan [ base ] then
40313: LD_EXP 139
40317: PUSH
40318: LD_VAR 0 1
40322: ARRAY
40323: IFFALSE 40784
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40325: LD_ADDR_EXP 158
40329: PUSH
40330: LD_EXP 158
40334: PPUSH
40335: LD_VAR 0 1
40339: PPUSH
40340: LD_INT 4
40342: PPUSH
40343: CALL_OW 1
40347: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40348: LD_ADDR_VAR 0 12
40352: PUSH
40353: LD_EXP 116
40357: PUSH
40358: LD_VAR 0 1
40362: ARRAY
40363: PPUSH
40364: LD_INT 2
40366: PUSH
40367: LD_INT 30
40369: PUSH
40370: LD_INT 4
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 30
40379: PUSH
40380: LD_INT 5
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: LIST
40391: PPUSH
40392: CALL_OW 72
40396: ST_TO_ADDR
// if not b then
40397: LD_VAR 0 12
40401: NOT
40402: IFFALSE 40406
// exit ;
40404: GO 43472
// p := [ ] ;
40406: LD_ADDR_VAR 0 11
40410: PUSH
40411: EMPTY
40412: ST_TO_ADDR
// if sci >= 2 then
40413: LD_VAR 0 8
40417: PUSH
40418: LD_INT 2
40420: GREATEREQUAL
40421: IFFALSE 40452
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40423: LD_ADDR_VAR 0 8
40427: PUSH
40428: LD_VAR 0 8
40432: PUSH
40433: LD_INT 1
40435: ARRAY
40436: PUSH
40437: LD_VAR 0 8
40441: PUSH
40442: LD_INT 2
40444: ARRAY
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: ST_TO_ADDR
40450: GO 40513
// if sci = 1 then
40452: LD_VAR 0 8
40456: PUSH
40457: LD_INT 1
40459: EQUAL
40460: IFFALSE 40481
// sci := [ sci [ 1 ] ] else
40462: LD_ADDR_VAR 0 8
40466: PUSH
40467: LD_VAR 0 8
40471: PUSH
40472: LD_INT 1
40474: ARRAY
40475: PUSH
40476: EMPTY
40477: LIST
40478: ST_TO_ADDR
40479: GO 40513
// if sci = 0 then
40481: LD_VAR 0 8
40485: PUSH
40486: LD_INT 0
40488: EQUAL
40489: IFFALSE 40513
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40491: LD_ADDR_VAR 0 11
40495: PUSH
40496: LD_VAR 0 4
40500: PPUSH
40501: LD_INT 4
40503: PPUSH
40504: CALL 100716 0 2
40508: PUSH
40509: LD_INT 1
40511: ARRAY
40512: ST_TO_ADDR
// if eng > 4 then
40513: LD_VAR 0 6
40517: PUSH
40518: LD_INT 4
40520: GREATER
40521: IFFALSE 40567
// for i = eng downto 4 do
40523: LD_ADDR_VAR 0 3
40527: PUSH
40528: DOUBLE
40529: LD_VAR 0 6
40533: INC
40534: ST_TO_ADDR
40535: LD_INT 4
40537: PUSH
40538: FOR_DOWNTO
40539: IFFALSE 40565
// eng := eng diff eng [ i ] ;
40541: LD_ADDR_VAR 0 6
40545: PUSH
40546: LD_VAR 0 6
40550: PUSH
40551: LD_VAR 0 6
40555: PUSH
40556: LD_VAR 0 3
40560: ARRAY
40561: DIFF
40562: ST_TO_ADDR
40563: GO 40538
40565: POP
40566: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40567: LD_ADDR_VAR 0 4
40571: PUSH
40572: LD_VAR 0 4
40576: PUSH
40577: LD_VAR 0 5
40581: PUSH
40582: LD_VAR 0 6
40586: UNION
40587: PUSH
40588: LD_VAR 0 7
40592: UNION
40593: PUSH
40594: LD_VAR 0 8
40598: UNION
40599: DIFF
40600: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40601: LD_ADDR_VAR 0 13
40605: PUSH
40606: LD_EXP 116
40610: PUSH
40611: LD_VAR 0 1
40615: ARRAY
40616: PPUSH
40617: LD_INT 2
40619: PUSH
40620: LD_INT 30
40622: PUSH
40623: LD_INT 32
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 30
40632: PUSH
40633: LD_INT 31
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: LIST
40644: PPUSH
40645: CALL_OW 72
40649: PUSH
40650: LD_EXP 116
40654: PUSH
40655: LD_VAR 0 1
40659: ARRAY
40660: PPUSH
40661: LD_INT 2
40663: PUSH
40664: LD_INT 30
40666: PUSH
40667: LD_INT 4
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: LD_INT 30
40676: PUSH
40677: LD_INT 5
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: LIST
40688: PPUSH
40689: CALL_OW 72
40693: PUSH
40694: LD_INT 6
40696: MUL
40697: PLUS
40698: ST_TO_ADDR
// if bcount < tmp then
40699: LD_VAR 0 13
40703: PUSH
40704: LD_VAR 0 4
40708: LESS
40709: IFFALSE 40755
// for i = tmp downto bcount do
40711: LD_ADDR_VAR 0 3
40715: PUSH
40716: DOUBLE
40717: LD_VAR 0 4
40721: INC
40722: ST_TO_ADDR
40723: LD_VAR 0 13
40727: PUSH
40728: FOR_DOWNTO
40729: IFFALSE 40753
// tmp := Delete ( tmp , tmp ) ;
40731: LD_ADDR_VAR 0 4
40735: PUSH
40736: LD_VAR 0 4
40740: PPUSH
40741: LD_VAR 0 4
40745: PPUSH
40746: CALL_OW 3
40750: ST_TO_ADDR
40751: GO 40728
40753: POP
40754: POP
// result := [ tmp , 0 , 0 , p ] ;
40755: LD_ADDR_VAR 0 2
40759: PUSH
40760: LD_VAR 0 4
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_VAR 0 11
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: ST_TO_ADDR
// exit ;
40782: GO 43472
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40784: LD_EXP 116
40788: PUSH
40789: LD_VAR 0 1
40793: ARRAY
40794: PPUSH
40795: LD_INT 2
40797: PUSH
40798: LD_INT 30
40800: PUSH
40801: LD_INT 6
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 30
40810: PUSH
40811: LD_INT 7
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 30
40820: PUSH
40821: LD_INT 8
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: LIST
40832: LIST
40833: PPUSH
40834: CALL_OW 72
40838: NOT
40839: PUSH
40840: LD_EXP 116
40844: PUSH
40845: LD_VAR 0 1
40849: ARRAY
40850: PPUSH
40851: LD_INT 30
40853: PUSH
40854: LD_INT 3
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PPUSH
40861: CALL_OW 72
40865: NOT
40866: AND
40867: IFFALSE 40939
// begin if eng = tmp then
40869: LD_VAR 0 6
40873: PUSH
40874: LD_VAR 0 4
40878: EQUAL
40879: IFFALSE 40883
// exit ;
40881: GO 43472
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40883: LD_ADDR_EXP 158
40887: PUSH
40888: LD_EXP 158
40892: PPUSH
40893: LD_VAR 0 1
40897: PPUSH
40898: LD_INT 1
40900: PPUSH
40901: CALL_OW 1
40905: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40906: LD_ADDR_VAR 0 2
40910: PUSH
40911: LD_INT 0
40913: PUSH
40914: LD_VAR 0 4
40918: PUSH
40919: LD_VAR 0 6
40923: DIFF
40924: PUSH
40925: LD_INT 0
40927: PUSH
40928: LD_INT 0
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: ST_TO_ADDR
// exit ;
40937: GO 43472
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40939: LD_EXP 143
40943: PUSH
40944: LD_EXP 142
40948: PUSH
40949: LD_VAR 0 1
40953: ARRAY
40954: ARRAY
40955: PUSH
40956: LD_EXP 116
40960: PUSH
40961: LD_VAR 0 1
40965: ARRAY
40966: PPUSH
40967: LD_INT 2
40969: PUSH
40970: LD_INT 30
40972: PUSH
40973: LD_INT 6
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 30
40982: PUSH
40983: LD_INT 7
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 30
40992: PUSH
40993: LD_INT 8
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: PPUSH
41006: CALL_OW 72
41010: AND
41011: PUSH
41012: LD_EXP 116
41016: PUSH
41017: LD_VAR 0 1
41021: ARRAY
41022: PPUSH
41023: LD_INT 30
41025: PUSH
41026: LD_INT 3
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PPUSH
41033: CALL_OW 72
41037: NOT
41038: AND
41039: IFFALSE 41253
// begin if sci >= 6 then
41041: LD_VAR 0 8
41045: PUSH
41046: LD_INT 6
41048: GREATEREQUAL
41049: IFFALSE 41053
// exit ;
41051: GO 43472
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41053: LD_ADDR_EXP 158
41057: PUSH
41058: LD_EXP 158
41062: PPUSH
41063: LD_VAR 0 1
41067: PPUSH
41068: LD_INT 2
41070: PPUSH
41071: CALL_OW 1
41075: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41076: LD_ADDR_VAR 0 9
41080: PUSH
41081: LD_VAR 0 4
41085: PUSH
41086: LD_VAR 0 8
41090: DIFF
41091: PPUSH
41092: LD_INT 4
41094: PPUSH
41095: CALL 100716 0 2
41099: ST_TO_ADDR
// p := [ ] ;
41100: LD_ADDR_VAR 0 11
41104: PUSH
41105: EMPTY
41106: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41107: LD_VAR 0 8
41111: PUSH
41112: LD_INT 6
41114: LESS
41115: PUSH
41116: LD_VAR 0 9
41120: PUSH
41121: LD_INT 6
41123: GREATER
41124: AND
41125: IFFALSE 41206
// begin for i = 1 to 6 - sci do
41127: LD_ADDR_VAR 0 3
41131: PUSH
41132: DOUBLE
41133: LD_INT 1
41135: DEC
41136: ST_TO_ADDR
41137: LD_INT 6
41139: PUSH
41140: LD_VAR 0 8
41144: MINUS
41145: PUSH
41146: FOR_TO
41147: IFFALSE 41202
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41149: LD_ADDR_VAR 0 11
41153: PUSH
41154: LD_VAR 0 11
41158: PPUSH
41159: LD_VAR 0 11
41163: PUSH
41164: LD_INT 1
41166: PLUS
41167: PPUSH
41168: LD_VAR 0 9
41172: PUSH
41173: LD_INT 1
41175: ARRAY
41176: PPUSH
41177: CALL_OW 2
41181: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41182: LD_ADDR_VAR 0 9
41186: PUSH
41187: LD_VAR 0 9
41191: PPUSH
41192: LD_INT 1
41194: PPUSH
41195: CALL_OW 3
41199: ST_TO_ADDR
// end ;
41200: GO 41146
41202: POP
41203: POP
// end else
41204: GO 41226
// if sort then
41206: LD_VAR 0 9
41210: IFFALSE 41226
// p := sort [ 1 ] ;
41212: LD_ADDR_VAR 0 11
41216: PUSH
41217: LD_VAR 0 9
41221: PUSH
41222: LD_INT 1
41224: ARRAY
41225: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41226: LD_ADDR_VAR 0 2
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: LD_INT 0
41236: PUSH
41237: LD_INT 0
41239: PUSH
41240: LD_VAR 0 11
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: ST_TO_ADDR
// exit ;
41251: GO 43472
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41253: LD_EXP 143
41257: PUSH
41258: LD_EXP 142
41262: PUSH
41263: LD_VAR 0 1
41267: ARRAY
41268: ARRAY
41269: PUSH
41270: LD_EXP 116
41274: PUSH
41275: LD_VAR 0 1
41279: ARRAY
41280: PPUSH
41281: LD_INT 2
41283: PUSH
41284: LD_INT 30
41286: PUSH
41287: LD_INT 6
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 30
41296: PUSH
41297: LD_INT 7
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 30
41306: PUSH
41307: LD_INT 8
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: LIST
41318: LIST
41319: PPUSH
41320: CALL_OW 72
41324: AND
41325: PUSH
41326: LD_EXP 116
41330: PUSH
41331: LD_VAR 0 1
41335: ARRAY
41336: PPUSH
41337: LD_INT 30
41339: PUSH
41340: LD_INT 3
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PPUSH
41347: CALL_OW 72
41351: AND
41352: IFFALSE 42086
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41354: LD_ADDR_EXP 158
41358: PUSH
41359: LD_EXP 158
41363: PPUSH
41364: LD_VAR 0 1
41368: PPUSH
41369: LD_INT 3
41371: PPUSH
41372: CALL_OW 1
41376: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41377: LD_ADDR_VAR 0 2
41381: PUSH
41382: LD_INT 0
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 0
41390: PUSH
41391: LD_INT 0
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: ST_TO_ADDR
// if not eng then
41400: LD_VAR 0 6
41404: NOT
41405: IFFALSE 41468
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41407: LD_ADDR_VAR 0 11
41411: PUSH
41412: LD_VAR 0 4
41416: PPUSH
41417: LD_INT 2
41419: PPUSH
41420: CALL 100716 0 2
41424: PUSH
41425: LD_INT 1
41427: ARRAY
41428: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41429: LD_ADDR_VAR 0 2
41433: PUSH
41434: LD_VAR 0 2
41438: PPUSH
41439: LD_INT 2
41441: PPUSH
41442: LD_VAR 0 11
41446: PPUSH
41447: CALL_OW 1
41451: ST_TO_ADDR
// tmp := tmp diff p ;
41452: LD_ADDR_VAR 0 4
41456: PUSH
41457: LD_VAR 0 4
41461: PUSH
41462: LD_VAR 0 11
41466: DIFF
41467: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41468: LD_VAR 0 4
41472: PUSH
41473: LD_VAR 0 8
41477: PUSH
41478: LD_INT 6
41480: LESS
41481: AND
41482: IFFALSE 41670
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41484: LD_ADDR_VAR 0 9
41488: PUSH
41489: LD_VAR 0 4
41493: PUSH
41494: LD_VAR 0 8
41498: PUSH
41499: LD_VAR 0 7
41503: UNION
41504: DIFF
41505: PPUSH
41506: LD_INT 4
41508: PPUSH
41509: CALL 100716 0 2
41513: ST_TO_ADDR
// p := [ ] ;
41514: LD_ADDR_VAR 0 11
41518: PUSH
41519: EMPTY
41520: ST_TO_ADDR
// if sort then
41521: LD_VAR 0 9
41525: IFFALSE 41641
// for i = 1 to 6 - sci do
41527: LD_ADDR_VAR 0 3
41531: PUSH
41532: DOUBLE
41533: LD_INT 1
41535: DEC
41536: ST_TO_ADDR
41537: LD_INT 6
41539: PUSH
41540: LD_VAR 0 8
41544: MINUS
41545: PUSH
41546: FOR_TO
41547: IFFALSE 41639
// begin if i = sort then
41549: LD_VAR 0 3
41553: PUSH
41554: LD_VAR 0 9
41558: EQUAL
41559: IFFALSE 41563
// break ;
41561: GO 41639
// if GetClass ( i ) = 4 then
41563: LD_VAR 0 3
41567: PPUSH
41568: CALL_OW 257
41572: PUSH
41573: LD_INT 4
41575: EQUAL
41576: IFFALSE 41580
// continue ;
41578: GO 41546
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41580: LD_ADDR_VAR 0 11
41584: PUSH
41585: LD_VAR 0 11
41589: PPUSH
41590: LD_VAR 0 11
41594: PUSH
41595: LD_INT 1
41597: PLUS
41598: PPUSH
41599: LD_VAR 0 9
41603: PUSH
41604: LD_VAR 0 3
41608: ARRAY
41609: PPUSH
41610: CALL_OW 2
41614: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41615: LD_ADDR_VAR 0 4
41619: PUSH
41620: LD_VAR 0 4
41624: PUSH
41625: LD_VAR 0 9
41629: PUSH
41630: LD_VAR 0 3
41634: ARRAY
41635: DIFF
41636: ST_TO_ADDR
// end ;
41637: GO 41546
41639: POP
41640: POP
// if p then
41641: LD_VAR 0 11
41645: IFFALSE 41670
// result := Replace ( result , 4 , p ) ;
41647: LD_ADDR_VAR 0 2
41651: PUSH
41652: LD_VAR 0 2
41656: PPUSH
41657: LD_INT 4
41659: PPUSH
41660: LD_VAR 0 11
41664: PPUSH
41665: CALL_OW 1
41669: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41670: LD_VAR 0 4
41674: PUSH
41675: LD_VAR 0 7
41679: PUSH
41680: LD_INT 6
41682: LESS
41683: AND
41684: IFFALSE 41872
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41686: LD_ADDR_VAR 0 9
41690: PUSH
41691: LD_VAR 0 4
41695: PUSH
41696: LD_VAR 0 8
41700: PUSH
41701: LD_VAR 0 7
41705: UNION
41706: DIFF
41707: PPUSH
41708: LD_INT 3
41710: PPUSH
41711: CALL 100716 0 2
41715: ST_TO_ADDR
// p := [ ] ;
41716: LD_ADDR_VAR 0 11
41720: PUSH
41721: EMPTY
41722: ST_TO_ADDR
// if sort then
41723: LD_VAR 0 9
41727: IFFALSE 41843
// for i = 1 to 6 - mech do
41729: LD_ADDR_VAR 0 3
41733: PUSH
41734: DOUBLE
41735: LD_INT 1
41737: DEC
41738: ST_TO_ADDR
41739: LD_INT 6
41741: PUSH
41742: LD_VAR 0 7
41746: MINUS
41747: PUSH
41748: FOR_TO
41749: IFFALSE 41841
// begin if i = sort then
41751: LD_VAR 0 3
41755: PUSH
41756: LD_VAR 0 9
41760: EQUAL
41761: IFFALSE 41765
// break ;
41763: GO 41841
// if GetClass ( i ) = 3 then
41765: LD_VAR 0 3
41769: PPUSH
41770: CALL_OW 257
41774: PUSH
41775: LD_INT 3
41777: EQUAL
41778: IFFALSE 41782
// continue ;
41780: GO 41748
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41782: LD_ADDR_VAR 0 11
41786: PUSH
41787: LD_VAR 0 11
41791: PPUSH
41792: LD_VAR 0 11
41796: PUSH
41797: LD_INT 1
41799: PLUS
41800: PPUSH
41801: LD_VAR 0 9
41805: PUSH
41806: LD_VAR 0 3
41810: ARRAY
41811: PPUSH
41812: CALL_OW 2
41816: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41817: LD_ADDR_VAR 0 4
41821: PUSH
41822: LD_VAR 0 4
41826: PUSH
41827: LD_VAR 0 9
41831: PUSH
41832: LD_VAR 0 3
41836: ARRAY
41837: DIFF
41838: ST_TO_ADDR
// end ;
41839: GO 41748
41841: POP
41842: POP
// if p then
41843: LD_VAR 0 11
41847: IFFALSE 41872
// result := Replace ( result , 3 , p ) ;
41849: LD_ADDR_VAR 0 2
41853: PUSH
41854: LD_VAR 0 2
41858: PPUSH
41859: LD_INT 3
41861: PPUSH
41862: LD_VAR 0 11
41866: PPUSH
41867: CALL_OW 1
41871: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41872: LD_VAR 0 4
41876: PUSH
41877: LD_INT 6
41879: GREATER
41880: PUSH
41881: LD_VAR 0 6
41885: PUSH
41886: LD_INT 6
41888: LESS
41889: AND
41890: IFFALSE 42084
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41892: LD_ADDR_VAR 0 9
41896: PUSH
41897: LD_VAR 0 4
41901: PUSH
41902: LD_VAR 0 8
41906: PUSH
41907: LD_VAR 0 7
41911: UNION
41912: PUSH
41913: LD_VAR 0 6
41917: UNION
41918: DIFF
41919: PPUSH
41920: LD_INT 2
41922: PPUSH
41923: CALL 100716 0 2
41927: ST_TO_ADDR
// p := [ ] ;
41928: LD_ADDR_VAR 0 11
41932: PUSH
41933: EMPTY
41934: ST_TO_ADDR
// if sort then
41935: LD_VAR 0 9
41939: IFFALSE 42055
// for i = 1 to 6 - eng do
41941: LD_ADDR_VAR 0 3
41945: PUSH
41946: DOUBLE
41947: LD_INT 1
41949: DEC
41950: ST_TO_ADDR
41951: LD_INT 6
41953: PUSH
41954: LD_VAR 0 6
41958: MINUS
41959: PUSH
41960: FOR_TO
41961: IFFALSE 42053
// begin if i = sort then
41963: LD_VAR 0 3
41967: PUSH
41968: LD_VAR 0 9
41972: EQUAL
41973: IFFALSE 41977
// break ;
41975: GO 42053
// if GetClass ( i ) = 2 then
41977: LD_VAR 0 3
41981: PPUSH
41982: CALL_OW 257
41986: PUSH
41987: LD_INT 2
41989: EQUAL
41990: IFFALSE 41994
// continue ;
41992: GO 41960
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41994: LD_ADDR_VAR 0 11
41998: PUSH
41999: LD_VAR 0 11
42003: PPUSH
42004: LD_VAR 0 11
42008: PUSH
42009: LD_INT 1
42011: PLUS
42012: PPUSH
42013: LD_VAR 0 9
42017: PUSH
42018: LD_VAR 0 3
42022: ARRAY
42023: PPUSH
42024: CALL_OW 2
42028: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42029: LD_ADDR_VAR 0 4
42033: PUSH
42034: LD_VAR 0 4
42038: PUSH
42039: LD_VAR 0 9
42043: PUSH
42044: LD_VAR 0 3
42048: ARRAY
42049: DIFF
42050: ST_TO_ADDR
// end ;
42051: GO 41960
42053: POP
42054: POP
// if p then
42055: LD_VAR 0 11
42059: IFFALSE 42084
// result := Replace ( result , 2 , p ) ;
42061: LD_ADDR_VAR 0 2
42065: PUSH
42066: LD_VAR 0 2
42070: PPUSH
42071: LD_INT 2
42073: PPUSH
42074: LD_VAR 0 11
42078: PPUSH
42079: CALL_OW 1
42083: ST_TO_ADDR
// end ; exit ;
42084: GO 43472
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42086: LD_EXP 143
42090: PUSH
42091: LD_EXP 142
42095: PUSH
42096: LD_VAR 0 1
42100: ARRAY
42101: ARRAY
42102: NOT
42103: PUSH
42104: LD_EXP 116
42108: PUSH
42109: LD_VAR 0 1
42113: ARRAY
42114: PPUSH
42115: LD_INT 30
42117: PUSH
42118: LD_INT 3
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PPUSH
42125: CALL_OW 72
42129: AND
42130: PUSH
42131: LD_EXP 121
42135: PUSH
42136: LD_VAR 0 1
42140: ARRAY
42141: AND
42142: IFFALSE 42750
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42144: LD_ADDR_EXP 158
42148: PUSH
42149: LD_EXP 158
42153: PPUSH
42154: LD_VAR 0 1
42158: PPUSH
42159: LD_INT 5
42161: PPUSH
42162: CALL_OW 1
42166: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42167: LD_ADDR_VAR 0 2
42171: PUSH
42172: LD_INT 0
42174: PUSH
42175: LD_INT 0
42177: PUSH
42178: LD_INT 0
42180: PUSH
42181: LD_INT 0
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: ST_TO_ADDR
// if sci > 1 then
42190: LD_VAR 0 8
42194: PUSH
42195: LD_INT 1
42197: GREATER
42198: IFFALSE 42226
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42200: LD_ADDR_VAR 0 4
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: LD_VAR 0 8
42214: PUSH
42215: LD_VAR 0 8
42219: PUSH
42220: LD_INT 1
42222: ARRAY
42223: DIFF
42224: DIFF
42225: ST_TO_ADDR
// if tmp and not sci then
42226: LD_VAR 0 4
42230: PUSH
42231: LD_VAR 0 8
42235: NOT
42236: AND
42237: IFFALSE 42306
// begin sort := SortBySkill ( tmp , 4 ) ;
42239: LD_ADDR_VAR 0 9
42243: PUSH
42244: LD_VAR 0 4
42248: PPUSH
42249: LD_INT 4
42251: PPUSH
42252: CALL 100716 0 2
42256: ST_TO_ADDR
// if sort then
42257: LD_VAR 0 9
42261: IFFALSE 42277
// p := sort [ 1 ] ;
42263: LD_ADDR_VAR 0 11
42267: PUSH
42268: LD_VAR 0 9
42272: PUSH
42273: LD_INT 1
42275: ARRAY
42276: ST_TO_ADDR
// if p then
42277: LD_VAR 0 11
42281: IFFALSE 42306
// result := Replace ( result , 4 , p ) ;
42283: LD_ADDR_VAR 0 2
42287: PUSH
42288: LD_VAR 0 2
42292: PPUSH
42293: LD_INT 4
42295: PPUSH
42296: LD_VAR 0 11
42300: PPUSH
42301: CALL_OW 1
42305: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42306: LD_ADDR_VAR 0 4
42310: PUSH
42311: LD_VAR 0 4
42315: PUSH
42316: LD_VAR 0 7
42320: DIFF
42321: ST_TO_ADDR
// if tmp and mech < 6 then
42322: LD_VAR 0 4
42326: PUSH
42327: LD_VAR 0 7
42331: PUSH
42332: LD_INT 6
42334: LESS
42335: AND
42336: IFFALSE 42524
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42338: LD_ADDR_VAR 0 9
42342: PUSH
42343: LD_VAR 0 4
42347: PUSH
42348: LD_VAR 0 8
42352: PUSH
42353: LD_VAR 0 7
42357: UNION
42358: DIFF
42359: PPUSH
42360: LD_INT 3
42362: PPUSH
42363: CALL 100716 0 2
42367: ST_TO_ADDR
// p := [ ] ;
42368: LD_ADDR_VAR 0 11
42372: PUSH
42373: EMPTY
42374: ST_TO_ADDR
// if sort then
42375: LD_VAR 0 9
42379: IFFALSE 42495
// for i = 1 to 6 - mech do
42381: LD_ADDR_VAR 0 3
42385: PUSH
42386: DOUBLE
42387: LD_INT 1
42389: DEC
42390: ST_TO_ADDR
42391: LD_INT 6
42393: PUSH
42394: LD_VAR 0 7
42398: MINUS
42399: PUSH
42400: FOR_TO
42401: IFFALSE 42493
// begin if i = sort then
42403: LD_VAR 0 3
42407: PUSH
42408: LD_VAR 0 9
42412: EQUAL
42413: IFFALSE 42417
// break ;
42415: GO 42493
// if GetClass ( i ) = 3 then
42417: LD_VAR 0 3
42421: PPUSH
42422: CALL_OW 257
42426: PUSH
42427: LD_INT 3
42429: EQUAL
42430: IFFALSE 42434
// continue ;
42432: GO 42400
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42434: LD_ADDR_VAR 0 11
42438: PUSH
42439: LD_VAR 0 11
42443: PPUSH
42444: LD_VAR 0 11
42448: PUSH
42449: LD_INT 1
42451: PLUS
42452: PPUSH
42453: LD_VAR 0 9
42457: PUSH
42458: LD_VAR 0 3
42462: ARRAY
42463: PPUSH
42464: CALL_OW 2
42468: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42469: LD_ADDR_VAR 0 4
42473: PUSH
42474: LD_VAR 0 4
42478: PUSH
42479: LD_VAR 0 9
42483: PUSH
42484: LD_VAR 0 3
42488: ARRAY
42489: DIFF
42490: ST_TO_ADDR
// end ;
42491: GO 42400
42493: POP
42494: POP
// if p then
42495: LD_VAR 0 11
42499: IFFALSE 42524
// result := Replace ( result , 3 , p ) ;
42501: LD_ADDR_VAR 0 2
42505: PUSH
42506: LD_VAR 0 2
42510: PPUSH
42511: LD_INT 3
42513: PPUSH
42514: LD_VAR 0 11
42518: PPUSH
42519: CALL_OW 1
42523: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42524: LD_ADDR_VAR 0 4
42528: PUSH
42529: LD_VAR 0 4
42533: PUSH
42534: LD_VAR 0 6
42538: DIFF
42539: ST_TO_ADDR
// if tmp and eng < 6 then
42540: LD_VAR 0 4
42544: PUSH
42545: LD_VAR 0 6
42549: PUSH
42550: LD_INT 6
42552: LESS
42553: AND
42554: IFFALSE 42748
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42556: LD_ADDR_VAR 0 9
42560: PUSH
42561: LD_VAR 0 4
42565: PUSH
42566: LD_VAR 0 8
42570: PUSH
42571: LD_VAR 0 7
42575: UNION
42576: PUSH
42577: LD_VAR 0 6
42581: UNION
42582: DIFF
42583: PPUSH
42584: LD_INT 2
42586: PPUSH
42587: CALL 100716 0 2
42591: ST_TO_ADDR
// p := [ ] ;
42592: LD_ADDR_VAR 0 11
42596: PUSH
42597: EMPTY
42598: ST_TO_ADDR
// if sort then
42599: LD_VAR 0 9
42603: IFFALSE 42719
// for i = 1 to 6 - eng do
42605: LD_ADDR_VAR 0 3
42609: PUSH
42610: DOUBLE
42611: LD_INT 1
42613: DEC
42614: ST_TO_ADDR
42615: LD_INT 6
42617: PUSH
42618: LD_VAR 0 6
42622: MINUS
42623: PUSH
42624: FOR_TO
42625: IFFALSE 42717
// begin if i = sort then
42627: LD_VAR 0 3
42631: PUSH
42632: LD_VAR 0 9
42636: EQUAL
42637: IFFALSE 42641
// break ;
42639: GO 42717
// if GetClass ( i ) = 2 then
42641: LD_VAR 0 3
42645: PPUSH
42646: CALL_OW 257
42650: PUSH
42651: LD_INT 2
42653: EQUAL
42654: IFFALSE 42658
// continue ;
42656: GO 42624
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42658: LD_ADDR_VAR 0 11
42662: PUSH
42663: LD_VAR 0 11
42667: PPUSH
42668: LD_VAR 0 11
42672: PUSH
42673: LD_INT 1
42675: PLUS
42676: PPUSH
42677: LD_VAR 0 9
42681: PUSH
42682: LD_VAR 0 3
42686: ARRAY
42687: PPUSH
42688: CALL_OW 2
42692: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42693: LD_ADDR_VAR 0 4
42697: PUSH
42698: LD_VAR 0 4
42702: PUSH
42703: LD_VAR 0 9
42707: PUSH
42708: LD_VAR 0 3
42712: ARRAY
42713: DIFF
42714: ST_TO_ADDR
// end ;
42715: GO 42624
42717: POP
42718: POP
// if p then
42719: LD_VAR 0 11
42723: IFFALSE 42748
// result := Replace ( result , 2 , p ) ;
42725: LD_ADDR_VAR 0 2
42729: PUSH
42730: LD_VAR 0 2
42734: PPUSH
42735: LD_INT 2
42737: PPUSH
42738: LD_VAR 0 11
42742: PPUSH
42743: CALL_OW 1
42747: ST_TO_ADDR
// end ; exit ;
42748: GO 43472
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42750: LD_EXP 143
42754: PUSH
42755: LD_EXP 142
42759: PUSH
42760: LD_VAR 0 1
42764: ARRAY
42765: ARRAY
42766: NOT
42767: PUSH
42768: LD_EXP 116
42772: PUSH
42773: LD_VAR 0 1
42777: ARRAY
42778: PPUSH
42779: LD_INT 30
42781: PUSH
42782: LD_INT 3
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PPUSH
42789: CALL_OW 72
42793: AND
42794: PUSH
42795: LD_EXP 121
42799: PUSH
42800: LD_VAR 0 1
42804: ARRAY
42805: NOT
42806: AND
42807: IFFALSE 43472
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42809: LD_ADDR_EXP 158
42813: PUSH
42814: LD_EXP 158
42818: PPUSH
42819: LD_VAR 0 1
42823: PPUSH
42824: LD_INT 6
42826: PPUSH
42827: CALL_OW 1
42831: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42832: LD_ADDR_VAR 0 2
42836: PUSH
42837: LD_INT 0
42839: PUSH
42840: LD_INT 0
42842: PUSH
42843: LD_INT 0
42845: PUSH
42846: LD_INT 0
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: ST_TO_ADDR
// if sci >= 1 then
42855: LD_VAR 0 8
42859: PUSH
42860: LD_INT 1
42862: GREATEREQUAL
42863: IFFALSE 42885
// tmp := tmp diff sci [ 1 ] ;
42865: LD_ADDR_VAR 0 4
42869: PUSH
42870: LD_VAR 0 4
42874: PUSH
42875: LD_VAR 0 8
42879: PUSH
42880: LD_INT 1
42882: ARRAY
42883: DIFF
42884: ST_TO_ADDR
// if tmp and not sci then
42885: LD_VAR 0 4
42889: PUSH
42890: LD_VAR 0 8
42894: NOT
42895: AND
42896: IFFALSE 42965
// begin sort := SortBySkill ( tmp , 4 ) ;
42898: LD_ADDR_VAR 0 9
42902: PUSH
42903: LD_VAR 0 4
42907: PPUSH
42908: LD_INT 4
42910: PPUSH
42911: CALL 100716 0 2
42915: ST_TO_ADDR
// if sort then
42916: LD_VAR 0 9
42920: IFFALSE 42936
// p := sort [ 1 ] ;
42922: LD_ADDR_VAR 0 11
42926: PUSH
42927: LD_VAR 0 9
42931: PUSH
42932: LD_INT 1
42934: ARRAY
42935: ST_TO_ADDR
// if p then
42936: LD_VAR 0 11
42940: IFFALSE 42965
// result := Replace ( result , 4 , p ) ;
42942: LD_ADDR_VAR 0 2
42946: PUSH
42947: LD_VAR 0 2
42951: PPUSH
42952: LD_INT 4
42954: PPUSH
42955: LD_VAR 0 11
42959: PPUSH
42960: CALL_OW 1
42964: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42965: LD_ADDR_VAR 0 4
42969: PUSH
42970: LD_VAR 0 4
42974: PUSH
42975: LD_VAR 0 7
42979: DIFF
42980: ST_TO_ADDR
// if tmp and mech < 6 then
42981: LD_VAR 0 4
42985: PUSH
42986: LD_VAR 0 7
42990: PUSH
42991: LD_INT 6
42993: LESS
42994: AND
42995: IFFALSE 43177
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42997: LD_ADDR_VAR 0 9
43001: PUSH
43002: LD_VAR 0 4
43006: PUSH
43007: LD_VAR 0 7
43011: DIFF
43012: PPUSH
43013: LD_INT 3
43015: PPUSH
43016: CALL 100716 0 2
43020: ST_TO_ADDR
// p := [ ] ;
43021: LD_ADDR_VAR 0 11
43025: PUSH
43026: EMPTY
43027: ST_TO_ADDR
// if sort then
43028: LD_VAR 0 9
43032: IFFALSE 43148
// for i = 1 to 6 - mech do
43034: LD_ADDR_VAR 0 3
43038: PUSH
43039: DOUBLE
43040: LD_INT 1
43042: DEC
43043: ST_TO_ADDR
43044: LD_INT 6
43046: PUSH
43047: LD_VAR 0 7
43051: MINUS
43052: PUSH
43053: FOR_TO
43054: IFFALSE 43146
// begin if i = sort then
43056: LD_VAR 0 3
43060: PUSH
43061: LD_VAR 0 9
43065: EQUAL
43066: IFFALSE 43070
// break ;
43068: GO 43146
// if GetClass ( i ) = 3 then
43070: LD_VAR 0 3
43074: PPUSH
43075: CALL_OW 257
43079: PUSH
43080: LD_INT 3
43082: EQUAL
43083: IFFALSE 43087
// continue ;
43085: GO 43053
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43087: LD_ADDR_VAR 0 11
43091: PUSH
43092: LD_VAR 0 11
43096: PPUSH
43097: LD_VAR 0 11
43101: PUSH
43102: LD_INT 1
43104: PLUS
43105: PPUSH
43106: LD_VAR 0 9
43110: PUSH
43111: LD_VAR 0 3
43115: ARRAY
43116: PPUSH
43117: CALL_OW 2
43121: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43122: LD_ADDR_VAR 0 4
43126: PUSH
43127: LD_VAR 0 4
43131: PUSH
43132: LD_VAR 0 9
43136: PUSH
43137: LD_VAR 0 3
43141: ARRAY
43142: DIFF
43143: ST_TO_ADDR
// end ;
43144: GO 43053
43146: POP
43147: POP
// if p then
43148: LD_VAR 0 11
43152: IFFALSE 43177
// result := Replace ( result , 3 , p ) ;
43154: LD_ADDR_VAR 0 2
43158: PUSH
43159: LD_VAR 0 2
43163: PPUSH
43164: LD_INT 3
43166: PPUSH
43167: LD_VAR 0 11
43171: PPUSH
43172: CALL_OW 1
43176: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43177: LD_ADDR_VAR 0 4
43181: PUSH
43182: LD_VAR 0 4
43186: PUSH
43187: LD_VAR 0 6
43191: DIFF
43192: ST_TO_ADDR
// if tmp and eng < 4 then
43193: LD_VAR 0 4
43197: PUSH
43198: LD_VAR 0 6
43202: PUSH
43203: LD_INT 4
43205: LESS
43206: AND
43207: IFFALSE 43397
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43209: LD_ADDR_VAR 0 9
43213: PUSH
43214: LD_VAR 0 4
43218: PUSH
43219: LD_VAR 0 7
43223: PUSH
43224: LD_VAR 0 6
43228: UNION
43229: DIFF
43230: PPUSH
43231: LD_INT 2
43233: PPUSH
43234: CALL 100716 0 2
43238: ST_TO_ADDR
// p := [ ] ;
43239: LD_ADDR_VAR 0 11
43243: PUSH
43244: EMPTY
43245: ST_TO_ADDR
// if sort then
43246: LD_VAR 0 9
43250: IFFALSE 43366
// for i = 1 to 4 - eng do
43252: LD_ADDR_VAR 0 3
43256: PUSH
43257: DOUBLE
43258: LD_INT 1
43260: DEC
43261: ST_TO_ADDR
43262: LD_INT 4
43264: PUSH
43265: LD_VAR 0 6
43269: MINUS
43270: PUSH
43271: FOR_TO
43272: IFFALSE 43364
// begin if i = sort then
43274: LD_VAR 0 3
43278: PUSH
43279: LD_VAR 0 9
43283: EQUAL
43284: IFFALSE 43288
// break ;
43286: GO 43364
// if GetClass ( i ) = 2 then
43288: LD_VAR 0 3
43292: PPUSH
43293: CALL_OW 257
43297: PUSH
43298: LD_INT 2
43300: EQUAL
43301: IFFALSE 43305
// continue ;
43303: GO 43271
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43305: LD_ADDR_VAR 0 11
43309: PUSH
43310: LD_VAR 0 11
43314: PPUSH
43315: LD_VAR 0 11
43319: PUSH
43320: LD_INT 1
43322: PLUS
43323: PPUSH
43324: LD_VAR 0 9
43328: PUSH
43329: LD_VAR 0 3
43333: ARRAY
43334: PPUSH
43335: CALL_OW 2
43339: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43340: LD_ADDR_VAR 0 4
43344: PUSH
43345: LD_VAR 0 4
43349: PUSH
43350: LD_VAR 0 9
43354: PUSH
43355: LD_VAR 0 3
43359: ARRAY
43360: DIFF
43361: ST_TO_ADDR
// end ;
43362: GO 43271
43364: POP
43365: POP
// if p then
43366: LD_VAR 0 11
43370: IFFALSE 43395
// result := Replace ( result , 2 , p ) ;
43372: LD_ADDR_VAR 0 2
43376: PUSH
43377: LD_VAR 0 2
43381: PPUSH
43382: LD_INT 2
43384: PPUSH
43385: LD_VAR 0 11
43389: PPUSH
43390: CALL_OW 1
43394: ST_TO_ADDR
// end else
43395: GO 43441
// for i = eng downto 5 do
43397: LD_ADDR_VAR 0 3
43401: PUSH
43402: DOUBLE
43403: LD_VAR 0 6
43407: INC
43408: ST_TO_ADDR
43409: LD_INT 5
43411: PUSH
43412: FOR_DOWNTO
43413: IFFALSE 43439
// tmp := tmp union eng [ i ] ;
43415: LD_ADDR_VAR 0 4
43419: PUSH
43420: LD_VAR 0 4
43424: PUSH
43425: LD_VAR 0 6
43429: PUSH
43430: LD_VAR 0 3
43434: ARRAY
43435: UNION
43436: ST_TO_ADDR
43437: GO 43412
43439: POP
43440: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43441: LD_ADDR_VAR 0 2
43445: PUSH
43446: LD_VAR 0 2
43450: PPUSH
43451: LD_INT 1
43453: PPUSH
43454: LD_VAR 0 4
43458: PUSH
43459: LD_VAR 0 5
43463: DIFF
43464: PPUSH
43465: CALL_OW 1
43469: ST_TO_ADDR
// exit ;
43470: GO 43472
// end ; end ;
43472: LD_VAR 0 2
43476: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43477: LD_INT 0
43479: PPUSH
43480: PPUSH
43481: PPUSH
// if not mc_bases then
43482: LD_EXP 116
43486: NOT
43487: IFFALSE 43491
// exit ;
43489: GO 43597
// for i = 1 to mc_bases do
43491: LD_ADDR_VAR 0 2
43495: PUSH
43496: DOUBLE
43497: LD_INT 1
43499: DEC
43500: ST_TO_ADDR
43501: LD_EXP 116
43505: PUSH
43506: FOR_TO
43507: IFFALSE 43588
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43509: LD_ADDR_VAR 0 3
43513: PUSH
43514: LD_EXP 116
43518: PUSH
43519: LD_VAR 0 2
43523: ARRAY
43524: PPUSH
43525: LD_INT 21
43527: PUSH
43528: LD_INT 3
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 3
43537: PUSH
43538: LD_INT 24
43540: PUSH
43541: LD_INT 1000
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PPUSH
43556: CALL_OW 72
43560: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43561: LD_ADDR_EXP 117
43565: PUSH
43566: LD_EXP 117
43570: PPUSH
43571: LD_VAR 0 2
43575: PPUSH
43576: LD_VAR 0 3
43580: PPUSH
43581: CALL_OW 1
43585: ST_TO_ADDR
// end ;
43586: GO 43506
43588: POP
43589: POP
// RaiseSailEvent ( 101 ) ;
43590: LD_INT 101
43592: PPUSH
43593: CALL_OW 427
// end ;
43597: LD_VAR 0 1
43601: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43602: LD_INT 0
43604: PPUSH
43605: PPUSH
43606: PPUSH
43607: PPUSH
43608: PPUSH
43609: PPUSH
43610: PPUSH
// if not mc_bases then
43611: LD_EXP 116
43615: NOT
43616: IFFALSE 43620
// exit ;
43618: GO 44182
// for i = 1 to mc_bases do
43620: LD_ADDR_VAR 0 2
43624: PUSH
43625: DOUBLE
43626: LD_INT 1
43628: DEC
43629: ST_TO_ADDR
43630: LD_EXP 116
43634: PUSH
43635: FOR_TO
43636: IFFALSE 44173
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43638: LD_ADDR_VAR 0 5
43642: PUSH
43643: LD_EXP 116
43647: PUSH
43648: LD_VAR 0 2
43652: ARRAY
43653: PUSH
43654: LD_EXP 145
43658: PUSH
43659: LD_VAR 0 2
43663: ARRAY
43664: UNION
43665: PPUSH
43666: LD_INT 21
43668: PUSH
43669: LD_INT 1
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 1
43678: PUSH
43679: LD_INT 3
43681: PUSH
43682: LD_INT 54
43684: PUSH
43685: EMPTY
43686: LIST
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 3
43694: PUSH
43695: LD_INT 24
43697: PUSH
43698: LD_INT 1000
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: LIST
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PPUSH
43718: CALL_OW 72
43722: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43723: LD_ADDR_VAR 0 6
43727: PUSH
43728: LD_EXP 116
43732: PUSH
43733: LD_VAR 0 2
43737: ARRAY
43738: PPUSH
43739: LD_INT 21
43741: PUSH
43742: LD_INT 1
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 1
43751: PUSH
43752: LD_INT 3
43754: PUSH
43755: LD_INT 54
43757: PUSH
43758: EMPTY
43759: LIST
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 3
43767: PUSH
43768: LD_INT 24
43770: PUSH
43771: LD_INT 250
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: LIST
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PPUSH
43791: CALL_OW 72
43795: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43796: LD_ADDR_VAR 0 7
43800: PUSH
43801: LD_VAR 0 5
43805: PUSH
43806: LD_VAR 0 6
43810: DIFF
43811: ST_TO_ADDR
// if not need_heal_1 then
43812: LD_VAR 0 6
43816: NOT
43817: IFFALSE 43850
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43819: LD_ADDR_EXP 119
43823: PUSH
43824: LD_EXP 119
43828: PPUSH
43829: LD_VAR 0 2
43833: PUSH
43834: LD_INT 1
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PPUSH
43841: EMPTY
43842: PPUSH
43843: CALL 70458 0 3
43847: ST_TO_ADDR
43848: GO 43920
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43850: LD_ADDR_EXP 119
43854: PUSH
43855: LD_EXP 119
43859: PPUSH
43860: LD_VAR 0 2
43864: PUSH
43865: LD_INT 1
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PPUSH
43872: LD_EXP 119
43876: PUSH
43877: LD_VAR 0 2
43881: ARRAY
43882: PUSH
43883: LD_INT 1
43885: ARRAY
43886: PPUSH
43887: LD_INT 3
43889: PUSH
43890: LD_INT 24
43892: PUSH
43893: LD_INT 1000
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PPUSH
43904: CALL_OW 72
43908: PUSH
43909: LD_VAR 0 6
43913: UNION
43914: PPUSH
43915: CALL 70458 0 3
43919: ST_TO_ADDR
// if not need_heal_2 then
43920: LD_VAR 0 7
43924: NOT
43925: IFFALSE 43958
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43927: LD_ADDR_EXP 119
43931: PUSH
43932: LD_EXP 119
43936: PPUSH
43937: LD_VAR 0 2
43941: PUSH
43942: LD_INT 2
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PPUSH
43949: EMPTY
43950: PPUSH
43951: CALL 70458 0 3
43955: ST_TO_ADDR
43956: GO 43990
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43958: LD_ADDR_EXP 119
43962: PUSH
43963: LD_EXP 119
43967: PPUSH
43968: LD_VAR 0 2
43972: PUSH
43973: LD_INT 2
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PPUSH
43980: LD_VAR 0 7
43984: PPUSH
43985: CALL 70458 0 3
43989: ST_TO_ADDR
// if need_heal_2 then
43990: LD_VAR 0 7
43994: IFFALSE 44155
// for j in need_heal_2 do
43996: LD_ADDR_VAR 0 3
44000: PUSH
44001: LD_VAR 0 7
44005: PUSH
44006: FOR_IN
44007: IFFALSE 44153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44009: LD_ADDR_VAR 0 5
44013: PUSH
44014: LD_EXP 116
44018: PUSH
44019: LD_VAR 0 2
44023: ARRAY
44024: PPUSH
44025: LD_INT 2
44027: PUSH
44028: LD_INT 30
44030: PUSH
44031: LD_INT 6
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 30
44040: PUSH
44041: LD_INT 7
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 30
44050: PUSH
44051: LD_INT 8
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: PUSH
44058: LD_INT 30
44060: PUSH
44061: LD_INT 0
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 30
44070: PUSH
44071: LD_INT 1
44073: PUSH
44074: EMPTY
44075: LIST
44076: LIST
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: PPUSH
44086: CALL_OW 72
44090: ST_TO_ADDR
// if tmp then
44091: LD_VAR 0 5
44095: IFFALSE 44151
// begin k := NearestUnitToUnit ( tmp , j ) ;
44097: LD_ADDR_VAR 0 4
44101: PUSH
44102: LD_VAR 0 5
44106: PPUSH
44107: LD_VAR 0 3
44111: PPUSH
44112: CALL_OW 74
44116: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44117: LD_VAR 0 3
44121: PPUSH
44122: LD_VAR 0 4
44126: PPUSH
44127: CALL_OW 296
44131: PUSH
44132: LD_INT 5
44134: GREATER
44135: IFFALSE 44151
// ComMoveToNearbyEntrance ( j , k ) ;
44137: LD_VAR 0 3
44141: PPUSH
44142: LD_VAR 0 4
44146: PPUSH
44147: CALL 103077 0 2
// end ; end ;
44151: GO 44006
44153: POP
44154: POP
// if not need_heal_1 and not need_heal_2 then
44155: LD_VAR 0 6
44159: NOT
44160: PUSH
44161: LD_VAR 0 7
44165: NOT
44166: AND
44167: IFFALSE 44171
// continue ;
44169: GO 43635
// end ;
44171: GO 43635
44173: POP
44174: POP
// RaiseSailEvent ( 102 ) ;
44175: LD_INT 102
44177: PPUSH
44178: CALL_OW 427
// end ;
44182: LD_VAR 0 1
44186: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44187: LD_INT 0
44189: PPUSH
44190: PPUSH
44191: PPUSH
44192: PPUSH
44193: PPUSH
44194: PPUSH
44195: PPUSH
44196: PPUSH
// if not mc_bases then
44197: LD_EXP 116
44201: NOT
44202: IFFALSE 44206
// exit ;
44204: GO 45067
// for i = 1 to mc_bases do
44206: LD_ADDR_VAR 0 2
44210: PUSH
44211: DOUBLE
44212: LD_INT 1
44214: DEC
44215: ST_TO_ADDR
44216: LD_EXP 116
44220: PUSH
44221: FOR_TO
44222: IFFALSE 45065
// begin if not mc_building_need_repair [ i ] then
44224: LD_EXP 117
44228: PUSH
44229: LD_VAR 0 2
44233: ARRAY
44234: NOT
44235: IFFALSE 44422
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44237: LD_ADDR_VAR 0 6
44241: PUSH
44242: LD_EXP 135
44246: PUSH
44247: LD_VAR 0 2
44251: ARRAY
44252: PPUSH
44253: LD_INT 3
44255: PUSH
44256: LD_INT 24
44258: PUSH
44259: LD_INT 1000
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 2
44272: PUSH
44273: LD_INT 34
44275: PUSH
44276: LD_INT 13
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 34
44285: PUSH
44286: LD_INT 52
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 34
44295: PUSH
44296: LD_EXP 101
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: LIST
44309: LIST
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PPUSH
44315: CALL_OW 72
44319: ST_TO_ADDR
// if cranes then
44320: LD_VAR 0 6
44324: IFFALSE 44386
// for j in cranes do
44326: LD_ADDR_VAR 0 3
44330: PUSH
44331: LD_VAR 0 6
44335: PUSH
44336: FOR_IN
44337: IFFALSE 44384
// if not IsInArea ( j , mc_parking [ i ] ) then
44339: LD_VAR 0 3
44343: PPUSH
44344: LD_EXP 140
44348: PUSH
44349: LD_VAR 0 2
44353: ARRAY
44354: PPUSH
44355: CALL_OW 308
44359: NOT
44360: IFFALSE 44382
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44362: LD_VAR 0 3
44366: PPUSH
44367: LD_EXP 140
44371: PUSH
44372: LD_VAR 0 2
44376: ARRAY
44377: PPUSH
44378: CALL_OW 113
44382: GO 44336
44384: POP
44385: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44386: LD_ADDR_EXP 118
44390: PUSH
44391: LD_EXP 118
44395: PPUSH
44396: LD_VAR 0 2
44400: PPUSH
44401: EMPTY
44402: PPUSH
44403: CALL_OW 1
44407: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44408: LD_VAR 0 2
44412: PPUSH
44413: LD_INT 101
44415: PPUSH
44416: CALL 39310 0 2
// continue ;
44420: GO 44221
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44422: LD_ADDR_EXP 122
44426: PUSH
44427: LD_EXP 122
44431: PPUSH
44432: LD_VAR 0 2
44436: PPUSH
44437: EMPTY
44438: PPUSH
44439: CALL_OW 1
44443: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44444: LD_VAR 0 2
44448: PPUSH
44449: LD_INT 103
44451: PPUSH
44452: CALL 39310 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44456: LD_ADDR_VAR 0 5
44460: PUSH
44461: LD_EXP 116
44465: PUSH
44466: LD_VAR 0 2
44470: ARRAY
44471: PUSH
44472: LD_EXP 145
44476: PUSH
44477: LD_VAR 0 2
44481: ARRAY
44482: UNION
44483: PPUSH
44484: LD_INT 2
44486: PUSH
44487: LD_INT 25
44489: PUSH
44490: LD_INT 2
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PUSH
44497: LD_INT 25
44499: PUSH
44500: LD_INT 16
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: EMPTY
44508: LIST
44509: LIST
44510: LIST
44511: PUSH
44512: EMPTY
44513: LIST
44514: PPUSH
44515: CALL_OW 72
44519: PUSH
44520: LD_EXP 119
44524: PUSH
44525: LD_VAR 0 2
44529: ARRAY
44530: PUSH
44531: LD_INT 1
44533: ARRAY
44534: PUSH
44535: LD_EXP 119
44539: PUSH
44540: LD_VAR 0 2
44544: ARRAY
44545: PUSH
44546: LD_INT 2
44548: ARRAY
44549: UNION
44550: DIFF
44551: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44552: LD_ADDR_VAR 0 6
44556: PUSH
44557: LD_EXP 135
44561: PUSH
44562: LD_VAR 0 2
44566: ARRAY
44567: PPUSH
44568: LD_INT 2
44570: PUSH
44571: LD_INT 34
44573: PUSH
44574: LD_INT 13
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 34
44583: PUSH
44584: LD_INT 52
44586: PUSH
44587: EMPTY
44588: LIST
44589: LIST
44590: PUSH
44591: LD_INT 34
44593: PUSH
44594: LD_EXP 101
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: PPUSH
44609: CALL_OW 72
44613: ST_TO_ADDR
// if cranes then
44614: LD_VAR 0 6
44618: IFFALSE 44754
// begin for j in cranes do
44620: LD_ADDR_VAR 0 3
44624: PUSH
44625: LD_VAR 0 6
44629: PUSH
44630: FOR_IN
44631: IFFALSE 44752
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44633: LD_VAR 0 3
44637: PPUSH
44638: CALL_OW 256
44642: PUSH
44643: LD_INT 1000
44645: EQUAL
44646: PUSH
44647: LD_VAR 0 3
44651: PPUSH
44652: CALL_OW 314
44656: NOT
44657: AND
44658: IFFALSE 44692
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44660: LD_VAR 0 3
44664: PPUSH
44665: LD_EXP 117
44669: PUSH
44670: LD_VAR 0 2
44674: ARRAY
44675: PPUSH
44676: LD_VAR 0 3
44680: PPUSH
44681: CALL_OW 74
44685: PPUSH
44686: CALL_OW 130
44690: GO 44750
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44692: LD_VAR 0 3
44696: PPUSH
44697: CALL_OW 256
44701: PUSH
44702: LD_INT 500
44704: LESS
44705: PUSH
44706: LD_VAR 0 3
44710: PPUSH
44711: LD_EXP 140
44715: PUSH
44716: LD_VAR 0 2
44720: ARRAY
44721: PPUSH
44722: CALL_OW 308
44726: NOT
44727: AND
44728: IFFALSE 44750
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44730: LD_VAR 0 3
44734: PPUSH
44735: LD_EXP 140
44739: PUSH
44740: LD_VAR 0 2
44744: ARRAY
44745: PPUSH
44746: CALL_OW 113
// end ;
44750: GO 44630
44752: POP
44753: POP
// end ; if tmp > 3 then
44754: LD_VAR 0 5
44758: PUSH
44759: LD_INT 3
44761: GREATER
44762: IFFALSE 44782
// tmp := ShrinkArray ( tmp , 4 ) ;
44764: LD_ADDR_VAR 0 5
44768: PUSH
44769: LD_VAR 0 5
44773: PPUSH
44774: LD_INT 4
44776: PPUSH
44777: CALL 102525 0 2
44781: ST_TO_ADDR
// if not tmp then
44782: LD_VAR 0 5
44786: NOT
44787: IFFALSE 44791
// continue ;
44789: GO 44221
// for j in tmp do
44791: LD_ADDR_VAR 0 3
44795: PUSH
44796: LD_VAR 0 5
44800: PUSH
44801: FOR_IN
44802: IFFALSE 45061
// begin if IsInUnit ( j ) then
44804: LD_VAR 0 3
44808: PPUSH
44809: CALL_OW 310
44813: IFFALSE 44824
// ComExitBuilding ( j ) ;
44815: LD_VAR 0 3
44819: PPUSH
44820: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44824: LD_VAR 0 3
44828: PUSH
44829: LD_EXP 118
44833: PUSH
44834: LD_VAR 0 2
44838: ARRAY
44839: IN
44840: NOT
44841: IFFALSE 44899
// begin SetTag ( j , 101 ) ;
44843: LD_VAR 0 3
44847: PPUSH
44848: LD_INT 101
44850: PPUSH
44851: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44855: LD_ADDR_EXP 118
44859: PUSH
44860: LD_EXP 118
44864: PPUSH
44865: LD_VAR 0 2
44869: PUSH
44870: LD_EXP 118
44874: PUSH
44875: LD_VAR 0 2
44879: ARRAY
44880: PUSH
44881: LD_INT 1
44883: PLUS
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PPUSH
44889: LD_VAR 0 3
44893: PPUSH
44894: CALL 70458 0 3
44898: ST_TO_ADDR
// end ; wait ( 1 ) ;
44899: LD_INT 1
44901: PPUSH
44902: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44906: LD_ADDR_VAR 0 7
44910: PUSH
44911: LD_EXP 117
44915: PUSH
44916: LD_VAR 0 2
44920: ARRAY
44921: ST_TO_ADDR
// if mc_scan [ i ] then
44922: LD_EXP 139
44926: PUSH
44927: LD_VAR 0 2
44931: ARRAY
44932: IFFALSE 44994
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44934: LD_ADDR_VAR 0 7
44938: PUSH
44939: LD_EXP 117
44943: PUSH
44944: LD_VAR 0 2
44948: ARRAY
44949: PPUSH
44950: LD_INT 3
44952: PUSH
44953: LD_INT 30
44955: PUSH
44956: LD_INT 32
44958: PUSH
44959: EMPTY
44960: LIST
44961: LIST
44962: PUSH
44963: LD_INT 30
44965: PUSH
44966: LD_INT 33
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_INT 30
44975: PUSH
44976: LD_INT 31
44978: PUSH
44979: EMPTY
44980: LIST
44981: LIST
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: PPUSH
44989: CALL_OW 72
44993: ST_TO_ADDR
// if not to_repair_tmp then
44994: LD_VAR 0 7
44998: NOT
44999: IFFALSE 45003
// continue ;
45001: GO 44801
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45003: LD_ADDR_VAR 0 8
45007: PUSH
45008: LD_VAR 0 7
45012: PPUSH
45013: LD_VAR 0 3
45017: PPUSH
45018: CALL_OW 74
45022: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45023: LD_VAR 0 8
45027: PPUSH
45028: LD_INT 16
45030: PPUSH
45031: CALL 73057 0 2
45035: PUSH
45036: LD_INT 4
45038: ARRAY
45039: PUSH
45040: LD_INT 10
45042: LESS
45043: IFFALSE 45059
// ComRepairBuilding ( j , to_repair ) ;
45045: LD_VAR 0 3
45049: PPUSH
45050: LD_VAR 0 8
45054: PPUSH
45055: CALL_OW 130
// end ;
45059: GO 44801
45061: POP
45062: POP
// end ;
45063: GO 44221
45065: POP
45066: POP
// end ;
45067: LD_VAR 0 1
45071: RET
// export function MC_Heal ; var i , j , tmp ; begin
45072: LD_INT 0
45074: PPUSH
45075: PPUSH
45076: PPUSH
45077: PPUSH
// if not mc_bases then
45078: LD_EXP 116
45082: NOT
45083: IFFALSE 45087
// exit ;
45085: GO 45489
// for i = 1 to mc_bases do
45087: LD_ADDR_VAR 0 2
45091: PUSH
45092: DOUBLE
45093: LD_INT 1
45095: DEC
45096: ST_TO_ADDR
45097: LD_EXP 116
45101: PUSH
45102: FOR_TO
45103: IFFALSE 45487
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45105: LD_EXP 119
45109: PUSH
45110: LD_VAR 0 2
45114: ARRAY
45115: PUSH
45116: LD_INT 1
45118: ARRAY
45119: NOT
45120: PUSH
45121: LD_EXP 119
45125: PUSH
45126: LD_VAR 0 2
45130: ARRAY
45131: PUSH
45132: LD_INT 2
45134: ARRAY
45135: NOT
45136: AND
45137: IFFALSE 45175
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45139: LD_ADDR_EXP 120
45143: PUSH
45144: LD_EXP 120
45148: PPUSH
45149: LD_VAR 0 2
45153: PPUSH
45154: EMPTY
45155: PPUSH
45156: CALL_OW 1
45160: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45161: LD_VAR 0 2
45165: PPUSH
45166: LD_INT 102
45168: PPUSH
45169: CALL 39310 0 2
// continue ;
45173: GO 45102
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45175: LD_ADDR_VAR 0 4
45179: PUSH
45180: LD_EXP 116
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: PPUSH
45191: LD_INT 25
45193: PUSH
45194: LD_INT 4
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PPUSH
45201: CALL_OW 72
45205: ST_TO_ADDR
// if not tmp then
45206: LD_VAR 0 4
45210: NOT
45211: IFFALSE 45215
// continue ;
45213: GO 45102
// if mc_taming [ i ] then
45215: LD_EXP 147
45219: PUSH
45220: LD_VAR 0 2
45224: ARRAY
45225: IFFALSE 45249
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45227: LD_ADDR_EXP 147
45231: PUSH
45232: LD_EXP 147
45236: PPUSH
45237: LD_VAR 0 2
45241: PPUSH
45242: EMPTY
45243: PPUSH
45244: CALL_OW 1
45248: ST_TO_ADDR
// for j in tmp do
45249: LD_ADDR_VAR 0 3
45253: PUSH
45254: LD_VAR 0 4
45258: PUSH
45259: FOR_IN
45260: IFFALSE 45483
// begin if IsInUnit ( j ) then
45262: LD_VAR 0 3
45266: PPUSH
45267: CALL_OW 310
45271: IFFALSE 45282
// ComExitBuilding ( j ) ;
45273: LD_VAR 0 3
45277: PPUSH
45278: CALL_OW 122
// if not j in mc_healers [ i ] then
45282: LD_VAR 0 3
45286: PUSH
45287: LD_EXP 120
45291: PUSH
45292: LD_VAR 0 2
45296: ARRAY
45297: IN
45298: NOT
45299: IFFALSE 45345
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45301: LD_ADDR_EXP 120
45305: PUSH
45306: LD_EXP 120
45310: PPUSH
45311: LD_VAR 0 2
45315: PUSH
45316: LD_EXP 120
45320: PUSH
45321: LD_VAR 0 2
45325: ARRAY
45326: PUSH
45327: LD_INT 1
45329: PLUS
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: PPUSH
45335: LD_VAR 0 3
45339: PPUSH
45340: CALL 70458 0 3
45344: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45345: LD_VAR 0 3
45349: PPUSH
45350: CALL_OW 110
45354: PUSH
45355: LD_INT 102
45357: NONEQUAL
45358: IFFALSE 45372
// SetTag ( j , 102 ) ;
45360: LD_VAR 0 3
45364: PPUSH
45365: LD_INT 102
45367: PPUSH
45368: CALL_OW 109
// Wait ( 3 ) ;
45372: LD_INT 3
45374: PPUSH
45375: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45379: LD_EXP 119
45383: PUSH
45384: LD_VAR 0 2
45388: ARRAY
45389: PUSH
45390: LD_INT 1
45392: ARRAY
45393: IFFALSE 45425
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45395: LD_VAR 0 3
45399: PPUSH
45400: LD_EXP 119
45404: PUSH
45405: LD_VAR 0 2
45409: ARRAY
45410: PUSH
45411: LD_INT 1
45413: ARRAY
45414: PUSH
45415: LD_INT 1
45417: ARRAY
45418: PPUSH
45419: CALL_OW 128
45423: GO 45481
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45425: LD_VAR 0 3
45429: PPUSH
45430: CALL_OW 314
45434: NOT
45435: PUSH
45436: LD_EXP 119
45440: PUSH
45441: LD_VAR 0 2
45445: ARRAY
45446: PUSH
45447: LD_INT 2
45449: ARRAY
45450: AND
45451: IFFALSE 45481
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45453: LD_VAR 0 3
45457: PPUSH
45458: LD_EXP 119
45462: PUSH
45463: LD_VAR 0 2
45467: ARRAY
45468: PUSH
45469: LD_INT 2
45471: ARRAY
45472: PUSH
45473: LD_INT 1
45475: ARRAY
45476: PPUSH
45477: CALL_OW 128
// end ;
45481: GO 45259
45483: POP
45484: POP
// end ;
45485: GO 45102
45487: POP
45488: POP
// end ;
45489: LD_VAR 0 1
45493: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45494: LD_INT 0
45496: PPUSH
45497: PPUSH
45498: PPUSH
45499: PPUSH
45500: PPUSH
// if not mc_bases then
45501: LD_EXP 116
45505: NOT
45506: IFFALSE 45510
// exit ;
45508: GO 46681
// for i = 1 to mc_bases do
45510: LD_ADDR_VAR 0 2
45514: PUSH
45515: DOUBLE
45516: LD_INT 1
45518: DEC
45519: ST_TO_ADDR
45520: LD_EXP 116
45524: PUSH
45525: FOR_TO
45526: IFFALSE 46679
// begin if mc_scan [ i ] then
45528: LD_EXP 139
45532: PUSH
45533: LD_VAR 0 2
45537: ARRAY
45538: IFFALSE 45542
// continue ;
45540: GO 45525
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45542: LD_EXP 121
45546: PUSH
45547: LD_VAR 0 2
45551: ARRAY
45552: NOT
45553: PUSH
45554: LD_EXP 123
45558: PUSH
45559: LD_VAR 0 2
45563: ARRAY
45564: NOT
45565: AND
45566: PUSH
45567: LD_EXP 122
45571: PUSH
45572: LD_VAR 0 2
45576: ARRAY
45577: AND
45578: IFFALSE 45616
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45580: LD_ADDR_EXP 122
45584: PUSH
45585: LD_EXP 122
45589: PPUSH
45590: LD_VAR 0 2
45594: PPUSH
45595: EMPTY
45596: PPUSH
45597: CALL_OW 1
45601: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45602: LD_VAR 0 2
45606: PPUSH
45607: LD_INT 103
45609: PPUSH
45610: CALL 39310 0 2
// continue ;
45614: GO 45525
// end ; if mc_construct_list [ i ] then
45616: LD_EXP 123
45620: PUSH
45621: LD_VAR 0 2
45625: ARRAY
45626: IFFALSE 45846
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45628: LD_ADDR_VAR 0 4
45632: PUSH
45633: LD_EXP 116
45637: PUSH
45638: LD_VAR 0 2
45642: ARRAY
45643: PPUSH
45644: LD_INT 25
45646: PUSH
45647: LD_INT 2
45649: PUSH
45650: EMPTY
45651: LIST
45652: LIST
45653: PPUSH
45654: CALL_OW 72
45658: PUSH
45659: LD_EXP 118
45663: PUSH
45664: LD_VAR 0 2
45668: ARRAY
45669: DIFF
45670: ST_TO_ADDR
// if not tmp then
45671: LD_VAR 0 4
45675: NOT
45676: IFFALSE 45680
// continue ;
45678: GO 45525
// for j in tmp do
45680: LD_ADDR_VAR 0 3
45684: PUSH
45685: LD_VAR 0 4
45689: PUSH
45690: FOR_IN
45691: IFFALSE 45842
// begin if not mc_builders [ i ] then
45693: LD_EXP 122
45697: PUSH
45698: LD_VAR 0 2
45702: ARRAY
45703: NOT
45704: IFFALSE 45762
// begin SetTag ( j , 103 ) ;
45706: LD_VAR 0 3
45710: PPUSH
45711: LD_INT 103
45713: PPUSH
45714: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45718: LD_ADDR_EXP 122
45722: PUSH
45723: LD_EXP 122
45727: PPUSH
45728: LD_VAR 0 2
45732: PUSH
45733: LD_EXP 122
45737: PUSH
45738: LD_VAR 0 2
45742: ARRAY
45743: PUSH
45744: LD_INT 1
45746: PLUS
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PPUSH
45752: LD_VAR 0 3
45756: PPUSH
45757: CALL 70458 0 3
45761: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45762: LD_VAR 0 3
45766: PPUSH
45767: CALL_OW 310
45771: IFFALSE 45782
// ComExitBuilding ( j ) ;
45773: LD_VAR 0 3
45777: PPUSH
45778: CALL_OW 122
// wait ( 3 ) ;
45782: LD_INT 3
45784: PPUSH
45785: CALL_OW 67
// if not mc_construct_list [ i ] then
45789: LD_EXP 123
45793: PUSH
45794: LD_VAR 0 2
45798: ARRAY
45799: NOT
45800: IFFALSE 45804
// break ;
45802: GO 45842
// if not HasTask ( j ) then
45804: LD_VAR 0 3
45808: PPUSH
45809: CALL_OW 314
45813: NOT
45814: IFFALSE 45840
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45816: LD_VAR 0 3
45820: PPUSH
45821: LD_EXP 123
45825: PUSH
45826: LD_VAR 0 2
45830: ARRAY
45831: PUSH
45832: LD_INT 1
45834: ARRAY
45835: PPUSH
45836: CALL 73321 0 2
// end ;
45840: GO 45690
45842: POP
45843: POP
// end else
45844: GO 46677
// if mc_build_list [ i ] then
45846: LD_EXP 121
45850: PUSH
45851: LD_VAR 0 2
45855: ARRAY
45856: IFFALSE 46677
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45858: LD_ADDR_VAR 0 5
45862: PUSH
45863: LD_EXP 116
45867: PUSH
45868: LD_VAR 0 2
45872: ARRAY
45873: PPUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 30
45879: PUSH
45880: LD_INT 0
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 30
45889: PUSH
45890: LD_INT 1
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: LIST
45901: PPUSH
45902: CALL_OW 72
45906: ST_TO_ADDR
// if depot then
45907: LD_VAR 0 5
45911: IFFALSE 45929
// depot := depot [ 1 ] else
45913: LD_ADDR_VAR 0 5
45917: PUSH
45918: LD_VAR 0 5
45922: PUSH
45923: LD_INT 1
45925: ARRAY
45926: ST_TO_ADDR
45927: GO 45937
// depot := 0 ;
45929: LD_ADDR_VAR 0 5
45933: PUSH
45934: LD_INT 0
45936: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45937: LD_EXP 121
45941: PUSH
45942: LD_VAR 0 2
45946: ARRAY
45947: PUSH
45948: LD_INT 1
45950: ARRAY
45951: PUSH
45952: LD_INT 1
45954: ARRAY
45955: PPUSH
45956: CALL 73145 0 1
45960: PUSH
45961: LD_EXP 116
45965: PUSH
45966: LD_VAR 0 2
45970: ARRAY
45971: PPUSH
45972: LD_INT 2
45974: PUSH
45975: LD_INT 30
45977: PUSH
45978: LD_INT 2
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 30
45987: PUSH
45988: LD_INT 3
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: LIST
45999: PPUSH
46000: CALL_OW 72
46004: NOT
46005: AND
46006: IFFALSE 46111
// begin for j = 1 to mc_build_list [ i ] do
46008: LD_ADDR_VAR 0 3
46012: PUSH
46013: DOUBLE
46014: LD_INT 1
46016: DEC
46017: ST_TO_ADDR
46018: LD_EXP 121
46022: PUSH
46023: LD_VAR 0 2
46027: ARRAY
46028: PUSH
46029: FOR_TO
46030: IFFALSE 46109
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46032: LD_EXP 121
46036: PUSH
46037: LD_VAR 0 2
46041: ARRAY
46042: PUSH
46043: LD_VAR 0 3
46047: ARRAY
46048: PUSH
46049: LD_INT 1
46051: ARRAY
46052: PUSH
46053: LD_INT 2
46055: EQUAL
46056: IFFALSE 46107
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46058: LD_ADDR_EXP 121
46062: PUSH
46063: LD_EXP 121
46067: PPUSH
46068: LD_VAR 0 2
46072: PPUSH
46073: LD_EXP 121
46077: PUSH
46078: LD_VAR 0 2
46082: ARRAY
46083: PPUSH
46084: LD_VAR 0 3
46088: PPUSH
46089: LD_INT 1
46091: PPUSH
46092: LD_INT 0
46094: PPUSH
46095: CALL 69876 0 4
46099: PPUSH
46100: CALL_OW 1
46104: ST_TO_ADDR
// break ;
46105: GO 46109
// end ;
46107: GO 46029
46109: POP
46110: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46111: LD_EXP 121
46115: PUSH
46116: LD_VAR 0 2
46120: ARRAY
46121: PUSH
46122: LD_INT 1
46124: ARRAY
46125: PUSH
46126: LD_INT 1
46128: ARRAY
46129: PUSH
46130: LD_INT 0
46132: EQUAL
46133: PUSH
46134: LD_VAR 0 5
46138: PUSH
46139: LD_VAR 0 5
46143: PPUSH
46144: LD_EXP 121
46148: PUSH
46149: LD_VAR 0 2
46153: ARRAY
46154: PUSH
46155: LD_INT 1
46157: ARRAY
46158: PUSH
46159: LD_INT 1
46161: ARRAY
46162: PPUSH
46163: LD_EXP 121
46167: PUSH
46168: LD_VAR 0 2
46172: ARRAY
46173: PUSH
46174: LD_INT 1
46176: ARRAY
46177: PUSH
46178: LD_INT 2
46180: ARRAY
46181: PPUSH
46182: LD_EXP 121
46186: PUSH
46187: LD_VAR 0 2
46191: ARRAY
46192: PUSH
46193: LD_INT 1
46195: ARRAY
46196: PUSH
46197: LD_INT 3
46199: ARRAY
46200: PPUSH
46201: LD_EXP 121
46205: PUSH
46206: LD_VAR 0 2
46210: ARRAY
46211: PUSH
46212: LD_INT 1
46214: ARRAY
46215: PUSH
46216: LD_INT 4
46218: ARRAY
46219: PPUSH
46220: CALL 78562 0 5
46224: AND
46225: OR
46226: IFFALSE 46507
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46228: LD_ADDR_VAR 0 4
46232: PUSH
46233: LD_EXP 116
46237: PUSH
46238: LD_VAR 0 2
46242: ARRAY
46243: PPUSH
46244: LD_INT 25
46246: PUSH
46247: LD_INT 2
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PPUSH
46254: CALL_OW 72
46258: PUSH
46259: LD_EXP 118
46263: PUSH
46264: LD_VAR 0 2
46268: ARRAY
46269: DIFF
46270: ST_TO_ADDR
// if not tmp then
46271: LD_VAR 0 4
46275: NOT
46276: IFFALSE 46280
// continue ;
46278: GO 45525
// for j in tmp do
46280: LD_ADDR_VAR 0 3
46284: PUSH
46285: LD_VAR 0 4
46289: PUSH
46290: FOR_IN
46291: IFFALSE 46503
// begin if not mc_builders [ i ] then
46293: LD_EXP 122
46297: PUSH
46298: LD_VAR 0 2
46302: ARRAY
46303: NOT
46304: IFFALSE 46362
// begin SetTag ( j , 103 ) ;
46306: LD_VAR 0 3
46310: PPUSH
46311: LD_INT 103
46313: PPUSH
46314: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46318: LD_ADDR_EXP 122
46322: PUSH
46323: LD_EXP 122
46327: PPUSH
46328: LD_VAR 0 2
46332: PUSH
46333: LD_EXP 122
46337: PUSH
46338: LD_VAR 0 2
46342: ARRAY
46343: PUSH
46344: LD_INT 1
46346: PLUS
46347: PUSH
46348: EMPTY
46349: LIST
46350: LIST
46351: PPUSH
46352: LD_VAR 0 3
46356: PPUSH
46357: CALL 70458 0 3
46361: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46362: LD_VAR 0 3
46366: PPUSH
46367: CALL_OW 310
46371: IFFALSE 46382
// ComExitBuilding ( j ) ;
46373: LD_VAR 0 3
46377: PPUSH
46378: CALL_OW 122
// wait ( 3 ) ;
46382: LD_INT 3
46384: PPUSH
46385: CALL_OW 67
// if not mc_build_list [ i ] then
46389: LD_EXP 121
46393: PUSH
46394: LD_VAR 0 2
46398: ARRAY
46399: NOT
46400: IFFALSE 46404
// break ;
46402: GO 46503
// if not HasTask ( j ) then
46404: LD_VAR 0 3
46408: PPUSH
46409: CALL_OW 314
46413: NOT
46414: IFFALSE 46501
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46416: LD_VAR 0 3
46420: PPUSH
46421: LD_EXP 121
46425: PUSH
46426: LD_VAR 0 2
46430: ARRAY
46431: PUSH
46432: LD_INT 1
46434: ARRAY
46435: PUSH
46436: LD_INT 1
46438: ARRAY
46439: PPUSH
46440: LD_EXP 121
46444: PUSH
46445: LD_VAR 0 2
46449: ARRAY
46450: PUSH
46451: LD_INT 1
46453: ARRAY
46454: PUSH
46455: LD_INT 2
46457: ARRAY
46458: PPUSH
46459: LD_EXP 121
46463: PUSH
46464: LD_VAR 0 2
46468: ARRAY
46469: PUSH
46470: LD_INT 1
46472: ARRAY
46473: PUSH
46474: LD_INT 3
46476: ARRAY
46477: PPUSH
46478: LD_EXP 121
46482: PUSH
46483: LD_VAR 0 2
46487: ARRAY
46488: PUSH
46489: LD_INT 1
46491: ARRAY
46492: PUSH
46493: LD_INT 4
46495: ARRAY
46496: PPUSH
46497: CALL_OW 145
// end ;
46501: GO 46290
46503: POP
46504: POP
// end else
46505: GO 46677
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46507: LD_EXP 116
46511: PUSH
46512: LD_VAR 0 2
46516: ARRAY
46517: PPUSH
46518: LD_EXP 121
46522: PUSH
46523: LD_VAR 0 2
46527: ARRAY
46528: PUSH
46529: LD_INT 1
46531: ARRAY
46532: PUSH
46533: LD_INT 1
46535: ARRAY
46536: PPUSH
46537: LD_EXP 121
46541: PUSH
46542: LD_VAR 0 2
46546: ARRAY
46547: PUSH
46548: LD_INT 1
46550: ARRAY
46551: PUSH
46552: LD_INT 2
46554: ARRAY
46555: PPUSH
46556: LD_EXP 121
46560: PUSH
46561: LD_VAR 0 2
46565: ARRAY
46566: PUSH
46567: LD_INT 1
46569: ARRAY
46570: PUSH
46571: LD_INT 3
46573: ARRAY
46574: PPUSH
46575: LD_EXP 121
46579: PUSH
46580: LD_VAR 0 2
46584: ARRAY
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: PUSH
46590: LD_INT 4
46592: ARRAY
46593: PPUSH
46594: LD_EXP 116
46598: PUSH
46599: LD_VAR 0 2
46603: ARRAY
46604: PPUSH
46605: LD_INT 21
46607: PUSH
46608: LD_INT 3
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PPUSH
46615: CALL_OW 72
46619: PPUSH
46620: EMPTY
46621: PPUSH
46622: CALL 77312 0 7
46626: NOT
46627: IFFALSE 46677
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46629: LD_ADDR_EXP 121
46633: PUSH
46634: LD_EXP 121
46638: PPUSH
46639: LD_VAR 0 2
46643: PPUSH
46644: LD_EXP 121
46648: PUSH
46649: LD_VAR 0 2
46653: ARRAY
46654: PPUSH
46655: LD_INT 1
46657: PPUSH
46658: LD_INT 1
46660: NEG
46661: PPUSH
46662: LD_INT 0
46664: PPUSH
46665: CALL 69876 0 4
46669: PPUSH
46670: CALL_OW 1
46674: ST_TO_ADDR
// continue ;
46675: GO 45525
// end ; end ; end ;
46677: GO 45525
46679: POP
46680: POP
// end ;
46681: LD_VAR 0 1
46685: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46686: LD_INT 0
46688: PPUSH
46689: PPUSH
46690: PPUSH
46691: PPUSH
46692: PPUSH
46693: PPUSH
// if not mc_bases then
46694: LD_EXP 116
46698: NOT
46699: IFFALSE 46703
// exit ;
46701: GO 47130
// for i = 1 to mc_bases do
46703: LD_ADDR_VAR 0 2
46707: PUSH
46708: DOUBLE
46709: LD_INT 1
46711: DEC
46712: ST_TO_ADDR
46713: LD_EXP 116
46717: PUSH
46718: FOR_TO
46719: IFFALSE 47128
// begin tmp := mc_build_upgrade [ i ] ;
46721: LD_ADDR_VAR 0 4
46725: PUSH
46726: LD_EXP 148
46730: PUSH
46731: LD_VAR 0 2
46735: ARRAY
46736: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46737: LD_ADDR_VAR 0 6
46741: PUSH
46742: LD_EXP 149
46746: PUSH
46747: LD_VAR 0 2
46751: ARRAY
46752: PPUSH
46753: LD_INT 2
46755: PUSH
46756: LD_INT 30
46758: PUSH
46759: LD_INT 6
46761: PUSH
46762: EMPTY
46763: LIST
46764: LIST
46765: PUSH
46766: LD_INT 30
46768: PUSH
46769: LD_INT 7
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: PPUSH
46781: CALL_OW 72
46785: ST_TO_ADDR
// if not tmp and not lab then
46786: LD_VAR 0 4
46790: NOT
46791: PUSH
46792: LD_VAR 0 6
46796: NOT
46797: AND
46798: IFFALSE 46802
// continue ;
46800: GO 46718
// if tmp then
46802: LD_VAR 0 4
46806: IFFALSE 46926
// for j in tmp do
46808: LD_ADDR_VAR 0 3
46812: PUSH
46813: LD_VAR 0 4
46817: PUSH
46818: FOR_IN
46819: IFFALSE 46924
// begin if UpgradeCost ( j ) then
46821: LD_VAR 0 3
46825: PPUSH
46826: CALL 76972 0 1
46830: IFFALSE 46922
// begin ComUpgrade ( j ) ;
46832: LD_VAR 0 3
46836: PPUSH
46837: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46841: LD_ADDR_EXP 148
46845: PUSH
46846: LD_EXP 148
46850: PPUSH
46851: LD_VAR 0 2
46855: PPUSH
46856: LD_EXP 148
46860: PUSH
46861: LD_VAR 0 2
46865: ARRAY
46866: PUSH
46867: LD_VAR 0 3
46871: DIFF
46872: PPUSH
46873: CALL_OW 1
46877: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46878: LD_ADDR_EXP 123
46882: PUSH
46883: LD_EXP 123
46887: PPUSH
46888: LD_VAR 0 2
46892: PUSH
46893: LD_EXP 123
46897: PUSH
46898: LD_VAR 0 2
46902: ARRAY
46903: PUSH
46904: LD_INT 1
46906: PLUS
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PPUSH
46912: LD_VAR 0 3
46916: PPUSH
46917: CALL 70458 0 3
46921: ST_TO_ADDR
// end ; end ;
46922: GO 46818
46924: POP
46925: POP
// if not lab or not mc_lab_upgrade [ i ] then
46926: LD_VAR 0 6
46930: NOT
46931: PUSH
46932: LD_EXP 150
46936: PUSH
46937: LD_VAR 0 2
46941: ARRAY
46942: NOT
46943: OR
46944: IFFALSE 46948
// continue ;
46946: GO 46718
// for j in lab do
46948: LD_ADDR_VAR 0 3
46952: PUSH
46953: LD_VAR 0 6
46957: PUSH
46958: FOR_IN
46959: IFFALSE 47124
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 266
46970: PUSH
46971: LD_INT 6
46973: PUSH
46974: LD_INT 7
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: IN
46981: PUSH
46982: LD_VAR 0 3
46986: PPUSH
46987: CALL_OW 461
46991: PUSH
46992: LD_INT 1
46994: NONEQUAL
46995: AND
46996: IFFALSE 47122
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46998: LD_VAR 0 3
47002: PPUSH
47003: LD_EXP 150
47007: PUSH
47008: LD_VAR 0 2
47012: ARRAY
47013: PUSH
47014: LD_INT 1
47016: ARRAY
47017: PPUSH
47018: CALL 77177 0 2
47022: IFFALSE 47122
// begin ComCancel ( j ) ;
47024: LD_VAR 0 3
47028: PPUSH
47029: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47033: LD_VAR 0 3
47037: PPUSH
47038: LD_EXP 150
47042: PUSH
47043: LD_VAR 0 2
47047: ARRAY
47048: PUSH
47049: LD_INT 1
47051: ARRAY
47052: PPUSH
47053: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47057: LD_VAR 0 3
47061: PUSH
47062: LD_EXP 123
47066: PUSH
47067: LD_VAR 0 2
47071: ARRAY
47072: IN
47073: NOT
47074: IFFALSE 47120
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47076: LD_ADDR_EXP 123
47080: PUSH
47081: LD_EXP 123
47085: PPUSH
47086: LD_VAR 0 2
47090: PUSH
47091: LD_EXP 123
47095: PUSH
47096: LD_VAR 0 2
47100: ARRAY
47101: PUSH
47102: LD_INT 1
47104: PLUS
47105: PUSH
47106: EMPTY
47107: LIST
47108: LIST
47109: PPUSH
47110: LD_VAR 0 3
47114: PPUSH
47115: CALL 70458 0 3
47119: ST_TO_ADDR
// break ;
47120: GO 47124
// end ; end ; end ;
47122: GO 46958
47124: POP
47125: POP
// end ;
47126: GO 46718
47128: POP
47129: POP
// end ;
47130: LD_VAR 0 1
47134: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47135: LD_INT 0
47137: PPUSH
47138: PPUSH
47139: PPUSH
47140: PPUSH
47141: PPUSH
47142: PPUSH
47143: PPUSH
47144: PPUSH
47145: PPUSH
// if not mc_bases then
47146: LD_EXP 116
47150: NOT
47151: IFFALSE 47155
// exit ;
47153: GO 47560
// for i = 1 to mc_bases do
47155: LD_ADDR_VAR 0 2
47159: PUSH
47160: DOUBLE
47161: LD_INT 1
47163: DEC
47164: ST_TO_ADDR
47165: LD_EXP 116
47169: PUSH
47170: FOR_TO
47171: IFFALSE 47558
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47173: LD_EXP 124
47177: PUSH
47178: LD_VAR 0 2
47182: ARRAY
47183: NOT
47184: PUSH
47185: LD_EXP 116
47189: PUSH
47190: LD_VAR 0 2
47194: ARRAY
47195: PPUSH
47196: LD_INT 30
47198: PUSH
47199: LD_INT 3
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PPUSH
47206: CALL_OW 72
47210: NOT
47211: OR
47212: IFFALSE 47216
// continue ;
47214: GO 47170
// busy := false ;
47216: LD_ADDR_VAR 0 8
47220: PUSH
47221: LD_INT 0
47223: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47224: LD_ADDR_VAR 0 4
47228: PUSH
47229: LD_EXP 116
47233: PUSH
47234: LD_VAR 0 2
47238: ARRAY
47239: PPUSH
47240: LD_INT 30
47242: PUSH
47243: LD_INT 3
47245: PUSH
47246: EMPTY
47247: LIST
47248: LIST
47249: PPUSH
47250: CALL_OW 72
47254: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47255: LD_ADDR_VAR 0 6
47259: PUSH
47260: LD_EXP 124
47264: PUSH
47265: LD_VAR 0 2
47269: ARRAY
47270: PPUSH
47271: LD_INT 2
47273: PUSH
47274: LD_INT 30
47276: PUSH
47277: LD_INT 32
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: PUSH
47284: LD_INT 30
47286: PUSH
47287: LD_INT 33
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: LIST
47298: PPUSH
47299: CALL_OW 72
47303: ST_TO_ADDR
// if not t then
47304: LD_VAR 0 6
47308: NOT
47309: IFFALSE 47313
// continue ;
47311: GO 47170
// for j in tmp do
47313: LD_ADDR_VAR 0 3
47317: PUSH
47318: LD_VAR 0 4
47322: PUSH
47323: FOR_IN
47324: IFFALSE 47354
// if not BuildingStatus ( j ) = bs_idle then
47326: LD_VAR 0 3
47330: PPUSH
47331: CALL_OW 461
47335: PUSH
47336: LD_INT 2
47338: EQUAL
47339: NOT
47340: IFFALSE 47352
// begin busy := true ;
47342: LD_ADDR_VAR 0 8
47346: PUSH
47347: LD_INT 1
47349: ST_TO_ADDR
// break ;
47350: GO 47354
// end ;
47352: GO 47323
47354: POP
47355: POP
// if busy then
47356: LD_VAR 0 8
47360: IFFALSE 47364
// continue ;
47362: GO 47170
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47364: LD_ADDR_VAR 0 7
47368: PUSH
47369: LD_VAR 0 6
47373: PPUSH
47374: LD_INT 35
47376: PUSH
47377: LD_INT 0
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PPUSH
47384: CALL_OW 72
47388: ST_TO_ADDR
// if tw then
47389: LD_VAR 0 7
47393: IFFALSE 47470
// begin tw := tw [ 1 ] ;
47395: LD_ADDR_VAR 0 7
47399: PUSH
47400: LD_VAR 0 7
47404: PUSH
47405: LD_INT 1
47407: ARRAY
47408: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47409: LD_ADDR_VAR 0 9
47413: PUSH
47414: LD_VAR 0 7
47418: PPUSH
47419: LD_EXP 141
47423: PUSH
47424: LD_VAR 0 2
47428: ARRAY
47429: PPUSH
47430: CALL 75469 0 2
47434: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47435: LD_EXP 155
47439: PUSH
47440: LD_VAR 0 2
47444: ARRAY
47445: IFFALSE 47468
// if not weapon in mc_allowed_tower_weapons [ i ] then
47447: LD_VAR 0 9
47451: PUSH
47452: LD_EXP 155
47456: PUSH
47457: LD_VAR 0 2
47461: ARRAY
47462: IN
47463: NOT
47464: IFFALSE 47468
// continue ;
47466: GO 47170
// end else
47468: GO 47533
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47470: LD_ADDR_VAR 0 5
47474: PUSH
47475: LD_EXP 124
47479: PUSH
47480: LD_VAR 0 2
47484: ARRAY
47485: PPUSH
47486: LD_VAR 0 4
47490: PPUSH
47491: CALL 101758 0 2
47495: ST_TO_ADDR
// if not tmp2 then
47496: LD_VAR 0 5
47500: NOT
47501: IFFALSE 47505
// continue ;
47503: GO 47170
// tw := tmp2 [ 1 ] ;
47505: LD_ADDR_VAR 0 7
47509: PUSH
47510: LD_VAR 0 5
47514: PUSH
47515: LD_INT 1
47517: ARRAY
47518: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47519: LD_ADDR_VAR 0 9
47523: PUSH
47524: LD_VAR 0 5
47528: PUSH
47529: LD_INT 2
47531: ARRAY
47532: ST_TO_ADDR
// end ; if not weapon then
47533: LD_VAR 0 9
47537: NOT
47538: IFFALSE 47542
// continue ;
47540: GO 47170
// ComPlaceWeapon ( tw , weapon ) ;
47542: LD_VAR 0 7
47546: PPUSH
47547: LD_VAR 0 9
47551: PPUSH
47552: CALL_OW 148
// end ;
47556: GO 47170
47558: POP
47559: POP
// end ;
47560: LD_VAR 0 1
47564: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47565: LD_INT 0
47567: PPUSH
47568: PPUSH
47569: PPUSH
47570: PPUSH
47571: PPUSH
47572: PPUSH
47573: PPUSH
// if not mc_bases then
47574: LD_EXP 116
47578: NOT
47579: IFFALSE 47583
// exit ;
47581: GO 48351
// for i = 1 to mc_bases do
47583: LD_ADDR_VAR 0 2
47587: PUSH
47588: DOUBLE
47589: LD_INT 1
47591: DEC
47592: ST_TO_ADDR
47593: LD_EXP 116
47597: PUSH
47598: FOR_TO
47599: IFFALSE 48349
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47601: LD_EXP 129
47605: PUSH
47606: LD_VAR 0 2
47610: ARRAY
47611: NOT
47612: PUSH
47613: LD_EXP 129
47617: PUSH
47618: LD_VAR 0 2
47622: ARRAY
47623: PUSH
47624: LD_EXP 130
47628: PUSH
47629: LD_VAR 0 2
47633: ARRAY
47634: EQUAL
47635: OR
47636: PUSH
47637: LD_EXP 139
47641: PUSH
47642: LD_VAR 0 2
47646: ARRAY
47647: OR
47648: IFFALSE 47652
// continue ;
47650: GO 47598
// if mc_miners [ i ] then
47652: LD_EXP 130
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: IFFALSE 48036
// begin for j = mc_miners [ i ] downto 1 do
47664: LD_ADDR_VAR 0 3
47668: PUSH
47669: DOUBLE
47670: LD_EXP 130
47674: PUSH
47675: LD_VAR 0 2
47679: ARRAY
47680: INC
47681: ST_TO_ADDR
47682: LD_INT 1
47684: PUSH
47685: FOR_DOWNTO
47686: IFFALSE 48034
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47688: LD_EXP 130
47692: PUSH
47693: LD_VAR 0 2
47697: ARRAY
47698: PUSH
47699: LD_VAR 0 3
47703: ARRAY
47704: PPUSH
47705: CALL_OW 301
47709: PUSH
47710: LD_EXP 130
47714: PUSH
47715: LD_VAR 0 2
47719: ARRAY
47720: PUSH
47721: LD_VAR 0 3
47725: ARRAY
47726: PPUSH
47727: CALL_OW 257
47731: PUSH
47732: LD_INT 1
47734: NONEQUAL
47735: OR
47736: IFFALSE 47799
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47738: LD_ADDR_VAR 0 5
47742: PUSH
47743: LD_EXP 130
47747: PUSH
47748: LD_VAR 0 2
47752: ARRAY
47753: PUSH
47754: LD_EXP 130
47758: PUSH
47759: LD_VAR 0 2
47763: ARRAY
47764: PUSH
47765: LD_VAR 0 3
47769: ARRAY
47770: DIFF
47771: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47772: LD_ADDR_EXP 130
47776: PUSH
47777: LD_EXP 130
47781: PPUSH
47782: LD_VAR 0 2
47786: PPUSH
47787: LD_VAR 0 5
47791: PPUSH
47792: CALL_OW 1
47796: ST_TO_ADDR
// continue ;
47797: GO 47685
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47799: LD_EXP 130
47803: PUSH
47804: LD_VAR 0 2
47808: ARRAY
47809: PUSH
47810: LD_VAR 0 3
47814: ARRAY
47815: PPUSH
47816: CALL_OW 257
47820: PUSH
47821: LD_INT 1
47823: EQUAL
47824: PUSH
47825: LD_EXP 130
47829: PUSH
47830: LD_VAR 0 2
47834: ARRAY
47835: PUSH
47836: LD_VAR 0 3
47840: ARRAY
47841: PPUSH
47842: CALL_OW 459
47846: NOT
47847: AND
47848: PUSH
47849: LD_EXP 130
47853: PUSH
47854: LD_VAR 0 2
47858: ARRAY
47859: PUSH
47860: LD_VAR 0 3
47864: ARRAY
47865: PPUSH
47866: CALL_OW 314
47870: NOT
47871: AND
47872: IFFALSE 48032
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47874: LD_EXP 130
47878: PUSH
47879: LD_VAR 0 2
47883: ARRAY
47884: PUSH
47885: LD_VAR 0 3
47889: ARRAY
47890: PPUSH
47891: CALL_OW 310
47895: IFFALSE 47918
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47897: LD_EXP 130
47901: PUSH
47902: LD_VAR 0 2
47906: ARRAY
47907: PUSH
47908: LD_VAR 0 3
47912: ARRAY
47913: PPUSH
47914: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47918: LD_EXP 130
47922: PUSH
47923: LD_VAR 0 2
47927: ARRAY
47928: PUSH
47929: LD_VAR 0 3
47933: ARRAY
47934: PPUSH
47935: CALL_OW 314
47939: NOT
47940: IFFALSE 48032
// begin r := rand ( 1 , mc_mines [ i ] ) ;
47942: LD_ADDR_VAR 0 7
47946: PUSH
47947: LD_INT 1
47949: PPUSH
47950: LD_EXP 129
47954: PUSH
47955: LD_VAR 0 2
47959: ARRAY
47960: PPUSH
47961: CALL_OW 12
47965: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
47966: LD_EXP 130
47970: PUSH
47971: LD_VAR 0 2
47975: ARRAY
47976: PUSH
47977: LD_VAR 0 3
47981: ARRAY
47982: PPUSH
47983: LD_EXP 129
47987: PUSH
47988: LD_VAR 0 2
47992: ARRAY
47993: PUSH
47994: LD_VAR 0 7
47998: ARRAY
47999: PUSH
48000: LD_INT 1
48002: ARRAY
48003: PPUSH
48004: LD_EXP 129
48008: PUSH
48009: LD_VAR 0 2
48013: ARRAY
48014: PUSH
48015: LD_VAR 0 7
48019: ARRAY
48020: PUSH
48021: LD_INT 2
48023: ARRAY
48024: PPUSH
48025: LD_INT 0
48027: PPUSH
48028: CALL_OW 193
// end ; end ; end ;
48032: GO 47685
48034: POP
48035: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48036: LD_ADDR_VAR 0 5
48040: PUSH
48041: LD_EXP 116
48045: PUSH
48046: LD_VAR 0 2
48050: ARRAY
48051: PPUSH
48052: LD_INT 2
48054: PUSH
48055: LD_INT 30
48057: PUSH
48058: LD_INT 4
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: PUSH
48065: LD_INT 30
48067: PUSH
48068: LD_INT 5
48070: PUSH
48071: EMPTY
48072: LIST
48073: LIST
48074: PUSH
48075: LD_INT 30
48077: PUSH
48078: LD_INT 32
48080: PUSH
48081: EMPTY
48082: LIST
48083: LIST
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: LIST
48089: LIST
48090: PPUSH
48091: CALL_OW 72
48095: ST_TO_ADDR
// if not tmp then
48096: LD_VAR 0 5
48100: NOT
48101: IFFALSE 48105
// continue ;
48103: GO 47598
// list := [ ] ;
48105: LD_ADDR_VAR 0 6
48109: PUSH
48110: EMPTY
48111: ST_TO_ADDR
// for j in tmp do
48112: LD_ADDR_VAR 0 3
48116: PUSH
48117: LD_VAR 0 5
48121: PUSH
48122: FOR_IN
48123: IFFALSE 48192
// begin for k in UnitsInside ( j ) do
48125: LD_ADDR_VAR 0 4
48129: PUSH
48130: LD_VAR 0 3
48134: PPUSH
48135: CALL_OW 313
48139: PUSH
48140: FOR_IN
48141: IFFALSE 48188
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48143: LD_VAR 0 4
48147: PPUSH
48148: CALL_OW 257
48152: PUSH
48153: LD_INT 1
48155: EQUAL
48156: PUSH
48157: LD_VAR 0 4
48161: PPUSH
48162: CALL_OW 459
48166: NOT
48167: AND
48168: IFFALSE 48186
// list := list ^ k ;
48170: LD_ADDR_VAR 0 6
48174: PUSH
48175: LD_VAR 0 6
48179: PUSH
48180: LD_VAR 0 4
48184: ADD
48185: ST_TO_ADDR
48186: GO 48140
48188: POP
48189: POP
// end ;
48190: GO 48122
48192: POP
48193: POP
// list := list diff mc_miners [ i ] ;
48194: LD_ADDR_VAR 0 6
48198: PUSH
48199: LD_VAR 0 6
48203: PUSH
48204: LD_EXP 130
48208: PUSH
48209: LD_VAR 0 2
48213: ARRAY
48214: DIFF
48215: ST_TO_ADDR
// if not list then
48216: LD_VAR 0 6
48220: NOT
48221: IFFALSE 48225
// continue ;
48223: GO 47598
// k := mc_mines [ i ] - mc_miners [ i ] ;
48225: LD_ADDR_VAR 0 4
48229: PUSH
48230: LD_EXP 129
48234: PUSH
48235: LD_VAR 0 2
48239: ARRAY
48240: PUSH
48241: LD_EXP 130
48245: PUSH
48246: LD_VAR 0 2
48250: ARRAY
48251: MINUS
48252: ST_TO_ADDR
// if k > list then
48253: LD_VAR 0 4
48257: PUSH
48258: LD_VAR 0 6
48262: GREATER
48263: IFFALSE 48275
// k := list ;
48265: LD_ADDR_VAR 0 4
48269: PUSH
48270: LD_VAR 0 6
48274: ST_TO_ADDR
// for j = 1 to k do
48275: LD_ADDR_VAR 0 3
48279: PUSH
48280: DOUBLE
48281: LD_INT 1
48283: DEC
48284: ST_TO_ADDR
48285: LD_VAR 0 4
48289: PUSH
48290: FOR_TO
48291: IFFALSE 48345
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48293: LD_ADDR_EXP 130
48297: PUSH
48298: LD_EXP 130
48302: PPUSH
48303: LD_VAR 0 2
48307: PUSH
48308: LD_EXP 130
48312: PUSH
48313: LD_VAR 0 2
48317: ARRAY
48318: PUSH
48319: LD_INT 1
48321: PLUS
48322: PUSH
48323: EMPTY
48324: LIST
48325: LIST
48326: PPUSH
48327: LD_VAR 0 6
48331: PUSH
48332: LD_VAR 0 3
48336: ARRAY
48337: PPUSH
48338: CALL 70458 0 3
48342: ST_TO_ADDR
48343: GO 48290
48345: POP
48346: POP
// end ;
48347: GO 47598
48349: POP
48350: POP
// end ;
48351: LD_VAR 0 1
48355: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48356: LD_INT 0
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
48362: PPUSH
48363: PPUSH
48364: PPUSH
48365: PPUSH
48366: PPUSH
48367: PPUSH
// if not mc_bases then
48368: LD_EXP 116
48372: NOT
48373: IFFALSE 48377
// exit ;
48375: GO 50127
// for i = 1 to mc_bases do
48377: LD_ADDR_VAR 0 2
48381: PUSH
48382: DOUBLE
48383: LD_INT 1
48385: DEC
48386: ST_TO_ADDR
48387: LD_EXP 116
48391: PUSH
48392: FOR_TO
48393: IFFALSE 50125
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48395: LD_EXP 116
48399: PUSH
48400: LD_VAR 0 2
48404: ARRAY
48405: NOT
48406: PUSH
48407: LD_EXP 123
48411: PUSH
48412: LD_VAR 0 2
48416: ARRAY
48417: OR
48418: IFFALSE 48422
// continue ;
48420: GO 48392
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48422: LD_EXP 132
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: NOT
48433: PUSH
48434: LD_EXP 133
48438: PUSH
48439: LD_VAR 0 2
48443: ARRAY
48444: AND
48445: IFFALSE 48483
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48447: LD_ADDR_EXP 133
48451: PUSH
48452: LD_EXP 133
48456: PPUSH
48457: LD_VAR 0 2
48461: PPUSH
48462: EMPTY
48463: PPUSH
48464: CALL_OW 1
48468: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48469: LD_VAR 0 2
48473: PPUSH
48474: LD_INT 107
48476: PPUSH
48477: CALL 39310 0 2
// continue ;
48481: GO 48392
// end ; target := [ ] ;
48483: LD_ADDR_VAR 0 6
48487: PUSH
48488: EMPTY
48489: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48490: LD_ADDR_VAR 0 3
48494: PUSH
48495: DOUBLE
48496: LD_EXP 132
48500: PUSH
48501: LD_VAR 0 2
48505: ARRAY
48506: INC
48507: ST_TO_ADDR
48508: LD_INT 1
48510: PUSH
48511: FOR_DOWNTO
48512: IFFALSE 48772
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48514: LD_EXP 132
48518: PUSH
48519: LD_VAR 0 2
48523: ARRAY
48524: PUSH
48525: LD_VAR 0 3
48529: ARRAY
48530: PUSH
48531: LD_INT 2
48533: ARRAY
48534: PPUSH
48535: LD_EXP 132
48539: PUSH
48540: LD_VAR 0 2
48544: ARRAY
48545: PUSH
48546: LD_VAR 0 3
48550: ARRAY
48551: PUSH
48552: LD_INT 3
48554: ARRAY
48555: PPUSH
48556: CALL_OW 488
48560: PUSH
48561: LD_EXP 132
48565: PUSH
48566: LD_VAR 0 2
48570: ARRAY
48571: PUSH
48572: LD_VAR 0 3
48576: ARRAY
48577: PUSH
48578: LD_INT 2
48580: ARRAY
48581: PPUSH
48582: LD_EXP 132
48586: PUSH
48587: LD_VAR 0 2
48591: ARRAY
48592: PUSH
48593: LD_VAR 0 3
48597: ARRAY
48598: PUSH
48599: LD_INT 3
48601: ARRAY
48602: PPUSH
48603: CALL_OW 284
48607: PUSH
48608: LD_INT 0
48610: EQUAL
48611: AND
48612: IFFALSE 48667
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48614: LD_ADDR_VAR 0 5
48618: PUSH
48619: LD_EXP 132
48623: PUSH
48624: LD_VAR 0 2
48628: ARRAY
48629: PPUSH
48630: LD_VAR 0 3
48634: PPUSH
48635: CALL_OW 3
48639: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48640: LD_ADDR_EXP 132
48644: PUSH
48645: LD_EXP 132
48649: PPUSH
48650: LD_VAR 0 2
48654: PPUSH
48655: LD_VAR 0 5
48659: PPUSH
48660: CALL_OW 1
48664: ST_TO_ADDR
// continue ;
48665: GO 48511
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48667: LD_EXP 116
48671: PUSH
48672: LD_VAR 0 2
48676: ARRAY
48677: PUSH
48678: LD_INT 1
48680: ARRAY
48681: PPUSH
48682: CALL_OW 255
48686: PPUSH
48687: LD_EXP 132
48691: PUSH
48692: LD_VAR 0 2
48696: ARRAY
48697: PUSH
48698: LD_VAR 0 3
48702: ARRAY
48703: PUSH
48704: LD_INT 2
48706: ARRAY
48707: PPUSH
48708: LD_EXP 132
48712: PUSH
48713: LD_VAR 0 2
48717: ARRAY
48718: PUSH
48719: LD_VAR 0 3
48723: ARRAY
48724: PUSH
48725: LD_INT 3
48727: ARRAY
48728: PPUSH
48729: LD_INT 30
48731: PPUSH
48732: CALL 71354 0 4
48736: PUSH
48737: LD_INT 4
48739: ARRAY
48740: PUSH
48741: LD_INT 0
48743: EQUAL
48744: IFFALSE 48770
// begin target := mc_crates [ i ] [ j ] ;
48746: LD_ADDR_VAR 0 6
48750: PUSH
48751: LD_EXP 132
48755: PUSH
48756: LD_VAR 0 2
48760: ARRAY
48761: PUSH
48762: LD_VAR 0 3
48766: ARRAY
48767: ST_TO_ADDR
// break ;
48768: GO 48772
// end ; end ;
48770: GO 48511
48772: POP
48773: POP
// if not target then
48774: LD_VAR 0 6
48778: NOT
48779: IFFALSE 48783
// continue ;
48781: GO 48392
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48783: LD_ADDR_VAR 0 7
48787: PUSH
48788: LD_EXP 135
48792: PUSH
48793: LD_VAR 0 2
48797: ARRAY
48798: PPUSH
48799: LD_INT 2
48801: PUSH
48802: LD_INT 3
48804: PUSH
48805: LD_INT 58
48807: PUSH
48808: EMPTY
48809: LIST
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: PUSH
48815: LD_INT 61
48817: PUSH
48818: EMPTY
48819: LIST
48820: PUSH
48821: LD_INT 33
48823: PUSH
48824: LD_INT 5
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 33
48833: PUSH
48834: LD_INT 3
48836: PUSH
48837: EMPTY
48838: LIST
48839: LIST
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: PUSH
48848: LD_INT 2
48850: PUSH
48851: LD_INT 34
48853: PUSH
48854: LD_INT 32
48856: PUSH
48857: EMPTY
48858: LIST
48859: LIST
48860: PUSH
48861: LD_INT 34
48863: PUSH
48864: LD_INT 51
48866: PUSH
48867: EMPTY
48868: LIST
48869: LIST
48870: PUSH
48871: LD_INT 34
48873: PUSH
48874: LD_INT 12
48876: PUSH
48877: EMPTY
48878: LIST
48879: LIST
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: LIST
48885: LIST
48886: PUSH
48887: EMPTY
48888: LIST
48889: LIST
48890: PPUSH
48891: CALL_OW 72
48895: ST_TO_ADDR
// if not cargo then
48896: LD_VAR 0 7
48900: NOT
48901: IFFALSE 49544
// begin if mc_crates_collector [ i ] < 5 then
48903: LD_EXP 133
48907: PUSH
48908: LD_VAR 0 2
48912: ARRAY
48913: PUSH
48914: LD_INT 5
48916: LESS
48917: IFFALSE 49283
// begin if mc_ape [ i ] then
48919: LD_EXP 145
48923: PUSH
48924: LD_VAR 0 2
48928: ARRAY
48929: IFFALSE 48976
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48931: LD_ADDR_VAR 0 5
48935: PUSH
48936: LD_EXP 145
48940: PUSH
48941: LD_VAR 0 2
48945: ARRAY
48946: PPUSH
48947: LD_INT 25
48949: PUSH
48950: LD_INT 16
48952: PUSH
48953: EMPTY
48954: LIST
48955: LIST
48956: PUSH
48957: LD_INT 24
48959: PUSH
48960: LD_INT 750
48962: PUSH
48963: EMPTY
48964: LIST
48965: LIST
48966: PUSH
48967: EMPTY
48968: LIST
48969: LIST
48970: PPUSH
48971: CALL_OW 72
48975: ST_TO_ADDR
// if not tmp then
48976: LD_VAR 0 5
48980: NOT
48981: IFFALSE 49028
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48983: LD_ADDR_VAR 0 5
48987: PUSH
48988: LD_EXP 116
48992: PUSH
48993: LD_VAR 0 2
48997: ARRAY
48998: PPUSH
48999: LD_INT 25
49001: PUSH
49002: LD_INT 2
49004: PUSH
49005: EMPTY
49006: LIST
49007: LIST
49008: PUSH
49009: LD_INT 24
49011: PUSH
49012: LD_INT 750
49014: PUSH
49015: EMPTY
49016: LIST
49017: LIST
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: PPUSH
49023: CALL_OW 72
49027: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49028: LD_EXP 145
49032: PUSH
49033: LD_VAR 0 2
49037: ARRAY
49038: PUSH
49039: LD_EXP 116
49043: PUSH
49044: LD_VAR 0 2
49048: ARRAY
49049: PPUSH
49050: LD_INT 25
49052: PUSH
49053: LD_INT 2
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PUSH
49060: LD_INT 24
49062: PUSH
49063: LD_INT 750
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PUSH
49070: EMPTY
49071: LIST
49072: LIST
49073: PPUSH
49074: CALL_OW 72
49078: AND
49079: PUSH
49080: LD_VAR 0 5
49084: PUSH
49085: LD_INT 5
49087: LESS
49088: AND
49089: IFFALSE 49171
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49091: LD_ADDR_VAR 0 3
49095: PUSH
49096: LD_EXP 116
49100: PUSH
49101: LD_VAR 0 2
49105: ARRAY
49106: PPUSH
49107: LD_INT 25
49109: PUSH
49110: LD_INT 2
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 24
49119: PUSH
49120: LD_INT 750
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PPUSH
49131: CALL_OW 72
49135: PUSH
49136: FOR_IN
49137: IFFALSE 49169
// begin tmp := tmp union j ;
49139: LD_ADDR_VAR 0 5
49143: PUSH
49144: LD_VAR 0 5
49148: PUSH
49149: LD_VAR 0 3
49153: UNION
49154: ST_TO_ADDR
// if tmp >= 5 then
49155: LD_VAR 0 5
49159: PUSH
49160: LD_INT 5
49162: GREATEREQUAL
49163: IFFALSE 49167
// break ;
49165: GO 49169
// end ;
49167: GO 49136
49169: POP
49170: POP
// end ; if not tmp then
49171: LD_VAR 0 5
49175: NOT
49176: IFFALSE 49180
// continue ;
49178: GO 48392
// for j in tmp do
49180: LD_ADDR_VAR 0 3
49184: PUSH
49185: LD_VAR 0 5
49189: PUSH
49190: FOR_IN
49191: IFFALSE 49281
// if not GetTag ( j ) then
49193: LD_VAR 0 3
49197: PPUSH
49198: CALL_OW 110
49202: NOT
49203: IFFALSE 49279
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49205: LD_ADDR_EXP 133
49209: PUSH
49210: LD_EXP 133
49214: PPUSH
49215: LD_VAR 0 2
49219: PUSH
49220: LD_EXP 133
49224: PUSH
49225: LD_VAR 0 2
49229: ARRAY
49230: PUSH
49231: LD_INT 1
49233: PLUS
49234: PUSH
49235: EMPTY
49236: LIST
49237: LIST
49238: PPUSH
49239: LD_VAR 0 3
49243: PPUSH
49244: CALL 70458 0 3
49248: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49249: LD_VAR 0 3
49253: PPUSH
49254: LD_INT 107
49256: PPUSH
49257: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49261: LD_EXP 133
49265: PUSH
49266: LD_VAR 0 2
49270: ARRAY
49271: PUSH
49272: LD_INT 5
49274: GREATEREQUAL
49275: IFFALSE 49279
// break ;
49277: GO 49281
// end ;
49279: GO 49190
49281: POP
49282: POP
// end ; if mc_crates_collector [ i ] and target then
49283: LD_EXP 133
49287: PUSH
49288: LD_VAR 0 2
49292: ARRAY
49293: PUSH
49294: LD_VAR 0 6
49298: AND
49299: IFFALSE 49542
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49301: LD_EXP 133
49305: PUSH
49306: LD_VAR 0 2
49310: ARRAY
49311: PUSH
49312: LD_VAR 0 6
49316: PUSH
49317: LD_INT 1
49319: ARRAY
49320: LESS
49321: IFFALSE 49341
// tmp := mc_crates_collector [ i ] else
49323: LD_ADDR_VAR 0 5
49327: PUSH
49328: LD_EXP 133
49332: PUSH
49333: LD_VAR 0 2
49337: ARRAY
49338: ST_TO_ADDR
49339: GO 49355
// tmp := target [ 1 ] ;
49341: LD_ADDR_VAR 0 5
49345: PUSH
49346: LD_VAR 0 6
49350: PUSH
49351: LD_INT 1
49353: ARRAY
49354: ST_TO_ADDR
// k := 0 ;
49355: LD_ADDR_VAR 0 4
49359: PUSH
49360: LD_INT 0
49362: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49363: LD_ADDR_VAR 0 3
49367: PUSH
49368: LD_EXP 133
49372: PUSH
49373: LD_VAR 0 2
49377: ARRAY
49378: PUSH
49379: FOR_IN
49380: IFFALSE 49540
// begin k := k + 1 ;
49382: LD_ADDR_VAR 0 4
49386: PUSH
49387: LD_VAR 0 4
49391: PUSH
49392: LD_INT 1
49394: PLUS
49395: ST_TO_ADDR
// if k > tmp then
49396: LD_VAR 0 4
49400: PUSH
49401: LD_VAR 0 5
49405: GREATER
49406: IFFALSE 49410
// break ;
49408: GO 49540
// if not GetClass ( j ) in [ 2 , 16 ] then
49410: LD_VAR 0 3
49414: PPUSH
49415: CALL_OW 257
49419: PUSH
49420: LD_INT 2
49422: PUSH
49423: LD_INT 16
49425: PUSH
49426: EMPTY
49427: LIST
49428: LIST
49429: IN
49430: NOT
49431: IFFALSE 49484
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49433: LD_ADDR_EXP 133
49437: PUSH
49438: LD_EXP 133
49442: PPUSH
49443: LD_VAR 0 2
49447: PPUSH
49448: LD_EXP 133
49452: PUSH
49453: LD_VAR 0 2
49457: ARRAY
49458: PUSH
49459: LD_VAR 0 3
49463: DIFF
49464: PPUSH
49465: CALL_OW 1
49469: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49470: LD_VAR 0 3
49474: PPUSH
49475: LD_INT 0
49477: PPUSH
49478: CALL_OW 109
// continue ;
49482: GO 49379
// end ; if IsInUnit ( j ) then
49484: LD_VAR 0 3
49488: PPUSH
49489: CALL_OW 310
49493: IFFALSE 49504
// ComExitBuilding ( j ) ;
49495: LD_VAR 0 3
49499: PPUSH
49500: CALL_OW 122
// wait ( 3 ) ;
49504: LD_INT 3
49506: PPUSH
49507: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49511: LD_VAR 0 3
49515: PPUSH
49516: LD_VAR 0 6
49520: PUSH
49521: LD_INT 2
49523: ARRAY
49524: PPUSH
49525: LD_VAR 0 6
49529: PUSH
49530: LD_INT 3
49532: ARRAY
49533: PPUSH
49534: CALL_OW 117
// end ;
49538: GO 49379
49540: POP
49541: POP
// end ; end else
49542: GO 50123
// begin for j in cargo do
49544: LD_ADDR_VAR 0 3
49548: PUSH
49549: LD_VAR 0 7
49553: PUSH
49554: FOR_IN
49555: IFFALSE 50121
// begin if GetTag ( j ) <> 0 then
49557: LD_VAR 0 3
49561: PPUSH
49562: CALL_OW 110
49566: PUSH
49567: LD_INT 0
49569: NONEQUAL
49570: IFFALSE 49574
// continue ;
49572: GO 49554
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49574: LD_VAR 0 3
49578: PPUSH
49579: CALL_OW 256
49583: PUSH
49584: LD_INT 1000
49586: LESS
49587: PUSH
49588: LD_VAR 0 3
49592: PPUSH
49593: LD_EXP 140
49597: PUSH
49598: LD_VAR 0 2
49602: ARRAY
49603: PPUSH
49604: CALL_OW 308
49608: NOT
49609: AND
49610: IFFALSE 49632
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49612: LD_VAR 0 3
49616: PPUSH
49617: LD_EXP 140
49621: PUSH
49622: LD_VAR 0 2
49626: ARRAY
49627: PPUSH
49628: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49632: LD_VAR 0 3
49636: PPUSH
49637: CALL_OW 256
49641: PUSH
49642: LD_INT 1000
49644: LESS
49645: PUSH
49646: LD_VAR 0 3
49650: PPUSH
49651: LD_EXP 140
49655: PUSH
49656: LD_VAR 0 2
49660: ARRAY
49661: PPUSH
49662: CALL_OW 308
49666: AND
49667: IFFALSE 49671
// continue ;
49669: GO 49554
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49671: LD_VAR 0 3
49675: PPUSH
49676: CALL_OW 262
49680: PUSH
49681: LD_INT 2
49683: EQUAL
49684: PUSH
49685: LD_VAR 0 3
49689: PPUSH
49690: CALL_OW 261
49694: PUSH
49695: LD_INT 15
49697: LESS
49698: AND
49699: IFFALSE 49703
// continue ;
49701: GO 49554
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 262
49712: PUSH
49713: LD_INT 1
49715: EQUAL
49716: PUSH
49717: LD_VAR 0 3
49721: PPUSH
49722: CALL_OW 261
49726: PUSH
49727: LD_INT 10
49729: LESS
49730: AND
49731: IFFALSE 50060
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49733: LD_ADDR_VAR 0 8
49737: PUSH
49738: LD_EXP 116
49742: PUSH
49743: LD_VAR 0 2
49747: ARRAY
49748: PPUSH
49749: LD_INT 2
49751: PUSH
49752: LD_INT 30
49754: PUSH
49755: LD_INT 0
49757: PUSH
49758: EMPTY
49759: LIST
49760: LIST
49761: PUSH
49762: LD_INT 30
49764: PUSH
49765: LD_INT 1
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: PUSH
49772: EMPTY
49773: LIST
49774: LIST
49775: LIST
49776: PPUSH
49777: CALL_OW 72
49781: ST_TO_ADDR
// if not depot then
49782: LD_VAR 0 8
49786: NOT
49787: IFFALSE 49791
// continue ;
49789: GO 49554
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49791: LD_VAR 0 3
49795: PPUSH
49796: LD_VAR 0 8
49800: PPUSH
49801: LD_VAR 0 3
49805: PPUSH
49806: CALL_OW 74
49810: PPUSH
49811: CALL_OW 296
49815: PUSH
49816: LD_INT 6
49818: LESS
49819: IFFALSE 49835
// SetFuel ( j , 100 ) else
49821: LD_VAR 0 3
49825: PPUSH
49826: LD_INT 100
49828: PPUSH
49829: CALL_OW 240
49833: GO 50060
// if GetFuel ( j ) = 0 then
49835: LD_VAR 0 3
49839: PPUSH
49840: CALL_OW 261
49844: PUSH
49845: LD_INT 0
49847: EQUAL
49848: IFFALSE 50060
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49850: LD_ADDR_EXP 135
49854: PUSH
49855: LD_EXP 135
49859: PPUSH
49860: LD_VAR 0 2
49864: PPUSH
49865: LD_EXP 135
49869: PUSH
49870: LD_VAR 0 2
49874: ARRAY
49875: PUSH
49876: LD_VAR 0 3
49880: DIFF
49881: PPUSH
49882: CALL_OW 1
49886: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49887: LD_VAR 0 3
49891: PPUSH
49892: CALL_OW 263
49896: PUSH
49897: LD_INT 1
49899: EQUAL
49900: IFFALSE 49916
// ComExitVehicle ( IsInUnit ( j ) ) ;
49902: LD_VAR 0 3
49906: PPUSH
49907: CALL_OW 310
49911: PPUSH
49912: CALL_OW 121
// if GetControl ( j ) = control_remote then
49916: LD_VAR 0 3
49920: PPUSH
49921: CALL_OW 263
49925: PUSH
49926: LD_INT 2
49928: EQUAL
49929: IFFALSE 49940
// ComUnlink ( j ) ;
49931: LD_VAR 0 3
49935: PPUSH
49936: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49940: LD_ADDR_VAR 0 9
49944: PUSH
49945: LD_VAR 0 2
49949: PPUSH
49950: LD_INT 3
49952: PPUSH
49953: CALL 59530 0 2
49957: ST_TO_ADDR
// if fac then
49958: LD_VAR 0 9
49962: IFFALSE 50058
// begin for k in fac do
49964: LD_ADDR_VAR 0 4
49968: PUSH
49969: LD_VAR 0 9
49973: PUSH
49974: FOR_IN
49975: IFFALSE 50056
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49977: LD_ADDR_VAR 0 10
49981: PUSH
49982: LD_VAR 0 9
49986: PPUSH
49987: LD_VAR 0 3
49991: PPUSH
49992: CALL_OW 265
49996: PPUSH
49997: LD_VAR 0 3
50001: PPUSH
50002: CALL_OW 262
50006: PPUSH
50007: LD_VAR 0 3
50011: PPUSH
50012: CALL_OW 263
50016: PPUSH
50017: LD_VAR 0 3
50021: PPUSH
50022: CALL_OW 264
50026: PPUSH
50027: CALL 67954 0 5
50031: ST_TO_ADDR
// if components then
50032: LD_VAR 0 10
50036: IFFALSE 50054
// begin MC_InsertProduceList ( i , components ) ;
50038: LD_VAR 0 2
50042: PPUSH
50043: LD_VAR 0 10
50047: PPUSH
50048: CALL 59075 0 2
// break ;
50052: GO 50056
// end ; end ;
50054: GO 49974
50056: POP
50057: POP
// end ; continue ;
50058: GO 49554
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50060: LD_VAR 0 3
50064: PPUSH
50065: LD_INT 1
50067: PPUSH
50068: CALL_OW 289
50072: PUSH
50073: LD_INT 100
50075: LESS
50076: PUSH
50077: LD_VAR 0 3
50081: PPUSH
50082: CALL_OW 314
50086: NOT
50087: AND
50088: IFFALSE 50117
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50090: LD_VAR 0 3
50094: PPUSH
50095: LD_VAR 0 6
50099: PUSH
50100: LD_INT 2
50102: ARRAY
50103: PPUSH
50104: LD_VAR 0 6
50108: PUSH
50109: LD_INT 3
50111: ARRAY
50112: PPUSH
50113: CALL_OW 117
// break ;
50117: GO 50121
// end ;
50119: GO 49554
50121: POP
50122: POP
// end ; end ;
50123: GO 48392
50125: POP
50126: POP
// end ;
50127: LD_VAR 0 1
50131: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50132: LD_INT 0
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
// if not mc_bases then
50138: LD_EXP 116
50142: NOT
50143: IFFALSE 50147
// exit ;
50145: GO 50308
// for i = 1 to mc_bases do
50147: LD_ADDR_VAR 0 2
50151: PUSH
50152: DOUBLE
50153: LD_INT 1
50155: DEC
50156: ST_TO_ADDR
50157: LD_EXP 116
50161: PUSH
50162: FOR_TO
50163: IFFALSE 50306
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50165: LD_ADDR_VAR 0 4
50169: PUSH
50170: LD_EXP 135
50174: PUSH
50175: LD_VAR 0 2
50179: ARRAY
50180: PUSH
50181: LD_EXP 138
50185: PUSH
50186: LD_VAR 0 2
50190: ARRAY
50191: UNION
50192: PPUSH
50193: LD_INT 33
50195: PUSH
50196: LD_INT 2
50198: PUSH
50199: EMPTY
50200: LIST
50201: LIST
50202: PPUSH
50203: CALL_OW 72
50207: ST_TO_ADDR
// if tmp then
50208: LD_VAR 0 4
50212: IFFALSE 50304
// for j in tmp do
50214: LD_ADDR_VAR 0 3
50218: PUSH
50219: LD_VAR 0 4
50223: PUSH
50224: FOR_IN
50225: IFFALSE 50302
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50227: LD_VAR 0 3
50231: PPUSH
50232: CALL_OW 312
50236: NOT
50237: PUSH
50238: LD_VAR 0 3
50242: PPUSH
50243: CALL_OW 256
50247: PUSH
50248: LD_INT 250
50250: GREATEREQUAL
50251: AND
50252: IFFALSE 50265
// Connect ( j ) else
50254: LD_VAR 0 3
50258: PPUSH
50259: CALL 73429 0 1
50263: GO 50300
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50265: LD_VAR 0 3
50269: PPUSH
50270: CALL_OW 256
50274: PUSH
50275: LD_INT 250
50277: LESS
50278: PUSH
50279: LD_VAR 0 3
50283: PPUSH
50284: CALL_OW 312
50288: AND
50289: IFFALSE 50300
// ComUnlink ( j ) ;
50291: LD_VAR 0 3
50295: PPUSH
50296: CALL_OW 136
50300: GO 50224
50302: POP
50303: POP
// end ;
50304: GO 50162
50306: POP
50307: POP
// end ;
50308: LD_VAR 0 1
50312: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50313: LD_INT 0
50315: PPUSH
50316: PPUSH
50317: PPUSH
50318: PPUSH
50319: PPUSH
// if not mc_bases then
50320: LD_EXP 116
50324: NOT
50325: IFFALSE 50329
// exit ;
50327: GO 50774
// for i = 1 to mc_bases do
50329: LD_ADDR_VAR 0 2
50333: PUSH
50334: DOUBLE
50335: LD_INT 1
50337: DEC
50338: ST_TO_ADDR
50339: LD_EXP 116
50343: PUSH
50344: FOR_TO
50345: IFFALSE 50772
// begin if not mc_produce [ i ] then
50347: LD_EXP 137
50351: PUSH
50352: LD_VAR 0 2
50356: ARRAY
50357: NOT
50358: IFFALSE 50362
// continue ;
50360: GO 50344
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50362: LD_ADDR_VAR 0 5
50366: PUSH
50367: LD_EXP 116
50371: PUSH
50372: LD_VAR 0 2
50376: ARRAY
50377: PPUSH
50378: LD_INT 30
50380: PUSH
50381: LD_INT 3
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: PPUSH
50388: CALL_OW 72
50392: ST_TO_ADDR
// if not fac then
50393: LD_VAR 0 5
50397: NOT
50398: IFFALSE 50402
// continue ;
50400: GO 50344
// for j in fac do
50402: LD_ADDR_VAR 0 3
50406: PUSH
50407: LD_VAR 0 5
50411: PUSH
50412: FOR_IN
50413: IFFALSE 50768
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50415: LD_VAR 0 3
50419: PPUSH
50420: CALL_OW 461
50424: PUSH
50425: LD_INT 2
50427: NONEQUAL
50428: PUSH
50429: LD_VAR 0 3
50433: PPUSH
50434: LD_INT 15
50436: PPUSH
50437: CALL 73057 0 2
50441: PUSH
50442: LD_INT 4
50444: ARRAY
50445: OR
50446: IFFALSE 50450
// continue ;
50448: GO 50412
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50450: LD_VAR 0 3
50454: PPUSH
50455: LD_EXP 137
50459: PUSH
50460: LD_VAR 0 2
50464: ARRAY
50465: PUSH
50466: LD_INT 1
50468: ARRAY
50469: PUSH
50470: LD_INT 1
50472: ARRAY
50473: PPUSH
50474: LD_EXP 137
50478: PUSH
50479: LD_VAR 0 2
50483: ARRAY
50484: PUSH
50485: LD_INT 1
50487: ARRAY
50488: PUSH
50489: LD_INT 2
50491: ARRAY
50492: PPUSH
50493: LD_EXP 137
50497: PUSH
50498: LD_VAR 0 2
50502: ARRAY
50503: PUSH
50504: LD_INT 1
50506: ARRAY
50507: PUSH
50508: LD_INT 3
50510: ARRAY
50511: PPUSH
50512: LD_EXP 137
50516: PUSH
50517: LD_VAR 0 2
50521: ARRAY
50522: PUSH
50523: LD_INT 1
50525: ARRAY
50526: PUSH
50527: LD_INT 4
50529: ARRAY
50530: PPUSH
50531: CALL_OW 448
50535: PUSH
50536: LD_VAR 0 3
50540: PPUSH
50541: LD_EXP 137
50545: PUSH
50546: LD_VAR 0 2
50550: ARRAY
50551: PUSH
50552: LD_INT 1
50554: ARRAY
50555: PUSH
50556: LD_INT 1
50558: ARRAY
50559: PUSH
50560: LD_EXP 137
50564: PUSH
50565: LD_VAR 0 2
50569: ARRAY
50570: PUSH
50571: LD_INT 1
50573: ARRAY
50574: PUSH
50575: LD_INT 2
50577: ARRAY
50578: PUSH
50579: LD_EXP 137
50583: PUSH
50584: LD_VAR 0 2
50588: ARRAY
50589: PUSH
50590: LD_INT 1
50592: ARRAY
50593: PUSH
50594: LD_INT 3
50596: ARRAY
50597: PUSH
50598: LD_EXP 137
50602: PUSH
50603: LD_VAR 0 2
50607: ARRAY
50608: PUSH
50609: LD_INT 1
50611: ARRAY
50612: PUSH
50613: LD_INT 4
50615: ARRAY
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: LIST
50621: LIST
50622: PPUSH
50623: CALL 76825 0 2
50627: AND
50628: IFFALSE 50766
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50630: LD_VAR 0 3
50634: PPUSH
50635: LD_EXP 137
50639: PUSH
50640: LD_VAR 0 2
50644: ARRAY
50645: PUSH
50646: LD_INT 1
50648: ARRAY
50649: PUSH
50650: LD_INT 1
50652: ARRAY
50653: PPUSH
50654: LD_EXP 137
50658: PUSH
50659: LD_VAR 0 2
50663: ARRAY
50664: PUSH
50665: LD_INT 1
50667: ARRAY
50668: PUSH
50669: LD_INT 2
50671: ARRAY
50672: PPUSH
50673: LD_EXP 137
50677: PUSH
50678: LD_VAR 0 2
50682: ARRAY
50683: PUSH
50684: LD_INT 1
50686: ARRAY
50687: PUSH
50688: LD_INT 3
50690: ARRAY
50691: PPUSH
50692: LD_EXP 137
50696: PUSH
50697: LD_VAR 0 2
50701: ARRAY
50702: PUSH
50703: LD_INT 1
50705: ARRAY
50706: PUSH
50707: LD_INT 4
50709: ARRAY
50710: PPUSH
50711: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50715: LD_ADDR_VAR 0 4
50719: PUSH
50720: LD_EXP 137
50724: PUSH
50725: LD_VAR 0 2
50729: ARRAY
50730: PPUSH
50731: LD_INT 1
50733: PPUSH
50734: CALL_OW 3
50738: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50739: LD_ADDR_EXP 137
50743: PUSH
50744: LD_EXP 137
50748: PPUSH
50749: LD_VAR 0 2
50753: PPUSH
50754: LD_VAR 0 4
50758: PPUSH
50759: CALL_OW 1
50763: ST_TO_ADDR
// break ;
50764: GO 50768
// end ; end ;
50766: GO 50412
50768: POP
50769: POP
// end ;
50770: GO 50344
50772: POP
50773: POP
// end ;
50774: LD_VAR 0 1
50778: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50779: LD_INT 0
50781: PPUSH
50782: PPUSH
50783: PPUSH
// if not mc_bases then
50784: LD_EXP 116
50788: NOT
50789: IFFALSE 50793
// exit ;
50791: GO 50882
// for i = 1 to mc_bases do
50793: LD_ADDR_VAR 0 2
50797: PUSH
50798: DOUBLE
50799: LD_INT 1
50801: DEC
50802: ST_TO_ADDR
50803: LD_EXP 116
50807: PUSH
50808: FOR_TO
50809: IFFALSE 50880
// begin if mc_attack [ i ] then
50811: LD_EXP 136
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: IFFALSE 50878
// begin tmp := mc_attack [ i ] [ 1 ] ;
50823: LD_ADDR_VAR 0 3
50827: PUSH
50828: LD_EXP 136
50832: PUSH
50833: LD_VAR 0 2
50837: ARRAY
50838: PUSH
50839: LD_INT 1
50841: ARRAY
50842: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50843: LD_ADDR_EXP 136
50847: PUSH
50848: LD_EXP 136
50852: PPUSH
50853: LD_VAR 0 2
50857: PPUSH
50858: EMPTY
50859: PPUSH
50860: CALL_OW 1
50864: ST_TO_ADDR
// Attack ( tmp ) ;
50865: LD_VAR 0 3
50869: PPUSH
50870: CALL 121133 0 1
// exit ;
50874: POP
50875: POP
50876: GO 50882
// end ; end ;
50878: GO 50808
50880: POP
50881: POP
// end ;
50882: LD_VAR 0 1
50886: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50887: LD_INT 0
50889: PPUSH
50890: PPUSH
50891: PPUSH
50892: PPUSH
50893: PPUSH
50894: PPUSH
50895: PPUSH
// if not mc_bases then
50896: LD_EXP 116
50900: NOT
50901: IFFALSE 50905
// exit ;
50903: GO 51604
// for i = 1 to mc_bases do
50905: LD_ADDR_VAR 0 2
50909: PUSH
50910: DOUBLE
50911: LD_INT 1
50913: DEC
50914: ST_TO_ADDR
50915: LD_EXP 116
50919: PUSH
50920: FOR_TO
50921: IFFALSE 51602
// begin if not mc_bases [ i ] then
50923: LD_EXP 116
50927: PUSH
50928: LD_VAR 0 2
50932: ARRAY
50933: NOT
50934: IFFALSE 50938
// continue ;
50936: GO 50920
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50938: LD_ADDR_VAR 0 7
50942: PUSH
50943: LD_EXP 116
50947: PUSH
50948: LD_VAR 0 2
50952: ARRAY
50953: PUSH
50954: LD_INT 1
50956: ARRAY
50957: PPUSH
50958: CALL 67258 0 1
50962: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50963: LD_ADDR_EXP 139
50967: PUSH
50968: LD_EXP 139
50972: PPUSH
50973: LD_VAR 0 2
50977: PPUSH
50978: LD_EXP 116
50982: PUSH
50983: LD_VAR 0 2
50987: ARRAY
50988: PUSH
50989: LD_INT 1
50991: ARRAY
50992: PPUSH
50993: CALL_OW 255
50997: PPUSH
50998: LD_EXP 141
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: PPUSH
51009: CALL 67223 0 2
51013: PPUSH
51014: CALL_OW 1
51018: ST_TO_ADDR
// if not mc_scan [ i ] then
51019: LD_EXP 139
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: NOT
51030: IFFALSE 51208
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51032: LD_ADDR_VAR 0 4
51036: PUSH
51037: LD_EXP 116
51041: PUSH
51042: LD_VAR 0 2
51046: ARRAY
51047: PPUSH
51048: LD_INT 2
51050: PUSH
51051: LD_INT 25
51053: PUSH
51054: LD_INT 5
51056: PUSH
51057: EMPTY
51058: LIST
51059: LIST
51060: PUSH
51061: LD_INT 25
51063: PUSH
51064: LD_INT 8
51066: PUSH
51067: EMPTY
51068: LIST
51069: LIST
51070: PUSH
51071: LD_INT 25
51073: PUSH
51074: LD_INT 9
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: PPUSH
51087: CALL_OW 72
51091: ST_TO_ADDR
// if not tmp then
51092: LD_VAR 0 4
51096: NOT
51097: IFFALSE 51101
// continue ;
51099: GO 50920
// for j in tmp do
51101: LD_ADDR_VAR 0 3
51105: PUSH
51106: LD_VAR 0 4
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51183
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51114: LD_VAR 0 3
51118: PPUSH
51119: CALL_OW 310
51123: PPUSH
51124: CALL_OW 266
51128: PUSH
51129: LD_INT 5
51131: EQUAL
51132: PUSH
51133: LD_VAR 0 3
51137: PPUSH
51138: CALL_OW 257
51142: PUSH
51143: LD_INT 1
51145: EQUAL
51146: AND
51147: PUSH
51148: LD_VAR 0 3
51152: PPUSH
51153: CALL_OW 459
51157: NOT
51158: AND
51159: PUSH
51160: LD_VAR 0 7
51164: AND
51165: IFFALSE 51181
// ComChangeProfession ( j , class ) ;
51167: LD_VAR 0 3
51171: PPUSH
51172: LD_VAR 0 7
51176: PPUSH
51177: CALL_OW 123
51181: GO 51111
51183: POP
51184: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51185: LD_ADDR_EXP 159
51189: PUSH
51190: LD_EXP 159
51194: PPUSH
51195: LD_VAR 0 2
51199: PPUSH
51200: LD_INT 0
51202: PPUSH
51203: CALL_OW 1
51207: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51208: LD_EXP 139
51212: PUSH
51213: LD_VAR 0 2
51217: ARRAY
51218: PUSH
51219: LD_EXP 159
51223: PUSH
51224: LD_VAR 0 2
51228: ARRAY
51229: NOT
51230: AND
51231: PUSH
51232: LD_EXP 138
51236: PUSH
51237: LD_VAR 0 2
51241: ARRAY
51242: NOT
51243: AND
51244: PUSH
51245: LD_EXP 116
51249: PUSH
51250: LD_VAR 0 2
51254: ARRAY
51255: PPUSH
51256: LD_INT 30
51258: PUSH
51259: LD_INT 32
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: PPUSH
51266: CALL_OW 72
51270: NOT
51271: AND
51272: PUSH
51273: LD_EXP 116
51277: PUSH
51278: LD_VAR 0 2
51282: ARRAY
51283: PPUSH
51284: LD_INT 2
51286: PUSH
51287: LD_INT 30
51289: PUSH
51290: LD_INT 4
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: PUSH
51297: LD_INT 30
51299: PUSH
51300: LD_INT 5
51302: PUSH
51303: EMPTY
51304: LIST
51305: LIST
51306: PUSH
51307: EMPTY
51308: LIST
51309: LIST
51310: LIST
51311: PPUSH
51312: CALL_OW 72
51316: NOT
51317: AND
51318: IFFALSE 51473
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51320: LD_ADDR_VAR 0 4
51324: PUSH
51325: LD_EXP 116
51329: PUSH
51330: LD_VAR 0 2
51334: ARRAY
51335: PPUSH
51336: LD_INT 2
51338: PUSH
51339: LD_INT 25
51341: PUSH
51342: LD_INT 1
51344: PUSH
51345: EMPTY
51346: LIST
51347: LIST
51348: PUSH
51349: LD_INT 25
51351: PUSH
51352: LD_INT 5
51354: PUSH
51355: EMPTY
51356: LIST
51357: LIST
51358: PUSH
51359: LD_INT 25
51361: PUSH
51362: LD_INT 8
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 25
51371: PUSH
51372: LD_INT 9
51374: PUSH
51375: EMPTY
51376: LIST
51377: LIST
51378: PUSH
51379: EMPTY
51380: LIST
51381: LIST
51382: LIST
51383: LIST
51384: LIST
51385: PPUSH
51386: CALL_OW 72
51390: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51391: LD_ADDR_VAR 0 4
51395: PUSH
51396: LD_VAR 0 4
51400: PUSH
51401: LD_VAR 0 4
51405: PPUSH
51406: LD_INT 18
51408: PPUSH
51409: CALL 99728 0 2
51413: DIFF
51414: ST_TO_ADDR
// if tmp then
51415: LD_VAR 0 4
51419: IFFALSE 51473
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51421: LD_ADDR_EXP 159
51425: PUSH
51426: LD_EXP 159
51430: PPUSH
51431: LD_VAR 0 2
51435: PPUSH
51436: LD_INT 1
51438: PPUSH
51439: CALL_OW 1
51443: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51444: LD_VAR 0 2
51448: PPUSH
51449: LD_VAR 0 4
51453: PPUSH
51454: LD_EXP 141
51458: PUSH
51459: LD_VAR 0 2
51463: ARRAY
51464: PPUSH
51465: CALL 125842 0 3
// exit ;
51469: POP
51470: POP
51471: GO 51604
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51473: LD_EXP 139
51477: PUSH
51478: LD_VAR 0 2
51482: ARRAY
51483: PUSH
51484: LD_EXP 159
51488: PUSH
51489: LD_VAR 0 2
51493: ARRAY
51494: NOT
51495: AND
51496: PUSH
51497: LD_EXP 138
51501: PUSH
51502: LD_VAR 0 2
51506: ARRAY
51507: AND
51508: IFFALSE 51600
// begin tmp := mc_defender [ i ] ;
51510: LD_ADDR_VAR 0 4
51514: PUSH
51515: LD_EXP 138
51519: PUSH
51520: LD_VAR 0 2
51524: ARRAY
51525: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51526: LD_ADDR_EXP 138
51530: PUSH
51531: LD_EXP 138
51535: PPUSH
51536: LD_VAR 0 2
51540: PPUSH
51541: EMPTY
51542: PPUSH
51543: CALL_OW 1
51547: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51548: LD_ADDR_EXP 159
51552: PUSH
51553: LD_EXP 159
51557: PPUSH
51558: LD_VAR 0 2
51562: PPUSH
51563: LD_INT 1
51565: PPUSH
51566: CALL_OW 1
51570: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51571: LD_VAR 0 2
51575: PPUSH
51576: LD_VAR 0 4
51580: PPUSH
51581: LD_EXP 139
51585: PUSH
51586: LD_VAR 0 2
51590: ARRAY
51591: PPUSH
51592: CALL 126403 0 3
// exit ;
51596: POP
51597: POP
51598: GO 51604
// end ; end ;
51600: GO 50920
51602: POP
51603: POP
// end ;
51604: LD_VAR 0 1
51608: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51609: LD_INT 0
51611: PPUSH
51612: PPUSH
51613: PPUSH
51614: PPUSH
51615: PPUSH
51616: PPUSH
51617: PPUSH
51618: PPUSH
51619: PPUSH
51620: PPUSH
51621: PPUSH
// if not mc_bases then
51622: LD_EXP 116
51626: NOT
51627: IFFALSE 51631
// exit ;
51629: GO 52718
// for i = 1 to mc_bases do
51631: LD_ADDR_VAR 0 2
51635: PUSH
51636: DOUBLE
51637: LD_INT 1
51639: DEC
51640: ST_TO_ADDR
51641: LD_EXP 116
51645: PUSH
51646: FOR_TO
51647: IFFALSE 52716
// begin tmp := mc_lab [ i ] ;
51649: LD_ADDR_VAR 0 6
51653: PUSH
51654: LD_EXP 149
51658: PUSH
51659: LD_VAR 0 2
51663: ARRAY
51664: ST_TO_ADDR
// if not tmp then
51665: LD_VAR 0 6
51669: NOT
51670: IFFALSE 51674
// continue ;
51672: GO 51646
// idle_lab := 0 ;
51674: LD_ADDR_VAR 0 11
51678: PUSH
51679: LD_INT 0
51681: ST_TO_ADDR
// for j in tmp do
51682: LD_ADDR_VAR 0 3
51686: PUSH
51687: LD_VAR 0 6
51691: PUSH
51692: FOR_IN
51693: IFFALSE 52712
// begin researching := false ;
51695: LD_ADDR_VAR 0 10
51699: PUSH
51700: LD_INT 0
51702: ST_TO_ADDR
// side := GetSide ( j ) ;
51703: LD_ADDR_VAR 0 4
51707: PUSH
51708: LD_VAR 0 3
51712: PPUSH
51713: CALL_OW 255
51717: ST_TO_ADDR
// if not mc_tech [ side ] then
51718: LD_EXP 143
51722: PUSH
51723: LD_VAR 0 4
51727: ARRAY
51728: NOT
51729: IFFALSE 51733
// continue ;
51731: GO 51692
// if BuildingStatus ( j ) = bs_idle then
51733: LD_VAR 0 3
51737: PPUSH
51738: CALL_OW 461
51742: PUSH
51743: LD_INT 2
51745: EQUAL
51746: IFFALSE 51934
// begin if idle_lab and UnitsInside ( j ) < 6 then
51748: LD_VAR 0 11
51752: PUSH
51753: LD_VAR 0 3
51757: PPUSH
51758: CALL_OW 313
51762: PUSH
51763: LD_INT 6
51765: LESS
51766: AND
51767: IFFALSE 51838
// begin tmp2 := UnitsInside ( idle_lab ) ;
51769: LD_ADDR_VAR 0 9
51773: PUSH
51774: LD_VAR 0 11
51778: PPUSH
51779: CALL_OW 313
51783: ST_TO_ADDR
// if tmp2 then
51784: LD_VAR 0 9
51788: IFFALSE 51830
// for x in tmp2 do
51790: LD_ADDR_VAR 0 7
51794: PUSH
51795: LD_VAR 0 9
51799: PUSH
51800: FOR_IN
51801: IFFALSE 51828
// begin ComExitBuilding ( x ) ;
51803: LD_VAR 0 7
51807: PPUSH
51808: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51812: LD_VAR 0 7
51816: PPUSH
51817: LD_VAR 0 3
51821: PPUSH
51822: CALL_OW 180
// end ;
51826: GO 51800
51828: POP
51829: POP
// idle_lab := 0 ;
51830: LD_ADDR_VAR 0 11
51834: PUSH
51835: LD_INT 0
51837: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51838: LD_ADDR_VAR 0 5
51842: PUSH
51843: LD_EXP 143
51847: PUSH
51848: LD_VAR 0 4
51852: ARRAY
51853: PUSH
51854: FOR_IN
51855: IFFALSE 51915
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51857: LD_VAR 0 3
51861: PPUSH
51862: LD_VAR 0 5
51866: PPUSH
51867: CALL_OW 430
51871: PUSH
51872: LD_VAR 0 4
51876: PPUSH
51877: LD_VAR 0 5
51881: PPUSH
51882: CALL 66328 0 2
51886: AND
51887: IFFALSE 51913
// begin researching := true ;
51889: LD_ADDR_VAR 0 10
51893: PUSH
51894: LD_INT 1
51896: ST_TO_ADDR
// ComResearch ( j , t ) ;
51897: LD_VAR 0 3
51901: PPUSH
51902: LD_VAR 0 5
51906: PPUSH
51907: CALL_OW 124
// break ;
51911: GO 51915
// end ;
51913: GO 51854
51915: POP
51916: POP
// if not researching then
51917: LD_VAR 0 10
51921: NOT
51922: IFFALSE 51934
// idle_lab := j ;
51924: LD_ADDR_VAR 0 11
51928: PUSH
51929: LD_VAR 0 3
51933: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51934: LD_VAR 0 3
51938: PPUSH
51939: CALL_OW 461
51943: PUSH
51944: LD_INT 10
51946: EQUAL
51947: IFFALSE 52535
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51949: LD_EXP 145
51953: PUSH
51954: LD_VAR 0 2
51958: ARRAY
51959: NOT
51960: PUSH
51961: LD_EXP 146
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: NOT
51972: AND
51973: PUSH
51974: LD_EXP 143
51978: PUSH
51979: LD_VAR 0 4
51983: ARRAY
51984: PUSH
51985: LD_INT 1
51987: GREATER
51988: AND
51989: IFFALSE 52120
// begin ComCancel ( j ) ;
51991: LD_VAR 0 3
51995: PPUSH
51996: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52000: LD_ADDR_EXP 143
52004: PUSH
52005: LD_EXP 143
52009: PPUSH
52010: LD_VAR 0 4
52014: PPUSH
52015: LD_EXP 143
52019: PUSH
52020: LD_VAR 0 4
52024: ARRAY
52025: PPUSH
52026: LD_EXP 143
52030: PUSH
52031: LD_VAR 0 4
52035: ARRAY
52036: PUSH
52037: LD_INT 1
52039: MINUS
52040: PPUSH
52041: LD_EXP 143
52045: PUSH
52046: LD_VAR 0 4
52050: ARRAY
52051: PPUSH
52052: LD_INT 0
52054: PPUSH
52055: CALL 69876 0 4
52059: PPUSH
52060: CALL_OW 1
52064: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52065: LD_ADDR_EXP 143
52069: PUSH
52070: LD_EXP 143
52074: PPUSH
52075: LD_VAR 0 4
52079: PPUSH
52080: LD_EXP 143
52084: PUSH
52085: LD_VAR 0 4
52089: ARRAY
52090: PPUSH
52091: LD_EXP 143
52095: PUSH
52096: LD_VAR 0 4
52100: ARRAY
52101: PPUSH
52102: LD_INT 1
52104: PPUSH
52105: LD_INT 0
52107: PPUSH
52108: CALL 69876 0 4
52112: PPUSH
52113: CALL_OW 1
52117: ST_TO_ADDR
// continue ;
52118: GO 51692
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52120: LD_EXP 145
52124: PUSH
52125: LD_VAR 0 2
52129: ARRAY
52130: PUSH
52131: LD_EXP 146
52135: PUSH
52136: LD_VAR 0 2
52140: ARRAY
52141: NOT
52142: AND
52143: IFFALSE 52270
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52145: LD_ADDR_EXP 146
52149: PUSH
52150: LD_EXP 146
52154: PPUSH
52155: LD_VAR 0 2
52159: PUSH
52160: LD_EXP 146
52164: PUSH
52165: LD_VAR 0 2
52169: ARRAY
52170: PUSH
52171: LD_INT 1
52173: PLUS
52174: PUSH
52175: EMPTY
52176: LIST
52177: LIST
52178: PPUSH
52179: LD_EXP 145
52183: PUSH
52184: LD_VAR 0 2
52188: ARRAY
52189: PUSH
52190: LD_INT 1
52192: ARRAY
52193: PPUSH
52194: CALL 70458 0 3
52198: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52199: LD_EXP 145
52203: PUSH
52204: LD_VAR 0 2
52208: ARRAY
52209: PUSH
52210: LD_INT 1
52212: ARRAY
52213: PPUSH
52214: LD_INT 112
52216: PPUSH
52217: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52221: LD_ADDR_VAR 0 9
52225: PUSH
52226: LD_EXP 145
52230: PUSH
52231: LD_VAR 0 2
52235: ARRAY
52236: PPUSH
52237: LD_INT 1
52239: PPUSH
52240: CALL_OW 3
52244: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52245: LD_ADDR_EXP 145
52249: PUSH
52250: LD_EXP 145
52254: PPUSH
52255: LD_VAR 0 2
52259: PPUSH
52260: LD_VAR 0 9
52264: PPUSH
52265: CALL_OW 1
52269: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52270: LD_EXP 145
52274: PUSH
52275: LD_VAR 0 2
52279: ARRAY
52280: PUSH
52281: LD_EXP 146
52285: PUSH
52286: LD_VAR 0 2
52290: ARRAY
52291: AND
52292: PUSH
52293: LD_EXP 146
52297: PUSH
52298: LD_VAR 0 2
52302: ARRAY
52303: PUSH
52304: LD_INT 1
52306: ARRAY
52307: PPUSH
52308: CALL_OW 310
52312: NOT
52313: AND
52314: PUSH
52315: LD_VAR 0 3
52319: PPUSH
52320: CALL_OW 313
52324: PUSH
52325: LD_INT 6
52327: EQUAL
52328: AND
52329: IFFALSE 52385
// begin tmp2 := UnitsInside ( j ) ;
52331: LD_ADDR_VAR 0 9
52335: PUSH
52336: LD_VAR 0 3
52340: PPUSH
52341: CALL_OW 313
52345: ST_TO_ADDR
// if tmp2 = 6 then
52346: LD_VAR 0 9
52350: PUSH
52351: LD_INT 6
52353: EQUAL
52354: IFFALSE 52385
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52356: LD_VAR 0 9
52360: PUSH
52361: LD_INT 1
52363: ARRAY
52364: PPUSH
52365: LD_INT 112
52367: PPUSH
52368: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52372: LD_VAR 0 9
52376: PUSH
52377: LD_INT 1
52379: ARRAY
52380: PPUSH
52381: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52385: LD_EXP 146
52389: PUSH
52390: LD_VAR 0 2
52394: ARRAY
52395: PUSH
52396: LD_EXP 146
52400: PUSH
52401: LD_VAR 0 2
52405: ARRAY
52406: PUSH
52407: LD_INT 1
52409: ARRAY
52410: PPUSH
52411: CALL_OW 314
52415: NOT
52416: AND
52417: PUSH
52418: LD_EXP 146
52422: PUSH
52423: LD_VAR 0 2
52427: ARRAY
52428: PUSH
52429: LD_INT 1
52431: ARRAY
52432: PPUSH
52433: CALL_OW 310
52437: NOT
52438: AND
52439: IFFALSE 52465
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52441: LD_EXP 146
52445: PUSH
52446: LD_VAR 0 2
52450: ARRAY
52451: PUSH
52452: LD_INT 1
52454: ARRAY
52455: PPUSH
52456: LD_VAR 0 3
52460: PPUSH
52461: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52465: LD_EXP 146
52469: PUSH
52470: LD_VAR 0 2
52474: ARRAY
52475: PUSH
52476: LD_INT 1
52478: ARRAY
52479: PPUSH
52480: CALL_OW 310
52484: PUSH
52485: LD_EXP 146
52489: PUSH
52490: LD_VAR 0 2
52494: ARRAY
52495: PUSH
52496: LD_INT 1
52498: ARRAY
52499: PPUSH
52500: CALL_OW 310
52504: PPUSH
52505: CALL_OW 461
52509: PUSH
52510: LD_INT 3
52512: NONEQUAL
52513: AND
52514: IFFALSE 52535
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52516: LD_EXP 146
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: PUSH
52527: LD_INT 1
52529: ARRAY
52530: PPUSH
52531: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52535: LD_VAR 0 3
52539: PPUSH
52540: CALL_OW 461
52544: PUSH
52545: LD_INT 6
52547: EQUAL
52548: PUSH
52549: LD_VAR 0 6
52553: PUSH
52554: LD_INT 1
52556: GREATER
52557: AND
52558: IFFALSE 52710
// begin sci := [ ] ;
52560: LD_ADDR_VAR 0 8
52564: PUSH
52565: EMPTY
52566: ST_TO_ADDR
// for x in ( tmp diff j ) do
52567: LD_ADDR_VAR 0 7
52571: PUSH
52572: LD_VAR 0 6
52576: PUSH
52577: LD_VAR 0 3
52581: DIFF
52582: PUSH
52583: FOR_IN
52584: IFFALSE 52636
// begin if sci = 6 then
52586: LD_VAR 0 8
52590: PUSH
52591: LD_INT 6
52593: EQUAL
52594: IFFALSE 52598
// break ;
52596: GO 52636
// if BuildingStatus ( x ) = bs_idle then
52598: LD_VAR 0 7
52602: PPUSH
52603: CALL_OW 461
52607: PUSH
52608: LD_INT 2
52610: EQUAL
52611: IFFALSE 52634
// sci := sci ^ UnitsInside ( x ) ;
52613: LD_ADDR_VAR 0 8
52617: PUSH
52618: LD_VAR 0 8
52622: PUSH
52623: LD_VAR 0 7
52627: PPUSH
52628: CALL_OW 313
52632: ADD
52633: ST_TO_ADDR
// end ;
52634: GO 52583
52636: POP
52637: POP
// if not sci then
52638: LD_VAR 0 8
52642: NOT
52643: IFFALSE 52647
// continue ;
52645: GO 51692
// for x in sci do
52647: LD_ADDR_VAR 0 7
52651: PUSH
52652: LD_VAR 0 8
52656: PUSH
52657: FOR_IN
52658: IFFALSE 52708
// if IsInUnit ( x ) and not HasTask ( x ) then
52660: LD_VAR 0 7
52664: PPUSH
52665: CALL_OW 310
52669: PUSH
52670: LD_VAR 0 7
52674: PPUSH
52675: CALL_OW 314
52679: NOT
52680: AND
52681: IFFALSE 52706
// begin ComExitBuilding ( x ) ;
52683: LD_VAR 0 7
52687: PPUSH
52688: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52692: LD_VAR 0 7
52696: PPUSH
52697: LD_VAR 0 3
52701: PPUSH
52702: CALL_OW 180
// end ;
52706: GO 52657
52708: POP
52709: POP
// end ; end ;
52710: GO 51692
52712: POP
52713: POP
// end ;
52714: GO 51646
52716: POP
52717: POP
// end ;
52718: LD_VAR 0 1
52722: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52723: LD_INT 0
52725: PPUSH
52726: PPUSH
// if not mc_bases then
52727: LD_EXP 116
52731: NOT
52732: IFFALSE 52736
// exit ;
52734: GO 52817
// for i = 1 to mc_bases do
52736: LD_ADDR_VAR 0 2
52740: PUSH
52741: DOUBLE
52742: LD_INT 1
52744: DEC
52745: ST_TO_ADDR
52746: LD_EXP 116
52750: PUSH
52751: FOR_TO
52752: IFFALSE 52815
// if mc_mines [ i ] and mc_miners [ i ] then
52754: LD_EXP 129
52758: PUSH
52759: LD_VAR 0 2
52763: ARRAY
52764: PUSH
52765: LD_EXP 130
52769: PUSH
52770: LD_VAR 0 2
52774: ARRAY
52775: AND
52776: IFFALSE 52813
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52778: LD_EXP 130
52782: PUSH
52783: LD_VAR 0 2
52787: ARRAY
52788: PUSH
52789: LD_INT 1
52791: ARRAY
52792: PPUSH
52793: CALL_OW 255
52797: PPUSH
52798: LD_EXP 129
52802: PUSH
52803: LD_VAR 0 2
52807: ARRAY
52808: PPUSH
52809: CALL 67411 0 2
52813: GO 52751
52815: POP
52816: POP
// end ;
52817: LD_VAR 0 1
52821: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52822: LD_INT 0
52824: PPUSH
52825: PPUSH
52826: PPUSH
52827: PPUSH
52828: PPUSH
52829: PPUSH
52830: PPUSH
52831: PPUSH
// if not mc_bases or not mc_parking then
52832: LD_EXP 116
52836: NOT
52837: PUSH
52838: LD_EXP 140
52842: NOT
52843: OR
52844: IFFALSE 52848
// exit ;
52846: GO 53547
// for i = 1 to mc_bases do
52848: LD_ADDR_VAR 0 2
52852: PUSH
52853: DOUBLE
52854: LD_INT 1
52856: DEC
52857: ST_TO_ADDR
52858: LD_EXP 116
52862: PUSH
52863: FOR_TO
52864: IFFALSE 53545
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52866: LD_EXP 116
52870: PUSH
52871: LD_VAR 0 2
52875: ARRAY
52876: NOT
52877: PUSH
52878: LD_EXP 140
52882: PUSH
52883: LD_VAR 0 2
52887: ARRAY
52888: NOT
52889: OR
52890: IFFALSE 52894
// continue ;
52892: GO 52863
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52894: LD_ADDR_VAR 0 5
52898: PUSH
52899: LD_EXP 116
52903: PUSH
52904: LD_VAR 0 2
52908: ARRAY
52909: PUSH
52910: LD_INT 1
52912: ARRAY
52913: PPUSH
52914: CALL_OW 255
52918: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52919: LD_ADDR_VAR 0 6
52923: PUSH
52924: LD_EXP 116
52928: PUSH
52929: LD_VAR 0 2
52933: ARRAY
52934: PPUSH
52935: LD_INT 30
52937: PUSH
52938: LD_INT 3
52940: PUSH
52941: EMPTY
52942: LIST
52943: LIST
52944: PPUSH
52945: CALL_OW 72
52949: ST_TO_ADDR
// if not fac then
52950: LD_VAR 0 6
52954: NOT
52955: IFFALSE 53006
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52957: LD_ADDR_VAR 0 6
52961: PUSH
52962: LD_EXP 116
52966: PUSH
52967: LD_VAR 0 2
52971: ARRAY
52972: PPUSH
52973: LD_INT 2
52975: PUSH
52976: LD_INT 30
52978: PUSH
52979: LD_INT 0
52981: PUSH
52982: EMPTY
52983: LIST
52984: LIST
52985: PUSH
52986: LD_INT 30
52988: PUSH
52989: LD_INT 1
52991: PUSH
52992: EMPTY
52993: LIST
52994: LIST
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: LIST
53000: PPUSH
53001: CALL_OW 72
53005: ST_TO_ADDR
// if not fac then
53006: LD_VAR 0 6
53010: NOT
53011: IFFALSE 53015
// continue ;
53013: GO 52863
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53015: LD_ADDR_VAR 0 7
53019: PUSH
53020: LD_EXP 140
53024: PUSH
53025: LD_VAR 0 2
53029: ARRAY
53030: PPUSH
53031: LD_INT 22
53033: PUSH
53034: LD_VAR 0 5
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: PUSH
53043: LD_INT 21
53045: PUSH
53046: LD_INT 2
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: PUSH
53053: LD_INT 3
53055: PUSH
53056: LD_INT 24
53058: PUSH
53059: LD_INT 1000
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: PUSH
53070: EMPTY
53071: LIST
53072: LIST
53073: LIST
53074: PPUSH
53075: CALL_OW 70
53079: ST_TO_ADDR
// for j in fac do
53080: LD_ADDR_VAR 0 3
53084: PUSH
53085: LD_VAR 0 6
53089: PUSH
53090: FOR_IN
53091: IFFALSE 53172
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53093: LD_ADDR_VAR 0 7
53097: PUSH
53098: LD_VAR 0 7
53102: PUSH
53103: LD_INT 22
53105: PUSH
53106: LD_VAR 0 5
53110: PUSH
53111: EMPTY
53112: LIST
53113: LIST
53114: PUSH
53115: LD_INT 91
53117: PUSH
53118: LD_VAR 0 3
53122: PUSH
53123: LD_INT 15
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: LIST
53130: PUSH
53131: LD_INT 21
53133: PUSH
53134: LD_INT 2
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PUSH
53141: LD_INT 3
53143: PUSH
53144: LD_INT 24
53146: PUSH
53147: LD_INT 1000
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: LIST
53162: LIST
53163: PPUSH
53164: CALL_OW 69
53168: UNION
53169: ST_TO_ADDR
53170: GO 53090
53172: POP
53173: POP
// if not vehs then
53174: LD_VAR 0 7
53178: NOT
53179: IFFALSE 53205
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53181: LD_ADDR_EXP 128
53185: PUSH
53186: LD_EXP 128
53190: PPUSH
53191: LD_VAR 0 2
53195: PPUSH
53196: EMPTY
53197: PPUSH
53198: CALL_OW 1
53202: ST_TO_ADDR
// continue ;
53203: GO 52863
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53205: LD_ADDR_VAR 0 8
53209: PUSH
53210: LD_EXP 116
53214: PUSH
53215: LD_VAR 0 2
53219: ARRAY
53220: PPUSH
53221: LD_INT 30
53223: PUSH
53224: LD_INT 3
53226: PUSH
53227: EMPTY
53228: LIST
53229: LIST
53230: PPUSH
53231: CALL_OW 72
53235: ST_TO_ADDR
// if tmp then
53236: LD_VAR 0 8
53240: IFFALSE 53343
// begin for j in tmp do
53242: LD_ADDR_VAR 0 3
53246: PUSH
53247: LD_VAR 0 8
53251: PUSH
53252: FOR_IN
53253: IFFALSE 53341
// for k in UnitsInside ( j ) do
53255: LD_ADDR_VAR 0 4
53259: PUSH
53260: LD_VAR 0 3
53264: PPUSH
53265: CALL_OW 313
53269: PUSH
53270: FOR_IN
53271: IFFALSE 53337
// if k then
53273: LD_VAR 0 4
53277: IFFALSE 53335
// if not k in mc_repair_vehicle [ i ] then
53279: LD_VAR 0 4
53283: PUSH
53284: LD_EXP 128
53288: PUSH
53289: LD_VAR 0 2
53293: ARRAY
53294: IN
53295: NOT
53296: IFFALSE 53335
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53298: LD_ADDR_EXP 128
53302: PUSH
53303: LD_EXP 128
53307: PPUSH
53308: LD_VAR 0 2
53312: PPUSH
53313: LD_EXP 128
53317: PUSH
53318: LD_VAR 0 2
53322: ARRAY
53323: PUSH
53324: LD_VAR 0 4
53328: UNION
53329: PPUSH
53330: CALL_OW 1
53334: ST_TO_ADDR
53335: GO 53270
53337: POP
53338: POP
53339: GO 53252
53341: POP
53342: POP
// end ; if not mc_repair_vehicle [ i ] then
53343: LD_EXP 128
53347: PUSH
53348: LD_VAR 0 2
53352: ARRAY
53353: NOT
53354: IFFALSE 53358
// continue ;
53356: GO 52863
// for j in mc_repair_vehicle [ i ] do
53358: LD_ADDR_VAR 0 3
53362: PUSH
53363: LD_EXP 128
53367: PUSH
53368: LD_VAR 0 2
53372: ARRAY
53373: PUSH
53374: FOR_IN
53375: IFFALSE 53541
// begin if GetClass ( j ) <> 3 then
53377: LD_VAR 0 3
53381: PPUSH
53382: CALL_OW 257
53386: PUSH
53387: LD_INT 3
53389: NONEQUAL
53390: IFFALSE 53431
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53392: LD_ADDR_EXP 128
53396: PUSH
53397: LD_EXP 128
53401: PPUSH
53402: LD_VAR 0 2
53406: PPUSH
53407: LD_EXP 128
53411: PUSH
53412: LD_VAR 0 2
53416: ARRAY
53417: PUSH
53418: LD_VAR 0 3
53422: DIFF
53423: PPUSH
53424: CALL_OW 1
53428: ST_TO_ADDR
// continue ;
53429: GO 53374
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53431: LD_VAR 0 3
53435: PPUSH
53436: CALL_OW 311
53440: NOT
53441: PUSH
53442: LD_VAR 0 3
53446: PUSH
53447: LD_EXP 119
53451: PUSH
53452: LD_VAR 0 2
53456: ARRAY
53457: PUSH
53458: LD_INT 1
53460: ARRAY
53461: IN
53462: NOT
53463: AND
53464: PUSH
53465: LD_VAR 0 3
53469: PUSH
53470: LD_EXP 119
53474: PUSH
53475: LD_VAR 0 2
53479: ARRAY
53480: PUSH
53481: LD_INT 2
53483: ARRAY
53484: IN
53485: NOT
53486: AND
53487: IFFALSE 53539
// begin if IsInUnit ( j ) then
53489: LD_VAR 0 3
53493: PPUSH
53494: CALL_OW 310
53498: IFFALSE 53509
// ComExitBuilding ( j ) ;
53500: LD_VAR 0 3
53504: PPUSH
53505: CALL_OW 122
// if not HasTask ( j ) then
53509: LD_VAR 0 3
53513: PPUSH
53514: CALL_OW 314
53518: NOT
53519: IFFALSE 53539
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53521: LD_VAR 0 3
53525: PPUSH
53526: LD_VAR 0 7
53530: PUSH
53531: LD_INT 1
53533: ARRAY
53534: PPUSH
53535: CALL_OW 189
// end ; end ;
53539: GO 53374
53541: POP
53542: POP
// end ;
53543: GO 52863
53545: POP
53546: POP
// end ;
53547: LD_VAR 0 1
53551: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53552: LD_INT 0
53554: PPUSH
53555: PPUSH
53556: PPUSH
53557: PPUSH
53558: PPUSH
53559: PPUSH
53560: PPUSH
53561: PPUSH
53562: PPUSH
53563: PPUSH
53564: PPUSH
// if not mc_bases then
53565: LD_EXP 116
53569: NOT
53570: IFFALSE 53574
// exit ;
53572: GO 54376
// for i = 1 to mc_bases do
53574: LD_ADDR_VAR 0 2
53578: PUSH
53579: DOUBLE
53580: LD_INT 1
53582: DEC
53583: ST_TO_ADDR
53584: LD_EXP 116
53588: PUSH
53589: FOR_TO
53590: IFFALSE 54374
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53592: LD_EXP 144
53596: PUSH
53597: LD_VAR 0 2
53601: ARRAY
53602: NOT
53603: PUSH
53604: LD_EXP 119
53608: PUSH
53609: LD_VAR 0 2
53613: ARRAY
53614: PUSH
53615: LD_INT 1
53617: ARRAY
53618: OR
53619: PUSH
53620: LD_EXP 119
53624: PUSH
53625: LD_VAR 0 2
53629: ARRAY
53630: PUSH
53631: LD_INT 2
53633: ARRAY
53634: OR
53635: PUSH
53636: LD_EXP 142
53640: PUSH
53641: LD_VAR 0 2
53645: ARRAY
53646: PPUSH
53647: LD_INT 1
53649: PPUSH
53650: CALL_OW 325
53654: NOT
53655: OR
53656: PUSH
53657: LD_EXP 139
53661: PUSH
53662: LD_VAR 0 2
53666: ARRAY
53667: OR
53668: IFFALSE 53672
// continue ;
53670: GO 53589
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53672: LD_ADDR_VAR 0 8
53676: PUSH
53677: LD_EXP 116
53681: PUSH
53682: LD_VAR 0 2
53686: ARRAY
53687: PPUSH
53688: LD_INT 25
53690: PUSH
53691: LD_INT 4
53693: PUSH
53694: EMPTY
53695: LIST
53696: LIST
53697: PUSH
53698: LD_INT 50
53700: PUSH
53701: EMPTY
53702: LIST
53703: PUSH
53704: LD_INT 3
53706: PUSH
53707: LD_INT 60
53709: PUSH
53710: EMPTY
53711: LIST
53712: PUSH
53713: EMPTY
53714: LIST
53715: LIST
53716: PUSH
53717: EMPTY
53718: LIST
53719: LIST
53720: LIST
53721: PPUSH
53722: CALL_OW 72
53726: PUSH
53727: LD_EXP 120
53731: PUSH
53732: LD_VAR 0 2
53736: ARRAY
53737: DIFF
53738: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53739: LD_ADDR_VAR 0 9
53743: PUSH
53744: LD_EXP 116
53748: PUSH
53749: LD_VAR 0 2
53753: ARRAY
53754: PPUSH
53755: LD_INT 2
53757: PUSH
53758: LD_INT 30
53760: PUSH
53761: LD_INT 0
53763: PUSH
53764: EMPTY
53765: LIST
53766: LIST
53767: PUSH
53768: LD_INT 30
53770: PUSH
53771: LD_INT 1
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: PUSH
53778: EMPTY
53779: LIST
53780: LIST
53781: LIST
53782: PPUSH
53783: CALL_OW 72
53787: ST_TO_ADDR
// if not tmp or not dep then
53788: LD_VAR 0 8
53792: NOT
53793: PUSH
53794: LD_VAR 0 9
53798: NOT
53799: OR
53800: IFFALSE 53804
// continue ;
53802: GO 53589
// side := GetSide ( tmp [ 1 ] ) ;
53804: LD_ADDR_VAR 0 11
53808: PUSH
53809: LD_VAR 0 8
53813: PUSH
53814: LD_INT 1
53816: ARRAY
53817: PPUSH
53818: CALL_OW 255
53822: ST_TO_ADDR
// dep := dep [ 1 ] ;
53823: LD_ADDR_VAR 0 9
53827: PUSH
53828: LD_VAR 0 9
53832: PUSH
53833: LD_INT 1
53835: ARRAY
53836: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53837: LD_ADDR_VAR 0 7
53841: PUSH
53842: LD_EXP 144
53846: PUSH
53847: LD_VAR 0 2
53851: ARRAY
53852: PPUSH
53853: LD_INT 22
53855: PUSH
53856: LD_INT 0
53858: PUSH
53859: EMPTY
53860: LIST
53861: LIST
53862: PUSH
53863: LD_INT 25
53865: PUSH
53866: LD_INT 12
53868: PUSH
53869: EMPTY
53870: LIST
53871: LIST
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PPUSH
53877: CALL_OW 70
53881: PUSH
53882: LD_INT 22
53884: PUSH
53885: LD_INT 0
53887: PUSH
53888: EMPTY
53889: LIST
53890: LIST
53891: PUSH
53892: LD_INT 25
53894: PUSH
53895: LD_INT 12
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PUSH
53902: LD_INT 91
53904: PUSH
53905: LD_VAR 0 9
53909: PUSH
53910: LD_INT 20
53912: PUSH
53913: EMPTY
53914: LIST
53915: LIST
53916: LIST
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: LIST
53922: PPUSH
53923: CALL_OW 69
53927: UNION
53928: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53929: LD_ADDR_VAR 0 10
53933: PUSH
53934: LD_EXP 144
53938: PUSH
53939: LD_VAR 0 2
53943: ARRAY
53944: PPUSH
53945: LD_INT 81
53947: PUSH
53948: LD_VAR 0 11
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PPUSH
53957: CALL_OW 70
53961: ST_TO_ADDR
// if not apes or danger_at_area then
53962: LD_VAR 0 7
53966: NOT
53967: PUSH
53968: LD_VAR 0 10
53972: OR
53973: IFFALSE 54023
// begin if mc_taming [ i ] then
53975: LD_EXP 147
53979: PUSH
53980: LD_VAR 0 2
53984: ARRAY
53985: IFFALSE 54021
// begin MC_Reset ( i , 121 ) ;
53987: LD_VAR 0 2
53991: PPUSH
53992: LD_INT 121
53994: PPUSH
53995: CALL 39310 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53999: LD_ADDR_EXP 147
54003: PUSH
54004: LD_EXP 147
54008: PPUSH
54009: LD_VAR 0 2
54013: PPUSH
54014: EMPTY
54015: PPUSH
54016: CALL_OW 1
54020: ST_TO_ADDR
// end ; continue ;
54021: GO 53589
// end ; for j in tmp do
54023: LD_ADDR_VAR 0 3
54027: PUSH
54028: LD_VAR 0 8
54032: PUSH
54033: FOR_IN
54034: IFFALSE 54370
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54036: LD_VAR 0 3
54040: PUSH
54041: LD_EXP 147
54045: PUSH
54046: LD_VAR 0 2
54050: ARRAY
54051: IN
54052: NOT
54053: PUSH
54054: LD_EXP 147
54058: PUSH
54059: LD_VAR 0 2
54063: ARRAY
54064: PUSH
54065: LD_INT 3
54067: LESS
54068: AND
54069: IFFALSE 54127
// begin SetTag ( j , 121 ) ;
54071: LD_VAR 0 3
54075: PPUSH
54076: LD_INT 121
54078: PPUSH
54079: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54083: LD_ADDR_EXP 147
54087: PUSH
54088: LD_EXP 147
54092: PPUSH
54093: LD_VAR 0 2
54097: PUSH
54098: LD_EXP 147
54102: PUSH
54103: LD_VAR 0 2
54107: ARRAY
54108: PUSH
54109: LD_INT 1
54111: PLUS
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PPUSH
54117: LD_VAR 0 3
54121: PPUSH
54122: CALL 70458 0 3
54126: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54127: LD_VAR 0 3
54131: PUSH
54132: LD_EXP 147
54136: PUSH
54137: LD_VAR 0 2
54141: ARRAY
54142: IN
54143: IFFALSE 54368
// begin if GetClass ( j ) <> 4 then
54145: LD_VAR 0 3
54149: PPUSH
54150: CALL_OW 257
54154: PUSH
54155: LD_INT 4
54157: NONEQUAL
54158: IFFALSE 54211
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54160: LD_ADDR_EXP 147
54164: PUSH
54165: LD_EXP 147
54169: PPUSH
54170: LD_VAR 0 2
54174: PPUSH
54175: LD_EXP 147
54179: PUSH
54180: LD_VAR 0 2
54184: ARRAY
54185: PUSH
54186: LD_VAR 0 3
54190: DIFF
54191: PPUSH
54192: CALL_OW 1
54196: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54197: LD_VAR 0 3
54201: PPUSH
54202: LD_INT 0
54204: PPUSH
54205: CALL_OW 109
// continue ;
54209: GO 54033
// end ; if IsInUnit ( j ) then
54211: LD_VAR 0 3
54215: PPUSH
54216: CALL_OW 310
54220: IFFALSE 54231
// ComExitBuilding ( j ) ;
54222: LD_VAR 0 3
54226: PPUSH
54227: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54231: LD_ADDR_VAR 0 6
54235: PUSH
54236: LD_VAR 0 7
54240: PPUSH
54241: LD_VAR 0 3
54245: PPUSH
54246: CALL_OW 74
54250: ST_TO_ADDR
// if not ape then
54251: LD_VAR 0 6
54255: NOT
54256: IFFALSE 54260
// break ;
54258: GO 54370
// x := GetX ( ape ) ;
54260: LD_ADDR_VAR 0 4
54264: PUSH
54265: LD_VAR 0 6
54269: PPUSH
54270: CALL_OW 250
54274: ST_TO_ADDR
// y := GetY ( ape ) ;
54275: LD_ADDR_VAR 0 5
54279: PUSH
54280: LD_VAR 0 6
54284: PPUSH
54285: CALL_OW 251
54289: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54290: LD_VAR 0 4
54294: PPUSH
54295: LD_VAR 0 5
54299: PPUSH
54300: CALL_OW 488
54304: NOT
54305: PUSH
54306: LD_VAR 0 11
54310: PPUSH
54311: LD_VAR 0 4
54315: PPUSH
54316: LD_VAR 0 5
54320: PPUSH
54321: LD_INT 20
54323: PPUSH
54324: CALL 71354 0 4
54328: PUSH
54329: LD_INT 4
54331: ARRAY
54332: OR
54333: IFFALSE 54337
// break ;
54335: GO 54370
// if not HasTask ( j ) then
54337: LD_VAR 0 3
54341: PPUSH
54342: CALL_OW 314
54346: NOT
54347: IFFALSE 54368
// ComTameXY ( j , x , y ) ;
54349: LD_VAR 0 3
54353: PPUSH
54354: LD_VAR 0 4
54358: PPUSH
54359: LD_VAR 0 5
54363: PPUSH
54364: CALL_OW 131
// end ; end ;
54368: GO 54033
54370: POP
54371: POP
// end ;
54372: GO 53589
54374: POP
54375: POP
// end ;
54376: LD_VAR 0 1
54380: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54381: LD_INT 0
54383: PPUSH
54384: PPUSH
54385: PPUSH
54386: PPUSH
54387: PPUSH
54388: PPUSH
54389: PPUSH
54390: PPUSH
// if not mc_bases then
54391: LD_EXP 116
54395: NOT
54396: IFFALSE 54400
// exit ;
54398: GO 55026
// for i = 1 to mc_bases do
54400: LD_ADDR_VAR 0 2
54404: PUSH
54405: DOUBLE
54406: LD_INT 1
54408: DEC
54409: ST_TO_ADDR
54410: LD_EXP 116
54414: PUSH
54415: FOR_TO
54416: IFFALSE 55024
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54418: LD_EXP 145
54422: PUSH
54423: LD_VAR 0 2
54427: ARRAY
54428: NOT
54429: PUSH
54430: LD_EXP 145
54434: PUSH
54435: LD_VAR 0 2
54439: ARRAY
54440: PPUSH
54441: LD_INT 25
54443: PUSH
54444: LD_INT 12
54446: PUSH
54447: EMPTY
54448: LIST
54449: LIST
54450: PPUSH
54451: CALL_OW 72
54455: NOT
54456: OR
54457: IFFALSE 54461
// continue ;
54459: GO 54415
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54461: LD_ADDR_VAR 0 5
54465: PUSH
54466: LD_EXP 145
54470: PUSH
54471: LD_VAR 0 2
54475: ARRAY
54476: PUSH
54477: LD_INT 1
54479: ARRAY
54480: PPUSH
54481: CALL_OW 255
54485: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54486: LD_VAR 0 5
54490: PPUSH
54491: LD_INT 2
54493: PPUSH
54494: CALL_OW 325
54498: IFFALSE 54751
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54500: LD_ADDR_VAR 0 4
54504: PUSH
54505: LD_EXP 145
54509: PUSH
54510: LD_VAR 0 2
54514: ARRAY
54515: PPUSH
54516: LD_INT 25
54518: PUSH
54519: LD_INT 16
54521: PUSH
54522: EMPTY
54523: LIST
54524: LIST
54525: PPUSH
54526: CALL_OW 72
54530: ST_TO_ADDR
// if tmp < 6 then
54531: LD_VAR 0 4
54535: PUSH
54536: LD_INT 6
54538: LESS
54539: IFFALSE 54751
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54541: LD_ADDR_VAR 0 6
54545: PUSH
54546: LD_EXP 116
54550: PUSH
54551: LD_VAR 0 2
54555: ARRAY
54556: PPUSH
54557: LD_INT 2
54559: PUSH
54560: LD_INT 30
54562: PUSH
54563: LD_INT 0
54565: PUSH
54566: EMPTY
54567: LIST
54568: LIST
54569: PUSH
54570: LD_INT 30
54572: PUSH
54573: LD_INT 1
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: PUSH
54580: EMPTY
54581: LIST
54582: LIST
54583: LIST
54584: PPUSH
54585: CALL_OW 72
54589: ST_TO_ADDR
// if depot then
54590: LD_VAR 0 6
54594: IFFALSE 54751
// begin selected := 0 ;
54596: LD_ADDR_VAR 0 7
54600: PUSH
54601: LD_INT 0
54603: ST_TO_ADDR
// for j in depot do
54604: LD_ADDR_VAR 0 3
54608: PUSH
54609: LD_VAR 0 6
54613: PUSH
54614: FOR_IN
54615: IFFALSE 54646
// begin if UnitsInside ( j ) < 6 then
54617: LD_VAR 0 3
54621: PPUSH
54622: CALL_OW 313
54626: PUSH
54627: LD_INT 6
54629: LESS
54630: IFFALSE 54644
// begin selected := j ;
54632: LD_ADDR_VAR 0 7
54636: PUSH
54637: LD_VAR 0 3
54641: ST_TO_ADDR
// break ;
54642: GO 54646
// end ; end ;
54644: GO 54614
54646: POP
54647: POP
// if selected then
54648: LD_VAR 0 7
54652: IFFALSE 54751
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54654: LD_ADDR_VAR 0 3
54658: PUSH
54659: LD_EXP 145
54663: PUSH
54664: LD_VAR 0 2
54668: ARRAY
54669: PPUSH
54670: LD_INT 25
54672: PUSH
54673: LD_INT 12
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: PPUSH
54680: CALL_OW 72
54684: PUSH
54685: FOR_IN
54686: IFFALSE 54749
// if not HasTask ( j ) then
54688: LD_VAR 0 3
54692: PPUSH
54693: CALL_OW 314
54697: NOT
54698: IFFALSE 54747
// begin if not IsInUnit ( j ) then
54700: LD_VAR 0 3
54704: PPUSH
54705: CALL_OW 310
54709: NOT
54710: IFFALSE 54726
// ComEnterUnit ( j , selected ) ;
54712: LD_VAR 0 3
54716: PPUSH
54717: LD_VAR 0 7
54721: PPUSH
54722: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54726: LD_VAR 0 3
54730: PPUSH
54731: LD_INT 16
54733: PPUSH
54734: CALL_OW 183
// AddComExitBuilding ( j ) ;
54738: LD_VAR 0 3
54742: PPUSH
54743: CALL_OW 182
// end ;
54747: GO 54685
54749: POP
54750: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54751: LD_VAR 0 5
54755: PPUSH
54756: LD_INT 11
54758: PPUSH
54759: CALL_OW 325
54763: IFFALSE 55022
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54765: LD_ADDR_VAR 0 4
54769: PUSH
54770: LD_EXP 145
54774: PUSH
54775: LD_VAR 0 2
54779: ARRAY
54780: PPUSH
54781: LD_INT 25
54783: PUSH
54784: LD_INT 16
54786: PUSH
54787: EMPTY
54788: LIST
54789: LIST
54790: PPUSH
54791: CALL_OW 72
54795: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54796: LD_VAR 0 4
54800: PUSH
54801: LD_INT 6
54803: GREATEREQUAL
54804: PUSH
54805: LD_VAR 0 5
54809: PPUSH
54810: LD_INT 2
54812: PPUSH
54813: CALL_OW 325
54817: NOT
54818: OR
54819: IFFALSE 55022
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54821: LD_ADDR_VAR 0 8
54825: PUSH
54826: LD_EXP 116
54830: PUSH
54831: LD_VAR 0 2
54835: ARRAY
54836: PPUSH
54837: LD_INT 2
54839: PUSH
54840: LD_INT 30
54842: PUSH
54843: LD_INT 4
54845: PUSH
54846: EMPTY
54847: LIST
54848: LIST
54849: PUSH
54850: LD_INT 30
54852: PUSH
54853: LD_INT 5
54855: PUSH
54856: EMPTY
54857: LIST
54858: LIST
54859: PUSH
54860: EMPTY
54861: LIST
54862: LIST
54863: LIST
54864: PPUSH
54865: CALL_OW 72
54869: ST_TO_ADDR
// if barracks then
54870: LD_VAR 0 8
54874: IFFALSE 55022
// begin selected := 0 ;
54876: LD_ADDR_VAR 0 7
54880: PUSH
54881: LD_INT 0
54883: ST_TO_ADDR
// for j in barracks do
54884: LD_ADDR_VAR 0 3
54888: PUSH
54889: LD_VAR 0 8
54893: PUSH
54894: FOR_IN
54895: IFFALSE 54926
// begin if UnitsInside ( j ) < 6 then
54897: LD_VAR 0 3
54901: PPUSH
54902: CALL_OW 313
54906: PUSH
54907: LD_INT 6
54909: LESS
54910: IFFALSE 54924
// begin selected := j ;
54912: LD_ADDR_VAR 0 7
54916: PUSH
54917: LD_VAR 0 3
54921: ST_TO_ADDR
// break ;
54922: GO 54926
// end ; end ;
54924: GO 54894
54926: POP
54927: POP
// if selected then
54928: LD_VAR 0 7
54932: IFFALSE 55022
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54934: LD_ADDR_VAR 0 3
54938: PUSH
54939: LD_EXP 145
54943: PUSH
54944: LD_VAR 0 2
54948: ARRAY
54949: PPUSH
54950: LD_INT 25
54952: PUSH
54953: LD_INT 12
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: PPUSH
54960: CALL_OW 72
54964: PUSH
54965: FOR_IN
54966: IFFALSE 55020
// if not IsInUnit ( j ) and not HasTask ( j ) then
54968: LD_VAR 0 3
54972: PPUSH
54973: CALL_OW 310
54977: NOT
54978: PUSH
54979: LD_VAR 0 3
54983: PPUSH
54984: CALL_OW 314
54988: NOT
54989: AND
54990: IFFALSE 55018
// begin ComEnterUnit ( j , selected ) ;
54992: LD_VAR 0 3
54996: PPUSH
54997: LD_VAR 0 7
55001: PPUSH
55002: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55006: LD_VAR 0 3
55010: PPUSH
55011: LD_INT 15
55013: PPUSH
55014: CALL_OW 183
// end ;
55018: GO 54965
55020: POP
55021: POP
// end ; end ; end ; end ; end ;
55022: GO 54415
55024: POP
55025: POP
// end ;
55026: LD_VAR 0 1
55030: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55031: LD_INT 0
55033: PPUSH
55034: PPUSH
55035: PPUSH
55036: PPUSH
// if not mc_bases then
55037: LD_EXP 116
55041: NOT
55042: IFFALSE 55046
// exit ;
55044: GO 55224
// for i = 1 to mc_bases do
55046: LD_ADDR_VAR 0 2
55050: PUSH
55051: DOUBLE
55052: LD_INT 1
55054: DEC
55055: ST_TO_ADDR
55056: LD_EXP 116
55060: PUSH
55061: FOR_TO
55062: IFFALSE 55222
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55064: LD_ADDR_VAR 0 4
55068: PUSH
55069: LD_EXP 116
55073: PUSH
55074: LD_VAR 0 2
55078: ARRAY
55079: PPUSH
55080: LD_INT 25
55082: PUSH
55083: LD_INT 9
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: PPUSH
55090: CALL_OW 72
55094: ST_TO_ADDR
// if not tmp then
55095: LD_VAR 0 4
55099: NOT
55100: IFFALSE 55104
// continue ;
55102: GO 55061
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55104: LD_EXP 142
55108: PUSH
55109: LD_VAR 0 2
55113: ARRAY
55114: PPUSH
55115: LD_INT 29
55117: PPUSH
55118: CALL_OW 325
55122: NOT
55123: PUSH
55124: LD_EXP 142
55128: PUSH
55129: LD_VAR 0 2
55133: ARRAY
55134: PPUSH
55135: LD_INT 28
55137: PPUSH
55138: CALL_OW 325
55142: NOT
55143: AND
55144: IFFALSE 55148
// continue ;
55146: GO 55061
// for j in tmp do
55148: LD_ADDR_VAR 0 3
55152: PUSH
55153: LD_VAR 0 4
55157: PUSH
55158: FOR_IN
55159: IFFALSE 55218
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55161: LD_VAR 0 3
55165: PUSH
55166: LD_EXP 119
55170: PUSH
55171: LD_VAR 0 2
55175: ARRAY
55176: PUSH
55177: LD_INT 1
55179: ARRAY
55180: IN
55181: NOT
55182: PUSH
55183: LD_VAR 0 3
55187: PUSH
55188: LD_EXP 119
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PUSH
55199: LD_INT 2
55201: ARRAY
55202: IN
55203: NOT
55204: AND
55205: IFFALSE 55216
// ComSpaceTimeShoot ( j ) ;
55207: LD_VAR 0 3
55211: PPUSH
55212: CALL 66419 0 1
55216: GO 55158
55218: POP
55219: POP
// end ;
55220: GO 55061
55222: POP
55223: POP
// end ;
55224: LD_VAR 0 1
55228: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55229: LD_INT 0
55231: PPUSH
55232: PPUSH
55233: PPUSH
55234: PPUSH
55235: PPUSH
55236: PPUSH
55237: PPUSH
55238: PPUSH
55239: PPUSH
// if not mc_bases then
55240: LD_EXP 116
55244: NOT
55245: IFFALSE 55249
// exit ;
55247: GO 55871
// for i = 1 to mc_bases do
55249: LD_ADDR_VAR 0 2
55253: PUSH
55254: DOUBLE
55255: LD_INT 1
55257: DEC
55258: ST_TO_ADDR
55259: LD_EXP 116
55263: PUSH
55264: FOR_TO
55265: IFFALSE 55869
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55267: LD_EXP 151
55271: PUSH
55272: LD_VAR 0 2
55276: ARRAY
55277: NOT
55278: PUSH
55279: LD_INT 38
55281: PPUSH
55282: LD_EXP 142
55286: PUSH
55287: LD_VAR 0 2
55291: ARRAY
55292: PPUSH
55293: CALL_OW 321
55297: PUSH
55298: LD_INT 2
55300: NONEQUAL
55301: OR
55302: IFFALSE 55306
// continue ;
55304: GO 55264
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55306: LD_ADDR_VAR 0 8
55310: PUSH
55311: LD_EXP 116
55315: PUSH
55316: LD_VAR 0 2
55320: ARRAY
55321: PPUSH
55322: LD_INT 30
55324: PUSH
55325: LD_INT 34
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: CALL_OW 72
55336: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55337: LD_ADDR_VAR 0 9
55341: PUSH
55342: LD_EXP 116
55346: PUSH
55347: LD_VAR 0 2
55351: ARRAY
55352: PPUSH
55353: LD_INT 25
55355: PUSH
55356: LD_INT 4
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: PPUSH
55363: CALL_OW 72
55367: PPUSH
55368: LD_INT 0
55370: PPUSH
55371: CALL 99728 0 2
55375: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55376: LD_VAR 0 9
55380: NOT
55381: PUSH
55382: LD_VAR 0 8
55386: NOT
55387: OR
55388: PUSH
55389: LD_EXP 116
55393: PUSH
55394: LD_VAR 0 2
55398: ARRAY
55399: PPUSH
55400: LD_INT 124
55402: PPUSH
55403: CALL 99728 0 2
55407: OR
55408: IFFALSE 55412
// continue ;
55410: GO 55264
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55412: LD_EXP 152
55416: PUSH
55417: LD_VAR 0 2
55421: ARRAY
55422: PUSH
55423: LD_EXP 151
55427: PUSH
55428: LD_VAR 0 2
55432: ARRAY
55433: LESS
55434: PUSH
55435: LD_EXP 152
55439: PUSH
55440: LD_VAR 0 2
55444: ARRAY
55445: PUSH
55446: LD_VAR 0 8
55450: LESS
55451: AND
55452: IFFALSE 55867
// begin tmp := sci [ 1 ] ;
55454: LD_ADDR_VAR 0 7
55458: PUSH
55459: LD_VAR 0 9
55463: PUSH
55464: LD_INT 1
55466: ARRAY
55467: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55468: LD_VAR 0 7
55472: PPUSH
55473: LD_INT 124
55475: PPUSH
55476: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55480: LD_ADDR_VAR 0 3
55484: PUSH
55485: DOUBLE
55486: LD_EXP 151
55490: PUSH
55491: LD_VAR 0 2
55495: ARRAY
55496: INC
55497: ST_TO_ADDR
55498: LD_EXP 151
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: PUSH
55509: FOR_DOWNTO
55510: IFFALSE 55853
// begin if IsInUnit ( tmp ) then
55512: LD_VAR 0 7
55516: PPUSH
55517: CALL_OW 310
55521: IFFALSE 55532
// ComExitBuilding ( tmp ) ;
55523: LD_VAR 0 7
55527: PPUSH
55528: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55532: LD_INT 35
55534: PPUSH
55535: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55539: LD_VAR 0 7
55543: PPUSH
55544: CALL_OW 310
55548: NOT
55549: PUSH
55550: LD_VAR 0 7
55554: PPUSH
55555: CALL_OW 314
55559: NOT
55560: AND
55561: IFFALSE 55532
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55563: LD_ADDR_VAR 0 6
55567: PUSH
55568: LD_VAR 0 7
55572: PPUSH
55573: CALL_OW 250
55577: PUSH
55578: LD_VAR 0 7
55582: PPUSH
55583: CALL_OW 251
55587: PUSH
55588: EMPTY
55589: LIST
55590: LIST
55591: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55592: LD_INT 35
55594: PPUSH
55595: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55599: LD_ADDR_VAR 0 4
55603: PUSH
55604: LD_EXP 151
55608: PUSH
55609: LD_VAR 0 2
55613: ARRAY
55614: PUSH
55615: LD_VAR 0 3
55619: ARRAY
55620: PUSH
55621: LD_INT 1
55623: ARRAY
55624: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55625: LD_ADDR_VAR 0 5
55629: PUSH
55630: LD_EXP 151
55634: PUSH
55635: LD_VAR 0 2
55639: ARRAY
55640: PUSH
55641: LD_VAR 0 3
55645: ARRAY
55646: PUSH
55647: LD_INT 2
55649: ARRAY
55650: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55651: LD_VAR 0 7
55655: PPUSH
55656: LD_INT 10
55658: PPUSH
55659: CALL 73057 0 2
55663: PUSH
55664: LD_INT 4
55666: ARRAY
55667: IFFALSE 55705
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55669: LD_VAR 0 7
55673: PPUSH
55674: LD_VAR 0 6
55678: PUSH
55679: LD_INT 1
55681: ARRAY
55682: PPUSH
55683: LD_VAR 0 6
55687: PUSH
55688: LD_INT 2
55690: ARRAY
55691: PPUSH
55692: CALL_OW 111
// wait ( 0 0$10 ) ;
55696: LD_INT 350
55698: PPUSH
55699: CALL_OW 67
// end else
55703: GO 55731
// begin ComMoveXY ( tmp , x , y ) ;
55705: LD_VAR 0 7
55709: PPUSH
55710: LD_VAR 0 4
55714: PPUSH
55715: LD_VAR 0 5
55719: PPUSH
55720: CALL_OW 111
// wait ( 0 0$3 ) ;
55724: LD_INT 105
55726: PPUSH
55727: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55731: LD_VAR 0 7
55735: PPUSH
55736: LD_VAR 0 4
55740: PPUSH
55741: LD_VAR 0 5
55745: PPUSH
55746: CALL_OW 307
55750: IFFALSE 55592
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55752: LD_VAR 0 7
55756: PPUSH
55757: LD_VAR 0 4
55761: PPUSH
55762: LD_VAR 0 5
55766: PPUSH
55767: LD_VAR 0 8
55771: PUSH
55772: LD_VAR 0 3
55776: ARRAY
55777: PPUSH
55778: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55782: LD_INT 35
55784: PPUSH
55785: CALL_OW 67
// until not HasTask ( tmp ) ;
55789: LD_VAR 0 7
55793: PPUSH
55794: CALL_OW 314
55798: NOT
55799: IFFALSE 55782
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55801: LD_ADDR_EXP 152
55805: PUSH
55806: LD_EXP 152
55810: PPUSH
55811: LD_VAR 0 2
55815: PUSH
55816: LD_EXP 152
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: PUSH
55827: LD_INT 1
55829: PLUS
55830: PUSH
55831: EMPTY
55832: LIST
55833: LIST
55834: PPUSH
55835: LD_VAR 0 8
55839: PUSH
55840: LD_VAR 0 3
55844: ARRAY
55845: PPUSH
55846: CALL 70458 0 3
55850: ST_TO_ADDR
// end ;
55851: GO 55509
55853: POP
55854: POP
// MC_Reset ( i , 124 ) ;
55855: LD_VAR 0 2
55859: PPUSH
55860: LD_INT 124
55862: PPUSH
55863: CALL 39310 0 2
// end ; end ;
55867: GO 55264
55869: POP
55870: POP
// end ;
55871: LD_VAR 0 1
55875: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55876: LD_INT 0
55878: PPUSH
55879: PPUSH
55880: PPUSH
// if not mc_bases then
55881: LD_EXP 116
55885: NOT
55886: IFFALSE 55890
// exit ;
55888: GO 56496
// for i = 1 to mc_bases do
55890: LD_ADDR_VAR 0 2
55894: PUSH
55895: DOUBLE
55896: LD_INT 1
55898: DEC
55899: ST_TO_ADDR
55900: LD_EXP 116
55904: PUSH
55905: FOR_TO
55906: IFFALSE 56494
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55908: LD_ADDR_VAR 0 3
55912: PUSH
55913: LD_EXP 116
55917: PUSH
55918: LD_VAR 0 2
55922: ARRAY
55923: PPUSH
55924: LD_INT 25
55926: PUSH
55927: LD_INT 4
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: PPUSH
55934: CALL_OW 72
55938: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55939: LD_VAR 0 3
55943: NOT
55944: PUSH
55945: LD_EXP 153
55949: PUSH
55950: LD_VAR 0 2
55954: ARRAY
55955: NOT
55956: OR
55957: PUSH
55958: LD_EXP 116
55962: PUSH
55963: LD_VAR 0 2
55967: ARRAY
55968: PPUSH
55969: LD_INT 2
55971: PUSH
55972: LD_INT 30
55974: PUSH
55975: LD_INT 0
55977: PUSH
55978: EMPTY
55979: LIST
55980: LIST
55981: PUSH
55982: LD_INT 30
55984: PUSH
55985: LD_INT 1
55987: PUSH
55988: EMPTY
55989: LIST
55990: LIST
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: LIST
55996: PPUSH
55997: CALL_OW 72
56001: NOT
56002: OR
56003: IFFALSE 56053
// begin if mc_deposits_finder [ i ] then
56005: LD_EXP 154
56009: PUSH
56010: LD_VAR 0 2
56014: ARRAY
56015: IFFALSE 56051
// begin MC_Reset ( i , 125 ) ;
56017: LD_VAR 0 2
56021: PPUSH
56022: LD_INT 125
56024: PPUSH
56025: CALL 39310 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56029: LD_ADDR_EXP 154
56033: PUSH
56034: LD_EXP 154
56038: PPUSH
56039: LD_VAR 0 2
56043: PPUSH
56044: EMPTY
56045: PPUSH
56046: CALL_OW 1
56050: ST_TO_ADDR
// end ; continue ;
56051: GO 55905
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56053: LD_EXP 153
56057: PUSH
56058: LD_VAR 0 2
56062: ARRAY
56063: PUSH
56064: LD_INT 1
56066: ARRAY
56067: PUSH
56068: LD_INT 3
56070: ARRAY
56071: PUSH
56072: LD_INT 1
56074: EQUAL
56075: PUSH
56076: LD_INT 20
56078: PPUSH
56079: LD_EXP 142
56083: PUSH
56084: LD_VAR 0 2
56088: ARRAY
56089: PPUSH
56090: CALL_OW 321
56094: PUSH
56095: LD_INT 2
56097: NONEQUAL
56098: AND
56099: IFFALSE 56149
// begin if mc_deposits_finder [ i ] then
56101: LD_EXP 154
56105: PUSH
56106: LD_VAR 0 2
56110: ARRAY
56111: IFFALSE 56147
// begin MC_Reset ( i , 125 ) ;
56113: LD_VAR 0 2
56117: PPUSH
56118: LD_INT 125
56120: PPUSH
56121: CALL 39310 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56125: LD_ADDR_EXP 154
56129: PUSH
56130: LD_EXP 154
56134: PPUSH
56135: LD_VAR 0 2
56139: PPUSH
56140: EMPTY
56141: PPUSH
56142: CALL_OW 1
56146: ST_TO_ADDR
// end ; continue ;
56147: GO 55905
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56149: LD_EXP 153
56153: PUSH
56154: LD_VAR 0 2
56158: ARRAY
56159: PUSH
56160: LD_INT 1
56162: ARRAY
56163: PUSH
56164: LD_INT 1
56166: ARRAY
56167: PPUSH
56168: LD_EXP 153
56172: PUSH
56173: LD_VAR 0 2
56177: ARRAY
56178: PUSH
56179: LD_INT 1
56181: ARRAY
56182: PUSH
56183: LD_INT 2
56185: ARRAY
56186: PPUSH
56187: LD_EXP 142
56191: PUSH
56192: LD_VAR 0 2
56196: ARRAY
56197: PPUSH
56198: CALL_OW 440
56202: IFFALSE 56245
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56204: LD_ADDR_EXP 153
56208: PUSH
56209: LD_EXP 153
56213: PPUSH
56214: LD_VAR 0 2
56218: PPUSH
56219: LD_EXP 153
56223: PUSH
56224: LD_VAR 0 2
56228: ARRAY
56229: PPUSH
56230: LD_INT 1
56232: PPUSH
56233: CALL_OW 3
56237: PPUSH
56238: CALL_OW 1
56242: ST_TO_ADDR
56243: GO 56492
// begin if not mc_deposits_finder [ i ] then
56245: LD_EXP 154
56249: PUSH
56250: LD_VAR 0 2
56254: ARRAY
56255: NOT
56256: IFFALSE 56308
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56258: LD_ADDR_EXP 154
56262: PUSH
56263: LD_EXP 154
56267: PPUSH
56268: LD_VAR 0 2
56272: PPUSH
56273: LD_VAR 0 3
56277: PUSH
56278: LD_INT 1
56280: ARRAY
56281: PUSH
56282: EMPTY
56283: LIST
56284: PPUSH
56285: CALL_OW 1
56289: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56290: LD_VAR 0 3
56294: PUSH
56295: LD_INT 1
56297: ARRAY
56298: PPUSH
56299: LD_INT 125
56301: PPUSH
56302: CALL_OW 109
// end else
56306: GO 56492
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56308: LD_EXP 154
56312: PUSH
56313: LD_VAR 0 2
56317: ARRAY
56318: PUSH
56319: LD_INT 1
56321: ARRAY
56322: PPUSH
56323: CALL_OW 310
56327: IFFALSE 56350
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56329: LD_EXP 154
56333: PUSH
56334: LD_VAR 0 2
56338: ARRAY
56339: PUSH
56340: LD_INT 1
56342: ARRAY
56343: PPUSH
56344: CALL_OW 122
56348: GO 56492
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56350: LD_EXP 154
56354: PUSH
56355: LD_VAR 0 2
56359: ARRAY
56360: PUSH
56361: LD_INT 1
56363: ARRAY
56364: PPUSH
56365: CALL_OW 314
56369: NOT
56370: PUSH
56371: LD_EXP 154
56375: PUSH
56376: LD_VAR 0 2
56380: ARRAY
56381: PUSH
56382: LD_INT 1
56384: ARRAY
56385: PPUSH
56386: LD_EXP 153
56390: PUSH
56391: LD_VAR 0 2
56395: ARRAY
56396: PUSH
56397: LD_INT 1
56399: ARRAY
56400: PUSH
56401: LD_INT 1
56403: ARRAY
56404: PPUSH
56405: LD_EXP 153
56409: PUSH
56410: LD_VAR 0 2
56414: ARRAY
56415: PUSH
56416: LD_INT 1
56418: ARRAY
56419: PUSH
56420: LD_INT 2
56422: ARRAY
56423: PPUSH
56424: CALL_OW 297
56428: PUSH
56429: LD_INT 6
56431: GREATER
56432: AND
56433: IFFALSE 56492
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56435: LD_EXP 154
56439: PUSH
56440: LD_VAR 0 2
56444: ARRAY
56445: PUSH
56446: LD_INT 1
56448: ARRAY
56449: PPUSH
56450: LD_EXP 153
56454: PUSH
56455: LD_VAR 0 2
56459: ARRAY
56460: PUSH
56461: LD_INT 1
56463: ARRAY
56464: PUSH
56465: LD_INT 1
56467: ARRAY
56468: PPUSH
56469: LD_EXP 153
56473: PUSH
56474: LD_VAR 0 2
56478: ARRAY
56479: PUSH
56480: LD_INT 1
56482: ARRAY
56483: PUSH
56484: LD_INT 2
56486: ARRAY
56487: PPUSH
56488: CALL_OW 111
// end ; end ; end ;
56492: GO 55905
56494: POP
56495: POP
// end ;
56496: LD_VAR 0 1
56500: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56501: LD_INT 0
56503: PPUSH
56504: PPUSH
56505: PPUSH
56506: PPUSH
56507: PPUSH
56508: PPUSH
56509: PPUSH
56510: PPUSH
56511: PPUSH
56512: PPUSH
56513: PPUSH
// if not mc_bases then
56514: LD_EXP 116
56518: NOT
56519: IFFALSE 56523
// exit ;
56521: GO 57463
// for i = 1 to mc_bases do
56523: LD_ADDR_VAR 0 2
56527: PUSH
56528: DOUBLE
56529: LD_INT 1
56531: DEC
56532: ST_TO_ADDR
56533: LD_EXP 116
56537: PUSH
56538: FOR_TO
56539: IFFALSE 57461
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56541: LD_EXP 116
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: NOT
56552: PUSH
56553: LD_EXP 139
56557: PUSH
56558: LD_VAR 0 2
56562: ARRAY
56563: OR
56564: IFFALSE 56568
// continue ;
56566: GO 56538
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56568: LD_ADDR_VAR 0 7
56572: PUSH
56573: LD_EXP 116
56577: PUSH
56578: LD_VAR 0 2
56582: ARRAY
56583: PUSH
56584: LD_INT 1
56586: ARRAY
56587: PPUSH
56588: CALL_OW 248
56592: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56593: LD_VAR 0 7
56597: PUSH
56598: LD_INT 3
56600: EQUAL
56601: PUSH
56602: LD_EXP 135
56606: PUSH
56607: LD_VAR 0 2
56611: ARRAY
56612: PUSH
56613: LD_EXP 138
56617: PUSH
56618: LD_VAR 0 2
56622: ARRAY
56623: UNION
56624: PPUSH
56625: LD_INT 33
56627: PUSH
56628: LD_INT 2
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: PPUSH
56635: CALL_OW 72
56639: NOT
56640: OR
56641: IFFALSE 56645
// continue ;
56643: GO 56538
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56645: LD_ADDR_VAR 0 9
56649: PUSH
56650: LD_EXP 116
56654: PUSH
56655: LD_VAR 0 2
56659: ARRAY
56660: PPUSH
56661: LD_INT 30
56663: PUSH
56664: LD_INT 36
56666: PUSH
56667: EMPTY
56668: LIST
56669: LIST
56670: PPUSH
56671: CALL_OW 72
56675: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56676: LD_ADDR_VAR 0 10
56680: PUSH
56681: LD_EXP 135
56685: PUSH
56686: LD_VAR 0 2
56690: ARRAY
56691: PPUSH
56692: LD_INT 34
56694: PUSH
56695: LD_INT 31
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: PPUSH
56702: CALL_OW 72
56706: ST_TO_ADDR
// if not cts and not mcts then
56707: LD_VAR 0 9
56711: NOT
56712: PUSH
56713: LD_VAR 0 10
56717: NOT
56718: AND
56719: IFFALSE 56723
// continue ;
56721: GO 56538
// x := cts ;
56723: LD_ADDR_VAR 0 11
56727: PUSH
56728: LD_VAR 0 9
56732: ST_TO_ADDR
// if not x then
56733: LD_VAR 0 11
56737: NOT
56738: IFFALSE 56750
// x := mcts ;
56740: LD_ADDR_VAR 0 11
56744: PUSH
56745: LD_VAR 0 10
56749: ST_TO_ADDR
// if not x then
56750: LD_VAR 0 11
56754: NOT
56755: IFFALSE 56759
// continue ;
56757: GO 56538
// if mc_remote_driver [ i ] then
56759: LD_EXP 156
56763: PUSH
56764: LD_VAR 0 2
56768: ARRAY
56769: IFFALSE 57156
// for j in mc_remote_driver [ i ] do
56771: LD_ADDR_VAR 0 3
56775: PUSH
56776: LD_EXP 156
56780: PUSH
56781: LD_VAR 0 2
56785: ARRAY
56786: PUSH
56787: FOR_IN
56788: IFFALSE 57154
// begin if GetClass ( j ) <> 3 then
56790: LD_VAR 0 3
56794: PPUSH
56795: CALL_OW 257
56799: PUSH
56800: LD_INT 3
56802: NONEQUAL
56803: IFFALSE 56856
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56805: LD_ADDR_EXP 156
56809: PUSH
56810: LD_EXP 156
56814: PPUSH
56815: LD_VAR 0 2
56819: PPUSH
56820: LD_EXP 156
56824: PUSH
56825: LD_VAR 0 2
56829: ARRAY
56830: PUSH
56831: LD_VAR 0 3
56835: DIFF
56836: PPUSH
56837: CALL_OW 1
56841: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56842: LD_VAR 0 3
56846: PPUSH
56847: LD_INT 0
56849: PPUSH
56850: CALL_OW 109
// continue ;
56854: GO 56787
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56856: LD_EXP 135
56860: PUSH
56861: LD_VAR 0 2
56865: ARRAY
56866: PPUSH
56867: LD_INT 34
56869: PUSH
56870: LD_INT 31
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PUSH
56877: LD_INT 58
56879: PUSH
56880: EMPTY
56881: LIST
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PPUSH
56887: CALL_OW 72
56891: PUSH
56892: LD_VAR 0 3
56896: PPUSH
56897: CALL 99816 0 1
56901: NOT
56902: AND
56903: IFFALSE 56974
// begin if IsInUnit ( j ) then
56905: LD_VAR 0 3
56909: PPUSH
56910: CALL_OW 310
56914: IFFALSE 56925
// ComExitBuilding ( j ) ;
56916: LD_VAR 0 3
56920: PPUSH
56921: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56925: LD_VAR 0 3
56929: PPUSH
56930: LD_EXP 135
56934: PUSH
56935: LD_VAR 0 2
56939: ARRAY
56940: PPUSH
56941: LD_INT 34
56943: PUSH
56944: LD_INT 31
56946: PUSH
56947: EMPTY
56948: LIST
56949: LIST
56950: PUSH
56951: LD_INT 58
56953: PUSH
56954: EMPTY
56955: LIST
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: PPUSH
56961: CALL_OW 72
56965: PUSH
56966: LD_INT 1
56968: ARRAY
56969: PPUSH
56970: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56974: LD_VAR 0 3
56978: PPUSH
56979: CALL_OW 310
56983: NOT
56984: PUSH
56985: LD_VAR 0 3
56989: PPUSH
56990: CALL_OW 310
56994: PPUSH
56995: CALL_OW 266
56999: PUSH
57000: LD_INT 36
57002: NONEQUAL
57003: PUSH
57004: LD_VAR 0 3
57008: PPUSH
57009: CALL 99816 0 1
57013: NOT
57014: AND
57015: OR
57016: IFFALSE 57152
// begin if IsInUnit ( j ) then
57018: LD_VAR 0 3
57022: PPUSH
57023: CALL_OW 310
57027: IFFALSE 57038
// ComExitBuilding ( j ) ;
57029: LD_VAR 0 3
57033: PPUSH
57034: CALL_OW 122
// ct := 0 ;
57038: LD_ADDR_VAR 0 8
57042: PUSH
57043: LD_INT 0
57045: ST_TO_ADDR
// for k in x do
57046: LD_ADDR_VAR 0 4
57050: PUSH
57051: LD_VAR 0 11
57055: PUSH
57056: FOR_IN
57057: IFFALSE 57130
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57059: LD_VAR 0 4
57063: PPUSH
57064: CALL_OW 264
57068: PUSH
57069: LD_INT 31
57071: EQUAL
57072: PUSH
57073: LD_VAR 0 4
57077: PPUSH
57078: CALL_OW 311
57082: NOT
57083: AND
57084: PUSH
57085: LD_VAR 0 4
57089: PPUSH
57090: CALL_OW 266
57094: PUSH
57095: LD_INT 36
57097: EQUAL
57098: PUSH
57099: LD_VAR 0 4
57103: PPUSH
57104: CALL_OW 313
57108: PUSH
57109: LD_INT 3
57111: LESS
57112: AND
57113: OR
57114: IFFALSE 57128
// begin ct := k ;
57116: LD_ADDR_VAR 0 8
57120: PUSH
57121: LD_VAR 0 4
57125: ST_TO_ADDR
// break ;
57126: GO 57130
// end ;
57128: GO 57056
57130: POP
57131: POP
// if ct then
57132: LD_VAR 0 8
57136: IFFALSE 57152
// ComEnterUnit ( j , ct ) ;
57138: LD_VAR 0 3
57142: PPUSH
57143: LD_VAR 0 8
57147: PPUSH
57148: CALL_OW 120
// end ; end ;
57152: GO 56787
57154: POP
57155: POP
// places := 0 ;
57156: LD_ADDR_VAR 0 5
57160: PUSH
57161: LD_INT 0
57163: ST_TO_ADDR
// for j = 1 to x do
57164: LD_ADDR_VAR 0 3
57168: PUSH
57169: DOUBLE
57170: LD_INT 1
57172: DEC
57173: ST_TO_ADDR
57174: LD_VAR 0 11
57178: PUSH
57179: FOR_TO
57180: IFFALSE 57256
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57182: LD_VAR 0 11
57186: PUSH
57187: LD_VAR 0 3
57191: ARRAY
57192: PPUSH
57193: CALL_OW 264
57197: PUSH
57198: LD_INT 31
57200: EQUAL
57201: IFFALSE 57219
// places := places + 1 else
57203: LD_ADDR_VAR 0 5
57207: PUSH
57208: LD_VAR 0 5
57212: PUSH
57213: LD_INT 1
57215: PLUS
57216: ST_TO_ADDR
57217: GO 57254
// if GetBType ( x [ j ] ) = b_control_tower then
57219: LD_VAR 0 11
57223: PUSH
57224: LD_VAR 0 3
57228: ARRAY
57229: PPUSH
57230: CALL_OW 266
57234: PUSH
57235: LD_INT 36
57237: EQUAL
57238: IFFALSE 57254
// places := places + 3 ;
57240: LD_ADDR_VAR 0 5
57244: PUSH
57245: LD_VAR 0 5
57249: PUSH
57250: LD_INT 3
57252: PLUS
57253: ST_TO_ADDR
57254: GO 57179
57256: POP
57257: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57258: LD_VAR 0 5
57262: PUSH
57263: LD_INT 0
57265: EQUAL
57266: PUSH
57267: LD_VAR 0 5
57271: PUSH
57272: LD_EXP 156
57276: PUSH
57277: LD_VAR 0 2
57281: ARRAY
57282: LESSEQUAL
57283: OR
57284: IFFALSE 57288
// continue ;
57286: GO 56538
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57288: LD_ADDR_VAR 0 6
57292: PUSH
57293: LD_EXP 116
57297: PUSH
57298: LD_VAR 0 2
57302: ARRAY
57303: PPUSH
57304: LD_INT 25
57306: PUSH
57307: LD_INT 3
57309: PUSH
57310: EMPTY
57311: LIST
57312: LIST
57313: PPUSH
57314: CALL_OW 72
57318: PUSH
57319: LD_EXP 156
57323: PUSH
57324: LD_VAR 0 2
57328: ARRAY
57329: DIFF
57330: PPUSH
57331: LD_INT 3
57333: PPUSH
57334: CALL 100716 0 2
57338: ST_TO_ADDR
// for j in tmp do
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: LD_VAR 0 6
57348: PUSH
57349: FOR_IN
57350: IFFALSE 57385
// if GetTag ( j ) > 0 then
57352: LD_VAR 0 3
57356: PPUSH
57357: CALL_OW 110
57361: PUSH
57362: LD_INT 0
57364: GREATER
57365: IFFALSE 57383
// tmp := tmp diff j ;
57367: LD_ADDR_VAR 0 6
57371: PUSH
57372: LD_VAR 0 6
57376: PUSH
57377: LD_VAR 0 3
57381: DIFF
57382: ST_TO_ADDR
57383: GO 57349
57385: POP
57386: POP
// if not tmp then
57387: LD_VAR 0 6
57391: NOT
57392: IFFALSE 57396
// continue ;
57394: GO 56538
// if places then
57396: LD_VAR 0 5
57400: IFFALSE 57459
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57402: LD_ADDR_EXP 156
57406: PUSH
57407: LD_EXP 156
57411: PPUSH
57412: LD_VAR 0 2
57416: PPUSH
57417: LD_EXP 156
57421: PUSH
57422: LD_VAR 0 2
57426: ARRAY
57427: PUSH
57428: LD_VAR 0 6
57432: PUSH
57433: LD_INT 1
57435: ARRAY
57436: UNION
57437: PPUSH
57438: CALL_OW 1
57442: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57443: LD_VAR 0 6
57447: PUSH
57448: LD_INT 1
57450: ARRAY
57451: PPUSH
57452: LD_INT 126
57454: PPUSH
57455: CALL_OW 109
// end ; end ;
57459: GO 56538
57461: POP
57462: POP
// end ;
57463: LD_VAR 0 1
57467: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57468: LD_INT 0
57470: PPUSH
57471: PPUSH
57472: PPUSH
57473: PPUSH
57474: PPUSH
57475: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57476: LD_VAR 0 1
57480: NOT
57481: PUSH
57482: LD_VAR 0 2
57486: NOT
57487: OR
57488: PUSH
57489: LD_VAR 0 3
57493: NOT
57494: OR
57495: PUSH
57496: LD_VAR 0 4
57500: PUSH
57501: LD_INT 1
57503: PUSH
57504: LD_INT 2
57506: PUSH
57507: LD_INT 3
57509: PUSH
57510: LD_INT 4
57512: PUSH
57513: LD_INT 5
57515: PUSH
57516: LD_INT 8
57518: PUSH
57519: LD_INT 9
57521: PUSH
57522: LD_INT 15
57524: PUSH
57525: LD_INT 16
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: LIST
57532: LIST
57533: LIST
57534: LIST
57535: LIST
57536: LIST
57537: LIST
57538: IN
57539: NOT
57540: OR
57541: IFFALSE 57545
// exit ;
57543: GO 58445
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57545: LD_ADDR_VAR 0 2
57549: PUSH
57550: LD_VAR 0 2
57554: PPUSH
57555: LD_INT 21
57557: PUSH
57558: LD_INT 3
57560: PUSH
57561: EMPTY
57562: LIST
57563: LIST
57564: PUSH
57565: LD_INT 24
57567: PUSH
57568: LD_INT 250
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: PPUSH
57579: CALL_OW 72
57583: ST_TO_ADDR
// case class of 1 , 15 :
57584: LD_VAR 0 4
57588: PUSH
57589: LD_INT 1
57591: DOUBLE
57592: EQUAL
57593: IFTRUE 57603
57595: LD_INT 15
57597: DOUBLE
57598: EQUAL
57599: IFTRUE 57603
57601: GO 57688
57603: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57604: LD_ADDR_VAR 0 8
57608: PUSH
57609: LD_VAR 0 2
57613: PPUSH
57614: LD_INT 2
57616: PUSH
57617: LD_INT 30
57619: PUSH
57620: LD_INT 32
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PUSH
57627: LD_INT 30
57629: PUSH
57630: LD_INT 31
57632: PUSH
57633: EMPTY
57634: LIST
57635: LIST
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: LIST
57641: PPUSH
57642: CALL_OW 72
57646: PUSH
57647: LD_VAR 0 2
57651: PPUSH
57652: LD_INT 2
57654: PUSH
57655: LD_INT 30
57657: PUSH
57658: LD_INT 4
57660: PUSH
57661: EMPTY
57662: LIST
57663: LIST
57664: PUSH
57665: LD_INT 30
57667: PUSH
57668: LD_INT 5
57670: PUSH
57671: EMPTY
57672: LIST
57673: LIST
57674: PUSH
57675: EMPTY
57676: LIST
57677: LIST
57678: LIST
57679: PPUSH
57680: CALL_OW 72
57684: ADD
57685: ST_TO_ADDR
57686: GO 57934
57688: LD_INT 2
57690: DOUBLE
57691: EQUAL
57692: IFTRUE 57702
57694: LD_INT 16
57696: DOUBLE
57697: EQUAL
57698: IFTRUE 57702
57700: GO 57748
57702: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57703: LD_ADDR_VAR 0 8
57707: PUSH
57708: LD_VAR 0 2
57712: PPUSH
57713: LD_INT 2
57715: PUSH
57716: LD_INT 30
57718: PUSH
57719: LD_INT 0
57721: PUSH
57722: EMPTY
57723: LIST
57724: LIST
57725: PUSH
57726: LD_INT 30
57728: PUSH
57729: LD_INT 1
57731: PUSH
57732: EMPTY
57733: LIST
57734: LIST
57735: PUSH
57736: EMPTY
57737: LIST
57738: LIST
57739: LIST
57740: PPUSH
57741: CALL_OW 72
57745: ST_TO_ADDR
57746: GO 57934
57748: LD_INT 3
57750: DOUBLE
57751: EQUAL
57752: IFTRUE 57756
57754: GO 57802
57756: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57757: LD_ADDR_VAR 0 8
57761: PUSH
57762: LD_VAR 0 2
57766: PPUSH
57767: LD_INT 2
57769: PUSH
57770: LD_INT 30
57772: PUSH
57773: LD_INT 2
57775: PUSH
57776: EMPTY
57777: LIST
57778: LIST
57779: PUSH
57780: LD_INT 30
57782: PUSH
57783: LD_INT 3
57785: PUSH
57786: EMPTY
57787: LIST
57788: LIST
57789: PUSH
57790: EMPTY
57791: LIST
57792: LIST
57793: LIST
57794: PPUSH
57795: CALL_OW 72
57799: ST_TO_ADDR
57800: GO 57934
57802: LD_INT 4
57804: DOUBLE
57805: EQUAL
57806: IFTRUE 57810
57808: GO 57867
57810: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57811: LD_ADDR_VAR 0 8
57815: PUSH
57816: LD_VAR 0 2
57820: PPUSH
57821: LD_INT 2
57823: PUSH
57824: LD_INT 30
57826: PUSH
57827: LD_INT 6
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: PUSH
57834: LD_INT 30
57836: PUSH
57837: LD_INT 7
57839: PUSH
57840: EMPTY
57841: LIST
57842: LIST
57843: PUSH
57844: LD_INT 30
57846: PUSH
57847: LD_INT 8
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: LIST
57858: LIST
57859: PPUSH
57860: CALL_OW 72
57864: ST_TO_ADDR
57865: GO 57934
57867: LD_INT 5
57869: DOUBLE
57870: EQUAL
57871: IFTRUE 57887
57873: LD_INT 8
57875: DOUBLE
57876: EQUAL
57877: IFTRUE 57887
57879: LD_INT 9
57881: DOUBLE
57882: EQUAL
57883: IFTRUE 57887
57885: GO 57933
57887: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57888: LD_ADDR_VAR 0 8
57892: PUSH
57893: LD_VAR 0 2
57897: PPUSH
57898: LD_INT 2
57900: PUSH
57901: LD_INT 30
57903: PUSH
57904: LD_INT 4
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: PUSH
57911: LD_INT 30
57913: PUSH
57914: LD_INT 5
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PUSH
57921: EMPTY
57922: LIST
57923: LIST
57924: LIST
57925: PPUSH
57926: CALL_OW 72
57930: ST_TO_ADDR
57931: GO 57934
57933: POP
// if not tmp then
57934: LD_VAR 0 8
57938: NOT
57939: IFFALSE 57943
// exit ;
57941: GO 58445
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57943: LD_VAR 0 4
57947: PUSH
57948: LD_INT 1
57950: PUSH
57951: LD_INT 15
57953: PUSH
57954: EMPTY
57955: LIST
57956: LIST
57957: IN
57958: PUSH
57959: LD_EXP 125
57963: PUSH
57964: LD_VAR 0 1
57968: ARRAY
57969: AND
57970: IFFALSE 58126
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57972: LD_ADDR_VAR 0 9
57976: PUSH
57977: LD_EXP 125
57981: PUSH
57982: LD_VAR 0 1
57986: ARRAY
57987: PUSH
57988: LD_INT 1
57990: ARRAY
57991: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57992: LD_VAR 0 9
57996: PUSH
57997: LD_EXP 126
58001: PUSH
58002: LD_VAR 0 1
58006: ARRAY
58007: IN
58008: NOT
58009: IFFALSE 58124
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58011: LD_ADDR_EXP 126
58015: PUSH
58016: LD_EXP 126
58020: PPUSH
58021: LD_VAR 0 1
58025: PUSH
58026: LD_EXP 126
58030: PUSH
58031: LD_VAR 0 1
58035: ARRAY
58036: PUSH
58037: LD_INT 1
58039: PLUS
58040: PUSH
58041: EMPTY
58042: LIST
58043: LIST
58044: PPUSH
58045: LD_VAR 0 9
58049: PPUSH
58050: CALL 70458 0 3
58054: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58055: LD_ADDR_EXP 125
58059: PUSH
58060: LD_EXP 125
58064: PPUSH
58065: LD_VAR 0 1
58069: PPUSH
58070: LD_EXP 125
58074: PUSH
58075: LD_VAR 0 1
58079: ARRAY
58080: PUSH
58081: LD_VAR 0 9
58085: DIFF
58086: PPUSH
58087: CALL_OW 1
58091: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58092: LD_VAR 0 3
58096: PPUSH
58097: LD_EXP 126
58101: PUSH
58102: LD_VAR 0 1
58106: ARRAY
58107: PUSH
58108: LD_EXP 126
58112: PUSH
58113: LD_VAR 0 1
58117: ARRAY
58118: ARRAY
58119: PPUSH
58120: CALL_OW 120
// end ; exit ;
58124: GO 58445
// end ; if tmp > 1 then
58126: LD_VAR 0 8
58130: PUSH
58131: LD_INT 1
58133: GREATER
58134: IFFALSE 58238
// for i = 2 to tmp do
58136: LD_ADDR_VAR 0 6
58140: PUSH
58141: DOUBLE
58142: LD_INT 2
58144: DEC
58145: ST_TO_ADDR
58146: LD_VAR 0 8
58150: PUSH
58151: FOR_TO
58152: IFFALSE 58236
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58154: LD_VAR 0 8
58158: PUSH
58159: LD_VAR 0 6
58163: ARRAY
58164: PPUSH
58165: CALL_OW 461
58169: PUSH
58170: LD_INT 6
58172: EQUAL
58173: IFFALSE 58234
// begin x := tmp [ i ] ;
58175: LD_ADDR_VAR 0 9
58179: PUSH
58180: LD_VAR 0 8
58184: PUSH
58185: LD_VAR 0 6
58189: ARRAY
58190: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58191: LD_ADDR_VAR 0 8
58195: PUSH
58196: LD_VAR 0 8
58200: PPUSH
58201: LD_VAR 0 6
58205: PPUSH
58206: CALL_OW 3
58210: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58211: LD_ADDR_VAR 0 8
58215: PUSH
58216: LD_VAR 0 8
58220: PPUSH
58221: LD_INT 1
58223: PPUSH
58224: LD_VAR 0 9
58228: PPUSH
58229: CALL_OW 2
58233: ST_TO_ADDR
// end ;
58234: GO 58151
58236: POP
58237: POP
// for i in tmp do
58238: LD_ADDR_VAR 0 6
58242: PUSH
58243: LD_VAR 0 8
58247: PUSH
58248: FOR_IN
58249: IFFALSE 58318
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58251: LD_VAR 0 6
58255: PPUSH
58256: CALL_OW 313
58260: PUSH
58261: LD_INT 6
58263: LESS
58264: PUSH
58265: LD_VAR 0 6
58269: PPUSH
58270: CALL_OW 266
58274: PUSH
58275: LD_INT 31
58277: PUSH
58278: LD_INT 32
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: IN
58285: NOT
58286: AND
58287: PUSH
58288: LD_VAR 0 6
58292: PPUSH
58293: CALL_OW 313
58297: PUSH
58298: LD_INT 0
58300: EQUAL
58301: OR
58302: IFFALSE 58316
// begin j := i ;
58304: LD_ADDR_VAR 0 7
58308: PUSH
58309: LD_VAR 0 6
58313: ST_TO_ADDR
// break ;
58314: GO 58318
// end ; end ;
58316: GO 58248
58318: POP
58319: POP
// if j then
58320: LD_VAR 0 7
58324: IFFALSE 58342
// ComEnterUnit ( unit , j ) else
58326: LD_VAR 0 3
58330: PPUSH
58331: LD_VAR 0 7
58335: PPUSH
58336: CALL_OW 120
58340: GO 58445
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58342: LD_ADDR_VAR 0 10
58346: PUSH
58347: LD_VAR 0 2
58351: PPUSH
58352: LD_INT 2
58354: PUSH
58355: LD_INT 30
58357: PUSH
58358: LD_INT 0
58360: PUSH
58361: EMPTY
58362: LIST
58363: LIST
58364: PUSH
58365: LD_INT 30
58367: PUSH
58368: LD_INT 1
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PUSH
58375: EMPTY
58376: LIST
58377: LIST
58378: LIST
58379: PPUSH
58380: CALL_OW 72
58384: ST_TO_ADDR
// if depot then
58385: LD_VAR 0 10
58389: IFFALSE 58445
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58391: LD_ADDR_VAR 0 10
58395: PUSH
58396: LD_VAR 0 10
58400: PPUSH
58401: LD_VAR 0 3
58405: PPUSH
58406: CALL_OW 74
58410: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58411: LD_VAR 0 3
58415: PPUSH
58416: LD_VAR 0 10
58420: PPUSH
58421: CALL_OW 296
58425: PUSH
58426: LD_INT 10
58428: GREATER
58429: IFFALSE 58445
// ComStandNearbyBuilding ( unit , depot ) ;
58431: LD_VAR 0 3
58435: PPUSH
58436: LD_VAR 0 10
58440: PPUSH
58441: CALL 67036 0 2
// end ; end ; end ;
58445: LD_VAR 0 5
58449: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58450: LD_INT 0
58452: PPUSH
58453: PPUSH
58454: PPUSH
58455: PPUSH
// if not mc_bases then
58456: LD_EXP 116
58460: NOT
58461: IFFALSE 58465
// exit ;
58463: GO 58704
// for i = 1 to mc_bases do
58465: LD_ADDR_VAR 0 2
58469: PUSH
58470: DOUBLE
58471: LD_INT 1
58473: DEC
58474: ST_TO_ADDR
58475: LD_EXP 116
58479: PUSH
58480: FOR_TO
58481: IFFALSE 58702
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58483: LD_ADDR_VAR 0 4
58487: PUSH
58488: LD_EXP 116
58492: PUSH
58493: LD_VAR 0 2
58497: ARRAY
58498: PPUSH
58499: LD_INT 21
58501: PUSH
58502: LD_INT 1
58504: PUSH
58505: EMPTY
58506: LIST
58507: LIST
58508: PPUSH
58509: CALL_OW 72
58513: PUSH
58514: LD_EXP 145
58518: PUSH
58519: LD_VAR 0 2
58523: ARRAY
58524: UNION
58525: ST_TO_ADDR
// if not tmp then
58526: LD_VAR 0 4
58530: NOT
58531: IFFALSE 58535
// continue ;
58533: GO 58480
// for j in tmp do
58535: LD_ADDR_VAR 0 3
58539: PUSH
58540: LD_VAR 0 4
58544: PUSH
58545: FOR_IN
58546: IFFALSE 58698
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58548: LD_VAR 0 3
58552: PPUSH
58553: CALL_OW 110
58557: NOT
58558: PUSH
58559: LD_VAR 0 3
58563: PPUSH
58564: CALL_OW 314
58568: NOT
58569: AND
58570: PUSH
58571: LD_VAR 0 3
58575: PPUSH
58576: CALL_OW 311
58580: NOT
58581: AND
58582: PUSH
58583: LD_VAR 0 3
58587: PPUSH
58588: CALL_OW 310
58592: NOT
58593: AND
58594: PUSH
58595: LD_VAR 0 3
58599: PUSH
58600: LD_EXP 119
58604: PUSH
58605: LD_VAR 0 2
58609: ARRAY
58610: PUSH
58611: LD_INT 1
58613: ARRAY
58614: IN
58615: NOT
58616: AND
58617: PUSH
58618: LD_VAR 0 3
58622: PUSH
58623: LD_EXP 119
58627: PUSH
58628: LD_VAR 0 2
58632: ARRAY
58633: PUSH
58634: LD_INT 2
58636: ARRAY
58637: IN
58638: NOT
58639: AND
58640: PUSH
58641: LD_VAR 0 3
58645: PUSH
58646: LD_EXP 128
58650: PUSH
58651: LD_VAR 0 2
58655: ARRAY
58656: IN
58657: NOT
58658: AND
58659: IFFALSE 58696
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58661: LD_VAR 0 2
58665: PPUSH
58666: LD_EXP 116
58670: PUSH
58671: LD_VAR 0 2
58675: ARRAY
58676: PPUSH
58677: LD_VAR 0 3
58681: PPUSH
58682: LD_VAR 0 3
58686: PPUSH
58687: CALL_OW 257
58691: PPUSH
58692: CALL 57468 0 4
// end ;
58696: GO 58545
58698: POP
58699: POP
// end ;
58700: GO 58480
58702: POP
58703: POP
// end ;
58704: LD_VAR 0 1
58708: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58709: LD_INT 0
58711: PPUSH
58712: PPUSH
58713: PPUSH
58714: PPUSH
58715: PPUSH
58716: PPUSH
// if not mc_bases [ base ] then
58717: LD_EXP 116
58721: PUSH
58722: LD_VAR 0 1
58726: ARRAY
58727: NOT
58728: IFFALSE 58732
// exit ;
58730: GO 58914
// tmp := [ ] ;
58732: LD_ADDR_VAR 0 6
58736: PUSH
58737: EMPTY
58738: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58739: LD_ADDR_VAR 0 7
58743: PUSH
58744: LD_VAR 0 3
58748: PPUSH
58749: LD_INT 0
58751: PPUSH
58752: CALL_OW 517
58756: ST_TO_ADDR
// if not list then
58757: LD_VAR 0 7
58761: NOT
58762: IFFALSE 58766
// exit ;
58764: GO 58914
// for i = 1 to amount do
58766: LD_ADDR_VAR 0 5
58770: PUSH
58771: DOUBLE
58772: LD_INT 1
58774: DEC
58775: ST_TO_ADDR
58776: LD_VAR 0 2
58780: PUSH
58781: FOR_TO
58782: IFFALSE 58862
// begin x := rand ( 1 , list [ 1 ] ) ;
58784: LD_ADDR_VAR 0 8
58788: PUSH
58789: LD_INT 1
58791: PPUSH
58792: LD_VAR 0 7
58796: PUSH
58797: LD_INT 1
58799: ARRAY
58800: PPUSH
58801: CALL_OW 12
58805: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58806: LD_ADDR_VAR 0 6
58810: PUSH
58811: LD_VAR 0 6
58815: PPUSH
58816: LD_VAR 0 5
58820: PPUSH
58821: LD_VAR 0 7
58825: PUSH
58826: LD_INT 1
58828: ARRAY
58829: PUSH
58830: LD_VAR 0 8
58834: ARRAY
58835: PUSH
58836: LD_VAR 0 7
58840: PUSH
58841: LD_INT 2
58843: ARRAY
58844: PUSH
58845: LD_VAR 0 8
58849: ARRAY
58850: PUSH
58851: EMPTY
58852: LIST
58853: LIST
58854: PPUSH
58855: CALL_OW 1
58859: ST_TO_ADDR
// end ;
58860: GO 58781
58862: POP
58863: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58864: LD_ADDR_EXP 129
58868: PUSH
58869: LD_EXP 129
58873: PPUSH
58874: LD_VAR 0 1
58878: PPUSH
58879: LD_VAR 0 6
58883: PPUSH
58884: CALL_OW 1
58888: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58889: LD_ADDR_EXP 131
58893: PUSH
58894: LD_EXP 131
58898: PPUSH
58899: LD_VAR 0 1
58903: PPUSH
58904: LD_VAR 0 3
58908: PPUSH
58909: CALL_OW 1
58913: ST_TO_ADDR
// end ;
58914: LD_VAR 0 4
58918: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58919: LD_INT 0
58921: PPUSH
// if not mc_bases [ base ] then
58922: LD_EXP 116
58926: PUSH
58927: LD_VAR 0 1
58931: ARRAY
58932: NOT
58933: IFFALSE 58937
// exit ;
58935: GO 58962
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58937: LD_ADDR_EXP 121
58941: PUSH
58942: LD_EXP 121
58946: PPUSH
58947: LD_VAR 0 1
58951: PPUSH
58952: LD_VAR 0 2
58956: PPUSH
58957: CALL_OW 1
58961: ST_TO_ADDR
// end ;
58962: LD_VAR 0 3
58966: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58967: LD_INT 0
58969: PPUSH
// if not mc_bases [ base ] then
58970: LD_EXP 116
58974: PUSH
58975: LD_VAR 0 1
58979: ARRAY
58980: NOT
58981: IFFALSE 58985
// exit ;
58983: GO 59022
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58985: LD_ADDR_EXP 121
58989: PUSH
58990: LD_EXP 121
58994: PPUSH
58995: LD_VAR 0 1
58999: PPUSH
59000: LD_EXP 121
59004: PUSH
59005: LD_VAR 0 1
59009: ARRAY
59010: PUSH
59011: LD_VAR 0 2
59015: UNION
59016: PPUSH
59017: CALL_OW 1
59021: ST_TO_ADDR
// end ;
59022: LD_VAR 0 3
59026: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59027: LD_INT 0
59029: PPUSH
// if not mc_bases [ base ] then
59030: LD_EXP 116
59034: PUSH
59035: LD_VAR 0 1
59039: ARRAY
59040: NOT
59041: IFFALSE 59045
// exit ;
59043: GO 59070
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59045: LD_ADDR_EXP 137
59049: PUSH
59050: LD_EXP 137
59054: PPUSH
59055: LD_VAR 0 1
59059: PPUSH
59060: LD_VAR 0 2
59064: PPUSH
59065: CALL_OW 1
59069: ST_TO_ADDR
// end ;
59070: LD_VAR 0 3
59074: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59075: LD_INT 0
59077: PPUSH
// if not mc_bases [ base ] then
59078: LD_EXP 116
59082: PUSH
59083: LD_VAR 0 1
59087: ARRAY
59088: NOT
59089: IFFALSE 59093
// exit ;
59091: GO 59130
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59093: LD_ADDR_EXP 137
59097: PUSH
59098: LD_EXP 137
59102: PPUSH
59103: LD_VAR 0 1
59107: PPUSH
59108: LD_EXP 137
59112: PUSH
59113: LD_VAR 0 1
59117: ARRAY
59118: PUSH
59119: LD_VAR 0 2
59123: ADD
59124: PPUSH
59125: CALL_OW 1
59129: ST_TO_ADDR
// end ;
59130: LD_VAR 0 3
59134: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59135: LD_INT 0
59137: PPUSH
// if not mc_bases [ base ] then
59138: LD_EXP 116
59142: PUSH
59143: LD_VAR 0 1
59147: ARRAY
59148: NOT
59149: IFFALSE 59153
// exit ;
59151: GO 59207
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59153: LD_ADDR_EXP 138
59157: PUSH
59158: LD_EXP 138
59162: PPUSH
59163: LD_VAR 0 1
59167: PPUSH
59168: LD_VAR 0 2
59172: PPUSH
59173: CALL_OW 1
59177: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59178: LD_ADDR_EXP 127
59182: PUSH
59183: LD_EXP 127
59187: PPUSH
59188: LD_VAR 0 1
59192: PPUSH
59193: LD_VAR 0 2
59197: PUSH
59198: LD_INT 0
59200: PLUS
59201: PPUSH
59202: CALL_OW 1
59206: ST_TO_ADDR
// end ;
59207: LD_VAR 0 3
59211: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59212: LD_INT 0
59214: PPUSH
// if not mc_bases [ base ] then
59215: LD_EXP 116
59219: PUSH
59220: LD_VAR 0 1
59224: ARRAY
59225: NOT
59226: IFFALSE 59230
// exit ;
59228: GO 59255
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59230: LD_ADDR_EXP 127
59234: PUSH
59235: LD_EXP 127
59239: PPUSH
59240: LD_VAR 0 1
59244: PPUSH
59245: LD_VAR 0 2
59249: PPUSH
59250: CALL_OW 1
59254: ST_TO_ADDR
// end ;
59255: LD_VAR 0 3
59259: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59260: LD_INT 0
59262: PPUSH
59263: PPUSH
59264: PPUSH
59265: PPUSH
// if not mc_bases [ base ] then
59266: LD_EXP 116
59270: PUSH
59271: LD_VAR 0 1
59275: ARRAY
59276: NOT
59277: IFFALSE 59281
// exit ;
59279: GO 59346
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59281: LD_ADDR_EXP 136
59285: PUSH
59286: LD_EXP 136
59290: PPUSH
59291: LD_VAR 0 1
59295: PUSH
59296: LD_EXP 136
59300: PUSH
59301: LD_VAR 0 1
59305: ARRAY
59306: PUSH
59307: LD_INT 1
59309: PLUS
59310: PUSH
59311: EMPTY
59312: LIST
59313: LIST
59314: PPUSH
59315: LD_VAR 0 1
59319: PUSH
59320: LD_VAR 0 2
59324: PUSH
59325: LD_VAR 0 3
59329: PUSH
59330: LD_VAR 0 4
59334: PUSH
59335: EMPTY
59336: LIST
59337: LIST
59338: LIST
59339: LIST
59340: PPUSH
59341: CALL 70458 0 3
59345: ST_TO_ADDR
// end ;
59346: LD_VAR 0 5
59350: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59351: LD_INT 0
59353: PPUSH
// if not mc_bases [ base ] then
59354: LD_EXP 116
59358: PUSH
59359: LD_VAR 0 1
59363: ARRAY
59364: NOT
59365: IFFALSE 59369
// exit ;
59367: GO 59394
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59369: LD_ADDR_EXP 153
59373: PUSH
59374: LD_EXP 153
59378: PPUSH
59379: LD_VAR 0 1
59383: PPUSH
59384: LD_VAR 0 2
59388: PPUSH
59389: CALL_OW 1
59393: ST_TO_ADDR
// end ;
59394: LD_VAR 0 3
59398: RET
// export function MC_GetMinesField ( base ) ; begin
59399: LD_INT 0
59401: PPUSH
// result := mc_mines [ base ] ;
59402: LD_ADDR_VAR 0 2
59406: PUSH
59407: LD_EXP 129
59411: PUSH
59412: LD_VAR 0 1
59416: ARRAY
59417: ST_TO_ADDR
// end ;
59418: LD_VAR 0 2
59422: RET
// export function MC_GetProduceList ( base ) ; begin
59423: LD_INT 0
59425: PPUSH
// result := mc_produce [ base ] ;
59426: LD_ADDR_VAR 0 2
59430: PUSH
59431: LD_EXP 137
59435: PUSH
59436: LD_VAR 0 1
59440: ARRAY
59441: ST_TO_ADDR
// end ;
59442: LD_VAR 0 2
59446: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59447: LD_INT 0
59449: PPUSH
59450: PPUSH
// if not mc_bases then
59451: LD_EXP 116
59455: NOT
59456: IFFALSE 59460
// exit ;
59458: GO 59525
// if mc_bases [ base ] then
59460: LD_EXP 116
59464: PUSH
59465: LD_VAR 0 1
59469: ARRAY
59470: IFFALSE 59525
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59472: LD_ADDR_VAR 0 3
59476: PUSH
59477: LD_EXP 116
59481: PUSH
59482: LD_VAR 0 1
59486: ARRAY
59487: PPUSH
59488: LD_INT 30
59490: PUSH
59491: LD_VAR 0 2
59495: PUSH
59496: EMPTY
59497: LIST
59498: LIST
59499: PPUSH
59500: CALL_OW 72
59504: ST_TO_ADDR
// if result then
59505: LD_VAR 0 3
59509: IFFALSE 59525
// result := result [ 1 ] ;
59511: LD_ADDR_VAR 0 3
59515: PUSH
59516: LD_VAR 0 3
59520: PUSH
59521: LD_INT 1
59523: ARRAY
59524: ST_TO_ADDR
// end ; end ;
59525: LD_VAR 0 3
59529: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59530: LD_INT 0
59532: PPUSH
59533: PPUSH
// if not mc_bases then
59534: LD_EXP 116
59538: NOT
59539: IFFALSE 59543
// exit ;
59541: GO 59588
// if mc_bases [ base ] then
59543: LD_EXP 116
59547: PUSH
59548: LD_VAR 0 1
59552: ARRAY
59553: IFFALSE 59588
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59555: LD_ADDR_VAR 0 3
59559: PUSH
59560: LD_EXP 116
59564: PUSH
59565: LD_VAR 0 1
59569: ARRAY
59570: PPUSH
59571: LD_INT 30
59573: PUSH
59574: LD_VAR 0 2
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: PPUSH
59583: CALL_OW 72
59587: ST_TO_ADDR
// end ;
59588: LD_VAR 0 3
59592: RET
// export function MC_SetTame ( base , area ) ; begin
59593: LD_INT 0
59595: PPUSH
// if not mc_bases or not base then
59596: LD_EXP 116
59600: NOT
59601: PUSH
59602: LD_VAR 0 1
59606: NOT
59607: OR
59608: IFFALSE 59612
// exit ;
59610: GO 59637
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59612: LD_ADDR_EXP 144
59616: PUSH
59617: LD_EXP 144
59621: PPUSH
59622: LD_VAR 0 1
59626: PPUSH
59627: LD_VAR 0 2
59631: PPUSH
59632: CALL_OW 1
59636: ST_TO_ADDR
// end ;
59637: LD_VAR 0 3
59641: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59642: LD_INT 0
59644: PPUSH
59645: PPUSH
// if not mc_bases or not base then
59646: LD_EXP 116
59650: NOT
59651: PUSH
59652: LD_VAR 0 1
59656: NOT
59657: OR
59658: IFFALSE 59662
// exit ;
59660: GO 59764
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59662: LD_ADDR_VAR 0 4
59666: PUSH
59667: LD_EXP 116
59671: PUSH
59672: LD_VAR 0 1
59676: ARRAY
59677: PPUSH
59678: LD_INT 30
59680: PUSH
59681: LD_VAR 0 2
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: PPUSH
59690: CALL_OW 72
59694: ST_TO_ADDR
// if not tmp then
59695: LD_VAR 0 4
59699: NOT
59700: IFFALSE 59704
// exit ;
59702: GO 59764
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59704: LD_ADDR_EXP 148
59708: PUSH
59709: LD_EXP 148
59713: PPUSH
59714: LD_VAR 0 1
59718: PPUSH
59719: LD_EXP 148
59723: PUSH
59724: LD_VAR 0 1
59728: ARRAY
59729: PPUSH
59730: LD_EXP 148
59734: PUSH
59735: LD_VAR 0 1
59739: ARRAY
59740: PUSH
59741: LD_INT 1
59743: PLUS
59744: PPUSH
59745: LD_VAR 0 4
59749: PUSH
59750: LD_INT 1
59752: ARRAY
59753: PPUSH
59754: CALL_OW 2
59758: PPUSH
59759: CALL_OW 1
59763: ST_TO_ADDR
// end ;
59764: LD_VAR 0 3
59768: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59769: LD_INT 0
59771: PPUSH
59772: PPUSH
// if not mc_bases or not base or not kinds then
59773: LD_EXP 116
59777: NOT
59778: PUSH
59779: LD_VAR 0 1
59783: NOT
59784: OR
59785: PUSH
59786: LD_VAR 0 2
59790: NOT
59791: OR
59792: IFFALSE 59796
// exit ;
59794: GO 59857
// for i in kinds do
59796: LD_ADDR_VAR 0 4
59800: PUSH
59801: LD_VAR 0 2
59805: PUSH
59806: FOR_IN
59807: IFFALSE 59855
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59809: LD_ADDR_EXP 150
59813: PUSH
59814: LD_EXP 150
59818: PPUSH
59819: LD_VAR 0 1
59823: PUSH
59824: LD_EXP 150
59828: PUSH
59829: LD_VAR 0 1
59833: ARRAY
59834: PUSH
59835: LD_INT 1
59837: PLUS
59838: PUSH
59839: EMPTY
59840: LIST
59841: LIST
59842: PPUSH
59843: LD_VAR 0 4
59847: PPUSH
59848: CALL 70458 0 3
59852: ST_TO_ADDR
59853: GO 59806
59855: POP
59856: POP
// end ;
59857: LD_VAR 0 3
59861: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59862: LD_INT 0
59864: PPUSH
// if not mc_bases or not base or not areas then
59865: LD_EXP 116
59869: NOT
59870: PUSH
59871: LD_VAR 0 1
59875: NOT
59876: OR
59877: PUSH
59878: LD_VAR 0 2
59882: NOT
59883: OR
59884: IFFALSE 59888
// exit ;
59886: GO 59913
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59888: LD_ADDR_EXP 134
59892: PUSH
59893: LD_EXP 134
59897: PPUSH
59898: LD_VAR 0 1
59902: PPUSH
59903: LD_VAR 0 2
59907: PPUSH
59908: CALL_OW 1
59912: ST_TO_ADDR
// end ;
59913: LD_VAR 0 3
59917: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59918: LD_INT 0
59920: PPUSH
// if not mc_bases or not base or not teleports_exit then
59921: LD_EXP 116
59925: NOT
59926: PUSH
59927: LD_VAR 0 1
59931: NOT
59932: OR
59933: PUSH
59934: LD_VAR 0 2
59938: NOT
59939: OR
59940: IFFALSE 59944
// exit ;
59942: GO 59969
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59944: LD_ADDR_EXP 151
59948: PUSH
59949: LD_EXP 151
59953: PPUSH
59954: LD_VAR 0 1
59958: PPUSH
59959: LD_VAR 0 2
59963: PPUSH
59964: CALL_OW 1
59968: ST_TO_ADDR
// end ;
59969: LD_VAR 0 3
59973: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59974: LD_INT 0
59976: PPUSH
59977: PPUSH
59978: PPUSH
// if not mc_bases or not base or not ext_list then
59979: LD_EXP 116
59983: NOT
59984: PUSH
59985: LD_VAR 0 1
59989: NOT
59990: OR
59991: PUSH
59992: LD_VAR 0 5
59996: NOT
59997: OR
59998: IFFALSE 60002
// exit ;
60000: GO 60175
// tmp := GetFacExtXYD ( x , y , d ) ;
60002: LD_ADDR_VAR 0 8
60006: PUSH
60007: LD_VAR 0 2
60011: PPUSH
60012: LD_VAR 0 3
60016: PPUSH
60017: LD_VAR 0 4
60021: PPUSH
60022: CALL 99846 0 3
60026: ST_TO_ADDR
// if not tmp then
60027: LD_VAR 0 8
60031: NOT
60032: IFFALSE 60036
// exit ;
60034: GO 60175
// for i in tmp do
60036: LD_ADDR_VAR 0 7
60040: PUSH
60041: LD_VAR 0 8
60045: PUSH
60046: FOR_IN
60047: IFFALSE 60173
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60049: LD_ADDR_EXP 121
60053: PUSH
60054: LD_EXP 121
60058: PPUSH
60059: LD_VAR 0 1
60063: PPUSH
60064: LD_EXP 121
60068: PUSH
60069: LD_VAR 0 1
60073: ARRAY
60074: PPUSH
60075: LD_EXP 121
60079: PUSH
60080: LD_VAR 0 1
60084: ARRAY
60085: PUSH
60086: LD_INT 1
60088: PLUS
60089: PPUSH
60090: LD_VAR 0 5
60094: PUSH
60095: LD_INT 1
60097: ARRAY
60098: PUSH
60099: LD_VAR 0 7
60103: PUSH
60104: LD_INT 1
60106: ARRAY
60107: PUSH
60108: LD_VAR 0 7
60112: PUSH
60113: LD_INT 2
60115: ARRAY
60116: PUSH
60117: LD_VAR 0 7
60121: PUSH
60122: LD_INT 3
60124: ARRAY
60125: PUSH
60126: EMPTY
60127: LIST
60128: LIST
60129: LIST
60130: LIST
60131: PPUSH
60132: CALL_OW 2
60136: PPUSH
60137: CALL_OW 1
60141: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60142: LD_ADDR_VAR 0 5
60146: PUSH
60147: LD_VAR 0 5
60151: PPUSH
60152: LD_INT 1
60154: PPUSH
60155: CALL_OW 3
60159: ST_TO_ADDR
// if not ext_list then
60160: LD_VAR 0 5
60164: NOT
60165: IFFALSE 60171
// exit ;
60167: POP
60168: POP
60169: GO 60175
// end ;
60171: GO 60046
60173: POP
60174: POP
// end ;
60175: LD_VAR 0 6
60179: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60180: LD_INT 0
60182: PPUSH
// if not mc_bases or not base or not weapon_list then
60183: LD_EXP 116
60187: NOT
60188: PUSH
60189: LD_VAR 0 1
60193: NOT
60194: OR
60195: PUSH
60196: LD_VAR 0 2
60200: NOT
60201: OR
60202: IFFALSE 60206
// exit ;
60204: GO 60231
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60206: LD_ADDR_EXP 155
60210: PUSH
60211: LD_EXP 155
60215: PPUSH
60216: LD_VAR 0 1
60220: PPUSH
60221: LD_VAR 0 2
60225: PPUSH
60226: CALL_OW 1
60230: ST_TO_ADDR
// end ;
60231: LD_VAR 0 3
60235: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60236: LD_INT 0
60238: PPUSH
// if not mc_bases or not base or not tech_list then
60239: LD_EXP 116
60243: NOT
60244: PUSH
60245: LD_VAR 0 1
60249: NOT
60250: OR
60251: PUSH
60252: LD_VAR 0 2
60256: NOT
60257: OR
60258: IFFALSE 60262
// exit ;
60260: GO 60287
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60262: LD_ADDR_EXP 143
60266: PUSH
60267: LD_EXP 143
60271: PPUSH
60272: LD_VAR 0 1
60276: PPUSH
60277: LD_VAR 0 2
60281: PPUSH
60282: CALL_OW 1
60286: ST_TO_ADDR
// end ;
60287: LD_VAR 0 3
60291: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60292: LD_INT 0
60294: PPUSH
// if not mc_bases or not parking_area or not base then
60295: LD_EXP 116
60299: NOT
60300: PUSH
60301: LD_VAR 0 2
60305: NOT
60306: OR
60307: PUSH
60308: LD_VAR 0 1
60312: NOT
60313: OR
60314: IFFALSE 60318
// exit ;
60316: GO 60343
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60318: LD_ADDR_EXP 140
60322: PUSH
60323: LD_EXP 140
60327: PPUSH
60328: LD_VAR 0 1
60332: PPUSH
60333: LD_VAR 0 2
60337: PPUSH
60338: CALL_OW 1
60342: ST_TO_ADDR
// end ;
60343: LD_VAR 0 3
60347: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60348: LD_INT 0
60350: PPUSH
// if not mc_bases or not base or not scan_area then
60351: LD_EXP 116
60355: NOT
60356: PUSH
60357: LD_VAR 0 1
60361: NOT
60362: OR
60363: PUSH
60364: LD_VAR 0 2
60368: NOT
60369: OR
60370: IFFALSE 60374
// exit ;
60372: GO 60399
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60374: LD_ADDR_EXP 141
60378: PUSH
60379: LD_EXP 141
60383: PPUSH
60384: LD_VAR 0 1
60388: PPUSH
60389: LD_VAR 0 2
60393: PPUSH
60394: CALL_OW 1
60398: ST_TO_ADDR
// end ;
60399: LD_VAR 0 3
60403: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60404: LD_INT 0
60406: PPUSH
60407: PPUSH
// if not mc_bases or not base then
60408: LD_EXP 116
60412: NOT
60413: PUSH
60414: LD_VAR 0 1
60418: NOT
60419: OR
60420: IFFALSE 60424
// exit ;
60422: GO 60488
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60424: LD_ADDR_VAR 0 3
60428: PUSH
60429: LD_INT 1
60431: PUSH
60432: LD_INT 2
60434: PUSH
60435: LD_INT 3
60437: PUSH
60438: LD_INT 4
60440: PUSH
60441: LD_INT 11
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: LIST
60450: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60451: LD_ADDR_EXP 143
60455: PUSH
60456: LD_EXP 143
60460: PPUSH
60461: LD_VAR 0 1
60465: PPUSH
60466: LD_EXP 143
60470: PUSH
60471: LD_VAR 0 1
60475: ARRAY
60476: PUSH
60477: LD_VAR 0 3
60481: DIFF
60482: PPUSH
60483: CALL_OW 1
60487: ST_TO_ADDR
// end ;
60488: LD_VAR 0 2
60492: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60493: LD_INT 0
60495: PPUSH
// result := mc_vehicles [ base ] ;
60496: LD_ADDR_VAR 0 3
60500: PUSH
60501: LD_EXP 135
60505: PUSH
60506: LD_VAR 0 1
60510: ARRAY
60511: ST_TO_ADDR
// if onlyCombat then
60512: LD_VAR 0 2
60516: IFFALSE 60694
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60518: LD_ADDR_VAR 0 3
60522: PUSH
60523: LD_VAR 0 3
60527: PUSH
60528: LD_VAR 0 3
60532: PPUSH
60533: LD_INT 2
60535: PUSH
60536: LD_INT 34
60538: PUSH
60539: LD_INT 12
60541: PUSH
60542: EMPTY
60543: LIST
60544: LIST
60545: PUSH
60546: LD_INT 34
60548: PUSH
60549: LD_INT 51
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PUSH
60556: LD_INT 34
60558: PUSH
60559: LD_EXP 96
60563: PUSH
60564: EMPTY
60565: LIST
60566: LIST
60567: PUSH
60568: LD_INT 34
60570: PUSH
60571: LD_INT 32
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: LD_INT 34
60580: PUSH
60581: LD_INT 13
60583: PUSH
60584: EMPTY
60585: LIST
60586: LIST
60587: PUSH
60588: LD_INT 34
60590: PUSH
60591: LD_INT 52
60593: PUSH
60594: EMPTY
60595: LIST
60596: LIST
60597: PUSH
60598: LD_INT 34
60600: PUSH
60601: LD_EXP 101
60605: PUSH
60606: EMPTY
60607: LIST
60608: LIST
60609: PUSH
60610: LD_INT 34
60612: PUSH
60613: LD_INT 14
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: LD_INT 34
60622: PUSH
60623: LD_INT 53
60625: PUSH
60626: EMPTY
60627: LIST
60628: LIST
60629: PUSH
60630: LD_INT 34
60632: PUSH
60633: LD_EXP 95
60637: PUSH
60638: EMPTY
60639: LIST
60640: LIST
60641: PUSH
60642: LD_INT 34
60644: PUSH
60645: LD_INT 31
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: PUSH
60652: LD_INT 34
60654: PUSH
60655: LD_INT 48
60657: PUSH
60658: EMPTY
60659: LIST
60660: LIST
60661: PUSH
60662: LD_INT 34
60664: PUSH
60665: LD_INT 8
60667: PUSH
60668: EMPTY
60669: LIST
60670: LIST
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: LIST
60676: LIST
60677: LIST
60678: LIST
60679: LIST
60680: LIST
60681: LIST
60682: LIST
60683: LIST
60684: LIST
60685: LIST
60686: LIST
60687: PPUSH
60688: CALL_OW 72
60692: DIFF
60693: ST_TO_ADDR
// end ; end_of_file
60694: LD_VAR 0 3
60698: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60699: LD_INT 0
60701: PPUSH
60702: PPUSH
60703: PPUSH
// if not mc_bases or not skirmish then
60704: LD_EXP 116
60708: NOT
60709: PUSH
60710: LD_EXP 114
60714: NOT
60715: OR
60716: IFFALSE 60720
// exit ;
60718: GO 60885
// for i = 1 to mc_bases do
60720: LD_ADDR_VAR 0 4
60724: PUSH
60725: DOUBLE
60726: LD_INT 1
60728: DEC
60729: ST_TO_ADDR
60730: LD_EXP 116
60734: PUSH
60735: FOR_TO
60736: IFFALSE 60883
// begin if sci in mc_bases [ i ] then
60738: LD_VAR 0 2
60742: PUSH
60743: LD_EXP 116
60747: PUSH
60748: LD_VAR 0 4
60752: ARRAY
60753: IN
60754: IFFALSE 60881
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60756: LD_ADDR_EXP 145
60760: PUSH
60761: LD_EXP 145
60765: PPUSH
60766: LD_VAR 0 4
60770: PUSH
60771: LD_EXP 145
60775: PUSH
60776: LD_VAR 0 4
60780: ARRAY
60781: PUSH
60782: LD_INT 1
60784: PLUS
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: PPUSH
60790: LD_VAR 0 1
60794: PPUSH
60795: CALL 70458 0 3
60799: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60800: LD_ADDR_VAR 0 5
60804: PUSH
60805: LD_EXP 116
60809: PUSH
60810: LD_VAR 0 4
60814: ARRAY
60815: PPUSH
60816: LD_INT 2
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 0
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 1
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: PPUSH
60844: CALL_OW 72
60848: PPUSH
60849: LD_VAR 0 1
60853: PPUSH
60854: CALL_OW 74
60858: ST_TO_ADDR
// if tmp then
60859: LD_VAR 0 5
60863: IFFALSE 60879
// ComStandNearbyBuilding ( ape , tmp ) ;
60865: LD_VAR 0 1
60869: PPUSH
60870: LD_VAR 0 5
60874: PPUSH
60875: CALL 67036 0 2
// break ;
60879: GO 60883
// end ; end ;
60881: GO 60735
60883: POP
60884: POP
// end ;
60885: LD_VAR 0 3
60889: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60890: LD_INT 0
60892: PPUSH
60893: PPUSH
60894: PPUSH
// if not mc_bases or not skirmish then
60895: LD_EXP 116
60899: NOT
60900: PUSH
60901: LD_EXP 114
60905: NOT
60906: OR
60907: IFFALSE 60911
// exit ;
60909: GO 61000
// for i = 1 to mc_bases do
60911: LD_ADDR_VAR 0 4
60915: PUSH
60916: DOUBLE
60917: LD_INT 1
60919: DEC
60920: ST_TO_ADDR
60921: LD_EXP 116
60925: PUSH
60926: FOR_TO
60927: IFFALSE 60998
// begin if building in mc_busy_turret_list [ i ] then
60929: LD_VAR 0 1
60933: PUSH
60934: LD_EXP 126
60938: PUSH
60939: LD_VAR 0 4
60943: ARRAY
60944: IN
60945: IFFALSE 60996
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60947: LD_ADDR_VAR 0 5
60951: PUSH
60952: LD_EXP 126
60956: PUSH
60957: LD_VAR 0 4
60961: ARRAY
60962: PUSH
60963: LD_VAR 0 1
60967: DIFF
60968: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60969: LD_ADDR_EXP 126
60973: PUSH
60974: LD_EXP 126
60978: PPUSH
60979: LD_VAR 0 4
60983: PPUSH
60984: LD_VAR 0 5
60988: PPUSH
60989: CALL_OW 1
60993: ST_TO_ADDR
// break ;
60994: GO 60998
// end ; end ;
60996: GO 60926
60998: POP
60999: POP
// end ;
61000: LD_VAR 0 3
61004: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61005: LD_INT 0
61007: PPUSH
61008: PPUSH
61009: PPUSH
// if not mc_bases or not skirmish then
61010: LD_EXP 116
61014: NOT
61015: PUSH
61016: LD_EXP 114
61020: NOT
61021: OR
61022: IFFALSE 61026
// exit ;
61024: GO 61225
// for i = 1 to mc_bases do
61026: LD_ADDR_VAR 0 5
61030: PUSH
61031: DOUBLE
61032: LD_INT 1
61034: DEC
61035: ST_TO_ADDR
61036: LD_EXP 116
61040: PUSH
61041: FOR_TO
61042: IFFALSE 61223
// if building in mc_bases [ i ] then
61044: LD_VAR 0 1
61048: PUSH
61049: LD_EXP 116
61053: PUSH
61054: LD_VAR 0 5
61058: ARRAY
61059: IN
61060: IFFALSE 61221
// begin tmp := mc_bases [ i ] diff building ;
61062: LD_ADDR_VAR 0 6
61066: PUSH
61067: LD_EXP 116
61071: PUSH
61072: LD_VAR 0 5
61076: ARRAY
61077: PUSH
61078: LD_VAR 0 1
61082: DIFF
61083: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61084: LD_ADDR_EXP 116
61088: PUSH
61089: LD_EXP 116
61093: PPUSH
61094: LD_VAR 0 5
61098: PPUSH
61099: LD_VAR 0 6
61103: PPUSH
61104: CALL_OW 1
61108: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61109: LD_VAR 0 1
61113: PUSH
61114: LD_EXP 124
61118: PUSH
61119: LD_VAR 0 5
61123: ARRAY
61124: IN
61125: IFFALSE 61164
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61127: LD_ADDR_EXP 124
61131: PUSH
61132: LD_EXP 124
61136: PPUSH
61137: LD_VAR 0 5
61141: PPUSH
61142: LD_EXP 124
61146: PUSH
61147: LD_VAR 0 5
61151: ARRAY
61152: PUSH
61153: LD_VAR 0 1
61157: DIFF
61158: PPUSH
61159: CALL_OW 1
61163: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61164: LD_VAR 0 1
61168: PUSH
61169: LD_EXP 125
61173: PUSH
61174: LD_VAR 0 5
61178: ARRAY
61179: IN
61180: IFFALSE 61219
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61182: LD_ADDR_EXP 125
61186: PUSH
61187: LD_EXP 125
61191: PPUSH
61192: LD_VAR 0 5
61196: PPUSH
61197: LD_EXP 125
61201: PUSH
61202: LD_VAR 0 5
61206: ARRAY
61207: PUSH
61208: LD_VAR 0 1
61212: DIFF
61213: PPUSH
61214: CALL_OW 1
61218: ST_TO_ADDR
// break ;
61219: GO 61223
// end ;
61221: GO 61041
61223: POP
61224: POP
// end ;
61225: LD_VAR 0 4
61229: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61230: LD_INT 0
61232: PPUSH
61233: PPUSH
61234: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61235: LD_EXP 116
61239: NOT
61240: PUSH
61241: LD_EXP 114
61245: NOT
61246: OR
61247: PUSH
61248: LD_VAR 0 3
61252: PUSH
61253: LD_EXP 142
61257: IN
61258: NOT
61259: OR
61260: IFFALSE 61264
// exit ;
61262: GO 61387
// for i = 1 to mc_vehicles do
61264: LD_ADDR_VAR 0 6
61268: PUSH
61269: DOUBLE
61270: LD_INT 1
61272: DEC
61273: ST_TO_ADDR
61274: LD_EXP 135
61278: PUSH
61279: FOR_TO
61280: IFFALSE 61385
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61282: LD_VAR 0 2
61286: PUSH
61287: LD_EXP 135
61291: PUSH
61292: LD_VAR 0 6
61296: ARRAY
61297: IN
61298: PUSH
61299: LD_VAR 0 1
61303: PUSH
61304: LD_EXP 135
61308: PUSH
61309: LD_VAR 0 6
61313: ARRAY
61314: IN
61315: OR
61316: IFFALSE 61383
// begin tmp := mc_vehicles [ i ] diff old ;
61318: LD_ADDR_VAR 0 7
61322: PUSH
61323: LD_EXP 135
61327: PUSH
61328: LD_VAR 0 6
61332: ARRAY
61333: PUSH
61334: LD_VAR 0 2
61338: DIFF
61339: ST_TO_ADDR
// tmp := tmp diff new ;
61340: LD_ADDR_VAR 0 7
61344: PUSH
61345: LD_VAR 0 7
61349: PUSH
61350: LD_VAR 0 1
61354: DIFF
61355: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61356: LD_ADDR_EXP 135
61360: PUSH
61361: LD_EXP 135
61365: PPUSH
61366: LD_VAR 0 6
61370: PPUSH
61371: LD_VAR 0 7
61375: PPUSH
61376: CALL_OW 1
61380: ST_TO_ADDR
// break ;
61381: GO 61385
// end ;
61383: GO 61279
61385: POP
61386: POP
// end ;
61387: LD_VAR 0 5
61391: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61392: LD_INT 0
61394: PPUSH
61395: PPUSH
61396: PPUSH
61397: PPUSH
// if not mc_bases or not skirmish then
61398: LD_EXP 116
61402: NOT
61403: PUSH
61404: LD_EXP 114
61408: NOT
61409: OR
61410: IFFALSE 61414
// exit ;
61412: GO 61797
// side := GetSide ( vehicle ) ;
61414: LD_ADDR_VAR 0 5
61418: PUSH
61419: LD_VAR 0 1
61423: PPUSH
61424: CALL_OW 255
61428: ST_TO_ADDR
// for i = 1 to mc_bases do
61429: LD_ADDR_VAR 0 4
61433: PUSH
61434: DOUBLE
61435: LD_INT 1
61437: DEC
61438: ST_TO_ADDR
61439: LD_EXP 116
61443: PUSH
61444: FOR_TO
61445: IFFALSE 61795
// begin if factory in mc_bases [ i ] then
61447: LD_VAR 0 2
61451: PUSH
61452: LD_EXP 116
61456: PUSH
61457: LD_VAR 0 4
61461: ARRAY
61462: IN
61463: IFFALSE 61793
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61465: LD_EXP 138
61469: PUSH
61470: LD_VAR 0 4
61474: ARRAY
61475: PUSH
61476: LD_EXP 127
61480: PUSH
61481: LD_VAR 0 4
61485: ARRAY
61486: LESS
61487: PUSH
61488: LD_VAR 0 1
61492: PPUSH
61493: CALL_OW 264
61497: PUSH
61498: LD_INT 31
61500: PUSH
61501: LD_INT 32
61503: PUSH
61504: LD_INT 51
61506: PUSH
61507: LD_EXP 96
61511: PUSH
61512: LD_INT 12
61514: PUSH
61515: LD_INT 30
61517: PUSH
61518: LD_EXP 95
61522: PUSH
61523: LD_INT 11
61525: PUSH
61526: LD_INT 53
61528: PUSH
61529: LD_INT 14
61531: PUSH
61532: LD_EXP 99
61536: PUSH
61537: LD_INT 29
61539: PUSH
61540: LD_EXP 97
61544: PUSH
61545: LD_INT 13
61547: PUSH
61548: LD_INT 52
61550: PUSH
61551: LD_EXP 101
61555: PUSH
61556: LD_INT 48
61558: PUSH
61559: LD_INT 8
61561: PUSH
61562: EMPTY
61563: LIST
61564: LIST
61565: LIST
61566: LIST
61567: LIST
61568: LIST
61569: LIST
61570: LIST
61571: LIST
61572: LIST
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: LIST
61578: LIST
61579: LIST
61580: LIST
61581: IN
61582: NOT
61583: AND
61584: IFFALSE 61632
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61586: LD_ADDR_EXP 138
61590: PUSH
61591: LD_EXP 138
61595: PPUSH
61596: LD_VAR 0 4
61600: PUSH
61601: LD_EXP 138
61605: PUSH
61606: LD_VAR 0 4
61610: ARRAY
61611: PUSH
61612: LD_INT 1
61614: PLUS
61615: PUSH
61616: EMPTY
61617: LIST
61618: LIST
61619: PPUSH
61620: LD_VAR 0 1
61624: PPUSH
61625: CALL 70458 0 3
61629: ST_TO_ADDR
61630: GO 61676
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61632: LD_ADDR_EXP 135
61636: PUSH
61637: LD_EXP 135
61641: PPUSH
61642: LD_VAR 0 4
61646: PUSH
61647: LD_EXP 135
61651: PUSH
61652: LD_VAR 0 4
61656: ARRAY
61657: PUSH
61658: LD_INT 1
61660: PLUS
61661: PUSH
61662: EMPTY
61663: LIST
61664: LIST
61665: PPUSH
61666: LD_VAR 0 1
61670: PPUSH
61671: CALL 70458 0 3
61675: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61676: LD_VAR 0 1
61680: PPUSH
61681: CALL_OW 263
61685: PUSH
61686: LD_INT 2
61688: EQUAL
61689: IFFALSE 61709
// begin repeat wait ( 0 0$1 ) ;
61691: LD_INT 35
61693: PPUSH
61694: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61698: LD_VAR 0 1
61702: PPUSH
61703: CALL_OW 312
61707: IFFALSE 61691
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61709: LD_VAR 0 1
61713: PPUSH
61714: LD_EXP 140
61718: PUSH
61719: LD_VAR 0 4
61723: ARRAY
61724: PPUSH
61725: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61729: LD_VAR 0 1
61733: PPUSH
61734: CALL_OW 263
61738: PUSH
61739: LD_INT 1
61741: NONEQUAL
61742: IFFALSE 61746
// break ;
61744: GO 61795
// repeat wait ( 0 0$1 ) ;
61746: LD_INT 35
61748: PPUSH
61749: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61753: LD_VAR 0 1
61757: PPUSH
61758: LD_EXP 140
61762: PUSH
61763: LD_VAR 0 4
61767: ARRAY
61768: PPUSH
61769: CALL_OW 308
61773: IFFALSE 61746
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61775: LD_VAR 0 1
61779: PPUSH
61780: CALL_OW 311
61784: PPUSH
61785: CALL_OW 121
// exit ;
61789: POP
61790: POP
61791: GO 61797
// end ; end ;
61793: GO 61444
61795: POP
61796: POP
// end ;
61797: LD_VAR 0 3
61801: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61802: LD_INT 0
61804: PPUSH
61805: PPUSH
61806: PPUSH
61807: PPUSH
// if not mc_bases or not skirmish then
61808: LD_EXP 116
61812: NOT
61813: PUSH
61814: LD_EXP 114
61818: NOT
61819: OR
61820: IFFALSE 61824
// exit ;
61822: GO 62177
// repeat wait ( 0 0$1 ) ;
61824: LD_INT 35
61826: PPUSH
61827: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61831: LD_VAR 0 2
61835: PPUSH
61836: LD_VAR 0 3
61840: PPUSH
61841: CALL_OW 284
61845: IFFALSE 61824
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61847: LD_VAR 0 2
61851: PPUSH
61852: LD_VAR 0 3
61856: PPUSH
61857: CALL_OW 283
61861: PUSH
61862: LD_INT 4
61864: EQUAL
61865: IFFALSE 61869
// exit ;
61867: GO 62177
// for i = 1 to mc_bases do
61869: LD_ADDR_VAR 0 7
61873: PUSH
61874: DOUBLE
61875: LD_INT 1
61877: DEC
61878: ST_TO_ADDR
61879: LD_EXP 116
61883: PUSH
61884: FOR_TO
61885: IFFALSE 62175
// begin if mc_crates_area [ i ] then
61887: LD_EXP 134
61891: PUSH
61892: LD_VAR 0 7
61896: ARRAY
61897: IFFALSE 62008
// for j in mc_crates_area [ i ] do
61899: LD_ADDR_VAR 0 8
61903: PUSH
61904: LD_EXP 134
61908: PUSH
61909: LD_VAR 0 7
61913: ARRAY
61914: PUSH
61915: FOR_IN
61916: IFFALSE 62006
// if InArea ( x , y , j ) then
61918: LD_VAR 0 2
61922: PPUSH
61923: LD_VAR 0 3
61927: PPUSH
61928: LD_VAR 0 8
61932: PPUSH
61933: CALL_OW 309
61937: IFFALSE 62004
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61939: LD_ADDR_EXP 132
61943: PUSH
61944: LD_EXP 132
61948: PPUSH
61949: LD_VAR 0 7
61953: PUSH
61954: LD_EXP 132
61958: PUSH
61959: LD_VAR 0 7
61963: ARRAY
61964: PUSH
61965: LD_INT 1
61967: PLUS
61968: PUSH
61969: EMPTY
61970: LIST
61971: LIST
61972: PPUSH
61973: LD_VAR 0 4
61977: PUSH
61978: LD_VAR 0 2
61982: PUSH
61983: LD_VAR 0 3
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: LIST
61992: PPUSH
61993: CALL 70458 0 3
61997: ST_TO_ADDR
// exit ;
61998: POP
61999: POP
62000: POP
62001: POP
62002: GO 62177
// end ;
62004: GO 61915
62006: POP
62007: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62008: LD_ADDR_VAR 0 9
62012: PUSH
62013: LD_EXP 116
62017: PUSH
62018: LD_VAR 0 7
62022: ARRAY
62023: PPUSH
62024: LD_INT 2
62026: PUSH
62027: LD_INT 30
62029: PUSH
62030: LD_INT 0
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: PUSH
62037: LD_INT 30
62039: PUSH
62040: LD_INT 1
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: LIST
62051: PPUSH
62052: CALL_OW 72
62056: ST_TO_ADDR
// if not depot then
62057: LD_VAR 0 9
62061: NOT
62062: IFFALSE 62066
// continue ;
62064: GO 61884
// for j in depot do
62066: LD_ADDR_VAR 0 8
62070: PUSH
62071: LD_VAR 0 9
62075: PUSH
62076: FOR_IN
62077: IFFALSE 62171
// if GetDistUnitXY ( j , x , y ) < 30 then
62079: LD_VAR 0 8
62083: PPUSH
62084: LD_VAR 0 2
62088: PPUSH
62089: LD_VAR 0 3
62093: PPUSH
62094: CALL_OW 297
62098: PUSH
62099: LD_INT 30
62101: LESS
62102: IFFALSE 62169
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62104: LD_ADDR_EXP 132
62108: PUSH
62109: LD_EXP 132
62113: PPUSH
62114: LD_VAR 0 7
62118: PUSH
62119: LD_EXP 132
62123: PUSH
62124: LD_VAR 0 7
62128: ARRAY
62129: PUSH
62130: LD_INT 1
62132: PLUS
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: PPUSH
62138: LD_VAR 0 4
62142: PUSH
62143: LD_VAR 0 2
62147: PUSH
62148: LD_VAR 0 3
62152: PUSH
62153: EMPTY
62154: LIST
62155: LIST
62156: LIST
62157: PPUSH
62158: CALL 70458 0 3
62162: ST_TO_ADDR
// exit ;
62163: POP
62164: POP
62165: POP
62166: POP
62167: GO 62177
// end ;
62169: GO 62076
62171: POP
62172: POP
// end ;
62173: GO 61884
62175: POP
62176: POP
// end ;
62177: LD_VAR 0 6
62181: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62182: LD_INT 0
62184: PPUSH
62185: PPUSH
62186: PPUSH
62187: PPUSH
// if not mc_bases or not skirmish then
62188: LD_EXP 116
62192: NOT
62193: PUSH
62194: LD_EXP 114
62198: NOT
62199: OR
62200: IFFALSE 62204
// exit ;
62202: GO 62481
// side := GetSide ( lab ) ;
62204: LD_ADDR_VAR 0 4
62208: PUSH
62209: LD_VAR 0 2
62213: PPUSH
62214: CALL_OW 255
62218: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62219: LD_VAR 0 4
62223: PUSH
62224: LD_EXP 142
62228: IN
62229: NOT
62230: PUSH
62231: LD_EXP 143
62235: NOT
62236: OR
62237: PUSH
62238: LD_EXP 116
62242: NOT
62243: OR
62244: IFFALSE 62248
// exit ;
62246: GO 62481
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62248: LD_ADDR_EXP 143
62252: PUSH
62253: LD_EXP 143
62257: PPUSH
62258: LD_VAR 0 4
62262: PPUSH
62263: LD_EXP 143
62267: PUSH
62268: LD_VAR 0 4
62272: ARRAY
62273: PUSH
62274: LD_VAR 0 1
62278: DIFF
62279: PPUSH
62280: CALL_OW 1
62284: ST_TO_ADDR
// for i = 1 to mc_bases do
62285: LD_ADDR_VAR 0 5
62289: PUSH
62290: DOUBLE
62291: LD_INT 1
62293: DEC
62294: ST_TO_ADDR
62295: LD_EXP 116
62299: PUSH
62300: FOR_TO
62301: IFFALSE 62479
// begin if lab in mc_bases [ i ] then
62303: LD_VAR 0 2
62307: PUSH
62308: LD_EXP 116
62312: PUSH
62313: LD_VAR 0 5
62317: ARRAY
62318: IN
62319: IFFALSE 62477
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62321: LD_VAR 0 1
62325: PUSH
62326: LD_INT 11
62328: PUSH
62329: LD_INT 4
62331: PUSH
62332: LD_INT 3
62334: PUSH
62335: LD_INT 2
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: LIST
62342: LIST
62343: IN
62344: PUSH
62345: LD_EXP 146
62349: PUSH
62350: LD_VAR 0 5
62354: ARRAY
62355: AND
62356: IFFALSE 62477
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62358: LD_ADDR_VAR 0 6
62362: PUSH
62363: LD_EXP 146
62367: PUSH
62368: LD_VAR 0 5
62372: ARRAY
62373: PUSH
62374: LD_INT 1
62376: ARRAY
62377: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62378: LD_ADDR_EXP 146
62382: PUSH
62383: LD_EXP 146
62387: PPUSH
62388: LD_VAR 0 5
62392: PPUSH
62393: EMPTY
62394: PPUSH
62395: CALL_OW 1
62399: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62400: LD_VAR 0 6
62404: PPUSH
62405: LD_INT 0
62407: PPUSH
62408: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62412: LD_VAR 0 6
62416: PPUSH
62417: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62421: LD_ADDR_EXP 145
62425: PUSH
62426: LD_EXP 145
62430: PPUSH
62431: LD_VAR 0 5
62435: PPUSH
62436: LD_EXP 145
62440: PUSH
62441: LD_VAR 0 5
62445: ARRAY
62446: PPUSH
62447: LD_INT 1
62449: PPUSH
62450: LD_VAR 0 6
62454: PPUSH
62455: CALL_OW 2
62459: PPUSH
62460: CALL_OW 1
62464: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62465: LD_VAR 0 5
62469: PPUSH
62470: LD_INT 112
62472: PPUSH
62473: CALL 39310 0 2
// end ; end ; end ;
62477: GO 62300
62479: POP
62480: POP
// end ;
62481: LD_VAR 0 3
62485: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62486: LD_INT 0
62488: PPUSH
62489: PPUSH
62490: PPUSH
62491: PPUSH
62492: PPUSH
62493: PPUSH
62494: PPUSH
62495: PPUSH
// if not mc_bases or not skirmish then
62496: LD_EXP 116
62500: NOT
62501: PUSH
62502: LD_EXP 114
62506: NOT
62507: OR
62508: IFFALSE 62512
// exit ;
62510: GO 63883
// for i = 1 to mc_bases do
62512: LD_ADDR_VAR 0 3
62516: PUSH
62517: DOUBLE
62518: LD_INT 1
62520: DEC
62521: ST_TO_ADDR
62522: LD_EXP 116
62526: PUSH
62527: FOR_TO
62528: IFFALSE 63881
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62530: LD_VAR 0 1
62534: PUSH
62535: LD_EXP 116
62539: PUSH
62540: LD_VAR 0 3
62544: ARRAY
62545: IN
62546: PUSH
62547: LD_VAR 0 1
62551: PUSH
62552: LD_EXP 123
62556: PUSH
62557: LD_VAR 0 3
62561: ARRAY
62562: IN
62563: OR
62564: PUSH
62565: LD_VAR 0 1
62569: PUSH
62570: LD_EXP 138
62574: PUSH
62575: LD_VAR 0 3
62579: ARRAY
62580: IN
62581: OR
62582: PUSH
62583: LD_VAR 0 1
62587: PUSH
62588: LD_EXP 135
62592: PUSH
62593: LD_VAR 0 3
62597: ARRAY
62598: IN
62599: OR
62600: PUSH
62601: LD_VAR 0 1
62605: PUSH
62606: LD_EXP 145
62610: PUSH
62611: LD_VAR 0 3
62615: ARRAY
62616: IN
62617: OR
62618: PUSH
62619: LD_VAR 0 1
62623: PUSH
62624: LD_EXP 146
62628: PUSH
62629: LD_VAR 0 3
62633: ARRAY
62634: IN
62635: OR
62636: IFFALSE 63879
// begin if un in mc_ape [ i ] then
62638: LD_VAR 0 1
62642: PUSH
62643: LD_EXP 145
62647: PUSH
62648: LD_VAR 0 3
62652: ARRAY
62653: IN
62654: IFFALSE 62693
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62656: LD_ADDR_EXP 145
62660: PUSH
62661: LD_EXP 145
62665: PPUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_EXP 145
62675: PUSH
62676: LD_VAR 0 3
62680: ARRAY
62681: PUSH
62682: LD_VAR 0 1
62686: DIFF
62687: PPUSH
62688: CALL_OW 1
62692: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62693: LD_VAR 0 1
62697: PUSH
62698: LD_EXP 146
62702: PUSH
62703: LD_VAR 0 3
62707: ARRAY
62708: IN
62709: IFFALSE 62733
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62711: LD_ADDR_EXP 146
62715: PUSH
62716: LD_EXP 146
62720: PPUSH
62721: LD_VAR 0 3
62725: PPUSH
62726: EMPTY
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62733: LD_VAR 0 1
62737: PPUSH
62738: CALL_OW 247
62742: PUSH
62743: LD_INT 2
62745: EQUAL
62746: PUSH
62747: LD_VAR 0 1
62751: PPUSH
62752: CALL_OW 110
62756: PUSH
62757: LD_INT 20
62759: EQUAL
62760: PUSH
62761: LD_VAR 0 1
62765: PUSH
62766: LD_EXP 138
62770: PUSH
62771: LD_VAR 0 3
62775: ARRAY
62776: IN
62777: OR
62778: PUSH
62779: LD_VAR 0 1
62783: PPUSH
62784: CALL_OW 264
62788: PUSH
62789: LD_INT 12
62791: PUSH
62792: LD_INT 51
62794: PUSH
62795: LD_EXP 96
62799: PUSH
62800: LD_INT 32
62802: PUSH
62803: LD_INT 13
62805: PUSH
62806: LD_INT 52
62808: PUSH
62809: LD_INT 31
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: LIST
62816: LIST
62817: LIST
62818: LIST
62819: LIST
62820: IN
62821: OR
62822: AND
62823: IFFALSE 63131
// begin if un in mc_defender [ i ] then
62825: LD_VAR 0 1
62829: PUSH
62830: LD_EXP 138
62834: PUSH
62835: LD_VAR 0 3
62839: ARRAY
62840: IN
62841: IFFALSE 62880
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62843: LD_ADDR_EXP 138
62847: PUSH
62848: LD_EXP 138
62852: PPUSH
62853: LD_VAR 0 3
62857: PPUSH
62858: LD_EXP 138
62862: PUSH
62863: LD_VAR 0 3
62867: ARRAY
62868: PUSH
62869: LD_VAR 0 1
62873: DIFF
62874: PPUSH
62875: CALL_OW 1
62879: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62880: LD_ADDR_VAR 0 8
62884: PUSH
62885: LD_VAR 0 3
62889: PPUSH
62890: LD_INT 3
62892: PPUSH
62893: CALL 59530 0 2
62897: ST_TO_ADDR
// if fac then
62898: LD_VAR 0 8
62902: IFFALSE 63131
// begin for j in fac do
62904: LD_ADDR_VAR 0 4
62908: PUSH
62909: LD_VAR 0 8
62913: PUSH
62914: FOR_IN
62915: IFFALSE 63129
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62917: LD_ADDR_VAR 0 9
62921: PUSH
62922: LD_VAR 0 8
62926: PPUSH
62927: LD_VAR 0 1
62931: PPUSH
62932: CALL_OW 265
62936: PPUSH
62937: LD_VAR 0 1
62941: PPUSH
62942: CALL_OW 262
62946: PPUSH
62947: LD_VAR 0 1
62951: PPUSH
62952: CALL_OW 263
62956: PPUSH
62957: LD_VAR 0 1
62961: PPUSH
62962: CALL_OW 264
62966: PPUSH
62967: CALL 67954 0 5
62971: ST_TO_ADDR
// if components then
62972: LD_VAR 0 9
62976: IFFALSE 63127
// begin if GetWeapon ( un ) = ar_control_tower then
62978: LD_VAR 0 1
62982: PPUSH
62983: CALL_OW 264
62987: PUSH
62988: LD_INT 31
62990: EQUAL
62991: IFFALSE 63108
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62993: LD_VAR 0 1
62997: PPUSH
62998: CALL_OW 311
63002: PPUSH
63003: LD_INT 0
63005: PPUSH
63006: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63010: LD_ADDR_EXP 156
63014: PUSH
63015: LD_EXP 156
63019: PPUSH
63020: LD_VAR 0 3
63024: PPUSH
63025: LD_EXP 156
63029: PUSH
63030: LD_VAR 0 3
63034: ARRAY
63035: PUSH
63036: LD_VAR 0 1
63040: PPUSH
63041: CALL_OW 311
63045: DIFF
63046: PPUSH
63047: CALL_OW 1
63051: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63052: LD_ADDR_VAR 0 7
63056: PUSH
63057: LD_EXP 137
63061: PUSH
63062: LD_VAR 0 3
63066: ARRAY
63067: PPUSH
63068: LD_INT 1
63070: PPUSH
63071: LD_VAR 0 9
63075: PPUSH
63076: CALL_OW 2
63080: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63081: LD_ADDR_EXP 137
63085: PUSH
63086: LD_EXP 137
63090: PPUSH
63091: LD_VAR 0 3
63095: PPUSH
63096: LD_VAR 0 7
63100: PPUSH
63101: CALL_OW 1
63105: ST_TO_ADDR
// end else
63106: GO 63125
// MC_InsertProduceList ( i , [ components ] ) ;
63108: LD_VAR 0 3
63112: PPUSH
63113: LD_VAR 0 9
63117: PUSH
63118: EMPTY
63119: LIST
63120: PPUSH
63121: CALL 59075 0 2
// break ;
63125: GO 63129
// end ; end ;
63127: GO 62914
63129: POP
63130: POP
// end ; end ; if GetType ( un ) = unit_building then
63131: LD_VAR 0 1
63135: PPUSH
63136: CALL_OW 247
63140: PUSH
63141: LD_INT 3
63143: EQUAL
63144: IFFALSE 63547
// begin btype := GetBType ( un ) ;
63146: LD_ADDR_VAR 0 5
63150: PUSH
63151: LD_VAR 0 1
63155: PPUSH
63156: CALL_OW 266
63160: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63161: LD_VAR 0 5
63165: PUSH
63166: LD_INT 29
63168: PUSH
63169: LD_INT 30
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: IN
63176: IFFALSE 63249
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63178: LD_VAR 0 1
63182: PPUSH
63183: CALL_OW 250
63187: PPUSH
63188: LD_VAR 0 1
63192: PPUSH
63193: CALL_OW 251
63197: PPUSH
63198: LD_VAR 0 1
63202: PPUSH
63203: CALL_OW 255
63207: PPUSH
63208: CALL_OW 440
63212: NOT
63213: IFFALSE 63249
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63215: LD_VAR 0 1
63219: PPUSH
63220: CALL_OW 250
63224: PPUSH
63225: LD_VAR 0 1
63229: PPUSH
63230: CALL_OW 251
63234: PPUSH
63235: LD_VAR 0 1
63239: PPUSH
63240: CALL_OW 255
63244: PPUSH
63245: CALL_OW 441
// end ; if btype = b_warehouse then
63249: LD_VAR 0 5
63253: PUSH
63254: LD_INT 1
63256: EQUAL
63257: IFFALSE 63275
// begin btype := b_depot ;
63259: LD_ADDR_VAR 0 5
63263: PUSH
63264: LD_INT 0
63266: ST_TO_ADDR
// pos := 1 ;
63267: LD_ADDR_VAR 0 6
63271: PUSH
63272: LD_INT 1
63274: ST_TO_ADDR
// end ; if btype = b_factory then
63275: LD_VAR 0 5
63279: PUSH
63280: LD_INT 3
63282: EQUAL
63283: IFFALSE 63301
// begin btype := b_workshop ;
63285: LD_ADDR_VAR 0 5
63289: PUSH
63290: LD_INT 2
63292: ST_TO_ADDR
// pos := 1 ;
63293: LD_ADDR_VAR 0 6
63297: PUSH
63298: LD_INT 1
63300: ST_TO_ADDR
// end ; if btype = b_barracks then
63301: LD_VAR 0 5
63305: PUSH
63306: LD_INT 5
63308: EQUAL
63309: IFFALSE 63319
// btype := b_armoury ;
63311: LD_ADDR_VAR 0 5
63315: PUSH
63316: LD_INT 4
63318: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63319: LD_VAR 0 5
63323: PUSH
63324: LD_INT 7
63326: PUSH
63327: LD_INT 8
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: IN
63334: IFFALSE 63344
// btype := b_lab ;
63336: LD_ADDR_VAR 0 5
63340: PUSH
63341: LD_INT 6
63343: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63344: LD_ADDR_EXP 121
63348: PUSH
63349: LD_EXP 121
63353: PPUSH
63354: LD_VAR 0 3
63358: PUSH
63359: LD_EXP 121
63363: PUSH
63364: LD_VAR 0 3
63368: ARRAY
63369: PUSH
63370: LD_INT 1
63372: PLUS
63373: PUSH
63374: EMPTY
63375: LIST
63376: LIST
63377: PPUSH
63378: LD_VAR 0 5
63382: PUSH
63383: LD_VAR 0 1
63387: PPUSH
63388: CALL_OW 250
63392: PUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: CALL_OW 251
63402: PUSH
63403: LD_VAR 0 1
63407: PPUSH
63408: CALL_OW 254
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: PPUSH
63419: CALL 70458 0 3
63423: ST_TO_ADDR
// if pos = 1 then
63424: LD_VAR 0 6
63428: PUSH
63429: LD_INT 1
63431: EQUAL
63432: IFFALSE 63547
// begin tmp := mc_build_list [ i ] ;
63434: LD_ADDR_VAR 0 7
63438: PUSH
63439: LD_EXP 121
63443: PUSH
63444: LD_VAR 0 3
63448: ARRAY
63449: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63450: LD_VAR 0 7
63454: PPUSH
63455: LD_INT 2
63457: PUSH
63458: LD_INT 30
63460: PUSH
63461: LD_INT 0
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 30
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: LIST
63482: PPUSH
63483: CALL_OW 72
63487: IFFALSE 63497
// pos := 2 ;
63489: LD_ADDR_VAR 0 6
63493: PUSH
63494: LD_INT 2
63496: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63497: LD_ADDR_VAR 0 7
63501: PUSH
63502: LD_VAR 0 7
63506: PPUSH
63507: LD_VAR 0 6
63511: PPUSH
63512: LD_VAR 0 7
63516: PPUSH
63517: CALL 70784 0 3
63521: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63522: LD_ADDR_EXP 121
63526: PUSH
63527: LD_EXP 121
63531: PPUSH
63532: LD_VAR 0 3
63536: PPUSH
63537: LD_VAR 0 7
63541: PPUSH
63542: CALL_OW 1
63546: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63547: LD_VAR 0 1
63551: PUSH
63552: LD_EXP 116
63556: PUSH
63557: LD_VAR 0 3
63561: ARRAY
63562: IN
63563: IFFALSE 63602
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63565: LD_ADDR_EXP 116
63569: PUSH
63570: LD_EXP 116
63574: PPUSH
63575: LD_VAR 0 3
63579: PPUSH
63580: LD_EXP 116
63584: PUSH
63585: LD_VAR 0 3
63589: ARRAY
63590: PUSH
63591: LD_VAR 0 1
63595: DIFF
63596: PPUSH
63597: CALL_OW 1
63601: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63602: LD_VAR 0 1
63606: PUSH
63607: LD_EXP 123
63611: PUSH
63612: LD_VAR 0 3
63616: ARRAY
63617: IN
63618: IFFALSE 63657
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63620: LD_ADDR_EXP 123
63624: PUSH
63625: LD_EXP 123
63629: PPUSH
63630: LD_VAR 0 3
63634: PPUSH
63635: LD_EXP 123
63639: PUSH
63640: LD_VAR 0 3
63644: ARRAY
63645: PUSH
63646: LD_VAR 0 1
63650: DIFF
63651: PPUSH
63652: CALL_OW 1
63656: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63657: LD_VAR 0 1
63661: PUSH
63662: LD_EXP 135
63666: PUSH
63667: LD_VAR 0 3
63671: ARRAY
63672: IN
63673: IFFALSE 63712
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63675: LD_ADDR_EXP 135
63679: PUSH
63680: LD_EXP 135
63684: PPUSH
63685: LD_VAR 0 3
63689: PPUSH
63690: LD_EXP 135
63694: PUSH
63695: LD_VAR 0 3
63699: ARRAY
63700: PUSH
63701: LD_VAR 0 1
63705: DIFF
63706: PPUSH
63707: CALL_OW 1
63711: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63712: LD_VAR 0 1
63716: PUSH
63717: LD_EXP 138
63721: PUSH
63722: LD_VAR 0 3
63726: ARRAY
63727: IN
63728: IFFALSE 63767
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63730: LD_ADDR_EXP 138
63734: PUSH
63735: LD_EXP 138
63739: PPUSH
63740: LD_VAR 0 3
63744: PPUSH
63745: LD_EXP 138
63749: PUSH
63750: LD_VAR 0 3
63754: ARRAY
63755: PUSH
63756: LD_VAR 0 1
63760: DIFF
63761: PPUSH
63762: CALL_OW 1
63766: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63767: LD_VAR 0 1
63771: PUSH
63772: LD_EXP 125
63776: PUSH
63777: LD_VAR 0 3
63781: ARRAY
63782: IN
63783: IFFALSE 63822
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63785: LD_ADDR_EXP 125
63789: PUSH
63790: LD_EXP 125
63794: PPUSH
63795: LD_VAR 0 3
63799: PPUSH
63800: LD_EXP 125
63804: PUSH
63805: LD_VAR 0 3
63809: ARRAY
63810: PUSH
63811: LD_VAR 0 1
63815: DIFF
63816: PPUSH
63817: CALL_OW 1
63821: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63822: LD_VAR 0 1
63826: PUSH
63827: LD_EXP 124
63831: PUSH
63832: LD_VAR 0 3
63836: ARRAY
63837: IN
63838: IFFALSE 63877
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63840: LD_ADDR_EXP 124
63844: PUSH
63845: LD_EXP 124
63849: PPUSH
63850: LD_VAR 0 3
63854: PPUSH
63855: LD_EXP 124
63859: PUSH
63860: LD_VAR 0 3
63864: ARRAY
63865: PUSH
63866: LD_VAR 0 1
63870: DIFF
63871: PPUSH
63872: CALL_OW 1
63876: ST_TO_ADDR
// end ; break ;
63877: GO 63881
// end ;
63879: GO 62527
63881: POP
63882: POP
// end ;
63883: LD_VAR 0 2
63887: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63888: LD_INT 0
63890: PPUSH
63891: PPUSH
63892: PPUSH
// if not mc_bases or not skirmish then
63893: LD_EXP 116
63897: NOT
63898: PUSH
63899: LD_EXP 114
63903: NOT
63904: OR
63905: IFFALSE 63909
// exit ;
63907: GO 64124
// for i = 1 to mc_bases do
63909: LD_ADDR_VAR 0 3
63913: PUSH
63914: DOUBLE
63915: LD_INT 1
63917: DEC
63918: ST_TO_ADDR
63919: LD_EXP 116
63923: PUSH
63924: FOR_TO
63925: IFFALSE 64122
// begin if building in mc_construct_list [ i ] then
63927: LD_VAR 0 1
63931: PUSH
63932: LD_EXP 123
63936: PUSH
63937: LD_VAR 0 3
63941: ARRAY
63942: IN
63943: IFFALSE 64120
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63945: LD_ADDR_EXP 123
63949: PUSH
63950: LD_EXP 123
63954: PPUSH
63955: LD_VAR 0 3
63959: PPUSH
63960: LD_EXP 123
63964: PUSH
63965: LD_VAR 0 3
63969: ARRAY
63970: PUSH
63971: LD_VAR 0 1
63975: DIFF
63976: PPUSH
63977: CALL_OW 1
63981: ST_TO_ADDR
// if building in mc_lab [ i ] then
63982: LD_VAR 0 1
63986: PUSH
63987: LD_EXP 149
63991: PUSH
63992: LD_VAR 0 3
63996: ARRAY
63997: IN
63998: IFFALSE 64053
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64000: LD_ADDR_EXP 150
64004: PUSH
64005: LD_EXP 150
64009: PPUSH
64010: LD_VAR 0 3
64014: PPUSH
64015: LD_EXP 150
64019: PUSH
64020: LD_VAR 0 3
64024: ARRAY
64025: PPUSH
64026: LD_INT 1
64028: PPUSH
64029: LD_EXP 150
64033: PUSH
64034: LD_VAR 0 3
64038: ARRAY
64039: PPUSH
64040: LD_INT 0
64042: PPUSH
64043: CALL 69876 0 4
64047: PPUSH
64048: CALL_OW 1
64052: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64053: LD_VAR 0 1
64057: PUSH
64058: LD_EXP 116
64062: PUSH
64063: LD_VAR 0 3
64067: ARRAY
64068: IN
64069: NOT
64070: IFFALSE 64116
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64072: LD_ADDR_EXP 116
64076: PUSH
64077: LD_EXP 116
64081: PPUSH
64082: LD_VAR 0 3
64086: PUSH
64087: LD_EXP 116
64091: PUSH
64092: LD_VAR 0 3
64096: ARRAY
64097: PUSH
64098: LD_INT 1
64100: PLUS
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PPUSH
64106: LD_VAR 0 1
64110: PPUSH
64111: CALL 70458 0 3
64115: ST_TO_ADDR
// exit ;
64116: POP
64117: POP
64118: GO 64124
// end ; end ;
64120: GO 63924
64122: POP
64123: POP
// end ;
64124: LD_VAR 0 2
64128: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64129: LD_INT 0
64131: PPUSH
64132: PPUSH
64133: PPUSH
64134: PPUSH
64135: PPUSH
64136: PPUSH
64137: PPUSH
// if not mc_bases or not skirmish then
64138: LD_EXP 116
64142: NOT
64143: PUSH
64144: LD_EXP 114
64148: NOT
64149: OR
64150: IFFALSE 64154
// exit ;
64152: GO 64815
// for i = 1 to mc_bases do
64154: LD_ADDR_VAR 0 3
64158: PUSH
64159: DOUBLE
64160: LD_INT 1
64162: DEC
64163: ST_TO_ADDR
64164: LD_EXP 116
64168: PUSH
64169: FOR_TO
64170: IFFALSE 64813
// begin if building in mc_construct_list [ i ] then
64172: LD_VAR 0 1
64176: PUSH
64177: LD_EXP 123
64181: PUSH
64182: LD_VAR 0 3
64186: ARRAY
64187: IN
64188: IFFALSE 64811
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64190: LD_ADDR_EXP 123
64194: PUSH
64195: LD_EXP 123
64199: PPUSH
64200: LD_VAR 0 3
64204: PPUSH
64205: LD_EXP 123
64209: PUSH
64210: LD_VAR 0 3
64214: ARRAY
64215: PUSH
64216: LD_VAR 0 1
64220: DIFF
64221: PPUSH
64222: CALL_OW 1
64226: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64227: LD_ADDR_EXP 116
64231: PUSH
64232: LD_EXP 116
64236: PPUSH
64237: LD_VAR 0 3
64241: PUSH
64242: LD_EXP 116
64246: PUSH
64247: LD_VAR 0 3
64251: ARRAY
64252: PUSH
64253: LD_INT 1
64255: PLUS
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PPUSH
64261: LD_VAR 0 1
64265: PPUSH
64266: CALL 70458 0 3
64270: ST_TO_ADDR
// btype := GetBType ( building ) ;
64271: LD_ADDR_VAR 0 5
64275: PUSH
64276: LD_VAR 0 1
64280: PPUSH
64281: CALL_OW 266
64285: ST_TO_ADDR
// side := GetSide ( building ) ;
64286: LD_ADDR_VAR 0 8
64290: PUSH
64291: LD_VAR 0 1
64295: PPUSH
64296: CALL_OW 255
64300: ST_TO_ADDR
// if btype = b_lab then
64301: LD_VAR 0 5
64305: PUSH
64306: LD_INT 6
64308: EQUAL
64309: IFFALSE 64359
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64311: LD_ADDR_EXP 149
64315: PUSH
64316: LD_EXP 149
64320: PPUSH
64321: LD_VAR 0 3
64325: PUSH
64326: LD_EXP 149
64330: PUSH
64331: LD_VAR 0 3
64335: ARRAY
64336: PUSH
64337: LD_INT 1
64339: PLUS
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: PPUSH
64345: LD_VAR 0 1
64349: PPUSH
64350: CALL 70458 0 3
64354: ST_TO_ADDR
// exit ;
64355: POP
64356: POP
64357: GO 64815
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64359: LD_VAR 0 5
64363: PUSH
64364: LD_INT 0
64366: PUSH
64367: LD_INT 2
64369: PUSH
64370: LD_INT 4
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: LIST
64377: IN
64378: IFFALSE 64502
// begin if btype = b_armoury then
64380: LD_VAR 0 5
64384: PUSH
64385: LD_INT 4
64387: EQUAL
64388: IFFALSE 64398
// btype := b_barracks ;
64390: LD_ADDR_VAR 0 5
64394: PUSH
64395: LD_INT 5
64397: ST_TO_ADDR
// if btype = b_depot then
64398: LD_VAR 0 5
64402: PUSH
64403: LD_INT 0
64405: EQUAL
64406: IFFALSE 64416
// btype := b_warehouse ;
64408: LD_ADDR_VAR 0 5
64412: PUSH
64413: LD_INT 1
64415: ST_TO_ADDR
// if btype = b_workshop then
64416: LD_VAR 0 5
64420: PUSH
64421: LD_INT 2
64423: EQUAL
64424: IFFALSE 64434
// btype := b_factory ;
64426: LD_ADDR_VAR 0 5
64430: PUSH
64431: LD_INT 3
64433: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64434: LD_VAR 0 5
64438: PPUSH
64439: LD_VAR 0 8
64443: PPUSH
64444: CALL_OW 323
64448: PUSH
64449: LD_INT 1
64451: EQUAL
64452: IFFALSE 64498
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64454: LD_ADDR_EXP 148
64458: PUSH
64459: LD_EXP 148
64463: PPUSH
64464: LD_VAR 0 3
64468: PUSH
64469: LD_EXP 148
64473: PUSH
64474: LD_VAR 0 3
64478: ARRAY
64479: PUSH
64480: LD_INT 1
64482: PLUS
64483: PUSH
64484: EMPTY
64485: LIST
64486: LIST
64487: PPUSH
64488: LD_VAR 0 1
64492: PPUSH
64493: CALL 70458 0 3
64497: ST_TO_ADDR
// exit ;
64498: POP
64499: POP
64500: GO 64815
// end ; if btype in [ b_bunker , b_turret ] then
64502: LD_VAR 0 5
64506: PUSH
64507: LD_INT 32
64509: PUSH
64510: LD_INT 33
64512: PUSH
64513: EMPTY
64514: LIST
64515: LIST
64516: IN
64517: IFFALSE 64807
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64519: LD_ADDR_EXP 124
64523: PUSH
64524: LD_EXP 124
64528: PPUSH
64529: LD_VAR 0 3
64533: PUSH
64534: LD_EXP 124
64538: PUSH
64539: LD_VAR 0 3
64543: ARRAY
64544: PUSH
64545: LD_INT 1
64547: PLUS
64548: PUSH
64549: EMPTY
64550: LIST
64551: LIST
64552: PPUSH
64553: LD_VAR 0 1
64557: PPUSH
64558: CALL 70458 0 3
64562: ST_TO_ADDR
// if btype = b_bunker then
64563: LD_VAR 0 5
64567: PUSH
64568: LD_INT 32
64570: EQUAL
64571: IFFALSE 64807
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64573: LD_ADDR_EXP 125
64577: PUSH
64578: LD_EXP 125
64582: PPUSH
64583: LD_VAR 0 3
64587: PUSH
64588: LD_EXP 125
64592: PUSH
64593: LD_VAR 0 3
64597: ARRAY
64598: PUSH
64599: LD_INT 1
64601: PLUS
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PPUSH
64607: LD_VAR 0 1
64611: PPUSH
64612: CALL 70458 0 3
64616: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64617: LD_ADDR_VAR 0 6
64621: PUSH
64622: LD_EXP 116
64626: PUSH
64627: LD_VAR 0 3
64631: ARRAY
64632: PPUSH
64633: LD_INT 25
64635: PUSH
64636: LD_INT 1
64638: PUSH
64639: EMPTY
64640: LIST
64641: LIST
64642: PUSH
64643: LD_INT 3
64645: PUSH
64646: LD_INT 54
64648: PUSH
64649: EMPTY
64650: LIST
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PPUSH
64660: CALL_OW 72
64664: ST_TO_ADDR
// if tmp then
64665: LD_VAR 0 6
64669: IFFALSE 64675
// exit ;
64671: POP
64672: POP
64673: GO 64815
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64675: LD_ADDR_VAR 0 6
64679: PUSH
64680: LD_EXP 116
64684: PUSH
64685: LD_VAR 0 3
64689: ARRAY
64690: PPUSH
64691: LD_INT 2
64693: PUSH
64694: LD_INT 30
64696: PUSH
64697: LD_INT 4
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: PUSH
64704: LD_INT 30
64706: PUSH
64707: LD_INT 5
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: PUSH
64714: EMPTY
64715: LIST
64716: LIST
64717: LIST
64718: PPUSH
64719: CALL_OW 72
64723: ST_TO_ADDR
// if not tmp then
64724: LD_VAR 0 6
64728: NOT
64729: IFFALSE 64735
// exit ;
64731: POP
64732: POP
64733: GO 64815
// for j in tmp do
64735: LD_ADDR_VAR 0 4
64739: PUSH
64740: LD_VAR 0 6
64744: PUSH
64745: FOR_IN
64746: IFFALSE 64805
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64748: LD_ADDR_VAR 0 7
64752: PUSH
64753: LD_VAR 0 4
64757: PPUSH
64758: CALL_OW 313
64762: PPUSH
64763: LD_INT 25
64765: PUSH
64766: LD_INT 1
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PPUSH
64773: CALL_OW 72
64777: ST_TO_ADDR
// if units then
64778: LD_VAR 0 7
64782: IFFALSE 64803
// begin ComExitBuilding ( units [ 1 ] ) ;
64784: LD_VAR 0 7
64788: PUSH
64789: LD_INT 1
64791: ARRAY
64792: PPUSH
64793: CALL_OW 122
// exit ;
64797: POP
64798: POP
64799: POP
64800: POP
64801: GO 64815
// end ; end ;
64803: GO 64745
64805: POP
64806: POP
// end ; end ; exit ;
64807: POP
64808: POP
64809: GO 64815
// end ; end ;
64811: GO 64169
64813: POP
64814: POP
// end ;
64815: LD_VAR 0 2
64819: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64820: LD_INT 0
64822: PPUSH
64823: PPUSH
64824: PPUSH
64825: PPUSH
64826: PPUSH
64827: PPUSH
64828: PPUSH
// if not mc_bases or not skirmish then
64829: LD_EXP 116
64833: NOT
64834: PUSH
64835: LD_EXP 114
64839: NOT
64840: OR
64841: IFFALSE 64845
// exit ;
64843: GO 65110
// btype := GetBType ( building ) ;
64845: LD_ADDR_VAR 0 6
64849: PUSH
64850: LD_VAR 0 1
64854: PPUSH
64855: CALL_OW 266
64859: ST_TO_ADDR
// x := GetX ( building ) ;
64860: LD_ADDR_VAR 0 7
64864: PUSH
64865: LD_VAR 0 1
64869: PPUSH
64870: CALL_OW 250
64874: ST_TO_ADDR
// y := GetY ( building ) ;
64875: LD_ADDR_VAR 0 8
64879: PUSH
64880: LD_VAR 0 1
64884: PPUSH
64885: CALL_OW 251
64889: ST_TO_ADDR
// d := GetDir ( building ) ;
64890: LD_ADDR_VAR 0 9
64894: PUSH
64895: LD_VAR 0 1
64899: PPUSH
64900: CALL_OW 254
64904: ST_TO_ADDR
// for i = 1 to mc_bases do
64905: LD_ADDR_VAR 0 4
64909: PUSH
64910: DOUBLE
64911: LD_INT 1
64913: DEC
64914: ST_TO_ADDR
64915: LD_EXP 116
64919: PUSH
64920: FOR_TO
64921: IFFALSE 65108
// begin if not mc_build_list [ i ] then
64923: LD_EXP 121
64927: PUSH
64928: LD_VAR 0 4
64932: ARRAY
64933: NOT
64934: IFFALSE 64938
// continue ;
64936: GO 64920
// for j := 1 to mc_build_list [ i ] do
64938: LD_ADDR_VAR 0 5
64942: PUSH
64943: DOUBLE
64944: LD_INT 1
64946: DEC
64947: ST_TO_ADDR
64948: LD_EXP 121
64952: PUSH
64953: LD_VAR 0 4
64957: ARRAY
64958: PUSH
64959: FOR_TO
64960: IFFALSE 65104
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
64962: LD_VAR 0 6
64966: PUSH
64967: LD_VAR 0 7
64971: PUSH
64972: LD_VAR 0 8
64976: PUSH
64977: LD_VAR 0 9
64981: PUSH
64982: EMPTY
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: PPUSH
64988: LD_EXP 121
64992: PUSH
64993: LD_VAR 0 4
64997: ARRAY
64998: PUSH
64999: LD_VAR 0 5
65003: ARRAY
65004: PPUSH
65005: CALL 76641 0 2
65009: IFFALSE 65102
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65011: LD_ADDR_EXP 121
65015: PUSH
65016: LD_EXP 121
65020: PPUSH
65021: LD_VAR 0 4
65025: PPUSH
65026: LD_EXP 121
65030: PUSH
65031: LD_VAR 0 4
65035: ARRAY
65036: PPUSH
65037: LD_VAR 0 5
65041: PPUSH
65042: CALL_OW 3
65046: PPUSH
65047: CALL_OW 1
65051: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65052: LD_ADDR_EXP 123
65056: PUSH
65057: LD_EXP 123
65061: PPUSH
65062: LD_VAR 0 4
65066: PUSH
65067: LD_EXP 123
65071: PUSH
65072: LD_VAR 0 4
65076: ARRAY
65077: PUSH
65078: LD_INT 1
65080: PLUS
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PPUSH
65086: LD_VAR 0 1
65090: PPUSH
65091: CALL 70458 0 3
65095: ST_TO_ADDR
// exit ;
65096: POP
65097: POP
65098: POP
65099: POP
65100: GO 65110
// end ;
65102: GO 64959
65104: POP
65105: POP
// end ;
65106: GO 64920
65108: POP
65109: POP
// end ;
65110: LD_VAR 0 3
65114: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65115: LD_INT 0
65117: PPUSH
65118: PPUSH
65119: PPUSH
// if not mc_bases or not skirmish then
65120: LD_EXP 116
65124: NOT
65125: PUSH
65126: LD_EXP 114
65130: NOT
65131: OR
65132: IFFALSE 65136
// exit ;
65134: GO 65326
// for i = 1 to mc_bases do
65136: LD_ADDR_VAR 0 4
65140: PUSH
65141: DOUBLE
65142: LD_INT 1
65144: DEC
65145: ST_TO_ADDR
65146: LD_EXP 116
65150: PUSH
65151: FOR_TO
65152: IFFALSE 65239
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65154: LD_VAR 0 1
65158: PUSH
65159: LD_EXP 124
65163: PUSH
65164: LD_VAR 0 4
65168: ARRAY
65169: IN
65170: PUSH
65171: LD_VAR 0 1
65175: PUSH
65176: LD_EXP 125
65180: PUSH
65181: LD_VAR 0 4
65185: ARRAY
65186: IN
65187: NOT
65188: AND
65189: IFFALSE 65237
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65191: LD_ADDR_EXP 125
65195: PUSH
65196: LD_EXP 125
65200: PPUSH
65201: LD_VAR 0 4
65205: PUSH
65206: LD_EXP 125
65210: PUSH
65211: LD_VAR 0 4
65215: ARRAY
65216: PUSH
65217: LD_INT 1
65219: PLUS
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PPUSH
65225: LD_VAR 0 1
65229: PPUSH
65230: CALL 70458 0 3
65234: ST_TO_ADDR
// break ;
65235: GO 65239
// end ; end ;
65237: GO 65151
65239: POP
65240: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65241: LD_VAR 0 1
65245: PPUSH
65246: CALL_OW 257
65250: PUSH
65251: LD_EXP 142
65255: IN
65256: PUSH
65257: LD_VAR 0 1
65261: PPUSH
65262: CALL_OW 266
65266: PUSH
65267: LD_INT 5
65269: EQUAL
65270: AND
65271: PUSH
65272: LD_VAR 0 2
65276: PPUSH
65277: CALL_OW 110
65281: PUSH
65282: LD_INT 18
65284: NONEQUAL
65285: AND
65286: IFFALSE 65326
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65288: LD_VAR 0 2
65292: PPUSH
65293: CALL_OW 257
65297: PUSH
65298: LD_INT 5
65300: PUSH
65301: LD_INT 8
65303: PUSH
65304: LD_INT 9
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: LIST
65311: IN
65312: IFFALSE 65326
// SetClass ( unit , 1 ) ;
65314: LD_VAR 0 2
65318: PPUSH
65319: LD_INT 1
65321: PPUSH
65322: CALL_OW 336
// end ;
65326: LD_VAR 0 3
65330: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65331: LD_INT 0
65333: PPUSH
65334: PPUSH
// if not mc_bases or not skirmish then
65335: LD_EXP 116
65339: NOT
65340: PUSH
65341: LD_EXP 114
65345: NOT
65346: OR
65347: IFFALSE 65351
// exit ;
65349: GO 65467
// if GetLives ( abandoned_vehicle ) > 250 then
65351: LD_VAR 0 2
65355: PPUSH
65356: CALL_OW 256
65360: PUSH
65361: LD_INT 250
65363: GREATER
65364: IFFALSE 65368
// exit ;
65366: GO 65467
// for i = 1 to mc_bases do
65368: LD_ADDR_VAR 0 6
65372: PUSH
65373: DOUBLE
65374: LD_INT 1
65376: DEC
65377: ST_TO_ADDR
65378: LD_EXP 116
65382: PUSH
65383: FOR_TO
65384: IFFALSE 65465
// begin if driver in mc_bases [ i ] then
65386: LD_VAR 0 1
65390: PUSH
65391: LD_EXP 116
65395: PUSH
65396: LD_VAR 0 6
65400: ARRAY
65401: IN
65402: IFFALSE 65463
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65404: LD_VAR 0 1
65408: PPUSH
65409: LD_EXP 116
65413: PUSH
65414: LD_VAR 0 6
65418: ARRAY
65419: PPUSH
65420: LD_INT 2
65422: PUSH
65423: LD_INT 30
65425: PUSH
65426: LD_INT 0
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: PUSH
65433: LD_INT 30
65435: PUSH
65436: LD_INT 1
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: LIST
65447: PPUSH
65448: CALL_OW 72
65452: PUSH
65453: LD_INT 1
65455: ARRAY
65456: PPUSH
65457: CALL 103077 0 2
// break ;
65461: GO 65465
// end ; end ;
65463: GO 65383
65465: POP
65466: POP
// end ; end_of_file
65467: LD_VAR 0 5
65471: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65472: LD_INT 0
65474: PPUSH
65475: PPUSH
// if exist_mode then
65476: LD_VAR 0 2
65480: IFFALSE 65505
// unit := CreateCharacter ( prefix & ident ) else
65482: LD_ADDR_VAR 0 5
65486: PUSH
65487: LD_VAR 0 3
65491: PUSH
65492: LD_VAR 0 1
65496: STR
65497: PPUSH
65498: CALL_OW 34
65502: ST_TO_ADDR
65503: GO 65520
// unit := NewCharacter ( ident ) ;
65505: LD_ADDR_VAR 0 5
65509: PUSH
65510: LD_VAR 0 1
65514: PPUSH
65515: CALL_OW 25
65519: ST_TO_ADDR
// result := unit ;
65520: LD_ADDR_VAR 0 4
65524: PUSH
65525: LD_VAR 0 5
65529: ST_TO_ADDR
// end ;
65530: LD_VAR 0 4
65534: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65535: LD_INT 0
65537: PPUSH
65538: PPUSH
// if not side or not nation then
65539: LD_VAR 0 1
65543: NOT
65544: PUSH
65545: LD_VAR 0 2
65549: NOT
65550: OR
65551: IFFALSE 65555
// exit ;
65553: GO 66323
// case nation of nation_american :
65555: LD_VAR 0 2
65559: PUSH
65560: LD_INT 1
65562: DOUBLE
65563: EQUAL
65564: IFTRUE 65568
65566: GO 65782
65568: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65569: LD_ADDR_VAR 0 4
65573: PUSH
65574: LD_INT 35
65576: PUSH
65577: LD_INT 45
65579: PUSH
65580: LD_INT 46
65582: PUSH
65583: LD_INT 47
65585: PUSH
65586: LD_INT 82
65588: PUSH
65589: LD_INT 83
65591: PUSH
65592: LD_INT 84
65594: PUSH
65595: LD_INT 85
65597: PUSH
65598: LD_INT 86
65600: PUSH
65601: LD_INT 1
65603: PUSH
65604: LD_INT 2
65606: PUSH
65607: LD_INT 6
65609: PUSH
65610: LD_INT 15
65612: PUSH
65613: LD_INT 16
65615: PUSH
65616: LD_INT 7
65618: PUSH
65619: LD_INT 12
65621: PUSH
65622: LD_INT 13
65624: PUSH
65625: LD_INT 10
65627: PUSH
65628: LD_INT 14
65630: PUSH
65631: LD_INT 20
65633: PUSH
65634: LD_INT 21
65636: PUSH
65637: LD_INT 22
65639: PUSH
65640: LD_INT 25
65642: PUSH
65643: LD_INT 32
65645: PUSH
65646: LD_INT 27
65648: PUSH
65649: LD_INT 36
65651: PUSH
65652: LD_INT 69
65654: PUSH
65655: LD_INT 39
65657: PUSH
65658: LD_INT 34
65660: PUSH
65661: LD_INT 40
65663: PUSH
65664: LD_INT 48
65666: PUSH
65667: LD_INT 49
65669: PUSH
65670: LD_INT 50
65672: PUSH
65673: LD_INT 51
65675: PUSH
65676: LD_INT 52
65678: PUSH
65679: LD_INT 53
65681: PUSH
65682: LD_INT 54
65684: PUSH
65685: LD_INT 55
65687: PUSH
65688: LD_INT 56
65690: PUSH
65691: LD_INT 57
65693: PUSH
65694: LD_INT 58
65696: PUSH
65697: LD_INT 59
65699: PUSH
65700: LD_INT 60
65702: PUSH
65703: LD_INT 61
65705: PUSH
65706: LD_INT 62
65708: PUSH
65709: LD_INT 80
65711: PUSH
65712: LD_INT 82
65714: PUSH
65715: LD_INT 83
65717: PUSH
65718: LD_INT 84
65720: PUSH
65721: LD_INT 85
65723: PUSH
65724: LD_INT 86
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: LIST
65731: LIST
65732: LIST
65733: LIST
65734: LIST
65735: LIST
65736: LIST
65737: LIST
65738: LIST
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: LIST
65744: LIST
65745: LIST
65746: LIST
65747: LIST
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: LIST
65755: LIST
65756: LIST
65757: LIST
65758: LIST
65759: LIST
65760: LIST
65761: LIST
65762: LIST
65763: LIST
65764: LIST
65765: LIST
65766: LIST
65767: LIST
65768: LIST
65769: LIST
65770: LIST
65771: LIST
65772: LIST
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: ST_TO_ADDR
65780: GO 66247
65782: LD_INT 2
65784: DOUBLE
65785: EQUAL
65786: IFTRUE 65790
65788: GO 66016
65790: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
65791: LD_ADDR_VAR 0 4
65795: PUSH
65796: LD_INT 35
65798: PUSH
65799: LD_INT 45
65801: PUSH
65802: LD_INT 46
65804: PUSH
65805: LD_INT 47
65807: PUSH
65808: LD_INT 82
65810: PUSH
65811: LD_INT 83
65813: PUSH
65814: LD_INT 84
65816: PUSH
65817: LD_INT 85
65819: PUSH
65820: LD_INT 87
65822: PUSH
65823: LD_INT 70
65825: PUSH
65826: LD_INT 1
65828: PUSH
65829: LD_INT 11
65831: PUSH
65832: LD_INT 3
65834: PUSH
65835: LD_INT 4
65837: PUSH
65838: LD_INT 5
65840: PUSH
65841: LD_INT 6
65843: PUSH
65844: LD_INT 15
65846: PUSH
65847: LD_INT 18
65849: PUSH
65850: LD_INT 7
65852: PUSH
65853: LD_INT 17
65855: PUSH
65856: LD_INT 8
65858: PUSH
65859: LD_INT 20
65861: PUSH
65862: LD_INT 21
65864: PUSH
65865: LD_INT 22
65867: PUSH
65868: LD_INT 72
65870: PUSH
65871: LD_INT 26
65873: PUSH
65874: LD_INT 69
65876: PUSH
65877: LD_INT 39
65879: PUSH
65880: LD_INT 40
65882: PUSH
65883: LD_INT 41
65885: PUSH
65886: LD_INT 42
65888: PUSH
65889: LD_INT 43
65891: PUSH
65892: LD_INT 48
65894: PUSH
65895: LD_INT 49
65897: PUSH
65898: LD_INT 50
65900: PUSH
65901: LD_INT 51
65903: PUSH
65904: LD_INT 52
65906: PUSH
65907: LD_INT 53
65909: PUSH
65910: LD_INT 54
65912: PUSH
65913: LD_INT 55
65915: PUSH
65916: LD_INT 56
65918: PUSH
65919: LD_INT 60
65921: PUSH
65922: LD_INT 61
65924: PUSH
65925: LD_INT 62
65927: PUSH
65928: LD_INT 66
65930: PUSH
65931: LD_INT 67
65933: PUSH
65934: LD_INT 68
65936: PUSH
65937: LD_INT 81
65939: PUSH
65940: LD_INT 82
65942: PUSH
65943: LD_INT 83
65945: PUSH
65946: LD_INT 84
65948: PUSH
65949: LD_INT 85
65951: PUSH
65952: LD_INT 87
65954: PUSH
65955: LD_INT 88
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: LIST
65997: LIST
65998: LIST
65999: LIST
66000: LIST
66001: LIST
66002: LIST
66003: LIST
66004: LIST
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: ST_TO_ADDR
66014: GO 66247
66016: LD_INT 3
66018: DOUBLE
66019: EQUAL
66020: IFTRUE 66024
66022: GO 66246
66024: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66025: LD_ADDR_VAR 0 4
66029: PUSH
66030: LD_INT 46
66032: PUSH
66033: LD_INT 47
66035: PUSH
66036: LD_INT 1
66038: PUSH
66039: LD_INT 2
66041: PUSH
66042: LD_INT 82
66044: PUSH
66045: LD_INT 83
66047: PUSH
66048: LD_INT 84
66050: PUSH
66051: LD_INT 85
66053: PUSH
66054: LD_INT 86
66056: PUSH
66057: LD_INT 11
66059: PUSH
66060: LD_INT 9
66062: PUSH
66063: LD_INT 20
66065: PUSH
66066: LD_INT 19
66068: PUSH
66069: LD_INT 21
66071: PUSH
66072: LD_INT 24
66074: PUSH
66075: LD_INT 22
66077: PUSH
66078: LD_INT 25
66080: PUSH
66081: LD_INT 28
66083: PUSH
66084: LD_INT 29
66086: PUSH
66087: LD_INT 30
66089: PUSH
66090: LD_INT 31
66092: PUSH
66093: LD_INT 37
66095: PUSH
66096: LD_INT 38
66098: PUSH
66099: LD_INT 32
66101: PUSH
66102: LD_INT 27
66104: PUSH
66105: LD_INT 33
66107: PUSH
66108: LD_INT 69
66110: PUSH
66111: LD_INT 39
66113: PUSH
66114: LD_INT 34
66116: PUSH
66117: LD_INT 40
66119: PUSH
66120: LD_INT 71
66122: PUSH
66123: LD_INT 23
66125: PUSH
66126: LD_INT 44
66128: PUSH
66129: LD_INT 48
66131: PUSH
66132: LD_INT 49
66134: PUSH
66135: LD_INT 50
66137: PUSH
66138: LD_INT 51
66140: PUSH
66141: LD_INT 52
66143: PUSH
66144: LD_INT 53
66146: PUSH
66147: LD_INT 54
66149: PUSH
66150: LD_INT 55
66152: PUSH
66153: LD_INT 56
66155: PUSH
66156: LD_INT 57
66158: PUSH
66159: LD_INT 58
66161: PUSH
66162: LD_INT 59
66164: PUSH
66165: LD_INT 63
66167: PUSH
66168: LD_INT 64
66170: PUSH
66171: LD_INT 65
66173: PUSH
66174: LD_INT 82
66176: PUSH
66177: LD_INT 83
66179: PUSH
66180: LD_INT 84
66182: PUSH
66183: LD_INT 85
66185: PUSH
66186: LD_INT 86
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: LIST
66223: LIST
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: ST_TO_ADDR
66244: GO 66247
66246: POP
// if state > - 1 and state < 3 then
66247: LD_VAR 0 3
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: GREATER
66256: PUSH
66257: LD_VAR 0 3
66261: PUSH
66262: LD_INT 3
66264: LESS
66265: AND
66266: IFFALSE 66323
// for i in result do
66268: LD_ADDR_VAR 0 5
66272: PUSH
66273: LD_VAR 0 4
66277: PUSH
66278: FOR_IN
66279: IFFALSE 66321
// if GetTech ( i , side ) <> state then
66281: LD_VAR 0 5
66285: PPUSH
66286: LD_VAR 0 1
66290: PPUSH
66291: CALL_OW 321
66295: PUSH
66296: LD_VAR 0 3
66300: NONEQUAL
66301: IFFALSE 66319
// result := result diff i ;
66303: LD_ADDR_VAR 0 4
66307: PUSH
66308: LD_VAR 0 4
66312: PUSH
66313: LD_VAR 0 5
66317: DIFF
66318: ST_TO_ADDR
66319: GO 66278
66321: POP
66322: POP
// end ;
66323: LD_VAR 0 4
66327: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66328: LD_INT 0
66330: PPUSH
66331: PPUSH
66332: PPUSH
// result := true ;
66333: LD_ADDR_VAR 0 3
66337: PUSH
66338: LD_INT 1
66340: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66341: LD_ADDR_VAR 0 5
66345: PUSH
66346: LD_VAR 0 2
66350: PPUSH
66351: CALL_OW 480
66355: ST_TO_ADDR
// if not tmp then
66356: LD_VAR 0 5
66360: NOT
66361: IFFALSE 66365
// exit ;
66363: GO 66414
// for i in tmp do
66365: LD_ADDR_VAR 0 4
66369: PUSH
66370: LD_VAR 0 5
66374: PUSH
66375: FOR_IN
66376: IFFALSE 66412
// if GetTech ( i , side ) <> state_researched then
66378: LD_VAR 0 4
66382: PPUSH
66383: LD_VAR 0 1
66387: PPUSH
66388: CALL_OW 321
66392: PUSH
66393: LD_INT 2
66395: NONEQUAL
66396: IFFALSE 66410
// begin result := false ;
66398: LD_ADDR_VAR 0 3
66402: PUSH
66403: LD_INT 0
66405: ST_TO_ADDR
// exit ;
66406: POP
66407: POP
66408: GO 66414
// end ;
66410: GO 66375
66412: POP
66413: POP
// end ;
66414: LD_VAR 0 3
66418: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66419: LD_INT 0
66421: PPUSH
66422: PPUSH
66423: PPUSH
66424: PPUSH
66425: PPUSH
66426: PPUSH
66427: PPUSH
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
66433: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66434: LD_VAR 0 1
66438: NOT
66439: PUSH
66440: LD_VAR 0 1
66444: PPUSH
66445: CALL_OW 257
66449: PUSH
66450: LD_INT 9
66452: NONEQUAL
66453: OR
66454: IFFALSE 66458
// exit ;
66456: GO 67031
// side := GetSide ( unit ) ;
66458: LD_ADDR_VAR 0 9
66462: PUSH
66463: LD_VAR 0 1
66467: PPUSH
66468: CALL_OW 255
66472: ST_TO_ADDR
// tech_space := tech_spacanom ;
66473: LD_ADDR_VAR 0 12
66477: PUSH
66478: LD_INT 29
66480: ST_TO_ADDR
// tech_time := tech_taurad ;
66481: LD_ADDR_VAR 0 13
66485: PUSH
66486: LD_INT 28
66488: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66489: LD_ADDR_VAR 0 11
66493: PUSH
66494: LD_VAR 0 1
66498: PPUSH
66499: CALL_OW 310
66503: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66504: LD_VAR 0 11
66508: PPUSH
66509: CALL_OW 247
66513: PUSH
66514: LD_INT 2
66516: EQUAL
66517: IFFALSE 66521
// exit ;
66519: GO 67031
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66521: LD_ADDR_VAR 0 8
66525: PUSH
66526: LD_INT 81
66528: PUSH
66529: LD_VAR 0 9
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: PUSH
66538: LD_INT 3
66540: PUSH
66541: LD_INT 21
66543: PUSH
66544: LD_INT 3
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PPUSH
66559: CALL_OW 69
66563: ST_TO_ADDR
// if not tmp then
66564: LD_VAR 0 8
66568: NOT
66569: IFFALSE 66573
// exit ;
66571: GO 67031
// if in_unit then
66573: LD_VAR 0 11
66577: IFFALSE 66601
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66579: LD_ADDR_VAR 0 10
66583: PUSH
66584: LD_VAR 0 8
66588: PPUSH
66589: LD_VAR 0 11
66593: PPUSH
66594: CALL_OW 74
66598: ST_TO_ADDR
66599: GO 66621
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66601: LD_ADDR_VAR 0 10
66605: PUSH
66606: LD_VAR 0 8
66610: PPUSH
66611: LD_VAR 0 1
66615: PPUSH
66616: CALL_OW 74
66620: ST_TO_ADDR
// if not enemy then
66621: LD_VAR 0 10
66625: NOT
66626: IFFALSE 66630
// exit ;
66628: GO 67031
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66630: LD_VAR 0 11
66634: PUSH
66635: LD_VAR 0 11
66639: PPUSH
66640: LD_VAR 0 10
66644: PPUSH
66645: CALL_OW 296
66649: PUSH
66650: LD_INT 13
66652: GREATER
66653: AND
66654: PUSH
66655: LD_VAR 0 1
66659: PPUSH
66660: LD_VAR 0 10
66664: PPUSH
66665: CALL_OW 296
66669: PUSH
66670: LD_INT 12
66672: GREATER
66673: OR
66674: IFFALSE 66678
// exit ;
66676: GO 67031
// missile := [ 1 ] ;
66678: LD_ADDR_VAR 0 14
66682: PUSH
66683: LD_INT 1
66685: PUSH
66686: EMPTY
66687: LIST
66688: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66689: LD_VAR 0 9
66693: PPUSH
66694: LD_VAR 0 12
66698: PPUSH
66699: CALL_OW 325
66703: IFFALSE 66732
// missile := Insert ( missile , missile + 1 , 2 ) ;
66705: LD_ADDR_VAR 0 14
66709: PUSH
66710: LD_VAR 0 14
66714: PPUSH
66715: LD_VAR 0 14
66719: PUSH
66720: LD_INT 1
66722: PLUS
66723: PPUSH
66724: LD_INT 2
66726: PPUSH
66727: CALL_OW 2
66731: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66732: LD_VAR 0 9
66736: PPUSH
66737: LD_VAR 0 13
66741: PPUSH
66742: CALL_OW 325
66746: PUSH
66747: LD_VAR 0 10
66751: PPUSH
66752: CALL_OW 255
66756: PPUSH
66757: LD_VAR 0 13
66761: PPUSH
66762: CALL_OW 325
66766: NOT
66767: AND
66768: IFFALSE 66797
// missile := Insert ( missile , missile + 1 , 3 ) ;
66770: LD_ADDR_VAR 0 14
66774: PUSH
66775: LD_VAR 0 14
66779: PPUSH
66780: LD_VAR 0 14
66784: PUSH
66785: LD_INT 1
66787: PLUS
66788: PPUSH
66789: LD_INT 3
66791: PPUSH
66792: CALL_OW 2
66796: ST_TO_ADDR
// if missile < 2 then
66797: LD_VAR 0 14
66801: PUSH
66802: LD_INT 2
66804: LESS
66805: IFFALSE 66809
// exit ;
66807: GO 67031
// x := GetX ( enemy ) ;
66809: LD_ADDR_VAR 0 4
66813: PUSH
66814: LD_VAR 0 10
66818: PPUSH
66819: CALL_OW 250
66823: ST_TO_ADDR
// y := GetY ( enemy ) ;
66824: LD_ADDR_VAR 0 5
66828: PUSH
66829: LD_VAR 0 10
66833: PPUSH
66834: CALL_OW 251
66838: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66839: LD_ADDR_VAR 0 6
66843: PUSH
66844: LD_VAR 0 4
66848: PUSH
66849: LD_INT 1
66851: NEG
66852: PPUSH
66853: LD_INT 1
66855: PPUSH
66856: CALL_OW 12
66860: PLUS
66861: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66862: LD_ADDR_VAR 0 7
66866: PUSH
66867: LD_VAR 0 5
66871: PUSH
66872: LD_INT 1
66874: NEG
66875: PPUSH
66876: LD_INT 1
66878: PPUSH
66879: CALL_OW 12
66883: PLUS
66884: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66885: LD_VAR 0 6
66889: PPUSH
66890: LD_VAR 0 7
66894: PPUSH
66895: CALL_OW 488
66899: NOT
66900: IFFALSE 66922
// begin _x := x ;
66902: LD_ADDR_VAR 0 6
66906: PUSH
66907: LD_VAR 0 4
66911: ST_TO_ADDR
// _y := y ;
66912: LD_ADDR_VAR 0 7
66916: PUSH
66917: LD_VAR 0 5
66921: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66922: LD_ADDR_VAR 0 3
66926: PUSH
66927: LD_INT 1
66929: PPUSH
66930: LD_VAR 0 14
66934: PPUSH
66935: CALL_OW 12
66939: ST_TO_ADDR
// case i of 1 :
66940: LD_VAR 0 3
66944: PUSH
66945: LD_INT 1
66947: DOUBLE
66948: EQUAL
66949: IFTRUE 66953
66951: GO 66970
66953: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66954: LD_VAR 0 1
66958: PPUSH
66959: LD_VAR 0 10
66963: PPUSH
66964: CALL_OW 115
66968: GO 67031
66970: LD_INT 2
66972: DOUBLE
66973: EQUAL
66974: IFTRUE 66978
66976: GO 67000
66978: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66979: LD_VAR 0 1
66983: PPUSH
66984: LD_VAR 0 6
66988: PPUSH
66989: LD_VAR 0 7
66993: PPUSH
66994: CALL_OW 153
66998: GO 67031
67000: LD_INT 3
67002: DOUBLE
67003: EQUAL
67004: IFTRUE 67008
67006: GO 67030
67008: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67009: LD_VAR 0 1
67013: PPUSH
67014: LD_VAR 0 6
67018: PPUSH
67019: LD_VAR 0 7
67023: PPUSH
67024: CALL_OW 154
67028: GO 67031
67030: POP
// end ;
67031: LD_VAR 0 2
67035: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67036: LD_INT 0
67038: PPUSH
67039: PPUSH
67040: PPUSH
67041: PPUSH
67042: PPUSH
67043: PPUSH
// if not unit or not building then
67044: LD_VAR 0 1
67048: NOT
67049: PUSH
67050: LD_VAR 0 2
67054: NOT
67055: OR
67056: IFFALSE 67060
// exit ;
67058: GO 67218
// x := GetX ( building ) ;
67060: LD_ADDR_VAR 0 5
67064: PUSH
67065: LD_VAR 0 2
67069: PPUSH
67070: CALL_OW 250
67074: ST_TO_ADDR
// y := GetY ( building ) ;
67075: LD_ADDR_VAR 0 6
67079: PUSH
67080: LD_VAR 0 2
67084: PPUSH
67085: CALL_OW 251
67089: ST_TO_ADDR
// for i = 0 to 5 do
67090: LD_ADDR_VAR 0 4
67094: PUSH
67095: DOUBLE
67096: LD_INT 0
67098: DEC
67099: ST_TO_ADDR
67100: LD_INT 5
67102: PUSH
67103: FOR_TO
67104: IFFALSE 67216
// begin _x := ShiftX ( x , i , 3 ) ;
67106: LD_ADDR_VAR 0 7
67110: PUSH
67111: LD_VAR 0 5
67115: PPUSH
67116: LD_VAR 0 4
67120: PPUSH
67121: LD_INT 3
67123: PPUSH
67124: CALL_OW 272
67128: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67129: LD_ADDR_VAR 0 8
67133: PUSH
67134: LD_VAR 0 6
67138: PPUSH
67139: LD_VAR 0 4
67143: PPUSH
67144: LD_INT 3
67146: PPUSH
67147: CALL_OW 273
67151: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67152: LD_VAR 0 7
67156: PPUSH
67157: LD_VAR 0 8
67161: PPUSH
67162: CALL_OW 488
67166: NOT
67167: IFFALSE 67171
// continue ;
67169: GO 67103
// if HexInfo ( _x , _y ) = 0 then
67171: LD_VAR 0 7
67175: PPUSH
67176: LD_VAR 0 8
67180: PPUSH
67181: CALL_OW 428
67185: PUSH
67186: LD_INT 0
67188: EQUAL
67189: IFFALSE 67214
// begin ComMoveXY ( unit , _x , _y ) ;
67191: LD_VAR 0 1
67195: PPUSH
67196: LD_VAR 0 7
67200: PPUSH
67201: LD_VAR 0 8
67205: PPUSH
67206: CALL_OW 111
// exit ;
67210: POP
67211: POP
67212: GO 67218
// end ; end ;
67214: GO 67103
67216: POP
67217: POP
// end ;
67218: LD_VAR 0 3
67222: RET
// export function ScanBase ( side , base_area ) ; begin
67223: LD_INT 0
67225: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67226: LD_ADDR_VAR 0 3
67230: PUSH
67231: LD_VAR 0 2
67235: PPUSH
67236: LD_INT 81
67238: PUSH
67239: LD_VAR 0 1
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PPUSH
67248: CALL_OW 70
67252: ST_TO_ADDR
// end ;
67253: LD_VAR 0 3
67257: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67258: LD_INT 0
67260: PPUSH
67261: PPUSH
67262: PPUSH
67263: PPUSH
// result := false ;
67264: LD_ADDR_VAR 0 2
67268: PUSH
67269: LD_INT 0
67271: ST_TO_ADDR
// side := GetSide ( unit ) ;
67272: LD_ADDR_VAR 0 3
67276: PUSH
67277: LD_VAR 0 1
67281: PPUSH
67282: CALL_OW 255
67286: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67287: LD_ADDR_VAR 0 4
67291: PUSH
67292: LD_VAR 0 1
67296: PPUSH
67297: CALL_OW 248
67301: ST_TO_ADDR
// case nat of 1 :
67302: LD_VAR 0 4
67306: PUSH
67307: LD_INT 1
67309: DOUBLE
67310: EQUAL
67311: IFTRUE 67315
67313: GO 67326
67315: POP
// tech := tech_lassight ; 2 :
67316: LD_ADDR_VAR 0 5
67320: PUSH
67321: LD_INT 12
67323: ST_TO_ADDR
67324: GO 67365
67326: LD_INT 2
67328: DOUBLE
67329: EQUAL
67330: IFTRUE 67334
67332: GO 67345
67334: POP
// tech := tech_mortar ; 3 :
67335: LD_ADDR_VAR 0 5
67339: PUSH
67340: LD_INT 41
67342: ST_TO_ADDR
67343: GO 67365
67345: LD_INT 3
67347: DOUBLE
67348: EQUAL
67349: IFTRUE 67353
67351: GO 67364
67353: POP
// tech := tech_bazooka ; end ;
67354: LD_ADDR_VAR 0 5
67358: PUSH
67359: LD_INT 44
67361: ST_TO_ADDR
67362: GO 67365
67364: POP
// if Researched ( side , tech ) then
67365: LD_VAR 0 3
67369: PPUSH
67370: LD_VAR 0 5
67374: PPUSH
67375: CALL_OW 325
67379: IFFALSE 67406
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67381: LD_ADDR_VAR 0 2
67385: PUSH
67386: LD_INT 5
67388: PUSH
67389: LD_INT 8
67391: PUSH
67392: LD_INT 9
67394: PUSH
67395: EMPTY
67396: LIST
67397: LIST
67398: LIST
67399: PUSH
67400: LD_VAR 0 4
67404: ARRAY
67405: ST_TO_ADDR
// end ;
67406: LD_VAR 0 2
67410: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67411: LD_INT 0
67413: PPUSH
67414: PPUSH
67415: PPUSH
// if not mines then
67416: LD_VAR 0 2
67420: NOT
67421: IFFALSE 67425
// exit ;
67423: GO 67569
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67425: LD_ADDR_VAR 0 5
67429: PUSH
67430: LD_INT 81
67432: PUSH
67433: LD_VAR 0 1
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 3
67444: PUSH
67445: LD_INT 21
67447: PUSH
67448: LD_INT 3
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: PUSH
67459: EMPTY
67460: LIST
67461: LIST
67462: PPUSH
67463: CALL_OW 69
67467: ST_TO_ADDR
// for i in mines do
67468: LD_ADDR_VAR 0 4
67472: PUSH
67473: LD_VAR 0 2
67477: PUSH
67478: FOR_IN
67479: IFFALSE 67567
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67481: LD_VAR 0 4
67485: PUSH
67486: LD_INT 1
67488: ARRAY
67489: PPUSH
67490: LD_VAR 0 4
67494: PUSH
67495: LD_INT 2
67497: ARRAY
67498: PPUSH
67499: CALL_OW 458
67503: NOT
67504: IFFALSE 67508
// continue ;
67506: GO 67478
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67508: LD_VAR 0 4
67512: PUSH
67513: LD_INT 1
67515: ARRAY
67516: PPUSH
67517: LD_VAR 0 4
67521: PUSH
67522: LD_INT 2
67524: ARRAY
67525: PPUSH
67526: CALL_OW 428
67530: PUSH
67531: LD_VAR 0 5
67535: IN
67536: IFFALSE 67565
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67538: LD_VAR 0 4
67542: PUSH
67543: LD_INT 1
67545: ARRAY
67546: PPUSH
67547: LD_VAR 0 4
67551: PUSH
67552: LD_INT 2
67554: ARRAY
67555: PPUSH
67556: LD_VAR 0 1
67560: PPUSH
67561: CALL_OW 456
// end ;
67565: GO 67478
67567: POP
67568: POP
// end ;
67569: LD_VAR 0 3
67573: RET
// export function Count ( array ) ; var i ; begin
67574: LD_INT 0
67576: PPUSH
67577: PPUSH
// result := 0 ;
67578: LD_ADDR_VAR 0 2
67582: PUSH
67583: LD_INT 0
67585: ST_TO_ADDR
// for i in array do
67586: LD_ADDR_VAR 0 3
67590: PUSH
67591: LD_VAR 0 1
67595: PUSH
67596: FOR_IN
67597: IFFALSE 67621
// if i then
67599: LD_VAR 0 3
67603: IFFALSE 67619
// result := result + 1 ;
67605: LD_ADDR_VAR 0 2
67609: PUSH
67610: LD_VAR 0 2
67614: PUSH
67615: LD_INT 1
67617: PLUS
67618: ST_TO_ADDR
67619: GO 67596
67621: POP
67622: POP
// end ;
67623: LD_VAR 0 2
67627: RET
// export function IsEmpty ( building ) ; begin
67628: LD_INT 0
67630: PPUSH
// if not building then
67631: LD_VAR 0 1
67635: NOT
67636: IFFALSE 67640
// exit ;
67638: GO 67683
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67640: LD_ADDR_VAR 0 2
67644: PUSH
67645: LD_VAR 0 1
67649: PUSH
67650: LD_INT 22
67652: PUSH
67653: LD_VAR 0 1
67657: PPUSH
67658: CALL_OW 255
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: PUSH
67667: LD_INT 58
67669: PUSH
67670: EMPTY
67671: LIST
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PPUSH
67677: CALL_OW 69
67681: IN
67682: ST_TO_ADDR
// end ;
67683: LD_VAR 0 2
67687: RET
// export function IsNotFull ( building ) ; begin
67688: LD_INT 0
67690: PPUSH
// if not building then
67691: LD_VAR 0 1
67695: NOT
67696: IFFALSE 67700
// exit ;
67698: GO 67719
// result := UnitsInside ( building ) < 6 ;
67700: LD_ADDR_VAR 0 2
67704: PUSH
67705: LD_VAR 0 1
67709: PPUSH
67710: CALL_OW 313
67714: PUSH
67715: LD_INT 6
67717: LESS
67718: ST_TO_ADDR
// end ;
67719: LD_VAR 0 2
67723: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67724: LD_INT 0
67726: PPUSH
67727: PPUSH
67728: PPUSH
67729: PPUSH
// tmp := [ ] ;
67730: LD_ADDR_VAR 0 3
67734: PUSH
67735: EMPTY
67736: ST_TO_ADDR
// list := [ ] ;
67737: LD_ADDR_VAR 0 5
67741: PUSH
67742: EMPTY
67743: ST_TO_ADDR
// for i = 16 to 25 do
67744: LD_ADDR_VAR 0 4
67748: PUSH
67749: DOUBLE
67750: LD_INT 16
67752: DEC
67753: ST_TO_ADDR
67754: LD_INT 25
67756: PUSH
67757: FOR_TO
67758: IFFALSE 67831
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67760: LD_ADDR_VAR 0 3
67764: PUSH
67765: LD_VAR 0 3
67769: PUSH
67770: LD_INT 22
67772: PUSH
67773: LD_VAR 0 1
67777: PPUSH
67778: CALL_OW 255
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: LD_INT 91
67789: PUSH
67790: LD_VAR 0 1
67794: PUSH
67795: LD_INT 6
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 30
67805: PUSH
67806: LD_VAR 0 4
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: LIST
67819: PUSH
67820: EMPTY
67821: LIST
67822: PPUSH
67823: CALL_OW 69
67827: ADD
67828: ST_TO_ADDR
67829: GO 67757
67831: POP
67832: POP
// for i = 1 to tmp do
67833: LD_ADDR_VAR 0 4
67837: PUSH
67838: DOUBLE
67839: LD_INT 1
67841: DEC
67842: ST_TO_ADDR
67843: LD_VAR 0 3
67847: PUSH
67848: FOR_TO
67849: IFFALSE 67937
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67851: LD_ADDR_VAR 0 5
67855: PUSH
67856: LD_VAR 0 5
67860: PUSH
67861: LD_VAR 0 3
67865: PUSH
67866: LD_VAR 0 4
67870: ARRAY
67871: PPUSH
67872: CALL_OW 266
67876: PUSH
67877: LD_VAR 0 3
67881: PUSH
67882: LD_VAR 0 4
67886: ARRAY
67887: PPUSH
67888: CALL_OW 250
67892: PUSH
67893: LD_VAR 0 3
67897: PUSH
67898: LD_VAR 0 4
67902: ARRAY
67903: PPUSH
67904: CALL_OW 251
67908: PUSH
67909: LD_VAR 0 3
67913: PUSH
67914: LD_VAR 0 4
67918: ARRAY
67919: PPUSH
67920: CALL_OW 254
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: PUSH
67931: EMPTY
67932: LIST
67933: ADD
67934: ST_TO_ADDR
67935: GO 67848
67937: POP
67938: POP
// result := list ;
67939: LD_ADDR_VAR 0 2
67943: PUSH
67944: LD_VAR 0 5
67948: ST_TO_ADDR
// end ;
67949: LD_VAR 0 2
67953: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67954: LD_INT 0
67956: PPUSH
67957: PPUSH
67958: PPUSH
67959: PPUSH
67960: PPUSH
67961: PPUSH
67962: PPUSH
// if not factory then
67963: LD_VAR 0 1
67967: NOT
67968: IFFALSE 67972
// exit ;
67970: GO 68565
// if control = control_apeman then
67972: LD_VAR 0 4
67976: PUSH
67977: LD_INT 5
67979: EQUAL
67980: IFFALSE 68089
// begin tmp := UnitsInside ( factory ) ;
67982: LD_ADDR_VAR 0 8
67986: PUSH
67987: LD_VAR 0 1
67991: PPUSH
67992: CALL_OW 313
67996: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67997: LD_VAR 0 8
68001: PPUSH
68002: LD_INT 25
68004: PUSH
68005: LD_INT 12
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PPUSH
68012: CALL_OW 72
68016: NOT
68017: IFFALSE 68027
// control := control_manual ;
68019: LD_ADDR_VAR 0 4
68023: PUSH
68024: LD_INT 1
68026: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68027: LD_ADDR_VAR 0 8
68031: PUSH
68032: LD_VAR 0 1
68036: PPUSH
68037: CALL 67724 0 1
68041: ST_TO_ADDR
// if tmp then
68042: LD_VAR 0 8
68046: IFFALSE 68089
// begin for i in tmp do
68048: LD_ADDR_VAR 0 7
68052: PUSH
68053: LD_VAR 0 8
68057: PUSH
68058: FOR_IN
68059: IFFALSE 68087
// if i [ 1 ] = b_ext_radio then
68061: LD_VAR 0 7
68065: PUSH
68066: LD_INT 1
68068: ARRAY
68069: PUSH
68070: LD_INT 22
68072: EQUAL
68073: IFFALSE 68085
// begin control := control_remote ;
68075: LD_ADDR_VAR 0 4
68079: PUSH
68080: LD_INT 2
68082: ST_TO_ADDR
// break ;
68083: GO 68087
// end ;
68085: GO 68058
68087: POP
68088: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68089: LD_VAR 0 1
68093: PPUSH
68094: LD_VAR 0 2
68098: PPUSH
68099: LD_VAR 0 3
68103: PPUSH
68104: LD_VAR 0 4
68108: PPUSH
68109: LD_VAR 0 5
68113: PPUSH
68114: CALL_OW 448
68118: IFFALSE 68153
// begin result := [ chassis , engine , control , weapon ] ;
68120: LD_ADDR_VAR 0 6
68124: PUSH
68125: LD_VAR 0 2
68129: PUSH
68130: LD_VAR 0 3
68134: PUSH
68135: LD_VAR 0 4
68139: PUSH
68140: LD_VAR 0 5
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: ST_TO_ADDR
// exit ;
68151: GO 68565
// end ; _chassis := AvailableChassisList ( factory ) ;
68153: LD_ADDR_VAR 0 9
68157: PUSH
68158: LD_VAR 0 1
68162: PPUSH
68163: CALL_OW 475
68167: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68168: LD_ADDR_VAR 0 11
68172: PUSH
68173: LD_VAR 0 1
68177: PPUSH
68178: CALL_OW 476
68182: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68183: LD_ADDR_VAR 0 12
68187: PUSH
68188: LD_VAR 0 1
68192: PPUSH
68193: CALL_OW 477
68197: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68198: LD_ADDR_VAR 0 10
68202: PUSH
68203: LD_VAR 0 1
68207: PPUSH
68208: CALL_OW 478
68212: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68213: LD_VAR 0 9
68217: NOT
68218: PUSH
68219: LD_VAR 0 11
68223: NOT
68224: OR
68225: PUSH
68226: LD_VAR 0 12
68230: NOT
68231: OR
68232: PUSH
68233: LD_VAR 0 10
68237: NOT
68238: OR
68239: IFFALSE 68274
// begin result := [ chassis , engine , control , weapon ] ;
68241: LD_ADDR_VAR 0 6
68245: PUSH
68246: LD_VAR 0 2
68250: PUSH
68251: LD_VAR 0 3
68255: PUSH
68256: LD_VAR 0 4
68260: PUSH
68261: LD_VAR 0 5
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: ST_TO_ADDR
// exit ;
68272: GO 68565
// end ; if not chassis in _chassis then
68274: LD_VAR 0 2
68278: PUSH
68279: LD_VAR 0 9
68283: IN
68284: NOT
68285: IFFALSE 68311
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68287: LD_ADDR_VAR 0 2
68291: PUSH
68292: LD_VAR 0 9
68296: PUSH
68297: LD_INT 1
68299: PPUSH
68300: LD_VAR 0 9
68304: PPUSH
68305: CALL_OW 12
68309: ARRAY
68310: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68311: LD_VAR 0 2
68315: PPUSH
68316: LD_VAR 0 3
68320: PPUSH
68321: CALL 68570 0 2
68325: NOT
68326: IFFALSE 68385
// repeat engine := _engine [ 1 ] ;
68328: LD_ADDR_VAR 0 3
68332: PUSH
68333: LD_VAR 0 11
68337: PUSH
68338: LD_INT 1
68340: ARRAY
68341: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68342: LD_ADDR_VAR 0 11
68346: PUSH
68347: LD_VAR 0 11
68351: PPUSH
68352: LD_INT 1
68354: PPUSH
68355: CALL_OW 3
68359: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68360: LD_VAR 0 2
68364: PPUSH
68365: LD_VAR 0 3
68369: PPUSH
68370: CALL 68570 0 2
68374: PUSH
68375: LD_VAR 0 11
68379: PUSH
68380: EMPTY
68381: EQUAL
68382: OR
68383: IFFALSE 68328
// if not control in _control then
68385: LD_VAR 0 4
68389: PUSH
68390: LD_VAR 0 12
68394: IN
68395: NOT
68396: IFFALSE 68422
// control := _control [ rand ( 1 , _control ) ] ;
68398: LD_ADDR_VAR 0 4
68402: PUSH
68403: LD_VAR 0 12
68407: PUSH
68408: LD_INT 1
68410: PPUSH
68411: LD_VAR 0 12
68415: PPUSH
68416: CALL_OW 12
68420: ARRAY
68421: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68422: LD_VAR 0 2
68426: PPUSH
68427: LD_VAR 0 5
68431: PPUSH
68432: CALL 68790 0 2
68436: NOT
68437: IFFALSE 68496
// repeat weapon := _weapon [ 1 ] ;
68439: LD_ADDR_VAR 0 5
68443: PUSH
68444: LD_VAR 0 10
68448: PUSH
68449: LD_INT 1
68451: ARRAY
68452: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68453: LD_ADDR_VAR 0 10
68457: PUSH
68458: LD_VAR 0 10
68462: PPUSH
68463: LD_INT 1
68465: PPUSH
68466: CALL_OW 3
68470: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68471: LD_VAR 0 2
68475: PPUSH
68476: LD_VAR 0 5
68480: PPUSH
68481: CALL 68790 0 2
68485: PUSH
68486: LD_VAR 0 10
68490: PUSH
68491: EMPTY
68492: EQUAL
68493: OR
68494: IFFALSE 68439
// result := [ ] ;
68496: LD_ADDR_VAR 0 6
68500: PUSH
68501: EMPTY
68502: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68503: LD_VAR 0 1
68507: PPUSH
68508: LD_VAR 0 2
68512: PPUSH
68513: LD_VAR 0 3
68517: PPUSH
68518: LD_VAR 0 4
68522: PPUSH
68523: LD_VAR 0 5
68527: PPUSH
68528: CALL_OW 448
68532: IFFALSE 68565
// result := [ chassis , engine , control , weapon ] ;
68534: LD_ADDR_VAR 0 6
68538: PUSH
68539: LD_VAR 0 2
68543: PUSH
68544: LD_VAR 0 3
68548: PUSH
68549: LD_VAR 0 4
68553: PUSH
68554: LD_VAR 0 5
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: LIST
68563: LIST
68564: ST_TO_ADDR
// end ;
68565: LD_VAR 0 6
68569: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68570: LD_INT 0
68572: PPUSH
// if not chassis or not engine then
68573: LD_VAR 0 1
68577: NOT
68578: PUSH
68579: LD_VAR 0 2
68583: NOT
68584: OR
68585: IFFALSE 68589
// exit ;
68587: GO 68785
// case engine of engine_solar :
68589: LD_VAR 0 2
68593: PUSH
68594: LD_INT 2
68596: DOUBLE
68597: EQUAL
68598: IFTRUE 68602
68600: GO 68640
68602: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68603: LD_ADDR_VAR 0 3
68607: PUSH
68608: LD_INT 11
68610: PUSH
68611: LD_INT 12
68613: PUSH
68614: LD_INT 13
68616: PUSH
68617: LD_INT 14
68619: PUSH
68620: LD_INT 1
68622: PUSH
68623: LD_INT 2
68625: PUSH
68626: LD_INT 3
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: ST_TO_ADDR
68638: GO 68769
68640: LD_INT 1
68642: DOUBLE
68643: EQUAL
68644: IFTRUE 68648
68646: GO 68710
68648: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68649: LD_ADDR_VAR 0 3
68653: PUSH
68654: LD_INT 11
68656: PUSH
68657: LD_INT 12
68659: PUSH
68660: LD_INT 13
68662: PUSH
68663: LD_INT 14
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: LD_INT 2
68671: PUSH
68672: LD_INT 3
68674: PUSH
68675: LD_INT 4
68677: PUSH
68678: LD_INT 5
68680: PUSH
68681: LD_INT 21
68683: PUSH
68684: LD_INT 23
68686: PUSH
68687: LD_INT 22
68689: PUSH
68690: LD_INT 24
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: ST_TO_ADDR
68708: GO 68769
68710: LD_INT 3
68712: DOUBLE
68713: EQUAL
68714: IFTRUE 68718
68716: GO 68768
68718: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68719: LD_ADDR_VAR 0 3
68723: PUSH
68724: LD_INT 13
68726: PUSH
68727: LD_INT 14
68729: PUSH
68730: LD_INT 2
68732: PUSH
68733: LD_INT 3
68735: PUSH
68736: LD_INT 4
68738: PUSH
68739: LD_INT 5
68741: PUSH
68742: LD_INT 21
68744: PUSH
68745: LD_INT 22
68747: PUSH
68748: LD_INT 23
68750: PUSH
68751: LD_INT 24
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: ST_TO_ADDR
68766: GO 68769
68768: POP
// result := ( chassis in result ) ;
68769: LD_ADDR_VAR 0 3
68773: PUSH
68774: LD_VAR 0 1
68778: PUSH
68779: LD_VAR 0 3
68783: IN
68784: ST_TO_ADDR
// end ;
68785: LD_VAR 0 3
68789: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68790: LD_INT 0
68792: PPUSH
// if not chassis or not weapon then
68793: LD_VAR 0 1
68797: NOT
68798: PUSH
68799: LD_VAR 0 2
68803: NOT
68804: OR
68805: IFFALSE 68809
// exit ;
68807: GO 69871
// case weapon of us_machine_gun :
68809: LD_VAR 0 2
68813: PUSH
68814: LD_INT 2
68816: DOUBLE
68817: EQUAL
68818: IFTRUE 68822
68820: GO 68852
68822: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68823: LD_ADDR_VAR 0 3
68827: PUSH
68828: LD_INT 1
68830: PUSH
68831: LD_INT 2
68833: PUSH
68834: LD_INT 3
68836: PUSH
68837: LD_INT 4
68839: PUSH
68840: LD_INT 5
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: ST_TO_ADDR
68850: GO 69855
68852: LD_INT 3
68854: DOUBLE
68855: EQUAL
68856: IFTRUE 68860
68858: GO 68890
68860: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68861: LD_ADDR_VAR 0 3
68865: PUSH
68866: LD_INT 1
68868: PUSH
68869: LD_INT 2
68871: PUSH
68872: LD_INT 3
68874: PUSH
68875: LD_INT 4
68877: PUSH
68878: LD_INT 5
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: LIST
68885: LIST
68886: LIST
68887: ST_TO_ADDR
68888: GO 69855
68890: LD_INT 11
68892: DOUBLE
68893: EQUAL
68894: IFTRUE 68898
68896: GO 68928
68898: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68899: LD_ADDR_VAR 0 3
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: LD_INT 2
68909: PUSH
68910: LD_INT 3
68912: PUSH
68913: LD_INT 4
68915: PUSH
68916: LD_INT 5
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: LIST
68923: LIST
68924: LIST
68925: ST_TO_ADDR
68926: GO 69855
68928: LD_INT 4
68930: DOUBLE
68931: EQUAL
68932: IFTRUE 68936
68934: GO 68962
68936: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68937: LD_ADDR_VAR 0 3
68941: PUSH
68942: LD_INT 2
68944: PUSH
68945: LD_INT 3
68947: PUSH
68948: LD_INT 4
68950: PUSH
68951: LD_INT 5
68953: PUSH
68954: EMPTY
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: ST_TO_ADDR
68960: GO 69855
68962: LD_INT 5
68964: DOUBLE
68965: EQUAL
68966: IFTRUE 68970
68968: GO 68996
68970: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68971: LD_ADDR_VAR 0 3
68975: PUSH
68976: LD_INT 2
68978: PUSH
68979: LD_INT 3
68981: PUSH
68982: LD_INT 4
68984: PUSH
68985: LD_INT 5
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: ST_TO_ADDR
68994: GO 69855
68996: LD_INT 9
68998: DOUBLE
68999: EQUAL
69000: IFTRUE 69004
69002: GO 69030
69004: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69005: LD_ADDR_VAR 0 3
69009: PUSH
69010: LD_INT 2
69012: PUSH
69013: LD_INT 3
69015: PUSH
69016: LD_INT 4
69018: PUSH
69019: LD_INT 5
69021: PUSH
69022: EMPTY
69023: LIST
69024: LIST
69025: LIST
69026: LIST
69027: ST_TO_ADDR
69028: GO 69855
69030: LD_INT 7
69032: DOUBLE
69033: EQUAL
69034: IFTRUE 69038
69036: GO 69064
69038: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69039: LD_ADDR_VAR 0 3
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: LD_INT 3
69049: PUSH
69050: LD_INT 4
69052: PUSH
69053: LD_INT 5
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: ST_TO_ADDR
69062: GO 69855
69064: LD_INT 12
69066: DOUBLE
69067: EQUAL
69068: IFTRUE 69072
69070: GO 69098
69072: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69073: LD_ADDR_VAR 0 3
69077: PUSH
69078: LD_INT 2
69080: PUSH
69081: LD_INT 3
69083: PUSH
69084: LD_INT 4
69086: PUSH
69087: LD_INT 5
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: ST_TO_ADDR
69096: GO 69855
69098: LD_INT 13
69100: DOUBLE
69101: EQUAL
69102: IFTRUE 69106
69104: GO 69132
69106: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69107: LD_ADDR_VAR 0 3
69111: PUSH
69112: LD_INT 2
69114: PUSH
69115: LD_INT 3
69117: PUSH
69118: LD_INT 4
69120: PUSH
69121: LD_INT 5
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: ST_TO_ADDR
69130: GO 69855
69132: LD_INT 14
69134: DOUBLE
69135: EQUAL
69136: IFTRUE 69140
69138: GO 69158
69140: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69141: LD_ADDR_VAR 0 3
69145: PUSH
69146: LD_INT 4
69148: PUSH
69149: LD_INT 5
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: ST_TO_ADDR
69156: GO 69855
69158: LD_INT 6
69160: DOUBLE
69161: EQUAL
69162: IFTRUE 69166
69164: GO 69184
69166: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69167: LD_ADDR_VAR 0 3
69171: PUSH
69172: LD_INT 4
69174: PUSH
69175: LD_INT 5
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: ST_TO_ADDR
69182: GO 69855
69184: LD_INT 10
69186: DOUBLE
69187: EQUAL
69188: IFTRUE 69192
69190: GO 69210
69192: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69193: LD_ADDR_VAR 0 3
69197: PUSH
69198: LD_INT 4
69200: PUSH
69201: LD_INT 5
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: ST_TO_ADDR
69208: GO 69855
69210: LD_INT 22
69212: DOUBLE
69213: EQUAL
69214: IFTRUE 69218
69216: GO 69244
69218: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69219: LD_ADDR_VAR 0 3
69223: PUSH
69224: LD_INT 11
69226: PUSH
69227: LD_INT 12
69229: PUSH
69230: LD_INT 13
69232: PUSH
69233: LD_INT 14
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: LIST
69240: LIST
69241: ST_TO_ADDR
69242: GO 69855
69244: LD_INT 23
69246: DOUBLE
69247: EQUAL
69248: IFTRUE 69252
69250: GO 69278
69252: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69253: LD_ADDR_VAR 0 3
69257: PUSH
69258: LD_INT 11
69260: PUSH
69261: LD_INT 12
69263: PUSH
69264: LD_INT 13
69266: PUSH
69267: LD_INT 14
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: LIST
69274: LIST
69275: ST_TO_ADDR
69276: GO 69855
69278: LD_INT 24
69280: DOUBLE
69281: EQUAL
69282: IFTRUE 69286
69284: GO 69312
69286: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69287: LD_ADDR_VAR 0 3
69291: PUSH
69292: LD_INT 11
69294: PUSH
69295: LD_INT 12
69297: PUSH
69298: LD_INT 13
69300: PUSH
69301: LD_INT 14
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: ST_TO_ADDR
69310: GO 69855
69312: LD_INT 30
69314: DOUBLE
69315: EQUAL
69316: IFTRUE 69320
69318: GO 69346
69320: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69321: LD_ADDR_VAR 0 3
69325: PUSH
69326: LD_INT 11
69328: PUSH
69329: LD_INT 12
69331: PUSH
69332: LD_INT 13
69334: PUSH
69335: LD_INT 14
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: ST_TO_ADDR
69344: GO 69855
69346: LD_INT 25
69348: DOUBLE
69349: EQUAL
69350: IFTRUE 69354
69352: GO 69372
69354: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69355: LD_ADDR_VAR 0 3
69359: PUSH
69360: LD_INT 13
69362: PUSH
69363: LD_INT 14
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: ST_TO_ADDR
69370: GO 69855
69372: LD_INT 27
69374: DOUBLE
69375: EQUAL
69376: IFTRUE 69380
69378: GO 69398
69380: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69381: LD_ADDR_VAR 0 3
69385: PUSH
69386: LD_INT 13
69388: PUSH
69389: LD_INT 14
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: ST_TO_ADDR
69396: GO 69855
69398: LD_EXP 100
69402: DOUBLE
69403: EQUAL
69404: IFTRUE 69408
69406: GO 69434
69408: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69409: LD_ADDR_VAR 0 3
69413: PUSH
69414: LD_INT 11
69416: PUSH
69417: LD_INT 12
69419: PUSH
69420: LD_INT 13
69422: PUSH
69423: LD_INT 14
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: ST_TO_ADDR
69432: GO 69855
69434: LD_INT 28
69436: DOUBLE
69437: EQUAL
69438: IFTRUE 69442
69440: GO 69460
69442: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69443: LD_ADDR_VAR 0 3
69447: PUSH
69448: LD_INT 13
69450: PUSH
69451: LD_INT 14
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: ST_TO_ADDR
69458: GO 69855
69460: LD_INT 29
69462: DOUBLE
69463: EQUAL
69464: IFTRUE 69468
69466: GO 69486
69468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69469: LD_ADDR_VAR 0 3
69473: PUSH
69474: LD_INT 13
69476: PUSH
69477: LD_INT 14
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: ST_TO_ADDR
69484: GO 69855
69486: LD_INT 31
69488: DOUBLE
69489: EQUAL
69490: IFTRUE 69494
69492: GO 69512
69494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69495: LD_ADDR_VAR 0 3
69499: PUSH
69500: LD_INT 13
69502: PUSH
69503: LD_INT 14
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: ST_TO_ADDR
69510: GO 69855
69512: LD_INT 26
69514: DOUBLE
69515: EQUAL
69516: IFTRUE 69520
69518: GO 69538
69520: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69521: LD_ADDR_VAR 0 3
69525: PUSH
69526: LD_INT 13
69528: PUSH
69529: LD_INT 14
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: ST_TO_ADDR
69536: GO 69855
69538: LD_INT 42
69540: DOUBLE
69541: EQUAL
69542: IFTRUE 69546
69544: GO 69572
69546: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69547: LD_ADDR_VAR 0 3
69551: PUSH
69552: LD_INT 21
69554: PUSH
69555: LD_INT 22
69557: PUSH
69558: LD_INT 23
69560: PUSH
69561: LD_INT 24
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: LIST
69568: LIST
69569: ST_TO_ADDR
69570: GO 69855
69572: LD_INT 43
69574: DOUBLE
69575: EQUAL
69576: IFTRUE 69580
69578: GO 69606
69580: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69581: LD_ADDR_VAR 0 3
69585: PUSH
69586: LD_INT 21
69588: PUSH
69589: LD_INT 22
69591: PUSH
69592: LD_INT 23
69594: PUSH
69595: LD_INT 24
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: ST_TO_ADDR
69604: GO 69855
69606: LD_INT 44
69608: DOUBLE
69609: EQUAL
69610: IFTRUE 69614
69612: GO 69640
69614: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69615: LD_ADDR_VAR 0 3
69619: PUSH
69620: LD_INT 21
69622: PUSH
69623: LD_INT 22
69625: PUSH
69626: LD_INT 23
69628: PUSH
69629: LD_INT 24
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: ST_TO_ADDR
69638: GO 69855
69640: LD_INT 45
69642: DOUBLE
69643: EQUAL
69644: IFTRUE 69648
69646: GO 69674
69648: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69649: LD_ADDR_VAR 0 3
69653: PUSH
69654: LD_INT 21
69656: PUSH
69657: LD_INT 22
69659: PUSH
69660: LD_INT 23
69662: PUSH
69663: LD_INT 24
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: ST_TO_ADDR
69672: GO 69855
69674: LD_INT 49
69676: DOUBLE
69677: EQUAL
69678: IFTRUE 69682
69680: GO 69708
69682: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69683: LD_ADDR_VAR 0 3
69687: PUSH
69688: LD_INT 21
69690: PUSH
69691: LD_INT 22
69693: PUSH
69694: LD_INT 23
69696: PUSH
69697: LD_INT 24
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: ST_TO_ADDR
69706: GO 69855
69708: LD_INT 51
69710: DOUBLE
69711: EQUAL
69712: IFTRUE 69716
69714: GO 69742
69716: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69717: LD_ADDR_VAR 0 3
69721: PUSH
69722: LD_INT 21
69724: PUSH
69725: LD_INT 22
69727: PUSH
69728: LD_INT 23
69730: PUSH
69731: LD_INT 24
69733: PUSH
69734: EMPTY
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: ST_TO_ADDR
69740: GO 69855
69742: LD_INT 52
69744: DOUBLE
69745: EQUAL
69746: IFTRUE 69750
69748: GO 69776
69750: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69751: LD_ADDR_VAR 0 3
69755: PUSH
69756: LD_INT 21
69758: PUSH
69759: LD_INT 22
69761: PUSH
69762: LD_INT 23
69764: PUSH
69765: LD_INT 24
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: LIST
69772: LIST
69773: ST_TO_ADDR
69774: GO 69855
69776: LD_INT 53
69778: DOUBLE
69779: EQUAL
69780: IFTRUE 69784
69782: GO 69802
69784: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69785: LD_ADDR_VAR 0 3
69789: PUSH
69790: LD_INT 23
69792: PUSH
69793: LD_INT 24
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: ST_TO_ADDR
69800: GO 69855
69802: LD_INT 46
69804: DOUBLE
69805: EQUAL
69806: IFTRUE 69810
69808: GO 69828
69810: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69811: LD_ADDR_VAR 0 3
69815: PUSH
69816: LD_INT 23
69818: PUSH
69819: LD_INT 24
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: ST_TO_ADDR
69826: GO 69855
69828: LD_INT 47
69830: DOUBLE
69831: EQUAL
69832: IFTRUE 69836
69834: GO 69854
69836: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69837: LD_ADDR_VAR 0 3
69841: PUSH
69842: LD_INT 23
69844: PUSH
69845: LD_INT 24
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: ST_TO_ADDR
69852: GO 69855
69854: POP
// result := ( chassis in result ) ;
69855: LD_ADDR_VAR 0 3
69859: PUSH
69860: LD_VAR 0 1
69864: PUSH
69865: LD_VAR 0 3
69869: IN
69870: ST_TO_ADDR
// end ;
69871: LD_VAR 0 3
69875: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69876: LD_INT 0
69878: PPUSH
69879: PPUSH
69880: PPUSH
69881: PPUSH
69882: PPUSH
69883: PPUSH
69884: PPUSH
// result := array ;
69885: LD_ADDR_VAR 0 5
69889: PUSH
69890: LD_VAR 0 1
69894: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69895: LD_VAR 0 1
69899: NOT
69900: PUSH
69901: LD_VAR 0 2
69905: NOT
69906: OR
69907: PUSH
69908: LD_VAR 0 3
69912: NOT
69913: OR
69914: PUSH
69915: LD_VAR 0 2
69919: PUSH
69920: LD_VAR 0 1
69924: GREATER
69925: OR
69926: PUSH
69927: LD_VAR 0 3
69931: PUSH
69932: LD_VAR 0 1
69936: GREATER
69937: OR
69938: IFFALSE 69942
// exit ;
69940: GO 70238
// if direction then
69942: LD_VAR 0 4
69946: IFFALSE 70010
// begin d := 1 ;
69948: LD_ADDR_VAR 0 9
69952: PUSH
69953: LD_INT 1
69955: ST_TO_ADDR
// if i_from > i_to then
69956: LD_VAR 0 2
69960: PUSH
69961: LD_VAR 0 3
69965: GREATER
69966: IFFALSE 69992
// length := ( array - i_from ) + i_to else
69968: LD_ADDR_VAR 0 11
69972: PUSH
69973: LD_VAR 0 1
69977: PUSH
69978: LD_VAR 0 2
69982: MINUS
69983: PUSH
69984: LD_VAR 0 3
69988: PLUS
69989: ST_TO_ADDR
69990: GO 70008
// length := i_to - i_from ;
69992: LD_ADDR_VAR 0 11
69996: PUSH
69997: LD_VAR 0 3
70001: PUSH
70002: LD_VAR 0 2
70006: MINUS
70007: ST_TO_ADDR
// end else
70008: GO 70071
// begin d := - 1 ;
70010: LD_ADDR_VAR 0 9
70014: PUSH
70015: LD_INT 1
70017: NEG
70018: ST_TO_ADDR
// if i_from > i_to then
70019: LD_VAR 0 2
70023: PUSH
70024: LD_VAR 0 3
70028: GREATER
70029: IFFALSE 70049
// length := i_from - i_to else
70031: LD_ADDR_VAR 0 11
70035: PUSH
70036: LD_VAR 0 2
70040: PUSH
70041: LD_VAR 0 3
70045: MINUS
70046: ST_TO_ADDR
70047: GO 70071
// length := ( array - i_to ) + i_from ;
70049: LD_ADDR_VAR 0 11
70053: PUSH
70054: LD_VAR 0 1
70058: PUSH
70059: LD_VAR 0 3
70063: MINUS
70064: PUSH
70065: LD_VAR 0 2
70069: PLUS
70070: ST_TO_ADDR
// end ; if not length then
70071: LD_VAR 0 11
70075: NOT
70076: IFFALSE 70080
// exit ;
70078: GO 70238
// tmp := array ;
70080: LD_ADDR_VAR 0 10
70084: PUSH
70085: LD_VAR 0 1
70089: ST_TO_ADDR
// for i = 1 to length do
70090: LD_ADDR_VAR 0 6
70094: PUSH
70095: DOUBLE
70096: LD_INT 1
70098: DEC
70099: ST_TO_ADDR
70100: LD_VAR 0 11
70104: PUSH
70105: FOR_TO
70106: IFFALSE 70226
// begin for j = 1 to array do
70108: LD_ADDR_VAR 0 7
70112: PUSH
70113: DOUBLE
70114: LD_INT 1
70116: DEC
70117: ST_TO_ADDR
70118: LD_VAR 0 1
70122: PUSH
70123: FOR_TO
70124: IFFALSE 70212
// begin k := j + d ;
70126: LD_ADDR_VAR 0 8
70130: PUSH
70131: LD_VAR 0 7
70135: PUSH
70136: LD_VAR 0 9
70140: PLUS
70141: ST_TO_ADDR
// if k > array then
70142: LD_VAR 0 8
70146: PUSH
70147: LD_VAR 0 1
70151: GREATER
70152: IFFALSE 70162
// k := 1 ;
70154: LD_ADDR_VAR 0 8
70158: PUSH
70159: LD_INT 1
70161: ST_TO_ADDR
// if not k then
70162: LD_VAR 0 8
70166: NOT
70167: IFFALSE 70179
// k := array ;
70169: LD_ADDR_VAR 0 8
70173: PUSH
70174: LD_VAR 0 1
70178: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70179: LD_ADDR_VAR 0 10
70183: PUSH
70184: LD_VAR 0 10
70188: PPUSH
70189: LD_VAR 0 8
70193: PPUSH
70194: LD_VAR 0 1
70198: PUSH
70199: LD_VAR 0 7
70203: ARRAY
70204: PPUSH
70205: CALL_OW 1
70209: ST_TO_ADDR
// end ;
70210: GO 70123
70212: POP
70213: POP
// array := tmp ;
70214: LD_ADDR_VAR 0 1
70218: PUSH
70219: LD_VAR 0 10
70223: ST_TO_ADDR
// end ;
70224: GO 70105
70226: POP
70227: POP
// result := array ;
70228: LD_ADDR_VAR 0 5
70232: PUSH
70233: LD_VAR 0 1
70237: ST_TO_ADDR
// end ;
70238: LD_VAR 0 5
70242: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70243: LD_INT 0
70245: PPUSH
70246: PPUSH
// result := 0 ;
70247: LD_ADDR_VAR 0 3
70251: PUSH
70252: LD_INT 0
70254: ST_TO_ADDR
// if not array or not value in array then
70255: LD_VAR 0 1
70259: NOT
70260: PUSH
70261: LD_VAR 0 2
70265: PUSH
70266: LD_VAR 0 1
70270: IN
70271: NOT
70272: OR
70273: IFFALSE 70277
// exit ;
70275: GO 70331
// for i = 1 to array do
70277: LD_ADDR_VAR 0 4
70281: PUSH
70282: DOUBLE
70283: LD_INT 1
70285: DEC
70286: ST_TO_ADDR
70287: LD_VAR 0 1
70291: PUSH
70292: FOR_TO
70293: IFFALSE 70329
// if value = array [ i ] then
70295: LD_VAR 0 2
70299: PUSH
70300: LD_VAR 0 1
70304: PUSH
70305: LD_VAR 0 4
70309: ARRAY
70310: EQUAL
70311: IFFALSE 70327
// begin result := i ;
70313: LD_ADDR_VAR 0 3
70317: PUSH
70318: LD_VAR 0 4
70322: ST_TO_ADDR
// exit ;
70323: POP
70324: POP
70325: GO 70331
// end ;
70327: GO 70292
70329: POP
70330: POP
// end ;
70331: LD_VAR 0 3
70335: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70336: LD_INT 0
70338: PPUSH
// vc_chassis := chassis ;
70339: LD_ADDR_OWVAR 37
70343: PUSH
70344: LD_VAR 0 1
70348: ST_TO_ADDR
// vc_engine := engine ;
70349: LD_ADDR_OWVAR 39
70353: PUSH
70354: LD_VAR 0 2
70358: ST_TO_ADDR
// vc_control := control ;
70359: LD_ADDR_OWVAR 38
70363: PUSH
70364: LD_VAR 0 3
70368: ST_TO_ADDR
// vc_weapon := weapon ;
70369: LD_ADDR_OWVAR 40
70373: PUSH
70374: LD_VAR 0 4
70378: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70379: LD_ADDR_OWVAR 41
70383: PUSH
70384: LD_VAR 0 5
70388: ST_TO_ADDR
// end ;
70389: LD_VAR 0 6
70393: RET
// export function WantPlant ( unit ) ; var task ; begin
70394: LD_INT 0
70396: PPUSH
70397: PPUSH
// result := false ;
70398: LD_ADDR_VAR 0 2
70402: PUSH
70403: LD_INT 0
70405: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70406: LD_ADDR_VAR 0 3
70410: PUSH
70411: LD_VAR 0 1
70415: PPUSH
70416: CALL_OW 437
70420: ST_TO_ADDR
// if task then
70421: LD_VAR 0 3
70425: IFFALSE 70453
// if task [ 1 ] [ 1 ] = p then
70427: LD_VAR 0 3
70431: PUSH
70432: LD_INT 1
70434: ARRAY
70435: PUSH
70436: LD_INT 1
70438: ARRAY
70439: PUSH
70440: LD_STRING p
70442: EQUAL
70443: IFFALSE 70453
// result := true ;
70445: LD_ADDR_VAR 0 2
70449: PUSH
70450: LD_INT 1
70452: ST_TO_ADDR
// end ;
70453: LD_VAR 0 2
70457: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70458: LD_INT 0
70460: PPUSH
70461: PPUSH
70462: PPUSH
70463: PPUSH
// if pos < 1 then
70464: LD_VAR 0 2
70468: PUSH
70469: LD_INT 1
70471: LESS
70472: IFFALSE 70476
// exit ;
70474: GO 70779
// if pos = 1 then
70476: LD_VAR 0 2
70480: PUSH
70481: LD_INT 1
70483: EQUAL
70484: IFFALSE 70517
// result := Replace ( arr , pos [ 1 ] , value ) else
70486: LD_ADDR_VAR 0 4
70490: PUSH
70491: LD_VAR 0 1
70495: PPUSH
70496: LD_VAR 0 2
70500: PUSH
70501: LD_INT 1
70503: ARRAY
70504: PPUSH
70505: LD_VAR 0 3
70509: PPUSH
70510: CALL_OW 1
70514: ST_TO_ADDR
70515: GO 70779
// begin tmp := arr ;
70517: LD_ADDR_VAR 0 6
70521: PUSH
70522: LD_VAR 0 1
70526: ST_TO_ADDR
// s_arr := [ tmp ] ;
70527: LD_ADDR_VAR 0 7
70531: PUSH
70532: LD_VAR 0 6
70536: PUSH
70537: EMPTY
70538: LIST
70539: ST_TO_ADDR
// for i = 1 to pos - 1 do
70540: LD_ADDR_VAR 0 5
70544: PUSH
70545: DOUBLE
70546: LD_INT 1
70548: DEC
70549: ST_TO_ADDR
70550: LD_VAR 0 2
70554: PUSH
70555: LD_INT 1
70557: MINUS
70558: PUSH
70559: FOR_TO
70560: IFFALSE 70605
// begin tmp := tmp [ pos [ i ] ] ;
70562: LD_ADDR_VAR 0 6
70566: PUSH
70567: LD_VAR 0 6
70571: PUSH
70572: LD_VAR 0 2
70576: PUSH
70577: LD_VAR 0 5
70581: ARRAY
70582: ARRAY
70583: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70584: LD_ADDR_VAR 0 7
70588: PUSH
70589: LD_VAR 0 7
70593: PUSH
70594: LD_VAR 0 6
70598: PUSH
70599: EMPTY
70600: LIST
70601: ADD
70602: ST_TO_ADDR
// end ;
70603: GO 70559
70605: POP
70606: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70607: LD_ADDR_VAR 0 6
70611: PUSH
70612: LD_VAR 0 6
70616: PPUSH
70617: LD_VAR 0 2
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PPUSH
70628: LD_VAR 0 3
70632: PPUSH
70633: CALL_OW 1
70637: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70638: LD_ADDR_VAR 0 7
70642: PUSH
70643: LD_VAR 0 7
70647: PPUSH
70648: LD_VAR 0 7
70652: PPUSH
70653: LD_VAR 0 6
70657: PPUSH
70658: CALL_OW 1
70662: ST_TO_ADDR
// for i = s_arr downto 2 do
70663: LD_ADDR_VAR 0 5
70667: PUSH
70668: DOUBLE
70669: LD_VAR 0 7
70673: INC
70674: ST_TO_ADDR
70675: LD_INT 2
70677: PUSH
70678: FOR_DOWNTO
70679: IFFALSE 70763
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70681: LD_ADDR_VAR 0 6
70685: PUSH
70686: LD_VAR 0 7
70690: PUSH
70691: LD_VAR 0 5
70695: PUSH
70696: LD_INT 1
70698: MINUS
70699: ARRAY
70700: PPUSH
70701: LD_VAR 0 2
70705: PUSH
70706: LD_VAR 0 5
70710: PUSH
70711: LD_INT 1
70713: MINUS
70714: ARRAY
70715: PPUSH
70716: LD_VAR 0 7
70720: PUSH
70721: LD_VAR 0 5
70725: ARRAY
70726: PPUSH
70727: CALL_OW 1
70731: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70732: LD_ADDR_VAR 0 7
70736: PUSH
70737: LD_VAR 0 7
70741: PPUSH
70742: LD_VAR 0 5
70746: PUSH
70747: LD_INT 1
70749: MINUS
70750: PPUSH
70751: LD_VAR 0 6
70755: PPUSH
70756: CALL_OW 1
70760: ST_TO_ADDR
// end ;
70761: GO 70678
70763: POP
70764: POP
// result := s_arr [ 1 ] ;
70765: LD_ADDR_VAR 0 4
70769: PUSH
70770: LD_VAR 0 7
70774: PUSH
70775: LD_INT 1
70777: ARRAY
70778: ST_TO_ADDR
// end ; end ;
70779: LD_VAR 0 4
70783: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70784: LD_INT 0
70786: PPUSH
70787: PPUSH
// if not list then
70788: LD_VAR 0 1
70792: NOT
70793: IFFALSE 70797
// exit ;
70795: GO 70888
// i := list [ pos1 ] ;
70797: LD_ADDR_VAR 0 5
70801: PUSH
70802: LD_VAR 0 1
70806: PUSH
70807: LD_VAR 0 2
70811: ARRAY
70812: ST_TO_ADDR
// if not i then
70813: LD_VAR 0 5
70817: NOT
70818: IFFALSE 70822
// exit ;
70820: GO 70888
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70822: LD_ADDR_VAR 0 1
70826: PUSH
70827: LD_VAR 0 1
70831: PPUSH
70832: LD_VAR 0 2
70836: PPUSH
70837: LD_VAR 0 1
70841: PUSH
70842: LD_VAR 0 3
70846: ARRAY
70847: PPUSH
70848: CALL_OW 1
70852: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70853: LD_ADDR_VAR 0 1
70857: PUSH
70858: LD_VAR 0 1
70862: PPUSH
70863: LD_VAR 0 3
70867: PPUSH
70868: LD_VAR 0 5
70872: PPUSH
70873: CALL_OW 1
70877: ST_TO_ADDR
// result := list ;
70878: LD_ADDR_VAR 0 4
70882: PUSH
70883: LD_VAR 0 1
70887: ST_TO_ADDR
// end ;
70888: LD_VAR 0 4
70892: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70893: LD_INT 0
70895: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70896: LD_ADDR_VAR 0 5
70900: PUSH
70901: LD_VAR 0 1
70905: PPUSH
70906: CALL_OW 250
70910: PPUSH
70911: LD_VAR 0 1
70915: PPUSH
70916: CALL_OW 251
70920: PPUSH
70921: LD_VAR 0 2
70925: PPUSH
70926: LD_VAR 0 3
70930: PPUSH
70931: LD_VAR 0 4
70935: PPUSH
70936: CALL 70946 0 5
70940: ST_TO_ADDR
// end ;
70941: LD_VAR 0 5
70945: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70946: LD_INT 0
70948: PPUSH
70949: PPUSH
70950: PPUSH
70951: PPUSH
// if not list then
70952: LD_VAR 0 3
70956: NOT
70957: IFFALSE 70961
// exit ;
70959: GO 71349
// result := [ ] ;
70961: LD_ADDR_VAR 0 6
70965: PUSH
70966: EMPTY
70967: ST_TO_ADDR
// for i in list do
70968: LD_ADDR_VAR 0 7
70972: PUSH
70973: LD_VAR 0 3
70977: PUSH
70978: FOR_IN
70979: IFFALSE 71181
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70981: LD_ADDR_VAR 0 9
70985: PUSH
70986: LD_VAR 0 7
70990: PPUSH
70991: LD_VAR 0 1
70995: PPUSH
70996: LD_VAR 0 2
71000: PPUSH
71001: CALL_OW 297
71005: ST_TO_ADDR
// if not result then
71006: LD_VAR 0 6
71010: NOT
71011: IFFALSE 71037
// result := [ [ i , tmp ] ] else
71013: LD_ADDR_VAR 0 6
71017: PUSH
71018: LD_VAR 0 7
71022: PUSH
71023: LD_VAR 0 9
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: EMPTY
71033: LIST
71034: ST_TO_ADDR
71035: GO 71179
// begin if result [ result ] [ 2 ] < tmp then
71037: LD_VAR 0 6
71041: PUSH
71042: LD_VAR 0 6
71046: ARRAY
71047: PUSH
71048: LD_INT 2
71050: ARRAY
71051: PUSH
71052: LD_VAR 0 9
71056: LESS
71057: IFFALSE 71099
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71059: LD_ADDR_VAR 0 6
71063: PUSH
71064: LD_VAR 0 6
71068: PPUSH
71069: LD_VAR 0 6
71073: PUSH
71074: LD_INT 1
71076: PLUS
71077: PPUSH
71078: LD_VAR 0 7
71082: PUSH
71083: LD_VAR 0 9
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PPUSH
71092: CALL_OW 2
71096: ST_TO_ADDR
71097: GO 71179
// for j = 1 to result do
71099: LD_ADDR_VAR 0 8
71103: PUSH
71104: DOUBLE
71105: LD_INT 1
71107: DEC
71108: ST_TO_ADDR
71109: LD_VAR 0 6
71113: PUSH
71114: FOR_TO
71115: IFFALSE 71177
// begin if tmp < result [ j ] [ 2 ] then
71117: LD_VAR 0 9
71121: PUSH
71122: LD_VAR 0 6
71126: PUSH
71127: LD_VAR 0 8
71131: ARRAY
71132: PUSH
71133: LD_INT 2
71135: ARRAY
71136: LESS
71137: IFFALSE 71175
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71139: LD_ADDR_VAR 0 6
71143: PUSH
71144: LD_VAR 0 6
71148: PPUSH
71149: LD_VAR 0 8
71153: PPUSH
71154: LD_VAR 0 7
71158: PUSH
71159: LD_VAR 0 9
71163: PUSH
71164: EMPTY
71165: LIST
71166: LIST
71167: PPUSH
71168: CALL_OW 2
71172: ST_TO_ADDR
// break ;
71173: GO 71177
// end ; end ;
71175: GO 71114
71177: POP
71178: POP
// end ; end ;
71179: GO 70978
71181: POP
71182: POP
// if result and not asc then
71183: LD_VAR 0 6
71187: PUSH
71188: LD_VAR 0 4
71192: NOT
71193: AND
71194: IFFALSE 71269
// begin tmp := result ;
71196: LD_ADDR_VAR 0 9
71200: PUSH
71201: LD_VAR 0 6
71205: ST_TO_ADDR
// for i = tmp downto 1 do
71206: LD_ADDR_VAR 0 7
71210: PUSH
71211: DOUBLE
71212: LD_VAR 0 9
71216: INC
71217: ST_TO_ADDR
71218: LD_INT 1
71220: PUSH
71221: FOR_DOWNTO
71222: IFFALSE 71267
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71224: LD_ADDR_VAR 0 6
71228: PUSH
71229: LD_VAR 0 6
71233: PPUSH
71234: LD_VAR 0 9
71238: PUSH
71239: LD_VAR 0 7
71243: MINUS
71244: PUSH
71245: LD_INT 1
71247: PLUS
71248: PPUSH
71249: LD_VAR 0 9
71253: PUSH
71254: LD_VAR 0 7
71258: ARRAY
71259: PPUSH
71260: CALL_OW 1
71264: ST_TO_ADDR
71265: GO 71221
71267: POP
71268: POP
// end ; tmp := [ ] ;
71269: LD_ADDR_VAR 0 9
71273: PUSH
71274: EMPTY
71275: ST_TO_ADDR
// if mode then
71276: LD_VAR 0 5
71280: IFFALSE 71349
// begin for i = 1 to result do
71282: LD_ADDR_VAR 0 7
71286: PUSH
71287: DOUBLE
71288: LD_INT 1
71290: DEC
71291: ST_TO_ADDR
71292: LD_VAR 0 6
71296: PUSH
71297: FOR_TO
71298: IFFALSE 71337
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71300: LD_ADDR_VAR 0 9
71304: PUSH
71305: LD_VAR 0 9
71309: PPUSH
71310: LD_VAR 0 7
71314: PPUSH
71315: LD_VAR 0 6
71319: PUSH
71320: LD_VAR 0 7
71324: ARRAY
71325: PUSH
71326: LD_INT 1
71328: ARRAY
71329: PPUSH
71330: CALL_OW 1
71334: ST_TO_ADDR
71335: GO 71297
71337: POP
71338: POP
// result := tmp ;
71339: LD_ADDR_VAR 0 6
71343: PUSH
71344: LD_VAR 0 9
71348: ST_TO_ADDR
// end ; end ;
71349: LD_VAR 0 6
71353: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71354: LD_INT 0
71356: PPUSH
71357: PPUSH
71358: PPUSH
71359: PPUSH
71360: PPUSH
71361: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71362: LD_ADDR_VAR 0 5
71366: PUSH
71367: LD_INT 0
71369: PUSH
71370: LD_INT 0
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: EMPTY
71377: PUSH
71378: EMPTY
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: ST_TO_ADDR
// if not x or not y then
71384: LD_VAR 0 2
71388: NOT
71389: PUSH
71390: LD_VAR 0 3
71394: NOT
71395: OR
71396: IFFALSE 71400
// exit ;
71398: GO 73052
// if not range then
71400: LD_VAR 0 4
71404: NOT
71405: IFFALSE 71415
// range := 10 ;
71407: LD_ADDR_VAR 0 4
71411: PUSH
71412: LD_INT 10
71414: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71415: LD_ADDR_VAR 0 8
71419: PUSH
71420: LD_INT 81
71422: PUSH
71423: LD_VAR 0 1
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 92
71434: PUSH
71435: LD_VAR 0 2
71439: PUSH
71440: LD_VAR 0 3
71444: PUSH
71445: LD_VAR 0 4
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 3
71458: PUSH
71459: LD_INT 21
71461: PUSH
71462: LD_INT 3
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: LIST
71477: PPUSH
71478: CALL_OW 69
71482: ST_TO_ADDR
// if not tmp then
71483: LD_VAR 0 8
71487: NOT
71488: IFFALSE 71492
// exit ;
71490: GO 73052
// for i in tmp do
71492: LD_ADDR_VAR 0 6
71496: PUSH
71497: LD_VAR 0 8
71501: PUSH
71502: FOR_IN
71503: IFFALSE 73027
// begin points := [ 0 , 0 , 0 ] ;
71505: LD_ADDR_VAR 0 9
71509: PUSH
71510: LD_INT 0
71512: PUSH
71513: LD_INT 0
71515: PUSH
71516: LD_INT 0
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: LIST
71523: ST_TO_ADDR
// bpoints := 1 ;
71524: LD_ADDR_VAR 0 10
71528: PUSH
71529: LD_INT 1
71531: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71532: LD_VAR 0 6
71536: PPUSH
71537: CALL_OW 247
71541: PUSH
71542: LD_INT 1
71544: DOUBLE
71545: EQUAL
71546: IFTRUE 71550
71548: GO 72128
71550: POP
// begin if GetClass ( i ) = 1 then
71551: LD_VAR 0 6
71555: PPUSH
71556: CALL_OW 257
71560: PUSH
71561: LD_INT 1
71563: EQUAL
71564: IFFALSE 71585
// points := [ 10 , 5 , 3 ] ;
71566: LD_ADDR_VAR 0 9
71570: PUSH
71571: LD_INT 10
71573: PUSH
71574: LD_INT 5
71576: PUSH
71577: LD_INT 3
71579: PUSH
71580: EMPTY
71581: LIST
71582: LIST
71583: LIST
71584: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71585: LD_VAR 0 6
71589: PPUSH
71590: CALL_OW 257
71594: PUSH
71595: LD_INT 2
71597: PUSH
71598: LD_INT 3
71600: PUSH
71601: LD_INT 4
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: LIST
71608: IN
71609: IFFALSE 71630
// points := [ 3 , 2 , 1 ] ;
71611: LD_ADDR_VAR 0 9
71615: PUSH
71616: LD_INT 3
71618: PUSH
71619: LD_INT 2
71621: PUSH
71622: LD_INT 1
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: LIST
71629: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71630: LD_VAR 0 6
71634: PPUSH
71635: CALL_OW 257
71639: PUSH
71640: LD_INT 5
71642: EQUAL
71643: IFFALSE 71664
// points := [ 130 , 5 , 2 ] ;
71645: LD_ADDR_VAR 0 9
71649: PUSH
71650: LD_INT 130
71652: PUSH
71653: LD_INT 5
71655: PUSH
71656: LD_INT 2
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: LIST
71663: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71664: LD_VAR 0 6
71668: PPUSH
71669: CALL_OW 257
71673: PUSH
71674: LD_INT 8
71676: EQUAL
71677: IFFALSE 71698
// points := [ 35 , 35 , 30 ] ;
71679: LD_ADDR_VAR 0 9
71683: PUSH
71684: LD_INT 35
71686: PUSH
71687: LD_INT 35
71689: PUSH
71690: LD_INT 30
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: LIST
71697: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71698: LD_VAR 0 6
71702: PPUSH
71703: CALL_OW 257
71707: PUSH
71708: LD_INT 9
71710: EQUAL
71711: IFFALSE 71732
// points := [ 20 , 55 , 40 ] ;
71713: LD_ADDR_VAR 0 9
71717: PUSH
71718: LD_INT 20
71720: PUSH
71721: LD_INT 55
71723: PUSH
71724: LD_INT 40
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: LIST
71731: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71732: LD_VAR 0 6
71736: PPUSH
71737: CALL_OW 257
71741: PUSH
71742: LD_INT 12
71744: PUSH
71745: LD_INT 16
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: IN
71752: IFFALSE 71773
// points := [ 5 , 3 , 2 ] ;
71754: LD_ADDR_VAR 0 9
71758: PUSH
71759: LD_INT 5
71761: PUSH
71762: LD_INT 3
71764: PUSH
71765: LD_INT 2
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: LIST
71772: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71773: LD_VAR 0 6
71777: PPUSH
71778: CALL_OW 257
71782: PUSH
71783: LD_INT 17
71785: EQUAL
71786: IFFALSE 71807
// points := [ 100 , 50 , 75 ] ;
71788: LD_ADDR_VAR 0 9
71792: PUSH
71793: LD_INT 100
71795: PUSH
71796: LD_INT 50
71798: PUSH
71799: LD_INT 75
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: LIST
71806: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71807: LD_VAR 0 6
71811: PPUSH
71812: CALL_OW 257
71816: PUSH
71817: LD_INT 15
71819: EQUAL
71820: IFFALSE 71841
// points := [ 10 , 5 , 3 ] ;
71822: LD_ADDR_VAR 0 9
71826: PUSH
71827: LD_INT 10
71829: PUSH
71830: LD_INT 5
71832: PUSH
71833: LD_INT 3
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: LIST
71840: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71841: LD_VAR 0 6
71845: PPUSH
71846: CALL_OW 257
71850: PUSH
71851: LD_INT 14
71853: EQUAL
71854: IFFALSE 71875
// points := [ 10 , 0 , 0 ] ;
71856: LD_ADDR_VAR 0 9
71860: PUSH
71861: LD_INT 10
71863: PUSH
71864: LD_INT 0
71866: PUSH
71867: LD_INT 0
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: LIST
71874: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71875: LD_VAR 0 6
71879: PPUSH
71880: CALL_OW 257
71884: PUSH
71885: LD_INT 11
71887: EQUAL
71888: IFFALSE 71909
// points := [ 30 , 10 , 5 ] ;
71890: LD_ADDR_VAR 0 9
71894: PUSH
71895: LD_INT 30
71897: PUSH
71898: LD_INT 10
71900: PUSH
71901: LD_INT 5
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: LIST
71908: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71909: LD_VAR 0 1
71913: PPUSH
71914: LD_INT 5
71916: PPUSH
71917: CALL_OW 321
71921: PUSH
71922: LD_INT 2
71924: EQUAL
71925: IFFALSE 71942
// bpoints := bpoints * 1.8 ;
71927: LD_ADDR_VAR 0 10
71931: PUSH
71932: LD_VAR 0 10
71936: PUSH
71937: LD_REAL  1.80000000000000E+0000
71940: MUL
71941: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71942: LD_VAR 0 6
71946: PPUSH
71947: CALL_OW 257
71951: PUSH
71952: LD_INT 1
71954: PUSH
71955: LD_INT 2
71957: PUSH
71958: LD_INT 3
71960: PUSH
71961: LD_INT 4
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: IN
71970: PUSH
71971: LD_VAR 0 1
71975: PPUSH
71976: LD_INT 51
71978: PPUSH
71979: CALL_OW 321
71983: PUSH
71984: LD_INT 2
71986: EQUAL
71987: AND
71988: IFFALSE 72005
// bpoints := bpoints * 1.2 ;
71990: LD_ADDR_VAR 0 10
71994: PUSH
71995: LD_VAR 0 10
71999: PUSH
72000: LD_REAL  1.20000000000000E+0000
72003: MUL
72004: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72005: LD_VAR 0 6
72009: PPUSH
72010: CALL_OW 257
72014: PUSH
72015: LD_INT 5
72017: PUSH
72018: LD_INT 7
72020: PUSH
72021: LD_INT 9
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: LIST
72028: IN
72029: PUSH
72030: LD_VAR 0 1
72034: PPUSH
72035: LD_INT 52
72037: PPUSH
72038: CALL_OW 321
72042: PUSH
72043: LD_INT 2
72045: EQUAL
72046: AND
72047: IFFALSE 72064
// bpoints := bpoints * 1.5 ;
72049: LD_ADDR_VAR 0 10
72053: PUSH
72054: LD_VAR 0 10
72058: PUSH
72059: LD_REAL  1.50000000000000E+0000
72062: MUL
72063: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72064: LD_VAR 0 1
72068: PPUSH
72069: LD_INT 66
72071: PPUSH
72072: CALL_OW 321
72076: PUSH
72077: LD_INT 2
72079: EQUAL
72080: IFFALSE 72097
// bpoints := bpoints * 1.1 ;
72082: LD_ADDR_VAR 0 10
72086: PUSH
72087: LD_VAR 0 10
72091: PUSH
72092: LD_REAL  1.10000000000000E+0000
72095: MUL
72096: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72097: LD_ADDR_VAR 0 10
72101: PUSH
72102: LD_VAR 0 10
72106: PUSH
72107: LD_VAR 0 6
72111: PPUSH
72112: LD_INT 1
72114: PPUSH
72115: CALL_OW 259
72119: PUSH
72120: LD_REAL  1.15000000000000E+0000
72123: MUL
72124: MUL
72125: ST_TO_ADDR
// end ; unit_vehicle :
72126: GO 72956
72128: LD_INT 2
72130: DOUBLE
72131: EQUAL
72132: IFTRUE 72136
72134: GO 72944
72136: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72137: LD_VAR 0 6
72141: PPUSH
72142: CALL_OW 264
72146: PUSH
72147: LD_INT 2
72149: PUSH
72150: LD_INT 42
72152: PUSH
72153: LD_INT 24
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: LIST
72160: IN
72161: IFFALSE 72182
// points := [ 25 , 5 , 3 ] ;
72163: LD_ADDR_VAR 0 9
72167: PUSH
72168: LD_INT 25
72170: PUSH
72171: LD_INT 5
72173: PUSH
72174: LD_INT 3
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: LIST
72181: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72182: LD_VAR 0 6
72186: PPUSH
72187: CALL_OW 264
72191: PUSH
72192: LD_INT 4
72194: PUSH
72195: LD_INT 43
72197: PUSH
72198: LD_INT 25
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: LIST
72205: IN
72206: IFFALSE 72227
// points := [ 40 , 15 , 5 ] ;
72208: LD_ADDR_VAR 0 9
72212: PUSH
72213: LD_INT 40
72215: PUSH
72216: LD_INT 15
72218: PUSH
72219: LD_INT 5
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: LIST
72226: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72227: LD_VAR 0 6
72231: PPUSH
72232: CALL_OW 264
72236: PUSH
72237: LD_INT 3
72239: PUSH
72240: LD_INT 23
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: IN
72247: IFFALSE 72268
// points := [ 7 , 25 , 8 ] ;
72249: LD_ADDR_VAR 0 9
72253: PUSH
72254: LD_INT 7
72256: PUSH
72257: LD_INT 25
72259: PUSH
72260: LD_INT 8
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: LIST
72267: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72268: LD_VAR 0 6
72272: PPUSH
72273: CALL_OW 264
72277: PUSH
72278: LD_INT 5
72280: PUSH
72281: LD_INT 27
72283: PUSH
72284: LD_INT 44
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: LIST
72291: IN
72292: IFFALSE 72313
// points := [ 14 , 50 , 16 ] ;
72294: LD_ADDR_VAR 0 9
72298: PUSH
72299: LD_INT 14
72301: PUSH
72302: LD_INT 50
72304: PUSH
72305: LD_INT 16
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: LIST
72312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72313: LD_VAR 0 6
72317: PPUSH
72318: CALL_OW 264
72322: PUSH
72323: LD_INT 6
72325: PUSH
72326: LD_INT 46
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: IN
72333: IFFALSE 72354
// points := [ 32 , 120 , 70 ] ;
72335: LD_ADDR_VAR 0 9
72339: PUSH
72340: LD_INT 32
72342: PUSH
72343: LD_INT 120
72345: PUSH
72346: LD_INT 70
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: LIST
72353: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72354: LD_VAR 0 6
72358: PPUSH
72359: CALL_OW 264
72363: PUSH
72364: LD_INT 7
72366: PUSH
72367: LD_INT 28
72369: PUSH
72370: LD_INT 45
72372: PUSH
72373: LD_EXP 100
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: IN
72384: IFFALSE 72405
// points := [ 35 , 20 , 45 ] ;
72386: LD_ADDR_VAR 0 9
72390: PUSH
72391: LD_INT 35
72393: PUSH
72394: LD_INT 20
72396: PUSH
72397: LD_INT 45
72399: PUSH
72400: EMPTY
72401: LIST
72402: LIST
72403: LIST
72404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72405: LD_VAR 0 6
72409: PPUSH
72410: CALL_OW 264
72414: PUSH
72415: LD_INT 47
72417: PUSH
72418: EMPTY
72419: LIST
72420: IN
72421: IFFALSE 72442
// points := [ 67 , 45 , 75 ] ;
72423: LD_ADDR_VAR 0 9
72427: PUSH
72428: LD_INT 67
72430: PUSH
72431: LD_INT 45
72433: PUSH
72434: LD_INT 75
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72442: LD_VAR 0 6
72446: PPUSH
72447: CALL_OW 264
72451: PUSH
72452: LD_INT 26
72454: PUSH
72455: EMPTY
72456: LIST
72457: IN
72458: IFFALSE 72479
// points := [ 120 , 30 , 80 ] ;
72460: LD_ADDR_VAR 0 9
72464: PUSH
72465: LD_INT 120
72467: PUSH
72468: LD_INT 30
72470: PUSH
72471: LD_INT 80
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: LIST
72478: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72479: LD_VAR 0 6
72483: PPUSH
72484: CALL_OW 264
72488: PUSH
72489: LD_INT 22
72491: PUSH
72492: EMPTY
72493: LIST
72494: IN
72495: IFFALSE 72516
// points := [ 40 , 1 , 1 ] ;
72497: LD_ADDR_VAR 0 9
72501: PUSH
72502: LD_INT 40
72504: PUSH
72505: LD_INT 1
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: LIST
72515: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72516: LD_VAR 0 6
72520: PPUSH
72521: CALL_OW 264
72525: PUSH
72526: LD_INT 29
72528: PUSH
72529: EMPTY
72530: LIST
72531: IN
72532: IFFALSE 72553
// points := [ 70 , 200 , 400 ] ;
72534: LD_ADDR_VAR 0 9
72538: PUSH
72539: LD_INT 70
72541: PUSH
72542: LD_INT 200
72544: PUSH
72545: LD_INT 400
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: LIST
72552: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72553: LD_VAR 0 6
72557: PPUSH
72558: CALL_OW 264
72562: PUSH
72563: LD_INT 14
72565: PUSH
72566: LD_INT 53
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: IN
72573: IFFALSE 72594
// points := [ 40 , 10 , 20 ] ;
72575: LD_ADDR_VAR 0 9
72579: PUSH
72580: LD_INT 40
72582: PUSH
72583: LD_INT 10
72585: PUSH
72586: LD_INT 20
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: LIST
72593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72594: LD_VAR 0 6
72598: PPUSH
72599: CALL_OW 264
72603: PUSH
72604: LD_INT 9
72606: PUSH
72607: EMPTY
72608: LIST
72609: IN
72610: IFFALSE 72631
// points := [ 5 , 70 , 20 ] ;
72612: LD_ADDR_VAR 0 9
72616: PUSH
72617: LD_INT 5
72619: PUSH
72620: LD_INT 70
72622: PUSH
72623: LD_INT 20
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: LIST
72630: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72631: LD_VAR 0 6
72635: PPUSH
72636: CALL_OW 264
72640: PUSH
72641: LD_INT 10
72643: PUSH
72644: EMPTY
72645: LIST
72646: IN
72647: IFFALSE 72668
// points := [ 35 , 110 , 70 ] ;
72649: LD_ADDR_VAR 0 9
72653: PUSH
72654: LD_INT 35
72656: PUSH
72657: LD_INT 110
72659: PUSH
72660: LD_INT 70
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: LIST
72667: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72668: LD_VAR 0 6
72672: PPUSH
72673: CALL_OW 265
72677: PUSH
72678: LD_INT 25
72680: EQUAL
72681: IFFALSE 72702
// points := [ 80 , 65 , 100 ] ;
72683: LD_ADDR_VAR 0 9
72687: PUSH
72688: LD_INT 80
72690: PUSH
72691: LD_INT 65
72693: PUSH
72694: LD_INT 100
72696: PUSH
72697: EMPTY
72698: LIST
72699: LIST
72700: LIST
72701: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72702: LD_VAR 0 6
72706: PPUSH
72707: CALL_OW 263
72711: PUSH
72712: LD_INT 1
72714: EQUAL
72715: IFFALSE 72750
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72717: LD_ADDR_VAR 0 10
72721: PUSH
72722: LD_VAR 0 10
72726: PUSH
72727: LD_VAR 0 6
72731: PPUSH
72732: CALL_OW 311
72736: PPUSH
72737: LD_INT 3
72739: PPUSH
72740: CALL_OW 259
72744: PUSH
72745: LD_INT 4
72747: MUL
72748: MUL
72749: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72750: LD_VAR 0 6
72754: PPUSH
72755: CALL_OW 263
72759: PUSH
72760: LD_INT 2
72762: EQUAL
72763: IFFALSE 72814
// begin j := IsControledBy ( i ) ;
72765: LD_ADDR_VAR 0 7
72769: PUSH
72770: LD_VAR 0 6
72774: PPUSH
72775: CALL_OW 312
72779: ST_TO_ADDR
// if j then
72780: LD_VAR 0 7
72784: IFFALSE 72814
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72786: LD_ADDR_VAR 0 10
72790: PUSH
72791: LD_VAR 0 10
72795: PUSH
72796: LD_VAR 0 7
72800: PPUSH
72801: LD_INT 3
72803: PPUSH
72804: CALL_OW 259
72808: PUSH
72809: LD_INT 3
72811: MUL
72812: MUL
72813: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72814: LD_VAR 0 6
72818: PPUSH
72819: CALL_OW 264
72823: PUSH
72824: LD_INT 5
72826: PUSH
72827: LD_INT 6
72829: PUSH
72830: LD_INT 46
72832: PUSH
72833: LD_INT 44
72835: PUSH
72836: LD_INT 47
72838: PUSH
72839: LD_INT 45
72841: PUSH
72842: LD_INT 28
72844: PUSH
72845: LD_INT 7
72847: PUSH
72848: LD_INT 27
72850: PUSH
72851: LD_INT 29
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: IN
72866: PUSH
72867: LD_VAR 0 1
72871: PPUSH
72872: LD_INT 52
72874: PPUSH
72875: CALL_OW 321
72879: PUSH
72880: LD_INT 2
72882: EQUAL
72883: AND
72884: IFFALSE 72901
// bpoints := bpoints * 1.2 ;
72886: LD_ADDR_VAR 0 10
72890: PUSH
72891: LD_VAR 0 10
72895: PUSH
72896: LD_REAL  1.20000000000000E+0000
72899: MUL
72900: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72901: LD_VAR 0 6
72905: PPUSH
72906: CALL_OW 264
72910: PUSH
72911: LD_INT 6
72913: PUSH
72914: LD_INT 46
72916: PUSH
72917: LD_INT 47
72919: PUSH
72920: EMPTY
72921: LIST
72922: LIST
72923: LIST
72924: IN
72925: IFFALSE 72942
// bpoints := bpoints * 1.2 ;
72927: LD_ADDR_VAR 0 10
72931: PUSH
72932: LD_VAR 0 10
72936: PUSH
72937: LD_REAL  1.20000000000000E+0000
72940: MUL
72941: ST_TO_ADDR
// end ; unit_building :
72942: GO 72956
72944: LD_INT 3
72946: DOUBLE
72947: EQUAL
72948: IFTRUE 72952
72950: GO 72955
72952: POP
// ; end ;
72953: GO 72956
72955: POP
// for j = 1 to 3 do
72956: LD_ADDR_VAR 0 7
72960: PUSH
72961: DOUBLE
72962: LD_INT 1
72964: DEC
72965: ST_TO_ADDR
72966: LD_INT 3
72968: PUSH
72969: FOR_TO
72970: IFFALSE 73023
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72972: LD_ADDR_VAR 0 5
72976: PUSH
72977: LD_VAR 0 5
72981: PPUSH
72982: LD_VAR 0 7
72986: PPUSH
72987: LD_VAR 0 5
72991: PUSH
72992: LD_VAR 0 7
72996: ARRAY
72997: PUSH
72998: LD_VAR 0 9
73002: PUSH
73003: LD_VAR 0 7
73007: ARRAY
73008: PUSH
73009: LD_VAR 0 10
73013: MUL
73014: PLUS
73015: PPUSH
73016: CALL_OW 1
73020: ST_TO_ADDR
73021: GO 72969
73023: POP
73024: POP
// end ;
73025: GO 71502
73027: POP
73028: POP
// result := Replace ( result , 4 , tmp ) ;
73029: LD_ADDR_VAR 0 5
73033: PUSH
73034: LD_VAR 0 5
73038: PPUSH
73039: LD_INT 4
73041: PPUSH
73042: LD_VAR 0 8
73046: PPUSH
73047: CALL_OW 1
73051: ST_TO_ADDR
// end ;
73052: LD_VAR 0 5
73056: RET
// export function DangerAtRange ( unit , range ) ; begin
73057: LD_INT 0
73059: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73060: LD_ADDR_VAR 0 3
73064: PUSH
73065: LD_VAR 0 1
73069: PPUSH
73070: CALL_OW 255
73074: PPUSH
73075: LD_VAR 0 1
73079: PPUSH
73080: CALL_OW 250
73084: PPUSH
73085: LD_VAR 0 1
73089: PPUSH
73090: CALL_OW 251
73094: PPUSH
73095: LD_VAR 0 2
73099: PPUSH
73100: CALL 71354 0 4
73104: ST_TO_ADDR
// end ;
73105: LD_VAR 0 3
73109: RET
// export function DangerInArea ( side , area ) ; begin
73110: LD_INT 0
73112: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73113: LD_ADDR_VAR 0 3
73117: PUSH
73118: LD_VAR 0 2
73122: PPUSH
73123: LD_INT 81
73125: PUSH
73126: LD_VAR 0 1
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PPUSH
73135: CALL_OW 70
73139: ST_TO_ADDR
// end ;
73140: LD_VAR 0 3
73144: RET
// export function IsExtension ( b ) ; begin
73145: LD_INT 0
73147: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73148: LD_ADDR_VAR 0 2
73152: PUSH
73153: LD_VAR 0 1
73157: PUSH
73158: LD_INT 23
73160: PUSH
73161: LD_INT 20
73163: PUSH
73164: LD_INT 22
73166: PUSH
73167: LD_INT 17
73169: PUSH
73170: LD_INT 24
73172: PUSH
73173: LD_INT 21
73175: PUSH
73176: LD_INT 19
73178: PUSH
73179: LD_INT 16
73181: PUSH
73182: LD_INT 25
73184: PUSH
73185: LD_INT 18
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: IN
73200: ST_TO_ADDR
// end ;
73201: LD_VAR 0 2
73205: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73206: LD_INT 0
73208: PPUSH
73209: PPUSH
73210: PPUSH
// result := [ ] ;
73211: LD_ADDR_VAR 0 4
73215: PUSH
73216: EMPTY
73217: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73218: LD_ADDR_VAR 0 5
73222: PUSH
73223: LD_VAR 0 2
73227: PPUSH
73228: LD_INT 21
73230: PUSH
73231: LD_INT 3
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PPUSH
73238: CALL_OW 70
73242: ST_TO_ADDR
// if not tmp then
73243: LD_VAR 0 5
73247: NOT
73248: IFFALSE 73252
// exit ;
73250: GO 73316
// if checkLink then
73252: LD_VAR 0 3
73256: IFFALSE 73306
// begin for i in tmp do
73258: LD_ADDR_VAR 0 6
73262: PUSH
73263: LD_VAR 0 5
73267: PUSH
73268: FOR_IN
73269: IFFALSE 73304
// if GetBase ( i ) <> base then
73271: LD_VAR 0 6
73275: PPUSH
73276: CALL_OW 274
73280: PUSH
73281: LD_VAR 0 1
73285: NONEQUAL
73286: IFFALSE 73302
// ComLinkToBase ( base , i ) ;
73288: LD_VAR 0 1
73292: PPUSH
73293: LD_VAR 0 6
73297: PPUSH
73298: CALL_OW 169
73302: GO 73268
73304: POP
73305: POP
// end ; result := tmp ;
73306: LD_ADDR_VAR 0 4
73310: PUSH
73311: LD_VAR 0 5
73315: ST_TO_ADDR
// end ;
73316: LD_VAR 0 4
73320: RET
// export function ComComplete ( units , b ) ; var i ; begin
73321: LD_INT 0
73323: PPUSH
73324: PPUSH
// if not units then
73325: LD_VAR 0 1
73329: NOT
73330: IFFALSE 73334
// exit ;
73332: GO 73424
// for i in units do
73334: LD_ADDR_VAR 0 4
73338: PUSH
73339: LD_VAR 0 1
73343: PUSH
73344: FOR_IN
73345: IFFALSE 73422
// if BuildingStatus ( b ) = bs_build then
73347: LD_VAR 0 2
73351: PPUSH
73352: CALL_OW 461
73356: PUSH
73357: LD_INT 1
73359: EQUAL
73360: IFFALSE 73420
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73362: LD_VAR 0 4
73366: PPUSH
73367: LD_STRING h
73369: PUSH
73370: LD_VAR 0 2
73374: PPUSH
73375: CALL_OW 250
73379: PUSH
73380: LD_VAR 0 2
73384: PPUSH
73385: CALL_OW 251
73389: PUSH
73390: LD_VAR 0 2
73394: PUSH
73395: LD_INT 0
73397: PUSH
73398: LD_INT 0
73400: PUSH
73401: LD_INT 0
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: LIST
73408: LIST
73409: LIST
73410: LIST
73411: LIST
73412: PUSH
73413: EMPTY
73414: LIST
73415: PPUSH
73416: CALL_OW 446
73420: GO 73344
73422: POP
73423: POP
// end ;
73424: LD_VAR 0 3
73428: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73429: LD_INT 0
73431: PPUSH
73432: PPUSH
73433: PPUSH
73434: PPUSH
73435: PPUSH
73436: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73437: LD_VAR 0 1
73441: NOT
73442: PUSH
73443: LD_VAR 0 1
73447: PPUSH
73448: CALL_OW 263
73452: PUSH
73453: LD_INT 2
73455: EQUAL
73456: NOT
73457: OR
73458: IFFALSE 73462
// exit ;
73460: GO 73778
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73462: LD_ADDR_VAR 0 6
73466: PUSH
73467: LD_INT 22
73469: PUSH
73470: LD_VAR 0 1
73474: PPUSH
73475: CALL_OW 255
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 2
73486: PUSH
73487: LD_INT 30
73489: PUSH
73490: LD_INT 36
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: PUSH
73497: LD_INT 34
73499: PUSH
73500: LD_INT 31
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: LIST
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PPUSH
73516: CALL_OW 69
73520: ST_TO_ADDR
// if not tmp then
73521: LD_VAR 0 6
73525: NOT
73526: IFFALSE 73530
// exit ;
73528: GO 73778
// result := [ ] ;
73530: LD_ADDR_VAR 0 2
73534: PUSH
73535: EMPTY
73536: ST_TO_ADDR
// for i in tmp do
73537: LD_ADDR_VAR 0 3
73541: PUSH
73542: LD_VAR 0 6
73546: PUSH
73547: FOR_IN
73548: IFFALSE 73619
// begin t := UnitsInside ( i ) ;
73550: LD_ADDR_VAR 0 4
73554: PUSH
73555: LD_VAR 0 3
73559: PPUSH
73560: CALL_OW 313
73564: ST_TO_ADDR
// if t then
73565: LD_VAR 0 4
73569: IFFALSE 73617
// for j in t do
73571: LD_ADDR_VAR 0 7
73575: PUSH
73576: LD_VAR 0 4
73580: PUSH
73581: FOR_IN
73582: IFFALSE 73615
// result := Insert ( result , result + 1 , j ) ;
73584: LD_ADDR_VAR 0 2
73588: PUSH
73589: LD_VAR 0 2
73593: PPUSH
73594: LD_VAR 0 2
73598: PUSH
73599: LD_INT 1
73601: PLUS
73602: PPUSH
73603: LD_VAR 0 7
73607: PPUSH
73608: CALL_OW 2
73612: ST_TO_ADDR
73613: GO 73581
73615: POP
73616: POP
// end ;
73617: GO 73547
73619: POP
73620: POP
// if not result then
73621: LD_VAR 0 2
73625: NOT
73626: IFFALSE 73630
// exit ;
73628: GO 73778
// mech := result [ 1 ] ;
73630: LD_ADDR_VAR 0 5
73634: PUSH
73635: LD_VAR 0 2
73639: PUSH
73640: LD_INT 1
73642: ARRAY
73643: ST_TO_ADDR
// if result > 1 then
73644: LD_VAR 0 2
73648: PUSH
73649: LD_INT 1
73651: GREATER
73652: IFFALSE 73764
// for i = 2 to result do
73654: LD_ADDR_VAR 0 3
73658: PUSH
73659: DOUBLE
73660: LD_INT 2
73662: DEC
73663: ST_TO_ADDR
73664: LD_VAR 0 2
73668: PUSH
73669: FOR_TO
73670: IFFALSE 73762
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73672: LD_ADDR_VAR 0 4
73676: PUSH
73677: LD_VAR 0 2
73681: PUSH
73682: LD_VAR 0 3
73686: ARRAY
73687: PPUSH
73688: LD_INT 3
73690: PPUSH
73691: CALL_OW 259
73695: PUSH
73696: LD_VAR 0 2
73700: PUSH
73701: LD_VAR 0 3
73705: ARRAY
73706: PPUSH
73707: CALL_OW 432
73711: MINUS
73712: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73713: LD_VAR 0 4
73717: PUSH
73718: LD_VAR 0 5
73722: PPUSH
73723: LD_INT 3
73725: PPUSH
73726: CALL_OW 259
73730: PUSH
73731: LD_VAR 0 5
73735: PPUSH
73736: CALL_OW 432
73740: MINUS
73741: GREATEREQUAL
73742: IFFALSE 73760
// mech := result [ i ] ;
73744: LD_ADDR_VAR 0 5
73748: PUSH
73749: LD_VAR 0 2
73753: PUSH
73754: LD_VAR 0 3
73758: ARRAY
73759: ST_TO_ADDR
// end ;
73760: GO 73669
73762: POP
73763: POP
// ComLinkTo ( vehicle , mech ) ;
73764: LD_VAR 0 1
73768: PPUSH
73769: LD_VAR 0 5
73773: PPUSH
73774: CALL_OW 135
// end ;
73778: LD_VAR 0 2
73782: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73783: LD_INT 0
73785: PPUSH
73786: PPUSH
73787: PPUSH
73788: PPUSH
73789: PPUSH
73790: PPUSH
73791: PPUSH
73792: PPUSH
73793: PPUSH
73794: PPUSH
73795: PPUSH
73796: PPUSH
73797: PPUSH
// result := [ ] ;
73798: LD_ADDR_VAR 0 7
73802: PUSH
73803: EMPTY
73804: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73805: LD_VAR 0 1
73809: PPUSH
73810: CALL_OW 266
73814: PUSH
73815: LD_INT 0
73817: PUSH
73818: LD_INT 1
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: IN
73825: NOT
73826: IFFALSE 73830
// exit ;
73828: GO 75464
// if name then
73830: LD_VAR 0 3
73834: IFFALSE 73850
// SetBName ( base_dep , name ) ;
73836: LD_VAR 0 1
73840: PPUSH
73841: LD_VAR 0 3
73845: PPUSH
73846: CALL_OW 500
// base := GetBase ( base_dep ) ;
73850: LD_ADDR_VAR 0 15
73854: PUSH
73855: LD_VAR 0 1
73859: PPUSH
73860: CALL_OW 274
73864: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73865: LD_ADDR_VAR 0 16
73869: PUSH
73870: LD_VAR 0 1
73874: PPUSH
73875: CALL_OW 255
73879: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73880: LD_ADDR_VAR 0 17
73884: PUSH
73885: LD_VAR 0 1
73889: PPUSH
73890: CALL_OW 248
73894: ST_TO_ADDR
// if sources then
73895: LD_VAR 0 5
73899: IFFALSE 73946
// for i = 1 to 3 do
73901: LD_ADDR_VAR 0 8
73905: PUSH
73906: DOUBLE
73907: LD_INT 1
73909: DEC
73910: ST_TO_ADDR
73911: LD_INT 3
73913: PUSH
73914: FOR_TO
73915: IFFALSE 73944
// AddResourceType ( base , i , sources [ i ] ) ;
73917: LD_VAR 0 15
73921: PPUSH
73922: LD_VAR 0 8
73926: PPUSH
73927: LD_VAR 0 5
73931: PUSH
73932: LD_VAR 0 8
73936: ARRAY
73937: PPUSH
73938: CALL_OW 276
73942: GO 73914
73944: POP
73945: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
73946: LD_ADDR_VAR 0 18
73950: PUSH
73951: LD_VAR 0 15
73955: PPUSH
73956: LD_VAR 0 2
73960: PPUSH
73961: LD_INT 1
73963: PPUSH
73964: CALL 73206 0 3
73968: ST_TO_ADDR
// InitHc ;
73969: CALL_OW 19
// InitUc ;
73973: CALL_OW 18
// uc_side := side ;
73977: LD_ADDR_OWVAR 20
73981: PUSH
73982: LD_VAR 0 16
73986: ST_TO_ADDR
// uc_nation := nation ;
73987: LD_ADDR_OWVAR 21
73991: PUSH
73992: LD_VAR 0 17
73996: ST_TO_ADDR
// if buildings then
73997: LD_VAR 0 18
74001: IFFALSE 75323
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74003: LD_ADDR_VAR 0 19
74007: PUSH
74008: LD_VAR 0 18
74012: PPUSH
74013: LD_INT 2
74015: PUSH
74016: LD_INT 30
74018: PUSH
74019: LD_INT 29
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: LD_INT 30
74028: PUSH
74029: LD_INT 30
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: LIST
74040: PPUSH
74041: CALL_OW 72
74045: ST_TO_ADDR
// if tmp then
74046: LD_VAR 0 19
74050: IFFALSE 74098
// for i in tmp do
74052: LD_ADDR_VAR 0 8
74056: PUSH
74057: LD_VAR 0 19
74061: PUSH
74062: FOR_IN
74063: IFFALSE 74096
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74065: LD_VAR 0 8
74069: PPUSH
74070: CALL_OW 250
74074: PPUSH
74075: LD_VAR 0 8
74079: PPUSH
74080: CALL_OW 251
74084: PPUSH
74085: LD_VAR 0 16
74089: PPUSH
74090: CALL_OW 441
74094: GO 74062
74096: POP
74097: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74098: LD_VAR 0 18
74102: PPUSH
74103: LD_INT 2
74105: PUSH
74106: LD_INT 30
74108: PUSH
74109: LD_INT 32
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: LD_INT 30
74118: PUSH
74119: LD_INT 33
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: LIST
74130: PPUSH
74131: CALL_OW 72
74135: IFFALSE 74223
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74137: LD_ADDR_VAR 0 8
74141: PUSH
74142: LD_VAR 0 18
74146: PPUSH
74147: LD_INT 2
74149: PUSH
74150: LD_INT 30
74152: PUSH
74153: LD_INT 32
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 30
74162: PUSH
74163: LD_INT 33
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: EMPTY
74171: LIST
74172: LIST
74173: LIST
74174: PPUSH
74175: CALL_OW 72
74179: PUSH
74180: FOR_IN
74181: IFFALSE 74221
// begin if not GetBWeapon ( i ) then
74183: LD_VAR 0 8
74187: PPUSH
74188: CALL_OW 269
74192: NOT
74193: IFFALSE 74219
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74195: LD_VAR 0 8
74199: PPUSH
74200: LD_VAR 0 8
74204: PPUSH
74205: LD_VAR 0 2
74209: PPUSH
74210: CALL 75469 0 2
74214: PPUSH
74215: CALL_OW 431
// end ;
74219: GO 74180
74221: POP
74222: POP
// end ; for i = 1 to personel do
74223: LD_ADDR_VAR 0 8
74227: PUSH
74228: DOUBLE
74229: LD_INT 1
74231: DEC
74232: ST_TO_ADDR
74233: LD_VAR 0 6
74237: PUSH
74238: FOR_TO
74239: IFFALSE 75303
// begin if i > 4 then
74241: LD_VAR 0 8
74245: PUSH
74246: LD_INT 4
74248: GREATER
74249: IFFALSE 74253
// break ;
74251: GO 75303
// case i of 1 :
74253: LD_VAR 0 8
74257: PUSH
74258: LD_INT 1
74260: DOUBLE
74261: EQUAL
74262: IFTRUE 74266
74264: GO 74346
74266: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74267: LD_ADDR_VAR 0 12
74271: PUSH
74272: LD_VAR 0 18
74276: PPUSH
74277: LD_INT 22
74279: PUSH
74280: LD_VAR 0 16
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: PUSH
74289: LD_INT 58
74291: PUSH
74292: EMPTY
74293: LIST
74294: PUSH
74295: LD_INT 2
74297: PUSH
74298: LD_INT 30
74300: PUSH
74301: LD_INT 32
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 30
74310: PUSH
74311: LD_INT 4
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 30
74320: PUSH
74321: LD_INT 5
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: LIST
74338: PPUSH
74339: CALL_OW 72
74343: ST_TO_ADDR
74344: GO 74568
74346: LD_INT 2
74348: DOUBLE
74349: EQUAL
74350: IFTRUE 74354
74352: GO 74416
74354: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74355: LD_ADDR_VAR 0 12
74359: PUSH
74360: LD_VAR 0 18
74364: PPUSH
74365: LD_INT 22
74367: PUSH
74368: LD_VAR 0 16
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 2
74379: PUSH
74380: LD_INT 30
74382: PUSH
74383: LD_INT 0
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 30
74392: PUSH
74393: LD_INT 1
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: LIST
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PPUSH
74409: CALL_OW 72
74413: ST_TO_ADDR
74414: GO 74568
74416: LD_INT 3
74418: DOUBLE
74419: EQUAL
74420: IFTRUE 74424
74422: GO 74486
74424: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74425: LD_ADDR_VAR 0 12
74429: PUSH
74430: LD_VAR 0 18
74434: PPUSH
74435: LD_INT 22
74437: PUSH
74438: LD_VAR 0 16
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PUSH
74447: LD_INT 2
74449: PUSH
74450: LD_INT 30
74452: PUSH
74453: LD_INT 2
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 30
74462: PUSH
74463: LD_INT 3
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: LIST
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PPUSH
74479: CALL_OW 72
74483: ST_TO_ADDR
74484: GO 74568
74486: LD_INT 4
74488: DOUBLE
74489: EQUAL
74490: IFTRUE 74494
74492: GO 74567
74494: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74495: LD_ADDR_VAR 0 12
74499: PUSH
74500: LD_VAR 0 18
74504: PPUSH
74505: LD_INT 22
74507: PUSH
74508: LD_VAR 0 16
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 2
74519: PUSH
74520: LD_INT 30
74522: PUSH
74523: LD_INT 6
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 30
74532: PUSH
74533: LD_INT 7
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 30
74542: PUSH
74543: LD_INT 8
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: LIST
74554: LIST
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PPUSH
74560: CALL_OW 72
74564: ST_TO_ADDR
74565: GO 74568
74567: POP
// if i = 1 then
74568: LD_VAR 0 8
74572: PUSH
74573: LD_INT 1
74575: EQUAL
74576: IFFALSE 74687
// begin tmp := [ ] ;
74578: LD_ADDR_VAR 0 19
74582: PUSH
74583: EMPTY
74584: ST_TO_ADDR
// for j in f do
74585: LD_ADDR_VAR 0 9
74589: PUSH
74590: LD_VAR 0 12
74594: PUSH
74595: FOR_IN
74596: IFFALSE 74669
// if GetBType ( j ) = b_bunker then
74598: LD_VAR 0 9
74602: PPUSH
74603: CALL_OW 266
74607: PUSH
74608: LD_INT 32
74610: EQUAL
74611: IFFALSE 74638
// tmp := Insert ( tmp , 1 , j ) else
74613: LD_ADDR_VAR 0 19
74617: PUSH
74618: LD_VAR 0 19
74622: PPUSH
74623: LD_INT 1
74625: PPUSH
74626: LD_VAR 0 9
74630: PPUSH
74631: CALL_OW 2
74635: ST_TO_ADDR
74636: GO 74667
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74638: LD_ADDR_VAR 0 19
74642: PUSH
74643: LD_VAR 0 19
74647: PPUSH
74648: LD_VAR 0 19
74652: PUSH
74653: LD_INT 1
74655: PLUS
74656: PPUSH
74657: LD_VAR 0 9
74661: PPUSH
74662: CALL_OW 2
74666: ST_TO_ADDR
74667: GO 74595
74669: POP
74670: POP
// if tmp then
74671: LD_VAR 0 19
74675: IFFALSE 74687
// f := tmp ;
74677: LD_ADDR_VAR 0 12
74681: PUSH
74682: LD_VAR 0 19
74686: ST_TO_ADDR
// end ; x := personel [ i ] ;
74687: LD_ADDR_VAR 0 13
74691: PUSH
74692: LD_VAR 0 6
74696: PUSH
74697: LD_VAR 0 8
74701: ARRAY
74702: ST_TO_ADDR
// if x = - 1 then
74703: LD_VAR 0 13
74707: PUSH
74708: LD_INT 1
74710: NEG
74711: EQUAL
74712: IFFALSE 74921
// begin for j in f do
74714: LD_ADDR_VAR 0 9
74718: PUSH
74719: LD_VAR 0 12
74723: PUSH
74724: FOR_IN
74725: IFFALSE 74917
// repeat InitHc ;
74727: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74731: LD_VAR 0 9
74735: PPUSH
74736: CALL_OW 266
74740: PUSH
74741: LD_INT 5
74743: EQUAL
74744: IFFALSE 74814
// begin if UnitsInside ( j ) < 3 then
74746: LD_VAR 0 9
74750: PPUSH
74751: CALL_OW 313
74755: PUSH
74756: LD_INT 3
74758: LESS
74759: IFFALSE 74795
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74761: LD_INT 0
74763: PPUSH
74764: LD_INT 5
74766: PUSH
74767: LD_INT 8
74769: PUSH
74770: LD_INT 9
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: LIST
74777: PUSH
74778: LD_VAR 0 17
74782: ARRAY
74783: PPUSH
74784: LD_VAR 0 4
74788: PPUSH
74789: CALL_OW 380
74793: GO 74812
// PrepareHuman ( false , i , skill ) ;
74795: LD_INT 0
74797: PPUSH
74798: LD_VAR 0 8
74802: PPUSH
74803: LD_VAR 0 4
74807: PPUSH
74808: CALL_OW 380
// end else
74812: GO 74831
// PrepareHuman ( false , i , skill ) ;
74814: LD_INT 0
74816: PPUSH
74817: LD_VAR 0 8
74821: PPUSH
74822: LD_VAR 0 4
74826: PPUSH
74827: CALL_OW 380
// un := CreateHuman ;
74831: LD_ADDR_VAR 0 14
74835: PUSH
74836: CALL_OW 44
74840: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74841: LD_ADDR_VAR 0 7
74845: PUSH
74846: LD_VAR 0 7
74850: PPUSH
74851: LD_INT 1
74853: PPUSH
74854: LD_VAR 0 14
74858: PPUSH
74859: CALL_OW 2
74863: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74864: LD_VAR 0 14
74868: PPUSH
74869: LD_VAR 0 9
74873: PPUSH
74874: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74878: LD_VAR 0 9
74882: PPUSH
74883: CALL_OW 313
74887: PUSH
74888: LD_INT 6
74890: EQUAL
74891: PUSH
74892: LD_VAR 0 9
74896: PPUSH
74897: CALL_OW 266
74901: PUSH
74902: LD_INT 32
74904: PUSH
74905: LD_INT 31
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: IN
74912: OR
74913: IFFALSE 74727
74915: GO 74724
74917: POP
74918: POP
// end else
74919: GO 75301
// for j = 1 to x do
74921: LD_ADDR_VAR 0 9
74925: PUSH
74926: DOUBLE
74927: LD_INT 1
74929: DEC
74930: ST_TO_ADDR
74931: LD_VAR 0 13
74935: PUSH
74936: FOR_TO
74937: IFFALSE 75299
// begin InitHc ;
74939: CALL_OW 19
// if not f then
74943: LD_VAR 0 12
74947: NOT
74948: IFFALSE 75037
// begin PrepareHuman ( false , i , skill ) ;
74950: LD_INT 0
74952: PPUSH
74953: LD_VAR 0 8
74957: PPUSH
74958: LD_VAR 0 4
74962: PPUSH
74963: CALL_OW 380
// un := CreateHuman ;
74967: LD_ADDR_VAR 0 14
74971: PUSH
74972: CALL_OW 44
74976: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74977: LD_ADDR_VAR 0 7
74981: PUSH
74982: LD_VAR 0 7
74986: PPUSH
74987: LD_INT 1
74989: PPUSH
74990: LD_VAR 0 14
74994: PPUSH
74995: CALL_OW 2
74999: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75000: LD_VAR 0 14
75004: PPUSH
75005: LD_VAR 0 1
75009: PPUSH
75010: CALL_OW 250
75014: PPUSH
75015: LD_VAR 0 1
75019: PPUSH
75020: CALL_OW 251
75024: PPUSH
75025: LD_INT 10
75027: PPUSH
75028: LD_INT 0
75030: PPUSH
75031: CALL_OW 50
// continue ;
75035: GO 74936
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75037: LD_VAR 0 12
75041: PUSH
75042: LD_INT 1
75044: ARRAY
75045: PPUSH
75046: CALL_OW 313
75050: PUSH
75051: LD_VAR 0 12
75055: PUSH
75056: LD_INT 1
75058: ARRAY
75059: PPUSH
75060: CALL_OW 266
75064: PUSH
75065: LD_INT 32
75067: PUSH
75068: LD_INT 31
75070: PUSH
75071: EMPTY
75072: LIST
75073: LIST
75074: IN
75075: AND
75076: PUSH
75077: LD_VAR 0 12
75081: PUSH
75082: LD_INT 1
75084: ARRAY
75085: PPUSH
75086: CALL_OW 313
75090: PUSH
75091: LD_INT 6
75093: EQUAL
75094: OR
75095: IFFALSE 75115
// f := Delete ( f , 1 ) ;
75097: LD_ADDR_VAR 0 12
75101: PUSH
75102: LD_VAR 0 12
75106: PPUSH
75107: LD_INT 1
75109: PPUSH
75110: CALL_OW 3
75114: ST_TO_ADDR
// if not f then
75115: LD_VAR 0 12
75119: NOT
75120: IFFALSE 75138
// begin x := x + 2 ;
75122: LD_ADDR_VAR 0 13
75126: PUSH
75127: LD_VAR 0 13
75131: PUSH
75132: LD_INT 2
75134: PLUS
75135: ST_TO_ADDR
// continue ;
75136: GO 74936
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75138: LD_VAR 0 12
75142: PUSH
75143: LD_INT 1
75145: ARRAY
75146: PPUSH
75147: CALL_OW 266
75151: PUSH
75152: LD_INT 5
75154: EQUAL
75155: IFFALSE 75229
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75157: LD_VAR 0 12
75161: PUSH
75162: LD_INT 1
75164: ARRAY
75165: PPUSH
75166: CALL_OW 313
75170: PUSH
75171: LD_INT 3
75173: LESS
75174: IFFALSE 75210
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75176: LD_INT 0
75178: PPUSH
75179: LD_INT 5
75181: PUSH
75182: LD_INT 8
75184: PUSH
75185: LD_INT 9
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: LIST
75192: PUSH
75193: LD_VAR 0 17
75197: ARRAY
75198: PPUSH
75199: LD_VAR 0 4
75203: PPUSH
75204: CALL_OW 380
75208: GO 75227
// PrepareHuman ( false , i , skill ) ;
75210: LD_INT 0
75212: PPUSH
75213: LD_VAR 0 8
75217: PPUSH
75218: LD_VAR 0 4
75222: PPUSH
75223: CALL_OW 380
// end else
75227: GO 75246
// PrepareHuman ( false , i , skill ) ;
75229: LD_INT 0
75231: PPUSH
75232: LD_VAR 0 8
75236: PPUSH
75237: LD_VAR 0 4
75241: PPUSH
75242: CALL_OW 380
// un := CreateHuman ;
75246: LD_ADDR_VAR 0 14
75250: PUSH
75251: CALL_OW 44
75255: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75256: LD_ADDR_VAR 0 7
75260: PUSH
75261: LD_VAR 0 7
75265: PPUSH
75266: LD_INT 1
75268: PPUSH
75269: LD_VAR 0 14
75273: PPUSH
75274: CALL_OW 2
75278: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75279: LD_VAR 0 14
75283: PPUSH
75284: LD_VAR 0 12
75288: PUSH
75289: LD_INT 1
75291: ARRAY
75292: PPUSH
75293: CALL_OW 52
// end ;
75297: GO 74936
75299: POP
75300: POP
// end ;
75301: GO 74238
75303: POP
75304: POP
// result := result ^ buildings ;
75305: LD_ADDR_VAR 0 7
75309: PUSH
75310: LD_VAR 0 7
75314: PUSH
75315: LD_VAR 0 18
75319: ADD
75320: ST_TO_ADDR
// end else
75321: GO 75464
// begin for i = 1 to personel do
75323: LD_ADDR_VAR 0 8
75327: PUSH
75328: DOUBLE
75329: LD_INT 1
75331: DEC
75332: ST_TO_ADDR
75333: LD_VAR 0 6
75337: PUSH
75338: FOR_TO
75339: IFFALSE 75462
// begin if i > 4 then
75341: LD_VAR 0 8
75345: PUSH
75346: LD_INT 4
75348: GREATER
75349: IFFALSE 75353
// break ;
75351: GO 75462
// x := personel [ i ] ;
75353: LD_ADDR_VAR 0 13
75357: PUSH
75358: LD_VAR 0 6
75362: PUSH
75363: LD_VAR 0 8
75367: ARRAY
75368: ST_TO_ADDR
// if x = - 1 then
75369: LD_VAR 0 13
75373: PUSH
75374: LD_INT 1
75376: NEG
75377: EQUAL
75378: IFFALSE 75382
// continue ;
75380: GO 75338
// PrepareHuman ( false , i , skill ) ;
75382: LD_INT 0
75384: PPUSH
75385: LD_VAR 0 8
75389: PPUSH
75390: LD_VAR 0 4
75394: PPUSH
75395: CALL_OW 380
// un := CreateHuman ;
75399: LD_ADDR_VAR 0 14
75403: PUSH
75404: CALL_OW 44
75408: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75409: LD_VAR 0 14
75413: PPUSH
75414: LD_VAR 0 1
75418: PPUSH
75419: CALL_OW 250
75423: PPUSH
75424: LD_VAR 0 1
75428: PPUSH
75429: CALL_OW 251
75433: PPUSH
75434: LD_INT 10
75436: PPUSH
75437: LD_INT 0
75439: PPUSH
75440: CALL_OW 50
// result := result ^ un ;
75444: LD_ADDR_VAR 0 7
75448: PUSH
75449: LD_VAR 0 7
75453: PUSH
75454: LD_VAR 0 14
75458: ADD
75459: ST_TO_ADDR
// end ;
75460: GO 75338
75462: POP
75463: POP
// end ; end ;
75464: LD_VAR 0 7
75468: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75469: LD_INT 0
75471: PPUSH
75472: PPUSH
75473: PPUSH
75474: PPUSH
75475: PPUSH
75476: PPUSH
75477: PPUSH
75478: PPUSH
75479: PPUSH
75480: PPUSH
75481: PPUSH
75482: PPUSH
75483: PPUSH
75484: PPUSH
75485: PPUSH
75486: PPUSH
// result := false ;
75487: LD_ADDR_VAR 0 3
75491: PUSH
75492: LD_INT 0
75494: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75495: LD_VAR 0 1
75499: NOT
75500: PUSH
75501: LD_VAR 0 1
75505: PPUSH
75506: CALL_OW 266
75510: PUSH
75511: LD_INT 32
75513: PUSH
75514: LD_INT 33
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: IN
75521: NOT
75522: OR
75523: IFFALSE 75527
// exit ;
75525: GO 76636
// nat := GetNation ( tower ) ;
75527: LD_ADDR_VAR 0 12
75531: PUSH
75532: LD_VAR 0 1
75536: PPUSH
75537: CALL_OW 248
75541: ST_TO_ADDR
// side := GetSide ( tower ) ;
75542: LD_ADDR_VAR 0 16
75546: PUSH
75547: LD_VAR 0 1
75551: PPUSH
75552: CALL_OW 255
75556: ST_TO_ADDR
// x := GetX ( tower ) ;
75557: LD_ADDR_VAR 0 10
75561: PUSH
75562: LD_VAR 0 1
75566: PPUSH
75567: CALL_OW 250
75571: ST_TO_ADDR
// y := GetY ( tower ) ;
75572: LD_ADDR_VAR 0 11
75576: PUSH
75577: LD_VAR 0 1
75581: PPUSH
75582: CALL_OW 251
75586: ST_TO_ADDR
// if not x or not y then
75587: LD_VAR 0 10
75591: NOT
75592: PUSH
75593: LD_VAR 0 11
75597: NOT
75598: OR
75599: IFFALSE 75603
// exit ;
75601: GO 76636
// weapon := 0 ;
75603: LD_ADDR_VAR 0 18
75607: PUSH
75608: LD_INT 0
75610: ST_TO_ADDR
// fac_list := [ ] ;
75611: LD_ADDR_VAR 0 17
75615: PUSH
75616: EMPTY
75617: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
75618: LD_ADDR_VAR 0 6
75622: PUSH
75623: LD_VAR 0 1
75627: PPUSH
75628: CALL_OW 274
75632: PPUSH
75633: LD_VAR 0 2
75637: PPUSH
75638: LD_INT 0
75640: PPUSH
75641: CALL 73206 0 3
75645: PPUSH
75646: LD_INT 30
75648: PUSH
75649: LD_INT 3
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PPUSH
75656: CALL_OW 72
75660: ST_TO_ADDR
// if not factories then
75661: LD_VAR 0 6
75665: NOT
75666: IFFALSE 75670
// exit ;
75668: GO 76636
// for i in factories do
75670: LD_ADDR_VAR 0 8
75674: PUSH
75675: LD_VAR 0 6
75679: PUSH
75680: FOR_IN
75681: IFFALSE 75706
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75683: LD_ADDR_VAR 0 17
75687: PUSH
75688: LD_VAR 0 17
75692: PUSH
75693: LD_VAR 0 8
75697: PPUSH
75698: CALL_OW 478
75702: UNION
75703: ST_TO_ADDR
75704: GO 75680
75706: POP
75707: POP
// if not fac_list then
75708: LD_VAR 0 17
75712: NOT
75713: IFFALSE 75717
// exit ;
75715: GO 76636
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75717: LD_ADDR_VAR 0 5
75721: PUSH
75722: LD_INT 4
75724: PUSH
75725: LD_INT 5
75727: PUSH
75728: LD_INT 9
75730: PUSH
75731: LD_INT 10
75733: PUSH
75734: LD_INT 6
75736: PUSH
75737: LD_INT 7
75739: PUSH
75740: LD_INT 11
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 27
75754: PUSH
75755: LD_INT 28
75757: PUSH
75758: LD_INT 26
75760: PUSH
75761: LD_INT 30
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 43
75772: PUSH
75773: LD_INT 44
75775: PUSH
75776: LD_INT 46
75778: PUSH
75779: LD_INT 45
75781: PUSH
75782: LD_INT 47
75784: PUSH
75785: LD_INT 49
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: LIST
75792: LIST
75793: LIST
75794: LIST
75795: PUSH
75796: EMPTY
75797: LIST
75798: LIST
75799: LIST
75800: PUSH
75801: LD_VAR 0 12
75805: ARRAY
75806: ST_TO_ADDR
// list := list isect fac_list ;
75807: LD_ADDR_VAR 0 5
75811: PUSH
75812: LD_VAR 0 5
75816: PUSH
75817: LD_VAR 0 17
75821: ISECT
75822: ST_TO_ADDR
// if not list then
75823: LD_VAR 0 5
75827: NOT
75828: IFFALSE 75832
// exit ;
75830: GO 76636
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75832: LD_VAR 0 12
75836: PUSH
75837: LD_INT 3
75839: EQUAL
75840: PUSH
75841: LD_INT 49
75843: PUSH
75844: LD_VAR 0 5
75848: IN
75849: AND
75850: PUSH
75851: LD_INT 31
75853: PPUSH
75854: LD_VAR 0 16
75858: PPUSH
75859: CALL_OW 321
75863: PUSH
75864: LD_INT 2
75866: EQUAL
75867: AND
75868: IFFALSE 75928
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75870: LD_INT 22
75872: PUSH
75873: LD_VAR 0 16
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 35
75884: PUSH
75885: LD_INT 49
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 91
75894: PUSH
75895: LD_VAR 0 1
75899: PUSH
75900: LD_INT 10
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: LIST
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: LIST
75912: PPUSH
75913: CALL_OW 69
75917: NOT
75918: IFFALSE 75928
// weapon := ru_time_lapser ;
75920: LD_ADDR_VAR 0 18
75924: PUSH
75925: LD_INT 49
75927: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75928: LD_VAR 0 12
75932: PUSH
75933: LD_INT 1
75935: PUSH
75936: LD_INT 2
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: IN
75943: PUSH
75944: LD_INT 11
75946: PUSH
75947: LD_VAR 0 5
75951: IN
75952: PUSH
75953: LD_INT 30
75955: PUSH
75956: LD_VAR 0 5
75960: IN
75961: OR
75962: AND
75963: PUSH
75964: LD_INT 6
75966: PPUSH
75967: LD_VAR 0 16
75971: PPUSH
75972: CALL_OW 321
75976: PUSH
75977: LD_INT 2
75979: EQUAL
75980: AND
75981: IFFALSE 76146
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75983: LD_INT 22
75985: PUSH
75986: LD_VAR 0 16
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 2
75997: PUSH
75998: LD_INT 35
76000: PUSH
76001: LD_INT 11
76003: PUSH
76004: EMPTY
76005: LIST
76006: LIST
76007: PUSH
76008: LD_INT 35
76010: PUSH
76011: LD_INT 30
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 91
76025: PUSH
76026: LD_VAR 0 1
76030: PUSH
76031: LD_INT 18
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: LIST
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: LIST
76043: PPUSH
76044: CALL_OW 69
76048: NOT
76049: PUSH
76050: LD_INT 22
76052: PUSH
76053: LD_VAR 0 16
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: LD_INT 2
76064: PUSH
76065: LD_INT 30
76067: PUSH
76068: LD_INT 32
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 30
76077: PUSH
76078: LD_INT 33
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: LIST
76089: PUSH
76090: LD_INT 91
76092: PUSH
76093: LD_VAR 0 1
76097: PUSH
76098: LD_INT 12
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: LIST
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: LIST
76110: PUSH
76111: EMPTY
76112: LIST
76113: PPUSH
76114: CALL_OW 69
76118: PUSH
76119: LD_INT 2
76121: GREATER
76122: AND
76123: IFFALSE 76146
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76125: LD_ADDR_VAR 0 18
76129: PUSH
76130: LD_INT 11
76132: PUSH
76133: LD_INT 30
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_VAR 0 12
76144: ARRAY
76145: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76146: LD_VAR 0 18
76150: NOT
76151: PUSH
76152: LD_INT 40
76154: PPUSH
76155: LD_VAR 0 16
76159: PPUSH
76160: CALL_OW 321
76164: PUSH
76165: LD_INT 2
76167: EQUAL
76168: AND
76169: PUSH
76170: LD_INT 7
76172: PUSH
76173: LD_VAR 0 5
76177: IN
76178: PUSH
76179: LD_INT 28
76181: PUSH
76182: LD_VAR 0 5
76186: IN
76187: OR
76188: PUSH
76189: LD_INT 45
76191: PUSH
76192: LD_VAR 0 5
76196: IN
76197: OR
76198: AND
76199: IFFALSE 76453
// begin hex := GetHexInfo ( x , y ) ;
76201: LD_ADDR_VAR 0 4
76205: PUSH
76206: LD_VAR 0 10
76210: PPUSH
76211: LD_VAR 0 11
76215: PPUSH
76216: CALL_OW 546
76220: ST_TO_ADDR
// if hex [ 1 ] then
76221: LD_VAR 0 4
76225: PUSH
76226: LD_INT 1
76228: ARRAY
76229: IFFALSE 76233
// exit ;
76231: GO 76636
// height := hex [ 2 ] ;
76233: LD_ADDR_VAR 0 15
76237: PUSH
76238: LD_VAR 0 4
76242: PUSH
76243: LD_INT 2
76245: ARRAY
76246: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76247: LD_ADDR_VAR 0 14
76251: PUSH
76252: LD_INT 0
76254: PUSH
76255: LD_INT 2
76257: PUSH
76258: LD_INT 3
76260: PUSH
76261: LD_INT 5
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: ST_TO_ADDR
// for i in tmp do
76270: LD_ADDR_VAR 0 8
76274: PUSH
76275: LD_VAR 0 14
76279: PUSH
76280: FOR_IN
76281: IFFALSE 76451
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76283: LD_ADDR_VAR 0 9
76287: PUSH
76288: LD_VAR 0 10
76292: PPUSH
76293: LD_VAR 0 8
76297: PPUSH
76298: LD_INT 5
76300: PPUSH
76301: CALL_OW 272
76305: PUSH
76306: LD_VAR 0 11
76310: PPUSH
76311: LD_VAR 0 8
76315: PPUSH
76316: LD_INT 5
76318: PPUSH
76319: CALL_OW 273
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76328: LD_VAR 0 9
76332: PUSH
76333: LD_INT 1
76335: ARRAY
76336: PPUSH
76337: LD_VAR 0 9
76341: PUSH
76342: LD_INT 2
76344: ARRAY
76345: PPUSH
76346: CALL_OW 488
76350: IFFALSE 76449
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76352: LD_ADDR_VAR 0 4
76356: PUSH
76357: LD_VAR 0 9
76361: PUSH
76362: LD_INT 1
76364: ARRAY
76365: PPUSH
76366: LD_VAR 0 9
76370: PUSH
76371: LD_INT 2
76373: ARRAY
76374: PPUSH
76375: CALL_OW 546
76379: ST_TO_ADDR
// if hex [ 1 ] then
76380: LD_VAR 0 4
76384: PUSH
76385: LD_INT 1
76387: ARRAY
76388: IFFALSE 76392
// continue ;
76390: GO 76280
// h := hex [ 2 ] ;
76392: LD_ADDR_VAR 0 13
76396: PUSH
76397: LD_VAR 0 4
76401: PUSH
76402: LD_INT 2
76404: ARRAY
76405: ST_TO_ADDR
// if h + 7 < height then
76406: LD_VAR 0 13
76410: PUSH
76411: LD_INT 7
76413: PLUS
76414: PUSH
76415: LD_VAR 0 15
76419: LESS
76420: IFFALSE 76449
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76422: LD_ADDR_VAR 0 18
76426: PUSH
76427: LD_INT 7
76429: PUSH
76430: LD_INT 28
76432: PUSH
76433: LD_INT 45
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: LIST
76440: PUSH
76441: LD_VAR 0 12
76445: ARRAY
76446: ST_TO_ADDR
// break ;
76447: GO 76451
// end ; end ; end ;
76449: GO 76280
76451: POP
76452: POP
// end ; if not weapon then
76453: LD_VAR 0 18
76457: NOT
76458: IFFALSE 76518
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76460: LD_ADDR_VAR 0 5
76464: PUSH
76465: LD_VAR 0 5
76469: PUSH
76470: LD_INT 11
76472: PUSH
76473: LD_INT 30
76475: PUSH
76476: LD_INT 49
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: LIST
76483: DIFF
76484: ST_TO_ADDR
// if not list then
76485: LD_VAR 0 5
76489: NOT
76490: IFFALSE 76494
// exit ;
76492: GO 76636
// weapon := list [ rand ( 1 , list ) ] ;
76494: LD_ADDR_VAR 0 18
76498: PUSH
76499: LD_VAR 0 5
76503: PUSH
76504: LD_INT 1
76506: PPUSH
76507: LD_VAR 0 5
76511: PPUSH
76512: CALL_OW 12
76516: ARRAY
76517: ST_TO_ADDR
// end ; if weapon then
76518: LD_VAR 0 18
76522: IFFALSE 76636
// begin tmp := CostOfWeapon ( weapon ) ;
76524: LD_ADDR_VAR 0 14
76528: PUSH
76529: LD_VAR 0 18
76533: PPUSH
76534: CALL_OW 451
76538: ST_TO_ADDR
// j := GetBase ( tower ) ;
76539: LD_ADDR_VAR 0 9
76543: PUSH
76544: LD_VAR 0 1
76548: PPUSH
76549: CALL_OW 274
76553: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76554: LD_VAR 0 9
76558: PPUSH
76559: LD_INT 1
76561: PPUSH
76562: CALL_OW 275
76566: PUSH
76567: LD_VAR 0 14
76571: PUSH
76572: LD_INT 1
76574: ARRAY
76575: GREATEREQUAL
76576: PUSH
76577: LD_VAR 0 9
76581: PPUSH
76582: LD_INT 2
76584: PPUSH
76585: CALL_OW 275
76589: PUSH
76590: LD_VAR 0 14
76594: PUSH
76595: LD_INT 2
76597: ARRAY
76598: GREATEREQUAL
76599: AND
76600: PUSH
76601: LD_VAR 0 9
76605: PPUSH
76606: LD_INT 3
76608: PPUSH
76609: CALL_OW 275
76613: PUSH
76614: LD_VAR 0 14
76618: PUSH
76619: LD_INT 3
76621: ARRAY
76622: GREATEREQUAL
76623: AND
76624: IFFALSE 76636
// result := weapon ;
76626: LD_ADDR_VAR 0 3
76630: PUSH
76631: LD_VAR 0 18
76635: ST_TO_ADDR
// end ; end ;
76636: LD_VAR 0 3
76640: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76641: LD_INT 0
76643: PPUSH
76644: PPUSH
// result := true ;
76645: LD_ADDR_VAR 0 3
76649: PUSH
76650: LD_INT 1
76652: ST_TO_ADDR
// if array1 = array2 then
76653: LD_VAR 0 1
76657: PUSH
76658: LD_VAR 0 2
76662: EQUAL
76663: IFFALSE 76723
// begin for i = 1 to array1 do
76665: LD_ADDR_VAR 0 4
76669: PUSH
76670: DOUBLE
76671: LD_INT 1
76673: DEC
76674: ST_TO_ADDR
76675: LD_VAR 0 1
76679: PUSH
76680: FOR_TO
76681: IFFALSE 76719
// if array1 [ i ] <> array2 [ i ] then
76683: LD_VAR 0 1
76687: PUSH
76688: LD_VAR 0 4
76692: ARRAY
76693: PUSH
76694: LD_VAR 0 2
76698: PUSH
76699: LD_VAR 0 4
76703: ARRAY
76704: NONEQUAL
76705: IFFALSE 76717
// begin result := false ;
76707: LD_ADDR_VAR 0 3
76711: PUSH
76712: LD_INT 0
76714: ST_TO_ADDR
// break ;
76715: GO 76719
// end ;
76717: GO 76680
76719: POP
76720: POP
// end else
76721: GO 76731
// result := false ;
76723: LD_ADDR_VAR 0 3
76727: PUSH
76728: LD_INT 0
76730: ST_TO_ADDR
// end ;
76731: LD_VAR 0 3
76735: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
76736: LD_INT 0
76738: PPUSH
76739: PPUSH
// if not array1 or not array2 then
76740: LD_VAR 0 1
76744: NOT
76745: PUSH
76746: LD_VAR 0 2
76750: NOT
76751: OR
76752: IFFALSE 76756
// exit ;
76754: GO 76820
// result := true ;
76756: LD_ADDR_VAR 0 3
76760: PUSH
76761: LD_INT 1
76763: ST_TO_ADDR
// for i = 1 to array1 do
76764: LD_ADDR_VAR 0 4
76768: PUSH
76769: DOUBLE
76770: LD_INT 1
76772: DEC
76773: ST_TO_ADDR
76774: LD_VAR 0 1
76778: PUSH
76779: FOR_TO
76780: IFFALSE 76818
// if array1 [ i ] <> array2 [ i ] then
76782: LD_VAR 0 1
76786: PUSH
76787: LD_VAR 0 4
76791: ARRAY
76792: PUSH
76793: LD_VAR 0 2
76797: PUSH
76798: LD_VAR 0 4
76802: ARRAY
76803: NONEQUAL
76804: IFFALSE 76816
// begin result := false ;
76806: LD_ADDR_VAR 0 3
76810: PUSH
76811: LD_INT 0
76813: ST_TO_ADDR
// break ;
76814: GO 76818
// end ;
76816: GO 76779
76818: POP
76819: POP
// end ;
76820: LD_VAR 0 3
76824: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76825: LD_INT 0
76827: PPUSH
76828: PPUSH
76829: PPUSH
// pom := GetBase ( fac ) ;
76830: LD_ADDR_VAR 0 5
76834: PUSH
76835: LD_VAR 0 1
76839: PPUSH
76840: CALL_OW 274
76844: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76845: LD_ADDR_VAR 0 4
76849: PUSH
76850: LD_VAR 0 2
76854: PUSH
76855: LD_INT 1
76857: ARRAY
76858: PPUSH
76859: LD_VAR 0 2
76863: PUSH
76864: LD_INT 2
76866: ARRAY
76867: PPUSH
76868: LD_VAR 0 2
76872: PUSH
76873: LD_INT 3
76875: ARRAY
76876: PPUSH
76877: LD_VAR 0 2
76881: PUSH
76882: LD_INT 4
76884: ARRAY
76885: PPUSH
76886: CALL_OW 449
76890: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76891: LD_ADDR_VAR 0 3
76895: PUSH
76896: LD_VAR 0 5
76900: PPUSH
76901: LD_INT 1
76903: PPUSH
76904: CALL_OW 275
76908: PUSH
76909: LD_VAR 0 4
76913: PUSH
76914: LD_INT 1
76916: ARRAY
76917: GREATEREQUAL
76918: PUSH
76919: LD_VAR 0 5
76923: PPUSH
76924: LD_INT 2
76926: PPUSH
76927: CALL_OW 275
76931: PUSH
76932: LD_VAR 0 4
76936: PUSH
76937: LD_INT 2
76939: ARRAY
76940: GREATEREQUAL
76941: AND
76942: PUSH
76943: LD_VAR 0 5
76947: PPUSH
76948: LD_INT 3
76950: PPUSH
76951: CALL_OW 275
76955: PUSH
76956: LD_VAR 0 4
76960: PUSH
76961: LD_INT 3
76963: ARRAY
76964: GREATEREQUAL
76965: AND
76966: ST_TO_ADDR
// end ;
76967: LD_VAR 0 3
76971: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76972: LD_INT 0
76974: PPUSH
76975: PPUSH
76976: PPUSH
76977: PPUSH
// pom := GetBase ( building ) ;
76978: LD_ADDR_VAR 0 3
76982: PUSH
76983: LD_VAR 0 1
76987: PPUSH
76988: CALL_OW 274
76992: ST_TO_ADDR
// if not pom then
76993: LD_VAR 0 3
76997: NOT
76998: IFFALSE 77002
// exit ;
77000: GO 77172
// btype := GetBType ( building ) ;
77002: LD_ADDR_VAR 0 5
77006: PUSH
77007: LD_VAR 0 1
77011: PPUSH
77012: CALL_OW 266
77016: ST_TO_ADDR
// if btype = b_armoury then
77017: LD_VAR 0 5
77021: PUSH
77022: LD_INT 4
77024: EQUAL
77025: IFFALSE 77035
// btype := b_barracks ;
77027: LD_ADDR_VAR 0 5
77031: PUSH
77032: LD_INT 5
77034: ST_TO_ADDR
// if btype = b_depot then
77035: LD_VAR 0 5
77039: PUSH
77040: LD_INT 0
77042: EQUAL
77043: IFFALSE 77053
// btype := b_warehouse ;
77045: LD_ADDR_VAR 0 5
77049: PUSH
77050: LD_INT 1
77052: ST_TO_ADDR
// if btype = b_workshop then
77053: LD_VAR 0 5
77057: PUSH
77058: LD_INT 2
77060: EQUAL
77061: IFFALSE 77071
// btype := b_factory ;
77063: LD_ADDR_VAR 0 5
77067: PUSH
77068: LD_INT 3
77070: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77071: LD_ADDR_VAR 0 4
77075: PUSH
77076: LD_VAR 0 5
77080: PPUSH
77081: LD_VAR 0 1
77085: PPUSH
77086: CALL_OW 248
77090: PPUSH
77091: CALL_OW 450
77095: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77096: LD_ADDR_VAR 0 2
77100: PUSH
77101: LD_VAR 0 3
77105: PPUSH
77106: LD_INT 1
77108: PPUSH
77109: CALL_OW 275
77113: PUSH
77114: LD_VAR 0 4
77118: PUSH
77119: LD_INT 1
77121: ARRAY
77122: GREATEREQUAL
77123: PUSH
77124: LD_VAR 0 3
77128: PPUSH
77129: LD_INT 2
77131: PPUSH
77132: CALL_OW 275
77136: PUSH
77137: LD_VAR 0 4
77141: PUSH
77142: LD_INT 2
77144: ARRAY
77145: GREATEREQUAL
77146: AND
77147: PUSH
77148: LD_VAR 0 3
77152: PPUSH
77153: LD_INT 3
77155: PPUSH
77156: CALL_OW 275
77160: PUSH
77161: LD_VAR 0 4
77165: PUSH
77166: LD_INT 3
77168: ARRAY
77169: GREATEREQUAL
77170: AND
77171: ST_TO_ADDR
// end ;
77172: LD_VAR 0 2
77176: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77177: LD_INT 0
77179: PPUSH
77180: PPUSH
77181: PPUSH
// pom := GetBase ( building ) ;
77182: LD_ADDR_VAR 0 4
77186: PUSH
77187: LD_VAR 0 1
77191: PPUSH
77192: CALL_OW 274
77196: ST_TO_ADDR
// if not pom then
77197: LD_VAR 0 4
77201: NOT
77202: IFFALSE 77206
// exit ;
77204: GO 77307
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77206: LD_ADDR_VAR 0 5
77210: PUSH
77211: LD_VAR 0 2
77215: PPUSH
77216: LD_VAR 0 1
77220: PPUSH
77221: CALL_OW 248
77225: PPUSH
77226: CALL_OW 450
77230: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77231: LD_ADDR_VAR 0 3
77235: PUSH
77236: LD_VAR 0 4
77240: PPUSH
77241: LD_INT 1
77243: PPUSH
77244: CALL_OW 275
77248: PUSH
77249: LD_VAR 0 5
77253: PUSH
77254: LD_INT 1
77256: ARRAY
77257: GREATEREQUAL
77258: PUSH
77259: LD_VAR 0 4
77263: PPUSH
77264: LD_INT 2
77266: PPUSH
77267: CALL_OW 275
77271: PUSH
77272: LD_VAR 0 5
77276: PUSH
77277: LD_INT 2
77279: ARRAY
77280: GREATEREQUAL
77281: AND
77282: PUSH
77283: LD_VAR 0 4
77287: PPUSH
77288: LD_INT 3
77290: PPUSH
77291: CALL_OW 275
77295: PUSH
77296: LD_VAR 0 5
77300: PUSH
77301: LD_INT 3
77303: ARRAY
77304: GREATEREQUAL
77305: AND
77306: ST_TO_ADDR
// end ;
77307: LD_VAR 0 3
77311: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77312: LD_INT 0
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
// result := false ;
77325: LD_ADDR_VAR 0 8
77329: PUSH
77330: LD_INT 0
77332: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77333: LD_VAR 0 5
77337: NOT
77338: PUSH
77339: LD_VAR 0 1
77343: NOT
77344: OR
77345: PUSH
77346: LD_VAR 0 2
77350: NOT
77351: OR
77352: PUSH
77353: LD_VAR 0 3
77357: NOT
77358: OR
77359: IFFALSE 77363
// exit ;
77361: GO 78177
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77363: LD_ADDR_VAR 0 14
77367: PUSH
77368: LD_VAR 0 1
77372: PPUSH
77373: LD_VAR 0 2
77377: PPUSH
77378: LD_VAR 0 3
77382: PPUSH
77383: LD_VAR 0 4
77387: PPUSH
77388: LD_VAR 0 5
77392: PUSH
77393: LD_INT 1
77395: ARRAY
77396: PPUSH
77397: CALL_OW 248
77401: PPUSH
77402: LD_INT 0
77404: PPUSH
77405: CALL 79414 0 6
77409: ST_TO_ADDR
// if not hexes then
77410: LD_VAR 0 14
77414: NOT
77415: IFFALSE 77419
// exit ;
77417: GO 78177
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77419: LD_ADDR_VAR 0 17
77423: PUSH
77424: LD_VAR 0 5
77428: PPUSH
77429: LD_INT 22
77431: PUSH
77432: LD_VAR 0 13
77436: PPUSH
77437: CALL_OW 255
77441: PUSH
77442: EMPTY
77443: LIST
77444: LIST
77445: PUSH
77446: LD_INT 2
77448: PUSH
77449: LD_INT 30
77451: PUSH
77452: LD_INT 0
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 30
77461: PUSH
77462: LD_INT 1
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: LIST
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PPUSH
77478: CALL_OW 72
77482: ST_TO_ADDR
// for i = 1 to hexes do
77483: LD_ADDR_VAR 0 9
77487: PUSH
77488: DOUBLE
77489: LD_INT 1
77491: DEC
77492: ST_TO_ADDR
77493: LD_VAR 0 14
77497: PUSH
77498: FOR_TO
77499: IFFALSE 78175
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77501: LD_ADDR_VAR 0 13
77505: PUSH
77506: LD_VAR 0 14
77510: PUSH
77511: LD_VAR 0 9
77515: ARRAY
77516: PUSH
77517: LD_INT 1
77519: ARRAY
77520: PPUSH
77521: LD_VAR 0 14
77525: PUSH
77526: LD_VAR 0 9
77530: ARRAY
77531: PUSH
77532: LD_INT 2
77534: ARRAY
77535: PPUSH
77536: CALL_OW 428
77540: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77541: LD_VAR 0 14
77545: PUSH
77546: LD_VAR 0 9
77550: ARRAY
77551: PUSH
77552: LD_INT 1
77554: ARRAY
77555: PPUSH
77556: LD_VAR 0 14
77560: PUSH
77561: LD_VAR 0 9
77565: ARRAY
77566: PUSH
77567: LD_INT 2
77569: ARRAY
77570: PPUSH
77571: CALL_OW 351
77575: PUSH
77576: LD_VAR 0 14
77580: PUSH
77581: LD_VAR 0 9
77585: ARRAY
77586: PUSH
77587: LD_INT 1
77589: ARRAY
77590: PPUSH
77591: LD_VAR 0 14
77595: PUSH
77596: LD_VAR 0 9
77600: ARRAY
77601: PUSH
77602: LD_INT 2
77604: ARRAY
77605: PPUSH
77606: CALL_OW 488
77610: NOT
77611: OR
77612: PUSH
77613: LD_VAR 0 13
77617: PPUSH
77618: CALL_OW 247
77622: PUSH
77623: LD_INT 3
77625: EQUAL
77626: OR
77627: IFFALSE 77633
// exit ;
77629: POP
77630: POP
77631: GO 78177
// if not tmp then
77633: LD_VAR 0 13
77637: NOT
77638: IFFALSE 77642
// continue ;
77640: GO 77498
// result := true ;
77642: LD_ADDR_VAR 0 8
77646: PUSH
77647: LD_INT 1
77649: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
77650: LD_VAR 0 6
77654: PUSH
77655: LD_VAR 0 13
77659: PPUSH
77660: CALL_OW 247
77664: PUSH
77665: LD_INT 2
77667: EQUAL
77668: AND
77669: PUSH
77670: LD_VAR 0 13
77674: PPUSH
77675: CALL_OW 263
77679: PUSH
77680: LD_INT 1
77682: EQUAL
77683: AND
77684: IFFALSE 77848
// begin if IsDrivenBy ( tmp ) then
77686: LD_VAR 0 13
77690: PPUSH
77691: CALL_OW 311
77695: IFFALSE 77699
// continue ;
77697: GO 77498
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
77699: LD_VAR 0 6
77703: PPUSH
77704: LD_INT 3
77706: PUSH
77707: LD_INT 60
77709: PUSH
77710: EMPTY
77711: LIST
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 3
77719: PUSH
77720: LD_INT 55
77722: PUSH
77723: EMPTY
77724: LIST
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PPUSH
77734: CALL_OW 72
77738: IFFALSE 77846
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
77740: LD_ADDR_VAR 0 18
77744: PUSH
77745: LD_VAR 0 6
77749: PPUSH
77750: LD_INT 3
77752: PUSH
77753: LD_INT 60
77755: PUSH
77756: EMPTY
77757: LIST
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 3
77765: PUSH
77766: LD_INT 55
77768: PUSH
77769: EMPTY
77770: LIST
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PPUSH
77780: CALL_OW 72
77784: PUSH
77785: LD_INT 1
77787: ARRAY
77788: ST_TO_ADDR
// if IsInUnit ( driver ) then
77789: LD_VAR 0 18
77793: PPUSH
77794: CALL_OW 310
77798: IFFALSE 77809
// ComExit ( driver ) ;
77800: LD_VAR 0 18
77804: PPUSH
77805: CALL 102598 0 1
// AddComEnterUnit ( driver , tmp ) ;
77809: LD_VAR 0 18
77813: PPUSH
77814: LD_VAR 0 13
77818: PPUSH
77819: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
77823: LD_VAR 0 18
77827: PPUSH
77828: LD_VAR 0 7
77832: PPUSH
77833: CALL_OW 173
// AddComExitVehicle ( driver ) ;
77837: LD_VAR 0 18
77841: PPUSH
77842: CALL_OW 181
// end ; continue ;
77846: GO 77498
// end ; if not cleaners or not tmp in cleaners then
77848: LD_VAR 0 6
77852: NOT
77853: PUSH
77854: LD_VAR 0 13
77858: PUSH
77859: LD_VAR 0 6
77863: IN
77864: NOT
77865: OR
77866: IFFALSE 78173
// begin if dep then
77868: LD_VAR 0 17
77872: IFFALSE 78008
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77874: LD_ADDR_VAR 0 16
77878: PUSH
77879: LD_VAR 0 17
77883: PUSH
77884: LD_INT 1
77886: ARRAY
77887: PPUSH
77888: CALL_OW 250
77892: PPUSH
77893: LD_VAR 0 17
77897: PUSH
77898: LD_INT 1
77900: ARRAY
77901: PPUSH
77902: CALL_OW 254
77906: PPUSH
77907: LD_INT 5
77909: PPUSH
77910: CALL_OW 272
77914: PUSH
77915: LD_VAR 0 17
77919: PUSH
77920: LD_INT 1
77922: ARRAY
77923: PPUSH
77924: CALL_OW 251
77928: PPUSH
77929: LD_VAR 0 17
77933: PUSH
77934: LD_INT 1
77936: ARRAY
77937: PPUSH
77938: CALL_OW 254
77942: PPUSH
77943: LD_INT 5
77945: PPUSH
77946: CALL_OW 273
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77955: LD_VAR 0 16
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: PPUSH
77964: LD_VAR 0 16
77968: PUSH
77969: LD_INT 2
77971: ARRAY
77972: PPUSH
77973: CALL_OW 488
77977: IFFALSE 78008
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77979: LD_VAR 0 13
77983: PPUSH
77984: LD_VAR 0 16
77988: PUSH
77989: LD_INT 1
77991: ARRAY
77992: PPUSH
77993: LD_VAR 0 16
77997: PUSH
77998: LD_INT 2
78000: ARRAY
78001: PPUSH
78002: CALL_OW 111
// continue ;
78006: GO 77498
// end ; end ; r := GetDir ( tmp ) ;
78008: LD_ADDR_VAR 0 15
78012: PUSH
78013: LD_VAR 0 13
78017: PPUSH
78018: CALL_OW 254
78022: ST_TO_ADDR
// if r = 5 then
78023: LD_VAR 0 15
78027: PUSH
78028: LD_INT 5
78030: EQUAL
78031: IFFALSE 78041
// r := 0 ;
78033: LD_ADDR_VAR 0 15
78037: PUSH
78038: LD_INT 0
78040: ST_TO_ADDR
// for j = r to 5 do
78041: LD_ADDR_VAR 0 10
78045: PUSH
78046: DOUBLE
78047: LD_VAR 0 15
78051: DEC
78052: ST_TO_ADDR
78053: LD_INT 5
78055: PUSH
78056: FOR_TO
78057: IFFALSE 78171
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78059: LD_ADDR_VAR 0 11
78063: PUSH
78064: LD_VAR 0 13
78068: PPUSH
78069: CALL_OW 250
78073: PPUSH
78074: LD_VAR 0 10
78078: PPUSH
78079: LD_INT 2
78081: PPUSH
78082: CALL_OW 272
78086: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78087: LD_ADDR_VAR 0 12
78091: PUSH
78092: LD_VAR 0 13
78096: PPUSH
78097: CALL_OW 251
78101: PPUSH
78102: LD_VAR 0 10
78106: PPUSH
78107: LD_INT 2
78109: PPUSH
78110: CALL_OW 273
78114: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78115: LD_VAR 0 11
78119: PPUSH
78120: LD_VAR 0 12
78124: PPUSH
78125: CALL_OW 488
78129: PUSH
78130: LD_VAR 0 11
78134: PPUSH
78135: LD_VAR 0 12
78139: PPUSH
78140: CALL_OW 428
78144: NOT
78145: AND
78146: IFFALSE 78169
// begin ComMoveXY ( tmp , _x , _y ) ;
78148: LD_VAR 0 13
78152: PPUSH
78153: LD_VAR 0 11
78157: PPUSH
78158: LD_VAR 0 12
78162: PPUSH
78163: CALL_OW 111
// break ;
78167: GO 78171
// end ; end ;
78169: GO 78056
78171: POP
78172: POP
// end ; end ;
78173: GO 77498
78175: POP
78176: POP
// end ;
78177: LD_VAR 0 8
78181: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78182: LD_INT 0
78184: PPUSH
// result := true ;
78185: LD_ADDR_VAR 0 3
78189: PUSH
78190: LD_INT 1
78192: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78193: LD_VAR 0 2
78197: PUSH
78198: LD_INT 24
78200: DOUBLE
78201: EQUAL
78202: IFTRUE 78212
78204: LD_INT 33
78206: DOUBLE
78207: EQUAL
78208: IFTRUE 78212
78210: GO 78237
78212: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78213: LD_ADDR_VAR 0 3
78217: PUSH
78218: LD_INT 32
78220: PPUSH
78221: LD_VAR 0 1
78225: PPUSH
78226: CALL_OW 321
78230: PUSH
78231: LD_INT 2
78233: EQUAL
78234: ST_TO_ADDR
78235: GO 78557
78237: LD_INT 20
78239: DOUBLE
78240: EQUAL
78241: IFTRUE 78245
78243: GO 78270
78245: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78246: LD_ADDR_VAR 0 3
78250: PUSH
78251: LD_INT 6
78253: PPUSH
78254: LD_VAR 0 1
78258: PPUSH
78259: CALL_OW 321
78263: PUSH
78264: LD_INT 2
78266: EQUAL
78267: ST_TO_ADDR
78268: GO 78557
78270: LD_INT 22
78272: DOUBLE
78273: EQUAL
78274: IFTRUE 78284
78276: LD_INT 36
78278: DOUBLE
78279: EQUAL
78280: IFTRUE 78284
78282: GO 78309
78284: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78285: LD_ADDR_VAR 0 3
78289: PUSH
78290: LD_INT 15
78292: PPUSH
78293: LD_VAR 0 1
78297: PPUSH
78298: CALL_OW 321
78302: PUSH
78303: LD_INT 2
78305: EQUAL
78306: ST_TO_ADDR
78307: GO 78557
78309: LD_INT 30
78311: DOUBLE
78312: EQUAL
78313: IFTRUE 78317
78315: GO 78342
78317: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78318: LD_ADDR_VAR 0 3
78322: PUSH
78323: LD_INT 20
78325: PPUSH
78326: LD_VAR 0 1
78330: PPUSH
78331: CALL_OW 321
78335: PUSH
78336: LD_INT 2
78338: EQUAL
78339: ST_TO_ADDR
78340: GO 78557
78342: LD_INT 28
78344: DOUBLE
78345: EQUAL
78346: IFTRUE 78356
78348: LD_INT 21
78350: DOUBLE
78351: EQUAL
78352: IFTRUE 78356
78354: GO 78381
78356: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78357: LD_ADDR_VAR 0 3
78361: PUSH
78362: LD_INT 21
78364: PPUSH
78365: LD_VAR 0 1
78369: PPUSH
78370: CALL_OW 321
78374: PUSH
78375: LD_INT 2
78377: EQUAL
78378: ST_TO_ADDR
78379: GO 78557
78381: LD_INT 16
78383: DOUBLE
78384: EQUAL
78385: IFTRUE 78389
78387: GO 78416
78389: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78390: LD_ADDR_VAR 0 3
78394: PUSH
78395: LD_EXP 107
78399: PPUSH
78400: LD_VAR 0 1
78404: PPUSH
78405: CALL_OW 321
78409: PUSH
78410: LD_INT 2
78412: EQUAL
78413: ST_TO_ADDR
78414: GO 78557
78416: LD_INT 19
78418: DOUBLE
78419: EQUAL
78420: IFTRUE 78430
78422: LD_INT 23
78424: DOUBLE
78425: EQUAL
78426: IFTRUE 78430
78428: GO 78457
78430: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78431: LD_ADDR_VAR 0 3
78435: PUSH
78436: LD_EXP 106
78440: PPUSH
78441: LD_VAR 0 1
78445: PPUSH
78446: CALL_OW 321
78450: PUSH
78451: LD_INT 2
78453: EQUAL
78454: ST_TO_ADDR
78455: GO 78557
78457: LD_INT 17
78459: DOUBLE
78460: EQUAL
78461: IFTRUE 78465
78463: GO 78490
78465: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78466: LD_ADDR_VAR 0 3
78470: PUSH
78471: LD_INT 39
78473: PPUSH
78474: LD_VAR 0 1
78478: PPUSH
78479: CALL_OW 321
78483: PUSH
78484: LD_INT 2
78486: EQUAL
78487: ST_TO_ADDR
78488: GO 78557
78490: LD_INT 18
78492: DOUBLE
78493: EQUAL
78494: IFTRUE 78498
78496: GO 78523
78498: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78499: LD_ADDR_VAR 0 3
78503: PUSH
78504: LD_INT 40
78506: PPUSH
78507: LD_VAR 0 1
78511: PPUSH
78512: CALL_OW 321
78516: PUSH
78517: LD_INT 2
78519: EQUAL
78520: ST_TO_ADDR
78521: GO 78557
78523: LD_INT 27
78525: DOUBLE
78526: EQUAL
78527: IFTRUE 78531
78529: GO 78556
78531: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78532: LD_ADDR_VAR 0 3
78536: PUSH
78537: LD_INT 35
78539: PPUSH
78540: LD_VAR 0 1
78544: PPUSH
78545: CALL_OW 321
78549: PUSH
78550: LD_INT 2
78552: EQUAL
78553: ST_TO_ADDR
78554: GO 78557
78556: POP
// end ;
78557: LD_VAR 0 3
78561: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78562: LD_INT 0
78564: PPUSH
78565: PPUSH
78566: PPUSH
78567: PPUSH
78568: PPUSH
78569: PPUSH
78570: PPUSH
78571: PPUSH
78572: PPUSH
78573: PPUSH
78574: PPUSH
// result := false ;
78575: LD_ADDR_VAR 0 6
78579: PUSH
78580: LD_INT 0
78582: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78583: LD_VAR 0 1
78587: NOT
78588: PUSH
78589: LD_VAR 0 1
78593: PPUSH
78594: CALL_OW 266
78598: PUSH
78599: LD_INT 0
78601: PUSH
78602: LD_INT 1
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: IN
78609: NOT
78610: OR
78611: PUSH
78612: LD_VAR 0 2
78616: NOT
78617: OR
78618: PUSH
78619: LD_VAR 0 5
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 1
78629: PUSH
78630: LD_INT 2
78632: PUSH
78633: LD_INT 3
78635: PUSH
78636: LD_INT 4
78638: PUSH
78639: LD_INT 5
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: IN
78650: NOT
78651: OR
78652: PUSH
78653: LD_VAR 0 3
78657: PPUSH
78658: LD_VAR 0 4
78662: PPUSH
78663: CALL_OW 488
78667: NOT
78668: OR
78669: IFFALSE 78673
// exit ;
78671: GO 79409
// side := GetSide ( depot ) ;
78673: LD_ADDR_VAR 0 9
78677: PUSH
78678: LD_VAR 0 1
78682: PPUSH
78683: CALL_OW 255
78687: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
78688: LD_VAR 0 9
78692: PPUSH
78693: LD_VAR 0 2
78697: PPUSH
78698: CALL 78182 0 2
78702: NOT
78703: IFFALSE 78707
// exit ;
78705: GO 79409
// pom := GetBase ( depot ) ;
78707: LD_ADDR_VAR 0 10
78711: PUSH
78712: LD_VAR 0 1
78716: PPUSH
78717: CALL_OW 274
78721: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78722: LD_ADDR_VAR 0 11
78726: PUSH
78727: LD_VAR 0 2
78731: PPUSH
78732: LD_VAR 0 1
78736: PPUSH
78737: CALL_OW 248
78741: PPUSH
78742: CALL_OW 450
78746: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78747: LD_VAR 0 10
78751: PPUSH
78752: LD_INT 1
78754: PPUSH
78755: CALL_OW 275
78759: PUSH
78760: LD_VAR 0 11
78764: PUSH
78765: LD_INT 1
78767: ARRAY
78768: GREATEREQUAL
78769: PUSH
78770: LD_VAR 0 10
78774: PPUSH
78775: LD_INT 2
78777: PPUSH
78778: CALL_OW 275
78782: PUSH
78783: LD_VAR 0 11
78787: PUSH
78788: LD_INT 2
78790: ARRAY
78791: GREATEREQUAL
78792: AND
78793: PUSH
78794: LD_VAR 0 10
78798: PPUSH
78799: LD_INT 3
78801: PPUSH
78802: CALL_OW 275
78806: PUSH
78807: LD_VAR 0 11
78811: PUSH
78812: LD_INT 3
78814: ARRAY
78815: GREATEREQUAL
78816: AND
78817: NOT
78818: IFFALSE 78822
// exit ;
78820: GO 79409
// if GetBType ( depot ) = b_depot then
78822: LD_VAR 0 1
78826: PPUSH
78827: CALL_OW 266
78831: PUSH
78832: LD_INT 0
78834: EQUAL
78835: IFFALSE 78847
// dist := 28 else
78837: LD_ADDR_VAR 0 14
78841: PUSH
78842: LD_INT 28
78844: ST_TO_ADDR
78845: GO 78855
// dist := 36 ;
78847: LD_ADDR_VAR 0 14
78851: PUSH
78852: LD_INT 36
78854: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78855: LD_VAR 0 1
78859: PPUSH
78860: LD_VAR 0 3
78864: PPUSH
78865: LD_VAR 0 4
78869: PPUSH
78870: CALL_OW 297
78874: PUSH
78875: LD_VAR 0 14
78879: GREATER
78880: IFFALSE 78884
// exit ;
78882: GO 79409
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78884: LD_ADDR_VAR 0 12
78888: PUSH
78889: LD_VAR 0 2
78893: PPUSH
78894: LD_VAR 0 3
78898: PPUSH
78899: LD_VAR 0 4
78903: PPUSH
78904: LD_VAR 0 5
78908: PPUSH
78909: LD_VAR 0 1
78913: PPUSH
78914: CALL_OW 248
78918: PPUSH
78919: LD_INT 0
78921: PPUSH
78922: CALL 79414 0 6
78926: ST_TO_ADDR
// if not hexes then
78927: LD_VAR 0 12
78931: NOT
78932: IFFALSE 78936
// exit ;
78934: GO 79409
// hex := GetHexInfo ( x , y ) ;
78936: LD_ADDR_VAR 0 15
78940: PUSH
78941: LD_VAR 0 3
78945: PPUSH
78946: LD_VAR 0 4
78950: PPUSH
78951: CALL_OW 546
78955: ST_TO_ADDR
// if hex [ 1 ] then
78956: LD_VAR 0 15
78960: PUSH
78961: LD_INT 1
78963: ARRAY
78964: IFFALSE 78968
// exit ;
78966: GO 79409
// height := hex [ 2 ] ;
78968: LD_ADDR_VAR 0 13
78972: PUSH
78973: LD_VAR 0 15
78977: PUSH
78978: LD_INT 2
78980: ARRAY
78981: ST_TO_ADDR
// for i = 1 to hexes do
78982: LD_ADDR_VAR 0 7
78986: PUSH
78987: DOUBLE
78988: LD_INT 1
78990: DEC
78991: ST_TO_ADDR
78992: LD_VAR 0 12
78996: PUSH
78997: FOR_TO
78998: IFFALSE 79328
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79000: LD_VAR 0 12
79004: PUSH
79005: LD_VAR 0 7
79009: ARRAY
79010: PUSH
79011: LD_INT 1
79013: ARRAY
79014: PPUSH
79015: LD_VAR 0 12
79019: PUSH
79020: LD_VAR 0 7
79024: ARRAY
79025: PUSH
79026: LD_INT 2
79028: ARRAY
79029: PPUSH
79030: CALL_OW 488
79034: NOT
79035: PUSH
79036: LD_VAR 0 12
79040: PUSH
79041: LD_VAR 0 7
79045: ARRAY
79046: PUSH
79047: LD_INT 1
79049: ARRAY
79050: PPUSH
79051: LD_VAR 0 12
79055: PUSH
79056: LD_VAR 0 7
79060: ARRAY
79061: PUSH
79062: LD_INT 2
79064: ARRAY
79065: PPUSH
79066: CALL_OW 428
79070: PUSH
79071: LD_INT 0
79073: GREATER
79074: OR
79075: PUSH
79076: LD_VAR 0 12
79080: PUSH
79081: LD_VAR 0 7
79085: ARRAY
79086: PUSH
79087: LD_INT 1
79089: ARRAY
79090: PPUSH
79091: LD_VAR 0 12
79095: PUSH
79096: LD_VAR 0 7
79100: ARRAY
79101: PUSH
79102: LD_INT 2
79104: ARRAY
79105: PPUSH
79106: CALL_OW 351
79110: OR
79111: IFFALSE 79117
// exit ;
79113: POP
79114: POP
79115: GO 79409
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79117: LD_ADDR_VAR 0 8
79121: PUSH
79122: LD_VAR 0 12
79126: PUSH
79127: LD_VAR 0 7
79131: ARRAY
79132: PUSH
79133: LD_INT 1
79135: ARRAY
79136: PPUSH
79137: LD_VAR 0 12
79141: PUSH
79142: LD_VAR 0 7
79146: ARRAY
79147: PUSH
79148: LD_INT 2
79150: ARRAY
79151: PPUSH
79152: CALL_OW 546
79156: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79157: LD_VAR 0 8
79161: PUSH
79162: LD_INT 1
79164: ARRAY
79165: PUSH
79166: LD_VAR 0 8
79170: PUSH
79171: LD_INT 2
79173: ARRAY
79174: PUSH
79175: LD_VAR 0 13
79179: PUSH
79180: LD_INT 2
79182: PLUS
79183: GREATER
79184: OR
79185: PUSH
79186: LD_VAR 0 8
79190: PUSH
79191: LD_INT 2
79193: ARRAY
79194: PUSH
79195: LD_VAR 0 13
79199: PUSH
79200: LD_INT 2
79202: MINUS
79203: LESS
79204: OR
79205: PUSH
79206: LD_VAR 0 8
79210: PUSH
79211: LD_INT 3
79213: ARRAY
79214: PUSH
79215: LD_INT 0
79217: PUSH
79218: LD_INT 8
79220: PUSH
79221: LD_INT 9
79223: PUSH
79224: LD_INT 10
79226: PUSH
79227: LD_INT 11
79229: PUSH
79230: LD_INT 12
79232: PUSH
79233: LD_INT 13
79235: PUSH
79236: LD_INT 16
79238: PUSH
79239: LD_INT 17
79241: PUSH
79242: LD_INT 18
79244: PUSH
79245: LD_INT 19
79247: PUSH
79248: LD_INT 20
79250: PUSH
79251: LD_INT 21
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: IN
79269: NOT
79270: OR
79271: PUSH
79272: LD_VAR 0 8
79276: PUSH
79277: LD_INT 5
79279: ARRAY
79280: NOT
79281: OR
79282: PUSH
79283: LD_VAR 0 8
79287: PUSH
79288: LD_INT 6
79290: ARRAY
79291: PUSH
79292: LD_INT 1
79294: PUSH
79295: LD_INT 2
79297: PUSH
79298: LD_INT 7
79300: PUSH
79301: LD_INT 9
79303: PUSH
79304: LD_INT 10
79306: PUSH
79307: LD_INT 11
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: IN
79318: NOT
79319: OR
79320: IFFALSE 79326
// exit ;
79322: POP
79323: POP
79324: GO 79409
// end ;
79326: GO 78997
79328: POP
79329: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79330: LD_VAR 0 9
79334: PPUSH
79335: LD_VAR 0 3
79339: PPUSH
79340: LD_VAR 0 4
79344: PPUSH
79345: LD_INT 20
79347: PPUSH
79348: CALL 71354 0 4
79352: PUSH
79353: LD_INT 4
79355: ARRAY
79356: IFFALSE 79360
// exit ;
79358: GO 79409
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79360: LD_VAR 0 2
79364: PUSH
79365: LD_INT 29
79367: PUSH
79368: LD_INT 30
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: IN
79375: PUSH
79376: LD_VAR 0 3
79380: PPUSH
79381: LD_VAR 0 4
79385: PPUSH
79386: LD_VAR 0 9
79390: PPUSH
79391: CALL_OW 440
79395: NOT
79396: AND
79397: IFFALSE 79401
// exit ;
79399: GO 79409
// result := true ;
79401: LD_ADDR_VAR 0 6
79405: PUSH
79406: LD_INT 1
79408: ST_TO_ADDR
// end ;
79409: LD_VAR 0 6
79413: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79414: LD_INT 0
79416: PPUSH
79417: PPUSH
79418: PPUSH
79419: PPUSH
79420: PPUSH
79421: PPUSH
79422: PPUSH
79423: PPUSH
79424: PPUSH
79425: PPUSH
79426: PPUSH
79427: PPUSH
79428: PPUSH
79429: PPUSH
79430: PPUSH
79431: PPUSH
79432: PPUSH
79433: PPUSH
79434: PPUSH
79435: PPUSH
79436: PPUSH
79437: PPUSH
79438: PPUSH
79439: PPUSH
79440: PPUSH
79441: PPUSH
79442: PPUSH
79443: PPUSH
79444: PPUSH
79445: PPUSH
79446: PPUSH
79447: PPUSH
79448: PPUSH
79449: PPUSH
79450: PPUSH
79451: PPUSH
79452: PPUSH
79453: PPUSH
79454: PPUSH
79455: PPUSH
79456: PPUSH
79457: PPUSH
79458: PPUSH
79459: PPUSH
79460: PPUSH
79461: PPUSH
79462: PPUSH
79463: PPUSH
79464: PPUSH
79465: PPUSH
79466: PPUSH
79467: PPUSH
79468: PPUSH
79469: PPUSH
79470: PPUSH
79471: PPUSH
79472: PPUSH
79473: PPUSH
// result = [ ] ;
79474: LD_ADDR_VAR 0 7
79478: PUSH
79479: EMPTY
79480: ST_TO_ADDR
// temp_list = [ ] ;
79481: LD_ADDR_VAR 0 9
79485: PUSH
79486: EMPTY
79487: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79488: LD_VAR 0 4
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: LD_INT 1
79498: PUSH
79499: LD_INT 2
79501: PUSH
79502: LD_INT 3
79504: PUSH
79505: LD_INT 4
79507: PUSH
79508: LD_INT 5
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: IN
79519: NOT
79520: PUSH
79521: LD_VAR 0 1
79525: PUSH
79526: LD_INT 0
79528: PUSH
79529: LD_INT 1
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: IN
79536: PUSH
79537: LD_VAR 0 5
79541: PUSH
79542: LD_INT 1
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: LD_INT 3
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: LIST
79555: IN
79556: NOT
79557: AND
79558: OR
79559: IFFALSE 79563
// exit ;
79561: GO 97954
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79563: LD_VAR 0 1
79567: PUSH
79568: LD_INT 6
79570: PUSH
79571: LD_INT 7
79573: PUSH
79574: LD_INT 8
79576: PUSH
79577: LD_INT 13
79579: PUSH
79580: LD_INT 12
79582: PUSH
79583: LD_INT 15
79585: PUSH
79586: LD_INT 11
79588: PUSH
79589: LD_INT 14
79591: PUSH
79592: LD_INT 10
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: IN
79606: IFFALSE 79616
// btype = b_lab ;
79608: LD_ADDR_VAR 0 1
79612: PUSH
79613: LD_INT 6
79615: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79616: LD_VAR 0 6
79620: PUSH
79621: LD_INT 0
79623: PUSH
79624: LD_INT 1
79626: PUSH
79627: LD_INT 2
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: LIST
79634: IN
79635: NOT
79636: PUSH
79637: LD_VAR 0 1
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: LD_INT 3
79653: PUSH
79654: LD_INT 6
79656: PUSH
79657: LD_INT 36
79659: PUSH
79660: LD_INT 4
79662: PUSH
79663: LD_INT 5
79665: PUSH
79666: LD_INT 31
79668: PUSH
79669: LD_INT 32
79671: PUSH
79672: LD_INT 33
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: IN
79688: NOT
79689: PUSH
79690: LD_VAR 0 6
79694: PUSH
79695: LD_INT 1
79697: EQUAL
79698: AND
79699: OR
79700: PUSH
79701: LD_VAR 0 1
79705: PUSH
79706: LD_INT 2
79708: PUSH
79709: LD_INT 3
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: IN
79716: NOT
79717: PUSH
79718: LD_VAR 0 6
79722: PUSH
79723: LD_INT 2
79725: EQUAL
79726: AND
79727: OR
79728: IFFALSE 79738
// mode = 0 ;
79730: LD_ADDR_VAR 0 6
79734: PUSH
79735: LD_INT 0
79737: ST_TO_ADDR
// case mode of 0 :
79738: LD_VAR 0 6
79742: PUSH
79743: LD_INT 0
79745: DOUBLE
79746: EQUAL
79747: IFTRUE 79751
79749: GO 91204
79751: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79752: LD_ADDR_VAR 0 11
79756: PUSH
79757: LD_INT 0
79759: PUSH
79760: LD_INT 0
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 0
79769: PUSH
79770: LD_INT 1
79772: NEG
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 1
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: PUSH
79791: LD_INT 1
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 0
79800: PUSH
79801: LD_INT 1
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 1
79810: NEG
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: NEG
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 1
79833: NEG
79834: PUSH
79835: LD_INT 2
79837: NEG
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: LD_INT 0
79845: PUSH
79846: LD_INT 2
79848: NEG
79849: PUSH
79850: EMPTY
79851: LIST
79852: LIST
79853: PUSH
79854: LD_INT 1
79856: PUSH
79857: LD_INT 1
79859: NEG
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PUSH
79865: LD_INT 1
79867: PUSH
79868: LD_INT 2
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 0
79877: PUSH
79878: LD_INT 2
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: LD_INT 1
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: PUSH
79899: LD_INT 3
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 0
79908: PUSH
79909: LD_INT 3
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 1
79918: NEG
79919: PUSH
79920: LD_INT 2
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79945: LD_ADDR_VAR 0 12
79949: PUSH
79950: LD_INT 0
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: LD_INT 1
79965: NEG
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: LD_INT 0
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 1
79983: PUSH
79984: LD_INT 1
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 0
79993: PUSH
79994: LD_INT 1
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 1
80003: NEG
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: NEG
80015: PUSH
80016: LD_INT 1
80018: NEG
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: PUSH
80027: LD_INT 1
80029: NEG
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 2
80037: PUSH
80038: LD_INT 0
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 1
80057: NEG
80058: PUSH
80059: LD_INT 1
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 2
80068: NEG
80069: PUSH
80070: LD_INT 0
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 2
80079: NEG
80080: PUSH
80081: LD_INT 1
80083: NEG
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 2
80091: NEG
80092: PUSH
80093: LD_INT 1
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 3
80102: NEG
80103: PUSH
80104: LD_INT 0
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 3
80113: NEG
80114: PUSH
80115: LD_INT 1
80117: NEG
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80141: LD_ADDR_VAR 0 13
80145: PUSH
80146: LD_INT 0
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 0
80158: PUSH
80159: LD_INT 1
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 1
80169: PUSH
80170: LD_INT 0
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 1
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 1
80199: NEG
80200: PUSH
80201: LD_INT 0
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: NEG
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: NEG
80223: PUSH
80224: LD_INT 2
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 2
80234: PUSH
80235: LD_INT 1
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: PUSH
80242: LD_INT 2
80244: PUSH
80245: LD_INT 2
80247: PUSH
80248: EMPTY
80249: LIST
80250: LIST
80251: PUSH
80252: LD_INT 1
80254: PUSH
80255: LD_INT 2
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 2
80264: NEG
80265: PUSH
80266: LD_INT 1
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: NEG
80277: PUSH
80278: LD_INT 2
80280: NEG
80281: PUSH
80282: EMPTY
80283: LIST
80284: LIST
80285: PUSH
80286: LD_INT 2
80288: NEG
80289: PUSH
80290: LD_INT 3
80292: NEG
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 3
80300: NEG
80301: PUSH
80302: LD_INT 2
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 3
80312: NEG
80313: PUSH
80314: LD_INT 3
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: EMPTY
80323: LIST
80324: LIST
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80340: LD_ADDR_VAR 0 14
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: LD_INT 0
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 0
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 1
80368: PUSH
80369: LD_INT 0
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 1
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: LD_INT 1
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 1
80398: NEG
80399: PUSH
80400: LD_INT 0
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 1
80409: NEG
80410: PUSH
80411: LD_INT 1
80413: NEG
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 1
80421: NEG
80422: PUSH
80423: LD_INT 2
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 0
80433: PUSH
80434: LD_INT 2
80436: NEG
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 1
80444: PUSH
80445: LD_INT 1
80447: NEG
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 1
80455: PUSH
80456: LD_INT 2
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 0
80465: PUSH
80466: LD_INT 2
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 1
80475: NEG
80476: PUSH
80477: LD_INT 1
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: NEG
80487: PUSH
80488: LD_INT 3
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: LD_INT 3
80501: NEG
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 1
80509: PUSH
80510: LD_INT 2
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80536: LD_ADDR_VAR 0 15
80540: PUSH
80541: LD_INT 0
80543: PUSH
80544: LD_INT 0
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 0
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 1
80564: PUSH
80565: LD_INT 0
80567: PUSH
80568: EMPTY
80569: LIST
80570: LIST
80571: PUSH
80572: LD_INT 1
80574: PUSH
80575: LD_INT 1
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: LD_INT 1
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 1
80594: NEG
80595: PUSH
80596: LD_INT 0
80598: PUSH
80599: EMPTY
80600: LIST
80601: LIST
80602: PUSH
80603: LD_INT 1
80605: NEG
80606: PUSH
80607: LD_INT 1
80609: NEG
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 1
80620: NEG
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 2
80628: PUSH
80629: LD_INT 0
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 2
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 1
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: LD_INT 0
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: LD_INT 1
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: LD_INT 1
80685: NEG
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 3
80693: PUSH
80694: LD_INT 0
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 3
80703: PUSH
80704: LD_INT 1
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80729: LD_ADDR_VAR 0 16
80733: PUSH
80734: LD_INT 0
80736: PUSH
80737: LD_INT 0
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 0
80746: PUSH
80747: LD_INT 1
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 1
80757: PUSH
80758: LD_INT 0
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PUSH
80765: LD_INT 1
80767: PUSH
80768: LD_INT 1
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 0
80777: PUSH
80778: LD_INT 1
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 1
80787: NEG
80788: PUSH
80789: LD_INT 0
80791: PUSH
80792: EMPTY
80793: LIST
80794: LIST
80795: PUSH
80796: LD_INT 1
80798: NEG
80799: PUSH
80800: LD_INT 1
80802: NEG
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: NEG
80811: PUSH
80812: LD_INT 2
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 2
80822: PUSH
80823: LD_INT 1
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 2
80832: PUSH
80833: LD_INT 2
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: LD_INT 2
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 2
80852: NEG
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: NEG
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 3
80876: PUSH
80877: LD_INT 2
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 3
80886: PUSH
80887: LD_INT 3
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 2
80896: PUSH
80897: LD_INT 3
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80922: LD_ADDR_VAR 0 17
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: LD_INT 0
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: LD_INT 1
80942: NEG
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 1
80950: PUSH
80951: LD_INT 0
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 1
80960: PUSH
80961: LD_INT 1
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 0
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: PUSH
80978: LD_INT 1
80980: NEG
80981: PUSH
80982: LD_INT 0
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 1
80991: NEG
80992: PUSH
80993: LD_INT 1
80995: NEG
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PUSH
81001: LD_INT 1
81003: NEG
81004: PUSH
81005: LD_INT 2
81007: NEG
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 0
81015: PUSH
81016: LD_INT 2
81018: NEG
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: PUSH
81024: LD_INT 1
81026: PUSH
81027: LD_INT 1
81029: NEG
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 2
81037: PUSH
81038: LD_INT 0
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 2
81047: PUSH
81048: LD_INT 1
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 2
81057: PUSH
81058: LD_INT 2
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 1
81067: PUSH
81068: LD_INT 2
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 0
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 1
81087: NEG
81088: PUSH
81089: LD_INT 1
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 2
81098: NEG
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 2
81109: NEG
81110: PUSH
81111: LD_INT 1
81113: NEG
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 2
81121: NEG
81122: PUSH
81123: LD_INT 2
81125: NEG
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81152: LD_ADDR_VAR 0 18
81156: PUSH
81157: LD_INT 0
81159: PUSH
81160: LD_INT 0
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 0
81169: PUSH
81170: LD_INT 1
81172: NEG
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 1
81180: PUSH
81181: LD_INT 0
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 1
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PUSH
81198: LD_INT 0
81200: PUSH
81201: LD_INT 1
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 1
81210: NEG
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 1
81221: NEG
81222: PUSH
81223: LD_INT 1
81225: NEG
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: NEG
81234: PUSH
81235: LD_INT 2
81237: NEG
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 0
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 1
81256: PUSH
81257: LD_INT 1
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 2
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 2
81277: PUSH
81278: LD_INT 1
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 2
81287: PUSH
81288: LD_INT 2
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 0
81307: PUSH
81308: LD_INT 2
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 1
81317: NEG
81318: PUSH
81319: LD_INT 1
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 2
81328: NEG
81329: PUSH
81330: LD_INT 0
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 2
81339: NEG
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 2
81351: NEG
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: LIST
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81382: LD_ADDR_VAR 0 19
81386: PUSH
81387: LD_INT 0
81389: PUSH
81390: LD_INT 0
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 0
81399: PUSH
81400: LD_INT 1
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 1
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 1
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 0
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 1
81440: NEG
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: LD_INT 1
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: NEG
81464: PUSH
81465: LD_INT 2
81467: NEG
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: LD_INT 2
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 1
81486: PUSH
81487: LD_INT 1
81489: NEG
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 2
81497: PUSH
81498: LD_INT 0
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 2
81507: PUSH
81508: LD_INT 1
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 2
81517: PUSH
81518: LD_INT 2
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 1
81527: PUSH
81528: LD_INT 2
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 0
81537: PUSH
81538: LD_INT 2
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 1
81547: NEG
81548: PUSH
81549: LD_INT 1
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 2
81569: NEG
81570: PUSH
81571: LD_INT 1
81573: NEG
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 2
81581: NEG
81582: PUSH
81583: LD_INT 2
81585: NEG
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81612: LD_ADDR_VAR 0 20
81616: PUSH
81617: LD_INT 0
81619: PUSH
81620: LD_INT 0
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 0
81629: PUSH
81630: LD_INT 1
81632: NEG
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: LD_INT 0
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 1
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 0
81660: PUSH
81661: LD_INT 1
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: LD_INT 1
81670: NEG
81671: PUSH
81672: LD_INT 0
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PUSH
81679: LD_INT 1
81681: NEG
81682: PUSH
81683: LD_INT 1
81685: NEG
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_INT 1
81693: NEG
81694: PUSH
81695: LD_INT 2
81697: NEG
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_INT 0
81705: PUSH
81706: LD_INT 2
81708: NEG
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 1
81716: PUSH
81717: LD_INT 1
81719: NEG
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: LD_INT 0
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 2
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 2
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 1
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 0
81767: PUSH
81768: LD_INT 2
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 1
81777: NEG
81778: PUSH
81779: LD_INT 1
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 2
81788: NEG
81789: PUSH
81790: LD_INT 0
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 2
81799: NEG
81800: PUSH
81801: LD_INT 1
81803: NEG
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 2
81811: NEG
81812: PUSH
81813: LD_INT 2
81815: NEG
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81842: LD_ADDR_VAR 0 21
81846: PUSH
81847: LD_INT 0
81849: PUSH
81850: LD_INT 0
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 0
81859: PUSH
81860: LD_INT 1
81862: NEG
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: LD_INT 0
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 1
81880: PUSH
81881: LD_INT 1
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 0
81890: PUSH
81891: LD_INT 1
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 1
81900: NEG
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 1
81911: NEG
81912: PUSH
81913: LD_INT 1
81915: NEG
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 1
81923: NEG
81924: PUSH
81925: LD_INT 2
81927: NEG
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 0
81935: PUSH
81936: LD_INT 2
81938: NEG
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 1
81946: PUSH
81947: LD_INT 1
81949: NEG
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 2
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 2
81967: PUSH
81968: LD_INT 1
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 2
81977: PUSH
81978: LD_INT 2
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 1
81987: PUSH
81988: LD_INT 2
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 0
81997: PUSH
81998: LD_INT 2
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 1
82007: NEG
82008: PUSH
82009: LD_INT 1
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 2
82018: NEG
82019: PUSH
82020: LD_INT 0
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 2
82029: NEG
82030: PUSH
82031: LD_INT 1
82033: NEG
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 2
82041: NEG
82042: PUSH
82043: LD_INT 2
82045: NEG
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82072: LD_ADDR_VAR 0 22
82076: PUSH
82077: LD_INT 0
82079: PUSH
82080: LD_INT 0
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 0
82089: PUSH
82090: LD_INT 1
82092: NEG
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 1
82100: PUSH
82101: LD_INT 0
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 1
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 0
82120: PUSH
82121: LD_INT 1
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 1
82130: NEG
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 1
82141: NEG
82142: PUSH
82143: LD_INT 1
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 1
82153: NEG
82154: PUSH
82155: LD_INT 2
82157: NEG
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: LD_INT 2
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 1
82176: PUSH
82177: LD_INT 1
82179: NEG
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: PUSH
82188: LD_INT 0
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 2
82197: PUSH
82198: LD_INT 1
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 2
82207: PUSH
82208: LD_INT 2
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 1
82217: PUSH
82218: LD_INT 2
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 0
82227: PUSH
82228: LD_INT 2
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 1
82237: NEG
82238: PUSH
82239: LD_INT 1
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 2
82248: NEG
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 2
82259: NEG
82260: PUSH
82261: LD_INT 1
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 2
82271: NEG
82272: PUSH
82273: LD_INT 2
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: LIST
82294: LIST
82295: LIST
82296: LIST
82297: LIST
82298: LIST
82299: LIST
82300: LIST
82301: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82302: LD_ADDR_VAR 0 23
82306: PUSH
82307: LD_INT 0
82309: PUSH
82310: LD_INT 0
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 0
82319: PUSH
82320: LD_INT 1
82322: NEG
82323: PUSH
82324: EMPTY
82325: LIST
82326: LIST
82327: PUSH
82328: LD_INT 1
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 1
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 0
82350: PUSH
82351: LD_INT 1
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 1
82360: NEG
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 1
82371: NEG
82372: PUSH
82373: LD_INT 1
82375: NEG
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 1
82383: NEG
82384: PUSH
82385: LD_INT 2
82387: NEG
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 0
82395: PUSH
82396: LD_INT 2
82398: NEG
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 1
82406: PUSH
82407: LD_INT 1
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 2
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: PUSH
82425: LD_INT 2
82427: PUSH
82428: LD_INT 1
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: LD_INT 2
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 1
82447: PUSH
82448: LD_INT 2
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: LD_INT 2
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 1
82467: NEG
82468: PUSH
82469: LD_INT 1
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: LD_INT 0
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 2
82489: NEG
82490: PUSH
82491: LD_INT 1
82493: NEG
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 2
82501: NEG
82502: PUSH
82503: LD_INT 2
82505: NEG
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: LD_INT 3
82517: NEG
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 1
82525: NEG
82526: PUSH
82527: LD_INT 3
82529: NEG
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 1
82537: PUSH
82538: LD_INT 2
82540: NEG
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: LD_INT 2
82548: PUSH
82549: LD_INT 1
82551: NEG
82552: PUSH
82553: EMPTY
82554: LIST
82555: LIST
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82582: LD_ADDR_VAR 0 24
82586: PUSH
82587: LD_INT 0
82589: PUSH
82590: LD_INT 0
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: LD_INT 1
82602: NEG
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 1
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 1
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 0
82630: PUSH
82631: LD_INT 1
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: NEG
82641: PUSH
82642: LD_INT 0
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 1
82651: NEG
82652: PUSH
82653: LD_INT 1
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: NEG
82664: PUSH
82665: LD_INT 2
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 0
82675: PUSH
82676: LD_INT 2
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 1
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 2
82697: PUSH
82698: LD_INT 0
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 2
82707: PUSH
82708: LD_INT 1
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 2
82717: PUSH
82718: LD_INT 2
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: LD_INT 2
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: LD_INT 2
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: NEG
82748: PUSH
82749: LD_INT 1
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 2
82758: NEG
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 2
82769: NEG
82770: PUSH
82771: LD_INT 1
82773: NEG
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 2
82781: NEG
82782: PUSH
82783: LD_INT 2
82785: NEG
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 1
82793: PUSH
82794: LD_INT 2
82796: NEG
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 2
82804: PUSH
82805: LD_INT 1
82807: NEG
82808: PUSH
82809: EMPTY
82810: LIST
82811: LIST
82812: PUSH
82813: LD_INT 3
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: EMPTY
82820: LIST
82821: LIST
82822: PUSH
82823: LD_INT 3
82825: PUSH
82826: LD_INT 2
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82858: LD_ADDR_VAR 0 25
82862: PUSH
82863: LD_INT 0
82865: PUSH
82866: LD_INT 0
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 0
82875: PUSH
82876: LD_INT 1
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 1
82886: PUSH
82887: LD_INT 0
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 1
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 0
82906: PUSH
82907: LD_INT 1
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 1
82916: NEG
82917: PUSH
82918: LD_INT 0
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 1
82927: NEG
82928: PUSH
82929: LD_INT 1
82931: NEG
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 1
82939: NEG
82940: PUSH
82941: LD_INT 2
82943: NEG
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 0
82951: PUSH
82952: LD_INT 2
82954: NEG
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 1
82962: PUSH
82963: LD_INT 1
82965: NEG
82966: PUSH
82967: EMPTY
82968: LIST
82969: LIST
82970: PUSH
82971: LD_INT 2
82973: PUSH
82974: LD_INT 0
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 2
82983: PUSH
82984: LD_INT 1
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 2
82993: PUSH
82994: LD_INT 2
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 1
83003: PUSH
83004: LD_INT 2
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 0
83013: PUSH
83014: LD_INT 2
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 1
83023: NEG
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 2
83034: NEG
83035: PUSH
83036: LD_INT 0
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 2
83045: NEG
83046: PUSH
83047: LD_INT 1
83049: NEG
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 2
83057: NEG
83058: PUSH
83059: LD_INT 2
83061: NEG
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 3
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: LD_INT 3
83079: PUSH
83080: LD_INT 2
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PUSH
83087: LD_INT 2
83089: PUSH
83090: LD_INT 3
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 1
83099: PUSH
83100: LD_INT 3
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83132: LD_ADDR_VAR 0 26
83136: PUSH
83137: LD_INT 0
83139: PUSH
83140: LD_INT 0
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 1
83152: NEG
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 1
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: LD_INT 1
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: LD_INT 0
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 1
83213: NEG
83214: PUSH
83215: LD_INT 2
83217: NEG
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 0
83225: PUSH
83226: LD_INT 2
83228: NEG
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: LD_INT 1
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: LD_INT 0
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 2
83267: PUSH
83268: LD_INT 2
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 1
83277: PUSH
83278: LD_INT 2
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: LD_INT 2
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 1
83297: NEG
83298: PUSH
83299: LD_INT 1
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 2
83308: NEG
83309: PUSH
83310: LD_INT 0
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 2
83319: NEG
83320: PUSH
83321: LD_INT 1
83323: NEG
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 2
83331: NEG
83332: PUSH
83333: LD_INT 2
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 2
83343: PUSH
83344: LD_INT 3
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: LD_INT 3
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 1
83363: NEG
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 2
83374: NEG
83375: PUSH
83376: LD_INT 1
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83408: LD_ADDR_VAR 0 27
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: LD_INT 0
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: LD_INT 1
83428: NEG
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 1
83436: PUSH
83437: LD_INT 0
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: LD_INT 1
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 0
83456: PUSH
83457: LD_INT 1
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 1
83466: NEG
83467: PUSH
83468: LD_INT 0
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: PUSH
83475: LD_INT 1
83477: NEG
83478: PUSH
83479: LD_INT 1
83481: NEG
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PUSH
83487: LD_INT 1
83489: NEG
83490: PUSH
83491: LD_INT 2
83493: NEG
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 0
83501: PUSH
83502: LD_INT 2
83504: NEG
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 1
83512: PUSH
83513: LD_INT 1
83515: NEG
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PUSH
83521: LD_INT 2
83523: PUSH
83524: LD_INT 0
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 2
83533: PUSH
83534: LD_INT 1
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 2
83543: PUSH
83544: LD_INT 2
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 1
83553: PUSH
83554: LD_INT 2
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: LD_INT 2
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 2
83584: NEG
83585: PUSH
83586: LD_INT 0
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 2
83595: NEG
83596: PUSH
83597: LD_INT 1
83599: NEG
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 2
83607: NEG
83608: PUSH
83609: LD_INT 2
83611: NEG
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: LD_INT 1
83619: NEG
83620: PUSH
83621: LD_INT 2
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 2
83630: NEG
83631: PUSH
83632: LD_INT 1
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 3
83641: NEG
83642: PUSH
83643: LD_INT 1
83645: NEG
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 3
83653: NEG
83654: PUSH
83655: LD_INT 2
83657: NEG
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83688: LD_ADDR_VAR 0 28
83692: PUSH
83693: LD_INT 0
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 0
83705: PUSH
83706: LD_INT 1
83708: NEG
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 1
83716: PUSH
83717: LD_INT 0
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: LD_INT 1
83726: PUSH
83727: LD_INT 1
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 0
83736: PUSH
83737: LD_INT 1
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: LD_INT 1
83746: NEG
83747: PUSH
83748: LD_INT 0
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: NEG
83758: PUSH
83759: LD_INT 1
83761: NEG
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 1
83769: NEG
83770: PUSH
83771: LD_INT 2
83773: NEG
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 2
83784: NEG
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: LD_INT 1
83795: NEG
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 2
83803: PUSH
83804: LD_INT 0
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 2
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 2
83823: PUSH
83824: LD_INT 2
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 1
83833: PUSH
83834: LD_INT 2
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: LD_INT 2
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 1
83853: NEG
83854: PUSH
83855: LD_INT 1
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 2
83864: NEG
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 2
83875: NEG
83876: PUSH
83877: LD_INT 1
83879: NEG
83880: PUSH
83881: EMPTY
83882: LIST
83883: LIST
83884: PUSH
83885: LD_INT 2
83887: NEG
83888: PUSH
83889: LD_INT 2
83891: NEG
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 2
83899: NEG
83900: PUSH
83901: LD_INT 3
83903: NEG
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: PUSH
83909: LD_INT 1
83911: NEG
83912: PUSH
83913: LD_INT 3
83915: NEG
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 3
83923: NEG
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 3
83935: NEG
83936: PUSH
83937: LD_INT 2
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83970: LD_ADDR_VAR 0 29
83974: PUSH
83975: LD_INT 0
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 0
83987: PUSH
83988: LD_INT 1
83990: NEG
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 1
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: PUSH
84009: LD_INT 1
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 0
84018: PUSH
84019: LD_INT 1
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 1
84028: NEG
84029: PUSH
84030: LD_INT 0
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 1
84039: NEG
84040: PUSH
84041: LD_INT 1
84043: NEG
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: PUSH
84049: LD_INT 1
84051: NEG
84052: PUSH
84053: LD_INT 2
84055: NEG
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 0
84063: PUSH
84064: LD_INT 2
84066: NEG
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 1
84074: PUSH
84075: LD_INT 1
84077: NEG
84078: PUSH
84079: EMPTY
84080: LIST
84081: LIST
84082: PUSH
84083: LD_INT 2
84085: PUSH
84086: LD_INT 0
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 2
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 1
84105: PUSH
84106: LD_INT 2
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 0
84115: PUSH
84116: LD_INT 2
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: LD_INT 1
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: LD_INT 1
84140: NEG
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 2
84148: NEG
84149: PUSH
84150: LD_INT 2
84152: NEG
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 2
84160: NEG
84161: PUSH
84162: LD_INT 3
84164: NEG
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 2
84172: PUSH
84173: LD_INT 1
84175: NEG
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 3
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 1
84193: PUSH
84194: LD_INT 3
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: LD_INT 2
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 3
84214: NEG
84215: PUSH
84216: LD_INT 2
84218: NEG
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84249: LD_ADDR_VAR 0 30
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: LD_INT 0
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 1
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: LD_INT 1
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 0
84297: PUSH
84298: LD_INT 1
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 1
84307: NEG
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 1
84322: NEG
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: NEG
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 0
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 2
84364: PUSH
84365: LD_INT 0
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 2
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 2
84384: PUSH
84385: LD_INT 2
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: PUSH
84395: LD_INT 2
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 1
84404: NEG
84405: PUSH
84406: LD_INT 1
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: NEG
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 2
84426: NEG
84427: PUSH
84428: LD_INT 1
84430: NEG
84431: PUSH
84432: EMPTY
84433: LIST
84434: LIST
84435: PUSH
84436: LD_INT 1
84438: NEG
84439: PUSH
84440: LD_INT 3
84442: NEG
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: LD_INT 2
84453: NEG
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 3
84461: PUSH
84462: LD_INT 2
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 2
84471: PUSH
84472: LD_INT 3
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 2
84481: NEG
84482: PUSH
84483: LD_INT 1
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 3
84492: NEG
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84527: LD_ADDR_VAR 0 31
84531: PUSH
84532: LD_INT 0
84534: PUSH
84535: LD_INT 0
84537: PUSH
84538: EMPTY
84539: LIST
84540: LIST
84541: PUSH
84542: LD_INT 0
84544: PUSH
84545: LD_INT 1
84547: NEG
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 1
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: PUSH
84563: LD_INT 1
84565: PUSH
84566: LD_INT 1
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: LD_INT 0
84575: PUSH
84576: LD_INT 1
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 1
84585: NEG
84586: PUSH
84587: LD_INT 0
84589: PUSH
84590: EMPTY
84591: LIST
84592: LIST
84593: PUSH
84594: LD_INT 1
84596: NEG
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: NEG
84609: PUSH
84610: LD_INT 2
84612: NEG
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 1
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 2
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 2
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 2
84651: PUSH
84652: LD_INT 2
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: PUSH
84662: LD_INT 2
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: LD_INT 2
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: EMPTY
84687: LIST
84688: LIST
84689: PUSH
84690: LD_INT 2
84692: NEG
84693: PUSH
84694: LD_INT 1
84696: NEG
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 2
84704: NEG
84705: PUSH
84706: LD_INT 2
84708: NEG
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: LD_INT 3
84720: NEG
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 2
84728: PUSH
84729: LD_INT 1
84731: NEG
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 3
84739: PUSH
84740: LD_INT 1
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: PUSH
84747: LD_INT 1
84749: PUSH
84750: LD_INT 3
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 1
84759: NEG
84760: PUSH
84761: LD_INT 2
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 3
84770: NEG
84771: PUSH
84772: LD_INT 2
84774: NEG
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: LIST
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84805: LD_ADDR_VAR 0 32
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: LD_INT 0
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 0
84822: PUSH
84823: LD_INT 1
84825: NEG
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 1
84833: PUSH
84834: LD_INT 0
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: LD_INT 1
84843: PUSH
84844: LD_INT 1
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: LD_INT 1
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 1
84874: NEG
84875: PUSH
84876: LD_INT 1
84878: NEG
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: NEG
84887: PUSH
84888: LD_INT 2
84890: NEG
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: LD_INT 2
84901: NEG
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 1
84909: PUSH
84910: LD_INT 1
84912: NEG
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: LD_INT 2
84920: PUSH
84921: LD_INT 1
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 2
84930: PUSH
84931: LD_INT 2
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: LD_INT 2
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 0
84950: PUSH
84951: LD_INT 2
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 1
84960: NEG
84961: PUSH
84962: LD_INT 1
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 2
84971: NEG
84972: PUSH
84973: LD_INT 0
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 2
84982: NEG
84983: PUSH
84984: LD_INT 1
84986: NEG
84987: PUSH
84988: EMPTY
84989: LIST
84990: LIST
84991: PUSH
84992: LD_INT 1
84994: NEG
84995: PUSH
84996: LD_INT 3
84998: NEG
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 1
85006: PUSH
85007: LD_INT 2
85009: NEG
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 3
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 2
85027: PUSH
85028: LD_INT 3
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: LD_INT 1
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 3
85048: NEG
85049: PUSH
85050: LD_INT 1
85052: NEG
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85083: LD_ADDR_VAR 0 33
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: LD_INT 0
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 0
85100: PUSH
85101: LD_INT 1
85103: NEG
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 0
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 1
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 0
85131: PUSH
85132: LD_INT 1
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: PUSH
85143: LD_INT 0
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 1
85152: NEG
85153: PUSH
85154: LD_INT 1
85156: NEG
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: NEG
85165: PUSH
85166: LD_INT 2
85168: NEG
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: LD_INT 1
85179: NEG
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 2
85187: PUSH
85188: LD_INT 0
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: LD_INT 2
85197: PUSH
85198: LD_INT 1
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 1
85207: PUSH
85208: LD_INT 2
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 0
85217: PUSH
85218: LD_INT 2
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 1
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 2
85238: NEG
85239: PUSH
85240: LD_INT 0
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 2
85249: NEG
85250: PUSH
85251: LD_INT 1
85253: NEG
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: NEG
85262: PUSH
85263: LD_INT 2
85265: NEG
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PUSH
85271: LD_INT 2
85273: NEG
85274: PUSH
85275: LD_INT 3
85277: NEG
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 2
85285: PUSH
85286: LD_INT 1
85288: NEG
85289: PUSH
85290: EMPTY
85291: LIST
85292: LIST
85293: PUSH
85294: LD_INT 3
85296: PUSH
85297: LD_INT 1
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 1
85306: PUSH
85307: LD_INT 3
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: LD_INT 2
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 3
85327: NEG
85328: PUSH
85329: LD_INT 2
85331: NEG
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85362: LD_ADDR_VAR 0 34
85366: PUSH
85367: LD_INT 0
85369: PUSH
85370: LD_INT 0
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 0
85379: PUSH
85380: LD_INT 1
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 1
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 1
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: LD_INT 1
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 1
85431: NEG
85432: PUSH
85433: LD_INT 1
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: NEG
85444: PUSH
85445: LD_INT 2
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: LD_INT 2
85458: NEG
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PUSH
85464: LD_INT 1
85466: PUSH
85467: LD_INT 1
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: LD_INT 1
85480: PUSH
85481: EMPTY
85482: LIST
85483: LIST
85484: PUSH
85485: LD_INT 2
85487: PUSH
85488: LD_INT 2
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 1
85497: PUSH
85498: LD_INT 2
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 1
85507: NEG
85508: PUSH
85509: LD_INT 1
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: LD_INT 2
85518: NEG
85519: PUSH
85520: LD_INT 0
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 2
85529: NEG
85530: PUSH
85531: LD_INT 1
85533: NEG
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 2
85541: NEG
85542: PUSH
85543: LD_INT 2
85545: NEG
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 3
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: PUSH
85566: LD_INT 2
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 3
85576: PUSH
85577: LD_INT 2
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: LD_INT 2
85586: PUSH
85587: LD_INT 3
85589: PUSH
85590: EMPTY
85591: LIST
85592: LIST
85593: PUSH
85594: LD_INT 2
85596: NEG
85597: PUSH
85598: LD_INT 1
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 3
85607: NEG
85608: PUSH
85609: LD_INT 1
85611: NEG
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85642: LD_ADDR_VAR 0 35
85646: PUSH
85647: LD_INT 0
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 1
85670: PUSH
85671: LD_INT 0
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 1
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 0
85690: PUSH
85691: LD_INT 1
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: LD_INT 0
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PUSH
85709: LD_INT 1
85711: NEG
85712: PUSH
85713: LD_INT 1
85715: NEG
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 2
85723: PUSH
85724: LD_INT 1
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 2
85733: NEG
85734: PUSH
85735: LD_INT 1
85737: NEG
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85754: LD_ADDR_VAR 0 36
85758: PUSH
85759: LD_INT 0
85761: PUSH
85762: LD_INT 0
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 1
85774: NEG
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 1
85782: PUSH
85783: LD_INT 0
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: PUSH
85793: LD_INT 1
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 0
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 1
85812: NEG
85813: PUSH
85814: LD_INT 0
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: LD_INT 1
85823: NEG
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: NEG
85836: PUSH
85837: LD_INT 2
85839: NEG
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 1
85847: PUSH
85848: LD_INT 2
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85866: LD_ADDR_VAR 0 37
85870: PUSH
85871: LD_INT 0
85873: PUSH
85874: LD_INT 0
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PUSH
85892: LD_INT 1
85894: PUSH
85895: LD_INT 0
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: LD_INT 1
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: LD_INT 1
85917: PUSH
85918: EMPTY
85919: LIST
85920: LIST
85921: PUSH
85922: LD_INT 1
85924: NEG
85925: PUSH
85926: LD_INT 0
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 1
85935: NEG
85936: PUSH
85937: LD_INT 1
85939: NEG
85940: PUSH
85941: EMPTY
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: LD_INT 1
85950: NEG
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 1
85958: NEG
85959: PUSH
85960: LD_INT 1
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85978: LD_ADDR_VAR 0 38
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: LD_INT 0
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 0
85995: PUSH
85996: LD_INT 1
85998: NEG
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 1
86006: PUSH
86007: LD_INT 0
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: LD_INT 1
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PUSH
86024: LD_INT 0
86026: PUSH
86027: LD_INT 1
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: LD_INT 1
86036: NEG
86037: PUSH
86038: LD_INT 0
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 1
86047: NEG
86048: PUSH
86049: LD_INT 1
86051: NEG
86052: PUSH
86053: EMPTY
86054: LIST
86055: LIST
86056: PUSH
86057: LD_INT 2
86059: PUSH
86060: LD_INT 1
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 2
86069: NEG
86070: PUSH
86071: LD_INT 1
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86090: LD_ADDR_VAR 0 39
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 0
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 0
86107: PUSH
86108: LD_INT 1
86110: NEG
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 1
86118: PUSH
86119: LD_INT 0
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 1
86128: PUSH
86129: LD_INT 1
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 0
86138: PUSH
86139: LD_INT 1
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: LD_INT 1
86148: NEG
86149: PUSH
86150: LD_INT 0
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: LD_INT 1
86163: NEG
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PUSH
86169: LD_INT 1
86171: NEG
86172: PUSH
86173: LD_INT 2
86175: NEG
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 1
86183: PUSH
86184: LD_INT 2
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86202: LD_ADDR_VAR 0 40
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: LD_INT 0
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 0
86219: PUSH
86220: LD_INT 1
86222: NEG
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 1
86230: PUSH
86231: LD_INT 0
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: PUSH
86241: LD_INT 1
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 0
86250: PUSH
86251: LD_INT 1
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 1
86260: NEG
86261: PUSH
86262: LD_INT 0
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: NEG
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: LD_INT 1
86283: PUSH
86284: LD_INT 1
86286: NEG
86287: PUSH
86288: EMPTY
86289: LIST
86290: LIST
86291: PUSH
86292: LD_INT 1
86294: NEG
86295: PUSH
86296: LD_INT 1
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86314: LD_ADDR_VAR 0 41
86318: PUSH
86319: LD_INT 0
86321: PUSH
86322: LD_INT 0
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 1
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: LD_INT 1
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: LD_INT 1
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 1
86372: NEG
86373: PUSH
86374: LD_INT 0
86376: PUSH
86377: EMPTY
86378: LIST
86379: LIST
86380: PUSH
86381: LD_INT 1
86383: NEG
86384: PUSH
86385: LD_INT 1
86387: NEG
86388: PUSH
86389: EMPTY
86390: LIST
86391: LIST
86392: PUSH
86393: LD_INT 1
86395: NEG
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 2
86418: PUSH
86419: LD_INT 0
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 2
86428: PUSH
86429: LD_INT 1
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 2
86438: PUSH
86439: LD_INT 2
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: LD_INT 2
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 1
86458: NEG
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 2
86469: NEG
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 2
86480: NEG
86481: PUSH
86482: LD_INT 1
86484: NEG
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 2
86492: NEG
86493: PUSH
86494: LD_INT 2
86496: NEG
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: LD_INT 3
86508: NEG
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 2
86516: PUSH
86517: LD_INT 1
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 3
86527: PUSH
86528: LD_INT 0
86530: PUSH
86531: EMPTY
86532: LIST
86533: LIST
86534: PUSH
86535: LD_INT 3
86537: PUSH
86538: LD_INT 1
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: PUSH
86545: LD_INT 3
86547: PUSH
86548: LD_INT 2
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: PUSH
86555: LD_INT 3
86557: PUSH
86558: LD_INT 3
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PUSH
86565: LD_INT 2
86567: PUSH
86568: LD_INT 3
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 2
86577: NEG
86578: PUSH
86579: LD_INT 1
86581: PUSH
86582: EMPTY
86583: LIST
86584: LIST
86585: PUSH
86586: LD_INT 3
86588: NEG
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 3
86599: NEG
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 3
86611: NEG
86612: PUSH
86613: LD_INT 2
86615: NEG
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 3
86623: NEG
86624: PUSH
86625: LD_INT 3
86627: NEG
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86664: LD_ADDR_VAR 0 42
86668: PUSH
86669: LD_INT 0
86671: PUSH
86672: LD_INT 0
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 0
86681: PUSH
86682: LD_INT 1
86684: NEG
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 1
86692: PUSH
86693: LD_INT 0
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PUSH
86700: LD_INT 1
86702: PUSH
86703: LD_INT 1
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 0
86712: PUSH
86713: LD_INT 1
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 1
86722: NEG
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 1
86733: NEG
86734: PUSH
86735: LD_INT 1
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 1
86745: NEG
86746: PUSH
86747: LD_INT 2
86749: NEG
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: LD_INT 2
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: LD_INT 1
86771: NEG
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 2
86779: PUSH
86780: LD_INT 1
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 2
86789: PUSH
86790: LD_INT 2
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: PUSH
86800: LD_INT 2
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: LD_INT 2
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 1
86819: NEG
86820: PUSH
86821: LD_INT 1
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 2
86830: NEG
86831: PUSH
86832: LD_INT 1
86834: NEG
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 2
86842: NEG
86843: PUSH
86844: LD_INT 2
86846: NEG
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 2
86854: NEG
86855: PUSH
86856: LD_INT 3
86858: NEG
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: PUSH
86864: LD_INT 1
86866: NEG
86867: PUSH
86868: LD_INT 3
86870: NEG
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PUSH
86876: LD_INT 0
86878: PUSH
86879: LD_INT 3
86881: NEG
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PUSH
86887: LD_INT 1
86889: PUSH
86890: LD_INT 2
86892: NEG
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 3
86900: PUSH
86901: LD_INT 2
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 3
86910: PUSH
86911: LD_INT 3
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 2
86920: PUSH
86921: LD_INT 3
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PUSH
86928: LD_INT 1
86930: PUSH
86931: LD_INT 3
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 0
86940: PUSH
86941: LD_INT 3
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: LD_INT 2
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 3
86961: NEG
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 3
86973: NEG
86974: PUSH
86975: LD_INT 3
86977: NEG
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87014: LD_ADDR_VAR 0 43
87018: PUSH
87019: LD_INT 0
87021: PUSH
87022: LD_INT 0
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: LD_INT 1
87034: NEG
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 1
87042: PUSH
87043: LD_INT 0
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 1
87072: NEG
87073: PUSH
87074: LD_INT 0
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 1
87083: NEG
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 1
87095: NEG
87096: PUSH
87097: LD_INT 2
87099: NEG
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: LD_INT 2
87110: NEG
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: LD_INT 1
87121: NEG
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PUSH
87127: LD_INT 2
87129: PUSH
87130: LD_INT 0
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 2
87139: PUSH
87140: LD_INT 1
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: LD_INT 2
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 0
87159: PUSH
87160: LD_INT 2
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 1
87169: NEG
87170: PUSH
87171: LD_INT 1
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 2
87180: NEG
87181: PUSH
87182: LD_INT 0
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: NEG
87192: PUSH
87193: LD_INT 1
87195: NEG
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: NEG
87204: PUSH
87205: LD_INT 3
87207: NEG
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 0
87215: PUSH
87216: LD_INT 3
87218: NEG
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 1
87226: PUSH
87227: LD_INT 2
87229: NEG
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 2
87237: PUSH
87238: LD_INT 1
87240: NEG
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 3
87248: PUSH
87249: LD_INT 0
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 3
87258: PUSH
87259: LD_INT 1
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 1
87268: PUSH
87269: LD_INT 3
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 0
87278: PUSH
87279: LD_INT 3
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 1
87288: NEG
87289: PUSH
87290: LD_INT 2
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: PUSH
87297: LD_INT 2
87299: NEG
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 3
87310: NEG
87311: PUSH
87312: LD_INT 0
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 3
87321: NEG
87322: PUSH
87323: LD_INT 1
87325: NEG
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: LIST
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87362: LD_ADDR_VAR 0 44
87366: PUSH
87367: LD_INT 0
87369: PUSH
87370: LD_INT 0
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 0
87379: PUSH
87380: LD_INT 1
87382: NEG
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: PUSH
87388: LD_INT 1
87390: PUSH
87391: LD_INT 0
87393: PUSH
87394: EMPTY
87395: LIST
87396: LIST
87397: PUSH
87398: LD_INT 1
87400: PUSH
87401: LD_INT 1
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PUSH
87408: LD_INT 0
87410: PUSH
87411: LD_INT 1
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: NEG
87432: PUSH
87433: LD_INT 1
87435: NEG
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: LD_INT 2
87447: NEG
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 1
87455: PUSH
87456: LD_INT 1
87458: NEG
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 2
87466: PUSH
87467: LD_INT 0
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 2
87476: PUSH
87477: LD_INT 1
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 2
87486: PUSH
87487: LD_INT 2
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 1
87496: PUSH
87497: LD_INT 2
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: NEG
87507: PUSH
87508: LD_INT 1
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 2
87517: NEG
87518: PUSH
87519: LD_INT 0
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 2
87528: NEG
87529: PUSH
87530: LD_INT 1
87532: NEG
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: NEG
87541: PUSH
87542: LD_INT 2
87544: NEG
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 2
87552: NEG
87553: PUSH
87554: LD_INT 3
87556: NEG
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 3
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 3
87585: PUSH
87586: LD_INT 1
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: PUSH
87593: LD_INT 3
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 3
87605: PUSH
87606: LD_INT 3
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 2
87615: PUSH
87616: LD_INT 3
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: LD_INT 2
87625: NEG
87626: PUSH
87627: LD_INT 1
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 3
87636: NEG
87637: PUSH
87638: LD_INT 0
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 3
87647: NEG
87648: PUSH
87649: LD_INT 1
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 3
87659: NEG
87660: PUSH
87661: LD_INT 2
87663: NEG
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 3
87671: NEG
87672: PUSH
87673: LD_INT 3
87675: NEG
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87712: LD_ADDR_VAR 0 45
87716: PUSH
87717: LD_INT 0
87719: PUSH
87720: LD_INT 0
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 0
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 1
87740: PUSH
87741: LD_INT 0
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 1
87750: PUSH
87751: LD_INT 1
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: PUSH
87758: LD_INT 0
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 1
87781: NEG
87782: PUSH
87783: LD_INT 1
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: LD_INT 2
87797: NEG
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: LD_INT 2
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 2
87827: PUSH
87828: LD_INT 1
87830: PUSH
87831: EMPTY
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: LD_INT 2
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: PUSH
87848: LD_INT 2
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 2
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 1
87867: NEG
87868: PUSH
87869: LD_INT 1
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: NEG
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 2
87890: NEG
87891: PUSH
87892: LD_INT 2
87894: NEG
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 2
87902: NEG
87903: PUSH
87904: LD_INT 3
87906: NEG
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: LD_INT 3
87918: NEG
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: LD_INT 3
87929: NEG
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 3
87948: PUSH
87949: LD_INT 2
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 3
87958: PUSH
87959: LD_INT 3
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 2
87968: PUSH
87969: LD_INT 3
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 1
87978: PUSH
87979: LD_INT 3
87981: PUSH
87982: EMPTY
87983: LIST
87984: LIST
87985: PUSH
87986: LD_INT 0
87988: PUSH
87989: LD_INT 3
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: PUSH
87996: LD_INT 1
87998: NEG
87999: PUSH
88000: LD_INT 2
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 3
88009: NEG
88010: PUSH
88011: LD_INT 2
88013: NEG
88014: PUSH
88015: EMPTY
88016: LIST
88017: LIST
88018: PUSH
88019: LD_INT 3
88021: NEG
88022: PUSH
88023: LD_INT 3
88025: NEG
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88062: LD_ADDR_VAR 0 46
88066: PUSH
88067: LD_INT 0
88069: PUSH
88070: LD_INT 0
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: LD_INT 1
88082: NEG
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: LD_INT 1
88090: PUSH
88091: LD_INT 0
88093: PUSH
88094: EMPTY
88095: LIST
88096: LIST
88097: PUSH
88098: LD_INT 1
88100: PUSH
88101: LD_INT 1
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 0
88110: PUSH
88111: LD_INT 1
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: PUSH
88118: LD_INT 1
88120: NEG
88121: PUSH
88122: LD_INT 0
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: PUSH
88129: LD_INT 1
88131: NEG
88132: PUSH
88133: LD_INT 1
88135: NEG
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 1
88143: NEG
88144: PUSH
88145: LD_INT 2
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: LD_INT 2
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 1
88166: PUSH
88167: LD_INT 1
88169: NEG
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 2
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 2
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 1
88197: PUSH
88198: LD_INT 2
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 0
88207: PUSH
88208: LD_INT 2
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 1
88217: NEG
88218: PUSH
88219: LD_INT 1
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 2
88228: NEG
88229: PUSH
88230: LD_INT 0
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 2
88239: NEG
88240: PUSH
88241: LD_INT 1
88243: NEG
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: NEG
88252: PUSH
88253: LD_INT 3
88255: NEG
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 0
88263: PUSH
88264: LD_INT 3
88266: NEG
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: LD_INT 2
88277: NEG
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: LD_INT 2
88285: PUSH
88286: LD_INT 1
88288: NEG
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: LD_INT 3
88296: PUSH
88297: LD_INT 0
88299: PUSH
88300: EMPTY
88301: LIST
88302: LIST
88303: PUSH
88304: LD_INT 3
88306: PUSH
88307: LD_INT 1
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 1
88316: PUSH
88317: LD_INT 3
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: LD_INT 3
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 1
88336: NEG
88337: PUSH
88338: LD_INT 2
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: LD_INT 2
88347: NEG
88348: PUSH
88349: LD_INT 1
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 3
88358: NEG
88359: PUSH
88360: LD_INT 0
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 3
88369: NEG
88370: PUSH
88371: LD_INT 1
88373: NEG
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88410: LD_ADDR_VAR 0 47
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: LD_INT 0
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 1
88430: NEG
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: LD_INT 1
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: PUSH
88456: LD_INT 0
88458: PUSH
88459: LD_INT 1
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 1
88479: NEG
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 1
88491: NEG
88492: PUSH
88493: LD_INT 2
88495: NEG
88496: PUSH
88497: EMPTY
88498: LIST
88499: LIST
88500: PUSH
88501: LD_INT 0
88503: PUSH
88504: LD_INT 2
88506: NEG
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 1
88514: PUSH
88515: LD_INT 1
88517: NEG
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: PUSH
88523: LD_INT 2
88525: NEG
88526: PUSH
88527: LD_INT 1
88529: NEG
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 2
88537: NEG
88538: PUSH
88539: LD_INT 2
88541: NEG
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88561: LD_ADDR_VAR 0 48
88565: PUSH
88566: LD_INT 0
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 0
88578: PUSH
88579: LD_INT 1
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: LD_INT 1
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 1
88619: NEG
88620: PUSH
88621: LD_INT 0
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: NEG
88631: PUSH
88632: LD_INT 1
88634: NEG
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 1
88642: NEG
88643: PUSH
88644: LD_INT 2
88646: NEG
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 0
88654: PUSH
88655: LD_INT 2
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 1
88665: PUSH
88666: LD_INT 1
88668: NEG
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 2
88676: PUSH
88677: LD_INT 0
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 2
88686: PUSH
88687: LD_INT 1
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88708: LD_ADDR_VAR 0 49
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: LD_INT 0
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 0
88725: PUSH
88726: LD_INT 1
88728: NEG
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 1
88736: PUSH
88737: LD_INT 0
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 1
88746: PUSH
88747: LD_INT 1
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 0
88756: PUSH
88757: LD_INT 1
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: LD_INT 0
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: LD_INT 1
88781: NEG
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: LD_INT 1
88792: NEG
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 2
88800: PUSH
88801: LD_INT 0
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 2
88810: PUSH
88811: LD_INT 1
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: LD_INT 2
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 1
88830: PUSH
88831: LD_INT 2
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88852: LD_ADDR_VAR 0 50
88856: PUSH
88857: LD_INT 0
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 0
88869: PUSH
88870: LD_INT 1
88872: NEG
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 1
88880: PUSH
88881: LD_INT 0
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 1
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 0
88900: PUSH
88901: LD_INT 1
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 1
88910: NEG
88911: PUSH
88912: LD_INT 0
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PUSH
88919: LD_INT 1
88921: NEG
88922: PUSH
88923: LD_INT 1
88925: NEG
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 2
88933: PUSH
88934: LD_INT 1
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 2
88943: PUSH
88944: LD_INT 2
88946: PUSH
88947: EMPTY
88948: LIST
88949: LIST
88950: PUSH
88951: LD_INT 1
88953: PUSH
88954: LD_INT 2
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 0
88963: PUSH
88964: LD_INT 2
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: NEG
88974: PUSH
88975: LD_INT 1
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88996: LD_ADDR_VAR 0 51
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: LD_INT 1
89016: NEG
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 1
89034: PUSH
89035: LD_INT 1
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: LD_INT 1
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 1
89065: NEG
89066: PUSH
89067: LD_INT 1
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: EMPTY
89082: LIST
89083: LIST
89084: PUSH
89085: LD_INT 0
89087: PUSH
89088: LD_INT 2
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 2
89108: NEG
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 2
89119: NEG
89120: PUSH
89121: LD_INT 1
89123: NEG
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89143: LD_ADDR_VAR 0 52
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 0
89191: PUSH
89192: LD_INT 1
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: LD_INT 0
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: LD_INT 2
89228: NEG
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 1
89236: NEG
89237: PUSH
89238: LD_INT 1
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 2
89247: NEG
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: EMPTY
89253: LIST
89254: LIST
89255: PUSH
89256: LD_INT 2
89258: NEG
89259: PUSH
89260: LD_INT 1
89262: NEG
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 2
89270: NEG
89271: PUSH
89272: LD_INT 2
89274: NEG
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89294: LD_ADDR_VAR 0 53
89298: PUSH
89299: LD_INT 0
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 0
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: PUSH
89323: LD_INT 0
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 1
89332: PUSH
89333: LD_INT 1
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 0
89342: PUSH
89343: LD_INT 1
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 1
89352: NEG
89353: PUSH
89354: LD_INT 0
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 1
89363: NEG
89364: PUSH
89365: LD_INT 1
89367: NEG
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 1
89375: NEG
89376: PUSH
89377: LD_INT 2
89379: NEG
89380: PUSH
89381: EMPTY
89382: LIST
89383: LIST
89384: PUSH
89385: LD_INT 0
89387: PUSH
89388: LD_INT 2
89390: NEG
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 1
89398: PUSH
89399: LD_INT 1
89401: NEG
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PUSH
89407: LD_INT 2
89409: PUSH
89410: LD_INT 0
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 2
89419: PUSH
89420: LD_INT 1
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: PUSH
89427: LD_INT 2
89429: PUSH
89430: LD_INT 2
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 1
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 0
89449: PUSH
89450: LD_INT 2
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 1
89459: NEG
89460: PUSH
89461: LD_INT 1
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 2
89470: NEG
89471: PUSH
89472: LD_INT 0
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 2
89481: NEG
89482: PUSH
89483: LD_INT 1
89485: NEG
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: PUSH
89491: LD_INT 2
89493: NEG
89494: PUSH
89495: LD_INT 2
89497: NEG
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89524: LD_ADDR_VAR 0 54
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 0
89541: PUSH
89542: LD_INT 1
89544: NEG
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 1
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 1
89562: PUSH
89563: LD_INT 1
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 0
89572: PUSH
89573: LD_INT 1
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: PUSH
89580: LD_INT 1
89582: NEG
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: NEG
89594: PUSH
89595: LD_INT 1
89597: NEG
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: LD_INT 2
89609: NEG
89610: PUSH
89611: EMPTY
89612: LIST
89613: LIST
89614: PUSH
89615: LD_INT 0
89617: PUSH
89618: LD_INT 2
89620: NEG
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: LD_INT 1
89628: PUSH
89629: LD_INT 1
89631: NEG
89632: PUSH
89633: EMPTY
89634: LIST
89635: LIST
89636: PUSH
89637: LD_INT 2
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: PUSH
89647: LD_INT 2
89649: PUSH
89650: LD_INT 1
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 2
89659: PUSH
89660: LD_INT 2
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: PUSH
89667: LD_INT 1
89669: PUSH
89670: LD_INT 2
89672: PUSH
89673: EMPTY
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 0
89679: PUSH
89680: LD_INT 2
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: LD_INT 1
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: LD_INT 0
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 2
89711: NEG
89712: PUSH
89713: LD_INT 1
89715: NEG
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 2
89723: NEG
89724: PUSH
89725: LD_INT 2
89727: NEG
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: EMPTY
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: LIST
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89754: LD_ADDR_VAR 0 55
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 0
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 0
89771: PUSH
89772: LD_INT 1
89774: NEG
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 1
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 1
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 0
89802: PUSH
89803: LD_INT 1
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 1
89812: NEG
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: NEG
89824: PUSH
89825: LD_INT 1
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: NEG
89836: PUSH
89837: LD_INT 2
89839: NEG
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: LD_INT 2
89850: NEG
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 1
89858: PUSH
89859: LD_INT 1
89861: NEG
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: LD_INT 0
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: PUSH
89880: LD_INT 1
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 2
89889: PUSH
89890: LD_INT 2
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 1
89899: PUSH
89900: LD_INT 2
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 0
89909: PUSH
89910: LD_INT 2
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 1
89919: NEG
89920: PUSH
89921: LD_INT 1
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 2
89930: NEG
89931: PUSH
89932: LD_INT 0
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 2
89941: NEG
89942: PUSH
89943: LD_INT 1
89945: NEG
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 2
89953: NEG
89954: PUSH
89955: LD_INT 2
89957: NEG
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89984: LD_ADDR_VAR 0 56
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 0
90001: PUSH
90002: LD_INT 1
90004: NEG
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 1
90012: PUSH
90013: LD_INT 0
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 1
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 0
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 1
90042: NEG
90043: PUSH
90044: LD_INT 0
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 1
90053: NEG
90054: PUSH
90055: LD_INT 1
90057: NEG
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 1
90065: NEG
90066: PUSH
90067: LD_INT 2
90069: NEG
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: PUSH
90075: LD_INT 0
90077: PUSH
90078: LD_INT 2
90080: NEG
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: PUSH
90097: LD_INT 2
90099: PUSH
90100: LD_INT 0
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 2
90109: PUSH
90110: LD_INT 1
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: LD_INT 2
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 1
90129: PUSH
90130: LD_INT 2
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: LD_INT 0
90139: PUSH
90140: LD_INT 2
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: PUSH
90147: LD_INT 1
90149: NEG
90150: PUSH
90151: LD_INT 1
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 2
90160: NEG
90161: PUSH
90162: LD_INT 0
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 2
90171: NEG
90172: PUSH
90173: LD_INT 1
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 2
90183: NEG
90184: PUSH
90185: LD_INT 2
90187: NEG
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: EMPTY
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90214: LD_ADDR_VAR 0 57
90218: PUSH
90219: LD_INT 0
90221: PUSH
90222: LD_INT 0
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 0
90231: PUSH
90232: LD_INT 1
90234: NEG
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 1
90242: PUSH
90243: LD_INT 0
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 1
90252: PUSH
90253: LD_INT 1
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 0
90262: PUSH
90263: LD_INT 1
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 1
90272: NEG
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 1
90283: NEG
90284: PUSH
90285: LD_INT 1
90287: NEG
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PUSH
90293: LD_INT 1
90295: NEG
90296: PUSH
90297: LD_INT 2
90299: NEG
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 0
90307: PUSH
90308: LD_INT 2
90310: NEG
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 1
90318: PUSH
90319: LD_INT 1
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 2
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 2
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 2
90349: PUSH
90350: LD_INT 2
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 1
90359: PUSH
90360: LD_INT 2
90362: PUSH
90363: EMPTY
90364: LIST
90365: LIST
90366: PUSH
90367: LD_INT 0
90369: PUSH
90370: LD_INT 2
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 1
90379: NEG
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 2
90390: NEG
90391: PUSH
90392: LD_INT 0
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 2
90401: NEG
90402: PUSH
90403: LD_INT 1
90405: NEG
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 2
90413: NEG
90414: PUSH
90415: LD_INT 2
90417: NEG
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90444: LD_ADDR_VAR 0 58
90448: PUSH
90449: LD_INT 0
90451: PUSH
90452: LD_INT 0
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: LD_INT 1
90464: NEG
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: LD_INT 1
90472: PUSH
90473: LD_INT 0
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 0
90492: PUSH
90493: LD_INT 1
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 1
90502: NEG
90503: PUSH
90504: LD_INT 0
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 1
90513: NEG
90514: PUSH
90515: LD_INT 1
90517: NEG
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 1
90525: NEG
90526: PUSH
90527: LD_INT 2
90529: NEG
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 0
90537: PUSH
90538: LD_INT 2
90540: NEG
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 1
90548: PUSH
90549: LD_INT 1
90551: NEG
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 2
90559: PUSH
90560: LD_INT 0
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 2
90569: PUSH
90570: LD_INT 1
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 2
90579: PUSH
90580: LD_INT 2
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: LD_INT 1
90589: PUSH
90590: LD_INT 2
90592: PUSH
90593: EMPTY
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: LD_INT 2
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 1
90609: NEG
90610: PUSH
90611: LD_INT 1
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 2
90620: NEG
90621: PUSH
90622: LD_INT 0
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 2
90631: NEG
90632: PUSH
90633: LD_INT 1
90635: NEG
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 2
90643: NEG
90644: PUSH
90645: LD_INT 2
90647: NEG
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90674: LD_ADDR_VAR 0 59
90678: PUSH
90679: LD_INT 0
90681: PUSH
90682: LD_INT 0
90684: PUSH
90685: EMPTY
90686: LIST
90687: LIST
90688: PUSH
90689: LD_INT 0
90691: PUSH
90692: LD_INT 1
90694: NEG
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 1
90702: PUSH
90703: LD_INT 0
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 1
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 0
90722: PUSH
90723: LD_INT 1
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: PUSH
90730: LD_INT 1
90732: NEG
90733: PUSH
90734: LD_INT 0
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: NEG
90744: PUSH
90745: LD_INT 1
90747: NEG
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90762: LD_ADDR_VAR 0 60
90766: PUSH
90767: LD_INT 0
90769: PUSH
90770: LD_INT 0
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: LD_INT 0
90779: PUSH
90780: LD_INT 1
90782: NEG
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 1
90790: PUSH
90791: LD_INT 0
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 1
90800: PUSH
90801: LD_INT 1
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: LD_INT 1
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: LD_INT 0
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 1
90831: NEG
90832: PUSH
90833: LD_INT 1
90835: NEG
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90850: LD_ADDR_VAR 0 61
90854: PUSH
90855: LD_INT 0
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 0
90867: PUSH
90868: LD_INT 1
90870: NEG
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: LD_INT 1
90878: PUSH
90879: LD_INT 0
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PUSH
90886: LD_INT 1
90888: PUSH
90889: LD_INT 1
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 0
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 1
90908: NEG
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 1
90919: NEG
90920: PUSH
90921: LD_INT 1
90923: NEG
90924: PUSH
90925: EMPTY
90926: LIST
90927: LIST
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90938: LD_ADDR_VAR 0 62
90942: PUSH
90943: LD_INT 0
90945: PUSH
90946: LD_INT 0
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: LD_INT 1
90958: NEG
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: PUSH
90964: LD_INT 1
90966: PUSH
90967: LD_INT 0
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 1
90976: PUSH
90977: LD_INT 1
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 0
90986: PUSH
90987: LD_INT 1
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 1
90996: NEG
90997: PUSH
90998: LD_INT 0
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 1
91007: NEG
91008: PUSH
91009: LD_INT 1
91011: NEG
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91026: LD_ADDR_VAR 0 63
91030: PUSH
91031: LD_INT 0
91033: PUSH
91034: LD_INT 0
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 0
91043: PUSH
91044: LD_INT 1
91046: NEG
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: LD_INT 0
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: LD_INT 1
91064: PUSH
91065: LD_INT 1
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 0
91074: PUSH
91075: LD_INT 1
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 1
91084: NEG
91085: PUSH
91086: LD_INT 0
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 1
91095: NEG
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91114: LD_ADDR_VAR 0 64
91118: PUSH
91119: LD_INT 0
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 0
91131: PUSH
91132: LD_INT 1
91134: NEG
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: PUSH
91140: LD_INT 1
91142: PUSH
91143: LD_INT 0
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: LD_INT 1
91152: PUSH
91153: LD_INT 1
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: PUSH
91160: LD_INT 0
91162: PUSH
91163: LD_INT 1
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 1
91172: NEG
91173: PUSH
91174: LD_INT 0
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 1
91183: NEG
91184: PUSH
91185: LD_INT 1
91187: NEG
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: ST_TO_ADDR
// end ; 1 :
91202: GO 97099
91204: LD_INT 1
91206: DOUBLE
91207: EQUAL
91208: IFTRUE 91212
91210: GO 93835
91212: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91213: LD_ADDR_VAR 0 11
91217: PUSH
91218: LD_INT 1
91220: NEG
91221: PUSH
91222: LD_INT 3
91224: NEG
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 0
91232: PUSH
91233: LD_INT 3
91235: NEG
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: LD_INT 2
91246: NEG
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: LIST
91256: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91257: LD_ADDR_VAR 0 12
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: LD_INT 1
91267: NEG
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 3
91275: PUSH
91276: LD_INT 0
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 3
91285: PUSH
91286: LD_INT 1
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: LIST
91297: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91298: LD_ADDR_VAR 0 13
91302: PUSH
91303: LD_INT 3
91305: PUSH
91306: LD_INT 2
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 3
91315: PUSH
91316: LD_INT 3
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 2
91325: PUSH
91326: LD_INT 3
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: LIST
91337: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91338: LD_ADDR_VAR 0 14
91342: PUSH
91343: LD_INT 1
91345: PUSH
91346: LD_INT 3
91348: PUSH
91349: EMPTY
91350: LIST
91351: LIST
91352: PUSH
91353: LD_INT 0
91355: PUSH
91356: LD_INT 3
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: LD_INT 2
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: LIST
91378: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91379: LD_ADDR_VAR 0 15
91383: PUSH
91384: LD_INT 2
91386: NEG
91387: PUSH
91388: LD_INT 1
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 3
91397: NEG
91398: PUSH
91399: LD_INT 0
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 3
91408: NEG
91409: PUSH
91410: LD_INT 1
91412: NEG
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: LIST
91422: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91423: LD_ADDR_VAR 0 16
91427: PUSH
91428: LD_INT 2
91430: NEG
91431: PUSH
91432: LD_INT 3
91434: NEG
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 3
91442: NEG
91443: PUSH
91444: LD_INT 2
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: LD_INT 3
91454: NEG
91455: PUSH
91456: LD_INT 3
91458: NEG
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: LIST
91468: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91469: LD_ADDR_VAR 0 17
91473: PUSH
91474: LD_INT 1
91476: NEG
91477: PUSH
91478: LD_INT 3
91480: NEG
91481: PUSH
91482: EMPTY
91483: LIST
91484: LIST
91485: PUSH
91486: LD_INT 0
91488: PUSH
91489: LD_INT 3
91491: NEG
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: PUSH
91500: LD_INT 2
91502: NEG
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: LIST
91512: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91513: LD_ADDR_VAR 0 18
91517: PUSH
91518: LD_INT 2
91520: PUSH
91521: LD_INT 1
91523: NEG
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 3
91531: PUSH
91532: LD_INT 0
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 3
91541: PUSH
91542: LD_INT 1
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: LIST
91553: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91554: LD_ADDR_VAR 0 19
91558: PUSH
91559: LD_INT 3
91561: PUSH
91562: LD_INT 2
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 3
91571: PUSH
91572: LD_INT 3
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 2
91581: PUSH
91582: LD_INT 3
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: LIST
91593: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91594: LD_ADDR_VAR 0 20
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: LD_INT 3
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: PUSH
91609: LD_INT 0
91611: PUSH
91612: LD_INT 3
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 1
91621: NEG
91622: PUSH
91623: LD_INT 2
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: LIST
91634: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91635: LD_ADDR_VAR 0 21
91639: PUSH
91640: LD_INT 2
91642: NEG
91643: PUSH
91644: LD_INT 1
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 3
91653: NEG
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 3
91664: NEG
91665: PUSH
91666: LD_INT 1
91668: NEG
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: LIST
91678: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91679: LD_ADDR_VAR 0 22
91683: PUSH
91684: LD_INT 2
91686: NEG
91687: PUSH
91688: LD_INT 3
91690: NEG
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 3
91698: NEG
91699: PUSH
91700: LD_INT 2
91702: NEG
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: PUSH
91708: LD_INT 3
91710: NEG
91711: PUSH
91712: LD_INT 3
91714: NEG
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: LIST
91724: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91725: LD_ADDR_VAR 0 23
91729: PUSH
91730: LD_INT 0
91732: PUSH
91733: LD_INT 3
91735: NEG
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 1
91743: NEG
91744: PUSH
91745: LD_INT 4
91747: NEG
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: PUSH
91753: LD_INT 1
91755: PUSH
91756: LD_INT 3
91758: NEG
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: LIST
91768: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91769: LD_ADDR_VAR 0 24
91773: PUSH
91774: LD_INT 3
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 3
91786: PUSH
91787: LD_INT 1
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 4
91797: PUSH
91798: LD_INT 1
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: LIST
91809: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91810: LD_ADDR_VAR 0 25
91814: PUSH
91815: LD_INT 3
91817: PUSH
91818: LD_INT 3
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: LD_INT 4
91827: PUSH
91828: LD_INT 3
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: PUSH
91835: LD_INT 3
91837: PUSH
91838: LD_INT 4
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: EMPTY
91846: LIST
91847: LIST
91848: LIST
91849: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91850: LD_ADDR_VAR 0 26
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: LD_INT 3
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: LD_INT 1
91867: PUSH
91868: LD_INT 4
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: LD_INT 1
91877: NEG
91878: PUSH
91879: LD_INT 3
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: LIST
91890: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91891: LD_ADDR_VAR 0 27
91895: PUSH
91896: LD_INT 3
91898: NEG
91899: PUSH
91900: LD_INT 0
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 3
91909: NEG
91910: PUSH
91911: LD_INT 1
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 4
91920: NEG
91921: PUSH
91922: LD_INT 1
91924: NEG
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: LIST
91934: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91935: LD_ADDR_VAR 0 28
91939: PUSH
91940: LD_INT 3
91942: NEG
91943: PUSH
91944: LD_INT 3
91946: NEG
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 3
91954: NEG
91955: PUSH
91956: LD_INT 4
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 4
91966: NEG
91967: PUSH
91968: LD_INT 3
91970: NEG
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: LIST
91980: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
91981: LD_ADDR_VAR 0 29
91985: PUSH
91986: LD_INT 1
91988: NEG
91989: PUSH
91990: LD_INT 3
91992: NEG
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 0
92000: PUSH
92001: LD_INT 3
92003: NEG
92004: PUSH
92005: EMPTY
92006: LIST
92007: LIST
92008: PUSH
92009: LD_INT 1
92011: PUSH
92012: LD_INT 2
92014: NEG
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: PUSH
92020: LD_INT 1
92022: NEG
92023: PUSH
92024: LD_INT 4
92026: NEG
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 0
92034: PUSH
92035: LD_INT 4
92037: NEG
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 1
92045: PUSH
92046: LD_INT 3
92048: NEG
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 1
92056: NEG
92057: PUSH
92058: LD_INT 5
92060: NEG
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 0
92068: PUSH
92069: LD_INT 5
92071: NEG
92072: PUSH
92073: EMPTY
92074: LIST
92075: LIST
92076: PUSH
92077: LD_INT 1
92079: PUSH
92080: LD_INT 4
92082: NEG
92083: PUSH
92084: EMPTY
92085: LIST
92086: LIST
92087: PUSH
92088: LD_INT 1
92090: NEG
92091: PUSH
92092: LD_INT 6
92094: NEG
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: PUSH
92100: LD_INT 0
92102: PUSH
92103: LD_INT 6
92105: NEG
92106: PUSH
92107: EMPTY
92108: LIST
92109: LIST
92110: PUSH
92111: LD_INT 1
92113: PUSH
92114: LD_INT 5
92116: NEG
92117: PUSH
92118: EMPTY
92119: LIST
92120: LIST
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92136: LD_ADDR_VAR 0 30
92140: PUSH
92141: LD_INT 2
92143: PUSH
92144: LD_INT 1
92146: NEG
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: PUSH
92152: LD_INT 3
92154: PUSH
92155: LD_INT 0
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PUSH
92162: LD_INT 3
92164: PUSH
92165: LD_INT 1
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 3
92174: PUSH
92175: LD_INT 1
92177: NEG
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 4
92185: PUSH
92186: LD_INT 0
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 4
92195: PUSH
92196: LD_INT 1
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 4
92205: PUSH
92206: LD_INT 1
92208: NEG
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 5
92216: PUSH
92217: LD_INT 0
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 5
92226: PUSH
92227: LD_INT 1
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 5
92236: PUSH
92237: LD_INT 1
92239: NEG
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: LD_INT 6
92247: PUSH
92248: LD_INT 0
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: PUSH
92255: LD_INT 6
92257: PUSH
92258: LD_INT 1
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: EMPTY
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92279: LD_ADDR_VAR 0 31
92283: PUSH
92284: LD_INT 3
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 3
92296: PUSH
92297: LD_INT 3
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 2
92306: PUSH
92307: LD_INT 3
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 4
92316: PUSH
92317: LD_INT 3
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: LD_INT 4
92326: PUSH
92327: LD_INT 4
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 3
92336: PUSH
92337: LD_INT 4
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 5
92346: PUSH
92347: LD_INT 4
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 5
92356: PUSH
92357: LD_INT 5
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 4
92366: PUSH
92367: LD_INT 5
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 6
92376: PUSH
92377: LD_INT 5
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: LD_INT 6
92386: PUSH
92387: LD_INT 6
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: PUSH
92394: LD_INT 5
92396: PUSH
92397: LD_INT 6
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: LIST
92416: LIST
92417: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92418: LD_ADDR_VAR 0 32
92422: PUSH
92423: LD_INT 1
92425: PUSH
92426: LD_INT 3
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 0
92435: PUSH
92436: LD_INT 3
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 1
92445: NEG
92446: PUSH
92447: LD_INT 2
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: PUSH
92457: LD_INT 4
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: LD_INT 4
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 1
92476: NEG
92477: PUSH
92478: LD_INT 3
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 1
92487: PUSH
92488: LD_INT 5
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 0
92497: PUSH
92498: LD_INT 5
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 1
92507: NEG
92508: PUSH
92509: LD_INT 4
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 1
92518: PUSH
92519: LD_INT 6
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: LD_INT 0
92528: PUSH
92529: LD_INT 6
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 1
92538: NEG
92539: PUSH
92540: LD_INT 5
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92561: LD_ADDR_VAR 0 33
92565: PUSH
92566: LD_INT 2
92568: NEG
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 3
92579: NEG
92580: PUSH
92581: LD_INT 0
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 3
92590: NEG
92591: PUSH
92592: LD_INT 1
92594: NEG
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 3
92602: NEG
92603: PUSH
92604: LD_INT 1
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 4
92613: NEG
92614: PUSH
92615: LD_INT 0
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 4
92624: NEG
92625: PUSH
92626: LD_INT 1
92628: NEG
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 4
92636: NEG
92637: PUSH
92638: LD_INT 1
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 5
92647: NEG
92648: PUSH
92649: LD_INT 0
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 5
92658: NEG
92659: PUSH
92660: LD_INT 1
92662: NEG
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 5
92670: NEG
92671: PUSH
92672: LD_INT 1
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: PUSH
92679: LD_INT 6
92681: NEG
92682: PUSH
92683: LD_INT 0
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 6
92692: NEG
92693: PUSH
92694: LD_INT 1
92696: NEG
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92716: LD_ADDR_VAR 0 34
92720: PUSH
92721: LD_INT 2
92723: NEG
92724: PUSH
92725: LD_INT 3
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: NEG
92736: PUSH
92737: LD_INT 2
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 3
92747: NEG
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 3
92759: NEG
92760: PUSH
92761: LD_INT 4
92763: NEG
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 4
92771: NEG
92772: PUSH
92773: LD_INT 3
92775: NEG
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 4
92783: NEG
92784: PUSH
92785: LD_INT 4
92787: NEG
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 4
92795: NEG
92796: PUSH
92797: LD_INT 5
92799: NEG
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 5
92807: NEG
92808: PUSH
92809: LD_INT 4
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: LD_INT 5
92819: NEG
92820: PUSH
92821: LD_INT 5
92823: NEG
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 5
92831: NEG
92832: PUSH
92833: LD_INT 6
92835: NEG
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 6
92843: NEG
92844: PUSH
92845: LD_INT 5
92847: NEG
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 6
92855: NEG
92856: PUSH
92857: LD_INT 6
92859: NEG
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92879: LD_ADDR_VAR 0 41
92883: PUSH
92884: LD_INT 0
92886: PUSH
92887: LD_INT 2
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 1
92897: NEG
92898: PUSH
92899: LD_INT 3
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 1
92909: PUSH
92910: LD_INT 2
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: LIST
92922: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92923: LD_ADDR_VAR 0 42
92927: PUSH
92928: LD_INT 2
92930: PUSH
92931: LD_INT 0
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 2
92940: PUSH
92941: LD_INT 1
92943: NEG
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 3
92951: PUSH
92952: LD_INT 1
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: LIST
92963: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92964: LD_ADDR_VAR 0 43
92968: PUSH
92969: LD_INT 2
92971: PUSH
92972: LD_INT 2
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 3
92981: PUSH
92982: LD_INT 2
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 2
92991: PUSH
92992: LD_INT 3
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: LIST
93003: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93004: LD_ADDR_VAR 0 44
93008: PUSH
93009: LD_INT 0
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 1
93021: PUSH
93022: LD_INT 3
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 1
93031: NEG
93032: PUSH
93033: LD_INT 2
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: LIST
93044: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93045: LD_ADDR_VAR 0 45
93049: PUSH
93050: LD_INT 2
93052: NEG
93053: PUSH
93054: LD_INT 0
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 2
93063: NEG
93064: PUSH
93065: LD_INT 1
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 3
93074: NEG
93075: PUSH
93076: LD_INT 1
93078: NEG
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: LIST
93088: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93089: LD_ADDR_VAR 0 46
93093: PUSH
93094: LD_INT 2
93096: NEG
93097: PUSH
93098: LD_INT 2
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 2
93108: NEG
93109: PUSH
93110: LD_INT 3
93112: NEG
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 3
93120: NEG
93121: PUSH
93122: LD_INT 2
93124: NEG
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: LIST
93134: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93135: LD_ADDR_VAR 0 47
93139: PUSH
93140: LD_INT 2
93142: NEG
93143: PUSH
93144: LD_INT 3
93146: NEG
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PUSH
93152: LD_INT 1
93154: NEG
93155: PUSH
93156: LD_INT 3
93158: NEG
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93168: LD_ADDR_VAR 0 48
93172: PUSH
93173: LD_INT 1
93175: PUSH
93176: LD_INT 2
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 2
93186: PUSH
93187: LD_INT 1
93189: NEG
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93199: LD_ADDR_VAR 0 49
93203: PUSH
93204: LD_INT 3
93206: PUSH
93207: LD_INT 1
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 3
93216: PUSH
93217: LD_INT 2
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93228: LD_ADDR_VAR 0 50
93232: PUSH
93233: LD_INT 2
93235: PUSH
93236: LD_INT 3
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 1
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93257: LD_ADDR_VAR 0 51
93261: PUSH
93262: LD_INT 1
93264: NEG
93265: PUSH
93266: LD_INT 2
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 2
93275: NEG
93276: PUSH
93277: LD_INT 1
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93288: LD_ADDR_VAR 0 52
93292: PUSH
93293: LD_INT 3
93295: NEG
93296: PUSH
93297: LD_INT 1
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 3
93307: NEG
93308: PUSH
93309: LD_INT 2
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93321: LD_ADDR_VAR 0 53
93325: PUSH
93326: LD_INT 1
93328: NEG
93329: PUSH
93330: LD_INT 3
93332: NEG
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 0
93340: PUSH
93341: LD_INT 3
93343: NEG
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 1
93351: PUSH
93352: LD_INT 2
93354: NEG
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93365: LD_ADDR_VAR 0 54
93369: PUSH
93370: LD_INT 2
93372: PUSH
93373: LD_INT 1
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 3
93383: PUSH
93384: LD_INT 0
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93406: LD_ADDR_VAR 0 55
93410: PUSH
93411: LD_INT 3
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 3
93423: PUSH
93424: LD_INT 3
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 2
93433: PUSH
93434: LD_INT 3
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: LIST
93445: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93446: LD_ADDR_VAR 0 56
93450: PUSH
93451: LD_INT 1
93453: PUSH
93454: LD_INT 3
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 0
93463: PUSH
93464: LD_INT 3
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: LD_INT 1
93473: NEG
93474: PUSH
93475: LD_INT 2
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: LIST
93486: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93487: LD_ADDR_VAR 0 57
93491: PUSH
93492: LD_INT 2
93494: NEG
93495: PUSH
93496: LD_INT 1
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 3
93505: NEG
93506: PUSH
93507: LD_INT 0
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 3
93516: NEG
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: LIST
93530: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93531: LD_ADDR_VAR 0 58
93535: PUSH
93536: LD_INT 2
93538: NEG
93539: PUSH
93540: LD_INT 3
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 3
93550: NEG
93551: PUSH
93552: LD_INT 2
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 3
93562: NEG
93563: PUSH
93564: LD_INT 3
93566: NEG
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: LIST
93576: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93577: LD_ADDR_VAR 0 59
93581: PUSH
93582: LD_INT 1
93584: NEG
93585: PUSH
93586: LD_INT 2
93588: NEG
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 0
93596: PUSH
93597: LD_INT 2
93599: NEG
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 1
93607: PUSH
93608: LD_INT 1
93610: NEG
93611: PUSH
93612: EMPTY
93613: LIST
93614: LIST
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: LIST
93620: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93621: LD_ADDR_VAR 0 60
93625: PUSH
93626: LD_INT 1
93628: PUSH
93629: LD_INT 1
93631: NEG
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: PUSH
93637: LD_INT 2
93639: PUSH
93640: LD_INT 0
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 2
93649: PUSH
93650: LD_INT 1
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: LIST
93661: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93662: LD_ADDR_VAR 0 61
93666: PUSH
93667: LD_INT 2
93669: PUSH
93670: LD_INT 1
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 2
93679: PUSH
93680: LD_INT 2
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: LD_INT 1
93689: PUSH
93690: LD_INT 2
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: LIST
93701: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93702: LD_ADDR_VAR 0 62
93706: PUSH
93707: LD_INT 1
93709: PUSH
93710: LD_INT 2
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 0
93719: PUSH
93720: LD_INT 2
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 1
93729: NEG
93730: PUSH
93731: LD_INT 1
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: LIST
93742: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93743: LD_ADDR_VAR 0 63
93747: PUSH
93748: LD_INT 1
93750: NEG
93751: PUSH
93752: LD_INT 1
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 2
93761: NEG
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 2
93772: NEG
93773: PUSH
93774: LD_INT 1
93776: NEG
93777: PUSH
93778: EMPTY
93779: LIST
93780: LIST
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: LIST
93786: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93787: LD_ADDR_VAR 0 64
93791: PUSH
93792: LD_INT 1
93794: NEG
93795: PUSH
93796: LD_INT 2
93798: NEG
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 2
93806: NEG
93807: PUSH
93808: LD_INT 1
93810: NEG
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: LD_INT 2
93818: NEG
93819: PUSH
93820: LD_INT 2
93822: NEG
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: PUSH
93828: EMPTY
93829: LIST
93830: LIST
93831: LIST
93832: ST_TO_ADDR
// end ; 2 :
93833: GO 97099
93835: LD_INT 2
93837: DOUBLE
93838: EQUAL
93839: IFTRUE 93843
93841: GO 97098
93843: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93844: LD_ADDR_VAR 0 29
93848: PUSH
93849: LD_INT 4
93851: PUSH
93852: LD_INT 0
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 4
93861: PUSH
93862: LD_INT 1
93864: NEG
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 5
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 5
93882: PUSH
93883: LD_INT 1
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: LD_INT 4
93892: PUSH
93893: LD_INT 1
93895: PUSH
93896: EMPTY
93897: LIST
93898: LIST
93899: PUSH
93900: LD_INT 3
93902: PUSH
93903: LD_INT 0
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 3
93912: PUSH
93913: LD_INT 1
93915: NEG
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 3
93923: PUSH
93924: LD_INT 2
93926: NEG
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 5
93934: PUSH
93935: LD_INT 2
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 3
93944: PUSH
93945: LD_INT 3
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 3
93954: PUSH
93955: LD_INT 2
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 4
93964: PUSH
93965: LD_INT 3
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 4
93974: PUSH
93975: LD_INT 4
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: PUSH
93982: LD_INT 3
93984: PUSH
93985: LD_INT 4
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 2
93994: PUSH
93995: LD_INT 3
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: LD_INT 2
94004: PUSH
94005: LD_INT 2
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 4
94014: PUSH
94015: LD_INT 2
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 2
94024: PUSH
94025: LD_INT 4
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 0
94034: PUSH
94035: LD_INT 4
94037: PUSH
94038: EMPTY
94039: LIST
94040: LIST
94041: PUSH
94042: LD_INT 0
94044: PUSH
94045: LD_INT 3
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: PUSH
94052: LD_INT 1
94054: PUSH
94055: LD_INT 4
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: LD_INT 5
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 0
94074: PUSH
94075: LD_INT 5
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: PUSH
94082: LD_INT 1
94084: NEG
94085: PUSH
94086: LD_INT 4
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 1
94095: NEG
94096: PUSH
94097: LD_INT 3
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 2
94106: PUSH
94107: LD_INT 5
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 2
94116: NEG
94117: PUSH
94118: LD_INT 3
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 3
94127: NEG
94128: PUSH
94129: LD_INT 0
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 3
94138: NEG
94139: PUSH
94140: LD_INT 1
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 2
94150: NEG
94151: PUSH
94152: LD_INT 0
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 2
94161: NEG
94162: PUSH
94163: LD_INT 1
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: PUSH
94170: LD_INT 3
94172: NEG
94173: PUSH
94174: LD_INT 1
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 4
94183: NEG
94184: PUSH
94185: LD_INT 0
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 4
94194: NEG
94195: PUSH
94196: LD_INT 1
94198: NEG
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 4
94206: NEG
94207: PUSH
94208: LD_INT 2
94210: NEG
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 2
94218: NEG
94219: PUSH
94220: LD_INT 2
94222: PUSH
94223: EMPTY
94224: LIST
94225: LIST
94226: PUSH
94227: LD_INT 4
94229: NEG
94230: PUSH
94231: LD_INT 4
94233: NEG
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 4
94241: NEG
94242: PUSH
94243: LD_INT 5
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 3
94253: NEG
94254: PUSH
94255: LD_INT 4
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 3
94265: NEG
94266: PUSH
94267: LD_INT 3
94269: NEG
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 4
94277: NEG
94278: PUSH
94279: LD_INT 3
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 5
94289: NEG
94290: PUSH
94291: LD_INT 4
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 5
94301: NEG
94302: PUSH
94303: LD_INT 5
94305: NEG
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: LD_INT 3
94313: NEG
94314: PUSH
94315: LD_INT 5
94317: NEG
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 5
94325: NEG
94326: PUSH
94327: LD_INT 3
94329: NEG
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94382: LD_ADDR_VAR 0 30
94386: PUSH
94387: LD_INT 4
94389: PUSH
94390: LD_INT 4
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: LD_INT 4
94399: PUSH
94400: LD_INT 3
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 5
94409: PUSH
94410: LD_INT 4
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 5
94419: PUSH
94420: LD_INT 5
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 4
94429: PUSH
94430: LD_INT 5
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 3
94439: PUSH
94440: LD_INT 4
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 3
94449: PUSH
94450: LD_INT 3
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 5
94459: PUSH
94460: LD_INT 3
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 3
94469: PUSH
94470: LD_INT 5
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 0
94479: PUSH
94480: LD_INT 3
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: LD_INT 2
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 1
94499: PUSH
94500: LD_INT 3
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 1
94509: PUSH
94510: LD_INT 4
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 0
94519: PUSH
94520: LD_INT 4
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: LD_INT 1
94529: NEG
94530: PUSH
94531: LD_INT 3
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 1
94540: NEG
94541: PUSH
94542: LD_INT 2
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 2
94551: PUSH
94552: LD_INT 4
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 2
94561: NEG
94562: PUSH
94563: LD_INT 2
94565: PUSH
94566: EMPTY
94567: LIST
94568: LIST
94569: PUSH
94570: LD_INT 4
94572: NEG
94573: PUSH
94574: LD_INT 0
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 4
94583: NEG
94584: PUSH
94585: LD_INT 1
94587: NEG
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 3
94595: NEG
94596: PUSH
94597: LD_INT 0
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 3
94606: NEG
94607: PUSH
94608: LD_INT 1
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 4
94617: NEG
94618: PUSH
94619: LD_INT 1
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: LD_INT 5
94628: NEG
94629: PUSH
94630: LD_INT 0
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 5
94639: NEG
94640: PUSH
94641: LD_INT 1
94643: NEG
94644: PUSH
94645: EMPTY
94646: LIST
94647: LIST
94648: PUSH
94649: LD_INT 5
94651: NEG
94652: PUSH
94653: LD_INT 2
94655: NEG
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 3
94663: NEG
94664: PUSH
94665: LD_INT 2
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 3
94674: NEG
94675: PUSH
94676: LD_INT 3
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 3
94686: NEG
94687: PUSH
94688: LD_INT 4
94690: NEG
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 2
94698: NEG
94699: PUSH
94700: LD_INT 3
94702: NEG
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 2
94710: NEG
94711: PUSH
94712: LD_INT 2
94714: NEG
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 3
94722: NEG
94723: PUSH
94724: LD_INT 2
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 4
94734: NEG
94735: PUSH
94736: LD_INT 3
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 4
94746: NEG
94747: PUSH
94748: LD_INT 4
94750: NEG
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 2
94758: NEG
94759: PUSH
94760: LD_INT 4
94762: NEG
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 4
94770: NEG
94771: PUSH
94772: LD_INT 2
94774: NEG
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 0
94782: PUSH
94783: LD_INT 4
94785: NEG
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: PUSH
94791: LD_INT 0
94793: PUSH
94794: LD_INT 5
94796: NEG
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 1
94804: PUSH
94805: LD_INT 4
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: LD_INT 3
94818: NEG
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 0
94826: PUSH
94827: LD_INT 3
94829: NEG
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 1
94837: NEG
94838: PUSH
94839: LD_INT 4
94841: NEG
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 1
94849: NEG
94850: PUSH
94851: LD_INT 5
94853: NEG
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 2
94861: PUSH
94862: LD_INT 3
94864: NEG
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 2
94872: NEG
94873: PUSH
94874: LD_INT 5
94876: NEG
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94929: LD_ADDR_VAR 0 31
94933: PUSH
94934: LD_INT 0
94936: PUSH
94937: LD_INT 4
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 0
94946: PUSH
94947: LD_INT 3
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PUSH
94954: LD_INT 1
94956: PUSH
94957: LD_INT 4
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PUSH
94964: LD_INT 1
94966: PUSH
94967: LD_INT 5
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 0
94976: PUSH
94977: LD_INT 5
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: LD_INT 1
94986: NEG
94987: PUSH
94988: LD_INT 4
94990: PUSH
94991: EMPTY
94992: LIST
94993: LIST
94994: PUSH
94995: LD_INT 1
94997: NEG
94998: PUSH
94999: LD_INT 3
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 2
95008: PUSH
95009: LD_INT 5
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 2
95018: NEG
95019: PUSH
95020: LD_INT 3
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 3
95029: NEG
95030: PUSH
95031: LD_INT 0
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 3
95040: NEG
95041: PUSH
95042: LD_INT 1
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 2
95052: NEG
95053: PUSH
95054: LD_INT 0
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 2
95063: NEG
95064: PUSH
95065: LD_INT 1
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 3
95074: NEG
95075: PUSH
95076: LD_INT 1
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 4
95085: NEG
95086: PUSH
95087: LD_INT 0
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 4
95096: NEG
95097: PUSH
95098: LD_INT 1
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 4
95108: NEG
95109: PUSH
95110: LD_INT 2
95112: NEG
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: PUSH
95118: LD_INT 2
95120: NEG
95121: PUSH
95122: LD_INT 2
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 4
95131: NEG
95132: PUSH
95133: LD_INT 4
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 4
95143: NEG
95144: PUSH
95145: LD_INT 5
95147: NEG
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 3
95155: NEG
95156: PUSH
95157: LD_INT 4
95159: NEG
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 3
95167: NEG
95168: PUSH
95169: LD_INT 3
95171: NEG
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 4
95179: NEG
95180: PUSH
95181: LD_INT 3
95183: NEG
95184: PUSH
95185: EMPTY
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 5
95191: NEG
95192: PUSH
95193: LD_INT 4
95195: NEG
95196: PUSH
95197: EMPTY
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 5
95203: NEG
95204: PUSH
95205: LD_INT 5
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 3
95215: NEG
95216: PUSH
95217: LD_INT 5
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 5
95227: NEG
95228: PUSH
95229: LD_INT 3
95231: NEG
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 0
95239: PUSH
95240: LD_INT 3
95242: NEG
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 0
95250: PUSH
95251: LD_INT 4
95253: NEG
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 1
95261: PUSH
95262: LD_INT 3
95264: NEG
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PUSH
95270: LD_INT 1
95272: PUSH
95273: LD_INT 2
95275: NEG
95276: PUSH
95277: EMPTY
95278: LIST
95279: LIST
95280: PUSH
95281: LD_INT 0
95283: PUSH
95284: LD_INT 2
95286: NEG
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: LD_INT 1
95294: NEG
95295: PUSH
95296: LD_INT 3
95298: NEG
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 1
95306: NEG
95307: PUSH
95308: LD_INT 4
95310: NEG
95311: PUSH
95312: EMPTY
95313: LIST
95314: LIST
95315: PUSH
95316: LD_INT 2
95318: PUSH
95319: LD_INT 2
95321: NEG
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 2
95329: NEG
95330: PUSH
95331: LD_INT 4
95333: NEG
95334: PUSH
95335: EMPTY
95336: LIST
95337: LIST
95338: PUSH
95339: LD_INT 4
95341: PUSH
95342: LD_INT 0
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 4
95351: PUSH
95352: LD_INT 1
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 5
95362: PUSH
95363: LD_INT 0
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 5
95372: PUSH
95373: LD_INT 1
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 4
95382: PUSH
95383: LD_INT 1
95385: PUSH
95386: EMPTY
95387: LIST
95388: LIST
95389: PUSH
95390: LD_INT 3
95392: PUSH
95393: LD_INT 0
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 3
95402: PUSH
95403: LD_INT 1
95405: NEG
95406: PUSH
95407: EMPTY
95408: LIST
95409: LIST
95410: PUSH
95411: LD_INT 3
95413: PUSH
95414: LD_INT 2
95416: NEG
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 5
95424: PUSH
95425: LD_INT 2
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: EMPTY
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95479: LD_ADDR_VAR 0 32
95483: PUSH
95484: LD_INT 4
95486: NEG
95487: PUSH
95488: LD_INT 0
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 4
95497: NEG
95498: PUSH
95499: LD_INT 1
95501: NEG
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 3
95509: NEG
95510: PUSH
95511: LD_INT 0
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 3
95520: NEG
95521: PUSH
95522: LD_INT 1
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: PUSH
95529: LD_INT 4
95531: NEG
95532: PUSH
95533: LD_INT 1
95535: PUSH
95536: EMPTY
95537: LIST
95538: LIST
95539: PUSH
95540: LD_INT 5
95542: NEG
95543: PUSH
95544: LD_INT 0
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PUSH
95551: LD_INT 5
95553: NEG
95554: PUSH
95555: LD_INT 1
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 5
95565: NEG
95566: PUSH
95567: LD_INT 2
95569: NEG
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PUSH
95575: LD_INT 3
95577: NEG
95578: PUSH
95579: LD_INT 2
95581: PUSH
95582: EMPTY
95583: LIST
95584: LIST
95585: PUSH
95586: LD_INT 3
95588: NEG
95589: PUSH
95590: LD_INT 3
95592: NEG
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 3
95600: NEG
95601: PUSH
95602: LD_INT 4
95604: NEG
95605: PUSH
95606: EMPTY
95607: LIST
95608: LIST
95609: PUSH
95610: LD_INT 2
95612: NEG
95613: PUSH
95614: LD_INT 3
95616: NEG
95617: PUSH
95618: EMPTY
95619: LIST
95620: LIST
95621: PUSH
95622: LD_INT 2
95624: NEG
95625: PUSH
95626: LD_INT 2
95628: NEG
95629: PUSH
95630: EMPTY
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 3
95636: NEG
95637: PUSH
95638: LD_INT 2
95640: NEG
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: PUSH
95646: LD_INT 4
95648: NEG
95649: PUSH
95650: LD_INT 3
95652: NEG
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 4
95660: NEG
95661: PUSH
95662: LD_INT 4
95664: NEG
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: PUSH
95670: LD_INT 2
95672: NEG
95673: PUSH
95674: LD_INT 4
95676: NEG
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 4
95684: NEG
95685: PUSH
95686: LD_INT 2
95688: NEG
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 0
95696: PUSH
95697: LD_INT 4
95699: NEG
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 0
95707: PUSH
95708: LD_INT 5
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 1
95718: PUSH
95719: LD_INT 4
95721: NEG
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 1
95729: PUSH
95730: LD_INT 3
95732: NEG
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: PUSH
95738: LD_INT 0
95740: PUSH
95741: LD_INT 3
95743: NEG
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 1
95751: NEG
95752: PUSH
95753: LD_INT 4
95755: NEG
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 1
95763: NEG
95764: PUSH
95765: LD_INT 5
95767: NEG
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 2
95775: PUSH
95776: LD_INT 3
95778: NEG
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 2
95786: NEG
95787: PUSH
95788: LD_INT 5
95790: NEG
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 3
95798: PUSH
95799: LD_INT 0
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 3
95808: PUSH
95809: LD_INT 1
95811: NEG
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: PUSH
95817: LD_INT 4
95819: PUSH
95820: LD_INT 0
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: PUSH
95827: LD_INT 4
95829: PUSH
95830: LD_INT 1
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 3
95839: PUSH
95840: LD_INT 1
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 2
95849: PUSH
95850: LD_INT 0
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 2
95859: PUSH
95860: LD_INT 1
95862: NEG
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: PUSH
95868: LD_INT 2
95870: PUSH
95871: LD_INT 2
95873: NEG
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 4
95881: PUSH
95882: LD_INT 2
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: PUSH
95889: LD_INT 4
95891: PUSH
95892: LD_INT 4
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 4
95901: PUSH
95902: LD_INT 3
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 5
95911: PUSH
95912: LD_INT 4
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 5
95921: PUSH
95922: LD_INT 5
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 4
95931: PUSH
95932: LD_INT 5
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 3
95941: PUSH
95942: LD_INT 4
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 3
95951: PUSH
95952: LD_INT 3
95954: PUSH
95955: EMPTY
95956: LIST
95957: LIST
95958: PUSH
95959: LD_INT 5
95961: PUSH
95962: LD_INT 3
95964: PUSH
95965: EMPTY
95966: LIST
95967: LIST
95968: PUSH
95969: LD_INT 3
95971: PUSH
95972: LD_INT 5
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: LIST
96003: LIST
96004: LIST
96005: LIST
96006: LIST
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: LIST
96020: LIST
96021: LIST
96022: LIST
96023: LIST
96024: LIST
96025: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96026: LD_ADDR_VAR 0 33
96030: PUSH
96031: LD_INT 4
96033: NEG
96034: PUSH
96035: LD_INT 4
96037: NEG
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: PUSH
96043: LD_INT 4
96045: NEG
96046: PUSH
96047: LD_INT 5
96049: NEG
96050: PUSH
96051: EMPTY
96052: LIST
96053: LIST
96054: PUSH
96055: LD_INT 3
96057: NEG
96058: PUSH
96059: LD_INT 4
96061: NEG
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: PUSH
96067: LD_INT 3
96069: NEG
96070: PUSH
96071: LD_INT 3
96073: NEG
96074: PUSH
96075: EMPTY
96076: LIST
96077: LIST
96078: PUSH
96079: LD_INT 4
96081: NEG
96082: PUSH
96083: LD_INT 3
96085: NEG
96086: PUSH
96087: EMPTY
96088: LIST
96089: LIST
96090: PUSH
96091: LD_INT 5
96093: NEG
96094: PUSH
96095: LD_INT 4
96097: NEG
96098: PUSH
96099: EMPTY
96100: LIST
96101: LIST
96102: PUSH
96103: LD_INT 5
96105: NEG
96106: PUSH
96107: LD_INT 5
96109: NEG
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 3
96117: NEG
96118: PUSH
96119: LD_INT 5
96121: NEG
96122: PUSH
96123: EMPTY
96124: LIST
96125: LIST
96126: PUSH
96127: LD_INT 5
96129: NEG
96130: PUSH
96131: LD_INT 3
96133: NEG
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 0
96141: PUSH
96142: LD_INT 3
96144: NEG
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 0
96152: PUSH
96153: LD_INT 4
96155: NEG
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 1
96163: PUSH
96164: LD_INT 3
96166: NEG
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: LD_INT 1
96174: PUSH
96175: LD_INT 2
96177: NEG
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: PUSH
96183: LD_INT 0
96185: PUSH
96186: LD_INT 2
96188: NEG
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: PUSH
96194: LD_INT 1
96196: NEG
96197: PUSH
96198: LD_INT 3
96200: NEG
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 1
96208: NEG
96209: PUSH
96210: LD_INT 4
96212: NEG
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 2
96220: PUSH
96221: LD_INT 2
96223: NEG
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_INT 2
96231: NEG
96232: PUSH
96233: LD_INT 4
96235: NEG
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 4
96243: PUSH
96244: LD_INT 0
96246: PUSH
96247: EMPTY
96248: LIST
96249: LIST
96250: PUSH
96251: LD_INT 4
96253: PUSH
96254: LD_INT 1
96256: NEG
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PUSH
96262: LD_INT 5
96264: PUSH
96265: LD_INT 0
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 5
96274: PUSH
96275: LD_INT 1
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 4
96284: PUSH
96285: LD_INT 1
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: LD_INT 3
96294: PUSH
96295: LD_INT 0
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: LD_INT 3
96304: PUSH
96305: LD_INT 1
96307: NEG
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: LD_INT 3
96315: PUSH
96316: LD_INT 2
96318: NEG
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 5
96326: PUSH
96327: LD_INT 2
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: LD_INT 3
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: PUSH
96347: LD_INT 2
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 4
96356: PUSH
96357: LD_INT 3
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 4
96366: PUSH
96367: LD_INT 4
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: LD_INT 4
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 2
96386: PUSH
96387: LD_INT 3
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 2
96396: PUSH
96397: LD_INT 2
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 4
96406: PUSH
96407: LD_INT 2
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 2
96416: PUSH
96417: LD_INT 4
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 0
96426: PUSH
96427: LD_INT 4
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 0
96436: PUSH
96437: LD_INT 3
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 1
96446: PUSH
96447: LD_INT 4
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: PUSH
96454: LD_INT 1
96456: PUSH
96457: LD_INT 5
96459: PUSH
96460: EMPTY
96461: LIST
96462: LIST
96463: PUSH
96464: LD_INT 0
96466: PUSH
96467: LD_INT 5
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: PUSH
96474: LD_INT 1
96476: NEG
96477: PUSH
96478: LD_INT 4
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PUSH
96485: LD_INT 1
96487: NEG
96488: PUSH
96489: LD_INT 3
96491: PUSH
96492: EMPTY
96493: LIST
96494: LIST
96495: PUSH
96496: LD_INT 2
96498: PUSH
96499: LD_INT 5
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 2
96508: NEG
96509: PUSH
96510: LD_INT 3
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96564: LD_ADDR_VAR 0 34
96568: PUSH
96569: LD_INT 0
96571: PUSH
96572: LD_INT 4
96574: NEG
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: LD_INT 0
96582: PUSH
96583: LD_INT 5
96585: NEG
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 1
96593: PUSH
96594: LD_INT 4
96596: NEG
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: LD_INT 1
96604: PUSH
96605: LD_INT 3
96607: NEG
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: LD_INT 0
96615: PUSH
96616: LD_INT 3
96618: NEG
96619: PUSH
96620: EMPTY
96621: LIST
96622: LIST
96623: PUSH
96624: LD_INT 1
96626: NEG
96627: PUSH
96628: LD_INT 4
96630: NEG
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 1
96638: NEG
96639: PUSH
96640: LD_INT 5
96642: NEG
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 2
96650: PUSH
96651: LD_INT 3
96653: NEG
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: PUSH
96659: LD_INT 2
96661: NEG
96662: PUSH
96663: LD_INT 5
96665: NEG
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: LD_INT 3
96673: PUSH
96674: LD_INT 0
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: PUSH
96681: LD_INT 3
96683: PUSH
96684: LD_INT 1
96686: NEG
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 4
96694: PUSH
96695: LD_INT 0
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 4
96704: PUSH
96705: LD_INT 1
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: LD_INT 3
96714: PUSH
96715: LD_INT 1
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: PUSH
96722: LD_INT 2
96724: PUSH
96725: LD_INT 0
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: PUSH
96732: LD_INT 2
96734: PUSH
96735: LD_INT 1
96737: NEG
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: PUSH
96743: LD_INT 2
96745: PUSH
96746: LD_INT 2
96748: NEG
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: PUSH
96754: LD_INT 4
96756: PUSH
96757: LD_INT 2
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 4
96766: PUSH
96767: LD_INT 4
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 4
96776: PUSH
96777: LD_INT 3
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 5
96786: PUSH
96787: LD_INT 4
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: PUSH
96794: LD_INT 5
96796: PUSH
96797: LD_INT 5
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: PUSH
96804: LD_INT 4
96806: PUSH
96807: LD_INT 5
96809: PUSH
96810: EMPTY
96811: LIST
96812: LIST
96813: PUSH
96814: LD_INT 3
96816: PUSH
96817: LD_INT 4
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 3
96826: PUSH
96827: LD_INT 3
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: PUSH
96834: LD_INT 5
96836: PUSH
96837: LD_INT 3
96839: PUSH
96840: EMPTY
96841: LIST
96842: LIST
96843: PUSH
96844: LD_INT 3
96846: PUSH
96847: LD_INT 5
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 0
96856: PUSH
96857: LD_INT 3
96859: PUSH
96860: EMPTY
96861: LIST
96862: LIST
96863: PUSH
96864: LD_INT 0
96866: PUSH
96867: LD_INT 2
96869: PUSH
96870: EMPTY
96871: LIST
96872: LIST
96873: PUSH
96874: LD_INT 1
96876: PUSH
96877: LD_INT 3
96879: PUSH
96880: EMPTY
96881: LIST
96882: LIST
96883: PUSH
96884: LD_INT 1
96886: PUSH
96887: LD_INT 4
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PUSH
96894: LD_INT 0
96896: PUSH
96897: LD_INT 4
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: PUSH
96904: LD_INT 1
96906: NEG
96907: PUSH
96908: LD_INT 3
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 1
96917: NEG
96918: PUSH
96919: LD_INT 2
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 2
96928: PUSH
96929: LD_INT 4
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 2
96938: NEG
96939: PUSH
96940: LD_INT 2
96942: PUSH
96943: EMPTY
96944: LIST
96945: LIST
96946: PUSH
96947: LD_INT 4
96949: NEG
96950: PUSH
96951: LD_INT 0
96953: PUSH
96954: EMPTY
96955: LIST
96956: LIST
96957: PUSH
96958: LD_INT 4
96960: NEG
96961: PUSH
96962: LD_INT 1
96964: NEG
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_INT 3
96972: NEG
96973: PUSH
96974: LD_INT 0
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 3
96983: NEG
96984: PUSH
96985: LD_INT 1
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 4
96994: NEG
96995: PUSH
96996: LD_INT 1
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 5
97005: NEG
97006: PUSH
97007: LD_INT 0
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 5
97016: NEG
97017: PUSH
97018: LD_INT 1
97020: NEG
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 5
97028: NEG
97029: PUSH
97030: LD_INT 2
97032: NEG
97033: PUSH
97034: EMPTY
97035: LIST
97036: LIST
97037: PUSH
97038: LD_INT 3
97040: NEG
97041: PUSH
97042: LD_INT 2
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: ST_TO_ADDR
// end ; end ;
97096: GO 97099
97098: POP
// case btype of b_depot , b_warehouse :
97099: LD_VAR 0 1
97103: PUSH
97104: LD_INT 0
97106: DOUBLE
97107: EQUAL
97108: IFTRUE 97118
97110: LD_INT 1
97112: DOUBLE
97113: EQUAL
97114: IFTRUE 97118
97116: GO 97319
97118: POP
// case nation of nation_american :
97119: LD_VAR 0 5
97123: PUSH
97124: LD_INT 1
97126: DOUBLE
97127: EQUAL
97128: IFTRUE 97132
97130: GO 97188
97132: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97133: LD_ADDR_VAR 0 9
97137: PUSH
97138: LD_VAR 0 11
97142: PUSH
97143: LD_VAR 0 12
97147: PUSH
97148: LD_VAR 0 13
97152: PUSH
97153: LD_VAR 0 14
97157: PUSH
97158: LD_VAR 0 15
97162: PUSH
97163: LD_VAR 0 16
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: PUSH
97176: LD_VAR 0 4
97180: PUSH
97181: LD_INT 1
97183: PLUS
97184: ARRAY
97185: ST_TO_ADDR
97186: GO 97317
97188: LD_INT 2
97190: DOUBLE
97191: EQUAL
97192: IFTRUE 97196
97194: GO 97252
97196: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97197: LD_ADDR_VAR 0 9
97201: PUSH
97202: LD_VAR 0 17
97206: PUSH
97207: LD_VAR 0 18
97211: PUSH
97212: LD_VAR 0 19
97216: PUSH
97217: LD_VAR 0 20
97221: PUSH
97222: LD_VAR 0 21
97226: PUSH
97227: LD_VAR 0 22
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: PUSH
97240: LD_VAR 0 4
97244: PUSH
97245: LD_INT 1
97247: PLUS
97248: ARRAY
97249: ST_TO_ADDR
97250: GO 97317
97252: LD_INT 3
97254: DOUBLE
97255: EQUAL
97256: IFTRUE 97260
97258: GO 97316
97260: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97261: LD_ADDR_VAR 0 9
97265: PUSH
97266: LD_VAR 0 23
97270: PUSH
97271: LD_VAR 0 24
97275: PUSH
97276: LD_VAR 0 25
97280: PUSH
97281: LD_VAR 0 26
97285: PUSH
97286: LD_VAR 0 27
97290: PUSH
97291: LD_VAR 0 28
97295: PUSH
97296: EMPTY
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: PUSH
97304: LD_VAR 0 4
97308: PUSH
97309: LD_INT 1
97311: PLUS
97312: ARRAY
97313: ST_TO_ADDR
97314: GO 97317
97316: POP
97317: GO 97872
97319: LD_INT 2
97321: DOUBLE
97322: EQUAL
97323: IFTRUE 97333
97325: LD_INT 3
97327: DOUBLE
97328: EQUAL
97329: IFTRUE 97333
97331: GO 97389
97333: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97334: LD_ADDR_VAR 0 9
97338: PUSH
97339: LD_VAR 0 29
97343: PUSH
97344: LD_VAR 0 30
97348: PUSH
97349: LD_VAR 0 31
97353: PUSH
97354: LD_VAR 0 32
97358: PUSH
97359: LD_VAR 0 33
97363: PUSH
97364: LD_VAR 0 34
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: PUSH
97377: LD_VAR 0 4
97381: PUSH
97382: LD_INT 1
97384: PLUS
97385: ARRAY
97386: ST_TO_ADDR
97387: GO 97872
97389: LD_INT 16
97391: DOUBLE
97392: EQUAL
97393: IFTRUE 97451
97395: LD_INT 17
97397: DOUBLE
97398: EQUAL
97399: IFTRUE 97451
97401: LD_INT 18
97403: DOUBLE
97404: EQUAL
97405: IFTRUE 97451
97407: LD_INT 19
97409: DOUBLE
97410: EQUAL
97411: IFTRUE 97451
97413: LD_INT 22
97415: DOUBLE
97416: EQUAL
97417: IFTRUE 97451
97419: LD_INT 20
97421: DOUBLE
97422: EQUAL
97423: IFTRUE 97451
97425: LD_INT 21
97427: DOUBLE
97428: EQUAL
97429: IFTRUE 97451
97431: LD_INT 23
97433: DOUBLE
97434: EQUAL
97435: IFTRUE 97451
97437: LD_INT 24
97439: DOUBLE
97440: EQUAL
97441: IFTRUE 97451
97443: LD_INT 25
97445: DOUBLE
97446: EQUAL
97447: IFTRUE 97451
97449: GO 97507
97451: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97452: LD_ADDR_VAR 0 9
97456: PUSH
97457: LD_VAR 0 35
97461: PUSH
97462: LD_VAR 0 36
97466: PUSH
97467: LD_VAR 0 37
97471: PUSH
97472: LD_VAR 0 38
97476: PUSH
97477: LD_VAR 0 39
97481: PUSH
97482: LD_VAR 0 40
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: PUSH
97495: LD_VAR 0 4
97499: PUSH
97500: LD_INT 1
97502: PLUS
97503: ARRAY
97504: ST_TO_ADDR
97505: GO 97872
97507: LD_INT 6
97509: DOUBLE
97510: EQUAL
97511: IFTRUE 97563
97513: LD_INT 7
97515: DOUBLE
97516: EQUAL
97517: IFTRUE 97563
97519: LD_INT 8
97521: DOUBLE
97522: EQUAL
97523: IFTRUE 97563
97525: LD_INT 13
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97563
97531: LD_INT 12
97533: DOUBLE
97534: EQUAL
97535: IFTRUE 97563
97537: LD_INT 15
97539: DOUBLE
97540: EQUAL
97541: IFTRUE 97563
97543: LD_INT 11
97545: DOUBLE
97546: EQUAL
97547: IFTRUE 97563
97549: LD_INT 14
97551: DOUBLE
97552: EQUAL
97553: IFTRUE 97563
97555: LD_INT 10
97557: DOUBLE
97558: EQUAL
97559: IFTRUE 97563
97561: GO 97619
97563: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97564: LD_ADDR_VAR 0 9
97568: PUSH
97569: LD_VAR 0 41
97573: PUSH
97574: LD_VAR 0 42
97578: PUSH
97579: LD_VAR 0 43
97583: PUSH
97584: LD_VAR 0 44
97588: PUSH
97589: LD_VAR 0 45
97593: PUSH
97594: LD_VAR 0 46
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: PUSH
97607: LD_VAR 0 4
97611: PUSH
97612: LD_INT 1
97614: PLUS
97615: ARRAY
97616: ST_TO_ADDR
97617: GO 97872
97619: LD_INT 36
97621: DOUBLE
97622: EQUAL
97623: IFTRUE 97627
97625: GO 97683
97627: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97628: LD_ADDR_VAR 0 9
97632: PUSH
97633: LD_VAR 0 47
97637: PUSH
97638: LD_VAR 0 48
97642: PUSH
97643: LD_VAR 0 49
97647: PUSH
97648: LD_VAR 0 50
97652: PUSH
97653: LD_VAR 0 51
97657: PUSH
97658: LD_VAR 0 52
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: PUSH
97671: LD_VAR 0 4
97675: PUSH
97676: LD_INT 1
97678: PLUS
97679: ARRAY
97680: ST_TO_ADDR
97681: GO 97872
97683: LD_INT 4
97685: DOUBLE
97686: EQUAL
97687: IFTRUE 97709
97689: LD_INT 5
97691: DOUBLE
97692: EQUAL
97693: IFTRUE 97709
97695: LD_INT 34
97697: DOUBLE
97698: EQUAL
97699: IFTRUE 97709
97701: LD_INT 37
97703: DOUBLE
97704: EQUAL
97705: IFTRUE 97709
97707: GO 97765
97709: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97710: LD_ADDR_VAR 0 9
97714: PUSH
97715: LD_VAR 0 53
97719: PUSH
97720: LD_VAR 0 54
97724: PUSH
97725: LD_VAR 0 55
97729: PUSH
97730: LD_VAR 0 56
97734: PUSH
97735: LD_VAR 0 57
97739: PUSH
97740: LD_VAR 0 58
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: PUSH
97753: LD_VAR 0 4
97757: PUSH
97758: LD_INT 1
97760: PLUS
97761: ARRAY
97762: ST_TO_ADDR
97763: GO 97872
97765: LD_INT 31
97767: DOUBLE
97768: EQUAL
97769: IFTRUE 97815
97771: LD_INT 32
97773: DOUBLE
97774: EQUAL
97775: IFTRUE 97815
97777: LD_INT 33
97779: DOUBLE
97780: EQUAL
97781: IFTRUE 97815
97783: LD_INT 27
97785: DOUBLE
97786: EQUAL
97787: IFTRUE 97815
97789: LD_INT 26
97791: DOUBLE
97792: EQUAL
97793: IFTRUE 97815
97795: LD_INT 28
97797: DOUBLE
97798: EQUAL
97799: IFTRUE 97815
97801: LD_INT 29
97803: DOUBLE
97804: EQUAL
97805: IFTRUE 97815
97807: LD_INT 30
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97815
97813: GO 97871
97815: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
97816: LD_ADDR_VAR 0 9
97820: PUSH
97821: LD_VAR 0 59
97825: PUSH
97826: LD_VAR 0 60
97830: PUSH
97831: LD_VAR 0 61
97835: PUSH
97836: LD_VAR 0 62
97840: PUSH
97841: LD_VAR 0 63
97845: PUSH
97846: LD_VAR 0 64
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: PUSH
97859: LD_VAR 0 4
97863: PUSH
97864: LD_INT 1
97866: PLUS
97867: ARRAY
97868: ST_TO_ADDR
97869: GO 97872
97871: POP
// temp_list2 = [ ] ;
97872: LD_ADDR_VAR 0 10
97876: PUSH
97877: EMPTY
97878: ST_TO_ADDR
// for i in temp_list do
97879: LD_ADDR_VAR 0 8
97883: PUSH
97884: LD_VAR 0 9
97888: PUSH
97889: FOR_IN
97890: IFFALSE 97942
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97892: LD_ADDR_VAR 0 10
97896: PUSH
97897: LD_VAR 0 10
97901: PUSH
97902: LD_VAR 0 8
97906: PUSH
97907: LD_INT 1
97909: ARRAY
97910: PUSH
97911: LD_VAR 0 2
97915: PLUS
97916: PUSH
97917: LD_VAR 0 8
97921: PUSH
97922: LD_INT 2
97924: ARRAY
97925: PUSH
97926: LD_VAR 0 3
97930: PLUS
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PUSH
97936: EMPTY
97937: LIST
97938: ADD
97939: ST_TO_ADDR
97940: GO 97889
97942: POP
97943: POP
// result = temp_list2 ;
97944: LD_ADDR_VAR 0 7
97948: PUSH
97949: LD_VAR 0 10
97953: ST_TO_ADDR
// end ;
97954: LD_VAR 0 7
97958: RET
// export function EnemyInRange ( unit , dist ) ; begin
97959: LD_INT 0
97961: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97962: LD_ADDR_VAR 0 3
97966: PUSH
97967: LD_VAR 0 1
97971: PPUSH
97972: CALL_OW 255
97976: PPUSH
97977: LD_VAR 0 1
97981: PPUSH
97982: CALL_OW 250
97986: PPUSH
97987: LD_VAR 0 1
97991: PPUSH
97992: CALL_OW 251
97996: PPUSH
97997: LD_VAR 0 2
98001: PPUSH
98002: CALL 71354 0 4
98006: PUSH
98007: LD_INT 4
98009: ARRAY
98010: ST_TO_ADDR
// end ;
98011: LD_VAR 0 3
98015: RET
// export function PlayerSeeMe ( unit ) ; begin
98016: LD_INT 0
98018: PPUSH
// result := See ( your_side , unit ) ;
98019: LD_ADDR_VAR 0 2
98023: PUSH
98024: LD_OWVAR 2
98028: PPUSH
98029: LD_VAR 0 1
98033: PPUSH
98034: CALL_OW 292
98038: ST_TO_ADDR
// end ;
98039: LD_VAR 0 2
98043: RET
// export function ReverseDir ( unit ) ; begin
98044: LD_INT 0
98046: PPUSH
// if not unit then
98047: LD_VAR 0 1
98051: NOT
98052: IFFALSE 98056
// exit ;
98054: GO 98079
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98056: LD_ADDR_VAR 0 2
98060: PUSH
98061: LD_VAR 0 1
98065: PPUSH
98066: CALL_OW 254
98070: PUSH
98071: LD_INT 3
98073: PLUS
98074: PUSH
98075: LD_INT 6
98077: MOD
98078: ST_TO_ADDR
// end ;
98079: LD_VAR 0 2
98083: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98084: LD_INT 0
98086: PPUSH
98087: PPUSH
98088: PPUSH
98089: PPUSH
98090: PPUSH
// if not hexes then
98091: LD_VAR 0 2
98095: NOT
98096: IFFALSE 98100
// exit ;
98098: GO 98248
// dist := 9999 ;
98100: LD_ADDR_VAR 0 5
98104: PUSH
98105: LD_INT 9999
98107: ST_TO_ADDR
// for i = 1 to hexes do
98108: LD_ADDR_VAR 0 4
98112: PUSH
98113: DOUBLE
98114: LD_INT 1
98116: DEC
98117: ST_TO_ADDR
98118: LD_VAR 0 2
98122: PUSH
98123: FOR_TO
98124: IFFALSE 98236
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98126: LD_VAR 0 1
98130: PPUSH
98131: LD_VAR 0 2
98135: PUSH
98136: LD_VAR 0 4
98140: ARRAY
98141: PUSH
98142: LD_INT 1
98144: ARRAY
98145: PPUSH
98146: LD_VAR 0 2
98150: PUSH
98151: LD_VAR 0 4
98155: ARRAY
98156: PUSH
98157: LD_INT 2
98159: ARRAY
98160: PPUSH
98161: CALL_OW 297
98165: PUSH
98166: LD_VAR 0 5
98170: LESS
98171: IFFALSE 98234
// begin hex := hexes [ i ] ;
98173: LD_ADDR_VAR 0 7
98177: PUSH
98178: LD_VAR 0 2
98182: PUSH
98183: LD_VAR 0 4
98187: ARRAY
98188: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98189: LD_ADDR_VAR 0 5
98193: PUSH
98194: LD_VAR 0 1
98198: PPUSH
98199: LD_VAR 0 2
98203: PUSH
98204: LD_VAR 0 4
98208: ARRAY
98209: PUSH
98210: LD_INT 1
98212: ARRAY
98213: PPUSH
98214: LD_VAR 0 2
98218: PUSH
98219: LD_VAR 0 4
98223: ARRAY
98224: PUSH
98225: LD_INT 2
98227: ARRAY
98228: PPUSH
98229: CALL_OW 297
98233: ST_TO_ADDR
// end ; end ;
98234: GO 98123
98236: POP
98237: POP
// result := hex ;
98238: LD_ADDR_VAR 0 3
98242: PUSH
98243: LD_VAR 0 7
98247: ST_TO_ADDR
// end ;
98248: LD_VAR 0 3
98252: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98253: LD_INT 0
98255: PPUSH
98256: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98257: LD_VAR 0 1
98261: NOT
98262: PUSH
98263: LD_VAR 0 1
98267: PUSH
98268: LD_INT 21
98270: PUSH
98271: LD_INT 2
98273: PUSH
98274: EMPTY
98275: LIST
98276: LIST
98277: PUSH
98278: LD_INT 23
98280: PUSH
98281: LD_INT 2
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: PUSH
98288: EMPTY
98289: LIST
98290: LIST
98291: PPUSH
98292: CALL_OW 69
98296: IN
98297: NOT
98298: OR
98299: IFFALSE 98303
// exit ;
98301: GO 98350
// for i = 1 to 3 do
98303: LD_ADDR_VAR 0 3
98307: PUSH
98308: DOUBLE
98309: LD_INT 1
98311: DEC
98312: ST_TO_ADDR
98313: LD_INT 3
98315: PUSH
98316: FOR_TO
98317: IFFALSE 98348
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98319: LD_VAR 0 1
98323: PPUSH
98324: CALL_OW 250
98328: PPUSH
98329: LD_VAR 0 1
98333: PPUSH
98334: CALL_OW 251
98338: PPUSH
98339: LD_INT 1
98341: PPUSH
98342: CALL_OW 453
98346: GO 98316
98348: POP
98349: POP
// end ;
98350: LD_VAR 0 2
98354: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98355: LD_INT 0
98357: PPUSH
98358: PPUSH
98359: PPUSH
98360: PPUSH
98361: PPUSH
98362: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98363: LD_VAR 0 1
98367: NOT
98368: PUSH
98369: LD_VAR 0 2
98373: NOT
98374: OR
98375: PUSH
98376: LD_VAR 0 1
98380: PPUSH
98381: CALL_OW 314
98385: OR
98386: IFFALSE 98390
// exit ;
98388: GO 98831
// x := GetX ( enemy_unit ) ;
98390: LD_ADDR_VAR 0 7
98394: PUSH
98395: LD_VAR 0 2
98399: PPUSH
98400: CALL_OW 250
98404: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98405: LD_ADDR_VAR 0 8
98409: PUSH
98410: LD_VAR 0 2
98414: PPUSH
98415: CALL_OW 251
98419: ST_TO_ADDR
// if not x or not y then
98420: LD_VAR 0 7
98424: NOT
98425: PUSH
98426: LD_VAR 0 8
98430: NOT
98431: OR
98432: IFFALSE 98436
// exit ;
98434: GO 98831
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98436: LD_ADDR_VAR 0 6
98440: PUSH
98441: LD_VAR 0 7
98445: PPUSH
98446: LD_INT 0
98448: PPUSH
98449: LD_INT 4
98451: PPUSH
98452: CALL_OW 272
98456: PUSH
98457: LD_VAR 0 8
98461: PPUSH
98462: LD_INT 0
98464: PPUSH
98465: LD_INT 4
98467: PPUSH
98468: CALL_OW 273
98472: PUSH
98473: EMPTY
98474: LIST
98475: LIST
98476: PUSH
98477: LD_VAR 0 7
98481: PPUSH
98482: LD_INT 1
98484: PPUSH
98485: LD_INT 4
98487: PPUSH
98488: CALL_OW 272
98492: PUSH
98493: LD_VAR 0 8
98497: PPUSH
98498: LD_INT 1
98500: PPUSH
98501: LD_INT 4
98503: PPUSH
98504: CALL_OW 273
98508: PUSH
98509: EMPTY
98510: LIST
98511: LIST
98512: PUSH
98513: LD_VAR 0 7
98517: PPUSH
98518: LD_INT 2
98520: PPUSH
98521: LD_INT 4
98523: PPUSH
98524: CALL_OW 272
98528: PUSH
98529: LD_VAR 0 8
98533: PPUSH
98534: LD_INT 2
98536: PPUSH
98537: LD_INT 4
98539: PPUSH
98540: CALL_OW 273
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: PUSH
98549: LD_VAR 0 7
98553: PPUSH
98554: LD_INT 3
98556: PPUSH
98557: LD_INT 4
98559: PPUSH
98560: CALL_OW 272
98564: PUSH
98565: LD_VAR 0 8
98569: PPUSH
98570: LD_INT 3
98572: PPUSH
98573: LD_INT 4
98575: PPUSH
98576: CALL_OW 273
98580: PUSH
98581: EMPTY
98582: LIST
98583: LIST
98584: PUSH
98585: LD_VAR 0 7
98589: PPUSH
98590: LD_INT 4
98592: PPUSH
98593: LD_INT 4
98595: PPUSH
98596: CALL_OW 272
98600: PUSH
98601: LD_VAR 0 8
98605: PPUSH
98606: LD_INT 4
98608: PPUSH
98609: LD_INT 4
98611: PPUSH
98612: CALL_OW 273
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_VAR 0 7
98625: PPUSH
98626: LD_INT 5
98628: PPUSH
98629: LD_INT 4
98631: PPUSH
98632: CALL_OW 272
98636: PUSH
98637: LD_VAR 0 8
98641: PPUSH
98642: LD_INT 5
98644: PPUSH
98645: LD_INT 4
98647: PPUSH
98648: CALL_OW 273
98652: PUSH
98653: EMPTY
98654: LIST
98655: LIST
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: ST_TO_ADDR
// for i = tmp downto 1 do
98665: LD_ADDR_VAR 0 4
98669: PUSH
98670: DOUBLE
98671: LD_VAR 0 6
98675: INC
98676: ST_TO_ADDR
98677: LD_INT 1
98679: PUSH
98680: FOR_DOWNTO
98681: IFFALSE 98782
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98683: LD_VAR 0 6
98687: PUSH
98688: LD_VAR 0 4
98692: ARRAY
98693: PUSH
98694: LD_INT 1
98696: ARRAY
98697: PPUSH
98698: LD_VAR 0 6
98702: PUSH
98703: LD_VAR 0 4
98707: ARRAY
98708: PUSH
98709: LD_INT 2
98711: ARRAY
98712: PPUSH
98713: CALL_OW 488
98717: NOT
98718: PUSH
98719: LD_VAR 0 6
98723: PUSH
98724: LD_VAR 0 4
98728: ARRAY
98729: PUSH
98730: LD_INT 1
98732: ARRAY
98733: PPUSH
98734: LD_VAR 0 6
98738: PUSH
98739: LD_VAR 0 4
98743: ARRAY
98744: PUSH
98745: LD_INT 2
98747: ARRAY
98748: PPUSH
98749: CALL_OW 428
98753: PUSH
98754: LD_INT 0
98756: NONEQUAL
98757: OR
98758: IFFALSE 98780
// tmp := Delete ( tmp , i ) ;
98760: LD_ADDR_VAR 0 6
98764: PUSH
98765: LD_VAR 0 6
98769: PPUSH
98770: LD_VAR 0 4
98774: PPUSH
98775: CALL_OW 3
98779: ST_TO_ADDR
98780: GO 98680
98782: POP
98783: POP
// j := GetClosestHex ( unit , tmp ) ;
98784: LD_ADDR_VAR 0 5
98788: PUSH
98789: LD_VAR 0 1
98793: PPUSH
98794: LD_VAR 0 6
98798: PPUSH
98799: CALL 98084 0 2
98803: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98804: LD_VAR 0 1
98808: PPUSH
98809: LD_VAR 0 5
98813: PUSH
98814: LD_INT 1
98816: ARRAY
98817: PPUSH
98818: LD_VAR 0 5
98822: PUSH
98823: LD_INT 2
98825: ARRAY
98826: PPUSH
98827: CALL_OW 111
// end ;
98831: LD_VAR 0 3
98835: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98836: LD_INT 0
98838: PPUSH
98839: PPUSH
98840: PPUSH
// uc_side = 0 ;
98841: LD_ADDR_OWVAR 20
98845: PUSH
98846: LD_INT 0
98848: ST_TO_ADDR
// uc_nation = 0 ;
98849: LD_ADDR_OWVAR 21
98853: PUSH
98854: LD_INT 0
98856: ST_TO_ADDR
// InitHc_All ( ) ;
98857: CALL_OW 584
// InitVc ;
98861: CALL_OW 20
// if mastodonts then
98865: LD_VAR 0 6
98869: IFFALSE 98936
// for i = 1 to mastodonts do
98871: LD_ADDR_VAR 0 11
98875: PUSH
98876: DOUBLE
98877: LD_INT 1
98879: DEC
98880: ST_TO_ADDR
98881: LD_VAR 0 6
98885: PUSH
98886: FOR_TO
98887: IFFALSE 98934
// begin vc_chassis := 31 ;
98889: LD_ADDR_OWVAR 37
98893: PUSH
98894: LD_INT 31
98896: ST_TO_ADDR
// vc_control := control_rider ;
98897: LD_ADDR_OWVAR 38
98901: PUSH
98902: LD_INT 4
98904: ST_TO_ADDR
// animal := CreateVehicle ;
98905: LD_ADDR_VAR 0 12
98909: PUSH
98910: CALL_OW 45
98914: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98915: LD_VAR 0 12
98919: PPUSH
98920: LD_VAR 0 8
98924: PPUSH
98925: LD_INT 0
98927: PPUSH
98928: CALL 101124 0 3
// end ;
98932: GO 98886
98934: POP
98935: POP
// if horses then
98936: LD_VAR 0 5
98940: IFFALSE 99007
// for i = 1 to horses do
98942: LD_ADDR_VAR 0 11
98946: PUSH
98947: DOUBLE
98948: LD_INT 1
98950: DEC
98951: ST_TO_ADDR
98952: LD_VAR 0 5
98956: PUSH
98957: FOR_TO
98958: IFFALSE 99005
// begin hc_class := 21 ;
98960: LD_ADDR_OWVAR 28
98964: PUSH
98965: LD_INT 21
98967: ST_TO_ADDR
// hc_gallery :=  ;
98968: LD_ADDR_OWVAR 33
98972: PUSH
98973: LD_STRING 
98975: ST_TO_ADDR
// animal := CreateHuman ;
98976: LD_ADDR_VAR 0 12
98980: PUSH
98981: CALL_OW 44
98985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98986: LD_VAR 0 12
98990: PPUSH
98991: LD_VAR 0 8
98995: PPUSH
98996: LD_INT 0
98998: PPUSH
98999: CALL 101124 0 3
// end ;
99003: GO 98957
99005: POP
99006: POP
// if birds then
99007: LD_VAR 0 1
99011: IFFALSE 99078
// for i = 1 to birds do
99013: LD_ADDR_VAR 0 11
99017: PUSH
99018: DOUBLE
99019: LD_INT 1
99021: DEC
99022: ST_TO_ADDR
99023: LD_VAR 0 1
99027: PUSH
99028: FOR_TO
99029: IFFALSE 99076
// begin hc_class = 18 ;
99031: LD_ADDR_OWVAR 28
99035: PUSH
99036: LD_INT 18
99038: ST_TO_ADDR
// hc_gallery =  ;
99039: LD_ADDR_OWVAR 33
99043: PUSH
99044: LD_STRING 
99046: ST_TO_ADDR
// animal := CreateHuman ;
99047: LD_ADDR_VAR 0 12
99051: PUSH
99052: CALL_OW 44
99056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99057: LD_VAR 0 12
99061: PPUSH
99062: LD_VAR 0 8
99066: PPUSH
99067: LD_INT 0
99069: PPUSH
99070: CALL 101124 0 3
// end ;
99074: GO 99028
99076: POP
99077: POP
// if tigers then
99078: LD_VAR 0 2
99082: IFFALSE 99166
// for i = 1 to tigers do
99084: LD_ADDR_VAR 0 11
99088: PUSH
99089: DOUBLE
99090: LD_INT 1
99092: DEC
99093: ST_TO_ADDR
99094: LD_VAR 0 2
99098: PUSH
99099: FOR_TO
99100: IFFALSE 99164
// begin hc_class = class_tiger ;
99102: LD_ADDR_OWVAR 28
99106: PUSH
99107: LD_INT 14
99109: ST_TO_ADDR
// hc_gallery =  ;
99110: LD_ADDR_OWVAR 33
99114: PUSH
99115: LD_STRING 
99117: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99118: LD_ADDR_OWVAR 35
99122: PUSH
99123: LD_INT 7
99125: NEG
99126: PPUSH
99127: LD_INT 7
99129: PPUSH
99130: CALL_OW 12
99134: ST_TO_ADDR
// animal := CreateHuman ;
99135: LD_ADDR_VAR 0 12
99139: PUSH
99140: CALL_OW 44
99144: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99145: LD_VAR 0 12
99149: PPUSH
99150: LD_VAR 0 8
99154: PPUSH
99155: LD_INT 0
99157: PPUSH
99158: CALL 101124 0 3
// end ;
99162: GO 99099
99164: POP
99165: POP
// if apemans then
99166: LD_VAR 0 3
99170: IFFALSE 99293
// for i = 1 to apemans do
99172: LD_ADDR_VAR 0 11
99176: PUSH
99177: DOUBLE
99178: LD_INT 1
99180: DEC
99181: ST_TO_ADDR
99182: LD_VAR 0 3
99186: PUSH
99187: FOR_TO
99188: IFFALSE 99291
// begin hc_class = class_apeman ;
99190: LD_ADDR_OWVAR 28
99194: PUSH
99195: LD_INT 12
99197: ST_TO_ADDR
// hc_gallery =  ;
99198: LD_ADDR_OWVAR 33
99202: PUSH
99203: LD_STRING 
99205: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99206: LD_ADDR_OWVAR 35
99210: PUSH
99211: LD_INT 5
99213: NEG
99214: PPUSH
99215: LD_INT 5
99217: PPUSH
99218: CALL_OW 12
99222: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99223: LD_ADDR_OWVAR 31
99227: PUSH
99228: LD_INT 1
99230: PPUSH
99231: LD_INT 3
99233: PPUSH
99234: CALL_OW 12
99238: PUSH
99239: LD_INT 1
99241: PPUSH
99242: LD_INT 3
99244: PPUSH
99245: CALL_OW 12
99249: PUSH
99250: LD_INT 0
99252: PUSH
99253: LD_INT 0
99255: PUSH
99256: EMPTY
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: ST_TO_ADDR
// animal := CreateHuman ;
99262: LD_ADDR_VAR 0 12
99266: PUSH
99267: CALL_OW 44
99271: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99272: LD_VAR 0 12
99276: PPUSH
99277: LD_VAR 0 8
99281: PPUSH
99282: LD_INT 0
99284: PPUSH
99285: CALL 101124 0 3
// end ;
99289: GO 99187
99291: POP
99292: POP
// if enchidnas then
99293: LD_VAR 0 4
99297: IFFALSE 99364
// for i = 1 to enchidnas do
99299: LD_ADDR_VAR 0 11
99303: PUSH
99304: DOUBLE
99305: LD_INT 1
99307: DEC
99308: ST_TO_ADDR
99309: LD_VAR 0 4
99313: PUSH
99314: FOR_TO
99315: IFFALSE 99362
// begin hc_class = 13 ;
99317: LD_ADDR_OWVAR 28
99321: PUSH
99322: LD_INT 13
99324: ST_TO_ADDR
// hc_gallery =  ;
99325: LD_ADDR_OWVAR 33
99329: PUSH
99330: LD_STRING 
99332: ST_TO_ADDR
// animal := CreateHuman ;
99333: LD_ADDR_VAR 0 12
99337: PUSH
99338: CALL_OW 44
99342: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99343: LD_VAR 0 12
99347: PPUSH
99348: LD_VAR 0 8
99352: PPUSH
99353: LD_INT 0
99355: PPUSH
99356: CALL 101124 0 3
// end ;
99360: GO 99314
99362: POP
99363: POP
// if fishes then
99364: LD_VAR 0 7
99368: IFFALSE 99435
// for i = 1 to fishes do
99370: LD_ADDR_VAR 0 11
99374: PUSH
99375: DOUBLE
99376: LD_INT 1
99378: DEC
99379: ST_TO_ADDR
99380: LD_VAR 0 7
99384: PUSH
99385: FOR_TO
99386: IFFALSE 99433
// begin hc_class = 20 ;
99388: LD_ADDR_OWVAR 28
99392: PUSH
99393: LD_INT 20
99395: ST_TO_ADDR
// hc_gallery =  ;
99396: LD_ADDR_OWVAR 33
99400: PUSH
99401: LD_STRING 
99403: ST_TO_ADDR
// animal := CreateHuman ;
99404: LD_ADDR_VAR 0 12
99408: PUSH
99409: CALL_OW 44
99413: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99414: LD_VAR 0 12
99418: PPUSH
99419: LD_VAR 0 9
99423: PPUSH
99424: LD_INT 0
99426: PPUSH
99427: CALL 101124 0 3
// end ;
99431: GO 99385
99433: POP
99434: POP
// end ;
99435: LD_VAR 0 10
99439: RET
// export function WantHeal ( sci , unit ) ; begin
99440: LD_INT 0
99442: PPUSH
// if GetTaskList ( sci ) > 0 then
99443: LD_VAR 0 1
99447: PPUSH
99448: CALL_OW 437
99452: PUSH
99453: LD_INT 0
99455: GREATER
99456: IFFALSE 99526
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99458: LD_VAR 0 1
99462: PPUSH
99463: CALL_OW 437
99467: PUSH
99468: LD_INT 1
99470: ARRAY
99471: PUSH
99472: LD_INT 1
99474: ARRAY
99475: PUSH
99476: LD_STRING l
99478: EQUAL
99479: PUSH
99480: LD_VAR 0 1
99484: PPUSH
99485: CALL_OW 437
99489: PUSH
99490: LD_INT 1
99492: ARRAY
99493: PUSH
99494: LD_INT 4
99496: ARRAY
99497: PUSH
99498: LD_VAR 0 2
99502: EQUAL
99503: AND
99504: IFFALSE 99516
// result := true else
99506: LD_ADDR_VAR 0 3
99510: PUSH
99511: LD_INT 1
99513: ST_TO_ADDR
99514: GO 99524
// result := false ;
99516: LD_ADDR_VAR 0 3
99520: PUSH
99521: LD_INT 0
99523: ST_TO_ADDR
// end else
99524: GO 99534
// result := false ;
99526: LD_ADDR_VAR 0 3
99530: PUSH
99531: LD_INT 0
99533: ST_TO_ADDR
// end ;
99534: LD_VAR 0 3
99538: RET
// export function HealTarget ( sci ) ; begin
99539: LD_INT 0
99541: PPUSH
// if not sci then
99542: LD_VAR 0 1
99546: NOT
99547: IFFALSE 99551
// exit ;
99549: GO 99616
// result := 0 ;
99551: LD_ADDR_VAR 0 2
99555: PUSH
99556: LD_INT 0
99558: ST_TO_ADDR
// if GetTaskList ( sci ) then
99559: LD_VAR 0 1
99563: PPUSH
99564: CALL_OW 437
99568: IFFALSE 99616
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99570: LD_VAR 0 1
99574: PPUSH
99575: CALL_OW 437
99579: PUSH
99580: LD_INT 1
99582: ARRAY
99583: PUSH
99584: LD_INT 1
99586: ARRAY
99587: PUSH
99588: LD_STRING l
99590: EQUAL
99591: IFFALSE 99616
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99593: LD_ADDR_VAR 0 2
99597: PUSH
99598: LD_VAR 0 1
99602: PPUSH
99603: CALL_OW 437
99607: PUSH
99608: LD_INT 1
99610: ARRAY
99611: PUSH
99612: LD_INT 4
99614: ARRAY
99615: ST_TO_ADDR
// end ;
99616: LD_VAR 0 2
99620: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99621: LD_INT 0
99623: PPUSH
99624: PPUSH
99625: PPUSH
99626: PPUSH
// if not base_units then
99627: LD_VAR 0 1
99631: NOT
99632: IFFALSE 99636
// exit ;
99634: GO 99723
// result := false ;
99636: LD_ADDR_VAR 0 2
99640: PUSH
99641: LD_INT 0
99643: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99644: LD_ADDR_VAR 0 5
99648: PUSH
99649: LD_VAR 0 1
99653: PPUSH
99654: LD_INT 21
99656: PUSH
99657: LD_INT 3
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: PPUSH
99664: CALL_OW 72
99668: ST_TO_ADDR
// if not tmp then
99669: LD_VAR 0 5
99673: NOT
99674: IFFALSE 99678
// exit ;
99676: GO 99723
// for i in tmp do
99678: LD_ADDR_VAR 0 3
99682: PUSH
99683: LD_VAR 0 5
99687: PUSH
99688: FOR_IN
99689: IFFALSE 99721
// begin result := EnemyInRange ( i , 22 ) ;
99691: LD_ADDR_VAR 0 2
99695: PUSH
99696: LD_VAR 0 3
99700: PPUSH
99701: LD_INT 22
99703: PPUSH
99704: CALL 97959 0 2
99708: ST_TO_ADDR
// if result then
99709: LD_VAR 0 2
99713: IFFALSE 99719
// exit ;
99715: POP
99716: POP
99717: GO 99723
// end ;
99719: GO 99688
99721: POP
99722: POP
// end ;
99723: LD_VAR 0 2
99727: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99728: LD_INT 0
99730: PPUSH
99731: PPUSH
// if not units then
99732: LD_VAR 0 1
99736: NOT
99737: IFFALSE 99741
// exit ;
99739: GO 99811
// result := [ ] ;
99741: LD_ADDR_VAR 0 3
99745: PUSH
99746: EMPTY
99747: ST_TO_ADDR
// for i in units do
99748: LD_ADDR_VAR 0 4
99752: PUSH
99753: LD_VAR 0 1
99757: PUSH
99758: FOR_IN
99759: IFFALSE 99809
// if GetTag ( i ) = tag then
99761: LD_VAR 0 4
99765: PPUSH
99766: CALL_OW 110
99770: PUSH
99771: LD_VAR 0 2
99775: EQUAL
99776: IFFALSE 99807
// result := Insert ( result , result + 1 , i ) ;
99778: LD_ADDR_VAR 0 3
99782: PUSH
99783: LD_VAR 0 3
99787: PPUSH
99788: LD_VAR 0 3
99792: PUSH
99793: LD_INT 1
99795: PLUS
99796: PPUSH
99797: LD_VAR 0 4
99801: PPUSH
99802: CALL_OW 2
99806: ST_TO_ADDR
99807: GO 99758
99809: POP
99810: POP
// end ;
99811: LD_VAR 0 3
99815: RET
// export function IsDriver ( un ) ; begin
99816: LD_INT 0
99818: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99819: LD_ADDR_VAR 0 2
99823: PUSH
99824: LD_VAR 0 1
99828: PUSH
99829: LD_INT 55
99831: PUSH
99832: EMPTY
99833: LIST
99834: PPUSH
99835: CALL_OW 69
99839: IN
99840: ST_TO_ADDR
// end ;
99841: LD_VAR 0 2
99845: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99846: LD_INT 0
99848: PPUSH
99849: PPUSH
// list := [ ] ;
99850: LD_ADDR_VAR 0 5
99854: PUSH
99855: EMPTY
99856: ST_TO_ADDR
// case d of 0 :
99857: LD_VAR 0 3
99861: PUSH
99862: LD_INT 0
99864: DOUBLE
99865: EQUAL
99866: IFTRUE 99870
99868: GO 100003
99870: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99871: LD_ADDR_VAR 0 5
99875: PUSH
99876: LD_VAR 0 1
99880: PUSH
99881: LD_INT 4
99883: MINUS
99884: PUSH
99885: LD_VAR 0 2
99889: PUSH
99890: LD_INT 4
99892: MINUS
99893: PUSH
99894: LD_INT 2
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: LIST
99901: PUSH
99902: LD_VAR 0 1
99906: PUSH
99907: LD_INT 3
99909: MINUS
99910: PUSH
99911: LD_VAR 0 2
99915: PUSH
99916: LD_INT 1
99918: PUSH
99919: EMPTY
99920: LIST
99921: LIST
99922: LIST
99923: PUSH
99924: LD_VAR 0 1
99928: PUSH
99929: LD_INT 4
99931: PLUS
99932: PUSH
99933: LD_VAR 0 2
99937: PUSH
99938: LD_INT 4
99940: PUSH
99941: EMPTY
99942: LIST
99943: LIST
99944: LIST
99945: PUSH
99946: LD_VAR 0 1
99950: PUSH
99951: LD_INT 3
99953: PLUS
99954: PUSH
99955: LD_VAR 0 2
99959: PUSH
99960: LD_INT 3
99962: PLUS
99963: PUSH
99964: LD_INT 5
99966: PUSH
99967: EMPTY
99968: LIST
99969: LIST
99970: LIST
99971: PUSH
99972: LD_VAR 0 1
99976: PUSH
99977: LD_VAR 0 2
99981: PUSH
99982: LD_INT 4
99984: PLUS
99985: PUSH
99986: LD_INT 0
99988: PUSH
99989: EMPTY
99990: LIST
99991: LIST
99992: LIST
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: ST_TO_ADDR
// end ; 1 :
100001: GO 100701
100003: LD_INT 1
100005: DOUBLE
100006: EQUAL
100007: IFTRUE 100011
100009: GO 100144
100011: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100012: LD_ADDR_VAR 0 5
100016: PUSH
100017: LD_VAR 0 1
100021: PUSH
100022: LD_VAR 0 2
100026: PUSH
100027: LD_INT 4
100029: MINUS
100030: PUSH
100031: LD_INT 3
100033: PUSH
100034: EMPTY
100035: LIST
100036: LIST
100037: LIST
100038: PUSH
100039: LD_VAR 0 1
100043: PUSH
100044: LD_INT 3
100046: MINUS
100047: PUSH
100048: LD_VAR 0 2
100052: PUSH
100053: LD_INT 3
100055: MINUS
100056: PUSH
100057: LD_INT 2
100059: PUSH
100060: EMPTY
100061: LIST
100062: LIST
100063: LIST
100064: PUSH
100065: LD_VAR 0 1
100069: PUSH
100070: LD_INT 4
100072: MINUS
100073: PUSH
100074: LD_VAR 0 2
100078: PUSH
100079: LD_INT 1
100081: PUSH
100082: EMPTY
100083: LIST
100084: LIST
100085: LIST
100086: PUSH
100087: LD_VAR 0 1
100091: PUSH
100092: LD_VAR 0 2
100096: PUSH
100097: LD_INT 3
100099: PLUS
100100: PUSH
100101: LD_INT 0
100103: PUSH
100104: EMPTY
100105: LIST
100106: LIST
100107: LIST
100108: PUSH
100109: LD_VAR 0 1
100113: PUSH
100114: LD_INT 4
100116: PLUS
100117: PUSH
100118: LD_VAR 0 2
100122: PUSH
100123: LD_INT 4
100125: PLUS
100126: PUSH
100127: LD_INT 5
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: LIST
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: LIST
100139: LIST
100140: LIST
100141: ST_TO_ADDR
// end ; 2 :
100142: GO 100701
100144: LD_INT 2
100146: DOUBLE
100147: EQUAL
100148: IFTRUE 100152
100150: GO 100281
100152: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100153: LD_ADDR_VAR 0 5
100157: PUSH
100158: LD_VAR 0 1
100162: PUSH
100163: LD_VAR 0 2
100167: PUSH
100168: LD_INT 3
100170: MINUS
100171: PUSH
100172: LD_INT 3
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: LIST
100179: PUSH
100180: LD_VAR 0 1
100184: PUSH
100185: LD_INT 4
100187: PLUS
100188: PUSH
100189: LD_VAR 0 2
100193: PUSH
100194: LD_INT 4
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: LIST
100201: PUSH
100202: LD_VAR 0 1
100206: PUSH
100207: LD_VAR 0 2
100211: PUSH
100212: LD_INT 4
100214: PLUS
100215: PUSH
100216: LD_INT 0
100218: PUSH
100219: EMPTY
100220: LIST
100221: LIST
100222: LIST
100223: PUSH
100224: LD_VAR 0 1
100228: PUSH
100229: LD_INT 3
100231: MINUS
100232: PUSH
100233: LD_VAR 0 2
100237: PUSH
100238: LD_INT 1
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: LIST
100245: PUSH
100246: LD_VAR 0 1
100250: PUSH
100251: LD_INT 4
100253: MINUS
100254: PUSH
100255: LD_VAR 0 2
100259: PUSH
100260: LD_INT 4
100262: MINUS
100263: PUSH
100264: LD_INT 2
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: LIST
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: ST_TO_ADDR
// end ; 3 :
100279: GO 100701
100281: LD_INT 3
100283: DOUBLE
100284: EQUAL
100285: IFTRUE 100289
100287: GO 100422
100289: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100290: LD_ADDR_VAR 0 5
100294: PUSH
100295: LD_VAR 0 1
100299: PUSH
100300: LD_INT 3
100302: PLUS
100303: PUSH
100304: LD_VAR 0 2
100308: PUSH
100309: LD_INT 4
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: LIST
100316: PUSH
100317: LD_VAR 0 1
100321: PUSH
100322: LD_INT 4
100324: PLUS
100325: PUSH
100326: LD_VAR 0 2
100330: PUSH
100331: LD_INT 4
100333: PLUS
100334: PUSH
100335: LD_INT 5
100337: PUSH
100338: EMPTY
100339: LIST
100340: LIST
100341: LIST
100342: PUSH
100343: LD_VAR 0 1
100347: PUSH
100348: LD_INT 4
100350: MINUS
100351: PUSH
100352: LD_VAR 0 2
100356: PUSH
100357: LD_INT 1
100359: PUSH
100360: EMPTY
100361: LIST
100362: LIST
100363: LIST
100364: PUSH
100365: LD_VAR 0 1
100369: PUSH
100370: LD_VAR 0 2
100374: PUSH
100375: LD_INT 4
100377: MINUS
100378: PUSH
100379: LD_INT 3
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: LIST
100386: PUSH
100387: LD_VAR 0 1
100391: PUSH
100392: LD_INT 3
100394: MINUS
100395: PUSH
100396: LD_VAR 0 2
100400: PUSH
100401: LD_INT 3
100403: MINUS
100404: PUSH
100405: LD_INT 2
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: LIST
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: ST_TO_ADDR
// end ; 4 :
100420: GO 100701
100422: LD_INT 4
100424: DOUBLE
100425: EQUAL
100426: IFTRUE 100430
100428: GO 100563
100430: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100431: LD_ADDR_VAR 0 5
100435: PUSH
100436: LD_VAR 0 1
100440: PUSH
100441: LD_VAR 0 2
100445: PUSH
100446: LD_INT 4
100448: PLUS
100449: PUSH
100450: LD_INT 0
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: LIST
100457: PUSH
100458: LD_VAR 0 1
100462: PUSH
100463: LD_INT 3
100465: PLUS
100466: PUSH
100467: LD_VAR 0 2
100471: PUSH
100472: LD_INT 3
100474: PLUS
100475: PUSH
100476: LD_INT 5
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: LIST
100483: PUSH
100484: LD_VAR 0 1
100488: PUSH
100489: LD_INT 4
100491: PLUS
100492: PUSH
100493: LD_VAR 0 2
100497: PUSH
100498: LD_INT 4
100500: PUSH
100501: EMPTY
100502: LIST
100503: LIST
100504: LIST
100505: PUSH
100506: LD_VAR 0 1
100510: PUSH
100511: LD_VAR 0 2
100515: PUSH
100516: LD_INT 3
100518: MINUS
100519: PUSH
100520: LD_INT 3
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: LIST
100527: PUSH
100528: LD_VAR 0 1
100532: PUSH
100533: LD_INT 4
100535: MINUS
100536: PUSH
100537: LD_VAR 0 2
100541: PUSH
100542: LD_INT 4
100544: MINUS
100545: PUSH
100546: LD_INT 2
100548: PUSH
100549: EMPTY
100550: LIST
100551: LIST
100552: LIST
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: LIST
100558: LIST
100559: LIST
100560: ST_TO_ADDR
// end ; 5 :
100561: GO 100701
100563: LD_INT 5
100565: DOUBLE
100566: EQUAL
100567: IFTRUE 100571
100569: GO 100700
100571: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100572: LD_ADDR_VAR 0 5
100576: PUSH
100577: LD_VAR 0 1
100581: PUSH
100582: LD_INT 4
100584: MINUS
100585: PUSH
100586: LD_VAR 0 2
100590: PUSH
100591: LD_INT 1
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: LIST
100598: PUSH
100599: LD_VAR 0 1
100603: PUSH
100604: LD_VAR 0 2
100608: PUSH
100609: LD_INT 4
100611: MINUS
100612: PUSH
100613: LD_INT 3
100615: PUSH
100616: EMPTY
100617: LIST
100618: LIST
100619: LIST
100620: PUSH
100621: LD_VAR 0 1
100625: PUSH
100626: LD_INT 4
100628: PLUS
100629: PUSH
100630: LD_VAR 0 2
100634: PUSH
100635: LD_INT 4
100637: PLUS
100638: PUSH
100639: LD_INT 5
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: LIST
100646: PUSH
100647: LD_VAR 0 1
100651: PUSH
100652: LD_INT 3
100654: PLUS
100655: PUSH
100656: LD_VAR 0 2
100660: PUSH
100661: LD_INT 4
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: LIST
100668: PUSH
100669: LD_VAR 0 1
100673: PUSH
100674: LD_VAR 0 2
100678: PUSH
100679: LD_INT 3
100681: PLUS
100682: PUSH
100683: LD_INT 0
100685: PUSH
100686: EMPTY
100687: LIST
100688: LIST
100689: LIST
100690: PUSH
100691: EMPTY
100692: LIST
100693: LIST
100694: LIST
100695: LIST
100696: LIST
100697: ST_TO_ADDR
// end ; end ;
100698: GO 100701
100700: POP
// result := list ;
100701: LD_ADDR_VAR 0 4
100705: PUSH
100706: LD_VAR 0 5
100710: ST_TO_ADDR
// end ;
100711: LD_VAR 0 4
100715: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100716: LD_INT 0
100718: PPUSH
100719: PPUSH
100720: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100721: LD_VAR 0 1
100725: NOT
100726: PUSH
100727: LD_VAR 0 2
100731: PUSH
100732: LD_INT 1
100734: PUSH
100735: LD_INT 2
100737: PUSH
100738: LD_INT 3
100740: PUSH
100741: LD_INT 4
100743: PUSH
100744: EMPTY
100745: LIST
100746: LIST
100747: LIST
100748: LIST
100749: IN
100750: NOT
100751: OR
100752: IFFALSE 100756
// exit ;
100754: GO 100848
// tmp := [ ] ;
100756: LD_ADDR_VAR 0 5
100760: PUSH
100761: EMPTY
100762: ST_TO_ADDR
// for i in units do
100763: LD_ADDR_VAR 0 4
100767: PUSH
100768: LD_VAR 0 1
100772: PUSH
100773: FOR_IN
100774: IFFALSE 100817
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
100776: LD_ADDR_VAR 0 5
100780: PUSH
100781: LD_VAR 0 5
100785: PPUSH
100786: LD_VAR 0 5
100790: PUSH
100791: LD_INT 1
100793: PLUS
100794: PPUSH
100795: LD_VAR 0 4
100799: PPUSH
100800: LD_VAR 0 2
100804: PPUSH
100805: CALL_OW 259
100809: PPUSH
100810: CALL_OW 2
100814: ST_TO_ADDR
100815: GO 100773
100817: POP
100818: POP
// if not tmp then
100819: LD_VAR 0 5
100823: NOT
100824: IFFALSE 100828
// exit ;
100826: GO 100848
// result := SortListByListDesc ( units , tmp ) ;
100828: LD_ADDR_VAR 0 3
100832: PUSH
100833: LD_VAR 0 1
100837: PPUSH
100838: LD_VAR 0 5
100842: PPUSH
100843: CALL_OW 77
100847: ST_TO_ADDR
// end ;
100848: LD_VAR 0 3
100852: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100853: LD_INT 0
100855: PPUSH
100856: PPUSH
100857: PPUSH
// result := false ;
100858: LD_ADDR_VAR 0 3
100862: PUSH
100863: LD_INT 0
100865: ST_TO_ADDR
// x := GetX ( building ) ;
100866: LD_ADDR_VAR 0 4
100870: PUSH
100871: LD_VAR 0 2
100875: PPUSH
100876: CALL_OW 250
100880: ST_TO_ADDR
// y := GetY ( building ) ;
100881: LD_ADDR_VAR 0 5
100885: PUSH
100886: LD_VAR 0 2
100890: PPUSH
100891: CALL_OW 251
100895: ST_TO_ADDR
// if not building or not x or not y then
100896: LD_VAR 0 2
100900: NOT
100901: PUSH
100902: LD_VAR 0 4
100906: NOT
100907: OR
100908: PUSH
100909: LD_VAR 0 5
100913: NOT
100914: OR
100915: IFFALSE 100919
// exit ;
100917: GO 101011
// if GetTaskList ( unit ) then
100919: LD_VAR 0 1
100923: PPUSH
100924: CALL_OW 437
100928: IFFALSE 101011
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100930: LD_STRING e
100932: PUSH
100933: LD_VAR 0 1
100937: PPUSH
100938: CALL_OW 437
100942: PUSH
100943: LD_INT 1
100945: ARRAY
100946: PUSH
100947: LD_INT 1
100949: ARRAY
100950: EQUAL
100951: PUSH
100952: LD_VAR 0 4
100956: PUSH
100957: LD_VAR 0 1
100961: PPUSH
100962: CALL_OW 437
100966: PUSH
100967: LD_INT 1
100969: ARRAY
100970: PUSH
100971: LD_INT 2
100973: ARRAY
100974: EQUAL
100975: AND
100976: PUSH
100977: LD_VAR 0 5
100981: PUSH
100982: LD_VAR 0 1
100986: PPUSH
100987: CALL_OW 437
100991: PUSH
100992: LD_INT 1
100994: ARRAY
100995: PUSH
100996: LD_INT 3
100998: ARRAY
100999: EQUAL
101000: AND
101001: IFFALSE 101011
// result := true end ;
101003: LD_ADDR_VAR 0 3
101007: PUSH
101008: LD_INT 1
101010: ST_TO_ADDR
// end ;
101011: LD_VAR 0 3
101015: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101016: LD_INT 0
101018: PPUSH
// result := false ;
101019: LD_ADDR_VAR 0 4
101023: PUSH
101024: LD_INT 0
101026: ST_TO_ADDR
// if GetTaskList ( unit ) then
101027: LD_VAR 0 1
101031: PPUSH
101032: CALL_OW 437
101036: IFFALSE 101119
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101038: LD_STRING M
101040: PUSH
101041: LD_VAR 0 1
101045: PPUSH
101046: CALL_OW 437
101050: PUSH
101051: LD_INT 1
101053: ARRAY
101054: PUSH
101055: LD_INT 1
101057: ARRAY
101058: EQUAL
101059: PUSH
101060: LD_VAR 0 2
101064: PUSH
101065: LD_VAR 0 1
101069: PPUSH
101070: CALL_OW 437
101074: PUSH
101075: LD_INT 1
101077: ARRAY
101078: PUSH
101079: LD_INT 2
101081: ARRAY
101082: EQUAL
101083: AND
101084: PUSH
101085: LD_VAR 0 3
101089: PUSH
101090: LD_VAR 0 1
101094: PPUSH
101095: CALL_OW 437
101099: PUSH
101100: LD_INT 1
101102: ARRAY
101103: PUSH
101104: LD_INT 3
101106: ARRAY
101107: EQUAL
101108: AND
101109: IFFALSE 101119
// result := true ;
101111: LD_ADDR_VAR 0 4
101115: PUSH
101116: LD_INT 1
101118: ST_TO_ADDR
// end ; end ;
101119: LD_VAR 0 4
101123: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101124: LD_INT 0
101126: PPUSH
101127: PPUSH
101128: PPUSH
101129: PPUSH
// if not unit or not area then
101130: LD_VAR 0 1
101134: NOT
101135: PUSH
101136: LD_VAR 0 2
101140: NOT
101141: OR
101142: IFFALSE 101146
// exit ;
101144: GO 101310
// tmp := AreaToList ( area , i ) ;
101146: LD_ADDR_VAR 0 6
101150: PUSH
101151: LD_VAR 0 2
101155: PPUSH
101156: LD_VAR 0 5
101160: PPUSH
101161: CALL_OW 517
101165: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101166: LD_ADDR_VAR 0 5
101170: PUSH
101171: DOUBLE
101172: LD_INT 1
101174: DEC
101175: ST_TO_ADDR
101176: LD_VAR 0 6
101180: PUSH
101181: LD_INT 1
101183: ARRAY
101184: PUSH
101185: FOR_TO
101186: IFFALSE 101308
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101188: LD_ADDR_VAR 0 7
101192: PUSH
101193: LD_VAR 0 6
101197: PUSH
101198: LD_INT 1
101200: ARRAY
101201: PUSH
101202: LD_VAR 0 5
101206: ARRAY
101207: PUSH
101208: LD_VAR 0 6
101212: PUSH
101213: LD_INT 2
101215: ARRAY
101216: PUSH
101217: LD_VAR 0 5
101221: ARRAY
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101227: LD_VAR 0 7
101231: PUSH
101232: LD_INT 1
101234: ARRAY
101235: PPUSH
101236: LD_VAR 0 7
101240: PUSH
101241: LD_INT 2
101243: ARRAY
101244: PPUSH
101245: CALL_OW 428
101249: PUSH
101250: LD_INT 0
101252: EQUAL
101253: IFFALSE 101306
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101255: LD_VAR 0 1
101259: PPUSH
101260: LD_VAR 0 7
101264: PUSH
101265: LD_INT 1
101267: ARRAY
101268: PPUSH
101269: LD_VAR 0 7
101273: PUSH
101274: LD_INT 2
101276: ARRAY
101277: PPUSH
101278: LD_VAR 0 3
101282: PPUSH
101283: CALL_OW 48
// result := IsPlaced ( unit ) ;
101287: LD_ADDR_VAR 0 4
101291: PUSH
101292: LD_VAR 0 1
101296: PPUSH
101297: CALL_OW 305
101301: ST_TO_ADDR
// exit ;
101302: POP
101303: POP
101304: GO 101310
// end ; end ;
101306: GO 101185
101308: POP
101309: POP
// end ;
101310: LD_VAR 0 4
101314: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101315: LD_INT 0
101317: PPUSH
101318: PPUSH
101319: PPUSH
// if not side or side > 8 then
101320: LD_VAR 0 1
101324: NOT
101325: PUSH
101326: LD_VAR 0 1
101330: PUSH
101331: LD_INT 8
101333: GREATER
101334: OR
101335: IFFALSE 101339
// exit ;
101337: GO 101526
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101339: LD_ADDR_VAR 0 4
101343: PUSH
101344: LD_INT 22
101346: PUSH
101347: LD_VAR 0 1
101351: PUSH
101352: EMPTY
101353: LIST
101354: LIST
101355: PUSH
101356: LD_INT 21
101358: PUSH
101359: LD_INT 3
101361: PUSH
101362: EMPTY
101363: LIST
101364: LIST
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PPUSH
101370: CALL_OW 69
101374: ST_TO_ADDR
// if not tmp then
101375: LD_VAR 0 4
101379: NOT
101380: IFFALSE 101384
// exit ;
101382: GO 101526
// enable_addtolog := true ;
101384: LD_ADDR_OWVAR 81
101388: PUSH
101389: LD_INT 1
101391: ST_TO_ADDR
// AddToLog ( [ ) ;
101392: LD_STRING [
101394: PPUSH
101395: CALL_OW 561
// for i in tmp do
101399: LD_ADDR_VAR 0 3
101403: PUSH
101404: LD_VAR 0 4
101408: PUSH
101409: FOR_IN
101410: IFFALSE 101517
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101412: LD_STRING [
101414: PUSH
101415: LD_VAR 0 3
101419: PPUSH
101420: CALL_OW 266
101424: STR
101425: PUSH
101426: LD_STRING , 
101428: STR
101429: PUSH
101430: LD_VAR 0 3
101434: PPUSH
101435: CALL_OW 250
101439: STR
101440: PUSH
101441: LD_STRING , 
101443: STR
101444: PUSH
101445: LD_VAR 0 3
101449: PPUSH
101450: CALL_OW 251
101454: STR
101455: PUSH
101456: LD_STRING , 
101458: STR
101459: PUSH
101460: LD_VAR 0 3
101464: PPUSH
101465: CALL_OW 254
101469: STR
101470: PUSH
101471: LD_STRING , 
101473: STR
101474: PUSH
101475: LD_VAR 0 3
101479: PPUSH
101480: LD_INT 1
101482: PPUSH
101483: CALL_OW 268
101487: STR
101488: PUSH
101489: LD_STRING , 
101491: STR
101492: PUSH
101493: LD_VAR 0 3
101497: PPUSH
101498: LD_INT 2
101500: PPUSH
101501: CALL_OW 268
101505: STR
101506: PUSH
101507: LD_STRING ],
101509: STR
101510: PPUSH
101511: CALL_OW 561
// end ;
101515: GO 101409
101517: POP
101518: POP
// AddToLog ( ]; ) ;
101519: LD_STRING ];
101521: PPUSH
101522: CALL_OW 561
// end ;
101526: LD_VAR 0 2
101530: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101531: LD_INT 0
101533: PPUSH
101534: PPUSH
101535: PPUSH
101536: PPUSH
101537: PPUSH
// if not area or not rate or not max then
101538: LD_VAR 0 1
101542: NOT
101543: PUSH
101544: LD_VAR 0 2
101548: NOT
101549: OR
101550: PUSH
101551: LD_VAR 0 4
101555: NOT
101556: OR
101557: IFFALSE 101561
// exit ;
101559: GO 101753
// while 1 do
101561: LD_INT 1
101563: IFFALSE 101753
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101565: LD_ADDR_VAR 0 9
101569: PUSH
101570: LD_VAR 0 1
101574: PPUSH
101575: LD_INT 1
101577: PPUSH
101578: CALL_OW 287
101582: PUSH
101583: LD_INT 10
101585: MUL
101586: ST_TO_ADDR
// r := rate / 10 ;
101587: LD_ADDR_VAR 0 7
101591: PUSH
101592: LD_VAR 0 2
101596: PUSH
101597: LD_INT 10
101599: DIVREAL
101600: ST_TO_ADDR
// time := 1 1$00 ;
101601: LD_ADDR_VAR 0 8
101605: PUSH
101606: LD_INT 2100
101608: ST_TO_ADDR
// if amount < min then
101609: LD_VAR 0 9
101613: PUSH
101614: LD_VAR 0 3
101618: LESS
101619: IFFALSE 101637
// r := r * 2 else
101621: LD_ADDR_VAR 0 7
101625: PUSH
101626: LD_VAR 0 7
101630: PUSH
101631: LD_INT 2
101633: MUL
101634: ST_TO_ADDR
101635: GO 101663
// if amount > max then
101637: LD_VAR 0 9
101641: PUSH
101642: LD_VAR 0 4
101646: GREATER
101647: IFFALSE 101663
// r := r / 2 ;
101649: LD_ADDR_VAR 0 7
101653: PUSH
101654: LD_VAR 0 7
101658: PUSH
101659: LD_INT 2
101661: DIVREAL
101662: ST_TO_ADDR
// time := time / r ;
101663: LD_ADDR_VAR 0 8
101667: PUSH
101668: LD_VAR 0 8
101672: PUSH
101673: LD_VAR 0 7
101677: DIVREAL
101678: ST_TO_ADDR
// if time < 0 then
101679: LD_VAR 0 8
101683: PUSH
101684: LD_INT 0
101686: LESS
101687: IFFALSE 101704
// time := time * - 1 ;
101689: LD_ADDR_VAR 0 8
101693: PUSH
101694: LD_VAR 0 8
101698: PUSH
101699: LD_INT 1
101701: NEG
101702: MUL
101703: ST_TO_ADDR
// wait ( time ) ;
101704: LD_VAR 0 8
101708: PPUSH
101709: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101713: LD_INT 35
101715: PPUSH
101716: LD_INT 875
101718: PPUSH
101719: CALL_OW 12
101723: PPUSH
101724: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101728: LD_INT 1
101730: PPUSH
101731: LD_INT 5
101733: PPUSH
101734: CALL_OW 12
101738: PPUSH
101739: LD_VAR 0 1
101743: PPUSH
101744: LD_INT 1
101746: PPUSH
101747: CALL_OW 55
// end ;
101751: GO 101561
// end ;
101753: LD_VAR 0 5
101757: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101758: LD_INT 0
101760: PPUSH
101761: PPUSH
101762: PPUSH
101763: PPUSH
101764: PPUSH
101765: PPUSH
101766: PPUSH
101767: PPUSH
// if not turrets or not factories then
101768: LD_VAR 0 1
101772: NOT
101773: PUSH
101774: LD_VAR 0 2
101778: NOT
101779: OR
101780: IFFALSE 101784
// exit ;
101782: GO 102091
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101784: LD_ADDR_VAR 0 10
101788: PUSH
101789: LD_INT 5
101791: PUSH
101792: LD_INT 6
101794: PUSH
101795: EMPTY
101796: LIST
101797: LIST
101798: PUSH
101799: LD_INT 2
101801: PUSH
101802: LD_INT 4
101804: PUSH
101805: EMPTY
101806: LIST
101807: LIST
101808: PUSH
101809: LD_INT 3
101811: PUSH
101812: LD_INT 5
101814: PUSH
101815: EMPTY
101816: LIST
101817: LIST
101818: PUSH
101819: EMPTY
101820: LIST
101821: LIST
101822: LIST
101823: PUSH
101824: LD_INT 24
101826: PUSH
101827: LD_INT 25
101829: PUSH
101830: EMPTY
101831: LIST
101832: LIST
101833: PUSH
101834: LD_INT 23
101836: PUSH
101837: LD_INT 27
101839: PUSH
101840: EMPTY
101841: LIST
101842: LIST
101843: PUSH
101844: EMPTY
101845: LIST
101846: LIST
101847: PUSH
101848: LD_INT 42
101850: PUSH
101851: LD_INT 43
101853: PUSH
101854: EMPTY
101855: LIST
101856: LIST
101857: PUSH
101858: LD_INT 44
101860: PUSH
101861: LD_INT 46
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PUSH
101868: LD_INT 45
101870: PUSH
101871: LD_INT 47
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: LIST
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: LIST
101887: ST_TO_ADDR
// result := [ ] ;
101888: LD_ADDR_VAR 0 3
101892: PUSH
101893: EMPTY
101894: ST_TO_ADDR
// for i in turrets do
101895: LD_ADDR_VAR 0 4
101899: PUSH
101900: LD_VAR 0 1
101904: PUSH
101905: FOR_IN
101906: IFFALSE 102089
// begin nat := GetNation ( i ) ;
101908: LD_ADDR_VAR 0 7
101912: PUSH
101913: LD_VAR 0 4
101917: PPUSH
101918: CALL_OW 248
101922: ST_TO_ADDR
// weapon := 0 ;
101923: LD_ADDR_VAR 0 8
101927: PUSH
101928: LD_INT 0
101930: ST_TO_ADDR
// if not nat then
101931: LD_VAR 0 7
101935: NOT
101936: IFFALSE 101940
// continue ;
101938: GO 101905
// for j in list [ nat ] do
101940: LD_ADDR_VAR 0 5
101944: PUSH
101945: LD_VAR 0 10
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PUSH
101956: FOR_IN
101957: IFFALSE 101998
// if GetBWeapon ( i ) = j [ 1 ] then
101959: LD_VAR 0 4
101963: PPUSH
101964: CALL_OW 269
101968: PUSH
101969: LD_VAR 0 5
101973: PUSH
101974: LD_INT 1
101976: ARRAY
101977: EQUAL
101978: IFFALSE 101996
// begin weapon := j [ 2 ] ;
101980: LD_ADDR_VAR 0 8
101984: PUSH
101985: LD_VAR 0 5
101989: PUSH
101990: LD_INT 2
101992: ARRAY
101993: ST_TO_ADDR
// break ;
101994: GO 101998
// end ;
101996: GO 101956
101998: POP
101999: POP
// if not weapon then
102000: LD_VAR 0 8
102004: NOT
102005: IFFALSE 102009
// continue ;
102007: GO 101905
// for k in factories do
102009: LD_ADDR_VAR 0 6
102013: PUSH
102014: LD_VAR 0 2
102018: PUSH
102019: FOR_IN
102020: IFFALSE 102085
// begin weapons := AvailableWeaponList ( k ) ;
102022: LD_ADDR_VAR 0 9
102026: PUSH
102027: LD_VAR 0 6
102031: PPUSH
102032: CALL_OW 478
102036: ST_TO_ADDR
// if not weapons then
102037: LD_VAR 0 9
102041: NOT
102042: IFFALSE 102046
// continue ;
102044: GO 102019
// if weapon in weapons then
102046: LD_VAR 0 8
102050: PUSH
102051: LD_VAR 0 9
102055: IN
102056: IFFALSE 102083
// begin result := [ i , weapon ] ;
102058: LD_ADDR_VAR 0 3
102062: PUSH
102063: LD_VAR 0 4
102067: PUSH
102068: LD_VAR 0 8
102072: PUSH
102073: EMPTY
102074: LIST
102075: LIST
102076: ST_TO_ADDR
// exit ;
102077: POP
102078: POP
102079: POP
102080: POP
102081: GO 102091
// end ; end ;
102083: GO 102019
102085: POP
102086: POP
// end ;
102087: GO 101905
102089: POP
102090: POP
// end ;
102091: LD_VAR 0 3
102095: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102096: LD_INT 0
102098: PPUSH
// if not side or side > 8 then
102099: LD_VAR 0 3
102103: NOT
102104: PUSH
102105: LD_VAR 0 3
102109: PUSH
102110: LD_INT 8
102112: GREATER
102113: OR
102114: IFFALSE 102118
// exit ;
102116: GO 102177
// if not range then
102118: LD_VAR 0 4
102122: NOT
102123: IFFALSE 102134
// range := - 12 ;
102125: LD_ADDR_VAR 0 4
102129: PUSH
102130: LD_INT 12
102132: NEG
102133: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102134: LD_VAR 0 1
102138: PPUSH
102139: LD_VAR 0 2
102143: PPUSH
102144: LD_VAR 0 3
102148: PPUSH
102149: LD_VAR 0 4
102153: PPUSH
102154: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102158: LD_VAR 0 1
102162: PPUSH
102163: LD_VAR 0 2
102167: PPUSH
102168: LD_VAR 0 3
102172: PPUSH
102173: CALL_OW 331
// end ;
102177: LD_VAR 0 5
102181: RET
// export function Video ( mode ) ; begin
102182: LD_INT 0
102184: PPUSH
// ingame_video = mode ;
102185: LD_ADDR_OWVAR 52
102189: PUSH
102190: LD_VAR 0 1
102194: ST_TO_ADDR
// interface_hidden = mode ;
102195: LD_ADDR_OWVAR 54
102199: PUSH
102200: LD_VAR 0 1
102204: ST_TO_ADDR
// end ;
102205: LD_VAR 0 2
102209: RET
// export function Join ( array , element ) ; begin
102210: LD_INT 0
102212: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102213: LD_ADDR_VAR 0 3
102217: PUSH
102218: LD_VAR 0 1
102222: PPUSH
102223: LD_VAR 0 1
102227: PUSH
102228: LD_INT 1
102230: PLUS
102231: PPUSH
102232: LD_VAR 0 2
102236: PPUSH
102237: CALL_OW 1
102241: ST_TO_ADDR
// end ;
102242: LD_VAR 0 3
102246: RET
// export function JoinUnion ( array , element ) ; begin
102247: LD_INT 0
102249: PPUSH
// result := array union element ;
102250: LD_ADDR_VAR 0 3
102254: PUSH
102255: LD_VAR 0 1
102259: PUSH
102260: LD_VAR 0 2
102264: UNION
102265: ST_TO_ADDR
// end ;
102266: LD_VAR 0 3
102270: RET
// export function GetBehemoths ( side ) ; begin
102271: LD_INT 0
102273: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102274: LD_ADDR_VAR 0 2
102278: PUSH
102279: LD_INT 22
102281: PUSH
102282: LD_VAR 0 1
102286: PUSH
102287: EMPTY
102288: LIST
102289: LIST
102290: PUSH
102291: LD_INT 31
102293: PUSH
102294: LD_INT 25
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: PUSH
102301: EMPTY
102302: LIST
102303: LIST
102304: PPUSH
102305: CALL_OW 69
102309: ST_TO_ADDR
// end ;
102310: LD_VAR 0 2
102314: RET
// export function Shuffle ( array ) ; var i , index ; begin
102315: LD_INT 0
102317: PPUSH
102318: PPUSH
102319: PPUSH
// result := [ ] ;
102320: LD_ADDR_VAR 0 2
102324: PUSH
102325: EMPTY
102326: ST_TO_ADDR
// if not array then
102327: LD_VAR 0 1
102331: NOT
102332: IFFALSE 102336
// exit ;
102334: GO 102435
// Randomize ;
102336: CALL_OW 10
// for i = array downto 1 do
102340: LD_ADDR_VAR 0 3
102344: PUSH
102345: DOUBLE
102346: LD_VAR 0 1
102350: INC
102351: ST_TO_ADDR
102352: LD_INT 1
102354: PUSH
102355: FOR_DOWNTO
102356: IFFALSE 102433
// begin index := rand ( 1 , array ) ;
102358: LD_ADDR_VAR 0 4
102362: PUSH
102363: LD_INT 1
102365: PPUSH
102366: LD_VAR 0 1
102370: PPUSH
102371: CALL_OW 12
102375: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102376: LD_ADDR_VAR 0 2
102380: PUSH
102381: LD_VAR 0 2
102385: PPUSH
102386: LD_VAR 0 2
102390: PUSH
102391: LD_INT 1
102393: PLUS
102394: PPUSH
102395: LD_VAR 0 1
102399: PUSH
102400: LD_VAR 0 4
102404: ARRAY
102405: PPUSH
102406: CALL_OW 2
102410: ST_TO_ADDR
// array := Delete ( array , index ) ;
102411: LD_ADDR_VAR 0 1
102415: PUSH
102416: LD_VAR 0 1
102420: PPUSH
102421: LD_VAR 0 4
102425: PPUSH
102426: CALL_OW 3
102430: ST_TO_ADDR
// end ;
102431: GO 102355
102433: POP
102434: POP
// end ;
102435: LD_VAR 0 2
102439: RET
// export function GetBaseMaterials ( base ) ; begin
102440: LD_INT 0
102442: PPUSH
// result := [ 0 , 0 , 0 ] ;
102443: LD_ADDR_VAR 0 2
102447: PUSH
102448: LD_INT 0
102450: PUSH
102451: LD_INT 0
102453: PUSH
102454: LD_INT 0
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: LIST
102461: ST_TO_ADDR
// if not base then
102462: LD_VAR 0 1
102466: NOT
102467: IFFALSE 102471
// exit ;
102469: GO 102520
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102471: LD_ADDR_VAR 0 2
102475: PUSH
102476: LD_VAR 0 1
102480: PPUSH
102481: LD_INT 1
102483: PPUSH
102484: CALL_OW 275
102488: PUSH
102489: LD_VAR 0 1
102493: PPUSH
102494: LD_INT 2
102496: PPUSH
102497: CALL_OW 275
102501: PUSH
102502: LD_VAR 0 1
102506: PPUSH
102507: LD_INT 3
102509: PPUSH
102510: CALL_OW 275
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: LIST
102519: ST_TO_ADDR
// end ;
102520: LD_VAR 0 2
102524: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102525: LD_INT 0
102527: PPUSH
102528: PPUSH
// result := array ;
102529: LD_ADDR_VAR 0 3
102533: PUSH
102534: LD_VAR 0 1
102538: ST_TO_ADDR
// if size > 0 then
102539: LD_VAR 0 2
102543: PUSH
102544: LD_INT 0
102546: GREATER
102547: IFFALSE 102593
// for i := array downto size do
102549: LD_ADDR_VAR 0 4
102553: PUSH
102554: DOUBLE
102555: LD_VAR 0 1
102559: INC
102560: ST_TO_ADDR
102561: LD_VAR 0 2
102565: PUSH
102566: FOR_DOWNTO
102567: IFFALSE 102591
// result := Delete ( result , result ) ;
102569: LD_ADDR_VAR 0 3
102573: PUSH
102574: LD_VAR 0 3
102578: PPUSH
102579: LD_VAR 0 3
102583: PPUSH
102584: CALL_OW 3
102588: ST_TO_ADDR
102589: GO 102566
102591: POP
102592: POP
// end ;
102593: LD_VAR 0 3
102597: RET
// export function ComExit ( unit ) ; var tmp ; begin
102598: LD_INT 0
102600: PPUSH
102601: PPUSH
// if not IsInUnit ( unit ) then
102602: LD_VAR 0 1
102606: PPUSH
102607: CALL_OW 310
102611: NOT
102612: IFFALSE 102616
// exit ;
102614: GO 102676
// tmp := IsInUnit ( unit ) ;
102616: LD_ADDR_VAR 0 3
102620: PUSH
102621: LD_VAR 0 1
102625: PPUSH
102626: CALL_OW 310
102630: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102631: LD_VAR 0 3
102635: PPUSH
102636: CALL_OW 247
102640: PUSH
102641: LD_INT 2
102643: EQUAL
102644: IFFALSE 102657
// ComExitVehicle ( unit ) else
102646: LD_VAR 0 1
102650: PPUSH
102651: CALL_OW 121
102655: GO 102666
// ComExitBuilding ( unit ) ;
102657: LD_VAR 0 1
102661: PPUSH
102662: CALL_OW 122
// result := tmp ;
102666: LD_ADDR_VAR 0 2
102670: PUSH
102671: LD_VAR 0 3
102675: ST_TO_ADDR
// end ;
102676: LD_VAR 0 2
102680: RET
// export function ComExitAll ( units ) ; var i ; begin
102681: LD_INT 0
102683: PPUSH
102684: PPUSH
// if not units then
102685: LD_VAR 0 1
102689: NOT
102690: IFFALSE 102694
// exit ;
102692: GO 102720
// for i in units do
102694: LD_ADDR_VAR 0 3
102698: PUSH
102699: LD_VAR 0 1
102703: PUSH
102704: FOR_IN
102705: IFFALSE 102718
// ComExit ( i ) ;
102707: LD_VAR 0 3
102711: PPUSH
102712: CALL 102598 0 1
102716: GO 102704
102718: POP
102719: POP
// end ;
102720: LD_VAR 0 2
102724: RET
// export function ResetHc ; begin
102725: LD_INT 0
102727: PPUSH
// InitHc ;
102728: CALL_OW 19
// hc_importance := 0 ;
102732: LD_ADDR_OWVAR 32
102736: PUSH
102737: LD_INT 0
102739: ST_TO_ADDR
// end ;
102740: LD_VAR 0 1
102744: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102745: LD_INT 0
102747: PPUSH
102748: PPUSH
102749: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102750: LD_ADDR_VAR 0 6
102754: PUSH
102755: LD_VAR 0 1
102759: PUSH
102760: LD_VAR 0 3
102764: PLUS
102765: PUSH
102766: LD_INT 2
102768: DIV
102769: ST_TO_ADDR
// if _x < 0 then
102770: LD_VAR 0 6
102774: PUSH
102775: LD_INT 0
102777: LESS
102778: IFFALSE 102795
// _x := _x * - 1 ;
102780: LD_ADDR_VAR 0 6
102784: PUSH
102785: LD_VAR 0 6
102789: PUSH
102790: LD_INT 1
102792: NEG
102793: MUL
102794: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102795: LD_ADDR_VAR 0 7
102799: PUSH
102800: LD_VAR 0 2
102804: PUSH
102805: LD_VAR 0 4
102809: PLUS
102810: PUSH
102811: LD_INT 2
102813: DIV
102814: ST_TO_ADDR
// if _y < 0 then
102815: LD_VAR 0 7
102819: PUSH
102820: LD_INT 0
102822: LESS
102823: IFFALSE 102840
// _y := _y * - 1 ;
102825: LD_ADDR_VAR 0 7
102829: PUSH
102830: LD_VAR 0 7
102834: PUSH
102835: LD_INT 1
102837: NEG
102838: MUL
102839: ST_TO_ADDR
// result := [ _x , _y ] ;
102840: LD_ADDR_VAR 0 5
102844: PUSH
102845: LD_VAR 0 6
102849: PUSH
102850: LD_VAR 0 7
102854: PUSH
102855: EMPTY
102856: LIST
102857: LIST
102858: ST_TO_ADDR
// end ;
102859: LD_VAR 0 5
102863: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
102864: LD_INT 0
102866: PPUSH
102867: PPUSH
102868: PPUSH
102869: PPUSH
// task := GetTaskList ( unit ) ;
102870: LD_ADDR_VAR 0 7
102874: PUSH
102875: LD_VAR 0 1
102879: PPUSH
102880: CALL_OW 437
102884: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
102885: LD_VAR 0 7
102889: NOT
102890: PUSH
102891: LD_VAR 0 1
102895: PPUSH
102896: LD_VAR 0 2
102900: PPUSH
102901: CALL_OW 308
102905: NOT
102906: AND
102907: IFFALSE 102911
// exit ;
102909: GO 103029
// if IsInArea ( unit , area ) then
102911: LD_VAR 0 1
102915: PPUSH
102916: LD_VAR 0 2
102920: PPUSH
102921: CALL_OW 308
102925: IFFALSE 102943
// begin ComMoveToArea ( unit , goAway ) ;
102927: LD_VAR 0 1
102931: PPUSH
102932: LD_VAR 0 3
102936: PPUSH
102937: CALL_OW 113
// exit ;
102941: GO 103029
// end ; if task [ 1 ] [ 1 ] <> M then
102943: LD_VAR 0 7
102947: PUSH
102948: LD_INT 1
102950: ARRAY
102951: PUSH
102952: LD_INT 1
102954: ARRAY
102955: PUSH
102956: LD_STRING M
102958: NONEQUAL
102959: IFFALSE 102963
// exit ;
102961: GO 103029
// x := task [ 1 ] [ 2 ] ;
102963: LD_ADDR_VAR 0 5
102967: PUSH
102968: LD_VAR 0 7
102972: PUSH
102973: LD_INT 1
102975: ARRAY
102976: PUSH
102977: LD_INT 2
102979: ARRAY
102980: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
102981: LD_ADDR_VAR 0 6
102985: PUSH
102986: LD_VAR 0 7
102990: PUSH
102991: LD_INT 1
102993: ARRAY
102994: PUSH
102995: LD_INT 3
102997: ARRAY
102998: ST_TO_ADDR
// if InArea ( x , y , area ) then
102999: LD_VAR 0 5
103003: PPUSH
103004: LD_VAR 0 6
103008: PPUSH
103009: LD_VAR 0 2
103013: PPUSH
103014: CALL_OW 309
103018: IFFALSE 103029
// ComStop ( unit ) ;
103020: LD_VAR 0 1
103024: PPUSH
103025: CALL_OW 141
// end ;
103029: LD_VAR 0 4
103033: RET
// export function Abs ( value ) ; begin
103034: LD_INT 0
103036: PPUSH
// result := value ;
103037: LD_ADDR_VAR 0 2
103041: PUSH
103042: LD_VAR 0 1
103046: ST_TO_ADDR
// if value < 0 then
103047: LD_VAR 0 1
103051: PUSH
103052: LD_INT 0
103054: LESS
103055: IFFALSE 103072
// result := value * - 1 ;
103057: LD_ADDR_VAR 0 2
103061: PUSH
103062: LD_VAR 0 1
103066: PUSH
103067: LD_INT 1
103069: NEG
103070: MUL
103071: ST_TO_ADDR
// end ;
103072: LD_VAR 0 2
103076: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103077: LD_INT 0
103079: PPUSH
103080: PPUSH
103081: PPUSH
103082: PPUSH
103083: PPUSH
103084: PPUSH
103085: PPUSH
103086: PPUSH
// if not unit or not building then
103087: LD_VAR 0 1
103091: NOT
103092: PUSH
103093: LD_VAR 0 2
103097: NOT
103098: OR
103099: IFFALSE 103103
// exit ;
103101: GO 103329
// x := GetX ( building ) ;
103103: LD_ADDR_VAR 0 4
103107: PUSH
103108: LD_VAR 0 2
103112: PPUSH
103113: CALL_OW 250
103117: ST_TO_ADDR
// y := GetY ( building ) ;
103118: LD_ADDR_VAR 0 6
103122: PUSH
103123: LD_VAR 0 2
103127: PPUSH
103128: CALL_OW 251
103132: ST_TO_ADDR
// d := GetDir ( building ) ;
103133: LD_ADDR_VAR 0 8
103137: PUSH
103138: LD_VAR 0 2
103142: PPUSH
103143: CALL_OW 254
103147: ST_TO_ADDR
// r := 4 ;
103148: LD_ADDR_VAR 0 9
103152: PUSH
103153: LD_INT 4
103155: ST_TO_ADDR
// for i := 1 to 5 do
103156: LD_ADDR_VAR 0 10
103160: PUSH
103161: DOUBLE
103162: LD_INT 1
103164: DEC
103165: ST_TO_ADDR
103166: LD_INT 5
103168: PUSH
103169: FOR_TO
103170: IFFALSE 103327
// begin _x := ShiftX ( x , d , r + i ) ;
103172: LD_ADDR_VAR 0 5
103176: PUSH
103177: LD_VAR 0 4
103181: PPUSH
103182: LD_VAR 0 8
103186: PPUSH
103187: LD_VAR 0 9
103191: PUSH
103192: LD_VAR 0 10
103196: PLUS
103197: PPUSH
103198: CALL_OW 272
103202: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103203: LD_ADDR_VAR 0 7
103207: PUSH
103208: LD_VAR 0 6
103212: PPUSH
103213: LD_VAR 0 8
103217: PPUSH
103218: LD_VAR 0 9
103222: PUSH
103223: LD_VAR 0 10
103227: PLUS
103228: PPUSH
103229: CALL_OW 273
103233: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103234: LD_VAR 0 5
103238: PPUSH
103239: LD_VAR 0 7
103243: PPUSH
103244: CALL_OW 488
103248: PUSH
103249: LD_VAR 0 5
103253: PPUSH
103254: LD_VAR 0 7
103258: PPUSH
103259: CALL_OW 428
103263: PPUSH
103264: CALL_OW 247
103268: PUSH
103269: LD_INT 3
103271: PUSH
103272: LD_INT 2
103274: PUSH
103275: EMPTY
103276: LIST
103277: LIST
103278: IN
103279: NOT
103280: AND
103281: IFFALSE 103325
// begin ComMoveXY ( unit , _x , _y ) ;
103283: LD_VAR 0 1
103287: PPUSH
103288: LD_VAR 0 5
103292: PPUSH
103293: LD_VAR 0 7
103297: PPUSH
103298: CALL_OW 111
// result := [ _x , _y ] ;
103302: LD_ADDR_VAR 0 3
103306: PUSH
103307: LD_VAR 0 5
103311: PUSH
103312: LD_VAR 0 7
103316: PUSH
103317: EMPTY
103318: LIST
103319: LIST
103320: ST_TO_ADDR
// exit ;
103321: POP
103322: POP
103323: GO 103329
// end ; end ;
103325: GO 103169
103327: POP
103328: POP
// end ;
103329: LD_VAR 0 3
103333: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103334: LD_INT 0
103336: PPUSH
103337: PPUSH
103338: PPUSH
// result := 0 ;
103339: LD_ADDR_VAR 0 3
103343: PUSH
103344: LD_INT 0
103346: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103347: LD_VAR 0 1
103351: PUSH
103352: LD_INT 0
103354: LESS
103355: PUSH
103356: LD_VAR 0 1
103360: PUSH
103361: LD_INT 8
103363: GREATER
103364: OR
103365: PUSH
103366: LD_VAR 0 2
103370: PUSH
103371: LD_INT 0
103373: LESS
103374: OR
103375: PUSH
103376: LD_VAR 0 2
103380: PUSH
103381: LD_INT 8
103383: GREATER
103384: OR
103385: IFFALSE 103389
// exit ;
103387: GO 103464
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103389: LD_ADDR_VAR 0 4
103393: PUSH
103394: LD_INT 22
103396: PUSH
103397: LD_VAR 0 2
103401: PUSH
103402: EMPTY
103403: LIST
103404: LIST
103405: PPUSH
103406: CALL_OW 69
103410: PUSH
103411: FOR_IN
103412: IFFALSE 103462
// begin un := UnitShoot ( i ) ;
103414: LD_ADDR_VAR 0 5
103418: PUSH
103419: LD_VAR 0 4
103423: PPUSH
103424: CALL_OW 504
103428: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103429: LD_VAR 0 5
103433: PPUSH
103434: CALL_OW 255
103438: PUSH
103439: LD_VAR 0 1
103443: EQUAL
103444: IFFALSE 103460
// begin result := un ;
103446: LD_ADDR_VAR 0 3
103450: PUSH
103451: LD_VAR 0 5
103455: ST_TO_ADDR
// exit ;
103456: POP
103457: POP
103458: GO 103464
// end ; end ;
103460: GO 103411
103462: POP
103463: POP
// end ;
103464: LD_VAR 0 3
103468: RET
// export function GetCargoBay ( units ) ; begin
103469: LD_INT 0
103471: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103472: LD_ADDR_VAR 0 2
103476: PUSH
103477: LD_VAR 0 1
103481: PPUSH
103482: LD_INT 2
103484: PUSH
103485: LD_INT 34
103487: PUSH
103488: LD_INT 12
103490: PUSH
103491: EMPTY
103492: LIST
103493: LIST
103494: PUSH
103495: LD_INT 34
103497: PUSH
103498: LD_INT 51
103500: PUSH
103501: EMPTY
103502: LIST
103503: LIST
103504: PUSH
103505: LD_INT 34
103507: PUSH
103508: LD_INT 32
103510: PUSH
103511: EMPTY
103512: LIST
103513: LIST
103514: PUSH
103515: LD_INT 34
103517: PUSH
103518: LD_EXP 96
103522: PUSH
103523: EMPTY
103524: LIST
103525: LIST
103526: PUSH
103527: EMPTY
103528: LIST
103529: LIST
103530: LIST
103531: LIST
103532: LIST
103533: PPUSH
103534: CALL_OW 72
103538: ST_TO_ADDR
// end ;
103539: LD_VAR 0 2
103543: RET
// export function Negate ( value ) ; begin
103544: LD_INT 0
103546: PPUSH
// result := not value ;
103547: LD_ADDR_VAR 0 2
103551: PUSH
103552: LD_VAR 0 1
103556: NOT
103557: ST_TO_ADDR
// end ;
103558: LD_VAR 0 2
103562: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
103563: LD_INT 0
103565: PPUSH
// if x1 = x2 then
103566: LD_VAR 0 1
103570: PUSH
103571: LD_VAR 0 3
103575: EQUAL
103576: IFFALSE 103610
// begin if y1 > y2 then
103578: LD_VAR 0 2
103582: PUSH
103583: LD_VAR 0 4
103587: GREATER
103588: IFFALSE 103600
// result := 0 else
103590: LD_ADDR_VAR 0 5
103594: PUSH
103595: LD_INT 0
103597: ST_TO_ADDR
103598: GO 103608
// result := 3 ;
103600: LD_ADDR_VAR 0 5
103604: PUSH
103605: LD_INT 3
103607: ST_TO_ADDR
// exit ;
103608: GO 103696
// end ; if y1 = y2 then
103610: LD_VAR 0 2
103614: PUSH
103615: LD_VAR 0 4
103619: EQUAL
103620: IFFALSE 103654
// begin if x1 > x2 then
103622: LD_VAR 0 1
103626: PUSH
103627: LD_VAR 0 3
103631: GREATER
103632: IFFALSE 103644
// result := 1 else
103634: LD_ADDR_VAR 0 5
103638: PUSH
103639: LD_INT 1
103641: ST_TO_ADDR
103642: GO 103652
// result := 4 ;
103644: LD_ADDR_VAR 0 5
103648: PUSH
103649: LD_INT 4
103651: ST_TO_ADDR
// exit ;
103652: GO 103696
// end ; if x1 > x2 and y1 > y2 then
103654: LD_VAR 0 1
103658: PUSH
103659: LD_VAR 0 3
103663: GREATER
103664: PUSH
103665: LD_VAR 0 2
103669: PUSH
103670: LD_VAR 0 4
103674: GREATER
103675: AND
103676: IFFALSE 103688
// result := 2 else
103678: LD_ADDR_VAR 0 5
103682: PUSH
103683: LD_INT 2
103685: ST_TO_ADDR
103686: GO 103696
// result := 5 ;
103688: LD_ADDR_VAR 0 5
103692: PUSH
103693: LD_INT 5
103695: ST_TO_ADDR
// end ;
103696: LD_VAR 0 5
103700: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103701: LD_INT 0
103703: PPUSH
103704: PPUSH
// if not driver or not IsInUnit ( driver ) then
103705: LD_VAR 0 1
103709: NOT
103710: PUSH
103711: LD_VAR 0 1
103715: PPUSH
103716: CALL_OW 310
103720: NOT
103721: OR
103722: IFFALSE 103726
// exit ;
103724: GO 103816
// vehicle := IsInUnit ( driver ) ;
103726: LD_ADDR_VAR 0 3
103730: PUSH
103731: LD_VAR 0 1
103735: PPUSH
103736: CALL_OW 310
103740: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103741: LD_VAR 0 1
103745: PPUSH
103746: LD_STRING \
103748: PUSH
103749: LD_INT 0
103751: PUSH
103752: LD_INT 0
103754: PUSH
103755: LD_INT 0
103757: PUSH
103758: LD_INT 0
103760: PUSH
103761: LD_INT 0
103763: PUSH
103764: LD_INT 0
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: LIST
103771: LIST
103772: LIST
103773: LIST
103774: LIST
103775: PUSH
103776: LD_STRING E
103778: PUSH
103779: LD_INT 0
103781: PUSH
103782: LD_INT 0
103784: PUSH
103785: LD_VAR 0 3
103789: PUSH
103790: LD_INT 0
103792: PUSH
103793: LD_INT 0
103795: PUSH
103796: LD_INT 0
103798: PUSH
103799: EMPTY
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: PUSH
103808: EMPTY
103809: LIST
103810: LIST
103811: PPUSH
103812: CALL_OW 446
// end ;
103816: LD_VAR 0 2
103820: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
103821: LD_INT 0
103823: PPUSH
103824: PPUSH
103825: PPUSH
// tmp := [ ] ;
103826: LD_ADDR_VAR 0 5
103830: PUSH
103831: EMPTY
103832: ST_TO_ADDR
// for i in units do
103833: LD_ADDR_VAR 0 4
103837: PUSH
103838: LD_VAR 0 1
103842: PUSH
103843: FOR_IN
103844: IFFALSE 103882
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
103846: LD_ADDR_VAR 0 5
103850: PUSH
103851: LD_VAR 0 5
103855: PPUSH
103856: LD_VAR 0 5
103860: PUSH
103861: LD_INT 1
103863: PLUS
103864: PPUSH
103865: LD_VAR 0 4
103869: PPUSH
103870: CALL_OW 256
103874: PPUSH
103875: CALL_OW 2
103879: ST_TO_ADDR
103880: GO 103843
103882: POP
103883: POP
// if not tmp then
103884: LD_VAR 0 5
103888: NOT
103889: IFFALSE 103893
// exit ;
103891: GO 103941
// if asc then
103893: LD_VAR 0 2
103897: IFFALSE 103921
// result := SortListByListAsc ( units , tmp ) else
103899: LD_ADDR_VAR 0 3
103903: PUSH
103904: LD_VAR 0 1
103908: PPUSH
103909: LD_VAR 0 5
103913: PPUSH
103914: CALL_OW 76
103918: ST_TO_ADDR
103919: GO 103941
// result := SortListByListDesc ( units , tmp ) ;
103921: LD_ADDR_VAR 0 3
103925: PUSH
103926: LD_VAR 0 1
103930: PPUSH
103931: LD_VAR 0 5
103935: PPUSH
103936: CALL_OW 77
103940: ST_TO_ADDR
// end ; end_of_file end_of_file
103941: LD_VAR 0 3
103945: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103946: LD_INT 0
103948: PPUSH
// if p2 = 100 then
103949: LD_VAR 0 2
103953: PUSH
103954: LD_INT 100
103956: EQUAL
103957: IFFALSE 104906
// begin if not StreamModeActive then
103959: LD_EXP 160
103963: NOT
103964: IFFALSE 103974
// StreamModeActive := true ;
103966: LD_ADDR_EXP 160
103970: PUSH
103971: LD_INT 1
103973: ST_TO_ADDR
// if p3 = 0 then
103974: LD_VAR 0 3
103978: PUSH
103979: LD_INT 0
103981: EQUAL
103982: IFFALSE 103988
// InitStreamMode ;
103984: CALL 105066 0 0
// if p3 = 1 then
103988: LD_VAR 0 3
103992: PUSH
103993: LD_INT 1
103995: EQUAL
103996: IFFALSE 104006
// sRocket := true ;
103998: LD_ADDR_EXP 165
104002: PUSH
104003: LD_INT 1
104005: ST_TO_ADDR
// if p3 = 2 then
104006: LD_VAR 0 3
104010: PUSH
104011: LD_INT 2
104013: EQUAL
104014: IFFALSE 104024
// sSpeed := true ;
104016: LD_ADDR_EXP 164
104020: PUSH
104021: LD_INT 1
104023: ST_TO_ADDR
// if p3 = 3 then
104024: LD_VAR 0 3
104028: PUSH
104029: LD_INT 3
104031: EQUAL
104032: IFFALSE 104042
// sEngine := true ;
104034: LD_ADDR_EXP 166
104038: PUSH
104039: LD_INT 1
104041: ST_TO_ADDR
// if p3 = 4 then
104042: LD_VAR 0 3
104046: PUSH
104047: LD_INT 4
104049: EQUAL
104050: IFFALSE 104060
// sSpec := true ;
104052: LD_ADDR_EXP 163
104056: PUSH
104057: LD_INT 1
104059: ST_TO_ADDR
// if p3 = 5 then
104060: LD_VAR 0 3
104064: PUSH
104065: LD_INT 5
104067: EQUAL
104068: IFFALSE 104078
// sLevel := true ;
104070: LD_ADDR_EXP 167
104074: PUSH
104075: LD_INT 1
104077: ST_TO_ADDR
// if p3 = 6 then
104078: LD_VAR 0 3
104082: PUSH
104083: LD_INT 6
104085: EQUAL
104086: IFFALSE 104096
// sArmoury := true ;
104088: LD_ADDR_EXP 168
104092: PUSH
104093: LD_INT 1
104095: ST_TO_ADDR
// if p3 = 7 then
104096: LD_VAR 0 3
104100: PUSH
104101: LD_INT 7
104103: EQUAL
104104: IFFALSE 104114
// sRadar := true ;
104106: LD_ADDR_EXP 169
104110: PUSH
104111: LD_INT 1
104113: ST_TO_ADDR
// if p3 = 8 then
104114: LD_VAR 0 3
104118: PUSH
104119: LD_INT 8
104121: EQUAL
104122: IFFALSE 104132
// sBunker := true ;
104124: LD_ADDR_EXP 170
104128: PUSH
104129: LD_INT 1
104131: ST_TO_ADDR
// if p3 = 9 then
104132: LD_VAR 0 3
104136: PUSH
104137: LD_INT 9
104139: EQUAL
104140: IFFALSE 104150
// sHack := true ;
104142: LD_ADDR_EXP 171
104146: PUSH
104147: LD_INT 1
104149: ST_TO_ADDR
// if p3 = 10 then
104150: LD_VAR 0 3
104154: PUSH
104155: LD_INT 10
104157: EQUAL
104158: IFFALSE 104168
// sFire := true ;
104160: LD_ADDR_EXP 172
104164: PUSH
104165: LD_INT 1
104167: ST_TO_ADDR
// if p3 = 11 then
104168: LD_VAR 0 3
104172: PUSH
104173: LD_INT 11
104175: EQUAL
104176: IFFALSE 104186
// sRefresh := true ;
104178: LD_ADDR_EXP 173
104182: PUSH
104183: LD_INT 1
104185: ST_TO_ADDR
// if p3 = 12 then
104186: LD_VAR 0 3
104190: PUSH
104191: LD_INT 12
104193: EQUAL
104194: IFFALSE 104204
// sExp := true ;
104196: LD_ADDR_EXP 174
104200: PUSH
104201: LD_INT 1
104203: ST_TO_ADDR
// if p3 = 13 then
104204: LD_VAR 0 3
104208: PUSH
104209: LD_INT 13
104211: EQUAL
104212: IFFALSE 104222
// sDepot := true ;
104214: LD_ADDR_EXP 175
104218: PUSH
104219: LD_INT 1
104221: ST_TO_ADDR
// if p3 = 14 then
104222: LD_VAR 0 3
104226: PUSH
104227: LD_INT 14
104229: EQUAL
104230: IFFALSE 104240
// sFlag := true ;
104232: LD_ADDR_EXP 176
104236: PUSH
104237: LD_INT 1
104239: ST_TO_ADDR
// if p3 = 15 then
104240: LD_VAR 0 3
104244: PUSH
104245: LD_INT 15
104247: EQUAL
104248: IFFALSE 104258
// sKamikadze := true ;
104250: LD_ADDR_EXP 184
104254: PUSH
104255: LD_INT 1
104257: ST_TO_ADDR
// if p3 = 16 then
104258: LD_VAR 0 3
104262: PUSH
104263: LD_INT 16
104265: EQUAL
104266: IFFALSE 104276
// sTroll := true ;
104268: LD_ADDR_EXP 185
104272: PUSH
104273: LD_INT 1
104275: ST_TO_ADDR
// if p3 = 17 then
104276: LD_VAR 0 3
104280: PUSH
104281: LD_INT 17
104283: EQUAL
104284: IFFALSE 104294
// sSlow := true ;
104286: LD_ADDR_EXP 186
104290: PUSH
104291: LD_INT 1
104293: ST_TO_ADDR
// if p3 = 18 then
104294: LD_VAR 0 3
104298: PUSH
104299: LD_INT 18
104301: EQUAL
104302: IFFALSE 104312
// sLack := true ;
104304: LD_ADDR_EXP 187
104308: PUSH
104309: LD_INT 1
104311: ST_TO_ADDR
// if p3 = 19 then
104312: LD_VAR 0 3
104316: PUSH
104317: LD_INT 19
104319: EQUAL
104320: IFFALSE 104330
// sTank := true ;
104322: LD_ADDR_EXP 189
104326: PUSH
104327: LD_INT 1
104329: ST_TO_ADDR
// if p3 = 20 then
104330: LD_VAR 0 3
104334: PUSH
104335: LD_INT 20
104337: EQUAL
104338: IFFALSE 104348
// sRemote := true ;
104340: LD_ADDR_EXP 190
104344: PUSH
104345: LD_INT 1
104347: ST_TO_ADDR
// if p3 = 21 then
104348: LD_VAR 0 3
104352: PUSH
104353: LD_INT 21
104355: EQUAL
104356: IFFALSE 104366
// sPowell := true ;
104358: LD_ADDR_EXP 191
104362: PUSH
104363: LD_INT 1
104365: ST_TO_ADDR
// if p3 = 22 then
104366: LD_VAR 0 3
104370: PUSH
104371: LD_INT 22
104373: EQUAL
104374: IFFALSE 104384
// sTeleport := true ;
104376: LD_ADDR_EXP 194
104380: PUSH
104381: LD_INT 1
104383: ST_TO_ADDR
// if p3 = 23 then
104384: LD_VAR 0 3
104388: PUSH
104389: LD_INT 23
104391: EQUAL
104392: IFFALSE 104402
// sOilTower := true ;
104394: LD_ADDR_EXP 196
104398: PUSH
104399: LD_INT 1
104401: ST_TO_ADDR
// if p3 = 24 then
104402: LD_VAR 0 3
104406: PUSH
104407: LD_INT 24
104409: EQUAL
104410: IFFALSE 104420
// sShovel := true ;
104412: LD_ADDR_EXP 197
104416: PUSH
104417: LD_INT 1
104419: ST_TO_ADDR
// if p3 = 25 then
104420: LD_VAR 0 3
104424: PUSH
104425: LD_INT 25
104427: EQUAL
104428: IFFALSE 104438
// sSheik := true ;
104430: LD_ADDR_EXP 198
104434: PUSH
104435: LD_INT 1
104437: ST_TO_ADDR
// if p3 = 26 then
104438: LD_VAR 0 3
104442: PUSH
104443: LD_INT 26
104445: EQUAL
104446: IFFALSE 104456
// sEarthquake := true ;
104448: LD_ADDR_EXP 200
104452: PUSH
104453: LD_INT 1
104455: ST_TO_ADDR
// if p3 = 27 then
104456: LD_VAR 0 3
104460: PUSH
104461: LD_INT 27
104463: EQUAL
104464: IFFALSE 104474
// sAI := true ;
104466: LD_ADDR_EXP 201
104470: PUSH
104471: LD_INT 1
104473: ST_TO_ADDR
// if p3 = 28 then
104474: LD_VAR 0 3
104478: PUSH
104479: LD_INT 28
104481: EQUAL
104482: IFFALSE 104492
// sCargo := true ;
104484: LD_ADDR_EXP 204
104488: PUSH
104489: LD_INT 1
104491: ST_TO_ADDR
// if p3 = 29 then
104492: LD_VAR 0 3
104496: PUSH
104497: LD_INT 29
104499: EQUAL
104500: IFFALSE 104510
// sDLaser := true ;
104502: LD_ADDR_EXP 205
104506: PUSH
104507: LD_INT 1
104509: ST_TO_ADDR
// if p3 = 30 then
104510: LD_VAR 0 3
104514: PUSH
104515: LD_INT 30
104517: EQUAL
104518: IFFALSE 104528
// sExchange := true ;
104520: LD_ADDR_EXP 206
104524: PUSH
104525: LD_INT 1
104527: ST_TO_ADDR
// if p3 = 31 then
104528: LD_VAR 0 3
104532: PUSH
104533: LD_INT 31
104535: EQUAL
104536: IFFALSE 104546
// sFac := true ;
104538: LD_ADDR_EXP 207
104542: PUSH
104543: LD_INT 1
104545: ST_TO_ADDR
// if p3 = 32 then
104546: LD_VAR 0 3
104550: PUSH
104551: LD_INT 32
104553: EQUAL
104554: IFFALSE 104564
// sPower := true ;
104556: LD_ADDR_EXP 208
104560: PUSH
104561: LD_INT 1
104563: ST_TO_ADDR
// if p3 = 33 then
104564: LD_VAR 0 3
104568: PUSH
104569: LD_INT 33
104571: EQUAL
104572: IFFALSE 104582
// sRandom := true ;
104574: LD_ADDR_EXP 209
104578: PUSH
104579: LD_INT 1
104581: ST_TO_ADDR
// if p3 = 34 then
104582: LD_VAR 0 3
104586: PUSH
104587: LD_INT 34
104589: EQUAL
104590: IFFALSE 104600
// sShield := true ;
104592: LD_ADDR_EXP 210
104596: PUSH
104597: LD_INT 1
104599: ST_TO_ADDR
// if p3 = 35 then
104600: LD_VAR 0 3
104604: PUSH
104605: LD_INT 35
104607: EQUAL
104608: IFFALSE 104618
// sTime := true ;
104610: LD_ADDR_EXP 211
104614: PUSH
104615: LD_INT 1
104617: ST_TO_ADDR
// if p3 = 36 then
104618: LD_VAR 0 3
104622: PUSH
104623: LD_INT 36
104625: EQUAL
104626: IFFALSE 104636
// sTools := true ;
104628: LD_ADDR_EXP 212
104632: PUSH
104633: LD_INT 1
104635: ST_TO_ADDR
// if p3 = 101 then
104636: LD_VAR 0 3
104640: PUSH
104641: LD_INT 101
104643: EQUAL
104644: IFFALSE 104654
// sSold := true ;
104646: LD_ADDR_EXP 177
104650: PUSH
104651: LD_INT 1
104653: ST_TO_ADDR
// if p3 = 102 then
104654: LD_VAR 0 3
104658: PUSH
104659: LD_INT 102
104661: EQUAL
104662: IFFALSE 104672
// sDiff := true ;
104664: LD_ADDR_EXP 178
104668: PUSH
104669: LD_INT 1
104671: ST_TO_ADDR
// if p3 = 103 then
104672: LD_VAR 0 3
104676: PUSH
104677: LD_INT 103
104679: EQUAL
104680: IFFALSE 104690
// sFog := true ;
104682: LD_ADDR_EXP 181
104686: PUSH
104687: LD_INT 1
104689: ST_TO_ADDR
// if p3 = 104 then
104690: LD_VAR 0 3
104694: PUSH
104695: LD_INT 104
104697: EQUAL
104698: IFFALSE 104708
// sReset := true ;
104700: LD_ADDR_EXP 182
104704: PUSH
104705: LD_INT 1
104707: ST_TO_ADDR
// if p3 = 105 then
104708: LD_VAR 0 3
104712: PUSH
104713: LD_INT 105
104715: EQUAL
104716: IFFALSE 104726
// sSun := true ;
104718: LD_ADDR_EXP 183
104722: PUSH
104723: LD_INT 1
104725: ST_TO_ADDR
// if p3 = 106 then
104726: LD_VAR 0 3
104730: PUSH
104731: LD_INT 106
104733: EQUAL
104734: IFFALSE 104744
// sTiger := true ;
104736: LD_ADDR_EXP 179
104740: PUSH
104741: LD_INT 1
104743: ST_TO_ADDR
// if p3 = 107 then
104744: LD_VAR 0 3
104748: PUSH
104749: LD_INT 107
104751: EQUAL
104752: IFFALSE 104762
// sBomb := true ;
104754: LD_ADDR_EXP 180
104758: PUSH
104759: LD_INT 1
104761: ST_TO_ADDR
// if p3 = 108 then
104762: LD_VAR 0 3
104766: PUSH
104767: LD_INT 108
104769: EQUAL
104770: IFFALSE 104780
// sWound := true ;
104772: LD_ADDR_EXP 188
104776: PUSH
104777: LD_INT 1
104779: ST_TO_ADDR
// if p3 = 109 then
104780: LD_VAR 0 3
104784: PUSH
104785: LD_INT 109
104787: EQUAL
104788: IFFALSE 104798
// sBetray := true ;
104790: LD_ADDR_EXP 192
104794: PUSH
104795: LD_INT 1
104797: ST_TO_ADDR
// if p3 = 110 then
104798: LD_VAR 0 3
104802: PUSH
104803: LD_INT 110
104805: EQUAL
104806: IFFALSE 104816
// sContamin := true ;
104808: LD_ADDR_EXP 193
104812: PUSH
104813: LD_INT 1
104815: ST_TO_ADDR
// if p3 = 111 then
104816: LD_VAR 0 3
104820: PUSH
104821: LD_INT 111
104823: EQUAL
104824: IFFALSE 104834
// sOil := true ;
104826: LD_ADDR_EXP 195
104830: PUSH
104831: LD_INT 1
104833: ST_TO_ADDR
// if p3 = 112 then
104834: LD_VAR 0 3
104838: PUSH
104839: LD_INT 112
104841: EQUAL
104842: IFFALSE 104852
// sStu := true ;
104844: LD_ADDR_EXP 199
104848: PUSH
104849: LD_INT 1
104851: ST_TO_ADDR
// if p3 = 113 then
104852: LD_VAR 0 3
104856: PUSH
104857: LD_INT 113
104859: EQUAL
104860: IFFALSE 104870
// sBazooka := true ;
104862: LD_ADDR_EXP 202
104866: PUSH
104867: LD_INT 1
104869: ST_TO_ADDR
// if p3 = 114 then
104870: LD_VAR 0 3
104874: PUSH
104875: LD_INT 114
104877: EQUAL
104878: IFFALSE 104888
// sMortar := true ;
104880: LD_ADDR_EXP 203
104884: PUSH
104885: LD_INT 1
104887: ST_TO_ADDR
// if p3 = 115 then
104888: LD_VAR 0 3
104892: PUSH
104893: LD_INT 115
104895: EQUAL
104896: IFFALSE 104906
// sRanger := true ;
104898: LD_ADDR_EXP 213
104902: PUSH
104903: LD_INT 1
104905: ST_TO_ADDR
// end ; if p2 = 101 then
104906: LD_VAR 0 2
104910: PUSH
104911: LD_INT 101
104913: EQUAL
104914: IFFALSE 105042
// begin case p3 of 1 :
104916: LD_VAR 0 3
104920: PUSH
104921: LD_INT 1
104923: DOUBLE
104924: EQUAL
104925: IFTRUE 104929
104927: GO 104936
104929: POP
// hHackUnlimitedResources ; 2 :
104930: CALL 116079 0 0
104934: GO 105042
104936: LD_INT 2
104938: DOUBLE
104939: EQUAL
104940: IFTRUE 104944
104942: GO 104951
104944: POP
// hHackSetLevel10 ; 3 :
104945: CALL 116212 0 0
104949: GO 105042
104951: LD_INT 3
104953: DOUBLE
104954: EQUAL
104955: IFTRUE 104959
104957: GO 104966
104959: POP
// hHackSetLevel10YourUnits ; 4 :
104960: CALL 116297 0 0
104964: GO 105042
104966: LD_INT 4
104968: DOUBLE
104969: EQUAL
104970: IFTRUE 104974
104972: GO 104981
104974: POP
// hHackInvincible ; 5 :
104975: CALL 116745 0 0
104979: GO 105042
104981: LD_INT 5
104983: DOUBLE
104984: EQUAL
104985: IFTRUE 104989
104987: GO 104996
104989: POP
// hHackInvisible ; 6 :
104990: CALL 116856 0 0
104994: GO 105042
104996: LD_INT 6
104998: DOUBLE
104999: EQUAL
105000: IFTRUE 105004
105002: GO 105011
105004: POP
// hHackChangeYourSide ; 7 :
105005: CALL 116913 0 0
105009: GO 105042
105011: LD_INT 7
105013: DOUBLE
105014: EQUAL
105015: IFTRUE 105019
105017: GO 105026
105019: POP
// hHackChangeUnitSide ; 8 :
105020: CALL 116955 0 0
105024: GO 105042
105026: LD_INT 8
105028: DOUBLE
105029: EQUAL
105030: IFTRUE 105034
105032: GO 105041
105034: POP
// hHackFog ; end ;
105035: CALL 117056 0 0
105039: GO 105042
105041: POP
// end ; end ;
105042: LD_VAR 0 7
105046: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
105047: GO 105049
105049: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
105050: LD_STRING initStreamRollete();
105052: PPUSH
105053: CALL_OW 559
// InitStreamMode ;
105057: CALL 105066 0 0
// DefineStreamItems ( ) ;
105061: CALL 105506 0 0
// end ;
105065: END
// function InitStreamMode ; begin
105066: LD_INT 0
105068: PPUSH
// streamModeActive := false ;
105069: LD_ADDR_EXP 160
105073: PUSH
105074: LD_INT 0
105076: ST_TO_ADDR
// normalCounter := 36 ;
105077: LD_ADDR_EXP 161
105081: PUSH
105082: LD_INT 36
105084: ST_TO_ADDR
// hardcoreCounter := 16 ;
105085: LD_ADDR_EXP 162
105089: PUSH
105090: LD_INT 16
105092: ST_TO_ADDR
// sRocket := false ;
105093: LD_ADDR_EXP 165
105097: PUSH
105098: LD_INT 0
105100: ST_TO_ADDR
// sSpeed := false ;
105101: LD_ADDR_EXP 164
105105: PUSH
105106: LD_INT 0
105108: ST_TO_ADDR
// sEngine := false ;
105109: LD_ADDR_EXP 166
105113: PUSH
105114: LD_INT 0
105116: ST_TO_ADDR
// sSpec := false ;
105117: LD_ADDR_EXP 163
105121: PUSH
105122: LD_INT 0
105124: ST_TO_ADDR
// sLevel := false ;
105125: LD_ADDR_EXP 167
105129: PUSH
105130: LD_INT 0
105132: ST_TO_ADDR
// sArmoury := false ;
105133: LD_ADDR_EXP 168
105137: PUSH
105138: LD_INT 0
105140: ST_TO_ADDR
// sRadar := false ;
105141: LD_ADDR_EXP 169
105145: PUSH
105146: LD_INT 0
105148: ST_TO_ADDR
// sBunker := false ;
105149: LD_ADDR_EXP 170
105153: PUSH
105154: LD_INT 0
105156: ST_TO_ADDR
// sHack := false ;
105157: LD_ADDR_EXP 171
105161: PUSH
105162: LD_INT 0
105164: ST_TO_ADDR
// sFire := false ;
105165: LD_ADDR_EXP 172
105169: PUSH
105170: LD_INT 0
105172: ST_TO_ADDR
// sRefresh := false ;
105173: LD_ADDR_EXP 173
105177: PUSH
105178: LD_INT 0
105180: ST_TO_ADDR
// sExp := false ;
105181: LD_ADDR_EXP 174
105185: PUSH
105186: LD_INT 0
105188: ST_TO_ADDR
// sDepot := false ;
105189: LD_ADDR_EXP 175
105193: PUSH
105194: LD_INT 0
105196: ST_TO_ADDR
// sFlag := false ;
105197: LD_ADDR_EXP 176
105201: PUSH
105202: LD_INT 0
105204: ST_TO_ADDR
// sKamikadze := false ;
105205: LD_ADDR_EXP 184
105209: PUSH
105210: LD_INT 0
105212: ST_TO_ADDR
// sTroll := false ;
105213: LD_ADDR_EXP 185
105217: PUSH
105218: LD_INT 0
105220: ST_TO_ADDR
// sSlow := false ;
105221: LD_ADDR_EXP 186
105225: PUSH
105226: LD_INT 0
105228: ST_TO_ADDR
// sLack := false ;
105229: LD_ADDR_EXP 187
105233: PUSH
105234: LD_INT 0
105236: ST_TO_ADDR
// sTank := false ;
105237: LD_ADDR_EXP 189
105241: PUSH
105242: LD_INT 0
105244: ST_TO_ADDR
// sRemote := false ;
105245: LD_ADDR_EXP 190
105249: PUSH
105250: LD_INT 0
105252: ST_TO_ADDR
// sPowell := false ;
105253: LD_ADDR_EXP 191
105257: PUSH
105258: LD_INT 0
105260: ST_TO_ADDR
// sTeleport := false ;
105261: LD_ADDR_EXP 194
105265: PUSH
105266: LD_INT 0
105268: ST_TO_ADDR
// sOilTower := false ;
105269: LD_ADDR_EXP 196
105273: PUSH
105274: LD_INT 0
105276: ST_TO_ADDR
// sShovel := false ;
105277: LD_ADDR_EXP 197
105281: PUSH
105282: LD_INT 0
105284: ST_TO_ADDR
// sSheik := false ;
105285: LD_ADDR_EXP 198
105289: PUSH
105290: LD_INT 0
105292: ST_TO_ADDR
// sEarthquake := false ;
105293: LD_ADDR_EXP 200
105297: PUSH
105298: LD_INT 0
105300: ST_TO_ADDR
// sAI := false ;
105301: LD_ADDR_EXP 201
105305: PUSH
105306: LD_INT 0
105308: ST_TO_ADDR
// sCargo := false ;
105309: LD_ADDR_EXP 204
105313: PUSH
105314: LD_INT 0
105316: ST_TO_ADDR
// sDLaser := false ;
105317: LD_ADDR_EXP 205
105321: PUSH
105322: LD_INT 0
105324: ST_TO_ADDR
// sExchange := false ;
105325: LD_ADDR_EXP 206
105329: PUSH
105330: LD_INT 0
105332: ST_TO_ADDR
// sFac := false ;
105333: LD_ADDR_EXP 207
105337: PUSH
105338: LD_INT 0
105340: ST_TO_ADDR
// sPower := false ;
105341: LD_ADDR_EXP 208
105345: PUSH
105346: LD_INT 0
105348: ST_TO_ADDR
// sRandom := false ;
105349: LD_ADDR_EXP 209
105353: PUSH
105354: LD_INT 0
105356: ST_TO_ADDR
// sShield := false ;
105357: LD_ADDR_EXP 210
105361: PUSH
105362: LD_INT 0
105364: ST_TO_ADDR
// sTime := false ;
105365: LD_ADDR_EXP 211
105369: PUSH
105370: LD_INT 0
105372: ST_TO_ADDR
// sTools := false ;
105373: LD_ADDR_EXP 212
105377: PUSH
105378: LD_INT 0
105380: ST_TO_ADDR
// sSold := false ;
105381: LD_ADDR_EXP 177
105385: PUSH
105386: LD_INT 0
105388: ST_TO_ADDR
// sDiff := false ;
105389: LD_ADDR_EXP 178
105393: PUSH
105394: LD_INT 0
105396: ST_TO_ADDR
// sFog := false ;
105397: LD_ADDR_EXP 181
105401: PUSH
105402: LD_INT 0
105404: ST_TO_ADDR
// sReset := false ;
105405: LD_ADDR_EXP 182
105409: PUSH
105410: LD_INT 0
105412: ST_TO_ADDR
// sSun := false ;
105413: LD_ADDR_EXP 183
105417: PUSH
105418: LD_INT 0
105420: ST_TO_ADDR
// sTiger := false ;
105421: LD_ADDR_EXP 179
105425: PUSH
105426: LD_INT 0
105428: ST_TO_ADDR
// sBomb := false ;
105429: LD_ADDR_EXP 180
105433: PUSH
105434: LD_INT 0
105436: ST_TO_ADDR
// sWound := false ;
105437: LD_ADDR_EXP 188
105441: PUSH
105442: LD_INT 0
105444: ST_TO_ADDR
// sBetray := false ;
105445: LD_ADDR_EXP 192
105449: PUSH
105450: LD_INT 0
105452: ST_TO_ADDR
// sContamin := false ;
105453: LD_ADDR_EXP 193
105457: PUSH
105458: LD_INT 0
105460: ST_TO_ADDR
// sOil := false ;
105461: LD_ADDR_EXP 195
105465: PUSH
105466: LD_INT 0
105468: ST_TO_ADDR
// sStu := false ;
105469: LD_ADDR_EXP 199
105473: PUSH
105474: LD_INT 0
105476: ST_TO_ADDR
// sBazooka := false ;
105477: LD_ADDR_EXP 202
105481: PUSH
105482: LD_INT 0
105484: ST_TO_ADDR
// sMortar := false ;
105485: LD_ADDR_EXP 203
105489: PUSH
105490: LD_INT 0
105492: ST_TO_ADDR
// sRanger := false ;
105493: LD_ADDR_EXP 213
105497: PUSH
105498: LD_INT 0
105500: ST_TO_ADDR
// end ;
105501: LD_VAR 0 1
105505: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
105506: LD_INT 0
105508: PPUSH
105509: PPUSH
105510: PPUSH
105511: PPUSH
105512: PPUSH
// result := [ ] ;
105513: LD_ADDR_VAR 0 1
105517: PUSH
105518: EMPTY
105519: ST_TO_ADDR
// if campaign_id = 1 then
105520: LD_OWVAR 69
105524: PUSH
105525: LD_INT 1
105527: EQUAL
105528: IFFALSE 108466
// begin case mission_number of 1 :
105530: LD_OWVAR 70
105534: PUSH
105535: LD_INT 1
105537: DOUBLE
105538: EQUAL
105539: IFTRUE 105543
105541: GO 105607
105543: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
105544: LD_ADDR_VAR 0 1
105548: PUSH
105549: LD_INT 2
105551: PUSH
105552: LD_INT 4
105554: PUSH
105555: LD_INT 11
105557: PUSH
105558: LD_INT 12
105560: PUSH
105561: LD_INT 15
105563: PUSH
105564: LD_INT 16
105566: PUSH
105567: LD_INT 22
105569: PUSH
105570: LD_INT 23
105572: PUSH
105573: LD_INT 26
105575: PUSH
105576: EMPTY
105577: LIST
105578: LIST
105579: LIST
105580: LIST
105581: LIST
105582: LIST
105583: LIST
105584: LIST
105585: LIST
105586: PUSH
105587: LD_INT 101
105589: PUSH
105590: LD_INT 102
105592: PUSH
105593: LD_INT 106
105595: PUSH
105596: EMPTY
105597: LIST
105598: LIST
105599: LIST
105600: PUSH
105601: EMPTY
105602: LIST
105603: LIST
105604: ST_TO_ADDR
105605: GO 108464
105607: LD_INT 2
105609: DOUBLE
105610: EQUAL
105611: IFTRUE 105615
105613: GO 105687
105615: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
105616: LD_ADDR_VAR 0 1
105620: PUSH
105621: LD_INT 2
105623: PUSH
105624: LD_INT 4
105626: PUSH
105627: LD_INT 11
105629: PUSH
105630: LD_INT 12
105632: PUSH
105633: LD_INT 15
105635: PUSH
105636: LD_INT 16
105638: PUSH
105639: LD_INT 22
105641: PUSH
105642: LD_INT 23
105644: PUSH
105645: LD_INT 26
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: LIST
105652: LIST
105653: LIST
105654: LIST
105655: LIST
105656: LIST
105657: LIST
105658: PUSH
105659: LD_INT 101
105661: PUSH
105662: LD_INT 102
105664: PUSH
105665: LD_INT 105
105667: PUSH
105668: LD_INT 106
105670: PUSH
105671: LD_INT 108
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: LIST
105678: LIST
105679: LIST
105680: PUSH
105681: EMPTY
105682: LIST
105683: LIST
105684: ST_TO_ADDR
105685: GO 108464
105687: LD_INT 3
105689: DOUBLE
105690: EQUAL
105691: IFTRUE 105695
105693: GO 105771
105695: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
105696: LD_ADDR_VAR 0 1
105700: PUSH
105701: LD_INT 2
105703: PUSH
105704: LD_INT 4
105706: PUSH
105707: LD_INT 5
105709: PUSH
105710: LD_INT 11
105712: PUSH
105713: LD_INT 12
105715: PUSH
105716: LD_INT 15
105718: PUSH
105719: LD_INT 16
105721: PUSH
105722: LD_INT 22
105724: PUSH
105725: LD_INT 26
105727: PUSH
105728: LD_INT 36
105730: PUSH
105731: EMPTY
105732: LIST
105733: LIST
105734: LIST
105735: LIST
105736: LIST
105737: LIST
105738: LIST
105739: LIST
105740: LIST
105741: LIST
105742: PUSH
105743: LD_INT 101
105745: PUSH
105746: LD_INT 102
105748: PUSH
105749: LD_INT 105
105751: PUSH
105752: LD_INT 106
105754: PUSH
105755: LD_INT 108
105757: PUSH
105758: EMPTY
105759: LIST
105760: LIST
105761: LIST
105762: LIST
105763: LIST
105764: PUSH
105765: EMPTY
105766: LIST
105767: LIST
105768: ST_TO_ADDR
105769: GO 108464
105771: LD_INT 4
105773: DOUBLE
105774: EQUAL
105775: IFTRUE 105779
105777: GO 105863
105779: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
105780: LD_ADDR_VAR 0 1
105784: PUSH
105785: LD_INT 2
105787: PUSH
105788: LD_INT 4
105790: PUSH
105791: LD_INT 5
105793: PUSH
105794: LD_INT 8
105796: PUSH
105797: LD_INT 11
105799: PUSH
105800: LD_INT 12
105802: PUSH
105803: LD_INT 15
105805: PUSH
105806: LD_INT 16
105808: PUSH
105809: LD_INT 22
105811: PUSH
105812: LD_INT 23
105814: PUSH
105815: LD_INT 26
105817: PUSH
105818: LD_INT 36
105820: PUSH
105821: EMPTY
105822: LIST
105823: LIST
105824: LIST
105825: LIST
105826: LIST
105827: LIST
105828: LIST
105829: LIST
105830: LIST
105831: LIST
105832: LIST
105833: LIST
105834: PUSH
105835: LD_INT 101
105837: PUSH
105838: LD_INT 102
105840: PUSH
105841: LD_INT 105
105843: PUSH
105844: LD_INT 106
105846: PUSH
105847: LD_INT 108
105849: PUSH
105850: EMPTY
105851: LIST
105852: LIST
105853: LIST
105854: LIST
105855: LIST
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: ST_TO_ADDR
105861: GO 108464
105863: LD_INT 5
105865: DOUBLE
105866: EQUAL
105867: IFTRUE 105871
105869: GO 105971
105871: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
105872: LD_ADDR_VAR 0 1
105876: PUSH
105877: LD_INT 2
105879: PUSH
105880: LD_INT 4
105882: PUSH
105883: LD_INT 5
105885: PUSH
105886: LD_INT 6
105888: PUSH
105889: LD_INT 8
105891: PUSH
105892: LD_INT 11
105894: PUSH
105895: LD_INT 12
105897: PUSH
105898: LD_INT 15
105900: PUSH
105901: LD_INT 16
105903: PUSH
105904: LD_INT 22
105906: PUSH
105907: LD_INT 23
105909: PUSH
105910: LD_INT 25
105912: PUSH
105913: LD_INT 26
105915: PUSH
105916: LD_INT 36
105918: PUSH
105919: EMPTY
105920: LIST
105921: LIST
105922: LIST
105923: LIST
105924: LIST
105925: LIST
105926: LIST
105927: LIST
105928: LIST
105929: LIST
105930: LIST
105931: LIST
105932: LIST
105933: LIST
105934: PUSH
105935: LD_INT 101
105937: PUSH
105938: LD_INT 102
105940: PUSH
105941: LD_INT 105
105943: PUSH
105944: LD_INT 106
105946: PUSH
105947: LD_INT 108
105949: PUSH
105950: LD_INT 109
105952: PUSH
105953: LD_INT 112
105955: PUSH
105956: EMPTY
105957: LIST
105958: LIST
105959: LIST
105960: LIST
105961: LIST
105962: LIST
105963: LIST
105964: PUSH
105965: EMPTY
105966: LIST
105967: LIST
105968: ST_TO_ADDR
105969: GO 108464
105971: LD_INT 6
105973: DOUBLE
105974: EQUAL
105975: IFTRUE 105979
105977: GO 106099
105979: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
105980: LD_ADDR_VAR 0 1
105984: PUSH
105985: LD_INT 2
105987: PUSH
105988: LD_INT 4
105990: PUSH
105991: LD_INT 5
105993: PUSH
105994: LD_INT 6
105996: PUSH
105997: LD_INT 8
105999: PUSH
106000: LD_INT 11
106002: PUSH
106003: LD_INT 12
106005: PUSH
106006: LD_INT 15
106008: PUSH
106009: LD_INT 16
106011: PUSH
106012: LD_INT 20
106014: PUSH
106015: LD_INT 21
106017: PUSH
106018: LD_INT 22
106020: PUSH
106021: LD_INT 23
106023: PUSH
106024: LD_INT 25
106026: PUSH
106027: LD_INT 26
106029: PUSH
106030: LD_INT 30
106032: PUSH
106033: LD_INT 31
106035: PUSH
106036: LD_INT 32
106038: PUSH
106039: LD_INT 36
106041: PUSH
106042: EMPTY
106043: LIST
106044: LIST
106045: LIST
106046: LIST
106047: LIST
106048: LIST
106049: LIST
106050: LIST
106051: LIST
106052: LIST
106053: LIST
106054: LIST
106055: LIST
106056: LIST
106057: LIST
106058: LIST
106059: LIST
106060: LIST
106061: LIST
106062: PUSH
106063: LD_INT 101
106065: PUSH
106066: LD_INT 102
106068: PUSH
106069: LD_INT 105
106071: PUSH
106072: LD_INT 106
106074: PUSH
106075: LD_INT 108
106077: PUSH
106078: LD_INT 109
106080: PUSH
106081: LD_INT 112
106083: PUSH
106084: EMPTY
106085: LIST
106086: LIST
106087: LIST
106088: LIST
106089: LIST
106090: LIST
106091: LIST
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: ST_TO_ADDR
106097: GO 108464
106099: LD_INT 7
106101: DOUBLE
106102: EQUAL
106103: IFTRUE 106107
106105: GO 106207
106107: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
106108: LD_ADDR_VAR 0 1
106112: PUSH
106113: LD_INT 2
106115: PUSH
106116: LD_INT 4
106118: PUSH
106119: LD_INT 5
106121: PUSH
106122: LD_INT 7
106124: PUSH
106125: LD_INT 11
106127: PUSH
106128: LD_INT 12
106130: PUSH
106131: LD_INT 15
106133: PUSH
106134: LD_INT 16
106136: PUSH
106137: LD_INT 20
106139: PUSH
106140: LD_INT 21
106142: PUSH
106143: LD_INT 22
106145: PUSH
106146: LD_INT 23
106148: PUSH
106149: LD_INT 25
106151: PUSH
106152: LD_INT 26
106154: PUSH
106155: EMPTY
106156: LIST
106157: LIST
106158: LIST
106159: LIST
106160: LIST
106161: LIST
106162: LIST
106163: LIST
106164: LIST
106165: LIST
106166: LIST
106167: LIST
106168: LIST
106169: LIST
106170: PUSH
106171: LD_INT 101
106173: PUSH
106174: LD_INT 102
106176: PUSH
106177: LD_INT 103
106179: PUSH
106180: LD_INT 105
106182: PUSH
106183: LD_INT 106
106185: PUSH
106186: LD_INT 108
106188: PUSH
106189: LD_INT 112
106191: PUSH
106192: EMPTY
106193: LIST
106194: LIST
106195: LIST
106196: LIST
106197: LIST
106198: LIST
106199: LIST
106200: PUSH
106201: EMPTY
106202: LIST
106203: LIST
106204: ST_TO_ADDR
106205: GO 108464
106207: LD_INT 8
106209: DOUBLE
106210: EQUAL
106211: IFTRUE 106215
106213: GO 106343
106215: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
106216: LD_ADDR_VAR 0 1
106220: PUSH
106221: LD_INT 2
106223: PUSH
106224: LD_INT 4
106226: PUSH
106227: LD_INT 5
106229: PUSH
106230: LD_INT 6
106232: PUSH
106233: LD_INT 7
106235: PUSH
106236: LD_INT 8
106238: PUSH
106239: LD_INT 11
106241: PUSH
106242: LD_INT 12
106244: PUSH
106245: LD_INT 15
106247: PUSH
106248: LD_INT 16
106250: PUSH
106251: LD_INT 20
106253: PUSH
106254: LD_INT 21
106256: PUSH
106257: LD_INT 22
106259: PUSH
106260: LD_INT 23
106262: PUSH
106263: LD_INT 25
106265: PUSH
106266: LD_INT 26
106268: PUSH
106269: LD_INT 30
106271: PUSH
106272: LD_INT 31
106274: PUSH
106275: LD_INT 32
106277: PUSH
106278: LD_INT 36
106280: PUSH
106281: EMPTY
106282: LIST
106283: LIST
106284: LIST
106285: LIST
106286: LIST
106287: LIST
106288: LIST
106289: LIST
106290: LIST
106291: LIST
106292: LIST
106293: LIST
106294: LIST
106295: LIST
106296: LIST
106297: LIST
106298: LIST
106299: LIST
106300: LIST
106301: LIST
106302: PUSH
106303: LD_INT 101
106305: PUSH
106306: LD_INT 102
106308: PUSH
106309: LD_INT 103
106311: PUSH
106312: LD_INT 105
106314: PUSH
106315: LD_INT 106
106317: PUSH
106318: LD_INT 108
106320: PUSH
106321: LD_INT 109
106323: PUSH
106324: LD_INT 112
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: LIST
106331: LIST
106332: LIST
106333: LIST
106334: LIST
106335: LIST
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: ST_TO_ADDR
106341: GO 108464
106343: LD_INT 9
106345: DOUBLE
106346: EQUAL
106347: IFTRUE 106351
106349: GO 106487
106351: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
106352: LD_ADDR_VAR 0 1
106356: PUSH
106357: LD_INT 2
106359: PUSH
106360: LD_INT 4
106362: PUSH
106363: LD_INT 5
106365: PUSH
106366: LD_INT 6
106368: PUSH
106369: LD_INT 7
106371: PUSH
106372: LD_INT 8
106374: PUSH
106375: LD_INT 11
106377: PUSH
106378: LD_INT 12
106380: PUSH
106381: LD_INT 15
106383: PUSH
106384: LD_INT 16
106386: PUSH
106387: LD_INT 20
106389: PUSH
106390: LD_INT 21
106392: PUSH
106393: LD_INT 22
106395: PUSH
106396: LD_INT 23
106398: PUSH
106399: LD_INT 25
106401: PUSH
106402: LD_INT 26
106404: PUSH
106405: LD_INT 28
106407: PUSH
106408: LD_INT 30
106410: PUSH
106411: LD_INT 31
106413: PUSH
106414: LD_INT 32
106416: PUSH
106417: LD_INT 36
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: LIST
106424: LIST
106425: LIST
106426: LIST
106427: LIST
106428: LIST
106429: LIST
106430: LIST
106431: LIST
106432: LIST
106433: LIST
106434: LIST
106435: LIST
106436: LIST
106437: LIST
106438: LIST
106439: LIST
106440: LIST
106441: LIST
106442: PUSH
106443: LD_INT 101
106445: PUSH
106446: LD_INT 102
106448: PUSH
106449: LD_INT 103
106451: PUSH
106452: LD_INT 105
106454: PUSH
106455: LD_INT 106
106457: PUSH
106458: LD_INT 108
106460: PUSH
106461: LD_INT 109
106463: PUSH
106464: LD_INT 112
106466: PUSH
106467: LD_INT 114
106469: PUSH
106470: EMPTY
106471: LIST
106472: LIST
106473: LIST
106474: LIST
106475: LIST
106476: LIST
106477: LIST
106478: LIST
106479: LIST
106480: PUSH
106481: EMPTY
106482: LIST
106483: LIST
106484: ST_TO_ADDR
106485: GO 108464
106487: LD_INT 10
106489: DOUBLE
106490: EQUAL
106491: IFTRUE 106495
106493: GO 106679
106495: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
106496: LD_ADDR_VAR 0 1
106500: PUSH
106501: LD_INT 2
106503: PUSH
106504: LD_INT 4
106506: PUSH
106507: LD_INT 5
106509: PUSH
106510: LD_INT 6
106512: PUSH
106513: LD_INT 7
106515: PUSH
106516: LD_INT 8
106518: PUSH
106519: LD_INT 9
106521: PUSH
106522: LD_INT 10
106524: PUSH
106525: LD_INT 11
106527: PUSH
106528: LD_INT 12
106530: PUSH
106531: LD_INT 13
106533: PUSH
106534: LD_INT 14
106536: PUSH
106537: LD_INT 15
106539: PUSH
106540: LD_INT 16
106542: PUSH
106543: LD_INT 17
106545: PUSH
106546: LD_INT 18
106548: PUSH
106549: LD_INT 19
106551: PUSH
106552: LD_INT 20
106554: PUSH
106555: LD_INT 21
106557: PUSH
106558: LD_INT 22
106560: PUSH
106561: LD_INT 23
106563: PUSH
106564: LD_INT 24
106566: PUSH
106567: LD_INT 25
106569: PUSH
106570: LD_INT 26
106572: PUSH
106573: LD_INT 28
106575: PUSH
106576: LD_INT 30
106578: PUSH
106579: LD_INT 31
106581: PUSH
106582: LD_INT 32
106584: PUSH
106585: LD_INT 36
106587: PUSH
106588: EMPTY
106589: LIST
106590: LIST
106591: LIST
106592: LIST
106593: LIST
106594: LIST
106595: LIST
106596: LIST
106597: LIST
106598: LIST
106599: LIST
106600: LIST
106601: LIST
106602: LIST
106603: LIST
106604: LIST
106605: LIST
106606: LIST
106607: LIST
106608: LIST
106609: LIST
106610: LIST
106611: LIST
106612: LIST
106613: LIST
106614: LIST
106615: LIST
106616: LIST
106617: LIST
106618: PUSH
106619: LD_INT 101
106621: PUSH
106622: LD_INT 102
106624: PUSH
106625: LD_INT 103
106627: PUSH
106628: LD_INT 104
106630: PUSH
106631: LD_INT 105
106633: PUSH
106634: LD_INT 106
106636: PUSH
106637: LD_INT 107
106639: PUSH
106640: LD_INT 108
106642: PUSH
106643: LD_INT 109
106645: PUSH
106646: LD_INT 110
106648: PUSH
106649: LD_INT 111
106651: PUSH
106652: LD_INT 112
106654: PUSH
106655: LD_INT 114
106657: PUSH
106658: EMPTY
106659: LIST
106660: LIST
106661: LIST
106662: LIST
106663: LIST
106664: LIST
106665: LIST
106666: LIST
106667: LIST
106668: LIST
106669: LIST
106670: LIST
106671: LIST
106672: PUSH
106673: EMPTY
106674: LIST
106675: LIST
106676: ST_TO_ADDR
106677: GO 108464
106679: LD_INT 11
106681: DOUBLE
106682: EQUAL
106683: IFTRUE 106687
106685: GO 106879
106687: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
106688: LD_ADDR_VAR 0 1
106692: PUSH
106693: LD_INT 2
106695: PUSH
106696: LD_INT 3
106698: PUSH
106699: LD_INT 4
106701: PUSH
106702: LD_INT 5
106704: PUSH
106705: LD_INT 6
106707: PUSH
106708: LD_INT 7
106710: PUSH
106711: LD_INT 8
106713: PUSH
106714: LD_INT 9
106716: PUSH
106717: LD_INT 10
106719: PUSH
106720: LD_INT 11
106722: PUSH
106723: LD_INT 12
106725: PUSH
106726: LD_INT 13
106728: PUSH
106729: LD_INT 14
106731: PUSH
106732: LD_INT 15
106734: PUSH
106735: LD_INT 16
106737: PUSH
106738: LD_INT 17
106740: PUSH
106741: LD_INT 18
106743: PUSH
106744: LD_INT 19
106746: PUSH
106747: LD_INT 20
106749: PUSH
106750: LD_INT 21
106752: PUSH
106753: LD_INT 22
106755: PUSH
106756: LD_INT 23
106758: PUSH
106759: LD_INT 24
106761: PUSH
106762: LD_INT 25
106764: PUSH
106765: LD_INT 26
106767: PUSH
106768: LD_INT 28
106770: PUSH
106771: LD_INT 30
106773: PUSH
106774: LD_INT 31
106776: PUSH
106777: LD_INT 32
106779: PUSH
106780: LD_INT 34
106782: PUSH
106783: LD_INT 36
106785: PUSH
106786: EMPTY
106787: LIST
106788: LIST
106789: LIST
106790: LIST
106791: LIST
106792: LIST
106793: LIST
106794: LIST
106795: LIST
106796: LIST
106797: LIST
106798: LIST
106799: LIST
106800: LIST
106801: LIST
106802: LIST
106803: LIST
106804: LIST
106805: LIST
106806: LIST
106807: LIST
106808: LIST
106809: LIST
106810: LIST
106811: LIST
106812: LIST
106813: LIST
106814: LIST
106815: LIST
106816: LIST
106817: LIST
106818: PUSH
106819: LD_INT 101
106821: PUSH
106822: LD_INT 102
106824: PUSH
106825: LD_INT 103
106827: PUSH
106828: LD_INT 104
106830: PUSH
106831: LD_INT 105
106833: PUSH
106834: LD_INT 106
106836: PUSH
106837: LD_INT 107
106839: PUSH
106840: LD_INT 108
106842: PUSH
106843: LD_INT 109
106845: PUSH
106846: LD_INT 110
106848: PUSH
106849: LD_INT 111
106851: PUSH
106852: LD_INT 112
106854: PUSH
106855: LD_INT 114
106857: PUSH
106858: EMPTY
106859: LIST
106860: LIST
106861: LIST
106862: LIST
106863: LIST
106864: LIST
106865: LIST
106866: LIST
106867: LIST
106868: LIST
106869: LIST
106870: LIST
106871: LIST
106872: PUSH
106873: EMPTY
106874: LIST
106875: LIST
106876: ST_TO_ADDR
106877: GO 108464
106879: LD_INT 12
106881: DOUBLE
106882: EQUAL
106883: IFTRUE 106887
106885: GO 107095
106887: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
106888: LD_ADDR_VAR 0 1
106892: PUSH
106893: LD_INT 1
106895: PUSH
106896: LD_INT 2
106898: PUSH
106899: LD_INT 3
106901: PUSH
106902: LD_INT 4
106904: PUSH
106905: LD_INT 5
106907: PUSH
106908: LD_INT 6
106910: PUSH
106911: LD_INT 7
106913: PUSH
106914: LD_INT 8
106916: PUSH
106917: LD_INT 9
106919: PUSH
106920: LD_INT 10
106922: PUSH
106923: LD_INT 11
106925: PUSH
106926: LD_INT 12
106928: PUSH
106929: LD_INT 13
106931: PUSH
106932: LD_INT 14
106934: PUSH
106935: LD_INT 15
106937: PUSH
106938: LD_INT 16
106940: PUSH
106941: LD_INT 17
106943: PUSH
106944: LD_INT 18
106946: PUSH
106947: LD_INT 19
106949: PUSH
106950: LD_INT 20
106952: PUSH
106953: LD_INT 21
106955: PUSH
106956: LD_INT 22
106958: PUSH
106959: LD_INT 23
106961: PUSH
106962: LD_INT 24
106964: PUSH
106965: LD_INT 25
106967: PUSH
106968: LD_INT 26
106970: PUSH
106971: LD_INT 27
106973: PUSH
106974: LD_INT 28
106976: PUSH
106977: LD_INT 30
106979: PUSH
106980: LD_INT 31
106982: PUSH
106983: LD_INT 32
106985: PUSH
106986: LD_INT 33
106988: PUSH
106989: LD_INT 34
106991: PUSH
106992: LD_INT 36
106994: PUSH
106995: EMPTY
106996: LIST
106997: LIST
106998: LIST
106999: LIST
107000: LIST
107001: LIST
107002: LIST
107003: LIST
107004: LIST
107005: LIST
107006: LIST
107007: LIST
107008: LIST
107009: LIST
107010: LIST
107011: LIST
107012: LIST
107013: LIST
107014: LIST
107015: LIST
107016: LIST
107017: LIST
107018: LIST
107019: LIST
107020: LIST
107021: LIST
107022: LIST
107023: LIST
107024: LIST
107025: LIST
107026: LIST
107027: LIST
107028: LIST
107029: LIST
107030: PUSH
107031: LD_INT 101
107033: PUSH
107034: LD_INT 102
107036: PUSH
107037: LD_INT 103
107039: PUSH
107040: LD_INT 104
107042: PUSH
107043: LD_INT 105
107045: PUSH
107046: LD_INT 106
107048: PUSH
107049: LD_INT 107
107051: PUSH
107052: LD_INT 108
107054: PUSH
107055: LD_INT 109
107057: PUSH
107058: LD_INT 110
107060: PUSH
107061: LD_INT 111
107063: PUSH
107064: LD_INT 112
107066: PUSH
107067: LD_INT 113
107069: PUSH
107070: LD_INT 114
107072: PUSH
107073: EMPTY
107074: LIST
107075: LIST
107076: LIST
107077: LIST
107078: LIST
107079: LIST
107080: LIST
107081: LIST
107082: LIST
107083: LIST
107084: LIST
107085: LIST
107086: LIST
107087: LIST
107088: PUSH
107089: EMPTY
107090: LIST
107091: LIST
107092: ST_TO_ADDR
107093: GO 108464
107095: LD_INT 13
107097: DOUBLE
107098: EQUAL
107099: IFTRUE 107103
107101: GO 107299
107103: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
107104: LD_ADDR_VAR 0 1
107108: PUSH
107109: LD_INT 1
107111: PUSH
107112: LD_INT 2
107114: PUSH
107115: LD_INT 3
107117: PUSH
107118: LD_INT 4
107120: PUSH
107121: LD_INT 5
107123: PUSH
107124: LD_INT 8
107126: PUSH
107127: LD_INT 9
107129: PUSH
107130: LD_INT 10
107132: PUSH
107133: LD_INT 11
107135: PUSH
107136: LD_INT 12
107138: PUSH
107139: LD_INT 14
107141: PUSH
107142: LD_INT 15
107144: PUSH
107145: LD_INT 16
107147: PUSH
107148: LD_INT 17
107150: PUSH
107151: LD_INT 18
107153: PUSH
107154: LD_INT 19
107156: PUSH
107157: LD_INT 20
107159: PUSH
107160: LD_INT 21
107162: PUSH
107163: LD_INT 22
107165: PUSH
107166: LD_INT 23
107168: PUSH
107169: LD_INT 24
107171: PUSH
107172: LD_INT 25
107174: PUSH
107175: LD_INT 26
107177: PUSH
107178: LD_INT 27
107180: PUSH
107181: LD_INT 28
107183: PUSH
107184: LD_INT 30
107186: PUSH
107187: LD_INT 31
107189: PUSH
107190: LD_INT 32
107192: PUSH
107193: LD_INT 33
107195: PUSH
107196: LD_INT 34
107198: PUSH
107199: LD_INT 36
107201: PUSH
107202: EMPTY
107203: LIST
107204: LIST
107205: LIST
107206: LIST
107207: LIST
107208: LIST
107209: LIST
107210: LIST
107211: LIST
107212: LIST
107213: LIST
107214: LIST
107215: LIST
107216: LIST
107217: LIST
107218: LIST
107219: LIST
107220: LIST
107221: LIST
107222: LIST
107223: LIST
107224: LIST
107225: LIST
107226: LIST
107227: LIST
107228: LIST
107229: LIST
107230: LIST
107231: LIST
107232: LIST
107233: LIST
107234: PUSH
107235: LD_INT 101
107237: PUSH
107238: LD_INT 102
107240: PUSH
107241: LD_INT 103
107243: PUSH
107244: LD_INT 104
107246: PUSH
107247: LD_INT 105
107249: PUSH
107250: LD_INT 106
107252: PUSH
107253: LD_INT 107
107255: PUSH
107256: LD_INT 108
107258: PUSH
107259: LD_INT 109
107261: PUSH
107262: LD_INT 110
107264: PUSH
107265: LD_INT 111
107267: PUSH
107268: LD_INT 112
107270: PUSH
107271: LD_INT 113
107273: PUSH
107274: LD_INT 114
107276: PUSH
107277: EMPTY
107278: LIST
107279: LIST
107280: LIST
107281: LIST
107282: LIST
107283: LIST
107284: LIST
107285: LIST
107286: LIST
107287: LIST
107288: LIST
107289: LIST
107290: LIST
107291: LIST
107292: PUSH
107293: EMPTY
107294: LIST
107295: LIST
107296: ST_TO_ADDR
107297: GO 108464
107299: LD_INT 14
107301: DOUBLE
107302: EQUAL
107303: IFTRUE 107307
107305: GO 107519
107307: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
107308: LD_ADDR_VAR 0 1
107312: PUSH
107313: LD_INT 1
107315: PUSH
107316: LD_INT 2
107318: PUSH
107319: LD_INT 3
107321: PUSH
107322: LD_INT 4
107324: PUSH
107325: LD_INT 5
107327: PUSH
107328: LD_INT 6
107330: PUSH
107331: LD_INT 7
107333: PUSH
107334: LD_INT 8
107336: PUSH
107337: LD_INT 9
107339: PUSH
107340: LD_INT 10
107342: PUSH
107343: LD_INT 11
107345: PUSH
107346: LD_INT 12
107348: PUSH
107349: LD_INT 13
107351: PUSH
107352: LD_INT 14
107354: PUSH
107355: LD_INT 15
107357: PUSH
107358: LD_INT 16
107360: PUSH
107361: LD_INT 17
107363: PUSH
107364: LD_INT 18
107366: PUSH
107367: LD_INT 19
107369: PUSH
107370: LD_INT 20
107372: PUSH
107373: LD_INT 21
107375: PUSH
107376: LD_INT 22
107378: PUSH
107379: LD_INT 23
107381: PUSH
107382: LD_INT 24
107384: PUSH
107385: LD_INT 25
107387: PUSH
107388: LD_INT 26
107390: PUSH
107391: LD_INT 27
107393: PUSH
107394: LD_INT 28
107396: PUSH
107397: LD_INT 29
107399: PUSH
107400: LD_INT 30
107402: PUSH
107403: LD_INT 31
107405: PUSH
107406: LD_INT 32
107408: PUSH
107409: LD_INT 33
107411: PUSH
107412: LD_INT 34
107414: PUSH
107415: LD_INT 36
107417: PUSH
107418: EMPTY
107419: LIST
107420: LIST
107421: LIST
107422: LIST
107423: LIST
107424: LIST
107425: LIST
107426: LIST
107427: LIST
107428: LIST
107429: LIST
107430: LIST
107431: LIST
107432: LIST
107433: LIST
107434: LIST
107435: LIST
107436: LIST
107437: LIST
107438: LIST
107439: LIST
107440: LIST
107441: LIST
107442: LIST
107443: LIST
107444: LIST
107445: LIST
107446: LIST
107447: LIST
107448: LIST
107449: LIST
107450: LIST
107451: LIST
107452: LIST
107453: LIST
107454: PUSH
107455: LD_INT 101
107457: PUSH
107458: LD_INT 102
107460: PUSH
107461: LD_INT 103
107463: PUSH
107464: LD_INT 104
107466: PUSH
107467: LD_INT 105
107469: PUSH
107470: LD_INT 106
107472: PUSH
107473: LD_INT 107
107475: PUSH
107476: LD_INT 108
107478: PUSH
107479: LD_INT 109
107481: PUSH
107482: LD_INT 110
107484: PUSH
107485: LD_INT 111
107487: PUSH
107488: LD_INT 112
107490: PUSH
107491: LD_INT 113
107493: PUSH
107494: LD_INT 114
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: LIST
107501: LIST
107502: LIST
107503: LIST
107504: LIST
107505: LIST
107506: LIST
107507: LIST
107508: LIST
107509: LIST
107510: LIST
107511: LIST
107512: PUSH
107513: EMPTY
107514: LIST
107515: LIST
107516: ST_TO_ADDR
107517: GO 108464
107519: LD_INT 15
107521: DOUBLE
107522: EQUAL
107523: IFTRUE 107527
107525: GO 107739
107527: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
107528: LD_ADDR_VAR 0 1
107532: PUSH
107533: LD_INT 1
107535: PUSH
107536: LD_INT 2
107538: PUSH
107539: LD_INT 3
107541: PUSH
107542: LD_INT 4
107544: PUSH
107545: LD_INT 5
107547: PUSH
107548: LD_INT 6
107550: PUSH
107551: LD_INT 7
107553: PUSH
107554: LD_INT 8
107556: PUSH
107557: LD_INT 9
107559: PUSH
107560: LD_INT 10
107562: PUSH
107563: LD_INT 11
107565: PUSH
107566: LD_INT 12
107568: PUSH
107569: LD_INT 13
107571: PUSH
107572: LD_INT 14
107574: PUSH
107575: LD_INT 15
107577: PUSH
107578: LD_INT 16
107580: PUSH
107581: LD_INT 17
107583: PUSH
107584: LD_INT 18
107586: PUSH
107587: LD_INT 19
107589: PUSH
107590: LD_INT 20
107592: PUSH
107593: LD_INT 21
107595: PUSH
107596: LD_INT 22
107598: PUSH
107599: LD_INT 23
107601: PUSH
107602: LD_INT 24
107604: PUSH
107605: LD_INT 25
107607: PUSH
107608: LD_INT 26
107610: PUSH
107611: LD_INT 27
107613: PUSH
107614: LD_INT 28
107616: PUSH
107617: LD_INT 29
107619: PUSH
107620: LD_INT 30
107622: PUSH
107623: LD_INT 31
107625: PUSH
107626: LD_INT 32
107628: PUSH
107629: LD_INT 33
107631: PUSH
107632: LD_INT 34
107634: PUSH
107635: LD_INT 36
107637: PUSH
107638: EMPTY
107639: LIST
107640: LIST
107641: LIST
107642: LIST
107643: LIST
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: LIST
107649: LIST
107650: LIST
107651: LIST
107652: LIST
107653: LIST
107654: LIST
107655: LIST
107656: LIST
107657: LIST
107658: LIST
107659: LIST
107660: LIST
107661: LIST
107662: LIST
107663: LIST
107664: LIST
107665: LIST
107666: LIST
107667: LIST
107668: LIST
107669: LIST
107670: LIST
107671: LIST
107672: LIST
107673: LIST
107674: PUSH
107675: LD_INT 101
107677: PUSH
107678: LD_INT 102
107680: PUSH
107681: LD_INT 103
107683: PUSH
107684: LD_INT 104
107686: PUSH
107687: LD_INT 105
107689: PUSH
107690: LD_INT 106
107692: PUSH
107693: LD_INT 107
107695: PUSH
107696: LD_INT 108
107698: PUSH
107699: LD_INT 109
107701: PUSH
107702: LD_INT 110
107704: PUSH
107705: LD_INT 111
107707: PUSH
107708: LD_INT 112
107710: PUSH
107711: LD_INT 113
107713: PUSH
107714: LD_INT 114
107716: PUSH
107717: EMPTY
107718: LIST
107719: LIST
107720: LIST
107721: LIST
107722: LIST
107723: LIST
107724: LIST
107725: LIST
107726: LIST
107727: LIST
107728: LIST
107729: LIST
107730: LIST
107731: LIST
107732: PUSH
107733: EMPTY
107734: LIST
107735: LIST
107736: ST_TO_ADDR
107737: GO 108464
107739: LD_INT 16
107741: DOUBLE
107742: EQUAL
107743: IFTRUE 107747
107745: GO 107871
107747: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
107748: LD_ADDR_VAR 0 1
107752: PUSH
107753: LD_INT 2
107755: PUSH
107756: LD_INT 4
107758: PUSH
107759: LD_INT 5
107761: PUSH
107762: LD_INT 7
107764: PUSH
107765: LD_INT 11
107767: PUSH
107768: LD_INT 12
107770: PUSH
107771: LD_INT 15
107773: PUSH
107774: LD_INT 16
107776: PUSH
107777: LD_INT 20
107779: PUSH
107780: LD_INT 21
107782: PUSH
107783: LD_INT 22
107785: PUSH
107786: LD_INT 23
107788: PUSH
107789: LD_INT 25
107791: PUSH
107792: LD_INT 26
107794: PUSH
107795: LD_INT 30
107797: PUSH
107798: LD_INT 31
107800: PUSH
107801: LD_INT 32
107803: PUSH
107804: LD_INT 33
107806: PUSH
107807: LD_INT 34
107809: PUSH
107810: EMPTY
107811: LIST
107812: LIST
107813: LIST
107814: LIST
107815: LIST
107816: LIST
107817: LIST
107818: LIST
107819: LIST
107820: LIST
107821: LIST
107822: LIST
107823: LIST
107824: LIST
107825: LIST
107826: LIST
107827: LIST
107828: LIST
107829: LIST
107830: PUSH
107831: LD_INT 101
107833: PUSH
107834: LD_INT 102
107836: PUSH
107837: LD_INT 103
107839: PUSH
107840: LD_INT 106
107842: PUSH
107843: LD_INT 108
107845: PUSH
107846: LD_INT 112
107848: PUSH
107849: LD_INT 113
107851: PUSH
107852: LD_INT 114
107854: PUSH
107855: EMPTY
107856: LIST
107857: LIST
107858: LIST
107859: LIST
107860: LIST
107861: LIST
107862: LIST
107863: LIST
107864: PUSH
107865: EMPTY
107866: LIST
107867: LIST
107868: ST_TO_ADDR
107869: GO 108464
107871: LD_INT 17
107873: DOUBLE
107874: EQUAL
107875: IFTRUE 107879
107877: GO 108091
107879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
107880: LD_ADDR_VAR 0 1
107884: PUSH
107885: LD_INT 1
107887: PUSH
107888: LD_INT 2
107890: PUSH
107891: LD_INT 3
107893: PUSH
107894: LD_INT 4
107896: PUSH
107897: LD_INT 5
107899: PUSH
107900: LD_INT 6
107902: PUSH
107903: LD_INT 7
107905: PUSH
107906: LD_INT 8
107908: PUSH
107909: LD_INT 9
107911: PUSH
107912: LD_INT 10
107914: PUSH
107915: LD_INT 11
107917: PUSH
107918: LD_INT 12
107920: PUSH
107921: LD_INT 13
107923: PUSH
107924: LD_INT 14
107926: PUSH
107927: LD_INT 15
107929: PUSH
107930: LD_INT 16
107932: PUSH
107933: LD_INT 17
107935: PUSH
107936: LD_INT 18
107938: PUSH
107939: LD_INT 19
107941: PUSH
107942: LD_INT 20
107944: PUSH
107945: LD_INT 21
107947: PUSH
107948: LD_INT 22
107950: PUSH
107951: LD_INT 23
107953: PUSH
107954: LD_INT 24
107956: PUSH
107957: LD_INT 25
107959: PUSH
107960: LD_INT 26
107962: PUSH
107963: LD_INT 27
107965: PUSH
107966: LD_INT 28
107968: PUSH
107969: LD_INT 29
107971: PUSH
107972: LD_INT 30
107974: PUSH
107975: LD_INT 31
107977: PUSH
107978: LD_INT 32
107980: PUSH
107981: LD_INT 33
107983: PUSH
107984: LD_INT 34
107986: PUSH
107987: LD_INT 36
107989: PUSH
107990: EMPTY
107991: LIST
107992: LIST
107993: LIST
107994: LIST
107995: LIST
107996: LIST
107997: LIST
107998: LIST
107999: LIST
108000: LIST
108001: LIST
108002: LIST
108003: LIST
108004: LIST
108005: LIST
108006: LIST
108007: LIST
108008: LIST
108009: LIST
108010: LIST
108011: LIST
108012: LIST
108013: LIST
108014: LIST
108015: LIST
108016: LIST
108017: LIST
108018: LIST
108019: LIST
108020: LIST
108021: LIST
108022: LIST
108023: LIST
108024: LIST
108025: LIST
108026: PUSH
108027: LD_INT 101
108029: PUSH
108030: LD_INT 102
108032: PUSH
108033: LD_INT 103
108035: PUSH
108036: LD_INT 104
108038: PUSH
108039: LD_INT 105
108041: PUSH
108042: LD_INT 106
108044: PUSH
108045: LD_INT 107
108047: PUSH
108048: LD_INT 108
108050: PUSH
108051: LD_INT 109
108053: PUSH
108054: LD_INT 110
108056: PUSH
108057: LD_INT 111
108059: PUSH
108060: LD_INT 112
108062: PUSH
108063: LD_INT 113
108065: PUSH
108066: LD_INT 114
108068: PUSH
108069: EMPTY
108070: LIST
108071: LIST
108072: LIST
108073: LIST
108074: LIST
108075: LIST
108076: LIST
108077: LIST
108078: LIST
108079: LIST
108080: LIST
108081: LIST
108082: LIST
108083: LIST
108084: PUSH
108085: EMPTY
108086: LIST
108087: LIST
108088: ST_TO_ADDR
108089: GO 108464
108091: LD_INT 18
108093: DOUBLE
108094: EQUAL
108095: IFTRUE 108099
108097: GO 108235
108099: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
108100: LD_ADDR_VAR 0 1
108104: PUSH
108105: LD_INT 2
108107: PUSH
108108: LD_INT 4
108110: PUSH
108111: LD_INT 5
108113: PUSH
108114: LD_INT 7
108116: PUSH
108117: LD_INT 11
108119: PUSH
108120: LD_INT 12
108122: PUSH
108123: LD_INT 15
108125: PUSH
108126: LD_INT 16
108128: PUSH
108129: LD_INT 20
108131: PUSH
108132: LD_INT 21
108134: PUSH
108135: LD_INT 22
108137: PUSH
108138: LD_INT 23
108140: PUSH
108141: LD_INT 25
108143: PUSH
108144: LD_INT 26
108146: PUSH
108147: LD_INT 30
108149: PUSH
108150: LD_INT 31
108152: PUSH
108153: LD_INT 32
108155: PUSH
108156: LD_INT 33
108158: PUSH
108159: LD_INT 34
108161: PUSH
108162: LD_INT 35
108164: PUSH
108165: LD_INT 36
108167: PUSH
108168: EMPTY
108169: LIST
108170: LIST
108171: LIST
108172: LIST
108173: LIST
108174: LIST
108175: LIST
108176: LIST
108177: LIST
108178: LIST
108179: LIST
108180: LIST
108181: LIST
108182: LIST
108183: LIST
108184: LIST
108185: LIST
108186: LIST
108187: LIST
108188: LIST
108189: LIST
108190: PUSH
108191: LD_INT 101
108193: PUSH
108194: LD_INT 102
108196: PUSH
108197: LD_INT 103
108199: PUSH
108200: LD_INT 106
108202: PUSH
108203: LD_INT 108
108205: PUSH
108206: LD_INT 112
108208: PUSH
108209: LD_INT 113
108211: PUSH
108212: LD_INT 114
108214: PUSH
108215: LD_INT 115
108217: PUSH
108218: EMPTY
108219: LIST
108220: LIST
108221: LIST
108222: LIST
108223: LIST
108224: LIST
108225: LIST
108226: LIST
108227: LIST
108228: PUSH
108229: EMPTY
108230: LIST
108231: LIST
108232: ST_TO_ADDR
108233: GO 108464
108235: LD_INT 19
108237: DOUBLE
108238: EQUAL
108239: IFTRUE 108243
108241: GO 108463
108243: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
108244: LD_ADDR_VAR 0 1
108248: PUSH
108249: LD_INT 1
108251: PUSH
108252: LD_INT 2
108254: PUSH
108255: LD_INT 3
108257: PUSH
108258: LD_INT 4
108260: PUSH
108261: LD_INT 5
108263: PUSH
108264: LD_INT 6
108266: PUSH
108267: LD_INT 7
108269: PUSH
108270: LD_INT 8
108272: PUSH
108273: LD_INT 9
108275: PUSH
108276: LD_INT 10
108278: PUSH
108279: LD_INT 11
108281: PUSH
108282: LD_INT 12
108284: PUSH
108285: LD_INT 13
108287: PUSH
108288: LD_INT 14
108290: PUSH
108291: LD_INT 15
108293: PUSH
108294: LD_INT 16
108296: PUSH
108297: LD_INT 17
108299: PUSH
108300: LD_INT 18
108302: PUSH
108303: LD_INT 19
108305: PUSH
108306: LD_INT 20
108308: PUSH
108309: LD_INT 21
108311: PUSH
108312: LD_INT 22
108314: PUSH
108315: LD_INT 23
108317: PUSH
108318: LD_INT 24
108320: PUSH
108321: LD_INT 25
108323: PUSH
108324: LD_INT 26
108326: PUSH
108327: LD_INT 27
108329: PUSH
108330: LD_INT 28
108332: PUSH
108333: LD_INT 29
108335: PUSH
108336: LD_INT 30
108338: PUSH
108339: LD_INT 31
108341: PUSH
108342: LD_INT 32
108344: PUSH
108345: LD_INT 33
108347: PUSH
108348: LD_INT 34
108350: PUSH
108351: LD_INT 35
108353: PUSH
108354: LD_INT 36
108356: PUSH
108357: EMPTY
108358: LIST
108359: LIST
108360: LIST
108361: LIST
108362: LIST
108363: LIST
108364: LIST
108365: LIST
108366: LIST
108367: LIST
108368: LIST
108369: LIST
108370: LIST
108371: LIST
108372: LIST
108373: LIST
108374: LIST
108375: LIST
108376: LIST
108377: LIST
108378: LIST
108379: LIST
108380: LIST
108381: LIST
108382: LIST
108383: LIST
108384: LIST
108385: LIST
108386: LIST
108387: LIST
108388: LIST
108389: LIST
108390: LIST
108391: LIST
108392: LIST
108393: LIST
108394: PUSH
108395: LD_INT 101
108397: PUSH
108398: LD_INT 102
108400: PUSH
108401: LD_INT 103
108403: PUSH
108404: LD_INT 104
108406: PUSH
108407: LD_INT 105
108409: PUSH
108410: LD_INT 106
108412: PUSH
108413: LD_INT 107
108415: PUSH
108416: LD_INT 108
108418: PUSH
108419: LD_INT 109
108421: PUSH
108422: LD_INT 110
108424: PUSH
108425: LD_INT 111
108427: PUSH
108428: LD_INT 112
108430: PUSH
108431: LD_INT 113
108433: PUSH
108434: LD_INT 114
108436: PUSH
108437: LD_INT 115
108439: PUSH
108440: EMPTY
108441: LIST
108442: LIST
108443: LIST
108444: LIST
108445: LIST
108446: LIST
108447: LIST
108448: LIST
108449: LIST
108450: LIST
108451: LIST
108452: LIST
108453: LIST
108454: LIST
108455: LIST
108456: PUSH
108457: EMPTY
108458: LIST
108459: LIST
108460: ST_TO_ADDR
108461: GO 108464
108463: POP
// end else
108464: GO 108683
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
108466: LD_ADDR_VAR 0 1
108470: PUSH
108471: LD_INT 1
108473: PUSH
108474: LD_INT 2
108476: PUSH
108477: LD_INT 3
108479: PUSH
108480: LD_INT 4
108482: PUSH
108483: LD_INT 5
108485: PUSH
108486: LD_INT 6
108488: PUSH
108489: LD_INT 7
108491: PUSH
108492: LD_INT 8
108494: PUSH
108495: LD_INT 9
108497: PUSH
108498: LD_INT 10
108500: PUSH
108501: LD_INT 11
108503: PUSH
108504: LD_INT 12
108506: PUSH
108507: LD_INT 13
108509: PUSH
108510: LD_INT 14
108512: PUSH
108513: LD_INT 15
108515: PUSH
108516: LD_INT 16
108518: PUSH
108519: LD_INT 17
108521: PUSH
108522: LD_INT 18
108524: PUSH
108525: LD_INT 19
108527: PUSH
108528: LD_INT 20
108530: PUSH
108531: LD_INT 21
108533: PUSH
108534: LD_INT 22
108536: PUSH
108537: LD_INT 23
108539: PUSH
108540: LD_INT 24
108542: PUSH
108543: LD_INT 25
108545: PUSH
108546: LD_INT 26
108548: PUSH
108549: LD_INT 27
108551: PUSH
108552: LD_INT 28
108554: PUSH
108555: LD_INT 29
108557: PUSH
108558: LD_INT 30
108560: PUSH
108561: LD_INT 31
108563: PUSH
108564: LD_INT 32
108566: PUSH
108567: LD_INT 33
108569: PUSH
108570: LD_INT 34
108572: PUSH
108573: LD_INT 35
108575: PUSH
108576: LD_INT 36
108578: PUSH
108579: EMPTY
108580: LIST
108581: LIST
108582: LIST
108583: LIST
108584: LIST
108585: LIST
108586: LIST
108587: LIST
108588: LIST
108589: LIST
108590: LIST
108591: LIST
108592: LIST
108593: LIST
108594: LIST
108595: LIST
108596: LIST
108597: LIST
108598: LIST
108599: LIST
108600: LIST
108601: LIST
108602: LIST
108603: LIST
108604: LIST
108605: LIST
108606: LIST
108607: LIST
108608: LIST
108609: LIST
108610: LIST
108611: LIST
108612: LIST
108613: LIST
108614: LIST
108615: LIST
108616: PUSH
108617: LD_INT 101
108619: PUSH
108620: LD_INT 102
108622: PUSH
108623: LD_INT 103
108625: PUSH
108626: LD_INT 104
108628: PUSH
108629: LD_INT 105
108631: PUSH
108632: LD_INT 106
108634: PUSH
108635: LD_INT 107
108637: PUSH
108638: LD_INT 108
108640: PUSH
108641: LD_INT 109
108643: PUSH
108644: LD_INT 110
108646: PUSH
108647: LD_INT 111
108649: PUSH
108650: LD_INT 112
108652: PUSH
108653: LD_INT 113
108655: PUSH
108656: LD_INT 114
108658: PUSH
108659: LD_INT 115
108661: PUSH
108662: EMPTY
108663: LIST
108664: LIST
108665: LIST
108666: LIST
108667: LIST
108668: LIST
108669: LIST
108670: LIST
108671: LIST
108672: LIST
108673: LIST
108674: LIST
108675: LIST
108676: LIST
108677: LIST
108678: PUSH
108679: EMPTY
108680: LIST
108681: LIST
108682: ST_TO_ADDR
// if result then
108683: LD_VAR 0 1
108687: IFFALSE 108976
// begin normal :=  ;
108689: LD_ADDR_VAR 0 3
108693: PUSH
108694: LD_STRING 
108696: ST_TO_ADDR
// hardcore :=  ;
108697: LD_ADDR_VAR 0 4
108701: PUSH
108702: LD_STRING 
108704: ST_TO_ADDR
// for i = 1 to normalCounter do
108705: LD_ADDR_VAR 0 5
108709: PUSH
108710: DOUBLE
108711: LD_INT 1
108713: DEC
108714: ST_TO_ADDR
108715: LD_EXP 161
108719: PUSH
108720: FOR_TO
108721: IFFALSE 108822
// begin tmp := 0 ;
108723: LD_ADDR_VAR 0 2
108727: PUSH
108728: LD_STRING 0
108730: ST_TO_ADDR
// if result [ 1 ] then
108731: LD_VAR 0 1
108735: PUSH
108736: LD_INT 1
108738: ARRAY
108739: IFFALSE 108804
// if result [ 1 ] [ 1 ] = i then
108741: LD_VAR 0 1
108745: PUSH
108746: LD_INT 1
108748: ARRAY
108749: PUSH
108750: LD_INT 1
108752: ARRAY
108753: PUSH
108754: LD_VAR 0 5
108758: EQUAL
108759: IFFALSE 108804
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
108761: LD_ADDR_VAR 0 1
108765: PUSH
108766: LD_VAR 0 1
108770: PPUSH
108771: LD_INT 1
108773: PPUSH
108774: LD_VAR 0 1
108778: PUSH
108779: LD_INT 1
108781: ARRAY
108782: PPUSH
108783: LD_INT 1
108785: PPUSH
108786: CALL_OW 3
108790: PPUSH
108791: CALL_OW 1
108795: ST_TO_ADDR
// tmp := 1 ;
108796: LD_ADDR_VAR 0 2
108800: PUSH
108801: LD_STRING 1
108803: ST_TO_ADDR
// end ; normal := normal & tmp ;
108804: LD_ADDR_VAR 0 3
108808: PUSH
108809: LD_VAR 0 3
108813: PUSH
108814: LD_VAR 0 2
108818: STR
108819: ST_TO_ADDR
// end ;
108820: GO 108720
108822: POP
108823: POP
// for i = 1 to hardcoreCounter do
108824: LD_ADDR_VAR 0 5
108828: PUSH
108829: DOUBLE
108830: LD_INT 1
108832: DEC
108833: ST_TO_ADDR
108834: LD_EXP 162
108838: PUSH
108839: FOR_TO
108840: IFFALSE 108945
// begin tmp := 0 ;
108842: LD_ADDR_VAR 0 2
108846: PUSH
108847: LD_STRING 0
108849: ST_TO_ADDR
// if result [ 2 ] then
108850: LD_VAR 0 1
108854: PUSH
108855: LD_INT 2
108857: ARRAY
108858: IFFALSE 108927
// if result [ 2 ] [ 1 ] = 100 + i then
108860: LD_VAR 0 1
108864: PUSH
108865: LD_INT 2
108867: ARRAY
108868: PUSH
108869: LD_INT 1
108871: ARRAY
108872: PUSH
108873: LD_INT 100
108875: PUSH
108876: LD_VAR 0 5
108880: PLUS
108881: EQUAL
108882: IFFALSE 108927
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
108884: LD_ADDR_VAR 0 1
108888: PUSH
108889: LD_VAR 0 1
108893: PPUSH
108894: LD_INT 2
108896: PPUSH
108897: LD_VAR 0 1
108901: PUSH
108902: LD_INT 2
108904: ARRAY
108905: PPUSH
108906: LD_INT 1
108908: PPUSH
108909: CALL_OW 3
108913: PPUSH
108914: CALL_OW 1
108918: ST_TO_ADDR
// tmp := 1 ;
108919: LD_ADDR_VAR 0 2
108923: PUSH
108924: LD_STRING 1
108926: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
108927: LD_ADDR_VAR 0 4
108931: PUSH
108932: LD_VAR 0 4
108936: PUSH
108937: LD_VAR 0 2
108941: STR
108942: ST_TO_ADDR
// end ;
108943: GO 108839
108945: POP
108946: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
108947: LD_STRING getStreamItemsFromMission("
108949: PUSH
108950: LD_VAR 0 3
108954: STR
108955: PUSH
108956: LD_STRING ","
108958: STR
108959: PUSH
108960: LD_VAR 0 4
108964: STR
108965: PUSH
108966: LD_STRING ")
108968: STR
108969: PPUSH
108970: CALL_OW 559
// end else
108974: GO 108983
// ToLua ( getStreamItemsFromMission("","") ) ;
108976: LD_STRING getStreamItemsFromMission("","")
108978: PPUSH
108979: CALL_OW 559
// end ;
108983: LD_VAR 0 1
108987: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
108988: LD_EXP 160
108992: PUSH
108993: LD_EXP 165
108997: AND
108998: IFFALSE 109122
109000: GO 109002
109002: DISABLE
109003: LD_INT 0
109005: PPUSH
109006: PPUSH
// begin enable ;
109007: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
109008: LD_ADDR_VAR 0 2
109012: PUSH
109013: LD_INT 22
109015: PUSH
109016: LD_OWVAR 2
109020: PUSH
109021: EMPTY
109022: LIST
109023: LIST
109024: PUSH
109025: LD_INT 2
109027: PUSH
109028: LD_INT 34
109030: PUSH
109031: LD_INT 7
109033: PUSH
109034: EMPTY
109035: LIST
109036: LIST
109037: PUSH
109038: LD_INT 34
109040: PUSH
109041: LD_INT 45
109043: PUSH
109044: EMPTY
109045: LIST
109046: LIST
109047: PUSH
109048: LD_INT 34
109050: PUSH
109051: LD_INT 28
109053: PUSH
109054: EMPTY
109055: LIST
109056: LIST
109057: PUSH
109058: LD_INT 34
109060: PUSH
109061: LD_INT 47
109063: PUSH
109064: EMPTY
109065: LIST
109066: LIST
109067: PUSH
109068: EMPTY
109069: LIST
109070: LIST
109071: LIST
109072: LIST
109073: LIST
109074: PUSH
109075: EMPTY
109076: LIST
109077: LIST
109078: PPUSH
109079: CALL_OW 69
109083: ST_TO_ADDR
// if not tmp then
109084: LD_VAR 0 2
109088: NOT
109089: IFFALSE 109093
// exit ;
109091: GO 109122
// for i in tmp do
109093: LD_ADDR_VAR 0 1
109097: PUSH
109098: LD_VAR 0 2
109102: PUSH
109103: FOR_IN
109104: IFFALSE 109120
// begin SetLives ( i , 0 ) ;
109106: LD_VAR 0 1
109110: PPUSH
109111: LD_INT 0
109113: PPUSH
109114: CALL_OW 234
// end ;
109118: GO 109103
109120: POP
109121: POP
// end ;
109122: PPOPN 2
109124: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
109125: LD_EXP 160
109129: PUSH
109130: LD_EXP 166
109134: AND
109135: IFFALSE 109219
109137: GO 109139
109139: DISABLE
109140: LD_INT 0
109142: PPUSH
109143: PPUSH
// begin enable ;
109144: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
109145: LD_ADDR_VAR 0 2
109149: PUSH
109150: LD_INT 22
109152: PUSH
109153: LD_OWVAR 2
109157: PUSH
109158: EMPTY
109159: LIST
109160: LIST
109161: PUSH
109162: LD_INT 32
109164: PUSH
109165: LD_INT 3
109167: PUSH
109168: EMPTY
109169: LIST
109170: LIST
109171: PUSH
109172: EMPTY
109173: LIST
109174: LIST
109175: PPUSH
109176: CALL_OW 69
109180: ST_TO_ADDR
// if not tmp then
109181: LD_VAR 0 2
109185: NOT
109186: IFFALSE 109190
// exit ;
109188: GO 109219
// for i in tmp do
109190: LD_ADDR_VAR 0 1
109194: PUSH
109195: LD_VAR 0 2
109199: PUSH
109200: FOR_IN
109201: IFFALSE 109217
// begin SetLives ( i , 0 ) ;
109203: LD_VAR 0 1
109207: PPUSH
109208: LD_INT 0
109210: PPUSH
109211: CALL_OW 234
// end ;
109215: GO 109200
109217: POP
109218: POP
// end ;
109219: PPOPN 2
109221: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
109222: LD_EXP 160
109226: PUSH
109227: LD_EXP 163
109231: AND
109232: IFFALSE 109325
109234: GO 109236
109236: DISABLE
109237: LD_INT 0
109239: PPUSH
// begin enable ;
109240: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
109241: LD_ADDR_VAR 0 1
109245: PUSH
109246: LD_INT 22
109248: PUSH
109249: LD_OWVAR 2
109253: PUSH
109254: EMPTY
109255: LIST
109256: LIST
109257: PUSH
109258: LD_INT 2
109260: PUSH
109261: LD_INT 25
109263: PUSH
109264: LD_INT 5
109266: PUSH
109267: EMPTY
109268: LIST
109269: LIST
109270: PUSH
109271: LD_INT 25
109273: PUSH
109274: LD_INT 9
109276: PUSH
109277: EMPTY
109278: LIST
109279: LIST
109280: PUSH
109281: LD_INT 25
109283: PUSH
109284: LD_INT 8
109286: PUSH
109287: EMPTY
109288: LIST
109289: LIST
109290: PUSH
109291: EMPTY
109292: LIST
109293: LIST
109294: LIST
109295: LIST
109296: PUSH
109297: EMPTY
109298: LIST
109299: LIST
109300: PPUSH
109301: CALL_OW 69
109305: PUSH
109306: FOR_IN
109307: IFFALSE 109323
// begin SetClass ( i , 1 ) ;
109309: LD_VAR 0 1
109313: PPUSH
109314: LD_INT 1
109316: PPUSH
109317: CALL_OW 336
// end ;
109321: GO 109306
109323: POP
109324: POP
// end ;
109325: PPOPN 1
109327: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
109328: LD_EXP 160
109332: PUSH
109333: LD_EXP 164
109337: AND
109338: PUSH
109339: LD_OWVAR 65
109343: PUSH
109344: LD_INT 7
109346: LESS
109347: AND
109348: IFFALSE 109362
109350: GO 109352
109352: DISABLE
// begin enable ;
109353: ENABLE
// game_speed := 7 ;
109354: LD_ADDR_OWVAR 65
109358: PUSH
109359: LD_INT 7
109361: ST_TO_ADDR
// end ;
109362: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
109363: LD_EXP 160
109367: PUSH
109368: LD_EXP 167
109372: AND
109373: IFFALSE 109575
109375: GO 109377
109377: DISABLE
109378: LD_INT 0
109380: PPUSH
109381: PPUSH
109382: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
109383: LD_ADDR_VAR 0 3
109387: PUSH
109388: LD_INT 81
109390: PUSH
109391: LD_OWVAR 2
109395: PUSH
109396: EMPTY
109397: LIST
109398: LIST
109399: PUSH
109400: LD_INT 21
109402: PUSH
109403: LD_INT 1
109405: PUSH
109406: EMPTY
109407: LIST
109408: LIST
109409: PUSH
109410: EMPTY
109411: LIST
109412: LIST
109413: PPUSH
109414: CALL_OW 69
109418: ST_TO_ADDR
// if not tmp then
109419: LD_VAR 0 3
109423: NOT
109424: IFFALSE 109428
// exit ;
109426: GO 109575
// if tmp > 5 then
109428: LD_VAR 0 3
109432: PUSH
109433: LD_INT 5
109435: GREATER
109436: IFFALSE 109448
// k := 5 else
109438: LD_ADDR_VAR 0 2
109442: PUSH
109443: LD_INT 5
109445: ST_TO_ADDR
109446: GO 109458
// k := tmp ;
109448: LD_ADDR_VAR 0 2
109452: PUSH
109453: LD_VAR 0 3
109457: ST_TO_ADDR
// for i := 1 to k do
109458: LD_ADDR_VAR 0 1
109462: PUSH
109463: DOUBLE
109464: LD_INT 1
109466: DEC
109467: ST_TO_ADDR
109468: LD_VAR 0 2
109472: PUSH
109473: FOR_TO
109474: IFFALSE 109573
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
109476: LD_VAR 0 3
109480: PUSH
109481: LD_VAR 0 1
109485: ARRAY
109486: PPUSH
109487: LD_VAR 0 1
109491: PUSH
109492: LD_INT 4
109494: MOD
109495: PUSH
109496: LD_INT 1
109498: PLUS
109499: PPUSH
109500: CALL_OW 259
109504: PUSH
109505: LD_INT 10
109507: LESS
109508: IFFALSE 109571
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
109510: LD_VAR 0 3
109514: PUSH
109515: LD_VAR 0 1
109519: ARRAY
109520: PPUSH
109521: LD_VAR 0 1
109525: PUSH
109526: LD_INT 4
109528: MOD
109529: PUSH
109530: LD_INT 1
109532: PLUS
109533: PPUSH
109534: LD_VAR 0 3
109538: PUSH
109539: LD_VAR 0 1
109543: ARRAY
109544: PPUSH
109545: LD_VAR 0 1
109549: PUSH
109550: LD_INT 4
109552: MOD
109553: PUSH
109554: LD_INT 1
109556: PLUS
109557: PPUSH
109558: CALL_OW 259
109562: PUSH
109563: LD_INT 1
109565: PLUS
109566: PPUSH
109567: CALL_OW 237
109571: GO 109473
109573: POP
109574: POP
// end ;
109575: PPOPN 3
109577: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
109578: LD_EXP 160
109582: PUSH
109583: LD_EXP 168
109587: AND
109588: IFFALSE 109608
109590: GO 109592
109592: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
109593: LD_INT 4
109595: PPUSH
109596: LD_OWVAR 2
109600: PPUSH
109601: LD_INT 0
109603: PPUSH
109604: CALL_OW 324
109608: END
// every 0 0$1 trigger StreamModeActive and sShovel do
109609: LD_EXP 160
109613: PUSH
109614: LD_EXP 197
109618: AND
109619: IFFALSE 109639
109621: GO 109623
109623: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
109624: LD_INT 19
109626: PPUSH
109627: LD_OWVAR 2
109631: PPUSH
109632: LD_INT 0
109634: PPUSH
109635: CALL_OW 324
109639: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
109640: LD_EXP 160
109644: PUSH
109645: LD_EXP 169
109649: AND
109650: IFFALSE 109752
109652: GO 109654
109654: DISABLE
109655: LD_INT 0
109657: PPUSH
109658: PPUSH
// begin enable ;
109659: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
109660: LD_ADDR_VAR 0 2
109664: PUSH
109665: LD_INT 22
109667: PUSH
109668: LD_OWVAR 2
109672: PUSH
109673: EMPTY
109674: LIST
109675: LIST
109676: PUSH
109677: LD_INT 2
109679: PUSH
109680: LD_INT 34
109682: PUSH
109683: LD_INT 11
109685: PUSH
109686: EMPTY
109687: LIST
109688: LIST
109689: PUSH
109690: LD_INT 34
109692: PUSH
109693: LD_INT 30
109695: PUSH
109696: EMPTY
109697: LIST
109698: LIST
109699: PUSH
109700: EMPTY
109701: LIST
109702: LIST
109703: LIST
109704: PUSH
109705: EMPTY
109706: LIST
109707: LIST
109708: PPUSH
109709: CALL_OW 69
109713: ST_TO_ADDR
// if not tmp then
109714: LD_VAR 0 2
109718: NOT
109719: IFFALSE 109723
// exit ;
109721: GO 109752
// for i in tmp do
109723: LD_ADDR_VAR 0 1
109727: PUSH
109728: LD_VAR 0 2
109732: PUSH
109733: FOR_IN
109734: IFFALSE 109750
// begin SetLives ( i , 0 ) ;
109736: LD_VAR 0 1
109740: PPUSH
109741: LD_INT 0
109743: PPUSH
109744: CALL_OW 234
// end ;
109748: GO 109733
109750: POP
109751: POP
// end ;
109752: PPOPN 2
109754: END
// every 0 0$1 trigger StreamModeActive and sBunker do
109755: LD_EXP 160
109759: PUSH
109760: LD_EXP 170
109764: AND
109765: IFFALSE 109785
109767: GO 109769
109769: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
109770: LD_INT 32
109772: PPUSH
109773: LD_OWVAR 2
109777: PPUSH
109778: LD_INT 0
109780: PPUSH
109781: CALL_OW 324
109785: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
109786: LD_EXP 160
109790: PUSH
109791: LD_EXP 171
109795: AND
109796: IFFALSE 109977
109798: GO 109800
109800: DISABLE
109801: LD_INT 0
109803: PPUSH
109804: PPUSH
109805: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
109806: LD_ADDR_VAR 0 2
109810: PUSH
109811: LD_INT 22
109813: PUSH
109814: LD_OWVAR 2
109818: PUSH
109819: EMPTY
109820: LIST
109821: LIST
109822: PUSH
109823: LD_INT 33
109825: PUSH
109826: LD_INT 3
109828: PUSH
109829: EMPTY
109830: LIST
109831: LIST
109832: PUSH
109833: EMPTY
109834: LIST
109835: LIST
109836: PPUSH
109837: CALL_OW 69
109841: ST_TO_ADDR
// if not tmp then
109842: LD_VAR 0 2
109846: NOT
109847: IFFALSE 109851
// exit ;
109849: GO 109977
// side := 0 ;
109851: LD_ADDR_VAR 0 3
109855: PUSH
109856: LD_INT 0
109858: ST_TO_ADDR
// for i := 1 to 8 do
109859: LD_ADDR_VAR 0 1
109863: PUSH
109864: DOUBLE
109865: LD_INT 1
109867: DEC
109868: ST_TO_ADDR
109869: LD_INT 8
109871: PUSH
109872: FOR_TO
109873: IFFALSE 109921
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
109875: LD_OWVAR 2
109879: PUSH
109880: LD_VAR 0 1
109884: NONEQUAL
109885: PUSH
109886: LD_OWVAR 2
109890: PPUSH
109891: LD_VAR 0 1
109895: PPUSH
109896: CALL_OW 81
109900: PUSH
109901: LD_INT 2
109903: EQUAL
109904: AND
109905: IFFALSE 109919
// begin side := i ;
109907: LD_ADDR_VAR 0 3
109911: PUSH
109912: LD_VAR 0 1
109916: ST_TO_ADDR
// break ;
109917: GO 109921
// end ;
109919: GO 109872
109921: POP
109922: POP
// if not side then
109923: LD_VAR 0 3
109927: NOT
109928: IFFALSE 109932
// exit ;
109930: GO 109977
// for i := 1 to tmp do
109932: LD_ADDR_VAR 0 1
109936: PUSH
109937: DOUBLE
109938: LD_INT 1
109940: DEC
109941: ST_TO_ADDR
109942: LD_VAR 0 2
109946: PUSH
109947: FOR_TO
109948: IFFALSE 109975
// if Prob ( 60 ) then
109950: LD_INT 60
109952: PPUSH
109953: CALL_OW 13
109957: IFFALSE 109973
// SetSide ( i , side ) ;
109959: LD_VAR 0 1
109963: PPUSH
109964: LD_VAR 0 3
109968: PPUSH
109969: CALL_OW 235
109973: GO 109947
109975: POP
109976: POP
// end ;
109977: PPOPN 3
109979: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
109980: LD_EXP 160
109984: PUSH
109985: LD_EXP 173
109989: AND
109990: IFFALSE 110109
109992: GO 109994
109994: DISABLE
109995: LD_INT 0
109997: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
109998: LD_ADDR_VAR 0 1
110002: PUSH
110003: LD_INT 22
110005: PUSH
110006: LD_OWVAR 2
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: PUSH
110015: LD_INT 21
110017: PUSH
110018: LD_INT 1
110020: PUSH
110021: EMPTY
110022: LIST
110023: LIST
110024: PUSH
110025: LD_INT 3
110027: PUSH
110028: LD_INT 23
110030: PUSH
110031: LD_INT 0
110033: PUSH
110034: EMPTY
110035: LIST
110036: LIST
110037: PUSH
110038: EMPTY
110039: LIST
110040: LIST
110041: PUSH
110042: EMPTY
110043: LIST
110044: LIST
110045: LIST
110046: PPUSH
110047: CALL_OW 69
110051: PUSH
110052: FOR_IN
110053: IFFALSE 110107
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
110055: LD_VAR 0 1
110059: PPUSH
110060: CALL_OW 257
110064: PUSH
110065: LD_INT 1
110067: PUSH
110068: LD_INT 2
110070: PUSH
110071: LD_INT 3
110073: PUSH
110074: LD_INT 4
110076: PUSH
110077: EMPTY
110078: LIST
110079: LIST
110080: LIST
110081: LIST
110082: IN
110083: IFFALSE 110105
// SetClass ( un , rand ( 1 , 4 ) ) ;
110085: LD_VAR 0 1
110089: PPUSH
110090: LD_INT 1
110092: PPUSH
110093: LD_INT 4
110095: PPUSH
110096: CALL_OW 12
110100: PPUSH
110101: CALL_OW 336
110105: GO 110052
110107: POP
110108: POP
// end ;
110109: PPOPN 1
110111: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
110112: LD_EXP 160
110116: PUSH
110117: LD_EXP 172
110121: AND
110122: IFFALSE 110201
110124: GO 110126
110126: DISABLE
110127: LD_INT 0
110129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
110130: LD_ADDR_VAR 0 1
110134: PUSH
110135: LD_INT 22
110137: PUSH
110138: LD_OWVAR 2
110142: PUSH
110143: EMPTY
110144: LIST
110145: LIST
110146: PUSH
110147: LD_INT 21
110149: PUSH
110150: LD_INT 3
110152: PUSH
110153: EMPTY
110154: LIST
110155: LIST
110156: PUSH
110157: EMPTY
110158: LIST
110159: LIST
110160: PPUSH
110161: CALL_OW 69
110165: ST_TO_ADDR
// if not tmp then
110166: LD_VAR 0 1
110170: NOT
110171: IFFALSE 110175
// exit ;
110173: GO 110201
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
110175: LD_VAR 0 1
110179: PUSH
110180: LD_INT 1
110182: PPUSH
110183: LD_VAR 0 1
110187: PPUSH
110188: CALL_OW 12
110192: ARRAY
110193: PPUSH
110194: LD_INT 100
110196: PPUSH
110197: CALL_OW 234
// end ;
110201: PPOPN 1
110203: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
110204: LD_EXP 160
110208: PUSH
110209: LD_EXP 174
110213: AND
110214: IFFALSE 110312
110216: GO 110218
110218: DISABLE
110219: LD_INT 0
110221: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
110222: LD_ADDR_VAR 0 1
110226: PUSH
110227: LD_INT 22
110229: PUSH
110230: LD_OWVAR 2
110234: PUSH
110235: EMPTY
110236: LIST
110237: LIST
110238: PUSH
110239: LD_INT 21
110241: PUSH
110242: LD_INT 1
110244: PUSH
110245: EMPTY
110246: LIST
110247: LIST
110248: PUSH
110249: EMPTY
110250: LIST
110251: LIST
110252: PPUSH
110253: CALL_OW 69
110257: ST_TO_ADDR
// if not tmp then
110258: LD_VAR 0 1
110262: NOT
110263: IFFALSE 110267
// exit ;
110265: GO 110312
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
110267: LD_VAR 0 1
110271: PUSH
110272: LD_INT 1
110274: PPUSH
110275: LD_VAR 0 1
110279: PPUSH
110280: CALL_OW 12
110284: ARRAY
110285: PPUSH
110286: LD_INT 1
110288: PPUSH
110289: LD_INT 4
110291: PPUSH
110292: CALL_OW 12
110296: PPUSH
110297: LD_INT 3000
110299: PPUSH
110300: LD_INT 9000
110302: PPUSH
110303: CALL_OW 12
110307: PPUSH
110308: CALL_OW 492
// end ;
110312: PPOPN 1
110314: END
// every 0 0$1 trigger StreamModeActive and sDepot do
110315: LD_EXP 160
110319: PUSH
110320: LD_EXP 175
110324: AND
110325: IFFALSE 110345
110327: GO 110329
110329: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
110330: LD_INT 1
110332: PPUSH
110333: LD_OWVAR 2
110337: PPUSH
110338: LD_INT 0
110340: PPUSH
110341: CALL_OW 324
110345: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
110346: LD_EXP 160
110350: PUSH
110351: LD_EXP 176
110355: AND
110356: IFFALSE 110439
110358: GO 110360
110360: DISABLE
110361: LD_INT 0
110363: PPUSH
110364: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
110365: LD_ADDR_VAR 0 2
110369: PUSH
110370: LD_INT 22
110372: PUSH
110373: LD_OWVAR 2
110377: PUSH
110378: EMPTY
110379: LIST
110380: LIST
110381: PUSH
110382: LD_INT 21
110384: PUSH
110385: LD_INT 3
110387: PUSH
110388: EMPTY
110389: LIST
110390: LIST
110391: PUSH
110392: EMPTY
110393: LIST
110394: LIST
110395: PPUSH
110396: CALL_OW 69
110400: ST_TO_ADDR
// if not tmp then
110401: LD_VAR 0 2
110405: NOT
110406: IFFALSE 110410
// exit ;
110408: GO 110439
// for i in tmp do
110410: LD_ADDR_VAR 0 1
110414: PUSH
110415: LD_VAR 0 2
110419: PUSH
110420: FOR_IN
110421: IFFALSE 110437
// SetBLevel ( i , 10 ) ;
110423: LD_VAR 0 1
110427: PPUSH
110428: LD_INT 10
110430: PPUSH
110431: CALL_OW 241
110435: GO 110420
110437: POP
110438: POP
// end ;
110439: PPOPN 2
110441: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
110442: LD_EXP 160
110446: PUSH
110447: LD_EXP 177
110451: AND
110452: IFFALSE 110563
110454: GO 110456
110456: DISABLE
110457: LD_INT 0
110459: PPUSH
110460: PPUSH
110461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110462: LD_ADDR_VAR 0 3
110466: PUSH
110467: LD_INT 22
110469: PUSH
110470: LD_OWVAR 2
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PUSH
110479: LD_INT 25
110481: PUSH
110482: LD_INT 1
110484: PUSH
110485: EMPTY
110486: LIST
110487: LIST
110488: PUSH
110489: EMPTY
110490: LIST
110491: LIST
110492: PPUSH
110493: CALL_OW 69
110497: ST_TO_ADDR
// if not tmp then
110498: LD_VAR 0 3
110502: NOT
110503: IFFALSE 110507
// exit ;
110505: GO 110563
// un := tmp [ rand ( 1 , tmp ) ] ;
110507: LD_ADDR_VAR 0 2
110511: PUSH
110512: LD_VAR 0 3
110516: PUSH
110517: LD_INT 1
110519: PPUSH
110520: LD_VAR 0 3
110524: PPUSH
110525: CALL_OW 12
110529: ARRAY
110530: ST_TO_ADDR
// if Crawls ( un ) then
110531: LD_VAR 0 2
110535: PPUSH
110536: CALL_OW 318
110540: IFFALSE 110551
// ComWalk ( un ) ;
110542: LD_VAR 0 2
110546: PPUSH
110547: CALL_OW 138
// SetClass ( un , class_sniper ) ;
110551: LD_VAR 0 2
110555: PPUSH
110556: LD_INT 5
110558: PPUSH
110559: CALL_OW 336
// end ;
110563: PPOPN 3
110565: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
110566: LD_EXP 160
110570: PUSH
110571: LD_EXP 178
110575: AND
110576: PUSH
110577: LD_OWVAR 67
110581: PUSH
110582: LD_INT 3
110584: LESS
110585: AND
110586: IFFALSE 110605
110588: GO 110590
110590: DISABLE
// Difficulty := Difficulty + 1 ;
110591: LD_ADDR_OWVAR 67
110595: PUSH
110596: LD_OWVAR 67
110600: PUSH
110601: LD_INT 1
110603: PLUS
110604: ST_TO_ADDR
110605: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
110606: LD_EXP 160
110610: PUSH
110611: LD_EXP 179
110615: AND
110616: IFFALSE 110719
110618: GO 110620
110620: DISABLE
110621: LD_INT 0
110623: PPUSH
// begin for i := 1 to 5 do
110624: LD_ADDR_VAR 0 1
110628: PUSH
110629: DOUBLE
110630: LD_INT 1
110632: DEC
110633: ST_TO_ADDR
110634: LD_INT 5
110636: PUSH
110637: FOR_TO
110638: IFFALSE 110717
// begin uc_nation := nation_nature ;
110640: LD_ADDR_OWVAR 21
110644: PUSH
110645: LD_INT 0
110647: ST_TO_ADDR
// uc_side := 0 ;
110648: LD_ADDR_OWVAR 20
110652: PUSH
110653: LD_INT 0
110655: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
110656: LD_ADDR_OWVAR 29
110660: PUSH
110661: LD_INT 12
110663: PUSH
110664: LD_INT 12
110666: PUSH
110667: EMPTY
110668: LIST
110669: LIST
110670: ST_TO_ADDR
// hc_agressivity := 20 ;
110671: LD_ADDR_OWVAR 35
110675: PUSH
110676: LD_INT 20
110678: ST_TO_ADDR
// hc_class := class_tiger ;
110679: LD_ADDR_OWVAR 28
110683: PUSH
110684: LD_INT 14
110686: ST_TO_ADDR
// hc_gallery :=  ;
110687: LD_ADDR_OWVAR 33
110691: PUSH
110692: LD_STRING 
110694: ST_TO_ADDR
// hc_name :=  ;
110695: LD_ADDR_OWVAR 26
110699: PUSH
110700: LD_STRING 
110702: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
110703: CALL_OW 44
110707: PPUSH
110708: LD_INT 0
110710: PPUSH
110711: CALL_OW 51
// end ;
110715: GO 110637
110717: POP
110718: POP
// end ;
110719: PPOPN 1
110721: END
// every 0 0$1 trigger StreamModeActive and sBomb do
110722: LD_EXP 160
110726: PUSH
110727: LD_EXP 180
110731: AND
110732: IFFALSE 110741
110734: GO 110736
110736: DISABLE
// StreamSibBomb ;
110737: CALL 110742 0 0
110741: END
// export function StreamSibBomb ; var i , x , y ; begin
110742: LD_INT 0
110744: PPUSH
110745: PPUSH
110746: PPUSH
110747: PPUSH
// result := false ;
110748: LD_ADDR_VAR 0 1
110752: PUSH
110753: LD_INT 0
110755: ST_TO_ADDR
// for i := 1 to 16 do
110756: LD_ADDR_VAR 0 2
110760: PUSH
110761: DOUBLE
110762: LD_INT 1
110764: DEC
110765: ST_TO_ADDR
110766: LD_INT 16
110768: PUSH
110769: FOR_TO
110770: IFFALSE 110969
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
110772: LD_ADDR_VAR 0 3
110776: PUSH
110777: LD_INT 10
110779: PUSH
110780: LD_INT 20
110782: PUSH
110783: LD_INT 30
110785: PUSH
110786: LD_INT 40
110788: PUSH
110789: LD_INT 50
110791: PUSH
110792: LD_INT 60
110794: PUSH
110795: LD_INT 70
110797: PUSH
110798: LD_INT 80
110800: PUSH
110801: LD_INT 90
110803: PUSH
110804: LD_INT 100
110806: PUSH
110807: LD_INT 110
110809: PUSH
110810: LD_INT 120
110812: PUSH
110813: LD_INT 130
110815: PUSH
110816: LD_INT 140
110818: PUSH
110819: LD_INT 150
110821: PUSH
110822: EMPTY
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: LIST
110831: LIST
110832: LIST
110833: LIST
110834: LIST
110835: LIST
110836: LIST
110837: LIST
110838: PUSH
110839: LD_INT 1
110841: PPUSH
110842: LD_INT 15
110844: PPUSH
110845: CALL_OW 12
110849: ARRAY
110850: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
110851: LD_ADDR_VAR 0 4
110855: PUSH
110856: LD_INT 10
110858: PUSH
110859: LD_INT 20
110861: PUSH
110862: LD_INT 30
110864: PUSH
110865: LD_INT 40
110867: PUSH
110868: LD_INT 50
110870: PUSH
110871: LD_INT 60
110873: PUSH
110874: LD_INT 70
110876: PUSH
110877: LD_INT 80
110879: PUSH
110880: LD_INT 90
110882: PUSH
110883: LD_INT 100
110885: PUSH
110886: LD_INT 110
110888: PUSH
110889: LD_INT 120
110891: PUSH
110892: LD_INT 130
110894: PUSH
110895: LD_INT 140
110897: PUSH
110898: LD_INT 150
110900: PUSH
110901: EMPTY
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: LIST
110910: LIST
110911: LIST
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: PUSH
110918: LD_INT 1
110920: PPUSH
110921: LD_INT 15
110923: PPUSH
110924: CALL_OW 12
110928: ARRAY
110929: ST_TO_ADDR
// if ValidHex ( x , y ) then
110930: LD_VAR 0 3
110934: PPUSH
110935: LD_VAR 0 4
110939: PPUSH
110940: CALL_OW 488
110944: IFFALSE 110967
// begin result := [ x , y ] ;
110946: LD_ADDR_VAR 0 1
110950: PUSH
110951: LD_VAR 0 3
110955: PUSH
110956: LD_VAR 0 4
110960: PUSH
110961: EMPTY
110962: LIST
110963: LIST
110964: ST_TO_ADDR
// break ;
110965: GO 110969
// end ; end ;
110967: GO 110769
110969: POP
110970: POP
// if result then
110971: LD_VAR 0 1
110975: IFFALSE 111035
// begin ToLua ( playSibBomb() ) ;
110977: LD_STRING playSibBomb()
110979: PPUSH
110980: CALL_OW 559
// wait ( 0 0$14 ) ;
110984: LD_INT 490
110986: PPUSH
110987: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
110991: LD_VAR 0 1
110995: PUSH
110996: LD_INT 1
110998: ARRAY
110999: PPUSH
111000: LD_VAR 0 1
111004: PUSH
111005: LD_INT 2
111007: ARRAY
111008: PPUSH
111009: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
111013: LD_VAR 0 1
111017: PUSH
111018: LD_INT 1
111020: ARRAY
111021: PPUSH
111022: LD_VAR 0 1
111026: PUSH
111027: LD_INT 2
111029: ARRAY
111030: PPUSH
111031: CALL_OW 429
// end ; end ;
111035: LD_VAR 0 1
111039: RET
// every 0 0$1 trigger StreamModeActive and sReset do
111040: LD_EXP 160
111044: PUSH
111045: LD_EXP 182
111049: AND
111050: IFFALSE 111062
111052: GO 111054
111054: DISABLE
// YouLost (  ) ;
111055: LD_STRING 
111057: PPUSH
111058: CALL_OW 104
111062: END
// every 0 0$1 trigger StreamModeActive and sFog do
111063: LD_EXP 160
111067: PUSH
111068: LD_EXP 181
111072: AND
111073: IFFALSE 111087
111075: GO 111077
111077: DISABLE
// FogOff ( your_side ) ;
111078: LD_OWVAR 2
111082: PPUSH
111083: CALL_OW 344
111087: END
// every 0 0$1 trigger StreamModeActive and sSun do
111088: LD_EXP 160
111092: PUSH
111093: LD_EXP 183
111097: AND
111098: IFFALSE 111126
111100: GO 111102
111102: DISABLE
// begin solar_recharge_percent := 0 ;
111103: LD_ADDR_OWVAR 79
111107: PUSH
111108: LD_INT 0
111110: ST_TO_ADDR
// wait ( 5 5$00 ) ;
111111: LD_INT 10500
111113: PPUSH
111114: CALL_OW 67
// solar_recharge_percent := 100 ;
111118: LD_ADDR_OWVAR 79
111122: PUSH
111123: LD_INT 100
111125: ST_TO_ADDR
// end ;
111126: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
111127: LD_EXP 160
111131: PUSH
111132: LD_EXP 184
111136: AND
111137: IFFALSE 111376
111139: GO 111141
111141: DISABLE
111142: LD_INT 0
111144: PPUSH
111145: PPUSH
111146: PPUSH
// begin tmp := [ ] ;
111147: LD_ADDR_VAR 0 3
111151: PUSH
111152: EMPTY
111153: ST_TO_ADDR
// for i := 1 to 6 do
111154: LD_ADDR_VAR 0 1
111158: PUSH
111159: DOUBLE
111160: LD_INT 1
111162: DEC
111163: ST_TO_ADDR
111164: LD_INT 6
111166: PUSH
111167: FOR_TO
111168: IFFALSE 111273
// begin uc_nation := nation_nature ;
111170: LD_ADDR_OWVAR 21
111174: PUSH
111175: LD_INT 0
111177: ST_TO_ADDR
// uc_side := 0 ;
111178: LD_ADDR_OWVAR 20
111182: PUSH
111183: LD_INT 0
111185: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
111186: LD_ADDR_OWVAR 29
111190: PUSH
111191: LD_INT 12
111193: PUSH
111194: LD_INT 12
111196: PUSH
111197: EMPTY
111198: LIST
111199: LIST
111200: ST_TO_ADDR
// hc_agressivity := 20 ;
111201: LD_ADDR_OWVAR 35
111205: PUSH
111206: LD_INT 20
111208: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
111209: LD_ADDR_OWVAR 28
111213: PUSH
111214: LD_INT 17
111216: ST_TO_ADDR
// hc_gallery :=  ;
111217: LD_ADDR_OWVAR 33
111221: PUSH
111222: LD_STRING 
111224: ST_TO_ADDR
// hc_name :=  ;
111225: LD_ADDR_OWVAR 26
111229: PUSH
111230: LD_STRING 
111232: ST_TO_ADDR
// un := CreateHuman ;
111233: LD_ADDR_VAR 0 2
111237: PUSH
111238: CALL_OW 44
111242: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
111243: LD_VAR 0 2
111247: PPUSH
111248: LD_INT 1
111250: PPUSH
111251: CALL_OW 51
// tmp := tmp ^ un ;
111255: LD_ADDR_VAR 0 3
111259: PUSH
111260: LD_VAR 0 3
111264: PUSH
111265: LD_VAR 0 2
111269: ADD
111270: ST_TO_ADDR
// end ;
111271: GO 111167
111273: POP
111274: POP
// repeat wait ( 0 0$1 ) ;
111275: LD_INT 35
111277: PPUSH
111278: CALL_OW 67
// for un in tmp do
111282: LD_ADDR_VAR 0 2
111286: PUSH
111287: LD_VAR 0 3
111291: PUSH
111292: FOR_IN
111293: IFFALSE 111367
// begin if IsDead ( un ) then
111295: LD_VAR 0 2
111299: PPUSH
111300: CALL_OW 301
111304: IFFALSE 111324
// begin tmp := tmp diff un ;
111306: LD_ADDR_VAR 0 3
111310: PUSH
111311: LD_VAR 0 3
111315: PUSH
111316: LD_VAR 0 2
111320: DIFF
111321: ST_TO_ADDR
// continue ;
111322: GO 111292
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
111324: LD_VAR 0 2
111328: PPUSH
111329: LD_INT 3
111331: PUSH
111332: LD_INT 22
111334: PUSH
111335: LD_INT 0
111337: PUSH
111338: EMPTY
111339: LIST
111340: LIST
111341: PUSH
111342: EMPTY
111343: LIST
111344: LIST
111345: PPUSH
111346: CALL_OW 69
111350: PPUSH
111351: LD_VAR 0 2
111355: PPUSH
111356: CALL_OW 74
111360: PPUSH
111361: CALL_OW 115
// end ;
111365: GO 111292
111367: POP
111368: POP
// until not tmp ;
111369: LD_VAR 0 3
111373: NOT
111374: IFFALSE 111275
// end ;
111376: PPOPN 3
111378: END
// every 0 0$1 trigger StreamModeActive and sTroll do
111379: LD_EXP 160
111383: PUSH
111384: LD_EXP 185
111388: AND
111389: IFFALSE 111443
111391: GO 111393
111393: DISABLE
// begin ToLua ( displayTroll(); ) ;
111394: LD_STRING displayTroll();
111396: PPUSH
111397: CALL_OW 559
// wait ( 3 3$00 ) ;
111401: LD_INT 6300
111403: PPUSH
111404: CALL_OW 67
// ToLua ( hideTroll(); ) ;
111408: LD_STRING hideTroll();
111410: PPUSH
111411: CALL_OW 559
// wait ( 1 1$00 ) ;
111415: LD_INT 2100
111417: PPUSH
111418: CALL_OW 67
// ToLua ( displayTroll(); ) ;
111422: LD_STRING displayTroll();
111424: PPUSH
111425: CALL_OW 559
// wait ( 1 1$00 ) ;
111429: LD_INT 2100
111431: PPUSH
111432: CALL_OW 67
// ToLua ( hideTroll(); ) ;
111436: LD_STRING hideTroll();
111438: PPUSH
111439: CALL_OW 559
// end ;
111443: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
111444: LD_EXP 160
111448: PUSH
111449: LD_EXP 186
111453: AND
111454: IFFALSE 111517
111456: GO 111458
111458: DISABLE
111459: LD_INT 0
111461: PPUSH
// begin p := 0 ;
111462: LD_ADDR_VAR 0 1
111466: PUSH
111467: LD_INT 0
111469: ST_TO_ADDR
// repeat game_speed := 1 ;
111470: LD_ADDR_OWVAR 65
111474: PUSH
111475: LD_INT 1
111477: ST_TO_ADDR
// wait ( 0 0$1 ) ;
111478: LD_INT 35
111480: PPUSH
111481: CALL_OW 67
// p := p + 1 ;
111485: LD_ADDR_VAR 0 1
111489: PUSH
111490: LD_VAR 0 1
111494: PUSH
111495: LD_INT 1
111497: PLUS
111498: ST_TO_ADDR
// until p >= 60 ;
111499: LD_VAR 0 1
111503: PUSH
111504: LD_INT 60
111506: GREATEREQUAL
111507: IFFALSE 111470
// game_speed := 4 ;
111509: LD_ADDR_OWVAR 65
111513: PUSH
111514: LD_INT 4
111516: ST_TO_ADDR
// end ;
111517: PPOPN 1
111519: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
111520: LD_EXP 160
111524: PUSH
111525: LD_EXP 187
111529: AND
111530: IFFALSE 111676
111532: GO 111534
111534: DISABLE
111535: LD_INT 0
111537: PPUSH
111538: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
111539: LD_ADDR_VAR 0 1
111543: PUSH
111544: LD_INT 22
111546: PUSH
111547: LD_OWVAR 2
111551: PUSH
111552: EMPTY
111553: LIST
111554: LIST
111555: PUSH
111556: LD_INT 2
111558: PUSH
111559: LD_INT 30
111561: PUSH
111562: LD_INT 0
111564: PUSH
111565: EMPTY
111566: LIST
111567: LIST
111568: PUSH
111569: LD_INT 30
111571: PUSH
111572: LD_INT 1
111574: PUSH
111575: EMPTY
111576: LIST
111577: LIST
111578: PUSH
111579: EMPTY
111580: LIST
111581: LIST
111582: LIST
111583: PUSH
111584: EMPTY
111585: LIST
111586: LIST
111587: PPUSH
111588: CALL_OW 69
111592: ST_TO_ADDR
// if not depot then
111593: LD_VAR 0 1
111597: NOT
111598: IFFALSE 111602
// exit ;
111600: GO 111676
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
111602: LD_ADDR_VAR 0 2
111606: PUSH
111607: LD_VAR 0 1
111611: PUSH
111612: LD_INT 1
111614: PPUSH
111615: LD_VAR 0 1
111619: PPUSH
111620: CALL_OW 12
111624: ARRAY
111625: PPUSH
111626: CALL_OW 274
111630: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
111631: LD_VAR 0 2
111635: PPUSH
111636: LD_INT 1
111638: PPUSH
111639: LD_INT 0
111641: PPUSH
111642: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
111646: LD_VAR 0 2
111650: PPUSH
111651: LD_INT 2
111653: PPUSH
111654: LD_INT 0
111656: PPUSH
111657: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
111661: LD_VAR 0 2
111665: PPUSH
111666: LD_INT 3
111668: PPUSH
111669: LD_INT 0
111671: PPUSH
111672: CALL_OW 277
// end ;
111676: PPOPN 2
111678: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
111679: LD_EXP 160
111683: PUSH
111684: LD_EXP 188
111688: AND
111689: IFFALSE 111786
111691: GO 111693
111693: DISABLE
111694: LD_INT 0
111696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111697: LD_ADDR_VAR 0 1
111701: PUSH
111702: LD_INT 22
111704: PUSH
111705: LD_OWVAR 2
111709: PUSH
111710: EMPTY
111711: LIST
111712: LIST
111713: PUSH
111714: LD_INT 21
111716: PUSH
111717: LD_INT 1
111719: PUSH
111720: EMPTY
111721: LIST
111722: LIST
111723: PUSH
111724: LD_INT 3
111726: PUSH
111727: LD_INT 23
111729: PUSH
111730: LD_INT 0
111732: PUSH
111733: EMPTY
111734: LIST
111735: LIST
111736: PUSH
111737: EMPTY
111738: LIST
111739: LIST
111740: PUSH
111741: EMPTY
111742: LIST
111743: LIST
111744: LIST
111745: PPUSH
111746: CALL_OW 69
111750: ST_TO_ADDR
// if not tmp then
111751: LD_VAR 0 1
111755: NOT
111756: IFFALSE 111760
// exit ;
111758: GO 111786
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
111760: LD_VAR 0 1
111764: PUSH
111765: LD_INT 1
111767: PPUSH
111768: LD_VAR 0 1
111772: PPUSH
111773: CALL_OW 12
111777: ARRAY
111778: PPUSH
111779: LD_INT 200
111781: PPUSH
111782: CALL_OW 234
// end ;
111786: PPOPN 1
111788: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
111789: LD_EXP 160
111793: PUSH
111794: LD_EXP 189
111798: AND
111799: IFFALSE 111878
111801: GO 111803
111803: DISABLE
111804: LD_INT 0
111806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
111807: LD_ADDR_VAR 0 1
111811: PUSH
111812: LD_INT 22
111814: PUSH
111815: LD_OWVAR 2
111819: PUSH
111820: EMPTY
111821: LIST
111822: LIST
111823: PUSH
111824: LD_INT 21
111826: PUSH
111827: LD_INT 2
111829: PUSH
111830: EMPTY
111831: LIST
111832: LIST
111833: PUSH
111834: EMPTY
111835: LIST
111836: LIST
111837: PPUSH
111838: CALL_OW 69
111842: ST_TO_ADDR
// if not tmp then
111843: LD_VAR 0 1
111847: NOT
111848: IFFALSE 111852
// exit ;
111850: GO 111878
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
111852: LD_VAR 0 1
111856: PUSH
111857: LD_INT 1
111859: PPUSH
111860: LD_VAR 0 1
111864: PPUSH
111865: CALL_OW 12
111869: ARRAY
111870: PPUSH
111871: LD_INT 60
111873: PPUSH
111874: CALL_OW 234
// end ;
111878: PPOPN 1
111880: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
111881: LD_EXP 160
111885: PUSH
111886: LD_EXP 190
111890: AND
111891: IFFALSE 111990
111893: GO 111895
111895: DISABLE
111896: LD_INT 0
111898: PPUSH
111899: PPUSH
// begin enable ;
111900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
111901: LD_ADDR_VAR 0 1
111905: PUSH
111906: LD_INT 22
111908: PUSH
111909: LD_OWVAR 2
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: PUSH
111918: LD_INT 61
111920: PUSH
111921: EMPTY
111922: LIST
111923: PUSH
111924: LD_INT 33
111926: PUSH
111927: LD_INT 2
111929: PUSH
111930: EMPTY
111931: LIST
111932: LIST
111933: PUSH
111934: EMPTY
111935: LIST
111936: LIST
111937: LIST
111938: PPUSH
111939: CALL_OW 69
111943: ST_TO_ADDR
// if not tmp then
111944: LD_VAR 0 1
111948: NOT
111949: IFFALSE 111953
// exit ;
111951: GO 111990
// for i in tmp do
111953: LD_ADDR_VAR 0 2
111957: PUSH
111958: LD_VAR 0 1
111962: PUSH
111963: FOR_IN
111964: IFFALSE 111988
// if IsControledBy ( i ) then
111966: LD_VAR 0 2
111970: PPUSH
111971: CALL_OW 312
111975: IFFALSE 111986
// ComUnlink ( i ) ;
111977: LD_VAR 0 2
111981: PPUSH
111982: CALL_OW 136
111986: GO 111963
111988: POP
111989: POP
// end ;
111990: PPOPN 2
111992: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
111993: LD_EXP 160
111997: PUSH
111998: LD_EXP 191
112002: AND
112003: IFFALSE 112143
112005: GO 112007
112007: DISABLE
112008: LD_INT 0
112010: PPUSH
112011: PPUSH
// begin ToLua ( displayPowell(); ) ;
112012: LD_STRING displayPowell();
112014: PPUSH
112015: CALL_OW 559
// uc_side := 0 ;
112019: LD_ADDR_OWVAR 20
112023: PUSH
112024: LD_INT 0
112026: ST_TO_ADDR
// uc_nation := 2 ;
112027: LD_ADDR_OWVAR 21
112031: PUSH
112032: LD_INT 2
112034: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
112035: LD_ADDR_OWVAR 37
112039: PUSH
112040: LD_INT 14
112042: ST_TO_ADDR
// vc_engine := engine_siberite ;
112043: LD_ADDR_OWVAR 39
112047: PUSH
112048: LD_INT 3
112050: ST_TO_ADDR
// vc_control := control_apeman ;
112051: LD_ADDR_OWVAR 38
112055: PUSH
112056: LD_INT 5
112058: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
112059: LD_ADDR_OWVAR 40
112063: PUSH
112064: LD_INT 29
112066: ST_TO_ADDR
// un := CreateVehicle ;
112067: LD_ADDR_VAR 0 2
112071: PUSH
112072: CALL_OW 45
112076: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112077: LD_VAR 0 2
112081: PPUSH
112082: LD_INT 1
112084: PPUSH
112085: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
112089: LD_INT 35
112091: PPUSH
112092: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
112096: LD_VAR 0 2
112100: PPUSH
112101: LD_INT 22
112103: PUSH
112104: LD_OWVAR 2
112108: PUSH
112109: EMPTY
112110: LIST
112111: LIST
112112: PPUSH
112113: CALL_OW 69
112117: PPUSH
112118: LD_VAR 0 2
112122: PPUSH
112123: CALL_OW 74
112127: PPUSH
112128: CALL_OW 115
// until IsDead ( un ) ;
112132: LD_VAR 0 2
112136: PPUSH
112137: CALL_OW 301
112141: IFFALSE 112089
// end ;
112143: PPOPN 2
112145: END
// every 0 0$1 trigger StreamModeActive and sStu do
112146: LD_EXP 160
112150: PUSH
112151: LD_EXP 199
112155: AND
112156: IFFALSE 112172
112158: GO 112160
112160: DISABLE
// begin ToLua ( displayStucuk(); ) ;
112161: LD_STRING displayStucuk();
112163: PPUSH
112164: CALL_OW 559
// ResetFog ;
112168: CALL_OW 335
// end ;
112172: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
112173: LD_EXP 160
112177: PUSH
112178: LD_EXP 192
112182: AND
112183: IFFALSE 112324
112185: GO 112187
112187: DISABLE
112188: LD_INT 0
112190: PPUSH
112191: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112192: LD_ADDR_VAR 0 2
112196: PUSH
112197: LD_INT 22
112199: PUSH
112200: LD_OWVAR 2
112204: PUSH
112205: EMPTY
112206: LIST
112207: LIST
112208: PUSH
112209: LD_INT 21
112211: PUSH
112212: LD_INT 1
112214: PUSH
112215: EMPTY
112216: LIST
112217: LIST
112218: PUSH
112219: EMPTY
112220: LIST
112221: LIST
112222: PPUSH
112223: CALL_OW 69
112227: ST_TO_ADDR
// if not tmp then
112228: LD_VAR 0 2
112232: NOT
112233: IFFALSE 112237
// exit ;
112235: GO 112324
// un := tmp [ rand ( 1 , tmp ) ] ;
112237: LD_ADDR_VAR 0 1
112241: PUSH
112242: LD_VAR 0 2
112246: PUSH
112247: LD_INT 1
112249: PPUSH
112250: LD_VAR 0 2
112254: PPUSH
112255: CALL_OW 12
112259: ARRAY
112260: ST_TO_ADDR
// SetSide ( un , 0 ) ;
112261: LD_VAR 0 1
112265: PPUSH
112266: LD_INT 0
112268: PPUSH
112269: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
112273: LD_VAR 0 1
112277: PPUSH
112278: LD_OWVAR 3
112282: PUSH
112283: LD_VAR 0 1
112287: DIFF
112288: PPUSH
112289: LD_VAR 0 1
112293: PPUSH
112294: CALL_OW 74
112298: PPUSH
112299: CALL_OW 115
// wait ( 0 0$20 ) ;
112303: LD_INT 700
112305: PPUSH
112306: CALL_OW 67
// SetSide ( un , your_side ) ;
112310: LD_VAR 0 1
112314: PPUSH
112315: LD_OWVAR 2
112319: PPUSH
112320: CALL_OW 235
// end ;
112324: PPOPN 2
112326: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
112327: LD_EXP 160
112331: PUSH
112332: LD_EXP 193
112336: AND
112337: IFFALSE 112443
112339: GO 112341
112341: DISABLE
112342: LD_INT 0
112344: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
112345: LD_ADDR_VAR 0 1
112349: PUSH
112350: LD_INT 22
112352: PUSH
112353: LD_OWVAR 2
112357: PUSH
112358: EMPTY
112359: LIST
112360: LIST
112361: PUSH
112362: LD_INT 2
112364: PUSH
112365: LD_INT 30
112367: PUSH
112368: LD_INT 0
112370: PUSH
112371: EMPTY
112372: LIST
112373: LIST
112374: PUSH
112375: LD_INT 30
112377: PUSH
112378: LD_INT 1
112380: PUSH
112381: EMPTY
112382: LIST
112383: LIST
112384: PUSH
112385: EMPTY
112386: LIST
112387: LIST
112388: LIST
112389: PUSH
112390: EMPTY
112391: LIST
112392: LIST
112393: PPUSH
112394: CALL_OW 69
112398: ST_TO_ADDR
// if not depot then
112399: LD_VAR 0 1
112403: NOT
112404: IFFALSE 112408
// exit ;
112406: GO 112443
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
112408: LD_VAR 0 1
112412: PUSH
112413: LD_INT 1
112415: ARRAY
112416: PPUSH
112417: CALL_OW 250
112421: PPUSH
112422: LD_VAR 0 1
112426: PUSH
112427: LD_INT 1
112429: ARRAY
112430: PPUSH
112431: CALL_OW 251
112435: PPUSH
112436: LD_INT 70
112438: PPUSH
112439: CALL_OW 495
// end ;
112443: PPOPN 1
112445: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
112446: LD_EXP 160
112450: PUSH
112451: LD_EXP 194
112455: AND
112456: IFFALSE 112667
112458: GO 112460
112460: DISABLE
112461: LD_INT 0
112463: PPUSH
112464: PPUSH
112465: PPUSH
112466: PPUSH
112467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112468: LD_ADDR_VAR 0 5
112472: PUSH
112473: LD_INT 22
112475: PUSH
112476: LD_OWVAR 2
112480: PUSH
112481: EMPTY
112482: LIST
112483: LIST
112484: PUSH
112485: LD_INT 21
112487: PUSH
112488: LD_INT 1
112490: PUSH
112491: EMPTY
112492: LIST
112493: LIST
112494: PUSH
112495: EMPTY
112496: LIST
112497: LIST
112498: PPUSH
112499: CALL_OW 69
112503: ST_TO_ADDR
// if not tmp then
112504: LD_VAR 0 5
112508: NOT
112509: IFFALSE 112513
// exit ;
112511: GO 112667
// for i in tmp do
112513: LD_ADDR_VAR 0 1
112517: PUSH
112518: LD_VAR 0 5
112522: PUSH
112523: FOR_IN
112524: IFFALSE 112665
// begin d := rand ( 0 , 5 ) ;
112526: LD_ADDR_VAR 0 4
112530: PUSH
112531: LD_INT 0
112533: PPUSH
112534: LD_INT 5
112536: PPUSH
112537: CALL_OW 12
112541: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
112542: LD_ADDR_VAR 0 2
112546: PUSH
112547: LD_VAR 0 1
112551: PPUSH
112552: CALL_OW 250
112556: PPUSH
112557: LD_VAR 0 4
112561: PPUSH
112562: LD_INT 3
112564: PPUSH
112565: LD_INT 12
112567: PPUSH
112568: CALL_OW 12
112572: PPUSH
112573: CALL_OW 272
112577: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
112578: LD_ADDR_VAR 0 3
112582: PUSH
112583: LD_VAR 0 1
112587: PPUSH
112588: CALL_OW 251
112592: PPUSH
112593: LD_VAR 0 4
112597: PPUSH
112598: LD_INT 3
112600: PPUSH
112601: LD_INT 12
112603: PPUSH
112604: CALL_OW 12
112608: PPUSH
112609: CALL_OW 273
112613: ST_TO_ADDR
// if ValidHex ( x , y ) then
112614: LD_VAR 0 2
112618: PPUSH
112619: LD_VAR 0 3
112623: PPUSH
112624: CALL_OW 488
112628: IFFALSE 112663
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
112630: LD_VAR 0 1
112634: PPUSH
112635: LD_VAR 0 2
112639: PPUSH
112640: LD_VAR 0 3
112644: PPUSH
112645: LD_INT 3
112647: PPUSH
112648: LD_INT 6
112650: PPUSH
112651: CALL_OW 12
112655: PPUSH
112656: LD_INT 1
112658: PPUSH
112659: CALL_OW 483
// end ;
112663: GO 112523
112665: POP
112666: POP
// end ;
112667: PPOPN 5
112669: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
112670: LD_EXP 160
112674: PUSH
112675: LD_EXP 195
112679: AND
112680: IFFALSE 112774
112682: GO 112684
112684: DISABLE
112685: LD_INT 0
112687: PPUSH
112688: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
112689: LD_ADDR_VAR 0 2
112693: PUSH
112694: LD_INT 22
112696: PUSH
112697: LD_OWVAR 2
112701: PUSH
112702: EMPTY
112703: LIST
112704: LIST
112705: PUSH
112706: LD_INT 32
112708: PUSH
112709: LD_INT 1
112711: PUSH
112712: EMPTY
112713: LIST
112714: LIST
112715: PUSH
112716: LD_INT 21
112718: PUSH
112719: LD_INT 2
112721: PUSH
112722: EMPTY
112723: LIST
112724: LIST
112725: PUSH
112726: EMPTY
112727: LIST
112728: LIST
112729: LIST
112730: PPUSH
112731: CALL_OW 69
112735: ST_TO_ADDR
// if not tmp then
112736: LD_VAR 0 2
112740: NOT
112741: IFFALSE 112745
// exit ;
112743: GO 112774
// for i in tmp do
112745: LD_ADDR_VAR 0 1
112749: PUSH
112750: LD_VAR 0 2
112754: PUSH
112755: FOR_IN
112756: IFFALSE 112772
// SetFuel ( i , 0 ) ;
112758: LD_VAR 0 1
112762: PPUSH
112763: LD_INT 0
112765: PPUSH
112766: CALL_OW 240
112770: GO 112755
112772: POP
112773: POP
// end ;
112774: PPOPN 2
112776: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
112777: LD_EXP 160
112781: PUSH
112782: LD_EXP 196
112786: AND
112787: IFFALSE 112853
112789: GO 112791
112791: DISABLE
112792: LD_INT 0
112794: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
112795: LD_ADDR_VAR 0 1
112799: PUSH
112800: LD_INT 22
112802: PUSH
112803: LD_OWVAR 2
112807: PUSH
112808: EMPTY
112809: LIST
112810: LIST
112811: PUSH
112812: LD_INT 30
112814: PUSH
112815: LD_INT 29
112817: PUSH
112818: EMPTY
112819: LIST
112820: LIST
112821: PUSH
112822: EMPTY
112823: LIST
112824: LIST
112825: PPUSH
112826: CALL_OW 69
112830: ST_TO_ADDR
// if not tmp then
112831: LD_VAR 0 1
112835: NOT
112836: IFFALSE 112840
// exit ;
112838: GO 112853
// DestroyUnit ( tmp [ 1 ] ) ;
112840: LD_VAR 0 1
112844: PUSH
112845: LD_INT 1
112847: ARRAY
112848: PPUSH
112849: CALL_OW 65
// end ;
112853: PPOPN 1
112855: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
112856: LD_EXP 160
112860: PUSH
112861: LD_EXP 198
112865: AND
112866: IFFALSE 112995
112868: GO 112870
112870: DISABLE
112871: LD_INT 0
112873: PPUSH
// begin uc_side := 0 ;
112874: LD_ADDR_OWVAR 20
112878: PUSH
112879: LD_INT 0
112881: ST_TO_ADDR
// uc_nation := nation_arabian ;
112882: LD_ADDR_OWVAR 21
112886: PUSH
112887: LD_INT 2
112889: ST_TO_ADDR
// hc_gallery :=  ;
112890: LD_ADDR_OWVAR 33
112894: PUSH
112895: LD_STRING 
112897: ST_TO_ADDR
// hc_name :=  ;
112898: LD_ADDR_OWVAR 26
112902: PUSH
112903: LD_STRING 
112905: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
112906: LD_INT 1
112908: PPUSH
112909: LD_INT 11
112911: PPUSH
112912: LD_INT 10
112914: PPUSH
112915: CALL_OW 380
// un := CreateHuman ;
112919: LD_ADDR_VAR 0 1
112923: PUSH
112924: CALL_OW 44
112928: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112929: LD_VAR 0 1
112933: PPUSH
112934: LD_INT 1
112936: PPUSH
112937: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
112941: LD_INT 35
112943: PPUSH
112944: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
112948: LD_VAR 0 1
112952: PPUSH
112953: LD_INT 22
112955: PUSH
112956: LD_OWVAR 2
112960: PUSH
112961: EMPTY
112962: LIST
112963: LIST
112964: PPUSH
112965: CALL_OW 69
112969: PPUSH
112970: LD_VAR 0 1
112974: PPUSH
112975: CALL_OW 74
112979: PPUSH
112980: CALL_OW 115
// until IsDead ( un ) ;
112984: LD_VAR 0 1
112988: PPUSH
112989: CALL_OW 301
112993: IFFALSE 112941
// end ;
112995: PPOPN 1
112997: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
112998: LD_EXP 160
113002: PUSH
113003: LD_EXP 200
113007: AND
113008: IFFALSE 113020
113010: GO 113012
113012: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
113013: LD_STRING earthquake(getX(game), 0, 32)
113015: PPUSH
113016: CALL_OW 559
113020: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
113021: LD_EXP 160
113025: PUSH
113026: LD_EXP 201
113030: AND
113031: IFFALSE 113122
113033: GO 113035
113035: DISABLE
113036: LD_INT 0
113038: PPUSH
// begin enable ;
113039: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
113040: LD_ADDR_VAR 0 1
113044: PUSH
113045: LD_INT 22
113047: PUSH
113048: LD_OWVAR 2
113052: PUSH
113053: EMPTY
113054: LIST
113055: LIST
113056: PUSH
113057: LD_INT 21
113059: PUSH
113060: LD_INT 2
113062: PUSH
113063: EMPTY
113064: LIST
113065: LIST
113066: PUSH
113067: LD_INT 33
113069: PUSH
113070: LD_INT 3
113072: PUSH
113073: EMPTY
113074: LIST
113075: LIST
113076: PUSH
113077: EMPTY
113078: LIST
113079: LIST
113080: LIST
113081: PPUSH
113082: CALL_OW 69
113086: ST_TO_ADDR
// if not tmp then
113087: LD_VAR 0 1
113091: NOT
113092: IFFALSE 113096
// exit ;
113094: GO 113122
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
113096: LD_VAR 0 1
113100: PUSH
113101: LD_INT 1
113103: PPUSH
113104: LD_VAR 0 1
113108: PPUSH
113109: CALL_OW 12
113113: ARRAY
113114: PPUSH
113115: LD_INT 1
113117: PPUSH
113118: CALL_OW 234
// end ;
113122: PPOPN 1
113124: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
113125: LD_EXP 160
113129: PUSH
113130: LD_EXP 202
113134: AND
113135: IFFALSE 113276
113137: GO 113139
113139: DISABLE
113140: LD_INT 0
113142: PPUSH
113143: PPUSH
113144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113145: LD_ADDR_VAR 0 3
113149: PUSH
113150: LD_INT 22
113152: PUSH
113153: LD_OWVAR 2
113157: PUSH
113158: EMPTY
113159: LIST
113160: LIST
113161: PUSH
113162: LD_INT 25
113164: PUSH
113165: LD_INT 1
113167: PUSH
113168: EMPTY
113169: LIST
113170: LIST
113171: PUSH
113172: EMPTY
113173: LIST
113174: LIST
113175: PPUSH
113176: CALL_OW 69
113180: ST_TO_ADDR
// if not tmp then
113181: LD_VAR 0 3
113185: NOT
113186: IFFALSE 113190
// exit ;
113188: GO 113276
// un := tmp [ rand ( 1 , tmp ) ] ;
113190: LD_ADDR_VAR 0 2
113194: PUSH
113195: LD_VAR 0 3
113199: PUSH
113200: LD_INT 1
113202: PPUSH
113203: LD_VAR 0 3
113207: PPUSH
113208: CALL_OW 12
113212: ARRAY
113213: ST_TO_ADDR
// if Crawls ( un ) then
113214: LD_VAR 0 2
113218: PPUSH
113219: CALL_OW 318
113223: IFFALSE 113234
// ComWalk ( un ) ;
113225: LD_VAR 0 2
113229: PPUSH
113230: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
113234: LD_VAR 0 2
113238: PPUSH
113239: LD_INT 9
113241: PPUSH
113242: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
113246: LD_INT 28
113248: PPUSH
113249: LD_OWVAR 2
113253: PPUSH
113254: LD_INT 2
113256: PPUSH
113257: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
113261: LD_INT 29
113263: PPUSH
113264: LD_OWVAR 2
113268: PPUSH
113269: LD_INT 2
113271: PPUSH
113272: CALL_OW 322
// end ;
113276: PPOPN 3
113278: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
113279: LD_EXP 160
113283: PUSH
113284: LD_EXP 203
113288: AND
113289: IFFALSE 113400
113291: GO 113293
113293: DISABLE
113294: LD_INT 0
113296: PPUSH
113297: PPUSH
113298: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
113299: LD_ADDR_VAR 0 3
113303: PUSH
113304: LD_INT 22
113306: PUSH
113307: LD_OWVAR 2
113311: PUSH
113312: EMPTY
113313: LIST
113314: LIST
113315: PUSH
113316: LD_INT 25
113318: PUSH
113319: LD_INT 1
113321: PUSH
113322: EMPTY
113323: LIST
113324: LIST
113325: PUSH
113326: EMPTY
113327: LIST
113328: LIST
113329: PPUSH
113330: CALL_OW 69
113334: ST_TO_ADDR
// if not tmp then
113335: LD_VAR 0 3
113339: NOT
113340: IFFALSE 113344
// exit ;
113342: GO 113400
// un := tmp [ rand ( 1 , tmp ) ] ;
113344: LD_ADDR_VAR 0 2
113348: PUSH
113349: LD_VAR 0 3
113353: PUSH
113354: LD_INT 1
113356: PPUSH
113357: LD_VAR 0 3
113361: PPUSH
113362: CALL_OW 12
113366: ARRAY
113367: ST_TO_ADDR
// if Crawls ( un ) then
113368: LD_VAR 0 2
113372: PPUSH
113373: CALL_OW 318
113377: IFFALSE 113388
// ComWalk ( un ) ;
113379: LD_VAR 0 2
113383: PPUSH
113384: CALL_OW 138
// SetClass ( un , class_mortar ) ;
113388: LD_VAR 0 2
113392: PPUSH
113393: LD_INT 8
113395: PPUSH
113396: CALL_OW 336
// end ;
113400: PPOPN 3
113402: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
113403: LD_EXP 160
113407: PUSH
113408: LD_EXP 204
113412: AND
113413: IFFALSE 113557
113415: GO 113417
113417: DISABLE
113418: LD_INT 0
113420: PPUSH
113421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
113422: LD_ADDR_VAR 0 2
113426: PUSH
113427: LD_INT 22
113429: PUSH
113430: LD_OWVAR 2
113434: PUSH
113435: EMPTY
113436: LIST
113437: LIST
113438: PUSH
113439: LD_INT 21
113441: PUSH
113442: LD_INT 2
113444: PUSH
113445: EMPTY
113446: LIST
113447: LIST
113448: PUSH
113449: LD_INT 2
113451: PUSH
113452: LD_INT 34
113454: PUSH
113455: LD_INT 12
113457: PUSH
113458: EMPTY
113459: LIST
113460: LIST
113461: PUSH
113462: LD_INT 34
113464: PUSH
113465: LD_INT 51
113467: PUSH
113468: EMPTY
113469: LIST
113470: LIST
113471: PUSH
113472: LD_INT 34
113474: PUSH
113475: LD_INT 32
113477: PUSH
113478: EMPTY
113479: LIST
113480: LIST
113481: PUSH
113482: EMPTY
113483: LIST
113484: LIST
113485: LIST
113486: LIST
113487: PUSH
113488: EMPTY
113489: LIST
113490: LIST
113491: LIST
113492: PPUSH
113493: CALL_OW 69
113497: ST_TO_ADDR
// if not tmp then
113498: LD_VAR 0 2
113502: NOT
113503: IFFALSE 113507
// exit ;
113505: GO 113557
// for i in tmp do
113507: LD_ADDR_VAR 0 1
113511: PUSH
113512: LD_VAR 0 2
113516: PUSH
113517: FOR_IN
113518: IFFALSE 113555
// if GetCargo ( i , mat_artifact ) = 0 then
113520: LD_VAR 0 1
113524: PPUSH
113525: LD_INT 4
113527: PPUSH
113528: CALL_OW 289
113532: PUSH
113533: LD_INT 0
113535: EQUAL
113536: IFFALSE 113553
// SetCargo ( i , mat_siberit , 100 ) ;
113538: LD_VAR 0 1
113542: PPUSH
113543: LD_INT 3
113545: PPUSH
113546: LD_INT 100
113548: PPUSH
113549: CALL_OW 290
113553: GO 113517
113555: POP
113556: POP
// end ;
113557: PPOPN 2
113559: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
113560: LD_EXP 160
113564: PUSH
113565: LD_EXP 205
113569: AND
113570: IFFALSE 113753
113572: GO 113574
113574: DISABLE
113575: LD_INT 0
113577: PPUSH
113578: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
113579: LD_ADDR_VAR 0 2
113583: PUSH
113584: LD_INT 22
113586: PUSH
113587: LD_OWVAR 2
113591: PUSH
113592: EMPTY
113593: LIST
113594: LIST
113595: PPUSH
113596: CALL_OW 69
113600: ST_TO_ADDR
// if not tmp then
113601: LD_VAR 0 2
113605: NOT
113606: IFFALSE 113610
// exit ;
113608: GO 113753
// for i := 1 to 2 do
113610: LD_ADDR_VAR 0 1
113614: PUSH
113615: DOUBLE
113616: LD_INT 1
113618: DEC
113619: ST_TO_ADDR
113620: LD_INT 2
113622: PUSH
113623: FOR_TO
113624: IFFALSE 113751
// begin uc_side := your_side ;
113626: LD_ADDR_OWVAR 20
113630: PUSH
113631: LD_OWVAR 2
113635: ST_TO_ADDR
// uc_nation := nation_american ;
113636: LD_ADDR_OWVAR 21
113640: PUSH
113641: LD_INT 1
113643: ST_TO_ADDR
// vc_chassis := us_morphling ;
113644: LD_ADDR_OWVAR 37
113648: PUSH
113649: LD_INT 5
113651: ST_TO_ADDR
// vc_engine := engine_siberite ;
113652: LD_ADDR_OWVAR 39
113656: PUSH
113657: LD_INT 3
113659: ST_TO_ADDR
// vc_control := control_computer ;
113660: LD_ADDR_OWVAR 38
113664: PUSH
113665: LD_INT 3
113667: ST_TO_ADDR
// vc_weapon := us_double_laser ;
113668: LD_ADDR_OWVAR 40
113672: PUSH
113673: LD_INT 10
113675: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
113676: LD_VAR 0 2
113680: PUSH
113681: LD_INT 1
113683: ARRAY
113684: PPUSH
113685: CALL_OW 310
113689: NOT
113690: IFFALSE 113737
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
113692: CALL_OW 45
113696: PPUSH
113697: LD_VAR 0 2
113701: PUSH
113702: LD_INT 1
113704: ARRAY
113705: PPUSH
113706: CALL_OW 250
113710: PPUSH
113711: LD_VAR 0 2
113715: PUSH
113716: LD_INT 1
113718: ARRAY
113719: PPUSH
113720: CALL_OW 251
113724: PPUSH
113725: LD_INT 12
113727: PPUSH
113728: LD_INT 1
113730: PPUSH
113731: CALL_OW 50
113735: GO 113749
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
113737: CALL_OW 45
113741: PPUSH
113742: LD_INT 1
113744: PPUSH
113745: CALL_OW 51
// end ;
113749: GO 113623
113751: POP
113752: POP
// end ;
113753: PPOPN 2
113755: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
113756: LD_EXP 160
113760: PUSH
113761: LD_EXP 206
113765: AND
113766: IFFALSE 113988
113768: GO 113770
113770: DISABLE
113771: LD_INT 0
113773: PPUSH
113774: PPUSH
113775: PPUSH
113776: PPUSH
113777: PPUSH
113778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
113779: LD_ADDR_VAR 0 6
113783: PUSH
113784: LD_INT 22
113786: PUSH
113787: LD_OWVAR 2
113791: PUSH
113792: EMPTY
113793: LIST
113794: LIST
113795: PUSH
113796: LD_INT 21
113798: PUSH
113799: LD_INT 1
113801: PUSH
113802: EMPTY
113803: LIST
113804: LIST
113805: PUSH
113806: LD_INT 3
113808: PUSH
113809: LD_INT 23
113811: PUSH
113812: LD_INT 0
113814: PUSH
113815: EMPTY
113816: LIST
113817: LIST
113818: PUSH
113819: EMPTY
113820: LIST
113821: LIST
113822: PUSH
113823: EMPTY
113824: LIST
113825: LIST
113826: LIST
113827: PPUSH
113828: CALL_OW 69
113832: ST_TO_ADDR
// if not tmp then
113833: LD_VAR 0 6
113837: NOT
113838: IFFALSE 113842
// exit ;
113840: GO 113988
// s1 := rand ( 1 , 4 ) ;
113842: LD_ADDR_VAR 0 2
113846: PUSH
113847: LD_INT 1
113849: PPUSH
113850: LD_INT 4
113852: PPUSH
113853: CALL_OW 12
113857: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
113858: LD_ADDR_VAR 0 4
113862: PUSH
113863: LD_VAR 0 6
113867: PUSH
113868: LD_INT 1
113870: ARRAY
113871: PPUSH
113872: LD_VAR 0 2
113876: PPUSH
113877: CALL_OW 259
113881: ST_TO_ADDR
// if s1 = 1 then
113882: LD_VAR 0 2
113886: PUSH
113887: LD_INT 1
113889: EQUAL
113890: IFFALSE 113910
// s2 := rand ( 2 , 4 ) else
113892: LD_ADDR_VAR 0 3
113896: PUSH
113897: LD_INT 2
113899: PPUSH
113900: LD_INT 4
113902: PPUSH
113903: CALL_OW 12
113907: ST_TO_ADDR
113908: GO 113918
// s2 := 1 ;
113910: LD_ADDR_VAR 0 3
113914: PUSH
113915: LD_INT 1
113917: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
113918: LD_ADDR_VAR 0 5
113922: PUSH
113923: LD_VAR 0 6
113927: PUSH
113928: LD_INT 1
113930: ARRAY
113931: PPUSH
113932: LD_VAR 0 3
113936: PPUSH
113937: CALL_OW 259
113941: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
113942: LD_VAR 0 6
113946: PUSH
113947: LD_INT 1
113949: ARRAY
113950: PPUSH
113951: LD_VAR 0 2
113955: PPUSH
113956: LD_VAR 0 5
113960: PPUSH
113961: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
113965: LD_VAR 0 6
113969: PUSH
113970: LD_INT 1
113972: ARRAY
113973: PPUSH
113974: LD_VAR 0 3
113978: PPUSH
113979: LD_VAR 0 4
113983: PPUSH
113984: CALL_OW 237
// end ;
113988: PPOPN 6
113990: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
113991: LD_EXP 160
113995: PUSH
113996: LD_EXP 207
114000: AND
114001: IFFALSE 114080
114003: GO 114005
114005: DISABLE
114006: LD_INT 0
114008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
114009: LD_ADDR_VAR 0 1
114013: PUSH
114014: LD_INT 22
114016: PUSH
114017: LD_OWVAR 2
114021: PUSH
114022: EMPTY
114023: LIST
114024: LIST
114025: PUSH
114026: LD_INT 30
114028: PUSH
114029: LD_INT 3
114031: PUSH
114032: EMPTY
114033: LIST
114034: LIST
114035: PUSH
114036: EMPTY
114037: LIST
114038: LIST
114039: PPUSH
114040: CALL_OW 69
114044: ST_TO_ADDR
// if not tmp then
114045: LD_VAR 0 1
114049: NOT
114050: IFFALSE 114054
// exit ;
114052: GO 114080
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
114054: LD_VAR 0 1
114058: PUSH
114059: LD_INT 1
114061: PPUSH
114062: LD_VAR 0 1
114066: PPUSH
114067: CALL_OW 12
114071: ARRAY
114072: PPUSH
114073: LD_INT 1
114075: PPUSH
114076: CALL_OW 234
// end ;
114080: PPOPN 1
114082: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
114083: LD_EXP 160
114087: PUSH
114088: LD_EXP 208
114092: AND
114093: IFFALSE 114205
114095: GO 114097
114097: DISABLE
114098: LD_INT 0
114100: PPUSH
114101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
114102: LD_ADDR_VAR 0 2
114106: PUSH
114107: LD_INT 22
114109: PUSH
114110: LD_OWVAR 2
114114: PUSH
114115: EMPTY
114116: LIST
114117: LIST
114118: PUSH
114119: LD_INT 2
114121: PUSH
114122: LD_INT 30
114124: PUSH
114125: LD_INT 27
114127: PUSH
114128: EMPTY
114129: LIST
114130: LIST
114131: PUSH
114132: LD_INT 30
114134: PUSH
114135: LD_INT 26
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: PUSH
114142: LD_INT 30
114144: PUSH
114145: LD_INT 28
114147: PUSH
114148: EMPTY
114149: LIST
114150: LIST
114151: PUSH
114152: EMPTY
114153: LIST
114154: LIST
114155: LIST
114156: LIST
114157: PUSH
114158: EMPTY
114159: LIST
114160: LIST
114161: PPUSH
114162: CALL_OW 69
114166: ST_TO_ADDR
// if not tmp then
114167: LD_VAR 0 2
114171: NOT
114172: IFFALSE 114176
// exit ;
114174: GO 114205
// for i in tmp do
114176: LD_ADDR_VAR 0 1
114180: PUSH
114181: LD_VAR 0 2
114185: PUSH
114186: FOR_IN
114187: IFFALSE 114203
// SetLives ( i , 1 ) ;
114189: LD_VAR 0 1
114193: PPUSH
114194: LD_INT 1
114196: PPUSH
114197: CALL_OW 234
114201: GO 114186
114203: POP
114204: POP
// end ;
114205: PPOPN 2
114207: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
114208: LD_EXP 160
114212: PUSH
114213: LD_EXP 209
114217: AND
114218: IFFALSE 114492
114220: GO 114222
114222: DISABLE
114223: LD_INT 0
114225: PPUSH
114226: PPUSH
114227: PPUSH
// begin i := rand ( 1 , 7 ) ;
114228: LD_ADDR_VAR 0 1
114232: PUSH
114233: LD_INT 1
114235: PPUSH
114236: LD_INT 7
114238: PPUSH
114239: CALL_OW 12
114243: ST_TO_ADDR
// case i of 1 :
114244: LD_VAR 0 1
114248: PUSH
114249: LD_INT 1
114251: DOUBLE
114252: EQUAL
114253: IFTRUE 114257
114255: GO 114267
114257: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
114258: LD_STRING earthquake(getX(game), 0, 32)
114260: PPUSH
114261: CALL_OW 559
114265: GO 114492
114267: LD_INT 2
114269: DOUBLE
114270: EQUAL
114271: IFTRUE 114275
114273: GO 114289
114275: POP
// begin ToLua ( displayStucuk(); ) ;
114276: LD_STRING displayStucuk();
114278: PPUSH
114279: CALL_OW 559
// ResetFog ;
114283: CALL_OW 335
// end ; 3 :
114287: GO 114492
114289: LD_INT 3
114291: DOUBLE
114292: EQUAL
114293: IFTRUE 114297
114295: GO 114401
114297: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114298: LD_ADDR_VAR 0 2
114302: PUSH
114303: LD_INT 22
114305: PUSH
114306: LD_OWVAR 2
114310: PUSH
114311: EMPTY
114312: LIST
114313: LIST
114314: PUSH
114315: LD_INT 25
114317: PUSH
114318: LD_INT 1
114320: PUSH
114321: EMPTY
114322: LIST
114323: LIST
114324: PUSH
114325: EMPTY
114326: LIST
114327: LIST
114328: PPUSH
114329: CALL_OW 69
114333: ST_TO_ADDR
// if not tmp then
114334: LD_VAR 0 2
114338: NOT
114339: IFFALSE 114343
// exit ;
114341: GO 114492
// un := tmp [ rand ( 1 , tmp ) ] ;
114343: LD_ADDR_VAR 0 3
114347: PUSH
114348: LD_VAR 0 2
114352: PUSH
114353: LD_INT 1
114355: PPUSH
114356: LD_VAR 0 2
114360: PPUSH
114361: CALL_OW 12
114365: ARRAY
114366: ST_TO_ADDR
// if Crawls ( un ) then
114367: LD_VAR 0 3
114371: PPUSH
114372: CALL_OW 318
114376: IFFALSE 114387
// ComWalk ( un ) ;
114378: LD_VAR 0 3
114382: PPUSH
114383: CALL_OW 138
// SetClass ( un , class_mortar ) ;
114387: LD_VAR 0 3
114391: PPUSH
114392: LD_INT 8
114394: PPUSH
114395: CALL_OW 336
// end ; 4 :
114399: GO 114492
114401: LD_INT 4
114403: DOUBLE
114404: EQUAL
114405: IFTRUE 114409
114407: GO 114470
114409: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
114410: LD_ADDR_VAR 0 2
114414: PUSH
114415: LD_INT 22
114417: PUSH
114418: LD_OWVAR 2
114422: PUSH
114423: EMPTY
114424: LIST
114425: LIST
114426: PUSH
114427: LD_INT 30
114429: PUSH
114430: LD_INT 29
114432: PUSH
114433: EMPTY
114434: LIST
114435: LIST
114436: PUSH
114437: EMPTY
114438: LIST
114439: LIST
114440: PPUSH
114441: CALL_OW 69
114445: ST_TO_ADDR
// if not tmp then
114446: LD_VAR 0 2
114450: NOT
114451: IFFALSE 114455
// exit ;
114453: GO 114492
// DestroyUnit ( tmp [ 1 ] ) ;
114455: LD_VAR 0 2
114459: PUSH
114460: LD_INT 1
114462: ARRAY
114463: PPUSH
114464: CALL_OW 65
// end ; 5 .. 7 :
114468: GO 114492
114470: LD_INT 5
114472: DOUBLE
114473: GREATEREQUAL
114474: IFFALSE 114482
114476: LD_INT 7
114478: DOUBLE
114479: LESSEQUAL
114480: IFTRUE 114484
114482: GO 114491
114484: POP
// StreamSibBomb ; end ;
114485: CALL 110742 0 0
114489: GO 114492
114491: POP
// end ;
114492: PPOPN 3
114494: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
114495: LD_EXP 160
114499: PUSH
114500: LD_EXP 210
114504: AND
114505: IFFALSE 114661
114507: GO 114509
114509: DISABLE
114510: LD_INT 0
114512: PPUSH
114513: PPUSH
114514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
114515: LD_ADDR_VAR 0 2
114519: PUSH
114520: LD_INT 81
114522: PUSH
114523: LD_OWVAR 2
114527: PUSH
114528: EMPTY
114529: LIST
114530: LIST
114531: PUSH
114532: LD_INT 2
114534: PUSH
114535: LD_INT 21
114537: PUSH
114538: LD_INT 1
114540: PUSH
114541: EMPTY
114542: LIST
114543: LIST
114544: PUSH
114545: LD_INT 21
114547: PUSH
114548: LD_INT 2
114550: PUSH
114551: EMPTY
114552: LIST
114553: LIST
114554: PUSH
114555: EMPTY
114556: LIST
114557: LIST
114558: LIST
114559: PUSH
114560: EMPTY
114561: LIST
114562: LIST
114563: PPUSH
114564: CALL_OW 69
114568: ST_TO_ADDR
// if not tmp then
114569: LD_VAR 0 2
114573: NOT
114574: IFFALSE 114578
// exit ;
114576: GO 114661
// p := 0 ;
114578: LD_ADDR_VAR 0 3
114582: PUSH
114583: LD_INT 0
114585: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
114586: LD_INT 35
114588: PPUSH
114589: CALL_OW 67
// p := p + 1 ;
114593: LD_ADDR_VAR 0 3
114597: PUSH
114598: LD_VAR 0 3
114602: PUSH
114603: LD_INT 1
114605: PLUS
114606: ST_TO_ADDR
// for i in tmp do
114607: LD_ADDR_VAR 0 1
114611: PUSH
114612: LD_VAR 0 2
114616: PUSH
114617: FOR_IN
114618: IFFALSE 114649
// if GetLives ( i ) < 1000 then
114620: LD_VAR 0 1
114624: PPUSH
114625: CALL_OW 256
114629: PUSH
114630: LD_INT 1000
114632: LESS
114633: IFFALSE 114647
// SetLives ( i , 1000 ) ;
114635: LD_VAR 0 1
114639: PPUSH
114640: LD_INT 1000
114642: PPUSH
114643: CALL_OW 234
114647: GO 114617
114649: POP
114650: POP
// until p > 20 ;
114651: LD_VAR 0 3
114655: PUSH
114656: LD_INT 20
114658: GREATER
114659: IFFALSE 114586
// end ;
114661: PPOPN 3
114663: END
// every 0 0$1 trigger StreamModeActive and sTime do
114664: LD_EXP 160
114668: PUSH
114669: LD_EXP 211
114673: AND
114674: IFFALSE 114709
114676: GO 114678
114678: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
114679: LD_INT 28
114681: PPUSH
114682: LD_OWVAR 2
114686: PPUSH
114687: LD_INT 2
114689: PPUSH
114690: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
114694: LD_INT 30
114696: PPUSH
114697: LD_OWVAR 2
114701: PPUSH
114702: LD_INT 2
114704: PPUSH
114705: CALL_OW 322
// end ;
114709: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
114710: LD_EXP 160
114714: PUSH
114715: LD_EXP 212
114719: AND
114720: IFFALSE 114841
114722: GO 114724
114724: DISABLE
114725: LD_INT 0
114727: PPUSH
114728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
114729: LD_ADDR_VAR 0 2
114733: PUSH
114734: LD_INT 22
114736: PUSH
114737: LD_OWVAR 2
114741: PUSH
114742: EMPTY
114743: LIST
114744: LIST
114745: PUSH
114746: LD_INT 21
114748: PUSH
114749: LD_INT 1
114751: PUSH
114752: EMPTY
114753: LIST
114754: LIST
114755: PUSH
114756: LD_INT 3
114758: PUSH
114759: LD_INT 23
114761: PUSH
114762: LD_INT 0
114764: PUSH
114765: EMPTY
114766: LIST
114767: LIST
114768: PUSH
114769: EMPTY
114770: LIST
114771: LIST
114772: PUSH
114773: EMPTY
114774: LIST
114775: LIST
114776: LIST
114777: PPUSH
114778: CALL_OW 69
114782: ST_TO_ADDR
// if not tmp then
114783: LD_VAR 0 2
114787: NOT
114788: IFFALSE 114792
// exit ;
114790: GO 114841
// for i in tmp do
114792: LD_ADDR_VAR 0 1
114796: PUSH
114797: LD_VAR 0 2
114801: PUSH
114802: FOR_IN
114803: IFFALSE 114839
// begin if Crawls ( i ) then
114805: LD_VAR 0 1
114809: PPUSH
114810: CALL_OW 318
114814: IFFALSE 114825
// ComWalk ( i ) ;
114816: LD_VAR 0 1
114820: PPUSH
114821: CALL_OW 138
// SetClass ( i , 2 ) ;
114825: LD_VAR 0 1
114829: PPUSH
114830: LD_INT 2
114832: PPUSH
114833: CALL_OW 336
// end ;
114837: GO 114802
114839: POP
114840: POP
// end ;
114841: PPOPN 2
114843: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
114844: LD_EXP 160
114848: PUSH
114849: LD_EXP 213
114853: AND
114854: IFFALSE 115135
114856: GO 114858
114858: DISABLE
114859: LD_INT 0
114861: PPUSH
114862: PPUSH
114863: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
114864: LD_OWVAR 2
114868: PPUSH
114869: LD_INT 9
114871: PPUSH
114872: LD_INT 1
114874: PPUSH
114875: LD_INT 1
114877: PPUSH
114878: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
114882: LD_INT 9
114884: PPUSH
114885: LD_OWVAR 2
114889: PPUSH
114890: CALL_OW 343
// uc_side := 9 ;
114894: LD_ADDR_OWVAR 20
114898: PUSH
114899: LD_INT 9
114901: ST_TO_ADDR
// uc_nation := 2 ;
114902: LD_ADDR_OWVAR 21
114906: PUSH
114907: LD_INT 2
114909: ST_TO_ADDR
// hc_name := Dark Warrior ;
114910: LD_ADDR_OWVAR 26
114914: PUSH
114915: LD_STRING Dark Warrior
114917: ST_TO_ADDR
// hc_gallery :=  ;
114918: LD_ADDR_OWVAR 33
114922: PUSH
114923: LD_STRING 
114925: ST_TO_ADDR
// hc_noskilllimit := true ;
114926: LD_ADDR_OWVAR 76
114930: PUSH
114931: LD_INT 1
114933: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
114934: LD_ADDR_OWVAR 31
114938: PUSH
114939: LD_INT 30
114941: PUSH
114942: LD_INT 30
114944: PUSH
114945: LD_INT 30
114947: PUSH
114948: LD_INT 30
114950: PUSH
114951: EMPTY
114952: LIST
114953: LIST
114954: LIST
114955: LIST
114956: ST_TO_ADDR
// un := CreateHuman ;
114957: LD_ADDR_VAR 0 3
114961: PUSH
114962: CALL_OW 44
114966: ST_TO_ADDR
// hc_noskilllimit := false ;
114967: LD_ADDR_OWVAR 76
114971: PUSH
114972: LD_INT 0
114974: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114975: LD_VAR 0 3
114979: PPUSH
114980: LD_INT 1
114982: PPUSH
114983: CALL_OW 51
// p := 0 ;
114987: LD_ADDR_VAR 0 2
114991: PUSH
114992: LD_INT 0
114994: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
114995: LD_INT 35
114997: PPUSH
114998: CALL_OW 67
// p := p + 1 ;
115002: LD_ADDR_VAR 0 2
115006: PUSH
115007: LD_VAR 0 2
115011: PUSH
115012: LD_INT 1
115014: PLUS
115015: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
115016: LD_VAR 0 3
115020: PPUSH
115021: CALL_OW 256
115025: PUSH
115026: LD_INT 1000
115028: LESS
115029: IFFALSE 115043
// SetLives ( un , 1000 ) ;
115031: LD_VAR 0 3
115035: PPUSH
115036: LD_INT 1000
115038: PPUSH
115039: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
115043: LD_VAR 0 3
115047: PPUSH
115048: LD_INT 81
115050: PUSH
115051: LD_OWVAR 2
115055: PUSH
115056: EMPTY
115057: LIST
115058: LIST
115059: PUSH
115060: LD_INT 91
115062: PUSH
115063: LD_VAR 0 3
115067: PUSH
115068: LD_INT 30
115070: PUSH
115071: EMPTY
115072: LIST
115073: LIST
115074: LIST
115075: PUSH
115076: EMPTY
115077: LIST
115078: LIST
115079: PPUSH
115080: CALL_OW 69
115084: PPUSH
115085: LD_VAR 0 3
115089: PPUSH
115090: CALL_OW 74
115094: PPUSH
115095: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
115099: LD_VAR 0 2
115103: PUSH
115104: LD_INT 60
115106: GREATER
115107: PUSH
115108: LD_VAR 0 3
115112: PPUSH
115113: CALL_OW 301
115117: OR
115118: IFFALSE 114995
// if un then
115120: LD_VAR 0 3
115124: IFFALSE 115135
// RemoveUnit ( un ) ;
115126: LD_VAR 0 3
115130: PPUSH
115131: CALL_OW 64
// end ;
115135: PPOPN 3
115137: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
115138: LD_INT 0
115140: PPUSH
// case cmd of 301 :
115141: LD_VAR 0 1
115145: PUSH
115146: LD_INT 301
115148: DOUBLE
115149: EQUAL
115150: IFTRUE 115154
115152: GO 115186
115154: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
115155: LD_VAR 0 6
115159: PPUSH
115160: LD_VAR 0 7
115164: PPUSH
115165: LD_VAR 0 8
115169: PPUSH
115170: LD_VAR 0 4
115174: PPUSH
115175: LD_VAR 0 5
115179: PPUSH
115180: CALL 116387 0 5
115184: GO 115307
115186: LD_INT 302
115188: DOUBLE
115189: EQUAL
115190: IFTRUE 115194
115192: GO 115231
115194: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
115195: LD_VAR 0 6
115199: PPUSH
115200: LD_VAR 0 7
115204: PPUSH
115205: LD_VAR 0 8
115209: PPUSH
115210: LD_VAR 0 9
115214: PPUSH
115215: LD_VAR 0 4
115219: PPUSH
115220: LD_VAR 0 5
115224: PPUSH
115225: CALL 116478 0 6
115229: GO 115307
115231: LD_INT 303
115233: DOUBLE
115234: EQUAL
115235: IFTRUE 115239
115237: GO 115276
115239: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
115240: LD_VAR 0 6
115244: PPUSH
115245: LD_VAR 0 7
115249: PPUSH
115250: LD_VAR 0 8
115254: PPUSH
115255: LD_VAR 0 9
115259: PPUSH
115260: LD_VAR 0 4
115264: PPUSH
115265: LD_VAR 0 5
115269: PPUSH
115270: CALL 115312 0 6
115274: GO 115307
115276: LD_INT 304
115278: DOUBLE
115279: EQUAL
115280: IFTRUE 115284
115282: GO 115306
115284: POP
// hHackTeleport ( unit , x , y ) ; end ;
115285: LD_VAR 0 2
115289: PPUSH
115290: LD_VAR 0 4
115294: PPUSH
115295: LD_VAR 0 5
115299: PPUSH
115300: CALL 117071 0 3
115304: GO 115307
115306: POP
// end ;
115307: LD_VAR 0 12
115311: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
115312: LD_INT 0
115314: PPUSH
115315: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
115316: LD_VAR 0 1
115320: PUSH
115321: LD_INT 1
115323: LESS
115324: PUSH
115325: LD_VAR 0 1
115329: PUSH
115330: LD_INT 3
115332: GREATER
115333: OR
115334: PUSH
115335: LD_VAR 0 5
115339: PPUSH
115340: LD_VAR 0 6
115344: PPUSH
115345: CALL_OW 428
115349: OR
115350: IFFALSE 115354
// exit ;
115352: GO 116074
// uc_side := your_side ;
115354: LD_ADDR_OWVAR 20
115358: PUSH
115359: LD_OWVAR 2
115363: ST_TO_ADDR
// uc_nation := nation ;
115364: LD_ADDR_OWVAR 21
115368: PUSH
115369: LD_VAR 0 1
115373: ST_TO_ADDR
// bc_level = 1 ;
115374: LD_ADDR_OWVAR 43
115378: PUSH
115379: LD_INT 1
115381: ST_TO_ADDR
// case btype of 1 :
115382: LD_VAR 0 2
115386: PUSH
115387: LD_INT 1
115389: DOUBLE
115390: EQUAL
115391: IFTRUE 115395
115393: GO 115406
115395: POP
// bc_type := b_depot ; 2 :
115396: LD_ADDR_OWVAR 42
115400: PUSH
115401: LD_INT 0
115403: ST_TO_ADDR
115404: GO 116018
115406: LD_INT 2
115408: DOUBLE
115409: EQUAL
115410: IFTRUE 115414
115412: GO 115425
115414: POP
// bc_type := b_warehouse ; 3 :
115415: LD_ADDR_OWVAR 42
115419: PUSH
115420: LD_INT 1
115422: ST_TO_ADDR
115423: GO 116018
115425: LD_INT 3
115427: DOUBLE
115428: EQUAL
115429: IFTRUE 115433
115431: GO 115444
115433: POP
// bc_type := b_lab ; 4 .. 9 :
115434: LD_ADDR_OWVAR 42
115438: PUSH
115439: LD_INT 6
115441: ST_TO_ADDR
115442: GO 116018
115444: LD_INT 4
115446: DOUBLE
115447: GREATEREQUAL
115448: IFFALSE 115456
115450: LD_INT 9
115452: DOUBLE
115453: LESSEQUAL
115454: IFTRUE 115458
115456: GO 115510
115458: POP
// begin bc_type := b_lab_half ;
115459: LD_ADDR_OWVAR 42
115463: PUSH
115464: LD_INT 7
115466: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
115467: LD_ADDR_OWVAR 44
115471: PUSH
115472: LD_INT 10
115474: PUSH
115475: LD_INT 11
115477: PUSH
115478: LD_INT 12
115480: PUSH
115481: LD_INT 15
115483: PUSH
115484: LD_INT 14
115486: PUSH
115487: LD_INT 13
115489: PUSH
115490: EMPTY
115491: LIST
115492: LIST
115493: LIST
115494: LIST
115495: LIST
115496: LIST
115497: PUSH
115498: LD_VAR 0 2
115502: PUSH
115503: LD_INT 3
115505: MINUS
115506: ARRAY
115507: ST_TO_ADDR
// end ; 10 .. 13 :
115508: GO 116018
115510: LD_INT 10
115512: DOUBLE
115513: GREATEREQUAL
115514: IFFALSE 115522
115516: LD_INT 13
115518: DOUBLE
115519: LESSEQUAL
115520: IFTRUE 115524
115522: GO 115601
115524: POP
// begin bc_type := b_lab_full ;
115525: LD_ADDR_OWVAR 42
115529: PUSH
115530: LD_INT 8
115532: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
115533: LD_ADDR_OWVAR 44
115537: PUSH
115538: LD_INT 10
115540: PUSH
115541: LD_INT 12
115543: PUSH
115544: LD_INT 14
115546: PUSH
115547: LD_INT 13
115549: PUSH
115550: EMPTY
115551: LIST
115552: LIST
115553: LIST
115554: LIST
115555: PUSH
115556: LD_VAR 0 2
115560: PUSH
115561: LD_INT 9
115563: MINUS
115564: ARRAY
115565: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
115566: LD_ADDR_OWVAR 45
115570: PUSH
115571: LD_INT 11
115573: PUSH
115574: LD_INT 15
115576: PUSH
115577: LD_INT 12
115579: PUSH
115580: LD_INT 15
115582: PUSH
115583: EMPTY
115584: LIST
115585: LIST
115586: LIST
115587: LIST
115588: PUSH
115589: LD_VAR 0 2
115593: PUSH
115594: LD_INT 9
115596: MINUS
115597: ARRAY
115598: ST_TO_ADDR
// end ; 14 :
115599: GO 116018
115601: LD_INT 14
115603: DOUBLE
115604: EQUAL
115605: IFTRUE 115609
115607: GO 115620
115609: POP
// bc_type := b_workshop ; 15 :
115610: LD_ADDR_OWVAR 42
115614: PUSH
115615: LD_INT 2
115617: ST_TO_ADDR
115618: GO 116018
115620: LD_INT 15
115622: DOUBLE
115623: EQUAL
115624: IFTRUE 115628
115626: GO 115639
115628: POP
// bc_type := b_factory ; 16 :
115629: LD_ADDR_OWVAR 42
115633: PUSH
115634: LD_INT 3
115636: ST_TO_ADDR
115637: GO 116018
115639: LD_INT 16
115641: DOUBLE
115642: EQUAL
115643: IFTRUE 115647
115645: GO 115658
115647: POP
// bc_type := b_ext_gun ; 17 :
115648: LD_ADDR_OWVAR 42
115652: PUSH
115653: LD_INT 17
115655: ST_TO_ADDR
115656: GO 116018
115658: LD_INT 17
115660: DOUBLE
115661: EQUAL
115662: IFTRUE 115666
115664: GO 115694
115666: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
115667: LD_ADDR_OWVAR 42
115671: PUSH
115672: LD_INT 19
115674: PUSH
115675: LD_INT 23
115677: PUSH
115678: LD_INT 19
115680: PUSH
115681: EMPTY
115682: LIST
115683: LIST
115684: LIST
115685: PUSH
115686: LD_VAR 0 1
115690: ARRAY
115691: ST_TO_ADDR
115692: GO 116018
115694: LD_INT 18
115696: DOUBLE
115697: EQUAL
115698: IFTRUE 115702
115700: GO 115713
115702: POP
// bc_type := b_ext_radar ; 19 :
115703: LD_ADDR_OWVAR 42
115707: PUSH
115708: LD_INT 20
115710: ST_TO_ADDR
115711: GO 116018
115713: LD_INT 19
115715: DOUBLE
115716: EQUAL
115717: IFTRUE 115721
115719: GO 115732
115721: POP
// bc_type := b_ext_radio ; 20 :
115722: LD_ADDR_OWVAR 42
115726: PUSH
115727: LD_INT 22
115729: ST_TO_ADDR
115730: GO 116018
115732: LD_INT 20
115734: DOUBLE
115735: EQUAL
115736: IFTRUE 115740
115738: GO 115751
115740: POP
// bc_type := b_ext_siberium ; 21 :
115741: LD_ADDR_OWVAR 42
115745: PUSH
115746: LD_INT 21
115748: ST_TO_ADDR
115749: GO 116018
115751: LD_INT 21
115753: DOUBLE
115754: EQUAL
115755: IFTRUE 115759
115757: GO 115770
115759: POP
// bc_type := b_ext_computer ; 22 :
115760: LD_ADDR_OWVAR 42
115764: PUSH
115765: LD_INT 24
115767: ST_TO_ADDR
115768: GO 116018
115770: LD_INT 22
115772: DOUBLE
115773: EQUAL
115774: IFTRUE 115778
115776: GO 115789
115778: POP
// bc_type := b_ext_track ; 23 :
115779: LD_ADDR_OWVAR 42
115783: PUSH
115784: LD_INT 16
115786: ST_TO_ADDR
115787: GO 116018
115789: LD_INT 23
115791: DOUBLE
115792: EQUAL
115793: IFTRUE 115797
115795: GO 115808
115797: POP
// bc_type := b_ext_laser ; 24 :
115798: LD_ADDR_OWVAR 42
115802: PUSH
115803: LD_INT 25
115805: ST_TO_ADDR
115806: GO 116018
115808: LD_INT 24
115810: DOUBLE
115811: EQUAL
115812: IFTRUE 115816
115814: GO 115827
115816: POP
// bc_type := b_control_tower ; 25 :
115817: LD_ADDR_OWVAR 42
115821: PUSH
115822: LD_INT 36
115824: ST_TO_ADDR
115825: GO 116018
115827: LD_INT 25
115829: DOUBLE
115830: EQUAL
115831: IFTRUE 115835
115833: GO 115846
115835: POP
// bc_type := b_breastwork ; 26 :
115836: LD_ADDR_OWVAR 42
115840: PUSH
115841: LD_INT 31
115843: ST_TO_ADDR
115844: GO 116018
115846: LD_INT 26
115848: DOUBLE
115849: EQUAL
115850: IFTRUE 115854
115852: GO 115865
115854: POP
// bc_type := b_bunker ; 27 :
115855: LD_ADDR_OWVAR 42
115859: PUSH
115860: LD_INT 32
115862: ST_TO_ADDR
115863: GO 116018
115865: LD_INT 27
115867: DOUBLE
115868: EQUAL
115869: IFTRUE 115873
115871: GO 115884
115873: POP
// bc_type := b_turret ; 28 :
115874: LD_ADDR_OWVAR 42
115878: PUSH
115879: LD_INT 33
115881: ST_TO_ADDR
115882: GO 116018
115884: LD_INT 28
115886: DOUBLE
115887: EQUAL
115888: IFTRUE 115892
115890: GO 115903
115892: POP
// bc_type := b_armoury ; 29 :
115893: LD_ADDR_OWVAR 42
115897: PUSH
115898: LD_INT 4
115900: ST_TO_ADDR
115901: GO 116018
115903: LD_INT 29
115905: DOUBLE
115906: EQUAL
115907: IFTRUE 115911
115909: GO 115922
115911: POP
// bc_type := b_barracks ; 30 :
115912: LD_ADDR_OWVAR 42
115916: PUSH
115917: LD_INT 5
115919: ST_TO_ADDR
115920: GO 116018
115922: LD_INT 30
115924: DOUBLE
115925: EQUAL
115926: IFTRUE 115930
115928: GO 115941
115930: POP
// bc_type := b_solar_power ; 31 :
115931: LD_ADDR_OWVAR 42
115935: PUSH
115936: LD_INT 27
115938: ST_TO_ADDR
115939: GO 116018
115941: LD_INT 31
115943: DOUBLE
115944: EQUAL
115945: IFTRUE 115949
115947: GO 115960
115949: POP
// bc_type := b_oil_power ; 32 :
115950: LD_ADDR_OWVAR 42
115954: PUSH
115955: LD_INT 26
115957: ST_TO_ADDR
115958: GO 116018
115960: LD_INT 32
115962: DOUBLE
115963: EQUAL
115964: IFTRUE 115968
115966: GO 115979
115968: POP
// bc_type := b_siberite_power ; 33 :
115969: LD_ADDR_OWVAR 42
115973: PUSH
115974: LD_INT 28
115976: ST_TO_ADDR
115977: GO 116018
115979: LD_INT 33
115981: DOUBLE
115982: EQUAL
115983: IFTRUE 115987
115985: GO 115998
115987: POP
// bc_type := b_oil_mine ; 34 :
115988: LD_ADDR_OWVAR 42
115992: PUSH
115993: LD_INT 29
115995: ST_TO_ADDR
115996: GO 116018
115998: LD_INT 34
116000: DOUBLE
116001: EQUAL
116002: IFTRUE 116006
116004: GO 116017
116006: POP
// bc_type := b_siberite_mine ; end ;
116007: LD_ADDR_OWVAR 42
116011: PUSH
116012: LD_INT 30
116014: ST_TO_ADDR
116015: GO 116018
116017: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
116018: LD_ADDR_VAR 0 8
116022: PUSH
116023: LD_VAR 0 5
116027: PPUSH
116028: LD_VAR 0 6
116032: PPUSH
116033: LD_VAR 0 3
116037: PPUSH
116038: CALL_OW 47
116042: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
116043: LD_OWVAR 42
116047: PUSH
116048: LD_INT 32
116050: PUSH
116051: LD_INT 33
116053: PUSH
116054: EMPTY
116055: LIST
116056: LIST
116057: IN
116058: IFFALSE 116074
// PlaceWeaponTurret ( b , weapon ) ;
116060: LD_VAR 0 8
116064: PPUSH
116065: LD_VAR 0 4
116069: PPUSH
116070: CALL_OW 431
// end ;
116074: LD_VAR 0 7
116078: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
116079: LD_INT 0
116081: PPUSH
116082: PPUSH
116083: PPUSH
116084: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116085: LD_ADDR_VAR 0 4
116089: PUSH
116090: LD_INT 22
116092: PUSH
116093: LD_OWVAR 2
116097: PUSH
116098: EMPTY
116099: LIST
116100: LIST
116101: PUSH
116102: LD_INT 2
116104: PUSH
116105: LD_INT 30
116107: PUSH
116108: LD_INT 0
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PUSH
116115: LD_INT 30
116117: PUSH
116118: LD_INT 1
116120: PUSH
116121: EMPTY
116122: LIST
116123: LIST
116124: PUSH
116125: EMPTY
116126: LIST
116127: LIST
116128: LIST
116129: PUSH
116130: EMPTY
116131: LIST
116132: LIST
116133: PPUSH
116134: CALL_OW 69
116138: ST_TO_ADDR
// if not tmp then
116139: LD_VAR 0 4
116143: NOT
116144: IFFALSE 116148
// exit ;
116146: GO 116207
// for i in tmp do
116148: LD_ADDR_VAR 0 2
116152: PUSH
116153: LD_VAR 0 4
116157: PUSH
116158: FOR_IN
116159: IFFALSE 116205
// for j = 1 to 3 do
116161: LD_ADDR_VAR 0 3
116165: PUSH
116166: DOUBLE
116167: LD_INT 1
116169: DEC
116170: ST_TO_ADDR
116171: LD_INT 3
116173: PUSH
116174: FOR_TO
116175: IFFALSE 116201
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
116177: LD_VAR 0 2
116181: PPUSH
116182: CALL_OW 274
116186: PPUSH
116187: LD_VAR 0 3
116191: PPUSH
116192: LD_INT 99999
116194: PPUSH
116195: CALL_OW 277
116199: GO 116174
116201: POP
116202: POP
116203: GO 116158
116205: POP
116206: POP
// end ;
116207: LD_VAR 0 1
116211: RET
// export function hHackSetLevel10 ; var i , j ; begin
116212: LD_INT 0
116214: PPUSH
116215: PPUSH
116216: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
116217: LD_ADDR_VAR 0 2
116221: PUSH
116222: LD_INT 21
116224: PUSH
116225: LD_INT 1
116227: PUSH
116228: EMPTY
116229: LIST
116230: LIST
116231: PPUSH
116232: CALL_OW 69
116236: PUSH
116237: FOR_IN
116238: IFFALSE 116290
// if IsSelected ( i ) then
116240: LD_VAR 0 2
116244: PPUSH
116245: CALL_OW 306
116249: IFFALSE 116288
// begin for j := 1 to 4 do
116251: LD_ADDR_VAR 0 3
116255: PUSH
116256: DOUBLE
116257: LD_INT 1
116259: DEC
116260: ST_TO_ADDR
116261: LD_INT 4
116263: PUSH
116264: FOR_TO
116265: IFFALSE 116286
// SetSkill ( i , j , 10 ) ;
116267: LD_VAR 0 2
116271: PPUSH
116272: LD_VAR 0 3
116276: PPUSH
116277: LD_INT 10
116279: PPUSH
116280: CALL_OW 237
116284: GO 116264
116286: POP
116287: POP
// end ;
116288: GO 116237
116290: POP
116291: POP
// end ;
116292: LD_VAR 0 1
116296: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
116297: LD_INT 0
116299: PPUSH
116300: PPUSH
116301: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
116302: LD_ADDR_VAR 0 2
116306: PUSH
116307: LD_INT 22
116309: PUSH
116310: LD_OWVAR 2
116314: PUSH
116315: EMPTY
116316: LIST
116317: LIST
116318: PUSH
116319: LD_INT 21
116321: PUSH
116322: LD_INT 1
116324: PUSH
116325: EMPTY
116326: LIST
116327: LIST
116328: PUSH
116329: EMPTY
116330: LIST
116331: LIST
116332: PPUSH
116333: CALL_OW 69
116337: PUSH
116338: FOR_IN
116339: IFFALSE 116380
// begin for j := 1 to 4 do
116341: LD_ADDR_VAR 0 3
116345: PUSH
116346: DOUBLE
116347: LD_INT 1
116349: DEC
116350: ST_TO_ADDR
116351: LD_INT 4
116353: PUSH
116354: FOR_TO
116355: IFFALSE 116376
// SetSkill ( i , j , 10 ) ;
116357: LD_VAR 0 2
116361: PPUSH
116362: LD_VAR 0 3
116366: PPUSH
116367: LD_INT 10
116369: PPUSH
116370: CALL_OW 237
116374: GO 116354
116376: POP
116377: POP
// end ;
116378: GO 116338
116380: POP
116381: POP
// end ;
116382: LD_VAR 0 1
116386: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
116387: LD_INT 0
116389: PPUSH
// uc_side := your_side ;
116390: LD_ADDR_OWVAR 20
116394: PUSH
116395: LD_OWVAR 2
116399: ST_TO_ADDR
// uc_nation := nation ;
116400: LD_ADDR_OWVAR 21
116404: PUSH
116405: LD_VAR 0 1
116409: ST_TO_ADDR
// InitHc ;
116410: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
116414: LD_INT 0
116416: PPUSH
116417: LD_VAR 0 2
116421: PPUSH
116422: LD_VAR 0 3
116426: PPUSH
116427: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
116431: LD_VAR 0 4
116435: PPUSH
116436: LD_VAR 0 5
116440: PPUSH
116441: CALL_OW 428
116445: PUSH
116446: LD_INT 0
116448: EQUAL
116449: IFFALSE 116473
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
116451: CALL_OW 44
116455: PPUSH
116456: LD_VAR 0 4
116460: PPUSH
116461: LD_VAR 0 5
116465: PPUSH
116466: LD_INT 1
116468: PPUSH
116469: CALL_OW 48
// end ;
116473: LD_VAR 0 6
116477: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
116478: LD_INT 0
116480: PPUSH
116481: PPUSH
// uc_side := your_side ;
116482: LD_ADDR_OWVAR 20
116486: PUSH
116487: LD_OWVAR 2
116491: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
116492: LD_VAR 0 1
116496: PUSH
116497: LD_INT 1
116499: PUSH
116500: LD_INT 2
116502: PUSH
116503: LD_INT 3
116505: PUSH
116506: LD_INT 4
116508: PUSH
116509: LD_INT 5
116511: PUSH
116512: EMPTY
116513: LIST
116514: LIST
116515: LIST
116516: LIST
116517: LIST
116518: IN
116519: IFFALSE 116531
// uc_nation := nation_american else
116521: LD_ADDR_OWVAR 21
116525: PUSH
116526: LD_INT 1
116528: ST_TO_ADDR
116529: GO 116574
// if chassis in [ 11 , 12 , 13 , 14 ] then
116531: LD_VAR 0 1
116535: PUSH
116536: LD_INT 11
116538: PUSH
116539: LD_INT 12
116541: PUSH
116542: LD_INT 13
116544: PUSH
116545: LD_INT 14
116547: PUSH
116548: EMPTY
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: IN
116554: IFFALSE 116566
// uc_nation := nation_arabian else
116556: LD_ADDR_OWVAR 21
116560: PUSH
116561: LD_INT 2
116563: ST_TO_ADDR
116564: GO 116574
// uc_nation := nation_russian ;
116566: LD_ADDR_OWVAR 21
116570: PUSH
116571: LD_INT 3
116573: ST_TO_ADDR
// vc_chassis := chassis ;
116574: LD_ADDR_OWVAR 37
116578: PUSH
116579: LD_VAR 0 1
116583: ST_TO_ADDR
// vc_engine := engine ;
116584: LD_ADDR_OWVAR 39
116588: PUSH
116589: LD_VAR 0 2
116593: ST_TO_ADDR
// vc_control := control ;
116594: LD_ADDR_OWVAR 38
116598: PUSH
116599: LD_VAR 0 3
116603: ST_TO_ADDR
// vc_weapon := weapon ;
116604: LD_ADDR_OWVAR 40
116608: PUSH
116609: LD_VAR 0 4
116613: ST_TO_ADDR
// un := CreateVehicle ;
116614: LD_ADDR_VAR 0 8
116618: PUSH
116619: CALL_OW 45
116623: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
116624: LD_VAR 0 8
116628: PPUSH
116629: LD_INT 0
116631: PPUSH
116632: LD_INT 5
116634: PPUSH
116635: CALL_OW 12
116639: PPUSH
116640: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
116644: LD_VAR 0 8
116648: PPUSH
116649: LD_VAR 0 5
116653: PPUSH
116654: LD_VAR 0 6
116658: PPUSH
116659: LD_INT 1
116661: PPUSH
116662: CALL_OW 48
// end ;
116666: LD_VAR 0 7
116670: RET
// export hInvincible ; every 1 do
116671: GO 116673
116673: DISABLE
// hInvincible := [ ] ;
116674: LD_ADDR_EXP 214
116678: PUSH
116679: EMPTY
116680: ST_TO_ADDR
116681: END
// every 10 do var i ;
116682: GO 116684
116684: DISABLE
116685: LD_INT 0
116687: PPUSH
// begin enable ;
116688: ENABLE
// if not hInvincible then
116689: LD_EXP 214
116693: NOT
116694: IFFALSE 116698
// exit ;
116696: GO 116742
// for i in hInvincible do
116698: LD_ADDR_VAR 0 1
116702: PUSH
116703: LD_EXP 214
116707: PUSH
116708: FOR_IN
116709: IFFALSE 116740
// if GetLives ( i ) < 1000 then
116711: LD_VAR 0 1
116715: PPUSH
116716: CALL_OW 256
116720: PUSH
116721: LD_INT 1000
116723: LESS
116724: IFFALSE 116738
// SetLives ( i , 1000 ) ;
116726: LD_VAR 0 1
116730: PPUSH
116731: LD_INT 1000
116733: PPUSH
116734: CALL_OW 234
116738: GO 116708
116740: POP
116741: POP
// end ;
116742: PPOPN 1
116744: END
// export function hHackInvincible ; var i ; begin
116745: LD_INT 0
116747: PPUSH
116748: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
116749: LD_ADDR_VAR 0 2
116753: PUSH
116754: LD_INT 2
116756: PUSH
116757: LD_INT 21
116759: PUSH
116760: LD_INT 1
116762: PUSH
116763: EMPTY
116764: LIST
116765: LIST
116766: PUSH
116767: LD_INT 21
116769: PUSH
116770: LD_INT 2
116772: PUSH
116773: EMPTY
116774: LIST
116775: LIST
116776: PUSH
116777: EMPTY
116778: LIST
116779: LIST
116780: LIST
116781: PPUSH
116782: CALL_OW 69
116786: PUSH
116787: FOR_IN
116788: IFFALSE 116849
// if IsSelected ( i ) then
116790: LD_VAR 0 2
116794: PPUSH
116795: CALL_OW 306
116799: IFFALSE 116847
// begin if i in hInvincible then
116801: LD_VAR 0 2
116805: PUSH
116806: LD_EXP 214
116810: IN
116811: IFFALSE 116831
// hInvincible := hInvincible diff i else
116813: LD_ADDR_EXP 214
116817: PUSH
116818: LD_EXP 214
116822: PUSH
116823: LD_VAR 0 2
116827: DIFF
116828: ST_TO_ADDR
116829: GO 116847
// hInvincible := hInvincible union i ;
116831: LD_ADDR_EXP 214
116835: PUSH
116836: LD_EXP 214
116840: PUSH
116841: LD_VAR 0 2
116845: UNION
116846: ST_TO_ADDR
// end ;
116847: GO 116787
116849: POP
116850: POP
// end ;
116851: LD_VAR 0 1
116855: RET
// export function hHackInvisible ; var i , j ; begin
116856: LD_INT 0
116858: PPUSH
116859: PPUSH
116860: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
116861: LD_ADDR_VAR 0 2
116865: PUSH
116866: LD_INT 21
116868: PUSH
116869: LD_INT 1
116871: PUSH
116872: EMPTY
116873: LIST
116874: LIST
116875: PPUSH
116876: CALL_OW 69
116880: PUSH
116881: FOR_IN
116882: IFFALSE 116906
// if IsSelected ( i ) then
116884: LD_VAR 0 2
116888: PPUSH
116889: CALL_OW 306
116893: IFFALSE 116904
// ComForceInvisible ( i ) ;
116895: LD_VAR 0 2
116899: PPUSH
116900: CALL_OW 496
116904: GO 116881
116906: POP
116907: POP
// end ;
116908: LD_VAR 0 1
116912: RET
// export function hHackChangeYourSide ; begin
116913: LD_INT 0
116915: PPUSH
// if your_side = 8 then
116916: LD_OWVAR 2
116920: PUSH
116921: LD_INT 8
116923: EQUAL
116924: IFFALSE 116936
// your_side := 0 else
116926: LD_ADDR_OWVAR 2
116930: PUSH
116931: LD_INT 0
116933: ST_TO_ADDR
116934: GO 116950
// your_side := your_side + 1 ;
116936: LD_ADDR_OWVAR 2
116940: PUSH
116941: LD_OWVAR 2
116945: PUSH
116946: LD_INT 1
116948: PLUS
116949: ST_TO_ADDR
// end ;
116950: LD_VAR 0 1
116954: RET
// export function hHackChangeUnitSide ; var i , j ; begin
116955: LD_INT 0
116957: PPUSH
116958: PPUSH
116959: PPUSH
// for i in all_units do
116960: LD_ADDR_VAR 0 2
116964: PUSH
116965: LD_OWVAR 3
116969: PUSH
116970: FOR_IN
116971: IFFALSE 117049
// if IsSelected ( i ) then
116973: LD_VAR 0 2
116977: PPUSH
116978: CALL_OW 306
116982: IFFALSE 117047
// begin j := GetSide ( i ) ;
116984: LD_ADDR_VAR 0 3
116988: PUSH
116989: LD_VAR 0 2
116993: PPUSH
116994: CALL_OW 255
116998: ST_TO_ADDR
// if j = 8 then
116999: LD_VAR 0 3
117003: PUSH
117004: LD_INT 8
117006: EQUAL
117007: IFFALSE 117019
// j := 0 else
117009: LD_ADDR_VAR 0 3
117013: PUSH
117014: LD_INT 0
117016: ST_TO_ADDR
117017: GO 117033
// j := j + 1 ;
117019: LD_ADDR_VAR 0 3
117023: PUSH
117024: LD_VAR 0 3
117028: PUSH
117029: LD_INT 1
117031: PLUS
117032: ST_TO_ADDR
// SetSide ( i , j ) ;
117033: LD_VAR 0 2
117037: PPUSH
117038: LD_VAR 0 3
117042: PPUSH
117043: CALL_OW 235
// end ;
117047: GO 116970
117049: POP
117050: POP
// end ;
117051: LD_VAR 0 1
117055: RET
// export function hHackFog ; begin
117056: LD_INT 0
117058: PPUSH
// FogOff ( true ) ;
117059: LD_INT 1
117061: PPUSH
117062: CALL_OW 344
// end ;
117066: LD_VAR 0 1
117070: RET
// export function hHackTeleport ( unit , x , y ) ; begin
117071: LD_INT 0
117073: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
117074: LD_VAR 0 1
117078: PPUSH
117079: LD_VAR 0 2
117083: PPUSH
117084: LD_VAR 0 3
117088: PPUSH
117089: LD_INT 1
117091: PPUSH
117092: LD_INT 1
117094: PPUSH
117095: CALL_OW 483
// CenterOnXY ( x , y ) ;
117099: LD_VAR 0 2
117103: PPUSH
117104: LD_VAR 0 3
117108: PPUSH
117109: CALL_OW 84
// end ; end_of_file
117113: LD_VAR 0 4
117117: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
117118: LD_INT 0
117120: PPUSH
117121: PPUSH
117122: PPUSH
117123: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
117124: LD_VAR 0 1
117128: PPUSH
117129: CALL_OW 264
117133: PUSH
117134: LD_EXP 99
117138: EQUAL
117139: IFFALSE 117211
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
117141: LD_INT 68
117143: PPUSH
117144: LD_VAR 0 1
117148: PPUSH
117149: CALL_OW 255
117153: PPUSH
117154: CALL_OW 321
117158: PUSH
117159: LD_INT 2
117161: EQUAL
117162: IFFALSE 117174
// eff := 70 else
117164: LD_ADDR_VAR 0 4
117168: PUSH
117169: LD_INT 70
117171: ST_TO_ADDR
117172: GO 117182
// eff := 30 ;
117174: LD_ADDR_VAR 0 4
117178: PUSH
117179: LD_INT 30
117181: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
117182: LD_VAR 0 1
117186: PPUSH
117187: CALL_OW 250
117191: PPUSH
117192: LD_VAR 0 1
117196: PPUSH
117197: CALL_OW 251
117201: PPUSH
117202: LD_VAR 0 4
117206: PPUSH
117207: CALL_OW 495
// end ; end ;
117211: LD_VAR 0 2
117215: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
117216: LD_INT 0
117218: PPUSH
// end ;
117219: LD_VAR 0 4
117223: RET
// export function SOS_Command ( cmd ) ; begin
117224: LD_INT 0
117226: PPUSH
// end ;
117227: LD_VAR 0 2
117231: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
117232: LD_INT 0
117234: PPUSH
// if cmd = 121 then
117235: LD_VAR 0 1
117239: PUSH
117240: LD_INT 121
117242: EQUAL
117243: IFFALSE 117245
// end ;
117245: LD_VAR 0 6
117249: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
117250: LD_INT 0
117252: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
117253: LD_VAR 0 1
117257: PUSH
117258: LD_INT 250
117260: EQUAL
117261: PUSH
117262: LD_VAR 0 2
117266: PPUSH
117267: CALL_OW 264
117271: PUSH
117272: LD_EXP 102
117276: EQUAL
117277: AND
117278: IFFALSE 117299
// MinerPlaceMine ( unit , x , y ) ;
117280: LD_VAR 0 2
117284: PPUSH
117285: LD_VAR 0 4
117289: PPUSH
117290: LD_VAR 0 5
117294: PPUSH
117295: CALL 119648 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
117299: LD_VAR 0 1
117303: PUSH
117304: LD_INT 251
117306: EQUAL
117307: PUSH
117308: LD_VAR 0 2
117312: PPUSH
117313: CALL_OW 264
117317: PUSH
117318: LD_EXP 102
117322: EQUAL
117323: AND
117324: IFFALSE 117345
// MinerDetonateMine ( unit , x , y ) ;
117326: LD_VAR 0 2
117330: PPUSH
117331: LD_VAR 0 4
117335: PPUSH
117336: LD_VAR 0 5
117340: PPUSH
117341: CALL 119925 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
117345: LD_VAR 0 1
117349: PUSH
117350: LD_INT 252
117352: EQUAL
117353: PUSH
117354: LD_VAR 0 2
117358: PPUSH
117359: CALL_OW 264
117363: PUSH
117364: LD_EXP 102
117368: EQUAL
117369: AND
117370: IFFALSE 117391
// MinerCreateMinefield ( unit , x , y ) ;
117372: LD_VAR 0 2
117376: PPUSH
117377: LD_VAR 0 4
117381: PPUSH
117382: LD_VAR 0 5
117386: PPUSH
117387: CALL 120342 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
117391: LD_VAR 0 1
117395: PUSH
117396: LD_INT 253
117398: EQUAL
117399: PUSH
117400: LD_VAR 0 2
117404: PPUSH
117405: CALL_OW 257
117409: PUSH
117410: LD_INT 5
117412: EQUAL
117413: AND
117414: IFFALSE 117435
// ComBinocular ( unit , x , y ) ;
117416: LD_VAR 0 2
117420: PPUSH
117421: LD_VAR 0 4
117425: PPUSH
117426: LD_VAR 0 5
117430: PPUSH
117431: CALL 120713 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
117435: LD_VAR 0 1
117439: PUSH
117440: LD_INT 254
117442: EQUAL
117443: PUSH
117444: LD_VAR 0 2
117448: PPUSH
117449: CALL_OW 264
117453: PUSH
117454: LD_EXP 97
117458: EQUAL
117459: AND
117460: PUSH
117461: LD_VAR 0 3
117465: PPUSH
117466: CALL_OW 263
117470: PUSH
117471: LD_INT 3
117473: EQUAL
117474: AND
117475: IFFALSE 117491
// HackDestroyVehicle ( unit , selectedUnit ) ;
117477: LD_VAR 0 2
117481: PPUSH
117482: LD_VAR 0 3
117486: PPUSH
117487: CALL 119008 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
117491: LD_VAR 0 1
117495: PUSH
117496: LD_INT 255
117498: EQUAL
117499: PUSH
117500: LD_VAR 0 2
117504: PPUSH
117505: CALL_OW 264
117509: PUSH
117510: LD_INT 14
117512: PUSH
117513: LD_INT 53
117515: PUSH
117516: EMPTY
117517: LIST
117518: LIST
117519: IN
117520: AND
117521: PUSH
117522: LD_VAR 0 4
117526: PPUSH
117527: LD_VAR 0 5
117531: PPUSH
117532: CALL_OW 488
117536: AND
117537: IFFALSE 117561
// CutTreeXYR ( unit , x , y , 12 ) ;
117539: LD_VAR 0 2
117543: PPUSH
117544: LD_VAR 0 4
117548: PPUSH
117549: LD_VAR 0 5
117553: PPUSH
117554: LD_INT 12
117556: PPUSH
117557: CALL 117574 0 4
// end ;
117561: LD_VAR 0 6
117565: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
117566: LD_INT 0
117568: PPUSH
// end ;
117569: LD_VAR 0 4
117573: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
117574: LD_INT 0
117576: PPUSH
117577: PPUSH
117578: PPUSH
117579: PPUSH
117580: PPUSH
117581: PPUSH
117582: PPUSH
117583: PPUSH
117584: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
117585: LD_VAR 0 1
117589: NOT
117590: PUSH
117591: LD_VAR 0 2
117595: PPUSH
117596: LD_VAR 0 3
117600: PPUSH
117601: CALL_OW 488
117605: NOT
117606: OR
117607: PUSH
117608: LD_VAR 0 4
117612: NOT
117613: OR
117614: IFFALSE 117618
// exit ;
117616: GO 117958
// list := [ ] ;
117618: LD_ADDR_VAR 0 13
117622: PUSH
117623: EMPTY
117624: ST_TO_ADDR
// if x - r < 0 then
117625: LD_VAR 0 2
117629: PUSH
117630: LD_VAR 0 4
117634: MINUS
117635: PUSH
117636: LD_INT 0
117638: LESS
117639: IFFALSE 117651
// min_x := 0 else
117641: LD_ADDR_VAR 0 7
117645: PUSH
117646: LD_INT 0
117648: ST_TO_ADDR
117649: GO 117667
// min_x := x - r ;
117651: LD_ADDR_VAR 0 7
117655: PUSH
117656: LD_VAR 0 2
117660: PUSH
117661: LD_VAR 0 4
117665: MINUS
117666: ST_TO_ADDR
// if y - r < 0 then
117667: LD_VAR 0 3
117671: PUSH
117672: LD_VAR 0 4
117676: MINUS
117677: PUSH
117678: LD_INT 0
117680: LESS
117681: IFFALSE 117693
// min_y := 0 else
117683: LD_ADDR_VAR 0 8
117687: PUSH
117688: LD_INT 0
117690: ST_TO_ADDR
117691: GO 117709
// min_y := y - r ;
117693: LD_ADDR_VAR 0 8
117697: PUSH
117698: LD_VAR 0 3
117702: PUSH
117703: LD_VAR 0 4
117707: MINUS
117708: ST_TO_ADDR
// max_x := x + r ;
117709: LD_ADDR_VAR 0 9
117713: PUSH
117714: LD_VAR 0 2
117718: PUSH
117719: LD_VAR 0 4
117723: PLUS
117724: ST_TO_ADDR
// max_y := y + r ;
117725: LD_ADDR_VAR 0 10
117729: PUSH
117730: LD_VAR 0 3
117734: PUSH
117735: LD_VAR 0 4
117739: PLUS
117740: ST_TO_ADDR
// for _x = min_x to max_x do
117741: LD_ADDR_VAR 0 11
117745: PUSH
117746: DOUBLE
117747: LD_VAR 0 7
117751: DEC
117752: ST_TO_ADDR
117753: LD_VAR 0 9
117757: PUSH
117758: FOR_TO
117759: IFFALSE 117876
// for _y = min_y to max_y do
117761: LD_ADDR_VAR 0 12
117765: PUSH
117766: DOUBLE
117767: LD_VAR 0 8
117771: DEC
117772: ST_TO_ADDR
117773: LD_VAR 0 10
117777: PUSH
117778: FOR_TO
117779: IFFALSE 117872
// begin if not ValidHex ( _x , _y ) then
117781: LD_VAR 0 11
117785: PPUSH
117786: LD_VAR 0 12
117790: PPUSH
117791: CALL_OW 488
117795: NOT
117796: IFFALSE 117800
// continue ;
117798: GO 117778
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
117800: LD_VAR 0 11
117804: PPUSH
117805: LD_VAR 0 12
117809: PPUSH
117810: CALL_OW 351
117814: PUSH
117815: LD_VAR 0 11
117819: PPUSH
117820: LD_VAR 0 12
117824: PPUSH
117825: CALL_OW 554
117829: AND
117830: IFFALSE 117870
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
117832: LD_ADDR_VAR 0 13
117836: PUSH
117837: LD_VAR 0 13
117841: PPUSH
117842: LD_VAR 0 13
117846: PUSH
117847: LD_INT 1
117849: PLUS
117850: PPUSH
117851: LD_VAR 0 11
117855: PUSH
117856: LD_VAR 0 12
117860: PUSH
117861: EMPTY
117862: LIST
117863: LIST
117864: PPUSH
117865: CALL_OW 2
117869: ST_TO_ADDR
// end ;
117870: GO 117778
117872: POP
117873: POP
117874: GO 117758
117876: POP
117877: POP
// if not list then
117878: LD_VAR 0 13
117882: NOT
117883: IFFALSE 117887
// exit ;
117885: GO 117958
// for i in list do
117887: LD_ADDR_VAR 0 6
117891: PUSH
117892: LD_VAR 0 13
117896: PUSH
117897: FOR_IN
117898: IFFALSE 117956
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
117900: LD_VAR 0 1
117904: PPUSH
117905: LD_STRING M
117907: PUSH
117908: LD_VAR 0 6
117912: PUSH
117913: LD_INT 1
117915: ARRAY
117916: PUSH
117917: LD_VAR 0 6
117921: PUSH
117922: LD_INT 2
117924: ARRAY
117925: PUSH
117926: LD_INT 0
117928: PUSH
117929: LD_INT 0
117931: PUSH
117932: LD_INT 0
117934: PUSH
117935: LD_INT 0
117937: PUSH
117938: EMPTY
117939: LIST
117940: LIST
117941: LIST
117942: LIST
117943: LIST
117944: LIST
117945: LIST
117946: PUSH
117947: EMPTY
117948: LIST
117949: PPUSH
117950: CALL_OW 447
117954: GO 117897
117956: POP
117957: POP
// end ;
117958: LD_VAR 0 5
117962: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
117963: LD_EXP 217
117967: NOT
117968: IFFALSE 118018
117970: GO 117972
117972: DISABLE
// begin initHack := true ;
117973: LD_ADDR_EXP 217
117977: PUSH
117978: LD_INT 1
117980: ST_TO_ADDR
// hackTanks := [ ] ;
117981: LD_ADDR_EXP 218
117985: PUSH
117986: EMPTY
117987: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
117988: LD_ADDR_EXP 219
117992: PUSH
117993: EMPTY
117994: ST_TO_ADDR
// hackLimit := 3 ;
117995: LD_ADDR_EXP 220
117999: PUSH
118000: LD_INT 3
118002: ST_TO_ADDR
// hackDist := 12 ;
118003: LD_ADDR_EXP 221
118007: PUSH
118008: LD_INT 12
118010: ST_TO_ADDR
// hackCounter := [ ] ;
118011: LD_ADDR_EXP 222
118015: PUSH
118016: EMPTY
118017: ST_TO_ADDR
// end ;
118018: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
118019: LD_EXP 217
118023: PUSH
118024: LD_INT 34
118026: PUSH
118027: LD_EXP 97
118031: PUSH
118032: EMPTY
118033: LIST
118034: LIST
118035: PPUSH
118036: CALL_OW 69
118040: AND
118041: IFFALSE 118296
118043: GO 118045
118045: DISABLE
118046: LD_INT 0
118048: PPUSH
118049: PPUSH
// begin enable ;
118050: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
118051: LD_ADDR_VAR 0 1
118055: PUSH
118056: LD_INT 34
118058: PUSH
118059: LD_EXP 97
118063: PUSH
118064: EMPTY
118065: LIST
118066: LIST
118067: PPUSH
118068: CALL_OW 69
118072: PUSH
118073: FOR_IN
118074: IFFALSE 118294
// begin if not i in hackTanks then
118076: LD_VAR 0 1
118080: PUSH
118081: LD_EXP 218
118085: IN
118086: NOT
118087: IFFALSE 118170
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
118089: LD_ADDR_EXP 218
118093: PUSH
118094: LD_EXP 218
118098: PPUSH
118099: LD_EXP 218
118103: PUSH
118104: LD_INT 1
118106: PLUS
118107: PPUSH
118108: LD_VAR 0 1
118112: PPUSH
118113: CALL_OW 1
118117: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
118118: LD_ADDR_EXP 219
118122: PUSH
118123: LD_EXP 219
118127: PPUSH
118128: LD_EXP 219
118132: PUSH
118133: LD_INT 1
118135: PLUS
118136: PPUSH
118137: EMPTY
118138: PPUSH
118139: CALL_OW 1
118143: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
118144: LD_ADDR_EXP 222
118148: PUSH
118149: LD_EXP 222
118153: PPUSH
118154: LD_EXP 222
118158: PUSH
118159: LD_INT 1
118161: PLUS
118162: PPUSH
118163: EMPTY
118164: PPUSH
118165: CALL_OW 1
118169: ST_TO_ADDR
// end ; if not IsOk ( i ) then
118170: LD_VAR 0 1
118174: PPUSH
118175: CALL_OW 302
118179: NOT
118180: IFFALSE 118193
// begin HackUnlinkAll ( i ) ;
118182: LD_VAR 0 1
118186: PPUSH
118187: CALL 118299 0 1
// continue ;
118191: GO 118073
// end ; HackCheckCapturedStatus ( i ) ;
118193: LD_VAR 0 1
118197: PPUSH
118198: CALL 118742 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
118202: LD_ADDR_VAR 0 2
118206: PUSH
118207: LD_INT 81
118209: PUSH
118210: LD_VAR 0 1
118214: PPUSH
118215: CALL_OW 255
118219: PUSH
118220: EMPTY
118221: LIST
118222: LIST
118223: PUSH
118224: LD_INT 33
118226: PUSH
118227: LD_INT 3
118229: PUSH
118230: EMPTY
118231: LIST
118232: LIST
118233: PUSH
118234: LD_INT 91
118236: PUSH
118237: LD_VAR 0 1
118241: PUSH
118242: LD_EXP 221
118246: PUSH
118247: EMPTY
118248: LIST
118249: LIST
118250: LIST
118251: PUSH
118252: LD_INT 50
118254: PUSH
118255: EMPTY
118256: LIST
118257: PUSH
118258: EMPTY
118259: LIST
118260: LIST
118261: LIST
118262: LIST
118263: PPUSH
118264: CALL_OW 69
118268: ST_TO_ADDR
// if not tmp then
118269: LD_VAR 0 2
118273: NOT
118274: IFFALSE 118278
// continue ;
118276: GO 118073
// HackLink ( i , tmp ) ;
118278: LD_VAR 0 1
118282: PPUSH
118283: LD_VAR 0 2
118287: PPUSH
118288: CALL 118435 0 2
// end ;
118292: GO 118073
118294: POP
118295: POP
// end ;
118296: PPOPN 2
118298: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
118299: LD_INT 0
118301: PPUSH
118302: PPUSH
118303: PPUSH
// if not hack in hackTanks then
118304: LD_VAR 0 1
118308: PUSH
118309: LD_EXP 218
118313: IN
118314: NOT
118315: IFFALSE 118319
// exit ;
118317: GO 118430
// index := GetElementIndex ( hackTanks , hack ) ;
118319: LD_ADDR_VAR 0 4
118323: PUSH
118324: LD_EXP 218
118328: PPUSH
118329: LD_VAR 0 1
118333: PPUSH
118334: CALL 70243 0 2
118338: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
118339: LD_EXP 219
118343: PUSH
118344: LD_VAR 0 4
118348: ARRAY
118349: IFFALSE 118430
// begin for i in hackTanksCaptured [ index ] do
118351: LD_ADDR_VAR 0 3
118355: PUSH
118356: LD_EXP 219
118360: PUSH
118361: LD_VAR 0 4
118365: ARRAY
118366: PUSH
118367: FOR_IN
118368: IFFALSE 118394
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
118370: LD_VAR 0 3
118374: PUSH
118375: LD_INT 1
118377: ARRAY
118378: PPUSH
118379: LD_VAR 0 3
118383: PUSH
118384: LD_INT 2
118386: ARRAY
118387: PPUSH
118388: CALL_OW 235
118392: GO 118367
118394: POP
118395: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
118396: LD_ADDR_EXP 219
118400: PUSH
118401: LD_EXP 219
118405: PPUSH
118406: LD_VAR 0 4
118410: PPUSH
118411: EMPTY
118412: PPUSH
118413: CALL_OW 1
118417: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
118418: LD_VAR 0 1
118422: PPUSH
118423: LD_INT 0
118425: PPUSH
118426: CALL_OW 505
// end ; end ;
118430: LD_VAR 0 2
118434: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
118435: LD_INT 0
118437: PPUSH
118438: PPUSH
118439: PPUSH
// if not hack in hackTanks or not vehicles then
118440: LD_VAR 0 1
118444: PUSH
118445: LD_EXP 218
118449: IN
118450: NOT
118451: PUSH
118452: LD_VAR 0 2
118456: NOT
118457: OR
118458: IFFALSE 118462
// exit ;
118460: GO 118737
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
118462: LD_ADDR_VAR 0 2
118466: PUSH
118467: LD_VAR 0 1
118471: PPUSH
118472: LD_VAR 0 2
118476: PPUSH
118477: LD_INT 1
118479: PPUSH
118480: LD_INT 1
118482: PPUSH
118483: CALL 70893 0 4
118487: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
118488: LD_ADDR_VAR 0 5
118492: PUSH
118493: LD_EXP 218
118497: PPUSH
118498: LD_VAR 0 1
118502: PPUSH
118503: CALL 70243 0 2
118507: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
118508: LD_EXP 219
118512: PUSH
118513: LD_VAR 0 5
118517: ARRAY
118518: PUSH
118519: LD_EXP 220
118523: LESS
118524: IFFALSE 118713
// begin for i := 1 to vehicles do
118526: LD_ADDR_VAR 0 4
118530: PUSH
118531: DOUBLE
118532: LD_INT 1
118534: DEC
118535: ST_TO_ADDR
118536: LD_VAR 0 2
118540: PUSH
118541: FOR_TO
118542: IFFALSE 118711
// begin if hackTanksCaptured [ index ] = hackLimit then
118544: LD_EXP 219
118548: PUSH
118549: LD_VAR 0 5
118553: ARRAY
118554: PUSH
118555: LD_EXP 220
118559: EQUAL
118560: IFFALSE 118564
// break ;
118562: GO 118711
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
118564: LD_ADDR_EXP 222
118568: PUSH
118569: LD_EXP 222
118573: PPUSH
118574: LD_VAR 0 5
118578: PPUSH
118579: LD_EXP 222
118583: PUSH
118584: LD_VAR 0 5
118588: ARRAY
118589: PUSH
118590: LD_INT 1
118592: PLUS
118593: PPUSH
118594: CALL_OW 1
118598: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
118599: LD_ADDR_EXP 219
118603: PUSH
118604: LD_EXP 219
118608: PPUSH
118609: LD_VAR 0 5
118613: PUSH
118614: LD_EXP 219
118618: PUSH
118619: LD_VAR 0 5
118623: ARRAY
118624: PUSH
118625: LD_INT 1
118627: PLUS
118628: PUSH
118629: EMPTY
118630: LIST
118631: LIST
118632: PPUSH
118633: LD_VAR 0 2
118637: PUSH
118638: LD_VAR 0 4
118642: ARRAY
118643: PUSH
118644: LD_VAR 0 2
118648: PUSH
118649: LD_VAR 0 4
118653: ARRAY
118654: PPUSH
118655: CALL_OW 255
118659: PUSH
118660: EMPTY
118661: LIST
118662: LIST
118663: PPUSH
118664: CALL 70458 0 3
118668: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
118669: LD_VAR 0 2
118673: PUSH
118674: LD_VAR 0 4
118678: ARRAY
118679: PPUSH
118680: LD_VAR 0 1
118684: PPUSH
118685: CALL_OW 255
118689: PPUSH
118690: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
118694: LD_VAR 0 2
118698: PUSH
118699: LD_VAR 0 4
118703: ARRAY
118704: PPUSH
118705: CALL_OW 141
// end ;
118709: GO 118541
118711: POP
118712: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
118713: LD_VAR 0 1
118717: PPUSH
118718: LD_EXP 219
118722: PUSH
118723: LD_VAR 0 5
118727: ARRAY
118728: PUSH
118729: LD_INT 0
118731: PLUS
118732: PPUSH
118733: CALL_OW 505
// end ;
118737: LD_VAR 0 3
118741: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
118742: LD_INT 0
118744: PPUSH
118745: PPUSH
118746: PPUSH
118747: PPUSH
// if not hack in hackTanks then
118748: LD_VAR 0 1
118752: PUSH
118753: LD_EXP 218
118757: IN
118758: NOT
118759: IFFALSE 118763
// exit ;
118761: GO 119003
// index := GetElementIndex ( hackTanks , hack ) ;
118763: LD_ADDR_VAR 0 4
118767: PUSH
118768: LD_EXP 218
118772: PPUSH
118773: LD_VAR 0 1
118777: PPUSH
118778: CALL 70243 0 2
118782: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
118783: LD_ADDR_VAR 0 3
118787: PUSH
118788: DOUBLE
118789: LD_EXP 219
118793: PUSH
118794: LD_VAR 0 4
118798: ARRAY
118799: INC
118800: ST_TO_ADDR
118801: LD_INT 1
118803: PUSH
118804: FOR_DOWNTO
118805: IFFALSE 118977
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
118807: LD_ADDR_VAR 0 5
118811: PUSH
118812: LD_EXP 219
118816: PUSH
118817: LD_VAR 0 4
118821: ARRAY
118822: PUSH
118823: LD_VAR 0 3
118827: ARRAY
118828: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
118829: LD_VAR 0 5
118833: PUSH
118834: LD_INT 1
118836: ARRAY
118837: PPUSH
118838: CALL_OW 302
118842: NOT
118843: PUSH
118844: LD_VAR 0 5
118848: PUSH
118849: LD_INT 1
118851: ARRAY
118852: PPUSH
118853: CALL_OW 255
118857: PUSH
118858: LD_VAR 0 1
118862: PPUSH
118863: CALL_OW 255
118867: NONEQUAL
118868: OR
118869: IFFALSE 118975
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
118871: LD_VAR 0 5
118875: PUSH
118876: LD_INT 1
118878: ARRAY
118879: PPUSH
118880: CALL_OW 305
118884: PUSH
118885: LD_VAR 0 5
118889: PUSH
118890: LD_INT 1
118892: ARRAY
118893: PPUSH
118894: CALL_OW 255
118898: PUSH
118899: LD_VAR 0 1
118903: PPUSH
118904: CALL_OW 255
118908: EQUAL
118909: AND
118910: IFFALSE 118934
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
118912: LD_VAR 0 5
118916: PUSH
118917: LD_INT 1
118919: ARRAY
118920: PPUSH
118921: LD_VAR 0 5
118925: PUSH
118926: LD_INT 2
118928: ARRAY
118929: PPUSH
118930: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
118934: LD_ADDR_EXP 219
118938: PUSH
118939: LD_EXP 219
118943: PPUSH
118944: LD_VAR 0 4
118948: PPUSH
118949: LD_EXP 219
118953: PUSH
118954: LD_VAR 0 4
118958: ARRAY
118959: PPUSH
118960: LD_VAR 0 3
118964: PPUSH
118965: CALL_OW 3
118969: PPUSH
118970: CALL_OW 1
118974: ST_TO_ADDR
// end ; end ;
118975: GO 118804
118977: POP
118978: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
118979: LD_VAR 0 1
118983: PPUSH
118984: LD_EXP 219
118988: PUSH
118989: LD_VAR 0 4
118993: ARRAY
118994: PUSH
118995: LD_INT 0
118997: PLUS
118998: PPUSH
118999: CALL_OW 505
// end ;
119003: LD_VAR 0 2
119007: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
119008: LD_INT 0
119010: PPUSH
119011: PPUSH
119012: PPUSH
119013: PPUSH
// if not hack in hackTanks then
119014: LD_VAR 0 1
119018: PUSH
119019: LD_EXP 218
119023: IN
119024: NOT
119025: IFFALSE 119029
// exit ;
119027: GO 119114
// index := GetElementIndex ( hackTanks , hack ) ;
119029: LD_ADDR_VAR 0 5
119033: PUSH
119034: LD_EXP 218
119038: PPUSH
119039: LD_VAR 0 1
119043: PPUSH
119044: CALL 70243 0 2
119048: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
119049: LD_ADDR_VAR 0 4
119053: PUSH
119054: DOUBLE
119055: LD_INT 1
119057: DEC
119058: ST_TO_ADDR
119059: LD_EXP 219
119063: PUSH
119064: LD_VAR 0 5
119068: ARRAY
119069: PUSH
119070: FOR_TO
119071: IFFALSE 119112
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
119073: LD_EXP 219
119077: PUSH
119078: LD_VAR 0 5
119082: ARRAY
119083: PUSH
119084: LD_VAR 0 4
119088: ARRAY
119089: PUSH
119090: LD_INT 1
119092: ARRAY
119093: PUSH
119094: LD_VAR 0 2
119098: EQUAL
119099: IFFALSE 119110
// KillUnit ( vehicle ) ;
119101: LD_VAR 0 2
119105: PPUSH
119106: CALL_OW 66
119110: GO 119070
119112: POP
119113: POP
// end ;
119114: LD_VAR 0 3
119118: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
119119: LD_EXP 223
119123: NOT
119124: IFFALSE 119159
119126: GO 119128
119128: DISABLE
// begin initMiner := true ;
119129: LD_ADDR_EXP 223
119133: PUSH
119134: LD_INT 1
119136: ST_TO_ADDR
// minersList := [ ] ;
119137: LD_ADDR_EXP 224
119141: PUSH
119142: EMPTY
119143: ST_TO_ADDR
// minerMinesList := [ ] ;
119144: LD_ADDR_EXP 225
119148: PUSH
119149: EMPTY
119150: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
119151: LD_ADDR_EXP 226
119155: PUSH
119156: LD_INT 5
119158: ST_TO_ADDR
// end ;
119159: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
119160: LD_EXP 223
119164: PUSH
119165: LD_INT 34
119167: PUSH
119168: LD_EXP 102
119172: PUSH
119173: EMPTY
119174: LIST
119175: LIST
119176: PPUSH
119177: CALL_OW 69
119181: AND
119182: IFFALSE 119645
119184: GO 119186
119186: DISABLE
119187: LD_INT 0
119189: PPUSH
119190: PPUSH
119191: PPUSH
119192: PPUSH
// begin enable ;
119193: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
119194: LD_ADDR_VAR 0 1
119198: PUSH
119199: LD_INT 34
119201: PUSH
119202: LD_EXP 102
119206: PUSH
119207: EMPTY
119208: LIST
119209: LIST
119210: PPUSH
119211: CALL_OW 69
119215: PUSH
119216: FOR_IN
119217: IFFALSE 119289
// begin if not i in minersList then
119219: LD_VAR 0 1
119223: PUSH
119224: LD_EXP 224
119228: IN
119229: NOT
119230: IFFALSE 119287
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
119232: LD_ADDR_EXP 224
119236: PUSH
119237: LD_EXP 224
119241: PPUSH
119242: LD_EXP 224
119246: PUSH
119247: LD_INT 1
119249: PLUS
119250: PPUSH
119251: LD_VAR 0 1
119255: PPUSH
119256: CALL_OW 1
119260: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
119261: LD_ADDR_EXP 225
119265: PUSH
119266: LD_EXP 225
119270: PPUSH
119271: LD_EXP 225
119275: PUSH
119276: LD_INT 1
119278: PLUS
119279: PPUSH
119280: EMPTY
119281: PPUSH
119282: CALL_OW 1
119286: ST_TO_ADDR
// end end ;
119287: GO 119216
119289: POP
119290: POP
// for i := minerMinesList downto 1 do
119291: LD_ADDR_VAR 0 1
119295: PUSH
119296: DOUBLE
119297: LD_EXP 225
119301: INC
119302: ST_TO_ADDR
119303: LD_INT 1
119305: PUSH
119306: FOR_DOWNTO
119307: IFFALSE 119643
// begin if IsLive ( minersList [ i ] ) then
119309: LD_EXP 224
119313: PUSH
119314: LD_VAR 0 1
119318: ARRAY
119319: PPUSH
119320: CALL_OW 300
119324: IFFALSE 119352
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
119326: LD_EXP 224
119330: PUSH
119331: LD_VAR 0 1
119335: ARRAY
119336: PPUSH
119337: LD_EXP 225
119341: PUSH
119342: LD_VAR 0 1
119346: ARRAY
119347: PPUSH
119348: CALL_OW 505
// if not minerMinesList [ i ] then
119352: LD_EXP 225
119356: PUSH
119357: LD_VAR 0 1
119361: ARRAY
119362: NOT
119363: IFFALSE 119367
// continue ;
119365: GO 119306
// for j := minerMinesList [ i ] downto 1 do
119367: LD_ADDR_VAR 0 2
119371: PUSH
119372: DOUBLE
119373: LD_EXP 225
119377: PUSH
119378: LD_VAR 0 1
119382: ARRAY
119383: INC
119384: ST_TO_ADDR
119385: LD_INT 1
119387: PUSH
119388: FOR_DOWNTO
119389: IFFALSE 119639
// begin side := GetSide ( minersList [ i ] ) ;
119391: LD_ADDR_VAR 0 3
119395: PUSH
119396: LD_EXP 224
119400: PUSH
119401: LD_VAR 0 1
119405: ARRAY
119406: PPUSH
119407: CALL_OW 255
119411: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
119412: LD_ADDR_VAR 0 4
119416: PUSH
119417: LD_EXP 225
119421: PUSH
119422: LD_VAR 0 1
119426: ARRAY
119427: PUSH
119428: LD_VAR 0 2
119432: ARRAY
119433: PUSH
119434: LD_INT 1
119436: ARRAY
119437: PPUSH
119438: LD_EXP 225
119442: PUSH
119443: LD_VAR 0 1
119447: ARRAY
119448: PUSH
119449: LD_VAR 0 2
119453: ARRAY
119454: PUSH
119455: LD_INT 2
119457: ARRAY
119458: PPUSH
119459: CALL_OW 428
119463: ST_TO_ADDR
// if not tmp then
119464: LD_VAR 0 4
119468: NOT
119469: IFFALSE 119473
// continue ;
119471: GO 119388
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
119473: LD_VAR 0 4
119477: PUSH
119478: LD_INT 81
119480: PUSH
119481: LD_VAR 0 3
119485: PUSH
119486: EMPTY
119487: LIST
119488: LIST
119489: PPUSH
119490: CALL_OW 69
119494: IN
119495: PUSH
119496: LD_EXP 225
119500: PUSH
119501: LD_VAR 0 1
119505: ARRAY
119506: PUSH
119507: LD_VAR 0 2
119511: ARRAY
119512: PUSH
119513: LD_INT 1
119515: ARRAY
119516: PPUSH
119517: LD_EXP 225
119521: PUSH
119522: LD_VAR 0 1
119526: ARRAY
119527: PUSH
119528: LD_VAR 0 2
119532: ARRAY
119533: PUSH
119534: LD_INT 2
119536: ARRAY
119537: PPUSH
119538: CALL_OW 458
119542: AND
119543: IFFALSE 119637
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
119545: LD_EXP 225
119549: PUSH
119550: LD_VAR 0 1
119554: ARRAY
119555: PUSH
119556: LD_VAR 0 2
119560: ARRAY
119561: PUSH
119562: LD_INT 1
119564: ARRAY
119565: PPUSH
119566: LD_EXP 225
119570: PUSH
119571: LD_VAR 0 1
119575: ARRAY
119576: PUSH
119577: LD_VAR 0 2
119581: ARRAY
119582: PUSH
119583: LD_INT 2
119585: ARRAY
119586: PPUSH
119587: LD_VAR 0 3
119591: PPUSH
119592: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
119596: LD_ADDR_EXP 225
119600: PUSH
119601: LD_EXP 225
119605: PPUSH
119606: LD_VAR 0 1
119610: PPUSH
119611: LD_EXP 225
119615: PUSH
119616: LD_VAR 0 1
119620: ARRAY
119621: PPUSH
119622: LD_VAR 0 2
119626: PPUSH
119627: CALL_OW 3
119631: PPUSH
119632: CALL_OW 1
119636: ST_TO_ADDR
// end ; end ;
119637: GO 119388
119639: POP
119640: POP
// end ;
119641: GO 119306
119643: POP
119644: POP
// end ;
119645: PPOPN 4
119647: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
119648: LD_INT 0
119650: PPUSH
119651: PPUSH
// result := false ;
119652: LD_ADDR_VAR 0 4
119656: PUSH
119657: LD_INT 0
119659: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
119660: LD_VAR 0 1
119664: PPUSH
119665: CALL_OW 264
119669: PUSH
119670: LD_EXP 102
119674: EQUAL
119675: NOT
119676: IFFALSE 119680
// exit ;
119678: GO 119920
// index := GetElementIndex ( minersList , unit ) ;
119680: LD_ADDR_VAR 0 5
119684: PUSH
119685: LD_EXP 224
119689: PPUSH
119690: LD_VAR 0 1
119694: PPUSH
119695: CALL 70243 0 2
119699: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
119700: LD_EXP 225
119704: PUSH
119705: LD_VAR 0 5
119709: ARRAY
119710: PUSH
119711: LD_EXP 226
119715: GREATEREQUAL
119716: IFFALSE 119720
// exit ;
119718: GO 119920
// ComMoveXY ( unit , x , y ) ;
119720: LD_VAR 0 1
119724: PPUSH
119725: LD_VAR 0 2
119729: PPUSH
119730: LD_VAR 0 3
119734: PPUSH
119735: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
119739: LD_INT 35
119741: PPUSH
119742: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
119746: LD_VAR 0 1
119750: PPUSH
119751: LD_VAR 0 2
119755: PPUSH
119756: LD_VAR 0 3
119760: PPUSH
119761: CALL 101016 0 3
119765: NOT
119766: PUSH
119767: LD_VAR 0 1
119771: PPUSH
119772: CALL_OW 314
119776: AND
119777: IFFALSE 119781
// exit ;
119779: GO 119920
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
119781: LD_VAR 0 2
119785: PPUSH
119786: LD_VAR 0 3
119790: PPUSH
119791: CALL_OW 428
119795: PUSH
119796: LD_VAR 0 1
119800: EQUAL
119801: PUSH
119802: LD_VAR 0 1
119806: PPUSH
119807: CALL_OW 314
119811: NOT
119812: AND
119813: IFFALSE 119739
// PlaySoundXY ( x , y , PlantMine ) ;
119815: LD_VAR 0 2
119819: PPUSH
119820: LD_VAR 0 3
119824: PPUSH
119825: LD_STRING PlantMine
119827: PPUSH
119828: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
119832: LD_VAR 0 2
119836: PPUSH
119837: LD_VAR 0 3
119841: PPUSH
119842: LD_VAR 0 1
119846: PPUSH
119847: CALL_OW 255
119851: PPUSH
119852: LD_INT 0
119854: PPUSH
119855: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
119859: LD_ADDR_EXP 225
119863: PUSH
119864: LD_EXP 225
119868: PPUSH
119869: LD_VAR 0 5
119873: PUSH
119874: LD_EXP 225
119878: PUSH
119879: LD_VAR 0 5
119883: ARRAY
119884: PUSH
119885: LD_INT 1
119887: PLUS
119888: PUSH
119889: EMPTY
119890: LIST
119891: LIST
119892: PPUSH
119893: LD_VAR 0 2
119897: PUSH
119898: LD_VAR 0 3
119902: PUSH
119903: EMPTY
119904: LIST
119905: LIST
119906: PPUSH
119907: CALL 70458 0 3
119911: ST_TO_ADDR
// result := true ;
119912: LD_ADDR_VAR 0 4
119916: PUSH
119917: LD_INT 1
119919: ST_TO_ADDR
// end ;
119920: LD_VAR 0 4
119924: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
119925: LD_INT 0
119927: PPUSH
119928: PPUSH
119929: PPUSH
// if not unit in minersList then
119930: LD_VAR 0 1
119934: PUSH
119935: LD_EXP 224
119939: IN
119940: NOT
119941: IFFALSE 119945
// exit ;
119943: GO 120337
// index := GetElementIndex ( minersList , unit ) ;
119945: LD_ADDR_VAR 0 6
119949: PUSH
119950: LD_EXP 224
119954: PPUSH
119955: LD_VAR 0 1
119959: PPUSH
119960: CALL 70243 0 2
119964: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
119965: LD_ADDR_VAR 0 5
119969: PUSH
119970: DOUBLE
119971: LD_EXP 225
119975: PUSH
119976: LD_VAR 0 6
119980: ARRAY
119981: INC
119982: ST_TO_ADDR
119983: LD_INT 1
119985: PUSH
119986: FOR_DOWNTO
119987: IFFALSE 120148
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
119989: LD_EXP 225
119993: PUSH
119994: LD_VAR 0 6
119998: ARRAY
119999: PUSH
120000: LD_VAR 0 5
120004: ARRAY
120005: PUSH
120006: LD_INT 1
120008: ARRAY
120009: PUSH
120010: LD_VAR 0 2
120014: EQUAL
120015: PUSH
120016: LD_EXP 225
120020: PUSH
120021: LD_VAR 0 6
120025: ARRAY
120026: PUSH
120027: LD_VAR 0 5
120031: ARRAY
120032: PUSH
120033: LD_INT 2
120035: ARRAY
120036: PUSH
120037: LD_VAR 0 3
120041: EQUAL
120042: AND
120043: IFFALSE 120146
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
120045: LD_EXP 225
120049: PUSH
120050: LD_VAR 0 6
120054: ARRAY
120055: PUSH
120056: LD_VAR 0 5
120060: ARRAY
120061: PUSH
120062: LD_INT 1
120064: ARRAY
120065: PPUSH
120066: LD_EXP 225
120070: PUSH
120071: LD_VAR 0 6
120075: ARRAY
120076: PUSH
120077: LD_VAR 0 5
120081: ARRAY
120082: PUSH
120083: LD_INT 2
120085: ARRAY
120086: PPUSH
120087: LD_VAR 0 1
120091: PPUSH
120092: CALL_OW 255
120096: PPUSH
120097: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
120101: LD_ADDR_EXP 225
120105: PUSH
120106: LD_EXP 225
120110: PPUSH
120111: LD_VAR 0 6
120115: PPUSH
120116: LD_EXP 225
120120: PUSH
120121: LD_VAR 0 6
120125: ARRAY
120126: PPUSH
120127: LD_VAR 0 5
120131: PPUSH
120132: CALL_OW 3
120136: PPUSH
120137: CALL_OW 1
120141: ST_TO_ADDR
// exit ;
120142: POP
120143: POP
120144: GO 120337
// end ; end ;
120146: GO 119986
120148: POP
120149: POP
// for i := minerMinesList [ index ] downto 1 do
120150: LD_ADDR_VAR 0 5
120154: PUSH
120155: DOUBLE
120156: LD_EXP 225
120160: PUSH
120161: LD_VAR 0 6
120165: ARRAY
120166: INC
120167: ST_TO_ADDR
120168: LD_INT 1
120170: PUSH
120171: FOR_DOWNTO
120172: IFFALSE 120335
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
120174: LD_EXP 225
120178: PUSH
120179: LD_VAR 0 6
120183: ARRAY
120184: PUSH
120185: LD_VAR 0 5
120189: ARRAY
120190: PUSH
120191: LD_INT 1
120193: ARRAY
120194: PPUSH
120195: LD_EXP 225
120199: PUSH
120200: LD_VAR 0 6
120204: ARRAY
120205: PUSH
120206: LD_VAR 0 5
120210: ARRAY
120211: PUSH
120212: LD_INT 2
120214: ARRAY
120215: PPUSH
120216: LD_VAR 0 2
120220: PPUSH
120221: LD_VAR 0 3
120225: PPUSH
120226: CALL_OW 298
120230: PUSH
120231: LD_INT 6
120233: LESS
120234: IFFALSE 120333
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
120236: LD_EXP 225
120240: PUSH
120241: LD_VAR 0 6
120245: ARRAY
120246: PUSH
120247: LD_VAR 0 5
120251: ARRAY
120252: PUSH
120253: LD_INT 1
120255: ARRAY
120256: PPUSH
120257: LD_EXP 225
120261: PUSH
120262: LD_VAR 0 6
120266: ARRAY
120267: PUSH
120268: LD_VAR 0 5
120272: ARRAY
120273: PUSH
120274: LD_INT 2
120276: ARRAY
120277: PPUSH
120278: LD_VAR 0 1
120282: PPUSH
120283: CALL_OW 255
120287: PPUSH
120288: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
120292: LD_ADDR_EXP 225
120296: PUSH
120297: LD_EXP 225
120301: PPUSH
120302: LD_VAR 0 6
120306: PPUSH
120307: LD_EXP 225
120311: PUSH
120312: LD_VAR 0 6
120316: ARRAY
120317: PPUSH
120318: LD_VAR 0 5
120322: PPUSH
120323: CALL_OW 3
120327: PPUSH
120328: CALL_OW 1
120332: ST_TO_ADDR
// end ; end ;
120333: GO 120171
120335: POP
120336: POP
// end ;
120337: LD_VAR 0 4
120341: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
120342: LD_INT 0
120344: PPUSH
120345: PPUSH
120346: PPUSH
120347: PPUSH
120348: PPUSH
120349: PPUSH
120350: PPUSH
120351: PPUSH
120352: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
120353: LD_VAR 0 1
120357: PPUSH
120358: CALL_OW 264
120362: PUSH
120363: LD_EXP 102
120367: EQUAL
120368: NOT
120369: PUSH
120370: LD_VAR 0 1
120374: PUSH
120375: LD_EXP 224
120379: IN
120380: NOT
120381: OR
120382: IFFALSE 120386
// exit ;
120384: GO 120708
// index := GetElementIndex ( minersList , unit ) ;
120386: LD_ADDR_VAR 0 6
120390: PUSH
120391: LD_EXP 224
120395: PPUSH
120396: LD_VAR 0 1
120400: PPUSH
120401: CALL 70243 0 2
120405: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
120406: LD_ADDR_VAR 0 8
120410: PUSH
120411: LD_EXP 226
120415: PUSH
120416: LD_EXP 225
120420: PUSH
120421: LD_VAR 0 6
120425: ARRAY
120426: MINUS
120427: ST_TO_ADDR
// if not minesFreeAmount then
120428: LD_VAR 0 8
120432: NOT
120433: IFFALSE 120437
// exit ;
120435: GO 120708
// tmp := [ ] ;
120437: LD_ADDR_VAR 0 7
120441: PUSH
120442: EMPTY
120443: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
120444: LD_ADDR_VAR 0 5
120448: PUSH
120449: DOUBLE
120450: LD_INT 1
120452: DEC
120453: ST_TO_ADDR
120454: LD_VAR 0 8
120458: PUSH
120459: FOR_TO
120460: IFFALSE 120655
// begin _d := rand ( 0 , 5 ) ;
120462: LD_ADDR_VAR 0 11
120466: PUSH
120467: LD_INT 0
120469: PPUSH
120470: LD_INT 5
120472: PPUSH
120473: CALL_OW 12
120477: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
120478: LD_ADDR_VAR 0 12
120482: PUSH
120483: LD_INT 2
120485: PPUSH
120486: LD_INT 6
120488: PPUSH
120489: CALL_OW 12
120493: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
120494: LD_ADDR_VAR 0 9
120498: PUSH
120499: LD_VAR 0 2
120503: PPUSH
120504: LD_VAR 0 11
120508: PPUSH
120509: LD_VAR 0 12
120513: PPUSH
120514: CALL_OW 272
120518: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
120519: LD_ADDR_VAR 0 10
120523: PUSH
120524: LD_VAR 0 3
120528: PPUSH
120529: LD_VAR 0 11
120533: PPUSH
120534: LD_VAR 0 12
120538: PPUSH
120539: CALL_OW 273
120543: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
120544: LD_VAR 0 9
120548: PPUSH
120549: LD_VAR 0 10
120553: PPUSH
120554: CALL_OW 488
120558: PUSH
120559: LD_VAR 0 9
120563: PUSH
120564: LD_VAR 0 10
120568: PUSH
120569: EMPTY
120570: LIST
120571: LIST
120572: PUSH
120573: LD_VAR 0 7
120577: IN
120578: NOT
120579: AND
120580: PUSH
120581: LD_VAR 0 9
120585: PPUSH
120586: LD_VAR 0 10
120590: PPUSH
120591: CALL_OW 458
120595: NOT
120596: AND
120597: IFFALSE 120639
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
120599: LD_ADDR_VAR 0 7
120603: PUSH
120604: LD_VAR 0 7
120608: PPUSH
120609: LD_VAR 0 7
120613: PUSH
120614: LD_INT 1
120616: PLUS
120617: PPUSH
120618: LD_VAR 0 9
120622: PUSH
120623: LD_VAR 0 10
120627: PUSH
120628: EMPTY
120629: LIST
120630: LIST
120631: PPUSH
120632: CALL_OW 1
120636: ST_TO_ADDR
120637: GO 120653
// i := i - 1 ;
120639: LD_ADDR_VAR 0 5
120643: PUSH
120644: LD_VAR 0 5
120648: PUSH
120649: LD_INT 1
120651: MINUS
120652: ST_TO_ADDR
// end ;
120653: GO 120459
120655: POP
120656: POP
// for i in tmp do
120657: LD_ADDR_VAR 0 5
120661: PUSH
120662: LD_VAR 0 7
120666: PUSH
120667: FOR_IN
120668: IFFALSE 120706
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
120670: LD_VAR 0 1
120674: PPUSH
120675: LD_VAR 0 5
120679: PUSH
120680: LD_INT 1
120682: ARRAY
120683: PPUSH
120684: LD_VAR 0 5
120688: PUSH
120689: LD_INT 2
120691: ARRAY
120692: PPUSH
120693: CALL 119648 0 3
120697: NOT
120698: IFFALSE 120704
// exit ;
120700: POP
120701: POP
120702: GO 120708
120704: GO 120667
120706: POP
120707: POP
// end ;
120708: LD_VAR 0 4
120712: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
120713: LD_INT 0
120715: PPUSH
120716: PPUSH
120717: PPUSH
120718: PPUSH
120719: PPUSH
120720: PPUSH
120721: PPUSH
// if not GetClass ( unit ) = class_sniper then
120722: LD_VAR 0 1
120726: PPUSH
120727: CALL_OW 257
120731: PUSH
120732: LD_INT 5
120734: EQUAL
120735: NOT
120736: IFFALSE 120740
// exit ;
120738: GO 121128
// dist := 8 ;
120740: LD_ADDR_VAR 0 5
120744: PUSH
120745: LD_INT 8
120747: ST_TO_ADDR
// viewRange := 12 ;
120748: LD_ADDR_VAR 0 7
120752: PUSH
120753: LD_INT 12
120755: ST_TO_ADDR
// side := GetSide ( unit ) ;
120756: LD_ADDR_VAR 0 6
120760: PUSH
120761: LD_VAR 0 1
120765: PPUSH
120766: CALL_OW 255
120770: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
120771: LD_INT 61
120773: PPUSH
120774: LD_VAR 0 6
120778: PPUSH
120779: CALL_OW 321
120783: PUSH
120784: LD_INT 2
120786: EQUAL
120787: IFFALSE 120797
// viewRange := 16 ;
120789: LD_ADDR_VAR 0 7
120793: PUSH
120794: LD_INT 16
120796: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
120797: LD_VAR 0 1
120801: PPUSH
120802: LD_VAR 0 2
120806: PPUSH
120807: LD_VAR 0 3
120811: PPUSH
120812: CALL_OW 297
120816: PUSH
120817: LD_VAR 0 5
120821: GREATER
120822: IFFALSE 120901
// begin ComMoveXY ( unit , x , y ) ;
120824: LD_VAR 0 1
120828: PPUSH
120829: LD_VAR 0 2
120833: PPUSH
120834: LD_VAR 0 3
120838: PPUSH
120839: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
120843: LD_INT 35
120845: PPUSH
120846: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
120850: LD_VAR 0 1
120854: PPUSH
120855: LD_VAR 0 2
120859: PPUSH
120860: LD_VAR 0 3
120864: PPUSH
120865: CALL 101016 0 3
120869: NOT
120870: IFFALSE 120874
// exit ;
120872: GO 121128
// until GetDistUnitXY ( unit , x , y ) < dist ;
120874: LD_VAR 0 1
120878: PPUSH
120879: LD_VAR 0 2
120883: PPUSH
120884: LD_VAR 0 3
120888: PPUSH
120889: CALL_OW 297
120893: PUSH
120894: LD_VAR 0 5
120898: LESS
120899: IFFALSE 120843
// end ; ComTurnXY ( unit , x , y ) ;
120901: LD_VAR 0 1
120905: PPUSH
120906: LD_VAR 0 2
120910: PPUSH
120911: LD_VAR 0 3
120915: PPUSH
120916: CALL_OW 118
// wait ( 5 ) ;
120920: LD_INT 5
120922: PPUSH
120923: CALL_OW 67
// _d := GetDir ( unit ) ;
120927: LD_ADDR_VAR 0 10
120931: PUSH
120932: LD_VAR 0 1
120936: PPUSH
120937: CALL_OW 254
120941: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
120942: LD_ADDR_VAR 0 8
120946: PUSH
120947: LD_VAR 0 1
120951: PPUSH
120952: CALL_OW 250
120956: PPUSH
120957: LD_VAR 0 10
120961: PPUSH
120962: LD_VAR 0 5
120966: PPUSH
120967: CALL_OW 272
120971: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
120972: LD_ADDR_VAR 0 9
120976: PUSH
120977: LD_VAR 0 1
120981: PPUSH
120982: CALL_OW 251
120986: PPUSH
120987: LD_VAR 0 10
120991: PPUSH
120992: LD_VAR 0 5
120996: PPUSH
120997: CALL_OW 273
121001: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
121002: LD_VAR 0 8
121006: PPUSH
121007: LD_VAR 0 9
121011: PPUSH
121012: CALL_OW 488
121016: NOT
121017: IFFALSE 121021
// exit ;
121019: GO 121128
// ComAnimCustom ( unit , 1 ) ;
121021: LD_VAR 0 1
121025: PPUSH
121026: LD_INT 1
121028: PPUSH
121029: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
121033: LD_VAR 0 8
121037: PPUSH
121038: LD_VAR 0 9
121042: PPUSH
121043: LD_VAR 0 6
121047: PPUSH
121048: LD_VAR 0 7
121052: PPUSH
121053: CALL_OW 330
// repeat wait ( 1 ) ;
121057: LD_INT 1
121059: PPUSH
121060: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
121064: LD_VAR 0 1
121068: PPUSH
121069: CALL_OW 316
121073: PUSH
121074: LD_VAR 0 1
121078: PPUSH
121079: CALL_OW 314
121083: OR
121084: PUSH
121085: LD_VAR 0 1
121089: PPUSH
121090: CALL_OW 302
121094: NOT
121095: OR
121096: PUSH
121097: LD_VAR 0 1
121101: PPUSH
121102: CALL_OW 301
121106: OR
121107: IFFALSE 121057
// RemoveSeeing ( _x , _y , side ) ;
121109: LD_VAR 0 8
121113: PPUSH
121114: LD_VAR 0 9
121118: PPUSH
121119: LD_VAR 0 6
121123: PPUSH
121124: CALL_OW 331
// end ; end_of_file
121128: LD_VAR 0 4
121132: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
121133: LD_INT 0
121135: PPUSH
121136: PPUSH
121137: PPUSH
121138: PPUSH
121139: PPUSH
121140: PPUSH
121141: PPUSH
121142: PPUSH
121143: PPUSH
121144: PPUSH
121145: PPUSH
121146: PPUSH
121147: PPUSH
121148: PPUSH
121149: PPUSH
121150: PPUSH
121151: PPUSH
121152: PPUSH
121153: PPUSH
121154: PPUSH
121155: PPUSH
121156: PPUSH
121157: PPUSH
121158: PPUSH
121159: PPUSH
121160: PPUSH
121161: PPUSH
121162: PPUSH
121163: PPUSH
121164: PPUSH
121165: PPUSH
121166: PPUSH
121167: PPUSH
121168: PPUSH
// if not list then
121169: LD_VAR 0 1
121173: NOT
121174: IFFALSE 121178
// exit ;
121176: GO 125837
// base := list [ 1 ] ;
121178: LD_ADDR_VAR 0 3
121182: PUSH
121183: LD_VAR 0 1
121187: PUSH
121188: LD_INT 1
121190: ARRAY
121191: ST_TO_ADDR
// group := list [ 2 ] ;
121192: LD_ADDR_VAR 0 4
121196: PUSH
121197: LD_VAR 0 1
121201: PUSH
121202: LD_INT 2
121204: ARRAY
121205: ST_TO_ADDR
// path := list [ 3 ] ;
121206: LD_ADDR_VAR 0 5
121210: PUSH
121211: LD_VAR 0 1
121215: PUSH
121216: LD_INT 3
121218: ARRAY
121219: ST_TO_ADDR
// flags := list [ 4 ] ;
121220: LD_ADDR_VAR 0 6
121224: PUSH
121225: LD_VAR 0 1
121229: PUSH
121230: LD_INT 4
121232: ARRAY
121233: ST_TO_ADDR
// mined := [ ] ;
121234: LD_ADDR_VAR 0 27
121238: PUSH
121239: EMPTY
121240: ST_TO_ADDR
// bombed := [ ] ;
121241: LD_ADDR_VAR 0 28
121245: PUSH
121246: EMPTY
121247: ST_TO_ADDR
// healers := [ ] ;
121248: LD_ADDR_VAR 0 31
121252: PUSH
121253: EMPTY
121254: ST_TO_ADDR
// to_heal := [ ] ;
121255: LD_ADDR_VAR 0 30
121259: PUSH
121260: EMPTY
121261: ST_TO_ADDR
// repairs := [ ] ;
121262: LD_ADDR_VAR 0 33
121266: PUSH
121267: EMPTY
121268: ST_TO_ADDR
// to_repair := [ ] ;
121269: LD_ADDR_VAR 0 32
121273: PUSH
121274: EMPTY
121275: ST_TO_ADDR
// if not group or not path then
121276: LD_VAR 0 4
121280: NOT
121281: PUSH
121282: LD_VAR 0 5
121286: NOT
121287: OR
121288: IFFALSE 121292
// exit ;
121290: GO 125837
// side := GetSide ( group [ 1 ] ) ;
121292: LD_ADDR_VAR 0 35
121296: PUSH
121297: LD_VAR 0 4
121301: PUSH
121302: LD_INT 1
121304: ARRAY
121305: PPUSH
121306: CALL_OW 255
121310: ST_TO_ADDR
// if flags then
121311: LD_VAR 0 6
121315: IFFALSE 121459
// begin f_ignore_area := flags [ 1 ] ;
121317: LD_ADDR_VAR 0 17
121321: PUSH
121322: LD_VAR 0 6
121326: PUSH
121327: LD_INT 1
121329: ARRAY
121330: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
121331: LD_ADDR_VAR 0 18
121335: PUSH
121336: LD_VAR 0 6
121340: PUSH
121341: LD_INT 2
121343: ARRAY
121344: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
121345: LD_ADDR_VAR 0 19
121349: PUSH
121350: LD_VAR 0 6
121354: PUSH
121355: LD_INT 3
121357: ARRAY
121358: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
121359: LD_ADDR_VAR 0 20
121363: PUSH
121364: LD_VAR 0 6
121368: PUSH
121369: LD_INT 4
121371: ARRAY
121372: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
121373: LD_ADDR_VAR 0 21
121377: PUSH
121378: LD_VAR 0 6
121382: PUSH
121383: LD_INT 5
121385: ARRAY
121386: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
121387: LD_ADDR_VAR 0 22
121391: PUSH
121392: LD_VAR 0 6
121396: PUSH
121397: LD_INT 6
121399: ARRAY
121400: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
121401: LD_ADDR_VAR 0 23
121405: PUSH
121406: LD_VAR 0 6
121410: PUSH
121411: LD_INT 7
121413: ARRAY
121414: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
121415: LD_ADDR_VAR 0 24
121419: PUSH
121420: LD_VAR 0 6
121424: PUSH
121425: LD_INT 8
121427: ARRAY
121428: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
121429: LD_ADDR_VAR 0 25
121433: PUSH
121434: LD_VAR 0 6
121438: PUSH
121439: LD_INT 9
121441: ARRAY
121442: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
121443: LD_ADDR_VAR 0 26
121447: PUSH
121448: LD_VAR 0 6
121452: PUSH
121453: LD_INT 10
121455: ARRAY
121456: ST_TO_ADDR
// end else
121457: GO 121539
// begin f_ignore_area := false ;
121459: LD_ADDR_VAR 0 17
121463: PUSH
121464: LD_INT 0
121466: ST_TO_ADDR
// f_capture := false ;
121467: LD_ADDR_VAR 0 18
121471: PUSH
121472: LD_INT 0
121474: ST_TO_ADDR
// f_ignore_civ := false ;
121475: LD_ADDR_VAR 0 19
121479: PUSH
121480: LD_INT 0
121482: ST_TO_ADDR
// f_murder := false ;
121483: LD_ADDR_VAR 0 20
121487: PUSH
121488: LD_INT 0
121490: ST_TO_ADDR
// f_mines := false ;
121491: LD_ADDR_VAR 0 21
121495: PUSH
121496: LD_INT 0
121498: ST_TO_ADDR
// f_repair := false ;
121499: LD_ADDR_VAR 0 22
121503: PUSH
121504: LD_INT 0
121506: ST_TO_ADDR
// f_heal := false ;
121507: LD_ADDR_VAR 0 23
121511: PUSH
121512: LD_INT 0
121514: ST_TO_ADDR
// f_spacetime := false ;
121515: LD_ADDR_VAR 0 24
121519: PUSH
121520: LD_INT 0
121522: ST_TO_ADDR
// f_attack_depot := false ;
121523: LD_ADDR_VAR 0 25
121527: PUSH
121528: LD_INT 0
121530: ST_TO_ADDR
// f_crawl := false ;
121531: LD_ADDR_VAR 0 26
121535: PUSH
121536: LD_INT 0
121538: ST_TO_ADDR
// end ; if f_heal then
121539: LD_VAR 0 23
121543: IFFALSE 121570
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
121545: LD_ADDR_VAR 0 31
121549: PUSH
121550: LD_VAR 0 4
121554: PPUSH
121555: LD_INT 25
121557: PUSH
121558: LD_INT 4
121560: PUSH
121561: EMPTY
121562: LIST
121563: LIST
121564: PPUSH
121565: CALL_OW 72
121569: ST_TO_ADDR
// if f_repair then
121570: LD_VAR 0 22
121574: IFFALSE 121601
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
121576: LD_ADDR_VAR 0 33
121580: PUSH
121581: LD_VAR 0 4
121585: PPUSH
121586: LD_INT 25
121588: PUSH
121589: LD_INT 3
121591: PUSH
121592: EMPTY
121593: LIST
121594: LIST
121595: PPUSH
121596: CALL_OW 72
121600: ST_TO_ADDR
// units_path := [ ] ;
121601: LD_ADDR_VAR 0 16
121605: PUSH
121606: EMPTY
121607: ST_TO_ADDR
// for i = 1 to group do
121608: LD_ADDR_VAR 0 7
121612: PUSH
121613: DOUBLE
121614: LD_INT 1
121616: DEC
121617: ST_TO_ADDR
121618: LD_VAR 0 4
121622: PUSH
121623: FOR_TO
121624: IFFALSE 121653
// units_path := Replace ( units_path , i , path ) ;
121626: LD_ADDR_VAR 0 16
121630: PUSH
121631: LD_VAR 0 16
121635: PPUSH
121636: LD_VAR 0 7
121640: PPUSH
121641: LD_VAR 0 5
121645: PPUSH
121646: CALL_OW 1
121650: ST_TO_ADDR
121651: GO 121623
121653: POP
121654: POP
// repeat for i = group downto 1 do
121655: LD_ADDR_VAR 0 7
121659: PUSH
121660: DOUBLE
121661: LD_VAR 0 4
121665: INC
121666: ST_TO_ADDR
121667: LD_INT 1
121669: PUSH
121670: FOR_DOWNTO
121671: IFFALSE 125793
// begin wait ( 5 ) ;
121673: LD_INT 5
121675: PPUSH
121676: CALL_OW 67
// tmp := [ ] ;
121680: LD_ADDR_VAR 0 14
121684: PUSH
121685: EMPTY
121686: ST_TO_ADDR
// attacking := false ;
121687: LD_ADDR_VAR 0 29
121691: PUSH
121692: LD_INT 0
121694: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
121695: LD_VAR 0 4
121699: PUSH
121700: LD_VAR 0 7
121704: ARRAY
121705: PPUSH
121706: CALL_OW 301
121710: PUSH
121711: LD_VAR 0 4
121715: PUSH
121716: LD_VAR 0 7
121720: ARRAY
121721: NOT
121722: OR
121723: IFFALSE 121832
// begin if GetType ( group [ i ] ) = unit_human then
121725: LD_VAR 0 4
121729: PUSH
121730: LD_VAR 0 7
121734: ARRAY
121735: PPUSH
121736: CALL_OW 247
121740: PUSH
121741: LD_INT 1
121743: EQUAL
121744: IFFALSE 121790
// begin to_heal := to_heal diff group [ i ] ;
121746: LD_ADDR_VAR 0 30
121750: PUSH
121751: LD_VAR 0 30
121755: PUSH
121756: LD_VAR 0 4
121760: PUSH
121761: LD_VAR 0 7
121765: ARRAY
121766: DIFF
121767: ST_TO_ADDR
// healers := healers diff group [ i ] ;
121768: LD_ADDR_VAR 0 31
121772: PUSH
121773: LD_VAR 0 31
121777: PUSH
121778: LD_VAR 0 4
121782: PUSH
121783: LD_VAR 0 7
121787: ARRAY
121788: DIFF
121789: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
121790: LD_ADDR_VAR 0 4
121794: PUSH
121795: LD_VAR 0 4
121799: PPUSH
121800: LD_VAR 0 7
121804: PPUSH
121805: CALL_OW 3
121809: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
121810: LD_ADDR_VAR 0 16
121814: PUSH
121815: LD_VAR 0 16
121819: PPUSH
121820: LD_VAR 0 7
121824: PPUSH
121825: CALL_OW 3
121829: ST_TO_ADDR
// continue ;
121830: GO 121670
// end ; if f_repair then
121832: LD_VAR 0 22
121836: IFFALSE 122325
// begin if GetType ( group [ i ] ) = unit_vehicle then
121838: LD_VAR 0 4
121842: PUSH
121843: LD_VAR 0 7
121847: ARRAY
121848: PPUSH
121849: CALL_OW 247
121853: PUSH
121854: LD_INT 2
121856: EQUAL
121857: IFFALSE 122047
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
121859: LD_VAR 0 4
121863: PUSH
121864: LD_VAR 0 7
121868: ARRAY
121869: PPUSH
121870: CALL_OW 256
121874: PUSH
121875: LD_INT 700
121877: LESS
121878: PUSH
121879: LD_VAR 0 4
121883: PUSH
121884: LD_VAR 0 7
121888: ARRAY
121889: PUSH
121890: LD_VAR 0 32
121894: IN
121895: NOT
121896: AND
121897: IFFALSE 121921
// to_repair := to_repair union group [ i ] ;
121899: LD_ADDR_VAR 0 32
121903: PUSH
121904: LD_VAR 0 32
121908: PUSH
121909: LD_VAR 0 4
121913: PUSH
121914: LD_VAR 0 7
121918: ARRAY
121919: UNION
121920: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
121921: LD_VAR 0 4
121925: PUSH
121926: LD_VAR 0 7
121930: ARRAY
121931: PPUSH
121932: CALL_OW 256
121936: PUSH
121937: LD_INT 1000
121939: EQUAL
121940: PUSH
121941: LD_VAR 0 4
121945: PUSH
121946: LD_VAR 0 7
121950: ARRAY
121951: PUSH
121952: LD_VAR 0 32
121956: IN
121957: AND
121958: IFFALSE 121982
// to_repair := to_repair diff group [ i ] ;
121960: LD_ADDR_VAR 0 32
121964: PUSH
121965: LD_VAR 0 32
121969: PUSH
121970: LD_VAR 0 4
121974: PUSH
121975: LD_VAR 0 7
121979: ARRAY
121980: DIFF
121981: ST_TO_ADDR
// if group [ i ] in to_repair then
121982: LD_VAR 0 4
121986: PUSH
121987: LD_VAR 0 7
121991: ARRAY
121992: PUSH
121993: LD_VAR 0 32
121997: IN
121998: IFFALSE 122045
// begin if not IsInArea ( group [ i ] , f_repair ) then
122000: LD_VAR 0 4
122004: PUSH
122005: LD_VAR 0 7
122009: ARRAY
122010: PPUSH
122011: LD_VAR 0 22
122015: PPUSH
122016: CALL_OW 308
122020: NOT
122021: IFFALSE 122043
// ComMoveToArea ( group [ i ] , f_repair ) ;
122023: LD_VAR 0 4
122027: PUSH
122028: LD_VAR 0 7
122032: ARRAY
122033: PPUSH
122034: LD_VAR 0 22
122038: PPUSH
122039: CALL_OW 113
// continue ;
122043: GO 121670
// end ; end else
122045: GO 122325
// if group [ i ] in repairs then
122047: LD_VAR 0 4
122051: PUSH
122052: LD_VAR 0 7
122056: ARRAY
122057: PUSH
122058: LD_VAR 0 33
122062: IN
122063: IFFALSE 122325
// begin if IsInUnit ( group [ i ] ) then
122065: LD_VAR 0 4
122069: PUSH
122070: LD_VAR 0 7
122074: ARRAY
122075: PPUSH
122076: CALL_OW 310
122080: IFFALSE 122148
// begin z := IsInUnit ( group [ i ] ) ;
122082: LD_ADDR_VAR 0 13
122086: PUSH
122087: LD_VAR 0 4
122091: PUSH
122092: LD_VAR 0 7
122096: ARRAY
122097: PPUSH
122098: CALL_OW 310
122102: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
122103: LD_VAR 0 13
122107: PUSH
122108: LD_VAR 0 32
122112: IN
122113: PUSH
122114: LD_VAR 0 13
122118: PPUSH
122119: LD_VAR 0 22
122123: PPUSH
122124: CALL_OW 308
122128: AND
122129: IFFALSE 122146
// ComExitVehicle ( group [ i ] ) ;
122131: LD_VAR 0 4
122135: PUSH
122136: LD_VAR 0 7
122140: ARRAY
122141: PPUSH
122142: CALL_OW 121
// end else
122146: GO 122325
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
122148: LD_ADDR_VAR 0 13
122152: PUSH
122153: LD_VAR 0 4
122157: PPUSH
122158: LD_INT 95
122160: PUSH
122161: LD_VAR 0 22
122165: PUSH
122166: EMPTY
122167: LIST
122168: LIST
122169: PUSH
122170: LD_INT 58
122172: PUSH
122173: EMPTY
122174: LIST
122175: PUSH
122176: EMPTY
122177: LIST
122178: LIST
122179: PPUSH
122180: CALL_OW 72
122184: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
122185: LD_VAR 0 4
122189: PUSH
122190: LD_VAR 0 7
122194: ARRAY
122195: PPUSH
122196: CALL_OW 314
122200: NOT
122201: IFFALSE 122323
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
122203: LD_ADDR_VAR 0 10
122207: PUSH
122208: LD_VAR 0 13
122212: PPUSH
122213: LD_VAR 0 4
122217: PUSH
122218: LD_VAR 0 7
122222: ARRAY
122223: PPUSH
122224: CALL_OW 74
122228: ST_TO_ADDR
// if not x then
122229: LD_VAR 0 10
122233: NOT
122234: IFFALSE 122238
// continue ;
122236: GO 121670
// if GetLives ( x ) < 1000 then
122238: LD_VAR 0 10
122242: PPUSH
122243: CALL_OW 256
122247: PUSH
122248: LD_INT 1000
122250: LESS
122251: IFFALSE 122275
// ComRepairVehicle ( group [ i ] , x ) else
122253: LD_VAR 0 4
122257: PUSH
122258: LD_VAR 0 7
122262: ARRAY
122263: PPUSH
122264: LD_VAR 0 10
122268: PPUSH
122269: CALL_OW 129
122273: GO 122323
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
122275: LD_VAR 0 23
122279: PUSH
122280: LD_VAR 0 4
122284: PUSH
122285: LD_VAR 0 7
122289: ARRAY
122290: PPUSH
122291: CALL_OW 256
122295: PUSH
122296: LD_INT 1000
122298: LESS
122299: AND
122300: NOT
122301: IFFALSE 122323
// ComEnterUnit ( group [ i ] , x ) ;
122303: LD_VAR 0 4
122307: PUSH
122308: LD_VAR 0 7
122312: ARRAY
122313: PPUSH
122314: LD_VAR 0 10
122318: PPUSH
122319: CALL_OW 120
// end ; continue ;
122323: GO 121670
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
122325: LD_VAR 0 23
122329: PUSH
122330: LD_VAR 0 4
122334: PUSH
122335: LD_VAR 0 7
122339: ARRAY
122340: PPUSH
122341: CALL_OW 247
122345: PUSH
122346: LD_INT 1
122348: EQUAL
122349: AND
122350: IFFALSE 122828
// begin if group [ i ] in healers then
122352: LD_VAR 0 4
122356: PUSH
122357: LD_VAR 0 7
122361: ARRAY
122362: PUSH
122363: LD_VAR 0 31
122367: IN
122368: IFFALSE 122641
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
122370: LD_VAR 0 4
122374: PUSH
122375: LD_VAR 0 7
122379: ARRAY
122380: PPUSH
122381: LD_VAR 0 23
122385: PPUSH
122386: CALL_OW 308
122390: NOT
122391: PUSH
122392: LD_VAR 0 4
122396: PUSH
122397: LD_VAR 0 7
122401: ARRAY
122402: PPUSH
122403: CALL_OW 314
122407: NOT
122408: AND
122409: IFFALSE 122433
// ComMoveToArea ( group [ i ] , f_heal ) else
122411: LD_VAR 0 4
122415: PUSH
122416: LD_VAR 0 7
122420: ARRAY
122421: PPUSH
122422: LD_VAR 0 23
122426: PPUSH
122427: CALL_OW 113
122431: GO 122639
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
122433: LD_VAR 0 4
122437: PUSH
122438: LD_VAR 0 7
122442: ARRAY
122443: PPUSH
122444: CALL 99539 0 1
122448: PPUSH
122449: CALL_OW 256
122453: PUSH
122454: LD_INT 1000
122456: EQUAL
122457: IFFALSE 122476
// ComStop ( group [ i ] ) else
122459: LD_VAR 0 4
122463: PUSH
122464: LD_VAR 0 7
122468: ARRAY
122469: PPUSH
122470: CALL_OW 141
122474: GO 122639
// if not HasTask ( group [ i ] ) and to_heal then
122476: LD_VAR 0 4
122480: PUSH
122481: LD_VAR 0 7
122485: ARRAY
122486: PPUSH
122487: CALL_OW 314
122491: NOT
122492: PUSH
122493: LD_VAR 0 30
122497: AND
122498: IFFALSE 122639
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
122500: LD_ADDR_VAR 0 13
122504: PUSH
122505: LD_VAR 0 30
122509: PPUSH
122510: LD_INT 3
122512: PUSH
122513: LD_INT 54
122515: PUSH
122516: EMPTY
122517: LIST
122518: PUSH
122519: EMPTY
122520: LIST
122521: LIST
122522: PPUSH
122523: CALL_OW 72
122527: PPUSH
122528: LD_VAR 0 4
122532: PUSH
122533: LD_VAR 0 7
122537: ARRAY
122538: PPUSH
122539: CALL_OW 74
122543: ST_TO_ADDR
// if z then
122544: LD_VAR 0 13
122548: IFFALSE 122639
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
122550: LD_INT 91
122552: PUSH
122553: LD_VAR 0 13
122557: PUSH
122558: LD_INT 10
122560: PUSH
122561: EMPTY
122562: LIST
122563: LIST
122564: LIST
122565: PUSH
122566: LD_INT 81
122568: PUSH
122569: LD_VAR 0 13
122573: PPUSH
122574: CALL_OW 255
122578: PUSH
122579: EMPTY
122580: LIST
122581: LIST
122582: PUSH
122583: EMPTY
122584: LIST
122585: LIST
122586: PPUSH
122587: CALL_OW 69
122591: PUSH
122592: LD_INT 0
122594: EQUAL
122595: IFFALSE 122619
// ComHeal ( group [ i ] , z ) else
122597: LD_VAR 0 4
122601: PUSH
122602: LD_VAR 0 7
122606: ARRAY
122607: PPUSH
122608: LD_VAR 0 13
122612: PPUSH
122613: CALL_OW 128
122617: GO 122639
// ComMoveToArea ( group [ i ] , f_heal ) ;
122619: LD_VAR 0 4
122623: PUSH
122624: LD_VAR 0 7
122628: ARRAY
122629: PPUSH
122630: LD_VAR 0 23
122634: PPUSH
122635: CALL_OW 113
// end ; continue ;
122639: GO 121670
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
122641: LD_VAR 0 4
122645: PUSH
122646: LD_VAR 0 7
122650: ARRAY
122651: PPUSH
122652: CALL_OW 256
122656: PUSH
122657: LD_INT 700
122659: LESS
122660: PUSH
122661: LD_VAR 0 4
122665: PUSH
122666: LD_VAR 0 7
122670: ARRAY
122671: PUSH
122672: LD_VAR 0 30
122676: IN
122677: NOT
122678: AND
122679: IFFALSE 122703
// to_heal := to_heal union group [ i ] ;
122681: LD_ADDR_VAR 0 30
122685: PUSH
122686: LD_VAR 0 30
122690: PUSH
122691: LD_VAR 0 4
122695: PUSH
122696: LD_VAR 0 7
122700: ARRAY
122701: UNION
122702: ST_TO_ADDR
// if group [ i ] in to_heal then
122703: LD_VAR 0 4
122707: PUSH
122708: LD_VAR 0 7
122712: ARRAY
122713: PUSH
122714: LD_VAR 0 30
122718: IN
122719: IFFALSE 122828
// begin if GetLives ( group [ i ] ) = 1000 then
122721: LD_VAR 0 4
122725: PUSH
122726: LD_VAR 0 7
122730: ARRAY
122731: PPUSH
122732: CALL_OW 256
122736: PUSH
122737: LD_INT 1000
122739: EQUAL
122740: IFFALSE 122766
// to_heal := to_heal diff group [ i ] else
122742: LD_ADDR_VAR 0 30
122746: PUSH
122747: LD_VAR 0 30
122751: PUSH
122752: LD_VAR 0 4
122756: PUSH
122757: LD_VAR 0 7
122761: ARRAY
122762: DIFF
122763: ST_TO_ADDR
122764: GO 122828
// begin if not IsInArea ( group [ i ] , to_heal ) then
122766: LD_VAR 0 4
122770: PUSH
122771: LD_VAR 0 7
122775: ARRAY
122776: PPUSH
122777: LD_VAR 0 30
122781: PPUSH
122782: CALL_OW 308
122786: NOT
122787: IFFALSE 122811
// ComMoveToArea ( group [ i ] , f_heal ) else
122789: LD_VAR 0 4
122793: PUSH
122794: LD_VAR 0 7
122798: ARRAY
122799: PPUSH
122800: LD_VAR 0 23
122804: PPUSH
122805: CALL_OW 113
122809: GO 122826
// ComHold ( group [ i ] ) ;
122811: LD_VAR 0 4
122815: PUSH
122816: LD_VAR 0 7
122820: ARRAY
122821: PPUSH
122822: CALL_OW 140
// continue ;
122826: GO 121670
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
122828: LD_VAR 0 4
122832: PUSH
122833: LD_VAR 0 7
122837: ARRAY
122838: PPUSH
122839: LD_INT 10
122841: PPUSH
122842: CALL 97959 0 2
122846: NOT
122847: PUSH
122848: LD_VAR 0 16
122852: PUSH
122853: LD_VAR 0 7
122857: ARRAY
122858: PUSH
122859: EMPTY
122860: EQUAL
122861: NOT
122862: AND
122863: IFFALSE 123129
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
122865: LD_VAR 0 4
122869: PUSH
122870: LD_VAR 0 7
122874: ARRAY
122875: PPUSH
122876: CALL_OW 262
122880: PUSH
122881: LD_INT 1
122883: PUSH
122884: LD_INT 2
122886: PUSH
122887: EMPTY
122888: LIST
122889: LIST
122890: IN
122891: IFFALSE 122932
// if GetFuel ( group [ i ] ) < 10 then
122893: LD_VAR 0 4
122897: PUSH
122898: LD_VAR 0 7
122902: ARRAY
122903: PPUSH
122904: CALL_OW 261
122908: PUSH
122909: LD_INT 10
122911: LESS
122912: IFFALSE 122932
// SetFuel ( group [ i ] , 12 ) ;
122914: LD_VAR 0 4
122918: PUSH
122919: LD_VAR 0 7
122923: ARRAY
122924: PPUSH
122925: LD_INT 12
122927: PPUSH
122928: CALL_OW 240
// if units_path [ i ] then
122932: LD_VAR 0 16
122936: PUSH
122937: LD_VAR 0 7
122941: ARRAY
122942: IFFALSE 123127
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
122944: LD_VAR 0 4
122948: PUSH
122949: LD_VAR 0 7
122953: ARRAY
122954: PPUSH
122955: LD_VAR 0 16
122959: PUSH
122960: LD_VAR 0 7
122964: ARRAY
122965: PUSH
122966: LD_INT 1
122968: ARRAY
122969: PUSH
122970: LD_INT 1
122972: ARRAY
122973: PPUSH
122974: LD_VAR 0 16
122978: PUSH
122979: LD_VAR 0 7
122983: ARRAY
122984: PUSH
122985: LD_INT 1
122987: ARRAY
122988: PUSH
122989: LD_INT 2
122991: ARRAY
122992: PPUSH
122993: CALL_OW 297
122997: PUSH
122998: LD_INT 6
123000: GREATER
123001: IFFALSE 123076
// begin if not HasTask ( group [ i ] ) then
123003: LD_VAR 0 4
123007: PUSH
123008: LD_VAR 0 7
123012: ARRAY
123013: PPUSH
123014: CALL_OW 314
123018: NOT
123019: IFFALSE 123074
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
123021: LD_VAR 0 4
123025: PUSH
123026: LD_VAR 0 7
123030: ARRAY
123031: PPUSH
123032: LD_VAR 0 16
123036: PUSH
123037: LD_VAR 0 7
123041: ARRAY
123042: PUSH
123043: LD_INT 1
123045: ARRAY
123046: PUSH
123047: LD_INT 1
123049: ARRAY
123050: PPUSH
123051: LD_VAR 0 16
123055: PUSH
123056: LD_VAR 0 7
123060: ARRAY
123061: PUSH
123062: LD_INT 1
123064: ARRAY
123065: PUSH
123066: LD_INT 2
123068: ARRAY
123069: PPUSH
123070: CALL_OW 114
// end else
123074: GO 123127
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
123076: LD_ADDR_VAR 0 15
123080: PUSH
123081: LD_VAR 0 16
123085: PUSH
123086: LD_VAR 0 7
123090: ARRAY
123091: PPUSH
123092: LD_INT 1
123094: PPUSH
123095: CALL_OW 3
123099: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
123100: LD_ADDR_VAR 0 16
123104: PUSH
123105: LD_VAR 0 16
123109: PPUSH
123110: LD_VAR 0 7
123114: PPUSH
123115: LD_VAR 0 15
123119: PPUSH
123120: CALL_OW 1
123124: ST_TO_ADDR
// continue ;
123125: GO 121670
// end ; end ; end else
123127: GO 125791
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
123129: LD_ADDR_VAR 0 14
123133: PUSH
123134: LD_INT 81
123136: PUSH
123137: LD_VAR 0 4
123141: PUSH
123142: LD_VAR 0 7
123146: ARRAY
123147: PPUSH
123148: CALL_OW 255
123152: PUSH
123153: EMPTY
123154: LIST
123155: LIST
123156: PPUSH
123157: CALL_OW 69
123161: ST_TO_ADDR
// if not tmp then
123162: LD_VAR 0 14
123166: NOT
123167: IFFALSE 123171
// continue ;
123169: GO 121670
// if f_ignore_area then
123171: LD_VAR 0 17
123175: IFFALSE 123263
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
123177: LD_ADDR_VAR 0 15
123181: PUSH
123182: LD_VAR 0 14
123186: PPUSH
123187: LD_INT 3
123189: PUSH
123190: LD_INT 92
123192: PUSH
123193: LD_VAR 0 17
123197: PUSH
123198: LD_INT 1
123200: ARRAY
123201: PUSH
123202: LD_VAR 0 17
123206: PUSH
123207: LD_INT 2
123209: ARRAY
123210: PUSH
123211: LD_VAR 0 17
123215: PUSH
123216: LD_INT 3
123218: ARRAY
123219: PUSH
123220: EMPTY
123221: LIST
123222: LIST
123223: LIST
123224: LIST
123225: PUSH
123226: EMPTY
123227: LIST
123228: LIST
123229: PPUSH
123230: CALL_OW 72
123234: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
123235: LD_VAR 0 14
123239: PUSH
123240: LD_VAR 0 15
123244: DIFF
123245: IFFALSE 123263
// tmp := tmp diff tmp2 ;
123247: LD_ADDR_VAR 0 14
123251: PUSH
123252: LD_VAR 0 14
123256: PUSH
123257: LD_VAR 0 15
123261: DIFF
123262: ST_TO_ADDR
// end ; if not f_murder then
123263: LD_VAR 0 20
123267: NOT
123268: IFFALSE 123326
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
123270: LD_ADDR_VAR 0 15
123274: PUSH
123275: LD_VAR 0 14
123279: PPUSH
123280: LD_INT 3
123282: PUSH
123283: LD_INT 50
123285: PUSH
123286: EMPTY
123287: LIST
123288: PUSH
123289: EMPTY
123290: LIST
123291: LIST
123292: PPUSH
123293: CALL_OW 72
123297: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
123298: LD_VAR 0 14
123302: PUSH
123303: LD_VAR 0 15
123307: DIFF
123308: IFFALSE 123326
// tmp := tmp diff tmp2 ;
123310: LD_ADDR_VAR 0 14
123314: PUSH
123315: LD_VAR 0 14
123319: PUSH
123320: LD_VAR 0 15
123324: DIFF
123325: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
123326: LD_ADDR_VAR 0 14
123330: PUSH
123331: LD_VAR 0 4
123335: PUSH
123336: LD_VAR 0 7
123340: ARRAY
123341: PPUSH
123342: LD_VAR 0 14
123346: PPUSH
123347: LD_INT 1
123349: PPUSH
123350: LD_INT 1
123352: PPUSH
123353: CALL 70893 0 4
123357: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
123358: LD_VAR 0 4
123362: PUSH
123363: LD_VAR 0 7
123367: ARRAY
123368: PPUSH
123369: CALL_OW 257
123373: PUSH
123374: LD_INT 1
123376: EQUAL
123377: IFFALSE 123825
// begin if WantPlant ( group [ i ] ) then
123379: LD_VAR 0 4
123383: PUSH
123384: LD_VAR 0 7
123388: ARRAY
123389: PPUSH
123390: CALL 70394 0 1
123394: IFFALSE 123398
// continue ;
123396: GO 121670
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
123398: LD_VAR 0 18
123402: PUSH
123403: LD_VAR 0 4
123407: PUSH
123408: LD_VAR 0 7
123412: ARRAY
123413: PPUSH
123414: CALL_OW 310
123418: NOT
123419: AND
123420: PUSH
123421: LD_VAR 0 14
123425: PUSH
123426: LD_INT 1
123428: ARRAY
123429: PUSH
123430: LD_VAR 0 14
123434: PPUSH
123435: LD_INT 21
123437: PUSH
123438: LD_INT 2
123440: PUSH
123441: EMPTY
123442: LIST
123443: LIST
123444: PUSH
123445: LD_INT 58
123447: PUSH
123448: EMPTY
123449: LIST
123450: PUSH
123451: EMPTY
123452: LIST
123453: LIST
123454: PPUSH
123455: CALL_OW 72
123459: IN
123460: AND
123461: IFFALSE 123497
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
123463: LD_VAR 0 4
123467: PUSH
123468: LD_VAR 0 7
123472: ARRAY
123473: PPUSH
123474: LD_VAR 0 14
123478: PUSH
123479: LD_INT 1
123481: ARRAY
123482: PPUSH
123483: CALL_OW 120
// attacking := true ;
123487: LD_ADDR_VAR 0 29
123491: PUSH
123492: LD_INT 1
123494: ST_TO_ADDR
// continue ;
123495: GO 121670
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
123497: LD_VAR 0 26
123501: PUSH
123502: LD_VAR 0 4
123506: PUSH
123507: LD_VAR 0 7
123511: ARRAY
123512: PPUSH
123513: CALL_OW 257
123517: PUSH
123518: LD_INT 1
123520: EQUAL
123521: AND
123522: PUSH
123523: LD_VAR 0 4
123527: PUSH
123528: LD_VAR 0 7
123532: ARRAY
123533: PPUSH
123534: CALL_OW 256
123538: PUSH
123539: LD_INT 800
123541: LESS
123542: AND
123543: PUSH
123544: LD_VAR 0 4
123548: PUSH
123549: LD_VAR 0 7
123553: ARRAY
123554: PPUSH
123555: CALL_OW 318
123559: NOT
123560: AND
123561: IFFALSE 123578
// ComCrawl ( group [ i ] ) ;
123563: LD_VAR 0 4
123567: PUSH
123568: LD_VAR 0 7
123572: ARRAY
123573: PPUSH
123574: CALL_OW 137
// if f_mines then
123578: LD_VAR 0 21
123582: IFFALSE 123825
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
123584: LD_VAR 0 14
123588: PUSH
123589: LD_INT 1
123591: ARRAY
123592: PPUSH
123593: CALL_OW 247
123597: PUSH
123598: LD_INT 3
123600: EQUAL
123601: PUSH
123602: LD_VAR 0 14
123606: PUSH
123607: LD_INT 1
123609: ARRAY
123610: PUSH
123611: LD_VAR 0 27
123615: IN
123616: NOT
123617: AND
123618: IFFALSE 123825
// begin x := GetX ( tmp [ 1 ] ) ;
123620: LD_ADDR_VAR 0 10
123624: PUSH
123625: LD_VAR 0 14
123629: PUSH
123630: LD_INT 1
123632: ARRAY
123633: PPUSH
123634: CALL_OW 250
123638: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
123639: LD_ADDR_VAR 0 11
123643: PUSH
123644: LD_VAR 0 14
123648: PUSH
123649: LD_INT 1
123651: ARRAY
123652: PPUSH
123653: CALL_OW 251
123657: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
123658: LD_ADDR_VAR 0 12
123662: PUSH
123663: LD_VAR 0 4
123667: PUSH
123668: LD_VAR 0 7
123672: ARRAY
123673: PPUSH
123674: CALL 98044 0 1
123678: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
123679: LD_VAR 0 4
123683: PUSH
123684: LD_VAR 0 7
123688: ARRAY
123689: PPUSH
123690: LD_VAR 0 10
123694: PPUSH
123695: LD_VAR 0 11
123699: PPUSH
123700: LD_VAR 0 14
123704: PUSH
123705: LD_INT 1
123707: ARRAY
123708: PPUSH
123709: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
123713: LD_VAR 0 4
123717: PUSH
123718: LD_VAR 0 7
123722: ARRAY
123723: PPUSH
123724: LD_VAR 0 10
123728: PPUSH
123729: LD_VAR 0 12
123733: PPUSH
123734: LD_INT 7
123736: PPUSH
123737: CALL_OW 272
123741: PPUSH
123742: LD_VAR 0 11
123746: PPUSH
123747: LD_VAR 0 12
123751: PPUSH
123752: LD_INT 7
123754: PPUSH
123755: CALL_OW 273
123759: PPUSH
123760: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
123764: LD_VAR 0 4
123768: PUSH
123769: LD_VAR 0 7
123773: ARRAY
123774: PPUSH
123775: LD_INT 71
123777: PPUSH
123778: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
123782: LD_ADDR_VAR 0 27
123786: PUSH
123787: LD_VAR 0 27
123791: PPUSH
123792: LD_VAR 0 27
123796: PUSH
123797: LD_INT 1
123799: PLUS
123800: PPUSH
123801: LD_VAR 0 14
123805: PUSH
123806: LD_INT 1
123808: ARRAY
123809: PPUSH
123810: CALL_OW 1
123814: ST_TO_ADDR
// attacking := true ;
123815: LD_ADDR_VAR 0 29
123819: PUSH
123820: LD_INT 1
123822: ST_TO_ADDR
// continue ;
123823: GO 121670
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
123825: LD_VAR 0 4
123829: PUSH
123830: LD_VAR 0 7
123834: ARRAY
123835: PPUSH
123836: CALL_OW 257
123840: PUSH
123841: LD_INT 17
123843: EQUAL
123844: PUSH
123845: LD_VAR 0 4
123849: PUSH
123850: LD_VAR 0 7
123854: ARRAY
123855: PPUSH
123856: CALL_OW 110
123860: PUSH
123861: LD_INT 71
123863: EQUAL
123864: NOT
123865: AND
123866: IFFALSE 124012
// begin attacking := false ;
123868: LD_ADDR_VAR 0 29
123872: PUSH
123873: LD_INT 0
123875: ST_TO_ADDR
// k := 5 ;
123876: LD_ADDR_VAR 0 9
123880: PUSH
123881: LD_INT 5
123883: ST_TO_ADDR
// if tmp < k then
123884: LD_VAR 0 14
123888: PUSH
123889: LD_VAR 0 9
123893: LESS
123894: IFFALSE 123906
// k := tmp ;
123896: LD_ADDR_VAR 0 9
123900: PUSH
123901: LD_VAR 0 14
123905: ST_TO_ADDR
// for j = 1 to k do
123906: LD_ADDR_VAR 0 8
123910: PUSH
123911: DOUBLE
123912: LD_INT 1
123914: DEC
123915: ST_TO_ADDR
123916: LD_VAR 0 9
123920: PUSH
123921: FOR_TO
123922: IFFALSE 124010
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
123924: LD_VAR 0 14
123928: PUSH
123929: LD_VAR 0 8
123933: ARRAY
123934: PUSH
123935: LD_VAR 0 14
123939: PPUSH
123940: LD_INT 58
123942: PUSH
123943: EMPTY
123944: LIST
123945: PPUSH
123946: CALL_OW 72
123950: IN
123951: NOT
123952: IFFALSE 124008
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
123954: LD_VAR 0 4
123958: PUSH
123959: LD_VAR 0 7
123963: ARRAY
123964: PPUSH
123965: LD_VAR 0 14
123969: PUSH
123970: LD_VAR 0 8
123974: ARRAY
123975: PPUSH
123976: CALL_OW 115
// attacking := true ;
123980: LD_ADDR_VAR 0 29
123984: PUSH
123985: LD_INT 1
123987: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
123988: LD_VAR 0 4
123992: PUSH
123993: LD_VAR 0 7
123997: ARRAY
123998: PPUSH
123999: LD_INT 71
124001: PPUSH
124002: CALL_OW 109
// continue ;
124006: GO 123921
// end ; end ;
124008: GO 123921
124010: POP
124011: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
124012: LD_VAR 0 4
124016: PUSH
124017: LD_VAR 0 7
124021: ARRAY
124022: PPUSH
124023: CALL_OW 257
124027: PUSH
124028: LD_INT 8
124030: EQUAL
124031: PUSH
124032: LD_VAR 0 4
124036: PUSH
124037: LD_VAR 0 7
124041: ARRAY
124042: PPUSH
124043: CALL_OW 264
124047: PUSH
124048: LD_INT 28
124050: PUSH
124051: LD_INT 45
124053: PUSH
124054: LD_INT 7
124056: PUSH
124057: LD_INT 47
124059: PUSH
124060: EMPTY
124061: LIST
124062: LIST
124063: LIST
124064: LIST
124065: IN
124066: OR
124067: IFFALSE 124323
// begin attacking := false ;
124069: LD_ADDR_VAR 0 29
124073: PUSH
124074: LD_INT 0
124076: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
124077: LD_VAR 0 14
124081: PUSH
124082: LD_INT 1
124084: ARRAY
124085: PPUSH
124086: CALL_OW 266
124090: PUSH
124091: LD_INT 32
124093: PUSH
124094: LD_INT 31
124096: PUSH
124097: LD_INT 33
124099: PUSH
124100: LD_INT 4
124102: PUSH
124103: LD_INT 5
124105: PUSH
124106: EMPTY
124107: LIST
124108: LIST
124109: LIST
124110: LIST
124111: LIST
124112: IN
124113: IFFALSE 124299
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
124115: LD_ADDR_VAR 0 9
124119: PUSH
124120: LD_VAR 0 14
124124: PUSH
124125: LD_INT 1
124127: ARRAY
124128: PPUSH
124129: CALL_OW 266
124133: PPUSH
124134: LD_VAR 0 14
124138: PUSH
124139: LD_INT 1
124141: ARRAY
124142: PPUSH
124143: CALL_OW 250
124147: PPUSH
124148: LD_VAR 0 14
124152: PUSH
124153: LD_INT 1
124155: ARRAY
124156: PPUSH
124157: CALL_OW 251
124161: PPUSH
124162: LD_VAR 0 14
124166: PUSH
124167: LD_INT 1
124169: ARRAY
124170: PPUSH
124171: CALL_OW 254
124175: PPUSH
124176: LD_VAR 0 14
124180: PUSH
124181: LD_INT 1
124183: ARRAY
124184: PPUSH
124185: CALL_OW 248
124189: PPUSH
124190: LD_INT 0
124192: PPUSH
124193: CALL 79414 0 6
124197: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
124198: LD_ADDR_VAR 0 8
124202: PUSH
124203: LD_VAR 0 4
124207: PUSH
124208: LD_VAR 0 7
124212: ARRAY
124213: PPUSH
124214: LD_VAR 0 9
124218: PPUSH
124219: CALL 98084 0 2
124223: ST_TO_ADDR
// if j then
124224: LD_VAR 0 8
124228: IFFALSE 124297
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
124230: LD_VAR 0 8
124234: PUSH
124235: LD_INT 1
124237: ARRAY
124238: PPUSH
124239: LD_VAR 0 8
124243: PUSH
124244: LD_INT 2
124246: ARRAY
124247: PPUSH
124248: CALL_OW 488
124252: IFFALSE 124297
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
124254: LD_VAR 0 4
124258: PUSH
124259: LD_VAR 0 7
124263: ARRAY
124264: PPUSH
124265: LD_VAR 0 8
124269: PUSH
124270: LD_INT 1
124272: ARRAY
124273: PPUSH
124274: LD_VAR 0 8
124278: PUSH
124279: LD_INT 2
124281: ARRAY
124282: PPUSH
124283: CALL_OW 116
// attacking := true ;
124287: LD_ADDR_VAR 0 29
124291: PUSH
124292: LD_INT 1
124294: ST_TO_ADDR
// continue ;
124295: GO 121670
// end ; end else
124297: GO 124323
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124299: LD_VAR 0 4
124303: PUSH
124304: LD_VAR 0 7
124308: ARRAY
124309: PPUSH
124310: LD_VAR 0 14
124314: PUSH
124315: LD_INT 1
124317: ARRAY
124318: PPUSH
124319: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
124323: LD_VAR 0 4
124327: PUSH
124328: LD_VAR 0 7
124332: ARRAY
124333: PPUSH
124334: CALL_OW 265
124338: PUSH
124339: LD_INT 11
124341: EQUAL
124342: IFFALSE 124620
// begin k := 10 ;
124344: LD_ADDR_VAR 0 9
124348: PUSH
124349: LD_INT 10
124351: ST_TO_ADDR
// x := 0 ;
124352: LD_ADDR_VAR 0 10
124356: PUSH
124357: LD_INT 0
124359: ST_TO_ADDR
// if tmp < k then
124360: LD_VAR 0 14
124364: PUSH
124365: LD_VAR 0 9
124369: LESS
124370: IFFALSE 124382
// k := tmp ;
124372: LD_ADDR_VAR 0 9
124376: PUSH
124377: LD_VAR 0 14
124381: ST_TO_ADDR
// for j = k downto 1 do
124382: LD_ADDR_VAR 0 8
124386: PUSH
124387: DOUBLE
124388: LD_VAR 0 9
124392: INC
124393: ST_TO_ADDR
124394: LD_INT 1
124396: PUSH
124397: FOR_DOWNTO
124398: IFFALSE 124473
// begin if GetType ( tmp [ j ] ) = unit_human then
124400: LD_VAR 0 14
124404: PUSH
124405: LD_VAR 0 8
124409: ARRAY
124410: PPUSH
124411: CALL_OW 247
124415: PUSH
124416: LD_INT 1
124418: EQUAL
124419: IFFALSE 124471
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
124421: LD_VAR 0 4
124425: PUSH
124426: LD_VAR 0 7
124430: ARRAY
124431: PPUSH
124432: LD_VAR 0 14
124436: PUSH
124437: LD_VAR 0 8
124441: ARRAY
124442: PPUSH
124443: CALL 98355 0 2
// x := tmp [ j ] ;
124447: LD_ADDR_VAR 0 10
124451: PUSH
124452: LD_VAR 0 14
124456: PUSH
124457: LD_VAR 0 8
124461: ARRAY
124462: ST_TO_ADDR
// attacking := true ;
124463: LD_ADDR_VAR 0 29
124467: PUSH
124468: LD_INT 1
124470: ST_TO_ADDR
// end ; end ;
124471: GO 124397
124473: POP
124474: POP
// if not x then
124475: LD_VAR 0 10
124479: NOT
124480: IFFALSE 124620
// begin attacking := true ;
124482: LD_ADDR_VAR 0 29
124486: PUSH
124487: LD_INT 1
124489: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
124490: LD_VAR 0 4
124494: PUSH
124495: LD_VAR 0 7
124499: ARRAY
124500: PPUSH
124501: CALL_OW 250
124505: PPUSH
124506: LD_VAR 0 4
124510: PUSH
124511: LD_VAR 0 7
124515: ARRAY
124516: PPUSH
124517: CALL_OW 251
124521: PPUSH
124522: CALL_OW 546
124526: PUSH
124527: LD_INT 2
124529: ARRAY
124530: PUSH
124531: LD_VAR 0 14
124535: PUSH
124536: LD_INT 1
124538: ARRAY
124539: PPUSH
124540: CALL_OW 250
124544: PPUSH
124545: LD_VAR 0 14
124549: PUSH
124550: LD_INT 1
124552: ARRAY
124553: PPUSH
124554: CALL_OW 251
124558: PPUSH
124559: CALL_OW 546
124563: PUSH
124564: LD_INT 2
124566: ARRAY
124567: EQUAL
124568: IFFALSE 124596
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
124570: LD_VAR 0 4
124574: PUSH
124575: LD_VAR 0 7
124579: ARRAY
124580: PPUSH
124581: LD_VAR 0 14
124585: PUSH
124586: LD_INT 1
124588: ARRAY
124589: PPUSH
124590: CALL 98355 0 2
124594: GO 124620
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124596: LD_VAR 0 4
124600: PUSH
124601: LD_VAR 0 7
124605: ARRAY
124606: PPUSH
124607: LD_VAR 0 14
124611: PUSH
124612: LD_INT 1
124614: ARRAY
124615: PPUSH
124616: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
124620: LD_VAR 0 4
124624: PUSH
124625: LD_VAR 0 7
124629: ARRAY
124630: PPUSH
124631: CALL_OW 264
124635: PUSH
124636: LD_INT 29
124638: EQUAL
124639: IFFALSE 125005
// begin if WantsToAttack ( group [ i ] ) in bombed then
124641: LD_VAR 0 4
124645: PUSH
124646: LD_VAR 0 7
124650: ARRAY
124651: PPUSH
124652: CALL_OW 319
124656: PUSH
124657: LD_VAR 0 28
124661: IN
124662: IFFALSE 124666
// continue ;
124664: GO 121670
// k := 8 ;
124666: LD_ADDR_VAR 0 9
124670: PUSH
124671: LD_INT 8
124673: ST_TO_ADDR
// x := 0 ;
124674: LD_ADDR_VAR 0 10
124678: PUSH
124679: LD_INT 0
124681: ST_TO_ADDR
// if tmp < k then
124682: LD_VAR 0 14
124686: PUSH
124687: LD_VAR 0 9
124691: LESS
124692: IFFALSE 124704
// k := tmp ;
124694: LD_ADDR_VAR 0 9
124698: PUSH
124699: LD_VAR 0 14
124703: ST_TO_ADDR
// for j = 1 to k do
124704: LD_ADDR_VAR 0 8
124708: PUSH
124709: DOUBLE
124710: LD_INT 1
124712: DEC
124713: ST_TO_ADDR
124714: LD_VAR 0 9
124718: PUSH
124719: FOR_TO
124720: IFFALSE 124852
// begin if GetType ( tmp [ j ] ) = unit_building then
124722: LD_VAR 0 14
124726: PUSH
124727: LD_VAR 0 8
124731: ARRAY
124732: PPUSH
124733: CALL_OW 247
124737: PUSH
124738: LD_INT 3
124740: EQUAL
124741: IFFALSE 124850
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
124743: LD_VAR 0 14
124747: PUSH
124748: LD_VAR 0 8
124752: ARRAY
124753: PUSH
124754: LD_VAR 0 28
124758: IN
124759: NOT
124760: PUSH
124761: LD_VAR 0 14
124765: PUSH
124766: LD_VAR 0 8
124770: ARRAY
124771: PPUSH
124772: CALL_OW 313
124776: AND
124777: IFFALSE 124850
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
124779: LD_VAR 0 4
124783: PUSH
124784: LD_VAR 0 7
124788: ARRAY
124789: PPUSH
124790: LD_VAR 0 14
124794: PUSH
124795: LD_VAR 0 8
124799: ARRAY
124800: PPUSH
124801: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
124805: LD_ADDR_VAR 0 28
124809: PUSH
124810: LD_VAR 0 28
124814: PPUSH
124815: LD_VAR 0 28
124819: PUSH
124820: LD_INT 1
124822: PLUS
124823: PPUSH
124824: LD_VAR 0 14
124828: PUSH
124829: LD_VAR 0 8
124833: ARRAY
124834: PPUSH
124835: CALL_OW 1
124839: ST_TO_ADDR
// attacking := true ;
124840: LD_ADDR_VAR 0 29
124844: PUSH
124845: LD_INT 1
124847: ST_TO_ADDR
// break ;
124848: GO 124852
// end ; end ;
124850: GO 124719
124852: POP
124853: POP
// if not attacking and f_attack_depot then
124854: LD_VAR 0 29
124858: NOT
124859: PUSH
124860: LD_VAR 0 25
124864: AND
124865: IFFALSE 124960
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
124867: LD_ADDR_VAR 0 13
124871: PUSH
124872: LD_VAR 0 14
124876: PPUSH
124877: LD_INT 2
124879: PUSH
124880: LD_INT 30
124882: PUSH
124883: LD_INT 0
124885: PUSH
124886: EMPTY
124887: LIST
124888: LIST
124889: PUSH
124890: LD_INT 30
124892: PUSH
124893: LD_INT 1
124895: PUSH
124896: EMPTY
124897: LIST
124898: LIST
124899: PUSH
124900: EMPTY
124901: LIST
124902: LIST
124903: LIST
124904: PPUSH
124905: CALL_OW 72
124909: ST_TO_ADDR
// if z then
124910: LD_VAR 0 13
124914: IFFALSE 124960
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
124916: LD_VAR 0 4
124920: PUSH
124921: LD_VAR 0 7
124925: ARRAY
124926: PPUSH
124927: LD_VAR 0 13
124931: PPUSH
124932: LD_VAR 0 4
124936: PUSH
124937: LD_VAR 0 7
124941: ARRAY
124942: PPUSH
124943: CALL_OW 74
124947: PPUSH
124948: CALL_OW 115
// attacking := true ;
124952: LD_ADDR_VAR 0 29
124956: PUSH
124957: LD_INT 1
124959: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
124960: LD_VAR 0 4
124964: PUSH
124965: LD_VAR 0 7
124969: ARRAY
124970: PPUSH
124971: CALL_OW 256
124975: PUSH
124976: LD_INT 500
124978: LESS
124979: IFFALSE 125005
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
124981: LD_VAR 0 4
124985: PUSH
124986: LD_VAR 0 7
124990: ARRAY
124991: PPUSH
124992: LD_VAR 0 14
124996: PUSH
124997: LD_INT 1
124999: ARRAY
125000: PPUSH
125001: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
125005: LD_VAR 0 4
125009: PUSH
125010: LD_VAR 0 7
125014: ARRAY
125015: PPUSH
125016: CALL_OW 264
125020: PUSH
125021: LD_INT 49
125023: EQUAL
125024: IFFALSE 125145
// begin if not HasTask ( group [ i ] ) then
125026: LD_VAR 0 4
125030: PUSH
125031: LD_VAR 0 7
125035: ARRAY
125036: PPUSH
125037: CALL_OW 314
125041: NOT
125042: IFFALSE 125145
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
125044: LD_ADDR_VAR 0 9
125048: PUSH
125049: LD_INT 81
125051: PUSH
125052: LD_VAR 0 4
125056: PUSH
125057: LD_VAR 0 7
125061: ARRAY
125062: PPUSH
125063: CALL_OW 255
125067: PUSH
125068: EMPTY
125069: LIST
125070: LIST
125071: PPUSH
125072: CALL_OW 69
125076: PPUSH
125077: LD_VAR 0 4
125081: PUSH
125082: LD_VAR 0 7
125086: ARRAY
125087: PPUSH
125088: CALL_OW 74
125092: ST_TO_ADDR
// if k then
125093: LD_VAR 0 9
125097: IFFALSE 125145
// if GetDistUnits ( group [ i ] , k ) > 10 then
125099: LD_VAR 0 4
125103: PUSH
125104: LD_VAR 0 7
125108: ARRAY
125109: PPUSH
125110: LD_VAR 0 9
125114: PPUSH
125115: CALL_OW 296
125119: PUSH
125120: LD_INT 10
125122: GREATER
125123: IFFALSE 125145
// ComMoveUnit ( group [ i ] , k ) ;
125125: LD_VAR 0 4
125129: PUSH
125130: LD_VAR 0 7
125134: ARRAY
125135: PPUSH
125136: LD_VAR 0 9
125140: PPUSH
125141: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
125145: LD_VAR 0 4
125149: PUSH
125150: LD_VAR 0 7
125154: ARRAY
125155: PPUSH
125156: CALL_OW 256
125160: PUSH
125161: LD_INT 250
125163: LESS
125164: PUSH
125165: LD_VAR 0 4
125169: PUSH
125170: LD_VAR 0 7
125174: ARRAY
125175: PUSH
125176: LD_INT 21
125178: PUSH
125179: LD_INT 2
125181: PUSH
125182: EMPTY
125183: LIST
125184: LIST
125185: PUSH
125186: LD_INT 23
125188: PUSH
125189: LD_INT 2
125191: PUSH
125192: EMPTY
125193: LIST
125194: LIST
125195: PUSH
125196: EMPTY
125197: LIST
125198: LIST
125199: PPUSH
125200: CALL_OW 69
125204: IN
125205: AND
125206: IFFALSE 125331
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
125208: LD_ADDR_VAR 0 9
125212: PUSH
125213: LD_OWVAR 3
125217: PUSH
125218: LD_VAR 0 4
125222: PUSH
125223: LD_VAR 0 7
125227: ARRAY
125228: DIFF
125229: PPUSH
125230: LD_VAR 0 4
125234: PUSH
125235: LD_VAR 0 7
125239: ARRAY
125240: PPUSH
125241: CALL_OW 74
125245: ST_TO_ADDR
// if not k then
125246: LD_VAR 0 9
125250: NOT
125251: IFFALSE 125255
// continue ;
125253: GO 121670
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
125255: LD_VAR 0 9
125259: PUSH
125260: LD_INT 81
125262: PUSH
125263: LD_VAR 0 4
125267: PUSH
125268: LD_VAR 0 7
125272: ARRAY
125273: PPUSH
125274: CALL_OW 255
125278: PUSH
125279: EMPTY
125280: LIST
125281: LIST
125282: PPUSH
125283: CALL_OW 69
125287: IN
125288: PUSH
125289: LD_VAR 0 9
125293: PPUSH
125294: LD_VAR 0 4
125298: PUSH
125299: LD_VAR 0 7
125303: ARRAY
125304: PPUSH
125305: CALL_OW 296
125309: PUSH
125310: LD_INT 5
125312: LESS
125313: AND
125314: IFFALSE 125331
// ComAutodestruct ( group [ i ] ) ;
125316: LD_VAR 0 4
125320: PUSH
125321: LD_VAR 0 7
125325: ARRAY
125326: PPUSH
125327: CALL 98253 0 1
// end ; if f_attack_depot then
125331: LD_VAR 0 25
125335: IFFALSE 125447
// begin k := 6 ;
125337: LD_ADDR_VAR 0 9
125341: PUSH
125342: LD_INT 6
125344: ST_TO_ADDR
// if tmp < k then
125345: LD_VAR 0 14
125349: PUSH
125350: LD_VAR 0 9
125354: LESS
125355: IFFALSE 125367
// k := tmp ;
125357: LD_ADDR_VAR 0 9
125361: PUSH
125362: LD_VAR 0 14
125366: ST_TO_ADDR
// for j = 1 to k do
125367: LD_ADDR_VAR 0 8
125371: PUSH
125372: DOUBLE
125373: LD_INT 1
125375: DEC
125376: ST_TO_ADDR
125377: LD_VAR 0 9
125381: PUSH
125382: FOR_TO
125383: IFFALSE 125445
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
125385: LD_VAR 0 8
125389: PPUSH
125390: CALL_OW 266
125394: PUSH
125395: LD_INT 0
125397: PUSH
125398: LD_INT 1
125400: PUSH
125401: EMPTY
125402: LIST
125403: LIST
125404: IN
125405: IFFALSE 125443
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
125407: LD_VAR 0 4
125411: PUSH
125412: LD_VAR 0 7
125416: ARRAY
125417: PPUSH
125418: LD_VAR 0 14
125422: PUSH
125423: LD_VAR 0 8
125427: ARRAY
125428: PPUSH
125429: CALL_OW 115
// attacking := true ;
125433: LD_ADDR_VAR 0 29
125437: PUSH
125438: LD_INT 1
125440: ST_TO_ADDR
// break ;
125441: GO 125445
// end ;
125443: GO 125382
125445: POP
125446: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
125447: LD_VAR 0 4
125451: PUSH
125452: LD_VAR 0 7
125456: ARRAY
125457: PPUSH
125458: CALL_OW 302
125462: PUSH
125463: LD_VAR 0 29
125467: NOT
125468: AND
125469: IFFALSE 125791
// begin if GetTag ( group [ i ] ) = 71 then
125471: LD_VAR 0 4
125475: PUSH
125476: LD_VAR 0 7
125480: ARRAY
125481: PPUSH
125482: CALL_OW 110
125486: PUSH
125487: LD_INT 71
125489: EQUAL
125490: IFFALSE 125531
// begin if HasTask ( group [ i ] ) then
125492: LD_VAR 0 4
125496: PUSH
125497: LD_VAR 0 7
125501: ARRAY
125502: PPUSH
125503: CALL_OW 314
125507: IFFALSE 125513
// continue else
125509: GO 121670
125511: GO 125531
// SetTag ( group [ i ] , 0 ) ;
125513: LD_VAR 0 4
125517: PUSH
125518: LD_VAR 0 7
125522: ARRAY
125523: PPUSH
125524: LD_INT 0
125526: PPUSH
125527: CALL_OW 109
// end ; k := 8 ;
125531: LD_ADDR_VAR 0 9
125535: PUSH
125536: LD_INT 8
125538: ST_TO_ADDR
// x := 0 ;
125539: LD_ADDR_VAR 0 10
125543: PUSH
125544: LD_INT 0
125546: ST_TO_ADDR
// if tmp < k then
125547: LD_VAR 0 14
125551: PUSH
125552: LD_VAR 0 9
125556: LESS
125557: IFFALSE 125569
// k := tmp ;
125559: LD_ADDR_VAR 0 9
125563: PUSH
125564: LD_VAR 0 14
125568: ST_TO_ADDR
// for j = 1 to k do
125569: LD_ADDR_VAR 0 8
125573: PUSH
125574: DOUBLE
125575: LD_INT 1
125577: DEC
125578: ST_TO_ADDR
125579: LD_VAR 0 9
125583: PUSH
125584: FOR_TO
125585: IFFALSE 125683
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
125587: LD_VAR 0 14
125591: PUSH
125592: LD_VAR 0 8
125596: ARRAY
125597: PPUSH
125598: CALL_OW 247
125602: PUSH
125603: LD_INT 1
125605: EQUAL
125606: PUSH
125607: LD_VAR 0 14
125611: PUSH
125612: LD_VAR 0 8
125616: ARRAY
125617: PPUSH
125618: CALL_OW 256
125622: PUSH
125623: LD_INT 250
125625: LESS
125626: PUSH
125627: LD_VAR 0 20
125631: AND
125632: PUSH
125633: LD_VAR 0 20
125637: NOT
125638: PUSH
125639: LD_VAR 0 14
125643: PUSH
125644: LD_VAR 0 8
125648: ARRAY
125649: PPUSH
125650: CALL_OW 256
125654: PUSH
125655: LD_INT 250
125657: GREATEREQUAL
125658: AND
125659: OR
125660: AND
125661: IFFALSE 125681
// begin x := tmp [ j ] ;
125663: LD_ADDR_VAR 0 10
125667: PUSH
125668: LD_VAR 0 14
125672: PUSH
125673: LD_VAR 0 8
125677: ARRAY
125678: ST_TO_ADDR
// break ;
125679: GO 125683
// end ;
125681: GO 125584
125683: POP
125684: POP
// if x then
125685: LD_VAR 0 10
125689: IFFALSE 125713
// ComAttackUnit ( group [ i ] , x ) else
125691: LD_VAR 0 4
125695: PUSH
125696: LD_VAR 0 7
125700: ARRAY
125701: PPUSH
125702: LD_VAR 0 10
125706: PPUSH
125707: CALL_OW 115
125711: GO 125737
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
125713: LD_VAR 0 4
125717: PUSH
125718: LD_VAR 0 7
125722: ARRAY
125723: PPUSH
125724: LD_VAR 0 14
125728: PUSH
125729: LD_INT 1
125731: ARRAY
125732: PPUSH
125733: CALL_OW 115
// if not HasTask ( group [ i ] ) then
125737: LD_VAR 0 4
125741: PUSH
125742: LD_VAR 0 7
125746: ARRAY
125747: PPUSH
125748: CALL_OW 314
125752: NOT
125753: IFFALSE 125791
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
125755: LD_VAR 0 4
125759: PUSH
125760: LD_VAR 0 7
125764: ARRAY
125765: PPUSH
125766: LD_VAR 0 14
125770: PPUSH
125771: LD_VAR 0 4
125775: PUSH
125776: LD_VAR 0 7
125780: ARRAY
125781: PPUSH
125782: CALL_OW 74
125786: PPUSH
125787: CALL_OW 115
// end ; end ; end ;
125791: GO 121670
125793: POP
125794: POP
// wait ( 0 0$2 ) ;
125795: LD_INT 70
125797: PPUSH
125798: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
125802: LD_VAR 0 4
125806: NOT
125807: PUSH
125808: LD_VAR 0 4
125812: PUSH
125813: EMPTY
125814: EQUAL
125815: OR
125816: PUSH
125817: LD_INT 81
125819: PUSH
125820: LD_VAR 0 35
125824: PUSH
125825: EMPTY
125826: LIST
125827: LIST
125828: PPUSH
125829: CALL_OW 69
125833: NOT
125834: OR
125835: IFFALSE 121655
// end ;
125837: LD_VAR 0 2
125841: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
125842: LD_INT 0
125844: PPUSH
125845: PPUSH
125846: PPUSH
125847: PPUSH
125848: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
125849: LD_VAR 0 1
125853: NOT
125854: PUSH
125855: LD_EXP 116
125859: PUSH
125860: LD_VAR 0 1
125864: ARRAY
125865: NOT
125866: OR
125867: PUSH
125868: LD_VAR 0 2
125872: NOT
125873: OR
125874: PUSH
125875: LD_VAR 0 3
125879: NOT
125880: OR
125881: IFFALSE 125885
// exit ;
125883: GO 126398
// side := mc_sides [ base ] ;
125885: LD_ADDR_VAR 0 6
125889: PUSH
125890: LD_EXP 142
125894: PUSH
125895: LD_VAR 0 1
125899: ARRAY
125900: ST_TO_ADDR
// if not side then
125901: LD_VAR 0 6
125905: NOT
125906: IFFALSE 125910
// exit ;
125908: GO 126398
// for i in solds do
125910: LD_ADDR_VAR 0 7
125914: PUSH
125915: LD_VAR 0 2
125919: PUSH
125920: FOR_IN
125921: IFFALSE 125982
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
125923: LD_VAR 0 7
125927: PPUSH
125928: CALL_OW 310
125932: PPUSH
125933: CALL_OW 266
125937: PUSH
125938: LD_INT 32
125940: PUSH
125941: LD_INT 31
125943: PUSH
125944: EMPTY
125945: LIST
125946: LIST
125947: IN
125948: IFFALSE 125968
// solds := solds diff i else
125950: LD_ADDR_VAR 0 2
125954: PUSH
125955: LD_VAR 0 2
125959: PUSH
125960: LD_VAR 0 7
125964: DIFF
125965: ST_TO_ADDR
125966: GO 125980
// SetTag ( i , 18 ) ;
125968: LD_VAR 0 7
125972: PPUSH
125973: LD_INT 18
125975: PPUSH
125976: CALL_OW 109
125980: GO 125920
125982: POP
125983: POP
// if not solds then
125984: LD_VAR 0 2
125988: NOT
125989: IFFALSE 125993
// exit ;
125991: GO 126398
// repeat wait ( 0 0$2 ) ;
125993: LD_INT 70
125995: PPUSH
125996: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
126000: LD_ADDR_VAR 0 5
126004: PUSH
126005: LD_VAR 0 6
126009: PPUSH
126010: LD_VAR 0 3
126014: PPUSH
126015: CALL 67223 0 2
126019: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126020: LD_EXP 116
126024: PUSH
126025: LD_VAR 0 1
126029: ARRAY
126030: NOT
126031: PUSH
126032: LD_EXP 116
126036: PUSH
126037: LD_VAR 0 1
126041: ARRAY
126042: PUSH
126043: EMPTY
126044: EQUAL
126045: OR
126046: IFFALSE 126083
// begin for i in solds do
126048: LD_ADDR_VAR 0 7
126052: PUSH
126053: LD_VAR 0 2
126057: PUSH
126058: FOR_IN
126059: IFFALSE 126072
// ComStop ( i ) ;
126061: LD_VAR 0 7
126065: PPUSH
126066: CALL_OW 141
126070: GO 126058
126072: POP
126073: POP
// solds := [ ] ;
126074: LD_ADDR_VAR 0 2
126078: PUSH
126079: EMPTY
126080: ST_TO_ADDR
// exit ;
126081: GO 126398
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
126083: LD_VAR 0 5
126087: NOT
126088: PUSH
126089: LD_VAR 0 5
126093: PUSH
126094: LD_INT 3
126096: GREATER
126097: OR
126098: PUSH
126099: LD_EXP 138
126103: PUSH
126104: LD_VAR 0 1
126108: ARRAY
126109: OR
126110: IFFALSE 126151
// begin for i in solds do
126112: LD_ADDR_VAR 0 7
126116: PUSH
126117: LD_VAR 0 2
126121: PUSH
126122: FOR_IN
126123: IFFALSE 126147
// if HasTask ( i ) then
126125: LD_VAR 0 7
126129: PPUSH
126130: CALL_OW 314
126134: IFFALSE 126145
// ComStop ( i ) ;
126136: LD_VAR 0 7
126140: PPUSH
126141: CALL_OW 141
126145: GO 126122
126147: POP
126148: POP
// break ;
126149: GO 126386
// end ; for i in solds do
126151: LD_ADDR_VAR 0 7
126155: PUSH
126156: LD_VAR 0 2
126160: PUSH
126161: FOR_IN
126162: IFFALSE 126378
// begin if IsInUnit ( i ) then
126164: LD_VAR 0 7
126168: PPUSH
126169: CALL_OW 310
126173: IFFALSE 126184
// ComExitBuilding ( i ) ;
126175: LD_VAR 0 7
126179: PPUSH
126180: CALL_OW 122
// if GetLives ( i ) > 333 then
126184: LD_VAR 0 7
126188: PPUSH
126189: CALL_OW 256
126193: PUSH
126194: LD_INT 333
126196: GREATER
126197: IFFALSE 126225
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
126199: LD_VAR 0 7
126203: PPUSH
126204: LD_VAR 0 5
126208: PPUSH
126209: LD_VAR 0 7
126213: PPUSH
126214: CALL_OW 74
126218: PPUSH
126219: CALL_OW 115
126223: GO 126376
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
126225: LD_ADDR_VAR 0 8
126229: PUSH
126230: LD_EXP 116
126234: PUSH
126235: LD_VAR 0 1
126239: ARRAY
126240: PPUSH
126241: LD_INT 2
126243: PUSH
126244: LD_INT 30
126246: PUSH
126247: LD_INT 0
126249: PUSH
126250: EMPTY
126251: LIST
126252: LIST
126253: PUSH
126254: LD_INT 30
126256: PUSH
126257: LD_INT 1
126259: PUSH
126260: EMPTY
126261: LIST
126262: LIST
126263: PUSH
126264: LD_INT 30
126266: PUSH
126267: LD_INT 6
126269: PUSH
126270: EMPTY
126271: LIST
126272: LIST
126273: PUSH
126274: EMPTY
126275: LIST
126276: LIST
126277: LIST
126278: LIST
126279: PPUSH
126280: CALL_OW 72
126284: PPUSH
126285: LD_VAR 0 7
126289: PPUSH
126290: CALL_OW 74
126294: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
126295: LD_VAR 0 7
126299: PPUSH
126300: LD_VAR 0 8
126304: PPUSH
126305: CALL_OW 250
126309: PPUSH
126310: LD_INT 3
126312: PPUSH
126313: LD_INT 5
126315: PPUSH
126316: CALL_OW 272
126320: PPUSH
126321: LD_VAR 0 8
126325: PPUSH
126326: CALL_OW 251
126330: PPUSH
126331: LD_INT 3
126333: PPUSH
126334: LD_INT 5
126336: PPUSH
126337: CALL_OW 273
126341: PPUSH
126342: CALL_OW 111
// SetTag ( i , 0 ) ;
126346: LD_VAR 0 7
126350: PPUSH
126351: LD_INT 0
126353: PPUSH
126354: CALL_OW 109
// solds := solds diff i ;
126358: LD_ADDR_VAR 0 2
126362: PUSH
126363: LD_VAR 0 2
126367: PUSH
126368: LD_VAR 0 7
126372: DIFF
126373: ST_TO_ADDR
// continue ;
126374: GO 126161
// end ; end ;
126376: GO 126161
126378: POP
126379: POP
// until solds ;
126380: LD_VAR 0 2
126384: IFFALSE 125993
// MC_Reset ( base , 18 ) ;
126386: LD_VAR 0 1
126390: PPUSH
126391: LD_INT 18
126393: PPUSH
126394: CALL 39310 0 2
// end ;
126398: LD_VAR 0 4
126402: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
126403: LD_INT 0
126405: PPUSH
126406: PPUSH
126407: PPUSH
126408: PPUSH
126409: PPUSH
126410: PPUSH
126411: PPUSH
126412: PPUSH
126413: PPUSH
126414: PPUSH
126415: PPUSH
126416: PPUSH
126417: PPUSH
126418: PPUSH
126419: PPUSH
126420: PPUSH
126421: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
126422: LD_ADDR_VAR 0 13
126426: PUSH
126427: LD_EXP 116
126431: PUSH
126432: LD_VAR 0 1
126436: ARRAY
126437: PPUSH
126438: LD_INT 25
126440: PUSH
126441: LD_INT 3
126443: PUSH
126444: EMPTY
126445: LIST
126446: LIST
126447: PPUSH
126448: CALL_OW 72
126452: ST_TO_ADDR
// if mc_remote_driver [ base ] then
126453: LD_EXP 156
126457: PUSH
126458: LD_VAR 0 1
126462: ARRAY
126463: IFFALSE 126487
// mechs := mechs diff mc_remote_driver [ base ] ;
126465: LD_ADDR_VAR 0 13
126469: PUSH
126470: LD_VAR 0 13
126474: PUSH
126475: LD_EXP 156
126479: PUSH
126480: LD_VAR 0 1
126484: ARRAY
126485: DIFF
126486: ST_TO_ADDR
// for i in mechs do
126487: LD_ADDR_VAR 0 5
126491: PUSH
126492: LD_VAR 0 13
126496: PUSH
126497: FOR_IN
126498: IFFALSE 126533
// if GetTag ( i ) > 0 then
126500: LD_VAR 0 5
126504: PPUSH
126505: CALL_OW 110
126509: PUSH
126510: LD_INT 0
126512: GREATER
126513: IFFALSE 126531
// mechs := mechs diff i ;
126515: LD_ADDR_VAR 0 13
126519: PUSH
126520: LD_VAR 0 13
126524: PUSH
126525: LD_VAR 0 5
126529: DIFF
126530: ST_TO_ADDR
126531: GO 126497
126533: POP
126534: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
126535: LD_ADDR_VAR 0 9
126539: PUSH
126540: LD_EXP 116
126544: PUSH
126545: LD_VAR 0 1
126549: ARRAY
126550: PPUSH
126551: LD_INT 2
126553: PUSH
126554: LD_INT 25
126556: PUSH
126557: LD_INT 1
126559: PUSH
126560: EMPTY
126561: LIST
126562: LIST
126563: PUSH
126564: LD_INT 25
126566: PUSH
126567: LD_INT 5
126569: PUSH
126570: EMPTY
126571: LIST
126572: LIST
126573: PUSH
126574: LD_INT 25
126576: PUSH
126577: LD_INT 8
126579: PUSH
126580: EMPTY
126581: LIST
126582: LIST
126583: PUSH
126584: LD_INT 25
126586: PUSH
126587: LD_INT 9
126589: PUSH
126590: EMPTY
126591: LIST
126592: LIST
126593: PUSH
126594: EMPTY
126595: LIST
126596: LIST
126597: LIST
126598: LIST
126599: LIST
126600: PPUSH
126601: CALL_OW 72
126605: ST_TO_ADDR
// if not defenders and not solds then
126606: LD_VAR 0 2
126610: NOT
126611: PUSH
126612: LD_VAR 0 9
126616: NOT
126617: AND
126618: IFFALSE 126622
// exit ;
126620: GO 128312
// depot_under_attack := false ;
126622: LD_ADDR_VAR 0 17
126626: PUSH
126627: LD_INT 0
126629: ST_TO_ADDR
// sold_defenders := [ ] ;
126630: LD_ADDR_VAR 0 18
126634: PUSH
126635: EMPTY
126636: ST_TO_ADDR
// if mechs then
126637: LD_VAR 0 13
126641: IFFALSE 126794
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
126643: LD_ADDR_VAR 0 5
126647: PUSH
126648: LD_VAR 0 2
126652: PPUSH
126653: LD_INT 21
126655: PUSH
126656: LD_INT 2
126658: PUSH
126659: EMPTY
126660: LIST
126661: LIST
126662: PPUSH
126663: CALL_OW 72
126667: PUSH
126668: FOR_IN
126669: IFFALSE 126792
// begin if GetTag ( i ) <> 20 then
126671: LD_VAR 0 5
126675: PPUSH
126676: CALL_OW 110
126680: PUSH
126681: LD_INT 20
126683: NONEQUAL
126684: IFFALSE 126698
// SetTag ( i , 20 ) ;
126686: LD_VAR 0 5
126690: PPUSH
126691: LD_INT 20
126693: PPUSH
126694: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
126698: LD_VAR 0 5
126702: PPUSH
126703: CALL_OW 263
126707: PUSH
126708: LD_INT 1
126710: EQUAL
126711: PUSH
126712: LD_VAR 0 5
126716: PPUSH
126717: CALL_OW 311
126721: NOT
126722: AND
126723: IFFALSE 126790
// begin un := mechs [ 1 ] ;
126725: LD_ADDR_VAR 0 11
126729: PUSH
126730: LD_VAR 0 13
126734: PUSH
126735: LD_INT 1
126737: ARRAY
126738: ST_TO_ADDR
// ComExit ( un ) ;
126739: LD_VAR 0 11
126743: PPUSH
126744: CALL 102598 0 1
// AddComEnterUnit ( un , i ) ;
126748: LD_VAR 0 11
126752: PPUSH
126753: LD_VAR 0 5
126757: PPUSH
126758: CALL_OW 180
// SetTag ( un , 19 ) ;
126762: LD_VAR 0 11
126766: PPUSH
126767: LD_INT 19
126769: PPUSH
126770: CALL_OW 109
// mechs := mechs diff un ;
126774: LD_ADDR_VAR 0 13
126778: PUSH
126779: LD_VAR 0 13
126783: PUSH
126784: LD_VAR 0 11
126788: DIFF
126789: ST_TO_ADDR
// end ; end ;
126790: GO 126668
126792: POP
126793: POP
// if solds then
126794: LD_VAR 0 9
126798: IFFALSE 126857
// for i in solds do
126800: LD_ADDR_VAR 0 5
126804: PUSH
126805: LD_VAR 0 9
126809: PUSH
126810: FOR_IN
126811: IFFALSE 126855
// if not GetTag ( i ) then
126813: LD_VAR 0 5
126817: PPUSH
126818: CALL_OW 110
126822: NOT
126823: IFFALSE 126853
// begin defenders := defenders union i ;
126825: LD_ADDR_VAR 0 2
126829: PUSH
126830: LD_VAR 0 2
126834: PUSH
126835: LD_VAR 0 5
126839: UNION
126840: ST_TO_ADDR
// SetTag ( i , 18 ) ;
126841: LD_VAR 0 5
126845: PPUSH
126846: LD_INT 18
126848: PPUSH
126849: CALL_OW 109
// end ;
126853: GO 126810
126855: POP
126856: POP
// repeat wait ( 0 0$2 ) ;
126857: LD_INT 70
126859: PPUSH
126860: CALL_OW 67
// enemy := mc_scan [ base ] ;
126864: LD_ADDR_VAR 0 3
126868: PUSH
126869: LD_EXP 139
126873: PUSH
126874: LD_VAR 0 1
126878: ARRAY
126879: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
126880: LD_EXP 116
126884: PUSH
126885: LD_VAR 0 1
126889: ARRAY
126890: NOT
126891: PUSH
126892: LD_EXP 116
126896: PUSH
126897: LD_VAR 0 1
126901: ARRAY
126902: PUSH
126903: EMPTY
126904: EQUAL
126905: OR
126906: IFFALSE 126943
// begin for i in defenders do
126908: LD_ADDR_VAR 0 5
126912: PUSH
126913: LD_VAR 0 2
126917: PUSH
126918: FOR_IN
126919: IFFALSE 126932
// ComStop ( i ) ;
126921: LD_VAR 0 5
126925: PPUSH
126926: CALL_OW 141
126930: GO 126918
126932: POP
126933: POP
// defenders := [ ] ;
126934: LD_ADDR_VAR 0 2
126938: PUSH
126939: EMPTY
126940: ST_TO_ADDR
// exit ;
126941: GO 128312
// end ; for i in defenders do
126943: LD_ADDR_VAR 0 5
126947: PUSH
126948: LD_VAR 0 2
126952: PUSH
126953: FOR_IN
126954: IFFALSE 127772
// begin e := NearestUnitToUnit ( enemy , i ) ;
126956: LD_ADDR_VAR 0 14
126960: PUSH
126961: LD_VAR 0 3
126965: PPUSH
126966: LD_VAR 0 5
126970: PPUSH
126971: CALL_OW 74
126975: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
126976: LD_ADDR_VAR 0 8
126980: PUSH
126981: LD_EXP 116
126985: PUSH
126986: LD_VAR 0 1
126990: ARRAY
126991: PPUSH
126992: LD_INT 2
126994: PUSH
126995: LD_INT 30
126997: PUSH
126998: LD_INT 0
127000: PUSH
127001: EMPTY
127002: LIST
127003: LIST
127004: PUSH
127005: LD_INT 30
127007: PUSH
127008: LD_INT 1
127010: PUSH
127011: EMPTY
127012: LIST
127013: LIST
127014: PUSH
127015: EMPTY
127016: LIST
127017: LIST
127018: LIST
127019: PPUSH
127020: CALL_OW 72
127024: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
127025: LD_ADDR_VAR 0 17
127029: PUSH
127030: LD_VAR 0 8
127034: NOT
127035: PUSH
127036: LD_VAR 0 8
127040: PPUSH
127041: LD_INT 3
127043: PUSH
127044: LD_INT 24
127046: PUSH
127047: LD_INT 600
127049: PUSH
127050: EMPTY
127051: LIST
127052: LIST
127053: PUSH
127054: EMPTY
127055: LIST
127056: LIST
127057: PPUSH
127058: CALL_OW 72
127062: OR
127063: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
127064: LD_VAR 0 5
127068: PPUSH
127069: CALL_OW 247
127073: PUSH
127074: LD_INT 2
127076: DOUBLE
127077: EQUAL
127078: IFTRUE 127082
127080: GO 127478
127082: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
127083: LD_VAR 0 5
127087: PPUSH
127088: CALL_OW 256
127092: PUSH
127093: LD_INT 1000
127095: EQUAL
127096: PUSH
127097: LD_VAR 0 5
127101: PPUSH
127102: LD_VAR 0 14
127106: PPUSH
127107: CALL_OW 296
127111: PUSH
127112: LD_INT 40
127114: LESS
127115: PUSH
127116: LD_VAR 0 14
127120: PPUSH
127121: LD_EXP 141
127125: PUSH
127126: LD_VAR 0 1
127130: ARRAY
127131: PPUSH
127132: CALL_OW 308
127136: OR
127137: AND
127138: IFFALSE 127260
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
127140: LD_VAR 0 5
127144: PPUSH
127145: CALL_OW 262
127149: PUSH
127150: LD_INT 1
127152: EQUAL
127153: PUSH
127154: LD_VAR 0 5
127158: PPUSH
127159: CALL_OW 261
127163: PUSH
127164: LD_INT 30
127166: LESS
127167: AND
127168: PUSH
127169: LD_VAR 0 8
127173: AND
127174: IFFALSE 127244
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
127176: LD_VAR 0 5
127180: PPUSH
127181: LD_VAR 0 8
127185: PPUSH
127186: LD_VAR 0 5
127190: PPUSH
127191: CALL_OW 74
127195: PPUSH
127196: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
127200: LD_VAR 0 5
127204: PPUSH
127205: LD_VAR 0 8
127209: PPUSH
127210: LD_VAR 0 5
127214: PPUSH
127215: CALL_OW 74
127219: PPUSH
127220: CALL_OW 296
127224: PUSH
127225: LD_INT 6
127227: LESS
127228: IFFALSE 127242
// SetFuel ( i , 100 ) ;
127230: LD_VAR 0 5
127234: PPUSH
127235: LD_INT 100
127237: PPUSH
127238: CALL_OW 240
// end else
127242: GO 127258
// ComAttackUnit ( i , e ) ;
127244: LD_VAR 0 5
127248: PPUSH
127249: LD_VAR 0 14
127253: PPUSH
127254: CALL_OW 115
// end else
127258: GO 127361
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
127260: LD_VAR 0 14
127264: PPUSH
127265: LD_EXP 141
127269: PUSH
127270: LD_VAR 0 1
127274: ARRAY
127275: PPUSH
127276: CALL_OW 308
127280: NOT
127281: PUSH
127282: LD_VAR 0 5
127286: PPUSH
127287: LD_VAR 0 14
127291: PPUSH
127292: CALL_OW 296
127296: PUSH
127297: LD_INT 40
127299: GREATEREQUAL
127300: AND
127301: PUSH
127302: LD_VAR 0 5
127306: PPUSH
127307: CALL_OW 256
127311: PUSH
127312: LD_INT 650
127314: LESSEQUAL
127315: OR
127316: PUSH
127317: LD_VAR 0 5
127321: PPUSH
127322: LD_EXP 140
127326: PUSH
127327: LD_VAR 0 1
127331: ARRAY
127332: PPUSH
127333: CALL_OW 308
127337: NOT
127338: AND
127339: IFFALSE 127361
// ComMoveToArea ( i , mc_parking [ base ] ) ;
127341: LD_VAR 0 5
127345: PPUSH
127346: LD_EXP 140
127350: PUSH
127351: LD_VAR 0 1
127355: ARRAY
127356: PPUSH
127357: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
127361: LD_VAR 0 5
127365: PPUSH
127366: CALL_OW 256
127370: PUSH
127371: LD_INT 1000
127373: LESS
127374: PUSH
127375: LD_VAR 0 5
127379: PPUSH
127380: CALL_OW 263
127384: PUSH
127385: LD_INT 1
127387: EQUAL
127388: AND
127389: PUSH
127390: LD_VAR 0 5
127394: PPUSH
127395: CALL_OW 311
127399: AND
127400: PUSH
127401: LD_VAR 0 5
127405: PPUSH
127406: LD_EXP 140
127410: PUSH
127411: LD_VAR 0 1
127415: ARRAY
127416: PPUSH
127417: CALL_OW 308
127421: AND
127422: IFFALSE 127476
// begin mech := IsDrivenBy ( i ) ;
127424: LD_ADDR_VAR 0 10
127428: PUSH
127429: LD_VAR 0 5
127433: PPUSH
127434: CALL_OW 311
127438: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
127439: LD_VAR 0 10
127443: PPUSH
127444: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
127448: LD_VAR 0 10
127452: PPUSH
127453: LD_VAR 0 5
127457: PPUSH
127458: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
127462: LD_VAR 0 10
127466: PPUSH
127467: LD_VAR 0 5
127471: PPUSH
127472: CALL_OW 180
// end ; end ; unit_human :
127476: GO 127743
127478: LD_INT 1
127480: DOUBLE
127481: EQUAL
127482: IFTRUE 127486
127484: GO 127742
127486: POP
// begin b := IsInUnit ( i ) ;
127487: LD_ADDR_VAR 0 19
127491: PUSH
127492: LD_VAR 0 5
127496: PPUSH
127497: CALL_OW 310
127501: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
127502: LD_ADDR_VAR 0 20
127506: PUSH
127507: LD_VAR 0 19
127511: NOT
127512: PUSH
127513: LD_VAR 0 19
127517: PPUSH
127518: CALL_OW 266
127522: PUSH
127523: LD_INT 32
127525: PUSH
127526: LD_INT 31
127528: PUSH
127529: EMPTY
127530: LIST
127531: LIST
127532: IN
127533: OR
127534: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
127535: LD_VAR 0 17
127539: PUSH
127540: LD_VAR 0 2
127544: PPUSH
127545: LD_INT 21
127547: PUSH
127548: LD_INT 2
127550: PUSH
127551: EMPTY
127552: LIST
127553: LIST
127554: PPUSH
127555: CALL_OW 72
127559: PUSH
127560: LD_INT 1
127562: LESSEQUAL
127563: OR
127564: PUSH
127565: LD_VAR 0 20
127569: AND
127570: PUSH
127571: LD_VAR 0 5
127575: PUSH
127576: LD_VAR 0 18
127580: IN
127581: NOT
127582: AND
127583: IFFALSE 127676
// begin if b then
127585: LD_VAR 0 19
127589: IFFALSE 127638
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
127591: LD_VAR 0 19
127595: PPUSH
127596: LD_VAR 0 3
127600: PPUSH
127601: LD_VAR 0 19
127605: PPUSH
127606: CALL_OW 74
127610: PPUSH
127611: CALL_OW 296
127615: PUSH
127616: LD_INT 10
127618: LESS
127619: PUSH
127620: LD_VAR 0 19
127624: PPUSH
127625: CALL_OW 461
127629: PUSH
127630: LD_INT 7
127632: NONEQUAL
127633: AND
127634: IFFALSE 127638
// continue ;
127636: GO 126953
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
127638: LD_ADDR_VAR 0 18
127642: PUSH
127643: LD_VAR 0 18
127647: PPUSH
127648: LD_VAR 0 18
127652: PUSH
127653: LD_INT 1
127655: PLUS
127656: PPUSH
127657: LD_VAR 0 5
127661: PPUSH
127662: CALL_OW 1
127666: ST_TO_ADDR
// ComExitBuilding ( i ) ;
127667: LD_VAR 0 5
127671: PPUSH
127672: CALL_OW 122
// end ; if sold_defenders then
127676: LD_VAR 0 18
127680: IFFALSE 127740
// if i in sold_defenders then
127682: LD_VAR 0 5
127686: PUSH
127687: LD_VAR 0 18
127691: IN
127692: IFFALSE 127740
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
127694: LD_VAR 0 5
127698: PPUSH
127699: CALL_OW 314
127703: NOT
127704: PUSH
127705: LD_VAR 0 5
127709: PPUSH
127710: LD_VAR 0 14
127714: PPUSH
127715: CALL_OW 296
127719: PUSH
127720: LD_INT 30
127722: LESS
127723: AND
127724: IFFALSE 127740
// ComAttackUnit ( i , e ) ;
127726: LD_VAR 0 5
127730: PPUSH
127731: LD_VAR 0 14
127735: PPUSH
127736: CALL_OW 115
// end ; end ; end ;
127740: GO 127743
127742: POP
// if IsDead ( i ) then
127743: LD_VAR 0 5
127747: PPUSH
127748: CALL_OW 301
127752: IFFALSE 127770
// defenders := defenders diff i ;
127754: LD_ADDR_VAR 0 2
127758: PUSH
127759: LD_VAR 0 2
127763: PUSH
127764: LD_VAR 0 5
127768: DIFF
127769: ST_TO_ADDR
// end ;
127770: GO 126953
127772: POP
127773: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
127774: LD_VAR 0 3
127778: NOT
127779: PUSH
127780: LD_VAR 0 2
127784: NOT
127785: OR
127786: PUSH
127787: LD_EXP 116
127791: PUSH
127792: LD_VAR 0 1
127796: ARRAY
127797: NOT
127798: OR
127799: IFFALSE 126857
// MC_Reset ( base , 18 ) ;
127801: LD_VAR 0 1
127805: PPUSH
127806: LD_INT 18
127808: PPUSH
127809: CALL 39310 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
127813: LD_ADDR_VAR 0 2
127817: PUSH
127818: LD_VAR 0 2
127822: PUSH
127823: LD_VAR 0 2
127827: PPUSH
127828: LD_INT 2
127830: PUSH
127831: LD_INT 25
127833: PUSH
127834: LD_INT 1
127836: PUSH
127837: EMPTY
127838: LIST
127839: LIST
127840: PUSH
127841: LD_INT 25
127843: PUSH
127844: LD_INT 5
127846: PUSH
127847: EMPTY
127848: LIST
127849: LIST
127850: PUSH
127851: LD_INT 25
127853: PUSH
127854: LD_INT 8
127856: PUSH
127857: EMPTY
127858: LIST
127859: LIST
127860: PUSH
127861: LD_INT 25
127863: PUSH
127864: LD_INT 9
127866: PUSH
127867: EMPTY
127868: LIST
127869: LIST
127870: PUSH
127871: EMPTY
127872: LIST
127873: LIST
127874: LIST
127875: LIST
127876: LIST
127877: PPUSH
127878: CALL_OW 72
127882: DIFF
127883: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
127884: LD_VAR 0 3
127888: NOT
127889: PUSH
127890: LD_VAR 0 2
127894: PPUSH
127895: LD_INT 21
127897: PUSH
127898: LD_INT 2
127900: PUSH
127901: EMPTY
127902: LIST
127903: LIST
127904: PPUSH
127905: CALL_OW 72
127909: AND
127910: IFFALSE 128248
// begin tmp := FilterByTag ( defenders , 19 ) ;
127912: LD_ADDR_VAR 0 12
127916: PUSH
127917: LD_VAR 0 2
127921: PPUSH
127922: LD_INT 19
127924: PPUSH
127925: CALL 99728 0 2
127929: ST_TO_ADDR
// if tmp then
127930: LD_VAR 0 12
127934: IFFALSE 128004
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
127936: LD_ADDR_VAR 0 12
127940: PUSH
127941: LD_VAR 0 12
127945: PPUSH
127946: LD_INT 25
127948: PUSH
127949: LD_INT 3
127951: PUSH
127952: EMPTY
127953: LIST
127954: LIST
127955: PPUSH
127956: CALL_OW 72
127960: ST_TO_ADDR
// if tmp then
127961: LD_VAR 0 12
127965: IFFALSE 128004
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
127967: LD_ADDR_EXP 128
127971: PUSH
127972: LD_EXP 128
127976: PPUSH
127977: LD_VAR 0 1
127981: PPUSH
127982: LD_EXP 128
127986: PUSH
127987: LD_VAR 0 1
127991: ARRAY
127992: PUSH
127993: LD_VAR 0 12
127997: UNION
127998: PPUSH
127999: CALL_OW 1
128003: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
128004: LD_VAR 0 1
128008: PPUSH
128009: LD_INT 19
128011: PPUSH
128012: CALL 39310 0 2
// repeat wait ( 0 0$1 ) ;
128016: LD_INT 35
128018: PPUSH
128019: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128023: LD_EXP 116
128027: PUSH
128028: LD_VAR 0 1
128032: ARRAY
128033: NOT
128034: PUSH
128035: LD_EXP 116
128039: PUSH
128040: LD_VAR 0 1
128044: ARRAY
128045: PUSH
128046: EMPTY
128047: EQUAL
128048: OR
128049: IFFALSE 128086
// begin for i in defenders do
128051: LD_ADDR_VAR 0 5
128055: PUSH
128056: LD_VAR 0 2
128060: PUSH
128061: FOR_IN
128062: IFFALSE 128075
// ComStop ( i ) ;
128064: LD_VAR 0 5
128068: PPUSH
128069: CALL_OW 141
128073: GO 128061
128075: POP
128076: POP
// defenders := [ ] ;
128077: LD_ADDR_VAR 0 2
128081: PUSH
128082: EMPTY
128083: ST_TO_ADDR
// exit ;
128084: GO 128312
// end ; for i in defenders do
128086: LD_ADDR_VAR 0 5
128090: PUSH
128091: LD_VAR 0 2
128095: PUSH
128096: FOR_IN
128097: IFFALSE 128186
// begin if not IsInArea ( i , mc_parking [ base ] ) then
128099: LD_VAR 0 5
128103: PPUSH
128104: LD_EXP 140
128108: PUSH
128109: LD_VAR 0 1
128113: ARRAY
128114: PPUSH
128115: CALL_OW 308
128119: NOT
128120: IFFALSE 128144
// ComMoveToArea ( i , mc_parking [ base ] ) else
128122: LD_VAR 0 5
128126: PPUSH
128127: LD_EXP 140
128131: PUSH
128132: LD_VAR 0 1
128136: ARRAY
128137: PPUSH
128138: CALL_OW 113
128142: GO 128184
// if GetControl ( i ) = control_manual then
128144: LD_VAR 0 5
128148: PPUSH
128149: CALL_OW 263
128153: PUSH
128154: LD_INT 1
128156: EQUAL
128157: IFFALSE 128184
// if IsDrivenBy ( i ) then
128159: LD_VAR 0 5
128163: PPUSH
128164: CALL_OW 311
128168: IFFALSE 128184
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
128170: LD_VAR 0 5
128174: PPUSH
128175: CALL_OW 311
128179: PPUSH
128180: CALL_OW 121
// end ;
128184: GO 128096
128186: POP
128187: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
128188: LD_VAR 0 2
128192: PPUSH
128193: LD_INT 95
128195: PUSH
128196: LD_EXP 140
128200: PUSH
128201: LD_VAR 0 1
128205: ARRAY
128206: PUSH
128207: EMPTY
128208: LIST
128209: LIST
128210: PPUSH
128211: CALL_OW 72
128215: PUSH
128216: LD_VAR 0 2
128220: EQUAL
128221: PUSH
128222: LD_EXP 139
128226: PUSH
128227: LD_VAR 0 1
128231: ARRAY
128232: OR
128233: PUSH
128234: LD_EXP 116
128238: PUSH
128239: LD_VAR 0 1
128243: ARRAY
128244: NOT
128245: OR
128246: IFFALSE 128016
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
128248: LD_ADDR_EXP 138
128252: PUSH
128253: LD_EXP 138
128257: PPUSH
128258: LD_VAR 0 1
128262: PPUSH
128263: LD_VAR 0 2
128267: PPUSH
128268: LD_INT 21
128270: PUSH
128271: LD_INT 2
128273: PUSH
128274: EMPTY
128275: LIST
128276: LIST
128277: PPUSH
128278: CALL_OW 72
128282: PPUSH
128283: CALL_OW 1
128287: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
128288: LD_VAR 0 1
128292: PPUSH
128293: LD_INT 19
128295: PPUSH
128296: CALL 39310 0 2
// MC_Reset ( base , 20 ) ;
128300: LD_VAR 0 1
128304: PPUSH
128305: LD_INT 20
128307: PPUSH
128308: CALL 39310 0 2
// end ; end_of_file
128312: LD_VAR 0 4
128316: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
128317: LD_VAR 0 1
128321: PUSH
128322: LD_INT 200
128324: DOUBLE
128325: GREATEREQUAL
128326: IFFALSE 128334
128328: LD_INT 299
128330: DOUBLE
128331: LESSEQUAL
128332: IFTRUE 128336
128334: GO 128368
128336: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
128337: LD_VAR 0 1
128341: PPUSH
128342: LD_VAR 0 2
128346: PPUSH
128347: LD_VAR 0 3
128351: PPUSH
128352: LD_VAR 0 4
128356: PPUSH
128357: LD_VAR 0 5
128361: PPUSH
128362: CALL 117250 0 5
128366: GO 128445
128368: LD_INT 300
128370: DOUBLE
128371: GREATEREQUAL
128372: IFFALSE 128380
128374: LD_INT 399
128376: DOUBLE
128377: LESSEQUAL
128378: IFTRUE 128382
128380: GO 128444
128382: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
128383: LD_VAR 0 1
128387: PPUSH
128388: LD_VAR 0 2
128392: PPUSH
128393: LD_VAR 0 3
128397: PPUSH
128398: LD_VAR 0 4
128402: PPUSH
128403: LD_VAR 0 5
128407: PPUSH
128408: LD_VAR 0 6
128412: PPUSH
128413: LD_VAR 0 7
128417: PPUSH
128418: LD_VAR 0 8
128422: PPUSH
128423: LD_VAR 0 9
128427: PPUSH
128428: LD_VAR 0 10
128432: PPUSH
128433: LD_VAR 0 11
128437: PPUSH
128438: CALL 115138 0 11
128442: GO 128445
128444: POP
// end ;
128445: PPOPN 11
128447: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
128448: LD_VAR 0 1
128452: PPUSH
128453: LD_VAR 0 2
128457: PPUSH
128458: LD_VAR 0 3
128462: PPUSH
128463: LD_VAR 0 4
128467: PPUSH
128468: LD_VAR 0 5
128472: PPUSH
128473: CALL 117232 0 5
// end ; end_of_file
128477: PPOPN 5
128479: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
128480: LD_VAR 0 1
128484: PPUSH
128485: LD_VAR 0 2
128489: PPUSH
128490: LD_VAR 0 3
128494: PPUSH
128495: LD_VAR 0 4
128499: PPUSH
128500: LD_VAR 0 5
128504: PPUSH
128505: LD_VAR 0 6
128509: PPUSH
128510: CALL 103946 0 6
// end ;
128514: PPOPN 6
128516: END
