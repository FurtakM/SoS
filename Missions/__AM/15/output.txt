// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36872 0 0
// InitNature ;
  19: CALL 36740 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11915 0 0
// PrepareRussian ;
  40: CALL 7187 0 0
// PrepareLegion ;
  44: CALL 4342 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15994 0 0
// MC_Start ( ) ;
  60: CALL 39052 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61850 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61943 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 61293 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 61108 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61850 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61943 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 61108 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 61293 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61723 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60790 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61850 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61943 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 61108 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61850 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61943 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 61000 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 62261 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61432 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61723 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61723 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 62055 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 61108 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61674 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67582 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72597 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72597 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72597 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72597 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72597 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67582 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67582 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67582 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67582 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 67582 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 67582 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 67582 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 67582 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 67582 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 67582 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 67582 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 67582 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 67582 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 67582 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 67582 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3159: LD_ADDR_EXP 60
3163: PUSH
3164: LD_STRING Powell
3166: PPUSH
3167: CALL_OW 25
3171: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3172: LD_EXP 60
3176: PPUSH
3177: LD_INT 57
3179: PPUSH
3180: LD_INT 94
3182: PPUSH
3183: LD_INT 0
3185: PPUSH
3186: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3190: LD_EXP 60
3194: PPUSH
3195: LD_INT 58
3197: PPUSH
3198: LD_INT 94
3200: PPUSH
3201: CALL_OW 118
// vip := [ ] ;
3205: LD_ADDR_EXP 61
3209: PUSH
3210: EMPTY
3211: ST_TO_ADDR
// tmp := [ ] ;
3212: LD_ADDR_VAR 0 5
3216: PUSH
3217: EMPTY
3218: ST_TO_ADDR
// if JMMGirl <> 2 then
3219: LD_EXP 7
3223: PUSH
3224: LD_INT 2
3226: NONEQUAL
3227: IFFALSE 3251
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3229: LD_ADDR_EXP 43
3233: PUSH
3234: LD_STRING Lisa
3236: PPUSH
3237: LD_EXP 1
3241: NOT
3242: PPUSH
3243: LD_STRING 13s_
3245: PPUSH
3246: CALL 67582 0 3
3250: ST_TO_ADDR
// if Lisa then
3251: LD_EXP 43
3255: IFFALSE 3273
// tmp := tmp ^ Lisa ;
3257: LD_ADDR_VAR 0 5
3261: PUSH
3262: LD_VAR 0 5
3266: PUSH
3267: LD_EXP 43
3271: ADD
3272: ST_TO_ADDR
// if JMMGirl < 3 then
3273: LD_EXP 7
3277: PUSH
3278: LD_INT 3
3280: LESS
3281: IFFALSE 3312
// begin Connie := NewCharacter ( Coonie ) ;
3283: LD_ADDR_EXP 55
3287: PUSH
3288: LD_STRING Coonie
3290: PPUSH
3291: CALL_OW 25
3295: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3296: LD_ADDR_VAR 0 5
3300: PUSH
3301: LD_VAR 0 5
3305: PUSH
3306: LD_EXP 55
3310: ADD
3311: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 44
3316: PUSH
3317: LD_STRING Donaldson
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 67582 0 3
3333: ST_TO_ADDR
// if Donaldson then
3334: LD_EXP 44
3338: IFFALSE 3356
// tmp := tmp ^ Donaldson ;
3340: LD_ADDR_VAR 0 5
3344: PUSH
3345: LD_VAR 0 5
3349: PUSH
3350: LD_EXP 44
3354: ADD
3355: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 45
3360: PUSH
3361: LD_STRING Bobby
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 67582 0 3
3377: ST_TO_ADDR
// if Bobby then
3378: LD_EXP 45
3382: IFFALSE 3400
// tmp := tmp ^ Bobby ;
3384: LD_ADDR_VAR 0 5
3388: PUSH
3389: LD_VAR 0 5
3393: PUSH
3394: LD_EXP 45
3398: ADD
3399: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 46
3404: PUSH
3405: LD_STRING Cyrus
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 67582 0 3
3421: ST_TO_ADDR
// if Cyrus then
3422: LD_EXP 46
3426: IFFALSE 3444
// tmp := tmp ^ Cyrus ;
3428: LD_ADDR_VAR 0 5
3432: PUSH
3433: LD_VAR 0 5
3437: PUSH
3438: LD_EXP 46
3442: ADD
3443: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 47
3448: PUSH
3449: LD_STRING Denis
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 67582 0 3
3465: ST_TO_ADDR
// if not Denis then
3466: LD_EXP 47
3470: NOT
3471: IFFALSE 3495
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3473: LD_ADDR_EXP 47
3477: PUSH
3478: LD_STRING Denis
3480: PPUSH
3481: LD_EXP 1
3485: NOT
3486: PPUSH
3487: LD_STRING 13f_
3489: PPUSH
3490: CALL 67582 0 3
3494: ST_TO_ADDR
// if Denis then
3495: LD_EXP 47
3499: IFFALSE 3517
// tmp := tmp ^ Denis ;
3501: LD_ADDR_VAR 0 5
3505: PUSH
3506: LD_VAR 0 5
3510: PUSH
3511: LD_EXP 47
3515: ADD
3516: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3517: LD_ADDR_EXP 48
3521: PUSH
3522: LD_STRING Brown
3524: PPUSH
3525: LD_EXP 1
3529: NOT
3530: PPUSH
3531: LD_STRING 13s_
3533: PPUSH
3534: CALL 67582 0 3
3538: ST_TO_ADDR
// if Brown then
3539: LD_EXP 48
3543: IFFALSE 3561
// tmp := tmp ^ Brown ;
3545: LD_ADDR_VAR 0 5
3549: PUSH
3550: LD_VAR 0 5
3554: PUSH
3555: LD_EXP 48
3559: ADD
3560: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3561: LD_ADDR_EXP 49
3565: PUSH
3566: LD_STRING Gladstone
3568: PPUSH
3569: LD_EXP 1
3573: NOT
3574: PPUSH
3575: LD_STRING 13s_
3577: PPUSH
3578: CALL 67582 0 3
3582: ST_TO_ADDR
// if Gladstone then
3583: LD_EXP 49
3587: IFFALSE 3605
// tmp := tmp ^ Gladstone ;
3589: LD_ADDR_VAR 0 5
3593: PUSH
3594: LD_VAR 0 5
3598: PUSH
3599: LD_EXP 49
3603: ADD
3604: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3605: LD_ADDR_EXP 50
3609: PUSH
3610: LD_STRING Houten
3612: PPUSH
3613: LD_EXP 1
3617: NOT
3618: PPUSH
3619: LD_STRING 13s_
3621: PPUSH
3622: CALL 67582 0 3
3626: ST_TO_ADDR
// if Houten then
3627: LD_EXP 50
3631: IFFALSE 3649
// tmp := tmp ^ Houten ;
3633: LD_ADDR_VAR 0 5
3637: PUSH
3638: LD_VAR 0 5
3642: PUSH
3643: LD_EXP 50
3647: ADD
3648: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3649: LD_ADDR_EXP 51
3653: PUSH
3654: LD_STRING Cornel
3656: PPUSH
3657: LD_EXP 1
3661: NOT
3662: PPUSH
3663: LD_STRING 13s_
3665: PPUSH
3666: CALL 67582 0 3
3670: ST_TO_ADDR
// if Cornel then
3671: LD_EXP 51
3675: IFFALSE 3693
// tmp := tmp ^ Cornel ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_VAR 0 5
3686: PUSH
3687: LD_EXP 51
3691: ADD
3692: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3693: LD_ADDR_EXP 52
3697: PUSH
3698: LD_STRING Gary
3700: PPUSH
3701: LD_EXP 1
3705: NOT
3706: PPUSH
3707: LD_STRING 13s_
3709: PPUSH
3710: CALL 67582 0 3
3714: ST_TO_ADDR
// if Gary then
3715: LD_EXP 52
3719: IFFALSE 3737
// tmp := tmp ^ Gary ;
3721: LD_ADDR_VAR 0 5
3725: PUSH
3726: LD_VAR 0 5
3730: PUSH
3731: LD_EXP 52
3735: ADD
3736: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3737: LD_ADDR_EXP 53
3741: PUSH
3742: LD_STRING Frank
3744: PPUSH
3745: LD_EXP 1
3749: NOT
3750: PPUSH
3751: LD_STRING 13s_
3753: PPUSH
3754: CALL 67582 0 3
3758: ST_TO_ADDR
// if Frank then
3759: LD_EXP 53
3763: IFFALSE 3781
// tmp := tmp ^ Frank ;
3765: LD_ADDR_VAR 0 5
3769: PUSH
3770: LD_VAR 0 5
3774: PUSH
3775: LD_EXP 53
3779: ADD
3780: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3781: LD_ADDR_EXP 54
3785: PUSH
3786: LD_STRING Kikuchi
3788: PPUSH
3789: LD_EXP 1
3793: NOT
3794: PPUSH
3795: LD_STRING 13s_
3797: PPUSH
3798: CALL 67582 0 3
3802: ST_TO_ADDR
// if Kikuchi then
3803: LD_EXP 54
3807: IFFALSE 3825
// tmp := tmp ^ Kikuchi ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: LD_VAR 0 5
3818: PUSH
3819: LD_EXP 54
3823: ADD
3824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3825: LD_ADDR_EXP 57
3829: PUSH
3830: LD_STRING Mike
3832: PPUSH
3833: LD_EXP 1
3837: NOT
3838: PPUSH
3839: LD_STRING 10c_
3841: PPUSH
3842: CALL 67582 0 3
3846: ST_TO_ADDR
// if Mike then
3847: LD_EXP 57
3851: IFFALSE 3874
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3853: LD_EXP 57
3857: PPUSH
3858: LD_INT 61
3860: PPUSH
3861: LD_INT 89
3863: PPUSH
3864: LD_INT 8
3866: PPUSH
3867: LD_INT 0
3869: PPUSH
3870: CALL_OW 50
// vip := tmp ;
3874: LD_ADDR_EXP 61
3878: PUSH
3879: LD_VAR 0 5
3883: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3884: LD_ADDR_VAR 0 5
3888: PUSH
3889: LD_VAR 0 5
3893: PUSH
3894: LD_STRING 13s_others
3896: PPUSH
3897: CALL_OW 31
3901: UNION
3902: ST_TO_ADDR
// if tmp < 18 then
3903: LD_VAR 0 5
3907: PUSH
3908: LD_INT 18
3910: LESS
3911: IFFALSE 4004
// for i = 1 to 18 - tmp do
3913: LD_ADDR_VAR 0 2
3917: PUSH
3918: DOUBLE
3919: LD_INT 1
3921: DEC
3922: ST_TO_ADDR
3923: LD_INT 18
3925: PUSH
3926: LD_VAR 0 5
3930: MINUS
3931: PUSH
3932: FOR_TO
3933: IFFALSE 4002
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3935: LD_INT 1
3937: PPUSH
3938: LD_VAR 0 2
3942: PUSH
3943: LD_INT 4
3945: MOD
3946: PUSH
3947: LD_INT 1
3949: PLUS
3950: PPUSH
3951: LD_INT 4
3953: PPUSH
3954: CALL_OW 380
// un := CreateHuman ;
3958: LD_ADDR_VAR 0 10
3962: PUSH
3963: CALL_OW 44
3967: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3968: LD_ADDR_VAR 0 5
3972: PUSH
3973: LD_VAR 0 5
3977: PPUSH
3978: LD_VAR 0 10
3982: PPUSH
3983: CALL 105050 0 2
3987: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3988: LD_VAR 0 10
3992: PPUSH
3993: LD_INT 1
3995: PPUSH
3996: CALL_OW 109
// end ;
4000: GO 3932
4002: POP
4003: POP
// depot := HexInfo ( 53 , 94 ) ;
4004: LD_ADDR_VAR 0 6
4008: PUSH
4009: LD_INT 53
4011: PPUSH
4012: LD_INT 94
4014: PPUSH
4015: CALL_OW 428
4019: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4020: LD_ADDR_VAR 0 7
4024: PUSH
4025: LD_INT 56
4027: PPUSH
4028: LD_INT 101
4030: PPUSH
4031: CALL_OW 428
4035: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4036: LD_ADDR_VAR 0 8
4040: PUSH
4041: LD_INT 67
4043: PPUSH
4044: LD_INT 101
4046: PPUSH
4047: CALL_OW 428
4051: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4052: LD_ADDR_VAR 0 9
4056: PUSH
4057: LD_INT 54
4059: PPUSH
4060: LD_INT 85
4062: PPUSH
4063: CALL_OW 428
4067: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4068: LD_ADDR_VAR 0 3
4072: PUSH
4073: LD_VAR 0 8
4077: PUSH
4078: LD_VAR 0 6
4082: PUSH
4083: LD_VAR 0 9
4087: PUSH
4088: LD_VAR 0 7
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// for i in tmp do
4099: LD_ADDR_VAR 0 2
4103: PUSH
4104: LD_VAR 0 5
4108: PUSH
4109: FOR_IN
4110: IFFALSE 4198
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4112: LD_VAR 0 3
4116: PUSH
4117: LD_INT 1
4119: ARRAY
4120: PPUSH
4121: CALL_OW 313
4125: PUSH
4126: LD_INT 6
4128: EQUAL
4129: IFFALSE 4149
// b := Delete ( b , 1 ) ;
4131: LD_ADDR_VAR 0 3
4135: PUSH
4136: LD_VAR 0 3
4140: PPUSH
4141: LD_INT 1
4143: PPUSH
4144: CALL_OW 3
4148: ST_TO_ADDR
// if b then
4149: LD_VAR 0 3
4153: IFFALSE 4175
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4155: LD_VAR 0 2
4159: PPUSH
4160: LD_VAR 0 3
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PPUSH
4169: CALL_OW 52
4173: GO 4196
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4175: LD_VAR 0 2
4179: PPUSH
4180: LD_INT 61
4182: PPUSH
4183: LD_INT 89
4185: PPUSH
4186: LD_INT 8
4188: PPUSH
4189: LD_INT 0
4191: PPUSH
4192: CALL_OW 50
// end ;
4196: GO 4109
4198: POP
4199: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4200: LD_INT 2
4202: PPUSH
4203: LD_INT 1
4205: PPUSH
4206: LD_INT 1
4208: PPUSH
4209: LD_INT 12
4211: PPUSH
4212: LD_INT 100
4214: PPUSH
4215: CALL 72597 0 5
// veh := CreateVehicle ;
4219: LD_ADDR_VAR 0 4
4223: PUSH
4224: CALL_OW 45
4228: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4229: LD_VAR 0 4
4233: PPUSH
4234: LD_INT 4
4236: PPUSH
4237: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4241: LD_VAR 0 4
4245: PPUSH
4246: LD_INT 49
4248: PPUSH
4249: LD_INT 88
4251: PPUSH
4252: LD_INT 0
4254: PPUSH
4255: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: LD_INT 100
4269: PPUSH
4270: CALL_OW 290
// uc_side := 0 ;
4274: LD_ADDR_OWVAR 20
4278: PUSH
4279: LD_INT 0
4281: ST_TO_ADDR
// uc_nation := 0 ;
4282: LD_ADDR_OWVAR 21
4286: PUSH
4287: LD_INT 0
4289: ST_TO_ADDR
// for i := 1 to 3 do
4290: LD_ADDR_VAR 0 2
4294: PUSH
4295: DOUBLE
4296: LD_INT 1
4298: DEC
4299: ST_TO_ADDR
4300: LD_INT 3
4302: PUSH
4303: FOR_TO
4304: IFFALSE 4335
// begin InitHc ;
4306: CALL_OW 19
// hc_class := class_apeman ;
4310: LD_ADDR_OWVAR 28
4314: PUSH
4315: LD_INT 12
4317: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4318: CALL_OW 44
4322: PPUSH
4323: LD_INT 13
4325: PPUSH
4326: LD_INT 0
4328: PPUSH
4329: CALL_OW 49
// end ;
4333: GO 4303
4335: POP
4336: POP
// end ; end_of_file
4337: LD_VAR 0 1
4341: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4342: LD_INT 0
4344: PPUSH
4345: PPUSH
4346: PPUSH
4347: PPUSH
4348: PPUSH
// side := 8 ;
4349: LD_ADDR_VAR 0 3
4353: PUSH
4354: LD_INT 8
4356: ST_TO_ADDR
// uc_side := side ;
4357: LD_ADDR_OWVAR 20
4361: PUSH
4362: LD_VAR 0 3
4366: ST_TO_ADDR
// uc_nation := 2 ;
4367: LD_ADDR_OWVAR 21
4371: PUSH
4372: LD_INT 2
4374: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4375: LD_ADDR_VAR 0 2
4379: PUSH
4380: LD_INT 22
4382: PUSH
4383: LD_VAR 0 3
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: LD_INT 21
4394: PUSH
4395: LD_INT 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PPUSH
4406: CALL_OW 69
4410: PUSH
4411: FOR_IN
4412: IFFALSE 4428
// SetBLevel ( i , 10 ) ;
4414: LD_VAR 0 2
4418: PPUSH
4419: LD_INT 10
4421: PPUSH
4422: CALL_OW 241
4426: GO 4411
4428: POP
4429: POP
// if KurtStatus then
4430: LD_EXP 3
4434: IFFALSE 4457
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4436: LD_ADDR_EXP 62
4440: PUSH
4441: LD_STRING Kurt
4443: PPUSH
4444: LD_INT 0
4446: PPUSH
4447: LD_STRING 
4449: PPUSH
4450: CALL 67582 0 3
4454: ST_TO_ADDR
4455: GO 4479
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4457: LD_ADDR_EXP 62
4461: PUSH
4462: LD_STRING AltKurt
4464: PPUSH
4465: LD_EXP 1
4469: NOT
4470: PPUSH
4471: LD_STRING 
4473: PPUSH
4474: CALL 67582 0 3
4478: ST_TO_ADDR
// if not Kurt then
4479: LD_EXP 62
4483: NOT
4484: IFFALSE 4510
// begin InitHc ;
4486: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4490: LD_INT 1
4492: PPUSH
4493: LD_INT 10
4495: PPUSH
4496: CALL_OW 381
// Kurt := CreateHuman ;
4500: LD_ADDR_EXP 62
4504: PUSH
4505: CALL_OW 44
4509: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4510: LD_EXP 62
4514: PPUSH
4515: LD_INT 324
4517: PPUSH
4518: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4522: LD_ADDR_EXP 63
4526: PUSH
4527: LD_STRING Kozlov
4529: PPUSH
4530: LD_INT 0
4532: PPUSH
4533: LD_STRING 
4535: PPUSH
4536: CALL 67582 0 3
4540: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4541: LD_EXP 63
4545: PPUSH
4546: LD_INT 22
4548: PUSH
4549: LD_INT 8
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 23
4558: PUSH
4559: LD_INT 3
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 30
4568: PUSH
4569: LD_INT 8
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: PPUSH
4581: CALL_OW 69
4585: PUSH
4586: LD_INT 1
4588: ARRAY
4589: PPUSH
4590: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4594: LD_EXP 63
4598: PPUSH
4599: LD_INT 3
4601: PPUSH
4602: LD_INT 10
4604: PPUSH
4605: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4609: LD_EXP 63
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 10
4619: PPUSH
4620: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4624: LD_ADDR_VAR 0 5
4628: PUSH
4629: LD_INT 22
4631: PUSH
4632: LD_VAR 0 3
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: PUSH
4641: LD_INT 30
4643: PUSH
4644: LD_INT 32
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 58
4653: PUSH
4654: EMPTY
4655: LIST
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: LIST
4661: PPUSH
4662: CALL_OW 69
4666: ST_TO_ADDR
// for i = 1 to 10 do
4667: LD_ADDR_VAR 0 2
4671: PUSH
4672: DOUBLE
4673: LD_INT 1
4675: DEC
4676: ST_TO_ADDR
4677: LD_INT 10
4679: PUSH
4680: FOR_TO
4681: IFFALSE 4753
// begin uc_nation := nation_nature ;
4683: LD_ADDR_OWVAR 21
4687: PUSH
4688: LD_INT 0
4690: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4691: LD_ADDR_OWVAR 28
4695: PUSH
4696: LD_INT 15
4698: ST_TO_ADDR
// hc_gallery :=  ;
4699: LD_ADDR_OWVAR 33
4703: PUSH
4704: LD_STRING 
4706: ST_TO_ADDR
// hc_name :=  ;
4707: LD_ADDR_OWVAR 26
4711: PUSH
4712: LD_STRING 
4714: ST_TO_ADDR
// un := CreateHuman ;
4715: LD_ADDR_VAR 0 4
4719: PUSH
4720: CALL_OW 44
4724: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4725: LD_VAR 0 4
4729: PPUSH
4730: LD_VAR 0 5
4734: PUSH
4735: LD_VAR 0 5
4739: PUSH
4740: LD_VAR 0 2
4744: MINUS
4745: ARRAY
4746: PPUSH
4747: CALL_OW 52
// end ;
4751: GO 4680
4753: POP
4754: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4755: LD_ADDR_VAR 0 5
4759: PUSH
4760: LD_STRING 12_kurt_squad
4762: PPUSH
4763: CALL_OW 31
4767: ST_TO_ADDR
// if tmp then
4768: LD_VAR 0 5
4772: IFFALSE 4806
// for i in tmp do
4774: LD_ADDR_VAR 0 2
4778: PUSH
4779: LD_VAR 0 5
4783: PUSH
4784: FOR_IN
4785: IFFALSE 4804
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4787: LD_VAR 0 2
4791: PPUSH
4792: LD_INT 5
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 49
4802: GO 4784
4804: POP
4805: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4806: LD_INT 324
4808: PPUSH
4809: LD_INT 5
4811: PPUSH
4812: LD_STRING 
4814: PPUSH
4815: LD_INT 8
4817: PUSH
4818: LD_INT 9
4820: PUSH
4821: LD_INT 10
4823: PUSH
4824: LD_INT 10
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: PUSH
4833: LD_OWVAR 67
4837: ARRAY
4838: PPUSH
4839: LD_INT 3000
4841: PUSH
4842: LD_INT 500
4844: PUSH
4845: LD_INT 150
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: LIST
4852: PPUSH
4853: LD_INT 16
4855: PUSH
4856: LD_INT 6
4858: PUSH
4859: LD_INT 6
4861: PUSH
4862: LD_INT 8
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL 76041 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4875: LD_ADDR_EXP 100
4879: PUSH
4880: LD_EXP 100
4884: PPUSH
4885: LD_INT 3
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_VAR 0 3
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 23
4902: PUSH
4903: LD_INT 2
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 3
4912: PUSH
4913: LD_INT 21
4915: PUSH
4916: LD_INT 2
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: EMPTY
4928: LIST
4929: LIST
4930: LIST
4931: PPUSH
4932: CALL_OW 69
4936: PUSH
4937: LD_EXP 62
4941: DIFF
4942: PPUSH
4943: CALL_OW 1
4947: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4948: LD_INT 1
4950: PPUSH
4951: LD_INT 7
4953: PPUSH
4954: CALL_OW 383
// hc_name := Ali Hadrach ;
4958: LD_ADDR_OWVAR 26
4962: PUSH
4963: LD_STRING Ali Hadrach
4965: ST_TO_ADDR
// hc_face_number := 31 ;
4966: LD_ADDR_OWVAR 34
4970: PUSH
4971: LD_INT 31
4973: ST_TO_ADDR
// Friend := CreateHuman ;
4974: LD_ADDR_EXP 64
4978: PUSH
4979: CALL_OW 44
4983: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4984: LD_INT 14
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 1
4992: PPUSH
4993: LD_INT 29
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 72597 0 5
// powellBomb := CreateVehicle ;
5003: LD_ADDR_EXP 65
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5013: LD_EXP 65
5017: PPUSH
5018: LD_INT 90
5020: PPUSH
5021: LD_INT 51
5023: PPUSH
5024: LD_INT 0
5026: PPUSH
5027: CALL_OW 48
// end ;
5031: LD_VAR 0 1
5035: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5036: LD_INT 0
5038: PPUSH
5039: PPUSH
5040: PPUSH
// if IsLive ( kozlov_fac ) then
5041: LD_INT 332
5043: PPUSH
5044: CALL_OW 300
5048: IFFALSE 5052
// exit ;
5050: GO 5619
// ComExitBuilding ( Kozlov ) ;
5052: LD_EXP 63
5056: PPUSH
5057: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5061: LD_EXP 63
5065: PPUSH
5066: CALL_OW 257
5070: PUSH
5071: LD_INT 2
5073: NONEQUAL
5074: IFFALSE 5109
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5076: LD_EXP 63
5080: PPUSH
5081: LD_INT 324
5083: PPUSH
5084: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5088: LD_EXP 63
5092: PPUSH
5093: LD_INT 2
5095: PPUSH
5096: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5100: LD_EXP 63
5104: PPUSH
5105: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5109: LD_EXP 63
5113: PPUSH
5114: LD_INT 2
5116: PPUSH
5117: LD_INT 93
5119: PPUSH
5120: LD_INT 32
5122: PPUSH
5123: LD_INT 3
5125: PPUSH
5126: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5130: LD_INT 35
5132: PPUSH
5133: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5137: LD_INT 22
5139: PUSH
5140: LD_INT 8
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: LD_INT 30
5149: PUSH
5150: LD_INT 3
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 23
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 57
5169: PUSH
5170: EMPTY
5171: LIST
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: PPUSH
5179: CALL_OW 69
5183: IFFALSE 5130
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5185: LD_ADDR_VAR 0 2
5189: PUSH
5190: LD_INT 22
5192: PUSH
5193: LD_INT 8
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: LD_INT 30
5202: PUSH
5203: LD_INT 3
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 23
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 57
5222: PUSH
5223: EMPTY
5224: LIST
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: PPUSH
5232: CALL_OW 69
5236: PUSH
5237: LD_INT 1
5239: ARRAY
5240: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5241: LD_INT 22
5243: PUSH
5244: LD_INT 8
5246: PUSH
5247: EMPTY
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 23
5253: PUSH
5254: LD_INT 3
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 30
5263: PUSH
5264: LD_INT 21
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: EMPTY
5272: LIST
5273: LIST
5274: LIST
5275: PPUSH
5276: CALL_OW 69
5280: NOT
5281: IFFALSE 5359
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5283: LD_EXP 63
5287: PPUSH
5288: LD_INT 21
5290: PPUSH
5291: LD_INT 97
5293: PPUSH
5294: LD_INT 36
5296: PPUSH
5297: LD_INT 5
5299: PPUSH
5300: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5304: LD_INT 35
5306: PPUSH
5307: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5311: LD_INT 22
5313: PUSH
5314: LD_INT 8
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 23
5323: PUSH
5324: LD_INT 3
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 30
5333: PUSH
5334: LD_INT 21
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 57
5343: PUSH
5344: EMPTY
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: PPUSH
5353: CALL_OW 69
5357: IFFALSE 5304
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5359: LD_INT 22
5361: PUSH
5362: LD_INT 8
5364: PUSH
5365: EMPTY
5366: LIST
5367: LIST
5368: PUSH
5369: LD_INT 23
5371: PUSH
5372: LD_INT 3
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 18
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: LIST
5393: PPUSH
5394: CALL_OW 69
5398: NOT
5399: IFFALSE 5477
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5401: LD_EXP 63
5405: PPUSH
5406: LD_INT 18
5408: PPUSH
5409: LD_INT 89
5411: PPUSH
5412: LD_INT 32
5414: PPUSH
5415: LD_INT 1
5417: PPUSH
5418: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5422: LD_INT 35
5424: PPUSH
5425: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5429: LD_INT 22
5431: PUSH
5432: LD_INT 8
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: LD_INT 23
5441: PUSH
5442: LD_INT 3
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 30
5451: PUSH
5452: LD_INT 18
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 57
5461: PUSH
5462: EMPTY
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 69
5475: IFFALSE 5422
// end ; lab := kozlov_lab ;
5477: LD_ADDR_VAR 0 3
5481: PUSH
5482: LD_INT 336
5484: ST_TO_ADDR
// if not lab then
5485: LD_VAR 0 3
5489: NOT
5490: IFFALSE 5494
// exit ;
5492: GO 5619
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5494: LD_EXP 63
5498: PPUSH
5499: LD_VAR 0 3
5503: PUSH
5504: LD_INT 1
5506: ARRAY
5507: PPUSH
5508: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5512: LD_EXP 63
5516: PPUSH
5517: LD_INT 4
5519: PPUSH
5520: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5524: LD_VAR 0 3
5528: PUSH
5529: LD_INT 1
5531: ARRAY
5532: PPUSH
5533: LD_INT 25
5535: PPUSH
5536: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5540: LD_INT 35
5542: PPUSH
5543: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5547: LD_INT 25
5549: PPUSH
5550: LD_INT 8
5552: PPUSH
5553: CALL_OW 321
5557: PUSH
5558: LD_INT 2
5560: EQUAL
5561: IFFALSE 5540
// ComExitBuilding ( Kozlov ) ;
5563: LD_EXP 63
5567: PPUSH
5568: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5572: LD_EXP 63
5576: PPUSH
5577: LD_VAR 0 2
5581: PPUSH
5582: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5586: LD_EXP 63
5590: PPUSH
5591: LD_INT 3
5593: PPUSH
5594: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5598: LD_VAR 0 2
5602: PPUSH
5603: LD_INT 23
5605: PPUSH
5606: LD_INT 3
5608: PPUSH
5609: LD_INT 1
5611: PPUSH
5612: LD_INT 48
5614: PPUSH
5615: CALL_OW 125
// end ;
5619: LD_VAR 0 1
5623: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5624: LD_EXP 22
5628: NOT
5629: PUSH
5630: LD_EXP 15
5634: PUSH
5635: LD_INT 6
5637: GREATEREQUAL
5638: AND
5639: IFFALSE 5720
5641: GO 5643
5643: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5644: LD_INT 3
5646: PPUSH
5647: LD_INT 3
5649: PPUSH
5650: CALL 61293 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 14
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 1
5665: PUSH
5666: LD_INT 28
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 14
5677: PUSH
5678: LD_INT 1
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 28
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 14
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 1
5701: PUSH
5702: LD_INT 28
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: LIST
5715: PPUSH
5716: CALL 61156 0 2
// end ;
5720: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5721: LD_EXP 22
5725: NOT
5726: PUSH
5727: LD_EXP 15
5731: PUSH
5732: LD_INT 6
5734: GREATEREQUAL
5735: AND
5736: PUSH
5737: LD_INT 3
5739: PPUSH
5740: LD_INT 1
5742: PPUSH
5743: CALL 62574 0 2
5747: NOT
5748: AND
5749: IFFALSE 6623
5751: GO 5753
5753: DISABLE
5754: LD_INT 0
5756: PPUSH
5757: PPUSH
5758: PPUSH
// begin enable ;
5759: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5760: LD_INT 22
5762: PUSH
5763: LD_INT 8
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 23
5772: PUSH
5773: LD_INT 2
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 30
5782: PUSH
5783: LD_INT 3
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: LIST
5794: PPUSH
5795: CALL_OW 69
5799: NOT
5800: IFFALSE 5804
// exit ;
5802: GO 6623
// if Prob ( 40 ) then
5804: LD_INT 40
5806: PPUSH
5807: CALL_OW 13
5811: IFFALSE 5938
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5813: LD_INT 3
5815: PPUSH
5816: LD_INT 14
5818: PUSH
5819: LD_INT 1
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 28
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: LIST
5833: PUSH
5834: LD_INT 14
5836: PUSH
5837: LD_INT 1
5839: PUSH
5840: LD_INT 2
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_INT 14
5854: PUSH
5855: LD_INT 1
5857: PUSH
5858: LD_INT 2
5860: PUSH
5861: LD_INT 28
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 14
5872: PUSH
5873: LD_INT 1
5875: PUSH
5876: LD_INT 2
5878: PUSH
5879: LD_INT 28
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 14
5890: PUSH
5891: LD_INT 1
5893: PUSH
5894: LD_INT 2
5896: PUSH
5897: LD_INT 28
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 14
5908: PUSH
5909: LD_INT 1
5911: PUSH
5912: LD_INT 2
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL 61156 0 2
// end else
5936: GO 6145
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5938: LD_INT 3
5940: PPUSH
5941: LD_INT 14
5943: PUSH
5944: LD_INT 1
5946: PUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 27
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: LD_INT 26
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_OWVAR 67
5972: ARRAY
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 14
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 27
5991: PUSH
5992: LD_INT 26
5994: PUSH
5995: LD_INT 26
5997: PUSH
5998: LD_INT 26
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: LIST
6006: PUSH
6007: LD_OWVAR 67
6011: ARRAY
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 14
6021: PUSH
6022: LD_INT 1
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 26
6030: PUSH
6031: LD_INT 26
6033: PUSH
6034: LD_INT 29
6036: PUSH
6037: LD_INT 29
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: PUSH
6046: LD_OWVAR 67
6050: ARRAY
6051: PUSH
6052: EMPTY
6053: LIST
6054: LIST
6055: LIST
6056: LIST
6057: PUSH
6058: LD_INT 13
6060: PUSH
6061: LD_INT 1
6063: PUSH
6064: LD_INT 2
6066: PUSH
6067: LD_INT 26
6069: PUSH
6070: LD_INT 29
6072: PUSH
6073: LD_INT 29
6075: PUSH
6076: LD_INT 29
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: LD_OWVAR 67
6089: ARRAY
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: LIST
6095: LIST
6096: PUSH
6097: LD_INT 13
6099: PUSH
6100: LD_INT 1
6102: PUSH
6103: LD_INT 2
6105: PUSH
6106: LD_INT 29
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 14
6117: PUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 2
6123: PUSH
6124: LD_INT 26
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: LIST
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: LIST
6139: LIST
6140: PPUSH
6141: CALL 61156 0 2
// end ; repeat wait ( 0 0$1 ) ;
6145: LD_INT 35
6147: PPUSH
6148: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6152: LD_INT 3
6154: PPUSH
6155: LD_INT 1
6157: PPUSH
6158: CALL 62574 0 2
6162: PUSH
6163: LD_INT 6
6165: GREATEREQUAL
6166: IFFALSE 6145
// wait ( 0 0$30 ) ;
6168: LD_INT 1050
6170: PPUSH
6171: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_INT 3
6182: PPUSH
6183: LD_INT 1
6185: PPUSH
6186: CALL 62574 0 2
6190: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6191: LD_ADDR_EXP 119
6195: PUSH
6196: LD_EXP 119
6200: PPUSH
6201: LD_INT 3
6203: PPUSH
6204: LD_EXP 119
6208: PUSH
6209: LD_INT 3
6211: ARRAY
6212: PUSH
6213: LD_VAR 0 2
6217: DIFF
6218: PPUSH
6219: CALL_OW 1
6223: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6224: LD_ADDR_VAR 0 3
6228: PUSH
6229: LD_INT 0
6231: PPUSH
6232: LD_INT 2
6234: PPUSH
6235: CALL_OW 12
6239: ST_TO_ADDR
// if target then
6240: LD_VAR 0 3
6244: IFFALSE 6381
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PPUSH
6256: LD_INT 24
6258: PUSH
6259: LD_INT 250
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: PPUSH
6266: CALL_OW 72
6270: ST_TO_ADDR
// if not tmp then
6271: LD_VAR 0 2
6275: NOT
6276: IFFALSE 6280
// break ;
6278: GO 6379
// for i in tmp do
6280: LD_ADDR_VAR 0 1
6284: PUSH
6285: LD_VAR 0 2
6289: PUSH
6290: FOR_IN
6291: IFFALSE 6331
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6293: LD_VAR 0 1
6297: PPUSH
6298: LD_INT 89
6300: PPUSH
6301: LD_INT 71
6303: PPUSH
6304: CALL_OW 297
6308: PUSH
6309: LD_INT 9
6311: GREATER
6312: IFFALSE 6329
// ComMoveXY ( i , 89 , 71 ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_INT 89
6321: PPUSH
6322: LD_INT 71
6324: PPUSH
6325: CALL_OW 111
6329: GO 6290
6331: POP
6332: POP
// wait ( 0 0$1 ) ;
6333: LD_INT 35
6335: PPUSH
6336: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6340: LD_VAR 0 2
6344: PPUSH
6345: LD_INT 92
6347: PUSH
6348: LD_INT 89
6350: PUSH
6351: LD_INT 71
6353: PUSH
6354: LD_INT 9
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PPUSH
6363: CALL_OW 72
6367: PUSH
6368: LD_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: MINUS
6376: GREATEREQUAL
6377: IFFALSE 6246
// end else
6379: GO 6514
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PPUSH
6391: LD_INT 24
6393: PUSH
6394: LD_INT 250
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: ST_TO_ADDR
// if not tmp then
6406: LD_VAR 0 2
6410: NOT
6411: IFFALSE 6415
// break ;
6413: GO 6514
// for i in tmp do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: LD_VAR 0 2
6424: PUSH
6425: FOR_IN
6426: IFFALSE 6466
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6428: LD_VAR 0 1
6432: PPUSH
6433: LD_INT 125
6435: PPUSH
6436: LD_INT 129
6438: PPUSH
6439: CALL_OW 297
6443: PUSH
6444: LD_INT 9
6446: GREATER
6447: IFFALSE 6464
// ComMoveXY ( i , 125 , 129 ) ;
6449: LD_VAR 0 1
6453: PPUSH
6454: LD_INT 125
6456: PPUSH
6457: LD_INT 129
6459: PPUSH
6460: CALL_OW 111
6464: GO 6425
6466: POP
6467: POP
// wait ( 0 0$1 ) ;
6468: LD_INT 35
6470: PPUSH
6471: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6475: LD_VAR 0 2
6479: PPUSH
6480: LD_INT 92
6482: PUSH
6483: LD_INT 125
6485: PUSH
6486: LD_INT 129
6488: PUSH
6489: LD_INT 9
6491: PUSH
6492: EMPTY
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL_OW 72
6502: PUSH
6503: LD_VAR 0 2
6507: PUSH
6508: LD_INT 1
6510: MINUS
6511: GREATEREQUAL
6512: IFFALSE 6381
// end ; repeat wait ( 0 0$1 ) ;
6514: LD_INT 35
6516: PPUSH
6517: CALL_OW 67
// for i in tmp do
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_VAR 0 2
6530: PUSH
6531: FOR_IN
6532: IFFALSE 6614
// begin if GetLives ( i ) > 251 then
6534: LD_VAR 0 1
6538: PPUSH
6539: CALL_OW 256
6543: PUSH
6544: LD_INT 251
6546: GREATER
6547: IFFALSE 6585
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6549: LD_VAR 0 1
6553: PPUSH
6554: LD_INT 81
6556: PUSH
6557: LD_INT 8
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PPUSH
6564: CALL_OW 69
6568: PPUSH
6569: LD_VAR 0 1
6573: PPUSH
6574: CALL_OW 74
6578: PPUSH
6579: CALL_OW 115
6583: GO 6612
// if IsDead ( i ) then
6585: LD_VAR 0 1
6589: PPUSH
6590: CALL_OW 301
6594: IFFALSE 6612
// tmp := tmp diff i ;
6596: LD_ADDR_VAR 0 2
6600: PUSH
6601: LD_VAR 0 2
6605: PUSH
6606: LD_VAR 0 1
6610: DIFF
6611: ST_TO_ADDR
// end ;
6612: GO 6531
6614: POP
6615: POP
// until not tmp ;
6616: LD_VAR 0 2
6620: NOT
6621: IFFALSE 6514
// end ;
6623: PPOPN 3
6625: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6626: LD_EXP 22
6630: NOT
6631: PUSH
6632: LD_EXP 15
6636: PUSH
6637: LD_INT 6
6639: GREATEREQUAL
6640: AND
6641: PUSH
6642: LD_OWVAR 67
6646: PUSH
6647: LD_INT 1
6649: GREATER
6650: AND
6651: IFFALSE 7184
6653: GO 6655
6655: DISABLE
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// begin enable ;
6661: ENABLE
// tmp := [ ] ;
6662: LD_ADDR_VAR 0 3
6666: PUSH
6667: EMPTY
6668: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6669: LD_ADDR_VAR 0 1
6673: PUSH
6674: DOUBLE
6675: LD_INT 1
6677: DEC
6678: ST_TO_ADDR
6679: LD_INT 4
6681: PUSH
6682: LD_INT 6
6684: PUSH
6685: LD_INT 7
6687: PUSH
6688: LD_INT 8
6690: PUSH
6691: EMPTY
6692: LIST
6693: LIST
6694: LIST
6695: LIST
6696: PUSH
6697: LD_OWVAR 67
6701: ARRAY
6702: PUSH
6703: FOR_TO
6704: IFFALSE 6864
// begin uc_side := 8 ;
6706: LD_ADDR_OWVAR 20
6710: PUSH
6711: LD_INT 8
6713: ST_TO_ADDR
// uc_nation := 2 ;
6714: LD_ADDR_OWVAR 21
6718: PUSH
6719: LD_INT 2
6721: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6722: LD_INT 13
6724: PUSH
6725: LD_INT 14
6727: PUSH
6728: EMPTY
6729: LIST
6730: LIST
6731: PUSH
6732: LD_INT 1
6734: PPUSH
6735: LD_INT 2
6737: PPUSH
6738: CALL_OW 12
6742: ARRAY
6743: PPUSH
6744: LD_INT 1
6746: PPUSH
6747: LD_INT 5
6749: PPUSH
6750: LD_INT 27
6752: PUSH
6753: LD_INT 28
6755: PUSH
6756: LD_INT 26
6758: PUSH
6759: LD_INT 25
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: LIST
6766: LIST
6767: PUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 4
6773: PPUSH
6774: CALL_OW 12
6778: ARRAY
6779: PPUSH
6780: LD_INT 88
6782: PPUSH
6783: CALL 72597 0 5
// un := CreateVehicle ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: CALL_OW 45
6796: ST_TO_ADDR
// tmp := tmp ^ un ;
6797: LD_ADDR_VAR 0 3
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: LD_VAR 0 2
6811: ADD
6812: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6813: LD_VAR 0 2
6817: PPUSH
6818: LD_INT 3
6820: PPUSH
6821: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 30
6832: PPUSH
6833: LD_INT 0
6835: PPUSH
6836: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6840: LD_VAR 0 2
6844: PPUSH
6845: LD_INT 16
6847: PPUSH
6848: LD_INT 11
6850: PPUSH
6851: CALL_OW 111
// wait ( 0 0$2 ) ;
6855: LD_INT 70
6857: PPUSH
6858: CALL_OW 67
// end ;
6862: GO 6703
6864: POP
6865: POP
// for i = 1 to Difficulty do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_OWVAR 67
6880: PUSH
6881: FOR_TO
6882: IFFALSE 7011
// begin uc_side := 8 ;
6884: LD_ADDR_OWVAR 20
6888: PUSH
6889: LD_INT 8
6891: ST_TO_ADDR
// uc_nation := 2 ;
6892: LD_ADDR_OWVAR 21
6896: PUSH
6897: LD_INT 2
6899: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6900: LD_INT 0
6902: PPUSH
6903: LD_INT 8
6905: PPUSH
6906: LD_INT 8
6908: PUSH
6909: LD_INT 8
6911: PUSH
6912: LD_INT 9
6914: PUSH
6915: LD_INT 10
6917: PUSH
6918: EMPTY
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: PUSH
6924: LD_OWVAR 67
6928: ARRAY
6929: PPUSH
6930: CALL_OW 380
// un := CreateHuman ;
6934: LD_ADDR_VAR 0 2
6938: PUSH
6939: CALL_OW 44
6943: ST_TO_ADDR
// tmp := tmp ^ un ;
6944: LD_ADDR_VAR 0 3
6948: PUSH
6949: LD_VAR 0 3
6953: PUSH
6954: LD_VAR 0 2
6958: ADD
6959: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6960: LD_VAR 0 2
6964: PPUSH
6965: LD_INT 3
6967: PPUSH
6968: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6972: LD_VAR 0 2
6976: PPUSH
6977: LD_INT 30
6979: PPUSH
6980: LD_INT 0
6982: PPUSH
6983: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6987: LD_VAR 0 2
6991: PPUSH
6992: LD_INT 16
6994: PPUSH
6995: LD_INT 11
6997: PPUSH
6998: CALL_OW 111
// wait ( 0 0$2 ) ;
7002: LD_INT 70
7004: PPUSH
7005: CALL_OW 67
// end ;
7009: GO 6881
7011: POP
7012: POP
// repeat wait ( 0 0$1 ) ;
7013: LD_INT 35
7015: PPUSH
7016: CALL_OW 67
// if legionDestroyed then
7020: LD_EXP 22
7024: IFFALSE 7028
// exit ;
7026: GO 7184
// for i in tmp do
7028: LD_ADDR_VAR 0 1
7032: PUSH
7033: LD_VAR 0 3
7037: PUSH
7038: FOR_IN
7039: IFFALSE 7175
// begin if GetLives ( i ) > 250 then
7041: LD_VAR 0 1
7045: PPUSH
7046: CALL_OW 256
7050: PUSH
7051: LD_INT 250
7053: GREATER
7054: IFFALSE 7146
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7056: LD_INT 81
7058: PUSH
7059: LD_INT 8
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: PUSH
7066: LD_INT 91
7068: PUSH
7069: LD_VAR 0 1
7073: PUSH
7074: LD_INT 10
7076: PUSH
7077: EMPTY
7078: LIST
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PPUSH
7086: CALL_OW 69
7090: NOT
7091: IFFALSE 7110
// ComAgressiveMove ( i , 67 , 110 ) else
7093: LD_VAR 0 1
7097: PPUSH
7098: LD_INT 67
7100: PPUSH
7101: LD_INT 110
7103: PPUSH
7104: CALL_OW 114
7108: GO 7144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7110: LD_VAR 0 1
7114: PPUSH
7115: LD_INT 81
7117: PUSH
7118: LD_INT 8
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL_OW 69
7129: PPUSH
7130: LD_VAR 0 1
7134: PPUSH
7135: CALL_OW 74
7139: PPUSH
7140: CALL_OW 115
// end else
7144: GO 7173
// if IsDead ( i ) then
7146: LD_VAR 0 1
7150: PPUSH
7151: CALL_OW 301
7155: IFFALSE 7173
// tmp := tmp diff i ;
7157: LD_ADDR_VAR 0 3
7161: PUSH
7162: LD_VAR 0 3
7166: PUSH
7167: LD_VAR 0 1
7171: DIFF
7172: ST_TO_ADDR
// end ;
7173: GO 7038
7175: POP
7176: POP
// until not tmp ;
7177: LD_VAR 0 3
7181: NOT
7182: IFFALSE 7013
// end ; end_of_file
7184: PPOPN 3
7186: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7187: LD_INT 0
7189: PPUSH
7190: PPUSH
7191: PPUSH
7192: PPUSH
7193: PPUSH
7194: PPUSH
7195: PPUSH
7196: PPUSH
7197: PPUSH
// side := 3 ;
7198: LD_ADDR_VAR 0 6
7202: PUSH
7203: LD_INT 3
7205: ST_TO_ADDR
// uc_side := side ;
7206: LD_ADDR_OWVAR 20
7210: PUSH
7211: LD_VAR 0 6
7215: ST_TO_ADDR
// uc_nation := 3 ;
7216: LD_ADDR_OWVAR 21
7220: PUSH
7221: LD_INT 3
7223: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7224: LD_ADDR_VAR 0 2
7228: PUSH
7229: LD_INT 22
7231: PUSH
7232: LD_VAR 0 6
7236: PUSH
7237: EMPTY
7238: LIST
7239: LIST
7240: PUSH
7241: LD_INT 21
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 69
7259: PUSH
7260: FOR_IN
7261: IFFALSE 7277
// SetBLevel ( i , 10 ) ;
7263: LD_VAR 0 2
7267: PPUSH
7268: LD_INT 10
7270: PPUSH
7271: CALL_OW 241
7275: GO 7260
7277: POP
7278: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7279: LD_ADDR_VAR 0 9
7283: PUSH
7284: LD_INT 22
7286: PUSH
7287: LD_VAR 0 6
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: PUSH
7296: LD_INT 30
7298: PUSH
7299: LD_INT 34
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: PPUSH
7310: CALL_OW 69
7314: ST_TO_ADDR
// if teleport then
7315: LD_VAR 0 9
7319: IFFALSE 7340
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7321: LD_VAR 0 9
7325: PUSH
7326: LD_INT 1
7328: ARRAY
7329: PPUSH
7330: LD_INT 123
7332: PPUSH
7333: LD_INT 122
7335: PPUSH
7336: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7340: LD_ADDR_EXP 66
7344: PUSH
7345: LD_STRING Platonov
7347: PPUSH
7348: CALL_OW 25
7352: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7353: LD_ADDR_EXP 67
7357: PUSH
7358: LD_STRING Kovalyuk
7360: PPUSH
7361: CALL_OW 25
7365: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7366: LD_ADDR_EXP 69
7370: PUSH
7371: LD_STRING Yakotich
7373: PPUSH
7374: LD_EXP 1
7378: NOT
7379: PPUSH
7380: LD_STRING 09_
7382: PPUSH
7383: CALL 67582 0 3
7387: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7388: LD_ADDR_EXP 68
7392: PUSH
7393: LD_STRING Bystrov
7395: PPUSH
7396: CALL_OW 25
7400: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7401: LD_ADDR_EXP 70
7405: PUSH
7406: LD_STRING Gleb
7408: PPUSH
7409: CALL_OW 25
7413: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7414: LD_STRING 03_Cornel
7416: PPUSH
7417: CALL_OW 28
7421: IFFALSE 7469
// begin Bierezov := NewCharacter ( Mikhail ) ;
7423: LD_ADDR_EXP 71
7427: PUSH
7428: LD_STRING Mikhail
7430: PPUSH
7431: CALL_OW 25
7435: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7436: LD_EXP 71
7440: PPUSH
7441: LD_INT 197
7443: PPUSH
7444: LD_INT 111
7446: PPUSH
7447: LD_INT 9
7449: PPUSH
7450: LD_INT 0
7452: PPUSH
7453: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7457: LD_EXP 71
7461: PPUSH
7462: LD_INT 3
7464: PPUSH
7465: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7469: LD_EXP 66
7473: PPUSH
7474: LD_INT 126
7476: PPUSH
7477: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7481: LD_EXP 67
7485: PPUSH
7486: LD_INT 134
7488: PPUSH
7489: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7493: LD_EXP 69
7497: PPUSH
7498: LD_INT 197
7500: PPUSH
7501: LD_INT 111
7503: PPUSH
7504: LD_INT 9
7506: PPUSH
7507: LD_INT 0
7509: PPUSH
7510: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7514: LD_EXP 68
7518: PPUSH
7519: LD_INT 197
7521: PPUSH
7522: LD_INT 111
7524: PPUSH
7525: LD_INT 9
7527: PPUSH
7528: LD_INT 0
7530: PPUSH
7531: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7535: LD_EXP 70
7539: PPUSH
7540: LD_INT 197
7542: PPUSH
7543: LD_INT 111
7545: PPUSH
7546: LD_INT 9
7548: PPUSH
7549: LD_INT 0
7551: PPUSH
7552: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7556: LD_ADDR_VAR 0 5
7560: PUSH
7561: LD_INT 126
7563: PPUSH
7564: LD_INT 4
7566: PPUSH
7567: LD_STRING zhukov
7569: PPUSH
7570: LD_INT 9
7572: PUSH
7573: LD_INT 10
7575: PUSH
7576: LD_INT 10
7578: PUSH
7579: LD_INT 10
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: LIST
7586: LIST
7587: PUSH
7588: LD_OWVAR 67
7592: ARRAY
7593: PPUSH
7594: LD_INT 90000
7596: PUSH
7597: LD_INT 1000
7599: PUSH
7600: LD_INT 300
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: LIST
7607: PPUSH
7608: LD_INT 18
7610: PUSH
7611: LD_INT 8
7613: PUSH
7614: LD_INT 13
7616: PUSH
7617: LD_INT 8
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL 76041 0 6
7630: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7631: LD_ADDR_VAR 0 4
7635: PUSH
7636: LD_INT 267
7638: PPUSH
7639: CALL_OW 274
7643: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7644: LD_VAR 0 4
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 5000
7654: PPUSH
7655: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7659: LD_VAR 0 4
7663: PPUSH
7664: LD_INT 2
7666: PPUSH
7667: LD_INT 200
7669: PPUSH
7670: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7674: LD_VAR 0 4
7678: PPUSH
7679: LD_INT 3
7681: PPUSH
7682: LD_INT 200
7684: PPUSH
7685: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7689: LD_ADDR_EXP 100
7693: PUSH
7694: LD_EXP 100
7698: PPUSH
7699: LD_INT 2
7701: PPUSH
7702: LD_VAR 0 5
7706: PUSH
7707: LD_INT 22
7709: PUSH
7710: LD_VAR 0 6
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 3
7721: PUSH
7722: LD_INT 21
7724: PUSH
7725: LD_INT 2
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PPUSH
7740: CALL_OW 69
7744: UNION
7745: PUSH
7746: LD_EXP 66
7750: DIFF
7751: PPUSH
7752: CALL_OW 1
7756: ST_TO_ADDR
// behemoths := [ ] ;
7757: LD_ADDR_EXP 74
7761: PUSH
7762: EMPTY
7763: ST_TO_ADDR
// behemothBuilders := [ ] ;
7764: LD_ADDR_EXP 75
7768: PUSH
7769: EMPTY
7770: ST_TO_ADDR
// if Kovalyuk then
7771: LD_EXP 67
7775: IFFALSE 7797
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7777: LD_ADDR_EXP 75
7781: PUSH
7782: LD_EXP 75
7786: PPUSH
7787: LD_EXP 67
7791: PPUSH
7792: CALL 105050 0 2
7796: ST_TO_ADDR
// j := 3 ;
7797: LD_ADDR_VAR 0 3
7801: PUSH
7802: LD_INT 3
7804: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7805: LD_ADDR_VAR 0 2
7809: PUSH
7810: LD_INT 22
7812: PUSH
7813: LD_INT 3
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 25
7822: PUSH
7823: LD_INT 3
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PPUSH
7834: CALL_OW 69
7838: PUSH
7839: LD_EXP 67
7843: DIFF
7844: PUSH
7845: FOR_IN
7846: IFFALSE 7896
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7848: LD_ADDR_EXP 75
7852: PUSH
7853: LD_EXP 75
7857: PPUSH
7858: LD_VAR 0 2
7862: PPUSH
7863: CALL 105050 0 2
7867: ST_TO_ADDR
// j := j - 1 ;
7868: LD_ADDR_VAR 0 3
7872: PUSH
7873: LD_VAR 0 3
7877: PUSH
7878: LD_INT 1
7880: MINUS
7881: ST_TO_ADDR
// if j = 0 then
7882: LD_VAR 0 3
7886: PUSH
7887: LD_INT 0
7889: EQUAL
7890: IFFALSE 7894
// break ;
7892: GO 7896
// end ;
7894: GO 7845
7896: POP
7897: POP
// end ;
7898: LD_VAR 0 1
7902: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
7909: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7910: LD_ADDR_VAR 0 4
7914: PUSH
7915: LD_INT 209
7917: PUSH
7918: LD_INT 149
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PUSH
7925: LD_INT 219
7927: PUSH
7928: LD_INT 154
7930: PUSH
7931: EMPTY
7932: LIST
7933: LIST
7934: PUSH
7935: LD_INT 223
7937: PUSH
7938: LD_INT 149
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 232
7947: PUSH
7948: LD_INT 155
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: LIST
7959: LIST
7960: ST_TO_ADDR
// if not behemothBuilders then
7961: LD_EXP 75
7965: NOT
7966: IFFALSE 7970
// exit ;
7968: GO 8101
// j := 1 ;
7970: LD_ADDR_VAR 0 3
7974: PUSH
7975: LD_INT 1
7977: ST_TO_ADDR
// for i in behemothBuilders do
7978: LD_ADDR_VAR 0 2
7982: PUSH
7983: LD_EXP 75
7987: PUSH
7988: FOR_IN
7989: IFFALSE 8099
// begin if GetClass ( i ) <> class_mechanic then
7991: LD_VAR 0 2
7995: PPUSH
7996: CALL_OW 257
8000: PUSH
8001: LD_INT 3
8003: NONEQUAL
8004: IFFALSE 8018
// SetClass ( i , class_mechanic ) ;
8006: LD_VAR 0 2
8010: PPUSH
8011: LD_INT 3
8013: PPUSH
8014: CALL_OW 336
// if IsInUnit ( i ) then
8018: LD_VAR 0 2
8022: PPUSH
8023: CALL_OW 310
8027: IFFALSE 8038
// ComExitBuilding ( i ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8038: LD_VAR 0 2
8042: PPUSH
8043: LD_INT 37
8045: PPUSH
8046: LD_VAR 0 4
8050: PUSH
8051: LD_VAR 0 3
8055: ARRAY
8056: PUSH
8057: LD_INT 1
8059: ARRAY
8060: PPUSH
8061: LD_VAR 0 4
8065: PUSH
8066: LD_VAR 0 3
8070: ARRAY
8071: PUSH
8072: LD_INT 2
8074: ARRAY
8075: PPUSH
8076: LD_INT 0
8078: PPUSH
8079: CALL_OW 230
// j := j + 1 ;
8083: LD_ADDR_VAR 0 3
8087: PUSH
8088: LD_VAR 0 3
8092: PUSH
8093: LD_INT 1
8095: PLUS
8096: ST_TO_ADDR
// end ;
8097: GO 7988
8099: POP
8100: POP
// end ;
8101: LD_VAR 0 1
8105: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8106: LD_INT 24
8108: PPUSH
8109: LD_INT 30
8111: PUSH
8112: LD_INT 37
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 70
8123: IFFALSE 8136
8125: GO 8127
8127: DISABLE
// behemothUnderConstruct := true ;
8128: LD_ADDR_EXP 26
8132: PUSH
8133: LD_INT 1
8135: ST_TO_ADDR
8136: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8137: LD_INT 3
8139: PPUSH
8140: CALL 105111 0 1
8144: PUSH
8145: LD_INT 22
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: LD_INT 30
8157: PUSH
8158: LD_INT 37
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 69
8173: NOT
8174: AND
8175: IFFALSE 8361
8177: GO 8179
8179: DISABLE
8180: LD_INT 0
8182: PPUSH
8183: PPUSH
// begin enable ;
8184: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8185: LD_ADDR_VAR 0 2
8189: PUSH
8190: LD_INT 3
8192: PPUSH
8193: CALL 105111 0 1
8197: ST_TO_ADDR
// for i in tmp do
8198: LD_ADDR_VAR 0 1
8202: PUSH
8203: LD_VAR 0 2
8207: PUSH
8208: FOR_IN
8209: IFFALSE 8359
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8211: LD_VAR 0 1
8215: PPUSH
8216: LD_INT 9
8218: PPUSH
8219: CALL_OW 308
8223: PUSH
8224: LD_VAR 0 1
8228: PPUSH
8229: CALL_OW 110
8233: PUSH
8234: LD_INT 2
8236: EQUAL
8237: NOT
8238: AND
8239: IFFALSE 8253
// SetTag ( i , 2 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 2
8248: PPUSH
8249: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8253: LD_INT 81
8255: PUSH
8256: LD_INT 3
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PUSH
8263: LD_INT 91
8265: PUSH
8266: LD_VAR 0 1
8270: PUSH
8271: LD_INT 12
8273: PUSH
8274: EMPTY
8275: LIST
8276: LIST
8277: LIST
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 69
8287: NOT
8288: PUSH
8289: LD_VAR 0 1
8293: PPUSH
8294: CALL_OW 110
8298: PUSH
8299: LD_INT 2
8301: EQUAL
8302: NOT
8303: AND
8304: IFFALSE 8323
// ComAgressiveMove ( i , 64 , 93 ) else
8306: LD_VAR 0 1
8310: PPUSH
8311: LD_INT 64
8313: PPUSH
8314: LD_INT 93
8316: PPUSH
8317: CALL_OW 114
8321: GO 8357
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8323: LD_VAR 0 1
8327: PPUSH
8328: LD_INT 81
8330: PUSH
8331: LD_INT 3
8333: PUSH
8334: EMPTY
8335: LIST
8336: LIST
8337: PPUSH
8338: CALL_OW 69
8342: PPUSH
8343: LD_VAR 0 1
8347: PPUSH
8348: CALL_OW 74
8352: PPUSH
8353: CALL_OW 115
// end ;
8357: GO 8208
8359: POP
8360: POP
// end ;
8361: PPOPN 2
8363: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8364: LD_INT 0
8366: PPUSH
8367: PPUSH
8368: PPUSH
// result := [ ] ;
8369: LD_ADDR_VAR 0 2
8373: PUSH
8374: EMPTY
8375: ST_TO_ADDR
// uc_side := 6 ;
8376: LD_ADDR_OWVAR 20
8380: PUSH
8381: LD_INT 6
8383: ST_TO_ADDR
// uc_nation := 3 ;
8384: LD_ADDR_OWVAR 21
8388: PUSH
8389: LD_INT 3
8391: ST_TO_ADDR
// case strength of 1 :
8392: LD_VAR 0 1
8396: PUSH
8397: LD_INT 1
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8547
8405: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 4
8418: PUSH
8419: LD_INT 5
8421: PUSH
8422: LD_INT 6
8424: PUSH
8425: LD_INT 7
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_OWVAR 67
8438: ARRAY
8439: PUSH
8440: FOR_TO
8441: IFFALSE 8543
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8443: LD_INT 22
8445: PUSH
8446: LD_INT 24
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 2
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 44
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: LIST
8505: PUSH
8506: LD_INT 1
8508: PPUSH
8509: LD_INT 3
8511: PPUSH
8512: CALL_OW 12
8516: ARRAY
8517: PPUSH
8518: LD_INT 80
8520: PPUSH
8521: CALL 72597 0 5
// result := result union CreateVehicle ;
8525: LD_ADDR_VAR 0 2
8529: PUSH
8530: LD_VAR 0 2
8534: PUSH
8535: CALL_OW 45
8539: UNION
8540: ST_TO_ADDR
// end ;
8541: GO 8440
8543: POP
8544: POP
// end ; 2 :
8545: GO 9542
8547: LD_INT 2
8549: DOUBLE
8550: EQUAL
8551: IFTRUE 8555
8553: GO 8723
8555: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: DOUBLE
8562: LD_INT 1
8564: DEC
8565: ST_TO_ADDR
8566: LD_INT 5
8568: PUSH
8569: LD_INT 6
8571: PUSH
8572: LD_INT 7
8574: PUSH
8575: LD_INT 8
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_OWVAR 67
8588: ARRAY
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8719
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8593: LD_INT 22
8595: PUSH
8596: LD_INT 24
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: LIST
8606: PUSH
8607: LD_VAR 0 3
8611: PUSH
8612: LD_INT 3
8614: MOD
8615: PUSH
8616: LD_INT 1
8618: PLUS
8619: ARRAY
8620: PPUSH
8621: LD_INT 1
8623: PUSH
8624: LD_INT 3
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PUSH
8631: LD_INT 1
8633: PPUSH
8634: LD_INT 2
8636: PPUSH
8637: CALL_OW 12
8641: ARRAY
8642: PPUSH
8643: LD_INT 3
8645: PPUSH
8646: LD_INT 43
8648: PUSH
8649: LD_INT 44
8651: PUSH
8652: LD_INT 45
8654: PUSH
8655: LD_INT 44
8657: PUSH
8658: LD_INT 46
8660: PUSH
8661: LD_INT 46
8663: PUSH
8664: LD_INT 49
8666: PUSH
8667: LD_INT 49
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: LIST
8674: LIST
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_VAR 0 3
8684: PUSH
8685: LD_INT 8
8687: MOD
8688: PUSH
8689: LD_INT 1
8691: PLUS
8692: ARRAY
8693: PPUSH
8694: LD_INT 80
8696: PPUSH
8697: CALL 72597 0 5
// result := result union CreateVehicle ;
8701: LD_ADDR_VAR 0 2
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: CALL_OW 45
8715: UNION
8716: ST_TO_ADDR
// end ;
8717: GO 8590
8719: POP
8720: POP
// end ; 3 :
8721: GO 9542
8723: LD_INT 3
8725: DOUBLE
8726: EQUAL
8727: IFTRUE 8731
8729: GO 8903
8731: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8732: LD_ADDR_VAR 0 3
8736: PUSH
8737: DOUBLE
8738: LD_INT 1
8740: DEC
8741: ST_TO_ADDR
8742: LD_INT 6
8744: PUSH
8745: LD_INT 7
8747: PUSH
8748: LD_INT 8
8750: PUSH
8751: LD_INT 9
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_OWVAR 67
8764: ARRAY
8765: PUSH
8766: FOR_TO
8767: IFFALSE 8899
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8769: LD_INT 22
8771: PUSH
8772: LD_INT 24
8774: PUSH
8775: LD_INT 24
8777: PUSH
8778: EMPTY
8779: LIST
8780: LIST
8781: LIST
8782: PUSH
8783: LD_VAR 0 3
8787: PUSH
8788: LD_INT 3
8790: MOD
8791: PUSH
8792: LD_INT 1
8794: PLUS
8795: ARRAY
8796: PPUSH
8797: LD_INT 1
8799: PUSH
8800: LD_INT 3
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 1
8809: PPUSH
8810: LD_INT 2
8812: PPUSH
8813: CALL_OW 12
8817: ARRAY
8818: PPUSH
8819: LD_INT 3
8821: PPUSH
8822: LD_INT 43
8824: PUSH
8825: LD_INT 47
8827: PUSH
8828: LD_INT 45
8830: PUSH
8831: LD_INT 45
8833: PUSH
8834: LD_INT 46
8836: PUSH
8837: LD_INT 46
8839: PUSH
8840: LD_INT 49
8842: PUSH
8843: LD_INT 49
8845: PUSH
8846: LD_INT 49
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_VAR 0 3
8864: PUSH
8865: LD_INT 9
8867: MOD
8868: PUSH
8869: LD_INT 1
8871: PLUS
8872: ARRAY
8873: PPUSH
8874: LD_INT 80
8876: PPUSH
8877: CALL 72597 0 5
// result := result union CreateVehicle ;
8881: LD_ADDR_VAR 0 2
8885: PUSH
8886: LD_VAR 0 2
8890: PUSH
8891: CALL_OW 45
8895: UNION
8896: ST_TO_ADDR
// end ;
8897: GO 8766
8899: POP
8900: POP
// end ; 4 :
8901: GO 9542
8903: LD_INT 4
8905: DOUBLE
8906: EQUAL
8907: IFTRUE 8911
8909: GO 9541
8911: POP
// begin uc_nation := 3 ;
8912: LD_ADDR_OWVAR 21
8916: PUSH
8917: LD_INT 3
8919: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8920: LD_ADDR_VAR 0 3
8924: PUSH
8925: DOUBLE
8926: LD_INT 1
8928: DEC
8929: ST_TO_ADDR
8930: LD_INT 6
8932: PUSH
8933: LD_INT 8
8935: PUSH
8936: LD_INT 9
8938: PUSH
8939: LD_INT 10
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: LIST
8946: LIST
8947: PUSH
8948: LD_OWVAR 67
8952: ARRAY
8953: PUSH
8954: FOR_TO
8955: IFFALSE 9087
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 24
8962: PUSH
8963: LD_INT 24
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: LIST
8970: PUSH
8971: LD_VAR 0 3
8975: PUSH
8976: LD_INT 3
8978: MOD
8979: PUSH
8980: LD_INT 1
8982: PLUS
8983: ARRAY
8984: PPUSH
8985: LD_INT 1
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: ARRAY
9006: PPUSH
9007: LD_INT 3
9009: PPUSH
9010: LD_INT 45
9012: PUSH
9013: LD_INT 47
9015: PUSH
9016: LD_INT 47
9018: PUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 46
9024: PUSH
9025: LD_INT 46
9027: PUSH
9028: LD_INT 49
9030: PUSH
9031: LD_INT 49
9033: PUSH
9034: LD_INT 49
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: PUSH
9048: LD_VAR 0 3
9052: PUSH
9053: LD_INT 9
9055: MOD
9056: PUSH
9057: LD_INT 1
9059: PLUS
9060: ARRAY
9061: PPUSH
9062: LD_INT 80
9064: PPUSH
9065: CALL 72597 0 5
// result := result union CreateVehicle ;
9069: LD_ADDR_VAR 0 2
9073: PUSH
9074: LD_VAR 0 2
9078: PUSH
9079: CALL_OW 45
9083: UNION
9084: ST_TO_ADDR
// end ;
9085: GO 8954
9087: POP
9088: POP
// if not KappaStatus then
9089: LD_EXP 2
9093: NOT
9094: IFFALSE 9329
// begin uc_nation := 1 ;
9096: LD_ADDR_OWVAR 21
9100: PUSH
9101: LD_INT 1
9103: ST_TO_ADDR
// for i = 1 to 3 do
9104: LD_ADDR_VAR 0 3
9108: PUSH
9109: DOUBLE
9110: LD_INT 1
9112: DEC
9113: ST_TO_ADDR
9114: LD_INT 3
9116: PUSH
9117: FOR_TO
9118: IFFALSE 9254
// begin j := rand ( 0 , 1 ) ;
9120: LD_ADDR_VAR 0 4
9124: PUSH
9125: LD_INT 0
9127: PPUSH
9128: LD_INT 1
9130: PPUSH
9131: CALL_OW 12
9135: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9136: LD_INT 3
9138: PUSH
9139: LD_INT 5
9141: PUSH
9142: LD_INT 5
9144: PUSH
9145: LD_INT 4
9147: PUSH
9148: EMPTY
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: PUSH
9154: LD_VAR 0 4
9158: PUSH
9159: LD_INT 1
9161: PPUSH
9162: LD_INT 3
9164: PPUSH
9165: CALL_OW 12
9169: PLUS
9170: ARRAY
9171: PPUSH
9172: LD_INT 1
9174: PUSH
9175: LD_INT 3
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PUSH
9182: LD_INT 1
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: CALL_OW 12
9192: ARRAY
9193: PPUSH
9194: LD_INT 3
9196: PPUSH
9197: LD_INT 9
9199: PUSH
9200: LD_INT 7
9202: PUSH
9203: LD_INT 6
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: PUSH
9211: LD_VAR 0 4
9215: PUSH
9216: LD_INT 1
9218: PPUSH
9219: LD_INT 2
9221: PPUSH
9222: CALL_OW 12
9226: PLUS
9227: ARRAY
9228: PPUSH
9229: LD_INT 85
9231: PPUSH
9232: CALL 72597 0 5
// result := result union CreateVehicle ;
9236: LD_ADDR_VAR 0 2
9240: PUSH
9241: LD_VAR 0 2
9245: PUSH
9246: CALL_OW 45
9250: UNION
9251: ST_TO_ADDR
// end ;
9252: GO 9117
9254: POP
9255: POP
// if vsevolodFirstAttack then
9256: LD_EXP 24
9260: IFFALSE 9327
// begin vsevolodFirstAttack := false ;
9262: LD_ADDR_EXP 24
9266: PUSH
9267: LD_INT 0
9269: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9270: LD_INT 5
9272: PPUSH
9273: LD_INT 3
9275: PPUSH
9276: LD_INT 1
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 100
9284: PPUSH
9285: CALL 72597 0 5
// sewiVeh := CreateVehicle ;
9289: LD_ADDR_EXP 73
9293: PUSH
9294: CALL_OW 45
9298: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9299: LD_EXP 73
9303: PPUSH
9304: LD_INT 1
9306: PPUSH
9307: CALL_OW 242
// result := result union sewiVeh ;
9311: LD_ADDR_VAR 0 2
9315: PUSH
9316: LD_VAR 0 2
9320: PUSH
9321: LD_EXP 73
9325: UNION
9326: ST_TO_ADDR
// end ; end else
9327: GO 9539
// if vsevolodFirstAttack then
9329: LD_EXP 24
9333: IFFALSE 9539
// begin vsevolodFirstAttack := false ;
9335: LD_ADDR_EXP 24
9339: PUSH
9340: LD_INT 0
9342: ST_TO_ADDR
// uc_nation := 3 ;
9343: LD_ADDR_OWVAR 21
9347: PUSH
9348: LD_INT 3
9350: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9351: LD_ADDR_VAR 0 3
9355: PUSH
9356: DOUBLE
9357: LD_INT 1
9359: DEC
9360: ST_TO_ADDR
9361: LD_INT 2
9363: PUSH
9364: LD_OWVAR 67
9368: PLUS
9369: PUSH
9370: FOR_TO
9371: IFFALSE 9479
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9373: LD_INT 22
9375: PUSH
9376: LD_INT 24
9378: PUSH
9379: LD_INT 24
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: LIST
9386: PUSH
9387: LD_VAR 0 3
9391: PUSH
9392: LD_INT 3
9394: MOD
9395: PUSH
9396: LD_INT 1
9398: PLUS
9399: ARRAY
9400: PPUSH
9401: LD_INT 1
9403: PUSH
9404: LD_INT 3
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 1
9413: PPUSH
9414: LD_INT 2
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: PPUSH
9423: LD_INT 1
9425: PPUSH
9426: LD_INT 45
9428: PUSH
9429: LD_INT 47
9431: PUSH
9432: LD_INT 47
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: PUSH
9440: LD_VAR 0 3
9444: PUSH
9445: LD_INT 3
9447: MOD
9448: PUSH
9449: LD_INT 1
9451: PLUS
9452: ARRAY
9453: PPUSH
9454: LD_INT 80
9456: PPUSH
9457: CALL 72597 0 5
// result := result union CreateVehicle ;
9461: LD_ADDR_VAR 0 2
9465: PUSH
9466: LD_VAR 0 2
9470: PUSH
9471: CALL_OW 45
9475: UNION
9476: ST_TO_ADDR
// end ;
9477: GO 9370
9479: POP
9480: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9481: LD_INT 24
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 47
9492: PPUSH
9493: LD_INT 100
9495: PPUSH
9496: CALL 72597 0 5
// sewiVeh := CreateVehicle ;
9500: LD_ADDR_EXP 73
9504: PUSH
9505: CALL_OW 45
9509: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9510: LD_EXP 73
9514: PPUSH
9515: LD_INT 6
9517: NEG
9518: PPUSH
9519: CALL_OW 242
// result := result union sewiVeh ;
9523: LD_ADDR_VAR 0 2
9527: PUSH
9528: LD_VAR 0 2
9532: PUSH
9533: LD_EXP 73
9537: UNION
9538: ST_TO_ADDR
// end ; end ; end ;
9539: GO 9542
9541: POP
// end ;
9542: LD_VAR 0 2
9546: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9547: LD_EXP 16
9551: IFFALSE 10222
9553: GO 9555
9555: DISABLE
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
9562: PPUSH
9563: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9564: LD_ADDR_VAR 0 4
9568: PUSH
9569: LD_INT 11
9571: PUSH
9572: LD_INT 12
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9579: LD_ADDR_VAR 0 3
9583: PUSH
9584: LD_INT 11550
9586: PUSH
9587: LD_INT 10150
9589: PUSH
9590: LD_INT 9800
9592: PUSH
9593: LD_INT 9450
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_OWVAR 67
9606: ARRAY
9607: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9608: LD_ADDR_VAR 0 6
9612: PUSH
9613: LD_INT 70
9615: PUSH
9616: LD_INT 118
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 78
9625: PUSH
9626: LD_INT 31
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: ST_TO_ADDR
// repeat if missionStage = 2 then
9637: LD_EXP 15
9641: PUSH
9642: LD_INT 2
9644: EQUAL
9645: IFFALSE 9656
// wait ( 1 1$30 ) else
9647: LD_INT 3150
9649: PPUSH
9650: CALL_OW 67
9654: GO 9665
// wait ( time ) ;
9656: LD_VAR 0 3
9660: PPUSH
9661: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9665: LD_EXP 15
9669: PUSH
9670: LD_INT 6
9672: EQUAL
9673: PUSH
9674: LD_OWVAR 67
9678: PUSH
9679: LD_INT 2
9681: GREATER
9682: OR
9683: IFFALSE 9711
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9685: LD_INT 51
9687: PPUSH
9688: LD_INT 6
9690: PPUSH
9691: LD_INT 2
9693: PPUSH
9694: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9698: LD_INT 57
9700: PPUSH
9701: LD_INT 6
9703: PPUSH
9704: LD_INT 2
9706: PPUSH
9707: CALL_OW 322
// end ; if missionStage = 8 then
9711: LD_EXP 15
9715: PUSH
9716: LD_INT 8
9718: EQUAL
9719: IFFALSE 9747
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9721: LD_INT 52
9723: PPUSH
9724: LD_INT 6
9726: PPUSH
9727: LD_INT 2
9729: PPUSH
9730: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9734: LD_INT 58
9736: PPUSH
9737: LD_INT 6
9739: PPUSH
9740: LD_INT 2
9742: PPUSH
9743: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9747: LD_EXP 15
9751: PUSH
9752: LD_INT 10
9754: EQUAL
9755: PUSH
9756: LD_OWVAR 67
9760: PUSH
9761: LD_INT 1
9763: GREATER
9764: AND
9765: IFFALSE 9793
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9767: LD_INT 53
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 2
9775: PPUSH
9776: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9780: LD_INT 59
9782: PPUSH
9783: LD_INT 6
9785: PPUSH
9786: LD_INT 2
9788: PPUSH
9789: CALL_OW 322
// end ; if activeAttacks then
9793: LD_EXP 16
9797: IFFALSE 10216
// begin if missionStage = 2 then
9799: LD_EXP 15
9803: PUSH
9804: LD_INT 2
9806: EQUAL
9807: IFFALSE 9817
// strength := 1 ;
9809: LD_ADDR_VAR 0 5
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
// if missionStage > 2 then
9817: LD_EXP 15
9821: PUSH
9822: LD_INT 2
9824: GREATER
9825: IFFALSE 9835
// strength := 2 ;
9827: LD_ADDR_VAR 0 5
9831: PUSH
9832: LD_INT 2
9834: ST_TO_ADDR
// if missionStage > 6 then
9835: LD_EXP 15
9839: PUSH
9840: LD_INT 6
9842: GREATER
9843: IFFALSE 9853
// strength := 3 ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_INT 3
9852: ST_TO_ADDR
// if missionStage > 10 then
9853: LD_EXP 15
9857: PUSH
9858: LD_INT 10
9860: GREATER
9861: IFFALSE 9871
// strength := 4 ;
9863: LD_ADDR_VAR 0 5
9867: PUSH
9868: LD_INT 4
9870: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9871: LD_ADDR_VAR 0 2
9875: PUSH
9876: LD_VAR 0 5
9880: PPUSH
9881: CALL 8364 0 1
9885: ST_TO_ADDR
// for i in tmp do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 2
9895: PUSH
9896: FOR_IN
9897: IFFALSE 10106
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9899: LD_VAR 0 1
9903: PPUSH
9904: LD_VAR 0 4
9908: PUSH
9909: LD_INT 1
9911: PPUSH
9912: LD_INT 2
9914: PPUSH
9915: CALL_OW 12
9919: ARRAY
9920: PPUSH
9921: LD_INT 0
9923: PPUSH
9924: CALL_OW 49
// if i = sewiVeh then
9928: LD_VAR 0 1
9932: PUSH
9933: LD_EXP 73
9937: EQUAL
9938: IFFALSE 9975
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9940: LD_ADDR_EXP 72
9944: PUSH
9945: LD_STRING Vsevolod
9947: PPUSH
9948: LD_INT 0
9950: PPUSH
9951: LD_STRING 
9953: PPUSH
9954: CALL 67582 0 3
9958: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9959: LD_EXP 72
9963: PPUSH
9964: LD_VAR 0 1
9968: PPUSH
9969: CALL_OW 52
// end else
9973: GO 10056
// if GetControl ( i ) = control_manual then
9975: LD_VAR 0 1
9979: PPUSH
9980: CALL_OW 263
9984: PUSH
9985: LD_INT 1
9987: EQUAL
9988: IFFALSE 10056
// begin uc_side := 6 ;
9990: LD_ADDR_OWVAR 20
9994: PUSH
9995: LD_INT 6
9997: ST_TO_ADDR
// uc_nation := 3 ;
9998: LD_ADDR_OWVAR 21
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// hc_gallery :=  ;
10006: LD_ADDR_OWVAR 33
10010: PUSH
10011: LD_STRING 
10013: ST_TO_ADDR
// hc_name :=  ;
10014: LD_ADDR_OWVAR 26
10018: PUSH
10019: LD_STRING 
10021: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10022: LD_INT 0
10024: PPUSH
10025: LD_INT 3
10027: PPUSH
10028: LD_INT 10
10030: PPUSH
10031: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10035: CALL_OW 44
10039: PPUSH
10040: LD_VAR 0 1
10044: PPUSH
10045: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10049: LD_INT 10
10051: PPUSH
10052: CALL_OW 67
// end ; if Prob ( 50 ) then
10056: LD_INT 50
10058: PPUSH
10059: CALL_OW 13
10063: IFFALSE 10082
// ComMoveXY ( i , 111 , 197 ) else
10065: LD_VAR 0 1
10069: PPUSH
10070: LD_INT 111
10072: PPUSH
10073: LD_INT 197
10075: PPUSH
10076: CALL_OW 111
10080: GO 10097
// ComMoveXY ( i , 91 , 165 ) ;
10082: LD_VAR 0 1
10086: PPUSH
10087: LD_INT 91
10089: PPUSH
10090: LD_INT 165
10092: PPUSH
10093: CALL_OW 111
// wait ( 0 0$2 ) ;
10097: LD_INT 70
10099: PPUSH
10100: CALL_OW 67
// end ;
10104: GO 9896
10106: POP
10107: POP
// repeat wait ( 0 0$1 ) ;
10108: LD_INT 35
10110: PPUSH
10111: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10115: LD_ADDR_VAR 0 1
10119: PUSH
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 50
10127: PUSH
10128: EMPTY
10129: LIST
10130: PPUSH
10131: CALL_OW 72
10135: PUSH
10136: FOR_IN
10137: IFFALSE 10196
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: LD_INT 108
10146: PUSH
10147: LD_INT 153
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 105
10156: PUSH
10157: LD_INT 149
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 85
10166: PUSH
10167: LD_INT 131
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 64
10176: PUSH
10177: LD_INT 105
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: LIST
10189: PPUSH
10190: CALL 107654 0 2
10194: GO 10136
10196: POP
10197: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10198: LD_VAR 0 2
10202: PPUSH
10203: LD_INT 50
10205: PUSH
10206: EMPTY
10207: LIST
10208: PPUSH
10209: CALL_OW 72
10213: NOT
10214: IFFALSE 10108
// end ; until russianDestroyed ;
10216: LD_EXP 21
10220: IFFALSE 9637
// end ;
10222: PPOPN 6
10224: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10225: LD_EXP 21
10229: NOT
10230: PUSH
10231: LD_EXP 15
10235: PUSH
10236: LD_INT 6
10238: GREATEREQUAL
10239: AND
10240: PUSH
10241: LD_INT 2
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL 62574 0 2
10251: NOT
10252: AND
10253: IFFALSE 11192
10255: GO 10257
10257: DISABLE
10258: LD_INT 0
10260: PPUSH
10261: PPUSH
10262: PPUSH
10263: PPUSH
// begin enable ;
10264: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10265: LD_INT 22
10267: PUSH
10268: LD_INT 3
10270: PUSH
10271: EMPTY
10272: LIST
10273: LIST
10274: PUSH
10275: LD_INT 30
10277: PUSH
10278: LD_INT 3
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: PUSH
10285: EMPTY
10286: LIST
10287: LIST
10288: PPUSH
10289: CALL_OW 69
10293: NOT
10294: IFFALSE 10298
// exit ;
10296: GO 11192
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10298: LD_ADDR_VAR 0 4
10302: PUSH
10303: LD_INT 22
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PUSH
10313: LD_INT 30
10315: PUSH
10316: LD_INT 34
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PPUSH
10327: CALL_OW 69
10331: ST_TO_ADDR
// if Prob ( 40 ) then
10332: LD_INT 40
10334: PPUSH
10335: CALL_OW 13
10339: IFFALSE 10485
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10341: LD_INT 2
10343: PPUSH
10344: LD_INT 22
10346: PUSH
10347: LD_INT 3
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 49
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: PUSH
10362: LD_INT 22
10364: PUSH
10365: LD_INT 3
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 49
10373: PUSH
10374: EMPTY
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_INT 3
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 49
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: LIST
10396: LIST
10397: PUSH
10398: LD_INT 24
10400: PUSH
10401: LD_INT 3
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 46
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 24
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 46
10427: PUSH
10428: EMPTY
10429: LIST
10430: LIST
10431: LIST
10432: LIST
10433: PUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 3
10439: PUSH
10440: LD_INT 3
10442: PUSH
10443: LD_INT 46
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: LIST
10450: LIST
10451: PUSH
10452: LD_INT 24
10454: PUSH
10455: LD_INT 3
10457: PUSH
10458: LD_INT 3
10460: PUSH
10461: LD_INT 46
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: PPUSH
10479: CALL 61156 0 2
// end else
10483: GO 10627
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10485: LD_INT 2
10487: PPUSH
10488: LD_INT 24
10490: PUSH
10491: LD_INT 3
10493: PUSH
10494: LD_INT 3
10496: PUSH
10497: LD_INT 47
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 24
10508: PUSH
10509: LD_INT 3
10511: PUSH
10512: LD_INT 3
10514: PUSH
10515: LD_INT 47
10517: PUSH
10518: EMPTY
10519: LIST
10520: LIST
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 24
10526: PUSH
10527: LD_INT 3
10529: PUSH
10530: LD_INT 3
10532: PUSH
10533: LD_INT 47
10535: PUSH
10536: EMPTY
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: PUSH
10542: LD_INT 24
10544: PUSH
10545: LD_INT 3
10547: PUSH
10548: LD_INT 3
10550: PUSH
10551: LD_INT 46
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: PUSH
10560: LD_INT 24
10562: PUSH
10563: LD_INT 3
10565: PUSH
10566: LD_INT 3
10568: PUSH
10569: LD_INT 46
10571: PUSH
10572: EMPTY
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: PUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 3
10583: PUSH
10584: LD_INT 3
10586: PUSH
10587: LD_INT 46
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: PUSH
10596: LD_INT 24
10598: PUSH
10599: LD_INT 3
10601: PUSH
10602: LD_INT 3
10604: PUSH
10605: LD_INT 46
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL 61156 0 2
// end ; repeat wait ( 0 0$1 ) ;
10627: LD_INT 35
10629: PPUSH
10630: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10634: LD_INT 2
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: CALL 62574 0 2
10644: PUSH
10645: LD_INT 7
10647: GREATEREQUAL
10648: IFFALSE 10627
// wait ( 0 0$10 ) ;
10650: LD_INT 350
10652: PPUSH
10653: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10657: LD_ADDR_VAR 0 2
10661: PUSH
10662: LD_INT 2
10664: PPUSH
10665: LD_INT 1
10667: PPUSH
10668: CALL 62574 0 2
10672: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10673: LD_ADDR_EXP 119
10677: PUSH
10678: LD_EXP 119
10682: PPUSH
10683: LD_INT 2
10685: PPUSH
10686: LD_EXP 119
10690: PUSH
10691: LD_INT 2
10693: ARRAY
10694: PUSH
10695: LD_VAR 0 2
10699: DIFF
10700: PPUSH
10701: CALL_OW 1
10705: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10706: LD_ADDR_VAR 0 3
10710: PUSH
10711: LD_INT 0
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: CALL_OW 12
10721: ST_TO_ADDR
// if target then
10722: LD_VAR 0 3
10726: IFFALSE 10854
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10728: LD_ADDR_VAR 0 2
10732: PUSH
10733: LD_VAR 0 2
10737: PPUSH
10738: LD_INT 24
10740: PUSH
10741: LD_INT 250
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: PPUSH
10748: CALL_OW 72
10752: ST_TO_ADDR
// for i in tmp do
10753: LD_ADDR_VAR 0 1
10757: PUSH
10758: LD_VAR 0 2
10762: PUSH
10763: FOR_IN
10764: IFFALSE 10804
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10766: LD_VAR 0 1
10770: PPUSH
10771: LD_INT 139
10773: PPUSH
10774: LD_INT 89
10776: PPUSH
10777: CALL_OW 297
10781: PUSH
10782: LD_INT 9
10784: GREATER
10785: IFFALSE 10802
// ComMoveXY ( i , 139 , 89 ) ;
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 139
10794: PPUSH
10795: LD_INT 89
10797: PPUSH
10798: CALL_OW 111
10802: GO 10763
10804: POP
10805: POP
// wait ( 0 0$1 ) ;
10806: LD_INT 35
10808: PPUSH
10809: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10813: LD_VAR 0 2
10817: PPUSH
10818: LD_INT 92
10820: PUSH
10821: LD_INT 139
10823: PUSH
10824: LD_INT 89
10826: PUSH
10827: LD_INT 9
10829: PUSH
10830: EMPTY
10831: LIST
10832: LIST
10833: LIST
10834: LIST
10835: PPUSH
10836: CALL_OW 72
10840: PUSH
10841: LD_VAR 0 2
10845: PUSH
10846: LD_INT 1
10848: MINUS
10849: GREATEREQUAL
10850: IFFALSE 10728
// end else
10852: GO 10996
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10854: LD_VAR 0 2
10858: PPUSH
10859: LD_VAR 0 4
10863: PUSH
10864: LD_INT 1
10866: ARRAY
10867: PPUSH
10868: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10872: LD_ADDR_VAR 0 2
10876: PUSH
10877: LD_VAR 0 2
10881: PPUSH
10882: LD_INT 24
10884: PUSH
10885: LD_INT 250
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PPUSH
10892: CALL_OW 72
10896: ST_TO_ADDR
// for i in tmp do
10897: LD_ADDR_VAR 0 1
10901: PUSH
10902: LD_VAR 0 2
10906: PUSH
10907: FOR_IN
10908: IFFALSE 10948
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10910: LD_VAR 0 1
10914: PPUSH
10915: LD_INT 124
10917: PPUSH
10918: LD_INT 139
10920: PPUSH
10921: CALL_OW 297
10925: PUSH
10926: LD_INT 9
10928: GREATER
10929: IFFALSE 10946
// ComMoveXY ( i , 124 , 139 ) ;
10931: LD_VAR 0 1
10935: PPUSH
10936: LD_INT 124
10938: PPUSH
10939: LD_INT 139
10941: PPUSH
10942: CALL_OW 111
10946: GO 10907
10948: POP
10949: POP
// wait ( 0 0$1 ) ;
10950: LD_INT 35
10952: PPUSH
10953: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: LD_INT 92
10964: PUSH
10965: LD_INT 124
10967: PUSH
10968: LD_INT 139
10970: PUSH
10971: LD_INT 9
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: PPUSH
10980: CALL_OW 72
10984: PUSH
10985: LD_VAR 0 2
10989: PUSH
10990: LD_INT 1
10992: MINUS
10993: GREATEREQUAL
10994: IFFALSE 10872
// end ; repeat wait ( 0 0$1 ) ;
10996: LD_INT 35
10998: PPUSH
10999: CALL_OW 67
// for i in tmp do
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_VAR 0 2
11012: PUSH
11013: FOR_IN
11014: IFFALSE 11183
// begin if GetLives ( i ) > 251 then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 256
11025: PUSH
11026: LD_INT 251
11028: GREATER
11029: IFFALSE 11154
// begin if GetWeapon ( i ) = ru_time_lapser then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 264
11040: PUSH
11041: LD_INT 49
11043: EQUAL
11044: IFFALSE 11100
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11046: LD_VAR 0 1
11050: PPUSH
11051: LD_INT 2
11053: PUSH
11054: LD_INT 22
11056: PUSH
11057: LD_INT 1
11059: PUSH
11060: EMPTY
11061: LIST
11062: LIST
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 8
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: LIST
11078: PPUSH
11079: CALL_OW 69
11083: PPUSH
11084: LD_VAR 0 1
11088: PPUSH
11089: CALL_OW 74
11093: PPUSH
11094: CALL_OW 112
11098: GO 11152
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11100: LD_VAR 0 1
11104: PPUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 22
11110: PUSH
11111: LD_INT 1
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: LD_INT 22
11120: PUSH
11121: LD_INT 8
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: LIST
11132: PPUSH
11133: CALL_OW 69
11137: PPUSH
11138: LD_VAR 0 1
11142: PPUSH
11143: CALL_OW 74
11147: PPUSH
11148: CALL_OW 115
// end else
11152: GO 11181
// if IsDead ( i ) then
11154: LD_VAR 0 1
11158: PPUSH
11159: CALL_OW 301
11163: IFFALSE 11181
// tmp := tmp diff i ;
11165: LD_ADDR_VAR 0 2
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_VAR 0 1
11179: DIFF
11180: ST_TO_ADDR
// end ;
11181: GO 11013
11183: POP
11184: POP
// until not tmp ;
11185: LD_VAR 0 2
11189: NOT
11190: IFFALSE 10996
// end ;
11192: PPOPN 4
11194: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11195: LD_EXP 15
11199: PUSH
11200: LD_INT 8
11202: GREATEREQUAL
11203: PUSH
11204: LD_OWVAR 67
11208: PUSH
11209: LD_INT 1
11211: GREATER
11212: AND
11213: IFFALSE 11397
11215: GO 11217
11217: DISABLE
11218: LD_INT 0
11220: PPUSH
11221: PPUSH
11222: PPUSH
// begin ruMobile := [ ] ;
11223: LD_ADDR_EXP 76
11227: PUSH
11228: EMPTY
11229: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11230: LD_ADDR_VAR 0 1
11234: PUSH
11235: DOUBLE
11236: LD_INT 1
11238: DEC
11239: ST_TO_ADDR
11240: LD_INT 3
11242: PUSH
11243: LD_INT 4
11245: PUSH
11246: LD_INT 5
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: LIST
11253: PUSH
11254: LD_OWVAR 67
11258: PUSH
11259: LD_INT 1
11261: MINUS
11262: ARRAY
11263: PUSH
11264: FOR_TO
11265: IFFALSE 11395
// begin uc_side := 3 ;
11267: LD_ADDR_OWVAR 20
11271: PUSH
11272: LD_INT 3
11274: ST_TO_ADDR
// uc_nation := 3 ;
11275: LD_ADDR_OWVAR 21
11279: PUSH
11280: LD_INT 3
11282: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11283: LD_INT 21
11285: PPUSH
11286: LD_INT 3
11288: PPUSH
11289: LD_INT 1
11291: PPUSH
11292: LD_INT 45
11294: PPUSH
11295: LD_INT 100
11297: PPUSH
11298: CALL 72597 0 5
// veh := CreateVehicle ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: CALL_OW 45
11311: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11312: LD_VAR 0 2
11316: PPUSH
11317: LD_INT 3
11319: PPUSH
11320: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11324: LD_VAR 0 2
11328: PPUSH
11329: LD_INT 29
11331: PPUSH
11332: LD_INT 0
11334: PPUSH
11335: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11339: LD_INT 0
11341: PPUSH
11342: LD_INT 10
11344: PPUSH
11345: CALL_OW 383
// un := CreateHuman ;
11349: LD_ADDR_VAR 0 3
11353: PUSH
11354: CALL_OW 44
11358: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11359: LD_VAR 0 3
11363: PPUSH
11364: LD_VAR 0 2
11368: PPUSH
11369: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11373: LD_ADDR_EXP 76
11377: PUSH
11378: LD_EXP 76
11382: PPUSH
11383: LD_VAR 0 2
11387: PPUSH
11388: CALL 105050 0 2
11392: ST_TO_ADDR
// end ;
11393: GO 11264
11395: POP
11396: POP
// end ;
11397: PPOPN 3
11399: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11400: LD_EXP 76
11404: IFFALSE 11912
11406: GO 11408
11408: DISABLE
11409: LD_INT 0
11411: PPUSH
11412: PPUSH
11413: PPUSH
// begin enable ;
11414: ENABLE
// if not ruMobile then
11415: LD_EXP 76
11419: NOT
11420: IFFALSE 11424
// exit ;
11422: GO 11912
// for i in ruMobile do
11424: LD_ADDR_VAR 0 1
11428: PUSH
11429: LD_EXP 76
11433: PUSH
11434: FOR_IN
11435: IFFALSE 11910
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11437: LD_VAR 0 1
11441: PPUSH
11442: CALL_OW 302
11446: NOT
11447: PUSH
11448: LD_VAR 0 1
11452: PPUSH
11453: CALL_OW 255
11457: PUSH
11458: LD_INT 3
11460: NONEQUAL
11461: OR
11462: IFFALSE 11482
// begin ruMobile := ruMobile diff i ;
11464: LD_ADDR_EXP 76
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_VAR 0 1
11478: DIFF
11479: ST_TO_ADDR
// continue ;
11480: GO 11434
// end ; if GetTag ( i ) = 300 then
11482: LD_VAR 0 1
11486: PPUSH
11487: CALL_OW 110
11491: PUSH
11492: LD_INT 300
11494: EQUAL
11495: IFFALSE 11545
// begin ComMoveXY ( i , 160 , 81 ) ;
11497: LD_VAR 0 1
11501: PPUSH
11502: LD_INT 160
11504: PPUSH
11505: LD_INT 81
11507: PPUSH
11508: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11512: LD_VAR 0 1
11516: PPUSH
11517: LD_INT 160
11519: PPUSH
11520: LD_INT 81
11522: PPUSH
11523: CALL_OW 297
11527: PUSH
11528: LD_INT 8
11530: LESS
11531: IFFALSE 11545
// SetTag ( i , 301 ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: LD_INT 301
11540: PPUSH
11541: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 110
11554: PUSH
11555: LD_INT 301
11557: EQUAL
11558: IFFALSE 11601
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11560: LD_VAR 0 1
11564: PPUSH
11565: LD_INT 33
11567: PPUSH
11568: CALL_OW 308
11572: NOT
11573: IFFALSE 11589
// ComMoveToArea ( i , ruMobileParkingArea ) else
11575: LD_VAR 0 1
11579: PPUSH
11580: LD_INT 33
11582: PPUSH
11583: CALL_OW 113
11587: GO 11601
// SetTag ( i , 302 ) ;
11589: LD_VAR 0 1
11593: PPUSH
11594: LD_INT 302
11596: PPUSH
11597: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11601: LD_VAR 0 1
11605: PPUSH
11606: CALL_OW 110
11610: PUSH
11611: LD_INT 302
11613: EQUAL
11614: IFFALSE 11744
// begin if GetLives ( i ) < 1000 then
11616: LD_VAR 0 1
11620: PPUSH
11621: CALL_OW 256
11625: PUSH
11626: LD_INT 1000
11628: LESS
11629: IFFALSE 11721
// begin if not IsDrivenBy ( i ) then
11631: LD_VAR 0 1
11635: PPUSH
11636: CALL_OW 311
11640: NOT
11641: IFFALSE 11645
// continue ;
11643: GO 11434
// mech := IsDrivenBy ( i ) ;
11645: LD_ADDR_VAR 0 2
11649: PUSH
11650: LD_VAR 0 1
11654: PPUSH
11655: CALL_OW 311
11659: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11660: LD_VAR 0 2
11664: PPUSH
11665: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_VAR 0 1
11678: PPUSH
11679: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11683: LD_INT 35
11685: PPUSH
11686: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11690: LD_VAR 0 1
11694: PPUSH
11695: CALL_OW 256
11699: PUSH
11700: LD_INT 1000
11702: EQUAL
11703: IFFALSE 11683
// ComEnterUnit ( mech , i ) ;
11705: LD_VAR 0 2
11709: PPUSH
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 120
// end else
11719: GO 11744
// if IsDrivenBy ( i ) then
11721: LD_VAR 0 1
11725: PPUSH
11726: CALL_OW 311
11730: IFFALSE 11744
// SetTag ( i , 0 ) ;
11732: LD_VAR 0 1
11736: PPUSH
11737: LD_INT 0
11739: PPUSH
11740: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11744: LD_VAR 0 1
11748: PPUSH
11749: CALL_OW 110
11753: PUSH
11754: LD_INT 300
11756: LESS
11757: IFFALSE 11908
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_INT 4
11766: PPUSH
11767: LD_INT 81
11769: PUSH
11770: LD_INT 3
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: PPUSH
11777: CALL_OW 70
11781: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11782: LD_VAR 0 1
11786: PPUSH
11787: CALL_OW 256
11791: PUSH
11792: LD_INT 650
11794: LESS
11795: IFFALSE 11820
// begin ComStop ( i ) ;
11797: LD_VAR 0 1
11801: PPUSH
11802: CALL_OW 141
// SetTag ( i , 300 ) ;
11806: LD_VAR 0 1
11810: PPUSH
11811: LD_INT 300
11813: PPUSH
11814: CALL_OW 109
// continue ;
11818: GO 11434
// end ; if enemy then
11820: LD_VAR 0 3
11824: IFFALSE 11864
// begin if not HasTask ( i ) then
11826: LD_VAR 0 1
11830: PPUSH
11831: CALL_OW 314
11835: NOT
11836: IFFALSE 11862
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11838: LD_VAR 0 1
11842: PPUSH
11843: LD_VAR 0 3
11847: PPUSH
11848: LD_VAR 0 1
11852: PPUSH
11853: CALL_OW 74
11857: PPUSH
11858: CALL_OW 115
// end else
11862: GO 11908
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11864: LD_VAR 0 1
11868: PPUSH
11869: LD_INT 158
11871: PUSH
11872: LD_INT 61
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: PUSH
11879: LD_INT 98
11881: PUSH
11882: LD_INT 100
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PUSH
11889: LD_INT 78
11891: PUSH
11892: LD_INT 93
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: PUSH
11899: EMPTY
11900: LIST
11901: LIST
11902: LIST
11903: PPUSH
11904: CALL 107654 0 2
// end ; end ;
11908: GO 11434
11910: POP
11911: POP
// end ; end_of_file
11912: PPOPN 3
11914: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11915: LD_INT 0
11917: PPUSH
11918: PPUSH
11919: PPUSH
11920: PPUSH
11921: PPUSH
11922: PPUSH
// side := 7 ;
11923: LD_ADDR_VAR 0 5
11927: PUSH
11928: LD_INT 7
11930: ST_TO_ADDR
// uc_side := side ;
11931: LD_ADDR_OWVAR 20
11935: PUSH
11936: LD_VAR 0 5
11940: ST_TO_ADDR
// uc_nation := 1 ;
11941: LD_ADDR_OWVAR 21
11945: PUSH
11946: LD_INT 1
11948: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11949: LD_ADDR_VAR 0 2
11953: PUSH
11954: LD_INT 22
11956: PUSH
11957: LD_VAR 0 5
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PUSH
11966: LD_INT 21
11968: PUSH
11969: LD_INT 3
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: EMPTY
11977: LIST
11978: LIST
11979: PPUSH
11980: CALL_OW 69
11984: PUSH
11985: FOR_IN
11986: IFFALSE 12002
// SetBLevel ( i , 10 ) ;
11988: LD_VAR 0 2
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 241
12000: GO 11985
12002: POP
12003: POP
// base := GetBase ( al_depot ) ;
12004: LD_ADDR_VAR 0 4
12008: PUSH
12009: LD_INT 2
12011: PPUSH
12012: CALL_OW 274
12016: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12017: LD_ADDR_VAR 0 6
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_VAR 0 5
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: LD_INT 30
12036: PUSH
12037: LD_INT 34
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PPUSH
12048: CALL_OW 69
12052: ST_TO_ADDR
// if teleport then
12053: LD_VAR 0 6
12057: IFFALSE 12078
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12059: LD_VAR 0 6
12063: PUSH
12064: LD_INT 1
12066: ARRAY
12067: PPUSH
12068: LD_INT 262
12070: PPUSH
12071: LD_INT 119
12073: PPUSH
12074: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12078: LD_VAR 0 4
12082: PPUSH
12083: LD_INT 1
12085: PPUSH
12086: LD_INT 19500
12088: PPUSH
12089: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12093: LD_VAR 0 4
12097: PPUSH
12098: LD_INT 2
12100: PPUSH
12101: LD_INT 200
12103: PPUSH
12104: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12108: LD_VAR 0 4
12112: PPUSH
12113: LD_INT 3
12115: PPUSH
12116: LD_INT 650
12118: PPUSH
12119: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12123: LD_ADDR_EXP 77
12127: PUSH
12128: LD_STRING Roth
12130: PPUSH
12131: CALL_OW 25
12135: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12136: LD_ADDR_EXP 78
12140: PUSH
12141: LD_STRING Simms
12143: PPUSH
12144: LD_EXP 1
12148: NOT
12149: PPUSH
12150: LD_STRING 10c_
12152: PPUSH
12153: CALL 67582 0 3
12157: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12158: LD_EXP 78
12162: PPUSH
12163: LD_INT 4
12165: PPUSH
12166: CALL_OW 336
// if not Simms then
12170: LD_EXP 78
12174: NOT
12175: IFFALSE 12205
// begin uc_nation := 1 ;
12177: LD_ADDR_OWVAR 21
12181: PUSH
12182: LD_INT 1
12184: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12185: LD_INT 2
12187: PPUSH
12188: LD_INT 10
12190: PPUSH
12191: CALL_OW 384
// Simms := CreateHuman ;
12195: LD_ADDR_EXP 78
12199: PUSH
12200: CALL_OW 44
12204: ST_TO_ADDR
// end ; uc_nation := 3 ;
12205: LD_ADDR_OWVAR 21
12209: PUSH
12210: LD_INT 3
12212: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12213: LD_ADDR_EXP 79
12217: PUSH
12218: LD_STRING Kirilenkova
12220: PPUSH
12221: CALL_OW 25
12225: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12226: LD_ADDR_EXP 93
12230: PUSH
12231: LD_STRING Oblukov
12233: PPUSH
12234: CALL_OW 25
12238: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12239: LD_ADDR_EXP 80
12243: PUSH
12244: LD_STRING Dolgov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12252: LD_ADDR_EXP 81
12256: PUSH
12257: LD_STRING Petrosyan
12259: PPUSH
12260: CALL_OW 25
12264: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12265: LD_ADDR_EXP 92
12269: PUSH
12270: LD_STRING Scholtze
12272: PPUSH
12273: CALL_OW 25
12277: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12278: LD_ADDR_EXP 91
12282: PUSH
12283: LD_STRING Kapitsova
12285: PPUSH
12286: CALL_OW 25
12290: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12291: LD_ADDR_EXP 82
12295: PUSH
12296: LD_STRING Petrovova
12298: PPUSH
12299: CALL_OW 25
12303: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12304: LD_ADDR_EXP 83
12308: PUSH
12309: LD_STRING Kuzmov
12311: PPUSH
12312: CALL_OW 25
12316: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12317: LD_ADDR_EXP 90
12321: PUSH
12322: LD_STRING Karamazov
12324: PPUSH
12325: CALL_OW 25
12329: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12330: LD_STRING 13_Lipshchin_1
12332: PPUSH
12333: LD_INT 0
12335: PPUSH
12336: CALL_OW 30
12340: IFFALSE 12355
// Lipshchin := NewCharacter ( Lipshchin ) ;
12342: LD_ADDR_EXP 84
12346: PUSH
12347: LD_STRING Lipshchin
12349: PPUSH
12350: CALL_OW 25
12354: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12355: LD_STRING 13_Titov_1
12357: PPUSH
12358: LD_INT 0
12360: PPUSH
12361: CALL_OW 30
12365: IFFALSE 12380
// Titov := NewCharacter ( Titov ) ;
12367: LD_ADDR_EXP 86
12371: PUSH
12372: LD_STRING Titov
12374: PPUSH
12375: CALL_OW 25
12379: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12380: LD_STRING 13_Gnyevko_1
12382: PPUSH
12383: LD_INT 0
12385: PPUSH
12386: CALL_OW 30
12390: IFFALSE 12405
// Gnyevko := NewCharacter ( Gnyevko ) ;
12392: LD_ADDR_EXP 85
12396: PUSH
12397: LD_STRING Gnyevko
12399: PPUSH
12400: CALL_OW 25
12404: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12405: LD_STRING 13_Xavier_1
12407: PPUSH
12408: LD_INT 0
12410: PPUSH
12411: CALL_OW 30
12415: IFFALSE 12430
// Xavier := NewCharacter ( Xavier2 ) ;
12417: LD_ADDR_EXP 87
12421: PUSH
12422: LD_STRING Xavier2
12424: PPUSH
12425: CALL_OW 25
12429: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12430: LD_STRING 13_Belkov_1
12432: PPUSH
12433: LD_INT 0
12435: PPUSH
12436: CALL_OW 30
12440: IFFALSE 12455
// Belkov := NewCharacter ( Belkov ) ;
12442: LD_ADDR_EXP 88
12446: PUSH
12447: LD_STRING Belkov
12449: PPUSH
12450: CALL_OW 25
12454: ST_TO_ADDR
// if not BurlakStatus then
12455: LD_EXP 9
12459: NOT
12460: IFFALSE 12475
// Burlak = NewCharacter ( Burlak ) ;
12462: LD_ADDR_EXP 89
12466: PUSH
12467: LD_STRING Burlak
12469: PPUSH
12470: CALL_OW 25
12474: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12475: LD_ADDR_VAR 0 3
12479: PUSH
12480: LD_EXP 77
12484: PUSH
12485: LD_EXP 79
12489: PUSH
12490: LD_EXP 93
12494: PUSH
12495: LD_EXP 80
12499: PUSH
12500: LD_EXP 81
12504: PUSH
12505: LD_EXP 92
12509: PUSH
12510: LD_EXP 91
12514: PUSH
12515: LD_EXP 82
12519: PUSH
12520: LD_EXP 83
12524: PUSH
12525: LD_EXP 90
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: ST_TO_ADDR
// if Simms then
12542: LD_EXP 78
12546: IFFALSE 12564
// tmp := tmp ^ Simms ;
12548: LD_ADDR_VAR 0 3
12552: PUSH
12553: LD_VAR 0 3
12557: PUSH
12558: LD_EXP 78
12562: ADD
12563: ST_TO_ADDR
// if Titov then
12564: LD_EXP 86
12568: IFFALSE 12586
// tmp := tmp ^ Titov ;
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_VAR 0 3
12579: PUSH
12580: LD_EXP 86
12584: ADD
12585: ST_TO_ADDR
// if Lipshchin then
12586: LD_EXP 84
12590: IFFALSE 12608
// tmp := tmp ^ Lipshchin ;
12592: LD_ADDR_VAR 0 3
12596: PUSH
12597: LD_VAR 0 3
12601: PUSH
12602: LD_EXP 84
12606: ADD
12607: ST_TO_ADDR
// if Gnyevko then
12608: LD_EXP 85
12612: IFFALSE 12630
// tmp := tmp ^ Gnyevko ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_VAR 0 3
12623: PUSH
12624: LD_EXP 85
12628: ADD
12629: ST_TO_ADDR
// if Xavier then
12630: LD_EXP 87
12634: IFFALSE 12652
// tmp := tmp ^ Xavier ;
12636: LD_ADDR_VAR 0 3
12640: PUSH
12641: LD_VAR 0 3
12645: PUSH
12646: LD_EXP 87
12650: ADD
12651: ST_TO_ADDR
// if Belkov then
12652: LD_EXP 88
12656: IFFALSE 12674
// tmp := tmp ^ Belkov ;
12658: LD_ADDR_VAR 0 3
12662: PUSH
12663: LD_VAR 0 3
12667: PUSH
12668: LD_EXP 88
12672: ADD
12673: ST_TO_ADDR
// if Burlak then
12674: LD_EXP 89
12678: IFFALSE 12696
// tmp := tmp ^ Burlak ;
12680: LD_ADDR_VAR 0 3
12684: PUSH
12685: LD_VAR 0 3
12689: PUSH
12690: LD_EXP 89
12694: ADD
12695: ST_TO_ADDR
// for i = 1 to 11 do
12696: LD_ADDR_VAR 0 2
12700: PUSH
12701: DOUBLE
12702: LD_INT 1
12704: DEC
12705: ST_TO_ADDR
12706: LD_INT 11
12708: PUSH
12709: FOR_TO
12710: IFFALSE 12776
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12712: LD_ADDR_OWVAR 21
12716: PUSH
12717: LD_INT 1
12719: PUSH
12720: LD_INT 3
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 1
12729: PPUSH
12730: LD_INT 2
12732: PPUSH
12733: CALL_OW 12
12737: ARRAY
12738: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12739: LD_INT 0
12741: PPUSH
12742: LD_VAR 0 2
12746: PUSH
12747: LD_INT 2
12749: DIV
12750: PPUSH
12751: LD_INT 10
12753: PPUSH
12754: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 3
12767: PUSH
12768: CALL_OW 44
12772: ADD
12773: ST_TO_ADDR
// end ;
12774: GO 12709
12776: POP
12777: POP
// for i in tmp do
12778: LD_ADDR_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: FOR_IN
12789: IFFALSE 12814
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12791: LD_VAR 0 2
12795: PPUSH
12796: LD_INT 260
12798: PPUSH
12799: LD_INT 235
12801: PPUSH
12802: LD_INT 8
12804: PPUSH
12805: LD_INT 0
12807: PPUSH
12808: CALL_OW 50
12812: GO 12788
12814: POP
12815: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12816: LD_ADDR_EXP 100
12820: PUSH
12821: LD_EXP 100
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: LD_INT 22
12831: PUSH
12832: LD_VAR 0 5
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 3
12843: PUSH
12844: LD_INT 21
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: EMPTY
12851: LIST
12852: LIST
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: PUSH
12867: LD_EXP 77
12871: PUSH
12872: LD_EXP 78
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: DIFF
12881: PPUSH
12882: CALL_OW 1
12886: ST_TO_ADDR
// uc_side := 0 ;
12887: LD_ADDR_OWVAR 20
12891: PUSH
12892: LD_INT 0
12894: ST_TO_ADDR
// uc_nation := 0 ;
12895: LD_ADDR_OWVAR 21
12899: PUSH
12900: LD_INT 0
12902: ST_TO_ADDR
// for i = 1 to 5 do
12903: LD_ADDR_VAR 0 2
12907: PUSH
12908: DOUBLE
12909: LD_INT 1
12911: DEC
12912: ST_TO_ADDR
12913: LD_INT 5
12915: PUSH
12916: FOR_TO
12917: IFFALSE 12954
// begin InitHc ;
12919: CALL_OW 19
// hc_class := class_apeman ;
12923: LD_ADDR_OWVAR 28
12927: PUSH
12928: LD_INT 12
12930: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12931: CALL_OW 44
12935: PPUSH
12936: LD_INT 299
12938: PPUSH
12939: LD_INT 229
12941: PPUSH
12942: LD_INT 10
12944: PPUSH
12945: LD_INT 0
12947: PPUSH
12948: CALL_OW 50
// end ;
12952: GO 12916
12954: POP
12955: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12956: LD_EXP 77
12960: PPUSH
12961: LD_INT 259
12963: PPUSH
12964: LD_INT 235
12966: PPUSH
12967: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12971: LD_EXP 77
12975: PPUSH
12976: LD_INT 262
12978: PPUSH
12979: LD_INT 235
12981: PPUSH
12982: CALL_OW 178
// if Simms then
12986: LD_EXP 78
12990: IFFALSE 13021
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12992: LD_EXP 78
12996: PPUSH
12997: LD_INT 262
12999: PPUSH
13000: LD_INT 235
13002: PPUSH
13003: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13007: LD_EXP 78
13011: PPUSH
13012: LD_EXP 77
13016: PPUSH
13017: CALL_OW 179
// end ; end ;
13021: LD_VAR 0 1
13025: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13026: LD_EXP 31
13030: PUSH
13031: LD_EXP 23
13035: NOT
13036: AND
13037: IFFALSE 13265
13039: GO 13041
13041: DISABLE
13042: LD_INT 0
13044: PPUSH
13045: PPUSH
13046: PPUSH
// begin enable ;
13047: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13048: LD_ADDR_VAR 0 2
13052: PUSH
13053: LD_INT 81
13055: PUSH
13056: LD_INT 7
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 2
13065: PUSH
13066: LD_INT 32
13068: PUSH
13069: LD_INT 3
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PUSH
13076: LD_INT 30
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: PUSH
13086: LD_INT 30
13088: PUSH
13089: LD_INT 28
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: PUSH
13096: LD_INT 34
13098: PUSH
13099: LD_INT 49
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PUSH
13106: LD_INT 34
13108: PUSH
13109: LD_INT 10
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: PUSH
13116: LD_INT 34
13118: PUSH
13119: LD_INT 8
13121: PUSH
13122: EMPTY
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: PPUSH
13139: CALL_OW 69
13143: ST_TO_ADDR
// if not tmp then
13144: LD_VAR 0 2
13148: NOT
13149: IFFALSE 13153
// exit ;
13151: GO 13265
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 34
13160: PUSH
13161: LD_INT 8
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PPUSH
13168: CALL_OW 72
13172: IFFALSE 13205
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13174: LD_ADDR_VAR 0 3
13178: PUSH
13179: LD_VAR 0 2
13183: PPUSH
13184: LD_INT 34
13186: PUSH
13187: LD_INT 8
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: PPUSH
13194: CALL_OW 72
13198: PUSH
13199: LD_INT 1
13201: ARRAY
13202: ST_TO_ADDR
13203: GO 13229
// target := tmp [ rand ( 1 , tmp ) ] ;
13205: LD_ADDR_VAR 0 3
13209: PUSH
13210: LD_VAR 0 2
13214: PUSH
13215: LD_INT 1
13217: PPUSH
13218: LD_VAR 0 2
13222: PPUSH
13223: CALL_OW 12
13227: ARRAY
13228: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13229: LD_VAR 0 3
13233: PPUSH
13234: CALL_OW 255
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13253
// CenterNowOnUnits ( target ) ;
13244: LD_VAR 0 3
13248: PPUSH
13249: CALL_OW 87
// SetLives ( target , 0 ) ;
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_INT 0
13260: PPUSH
13261: CALL_OW 234
// end ;
13265: PPOPN 3
13267: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13268: LD_EXP 23
13272: NOT
13273: PUSH
13274: LD_EXP 31
13278: AND
13279: IFFALSE 13805
13281: GO 13283
13283: DISABLE
13284: LD_INT 0
13286: PPUSH
13287: PPUSH
13288: PPUSH
// begin uc_side := 7 ;
13289: LD_ADDR_OWVAR 20
13293: PUSH
13294: LD_INT 7
13296: ST_TO_ADDR
// uc_nation := 1 ;
13297: LD_ADDR_OWVAR 21
13301: PUSH
13302: LD_INT 1
13304: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13305: LD_ADDR_VAR 0 3
13309: PUSH
13310: LD_INT 125
13312: PUSH
13313: LD_INT 163
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PUSH
13320: LD_INT 185
13322: PUSH
13323: LD_INT 168
13325: PUSH
13326: EMPTY
13327: LIST
13328: LIST
13329: PUSH
13330: LD_INT 111
13332: PUSH
13333: LD_INT 97
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: PPUSH
13345: CALL 105155 0 1
13349: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13350: LD_ADDR_EXP 94
13354: PUSH
13355: EMPTY
13356: ST_TO_ADDR
// for i = 1 to Difficulty do
13357: LD_ADDR_VAR 0 1
13361: PUSH
13362: DOUBLE
13363: LD_INT 1
13365: DEC
13366: ST_TO_ADDR
13367: LD_OWVAR 67
13371: PUSH
13372: FOR_TO
13373: IFFALSE 13531
// begin InitHc ;
13375: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13379: LD_INT 0
13381: PPUSH
13382: LD_INT 8
13384: PPUSH
13385: CALL_OW 381
// un := CreateHuman ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: CALL_OW 44
13398: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13399: LD_VAR 0 2
13403: PPUSH
13404: LD_INT 258
13406: PPUSH
13407: LD_INT 267
13409: PPUSH
13410: LD_INT 4
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13420: LD_ADDR_EXP 94
13424: PUSH
13425: LD_EXP 94
13429: PUSH
13430: LD_VAR 0 2
13434: UNION
13435: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13436: LD_VAR 0 2
13440: PPUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 1
13450: ARRAY
13451: PUSH
13452: LD_INT 1
13454: ARRAY
13455: PPUSH
13456: LD_VAR 0 3
13460: PUSH
13461: LD_VAR 0 1
13465: ARRAY
13466: PUSH
13467: LD_INT 2
13469: ARRAY
13470: PPUSH
13471: LD_INT 4
13473: PPUSH
13474: LD_INT 1
13476: PPUSH
13477: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13481: LD_VAR 0 2
13485: PPUSH
13486: LD_VAR 0 3
13490: PUSH
13491: LD_VAR 0 1
13495: ARRAY
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: PPUSH
13501: LD_VAR 0 3
13505: PUSH
13506: LD_VAR 0 1
13510: ARRAY
13511: PUSH
13512: LD_INT 2
13514: ARRAY
13515: PPUSH
13516: CALL_OW 171
// AddComInvisible ( un ) ;
13520: LD_VAR 0 2
13524: PPUSH
13525: CALL_OW 212
// end ;
13529: GO 13372
13531: POP
13532: POP
// repeat wait ( 0 0$20 ) ;
13533: LD_INT 700
13535: PPUSH
13536: CALL_OW 67
// for i in allianceSpecialForce do
13540: LD_ADDR_VAR 0 1
13544: PUSH
13545: LD_EXP 94
13549: PUSH
13550: FOR_IN
13551: IFFALSE 13790
// begin if IsInvisible ( i ) then
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 571
13562: IFFALSE 13759
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 22
13571: PUSH
13572: LD_INT 1
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 50
13581: PUSH
13582: EMPTY
13583: LIST
13584: PUSH
13585: LD_INT 56
13587: PUSH
13588: EMPTY
13589: LIST
13590: PUSH
13591: LD_INT 91
13593: PUSH
13594: LD_VAR 0 1
13598: PUSH
13599: LD_INT 25
13601: PUSH
13602: LD_INT 30
13604: PUSH
13605: LD_INT 35
13607: PUSH
13608: LD_INT 40
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: PUSH
13617: LD_OWVAR 67
13621: ARRAY
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PUSH
13628: LD_INT 2
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 1
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 3
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 25
13663: PUSH
13664: LD_INT 4
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: LD_INT 25
13673: PUSH
13674: LD_INT 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 25
13683: PUSH
13684: LD_INT 8
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PPUSH
13707: CALL_OW 69
13711: ST_TO_ADDR
// if not tmp then
13712: LD_VAR 0 3
13716: NOT
13717: IFFALSE 13721
// continue ;
13719: GO 13550
// if Prob ( 30 * Difficulty ) then
13721: LD_INT 30
13723: PUSH
13724: LD_OWVAR 67
13728: MUL
13729: PPUSH
13730: CALL_OW 13
13734: IFFALSE 13759
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13736: LD_VAR 0 3
13740: PUSH
13741: LD_INT 1
13743: PPUSH
13744: LD_VAR 0 3
13748: PPUSH
13749: CALL_OW 12
13753: ARRAY
13754: PPUSH
13755: CALL 32858 0 1
// end ; if IsDead ( i ) then
13759: LD_VAR 0 1
13763: PPUSH
13764: CALL_OW 301
13768: IFFALSE 13788
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13770: LD_ADDR_EXP 94
13774: PUSH
13775: LD_EXP 94
13779: PUSH
13780: LD_VAR 0 1
13784: DIFF
13785: ST_TO_ADDR
// continue ;
13786: GO 13550
// end ; end ;
13788: GO 13550
13790: POP
13791: POP
// until allianceDestroyed or not allianceSpecialForce ;
13792: LD_EXP 23
13796: PUSH
13797: LD_EXP 94
13801: NOT
13802: OR
13803: IFFALSE 13533
// end ;
13805: PPOPN 3
13807: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13808: LD_EXP 23
13812: NOT
13813: PUSH
13814: LD_EXP 31
13818: AND
13819: IFFALSE 14769
13821: GO 13823
13823: DISABLE
13824: LD_INT 0
13826: PPUSH
13827: PPUSH
13828: PPUSH
13829: PPUSH
// begin enable ;
13830: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13831: LD_INT 22
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: EMPTY
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 3
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PPUSH
13855: CALL_OW 69
13859: NOT
13860: IFFALSE 13864
// exit ;
13862: GO 14769
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13864: LD_ADDR_VAR 0 4
13868: PUSH
13869: LD_INT 22
13871: PUSH
13872: LD_INT 7
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: PUSH
13879: LD_INT 30
13881: PUSH
13882: LD_INT 34
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: PUSH
13889: EMPTY
13890: LIST
13891: LIST
13892: PPUSH
13893: CALL_OW 69
13897: ST_TO_ADDR
// if Prob ( 40 ) then
13898: LD_INT 40
13900: PPUSH
13901: CALL_OW 13
13905: IFFALSE 14051
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13907: LD_INT 1
13909: PPUSH
13910: LD_INT 5
13912: PUSH
13913: LD_INT 3
13915: PUSH
13916: LD_INT 2
13918: PUSH
13919: LD_INT 6
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: PUSH
13928: LD_INT 5
13930: PUSH
13931: LD_INT 3
13933: PUSH
13934: LD_INT 2
13936: PUSH
13937: LD_INT 6
13939: PUSH
13940: EMPTY
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 5
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: LD_INT 2
13954: PUSH
13955: LD_INT 6
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 5
13966: PUSH
13967: LD_INT 3
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 9
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: PUSH
13982: LD_INT 24
13984: PUSH
13985: LD_INT 3
13987: PUSH
13988: LD_INT 3
13990: PUSH
13991: LD_INT 45
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 24
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: LD_INT 3
14008: PUSH
14009: LD_INT 47
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: PUSH
14018: LD_INT 24
14020: PUSH
14021: LD_INT 3
14023: PUSH
14024: LD_INT 3
14026: PUSH
14027: LD_INT 45
14029: PUSH
14030: EMPTY
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: PPUSH
14045: CALL 61156 0 2
// end else
14049: GO 14193
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14051: LD_INT 1
14053: PPUSH
14054: LD_INT 24
14056: PUSH
14057: LD_INT 3
14059: PUSH
14060: LD_INT 3
14062: PUSH
14063: LD_INT 47
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: PUSH
14072: LD_INT 24
14074: PUSH
14075: LD_INT 3
14077: PUSH
14078: LD_INT 3
14080: PUSH
14081: LD_INT 47
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 5
14092: PUSH
14093: LD_INT 3
14095: PUSH
14096: LD_INT 2
14098: PUSH
14099: LD_INT 9
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: PUSH
14108: LD_INT 5
14110: PUSH
14111: LD_INT 3
14113: PUSH
14114: LD_INT 2
14116: PUSH
14117: LD_INT 9
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PUSH
14126: LD_INT 5
14128: PUSH
14129: LD_INT 3
14131: PUSH
14132: LD_INT 2
14134: PUSH
14135: LD_INT 9
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: LD_INT 1
14149: PUSH
14150: LD_INT 3
14152: PUSH
14153: LD_INT 45
14155: PUSH
14156: EMPTY
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 24
14164: PUSH
14165: LD_INT 1
14167: PUSH
14168: LD_INT 3
14170: PUSH
14171: LD_INT 45
14173: PUSH
14174: EMPTY
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: PPUSH
14189: CALL 61156 0 2
// end ; repeat wait ( 0 0$1 ) ;
14193: LD_INT 35
14195: PPUSH
14196: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14200: LD_INT 1
14202: PPUSH
14203: LD_INT 1
14205: PPUSH
14206: CALL 62574 0 2
14210: PUSH
14211: LD_INT 7
14213: GREATEREQUAL
14214: IFFALSE 14193
// wait ( 0 0$10 ) ;
14216: LD_INT 350
14218: PPUSH
14219: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14223: LD_ADDR_VAR 0 2
14227: PUSH
14228: LD_INT 1
14230: PPUSH
14231: LD_INT 1
14233: PPUSH
14234: CALL 62574 0 2
14238: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14239: LD_ADDR_EXP 119
14243: PUSH
14244: LD_EXP 119
14248: PPUSH
14249: LD_INT 1
14251: PPUSH
14252: LD_EXP 119
14256: PUSH
14257: LD_INT 1
14259: ARRAY
14260: PUSH
14261: LD_VAR 0 2
14265: DIFF
14266: PPUSH
14267: CALL_OW 1
14271: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14272: LD_ADDR_VAR 0 3
14276: PUSH
14277: LD_INT 0
14279: PPUSH
14280: LD_INT 1
14282: PPUSH
14283: CALL_OW 12
14287: ST_TO_ADDR
// if target then
14288: LD_VAR 0 3
14292: IFFALSE 14458
// begin for i in tmp do
14294: LD_ADDR_VAR 0 1
14298: PUSH
14299: LD_VAR 0 2
14303: PUSH
14304: FOR_IN
14305: IFFALSE 14330
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14307: LD_VAR 0 1
14311: PPUSH
14312: LD_INT 179
14314: PPUSH
14315: LD_INT 209
14317: PPUSH
14318: LD_INT 8
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: CALL_OW 483
14328: GO 14304
14330: POP
14331: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14332: LD_ADDR_VAR 0 2
14336: PUSH
14337: LD_VAR 0 2
14341: PPUSH
14342: LD_INT 24
14344: PUSH
14345: LD_INT 250
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PPUSH
14352: CALL_OW 72
14356: ST_TO_ADDR
// for i in tmp do
14357: LD_ADDR_VAR 0 1
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: FOR_IN
14368: IFFALSE 14408
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14370: LD_VAR 0 1
14374: PPUSH
14375: LD_INT 179
14377: PPUSH
14378: LD_INT 209
14380: PPUSH
14381: CALL_OW 297
14385: PUSH
14386: LD_INT 9
14388: GREATER
14389: IFFALSE 14406
// ComMoveXY ( i , 179 , 209 ) ;
14391: LD_VAR 0 1
14395: PPUSH
14396: LD_INT 179
14398: PPUSH
14399: LD_INT 209
14401: PPUSH
14402: CALL_OW 111
14406: GO 14367
14408: POP
14409: POP
// wait ( 0 0$1 ) ;
14410: LD_INT 35
14412: PPUSH
14413: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14417: LD_VAR 0 2
14421: PPUSH
14422: LD_INT 92
14424: PUSH
14425: LD_INT 179
14427: PUSH
14428: LD_INT 209
14430: PUSH
14431: LD_INT 9
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 72
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_INT 1
14452: MINUS
14453: GREATEREQUAL
14454: IFFALSE 14332
// end else
14456: GO 14620
// begin for i in tmp do
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: LD_VAR 0 2
14467: PUSH
14468: FOR_IN
14469: IFFALSE 14494
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 285
14478: PPUSH
14479: LD_INT 163
14481: PPUSH
14482: LD_INT 8
14484: PPUSH
14485: LD_INT 1
14487: PPUSH
14488: CALL_OW 483
14492: GO 14468
14494: POP
14495: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_VAR 0 2
14505: PPUSH
14506: LD_INT 24
14508: PUSH
14509: LD_INT 250
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: PPUSH
14516: CALL_OW 72
14520: ST_TO_ADDR
// for i in tmp do
14521: LD_ADDR_VAR 0 1
14525: PUSH
14526: LD_VAR 0 2
14530: PUSH
14531: FOR_IN
14532: IFFALSE 14572
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14534: LD_VAR 0 1
14538: PPUSH
14539: LD_INT 285
14541: PPUSH
14542: LD_INT 163
14544: PPUSH
14545: CALL_OW 297
14549: PUSH
14550: LD_INT 9
14552: GREATER
14553: IFFALSE 14570
// ComMoveXY ( i , 285 , 163 ) ;
14555: LD_VAR 0 1
14559: PPUSH
14560: LD_INT 285
14562: PPUSH
14563: LD_INT 163
14565: PPUSH
14566: CALL_OW 111
14570: GO 14531
14572: POP
14573: POP
// wait ( 0 0$1 ) ;
14574: LD_INT 35
14576: PPUSH
14577: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14581: LD_VAR 0 2
14585: PPUSH
14586: LD_INT 92
14588: PUSH
14589: LD_INT 285
14591: PUSH
14592: LD_INT 163
14594: PUSH
14595: LD_INT 9
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: PPUSH
14604: CALL_OW 72
14608: PUSH
14609: LD_VAR 0 2
14613: PUSH
14614: LD_INT 1
14616: MINUS
14617: GREATEREQUAL
14618: IFFALSE 14496
// end ; repeat wait ( 0 0$1 ) ;
14620: LD_INT 35
14622: PPUSH
14623: CALL_OW 67
// for i in tmp do
14627: LD_ADDR_VAR 0 1
14631: PUSH
14632: LD_VAR 0 2
14636: PUSH
14637: FOR_IN
14638: IFFALSE 14760
// if GetLives ( i ) > 251 then
14640: LD_VAR 0 1
14644: PPUSH
14645: CALL_OW 256
14649: PUSH
14650: LD_INT 251
14652: GREATER
14653: IFFALSE 14742
// begin if GetWeapon ( i ) = ru_time_lapser then
14655: LD_VAR 0 1
14659: PPUSH
14660: CALL_OW 264
14664: PUSH
14665: LD_INT 49
14667: EQUAL
14668: IFFALSE 14706
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14670: LD_VAR 0 1
14674: PPUSH
14675: LD_INT 81
14677: PUSH
14678: LD_INT 7
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: PPUSH
14685: CALL_OW 69
14689: PPUSH
14690: LD_VAR 0 1
14694: PPUSH
14695: CALL_OW 74
14699: PPUSH
14700: CALL_OW 112
14704: GO 14740
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14706: LD_VAR 0 1
14710: PPUSH
14711: LD_INT 81
14713: PUSH
14714: LD_INT 7
14716: PUSH
14717: EMPTY
14718: LIST
14719: LIST
14720: PPUSH
14721: CALL_OW 69
14725: PPUSH
14726: LD_VAR 0 1
14730: PPUSH
14731: CALL_OW 74
14735: PPUSH
14736: CALL_OW 115
// end else
14740: GO 14758
// tmp := tmp diff i ;
14742: LD_ADDR_VAR 0 2
14746: PUSH
14747: LD_VAR 0 2
14751: PUSH
14752: LD_VAR 0 1
14756: DIFF
14757: ST_TO_ADDR
14758: GO 14637
14760: POP
14761: POP
// until not tmp ;
14762: LD_VAR 0 2
14766: NOT
14767: IFFALSE 14620
// end ; end_of_file
14769: PPOPN 4
14771: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14772: LD_INT 0
14774: PPUSH
14775: PPUSH
14776: PPUSH
14777: PPUSH
// missionStage := 13 ;
14778: LD_ADDR_EXP 15
14782: PUSH
14783: LD_INT 13
14785: ST_TO_ADDR
// uc_side := 2 ;
14786: LD_ADDR_OWVAR 20
14790: PUSH
14791: LD_INT 2
14793: ST_TO_ADDR
// uc_nation := 2 ;
14794: LD_ADDR_OWVAR 21
14798: PUSH
14799: LD_INT 2
14801: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14802: LD_ADDR_EXP 95
14806: PUSH
14807: LD_STRING Omar
14809: PPUSH
14810: CALL_OW 25
14814: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14815: LD_EXP 95
14819: PPUSH
14820: LD_INT 4
14822: PPUSH
14823: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14827: LD_EXP 95
14831: PPUSH
14832: LD_INT 242
14834: PPUSH
14835: LD_INT 75
14837: PPUSH
14838: LD_INT 0
14840: PPUSH
14841: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14845: LD_ADDR_EXP 96
14849: PUSH
14850: LD_STRING Heike
14852: PPUSH
14853: CALL_OW 25
14857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14858: LD_INT 14
14860: PPUSH
14861: LD_INT 3
14863: PPUSH
14864: LD_INT 1
14866: PPUSH
14867: LD_INT 27
14869: PPUSH
14870: LD_INT 100
14872: PPUSH
14873: CALL 72597 0 5
// veh := CreateVehicle ;
14877: LD_ADDR_VAR 0 3
14881: PUSH
14882: CALL_OW 45
14886: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14887: LD_VAR 0 3
14891: PPUSH
14892: LD_INT 2
14894: NEG
14895: PPUSH
14896: CALL_OW 242
// SetDir ( veh , 4 ) ;
14900: LD_VAR 0 3
14904: PPUSH
14905: LD_INT 4
14907: PPUSH
14908: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14912: LD_VAR 0 3
14916: PPUSH
14917: LD_INT 241
14919: PPUSH
14920: LD_INT 72
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14930: LD_EXP 96
14934: PPUSH
14935: LD_VAR 0 3
14939: PPUSH
14940: CALL_OW 52
// if KhatamStatus then
14944: LD_EXP 8
14948: IFFALSE 15011
// begin Khatam := NewCharacter ( Khatam ) ;
14950: LD_ADDR_EXP 97
14954: PUSH
14955: LD_STRING Khatam
14957: PPUSH
14958: CALL_OW 25
14962: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14963: LD_EXP 97
14967: PPUSH
14968: LD_INT 245
14970: PPUSH
14971: LD_INT 78
14973: PPUSH
14974: LD_INT 3
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14984: LD_EXP 97
14988: PPUSH
14989: LD_INT 4
14991: PPUSH
14992: LD_INT 10
14994: PPUSH
14995: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14999: LD_EXP 97
15003: PPUSH
15004: LD_INT 4
15006: PPUSH
15007: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: DOUBLE
15017: LD_INT 1
15019: DEC
15020: ST_TO_ADDR
15021: LD_INT 2
15023: PUSH
15024: LD_INT 2
15026: PUSH
15027: LD_INT 3
15029: PUSH
15030: LD_INT 3
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: PUSH
15039: LD_OWVAR 67
15043: ARRAY
15044: PUSH
15045: FOR_TO
15046: IFFALSE 15112
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15048: LD_INT 0
15050: PPUSH
15051: LD_INT 6
15053: PUSH
15054: LD_OWVAR 67
15058: PLUS
15059: PPUSH
15060: CALL_OW 384
// un := CreateHuman ;
15064: LD_ADDR_VAR 0 4
15068: PUSH
15069: CALL_OW 44
15073: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15074: LD_VAR 0 4
15078: PPUSH
15079: LD_INT 28
15081: PUSH
15082: LD_INT 29
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_VAR 0 2
15093: PUSH
15094: LD_INT 2
15096: MOD
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: ARRAY
15102: PPUSH
15103: LD_INT 0
15105: PPUSH
15106: CALL_OW 49
// end ;
15110: GO 15045
15112: POP
15113: POP
// for i = 1 to 6 do
15114: LD_ADDR_VAR 0 2
15118: PUSH
15119: DOUBLE
15120: LD_INT 1
15122: DEC
15123: ST_TO_ADDR
15124: LD_INT 6
15126: PUSH
15127: FOR_TO
15128: IFFALSE 15173
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15130: LD_INT 0
15132: PPUSH
15133: LD_INT 6
15135: PUSH
15136: LD_OWVAR 67
15140: PLUS
15141: PPUSH
15142: CALL_OW 381
// un := CreateHuman ;
15146: LD_ADDR_VAR 0 4
15150: PUSH
15151: CALL_OW 44
15155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15156: LD_VAR 0 4
15160: PPUSH
15161: LD_INT 32
15163: PPUSH
15164: LD_INT 0
15166: PPUSH
15167: CALL_OW 49
// end ;
15171: GO 15127
15173: POP
15174: POP
// for i = 1 to 3 do
15175: LD_ADDR_VAR 0 2
15179: PUSH
15180: DOUBLE
15181: LD_INT 1
15183: DEC
15184: ST_TO_ADDR
15185: LD_INT 3
15187: PUSH
15188: FOR_TO
15189: IFFALSE 15237
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15191: LD_INT 0
15193: PPUSH
15194: LD_INT 8
15196: PPUSH
15197: LD_INT 6
15199: PUSH
15200: LD_OWVAR 67
15204: PLUS
15205: PPUSH
15206: CALL_OW 380
// un := CreateHuman ;
15210: LD_ADDR_VAR 0 4
15214: PUSH
15215: CALL_OW 44
15219: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15220: LD_VAR 0 4
15224: PPUSH
15225: LD_INT 32
15227: PPUSH
15228: LD_INT 0
15230: PPUSH
15231: CALL_OW 49
// end ;
15235: GO 15188
15237: POP
15238: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15239: LD_ADDR_VAR 0 2
15243: PUSH
15244: DOUBLE
15245: LD_INT 1
15247: DEC
15248: ST_TO_ADDR
15249: LD_INT 2
15251: PUSH
15252: LD_INT 3
15254: PUSH
15255: LD_INT 4
15257: PUSH
15258: LD_INT 4
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: PUSH
15267: LD_OWVAR 67
15271: ARRAY
15272: PUSH
15273: FOR_TO
15274: IFFALSE 15364
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15276: LD_INT 14
15278: PPUSH
15279: LD_INT 2
15281: PPUSH
15282: LD_INT 1
15284: PPUSH
15285: LD_INT 28
15287: PPUSH
15288: LD_INT 80
15290: PPUSH
15291: CALL 72597 0 5
// veh := CreateVehicle ;
15295: LD_ADDR_VAR 0 3
15299: PUSH
15300: CALL_OW 45
15304: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15305: LD_VAR 0 3
15309: PPUSH
15310: LD_INT 3
15312: PPUSH
15313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15317: LD_VAR 0 3
15321: PPUSH
15322: LD_INT 29
15324: PPUSH
15325: LD_INT 0
15327: PPUSH
15328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15332: LD_INT 0
15334: PPUSH
15335: LD_INT 6
15337: PUSH
15338: LD_OWVAR 67
15342: PLUS
15343: PPUSH
15344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15348: CALL_OW 44
15352: PPUSH
15353: LD_VAR 0 3
15357: PPUSH
15358: CALL_OW 52
// end ;
15362: GO 15273
15364: POP
15365: POP
// for i = 1 to 5 + Difficulty do
15366: LD_ADDR_VAR 0 2
15370: PUSH
15371: DOUBLE
15372: LD_INT 1
15374: DEC
15375: ST_TO_ADDR
15376: LD_INT 5
15378: PUSH
15379: LD_OWVAR 67
15383: PLUS
15384: PUSH
15385: FOR_TO
15386: IFFALSE 15513
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15388: LD_INT 14
15390: PPUSH
15391: LD_INT 1
15393: PPUSH
15394: LD_INT 3
15396: PPUSH
15397: CALL_OW 12
15401: PPUSH
15402: LD_INT 1
15404: PPUSH
15405: LD_INT 28
15407: PUSH
15408: LD_INT 26
15410: PUSH
15411: LD_INT 27
15413: PUSH
15414: LD_INT 25
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: LIST
15421: LIST
15422: PUSH
15423: LD_VAR 0 2
15427: PUSH
15428: LD_INT 4
15430: MOD
15431: PUSH
15432: LD_INT 1
15434: PLUS
15435: ARRAY
15436: PPUSH
15437: LD_INT 80
15439: PPUSH
15440: CALL 72597 0 5
// veh := CreateVehicle ;
15444: LD_ADDR_VAR 0 3
15448: PUSH
15449: CALL_OW 45
15453: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15454: LD_VAR 0 3
15458: PPUSH
15459: LD_INT 4
15461: PPUSH
15462: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15466: LD_VAR 0 3
15470: PPUSH
15471: LD_INT 28
15473: PPUSH
15474: LD_INT 0
15476: PPUSH
15477: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15481: LD_INT 0
15483: PPUSH
15484: LD_INT 6
15486: PUSH
15487: LD_OWVAR 67
15491: PLUS
15492: PPUSH
15493: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15497: CALL_OW 44
15501: PPUSH
15502: LD_VAR 0 3
15506: PPUSH
15507: CALL_OW 52
// end ;
15511: GO 15385
15513: POP
15514: POP
// for i = 1 to Difficulty do
15515: LD_ADDR_VAR 0 2
15519: PUSH
15520: DOUBLE
15521: LD_INT 1
15523: DEC
15524: ST_TO_ADDR
15525: LD_OWVAR 67
15529: PUSH
15530: FOR_TO
15531: IFFALSE 15591
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15533: LD_INT 14
15535: PPUSH
15536: LD_INT 3
15538: PPUSH
15539: LD_INT 5
15541: PPUSH
15542: LD_INT 29
15544: PPUSH
15545: LD_INT 80
15547: PPUSH
15548: CALL 72597 0 5
// veh := CreateVehicle ;
15552: LD_ADDR_VAR 0 3
15556: PUSH
15557: CALL_OW 45
15561: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15562: LD_VAR 0 3
15566: PPUSH
15567: LD_INT 4
15569: PPUSH
15570: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15574: LD_VAR 0 3
15578: PPUSH
15579: LD_INT 28
15581: PPUSH
15582: LD_INT 0
15584: PPUSH
15585: CALL_OW 49
// end ;
15589: GO 15530
15591: POP
15592: POP
// end ;
15593: LD_VAR 0 1
15597: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15598: LD_INT 22
15600: PUSH
15601: LD_INT 2
15603: PUSH
15604: EMPTY
15605: LIST
15606: LIST
15607: PPUSH
15608: CALL_OW 69
15612: IFFALSE 15991
15614: GO 15616
15616: DISABLE
15617: LD_INT 0
15619: PPUSH
15620: PPUSH
15621: PPUSH
15622: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15623: LD_ADDR_VAR 0 3
15627: PUSH
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 25
15640: PUSH
15641: LD_INT 4
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: EMPTY
15649: LIST
15650: LIST
15651: PPUSH
15652: CALL_OW 69
15656: PUSH
15657: LD_EXP 97
15661: DIFF
15662: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15663: LD_ADDR_VAR 0 2
15667: PUSH
15668: LD_INT 22
15670: PUSH
15671: LD_INT 2
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PPUSH
15678: CALL_OW 69
15682: PUSH
15683: LD_EXP 97
15687: PUSH
15688: LD_VAR 0 3
15692: UNION
15693: DIFF
15694: ST_TO_ADDR
// if Khatam then
15695: LD_EXP 97
15699: IFFALSE 15716
// ComMoveXY ( Khatam , 211 , 92 ) ;
15701: LD_EXP 97
15705: PPUSH
15706: LD_INT 211
15708: PPUSH
15709: LD_INT 92
15711: PPUSH
15712: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15716: LD_INT 197
15718: PPUSH
15719: LD_INT 80
15721: PPUSH
15722: LD_INT 2
15724: PPUSH
15725: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15729: LD_INT 213
15731: PPUSH
15732: LD_INT 90
15734: PPUSH
15735: LD_INT 2
15737: PPUSH
15738: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15742: LD_INT 215
15744: PPUSH
15745: LD_INT 129
15747: PPUSH
15748: LD_INT 2
15750: PPUSH
15751: CALL_OW 441
// if sci then
15755: LD_VAR 0 3
15759: IFFALSE 15780
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15761: LD_VAR 0 3
15765: PUSH
15766: LD_INT 1
15768: ARRAY
15769: PPUSH
15770: LD_INT 197
15772: PPUSH
15773: LD_INT 80
15775: PPUSH
15776: CALL_OW 158
// if sci > 1 then
15780: LD_VAR 0 3
15784: PUSH
15785: LD_INT 1
15787: GREATER
15788: IFFALSE 15809
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15790: LD_VAR 0 3
15794: PUSH
15795: LD_INT 2
15797: ARRAY
15798: PPUSH
15799: LD_INT 213
15801: PPUSH
15802: LD_INT 90
15804: PPUSH
15805: CALL_OW 158
// if sci > 2 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 2
15816: GREATER
15817: IFFALSE 15838
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15819: LD_VAR 0 3
15823: PUSH
15824: LD_INT 3
15826: ARRAY
15827: PPUSH
15828: LD_INT 215
15830: PPUSH
15831: LD_INT 129
15833: PPUSH
15834: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15838: LD_VAR 0 2
15842: PPUSH
15843: LD_INT 195
15845: PPUSH
15846: LD_INT 102
15848: PPUSH
15849: CALL_OW 114
// wait ( 0 0$5 ) ;
15853: LD_INT 175
15855: PPUSH
15856: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15860: LD_INT 70
15862: PPUSH
15863: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15867: LD_ADDR_VAR 0 4
15871: PUSH
15872: LD_INT 92
15874: PUSH
15875: LD_INT 195
15877: PUSH
15878: LD_INT 102
15880: PUSH
15881: LD_INT 36
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: PUSH
15890: LD_INT 22
15892: PUSH
15893: LD_INT 1
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: PUSH
15900: EMPTY
15901: LIST
15902: LIST
15903: PPUSH
15904: CALL_OW 69
15908: ST_TO_ADDR
// for i in tmp do
15909: LD_ADDR_VAR 0 1
15913: PUSH
15914: LD_VAR 0 2
15918: PUSH
15919: FOR_IN
15920: IFFALSE 15971
// if enemy then
15922: LD_VAR 0 4
15926: IFFALSE 15954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15928: LD_VAR 0 1
15932: PPUSH
15933: LD_VAR 0 4
15937: PPUSH
15938: LD_VAR 0 1
15942: PPUSH
15943: CALL_OW 74
15947: PPUSH
15948: CALL_OW 115
15952: GO 15969
// ComAgressiveMove ( i , 195 , 102 ) ;
15954: LD_VAR 0 1
15958: PPUSH
15959: LD_INT 195
15961: PPUSH
15962: LD_INT 102
15964: PPUSH
15965: CALL_OW 114
15969: GO 15919
15971: POP
15972: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15973: LD_VAR 0 2
15977: PPUSH
15978: LD_INT 50
15980: PUSH
15981: EMPTY
15982: LIST
15983: PPUSH
15984: CALL_OW 72
15988: NOT
15989: IFFALSE 15860
// end ; end_of_file
15991: PPOPN 4
15993: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15994: LD_INT 0
15996: PPUSH
15997: PPUSH
15998: PPUSH
15999: PPUSH
16000: PPUSH
16001: PPUSH
16002: PPUSH
16003: PPUSH
16004: PPUSH
// Video ( true ) ;
16005: LD_INT 1
16007: PPUSH
16008: CALL 105022 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 7
16019: PPUSH
16020: LD_INT 0
16022: PPUSH
16023: CALL_OW 517
16027: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16028: LD_ADDR_VAR 0 2
16032: PUSH
16033: DOUBLE
16034: LD_INT 1
16036: DEC
16037: ST_TO_ADDR
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ARRAY
16046: PUSH
16047: FOR_TO
16048: IFFALSE 16093
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16050: LD_VAR 0 5
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_VAR 0 2
16063: ARRAY
16064: PPUSH
16065: LD_VAR 0 5
16069: PUSH
16070: LD_INT 2
16072: ARRAY
16073: PUSH
16074: LD_VAR 0 2
16078: ARRAY
16079: PPUSH
16080: LD_INT 1
16082: PPUSH
16083: LD_INT 15
16085: NEG
16086: PPUSH
16087: CALL 104936 0 4
16091: GO 16047
16093: POP
16094: POP
// CenterNowOnUnits ( Powell ) ;
16095: LD_EXP 60
16099: PPUSH
16100: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16104: LD_ADDR_VAR 0 5
16108: PUSH
16109: LD_EXP 58
16113: PUSH
16114: EMPTY
16115: LIST
16116: ST_TO_ADDR
// if GirlNewVeh then
16117: LD_EXP 59
16121: IFFALSE 16139
// tmp := tmp ^ GirlNewVeh ;
16123: LD_ADDR_VAR 0 5
16127: PUSH
16128: LD_VAR 0 5
16132: PUSH
16133: LD_EXP 59
16137: ADD
16138: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16139: LD_VAR 0 5
16143: PPUSH
16144: LD_INT 60
16146: PPUSH
16147: LD_INT 109
16149: PPUSH
16150: CALL_OW 111
// if KappaStatus then
16154: LD_EXP 2
16158: IFFALSE 16210
// begin Say ( JMM , D1nT-JMM-1 ) ;
16160: LD_EXP 40
16164: PPUSH
16165: LD_STRING D1nT-JMM-1
16167: PPUSH
16168: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16172: LD_EXP 60
16176: PPUSH
16177: LD_STRING D1T-Pow-1
16179: PPUSH
16180: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16184: LD_EXP 40
16188: PPUSH
16189: LD_STRING D1T-JMM-2
16191: PPUSH
16192: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16196: LD_EXP 60
16200: PPUSH
16201: LD_STRING D1T-Pow-2
16203: PPUSH
16204: CALL_OW 88
// end else
16208: GO 16416
// if JMMGirlStatus then
16210: LD_EXP 6
16214: IFFALSE 16359
// begin Say ( JMM , D1T-JMM-1 ) ;
16216: LD_EXP 40
16220: PPUSH
16221: LD_STRING D1T-JMM-1
16223: PPUSH
16224: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16228: LD_EXP 60
16232: PPUSH
16233: LD_STRING D1T-Pow-1
16235: PPUSH
16236: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16240: LD_EXP 40
16244: PPUSH
16245: LD_STRING D1T-JMM-3
16247: PPUSH
16248: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16252: LD_EXP 60
16256: PPUSH
16257: LD_STRING D1T-Pow-3
16259: PPUSH
16260: CALL_OW 88
// if JMMGirl then
16264: LD_EXP 7
16268: IFFALSE 16357
// begin case JMMGirl of 1 :
16270: LD_EXP 7
16274: PUSH
16275: LD_INT 1
16277: DOUBLE
16278: EQUAL
16279: IFTRUE 16283
16281: GO 16298
16283: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16284: LD_EXP 41
16288: PPUSH
16289: LD_STRING D1T-Joan-3
16291: PPUSH
16292: CALL_OW 88
16296: GO 16345
16298: LD_INT 2
16300: DOUBLE
16301: EQUAL
16302: IFTRUE 16306
16304: GO 16321
16306: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16307: LD_EXP 43
16311: PPUSH
16312: LD_STRING D1T-Lisa-3
16314: PPUSH
16315: CALL_OW 88
16319: GO 16345
16321: LD_INT 3
16323: DOUBLE
16324: EQUAL
16325: IFTRUE 16329
16327: GO 16344
16329: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16330: LD_EXP 55
16334: PPUSH
16335: LD_STRING D1T-Con-3
16337: PPUSH
16338: CALL_OW 88
16342: GO 16345
16344: POP
// Say ( Powell , D1T-Pow-4 ) ;
16345: LD_EXP 60
16349: PPUSH
16350: LD_STRING D1T-Pow-4
16352: PPUSH
16353: CALL_OW 88
// end ; end else
16357: GO 16416
// if not FastEnd then
16359: LD_EXP 11
16363: NOT
16364: IFFALSE 16392
// begin Say ( JMM , D1T-JMM-4 ) ;
16366: LD_EXP 40
16370: PPUSH
16371: LD_STRING D1T-JMM-4
16373: PPUSH
16374: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16378: LD_EXP 60
16382: PPUSH
16383: LD_STRING D1T-Pow-5
16385: PPUSH
16386: CALL_OW 88
// end else
16390: GO 16416
// begin Say ( JMM , D1nT-JMM-1 ) ;
16392: LD_EXP 40
16396: PPUSH
16397: LD_STRING D1nT-JMM-1
16399: PPUSH
16400: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16404: LD_EXP 60
16408: PPUSH
16409: LD_STRING D1nT-Pow-1
16411: PPUSH
16412: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16416: LD_INT 3
16418: PPUSH
16419: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16423: LD_EXP 58
16427: PPUSH
16428: CALL_OW 314
16432: NOT
16433: IFFALSE 16416
// ComExitVehicle ( JMM ) ;
16435: LD_EXP 40
16439: PPUSH
16440: CALL_OW 121
// repeat wait ( 3 ) ;
16444: LD_INT 3
16446: PPUSH
16447: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16451: LD_EXP 40
16455: PPUSH
16456: CALL_OW 310
16460: NOT
16461: IFFALSE 16444
// ComMoveXY ( JMM , 60 , 94 ) ;
16463: LD_EXP 40
16467: PPUSH
16468: LD_INT 60
16470: PPUSH
16471: LD_INT 94
16473: PPUSH
16474: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16478: LD_EXP 40
16482: PPUSH
16483: LD_EXP 60
16487: PPUSH
16488: CALL_OW 179
// if Joan then
16492: LD_EXP 41
16496: IFFALSE 16550
// begin ComExitVehicle ( Joan ) ;
16498: LD_EXP 41
16502: PPUSH
16503: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16507: LD_EXP 41
16511: PPUSH
16512: LD_INT 35
16514: PPUSH
16515: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16519: LD_EXP 41
16523: PPUSH
16524: LD_INT 65
16526: PPUSH
16527: LD_INT 104
16529: PPUSH
16530: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16534: LD_EXP 41
16538: PPUSH
16539: LD_EXP 40
16543: PPUSH
16544: CALL_OW 179
// end else
16548: GO 16684
// if Lisa and JMMGirl = 2 then
16550: LD_EXP 43
16554: PUSH
16555: LD_EXP 7
16559: PUSH
16560: LD_INT 2
16562: EQUAL
16563: AND
16564: IFFALSE 16618
// begin ComExitVehicle ( Lisa ) ;
16566: LD_EXP 43
16570: PPUSH
16571: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16575: LD_EXP 43
16579: PPUSH
16580: LD_INT 35
16582: PPUSH
16583: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16587: LD_EXP 43
16591: PPUSH
16592: LD_INT 65
16594: PPUSH
16595: LD_INT 104
16597: PPUSH
16598: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16602: LD_EXP 43
16606: PPUSH
16607: LD_EXP 40
16611: PPUSH
16612: CALL_OW 179
// end else
16616: GO 16684
// if Connie and JMMGirl = 3 then
16618: LD_EXP 55
16622: PUSH
16623: LD_EXP 7
16627: PUSH
16628: LD_INT 3
16630: EQUAL
16631: AND
16632: IFFALSE 16684
// begin ComExitVehicle ( Connie ) ;
16634: LD_EXP 55
16638: PPUSH
16639: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16643: LD_EXP 55
16647: PPUSH
16648: LD_INT 35
16650: PPUSH
16651: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16655: LD_EXP 55
16659: PPUSH
16660: LD_INT 65
16662: PPUSH
16663: LD_INT 104
16665: PPUSH
16666: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16670: LD_EXP 55
16674: PPUSH
16675: LD_EXP 40
16679: PPUSH
16680: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16684: LD_INT 35
16686: PPUSH
16687: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16691: LD_EXP 40
16695: PPUSH
16696: LD_EXP 60
16700: PPUSH
16701: CALL_OW 296
16705: PUSH
16706: LD_INT 8
16708: LESS
16709: IFFALSE 16684
// wait ( 0 0$0.5 ) ;
16711: LD_INT 18
16713: PPUSH
16714: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16718: LD_EXP 40
16722: PPUSH
16723: LD_STRING D1-JMM-1
16725: PPUSH
16726: CALL_OW 88
// async ;
16730: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16731: LD_EXP 60
16735: PPUSH
16736: LD_STRING D1-Pow-1
16738: PPUSH
16739: CALL_OW 88
// if not dialogue_skipped then
16743: LD_OWVAR 59
16747: NOT
16748: IFFALSE 16757
// wait ( 0 0$2 ) ;
16750: LD_INT 70
16752: PPUSH
16753: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16757: LD_INT 170
16759: PPUSH
16760: LD_INT 99
16762: PPUSH
16763: LD_INT 1
16765: PPUSH
16766: LD_INT 6
16768: NEG
16769: PPUSH
16770: CALL 104936 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16774: LD_INT 174
16776: PPUSH
16777: LD_INT 115
16779: PPUSH
16780: LD_INT 1
16782: PPUSH
16783: LD_INT 6
16785: NEG
16786: PPUSH
16787: CALL 104936 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16791: LD_INT 169
16793: PPUSH
16794: LD_INT 71
16796: PPUSH
16797: LD_INT 1
16799: PPUSH
16800: LD_INT 6
16802: NEG
16803: PPUSH
16804: CALL 104936 0 4
// if not dialogue_skipped then
16808: LD_OWVAR 59
16812: NOT
16813: IFFALSE 16832
// begin CenterOnXY ( 170 , 99 ) ;
16815: LD_INT 170
16817: PPUSH
16818: LD_INT 99
16820: PPUSH
16821: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16825: LD_INT 80
16827: PPUSH
16828: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16832: LD_INT 75
16834: PPUSH
16835: LD_INT 53
16837: PPUSH
16838: LD_INT 1
16840: PPUSH
16841: LD_INT 9
16843: NEG
16844: PPUSH
16845: CALL 104936 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16849: LD_INT 54
16851: PPUSH
16852: LD_INT 42
16854: PPUSH
16855: LD_INT 1
16857: PPUSH
16858: LD_INT 9
16860: NEG
16861: PPUSH
16862: CALL 104936 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16866: LD_INT 62
16868: PPUSH
16869: LD_INT 51
16871: PPUSH
16872: LD_INT 1
16874: PPUSH
16875: LD_INT 9
16877: NEG
16878: PPUSH
16879: CALL 104936 0 4
// if not dialogue_skipped then
16883: LD_OWVAR 59
16887: NOT
16888: IFFALSE 16907
// begin CenterOnXY ( 75 , 53 ) ;
16890: LD_INT 75
16892: PPUSH
16893: LD_INT 53
16895: PPUSH
16896: CALL_OW 84
// wait ( 0 0$4 ) ;
16900: LD_INT 140
16902: PPUSH
16903: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16907: LD_EXP 60
16911: PPUSH
16912: CALL_OW 87
// if not dialogue_skipped then
16916: LD_OWVAR 59
16920: NOT
16921: IFFALSE 16930
// wait ( 0 0$2 ) ;
16923: LD_INT 70
16925: PPUSH
16926: CALL_OW 67
// sync ;
16930: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16931: LD_EXP 40
16935: PPUSH
16936: LD_STRING D1-JMM-2
16938: PPUSH
16939: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16943: LD_EXP 60
16947: PPUSH
16948: LD_STRING D1-Pow-2
16950: PPUSH
16951: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16955: LD_EXP 40
16959: PPUSH
16960: LD_STRING D1-JMM-3
16962: PPUSH
16963: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16967: LD_EXP 60
16971: PPUSH
16972: LD_STRING D1-Pow-3
16974: PPUSH
16975: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16979: LD_EXP 40
16983: PPUSH
16984: LD_STRING D1-JMM-4
16986: PPUSH
16987: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16991: LD_EXP 60
16995: PPUSH
16996: LD_STRING D1-Pow-4
16998: PPUSH
16999: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17003: LD_EXP 40
17007: PPUSH
17008: LD_STRING D1-JMM-5
17010: PPUSH
17011: CALL_OW 88
// async ;
17015: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17016: LD_EXP 60
17020: PPUSH
17021: LD_STRING D1-Pow-5
17023: PPUSH
17024: CALL_OW 88
// if not dialogue_skipped then
17028: LD_OWVAR 59
17032: NOT
17033: IFFALSE 17042
// wait ( 0 0$3.6 ) ;
17035: LD_INT 126
17037: PPUSH
17038: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17042: LD_INT 134
17044: PPUSH
17045: LD_INT 210
17047: PPUSH
17048: LD_INT 1
17050: PPUSH
17051: LD_INT 11
17053: NEG
17054: PPUSH
17055: CALL 104936 0 4
// if not dialogue_skipped then
17059: LD_OWVAR 59
17063: NOT
17064: IFFALSE 17083
// begin CenterOnXY ( 134 , 210 ) ;
17066: LD_INT 134
17068: PPUSH
17069: LD_INT 210
17071: PPUSH
17072: CALL_OW 84
// wait ( 0 0$2 ) ;
17076: LD_INT 70
17078: PPUSH
17079: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17083: LD_INT 101
17085: PPUSH
17086: LD_INT 159
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: LD_INT 10
17094: NEG
17095: PPUSH
17096: CALL 104936 0 4
// if not dialogue_skipped then
17100: LD_OWVAR 59
17104: NOT
17105: IFFALSE 17124
// begin CenterOnXY ( 101 , 159 ) ;
17107: LD_INT 101
17109: PPUSH
17110: LD_INT 159
17112: PPUSH
17113: CALL_OW 84
// wait ( 0 0$2 ) ;
17117: LD_INT 70
17119: PPUSH
17120: CALL_OW 67
// end ; sync ;
17124: SYNC
// CenterNowOnUnits ( Powell ) ;
17125: LD_EXP 60
17129: PPUSH
17130: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17134: LD_ADDR_VAR 0 6
17138: PUSH
17139: LD_INT 1
17141: PUSH
17142: LD_INT 2
17144: PUSH
17145: LD_INT 3
17147: PUSH
17148: LD_INT 4
17150: PUSH
17151: LD_INT 5
17153: PUSH
17154: LD_INT 6
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: LIST
17164: ST_TO_ADDR
// if not dialogue_skipped then
17165: LD_OWVAR 59
17169: NOT
17170: IFFALSE 17339
// begin game_speed := 4 ;
17172: LD_ADDR_OWVAR 65
17176: PUSH
17177: LD_INT 4
17179: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17180: LD_INT 210
17182: PPUSH
17183: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17187: LD_ADDR_VAR 0 7
17191: PUSH
17192: LD_STRING Q1
17194: PPUSH
17195: LD_VAR 0 6
17199: PPUSH
17200: CALL_OW 98
17204: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17205: LD_ADDR_VAR 0 7
17209: PUSH
17210: LD_STRING Q1
17212: PPUSH
17213: LD_VAR 0 6
17217: PPUSH
17218: CALL_OW 98
17222: ST_TO_ADDR
// options := options diff dec ;
17223: LD_ADDR_VAR 0 6
17227: PUSH
17228: LD_VAR 0 6
17232: PUSH
17233: LD_VAR 0 7
17237: DIFF
17238: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17239: LD_VAR 0 7
17243: PPUSH
17244: LD_VAR 0 6
17248: PPUSH
17249: CALL 18903 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17253: LD_VAR 0 7
17257: PUSH
17258: LD_INT 5
17260: PUSH
17261: LD_INT 6
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: IN
17268: PUSH
17269: LD_VAR 0 6
17273: PUSH
17274: LD_INT 2
17276: EQUAL
17277: OR
17278: IFFALSE 17205
// if not ( dec in [ 5 , 6 ] ) then
17280: LD_VAR 0 7
17284: PUSH
17285: LD_INT 5
17287: PUSH
17288: LD_INT 6
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: IN
17295: NOT
17296: IFFALSE 17339
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17298: LD_ADDR_VAR 0 7
17302: PUSH
17303: LD_STRING Q1a
17305: PPUSH
17306: LD_INT 1
17308: PUSH
17309: LD_INT 2
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PPUSH
17316: CALL_OW 98
17320: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17321: LD_VAR 0 7
17325: PUSH
17326: LD_INT 4
17328: PLUS
17329: PPUSH
17330: LD_VAR 0 6
17334: PPUSH
17335: CALL 18903 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17339: LD_INT 81
17341: PPUSH
17342: LD_INT 127
17344: PPUSH
17345: CALL_OW 84
// amount := 8 ;
17349: LD_ADDR_VAR 0 8
17353: PUSH
17354: LD_INT 8
17356: ST_TO_ADDR
// macmilan_squad := [ ] ;
17357: LD_ADDR_VAR 0 9
17361: PUSH
17362: EMPTY
17363: ST_TO_ADDR
// if vip < amount then
17364: LD_EXP 61
17368: PUSH
17369: LD_VAR 0 8
17373: LESS
17374: IFFALSE 17418
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17376: LD_ADDR_VAR 0 5
17380: PUSH
17381: LD_EXP 61
17385: PUSH
17386: LD_INT 22
17388: PUSH
17389: LD_INT 4
17391: PUSH
17392: EMPTY
17393: LIST
17394: LIST
17395: PUSH
17396: LD_INT 21
17398: PUSH
17399: LD_INT 1
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PPUSH
17410: CALL_OW 69
17414: UNION
17415: ST_TO_ADDR
17416: GO 17428
// tmp := vip ;
17418: LD_ADDR_VAR 0 5
17422: PUSH
17423: LD_EXP 61
17427: ST_TO_ADDR
// tmp := tmp diff Powell ;
17428: LD_ADDR_VAR 0 5
17432: PUSH
17433: LD_VAR 0 5
17437: PUSH
17438: LD_EXP 60
17442: DIFF
17443: ST_TO_ADDR
// if tmp < amount then
17444: LD_VAR 0 5
17448: PUSH
17449: LD_VAR 0 8
17453: LESS
17454: IFFALSE 17466
// amount := tmp ;
17456: LD_ADDR_VAR 0 8
17460: PUSH
17461: LD_VAR 0 5
17465: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17466: LD_VAR 0 5
17470: PUSH
17471: LD_INT 1
17473: ARRAY
17474: PPUSH
17475: CALL_OW 257
17479: PUSH
17480: LD_INT 2
17482: NONEQUAL
17483: IFFALSE 17581
// begin if IsInUnit ( tmp [ 1 ] ) then
17485: LD_VAR 0 5
17489: PUSH
17490: LD_INT 1
17492: ARRAY
17493: PPUSH
17494: CALL_OW 310
17498: IFFALSE 17513
// ComExitBuilding ( tmp [ 1 ] ) ;
17500: LD_VAR 0 5
17504: PUSH
17505: LD_INT 1
17507: ARRAY
17508: PPUSH
17509: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17513: LD_INT 387
17515: PPUSH
17516: CALL_OW 313
17520: PUSH
17521: LD_INT 6
17523: EQUAL
17524: IFFALSE 17549
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17526: LD_INT 387
17528: PPUSH
17529: CALL_OW 313
17533: PUSH
17534: LD_INT 1
17536: ARRAY
17537: PPUSH
17538: CALL_OW 122
// wait ( 3 ) ;
17542: LD_INT 3
17544: PPUSH
17545: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17549: LD_VAR 0 5
17553: PUSH
17554: LD_INT 1
17556: ARRAY
17557: PPUSH
17558: LD_INT 387
17560: PPUSH
17561: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17565: LD_VAR 0 5
17569: PUSH
17570: LD_INT 1
17572: ARRAY
17573: PPUSH
17574: LD_INT 2
17576: PPUSH
17577: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17581: LD_EXP 40
17585: PPUSH
17586: LD_INT 82
17588: PPUSH
17589: LD_INT 129
17591: PPUSH
17592: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17596: LD_EXP 40
17600: PPUSH
17601: LD_EXP 60
17605: PPUSH
17606: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17610: LD_INT 22
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: PPUSH
17620: CALL_OW 69
17624: PUSH
17625: LD_EXP 40
17629: DIFF
17630: PPUSH
17631: LD_INT 84
17633: PPUSH
17634: LD_INT 128
17636: PPUSH
17637: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17641: LD_INT 22
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: EMPTY
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: PUSH
17656: LD_EXP 40
17660: DIFF
17661: PPUSH
17662: LD_EXP 40
17666: PPUSH
17667: CALL_OW 179
// for i = 1 to amount do
17671: LD_ADDR_VAR 0 2
17675: PUSH
17676: DOUBLE
17677: LD_INT 1
17679: DEC
17680: ST_TO_ADDR
17681: LD_VAR 0 8
17685: PUSH
17686: FOR_TO
17687: IFFALSE 17855
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17689: LD_ADDR_VAR 0 9
17693: PUSH
17694: LD_VAR 0 9
17698: PUSH
17699: LD_VAR 0 5
17703: PUSH
17704: LD_VAR 0 2
17708: ARRAY
17709: ADD
17710: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17711: LD_VAR 0 5
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: CALL_OW 310
17726: IFFALSE 17743
// AddComExitBuilding ( tmp [ i ] ) ;
17728: LD_VAR 0 5
17732: PUSH
17733: LD_VAR 0 2
17737: ARRAY
17738: PPUSH
17739: CALL_OW 182
// if i = 2 and JMMNewVeh then
17743: LD_VAR 0 2
17747: PUSH
17748: LD_INT 2
17750: EQUAL
17751: PUSH
17752: LD_EXP 58
17756: AND
17757: IFFALSE 17815
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17759: LD_VAR 0 5
17763: PUSH
17764: LD_VAR 0 2
17768: ARRAY
17769: PPUSH
17770: LD_EXP 58
17774: PPUSH
17775: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17779: LD_VAR 0 5
17783: PUSH
17784: LD_VAR 0 2
17788: ARRAY
17789: PPUSH
17790: LD_INT 86
17792: PPUSH
17793: LD_INT 133
17795: PPUSH
17796: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 2
17809: ARRAY
17810: PPUSH
17811: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17815: LD_VAR 0 5
17819: PUSH
17820: LD_VAR 0 2
17824: ARRAY
17825: PPUSH
17826: LD_INT 8
17828: PPUSH
17829: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17833: LD_VAR 0 5
17837: PUSH
17838: LD_VAR 0 2
17842: ARRAY
17843: PPUSH
17844: LD_EXP 40
17848: PPUSH
17849: CALL_OW 179
// end ;
17853: GO 17686
17855: POP
17856: POP
// if GirlNewVeh then
17857: LD_EXP 59
17861: IFFALSE 17875
// SetSide ( GirlNewVeh , 4 ) ;
17863: LD_EXP 59
17867: PPUSH
17868: LD_INT 4
17870: PPUSH
17871: CALL_OW 235
// if Mike then
17875: LD_EXP 57
17879: IFFALSE 17916
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
17881: LD_ADDR_VAR 0 9
17885: PUSH
17886: LD_VAR 0 9
17890: PPUSH
17891: LD_EXP 57
17895: PPUSH
17896: CALL 105050 0 2
17900: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
17901: LD_EXP 57
17905: PPUSH
17906: LD_INT 86
17908: PPUSH
17909: LD_INT 133
17911: PPUSH
17912: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
17916: LD_INT 35
17918: PPUSH
17919: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_INT 95
17930: PUSH
17931: LD_INT 9
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PPUSH
17938: CALL_OW 72
17942: PUSH
17943: LD_INT 0
17945: EQUAL
17946: PUSH
17947: LD_EXP 40
17951: PPUSH
17952: LD_INT 9
17954: PPUSH
17955: CALL_OW 308
17959: NOT
17960: AND
17961: IFFALSE 17916
// wait ( 0 0$2 ) ;
17963: LD_INT 70
17965: PPUSH
17966: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17970: LD_VAR 0 9
17974: PPUSH
17975: LD_INT 1
17977: PPUSH
17978: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17982: LD_INT 21
17984: PUSH
17985: LD_INT 2
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: LD_INT 83
17997: PUSH
17998: LD_INT 130
18000: PUSH
18001: LD_INT 10
18003: PUSH
18004: EMPTY
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: PUSH
18010: EMPTY
18011: LIST
18012: LIST
18013: PPUSH
18014: CALL_OW 69
18018: PPUSH
18019: LD_INT 1
18021: PPUSH
18022: CALL_OW 235
// tick := 0 ;
18026: LD_ADDR_OWVAR 1
18030: PUSH
18031: LD_INT 0
18033: ST_TO_ADDR
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 105022 0 1
// ChangeMissionObjectives ( M1 ) ;
18041: LD_STRING M1
18043: PPUSH
18044: CALL_OW 337
// SaveForQuickRestart ;
18048: CALL_OW 22
// missionStart := true ;
18052: LD_ADDR_EXP 13
18056: PUSH
18057: LD_INT 1
18059: ST_TO_ADDR
// missionStage := 2 ;
18060: LD_ADDR_EXP 15
18064: PUSH
18065: LD_INT 2
18067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18068: LD_INT 35
18070: PPUSH
18071: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18075: LD_ADDR_VAR 0 5
18079: PUSH
18080: LD_INT 22
18082: PUSH
18083: LD_INT 4
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 21
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: PPUSH
18104: CALL_OW 69
18108: PUSH
18109: LD_EXP 60
18113: DIFF
18114: ST_TO_ADDR
// if not tmp then
18115: LD_VAR 0 5
18119: NOT
18120: IFFALSE 18135
// tmp := [ Powell ] ;
18122: LD_ADDR_VAR 0 5
18126: PUSH
18127: LD_EXP 60
18131: PUSH
18132: EMPTY
18133: LIST
18134: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18135: LD_ADDR_VAR 0 4
18139: PUSH
18140: LD_INT 22
18142: PUSH
18143: LD_INT 4
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: PUSH
18150: LD_INT 34
18152: PUSH
18153: LD_INT 12
18155: PUSH
18156: EMPTY
18157: LIST
18158: LIST
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PPUSH
18164: CALL_OW 69
18168: PUSH
18169: LD_INT 1
18171: ARRAY
18172: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18173: LD_VAR 0 5
18177: PUSH
18178: LD_INT 1
18180: ARRAY
18181: PPUSH
18182: CALL_OW 310
18186: IFFALSE 18201
// ComExitBuilding ( tmp [ 1 ] ) ;
18188: LD_VAR 0 5
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: PPUSH
18197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18201: LD_VAR 0 5
18205: PUSH
18206: LD_INT 1
18208: ARRAY
18209: PPUSH
18210: LD_VAR 0 4
18214: PPUSH
18215: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18219: LD_VAR 0 5
18223: PUSH
18224: LD_INT 1
18226: ARRAY
18227: PPUSH
18228: LD_INT 80
18230: PPUSH
18231: LD_INT 136
18233: PPUSH
18234: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18238: LD_VAR 0 5
18242: PUSH
18243: LD_INT 1
18245: ARRAY
18246: PPUSH
18247: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18251: LD_VAR 0 5
18255: PUSH
18256: LD_INT 1
18258: ARRAY
18259: PPUSH
18260: LD_INT 59
18262: PPUSH
18263: LD_INT 112
18265: PPUSH
18266: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18270: LD_VAR 0 5
18274: PUSH
18275: LD_INT 1
18277: ARRAY
18278: PPUSH
18279: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18283: LD_EXP 41
18287: PUSH
18288: LD_EXP 41
18292: PPUSH
18293: CALL_OW 255
18297: PUSH
18298: LD_INT 1
18300: EQUAL
18301: AND
18302: IFFALSE 18328
// begin Say ( Joan , D3W-Joan-1 ) ;
18304: LD_EXP 41
18308: PPUSH
18309: LD_STRING D3W-Joan-1
18311: PPUSH
18312: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18316: LD_EXP 40
18320: PPUSH
18321: LD_STRING D3W-JMM-1
18323: PPUSH
18324: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18328: LD_EXP 43
18332: PUSH
18333: LD_EXP 43
18337: PPUSH
18338: CALL_OW 255
18342: PUSH
18343: LD_INT 1
18345: EQUAL
18346: AND
18347: PUSH
18348: LD_EXP 43
18352: PUSH
18353: LD_EXP 61
18357: IN
18358: NOT
18359: AND
18360: IFFALSE 18386
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18362: LD_EXP 43
18366: PPUSH
18367: LD_STRING D3W-Lisa-1
18369: PPUSH
18370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18374: LD_EXP 40
18378: PPUSH
18379: LD_STRING D3W-JMM-1
18381: PPUSH
18382: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18386: LD_EXP 55
18390: PUSH
18391: LD_EXP 55
18395: PPUSH
18396: CALL_OW 255
18400: PUSH
18401: LD_INT 1
18403: EQUAL
18404: AND
18405: IFFALSE 18431
// begin Say ( Connie , D3W-Con-1 ) ;
18407: LD_EXP 55
18411: PPUSH
18412: LD_STRING D3W-Con-1
18414: PPUSH
18415: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18419: LD_EXP 40
18423: PPUSH
18424: LD_STRING D3W-JMM-1
18426: PPUSH
18427: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
18431: LD_INT 18
18433: PPUSH
18434: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
18438: LD_EXP 43
18442: PUSH
18443: LD_EXP 61
18447: IN
18448: PUSH
18449: LD_EXP 43
18453: PPUSH
18454: CALL_OW 255
18458: PUSH
18459: LD_INT 1
18461: EQUAL
18462: AND
18463: IFFALSE 18479
// Say ( Lisa , D3nW-Lisa-1 ) else
18465: LD_EXP 43
18469: PPUSH
18470: LD_STRING D3nW-Lisa-1
18472: PPUSH
18473: CALL_OW 88
18477: GO 18723
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18479: LD_EXP 46
18483: PUSH
18484: LD_EXP 61
18488: IN
18489: PUSH
18490: LD_EXP 46
18494: PPUSH
18495: CALL_OW 255
18499: PUSH
18500: LD_INT 1
18502: EQUAL
18503: AND
18504: IFFALSE 18520
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18506: LD_EXP 46
18510: PPUSH
18511: LD_STRING D3nW-Cyrus-1
18513: PPUSH
18514: CALL_OW 88
18518: GO 18723
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18520: LD_EXP 45
18524: PUSH
18525: LD_EXP 61
18529: IN
18530: PUSH
18531: LD_EXP 45
18535: PPUSH
18536: CALL_OW 255
18540: PUSH
18541: LD_INT 1
18543: EQUAL
18544: AND
18545: IFFALSE 18561
// Say ( Bobby , D3nW-Bobby-1 ) else
18547: LD_EXP 45
18551: PPUSH
18552: LD_STRING D3nW-Bobby-1
18554: PPUSH
18555: CALL_OW 88
18559: GO 18723
// if Gary in vip and GetSide ( Gary ) = 1 then
18561: LD_EXP 52
18565: PUSH
18566: LD_EXP 61
18570: IN
18571: PUSH
18572: LD_EXP 52
18576: PPUSH
18577: CALL_OW 255
18581: PUSH
18582: LD_INT 1
18584: EQUAL
18585: AND
18586: IFFALSE 18602
// Say ( Gary , D3nW-Gary-1 ) else
18588: LD_EXP 52
18592: PPUSH
18593: LD_STRING D3nW-Gary-1
18595: PPUSH
18596: CALL_OW 88
18600: GO 18723
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18602: LD_EXP 44
18606: PUSH
18607: LD_EXP 61
18611: IN
18612: PUSH
18613: LD_EXP 44
18617: PPUSH
18618: CALL_OW 255
18622: PUSH
18623: LD_INT 1
18625: EQUAL
18626: AND
18627: IFFALSE 18643
// Say ( Donaldson , D3nW-Don-1 ) else
18629: LD_EXP 44
18633: PPUSH
18634: LD_STRING D3nW-Don-1
18636: PPUSH
18637: CALL_OW 88
18641: GO 18723
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18643: LD_EXP 51
18647: PUSH
18648: LD_EXP 61
18652: IN
18653: PUSH
18654: LD_EXP 51
18658: PPUSH
18659: CALL_OW 255
18663: PUSH
18664: LD_INT 1
18666: EQUAL
18667: AND
18668: IFFALSE 18684
// Say ( Cornel , D3nW-Corn-1 ) else
18670: LD_EXP 51
18674: PPUSH
18675: LD_STRING D3nW-Corn-1
18677: PPUSH
18678: CALL_OW 88
18682: GO 18723
// if Frank in vip and GetSide ( Frank ) = 1 then
18684: LD_EXP 53
18688: PUSH
18689: LD_EXP 61
18693: IN
18694: PUSH
18695: LD_EXP 53
18699: PPUSH
18700: CALL_OW 255
18704: PUSH
18705: LD_INT 1
18707: EQUAL
18708: AND
18709: IFFALSE 18723
// Say ( Frank , D3nW-Frank-1 ) ;
18711: LD_EXP 53
18715: PPUSH
18716: LD_STRING D3nW-Frank-1
18718: PPUSH
18719: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18723: LD_EXP 61
18727: PPUSH
18728: LD_INT 22
18730: PUSH
18731: LD_INT 1
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: PPUSH
18738: CALL_OW 72
18742: IFFALSE 18768
// begin Say ( JMM , D3nW-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D3nW-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18756: LD_EXP 40
18760: PPUSH
18761: LD_STRING D3nW-JMM-1a
18763: PPUSH
18764: CALL_OW 88
// end ; t := 0 0$00 ;
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_INT 0
18775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18776: LD_INT 35
18778: PPUSH
18779: CALL_OW 67
// t := t + 0 0$1 ;
18783: LD_ADDR_VAR 0 3
18787: PUSH
18788: LD_VAR 0 3
18792: PUSH
18793: LD_INT 35
18795: PLUS
18796: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18797: LD_INT 59
18799: PPUSH
18800: LD_INT 112
18802: PPUSH
18803: CALL_OW 428
18807: PUSH
18808: LD_VAR 0 3
18812: PUSH
18813: LD_INT 2100
18815: GREATER
18816: OR
18817: IFFALSE 18776
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18819: LD_ADDR_EXP 100
18823: PUSH
18824: LD_EXP 100
18828: PPUSH
18829: LD_INT 4
18831: PPUSH
18832: LD_INT 22
18834: PUSH
18835: LD_INT 4
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 23
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 3
18854: PUSH
18855: LD_INT 21
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: LIST
18873: PPUSH
18874: CALL_OW 69
18878: PUSH
18879: LD_EXP 60
18883: DIFF
18884: PPUSH
18885: CALL_OW 1
18889: ST_TO_ADDR
// activeAttacks := true ;
18890: LD_ADDR_EXP 16
18894: PUSH
18895: LD_INT 1
18897: ST_TO_ADDR
// end ;
18898: LD_VAR 0 1
18902: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18903: LD_INT 0
18905: PPUSH
// case question of 1 :
18906: LD_VAR 0 1
18910: PUSH
18911: LD_INT 1
18913: DOUBLE
18914: EQUAL
18915: IFTRUE 18919
18917: GO 18970
18919: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18920: LD_EXP 40
18924: PPUSH
18925: LD_STRING D2Mot-JMM-1
18927: PPUSH
18928: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18932: LD_EXP 60
18936: PPUSH
18937: LD_STRING D2Mot-Pow-1
18939: PPUSH
18940: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18944: LD_EXP 40
18948: PPUSH
18949: LD_STRING D2Mot-JMM-2
18951: PPUSH
18952: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18956: LD_EXP 60
18960: PPUSH
18961: LD_STRING D2Mot-Pow-2
18963: PPUSH
18964: CALL_OW 88
// end ; 2 :
18968: GO 19321
18970: LD_INT 2
18972: DOUBLE
18973: EQUAL
18974: IFTRUE 18978
18976: GO 19054
18978: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18979: LD_EXP 40
18983: PPUSH
18984: LD_STRING D2Rus-JMM-1
18986: PPUSH
18987: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18991: LD_EXP 60
18995: PPUSH
18996: LD_STRING D2Rus-Pow-1
18998: PPUSH
18999: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19003: LD_EXP 40
19007: PPUSH
19008: LD_STRING D2Rus-JMM-2
19010: PPUSH
19011: CALL_OW 88
// if not ( 3 in list_of_q ) then
19015: LD_INT 3
19017: PUSH
19018: LD_VAR 0 2
19022: IN
19023: NOT
19024: IFFALSE 19040
// Say ( Powell , D2Rus-Pow-2 ) else
19026: LD_EXP 60
19030: PPUSH
19031: LD_STRING D2Rus-Pow-2
19033: PPUSH
19034: CALL_OW 88
19038: GO 19052
// Say ( Powell , D2Rus-Pow-2a ) ;
19040: LD_EXP 60
19044: PPUSH
19045: LD_STRING D2Rus-Pow-2a
19047: PPUSH
19048: CALL_OW 88
// end ; 3 :
19052: GO 19321
19054: LD_INT 3
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19147
19062: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Leg-JMM-1
19070: PPUSH
19071: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19075: LD_EXP 60
19079: PPUSH
19080: LD_STRING D2Leg-Pow-1
19082: PPUSH
19083: CALL_OW 88
// if 2 in list_of_q then
19087: LD_INT 2
19089: PUSH
19090: LD_VAR 0 2
19094: IN
19095: IFFALSE 19121
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19097: LD_EXP 40
19101: PPUSH
19102: LD_STRING D2Leg-JMM-2
19104: PPUSH
19105: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19109: LD_EXP 60
19113: PPUSH
19114: LD_STRING D2Leg-Pow-2
19116: PPUSH
19117: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19121: LD_EXP 40
19125: PPUSH
19126: LD_STRING D2Leg-JMM-3
19128: PPUSH
19129: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19133: LD_EXP 60
19137: PPUSH
19138: LD_STRING D2Leg-Pow-3
19140: PPUSH
19141: CALL_OW 88
// end ; 4 :
19145: GO 19321
19147: LD_INT 4
19149: DOUBLE
19150: EQUAL
19151: IFTRUE 19155
19153: GO 19230
19155: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
19156: LD_EXP 40
19160: PPUSH
19161: LD_STRING D2Ar-JMM-1
19163: PPUSH
19164: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
19168: LD_EXP 60
19172: PPUSH
19173: LD_STRING D2Ar-Pow-1
19175: PPUSH
19176: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19180: LD_EXP 40
19184: PPUSH
19185: LD_STRING D2Ar-JMM-2
19187: PPUSH
19188: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19192: LD_EXP 60
19196: PPUSH
19197: LD_STRING D2Ar-Pow-2
19199: PPUSH
19200: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19204: LD_EXP 40
19208: PPUSH
19209: LD_STRING D2Ar-JMM-3
19211: PPUSH
19212: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19216: LD_EXP 60
19220: PPUSH
19221: LD_STRING D2Ar-Pow-3
19223: PPUSH
19224: CALL_OW 88
// end ; 5 :
19228: GO 19321
19230: LD_INT 5
19232: DOUBLE
19233: EQUAL
19234: IFTRUE 19238
19236: GO 19253
19238: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19239: LD_EXP 40
19243: PPUSH
19244: LD_STRING D2Conf-JMM-1
19246: PPUSH
19247: CALL_OW 88
19251: GO 19321
19253: LD_INT 6
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19320
19261: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19262: LD_EXP 40
19266: PPUSH
19267: LD_STRING D2Com-JMM-1
19269: PPUSH
19270: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19274: LD_EXP 60
19278: PPUSH
19279: LD_STRING D2Com-Pow-1
19281: PPUSH
19282: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19286: LD_EXP 40
19290: PPUSH
19291: LD_STRING D2Com-JMM-2
19293: PPUSH
19294: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19298: LD_EXP 60
19302: PPUSH
19303: LD_STRING D2Com-Pow-2
19305: PPUSH
19306: CALL_OW 88
// powellAngerQuery := true ;
19310: LD_ADDR_EXP 36
19314: PUSH
19315: LD_INT 1
19317: ST_TO_ADDR
// end ; end ;
19318: GO 19321
19320: POP
// end ;
19321: LD_VAR 0 3
19325: RET
// every 0 0$5 trigger missionStart do var tmp ;
19326: LD_EXP 13
19330: IFFALSE 19613
19332: GO 19334
19334: DISABLE
19335: LD_INT 0
19337: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19338: LD_INT 35
19340: PPUSH
19341: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19345: LD_INT 14
19347: PPUSH
19348: LD_INT 22
19350: PUSH
19351: LD_INT 1
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PPUSH
19358: CALL_OW 70
19362: PUSH
19363: LD_EXP 15
19367: PUSH
19368: LD_INT 2
19370: PUSH
19371: LD_INT 3
19373: PUSH
19374: LD_INT 4
19376: PUSH
19377: LD_INT 5
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: IN
19386: AND
19387: IFFALSE 19603
// begin powellAnger := powellAnger + 1 ;
19389: LD_ADDR_EXP 17
19393: PUSH
19394: LD_EXP 17
19398: PUSH
19399: LD_INT 1
19401: PLUS
19402: ST_TO_ADDR
// Video ( true ) ;
19403: LD_INT 1
19405: PPUSH
19406: CALL 105022 0 1
// CenterNowOnUnits ( tmp ) ;
19410: LD_VAR 0 1
19414: PPUSH
19415: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19419: LD_INT 14
19421: PPUSH
19422: LD_INT 22
19424: PUSH
19425: LD_INT 1
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: PPUSH
19432: CALL_OW 70
19436: PPUSH
19437: LD_INT 86
19439: PPUSH
19440: LD_INT 133
19442: PPUSH
19443: CALL_OW 111
// async ;
19447: ASYNC
// case powellAnger of 1 :
19448: LD_EXP 17
19452: PUSH
19453: LD_INT 1
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19476
19461: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19462: LD_EXP 60
19466: PPUSH
19467: LD_STRING DBack1-Pow-1
19469: PPUSH
19470: CALL_OW 88
19474: GO 19523
19476: LD_INT 2
19478: DOUBLE
19479: EQUAL
19480: IFTRUE 19484
19482: GO 19499
19484: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19485: LD_EXP 60
19489: PPUSH
19490: LD_STRING DBack2-Pow-1
19492: PPUSH
19493: CALL_OW 88
19497: GO 19523
19499: LD_INT 3
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19522
19507: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19508: LD_EXP 60
19512: PPUSH
19513: LD_STRING DBack3-Pow-1
19515: PPUSH
19516: CALL_OW 88
19520: GO 19523
19522: POP
// sync ;
19523: SYNC
// repeat wait ( 0 0$1 ) ;
19524: LD_INT 35
19526: PPUSH
19527: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19531: LD_INT 14
19533: PPUSH
19534: LD_INT 22
19536: PUSH
19537: LD_INT 1
19539: PUSH
19540: EMPTY
19541: LIST
19542: LIST
19543: PPUSH
19544: CALL_OW 70
19548: PPUSH
19549: LD_INT 86
19551: PPUSH
19552: LD_INT 133
19554: PPUSH
19555: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19559: LD_INT 14
19561: PPUSH
19562: LD_INT 22
19564: PUSH
19565: LD_INT 1
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 70
19576: NOT
19577: IFFALSE 19524
// if powellAnger >= 3 then
19579: LD_EXP 17
19583: PUSH
19584: LD_INT 3
19586: GREATEREQUAL
19587: IFFALSE 19596
// YouLost ( Dismissed ) ;
19589: LD_STRING Dismissed
19591: PPUSH
19592: CALL_OW 104
// Video ( false ) ;
19596: LD_INT 0
19598: PPUSH
19599: CALL 105022 0 1
// end ; until missionStage > 5 ;
19603: LD_EXP 15
19607: PUSH
19608: LD_INT 5
19610: GREATER
19611: IFFALSE 19338
// end ;
19613: PPOPN 1
19615: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19616: LD_EXP 13
19620: PUSH
19621: LD_INT 22
19623: PUSH
19624: LD_INT 4
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PUSH
19631: LD_INT 21
19633: PUSH
19634: LD_INT 2
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PPUSH
19645: CALL_OW 69
19649: PUSH
19650: LD_INT 4
19652: GREATEREQUAL
19653: AND
19654: PUSH
19655: LD_EXP 15
19659: PUSH
19660: LD_INT 2
19662: EQUAL
19663: AND
19664: IFFALSE 21854
19666: GO 19668
19668: DISABLE
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
19677: PPUSH
19678: PPUSH
19679: PPUSH
19680: PPUSH
// begin missionStage := 3 ;
19681: LD_ADDR_EXP 15
19685: PUSH
19686: LD_INT 3
19688: ST_TO_ADDR
// retreat := false ;
19689: LD_ADDR_VAR 0 4
19693: PUSH
19694: LD_INT 0
19696: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_INT 22
19704: PUSH
19705: LD_INT 4
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 30
19714: PUSH
19715: LD_INT 4
19717: PUSH
19718: EMPTY
19719: LIST
19720: LIST
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: PPUSH
19726: CALL_OW 69
19730: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19731: LD_ADDR_VAR 0 6
19735: PUSH
19736: LD_INT 22
19738: PUSH
19739: LD_INT 4
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 30
19748: PUSH
19749: LD_INT 5
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: ST_TO_ADDR
// if not bar then
19765: LD_VAR 0 6
19769: NOT
19770: IFFALSE 19823
// begin repeat wait ( 0 0$1 ) ;
19772: LD_INT 35
19774: PPUSH
19775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19779: LD_INT 22
19781: PUSH
19782: LD_INT 4
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PUSH
19789: LD_INT 3
19791: PUSH
19792: LD_INT 57
19794: PUSH
19795: EMPTY
19796: LIST
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PUSH
19802: LD_INT 30
19804: PUSH
19805: LD_INT 5
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: LIST
19816: PPUSH
19817: CALL_OW 69
19821: IFFALSE 19772
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19823: LD_ADDR_VAR 0 6
19827: PUSH
19828: LD_INT 22
19830: PUSH
19831: LD_INT 4
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: LD_INT 30
19840: PUSH
19841: LD_INT 5
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: PPUSH
19852: CALL_OW 69
19856: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19857: LD_INT 35
19859: PPUSH
19860: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19864: LD_EXP 119
19868: PUSH
19869: LD_INT 4
19871: ARRAY
19872: PUSH
19873: LD_INT 4
19875: GREATEREQUAL
19876: IFFALSE 19857
// tmp := [ ] ;
19878: LD_ADDR_VAR 0 2
19882: PUSH
19883: EMPTY
19884: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19885: LD_ADDR_VAR 0 1
19889: PUSH
19890: LD_INT 22
19892: PUSH
19893: LD_INT 4
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 2
19902: PUSH
19903: LD_INT 25
19905: PUSH
19906: LD_INT 1
19908: PUSH
19909: EMPTY
19910: LIST
19911: LIST
19912: PUSH
19913: LD_INT 25
19915: PUSH
19916: LD_INT 2
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: LD_INT 25
19925: PUSH
19926: LD_INT 3
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: LD_INT 25
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: PUSH
19943: LD_INT 25
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: PPUSH
19965: CALL_OW 69
19969: PUSH
19970: LD_EXP 60
19974: PUSH
19975: LD_EXP 61
19979: ADD
19980: DIFF
19981: PUSH
19982: FOR_IN
19983: IFFALSE 20047
// if GetTag ( i ) = 1 then
19985: LD_VAR 0 1
19989: PPUSH
19990: CALL_OW 110
19994: PUSH
19995: LD_INT 1
19997: EQUAL
19998: IFFALSE 20022
// tmp := Join ( tmp , i ) else
20000: LD_ADDR_VAR 0 2
20004: PUSH
20005: LD_VAR 0 2
20009: PPUSH
20010: LD_VAR 0 1
20014: PPUSH
20015: CALL 105050 0 2
20019: ST_TO_ADDR
20020: GO 20045
// tmp := Insert ( tmp , 1 , i ) ;
20022: LD_ADDR_VAR 0 2
20026: PUSH
20027: LD_VAR 0 2
20031: PPUSH
20032: LD_INT 1
20034: PPUSH
20035: LD_VAR 0 1
20039: PPUSH
20040: CALL_OW 2
20044: ST_TO_ADDR
20045: GO 19982
20047: POP
20048: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20049: LD_ADDR_VAR 0 3
20053: PUSH
20054: LD_VAR 0 2
20058: PPUSH
20059: LD_INT 26
20061: PUSH
20062: LD_INT 1
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PPUSH
20069: CALL_OW 72
20073: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20074: LD_ADDR_VAR 0 2
20078: PUSH
20079: LD_VAR 0 2
20083: PUSH
20084: LD_VAR 0 3
20088: DIFF
20089: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20090: LD_ADDR_VAR 0 2
20094: PUSH
20095: LD_VAR 0 2
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: CALL 103566 0 2
20107: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_VAR 0 3
20117: PPUSH
20118: LD_INT 3
20120: PPUSH
20121: CALL 103566 0 2
20125: ST_TO_ADDR
// for i := 1 to 4 do
20126: LD_ADDR_VAR 0 1
20130: PUSH
20131: DOUBLE
20132: LD_INT 1
20134: DEC
20135: ST_TO_ADDR
20136: LD_INT 4
20138: PUSH
20139: FOR_TO
20140: IFFALSE 20293
// begin if tmp2 then
20142: LD_VAR 0 3
20146: IFFALSE 20214
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20148: LD_ADDR_EXP 18
20152: PUSH
20153: LD_EXP 18
20157: PPUSH
20158: LD_INT 1
20160: PPUSH
20161: LD_EXP 18
20165: PUSH
20166: LD_INT 1
20168: ARRAY
20169: PUSH
20170: LD_VAR 0 3
20174: PUSH
20175: LD_VAR 0 3
20179: ARRAY
20180: ADD
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20187: LD_VAR 0 3
20191: PUSH
20192: LD_VAR 0 3
20196: ARRAY
20197: PPUSH
20198: LD_INT 1
20200: PPUSH
20201: CALL_OW 109
// tmp2 := [ ] ;
20205: LD_ADDR_VAR 0 3
20209: PUSH
20210: EMPTY
20211: ST_TO_ADDR
// end else
20212: GO 20291
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20214: LD_ADDR_EXP 18
20218: PUSH
20219: LD_EXP 18
20223: PPUSH
20224: LD_INT 1
20226: PPUSH
20227: LD_EXP 18
20231: PUSH
20232: LD_INT 1
20234: ARRAY
20235: PUSH
20236: LD_VAR 0 2
20240: PUSH
20241: LD_VAR 0 2
20245: ARRAY
20246: ADD
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20253: LD_VAR 0 2
20257: PUSH
20258: LD_VAR 0 2
20262: ARRAY
20263: PPUSH
20264: LD_INT 1
20266: PPUSH
20267: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20271: LD_ADDR_VAR 0 2
20275: PUSH
20276: LD_VAR 0 2
20280: PPUSH
20281: LD_VAR 0 2
20285: PPUSH
20286: CALL_OW 3
20290: ST_TO_ADDR
// end ; end ;
20291: GO 20139
20293: POP
20294: POP
// if tmp2 then
20295: LD_VAR 0 3
20299: IFFALSE 20317
// tmp := tmp union tmp2 ;
20301: LD_ADDR_VAR 0 2
20305: PUSH
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 3
20315: UNION
20316: ST_TO_ADDR
// for i := 1 to 4 do
20317: LD_ADDR_VAR 0 1
20321: PUSH
20322: DOUBLE
20323: LD_INT 1
20325: DEC
20326: ST_TO_ADDR
20327: LD_INT 4
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20380
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20333: LD_ADDR_EXP 18
20337: PUSH
20338: LD_EXP 18
20342: PPUSH
20343: LD_INT 2
20345: PPUSH
20346: LD_EXP 18
20350: PUSH
20351: LD_INT 2
20353: ARRAY
20354: PUSH
20355: LD_VAR 0 2
20359: PUSH
20360: LD_VAR 0 2
20364: PUSH
20365: LD_VAR 0 1
20369: MINUS
20370: ARRAY
20371: ADD
20372: PPUSH
20373: CALL_OW 1
20377: ST_TO_ADDR
20378: GO 20330
20380: POP
20381: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20382: LD_ADDR_EXP 100
20386: PUSH
20387: LD_EXP 100
20391: PPUSH
20392: LD_INT 4
20394: PPUSH
20395: LD_EXP 100
20399: PUSH
20400: LD_INT 4
20402: ARRAY
20403: PUSH
20404: LD_EXP 18
20408: PUSH
20409: LD_INT 1
20411: ARRAY
20412: DIFF
20413: PPUSH
20414: CALL_OW 1
20418: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20419: LD_VAR 0 5
20423: PUSH
20424: LD_INT 1
20426: ARRAY
20427: PPUSH
20428: CALL_OW 313
20432: IFFALSE 20487
// begin for i in UnitsInside ( arm [ 1 ] ) do
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 5
20443: PUSH
20444: LD_INT 1
20446: ARRAY
20447: PPUSH
20448: CALL_OW 313
20452: PUSH
20453: FOR_IN
20454: IFFALSE 20485
// begin ComExitBuilding ( i ) ;
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20465: LD_VAR 0 1
20469: PPUSH
20470: LD_VAR 0 6
20474: PUSH
20475: LD_INT 1
20477: ARRAY
20478: PPUSH
20479: CALL_OW 180
// end ;
20483: GO 20453
20485: POP
20486: POP
// end ; wait ( 0 0$3 ) ;
20487: LD_INT 105
20489: PPUSH
20490: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20494: LD_ADDR_VAR 0 1
20498: PUSH
20499: LD_EXP 18
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PUSH
20508: FOR_IN
20509: IFFALSE 20616
// begin if IsInUnit ( i ) then
20511: LD_VAR 0 1
20515: PPUSH
20516: CALL_OW 310
20520: IFFALSE 20531
// ComExitBuilding ( i ) ;
20522: LD_VAR 0 1
20526: PPUSH
20527: CALL_OW 122
// if GetClass ( i ) <> 1 then
20531: LD_VAR 0 1
20535: PPUSH
20536: CALL_OW 257
20540: PUSH
20541: LD_INT 1
20543: NONEQUAL
20544: IFFALSE 20585
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20546: LD_VAR 0 1
20550: PPUSH
20551: LD_VAR 0 5
20555: PUSH
20556: LD_INT 1
20558: ARRAY
20559: PPUSH
20560: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20564: LD_VAR 0 1
20568: PPUSH
20569: LD_INT 1
20571: PPUSH
20572: CALL_OW 183
// AddComExitBuilding ( i ) ;
20576: LD_VAR 0 1
20580: PPUSH
20581: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20585: LD_VAR 0 1
20589: PPUSH
20590: LD_INT 60
20592: PPUSH
20593: LD_INT 94
20595: PPUSH
20596: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20600: LD_VAR 0 1
20604: PPUSH
20605: LD_EXP 60
20609: PPUSH
20610: CALL_OW 179
// end ;
20614: GO 20508
20616: POP
20617: POP
// wait ( 0 0$10 ) ;
20618: LD_INT 350
20620: PPUSH
20621: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20625: LD_EXP 60
20629: PPUSH
20630: LD_STRING D4-Pow-1
20632: PPUSH
20633: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20637: LD_ADDR_VAR 0 2
20641: PUSH
20642: LD_EXP 18
20646: PUSH
20647: LD_INT 1
20649: ARRAY
20650: PPUSH
20651: LD_INT 26
20653: PUSH
20654: LD_INT 1
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: ST_TO_ADDR
// if tmp then
20666: LD_VAR 0 2
20670: IFFALSE 20688
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20672: LD_VAR 0 2
20676: PUSH
20677: LD_INT 1
20679: ARRAY
20680: PPUSH
20681: LD_STRING D4-Sol1-1
20683: PPUSH
20684: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20688: LD_EXP 60
20692: PPUSH
20693: LD_STRING D4-Pow-2
20695: PPUSH
20696: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20700: LD_ADDR_VAR 0 1
20704: PUSH
20705: DOUBLE
20706: LD_INT 1
20708: DEC
20709: ST_TO_ADDR
20710: LD_EXP 18
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20813
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20722: LD_EXP 18
20726: PUSH
20727: LD_INT 1
20729: ARRAY
20730: PUSH
20731: LD_VAR 0 1
20735: ARRAY
20736: PPUSH
20737: LD_EXP 119
20741: PUSH
20742: LD_INT 4
20744: ARRAY
20745: PUSH
20746: LD_INT 1
20748: ARRAY
20749: PPUSH
20750: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20754: LD_ADDR_EXP 119
20758: PUSH
20759: LD_EXP 119
20763: PPUSH
20764: LD_INT 4
20766: PPUSH
20767: LD_EXP 119
20771: PUSH
20772: LD_INT 4
20774: ARRAY
20775: PPUSH
20776: LD_INT 1
20778: PPUSH
20779: CALL_OW 3
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20789: LD_INT 8
20791: PPUSH
20792: LD_EXP 18
20796: PUSH
20797: LD_INT 1
20799: ARRAY
20800: PUSH
20801: LD_VAR 0 1
20805: ARRAY
20806: PPUSH
20807: CALL_OW 471
// end ;
20811: GO 20719
20813: POP
20814: POP
// repeat wait ( 0 0$1 ) ;
20815: LD_INT 35
20817: PPUSH
20818: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20822: LD_EXP 18
20826: PUSH
20827: LD_INT 1
20829: ARRAY
20830: PPUSH
20831: LD_INT 55
20833: PUSH
20834: EMPTY
20835: LIST
20836: PPUSH
20837: CALL_OW 72
20841: PUSH
20842: LD_INT 4
20844: GREATEREQUAL
20845: IFFALSE 20815
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20847: LD_EXP 18
20851: PUSH
20852: LD_INT 1
20854: ARRAY
20855: PPUSH
20856: LD_INT 69
20858: PPUSH
20859: LD_INT 94
20861: PPUSH
20862: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20866: LD_EXP 18
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: LD_INT 82
20877: PPUSH
20878: LD_INT 83
20880: PPUSH
20881: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20885: LD_EXP 18
20889: PUSH
20890: LD_INT 1
20892: ARRAY
20893: PPUSH
20894: LD_INT 77
20896: PPUSH
20897: LD_INT 69
20899: PPUSH
20900: CALL_OW 174
// repeat wait ( 3 ) ;
20904: LD_INT 3
20906: PPUSH
20907: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20911: LD_ADDR_VAR 0 1
20915: PUSH
20916: LD_EXP 18
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PUSH
20925: FOR_IN
20926: IFFALSE 21062
// begin if GetLives ( i ) < 990 then
20928: LD_VAR 0 1
20932: PPUSH
20933: CALL_OW 256
20937: PUSH
20938: LD_INT 990
20940: LESS
20941: IFFALSE 20955
// SetLives ( i , 1000 ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_INT 1000
20950: PPUSH
20951: CALL_OW 234
// if not IsInUnit ( i ) then
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 310
20964: NOT
20965: IFFALSE 21060
// begin if not HasTask ( i ) then
20967: LD_VAR 0 1
20971: PPUSH
20972: CALL_OW 314
20976: NOT
20977: IFFALSE 20994
// ComMoveXY ( i , 64 , 93 ) ;
20979: LD_VAR 0 1
20983: PPUSH
20984: LD_INT 64
20986: PPUSH
20987: LD_INT 93
20989: PPUSH
20990: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20994: LD_VAR 0 4
20998: NOT
20999: PUSH
21000: LD_VAR 0 1
21004: PPUSH
21005: CALL_OW 258
21009: PUSH
21010: LD_INT 1
21012: EQUAL
21013: AND
21014: IFFALSE 21060
// begin retreat := true ;
21016: LD_ADDR_VAR 0 4
21020: PUSH
21021: LD_INT 1
21023: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21024: LD_VAR 0 1
21028: PPUSH
21029: LD_INT 2
21031: PPUSH
21032: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21036: LD_VAR 0 1
21040: PPUSH
21041: LD_STRING D4a-Sol1-1
21043: PPUSH
21044: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21048: LD_EXP 60
21052: PPUSH
21053: LD_STRING D4a-Pow-1
21055: PPUSH
21056: CALL_OW 88
// end ; end ; end ;
21060: GO 20925
21062: POP
21063: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21064: LD_EXP 18
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: LD_INT 95
21075: PUSH
21076: LD_INT 9
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 55
21088: PUSH
21089: EMPTY
21090: LIST
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PPUSH
21100: CALL_OW 72
21104: PUSH
21105: LD_INT 4
21107: GREATEREQUAL
21108: IFFALSE 20904
// for i in powellSquadAttack [ 1 ] do
21110: LD_ADDR_VAR 0 1
21114: PUSH
21115: LD_EXP 18
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PUSH
21124: FOR_IN
21125: IFFALSE 21261
// begin if GetTag ( i ) = 2 then
21127: LD_VAR 0 1
21131: PPUSH
21132: CALL_OW 110
21136: PUSH
21137: LD_INT 2
21139: EQUAL
21140: IFFALSE 21202
// begin ComMoveXY ( i , 60 , 94 ) ;
21142: LD_VAR 0 1
21146: PPUSH
21147: LD_INT 60
21149: PPUSH
21150: LD_INT 94
21152: PPUSH
21153: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
21157: LD_VAR 0 1
21161: PPUSH
21162: LD_EXP 60
21166: PPUSH
21167: CALL_OW 179
// wait ( 0 0$3 ) ;
21171: LD_INT 105
21173: PPUSH
21174: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21178: LD_VAR 0 1
21182: PPUSH
21183: LD_STRING D4a-Sol1-2
21185: PPUSH
21186: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21190: LD_EXP 60
21194: PPUSH
21195: LD_STRING D4a-Pow-2
21197: PPUSH
21198: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_INT 0
21209: PPUSH
21210: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21214: LD_ADDR_EXP 100
21218: PUSH
21219: LD_EXP 100
21223: PPUSH
21224: LD_INT 4
21226: PPUSH
21227: LD_EXP 100
21231: PUSH
21232: LD_INT 4
21234: ARRAY
21235: PUSH
21236: LD_VAR 0 1
21240: UNION
21241: PPUSH
21242: CALL_OW 1
21246: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21247: LD_INT 8
21249: PPUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: CALL_OW 472
// end ;
21259: GO 21124
21261: POP
21262: POP
// wait ( 2 2$00 ) ;
21263: LD_INT 4200
21265: PPUSH
21266: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21270: LD_ADDR_VAR 0 9
21274: PUSH
21275: LD_INT 22
21277: PUSH
21278: LD_INT 4
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: LD_INT 30
21287: PUSH
21288: LD_INT 32
21290: PUSH
21291: EMPTY
21292: LIST
21293: LIST
21294: PUSH
21295: LD_INT 58
21297: PUSH
21298: EMPTY
21299: LIST
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: LIST
21305: PPUSH
21306: CALL_OW 69
21310: ST_TO_ADDR
// if tmp then
21311: LD_VAR 0 2
21315: IFFALSE 21555
// begin for i := 1 to tmp do
21317: LD_ADDR_VAR 0 1
21321: PUSH
21322: DOUBLE
21323: LD_INT 1
21325: DEC
21326: ST_TO_ADDR
21327: LD_VAR 0 2
21331: PUSH
21332: FOR_TO
21333: IFFALSE 21546
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21335: LD_ADDR_EXP 100
21339: PUSH
21340: LD_EXP 100
21344: PPUSH
21345: LD_INT 4
21347: PPUSH
21348: LD_EXP 100
21352: PUSH
21353: LD_INT 4
21355: ARRAY
21356: PUSH
21357: LD_VAR 0 2
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: DIFF
21368: PPUSH
21369: CALL_OW 1
21373: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21374: LD_ADDR_VAR 0 10
21378: PUSH
21379: LD_VAR 0 2
21383: PUSH
21384: LD_VAR 0 1
21388: ARRAY
21389: PPUSH
21390: CALL_OW 310
21394: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21395: LD_VAR 0 10
21399: PUSH
21400: LD_VAR 0 10
21404: PPUSH
21405: CALL_OW 266
21409: PUSH
21410: LD_INT 32
21412: EQUAL
21413: AND
21414: IFFALSE 21418
// continue ;
21416: GO 21332
// if t then
21418: LD_VAR 0 10
21422: IFFALSE 21439
// ComExitBuilding ( tmp [ i ] ) ;
21424: LD_VAR 0 2
21428: PUSH
21429: LD_VAR 0 1
21433: ARRAY
21434: PPUSH
21435: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21439: LD_VAR 0 2
21443: PUSH
21444: LD_VAR 0 1
21448: ARRAY
21449: PPUSH
21450: LD_VAR 0 5
21454: PUSH
21455: LD_INT 1
21457: ARRAY
21458: PPUSH
21459: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21463: LD_VAR 0 2
21467: PUSH
21468: LD_VAR 0 1
21472: ARRAY
21473: PPUSH
21474: LD_INT 1
21476: PPUSH
21477: CALL_OW 183
// if emptyTowers then
21481: LD_VAR 0 9
21485: IFFALSE 21544
// begin AddComExitBuilding ( tmp [ i ] ) ;
21487: LD_VAR 0 2
21491: PUSH
21492: LD_VAR 0 1
21496: ARRAY
21497: PPUSH
21498: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21502: LD_VAR 0 2
21506: PUSH
21507: LD_VAR 0 1
21511: ARRAY
21512: PPUSH
21513: LD_VAR 0 9
21517: PUSH
21518: LD_INT 1
21520: ARRAY
21521: PPUSH
21522: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21526: LD_ADDR_VAR 0 9
21530: PUSH
21531: LD_VAR 0 9
21535: PPUSH
21536: LD_INT 1
21538: PPUSH
21539: CALL_OW 3
21543: ST_TO_ADDR
// end ; end ;
21544: GO 21332
21546: POP
21547: POP
// wait ( 0 0$30 ) ;
21548: LD_INT 1050
21550: PPUSH
21551: CALL_OW 67
// end ; uc_side := 6 ;
21555: LD_ADDR_OWVAR 20
21559: PUSH
21560: LD_INT 6
21562: ST_TO_ADDR
// uc_nation := 3 ;
21563: LD_ADDR_OWVAR 21
21567: PUSH
21568: LD_INT 3
21570: ST_TO_ADDR
// ru := [ ] ;
21571: LD_ADDR_VAR 0 7
21575: PUSH
21576: EMPTY
21577: ST_TO_ADDR
// for i = 1 to 5 do
21578: LD_ADDR_VAR 0 1
21582: PUSH
21583: DOUBLE
21584: LD_INT 1
21586: DEC
21587: ST_TO_ADDR
21588: LD_INT 5
21590: PUSH
21591: FOR_TO
21592: IFFALSE 21712
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21594: LD_INT 22
21596: PUSH
21597: LD_INT 23
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 1
21606: PPUSH
21607: LD_INT 2
21609: PPUSH
21610: CALL_OW 12
21614: ARRAY
21615: PPUSH
21616: LD_INT 1
21618: PPUSH
21619: LD_INT 3
21621: PPUSH
21622: LD_INT 43
21624: PUSH
21625: LD_INT 44
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 1
21634: PPUSH
21635: LD_INT 2
21637: PPUSH
21638: CALL_OW 12
21642: ARRAY
21643: PPUSH
21644: LD_INT 89
21646: PPUSH
21647: CALL 72597 0 5
// un := CreateVehicle ;
21651: LD_ADDR_VAR 0 8
21655: PUSH
21656: CALL_OW 45
21660: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21661: LD_VAR 0 8
21665: PPUSH
21666: LD_INT 4
21668: PPUSH
21669: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21673: LD_VAR 0 8
21677: PPUSH
21678: LD_INT 136
21680: PPUSH
21681: LD_INT 90
21683: PPUSH
21684: LD_INT 8
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 50
// ru := ru ^ un ;
21694: LD_ADDR_VAR 0 7
21698: PUSH
21699: LD_VAR 0 7
21703: PUSH
21704: LD_VAR 0 8
21708: ADD
21709: ST_TO_ADDR
// end ;
21710: GO 21591
21712: POP
21713: POP
// if ru then
21714: LD_VAR 0 7
21718: IFFALSE 21735
// ComAgressiveMove ( ru , 57 , 94 ) ;
21720: LD_VAR 0 7
21724: PPUSH
21725: LD_INT 57
21727: PPUSH
21728: LD_INT 94
21730: PPUSH
21731: CALL_OW 114
// wait ( 3 3$00 ) ;
21735: LD_INT 6300
21737: PPUSH
21738: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21742: LD_INT 4
21744: PPUSH
21745: LD_INT 3
21747: PUSH
21748: LD_INT 1
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 5
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 4
21765: PUSH
21766: LD_INT 1
21768: PUSH
21769: LD_INT 1
21771: PUSH
21772: LD_INT 6
21774: PUSH
21775: EMPTY
21776: LIST
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 4
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: LD_INT 1
21789: PUSH
21790: LD_INT 7
21792: PUSH
21793: EMPTY
21794: LIST
21795: LIST
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 3
21801: PUSH
21802: LD_INT 1
21804: PUSH
21805: LD_INT 1
21807: PUSH
21808: LD_INT 7
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: PUSH
21817: LD_INT 3
21819: PUSH
21820: LD_INT 1
21822: PUSH
21823: LD_INT 1
21825: PUSH
21826: LD_INT 5
21828: PUSH
21829: EMPTY
21830: LIST
21831: LIST
21832: LIST
21833: LIST
21834: PUSH
21835: EMPTY
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: PPUSH
21842: CALL 61108 0 2
// missionStage := 4 ;
21846: LD_ADDR_EXP 15
21850: PUSH
21851: LD_INT 4
21853: ST_TO_ADDR
// end ;
21854: PPOPN 10
21856: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21857: LD_EXP 15
21861: PUSH
21862: LD_INT 4
21864: EQUAL
21865: PUSH
21866: LD_INT 22
21868: PUSH
21869: LD_INT 4
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: LD_INT 21
21878: PUSH
21879: LD_INT 2
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PUSH
21886: EMPTY
21887: LIST
21888: LIST
21889: PPUSH
21890: CALL_OW 69
21894: PUSH
21895: LD_INT 5
21897: GREATEREQUAL
21898: AND
21899: IFFALSE 26112
21901: GO 21903
21903: DISABLE
21904: LD_INT 0
21906: PPUSH
21907: PPUSH
21908: PPUSH
21909: PPUSH
21910: PPUSH
21911: PPUSH
21912: PPUSH
21913: PPUSH
21914: PPUSH
21915: PPUSH
21916: PPUSH
21917: PPUSH
21918: PPUSH
// begin wait ( 0 0$10 ) ;
21919: LD_INT 350
21921: PPUSH
21922: CALL_OW 67
// missionStage := 5 ;
21926: LD_ADDR_EXP 15
21930: PUSH
21931: LD_INT 5
21933: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21934: LD_ADDR_VAR 0 10
21938: PUSH
21939: LD_INT 22
21941: PUSH
21942: LD_INT 4
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 2
21951: PUSH
21952: LD_INT 30
21954: PUSH
21955: LD_INT 4
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: PUSH
21962: LD_INT 30
21964: PUSH
21965: LD_INT 5
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: LIST
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PPUSH
21981: CALL_OW 69
21985: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21986: LD_ADDR_VAR 0 6
21990: PUSH
21991: LD_INT 22
21993: PUSH
21994: LD_INT 4
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 21
22003: PUSH
22004: LD_INT 1
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: LD_INT 3
22013: PUSH
22014: LD_INT 25
22016: PUSH
22017: LD_INT 16
22019: PUSH
22020: EMPTY
22021: LIST
22022: LIST
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 3
22030: PUSH
22031: LD_INT 25
22033: PUSH
22034: LD_INT 12
22036: PUSH
22037: EMPTY
22038: LIST
22039: LIST
22040: PUSH
22041: EMPTY
22042: LIST
22043: LIST
22044: PUSH
22045: EMPTY
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: PPUSH
22051: CALL_OW 69
22055: PUSH
22056: LD_EXP 60
22060: DIFF
22061: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22062: LD_ADDR_VAR 0 9
22066: PUSH
22067: LD_INT 22
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PPUSH
22091: CALL_OW 69
22095: PUSH
22096: LD_INT 1
22098: ARRAY
22099: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22100: LD_INT 350
22102: PPUSH
22103: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22107: LD_EXP 119
22111: PUSH
22112: LD_INT 4
22114: ARRAY
22115: PUSH
22116: LD_INT 5
22118: LESS
22119: PUSH
22120: LD_VAR 0 9
22124: PPUSH
22125: CALL_OW 461
22129: PUSH
22130: LD_INT 2
22132: EQUAL
22133: AND
22134: IFFALSE 22164
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22136: LD_INT 4
22138: PPUSH
22139: LD_INT 3
22141: PUSH
22142: LD_INT 1
22144: PUSH
22145: LD_INT 1
22147: PUSH
22148: LD_INT 5
22150: PUSH
22151: EMPTY
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: PUSH
22157: EMPTY
22158: LIST
22159: PPUSH
22160: CALL 61156 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
22164: LD_EXP 119
22168: PUSH
22169: LD_INT 4
22171: ARRAY
22172: PUSH
22173: LD_INT 5
22175: GREATEREQUAL
22176: PUSH
22177: LD_EXP 119
22181: PUSH
22182: LD_INT 4
22184: ARRAY
22185: PPUSH
22186: LD_INT 58
22188: PUSH
22189: EMPTY
22190: LIST
22191: PPUSH
22192: CALL_OW 72
22196: PUSH
22197: LD_INT 5
22199: GREATEREQUAL
22200: AND
22201: IFFALSE 22100
// powellAllowRetreat := false ;
22203: LD_ADDR_EXP 19
22207: PUSH
22208: LD_INT 0
22210: ST_TO_ADDR
// activeAttacks := false ;
22211: LD_ADDR_EXP 16
22215: PUSH
22216: LD_INT 0
22218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22219: LD_INT 35
22221: PPUSH
22222: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22226: LD_INT 22
22228: PUSH
22229: LD_INT 6
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PPUSH
22236: CALL_OW 69
22240: PUSH
22241: LD_INT 0
22243: EQUAL
22244: IFFALSE 22219
// tmp := mc_vehicles [ 4 ] ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_EXP 119
22255: PUSH
22256: LD_INT 4
22258: ARRAY
22259: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22260: LD_ADDR_VAR 0 1
22264: PUSH
22265: DOUBLE
22266: LD_INT 1
22268: DEC
22269: ST_TO_ADDR
22270: LD_EXP 18
22274: PUSH
22275: FOR_TO
22276: IFFALSE 22537
// begin for j in powellSquadAttack [ i ] do
22278: LD_ADDR_VAR 0 2
22282: PUSH
22283: LD_EXP 18
22287: PUSH
22288: LD_VAR 0 1
22292: ARRAY
22293: PUSH
22294: FOR_IN
22295: IFFALSE 22533
// begin forces := forces diff j ;
22297: LD_ADDR_VAR 0 6
22301: PUSH
22302: LD_VAR 0 6
22306: PUSH
22307: LD_VAR 0 2
22311: DIFF
22312: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22313: LD_VAR 0 2
22317: PPUSH
22318: LD_INT 1
22320: PPUSH
22321: CALL_OW 109
// wait ( 0 0$2 ) ;
22325: LD_INT 70
22327: PPUSH
22328: CALL_OW 67
// if IsInUnit ( j ) then
22332: LD_VAR 0 2
22336: PPUSH
22337: CALL_OW 310
22341: IFFALSE 22352
// ComExitBuilding ( j ) ;
22343: LD_VAR 0 2
22347: PPUSH
22348: CALL_OW 122
// if GetClass ( j ) <> 1 then
22352: LD_VAR 0 2
22356: PPUSH
22357: CALL_OW 257
22361: PUSH
22362: LD_INT 1
22364: NONEQUAL
22365: IFFALSE 22445
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22367: LD_VAR 0 10
22371: PUSH
22372: LD_INT 1
22374: ARRAY
22375: PPUSH
22376: CALL_OW 313
22380: PUSH
22381: LD_INT 5
22383: GREATEREQUAL
22384: IFFALSE 22406
// AddComEnterUnit ( j , arm [ 2 ] ) else
22386: LD_VAR 0 2
22390: PPUSH
22391: LD_VAR 0 10
22395: PUSH
22396: LD_INT 2
22398: ARRAY
22399: PPUSH
22400: CALL_OW 180
22404: GO 22424
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22406: LD_VAR 0 2
22410: PPUSH
22411: LD_VAR 0 10
22415: PUSH
22416: LD_INT 1
22418: ARRAY
22419: PPUSH
22420: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22424: LD_VAR 0 2
22428: PPUSH
22429: LD_INT 1
22431: PPUSH
22432: CALL_OW 183
// AddComExitBuilding ( j ) ;
22436: LD_VAR 0 2
22440: PPUSH
22441: CALL_OW 182
// end ; if i = 2 then
22445: LD_VAR 0 1
22449: PUSH
22450: LD_INT 2
22452: EQUAL
22453: IFFALSE 22470
// AddComMoveXY ( j , 61 , 93 ) ;
22455: LD_VAR 0 2
22459: PPUSH
22460: LD_INT 61
22462: PPUSH
22463: LD_INT 93
22465: PPUSH
22466: CALL_OW 171
// if i = 1 then
22470: LD_VAR 0 1
22474: PUSH
22475: LD_INT 1
22477: EQUAL
22478: IFFALSE 22531
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22480: LD_VAR 0 2
22484: PPUSH
22485: LD_VAR 0 3
22489: PUSH
22490: LD_INT 1
22492: ARRAY
22493: PPUSH
22494: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_VAR 0 3
22507: PPUSH
22508: LD_INT 1
22510: PPUSH
22511: CALL_OW 3
22515: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22516: LD_VAR 0 2
22520: PPUSH
22521: LD_INT 69
22523: PPUSH
22524: LD_INT 94
22526: PPUSH
22527: CALL_OW 171
// end ; end ;
22531: GO 22294
22533: POP
22534: POP
// end ;
22535: GO 22275
22537: POP
22538: POP
// wait ( 0 0$30 ) ;
22539: LD_INT 1050
22541: PPUSH
22542: CALL_OW 67
// MC_Kill ( 4 ) ;
22546: LD_INT 4
22548: PPUSH
22549: CALL 37129 0 1
// tmp := UnitsInside ( fac ) ;
22553: LD_ADDR_VAR 0 3
22557: PUSH
22558: LD_VAR 0 9
22562: PPUSH
22563: CALL_OW 313
22567: ST_TO_ADDR
// if tmp then
22568: LD_VAR 0 3
22572: IFFALSE 22693
// for i in tmp do
22574: LD_ADDR_VAR 0 1
22578: PUSH
22579: LD_VAR 0 3
22583: PUSH
22584: FOR_IN
22585: IFFALSE 22691
// begin ComExitBuilding ( i ) ;
22587: LD_VAR 0 1
22591: PPUSH
22592: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22596: LD_VAR 0 10
22600: PUSH
22601: LD_INT 2
22603: ARRAY
22604: PPUSH
22605: CALL_OW 313
22609: PUSH
22610: LD_INT 6
22612: LESS
22613: IFFALSE 22635
// AddComEnterUnit ( i , arm [ 2 ] ) else
22615: LD_VAR 0 1
22619: PPUSH
22620: LD_VAR 0 10
22624: PUSH
22625: LD_INT 2
22627: ARRAY
22628: PPUSH
22629: CALL_OW 180
22633: GO 22689
// if UnitsInside ( arm [ 1 ] ) < 6 then
22635: LD_VAR 0 10
22639: PUSH
22640: LD_INT 1
22642: ARRAY
22643: PPUSH
22644: CALL_OW 313
22648: PUSH
22649: LD_INT 6
22651: LESS
22652: IFFALSE 22674
// AddComEnterUnit ( i , arm [ 1 ] ) else
22654: LD_VAR 0 1
22658: PPUSH
22659: LD_VAR 0 10
22663: PUSH
22664: LD_INT 1
22666: ARRAY
22667: PPUSH
22668: CALL_OW 180
22672: GO 22689
// AddComMoveXY ( i , 37 , 68 ) ;
22674: LD_VAR 0 1
22678: PPUSH
22679: LD_INT 37
22681: PPUSH
22682: LD_INT 68
22684: PPUSH
22685: CALL_OW 171
// end ;
22689: GO 22584
22691: POP
22692: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22693: LD_ADDR_VAR 0 11
22697: PUSH
22698: LD_VAR 0 6
22702: PPUSH
22703: LD_INT 26
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: EMPTY
22710: LIST
22711: LIST
22712: PPUSH
22713: CALL_OW 72
22717: PUSH
22718: LD_EXP 61
22722: DIFF
22723: ST_TO_ADDR
// if not speaker then
22724: LD_VAR 0 11
22728: NOT
22729: IFFALSE 22756
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22731: LD_ADDR_VAR 0 11
22735: PUSH
22736: LD_VAR 0 6
22740: PPUSH
22741: LD_INT 26
22743: PUSH
22744: LD_INT 1
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PPUSH
22751: CALL_OW 72
22755: ST_TO_ADDR
// if speaker then
22756: LD_VAR 0 11
22760: IFFALSE 22776
// speaker := speaker [ 1 ] ;
22762: LD_ADDR_VAR 0 11
22766: PUSH
22767: LD_VAR 0 11
22771: PUSH
22772: LD_INT 1
22774: ARRAY
22775: ST_TO_ADDR
// Video ( true ) ;
22776: LD_INT 1
22778: PPUSH
22779: CALL 105022 0 1
// CenterNowOnUnits ( Powell ) ;
22783: LD_EXP 60
22787: PPUSH
22788: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22792: LD_ADDR_VAR 0 3
22796: PUSH
22797: LD_VAR 0 6
22801: PPUSH
22802: LD_INT 3
22804: PUSH
22805: LD_INT 25
22807: PUSH
22808: LD_INT 1
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: EMPTY
22816: LIST
22817: LIST
22818: PPUSH
22819: CALL_OW 72
22823: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_INT 22
22831: PUSH
22832: LD_INT 4
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 30
22841: PUSH
22842: LD_INT 32
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: LD_INT 58
22851: PUSH
22852: EMPTY
22853: LIST
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: LIST
22859: PPUSH
22860: CALL_OW 69
22864: ST_TO_ADDR
// for i := 1 to 4 do
22865: LD_ADDR_VAR 0 1
22869: PUSH
22870: DOUBLE
22871: LD_INT 1
22873: DEC
22874: ST_TO_ADDR
22875: LD_INT 4
22877: PUSH
22878: FOR_TO
22879: IFFALSE 23020
// begin if IsInUnit ( tmp [ i ] ) then
22881: LD_VAR 0 3
22885: PUSH
22886: LD_VAR 0 1
22890: ARRAY
22891: PPUSH
22892: CALL_OW 310
22896: IFFALSE 22913
// ComExitBuilding ( tmp [ i ] ) ;
22898: LD_VAR 0 3
22902: PUSH
22903: LD_VAR 0 1
22907: ARRAY
22908: PPUSH
22909: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22913: LD_VAR 0 3
22917: PUSH
22918: LD_VAR 0 1
22922: ARRAY
22923: PPUSH
22924: LD_VAR 0 10
22928: PUSH
22929: LD_INT 1
22931: ARRAY
22932: PPUSH
22933: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22937: LD_VAR 0 3
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 1
22950: PPUSH
22951: CALL_OW 183
// if emp_towers then
22955: LD_VAR 0 12
22959: IFFALSE 23018
// begin AddComExitBuilding ( tmp [ i ] ) ;
22961: LD_VAR 0 3
22965: PUSH
22966: LD_VAR 0 1
22970: ARRAY
22971: PPUSH
22972: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_VAR 0 1
22985: ARRAY
22986: PPUSH
22987: LD_VAR 0 12
22991: PUSH
22992: LD_INT 1
22994: ARRAY
22995: PPUSH
22996: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23000: LD_ADDR_VAR 0 12
23004: PUSH
23005: LD_VAR 0 12
23009: PPUSH
23010: LD_INT 1
23012: PPUSH
23013: CALL_OW 3
23017: ST_TO_ADDR
// end ; end ;
23018: GO 22878
23020: POP
23021: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_EXP 18
23031: PUSH
23032: LD_INT 1
23034: ARRAY
23035: PUSH
23036: LD_EXP 18
23040: PUSH
23041: LD_INT 2
23043: ARRAY
23044: ADD
23045: PPUSH
23046: LD_INT 26
23048: PUSH
23049: LD_INT 1
23051: PUSH
23052: EMPTY
23053: LIST
23054: LIST
23055: PPUSH
23056: CALL_OW 72
23060: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23061: LD_ADDR_VAR 0 1
23065: PUSH
23066: LD_EXP 18
23070: PUSH
23071: LD_INT 2
23073: ARRAY
23074: PUSH
23075: FOR_IN
23076: IFFALSE 23094
// ComTurnUnit ( i , Powell ) ;
23078: LD_VAR 0 1
23082: PPUSH
23083: LD_EXP 60
23087: PPUSH
23088: CALL_OW 119
23092: GO 23075
23094: POP
23095: POP
// Say ( Powell , D5-Pow-1 ) ;
23096: LD_EXP 60
23100: PPUSH
23101: LD_STRING D5-Pow-1
23103: PPUSH
23104: CALL_OW 88
// if tmp then
23108: LD_VAR 0 3
23112: IFFALSE 23130
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
23114: LD_VAR 0 3
23118: PUSH
23119: LD_INT 1
23121: ARRAY
23122: PPUSH
23123: LD_STRING D5-Sol2-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
23130: LD_EXP 60
23134: PPUSH
23135: LD_STRING D5-Pow-2
23137: PPUSH
23138: CALL_OW 88
// if tmp > 1 then
23142: LD_VAR 0 3
23146: PUSH
23147: LD_INT 1
23149: GREATER
23150: IFFALSE 23168
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
23152: LD_VAR 0 3
23156: PUSH
23157: LD_INT 2
23159: ARRAY
23160: PPUSH
23161: LD_STRING D5-Sol2-2
23163: PPUSH
23164: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
23168: LD_EXP 60
23172: PPUSH
23173: LD_STRING D5-Pow-3
23175: PPUSH
23176: CALL_OW 88
// wait ( 0 0$1 ) ;
23180: LD_INT 35
23182: PPUSH
23183: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23187: LD_ADDR_VAR 0 3
23191: PUSH
23192: LD_EXP 18
23196: PUSH
23197: LD_INT 1
23199: ARRAY
23200: PUSH
23201: LD_EXP 18
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: UNION
23210: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23211: LD_VAR 0 3
23215: PPUSH
23216: LD_INT 80
23218: PPUSH
23219: LD_INT 67
23221: PPUSH
23222: CALL_OW 114
// wait ( 0 0$2 ) ;
23226: LD_INT 70
23228: PPUSH
23229: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23233: LD_INT 79
23235: PPUSH
23236: LD_INT 72
23238: PPUSH
23239: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23243: LD_INT 70
23245: PPUSH
23246: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23250: LD_VAR 0 3
23254: PPUSH
23255: LD_INT 3
23257: PUSH
23258: LD_INT 24
23260: PUSH
23261: LD_INT 1000
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PPUSH
23272: CALL_OW 72
23276: IFFALSE 23243
// Say ( Powell , D5a-Pow-1 ) ;
23278: LD_EXP 60
23282: PPUSH
23283: LD_STRING D5a-Pow-1
23285: PPUSH
23286: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23290: LD_EXP 60
23294: PPUSH
23295: LD_STRING D5a-Pow-1a
23297: PPUSH
23298: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23302: LD_INT 24
23304: PPUSH
23305: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23309: LD_EXP 60
23313: PPUSH
23314: LD_STRING D5a-Pow-1b
23316: PPUSH
23317: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23321: LD_INT 10
23323: PPUSH
23324: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23328: LD_EXP 60
23332: PPUSH
23333: LD_STRING D5a-Pow-1c
23335: PPUSH
23336: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23340: LD_VAR 0 3
23344: PPUSH
23345: LD_INT 68
23347: PPUSH
23348: LD_INT 63
23350: PPUSH
23351: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23355: LD_INT 18
23357: PPUSH
23358: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23362: LD_EXP 60
23366: PPUSH
23367: LD_STRING D5a-Pow-1d
23369: PPUSH
23370: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if not HasTask ( tmp ) then
23381: LD_VAR 0 3
23385: PPUSH
23386: CALL_OW 314
23390: NOT
23391: IFFALSE 23408
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23393: LD_VAR 0 3
23397: PPUSH
23398: LD_INT 68
23400: PPUSH
23401: LD_INT 63
23403: PPUSH
23404: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23408: LD_VAR 0 3
23412: PPUSH
23413: LD_INT 24
23415: PUSH
23416: LD_INT 1
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PPUSH
23423: CALL_OW 72
23427: NOT
23428: IFFALSE 23374
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_INT 22
23437: PUSH
23438: LD_INT 4
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 92
23447: PUSH
23448: LD_INT 60
23450: PUSH
23451: LD_INT 93
23453: PUSH
23454: LD_INT 10
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 3
23465: PUSH
23466: LD_INT 54
23468: PUSH
23469: EMPTY
23470: LIST
23471: PUSH
23472: EMPTY
23473: LIST
23474: LIST
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: LIST
23480: PPUSH
23481: CALL_OW 69
23485: PUSH
23486: LD_EXP 60
23490: DIFF
23491: ST_TO_ADDR
// if tmp then
23492: LD_VAR 0 3
23496: IFFALSE 23530
// for i in tmp do
23498: LD_ADDR_VAR 0 1
23502: PUSH
23503: LD_VAR 0 3
23507: PUSH
23508: FOR_IN
23509: IFFALSE 23528
// ComMoveXY ( i , 36 , 67 ) ;
23511: LD_VAR 0 1
23515: PPUSH
23516: LD_INT 36
23518: PPUSH
23519: LD_INT 67
23521: PPUSH
23522: CALL_OW 111
23526: GO 23508
23528: POP
23529: POP
// wait ( 0 0$3 ) ;
23530: LD_INT 105
23532: PPUSH
23533: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23537: LD_VAR 0 11
23541: PPUSH
23542: LD_STRING D6-Sol3-1
23544: PPUSH
23545: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23549: LD_EXP 60
23553: PPUSH
23554: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23558: LD_EXP 60
23562: PPUSH
23563: LD_STRING D6-Pow-1
23565: PPUSH
23566: CALL_OW 88
// tmp := [ ] ;
23570: LD_ADDR_VAR 0 3
23574: PUSH
23575: EMPTY
23576: ST_TO_ADDR
// for i = 1 to 2 do
23577: LD_ADDR_VAR 0 1
23581: PUSH
23582: DOUBLE
23583: LD_INT 1
23585: DEC
23586: ST_TO_ADDR
23587: LD_INT 2
23589: PUSH
23590: FOR_TO
23591: IFFALSE 23705
// begin uc_side := 8 ;
23593: LD_ADDR_OWVAR 20
23597: PUSH
23598: LD_INT 8
23600: ST_TO_ADDR
// uc_nation := 2 ;
23601: LD_ADDR_OWVAR 21
23605: PUSH
23606: LD_INT 2
23608: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23609: LD_INT 14
23611: PPUSH
23612: LD_INT 3
23614: PPUSH
23615: LD_INT 2
23617: PPUSH
23618: LD_INT 29
23620: PPUSH
23621: LD_INT 100
23623: PPUSH
23624: CALL 72597 0 5
// veh := CreateVehicle ;
23628: LD_ADDR_VAR 0 13
23632: PUSH
23633: CALL_OW 45
23637: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23638: LD_VAR 0 13
23642: PPUSH
23643: LD_INT 4
23645: PPUSH
23646: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23650: LD_VAR 0 13
23654: PPUSH
23655: LD_INT 99
23657: PPUSH
23658: LD_INT 83
23660: PPUSH
23661: LD_INT 3
23663: PPUSH
23664: LD_INT 0
23666: PPUSH
23667: CALL_OW 50
// wait ( 3 ) ;
23671: LD_INT 3
23673: PPUSH
23674: CALL_OW 67
// Connect ( veh ) ;
23678: LD_VAR 0 13
23682: PPUSH
23683: CALL 75688 0 1
// tmp := tmp ^ veh ;
23687: LD_ADDR_VAR 0 3
23691: PUSH
23692: LD_VAR 0 3
23696: PUSH
23697: LD_VAR 0 13
23701: ADD
23702: ST_TO_ADDR
// end ;
23703: GO 23590
23705: POP
23706: POP
// wait ( 0 0$1 ) ;
23707: LD_INT 35
23709: PPUSH
23710: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23714: LD_INT 99
23716: PPUSH
23717: LD_INT 83
23719: PPUSH
23720: LD_INT 1
23722: PPUSH
23723: LD_INT 10
23725: PPUSH
23726: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23730: LD_INT 99
23732: PPUSH
23733: LD_INT 83
23735: PPUSH
23736: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23740: LD_VAR 0 11
23744: PPUSH
23745: LD_STRING D6-Sol3-2
23747: PPUSH
23748: CALL_OW 88
// async ;
23752: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23753: LD_EXP 60
23757: PPUSH
23758: LD_STRING D6-Pow-2
23760: PPUSH
23761: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23765: LD_VAR 0 3
23769: PUSH
23770: LD_INT 1
23772: ARRAY
23773: PPUSH
23774: LD_VAR 0 9
23778: PPUSH
23779: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23783: LD_VAR 0 3
23787: PUSH
23788: LD_INT 2
23790: ARRAY
23791: PPUSH
23792: LD_INT 22
23794: PUSH
23795: LD_INT 4
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 21
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: PPUSH
23816: CALL_OW 69
23820: PPUSH
23821: LD_VAR 0 3
23825: PUSH
23826: LD_INT 2
23828: ARRAY
23829: PPUSH
23830: CALL_OW 74
23834: PPUSH
23835: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23839: LD_EXP 60
23843: PPUSH
23844: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23848: LD_INT 99
23850: PPUSH
23851: LD_INT 83
23853: PPUSH
23854: LD_INT 1
23856: PPUSH
23857: CALL_OW 331
// repeat wait ( 4 ) ;
23861: LD_INT 4
23863: PPUSH
23864: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23868: LD_VAR 0 3
23872: PUSH
23873: LD_INT 1
23875: ARRAY
23876: PPUSH
23877: CALL_OW 256
23881: PUSH
23882: LD_INT 1000
23884: LESS
23885: IFFALSE 23903
// SetLives ( tmp [ 1 ] , 1000 ) ;
23887: LD_VAR 0 3
23891: PUSH
23892: LD_INT 1
23894: ARRAY
23895: PPUSH
23896: LD_INT 1000
23898: PPUSH
23899: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23903: LD_INT 22
23905: PUSH
23906: LD_INT 4
23908: PUSH
23909: EMPTY
23910: LIST
23911: LIST
23912: PUSH
23913: LD_INT 30
23915: PUSH
23916: LD_INT 3
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PPUSH
23927: CALL_OW 69
23931: PUSH
23932: LD_INT 0
23934: EQUAL
23935: IFFALSE 23861
// skirmish := false ;
23937: LD_ADDR_EXP 98
23941: PUSH
23942: LD_INT 0
23944: ST_TO_ADDR
// sync ;
23945: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23946: LD_EXP 60
23950: PPUSH
23951: LD_STRING D6a-Pow-1
23953: PPUSH
23954: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23958: LD_VAR 0 11
23962: PPUSH
23963: LD_STRING D6a-Sol3-1
23965: PPUSH
23966: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23970: LD_EXP 60
23974: PPUSH
23975: LD_STRING D6a-Pow-2
23977: PPUSH
23978: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23982: LD_VAR 0 11
23986: PPUSH
23987: LD_STRING D6a-Sol3-2
23989: PPUSH
23990: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23994: LD_EXP 60
23998: PPUSH
23999: LD_STRING D6a-Pow-3
24001: PPUSH
24002: CALL_OW 88
// powellCenterCameraMode := true ;
24006: LD_ADDR_EXP 20
24010: PUSH
24011: LD_INT 1
24013: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24014: LD_ADDR_VAR 0 1
24018: PUSH
24019: LD_INT 22
24021: PUSH
24022: LD_INT 8
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 25
24031: PUSH
24032: LD_INT 2
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: EMPTY
24040: LIST
24041: LIST
24042: PPUSH
24043: CALL_OW 69
24047: PUSH
24048: FOR_IN
24049: IFFALSE 24104
// begin SetTag ( i , 1 ) ;
24051: LD_VAR 0 1
24055: PPUSH
24056: LD_INT 1
24058: PPUSH
24059: CALL_OW 109
// ComExitBuilding ( i ) ;
24063: LD_VAR 0 1
24067: PPUSH
24068: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24072: LD_VAR 0 1
24076: PPUSH
24077: LD_INT 35
24079: PPUSH
24080: LD_INT 6
24082: PPUSH
24083: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24087: LD_VAR 0 1
24091: PPUSH
24092: LD_INT 53
24094: PPUSH
24095: LD_INT 4
24097: PPUSH
24098: CALL_OW 171
// end ;
24102: GO 24048
24104: POP
24105: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
24106: LD_ADDR_VAR 0 3
24110: PUSH
24111: LD_INT 22
24113: PUSH
24114: LD_INT 4
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 21
24123: PUSH
24124: LD_INT 2
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PUSH
24131: LD_INT 3
24133: PUSH
24134: LD_INT 34
24136: PUSH
24137: LD_INT 12
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: LIST
24152: PPUSH
24153: CALL_OW 69
24157: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
24158: LD_EXP 60
24162: PPUSH
24163: LD_VAR 0 3
24167: PPUSH
24168: LD_EXP 60
24172: PPUSH
24173: CALL_OW 74
24177: PPUSH
24178: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24182: LD_EXP 60
24186: PPUSH
24187: LD_INT 100
24189: PPUSH
24190: LD_INT 88
24192: PPUSH
24193: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24197: LD_EXP 60
24201: PPUSH
24202: LD_INT 100
24204: PPUSH
24205: LD_INT 75
24207: PPUSH
24208: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24212: LD_EXP 60
24216: PPUSH
24217: LD_INT 88
24219: PPUSH
24220: LD_INT 53
24222: PPUSH
24223: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24227: LD_INT 8
24229: PPUSH
24230: LD_EXP 60
24234: PPUSH
24235: CALL_OW 471
// repeat wait ( 3 ) ;
24239: LD_INT 3
24241: PPUSH
24242: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24246: LD_INT 22
24248: PUSH
24249: LD_INT 4
24251: PUSH
24252: EMPTY
24253: LIST
24254: LIST
24255: PUSH
24256: LD_INT 92
24258: PUSH
24259: LD_INT 100
24261: PUSH
24262: LD_INT 75
24264: PUSH
24265: LD_INT 6
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PPUSH
24278: CALL_OW 69
24282: IFFALSE 24239
// async ;
24284: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24285: LD_EXP 60
24289: PPUSH
24290: LD_STRING D6b-Pow-1
24292: PPUSH
24293: CALL_OW 88
// repeat wait ( 3 ) ;
24297: LD_INT 3
24299: PPUSH
24300: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24304: LD_EXP 60
24308: PPUSH
24309: CALL_OW 310
24313: PPUSH
24314: CALL_OW 256
24318: PUSH
24319: LD_INT 1000
24321: LESS
24322: IFFALSE 24341
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24324: LD_EXP 60
24328: PPUSH
24329: CALL_OW 310
24333: PPUSH
24334: LD_INT 1000
24336: PPUSH
24337: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24341: LD_EXP 60
24345: PPUSH
24346: CALL_OW 256
24350: PUSH
24351: LD_INT 1000
24353: LESS
24354: IFFALSE 24368
// SetLives ( Powell , 1000 ) ;
24356: LD_EXP 60
24360: PPUSH
24361: LD_INT 1000
24363: PPUSH
24364: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24368: LD_EXP 60
24372: PPUSH
24373: LD_EXP 65
24377: PPUSH
24378: CALL_OW 296
24382: PUSH
24383: LD_INT 5
24385: LESS
24386: PUSH
24387: LD_EXP 60
24391: PPUSH
24392: CALL_OW 310
24396: PPUSH
24397: LD_EXP 65
24401: PPUSH
24402: CALL_OW 296
24406: PUSH
24407: LD_INT 5
24409: LESS
24410: OR
24411: IFFALSE 24430
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24413: LD_EXP 60
24417: PPUSH
24418: CALL_OW 310
24422: PPUSH
24423: LD_INT 100
24425: PPUSH
24426: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24430: LD_EXP 60
24434: PPUSH
24435: CALL_OW 310
24439: NOT
24440: IFFALSE 24297
// DoNotAttack ( 8 , powellBomb ) ;
24442: LD_INT 8
24444: PPUSH
24445: LD_EXP 65
24449: PPUSH
24450: CALL_OW 471
// game_speed := 4 ;
24454: LD_ADDR_OWVAR 65
24458: PUSH
24459: LD_INT 4
24461: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24462: LD_EXP 60
24466: PPUSH
24467: LD_STRING D6b-Pow-1a
24469: PPUSH
24470: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24474: LD_EXP 60
24478: PPUSH
24479: LD_EXP 65
24483: PPUSH
24484: CALL_OW 180
// sync ;
24488: SYNC
// repeat wait ( 0 0$1 ) ;
24489: LD_INT 35
24491: PPUSH
24492: CALL_OW 67
// until IsInUnit ( Powell ) ;
24496: LD_EXP 60
24500: PPUSH
24501: CALL_OW 310
24505: IFFALSE 24489
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24507: LD_INT 8
24509: PPUSH
24510: LD_EXP 60
24514: PPUSH
24515: CALL_OW 310
24519: PPUSH
24520: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24524: LD_EXP 60
24528: PPUSH
24529: LD_INT 91
24531: PPUSH
24532: LD_INT 44
24534: PPUSH
24535: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24539: LD_EXP 60
24543: PPUSH
24544: LD_INT 96
24546: PPUSH
24547: LD_INT 44
24549: PPUSH
24550: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24554: LD_EXP 60
24558: PPUSH
24559: LD_INT 96
24561: PPUSH
24562: LD_INT 41
24564: PPUSH
24565: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24569: LD_EXP 60
24573: PPUSH
24574: LD_INT 92
24576: PPUSH
24577: LD_INT 39
24579: PPUSH
24580: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24584: LD_EXP 60
24588: PPUSH
24589: LD_INT 88
24591: PPUSH
24592: LD_INT 41
24594: PPUSH
24595: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24599: LD_EXP 60
24603: PPUSH
24604: LD_INT 91
24606: PPUSH
24607: LD_INT 44
24609: PPUSH
24610: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24614: LD_EXP 60
24618: PPUSH
24619: LD_INT 96
24621: PPUSH
24622: LD_INT 44
24624: PPUSH
24625: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24629: LD_EXP 60
24633: PPUSH
24634: LD_INT 96
24636: PPUSH
24637: LD_INT 41
24639: PPUSH
24640: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24644: LD_EXP 60
24648: PPUSH
24649: LD_INT 92
24651: PPUSH
24652: LD_INT 39
24654: PPUSH
24655: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24659: LD_EXP 60
24663: PPUSH
24664: LD_INT 88
24666: PPUSH
24667: LD_INT 41
24669: PPUSH
24670: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24674: LD_EXP 60
24678: PPUSH
24679: LD_INT 91
24681: PPUSH
24682: LD_INT 44
24684: PPUSH
24685: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24689: LD_EXP 60
24693: PPUSH
24694: LD_INT 93
24696: PPUSH
24697: LD_INT 39
24699: PPUSH
24700: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24704: LD_EXP 60
24708: PPUSH
24709: LD_INT 93
24711: PPUSH
24712: LD_INT 36
24714: PPUSH
24715: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24719: LD_INT 122
24721: PPUSH
24722: CALL_OW 67
// game_speed := 4 ;
24726: LD_ADDR_OWVAR 65
24730: PUSH
24731: LD_INT 4
24733: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24734: LD_EXP 60
24738: PPUSH
24739: LD_STRING D6b-Pow-1b
24741: PPUSH
24742: CALL_OW 88
// tmp := [ ] ;
24746: LD_ADDR_VAR 0 3
24750: PUSH
24751: EMPTY
24752: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24753: LD_ADDR_VAR 0 5
24757: PUSH
24758: LD_INT 78
24760: PUSH
24761: LD_INT 47
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: LD_INT 106
24770: PUSH
24771: LD_INT 53
24773: PUSH
24774: EMPTY
24775: LIST
24776: LIST
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24782: LD_ADDR_VAR 0 1
24786: PUSH
24787: LD_INT 22
24789: PUSH
24790: LD_INT 8
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 21
24799: PUSH
24800: LD_INT 3
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: PUSH
24807: LD_INT 92
24809: PUSH
24810: LD_INT 90
24812: PUSH
24813: LD_INT 52
24815: PUSH
24816: LD_INT 12
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PPUSH
24830: CALL_OW 69
24834: PUSH
24835: FOR_IN
24836: IFFALSE 24861
// tmp := tmp ^ UnitsInside ( i ) ;
24838: LD_ADDR_VAR 0 3
24842: PUSH
24843: LD_VAR 0 3
24847: PUSH
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 313
24857: ADD
24858: ST_TO_ADDR
24859: GO 24835
24861: POP
24862: POP
// for i in tmp do
24863: LD_ADDR_VAR 0 1
24867: PUSH
24868: LD_VAR 0 3
24872: PUSH
24873: FOR_IN
24874: IFFALSE 25036
// begin dist := 9999 ;
24876: LD_ADDR_VAR 0 8
24880: PUSH
24881: LD_INT 9999
24883: ST_TO_ADDR
// _xy := [ ] ;
24884: LD_ADDR_VAR 0 7
24888: PUSH
24889: EMPTY
24890: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24891: LD_VAR 0 1
24895: PPUSH
24896: LD_INT 1
24898: PPUSH
24899: CALL_OW 109
// ComExitBuilding ( i ) ;
24903: LD_VAR 0 1
24907: PPUSH
24908: CALL_OW 122
// for j in xy do
24912: LD_ADDR_VAR 0 2
24916: PUSH
24917: LD_VAR 0 5
24921: PUSH
24922: FOR_IN
24923: IFFALSE 25005
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24925: LD_VAR 0 1
24929: PPUSH
24930: LD_VAR 0 2
24934: PUSH
24935: LD_INT 1
24937: ARRAY
24938: PPUSH
24939: LD_VAR 0 2
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 297
24952: PUSH
24953: LD_VAR 0 8
24957: LESS
24958: IFFALSE 25003
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24960: LD_ADDR_VAR 0 8
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: LD_VAR 0 2
24974: PUSH
24975: LD_INT 1
24977: ARRAY
24978: PPUSH
24979: LD_VAR 0 2
24983: PUSH
24984: LD_INT 2
24986: ARRAY
24987: PPUSH
24988: CALL_OW 297
24992: ST_TO_ADDR
// _xy := j ;
24993: LD_ADDR_VAR 0 7
24997: PUSH
24998: LD_VAR 0 2
25002: ST_TO_ADDR
// end ;
25003: GO 24922
25005: POP
25006: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25007: LD_VAR 0 1
25011: PPUSH
25012: LD_VAR 0 7
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: PPUSH
25021: LD_VAR 0 7
25025: PUSH
25026: LD_INT 2
25028: ARRAY
25029: PPUSH
25030: CALL_OW 171
// end ;
25034: GO 24873
25036: POP
25037: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25038: LD_ADDR_VAR 0 4
25042: PUSH
25043: LD_VAR 0 3
25047: PPUSH
25048: LD_INT 26
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 25
25060: PUSH
25061: LD_INT 1
25063: PUSH
25064: EMPTY
25065: LIST
25066: LIST
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: ST_TO_ADDR
// if tmp2 < 2 then
25077: LD_VAR 0 4
25081: PUSH
25082: LD_INT 2
25084: LESS
25085: IFFALSE 25154
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_INT 22
25094: PUSH
25095: LD_INT 8
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 26
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 3
25114: PUSH
25115: LD_INT 25
25117: PUSH
25118: LD_INT 15
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: PPUSH
25134: CALL_OW 69
25138: PUSH
25139: LD_EXP 62
25143: PUSH
25144: LD_EXP 63
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: DIFF
25153: ST_TO_ADDR
// if tmp2 then
25154: LD_VAR 0 4
25158: IFFALSE 25176
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
25160: LD_VAR 0 4
25164: PUSH
25165: LD_INT 1
25167: ARRAY
25168: PPUSH
25169: LD_STRING D6b-ArSol1-1
25171: PPUSH
25172: CALL_OW 88
// async ;
25176: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25177: LD_EXP 60
25181: PPUSH
25182: LD_STRING D6b-Pow-2
25184: PPUSH
25185: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25189: LD_INT 18
25191: PPUSH
25192: CALL_OW 67
// if tmp2 > 1 then
25196: LD_VAR 0 4
25200: PUSH
25201: LD_INT 1
25203: GREATER
25204: IFFALSE 25222
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25206: LD_VAR 0 4
25210: PUSH
25211: LD_INT 2
25213: ARRAY
25214: PPUSH
25215: LD_STRING D6b-ArSol2-1
25217: PPUSH
25218: CALL_OW 88
// sync ;
25222: SYNC
// repeat wait ( 5 ) ;
25223: LD_INT 5
25225: PPUSH
25226: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25230: LD_INT 93
25232: PPUSH
25233: LD_INT 36
25235: PPUSH
25236: CALL_OW 428
25240: PPUSH
25241: CALL_OW 255
25245: PUSH
25246: LD_INT 4
25248: EQUAL
25249: IFFALSE 25223
// DialogueOn ;
25251: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25255: LD_INT 10
25257: PPUSH
25258: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25262: LD_EXP 60
25266: PPUSH
25267: LD_STRING D6b-Pow-2a
25269: PPUSH
25270: CALL_OW 88
// DialogueOff ;
25274: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25278: LD_EXP 60
25282: PPUSH
25283: CALL_OW 310
25287: PPUSH
25288: LD_INT 332
25290: PPUSH
25291: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25295: LD_INT 93
25297: PPUSH
25298: LD_INT 35
25300: PPUSH
25301: LD_INT 1
25303: PPUSH
25304: LD_INT 6
25306: NEG
25307: PPUSH
25308: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25312: LD_INT 35
25314: PPUSH
25315: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25319: LD_INT 332
25321: PPUSH
25322: CALL_OW 256
25326: PUSH
25327: LD_INT 1000
25329: LESS
25330: PUSH
25331: LD_INT 332
25333: PPUSH
25334: CALL_OW 300
25338: AND
25339: IFFALSE 25351
// SetLives ( kozlov_fac , 0 ) ;
25341: LD_INT 332
25343: PPUSH
25344: LD_INT 0
25346: PPUSH
25347: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25351: LD_INT 332
25353: PPUSH
25354: CALL_OW 301
25358: PUSH
25359: LD_EXP 60
25363: PPUSH
25364: CALL_OW 301
25368: OR
25369: IFFALSE 25312
// game_speed := 4 ;
25371: LD_ADDR_OWVAR 65
25375: PUSH
25376: LD_INT 4
25378: ST_TO_ADDR
// powellCenterCameraMode := false ;
25379: LD_ADDR_EXP 20
25383: PUSH
25384: LD_INT 0
25386: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25387: LD_ADDR_VAR 0 1
25391: PUSH
25392: LD_VAR 0 3
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 8
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 25
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PPUSH
25421: CALL_OW 69
25425: UNION
25426: PUSH
25427: FOR_IN
25428: IFFALSE 25444
// SetTag ( i , 0 ) ;
25430: LD_VAR 0 1
25434: PPUSH
25435: LD_INT 0
25437: PPUSH
25438: CALL_OW 109
25442: GO 25427
25444: POP
25445: POP
// wait ( 0 0$3 ) ;
25446: LD_INT 105
25448: PPUSH
25449: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25453: LD_INT 93
25455: PPUSH
25456: LD_INT 35
25458: PPUSH
25459: LD_INT 1
25461: PPUSH
25462: CALL_OW 331
// DialogueOn ;
25466: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25470: LD_VAR 0 11
25474: PPUSH
25475: LD_STRING D6c-Sol3-1
25477: PPUSH
25478: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25482: LD_INT 10
25484: PPUSH
25485: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25489: LD_EXP 40
25493: PPUSH
25494: LD_STRING D6c-JMM-1
25496: PPUSH
25497: CALL_OW 88
// if Cyrus then
25501: LD_EXP 46
25505: IFFALSE 25519
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25507: LD_EXP 46
25511: PPUSH
25512: LD_STRING D6c-Cyrus-1
25514: PPUSH
25515: CALL_OW 88
// if Bobby then
25519: LD_EXP 45
25523: IFFALSE 25537
// Say ( Bobby , D6c-Bobby-1 ) ;
25525: LD_EXP 45
25529: PPUSH
25530: LD_STRING D6c-Bobby-1
25532: PPUSH
25533: CALL_OW 88
// if Cornel then
25537: LD_EXP 51
25541: IFFALSE 25555
// Say ( Cornel , D6c-Corn-1 ) ;
25543: LD_EXP 51
25547: PPUSH
25548: LD_STRING D6c-Corn-1
25550: PPUSH
25551: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25555: LD_ADDR_VAR 0 4
25559: PUSH
25560: LD_INT 2
25562: PUSH
25563: LD_INT 22
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 22
25575: PUSH
25576: LD_INT 4
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 26
25590: PUSH
25591: LD_INT 1
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 23
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: LIST
25612: PPUSH
25613: CALL_OW 69
25617: PUSH
25618: LD_VAR 0 11
25622: PUSH
25623: LD_EXP 40
25627: UNION
25628: PUSH
25629: LD_EXP 61
25633: UNION
25634: DIFF
25635: ST_TO_ADDR
// if tmp2 then
25636: LD_VAR 0 4
25640: IFFALSE 25658
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25642: LD_VAR 0 4
25646: PUSH
25647: LD_INT 1
25649: ARRAY
25650: PPUSH
25651: LD_STRING D6c-Sol1-1
25653: PPUSH
25654: CALL_OW 88
// if Lisa then
25658: LD_EXP 43
25662: IFFALSE 25676
// Say ( Lisa , D6c-Lisa-1 ) ;
25664: LD_EXP 43
25668: PPUSH
25669: LD_STRING D6c-Lisa-1
25671: PPUSH
25672: CALL_OW 88
// if Gary then
25676: LD_EXP 52
25680: IFFALSE 25694
// Say ( Gary , D6c-Gary-1 ) ;
25682: LD_EXP 52
25686: PPUSH
25687: LD_STRING D6c-Gary-1
25689: PPUSH
25690: CALL_OW 88
// if Donaldson then
25694: LD_EXP 44
25698: IFFALSE 25712
// Say ( Donaldson , D6c-Don-1 ) ;
25700: LD_EXP 44
25704: PPUSH
25705: LD_STRING D6c-Don-1
25707: PPUSH
25708: CALL_OW 88
// if tmp2 > 1 then
25712: LD_VAR 0 4
25716: PUSH
25717: LD_INT 1
25719: GREATER
25720: IFFALSE 25738
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 2
25729: ARRAY
25730: PPUSH
25731: LD_STRING D6c-Sol2-1
25733: PPUSH
25734: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25738: LD_VAR 0 11
25742: PPUSH
25743: LD_STRING D6c-Sol3-2
25745: PPUSH
25746: CALL_OW 88
// if IsInUnit ( JMM ) then
25750: LD_EXP 40
25754: PPUSH
25755: CALL_OW 310
25759: IFFALSE 25777
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25761: LD_EXP 40
25765: PPUSH
25766: CALL_OW 310
25770: PPUSH
25771: CALL_OW 87
25775: GO 25786
// CenterNowOnUnits ( JMM ) ;
25777: LD_EXP 40
25781: PPUSH
25782: CALL_OW 87
// dwait ( 0 0$2 ) ;
25786: LD_INT 70
25788: PPUSH
25789: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25793: LD_EXP 40
25797: PPUSH
25798: LD_STRING D6c-JMM-2
25800: PPUSH
25801: CALL_OW 88
// DialogueOff ;
25805: CALL_OW 7
// Video ( false ) ;
25809: LD_INT 0
25811: PPUSH
25812: CALL 105022 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25816: LD_INT 22
25818: PUSH
25819: LD_INT 4
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 69
25830: PPUSH
25831: LD_INT 1
25833: PPUSH
25834: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25838: LD_INT 4
25840: PPUSH
25841: LD_INT 4
25843: PPUSH
25844: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25848: LD_ADDR_VAR 0 1
25852: PUSH
25853: LD_INT 4
25855: PPUSH
25856: LD_INT 1
25858: PPUSH
25859: LD_INT 2
25861: PPUSH
25862: CALL 67645 0 3
25866: PUSH
25867: FOR_IN
25868: IFFALSE 25905
// if GetTech ( i , 1 ) <> state_researched then
25870: LD_VAR 0 1
25874: PPUSH
25875: LD_INT 1
25877: PPUSH
25878: CALL_OW 321
25882: PUSH
25883: LD_INT 2
25885: NONEQUAL
25886: IFFALSE 25903
// SetTech ( i , 1 , state_researched ) ;
25888: LD_VAR 0 1
25892: PPUSH
25893: LD_INT 1
25895: PPUSH
25896: LD_INT 2
25898: PPUSH
25899: CALL_OW 322
25903: GO 25867
25905: POP
25906: POP
// missionStage := 6 ;
25907: LD_ADDR_EXP 15
25911: PUSH
25912: LD_INT 6
25914: ST_TO_ADDR
// activeAttacks := true ;
25915: LD_ADDR_EXP 16
25919: PUSH
25920: LD_INT 1
25922: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25923: LD_STRING M2
25925: PPUSH
25926: CALL_OW 337
// SaveForQuickRestart ;
25930: CALL_OW 22
// wait ( 0 0$40 ) ;
25934: LD_INT 1400
25936: PPUSH
25937: CALL_OW 67
// DialogueOn ;
25941: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
25945: LD_EXP 64
25949: PPUSH
25950: LD_STRING D7-Friend-1
25952: PPUSH
25953: CALL 108969 0 2
// Say ( JMM , D7-JMM-1 ) ;
25957: LD_EXP 40
25961: PPUSH
25962: LD_STRING D7-JMM-1
25964: PPUSH
25965: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
25969: LD_EXP 64
25973: PPUSH
25974: LD_STRING D7-Friend-2
25976: PPUSH
25977: CALL 108969 0 2
// Say ( JMM , D7-JMM-2 ) ;
25981: LD_EXP 40
25985: PPUSH
25986: LD_STRING D7-JMM-2
25988: PPUSH
25989: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
25993: LD_EXP 64
25997: PPUSH
25998: LD_STRING D7-Friend-3
26000: PPUSH
26001: CALL 108969 0 2
// Say ( JMM , D7-JMM-3 ) ;
26005: LD_EXP 40
26009: PPUSH
26010: LD_STRING D7-JMM-3
26012: PPUSH
26013: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26017: LD_EXP 64
26021: PPUSH
26022: LD_STRING D7-Friend-4
26024: PPUSH
26025: CALL 108969 0 2
// Say ( JMM , D7-JMM-4 ) ;
26029: LD_EXP 40
26033: PPUSH
26034: LD_STRING D7-JMM-4
26036: PPUSH
26037: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26041: LD_EXP 64
26045: PPUSH
26046: LD_STRING D7-Friend-5
26048: PPUSH
26049: CALL 108969 0 2
// Say ( JMM , D7-JMM-5 ) ;
26053: LD_EXP 40
26057: PPUSH
26058: LD_STRING D7-JMM-5
26060: PPUSH
26061: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26065: LD_EXP 64
26069: PPUSH
26070: LD_STRING D7-Friend-6
26072: PPUSH
26073: CALL 108969 0 2
// Say ( JMM , D7-JMM-6 ) ;
26077: LD_EXP 40
26081: PPUSH
26082: LD_STRING D7-JMM-6
26084: PPUSH
26085: CALL_OW 88
// DialogueOff ;
26089: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26093: LD_STRING Mlegion
26095: PPUSH
26096: CALL_OW 337
// skirmish := true ;
26100: LD_ADDR_EXP 98
26104: PUSH
26105: LD_INT 1
26107: ST_TO_ADDR
// RebuildKozlovFactory ;
26108: CALL 5036 0 0
// end ;
26112: PPOPN 13
26114: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
26115: LD_EXP 20
26119: PUSH
26120: LD_EXP 60
26124: PPUSH
26125: CALL_OW 300
26129: AND
26130: IFFALSE 26172
26132: GO 26134
26134: DISABLE
// begin enable ;
26135: ENABLE
// if IsInUnit ( Powell ) then
26136: LD_EXP 60
26140: PPUSH
26141: CALL_OW 310
26145: IFFALSE 26163
// CenterOnUnits ( IsInUnit ( Powell ) ) else
26147: LD_EXP 60
26151: PPUSH
26152: CALL_OW 310
26156: PPUSH
26157: CALL_OW 85
26161: GO 26172
// CenterOnUnits ( Powell ) ;
26163: LD_EXP 60
26167: PPUSH
26168: CALL_OW 85
// end ;
26172: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
26173: LD_INT 22
26175: PUSH
26176: LD_INT 8
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 34
26185: PUSH
26186: LD_INT 48
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PPUSH
26197: CALL_OW 69
26201: IFFALSE 26475
26203: GO 26205
26205: DISABLE
26206: LD_INT 0
26208: PPUSH
26209: PPUSH
// begin if missionStage < 9 then
26210: LD_EXP 15
26214: PUSH
26215: LD_INT 9
26217: LESS
26218: IFFALSE 26228
// missionStage := 9 ;
26220: LD_ADDR_EXP 15
26224: PUSH
26225: LD_INT 9
26227: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26228: LD_ADDR_VAR 0 1
26232: PUSH
26233: LD_INT 22
26235: PUSH
26236: LD_INT 8
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: PUSH
26243: LD_INT 34
26245: PUSH
26246: LD_INT 48
26248: PUSH
26249: EMPTY
26250: LIST
26251: LIST
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PPUSH
26257: CALL_OW 69
26261: PUSH
26262: LD_INT 1
26264: ARRAY
26265: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26266: LD_INT 175
26268: PPUSH
26269: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26273: LD_EXP 12
26277: PUSH
26278: LD_EXP 3
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: LD_INT 2
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: IN
26293: OR
26294: IFFALSE 26317
// target := [ 68 , 108 , 1 ] else
26296: LD_ADDR_VAR 0 2
26300: PUSH
26301: LD_INT 68
26303: PUSH
26304: LD_INT 108
26306: PUSH
26307: LD_INT 1
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: LIST
26314: ST_TO_ADDR
26315: GO 26336
// target := [ 181 , 88 , 2 ] ;
26317: LD_ADDR_VAR 0 2
26321: PUSH
26322: LD_INT 181
26324: PUSH
26325: LD_INT 88
26327: PUSH
26328: LD_INT 2
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26336: LD_VAR 0 1
26340: PPUSH
26341: LD_VAR 0 2
26345: PUSH
26346: LD_INT 1
26348: ARRAY
26349: PPUSH
26350: LD_VAR 0 2
26354: PUSH
26355: LD_INT 2
26357: ARRAY
26358: PPUSH
26359: CALL_OW 176
// if target [ 3 ] = 1 then
26363: LD_VAR 0 2
26367: PUSH
26368: LD_INT 3
26370: ARRAY
26371: PUSH
26372: LD_INT 1
26374: EQUAL
26375: IFFALSE 26391
// SayRadio ( Kurt , D12-Kurt-1 ) else
26377: LD_EXP 62
26381: PPUSH
26382: LD_STRING D12-Kurt-1
26384: PPUSH
26385: CALL_OW 94
26389: GO 26415
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26391: LD_EXP 62
26395: PPUSH
26396: LD_STRING D12a-Kurt-1
26398: PPUSH
26399: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26403: LD_EXP 77
26407: PPUSH
26408: LD_STRING D12a-Roth-1
26410: PPUSH
26411: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26415: LD_INT 350
26417: PPUSH
26418: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26422: LD_VAR 0 1
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 8
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 23
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 30
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PPUSH
26462: CALL_OW 69
26466: PUSH
26467: LD_INT 1
26469: ARRAY
26470: PPUSH
26471: CALL_OW 228
// end ;
26475: PPOPN 2
26477: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26478: LD_EXP 62
26482: PPUSH
26483: CALL_OW 256
26487: PUSH
26488: LD_INT 999
26490: LESS
26491: PUSH
26492: LD_INT 22
26494: PUSH
26495: LD_INT 8
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 21
26504: PUSH
26505: LD_INT 1
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 23
26514: PUSH
26515: LD_INT 2
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 69
26531: PUSH
26532: LD_INT 9
26534: PUSH
26535: LD_INT 8
26537: PUSH
26538: LD_INT 7
26540: PUSH
26541: LD_INT 6
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: PUSH
26550: LD_OWVAR 67
26554: ARRAY
26555: LESSEQUAL
26556: OR
26557: PUSH
26558: LD_INT 22
26560: PUSH
26561: LD_INT 8
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: PUSH
26568: LD_INT 34
26570: PUSH
26571: LD_INT 48
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 69
26586: NOT
26587: AND
26588: PUSH
26589: LD_EXP 62
26593: PPUSH
26594: CALL_OW 302
26598: AND
26599: PUSH
26600: LD_INT 5
26602: PPUSH
26603: LD_INT 22
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 70
26617: AND
26618: IFFALSE 27362
26620: GO 26622
26622: DISABLE
26623: LD_INT 0
26625: PPUSH
26626: PPUSH
26627: PPUSH
// begin legionDestroyed := true ;
26628: LD_ADDR_EXP 22
26632: PUSH
26633: LD_INT 1
26635: ST_TO_ADDR
// DialogueOn ;
26636: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26640: LD_EXP 40
26644: PPUSH
26645: LD_STRING D13-JMM-1
26647: PPUSH
26648: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26652: LD_EXP 62
26656: PPUSH
26657: LD_STRING D13-Kurt-1
26659: PPUSH
26660: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26664: LD_EXP 40
26668: PPUSH
26669: LD_STRING D13-JMM-2
26671: PPUSH
26672: CALL_OW 88
// if FakeInfo then
26676: LD_EXP 12
26680: IFFALSE 26700
// begin Say ( Kurt , D13-Kurt-2 ) ;
26682: LD_EXP 62
26686: PPUSH
26687: LD_STRING D13-Kurt-2
26689: PPUSH
26690: CALL_OW 88
// DialogueOff ;
26694: CALL_OW 7
// exit ;
26698: GO 27362
// end ; if not KurtStatus then
26700: LD_EXP 3
26704: NOT
26705: IFFALSE 26721
// Say ( Kurt , D13-Kurt-2b ) else
26707: LD_EXP 62
26711: PPUSH
26712: LD_STRING D13-Kurt-2b
26714: PPUSH
26715: CALL_OW 88
26719: GO 26733
// Say ( Kurt , D13-Kurt-2a ) ;
26721: LD_EXP 62
26725: PPUSH
26726: LD_STRING D13-Kurt-2a
26728: PPUSH
26729: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26733: LD_EXP 40
26737: PPUSH
26738: LD_STRING D13-JMM-3
26740: PPUSH
26741: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26745: LD_EXP 62
26749: PPUSH
26750: LD_STRING D13-Kurt-3
26752: PPUSH
26753: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26757: LD_EXP 40
26761: PPUSH
26762: LD_STRING D13-JMM-4
26764: PPUSH
26765: CALL_OW 88
// DialogueOff ;
26769: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26773: LD_STRING MlegionOut
26775: PPUSH
26776: CALL_OW 337
// MC_Kill ( 3 ) ;
26780: LD_INT 3
26782: PPUSH
26783: CALL 37129 0 1
// KillUnit ( Kozlov ) ;
26787: LD_EXP 63
26791: PPUSH
26792: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26796: LD_ADDR_VAR 0 1
26800: PUSH
26801: LD_INT 22
26803: PUSH
26804: LD_INT 8
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 23
26813: PUSH
26814: LD_INT 3
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 3
26823: PUSH
26824: LD_INT 21
26826: PUSH
26827: LD_INT 33
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PPUSH
26843: CALL_OW 69
26847: PUSH
26848: FOR_IN
26849: IFFALSE 26862
// KillUnit ( i ) ;
26851: LD_VAR 0 1
26855: PPUSH
26856: CALL_OW 66
26860: GO 26848
26862: POP
26863: POP
// ChangeSideFog ( 8 , 1 ) ;
26864: LD_INT 8
26866: PPUSH
26867: LD_INT 1
26869: PPUSH
26870: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26874: LD_ADDR_VAR 0 2
26878: PUSH
26879: LD_INT 22
26881: PUSH
26882: LD_INT 8
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 21
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PPUSH
26903: CALL_OW 69
26907: PUSH
26908: LD_EXP 63
26912: PUSH
26913: LD_EXP 62
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: DIFF
26922: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26923: LD_VAR 0 2
26927: PUSH
26928: LD_INT 6
26930: PUSH
26931: LD_INT 5
26933: PUSH
26934: LD_INT 4
26936: PUSH
26937: LD_INT 3
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: PUSH
26946: LD_OWVAR 67
26950: ARRAY
26951: GREATEREQUAL
26952: IFFALSE 27104
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26954: LD_ADDR_VAR 0 3
26958: PUSH
26959: LD_INT 6
26961: PUSH
26962: LD_INT 5
26964: PUSH
26965: LD_INT 4
26967: PUSH
26968: LD_INT 3
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: LIST
26975: LIST
26976: PUSH
26977: LD_OWVAR 67
26981: ARRAY
26982: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26983: LD_ADDR_VAR 0 1
26987: PUSH
26988: DOUBLE
26989: LD_VAR 0 2
26993: PUSH
26994: LD_VAR 0 3
26998: PUSH
26999: LD_INT 1
27001: PLUS
27002: MINUS
27003: INC
27004: ST_TO_ADDR
27005: LD_INT 1
27007: PUSH
27008: FOR_DOWNTO
27009: IFFALSE 27100
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27011: LD_ADDR_EXP 38
27015: PUSH
27016: LD_EXP 38
27020: PUSH
27021: LD_VAR 0 2
27025: PUSH
27026: LD_VAR 0 1
27030: ARRAY
27031: ADD
27032: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27033: LD_VAR 0 2
27037: PUSH
27038: LD_VAR 0 1
27042: ARRAY
27043: PPUSH
27044: CALL_OW 310
27048: IFFALSE 27065
// ComExit ( tmp [ i ] ) ;
27050: LD_VAR 0 2
27054: PUSH
27055: LD_VAR 0 1
27059: ARRAY
27060: PPUSH
27061: CALL 105448 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27065: LD_VAR 0 2
27069: PUSH
27070: LD_VAR 0 1
27074: ARRAY
27075: PPUSH
27076: LD_INT 34
27078: PUSH
27079: LD_INT 0
27081: PPUSH
27082: LD_INT 6
27084: PPUSH
27085: CALL_OW 12
27089: PLUS
27090: PPUSH
27091: LD_INT 1
27093: PPUSH
27094: CALL_OW 171
// end ;
27098: GO 27008
27100: POP
27101: POP
// end else
27102: GO 27114
// x := tmp ;
27104: LD_ADDR_VAR 0 3
27108: PUSH
27109: LD_VAR 0 2
27113: ST_TO_ADDR
// for i := tmp downto tmp - x do
27114: LD_ADDR_VAR 0 1
27118: PUSH
27119: DOUBLE
27120: LD_VAR 0 2
27124: INC
27125: ST_TO_ADDR
27126: LD_VAR 0 2
27130: PUSH
27131: LD_VAR 0 3
27135: MINUS
27136: PUSH
27137: FOR_DOWNTO
27138: IFFALSE 27192
// begin if IsInUnit ( tmp [ i ] ) then
27140: LD_VAR 0 2
27144: PUSH
27145: LD_VAR 0 1
27149: ARRAY
27150: PPUSH
27151: CALL_OW 310
27155: IFFALSE 27172
// ComExit ( tmp [ i ] ) ;
27157: LD_VAR 0 2
27161: PUSH
27162: LD_VAR 0 1
27166: ARRAY
27167: PPUSH
27168: CALL 105448 0 1
// SetSide ( tmp [ i ] , 1 ) ;
27172: LD_VAR 0 2
27176: PUSH
27177: LD_VAR 0 1
27181: ARRAY
27182: PPUSH
27183: LD_INT 1
27185: PPUSH
27186: CALL_OW 235
// end ;
27190: GO 27137
27192: POP
27193: POP
// wait ( 0 0$0.3 ) ;
27194: LD_INT 10
27196: PPUSH
27197: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27201: LD_ADDR_VAR 0 1
27205: PUSH
27206: LD_INT 22
27208: PUSH
27209: LD_INT 8
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: PUSH
27216: LD_INT 21
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PPUSH
27230: CALL_OW 69
27234: PUSH
27235: FOR_IN
27236: IFFALSE 27249
// KillUnit ( i ) ;
27238: LD_VAR 0 1
27242: PPUSH
27243: CALL_OW 66
27247: GO 27235
27249: POP
27250: POP
// SetSide ( Kurt , 1 ) ;
27251: LD_EXP 62
27255: PPUSH
27256: LD_INT 1
27258: PPUSH
27259: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27263: LD_INT 22
27265: PUSH
27266: LD_INT 8
27268: PUSH
27269: EMPTY
27270: LIST
27271: LIST
27272: PUSH
27273: LD_INT 21
27275: PUSH
27276: LD_INT 3
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PPUSH
27287: CALL_OW 69
27291: PPUSH
27292: LD_INT 1
27294: PPUSH
27295: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27299: LD_INT 8
27301: PPUSH
27302: LD_INT 1
27304: PPUSH
27305: LD_INT 1
27307: PPUSH
27308: LD_INT 1
27310: PPUSH
27311: CALL_OW 80
// wait ( 1 1$20 ) ;
27315: LD_INT 2800
27317: PPUSH
27318: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27322: LD_EXP 64
27326: PPUSH
27327: LD_INT 37
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: LD_INT 0
27335: PPUSH
27336: CALL_OW 48
// wait ( 0 0$1 ) ;
27340: LD_INT 35
27342: PPUSH
27343: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27347: LD_EXP 64
27351: PPUSH
27352: LD_INT 60
27354: PPUSH
27355: LD_INT 95
27357: PPUSH
27358: CALL_OW 111
// end ;
27362: PPOPN 3
27364: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27365: LD_EXP 22
27369: NOT
27370: PUSH
27371: LD_INT 22
27373: PUSH
27374: LD_INT 8
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 21
27383: PUSH
27384: LD_INT 1
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PPUSH
27395: CALL_OW 69
27399: PUSH
27400: LD_INT 0
27402: EQUAL
27403: AND
27404: IFFALSE 27424
27406: GO 27408
27408: DISABLE
// begin legionDestroyed := true ;
27409: LD_ADDR_EXP 22
27413: PUSH
27414: LD_INT 1
27416: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27417: LD_STRING MlegionOut
27419: PPUSH
27420: CALL_OW 337
// end ;
27424: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27425: LD_EXP 38
27429: IFFALSE 27504
27431: GO 27433
27433: DISABLE
27434: LD_INT 0
27436: PPUSH
// begin enable ;
27437: ENABLE
// for i in legionEscapeUnits do
27438: LD_ADDR_VAR 0 1
27442: PUSH
27443: LD_EXP 38
27447: PUSH
27448: FOR_IN
27449: IFFALSE 27502
// begin if IsInArea ( i , legionEscapeArea ) then
27451: LD_VAR 0 1
27455: PPUSH
27456: LD_INT 31
27458: PPUSH
27459: CALL_OW 308
27463: IFFALSE 27476
// RemoveUnit ( i ) else
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 64
27474: GO 27500
// if not HasTask ( i ) then
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 314
27485: NOT
27486: IFFALSE 27500
// ComMoveToArea ( i , legionEscapeArea ) ;
27488: LD_VAR 0 1
27492: PPUSH
27493: LD_INT 31
27495: PPUSH
27496: CALL_OW 113
// end ;
27500: GO 27448
27502: POP
27503: POP
// end ;
27504: PPOPN 1
27506: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27507: LD_INT 1
27509: PPUSH
27510: LD_EXP 64
27514: PPUSH
27515: CALL_OW 292
27519: IFFALSE 27817
27521: GO 27523
27523: DISABLE
27524: LD_INT 0
27526: PPUSH
// begin wait ( 0 0$2 ) ;
27527: LD_INT 70
27529: PPUSH
27530: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27534: LD_EXP 64
27538: PPUSH
27539: CALL_OW 87
// DialogueOn ;
27543: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27547: LD_EXP 40
27551: PPUSH
27552: LD_STRING D14-JMM-1
27554: PPUSH
27555: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27559: LD_EXP 64
27563: PPUSH
27564: LD_STRING D14-Friend-1
27566: PPUSH
27567: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27571: LD_EXP 40
27575: PPUSH
27576: LD_STRING D14-JMM-2
27578: PPUSH
27579: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27583: LD_EXP 64
27587: PPUSH
27588: LD_STRING D14-Friend-2
27590: PPUSH
27591: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27595: LD_EXP 40
27599: PPUSH
27600: LD_STRING D14-JMM-3
27602: PPUSH
27603: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27607: LD_EXP 64
27611: PPUSH
27612: LD_STRING D14-Friend-3
27614: PPUSH
27615: CALL_OW 88
// DialogueOff ;
27619: CALL_OW 7
// dec = Query ( Q14 ) ;
27623: LD_ADDR_VAR 0 1
27627: PUSH
27628: LD_STRING Q14
27630: PPUSH
27631: CALL_OW 97
27635: ST_TO_ADDR
// if dec = 1 then
27636: LD_VAR 0 1
27640: PUSH
27641: LD_INT 1
27643: EQUAL
27644: IFFALSE 27678
// begin DialogueOn ;
27646: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27650: LD_EXP 40
27654: PPUSH
27655: LD_STRING D14a-JMM-1
27657: PPUSH
27658: CALL_OW 88
// DialogueOff ;
27662: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27666: LD_EXP 64
27670: PPUSH
27671: LD_INT 1
27673: PPUSH
27674: CALL_OW 235
// end ; if dec = 2 then
27678: LD_VAR 0 1
27682: PUSH
27683: LD_INT 2
27685: EQUAL
27686: IFFALSE 27739
// begin DialogueOn ;
27688: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27692: LD_EXP 40
27696: PPUSH
27697: LD_STRING D14b-JMM-1
27699: PPUSH
27700: CALL_OW 88
// DialogueOff ;
27704: CALL_OW 7
// wait ( 0 0$1 ) ;
27708: LD_INT 35
27710: PPUSH
27711: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27715: LD_EXP 64
27719: PPUSH
27720: LD_INT 9
27722: PPUSH
27723: LD_INT 2
27725: PPUSH
27726: CALL_OW 111
// AddComHold ( Friend ) ;
27730: LD_EXP 64
27734: PPUSH
27735: CALL_OW 200
// end ; if dec = 3 then
27739: LD_VAR 0 1
27743: PUSH
27744: LD_INT 3
27746: EQUAL
27747: IFFALSE 27817
// begin DialogueOn ;
27749: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27753: LD_EXP 40
27757: PPUSH
27758: LD_STRING D14c-JMM-1
27760: PPUSH
27761: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27765: LD_EXP 64
27769: PPUSH
27770: LD_STRING D14c-Friend-1
27772: PPUSH
27773: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27777: LD_EXP 40
27781: PPUSH
27782: LD_STRING D14c-JMM-2
27784: PPUSH
27785: CALL_OW 88
// DialogueOff ;
27789: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27793: LD_EXP 64
27797: PPUSH
27798: LD_INT 9
27800: PPUSH
27801: LD_INT 2
27803: PPUSH
27804: CALL_OW 111
// AddComHold ( Friend ) ;
27808: LD_EXP 64
27812: PPUSH
27813: CALL_OW 200
// end ; end ;
27817: PPOPN 1
27819: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27820: LD_INT 9
27822: PPUSH
27823: LD_INT 2
27825: PPUSH
27826: CALL_OW 428
27830: PUSH
27831: LD_EXP 64
27835: EQUAL
27836: PUSH
27837: LD_EXP 64
27841: PPUSH
27842: CALL_OW 255
27846: PUSH
27847: LD_INT 8
27849: EQUAL
27850: AND
27851: IFFALSE 27865
27853: GO 27855
27855: DISABLE
// RemoveUnit ( Friend ) ;
27856: LD_EXP 64
27860: PPUSH
27861: CALL_OW 64
27865: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27866: LD_EXP 14
27870: PUSH
27871: LD_INT 31500
27873: GREATEREQUAL
27874: PUSH
27875: LD_EXP 7
27879: AND
27880: PUSH
27881: LD_EXP 2
27885: AND
27886: IFFALSE 28316
27888: GO 27890
27890: DISABLE
27891: LD_INT 0
27893: PPUSH
27894: PPUSH
27895: PPUSH
// begin missionStage := 7 ;
27896: LD_ADDR_EXP 15
27900: PUSH
27901: LD_INT 7
27903: ST_TO_ADDR
// uc_side = 1 ;
27904: LD_ADDR_OWVAR 20
27908: PUSH
27909: LD_INT 1
27911: ST_TO_ADDR
// uc_nation = 1 ;
27912: LD_ADDR_OWVAR 21
27916: PUSH
27917: LD_INT 1
27919: ST_TO_ADDR
// for i = 1 to 5 do
27920: LD_ADDR_VAR 0 1
27924: PUSH
27925: DOUBLE
27926: LD_INT 1
27928: DEC
27929: ST_TO_ADDR
27930: LD_INT 5
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28030
// begin vc_engine = 3 ;
27936: LD_ADDR_OWVAR 39
27940: PUSH
27941: LD_INT 3
27943: ST_TO_ADDR
// vc_control = 3 ;
27944: LD_ADDR_OWVAR 38
27948: PUSH
27949: LD_INT 3
27951: ST_TO_ADDR
// vc_chassis = 3 ;
27952: LD_ADDR_OWVAR 37
27956: PUSH
27957: LD_INT 3
27959: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27960: LD_ADDR_OWVAR 40
27964: PUSH
27965: LD_INT 5
27967: PUSH
27968: LD_INT 9
27970: PUSH
27971: LD_INT 7
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 1
27981: PPUSH
27982: LD_INT 3
27984: PPUSH
27985: CALL_OW 12
27989: ARRAY
27990: ST_TO_ADDR
// veh = CreateVehicle ;
27991: LD_ADDR_VAR 0 2
27995: PUSH
27996: CALL_OW 45
28000: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28001: LD_VAR 0 2
28005: PPUSH
28006: LD_INT 1
28008: PPUSH
28009: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28013: LD_VAR 0 2
28017: PPUSH
28018: LD_INT 19
28020: PPUSH
28021: LD_INT 0
28023: PPUSH
28024: CALL_OW 49
// end ;
28028: GO 27933
28030: POP
28031: POP
// vc_engine = 3 ;
28032: LD_ADDR_OWVAR 39
28036: PUSH
28037: LD_INT 3
28039: ST_TO_ADDR
// vc_control = 1 ;
28040: LD_ADDR_OWVAR 38
28044: PUSH
28045: LD_INT 1
28047: ST_TO_ADDR
// vc_chassis = 3 ;
28048: LD_ADDR_OWVAR 37
28052: PUSH
28053: LD_INT 3
28055: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28056: LD_ADDR_OWVAR 40
28060: PUSH
28061: LD_INT 5
28063: PUSH
28064: LD_INT 9
28066: PUSH
28067: LD_INT 7
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 1
28077: PPUSH
28078: LD_INT 3
28080: PPUSH
28081: CALL_OW 12
28085: ARRAY
28086: ST_TO_ADDR
// vehG = CreateVehicle ;
28087: LD_ADDR_VAR 0 3
28091: PUSH
28092: CALL_OW 45
28096: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
28097: LD_VAR 0 3
28101: PPUSH
28102: LD_INT 1
28104: PPUSH
28105: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
28109: LD_VAR 0 3
28113: PPUSH
28114: LD_INT 19
28116: PPUSH
28117: LD_INT 0
28119: PPUSH
28120: CALL_OW 49
// if JMMGirl = 1 then
28124: LD_EXP 7
28128: PUSH
28129: LD_INT 1
28131: EQUAL
28132: IFFALSE 28188
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
28134: LD_ADDR_EXP 41
28138: PUSH
28139: LD_STRING Joan
28141: PPUSH
28142: LD_INT 1
28144: PPUSH
28145: LD_STRING 14_
28147: PPUSH
28148: CALL 67582 0 3
28152: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
28153: LD_EXP 41
28157: PPUSH
28158: LD_VAR 0 3
28162: PPUSH
28163: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28167: LD_VAR 0 3
28171: PPUSH
28172: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28176: LD_EXP 41
28180: PPUSH
28181: LD_STRING D10BW-Joan-1
28183: PPUSH
28184: CALL_OW 94
// end ; if JMMGirl = 2 then
28188: LD_EXP 7
28192: PUSH
28193: LD_INT 2
28195: EQUAL
28196: IFFALSE 28252
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28198: LD_ADDR_EXP 43
28202: PUSH
28203: LD_STRING Lisa
28205: PPUSH
28206: LD_INT 1
28208: PPUSH
28209: LD_STRING 14_
28211: PPUSH
28212: CALL 67582 0 3
28216: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28217: LD_EXP 43
28221: PPUSH
28222: LD_VAR 0 3
28226: PPUSH
28227: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28231: LD_VAR 0 3
28235: PPUSH
28236: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28240: LD_EXP 43
28244: PPUSH
28245: LD_STRING D10BW-Lisa-1
28247: PPUSH
28248: CALL_OW 94
// end ; if JMMGirl = 3 then
28252: LD_EXP 7
28256: PUSH
28257: LD_INT 3
28259: EQUAL
28260: IFFALSE 28316
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28262: LD_ADDR_EXP 55
28266: PUSH
28267: LD_STRING Connie
28269: PPUSH
28270: LD_INT 1
28272: PPUSH
28273: LD_STRING 14_
28275: PPUSH
28276: CALL 67582 0 3
28280: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28281: LD_EXP 55
28285: PPUSH
28286: LD_VAR 0 3
28290: PPUSH
28291: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28295: LD_VAR 0 3
28299: PPUSH
28300: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28304: LD_EXP 55
28308: PPUSH
28309: LD_STRING D10BW-Con-1
28311: PPUSH
28312: CALL_OW 94
// end ; end ;
28316: PPOPN 3
28318: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28319: LD_EXP 14
28323: PUSH
28324: LD_INT 94500
28326: GREATEREQUAL
28327: IFFALSE 28739
28329: GO 28331
28331: DISABLE
28332: LD_INT 0
28334: PPUSH
28335: PPUSH
28336: PPUSH
// begin tmp := PrepareStevensSquad ;
28337: LD_ADDR_VAR 0 3
28341: PUSH
28342: CALL 2323 0 0
28346: ST_TO_ADDR
// if not tmp then
28347: LD_VAR 0 3
28351: NOT
28352: IFFALSE 28356
// exit ;
28354: GO 28739
// uc_side := 1 ;
28356: LD_ADDR_OWVAR 20
28360: PUSH
28361: LD_INT 1
28363: ST_TO_ADDR
// uc_nation := 1 ;
28364: LD_ADDR_OWVAR 21
28368: PUSH
28369: LD_INT 1
28371: ST_TO_ADDR
// for i in tmp do
28372: LD_ADDR_VAR 0 1
28376: PUSH
28377: LD_VAR 0 3
28381: PUSH
28382: FOR_IN
28383: IFFALSE 28480
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28385: LD_INT 3
28387: PPUSH
28388: LD_INT 3
28390: PPUSH
28391: LD_INT 1
28393: PPUSH
28394: LD_INT 5
28396: PUSH
28397: LD_INT 9
28399: PUSH
28400: LD_INT 7
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 1
28410: PPUSH
28411: LD_INT 3
28413: PPUSH
28414: CALL_OW 12
28418: ARRAY
28419: PPUSH
28420: LD_INT 40
28422: PPUSH
28423: CALL 72597 0 5
// veh := CreateVehicle ;
28427: LD_ADDR_VAR 0 2
28431: PUSH
28432: CALL_OW 45
28436: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28437: LD_VAR 0 2
28441: PPUSH
28442: LD_INT 1
28444: PPUSH
28445: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28449: LD_VAR 0 2
28453: PPUSH
28454: LD_INT 19
28456: PPUSH
28457: LD_INT 0
28459: PPUSH
28460: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28464: LD_VAR 0 1
28468: PPUSH
28469: LD_VAR 0 2
28473: PPUSH
28474: CALL_OW 52
// end ;
28478: GO 28382
28480: POP
28481: POP
// missionStage := 8 ;
28482: LD_ADDR_EXP 15
28486: PUSH
28487: LD_INT 8
28489: ST_TO_ADDR
// DialogueOn ;
28490: CALL_OW 6
// if Stevens then
28494: LD_EXP 42
28498: IFFALSE 28612
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28500: LD_EXP 42
28504: PPUSH
28505: CALL_OW 310
28509: PPUSH
28510: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28514: LD_EXP 42
28518: PPUSH
28519: LD_STRING D8-Huck-1
28521: PPUSH
28522: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28526: LD_EXP 40
28530: PPUSH
28531: LD_STRING D8-JMM-1
28533: PPUSH
28534: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28538: LD_EXP 42
28542: PPUSH
28543: LD_STRING D8-Huck-2
28545: PPUSH
28546: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28550: LD_EXP 40
28554: PPUSH
28555: LD_STRING D8-JMM-2
28557: PPUSH
28558: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28562: LD_EXP 42
28566: PPUSH
28567: LD_STRING D8-Huck-3
28569: PPUSH
28570: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28574: LD_EXP 40
28578: PPUSH
28579: LD_STRING D8-JMM-3
28581: PPUSH
28582: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28586: LD_EXP 42
28590: PPUSH
28591: LD_STRING D8-Huck-4
28593: PPUSH
28594: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28598: LD_EXP 40
28602: PPUSH
28603: LD_STRING D8-JMM-4
28605: PPUSH
28606: CALL_OW 88
// end else
28610: GO 28722
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28612: LD_EXP 56
28616: PPUSH
28617: CALL_OW 310
28621: PPUSH
28622: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28626: LD_EXP 56
28630: PPUSH
28631: LD_STRING D8-Huck-1
28633: PPUSH
28634: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28638: LD_EXP 40
28642: PPUSH
28643: LD_STRING D8-JMM-1a
28645: PPUSH
28646: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28650: LD_EXP 56
28654: PPUSH
28655: LD_STRING D8-Huck-2
28657: PPUSH
28658: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28662: LD_EXP 40
28666: PPUSH
28667: LD_STRING D8-JMM-2
28669: PPUSH
28670: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28674: LD_EXP 56
28678: PPUSH
28679: LD_STRING D8-Huck-3
28681: PPUSH
28682: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28686: LD_EXP 40
28690: PPUSH
28691: LD_STRING D8-JMM-3
28693: PPUSH
28694: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28698: LD_EXP 56
28702: PPUSH
28703: LD_STRING D8-Huck-4
28705: PPUSH
28706: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28710: LD_EXP 40
28714: PPUSH
28715: LD_STRING D8-JMM-4
28717: PPUSH
28718: CALL_OW 88
// end ; DialogueOff ;
28722: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28726: LD_INT 25
28728: PPUSH
28729: LD_INT 1
28731: PPUSH
28732: LD_INT 1
28734: PPUSH
28735: CALL_OW 322
// end ;
28739: PPOPN 3
28741: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
28742: LD_EXP 73
28746: PPUSH
28747: CALL_OW 302
28751: PUSH
28752: LD_INT 1
28754: PPUSH
28755: LD_EXP 73
28759: PPUSH
28760: CALL_OW 292
28764: AND
28765: IFFALSE 29016
28767: GO 28769
28769: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28770: LD_EXP 73
28774: PPUSH
28775: CALL_OW 87
// DialogueOn ;
28779: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28783: LD_EXP 40
28787: PPUSH
28788: LD_STRING D10nB-JMM-1
28790: PPUSH
28791: CALL_OW 88
// if BurlakStatus = 1 then
28795: LD_EXP 9
28799: PUSH
28800: LD_INT 1
28802: EQUAL
28803: IFFALSE 28817
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28805: LD_EXP 72
28809: PPUSH
28810: LD_STRING D10nB-Vse-1a
28812: PPUSH
28813: CALL_OW 94
// end ; if BurlakStatus = 0 then
28817: LD_EXP 9
28821: PUSH
28822: LD_INT 0
28824: EQUAL
28825: IFFALSE 28839
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28827: LD_EXP 72
28831: PPUSH
28832: LD_STRING D10nB-Vse-1
28834: PPUSH
28835: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28839: LD_EXP 40
28843: PPUSH
28844: LD_STRING D10nB-JMM-2
28846: PPUSH
28847: CALL_OW 88
// if KappaStatus then
28851: LD_EXP 2
28855: IFFALSE 28869
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28857: LD_EXP 72
28861: PPUSH
28862: LD_STRING D10nB-Vse-5a
28864: PPUSH
28865: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28869: LD_EXP 2
28873: NOT
28874: PUSH
28875: LD_EXP 6
28879: PUSH
28880: LD_INT 0
28882: EQUAL
28883: AND
28884: IFFALSE 29012
// begin if JMMGirl = 1 then
28886: LD_EXP 7
28890: PUSH
28891: LD_INT 1
28893: EQUAL
28894: IFFALSE 28944
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28896: LD_EXP 72
28900: PPUSH
28901: LD_STRING D10nB-Vse-2
28903: PPUSH
28904: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28908: LD_EXP 40
28912: PPUSH
28913: LD_STRING D10nB-JMM-3
28915: PPUSH
28916: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28920: LD_EXP 72
28924: PPUSH
28925: LD_STRING D10nB-Vse-3
28927: PPUSH
28928: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28932: LD_EXP 40
28936: PPUSH
28937: LD_STRING D10nB-JMM-4
28939: PPUSH
28940: CALL_OW 88
// end ; if JMMGirl = 2 then
28944: LD_EXP 7
28948: PUSH
28949: LD_INT 2
28951: EQUAL
28952: IFFALSE 28978
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28954: LD_EXP 72
28958: PPUSH
28959: LD_STRING D10nB-Vse-4
28961: PPUSH
28962: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28966: LD_EXP 40
28970: PPUSH
28971: LD_STRING D10nB-JMM-5
28973: PPUSH
28974: CALL_OW 88
// end ; if JMMGirl = 3 then
28978: LD_EXP 7
28982: PUSH
28983: LD_INT 3
28985: EQUAL
28986: IFFALSE 29012
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28988: LD_EXP 72
28992: PPUSH
28993: LD_STRING D10nB-Vse-5
28995: PPUSH
28996: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29000: LD_EXP 40
29004: PPUSH
29005: LD_STRING D10nB-JMM-6
29007: PPUSH
29008: CALL_OW 88
// end ; end ; DialogueOff ;
29012: CALL_OW 7
// end ;
29016: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
29017: LD_EXP 14
29021: PUSH
29022: LD_INT 115500
29024: GREATEREQUAL
29025: IFFALSE 29401
29027: GO 29029
29029: DISABLE
29030: LD_INT 0
29032: PPUSH
// begin missionStage := 10 ;
29033: LD_ADDR_EXP 15
29037: PUSH
29038: LD_INT 10
29040: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29041: LD_ADDR_VAR 0 1
29045: PUSH
29046: LD_INT 22
29048: PUSH
29049: LD_INT 1
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 23
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 26
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 25
29081: PUSH
29082: LD_INT 12
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 3
29095: PUSH
29096: LD_INT 25
29098: PUSH
29099: LD_INT 16
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: LIST
29115: LIST
29116: PPUSH
29117: CALL_OW 69
29121: PUSH
29122: LD_EXP 40
29126: PUSH
29127: LD_EXP 62
29131: PUSH
29132: LD_EXP 42
29136: PUSH
29137: LD_EXP 56
29141: PUSH
29142: LD_EXP 43
29146: PUSH
29147: LD_EXP 44
29151: PUSH
29152: LD_EXP 45
29156: PUSH
29157: LD_EXP 46
29161: PUSH
29162: LD_EXP 47
29166: PUSH
29167: LD_EXP 48
29171: PUSH
29172: LD_EXP 49
29176: PUSH
29177: LD_EXP 50
29181: PUSH
29182: LD_EXP 51
29186: PUSH
29187: LD_EXP 52
29191: PUSH
29192: LD_EXP 53
29196: PUSH
29197: LD_EXP 54
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: DIFF
29220: ST_TO_ADDR
// if not tmp and Brown then
29221: LD_VAR 0 1
29225: NOT
29226: PUSH
29227: LD_EXP 48
29231: AND
29232: IFFALSE 29247
// tmp := [ Brown ] ;
29234: LD_ADDR_VAR 0 1
29238: PUSH
29239: LD_EXP 48
29243: PUSH
29244: EMPTY
29245: LIST
29246: ST_TO_ADDR
// DialogueOn ;
29247: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29251: LD_VAR 0 1
29255: PUSH
29256: LD_INT 1
29258: ARRAY
29259: PPUSH
29260: LD_STRING D11-Sol1-1
29262: PPUSH
29263: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29267: LD_EXP 66
29271: PPUSH
29272: LD_STRING D11-Pla-1
29274: PPUSH
29275: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29279: LD_EXP 67
29283: PPUSH
29284: LD_STRING D11-Kov-1
29286: PPUSH
29287: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29291: LD_EXP 66
29295: PPUSH
29296: LD_STRING D11-Pla-2
29298: PPUSH
29299: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29303: LD_VAR 0 1
29307: PUSH
29308: LD_INT 1
29310: ARRAY
29311: PPUSH
29312: LD_STRING D11-Sol1-2
29314: PPUSH
29315: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29319: LD_EXP 40
29323: PPUSH
29324: LD_STRING D11-JMM-2
29326: PPUSH
29327: CALL_OW 88
// DialogueOff ;
29331: CALL_OW 7
// allowBehemothConstruct := true ;
29335: LD_ADDR_EXP 25
29339: PUSH
29340: LD_INT 1
29342: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29343: LD_STRING M4
29345: PPUSH
29346: CALL_OW 337
// BuildBehemoths ;
29350: CALL 7903 0 0
// repeat wait ( 15 15$00 ) ;
29354: LD_INT 31500
29356: PPUSH
29357: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29361: LD_EXP 27
29365: IFFALSE 29369
// break ;
29367: GO 29401
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29369: LD_INT 267
29371: PPUSH
29372: CALL_OW 274
29376: PPUSH
29377: LD_INT 1
29379: PPUSH
29380: CALL_OW 275
29384: PUSH
29385: LD_INT 1000
29387: GREATEREQUAL
29388: IFFALSE 29394
// BuildBehemoths ;
29390: CALL 7903 0 0
// until not behemothBuilders ;
29394: LD_EXP 75
29398: NOT
29399: IFFALSE 29354
// end ;
29401: PPOPN 1
29403: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29404: LD_EXP 75
29408: NOT
29409: PUSH
29410: LD_EXP 28
29414: NOT
29415: AND
29416: PUSH
29417: LD_EXP 25
29421: AND
29422: IFFALSE 29442
29424: GO 29426
29426: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29427: LD_STRING M4a
29429: PPUSH
29430: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29434: LD_ADDR_EXP 27
29438: PUSH
29439: LD_INT 1
29441: ST_TO_ADDR
// end ;
29442: END
// every 0 0$1 trigger behemothDone do
29443: LD_EXP 28
29447: IFFALSE 29459
29449: GO 29451
29451: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29452: LD_STRING M4b
29454: PPUSH
29455: CALL_OW 337
29459: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29460: LD_EXP 29
29464: NOT
29465: IFFALSE 29661
29467: GO 29469
29469: DISABLE
29470: LD_INT 0
29472: PPUSH
29473: PPUSH
// begin enable ;
29474: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29475: LD_ADDR_VAR 0 1
29479: PUSH
29480: LD_INT 3
29482: PPUSH
29483: CALL 105111 0 1
29487: ST_TO_ADDR
// if not tmp and not behemothDone then
29488: LD_VAR 0 1
29492: NOT
29493: PUSH
29494: LD_EXP 28
29498: NOT
29499: AND
29500: IFFALSE 29536
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29502: LD_ADDR_VAR 0 1
29506: PUSH
29507: LD_INT 22
29509: PUSH
29510: LD_INT 3
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 30
29519: PUSH
29520: LD_INT 37
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PPUSH
29531: CALL_OW 69
29535: ST_TO_ADDR
// if not tmp then
29536: LD_VAR 0 1
29540: NOT
29541: IFFALSE 29545
// exit ;
29543: GO 29661
// for i in tmp do
29545: LD_ADDR_VAR 0 2
29549: PUSH
29550: LD_VAR 0 1
29554: PUSH
29555: FOR_IN
29556: IFFALSE 29659
// if See ( 1 , i ) then
29558: LD_INT 1
29560: PPUSH
29561: LD_VAR 0 2
29565: PPUSH
29566: CALL_OW 292
29570: IFFALSE 29657
// begin if GetType ( i ) = unit_building then
29572: LD_VAR 0 2
29576: PPUSH
29577: CALL_OW 247
29581: PUSH
29582: LD_INT 3
29584: EQUAL
29585: IFFALSE 29623
// begin disable ;
29587: DISABLE
// CenterNowOnUnits ( i ) ;
29588: LD_VAR 0 2
29592: PPUSH
29593: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29597: LD_EXP 40
29601: PPUSH
29602: LD_STRING D17a-JMM-1
29604: PPUSH
29605: CALL_OW 88
// seeBehemoth := true ;
29609: LD_ADDR_EXP 29
29613: PUSH
29614: LD_INT 1
29616: ST_TO_ADDR
// exit ;
29617: POP
29618: POP
29619: GO 29661
// end else
29621: GO 29657
// begin disable ;
29623: DISABLE
// CenterNowOnUnits ( i ) ;
29624: LD_VAR 0 2
29628: PPUSH
29629: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29633: LD_EXP 40
29637: PPUSH
29638: LD_STRING D17b-JMM-1
29640: PPUSH
29641: CALL_OW 88
// seeBehemoth := true ;
29645: LD_ADDR_EXP 29
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// exit ;
29653: POP
29654: POP
29655: GO 29661
// end ; end ;
29657: GO 29555
29659: POP
29660: POP
// end ;
29661: PPOPN 2
29663: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29664: LD_EXP 14
29668: PUSH
29669: LD_INT 123200
29671: GREATEREQUAL
29672: IFFALSE 30872
29674: GO 29676
29676: DISABLE
29677: LD_INT 0
29679: PPUSH
29680: PPUSH
29681: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29682: LD_INT 2
29684: PPUSH
29685: LD_INT 23
29687: PUSH
29688: LD_INT 3
29690: PUSH
29691: LD_INT 3
29693: PUSH
29694: LD_INT 48
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: PUSH
29703: EMPTY
29704: LIST
29705: PPUSH
29706: CALL 61156 0 2
// repeat wait ( 0 0$1 ) ;
29710: LD_INT 35
29712: PPUSH
29713: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29717: LD_INT 22
29719: PUSH
29720: LD_INT 3
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 34
29729: PUSH
29730: LD_INT 48
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PPUSH
29741: CALL_OW 69
29745: IFFALSE 29710
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29747: LD_ADDR_VAR 0 1
29751: PUSH
29752: LD_INT 22
29754: PUSH
29755: LD_INT 3
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 34
29764: PUSH
29765: LD_INT 48
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PPUSH
29776: CALL_OW 69
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: ST_TO_ADDR
// missionStage := 12 ;
29785: LD_ADDR_EXP 15
29789: PUSH
29790: LD_INT 12
29792: ST_TO_ADDR
// platonovHasBomb := true ;
29793: LD_ADDR_EXP 30
29797: PUSH
29798: LD_INT 1
29800: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29801: LD_VAR 0 1
29805: PPUSH
29806: LD_INT 181
29808: PPUSH
29809: LD_INT 86
29811: PPUSH
29812: CALL_OW 171
// AddComHold ( bomb ) ;
29816: LD_VAR 0 1
29820: PPUSH
29821: CALL_OW 200
// wait ( 0 0$10 ) ;
29825: LD_INT 350
29827: PPUSH
29828: CALL_OW 67
// DialogueOn ;
29832: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29836: LD_EXP 66
29840: PPUSH
29841: LD_STRING D15-Pla-1
29843: PPUSH
29844: CALL_OW 94
// dec = Query ( Q15a ) ;
29848: LD_ADDR_VAR 0 2
29852: PUSH
29853: LD_STRING Q15a
29855: PPUSH
29856: CALL_OW 97
29860: ST_TO_ADDR
// if dec = 1 then
29861: LD_VAR 0 2
29865: PUSH
29866: LD_INT 1
29868: EQUAL
29869: IFFALSE 29892
// begin Say ( JMM , D15a-JMM-1 ) ;
29871: LD_EXP 40
29875: PPUSH
29876: LD_STRING D15a-JMM-1
29878: PPUSH
29879: CALL_OW 88
// YouLost ( Surrender ) ;
29883: LD_STRING Surrender
29885: PPUSH
29886: CALL_OW 104
// exit ;
29890: GO 30872
// end ; if dec = 2 then
29892: LD_VAR 0 2
29896: PUSH
29897: LD_INT 2
29899: EQUAL
29900: IFFALSE 29969
// begin Say ( JMM , D15b-JMM-1 ) ;
29902: LD_EXP 40
29906: PPUSH
29907: LD_STRING D15b-JMM-1
29909: PPUSH
29910: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29914: LD_EXP 66
29918: PPUSH
29919: LD_STRING D15b-Pla-1
29921: PPUSH
29922: CALL_OW 94
// DialogueOff ;
29926: CALL_OW 7
// wait ( 3 3$00 ) ;
29930: LD_INT 6300
29932: PPUSH
29933: CALL_OW 67
// DialogueOn ;
29937: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29941: LD_EXP 40
29945: PPUSH
29946: LD_STRING D15d-JMM-1a
29948: PPUSH
29949: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29953: LD_EXP 66
29957: PPUSH
29958: LD_STRING D15d-Pla-1
29960: PPUSH
29961: CALL_OW 94
// DialogueOff ;
29965: CALL_OW 7
// end ; if dec = 3 then
29969: LD_VAR 0 2
29973: PUSH
29974: LD_INT 3
29976: EQUAL
29977: IFFALSE 30031
// begin Say ( JMM , D15c-JMM-1 ) ;
29979: LD_EXP 40
29983: PPUSH
29984: LD_STRING D15c-JMM-1
29986: PPUSH
29987: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29991: LD_EXP 66
29995: PPUSH
29996: LD_STRING D15c-Pla-1
29998: PPUSH
29999: CALL_OW 94
// DialogueOff ;
30003: CALL_OW 7
// wait ( 0 0$15 ) ;
30007: LD_INT 525
30009: PPUSH
30010: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30014: LD_VAR 0 1
30018: PPUSH
30019: LD_INT 60
30021: PPUSH
30022: LD_INT 95
30024: PPUSH
30025: CALL_OW 116
// exit ;
30029: GO 30872
// end ; if dec = 4 then
30031: LD_VAR 0 2
30035: PUSH
30036: LD_INT 4
30038: EQUAL
30039: IFFALSE 30069
// begin Say ( JMM , D15d-JMM-1 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D15d-JMM-1
30048: PPUSH
30049: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D15d-Pla-1
30060: PPUSH
30061: CALL_OW 94
// DialogueOff ;
30065: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30069: LD_EXP 64
30073: PPUSH
30074: CALL_OW 302
30078: PUSH
30079: LD_EXP 64
30083: PPUSH
30084: CALL_OW 255
30088: PUSH
30089: LD_INT 1
30091: EQUAL
30092: AND
30093: PUSH
30094: LD_INT 22
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 34
30106: PUSH
30107: LD_INT 8
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PPUSH
30118: CALL_OW 69
30122: NOT
30123: AND
30124: IFFALSE 30773
// begin SetSide ( Friend , 8 ) ;
30126: LD_EXP 64
30130: PPUSH
30131: LD_INT 8
30133: PPUSH
30134: CALL_OW 235
// if IsInUnit ( Friend ) then
30138: LD_EXP 64
30142: PPUSH
30143: CALL_OW 310
30147: IFFALSE 30158
// ComExitBuilding ( Friend ) ;
30149: LD_EXP 64
30153: PPUSH
30154: CALL_OW 122
// if IsDriver ( Friend ) then
30158: LD_EXP 64
30162: PPUSH
30163: CALL 102666 0 1
30167: IFFALSE 30178
// ComExitVehicle ( Friend ) ;
30169: LD_EXP 64
30173: PPUSH
30174: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30178: LD_EXP 64
30182: PPUSH
30183: LD_INT 9
30185: PPUSH
30186: LD_INT 2
30188: PPUSH
30189: CALL_OW 171
// wait ( 0 0$05 ) ;
30193: LD_INT 175
30195: PPUSH
30196: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30200: LD_EXP 64
30204: PPUSH
30205: CALL_OW 87
// DialogueOn ;
30209: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30213: LD_EXP 40
30217: PPUSH
30218: LD_STRING D16-JMM-1
30220: PPUSH
30221: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30225: LD_EXP 64
30229: PPUSH
30230: LD_STRING D16-Friend-1
30232: PPUSH
30233: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30237: LD_EXP 40
30241: PPUSH
30242: LD_STRING D16-JMM-2
30244: PPUSH
30245: CALL_OW 88
// DialogueOff ;
30249: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30253: LD_EXP 64
30257: PPUSH
30258: LD_INT 1
30260: PPUSH
30261: CALL_OW 235
// ComHold ( Friend ) ;
30265: LD_EXP 64
30269: PPUSH
30270: CALL_OW 140
// wait ( 0 0$20 ) ;
30274: LD_INT 700
30276: PPUSH
30277: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30281: LD_EXP 64
30285: PPUSH
30286: LD_INT 9
30288: PPUSH
30289: LD_INT 2
30291: PPUSH
30292: CALL_OW 297
30296: PUSH
30297: LD_INT 30
30299: LESS
30300: IFFALSE 30369
// begin SetSide ( Friend , 8 ) ;
30302: LD_EXP 64
30306: PPUSH
30307: LD_INT 8
30309: PPUSH
30310: CALL_OW 235
// if IsInUnit ( Friend ) then
30314: LD_EXP 64
30318: PPUSH
30319: CALL_OW 310
30323: IFFALSE 30334
// ComExitBuilding ( Friend ) ;
30325: LD_EXP 64
30329: PPUSH
30330: CALL_OW 122
// if IsDriver ( Friend ) then
30334: LD_EXP 64
30338: PPUSH
30339: CALL 102666 0 1
30343: IFFALSE 30354
// ComExitVehicle ( Friend ) ;
30345: LD_EXP 64
30349: PPUSH
30350: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30354: LD_EXP 64
30358: PPUSH
30359: LD_INT 9
30361: PPUSH
30362: LD_INT 2
30364: PPUSH
30365: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30369: LD_INT 1050
30371: PPUSH
30372: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30376: LD_INT 22
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 34
30388: PUSH
30389: LD_INT 8
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PPUSH
30400: CALL_OW 69
30404: NOT
30405: IFFALSE 30751
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30407: LD_ADDR_VAR 0 3
30411: PUSH
30412: LD_INT 22
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 26
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 25
30437: PUSH
30438: LD_INT 12
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 25
30447: PUSH
30448: LD_INT 16
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: LIST
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: LIST
30464: PPUSH
30465: CALL_OW 69
30469: PUSH
30470: LD_EXP 40
30474: PUSH
30475: LD_EXP 42
30479: PUSH
30480: LD_EXP 56
30484: PUSH
30485: LD_EXP 43
30489: PUSH
30490: LD_EXP 44
30494: PUSH
30495: LD_EXP 45
30499: PUSH
30500: LD_EXP 46
30504: PUSH
30505: LD_EXP 47
30509: PUSH
30510: LD_EXP 48
30514: PUSH
30515: LD_EXP 49
30519: PUSH
30520: LD_EXP 50
30524: PUSH
30525: LD_EXP 51
30529: PUSH
30530: LD_EXP 52
30534: PUSH
30535: LD_EXP 53
30539: PUSH
30540: LD_EXP 54
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: DIFF
30562: ST_TO_ADDR
// DialogueOn ;
30563: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30567: LD_EXP 66
30571: PPUSH
30572: LD_STRING D16a-Pla-1
30574: PPUSH
30575: CALL_OW 94
// if Stevens then
30579: LD_EXP 42
30583: IFFALSE 30599
// Say ( Stevens , D16a-Huck-1 ) else
30585: LD_EXP 42
30589: PPUSH
30590: LD_STRING D16a-Huck-1
30592: PPUSH
30593: CALL_OW 88
30597: GO 30641
// if Baker then
30599: LD_EXP 56
30603: IFFALSE 30619
// Say ( Baker , D16a-Huck-1 ) else
30605: LD_EXP 56
30609: PPUSH
30610: LD_STRING D16a-Huck-1
30612: PPUSH
30613: CALL_OW 88
30617: GO 30641
// if tmp then
30619: LD_VAR 0 3
30623: IFFALSE 30641
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30625: LD_VAR 0 3
30629: PUSH
30630: LD_INT 1
30632: ARRAY
30633: PPUSH
30634: LD_STRING D16a-Sol1-1
30636: PPUSH
30637: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30641: LD_EXP 64
30645: PPUSH
30646: CALL_OW 255
30650: PUSH
30651: LD_INT 8
30653: EQUAL
30654: IFFALSE 30670
// Say ( JMM , D16a-JMM-1 ) else
30656: LD_EXP 40
30660: PPUSH
30661: LD_STRING D16a-JMM-1
30663: PPUSH
30664: CALL_OW 88
30668: GO 30730
// begin Say ( JMM , D16a-JMM-1a ) ;
30670: LD_EXP 40
30674: PPUSH
30675: LD_STRING D16a-JMM-1a
30677: PPUSH
30678: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30682: LD_EXP 64
30686: PPUSH
30687: LD_STRING D16a-Friend-1
30689: PPUSH
30690: CALL_OW 88
// ComExitBuilding ( Friend ) ;
30694: LD_EXP 64
30698: PPUSH
30699: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
30703: LD_EXP 64
30707: PPUSH
30708: LD_INT 191
30710: PPUSH
30711: LD_INT 103
30713: PPUSH
30714: CALL_OW 171
// SetSide ( Friend , 3 ) ;
30718: LD_EXP 64
30722: PPUSH
30723: LD_INT 3
30725: PPUSH
30726: CALL_OW 235
// end ; DialogueOff ;
30730: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30734: LD_VAR 0 1
30738: PPUSH
30739: LD_INT 60
30741: PPUSH
30742: LD_INT 95
30744: PPUSH
30745: CALL_OW 116
// end else
30749: GO 30771
// begin DialogueOn ;
30751: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30755: LD_EXP 66
30759: PPUSH
30760: LD_STRING D16c-Pla-1
30762: PPUSH
30763: CALL_OW 94
// DialogueOff ;
30767: CALL_OW 7
// end ; end else
30771: GO 30872
// begin wait ( 3 3$00 ) ;
30773: LD_INT 6300
30775: PPUSH
30776: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30780: LD_INT 22
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 34
30792: PUSH
30793: LD_INT 8
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PPUSH
30804: CALL_OW 69
30808: NOT
30809: IFFALSE 30852
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30811: LD_EXP 66
30815: PPUSH
30816: LD_STRING D16b-Pla-1
30818: PPUSH
30819: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
30823: LD_EXP 40
30827: PPUSH
30828: LD_STRING D16b-JMM-1
30830: PPUSH
30831: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30835: LD_VAR 0 1
30839: PPUSH
30840: LD_INT 60
30842: PPUSH
30843: LD_INT 95
30845: PPUSH
30846: CALL_OW 116
// end else
30850: GO 30872
// begin DialogueOn ;
30852: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30856: LD_EXP 66
30860: PPUSH
30861: LD_STRING D16c-Pla-1
30863: PPUSH
30864: CALL_OW 94
// DialogueOff ;
30868: CALL_OW 7
// end ; end ; end ;
30872: PPOPN 3
30874: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30875: LD_EXP 14
30879: PUSH
30880: LD_INT 126000
30882: GREATEREQUAL
30883: PUSH
30884: LD_EXP 23
30888: NOT
30889: AND
30890: PUSH
30891: LD_EXP 77
30895: PPUSH
30896: CALL_OW 302
30900: AND
30901: IFFALSE 31259
30903: GO 30905
30905: DISABLE
30906: LD_INT 0
30908: PPUSH
// begin missionStage = 11 ;
30909: LD_ADDR_EXP 15
30913: PUSH
30914: LD_INT 11
30916: ST_TO_ADDR
// DialogueOn ;
30917: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30921: LD_EXP 77
30925: PPUSH
30926: LD_STRING D9-Roth-1
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9-JMM-1
30940: PPUSH
30941: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30945: LD_EXP 77
30949: PPUSH
30950: LD_STRING D9-Roth-2
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30957: LD_EXP 77
30961: PPUSH
30962: LD_STRING D9-Roth-2a
30964: PPUSH
30965: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30969: LD_EXP 66
30973: PPUSH
30974: LD_STRING D9-Pla-2
30976: PPUSH
30977: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30981: LD_EXP 77
30985: PPUSH
30986: LD_STRING D9-Roth-3
30988: PPUSH
30989: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30993: LD_EXP 66
30997: PPUSH
30998: LD_STRING D9-Pla-3
31000: PPUSH
31001: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31005: LD_EXP 77
31009: PPUSH
31010: LD_STRING D9-Roth-4
31012: PPUSH
31013: CALL_OW 94
// dec = Query ( Q9 ) ;
31017: LD_ADDR_VAR 0 1
31021: PUSH
31022: LD_STRING Q9
31024: PPUSH
31025: CALL_OW 97
31029: ST_TO_ADDR
// if dec = 1 then
31030: LD_VAR 0 1
31034: PUSH
31035: LD_INT 1
31037: EQUAL
31038: IFFALSE 31052
// SayRadio ( Roth , D9a-Roth-1 ) ;
31040: LD_EXP 77
31044: PPUSH
31045: LD_STRING D9a-Roth-1
31047: PPUSH
31048: CALL_OW 94
// if dec = 2 then
31052: LD_VAR 0 1
31056: PUSH
31057: LD_INT 2
31059: EQUAL
31060: IFFALSE 31086
// begin Say ( JMM , D9b-JMM-1 ) ;
31062: LD_EXP 40
31066: PPUSH
31067: LD_STRING D9b-JMM-1
31069: PPUSH
31070: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
31074: LD_EXP 77
31078: PPUSH
31079: LD_STRING D9b-Roth-1
31081: PPUSH
31082: CALL_OW 94
// end ; if dec = 3 then
31086: LD_VAR 0 1
31090: PUSH
31091: LD_INT 3
31093: EQUAL
31094: IFFALSE 31156
// begin Say ( JMM , D9c-JMM-1 ) ;
31096: LD_EXP 40
31100: PPUSH
31101: LD_STRING D9c-JMM-1
31103: PPUSH
31104: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
31108: LD_EXP 77
31112: PPUSH
31113: LD_STRING D9c-Roth-1
31115: PPUSH
31116: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
31120: LD_EXP 40
31124: PPUSH
31125: LD_STRING D9c-JMM-2
31127: PPUSH
31128: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
31132: LD_EXP 77
31136: PPUSH
31137: LD_STRING D9c-Roth-2
31139: PPUSH
31140: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
31144: LD_EXP 40
31148: PPUSH
31149: LD_STRING D9c-JMM-3
31151: PPUSH
31152: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
31156: LD_EXP 77
31160: PPUSH
31161: LD_STRING D9c-Roth-3
31163: PPUSH
31164: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
31168: LD_EXP 77
31172: PPUSH
31173: LD_STRING D9cont-Roth-1
31175: PPUSH
31176: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
31180: LD_EXP 40
31184: PPUSH
31185: LD_STRING D9cont-JMM-1
31187: PPUSH
31188: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
31192: LD_EXP 77
31196: PPUSH
31197: LD_STRING D9cont-Roth-2
31199: PPUSH
31200: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
31204: LD_EXP 40
31208: PPUSH
31209: LD_STRING D9cont-JMM-2
31211: PPUSH
31212: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31216: LD_EXP 77
31220: PPUSH
31221: LD_STRING D9cont-Roth-3
31223: PPUSH
31224: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31228: LD_EXP 40
31232: PPUSH
31233: LD_STRING D9cont-JMM-3
31235: PPUSH
31236: CALL_OW 88
// DialogueOff ;
31240: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31244: LD_STRING M3
31246: PPUSH
31247: CALL_OW 337
// allianceActive := true ;
31251: LD_ADDR_EXP 31
31255: PUSH
31256: LD_INT 1
31258: ST_TO_ADDR
// end ;
31259: PPOPN 1
31261: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31262: LD_INT 1
31264: PPUSH
31265: LD_INT 126
31267: PPUSH
31268: CALL_OW 292
31272: PUSH
31273: LD_EXP 66
31277: PPUSH
31278: CALL_OW 310
31282: AND
31283: IFFALSE 31363
31285: GO 31287
31287: DISABLE
31288: LD_INT 0
31290: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31291: LD_EXP 66
31295: PPUSH
31296: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31300: LD_ADDR_VAR 0 1
31304: PUSH
31305: LD_INT 4
31307: PPUSH
31308: LD_INT 22
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 70
31322: PPUSH
31323: LD_EXP 66
31327: PPUSH
31328: CALL_OW 74
31332: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31333: LD_EXP 66
31337: PPUSH
31338: LD_VAR 0 1
31342: PUSH
31343: LD_INT 1
31345: ARRAY
31346: PPUSH
31347: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31351: LD_EXP 66
31355: PPUSH
31356: LD_STRING D18-Pla-1
31358: PPUSH
31359: CALL_OW 88
// end ;
31363: PPOPN 1
31365: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31366: LD_EXP 66
31370: PPUSH
31371: CALL_OW 301
31375: PUSH
31376: LD_EXP 69
31380: PPUSH
31381: CALL_OW 301
31385: AND
31386: PUSH
31387: LD_INT 22
31389: PUSH
31390: LD_INT 3
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 21
31399: PUSH
31400: LD_INT 1
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 50
31409: PUSH
31410: EMPTY
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: LIST
31417: PPUSH
31418: CALL_OW 69
31422: PUSH
31423: LD_INT 7
31425: PUSH
31426: LD_INT 8
31428: PUSH
31429: LD_INT 9
31431: PUSH
31432: LD_INT 10
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: PUSH
31441: LD_OWVAR 67
31445: ARRAY
31446: LESS
31447: AND
31448: IFFALSE 32247
31450: GO 31452
31452: DISABLE
31453: LD_INT 0
31455: PPUSH
31456: PPUSH
31457: PPUSH
31458: PPUSH
// begin MC_Kill ( 2 ) ;
31459: LD_INT 2
31461: PPUSH
31462: CALL 37129 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31466: LD_INT 1
31468: PPUSH
31469: LD_INT 3
31471: PPUSH
31472: LD_INT 1
31474: PPUSH
31475: LD_INT 1
31477: PPUSH
31478: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31482: LD_ADDR_VAR 0 2
31486: PUSH
31487: LD_INT 22
31489: PUSH
31490: LD_INT 3
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 21
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 50
31509: PUSH
31510: EMPTY
31511: LIST
31512: PUSH
31513: LD_INT 26
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: PPUSH
31529: CALL_OW 69
31533: ST_TO_ADDR
// if not tmp then
31534: LD_VAR 0 2
31538: NOT
31539: IFFALSE 31595
// begin uc_side = 3 ;
31541: LD_ADDR_OWVAR 20
31545: PUSH
31546: LD_INT 3
31548: ST_TO_ADDR
// uc_nation = 3 ;
31549: LD_ADDR_OWVAR 21
31553: PUSH
31554: LD_INT 3
31556: ST_TO_ADDR
// hc_name =  ;
31557: LD_ADDR_OWVAR 26
31561: PUSH
31562: LD_STRING 
31564: ST_TO_ADDR
// hc_gallery =  ;
31565: LD_ADDR_OWVAR 33
31569: PUSH
31570: LD_STRING 
31572: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31573: LD_INT 1
31575: PPUSH
31576: LD_INT 10
31578: PPUSH
31579: CALL_OW 381
// tmp = CreateHuman ;
31583: LD_ADDR_VAR 0 2
31587: PUSH
31588: CALL_OW 44
31592: ST_TO_ADDR
// end else
31593: GO 31609
// tmp := tmp [ 1 ] ;
31595: LD_ADDR_VAR 0 2
31599: PUSH
31600: LD_VAR 0 2
31604: PUSH
31605: LD_INT 1
31607: ARRAY
31608: ST_TO_ADDR
// DialogueOn ;
31609: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31613: LD_VAR 0 2
31617: PPUSH
31618: LD_STRING DSurrenderRussians-RSol1-1a
31620: PPUSH
31621: CALL_OW 94
// DialogueOff ;
31625: CALL_OW 7
// russianDestroyed := true ;
31629: LD_ADDR_EXP 21
31633: PUSH
31634: LD_INT 1
31636: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
31637: LD_ADDR_VAR 0 1
31641: PUSH
31642: LD_INT 22
31644: PUSH
31645: LD_INT 6
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PPUSH
31652: CALL_OW 69
31656: PUSH
31657: FOR_IN
31658: IFFALSE 31671
// KillUnit ( i ) ;
31660: LD_VAR 0 1
31664: PPUSH
31665: CALL_OW 66
31669: GO 31657
31671: POP
31672: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31673: LD_INT 22
31675: PUSH
31676: LD_INT 3
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 1
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PPUSH
31697: CALL_OW 69
31701: PPUSH
31702: CALL_OW 122
// wait ( 0 0$1 ) ;
31706: LD_INT 35
31708: PPUSH
31709: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31713: LD_INT 22
31715: PUSH
31716: LD_INT 3
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 21
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: PPUSH
31742: LD_INT 25
31744: PPUSH
31745: CALL_OW 173
// wait ( 0 0$35 ) ;
31749: LD_INT 1225
31751: PPUSH
31752: CALL_OW 67
// PrepareOmarInvasion ;
31756: CALL 14772 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31760: LD_ADDR_VAR 0 2
31764: PUSH
31765: LD_EXP 95
31769: PPUSH
31770: CALL_OW 250
31774: PUSH
31775: LD_EXP 95
31779: PPUSH
31780: CALL_OW 251
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31789: LD_VAR 0 2
31793: PUSH
31794: LD_INT 1
31796: ARRAY
31797: PPUSH
31798: LD_VAR 0 2
31802: PUSH
31803: LD_INT 2
31805: ARRAY
31806: PPUSH
31807: LD_INT 1
31809: PPUSH
31810: LD_INT 8
31812: NEG
31813: PPUSH
31814: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31818: LD_EXP 95
31822: PPUSH
31823: CALL_OW 87
// DialogueOn ;
31827: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31831: LD_EXP 40
31835: PPUSH
31836: LD_STRING D19-JMM-1
31838: PPUSH
31839: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31843: LD_ADDR_VAR 0 3
31847: PUSH
31848: LD_INT 22
31850: PUSH
31851: LD_INT 1
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 26
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: LD_INT 25
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 25
31883: PUSH
31884: LD_INT 2
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 25
31893: PUSH
31894: LD_INT 3
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 25
31903: PUSH
31904: LD_INT 4
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 25
31913: PUSH
31914: LD_INT 5
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 25
31923: PUSH
31924: LD_INT 8
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: LIST
31944: PPUSH
31945: CALL_OW 69
31949: PUSH
31950: LD_EXP 40
31954: PUSH
31955: LD_EXP 41
31959: PUSH
31960: LD_EXP 62
31964: PUSH
31965: LD_EXP 42
31969: PUSH
31970: LD_EXP 43
31974: PUSH
31975: LD_EXP 44
31979: PUSH
31980: LD_EXP 45
31984: PUSH
31985: LD_EXP 46
31989: PUSH
31990: LD_EXP 47
31994: PUSH
31995: LD_EXP 48
31999: PUSH
32000: LD_EXP 49
32004: PUSH
32005: LD_EXP 50
32009: PUSH
32010: LD_EXP 51
32014: PUSH
32015: LD_EXP 52
32019: PUSH
32020: LD_EXP 53
32024: PUSH
32025: LD_EXP 54
32029: PUSH
32030: LD_EXP 55
32034: PUSH
32035: LD_EXP 56
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: DIFF
32060: ST_TO_ADDR
// if tmp2 then
32061: LD_VAR 0 3
32065: IFFALSE 32083
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
32067: LD_VAR 0 3
32071: PUSH
32072: LD_INT 1
32074: ARRAY
32075: PPUSH
32076: LD_STRING D19-Sol1-1
32078: PPUSH
32079: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
32083: LD_EXP 40
32087: PPUSH
32088: LD_STRING D19-JMM-2
32090: PPUSH
32091: CALL_OW 88
// DialogueOff ;
32095: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
32099: LD_VAR 0 2
32103: PUSH
32104: LD_INT 1
32106: ARRAY
32107: PPUSH
32108: LD_VAR 0 2
32112: PUSH
32113: LD_INT 2
32115: ARRAY
32116: PPUSH
32117: LD_INT 1
32119: PPUSH
32120: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
32124: LD_STRING M5
32126: PPUSH
32127: CALL_OW 337
// omarOnMotherLode := false ;
32131: LD_ADDR_VAR 0 4
32135: PUSH
32136: LD_INT 0
32138: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
32139: LD_INT 35
32141: PPUSH
32142: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
32146: LD_EXP 95
32150: PPUSH
32151: LD_INT 215
32153: PPUSH
32154: LD_INT 100
32156: PPUSH
32157: CALL_OW 297
32161: PUSH
32162: LD_INT 10
32164: LESS
32165: PUSH
32166: LD_VAR 0 4
32170: NOT
32171: AND
32172: IFFALSE 32206
// begin omarOnMotherLode := true ;
32174: LD_ADDR_VAR 0 4
32178: PUSH
32179: LD_INT 1
32181: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
32182: LD_EXP 40
32186: PPUSH
32187: LD_STRING D19b-JMM-1
32189: PPUSH
32190: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
32194: LD_EXP 95
32198: PPUSH
32199: LD_STRING DOmarContam-Omar-1
32201: PPUSH
32202: CALL_OW 88
// end ; until IsDead ( Omar ) ;
32206: LD_EXP 95
32210: PPUSH
32211: CALL_OW 301
32215: IFFALSE 32139
// Say ( JMM , D19a-JMM-1 ) ;
32217: LD_EXP 40
32221: PPUSH
32222: LD_STRING D19a-JMM-1
32224: PPUSH
32225: CALL_OW 88
// if Heike then
32229: LD_EXP 96
32233: IFFALSE 32247
// Say ( Heike , D19a-Hke-1 ) ;
32235: LD_EXP 96
32239: PPUSH
32240: LD_STRING D19a-Hke-1
32242: PPUSH
32243: CALL_OW 88
// end ;
32247: PPOPN 4
32249: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
32250: LD_INT 22
32252: PUSH
32253: LD_INT 3
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 21
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PPUSH
32274: CALL_OW 69
32278: PUSH
32279: LD_EXP 21
32283: AND
32284: IFFALSE 32352
32286: GO 32288
32288: DISABLE
32289: LD_INT 0
32291: PPUSH
32292: PPUSH
// begin enable ;
32293: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32294: LD_ADDR_VAR 0 2
32298: PUSH
32299: LD_INT 25
32301: PPUSH
32302: LD_INT 22
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PPUSH
32312: CALL_OW 70
32316: ST_TO_ADDR
// if not tmp then
32317: LD_VAR 0 2
32321: NOT
32322: IFFALSE 32326
// exit ;
32324: GO 32352
// for i in tmp do
32326: LD_ADDR_VAR 0 1
32330: PUSH
32331: LD_VAR 0 2
32335: PUSH
32336: FOR_IN
32337: IFFALSE 32350
// RemoveUnit ( i ) ;
32339: LD_VAR 0 1
32343: PPUSH
32344: CALL_OW 64
32348: GO 32336
32350: POP
32351: POP
// end ;
32352: PPOPN 2
32354: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32355: LD_INT 22
32357: PUSH
32358: LD_INT 7
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 21
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PPUSH
32379: CALL_OW 69
32383: PUSH
32384: LD_INT 6
32386: LESS
32387: IFFALSE 32855
32389: GO 32391
32391: DISABLE
32392: LD_INT 0
32394: PPUSH
32395: PPUSH
// begin MC_Kill ( 1 ) ;
32396: LD_INT 1
32398: PPUSH
32399: CALL 37129 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32403: LD_INT 7
32405: PPUSH
32406: LD_INT 1
32408: PPUSH
32409: LD_INT 1
32411: PPUSH
32412: LD_INT 1
32414: PPUSH
32415: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32419: LD_ADDR_VAR 0 1
32423: PUSH
32424: LD_INT 22
32426: PUSH
32427: LD_INT 7
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 26
32436: PUSH
32437: LD_INT 1
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PPUSH
32448: CALL_OW 69
32452: PUSH
32453: LD_EXP 77
32457: DIFF
32458: ST_TO_ADDR
// if tmp then
32459: LD_VAR 0 1
32463: IFFALSE 32481
// tmp := tmp [ 1 ] else
32465: LD_ADDR_VAR 0 1
32469: PUSH
32470: LD_VAR 0 1
32474: PUSH
32475: LD_INT 1
32477: ARRAY
32478: ST_TO_ADDR
32479: GO 32517
// begin uc_side := 7 ;
32481: LD_ADDR_OWVAR 20
32485: PUSH
32486: LD_INT 7
32488: ST_TO_ADDR
// uc_nation := 1 ;
32489: LD_ADDR_OWVAR 21
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32497: LD_INT 1
32499: PPUSH
32500: LD_INT 8
32502: PPUSH
32503: CALL_OW 384
// tmp := CreateHuman ;
32507: LD_ADDR_VAR 0 1
32511: PUSH
32512: CALL_OW 44
32516: ST_TO_ADDR
// end ; DialogueOn ;
32517: CALL_OW 6
// if IsOK ( Roth ) then
32521: LD_EXP 77
32525: PPUSH
32526: CALL_OW 302
32530: IFFALSE 32544
// Say ( JMM , DAb-JMM-1 ) ;
32532: LD_EXP 40
32536: PPUSH
32537: LD_STRING DAb-JMM-1
32539: PPUSH
32540: CALL_OW 88
// if IsOK ( Roth ) then
32544: LD_EXP 77
32548: PPUSH
32549: CALL_OW 302
32553: IFFALSE 32577
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32555: LD_EXP 77
32559: PPUSH
32560: LD_STRING DSurrenderAlliance-Roth-1
32562: PPUSH
32563: CALL_OW 88
// RothCaptured := true ;
32567: LD_ADDR_EXP 33
32571: PUSH
32572: LD_INT 1
32574: ST_TO_ADDR
// end else
32575: GO 32589
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32577: LD_VAR 0 1
32581: PPUSH
32582: LD_STRING DSurrenderAlliance-Sci1-1
32584: PPUSH
32585: CALL_OW 88
// DialogueOff ;
32589: CALL_OW 7
// allianceDestroyed := true ;
32593: LD_ADDR_EXP 23
32597: PUSH
32598: LD_INT 1
32600: ST_TO_ADDR
// if capturedUnit = 0 then
32601: LD_EXP 34
32605: PUSH
32606: LD_INT 0
32608: EQUAL
32609: IFFALSE 32618
// SetAchievement ( ACH_ALLIANCE ) ;
32611: LD_STRING ACH_ALLIANCE
32613: PPUSH
32614: CALL_OW 543
// if trueAmericans then
32618: LD_EXP 35
32622: IFFALSE 32698
// begin if trueAmericans = 1 then
32624: LD_EXP 35
32628: PUSH
32629: LD_INT 1
32631: EQUAL
32632: IFFALSE 32648
// Say ( JMM , DAb-JMM-1a ) else
32634: LD_EXP 40
32638: PPUSH
32639: LD_STRING DAb-JMM-1a
32641: PPUSH
32642: CALL_OW 88
32646: GO 32660
// Say ( JMM , DAb-JMM-1b ) ;
32648: LD_EXP 40
32652: PPUSH
32653: LD_STRING DAb-JMM-1b
32655: PPUSH
32656: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32660: LD_EXP 35
32664: PPUSH
32665: CALL_OW 87
// for i in trueAmericans do
32669: LD_ADDR_VAR 0 2
32673: PUSH
32674: LD_EXP 35
32678: PUSH
32679: FOR_IN
32680: IFFALSE 32696
// SetSide ( i , 1 ) ;
32682: LD_VAR 0 2
32686: PPUSH
32687: LD_INT 1
32689: PPUSH
32690: CALL_OW 235
32694: GO 32679
32696: POP
32697: POP
// end ; repeat wait ( 0 0$1 ) ;
32698: LD_INT 35
32700: PPUSH
32701: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32705: LD_ADDR_VAR 0 2
32709: PUSH
32710: LD_INT 22
32712: PUSH
32713: LD_INT 7
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 21
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PPUSH
32734: CALL_OW 69
32738: PUSH
32739: FOR_IN
32740: IFFALSE 32822
// begin if IsInUnit ( i ) then
32742: LD_VAR 0 2
32746: PPUSH
32747: CALL_OW 310
32751: IFFALSE 32762
// ComExitBuilding ( i ) ;
32753: LD_VAR 0 2
32757: PPUSH
32758: CALL_OW 122
// if IsDriver ( i ) then
32762: LD_VAR 0 2
32766: PPUSH
32767: CALL 102666 0 1
32771: IFFALSE 32782
// ComExitVehicle ( i ) ;
32773: LD_VAR 0 2
32777: PPUSH
32778: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32782: LD_VAR 0 2
32786: PPUSH
32787: LD_INT 26
32789: PPUSH
32790: CALL_OW 308
32794: NOT
32795: IFFALSE 32811
// AddComMoveToArea ( i , allianceEscapeArea ) else
32797: LD_VAR 0 2
32801: PPUSH
32802: LD_INT 26
32804: PPUSH
32805: CALL_OW 173
32809: GO 32820
// RemoveUnit ( i ) ;
32811: LD_VAR 0 2
32815: PPUSH
32816: CALL_OW 64
// end ;
32820: GO 32739
32822: POP
32823: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32824: LD_INT 22
32826: PUSH
32827: LD_INT 7
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 21
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PPUSH
32848: CALL_OW 69
32852: NOT
32853: IFFALSE 32698
// end ;
32855: PPOPN 2
32857: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32858: LD_INT 0
32860: PPUSH
32861: PPUSH
// if not unit then
32862: LD_VAR 0 1
32866: NOT
32867: IFFALSE 32871
// exit ;
32869: GO 34369
// DoNotAttack ( 7 , unit ) ;
32871: LD_INT 7
32873: PPUSH
32874: LD_VAR 0 1
32878: PPUSH
32879: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: LD_INT 260
32890: PPUSH
32891: LD_INT 235
32893: PPUSH
32894: LD_INT 3
32896: PPUSH
32897: LD_INT 1
32899: PPUSH
32900: CALL_OW 483
// SetSide ( unit , 4 ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: LD_INT 4
32911: PPUSH
32912: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32916: LD_ADDR_EXP 34
32920: PUSH
32921: LD_EXP 34
32925: PUSH
32926: LD_INT 1
32928: PLUS
32929: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32930: LD_INT 70
32932: PPUSH
32933: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32937: LD_INT 260
32939: PPUSH
32940: LD_INT 235
32942: PPUSH
32943: LD_INT 1
32945: PPUSH
32946: LD_INT 8
32948: NEG
32949: PPUSH
32950: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32963: LD_VAR 0 1
32967: PPUSH
32968: LD_EXP 77
32972: PPUSH
32973: CALL_OW 119
// DialogueOn ;
32977: CALL_OW 6
// case unit of JMM :
32981: LD_VAR 0 1
32985: PUSH
32986: LD_EXP 40
32990: DOUBLE
32991: EQUAL
32992: IFTRUE 32996
32994: GO 33011
32996: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32997: LD_EXP 40
33001: PPUSH
33002: LD_STRING DA1-JMM-1
33004: PPUSH
33005: CALL_OW 91
33009: GO 33453
33011: LD_EXP 41
33015: DOUBLE
33016: EQUAL
33017: IFTRUE 33021
33019: GO 33036
33021: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33022: LD_EXP 41
33026: PPUSH
33027: LD_STRING DA1-Joan-1
33029: PPUSH
33030: CALL_OW 91
33034: GO 33453
33036: LD_EXP 43
33040: DOUBLE
33041: EQUAL
33042: IFTRUE 33046
33044: GO 33061
33046: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33047: LD_EXP 43
33051: PPUSH
33052: LD_STRING DA1-Lisa-1
33054: PPUSH
33055: CALL_OW 91
33059: GO 33453
33061: LD_EXP 44
33065: DOUBLE
33066: EQUAL
33067: IFTRUE 33071
33069: GO 33086
33071: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
33072: LD_EXP 44
33076: PPUSH
33077: LD_STRING DA1-Don-1
33079: PPUSH
33080: CALL_OW 91
33084: GO 33453
33086: LD_EXP 51
33090: DOUBLE
33091: EQUAL
33092: IFTRUE 33096
33094: GO 33111
33096: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
33097: LD_EXP 51
33101: PPUSH
33102: LD_STRING DA1-Corn-1
33104: PPUSH
33105: CALL_OW 91
33109: GO 33453
33111: LD_EXP 47
33115: DOUBLE
33116: EQUAL
33117: IFTRUE 33121
33119: GO 33136
33121: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
33122: LD_EXP 47
33126: PPUSH
33127: LD_STRING DA1-Den-1
33129: PPUSH
33130: CALL_OW 91
33134: GO 33453
33136: LD_EXP 45
33140: DOUBLE
33141: EQUAL
33142: IFTRUE 33146
33144: GO 33161
33146: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
33147: LD_EXP 45
33151: PPUSH
33152: LD_STRING DA1-Bobby-1
33154: PPUSH
33155: CALL_OW 91
33159: GO 33453
33161: LD_EXP 49
33165: DOUBLE
33166: EQUAL
33167: IFTRUE 33171
33169: GO 33186
33171: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
33172: LD_EXP 49
33176: PPUSH
33177: LD_STRING DA1-Glad-1
33179: PPUSH
33180: CALL_OW 91
33184: GO 33453
33186: LD_EXP 46
33190: DOUBLE
33191: EQUAL
33192: IFTRUE 33196
33194: GO 33211
33196: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
33197: LD_EXP 46
33201: PPUSH
33202: LD_STRING DA1-Cyrus-1
33204: PPUSH
33205: CALL_OW 91
33209: GO 33453
33211: LD_EXP 42
33215: DOUBLE
33216: EQUAL
33217: IFTRUE 33221
33219: GO 33236
33221: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
33222: LD_EXP 42
33226: PPUSH
33227: LD_STRING DA1-Huck-1
33229: PPUSH
33230: CALL_OW 91
33234: GO 33453
33236: LD_EXP 56
33240: DOUBLE
33241: EQUAL
33242: IFTRUE 33246
33244: GO 33261
33246: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
33247: LD_EXP 56
33251: PPUSH
33252: LD_STRING DA1-Huck-1
33254: PPUSH
33255: CALL_OW 91
33259: GO 33453
33261: LD_EXP 48
33265: DOUBLE
33266: EQUAL
33267: IFTRUE 33271
33269: GO 33286
33271: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33272: LD_EXP 48
33276: PPUSH
33277: LD_STRING DA1-Brown-1
33279: PPUSH
33280: CALL_OW 91
33284: GO 33453
33286: LD_EXP 52
33290: DOUBLE
33291: EQUAL
33292: IFTRUE 33296
33294: GO 33311
33296: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33297: LD_EXP 52
33301: PPUSH
33302: LD_STRING DA1-Gary-1
33304: PPUSH
33305: CALL_OW 91
33309: GO 33453
33311: LD_EXP 55
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33336
33321: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33322: LD_EXP 55
33326: PPUSH
33327: LD_STRING DA1-Con-1
33329: PPUSH
33330: CALL_OW 91
33334: GO 33453
33336: LD_EXP 62
33340: DOUBLE
33341: EQUAL
33342: IFTRUE 33346
33344: GO 33361
33346: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33347: LD_EXP 62
33351: PPUSH
33352: LD_STRING DA1-Kurt-1
33354: PPUSH
33355: CALL_OW 91
33359: GO 33453
33361: LD_EXP 54
33365: DOUBLE
33366: EQUAL
33367: IFTRUE 33371
33369: GO 33386
33371: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33372: LD_EXP 54
33376: PPUSH
33377: LD_STRING DA1-Yam-1
33379: PPUSH
33380: CALL_OW 91
33384: GO 33453
33386: LD_EXP 53
33390: DOUBLE
33391: EQUAL
33392: IFTRUE 33396
33394: GO 33411
33396: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33397: LD_EXP 53
33401: PPUSH
33402: LD_STRING DA1-Frank-1
33404: PPUSH
33405: CALL_OW 91
33409: GO 33453
33411: POP
// begin if GetSex ( unit ) = sex_male then
33412: LD_VAR 0 1
33416: PPUSH
33417: CALL_OW 258
33421: PUSH
33422: LD_INT 1
33424: EQUAL
33425: IFFALSE 33441
// ForceSay ( unit , DA1-Sol1-1 ) else
33427: LD_VAR 0 1
33431: PPUSH
33432: LD_STRING DA1-Sol1-1
33434: PPUSH
33435: CALL_OW 91
33439: GO 33453
// ForceSay ( unit , DA1-FSol1-1 ) ;
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_STRING DA1-FSol1-1
33448: PPUSH
33449: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33453: LD_EXP 77
33457: PPUSH
33458: LD_STRING DA-Roth-1
33460: PPUSH
33461: CALL_OW 88
// if capturedUnit = 1 then
33465: LD_EXP 34
33469: PUSH
33470: LD_INT 1
33472: EQUAL
33473: IFFALSE 33501
// begin Say ( Simms , DA-Sim-1 ) ;
33475: LD_EXP 78
33479: PPUSH
33480: LD_STRING DA-Sim-1
33482: PPUSH
33483: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33487: LD_EXP 77
33491: PPUSH
33492: LD_STRING DA-Roth-2
33494: PPUSH
33495: CALL_OW 88
// end else
33499: GO 33513
// Say ( Simms , DA-Sim-2 ) ;
33501: LD_EXP 78
33505: PPUSH
33506: LD_STRING DA-Sim-2
33508: PPUSH
33509: CALL_OW 88
// case unit of JMM :
33513: LD_VAR 0 1
33517: PUSH
33518: LD_EXP 40
33522: DOUBLE
33523: EQUAL
33524: IFTRUE 33528
33526: GO 33543
33528: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33529: LD_EXP 40
33533: PPUSH
33534: LD_STRING DA1-JMM-1a
33536: PPUSH
33537: CALL_OW 91
33541: GO 34050
33543: LD_EXP 41
33547: DOUBLE
33548: EQUAL
33549: IFTRUE 33553
33551: GO 33568
33553: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33554: LD_EXP 41
33558: PPUSH
33559: LD_STRING DA1-Joan-1a
33561: PPUSH
33562: CALL_OW 91
33566: GO 34050
33568: LD_EXP 43
33572: DOUBLE
33573: EQUAL
33574: IFTRUE 33578
33576: GO 33593
33578: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33579: LD_EXP 43
33583: PPUSH
33584: LD_STRING DA1-Lisa-1a
33586: PPUSH
33587: CALL_OW 91
33591: GO 34050
33593: LD_EXP 44
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33618
33603: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33604: LD_EXP 44
33608: PPUSH
33609: LD_STRING DA1-Don-1a
33611: PPUSH
33612: CALL_OW 91
33616: GO 34050
33618: LD_EXP 51
33622: DOUBLE
33623: EQUAL
33624: IFTRUE 33628
33626: GO 33643
33628: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33629: LD_EXP 51
33633: PPUSH
33634: LD_STRING DA1-Corn-1a
33636: PPUSH
33637: CALL_OW 91
33641: GO 34050
33643: LD_EXP 47
33647: DOUBLE
33648: EQUAL
33649: IFTRUE 33653
33651: GO 33668
33653: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33654: LD_EXP 47
33658: PPUSH
33659: LD_STRING DA1-Den-1a
33661: PPUSH
33662: CALL_OW 91
33666: GO 34050
33668: LD_EXP 45
33672: DOUBLE
33673: EQUAL
33674: IFTRUE 33678
33676: GO 33693
33678: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33679: LD_EXP 45
33683: PPUSH
33684: LD_STRING DA1-Bobby-1a
33686: PPUSH
33687: CALL_OW 91
33691: GO 34050
33693: LD_EXP 49
33697: DOUBLE
33698: EQUAL
33699: IFTRUE 33703
33701: GO 33718
33703: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33704: LD_EXP 49
33708: PPUSH
33709: LD_STRING DA1-Glad-1a
33711: PPUSH
33712: CALL_OW 91
33716: GO 34050
33718: LD_EXP 46
33722: DOUBLE
33723: EQUAL
33724: IFTRUE 33728
33726: GO 33743
33728: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33729: LD_EXP 46
33733: PPUSH
33734: LD_STRING DA1-Cyrus-1a
33736: PPUSH
33737: CALL_OW 91
33741: GO 34050
33743: LD_EXP 42
33747: DOUBLE
33748: EQUAL
33749: IFTRUE 33753
33751: GO 33768
33753: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33754: LD_EXP 42
33758: PPUSH
33759: LD_STRING DA1-Huck-1a
33761: PPUSH
33762: CALL_OW 91
33766: GO 34050
33768: LD_EXP 56
33772: DOUBLE
33773: EQUAL
33774: IFTRUE 33778
33776: GO 33793
33778: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33779: LD_EXP 56
33783: PPUSH
33784: LD_STRING DA1-Huck-1a
33786: PPUSH
33787: CALL_OW 91
33791: GO 34050
33793: LD_EXP 48
33797: DOUBLE
33798: EQUAL
33799: IFTRUE 33803
33801: GO 33818
33803: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33804: LD_EXP 48
33808: PPUSH
33809: LD_STRING DA1-Brown-1a
33811: PPUSH
33812: CALL_OW 91
33816: GO 34050
33818: LD_EXP 52
33822: DOUBLE
33823: EQUAL
33824: IFTRUE 33828
33826: GO 33843
33828: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33829: LD_EXP 52
33833: PPUSH
33834: LD_STRING DA1-Gary-1a
33836: PPUSH
33837: CALL_OW 91
33841: GO 34050
33843: LD_EXP 55
33847: DOUBLE
33848: EQUAL
33849: IFTRUE 33853
33851: GO 33868
33853: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33854: LD_EXP 55
33858: PPUSH
33859: LD_STRING DA1-Con-1a
33861: PPUSH
33862: CALL_OW 91
33866: GO 34050
33868: LD_EXP 62
33872: DOUBLE
33873: EQUAL
33874: IFTRUE 33878
33876: GO 33893
33878: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33879: LD_EXP 62
33883: PPUSH
33884: LD_STRING DA1-Kurt-1a
33886: PPUSH
33887: CALL_OW 91
33891: GO 34050
33893: LD_EXP 54
33897: DOUBLE
33898: EQUAL
33899: IFTRUE 33903
33901: GO 33918
33903: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33904: LD_EXP 54
33908: PPUSH
33909: LD_STRING DA1-Yam-1a
33911: PPUSH
33912: CALL_OW 91
33916: GO 34050
33918: LD_EXP 53
33922: DOUBLE
33923: EQUAL
33924: IFTRUE 33928
33926: GO 33943
33928: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33929: LD_EXP 53
33933: PPUSH
33934: LD_STRING DA1-Frank-1a
33936: PPUSH
33937: CALL_OW 91
33941: GO 34050
33943: POP
// begin join := rand ( 0 , 1 ) ;
33944: LD_ADDR_VAR 0 3
33948: PUSH
33949: LD_INT 0
33951: PPUSH
33952: LD_INT 1
33954: PPUSH
33955: CALL_OW 12
33959: ST_TO_ADDR
// if join then
33960: LD_VAR 0 3
33964: IFFALSE 34009
// begin if GetSex ( unit ) = sex_male then
33966: LD_VAR 0 1
33970: PPUSH
33971: CALL_OW 258
33975: PUSH
33976: LD_INT 1
33978: EQUAL
33979: IFFALSE 33995
// ForceSay ( unit , DA1-Sol1-1b ) else
33981: LD_VAR 0 1
33985: PPUSH
33986: LD_STRING DA1-Sol1-1b
33988: PPUSH
33989: CALL_OW 91
33993: GO 34007
// ForceSay ( unit , DA1-FSol1-1b ) ;
33995: LD_VAR 0 1
33999: PPUSH
34000: LD_STRING DA1-FSol1-1b
34002: PPUSH
34003: CALL_OW 91
// end else
34007: GO 34050
// begin if GetSex ( unit ) = sex_male then
34009: LD_VAR 0 1
34013: PPUSH
34014: CALL_OW 258
34018: PUSH
34019: LD_INT 1
34021: EQUAL
34022: IFFALSE 34038
// ForceSay ( unit , DA1-Sol1-1a ) else
34024: LD_VAR 0 1
34028: PPUSH
34029: LD_STRING DA1-Sol1-1a
34031: PPUSH
34032: CALL_OW 91
34036: GO 34050
// ForceSay ( unit , DA1-FSol1-1a ) ;
34038: LD_VAR 0 1
34042: PPUSH
34043: LD_STRING DA1-FSol1-1a
34045: PPUSH
34046: CALL_OW 91
// end ; end ; end ; if unit = JMM then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 40
34059: EQUAL
34060: IFFALSE 34071
// begin YouLost ( JMMCaptured ) ;
34062: LD_STRING JMMCaptured
34064: PPUSH
34065: CALL_OW 104
// exit ;
34069: GO 34369
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
34071: LD_VAR 0 1
34075: PUSH
34076: LD_EXP 44
34080: PUSH
34081: LD_EXP 47
34085: PUSH
34086: LD_EXP 45
34090: PUSH
34091: LD_EXP 42
34095: PUSH
34096: LD_EXP 56
34100: PUSH
34101: LD_EXP 48
34105: PUSH
34106: LD_EXP 54
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: IN
34120: PUSH
34121: LD_VAR 0 3
34125: OR
34126: IFFALSE 34225
// begin Say ( Roth , DA-Roth-3 ) ;
34128: LD_EXP 77
34132: PPUSH
34133: LD_STRING DA-Roth-3
34135: PPUSH
34136: CALL_OW 88
// SetSide ( unit , 7 ) ;
34140: LD_VAR 0 1
34144: PPUSH
34145: LD_INT 7
34147: PPUSH
34148: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
34152: LD_ADDR_EXP 100
34156: PUSH
34157: LD_EXP 100
34161: PPUSH
34162: LD_INT 1
34164: PPUSH
34165: LD_EXP 100
34169: PUSH
34170: LD_INT 1
34172: ARRAY
34173: PUSH
34174: LD_VAR 0 1
34178: ADD
34179: PPUSH
34180: CALL_OW 1
34184: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34185: LD_INT 260
34187: PPUSH
34188: LD_INT 235
34190: PPUSH
34191: LD_INT 1
34193: PPUSH
34194: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 1000
34205: PPUSH
34206: CALL_OW 234
// DialogueOff ;
34210: CALL_OW 7
// ComFree ( unit ) ;
34214: LD_VAR 0 1
34218: PPUSH
34219: CALL_OW 139
// end else
34223: GO 34306
// begin Say ( Roth , DA-Roth-3a ) ;
34225: LD_EXP 77
34229: PPUSH
34230: LD_STRING DA-Roth-3a
34232: PPUSH
34233: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
34237: LD_ADDR_EXP 35
34241: PUSH
34242: LD_EXP 35
34246: PUSH
34247: LD_VAR 0 1
34251: ADD
34252: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34253: LD_INT 260
34255: PPUSH
34256: LD_INT 235
34258: PPUSH
34259: LD_INT 1
34261: PPUSH
34262: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34266: LD_VAR 0 1
34270: PPUSH
34271: LD_INT 1000
34273: PPUSH
34274: CALL_OW 234
// DialogueOff ;
34278: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34282: LD_VAR 0 1
34286: PPUSH
34287: LD_INT 272
34289: PPUSH
34290: LD_INT 254
34292: PPUSH
34293: CALL_OW 111
// AddComHold ( unit ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 200
// end ; if capturedUnit = 1 then
34306: LD_EXP 34
34310: PUSH
34311: LD_INT 1
34313: EQUAL
34314: IFFALSE 34369
// begin DialogueOn ;
34316: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34320: LD_EXP 40
34324: PPUSH
34325: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34329: LD_EXP 40
34333: PPUSH
34334: LD_STRING DAa-JMM-1
34336: PPUSH
34337: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34341: LD_EXP 40
34345: PPUSH
34346: LD_STRING DAa-JMM-1a
34348: PPUSH
34349: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34353: LD_EXP 40
34357: PPUSH
34358: LD_STRING DAa-JMM-1b
34360: PPUSH
34361: CALL_OW 88
// DialogueOff ;
34365: CALL_OW 7
// end ; end ;
34369: LD_VAR 0 2
34373: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34374: LD_EXP 15
34378: PUSH
34379: LD_INT 13
34381: GREATEREQUAL
34382: PUSH
34383: LD_INT 22
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 21
34395: PUSH
34396: LD_INT 1
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PPUSH
34407: CALL_OW 69
34411: PUSH
34412: LD_INT 0
34414: EQUAL
34415: AND
34416: PUSH
34417: LD_INT 22
34419: PUSH
34420: LD_INT 2
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 33
34429: PUSH
34430: LD_INT 5
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 21
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 50
34449: PUSH
34450: EMPTY
34451: LIST
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: PPUSH
34459: CALL_OW 69
34463: PUSH
34464: LD_INT 0
34466: EQUAL
34467: AND
34468: PUSH
34469: LD_EXP 21
34473: AND
34474: PUSH
34475: LD_EXP 22
34479: AND
34480: PUSH
34481: LD_EXP 23
34485: AND
34486: IFFALSE 35175
34488: GO 34490
34490: DISABLE
34491: LD_INT 0
34493: PPUSH
34494: PPUSH
34495: PPUSH
// begin m1 := false ;
34496: LD_ADDR_VAR 0 1
34500: PUSH
34501: LD_INT 0
34503: ST_TO_ADDR
// m2 := false ;
34504: LD_ADDR_VAR 0 2
34508: PUSH
34509: LD_INT 0
34511: ST_TO_ADDR
// m3 := false ;
34512: LD_ADDR_VAR 0 3
34516: PUSH
34517: LD_INT 0
34519: ST_TO_ADDR
// if not bombExploded then
34520: LD_EXP 37
34524: NOT
34525: IFFALSE 34534
// SetAchievement ( ACH_SIBROCKET ) ;
34527: LD_STRING ACH_SIBROCKET
34529: PPUSH
34530: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34534: LD_EXP 64
34538: PPUSH
34539: CALL_OW 255
34543: PUSH
34544: LD_INT 1
34546: EQUAL
34547: PUSH
34548: LD_EXP 64
34552: PPUSH
34553: CALL_OW 302
34557: AND
34558: IFFALSE 34574
// begin wait ( 3 ) ;
34560: LD_INT 3
34562: PPUSH
34563: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34567: LD_STRING ACH_OPO
34569: PPUSH
34570: CALL_OW 543
// end ; if tick <= 120 120$00 then
34574: LD_OWVAR 1
34578: PUSH
34579: LD_INT 252000
34581: LESSEQUAL
34582: IFFALSE 34598
// begin wait ( 3 ) ;
34584: LD_INT 3
34586: PPUSH
34587: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34591: LD_STRING ACH_ASPEED_15
34593: PPUSH
34594: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34598: LD_EXP 40
34602: PPUSH
34603: CALL_OW 87
// music_class := 5 ;
34607: LD_ADDR_OWVAR 72
34611: PUSH
34612: LD_INT 5
34614: ST_TO_ADDR
// music_nat := 5 ;
34615: LD_ADDR_OWVAR 71
34619: PUSH
34620: LD_INT 5
34622: ST_TO_ADDR
// DialogueOn ;
34623: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34627: LD_EXP 40
34631: PPUSH
34632: LD_STRING D20-JMM-1
34634: PPUSH
34635: CALL_OW 88
// if IsOK ( Joan ) then
34639: LD_EXP 41
34643: PPUSH
34644: CALL_OW 302
34648: IFFALSE 34662
// Say ( Joan , D20-Joan-1 ) ;
34650: LD_EXP 41
34654: PPUSH
34655: LD_STRING D20-Joan-1
34657: PPUSH
34658: CALL_OW 88
// if IsOk ( Lisa ) then
34662: LD_EXP 43
34666: PPUSH
34667: CALL_OW 302
34671: IFFALSE 34685
// Say ( Lisa , D20-Lisa-1 ) ;
34673: LD_EXP 43
34677: PPUSH
34678: LD_STRING D20-Lisa-1
34680: PPUSH
34681: CALL_OW 88
// if IsOk ( Donaldson ) then
34685: LD_EXP 44
34689: PPUSH
34690: CALL_OW 302
34694: IFFALSE 34708
// Say ( Donaldson , D20-Don-1 ) ;
34696: LD_EXP 44
34700: PPUSH
34701: LD_STRING D20-Don-1
34703: PPUSH
34704: CALL_OW 88
// if IsOK ( Cornel ) then
34708: LD_EXP 51
34712: PPUSH
34713: CALL_OW 302
34717: IFFALSE 34731
// Say ( Cornel , D20-Corn-1 ) ;
34719: LD_EXP 51
34723: PPUSH
34724: LD_STRING D20-Corn-1
34726: PPUSH
34727: CALL_OW 88
// if IsOk ( Denis ) then
34731: LD_EXP 47
34735: PPUSH
34736: CALL_OW 302
34740: IFFALSE 34754
// Say ( Denis , D20-Den-1 ) ;
34742: LD_EXP 47
34746: PPUSH
34747: LD_STRING D20-Den-1
34749: PPUSH
34750: CALL_OW 88
// if IsOk ( Bobby ) then
34754: LD_EXP 45
34758: PPUSH
34759: CALL_OW 302
34763: IFFALSE 34777
// Say ( Bobby , D20-Bobby-1 ) ;
34765: LD_EXP 45
34769: PPUSH
34770: LD_STRING D20-Bobby-1
34772: PPUSH
34773: CALL_OW 88
// if IsOk ( Gladstone ) then
34777: LD_EXP 49
34781: PPUSH
34782: CALL_OW 302
34786: IFFALSE 34800
// Say ( Gladstone , D20-Glad-1 ) ;
34788: LD_EXP 49
34792: PPUSH
34793: LD_STRING D20-Glad-1
34795: PPUSH
34796: CALL_OW 88
// if IsOk ( Cyrus ) then
34800: LD_EXP 46
34804: PPUSH
34805: CALL_OW 302
34809: IFFALSE 34823
// Say ( Cyrus , D20-Cyrus-1 ) ;
34811: LD_EXP 46
34815: PPUSH
34816: LD_STRING D20-Cyrus-1
34818: PPUSH
34819: CALL_OW 88
// if IsOk ( Stevens ) then
34823: LD_EXP 42
34827: PPUSH
34828: CALL_OW 302
34832: IFFALSE 34846
// Say ( Stevens , D20-Huck-1 ) ;
34834: LD_EXP 42
34838: PPUSH
34839: LD_STRING D20-Huck-1
34841: PPUSH
34842: CALL_OW 88
// if IsOk ( Brown ) then
34846: LD_EXP 48
34850: PPUSH
34851: CALL_OW 302
34855: IFFALSE 34869
// Say ( Brown , D20-Brown-1 ) ;
34857: LD_EXP 48
34861: PPUSH
34862: LD_STRING D20-Brown-1
34864: PPUSH
34865: CALL_OW 88
// if IsOk ( Gary ) then
34869: LD_EXP 52
34873: PPUSH
34874: CALL_OW 302
34878: IFFALSE 34892
// Say ( Gary , D20-Gary-1 ) ;
34880: LD_EXP 52
34884: PPUSH
34885: LD_STRING D20-Gary-1
34887: PPUSH
34888: CALL_OW 88
// if IsOk ( Connie ) then
34892: LD_EXP 55
34896: PPUSH
34897: CALL_OW 302
34901: IFFALSE 34915
// Say ( Connie , D20-Con-1 ) ;
34903: LD_EXP 55
34907: PPUSH
34908: LD_STRING D20-Con-1
34910: PPUSH
34911: CALL_OW 88
// if IsOk ( Kurt ) then
34915: LD_EXP 62
34919: PPUSH
34920: CALL_OW 302
34924: IFFALSE 34938
// Say ( Kurt , D20-Kurt-1 ) ;
34926: LD_EXP 62
34930: PPUSH
34931: LD_STRING D20-Kurt-1
34933: PPUSH
34934: CALL_OW 88
// if IsOk ( Kikuchi ) then
34938: LD_EXP 54
34942: PPUSH
34943: CALL_OW 302
34947: IFFALSE 34961
// Say ( Kikuchi , D20-Yam-1 ) ;
34949: LD_EXP 54
34953: PPUSH
34954: LD_STRING D20-Yam-1
34956: PPUSH
34957: CALL_OW 88
// if IsOk ( Frank ) then
34961: LD_EXP 53
34965: PPUSH
34966: CALL_OW 302
34970: IFFALSE 34984
// Say ( Frank , D20-Frank-1 ) ;
34972: LD_EXP 53
34976: PPUSH
34977: LD_STRING D20-Frank-1
34979: PPUSH
34980: CALL_OW 88
// DialogueOff ;
34984: CALL_OW 7
// if RothCaptured then
34988: LD_EXP 33
34992: IFFALSE 35014
// begin m1 := true ;
34994: LD_ADDR_VAR 0 1
34998: PUSH
34999: LD_INT 1
35001: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35002: LD_STRING Roth
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: CALL_OW 101
// end else
35012: GO 35025
// AddMedal ( Roth , - 1 ) ;
35014: LD_STRING Roth
35016: PPUSH
35017: LD_INT 1
35019: NEG
35020: PPUSH
35021: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
35025: LD_EXP 25
35029: NOT
35030: PUSH
35031: LD_EXP 27
35035: OR
35036: IFFALSE 35058
// begin m2 := true ;
35038: LD_ADDR_VAR 0 2
35042: PUSH
35043: LD_INT 1
35045: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
35046: LD_STRING Project
35048: PPUSH
35049: LD_INT 1
35051: PPUSH
35052: CALL_OW 101
// end else
35056: GO 35069
// AddMedal ( Project , - 1 ) ;
35058: LD_STRING Project
35060: PPUSH
35061: LD_INT 1
35063: NEG
35064: PPUSH
35065: CALL_OW 101
// if lostCounter = 0 then
35069: LD_EXP 32
35073: PUSH
35074: LD_INT 0
35076: EQUAL
35077: IFFALSE 35099
// begin m3 := true ;
35079: LD_ADDR_VAR 0 3
35083: PUSH
35084: LD_INT 1
35086: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
35087: LD_STRING NoLosses
35089: PPUSH
35090: LD_INT 1
35092: PPUSH
35093: CALL_OW 101
// end else
35097: GO 35110
// AddMedal ( NoLosses , - 1 ) ;
35099: LD_STRING NoLosses
35101: PPUSH
35102: LD_INT 1
35104: NEG
35105: PPUSH
35106: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
35110: LD_VAR 0 1
35114: PUSH
35115: LD_VAR 0 2
35119: AND
35120: PUSH
35121: LD_VAR 0 3
35125: AND
35126: PUSH
35127: LD_OWVAR 67
35131: PUSH
35132: LD_INT 3
35134: GREATEREQUAL
35135: AND
35136: IFFALSE 35148
// SetAchievementEX ( ACH_AMER , 15 ) ;
35138: LD_STRING ACH_AMER
35140: PPUSH
35141: LD_INT 15
35143: PPUSH
35144: CALL_OW 564
// GiveMedals ( MAIN ) ;
35148: LD_STRING MAIN
35150: PPUSH
35151: CALL_OW 102
// music_class := 4 ;
35155: LD_ADDR_OWVAR 72
35159: PUSH
35160: LD_INT 4
35162: ST_TO_ADDR
// music_nat := 1 ;
35163: LD_ADDR_OWVAR 71
35167: PUSH
35168: LD_INT 1
35170: ST_TO_ADDR
// YouWin ;
35171: CALL_OW 103
// end ; end_of_file
35175: PPOPN 3
35177: END
// export function CustomEvent ( event ) ; begin
35178: LD_INT 0
35180: PPUSH
// end ;
35181: LD_VAR 0 2
35185: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
35186: LD_VAR 0 1
35190: PUSH
35191: LD_INT 1
35193: EQUAL
35194: PUSH
35195: LD_VAR 0 2
35199: PUSH
35200: LD_INT 4
35202: EQUAL
35203: AND
35204: PUSH
35205: LD_EXP 60
35209: PPUSH
35210: CALL_OW 300
35214: AND
35215: IFFALSE 35231
// begin wait ( 0 0$2 ) ;
35217: LD_INT 70
35219: PPUSH
35220: CALL_OW 67
// YouLost ( Dismissed ) ;
35224: LD_STRING Dismissed
35226: PPUSH
35227: CALL_OW 104
// end ; end ;
35231: PPOPN 2
35233: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
35234: LD_VAR 0 2
35238: PPUSH
35239: LD_VAR 0 3
35243: PPUSH
35244: LD_INT 18
35246: PPUSH
35247: CALL_OW 309
35251: IFFALSE 35260
// YouLost ( Motherlode3 ) ;
35253: LD_STRING Motherlode3
35255: PPUSH
35256: CALL_OW 104
// end ;
35260: PPOPN 3
35262: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35263: LD_EXP 27
35267: NOT
35268: IFFALSE 35278
// behemothDone := true ;
35270: LD_ADDR_EXP 28
35274: PUSH
35275: LD_INT 1
35277: ST_TO_ADDR
// end ;
35278: PPOPN 1
35280: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35281: LD_VAR 0 1
35285: PPUSH
35286: CALL_OW 255
35290: PUSH
35291: LD_INT 1
35293: EQUAL
35294: IFFALSE 35304
// bombExploded := true ;
35296: LD_ADDR_EXP 37
35300: PUSH
35301: LD_INT 1
35303: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
35304: LD_VAR 0 1
35308: PPUSH
35309: CALL_OW 255
35313: PUSH
35314: LD_INT 3
35316: EQUAL
35317: IFFALSE 35347
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
35319: LD_INT 2
35321: PPUSH
35322: LD_INT 23
35324: PUSH
35325: LD_INT 3
35327: PUSH
35328: LD_INT 3
35330: PUSH
35331: LD_INT 48
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: PUSH
35340: EMPTY
35341: LIST
35342: PPUSH
35343: CALL 61156 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35347: LD_VAR 0 1
35351: PPUSH
35352: CALL_OW 255
35356: PUSH
35357: LD_INT 1
35359: EQUAL
35360: PUSH
35361: LD_EXP 64
35365: PPUSH
35366: CALL_OW 255
35370: PUSH
35371: LD_INT 1
35373: EQUAL
35374: AND
35375: PUSH
35376: LD_EXP 64
35380: PPUSH
35381: CALL_OW 302
35385: AND
35386: PUSH
35387: LD_EXP 30
35391: AND
35392: PUSH
35393: LD_INT 22
35395: PUSH
35396: LD_INT 3
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 34
35405: PUSH
35406: LD_INT 48
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PPUSH
35417: CALL_OW 69
35421: AND
35422: PUSH
35423: LD_INT 22
35425: PUSH
35426: LD_INT 1
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 34
35435: PUSH
35436: LD_INT 8
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PPUSH
35447: CALL_OW 69
35451: NOT
35452: AND
35453: IFFALSE 35505
// begin wait ( 0 0$5 ) ;
35455: LD_INT 175
35457: PPUSH
35458: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35462: LD_INT 22
35464: PUSH
35465: LD_INT 3
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 34
35474: PUSH
35475: LD_INT 48
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PPUSH
35486: CALL_OW 69
35490: PUSH
35491: LD_INT 1
35493: ARRAY
35494: PPUSH
35495: LD_INT 60
35497: PPUSH
35498: LD_INT 95
35500: PPUSH
35501: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
35505: LD_VAR 0 2
35509: PPUSH
35510: LD_VAR 0 3
35514: PPUSH
35515: LD_INT 18
35517: PPUSH
35518: CALL_OW 309
35522: PUSH
35523: LD_VAR 0 2
35527: PPUSH
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_INT 18
35535: PPUSH
35536: CALL 108859 0 3
35540: OR
35541: IFFALSE 35588
// begin if GetSide ( unit ) = 1 then
35543: LD_VAR 0 1
35547: PPUSH
35548: CALL_OW 255
35552: PUSH
35553: LD_INT 1
35555: EQUAL
35556: IFFALSE 35574
// begin wait ( 0 0$6 ) ;
35558: LD_INT 210
35560: PPUSH
35561: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35565: LD_STRING Motherlode2
35567: PPUSH
35568: CALL_OW 104
// end else
35572: GO 35588
// begin wait ( 0 0$6 ) ;
35574: LD_INT 210
35576: PPUSH
35577: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35581: LD_STRING Motherlode1
35583: PPUSH
35584: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35588: LD_VAR 0 1
35592: PPUSH
35593: CALL_OW 255
35597: PUSH
35598: LD_INT 3
35600: EQUAL
35601: IFFALSE 35622
// begin wait ( 0 0$5 ) ;
35603: LD_INT 175
35605: PPUSH
35606: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35610: LD_EXP 66
35614: PPUSH
35615: LD_STRING D18-Pla-1
35617: PPUSH
35618: CALL_OW 94
// end ; end ;
35622: PPOPN 3
35624: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35625: LD_VAR 0 1
35629: PPUSH
35630: CALL 124797 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35634: LD_VAR 0 1
35638: PUSH
35639: LD_INT 22
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 21
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 23
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: LIST
35673: PPUSH
35674: CALL_OW 69
35678: IN
35679: IFFALSE 35695
// lostCounter := lostCounter + 1 ;
35681: LD_ADDR_EXP 32
35685: PUSH
35686: LD_EXP 32
35690: PUSH
35691: LD_INT 1
35693: PLUS
35694: ST_TO_ADDR
// if un in behemothBuilders then
35695: LD_VAR 0 1
35699: PUSH
35700: LD_EXP 75
35704: IN
35705: IFFALSE 35725
// begin behemothBuilders := behemothBuilders diff un ;
35707: LD_ADDR_EXP 75
35711: PUSH
35712: LD_EXP 75
35716: PUSH
35717: LD_VAR 0 1
35721: DIFF
35722: ST_TO_ADDR
// exit ;
35723: GO 35755
// end ; if un = JMM then
35725: LD_VAR 0 1
35729: PUSH
35730: LD_EXP 40
35734: EQUAL
35735: IFFALSE 35746
// begin YouLost ( JMM ) ;
35737: LD_STRING JMM
35739: PPUSH
35740: CALL_OW 104
// exit ;
35744: GO 35755
// end ; MCE_UnitDestroyed ( un ) ;
35746: LD_VAR 0 1
35750: PPUSH
35751: CALL 64598 0 1
// end ;
35755: PPOPN 1
35757: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35758: LD_VAR 0 1
35762: PPUSH
35763: LD_VAR 0 2
35767: PPUSH
35768: CALL 66930 0 2
// end ;
35772: PPOPN 2
35774: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35775: LD_VAR 0 1
35779: PPUSH
35780: CALL 65998 0 1
// end ;
35784: PPOPN 1
35786: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35787: LD_VAR 0 1
35791: PUSH
35792: LD_INT 22
35794: PUSH
35795: LD_INT 8
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 30
35804: PUSH
35805: LD_INT 2
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 23
35814: PUSH
35815: LD_INT 3
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: LIST
35826: PPUSH
35827: CALL_OW 69
35831: IN
35832: IFFALSE 35859
// begin ComUpgrade ( building ) ;
35834: LD_VAR 0 1
35838: PPUSH
35839: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35843: LD_EXP 63
35847: PPUSH
35848: LD_VAR 0 1
35852: PPUSH
35853: CALL 75580 0 2
// exit ;
35857: GO 35868
// end ; MCE_BuildingComplete ( building ) ;
35859: LD_VAR 0 1
35863: PPUSH
35864: CALL 66239 0 1
// end ;
35868: PPOPN 1
35870: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35871: LD_VAR 0 1
35875: PPUSH
35876: LD_VAR 0 2
35880: PPUSH
35881: CALL 64294 0 2
// end ;
35885: PPOPN 2
35887: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35888: LD_VAR 0 1
35892: PPUSH
35893: LD_VAR 0 2
35897: PPUSH
35898: LD_VAR 0 3
35902: PPUSH
35903: LD_VAR 0 4
35907: PPUSH
35908: LD_VAR 0 5
35912: PPUSH
35913: CALL 63914 0 5
// end ;
35917: PPOPN 5
35919: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35920: LD_VAR 0 1
35924: PPUSH
35925: CALL_OW 255
35929: PUSH
35930: LD_INT 1
35932: EQUAL
35933: IFFALSE 35950
// amConstructCounter := Inc ( amConstructCounter ) ;
35935: LD_ADDR_EXP 39
35939: PUSH
35940: LD_EXP 39
35944: PPUSH
35945: CALL 106411 0 1
35949: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35950: LD_VAR 0 1
35954: PPUSH
35955: LD_VAR 0 2
35959: PPUSH
35960: CALL 124917 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35964: LD_VAR 0 1
35968: PPUSH
35969: LD_VAR 0 2
35973: PPUSH
35974: CALL 63467 0 2
// end ;
35978: PPOPN 2
35980: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35981: LD_VAR 0 1
35985: PPUSH
35986: LD_VAR 0 2
35990: PPUSH
35991: LD_VAR 0 3
35995: PPUSH
35996: LD_VAR 0 4
36000: PPUSH
36001: CALL 63305 0 4
// end ;
36005: PPOPN 4
36007: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
36008: LD_VAR 0 1
36012: PPUSH
36013: LD_VAR 0 2
36017: PPUSH
36018: LD_VAR 0 3
36022: PPUSH
36023: CALL 63080 0 3
// end ;
36027: PPOPN 3
36029: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36030: LD_VAR 0 1
36034: PPUSH
36035: LD_VAR 0 2
36039: PPUSH
36040: CALL 62965 0 2
// end ;
36044: PPOPN 2
36046: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
36047: LD_VAR 0 1
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: CALL 67225 0 2
// end ;
36061: PPOPN 2
36063: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
36064: LD_VAR 0 1
36068: PPUSH
36069: CALL_OW 255
36073: PUSH
36074: LD_INT 4
36076: EQUAL
36077: PUSH
36078: LD_VAR 0 1
36082: PUSH
36083: LD_EXP 18
36087: PUSH
36088: LD_INT 1
36090: ARRAY
36091: IN
36092: AND
36093: PUSH
36094: LD_EXP 19
36098: AND
36099: IFFALSE 36118
// begin ComMoveXY ( driver , 61 , 93 ) ;
36101: LD_VAR 0 1
36105: PPUSH
36106: LD_INT 61
36108: PPUSH
36109: LD_INT 93
36111: PPUSH
36112: CALL_OW 111
// exit ;
36116: GO 36142
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
36118: LD_VAR 0 1
36122: PPUSH
36123: LD_VAR 0 2
36127: PPUSH
36128: LD_VAR 0 3
36132: PPUSH
36133: LD_VAR 0 4
36137: PPUSH
36138: CALL 67441 0 4
// end ;
36142: PPOPN 4
36144: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
36145: LD_VAR 0 1
36149: PPUSH
36150: LD_VAR 0 2
36154: PPUSH
36155: CALL 62774 0 2
// end ;
36159: PPOPN 2
36161: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
36162: LD_VAR 0 1
36166: PPUSH
36167: CALL 124901 0 1
// end ; end_of_file
36171: PPOPN 1
36173: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
36174: LD_EXP 15
36178: PUSH
36179: LD_INT 2
36181: EQUAL
36182: IFFALSE 36685
36184: GO 36186
36186: DISABLE
36187: LD_INT 0
36189: PPUSH
36190: PPUSH
// begin time := 0 0$35 ;
36191: LD_ADDR_VAR 0 2
36195: PUSH
36196: LD_INT 1225
36198: ST_TO_ADDR
// repeat wait ( time ) ;
36199: LD_VAR 0 2
36203: PPUSH
36204: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
36208: LD_INT 1
36210: PPUSH
36211: LD_INT 5
36213: PPUSH
36214: CALL_OW 12
36218: PPUSH
36219: LD_INT 106
36221: PPUSH
36222: LD_INT 150
36224: PPUSH
36225: LD_INT 19
36227: PPUSH
36228: LD_INT 1
36230: PPUSH
36231: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
36235: LD_INT 455
36237: PPUSH
36238: LD_INT 770
36240: PPUSH
36241: CALL_OW 12
36245: PPUSH
36246: CALL_OW 67
// if Prob ( 50 ) then
36250: LD_INT 50
36252: PPUSH
36253: CALL_OW 13
36257: IFFALSE 36286
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
36259: LD_INT 1
36261: PPUSH
36262: LD_INT 5
36264: PPUSH
36265: CALL_OW 12
36269: PPUSH
36270: LD_INT 62
36272: PPUSH
36273: LD_INT 108
36275: PPUSH
36276: LD_INT 10
36278: PPUSH
36279: LD_INT 1
36281: PPUSH
36282: CALL_OW 56
// until missionStage > 4 ;
36286: LD_EXP 15
36290: PUSH
36291: LD_INT 4
36293: GREATER
36294: IFFALSE 36199
// repeat wait ( 0 0$1 ) ;
36296: LD_INT 35
36298: PPUSH
36299: CALL_OW 67
// until missionStage = 6 ;
36303: LD_EXP 15
36307: PUSH
36308: LD_INT 6
36310: EQUAL
36311: IFFALSE 36296
// time := 0 0$20 ;
36313: LD_ADDR_VAR 0 2
36317: PUSH
36318: LD_INT 700
36320: ST_TO_ADDR
// repeat wait ( time ) ;
36321: LD_VAR 0 2
36325: PPUSH
36326: CALL_OW 67
// if Prob ( 90 ) then
36330: LD_INT 90
36332: PPUSH
36333: CALL_OW 13
36337: IFFALSE 36380
// begin time := time + 0 0$2 ;
36339: LD_ADDR_VAR 0 2
36343: PUSH
36344: LD_VAR 0 2
36348: PUSH
36349: LD_INT 70
36351: PLUS
36352: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36353: LD_INT 1
36355: PPUSH
36356: LD_INT 5
36358: PPUSH
36359: CALL_OW 12
36363: PPUSH
36364: LD_INT 106
36366: PPUSH
36367: LD_INT 89
36369: PPUSH
36370: LD_INT 45
36372: PPUSH
36373: LD_INT 1
36375: PPUSH
36376: CALL_OW 56
// end ; if Prob ( 45 ) then
36380: LD_INT 45
36382: PPUSH
36383: CALL_OW 13
36387: IFFALSE 36443
// begin for i := 1 to 4 do
36389: LD_ADDR_VAR 0 1
36393: PUSH
36394: DOUBLE
36395: LD_INT 1
36397: DEC
36398: ST_TO_ADDR
36399: LD_INT 4
36401: PUSH
36402: FOR_TO
36403: IFFALSE 36441
// begin wait ( 0 0$5 ) ;
36405: LD_INT 175
36407: PPUSH
36408: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36412: LD_INT 1
36414: PPUSH
36415: LD_INT 5
36417: PPUSH
36418: CALL_OW 12
36422: PPUSH
36423: LD_INT 113
36425: PPUSH
36426: LD_INT 117
36428: PPUSH
36429: LD_INT 25
36431: PPUSH
36432: LD_INT 1
36434: PPUSH
36435: CALL_OW 56
// end ;
36439: GO 36402
36441: POP
36442: POP
// end ; if Prob ( 40 ) then
36443: LD_INT 40
36445: PPUSH
36446: CALL_OW 13
36450: IFFALSE 36496
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36452: LD_INT 385
36454: PPUSH
36455: LD_INT 945
36457: PPUSH
36458: CALL_OW 12
36462: PPUSH
36463: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36467: LD_INT 1
36469: PPUSH
36470: LD_INT 5
36472: PPUSH
36473: CALL_OW 12
36477: PPUSH
36478: LD_INT 21
36480: PPUSH
36481: LD_INT 26
36483: PPUSH
36484: LD_INT 12
36486: PPUSH
36487: LD_INT 1
36489: PPUSH
36490: CALL_OW 56
// end else
36494: GO 36532
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36496: LD_INT 700
36498: PPUSH
36499: LD_INT 1225
36501: PPUSH
36502: CALL_OW 12
36506: PPUSH
36507: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36511: LD_INT 1
36513: PPUSH
36514: LD_INT 5
36516: PPUSH
36517: CALL_OW 12
36521: PPUSH
36522: LD_INT 16
36524: PPUSH
36525: LD_INT 1
36527: PPUSH
36528: CALL_OW 55
// end ; if Prob ( 50 ) then
36532: LD_INT 50
36534: PPUSH
36535: CALL_OW 13
36539: IFFALSE 36585
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36541: LD_INT 700
36543: PPUSH
36544: LD_INT 1050
36546: PPUSH
36547: CALL_OW 12
36551: PPUSH
36552: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36556: LD_INT 1
36558: PPUSH
36559: LD_INT 5
36561: PPUSH
36562: CALL_OW 12
36566: PPUSH
36567: LD_INT 168
36569: PPUSH
36570: LD_INT 168
36572: PPUSH
36573: LD_INT 16
36575: PPUSH
36576: LD_INT 1
36578: PPUSH
36579: CALL_OW 56
// end else
36583: GO 36621
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36585: LD_INT 350
36587: PPUSH
36588: LD_INT 525
36590: PPUSH
36591: CALL_OW 12
36595: PPUSH
36596: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36600: LD_INT 1
36602: PPUSH
36603: LD_INT 5
36605: PPUSH
36606: CALL_OW 12
36610: PPUSH
36611: LD_INT 15
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36621: LD_INT 175
36623: PPUSH
36624: LD_INT 315
36626: PPUSH
36627: CALL_OW 12
36631: PPUSH
36632: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36636: LD_INT 1
36638: PPUSH
36639: LD_INT 5
36641: PPUSH
36642: CALL_OW 12
36646: PPUSH
36647: LD_INT 103
36649: PPUSH
36650: LD_INT 140
36652: PPUSH
36653: LD_INT 20
36655: PPUSH
36656: LD_INT 1
36658: PPUSH
36659: CALL_OW 56
// if time > 1 1$10 then
36663: LD_VAR 0 2
36667: PUSH
36668: LD_INT 2450
36670: GREATER
36671: IFFALSE 36681
// time := 0 0$30 ;
36673: LD_ADDR_VAR 0 2
36677: PUSH
36678: LD_INT 1050
36680: ST_TO_ADDR
// until false ;
36681: LD_INT 0
36683: IFFALSE 36321
// end ; end_of_file
36685: PPOPN 2
36687: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36688: LD_EXP 13
36692: PUSH
36693: LD_EXP 15
36697: PUSH
36698: LD_INT 6
36700: GREATEREQUAL
36701: AND
36702: IFFALSE 36739
36704: GO 36706
36706: DISABLE
// begin enable ;
36707: ENABLE
// missionTime := missionTime + 0 0$1 ;
36708: LD_ADDR_EXP 14
36712: PUSH
36713: LD_EXP 14
36717: PUSH
36718: LD_INT 35
36720: PLUS
36721: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36722: LD_ADDR_OWVAR 47
36726: PUSH
36727: LD_STRING #Am15-1
36729: PUSH
36730: LD_EXP 14
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: ST_TO_ADDR
// end ; end_of_file
36739: END
// export function InitNature ; begin
36740: LD_INT 0
36742: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36743: LD_INT 3
36745: PPUSH
36746: LD_INT 3
36748: PPUSH
36749: LD_INT 2
36751: PPUSH
36752: LD_INT 1
36754: PPUSH
36755: LD_INT 1
36757: PPUSH
36758: LD_INT 0
36760: PPUSH
36761: LD_INT 0
36763: PPUSH
36764: LD_INT 20
36766: PPUSH
36767: LD_INT 0
36769: PPUSH
36770: CALL 101739 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36774: LD_INT 2
36776: PPUSH
36777: LD_INT 1
36779: PPUSH
36780: LD_INT 1
36782: PPUSH
36783: LD_INT 1
36785: PPUSH
36786: LD_INT 1
36788: PPUSH
36789: LD_INT 0
36791: PPUSH
36792: LD_INT 0
36794: PPUSH
36795: LD_INT 21
36797: PPUSH
36798: LD_INT 0
36800: PPUSH
36801: CALL 101739 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36805: LD_INT 4
36807: PPUSH
36808: LD_INT 1
36810: PPUSH
36811: LD_INT 2
36813: PPUSH
36814: LD_INT 4
36816: PPUSH
36817: LD_INT 2
36819: PPUSH
36820: LD_INT 1
36822: PPUSH
36823: LD_INT 0
36825: PPUSH
36826: LD_INT 22
36828: PPUSH
36829: LD_INT 0
36831: PPUSH
36832: CALL 101739 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36836: LD_INT 0
36838: PPUSH
36839: LD_INT 0
36841: PPUSH
36842: LD_INT 0
36844: PPUSH
36845: LD_INT 0
36847: PPUSH
36848: LD_INT 0
36850: PPUSH
36851: LD_INT 0
36853: PPUSH
36854: LD_INT 9
36856: PPUSH
36857: LD_INT 0
36859: PPUSH
36860: LD_INT 23
36862: PPUSH
36863: CALL 101739 0 9
// end ; end_of_file
36867: LD_VAR 0 1
36871: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
36872: LD_INT 0
36874: PPUSH
36875: PPUSH
// skirmish := false ;
36876: LD_ADDR_EXP 98
36880: PUSH
36881: LD_INT 0
36883: ST_TO_ADDR
// debug_mc := false ;
36884: LD_ADDR_EXP 99
36888: PUSH
36889: LD_INT 0
36891: ST_TO_ADDR
// mc_bases := [ ] ;
36892: LD_ADDR_EXP 100
36896: PUSH
36897: EMPTY
36898: ST_TO_ADDR
// mc_sides := [ ] ;
36899: LD_ADDR_EXP 126
36903: PUSH
36904: EMPTY
36905: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36906: LD_ADDR_EXP 101
36910: PUSH
36911: EMPTY
36912: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36913: LD_ADDR_EXP 102
36917: PUSH
36918: EMPTY
36919: ST_TO_ADDR
// mc_need_heal := [ ] ;
36920: LD_ADDR_EXP 103
36924: PUSH
36925: EMPTY
36926: ST_TO_ADDR
// mc_healers := [ ] ;
36927: LD_ADDR_EXP 104
36931: PUSH
36932: EMPTY
36933: ST_TO_ADDR
// mc_build_list := [ ] ;
36934: LD_ADDR_EXP 105
36938: PUSH
36939: EMPTY
36940: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36941: LD_ADDR_EXP 132
36945: PUSH
36946: EMPTY
36947: ST_TO_ADDR
// mc_builders := [ ] ;
36948: LD_ADDR_EXP 106
36952: PUSH
36953: EMPTY
36954: ST_TO_ADDR
// mc_construct_list := [ ] ;
36955: LD_ADDR_EXP 107
36959: PUSH
36960: EMPTY
36961: ST_TO_ADDR
// mc_turret_list := [ ] ;
36962: LD_ADDR_EXP 108
36966: PUSH
36967: EMPTY
36968: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36969: LD_ADDR_EXP 109
36973: PUSH
36974: EMPTY
36975: ST_TO_ADDR
// mc_miners := [ ] ;
36976: LD_ADDR_EXP 114
36980: PUSH
36981: EMPTY
36982: ST_TO_ADDR
// mc_mines := [ ] ;
36983: LD_ADDR_EXP 113
36987: PUSH
36988: EMPTY
36989: ST_TO_ADDR
// mc_minefields := [ ] ;
36990: LD_ADDR_EXP 115
36994: PUSH
36995: EMPTY
36996: ST_TO_ADDR
// mc_crates := [ ] ;
36997: LD_ADDR_EXP 116
37001: PUSH
37002: EMPTY
37003: ST_TO_ADDR
// mc_crates_collector := [ ] ;
37004: LD_ADDR_EXP 117
37008: PUSH
37009: EMPTY
37010: ST_TO_ADDR
// mc_crates_area := [ ] ;
37011: LD_ADDR_EXP 118
37015: PUSH
37016: EMPTY
37017: ST_TO_ADDR
// mc_vehicles := [ ] ;
37018: LD_ADDR_EXP 119
37022: PUSH
37023: EMPTY
37024: ST_TO_ADDR
// mc_attack := [ ] ;
37025: LD_ADDR_EXP 120
37029: PUSH
37030: EMPTY
37031: ST_TO_ADDR
// mc_produce := [ ] ;
37032: LD_ADDR_EXP 121
37036: PUSH
37037: EMPTY
37038: ST_TO_ADDR
// mc_defender := [ ] ;
37039: LD_ADDR_EXP 122
37043: PUSH
37044: EMPTY
37045: ST_TO_ADDR
// mc_parking := [ ] ;
37046: LD_ADDR_EXP 124
37050: PUSH
37051: EMPTY
37052: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
37053: LD_ADDR_EXP 110
37057: PUSH
37058: EMPTY
37059: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
37060: LD_ADDR_EXP 112
37064: PUSH
37065: EMPTY
37066: ST_TO_ADDR
// mc_scan := [ ] ;
37067: LD_ADDR_EXP 123
37071: PUSH
37072: EMPTY
37073: ST_TO_ADDR
// mc_scan_area := [ ] ;
37074: LD_ADDR_EXP 125
37078: PUSH
37079: EMPTY
37080: ST_TO_ADDR
// mc_tech := [ ] ;
37081: LD_ADDR_EXP 127
37085: PUSH
37086: EMPTY
37087: ST_TO_ADDR
// mc_class := [ ] ;
37088: LD_ADDR_EXP 141
37092: PUSH
37093: EMPTY
37094: ST_TO_ADDR
// mc_class_case_use := [ ] ;
37095: LD_ADDR_EXP 142
37099: PUSH
37100: EMPTY
37101: ST_TO_ADDR
// mc_is_defending := [ ] ;
37102: LD_ADDR_EXP 143
37106: PUSH
37107: EMPTY
37108: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
37109: LD_ADDR_EXP 134
37113: PUSH
37114: EMPTY
37115: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
37116: LD_ADDR_EXP 144
37120: PUSH
37121: LD_INT 0
37123: ST_TO_ADDR
// end ;
37124: LD_VAR 0 1
37128: RET
// export function MC_Kill ( base ) ; begin
37129: LD_INT 0
37131: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
37132: LD_ADDR_EXP 100
37136: PUSH
37137: LD_EXP 100
37141: PPUSH
37142: LD_VAR 0 1
37146: PPUSH
37147: EMPTY
37148: PPUSH
37149: CALL_OW 1
37153: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37154: LD_ADDR_EXP 101
37158: PUSH
37159: LD_EXP 101
37163: PPUSH
37164: LD_VAR 0 1
37168: PPUSH
37169: EMPTY
37170: PPUSH
37171: CALL_OW 1
37175: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37176: LD_ADDR_EXP 102
37180: PUSH
37181: LD_EXP 102
37185: PPUSH
37186: LD_VAR 0 1
37190: PPUSH
37191: EMPTY
37192: PPUSH
37193: CALL_OW 1
37197: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37198: LD_ADDR_EXP 103
37202: PUSH
37203: LD_EXP 103
37207: PPUSH
37208: LD_VAR 0 1
37212: PPUSH
37213: EMPTY
37214: PPUSH
37215: CALL_OW 1
37219: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37220: LD_ADDR_EXP 104
37224: PUSH
37225: LD_EXP 104
37229: PPUSH
37230: LD_VAR 0 1
37234: PPUSH
37235: EMPTY
37236: PPUSH
37237: CALL_OW 1
37241: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37242: LD_ADDR_EXP 105
37246: PUSH
37247: LD_EXP 105
37251: PPUSH
37252: LD_VAR 0 1
37256: PPUSH
37257: EMPTY
37258: PPUSH
37259: CALL_OW 1
37263: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37264: LD_ADDR_EXP 106
37268: PUSH
37269: LD_EXP 106
37273: PPUSH
37274: LD_VAR 0 1
37278: PPUSH
37279: EMPTY
37280: PPUSH
37281: CALL_OW 1
37285: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37286: LD_ADDR_EXP 107
37290: PUSH
37291: LD_EXP 107
37295: PPUSH
37296: LD_VAR 0 1
37300: PPUSH
37301: EMPTY
37302: PPUSH
37303: CALL_OW 1
37307: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37308: LD_ADDR_EXP 108
37312: PUSH
37313: LD_EXP 108
37317: PPUSH
37318: LD_VAR 0 1
37322: PPUSH
37323: EMPTY
37324: PPUSH
37325: CALL_OW 1
37329: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37330: LD_ADDR_EXP 109
37334: PUSH
37335: LD_EXP 109
37339: PPUSH
37340: LD_VAR 0 1
37344: PPUSH
37345: EMPTY
37346: PPUSH
37347: CALL_OW 1
37351: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37352: LD_ADDR_EXP 110
37356: PUSH
37357: LD_EXP 110
37361: PPUSH
37362: LD_VAR 0 1
37366: PPUSH
37367: EMPTY
37368: PPUSH
37369: CALL_OW 1
37373: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37374: LD_ADDR_EXP 111
37378: PUSH
37379: LD_EXP 111
37383: PPUSH
37384: LD_VAR 0 1
37388: PPUSH
37389: LD_INT 0
37391: PPUSH
37392: CALL_OW 1
37396: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37397: LD_ADDR_EXP 112
37401: PUSH
37402: LD_EXP 112
37406: PPUSH
37407: LD_VAR 0 1
37411: PPUSH
37412: EMPTY
37413: PPUSH
37414: CALL_OW 1
37418: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37419: LD_ADDR_EXP 113
37423: PUSH
37424: LD_EXP 113
37428: PPUSH
37429: LD_VAR 0 1
37433: PPUSH
37434: EMPTY
37435: PPUSH
37436: CALL_OW 1
37440: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37441: LD_ADDR_EXP 114
37445: PUSH
37446: LD_EXP 114
37450: PPUSH
37451: LD_VAR 0 1
37455: PPUSH
37456: EMPTY
37457: PPUSH
37458: CALL_OW 1
37462: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37463: LD_ADDR_EXP 115
37467: PUSH
37468: LD_EXP 115
37472: PPUSH
37473: LD_VAR 0 1
37477: PPUSH
37478: EMPTY
37479: PPUSH
37480: CALL_OW 1
37484: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37485: LD_ADDR_EXP 116
37489: PUSH
37490: LD_EXP 116
37494: PPUSH
37495: LD_VAR 0 1
37499: PPUSH
37500: EMPTY
37501: PPUSH
37502: CALL_OW 1
37506: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37507: LD_ADDR_EXP 117
37511: PUSH
37512: LD_EXP 117
37516: PPUSH
37517: LD_VAR 0 1
37521: PPUSH
37522: EMPTY
37523: PPUSH
37524: CALL_OW 1
37528: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37529: LD_ADDR_EXP 118
37533: PUSH
37534: LD_EXP 118
37538: PPUSH
37539: LD_VAR 0 1
37543: PPUSH
37544: EMPTY
37545: PPUSH
37546: CALL_OW 1
37550: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37551: LD_ADDR_EXP 119
37555: PUSH
37556: LD_EXP 119
37560: PPUSH
37561: LD_VAR 0 1
37565: PPUSH
37566: EMPTY
37567: PPUSH
37568: CALL_OW 1
37572: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37573: LD_ADDR_EXP 120
37577: PUSH
37578: LD_EXP 120
37582: PPUSH
37583: LD_VAR 0 1
37587: PPUSH
37588: EMPTY
37589: PPUSH
37590: CALL_OW 1
37594: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37595: LD_ADDR_EXP 121
37599: PUSH
37600: LD_EXP 121
37604: PPUSH
37605: LD_VAR 0 1
37609: PPUSH
37610: EMPTY
37611: PPUSH
37612: CALL_OW 1
37616: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37617: LD_ADDR_EXP 122
37621: PUSH
37622: LD_EXP 122
37626: PPUSH
37627: LD_VAR 0 1
37631: PPUSH
37632: EMPTY
37633: PPUSH
37634: CALL_OW 1
37638: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37639: LD_ADDR_EXP 123
37643: PUSH
37644: LD_EXP 123
37648: PPUSH
37649: LD_VAR 0 1
37653: PPUSH
37654: EMPTY
37655: PPUSH
37656: CALL_OW 1
37660: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37661: LD_ADDR_EXP 124
37665: PUSH
37666: LD_EXP 124
37670: PPUSH
37671: LD_VAR 0 1
37675: PPUSH
37676: EMPTY
37677: PPUSH
37678: CALL_OW 1
37682: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37683: LD_ADDR_EXP 125
37687: PUSH
37688: LD_EXP 125
37692: PPUSH
37693: LD_VAR 0 1
37697: PPUSH
37698: EMPTY
37699: PPUSH
37700: CALL_OW 1
37704: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37705: LD_ADDR_EXP 127
37709: PUSH
37710: LD_EXP 127
37714: PPUSH
37715: LD_VAR 0 1
37719: PPUSH
37720: EMPTY
37721: PPUSH
37722: CALL_OW 1
37726: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37727: LD_ADDR_EXP 129
37731: PUSH
37732: LD_EXP 129
37736: PPUSH
37737: LD_VAR 0 1
37741: PPUSH
37742: EMPTY
37743: PPUSH
37744: CALL_OW 1
37748: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37749: LD_ADDR_EXP 130
37753: PUSH
37754: LD_EXP 130
37758: PPUSH
37759: LD_VAR 0 1
37763: PPUSH
37764: EMPTY
37765: PPUSH
37766: CALL_OW 1
37770: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37771: LD_ADDR_EXP 131
37775: PUSH
37776: LD_EXP 131
37780: PPUSH
37781: LD_VAR 0 1
37785: PPUSH
37786: EMPTY
37787: PPUSH
37788: CALL_OW 1
37792: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37793: LD_ADDR_EXP 132
37797: PUSH
37798: LD_EXP 132
37802: PPUSH
37803: LD_VAR 0 1
37807: PPUSH
37808: EMPTY
37809: PPUSH
37810: CALL_OW 1
37814: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37815: LD_ADDR_EXP 133
37819: PUSH
37820: LD_EXP 133
37824: PPUSH
37825: LD_VAR 0 1
37829: PPUSH
37830: EMPTY
37831: PPUSH
37832: CALL_OW 1
37836: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37837: LD_ADDR_EXP 134
37841: PUSH
37842: LD_EXP 134
37846: PPUSH
37847: LD_VAR 0 1
37851: PPUSH
37852: EMPTY
37853: PPUSH
37854: CALL_OW 1
37858: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37859: LD_ADDR_EXP 135
37863: PUSH
37864: LD_EXP 135
37868: PPUSH
37869: LD_VAR 0 1
37873: PPUSH
37874: EMPTY
37875: PPUSH
37876: CALL_OW 1
37880: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37881: LD_ADDR_EXP 136
37885: PUSH
37886: LD_EXP 136
37890: PPUSH
37891: LD_VAR 0 1
37895: PPUSH
37896: EMPTY
37897: PPUSH
37898: CALL_OW 1
37902: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37903: LD_ADDR_EXP 137
37907: PUSH
37908: LD_EXP 137
37912: PPUSH
37913: LD_VAR 0 1
37917: PPUSH
37918: EMPTY
37919: PPUSH
37920: CALL_OW 1
37924: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37925: LD_ADDR_EXP 138
37929: PUSH
37930: LD_EXP 138
37934: PPUSH
37935: LD_VAR 0 1
37939: PPUSH
37940: EMPTY
37941: PPUSH
37942: CALL_OW 1
37946: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37947: LD_ADDR_EXP 139
37951: PUSH
37952: LD_EXP 139
37956: PPUSH
37957: LD_VAR 0 1
37961: PPUSH
37962: EMPTY
37963: PPUSH
37964: CALL_OW 1
37968: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37969: LD_ADDR_EXP 140
37973: PUSH
37974: LD_EXP 140
37978: PPUSH
37979: LD_VAR 0 1
37983: PPUSH
37984: EMPTY
37985: PPUSH
37986: CALL_OW 1
37990: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37991: LD_ADDR_EXP 141
37995: PUSH
37996: LD_EXP 141
38000: PPUSH
38001: LD_VAR 0 1
38005: PPUSH
38006: EMPTY
38007: PPUSH
38008: CALL_OW 1
38012: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38013: LD_ADDR_EXP 142
38017: PUSH
38018: LD_EXP 142
38022: PPUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 0
38030: PPUSH
38031: CALL_OW 1
38035: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38036: LD_ADDR_EXP 143
38040: PUSH
38041: LD_EXP 143
38045: PPUSH
38046: LD_VAR 0 1
38050: PPUSH
38051: LD_INT 0
38053: PPUSH
38054: CALL_OW 1
38058: ST_TO_ADDR
// end ;
38059: LD_VAR 0 2
38063: RET
// export function MC_Add ( side , units ) ; var base ; begin
38064: LD_INT 0
38066: PPUSH
38067: PPUSH
// base := mc_bases + 1 ;
38068: LD_ADDR_VAR 0 4
38072: PUSH
38073: LD_EXP 100
38077: PUSH
38078: LD_INT 1
38080: PLUS
38081: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
38082: LD_ADDR_EXP 126
38086: PUSH
38087: LD_EXP 126
38091: PPUSH
38092: LD_VAR 0 4
38096: PPUSH
38097: LD_VAR 0 1
38101: PPUSH
38102: CALL_OW 1
38106: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
38107: LD_ADDR_EXP 100
38111: PUSH
38112: LD_EXP 100
38116: PPUSH
38117: LD_VAR 0 4
38121: PPUSH
38122: LD_VAR 0 2
38126: PPUSH
38127: CALL_OW 1
38131: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38132: LD_ADDR_EXP 101
38136: PUSH
38137: LD_EXP 101
38141: PPUSH
38142: LD_VAR 0 4
38146: PPUSH
38147: EMPTY
38148: PPUSH
38149: CALL_OW 1
38153: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38154: LD_ADDR_EXP 102
38158: PUSH
38159: LD_EXP 102
38163: PPUSH
38164: LD_VAR 0 4
38168: PPUSH
38169: EMPTY
38170: PPUSH
38171: CALL_OW 1
38175: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38176: LD_ADDR_EXP 103
38180: PUSH
38181: LD_EXP 103
38185: PPUSH
38186: LD_VAR 0 4
38190: PPUSH
38191: EMPTY
38192: PPUSH
38193: CALL_OW 1
38197: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38198: LD_ADDR_EXP 104
38202: PUSH
38203: LD_EXP 104
38207: PPUSH
38208: LD_VAR 0 4
38212: PPUSH
38213: EMPTY
38214: PPUSH
38215: CALL_OW 1
38219: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38220: LD_ADDR_EXP 105
38224: PUSH
38225: LD_EXP 105
38229: PPUSH
38230: LD_VAR 0 4
38234: PPUSH
38235: EMPTY
38236: PPUSH
38237: CALL_OW 1
38241: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38242: LD_ADDR_EXP 106
38246: PUSH
38247: LD_EXP 106
38251: PPUSH
38252: LD_VAR 0 4
38256: PPUSH
38257: EMPTY
38258: PPUSH
38259: CALL_OW 1
38263: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38264: LD_ADDR_EXP 107
38268: PUSH
38269: LD_EXP 107
38273: PPUSH
38274: LD_VAR 0 4
38278: PPUSH
38279: EMPTY
38280: PPUSH
38281: CALL_OW 1
38285: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38286: LD_ADDR_EXP 108
38290: PUSH
38291: LD_EXP 108
38295: PPUSH
38296: LD_VAR 0 4
38300: PPUSH
38301: EMPTY
38302: PPUSH
38303: CALL_OW 1
38307: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38308: LD_ADDR_EXP 109
38312: PUSH
38313: LD_EXP 109
38317: PPUSH
38318: LD_VAR 0 4
38322: PPUSH
38323: EMPTY
38324: PPUSH
38325: CALL_OW 1
38329: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38330: LD_ADDR_EXP 110
38334: PUSH
38335: LD_EXP 110
38339: PPUSH
38340: LD_VAR 0 4
38344: PPUSH
38345: EMPTY
38346: PPUSH
38347: CALL_OW 1
38351: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38352: LD_ADDR_EXP 111
38356: PUSH
38357: LD_EXP 111
38361: PPUSH
38362: LD_VAR 0 4
38366: PPUSH
38367: LD_INT 0
38369: PPUSH
38370: CALL_OW 1
38374: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38375: LD_ADDR_EXP 112
38379: PUSH
38380: LD_EXP 112
38384: PPUSH
38385: LD_VAR 0 4
38389: PPUSH
38390: EMPTY
38391: PPUSH
38392: CALL_OW 1
38396: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38397: LD_ADDR_EXP 113
38401: PUSH
38402: LD_EXP 113
38406: PPUSH
38407: LD_VAR 0 4
38411: PPUSH
38412: EMPTY
38413: PPUSH
38414: CALL_OW 1
38418: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38419: LD_ADDR_EXP 114
38423: PUSH
38424: LD_EXP 114
38428: PPUSH
38429: LD_VAR 0 4
38433: PPUSH
38434: EMPTY
38435: PPUSH
38436: CALL_OW 1
38440: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38441: LD_ADDR_EXP 115
38445: PUSH
38446: LD_EXP 115
38450: PPUSH
38451: LD_VAR 0 4
38455: PPUSH
38456: EMPTY
38457: PPUSH
38458: CALL_OW 1
38462: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38463: LD_ADDR_EXP 116
38467: PUSH
38468: LD_EXP 116
38472: PPUSH
38473: LD_VAR 0 4
38477: PPUSH
38478: EMPTY
38479: PPUSH
38480: CALL_OW 1
38484: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38485: LD_ADDR_EXP 117
38489: PUSH
38490: LD_EXP 117
38494: PPUSH
38495: LD_VAR 0 4
38499: PPUSH
38500: EMPTY
38501: PPUSH
38502: CALL_OW 1
38506: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38507: LD_ADDR_EXP 118
38511: PUSH
38512: LD_EXP 118
38516: PPUSH
38517: LD_VAR 0 4
38521: PPUSH
38522: EMPTY
38523: PPUSH
38524: CALL_OW 1
38528: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38529: LD_ADDR_EXP 119
38533: PUSH
38534: LD_EXP 119
38538: PPUSH
38539: LD_VAR 0 4
38543: PPUSH
38544: EMPTY
38545: PPUSH
38546: CALL_OW 1
38550: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38551: LD_ADDR_EXP 120
38555: PUSH
38556: LD_EXP 120
38560: PPUSH
38561: LD_VAR 0 4
38565: PPUSH
38566: EMPTY
38567: PPUSH
38568: CALL_OW 1
38572: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38573: LD_ADDR_EXP 121
38577: PUSH
38578: LD_EXP 121
38582: PPUSH
38583: LD_VAR 0 4
38587: PPUSH
38588: EMPTY
38589: PPUSH
38590: CALL_OW 1
38594: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38595: LD_ADDR_EXP 122
38599: PUSH
38600: LD_EXP 122
38604: PPUSH
38605: LD_VAR 0 4
38609: PPUSH
38610: EMPTY
38611: PPUSH
38612: CALL_OW 1
38616: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38617: LD_ADDR_EXP 123
38621: PUSH
38622: LD_EXP 123
38626: PPUSH
38627: LD_VAR 0 4
38631: PPUSH
38632: EMPTY
38633: PPUSH
38634: CALL_OW 1
38638: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38639: LD_ADDR_EXP 124
38643: PUSH
38644: LD_EXP 124
38648: PPUSH
38649: LD_VAR 0 4
38653: PPUSH
38654: EMPTY
38655: PPUSH
38656: CALL_OW 1
38660: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38661: LD_ADDR_EXP 125
38665: PUSH
38666: LD_EXP 125
38670: PPUSH
38671: LD_VAR 0 4
38675: PPUSH
38676: EMPTY
38677: PPUSH
38678: CALL_OW 1
38682: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38683: LD_ADDR_EXP 127
38687: PUSH
38688: LD_EXP 127
38692: PPUSH
38693: LD_VAR 0 4
38697: PPUSH
38698: EMPTY
38699: PPUSH
38700: CALL_OW 1
38704: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38705: LD_ADDR_EXP 129
38709: PUSH
38710: LD_EXP 129
38714: PPUSH
38715: LD_VAR 0 4
38719: PPUSH
38720: EMPTY
38721: PPUSH
38722: CALL_OW 1
38726: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38727: LD_ADDR_EXP 130
38731: PUSH
38732: LD_EXP 130
38736: PPUSH
38737: LD_VAR 0 4
38741: PPUSH
38742: EMPTY
38743: PPUSH
38744: CALL_OW 1
38748: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38749: LD_ADDR_EXP 131
38753: PUSH
38754: LD_EXP 131
38758: PPUSH
38759: LD_VAR 0 4
38763: PPUSH
38764: EMPTY
38765: PPUSH
38766: CALL_OW 1
38770: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38771: LD_ADDR_EXP 132
38775: PUSH
38776: LD_EXP 132
38780: PPUSH
38781: LD_VAR 0 4
38785: PPUSH
38786: EMPTY
38787: PPUSH
38788: CALL_OW 1
38792: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38793: LD_ADDR_EXP 133
38797: PUSH
38798: LD_EXP 133
38802: PPUSH
38803: LD_VAR 0 4
38807: PPUSH
38808: EMPTY
38809: PPUSH
38810: CALL_OW 1
38814: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38815: LD_ADDR_EXP 134
38819: PUSH
38820: LD_EXP 134
38824: PPUSH
38825: LD_VAR 0 4
38829: PPUSH
38830: EMPTY
38831: PPUSH
38832: CALL_OW 1
38836: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38837: LD_ADDR_EXP 135
38841: PUSH
38842: LD_EXP 135
38846: PPUSH
38847: LD_VAR 0 4
38851: PPUSH
38852: EMPTY
38853: PPUSH
38854: CALL_OW 1
38858: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38859: LD_ADDR_EXP 136
38863: PUSH
38864: LD_EXP 136
38868: PPUSH
38869: LD_VAR 0 4
38873: PPUSH
38874: EMPTY
38875: PPUSH
38876: CALL_OW 1
38880: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38881: LD_ADDR_EXP 137
38885: PUSH
38886: LD_EXP 137
38890: PPUSH
38891: LD_VAR 0 4
38895: PPUSH
38896: EMPTY
38897: PPUSH
38898: CALL_OW 1
38902: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38903: LD_ADDR_EXP 138
38907: PUSH
38908: LD_EXP 138
38912: PPUSH
38913: LD_VAR 0 4
38917: PPUSH
38918: EMPTY
38919: PPUSH
38920: CALL_OW 1
38924: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38925: LD_ADDR_EXP 139
38929: PUSH
38930: LD_EXP 139
38934: PPUSH
38935: LD_VAR 0 4
38939: PPUSH
38940: EMPTY
38941: PPUSH
38942: CALL_OW 1
38946: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38947: LD_ADDR_EXP 140
38951: PUSH
38952: LD_EXP 140
38956: PPUSH
38957: LD_VAR 0 4
38961: PPUSH
38962: EMPTY
38963: PPUSH
38964: CALL_OW 1
38968: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38969: LD_ADDR_EXP 141
38973: PUSH
38974: LD_EXP 141
38978: PPUSH
38979: LD_VAR 0 4
38983: PPUSH
38984: EMPTY
38985: PPUSH
38986: CALL_OW 1
38990: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38991: LD_ADDR_EXP 142
38995: PUSH
38996: LD_EXP 142
39000: PPUSH
39001: LD_VAR 0 4
39005: PPUSH
39006: LD_INT 0
39008: PPUSH
39009: CALL_OW 1
39013: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39014: LD_ADDR_EXP 143
39018: PUSH
39019: LD_EXP 143
39023: PPUSH
39024: LD_VAR 0 4
39028: PPUSH
39029: LD_INT 0
39031: PPUSH
39032: CALL_OW 1
39036: ST_TO_ADDR
// result := base ;
39037: LD_ADDR_VAR 0 3
39041: PUSH
39042: LD_VAR 0 4
39046: ST_TO_ADDR
// end ;
39047: LD_VAR 0 3
39051: RET
// export function MC_Start ( ) ; var i ; begin
39052: LD_INT 0
39054: PPUSH
39055: PPUSH
// for i = 1 to mc_bases do
39056: LD_ADDR_VAR 0 2
39060: PUSH
39061: DOUBLE
39062: LD_INT 1
39064: DEC
39065: ST_TO_ADDR
39066: LD_EXP 100
39070: PUSH
39071: FOR_TO
39072: IFFALSE 40172
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
39074: LD_ADDR_EXP 100
39078: PUSH
39079: LD_EXP 100
39083: PPUSH
39084: LD_VAR 0 2
39088: PPUSH
39089: LD_EXP 100
39093: PUSH
39094: LD_VAR 0 2
39098: ARRAY
39099: PUSH
39100: LD_INT 0
39102: DIFF
39103: PPUSH
39104: CALL_OW 1
39108: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
39109: LD_ADDR_EXP 101
39113: PUSH
39114: LD_EXP 101
39118: PPUSH
39119: LD_VAR 0 2
39123: PPUSH
39124: EMPTY
39125: PPUSH
39126: CALL_OW 1
39130: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39131: LD_ADDR_EXP 102
39135: PUSH
39136: LD_EXP 102
39140: PPUSH
39141: LD_VAR 0 2
39145: PPUSH
39146: EMPTY
39147: PPUSH
39148: CALL_OW 1
39152: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
39153: LD_ADDR_EXP 103
39157: PUSH
39158: LD_EXP 103
39162: PPUSH
39163: LD_VAR 0 2
39167: PPUSH
39168: EMPTY
39169: PPUSH
39170: CALL_OW 1
39174: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
39175: LD_ADDR_EXP 104
39179: PUSH
39180: LD_EXP 104
39184: PPUSH
39185: LD_VAR 0 2
39189: PPUSH
39190: EMPTY
39191: PUSH
39192: EMPTY
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PPUSH
39198: CALL_OW 1
39202: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
39203: LD_ADDR_EXP 105
39207: PUSH
39208: LD_EXP 105
39212: PPUSH
39213: LD_VAR 0 2
39217: PPUSH
39218: EMPTY
39219: PPUSH
39220: CALL_OW 1
39224: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
39225: LD_ADDR_EXP 132
39229: PUSH
39230: LD_EXP 132
39234: PPUSH
39235: LD_VAR 0 2
39239: PPUSH
39240: EMPTY
39241: PPUSH
39242: CALL_OW 1
39246: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
39247: LD_ADDR_EXP 106
39251: PUSH
39252: LD_EXP 106
39256: PPUSH
39257: LD_VAR 0 2
39261: PPUSH
39262: EMPTY
39263: PPUSH
39264: CALL_OW 1
39268: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
39269: LD_ADDR_EXP 107
39273: PUSH
39274: LD_EXP 107
39278: PPUSH
39279: LD_VAR 0 2
39283: PPUSH
39284: EMPTY
39285: PPUSH
39286: CALL_OW 1
39290: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
39291: LD_ADDR_EXP 108
39295: PUSH
39296: LD_EXP 108
39300: PPUSH
39301: LD_VAR 0 2
39305: PPUSH
39306: LD_EXP 100
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: PPUSH
39317: LD_INT 2
39319: PUSH
39320: LD_INT 30
39322: PUSH
39323: LD_INT 32
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 30
39332: PUSH
39333: LD_INT 33
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: LIST
39344: PPUSH
39345: CALL_OW 72
39349: PPUSH
39350: CALL_OW 1
39354: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39355: LD_ADDR_EXP 109
39359: PUSH
39360: LD_EXP 109
39364: PPUSH
39365: LD_VAR 0 2
39369: PPUSH
39370: LD_EXP 100
39374: PUSH
39375: LD_VAR 0 2
39379: ARRAY
39380: PPUSH
39381: LD_INT 2
39383: PUSH
39384: LD_INT 30
39386: PUSH
39387: LD_INT 32
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 30
39396: PUSH
39397: LD_INT 31
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 58
39411: PUSH
39412: EMPTY
39413: LIST
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PPUSH
39419: CALL_OW 72
39423: PPUSH
39424: CALL_OW 1
39428: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39429: LD_ADDR_EXP 110
39433: PUSH
39434: LD_EXP 110
39438: PPUSH
39439: LD_VAR 0 2
39443: PPUSH
39444: EMPTY
39445: PPUSH
39446: CALL_OW 1
39450: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39451: LD_ADDR_EXP 114
39455: PUSH
39456: LD_EXP 114
39460: PPUSH
39461: LD_VAR 0 2
39465: PPUSH
39466: EMPTY
39467: PPUSH
39468: CALL_OW 1
39472: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39473: LD_ADDR_EXP 113
39477: PUSH
39478: LD_EXP 113
39482: PPUSH
39483: LD_VAR 0 2
39487: PPUSH
39488: EMPTY
39489: PPUSH
39490: CALL_OW 1
39494: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39495: LD_ADDR_EXP 115
39499: PUSH
39500: LD_EXP 115
39504: PPUSH
39505: LD_VAR 0 2
39509: PPUSH
39510: EMPTY
39511: PPUSH
39512: CALL_OW 1
39516: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39517: LD_ADDR_EXP 116
39521: PUSH
39522: LD_EXP 116
39526: PPUSH
39527: LD_VAR 0 2
39531: PPUSH
39532: EMPTY
39533: PPUSH
39534: CALL_OW 1
39538: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39539: LD_ADDR_EXP 117
39543: PUSH
39544: LD_EXP 117
39548: PPUSH
39549: LD_VAR 0 2
39553: PPUSH
39554: EMPTY
39555: PPUSH
39556: CALL_OW 1
39560: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39561: LD_ADDR_EXP 118
39565: PUSH
39566: LD_EXP 118
39570: PPUSH
39571: LD_VAR 0 2
39575: PPUSH
39576: EMPTY
39577: PPUSH
39578: CALL_OW 1
39582: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39583: LD_ADDR_EXP 119
39587: PUSH
39588: LD_EXP 119
39592: PPUSH
39593: LD_VAR 0 2
39597: PPUSH
39598: EMPTY
39599: PPUSH
39600: CALL_OW 1
39604: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39605: LD_ADDR_EXP 120
39609: PUSH
39610: LD_EXP 120
39614: PPUSH
39615: LD_VAR 0 2
39619: PPUSH
39620: EMPTY
39621: PPUSH
39622: CALL_OW 1
39626: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39627: LD_ADDR_EXP 121
39631: PUSH
39632: LD_EXP 121
39636: PPUSH
39637: LD_VAR 0 2
39641: PPUSH
39642: EMPTY
39643: PPUSH
39644: CALL_OW 1
39648: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39649: LD_ADDR_EXP 122
39653: PUSH
39654: LD_EXP 122
39658: PPUSH
39659: LD_VAR 0 2
39663: PPUSH
39664: EMPTY
39665: PPUSH
39666: CALL_OW 1
39670: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39671: LD_ADDR_EXP 111
39675: PUSH
39676: LD_EXP 111
39680: PPUSH
39681: LD_VAR 0 2
39685: PPUSH
39686: LD_INT 0
39688: PPUSH
39689: CALL_OW 1
39693: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39694: LD_ADDR_EXP 124
39698: PUSH
39699: LD_EXP 124
39703: PPUSH
39704: LD_VAR 0 2
39708: PPUSH
39709: LD_INT 0
39711: PPUSH
39712: CALL_OW 1
39716: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39717: LD_ADDR_EXP 112
39721: PUSH
39722: LD_EXP 112
39726: PPUSH
39727: LD_VAR 0 2
39731: PPUSH
39732: EMPTY
39733: PPUSH
39734: CALL_OW 1
39738: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39739: LD_ADDR_EXP 123
39743: PUSH
39744: LD_EXP 123
39748: PPUSH
39749: LD_VAR 0 2
39753: PPUSH
39754: LD_INT 0
39756: PPUSH
39757: CALL_OW 1
39761: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39762: LD_ADDR_EXP 125
39766: PUSH
39767: LD_EXP 125
39771: PPUSH
39772: LD_VAR 0 2
39776: PPUSH
39777: EMPTY
39778: PPUSH
39779: CALL_OW 1
39783: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39784: LD_ADDR_EXP 128
39788: PUSH
39789: LD_EXP 128
39793: PPUSH
39794: LD_VAR 0 2
39798: PPUSH
39799: LD_INT 0
39801: PPUSH
39802: CALL_OW 1
39806: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39807: LD_ADDR_EXP 129
39811: PUSH
39812: LD_EXP 129
39816: PPUSH
39817: LD_VAR 0 2
39821: PPUSH
39822: EMPTY
39823: PPUSH
39824: CALL_OW 1
39828: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39829: LD_ADDR_EXP 130
39833: PUSH
39834: LD_EXP 130
39838: PPUSH
39839: LD_VAR 0 2
39843: PPUSH
39844: EMPTY
39845: PPUSH
39846: CALL_OW 1
39850: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39851: LD_ADDR_EXP 131
39855: PUSH
39856: LD_EXP 131
39860: PPUSH
39861: LD_VAR 0 2
39865: PPUSH
39866: EMPTY
39867: PPUSH
39868: CALL_OW 1
39872: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39873: LD_ADDR_EXP 133
39877: PUSH
39878: LD_EXP 133
39882: PPUSH
39883: LD_VAR 0 2
39887: PPUSH
39888: LD_EXP 100
39892: PUSH
39893: LD_VAR 0 2
39897: ARRAY
39898: PPUSH
39899: LD_INT 2
39901: PUSH
39902: LD_INT 30
39904: PUSH
39905: LD_INT 6
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 30
39914: PUSH
39915: LD_INT 7
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 30
39924: PUSH
39925: LD_INT 8
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: LIST
39936: LIST
39937: PPUSH
39938: CALL_OW 72
39942: PPUSH
39943: CALL_OW 1
39947: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39948: LD_ADDR_EXP 134
39952: PUSH
39953: LD_EXP 134
39957: PPUSH
39958: LD_VAR 0 2
39962: PPUSH
39963: EMPTY
39964: PPUSH
39965: CALL_OW 1
39969: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39970: LD_ADDR_EXP 135
39974: PUSH
39975: LD_EXP 135
39979: PPUSH
39980: LD_VAR 0 2
39984: PPUSH
39985: EMPTY
39986: PPUSH
39987: CALL_OW 1
39991: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39992: LD_ADDR_EXP 136
39996: PUSH
39997: LD_EXP 136
40001: PPUSH
40002: LD_VAR 0 2
40006: PPUSH
40007: EMPTY
40008: PPUSH
40009: CALL_OW 1
40013: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
40014: LD_ADDR_EXP 137
40018: PUSH
40019: LD_EXP 137
40023: PPUSH
40024: LD_VAR 0 2
40028: PPUSH
40029: EMPTY
40030: PPUSH
40031: CALL_OW 1
40035: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40036: LD_ADDR_EXP 138
40040: PUSH
40041: LD_EXP 138
40045: PPUSH
40046: LD_VAR 0 2
40050: PPUSH
40051: EMPTY
40052: PPUSH
40053: CALL_OW 1
40057: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
40058: LD_ADDR_EXP 139
40062: PUSH
40063: LD_EXP 139
40067: PPUSH
40068: LD_VAR 0 2
40072: PPUSH
40073: EMPTY
40074: PPUSH
40075: CALL_OW 1
40079: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
40080: LD_ADDR_EXP 140
40084: PUSH
40085: LD_EXP 140
40089: PPUSH
40090: LD_VAR 0 2
40094: PPUSH
40095: EMPTY
40096: PPUSH
40097: CALL_OW 1
40101: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
40102: LD_ADDR_EXP 141
40106: PUSH
40107: LD_EXP 141
40111: PPUSH
40112: LD_VAR 0 2
40116: PPUSH
40117: EMPTY
40118: PPUSH
40119: CALL_OW 1
40123: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
40124: LD_ADDR_EXP 142
40128: PUSH
40129: LD_EXP 142
40133: PPUSH
40134: LD_VAR 0 2
40138: PPUSH
40139: LD_INT 0
40141: PPUSH
40142: CALL_OW 1
40146: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
40147: LD_ADDR_EXP 143
40151: PUSH
40152: LD_EXP 143
40156: PPUSH
40157: LD_VAR 0 2
40161: PPUSH
40162: LD_INT 0
40164: PPUSH
40165: CALL_OW 1
40169: ST_TO_ADDR
// end ;
40170: GO 39071
40172: POP
40173: POP
// MC_InitSides ( ) ;
40174: CALL 40460 0 0
// MC_InitResearch ( ) ;
40178: CALL 40199 0 0
// CustomInitMacro ( ) ;
40182: CALL 475 0 0
// skirmish := true ;
40186: LD_ADDR_EXP 98
40190: PUSH
40191: LD_INT 1
40193: ST_TO_ADDR
// end ;
40194: LD_VAR 0 1
40198: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
40199: LD_INT 0
40201: PPUSH
40202: PPUSH
40203: PPUSH
40204: PPUSH
40205: PPUSH
40206: PPUSH
// if not mc_bases then
40207: LD_EXP 100
40211: NOT
40212: IFFALSE 40216
// exit ;
40214: GO 40455
// for i = 1 to 8 do
40216: LD_ADDR_VAR 0 2
40220: PUSH
40221: DOUBLE
40222: LD_INT 1
40224: DEC
40225: ST_TO_ADDR
40226: LD_INT 8
40228: PUSH
40229: FOR_TO
40230: IFFALSE 40256
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
40232: LD_ADDR_EXP 127
40236: PUSH
40237: LD_EXP 127
40241: PPUSH
40242: LD_VAR 0 2
40246: PPUSH
40247: EMPTY
40248: PPUSH
40249: CALL_OW 1
40253: ST_TO_ADDR
40254: GO 40229
40256: POP
40257: POP
// tmp := [ ] ;
40258: LD_ADDR_VAR 0 5
40262: PUSH
40263: EMPTY
40264: ST_TO_ADDR
// for i = 1 to mc_sides do
40265: LD_ADDR_VAR 0 2
40269: PUSH
40270: DOUBLE
40271: LD_INT 1
40273: DEC
40274: ST_TO_ADDR
40275: LD_EXP 126
40279: PUSH
40280: FOR_TO
40281: IFFALSE 40339
// if not mc_sides [ i ] in tmp then
40283: LD_EXP 126
40287: PUSH
40288: LD_VAR 0 2
40292: ARRAY
40293: PUSH
40294: LD_VAR 0 5
40298: IN
40299: NOT
40300: IFFALSE 40337
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
40302: LD_ADDR_VAR 0 5
40306: PUSH
40307: LD_VAR 0 5
40311: PPUSH
40312: LD_VAR 0 5
40316: PUSH
40317: LD_INT 1
40319: PLUS
40320: PPUSH
40321: LD_EXP 126
40325: PUSH
40326: LD_VAR 0 2
40330: ARRAY
40331: PPUSH
40332: CALL_OW 2
40336: ST_TO_ADDR
40337: GO 40280
40339: POP
40340: POP
// if not tmp then
40341: LD_VAR 0 5
40345: NOT
40346: IFFALSE 40350
// exit ;
40348: GO 40455
// for j in tmp do
40350: LD_ADDR_VAR 0 3
40354: PUSH
40355: LD_VAR 0 5
40359: PUSH
40360: FOR_IN
40361: IFFALSE 40453
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40363: LD_ADDR_VAR 0 6
40367: PUSH
40368: LD_INT 22
40370: PUSH
40371: LD_VAR 0 3
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PPUSH
40380: CALL_OW 69
40384: ST_TO_ADDR
// if not un then
40385: LD_VAR 0 6
40389: NOT
40390: IFFALSE 40394
// continue ;
40392: GO 40360
// nation := GetNation ( un [ 1 ] ) ;
40394: LD_ADDR_VAR 0 4
40398: PUSH
40399: LD_VAR 0 6
40403: PUSH
40404: LD_INT 1
40406: ARRAY
40407: PPUSH
40408: CALL_OW 248
40412: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40413: LD_ADDR_EXP 127
40417: PUSH
40418: LD_EXP 127
40422: PPUSH
40423: LD_VAR 0 3
40427: PPUSH
40428: LD_VAR 0 3
40432: PPUSH
40433: LD_VAR 0 4
40437: PPUSH
40438: LD_INT 1
40440: PPUSH
40441: CALL 67645 0 3
40445: PPUSH
40446: CALL_OW 1
40450: ST_TO_ADDR
// end ;
40451: GO 40360
40453: POP
40454: POP
// end ;
40455: LD_VAR 0 1
40459: RET
// export function MC_InitSides ( ) ; var i ; begin
40460: LD_INT 0
40462: PPUSH
40463: PPUSH
// if not mc_bases then
40464: LD_EXP 100
40468: NOT
40469: IFFALSE 40473
// exit ;
40471: GO 40547
// for i = 1 to mc_bases do
40473: LD_ADDR_VAR 0 2
40477: PUSH
40478: DOUBLE
40479: LD_INT 1
40481: DEC
40482: ST_TO_ADDR
40483: LD_EXP 100
40487: PUSH
40488: FOR_TO
40489: IFFALSE 40545
// if mc_bases [ i ] then
40491: LD_EXP 100
40495: PUSH
40496: LD_VAR 0 2
40500: ARRAY
40501: IFFALSE 40543
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40503: LD_ADDR_EXP 126
40507: PUSH
40508: LD_EXP 126
40512: PPUSH
40513: LD_VAR 0 2
40517: PPUSH
40518: LD_EXP 100
40522: PUSH
40523: LD_VAR 0 2
40527: ARRAY
40528: PUSH
40529: LD_INT 1
40531: ARRAY
40532: PPUSH
40533: CALL_OW 255
40537: PPUSH
40538: CALL_OW 1
40542: ST_TO_ADDR
40543: GO 40488
40545: POP
40546: POP
// end ;
40547: LD_VAR 0 1
40551: RET
// every 0 0$03 trigger skirmish do
40552: LD_EXP 98
40556: IFFALSE 40710
40558: GO 40560
40560: DISABLE
// begin enable ;
40561: ENABLE
// MC_CheckBuildings ( ) ;
40562: CALL 45208 0 0
// MC_CheckPeopleLife ( ) ;
40566: CALL 45369 0 0
// RaiseSailEvent ( 100 ) ;
40570: LD_INT 100
40572: PPUSH
40573: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40577: LD_INT 103
40579: PPUSH
40580: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40584: LD_INT 104
40586: PPUSH
40587: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40591: LD_INT 105
40593: PPUSH
40594: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40598: LD_INT 106
40600: PPUSH
40601: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40605: LD_INT 107
40607: PPUSH
40608: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40612: LD_INT 108
40614: PPUSH
40615: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40619: LD_INT 109
40621: PPUSH
40622: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40626: LD_INT 110
40628: PPUSH
40629: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40633: LD_INT 111
40635: PPUSH
40636: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40640: LD_INT 112
40642: PPUSH
40643: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40647: LD_INT 113
40649: PPUSH
40650: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40654: LD_INT 120
40656: PPUSH
40657: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40661: LD_INT 121
40663: PPUSH
40664: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40668: LD_INT 122
40670: PPUSH
40671: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40675: LD_INT 123
40677: PPUSH
40678: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40682: LD_INT 124
40684: PPUSH
40685: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40689: LD_INT 125
40691: PPUSH
40692: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40696: LD_INT 126
40698: PPUSH
40699: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40703: LD_INT 200
40705: PPUSH
40706: CALL_OW 427
// end ;
40710: END
// on SailEvent ( event ) do begin if event < 100 then
40711: LD_VAR 0 1
40715: PUSH
40716: LD_INT 100
40718: LESS
40719: IFFALSE 40730
// CustomEvent ( event ) ;
40721: LD_VAR 0 1
40725: PPUSH
40726: CALL 35178 0 1
// if event = 100 then
40730: LD_VAR 0 1
40734: PUSH
40735: LD_INT 100
40737: EQUAL
40738: IFFALSE 40744
// MC_ClassManager ( ) ;
40740: CALL 41136 0 0
// if event = 101 then
40744: LD_VAR 0 1
40748: PUSH
40749: LD_INT 101
40751: EQUAL
40752: IFFALSE 40758
// MC_RepairBuildings ( ) ;
40754: CALL 45954 0 0
// if event = 102 then
40758: LD_VAR 0 1
40762: PUSH
40763: LD_INT 102
40765: EQUAL
40766: IFFALSE 40772
// MC_Heal ( ) ;
40768: CALL 46889 0 0
// if event = 103 then
40772: LD_VAR 0 1
40776: PUSH
40777: LD_INT 103
40779: EQUAL
40780: IFFALSE 40786
// MC_Build ( ) ;
40782: CALL 47311 0 0
// if event = 104 then
40786: LD_VAR 0 1
40790: PUSH
40791: LD_INT 104
40793: EQUAL
40794: IFFALSE 40800
// MC_TurretWeapon ( ) ;
40796: CALL 48945 0 0
// if event = 105 then
40800: LD_VAR 0 1
40804: PUSH
40805: LD_INT 105
40807: EQUAL
40808: IFFALSE 40814
// MC_BuildUpgrade ( ) ;
40810: CALL 48496 0 0
// if event = 106 then
40814: LD_VAR 0 1
40818: PUSH
40819: LD_INT 106
40821: EQUAL
40822: IFFALSE 40828
// MC_PlantMines ( ) ;
40824: CALL 49375 0 0
// if event = 107 then
40828: LD_VAR 0 1
40832: PUSH
40833: LD_INT 107
40835: EQUAL
40836: IFFALSE 40842
// MC_CollectCrates ( ) ;
40838: CALL 50166 0 0
// if event = 108 then
40842: LD_VAR 0 1
40846: PUSH
40847: LD_INT 108
40849: EQUAL
40850: IFFALSE 40856
// MC_LinkRemoteControl ( ) ;
40852: CALL 52016 0 0
// if event = 109 then
40856: LD_VAR 0 1
40860: PUSH
40861: LD_INT 109
40863: EQUAL
40864: IFFALSE 40870
// MC_ProduceVehicle ( ) ;
40866: CALL 52197 0 0
// if event = 110 then
40870: LD_VAR 0 1
40874: PUSH
40875: LD_INT 110
40877: EQUAL
40878: IFFALSE 40884
// MC_SendAttack ( ) ;
40880: CALL 52663 0 0
// if event = 111 then
40884: LD_VAR 0 1
40888: PUSH
40889: LD_INT 111
40891: EQUAL
40892: IFFALSE 40898
// MC_Defend ( ) ;
40894: CALL 52771 0 0
// if event = 112 then
40898: LD_VAR 0 1
40902: PUSH
40903: LD_INT 112
40905: EQUAL
40906: IFFALSE 40912
// MC_Research ( ) ;
40908: CALL 53651 0 0
// if event = 113 then
40912: LD_VAR 0 1
40916: PUSH
40917: LD_INT 113
40919: EQUAL
40920: IFFALSE 40926
// MC_MinesTrigger ( ) ;
40922: CALL 54765 0 0
// if event = 120 then
40926: LD_VAR 0 1
40930: PUSH
40931: LD_INT 120
40933: EQUAL
40934: IFFALSE 40940
// MC_RepairVehicle ( ) ;
40936: CALL 54864 0 0
// if event = 121 then
40940: LD_VAR 0 1
40944: PUSH
40945: LD_INT 121
40947: EQUAL
40948: IFFALSE 40954
// MC_TameApe ( ) ;
40950: CALL 55633 0 0
// if event = 122 then
40954: LD_VAR 0 1
40958: PUSH
40959: LD_INT 122
40961: EQUAL
40962: IFFALSE 40968
// MC_ChangeApeClass ( ) ;
40964: CALL 56462 0 0
// if event = 123 then
40968: LD_VAR 0 1
40972: PUSH
40973: LD_INT 123
40975: EQUAL
40976: IFFALSE 40982
// MC_Bazooka ( ) ;
40978: CALL 57112 0 0
// if event = 124 then
40982: LD_VAR 0 1
40986: PUSH
40987: LD_INT 124
40989: EQUAL
40990: IFFALSE 40996
// MC_TeleportExit ( ) ;
40992: CALL 57310 0 0
// if event = 125 then
40996: LD_VAR 0 1
41000: PUSH
41001: LD_INT 125
41003: EQUAL
41004: IFFALSE 41010
// MC_Deposits ( ) ;
41006: CALL 57957 0 0
// if event = 126 then
41010: LD_VAR 0 1
41014: PUSH
41015: LD_INT 126
41017: EQUAL
41018: IFFALSE 41024
// MC_RemoteDriver ( ) ;
41020: CALL 58582 0 0
// if event = 200 then
41024: LD_VAR 0 1
41028: PUSH
41029: LD_INT 200
41031: EQUAL
41032: IFFALSE 41038
// MC_Idle ( ) ;
41034: CALL 60531 0 0
// end ;
41038: PPOPN 1
41040: END
// export function MC_Reset ( base , tag ) ; var i ; begin
41041: LD_INT 0
41043: PPUSH
41044: PPUSH
// if not mc_bases [ base ] or not tag then
41045: LD_EXP 100
41049: PUSH
41050: LD_VAR 0 1
41054: ARRAY
41055: NOT
41056: PUSH
41057: LD_VAR 0 2
41061: NOT
41062: OR
41063: IFFALSE 41067
// exit ;
41065: GO 41131
// for i in mc_bases [ base ] union mc_ape [ base ] do
41067: LD_ADDR_VAR 0 4
41071: PUSH
41072: LD_EXP 100
41076: PUSH
41077: LD_VAR 0 1
41081: ARRAY
41082: PUSH
41083: LD_EXP 129
41087: PUSH
41088: LD_VAR 0 1
41092: ARRAY
41093: UNION
41094: PUSH
41095: FOR_IN
41096: IFFALSE 41129
// if GetTag ( i ) = tag then
41098: LD_VAR 0 4
41102: PPUSH
41103: CALL_OW 110
41107: PUSH
41108: LD_VAR 0 2
41112: EQUAL
41113: IFFALSE 41127
// SetTag ( i , 0 ) ;
41115: LD_VAR 0 4
41119: PPUSH
41120: LD_INT 0
41122: PPUSH
41123: CALL_OW 109
41127: GO 41095
41129: POP
41130: POP
// end ;
41131: LD_VAR 0 3
41135: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
41136: LD_INT 0
41138: PPUSH
41139: PPUSH
41140: PPUSH
41141: PPUSH
41142: PPUSH
41143: PPUSH
41144: PPUSH
41145: PPUSH
// if not mc_bases then
41146: LD_EXP 100
41150: NOT
41151: IFFALSE 41155
// exit ;
41153: GO 41613
// for i = 1 to mc_bases do
41155: LD_ADDR_VAR 0 2
41159: PUSH
41160: DOUBLE
41161: LD_INT 1
41163: DEC
41164: ST_TO_ADDR
41165: LD_EXP 100
41169: PUSH
41170: FOR_TO
41171: IFFALSE 41611
// begin tmp := MC_ClassCheckReq ( i ) ;
41173: LD_ADDR_VAR 0 4
41177: PUSH
41178: LD_VAR 0 2
41182: PPUSH
41183: CALL 41618 0 1
41187: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
41188: LD_ADDR_EXP 141
41192: PUSH
41193: LD_EXP 141
41197: PPUSH
41198: LD_VAR 0 2
41202: PPUSH
41203: LD_VAR 0 4
41207: PPUSH
41208: CALL_OW 1
41212: ST_TO_ADDR
// if not tmp then
41213: LD_VAR 0 4
41217: NOT
41218: IFFALSE 41222
// continue ;
41220: GO 41170
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
41222: LD_ADDR_VAR 0 6
41226: PUSH
41227: LD_EXP 100
41231: PUSH
41232: LD_VAR 0 2
41236: ARRAY
41237: PPUSH
41238: LD_INT 2
41240: PUSH
41241: LD_INT 30
41243: PUSH
41244: LD_INT 4
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 30
41253: PUSH
41254: LD_INT 5
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: LIST
41265: PPUSH
41266: CALL_OW 72
41270: PUSH
41271: LD_EXP 100
41275: PUSH
41276: LD_VAR 0 2
41280: ARRAY
41281: PPUSH
41282: LD_INT 2
41284: PUSH
41285: LD_INT 30
41287: PUSH
41288: LD_INT 0
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 30
41297: PUSH
41298: LD_INT 1
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: LIST
41309: PPUSH
41310: CALL_OW 72
41314: PUSH
41315: LD_EXP 100
41319: PUSH
41320: LD_VAR 0 2
41324: ARRAY
41325: PPUSH
41326: LD_INT 30
41328: PUSH
41329: LD_INT 3
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PPUSH
41336: CALL_OW 72
41340: PUSH
41341: LD_EXP 100
41345: PUSH
41346: LD_VAR 0 2
41350: ARRAY
41351: PPUSH
41352: LD_INT 2
41354: PUSH
41355: LD_INT 30
41357: PUSH
41358: LD_INT 6
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 30
41367: PUSH
41368: LD_INT 7
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 30
41377: PUSH
41378: LD_INT 8
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: LIST
41389: LIST
41390: PPUSH
41391: CALL_OW 72
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: ST_TO_ADDR
// for j = 1 to 4 do
41402: LD_ADDR_VAR 0 3
41406: PUSH
41407: DOUBLE
41408: LD_INT 1
41410: DEC
41411: ST_TO_ADDR
41412: LD_INT 4
41414: PUSH
41415: FOR_TO
41416: IFFALSE 41607
// begin if not tmp [ j ] then
41418: LD_VAR 0 4
41422: PUSH
41423: LD_VAR 0 3
41427: ARRAY
41428: NOT
41429: IFFALSE 41433
// continue ;
41431: GO 41415
// for p in tmp [ j ] do
41433: LD_ADDR_VAR 0 5
41437: PUSH
41438: LD_VAR 0 4
41442: PUSH
41443: LD_VAR 0 3
41447: ARRAY
41448: PUSH
41449: FOR_IN
41450: IFFALSE 41603
// begin if not b [ j ] then
41452: LD_VAR 0 6
41456: PUSH
41457: LD_VAR 0 3
41461: ARRAY
41462: NOT
41463: IFFALSE 41467
// break ;
41465: GO 41603
// e := 0 ;
41467: LD_ADDR_VAR 0 7
41471: PUSH
41472: LD_INT 0
41474: ST_TO_ADDR
// for k in b [ j ] do
41475: LD_ADDR_VAR 0 8
41479: PUSH
41480: LD_VAR 0 6
41484: PUSH
41485: LD_VAR 0 3
41489: ARRAY
41490: PUSH
41491: FOR_IN
41492: IFFALSE 41519
// if IsNotFull ( k ) then
41494: LD_VAR 0 8
41498: PPUSH
41499: CALL 69798 0 1
41503: IFFALSE 41517
// begin e := k ;
41505: LD_ADDR_VAR 0 7
41509: PUSH
41510: LD_VAR 0 8
41514: ST_TO_ADDR
// break ;
41515: GO 41519
// end ;
41517: GO 41491
41519: POP
41520: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41521: LD_VAR 0 7
41525: PUSH
41526: LD_VAR 0 5
41530: PPUSH
41531: LD_VAR 0 7
41535: PPUSH
41536: CALL 103694 0 2
41540: NOT
41541: AND
41542: IFFALSE 41601
// begin if IsInUnit ( p ) then
41544: LD_VAR 0 5
41548: PPUSH
41549: CALL_OW 310
41553: IFFALSE 41564
// ComExitBuilding ( p ) ;
41555: LD_VAR 0 5
41559: PPUSH
41560: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41564: LD_VAR 0 5
41568: PPUSH
41569: LD_VAR 0 7
41573: PPUSH
41574: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41578: LD_VAR 0 5
41582: PPUSH
41583: LD_VAR 0 3
41587: PPUSH
41588: CALL_OW 183
// AddComExitBuilding ( p ) ;
41592: LD_VAR 0 5
41596: PPUSH
41597: CALL_OW 182
// end ; end ;
41601: GO 41449
41603: POP
41604: POP
// end ;
41605: GO 41415
41607: POP
41608: POP
// end ;
41609: GO 41170
41611: POP
41612: POP
// end ;
41613: LD_VAR 0 1
41617: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41618: LD_INT 0
41620: PPUSH
41621: PPUSH
41622: PPUSH
41623: PPUSH
41624: PPUSH
41625: PPUSH
41626: PPUSH
41627: PPUSH
41628: PPUSH
41629: PPUSH
41630: PPUSH
41631: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41632: LD_VAR 0 1
41636: NOT
41637: PUSH
41638: LD_EXP 100
41642: PUSH
41643: LD_VAR 0 1
41647: ARRAY
41648: NOT
41649: OR
41650: PUSH
41651: LD_EXP 100
41655: PUSH
41656: LD_VAR 0 1
41660: ARRAY
41661: PPUSH
41662: LD_INT 2
41664: PUSH
41665: LD_INT 30
41667: PUSH
41668: LD_INT 0
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 30
41677: PUSH
41678: LD_INT 1
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: LIST
41689: PPUSH
41690: CALL_OW 72
41694: NOT
41695: OR
41696: IFFALSE 41700
// exit ;
41698: GO 45203
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41700: LD_ADDR_VAR 0 4
41704: PUSH
41705: LD_EXP 100
41709: PUSH
41710: LD_VAR 0 1
41714: ARRAY
41715: PPUSH
41716: LD_INT 2
41718: PUSH
41719: LD_INT 25
41721: PUSH
41722: LD_INT 1
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 25
41731: PUSH
41732: LD_INT 2
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 25
41741: PUSH
41742: LD_INT 3
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 25
41751: PUSH
41752: LD_INT 4
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 25
41761: PUSH
41762: LD_INT 5
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: LD_INT 25
41771: PUSH
41772: LD_INT 8
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PUSH
41779: LD_INT 25
41781: PUSH
41782: LD_INT 9
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: PPUSH
41799: CALL_OW 72
41803: ST_TO_ADDR
// if not tmp then
41804: LD_VAR 0 4
41808: NOT
41809: IFFALSE 41813
// exit ;
41811: GO 45203
// for i in tmp do
41813: LD_ADDR_VAR 0 3
41817: PUSH
41818: LD_VAR 0 4
41822: PUSH
41823: FOR_IN
41824: IFFALSE 41855
// if GetTag ( i ) then
41826: LD_VAR 0 3
41830: PPUSH
41831: CALL_OW 110
41835: IFFALSE 41853
// tmp := tmp diff i ;
41837: LD_ADDR_VAR 0 4
41841: PUSH
41842: LD_VAR 0 4
41846: PUSH
41847: LD_VAR 0 3
41851: DIFF
41852: ST_TO_ADDR
41853: GO 41823
41855: POP
41856: POP
// if not tmp then
41857: LD_VAR 0 4
41861: NOT
41862: IFFALSE 41866
// exit ;
41864: GO 45203
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41866: LD_ADDR_VAR 0 5
41870: PUSH
41871: LD_EXP 100
41875: PUSH
41876: LD_VAR 0 1
41880: ARRAY
41881: PPUSH
41882: LD_INT 2
41884: PUSH
41885: LD_INT 25
41887: PUSH
41888: LD_INT 1
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 25
41897: PUSH
41898: LD_INT 5
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 25
41907: PUSH
41908: LD_INT 8
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 25
41917: PUSH
41918: LD_INT 9
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: LIST
41929: LIST
41930: LIST
41931: PPUSH
41932: CALL_OW 72
41936: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41937: LD_ADDR_VAR 0 6
41941: PUSH
41942: LD_EXP 100
41946: PUSH
41947: LD_VAR 0 1
41951: ARRAY
41952: PPUSH
41953: LD_INT 25
41955: PUSH
41956: LD_INT 2
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PPUSH
41963: CALL_OW 72
41967: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41968: LD_ADDR_VAR 0 7
41972: PUSH
41973: LD_EXP 100
41977: PUSH
41978: LD_VAR 0 1
41982: ARRAY
41983: PPUSH
41984: LD_INT 25
41986: PUSH
41987: LD_INT 3
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PPUSH
41994: CALL_OW 72
41998: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41999: LD_ADDR_VAR 0 8
42003: PUSH
42004: LD_EXP 100
42008: PUSH
42009: LD_VAR 0 1
42013: ARRAY
42014: PPUSH
42015: LD_INT 25
42017: PUSH
42018: LD_INT 4
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 24
42027: PUSH
42028: LD_INT 251
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PPUSH
42039: CALL_OW 72
42043: ST_TO_ADDR
// if mc_is_defending [ base ] then
42044: LD_EXP 143
42048: PUSH
42049: LD_VAR 0 1
42053: ARRAY
42054: IFFALSE 42515
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
42056: LD_ADDR_EXP 142
42060: PUSH
42061: LD_EXP 142
42065: PPUSH
42066: LD_VAR 0 1
42070: PPUSH
42071: LD_INT 4
42073: PPUSH
42074: CALL_OW 1
42078: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42079: LD_ADDR_VAR 0 12
42083: PUSH
42084: LD_EXP 100
42088: PUSH
42089: LD_VAR 0 1
42093: ARRAY
42094: PPUSH
42095: LD_INT 2
42097: PUSH
42098: LD_INT 30
42100: PUSH
42101: LD_INT 4
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 30
42110: PUSH
42111: LD_INT 5
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: LIST
42122: PPUSH
42123: CALL_OW 72
42127: ST_TO_ADDR
// if not b then
42128: LD_VAR 0 12
42132: NOT
42133: IFFALSE 42137
// exit ;
42135: GO 45203
// p := [ ] ;
42137: LD_ADDR_VAR 0 11
42141: PUSH
42142: EMPTY
42143: ST_TO_ADDR
// if sci >= 2 then
42144: LD_VAR 0 8
42148: PUSH
42149: LD_INT 2
42151: GREATEREQUAL
42152: IFFALSE 42183
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
42154: LD_ADDR_VAR 0 8
42158: PUSH
42159: LD_VAR 0 8
42163: PUSH
42164: LD_INT 1
42166: ARRAY
42167: PUSH
42168: LD_VAR 0 8
42172: PUSH
42173: LD_INT 2
42175: ARRAY
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: ST_TO_ADDR
42181: GO 42244
// if sci = 1 then
42183: LD_VAR 0 8
42187: PUSH
42188: LD_INT 1
42190: EQUAL
42191: IFFALSE 42212
// sci := [ sci [ 1 ] ] else
42193: LD_ADDR_VAR 0 8
42197: PUSH
42198: LD_VAR 0 8
42202: PUSH
42203: LD_INT 1
42205: ARRAY
42206: PUSH
42207: EMPTY
42208: LIST
42209: ST_TO_ADDR
42210: GO 42244
// if sci = 0 then
42212: LD_VAR 0 8
42216: PUSH
42217: LD_INT 0
42219: EQUAL
42220: IFFALSE 42244
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
42222: LD_ADDR_VAR 0 11
42226: PUSH
42227: LD_VAR 0 4
42231: PPUSH
42232: LD_INT 4
42234: PPUSH
42235: CALL 103566 0 2
42239: PUSH
42240: LD_INT 1
42242: ARRAY
42243: ST_TO_ADDR
// if eng > 4 then
42244: LD_VAR 0 6
42248: PUSH
42249: LD_INT 4
42251: GREATER
42252: IFFALSE 42298
// for i = eng downto 4 do
42254: LD_ADDR_VAR 0 3
42258: PUSH
42259: DOUBLE
42260: LD_VAR 0 6
42264: INC
42265: ST_TO_ADDR
42266: LD_INT 4
42268: PUSH
42269: FOR_DOWNTO
42270: IFFALSE 42296
// eng := eng diff eng [ i ] ;
42272: LD_ADDR_VAR 0 6
42276: PUSH
42277: LD_VAR 0 6
42281: PUSH
42282: LD_VAR 0 6
42286: PUSH
42287: LD_VAR 0 3
42291: ARRAY
42292: DIFF
42293: ST_TO_ADDR
42294: GO 42269
42296: POP
42297: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
42298: LD_ADDR_VAR 0 4
42302: PUSH
42303: LD_VAR 0 4
42307: PUSH
42308: LD_VAR 0 5
42312: PUSH
42313: LD_VAR 0 6
42317: UNION
42318: PUSH
42319: LD_VAR 0 7
42323: UNION
42324: PUSH
42325: LD_VAR 0 8
42329: UNION
42330: DIFF
42331: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
42332: LD_ADDR_VAR 0 13
42336: PUSH
42337: LD_EXP 100
42341: PUSH
42342: LD_VAR 0 1
42346: ARRAY
42347: PPUSH
42348: LD_INT 2
42350: PUSH
42351: LD_INT 30
42353: PUSH
42354: LD_INT 32
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 30
42363: PUSH
42364: LD_INT 31
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: LIST
42375: PPUSH
42376: CALL_OW 72
42380: PUSH
42381: LD_EXP 100
42385: PUSH
42386: LD_VAR 0 1
42390: ARRAY
42391: PPUSH
42392: LD_INT 2
42394: PUSH
42395: LD_INT 30
42397: PUSH
42398: LD_INT 4
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 30
42407: PUSH
42408: LD_INT 5
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: LIST
42419: PPUSH
42420: CALL_OW 72
42424: PUSH
42425: LD_INT 6
42427: MUL
42428: PLUS
42429: ST_TO_ADDR
// if bcount < tmp then
42430: LD_VAR 0 13
42434: PUSH
42435: LD_VAR 0 4
42439: LESS
42440: IFFALSE 42486
// for i = tmp downto bcount do
42442: LD_ADDR_VAR 0 3
42446: PUSH
42447: DOUBLE
42448: LD_VAR 0 4
42452: INC
42453: ST_TO_ADDR
42454: LD_VAR 0 13
42458: PUSH
42459: FOR_DOWNTO
42460: IFFALSE 42484
// tmp := Delete ( tmp , tmp ) ;
42462: LD_ADDR_VAR 0 4
42466: PUSH
42467: LD_VAR 0 4
42471: PPUSH
42472: LD_VAR 0 4
42476: PPUSH
42477: CALL_OW 3
42481: ST_TO_ADDR
42482: GO 42459
42484: POP
42485: POP
// result := [ tmp , 0 , 0 , p ] ;
42486: LD_ADDR_VAR 0 2
42490: PUSH
42491: LD_VAR 0 4
42495: PUSH
42496: LD_INT 0
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: LD_VAR 0 11
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: LIST
42511: LIST
42512: ST_TO_ADDR
// exit ;
42513: GO 45203
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42515: LD_EXP 100
42519: PUSH
42520: LD_VAR 0 1
42524: ARRAY
42525: PPUSH
42526: LD_INT 2
42528: PUSH
42529: LD_INT 30
42531: PUSH
42532: LD_INT 6
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 30
42541: PUSH
42542: LD_INT 7
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 30
42551: PUSH
42552: LD_INT 8
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: PPUSH
42565: CALL_OW 72
42569: NOT
42570: PUSH
42571: LD_EXP 100
42575: PUSH
42576: LD_VAR 0 1
42580: ARRAY
42581: PPUSH
42582: LD_INT 30
42584: PUSH
42585: LD_INT 3
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PPUSH
42592: CALL_OW 72
42596: NOT
42597: AND
42598: IFFALSE 42670
// begin if eng = tmp then
42600: LD_VAR 0 6
42604: PUSH
42605: LD_VAR 0 4
42609: EQUAL
42610: IFFALSE 42614
// exit ;
42612: GO 45203
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42614: LD_ADDR_EXP 142
42618: PUSH
42619: LD_EXP 142
42623: PPUSH
42624: LD_VAR 0 1
42628: PPUSH
42629: LD_INT 1
42631: PPUSH
42632: CALL_OW 1
42636: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42637: LD_ADDR_VAR 0 2
42641: PUSH
42642: LD_INT 0
42644: PUSH
42645: LD_VAR 0 4
42649: PUSH
42650: LD_VAR 0 6
42654: DIFF
42655: PUSH
42656: LD_INT 0
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: ST_TO_ADDR
// exit ;
42668: GO 45203
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42670: LD_EXP 127
42674: PUSH
42675: LD_EXP 126
42679: PUSH
42680: LD_VAR 0 1
42684: ARRAY
42685: ARRAY
42686: PUSH
42687: LD_EXP 100
42691: PUSH
42692: LD_VAR 0 1
42696: ARRAY
42697: PPUSH
42698: LD_INT 2
42700: PUSH
42701: LD_INT 30
42703: PUSH
42704: LD_INT 6
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 30
42713: PUSH
42714: LD_INT 7
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 30
42723: PUSH
42724: LD_INT 8
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: PPUSH
42737: CALL_OW 72
42741: AND
42742: PUSH
42743: LD_EXP 100
42747: PUSH
42748: LD_VAR 0 1
42752: ARRAY
42753: PPUSH
42754: LD_INT 30
42756: PUSH
42757: LD_INT 3
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PPUSH
42764: CALL_OW 72
42768: NOT
42769: AND
42770: IFFALSE 42984
// begin if sci >= 6 then
42772: LD_VAR 0 8
42776: PUSH
42777: LD_INT 6
42779: GREATEREQUAL
42780: IFFALSE 42784
// exit ;
42782: GO 45203
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42784: LD_ADDR_EXP 142
42788: PUSH
42789: LD_EXP 142
42793: PPUSH
42794: LD_VAR 0 1
42798: PPUSH
42799: LD_INT 2
42801: PPUSH
42802: CALL_OW 1
42806: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42807: LD_ADDR_VAR 0 9
42811: PUSH
42812: LD_VAR 0 4
42816: PUSH
42817: LD_VAR 0 8
42821: DIFF
42822: PPUSH
42823: LD_INT 4
42825: PPUSH
42826: CALL 103566 0 2
42830: ST_TO_ADDR
// p := [ ] ;
42831: LD_ADDR_VAR 0 11
42835: PUSH
42836: EMPTY
42837: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42838: LD_VAR 0 8
42842: PUSH
42843: LD_INT 6
42845: LESS
42846: PUSH
42847: LD_VAR 0 9
42851: PUSH
42852: LD_INT 6
42854: GREATER
42855: AND
42856: IFFALSE 42937
// begin for i = 1 to 6 - sci do
42858: LD_ADDR_VAR 0 3
42862: PUSH
42863: DOUBLE
42864: LD_INT 1
42866: DEC
42867: ST_TO_ADDR
42868: LD_INT 6
42870: PUSH
42871: LD_VAR 0 8
42875: MINUS
42876: PUSH
42877: FOR_TO
42878: IFFALSE 42933
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42880: LD_ADDR_VAR 0 11
42884: PUSH
42885: LD_VAR 0 11
42889: PPUSH
42890: LD_VAR 0 11
42894: PUSH
42895: LD_INT 1
42897: PLUS
42898: PPUSH
42899: LD_VAR 0 9
42903: PUSH
42904: LD_INT 1
42906: ARRAY
42907: PPUSH
42908: CALL_OW 2
42912: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42913: LD_ADDR_VAR 0 9
42917: PUSH
42918: LD_VAR 0 9
42922: PPUSH
42923: LD_INT 1
42925: PPUSH
42926: CALL_OW 3
42930: ST_TO_ADDR
// end ;
42931: GO 42877
42933: POP
42934: POP
// end else
42935: GO 42957
// if sort then
42937: LD_VAR 0 9
42941: IFFALSE 42957
// p := sort [ 1 ] ;
42943: LD_ADDR_VAR 0 11
42947: PUSH
42948: LD_VAR 0 9
42952: PUSH
42953: LD_INT 1
42955: ARRAY
42956: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42957: LD_ADDR_VAR 0 2
42961: PUSH
42962: LD_INT 0
42964: PUSH
42965: LD_INT 0
42967: PUSH
42968: LD_INT 0
42970: PUSH
42971: LD_VAR 0 11
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: ST_TO_ADDR
// exit ;
42982: GO 45203
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42984: LD_EXP 127
42988: PUSH
42989: LD_EXP 126
42993: PUSH
42994: LD_VAR 0 1
42998: ARRAY
42999: ARRAY
43000: PUSH
43001: LD_EXP 100
43005: PUSH
43006: LD_VAR 0 1
43010: ARRAY
43011: PPUSH
43012: LD_INT 2
43014: PUSH
43015: LD_INT 30
43017: PUSH
43018: LD_INT 6
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 30
43027: PUSH
43028: LD_INT 7
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 30
43037: PUSH
43038: LD_INT 8
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: PPUSH
43051: CALL_OW 72
43055: AND
43056: PUSH
43057: LD_EXP 100
43061: PUSH
43062: LD_VAR 0 1
43066: ARRAY
43067: PPUSH
43068: LD_INT 30
43070: PUSH
43071: LD_INT 3
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PPUSH
43078: CALL_OW 72
43082: AND
43083: IFFALSE 43817
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
43085: LD_ADDR_EXP 142
43089: PUSH
43090: LD_EXP 142
43094: PPUSH
43095: LD_VAR 0 1
43099: PPUSH
43100: LD_INT 3
43102: PPUSH
43103: CALL_OW 1
43107: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43108: LD_ADDR_VAR 0 2
43112: PUSH
43113: LD_INT 0
43115: PUSH
43116: LD_INT 0
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: LD_INT 0
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: ST_TO_ADDR
// if not eng then
43131: LD_VAR 0 6
43135: NOT
43136: IFFALSE 43199
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
43138: LD_ADDR_VAR 0 11
43142: PUSH
43143: LD_VAR 0 4
43147: PPUSH
43148: LD_INT 2
43150: PPUSH
43151: CALL 103566 0 2
43155: PUSH
43156: LD_INT 1
43158: ARRAY
43159: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
43160: LD_ADDR_VAR 0 2
43164: PUSH
43165: LD_VAR 0 2
43169: PPUSH
43170: LD_INT 2
43172: PPUSH
43173: LD_VAR 0 11
43177: PPUSH
43178: CALL_OW 1
43182: ST_TO_ADDR
// tmp := tmp diff p ;
43183: LD_ADDR_VAR 0 4
43187: PUSH
43188: LD_VAR 0 4
43192: PUSH
43193: LD_VAR 0 11
43197: DIFF
43198: ST_TO_ADDR
// end ; if tmp and sci < 6 then
43199: LD_VAR 0 4
43203: PUSH
43204: LD_VAR 0 8
43208: PUSH
43209: LD_INT 6
43211: LESS
43212: AND
43213: IFFALSE 43401
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
43215: LD_ADDR_VAR 0 9
43219: PUSH
43220: LD_VAR 0 4
43224: PUSH
43225: LD_VAR 0 8
43229: PUSH
43230: LD_VAR 0 7
43234: UNION
43235: DIFF
43236: PPUSH
43237: LD_INT 4
43239: PPUSH
43240: CALL 103566 0 2
43244: ST_TO_ADDR
// p := [ ] ;
43245: LD_ADDR_VAR 0 11
43249: PUSH
43250: EMPTY
43251: ST_TO_ADDR
// if sort then
43252: LD_VAR 0 9
43256: IFFALSE 43372
// for i = 1 to 6 - sci do
43258: LD_ADDR_VAR 0 3
43262: PUSH
43263: DOUBLE
43264: LD_INT 1
43266: DEC
43267: ST_TO_ADDR
43268: LD_INT 6
43270: PUSH
43271: LD_VAR 0 8
43275: MINUS
43276: PUSH
43277: FOR_TO
43278: IFFALSE 43370
// begin if i = sort then
43280: LD_VAR 0 3
43284: PUSH
43285: LD_VAR 0 9
43289: EQUAL
43290: IFFALSE 43294
// break ;
43292: GO 43370
// if GetClass ( i ) = 4 then
43294: LD_VAR 0 3
43298: PPUSH
43299: CALL_OW 257
43303: PUSH
43304: LD_INT 4
43306: EQUAL
43307: IFFALSE 43311
// continue ;
43309: GO 43277
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43311: LD_ADDR_VAR 0 11
43315: PUSH
43316: LD_VAR 0 11
43320: PPUSH
43321: LD_VAR 0 11
43325: PUSH
43326: LD_INT 1
43328: PLUS
43329: PPUSH
43330: LD_VAR 0 9
43334: PUSH
43335: LD_VAR 0 3
43339: ARRAY
43340: PPUSH
43341: CALL_OW 2
43345: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43346: LD_ADDR_VAR 0 4
43350: PUSH
43351: LD_VAR 0 4
43355: PUSH
43356: LD_VAR 0 9
43360: PUSH
43361: LD_VAR 0 3
43365: ARRAY
43366: DIFF
43367: ST_TO_ADDR
// end ;
43368: GO 43277
43370: POP
43371: POP
// if p then
43372: LD_VAR 0 11
43376: IFFALSE 43401
// result := Replace ( result , 4 , p ) ;
43378: LD_ADDR_VAR 0 2
43382: PUSH
43383: LD_VAR 0 2
43387: PPUSH
43388: LD_INT 4
43390: PPUSH
43391: LD_VAR 0 11
43395: PPUSH
43396: CALL_OW 1
43400: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43401: LD_VAR 0 4
43405: PUSH
43406: LD_VAR 0 7
43410: PUSH
43411: LD_INT 6
43413: LESS
43414: AND
43415: IFFALSE 43603
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43417: LD_ADDR_VAR 0 9
43421: PUSH
43422: LD_VAR 0 4
43426: PUSH
43427: LD_VAR 0 8
43431: PUSH
43432: LD_VAR 0 7
43436: UNION
43437: DIFF
43438: PPUSH
43439: LD_INT 3
43441: PPUSH
43442: CALL 103566 0 2
43446: ST_TO_ADDR
// p := [ ] ;
43447: LD_ADDR_VAR 0 11
43451: PUSH
43452: EMPTY
43453: ST_TO_ADDR
// if sort then
43454: LD_VAR 0 9
43458: IFFALSE 43574
// for i = 1 to 6 - mech do
43460: LD_ADDR_VAR 0 3
43464: PUSH
43465: DOUBLE
43466: LD_INT 1
43468: DEC
43469: ST_TO_ADDR
43470: LD_INT 6
43472: PUSH
43473: LD_VAR 0 7
43477: MINUS
43478: PUSH
43479: FOR_TO
43480: IFFALSE 43572
// begin if i = sort then
43482: LD_VAR 0 3
43486: PUSH
43487: LD_VAR 0 9
43491: EQUAL
43492: IFFALSE 43496
// break ;
43494: GO 43572
// if GetClass ( i ) = 3 then
43496: LD_VAR 0 3
43500: PPUSH
43501: CALL_OW 257
43505: PUSH
43506: LD_INT 3
43508: EQUAL
43509: IFFALSE 43513
// continue ;
43511: GO 43479
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43513: LD_ADDR_VAR 0 11
43517: PUSH
43518: LD_VAR 0 11
43522: PPUSH
43523: LD_VAR 0 11
43527: PUSH
43528: LD_INT 1
43530: PLUS
43531: PPUSH
43532: LD_VAR 0 9
43536: PUSH
43537: LD_VAR 0 3
43541: ARRAY
43542: PPUSH
43543: CALL_OW 2
43547: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43548: LD_ADDR_VAR 0 4
43552: PUSH
43553: LD_VAR 0 4
43557: PUSH
43558: LD_VAR 0 9
43562: PUSH
43563: LD_VAR 0 3
43567: ARRAY
43568: DIFF
43569: ST_TO_ADDR
// end ;
43570: GO 43479
43572: POP
43573: POP
// if p then
43574: LD_VAR 0 11
43578: IFFALSE 43603
// result := Replace ( result , 3 , p ) ;
43580: LD_ADDR_VAR 0 2
43584: PUSH
43585: LD_VAR 0 2
43589: PPUSH
43590: LD_INT 3
43592: PPUSH
43593: LD_VAR 0 11
43597: PPUSH
43598: CALL_OW 1
43602: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43603: LD_VAR 0 4
43607: PUSH
43608: LD_INT 6
43610: GREATER
43611: PUSH
43612: LD_VAR 0 6
43616: PUSH
43617: LD_INT 6
43619: LESS
43620: AND
43621: IFFALSE 43815
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43623: LD_ADDR_VAR 0 9
43627: PUSH
43628: LD_VAR 0 4
43632: PUSH
43633: LD_VAR 0 8
43637: PUSH
43638: LD_VAR 0 7
43642: UNION
43643: PUSH
43644: LD_VAR 0 6
43648: UNION
43649: DIFF
43650: PPUSH
43651: LD_INT 2
43653: PPUSH
43654: CALL 103566 0 2
43658: ST_TO_ADDR
// p := [ ] ;
43659: LD_ADDR_VAR 0 11
43663: PUSH
43664: EMPTY
43665: ST_TO_ADDR
// if sort then
43666: LD_VAR 0 9
43670: IFFALSE 43786
// for i = 1 to 6 - eng do
43672: LD_ADDR_VAR 0 3
43676: PUSH
43677: DOUBLE
43678: LD_INT 1
43680: DEC
43681: ST_TO_ADDR
43682: LD_INT 6
43684: PUSH
43685: LD_VAR 0 6
43689: MINUS
43690: PUSH
43691: FOR_TO
43692: IFFALSE 43784
// begin if i = sort then
43694: LD_VAR 0 3
43698: PUSH
43699: LD_VAR 0 9
43703: EQUAL
43704: IFFALSE 43708
// break ;
43706: GO 43784
// if GetClass ( i ) = 2 then
43708: LD_VAR 0 3
43712: PPUSH
43713: CALL_OW 257
43717: PUSH
43718: LD_INT 2
43720: EQUAL
43721: IFFALSE 43725
// continue ;
43723: GO 43691
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43725: LD_ADDR_VAR 0 11
43729: PUSH
43730: LD_VAR 0 11
43734: PPUSH
43735: LD_VAR 0 11
43739: PUSH
43740: LD_INT 1
43742: PLUS
43743: PPUSH
43744: LD_VAR 0 9
43748: PUSH
43749: LD_VAR 0 3
43753: ARRAY
43754: PPUSH
43755: CALL_OW 2
43759: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43760: LD_ADDR_VAR 0 4
43764: PUSH
43765: LD_VAR 0 4
43769: PUSH
43770: LD_VAR 0 9
43774: PUSH
43775: LD_VAR 0 3
43779: ARRAY
43780: DIFF
43781: ST_TO_ADDR
// end ;
43782: GO 43691
43784: POP
43785: POP
// if p then
43786: LD_VAR 0 11
43790: IFFALSE 43815
// result := Replace ( result , 2 , p ) ;
43792: LD_ADDR_VAR 0 2
43796: PUSH
43797: LD_VAR 0 2
43801: PPUSH
43802: LD_INT 2
43804: PPUSH
43805: LD_VAR 0 11
43809: PPUSH
43810: CALL_OW 1
43814: ST_TO_ADDR
// end ; exit ;
43815: GO 45203
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43817: LD_EXP 127
43821: PUSH
43822: LD_EXP 126
43826: PUSH
43827: LD_VAR 0 1
43831: ARRAY
43832: ARRAY
43833: NOT
43834: PUSH
43835: LD_EXP 100
43839: PUSH
43840: LD_VAR 0 1
43844: ARRAY
43845: PPUSH
43846: LD_INT 30
43848: PUSH
43849: LD_INT 3
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PPUSH
43856: CALL_OW 72
43860: AND
43861: PUSH
43862: LD_EXP 105
43866: PUSH
43867: LD_VAR 0 1
43871: ARRAY
43872: AND
43873: IFFALSE 44481
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43875: LD_ADDR_EXP 142
43879: PUSH
43880: LD_EXP 142
43884: PPUSH
43885: LD_VAR 0 1
43889: PPUSH
43890: LD_INT 5
43892: PPUSH
43893: CALL_OW 1
43897: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43898: LD_ADDR_VAR 0 2
43902: PUSH
43903: LD_INT 0
43905: PUSH
43906: LD_INT 0
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: LD_INT 0
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: ST_TO_ADDR
// if sci > 1 then
43921: LD_VAR 0 8
43925: PUSH
43926: LD_INT 1
43928: GREATER
43929: IFFALSE 43957
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43931: LD_ADDR_VAR 0 4
43935: PUSH
43936: LD_VAR 0 4
43940: PUSH
43941: LD_VAR 0 8
43945: PUSH
43946: LD_VAR 0 8
43950: PUSH
43951: LD_INT 1
43953: ARRAY
43954: DIFF
43955: DIFF
43956: ST_TO_ADDR
// if tmp and not sci then
43957: LD_VAR 0 4
43961: PUSH
43962: LD_VAR 0 8
43966: NOT
43967: AND
43968: IFFALSE 44037
// begin sort := SortBySkill ( tmp , 4 ) ;
43970: LD_ADDR_VAR 0 9
43974: PUSH
43975: LD_VAR 0 4
43979: PPUSH
43980: LD_INT 4
43982: PPUSH
43983: CALL 103566 0 2
43987: ST_TO_ADDR
// if sort then
43988: LD_VAR 0 9
43992: IFFALSE 44008
// p := sort [ 1 ] ;
43994: LD_ADDR_VAR 0 11
43998: PUSH
43999: LD_VAR 0 9
44003: PUSH
44004: LD_INT 1
44006: ARRAY
44007: ST_TO_ADDR
// if p then
44008: LD_VAR 0 11
44012: IFFALSE 44037
// result := Replace ( result , 4 , p ) ;
44014: LD_ADDR_VAR 0 2
44018: PUSH
44019: LD_VAR 0 2
44023: PPUSH
44024: LD_INT 4
44026: PPUSH
44027: LD_VAR 0 11
44031: PPUSH
44032: CALL_OW 1
44036: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44037: LD_ADDR_VAR 0 4
44041: PUSH
44042: LD_VAR 0 4
44046: PUSH
44047: LD_VAR 0 7
44051: DIFF
44052: ST_TO_ADDR
// if tmp and mech < 6 then
44053: LD_VAR 0 4
44057: PUSH
44058: LD_VAR 0 7
44062: PUSH
44063: LD_INT 6
44065: LESS
44066: AND
44067: IFFALSE 44255
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44069: LD_ADDR_VAR 0 9
44073: PUSH
44074: LD_VAR 0 4
44078: PUSH
44079: LD_VAR 0 8
44083: PUSH
44084: LD_VAR 0 7
44088: UNION
44089: DIFF
44090: PPUSH
44091: LD_INT 3
44093: PPUSH
44094: CALL 103566 0 2
44098: ST_TO_ADDR
// p := [ ] ;
44099: LD_ADDR_VAR 0 11
44103: PUSH
44104: EMPTY
44105: ST_TO_ADDR
// if sort then
44106: LD_VAR 0 9
44110: IFFALSE 44226
// for i = 1 to 6 - mech do
44112: LD_ADDR_VAR 0 3
44116: PUSH
44117: DOUBLE
44118: LD_INT 1
44120: DEC
44121: ST_TO_ADDR
44122: LD_INT 6
44124: PUSH
44125: LD_VAR 0 7
44129: MINUS
44130: PUSH
44131: FOR_TO
44132: IFFALSE 44224
// begin if i = sort then
44134: LD_VAR 0 3
44138: PUSH
44139: LD_VAR 0 9
44143: EQUAL
44144: IFFALSE 44148
// break ;
44146: GO 44224
// if GetClass ( i ) = 3 then
44148: LD_VAR 0 3
44152: PPUSH
44153: CALL_OW 257
44157: PUSH
44158: LD_INT 3
44160: EQUAL
44161: IFFALSE 44165
// continue ;
44163: GO 44131
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44165: LD_ADDR_VAR 0 11
44169: PUSH
44170: LD_VAR 0 11
44174: PPUSH
44175: LD_VAR 0 11
44179: PUSH
44180: LD_INT 1
44182: PLUS
44183: PPUSH
44184: LD_VAR 0 9
44188: PUSH
44189: LD_VAR 0 3
44193: ARRAY
44194: PPUSH
44195: CALL_OW 2
44199: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44200: LD_ADDR_VAR 0 4
44204: PUSH
44205: LD_VAR 0 4
44209: PUSH
44210: LD_VAR 0 9
44214: PUSH
44215: LD_VAR 0 3
44219: ARRAY
44220: DIFF
44221: ST_TO_ADDR
// end ;
44222: GO 44131
44224: POP
44225: POP
// if p then
44226: LD_VAR 0 11
44230: IFFALSE 44255
// result := Replace ( result , 3 , p ) ;
44232: LD_ADDR_VAR 0 2
44236: PUSH
44237: LD_VAR 0 2
44241: PPUSH
44242: LD_INT 3
44244: PPUSH
44245: LD_VAR 0 11
44249: PPUSH
44250: CALL_OW 1
44254: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44255: LD_ADDR_VAR 0 4
44259: PUSH
44260: LD_VAR 0 4
44264: PUSH
44265: LD_VAR 0 6
44269: DIFF
44270: ST_TO_ADDR
// if tmp and eng < 6 then
44271: LD_VAR 0 4
44275: PUSH
44276: LD_VAR 0 6
44280: PUSH
44281: LD_INT 6
44283: LESS
44284: AND
44285: IFFALSE 44479
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44287: LD_ADDR_VAR 0 9
44291: PUSH
44292: LD_VAR 0 4
44296: PUSH
44297: LD_VAR 0 8
44301: PUSH
44302: LD_VAR 0 7
44306: UNION
44307: PUSH
44308: LD_VAR 0 6
44312: UNION
44313: DIFF
44314: PPUSH
44315: LD_INT 2
44317: PPUSH
44318: CALL 103566 0 2
44322: ST_TO_ADDR
// p := [ ] ;
44323: LD_ADDR_VAR 0 11
44327: PUSH
44328: EMPTY
44329: ST_TO_ADDR
// if sort then
44330: LD_VAR 0 9
44334: IFFALSE 44450
// for i = 1 to 6 - eng do
44336: LD_ADDR_VAR 0 3
44340: PUSH
44341: DOUBLE
44342: LD_INT 1
44344: DEC
44345: ST_TO_ADDR
44346: LD_INT 6
44348: PUSH
44349: LD_VAR 0 6
44353: MINUS
44354: PUSH
44355: FOR_TO
44356: IFFALSE 44448
// begin if i = sort then
44358: LD_VAR 0 3
44362: PUSH
44363: LD_VAR 0 9
44367: EQUAL
44368: IFFALSE 44372
// break ;
44370: GO 44448
// if GetClass ( i ) = 2 then
44372: LD_VAR 0 3
44376: PPUSH
44377: CALL_OW 257
44381: PUSH
44382: LD_INT 2
44384: EQUAL
44385: IFFALSE 44389
// continue ;
44387: GO 44355
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44389: LD_ADDR_VAR 0 11
44393: PUSH
44394: LD_VAR 0 11
44398: PPUSH
44399: LD_VAR 0 11
44403: PUSH
44404: LD_INT 1
44406: PLUS
44407: PPUSH
44408: LD_VAR 0 9
44412: PUSH
44413: LD_VAR 0 3
44417: ARRAY
44418: PPUSH
44419: CALL_OW 2
44423: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44424: LD_ADDR_VAR 0 4
44428: PUSH
44429: LD_VAR 0 4
44433: PUSH
44434: LD_VAR 0 9
44438: PUSH
44439: LD_VAR 0 3
44443: ARRAY
44444: DIFF
44445: ST_TO_ADDR
// end ;
44446: GO 44355
44448: POP
44449: POP
// if p then
44450: LD_VAR 0 11
44454: IFFALSE 44479
// result := Replace ( result , 2 , p ) ;
44456: LD_ADDR_VAR 0 2
44460: PUSH
44461: LD_VAR 0 2
44465: PPUSH
44466: LD_INT 2
44468: PPUSH
44469: LD_VAR 0 11
44473: PPUSH
44474: CALL_OW 1
44478: ST_TO_ADDR
// end ; exit ;
44479: GO 45203
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44481: LD_EXP 127
44485: PUSH
44486: LD_EXP 126
44490: PUSH
44491: LD_VAR 0 1
44495: ARRAY
44496: ARRAY
44497: NOT
44498: PUSH
44499: LD_EXP 100
44503: PUSH
44504: LD_VAR 0 1
44508: ARRAY
44509: PPUSH
44510: LD_INT 30
44512: PUSH
44513: LD_INT 3
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PPUSH
44520: CALL_OW 72
44524: AND
44525: PUSH
44526: LD_EXP 105
44530: PUSH
44531: LD_VAR 0 1
44535: ARRAY
44536: NOT
44537: AND
44538: IFFALSE 45203
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44540: LD_ADDR_EXP 142
44544: PUSH
44545: LD_EXP 142
44549: PPUSH
44550: LD_VAR 0 1
44554: PPUSH
44555: LD_INT 6
44557: PPUSH
44558: CALL_OW 1
44562: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44563: LD_ADDR_VAR 0 2
44567: PUSH
44568: LD_INT 0
44570: PUSH
44571: LD_INT 0
44573: PUSH
44574: LD_INT 0
44576: PUSH
44577: LD_INT 0
44579: PUSH
44580: EMPTY
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: ST_TO_ADDR
// if sci >= 1 then
44586: LD_VAR 0 8
44590: PUSH
44591: LD_INT 1
44593: GREATEREQUAL
44594: IFFALSE 44616
// tmp := tmp diff sci [ 1 ] ;
44596: LD_ADDR_VAR 0 4
44600: PUSH
44601: LD_VAR 0 4
44605: PUSH
44606: LD_VAR 0 8
44610: PUSH
44611: LD_INT 1
44613: ARRAY
44614: DIFF
44615: ST_TO_ADDR
// if tmp and not sci then
44616: LD_VAR 0 4
44620: PUSH
44621: LD_VAR 0 8
44625: NOT
44626: AND
44627: IFFALSE 44696
// begin sort := SortBySkill ( tmp , 4 ) ;
44629: LD_ADDR_VAR 0 9
44633: PUSH
44634: LD_VAR 0 4
44638: PPUSH
44639: LD_INT 4
44641: PPUSH
44642: CALL 103566 0 2
44646: ST_TO_ADDR
// if sort then
44647: LD_VAR 0 9
44651: IFFALSE 44667
// p := sort [ 1 ] ;
44653: LD_ADDR_VAR 0 11
44657: PUSH
44658: LD_VAR 0 9
44662: PUSH
44663: LD_INT 1
44665: ARRAY
44666: ST_TO_ADDR
// if p then
44667: LD_VAR 0 11
44671: IFFALSE 44696
// result := Replace ( result , 4 , p ) ;
44673: LD_ADDR_VAR 0 2
44677: PUSH
44678: LD_VAR 0 2
44682: PPUSH
44683: LD_INT 4
44685: PPUSH
44686: LD_VAR 0 11
44690: PPUSH
44691: CALL_OW 1
44695: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44696: LD_ADDR_VAR 0 4
44700: PUSH
44701: LD_VAR 0 4
44705: PUSH
44706: LD_VAR 0 7
44710: DIFF
44711: ST_TO_ADDR
// if tmp and mech < 6 then
44712: LD_VAR 0 4
44716: PUSH
44717: LD_VAR 0 7
44721: PUSH
44722: LD_INT 6
44724: LESS
44725: AND
44726: IFFALSE 44908
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44728: LD_ADDR_VAR 0 9
44732: PUSH
44733: LD_VAR 0 4
44737: PUSH
44738: LD_VAR 0 7
44742: DIFF
44743: PPUSH
44744: LD_INT 3
44746: PPUSH
44747: CALL 103566 0 2
44751: ST_TO_ADDR
// p := [ ] ;
44752: LD_ADDR_VAR 0 11
44756: PUSH
44757: EMPTY
44758: ST_TO_ADDR
// if sort then
44759: LD_VAR 0 9
44763: IFFALSE 44879
// for i = 1 to 6 - mech do
44765: LD_ADDR_VAR 0 3
44769: PUSH
44770: DOUBLE
44771: LD_INT 1
44773: DEC
44774: ST_TO_ADDR
44775: LD_INT 6
44777: PUSH
44778: LD_VAR 0 7
44782: MINUS
44783: PUSH
44784: FOR_TO
44785: IFFALSE 44877
// begin if i = sort then
44787: LD_VAR 0 3
44791: PUSH
44792: LD_VAR 0 9
44796: EQUAL
44797: IFFALSE 44801
// break ;
44799: GO 44877
// if GetClass ( i ) = 3 then
44801: LD_VAR 0 3
44805: PPUSH
44806: CALL_OW 257
44810: PUSH
44811: LD_INT 3
44813: EQUAL
44814: IFFALSE 44818
// continue ;
44816: GO 44784
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44818: LD_ADDR_VAR 0 11
44822: PUSH
44823: LD_VAR 0 11
44827: PPUSH
44828: LD_VAR 0 11
44832: PUSH
44833: LD_INT 1
44835: PLUS
44836: PPUSH
44837: LD_VAR 0 9
44841: PUSH
44842: LD_VAR 0 3
44846: ARRAY
44847: PPUSH
44848: CALL_OW 2
44852: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44853: LD_ADDR_VAR 0 4
44857: PUSH
44858: LD_VAR 0 4
44862: PUSH
44863: LD_VAR 0 9
44867: PUSH
44868: LD_VAR 0 3
44872: ARRAY
44873: DIFF
44874: ST_TO_ADDR
// end ;
44875: GO 44784
44877: POP
44878: POP
// if p then
44879: LD_VAR 0 11
44883: IFFALSE 44908
// result := Replace ( result , 3 , p ) ;
44885: LD_ADDR_VAR 0 2
44889: PUSH
44890: LD_VAR 0 2
44894: PPUSH
44895: LD_INT 3
44897: PPUSH
44898: LD_VAR 0 11
44902: PPUSH
44903: CALL_OW 1
44907: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44908: LD_ADDR_VAR 0 4
44912: PUSH
44913: LD_VAR 0 4
44917: PUSH
44918: LD_VAR 0 6
44922: DIFF
44923: ST_TO_ADDR
// if tmp and eng < 4 then
44924: LD_VAR 0 4
44928: PUSH
44929: LD_VAR 0 6
44933: PUSH
44934: LD_INT 4
44936: LESS
44937: AND
44938: IFFALSE 45128
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44940: LD_ADDR_VAR 0 9
44944: PUSH
44945: LD_VAR 0 4
44949: PUSH
44950: LD_VAR 0 7
44954: PUSH
44955: LD_VAR 0 6
44959: UNION
44960: DIFF
44961: PPUSH
44962: LD_INT 2
44964: PPUSH
44965: CALL 103566 0 2
44969: ST_TO_ADDR
// p := [ ] ;
44970: LD_ADDR_VAR 0 11
44974: PUSH
44975: EMPTY
44976: ST_TO_ADDR
// if sort then
44977: LD_VAR 0 9
44981: IFFALSE 45097
// for i = 1 to 4 - eng do
44983: LD_ADDR_VAR 0 3
44987: PUSH
44988: DOUBLE
44989: LD_INT 1
44991: DEC
44992: ST_TO_ADDR
44993: LD_INT 4
44995: PUSH
44996: LD_VAR 0 6
45000: MINUS
45001: PUSH
45002: FOR_TO
45003: IFFALSE 45095
// begin if i = sort then
45005: LD_VAR 0 3
45009: PUSH
45010: LD_VAR 0 9
45014: EQUAL
45015: IFFALSE 45019
// break ;
45017: GO 45095
// if GetClass ( i ) = 2 then
45019: LD_VAR 0 3
45023: PPUSH
45024: CALL_OW 257
45028: PUSH
45029: LD_INT 2
45031: EQUAL
45032: IFFALSE 45036
// continue ;
45034: GO 45002
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45036: LD_ADDR_VAR 0 11
45040: PUSH
45041: LD_VAR 0 11
45045: PPUSH
45046: LD_VAR 0 11
45050: PUSH
45051: LD_INT 1
45053: PLUS
45054: PPUSH
45055: LD_VAR 0 9
45059: PUSH
45060: LD_VAR 0 3
45064: ARRAY
45065: PPUSH
45066: CALL_OW 2
45070: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45071: LD_ADDR_VAR 0 4
45075: PUSH
45076: LD_VAR 0 4
45080: PUSH
45081: LD_VAR 0 9
45085: PUSH
45086: LD_VAR 0 3
45090: ARRAY
45091: DIFF
45092: ST_TO_ADDR
// end ;
45093: GO 45002
45095: POP
45096: POP
// if p then
45097: LD_VAR 0 11
45101: IFFALSE 45126
// result := Replace ( result , 2 , p ) ;
45103: LD_ADDR_VAR 0 2
45107: PUSH
45108: LD_VAR 0 2
45112: PPUSH
45113: LD_INT 2
45115: PPUSH
45116: LD_VAR 0 11
45120: PPUSH
45121: CALL_OW 1
45125: ST_TO_ADDR
// end else
45126: GO 45172
// for i = eng downto 5 do
45128: LD_ADDR_VAR 0 3
45132: PUSH
45133: DOUBLE
45134: LD_VAR 0 6
45138: INC
45139: ST_TO_ADDR
45140: LD_INT 5
45142: PUSH
45143: FOR_DOWNTO
45144: IFFALSE 45170
// tmp := tmp union eng [ i ] ;
45146: LD_ADDR_VAR 0 4
45150: PUSH
45151: LD_VAR 0 4
45155: PUSH
45156: LD_VAR 0 6
45160: PUSH
45161: LD_VAR 0 3
45165: ARRAY
45166: UNION
45167: ST_TO_ADDR
45168: GO 45143
45170: POP
45171: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
45172: LD_ADDR_VAR 0 2
45176: PUSH
45177: LD_VAR 0 2
45181: PPUSH
45182: LD_INT 1
45184: PPUSH
45185: LD_VAR 0 4
45189: PUSH
45190: LD_VAR 0 5
45194: DIFF
45195: PPUSH
45196: CALL_OW 1
45200: ST_TO_ADDR
// exit ;
45201: GO 45203
// end ; end ;
45203: LD_VAR 0 2
45207: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
45208: LD_INT 0
45210: PPUSH
45211: PPUSH
45212: PPUSH
// if not mc_bases then
45213: LD_EXP 100
45217: NOT
45218: IFFALSE 45222
// exit ;
45220: GO 45364
// for i = 1 to mc_bases do
45222: LD_ADDR_VAR 0 2
45226: PUSH
45227: DOUBLE
45228: LD_INT 1
45230: DEC
45231: ST_TO_ADDR
45232: LD_EXP 100
45236: PUSH
45237: FOR_TO
45238: IFFALSE 45355
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
45240: LD_ADDR_VAR 0 3
45244: PUSH
45245: LD_EXP 100
45249: PUSH
45250: LD_VAR 0 2
45254: ARRAY
45255: PPUSH
45256: LD_INT 21
45258: PUSH
45259: LD_INT 3
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 3
45268: PUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 30
45274: PUSH
45275: LD_INT 29
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 30
45284: PUSH
45285: LD_INT 30
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 3
45303: PUSH
45304: LD_INT 24
45306: PUSH
45307: LD_INT 1000
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: LIST
45322: PPUSH
45323: CALL_OW 72
45327: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
45328: LD_ADDR_EXP 101
45332: PUSH
45333: LD_EXP 101
45337: PPUSH
45338: LD_VAR 0 2
45342: PPUSH
45343: LD_VAR 0 3
45347: PPUSH
45348: CALL_OW 1
45352: ST_TO_ADDR
// end ;
45353: GO 45237
45355: POP
45356: POP
// RaiseSailEvent ( 101 ) ;
45357: LD_INT 101
45359: PPUSH
45360: CALL_OW 427
// end ;
45364: LD_VAR 0 1
45368: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45369: LD_INT 0
45371: PPUSH
45372: PPUSH
45373: PPUSH
45374: PPUSH
45375: PPUSH
45376: PPUSH
45377: PPUSH
// if not mc_bases then
45378: LD_EXP 100
45382: NOT
45383: IFFALSE 45387
// exit ;
45385: GO 45949
// for i = 1 to mc_bases do
45387: LD_ADDR_VAR 0 2
45391: PUSH
45392: DOUBLE
45393: LD_INT 1
45395: DEC
45396: ST_TO_ADDR
45397: LD_EXP 100
45401: PUSH
45402: FOR_TO
45403: IFFALSE 45940
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45405: LD_ADDR_VAR 0 5
45409: PUSH
45410: LD_EXP 100
45414: PUSH
45415: LD_VAR 0 2
45419: ARRAY
45420: PUSH
45421: LD_EXP 129
45425: PUSH
45426: LD_VAR 0 2
45430: ARRAY
45431: UNION
45432: PPUSH
45433: LD_INT 21
45435: PUSH
45436: LD_INT 1
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 1
45445: PUSH
45446: LD_INT 3
45448: PUSH
45449: LD_INT 54
45451: PUSH
45452: EMPTY
45453: LIST
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: LD_INT 24
45464: PUSH
45465: LD_INT 1000
45467: PUSH
45468: EMPTY
45469: LIST
45470: LIST
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: LIST
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PPUSH
45485: CALL_OW 72
45489: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45490: LD_ADDR_VAR 0 6
45494: PUSH
45495: LD_EXP 100
45499: PUSH
45500: LD_VAR 0 2
45504: ARRAY
45505: PPUSH
45506: LD_INT 21
45508: PUSH
45509: LD_INT 1
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: PUSH
45516: LD_INT 1
45518: PUSH
45519: LD_INT 3
45521: PUSH
45522: LD_INT 54
45524: PUSH
45525: EMPTY
45526: LIST
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: LD_INT 3
45534: PUSH
45535: LD_INT 24
45537: PUSH
45538: LD_INT 250
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: LIST
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: PPUSH
45558: CALL_OW 72
45562: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45563: LD_ADDR_VAR 0 7
45567: PUSH
45568: LD_VAR 0 5
45572: PUSH
45573: LD_VAR 0 6
45577: DIFF
45578: ST_TO_ADDR
// if not need_heal_1 then
45579: LD_VAR 0 6
45583: NOT
45584: IFFALSE 45617
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45586: LD_ADDR_EXP 103
45590: PUSH
45591: LD_EXP 103
45595: PPUSH
45596: LD_VAR 0 2
45600: PUSH
45601: LD_INT 1
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: EMPTY
45609: PPUSH
45610: CALL 72719 0 3
45614: ST_TO_ADDR
45615: GO 45687
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45617: LD_ADDR_EXP 103
45621: PUSH
45622: LD_EXP 103
45626: PPUSH
45627: LD_VAR 0 2
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PPUSH
45639: LD_EXP 103
45643: PUSH
45644: LD_VAR 0 2
45648: ARRAY
45649: PUSH
45650: LD_INT 1
45652: ARRAY
45653: PPUSH
45654: LD_INT 3
45656: PUSH
45657: LD_INT 24
45659: PUSH
45660: LD_INT 1000
45662: PUSH
45663: EMPTY
45664: LIST
45665: LIST
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PPUSH
45671: CALL_OW 72
45675: PUSH
45676: LD_VAR 0 6
45680: UNION
45681: PPUSH
45682: CALL 72719 0 3
45686: ST_TO_ADDR
// if not need_heal_2 then
45687: LD_VAR 0 7
45691: NOT
45692: IFFALSE 45725
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45694: LD_ADDR_EXP 103
45698: PUSH
45699: LD_EXP 103
45703: PPUSH
45704: LD_VAR 0 2
45708: PUSH
45709: LD_INT 2
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PPUSH
45716: EMPTY
45717: PPUSH
45718: CALL 72719 0 3
45722: ST_TO_ADDR
45723: GO 45757
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45725: LD_ADDR_EXP 103
45729: PUSH
45730: LD_EXP 103
45734: PPUSH
45735: LD_VAR 0 2
45739: PUSH
45740: LD_INT 2
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PPUSH
45747: LD_VAR 0 7
45751: PPUSH
45752: CALL 72719 0 3
45756: ST_TO_ADDR
// if need_heal_2 then
45757: LD_VAR 0 7
45761: IFFALSE 45922
// for j in need_heal_2 do
45763: LD_ADDR_VAR 0 3
45767: PUSH
45768: LD_VAR 0 7
45772: PUSH
45773: FOR_IN
45774: IFFALSE 45920
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45776: LD_ADDR_VAR 0 5
45780: PUSH
45781: LD_EXP 100
45785: PUSH
45786: LD_VAR 0 2
45790: ARRAY
45791: PPUSH
45792: LD_INT 2
45794: PUSH
45795: LD_INT 30
45797: PUSH
45798: LD_INT 6
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 30
45807: PUSH
45808: LD_INT 7
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 30
45817: PUSH
45818: LD_INT 8
45820: PUSH
45821: EMPTY
45822: LIST
45823: LIST
45824: PUSH
45825: LD_INT 30
45827: PUSH
45828: LD_INT 0
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: PUSH
45835: LD_INT 30
45837: PUSH
45838: LD_INT 1
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: PPUSH
45853: CALL_OW 72
45857: ST_TO_ADDR
// if tmp then
45858: LD_VAR 0 5
45862: IFFALSE 45918
// begin k := NearestUnitToUnit ( tmp , j ) ;
45864: LD_ADDR_VAR 0 4
45868: PUSH
45869: LD_VAR 0 5
45873: PPUSH
45874: LD_VAR 0 3
45878: PPUSH
45879: CALL_OW 74
45883: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45884: LD_VAR 0 3
45888: PPUSH
45889: LD_VAR 0 4
45893: PPUSH
45894: CALL_OW 296
45898: PUSH
45899: LD_INT 5
45901: GREATER
45902: IFFALSE 45918
// ComMoveToNearbyEntrance ( j , k ) ;
45904: LD_VAR 0 3
45908: PPUSH
45909: LD_VAR 0 4
45913: PPUSH
45914: CALL 105927 0 2
// end ; end ;
45918: GO 45773
45920: POP
45921: POP
// if not need_heal_1 and not need_heal_2 then
45922: LD_VAR 0 6
45926: NOT
45927: PUSH
45928: LD_VAR 0 7
45932: NOT
45933: AND
45934: IFFALSE 45938
// continue ;
45936: GO 45402
// end ;
45938: GO 45402
45940: POP
45941: POP
// RaiseSailEvent ( 102 ) ;
45942: LD_INT 102
45944: PPUSH
45945: CALL_OW 427
// end ;
45949: LD_VAR 0 1
45953: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45954: LD_INT 0
45956: PPUSH
45957: PPUSH
45958: PPUSH
45959: PPUSH
45960: PPUSH
45961: PPUSH
45962: PPUSH
45963: PPUSH
// if not mc_bases then
45964: LD_EXP 100
45968: NOT
45969: IFFALSE 45973
// exit ;
45971: GO 46884
// for i = 1 to mc_bases do
45973: LD_ADDR_VAR 0 2
45977: PUSH
45978: DOUBLE
45979: LD_INT 1
45981: DEC
45982: ST_TO_ADDR
45983: LD_EXP 100
45987: PUSH
45988: FOR_TO
45989: IFFALSE 46882
// begin if not mc_building_need_repair [ i ] then
45991: LD_EXP 101
45995: PUSH
45996: LD_VAR 0 2
46000: ARRAY
46001: NOT
46002: IFFALSE 46187
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
46004: LD_ADDR_VAR 0 6
46008: PUSH
46009: LD_EXP 119
46013: PUSH
46014: LD_VAR 0 2
46018: ARRAY
46019: PPUSH
46020: LD_INT 3
46022: PUSH
46023: LD_INT 24
46025: PUSH
46026: LD_INT 1000
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 2
46039: PUSH
46040: LD_INT 34
46042: PUSH
46043: LD_INT 13
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 34
46052: PUSH
46053: LD_INT 52
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 34
46062: PUSH
46063: LD_INT 88
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PPUSH
46080: CALL_OW 72
46084: ST_TO_ADDR
// if cranes then
46085: LD_VAR 0 6
46089: IFFALSE 46151
// for j in cranes do
46091: LD_ADDR_VAR 0 3
46095: PUSH
46096: LD_VAR 0 6
46100: PUSH
46101: FOR_IN
46102: IFFALSE 46149
// if not IsInArea ( j , mc_parking [ i ] ) then
46104: LD_VAR 0 3
46108: PPUSH
46109: LD_EXP 124
46113: PUSH
46114: LD_VAR 0 2
46118: ARRAY
46119: PPUSH
46120: CALL_OW 308
46124: NOT
46125: IFFALSE 46147
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46127: LD_VAR 0 3
46131: PPUSH
46132: LD_EXP 124
46136: PUSH
46137: LD_VAR 0 2
46141: ARRAY
46142: PPUSH
46143: CALL_OW 113
46147: GO 46101
46149: POP
46150: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
46151: LD_ADDR_EXP 102
46155: PUSH
46156: LD_EXP 102
46160: PPUSH
46161: LD_VAR 0 2
46165: PPUSH
46166: EMPTY
46167: PPUSH
46168: CALL_OW 1
46172: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
46173: LD_VAR 0 2
46177: PPUSH
46178: LD_INT 101
46180: PPUSH
46181: CALL 41041 0 2
// continue ;
46185: GO 45988
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
46187: LD_ADDR_EXP 106
46191: PUSH
46192: LD_EXP 106
46196: PPUSH
46197: LD_VAR 0 2
46201: PPUSH
46202: EMPTY
46203: PPUSH
46204: CALL_OW 1
46208: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
46209: LD_VAR 0 2
46213: PPUSH
46214: LD_INT 103
46216: PPUSH
46217: CALL 41041 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
46221: LD_ADDR_VAR 0 5
46225: PUSH
46226: LD_EXP 100
46230: PUSH
46231: LD_VAR 0 2
46235: ARRAY
46236: PUSH
46237: LD_EXP 129
46241: PUSH
46242: LD_VAR 0 2
46246: ARRAY
46247: UNION
46248: PPUSH
46249: LD_INT 2
46251: PUSH
46252: LD_INT 25
46254: PUSH
46255: LD_INT 2
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 25
46264: PUSH
46265: LD_INT 16
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: LIST
46276: PUSH
46277: EMPTY
46278: LIST
46279: PPUSH
46280: CALL_OW 72
46284: ST_TO_ADDR
// if mc_need_heal [ i ] then
46285: LD_EXP 103
46289: PUSH
46290: LD_VAR 0 2
46294: ARRAY
46295: IFFALSE 46339
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
46297: LD_ADDR_VAR 0 5
46301: PUSH
46302: LD_VAR 0 5
46306: PUSH
46307: LD_EXP 103
46311: PUSH
46312: LD_VAR 0 2
46316: ARRAY
46317: PUSH
46318: LD_INT 1
46320: ARRAY
46321: PUSH
46322: LD_EXP 103
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_INT 2
46335: ARRAY
46336: UNION
46337: DIFF
46338: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
46339: LD_ADDR_VAR 0 6
46343: PUSH
46344: LD_EXP 119
46348: PUSH
46349: LD_VAR 0 2
46353: ARRAY
46354: PPUSH
46355: LD_INT 2
46357: PUSH
46358: LD_INT 34
46360: PUSH
46361: LD_INT 13
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 34
46370: PUSH
46371: LD_INT 52
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 34
46380: PUSH
46381: LD_INT 88
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: PPUSH
46394: CALL_OW 72
46398: ST_TO_ADDR
// if cranes then
46399: LD_VAR 0 6
46403: IFFALSE 46571
// begin for j in cranes do
46405: LD_ADDR_VAR 0 3
46409: PUSH
46410: LD_VAR 0 6
46414: PUSH
46415: FOR_IN
46416: IFFALSE 46569
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46418: LD_VAR 0 3
46422: PPUSH
46423: CALL_OW 256
46427: PUSH
46428: LD_INT 1000
46430: EQUAL
46431: PUSH
46432: LD_VAR 0 3
46436: PPUSH
46437: CALL_OW 314
46441: NOT
46442: AND
46443: IFFALSE 46509
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46445: LD_ADDR_VAR 0 8
46449: PUSH
46450: LD_EXP 101
46454: PUSH
46455: LD_VAR 0 2
46459: ARRAY
46460: PPUSH
46461: LD_VAR 0 3
46465: PPUSH
46466: CALL_OW 74
46470: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46471: LD_VAR 0 8
46475: PPUSH
46476: LD_INT 16
46478: PPUSH
46479: CALL 75316 0 2
46483: PUSH
46484: LD_INT 4
46486: ARRAY
46487: PUSH
46488: LD_INT 10
46490: LESS
46491: IFFALSE 46507
// ComRepairBuilding ( j , to_repair ) ;
46493: LD_VAR 0 3
46497: PPUSH
46498: LD_VAR 0 8
46502: PPUSH
46503: CALL_OW 130
// end else
46507: GO 46567
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46509: LD_VAR 0 3
46513: PPUSH
46514: CALL_OW 256
46518: PUSH
46519: LD_INT 500
46521: LESS
46522: PUSH
46523: LD_VAR 0 3
46527: PPUSH
46528: LD_EXP 124
46532: PUSH
46533: LD_VAR 0 2
46537: ARRAY
46538: PPUSH
46539: CALL_OW 308
46543: NOT
46544: AND
46545: IFFALSE 46567
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46547: LD_VAR 0 3
46551: PPUSH
46552: LD_EXP 124
46556: PUSH
46557: LD_VAR 0 2
46561: ARRAY
46562: PPUSH
46563: CALL_OW 113
// end ;
46567: GO 46415
46569: POP
46570: POP
// end ; if tmp > 3 then
46571: LD_VAR 0 5
46575: PUSH
46576: LD_INT 3
46578: GREATER
46579: IFFALSE 46599
// tmp := ShrinkArray ( tmp , 4 ) ;
46581: LD_ADDR_VAR 0 5
46585: PUSH
46586: LD_VAR 0 5
46590: PPUSH
46591: LD_INT 4
46593: PPUSH
46594: CALL 105365 0 2
46598: ST_TO_ADDR
// if not tmp then
46599: LD_VAR 0 5
46603: NOT
46604: IFFALSE 46608
// continue ;
46606: GO 45988
// for j in tmp do
46608: LD_ADDR_VAR 0 3
46612: PUSH
46613: LD_VAR 0 5
46617: PUSH
46618: FOR_IN
46619: IFFALSE 46878
// begin if IsInUnit ( j ) then
46621: LD_VAR 0 3
46625: PPUSH
46626: CALL_OW 310
46630: IFFALSE 46641
// ComExitBuilding ( j ) ;
46632: LD_VAR 0 3
46636: PPUSH
46637: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46641: LD_VAR 0 3
46645: PUSH
46646: LD_EXP 102
46650: PUSH
46651: LD_VAR 0 2
46655: ARRAY
46656: IN
46657: NOT
46658: IFFALSE 46716
// begin SetTag ( j , 101 ) ;
46660: LD_VAR 0 3
46664: PPUSH
46665: LD_INT 101
46667: PPUSH
46668: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46672: LD_ADDR_EXP 102
46676: PUSH
46677: LD_EXP 102
46681: PPUSH
46682: LD_VAR 0 2
46686: PUSH
46687: LD_EXP 102
46691: PUSH
46692: LD_VAR 0 2
46696: ARRAY
46697: PUSH
46698: LD_INT 1
46700: PLUS
46701: PUSH
46702: EMPTY
46703: LIST
46704: LIST
46705: PPUSH
46706: LD_VAR 0 3
46710: PPUSH
46711: CALL 72719 0 3
46715: ST_TO_ADDR
// end ; wait ( 1 ) ;
46716: LD_INT 1
46718: PPUSH
46719: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46723: LD_ADDR_VAR 0 7
46727: PUSH
46728: LD_EXP 101
46732: PUSH
46733: LD_VAR 0 2
46737: ARRAY
46738: ST_TO_ADDR
// if mc_scan [ i ] then
46739: LD_EXP 123
46743: PUSH
46744: LD_VAR 0 2
46748: ARRAY
46749: IFFALSE 46811
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46751: LD_ADDR_VAR 0 7
46755: PUSH
46756: LD_EXP 101
46760: PUSH
46761: LD_VAR 0 2
46765: ARRAY
46766: PPUSH
46767: LD_INT 3
46769: PUSH
46770: LD_INT 30
46772: PUSH
46773: LD_INT 32
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: PUSH
46780: LD_INT 30
46782: PUSH
46783: LD_INT 33
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PUSH
46790: LD_INT 30
46792: PUSH
46793: LD_INT 31
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: PPUSH
46806: CALL_OW 72
46810: ST_TO_ADDR
// if not to_repair_tmp then
46811: LD_VAR 0 7
46815: NOT
46816: IFFALSE 46820
// continue ;
46818: GO 46618
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46820: LD_ADDR_VAR 0 8
46824: PUSH
46825: LD_VAR 0 7
46829: PPUSH
46830: LD_VAR 0 3
46834: PPUSH
46835: CALL_OW 74
46839: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46840: LD_VAR 0 8
46844: PPUSH
46845: LD_INT 16
46847: PPUSH
46848: CALL 75316 0 2
46852: PUSH
46853: LD_INT 4
46855: ARRAY
46856: PUSH
46857: LD_INT 14
46859: LESS
46860: IFFALSE 46876
// ComRepairBuilding ( j , to_repair ) ;
46862: LD_VAR 0 3
46866: PPUSH
46867: LD_VAR 0 8
46871: PPUSH
46872: CALL_OW 130
// end ;
46876: GO 46618
46878: POP
46879: POP
// end ;
46880: GO 45988
46882: POP
46883: POP
// end ;
46884: LD_VAR 0 1
46888: RET
// export function MC_Heal ; var i , j , tmp ; begin
46889: LD_INT 0
46891: PPUSH
46892: PPUSH
46893: PPUSH
46894: PPUSH
// if not mc_bases then
46895: LD_EXP 100
46899: NOT
46900: IFFALSE 46904
// exit ;
46902: GO 47306
// for i = 1 to mc_bases do
46904: LD_ADDR_VAR 0 2
46908: PUSH
46909: DOUBLE
46910: LD_INT 1
46912: DEC
46913: ST_TO_ADDR
46914: LD_EXP 100
46918: PUSH
46919: FOR_TO
46920: IFFALSE 47304
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46922: LD_EXP 103
46926: PUSH
46927: LD_VAR 0 2
46931: ARRAY
46932: PUSH
46933: LD_INT 1
46935: ARRAY
46936: NOT
46937: PUSH
46938: LD_EXP 103
46942: PUSH
46943: LD_VAR 0 2
46947: ARRAY
46948: PUSH
46949: LD_INT 2
46951: ARRAY
46952: NOT
46953: AND
46954: IFFALSE 46992
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46956: LD_ADDR_EXP 104
46960: PUSH
46961: LD_EXP 104
46965: PPUSH
46966: LD_VAR 0 2
46970: PPUSH
46971: EMPTY
46972: PPUSH
46973: CALL_OW 1
46977: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46978: LD_VAR 0 2
46982: PPUSH
46983: LD_INT 102
46985: PPUSH
46986: CALL 41041 0 2
// continue ;
46990: GO 46919
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46992: LD_ADDR_VAR 0 4
46996: PUSH
46997: LD_EXP 100
47001: PUSH
47002: LD_VAR 0 2
47006: ARRAY
47007: PPUSH
47008: LD_INT 25
47010: PUSH
47011: LD_INT 4
47013: PUSH
47014: EMPTY
47015: LIST
47016: LIST
47017: PPUSH
47018: CALL_OW 72
47022: ST_TO_ADDR
// if not tmp then
47023: LD_VAR 0 4
47027: NOT
47028: IFFALSE 47032
// continue ;
47030: GO 46919
// if mc_taming [ i ] then
47032: LD_EXP 131
47036: PUSH
47037: LD_VAR 0 2
47041: ARRAY
47042: IFFALSE 47066
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
47044: LD_ADDR_EXP 131
47048: PUSH
47049: LD_EXP 131
47053: PPUSH
47054: LD_VAR 0 2
47058: PPUSH
47059: EMPTY
47060: PPUSH
47061: CALL_OW 1
47065: ST_TO_ADDR
// for j in tmp do
47066: LD_ADDR_VAR 0 3
47070: PUSH
47071: LD_VAR 0 4
47075: PUSH
47076: FOR_IN
47077: IFFALSE 47300
// begin if IsInUnit ( j ) then
47079: LD_VAR 0 3
47083: PPUSH
47084: CALL_OW 310
47088: IFFALSE 47099
// ComExitBuilding ( j ) ;
47090: LD_VAR 0 3
47094: PPUSH
47095: CALL_OW 122
// if not j in mc_healers [ i ] then
47099: LD_VAR 0 3
47103: PUSH
47104: LD_EXP 104
47108: PUSH
47109: LD_VAR 0 2
47113: ARRAY
47114: IN
47115: NOT
47116: IFFALSE 47162
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
47118: LD_ADDR_EXP 104
47122: PUSH
47123: LD_EXP 104
47127: PPUSH
47128: LD_VAR 0 2
47132: PUSH
47133: LD_EXP 104
47137: PUSH
47138: LD_VAR 0 2
47142: ARRAY
47143: PUSH
47144: LD_INT 1
47146: PLUS
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PPUSH
47152: LD_VAR 0 3
47156: PPUSH
47157: CALL 72719 0 3
47161: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
47162: LD_VAR 0 3
47166: PPUSH
47167: CALL_OW 110
47171: PUSH
47172: LD_INT 102
47174: NONEQUAL
47175: IFFALSE 47189
// SetTag ( j , 102 ) ;
47177: LD_VAR 0 3
47181: PPUSH
47182: LD_INT 102
47184: PPUSH
47185: CALL_OW 109
// Wait ( 3 ) ;
47189: LD_INT 3
47191: PPUSH
47192: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
47196: LD_EXP 103
47200: PUSH
47201: LD_VAR 0 2
47205: ARRAY
47206: PUSH
47207: LD_INT 1
47209: ARRAY
47210: IFFALSE 47242
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
47212: LD_VAR 0 3
47216: PPUSH
47217: LD_EXP 103
47221: PUSH
47222: LD_VAR 0 2
47226: ARRAY
47227: PUSH
47228: LD_INT 1
47230: ARRAY
47231: PUSH
47232: LD_INT 1
47234: ARRAY
47235: PPUSH
47236: CALL_OW 128
47240: GO 47298
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
47242: LD_VAR 0 3
47246: PPUSH
47247: CALL_OW 314
47251: NOT
47252: PUSH
47253: LD_EXP 103
47257: PUSH
47258: LD_VAR 0 2
47262: ARRAY
47263: PUSH
47264: LD_INT 2
47266: ARRAY
47267: AND
47268: IFFALSE 47298
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
47270: LD_VAR 0 3
47274: PPUSH
47275: LD_EXP 103
47279: PUSH
47280: LD_VAR 0 2
47284: ARRAY
47285: PUSH
47286: LD_INT 2
47288: ARRAY
47289: PUSH
47290: LD_INT 1
47292: ARRAY
47293: PPUSH
47294: CALL_OW 128
// end ;
47298: GO 47076
47300: POP
47301: POP
// end ;
47302: GO 46919
47304: POP
47305: POP
// end ;
47306: LD_VAR 0 1
47310: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
47311: LD_INT 0
47313: PPUSH
47314: PPUSH
47315: PPUSH
47316: PPUSH
47317: PPUSH
47318: PPUSH
// if not mc_bases then
47319: LD_EXP 100
47323: NOT
47324: IFFALSE 47328
// exit ;
47326: GO 48491
// for i = 1 to mc_bases do
47328: LD_ADDR_VAR 0 2
47332: PUSH
47333: DOUBLE
47334: LD_INT 1
47336: DEC
47337: ST_TO_ADDR
47338: LD_EXP 100
47342: PUSH
47343: FOR_TO
47344: IFFALSE 48489
// begin if mc_scan [ i ] then
47346: LD_EXP 123
47350: PUSH
47351: LD_VAR 0 2
47355: ARRAY
47356: IFFALSE 47360
// continue ;
47358: GO 47343
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47360: LD_EXP 105
47364: PUSH
47365: LD_VAR 0 2
47369: ARRAY
47370: NOT
47371: PUSH
47372: LD_EXP 107
47376: PUSH
47377: LD_VAR 0 2
47381: ARRAY
47382: NOT
47383: AND
47384: PUSH
47385: LD_EXP 106
47389: PUSH
47390: LD_VAR 0 2
47394: ARRAY
47395: AND
47396: IFFALSE 47434
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47398: LD_ADDR_EXP 106
47402: PUSH
47403: LD_EXP 106
47407: PPUSH
47408: LD_VAR 0 2
47412: PPUSH
47413: EMPTY
47414: PPUSH
47415: CALL_OW 1
47419: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47420: LD_VAR 0 2
47424: PPUSH
47425: LD_INT 103
47427: PPUSH
47428: CALL 41041 0 2
// continue ;
47432: GO 47343
// end ; if mc_construct_list [ i ] then
47434: LD_EXP 107
47438: PUSH
47439: LD_VAR 0 2
47443: ARRAY
47444: IFFALSE 47664
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47446: LD_ADDR_VAR 0 5
47450: PUSH
47451: LD_EXP 100
47455: PUSH
47456: LD_VAR 0 2
47460: ARRAY
47461: PPUSH
47462: LD_INT 25
47464: PUSH
47465: LD_INT 2
47467: PUSH
47468: EMPTY
47469: LIST
47470: LIST
47471: PPUSH
47472: CALL_OW 72
47476: PUSH
47477: LD_EXP 102
47481: PUSH
47482: LD_VAR 0 2
47486: ARRAY
47487: DIFF
47488: ST_TO_ADDR
// if not tmp then
47489: LD_VAR 0 5
47493: NOT
47494: IFFALSE 47498
// continue ;
47496: GO 47343
// for j in tmp do
47498: LD_ADDR_VAR 0 3
47502: PUSH
47503: LD_VAR 0 5
47507: PUSH
47508: FOR_IN
47509: IFFALSE 47660
// begin if not mc_builders [ i ] then
47511: LD_EXP 106
47515: PUSH
47516: LD_VAR 0 2
47520: ARRAY
47521: NOT
47522: IFFALSE 47580
// begin SetTag ( j , 103 ) ;
47524: LD_VAR 0 3
47528: PPUSH
47529: LD_INT 103
47531: PPUSH
47532: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47536: LD_ADDR_EXP 106
47540: PUSH
47541: LD_EXP 106
47545: PPUSH
47546: LD_VAR 0 2
47550: PUSH
47551: LD_EXP 106
47555: PUSH
47556: LD_VAR 0 2
47560: ARRAY
47561: PUSH
47562: LD_INT 1
47564: PLUS
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PPUSH
47570: LD_VAR 0 3
47574: PPUSH
47575: CALL 72719 0 3
47579: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47580: LD_VAR 0 3
47584: PPUSH
47585: CALL_OW 310
47589: IFFALSE 47600
// ComExitBuilding ( j ) ;
47591: LD_VAR 0 3
47595: PPUSH
47596: CALL_OW 122
// wait ( 3 ) ;
47600: LD_INT 3
47602: PPUSH
47603: CALL_OW 67
// if not mc_construct_list [ i ] then
47607: LD_EXP 107
47611: PUSH
47612: LD_VAR 0 2
47616: ARRAY
47617: NOT
47618: IFFALSE 47622
// break ;
47620: GO 47660
// if not HasTask ( j ) then
47622: LD_VAR 0 3
47626: PPUSH
47627: CALL_OW 314
47631: NOT
47632: IFFALSE 47658
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47634: LD_VAR 0 3
47638: PPUSH
47639: LD_EXP 107
47643: PUSH
47644: LD_VAR 0 2
47648: ARRAY
47649: PUSH
47650: LD_INT 1
47652: ARRAY
47653: PPUSH
47654: CALL 75580 0 2
// end ;
47658: GO 47508
47660: POP
47661: POP
// end else
47662: GO 48487
// if mc_build_list [ i ] then
47664: LD_EXP 105
47668: PUSH
47669: LD_VAR 0 2
47673: ARRAY
47674: IFFALSE 48487
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47676: LD_EXP 105
47680: PUSH
47681: LD_VAR 0 2
47685: ARRAY
47686: PUSH
47687: LD_INT 1
47689: ARRAY
47690: PUSH
47691: LD_INT 1
47693: ARRAY
47694: PPUSH
47695: CALL 75404 0 1
47699: PUSH
47700: LD_EXP 100
47704: PUSH
47705: LD_VAR 0 2
47709: ARRAY
47710: PPUSH
47711: LD_INT 2
47713: PUSH
47714: LD_INT 30
47716: PUSH
47717: LD_INT 2
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: LD_INT 30
47726: PUSH
47727: LD_INT 3
47729: PUSH
47730: EMPTY
47731: LIST
47732: LIST
47733: PUSH
47734: EMPTY
47735: LIST
47736: LIST
47737: LIST
47738: PPUSH
47739: CALL_OW 72
47743: NOT
47744: AND
47745: IFFALSE 47850
// begin for j = 1 to mc_build_list [ i ] do
47747: LD_ADDR_VAR 0 3
47751: PUSH
47752: DOUBLE
47753: LD_INT 1
47755: DEC
47756: ST_TO_ADDR
47757: LD_EXP 105
47761: PUSH
47762: LD_VAR 0 2
47766: ARRAY
47767: PUSH
47768: FOR_TO
47769: IFFALSE 47848
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47771: LD_EXP 105
47775: PUSH
47776: LD_VAR 0 2
47780: ARRAY
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: PUSH
47788: LD_INT 1
47790: ARRAY
47791: PUSH
47792: LD_INT 2
47794: EQUAL
47795: IFFALSE 47846
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47797: LD_ADDR_EXP 105
47801: PUSH
47802: LD_EXP 105
47806: PPUSH
47807: LD_VAR 0 2
47811: PPUSH
47812: LD_EXP 105
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PPUSH
47823: LD_VAR 0 3
47827: PPUSH
47828: LD_INT 1
47830: PPUSH
47831: LD_INT 0
47833: PPUSH
47834: CALL 72137 0 4
47838: PPUSH
47839: CALL_OW 1
47843: ST_TO_ADDR
// break ;
47844: GO 47848
// end ;
47846: GO 47768
47848: POP
47849: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47850: LD_ADDR_VAR 0 6
47854: PUSH
47855: LD_EXP 100
47859: PUSH
47860: LD_VAR 0 2
47864: ARRAY
47865: PPUSH
47866: LD_INT 2
47868: PUSH
47869: LD_INT 30
47871: PUSH
47872: LD_INT 0
47874: PUSH
47875: EMPTY
47876: LIST
47877: LIST
47878: PUSH
47879: LD_INT 30
47881: PUSH
47882: LD_INT 1
47884: PUSH
47885: EMPTY
47886: LIST
47887: LIST
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: LIST
47893: PPUSH
47894: CALL_OW 72
47898: ST_TO_ADDR
// for k := 1 to depot do
47899: LD_ADDR_VAR 0 4
47903: PUSH
47904: DOUBLE
47905: LD_INT 1
47907: DEC
47908: ST_TO_ADDR
47909: LD_VAR 0 6
47913: PUSH
47914: FOR_TO
47915: IFFALSE 48485
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47917: LD_EXP 105
47921: PUSH
47922: LD_VAR 0 2
47926: ARRAY
47927: PUSH
47928: LD_INT 1
47930: ARRAY
47931: PUSH
47932: LD_INT 1
47934: ARRAY
47935: PUSH
47936: LD_INT 0
47938: EQUAL
47939: PUSH
47940: LD_VAR 0 6
47944: PUSH
47945: LD_VAR 0 4
47949: ARRAY
47950: PPUSH
47951: LD_EXP 105
47955: PUSH
47956: LD_VAR 0 2
47960: ARRAY
47961: PUSH
47962: LD_INT 1
47964: ARRAY
47965: PUSH
47966: LD_INT 1
47968: ARRAY
47969: PPUSH
47970: LD_EXP 105
47974: PUSH
47975: LD_VAR 0 2
47979: ARRAY
47980: PUSH
47981: LD_INT 1
47983: ARRAY
47984: PUSH
47985: LD_INT 2
47987: ARRAY
47988: PPUSH
47989: LD_EXP 105
47993: PUSH
47994: LD_VAR 0 2
47998: ARRAY
47999: PUSH
48000: LD_INT 1
48002: ARRAY
48003: PUSH
48004: LD_INT 3
48006: ARRAY
48007: PPUSH
48008: LD_EXP 105
48012: PUSH
48013: LD_VAR 0 2
48017: ARRAY
48018: PUSH
48019: LD_INT 1
48021: ARRAY
48022: PUSH
48023: LD_INT 4
48025: ARRAY
48026: PPUSH
48027: CALL 80816 0 5
48031: OR
48032: IFFALSE 48313
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48034: LD_ADDR_VAR 0 5
48038: PUSH
48039: LD_EXP 100
48043: PUSH
48044: LD_VAR 0 2
48048: ARRAY
48049: PPUSH
48050: LD_INT 25
48052: PUSH
48053: LD_INT 2
48055: PUSH
48056: EMPTY
48057: LIST
48058: LIST
48059: PPUSH
48060: CALL_OW 72
48064: PUSH
48065: LD_EXP 102
48069: PUSH
48070: LD_VAR 0 2
48074: ARRAY
48075: DIFF
48076: ST_TO_ADDR
// if not tmp then
48077: LD_VAR 0 5
48081: NOT
48082: IFFALSE 48086
// continue ;
48084: GO 47914
// for j in tmp do
48086: LD_ADDR_VAR 0 3
48090: PUSH
48091: LD_VAR 0 5
48095: PUSH
48096: FOR_IN
48097: IFFALSE 48309
// begin if not mc_builders [ i ] then
48099: LD_EXP 106
48103: PUSH
48104: LD_VAR 0 2
48108: ARRAY
48109: NOT
48110: IFFALSE 48168
// begin SetTag ( j , 103 ) ;
48112: LD_VAR 0 3
48116: PPUSH
48117: LD_INT 103
48119: PPUSH
48120: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48124: LD_ADDR_EXP 106
48128: PUSH
48129: LD_EXP 106
48133: PPUSH
48134: LD_VAR 0 2
48138: PUSH
48139: LD_EXP 106
48143: PUSH
48144: LD_VAR 0 2
48148: ARRAY
48149: PUSH
48150: LD_INT 1
48152: PLUS
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PPUSH
48158: LD_VAR 0 3
48162: PPUSH
48163: CALL 72719 0 3
48167: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48168: LD_VAR 0 3
48172: PPUSH
48173: CALL_OW 310
48177: IFFALSE 48188
// ComExitBuilding ( j ) ;
48179: LD_VAR 0 3
48183: PPUSH
48184: CALL_OW 122
// wait ( 3 ) ;
48188: LD_INT 3
48190: PPUSH
48191: CALL_OW 67
// if not mc_build_list [ i ] then
48195: LD_EXP 105
48199: PUSH
48200: LD_VAR 0 2
48204: ARRAY
48205: NOT
48206: IFFALSE 48210
// break ;
48208: GO 48309
// if not HasTask ( j ) then
48210: LD_VAR 0 3
48214: PPUSH
48215: CALL_OW 314
48219: NOT
48220: IFFALSE 48307
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
48222: LD_VAR 0 3
48226: PPUSH
48227: LD_EXP 105
48231: PUSH
48232: LD_VAR 0 2
48236: ARRAY
48237: PUSH
48238: LD_INT 1
48240: ARRAY
48241: PUSH
48242: LD_INT 1
48244: ARRAY
48245: PPUSH
48246: LD_EXP 105
48250: PUSH
48251: LD_VAR 0 2
48255: ARRAY
48256: PUSH
48257: LD_INT 1
48259: ARRAY
48260: PUSH
48261: LD_INT 2
48263: ARRAY
48264: PPUSH
48265: LD_EXP 105
48269: PUSH
48270: LD_VAR 0 2
48274: ARRAY
48275: PUSH
48276: LD_INT 1
48278: ARRAY
48279: PUSH
48280: LD_INT 3
48282: ARRAY
48283: PPUSH
48284: LD_EXP 105
48288: PUSH
48289: LD_VAR 0 2
48293: ARRAY
48294: PUSH
48295: LD_INT 1
48297: ARRAY
48298: PUSH
48299: LD_INT 4
48301: ARRAY
48302: PPUSH
48303: CALL_OW 145
// end ;
48307: GO 48096
48309: POP
48310: POP
// end else
48311: GO 48483
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
48313: LD_EXP 100
48317: PUSH
48318: LD_VAR 0 2
48322: ARRAY
48323: PPUSH
48324: LD_EXP 105
48328: PUSH
48329: LD_VAR 0 2
48333: ARRAY
48334: PUSH
48335: LD_INT 1
48337: ARRAY
48338: PUSH
48339: LD_INT 1
48341: ARRAY
48342: PPUSH
48343: LD_EXP 105
48347: PUSH
48348: LD_VAR 0 2
48352: ARRAY
48353: PUSH
48354: LD_INT 1
48356: ARRAY
48357: PUSH
48358: LD_INT 2
48360: ARRAY
48361: PPUSH
48362: LD_EXP 105
48366: PUSH
48367: LD_VAR 0 2
48371: ARRAY
48372: PUSH
48373: LD_INT 1
48375: ARRAY
48376: PUSH
48377: LD_INT 3
48379: ARRAY
48380: PPUSH
48381: LD_EXP 105
48385: PUSH
48386: LD_VAR 0 2
48390: ARRAY
48391: PUSH
48392: LD_INT 1
48394: ARRAY
48395: PUSH
48396: LD_INT 4
48398: ARRAY
48399: PPUSH
48400: LD_EXP 100
48404: PUSH
48405: LD_VAR 0 2
48409: ARRAY
48410: PPUSH
48411: LD_INT 21
48413: PUSH
48414: LD_INT 3
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PPUSH
48421: CALL_OW 72
48425: PPUSH
48426: EMPTY
48427: PPUSH
48428: CALL 79570 0 7
48432: NOT
48433: IFFALSE 48483
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48435: LD_ADDR_EXP 105
48439: PUSH
48440: LD_EXP 105
48444: PPUSH
48445: LD_VAR 0 2
48449: PPUSH
48450: LD_EXP 105
48454: PUSH
48455: LD_VAR 0 2
48459: ARRAY
48460: PPUSH
48461: LD_INT 1
48463: PPUSH
48464: LD_INT 1
48466: NEG
48467: PPUSH
48468: LD_INT 0
48470: PPUSH
48471: CALL 72137 0 4
48475: PPUSH
48476: CALL_OW 1
48480: ST_TO_ADDR
// continue ;
48481: GO 47914
// end ; end ;
48483: GO 47914
48485: POP
48486: POP
// end ; end ;
48487: GO 47343
48489: POP
48490: POP
// end ;
48491: LD_VAR 0 1
48495: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48496: LD_INT 0
48498: PPUSH
48499: PPUSH
48500: PPUSH
48501: PPUSH
48502: PPUSH
48503: PPUSH
// if not mc_bases then
48504: LD_EXP 100
48508: NOT
48509: IFFALSE 48513
// exit ;
48511: GO 48940
// for i = 1 to mc_bases do
48513: LD_ADDR_VAR 0 2
48517: PUSH
48518: DOUBLE
48519: LD_INT 1
48521: DEC
48522: ST_TO_ADDR
48523: LD_EXP 100
48527: PUSH
48528: FOR_TO
48529: IFFALSE 48938
// begin tmp := mc_build_upgrade [ i ] ;
48531: LD_ADDR_VAR 0 4
48535: PUSH
48536: LD_EXP 132
48540: PUSH
48541: LD_VAR 0 2
48545: ARRAY
48546: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48547: LD_ADDR_VAR 0 6
48551: PUSH
48552: LD_EXP 133
48556: PUSH
48557: LD_VAR 0 2
48561: ARRAY
48562: PPUSH
48563: LD_INT 2
48565: PUSH
48566: LD_INT 30
48568: PUSH
48569: LD_INT 6
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PUSH
48576: LD_INT 30
48578: PUSH
48579: LD_INT 7
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: LIST
48590: PPUSH
48591: CALL_OW 72
48595: ST_TO_ADDR
// if not tmp and not lab then
48596: LD_VAR 0 4
48600: NOT
48601: PUSH
48602: LD_VAR 0 6
48606: NOT
48607: AND
48608: IFFALSE 48612
// continue ;
48610: GO 48528
// if tmp then
48612: LD_VAR 0 4
48616: IFFALSE 48736
// for j in tmp do
48618: LD_ADDR_VAR 0 3
48622: PUSH
48623: LD_VAR 0 4
48627: PUSH
48628: FOR_IN
48629: IFFALSE 48734
// begin if UpgradeCost ( j ) then
48631: LD_VAR 0 3
48635: PPUSH
48636: CALL 79230 0 1
48640: IFFALSE 48732
// begin ComUpgrade ( j ) ;
48642: LD_VAR 0 3
48646: PPUSH
48647: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48651: LD_ADDR_EXP 132
48655: PUSH
48656: LD_EXP 132
48660: PPUSH
48661: LD_VAR 0 2
48665: PPUSH
48666: LD_EXP 132
48670: PUSH
48671: LD_VAR 0 2
48675: ARRAY
48676: PUSH
48677: LD_VAR 0 3
48681: DIFF
48682: PPUSH
48683: CALL_OW 1
48687: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48688: LD_ADDR_EXP 107
48692: PUSH
48693: LD_EXP 107
48697: PPUSH
48698: LD_VAR 0 2
48702: PUSH
48703: LD_EXP 107
48707: PUSH
48708: LD_VAR 0 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: PLUS
48717: PUSH
48718: EMPTY
48719: LIST
48720: LIST
48721: PPUSH
48722: LD_VAR 0 3
48726: PPUSH
48727: CALL 72719 0 3
48731: ST_TO_ADDR
// end ; end ;
48732: GO 48628
48734: POP
48735: POP
// if not lab or not mc_lab_upgrade [ i ] then
48736: LD_VAR 0 6
48740: NOT
48741: PUSH
48742: LD_EXP 134
48746: PUSH
48747: LD_VAR 0 2
48751: ARRAY
48752: NOT
48753: OR
48754: IFFALSE 48758
// continue ;
48756: GO 48528
// for j in lab do
48758: LD_ADDR_VAR 0 3
48762: PUSH
48763: LD_VAR 0 6
48767: PUSH
48768: FOR_IN
48769: IFFALSE 48934
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48771: LD_VAR 0 3
48775: PPUSH
48776: CALL_OW 266
48780: PUSH
48781: LD_INT 6
48783: PUSH
48784: LD_INT 7
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: IN
48791: PUSH
48792: LD_VAR 0 3
48796: PPUSH
48797: CALL_OW 461
48801: PUSH
48802: LD_INT 1
48804: NONEQUAL
48805: AND
48806: IFFALSE 48932
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48808: LD_VAR 0 3
48812: PPUSH
48813: LD_EXP 134
48817: PUSH
48818: LD_VAR 0 2
48822: ARRAY
48823: PUSH
48824: LD_INT 1
48826: ARRAY
48827: PPUSH
48828: CALL 79435 0 2
48832: IFFALSE 48932
// begin ComCancel ( j ) ;
48834: LD_VAR 0 3
48838: PPUSH
48839: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48843: LD_VAR 0 3
48847: PPUSH
48848: LD_EXP 134
48852: PUSH
48853: LD_VAR 0 2
48857: ARRAY
48858: PUSH
48859: LD_INT 1
48861: ARRAY
48862: PPUSH
48863: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48867: LD_VAR 0 3
48871: PUSH
48872: LD_EXP 107
48876: PUSH
48877: LD_VAR 0 2
48881: ARRAY
48882: IN
48883: NOT
48884: IFFALSE 48930
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48886: LD_ADDR_EXP 107
48890: PUSH
48891: LD_EXP 107
48895: PPUSH
48896: LD_VAR 0 2
48900: PUSH
48901: LD_EXP 107
48905: PUSH
48906: LD_VAR 0 2
48910: ARRAY
48911: PUSH
48912: LD_INT 1
48914: PLUS
48915: PUSH
48916: EMPTY
48917: LIST
48918: LIST
48919: PPUSH
48920: LD_VAR 0 3
48924: PPUSH
48925: CALL 72719 0 3
48929: ST_TO_ADDR
// break ;
48930: GO 48934
// end ; end ; end ;
48932: GO 48768
48934: POP
48935: POP
// end ;
48936: GO 48528
48938: POP
48939: POP
// end ;
48940: LD_VAR 0 1
48944: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48945: LD_INT 0
48947: PPUSH
48948: PPUSH
48949: PPUSH
48950: PPUSH
48951: PPUSH
48952: PPUSH
48953: PPUSH
48954: PPUSH
48955: PPUSH
// if not mc_bases then
48956: LD_EXP 100
48960: NOT
48961: IFFALSE 48965
// exit ;
48963: GO 49370
// for i = 1 to mc_bases do
48965: LD_ADDR_VAR 0 2
48969: PUSH
48970: DOUBLE
48971: LD_INT 1
48973: DEC
48974: ST_TO_ADDR
48975: LD_EXP 100
48979: PUSH
48980: FOR_TO
48981: IFFALSE 49368
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48983: LD_EXP 108
48987: PUSH
48988: LD_VAR 0 2
48992: ARRAY
48993: NOT
48994: PUSH
48995: LD_EXP 100
48999: PUSH
49000: LD_VAR 0 2
49004: ARRAY
49005: PPUSH
49006: LD_INT 30
49008: PUSH
49009: LD_INT 3
49011: PUSH
49012: EMPTY
49013: LIST
49014: LIST
49015: PPUSH
49016: CALL_OW 72
49020: NOT
49021: OR
49022: IFFALSE 49026
// continue ;
49024: GO 48980
// busy := false ;
49026: LD_ADDR_VAR 0 8
49030: PUSH
49031: LD_INT 0
49033: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49034: LD_ADDR_VAR 0 4
49038: PUSH
49039: LD_EXP 100
49043: PUSH
49044: LD_VAR 0 2
49048: ARRAY
49049: PPUSH
49050: LD_INT 30
49052: PUSH
49053: LD_INT 3
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: PPUSH
49060: CALL_OW 72
49064: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
49065: LD_ADDR_VAR 0 6
49069: PUSH
49070: LD_EXP 108
49074: PUSH
49075: LD_VAR 0 2
49079: ARRAY
49080: PPUSH
49081: LD_INT 2
49083: PUSH
49084: LD_INT 30
49086: PUSH
49087: LD_INT 32
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: PUSH
49094: LD_INT 30
49096: PUSH
49097: LD_INT 33
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: LIST
49108: PPUSH
49109: CALL_OW 72
49113: ST_TO_ADDR
// if not t then
49114: LD_VAR 0 6
49118: NOT
49119: IFFALSE 49123
// continue ;
49121: GO 48980
// for j in tmp do
49123: LD_ADDR_VAR 0 3
49127: PUSH
49128: LD_VAR 0 4
49132: PUSH
49133: FOR_IN
49134: IFFALSE 49164
// if not BuildingStatus ( j ) = bs_idle then
49136: LD_VAR 0 3
49140: PPUSH
49141: CALL_OW 461
49145: PUSH
49146: LD_INT 2
49148: EQUAL
49149: NOT
49150: IFFALSE 49162
// begin busy := true ;
49152: LD_ADDR_VAR 0 8
49156: PUSH
49157: LD_INT 1
49159: ST_TO_ADDR
// break ;
49160: GO 49164
// end ;
49162: GO 49133
49164: POP
49165: POP
// if busy then
49166: LD_VAR 0 8
49170: IFFALSE 49174
// continue ;
49172: GO 48980
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
49174: LD_ADDR_VAR 0 7
49178: PUSH
49179: LD_VAR 0 6
49183: PPUSH
49184: LD_INT 35
49186: PUSH
49187: LD_INT 0
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: PPUSH
49194: CALL_OW 72
49198: ST_TO_ADDR
// if tw then
49199: LD_VAR 0 7
49203: IFFALSE 49280
// begin tw := tw [ 1 ] ;
49205: LD_ADDR_VAR 0 7
49209: PUSH
49210: LD_VAR 0 7
49214: PUSH
49215: LD_INT 1
49217: ARRAY
49218: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
49219: LD_ADDR_VAR 0 9
49223: PUSH
49224: LD_VAR 0 7
49228: PPUSH
49229: LD_EXP 125
49233: PUSH
49234: LD_VAR 0 2
49238: ARRAY
49239: PPUSH
49240: CALL 77727 0 2
49244: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
49245: LD_EXP 139
49249: PUSH
49250: LD_VAR 0 2
49254: ARRAY
49255: IFFALSE 49278
// if not weapon in mc_allowed_tower_weapons [ i ] then
49257: LD_VAR 0 9
49261: PUSH
49262: LD_EXP 139
49266: PUSH
49267: LD_VAR 0 2
49271: ARRAY
49272: IN
49273: NOT
49274: IFFALSE 49278
// continue ;
49276: GO 48980
// end else
49278: GO 49343
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
49280: LD_ADDR_VAR 0 5
49284: PUSH
49285: LD_EXP 108
49289: PUSH
49290: LD_VAR 0 2
49294: ARRAY
49295: PPUSH
49296: LD_VAR 0 4
49300: PPUSH
49301: CALL 104598 0 2
49305: ST_TO_ADDR
// if not tmp2 then
49306: LD_VAR 0 5
49310: NOT
49311: IFFALSE 49315
// continue ;
49313: GO 48980
// tw := tmp2 [ 1 ] ;
49315: LD_ADDR_VAR 0 7
49319: PUSH
49320: LD_VAR 0 5
49324: PUSH
49325: LD_INT 1
49327: ARRAY
49328: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
49329: LD_ADDR_VAR 0 9
49333: PUSH
49334: LD_VAR 0 5
49338: PUSH
49339: LD_INT 2
49341: ARRAY
49342: ST_TO_ADDR
// end ; if not weapon then
49343: LD_VAR 0 9
49347: NOT
49348: IFFALSE 49352
// continue ;
49350: GO 48980
// ComPlaceWeapon ( tw , weapon ) ;
49352: LD_VAR 0 7
49356: PPUSH
49357: LD_VAR 0 9
49361: PPUSH
49362: CALL_OW 148
// end ;
49366: GO 48980
49368: POP
49369: POP
// end ;
49370: LD_VAR 0 1
49374: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49375: LD_INT 0
49377: PPUSH
49378: PPUSH
49379: PPUSH
49380: PPUSH
49381: PPUSH
49382: PPUSH
49383: PPUSH
// if not mc_bases then
49384: LD_EXP 100
49388: NOT
49389: IFFALSE 49393
// exit ;
49391: GO 50161
// for i = 1 to mc_bases do
49393: LD_ADDR_VAR 0 2
49397: PUSH
49398: DOUBLE
49399: LD_INT 1
49401: DEC
49402: ST_TO_ADDR
49403: LD_EXP 100
49407: PUSH
49408: FOR_TO
49409: IFFALSE 50159
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49411: LD_EXP 113
49415: PUSH
49416: LD_VAR 0 2
49420: ARRAY
49421: NOT
49422: PUSH
49423: LD_EXP 113
49427: PUSH
49428: LD_VAR 0 2
49432: ARRAY
49433: PUSH
49434: LD_EXP 114
49438: PUSH
49439: LD_VAR 0 2
49443: ARRAY
49444: EQUAL
49445: OR
49446: PUSH
49447: LD_EXP 123
49451: PUSH
49452: LD_VAR 0 2
49456: ARRAY
49457: OR
49458: IFFALSE 49462
// continue ;
49460: GO 49408
// if mc_miners [ i ] then
49462: LD_EXP 114
49466: PUSH
49467: LD_VAR 0 2
49471: ARRAY
49472: IFFALSE 49846
// begin for j = mc_miners [ i ] downto 1 do
49474: LD_ADDR_VAR 0 3
49478: PUSH
49479: DOUBLE
49480: LD_EXP 114
49484: PUSH
49485: LD_VAR 0 2
49489: ARRAY
49490: INC
49491: ST_TO_ADDR
49492: LD_INT 1
49494: PUSH
49495: FOR_DOWNTO
49496: IFFALSE 49844
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49498: LD_EXP 114
49502: PUSH
49503: LD_VAR 0 2
49507: ARRAY
49508: PUSH
49509: LD_VAR 0 3
49513: ARRAY
49514: PPUSH
49515: CALL_OW 301
49519: PUSH
49520: LD_EXP 114
49524: PUSH
49525: LD_VAR 0 2
49529: ARRAY
49530: PUSH
49531: LD_VAR 0 3
49535: ARRAY
49536: PPUSH
49537: CALL_OW 257
49541: PUSH
49542: LD_INT 1
49544: NONEQUAL
49545: OR
49546: IFFALSE 49609
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49548: LD_ADDR_VAR 0 5
49552: PUSH
49553: LD_EXP 114
49557: PUSH
49558: LD_VAR 0 2
49562: ARRAY
49563: PUSH
49564: LD_EXP 114
49568: PUSH
49569: LD_VAR 0 2
49573: ARRAY
49574: PUSH
49575: LD_VAR 0 3
49579: ARRAY
49580: DIFF
49581: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49582: LD_ADDR_EXP 114
49586: PUSH
49587: LD_EXP 114
49591: PPUSH
49592: LD_VAR 0 2
49596: PPUSH
49597: LD_VAR 0 5
49601: PPUSH
49602: CALL_OW 1
49606: ST_TO_ADDR
// continue ;
49607: GO 49495
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49609: LD_EXP 114
49613: PUSH
49614: LD_VAR 0 2
49618: ARRAY
49619: PUSH
49620: LD_VAR 0 3
49624: ARRAY
49625: PPUSH
49626: CALL_OW 257
49630: PUSH
49631: LD_INT 1
49633: EQUAL
49634: PUSH
49635: LD_EXP 114
49639: PUSH
49640: LD_VAR 0 2
49644: ARRAY
49645: PUSH
49646: LD_VAR 0 3
49650: ARRAY
49651: PPUSH
49652: CALL_OW 459
49656: NOT
49657: AND
49658: PUSH
49659: LD_EXP 114
49663: PUSH
49664: LD_VAR 0 2
49668: ARRAY
49669: PUSH
49670: LD_VAR 0 3
49674: ARRAY
49675: PPUSH
49676: CALL_OW 314
49680: NOT
49681: AND
49682: IFFALSE 49842
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49684: LD_EXP 114
49688: PUSH
49689: LD_VAR 0 2
49693: ARRAY
49694: PUSH
49695: LD_VAR 0 3
49699: ARRAY
49700: PPUSH
49701: CALL_OW 310
49705: IFFALSE 49728
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49707: LD_EXP 114
49711: PUSH
49712: LD_VAR 0 2
49716: ARRAY
49717: PUSH
49718: LD_VAR 0 3
49722: ARRAY
49723: PPUSH
49724: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49728: LD_EXP 114
49732: PUSH
49733: LD_VAR 0 2
49737: ARRAY
49738: PUSH
49739: LD_VAR 0 3
49743: ARRAY
49744: PPUSH
49745: CALL_OW 314
49749: NOT
49750: IFFALSE 49842
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49752: LD_ADDR_VAR 0 7
49756: PUSH
49757: LD_INT 1
49759: PPUSH
49760: LD_EXP 113
49764: PUSH
49765: LD_VAR 0 2
49769: ARRAY
49770: PPUSH
49771: CALL_OW 12
49775: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49776: LD_EXP 114
49780: PUSH
49781: LD_VAR 0 2
49785: ARRAY
49786: PUSH
49787: LD_VAR 0 3
49791: ARRAY
49792: PPUSH
49793: LD_EXP 113
49797: PUSH
49798: LD_VAR 0 2
49802: ARRAY
49803: PUSH
49804: LD_VAR 0 7
49808: ARRAY
49809: PUSH
49810: LD_INT 1
49812: ARRAY
49813: PPUSH
49814: LD_EXP 113
49818: PUSH
49819: LD_VAR 0 2
49823: ARRAY
49824: PUSH
49825: LD_VAR 0 7
49829: ARRAY
49830: PUSH
49831: LD_INT 2
49833: ARRAY
49834: PPUSH
49835: LD_INT 0
49837: PPUSH
49838: CALL_OW 193
// end ; end ; end ;
49842: GO 49495
49844: POP
49845: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49846: LD_ADDR_VAR 0 5
49850: PUSH
49851: LD_EXP 100
49855: PUSH
49856: LD_VAR 0 2
49860: ARRAY
49861: PPUSH
49862: LD_INT 2
49864: PUSH
49865: LD_INT 30
49867: PUSH
49868: LD_INT 4
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: LD_INT 30
49877: PUSH
49878: LD_INT 5
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: PUSH
49885: LD_INT 30
49887: PUSH
49888: LD_INT 32
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: LIST
49899: LIST
49900: PPUSH
49901: CALL_OW 72
49905: ST_TO_ADDR
// if not tmp then
49906: LD_VAR 0 5
49910: NOT
49911: IFFALSE 49915
// continue ;
49913: GO 49408
// list := [ ] ;
49915: LD_ADDR_VAR 0 6
49919: PUSH
49920: EMPTY
49921: ST_TO_ADDR
// for j in tmp do
49922: LD_ADDR_VAR 0 3
49926: PUSH
49927: LD_VAR 0 5
49931: PUSH
49932: FOR_IN
49933: IFFALSE 50002
// begin for k in UnitsInside ( j ) do
49935: LD_ADDR_VAR 0 4
49939: PUSH
49940: LD_VAR 0 3
49944: PPUSH
49945: CALL_OW 313
49949: PUSH
49950: FOR_IN
49951: IFFALSE 49998
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49953: LD_VAR 0 4
49957: PPUSH
49958: CALL_OW 257
49962: PUSH
49963: LD_INT 1
49965: EQUAL
49966: PUSH
49967: LD_VAR 0 4
49971: PPUSH
49972: CALL_OW 459
49976: NOT
49977: AND
49978: IFFALSE 49996
// list := list ^ k ;
49980: LD_ADDR_VAR 0 6
49984: PUSH
49985: LD_VAR 0 6
49989: PUSH
49990: LD_VAR 0 4
49994: ADD
49995: ST_TO_ADDR
49996: GO 49950
49998: POP
49999: POP
// end ;
50000: GO 49932
50002: POP
50003: POP
// list := list diff mc_miners [ i ] ;
50004: LD_ADDR_VAR 0 6
50008: PUSH
50009: LD_VAR 0 6
50013: PUSH
50014: LD_EXP 114
50018: PUSH
50019: LD_VAR 0 2
50023: ARRAY
50024: DIFF
50025: ST_TO_ADDR
// if not list then
50026: LD_VAR 0 6
50030: NOT
50031: IFFALSE 50035
// continue ;
50033: GO 49408
// k := mc_mines [ i ] - mc_miners [ i ] ;
50035: LD_ADDR_VAR 0 4
50039: PUSH
50040: LD_EXP 113
50044: PUSH
50045: LD_VAR 0 2
50049: ARRAY
50050: PUSH
50051: LD_EXP 114
50055: PUSH
50056: LD_VAR 0 2
50060: ARRAY
50061: MINUS
50062: ST_TO_ADDR
// if k > list then
50063: LD_VAR 0 4
50067: PUSH
50068: LD_VAR 0 6
50072: GREATER
50073: IFFALSE 50085
// k := list ;
50075: LD_ADDR_VAR 0 4
50079: PUSH
50080: LD_VAR 0 6
50084: ST_TO_ADDR
// for j = 1 to k do
50085: LD_ADDR_VAR 0 3
50089: PUSH
50090: DOUBLE
50091: LD_INT 1
50093: DEC
50094: ST_TO_ADDR
50095: LD_VAR 0 4
50099: PUSH
50100: FOR_TO
50101: IFFALSE 50155
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
50103: LD_ADDR_EXP 114
50107: PUSH
50108: LD_EXP 114
50112: PPUSH
50113: LD_VAR 0 2
50117: PUSH
50118: LD_EXP 114
50122: PUSH
50123: LD_VAR 0 2
50127: ARRAY
50128: PUSH
50129: LD_INT 1
50131: PLUS
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PPUSH
50137: LD_VAR 0 6
50141: PUSH
50142: LD_VAR 0 3
50146: ARRAY
50147: PPUSH
50148: CALL 72719 0 3
50152: ST_TO_ADDR
50153: GO 50100
50155: POP
50156: POP
// end ;
50157: GO 49408
50159: POP
50160: POP
// end ;
50161: LD_VAR 0 1
50165: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
50166: LD_INT 0
50168: PPUSH
50169: PPUSH
50170: PPUSH
50171: PPUSH
50172: PPUSH
50173: PPUSH
50174: PPUSH
50175: PPUSH
50176: PPUSH
50177: PPUSH
50178: PPUSH
// if not mc_bases then
50179: LD_EXP 100
50183: NOT
50184: IFFALSE 50188
// exit ;
50186: GO 52011
// for i = 1 to mc_bases do
50188: LD_ADDR_VAR 0 2
50192: PUSH
50193: DOUBLE
50194: LD_INT 1
50196: DEC
50197: ST_TO_ADDR
50198: LD_EXP 100
50202: PUSH
50203: FOR_TO
50204: IFFALSE 52009
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
50206: LD_EXP 100
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: NOT
50217: PUSH
50218: LD_EXP 107
50222: PUSH
50223: LD_VAR 0 2
50227: ARRAY
50228: OR
50229: IFFALSE 50233
// continue ;
50231: GO 50203
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
50233: LD_EXP 116
50237: PUSH
50238: LD_VAR 0 2
50242: ARRAY
50243: NOT
50244: PUSH
50245: LD_EXP 117
50249: PUSH
50250: LD_VAR 0 2
50254: ARRAY
50255: AND
50256: IFFALSE 50294
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50258: LD_ADDR_EXP 117
50262: PUSH
50263: LD_EXP 117
50267: PPUSH
50268: LD_VAR 0 2
50272: PPUSH
50273: EMPTY
50274: PPUSH
50275: CALL_OW 1
50279: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
50280: LD_VAR 0 2
50284: PPUSH
50285: LD_INT 107
50287: PPUSH
50288: CALL 41041 0 2
// continue ;
50292: GO 50203
// end ; target := [ ] ;
50294: LD_ADDR_VAR 0 7
50298: PUSH
50299: EMPTY
50300: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50301: LD_ADDR_VAR 0 6
50305: PUSH
50306: LD_EXP 100
50310: PUSH
50311: LD_VAR 0 2
50315: ARRAY
50316: PUSH
50317: LD_INT 1
50319: ARRAY
50320: PPUSH
50321: CALL_OW 255
50325: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50326: LD_ADDR_VAR 0 9
50330: PUSH
50331: LD_EXP 100
50335: PUSH
50336: LD_VAR 0 2
50340: ARRAY
50341: PPUSH
50342: LD_INT 2
50344: PUSH
50345: LD_INT 30
50347: PUSH
50348: LD_INT 0
50350: PUSH
50351: EMPTY
50352: LIST
50353: LIST
50354: PUSH
50355: LD_INT 30
50357: PUSH
50358: LD_INT 1
50360: PUSH
50361: EMPTY
50362: LIST
50363: LIST
50364: PUSH
50365: EMPTY
50366: LIST
50367: LIST
50368: LIST
50369: PPUSH
50370: CALL_OW 72
50374: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50375: LD_ADDR_VAR 0 3
50379: PUSH
50380: DOUBLE
50381: LD_EXP 116
50385: PUSH
50386: LD_VAR 0 2
50390: ARRAY
50391: INC
50392: ST_TO_ADDR
50393: LD_INT 1
50395: PUSH
50396: FOR_DOWNTO
50397: IFFALSE 50642
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50399: LD_EXP 116
50403: PUSH
50404: LD_VAR 0 2
50408: ARRAY
50409: PUSH
50410: LD_VAR 0 3
50414: ARRAY
50415: PUSH
50416: LD_INT 2
50418: ARRAY
50419: PPUSH
50420: LD_EXP 116
50424: PUSH
50425: LD_VAR 0 2
50429: ARRAY
50430: PUSH
50431: LD_VAR 0 3
50435: ARRAY
50436: PUSH
50437: LD_INT 3
50439: ARRAY
50440: PPUSH
50441: CALL_OW 488
50445: PUSH
50446: LD_EXP 116
50450: PUSH
50451: LD_VAR 0 2
50455: ARRAY
50456: PUSH
50457: LD_VAR 0 3
50461: ARRAY
50462: PUSH
50463: LD_INT 2
50465: ARRAY
50466: PPUSH
50467: LD_EXP 116
50471: PUSH
50472: LD_VAR 0 2
50476: ARRAY
50477: PUSH
50478: LD_VAR 0 3
50482: ARRAY
50483: PUSH
50484: LD_INT 3
50486: ARRAY
50487: PPUSH
50488: CALL_OW 284
50492: PUSH
50493: LD_INT 0
50495: EQUAL
50496: AND
50497: IFFALSE 50552
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50499: LD_ADDR_VAR 0 5
50503: PUSH
50504: LD_EXP 116
50508: PUSH
50509: LD_VAR 0 2
50513: ARRAY
50514: PPUSH
50515: LD_VAR 0 3
50519: PPUSH
50520: CALL_OW 3
50524: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50525: LD_ADDR_EXP 116
50529: PUSH
50530: LD_EXP 116
50534: PPUSH
50535: LD_VAR 0 2
50539: PPUSH
50540: LD_VAR 0 5
50544: PPUSH
50545: CALL_OW 1
50549: ST_TO_ADDR
// continue ;
50550: GO 50396
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50552: LD_VAR 0 6
50556: PPUSH
50557: LD_EXP 116
50561: PUSH
50562: LD_VAR 0 2
50566: ARRAY
50567: PUSH
50568: LD_VAR 0 3
50572: ARRAY
50573: PUSH
50574: LD_INT 2
50576: ARRAY
50577: PPUSH
50578: LD_EXP 116
50582: PUSH
50583: LD_VAR 0 2
50587: ARRAY
50588: PUSH
50589: LD_VAR 0 3
50593: ARRAY
50594: PUSH
50595: LD_INT 3
50597: ARRAY
50598: PPUSH
50599: LD_INT 30
50601: PPUSH
50602: CALL 73615 0 4
50606: PUSH
50607: LD_INT 4
50609: ARRAY
50610: PUSH
50611: LD_INT 0
50613: EQUAL
50614: IFFALSE 50640
// begin target := mc_crates [ i ] [ j ] ;
50616: LD_ADDR_VAR 0 7
50620: PUSH
50621: LD_EXP 116
50625: PUSH
50626: LD_VAR 0 2
50630: ARRAY
50631: PUSH
50632: LD_VAR 0 3
50636: ARRAY
50637: ST_TO_ADDR
// break ;
50638: GO 50642
// end ; end ;
50640: GO 50396
50642: POP
50643: POP
// if not target then
50644: LD_VAR 0 7
50648: NOT
50649: IFFALSE 50653
// continue ;
50651: GO 50203
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50653: LD_ADDR_VAR 0 8
50657: PUSH
50658: LD_EXP 119
50662: PUSH
50663: LD_VAR 0 2
50667: ARRAY
50668: PPUSH
50669: LD_INT 2
50671: PUSH
50672: LD_INT 3
50674: PUSH
50675: LD_INT 58
50677: PUSH
50678: EMPTY
50679: LIST
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: PUSH
50685: LD_INT 61
50687: PUSH
50688: EMPTY
50689: LIST
50690: PUSH
50691: LD_INT 33
50693: PUSH
50694: LD_INT 5
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: PUSH
50701: LD_INT 33
50703: PUSH
50704: LD_INT 3
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: PUSH
50711: EMPTY
50712: LIST
50713: LIST
50714: LIST
50715: LIST
50716: LIST
50717: PUSH
50718: LD_INT 2
50720: PUSH
50721: LD_INT 34
50723: PUSH
50724: LD_INT 32
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: LD_INT 34
50733: PUSH
50734: LD_INT 51
50736: PUSH
50737: EMPTY
50738: LIST
50739: LIST
50740: PUSH
50741: LD_INT 34
50743: PUSH
50744: LD_INT 12
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: PUSH
50751: EMPTY
50752: LIST
50753: LIST
50754: LIST
50755: LIST
50756: PUSH
50757: EMPTY
50758: LIST
50759: LIST
50760: PPUSH
50761: CALL_OW 72
50765: ST_TO_ADDR
// if not cargo then
50766: LD_VAR 0 8
50770: NOT
50771: IFFALSE 51477
// begin if mc_crates_collector [ i ] < 5 then
50773: LD_EXP 117
50777: PUSH
50778: LD_VAR 0 2
50782: ARRAY
50783: PUSH
50784: LD_INT 5
50786: LESS
50787: IFFALSE 51153
// begin if mc_ape [ i ] then
50789: LD_EXP 129
50793: PUSH
50794: LD_VAR 0 2
50798: ARRAY
50799: IFFALSE 50846
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50801: LD_ADDR_VAR 0 5
50805: PUSH
50806: LD_EXP 129
50810: PUSH
50811: LD_VAR 0 2
50815: ARRAY
50816: PPUSH
50817: LD_INT 25
50819: PUSH
50820: LD_INT 16
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PUSH
50827: LD_INT 24
50829: PUSH
50830: LD_INT 750
50832: PUSH
50833: EMPTY
50834: LIST
50835: LIST
50836: PUSH
50837: EMPTY
50838: LIST
50839: LIST
50840: PPUSH
50841: CALL_OW 72
50845: ST_TO_ADDR
// if not tmp then
50846: LD_VAR 0 5
50850: NOT
50851: IFFALSE 50898
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50853: LD_ADDR_VAR 0 5
50857: PUSH
50858: LD_EXP 100
50862: PUSH
50863: LD_VAR 0 2
50867: ARRAY
50868: PPUSH
50869: LD_INT 25
50871: PUSH
50872: LD_INT 2
50874: PUSH
50875: EMPTY
50876: LIST
50877: LIST
50878: PUSH
50879: LD_INT 24
50881: PUSH
50882: LD_INT 750
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: PPUSH
50893: CALL_OW 72
50897: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50898: LD_EXP 129
50902: PUSH
50903: LD_VAR 0 2
50907: ARRAY
50908: PUSH
50909: LD_EXP 100
50913: PUSH
50914: LD_VAR 0 2
50918: ARRAY
50919: PPUSH
50920: LD_INT 25
50922: PUSH
50923: LD_INT 2
50925: PUSH
50926: EMPTY
50927: LIST
50928: LIST
50929: PUSH
50930: LD_INT 24
50932: PUSH
50933: LD_INT 750
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: PPUSH
50944: CALL_OW 72
50948: AND
50949: PUSH
50950: LD_VAR 0 5
50954: PUSH
50955: LD_INT 5
50957: LESS
50958: AND
50959: IFFALSE 51041
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50961: LD_ADDR_VAR 0 3
50965: PUSH
50966: LD_EXP 100
50970: PUSH
50971: LD_VAR 0 2
50975: ARRAY
50976: PPUSH
50977: LD_INT 25
50979: PUSH
50980: LD_INT 2
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: PUSH
50987: LD_INT 24
50989: PUSH
50990: LD_INT 750
50992: PUSH
50993: EMPTY
50994: LIST
50995: LIST
50996: PUSH
50997: EMPTY
50998: LIST
50999: LIST
51000: PPUSH
51001: CALL_OW 72
51005: PUSH
51006: FOR_IN
51007: IFFALSE 51039
// begin tmp := tmp union j ;
51009: LD_ADDR_VAR 0 5
51013: PUSH
51014: LD_VAR 0 5
51018: PUSH
51019: LD_VAR 0 3
51023: UNION
51024: ST_TO_ADDR
// if tmp >= 5 then
51025: LD_VAR 0 5
51029: PUSH
51030: LD_INT 5
51032: GREATEREQUAL
51033: IFFALSE 51037
// break ;
51035: GO 51039
// end ;
51037: GO 51006
51039: POP
51040: POP
// end ; if not tmp then
51041: LD_VAR 0 5
51045: NOT
51046: IFFALSE 51050
// continue ;
51048: GO 50203
// for j in tmp do
51050: LD_ADDR_VAR 0 3
51054: PUSH
51055: LD_VAR 0 5
51059: PUSH
51060: FOR_IN
51061: IFFALSE 51151
// if not GetTag ( j ) then
51063: LD_VAR 0 3
51067: PPUSH
51068: CALL_OW 110
51072: NOT
51073: IFFALSE 51149
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
51075: LD_ADDR_EXP 117
51079: PUSH
51080: LD_EXP 117
51084: PPUSH
51085: LD_VAR 0 2
51089: PUSH
51090: LD_EXP 117
51094: PUSH
51095: LD_VAR 0 2
51099: ARRAY
51100: PUSH
51101: LD_INT 1
51103: PLUS
51104: PUSH
51105: EMPTY
51106: LIST
51107: LIST
51108: PPUSH
51109: LD_VAR 0 3
51113: PPUSH
51114: CALL 72719 0 3
51118: ST_TO_ADDR
// SetTag ( j , 107 ) ;
51119: LD_VAR 0 3
51123: PPUSH
51124: LD_INT 107
51126: PPUSH
51127: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
51131: LD_EXP 117
51135: PUSH
51136: LD_VAR 0 2
51140: ARRAY
51141: PUSH
51142: LD_INT 5
51144: GREATEREQUAL
51145: IFFALSE 51149
// break ;
51147: GO 51151
// end ;
51149: GO 51060
51151: POP
51152: POP
// end ; if mc_crates_collector [ i ] and target then
51153: LD_EXP 117
51157: PUSH
51158: LD_VAR 0 2
51162: ARRAY
51163: PUSH
51164: LD_VAR 0 7
51168: AND
51169: IFFALSE 51475
// begin if mc_crates_collector [ i ] < target [ 1 ] then
51171: LD_EXP 117
51175: PUSH
51176: LD_VAR 0 2
51180: ARRAY
51181: PUSH
51182: LD_VAR 0 7
51186: PUSH
51187: LD_INT 1
51189: ARRAY
51190: LESS
51191: IFFALSE 51211
// tmp := mc_crates_collector [ i ] else
51193: LD_ADDR_VAR 0 5
51197: PUSH
51198: LD_EXP 117
51202: PUSH
51203: LD_VAR 0 2
51207: ARRAY
51208: ST_TO_ADDR
51209: GO 51225
// tmp := target [ 1 ] ;
51211: LD_ADDR_VAR 0 5
51215: PUSH
51216: LD_VAR 0 7
51220: PUSH
51221: LD_INT 1
51223: ARRAY
51224: ST_TO_ADDR
// k := 0 ;
51225: LD_ADDR_VAR 0 4
51229: PUSH
51230: LD_INT 0
51232: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
51233: LD_ADDR_VAR 0 3
51237: PUSH
51238: LD_EXP 117
51242: PUSH
51243: LD_VAR 0 2
51247: ARRAY
51248: PUSH
51249: FOR_IN
51250: IFFALSE 51473
// begin k := k + 1 ;
51252: LD_ADDR_VAR 0 4
51256: PUSH
51257: LD_VAR 0 4
51261: PUSH
51262: LD_INT 1
51264: PLUS
51265: ST_TO_ADDR
// if k > tmp then
51266: LD_VAR 0 4
51270: PUSH
51271: LD_VAR 0 5
51275: GREATER
51276: IFFALSE 51280
// break ;
51278: GO 51473
// if not GetClass ( j ) in [ 2 , 16 ] then
51280: LD_VAR 0 3
51284: PPUSH
51285: CALL_OW 257
51289: PUSH
51290: LD_INT 2
51292: PUSH
51293: LD_INT 16
51295: PUSH
51296: EMPTY
51297: LIST
51298: LIST
51299: IN
51300: NOT
51301: IFFALSE 51354
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
51303: LD_ADDR_EXP 117
51307: PUSH
51308: LD_EXP 117
51312: PPUSH
51313: LD_VAR 0 2
51317: PPUSH
51318: LD_EXP 117
51322: PUSH
51323: LD_VAR 0 2
51327: ARRAY
51328: PUSH
51329: LD_VAR 0 3
51333: DIFF
51334: PPUSH
51335: CALL_OW 1
51339: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51340: LD_VAR 0 3
51344: PPUSH
51345: LD_INT 0
51347: PPUSH
51348: CALL_OW 109
// continue ;
51352: GO 51249
// end ; if IsInUnit ( j ) then
51354: LD_VAR 0 3
51358: PPUSH
51359: CALL_OW 310
51363: IFFALSE 51374
// ComExitBuilding ( j ) ;
51365: LD_VAR 0 3
51369: PPUSH
51370: CALL_OW 122
// wait ( 3 ) ;
51374: LD_INT 3
51376: PPUSH
51377: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51381: LD_VAR 0 3
51385: PPUSH
51386: CALL_OW 314
51390: PUSH
51391: LD_VAR 0 6
51395: PPUSH
51396: LD_VAR 0 7
51400: PUSH
51401: LD_INT 2
51403: ARRAY
51404: PPUSH
51405: LD_VAR 0 7
51409: PUSH
51410: LD_INT 3
51412: ARRAY
51413: PPUSH
51414: LD_INT 30
51416: PPUSH
51417: CALL 73615 0 4
51421: PUSH
51422: LD_INT 4
51424: ARRAY
51425: AND
51426: IFFALSE 51444
// ComStandNearbyBuilding ( j , depot ) else
51428: LD_VAR 0 3
51432: PPUSH
51433: LD_VAR 0 9
51437: PPUSH
51438: CALL 69146 0 2
51442: GO 51471
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51444: LD_VAR 0 3
51448: PPUSH
51449: LD_VAR 0 7
51453: PUSH
51454: LD_INT 2
51456: ARRAY
51457: PPUSH
51458: LD_VAR 0 7
51462: PUSH
51463: LD_INT 3
51465: ARRAY
51466: PPUSH
51467: CALL_OW 117
// end ;
51471: GO 51249
51473: POP
51474: POP
// end ; end else
51475: GO 52007
// begin for j in cargo do
51477: LD_ADDR_VAR 0 3
51481: PUSH
51482: LD_VAR 0 8
51486: PUSH
51487: FOR_IN
51488: IFFALSE 52005
// begin if GetTag ( j ) <> 0 then
51490: LD_VAR 0 3
51494: PPUSH
51495: CALL_OW 110
51499: PUSH
51500: LD_INT 0
51502: NONEQUAL
51503: IFFALSE 51507
// continue ;
51505: GO 51487
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51507: LD_VAR 0 3
51511: PPUSH
51512: CALL_OW 256
51516: PUSH
51517: LD_INT 1000
51519: LESS
51520: PUSH
51521: LD_VAR 0 3
51525: PPUSH
51526: LD_EXP 124
51530: PUSH
51531: LD_VAR 0 2
51535: ARRAY
51536: PPUSH
51537: CALL_OW 308
51541: NOT
51542: AND
51543: IFFALSE 51565
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51545: LD_VAR 0 3
51549: PPUSH
51550: LD_EXP 124
51554: PUSH
51555: LD_VAR 0 2
51559: ARRAY
51560: PPUSH
51561: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51565: LD_VAR 0 3
51569: PPUSH
51570: CALL_OW 256
51574: PUSH
51575: LD_INT 1000
51577: LESS
51578: PUSH
51579: LD_VAR 0 3
51583: PPUSH
51584: LD_EXP 124
51588: PUSH
51589: LD_VAR 0 2
51593: ARRAY
51594: PPUSH
51595: CALL_OW 308
51599: AND
51600: IFFALSE 51604
// continue ;
51602: GO 51487
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51604: LD_VAR 0 3
51608: PPUSH
51609: CALL_OW 262
51613: PUSH
51614: LD_INT 2
51616: EQUAL
51617: PUSH
51618: LD_VAR 0 3
51622: PPUSH
51623: CALL_OW 261
51627: PUSH
51628: LD_INT 15
51630: LESS
51631: AND
51632: IFFALSE 51636
// continue ;
51634: GO 51487
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51636: LD_VAR 0 3
51640: PPUSH
51641: CALL_OW 262
51645: PUSH
51646: LD_INT 1
51648: EQUAL
51649: PUSH
51650: LD_VAR 0 3
51654: PPUSH
51655: CALL_OW 261
51659: PUSH
51660: LD_INT 10
51662: LESS
51663: AND
51664: IFFALSE 51944
// begin if not depot then
51666: LD_VAR 0 9
51670: NOT
51671: IFFALSE 51675
// continue ;
51673: GO 51487
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51675: LD_VAR 0 3
51679: PPUSH
51680: LD_VAR 0 9
51684: PPUSH
51685: LD_VAR 0 3
51689: PPUSH
51690: CALL_OW 74
51694: PPUSH
51695: CALL_OW 296
51699: PUSH
51700: LD_INT 6
51702: LESS
51703: IFFALSE 51719
// SetFuel ( j , 100 ) else
51705: LD_VAR 0 3
51709: PPUSH
51710: LD_INT 100
51712: PPUSH
51713: CALL_OW 240
51717: GO 51944
// if GetFuel ( j ) = 0 then
51719: LD_VAR 0 3
51723: PPUSH
51724: CALL_OW 261
51728: PUSH
51729: LD_INT 0
51731: EQUAL
51732: IFFALSE 51944
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51734: LD_ADDR_EXP 119
51738: PUSH
51739: LD_EXP 119
51743: PPUSH
51744: LD_VAR 0 2
51748: PPUSH
51749: LD_EXP 119
51753: PUSH
51754: LD_VAR 0 2
51758: ARRAY
51759: PUSH
51760: LD_VAR 0 3
51764: DIFF
51765: PPUSH
51766: CALL_OW 1
51770: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51771: LD_VAR 0 3
51775: PPUSH
51776: CALL_OW 263
51780: PUSH
51781: LD_INT 1
51783: EQUAL
51784: IFFALSE 51800
// ComExitVehicle ( IsInUnit ( j ) ) ;
51786: LD_VAR 0 3
51790: PPUSH
51791: CALL_OW 310
51795: PPUSH
51796: CALL_OW 121
// if GetControl ( j ) = control_remote then
51800: LD_VAR 0 3
51804: PPUSH
51805: CALL_OW 263
51809: PUSH
51810: LD_INT 2
51812: EQUAL
51813: IFFALSE 51824
// ComUnlink ( j ) ;
51815: LD_VAR 0 3
51819: PPUSH
51820: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51824: LD_ADDR_VAR 0 10
51828: PUSH
51829: LD_VAR 0 2
51833: PPUSH
51834: LD_INT 3
51836: PPUSH
51837: CALL 61611 0 2
51841: ST_TO_ADDR
// if fac then
51842: LD_VAR 0 10
51846: IFFALSE 51942
// begin for k in fac do
51848: LD_ADDR_VAR 0 4
51852: PUSH
51853: LD_VAR 0 10
51857: PUSH
51858: FOR_IN
51859: IFFALSE 51940
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51861: LD_ADDR_VAR 0 11
51865: PUSH
51866: LD_VAR 0 10
51870: PPUSH
51871: LD_VAR 0 3
51875: PPUSH
51876: CALL_OW 265
51880: PPUSH
51881: LD_VAR 0 3
51885: PPUSH
51886: CALL_OW 262
51890: PPUSH
51891: LD_VAR 0 3
51895: PPUSH
51896: CALL_OW 263
51900: PPUSH
51901: LD_VAR 0 3
51905: PPUSH
51906: CALL_OW 264
51910: PPUSH
51911: CALL 70217 0 5
51915: ST_TO_ADDR
// if components then
51916: LD_VAR 0 11
51920: IFFALSE 51938
// begin MC_InsertProduceList ( i , components ) ;
51922: LD_VAR 0 2
51926: PPUSH
51927: LD_VAR 0 11
51931: PPUSH
51932: CALL 61156 0 2
// break ;
51936: GO 51940
// end ; end ;
51938: GO 51858
51940: POP
51941: POP
// end ; continue ;
51942: GO 51487
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51944: LD_VAR 0 3
51948: PPUSH
51949: LD_INT 1
51951: PPUSH
51952: CALL_OW 289
51956: PUSH
51957: LD_INT 100
51959: LESS
51960: PUSH
51961: LD_VAR 0 3
51965: PPUSH
51966: CALL_OW 314
51970: NOT
51971: AND
51972: IFFALSE 52001
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51974: LD_VAR 0 3
51978: PPUSH
51979: LD_VAR 0 7
51983: PUSH
51984: LD_INT 2
51986: ARRAY
51987: PPUSH
51988: LD_VAR 0 7
51992: PUSH
51993: LD_INT 3
51995: ARRAY
51996: PPUSH
51997: CALL_OW 117
// break ;
52001: GO 52005
// end ;
52003: GO 51487
52005: POP
52006: POP
// end ; end ;
52007: GO 50203
52009: POP
52010: POP
// end ;
52011: LD_VAR 0 1
52015: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
52016: LD_INT 0
52018: PPUSH
52019: PPUSH
52020: PPUSH
52021: PPUSH
// if not mc_bases then
52022: LD_EXP 100
52026: NOT
52027: IFFALSE 52031
// exit ;
52029: GO 52192
// for i = 1 to mc_bases do
52031: LD_ADDR_VAR 0 2
52035: PUSH
52036: DOUBLE
52037: LD_INT 1
52039: DEC
52040: ST_TO_ADDR
52041: LD_EXP 100
52045: PUSH
52046: FOR_TO
52047: IFFALSE 52190
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
52049: LD_ADDR_VAR 0 4
52053: PUSH
52054: LD_EXP 119
52058: PUSH
52059: LD_VAR 0 2
52063: ARRAY
52064: PUSH
52065: LD_EXP 122
52069: PUSH
52070: LD_VAR 0 2
52074: ARRAY
52075: UNION
52076: PPUSH
52077: LD_INT 33
52079: PUSH
52080: LD_INT 2
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PPUSH
52087: CALL_OW 72
52091: ST_TO_ADDR
// if tmp then
52092: LD_VAR 0 4
52096: IFFALSE 52188
// for j in tmp do
52098: LD_ADDR_VAR 0 3
52102: PUSH
52103: LD_VAR 0 4
52107: PUSH
52108: FOR_IN
52109: IFFALSE 52186
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
52111: LD_VAR 0 3
52115: PPUSH
52116: CALL_OW 312
52120: NOT
52121: PUSH
52122: LD_VAR 0 3
52126: PPUSH
52127: CALL_OW 256
52131: PUSH
52132: LD_INT 250
52134: GREATEREQUAL
52135: AND
52136: IFFALSE 52149
// Connect ( j ) else
52138: LD_VAR 0 3
52142: PPUSH
52143: CALL 75688 0 1
52147: GO 52184
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
52149: LD_VAR 0 3
52153: PPUSH
52154: CALL_OW 256
52158: PUSH
52159: LD_INT 250
52161: LESS
52162: PUSH
52163: LD_VAR 0 3
52167: PPUSH
52168: CALL_OW 312
52172: AND
52173: IFFALSE 52184
// ComUnlink ( j ) ;
52175: LD_VAR 0 3
52179: PPUSH
52180: CALL_OW 136
52184: GO 52108
52186: POP
52187: POP
// end ;
52188: GO 52046
52190: POP
52191: POP
// end ;
52192: LD_VAR 0 1
52196: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
52197: LD_INT 0
52199: PPUSH
52200: PPUSH
52201: PPUSH
52202: PPUSH
52203: PPUSH
// if not mc_bases then
52204: LD_EXP 100
52208: NOT
52209: IFFALSE 52213
// exit ;
52211: GO 52658
// for i = 1 to mc_bases do
52213: LD_ADDR_VAR 0 2
52217: PUSH
52218: DOUBLE
52219: LD_INT 1
52221: DEC
52222: ST_TO_ADDR
52223: LD_EXP 100
52227: PUSH
52228: FOR_TO
52229: IFFALSE 52656
// begin if not mc_produce [ i ] then
52231: LD_EXP 121
52235: PUSH
52236: LD_VAR 0 2
52240: ARRAY
52241: NOT
52242: IFFALSE 52246
// continue ;
52244: GO 52228
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52246: LD_ADDR_VAR 0 5
52250: PUSH
52251: LD_EXP 100
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PPUSH
52262: LD_INT 30
52264: PUSH
52265: LD_INT 3
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PPUSH
52272: CALL_OW 72
52276: ST_TO_ADDR
// if not fac then
52277: LD_VAR 0 5
52281: NOT
52282: IFFALSE 52286
// continue ;
52284: GO 52228
// for j in fac do
52286: LD_ADDR_VAR 0 3
52290: PUSH
52291: LD_VAR 0 5
52295: PUSH
52296: FOR_IN
52297: IFFALSE 52652
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
52299: LD_VAR 0 3
52303: PPUSH
52304: CALL_OW 461
52308: PUSH
52309: LD_INT 2
52311: NONEQUAL
52312: PUSH
52313: LD_VAR 0 3
52317: PPUSH
52318: LD_INT 15
52320: PPUSH
52321: CALL 75316 0 2
52325: PUSH
52326: LD_INT 4
52328: ARRAY
52329: OR
52330: IFFALSE 52334
// continue ;
52332: GO 52296
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
52334: LD_VAR 0 3
52338: PPUSH
52339: LD_EXP 121
52343: PUSH
52344: LD_VAR 0 2
52348: ARRAY
52349: PUSH
52350: LD_INT 1
52352: ARRAY
52353: PUSH
52354: LD_INT 1
52356: ARRAY
52357: PPUSH
52358: LD_EXP 121
52362: PUSH
52363: LD_VAR 0 2
52367: ARRAY
52368: PUSH
52369: LD_INT 1
52371: ARRAY
52372: PUSH
52373: LD_INT 2
52375: ARRAY
52376: PPUSH
52377: LD_EXP 121
52381: PUSH
52382: LD_VAR 0 2
52386: ARRAY
52387: PUSH
52388: LD_INT 1
52390: ARRAY
52391: PUSH
52392: LD_INT 3
52394: ARRAY
52395: PPUSH
52396: LD_EXP 121
52400: PUSH
52401: LD_VAR 0 2
52405: ARRAY
52406: PUSH
52407: LD_INT 1
52409: ARRAY
52410: PUSH
52411: LD_INT 4
52413: ARRAY
52414: PPUSH
52415: CALL_OW 448
52419: PUSH
52420: LD_VAR 0 3
52424: PPUSH
52425: LD_EXP 121
52429: PUSH
52430: LD_VAR 0 2
52434: ARRAY
52435: PUSH
52436: LD_INT 1
52438: ARRAY
52439: PUSH
52440: LD_INT 1
52442: ARRAY
52443: PUSH
52444: LD_EXP 121
52448: PUSH
52449: LD_VAR 0 2
52453: ARRAY
52454: PUSH
52455: LD_INT 1
52457: ARRAY
52458: PUSH
52459: LD_INT 2
52461: ARRAY
52462: PUSH
52463: LD_EXP 121
52467: PUSH
52468: LD_VAR 0 2
52472: ARRAY
52473: PUSH
52474: LD_INT 1
52476: ARRAY
52477: PUSH
52478: LD_INT 3
52480: ARRAY
52481: PUSH
52482: LD_EXP 121
52486: PUSH
52487: LD_VAR 0 2
52491: ARRAY
52492: PUSH
52493: LD_INT 1
52495: ARRAY
52496: PUSH
52497: LD_INT 4
52499: ARRAY
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: LIST
52505: LIST
52506: PPUSH
52507: CALL 79083 0 2
52511: AND
52512: IFFALSE 52650
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52514: LD_VAR 0 3
52518: PPUSH
52519: LD_EXP 121
52523: PUSH
52524: LD_VAR 0 2
52528: ARRAY
52529: PUSH
52530: LD_INT 1
52532: ARRAY
52533: PUSH
52534: LD_INT 1
52536: ARRAY
52537: PPUSH
52538: LD_EXP 121
52542: PUSH
52543: LD_VAR 0 2
52547: ARRAY
52548: PUSH
52549: LD_INT 1
52551: ARRAY
52552: PUSH
52553: LD_INT 2
52555: ARRAY
52556: PPUSH
52557: LD_EXP 121
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: PUSH
52568: LD_INT 1
52570: ARRAY
52571: PUSH
52572: LD_INT 3
52574: ARRAY
52575: PPUSH
52576: LD_EXP 121
52580: PUSH
52581: LD_VAR 0 2
52585: ARRAY
52586: PUSH
52587: LD_INT 1
52589: ARRAY
52590: PUSH
52591: LD_INT 4
52593: ARRAY
52594: PPUSH
52595: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52599: LD_ADDR_VAR 0 4
52603: PUSH
52604: LD_EXP 121
52608: PUSH
52609: LD_VAR 0 2
52613: ARRAY
52614: PPUSH
52615: LD_INT 1
52617: PPUSH
52618: CALL_OW 3
52622: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52623: LD_ADDR_EXP 121
52627: PUSH
52628: LD_EXP 121
52632: PPUSH
52633: LD_VAR 0 2
52637: PPUSH
52638: LD_VAR 0 4
52642: PPUSH
52643: CALL_OW 1
52647: ST_TO_ADDR
// break ;
52648: GO 52652
// end ; end ;
52650: GO 52296
52652: POP
52653: POP
// end ;
52654: GO 52228
52656: POP
52657: POP
// end ;
52658: LD_VAR 0 1
52662: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52663: LD_INT 0
52665: PPUSH
52666: PPUSH
52667: PPUSH
// if not mc_bases then
52668: LD_EXP 100
52672: NOT
52673: IFFALSE 52677
// exit ;
52675: GO 52766
// for i = 1 to mc_bases do
52677: LD_ADDR_VAR 0 2
52681: PUSH
52682: DOUBLE
52683: LD_INT 1
52685: DEC
52686: ST_TO_ADDR
52687: LD_EXP 100
52691: PUSH
52692: FOR_TO
52693: IFFALSE 52764
// begin if mc_attack [ i ] then
52695: LD_EXP 120
52699: PUSH
52700: LD_VAR 0 2
52704: ARRAY
52705: IFFALSE 52762
// begin tmp := mc_attack [ i ] [ 1 ] ;
52707: LD_ADDR_VAR 0 3
52711: PUSH
52712: LD_EXP 120
52716: PUSH
52717: LD_VAR 0 2
52721: ARRAY
52722: PUSH
52723: LD_INT 1
52725: ARRAY
52726: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52727: LD_ADDR_EXP 120
52731: PUSH
52732: LD_EXP 120
52736: PPUSH
52737: LD_VAR 0 2
52741: PPUSH
52742: EMPTY
52743: PPUSH
52744: CALL_OW 1
52748: ST_TO_ADDR
// Attack ( tmp ) ;
52749: LD_VAR 0 3
52753: PPUSH
52754: CALL 129086 0 1
// exit ;
52758: POP
52759: POP
52760: GO 52766
// end ; end ;
52762: GO 52692
52764: POP
52765: POP
// end ;
52766: LD_VAR 0 1
52770: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52771: LD_INT 0
52773: PPUSH
52774: PPUSH
52775: PPUSH
52776: PPUSH
52777: PPUSH
52778: PPUSH
52779: PPUSH
// if not mc_bases then
52780: LD_EXP 100
52784: NOT
52785: IFFALSE 52789
// exit ;
52787: GO 53646
// for i = 1 to mc_bases do
52789: LD_ADDR_VAR 0 2
52793: PUSH
52794: DOUBLE
52795: LD_INT 1
52797: DEC
52798: ST_TO_ADDR
52799: LD_EXP 100
52803: PUSH
52804: FOR_TO
52805: IFFALSE 53644
// begin if not mc_bases [ i ] then
52807: LD_EXP 100
52811: PUSH
52812: LD_VAR 0 2
52816: ARRAY
52817: NOT
52818: IFFALSE 52822
// continue ;
52820: GO 52804
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52822: LD_ADDR_VAR 0 7
52826: PUSH
52827: LD_EXP 100
52831: PUSH
52832: LD_VAR 0 2
52836: ARRAY
52837: PUSH
52838: LD_INT 1
52840: ARRAY
52841: PPUSH
52842: CALL 69368 0 1
52846: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52847: LD_ADDR_EXP 123
52851: PUSH
52852: LD_EXP 123
52856: PPUSH
52857: LD_VAR 0 2
52861: PPUSH
52862: LD_EXP 100
52866: PUSH
52867: LD_VAR 0 2
52871: ARRAY
52872: PUSH
52873: LD_INT 1
52875: ARRAY
52876: PPUSH
52877: CALL_OW 255
52881: PPUSH
52882: LD_EXP 125
52886: PUSH
52887: LD_VAR 0 2
52891: ARRAY
52892: PPUSH
52893: CALL 69333 0 2
52897: PPUSH
52898: CALL_OW 1
52902: ST_TO_ADDR
// if not mc_scan [ i ] then
52903: LD_EXP 123
52907: PUSH
52908: LD_VAR 0 2
52912: ARRAY
52913: NOT
52914: IFFALSE 53092
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52916: LD_ADDR_EXP 143
52920: PUSH
52921: LD_EXP 143
52925: PPUSH
52926: LD_VAR 0 2
52930: PPUSH
52931: LD_INT 0
52933: PPUSH
52934: CALL_OW 1
52938: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52939: LD_ADDR_VAR 0 4
52943: PUSH
52944: LD_EXP 100
52948: PUSH
52949: LD_VAR 0 2
52953: ARRAY
52954: PPUSH
52955: LD_INT 2
52957: PUSH
52958: LD_INT 25
52960: PUSH
52961: LD_INT 5
52963: PUSH
52964: EMPTY
52965: LIST
52966: LIST
52967: PUSH
52968: LD_INT 25
52970: PUSH
52971: LD_INT 8
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: PUSH
52978: LD_INT 25
52980: PUSH
52981: LD_INT 9
52983: PUSH
52984: EMPTY
52985: LIST
52986: LIST
52987: PUSH
52988: EMPTY
52989: LIST
52990: LIST
52991: LIST
52992: LIST
52993: PPUSH
52994: CALL_OW 72
52998: ST_TO_ADDR
// if not tmp then
52999: LD_VAR 0 4
53003: NOT
53004: IFFALSE 53008
// continue ;
53006: GO 52804
// for j in tmp do
53008: LD_ADDR_VAR 0 3
53012: PUSH
53013: LD_VAR 0 4
53017: PUSH
53018: FOR_IN
53019: IFFALSE 53090
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
53021: LD_VAR 0 3
53025: PPUSH
53026: CALL_OW 310
53030: PPUSH
53031: CALL_OW 266
53035: PUSH
53036: LD_INT 5
53038: EQUAL
53039: PUSH
53040: LD_VAR 0 3
53044: PPUSH
53045: CALL_OW 257
53049: PUSH
53050: LD_INT 1
53052: EQUAL
53053: AND
53054: PUSH
53055: LD_VAR 0 3
53059: PPUSH
53060: CALL_OW 459
53064: NOT
53065: AND
53066: PUSH
53067: LD_VAR 0 7
53071: AND
53072: IFFALSE 53088
// ComChangeProfession ( j , class ) ;
53074: LD_VAR 0 3
53078: PPUSH
53079: LD_VAR 0 7
53083: PPUSH
53084: CALL_OW 123
53088: GO 53018
53090: POP
53091: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
53092: LD_EXP 123
53096: PUSH
53097: LD_VAR 0 2
53101: ARRAY
53102: PUSH
53103: LD_EXP 143
53107: PUSH
53108: LD_VAR 0 2
53112: ARRAY
53113: NOT
53114: AND
53115: PUSH
53116: LD_EXP 122
53120: PUSH
53121: LD_VAR 0 2
53125: ARRAY
53126: NOT
53127: AND
53128: PUSH
53129: LD_EXP 100
53133: PUSH
53134: LD_VAR 0 2
53138: ARRAY
53139: PPUSH
53140: LD_INT 50
53142: PUSH
53143: EMPTY
53144: LIST
53145: PUSH
53146: LD_INT 2
53148: PUSH
53149: LD_INT 30
53151: PUSH
53152: LD_INT 32
53154: PUSH
53155: EMPTY
53156: LIST
53157: LIST
53158: PUSH
53159: LD_INT 30
53161: PUSH
53162: LD_INT 33
53164: PUSH
53165: EMPTY
53166: LIST
53167: LIST
53168: PUSH
53169: LD_INT 30
53171: PUSH
53172: LD_INT 4
53174: PUSH
53175: EMPTY
53176: LIST
53177: LIST
53178: PUSH
53179: LD_INT 30
53181: PUSH
53182: LD_INT 5
53184: PUSH
53185: EMPTY
53186: LIST
53187: LIST
53188: PUSH
53189: EMPTY
53190: LIST
53191: LIST
53192: LIST
53193: LIST
53194: LIST
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: PPUSH
53200: CALL_OW 72
53204: PUSH
53205: LD_INT 4
53207: LESS
53208: PUSH
53209: LD_EXP 100
53213: PUSH
53214: LD_VAR 0 2
53218: ARRAY
53219: PPUSH
53220: LD_INT 3
53222: PUSH
53223: LD_INT 24
53225: PUSH
53226: LD_INT 1000
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: PUSH
53233: EMPTY
53234: LIST
53235: LIST
53236: PUSH
53237: LD_INT 2
53239: PUSH
53240: LD_INT 30
53242: PUSH
53243: LD_INT 0
53245: PUSH
53246: EMPTY
53247: LIST
53248: LIST
53249: PUSH
53250: LD_INT 30
53252: PUSH
53253: LD_INT 1
53255: PUSH
53256: EMPTY
53257: LIST
53258: LIST
53259: PUSH
53260: EMPTY
53261: LIST
53262: LIST
53263: LIST
53264: PUSH
53265: EMPTY
53266: LIST
53267: LIST
53268: PPUSH
53269: CALL_OW 72
53273: OR
53274: AND
53275: IFFALSE 53526
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53277: LD_ADDR_EXP 143
53281: PUSH
53282: LD_EXP 143
53286: PPUSH
53287: LD_VAR 0 2
53291: PPUSH
53292: LD_INT 1
53294: PPUSH
53295: CALL_OW 1
53299: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53300: LD_ADDR_VAR 0 4
53304: PUSH
53305: LD_EXP 100
53309: PUSH
53310: LD_VAR 0 2
53314: ARRAY
53315: PPUSH
53316: LD_INT 2
53318: PUSH
53319: LD_INT 25
53321: PUSH
53322: LD_INT 1
53324: PUSH
53325: EMPTY
53326: LIST
53327: LIST
53328: PUSH
53329: LD_INT 25
53331: PUSH
53332: LD_INT 5
53334: PUSH
53335: EMPTY
53336: LIST
53337: LIST
53338: PUSH
53339: LD_INT 25
53341: PUSH
53342: LD_INT 8
53344: PUSH
53345: EMPTY
53346: LIST
53347: LIST
53348: PUSH
53349: LD_INT 25
53351: PUSH
53352: LD_INT 9
53354: PUSH
53355: EMPTY
53356: LIST
53357: LIST
53358: PUSH
53359: EMPTY
53360: LIST
53361: LIST
53362: LIST
53363: LIST
53364: LIST
53365: PPUSH
53366: CALL_OW 72
53370: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53371: LD_ADDR_VAR 0 4
53375: PUSH
53376: LD_VAR 0 4
53380: PUSH
53381: LD_VAR 0 4
53385: PPUSH
53386: LD_INT 18
53388: PPUSH
53389: CALL 102631 0 2
53393: DIFF
53394: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53395: LD_VAR 0 4
53399: NOT
53400: PUSH
53401: LD_EXP 100
53405: PUSH
53406: LD_VAR 0 2
53410: ARRAY
53411: PPUSH
53412: LD_INT 2
53414: PUSH
53415: LD_INT 30
53417: PUSH
53418: LD_INT 4
53420: PUSH
53421: EMPTY
53422: LIST
53423: LIST
53424: PUSH
53425: LD_INT 30
53427: PUSH
53428: LD_INT 5
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: LIST
53439: PPUSH
53440: CALL_OW 72
53444: NOT
53445: AND
53446: IFFALSE 53508
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53448: LD_ADDR_VAR 0 4
53452: PUSH
53453: LD_EXP 100
53457: PUSH
53458: LD_VAR 0 2
53462: ARRAY
53463: PPUSH
53464: LD_INT 2
53466: PUSH
53467: LD_INT 25
53469: PUSH
53470: LD_INT 2
53472: PUSH
53473: EMPTY
53474: LIST
53475: LIST
53476: PUSH
53477: LD_INT 25
53479: PUSH
53480: LD_INT 3
53482: PUSH
53483: EMPTY
53484: LIST
53485: LIST
53486: PUSH
53487: LD_INT 25
53489: PUSH
53490: LD_INT 4
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: PUSH
53497: EMPTY
53498: LIST
53499: LIST
53500: LIST
53501: LIST
53502: PPUSH
53503: CALL_OW 72
53507: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53508: LD_VAR 0 2
53512: PPUSH
53513: LD_VAR 0 4
53517: PPUSH
53518: CALL 133795 0 2
// exit ;
53522: POP
53523: POP
53524: GO 53646
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53526: LD_EXP 123
53530: PUSH
53531: LD_VAR 0 2
53535: ARRAY
53536: PUSH
53537: LD_EXP 143
53541: PUSH
53542: LD_VAR 0 2
53546: ARRAY
53547: NOT
53548: AND
53549: PUSH
53550: LD_EXP 122
53554: PUSH
53555: LD_VAR 0 2
53559: ARRAY
53560: AND
53561: IFFALSE 53642
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53563: LD_ADDR_EXP 143
53567: PUSH
53568: LD_EXP 143
53572: PPUSH
53573: LD_VAR 0 2
53577: PPUSH
53578: LD_INT 1
53580: PPUSH
53581: CALL_OW 1
53585: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53586: LD_ADDR_VAR 0 4
53590: PUSH
53591: LD_EXP 122
53595: PUSH
53596: LD_VAR 0 2
53600: ARRAY
53601: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53602: LD_ADDR_EXP 122
53606: PUSH
53607: LD_EXP 122
53611: PPUSH
53612: LD_VAR 0 2
53616: PPUSH
53617: EMPTY
53618: PPUSH
53619: CALL_OW 1
53623: ST_TO_ADDR
// Defend ( i , tmp ) ;
53624: LD_VAR 0 2
53628: PPUSH
53629: LD_VAR 0 4
53633: PPUSH
53634: CALL 134391 0 2
// exit ;
53638: POP
53639: POP
53640: GO 53646
// end ; end ;
53642: GO 52804
53644: POP
53645: POP
// end ;
53646: LD_VAR 0 1
53650: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53651: LD_INT 0
53653: PPUSH
53654: PPUSH
53655: PPUSH
53656: PPUSH
53657: PPUSH
53658: PPUSH
53659: PPUSH
53660: PPUSH
53661: PPUSH
53662: PPUSH
53663: PPUSH
// if not mc_bases then
53664: LD_EXP 100
53668: NOT
53669: IFFALSE 53673
// exit ;
53671: GO 54760
// for i = 1 to mc_bases do
53673: LD_ADDR_VAR 0 2
53677: PUSH
53678: DOUBLE
53679: LD_INT 1
53681: DEC
53682: ST_TO_ADDR
53683: LD_EXP 100
53687: PUSH
53688: FOR_TO
53689: IFFALSE 54758
// begin tmp := mc_lab [ i ] ;
53691: LD_ADDR_VAR 0 6
53695: PUSH
53696: LD_EXP 133
53700: PUSH
53701: LD_VAR 0 2
53705: ARRAY
53706: ST_TO_ADDR
// if not tmp then
53707: LD_VAR 0 6
53711: NOT
53712: IFFALSE 53716
// continue ;
53714: GO 53688
// idle_lab := 0 ;
53716: LD_ADDR_VAR 0 11
53720: PUSH
53721: LD_INT 0
53723: ST_TO_ADDR
// for j in tmp do
53724: LD_ADDR_VAR 0 3
53728: PUSH
53729: LD_VAR 0 6
53733: PUSH
53734: FOR_IN
53735: IFFALSE 54754
// begin researching := false ;
53737: LD_ADDR_VAR 0 10
53741: PUSH
53742: LD_INT 0
53744: ST_TO_ADDR
// side := GetSide ( j ) ;
53745: LD_ADDR_VAR 0 4
53749: PUSH
53750: LD_VAR 0 3
53754: PPUSH
53755: CALL_OW 255
53759: ST_TO_ADDR
// if not mc_tech [ side ] then
53760: LD_EXP 127
53764: PUSH
53765: LD_VAR 0 4
53769: ARRAY
53770: NOT
53771: IFFALSE 53775
// continue ;
53773: GO 53734
// if BuildingStatus ( j ) = bs_idle then
53775: LD_VAR 0 3
53779: PPUSH
53780: CALL_OW 461
53784: PUSH
53785: LD_INT 2
53787: EQUAL
53788: IFFALSE 53976
// begin if idle_lab and UnitsInside ( j ) < 6 then
53790: LD_VAR 0 11
53794: PUSH
53795: LD_VAR 0 3
53799: PPUSH
53800: CALL_OW 313
53804: PUSH
53805: LD_INT 6
53807: LESS
53808: AND
53809: IFFALSE 53880
// begin tmp2 := UnitsInside ( idle_lab ) ;
53811: LD_ADDR_VAR 0 9
53815: PUSH
53816: LD_VAR 0 11
53820: PPUSH
53821: CALL_OW 313
53825: ST_TO_ADDR
// if tmp2 then
53826: LD_VAR 0 9
53830: IFFALSE 53872
// for x in tmp2 do
53832: LD_ADDR_VAR 0 7
53836: PUSH
53837: LD_VAR 0 9
53841: PUSH
53842: FOR_IN
53843: IFFALSE 53870
// begin ComExitBuilding ( x ) ;
53845: LD_VAR 0 7
53849: PPUSH
53850: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53854: LD_VAR 0 7
53858: PPUSH
53859: LD_VAR 0 3
53863: PPUSH
53864: CALL_OW 180
// end ;
53868: GO 53842
53870: POP
53871: POP
// idle_lab := 0 ;
53872: LD_ADDR_VAR 0 11
53876: PUSH
53877: LD_INT 0
53879: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53880: LD_ADDR_VAR 0 5
53884: PUSH
53885: LD_EXP 127
53889: PUSH
53890: LD_VAR 0 4
53894: ARRAY
53895: PUSH
53896: FOR_IN
53897: IFFALSE 53957
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53899: LD_VAR 0 3
53903: PPUSH
53904: LD_VAR 0 5
53908: PPUSH
53909: CALL_OW 430
53913: PUSH
53914: LD_VAR 0 4
53918: PPUSH
53919: LD_VAR 0 5
53923: PPUSH
53924: CALL 68438 0 2
53928: AND
53929: IFFALSE 53955
// begin researching := true ;
53931: LD_ADDR_VAR 0 10
53935: PUSH
53936: LD_INT 1
53938: ST_TO_ADDR
// ComResearch ( j , t ) ;
53939: LD_VAR 0 3
53943: PPUSH
53944: LD_VAR 0 5
53948: PPUSH
53949: CALL_OW 124
// break ;
53953: GO 53957
// end ;
53955: GO 53896
53957: POP
53958: POP
// if not researching then
53959: LD_VAR 0 10
53963: NOT
53964: IFFALSE 53976
// idle_lab := j ;
53966: LD_ADDR_VAR 0 11
53970: PUSH
53971: LD_VAR 0 3
53975: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53976: LD_VAR 0 3
53980: PPUSH
53981: CALL_OW 461
53985: PUSH
53986: LD_INT 10
53988: EQUAL
53989: IFFALSE 54577
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53991: LD_EXP 129
53995: PUSH
53996: LD_VAR 0 2
54000: ARRAY
54001: NOT
54002: PUSH
54003: LD_EXP 130
54007: PUSH
54008: LD_VAR 0 2
54012: ARRAY
54013: NOT
54014: AND
54015: PUSH
54016: LD_EXP 127
54020: PUSH
54021: LD_VAR 0 4
54025: ARRAY
54026: PUSH
54027: LD_INT 1
54029: GREATER
54030: AND
54031: IFFALSE 54162
// begin ComCancel ( j ) ;
54033: LD_VAR 0 3
54037: PPUSH
54038: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
54042: LD_ADDR_EXP 127
54046: PUSH
54047: LD_EXP 127
54051: PPUSH
54052: LD_VAR 0 4
54056: PPUSH
54057: LD_EXP 127
54061: PUSH
54062: LD_VAR 0 4
54066: ARRAY
54067: PPUSH
54068: LD_EXP 127
54072: PUSH
54073: LD_VAR 0 4
54077: ARRAY
54078: PUSH
54079: LD_INT 1
54081: MINUS
54082: PPUSH
54083: LD_EXP 127
54087: PUSH
54088: LD_VAR 0 4
54092: ARRAY
54093: PPUSH
54094: LD_INT 0
54096: PPUSH
54097: CALL 72137 0 4
54101: PPUSH
54102: CALL_OW 1
54106: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
54107: LD_ADDR_EXP 127
54111: PUSH
54112: LD_EXP 127
54116: PPUSH
54117: LD_VAR 0 4
54121: PPUSH
54122: LD_EXP 127
54126: PUSH
54127: LD_VAR 0 4
54131: ARRAY
54132: PPUSH
54133: LD_EXP 127
54137: PUSH
54138: LD_VAR 0 4
54142: ARRAY
54143: PPUSH
54144: LD_INT 1
54146: PPUSH
54147: LD_INT 0
54149: PPUSH
54150: CALL 72137 0 4
54154: PPUSH
54155: CALL_OW 1
54159: ST_TO_ADDR
// continue ;
54160: GO 53734
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
54162: LD_EXP 129
54166: PUSH
54167: LD_VAR 0 2
54171: ARRAY
54172: PUSH
54173: LD_EXP 130
54177: PUSH
54178: LD_VAR 0 2
54182: ARRAY
54183: NOT
54184: AND
54185: IFFALSE 54312
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
54187: LD_ADDR_EXP 130
54191: PUSH
54192: LD_EXP 130
54196: PPUSH
54197: LD_VAR 0 2
54201: PUSH
54202: LD_EXP 130
54206: PUSH
54207: LD_VAR 0 2
54211: ARRAY
54212: PUSH
54213: LD_INT 1
54215: PLUS
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PPUSH
54221: LD_EXP 129
54225: PUSH
54226: LD_VAR 0 2
54230: ARRAY
54231: PUSH
54232: LD_INT 1
54234: ARRAY
54235: PPUSH
54236: CALL 72719 0 3
54240: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
54241: LD_EXP 129
54245: PUSH
54246: LD_VAR 0 2
54250: ARRAY
54251: PUSH
54252: LD_INT 1
54254: ARRAY
54255: PPUSH
54256: LD_INT 112
54258: PPUSH
54259: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
54263: LD_ADDR_VAR 0 9
54267: PUSH
54268: LD_EXP 129
54272: PUSH
54273: LD_VAR 0 2
54277: ARRAY
54278: PPUSH
54279: LD_INT 1
54281: PPUSH
54282: CALL_OW 3
54286: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
54287: LD_ADDR_EXP 129
54291: PUSH
54292: LD_EXP 129
54296: PPUSH
54297: LD_VAR 0 2
54301: PPUSH
54302: LD_VAR 0 9
54306: PPUSH
54307: CALL_OW 1
54311: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
54312: LD_EXP 129
54316: PUSH
54317: LD_VAR 0 2
54321: ARRAY
54322: PUSH
54323: LD_EXP 130
54327: PUSH
54328: LD_VAR 0 2
54332: ARRAY
54333: AND
54334: PUSH
54335: LD_EXP 130
54339: PUSH
54340: LD_VAR 0 2
54344: ARRAY
54345: PUSH
54346: LD_INT 1
54348: ARRAY
54349: PPUSH
54350: CALL_OW 310
54354: NOT
54355: AND
54356: PUSH
54357: LD_VAR 0 3
54361: PPUSH
54362: CALL_OW 313
54366: PUSH
54367: LD_INT 6
54369: EQUAL
54370: AND
54371: IFFALSE 54427
// begin tmp2 := UnitsInside ( j ) ;
54373: LD_ADDR_VAR 0 9
54377: PUSH
54378: LD_VAR 0 3
54382: PPUSH
54383: CALL_OW 313
54387: ST_TO_ADDR
// if tmp2 = 6 then
54388: LD_VAR 0 9
54392: PUSH
54393: LD_INT 6
54395: EQUAL
54396: IFFALSE 54427
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54398: LD_VAR 0 9
54402: PUSH
54403: LD_INT 1
54405: ARRAY
54406: PPUSH
54407: LD_INT 112
54409: PPUSH
54410: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54414: LD_VAR 0 9
54418: PUSH
54419: LD_INT 1
54421: ARRAY
54422: PPUSH
54423: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54427: LD_EXP 130
54431: PUSH
54432: LD_VAR 0 2
54436: ARRAY
54437: PUSH
54438: LD_EXP 130
54442: PUSH
54443: LD_VAR 0 2
54447: ARRAY
54448: PUSH
54449: LD_INT 1
54451: ARRAY
54452: PPUSH
54453: CALL_OW 314
54457: NOT
54458: AND
54459: PUSH
54460: LD_EXP 130
54464: PUSH
54465: LD_VAR 0 2
54469: ARRAY
54470: PUSH
54471: LD_INT 1
54473: ARRAY
54474: PPUSH
54475: CALL_OW 310
54479: NOT
54480: AND
54481: IFFALSE 54507
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54483: LD_EXP 130
54487: PUSH
54488: LD_VAR 0 2
54492: ARRAY
54493: PUSH
54494: LD_INT 1
54496: ARRAY
54497: PPUSH
54498: LD_VAR 0 3
54502: PPUSH
54503: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54507: LD_EXP 130
54511: PUSH
54512: LD_VAR 0 2
54516: ARRAY
54517: PUSH
54518: LD_INT 1
54520: ARRAY
54521: PPUSH
54522: CALL_OW 310
54526: PUSH
54527: LD_EXP 130
54531: PUSH
54532: LD_VAR 0 2
54536: ARRAY
54537: PUSH
54538: LD_INT 1
54540: ARRAY
54541: PPUSH
54542: CALL_OW 310
54546: PPUSH
54547: CALL_OW 461
54551: PUSH
54552: LD_INT 3
54554: NONEQUAL
54555: AND
54556: IFFALSE 54577
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54558: LD_EXP 130
54562: PUSH
54563: LD_VAR 0 2
54567: ARRAY
54568: PUSH
54569: LD_INT 1
54571: ARRAY
54572: PPUSH
54573: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54577: LD_VAR 0 3
54581: PPUSH
54582: CALL_OW 461
54586: PUSH
54587: LD_INT 6
54589: EQUAL
54590: PUSH
54591: LD_VAR 0 6
54595: PUSH
54596: LD_INT 1
54598: GREATER
54599: AND
54600: IFFALSE 54752
// begin sci := [ ] ;
54602: LD_ADDR_VAR 0 8
54606: PUSH
54607: EMPTY
54608: ST_TO_ADDR
// for x in ( tmp diff j ) do
54609: LD_ADDR_VAR 0 7
54613: PUSH
54614: LD_VAR 0 6
54618: PUSH
54619: LD_VAR 0 3
54623: DIFF
54624: PUSH
54625: FOR_IN
54626: IFFALSE 54678
// begin if sci = 6 then
54628: LD_VAR 0 8
54632: PUSH
54633: LD_INT 6
54635: EQUAL
54636: IFFALSE 54640
// break ;
54638: GO 54678
// if BuildingStatus ( x ) = bs_idle then
54640: LD_VAR 0 7
54644: PPUSH
54645: CALL_OW 461
54649: PUSH
54650: LD_INT 2
54652: EQUAL
54653: IFFALSE 54676
// sci := sci ^ UnitsInside ( x ) ;
54655: LD_ADDR_VAR 0 8
54659: PUSH
54660: LD_VAR 0 8
54664: PUSH
54665: LD_VAR 0 7
54669: PPUSH
54670: CALL_OW 313
54674: ADD
54675: ST_TO_ADDR
// end ;
54676: GO 54625
54678: POP
54679: POP
// if not sci then
54680: LD_VAR 0 8
54684: NOT
54685: IFFALSE 54689
// continue ;
54687: GO 53734
// for x in sci do
54689: LD_ADDR_VAR 0 7
54693: PUSH
54694: LD_VAR 0 8
54698: PUSH
54699: FOR_IN
54700: IFFALSE 54750
// if IsInUnit ( x ) and not HasTask ( x ) then
54702: LD_VAR 0 7
54706: PPUSH
54707: CALL_OW 310
54711: PUSH
54712: LD_VAR 0 7
54716: PPUSH
54717: CALL_OW 314
54721: NOT
54722: AND
54723: IFFALSE 54748
// begin ComExitBuilding ( x ) ;
54725: LD_VAR 0 7
54729: PPUSH
54730: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54734: LD_VAR 0 7
54738: PPUSH
54739: LD_VAR 0 3
54743: PPUSH
54744: CALL_OW 180
// end ;
54748: GO 54699
54750: POP
54751: POP
// end ; end ;
54752: GO 53734
54754: POP
54755: POP
// end ;
54756: GO 53688
54758: POP
54759: POP
// end ;
54760: LD_VAR 0 1
54764: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54765: LD_INT 0
54767: PPUSH
54768: PPUSH
// if not mc_bases then
54769: LD_EXP 100
54773: NOT
54774: IFFALSE 54778
// exit ;
54776: GO 54859
// for i = 1 to mc_bases do
54778: LD_ADDR_VAR 0 2
54782: PUSH
54783: DOUBLE
54784: LD_INT 1
54786: DEC
54787: ST_TO_ADDR
54788: LD_EXP 100
54792: PUSH
54793: FOR_TO
54794: IFFALSE 54857
// if mc_mines [ i ] and mc_miners [ i ] then
54796: LD_EXP 113
54800: PUSH
54801: LD_VAR 0 2
54805: ARRAY
54806: PUSH
54807: LD_EXP 114
54811: PUSH
54812: LD_VAR 0 2
54816: ARRAY
54817: AND
54818: IFFALSE 54855
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54820: LD_EXP 114
54824: PUSH
54825: LD_VAR 0 2
54829: ARRAY
54830: PUSH
54831: LD_INT 1
54833: ARRAY
54834: PPUSH
54835: CALL_OW 255
54839: PPUSH
54840: LD_EXP 113
54844: PUSH
54845: LD_VAR 0 2
54849: ARRAY
54850: PPUSH
54851: CALL 69521 0 2
54855: GO 54793
54857: POP
54858: POP
// end ;
54859: LD_VAR 0 1
54863: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54864: LD_INT 0
54866: PPUSH
54867: PPUSH
54868: PPUSH
54869: PPUSH
54870: PPUSH
54871: PPUSH
54872: PPUSH
54873: PPUSH
// if not mc_bases or not mc_parking then
54874: LD_EXP 100
54878: NOT
54879: PUSH
54880: LD_EXP 124
54884: NOT
54885: OR
54886: IFFALSE 54890
// exit ;
54888: GO 55628
// for i = 1 to mc_bases do
54890: LD_ADDR_VAR 0 2
54894: PUSH
54895: DOUBLE
54896: LD_INT 1
54898: DEC
54899: ST_TO_ADDR
54900: LD_EXP 100
54904: PUSH
54905: FOR_TO
54906: IFFALSE 55626
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54908: LD_EXP 100
54912: PUSH
54913: LD_VAR 0 2
54917: ARRAY
54918: NOT
54919: PUSH
54920: LD_EXP 124
54924: PUSH
54925: LD_VAR 0 2
54929: ARRAY
54930: NOT
54931: OR
54932: IFFALSE 54936
// continue ;
54934: GO 54905
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54936: LD_ADDR_VAR 0 5
54940: PUSH
54941: LD_EXP 100
54945: PUSH
54946: LD_VAR 0 2
54950: ARRAY
54951: PUSH
54952: LD_INT 1
54954: ARRAY
54955: PPUSH
54956: CALL_OW 255
54960: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54961: LD_ADDR_VAR 0 6
54965: PUSH
54966: LD_EXP 100
54970: PUSH
54971: LD_VAR 0 2
54975: ARRAY
54976: PPUSH
54977: LD_INT 30
54979: PUSH
54980: LD_INT 3
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PPUSH
54987: CALL_OW 72
54991: ST_TO_ADDR
// if not fac then
54992: LD_VAR 0 6
54996: NOT
54997: IFFALSE 55048
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54999: LD_ADDR_VAR 0 6
55003: PUSH
55004: LD_EXP 100
55008: PUSH
55009: LD_VAR 0 2
55013: ARRAY
55014: PPUSH
55015: LD_INT 2
55017: PUSH
55018: LD_INT 30
55020: PUSH
55021: LD_INT 0
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: PUSH
55028: LD_INT 30
55030: PUSH
55031: LD_INT 1
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: LIST
55042: PPUSH
55043: CALL_OW 72
55047: ST_TO_ADDR
// if not fac then
55048: LD_VAR 0 6
55052: NOT
55053: IFFALSE 55057
// continue ;
55055: GO 54905
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55057: LD_ADDR_VAR 0 7
55061: PUSH
55062: LD_EXP 124
55066: PUSH
55067: LD_VAR 0 2
55071: ARRAY
55072: PPUSH
55073: LD_INT 22
55075: PUSH
55076: LD_VAR 0 5
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: PUSH
55085: LD_INT 21
55087: PUSH
55088: LD_INT 2
55090: PUSH
55091: EMPTY
55092: LIST
55093: LIST
55094: PUSH
55095: LD_INT 3
55097: PUSH
55098: LD_INT 60
55100: PUSH
55101: EMPTY
55102: LIST
55103: PUSH
55104: EMPTY
55105: LIST
55106: LIST
55107: PUSH
55108: LD_INT 3
55110: PUSH
55111: LD_INT 24
55113: PUSH
55114: LD_INT 1000
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: LIST
55129: LIST
55130: PPUSH
55131: CALL_OW 70
55135: ST_TO_ADDR
// for j in fac do
55136: LD_ADDR_VAR 0 3
55140: PUSH
55141: LD_VAR 0 6
55145: PUSH
55146: FOR_IN
55147: IFFALSE 55242
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55149: LD_ADDR_VAR 0 7
55153: PUSH
55154: LD_VAR 0 7
55158: PUSH
55159: LD_INT 22
55161: PUSH
55162: LD_VAR 0 5
55166: PUSH
55167: EMPTY
55168: LIST
55169: LIST
55170: PUSH
55171: LD_INT 91
55173: PUSH
55174: LD_VAR 0 3
55178: PUSH
55179: LD_INT 15
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: LIST
55186: PUSH
55187: LD_INT 21
55189: PUSH
55190: LD_INT 2
55192: PUSH
55193: EMPTY
55194: LIST
55195: LIST
55196: PUSH
55197: LD_INT 3
55199: PUSH
55200: LD_INT 60
55202: PUSH
55203: EMPTY
55204: LIST
55205: PUSH
55206: EMPTY
55207: LIST
55208: LIST
55209: PUSH
55210: LD_INT 3
55212: PUSH
55213: LD_INT 24
55215: PUSH
55216: LD_INT 1000
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: PUSH
55227: EMPTY
55228: LIST
55229: LIST
55230: LIST
55231: LIST
55232: LIST
55233: PPUSH
55234: CALL_OW 69
55238: UNION
55239: ST_TO_ADDR
55240: GO 55146
55242: POP
55243: POP
// if not vehs then
55244: LD_VAR 0 7
55248: NOT
55249: IFFALSE 55275
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55251: LD_ADDR_EXP 112
55255: PUSH
55256: LD_EXP 112
55260: PPUSH
55261: LD_VAR 0 2
55265: PPUSH
55266: EMPTY
55267: PPUSH
55268: CALL_OW 1
55272: ST_TO_ADDR
// continue ;
55273: GO 54905
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55275: LD_ADDR_VAR 0 8
55279: PUSH
55280: LD_EXP 100
55284: PUSH
55285: LD_VAR 0 2
55289: ARRAY
55290: PPUSH
55291: LD_INT 30
55293: PUSH
55294: LD_INT 3
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: PPUSH
55301: CALL_OW 72
55305: ST_TO_ADDR
// if tmp then
55306: LD_VAR 0 8
55310: IFFALSE 55413
// begin for j in tmp do
55312: LD_ADDR_VAR 0 3
55316: PUSH
55317: LD_VAR 0 8
55321: PUSH
55322: FOR_IN
55323: IFFALSE 55411
// for k in UnitsInside ( j ) do
55325: LD_ADDR_VAR 0 4
55329: PUSH
55330: LD_VAR 0 3
55334: PPUSH
55335: CALL_OW 313
55339: PUSH
55340: FOR_IN
55341: IFFALSE 55407
// if k then
55343: LD_VAR 0 4
55347: IFFALSE 55405
// if not k in mc_repair_vehicle [ i ] then
55349: LD_VAR 0 4
55353: PUSH
55354: LD_EXP 112
55358: PUSH
55359: LD_VAR 0 2
55363: ARRAY
55364: IN
55365: NOT
55366: IFFALSE 55405
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55368: LD_ADDR_EXP 112
55372: PUSH
55373: LD_EXP 112
55377: PPUSH
55378: LD_VAR 0 2
55382: PPUSH
55383: LD_EXP 112
55387: PUSH
55388: LD_VAR 0 2
55392: ARRAY
55393: PUSH
55394: LD_VAR 0 4
55398: UNION
55399: PPUSH
55400: CALL_OW 1
55404: ST_TO_ADDR
55405: GO 55340
55407: POP
55408: POP
55409: GO 55322
55411: POP
55412: POP
// end ; if not mc_repair_vehicle [ i ] then
55413: LD_EXP 112
55417: PUSH
55418: LD_VAR 0 2
55422: ARRAY
55423: NOT
55424: IFFALSE 55428
// continue ;
55426: GO 54905
// for j in mc_repair_vehicle [ i ] do
55428: LD_ADDR_VAR 0 3
55432: PUSH
55433: LD_EXP 112
55437: PUSH
55438: LD_VAR 0 2
55442: ARRAY
55443: PUSH
55444: FOR_IN
55445: IFFALSE 55622
// begin if GetClass ( j ) <> 3 then
55447: LD_VAR 0 3
55451: PPUSH
55452: CALL_OW 257
55456: PUSH
55457: LD_INT 3
55459: NONEQUAL
55460: IFFALSE 55501
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55462: LD_ADDR_EXP 112
55466: PUSH
55467: LD_EXP 112
55471: PPUSH
55472: LD_VAR 0 2
55476: PPUSH
55477: LD_EXP 112
55481: PUSH
55482: LD_VAR 0 2
55486: ARRAY
55487: PUSH
55488: LD_VAR 0 3
55492: DIFF
55493: PPUSH
55494: CALL_OW 1
55498: ST_TO_ADDR
// continue ;
55499: GO 55444
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55501: LD_VAR 0 3
55505: PPUSH
55506: CALL_OW 311
55510: NOT
55511: PUSH
55512: LD_VAR 0 3
55516: PUSH
55517: LD_EXP 103
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PUSH
55528: LD_INT 1
55530: ARRAY
55531: IN
55532: NOT
55533: AND
55534: PUSH
55535: LD_VAR 0 3
55539: PUSH
55540: LD_EXP 103
55544: PUSH
55545: LD_VAR 0 2
55549: ARRAY
55550: PUSH
55551: LD_INT 2
55553: ARRAY
55554: IN
55555: NOT
55556: AND
55557: IFFALSE 55620
// begin if IsInUnit ( j ) then
55559: LD_VAR 0 3
55563: PPUSH
55564: CALL_OW 310
55568: IFFALSE 55581
// ComExitBuilding ( j ) else
55570: LD_VAR 0 3
55574: PPUSH
55575: CALL_OW 122
55579: GO 55620
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55581: LD_VAR 0 3
55585: PPUSH
55586: LD_VAR 0 7
55590: PUSH
55591: LD_INT 1
55593: ARRAY
55594: PPUSH
55595: CALL 107115 0 2
55599: NOT
55600: IFFALSE 55620
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55602: LD_VAR 0 3
55606: PPUSH
55607: LD_VAR 0 7
55611: PUSH
55612: LD_INT 1
55614: ARRAY
55615: PPUSH
55616: CALL_OW 129
// end ; end ;
55620: GO 55444
55622: POP
55623: POP
// end ;
55624: GO 54905
55626: POP
55627: POP
// end ;
55628: LD_VAR 0 1
55632: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55633: LD_INT 0
55635: PPUSH
55636: PPUSH
55637: PPUSH
55638: PPUSH
55639: PPUSH
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
55644: PPUSH
55645: PPUSH
// if not mc_bases then
55646: LD_EXP 100
55650: NOT
55651: IFFALSE 55655
// exit ;
55653: GO 56457
// for i = 1 to mc_bases do
55655: LD_ADDR_VAR 0 2
55659: PUSH
55660: DOUBLE
55661: LD_INT 1
55663: DEC
55664: ST_TO_ADDR
55665: LD_EXP 100
55669: PUSH
55670: FOR_TO
55671: IFFALSE 56455
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55673: LD_EXP 128
55677: PUSH
55678: LD_VAR 0 2
55682: ARRAY
55683: NOT
55684: PUSH
55685: LD_EXP 103
55689: PUSH
55690: LD_VAR 0 2
55694: ARRAY
55695: PUSH
55696: LD_INT 1
55698: ARRAY
55699: OR
55700: PUSH
55701: LD_EXP 103
55705: PUSH
55706: LD_VAR 0 2
55710: ARRAY
55711: PUSH
55712: LD_INT 2
55714: ARRAY
55715: OR
55716: PUSH
55717: LD_EXP 126
55721: PUSH
55722: LD_VAR 0 2
55726: ARRAY
55727: PPUSH
55728: LD_INT 1
55730: PPUSH
55731: CALL_OW 325
55735: NOT
55736: OR
55737: PUSH
55738: LD_EXP 123
55742: PUSH
55743: LD_VAR 0 2
55747: ARRAY
55748: OR
55749: IFFALSE 55753
// continue ;
55751: GO 55670
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55753: LD_ADDR_VAR 0 8
55757: PUSH
55758: LD_EXP 100
55762: PUSH
55763: LD_VAR 0 2
55767: ARRAY
55768: PPUSH
55769: LD_INT 25
55771: PUSH
55772: LD_INT 4
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: PUSH
55779: LD_INT 50
55781: PUSH
55782: EMPTY
55783: LIST
55784: PUSH
55785: LD_INT 3
55787: PUSH
55788: LD_INT 60
55790: PUSH
55791: EMPTY
55792: LIST
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PUSH
55798: EMPTY
55799: LIST
55800: LIST
55801: LIST
55802: PPUSH
55803: CALL_OW 72
55807: PUSH
55808: LD_EXP 104
55812: PUSH
55813: LD_VAR 0 2
55817: ARRAY
55818: DIFF
55819: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55820: LD_ADDR_VAR 0 9
55824: PUSH
55825: LD_EXP 100
55829: PUSH
55830: LD_VAR 0 2
55834: ARRAY
55835: PPUSH
55836: LD_INT 2
55838: PUSH
55839: LD_INT 30
55841: PUSH
55842: LD_INT 0
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PUSH
55849: LD_INT 30
55851: PUSH
55852: LD_INT 1
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: PPUSH
55864: CALL_OW 72
55868: ST_TO_ADDR
// if not tmp or not dep then
55869: LD_VAR 0 8
55873: NOT
55874: PUSH
55875: LD_VAR 0 9
55879: NOT
55880: OR
55881: IFFALSE 55885
// continue ;
55883: GO 55670
// side := GetSide ( tmp [ 1 ] ) ;
55885: LD_ADDR_VAR 0 11
55889: PUSH
55890: LD_VAR 0 8
55894: PUSH
55895: LD_INT 1
55897: ARRAY
55898: PPUSH
55899: CALL_OW 255
55903: ST_TO_ADDR
// dep := dep [ 1 ] ;
55904: LD_ADDR_VAR 0 9
55908: PUSH
55909: LD_VAR 0 9
55913: PUSH
55914: LD_INT 1
55916: ARRAY
55917: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55918: LD_ADDR_VAR 0 7
55922: PUSH
55923: LD_EXP 128
55927: PUSH
55928: LD_VAR 0 2
55932: ARRAY
55933: PPUSH
55934: LD_INT 22
55936: PUSH
55937: LD_INT 0
55939: PUSH
55940: EMPTY
55941: LIST
55942: LIST
55943: PUSH
55944: LD_INT 25
55946: PUSH
55947: LD_INT 12
55949: PUSH
55950: EMPTY
55951: LIST
55952: LIST
55953: PUSH
55954: EMPTY
55955: LIST
55956: LIST
55957: PPUSH
55958: CALL_OW 70
55962: PUSH
55963: LD_INT 22
55965: PUSH
55966: LD_INT 0
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: PUSH
55973: LD_INT 25
55975: PUSH
55976: LD_INT 12
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: PUSH
55983: LD_INT 91
55985: PUSH
55986: LD_VAR 0 9
55990: PUSH
55991: LD_INT 20
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: LIST
55998: PUSH
55999: EMPTY
56000: LIST
56001: LIST
56002: LIST
56003: PPUSH
56004: CALL_OW 69
56008: UNION
56009: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
56010: LD_ADDR_VAR 0 10
56014: PUSH
56015: LD_EXP 128
56019: PUSH
56020: LD_VAR 0 2
56024: ARRAY
56025: PPUSH
56026: LD_INT 81
56028: PUSH
56029: LD_VAR 0 11
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: PPUSH
56038: CALL_OW 70
56042: ST_TO_ADDR
// if not apes or danger_at_area then
56043: LD_VAR 0 7
56047: NOT
56048: PUSH
56049: LD_VAR 0 10
56053: OR
56054: IFFALSE 56104
// begin if mc_taming [ i ] then
56056: LD_EXP 131
56060: PUSH
56061: LD_VAR 0 2
56065: ARRAY
56066: IFFALSE 56102
// begin MC_Reset ( i , 121 ) ;
56068: LD_VAR 0 2
56072: PPUSH
56073: LD_INT 121
56075: PPUSH
56076: CALL 41041 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56080: LD_ADDR_EXP 131
56084: PUSH
56085: LD_EXP 131
56089: PPUSH
56090: LD_VAR 0 2
56094: PPUSH
56095: EMPTY
56096: PPUSH
56097: CALL_OW 1
56101: ST_TO_ADDR
// end ; continue ;
56102: GO 55670
// end ; for j in tmp do
56104: LD_ADDR_VAR 0 3
56108: PUSH
56109: LD_VAR 0 8
56113: PUSH
56114: FOR_IN
56115: IFFALSE 56451
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
56117: LD_VAR 0 3
56121: PUSH
56122: LD_EXP 131
56126: PUSH
56127: LD_VAR 0 2
56131: ARRAY
56132: IN
56133: NOT
56134: PUSH
56135: LD_EXP 131
56139: PUSH
56140: LD_VAR 0 2
56144: ARRAY
56145: PUSH
56146: LD_INT 3
56148: LESS
56149: AND
56150: IFFALSE 56208
// begin SetTag ( j , 121 ) ;
56152: LD_VAR 0 3
56156: PPUSH
56157: LD_INT 121
56159: PPUSH
56160: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
56164: LD_ADDR_EXP 131
56168: PUSH
56169: LD_EXP 131
56173: PPUSH
56174: LD_VAR 0 2
56178: PUSH
56179: LD_EXP 131
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: PUSH
56190: LD_INT 1
56192: PLUS
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: PPUSH
56198: LD_VAR 0 3
56202: PPUSH
56203: CALL 72719 0 3
56207: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
56208: LD_VAR 0 3
56212: PUSH
56213: LD_EXP 131
56217: PUSH
56218: LD_VAR 0 2
56222: ARRAY
56223: IN
56224: IFFALSE 56449
// begin if GetClass ( j ) <> 4 then
56226: LD_VAR 0 3
56230: PPUSH
56231: CALL_OW 257
56235: PUSH
56236: LD_INT 4
56238: NONEQUAL
56239: IFFALSE 56292
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
56241: LD_ADDR_EXP 131
56245: PUSH
56246: LD_EXP 131
56250: PPUSH
56251: LD_VAR 0 2
56255: PPUSH
56256: LD_EXP 131
56260: PUSH
56261: LD_VAR 0 2
56265: ARRAY
56266: PUSH
56267: LD_VAR 0 3
56271: DIFF
56272: PPUSH
56273: CALL_OW 1
56277: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56278: LD_VAR 0 3
56282: PPUSH
56283: LD_INT 0
56285: PPUSH
56286: CALL_OW 109
// continue ;
56290: GO 56114
// end ; if IsInUnit ( j ) then
56292: LD_VAR 0 3
56296: PPUSH
56297: CALL_OW 310
56301: IFFALSE 56312
// ComExitBuilding ( j ) ;
56303: LD_VAR 0 3
56307: PPUSH
56308: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
56312: LD_ADDR_VAR 0 6
56316: PUSH
56317: LD_VAR 0 7
56321: PPUSH
56322: LD_VAR 0 3
56326: PPUSH
56327: CALL_OW 74
56331: ST_TO_ADDR
// if not ape then
56332: LD_VAR 0 6
56336: NOT
56337: IFFALSE 56341
// break ;
56339: GO 56451
// x := GetX ( ape ) ;
56341: LD_ADDR_VAR 0 4
56345: PUSH
56346: LD_VAR 0 6
56350: PPUSH
56351: CALL_OW 250
56355: ST_TO_ADDR
// y := GetY ( ape ) ;
56356: LD_ADDR_VAR 0 5
56360: PUSH
56361: LD_VAR 0 6
56365: PPUSH
56366: CALL_OW 251
56370: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56371: LD_VAR 0 4
56375: PPUSH
56376: LD_VAR 0 5
56380: PPUSH
56381: CALL_OW 488
56385: NOT
56386: PUSH
56387: LD_VAR 0 11
56391: PPUSH
56392: LD_VAR 0 4
56396: PPUSH
56397: LD_VAR 0 5
56401: PPUSH
56402: LD_INT 20
56404: PPUSH
56405: CALL 73615 0 4
56409: PUSH
56410: LD_INT 4
56412: ARRAY
56413: OR
56414: IFFALSE 56418
// break ;
56416: GO 56451
// if not HasTask ( j ) then
56418: LD_VAR 0 3
56422: PPUSH
56423: CALL_OW 314
56427: NOT
56428: IFFALSE 56449
// ComTameXY ( j , x , y ) ;
56430: LD_VAR 0 3
56434: PPUSH
56435: LD_VAR 0 4
56439: PPUSH
56440: LD_VAR 0 5
56444: PPUSH
56445: CALL_OW 131
// end ; end ;
56449: GO 56114
56451: POP
56452: POP
// end ;
56453: GO 55670
56455: POP
56456: POP
// end ;
56457: LD_VAR 0 1
56461: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56462: LD_INT 0
56464: PPUSH
56465: PPUSH
56466: PPUSH
56467: PPUSH
56468: PPUSH
56469: PPUSH
56470: PPUSH
56471: PPUSH
// if not mc_bases then
56472: LD_EXP 100
56476: NOT
56477: IFFALSE 56481
// exit ;
56479: GO 57107
// for i = 1 to mc_bases do
56481: LD_ADDR_VAR 0 2
56485: PUSH
56486: DOUBLE
56487: LD_INT 1
56489: DEC
56490: ST_TO_ADDR
56491: LD_EXP 100
56495: PUSH
56496: FOR_TO
56497: IFFALSE 57105
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56499: LD_EXP 129
56503: PUSH
56504: LD_VAR 0 2
56508: ARRAY
56509: NOT
56510: PUSH
56511: LD_EXP 129
56515: PUSH
56516: LD_VAR 0 2
56520: ARRAY
56521: PPUSH
56522: LD_INT 25
56524: PUSH
56525: LD_INT 12
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PPUSH
56532: CALL_OW 72
56536: NOT
56537: OR
56538: IFFALSE 56542
// continue ;
56540: GO 56496
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56542: LD_ADDR_VAR 0 5
56546: PUSH
56547: LD_EXP 129
56551: PUSH
56552: LD_VAR 0 2
56556: ARRAY
56557: PUSH
56558: LD_INT 1
56560: ARRAY
56561: PPUSH
56562: CALL_OW 255
56566: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56567: LD_VAR 0 5
56571: PPUSH
56572: LD_INT 2
56574: PPUSH
56575: CALL_OW 325
56579: IFFALSE 56832
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56581: LD_ADDR_VAR 0 4
56585: PUSH
56586: LD_EXP 129
56590: PUSH
56591: LD_VAR 0 2
56595: ARRAY
56596: PPUSH
56597: LD_INT 25
56599: PUSH
56600: LD_INT 16
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PPUSH
56607: CALL_OW 72
56611: ST_TO_ADDR
// if tmp < 6 then
56612: LD_VAR 0 4
56616: PUSH
56617: LD_INT 6
56619: LESS
56620: IFFALSE 56832
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56622: LD_ADDR_VAR 0 6
56626: PUSH
56627: LD_EXP 100
56631: PUSH
56632: LD_VAR 0 2
56636: ARRAY
56637: PPUSH
56638: LD_INT 2
56640: PUSH
56641: LD_INT 30
56643: PUSH
56644: LD_INT 0
56646: PUSH
56647: EMPTY
56648: LIST
56649: LIST
56650: PUSH
56651: LD_INT 30
56653: PUSH
56654: LD_INT 1
56656: PUSH
56657: EMPTY
56658: LIST
56659: LIST
56660: PUSH
56661: EMPTY
56662: LIST
56663: LIST
56664: LIST
56665: PPUSH
56666: CALL_OW 72
56670: ST_TO_ADDR
// if depot then
56671: LD_VAR 0 6
56675: IFFALSE 56832
// begin selected := 0 ;
56677: LD_ADDR_VAR 0 7
56681: PUSH
56682: LD_INT 0
56684: ST_TO_ADDR
// for j in depot do
56685: LD_ADDR_VAR 0 3
56689: PUSH
56690: LD_VAR 0 6
56694: PUSH
56695: FOR_IN
56696: IFFALSE 56727
// begin if UnitsInside ( j ) < 6 then
56698: LD_VAR 0 3
56702: PPUSH
56703: CALL_OW 313
56707: PUSH
56708: LD_INT 6
56710: LESS
56711: IFFALSE 56725
// begin selected := j ;
56713: LD_ADDR_VAR 0 7
56717: PUSH
56718: LD_VAR 0 3
56722: ST_TO_ADDR
// break ;
56723: GO 56727
// end ; end ;
56725: GO 56695
56727: POP
56728: POP
// if selected then
56729: LD_VAR 0 7
56733: IFFALSE 56832
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56735: LD_ADDR_VAR 0 3
56739: PUSH
56740: LD_EXP 129
56744: PUSH
56745: LD_VAR 0 2
56749: ARRAY
56750: PPUSH
56751: LD_INT 25
56753: PUSH
56754: LD_INT 12
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PPUSH
56761: CALL_OW 72
56765: PUSH
56766: FOR_IN
56767: IFFALSE 56830
// if not HasTask ( j ) then
56769: LD_VAR 0 3
56773: PPUSH
56774: CALL_OW 314
56778: NOT
56779: IFFALSE 56828
// begin if not IsInUnit ( j ) then
56781: LD_VAR 0 3
56785: PPUSH
56786: CALL_OW 310
56790: NOT
56791: IFFALSE 56807
// ComEnterUnit ( j , selected ) ;
56793: LD_VAR 0 3
56797: PPUSH
56798: LD_VAR 0 7
56802: PPUSH
56803: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56807: LD_VAR 0 3
56811: PPUSH
56812: LD_INT 16
56814: PPUSH
56815: CALL_OW 183
// AddComExitBuilding ( j ) ;
56819: LD_VAR 0 3
56823: PPUSH
56824: CALL_OW 182
// end ;
56828: GO 56766
56830: POP
56831: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56832: LD_VAR 0 5
56836: PPUSH
56837: LD_INT 11
56839: PPUSH
56840: CALL_OW 325
56844: IFFALSE 57103
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56846: LD_ADDR_VAR 0 4
56850: PUSH
56851: LD_EXP 129
56855: PUSH
56856: LD_VAR 0 2
56860: ARRAY
56861: PPUSH
56862: LD_INT 25
56864: PUSH
56865: LD_INT 16
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PPUSH
56872: CALL_OW 72
56876: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56877: LD_VAR 0 4
56881: PUSH
56882: LD_INT 6
56884: GREATEREQUAL
56885: PUSH
56886: LD_VAR 0 5
56890: PPUSH
56891: LD_INT 2
56893: PPUSH
56894: CALL_OW 325
56898: NOT
56899: OR
56900: IFFALSE 57103
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56902: LD_ADDR_VAR 0 8
56906: PUSH
56907: LD_EXP 100
56911: PUSH
56912: LD_VAR 0 2
56916: ARRAY
56917: PPUSH
56918: LD_INT 2
56920: PUSH
56921: LD_INT 30
56923: PUSH
56924: LD_INT 4
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: PUSH
56931: LD_INT 30
56933: PUSH
56934: LD_INT 5
56936: PUSH
56937: EMPTY
56938: LIST
56939: LIST
56940: PUSH
56941: EMPTY
56942: LIST
56943: LIST
56944: LIST
56945: PPUSH
56946: CALL_OW 72
56950: ST_TO_ADDR
// if barracks then
56951: LD_VAR 0 8
56955: IFFALSE 57103
// begin selected := 0 ;
56957: LD_ADDR_VAR 0 7
56961: PUSH
56962: LD_INT 0
56964: ST_TO_ADDR
// for j in barracks do
56965: LD_ADDR_VAR 0 3
56969: PUSH
56970: LD_VAR 0 8
56974: PUSH
56975: FOR_IN
56976: IFFALSE 57007
// begin if UnitsInside ( j ) < 6 then
56978: LD_VAR 0 3
56982: PPUSH
56983: CALL_OW 313
56987: PUSH
56988: LD_INT 6
56990: LESS
56991: IFFALSE 57005
// begin selected := j ;
56993: LD_ADDR_VAR 0 7
56997: PUSH
56998: LD_VAR 0 3
57002: ST_TO_ADDR
// break ;
57003: GO 57007
// end ; end ;
57005: GO 56975
57007: POP
57008: POP
// if selected then
57009: LD_VAR 0 7
57013: IFFALSE 57103
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57015: LD_ADDR_VAR 0 3
57019: PUSH
57020: LD_EXP 129
57024: PUSH
57025: LD_VAR 0 2
57029: ARRAY
57030: PPUSH
57031: LD_INT 25
57033: PUSH
57034: LD_INT 12
57036: PUSH
57037: EMPTY
57038: LIST
57039: LIST
57040: PPUSH
57041: CALL_OW 72
57045: PUSH
57046: FOR_IN
57047: IFFALSE 57101
// if not IsInUnit ( j ) and not HasTask ( j ) then
57049: LD_VAR 0 3
57053: PPUSH
57054: CALL_OW 310
57058: NOT
57059: PUSH
57060: LD_VAR 0 3
57064: PPUSH
57065: CALL_OW 314
57069: NOT
57070: AND
57071: IFFALSE 57099
// begin ComEnterUnit ( j , selected ) ;
57073: LD_VAR 0 3
57077: PPUSH
57078: LD_VAR 0 7
57082: PPUSH
57083: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
57087: LD_VAR 0 3
57091: PPUSH
57092: LD_INT 15
57094: PPUSH
57095: CALL_OW 183
// end ;
57099: GO 57046
57101: POP
57102: POP
// end ; end ; end ; end ; end ;
57103: GO 56496
57105: POP
57106: POP
// end ;
57107: LD_VAR 0 1
57111: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
57112: LD_INT 0
57114: PPUSH
57115: PPUSH
57116: PPUSH
57117: PPUSH
// if not mc_bases then
57118: LD_EXP 100
57122: NOT
57123: IFFALSE 57127
// exit ;
57125: GO 57305
// for i = 1 to mc_bases do
57127: LD_ADDR_VAR 0 2
57131: PUSH
57132: DOUBLE
57133: LD_INT 1
57135: DEC
57136: ST_TO_ADDR
57137: LD_EXP 100
57141: PUSH
57142: FOR_TO
57143: IFFALSE 57303
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
57145: LD_ADDR_VAR 0 4
57149: PUSH
57150: LD_EXP 100
57154: PUSH
57155: LD_VAR 0 2
57159: ARRAY
57160: PPUSH
57161: LD_INT 25
57163: PUSH
57164: LD_INT 9
57166: PUSH
57167: EMPTY
57168: LIST
57169: LIST
57170: PPUSH
57171: CALL_OW 72
57175: ST_TO_ADDR
// if not tmp then
57176: LD_VAR 0 4
57180: NOT
57181: IFFALSE 57185
// continue ;
57183: GO 57142
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
57185: LD_EXP 126
57189: PUSH
57190: LD_VAR 0 2
57194: ARRAY
57195: PPUSH
57196: LD_INT 29
57198: PPUSH
57199: CALL_OW 325
57203: NOT
57204: PUSH
57205: LD_EXP 126
57209: PUSH
57210: LD_VAR 0 2
57214: ARRAY
57215: PPUSH
57216: LD_INT 28
57218: PPUSH
57219: CALL_OW 325
57223: NOT
57224: AND
57225: IFFALSE 57229
// continue ;
57227: GO 57142
// for j in tmp do
57229: LD_ADDR_VAR 0 3
57233: PUSH
57234: LD_VAR 0 4
57238: PUSH
57239: FOR_IN
57240: IFFALSE 57299
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57242: LD_VAR 0 3
57246: PUSH
57247: LD_EXP 103
57251: PUSH
57252: LD_VAR 0 2
57256: ARRAY
57257: PUSH
57258: LD_INT 1
57260: ARRAY
57261: IN
57262: NOT
57263: PUSH
57264: LD_VAR 0 3
57268: PUSH
57269: LD_EXP 103
57273: PUSH
57274: LD_VAR 0 2
57278: ARRAY
57279: PUSH
57280: LD_INT 2
57282: ARRAY
57283: IN
57284: NOT
57285: AND
57286: IFFALSE 57297
// ComSpaceTimeShoot ( j ) ;
57288: LD_VAR 0 3
57292: PPUSH
57293: CALL 68529 0 1
57297: GO 57239
57299: POP
57300: POP
// end ;
57301: GO 57142
57303: POP
57304: POP
// end ;
57305: LD_VAR 0 1
57309: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
57310: LD_INT 0
57312: PPUSH
57313: PPUSH
57314: PPUSH
57315: PPUSH
57316: PPUSH
57317: PPUSH
57318: PPUSH
57319: PPUSH
57320: PPUSH
// if not mc_bases then
57321: LD_EXP 100
57325: NOT
57326: IFFALSE 57330
// exit ;
57328: GO 57952
// for i = 1 to mc_bases do
57330: LD_ADDR_VAR 0 2
57334: PUSH
57335: DOUBLE
57336: LD_INT 1
57338: DEC
57339: ST_TO_ADDR
57340: LD_EXP 100
57344: PUSH
57345: FOR_TO
57346: IFFALSE 57950
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
57348: LD_EXP 135
57352: PUSH
57353: LD_VAR 0 2
57357: ARRAY
57358: NOT
57359: PUSH
57360: LD_INT 38
57362: PPUSH
57363: LD_EXP 126
57367: PUSH
57368: LD_VAR 0 2
57372: ARRAY
57373: PPUSH
57374: CALL_OW 321
57378: PUSH
57379: LD_INT 2
57381: NONEQUAL
57382: OR
57383: IFFALSE 57387
// continue ;
57385: GO 57345
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57387: LD_ADDR_VAR 0 8
57391: PUSH
57392: LD_EXP 100
57396: PUSH
57397: LD_VAR 0 2
57401: ARRAY
57402: PPUSH
57403: LD_INT 30
57405: PUSH
57406: LD_INT 34
57408: PUSH
57409: EMPTY
57410: LIST
57411: LIST
57412: PPUSH
57413: CALL_OW 72
57417: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57418: LD_ADDR_VAR 0 9
57422: PUSH
57423: LD_EXP 100
57427: PUSH
57428: LD_VAR 0 2
57432: ARRAY
57433: PPUSH
57434: LD_INT 25
57436: PUSH
57437: LD_INT 4
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: PPUSH
57444: CALL_OW 72
57448: PPUSH
57449: LD_INT 0
57451: PPUSH
57452: CALL 102631 0 2
57456: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57457: LD_VAR 0 9
57461: NOT
57462: PUSH
57463: LD_VAR 0 8
57467: NOT
57468: OR
57469: PUSH
57470: LD_EXP 100
57474: PUSH
57475: LD_VAR 0 2
57479: ARRAY
57480: PPUSH
57481: LD_INT 124
57483: PPUSH
57484: CALL 102631 0 2
57488: OR
57489: IFFALSE 57493
// continue ;
57491: GO 57345
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57493: LD_EXP 136
57497: PUSH
57498: LD_VAR 0 2
57502: ARRAY
57503: PUSH
57504: LD_EXP 135
57508: PUSH
57509: LD_VAR 0 2
57513: ARRAY
57514: LESS
57515: PUSH
57516: LD_EXP 136
57520: PUSH
57521: LD_VAR 0 2
57525: ARRAY
57526: PUSH
57527: LD_VAR 0 8
57531: LESS
57532: AND
57533: IFFALSE 57948
// begin tmp := sci [ 1 ] ;
57535: LD_ADDR_VAR 0 7
57539: PUSH
57540: LD_VAR 0 9
57544: PUSH
57545: LD_INT 1
57547: ARRAY
57548: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57549: LD_VAR 0 7
57553: PPUSH
57554: LD_INT 124
57556: PPUSH
57557: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57561: LD_ADDR_VAR 0 3
57565: PUSH
57566: DOUBLE
57567: LD_EXP 135
57571: PUSH
57572: LD_VAR 0 2
57576: ARRAY
57577: INC
57578: ST_TO_ADDR
57579: LD_EXP 135
57583: PUSH
57584: LD_VAR 0 2
57588: ARRAY
57589: PUSH
57590: FOR_DOWNTO
57591: IFFALSE 57934
// begin if IsInUnit ( tmp ) then
57593: LD_VAR 0 7
57597: PPUSH
57598: CALL_OW 310
57602: IFFALSE 57613
// ComExitBuilding ( tmp ) ;
57604: LD_VAR 0 7
57608: PPUSH
57609: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57613: LD_INT 35
57615: PPUSH
57616: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57620: LD_VAR 0 7
57624: PPUSH
57625: CALL_OW 310
57629: NOT
57630: PUSH
57631: LD_VAR 0 7
57635: PPUSH
57636: CALL_OW 314
57640: NOT
57641: AND
57642: IFFALSE 57613
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57644: LD_ADDR_VAR 0 6
57648: PUSH
57649: LD_VAR 0 7
57653: PPUSH
57654: CALL_OW 250
57658: PUSH
57659: LD_VAR 0 7
57663: PPUSH
57664: CALL_OW 251
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57673: LD_INT 35
57675: PPUSH
57676: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57680: LD_ADDR_VAR 0 4
57684: PUSH
57685: LD_EXP 135
57689: PUSH
57690: LD_VAR 0 2
57694: ARRAY
57695: PUSH
57696: LD_VAR 0 3
57700: ARRAY
57701: PUSH
57702: LD_INT 1
57704: ARRAY
57705: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57706: LD_ADDR_VAR 0 5
57710: PUSH
57711: LD_EXP 135
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_VAR 0 3
57726: ARRAY
57727: PUSH
57728: LD_INT 2
57730: ARRAY
57731: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57732: LD_VAR 0 7
57736: PPUSH
57737: LD_INT 10
57739: PPUSH
57740: CALL 75316 0 2
57744: PUSH
57745: LD_INT 4
57747: ARRAY
57748: IFFALSE 57786
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57750: LD_VAR 0 7
57754: PPUSH
57755: LD_VAR 0 6
57759: PUSH
57760: LD_INT 1
57762: ARRAY
57763: PPUSH
57764: LD_VAR 0 6
57768: PUSH
57769: LD_INT 2
57771: ARRAY
57772: PPUSH
57773: CALL_OW 111
// wait ( 0 0$10 ) ;
57777: LD_INT 350
57779: PPUSH
57780: CALL_OW 67
// end else
57784: GO 57812
// begin ComMoveXY ( tmp , x , y ) ;
57786: LD_VAR 0 7
57790: PPUSH
57791: LD_VAR 0 4
57795: PPUSH
57796: LD_VAR 0 5
57800: PPUSH
57801: CALL_OW 111
// wait ( 0 0$3 ) ;
57805: LD_INT 105
57807: PPUSH
57808: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57812: LD_VAR 0 7
57816: PPUSH
57817: LD_VAR 0 4
57821: PPUSH
57822: LD_VAR 0 5
57826: PPUSH
57827: CALL_OW 307
57831: IFFALSE 57673
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57833: LD_VAR 0 7
57837: PPUSH
57838: LD_VAR 0 4
57842: PPUSH
57843: LD_VAR 0 5
57847: PPUSH
57848: LD_VAR 0 8
57852: PUSH
57853: LD_VAR 0 3
57857: ARRAY
57858: PPUSH
57859: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57863: LD_INT 35
57865: PPUSH
57866: CALL_OW 67
// until not HasTask ( tmp ) ;
57870: LD_VAR 0 7
57874: PPUSH
57875: CALL_OW 314
57879: NOT
57880: IFFALSE 57863
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57882: LD_ADDR_EXP 136
57886: PUSH
57887: LD_EXP 136
57891: PPUSH
57892: LD_VAR 0 2
57896: PUSH
57897: LD_EXP 136
57901: PUSH
57902: LD_VAR 0 2
57906: ARRAY
57907: PUSH
57908: LD_INT 1
57910: PLUS
57911: PUSH
57912: EMPTY
57913: LIST
57914: LIST
57915: PPUSH
57916: LD_VAR 0 8
57920: PUSH
57921: LD_VAR 0 3
57925: ARRAY
57926: PPUSH
57927: CALL 72719 0 3
57931: ST_TO_ADDR
// end ;
57932: GO 57590
57934: POP
57935: POP
// MC_Reset ( i , 124 ) ;
57936: LD_VAR 0 2
57940: PPUSH
57941: LD_INT 124
57943: PPUSH
57944: CALL 41041 0 2
// end ; end ;
57948: GO 57345
57950: POP
57951: POP
// end ;
57952: LD_VAR 0 1
57956: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57957: LD_INT 0
57959: PPUSH
57960: PPUSH
57961: PPUSH
// if not mc_bases then
57962: LD_EXP 100
57966: NOT
57967: IFFALSE 57971
// exit ;
57969: GO 58577
// for i = 1 to mc_bases do
57971: LD_ADDR_VAR 0 2
57975: PUSH
57976: DOUBLE
57977: LD_INT 1
57979: DEC
57980: ST_TO_ADDR
57981: LD_EXP 100
57985: PUSH
57986: FOR_TO
57987: IFFALSE 58575
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57989: LD_ADDR_VAR 0 3
57993: PUSH
57994: LD_EXP 100
57998: PUSH
57999: LD_VAR 0 2
58003: ARRAY
58004: PPUSH
58005: LD_INT 25
58007: PUSH
58008: LD_INT 4
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PPUSH
58015: CALL_OW 72
58019: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58020: LD_VAR 0 3
58024: NOT
58025: PUSH
58026: LD_EXP 137
58030: PUSH
58031: LD_VAR 0 2
58035: ARRAY
58036: NOT
58037: OR
58038: PUSH
58039: LD_EXP 100
58043: PUSH
58044: LD_VAR 0 2
58048: ARRAY
58049: PPUSH
58050: LD_INT 2
58052: PUSH
58053: LD_INT 30
58055: PUSH
58056: LD_INT 0
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: PUSH
58063: LD_INT 30
58065: PUSH
58066: LD_INT 1
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: PPUSH
58078: CALL_OW 72
58082: NOT
58083: OR
58084: IFFALSE 58134
// begin if mc_deposits_finder [ i ] then
58086: LD_EXP 138
58090: PUSH
58091: LD_VAR 0 2
58095: ARRAY
58096: IFFALSE 58132
// begin MC_Reset ( i , 125 ) ;
58098: LD_VAR 0 2
58102: PPUSH
58103: LD_INT 125
58105: PPUSH
58106: CALL 41041 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58110: LD_ADDR_EXP 138
58114: PUSH
58115: LD_EXP 138
58119: PPUSH
58120: LD_VAR 0 2
58124: PPUSH
58125: EMPTY
58126: PPUSH
58127: CALL_OW 1
58131: ST_TO_ADDR
// end ; continue ;
58132: GO 57986
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
58134: LD_EXP 137
58138: PUSH
58139: LD_VAR 0 2
58143: ARRAY
58144: PUSH
58145: LD_INT 1
58147: ARRAY
58148: PUSH
58149: LD_INT 3
58151: ARRAY
58152: PUSH
58153: LD_INT 1
58155: EQUAL
58156: PUSH
58157: LD_INT 20
58159: PPUSH
58160: LD_EXP 126
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: PPUSH
58171: CALL_OW 321
58175: PUSH
58176: LD_INT 2
58178: NONEQUAL
58179: AND
58180: IFFALSE 58230
// begin if mc_deposits_finder [ i ] then
58182: LD_EXP 138
58186: PUSH
58187: LD_VAR 0 2
58191: ARRAY
58192: IFFALSE 58228
// begin MC_Reset ( i , 125 ) ;
58194: LD_VAR 0 2
58198: PPUSH
58199: LD_INT 125
58201: PPUSH
58202: CALL 41041 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58206: LD_ADDR_EXP 138
58210: PUSH
58211: LD_EXP 138
58215: PPUSH
58216: LD_VAR 0 2
58220: PPUSH
58221: EMPTY
58222: PPUSH
58223: CALL_OW 1
58227: ST_TO_ADDR
// end ; continue ;
58228: GO 57986
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
58230: LD_EXP 137
58234: PUSH
58235: LD_VAR 0 2
58239: ARRAY
58240: PUSH
58241: LD_INT 1
58243: ARRAY
58244: PUSH
58245: LD_INT 1
58247: ARRAY
58248: PPUSH
58249: LD_EXP 137
58253: PUSH
58254: LD_VAR 0 2
58258: ARRAY
58259: PUSH
58260: LD_INT 1
58262: ARRAY
58263: PUSH
58264: LD_INT 2
58266: ARRAY
58267: PPUSH
58268: LD_EXP 126
58272: PUSH
58273: LD_VAR 0 2
58277: ARRAY
58278: PPUSH
58279: CALL_OW 440
58283: IFFALSE 58326
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
58285: LD_ADDR_EXP 137
58289: PUSH
58290: LD_EXP 137
58294: PPUSH
58295: LD_VAR 0 2
58299: PPUSH
58300: LD_EXP 137
58304: PUSH
58305: LD_VAR 0 2
58309: ARRAY
58310: PPUSH
58311: LD_INT 1
58313: PPUSH
58314: CALL_OW 3
58318: PPUSH
58319: CALL_OW 1
58323: ST_TO_ADDR
58324: GO 58573
// begin if not mc_deposits_finder [ i ] then
58326: LD_EXP 138
58330: PUSH
58331: LD_VAR 0 2
58335: ARRAY
58336: NOT
58337: IFFALSE 58389
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
58339: LD_ADDR_EXP 138
58343: PUSH
58344: LD_EXP 138
58348: PPUSH
58349: LD_VAR 0 2
58353: PPUSH
58354: LD_VAR 0 3
58358: PUSH
58359: LD_INT 1
58361: ARRAY
58362: PUSH
58363: EMPTY
58364: LIST
58365: PPUSH
58366: CALL_OW 1
58370: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58371: LD_VAR 0 3
58375: PUSH
58376: LD_INT 1
58378: ARRAY
58379: PPUSH
58380: LD_INT 125
58382: PPUSH
58383: CALL_OW 109
// end else
58387: GO 58573
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58389: LD_EXP 138
58393: PUSH
58394: LD_VAR 0 2
58398: ARRAY
58399: PUSH
58400: LD_INT 1
58402: ARRAY
58403: PPUSH
58404: CALL_OW 310
58408: IFFALSE 58431
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58410: LD_EXP 138
58414: PUSH
58415: LD_VAR 0 2
58419: ARRAY
58420: PUSH
58421: LD_INT 1
58423: ARRAY
58424: PPUSH
58425: CALL_OW 122
58429: GO 58573
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58431: LD_EXP 138
58435: PUSH
58436: LD_VAR 0 2
58440: ARRAY
58441: PUSH
58442: LD_INT 1
58444: ARRAY
58445: PPUSH
58446: CALL_OW 314
58450: NOT
58451: PUSH
58452: LD_EXP 138
58456: PUSH
58457: LD_VAR 0 2
58461: ARRAY
58462: PUSH
58463: LD_INT 1
58465: ARRAY
58466: PPUSH
58467: LD_EXP 137
58471: PUSH
58472: LD_VAR 0 2
58476: ARRAY
58477: PUSH
58478: LD_INT 1
58480: ARRAY
58481: PUSH
58482: LD_INT 1
58484: ARRAY
58485: PPUSH
58486: LD_EXP 137
58490: PUSH
58491: LD_VAR 0 2
58495: ARRAY
58496: PUSH
58497: LD_INT 1
58499: ARRAY
58500: PUSH
58501: LD_INT 2
58503: ARRAY
58504: PPUSH
58505: CALL_OW 297
58509: PUSH
58510: LD_INT 6
58512: GREATER
58513: AND
58514: IFFALSE 58573
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58516: LD_EXP 138
58520: PUSH
58521: LD_VAR 0 2
58525: ARRAY
58526: PUSH
58527: LD_INT 1
58529: ARRAY
58530: PPUSH
58531: LD_EXP 137
58535: PUSH
58536: LD_VAR 0 2
58540: ARRAY
58541: PUSH
58542: LD_INT 1
58544: ARRAY
58545: PUSH
58546: LD_INT 1
58548: ARRAY
58549: PPUSH
58550: LD_EXP 137
58554: PUSH
58555: LD_VAR 0 2
58559: ARRAY
58560: PUSH
58561: LD_INT 1
58563: ARRAY
58564: PUSH
58565: LD_INT 2
58567: ARRAY
58568: PPUSH
58569: CALL_OW 111
// end ; end ; end ;
58573: GO 57986
58575: POP
58576: POP
// end ;
58577: LD_VAR 0 1
58581: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58582: LD_INT 0
58584: PPUSH
58585: PPUSH
58586: PPUSH
58587: PPUSH
58588: PPUSH
58589: PPUSH
58590: PPUSH
58591: PPUSH
58592: PPUSH
58593: PPUSH
58594: PPUSH
// if not mc_bases then
58595: LD_EXP 100
58599: NOT
58600: IFFALSE 58604
// exit ;
58602: GO 59544
// for i = 1 to mc_bases do
58604: LD_ADDR_VAR 0 2
58608: PUSH
58609: DOUBLE
58610: LD_INT 1
58612: DEC
58613: ST_TO_ADDR
58614: LD_EXP 100
58618: PUSH
58619: FOR_TO
58620: IFFALSE 59542
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58622: LD_EXP 100
58626: PUSH
58627: LD_VAR 0 2
58631: ARRAY
58632: NOT
58633: PUSH
58634: LD_EXP 123
58638: PUSH
58639: LD_VAR 0 2
58643: ARRAY
58644: OR
58645: IFFALSE 58649
// continue ;
58647: GO 58619
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58649: LD_ADDR_VAR 0 7
58653: PUSH
58654: LD_EXP 100
58658: PUSH
58659: LD_VAR 0 2
58663: ARRAY
58664: PUSH
58665: LD_INT 1
58667: ARRAY
58668: PPUSH
58669: CALL_OW 248
58673: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58674: LD_VAR 0 7
58678: PUSH
58679: LD_INT 3
58681: EQUAL
58682: PUSH
58683: LD_EXP 119
58687: PUSH
58688: LD_VAR 0 2
58692: ARRAY
58693: PUSH
58694: LD_EXP 122
58698: PUSH
58699: LD_VAR 0 2
58703: ARRAY
58704: UNION
58705: PPUSH
58706: LD_INT 33
58708: PUSH
58709: LD_INT 2
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: PPUSH
58716: CALL_OW 72
58720: NOT
58721: OR
58722: IFFALSE 58726
// continue ;
58724: GO 58619
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58726: LD_ADDR_VAR 0 9
58730: PUSH
58731: LD_EXP 100
58735: PUSH
58736: LD_VAR 0 2
58740: ARRAY
58741: PPUSH
58742: LD_INT 30
58744: PUSH
58745: LD_INT 36
58747: PUSH
58748: EMPTY
58749: LIST
58750: LIST
58751: PPUSH
58752: CALL_OW 72
58756: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58757: LD_ADDR_VAR 0 10
58761: PUSH
58762: LD_EXP 119
58766: PUSH
58767: LD_VAR 0 2
58771: ARRAY
58772: PPUSH
58773: LD_INT 34
58775: PUSH
58776: LD_INT 31
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: PPUSH
58783: CALL_OW 72
58787: ST_TO_ADDR
// if not cts and not mcts then
58788: LD_VAR 0 9
58792: NOT
58793: PUSH
58794: LD_VAR 0 10
58798: NOT
58799: AND
58800: IFFALSE 58804
// continue ;
58802: GO 58619
// x := cts ;
58804: LD_ADDR_VAR 0 11
58808: PUSH
58809: LD_VAR 0 9
58813: ST_TO_ADDR
// if not x then
58814: LD_VAR 0 11
58818: NOT
58819: IFFALSE 58831
// x := mcts ;
58821: LD_ADDR_VAR 0 11
58825: PUSH
58826: LD_VAR 0 10
58830: ST_TO_ADDR
// if not x then
58831: LD_VAR 0 11
58835: NOT
58836: IFFALSE 58840
// continue ;
58838: GO 58619
// if mc_remote_driver [ i ] then
58840: LD_EXP 140
58844: PUSH
58845: LD_VAR 0 2
58849: ARRAY
58850: IFFALSE 59237
// for j in mc_remote_driver [ i ] do
58852: LD_ADDR_VAR 0 3
58856: PUSH
58857: LD_EXP 140
58861: PUSH
58862: LD_VAR 0 2
58866: ARRAY
58867: PUSH
58868: FOR_IN
58869: IFFALSE 59235
// begin if GetClass ( j ) <> 3 then
58871: LD_VAR 0 3
58875: PPUSH
58876: CALL_OW 257
58880: PUSH
58881: LD_INT 3
58883: NONEQUAL
58884: IFFALSE 58937
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58886: LD_ADDR_EXP 140
58890: PUSH
58891: LD_EXP 140
58895: PPUSH
58896: LD_VAR 0 2
58900: PPUSH
58901: LD_EXP 140
58905: PUSH
58906: LD_VAR 0 2
58910: ARRAY
58911: PUSH
58912: LD_VAR 0 3
58916: DIFF
58917: PPUSH
58918: CALL_OW 1
58922: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58923: LD_VAR 0 3
58927: PPUSH
58928: LD_INT 0
58930: PPUSH
58931: CALL_OW 109
// continue ;
58935: GO 58868
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58937: LD_EXP 119
58941: PUSH
58942: LD_VAR 0 2
58946: ARRAY
58947: PPUSH
58948: LD_INT 34
58950: PUSH
58951: LD_INT 31
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: PUSH
58958: LD_INT 58
58960: PUSH
58961: EMPTY
58962: LIST
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: PPUSH
58968: CALL_OW 72
58972: PUSH
58973: LD_VAR 0 3
58977: PPUSH
58978: CALL 102666 0 1
58982: NOT
58983: AND
58984: IFFALSE 59055
// begin if IsInUnit ( j ) then
58986: LD_VAR 0 3
58990: PPUSH
58991: CALL_OW 310
58995: IFFALSE 59006
// ComExitBuilding ( j ) ;
58997: LD_VAR 0 3
59001: PPUSH
59002: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
59006: LD_VAR 0 3
59010: PPUSH
59011: LD_EXP 119
59015: PUSH
59016: LD_VAR 0 2
59020: ARRAY
59021: PPUSH
59022: LD_INT 34
59024: PUSH
59025: LD_INT 31
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: PUSH
59032: LD_INT 58
59034: PUSH
59035: EMPTY
59036: LIST
59037: PUSH
59038: EMPTY
59039: LIST
59040: LIST
59041: PPUSH
59042: CALL_OW 72
59046: PUSH
59047: LD_INT 1
59049: ARRAY
59050: PPUSH
59051: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
59055: LD_VAR 0 3
59059: PPUSH
59060: CALL_OW 310
59064: NOT
59065: PUSH
59066: LD_VAR 0 3
59070: PPUSH
59071: CALL_OW 310
59075: PPUSH
59076: CALL_OW 266
59080: PUSH
59081: LD_INT 36
59083: NONEQUAL
59084: PUSH
59085: LD_VAR 0 3
59089: PPUSH
59090: CALL 102666 0 1
59094: NOT
59095: AND
59096: OR
59097: IFFALSE 59233
// begin if IsInUnit ( j ) then
59099: LD_VAR 0 3
59103: PPUSH
59104: CALL_OW 310
59108: IFFALSE 59119
// ComExitBuilding ( j ) ;
59110: LD_VAR 0 3
59114: PPUSH
59115: CALL_OW 122
// ct := 0 ;
59119: LD_ADDR_VAR 0 8
59123: PUSH
59124: LD_INT 0
59126: ST_TO_ADDR
// for k in x do
59127: LD_ADDR_VAR 0 4
59131: PUSH
59132: LD_VAR 0 11
59136: PUSH
59137: FOR_IN
59138: IFFALSE 59211
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
59140: LD_VAR 0 4
59144: PPUSH
59145: CALL_OW 264
59149: PUSH
59150: LD_INT 31
59152: EQUAL
59153: PUSH
59154: LD_VAR 0 4
59158: PPUSH
59159: CALL_OW 311
59163: NOT
59164: AND
59165: PUSH
59166: LD_VAR 0 4
59170: PPUSH
59171: CALL_OW 266
59175: PUSH
59176: LD_INT 36
59178: EQUAL
59179: PUSH
59180: LD_VAR 0 4
59184: PPUSH
59185: CALL_OW 313
59189: PUSH
59190: LD_INT 3
59192: LESS
59193: AND
59194: OR
59195: IFFALSE 59209
// begin ct := k ;
59197: LD_ADDR_VAR 0 8
59201: PUSH
59202: LD_VAR 0 4
59206: ST_TO_ADDR
// break ;
59207: GO 59211
// end ;
59209: GO 59137
59211: POP
59212: POP
// if ct then
59213: LD_VAR 0 8
59217: IFFALSE 59233
// ComEnterUnit ( j , ct ) ;
59219: LD_VAR 0 3
59223: PPUSH
59224: LD_VAR 0 8
59228: PPUSH
59229: CALL_OW 120
// end ; end ;
59233: GO 58868
59235: POP
59236: POP
// places := 0 ;
59237: LD_ADDR_VAR 0 5
59241: PUSH
59242: LD_INT 0
59244: ST_TO_ADDR
// for j = 1 to x do
59245: LD_ADDR_VAR 0 3
59249: PUSH
59250: DOUBLE
59251: LD_INT 1
59253: DEC
59254: ST_TO_ADDR
59255: LD_VAR 0 11
59259: PUSH
59260: FOR_TO
59261: IFFALSE 59337
// if GetWeapon ( x [ j ] ) = ar_control_tower then
59263: LD_VAR 0 11
59267: PUSH
59268: LD_VAR 0 3
59272: ARRAY
59273: PPUSH
59274: CALL_OW 264
59278: PUSH
59279: LD_INT 31
59281: EQUAL
59282: IFFALSE 59300
// places := places + 1 else
59284: LD_ADDR_VAR 0 5
59288: PUSH
59289: LD_VAR 0 5
59293: PUSH
59294: LD_INT 1
59296: PLUS
59297: ST_TO_ADDR
59298: GO 59335
// if GetBType ( x [ j ] ) = b_control_tower then
59300: LD_VAR 0 11
59304: PUSH
59305: LD_VAR 0 3
59309: ARRAY
59310: PPUSH
59311: CALL_OW 266
59315: PUSH
59316: LD_INT 36
59318: EQUAL
59319: IFFALSE 59335
// places := places + 3 ;
59321: LD_ADDR_VAR 0 5
59325: PUSH
59326: LD_VAR 0 5
59330: PUSH
59331: LD_INT 3
59333: PLUS
59334: ST_TO_ADDR
59335: GO 59260
59337: POP
59338: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
59339: LD_VAR 0 5
59343: PUSH
59344: LD_INT 0
59346: EQUAL
59347: PUSH
59348: LD_VAR 0 5
59352: PUSH
59353: LD_EXP 140
59357: PUSH
59358: LD_VAR 0 2
59362: ARRAY
59363: LESSEQUAL
59364: OR
59365: IFFALSE 59369
// continue ;
59367: GO 58619
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59369: LD_ADDR_VAR 0 6
59373: PUSH
59374: LD_EXP 100
59378: PUSH
59379: LD_VAR 0 2
59383: ARRAY
59384: PPUSH
59385: LD_INT 25
59387: PUSH
59388: LD_INT 3
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: PPUSH
59395: CALL_OW 72
59399: PUSH
59400: LD_EXP 140
59404: PUSH
59405: LD_VAR 0 2
59409: ARRAY
59410: DIFF
59411: PPUSH
59412: LD_INT 3
59414: PPUSH
59415: CALL 103566 0 2
59419: ST_TO_ADDR
// for j in tmp do
59420: LD_ADDR_VAR 0 3
59424: PUSH
59425: LD_VAR 0 6
59429: PUSH
59430: FOR_IN
59431: IFFALSE 59466
// if GetTag ( j ) > 0 then
59433: LD_VAR 0 3
59437: PPUSH
59438: CALL_OW 110
59442: PUSH
59443: LD_INT 0
59445: GREATER
59446: IFFALSE 59464
// tmp := tmp diff j ;
59448: LD_ADDR_VAR 0 6
59452: PUSH
59453: LD_VAR 0 6
59457: PUSH
59458: LD_VAR 0 3
59462: DIFF
59463: ST_TO_ADDR
59464: GO 59430
59466: POP
59467: POP
// if not tmp then
59468: LD_VAR 0 6
59472: NOT
59473: IFFALSE 59477
// continue ;
59475: GO 58619
// if places then
59477: LD_VAR 0 5
59481: IFFALSE 59540
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59483: LD_ADDR_EXP 140
59487: PUSH
59488: LD_EXP 140
59492: PPUSH
59493: LD_VAR 0 2
59497: PPUSH
59498: LD_EXP 140
59502: PUSH
59503: LD_VAR 0 2
59507: ARRAY
59508: PUSH
59509: LD_VAR 0 6
59513: PUSH
59514: LD_INT 1
59516: ARRAY
59517: UNION
59518: PPUSH
59519: CALL_OW 1
59523: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59524: LD_VAR 0 6
59528: PUSH
59529: LD_INT 1
59531: ARRAY
59532: PPUSH
59533: LD_INT 126
59535: PPUSH
59536: CALL_OW 109
// end ; end ;
59540: GO 58619
59542: POP
59543: POP
// end ;
59544: LD_VAR 0 1
59548: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59549: LD_INT 0
59551: PPUSH
59552: PPUSH
59553: PPUSH
59554: PPUSH
59555: PPUSH
59556: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59557: LD_VAR 0 1
59561: NOT
59562: PUSH
59563: LD_VAR 0 2
59567: NOT
59568: OR
59569: PUSH
59570: LD_VAR 0 3
59574: NOT
59575: OR
59576: PUSH
59577: LD_VAR 0 4
59581: PUSH
59582: LD_INT 1
59584: PUSH
59585: LD_INT 2
59587: PUSH
59588: LD_INT 3
59590: PUSH
59591: LD_INT 4
59593: PUSH
59594: LD_INT 5
59596: PUSH
59597: LD_INT 8
59599: PUSH
59600: LD_INT 9
59602: PUSH
59603: LD_INT 15
59605: PUSH
59606: LD_INT 16
59608: PUSH
59609: EMPTY
59610: LIST
59611: LIST
59612: LIST
59613: LIST
59614: LIST
59615: LIST
59616: LIST
59617: LIST
59618: LIST
59619: IN
59620: NOT
59621: OR
59622: IFFALSE 59626
// exit ;
59624: GO 60526
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59626: LD_ADDR_VAR 0 2
59630: PUSH
59631: LD_VAR 0 2
59635: PPUSH
59636: LD_INT 21
59638: PUSH
59639: LD_INT 3
59641: PUSH
59642: EMPTY
59643: LIST
59644: LIST
59645: PUSH
59646: LD_INT 24
59648: PUSH
59649: LD_INT 250
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: EMPTY
59657: LIST
59658: LIST
59659: PPUSH
59660: CALL_OW 72
59664: ST_TO_ADDR
// case class of 1 , 15 :
59665: LD_VAR 0 4
59669: PUSH
59670: LD_INT 1
59672: DOUBLE
59673: EQUAL
59674: IFTRUE 59684
59676: LD_INT 15
59678: DOUBLE
59679: EQUAL
59680: IFTRUE 59684
59682: GO 59769
59684: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59685: LD_ADDR_VAR 0 8
59689: PUSH
59690: LD_VAR 0 2
59694: PPUSH
59695: LD_INT 2
59697: PUSH
59698: LD_INT 30
59700: PUSH
59701: LD_INT 32
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PUSH
59708: LD_INT 30
59710: PUSH
59711: LD_INT 31
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: LIST
59722: PPUSH
59723: CALL_OW 72
59727: PUSH
59728: LD_VAR 0 2
59732: PPUSH
59733: LD_INT 2
59735: PUSH
59736: LD_INT 30
59738: PUSH
59739: LD_INT 4
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: PUSH
59746: LD_INT 30
59748: PUSH
59749: LD_INT 5
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: LIST
59760: PPUSH
59761: CALL_OW 72
59765: ADD
59766: ST_TO_ADDR
59767: GO 60015
59769: LD_INT 2
59771: DOUBLE
59772: EQUAL
59773: IFTRUE 59783
59775: LD_INT 16
59777: DOUBLE
59778: EQUAL
59779: IFTRUE 59783
59781: GO 59829
59783: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59784: LD_ADDR_VAR 0 8
59788: PUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: LD_INT 2
59796: PUSH
59797: LD_INT 30
59799: PUSH
59800: LD_INT 0
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: PUSH
59807: LD_INT 30
59809: PUSH
59810: LD_INT 1
59812: PUSH
59813: EMPTY
59814: LIST
59815: LIST
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: LIST
59821: PPUSH
59822: CALL_OW 72
59826: ST_TO_ADDR
59827: GO 60015
59829: LD_INT 3
59831: DOUBLE
59832: EQUAL
59833: IFTRUE 59837
59835: GO 59883
59837: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59838: LD_ADDR_VAR 0 8
59842: PUSH
59843: LD_VAR 0 2
59847: PPUSH
59848: LD_INT 2
59850: PUSH
59851: LD_INT 30
59853: PUSH
59854: LD_INT 2
59856: PUSH
59857: EMPTY
59858: LIST
59859: LIST
59860: PUSH
59861: LD_INT 30
59863: PUSH
59864: LD_INT 3
59866: PUSH
59867: EMPTY
59868: LIST
59869: LIST
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: LIST
59875: PPUSH
59876: CALL_OW 72
59880: ST_TO_ADDR
59881: GO 60015
59883: LD_INT 4
59885: DOUBLE
59886: EQUAL
59887: IFTRUE 59891
59889: GO 59948
59891: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59892: LD_ADDR_VAR 0 8
59896: PUSH
59897: LD_VAR 0 2
59901: PPUSH
59902: LD_INT 2
59904: PUSH
59905: LD_INT 30
59907: PUSH
59908: LD_INT 6
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 30
59917: PUSH
59918: LD_INT 7
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: LD_INT 30
59927: PUSH
59928: LD_INT 8
59930: PUSH
59931: EMPTY
59932: LIST
59933: LIST
59934: PUSH
59935: EMPTY
59936: LIST
59937: LIST
59938: LIST
59939: LIST
59940: PPUSH
59941: CALL_OW 72
59945: ST_TO_ADDR
59946: GO 60015
59948: LD_INT 5
59950: DOUBLE
59951: EQUAL
59952: IFTRUE 59968
59954: LD_INT 8
59956: DOUBLE
59957: EQUAL
59958: IFTRUE 59968
59960: LD_INT 9
59962: DOUBLE
59963: EQUAL
59964: IFTRUE 59968
59966: GO 60014
59968: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59969: LD_ADDR_VAR 0 8
59973: PUSH
59974: LD_VAR 0 2
59978: PPUSH
59979: LD_INT 2
59981: PUSH
59982: LD_INT 30
59984: PUSH
59985: LD_INT 4
59987: PUSH
59988: EMPTY
59989: LIST
59990: LIST
59991: PUSH
59992: LD_INT 30
59994: PUSH
59995: LD_INT 5
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: PUSH
60002: EMPTY
60003: LIST
60004: LIST
60005: LIST
60006: PPUSH
60007: CALL_OW 72
60011: ST_TO_ADDR
60012: GO 60015
60014: POP
// if not tmp then
60015: LD_VAR 0 8
60019: NOT
60020: IFFALSE 60024
// exit ;
60022: GO 60526
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
60024: LD_VAR 0 4
60028: PUSH
60029: LD_INT 1
60031: PUSH
60032: LD_INT 15
60034: PUSH
60035: EMPTY
60036: LIST
60037: LIST
60038: IN
60039: PUSH
60040: LD_EXP 109
60044: PUSH
60045: LD_VAR 0 1
60049: ARRAY
60050: AND
60051: IFFALSE 60207
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
60053: LD_ADDR_VAR 0 9
60057: PUSH
60058: LD_EXP 109
60062: PUSH
60063: LD_VAR 0 1
60067: ARRAY
60068: PUSH
60069: LD_INT 1
60071: ARRAY
60072: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
60073: LD_VAR 0 9
60077: PUSH
60078: LD_EXP 110
60082: PUSH
60083: LD_VAR 0 1
60087: ARRAY
60088: IN
60089: NOT
60090: IFFALSE 60205
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
60092: LD_ADDR_EXP 110
60096: PUSH
60097: LD_EXP 110
60101: PPUSH
60102: LD_VAR 0 1
60106: PUSH
60107: LD_EXP 110
60111: PUSH
60112: LD_VAR 0 1
60116: ARRAY
60117: PUSH
60118: LD_INT 1
60120: PLUS
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PPUSH
60126: LD_VAR 0 9
60130: PPUSH
60131: CALL 72719 0 3
60135: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
60136: LD_ADDR_EXP 109
60140: PUSH
60141: LD_EXP 109
60145: PPUSH
60146: LD_VAR 0 1
60150: PPUSH
60151: LD_EXP 109
60155: PUSH
60156: LD_VAR 0 1
60160: ARRAY
60161: PUSH
60162: LD_VAR 0 9
60166: DIFF
60167: PPUSH
60168: CALL_OW 1
60172: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
60173: LD_VAR 0 3
60177: PPUSH
60178: LD_EXP 110
60182: PUSH
60183: LD_VAR 0 1
60187: ARRAY
60188: PUSH
60189: LD_EXP 110
60193: PUSH
60194: LD_VAR 0 1
60198: ARRAY
60199: ARRAY
60200: PPUSH
60201: CALL_OW 120
// end ; exit ;
60205: GO 60526
// end ; if tmp > 1 then
60207: LD_VAR 0 8
60211: PUSH
60212: LD_INT 1
60214: GREATER
60215: IFFALSE 60319
// for i = 2 to tmp do
60217: LD_ADDR_VAR 0 6
60221: PUSH
60222: DOUBLE
60223: LD_INT 2
60225: DEC
60226: ST_TO_ADDR
60227: LD_VAR 0 8
60231: PUSH
60232: FOR_TO
60233: IFFALSE 60317
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
60235: LD_VAR 0 8
60239: PUSH
60240: LD_VAR 0 6
60244: ARRAY
60245: PPUSH
60246: CALL_OW 461
60250: PUSH
60251: LD_INT 6
60253: EQUAL
60254: IFFALSE 60315
// begin x := tmp [ i ] ;
60256: LD_ADDR_VAR 0 9
60260: PUSH
60261: LD_VAR 0 8
60265: PUSH
60266: LD_VAR 0 6
60270: ARRAY
60271: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
60272: LD_ADDR_VAR 0 8
60276: PUSH
60277: LD_VAR 0 8
60281: PPUSH
60282: LD_VAR 0 6
60286: PPUSH
60287: CALL_OW 3
60291: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
60292: LD_ADDR_VAR 0 8
60296: PUSH
60297: LD_VAR 0 8
60301: PPUSH
60302: LD_INT 1
60304: PPUSH
60305: LD_VAR 0 9
60309: PPUSH
60310: CALL_OW 2
60314: ST_TO_ADDR
// end ;
60315: GO 60232
60317: POP
60318: POP
// for i in tmp do
60319: LD_ADDR_VAR 0 6
60323: PUSH
60324: LD_VAR 0 8
60328: PUSH
60329: FOR_IN
60330: IFFALSE 60399
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
60332: LD_VAR 0 6
60336: PPUSH
60337: CALL_OW 313
60341: PUSH
60342: LD_INT 6
60344: LESS
60345: PUSH
60346: LD_VAR 0 6
60350: PPUSH
60351: CALL_OW 266
60355: PUSH
60356: LD_INT 31
60358: PUSH
60359: LD_INT 32
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: IN
60366: NOT
60367: AND
60368: PUSH
60369: LD_VAR 0 6
60373: PPUSH
60374: CALL_OW 313
60378: PUSH
60379: LD_INT 0
60381: EQUAL
60382: OR
60383: IFFALSE 60397
// begin j := i ;
60385: LD_ADDR_VAR 0 7
60389: PUSH
60390: LD_VAR 0 6
60394: ST_TO_ADDR
// break ;
60395: GO 60399
// end ; end ;
60397: GO 60329
60399: POP
60400: POP
// if j then
60401: LD_VAR 0 7
60405: IFFALSE 60423
// ComEnterUnit ( unit , j ) else
60407: LD_VAR 0 3
60411: PPUSH
60412: LD_VAR 0 7
60416: PPUSH
60417: CALL_OW 120
60421: GO 60526
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60423: LD_ADDR_VAR 0 10
60427: PUSH
60428: LD_VAR 0 2
60432: PPUSH
60433: LD_INT 2
60435: PUSH
60436: LD_INT 30
60438: PUSH
60439: LD_INT 0
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 30
60448: PUSH
60449: LD_INT 1
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: LIST
60460: PPUSH
60461: CALL_OW 72
60465: ST_TO_ADDR
// if depot then
60466: LD_VAR 0 10
60470: IFFALSE 60526
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60472: LD_ADDR_VAR 0 10
60476: PUSH
60477: LD_VAR 0 10
60481: PPUSH
60482: LD_VAR 0 3
60486: PPUSH
60487: CALL_OW 74
60491: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60492: LD_VAR 0 3
60496: PPUSH
60497: LD_VAR 0 10
60501: PPUSH
60502: CALL_OW 296
60506: PUSH
60507: LD_INT 10
60509: GREATER
60510: IFFALSE 60526
// ComStandNearbyBuilding ( unit , depot ) ;
60512: LD_VAR 0 3
60516: PPUSH
60517: LD_VAR 0 10
60521: PPUSH
60522: CALL 69146 0 2
// end ; end ; end ;
60526: LD_VAR 0 5
60530: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60531: LD_INT 0
60533: PPUSH
60534: PPUSH
60535: PPUSH
60536: PPUSH
// if not mc_bases then
60537: LD_EXP 100
60541: NOT
60542: IFFALSE 60546
// exit ;
60544: GO 60785
// for i = 1 to mc_bases do
60546: LD_ADDR_VAR 0 2
60550: PUSH
60551: DOUBLE
60552: LD_INT 1
60554: DEC
60555: ST_TO_ADDR
60556: LD_EXP 100
60560: PUSH
60561: FOR_TO
60562: IFFALSE 60783
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60564: LD_ADDR_VAR 0 4
60568: PUSH
60569: LD_EXP 100
60573: PUSH
60574: LD_VAR 0 2
60578: ARRAY
60579: PPUSH
60580: LD_INT 21
60582: PUSH
60583: LD_INT 1
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PPUSH
60590: CALL_OW 72
60594: PUSH
60595: LD_EXP 129
60599: PUSH
60600: LD_VAR 0 2
60604: ARRAY
60605: UNION
60606: ST_TO_ADDR
// if not tmp then
60607: LD_VAR 0 4
60611: NOT
60612: IFFALSE 60616
// continue ;
60614: GO 60561
// for j in tmp do
60616: LD_ADDR_VAR 0 3
60620: PUSH
60621: LD_VAR 0 4
60625: PUSH
60626: FOR_IN
60627: IFFALSE 60779
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60629: LD_VAR 0 3
60633: PPUSH
60634: CALL_OW 110
60638: NOT
60639: PUSH
60640: LD_VAR 0 3
60644: PPUSH
60645: CALL_OW 314
60649: NOT
60650: AND
60651: PUSH
60652: LD_VAR 0 3
60656: PPUSH
60657: CALL_OW 311
60661: NOT
60662: AND
60663: PUSH
60664: LD_VAR 0 3
60668: PPUSH
60669: CALL_OW 310
60673: NOT
60674: AND
60675: PUSH
60676: LD_VAR 0 3
60680: PUSH
60681: LD_EXP 103
60685: PUSH
60686: LD_VAR 0 2
60690: ARRAY
60691: PUSH
60692: LD_INT 1
60694: ARRAY
60695: IN
60696: NOT
60697: AND
60698: PUSH
60699: LD_VAR 0 3
60703: PUSH
60704: LD_EXP 103
60708: PUSH
60709: LD_VAR 0 2
60713: ARRAY
60714: PUSH
60715: LD_INT 2
60717: ARRAY
60718: IN
60719: NOT
60720: AND
60721: PUSH
60722: LD_VAR 0 3
60726: PUSH
60727: LD_EXP 112
60731: PUSH
60732: LD_VAR 0 2
60736: ARRAY
60737: IN
60738: NOT
60739: AND
60740: IFFALSE 60777
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60742: LD_VAR 0 2
60746: PPUSH
60747: LD_EXP 100
60751: PUSH
60752: LD_VAR 0 2
60756: ARRAY
60757: PPUSH
60758: LD_VAR 0 3
60762: PPUSH
60763: LD_VAR 0 3
60767: PPUSH
60768: CALL_OW 257
60772: PPUSH
60773: CALL 59549 0 4
// end ;
60777: GO 60626
60779: POP
60780: POP
// end ;
60781: GO 60561
60783: POP
60784: POP
// end ;
60785: LD_VAR 0 1
60789: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60790: LD_INT 0
60792: PPUSH
60793: PPUSH
60794: PPUSH
60795: PPUSH
60796: PPUSH
60797: PPUSH
// if not mc_bases [ base ] then
60798: LD_EXP 100
60802: PUSH
60803: LD_VAR 0 1
60807: ARRAY
60808: NOT
60809: IFFALSE 60813
// exit ;
60811: GO 60995
// tmp := [ ] ;
60813: LD_ADDR_VAR 0 6
60817: PUSH
60818: EMPTY
60819: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60820: LD_ADDR_VAR 0 7
60824: PUSH
60825: LD_VAR 0 3
60829: PPUSH
60830: LD_INT 0
60832: PPUSH
60833: CALL_OW 517
60837: ST_TO_ADDR
// if not list then
60838: LD_VAR 0 7
60842: NOT
60843: IFFALSE 60847
// exit ;
60845: GO 60995
// for i = 1 to amount do
60847: LD_ADDR_VAR 0 5
60851: PUSH
60852: DOUBLE
60853: LD_INT 1
60855: DEC
60856: ST_TO_ADDR
60857: LD_VAR 0 2
60861: PUSH
60862: FOR_TO
60863: IFFALSE 60943
// begin x := rand ( 1 , list [ 1 ] ) ;
60865: LD_ADDR_VAR 0 8
60869: PUSH
60870: LD_INT 1
60872: PPUSH
60873: LD_VAR 0 7
60877: PUSH
60878: LD_INT 1
60880: ARRAY
60881: PPUSH
60882: CALL_OW 12
60886: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60887: LD_ADDR_VAR 0 6
60891: PUSH
60892: LD_VAR 0 6
60896: PPUSH
60897: LD_VAR 0 5
60901: PPUSH
60902: LD_VAR 0 7
60906: PUSH
60907: LD_INT 1
60909: ARRAY
60910: PUSH
60911: LD_VAR 0 8
60915: ARRAY
60916: PUSH
60917: LD_VAR 0 7
60921: PUSH
60922: LD_INT 2
60924: ARRAY
60925: PUSH
60926: LD_VAR 0 8
60930: ARRAY
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PPUSH
60936: CALL_OW 1
60940: ST_TO_ADDR
// end ;
60941: GO 60862
60943: POP
60944: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60945: LD_ADDR_EXP 113
60949: PUSH
60950: LD_EXP 113
60954: PPUSH
60955: LD_VAR 0 1
60959: PPUSH
60960: LD_VAR 0 6
60964: PPUSH
60965: CALL_OW 1
60969: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60970: LD_ADDR_EXP 115
60974: PUSH
60975: LD_EXP 115
60979: PPUSH
60980: LD_VAR 0 1
60984: PPUSH
60985: LD_VAR 0 3
60989: PPUSH
60990: CALL_OW 1
60994: ST_TO_ADDR
// end ;
60995: LD_VAR 0 4
60999: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
61000: LD_INT 0
61002: PPUSH
// if not mc_bases [ base ] then
61003: LD_EXP 100
61007: PUSH
61008: LD_VAR 0 1
61012: ARRAY
61013: NOT
61014: IFFALSE 61018
// exit ;
61016: GO 61043
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
61018: LD_ADDR_EXP 105
61022: PUSH
61023: LD_EXP 105
61027: PPUSH
61028: LD_VAR 0 1
61032: PPUSH
61033: LD_VAR 0 2
61037: PPUSH
61038: CALL_OW 1
61042: ST_TO_ADDR
// end ;
61043: LD_VAR 0 3
61047: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
61048: LD_INT 0
61050: PPUSH
// if not mc_bases [ base ] then
61051: LD_EXP 100
61055: PUSH
61056: LD_VAR 0 1
61060: ARRAY
61061: NOT
61062: IFFALSE 61066
// exit ;
61064: GO 61103
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
61066: LD_ADDR_EXP 105
61070: PUSH
61071: LD_EXP 105
61075: PPUSH
61076: LD_VAR 0 1
61080: PPUSH
61081: LD_EXP 105
61085: PUSH
61086: LD_VAR 0 1
61090: ARRAY
61091: PUSH
61092: LD_VAR 0 2
61096: UNION
61097: PPUSH
61098: CALL_OW 1
61102: ST_TO_ADDR
// end ;
61103: LD_VAR 0 3
61107: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
61108: LD_INT 0
61110: PPUSH
// if not mc_bases [ base ] then
61111: LD_EXP 100
61115: PUSH
61116: LD_VAR 0 1
61120: ARRAY
61121: NOT
61122: IFFALSE 61126
// exit ;
61124: GO 61151
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
61126: LD_ADDR_EXP 121
61130: PUSH
61131: LD_EXP 121
61135: PPUSH
61136: LD_VAR 0 1
61140: PPUSH
61141: LD_VAR 0 2
61145: PPUSH
61146: CALL_OW 1
61150: ST_TO_ADDR
// end ;
61151: LD_VAR 0 3
61155: RET
// export function MC_InsertProduceList ( base , components ) ; begin
61156: LD_INT 0
61158: PPUSH
// if not mc_bases [ base ] then
61159: LD_EXP 100
61163: PUSH
61164: LD_VAR 0 1
61168: ARRAY
61169: NOT
61170: IFFALSE 61174
// exit ;
61172: GO 61211
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
61174: LD_ADDR_EXP 121
61178: PUSH
61179: LD_EXP 121
61183: PPUSH
61184: LD_VAR 0 1
61188: PPUSH
61189: LD_EXP 121
61193: PUSH
61194: LD_VAR 0 1
61198: ARRAY
61199: PUSH
61200: LD_VAR 0 2
61204: ADD
61205: PPUSH
61206: CALL_OW 1
61210: ST_TO_ADDR
// end ;
61211: LD_VAR 0 3
61215: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
61216: LD_INT 0
61218: PPUSH
// if not mc_bases [ base ] then
61219: LD_EXP 100
61223: PUSH
61224: LD_VAR 0 1
61228: ARRAY
61229: NOT
61230: IFFALSE 61234
// exit ;
61232: GO 61288
// mc_defender := Replace ( mc_defender , base , deflist ) ;
61234: LD_ADDR_EXP 122
61238: PUSH
61239: LD_EXP 122
61243: PPUSH
61244: LD_VAR 0 1
61248: PPUSH
61249: LD_VAR 0 2
61253: PPUSH
61254: CALL_OW 1
61258: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
61259: LD_ADDR_EXP 111
61263: PUSH
61264: LD_EXP 111
61268: PPUSH
61269: LD_VAR 0 1
61273: PPUSH
61274: LD_VAR 0 2
61278: PUSH
61279: LD_INT 0
61281: PLUS
61282: PPUSH
61283: CALL_OW 1
61287: ST_TO_ADDR
// end ;
61288: LD_VAR 0 3
61292: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
61293: LD_INT 0
61295: PPUSH
// if not mc_bases [ base ] then
61296: LD_EXP 100
61300: PUSH
61301: LD_VAR 0 1
61305: ARRAY
61306: NOT
61307: IFFALSE 61311
// exit ;
61309: GO 61336
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
61311: LD_ADDR_EXP 111
61315: PUSH
61316: LD_EXP 111
61320: PPUSH
61321: LD_VAR 0 1
61325: PPUSH
61326: LD_VAR 0 2
61330: PPUSH
61331: CALL_OW 1
61335: ST_TO_ADDR
// end ;
61336: LD_VAR 0 3
61340: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
61341: LD_INT 0
61343: PPUSH
61344: PPUSH
61345: PPUSH
61346: PPUSH
// if not mc_bases [ base ] then
61347: LD_EXP 100
61351: PUSH
61352: LD_VAR 0 1
61356: ARRAY
61357: NOT
61358: IFFALSE 61362
// exit ;
61360: GO 61427
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61362: LD_ADDR_EXP 120
61366: PUSH
61367: LD_EXP 120
61371: PPUSH
61372: LD_VAR 0 1
61376: PUSH
61377: LD_EXP 120
61381: PUSH
61382: LD_VAR 0 1
61386: ARRAY
61387: PUSH
61388: LD_INT 1
61390: PLUS
61391: PUSH
61392: EMPTY
61393: LIST
61394: LIST
61395: PPUSH
61396: LD_VAR 0 1
61400: PUSH
61401: LD_VAR 0 2
61405: PUSH
61406: LD_VAR 0 3
61410: PUSH
61411: LD_VAR 0 4
61415: PUSH
61416: EMPTY
61417: LIST
61418: LIST
61419: LIST
61420: LIST
61421: PPUSH
61422: CALL 72719 0 3
61426: ST_TO_ADDR
// end ;
61427: LD_VAR 0 5
61431: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61432: LD_INT 0
61434: PPUSH
// if not mc_bases [ base ] then
61435: LD_EXP 100
61439: PUSH
61440: LD_VAR 0 1
61444: ARRAY
61445: NOT
61446: IFFALSE 61450
// exit ;
61448: GO 61475
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61450: LD_ADDR_EXP 137
61454: PUSH
61455: LD_EXP 137
61459: PPUSH
61460: LD_VAR 0 1
61464: PPUSH
61465: LD_VAR 0 2
61469: PPUSH
61470: CALL_OW 1
61474: ST_TO_ADDR
// end ;
61475: LD_VAR 0 3
61479: RET
// export function MC_GetMinesField ( base ) ; begin
61480: LD_INT 0
61482: PPUSH
// result := mc_mines [ base ] ;
61483: LD_ADDR_VAR 0 2
61487: PUSH
61488: LD_EXP 113
61492: PUSH
61493: LD_VAR 0 1
61497: ARRAY
61498: ST_TO_ADDR
// end ;
61499: LD_VAR 0 2
61503: RET
// export function MC_GetProduceList ( base ) ; begin
61504: LD_INT 0
61506: PPUSH
// result := mc_produce [ base ] ;
61507: LD_ADDR_VAR 0 2
61511: PUSH
61512: LD_EXP 121
61516: PUSH
61517: LD_VAR 0 1
61521: ARRAY
61522: ST_TO_ADDR
// end ;
61523: LD_VAR 0 2
61527: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61528: LD_INT 0
61530: PPUSH
61531: PPUSH
// if not mc_bases then
61532: LD_EXP 100
61536: NOT
61537: IFFALSE 61541
// exit ;
61539: GO 61606
// if mc_bases [ base ] then
61541: LD_EXP 100
61545: PUSH
61546: LD_VAR 0 1
61550: ARRAY
61551: IFFALSE 61606
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61553: LD_ADDR_VAR 0 3
61557: PUSH
61558: LD_EXP 100
61562: PUSH
61563: LD_VAR 0 1
61567: ARRAY
61568: PPUSH
61569: LD_INT 30
61571: PUSH
61572: LD_VAR 0 2
61576: PUSH
61577: EMPTY
61578: LIST
61579: LIST
61580: PPUSH
61581: CALL_OW 72
61585: ST_TO_ADDR
// if result then
61586: LD_VAR 0 3
61590: IFFALSE 61606
// result := result [ 1 ] ;
61592: LD_ADDR_VAR 0 3
61596: PUSH
61597: LD_VAR 0 3
61601: PUSH
61602: LD_INT 1
61604: ARRAY
61605: ST_TO_ADDR
// end ; end ;
61606: LD_VAR 0 3
61610: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61611: LD_INT 0
61613: PPUSH
61614: PPUSH
// if not mc_bases then
61615: LD_EXP 100
61619: NOT
61620: IFFALSE 61624
// exit ;
61622: GO 61669
// if mc_bases [ base ] then
61624: LD_EXP 100
61628: PUSH
61629: LD_VAR 0 1
61633: ARRAY
61634: IFFALSE 61669
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61636: LD_ADDR_VAR 0 3
61640: PUSH
61641: LD_EXP 100
61645: PUSH
61646: LD_VAR 0 1
61650: ARRAY
61651: PPUSH
61652: LD_INT 30
61654: PUSH
61655: LD_VAR 0 2
61659: PUSH
61660: EMPTY
61661: LIST
61662: LIST
61663: PPUSH
61664: CALL_OW 72
61668: ST_TO_ADDR
// end ;
61669: LD_VAR 0 3
61673: RET
// export function MC_SetTame ( base , area ) ; begin
61674: LD_INT 0
61676: PPUSH
// if not mc_bases or not base then
61677: LD_EXP 100
61681: NOT
61682: PUSH
61683: LD_VAR 0 1
61687: NOT
61688: OR
61689: IFFALSE 61693
// exit ;
61691: GO 61718
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61693: LD_ADDR_EXP 128
61697: PUSH
61698: LD_EXP 128
61702: PPUSH
61703: LD_VAR 0 1
61707: PPUSH
61708: LD_VAR 0 2
61712: PPUSH
61713: CALL_OW 1
61717: ST_TO_ADDR
// end ;
61718: LD_VAR 0 3
61722: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61723: LD_INT 0
61725: PPUSH
61726: PPUSH
// if not mc_bases or not base then
61727: LD_EXP 100
61731: NOT
61732: PUSH
61733: LD_VAR 0 1
61737: NOT
61738: OR
61739: IFFALSE 61743
// exit ;
61741: GO 61845
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61743: LD_ADDR_VAR 0 4
61747: PUSH
61748: LD_EXP 100
61752: PUSH
61753: LD_VAR 0 1
61757: ARRAY
61758: PPUSH
61759: LD_INT 30
61761: PUSH
61762: LD_VAR 0 2
61766: PUSH
61767: EMPTY
61768: LIST
61769: LIST
61770: PPUSH
61771: CALL_OW 72
61775: ST_TO_ADDR
// if not tmp then
61776: LD_VAR 0 4
61780: NOT
61781: IFFALSE 61785
// exit ;
61783: GO 61845
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61785: LD_ADDR_EXP 132
61789: PUSH
61790: LD_EXP 132
61794: PPUSH
61795: LD_VAR 0 1
61799: PPUSH
61800: LD_EXP 132
61804: PUSH
61805: LD_VAR 0 1
61809: ARRAY
61810: PPUSH
61811: LD_EXP 132
61815: PUSH
61816: LD_VAR 0 1
61820: ARRAY
61821: PUSH
61822: LD_INT 1
61824: PLUS
61825: PPUSH
61826: LD_VAR 0 4
61830: PUSH
61831: LD_INT 1
61833: ARRAY
61834: PPUSH
61835: CALL_OW 2
61839: PPUSH
61840: CALL_OW 1
61844: ST_TO_ADDR
// end ;
61845: LD_VAR 0 3
61849: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61850: LD_INT 0
61852: PPUSH
61853: PPUSH
// if not mc_bases or not base or not kinds then
61854: LD_EXP 100
61858: NOT
61859: PUSH
61860: LD_VAR 0 1
61864: NOT
61865: OR
61866: PUSH
61867: LD_VAR 0 2
61871: NOT
61872: OR
61873: IFFALSE 61877
// exit ;
61875: GO 61938
// for i in kinds do
61877: LD_ADDR_VAR 0 4
61881: PUSH
61882: LD_VAR 0 2
61886: PUSH
61887: FOR_IN
61888: IFFALSE 61936
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61890: LD_ADDR_EXP 134
61894: PUSH
61895: LD_EXP 134
61899: PPUSH
61900: LD_VAR 0 1
61904: PUSH
61905: LD_EXP 134
61909: PUSH
61910: LD_VAR 0 1
61914: ARRAY
61915: PUSH
61916: LD_INT 1
61918: PLUS
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: PPUSH
61924: LD_VAR 0 4
61928: PPUSH
61929: CALL 72719 0 3
61933: ST_TO_ADDR
61934: GO 61887
61936: POP
61937: POP
// end ;
61938: LD_VAR 0 3
61942: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61943: LD_INT 0
61945: PPUSH
// if not mc_bases or not base or not areas then
61946: LD_EXP 100
61950: NOT
61951: PUSH
61952: LD_VAR 0 1
61956: NOT
61957: OR
61958: PUSH
61959: LD_VAR 0 2
61963: NOT
61964: OR
61965: IFFALSE 61969
// exit ;
61967: GO 61994
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61969: LD_ADDR_EXP 118
61973: PUSH
61974: LD_EXP 118
61978: PPUSH
61979: LD_VAR 0 1
61983: PPUSH
61984: LD_VAR 0 2
61988: PPUSH
61989: CALL_OW 1
61993: ST_TO_ADDR
// end ;
61994: LD_VAR 0 3
61998: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61999: LD_INT 0
62001: PPUSH
// if not mc_bases or not base or not teleports_exit then
62002: LD_EXP 100
62006: NOT
62007: PUSH
62008: LD_VAR 0 1
62012: NOT
62013: OR
62014: PUSH
62015: LD_VAR 0 2
62019: NOT
62020: OR
62021: IFFALSE 62025
// exit ;
62023: GO 62050
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
62025: LD_ADDR_EXP 135
62029: PUSH
62030: LD_EXP 135
62034: PPUSH
62035: LD_VAR 0 1
62039: PPUSH
62040: LD_VAR 0 2
62044: PPUSH
62045: CALL_OW 1
62049: ST_TO_ADDR
// end ;
62050: LD_VAR 0 3
62054: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
62055: LD_INT 0
62057: PPUSH
62058: PPUSH
62059: PPUSH
// if not mc_bases or not base or not ext_list then
62060: LD_EXP 100
62064: NOT
62065: PUSH
62066: LD_VAR 0 1
62070: NOT
62071: OR
62072: PUSH
62073: LD_VAR 0 5
62077: NOT
62078: OR
62079: IFFALSE 62083
// exit ;
62081: GO 62256
// tmp := GetFacExtXYD ( x , y , d ) ;
62083: LD_ADDR_VAR 0 8
62087: PUSH
62088: LD_VAR 0 2
62092: PPUSH
62093: LD_VAR 0 3
62097: PPUSH
62098: LD_VAR 0 4
62102: PPUSH
62103: CALL 102696 0 3
62107: ST_TO_ADDR
// if not tmp then
62108: LD_VAR 0 8
62112: NOT
62113: IFFALSE 62117
// exit ;
62115: GO 62256
// for i in tmp do
62117: LD_ADDR_VAR 0 7
62121: PUSH
62122: LD_VAR 0 8
62126: PUSH
62127: FOR_IN
62128: IFFALSE 62254
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
62130: LD_ADDR_EXP 105
62134: PUSH
62135: LD_EXP 105
62139: PPUSH
62140: LD_VAR 0 1
62144: PPUSH
62145: LD_EXP 105
62149: PUSH
62150: LD_VAR 0 1
62154: ARRAY
62155: PPUSH
62156: LD_EXP 105
62160: PUSH
62161: LD_VAR 0 1
62165: ARRAY
62166: PUSH
62167: LD_INT 1
62169: PLUS
62170: PPUSH
62171: LD_VAR 0 5
62175: PUSH
62176: LD_INT 1
62178: ARRAY
62179: PUSH
62180: LD_VAR 0 7
62184: PUSH
62185: LD_INT 1
62187: ARRAY
62188: PUSH
62189: LD_VAR 0 7
62193: PUSH
62194: LD_INT 2
62196: ARRAY
62197: PUSH
62198: LD_VAR 0 7
62202: PUSH
62203: LD_INT 3
62205: ARRAY
62206: PUSH
62207: EMPTY
62208: LIST
62209: LIST
62210: LIST
62211: LIST
62212: PPUSH
62213: CALL_OW 2
62217: PPUSH
62218: CALL_OW 1
62222: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
62223: LD_ADDR_VAR 0 5
62227: PUSH
62228: LD_VAR 0 5
62232: PPUSH
62233: LD_INT 1
62235: PPUSH
62236: CALL_OW 3
62240: ST_TO_ADDR
// if not ext_list then
62241: LD_VAR 0 5
62245: NOT
62246: IFFALSE 62252
// exit ;
62248: POP
62249: POP
62250: GO 62256
// end ;
62252: GO 62127
62254: POP
62255: POP
// end ;
62256: LD_VAR 0 6
62260: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
62261: LD_INT 0
62263: PPUSH
// if not mc_bases or not base or not weapon_list then
62264: LD_EXP 100
62268: NOT
62269: PUSH
62270: LD_VAR 0 1
62274: NOT
62275: OR
62276: PUSH
62277: LD_VAR 0 2
62281: NOT
62282: OR
62283: IFFALSE 62287
// exit ;
62285: GO 62312
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
62287: LD_ADDR_EXP 139
62291: PUSH
62292: LD_EXP 139
62296: PPUSH
62297: LD_VAR 0 1
62301: PPUSH
62302: LD_VAR 0 2
62306: PPUSH
62307: CALL_OW 1
62311: ST_TO_ADDR
// end ;
62312: LD_VAR 0 3
62316: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
62317: LD_INT 0
62319: PPUSH
// if not mc_bases or not base or not tech_list then
62320: LD_EXP 100
62324: NOT
62325: PUSH
62326: LD_VAR 0 1
62330: NOT
62331: OR
62332: PUSH
62333: LD_VAR 0 2
62337: NOT
62338: OR
62339: IFFALSE 62343
// exit ;
62341: GO 62368
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
62343: LD_ADDR_EXP 127
62347: PUSH
62348: LD_EXP 127
62352: PPUSH
62353: LD_VAR 0 1
62357: PPUSH
62358: LD_VAR 0 2
62362: PPUSH
62363: CALL_OW 1
62367: ST_TO_ADDR
// end ;
62368: LD_VAR 0 3
62372: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62373: LD_INT 0
62375: PPUSH
// if not mc_bases or not parking_area or not base then
62376: LD_EXP 100
62380: NOT
62381: PUSH
62382: LD_VAR 0 2
62386: NOT
62387: OR
62388: PUSH
62389: LD_VAR 0 1
62393: NOT
62394: OR
62395: IFFALSE 62399
// exit ;
62397: GO 62424
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62399: LD_ADDR_EXP 124
62403: PUSH
62404: LD_EXP 124
62408: PPUSH
62409: LD_VAR 0 1
62413: PPUSH
62414: LD_VAR 0 2
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// end ;
62424: LD_VAR 0 3
62428: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62429: LD_INT 0
62431: PPUSH
// if not mc_bases or not base or not scan_area then
62432: LD_EXP 100
62436: NOT
62437: PUSH
62438: LD_VAR 0 1
62442: NOT
62443: OR
62444: PUSH
62445: LD_VAR 0 2
62449: NOT
62450: OR
62451: IFFALSE 62455
// exit ;
62453: GO 62480
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62455: LD_ADDR_EXP 125
62459: PUSH
62460: LD_EXP 125
62464: PPUSH
62465: LD_VAR 0 1
62469: PPUSH
62470: LD_VAR 0 2
62474: PPUSH
62475: CALL_OW 1
62479: ST_TO_ADDR
// end ;
62480: LD_VAR 0 3
62484: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62485: LD_INT 0
62487: PPUSH
62488: PPUSH
// if not mc_bases or not base then
62489: LD_EXP 100
62493: NOT
62494: PUSH
62495: LD_VAR 0 1
62499: NOT
62500: OR
62501: IFFALSE 62505
// exit ;
62503: GO 62569
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62505: LD_ADDR_VAR 0 3
62509: PUSH
62510: LD_INT 1
62512: PUSH
62513: LD_INT 2
62515: PUSH
62516: LD_INT 3
62518: PUSH
62519: LD_INT 4
62521: PUSH
62522: LD_INT 11
62524: PUSH
62525: EMPTY
62526: LIST
62527: LIST
62528: LIST
62529: LIST
62530: LIST
62531: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62532: LD_ADDR_EXP 127
62536: PUSH
62537: LD_EXP 127
62541: PPUSH
62542: LD_VAR 0 1
62546: PPUSH
62547: LD_EXP 127
62551: PUSH
62552: LD_VAR 0 1
62556: ARRAY
62557: PUSH
62558: LD_VAR 0 3
62562: DIFF
62563: PPUSH
62564: CALL_OW 1
62568: ST_TO_ADDR
// end ;
62569: LD_VAR 0 2
62573: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62574: LD_INT 0
62576: PPUSH
// result := mc_vehicles [ base ] ;
62577: LD_ADDR_VAR 0 3
62581: PUSH
62582: LD_EXP 119
62586: PUSH
62587: LD_VAR 0 1
62591: ARRAY
62592: ST_TO_ADDR
// if onlyCombat then
62593: LD_VAR 0 2
62597: IFFALSE 62769
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62599: LD_ADDR_VAR 0 3
62603: PUSH
62604: LD_VAR 0 3
62608: PUSH
62609: LD_VAR 0 3
62613: PPUSH
62614: LD_INT 2
62616: PUSH
62617: LD_INT 34
62619: PUSH
62620: LD_INT 12
62622: PUSH
62623: EMPTY
62624: LIST
62625: LIST
62626: PUSH
62627: LD_INT 34
62629: PUSH
62630: LD_INT 51
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: PUSH
62637: LD_INT 34
62639: PUSH
62640: LD_INT 89
62642: PUSH
62643: EMPTY
62644: LIST
62645: LIST
62646: PUSH
62647: LD_INT 34
62649: PUSH
62650: LD_INT 32
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PUSH
62657: LD_INT 34
62659: PUSH
62660: LD_INT 13
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PUSH
62667: LD_INT 34
62669: PUSH
62670: LD_INT 52
62672: PUSH
62673: EMPTY
62674: LIST
62675: LIST
62676: PUSH
62677: LD_INT 34
62679: PUSH
62680: LD_INT 88
62682: PUSH
62683: EMPTY
62684: LIST
62685: LIST
62686: PUSH
62687: LD_INT 34
62689: PUSH
62690: LD_INT 14
62692: PUSH
62693: EMPTY
62694: LIST
62695: LIST
62696: PUSH
62697: LD_INT 34
62699: PUSH
62700: LD_INT 53
62702: PUSH
62703: EMPTY
62704: LIST
62705: LIST
62706: PUSH
62707: LD_INT 34
62709: PUSH
62710: LD_INT 98
62712: PUSH
62713: EMPTY
62714: LIST
62715: LIST
62716: PUSH
62717: LD_INT 34
62719: PUSH
62720: LD_INT 31
62722: PUSH
62723: EMPTY
62724: LIST
62725: LIST
62726: PUSH
62727: LD_INT 34
62729: PUSH
62730: LD_INT 48
62732: PUSH
62733: EMPTY
62734: LIST
62735: LIST
62736: PUSH
62737: LD_INT 34
62739: PUSH
62740: LD_INT 8
62742: PUSH
62743: EMPTY
62744: LIST
62745: LIST
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: LIST
62753: LIST
62754: LIST
62755: LIST
62756: LIST
62757: LIST
62758: LIST
62759: LIST
62760: LIST
62761: LIST
62762: PPUSH
62763: CALL_OW 72
62767: DIFF
62768: ST_TO_ADDR
// end ; end_of_file
62769: LD_VAR 0 3
62773: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62774: LD_INT 0
62776: PPUSH
62777: PPUSH
62778: PPUSH
// if not mc_bases or not skirmish then
62779: LD_EXP 100
62783: NOT
62784: PUSH
62785: LD_EXP 98
62789: NOT
62790: OR
62791: IFFALSE 62795
// exit ;
62793: GO 62960
// for i = 1 to mc_bases do
62795: LD_ADDR_VAR 0 4
62799: PUSH
62800: DOUBLE
62801: LD_INT 1
62803: DEC
62804: ST_TO_ADDR
62805: LD_EXP 100
62809: PUSH
62810: FOR_TO
62811: IFFALSE 62958
// begin if sci in mc_bases [ i ] then
62813: LD_VAR 0 2
62817: PUSH
62818: LD_EXP 100
62822: PUSH
62823: LD_VAR 0 4
62827: ARRAY
62828: IN
62829: IFFALSE 62956
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62831: LD_ADDR_EXP 129
62835: PUSH
62836: LD_EXP 129
62840: PPUSH
62841: LD_VAR 0 4
62845: PUSH
62846: LD_EXP 129
62850: PUSH
62851: LD_VAR 0 4
62855: ARRAY
62856: PUSH
62857: LD_INT 1
62859: PLUS
62860: PUSH
62861: EMPTY
62862: LIST
62863: LIST
62864: PPUSH
62865: LD_VAR 0 1
62869: PPUSH
62870: CALL 72719 0 3
62874: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62875: LD_ADDR_VAR 0 5
62879: PUSH
62880: LD_EXP 100
62884: PUSH
62885: LD_VAR 0 4
62889: ARRAY
62890: PPUSH
62891: LD_INT 2
62893: PUSH
62894: LD_INT 30
62896: PUSH
62897: LD_INT 0
62899: PUSH
62900: EMPTY
62901: LIST
62902: LIST
62903: PUSH
62904: LD_INT 30
62906: PUSH
62907: LD_INT 1
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: EMPTY
62915: LIST
62916: LIST
62917: LIST
62918: PPUSH
62919: CALL_OW 72
62923: PPUSH
62924: LD_VAR 0 1
62928: PPUSH
62929: CALL_OW 74
62933: ST_TO_ADDR
// if tmp then
62934: LD_VAR 0 5
62938: IFFALSE 62954
// ComStandNearbyBuilding ( ape , tmp ) ;
62940: LD_VAR 0 1
62944: PPUSH
62945: LD_VAR 0 5
62949: PPUSH
62950: CALL 69146 0 2
// break ;
62954: GO 62958
// end ; end ;
62956: GO 62810
62958: POP
62959: POP
// end ;
62960: LD_VAR 0 3
62964: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62965: LD_INT 0
62967: PPUSH
62968: PPUSH
62969: PPUSH
// if not mc_bases or not skirmish then
62970: LD_EXP 100
62974: NOT
62975: PUSH
62976: LD_EXP 98
62980: NOT
62981: OR
62982: IFFALSE 62986
// exit ;
62984: GO 63075
// for i = 1 to mc_bases do
62986: LD_ADDR_VAR 0 4
62990: PUSH
62991: DOUBLE
62992: LD_INT 1
62994: DEC
62995: ST_TO_ADDR
62996: LD_EXP 100
63000: PUSH
63001: FOR_TO
63002: IFFALSE 63073
// begin if building in mc_busy_turret_list [ i ] then
63004: LD_VAR 0 1
63008: PUSH
63009: LD_EXP 110
63013: PUSH
63014: LD_VAR 0 4
63018: ARRAY
63019: IN
63020: IFFALSE 63071
// begin tmp := mc_busy_turret_list [ i ] diff building ;
63022: LD_ADDR_VAR 0 5
63026: PUSH
63027: LD_EXP 110
63031: PUSH
63032: LD_VAR 0 4
63036: ARRAY
63037: PUSH
63038: LD_VAR 0 1
63042: DIFF
63043: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
63044: LD_ADDR_EXP 110
63048: PUSH
63049: LD_EXP 110
63053: PPUSH
63054: LD_VAR 0 4
63058: PPUSH
63059: LD_VAR 0 5
63063: PPUSH
63064: CALL_OW 1
63068: ST_TO_ADDR
// break ;
63069: GO 63073
// end ; end ;
63071: GO 63001
63073: POP
63074: POP
// end ;
63075: LD_VAR 0 3
63079: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
63080: LD_INT 0
63082: PPUSH
63083: PPUSH
63084: PPUSH
// if not mc_bases or not skirmish then
63085: LD_EXP 100
63089: NOT
63090: PUSH
63091: LD_EXP 98
63095: NOT
63096: OR
63097: IFFALSE 63101
// exit ;
63099: GO 63300
// for i = 1 to mc_bases do
63101: LD_ADDR_VAR 0 5
63105: PUSH
63106: DOUBLE
63107: LD_INT 1
63109: DEC
63110: ST_TO_ADDR
63111: LD_EXP 100
63115: PUSH
63116: FOR_TO
63117: IFFALSE 63298
// if building in mc_bases [ i ] then
63119: LD_VAR 0 1
63123: PUSH
63124: LD_EXP 100
63128: PUSH
63129: LD_VAR 0 5
63133: ARRAY
63134: IN
63135: IFFALSE 63296
// begin tmp := mc_bases [ i ] diff building ;
63137: LD_ADDR_VAR 0 6
63141: PUSH
63142: LD_EXP 100
63146: PUSH
63147: LD_VAR 0 5
63151: ARRAY
63152: PUSH
63153: LD_VAR 0 1
63157: DIFF
63158: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
63159: LD_ADDR_EXP 100
63163: PUSH
63164: LD_EXP 100
63168: PPUSH
63169: LD_VAR 0 5
63173: PPUSH
63174: LD_VAR 0 6
63178: PPUSH
63179: CALL_OW 1
63183: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
63184: LD_VAR 0 1
63188: PUSH
63189: LD_EXP 108
63193: PUSH
63194: LD_VAR 0 5
63198: ARRAY
63199: IN
63200: IFFALSE 63239
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
63202: LD_ADDR_EXP 108
63206: PUSH
63207: LD_EXP 108
63211: PPUSH
63212: LD_VAR 0 5
63216: PPUSH
63217: LD_EXP 108
63221: PUSH
63222: LD_VAR 0 5
63226: ARRAY
63227: PUSH
63228: LD_VAR 0 1
63232: DIFF
63233: PPUSH
63234: CALL_OW 1
63238: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
63239: LD_VAR 0 1
63243: PUSH
63244: LD_EXP 109
63248: PUSH
63249: LD_VAR 0 5
63253: ARRAY
63254: IN
63255: IFFALSE 63294
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
63257: LD_ADDR_EXP 109
63261: PUSH
63262: LD_EXP 109
63266: PPUSH
63267: LD_VAR 0 5
63271: PPUSH
63272: LD_EXP 109
63276: PUSH
63277: LD_VAR 0 5
63281: ARRAY
63282: PUSH
63283: LD_VAR 0 1
63287: DIFF
63288: PPUSH
63289: CALL_OW 1
63293: ST_TO_ADDR
// break ;
63294: GO 63298
// end ;
63296: GO 63116
63298: POP
63299: POP
// end ;
63300: LD_VAR 0 4
63304: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
63305: LD_INT 0
63307: PPUSH
63308: PPUSH
63309: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
63310: LD_EXP 100
63314: NOT
63315: PUSH
63316: LD_EXP 98
63320: NOT
63321: OR
63322: PUSH
63323: LD_VAR 0 3
63327: PUSH
63328: LD_EXP 126
63332: IN
63333: NOT
63334: OR
63335: IFFALSE 63339
// exit ;
63337: GO 63462
// for i = 1 to mc_vehicles do
63339: LD_ADDR_VAR 0 6
63343: PUSH
63344: DOUBLE
63345: LD_INT 1
63347: DEC
63348: ST_TO_ADDR
63349: LD_EXP 119
63353: PUSH
63354: FOR_TO
63355: IFFALSE 63460
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63357: LD_VAR 0 2
63361: PUSH
63362: LD_EXP 119
63366: PUSH
63367: LD_VAR 0 6
63371: ARRAY
63372: IN
63373: PUSH
63374: LD_VAR 0 1
63378: PUSH
63379: LD_EXP 119
63383: PUSH
63384: LD_VAR 0 6
63388: ARRAY
63389: IN
63390: OR
63391: IFFALSE 63458
// begin tmp := mc_vehicles [ i ] diff old ;
63393: LD_ADDR_VAR 0 7
63397: PUSH
63398: LD_EXP 119
63402: PUSH
63403: LD_VAR 0 6
63407: ARRAY
63408: PUSH
63409: LD_VAR 0 2
63413: DIFF
63414: ST_TO_ADDR
// tmp := tmp diff new ;
63415: LD_ADDR_VAR 0 7
63419: PUSH
63420: LD_VAR 0 7
63424: PUSH
63425: LD_VAR 0 1
63429: DIFF
63430: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63431: LD_ADDR_EXP 119
63435: PUSH
63436: LD_EXP 119
63440: PPUSH
63441: LD_VAR 0 6
63445: PPUSH
63446: LD_VAR 0 7
63450: PPUSH
63451: CALL_OW 1
63455: ST_TO_ADDR
// break ;
63456: GO 63460
// end ;
63458: GO 63354
63460: POP
63461: POP
// end ;
63462: LD_VAR 0 5
63466: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63467: LD_INT 0
63469: PPUSH
63470: PPUSH
63471: PPUSH
63472: PPUSH
// if not mc_bases or not skirmish then
63473: LD_EXP 100
63477: NOT
63478: PUSH
63479: LD_EXP 98
63483: NOT
63484: OR
63485: IFFALSE 63489
// exit ;
63487: GO 63909
// repeat wait ( 0 0$1 ) ;
63489: LD_INT 35
63491: PPUSH
63492: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
63496: LD_EXP 144
63500: NOT
63501: IFFALSE 63489
// mc_block_vehicle_constructed_thread := true ;
63503: LD_ADDR_EXP 144
63507: PUSH
63508: LD_INT 1
63510: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
63511: LD_ADDR_VAR 0 5
63515: PUSH
63516: LD_VAR 0 1
63520: PPUSH
63521: CALL_OW 255
63525: ST_TO_ADDR
// for i = 1 to mc_bases do
63526: LD_ADDR_VAR 0 4
63530: PUSH
63531: DOUBLE
63532: LD_INT 1
63534: DEC
63535: ST_TO_ADDR
63536: LD_EXP 100
63540: PUSH
63541: FOR_TO
63542: IFFALSE 63899
// begin if factory in mc_bases [ i ] then
63544: LD_VAR 0 2
63548: PUSH
63549: LD_EXP 100
63553: PUSH
63554: LD_VAR 0 4
63558: ARRAY
63559: IN
63560: IFFALSE 63897
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63562: LD_EXP 122
63566: PUSH
63567: LD_VAR 0 4
63571: ARRAY
63572: PUSH
63573: LD_EXP 111
63577: PUSH
63578: LD_VAR 0 4
63582: ARRAY
63583: LESS
63584: PUSH
63585: LD_VAR 0 1
63589: PPUSH
63590: CALL_OW 264
63594: PUSH
63595: LD_INT 31
63597: PUSH
63598: LD_INT 32
63600: PUSH
63601: LD_INT 51
63603: PUSH
63604: LD_INT 89
63606: PUSH
63607: LD_INT 12
63609: PUSH
63610: LD_INT 30
63612: PUSH
63613: LD_INT 98
63615: PUSH
63616: LD_INT 11
63618: PUSH
63619: LD_INT 53
63621: PUSH
63622: LD_INT 14
63624: PUSH
63625: LD_INT 91
63627: PUSH
63628: LD_INT 29
63630: PUSH
63631: LD_INT 99
63633: PUSH
63634: LD_INT 13
63636: PUSH
63637: LD_INT 52
63639: PUSH
63640: LD_INT 88
63642: PUSH
63643: LD_INT 48
63645: PUSH
63646: LD_INT 8
63648: PUSH
63649: EMPTY
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: IN
63669: NOT
63670: AND
63671: IFFALSE 63719
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63673: LD_ADDR_EXP 122
63677: PUSH
63678: LD_EXP 122
63682: PPUSH
63683: LD_VAR 0 4
63687: PUSH
63688: LD_EXP 122
63692: PUSH
63693: LD_VAR 0 4
63697: ARRAY
63698: PUSH
63699: LD_INT 1
63701: PLUS
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PPUSH
63707: LD_VAR 0 1
63711: PPUSH
63712: CALL 72719 0 3
63716: ST_TO_ADDR
63717: GO 63763
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63719: LD_ADDR_EXP 119
63723: PUSH
63724: LD_EXP 119
63728: PPUSH
63729: LD_VAR 0 4
63733: PUSH
63734: LD_EXP 119
63738: PUSH
63739: LD_VAR 0 4
63743: ARRAY
63744: PUSH
63745: LD_INT 1
63747: PLUS
63748: PUSH
63749: EMPTY
63750: LIST
63751: LIST
63752: PPUSH
63753: LD_VAR 0 1
63757: PPUSH
63758: CALL 72719 0 3
63762: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
63763: LD_ADDR_EXP 144
63767: PUSH
63768: LD_INT 0
63770: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63771: LD_VAR 0 1
63775: PPUSH
63776: CALL_OW 263
63780: PUSH
63781: LD_INT 2
63783: EQUAL
63784: IFFALSE 63813
// begin repeat wait ( 0 0$3 ) ;
63786: LD_INT 105
63788: PPUSH
63789: CALL_OW 67
// Connect ( vehicle ) ;
63793: LD_VAR 0 1
63797: PPUSH
63798: CALL 75688 0 1
// until IsControledBy ( vehicle ) ;
63802: LD_VAR 0 1
63806: PPUSH
63807: CALL_OW 312
63811: IFFALSE 63786
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63813: LD_VAR 0 1
63817: PPUSH
63818: LD_EXP 124
63822: PUSH
63823: LD_VAR 0 4
63827: ARRAY
63828: PPUSH
63829: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63833: LD_VAR 0 1
63837: PPUSH
63838: CALL_OW 263
63842: PUSH
63843: LD_INT 1
63845: NONEQUAL
63846: IFFALSE 63850
// break ;
63848: GO 63899
// repeat wait ( 0 0$1 ) ;
63850: LD_INT 35
63852: PPUSH
63853: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63857: LD_VAR 0 1
63861: PPUSH
63862: LD_EXP 124
63866: PUSH
63867: LD_VAR 0 4
63871: ARRAY
63872: PPUSH
63873: CALL_OW 308
63877: IFFALSE 63850
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63879: LD_VAR 0 1
63883: PPUSH
63884: CALL_OW 311
63888: PPUSH
63889: CALL_OW 121
// exit ;
63893: POP
63894: POP
63895: GO 63909
// end ; end ;
63897: GO 63541
63899: POP
63900: POP
// mc_block_vehicle_constructed_thread := false ;
63901: LD_ADDR_EXP 144
63905: PUSH
63906: LD_INT 0
63908: ST_TO_ADDR
// end ;
63909: LD_VAR 0 3
63913: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63914: LD_INT 0
63916: PPUSH
63917: PPUSH
63918: PPUSH
63919: PPUSH
// if not mc_bases or not skirmish then
63920: LD_EXP 100
63924: NOT
63925: PUSH
63926: LD_EXP 98
63930: NOT
63931: OR
63932: IFFALSE 63936
// exit ;
63934: GO 64289
// repeat wait ( 0 0$1 ) ;
63936: LD_INT 35
63938: PPUSH
63939: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63943: LD_VAR 0 2
63947: PPUSH
63948: LD_VAR 0 3
63952: PPUSH
63953: CALL_OW 284
63957: IFFALSE 63936
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63959: LD_VAR 0 2
63963: PPUSH
63964: LD_VAR 0 3
63968: PPUSH
63969: CALL_OW 283
63973: PUSH
63974: LD_INT 4
63976: EQUAL
63977: IFFALSE 63981
// exit ;
63979: GO 64289
// for i = 1 to mc_bases do
63981: LD_ADDR_VAR 0 7
63985: PUSH
63986: DOUBLE
63987: LD_INT 1
63989: DEC
63990: ST_TO_ADDR
63991: LD_EXP 100
63995: PUSH
63996: FOR_TO
63997: IFFALSE 64287
// begin if mc_crates_area [ i ] then
63999: LD_EXP 118
64003: PUSH
64004: LD_VAR 0 7
64008: ARRAY
64009: IFFALSE 64120
// for j in mc_crates_area [ i ] do
64011: LD_ADDR_VAR 0 8
64015: PUSH
64016: LD_EXP 118
64020: PUSH
64021: LD_VAR 0 7
64025: ARRAY
64026: PUSH
64027: FOR_IN
64028: IFFALSE 64118
// if InArea ( x , y , j ) then
64030: LD_VAR 0 2
64034: PPUSH
64035: LD_VAR 0 3
64039: PPUSH
64040: LD_VAR 0 8
64044: PPUSH
64045: CALL_OW 309
64049: IFFALSE 64116
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64051: LD_ADDR_EXP 116
64055: PUSH
64056: LD_EXP 116
64060: PPUSH
64061: LD_VAR 0 7
64065: PUSH
64066: LD_EXP 116
64070: PUSH
64071: LD_VAR 0 7
64075: ARRAY
64076: PUSH
64077: LD_INT 1
64079: PLUS
64080: PUSH
64081: EMPTY
64082: LIST
64083: LIST
64084: PPUSH
64085: LD_VAR 0 4
64089: PUSH
64090: LD_VAR 0 2
64094: PUSH
64095: LD_VAR 0 3
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: LIST
64104: PPUSH
64105: CALL 72719 0 3
64109: ST_TO_ADDR
// exit ;
64110: POP
64111: POP
64112: POP
64113: POP
64114: GO 64289
// end ;
64116: GO 64027
64118: POP
64119: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64120: LD_ADDR_VAR 0 9
64124: PUSH
64125: LD_EXP 100
64129: PUSH
64130: LD_VAR 0 7
64134: ARRAY
64135: PPUSH
64136: LD_INT 2
64138: PUSH
64139: LD_INT 30
64141: PUSH
64142: LD_INT 0
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: LD_INT 30
64151: PUSH
64152: LD_INT 1
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: LIST
64163: PPUSH
64164: CALL_OW 72
64168: ST_TO_ADDR
// if not depot then
64169: LD_VAR 0 9
64173: NOT
64174: IFFALSE 64178
// continue ;
64176: GO 63996
// for j in depot do
64178: LD_ADDR_VAR 0 8
64182: PUSH
64183: LD_VAR 0 9
64187: PUSH
64188: FOR_IN
64189: IFFALSE 64283
// if GetDistUnitXY ( j , x , y ) < 30 then
64191: LD_VAR 0 8
64195: PPUSH
64196: LD_VAR 0 2
64200: PPUSH
64201: LD_VAR 0 3
64205: PPUSH
64206: CALL_OW 297
64210: PUSH
64211: LD_INT 30
64213: LESS
64214: IFFALSE 64281
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
64216: LD_ADDR_EXP 116
64220: PUSH
64221: LD_EXP 116
64225: PPUSH
64226: LD_VAR 0 7
64230: PUSH
64231: LD_EXP 116
64235: PUSH
64236: LD_VAR 0 7
64240: ARRAY
64241: PUSH
64242: LD_INT 1
64244: PLUS
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PPUSH
64250: LD_VAR 0 4
64254: PUSH
64255: LD_VAR 0 2
64259: PUSH
64260: LD_VAR 0 3
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: LIST
64269: PPUSH
64270: CALL 72719 0 3
64274: ST_TO_ADDR
// exit ;
64275: POP
64276: POP
64277: POP
64278: POP
64279: GO 64289
// end ;
64281: GO 64188
64283: POP
64284: POP
// end ;
64285: GO 63996
64287: POP
64288: POP
// end ;
64289: LD_VAR 0 6
64293: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
64294: LD_INT 0
64296: PPUSH
64297: PPUSH
64298: PPUSH
64299: PPUSH
// if not mc_bases or not skirmish then
64300: LD_EXP 100
64304: NOT
64305: PUSH
64306: LD_EXP 98
64310: NOT
64311: OR
64312: IFFALSE 64316
// exit ;
64314: GO 64593
// side := GetSide ( lab ) ;
64316: LD_ADDR_VAR 0 4
64320: PUSH
64321: LD_VAR 0 2
64325: PPUSH
64326: CALL_OW 255
64330: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
64331: LD_VAR 0 4
64335: PUSH
64336: LD_EXP 126
64340: IN
64341: NOT
64342: PUSH
64343: LD_EXP 127
64347: NOT
64348: OR
64349: PUSH
64350: LD_EXP 100
64354: NOT
64355: OR
64356: IFFALSE 64360
// exit ;
64358: GO 64593
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
64360: LD_ADDR_EXP 127
64364: PUSH
64365: LD_EXP 127
64369: PPUSH
64370: LD_VAR 0 4
64374: PPUSH
64375: LD_EXP 127
64379: PUSH
64380: LD_VAR 0 4
64384: ARRAY
64385: PUSH
64386: LD_VAR 0 1
64390: DIFF
64391: PPUSH
64392: CALL_OW 1
64396: ST_TO_ADDR
// for i = 1 to mc_bases do
64397: LD_ADDR_VAR 0 5
64401: PUSH
64402: DOUBLE
64403: LD_INT 1
64405: DEC
64406: ST_TO_ADDR
64407: LD_EXP 100
64411: PUSH
64412: FOR_TO
64413: IFFALSE 64591
// begin if lab in mc_bases [ i ] then
64415: LD_VAR 0 2
64419: PUSH
64420: LD_EXP 100
64424: PUSH
64425: LD_VAR 0 5
64429: ARRAY
64430: IN
64431: IFFALSE 64589
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64433: LD_VAR 0 1
64437: PUSH
64438: LD_INT 11
64440: PUSH
64441: LD_INT 4
64443: PUSH
64444: LD_INT 3
64446: PUSH
64447: LD_INT 2
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: IN
64456: PUSH
64457: LD_EXP 130
64461: PUSH
64462: LD_VAR 0 5
64466: ARRAY
64467: AND
64468: IFFALSE 64589
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64470: LD_ADDR_VAR 0 6
64474: PUSH
64475: LD_EXP 130
64479: PUSH
64480: LD_VAR 0 5
64484: ARRAY
64485: PUSH
64486: LD_INT 1
64488: ARRAY
64489: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64490: LD_ADDR_EXP 130
64494: PUSH
64495: LD_EXP 130
64499: PPUSH
64500: LD_VAR 0 5
64504: PPUSH
64505: EMPTY
64506: PPUSH
64507: CALL_OW 1
64511: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64512: LD_VAR 0 6
64516: PPUSH
64517: LD_INT 0
64519: PPUSH
64520: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64524: LD_VAR 0 6
64528: PPUSH
64529: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64533: LD_ADDR_EXP 129
64537: PUSH
64538: LD_EXP 129
64542: PPUSH
64543: LD_VAR 0 5
64547: PPUSH
64548: LD_EXP 129
64552: PUSH
64553: LD_VAR 0 5
64557: ARRAY
64558: PPUSH
64559: LD_INT 1
64561: PPUSH
64562: LD_VAR 0 6
64566: PPUSH
64567: CALL_OW 2
64571: PPUSH
64572: CALL_OW 1
64576: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64577: LD_VAR 0 5
64581: PPUSH
64582: LD_INT 112
64584: PPUSH
64585: CALL 41041 0 2
// end ; end ; end ;
64589: GO 64412
64591: POP
64592: POP
// end ;
64593: LD_VAR 0 3
64597: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64598: LD_INT 0
64600: PPUSH
64601: PPUSH
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
64606: PPUSH
64607: PPUSH
// if not mc_bases or not skirmish then
64608: LD_EXP 100
64612: NOT
64613: PUSH
64614: LD_EXP 98
64618: NOT
64619: OR
64620: IFFALSE 64624
// exit ;
64622: GO 65993
// for i = 1 to mc_bases do
64624: LD_ADDR_VAR 0 3
64628: PUSH
64629: DOUBLE
64630: LD_INT 1
64632: DEC
64633: ST_TO_ADDR
64634: LD_EXP 100
64638: PUSH
64639: FOR_TO
64640: IFFALSE 65991
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64642: LD_VAR 0 1
64646: PUSH
64647: LD_EXP 100
64651: PUSH
64652: LD_VAR 0 3
64656: ARRAY
64657: IN
64658: PUSH
64659: LD_VAR 0 1
64663: PUSH
64664: LD_EXP 107
64668: PUSH
64669: LD_VAR 0 3
64673: ARRAY
64674: IN
64675: OR
64676: PUSH
64677: LD_VAR 0 1
64681: PUSH
64682: LD_EXP 122
64686: PUSH
64687: LD_VAR 0 3
64691: ARRAY
64692: IN
64693: OR
64694: PUSH
64695: LD_VAR 0 1
64699: PUSH
64700: LD_EXP 119
64704: PUSH
64705: LD_VAR 0 3
64709: ARRAY
64710: IN
64711: OR
64712: PUSH
64713: LD_VAR 0 1
64717: PUSH
64718: LD_EXP 129
64722: PUSH
64723: LD_VAR 0 3
64727: ARRAY
64728: IN
64729: OR
64730: PUSH
64731: LD_VAR 0 1
64735: PUSH
64736: LD_EXP 130
64740: PUSH
64741: LD_VAR 0 3
64745: ARRAY
64746: IN
64747: OR
64748: IFFALSE 65989
// begin if un in mc_ape [ i ] then
64750: LD_VAR 0 1
64754: PUSH
64755: LD_EXP 129
64759: PUSH
64760: LD_VAR 0 3
64764: ARRAY
64765: IN
64766: IFFALSE 64805
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64768: LD_ADDR_EXP 129
64772: PUSH
64773: LD_EXP 129
64777: PPUSH
64778: LD_VAR 0 3
64782: PPUSH
64783: LD_EXP 129
64787: PUSH
64788: LD_VAR 0 3
64792: ARRAY
64793: PUSH
64794: LD_VAR 0 1
64798: DIFF
64799: PPUSH
64800: CALL_OW 1
64804: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64805: LD_VAR 0 1
64809: PUSH
64810: LD_EXP 130
64814: PUSH
64815: LD_VAR 0 3
64819: ARRAY
64820: IN
64821: IFFALSE 64845
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64823: LD_ADDR_EXP 130
64827: PUSH
64828: LD_EXP 130
64832: PPUSH
64833: LD_VAR 0 3
64837: PPUSH
64838: EMPTY
64839: PPUSH
64840: CALL_OW 1
64844: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64845: LD_VAR 0 1
64849: PPUSH
64850: CALL_OW 247
64854: PUSH
64855: LD_INT 2
64857: EQUAL
64858: PUSH
64859: LD_VAR 0 1
64863: PPUSH
64864: CALL_OW 110
64868: PUSH
64869: LD_INT 20
64871: EQUAL
64872: PUSH
64873: LD_VAR 0 1
64877: PUSH
64878: LD_EXP 122
64882: PUSH
64883: LD_VAR 0 3
64887: ARRAY
64888: IN
64889: OR
64890: PUSH
64891: LD_VAR 0 1
64895: PPUSH
64896: CALL_OW 264
64900: PUSH
64901: LD_INT 12
64903: PUSH
64904: LD_INT 51
64906: PUSH
64907: LD_INT 89
64909: PUSH
64910: LD_INT 32
64912: PUSH
64913: LD_INT 13
64915: PUSH
64916: LD_INT 52
64918: PUSH
64919: LD_INT 31
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: IN
64931: OR
64932: AND
64933: IFFALSE 65241
// begin if un in mc_defender [ i ] then
64935: LD_VAR 0 1
64939: PUSH
64940: LD_EXP 122
64944: PUSH
64945: LD_VAR 0 3
64949: ARRAY
64950: IN
64951: IFFALSE 64990
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64953: LD_ADDR_EXP 122
64957: PUSH
64958: LD_EXP 122
64962: PPUSH
64963: LD_VAR 0 3
64967: PPUSH
64968: LD_EXP 122
64972: PUSH
64973: LD_VAR 0 3
64977: ARRAY
64978: PUSH
64979: LD_VAR 0 1
64983: DIFF
64984: PPUSH
64985: CALL_OW 1
64989: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64990: LD_ADDR_VAR 0 8
64994: PUSH
64995: LD_VAR 0 3
64999: PPUSH
65000: LD_INT 3
65002: PPUSH
65003: CALL 61611 0 2
65007: ST_TO_ADDR
// if fac then
65008: LD_VAR 0 8
65012: IFFALSE 65241
// begin for j in fac do
65014: LD_ADDR_VAR 0 4
65018: PUSH
65019: LD_VAR 0 8
65023: PUSH
65024: FOR_IN
65025: IFFALSE 65239
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
65027: LD_ADDR_VAR 0 9
65031: PUSH
65032: LD_VAR 0 8
65036: PPUSH
65037: LD_VAR 0 1
65041: PPUSH
65042: CALL_OW 265
65046: PPUSH
65047: LD_VAR 0 1
65051: PPUSH
65052: CALL_OW 262
65056: PPUSH
65057: LD_VAR 0 1
65061: PPUSH
65062: CALL_OW 263
65066: PPUSH
65067: LD_VAR 0 1
65071: PPUSH
65072: CALL_OW 264
65076: PPUSH
65077: CALL 70217 0 5
65081: ST_TO_ADDR
// if components then
65082: LD_VAR 0 9
65086: IFFALSE 65237
// begin if GetWeapon ( un ) = ar_control_tower then
65088: LD_VAR 0 1
65092: PPUSH
65093: CALL_OW 264
65097: PUSH
65098: LD_INT 31
65100: EQUAL
65101: IFFALSE 65218
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
65103: LD_VAR 0 1
65107: PPUSH
65108: CALL_OW 311
65112: PPUSH
65113: LD_INT 0
65115: PPUSH
65116: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
65120: LD_ADDR_EXP 140
65124: PUSH
65125: LD_EXP 140
65129: PPUSH
65130: LD_VAR 0 3
65134: PPUSH
65135: LD_EXP 140
65139: PUSH
65140: LD_VAR 0 3
65144: ARRAY
65145: PUSH
65146: LD_VAR 0 1
65150: PPUSH
65151: CALL_OW 311
65155: DIFF
65156: PPUSH
65157: CALL_OW 1
65161: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
65162: LD_ADDR_VAR 0 7
65166: PUSH
65167: LD_EXP 121
65171: PUSH
65172: LD_VAR 0 3
65176: ARRAY
65177: PPUSH
65178: LD_INT 1
65180: PPUSH
65181: LD_VAR 0 9
65185: PPUSH
65186: CALL_OW 2
65190: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65191: LD_ADDR_EXP 121
65195: PUSH
65196: LD_EXP 121
65200: PPUSH
65201: LD_VAR 0 3
65205: PPUSH
65206: LD_VAR 0 7
65210: PPUSH
65211: CALL_OW 1
65215: ST_TO_ADDR
// end else
65216: GO 65235
// MC_InsertProduceList ( i , [ components ] ) ;
65218: LD_VAR 0 3
65222: PPUSH
65223: LD_VAR 0 9
65227: PUSH
65228: EMPTY
65229: LIST
65230: PPUSH
65231: CALL 61156 0 2
// break ;
65235: GO 65239
// end ; end ;
65237: GO 65024
65239: POP
65240: POP
// end ; end ; if GetType ( un ) = unit_building then
65241: LD_VAR 0 1
65245: PPUSH
65246: CALL_OW 247
65250: PUSH
65251: LD_INT 3
65253: EQUAL
65254: IFFALSE 65657
// begin btype := GetBType ( un ) ;
65256: LD_ADDR_VAR 0 5
65260: PUSH
65261: LD_VAR 0 1
65265: PPUSH
65266: CALL_OW 266
65270: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
65271: LD_VAR 0 5
65275: PUSH
65276: LD_INT 29
65278: PUSH
65279: LD_INT 30
65281: PUSH
65282: EMPTY
65283: LIST
65284: LIST
65285: IN
65286: IFFALSE 65359
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
65288: LD_VAR 0 1
65292: PPUSH
65293: CALL_OW 250
65297: PPUSH
65298: LD_VAR 0 1
65302: PPUSH
65303: CALL_OW 251
65307: PPUSH
65308: LD_VAR 0 1
65312: PPUSH
65313: CALL_OW 255
65317: PPUSH
65318: CALL_OW 440
65322: NOT
65323: IFFALSE 65359
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
65325: LD_VAR 0 1
65329: PPUSH
65330: CALL_OW 250
65334: PPUSH
65335: LD_VAR 0 1
65339: PPUSH
65340: CALL_OW 251
65344: PPUSH
65345: LD_VAR 0 1
65349: PPUSH
65350: CALL_OW 255
65354: PPUSH
65355: CALL_OW 441
// end ; if btype = b_warehouse then
65359: LD_VAR 0 5
65363: PUSH
65364: LD_INT 1
65366: EQUAL
65367: IFFALSE 65385
// begin btype := b_depot ;
65369: LD_ADDR_VAR 0 5
65373: PUSH
65374: LD_INT 0
65376: ST_TO_ADDR
// pos := 1 ;
65377: LD_ADDR_VAR 0 6
65381: PUSH
65382: LD_INT 1
65384: ST_TO_ADDR
// end ; if btype = b_factory then
65385: LD_VAR 0 5
65389: PUSH
65390: LD_INT 3
65392: EQUAL
65393: IFFALSE 65411
// begin btype := b_workshop ;
65395: LD_ADDR_VAR 0 5
65399: PUSH
65400: LD_INT 2
65402: ST_TO_ADDR
// pos := 1 ;
65403: LD_ADDR_VAR 0 6
65407: PUSH
65408: LD_INT 1
65410: ST_TO_ADDR
// end ; if btype = b_barracks then
65411: LD_VAR 0 5
65415: PUSH
65416: LD_INT 5
65418: EQUAL
65419: IFFALSE 65429
// btype := b_armoury ;
65421: LD_ADDR_VAR 0 5
65425: PUSH
65426: LD_INT 4
65428: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65429: LD_VAR 0 5
65433: PUSH
65434: LD_INT 7
65436: PUSH
65437: LD_INT 8
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: IN
65444: IFFALSE 65454
// btype := b_lab ;
65446: LD_ADDR_VAR 0 5
65450: PUSH
65451: LD_INT 6
65453: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65454: LD_ADDR_EXP 105
65458: PUSH
65459: LD_EXP 105
65463: PPUSH
65464: LD_VAR 0 3
65468: PUSH
65469: LD_EXP 105
65473: PUSH
65474: LD_VAR 0 3
65478: ARRAY
65479: PUSH
65480: LD_INT 1
65482: PLUS
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PPUSH
65488: LD_VAR 0 5
65492: PUSH
65493: LD_VAR 0 1
65497: PPUSH
65498: CALL_OW 250
65502: PUSH
65503: LD_VAR 0 1
65507: PPUSH
65508: CALL_OW 251
65512: PUSH
65513: LD_VAR 0 1
65517: PPUSH
65518: CALL_OW 254
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: LIST
65527: LIST
65528: PPUSH
65529: CALL 72719 0 3
65533: ST_TO_ADDR
// if pos = 1 then
65534: LD_VAR 0 6
65538: PUSH
65539: LD_INT 1
65541: EQUAL
65542: IFFALSE 65657
// begin tmp := mc_build_list [ i ] ;
65544: LD_ADDR_VAR 0 7
65548: PUSH
65549: LD_EXP 105
65553: PUSH
65554: LD_VAR 0 3
65558: ARRAY
65559: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65560: LD_VAR 0 7
65564: PPUSH
65565: LD_INT 2
65567: PUSH
65568: LD_INT 30
65570: PUSH
65571: LD_INT 0
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: PUSH
65578: LD_INT 30
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: EMPTY
65585: LIST
65586: LIST
65587: PUSH
65588: EMPTY
65589: LIST
65590: LIST
65591: LIST
65592: PPUSH
65593: CALL_OW 72
65597: IFFALSE 65607
// pos := 2 ;
65599: LD_ADDR_VAR 0 6
65603: PUSH
65604: LD_INT 2
65606: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65607: LD_ADDR_VAR 0 7
65611: PUSH
65612: LD_VAR 0 7
65616: PPUSH
65617: LD_VAR 0 6
65621: PPUSH
65622: LD_VAR 0 7
65626: PPUSH
65627: CALL 73045 0 3
65631: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65632: LD_ADDR_EXP 105
65636: PUSH
65637: LD_EXP 105
65641: PPUSH
65642: LD_VAR 0 3
65646: PPUSH
65647: LD_VAR 0 7
65651: PPUSH
65652: CALL_OW 1
65656: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65657: LD_VAR 0 1
65661: PUSH
65662: LD_EXP 100
65666: PUSH
65667: LD_VAR 0 3
65671: ARRAY
65672: IN
65673: IFFALSE 65712
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65675: LD_ADDR_EXP 100
65679: PUSH
65680: LD_EXP 100
65684: PPUSH
65685: LD_VAR 0 3
65689: PPUSH
65690: LD_EXP 100
65694: PUSH
65695: LD_VAR 0 3
65699: ARRAY
65700: PUSH
65701: LD_VAR 0 1
65705: DIFF
65706: PPUSH
65707: CALL_OW 1
65711: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65712: LD_VAR 0 1
65716: PUSH
65717: LD_EXP 107
65721: PUSH
65722: LD_VAR 0 3
65726: ARRAY
65727: IN
65728: IFFALSE 65767
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65730: LD_ADDR_EXP 107
65734: PUSH
65735: LD_EXP 107
65739: PPUSH
65740: LD_VAR 0 3
65744: PPUSH
65745: LD_EXP 107
65749: PUSH
65750: LD_VAR 0 3
65754: ARRAY
65755: PUSH
65756: LD_VAR 0 1
65760: DIFF
65761: PPUSH
65762: CALL_OW 1
65766: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65767: LD_VAR 0 1
65771: PUSH
65772: LD_EXP 119
65776: PUSH
65777: LD_VAR 0 3
65781: ARRAY
65782: IN
65783: IFFALSE 65822
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65785: LD_ADDR_EXP 119
65789: PUSH
65790: LD_EXP 119
65794: PPUSH
65795: LD_VAR 0 3
65799: PPUSH
65800: LD_EXP 119
65804: PUSH
65805: LD_VAR 0 3
65809: ARRAY
65810: PUSH
65811: LD_VAR 0 1
65815: DIFF
65816: PPUSH
65817: CALL_OW 1
65821: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65822: LD_VAR 0 1
65826: PUSH
65827: LD_EXP 122
65831: PUSH
65832: LD_VAR 0 3
65836: ARRAY
65837: IN
65838: IFFALSE 65877
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65840: LD_ADDR_EXP 122
65844: PUSH
65845: LD_EXP 122
65849: PPUSH
65850: LD_VAR 0 3
65854: PPUSH
65855: LD_EXP 122
65859: PUSH
65860: LD_VAR 0 3
65864: ARRAY
65865: PUSH
65866: LD_VAR 0 1
65870: DIFF
65871: PPUSH
65872: CALL_OW 1
65876: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65877: LD_VAR 0 1
65881: PUSH
65882: LD_EXP 109
65886: PUSH
65887: LD_VAR 0 3
65891: ARRAY
65892: IN
65893: IFFALSE 65932
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65895: LD_ADDR_EXP 109
65899: PUSH
65900: LD_EXP 109
65904: PPUSH
65905: LD_VAR 0 3
65909: PPUSH
65910: LD_EXP 109
65914: PUSH
65915: LD_VAR 0 3
65919: ARRAY
65920: PUSH
65921: LD_VAR 0 1
65925: DIFF
65926: PPUSH
65927: CALL_OW 1
65931: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65932: LD_VAR 0 1
65936: PUSH
65937: LD_EXP 108
65941: PUSH
65942: LD_VAR 0 3
65946: ARRAY
65947: IN
65948: IFFALSE 65987
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65950: LD_ADDR_EXP 108
65954: PUSH
65955: LD_EXP 108
65959: PPUSH
65960: LD_VAR 0 3
65964: PPUSH
65965: LD_EXP 108
65969: PUSH
65970: LD_VAR 0 3
65974: ARRAY
65975: PUSH
65976: LD_VAR 0 1
65980: DIFF
65981: PPUSH
65982: CALL_OW 1
65986: ST_TO_ADDR
// end ; break ;
65987: GO 65991
// end ;
65989: GO 64639
65991: POP
65992: POP
// end ;
65993: LD_VAR 0 2
65997: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65998: LD_INT 0
66000: PPUSH
66001: PPUSH
66002: PPUSH
// if not mc_bases or not skirmish then
66003: LD_EXP 100
66007: NOT
66008: PUSH
66009: LD_EXP 98
66013: NOT
66014: OR
66015: IFFALSE 66019
// exit ;
66017: GO 66234
// for i = 1 to mc_bases do
66019: LD_ADDR_VAR 0 3
66023: PUSH
66024: DOUBLE
66025: LD_INT 1
66027: DEC
66028: ST_TO_ADDR
66029: LD_EXP 100
66033: PUSH
66034: FOR_TO
66035: IFFALSE 66232
// begin if building in mc_construct_list [ i ] then
66037: LD_VAR 0 1
66041: PUSH
66042: LD_EXP 107
66046: PUSH
66047: LD_VAR 0 3
66051: ARRAY
66052: IN
66053: IFFALSE 66230
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66055: LD_ADDR_EXP 107
66059: PUSH
66060: LD_EXP 107
66064: PPUSH
66065: LD_VAR 0 3
66069: PPUSH
66070: LD_EXP 107
66074: PUSH
66075: LD_VAR 0 3
66079: ARRAY
66080: PUSH
66081: LD_VAR 0 1
66085: DIFF
66086: PPUSH
66087: CALL_OW 1
66091: ST_TO_ADDR
// if building in mc_lab [ i ] then
66092: LD_VAR 0 1
66096: PUSH
66097: LD_EXP 133
66101: PUSH
66102: LD_VAR 0 3
66106: ARRAY
66107: IN
66108: IFFALSE 66163
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
66110: LD_ADDR_EXP 134
66114: PUSH
66115: LD_EXP 134
66119: PPUSH
66120: LD_VAR 0 3
66124: PPUSH
66125: LD_EXP 134
66129: PUSH
66130: LD_VAR 0 3
66134: ARRAY
66135: PPUSH
66136: LD_INT 1
66138: PPUSH
66139: LD_EXP 134
66143: PUSH
66144: LD_VAR 0 3
66148: ARRAY
66149: PPUSH
66150: LD_INT 0
66152: PPUSH
66153: CALL 72137 0 4
66157: PPUSH
66158: CALL_OW 1
66162: ST_TO_ADDR
// if not building in mc_bases [ i ] then
66163: LD_VAR 0 1
66167: PUSH
66168: LD_EXP 100
66172: PUSH
66173: LD_VAR 0 3
66177: ARRAY
66178: IN
66179: NOT
66180: IFFALSE 66226
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66182: LD_ADDR_EXP 100
66186: PUSH
66187: LD_EXP 100
66191: PPUSH
66192: LD_VAR 0 3
66196: PUSH
66197: LD_EXP 100
66201: PUSH
66202: LD_VAR 0 3
66206: ARRAY
66207: PUSH
66208: LD_INT 1
66210: PLUS
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PPUSH
66216: LD_VAR 0 1
66220: PPUSH
66221: CALL 72719 0 3
66225: ST_TO_ADDR
// exit ;
66226: POP
66227: POP
66228: GO 66234
// end ; end ;
66230: GO 66034
66232: POP
66233: POP
// end ;
66234: LD_VAR 0 2
66238: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
66239: LD_INT 0
66241: PPUSH
66242: PPUSH
66243: PPUSH
66244: PPUSH
66245: PPUSH
66246: PPUSH
66247: PPUSH
// if not mc_bases or not skirmish then
66248: LD_EXP 100
66252: NOT
66253: PUSH
66254: LD_EXP 98
66258: NOT
66259: OR
66260: IFFALSE 66264
// exit ;
66262: GO 66925
// for i = 1 to mc_bases do
66264: LD_ADDR_VAR 0 3
66268: PUSH
66269: DOUBLE
66270: LD_INT 1
66272: DEC
66273: ST_TO_ADDR
66274: LD_EXP 100
66278: PUSH
66279: FOR_TO
66280: IFFALSE 66923
// begin if building in mc_construct_list [ i ] then
66282: LD_VAR 0 1
66286: PUSH
66287: LD_EXP 107
66291: PUSH
66292: LD_VAR 0 3
66296: ARRAY
66297: IN
66298: IFFALSE 66921
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
66300: LD_ADDR_EXP 107
66304: PUSH
66305: LD_EXP 107
66309: PPUSH
66310: LD_VAR 0 3
66314: PPUSH
66315: LD_EXP 107
66319: PUSH
66320: LD_VAR 0 3
66324: ARRAY
66325: PUSH
66326: LD_VAR 0 1
66330: DIFF
66331: PPUSH
66332: CALL_OW 1
66336: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
66337: LD_ADDR_EXP 100
66341: PUSH
66342: LD_EXP 100
66346: PPUSH
66347: LD_VAR 0 3
66351: PUSH
66352: LD_EXP 100
66356: PUSH
66357: LD_VAR 0 3
66361: ARRAY
66362: PUSH
66363: LD_INT 1
66365: PLUS
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PPUSH
66371: LD_VAR 0 1
66375: PPUSH
66376: CALL 72719 0 3
66380: ST_TO_ADDR
// btype := GetBType ( building ) ;
66381: LD_ADDR_VAR 0 5
66385: PUSH
66386: LD_VAR 0 1
66390: PPUSH
66391: CALL_OW 266
66395: ST_TO_ADDR
// side := GetSide ( building ) ;
66396: LD_ADDR_VAR 0 8
66400: PUSH
66401: LD_VAR 0 1
66405: PPUSH
66406: CALL_OW 255
66410: ST_TO_ADDR
// if btype = b_lab then
66411: LD_VAR 0 5
66415: PUSH
66416: LD_INT 6
66418: EQUAL
66419: IFFALSE 66469
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66421: LD_ADDR_EXP 133
66425: PUSH
66426: LD_EXP 133
66430: PPUSH
66431: LD_VAR 0 3
66435: PUSH
66436: LD_EXP 133
66440: PUSH
66441: LD_VAR 0 3
66445: ARRAY
66446: PUSH
66447: LD_INT 1
66449: PLUS
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PPUSH
66455: LD_VAR 0 1
66459: PPUSH
66460: CALL 72719 0 3
66464: ST_TO_ADDR
// exit ;
66465: POP
66466: POP
66467: GO 66925
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66469: LD_VAR 0 5
66473: PUSH
66474: LD_INT 0
66476: PUSH
66477: LD_INT 2
66479: PUSH
66480: LD_INT 4
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: LIST
66487: IN
66488: IFFALSE 66612
// begin if btype = b_armoury then
66490: LD_VAR 0 5
66494: PUSH
66495: LD_INT 4
66497: EQUAL
66498: IFFALSE 66508
// btype := b_barracks ;
66500: LD_ADDR_VAR 0 5
66504: PUSH
66505: LD_INT 5
66507: ST_TO_ADDR
// if btype = b_depot then
66508: LD_VAR 0 5
66512: PUSH
66513: LD_INT 0
66515: EQUAL
66516: IFFALSE 66526
// btype := b_warehouse ;
66518: LD_ADDR_VAR 0 5
66522: PUSH
66523: LD_INT 1
66525: ST_TO_ADDR
// if btype = b_workshop then
66526: LD_VAR 0 5
66530: PUSH
66531: LD_INT 2
66533: EQUAL
66534: IFFALSE 66544
// btype := b_factory ;
66536: LD_ADDR_VAR 0 5
66540: PUSH
66541: LD_INT 3
66543: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66544: LD_VAR 0 5
66548: PPUSH
66549: LD_VAR 0 8
66553: PPUSH
66554: CALL_OW 323
66558: PUSH
66559: LD_INT 1
66561: EQUAL
66562: IFFALSE 66608
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66564: LD_ADDR_EXP 132
66568: PUSH
66569: LD_EXP 132
66573: PPUSH
66574: LD_VAR 0 3
66578: PUSH
66579: LD_EXP 132
66583: PUSH
66584: LD_VAR 0 3
66588: ARRAY
66589: PUSH
66590: LD_INT 1
66592: PLUS
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PPUSH
66598: LD_VAR 0 1
66602: PPUSH
66603: CALL 72719 0 3
66607: ST_TO_ADDR
// exit ;
66608: POP
66609: POP
66610: GO 66925
// end ; if btype in [ b_bunker , b_turret ] then
66612: LD_VAR 0 5
66616: PUSH
66617: LD_INT 32
66619: PUSH
66620: LD_INT 33
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: IN
66627: IFFALSE 66917
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66629: LD_ADDR_EXP 108
66633: PUSH
66634: LD_EXP 108
66638: PPUSH
66639: LD_VAR 0 3
66643: PUSH
66644: LD_EXP 108
66648: PUSH
66649: LD_VAR 0 3
66653: ARRAY
66654: PUSH
66655: LD_INT 1
66657: PLUS
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PPUSH
66663: LD_VAR 0 1
66667: PPUSH
66668: CALL 72719 0 3
66672: ST_TO_ADDR
// if btype = b_bunker then
66673: LD_VAR 0 5
66677: PUSH
66678: LD_INT 32
66680: EQUAL
66681: IFFALSE 66917
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66683: LD_ADDR_EXP 109
66687: PUSH
66688: LD_EXP 109
66692: PPUSH
66693: LD_VAR 0 3
66697: PUSH
66698: LD_EXP 109
66702: PUSH
66703: LD_VAR 0 3
66707: ARRAY
66708: PUSH
66709: LD_INT 1
66711: PLUS
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PPUSH
66717: LD_VAR 0 1
66721: PPUSH
66722: CALL 72719 0 3
66726: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66727: LD_ADDR_VAR 0 6
66731: PUSH
66732: LD_EXP 100
66736: PUSH
66737: LD_VAR 0 3
66741: ARRAY
66742: PPUSH
66743: LD_INT 25
66745: PUSH
66746: LD_INT 1
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 3
66755: PUSH
66756: LD_INT 54
66758: PUSH
66759: EMPTY
66760: LIST
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PPUSH
66770: CALL_OW 72
66774: ST_TO_ADDR
// if tmp then
66775: LD_VAR 0 6
66779: IFFALSE 66785
// exit ;
66781: POP
66782: POP
66783: GO 66925
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66785: LD_ADDR_VAR 0 6
66789: PUSH
66790: LD_EXP 100
66794: PUSH
66795: LD_VAR 0 3
66799: ARRAY
66800: PPUSH
66801: LD_INT 2
66803: PUSH
66804: LD_INT 30
66806: PUSH
66807: LD_INT 4
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 30
66816: PUSH
66817: LD_INT 5
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: LIST
66828: PPUSH
66829: CALL_OW 72
66833: ST_TO_ADDR
// if not tmp then
66834: LD_VAR 0 6
66838: NOT
66839: IFFALSE 66845
// exit ;
66841: POP
66842: POP
66843: GO 66925
// for j in tmp do
66845: LD_ADDR_VAR 0 4
66849: PUSH
66850: LD_VAR 0 6
66854: PUSH
66855: FOR_IN
66856: IFFALSE 66915
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66858: LD_ADDR_VAR 0 7
66862: PUSH
66863: LD_VAR 0 4
66867: PPUSH
66868: CALL_OW 313
66872: PPUSH
66873: LD_INT 25
66875: PUSH
66876: LD_INT 1
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PPUSH
66883: CALL_OW 72
66887: ST_TO_ADDR
// if units then
66888: LD_VAR 0 7
66892: IFFALSE 66913
// begin ComExitBuilding ( units [ 1 ] ) ;
66894: LD_VAR 0 7
66898: PUSH
66899: LD_INT 1
66901: ARRAY
66902: PPUSH
66903: CALL_OW 122
// exit ;
66907: POP
66908: POP
66909: POP
66910: POP
66911: GO 66925
// end ; end ;
66913: GO 66855
66915: POP
66916: POP
// end ; end ; exit ;
66917: POP
66918: POP
66919: GO 66925
// end ; end ;
66921: GO 66279
66923: POP
66924: POP
// end ;
66925: LD_VAR 0 2
66929: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66930: LD_INT 0
66932: PPUSH
66933: PPUSH
66934: PPUSH
66935: PPUSH
66936: PPUSH
66937: PPUSH
66938: PPUSH
// if not mc_bases or not skirmish then
66939: LD_EXP 100
66943: NOT
66944: PUSH
66945: LD_EXP 98
66949: NOT
66950: OR
66951: IFFALSE 66955
// exit ;
66953: GO 67220
// btype := GetBType ( building ) ;
66955: LD_ADDR_VAR 0 6
66959: PUSH
66960: LD_VAR 0 1
66964: PPUSH
66965: CALL_OW 266
66969: ST_TO_ADDR
// x := GetX ( building ) ;
66970: LD_ADDR_VAR 0 7
66974: PUSH
66975: LD_VAR 0 1
66979: PPUSH
66980: CALL_OW 250
66984: ST_TO_ADDR
// y := GetY ( building ) ;
66985: LD_ADDR_VAR 0 8
66989: PUSH
66990: LD_VAR 0 1
66994: PPUSH
66995: CALL_OW 251
66999: ST_TO_ADDR
// d := GetDir ( building ) ;
67000: LD_ADDR_VAR 0 9
67004: PUSH
67005: LD_VAR 0 1
67009: PPUSH
67010: CALL_OW 254
67014: ST_TO_ADDR
// for i = 1 to mc_bases do
67015: LD_ADDR_VAR 0 4
67019: PUSH
67020: DOUBLE
67021: LD_INT 1
67023: DEC
67024: ST_TO_ADDR
67025: LD_EXP 100
67029: PUSH
67030: FOR_TO
67031: IFFALSE 67218
// begin if not mc_build_list [ i ] then
67033: LD_EXP 105
67037: PUSH
67038: LD_VAR 0 4
67042: ARRAY
67043: NOT
67044: IFFALSE 67048
// continue ;
67046: GO 67030
// for j := 1 to mc_build_list [ i ] do
67048: LD_ADDR_VAR 0 5
67052: PUSH
67053: DOUBLE
67054: LD_INT 1
67056: DEC
67057: ST_TO_ADDR
67058: LD_EXP 105
67062: PUSH
67063: LD_VAR 0 4
67067: ARRAY
67068: PUSH
67069: FOR_TO
67070: IFFALSE 67214
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
67072: LD_VAR 0 6
67076: PUSH
67077: LD_VAR 0 7
67081: PUSH
67082: LD_VAR 0 8
67086: PUSH
67087: LD_VAR 0 9
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: PPUSH
67098: LD_EXP 105
67102: PUSH
67103: LD_VAR 0 4
67107: ARRAY
67108: PUSH
67109: LD_VAR 0 5
67113: ARRAY
67114: PPUSH
67115: CALL 78899 0 2
67119: IFFALSE 67212
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
67121: LD_ADDR_EXP 105
67125: PUSH
67126: LD_EXP 105
67130: PPUSH
67131: LD_VAR 0 4
67135: PPUSH
67136: LD_EXP 105
67140: PUSH
67141: LD_VAR 0 4
67145: ARRAY
67146: PPUSH
67147: LD_VAR 0 5
67151: PPUSH
67152: CALL_OW 3
67156: PPUSH
67157: CALL_OW 1
67161: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
67162: LD_ADDR_EXP 107
67166: PUSH
67167: LD_EXP 107
67171: PPUSH
67172: LD_VAR 0 4
67176: PUSH
67177: LD_EXP 107
67181: PUSH
67182: LD_VAR 0 4
67186: ARRAY
67187: PUSH
67188: LD_INT 1
67190: PLUS
67191: PUSH
67192: EMPTY
67193: LIST
67194: LIST
67195: PPUSH
67196: LD_VAR 0 1
67200: PPUSH
67201: CALL 72719 0 3
67205: ST_TO_ADDR
// exit ;
67206: POP
67207: POP
67208: POP
67209: POP
67210: GO 67220
// end ;
67212: GO 67069
67214: POP
67215: POP
// end ;
67216: GO 67030
67218: POP
67219: POP
// end ;
67220: LD_VAR 0 3
67224: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
67225: LD_INT 0
67227: PPUSH
67228: PPUSH
67229: PPUSH
// if not mc_bases or not skirmish then
67230: LD_EXP 100
67234: NOT
67235: PUSH
67236: LD_EXP 98
67240: NOT
67241: OR
67242: IFFALSE 67246
// exit ;
67244: GO 67436
// for i = 1 to mc_bases do
67246: LD_ADDR_VAR 0 4
67250: PUSH
67251: DOUBLE
67252: LD_INT 1
67254: DEC
67255: ST_TO_ADDR
67256: LD_EXP 100
67260: PUSH
67261: FOR_TO
67262: IFFALSE 67349
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
67264: LD_VAR 0 1
67268: PUSH
67269: LD_EXP 108
67273: PUSH
67274: LD_VAR 0 4
67278: ARRAY
67279: IN
67280: PUSH
67281: LD_VAR 0 1
67285: PUSH
67286: LD_EXP 109
67290: PUSH
67291: LD_VAR 0 4
67295: ARRAY
67296: IN
67297: NOT
67298: AND
67299: IFFALSE 67347
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67301: LD_ADDR_EXP 109
67305: PUSH
67306: LD_EXP 109
67310: PPUSH
67311: LD_VAR 0 4
67315: PUSH
67316: LD_EXP 109
67320: PUSH
67321: LD_VAR 0 4
67325: ARRAY
67326: PUSH
67327: LD_INT 1
67329: PLUS
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: PPUSH
67335: LD_VAR 0 1
67339: PPUSH
67340: CALL 72719 0 3
67344: ST_TO_ADDR
// break ;
67345: GO 67349
// end ; end ;
67347: GO 67261
67349: POP
67350: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
67351: LD_VAR 0 1
67355: PPUSH
67356: CALL_OW 257
67360: PUSH
67361: LD_EXP 126
67365: IN
67366: PUSH
67367: LD_VAR 0 1
67371: PPUSH
67372: CALL_OW 266
67376: PUSH
67377: LD_INT 5
67379: EQUAL
67380: AND
67381: PUSH
67382: LD_VAR 0 2
67386: PPUSH
67387: CALL_OW 110
67391: PUSH
67392: LD_INT 18
67394: NONEQUAL
67395: AND
67396: IFFALSE 67436
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67398: LD_VAR 0 2
67402: PPUSH
67403: CALL_OW 257
67407: PUSH
67408: LD_INT 5
67410: PUSH
67411: LD_INT 8
67413: PUSH
67414: LD_INT 9
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: LIST
67421: IN
67422: IFFALSE 67436
// SetClass ( unit , 1 ) ;
67424: LD_VAR 0 2
67428: PPUSH
67429: LD_INT 1
67431: PPUSH
67432: CALL_OW 336
// end ;
67436: LD_VAR 0 3
67440: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67441: LD_INT 0
67443: PPUSH
67444: PPUSH
// if not mc_bases or not skirmish then
67445: LD_EXP 100
67449: NOT
67450: PUSH
67451: LD_EXP 98
67455: NOT
67456: OR
67457: IFFALSE 67461
// exit ;
67459: GO 67577
// if GetLives ( abandoned_vehicle ) > 250 then
67461: LD_VAR 0 2
67465: PPUSH
67466: CALL_OW 256
67470: PUSH
67471: LD_INT 250
67473: GREATER
67474: IFFALSE 67478
// exit ;
67476: GO 67577
// for i = 1 to mc_bases do
67478: LD_ADDR_VAR 0 6
67482: PUSH
67483: DOUBLE
67484: LD_INT 1
67486: DEC
67487: ST_TO_ADDR
67488: LD_EXP 100
67492: PUSH
67493: FOR_TO
67494: IFFALSE 67575
// begin if driver in mc_bases [ i ] then
67496: LD_VAR 0 1
67500: PUSH
67501: LD_EXP 100
67505: PUSH
67506: LD_VAR 0 6
67510: ARRAY
67511: IN
67512: IFFALSE 67573
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67514: LD_VAR 0 1
67518: PPUSH
67519: LD_EXP 100
67523: PUSH
67524: LD_VAR 0 6
67528: ARRAY
67529: PPUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 30
67535: PUSH
67536: LD_INT 0
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: LD_INT 30
67545: PUSH
67546: LD_INT 1
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: LIST
67557: PPUSH
67558: CALL_OW 72
67562: PUSH
67563: LD_INT 1
67565: ARRAY
67566: PPUSH
67567: CALL 105927 0 2
// break ;
67571: GO 67575
// end ; end ;
67573: GO 67493
67575: POP
67576: POP
// end ; end_of_file
67577: LD_VAR 0 5
67581: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67582: LD_INT 0
67584: PPUSH
67585: PPUSH
// if exist_mode then
67586: LD_VAR 0 2
67590: IFFALSE 67615
// unit := CreateCharacter ( prefix & ident ) else
67592: LD_ADDR_VAR 0 5
67596: PUSH
67597: LD_VAR 0 3
67601: PUSH
67602: LD_VAR 0 1
67606: STR
67607: PPUSH
67608: CALL_OW 34
67612: ST_TO_ADDR
67613: GO 67630
// unit := NewCharacter ( ident ) ;
67615: LD_ADDR_VAR 0 5
67619: PUSH
67620: LD_VAR 0 1
67624: PPUSH
67625: CALL_OW 25
67629: ST_TO_ADDR
// result := unit ;
67630: LD_ADDR_VAR 0 4
67634: PUSH
67635: LD_VAR 0 5
67639: ST_TO_ADDR
// end ;
67640: LD_VAR 0 4
67644: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67645: LD_INT 0
67647: PPUSH
67648: PPUSH
// if not side or not nation then
67649: LD_VAR 0 1
67653: NOT
67654: PUSH
67655: LD_VAR 0 2
67659: NOT
67660: OR
67661: IFFALSE 67665
// exit ;
67663: GO 68433
// case nation of nation_american :
67665: LD_VAR 0 2
67669: PUSH
67670: LD_INT 1
67672: DOUBLE
67673: EQUAL
67674: IFTRUE 67678
67676: GO 67892
67678: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67679: LD_ADDR_VAR 0 4
67683: PUSH
67684: LD_INT 35
67686: PUSH
67687: LD_INT 45
67689: PUSH
67690: LD_INT 46
67692: PUSH
67693: LD_INT 47
67695: PUSH
67696: LD_INT 82
67698: PUSH
67699: LD_INT 83
67701: PUSH
67702: LD_INT 84
67704: PUSH
67705: LD_INT 85
67707: PUSH
67708: LD_INT 86
67710: PUSH
67711: LD_INT 1
67713: PUSH
67714: LD_INT 2
67716: PUSH
67717: LD_INT 6
67719: PUSH
67720: LD_INT 15
67722: PUSH
67723: LD_INT 16
67725: PUSH
67726: LD_INT 7
67728: PUSH
67729: LD_INT 12
67731: PUSH
67732: LD_INT 13
67734: PUSH
67735: LD_INT 10
67737: PUSH
67738: LD_INT 14
67740: PUSH
67741: LD_INT 20
67743: PUSH
67744: LD_INT 21
67746: PUSH
67747: LD_INT 22
67749: PUSH
67750: LD_INT 25
67752: PUSH
67753: LD_INT 32
67755: PUSH
67756: LD_INT 27
67758: PUSH
67759: LD_INT 36
67761: PUSH
67762: LD_INT 69
67764: PUSH
67765: LD_INT 39
67767: PUSH
67768: LD_INT 34
67770: PUSH
67771: LD_INT 40
67773: PUSH
67774: LD_INT 48
67776: PUSH
67777: LD_INT 49
67779: PUSH
67780: LD_INT 50
67782: PUSH
67783: LD_INT 51
67785: PUSH
67786: LD_INT 52
67788: PUSH
67789: LD_INT 53
67791: PUSH
67792: LD_INT 54
67794: PUSH
67795: LD_INT 55
67797: PUSH
67798: LD_INT 56
67800: PUSH
67801: LD_INT 57
67803: PUSH
67804: LD_INT 58
67806: PUSH
67807: LD_INT 59
67809: PUSH
67810: LD_INT 60
67812: PUSH
67813: LD_INT 61
67815: PUSH
67816: LD_INT 62
67818: PUSH
67819: LD_INT 80
67821: PUSH
67822: LD_INT 82
67824: PUSH
67825: LD_INT 83
67827: PUSH
67828: LD_INT 84
67830: PUSH
67831: LD_INT 85
67833: PUSH
67834: LD_INT 86
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: LIST
67880: LIST
67881: LIST
67882: LIST
67883: LIST
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: ST_TO_ADDR
67890: GO 68357
67892: LD_INT 2
67894: DOUBLE
67895: EQUAL
67896: IFTRUE 67900
67898: GO 68126
67900: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67901: LD_ADDR_VAR 0 4
67905: PUSH
67906: LD_INT 35
67908: PUSH
67909: LD_INT 45
67911: PUSH
67912: LD_INT 46
67914: PUSH
67915: LD_INT 47
67917: PUSH
67918: LD_INT 82
67920: PUSH
67921: LD_INT 83
67923: PUSH
67924: LD_INT 84
67926: PUSH
67927: LD_INT 85
67929: PUSH
67930: LD_INT 87
67932: PUSH
67933: LD_INT 70
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: LD_INT 11
67941: PUSH
67942: LD_INT 3
67944: PUSH
67945: LD_INT 4
67947: PUSH
67948: LD_INT 5
67950: PUSH
67951: LD_INT 6
67953: PUSH
67954: LD_INT 15
67956: PUSH
67957: LD_INT 18
67959: PUSH
67960: LD_INT 7
67962: PUSH
67963: LD_INT 17
67965: PUSH
67966: LD_INT 8
67968: PUSH
67969: LD_INT 20
67971: PUSH
67972: LD_INT 21
67974: PUSH
67975: LD_INT 22
67977: PUSH
67978: LD_INT 72
67980: PUSH
67981: LD_INT 26
67983: PUSH
67984: LD_INT 69
67986: PUSH
67987: LD_INT 39
67989: PUSH
67990: LD_INT 40
67992: PUSH
67993: LD_INT 41
67995: PUSH
67996: LD_INT 42
67998: PUSH
67999: LD_INT 43
68001: PUSH
68002: LD_INT 48
68004: PUSH
68005: LD_INT 49
68007: PUSH
68008: LD_INT 50
68010: PUSH
68011: LD_INT 51
68013: PUSH
68014: LD_INT 52
68016: PUSH
68017: LD_INT 53
68019: PUSH
68020: LD_INT 54
68022: PUSH
68023: LD_INT 55
68025: PUSH
68026: LD_INT 56
68028: PUSH
68029: LD_INT 60
68031: PUSH
68032: LD_INT 61
68034: PUSH
68035: LD_INT 62
68037: PUSH
68038: LD_INT 66
68040: PUSH
68041: LD_INT 67
68043: PUSH
68044: LD_INT 68
68046: PUSH
68047: LD_INT 81
68049: PUSH
68050: LD_INT 82
68052: PUSH
68053: LD_INT 83
68055: PUSH
68056: LD_INT 84
68058: PUSH
68059: LD_INT 85
68061: PUSH
68062: LD_INT 87
68064: PUSH
68065: LD_INT 88
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: LIST
68090: LIST
68091: LIST
68092: LIST
68093: LIST
68094: LIST
68095: LIST
68096: LIST
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: LIST
68103: LIST
68104: LIST
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: ST_TO_ADDR
68124: GO 68357
68126: LD_INT 3
68128: DOUBLE
68129: EQUAL
68130: IFTRUE 68134
68132: GO 68356
68134: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
68135: LD_ADDR_VAR 0 4
68139: PUSH
68140: LD_INT 46
68142: PUSH
68143: LD_INT 47
68145: PUSH
68146: LD_INT 1
68148: PUSH
68149: LD_INT 2
68151: PUSH
68152: LD_INT 82
68154: PUSH
68155: LD_INT 83
68157: PUSH
68158: LD_INT 84
68160: PUSH
68161: LD_INT 85
68163: PUSH
68164: LD_INT 86
68166: PUSH
68167: LD_INT 11
68169: PUSH
68170: LD_INT 9
68172: PUSH
68173: LD_INT 20
68175: PUSH
68176: LD_INT 19
68178: PUSH
68179: LD_INT 21
68181: PUSH
68182: LD_INT 24
68184: PUSH
68185: LD_INT 22
68187: PUSH
68188: LD_INT 25
68190: PUSH
68191: LD_INT 28
68193: PUSH
68194: LD_INT 29
68196: PUSH
68197: LD_INT 30
68199: PUSH
68200: LD_INT 31
68202: PUSH
68203: LD_INT 37
68205: PUSH
68206: LD_INT 38
68208: PUSH
68209: LD_INT 32
68211: PUSH
68212: LD_INT 27
68214: PUSH
68215: LD_INT 33
68217: PUSH
68218: LD_INT 69
68220: PUSH
68221: LD_INT 39
68223: PUSH
68224: LD_INT 34
68226: PUSH
68227: LD_INT 40
68229: PUSH
68230: LD_INT 71
68232: PUSH
68233: LD_INT 23
68235: PUSH
68236: LD_INT 44
68238: PUSH
68239: LD_INT 48
68241: PUSH
68242: LD_INT 49
68244: PUSH
68245: LD_INT 50
68247: PUSH
68248: LD_INT 51
68250: PUSH
68251: LD_INT 52
68253: PUSH
68254: LD_INT 53
68256: PUSH
68257: LD_INT 54
68259: PUSH
68260: LD_INT 55
68262: PUSH
68263: LD_INT 56
68265: PUSH
68266: LD_INT 57
68268: PUSH
68269: LD_INT 58
68271: PUSH
68272: LD_INT 59
68274: PUSH
68275: LD_INT 63
68277: PUSH
68278: LD_INT 64
68280: PUSH
68281: LD_INT 65
68283: PUSH
68284: LD_INT 82
68286: PUSH
68287: LD_INT 83
68289: PUSH
68290: LD_INT 84
68292: PUSH
68293: LD_INT 85
68295: PUSH
68296: LD_INT 86
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: LIST
68336: LIST
68337: LIST
68338: LIST
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: ST_TO_ADDR
68354: GO 68357
68356: POP
// if state > - 1 and state < 3 then
68357: LD_VAR 0 3
68361: PUSH
68362: LD_INT 1
68364: NEG
68365: GREATER
68366: PUSH
68367: LD_VAR 0 3
68371: PUSH
68372: LD_INT 3
68374: LESS
68375: AND
68376: IFFALSE 68433
// for i in result do
68378: LD_ADDR_VAR 0 5
68382: PUSH
68383: LD_VAR 0 4
68387: PUSH
68388: FOR_IN
68389: IFFALSE 68431
// if GetTech ( i , side ) <> state then
68391: LD_VAR 0 5
68395: PPUSH
68396: LD_VAR 0 1
68400: PPUSH
68401: CALL_OW 321
68405: PUSH
68406: LD_VAR 0 3
68410: NONEQUAL
68411: IFFALSE 68429
// result := result diff i ;
68413: LD_ADDR_VAR 0 4
68417: PUSH
68418: LD_VAR 0 4
68422: PUSH
68423: LD_VAR 0 5
68427: DIFF
68428: ST_TO_ADDR
68429: GO 68388
68431: POP
68432: POP
// end ;
68433: LD_VAR 0 4
68437: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68438: LD_INT 0
68440: PPUSH
68441: PPUSH
68442: PPUSH
// result := true ;
68443: LD_ADDR_VAR 0 3
68447: PUSH
68448: LD_INT 1
68450: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68451: LD_ADDR_VAR 0 5
68455: PUSH
68456: LD_VAR 0 2
68460: PPUSH
68461: CALL_OW 480
68465: ST_TO_ADDR
// if not tmp then
68466: LD_VAR 0 5
68470: NOT
68471: IFFALSE 68475
// exit ;
68473: GO 68524
// for i in tmp do
68475: LD_ADDR_VAR 0 4
68479: PUSH
68480: LD_VAR 0 5
68484: PUSH
68485: FOR_IN
68486: IFFALSE 68522
// if GetTech ( i , side ) <> state_researched then
68488: LD_VAR 0 4
68492: PPUSH
68493: LD_VAR 0 1
68497: PPUSH
68498: CALL_OW 321
68502: PUSH
68503: LD_INT 2
68505: NONEQUAL
68506: IFFALSE 68520
// begin result := false ;
68508: LD_ADDR_VAR 0 3
68512: PUSH
68513: LD_INT 0
68515: ST_TO_ADDR
// exit ;
68516: POP
68517: POP
68518: GO 68524
// end ;
68520: GO 68485
68522: POP
68523: POP
// end ;
68524: LD_VAR 0 3
68528: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68529: LD_INT 0
68531: PPUSH
68532: PPUSH
68533: PPUSH
68534: PPUSH
68535: PPUSH
68536: PPUSH
68537: PPUSH
68538: PPUSH
68539: PPUSH
68540: PPUSH
68541: PPUSH
68542: PPUSH
68543: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68544: LD_VAR 0 1
68548: NOT
68549: PUSH
68550: LD_VAR 0 1
68554: PPUSH
68555: CALL_OW 257
68559: PUSH
68560: LD_INT 9
68562: NONEQUAL
68563: OR
68564: IFFALSE 68568
// exit ;
68566: GO 69141
// side := GetSide ( unit ) ;
68568: LD_ADDR_VAR 0 9
68572: PUSH
68573: LD_VAR 0 1
68577: PPUSH
68578: CALL_OW 255
68582: ST_TO_ADDR
// tech_space := tech_spacanom ;
68583: LD_ADDR_VAR 0 12
68587: PUSH
68588: LD_INT 29
68590: ST_TO_ADDR
// tech_time := tech_taurad ;
68591: LD_ADDR_VAR 0 13
68595: PUSH
68596: LD_INT 28
68598: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68599: LD_ADDR_VAR 0 11
68603: PUSH
68604: LD_VAR 0 1
68608: PPUSH
68609: CALL_OW 310
68613: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68614: LD_VAR 0 11
68618: PPUSH
68619: CALL_OW 247
68623: PUSH
68624: LD_INT 2
68626: EQUAL
68627: IFFALSE 68631
// exit ;
68629: GO 69141
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68631: LD_ADDR_VAR 0 8
68635: PUSH
68636: LD_INT 81
68638: PUSH
68639: LD_VAR 0 9
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 3
68650: PUSH
68651: LD_INT 21
68653: PUSH
68654: LD_INT 3
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PPUSH
68669: CALL_OW 69
68673: ST_TO_ADDR
// if not tmp then
68674: LD_VAR 0 8
68678: NOT
68679: IFFALSE 68683
// exit ;
68681: GO 69141
// if in_unit then
68683: LD_VAR 0 11
68687: IFFALSE 68711
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68689: LD_ADDR_VAR 0 10
68693: PUSH
68694: LD_VAR 0 8
68698: PPUSH
68699: LD_VAR 0 11
68703: PPUSH
68704: CALL_OW 74
68708: ST_TO_ADDR
68709: GO 68731
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68711: LD_ADDR_VAR 0 10
68715: PUSH
68716: LD_VAR 0 8
68720: PPUSH
68721: LD_VAR 0 1
68725: PPUSH
68726: CALL_OW 74
68730: ST_TO_ADDR
// if not enemy then
68731: LD_VAR 0 10
68735: NOT
68736: IFFALSE 68740
// exit ;
68738: GO 69141
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68740: LD_VAR 0 11
68744: PUSH
68745: LD_VAR 0 11
68749: PPUSH
68750: LD_VAR 0 10
68754: PPUSH
68755: CALL_OW 296
68759: PUSH
68760: LD_INT 13
68762: GREATER
68763: AND
68764: PUSH
68765: LD_VAR 0 1
68769: PPUSH
68770: LD_VAR 0 10
68774: PPUSH
68775: CALL_OW 296
68779: PUSH
68780: LD_INT 12
68782: GREATER
68783: OR
68784: IFFALSE 68788
// exit ;
68786: GO 69141
// missile := [ 1 ] ;
68788: LD_ADDR_VAR 0 14
68792: PUSH
68793: LD_INT 1
68795: PUSH
68796: EMPTY
68797: LIST
68798: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68799: LD_VAR 0 9
68803: PPUSH
68804: LD_VAR 0 12
68808: PPUSH
68809: CALL_OW 325
68813: IFFALSE 68842
// missile := Replace ( missile , missile + 1 , 2 ) ;
68815: LD_ADDR_VAR 0 14
68819: PUSH
68820: LD_VAR 0 14
68824: PPUSH
68825: LD_VAR 0 14
68829: PUSH
68830: LD_INT 1
68832: PLUS
68833: PPUSH
68834: LD_INT 2
68836: PPUSH
68837: CALL_OW 1
68841: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68842: LD_VAR 0 9
68846: PPUSH
68847: LD_VAR 0 13
68851: PPUSH
68852: CALL_OW 325
68856: PUSH
68857: LD_VAR 0 10
68861: PPUSH
68862: CALL_OW 255
68866: PPUSH
68867: LD_VAR 0 13
68871: PPUSH
68872: CALL_OW 325
68876: NOT
68877: AND
68878: IFFALSE 68907
// missile := Replace ( missile , missile + 1 , 3 ) ;
68880: LD_ADDR_VAR 0 14
68884: PUSH
68885: LD_VAR 0 14
68889: PPUSH
68890: LD_VAR 0 14
68894: PUSH
68895: LD_INT 1
68897: PLUS
68898: PPUSH
68899: LD_INT 3
68901: PPUSH
68902: CALL_OW 1
68906: ST_TO_ADDR
// if missile < 2 then
68907: LD_VAR 0 14
68911: PUSH
68912: LD_INT 2
68914: LESS
68915: IFFALSE 68919
// exit ;
68917: GO 69141
// x := GetX ( enemy ) ;
68919: LD_ADDR_VAR 0 4
68923: PUSH
68924: LD_VAR 0 10
68928: PPUSH
68929: CALL_OW 250
68933: ST_TO_ADDR
// y := GetY ( enemy ) ;
68934: LD_ADDR_VAR 0 5
68938: PUSH
68939: LD_VAR 0 10
68943: PPUSH
68944: CALL_OW 251
68948: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68949: LD_ADDR_VAR 0 6
68953: PUSH
68954: LD_VAR 0 4
68958: PUSH
68959: LD_INT 1
68961: NEG
68962: PPUSH
68963: LD_INT 1
68965: PPUSH
68966: CALL_OW 12
68970: PLUS
68971: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68972: LD_ADDR_VAR 0 7
68976: PUSH
68977: LD_VAR 0 5
68981: PUSH
68982: LD_INT 1
68984: NEG
68985: PPUSH
68986: LD_INT 1
68988: PPUSH
68989: CALL_OW 12
68993: PLUS
68994: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68995: LD_VAR 0 6
68999: PPUSH
69000: LD_VAR 0 7
69004: PPUSH
69005: CALL_OW 488
69009: NOT
69010: IFFALSE 69032
// begin _x := x ;
69012: LD_ADDR_VAR 0 6
69016: PUSH
69017: LD_VAR 0 4
69021: ST_TO_ADDR
// _y := y ;
69022: LD_ADDR_VAR 0 7
69026: PUSH
69027: LD_VAR 0 5
69031: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
69032: LD_ADDR_VAR 0 3
69036: PUSH
69037: LD_INT 1
69039: PPUSH
69040: LD_VAR 0 14
69044: PPUSH
69045: CALL_OW 12
69049: ST_TO_ADDR
// case i of 1 :
69050: LD_VAR 0 3
69054: PUSH
69055: LD_INT 1
69057: DOUBLE
69058: EQUAL
69059: IFTRUE 69063
69061: GO 69080
69063: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
69064: LD_VAR 0 1
69068: PPUSH
69069: LD_VAR 0 10
69073: PPUSH
69074: CALL_OW 115
69078: GO 69141
69080: LD_INT 2
69082: DOUBLE
69083: EQUAL
69084: IFTRUE 69088
69086: GO 69110
69088: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
69089: LD_VAR 0 1
69093: PPUSH
69094: LD_VAR 0 6
69098: PPUSH
69099: LD_VAR 0 7
69103: PPUSH
69104: CALL_OW 153
69108: GO 69141
69110: LD_INT 3
69112: DOUBLE
69113: EQUAL
69114: IFTRUE 69118
69116: GO 69140
69118: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
69119: LD_VAR 0 1
69123: PPUSH
69124: LD_VAR 0 6
69128: PPUSH
69129: LD_VAR 0 7
69133: PPUSH
69134: CALL_OW 154
69138: GO 69141
69140: POP
// end ;
69141: LD_VAR 0 2
69145: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
69146: LD_INT 0
69148: PPUSH
69149: PPUSH
69150: PPUSH
69151: PPUSH
69152: PPUSH
69153: PPUSH
// if not unit or not building then
69154: LD_VAR 0 1
69158: NOT
69159: PUSH
69160: LD_VAR 0 2
69164: NOT
69165: OR
69166: IFFALSE 69170
// exit ;
69168: GO 69328
// x := GetX ( building ) ;
69170: LD_ADDR_VAR 0 5
69174: PUSH
69175: LD_VAR 0 2
69179: PPUSH
69180: CALL_OW 250
69184: ST_TO_ADDR
// y := GetY ( building ) ;
69185: LD_ADDR_VAR 0 6
69189: PUSH
69190: LD_VAR 0 2
69194: PPUSH
69195: CALL_OW 251
69199: ST_TO_ADDR
// for i = 0 to 5 do
69200: LD_ADDR_VAR 0 4
69204: PUSH
69205: DOUBLE
69206: LD_INT 0
69208: DEC
69209: ST_TO_ADDR
69210: LD_INT 5
69212: PUSH
69213: FOR_TO
69214: IFFALSE 69326
// begin _x := ShiftX ( x , i , 3 ) ;
69216: LD_ADDR_VAR 0 7
69220: PUSH
69221: LD_VAR 0 5
69225: PPUSH
69226: LD_VAR 0 4
69230: PPUSH
69231: LD_INT 3
69233: PPUSH
69234: CALL_OW 272
69238: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
69239: LD_ADDR_VAR 0 8
69243: PUSH
69244: LD_VAR 0 6
69248: PPUSH
69249: LD_VAR 0 4
69253: PPUSH
69254: LD_INT 3
69256: PPUSH
69257: CALL_OW 273
69261: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69262: LD_VAR 0 7
69266: PPUSH
69267: LD_VAR 0 8
69271: PPUSH
69272: CALL_OW 488
69276: NOT
69277: IFFALSE 69281
// continue ;
69279: GO 69213
// if HexInfo ( _x , _y ) = 0 then
69281: LD_VAR 0 7
69285: PPUSH
69286: LD_VAR 0 8
69290: PPUSH
69291: CALL_OW 428
69295: PUSH
69296: LD_INT 0
69298: EQUAL
69299: IFFALSE 69324
// begin ComMoveXY ( unit , _x , _y ) ;
69301: LD_VAR 0 1
69305: PPUSH
69306: LD_VAR 0 7
69310: PPUSH
69311: LD_VAR 0 8
69315: PPUSH
69316: CALL_OW 111
// exit ;
69320: POP
69321: POP
69322: GO 69328
// end ; end ;
69324: GO 69213
69326: POP
69327: POP
// end ;
69328: LD_VAR 0 3
69332: RET
// export function ScanBase ( side , base_area ) ; begin
69333: LD_INT 0
69335: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
69336: LD_ADDR_VAR 0 3
69340: PUSH
69341: LD_VAR 0 2
69345: PPUSH
69346: LD_INT 81
69348: PUSH
69349: LD_VAR 0 1
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PPUSH
69358: CALL_OW 70
69362: ST_TO_ADDR
// end ;
69363: LD_VAR 0 3
69367: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69368: LD_INT 0
69370: PPUSH
69371: PPUSH
69372: PPUSH
69373: PPUSH
// result := false ;
69374: LD_ADDR_VAR 0 2
69378: PUSH
69379: LD_INT 0
69381: ST_TO_ADDR
// side := GetSide ( unit ) ;
69382: LD_ADDR_VAR 0 3
69386: PUSH
69387: LD_VAR 0 1
69391: PPUSH
69392: CALL_OW 255
69396: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69397: LD_ADDR_VAR 0 4
69401: PUSH
69402: LD_VAR 0 1
69406: PPUSH
69407: CALL_OW 248
69411: ST_TO_ADDR
// case nat of 1 :
69412: LD_VAR 0 4
69416: PUSH
69417: LD_INT 1
69419: DOUBLE
69420: EQUAL
69421: IFTRUE 69425
69423: GO 69436
69425: POP
// tech := tech_lassight ; 2 :
69426: LD_ADDR_VAR 0 5
69430: PUSH
69431: LD_INT 12
69433: ST_TO_ADDR
69434: GO 69475
69436: LD_INT 2
69438: DOUBLE
69439: EQUAL
69440: IFTRUE 69444
69442: GO 69455
69444: POP
// tech := tech_mortar ; 3 :
69445: LD_ADDR_VAR 0 5
69449: PUSH
69450: LD_INT 41
69452: ST_TO_ADDR
69453: GO 69475
69455: LD_INT 3
69457: DOUBLE
69458: EQUAL
69459: IFTRUE 69463
69461: GO 69474
69463: POP
// tech := tech_bazooka ; end ;
69464: LD_ADDR_VAR 0 5
69468: PUSH
69469: LD_INT 44
69471: ST_TO_ADDR
69472: GO 69475
69474: POP
// if Researched ( side , tech ) then
69475: LD_VAR 0 3
69479: PPUSH
69480: LD_VAR 0 5
69484: PPUSH
69485: CALL_OW 325
69489: IFFALSE 69516
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69491: LD_ADDR_VAR 0 2
69495: PUSH
69496: LD_INT 5
69498: PUSH
69499: LD_INT 8
69501: PUSH
69502: LD_INT 9
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: LIST
69509: PUSH
69510: LD_VAR 0 4
69514: ARRAY
69515: ST_TO_ADDR
// end ;
69516: LD_VAR 0 2
69520: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69521: LD_INT 0
69523: PPUSH
69524: PPUSH
69525: PPUSH
// if not mines then
69526: LD_VAR 0 2
69530: NOT
69531: IFFALSE 69535
// exit ;
69533: GO 69679
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69535: LD_ADDR_VAR 0 5
69539: PUSH
69540: LD_INT 81
69542: PUSH
69543: LD_VAR 0 1
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 3
69554: PUSH
69555: LD_INT 21
69557: PUSH
69558: LD_INT 3
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: PPUSH
69573: CALL_OW 69
69577: ST_TO_ADDR
// for i in mines do
69578: LD_ADDR_VAR 0 4
69582: PUSH
69583: LD_VAR 0 2
69587: PUSH
69588: FOR_IN
69589: IFFALSE 69677
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69591: LD_VAR 0 4
69595: PUSH
69596: LD_INT 1
69598: ARRAY
69599: PPUSH
69600: LD_VAR 0 4
69604: PUSH
69605: LD_INT 2
69607: ARRAY
69608: PPUSH
69609: CALL_OW 458
69613: NOT
69614: IFFALSE 69618
// continue ;
69616: GO 69588
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69618: LD_VAR 0 4
69622: PUSH
69623: LD_INT 1
69625: ARRAY
69626: PPUSH
69627: LD_VAR 0 4
69631: PUSH
69632: LD_INT 2
69634: ARRAY
69635: PPUSH
69636: CALL_OW 428
69640: PUSH
69641: LD_VAR 0 5
69645: IN
69646: IFFALSE 69675
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69648: LD_VAR 0 4
69652: PUSH
69653: LD_INT 1
69655: ARRAY
69656: PPUSH
69657: LD_VAR 0 4
69661: PUSH
69662: LD_INT 2
69664: ARRAY
69665: PPUSH
69666: LD_VAR 0 1
69670: PPUSH
69671: CALL_OW 456
// end ;
69675: GO 69588
69677: POP
69678: POP
// end ;
69679: LD_VAR 0 3
69683: RET
// export function Count ( array ) ; var i ; begin
69684: LD_INT 0
69686: PPUSH
69687: PPUSH
// result := 0 ;
69688: LD_ADDR_VAR 0 2
69692: PUSH
69693: LD_INT 0
69695: ST_TO_ADDR
// for i in array do
69696: LD_ADDR_VAR 0 3
69700: PUSH
69701: LD_VAR 0 1
69705: PUSH
69706: FOR_IN
69707: IFFALSE 69731
// if i then
69709: LD_VAR 0 3
69713: IFFALSE 69729
// result := result + 1 ;
69715: LD_ADDR_VAR 0 2
69719: PUSH
69720: LD_VAR 0 2
69724: PUSH
69725: LD_INT 1
69727: PLUS
69728: ST_TO_ADDR
69729: GO 69706
69731: POP
69732: POP
// end ;
69733: LD_VAR 0 2
69737: RET
// export function IsEmpty ( building ) ; begin
69738: LD_INT 0
69740: PPUSH
// if not building then
69741: LD_VAR 0 1
69745: NOT
69746: IFFALSE 69750
// exit ;
69748: GO 69793
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69750: LD_ADDR_VAR 0 2
69754: PUSH
69755: LD_VAR 0 1
69759: PUSH
69760: LD_INT 22
69762: PUSH
69763: LD_VAR 0 1
69767: PPUSH
69768: CALL_OW 255
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 58
69779: PUSH
69780: EMPTY
69781: LIST
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PPUSH
69787: CALL_OW 69
69791: IN
69792: ST_TO_ADDR
// end ;
69793: LD_VAR 0 2
69797: RET
// export function IsNotFull ( building ) ; var places ; begin
69798: LD_INT 0
69800: PPUSH
69801: PPUSH
// if not building then
69802: LD_VAR 0 1
69806: NOT
69807: IFFALSE 69811
// exit ;
69809: GO 69982
// result := false ;
69811: LD_ADDR_VAR 0 2
69815: PUSH
69816: LD_INT 0
69818: ST_TO_ADDR
// places := 0 ;
69819: LD_ADDR_VAR 0 3
69823: PUSH
69824: LD_INT 0
69826: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69827: LD_VAR 0 1
69831: PPUSH
69832: CALL_OW 266
69836: PUSH
69837: LD_INT 0
69839: DOUBLE
69840: EQUAL
69841: IFTRUE 69899
69843: LD_INT 1
69845: DOUBLE
69846: EQUAL
69847: IFTRUE 69899
69849: LD_INT 6
69851: DOUBLE
69852: EQUAL
69853: IFTRUE 69899
69855: LD_INT 7
69857: DOUBLE
69858: EQUAL
69859: IFTRUE 69899
69861: LD_INT 8
69863: DOUBLE
69864: EQUAL
69865: IFTRUE 69899
69867: LD_INT 4
69869: DOUBLE
69870: EQUAL
69871: IFTRUE 69899
69873: LD_INT 5
69875: DOUBLE
69876: EQUAL
69877: IFTRUE 69899
69879: LD_INT 2
69881: DOUBLE
69882: EQUAL
69883: IFTRUE 69899
69885: LD_INT 3
69887: DOUBLE
69888: EQUAL
69889: IFTRUE 69899
69891: LD_INT 35
69893: DOUBLE
69894: EQUAL
69895: IFTRUE 69899
69897: GO 69910
69899: POP
// places := 6 ; b_bunker , b_breastwork :
69900: LD_ADDR_VAR 0 3
69904: PUSH
69905: LD_INT 6
69907: ST_TO_ADDR
69908: GO 69955
69910: LD_INT 32
69912: DOUBLE
69913: EQUAL
69914: IFTRUE 69924
69916: LD_INT 31
69918: DOUBLE
69919: EQUAL
69920: IFTRUE 69924
69922: GO 69935
69924: POP
// places := 1 ; b_control_tower :
69925: LD_ADDR_VAR 0 3
69929: PUSH
69930: LD_INT 1
69932: ST_TO_ADDR
69933: GO 69955
69935: LD_INT 36
69937: DOUBLE
69938: EQUAL
69939: IFTRUE 69943
69941: GO 69954
69943: POP
// places := 3 ; end ;
69944: LD_ADDR_VAR 0 3
69948: PUSH
69949: LD_INT 3
69951: ST_TO_ADDR
69952: GO 69955
69954: POP
// if places then
69955: LD_VAR 0 3
69959: IFFALSE 69982
// result := UnitsInside ( building ) < places ;
69961: LD_ADDR_VAR 0 2
69965: PUSH
69966: LD_VAR 0 1
69970: PPUSH
69971: CALL_OW 313
69975: PUSH
69976: LD_VAR 0 3
69980: LESS
69981: ST_TO_ADDR
// end ;
69982: LD_VAR 0 2
69986: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69987: LD_INT 0
69989: PPUSH
69990: PPUSH
69991: PPUSH
69992: PPUSH
// tmp := [ ] ;
69993: LD_ADDR_VAR 0 3
69997: PUSH
69998: EMPTY
69999: ST_TO_ADDR
// list := [ ] ;
70000: LD_ADDR_VAR 0 5
70004: PUSH
70005: EMPTY
70006: ST_TO_ADDR
// for i = 16 to 25 do
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: DOUBLE
70013: LD_INT 16
70015: DEC
70016: ST_TO_ADDR
70017: LD_INT 25
70019: PUSH
70020: FOR_TO
70021: IFFALSE 70094
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
70023: LD_ADDR_VAR 0 3
70027: PUSH
70028: LD_VAR 0 3
70032: PUSH
70033: LD_INT 22
70035: PUSH
70036: LD_VAR 0 1
70040: PPUSH
70041: CALL_OW 255
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 91
70052: PUSH
70053: LD_VAR 0 1
70057: PUSH
70058: LD_INT 6
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: LIST
70065: PUSH
70066: LD_INT 30
70068: PUSH
70069: LD_VAR 0 4
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: LIST
70082: PUSH
70083: EMPTY
70084: LIST
70085: PPUSH
70086: CALL_OW 69
70090: ADD
70091: ST_TO_ADDR
70092: GO 70020
70094: POP
70095: POP
// for i = 1 to tmp do
70096: LD_ADDR_VAR 0 4
70100: PUSH
70101: DOUBLE
70102: LD_INT 1
70104: DEC
70105: ST_TO_ADDR
70106: LD_VAR 0 3
70110: PUSH
70111: FOR_TO
70112: IFFALSE 70200
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70114: LD_ADDR_VAR 0 5
70118: PUSH
70119: LD_VAR 0 5
70123: PUSH
70124: LD_VAR 0 3
70128: PUSH
70129: LD_VAR 0 4
70133: ARRAY
70134: PPUSH
70135: CALL_OW 266
70139: PUSH
70140: LD_VAR 0 3
70144: PUSH
70145: LD_VAR 0 4
70149: ARRAY
70150: PPUSH
70151: CALL_OW 250
70155: PUSH
70156: LD_VAR 0 3
70160: PUSH
70161: LD_VAR 0 4
70165: ARRAY
70166: PPUSH
70167: CALL_OW 251
70171: PUSH
70172: LD_VAR 0 3
70176: PUSH
70177: LD_VAR 0 4
70181: ARRAY
70182: PPUSH
70183: CALL_OW 254
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: PUSH
70194: EMPTY
70195: LIST
70196: ADD
70197: ST_TO_ADDR
70198: GO 70111
70200: POP
70201: POP
// result := list ;
70202: LD_ADDR_VAR 0 2
70206: PUSH
70207: LD_VAR 0 5
70211: ST_TO_ADDR
// end ;
70212: LD_VAR 0 2
70216: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
70217: LD_INT 0
70219: PPUSH
70220: PPUSH
70221: PPUSH
70222: PPUSH
70223: PPUSH
70224: PPUSH
70225: PPUSH
// if not factory then
70226: LD_VAR 0 1
70230: NOT
70231: IFFALSE 70235
// exit ;
70233: GO 70828
// if control = control_apeman then
70235: LD_VAR 0 4
70239: PUSH
70240: LD_INT 5
70242: EQUAL
70243: IFFALSE 70352
// begin tmp := UnitsInside ( factory ) ;
70245: LD_ADDR_VAR 0 8
70249: PUSH
70250: LD_VAR 0 1
70254: PPUSH
70255: CALL_OW 313
70259: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
70260: LD_VAR 0 8
70264: PPUSH
70265: LD_INT 25
70267: PUSH
70268: LD_INT 12
70270: PUSH
70271: EMPTY
70272: LIST
70273: LIST
70274: PPUSH
70275: CALL_OW 72
70279: NOT
70280: IFFALSE 70290
// control := control_manual ;
70282: LD_ADDR_VAR 0 4
70286: PUSH
70287: LD_INT 1
70289: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
70290: LD_ADDR_VAR 0 8
70294: PUSH
70295: LD_VAR 0 1
70299: PPUSH
70300: CALL 69987 0 1
70304: ST_TO_ADDR
// if tmp then
70305: LD_VAR 0 8
70309: IFFALSE 70352
// begin for i in tmp do
70311: LD_ADDR_VAR 0 7
70315: PUSH
70316: LD_VAR 0 8
70320: PUSH
70321: FOR_IN
70322: IFFALSE 70350
// if i [ 1 ] = b_ext_radio then
70324: LD_VAR 0 7
70328: PUSH
70329: LD_INT 1
70331: ARRAY
70332: PUSH
70333: LD_INT 22
70335: EQUAL
70336: IFFALSE 70348
// begin control := control_remote ;
70338: LD_ADDR_VAR 0 4
70342: PUSH
70343: LD_INT 2
70345: ST_TO_ADDR
// break ;
70346: GO 70350
// end ;
70348: GO 70321
70350: POP
70351: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70352: LD_VAR 0 1
70356: PPUSH
70357: LD_VAR 0 2
70361: PPUSH
70362: LD_VAR 0 3
70366: PPUSH
70367: LD_VAR 0 4
70371: PPUSH
70372: LD_VAR 0 5
70376: PPUSH
70377: CALL_OW 448
70381: IFFALSE 70416
// begin result := [ chassis , engine , control , weapon ] ;
70383: LD_ADDR_VAR 0 6
70387: PUSH
70388: LD_VAR 0 2
70392: PUSH
70393: LD_VAR 0 3
70397: PUSH
70398: LD_VAR 0 4
70402: PUSH
70403: LD_VAR 0 5
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: LIST
70412: LIST
70413: ST_TO_ADDR
// exit ;
70414: GO 70828
// end ; _chassis := AvailableChassisList ( factory ) ;
70416: LD_ADDR_VAR 0 9
70420: PUSH
70421: LD_VAR 0 1
70425: PPUSH
70426: CALL_OW 475
70430: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70431: LD_ADDR_VAR 0 11
70435: PUSH
70436: LD_VAR 0 1
70440: PPUSH
70441: CALL_OW 476
70445: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70446: LD_ADDR_VAR 0 12
70450: PUSH
70451: LD_VAR 0 1
70455: PPUSH
70456: CALL_OW 477
70460: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70461: LD_ADDR_VAR 0 10
70465: PUSH
70466: LD_VAR 0 1
70470: PPUSH
70471: CALL_OW 478
70475: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70476: LD_VAR 0 9
70480: NOT
70481: PUSH
70482: LD_VAR 0 11
70486: NOT
70487: OR
70488: PUSH
70489: LD_VAR 0 12
70493: NOT
70494: OR
70495: PUSH
70496: LD_VAR 0 10
70500: NOT
70501: OR
70502: IFFALSE 70537
// begin result := [ chassis , engine , control , weapon ] ;
70504: LD_ADDR_VAR 0 6
70508: PUSH
70509: LD_VAR 0 2
70513: PUSH
70514: LD_VAR 0 3
70518: PUSH
70519: LD_VAR 0 4
70523: PUSH
70524: LD_VAR 0 5
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: ST_TO_ADDR
// exit ;
70535: GO 70828
// end ; if not chassis in _chassis then
70537: LD_VAR 0 2
70541: PUSH
70542: LD_VAR 0 9
70546: IN
70547: NOT
70548: IFFALSE 70574
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70550: LD_ADDR_VAR 0 2
70554: PUSH
70555: LD_VAR 0 9
70559: PUSH
70560: LD_INT 1
70562: PPUSH
70563: LD_VAR 0 9
70567: PPUSH
70568: CALL_OW 12
70572: ARRAY
70573: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70574: LD_VAR 0 2
70578: PPUSH
70579: LD_VAR 0 3
70583: PPUSH
70584: CALL 70833 0 2
70588: NOT
70589: IFFALSE 70648
// repeat engine := _engine [ 1 ] ;
70591: LD_ADDR_VAR 0 3
70595: PUSH
70596: LD_VAR 0 11
70600: PUSH
70601: LD_INT 1
70603: ARRAY
70604: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70605: LD_ADDR_VAR 0 11
70609: PUSH
70610: LD_VAR 0 11
70614: PPUSH
70615: LD_INT 1
70617: PPUSH
70618: CALL_OW 3
70622: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70623: LD_VAR 0 2
70627: PPUSH
70628: LD_VAR 0 3
70632: PPUSH
70633: CALL 70833 0 2
70637: PUSH
70638: LD_VAR 0 11
70642: PUSH
70643: EMPTY
70644: EQUAL
70645: OR
70646: IFFALSE 70591
// if not control in _control then
70648: LD_VAR 0 4
70652: PUSH
70653: LD_VAR 0 12
70657: IN
70658: NOT
70659: IFFALSE 70685
// control := _control [ rand ( 1 , _control ) ] ;
70661: LD_ADDR_VAR 0 4
70665: PUSH
70666: LD_VAR 0 12
70670: PUSH
70671: LD_INT 1
70673: PPUSH
70674: LD_VAR 0 12
70678: PPUSH
70679: CALL_OW 12
70683: ARRAY
70684: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70685: LD_VAR 0 2
70689: PPUSH
70690: LD_VAR 0 5
70694: PPUSH
70695: CALL 71053 0 2
70699: NOT
70700: IFFALSE 70759
// repeat weapon := _weapon [ 1 ] ;
70702: LD_ADDR_VAR 0 5
70706: PUSH
70707: LD_VAR 0 10
70711: PUSH
70712: LD_INT 1
70714: ARRAY
70715: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70716: LD_ADDR_VAR 0 10
70720: PUSH
70721: LD_VAR 0 10
70725: PPUSH
70726: LD_INT 1
70728: PPUSH
70729: CALL_OW 3
70733: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70734: LD_VAR 0 2
70738: PPUSH
70739: LD_VAR 0 5
70743: PPUSH
70744: CALL 71053 0 2
70748: PUSH
70749: LD_VAR 0 10
70753: PUSH
70754: EMPTY
70755: EQUAL
70756: OR
70757: IFFALSE 70702
// result := [ ] ;
70759: LD_ADDR_VAR 0 6
70763: PUSH
70764: EMPTY
70765: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70766: LD_VAR 0 1
70770: PPUSH
70771: LD_VAR 0 2
70775: PPUSH
70776: LD_VAR 0 3
70780: PPUSH
70781: LD_VAR 0 4
70785: PPUSH
70786: LD_VAR 0 5
70790: PPUSH
70791: CALL_OW 448
70795: IFFALSE 70828
// result := [ chassis , engine , control , weapon ] ;
70797: LD_ADDR_VAR 0 6
70801: PUSH
70802: LD_VAR 0 2
70806: PUSH
70807: LD_VAR 0 3
70811: PUSH
70812: LD_VAR 0 4
70816: PUSH
70817: LD_VAR 0 5
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: ST_TO_ADDR
// end ;
70828: LD_VAR 0 6
70832: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70833: LD_INT 0
70835: PPUSH
// if not chassis or not engine then
70836: LD_VAR 0 1
70840: NOT
70841: PUSH
70842: LD_VAR 0 2
70846: NOT
70847: OR
70848: IFFALSE 70852
// exit ;
70850: GO 71048
// case engine of engine_solar :
70852: LD_VAR 0 2
70856: PUSH
70857: LD_INT 2
70859: DOUBLE
70860: EQUAL
70861: IFTRUE 70865
70863: GO 70903
70865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70866: LD_ADDR_VAR 0 3
70870: PUSH
70871: LD_INT 11
70873: PUSH
70874: LD_INT 12
70876: PUSH
70877: LD_INT 13
70879: PUSH
70880: LD_INT 14
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 3
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: ST_TO_ADDR
70901: GO 71032
70903: LD_INT 1
70905: DOUBLE
70906: EQUAL
70907: IFTRUE 70911
70909: GO 70973
70911: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70912: LD_ADDR_VAR 0 3
70916: PUSH
70917: LD_INT 11
70919: PUSH
70920: LD_INT 12
70922: PUSH
70923: LD_INT 13
70925: PUSH
70926: LD_INT 14
70928: PUSH
70929: LD_INT 1
70931: PUSH
70932: LD_INT 2
70934: PUSH
70935: LD_INT 3
70937: PUSH
70938: LD_INT 4
70940: PUSH
70941: LD_INT 5
70943: PUSH
70944: LD_INT 21
70946: PUSH
70947: LD_INT 23
70949: PUSH
70950: LD_INT 22
70952: PUSH
70953: LD_INT 24
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: LIST
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: ST_TO_ADDR
70971: GO 71032
70973: LD_INT 3
70975: DOUBLE
70976: EQUAL
70977: IFTRUE 70981
70979: GO 71031
70981: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70982: LD_ADDR_VAR 0 3
70986: PUSH
70987: LD_INT 13
70989: PUSH
70990: LD_INT 14
70992: PUSH
70993: LD_INT 2
70995: PUSH
70996: LD_INT 3
70998: PUSH
70999: LD_INT 4
71001: PUSH
71002: LD_INT 5
71004: PUSH
71005: LD_INT 21
71007: PUSH
71008: LD_INT 22
71010: PUSH
71011: LD_INT 23
71013: PUSH
71014: LD_INT 24
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: ST_TO_ADDR
71029: GO 71032
71031: POP
// result := ( chassis in result ) ;
71032: LD_ADDR_VAR 0 3
71036: PUSH
71037: LD_VAR 0 1
71041: PUSH
71042: LD_VAR 0 3
71046: IN
71047: ST_TO_ADDR
// end ;
71048: LD_VAR 0 3
71052: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
71053: LD_INT 0
71055: PPUSH
// if not chassis or not weapon then
71056: LD_VAR 0 1
71060: NOT
71061: PUSH
71062: LD_VAR 0 2
71066: NOT
71067: OR
71068: IFFALSE 71072
// exit ;
71070: GO 72132
// case weapon of us_machine_gun :
71072: LD_VAR 0 2
71076: PUSH
71077: LD_INT 2
71079: DOUBLE
71080: EQUAL
71081: IFTRUE 71085
71083: GO 71115
71085: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71086: LD_ADDR_VAR 0 3
71090: PUSH
71091: LD_INT 1
71093: PUSH
71094: LD_INT 2
71096: PUSH
71097: LD_INT 3
71099: PUSH
71100: LD_INT 4
71102: PUSH
71103: LD_INT 5
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: ST_TO_ADDR
71113: GO 72116
71115: LD_INT 3
71117: DOUBLE
71118: EQUAL
71119: IFTRUE 71123
71121: GO 71153
71123: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71124: LD_ADDR_VAR 0 3
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: LD_INT 2
71134: PUSH
71135: LD_INT 3
71137: PUSH
71138: LD_INT 4
71140: PUSH
71141: LD_INT 5
71143: PUSH
71144: EMPTY
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: ST_TO_ADDR
71151: GO 72116
71153: LD_INT 11
71155: DOUBLE
71156: EQUAL
71157: IFTRUE 71161
71159: GO 71191
71161: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71162: LD_ADDR_VAR 0 3
71166: PUSH
71167: LD_INT 1
71169: PUSH
71170: LD_INT 2
71172: PUSH
71173: LD_INT 3
71175: PUSH
71176: LD_INT 4
71178: PUSH
71179: LD_INT 5
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: LIST
71186: LIST
71187: LIST
71188: ST_TO_ADDR
71189: GO 72116
71191: LD_INT 4
71193: DOUBLE
71194: EQUAL
71195: IFTRUE 71199
71197: GO 71225
71199: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
71200: LD_ADDR_VAR 0 3
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: LD_INT 3
71210: PUSH
71211: LD_INT 4
71213: PUSH
71214: LD_INT 5
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: ST_TO_ADDR
71223: GO 72116
71225: LD_INT 5
71227: DOUBLE
71228: EQUAL
71229: IFTRUE 71233
71231: GO 71259
71233: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
71234: LD_ADDR_VAR 0 3
71238: PUSH
71239: LD_INT 2
71241: PUSH
71242: LD_INT 3
71244: PUSH
71245: LD_INT 4
71247: PUSH
71248: LD_INT 5
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: ST_TO_ADDR
71257: GO 72116
71259: LD_INT 9
71261: DOUBLE
71262: EQUAL
71263: IFTRUE 71267
71265: GO 71293
71267: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
71268: LD_ADDR_VAR 0 3
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: LD_INT 3
71278: PUSH
71279: LD_INT 4
71281: PUSH
71282: LD_INT 5
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: ST_TO_ADDR
71291: GO 72116
71293: LD_INT 7
71295: DOUBLE
71296: EQUAL
71297: IFTRUE 71301
71299: GO 71327
71301: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
71302: LD_ADDR_VAR 0 3
71306: PUSH
71307: LD_INT 2
71309: PUSH
71310: LD_INT 3
71312: PUSH
71313: LD_INT 4
71315: PUSH
71316: LD_INT 5
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: ST_TO_ADDR
71325: GO 72116
71327: LD_INT 12
71329: DOUBLE
71330: EQUAL
71331: IFTRUE 71335
71333: GO 71361
71335: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
71336: LD_ADDR_VAR 0 3
71340: PUSH
71341: LD_INT 2
71343: PUSH
71344: LD_INT 3
71346: PUSH
71347: LD_INT 4
71349: PUSH
71350: LD_INT 5
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: ST_TO_ADDR
71359: GO 72116
71361: LD_INT 13
71363: DOUBLE
71364: EQUAL
71365: IFTRUE 71369
71367: GO 71395
71369: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
71370: LD_ADDR_VAR 0 3
71374: PUSH
71375: LD_INT 2
71377: PUSH
71378: LD_INT 3
71380: PUSH
71381: LD_INT 4
71383: PUSH
71384: LD_INT 5
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: ST_TO_ADDR
71393: GO 72116
71395: LD_INT 14
71397: DOUBLE
71398: EQUAL
71399: IFTRUE 71403
71401: GO 71421
71403: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71404: LD_ADDR_VAR 0 3
71408: PUSH
71409: LD_INT 4
71411: PUSH
71412: LD_INT 5
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: ST_TO_ADDR
71419: GO 72116
71421: LD_INT 6
71423: DOUBLE
71424: EQUAL
71425: IFTRUE 71429
71427: GO 71447
71429: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71430: LD_ADDR_VAR 0 3
71434: PUSH
71435: LD_INT 4
71437: PUSH
71438: LD_INT 5
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: ST_TO_ADDR
71445: GO 72116
71447: LD_INT 10
71449: DOUBLE
71450: EQUAL
71451: IFTRUE 71455
71453: GO 71473
71455: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71456: LD_ADDR_VAR 0 3
71460: PUSH
71461: LD_INT 4
71463: PUSH
71464: LD_INT 5
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: ST_TO_ADDR
71471: GO 72116
71473: LD_INT 22
71475: DOUBLE
71476: EQUAL
71477: IFTRUE 71481
71479: GO 71507
71481: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71482: LD_ADDR_VAR 0 3
71486: PUSH
71487: LD_INT 11
71489: PUSH
71490: LD_INT 12
71492: PUSH
71493: LD_INT 13
71495: PUSH
71496: LD_INT 14
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: LIST
71503: LIST
71504: ST_TO_ADDR
71505: GO 72116
71507: LD_INT 23
71509: DOUBLE
71510: EQUAL
71511: IFTRUE 71515
71513: GO 71541
71515: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71516: LD_ADDR_VAR 0 3
71520: PUSH
71521: LD_INT 11
71523: PUSH
71524: LD_INT 12
71526: PUSH
71527: LD_INT 13
71529: PUSH
71530: LD_INT 14
71532: PUSH
71533: EMPTY
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: ST_TO_ADDR
71539: GO 72116
71541: LD_INT 24
71543: DOUBLE
71544: EQUAL
71545: IFTRUE 71549
71547: GO 71575
71549: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71550: LD_ADDR_VAR 0 3
71554: PUSH
71555: LD_INT 11
71557: PUSH
71558: LD_INT 12
71560: PUSH
71561: LD_INT 13
71563: PUSH
71564: LD_INT 14
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: LIST
71571: LIST
71572: ST_TO_ADDR
71573: GO 72116
71575: LD_INT 30
71577: DOUBLE
71578: EQUAL
71579: IFTRUE 71583
71581: GO 71609
71583: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71584: LD_ADDR_VAR 0 3
71588: PUSH
71589: LD_INT 11
71591: PUSH
71592: LD_INT 12
71594: PUSH
71595: LD_INT 13
71597: PUSH
71598: LD_INT 14
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: ST_TO_ADDR
71607: GO 72116
71609: LD_INT 25
71611: DOUBLE
71612: EQUAL
71613: IFTRUE 71617
71615: GO 71635
71617: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71618: LD_ADDR_VAR 0 3
71622: PUSH
71623: LD_INT 13
71625: PUSH
71626: LD_INT 14
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: ST_TO_ADDR
71633: GO 72116
71635: LD_INT 27
71637: DOUBLE
71638: EQUAL
71639: IFTRUE 71643
71641: GO 71661
71643: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71644: LD_ADDR_VAR 0 3
71648: PUSH
71649: LD_INT 13
71651: PUSH
71652: LD_INT 14
71654: PUSH
71655: EMPTY
71656: LIST
71657: LIST
71658: ST_TO_ADDR
71659: GO 72116
71661: LD_INT 92
71663: DOUBLE
71664: EQUAL
71665: IFTRUE 71669
71667: GO 71695
71669: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71670: LD_ADDR_VAR 0 3
71674: PUSH
71675: LD_INT 11
71677: PUSH
71678: LD_INT 12
71680: PUSH
71681: LD_INT 13
71683: PUSH
71684: LD_INT 14
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: ST_TO_ADDR
71693: GO 72116
71695: LD_INT 28
71697: DOUBLE
71698: EQUAL
71699: IFTRUE 71703
71701: GO 71721
71703: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71704: LD_ADDR_VAR 0 3
71708: PUSH
71709: LD_INT 13
71711: PUSH
71712: LD_INT 14
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: ST_TO_ADDR
71719: GO 72116
71721: LD_INT 29
71723: DOUBLE
71724: EQUAL
71725: IFTRUE 71729
71727: GO 71747
71729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71730: LD_ADDR_VAR 0 3
71734: PUSH
71735: LD_INT 13
71737: PUSH
71738: LD_INT 14
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: ST_TO_ADDR
71745: GO 72116
71747: LD_INT 31
71749: DOUBLE
71750: EQUAL
71751: IFTRUE 71755
71753: GO 71773
71755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71756: LD_ADDR_VAR 0 3
71760: PUSH
71761: LD_INT 13
71763: PUSH
71764: LD_INT 14
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: ST_TO_ADDR
71771: GO 72116
71773: LD_INT 26
71775: DOUBLE
71776: EQUAL
71777: IFTRUE 71781
71779: GO 71799
71781: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71782: LD_ADDR_VAR 0 3
71786: PUSH
71787: LD_INT 13
71789: PUSH
71790: LD_INT 14
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: ST_TO_ADDR
71797: GO 72116
71799: LD_INT 42
71801: DOUBLE
71802: EQUAL
71803: IFTRUE 71807
71805: GO 71833
71807: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71808: LD_ADDR_VAR 0 3
71812: PUSH
71813: LD_INT 21
71815: PUSH
71816: LD_INT 22
71818: PUSH
71819: LD_INT 23
71821: PUSH
71822: LD_INT 24
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: ST_TO_ADDR
71831: GO 72116
71833: LD_INT 43
71835: DOUBLE
71836: EQUAL
71837: IFTRUE 71841
71839: GO 71867
71841: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71842: LD_ADDR_VAR 0 3
71846: PUSH
71847: LD_INT 21
71849: PUSH
71850: LD_INT 22
71852: PUSH
71853: LD_INT 23
71855: PUSH
71856: LD_INT 24
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: ST_TO_ADDR
71865: GO 72116
71867: LD_INT 44
71869: DOUBLE
71870: EQUAL
71871: IFTRUE 71875
71873: GO 71901
71875: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71876: LD_ADDR_VAR 0 3
71880: PUSH
71881: LD_INT 21
71883: PUSH
71884: LD_INT 22
71886: PUSH
71887: LD_INT 23
71889: PUSH
71890: LD_INT 24
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: ST_TO_ADDR
71899: GO 72116
71901: LD_INT 45
71903: DOUBLE
71904: EQUAL
71905: IFTRUE 71909
71907: GO 71935
71909: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71910: LD_ADDR_VAR 0 3
71914: PUSH
71915: LD_INT 21
71917: PUSH
71918: LD_INT 22
71920: PUSH
71921: LD_INT 23
71923: PUSH
71924: LD_INT 24
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: ST_TO_ADDR
71933: GO 72116
71935: LD_INT 49
71937: DOUBLE
71938: EQUAL
71939: IFTRUE 71943
71941: GO 71969
71943: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71944: LD_ADDR_VAR 0 3
71948: PUSH
71949: LD_INT 21
71951: PUSH
71952: LD_INT 22
71954: PUSH
71955: LD_INT 23
71957: PUSH
71958: LD_INT 24
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: ST_TO_ADDR
71967: GO 72116
71969: LD_INT 51
71971: DOUBLE
71972: EQUAL
71973: IFTRUE 71977
71975: GO 72003
71977: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71978: LD_ADDR_VAR 0 3
71982: PUSH
71983: LD_INT 21
71985: PUSH
71986: LD_INT 22
71988: PUSH
71989: LD_INT 23
71991: PUSH
71992: LD_INT 24
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: ST_TO_ADDR
72001: GO 72116
72003: LD_INT 52
72005: DOUBLE
72006: EQUAL
72007: IFTRUE 72011
72009: GO 72037
72011: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
72012: LD_ADDR_VAR 0 3
72016: PUSH
72017: LD_INT 21
72019: PUSH
72020: LD_INT 22
72022: PUSH
72023: LD_INT 23
72025: PUSH
72026: LD_INT 24
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: ST_TO_ADDR
72035: GO 72116
72037: LD_INT 53
72039: DOUBLE
72040: EQUAL
72041: IFTRUE 72045
72043: GO 72063
72045: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
72046: LD_ADDR_VAR 0 3
72050: PUSH
72051: LD_INT 23
72053: PUSH
72054: LD_INT 24
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: ST_TO_ADDR
72061: GO 72116
72063: LD_INT 46
72065: DOUBLE
72066: EQUAL
72067: IFTRUE 72071
72069: GO 72089
72071: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72072: LD_ADDR_VAR 0 3
72076: PUSH
72077: LD_INT 23
72079: PUSH
72080: LD_INT 24
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: ST_TO_ADDR
72087: GO 72116
72089: LD_INT 47
72091: DOUBLE
72092: EQUAL
72093: IFTRUE 72097
72095: GO 72115
72097: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72098: LD_ADDR_VAR 0 3
72102: PUSH
72103: LD_INT 23
72105: PUSH
72106: LD_INT 24
72108: PUSH
72109: EMPTY
72110: LIST
72111: LIST
72112: ST_TO_ADDR
72113: GO 72116
72115: POP
// result := ( chassis in result ) ;
72116: LD_ADDR_VAR 0 3
72120: PUSH
72121: LD_VAR 0 1
72125: PUSH
72126: LD_VAR 0 3
72130: IN
72131: ST_TO_ADDR
// end ;
72132: LD_VAR 0 3
72136: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72137: LD_INT 0
72139: PPUSH
72140: PPUSH
72141: PPUSH
72142: PPUSH
72143: PPUSH
72144: PPUSH
72145: PPUSH
// result := array ;
72146: LD_ADDR_VAR 0 5
72150: PUSH
72151: LD_VAR 0 1
72155: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72156: LD_VAR 0 1
72160: NOT
72161: PUSH
72162: LD_VAR 0 2
72166: NOT
72167: OR
72168: PUSH
72169: LD_VAR 0 3
72173: NOT
72174: OR
72175: PUSH
72176: LD_VAR 0 2
72180: PUSH
72181: LD_VAR 0 1
72185: GREATER
72186: OR
72187: PUSH
72188: LD_VAR 0 3
72192: PUSH
72193: LD_VAR 0 1
72197: GREATER
72198: OR
72199: IFFALSE 72203
// exit ;
72201: GO 72499
// if direction then
72203: LD_VAR 0 4
72207: IFFALSE 72271
// begin d := 1 ;
72209: LD_ADDR_VAR 0 9
72213: PUSH
72214: LD_INT 1
72216: ST_TO_ADDR
// if i_from > i_to then
72217: LD_VAR 0 2
72221: PUSH
72222: LD_VAR 0 3
72226: GREATER
72227: IFFALSE 72253
// length := ( array - i_from ) + i_to else
72229: LD_ADDR_VAR 0 11
72233: PUSH
72234: LD_VAR 0 1
72238: PUSH
72239: LD_VAR 0 2
72243: MINUS
72244: PUSH
72245: LD_VAR 0 3
72249: PLUS
72250: ST_TO_ADDR
72251: GO 72269
// length := i_to - i_from ;
72253: LD_ADDR_VAR 0 11
72257: PUSH
72258: LD_VAR 0 3
72262: PUSH
72263: LD_VAR 0 2
72267: MINUS
72268: ST_TO_ADDR
// end else
72269: GO 72332
// begin d := - 1 ;
72271: LD_ADDR_VAR 0 9
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: ST_TO_ADDR
// if i_from > i_to then
72280: LD_VAR 0 2
72284: PUSH
72285: LD_VAR 0 3
72289: GREATER
72290: IFFALSE 72310
// length := i_from - i_to else
72292: LD_ADDR_VAR 0 11
72296: PUSH
72297: LD_VAR 0 2
72301: PUSH
72302: LD_VAR 0 3
72306: MINUS
72307: ST_TO_ADDR
72308: GO 72332
// length := ( array - i_to ) + i_from ;
72310: LD_ADDR_VAR 0 11
72314: PUSH
72315: LD_VAR 0 1
72319: PUSH
72320: LD_VAR 0 3
72324: MINUS
72325: PUSH
72326: LD_VAR 0 2
72330: PLUS
72331: ST_TO_ADDR
// end ; if not length then
72332: LD_VAR 0 11
72336: NOT
72337: IFFALSE 72341
// exit ;
72339: GO 72499
// tmp := array ;
72341: LD_ADDR_VAR 0 10
72345: PUSH
72346: LD_VAR 0 1
72350: ST_TO_ADDR
// for i = 1 to length do
72351: LD_ADDR_VAR 0 6
72355: PUSH
72356: DOUBLE
72357: LD_INT 1
72359: DEC
72360: ST_TO_ADDR
72361: LD_VAR 0 11
72365: PUSH
72366: FOR_TO
72367: IFFALSE 72487
// begin for j = 1 to array do
72369: LD_ADDR_VAR 0 7
72373: PUSH
72374: DOUBLE
72375: LD_INT 1
72377: DEC
72378: ST_TO_ADDR
72379: LD_VAR 0 1
72383: PUSH
72384: FOR_TO
72385: IFFALSE 72473
// begin k := j + d ;
72387: LD_ADDR_VAR 0 8
72391: PUSH
72392: LD_VAR 0 7
72396: PUSH
72397: LD_VAR 0 9
72401: PLUS
72402: ST_TO_ADDR
// if k > array then
72403: LD_VAR 0 8
72407: PUSH
72408: LD_VAR 0 1
72412: GREATER
72413: IFFALSE 72423
// k := 1 ;
72415: LD_ADDR_VAR 0 8
72419: PUSH
72420: LD_INT 1
72422: ST_TO_ADDR
// if not k then
72423: LD_VAR 0 8
72427: NOT
72428: IFFALSE 72440
// k := array ;
72430: LD_ADDR_VAR 0 8
72434: PUSH
72435: LD_VAR 0 1
72439: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72440: LD_ADDR_VAR 0 10
72444: PUSH
72445: LD_VAR 0 10
72449: PPUSH
72450: LD_VAR 0 8
72454: PPUSH
72455: LD_VAR 0 1
72459: PUSH
72460: LD_VAR 0 7
72464: ARRAY
72465: PPUSH
72466: CALL_OW 1
72470: ST_TO_ADDR
// end ;
72471: GO 72384
72473: POP
72474: POP
// array := tmp ;
72475: LD_ADDR_VAR 0 1
72479: PUSH
72480: LD_VAR 0 10
72484: ST_TO_ADDR
// end ;
72485: GO 72366
72487: POP
72488: POP
// result := array ;
72489: LD_ADDR_VAR 0 5
72493: PUSH
72494: LD_VAR 0 1
72498: ST_TO_ADDR
// end ;
72499: LD_VAR 0 5
72503: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72504: LD_INT 0
72506: PPUSH
72507: PPUSH
// result := 0 ;
72508: LD_ADDR_VAR 0 3
72512: PUSH
72513: LD_INT 0
72515: ST_TO_ADDR
// if not array or not value in array then
72516: LD_VAR 0 1
72520: NOT
72521: PUSH
72522: LD_VAR 0 2
72526: PUSH
72527: LD_VAR 0 1
72531: IN
72532: NOT
72533: OR
72534: IFFALSE 72538
// exit ;
72536: GO 72592
// for i = 1 to array do
72538: LD_ADDR_VAR 0 4
72542: PUSH
72543: DOUBLE
72544: LD_INT 1
72546: DEC
72547: ST_TO_ADDR
72548: LD_VAR 0 1
72552: PUSH
72553: FOR_TO
72554: IFFALSE 72590
// if value = array [ i ] then
72556: LD_VAR 0 2
72560: PUSH
72561: LD_VAR 0 1
72565: PUSH
72566: LD_VAR 0 4
72570: ARRAY
72571: EQUAL
72572: IFFALSE 72588
// begin result := i ;
72574: LD_ADDR_VAR 0 3
72578: PUSH
72579: LD_VAR 0 4
72583: ST_TO_ADDR
// exit ;
72584: POP
72585: POP
72586: GO 72592
// end ;
72588: GO 72553
72590: POP
72591: POP
// end ;
72592: LD_VAR 0 3
72596: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72597: LD_INT 0
72599: PPUSH
// vc_chassis := chassis ;
72600: LD_ADDR_OWVAR 37
72604: PUSH
72605: LD_VAR 0 1
72609: ST_TO_ADDR
// vc_engine := engine ;
72610: LD_ADDR_OWVAR 39
72614: PUSH
72615: LD_VAR 0 2
72619: ST_TO_ADDR
// vc_control := control ;
72620: LD_ADDR_OWVAR 38
72624: PUSH
72625: LD_VAR 0 3
72629: ST_TO_ADDR
// vc_weapon := weapon ;
72630: LD_ADDR_OWVAR 40
72634: PUSH
72635: LD_VAR 0 4
72639: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72640: LD_ADDR_OWVAR 41
72644: PUSH
72645: LD_VAR 0 5
72649: ST_TO_ADDR
// end ;
72650: LD_VAR 0 6
72654: RET
// export function WantPlant ( unit ) ; var task ; begin
72655: LD_INT 0
72657: PPUSH
72658: PPUSH
// result := false ;
72659: LD_ADDR_VAR 0 2
72663: PUSH
72664: LD_INT 0
72666: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72667: LD_ADDR_VAR 0 3
72671: PUSH
72672: LD_VAR 0 1
72676: PPUSH
72677: CALL_OW 437
72681: ST_TO_ADDR
// if task then
72682: LD_VAR 0 3
72686: IFFALSE 72714
// if task [ 1 ] [ 1 ] = p then
72688: LD_VAR 0 3
72692: PUSH
72693: LD_INT 1
72695: ARRAY
72696: PUSH
72697: LD_INT 1
72699: ARRAY
72700: PUSH
72701: LD_STRING p
72703: EQUAL
72704: IFFALSE 72714
// result := true ;
72706: LD_ADDR_VAR 0 2
72710: PUSH
72711: LD_INT 1
72713: ST_TO_ADDR
// end ;
72714: LD_VAR 0 2
72718: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72719: LD_INT 0
72721: PPUSH
72722: PPUSH
72723: PPUSH
72724: PPUSH
// if pos < 1 then
72725: LD_VAR 0 2
72729: PUSH
72730: LD_INT 1
72732: LESS
72733: IFFALSE 72737
// exit ;
72735: GO 73040
// if pos = 1 then
72737: LD_VAR 0 2
72741: PUSH
72742: LD_INT 1
72744: EQUAL
72745: IFFALSE 72778
// result := Replace ( arr , pos [ 1 ] , value ) else
72747: LD_ADDR_VAR 0 4
72751: PUSH
72752: LD_VAR 0 1
72756: PPUSH
72757: LD_VAR 0 2
72761: PUSH
72762: LD_INT 1
72764: ARRAY
72765: PPUSH
72766: LD_VAR 0 3
72770: PPUSH
72771: CALL_OW 1
72775: ST_TO_ADDR
72776: GO 73040
// begin tmp := arr ;
72778: LD_ADDR_VAR 0 6
72782: PUSH
72783: LD_VAR 0 1
72787: ST_TO_ADDR
// s_arr := [ tmp ] ;
72788: LD_ADDR_VAR 0 7
72792: PUSH
72793: LD_VAR 0 6
72797: PUSH
72798: EMPTY
72799: LIST
72800: ST_TO_ADDR
// for i = 1 to pos - 1 do
72801: LD_ADDR_VAR 0 5
72805: PUSH
72806: DOUBLE
72807: LD_INT 1
72809: DEC
72810: ST_TO_ADDR
72811: LD_VAR 0 2
72815: PUSH
72816: LD_INT 1
72818: MINUS
72819: PUSH
72820: FOR_TO
72821: IFFALSE 72866
// begin tmp := tmp [ pos [ i ] ] ;
72823: LD_ADDR_VAR 0 6
72827: PUSH
72828: LD_VAR 0 6
72832: PUSH
72833: LD_VAR 0 2
72837: PUSH
72838: LD_VAR 0 5
72842: ARRAY
72843: ARRAY
72844: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72845: LD_ADDR_VAR 0 7
72849: PUSH
72850: LD_VAR 0 7
72854: PUSH
72855: LD_VAR 0 6
72859: PUSH
72860: EMPTY
72861: LIST
72862: ADD
72863: ST_TO_ADDR
// end ;
72864: GO 72820
72866: POP
72867: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72868: LD_ADDR_VAR 0 6
72872: PUSH
72873: LD_VAR 0 6
72877: PPUSH
72878: LD_VAR 0 2
72882: PUSH
72883: LD_VAR 0 2
72887: ARRAY
72888: PPUSH
72889: LD_VAR 0 3
72893: PPUSH
72894: CALL_OW 1
72898: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72899: LD_ADDR_VAR 0 7
72903: PUSH
72904: LD_VAR 0 7
72908: PPUSH
72909: LD_VAR 0 7
72913: PPUSH
72914: LD_VAR 0 6
72918: PPUSH
72919: CALL_OW 1
72923: ST_TO_ADDR
// for i = s_arr downto 2 do
72924: LD_ADDR_VAR 0 5
72928: PUSH
72929: DOUBLE
72930: LD_VAR 0 7
72934: INC
72935: ST_TO_ADDR
72936: LD_INT 2
72938: PUSH
72939: FOR_DOWNTO
72940: IFFALSE 73024
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72942: LD_ADDR_VAR 0 6
72946: PUSH
72947: LD_VAR 0 7
72951: PUSH
72952: LD_VAR 0 5
72956: PUSH
72957: LD_INT 1
72959: MINUS
72960: ARRAY
72961: PPUSH
72962: LD_VAR 0 2
72966: PUSH
72967: LD_VAR 0 5
72971: PUSH
72972: LD_INT 1
72974: MINUS
72975: ARRAY
72976: PPUSH
72977: LD_VAR 0 7
72981: PUSH
72982: LD_VAR 0 5
72986: ARRAY
72987: PPUSH
72988: CALL_OW 1
72992: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72993: LD_ADDR_VAR 0 7
72997: PUSH
72998: LD_VAR 0 7
73002: PPUSH
73003: LD_VAR 0 5
73007: PUSH
73008: LD_INT 1
73010: MINUS
73011: PPUSH
73012: LD_VAR 0 6
73016: PPUSH
73017: CALL_OW 1
73021: ST_TO_ADDR
// end ;
73022: GO 72939
73024: POP
73025: POP
// result := s_arr [ 1 ] ;
73026: LD_ADDR_VAR 0 4
73030: PUSH
73031: LD_VAR 0 7
73035: PUSH
73036: LD_INT 1
73038: ARRAY
73039: ST_TO_ADDR
// end ; end ;
73040: LD_VAR 0 4
73044: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
73045: LD_INT 0
73047: PPUSH
73048: PPUSH
// if not list then
73049: LD_VAR 0 1
73053: NOT
73054: IFFALSE 73058
// exit ;
73056: GO 73149
// i := list [ pos1 ] ;
73058: LD_ADDR_VAR 0 5
73062: PUSH
73063: LD_VAR 0 1
73067: PUSH
73068: LD_VAR 0 2
73072: ARRAY
73073: ST_TO_ADDR
// if not i then
73074: LD_VAR 0 5
73078: NOT
73079: IFFALSE 73083
// exit ;
73081: GO 73149
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73083: LD_ADDR_VAR 0 1
73087: PUSH
73088: LD_VAR 0 1
73092: PPUSH
73093: LD_VAR 0 2
73097: PPUSH
73098: LD_VAR 0 1
73102: PUSH
73103: LD_VAR 0 3
73107: ARRAY
73108: PPUSH
73109: CALL_OW 1
73113: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73114: LD_ADDR_VAR 0 1
73118: PUSH
73119: LD_VAR 0 1
73123: PPUSH
73124: LD_VAR 0 3
73128: PPUSH
73129: LD_VAR 0 5
73133: PPUSH
73134: CALL_OW 1
73138: ST_TO_ADDR
// result := list ;
73139: LD_ADDR_VAR 0 4
73143: PUSH
73144: LD_VAR 0 1
73148: ST_TO_ADDR
// end ;
73149: LD_VAR 0 4
73153: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73154: LD_INT 0
73156: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73157: LD_ADDR_VAR 0 5
73161: PUSH
73162: LD_VAR 0 1
73166: PPUSH
73167: CALL_OW 250
73171: PPUSH
73172: LD_VAR 0 1
73176: PPUSH
73177: CALL_OW 251
73181: PPUSH
73182: LD_VAR 0 2
73186: PPUSH
73187: LD_VAR 0 3
73191: PPUSH
73192: LD_VAR 0 4
73196: PPUSH
73197: CALL 73207 0 5
73201: ST_TO_ADDR
// end ;
73202: LD_VAR 0 5
73206: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
73207: LD_INT 0
73209: PPUSH
73210: PPUSH
73211: PPUSH
73212: PPUSH
// if not list then
73213: LD_VAR 0 3
73217: NOT
73218: IFFALSE 73222
// exit ;
73220: GO 73610
// result := [ ] ;
73222: LD_ADDR_VAR 0 6
73226: PUSH
73227: EMPTY
73228: ST_TO_ADDR
// for i in list do
73229: LD_ADDR_VAR 0 7
73233: PUSH
73234: LD_VAR 0 3
73238: PUSH
73239: FOR_IN
73240: IFFALSE 73442
// begin tmp := GetDistUnitXY ( i , x , y ) ;
73242: LD_ADDR_VAR 0 9
73246: PUSH
73247: LD_VAR 0 7
73251: PPUSH
73252: LD_VAR 0 1
73256: PPUSH
73257: LD_VAR 0 2
73261: PPUSH
73262: CALL_OW 297
73266: ST_TO_ADDR
// if not result then
73267: LD_VAR 0 6
73271: NOT
73272: IFFALSE 73298
// result := [ [ i , tmp ] ] else
73274: LD_ADDR_VAR 0 6
73278: PUSH
73279: LD_VAR 0 7
73283: PUSH
73284: LD_VAR 0 9
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: EMPTY
73294: LIST
73295: ST_TO_ADDR
73296: GO 73440
// begin if result [ result ] [ 2 ] < tmp then
73298: LD_VAR 0 6
73302: PUSH
73303: LD_VAR 0 6
73307: ARRAY
73308: PUSH
73309: LD_INT 2
73311: ARRAY
73312: PUSH
73313: LD_VAR 0 9
73317: LESS
73318: IFFALSE 73360
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
73320: LD_ADDR_VAR 0 6
73324: PUSH
73325: LD_VAR 0 6
73329: PPUSH
73330: LD_VAR 0 6
73334: PUSH
73335: LD_INT 1
73337: PLUS
73338: PPUSH
73339: LD_VAR 0 7
73343: PUSH
73344: LD_VAR 0 9
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PPUSH
73353: CALL_OW 2
73357: ST_TO_ADDR
73358: GO 73440
// for j = 1 to result do
73360: LD_ADDR_VAR 0 8
73364: PUSH
73365: DOUBLE
73366: LD_INT 1
73368: DEC
73369: ST_TO_ADDR
73370: LD_VAR 0 6
73374: PUSH
73375: FOR_TO
73376: IFFALSE 73438
// begin if tmp < result [ j ] [ 2 ] then
73378: LD_VAR 0 9
73382: PUSH
73383: LD_VAR 0 6
73387: PUSH
73388: LD_VAR 0 8
73392: ARRAY
73393: PUSH
73394: LD_INT 2
73396: ARRAY
73397: LESS
73398: IFFALSE 73436
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73400: LD_ADDR_VAR 0 6
73404: PUSH
73405: LD_VAR 0 6
73409: PPUSH
73410: LD_VAR 0 8
73414: PPUSH
73415: LD_VAR 0 7
73419: PUSH
73420: LD_VAR 0 9
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PPUSH
73429: CALL_OW 2
73433: ST_TO_ADDR
// break ;
73434: GO 73438
// end ; end ;
73436: GO 73375
73438: POP
73439: POP
// end ; end ;
73440: GO 73239
73442: POP
73443: POP
// if result and not asc then
73444: LD_VAR 0 6
73448: PUSH
73449: LD_VAR 0 4
73453: NOT
73454: AND
73455: IFFALSE 73530
// begin tmp := result ;
73457: LD_ADDR_VAR 0 9
73461: PUSH
73462: LD_VAR 0 6
73466: ST_TO_ADDR
// for i = tmp downto 1 do
73467: LD_ADDR_VAR 0 7
73471: PUSH
73472: DOUBLE
73473: LD_VAR 0 9
73477: INC
73478: ST_TO_ADDR
73479: LD_INT 1
73481: PUSH
73482: FOR_DOWNTO
73483: IFFALSE 73528
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73485: LD_ADDR_VAR 0 6
73489: PUSH
73490: LD_VAR 0 6
73494: PPUSH
73495: LD_VAR 0 9
73499: PUSH
73500: LD_VAR 0 7
73504: MINUS
73505: PUSH
73506: LD_INT 1
73508: PLUS
73509: PPUSH
73510: LD_VAR 0 9
73514: PUSH
73515: LD_VAR 0 7
73519: ARRAY
73520: PPUSH
73521: CALL_OW 1
73525: ST_TO_ADDR
73526: GO 73482
73528: POP
73529: POP
// end ; tmp := [ ] ;
73530: LD_ADDR_VAR 0 9
73534: PUSH
73535: EMPTY
73536: ST_TO_ADDR
// if mode then
73537: LD_VAR 0 5
73541: IFFALSE 73610
// begin for i = 1 to result do
73543: LD_ADDR_VAR 0 7
73547: PUSH
73548: DOUBLE
73549: LD_INT 1
73551: DEC
73552: ST_TO_ADDR
73553: LD_VAR 0 6
73557: PUSH
73558: FOR_TO
73559: IFFALSE 73598
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73561: LD_ADDR_VAR 0 9
73565: PUSH
73566: LD_VAR 0 9
73570: PPUSH
73571: LD_VAR 0 7
73575: PPUSH
73576: LD_VAR 0 6
73580: PUSH
73581: LD_VAR 0 7
73585: ARRAY
73586: PUSH
73587: LD_INT 1
73589: ARRAY
73590: PPUSH
73591: CALL_OW 1
73595: ST_TO_ADDR
73596: GO 73558
73598: POP
73599: POP
// result := tmp ;
73600: LD_ADDR_VAR 0 6
73604: PUSH
73605: LD_VAR 0 9
73609: ST_TO_ADDR
// end ; end ;
73610: LD_VAR 0 6
73614: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73615: LD_INT 0
73617: PPUSH
73618: PPUSH
73619: PPUSH
73620: PPUSH
73621: PPUSH
73622: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73623: LD_ADDR_VAR 0 5
73627: PUSH
73628: LD_INT 0
73630: PUSH
73631: LD_INT 0
73633: PUSH
73634: LD_INT 0
73636: PUSH
73637: EMPTY
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: ST_TO_ADDR
// if not x or not y then
73645: LD_VAR 0 2
73649: NOT
73650: PUSH
73651: LD_VAR 0 3
73655: NOT
73656: OR
73657: IFFALSE 73661
// exit ;
73659: GO 75311
// if not range then
73661: LD_VAR 0 4
73665: NOT
73666: IFFALSE 73676
// range := 10 ;
73668: LD_ADDR_VAR 0 4
73672: PUSH
73673: LD_INT 10
73675: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73676: LD_ADDR_VAR 0 8
73680: PUSH
73681: LD_INT 81
73683: PUSH
73684: LD_VAR 0 1
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PUSH
73693: LD_INT 92
73695: PUSH
73696: LD_VAR 0 2
73700: PUSH
73701: LD_VAR 0 3
73705: PUSH
73706: LD_VAR 0 4
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 3
73719: PUSH
73720: LD_INT 21
73722: PUSH
73723: LD_INT 3
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: LIST
73738: PPUSH
73739: CALL_OW 69
73743: ST_TO_ADDR
// if not tmp then
73744: LD_VAR 0 8
73748: NOT
73749: IFFALSE 73753
// exit ;
73751: GO 75311
// for i in tmp do
73753: LD_ADDR_VAR 0 6
73757: PUSH
73758: LD_VAR 0 8
73762: PUSH
73763: FOR_IN
73764: IFFALSE 75286
// begin points := [ 0 , 0 , 0 ] ;
73766: LD_ADDR_VAR 0 9
73770: PUSH
73771: LD_INT 0
73773: PUSH
73774: LD_INT 0
73776: PUSH
73777: LD_INT 0
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: LIST
73784: ST_TO_ADDR
// bpoints := 1 ;
73785: LD_ADDR_VAR 0 10
73789: PUSH
73790: LD_INT 1
73792: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73793: LD_VAR 0 6
73797: PPUSH
73798: CALL_OW 247
73802: PUSH
73803: LD_INT 1
73805: DOUBLE
73806: EQUAL
73807: IFTRUE 73811
73809: GO 74389
73811: POP
// begin if GetClass ( i ) = 1 then
73812: LD_VAR 0 6
73816: PPUSH
73817: CALL_OW 257
73821: PUSH
73822: LD_INT 1
73824: EQUAL
73825: IFFALSE 73846
// points := [ 10 , 5 , 3 ] ;
73827: LD_ADDR_VAR 0 9
73831: PUSH
73832: LD_INT 10
73834: PUSH
73835: LD_INT 5
73837: PUSH
73838: LD_INT 3
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: LIST
73845: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73846: LD_VAR 0 6
73850: PPUSH
73851: CALL_OW 257
73855: PUSH
73856: LD_INT 2
73858: PUSH
73859: LD_INT 3
73861: PUSH
73862: LD_INT 4
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: LIST
73869: IN
73870: IFFALSE 73891
// points := [ 3 , 2 , 1 ] ;
73872: LD_ADDR_VAR 0 9
73876: PUSH
73877: LD_INT 3
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: LD_INT 1
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: LIST
73890: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73891: LD_VAR 0 6
73895: PPUSH
73896: CALL_OW 257
73900: PUSH
73901: LD_INT 5
73903: EQUAL
73904: IFFALSE 73925
// points := [ 130 , 5 , 2 ] ;
73906: LD_ADDR_VAR 0 9
73910: PUSH
73911: LD_INT 130
73913: PUSH
73914: LD_INT 5
73916: PUSH
73917: LD_INT 2
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: LIST
73924: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73925: LD_VAR 0 6
73929: PPUSH
73930: CALL_OW 257
73934: PUSH
73935: LD_INT 8
73937: EQUAL
73938: IFFALSE 73959
// points := [ 35 , 35 , 30 ] ;
73940: LD_ADDR_VAR 0 9
73944: PUSH
73945: LD_INT 35
73947: PUSH
73948: LD_INT 35
73950: PUSH
73951: LD_INT 30
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: LIST
73958: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73959: LD_VAR 0 6
73963: PPUSH
73964: CALL_OW 257
73968: PUSH
73969: LD_INT 9
73971: EQUAL
73972: IFFALSE 73993
// points := [ 20 , 55 , 40 ] ;
73974: LD_ADDR_VAR 0 9
73978: PUSH
73979: LD_INT 20
73981: PUSH
73982: LD_INT 55
73984: PUSH
73985: LD_INT 40
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: LIST
73992: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73993: LD_VAR 0 6
73997: PPUSH
73998: CALL_OW 257
74002: PUSH
74003: LD_INT 12
74005: PUSH
74006: LD_INT 16
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: IN
74013: IFFALSE 74034
// points := [ 5 , 3 , 2 ] ;
74015: LD_ADDR_VAR 0 9
74019: PUSH
74020: LD_INT 5
74022: PUSH
74023: LD_INT 3
74025: PUSH
74026: LD_INT 2
74028: PUSH
74029: EMPTY
74030: LIST
74031: LIST
74032: LIST
74033: ST_TO_ADDR
// if GetClass ( i ) = 17 then
74034: LD_VAR 0 6
74038: PPUSH
74039: CALL_OW 257
74043: PUSH
74044: LD_INT 17
74046: EQUAL
74047: IFFALSE 74068
// points := [ 100 , 50 , 75 ] ;
74049: LD_ADDR_VAR 0 9
74053: PUSH
74054: LD_INT 100
74056: PUSH
74057: LD_INT 50
74059: PUSH
74060: LD_INT 75
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: LIST
74067: ST_TO_ADDR
// if GetClass ( i ) = 15 then
74068: LD_VAR 0 6
74072: PPUSH
74073: CALL_OW 257
74077: PUSH
74078: LD_INT 15
74080: EQUAL
74081: IFFALSE 74102
// points := [ 10 , 5 , 3 ] ;
74083: LD_ADDR_VAR 0 9
74087: PUSH
74088: LD_INT 10
74090: PUSH
74091: LD_INT 5
74093: PUSH
74094: LD_INT 3
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: LIST
74101: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74102: LD_VAR 0 6
74106: PPUSH
74107: CALL_OW 257
74111: PUSH
74112: LD_INT 14
74114: EQUAL
74115: IFFALSE 74136
// points := [ 10 , 0 , 0 ] ;
74117: LD_ADDR_VAR 0 9
74121: PUSH
74122: LD_INT 10
74124: PUSH
74125: LD_INT 0
74127: PUSH
74128: LD_INT 0
74130: PUSH
74131: EMPTY
74132: LIST
74133: LIST
74134: LIST
74135: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74136: LD_VAR 0 6
74140: PPUSH
74141: CALL_OW 257
74145: PUSH
74146: LD_INT 11
74148: EQUAL
74149: IFFALSE 74170
// points := [ 30 , 10 , 5 ] ;
74151: LD_ADDR_VAR 0 9
74155: PUSH
74156: LD_INT 30
74158: PUSH
74159: LD_INT 10
74161: PUSH
74162: LD_INT 5
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: LIST
74169: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74170: LD_VAR 0 1
74174: PPUSH
74175: LD_INT 5
74177: PPUSH
74178: CALL_OW 321
74182: PUSH
74183: LD_INT 2
74185: EQUAL
74186: IFFALSE 74203
// bpoints := bpoints * 1.8 ;
74188: LD_ADDR_VAR 0 10
74192: PUSH
74193: LD_VAR 0 10
74197: PUSH
74198: LD_REAL  1.80000000000000E+0000
74201: MUL
74202: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
74203: LD_VAR 0 6
74207: PPUSH
74208: CALL_OW 257
74212: PUSH
74213: LD_INT 1
74215: PUSH
74216: LD_INT 2
74218: PUSH
74219: LD_INT 3
74221: PUSH
74222: LD_INT 4
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: LIST
74229: LIST
74230: IN
74231: PUSH
74232: LD_VAR 0 1
74236: PPUSH
74237: LD_INT 51
74239: PPUSH
74240: CALL_OW 321
74244: PUSH
74245: LD_INT 2
74247: EQUAL
74248: AND
74249: IFFALSE 74266
// bpoints := bpoints * 1.2 ;
74251: LD_ADDR_VAR 0 10
74255: PUSH
74256: LD_VAR 0 10
74260: PUSH
74261: LD_REAL  1.20000000000000E+0000
74264: MUL
74265: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
74266: LD_VAR 0 6
74270: PPUSH
74271: CALL_OW 257
74275: PUSH
74276: LD_INT 5
74278: PUSH
74279: LD_INT 7
74281: PUSH
74282: LD_INT 9
74284: PUSH
74285: EMPTY
74286: LIST
74287: LIST
74288: LIST
74289: IN
74290: PUSH
74291: LD_VAR 0 1
74295: PPUSH
74296: LD_INT 52
74298: PPUSH
74299: CALL_OW 321
74303: PUSH
74304: LD_INT 2
74306: EQUAL
74307: AND
74308: IFFALSE 74325
// bpoints := bpoints * 1.5 ;
74310: LD_ADDR_VAR 0 10
74314: PUSH
74315: LD_VAR 0 10
74319: PUSH
74320: LD_REAL  1.50000000000000E+0000
74323: MUL
74324: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
74325: LD_VAR 0 1
74329: PPUSH
74330: LD_INT 66
74332: PPUSH
74333: CALL_OW 321
74337: PUSH
74338: LD_INT 2
74340: EQUAL
74341: IFFALSE 74358
// bpoints := bpoints * 1.1 ;
74343: LD_ADDR_VAR 0 10
74347: PUSH
74348: LD_VAR 0 10
74352: PUSH
74353: LD_REAL  1.10000000000000E+0000
74356: MUL
74357: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
74358: LD_ADDR_VAR 0 10
74362: PUSH
74363: LD_VAR 0 10
74367: PUSH
74368: LD_VAR 0 6
74372: PPUSH
74373: LD_INT 1
74375: PPUSH
74376: CALL_OW 259
74380: PUSH
74381: LD_REAL  1.15000000000000E+0000
74384: MUL
74385: MUL
74386: ST_TO_ADDR
// end ; unit_vehicle :
74387: GO 75215
74389: LD_INT 2
74391: DOUBLE
74392: EQUAL
74393: IFTRUE 74397
74395: GO 75203
74397: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74398: LD_VAR 0 6
74402: PPUSH
74403: CALL_OW 264
74407: PUSH
74408: LD_INT 2
74410: PUSH
74411: LD_INT 42
74413: PUSH
74414: LD_INT 24
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: LIST
74421: IN
74422: IFFALSE 74443
// points := [ 25 , 5 , 3 ] ;
74424: LD_ADDR_VAR 0 9
74428: PUSH
74429: LD_INT 25
74431: PUSH
74432: LD_INT 5
74434: PUSH
74435: LD_INT 3
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: LIST
74442: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74443: LD_VAR 0 6
74447: PPUSH
74448: CALL_OW 264
74452: PUSH
74453: LD_INT 4
74455: PUSH
74456: LD_INT 43
74458: PUSH
74459: LD_INT 25
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: LIST
74466: IN
74467: IFFALSE 74488
// points := [ 40 , 15 , 5 ] ;
74469: LD_ADDR_VAR 0 9
74473: PUSH
74474: LD_INT 40
74476: PUSH
74477: LD_INT 15
74479: PUSH
74480: LD_INT 5
74482: PUSH
74483: EMPTY
74484: LIST
74485: LIST
74486: LIST
74487: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74488: LD_VAR 0 6
74492: PPUSH
74493: CALL_OW 264
74497: PUSH
74498: LD_INT 3
74500: PUSH
74501: LD_INT 23
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: IN
74508: IFFALSE 74529
// points := [ 7 , 25 , 8 ] ;
74510: LD_ADDR_VAR 0 9
74514: PUSH
74515: LD_INT 7
74517: PUSH
74518: LD_INT 25
74520: PUSH
74521: LD_INT 8
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: LIST
74528: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74529: LD_VAR 0 6
74533: PPUSH
74534: CALL_OW 264
74538: PUSH
74539: LD_INT 5
74541: PUSH
74542: LD_INT 27
74544: PUSH
74545: LD_INT 44
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: LIST
74552: IN
74553: IFFALSE 74574
// points := [ 14 , 50 , 16 ] ;
74555: LD_ADDR_VAR 0 9
74559: PUSH
74560: LD_INT 14
74562: PUSH
74563: LD_INT 50
74565: PUSH
74566: LD_INT 16
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74574: LD_VAR 0 6
74578: PPUSH
74579: CALL_OW 264
74583: PUSH
74584: LD_INT 6
74586: PUSH
74587: LD_INT 46
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: IN
74594: IFFALSE 74615
// points := [ 32 , 120 , 70 ] ;
74596: LD_ADDR_VAR 0 9
74600: PUSH
74601: LD_INT 32
74603: PUSH
74604: LD_INT 120
74606: PUSH
74607: LD_INT 70
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: LIST
74614: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74615: LD_VAR 0 6
74619: PPUSH
74620: CALL_OW 264
74624: PUSH
74625: LD_INT 7
74627: PUSH
74628: LD_INT 28
74630: PUSH
74631: LD_INT 45
74633: PUSH
74634: LD_INT 92
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: IN
74643: IFFALSE 74664
// points := [ 35 , 20 , 45 ] ;
74645: LD_ADDR_VAR 0 9
74649: PUSH
74650: LD_INT 35
74652: PUSH
74653: LD_INT 20
74655: PUSH
74656: LD_INT 45
74658: PUSH
74659: EMPTY
74660: LIST
74661: LIST
74662: LIST
74663: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74664: LD_VAR 0 6
74668: PPUSH
74669: CALL_OW 264
74673: PUSH
74674: LD_INT 47
74676: PUSH
74677: EMPTY
74678: LIST
74679: IN
74680: IFFALSE 74701
// points := [ 67 , 45 , 75 ] ;
74682: LD_ADDR_VAR 0 9
74686: PUSH
74687: LD_INT 67
74689: PUSH
74690: LD_INT 45
74692: PUSH
74693: LD_INT 75
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: LIST
74700: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74701: LD_VAR 0 6
74705: PPUSH
74706: CALL_OW 264
74710: PUSH
74711: LD_INT 26
74713: PUSH
74714: EMPTY
74715: LIST
74716: IN
74717: IFFALSE 74738
// points := [ 120 , 30 , 80 ] ;
74719: LD_ADDR_VAR 0 9
74723: PUSH
74724: LD_INT 120
74726: PUSH
74727: LD_INT 30
74729: PUSH
74730: LD_INT 80
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: LIST
74737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74738: LD_VAR 0 6
74742: PPUSH
74743: CALL_OW 264
74747: PUSH
74748: LD_INT 22
74750: PUSH
74751: EMPTY
74752: LIST
74753: IN
74754: IFFALSE 74775
// points := [ 40 , 1 , 1 ] ;
74756: LD_ADDR_VAR 0 9
74760: PUSH
74761: LD_INT 40
74763: PUSH
74764: LD_INT 1
74766: PUSH
74767: LD_INT 1
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: LIST
74774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74775: LD_VAR 0 6
74779: PPUSH
74780: CALL_OW 264
74784: PUSH
74785: LD_INT 29
74787: PUSH
74788: EMPTY
74789: LIST
74790: IN
74791: IFFALSE 74812
// points := [ 70 , 200 , 400 ] ;
74793: LD_ADDR_VAR 0 9
74797: PUSH
74798: LD_INT 70
74800: PUSH
74801: LD_INT 200
74803: PUSH
74804: LD_INT 400
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: LIST
74811: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74812: LD_VAR 0 6
74816: PPUSH
74817: CALL_OW 264
74821: PUSH
74822: LD_INT 14
74824: PUSH
74825: LD_INT 53
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: IN
74832: IFFALSE 74853
// points := [ 40 , 10 , 20 ] ;
74834: LD_ADDR_VAR 0 9
74838: PUSH
74839: LD_INT 40
74841: PUSH
74842: LD_INT 10
74844: PUSH
74845: LD_INT 20
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: LIST
74852: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74853: LD_VAR 0 6
74857: PPUSH
74858: CALL_OW 264
74862: PUSH
74863: LD_INT 9
74865: PUSH
74866: EMPTY
74867: LIST
74868: IN
74869: IFFALSE 74890
// points := [ 5 , 70 , 20 ] ;
74871: LD_ADDR_VAR 0 9
74875: PUSH
74876: LD_INT 5
74878: PUSH
74879: LD_INT 70
74881: PUSH
74882: LD_INT 20
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: LIST
74889: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74890: LD_VAR 0 6
74894: PPUSH
74895: CALL_OW 264
74899: PUSH
74900: LD_INT 10
74902: PUSH
74903: EMPTY
74904: LIST
74905: IN
74906: IFFALSE 74927
// points := [ 35 , 110 , 70 ] ;
74908: LD_ADDR_VAR 0 9
74912: PUSH
74913: LD_INT 35
74915: PUSH
74916: LD_INT 110
74918: PUSH
74919: LD_INT 70
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: LIST
74926: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74927: LD_VAR 0 6
74931: PPUSH
74932: CALL_OW 265
74936: PUSH
74937: LD_INT 25
74939: EQUAL
74940: IFFALSE 74961
// points := [ 80 , 65 , 100 ] ;
74942: LD_ADDR_VAR 0 9
74946: PUSH
74947: LD_INT 80
74949: PUSH
74950: LD_INT 65
74952: PUSH
74953: LD_INT 100
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: LIST
74960: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74961: LD_VAR 0 6
74965: PPUSH
74966: CALL_OW 263
74970: PUSH
74971: LD_INT 1
74973: EQUAL
74974: IFFALSE 75009
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74976: LD_ADDR_VAR 0 10
74980: PUSH
74981: LD_VAR 0 10
74985: PUSH
74986: LD_VAR 0 6
74990: PPUSH
74991: CALL_OW 311
74995: PPUSH
74996: LD_INT 3
74998: PPUSH
74999: CALL_OW 259
75003: PUSH
75004: LD_INT 4
75006: MUL
75007: MUL
75008: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
75009: LD_VAR 0 6
75013: PPUSH
75014: CALL_OW 263
75018: PUSH
75019: LD_INT 2
75021: EQUAL
75022: IFFALSE 75073
// begin j := IsControledBy ( i ) ;
75024: LD_ADDR_VAR 0 7
75028: PUSH
75029: LD_VAR 0 6
75033: PPUSH
75034: CALL_OW 312
75038: ST_TO_ADDR
// if j then
75039: LD_VAR 0 7
75043: IFFALSE 75073
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
75045: LD_ADDR_VAR 0 10
75049: PUSH
75050: LD_VAR 0 10
75054: PUSH
75055: LD_VAR 0 7
75059: PPUSH
75060: LD_INT 3
75062: PPUSH
75063: CALL_OW 259
75067: PUSH
75068: LD_INT 3
75070: MUL
75071: MUL
75072: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75073: LD_VAR 0 6
75077: PPUSH
75078: CALL_OW 264
75082: PUSH
75083: LD_INT 5
75085: PUSH
75086: LD_INT 6
75088: PUSH
75089: LD_INT 46
75091: PUSH
75092: LD_INT 44
75094: PUSH
75095: LD_INT 47
75097: PUSH
75098: LD_INT 45
75100: PUSH
75101: LD_INT 28
75103: PUSH
75104: LD_INT 7
75106: PUSH
75107: LD_INT 27
75109: PUSH
75110: LD_INT 29
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: LIST
75119: LIST
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: IN
75125: PUSH
75126: LD_VAR 0 1
75130: PPUSH
75131: LD_INT 52
75133: PPUSH
75134: CALL_OW 321
75138: PUSH
75139: LD_INT 2
75141: EQUAL
75142: AND
75143: IFFALSE 75160
// bpoints := bpoints * 1.2 ;
75145: LD_ADDR_VAR 0 10
75149: PUSH
75150: LD_VAR 0 10
75154: PUSH
75155: LD_REAL  1.20000000000000E+0000
75158: MUL
75159: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75160: LD_VAR 0 6
75164: PPUSH
75165: CALL_OW 264
75169: PUSH
75170: LD_INT 6
75172: PUSH
75173: LD_INT 46
75175: PUSH
75176: LD_INT 47
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: LIST
75183: IN
75184: IFFALSE 75201
// bpoints := bpoints * 1.2 ;
75186: LD_ADDR_VAR 0 10
75190: PUSH
75191: LD_VAR 0 10
75195: PUSH
75196: LD_REAL  1.20000000000000E+0000
75199: MUL
75200: ST_TO_ADDR
// end ; unit_building :
75201: GO 75215
75203: LD_INT 3
75205: DOUBLE
75206: EQUAL
75207: IFTRUE 75211
75209: GO 75214
75211: POP
// ; end ;
75212: GO 75215
75214: POP
// for j = 1 to 3 do
75215: LD_ADDR_VAR 0 7
75219: PUSH
75220: DOUBLE
75221: LD_INT 1
75223: DEC
75224: ST_TO_ADDR
75225: LD_INT 3
75227: PUSH
75228: FOR_TO
75229: IFFALSE 75282
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
75231: LD_ADDR_VAR 0 5
75235: PUSH
75236: LD_VAR 0 5
75240: PPUSH
75241: LD_VAR 0 7
75245: PPUSH
75246: LD_VAR 0 5
75250: PUSH
75251: LD_VAR 0 7
75255: ARRAY
75256: PUSH
75257: LD_VAR 0 9
75261: PUSH
75262: LD_VAR 0 7
75266: ARRAY
75267: PUSH
75268: LD_VAR 0 10
75272: MUL
75273: PLUS
75274: PPUSH
75275: CALL_OW 1
75279: ST_TO_ADDR
75280: GO 75228
75282: POP
75283: POP
// end ;
75284: GO 73763
75286: POP
75287: POP
// result := Replace ( result , 4 , tmp ) ;
75288: LD_ADDR_VAR 0 5
75292: PUSH
75293: LD_VAR 0 5
75297: PPUSH
75298: LD_INT 4
75300: PPUSH
75301: LD_VAR 0 8
75305: PPUSH
75306: CALL_OW 1
75310: ST_TO_ADDR
// end ;
75311: LD_VAR 0 5
75315: RET
// export function DangerAtRange ( unit , range ) ; begin
75316: LD_INT 0
75318: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
75319: LD_ADDR_VAR 0 3
75323: PUSH
75324: LD_VAR 0 1
75328: PPUSH
75329: CALL_OW 255
75333: PPUSH
75334: LD_VAR 0 1
75338: PPUSH
75339: CALL_OW 250
75343: PPUSH
75344: LD_VAR 0 1
75348: PPUSH
75349: CALL_OW 251
75353: PPUSH
75354: LD_VAR 0 2
75358: PPUSH
75359: CALL 73615 0 4
75363: ST_TO_ADDR
// end ;
75364: LD_VAR 0 3
75368: RET
// export function DangerInArea ( side , area ) ; begin
75369: LD_INT 0
75371: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
75372: LD_ADDR_VAR 0 3
75376: PUSH
75377: LD_VAR 0 2
75381: PPUSH
75382: LD_INT 81
75384: PUSH
75385: LD_VAR 0 1
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PPUSH
75394: CALL_OW 70
75398: ST_TO_ADDR
// end ;
75399: LD_VAR 0 3
75403: RET
// export function IsExtension ( b ) ; begin
75404: LD_INT 0
75406: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75407: LD_ADDR_VAR 0 2
75411: PUSH
75412: LD_VAR 0 1
75416: PUSH
75417: LD_INT 23
75419: PUSH
75420: LD_INT 20
75422: PUSH
75423: LD_INT 22
75425: PUSH
75426: LD_INT 17
75428: PUSH
75429: LD_INT 24
75431: PUSH
75432: LD_INT 21
75434: PUSH
75435: LD_INT 19
75437: PUSH
75438: LD_INT 16
75440: PUSH
75441: LD_INT 25
75443: PUSH
75444: LD_INT 18
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: IN
75459: ST_TO_ADDR
// end ;
75460: LD_VAR 0 2
75464: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75465: LD_INT 0
75467: PPUSH
75468: PPUSH
75469: PPUSH
// result := [ ] ;
75470: LD_ADDR_VAR 0 4
75474: PUSH
75475: EMPTY
75476: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75477: LD_ADDR_VAR 0 5
75481: PUSH
75482: LD_VAR 0 2
75486: PPUSH
75487: LD_INT 21
75489: PUSH
75490: LD_INT 3
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PPUSH
75497: CALL_OW 70
75501: ST_TO_ADDR
// if not tmp then
75502: LD_VAR 0 5
75506: NOT
75507: IFFALSE 75511
// exit ;
75509: GO 75575
// if checkLink then
75511: LD_VAR 0 3
75515: IFFALSE 75565
// begin for i in tmp do
75517: LD_ADDR_VAR 0 6
75521: PUSH
75522: LD_VAR 0 5
75526: PUSH
75527: FOR_IN
75528: IFFALSE 75563
// if GetBase ( i ) <> base then
75530: LD_VAR 0 6
75534: PPUSH
75535: CALL_OW 274
75539: PUSH
75540: LD_VAR 0 1
75544: NONEQUAL
75545: IFFALSE 75561
// ComLinkToBase ( base , i ) ;
75547: LD_VAR 0 1
75551: PPUSH
75552: LD_VAR 0 6
75556: PPUSH
75557: CALL_OW 169
75561: GO 75527
75563: POP
75564: POP
// end ; result := tmp ;
75565: LD_ADDR_VAR 0 4
75569: PUSH
75570: LD_VAR 0 5
75574: ST_TO_ADDR
// end ;
75575: LD_VAR 0 4
75579: RET
// export function ComComplete ( units , b ) ; var i ; begin
75580: LD_INT 0
75582: PPUSH
75583: PPUSH
// if not units then
75584: LD_VAR 0 1
75588: NOT
75589: IFFALSE 75593
// exit ;
75591: GO 75683
// for i in units do
75593: LD_ADDR_VAR 0 4
75597: PUSH
75598: LD_VAR 0 1
75602: PUSH
75603: FOR_IN
75604: IFFALSE 75681
// if BuildingStatus ( b ) = bs_build then
75606: LD_VAR 0 2
75610: PPUSH
75611: CALL_OW 461
75615: PUSH
75616: LD_INT 1
75618: EQUAL
75619: IFFALSE 75679
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75621: LD_VAR 0 4
75625: PPUSH
75626: LD_STRING h
75628: PUSH
75629: LD_VAR 0 2
75633: PPUSH
75634: CALL_OW 250
75638: PUSH
75639: LD_VAR 0 2
75643: PPUSH
75644: CALL_OW 251
75648: PUSH
75649: LD_VAR 0 2
75653: PUSH
75654: LD_INT 0
75656: PUSH
75657: LD_INT 0
75659: PUSH
75660: LD_INT 0
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: LIST
75667: LIST
75668: LIST
75669: LIST
75670: LIST
75671: PUSH
75672: EMPTY
75673: LIST
75674: PPUSH
75675: CALL_OW 446
75679: GO 75603
75681: POP
75682: POP
// end ;
75683: LD_VAR 0 3
75687: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75688: LD_INT 0
75690: PPUSH
75691: PPUSH
75692: PPUSH
75693: PPUSH
75694: PPUSH
75695: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75696: LD_VAR 0 1
75700: NOT
75701: PUSH
75702: LD_VAR 0 1
75706: PPUSH
75707: CALL_OW 263
75711: PUSH
75712: LD_INT 2
75714: NONEQUAL
75715: OR
75716: IFFALSE 75720
// exit ;
75718: GO 76036
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75720: LD_ADDR_VAR 0 6
75724: PUSH
75725: LD_INT 22
75727: PUSH
75728: LD_VAR 0 1
75732: PPUSH
75733: CALL_OW 255
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 2
75744: PUSH
75745: LD_INT 30
75747: PUSH
75748: LD_INT 36
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 34
75757: PUSH
75758: LD_INT 31
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: EMPTY
75766: LIST
75767: LIST
75768: LIST
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PPUSH
75774: CALL_OW 69
75778: ST_TO_ADDR
// if not tmp then
75779: LD_VAR 0 6
75783: NOT
75784: IFFALSE 75788
// exit ;
75786: GO 76036
// result := [ ] ;
75788: LD_ADDR_VAR 0 2
75792: PUSH
75793: EMPTY
75794: ST_TO_ADDR
// for i in tmp do
75795: LD_ADDR_VAR 0 3
75799: PUSH
75800: LD_VAR 0 6
75804: PUSH
75805: FOR_IN
75806: IFFALSE 75877
// begin t := UnitsInside ( i ) ;
75808: LD_ADDR_VAR 0 4
75812: PUSH
75813: LD_VAR 0 3
75817: PPUSH
75818: CALL_OW 313
75822: ST_TO_ADDR
// if t then
75823: LD_VAR 0 4
75827: IFFALSE 75875
// for j in t do
75829: LD_ADDR_VAR 0 7
75833: PUSH
75834: LD_VAR 0 4
75838: PUSH
75839: FOR_IN
75840: IFFALSE 75873
// result := Replace ( result , result + 1 , j ) ;
75842: LD_ADDR_VAR 0 2
75846: PUSH
75847: LD_VAR 0 2
75851: PPUSH
75852: LD_VAR 0 2
75856: PUSH
75857: LD_INT 1
75859: PLUS
75860: PPUSH
75861: LD_VAR 0 7
75865: PPUSH
75866: CALL_OW 1
75870: ST_TO_ADDR
75871: GO 75839
75873: POP
75874: POP
// end ;
75875: GO 75805
75877: POP
75878: POP
// if not result then
75879: LD_VAR 0 2
75883: NOT
75884: IFFALSE 75888
// exit ;
75886: GO 76036
// mech := result [ 1 ] ;
75888: LD_ADDR_VAR 0 5
75892: PUSH
75893: LD_VAR 0 2
75897: PUSH
75898: LD_INT 1
75900: ARRAY
75901: ST_TO_ADDR
// if result > 1 then
75902: LD_VAR 0 2
75906: PUSH
75907: LD_INT 1
75909: GREATER
75910: IFFALSE 76022
// begin for i = 2 to result do
75912: LD_ADDR_VAR 0 3
75916: PUSH
75917: DOUBLE
75918: LD_INT 2
75920: DEC
75921: ST_TO_ADDR
75922: LD_VAR 0 2
75926: PUSH
75927: FOR_TO
75928: IFFALSE 76020
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75930: LD_ADDR_VAR 0 4
75934: PUSH
75935: LD_VAR 0 2
75939: PUSH
75940: LD_VAR 0 3
75944: ARRAY
75945: PPUSH
75946: LD_INT 3
75948: PPUSH
75949: CALL_OW 259
75953: PUSH
75954: LD_VAR 0 2
75958: PUSH
75959: LD_VAR 0 3
75963: ARRAY
75964: PPUSH
75965: CALL_OW 432
75969: MINUS
75970: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75971: LD_VAR 0 4
75975: PUSH
75976: LD_VAR 0 5
75980: PPUSH
75981: LD_INT 3
75983: PPUSH
75984: CALL_OW 259
75988: PUSH
75989: LD_VAR 0 5
75993: PPUSH
75994: CALL_OW 432
75998: MINUS
75999: GREATEREQUAL
76000: IFFALSE 76018
// mech := result [ i ] ;
76002: LD_ADDR_VAR 0 5
76006: PUSH
76007: LD_VAR 0 2
76011: PUSH
76012: LD_VAR 0 3
76016: ARRAY
76017: ST_TO_ADDR
// end ;
76018: GO 75927
76020: POP
76021: POP
// end ; ComLinkTo ( vehicle , mech ) ;
76022: LD_VAR 0 1
76026: PPUSH
76027: LD_VAR 0 5
76031: PPUSH
76032: CALL_OW 135
// end ;
76036: LD_VAR 0 2
76040: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
76041: LD_INT 0
76043: PPUSH
76044: PPUSH
76045: PPUSH
76046: PPUSH
76047: PPUSH
76048: PPUSH
76049: PPUSH
76050: PPUSH
76051: PPUSH
76052: PPUSH
76053: PPUSH
76054: PPUSH
76055: PPUSH
// result := [ ] ;
76056: LD_ADDR_VAR 0 7
76060: PUSH
76061: EMPTY
76062: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
76063: LD_VAR 0 1
76067: PPUSH
76068: CALL_OW 266
76072: PUSH
76073: LD_INT 0
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: IN
76083: NOT
76084: IFFALSE 76088
// exit ;
76086: GO 77722
// if name then
76088: LD_VAR 0 3
76092: IFFALSE 76108
// SetBName ( base_dep , name ) ;
76094: LD_VAR 0 1
76098: PPUSH
76099: LD_VAR 0 3
76103: PPUSH
76104: CALL_OW 500
// base := GetBase ( base_dep ) ;
76108: LD_ADDR_VAR 0 15
76112: PUSH
76113: LD_VAR 0 1
76117: PPUSH
76118: CALL_OW 274
76122: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76123: LD_ADDR_VAR 0 16
76127: PUSH
76128: LD_VAR 0 1
76132: PPUSH
76133: CALL_OW 255
76137: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76138: LD_ADDR_VAR 0 17
76142: PUSH
76143: LD_VAR 0 1
76147: PPUSH
76148: CALL_OW 248
76152: ST_TO_ADDR
// if sources then
76153: LD_VAR 0 5
76157: IFFALSE 76204
// for i = 1 to 3 do
76159: LD_ADDR_VAR 0 8
76163: PUSH
76164: DOUBLE
76165: LD_INT 1
76167: DEC
76168: ST_TO_ADDR
76169: LD_INT 3
76171: PUSH
76172: FOR_TO
76173: IFFALSE 76202
// AddResourceType ( base , i , sources [ i ] ) ;
76175: LD_VAR 0 15
76179: PPUSH
76180: LD_VAR 0 8
76184: PPUSH
76185: LD_VAR 0 5
76189: PUSH
76190: LD_VAR 0 8
76194: ARRAY
76195: PPUSH
76196: CALL_OW 276
76200: GO 76172
76202: POP
76203: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
76204: LD_ADDR_VAR 0 18
76208: PUSH
76209: LD_VAR 0 15
76213: PPUSH
76214: LD_VAR 0 2
76218: PPUSH
76219: LD_INT 1
76221: PPUSH
76222: CALL 75465 0 3
76226: ST_TO_ADDR
// InitHc ;
76227: CALL_OW 19
// InitUc ;
76231: CALL_OW 18
// uc_side := side ;
76235: LD_ADDR_OWVAR 20
76239: PUSH
76240: LD_VAR 0 16
76244: ST_TO_ADDR
// uc_nation := nation ;
76245: LD_ADDR_OWVAR 21
76249: PUSH
76250: LD_VAR 0 17
76254: ST_TO_ADDR
// if buildings then
76255: LD_VAR 0 18
76259: IFFALSE 77581
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
76261: LD_ADDR_VAR 0 19
76265: PUSH
76266: LD_VAR 0 18
76270: PPUSH
76271: LD_INT 2
76273: PUSH
76274: LD_INT 30
76276: PUSH
76277: LD_INT 29
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 30
76286: PUSH
76287: LD_INT 30
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: LIST
76298: PPUSH
76299: CALL_OW 72
76303: ST_TO_ADDR
// if tmp then
76304: LD_VAR 0 19
76308: IFFALSE 76356
// for i in tmp do
76310: LD_ADDR_VAR 0 8
76314: PUSH
76315: LD_VAR 0 19
76319: PUSH
76320: FOR_IN
76321: IFFALSE 76354
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
76323: LD_VAR 0 8
76327: PPUSH
76328: CALL_OW 250
76332: PPUSH
76333: LD_VAR 0 8
76337: PPUSH
76338: CALL_OW 251
76342: PPUSH
76343: LD_VAR 0 16
76347: PPUSH
76348: CALL_OW 441
76352: GO 76320
76354: POP
76355: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
76356: LD_VAR 0 18
76360: PPUSH
76361: LD_INT 2
76363: PUSH
76364: LD_INT 30
76366: PUSH
76367: LD_INT 32
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: LD_INT 30
76376: PUSH
76377: LD_INT 33
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: LIST
76388: PPUSH
76389: CALL_OW 72
76393: IFFALSE 76481
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76395: LD_ADDR_VAR 0 8
76399: PUSH
76400: LD_VAR 0 18
76404: PPUSH
76405: LD_INT 2
76407: PUSH
76408: LD_INT 30
76410: PUSH
76411: LD_INT 32
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 30
76420: PUSH
76421: LD_INT 33
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: LIST
76432: PPUSH
76433: CALL_OW 72
76437: PUSH
76438: FOR_IN
76439: IFFALSE 76479
// begin if not GetBWeapon ( i ) then
76441: LD_VAR 0 8
76445: PPUSH
76446: CALL_OW 269
76450: NOT
76451: IFFALSE 76477
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76453: LD_VAR 0 8
76457: PPUSH
76458: LD_VAR 0 8
76462: PPUSH
76463: LD_VAR 0 2
76467: PPUSH
76468: CALL 77727 0 2
76472: PPUSH
76473: CALL_OW 431
// end ;
76477: GO 76438
76479: POP
76480: POP
// end ; for i = 1 to personel do
76481: LD_ADDR_VAR 0 8
76485: PUSH
76486: DOUBLE
76487: LD_INT 1
76489: DEC
76490: ST_TO_ADDR
76491: LD_VAR 0 6
76495: PUSH
76496: FOR_TO
76497: IFFALSE 77561
// begin if i > 4 then
76499: LD_VAR 0 8
76503: PUSH
76504: LD_INT 4
76506: GREATER
76507: IFFALSE 76511
// break ;
76509: GO 77561
// case i of 1 :
76511: LD_VAR 0 8
76515: PUSH
76516: LD_INT 1
76518: DOUBLE
76519: EQUAL
76520: IFTRUE 76524
76522: GO 76604
76524: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76525: LD_ADDR_VAR 0 12
76529: PUSH
76530: LD_VAR 0 18
76534: PPUSH
76535: LD_INT 22
76537: PUSH
76538: LD_VAR 0 16
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 58
76549: PUSH
76550: EMPTY
76551: LIST
76552: PUSH
76553: LD_INT 2
76555: PUSH
76556: LD_INT 30
76558: PUSH
76559: LD_INT 32
76561: PUSH
76562: EMPTY
76563: LIST
76564: LIST
76565: PUSH
76566: LD_INT 30
76568: PUSH
76569: LD_INT 4
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 30
76578: PUSH
76579: LD_INT 5
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: LIST
76590: LIST
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: LIST
76596: PPUSH
76597: CALL_OW 72
76601: ST_TO_ADDR
76602: GO 76826
76604: LD_INT 2
76606: DOUBLE
76607: EQUAL
76608: IFTRUE 76612
76610: GO 76674
76612: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76613: LD_ADDR_VAR 0 12
76617: PUSH
76618: LD_VAR 0 18
76622: PPUSH
76623: LD_INT 22
76625: PUSH
76626: LD_VAR 0 16
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: PUSH
76638: LD_INT 30
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: PUSH
76648: LD_INT 30
76650: PUSH
76651: LD_INT 1
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: LIST
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PPUSH
76667: CALL_OW 72
76671: ST_TO_ADDR
76672: GO 76826
76674: LD_INT 3
76676: DOUBLE
76677: EQUAL
76678: IFTRUE 76682
76680: GO 76744
76682: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76683: LD_ADDR_VAR 0 12
76687: PUSH
76688: LD_VAR 0 18
76692: PPUSH
76693: LD_INT 22
76695: PUSH
76696: LD_VAR 0 16
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 2
76707: PUSH
76708: LD_INT 30
76710: PUSH
76711: LD_INT 2
76713: PUSH
76714: EMPTY
76715: LIST
76716: LIST
76717: PUSH
76718: LD_INT 30
76720: PUSH
76721: LD_INT 3
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: LIST
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PPUSH
76737: CALL_OW 72
76741: ST_TO_ADDR
76742: GO 76826
76744: LD_INT 4
76746: DOUBLE
76747: EQUAL
76748: IFTRUE 76752
76750: GO 76825
76752: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76753: LD_ADDR_VAR 0 12
76757: PUSH
76758: LD_VAR 0 18
76762: PPUSH
76763: LD_INT 22
76765: PUSH
76766: LD_VAR 0 16
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 2
76777: PUSH
76778: LD_INT 30
76780: PUSH
76781: LD_INT 6
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 30
76790: PUSH
76791: LD_INT 7
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 30
76800: PUSH
76801: LD_INT 8
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: LIST
76812: LIST
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PPUSH
76818: CALL_OW 72
76822: ST_TO_ADDR
76823: GO 76826
76825: POP
// if i = 1 then
76826: LD_VAR 0 8
76830: PUSH
76831: LD_INT 1
76833: EQUAL
76834: IFFALSE 76945
// begin tmp := [ ] ;
76836: LD_ADDR_VAR 0 19
76840: PUSH
76841: EMPTY
76842: ST_TO_ADDR
// for j in f do
76843: LD_ADDR_VAR 0 9
76847: PUSH
76848: LD_VAR 0 12
76852: PUSH
76853: FOR_IN
76854: IFFALSE 76927
// if GetBType ( j ) = b_bunker then
76856: LD_VAR 0 9
76860: PPUSH
76861: CALL_OW 266
76865: PUSH
76866: LD_INT 32
76868: EQUAL
76869: IFFALSE 76896
// tmp := Insert ( tmp , 1 , j ) else
76871: LD_ADDR_VAR 0 19
76875: PUSH
76876: LD_VAR 0 19
76880: PPUSH
76881: LD_INT 1
76883: PPUSH
76884: LD_VAR 0 9
76888: PPUSH
76889: CALL_OW 2
76893: ST_TO_ADDR
76894: GO 76925
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76896: LD_ADDR_VAR 0 19
76900: PUSH
76901: LD_VAR 0 19
76905: PPUSH
76906: LD_VAR 0 19
76910: PUSH
76911: LD_INT 1
76913: PLUS
76914: PPUSH
76915: LD_VAR 0 9
76919: PPUSH
76920: CALL_OW 2
76924: ST_TO_ADDR
76925: GO 76853
76927: POP
76928: POP
// if tmp then
76929: LD_VAR 0 19
76933: IFFALSE 76945
// f := tmp ;
76935: LD_ADDR_VAR 0 12
76939: PUSH
76940: LD_VAR 0 19
76944: ST_TO_ADDR
// end ; x := personel [ i ] ;
76945: LD_ADDR_VAR 0 13
76949: PUSH
76950: LD_VAR 0 6
76954: PUSH
76955: LD_VAR 0 8
76959: ARRAY
76960: ST_TO_ADDR
// if x = - 1 then
76961: LD_VAR 0 13
76965: PUSH
76966: LD_INT 1
76968: NEG
76969: EQUAL
76970: IFFALSE 77179
// begin for j in f do
76972: LD_ADDR_VAR 0 9
76976: PUSH
76977: LD_VAR 0 12
76981: PUSH
76982: FOR_IN
76983: IFFALSE 77175
// repeat InitHc ;
76985: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76989: LD_VAR 0 9
76993: PPUSH
76994: CALL_OW 266
76998: PUSH
76999: LD_INT 5
77001: EQUAL
77002: IFFALSE 77072
// begin if UnitsInside ( j ) < 3 then
77004: LD_VAR 0 9
77008: PPUSH
77009: CALL_OW 313
77013: PUSH
77014: LD_INT 3
77016: LESS
77017: IFFALSE 77053
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77019: LD_INT 0
77021: PPUSH
77022: LD_INT 5
77024: PUSH
77025: LD_INT 8
77027: PUSH
77028: LD_INT 9
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: LIST
77035: PUSH
77036: LD_VAR 0 17
77040: ARRAY
77041: PPUSH
77042: LD_VAR 0 4
77046: PPUSH
77047: CALL_OW 380
77051: GO 77070
// PrepareHuman ( false , i , skill ) ;
77053: LD_INT 0
77055: PPUSH
77056: LD_VAR 0 8
77060: PPUSH
77061: LD_VAR 0 4
77065: PPUSH
77066: CALL_OW 380
// end else
77070: GO 77089
// PrepareHuman ( false , i , skill ) ;
77072: LD_INT 0
77074: PPUSH
77075: LD_VAR 0 8
77079: PPUSH
77080: LD_VAR 0 4
77084: PPUSH
77085: CALL_OW 380
// un := CreateHuman ;
77089: LD_ADDR_VAR 0 14
77093: PUSH
77094: CALL_OW 44
77098: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77099: LD_ADDR_VAR 0 7
77103: PUSH
77104: LD_VAR 0 7
77108: PPUSH
77109: LD_INT 1
77111: PPUSH
77112: LD_VAR 0 14
77116: PPUSH
77117: CALL_OW 2
77121: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77122: LD_VAR 0 14
77126: PPUSH
77127: LD_VAR 0 9
77131: PPUSH
77132: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77136: LD_VAR 0 9
77140: PPUSH
77141: CALL_OW 313
77145: PUSH
77146: LD_INT 6
77148: EQUAL
77149: PUSH
77150: LD_VAR 0 9
77154: PPUSH
77155: CALL_OW 266
77159: PUSH
77160: LD_INT 32
77162: PUSH
77163: LD_INT 31
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: IN
77170: OR
77171: IFFALSE 76985
77173: GO 76982
77175: POP
77176: POP
// end else
77177: GO 77559
// for j = 1 to x do
77179: LD_ADDR_VAR 0 9
77183: PUSH
77184: DOUBLE
77185: LD_INT 1
77187: DEC
77188: ST_TO_ADDR
77189: LD_VAR 0 13
77193: PUSH
77194: FOR_TO
77195: IFFALSE 77557
// begin InitHc ;
77197: CALL_OW 19
// if not f then
77201: LD_VAR 0 12
77205: NOT
77206: IFFALSE 77295
// begin PrepareHuman ( false , i , skill ) ;
77208: LD_INT 0
77210: PPUSH
77211: LD_VAR 0 8
77215: PPUSH
77216: LD_VAR 0 4
77220: PPUSH
77221: CALL_OW 380
// un := CreateHuman ;
77225: LD_ADDR_VAR 0 14
77229: PUSH
77230: CALL_OW 44
77234: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77235: LD_ADDR_VAR 0 7
77239: PUSH
77240: LD_VAR 0 7
77244: PPUSH
77245: LD_INT 1
77247: PPUSH
77248: LD_VAR 0 14
77252: PPUSH
77253: CALL_OW 2
77257: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77258: LD_VAR 0 14
77262: PPUSH
77263: LD_VAR 0 1
77267: PPUSH
77268: CALL_OW 250
77272: PPUSH
77273: LD_VAR 0 1
77277: PPUSH
77278: CALL_OW 251
77282: PPUSH
77283: LD_INT 10
77285: PPUSH
77286: LD_INT 0
77288: PPUSH
77289: CALL_OW 50
// continue ;
77293: GO 77194
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
77295: LD_VAR 0 12
77299: PUSH
77300: LD_INT 1
77302: ARRAY
77303: PPUSH
77304: CALL_OW 313
77308: PUSH
77309: LD_VAR 0 12
77313: PUSH
77314: LD_INT 1
77316: ARRAY
77317: PPUSH
77318: CALL_OW 266
77322: PUSH
77323: LD_INT 32
77325: PUSH
77326: LD_INT 31
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: IN
77333: AND
77334: PUSH
77335: LD_VAR 0 12
77339: PUSH
77340: LD_INT 1
77342: ARRAY
77343: PPUSH
77344: CALL_OW 313
77348: PUSH
77349: LD_INT 6
77351: EQUAL
77352: OR
77353: IFFALSE 77373
// f := Delete ( f , 1 ) ;
77355: LD_ADDR_VAR 0 12
77359: PUSH
77360: LD_VAR 0 12
77364: PPUSH
77365: LD_INT 1
77367: PPUSH
77368: CALL_OW 3
77372: ST_TO_ADDR
// if not f then
77373: LD_VAR 0 12
77377: NOT
77378: IFFALSE 77396
// begin x := x + 2 ;
77380: LD_ADDR_VAR 0 13
77384: PUSH
77385: LD_VAR 0 13
77389: PUSH
77390: LD_INT 2
77392: PLUS
77393: ST_TO_ADDR
// continue ;
77394: GO 77194
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77396: LD_VAR 0 12
77400: PUSH
77401: LD_INT 1
77403: ARRAY
77404: PPUSH
77405: CALL_OW 266
77409: PUSH
77410: LD_INT 5
77412: EQUAL
77413: IFFALSE 77487
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77415: LD_VAR 0 12
77419: PUSH
77420: LD_INT 1
77422: ARRAY
77423: PPUSH
77424: CALL_OW 313
77428: PUSH
77429: LD_INT 3
77431: LESS
77432: IFFALSE 77468
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77434: LD_INT 0
77436: PPUSH
77437: LD_INT 5
77439: PUSH
77440: LD_INT 8
77442: PUSH
77443: LD_INT 9
77445: PUSH
77446: EMPTY
77447: LIST
77448: LIST
77449: LIST
77450: PUSH
77451: LD_VAR 0 17
77455: ARRAY
77456: PPUSH
77457: LD_VAR 0 4
77461: PPUSH
77462: CALL_OW 380
77466: GO 77485
// PrepareHuman ( false , i , skill ) ;
77468: LD_INT 0
77470: PPUSH
77471: LD_VAR 0 8
77475: PPUSH
77476: LD_VAR 0 4
77480: PPUSH
77481: CALL_OW 380
// end else
77485: GO 77504
// PrepareHuman ( false , i , skill ) ;
77487: LD_INT 0
77489: PPUSH
77490: LD_VAR 0 8
77494: PPUSH
77495: LD_VAR 0 4
77499: PPUSH
77500: CALL_OW 380
// un := CreateHuman ;
77504: LD_ADDR_VAR 0 14
77508: PUSH
77509: CALL_OW 44
77513: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77514: LD_ADDR_VAR 0 7
77518: PUSH
77519: LD_VAR 0 7
77523: PPUSH
77524: LD_INT 1
77526: PPUSH
77527: LD_VAR 0 14
77531: PPUSH
77532: CALL_OW 2
77536: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77537: LD_VAR 0 14
77541: PPUSH
77542: LD_VAR 0 12
77546: PUSH
77547: LD_INT 1
77549: ARRAY
77550: PPUSH
77551: CALL_OW 52
// end ;
77555: GO 77194
77557: POP
77558: POP
// end ;
77559: GO 76496
77561: POP
77562: POP
// result := result ^ buildings ;
77563: LD_ADDR_VAR 0 7
77567: PUSH
77568: LD_VAR 0 7
77572: PUSH
77573: LD_VAR 0 18
77577: ADD
77578: ST_TO_ADDR
// end else
77579: GO 77722
// begin for i = 1 to personel do
77581: LD_ADDR_VAR 0 8
77585: PUSH
77586: DOUBLE
77587: LD_INT 1
77589: DEC
77590: ST_TO_ADDR
77591: LD_VAR 0 6
77595: PUSH
77596: FOR_TO
77597: IFFALSE 77720
// begin if i > 4 then
77599: LD_VAR 0 8
77603: PUSH
77604: LD_INT 4
77606: GREATER
77607: IFFALSE 77611
// break ;
77609: GO 77720
// x := personel [ i ] ;
77611: LD_ADDR_VAR 0 13
77615: PUSH
77616: LD_VAR 0 6
77620: PUSH
77621: LD_VAR 0 8
77625: ARRAY
77626: ST_TO_ADDR
// if x = - 1 then
77627: LD_VAR 0 13
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: EQUAL
77636: IFFALSE 77640
// continue ;
77638: GO 77596
// PrepareHuman ( false , i , skill ) ;
77640: LD_INT 0
77642: PPUSH
77643: LD_VAR 0 8
77647: PPUSH
77648: LD_VAR 0 4
77652: PPUSH
77653: CALL_OW 380
// un := CreateHuman ;
77657: LD_ADDR_VAR 0 14
77661: PUSH
77662: CALL_OW 44
77666: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77667: LD_VAR 0 14
77671: PPUSH
77672: LD_VAR 0 1
77676: PPUSH
77677: CALL_OW 250
77681: PPUSH
77682: LD_VAR 0 1
77686: PPUSH
77687: CALL_OW 251
77691: PPUSH
77692: LD_INT 10
77694: PPUSH
77695: LD_INT 0
77697: PPUSH
77698: CALL_OW 50
// result := result ^ un ;
77702: LD_ADDR_VAR 0 7
77706: PUSH
77707: LD_VAR 0 7
77711: PUSH
77712: LD_VAR 0 14
77716: ADD
77717: ST_TO_ADDR
// end ;
77718: GO 77596
77720: POP
77721: POP
// end ; end ;
77722: LD_VAR 0 7
77726: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77727: LD_INT 0
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
77736: PPUSH
77737: PPUSH
77738: PPUSH
77739: PPUSH
77740: PPUSH
77741: PPUSH
77742: PPUSH
77743: PPUSH
77744: PPUSH
// result := false ;
77745: LD_ADDR_VAR 0 3
77749: PUSH
77750: LD_INT 0
77752: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77753: LD_VAR 0 1
77757: NOT
77758: PUSH
77759: LD_VAR 0 1
77763: PPUSH
77764: CALL_OW 266
77768: PUSH
77769: LD_INT 32
77771: PUSH
77772: LD_INT 33
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: IN
77779: NOT
77780: OR
77781: IFFALSE 77785
// exit ;
77783: GO 78894
// nat := GetNation ( tower ) ;
77785: LD_ADDR_VAR 0 12
77789: PUSH
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 248
77799: ST_TO_ADDR
// side := GetSide ( tower ) ;
77800: LD_ADDR_VAR 0 16
77804: PUSH
77805: LD_VAR 0 1
77809: PPUSH
77810: CALL_OW 255
77814: ST_TO_ADDR
// x := GetX ( tower ) ;
77815: LD_ADDR_VAR 0 10
77819: PUSH
77820: LD_VAR 0 1
77824: PPUSH
77825: CALL_OW 250
77829: ST_TO_ADDR
// y := GetY ( tower ) ;
77830: LD_ADDR_VAR 0 11
77834: PUSH
77835: LD_VAR 0 1
77839: PPUSH
77840: CALL_OW 251
77844: ST_TO_ADDR
// if not x or not y then
77845: LD_VAR 0 10
77849: NOT
77850: PUSH
77851: LD_VAR 0 11
77855: NOT
77856: OR
77857: IFFALSE 77861
// exit ;
77859: GO 78894
// weapon := 0 ;
77861: LD_ADDR_VAR 0 18
77865: PUSH
77866: LD_INT 0
77868: ST_TO_ADDR
// fac_list := [ ] ;
77869: LD_ADDR_VAR 0 17
77873: PUSH
77874: EMPTY
77875: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77876: LD_ADDR_VAR 0 6
77880: PUSH
77881: LD_VAR 0 1
77885: PPUSH
77886: CALL_OW 274
77890: PPUSH
77891: LD_VAR 0 2
77895: PPUSH
77896: LD_INT 0
77898: PPUSH
77899: CALL 75465 0 3
77903: PPUSH
77904: LD_INT 30
77906: PUSH
77907: LD_INT 3
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PPUSH
77914: CALL_OW 72
77918: ST_TO_ADDR
// if not factories then
77919: LD_VAR 0 6
77923: NOT
77924: IFFALSE 77928
// exit ;
77926: GO 78894
// for i in factories do
77928: LD_ADDR_VAR 0 8
77932: PUSH
77933: LD_VAR 0 6
77937: PUSH
77938: FOR_IN
77939: IFFALSE 77964
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77941: LD_ADDR_VAR 0 17
77945: PUSH
77946: LD_VAR 0 17
77950: PUSH
77951: LD_VAR 0 8
77955: PPUSH
77956: CALL_OW 478
77960: UNION
77961: ST_TO_ADDR
77962: GO 77938
77964: POP
77965: POP
// if not fac_list then
77966: LD_VAR 0 17
77970: NOT
77971: IFFALSE 77975
// exit ;
77973: GO 78894
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77975: LD_ADDR_VAR 0 5
77979: PUSH
77980: LD_INT 4
77982: PUSH
77983: LD_INT 5
77985: PUSH
77986: LD_INT 9
77988: PUSH
77989: LD_INT 10
77991: PUSH
77992: LD_INT 6
77994: PUSH
77995: LD_INT 7
77997: PUSH
77998: LD_INT 11
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 27
78012: PUSH
78013: LD_INT 28
78015: PUSH
78016: LD_INT 26
78018: PUSH
78019: LD_INT 30
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 43
78030: PUSH
78031: LD_INT 44
78033: PUSH
78034: LD_INT 46
78036: PUSH
78037: LD_INT 45
78039: PUSH
78040: LD_INT 47
78042: PUSH
78043: LD_INT 49
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: LIST
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: LIST
78058: PUSH
78059: LD_VAR 0 12
78063: ARRAY
78064: ST_TO_ADDR
// list := list isect fac_list ;
78065: LD_ADDR_VAR 0 5
78069: PUSH
78070: LD_VAR 0 5
78074: PUSH
78075: LD_VAR 0 17
78079: ISECT
78080: ST_TO_ADDR
// if not list then
78081: LD_VAR 0 5
78085: NOT
78086: IFFALSE 78090
// exit ;
78088: GO 78894
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78090: LD_VAR 0 12
78094: PUSH
78095: LD_INT 3
78097: EQUAL
78098: PUSH
78099: LD_INT 49
78101: PUSH
78102: LD_VAR 0 5
78106: IN
78107: AND
78108: PUSH
78109: LD_INT 31
78111: PPUSH
78112: LD_VAR 0 16
78116: PPUSH
78117: CALL_OW 321
78121: PUSH
78122: LD_INT 2
78124: EQUAL
78125: AND
78126: IFFALSE 78186
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78128: LD_INT 22
78130: PUSH
78131: LD_VAR 0 16
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 35
78142: PUSH
78143: LD_INT 49
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 91
78152: PUSH
78153: LD_VAR 0 1
78157: PUSH
78158: LD_INT 10
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: LIST
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: LIST
78170: PPUSH
78171: CALL_OW 69
78175: NOT
78176: IFFALSE 78186
// weapon := ru_time_lapser ;
78178: LD_ADDR_VAR 0 18
78182: PUSH
78183: LD_INT 49
78185: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78186: LD_VAR 0 12
78190: PUSH
78191: LD_INT 1
78193: PUSH
78194: LD_INT 2
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: IN
78201: PUSH
78202: LD_INT 11
78204: PUSH
78205: LD_VAR 0 5
78209: IN
78210: PUSH
78211: LD_INT 30
78213: PUSH
78214: LD_VAR 0 5
78218: IN
78219: OR
78220: AND
78221: PUSH
78222: LD_INT 6
78224: PPUSH
78225: LD_VAR 0 16
78229: PPUSH
78230: CALL_OW 321
78234: PUSH
78235: LD_INT 2
78237: EQUAL
78238: AND
78239: IFFALSE 78404
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
78241: LD_INT 22
78243: PUSH
78244: LD_VAR 0 16
78248: PUSH
78249: EMPTY
78250: LIST
78251: LIST
78252: PUSH
78253: LD_INT 2
78255: PUSH
78256: LD_INT 35
78258: PUSH
78259: LD_INT 11
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 35
78268: PUSH
78269: LD_INT 30
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 91
78283: PUSH
78284: LD_VAR 0 1
78288: PUSH
78289: LD_INT 18
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: LIST
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: LIST
78301: PPUSH
78302: CALL_OW 69
78306: NOT
78307: PUSH
78308: LD_INT 22
78310: PUSH
78311: LD_VAR 0 16
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: PUSH
78320: LD_INT 2
78322: PUSH
78323: LD_INT 30
78325: PUSH
78326: LD_INT 32
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 30
78335: PUSH
78336: LD_INT 33
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 91
78350: PUSH
78351: LD_VAR 0 1
78355: PUSH
78356: LD_INT 12
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: PUSH
78369: EMPTY
78370: LIST
78371: PPUSH
78372: CALL_OW 69
78376: PUSH
78377: LD_INT 2
78379: GREATER
78380: AND
78381: IFFALSE 78404
// weapon := [ us_radar , ar_radar ] [ nat ] ;
78383: LD_ADDR_VAR 0 18
78387: PUSH
78388: LD_INT 11
78390: PUSH
78391: LD_INT 30
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_VAR 0 12
78402: ARRAY
78403: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78404: LD_VAR 0 18
78408: NOT
78409: PUSH
78410: LD_INT 40
78412: PPUSH
78413: LD_VAR 0 16
78417: PPUSH
78418: CALL_OW 321
78422: PUSH
78423: LD_INT 2
78425: EQUAL
78426: AND
78427: PUSH
78428: LD_INT 7
78430: PUSH
78431: LD_VAR 0 5
78435: IN
78436: PUSH
78437: LD_INT 28
78439: PUSH
78440: LD_VAR 0 5
78444: IN
78445: OR
78446: PUSH
78447: LD_INT 45
78449: PUSH
78450: LD_VAR 0 5
78454: IN
78455: OR
78456: AND
78457: IFFALSE 78711
// begin hex := GetHexInfo ( x , y ) ;
78459: LD_ADDR_VAR 0 4
78463: PUSH
78464: LD_VAR 0 10
78468: PPUSH
78469: LD_VAR 0 11
78473: PPUSH
78474: CALL_OW 546
78478: ST_TO_ADDR
// if hex [ 1 ] then
78479: LD_VAR 0 4
78483: PUSH
78484: LD_INT 1
78486: ARRAY
78487: IFFALSE 78491
// exit ;
78489: GO 78894
// height := hex [ 2 ] ;
78491: LD_ADDR_VAR 0 15
78495: PUSH
78496: LD_VAR 0 4
78500: PUSH
78501: LD_INT 2
78503: ARRAY
78504: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78505: LD_ADDR_VAR 0 14
78509: PUSH
78510: LD_INT 0
78512: PUSH
78513: LD_INT 2
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: LD_INT 5
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: ST_TO_ADDR
// for i in tmp do
78528: LD_ADDR_VAR 0 8
78532: PUSH
78533: LD_VAR 0 14
78537: PUSH
78538: FOR_IN
78539: IFFALSE 78709
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78541: LD_ADDR_VAR 0 9
78545: PUSH
78546: LD_VAR 0 10
78550: PPUSH
78551: LD_VAR 0 8
78555: PPUSH
78556: LD_INT 5
78558: PPUSH
78559: CALL_OW 272
78563: PUSH
78564: LD_VAR 0 11
78568: PPUSH
78569: LD_VAR 0 8
78573: PPUSH
78574: LD_INT 5
78576: PPUSH
78577: CALL_OW 273
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78586: LD_VAR 0 9
78590: PUSH
78591: LD_INT 1
78593: ARRAY
78594: PPUSH
78595: LD_VAR 0 9
78599: PUSH
78600: LD_INT 2
78602: ARRAY
78603: PPUSH
78604: CALL_OW 488
78608: IFFALSE 78707
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78610: LD_ADDR_VAR 0 4
78614: PUSH
78615: LD_VAR 0 9
78619: PUSH
78620: LD_INT 1
78622: ARRAY
78623: PPUSH
78624: LD_VAR 0 9
78628: PUSH
78629: LD_INT 2
78631: ARRAY
78632: PPUSH
78633: CALL_OW 546
78637: ST_TO_ADDR
// if hex [ 1 ] then
78638: LD_VAR 0 4
78642: PUSH
78643: LD_INT 1
78645: ARRAY
78646: IFFALSE 78650
// continue ;
78648: GO 78538
// h := hex [ 2 ] ;
78650: LD_ADDR_VAR 0 13
78654: PUSH
78655: LD_VAR 0 4
78659: PUSH
78660: LD_INT 2
78662: ARRAY
78663: ST_TO_ADDR
// if h + 7 < height then
78664: LD_VAR 0 13
78668: PUSH
78669: LD_INT 7
78671: PLUS
78672: PUSH
78673: LD_VAR 0 15
78677: LESS
78678: IFFALSE 78707
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78680: LD_ADDR_VAR 0 18
78684: PUSH
78685: LD_INT 7
78687: PUSH
78688: LD_INT 28
78690: PUSH
78691: LD_INT 45
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: LIST
78698: PUSH
78699: LD_VAR 0 12
78703: ARRAY
78704: ST_TO_ADDR
// break ;
78705: GO 78709
// end ; end ; end ;
78707: GO 78538
78709: POP
78710: POP
// end ; if not weapon then
78711: LD_VAR 0 18
78715: NOT
78716: IFFALSE 78776
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78718: LD_ADDR_VAR 0 5
78722: PUSH
78723: LD_VAR 0 5
78727: PUSH
78728: LD_INT 11
78730: PUSH
78731: LD_INT 30
78733: PUSH
78734: LD_INT 49
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: LIST
78741: DIFF
78742: ST_TO_ADDR
// if not list then
78743: LD_VAR 0 5
78747: NOT
78748: IFFALSE 78752
// exit ;
78750: GO 78894
// weapon := list [ rand ( 1 , list ) ] ;
78752: LD_ADDR_VAR 0 18
78756: PUSH
78757: LD_VAR 0 5
78761: PUSH
78762: LD_INT 1
78764: PPUSH
78765: LD_VAR 0 5
78769: PPUSH
78770: CALL_OW 12
78774: ARRAY
78775: ST_TO_ADDR
// end ; if weapon then
78776: LD_VAR 0 18
78780: IFFALSE 78894
// begin tmp := CostOfWeapon ( weapon ) ;
78782: LD_ADDR_VAR 0 14
78786: PUSH
78787: LD_VAR 0 18
78791: PPUSH
78792: CALL_OW 451
78796: ST_TO_ADDR
// j := GetBase ( tower ) ;
78797: LD_ADDR_VAR 0 9
78801: PUSH
78802: LD_VAR 0 1
78806: PPUSH
78807: CALL_OW 274
78811: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78812: LD_VAR 0 9
78816: PPUSH
78817: LD_INT 1
78819: PPUSH
78820: CALL_OW 275
78824: PUSH
78825: LD_VAR 0 14
78829: PUSH
78830: LD_INT 1
78832: ARRAY
78833: GREATEREQUAL
78834: PUSH
78835: LD_VAR 0 9
78839: PPUSH
78840: LD_INT 2
78842: PPUSH
78843: CALL_OW 275
78847: PUSH
78848: LD_VAR 0 14
78852: PUSH
78853: LD_INT 2
78855: ARRAY
78856: GREATEREQUAL
78857: AND
78858: PUSH
78859: LD_VAR 0 9
78863: PPUSH
78864: LD_INT 3
78866: PPUSH
78867: CALL_OW 275
78871: PUSH
78872: LD_VAR 0 14
78876: PUSH
78877: LD_INT 3
78879: ARRAY
78880: GREATEREQUAL
78881: AND
78882: IFFALSE 78894
// result := weapon ;
78884: LD_ADDR_VAR 0 3
78888: PUSH
78889: LD_VAR 0 18
78893: ST_TO_ADDR
// end ; end ;
78894: LD_VAR 0 3
78898: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78899: LD_INT 0
78901: PPUSH
78902: PPUSH
// result := true ;
78903: LD_ADDR_VAR 0 3
78907: PUSH
78908: LD_INT 1
78910: ST_TO_ADDR
// if array1 = array2 then
78911: LD_VAR 0 1
78915: PUSH
78916: LD_VAR 0 2
78920: EQUAL
78921: IFFALSE 78981
// begin for i = 1 to array1 do
78923: LD_ADDR_VAR 0 4
78927: PUSH
78928: DOUBLE
78929: LD_INT 1
78931: DEC
78932: ST_TO_ADDR
78933: LD_VAR 0 1
78937: PUSH
78938: FOR_TO
78939: IFFALSE 78977
// if array1 [ i ] <> array2 [ i ] then
78941: LD_VAR 0 1
78945: PUSH
78946: LD_VAR 0 4
78950: ARRAY
78951: PUSH
78952: LD_VAR 0 2
78956: PUSH
78957: LD_VAR 0 4
78961: ARRAY
78962: NONEQUAL
78963: IFFALSE 78975
// begin result := false ;
78965: LD_ADDR_VAR 0 3
78969: PUSH
78970: LD_INT 0
78972: ST_TO_ADDR
// break ;
78973: GO 78977
// end ;
78975: GO 78938
78977: POP
78978: POP
// end else
78979: GO 78989
// result := false ;
78981: LD_ADDR_VAR 0 3
78985: PUSH
78986: LD_INT 0
78988: ST_TO_ADDR
// end ;
78989: LD_VAR 0 3
78993: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78994: LD_INT 0
78996: PPUSH
78997: PPUSH
// if not array1 or not array2 then
78998: LD_VAR 0 1
79002: NOT
79003: PUSH
79004: LD_VAR 0 2
79008: NOT
79009: OR
79010: IFFALSE 79014
// exit ;
79012: GO 79078
// result := true ;
79014: LD_ADDR_VAR 0 3
79018: PUSH
79019: LD_INT 1
79021: ST_TO_ADDR
// for i = 1 to array1 do
79022: LD_ADDR_VAR 0 4
79026: PUSH
79027: DOUBLE
79028: LD_INT 1
79030: DEC
79031: ST_TO_ADDR
79032: LD_VAR 0 1
79036: PUSH
79037: FOR_TO
79038: IFFALSE 79076
// if array1 [ i ] <> array2 [ i ] then
79040: LD_VAR 0 1
79044: PUSH
79045: LD_VAR 0 4
79049: ARRAY
79050: PUSH
79051: LD_VAR 0 2
79055: PUSH
79056: LD_VAR 0 4
79060: ARRAY
79061: NONEQUAL
79062: IFFALSE 79074
// begin result := false ;
79064: LD_ADDR_VAR 0 3
79068: PUSH
79069: LD_INT 0
79071: ST_TO_ADDR
// break ;
79072: GO 79076
// end ;
79074: GO 79037
79076: POP
79077: POP
// end ;
79078: LD_VAR 0 3
79082: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79083: LD_INT 0
79085: PPUSH
79086: PPUSH
79087: PPUSH
// pom := GetBase ( fac ) ;
79088: LD_ADDR_VAR 0 5
79092: PUSH
79093: LD_VAR 0 1
79097: PPUSH
79098: CALL_OW 274
79102: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79103: LD_ADDR_VAR 0 4
79107: PUSH
79108: LD_VAR 0 2
79112: PUSH
79113: LD_INT 1
79115: ARRAY
79116: PPUSH
79117: LD_VAR 0 2
79121: PUSH
79122: LD_INT 2
79124: ARRAY
79125: PPUSH
79126: LD_VAR 0 2
79130: PUSH
79131: LD_INT 3
79133: ARRAY
79134: PPUSH
79135: LD_VAR 0 2
79139: PUSH
79140: LD_INT 4
79142: ARRAY
79143: PPUSH
79144: CALL_OW 449
79148: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79149: LD_ADDR_VAR 0 3
79153: PUSH
79154: LD_VAR 0 5
79158: PPUSH
79159: LD_INT 1
79161: PPUSH
79162: CALL_OW 275
79166: PUSH
79167: LD_VAR 0 4
79171: PUSH
79172: LD_INT 1
79174: ARRAY
79175: GREATEREQUAL
79176: PUSH
79177: LD_VAR 0 5
79181: PPUSH
79182: LD_INT 2
79184: PPUSH
79185: CALL_OW 275
79189: PUSH
79190: LD_VAR 0 4
79194: PUSH
79195: LD_INT 2
79197: ARRAY
79198: GREATEREQUAL
79199: AND
79200: PUSH
79201: LD_VAR 0 5
79205: PPUSH
79206: LD_INT 3
79208: PPUSH
79209: CALL_OW 275
79213: PUSH
79214: LD_VAR 0 4
79218: PUSH
79219: LD_INT 3
79221: ARRAY
79222: GREATEREQUAL
79223: AND
79224: ST_TO_ADDR
// end ;
79225: LD_VAR 0 3
79229: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
79230: LD_INT 0
79232: PPUSH
79233: PPUSH
79234: PPUSH
79235: PPUSH
// pom := GetBase ( building ) ;
79236: LD_ADDR_VAR 0 3
79240: PUSH
79241: LD_VAR 0 1
79245: PPUSH
79246: CALL_OW 274
79250: ST_TO_ADDR
// if not pom then
79251: LD_VAR 0 3
79255: NOT
79256: IFFALSE 79260
// exit ;
79258: GO 79430
// btype := GetBType ( building ) ;
79260: LD_ADDR_VAR 0 5
79264: PUSH
79265: LD_VAR 0 1
79269: PPUSH
79270: CALL_OW 266
79274: ST_TO_ADDR
// if btype = b_armoury then
79275: LD_VAR 0 5
79279: PUSH
79280: LD_INT 4
79282: EQUAL
79283: IFFALSE 79293
// btype := b_barracks ;
79285: LD_ADDR_VAR 0 5
79289: PUSH
79290: LD_INT 5
79292: ST_TO_ADDR
// if btype = b_depot then
79293: LD_VAR 0 5
79297: PUSH
79298: LD_INT 0
79300: EQUAL
79301: IFFALSE 79311
// btype := b_warehouse ;
79303: LD_ADDR_VAR 0 5
79307: PUSH
79308: LD_INT 1
79310: ST_TO_ADDR
// if btype = b_workshop then
79311: LD_VAR 0 5
79315: PUSH
79316: LD_INT 2
79318: EQUAL
79319: IFFALSE 79329
// btype := b_factory ;
79321: LD_ADDR_VAR 0 5
79325: PUSH
79326: LD_INT 3
79328: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79329: LD_ADDR_VAR 0 4
79333: PUSH
79334: LD_VAR 0 5
79338: PPUSH
79339: LD_VAR 0 1
79343: PPUSH
79344: CALL_OW 248
79348: PPUSH
79349: CALL_OW 450
79353: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79354: LD_ADDR_VAR 0 2
79358: PUSH
79359: LD_VAR 0 3
79363: PPUSH
79364: LD_INT 1
79366: PPUSH
79367: CALL_OW 275
79371: PUSH
79372: LD_VAR 0 4
79376: PUSH
79377: LD_INT 1
79379: ARRAY
79380: GREATEREQUAL
79381: PUSH
79382: LD_VAR 0 3
79386: PPUSH
79387: LD_INT 2
79389: PPUSH
79390: CALL_OW 275
79394: PUSH
79395: LD_VAR 0 4
79399: PUSH
79400: LD_INT 2
79402: ARRAY
79403: GREATEREQUAL
79404: AND
79405: PUSH
79406: LD_VAR 0 3
79410: PPUSH
79411: LD_INT 3
79413: PPUSH
79414: CALL_OW 275
79418: PUSH
79419: LD_VAR 0 4
79423: PUSH
79424: LD_INT 3
79426: ARRAY
79427: GREATEREQUAL
79428: AND
79429: ST_TO_ADDR
// end ;
79430: LD_VAR 0 2
79434: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79435: LD_INT 0
79437: PPUSH
79438: PPUSH
79439: PPUSH
// pom := GetBase ( building ) ;
79440: LD_ADDR_VAR 0 4
79444: PUSH
79445: LD_VAR 0 1
79449: PPUSH
79450: CALL_OW 274
79454: ST_TO_ADDR
// if not pom then
79455: LD_VAR 0 4
79459: NOT
79460: IFFALSE 79464
// exit ;
79462: GO 79565
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79464: LD_ADDR_VAR 0 5
79468: PUSH
79469: LD_VAR 0 2
79473: PPUSH
79474: LD_VAR 0 1
79478: PPUSH
79479: CALL_OW 248
79483: PPUSH
79484: CALL_OW 450
79488: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79489: LD_ADDR_VAR 0 3
79493: PUSH
79494: LD_VAR 0 4
79498: PPUSH
79499: LD_INT 1
79501: PPUSH
79502: CALL_OW 275
79506: PUSH
79507: LD_VAR 0 5
79511: PUSH
79512: LD_INT 1
79514: ARRAY
79515: GREATEREQUAL
79516: PUSH
79517: LD_VAR 0 4
79521: PPUSH
79522: LD_INT 2
79524: PPUSH
79525: CALL_OW 275
79529: PUSH
79530: LD_VAR 0 5
79534: PUSH
79535: LD_INT 2
79537: ARRAY
79538: GREATEREQUAL
79539: AND
79540: PUSH
79541: LD_VAR 0 4
79545: PPUSH
79546: LD_INT 3
79548: PPUSH
79549: CALL_OW 275
79553: PUSH
79554: LD_VAR 0 5
79558: PUSH
79559: LD_INT 3
79561: ARRAY
79562: GREATEREQUAL
79563: AND
79564: ST_TO_ADDR
// end ;
79565: LD_VAR 0 3
79569: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79570: LD_INT 0
79572: PPUSH
79573: PPUSH
79574: PPUSH
79575: PPUSH
79576: PPUSH
79577: PPUSH
79578: PPUSH
79579: PPUSH
79580: PPUSH
79581: PPUSH
79582: PPUSH
// result := false ;
79583: LD_ADDR_VAR 0 8
79587: PUSH
79588: LD_INT 0
79590: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79591: LD_VAR 0 5
79595: NOT
79596: PUSH
79597: LD_VAR 0 1
79601: NOT
79602: OR
79603: PUSH
79604: LD_VAR 0 2
79608: NOT
79609: OR
79610: PUSH
79611: LD_VAR 0 3
79615: NOT
79616: OR
79617: IFFALSE 79621
// exit ;
79619: GO 80435
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79621: LD_ADDR_VAR 0 14
79625: PUSH
79626: LD_VAR 0 1
79630: PPUSH
79631: LD_VAR 0 2
79635: PPUSH
79636: LD_VAR 0 3
79640: PPUSH
79641: LD_VAR 0 4
79645: PPUSH
79646: LD_VAR 0 5
79650: PUSH
79651: LD_INT 1
79653: ARRAY
79654: PPUSH
79655: CALL_OW 248
79659: PPUSH
79660: LD_INT 0
79662: PPUSH
79663: CALL 81668 0 6
79667: ST_TO_ADDR
// if not hexes then
79668: LD_VAR 0 14
79672: NOT
79673: IFFALSE 79677
// exit ;
79675: GO 80435
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79677: LD_ADDR_VAR 0 17
79681: PUSH
79682: LD_VAR 0 5
79686: PPUSH
79687: LD_INT 22
79689: PUSH
79690: LD_VAR 0 13
79694: PPUSH
79695: CALL_OW 255
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 2
79706: PUSH
79707: LD_INT 30
79709: PUSH
79710: LD_INT 0
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: LD_INT 30
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: LIST
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PPUSH
79736: CALL_OW 72
79740: ST_TO_ADDR
// for i = 1 to hexes do
79741: LD_ADDR_VAR 0 9
79745: PUSH
79746: DOUBLE
79747: LD_INT 1
79749: DEC
79750: ST_TO_ADDR
79751: LD_VAR 0 14
79755: PUSH
79756: FOR_TO
79757: IFFALSE 80433
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79759: LD_ADDR_VAR 0 13
79763: PUSH
79764: LD_VAR 0 14
79768: PUSH
79769: LD_VAR 0 9
79773: ARRAY
79774: PUSH
79775: LD_INT 1
79777: ARRAY
79778: PPUSH
79779: LD_VAR 0 14
79783: PUSH
79784: LD_VAR 0 9
79788: ARRAY
79789: PUSH
79790: LD_INT 2
79792: ARRAY
79793: PPUSH
79794: CALL_OW 428
79798: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79799: LD_VAR 0 14
79803: PUSH
79804: LD_VAR 0 9
79808: ARRAY
79809: PUSH
79810: LD_INT 1
79812: ARRAY
79813: PPUSH
79814: LD_VAR 0 14
79818: PUSH
79819: LD_VAR 0 9
79823: ARRAY
79824: PUSH
79825: LD_INT 2
79827: ARRAY
79828: PPUSH
79829: CALL_OW 351
79833: PUSH
79834: LD_VAR 0 14
79838: PUSH
79839: LD_VAR 0 9
79843: ARRAY
79844: PUSH
79845: LD_INT 1
79847: ARRAY
79848: PPUSH
79849: LD_VAR 0 14
79853: PUSH
79854: LD_VAR 0 9
79858: ARRAY
79859: PUSH
79860: LD_INT 2
79862: ARRAY
79863: PPUSH
79864: CALL_OW 488
79868: NOT
79869: OR
79870: PUSH
79871: LD_VAR 0 13
79875: PPUSH
79876: CALL_OW 247
79880: PUSH
79881: LD_INT 3
79883: EQUAL
79884: OR
79885: IFFALSE 79891
// exit ;
79887: POP
79888: POP
79889: GO 80435
// if not tmp then
79891: LD_VAR 0 13
79895: NOT
79896: IFFALSE 79900
// continue ;
79898: GO 79756
// result := true ;
79900: LD_ADDR_VAR 0 8
79904: PUSH
79905: LD_INT 1
79907: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79908: LD_VAR 0 6
79912: PUSH
79913: LD_VAR 0 13
79917: PPUSH
79918: CALL_OW 247
79922: PUSH
79923: LD_INT 2
79925: EQUAL
79926: AND
79927: PUSH
79928: LD_VAR 0 13
79932: PPUSH
79933: CALL_OW 263
79937: PUSH
79938: LD_INT 1
79940: EQUAL
79941: AND
79942: IFFALSE 80106
// begin if IsDrivenBy ( tmp ) then
79944: LD_VAR 0 13
79948: PPUSH
79949: CALL_OW 311
79953: IFFALSE 79957
// continue ;
79955: GO 79756
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79957: LD_VAR 0 6
79961: PPUSH
79962: LD_INT 3
79964: PUSH
79965: LD_INT 60
79967: PUSH
79968: EMPTY
79969: LIST
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: LD_INT 55
79980: PUSH
79981: EMPTY
79982: LIST
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PPUSH
79992: CALL_OW 72
79996: IFFALSE 80104
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79998: LD_ADDR_VAR 0 18
80002: PUSH
80003: LD_VAR 0 6
80007: PPUSH
80008: LD_INT 3
80010: PUSH
80011: LD_INT 60
80013: PUSH
80014: EMPTY
80015: LIST
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: PUSH
80021: LD_INT 3
80023: PUSH
80024: LD_INT 55
80026: PUSH
80027: EMPTY
80028: LIST
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PPUSH
80038: CALL_OW 72
80042: PUSH
80043: LD_INT 1
80045: ARRAY
80046: ST_TO_ADDR
// if IsInUnit ( driver ) then
80047: LD_VAR 0 18
80051: PPUSH
80052: CALL_OW 310
80056: IFFALSE 80067
// ComExit ( driver ) ;
80058: LD_VAR 0 18
80062: PPUSH
80063: CALL 105448 0 1
// AddComEnterUnit ( driver , tmp ) ;
80067: LD_VAR 0 18
80071: PPUSH
80072: LD_VAR 0 13
80076: PPUSH
80077: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80081: LD_VAR 0 18
80085: PPUSH
80086: LD_VAR 0 7
80090: PPUSH
80091: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80095: LD_VAR 0 18
80099: PPUSH
80100: CALL_OW 181
// end ; continue ;
80104: GO 79756
// end ; if not cleaners or not tmp in cleaners then
80106: LD_VAR 0 6
80110: NOT
80111: PUSH
80112: LD_VAR 0 13
80116: PUSH
80117: LD_VAR 0 6
80121: IN
80122: NOT
80123: OR
80124: IFFALSE 80431
// begin if dep then
80126: LD_VAR 0 17
80130: IFFALSE 80266
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80132: LD_ADDR_VAR 0 16
80136: PUSH
80137: LD_VAR 0 17
80141: PUSH
80142: LD_INT 1
80144: ARRAY
80145: PPUSH
80146: CALL_OW 250
80150: PPUSH
80151: LD_VAR 0 17
80155: PUSH
80156: LD_INT 1
80158: ARRAY
80159: PPUSH
80160: CALL_OW 254
80164: PPUSH
80165: LD_INT 5
80167: PPUSH
80168: CALL_OW 272
80172: PUSH
80173: LD_VAR 0 17
80177: PUSH
80178: LD_INT 1
80180: ARRAY
80181: PPUSH
80182: CALL_OW 251
80186: PPUSH
80187: LD_VAR 0 17
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: PPUSH
80196: CALL_OW 254
80200: PPUSH
80201: LD_INT 5
80203: PPUSH
80204: CALL_OW 273
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
80213: LD_VAR 0 16
80217: PUSH
80218: LD_INT 1
80220: ARRAY
80221: PPUSH
80222: LD_VAR 0 16
80226: PUSH
80227: LD_INT 2
80229: ARRAY
80230: PPUSH
80231: CALL_OW 488
80235: IFFALSE 80266
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
80237: LD_VAR 0 13
80241: PPUSH
80242: LD_VAR 0 16
80246: PUSH
80247: LD_INT 1
80249: ARRAY
80250: PPUSH
80251: LD_VAR 0 16
80255: PUSH
80256: LD_INT 2
80258: ARRAY
80259: PPUSH
80260: CALL_OW 111
// continue ;
80264: GO 79756
// end ; end ; r := GetDir ( tmp ) ;
80266: LD_ADDR_VAR 0 15
80270: PUSH
80271: LD_VAR 0 13
80275: PPUSH
80276: CALL_OW 254
80280: ST_TO_ADDR
// if r = 5 then
80281: LD_VAR 0 15
80285: PUSH
80286: LD_INT 5
80288: EQUAL
80289: IFFALSE 80299
// r := 0 ;
80291: LD_ADDR_VAR 0 15
80295: PUSH
80296: LD_INT 0
80298: ST_TO_ADDR
// for j = r to 5 do
80299: LD_ADDR_VAR 0 10
80303: PUSH
80304: DOUBLE
80305: LD_VAR 0 15
80309: DEC
80310: ST_TO_ADDR
80311: LD_INT 5
80313: PUSH
80314: FOR_TO
80315: IFFALSE 80429
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
80317: LD_ADDR_VAR 0 11
80321: PUSH
80322: LD_VAR 0 13
80326: PPUSH
80327: CALL_OW 250
80331: PPUSH
80332: LD_VAR 0 10
80336: PPUSH
80337: LD_INT 2
80339: PPUSH
80340: CALL_OW 272
80344: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
80345: LD_ADDR_VAR 0 12
80349: PUSH
80350: LD_VAR 0 13
80354: PPUSH
80355: CALL_OW 251
80359: PPUSH
80360: LD_VAR 0 10
80364: PPUSH
80365: LD_INT 2
80367: PPUSH
80368: CALL_OW 273
80372: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
80373: LD_VAR 0 11
80377: PPUSH
80378: LD_VAR 0 12
80382: PPUSH
80383: CALL_OW 488
80387: PUSH
80388: LD_VAR 0 11
80392: PPUSH
80393: LD_VAR 0 12
80397: PPUSH
80398: CALL_OW 428
80402: NOT
80403: AND
80404: IFFALSE 80427
// begin ComMoveXY ( tmp , _x , _y ) ;
80406: LD_VAR 0 13
80410: PPUSH
80411: LD_VAR 0 11
80415: PPUSH
80416: LD_VAR 0 12
80420: PPUSH
80421: CALL_OW 111
// break ;
80425: GO 80429
// end ; end ;
80427: GO 80314
80429: POP
80430: POP
// end ; end ;
80431: GO 79756
80433: POP
80434: POP
// end ;
80435: LD_VAR 0 8
80439: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80440: LD_INT 0
80442: PPUSH
// result := true ;
80443: LD_ADDR_VAR 0 3
80447: PUSH
80448: LD_INT 1
80450: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80451: LD_VAR 0 2
80455: PUSH
80456: LD_INT 24
80458: DOUBLE
80459: EQUAL
80460: IFTRUE 80470
80462: LD_INT 33
80464: DOUBLE
80465: EQUAL
80466: IFTRUE 80470
80468: GO 80495
80470: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80471: LD_ADDR_VAR 0 3
80475: PUSH
80476: LD_INT 32
80478: PPUSH
80479: LD_VAR 0 1
80483: PPUSH
80484: CALL_OW 321
80488: PUSH
80489: LD_INT 2
80491: EQUAL
80492: ST_TO_ADDR
80493: GO 80811
80495: LD_INT 20
80497: DOUBLE
80498: EQUAL
80499: IFTRUE 80503
80501: GO 80528
80503: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80504: LD_ADDR_VAR 0 3
80508: PUSH
80509: LD_INT 6
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: CALL_OW 321
80521: PUSH
80522: LD_INT 2
80524: EQUAL
80525: ST_TO_ADDR
80526: GO 80811
80528: LD_INT 22
80530: DOUBLE
80531: EQUAL
80532: IFTRUE 80542
80534: LD_INT 36
80536: DOUBLE
80537: EQUAL
80538: IFTRUE 80542
80540: GO 80567
80542: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80543: LD_ADDR_VAR 0 3
80547: PUSH
80548: LD_INT 15
80550: PPUSH
80551: LD_VAR 0 1
80555: PPUSH
80556: CALL_OW 321
80560: PUSH
80561: LD_INT 2
80563: EQUAL
80564: ST_TO_ADDR
80565: GO 80811
80567: LD_INT 30
80569: DOUBLE
80570: EQUAL
80571: IFTRUE 80575
80573: GO 80600
80575: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80576: LD_ADDR_VAR 0 3
80580: PUSH
80581: LD_INT 20
80583: PPUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: CALL_OW 321
80593: PUSH
80594: LD_INT 2
80596: EQUAL
80597: ST_TO_ADDR
80598: GO 80811
80600: LD_INT 28
80602: DOUBLE
80603: EQUAL
80604: IFTRUE 80614
80606: LD_INT 21
80608: DOUBLE
80609: EQUAL
80610: IFTRUE 80614
80612: GO 80639
80614: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80615: LD_ADDR_VAR 0 3
80619: PUSH
80620: LD_INT 21
80622: PPUSH
80623: LD_VAR 0 1
80627: PPUSH
80628: CALL_OW 321
80632: PUSH
80633: LD_INT 2
80635: EQUAL
80636: ST_TO_ADDR
80637: GO 80811
80639: LD_INT 16
80641: DOUBLE
80642: EQUAL
80643: IFTRUE 80647
80645: GO 80672
80647: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80648: LD_ADDR_VAR 0 3
80652: PUSH
80653: LD_INT 84
80655: PPUSH
80656: LD_VAR 0 1
80660: PPUSH
80661: CALL_OW 321
80665: PUSH
80666: LD_INT 2
80668: EQUAL
80669: ST_TO_ADDR
80670: GO 80811
80672: LD_INT 19
80674: DOUBLE
80675: EQUAL
80676: IFTRUE 80686
80678: LD_INT 23
80680: DOUBLE
80681: EQUAL
80682: IFTRUE 80686
80684: GO 80711
80686: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80687: LD_ADDR_VAR 0 3
80691: PUSH
80692: LD_INT 83
80694: PPUSH
80695: LD_VAR 0 1
80699: PPUSH
80700: CALL_OW 321
80704: PUSH
80705: LD_INT 2
80707: EQUAL
80708: ST_TO_ADDR
80709: GO 80811
80711: LD_INT 17
80713: DOUBLE
80714: EQUAL
80715: IFTRUE 80719
80717: GO 80744
80719: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80720: LD_ADDR_VAR 0 3
80724: PUSH
80725: LD_INT 39
80727: PPUSH
80728: LD_VAR 0 1
80732: PPUSH
80733: CALL_OW 321
80737: PUSH
80738: LD_INT 2
80740: EQUAL
80741: ST_TO_ADDR
80742: GO 80811
80744: LD_INT 18
80746: DOUBLE
80747: EQUAL
80748: IFTRUE 80752
80750: GO 80777
80752: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80753: LD_ADDR_VAR 0 3
80757: PUSH
80758: LD_INT 40
80760: PPUSH
80761: LD_VAR 0 1
80765: PPUSH
80766: CALL_OW 321
80770: PUSH
80771: LD_INT 2
80773: EQUAL
80774: ST_TO_ADDR
80775: GO 80811
80777: LD_INT 27
80779: DOUBLE
80780: EQUAL
80781: IFTRUE 80785
80783: GO 80810
80785: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80786: LD_ADDR_VAR 0 3
80790: PUSH
80791: LD_INT 35
80793: PPUSH
80794: LD_VAR 0 1
80798: PPUSH
80799: CALL_OW 321
80803: PUSH
80804: LD_INT 2
80806: EQUAL
80807: ST_TO_ADDR
80808: GO 80811
80810: POP
// end ;
80811: LD_VAR 0 3
80815: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80816: LD_INT 0
80818: PPUSH
80819: PPUSH
80820: PPUSH
80821: PPUSH
80822: PPUSH
80823: PPUSH
80824: PPUSH
80825: PPUSH
80826: PPUSH
80827: PPUSH
80828: PPUSH
// result := false ;
80829: LD_ADDR_VAR 0 6
80833: PUSH
80834: LD_INT 0
80836: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80837: LD_VAR 0 1
80841: NOT
80842: PUSH
80843: LD_VAR 0 1
80847: PPUSH
80848: CALL_OW 266
80852: PUSH
80853: LD_INT 0
80855: PUSH
80856: LD_INT 1
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: IN
80863: NOT
80864: OR
80865: PUSH
80866: LD_VAR 0 2
80870: NOT
80871: OR
80872: PUSH
80873: LD_VAR 0 5
80877: PUSH
80878: LD_INT 0
80880: PUSH
80881: LD_INT 1
80883: PUSH
80884: LD_INT 2
80886: PUSH
80887: LD_INT 3
80889: PUSH
80890: LD_INT 4
80892: PUSH
80893: LD_INT 5
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: IN
80904: NOT
80905: OR
80906: PUSH
80907: LD_VAR 0 3
80911: PPUSH
80912: LD_VAR 0 4
80916: PPUSH
80917: CALL_OW 488
80921: NOT
80922: OR
80923: IFFALSE 80927
// exit ;
80925: GO 81663
// side := GetSide ( depot ) ;
80927: LD_ADDR_VAR 0 9
80931: PUSH
80932: LD_VAR 0 1
80936: PPUSH
80937: CALL_OW 255
80941: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80942: LD_VAR 0 9
80946: PPUSH
80947: LD_VAR 0 2
80951: PPUSH
80952: CALL 80440 0 2
80956: NOT
80957: IFFALSE 80961
// exit ;
80959: GO 81663
// pom := GetBase ( depot ) ;
80961: LD_ADDR_VAR 0 10
80965: PUSH
80966: LD_VAR 0 1
80970: PPUSH
80971: CALL_OW 274
80975: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80976: LD_ADDR_VAR 0 11
80980: PUSH
80981: LD_VAR 0 2
80985: PPUSH
80986: LD_VAR 0 1
80990: PPUSH
80991: CALL_OW 248
80995: PPUSH
80996: CALL_OW 450
81000: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
81001: LD_VAR 0 10
81005: PPUSH
81006: LD_INT 1
81008: PPUSH
81009: CALL_OW 275
81013: PUSH
81014: LD_VAR 0 11
81018: PUSH
81019: LD_INT 1
81021: ARRAY
81022: GREATEREQUAL
81023: PUSH
81024: LD_VAR 0 10
81028: PPUSH
81029: LD_INT 2
81031: PPUSH
81032: CALL_OW 275
81036: PUSH
81037: LD_VAR 0 11
81041: PUSH
81042: LD_INT 2
81044: ARRAY
81045: GREATEREQUAL
81046: AND
81047: PUSH
81048: LD_VAR 0 10
81052: PPUSH
81053: LD_INT 3
81055: PPUSH
81056: CALL_OW 275
81060: PUSH
81061: LD_VAR 0 11
81065: PUSH
81066: LD_INT 3
81068: ARRAY
81069: GREATEREQUAL
81070: AND
81071: NOT
81072: IFFALSE 81076
// exit ;
81074: GO 81663
// if GetBType ( depot ) = b_depot then
81076: LD_VAR 0 1
81080: PPUSH
81081: CALL_OW 266
81085: PUSH
81086: LD_INT 0
81088: EQUAL
81089: IFFALSE 81101
// dist := 28 else
81091: LD_ADDR_VAR 0 14
81095: PUSH
81096: LD_INT 28
81098: ST_TO_ADDR
81099: GO 81109
// dist := 36 ;
81101: LD_ADDR_VAR 0 14
81105: PUSH
81106: LD_INT 36
81108: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81109: LD_VAR 0 1
81113: PPUSH
81114: LD_VAR 0 3
81118: PPUSH
81119: LD_VAR 0 4
81123: PPUSH
81124: CALL_OW 297
81128: PUSH
81129: LD_VAR 0 14
81133: GREATER
81134: IFFALSE 81138
// exit ;
81136: GO 81663
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81138: LD_ADDR_VAR 0 12
81142: PUSH
81143: LD_VAR 0 2
81147: PPUSH
81148: LD_VAR 0 3
81152: PPUSH
81153: LD_VAR 0 4
81157: PPUSH
81158: LD_VAR 0 5
81162: PPUSH
81163: LD_VAR 0 1
81167: PPUSH
81168: CALL_OW 248
81172: PPUSH
81173: LD_INT 0
81175: PPUSH
81176: CALL 81668 0 6
81180: ST_TO_ADDR
// if not hexes then
81181: LD_VAR 0 12
81185: NOT
81186: IFFALSE 81190
// exit ;
81188: GO 81663
// hex := GetHexInfo ( x , y ) ;
81190: LD_ADDR_VAR 0 15
81194: PUSH
81195: LD_VAR 0 3
81199: PPUSH
81200: LD_VAR 0 4
81204: PPUSH
81205: CALL_OW 546
81209: ST_TO_ADDR
// if hex [ 1 ] then
81210: LD_VAR 0 15
81214: PUSH
81215: LD_INT 1
81217: ARRAY
81218: IFFALSE 81222
// exit ;
81220: GO 81663
// height := hex [ 2 ] ;
81222: LD_ADDR_VAR 0 13
81226: PUSH
81227: LD_VAR 0 15
81231: PUSH
81232: LD_INT 2
81234: ARRAY
81235: ST_TO_ADDR
// for i = 1 to hexes do
81236: LD_ADDR_VAR 0 7
81240: PUSH
81241: DOUBLE
81242: LD_INT 1
81244: DEC
81245: ST_TO_ADDR
81246: LD_VAR 0 12
81250: PUSH
81251: FOR_TO
81252: IFFALSE 81582
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
81254: LD_VAR 0 12
81258: PUSH
81259: LD_VAR 0 7
81263: ARRAY
81264: PUSH
81265: LD_INT 1
81267: ARRAY
81268: PPUSH
81269: LD_VAR 0 12
81273: PUSH
81274: LD_VAR 0 7
81278: ARRAY
81279: PUSH
81280: LD_INT 2
81282: ARRAY
81283: PPUSH
81284: CALL_OW 488
81288: NOT
81289: PUSH
81290: LD_VAR 0 12
81294: PUSH
81295: LD_VAR 0 7
81299: ARRAY
81300: PUSH
81301: LD_INT 1
81303: ARRAY
81304: PPUSH
81305: LD_VAR 0 12
81309: PUSH
81310: LD_VAR 0 7
81314: ARRAY
81315: PUSH
81316: LD_INT 2
81318: ARRAY
81319: PPUSH
81320: CALL_OW 428
81324: PUSH
81325: LD_INT 0
81327: GREATER
81328: OR
81329: PUSH
81330: LD_VAR 0 12
81334: PUSH
81335: LD_VAR 0 7
81339: ARRAY
81340: PUSH
81341: LD_INT 1
81343: ARRAY
81344: PPUSH
81345: LD_VAR 0 12
81349: PUSH
81350: LD_VAR 0 7
81354: ARRAY
81355: PUSH
81356: LD_INT 2
81358: ARRAY
81359: PPUSH
81360: CALL_OW 351
81364: OR
81365: IFFALSE 81371
// exit ;
81367: POP
81368: POP
81369: GO 81663
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81371: LD_ADDR_VAR 0 8
81375: PUSH
81376: LD_VAR 0 12
81380: PUSH
81381: LD_VAR 0 7
81385: ARRAY
81386: PUSH
81387: LD_INT 1
81389: ARRAY
81390: PPUSH
81391: LD_VAR 0 12
81395: PUSH
81396: LD_VAR 0 7
81400: ARRAY
81401: PUSH
81402: LD_INT 2
81404: ARRAY
81405: PPUSH
81406: CALL_OW 546
81410: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81411: LD_VAR 0 8
81415: PUSH
81416: LD_INT 1
81418: ARRAY
81419: PUSH
81420: LD_VAR 0 8
81424: PUSH
81425: LD_INT 2
81427: ARRAY
81428: PUSH
81429: LD_VAR 0 13
81433: PUSH
81434: LD_INT 2
81436: PLUS
81437: GREATER
81438: OR
81439: PUSH
81440: LD_VAR 0 8
81444: PUSH
81445: LD_INT 2
81447: ARRAY
81448: PUSH
81449: LD_VAR 0 13
81453: PUSH
81454: LD_INT 2
81456: MINUS
81457: LESS
81458: OR
81459: PUSH
81460: LD_VAR 0 8
81464: PUSH
81465: LD_INT 3
81467: ARRAY
81468: PUSH
81469: LD_INT 0
81471: PUSH
81472: LD_INT 8
81474: PUSH
81475: LD_INT 9
81477: PUSH
81478: LD_INT 10
81480: PUSH
81481: LD_INT 11
81483: PUSH
81484: LD_INT 12
81486: PUSH
81487: LD_INT 13
81489: PUSH
81490: LD_INT 16
81492: PUSH
81493: LD_INT 17
81495: PUSH
81496: LD_INT 18
81498: PUSH
81499: LD_INT 19
81501: PUSH
81502: LD_INT 20
81504: PUSH
81505: LD_INT 21
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: IN
81523: NOT
81524: OR
81525: PUSH
81526: LD_VAR 0 8
81530: PUSH
81531: LD_INT 5
81533: ARRAY
81534: NOT
81535: OR
81536: PUSH
81537: LD_VAR 0 8
81541: PUSH
81542: LD_INT 6
81544: ARRAY
81545: PUSH
81546: LD_INT 1
81548: PUSH
81549: LD_INT 2
81551: PUSH
81552: LD_INT 7
81554: PUSH
81555: LD_INT 9
81557: PUSH
81558: LD_INT 10
81560: PUSH
81561: LD_INT 11
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: IN
81572: NOT
81573: OR
81574: IFFALSE 81580
// exit ;
81576: POP
81577: POP
81578: GO 81663
// end ;
81580: GO 81251
81582: POP
81583: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81584: LD_VAR 0 9
81588: PPUSH
81589: LD_VAR 0 3
81593: PPUSH
81594: LD_VAR 0 4
81598: PPUSH
81599: LD_INT 20
81601: PPUSH
81602: CALL 73615 0 4
81606: PUSH
81607: LD_INT 4
81609: ARRAY
81610: IFFALSE 81614
// exit ;
81612: GO 81663
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81614: LD_VAR 0 2
81618: PUSH
81619: LD_INT 29
81621: PUSH
81622: LD_INT 30
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: IN
81629: PUSH
81630: LD_VAR 0 3
81634: PPUSH
81635: LD_VAR 0 4
81639: PPUSH
81640: LD_VAR 0 9
81644: PPUSH
81645: CALL_OW 440
81649: NOT
81650: AND
81651: IFFALSE 81655
// exit ;
81653: GO 81663
// result := true ;
81655: LD_ADDR_VAR 0 6
81659: PUSH
81660: LD_INT 1
81662: ST_TO_ADDR
// end ;
81663: LD_VAR 0 6
81667: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81668: LD_INT 0
81670: PPUSH
81671: PPUSH
81672: PPUSH
81673: PPUSH
81674: PPUSH
81675: PPUSH
81676: PPUSH
81677: PPUSH
81678: PPUSH
81679: PPUSH
81680: PPUSH
81681: PPUSH
81682: PPUSH
81683: PPUSH
81684: PPUSH
81685: PPUSH
81686: PPUSH
81687: PPUSH
81688: PPUSH
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
81693: PPUSH
81694: PPUSH
81695: PPUSH
81696: PPUSH
81697: PPUSH
81698: PPUSH
81699: PPUSH
81700: PPUSH
81701: PPUSH
81702: PPUSH
81703: PPUSH
81704: PPUSH
81705: PPUSH
81706: PPUSH
81707: PPUSH
81708: PPUSH
81709: PPUSH
81710: PPUSH
81711: PPUSH
81712: PPUSH
81713: PPUSH
81714: PPUSH
81715: PPUSH
81716: PPUSH
81717: PPUSH
81718: PPUSH
81719: PPUSH
81720: PPUSH
81721: PPUSH
81722: PPUSH
81723: PPUSH
81724: PPUSH
81725: PPUSH
81726: PPUSH
81727: PPUSH
// result = [ ] ;
81728: LD_ADDR_VAR 0 7
81732: PUSH
81733: EMPTY
81734: ST_TO_ADDR
// temp_list = [ ] ;
81735: LD_ADDR_VAR 0 9
81739: PUSH
81740: EMPTY
81741: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81742: LD_VAR 0 4
81746: PUSH
81747: LD_INT 0
81749: PUSH
81750: LD_INT 1
81752: PUSH
81753: LD_INT 2
81755: PUSH
81756: LD_INT 3
81758: PUSH
81759: LD_INT 4
81761: PUSH
81762: LD_INT 5
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: IN
81773: NOT
81774: PUSH
81775: LD_VAR 0 1
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: LD_INT 1
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: IN
81790: PUSH
81791: LD_VAR 0 5
81795: PUSH
81796: LD_INT 1
81798: PUSH
81799: LD_INT 2
81801: PUSH
81802: LD_INT 3
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: LIST
81809: IN
81810: NOT
81811: AND
81812: OR
81813: IFFALSE 81817
// exit ;
81815: GO 100208
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81817: LD_VAR 0 1
81821: PUSH
81822: LD_INT 6
81824: PUSH
81825: LD_INT 7
81827: PUSH
81828: LD_INT 8
81830: PUSH
81831: LD_INT 13
81833: PUSH
81834: LD_INT 12
81836: PUSH
81837: LD_INT 15
81839: PUSH
81840: LD_INT 11
81842: PUSH
81843: LD_INT 14
81845: PUSH
81846: LD_INT 10
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: IN
81860: IFFALSE 81870
// btype = b_lab ;
81862: LD_ADDR_VAR 0 1
81866: PUSH
81867: LD_INT 6
81869: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81870: LD_VAR 0 6
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: LD_INT 1
81880: PUSH
81881: LD_INT 2
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: LIST
81888: IN
81889: NOT
81890: PUSH
81891: LD_VAR 0 1
81895: PUSH
81896: LD_INT 0
81898: PUSH
81899: LD_INT 1
81901: PUSH
81902: LD_INT 2
81904: PUSH
81905: LD_INT 3
81907: PUSH
81908: LD_INT 6
81910: PUSH
81911: LD_INT 36
81913: PUSH
81914: LD_INT 4
81916: PUSH
81917: LD_INT 5
81919: PUSH
81920: LD_INT 31
81922: PUSH
81923: LD_INT 32
81925: PUSH
81926: LD_INT 33
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: IN
81942: NOT
81943: PUSH
81944: LD_VAR 0 6
81948: PUSH
81949: LD_INT 1
81951: EQUAL
81952: AND
81953: OR
81954: PUSH
81955: LD_VAR 0 1
81959: PUSH
81960: LD_INT 2
81962: PUSH
81963: LD_INT 3
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: IN
81970: NOT
81971: PUSH
81972: LD_VAR 0 6
81976: PUSH
81977: LD_INT 2
81979: EQUAL
81980: AND
81981: OR
81982: IFFALSE 81992
// mode = 0 ;
81984: LD_ADDR_VAR 0 6
81988: PUSH
81989: LD_INT 0
81991: ST_TO_ADDR
// case mode of 0 :
81992: LD_VAR 0 6
81996: PUSH
81997: LD_INT 0
81999: DOUBLE
82000: EQUAL
82001: IFTRUE 82005
82003: GO 93458
82005: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
82006: LD_ADDR_VAR 0 11
82010: PUSH
82011: LD_INT 0
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 1
82034: PUSH
82035: LD_INT 0
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: LD_INT 1
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 1
82064: NEG
82065: PUSH
82066: LD_INT 0
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: LD_INT 1
82079: NEG
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 1
82087: NEG
82088: PUSH
82089: LD_INT 2
82091: NEG
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: LD_INT 2
82102: NEG
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 1
82110: PUSH
82111: LD_INT 1
82113: NEG
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: PUSH
82122: LD_INT 2
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 0
82131: PUSH
82132: LD_INT 2
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 1
82141: NEG
82142: PUSH
82143: LD_INT 1
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: LD_INT 3
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 0
82162: PUSH
82163: LD_INT 3
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 1
82172: NEG
82173: PUSH
82174: LD_INT 2
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82199: LD_ADDR_VAR 0 12
82203: PUSH
82204: LD_INT 0
82206: PUSH
82207: LD_INT 0
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: LD_INT 1
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: PUSH
82228: LD_INT 0
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 1
82237: PUSH
82238: LD_INT 1
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 1
82268: NEG
82269: PUSH
82270: LD_INT 1
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: PUSH
82281: LD_INT 1
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 2
82301: PUSH
82302: LD_INT 1
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 1
82311: NEG
82312: PUSH
82313: LD_INT 1
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 2
82322: NEG
82323: PUSH
82324: LD_INT 0
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: NEG
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: NEG
82346: PUSH
82347: LD_INT 1
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 3
82356: NEG
82357: PUSH
82358: LD_INT 0
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 3
82367: NEG
82368: PUSH
82369: LD_INT 1
82371: NEG
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82395: LD_ADDR_VAR 0 13
82399: PUSH
82400: LD_INT 0
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 0
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 1
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 1
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: EMPTY
82438: LIST
82439: LIST
82440: PUSH
82441: LD_INT 0
82443: PUSH
82444: LD_INT 1
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 1
82453: NEG
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: LD_INT 1
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: LD_INT 2
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 2
82488: PUSH
82489: LD_INT 1
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 2
82498: PUSH
82499: LD_INT 2
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 1
82508: PUSH
82509: LD_INT 2
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 2
82518: NEG
82519: PUSH
82520: LD_INT 1
82522: NEG
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 2
82530: NEG
82531: PUSH
82532: LD_INT 2
82534: NEG
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 2
82542: NEG
82543: PUSH
82544: LD_INT 3
82546: NEG
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 3
82554: NEG
82555: PUSH
82556: LD_INT 2
82558: NEG
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 3
82566: NEG
82567: PUSH
82568: LD_INT 3
82570: NEG
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82594: LD_ADDR_VAR 0 14
82598: PUSH
82599: LD_INT 0
82601: PUSH
82602: LD_INT 0
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 0
82611: PUSH
82612: LD_INT 1
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 1
82622: PUSH
82623: LD_INT 0
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: LD_INT 1
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 0
82642: PUSH
82643: LD_INT 1
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: NEG
82653: PUSH
82654: LD_INT 0
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: NEG
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 1
82675: NEG
82676: PUSH
82677: LD_INT 2
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 0
82687: PUSH
82688: LD_INT 2
82690: NEG
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 1
82698: PUSH
82699: LD_INT 1
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: LD_INT 2
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 0
82719: PUSH
82720: LD_INT 2
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 1
82729: NEG
82730: PUSH
82731: LD_INT 1
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: NEG
82741: PUSH
82742: LD_INT 3
82744: NEG
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 0
82752: PUSH
82753: LD_INT 3
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 1
82763: PUSH
82764: LD_INT 2
82766: NEG
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82790: LD_ADDR_VAR 0 15
82794: PUSH
82795: LD_INT 0
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: LD_INT 0
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PUSH
82826: LD_INT 1
82828: PUSH
82829: LD_INT 1
82831: PUSH
82832: EMPTY
82833: LIST
82834: LIST
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: LD_INT 1
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PUSH
82846: LD_INT 1
82848: NEG
82849: PUSH
82850: LD_INT 0
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 1
82859: NEG
82860: PUSH
82861: LD_INT 1
82863: NEG
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 2
82892: PUSH
82893: LD_INT 1
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: LD_INT 1
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 2
82913: NEG
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 2
82924: NEG
82925: PUSH
82926: LD_INT 1
82928: NEG
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 2
82936: PUSH
82937: LD_INT 1
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 3
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 3
82957: PUSH
82958: LD_INT 1
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82983: LD_ADDR_VAR 0 16
82987: PUSH
82988: LD_INT 0
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 0
83000: PUSH
83001: LD_INT 1
83003: NEG
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 1
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 0
83031: PUSH
83032: LD_INT 1
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 1
83041: NEG
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 1
83052: NEG
83053: PUSH
83054: LD_INT 1
83056: NEG
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 1
83064: NEG
83065: PUSH
83066: LD_INT 2
83068: NEG
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 2
83076: PUSH
83077: LD_INT 1
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 2
83086: PUSH
83087: LD_INT 2
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 1
83096: PUSH
83097: LD_INT 2
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 2
83106: NEG
83107: PUSH
83108: LD_INT 1
83110: NEG
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 2
83118: NEG
83119: PUSH
83120: LD_INT 2
83122: NEG
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 3
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 3
83140: PUSH
83141: LD_INT 3
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 2
83150: PUSH
83151: LD_INT 3
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83176: LD_ADDR_VAR 0 17
83180: PUSH
83181: LD_INT 0
83183: PUSH
83184: LD_INT 0
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 0
83193: PUSH
83194: LD_INT 1
83196: NEG
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 1
83204: PUSH
83205: LD_INT 0
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 1
83214: PUSH
83215: LD_INT 1
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 0
83224: PUSH
83225: LD_INT 1
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: NEG
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 1
83245: NEG
83246: PUSH
83247: LD_INT 1
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: LD_INT 2
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: LD_INT 2
83272: NEG
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 2
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: PUSH
83299: LD_INT 2
83301: PUSH
83302: LD_INT 1
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: PUSH
83309: LD_INT 2
83311: PUSH
83312: LD_INT 2
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: LD_INT 2
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 0
83331: PUSH
83332: LD_INT 2
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 1
83341: NEG
83342: PUSH
83343: LD_INT 1
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 2
83352: NEG
83353: PUSH
83354: LD_INT 0
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 2
83363: NEG
83364: PUSH
83365: LD_INT 1
83367: NEG
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 2
83375: NEG
83376: PUSH
83377: LD_INT 2
83379: NEG
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83406: LD_ADDR_VAR 0 18
83410: PUSH
83411: LD_INT 0
83413: PUSH
83414: LD_INT 0
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: PUSH
83421: LD_INT 0
83423: PUSH
83424: LD_INT 1
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: LD_INT 0
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 1
83444: PUSH
83445: LD_INT 1
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 0
83454: PUSH
83455: LD_INT 1
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: LD_INT 0
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 1
83487: NEG
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 0
83499: PUSH
83500: LD_INT 2
83502: NEG
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: PUSH
83508: LD_INT 1
83510: PUSH
83511: LD_INT 1
83513: NEG
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 2
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 2
83531: PUSH
83532: LD_INT 1
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 2
83541: PUSH
83542: LD_INT 2
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: LD_INT 2
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 0
83561: PUSH
83562: LD_INT 2
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 1
83571: NEG
83572: PUSH
83573: LD_INT 1
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 2
83582: NEG
83583: PUSH
83584: LD_INT 0
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 2
83593: NEG
83594: PUSH
83595: LD_INT 1
83597: NEG
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 2
83605: NEG
83606: PUSH
83607: LD_INT 2
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83636: LD_ADDR_VAR 0 19
83640: PUSH
83641: LD_INT 0
83643: PUSH
83644: LD_INT 0
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 0
83653: PUSH
83654: LD_INT 1
83656: NEG
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PUSH
83662: LD_INT 1
83664: PUSH
83665: LD_INT 0
83667: PUSH
83668: EMPTY
83669: LIST
83670: LIST
83671: PUSH
83672: LD_INT 1
83674: PUSH
83675: LD_INT 1
83677: PUSH
83678: EMPTY
83679: LIST
83680: LIST
83681: PUSH
83682: LD_INT 0
83684: PUSH
83685: LD_INT 1
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: NEG
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 1
83705: NEG
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 1
83717: NEG
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 0
83729: PUSH
83730: LD_INT 2
83732: NEG
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PUSH
83738: LD_INT 1
83740: PUSH
83741: LD_INT 1
83743: NEG
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 2
83751: PUSH
83752: LD_INT 0
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 2
83761: PUSH
83762: LD_INT 1
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 2
83771: PUSH
83772: LD_INT 2
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 1
83781: PUSH
83782: LD_INT 2
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 0
83791: PUSH
83792: LD_INT 2
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: NEG
83802: PUSH
83803: LD_INT 1
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 2
83812: NEG
83813: PUSH
83814: LD_INT 0
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 2
83823: NEG
83824: PUSH
83825: LD_INT 1
83827: NEG
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 2
83835: NEG
83836: PUSH
83837: LD_INT 2
83839: NEG
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83866: LD_ADDR_VAR 0 20
83870: PUSH
83871: LD_INT 0
83873: PUSH
83874: LD_INT 0
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 0
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 1
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 1
83904: PUSH
83905: LD_INT 1
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: LD_INT 1
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: NEG
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 1
83935: NEG
83936: PUSH
83937: LD_INT 1
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: NEG
83948: PUSH
83949: LD_INT 2
83951: NEG
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 0
83959: PUSH
83960: LD_INT 2
83962: NEG
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 1
83970: PUSH
83971: LD_INT 1
83973: NEG
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 2
83981: PUSH
83982: LD_INT 0
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: PUSH
83989: LD_INT 2
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 2
84001: PUSH
84002: LD_INT 2
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 1
84011: PUSH
84012: LD_INT 2
84014: PUSH
84015: EMPTY
84016: LIST
84017: LIST
84018: PUSH
84019: LD_INT 0
84021: PUSH
84022: LD_INT 2
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 1
84031: NEG
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: NEG
84043: PUSH
84044: LD_INT 0
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 2
84053: NEG
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84096: LD_ADDR_VAR 0 21
84100: PUSH
84101: LD_INT 0
84103: PUSH
84104: LD_INT 0
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: LD_INT 1
84116: NEG
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 1
84124: PUSH
84125: LD_INT 0
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 0
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: NEG
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: NEG
84178: PUSH
84179: LD_INT 2
84181: NEG
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 0
84189: PUSH
84190: LD_INT 2
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 2
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: LD_INT 1
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 2
84231: PUSH
84232: LD_INT 2
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: PUSH
84242: LD_INT 2
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: PUSH
84249: LD_INT 0
84251: PUSH
84252: LD_INT 2
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: PUSH
84259: LD_INT 1
84261: NEG
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 2
84272: NEG
84273: PUSH
84274: LD_INT 0
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 2
84283: NEG
84284: PUSH
84285: LD_INT 1
84287: NEG
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 2
84295: NEG
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: LIST
84325: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84326: LD_ADDR_VAR 0 22
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 1
84354: PUSH
84355: LD_INT 0
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 1
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: PUSH
84386: LD_INT 0
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 1
84395: NEG
84396: PUSH
84397: LD_INT 1
84399: NEG
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: NEG
84408: PUSH
84409: LD_INT 2
84411: NEG
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 0
84419: PUSH
84420: LD_INT 2
84422: NEG
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 1
84430: PUSH
84431: LD_INT 1
84433: NEG
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 2
84451: PUSH
84452: LD_INT 1
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 2
84461: PUSH
84462: LD_INT 2
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: LD_INT 2
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: LD_INT 0
84481: PUSH
84482: LD_INT 2
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: LD_INT 1
84491: NEG
84492: PUSH
84493: LD_INT 1
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 2
84502: NEG
84503: PUSH
84504: LD_INT 0
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: NEG
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 2
84525: NEG
84526: PUSH
84527: LD_INT 2
84529: NEG
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84556: LD_ADDR_VAR 0 23
84560: PUSH
84561: LD_INT 0
84563: PUSH
84564: LD_INT 0
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 0
84573: PUSH
84574: LD_INT 1
84576: NEG
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 1
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 0
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: NEG
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 1
84625: NEG
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 1
84637: NEG
84638: PUSH
84639: LD_INT 2
84641: NEG
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 0
84649: PUSH
84650: LD_INT 2
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 1
84660: PUSH
84661: LD_INT 1
84663: NEG
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 2
84671: PUSH
84672: LD_INT 0
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 2
84681: PUSH
84682: LD_INT 1
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 2
84691: PUSH
84692: LD_INT 2
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: PUSH
84702: LD_INT 2
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 0
84711: PUSH
84712: LD_INT 2
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 1
84721: NEG
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 2
84732: NEG
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 2
84743: NEG
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: EMPTY
84750: LIST
84751: LIST
84752: PUSH
84753: LD_INT 2
84755: NEG
84756: PUSH
84757: LD_INT 2
84759: NEG
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: LD_INT 2
84767: NEG
84768: PUSH
84769: LD_INT 3
84771: NEG
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: PUSH
84777: LD_INT 1
84779: NEG
84780: PUSH
84781: LD_INT 3
84783: NEG
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: PUSH
84792: LD_INT 2
84794: NEG
84795: PUSH
84796: EMPTY
84797: LIST
84798: LIST
84799: PUSH
84800: LD_INT 2
84802: PUSH
84803: LD_INT 1
84805: NEG
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84836: LD_ADDR_VAR 0 24
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: LD_INT 1
84856: NEG
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: PUSH
84862: LD_INT 1
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 1
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 1
84905: NEG
84906: PUSH
84907: LD_INT 1
84909: NEG
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 1
84917: NEG
84918: PUSH
84919: LD_INT 2
84921: NEG
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 0
84929: PUSH
84930: LD_INT 2
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: PUSH
84941: LD_INT 1
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 2
84951: PUSH
84952: LD_INT 0
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: LD_INT 2
84961: PUSH
84962: LD_INT 1
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 2
84971: PUSH
84972: LD_INT 2
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 1
84981: PUSH
84982: LD_INT 2
84984: PUSH
84985: EMPTY
84986: LIST
84987: LIST
84988: PUSH
84989: LD_INT 0
84991: PUSH
84992: LD_INT 2
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 1
85001: NEG
85002: PUSH
85003: LD_INT 1
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 2
85012: NEG
85013: PUSH
85014: LD_INT 0
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 2
85023: NEG
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 2
85035: NEG
85036: PUSH
85037: LD_INT 2
85039: NEG
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 1
85047: PUSH
85048: LD_INT 2
85050: NEG
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 2
85058: PUSH
85059: LD_INT 1
85061: NEG
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 3
85069: PUSH
85070: LD_INT 1
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 3
85079: PUSH
85080: LD_INT 2
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85112: LD_ADDR_VAR 0 25
85116: PUSH
85117: LD_INT 0
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 0
85129: PUSH
85130: LD_INT 1
85132: NEG
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 1
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: PUSH
85148: LD_INT 1
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 0
85160: PUSH
85161: LD_INT 1
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 1
85170: NEG
85171: PUSH
85172: LD_INT 0
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 1
85181: NEG
85182: PUSH
85183: LD_INT 1
85185: NEG
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 1
85193: NEG
85194: PUSH
85195: LD_INT 2
85197: NEG
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 0
85205: PUSH
85206: LD_INT 2
85208: NEG
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 1
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 2
85227: PUSH
85228: LD_INT 0
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 2
85237: PUSH
85238: LD_INT 1
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 2
85247: PUSH
85248: LD_INT 2
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: LD_INT 2
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: LD_INT 2
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 2
85288: NEG
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 2
85299: NEG
85300: PUSH
85301: LD_INT 1
85303: NEG
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 2
85311: NEG
85312: PUSH
85313: LD_INT 2
85315: NEG
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 3
85323: PUSH
85324: LD_INT 1
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 3
85333: PUSH
85334: LD_INT 2
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 2
85343: PUSH
85344: LD_INT 3
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 1
85353: PUSH
85354: LD_INT 3
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85386: LD_ADDR_VAR 0 26
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 1
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 0
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: LD_INT 0
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 1
85455: NEG
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: LD_INT 2
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 0
85479: PUSH
85480: LD_INT 2
85482: NEG
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 1
85490: PUSH
85491: LD_INT 1
85493: NEG
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 2
85501: PUSH
85502: LD_INT 0
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 2
85511: PUSH
85512: LD_INT 1
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: PUSH
85519: LD_INT 2
85521: PUSH
85522: LD_INT 2
85524: PUSH
85525: EMPTY
85526: LIST
85527: LIST
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: LD_INT 2
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 0
85541: PUSH
85542: LD_INT 2
85544: PUSH
85545: EMPTY
85546: LIST
85547: LIST
85548: PUSH
85549: LD_INT 1
85551: NEG
85552: PUSH
85553: LD_INT 1
85555: PUSH
85556: EMPTY
85557: LIST
85558: LIST
85559: PUSH
85560: LD_INT 2
85562: NEG
85563: PUSH
85564: LD_INT 0
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 2
85573: NEG
85574: PUSH
85575: LD_INT 1
85577: NEG
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 2
85585: NEG
85586: PUSH
85587: LD_INT 2
85589: NEG
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PUSH
85595: LD_INT 2
85597: PUSH
85598: LD_INT 3
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 1
85607: PUSH
85608: LD_INT 3
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 1
85617: NEG
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 2
85628: NEG
85629: PUSH
85630: LD_INT 1
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85662: LD_ADDR_VAR 0 27
85666: PUSH
85667: LD_INT 0
85669: PUSH
85670: LD_INT 0
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 0
85679: PUSH
85680: LD_INT 1
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: LD_INT 0
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 1
85700: PUSH
85701: LD_INT 1
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 0
85710: PUSH
85711: LD_INT 1
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: LD_INT 0
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 1
85731: NEG
85732: PUSH
85733: LD_INT 1
85735: NEG
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: PUSH
85741: LD_INT 1
85743: NEG
85744: PUSH
85745: LD_INT 2
85747: NEG
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 0
85755: PUSH
85756: LD_INT 2
85758: NEG
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 1
85766: PUSH
85767: LD_INT 1
85769: NEG
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: LD_INT 2
85777: PUSH
85778: LD_INT 0
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: LD_INT 2
85787: PUSH
85788: LD_INT 1
85790: PUSH
85791: EMPTY
85792: LIST
85793: LIST
85794: PUSH
85795: LD_INT 2
85797: PUSH
85798: LD_INT 2
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: LD_INT 2
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 0
85817: PUSH
85818: LD_INT 2
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: LD_INT 1
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 2
85838: NEG
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 2
85849: NEG
85850: PUSH
85851: LD_INT 1
85853: NEG
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 2
85861: NEG
85862: PUSH
85863: LD_INT 2
85865: NEG
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 1
85873: NEG
85874: PUSH
85875: LD_INT 2
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 2
85884: NEG
85885: PUSH
85886: LD_INT 1
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: LD_INT 3
85895: NEG
85896: PUSH
85897: LD_INT 1
85899: NEG
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: LD_INT 3
85907: NEG
85908: PUSH
85909: LD_INT 2
85911: NEG
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85942: LD_ADDR_VAR 0 28
85946: PUSH
85947: LD_INT 0
85949: PUSH
85950: LD_INT 0
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: LD_INT 0
85959: PUSH
85960: LD_INT 1
85962: NEG
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 1
85970: PUSH
85971: LD_INT 0
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: LD_INT 1
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 0
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: NEG
86001: PUSH
86002: LD_INT 0
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 1
86011: NEG
86012: PUSH
86013: LD_INT 1
86015: NEG
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: LD_INT 2
86027: NEG
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: LD_INT 2
86038: NEG
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 1
86046: PUSH
86047: LD_INT 1
86049: NEG
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 2
86057: PUSH
86058: LD_INT 0
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 2
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 2
86077: PUSH
86078: LD_INT 2
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 2
86118: NEG
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: NEG
86130: PUSH
86131: LD_INT 1
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 2
86141: NEG
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 2
86153: NEG
86154: PUSH
86155: LD_INT 3
86157: NEG
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 1
86165: NEG
86166: PUSH
86167: LD_INT 3
86169: NEG
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 3
86177: NEG
86178: PUSH
86179: LD_INT 1
86181: NEG
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 3
86189: NEG
86190: PUSH
86191: LD_INT 2
86193: NEG
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86224: LD_ADDR_VAR 0 29
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: PUSH
86253: LD_INT 0
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 1
86262: PUSH
86263: LD_INT 1
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 0
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: NEG
86283: PUSH
86284: LD_INT 0
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 1
86305: NEG
86306: PUSH
86307: LD_INT 2
86309: NEG
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 0
86317: PUSH
86318: LD_INT 2
86320: NEG
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: LD_INT 1
86331: NEG
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 0
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 2
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 0
86369: PUSH
86370: LD_INT 2
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 1
86379: NEG
86380: PUSH
86381: LD_INT 1
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 2
86390: NEG
86391: PUSH
86392: LD_INT 1
86394: NEG
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: PUSH
86400: LD_INT 2
86402: NEG
86403: PUSH
86404: LD_INT 2
86406: NEG
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 2
86414: NEG
86415: PUSH
86416: LD_INT 3
86418: NEG
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 2
86426: PUSH
86427: LD_INT 1
86429: NEG
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 3
86437: PUSH
86438: LD_INT 1
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 1
86447: PUSH
86448: LD_INT 3
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 1
86457: NEG
86458: PUSH
86459: LD_INT 2
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 3
86468: NEG
86469: PUSH
86470: LD_INT 2
86472: NEG
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86503: LD_ADDR_VAR 0 30
86507: PUSH
86508: LD_INT 0
86510: PUSH
86511: LD_INT 0
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 0
86520: PUSH
86521: LD_INT 1
86523: NEG
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 1
86531: PUSH
86532: LD_INT 0
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 1
86541: PUSH
86542: LD_INT 1
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 0
86551: PUSH
86552: LD_INT 1
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: LD_INT 0
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 1
86572: NEG
86573: PUSH
86574: LD_INT 1
86576: NEG
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 1
86584: NEG
86585: PUSH
86586: LD_INT 2
86588: NEG
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 0
86596: PUSH
86597: LD_INT 2
86599: NEG
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: LD_INT 1
86610: NEG
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 2
86618: PUSH
86619: LD_INT 0
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 2
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 2
86638: PUSH
86639: LD_INT 2
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: LD_INT 2
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 1
86658: NEG
86659: PUSH
86660: LD_INT 1
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 2
86669: NEG
86670: PUSH
86671: LD_INT 0
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 2
86680: NEG
86681: PUSH
86682: LD_INT 1
86684: NEG
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 1
86692: NEG
86693: PUSH
86694: LD_INT 3
86696: NEG
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 1
86704: PUSH
86705: LD_INT 2
86707: NEG
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: PUSH
86713: LD_INT 3
86715: PUSH
86716: LD_INT 2
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 2
86725: PUSH
86726: LD_INT 3
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 2
86735: NEG
86736: PUSH
86737: LD_INT 1
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 3
86746: NEG
86747: PUSH
86748: LD_INT 1
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86781: LD_ADDR_VAR 0 31
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: LD_INT 0
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 0
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 1
86809: PUSH
86810: LD_INT 0
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 0
86829: PUSH
86830: LD_INT 1
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 1
86839: NEG
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: LD_INT 1
86854: NEG
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: LD_INT 2
86866: NEG
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: LD_INT 1
86877: NEG
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 2
86885: PUSH
86886: LD_INT 0
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: PUSH
86893: LD_INT 2
86895: PUSH
86896: LD_INT 1
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 2
86905: PUSH
86906: LD_INT 2
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: LD_INT 2
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 0
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: EMPTY
86930: LIST
86931: LIST
86932: PUSH
86933: LD_INT 1
86935: NEG
86936: PUSH
86937: LD_INT 1
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 2
86946: NEG
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 2
86958: NEG
86959: PUSH
86960: LD_INT 2
86962: NEG
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 2
86970: NEG
86971: PUSH
86972: LD_INT 3
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 2
86982: PUSH
86983: LD_INT 1
86985: NEG
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 3
86993: PUSH
86994: LD_INT 1
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 1
87003: PUSH
87004: LD_INT 3
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 1
87013: NEG
87014: PUSH
87015: LD_INT 2
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 3
87024: NEG
87025: PUSH
87026: LD_INT 2
87028: NEG
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87059: LD_ADDR_VAR 0 32
87063: PUSH
87064: LD_INT 0
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 0
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 1
87087: PUSH
87088: LD_INT 0
87090: PUSH
87091: EMPTY
87092: LIST
87093: LIST
87094: PUSH
87095: LD_INT 1
87097: PUSH
87098: LD_INT 1
87100: PUSH
87101: EMPTY
87102: LIST
87103: LIST
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: LD_INT 1
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 1
87117: NEG
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 1
87128: NEG
87129: PUSH
87130: LD_INT 1
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 1
87140: NEG
87141: PUSH
87142: LD_INT 2
87144: NEG
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: LD_INT 2
87155: NEG
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 1
87163: PUSH
87164: LD_INT 1
87166: NEG
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 2
87174: PUSH
87175: LD_INT 1
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 2
87184: PUSH
87185: LD_INT 2
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: LD_INT 2
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 0
87204: PUSH
87205: LD_INT 2
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 1
87214: NEG
87215: PUSH
87216: LD_INT 1
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 2
87225: NEG
87226: PUSH
87227: LD_INT 0
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 2
87236: NEG
87237: PUSH
87238: LD_INT 1
87240: NEG
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: LD_INT 3
87252: NEG
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 1
87260: PUSH
87261: LD_INT 2
87263: NEG
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 3
87271: PUSH
87272: LD_INT 2
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 2
87281: PUSH
87282: LD_INT 3
87284: PUSH
87285: EMPTY
87286: LIST
87287: LIST
87288: PUSH
87289: LD_INT 2
87291: NEG
87292: PUSH
87293: LD_INT 1
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: LD_INT 3
87302: NEG
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87337: LD_ADDR_VAR 0 33
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: LD_INT 0
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 0
87354: PUSH
87355: LD_INT 1
87357: NEG
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 1
87365: PUSH
87366: LD_INT 0
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 1
87375: PUSH
87376: LD_INT 1
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 0
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 1
87395: NEG
87396: PUSH
87397: LD_INT 0
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 1
87406: NEG
87407: PUSH
87408: LD_INT 1
87410: NEG
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: LD_INT 2
87422: NEG
87423: PUSH
87424: EMPTY
87425: LIST
87426: LIST
87427: PUSH
87428: LD_INT 1
87430: PUSH
87431: LD_INT 1
87433: NEG
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 2
87441: PUSH
87442: LD_INT 0
87444: PUSH
87445: EMPTY
87446: LIST
87447: LIST
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 1
87461: PUSH
87462: LD_INT 2
87464: PUSH
87465: EMPTY
87466: LIST
87467: LIST
87468: PUSH
87469: LD_INT 0
87471: PUSH
87472: LD_INT 2
87474: PUSH
87475: EMPTY
87476: LIST
87477: LIST
87478: PUSH
87479: LD_INT 1
87481: NEG
87482: PUSH
87483: LD_INT 1
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 2
87492: NEG
87493: PUSH
87494: LD_INT 0
87496: PUSH
87497: EMPTY
87498: LIST
87499: LIST
87500: PUSH
87501: LD_INT 2
87503: NEG
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 2
87515: NEG
87516: PUSH
87517: LD_INT 2
87519: NEG
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 2
87527: NEG
87528: PUSH
87529: LD_INT 3
87531: NEG
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 2
87539: PUSH
87540: LD_INT 1
87542: NEG
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 3
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: LD_INT 3
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 1
87570: NEG
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 3
87581: NEG
87582: PUSH
87583: LD_INT 2
87585: NEG
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87616: LD_ADDR_VAR 0 34
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: LD_INT 0
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 0
87633: PUSH
87634: LD_INT 1
87636: NEG
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 1
87644: PUSH
87645: LD_INT 0
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 1
87654: PUSH
87655: LD_INT 1
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 0
87664: PUSH
87665: LD_INT 1
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 1
87674: NEG
87675: PUSH
87676: LD_INT 0
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 1
87685: NEG
87686: PUSH
87687: LD_INT 1
87689: NEG
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 1
87697: NEG
87698: PUSH
87699: LD_INT 2
87701: NEG
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 0
87709: PUSH
87710: LD_INT 2
87712: NEG
87713: PUSH
87714: EMPTY
87715: LIST
87716: LIST
87717: PUSH
87718: LD_INT 1
87720: PUSH
87721: LD_INT 1
87723: NEG
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 2
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 2
87741: PUSH
87742: LD_INT 2
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: LD_INT 2
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: LD_INT 1
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 2
87772: NEG
87773: PUSH
87774: LD_INT 0
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 2
87783: NEG
87784: PUSH
87785: LD_INT 1
87787: NEG
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 2
87795: NEG
87796: PUSH
87797: LD_INT 2
87799: NEG
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 1
87807: NEG
87808: PUSH
87809: LD_INT 3
87811: NEG
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 1
87819: PUSH
87820: LD_INT 2
87822: NEG
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 3
87830: PUSH
87831: LD_INT 2
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PUSH
87838: LD_INT 2
87840: PUSH
87841: LD_INT 3
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: LD_INT 2
87850: NEG
87851: PUSH
87852: LD_INT 1
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 3
87861: NEG
87862: PUSH
87863: LD_INT 1
87865: NEG
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: LIST
87887: LIST
87888: LIST
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87896: LD_ADDR_VAR 0 35
87900: PUSH
87901: LD_INT 0
87903: PUSH
87904: LD_INT 0
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: LD_INT 1
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 1
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 1
87934: PUSH
87935: LD_INT 1
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 0
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 1
87954: NEG
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 1
87965: NEG
87966: PUSH
87967: LD_INT 1
87969: NEG
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 2
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 2
87987: NEG
87988: PUSH
87989: LD_INT 1
87991: NEG
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88008: LD_ADDR_VAR 0 36
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 0
88025: PUSH
88026: LD_INT 1
88028: NEG
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: LD_INT 0
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 1
88046: PUSH
88047: LD_INT 1
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: LD_INT 1
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 1
88066: NEG
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 1
88077: NEG
88078: PUSH
88079: LD_INT 1
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 1
88089: NEG
88090: PUSH
88091: LD_INT 2
88093: NEG
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 1
88101: PUSH
88102: LD_INT 2
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88120: LD_ADDR_VAR 0 37
88124: PUSH
88125: LD_INT 0
88127: PUSH
88128: LD_INT 0
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: LD_INT 1
88140: NEG
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 1
88148: PUSH
88149: LD_INT 0
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 1
88158: PUSH
88159: LD_INT 1
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: LD_INT 0
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 1
88178: NEG
88179: PUSH
88180: LD_INT 0
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 1
88189: NEG
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 1
88201: PUSH
88202: LD_INT 1
88204: NEG
88205: PUSH
88206: EMPTY
88207: LIST
88208: LIST
88209: PUSH
88210: LD_INT 1
88212: NEG
88213: PUSH
88214: LD_INT 1
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88232: LD_ADDR_VAR 0 38
88236: PUSH
88237: LD_INT 0
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 0
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PUSH
88258: LD_INT 1
88260: PUSH
88261: LD_INT 0
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 1
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 0
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 1
88290: NEG
88291: PUSH
88292: LD_INT 0
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 1
88301: NEG
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 2
88313: PUSH
88314: LD_INT 1
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: LD_INT 2
88323: NEG
88324: PUSH
88325: LD_INT 1
88327: NEG
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88344: LD_ADDR_VAR 0 39
88348: PUSH
88349: LD_INT 0
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 0
88361: PUSH
88362: LD_INT 1
88364: NEG
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 1
88372: PUSH
88373: LD_INT 0
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: PUSH
88380: LD_INT 1
88382: PUSH
88383: LD_INT 1
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: LD_INT 1
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: PUSH
88400: LD_INT 1
88402: NEG
88403: PUSH
88404: LD_INT 0
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 1
88413: NEG
88414: PUSH
88415: LD_INT 1
88417: NEG
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: LD_INT 2
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: PUSH
88438: LD_INT 2
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88456: LD_ADDR_VAR 0 40
88460: PUSH
88461: LD_INT 0
88463: PUSH
88464: LD_INT 0
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 1
88484: PUSH
88485: LD_INT 0
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: LD_INT 1
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 1
88514: NEG
88515: PUSH
88516: LD_INT 0
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: LD_INT 1
88529: NEG
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 1
88537: PUSH
88538: LD_INT 1
88540: NEG
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88568: LD_ADDR_VAR 0 41
88572: PUSH
88573: LD_INT 0
88575: PUSH
88576: LD_INT 0
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: PUSH
88583: LD_INT 0
88585: PUSH
88586: LD_INT 1
88588: NEG
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: PUSH
88594: LD_INT 1
88596: PUSH
88597: LD_INT 0
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 1
88606: PUSH
88607: LD_INT 1
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: LD_INT 1
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: PUSH
88624: LD_INT 1
88626: NEG
88627: PUSH
88628: LD_INT 0
88630: PUSH
88631: EMPTY
88632: LIST
88633: LIST
88634: PUSH
88635: LD_INT 1
88637: NEG
88638: PUSH
88639: LD_INT 1
88641: NEG
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 1
88649: NEG
88650: PUSH
88651: LD_INT 2
88653: NEG
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 1
88661: PUSH
88662: LD_INT 1
88664: NEG
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 2
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 2
88682: PUSH
88683: LD_INT 1
88685: PUSH
88686: EMPTY
88687: LIST
88688: LIST
88689: PUSH
88690: LD_INT 2
88692: PUSH
88693: LD_INT 2
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 1
88702: PUSH
88703: LD_INT 2
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 1
88712: NEG
88713: PUSH
88714: LD_INT 1
88716: PUSH
88717: EMPTY
88718: LIST
88719: LIST
88720: PUSH
88721: LD_INT 2
88723: NEG
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 2
88734: NEG
88735: PUSH
88736: LD_INT 1
88738: NEG
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 2
88746: NEG
88747: PUSH
88748: LD_INT 2
88750: NEG
88751: PUSH
88752: EMPTY
88753: LIST
88754: LIST
88755: PUSH
88756: LD_INT 2
88758: NEG
88759: PUSH
88760: LD_INT 3
88762: NEG
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 2
88770: PUSH
88771: LD_INT 1
88773: NEG
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 3
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 3
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 3
88801: PUSH
88802: LD_INT 2
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 3
88811: PUSH
88812: LD_INT 3
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 2
88821: PUSH
88822: LD_INT 3
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 2
88831: NEG
88832: PUSH
88833: LD_INT 1
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 3
88842: NEG
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: PUSH
88851: LD_INT 3
88853: NEG
88854: PUSH
88855: LD_INT 1
88857: NEG
88858: PUSH
88859: EMPTY
88860: LIST
88861: LIST
88862: PUSH
88863: LD_INT 3
88865: NEG
88866: PUSH
88867: LD_INT 2
88869: NEG
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 3
88877: NEG
88878: PUSH
88879: LD_INT 3
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88918: LD_ADDR_VAR 0 42
88922: PUSH
88923: LD_INT 0
88925: PUSH
88926: LD_INT 0
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PUSH
88933: LD_INT 0
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 1
88946: PUSH
88947: LD_INT 0
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 1
88956: PUSH
88957: LD_INT 1
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: LD_INT 1
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 1
88976: NEG
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: EMPTY
88982: LIST
88983: LIST
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: LD_INT 1
88991: NEG
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 1
88999: NEG
89000: PUSH
89001: LD_INT 2
89003: NEG
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 0
89011: PUSH
89012: LD_INT 2
89014: NEG
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 1
89022: PUSH
89023: LD_INT 1
89025: NEG
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 2
89033: PUSH
89034: LD_INT 1
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 2
89043: PUSH
89044: LD_INT 2
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 1
89053: PUSH
89054: LD_INT 2
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: LD_INT 2
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: NEG
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: EMPTY
89079: LIST
89080: LIST
89081: PUSH
89082: LD_INT 2
89084: NEG
89085: PUSH
89086: LD_INT 1
89088: NEG
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 2
89096: NEG
89097: PUSH
89098: LD_INT 2
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 2
89108: NEG
89109: PUSH
89110: LD_INT 3
89112: NEG
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 1
89120: NEG
89121: PUSH
89122: LD_INT 3
89124: NEG
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: PUSH
89130: LD_INT 0
89132: PUSH
89133: LD_INT 3
89135: NEG
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: LD_INT 2
89146: NEG
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 3
89154: PUSH
89155: LD_INT 2
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 3
89164: PUSH
89165: LD_INT 3
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 2
89174: PUSH
89175: LD_INT 3
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: LD_INT 3
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 0
89194: PUSH
89195: LD_INT 3
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: LD_INT 2
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 3
89215: NEG
89216: PUSH
89217: LD_INT 2
89219: NEG
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 3
89227: NEG
89228: PUSH
89229: LD_INT 3
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: LIST
89267: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89268: LD_ADDR_VAR 0 43
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: LD_INT 0
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 0
89285: PUSH
89286: LD_INT 1
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 1
89296: PUSH
89297: LD_INT 0
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 1
89306: PUSH
89307: LD_INT 1
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 0
89316: PUSH
89317: LD_INT 1
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: LD_INT 1
89326: NEG
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: LD_INT 1
89341: NEG
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 1
89349: NEG
89350: PUSH
89351: LD_INT 2
89353: NEG
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 0
89361: PUSH
89362: LD_INT 2
89364: NEG
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 1
89372: PUSH
89373: LD_INT 1
89375: NEG
89376: PUSH
89377: EMPTY
89378: LIST
89379: LIST
89380: PUSH
89381: LD_INT 2
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 2
89393: PUSH
89394: LD_INT 1
89396: PUSH
89397: EMPTY
89398: LIST
89399: LIST
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: LD_INT 2
89406: PUSH
89407: EMPTY
89408: LIST
89409: LIST
89410: PUSH
89411: LD_INT 0
89413: PUSH
89414: LD_INT 2
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 1
89423: NEG
89424: PUSH
89425: LD_INT 1
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 2
89434: NEG
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 2
89445: NEG
89446: PUSH
89447: LD_INT 1
89449: NEG
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 1
89457: NEG
89458: PUSH
89459: LD_INT 3
89461: NEG
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: LD_INT 3
89472: NEG
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: LD_INT 2
89483: NEG
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 2
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 3
89502: PUSH
89503: LD_INT 0
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 3
89512: PUSH
89513: LD_INT 1
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 1
89522: PUSH
89523: LD_INT 3
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: LD_INT 3
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 1
89542: NEG
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 2
89553: NEG
89554: PUSH
89555: LD_INT 1
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 3
89564: NEG
89565: PUSH
89566: LD_INT 0
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 3
89575: NEG
89576: PUSH
89577: LD_INT 1
89579: NEG
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: LIST
89606: LIST
89607: LIST
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89616: LD_ADDR_VAR 0 44
89620: PUSH
89621: LD_INT 0
89623: PUSH
89624: LD_INT 0
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 0
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: PUSH
89655: LD_INT 1
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: LD_INT 1
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 1
89685: NEG
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: LD_INT 1
89697: NEG
89698: PUSH
89699: LD_INT 2
89701: NEG
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 1
89709: PUSH
89710: LD_INT 1
89712: NEG
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 2
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 2
89730: PUSH
89731: LD_INT 1
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: PUSH
89738: LD_INT 2
89740: PUSH
89741: LD_INT 2
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 1
89750: PUSH
89751: LD_INT 2
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 1
89760: NEG
89761: PUSH
89762: LD_INT 1
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 2
89771: NEG
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 2
89782: NEG
89783: PUSH
89784: LD_INT 1
89786: NEG
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 2
89794: NEG
89795: PUSH
89796: LD_INT 2
89798: NEG
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 2
89806: NEG
89807: PUSH
89808: LD_INT 3
89810: NEG
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 2
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 3
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 3
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 3
89849: PUSH
89850: LD_INT 2
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 3
89859: PUSH
89860: LD_INT 3
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: LD_INT 3
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 2
89879: NEG
89880: PUSH
89881: LD_INT 1
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 3
89890: NEG
89891: PUSH
89892: LD_INT 0
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 3
89901: NEG
89902: PUSH
89903: LD_INT 1
89905: NEG
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PUSH
89911: LD_INT 3
89913: NEG
89914: PUSH
89915: LD_INT 2
89917: NEG
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 3
89925: NEG
89926: PUSH
89927: LD_INT 3
89929: NEG
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89966: LD_ADDR_VAR 0 45
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 0
89983: PUSH
89984: LD_INT 1
89986: NEG
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 0
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 1
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 0
90014: PUSH
90015: LD_INT 1
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 1
90024: NEG
90025: PUSH
90026: LD_INT 0
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: NEG
90036: PUSH
90037: LD_INT 1
90039: NEG
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: LD_INT 1
90047: NEG
90048: PUSH
90049: LD_INT 2
90051: NEG
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: LD_INT 2
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 1
90070: PUSH
90071: LD_INT 1
90073: NEG
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 2
90081: PUSH
90082: LD_INT 1
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 2
90091: PUSH
90092: LD_INT 2
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 1
90101: PUSH
90102: LD_INT 2
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 0
90111: PUSH
90112: LD_INT 2
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 1
90121: NEG
90122: PUSH
90123: LD_INT 1
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 2
90132: NEG
90133: PUSH
90134: LD_INT 1
90136: NEG
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 2
90144: NEG
90145: PUSH
90146: LD_INT 2
90148: NEG
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 2
90156: NEG
90157: PUSH
90158: LD_INT 3
90160: NEG
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 1
90168: NEG
90169: PUSH
90170: LD_INT 3
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 0
90180: PUSH
90181: LD_INT 3
90183: NEG
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 1
90191: PUSH
90192: LD_INT 2
90194: NEG
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 3
90202: PUSH
90203: LD_INT 2
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 3
90212: PUSH
90213: LD_INT 3
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: PUSH
90220: LD_INT 2
90222: PUSH
90223: LD_INT 3
90225: PUSH
90226: EMPTY
90227: LIST
90228: LIST
90229: PUSH
90230: LD_INT 1
90232: PUSH
90233: LD_INT 3
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 0
90242: PUSH
90243: LD_INT 3
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 1
90252: NEG
90253: PUSH
90254: LD_INT 2
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: LD_INT 3
90263: NEG
90264: PUSH
90265: LD_INT 2
90267: NEG
90268: PUSH
90269: EMPTY
90270: LIST
90271: LIST
90272: PUSH
90273: LD_INT 3
90275: NEG
90276: PUSH
90277: LD_INT 3
90279: NEG
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90316: LD_ADDR_VAR 0 46
90320: PUSH
90321: LD_INT 0
90323: PUSH
90324: LD_INT 0
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 1
90336: NEG
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 1
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: LD_INT 1
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: LD_INT 1
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: LD_INT 0
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 1
90385: NEG
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 1
90397: NEG
90398: PUSH
90399: LD_INT 2
90401: NEG
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 0
90409: PUSH
90410: LD_INT 2
90412: NEG
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 1
90420: PUSH
90421: LD_INT 1
90423: NEG
90424: PUSH
90425: EMPTY
90426: LIST
90427: LIST
90428: PUSH
90429: LD_INT 2
90431: PUSH
90432: LD_INT 0
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 2
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 1
90451: PUSH
90452: LD_INT 2
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: LD_INT 2
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 1
90471: NEG
90472: PUSH
90473: LD_INT 1
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 2
90482: NEG
90483: PUSH
90484: LD_INT 0
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 2
90493: NEG
90494: PUSH
90495: LD_INT 1
90497: NEG
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: NEG
90506: PUSH
90507: LD_INT 3
90509: NEG
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: LD_INT 3
90520: NEG
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: PUSH
90526: LD_INT 1
90528: PUSH
90529: LD_INT 2
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 2
90539: PUSH
90540: LD_INT 1
90542: NEG
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 3
90550: PUSH
90551: LD_INT 0
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 3
90560: PUSH
90561: LD_INT 1
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: LD_INT 1
90570: PUSH
90571: LD_INT 3
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: LD_INT 3
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: LD_INT 2
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 2
90601: NEG
90602: PUSH
90603: LD_INT 1
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_INT 3
90612: NEG
90613: PUSH
90614: LD_INT 0
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 3
90623: NEG
90624: PUSH
90625: LD_INT 1
90627: NEG
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90664: LD_ADDR_VAR 0 47
90668: PUSH
90669: LD_INT 0
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 0
90681: PUSH
90682: LD_INT 1
90684: NEG
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: PUSH
90690: LD_INT 1
90692: PUSH
90693: LD_INT 0
90695: PUSH
90696: EMPTY
90697: LIST
90698: LIST
90699: PUSH
90700: LD_INT 1
90702: PUSH
90703: LD_INT 1
90705: PUSH
90706: EMPTY
90707: LIST
90708: LIST
90709: PUSH
90710: LD_INT 0
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: LD_INT 0
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 1
90745: NEG
90746: PUSH
90747: LD_INT 2
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 0
90757: PUSH
90758: LD_INT 2
90760: NEG
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 1
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PUSH
90777: LD_INT 2
90779: NEG
90780: PUSH
90781: LD_INT 1
90783: NEG
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 2
90791: NEG
90792: PUSH
90793: LD_INT 2
90795: NEG
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: LIST
90812: LIST
90813: LIST
90814: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90815: LD_ADDR_VAR 0 48
90819: PUSH
90820: LD_INT 0
90822: PUSH
90823: LD_INT 0
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 0
90832: PUSH
90833: LD_INT 1
90835: NEG
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 1
90843: PUSH
90844: LD_INT 0
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 1
90853: PUSH
90854: LD_INT 1
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: LD_INT 1
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: LD_INT 0
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 1
90884: NEG
90885: PUSH
90886: LD_INT 1
90888: NEG
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: PUSH
90894: LD_INT 1
90896: NEG
90897: PUSH
90898: LD_INT 2
90900: NEG
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 0
90908: PUSH
90909: LD_INT 2
90911: NEG
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 1
90919: PUSH
90920: LD_INT 1
90922: NEG
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 2
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 2
90940: PUSH
90941: LD_INT 1
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90962: LD_ADDR_VAR 0 49
90966: PUSH
90967: LD_INT 0
90969: PUSH
90970: LD_INT 0
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: LD_INT 1
90982: NEG
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 1
90990: PUSH
90991: LD_INT 0
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 1
91000: PUSH
91001: LD_INT 1
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: LD_INT 1
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 1
91020: NEG
91021: PUSH
91022: LD_INT 0
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 1
91031: NEG
91032: PUSH
91033: LD_INT 1
91035: NEG
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 1
91043: PUSH
91044: LD_INT 1
91046: NEG
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 2
91054: PUSH
91055: LD_INT 0
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: LD_INT 2
91064: PUSH
91065: LD_INT 1
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: LD_INT 2
91074: PUSH
91075: LD_INT 2
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 1
91084: PUSH
91085: LD_INT 2
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91106: LD_ADDR_VAR 0 50
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: LD_INT 0
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 1
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: LD_INT 0
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: LD_INT 1
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: LD_INT 1
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 1
91164: NEG
91165: PUSH
91166: LD_INT 0
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 1
91175: NEG
91176: PUSH
91177: LD_INT 1
91179: NEG
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 2
91187: PUSH
91188: LD_INT 1
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 2
91197: PUSH
91198: LD_INT 2
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 2
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 0
91217: PUSH
91218: LD_INT 2
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 1
91227: NEG
91228: PUSH
91229: LD_INT 1
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91250: LD_ADDR_VAR 0 51
91254: PUSH
91255: LD_INT 0
91257: PUSH
91258: LD_INT 0
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: LD_INT 1
91270: NEG
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: LD_INT 1
91278: PUSH
91279: LD_INT 0
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 1
91288: PUSH
91289: LD_INT 1
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 0
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 1
91308: NEG
91309: PUSH
91310: LD_INT 0
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: PUSH
91332: LD_INT 2
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 0
91341: PUSH
91342: LD_INT 2
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 1
91351: NEG
91352: PUSH
91353: LD_INT 1
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 2
91362: NEG
91363: PUSH
91364: LD_INT 0
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 2
91373: NEG
91374: PUSH
91375: LD_INT 1
91377: NEG
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91397: LD_ADDR_VAR 0 52
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: LD_INT 0
91407: PUSH
91408: EMPTY
91409: LIST
91410: LIST
91411: PUSH
91412: LD_INT 0
91414: PUSH
91415: LD_INT 1
91417: NEG
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 1
91425: PUSH
91426: LD_INT 0
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 1
91435: PUSH
91436: LD_INT 1
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 0
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 1
91455: NEG
91456: PUSH
91457: LD_INT 0
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: NEG
91467: PUSH
91468: LD_INT 1
91470: NEG
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 1
91478: NEG
91479: PUSH
91480: LD_INT 2
91482: NEG
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 1
91490: NEG
91491: PUSH
91492: LD_INT 1
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 2
91501: NEG
91502: PUSH
91503: LD_INT 0
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 2
91512: NEG
91513: PUSH
91514: LD_INT 1
91516: NEG
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 2
91524: NEG
91525: PUSH
91526: LD_INT 2
91528: NEG
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91548: LD_ADDR_VAR 0 53
91552: PUSH
91553: LD_INT 0
91555: PUSH
91556: LD_INT 0
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: PUSH
91563: LD_INT 0
91565: PUSH
91566: LD_INT 1
91568: NEG
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 1
91576: PUSH
91577: LD_INT 0
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: LD_INT 1
91586: PUSH
91587: LD_INT 1
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 0
91596: PUSH
91597: LD_INT 1
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: NEG
91607: PUSH
91608: LD_INT 0
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 1
91617: NEG
91618: PUSH
91619: LD_INT 1
91621: NEG
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 1
91629: NEG
91630: PUSH
91631: LD_INT 2
91633: NEG
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: PUSH
91639: LD_INT 0
91641: PUSH
91642: LD_INT 2
91644: NEG
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: LD_INT 1
91655: NEG
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 2
91663: PUSH
91664: LD_INT 0
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 2
91673: PUSH
91674: LD_INT 1
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: LD_INT 2
91683: PUSH
91684: LD_INT 2
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: PUSH
91691: LD_INT 1
91693: PUSH
91694: LD_INT 2
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 0
91703: PUSH
91704: LD_INT 2
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: LD_INT 1
91713: NEG
91714: PUSH
91715: LD_INT 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 2
91724: NEG
91725: PUSH
91726: LD_INT 0
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 2
91735: NEG
91736: PUSH
91737: LD_INT 1
91739: NEG
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: LD_INT 2
91747: NEG
91748: PUSH
91749: LD_INT 2
91751: NEG
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91778: LD_ADDR_VAR 0 54
91782: PUSH
91783: LD_INT 0
91785: PUSH
91786: LD_INT 0
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: PUSH
91793: LD_INT 0
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: EMPTY
91801: LIST
91802: LIST
91803: PUSH
91804: LD_INT 1
91806: PUSH
91807: LD_INT 0
91809: PUSH
91810: EMPTY
91811: LIST
91812: LIST
91813: PUSH
91814: LD_INT 1
91816: PUSH
91817: LD_INT 1
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: PUSH
91824: LD_INT 0
91826: PUSH
91827: LD_INT 1
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: NEG
91837: PUSH
91838: LD_INT 0
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 1
91847: NEG
91848: PUSH
91849: LD_INT 1
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 1
91859: NEG
91860: PUSH
91861: LD_INT 2
91863: NEG
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 0
91871: PUSH
91872: LD_INT 2
91874: NEG
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: LD_INT 1
91885: NEG
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: LD_INT 2
91893: PUSH
91894: LD_INT 0
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: LD_INT 1
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 2
91913: PUSH
91914: LD_INT 2
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 1
91923: PUSH
91924: LD_INT 2
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 2
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: LD_INT 1
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 2
91954: NEG
91955: PUSH
91956: LD_INT 0
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 2
91965: NEG
91966: PUSH
91967: LD_INT 1
91969: NEG
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 2
91977: NEG
91978: PUSH
91979: LD_INT 2
91981: NEG
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92008: LD_ADDR_VAR 0 55
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: LD_INT 0
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 0
92025: PUSH
92026: LD_INT 1
92028: NEG
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PUSH
92034: LD_INT 1
92036: PUSH
92037: LD_INT 0
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 1
92046: PUSH
92047: LD_INT 1
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 0
92056: PUSH
92057: LD_INT 1
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 1
92066: NEG
92067: PUSH
92068: LD_INT 0
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 1
92077: NEG
92078: PUSH
92079: LD_INT 1
92081: NEG
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 1
92089: NEG
92090: PUSH
92091: LD_INT 2
92093: NEG
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_INT 0
92101: PUSH
92102: LD_INT 2
92104: NEG
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PUSH
92110: LD_INT 1
92112: PUSH
92113: LD_INT 1
92115: NEG
92116: PUSH
92117: EMPTY
92118: LIST
92119: LIST
92120: PUSH
92121: LD_INT 2
92123: PUSH
92124: LD_INT 0
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: LD_INT 2
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 2
92143: PUSH
92144: LD_INT 2
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: LD_INT 1
92153: PUSH
92154: LD_INT 2
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 0
92163: PUSH
92164: LD_INT 2
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: LD_INT 1
92173: NEG
92174: PUSH
92175: LD_INT 1
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 2
92184: NEG
92185: PUSH
92186: LD_INT 0
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 2
92195: NEG
92196: PUSH
92197: LD_INT 1
92199: NEG
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 2
92207: NEG
92208: PUSH
92209: LD_INT 2
92211: NEG
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92238: LD_ADDR_VAR 0 56
92242: PUSH
92243: LD_INT 0
92245: PUSH
92246: LD_INT 0
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 0
92255: PUSH
92256: LD_INT 1
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 1
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 1
92276: PUSH
92277: LD_INT 1
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 0
92286: PUSH
92287: LD_INT 1
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 1
92296: NEG
92297: PUSH
92298: LD_INT 0
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 1
92307: NEG
92308: PUSH
92309: LD_INT 1
92311: NEG
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 1
92319: NEG
92320: PUSH
92321: LD_INT 2
92323: NEG
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 0
92331: PUSH
92332: LD_INT 2
92334: NEG
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 1
92342: PUSH
92343: LD_INT 1
92345: NEG
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 2
92353: PUSH
92354: LD_INT 0
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 2
92363: PUSH
92364: LD_INT 1
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 2
92373: PUSH
92374: LD_INT 2
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 1
92383: PUSH
92384: LD_INT 2
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 0
92393: PUSH
92394: LD_INT 2
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 1
92403: NEG
92404: PUSH
92405: LD_INT 1
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 2
92414: NEG
92415: PUSH
92416: LD_INT 0
92418: PUSH
92419: EMPTY
92420: LIST
92421: LIST
92422: PUSH
92423: LD_INT 2
92425: NEG
92426: PUSH
92427: LD_INT 1
92429: NEG
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 2
92437: NEG
92438: PUSH
92439: LD_INT 2
92441: NEG
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92468: LD_ADDR_VAR 0 57
92472: PUSH
92473: LD_INT 0
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 0
92485: PUSH
92486: LD_INT 1
92488: NEG
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: LD_INT 0
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 1
92506: PUSH
92507: LD_INT 1
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 0
92516: PUSH
92517: LD_INT 1
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 1
92526: NEG
92527: PUSH
92528: LD_INT 0
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 1
92537: NEG
92538: PUSH
92539: LD_INT 1
92541: NEG
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 1
92549: NEG
92550: PUSH
92551: LD_INT 2
92553: NEG
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 0
92561: PUSH
92562: LD_INT 2
92564: NEG
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: LD_INT 1
92575: NEG
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: LD_INT 2
92583: PUSH
92584: LD_INT 0
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: LD_INT 1
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 2
92603: PUSH
92604: LD_INT 2
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 1
92613: PUSH
92614: LD_INT 2
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: LD_INT 0
92623: PUSH
92624: LD_INT 2
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 1
92633: NEG
92634: PUSH
92635: LD_INT 1
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 2
92644: NEG
92645: PUSH
92646: LD_INT 0
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: LD_INT 2
92655: NEG
92656: PUSH
92657: LD_INT 1
92659: NEG
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 2
92667: NEG
92668: PUSH
92669: LD_INT 2
92671: NEG
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92698: LD_ADDR_VAR 0 58
92702: PUSH
92703: LD_INT 0
92705: PUSH
92706: LD_INT 0
92708: PUSH
92709: EMPTY
92710: LIST
92711: LIST
92712: PUSH
92713: LD_INT 0
92715: PUSH
92716: LD_INT 1
92718: NEG
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PUSH
92724: LD_INT 1
92726: PUSH
92727: LD_INT 0
92729: PUSH
92730: EMPTY
92731: LIST
92732: LIST
92733: PUSH
92734: LD_INT 1
92736: PUSH
92737: LD_INT 1
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 0
92746: PUSH
92747: LD_INT 1
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 1
92756: NEG
92757: PUSH
92758: LD_INT 0
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 1
92767: NEG
92768: PUSH
92769: LD_INT 1
92771: NEG
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 1
92779: NEG
92780: PUSH
92781: LD_INT 2
92783: NEG
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 0
92791: PUSH
92792: LD_INT 2
92794: NEG
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: LD_INT 1
92802: PUSH
92803: LD_INT 1
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 2
92813: PUSH
92814: LD_INT 0
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 2
92823: PUSH
92824: LD_INT 1
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 2
92833: PUSH
92834: LD_INT 2
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 1
92843: PUSH
92844: LD_INT 2
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: LD_INT 0
92853: PUSH
92854: LD_INT 2
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: NEG
92864: PUSH
92865: LD_INT 1
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 2
92874: NEG
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 2
92885: NEG
92886: PUSH
92887: LD_INT 1
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 2
92897: NEG
92898: PUSH
92899: LD_INT 2
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92928: LD_ADDR_VAR 0 59
92932: PUSH
92933: LD_INT 0
92935: PUSH
92936: LD_INT 0
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 0
92945: PUSH
92946: LD_INT 1
92948: NEG
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 1
92956: PUSH
92957: LD_INT 0
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 1
92966: PUSH
92967: LD_INT 1
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 0
92976: PUSH
92977: LD_INT 1
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 1
92986: NEG
92987: PUSH
92988: LD_INT 0
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 1
92997: NEG
92998: PUSH
92999: LD_INT 1
93001: NEG
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93016: LD_ADDR_VAR 0 60
93020: PUSH
93021: LD_INT 0
93023: PUSH
93024: LD_INT 0
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 0
93033: PUSH
93034: LD_INT 1
93036: NEG
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 1
93044: PUSH
93045: LD_INT 0
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 1
93054: PUSH
93055: LD_INT 1
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 0
93064: PUSH
93065: LD_INT 1
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 1
93074: NEG
93075: PUSH
93076: LD_INT 0
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 1
93085: NEG
93086: PUSH
93087: LD_INT 1
93089: NEG
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93104: LD_ADDR_VAR 0 61
93108: PUSH
93109: LD_INT 0
93111: PUSH
93112: LD_INT 0
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 0
93121: PUSH
93122: LD_INT 1
93124: NEG
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 1
93132: PUSH
93133: LD_INT 0
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 1
93142: PUSH
93143: LD_INT 1
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 0
93152: PUSH
93153: LD_INT 1
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 1
93162: NEG
93163: PUSH
93164: LD_INT 0
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 1
93173: NEG
93174: PUSH
93175: LD_INT 1
93177: NEG
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: EMPTY
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93192: LD_ADDR_VAR 0 62
93196: PUSH
93197: LD_INT 0
93199: PUSH
93200: LD_INT 0
93202: PUSH
93203: EMPTY
93204: LIST
93205: LIST
93206: PUSH
93207: LD_INT 0
93209: PUSH
93210: LD_INT 1
93212: NEG
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: LD_INT 1
93220: PUSH
93221: LD_INT 0
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: PUSH
93228: LD_INT 1
93230: PUSH
93231: LD_INT 1
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 0
93240: PUSH
93241: LD_INT 1
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 1
93250: NEG
93251: PUSH
93252: LD_INT 0
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 1
93261: NEG
93262: PUSH
93263: LD_INT 1
93265: NEG
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: EMPTY
93272: LIST
93273: LIST
93274: LIST
93275: LIST
93276: LIST
93277: LIST
93278: LIST
93279: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93280: LD_ADDR_VAR 0 63
93284: PUSH
93285: LD_INT 0
93287: PUSH
93288: LD_INT 0
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 0
93297: PUSH
93298: LD_INT 1
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: LD_INT 0
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 1
93318: PUSH
93319: LD_INT 1
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: PUSH
93326: LD_INT 0
93328: PUSH
93329: LD_INT 1
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 1
93338: NEG
93339: PUSH
93340: LD_INT 0
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: NEG
93350: PUSH
93351: LD_INT 1
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93368: LD_ADDR_VAR 0 64
93372: PUSH
93373: LD_INT 0
93375: PUSH
93376: LD_INT 0
93378: PUSH
93379: EMPTY
93380: LIST
93381: LIST
93382: PUSH
93383: LD_INT 0
93385: PUSH
93386: LD_INT 1
93388: NEG
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: LD_INT 0
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 1
93406: PUSH
93407: LD_INT 1
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 0
93416: PUSH
93417: LD_INT 1
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 1
93426: NEG
93427: PUSH
93428: LD_INT 0
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 1
93437: NEG
93438: PUSH
93439: LD_INT 1
93441: NEG
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: ST_TO_ADDR
// end ; 1 :
93456: GO 99353
93458: LD_INT 1
93460: DOUBLE
93461: EQUAL
93462: IFTRUE 93466
93464: GO 96089
93466: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93467: LD_ADDR_VAR 0 11
93471: PUSH
93472: LD_INT 1
93474: NEG
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 0
93486: PUSH
93487: LD_INT 3
93489: NEG
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 1
93497: PUSH
93498: LD_INT 2
93500: NEG
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: LIST
93510: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93511: LD_ADDR_VAR 0 12
93515: PUSH
93516: LD_INT 2
93518: PUSH
93519: LD_INT 1
93521: NEG
93522: PUSH
93523: EMPTY
93524: LIST
93525: LIST
93526: PUSH
93527: LD_INT 3
93529: PUSH
93530: LD_INT 0
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 3
93539: PUSH
93540: LD_INT 1
93542: PUSH
93543: EMPTY
93544: LIST
93545: LIST
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: LIST
93551: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93552: LD_ADDR_VAR 0 13
93556: PUSH
93557: LD_INT 3
93559: PUSH
93560: LD_INT 2
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 3
93569: PUSH
93570: LD_INT 3
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 2
93579: PUSH
93580: LD_INT 3
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: LIST
93591: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93592: LD_ADDR_VAR 0 14
93596: PUSH
93597: LD_INT 1
93599: PUSH
93600: LD_INT 3
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: LD_INT 0
93609: PUSH
93610: LD_INT 3
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 1
93619: NEG
93620: PUSH
93621: LD_INT 2
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: LIST
93632: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93633: LD_ADDR_VAR 0 15
93637: PUSH
93638: LD_INT 2
93640: NEG
93641: PUSH
93642: LD_INT 1
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 3
93651: NEG
93652: PUSH
93653: LD_INT 0
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PUSH
93660: LD_INT 3
93662: NEG
93663: PUSH
93664: LD_INT 1
93666: NEG
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93677: LD_ADDR_VAR 0 16
93681: PUSH
93682: LD_INT 2
93684: NEG
93685: PUSH
93686: LD_INT 3
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 3
93696: NEG
93697: PUSH
93698: LD_INT 2
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 3
93708: NEG
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: LIST
93722: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93723: LD_ADDR_VAR 0 17
93727: PUSH
93728: LD_INT 1
93730: NEG
93731: PUSH
93732: LD_INT 3
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 0
93742: PUSH
93743: LD_INT 3
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 1
93753: PUSH
93754: LD_INT 2
93756: NEG
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: LIST
93766: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93767: LD_ADDR_VAR 0 18
93771: PUSH
93772: LD_INT 2
93774: PUSH
93775: LD_INT 1
93777: NEG
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 3
93785: PUSH
93786: LD_INT 0
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 3
93795: PUSH
93796: LD_INT 1
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: LIST
93807: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93808: LD_ADDR_VAR 0 19
93812: PUSH
93813: LD_INT 3
93815: PUSH
93816: LD_INT 2
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 3
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 2
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: LIST
93847: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93848: LD_ADDR_VAR 0 20
93852: PUSH
93853: LD_INT 1
93855: PUSH
93856: LD_INT 3
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: LD_INT 3
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 1
93875: NEG
93876: PUSH
93877: LD_INT 2
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: LIST
93888: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93889: LD_ADDR_VAR 0 21
93893: PUSH
93894: LD_INT 2
93896: NEG
93897: PUSH
93898: LD_INT 1
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: PUSH
93905: LD_INT 3
93907: NEG
93908: PUSH
93909: LD_INT 0
93911: PUSH
93912: EMPTY
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 3
93918: NEG
93919: PUSH
93920: LD_INT 1
93922: NEG
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: LIST
93932: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93933: LD_ADDR_VAR 0 22
93937: PUSH
93938: LD_INT 2
93940: NEG
93941: PUSH
93942: LD_INT 3
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 3
93952: NEG
93953: PUSH
93954: LD_INT 2
93956: NEG
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 3
93964: NEG
93965: PUSH
93966: LD_INT 3
93968: NEG
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: LIST
93978: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93979: LD_ADDR_VAR 0 23
93983: PUSH
93984: LD_INT 0
93986: PUSH
93987: LD_INT 3
93989: NEG
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 1
93997: NEG
93998: PUSH
93999: LD_INT 4
94001: NEG
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 1
94009: PUSH
94010: LD_INT 3
94012: NEG
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: LIST
94022: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
94023: LD_ADDR_VAR 0 24
94027: PUSH
94028: LD_INT 3
94030: PUSH
94031: LD_INT 0
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 3
94040: PUSH
94041: LD_INT 1
94043: NEG
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 4
94051: PUSH
94052: LD_INT 1
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: LIST
94063: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
94064: LD_ADDR_VAR 0 25
94068: PUSH
94069: LD_INT 3
94071: PUSH
94072: LD_INT 3
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 4
94081: PUSH
94082: LD_INT 3
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 3
94091: PUSH
94092: LD_INT 4
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: LIST
94103: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94104: LD_ADDR_VAR 0 26
94108: PUSH
94109: LD_INT 0
94111: PUSH
94112: LD_INT 3
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 1
94131: NEG
94132: PUSH
94133: LD_INT 3
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: EMPTY
94141: LIST
94142: LIST
94143: LIST
94144: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94145: LD_ADDR_VAR 0 27
94149: PUSH
94150: LD_INT 3
94152: NEG
94153: PUSH
94154: LD_INT 0
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 3
94163: NEG
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 4
94174: NEG
94175: PUSH
94176: LD_INT 1
94178: NEG
94179: PUSH
94180: EMPTY
94181: LIST
94182: LIST
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: LIST
94188: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94189: LD_ADDR_VAR 0 28
94193: PUSH
94194: LD_INT 3
94196: NEG
94197: PUSH
94198: LD_INT 3
94200: NEG
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 3
94208: NEG
94209: PUSH
94210: LD_INT 4
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 4
94220: NEG
94221: PUSH
94222: LD_INT 3
94224: NEG
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: EMPTY
94231: LIST
94232: LIST
94233: LIST
94234: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
94235: LD_ADDR_VAR 0 29
94239: PUSH
94240: LD_INT 1
94242: NEG
94243: PUSH
94244: LD_INT 3
94246: NEG
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 0
94254: PUSH
94255: LD_INT 3
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 1
94265: PUSH
94266: LD_INT 2
94268: NEG
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 1
94276: NEG
94277: PUSH
94278: LD_INT 4
94280: NEG
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 0
94288: PUSH
94289: LD_INT 4
94291: NEG
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 1
94299: PUSH
94300: LD_INT 3
94302: NEG
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 1
94310: NEG
94311: PUSH
94312: LD_INT 5
94314: NEG
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: PUSH
94320: LD_INT 0
94322: PUSH
94323: LD_INT 5
94325: NEG
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 1
94333: PUSH
94334: LD_INT 4
94336: NEG
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 1
94344: NEG
94345: PUSH
94346: LD_INT 6
94348: NEG
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: LD_INT 6
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 1
94367: PUSH
94368: LD_INT 5
94370: NEG
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94390: LD_ADDR_VAR 0 30
94394: PUSH
94395: LD_INT 2
94397: PUSH
94398: LD_INT 1
94400: NEG
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 3
94408: PUSH
94409: LD_INT 0
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 3
94418: PUSH
94419: LD_INT 1
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 3
94428: PUSH
94429: LD_INT 1
94431: NEG
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 4
94439: PUSH
94440: LD_INT 0
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 4
94449: PUSH
94450: LD_INT 1
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 4
94459: PUSH
94460: LD_INT 1
94462: NEG
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 5
94470: PUSH
94471: LD_INT 0
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 5
94480: PUSH
94481: LD_INT 1
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 5
94490: PUSH
94491: LD_INT 1
94493: NEG
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 6
94501: PUSH
94502: LD_INT 0
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 6
94511: PUSH
94512: LD_INT 1
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94533: LD_ADDR_VAR 0 31
94537: PUSH
94538: LD_INT 3
94540: PUSH
94541: LD_INT 2
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 3
94550: PUSH
94551: LD_INT 3
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 2
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: PUSH
94568: LD_INT 4
94570: PUSH
94571: LD_INT 3
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 4
94580: PUSH
94581: LD_INT 4
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 3
94590: PUSH
94591: LD_INT 4
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 5
94600: PUSH
94601: LD_INT 4
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 5
94610: PUSH
94611: LD_INT 5
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 4
94620: PUSH
94621: LD_INT 5
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 6
94630: PUSH
94631: LD_INT 5
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 6
94640: PUSH
94641: LD_INT 6
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 5
94650: PUSH
94651: LD_INT 6
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94672: LD_ADDR_VAR 0 32
94676: PUSH
94677: LD_INT 1
94679: PUSH
94680: LD_INT 3
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 0
94689: PUSH
94690: LD_INT 3
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 1
94699: NEG
94700: PUSH
94701: LD_INT 2
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 1
94710: PUSH
94711: LD_INT 4
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 0
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 1
94730: NEG
94731: PUSH
94732: LD_INT 3
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: LD_INT 5
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: PUSH
94749: LD_INT 0
94751: PUSH
94752: LD_INT 5
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: PUSH
94759: LD_INT 1
94761: NEG
94762: PUSH
94763: LD_INT 4
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 1
94772: PUSH
94773: LD_INT 6
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 0
94782: PUSH
94783: LD_INT 6
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 1
94792: NEG
94793: PUSH
94794: LD_INT 5
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94815: LD_ADDR_VAR 0 33
94819: PUSH
94820: LD_INT 2
94822: NEG
94823: PUSH
94824: LD_INT 1
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 3
94833: NEG
94834: PUSH
94835: LD_INT 0
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 3
94844: NEG
94845: PUSH
94846: LD_INT 1
94848: NEG
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 3
94856: NEG
94857: PUSH
94858: LD_INT 1
94860: PUSH
94861: EMPTY
94862: LIST
94863: LIST
94864: PUSH
94865: LD_INT 4
94867: NEG
94868: PUSH
94869: LD_INT 0
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 4
94878: NEG
94879: PUSH
94880: LD_INT 1
94882: NEG
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 4
94890: NEG
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 5
94901: NEG
94902: PUSH
94903: LD_INT 0
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 5
94912: NEG
94913: PUSH
94914: LD_INT 1
94916: NEG
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 5
94924: NEG
94925: PUSH
94926: LD_INT 1
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: PUSH
94933: LD_INT 6
94935: NEG
94936: PUSH
94937: LD_INT 0
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 6
94946: NEG
94947: PUSH
94948: LD_INT 1
94950: NEG
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94970: LD_ADDR_VAR 0 34
94974: PUSH
94975: LD_INT 2
94977: NEG
94978: PUSH
94979: LD_INT 3
94981: NEG
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: LD_INT 3
94989: NEG
94990: PUSH
94991: LD_INT 2
94993: NEG
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: LD_INT 3
95001: NEG
95002: PUSH
95003: LD_INT 3
95005: NEG
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 3
95013: NEG
95014: PUSH
95015: LD_INT 4
95017: NEG
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 4
95025: NEG
95026: PUSH
95027: LD_INT 3
95029: NEG
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: PUSH
95035: LD_INT 4
95037: NEG
95038: PUSH
95039: LD_INT 4
95041: NEG
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: PUSH
95047: LD_INT 4
95049: NEG
95050: PUSH
95051: LD_INT 5
95053: NEG
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: PUSH
95059: LD_INT 5
95061: NEG
95062: PUSH
95063: LD_INT 4
95065: NEG
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: LD_INT 5
95073: NEG
95074: PUSH
95075: LD_INT 5
95077: NEG
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 5
95085: NEG
95086: PUSH
95087: LD_INT 6
95089: NEG
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: PUSH
95095: LD_INT 6
95097: NEG
95098: PUSH
95099: LD_INT 5
95101: NEG
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_INT 6
95109: NEG
95110: PUSH
95111: LD_INT 6
95113: NEG
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: LIST
95132: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95133: LD_ADDR_VAR 0 41
95137: PUSH
95138: LD_INT 0
95140: PUSH
95141: LD_INT 2
95143: NEG
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: LD_INT 3
95155: NEG
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: LD_INT 1
95163: PUSH
95164: LD_INT 2
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: LIST
95176: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95177: LD_ADDR_VAR 0 42
95181: PUSH
95182: LD_INT 2
95184: PUSH
95185: LD_INT 0
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 2
95194: PUSH
95195: LD_INT 1
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 3
95205: PUSH
95206: LD_INT 1
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: LIST
95217: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
95218: LD_ADDR_VAR 0 43
95222: PUSH
95223: LD_INT 2
95225: PUSH
95226: LD_INT 2
95228: PUSH
95229: EMPTY
95230: LIST
95231: LIST
95232: PUSH
95233: LD_INT 3
95235: PUSH
95236: LD_INT 2
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 2
95245: PUSH
95246: LD_INT 3
95248: PUSH
95249: EMPTY
95250: LIST
95251: LIST
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: LIST
95257: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
95258: LD_ADDR_VAR 0 44
95262: PUSH
95263: LD_INT 0
95265: PUSH
95266: LD_INT 2
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 1
95275: PUSH
95276: LD_INT 3
95278: PUSH
95279: EMPTY
95280: LIST
95281: LIST
95282: PUSH
95283: LD_INT 1
95285: NEG
95286: PUSH
95287: LD_INT 2
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: LIST
95298: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
95299: LD_ADDR_VAR 0 45
95303: PUSH
95304: LD_INT 2
95306: NEG
95307: PUSH
95308: LD_INT 0
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 2
95317: NEG
95318: PUSH
95319: LD_INT 1
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 3
95328: NEG
95329: PUSH
95330: LD_INT 1
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: LIST
95342: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
95343: LD_ADDR_VAR 0 46
95347: PUSH
95348: LD_INT 2
95350: NEG
95351: PUSH
95352: LD_INT 2
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 2
95362: NEG
95363: PUSH
95364: LD_INT 3
95366: NEG
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: PUSH
95372: LD_INT 3
95374: NEG
95375: PUSH
95376: LD_INT 2
95378: NEG
95379: PUSH
95380: EMPTY
95381: LIST
95382: LIST
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: LIST
95388: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95389: LD_ADDR_VAR 0 47
95393: PUSH
95394: LD_INT 2
95396: NEG
95397: PUSH
95398: LD_INT 3
95400: NEG
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 1
95408: NEG
95409: PUSH
95410: LD_INT 3
95412: NEG
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95422: LD_ADDR_VAR 0 48
95426: PUSH
95427: LD_INT 1
95429: PUSH
95430: LD_INT 2
95432: NEG
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 2
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95453: LD_ADDR_VAR 0 49
95457: PUSH
95458: LD_INT 3
95460: PUSH
95461: LD_INT 1
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: PUSH
95468: LD_INT 3
95470: PUSH
95471: LD_INT 2
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: PUSH
95478: EMPTY
95479: LIST
95480: LIST
95481: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95482: LD_ADDR_VAR 0 50
95486: PUSH
95487: LD_INT 2
95489: PUSH
95490: LD_INT 3
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 1
95499: PUSH
95500: LD_INT 3
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95511: LD_ADDR_VAR 0 51
95515: PUSH
95516: LD_INT 1
95518: NEG
95519: PUSH
95520: LD_INT 2
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 2
95529: NEG
95530: PUSH
95531: LD_INT 1
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95542: LD_ADDR_VAR 0 52
95546: PUSH
95547: LD_INT 3
95549: NEG
95550: PUSH
95551: LD_INT 1
95553: NEG
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: PUSH
95559: LD_INT 3
95561: NEG
95562: PUSH
95563: LD_INT 2
95565: NEG
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95575: LD_ADDR_VAR 0 53
95579: PUSH
95580: LD_INT 1
95582: NEG
95583: PUSH
95584: LD_INT 3
95586: NEG
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 0
95594: PUSH
95595: LD_INT 3
95597: NEG
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 1
95605: PUSH
95606: LD_INT 2
95608: NEG
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: LIST
95618: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95619: LD_ADDR_VAR 0 54
95623: PUSH
95624: LD_INT 2
95626: PUSH
95627: LD_INT 1
95629: NEG
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 3
95637: PUSH
95638: LD_INT 0
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 3
95647: PUSH
95648: LD_INT 1
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: EMPTY
95656: LIST
95657: LIST
95658: LIST
95659: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95660: LD_ADDR_VAR 0 55
95664: PUSH
95665: LD_INT 3
95667: PUSH
95668: LD_INT 2
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 3
95677: PUSH
95678: LD_INT 3
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 2
95687: PUSH
95688: LD_INT 3
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: LIST
95699: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95700: LD_ADDR_VAR 0 56
95704: PUSH
95705: LD_INT 1
95707: PUSH
95708: LD_INT 3
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: LD_INT 3
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 1
95727: NEG
95728: PUSH
95729: LD_INT 2
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: LIST
95740: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95741: LD_ADDR_VAR 0 57
95745: PUSH
95746: LD_INT 2
95748: NEG
95749: PUSH
95750: LD_INT 1
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 3
95759: NEG
95760: PUSH
95761: LD_INT 0
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 3
95770: NEG
95771: PUSH
95772: LD_INT 1
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: LIST
95784: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95785: LD_ADDR_VAR 0 58
95789: PUSH
95790: LD_INT 2
95792: NEG
95793: PUSH
95794: LD_INT 3
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 3
95804: NEG
95805: PUSH
95806: LD_INT 2
95808: NEG
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 3
95816: NEG
95817: PUSH
95818: LD_INT 3
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: LIST
95830: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95831: LD_ADDR_VAR 0 59
95835: PUSH
95836: LD_INT 1
95838: NEG
95839: PUSH
95840: LD_INT 2
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: LD_INT 2
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 1
95861: PUSH
95862: LD_INT 1
95864: NEG
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: LIST
95874: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95875: LD_ADDR_VAR 0 60
95879: PUSH
95880: LD_INT 1
95882: PUSH
95883: LD_INT 1
95885: NEG
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 2
95893: PUSH
95894: LD_INT 0
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: PUSH
95901: LD_INT 2
95903: PUSH
95904: LD_INT 1
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: EMPTY
95912: LIST
95913: LIST
95914: LIST
95915: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95916: LD_ADDR_VAR 0 61
95920: PUSH
95921: LD_INT 2
95923: PUSH
95924: LD_INT 1
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 2
95933: PUSH
95934: LD_INT 2
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 1
95943: PUSH
95944: LD_INT 2
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: LIST
95955: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95956: LD_ADDR_VAR 0 62
95960: PUSH
95961: LD_INT 1
95963: PUSH
95964: LD_INT 2
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: LD_INT 2
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 1
95983: NEG
95984: PUSH
95985: LD_INT 1
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: LIST
95996: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95997: LD_ADDR_VAR 0 63
96001: PUSH
96002: LD_INT 1
96004: NEG
96005: PUSH
96006: LD_INT 1
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: LD_INT 2
96015: NEG
96016: PUSH
96017: LD_INT 0
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PUSH
96024: LD_INT 2
96026: NEG
96027: PUSH
96028: LD_INT 1
96030: NEG
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: LIST
96040: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96041: LD_ADDR_VAR 0 64
96045: PUSH
96046: LD_INT 1
96048: NEG
96049: PUSH
96050: LD_INT 2
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 2
96060: NEG
96061: PUSH
96062: LD_INT 1
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 2
96072: NEG
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: LIST
96086: ST_TO_ADDR
// end ; 2 :
96087: GO 99353
96089: LD_INT 2
96091: DOUBLE
96092: EQUAL
96093: IFTRUE 96097
96095: GO 99352
96097: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96098: LD_ADDR_VAR 0 29
96102: PUSH
96103: LD_INT 4
96105: PUSH
96106: LD_INT 0
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PUSH
96113: LD_INT 4
96115: PUSH
96116: LD_INT 1
96118: NEG
96119: PUSH
96120: EMPTY
96121: LIST
96122: LIST
96123: PUSH
96124: LD_INT 5
96126: PUSH
96127: LD_INT 0
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: LD_INT 5
96136: PUSH
96137: LD_INT 1
96139: PUSH
96140: EMPTY
96141: LIST
96142: LIST
96143: PUSH
96144: LD_INT 4
96146: PUSH
96147: LD_INT 1
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PUSH
96154: LD_INT 3
96156: PUSH
96157: LD_INT 0
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 3
96166: PUSH
96167: LD_INT 1
96169: NEG
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 3
96177: PUSH
96178: LD_INT 2
96180: NEG
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 5
96188: PUSH
96189: LD_INT 2
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 3
96198: PUSH
96199: LD_INT 3
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 3
96208: PUSH
96209: LD_INT 2
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 4
96218: PUSH
96219: LD_INT 3
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 4
96228: PUSH
96229: LD_INT 4
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: LD_INT 3
96238: PUSH
96239: LD_INT 4
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 2
96248: PUSH
96249: LD_INT 3
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: PUSH
96256: LD_INT 2
96258: PUSH
96259: LD_INT 2
96261: PUSH
96262: EMPTY
96263: LIST
96264: LIST
96265: PUSH
96266: LD_INT 4
96268: PUSH
96269: LD_INT 2
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 2
96278: PUSH
96279: LD_INT 4
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 0
96288: PUSH
96289: LD_INT 4
96291: PUSH
96292: EMPTY
96293: LIST
96294: LIST
96295: PUSH
96296: LD_INT 0
96298: PUSH
96299: LD_INT 3
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 1
96308: PUSH
96309: LD_INT 4
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: LD_INT 5
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: PUSH
96326: LD_INT 0
96328: PUSH
96329: LD_INT 5
96331: PUSH
96332: EMPTY
96333: LIST
96334: LIST
96335: PUSH
96336: LD_INT 1
96338: NEG
96339: PUSH
96340: LD_INT 4
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 1
96349: NEG
96350: PUSH
96351: LD_INT 3
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PUSH
96358: LD_INT 2
96360: PUSH
96361: LD_INT 5
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: LD_INT 2
96370: NEG
96371: PUSH
96372: LD_INT 3
96374: PUSH
96375: EMPTY
96376: LIST
96377: LIST
96378: PUSH
96379: LD_INT 3
96381: NEG
96382: PUSH
96383: LD_INT 0
96385: PUSH
96386: EMPTY
96387: LIST
96388: LIST
96389: PUSH
96390: LD_INT 3
96392: NEG
96393: PUSH
96394: LD_INT 1
96396: NEG
96397: PUSH
96398: EMPTY
96399: LIST
96400: LIST
96401: PUSH
96402: LD_INT 2
96404: NEG
96405: PUSH
96406: LD_INT 0
96408: PUSH
96409: EMPTY
96410: LIST
96411: LIST
96412: PUSH
96413: LD_INT 2
96415: NEG
96416: PUSH
96417: LD_INT 1
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 3
96426: NEG
96427: PUSH
96428: LD_INT 1
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 4
96437: NEG
96438: PUSH
96439: LD_INT 0
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 4
96448: NEG
96449: PUSH
96450: LD_INT 1
96452: NEG
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 4
96460: NEG
96461: PUSH
96462: LD_INT 2
96464: NEG
96465: PUSH
96466: EMPTY
96467: LIST
96468: LIST
96469: PUSH
96470: LD_INT 2
96472: NEG
96473: PUSH
96474: LD_INT 2
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 4
96483: NEG
96484: PUSH
96485: LD_INT 4
96487: NEG
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 4
96495: NEG
96496: PUSH
96497: LD_INT 5
96499: NEG
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 3
96507: NEG
96508: PUSH
96509: LD_INT 4
96511: NEG
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: LD_INT 3
96519: NEG
96520: PUSH
96521: LD_INT 3
96523: NEG
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: PUSH
96529: LD_INT 4
96531: NEG
96532: PUSH
96533: LD_INT 3
96535: NEG
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 5
96543: NEG
96544: PUSH
96545: LD_INT 4
96547: NEG
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 5
96555: NEG
96556: PUSH
96557: LD_INT 5
96559: NEG
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 3
96567: NEG
96568: PUSH
96569: LD_INT 5
96571: NEG
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 5
96579: NEG
96580: PUSH
96581: LD_INT 3
96583: NEG
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: PUSH
96589: EMPTY
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96636: LD_ADDR_VAR 0 30
96640: PUSH
96641: LD_INT 4
96643: PUSH
96644: LD_INT 4
96646: PUSH
96647: EMPTY
96648: LIST
96649: LIST
96650: PUSH
96651: LD_INT 4
96653: PUSH
96654: LD_INT 3
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: PUSH
96661: LD_INT 5
96663: PUSH
96664: LD_INT 4
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: LD_INT 5
96673: PUSH
96674: LD_INT 5
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: PUSH
96681: LD_INT 4
96683: PUSH
96684: LD_INT 5
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 3
96693: PUSH
96694: LD_INT 4
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: PUSH
96701: LD_INT 3
96703: PUSH
96704: LD_INT 3
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: PUSH
96711: LD_INT 5
96713: PUSH
96714: LD_INT 3
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 3
96723: PUSH
96724: LD_INT 5
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 0
96733: PUSH
96734: LD_INT 3
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 0
96743: PUSH
96744: LD_INT 2
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 1
96753: PUSH
96754: LD_INT 3
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: PUSH
96761: LD_INT 1
96763: PUSH
96764: LD_INT 4
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 0
96773: PUSH
96774: LD_INT 4
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 1
96783: NEG
96784: PUSH
96785: LD_INT 3
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: LD_INT 1
96794: NEG
96795: PUSH
96796: LD_INT 2
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 2
96805: PUSH
96806: LD_INT 4
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: LD_INT 2
96815: NEG
96816: PUSH
96817: LD_INT 2
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 4
96826: NEG
96827: PUSH
96828: LD_INT 0
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 4
96837: NEG
96838: PUSH
96839: LD_INT 1
96841: NEG
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: PUSH
96847: LD_INT 3
96849: NEG
96850: PUSH
96851: LD_INT 0
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 3
96860: NEG
96861: PUSH
96862: LD_INT 1
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 4
96871: NEG
96872: PUSH
96873: LD_INT 1
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 5
96882: NEG
96883: PUSH
96884: LD_INT 0
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 5
96893: NEG
96894: PUSH
96895: LD_INT 1
96897: NEG
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 5
96905: NEG
96906: PUSH
96907: LD_INT 2
96909: NEG
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 3
96917: NEG
96918: PUSH
96919: LD_INT 2
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 3
96928: NEG
96929: PUSH
96930: LD_INT 3
96932: NEG
96933: PUSH
96934: EMPTY
96935: LIST
96936: LIST
96937: PUSH
96938: LD_INT 3
96940: NEG
96941: PUSH
96942: LD_INT 4
96944: NEG
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PUSH
96950: LD_INT 2
96952: NEG
96953: PUSH
96954: LD_INT 3
96956: NEG
96957: PUSH
96958: EMPTY
96959: LIST
96960: LIST
96961: PUSH
96962: LD_INT 2
96964: NEG
96965: PUSH
96966: LD_INT 2
96968: NEG
96969: PUSH
96970: EMPTY
96971: LIST
96972: LIST
96973: PUSH
96974: LD_INT 3
96976: NEG
96977: PUSH
96978: LD_INT 2
96980: NEG
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: LD_INT 4
96988: NEG
96989: PUSH
96990: LD_INT 3
96992: NEG
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: PUSH
96998: LD_INT 4
97000: NEG
97001: PUSH
97002: LD_INT 4
97004: NEG
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: PUSH
97010: LD_INT 2
97012: NEG
97013: PUSH
97014: LD_INT 4
97016: NEG
97017: PUSH
97018: EMPTY
97019: LIST
97020: LIST
97021: PUSH
97022: LD_INT 4
97024: NEG
97025: PUSH
97026: LD_INT 2
97028: NEG
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 0
97036: PUSH
97037: LD_INT 4
97039: NEG
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 0
97047: PUSH
97048: LD_INT 5
97050: NEG
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 1
97058: PUSH
97059: LD_INT 4
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 1
97069: PUSH
97070: LD_INT 3
97072: NEG
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: LD_INT 3
97083: NEG
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: LD_INT 1
97091: NEG
97092: PUSH
97093: LD_INT 4
97095: NEG
97096: PUSH
97097: EMPTY
97098: LIST
97099: LIST
97100: PUSH
97101: LD_INT 1
97103: NEG
97104: PUSH
97105: LD_INT 5
97107: NEG
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_INT 2
97115: PUSH
97116: LD_INT 3
97118: NEG
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 2
97126: NEG
97127: PUSH
97128: LD_INT 5
97130: NEG
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: LIST
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: LIST
97179: LIST
97180: LIST
97181: LIST
97182: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97183: LD_ADDR_VAR 0 31
97187: PUSH
97188: LD_INT 0
97190: PUSH
97191: LD_INT 4
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PUSH
97198: LD_INT 0
97200: PUSH
97201: LD_INT 3
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 1
97210: PUSH
97211: LD_INT 4
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 1
97220: PUSH
97221: LD_INT 5
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: LD_INT 0
97230: PUSH
97231: LD_INT 5
97233: PUSH
97234: EMPTY
97235: LIST
97236: LIST
97237: PUSH
97238: LD_INT 1
97240: NEG
97241: PUSH
97242: LD_INT 4
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: LD_INT 1
97251: NEG
97252: PUSH
97253: LD_INT 3
97255: PUSH
97256: EMPTY
97257: LIST
97258: LIST
97259: PUSH
97260: LD_INT 2
97262: PUSH
97263: LD_INT 5
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: PUSH
97270: LD_INT 2
97272: NEG
97273: PUSH
97274: LD_INT 3
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: PUSH
97281: LD_INT 3
97283: NEG
97284: PUSH
97285: LD_INT 0
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 3
97294: NEG
97295: PUSH
97296: LD_INT 1
97298: NEG
97299: PUSH
97300: EMPTY
97301: LIST
97302: LIST
97303: PUSH
97304: LD_INT 2
97306: NEG
97307: PUSH
97308: LD_INT 0
97310: PUSH
97311: EMPTY
97312: LIST
97313: LIST
97314: PUSH
97315: LD_INT 2
97317: NEG
97318: PUSH
97319: LD_INT 1
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 3
97328: NEG
97329: PUSH
97330: LD_INT 1
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 4
97339: NEG
97340: PUSH
97341: LD_INT 0
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 4
97350: NEG
97351: PUSH
97352: LD_INT 1
97354: NEG
97355: PUSH
97356: EMPTY
97357: LIST
97358: LIST
97359: PUSH
97360: LD_INT 4
97362: NEG
97363: PUSH
97364: LD_INT 2
97366: NEG
97367: PUSH
97368: EMPTY
97369: LIST
97370: LIST
97371: PUSH
97372: LD_INT 2
97374: NEG
97375: PUSH
97376: LD_INT 2
97378: PUSH
97379: EMPTY
97380: LIST
97381: LIST
97382: PUSH
97383: LD_INT 4
97385: NEG
97386: PUSH
97387: LD_INT 4
97389: NEG
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PUSH
97395: LD_INT 4
97397: NEG
97398: PUSH
97399: LD_INT 5
97401: NEG
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 3
97409: NEG
97410: PUSH
97411: LD_INT 4
97413: NEG
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PUSH
97419: LD_INT 3
97421: NEG
97422: PUSH
97423: LD_INT 3
97425: NEG
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: PUSH
97431: LD_INT 4
97433: NEG
97434: PUSH
97435: LD_INT 3
97437: NEG
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: PUSH
97443: LD_INT 5
97445: NEG
97446: PUSH
97447: LD_INT 4
97449: NEG
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PUSH
97455: LD_INT 5
97457: NEG
97458: PUSH
97459: LD_INT 5
97461: NEG
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 3
97469: NEG
97470: PUSH
97471: LD_INT 5
97473: NEG
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: LD_INT 5
97481: NEG
97482: PUSH
97483: LD_INT 3
97485: NEG
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: LD_INT 0
97493: PUSH
97494: LD_INT 3
97496: NEG
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: LD_INT 0
97504: PUSH
97505: LD_INT 4
97507: NEG
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PUSH
97513: LD_INT 1
97515: PUSH
97516: LD_INT 3
97518: NEG
97519: PUSH
97520: EMPTY
97521: LIST
97522: LIST
97523: PUSH
97524: LD_INT 1
97526: PUSH
97527: LD_INT 2
97529: NEG
97530: PUSH
97531: EMPTY
97532: LIST
97533: LIST
97534: PUSH
97535: LD_INT 0
97537: PUSH
97538: LD_INT 2
97540: NEG
97541: PUSH
97542: EMPTY
97543: LIST
97544: LIST
97545: PUSH
97546: LD_INT 1
97548: NEG
97549: PUSH
97550: LD_INT 3
97552: NEG
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: PUSH
97558: LD_INT 1
97560: NEG
97561: PUSH
97562: LD_INT 4
97564: NEG
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 2
97572: PUSH
97573: LD_INT 2
97575: NEG
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 2
97583: NEG
97584: PUSH
97585: LD_INT 4
97587: NEG
97588: PUSH
97589: EMPTY
97590: LIST
97591: LIST
97592: PUSH
97593: LD_INT 4
97595: PUSH
97596: LD_INT 0
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: LD_INT 4
97605: PUSH
97606: LD_INT 1
97608: NEG
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: PUSH
97614: LD_INT 5
97616: PUSH
97617: LD_INT 0
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PUSH
97624: LD_INT 5
97626: PUSH
97627: LD_INT 1
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: LD_INT 4
97636: PUSH
97637: LD_INT 1
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: PUSH
97644: LD_INT 3
97646: PUSH
97647: LD_INT 0
97649: PUSH
97650: EMPTY
97651: LIST
97652: LIST
97653: PUSH
97654: LD_INT 3
97656: PUSH
97657: LD_INT 1
97659: NEG
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PUSH
97665: LD_INT 3
97667: PUSH
97668: LD_INT 2
97670: NEG
97671: PUSH
97672: EMPTY
97673: LIST
97674: LIST
97675: PUSH
97676: LD_INT 5
97678: PUSH
97679: LD_INT 2
97681: PUSH
97682: EMPTY
97683: LIST
97684: LIST
97685: PUSH
97686: EMPTY
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: LIST
97719: LIST
97720: LIST
97721: LIST
97722: LIST
97723: LIST
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97733: LD_ADDR_VAR 0 32
97737: PUSH
97738: LD_INT 4
97740: NEG
97741: PUSH
97742: LD_INT 0
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PUSH
97749: LD_INT 4
97751: NEG
97752: PUSH
97753: LD_INT 1
97755: NEG
97756: PUSH
97757: EMPTY
97758: LIST
97759: LIST
97760: PUSH
97761: LD_INT 3
97763: NEG
97764: PUSH
97765: LD_INT 0
97767: PUSH
97768: EMPTY
97769: LIST
97770: LIST
97771: PUSH
97772: LD_INT 3
97774: NEG
97775: PUSH
97776: LD_INT 1
97778: PUSH
97779: EMPTY
97780: LIST
97781: LIST
97782: PUSH
97783: LD_INT 4
97785: NEG
97786: PUSH
97787: LD_INT 1
97789: PUSH
97790: EMPTY
97791: LIST
97792: LIST
97793: PUSH
97794: LD_INT 5
97796: NEG
97797: PUSH
97798: LD_INT 0
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: PUSH
97805: LD_INT 5
97807: NEG
97808: PUSH
97809: LD_INT 1
97811: NEG
97812: PUSH
97813: EMPTY
97814: LIST
97815: LIST
97816: PUSH
97817: LD_INT 5
97819: NEG
97820: PUSH
97821: LD_INT 2
97823: NEG
97824: PUSH
97825: EMPTY
97826: LIST
97827: LIST
97828: PUSH
97829: LD_INT 3
97831: NEG
97832: PUSH
97833: LD_INT 2
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 3
97842: NEG
97843: PUSH
97844: LD_INT 3
97846: NEG
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 3
97854: NEG
97855: PUSH
97856: LD_INT 4
97858: NEG
97859: PUSH
97860: EMPTY
97861: LIST
97862: LIST
97863: PUSH
97864: LD_INT 2
97866: NEG
97867: PUSH
97868: LD_INT 3
97870: NEG
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: PUSH
97876: LD_INT 2
97878: NEG
97879: PUSH
97880: LD_INT 2
97882: NEG
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 3
97890: NEG
97891: PUSH
97892: LD_INT 2
97894: NEG
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PUSH
97900: LD_INT 4
97902: NEG
97903: PUSH
97904: LD_INT 3
97906: NEG
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 4
97914: NEG
97915: PUSH
97916: LD_INT 4
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 2
97926: NEG
97927: PUSH
97928: LD_INT 4
97930: NEG
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PUSH
97936: LD_INT 4
97938: NEG
97939: PUSH
97940: LD_INT 2
97942: NEG
97943: PUSH
97944: EMPTY
97945: LIST
97946: LIST
97947: PUSH
97948: LD_INT 0
97950: PUSH
97951: LD_INT 4
97953: NEG
97954: PUSH
97955: EMPTY
97956: LIST
97957: LIST
97958: PUSH
97959: LD_INT 0
97961: PUSH
97962: LD_INT 5
97964: NEG
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: PUSH
97970: LD_INT 1
97972: PUSH
97973: LD_INT 4
97975: NEG
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 1
97983: PUSH
97984: LD_INT 3
97986: NEG
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 0
97994: PUSH
97995: LD_INT 3
97997: NEG
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: PUSH
98003: LD_INT 1
98005: NEG
98006: PUSH
98007: LD_INT 4
98009: NEG
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: PUSH
98015: LD_INT 1
98017: NEG
98018: PUSH
98019: LD_INT 5
98021: NEG
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: PUSH
98027: LD_INT 2
98029: PUSH
98030: LD_INT 3
98032: NEG
98033: PUSH
98034: EMPTY
98035: LIST
98036: LIST
98037: PUSH
98038: LD_INT 2
98040: NEG
98041: PUSH
98042: LD_INT 5
98044: NEG
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 3
98052: PUSH
98053: LD_INT 0
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 3
98062: PUSH
98063: LD_INT 1
98065: NEG
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: PUSH
98071: LD_INT 4
98073: PUSH
98074: LD_INT 0
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 4
98083: PUSH
98084: LD_INT 1
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 3
98093: PUSH
98094: LD_INT 1
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PUSH
98101: LD_INT 2
98103: PUSH
98104: LD_INT 0
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: LD_INT 2
98113: PUSH
98114: LD_INT 1
98116: NEG
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_INT 2
98124: PUSH
98125: LD_INT 2
98127: NEG
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PUSH
98133: LD_INT 4
98135: PUSH
98136: LD_INT 2
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: PUSH
98143: LD_INT 4
98145: PUSH
98146: LD_INT 4
98148: PUSH
98149: EMPTY
98150: LIST
98151: LIST
98152: PUSH
98153: LD_INT 4
98155: PUSH
98156: LD_INT 3
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PUSH
98163: LD_INT 5
98165: PUSH
98166: LD_INT 4
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: LD_INT 5
98175: PUSH
98176: LD_INT 5
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PUSH
98183: LD_INT 4
98185: PUSH
98186: LD_INT 5
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: PUSH
98193: LD_INT 3
98195: PUSH
98196: LD_INT 4
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: PUSH
98203: LD_INT 3
98205: PUSH
98206: LD_INT 3
98208: PUSH
98209: EMPTY
98210: LIST
98211: LIST
98212: PUSH
98213: LD_INT 5
98215: PUSH
98216: LD_INT 3
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: LD_INT 3
98225: PUSH
98226: LD_INT 5
98228: PUSH
98229: EMPTY
98230: LIST
98231: LIST
98232: PUSH
98233: EMPTY
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: LIST
98279: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
98280: LD_ADDR_VAR 0 33
98284: PUSH
98285: LD_INT 4
98287: NEG
98288: PUSH
98289: LD_INT 4
98291: NEG
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PUSH
98297: LD_INT 4
98299: NEG
98300: PUSH
98301: LD_INT 5
98303: NEG
98304: PUSH
98305: EMPTY
98306: LIST
98307: LIST
98308: PUSH
98309: LD_INT 3
98311: NEG
98312: PUSH
98313: LD_INT 4
98315: NEG
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: PUSH
98321: LD_INT 3
98323: NEG
98324: PUSH
98325: LD_INT 3
98327: NEG
98328: PUSH
98329: EMPTY
98330: LIST
98331: LIST
98332: PUSH
98333: LD_INT 4
98335: NEG
98336: PUSH
98337: LD_INT 3
98339: NEG
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: PUSH
98345: LD_INT 5
98347: NEG
98348: PUSH
98349: LD_INT 4
98351: NEG
98352: PUSH
98353: EMPTY
98354: LIST
98355: LIST
98356: PUSH
98357: LD_INT 5
98359: NEG
98360: PUSH
98361: LD_INT 5
98363: NEG
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 3
98371: NEG
98372: PUSH
98373: LD_INT 5
98375: NEG
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PUSH
98381: LD_INT 5
98383: NEG
98384: PUSH
98385: LD_INT 3
98387: NEG
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: PUSH
98393: LD_INT 0
98395: PUSH
98396: LD_INT 3
98398: NEG
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: PUSH
98404: LD_INT 0
98406: PUSH
98407: LD_INT 4
98409: NEG
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: PUSH
98415: LD_INT 1
98417: PUSH
98418: LD_INT 3
98420: NEG
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PUSH
98426: LD_INT 1
98428: PUSH
98429: LD_INT 2
98431: NEG
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: PUSH
98437: LD_INT 0
98439: PUSH
98440: LD_INT 2
98442: NEG
98443: PUSH
98444: EMPTY
98445: LIST
98446: LIST
98447: PUSH
98448: LD_INT 1
98450: NEG
98451: PUSH
98452: LD_INT 3
98454: NEG
98455: PUSH
98456: EMPTY
98457: LIST
98458: LIST
98459: PUSH
98460: LD_INT 1
98462: NEG
98463: PUSH
98464: LD_INT 4
98466: NEG
98467: PUSH
98468: EMPTY
98469: LIST
98470: LIST
98471: PUSH
98472: LD_INT 2
98474: PUSH
98475: LD_INT 2
98477: NEG
98478: PUSH
98479: EMPTY
98480: LIST
98481: LIST
98482: PUSH
98483: LD_INT 2
98485: NEG
98486: PUSH
98487: LD_INT 4
98489: NEG
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PUSH
98495: LD_INT 4
98497: PUSH
98498: LD_INT 0
98500: PUSH
98501: EMPTY
98502: LIST
98503: LIST
98504: PUSH
98505: LD_INT 4
98507: PUSH
98508: LD_INT 1
98510: NEG
98511: PUSH
98512: EMPTY
98513: LIST
98514: LIST
98515: PUSH
98516: LD_INT 5
98518: PUSH
98519: LD_INT 0
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: LD_INT 5
98528: PUSH
98529: LD_INT 1
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 4
98538: PUSH
98539: LD_INT 1
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: LD_INT 3
98548: PUSH
98549: LD_INT 0
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 3
98558: PUSH
98559: LD_INT 1
98561: NEG
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: PUSH
98567: LD_INT 3
98569: PUSH
98570: LD_INT 2
98572: NEG
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 5
98580: PUSH
98581: LD_INT 2
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: PUSH
98588: LD_INT 3
98590: PUSH
98591: LD_INT 3
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 3
98600: PUSH
98601: LD_INT 2
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: LD_INT 4
98610: PUSH
98611: LD_INT 3
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: PUSH
98618: LD_INT 4
98620: PUSH
98621: LD_INT 4
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: PUSH
98628: LD_INT 3
98630: PUSH
98631: LD_INT 4
98633: PUSH
98634: EMPTY
98635: LIST
98636: LIST
98637: PUSH
98638: LD_INT 2
98640: PUSH
98641: LD_INT 3
98643: PUSH
98644: EMPTY
98645: LIST
98646: LIST
98647: PUSH
98648: LD_INT 2
98650: PUSH
98651: LD_INT 2
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: PUSH
98658: LD_INT 4
98660: PUSH
98661: LD_INT 2
98663: PUSH
98664: EMPTY
98665: LIST
98666: LIST
98667: PUSH
98668: LD_INT 2
98670: PUSH
98671: LD_INT 4
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 0
98680: PUSH
98681: LD_INT 4
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 0
98690: PUSH
98691: LD_INT 3
98693: PUSH
98694: EMPTY
98695: LIST
98696: LIST
98697: PUSH
98698: LD_INT 1
98700: PUSH
98701: LD_INT 4
98703: PUSH
98704: EMPTY
98705: LIST
98706: LIST
98707: PUSH
98708: LD_INT 1
98710: PUSH
98711: LD_INT 5
98713: PUSH
98714: EMPTY
98715: LIST
98716: LIST
98717: PUSH
98718: LD_INT 0
98720: PUSH
98721: LD_INT 5
98723: PUSH
98724: EMPTY
98725: LIST
98726: LIST
98727: PUSH
98728: LD_INT 1
98730: NEG
98731: PUSH
98732: LD_INT 4
98734: PUSH
98735: EMPTY
98736: LIST
98737: LIST
98738: PUSH
98739: LD_INT 1
98741: NEG
98742: PUSH
98743: LD_INT 3
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PUSH
98750: LD_INT 2
98752: PUSH
98753: LD_INT 5
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 2
98762: NEG
98763: PUSH
98764: LD_INT 3
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: LIST
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98818: LD_ADDR_VAR 0 34
98822: PUSH
98823: LD_INT 0
98825: PUSH
98826: LD_INT 4
98828: NEG
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 0
98836: PUSH
98837: LD_INT 5
98839: NEG
98840: PUSH
98841: EMPTY
98842: LIST
98843: LIST
98844: PUSH
98845: LD_INT 1
98847: PUSH
98848: LD_INT 4
98850: NEG
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 1
98858: PUSH
98859: LD_INT 3
98861: NEG
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: PUSH
98867: LD_INT 0
98869: PUSH
98870: LD_INT 3
98872: NEG
98873: PUSH
98874: EMPTY
98875: LIST
98876: LIST
98877: PUSH
98878: LD_INT 1
98880: NEG
98881: PUSH
98882: LD_INT 4
98884: NEG
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PUSH
98890: LD_INT 1
98892: NEG
98893: PUSH
98894: LD_INT 5
98896: NEG
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: LD_INT 2
98904: PUSH
98905: LD_INT 3
98907: NEG
98908: PUSH
98909: EMPTY
98910: LIST
98911: LIST
98912: PUSH
98913: LD_INT 2
98915: NEG
98916: PUSH
98917: LD_INT 5
98919: NEG
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_INT 3
98927: PUSH
98928: LD_INT 0
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 3
98937: PUSH
98938: LD_INT 1
98940: NEG
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 4
98948: PUSH
98949: LD_INT 0
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PUSH
98956: LD_INT 4
98958: PUSH
98959: LD_INT 1
98961: PUSH
98962: EMPTY
98963: LIST
98964: LIST
98965: PUSH
98966: LD_INT 3
98968: PUSH
98969: LD_INT 1
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PUSH
98976: LD_INT 2
98978: PUSH
98979: LD_INT 0
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 2
98988: PUSH
98989: LD_INT 1
98991: NEG
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PUSH
98997: LD_INT 2
98999: PUSH
99000: LD_INT 2
99002: NEG
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: PUSH
99008: LD_INT 4
99010: PUSH
99011: LD_INT 2
99013: PUSH
99014: EMPTY
99015: LIST
99016: LIST
99017: PUSH
99018: LD_INT 4
99020: PUSH
99021: LD_INT 4
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PUSH
99028: LD_INT 4
99030: PUSH
99031: LD_INT 3
99033: PUSH
99034: EMPTY
99035: LIST
99036: LIST
99037: PUSH
99038: LD_INT 5
99040: PUSH
99041: LD_INT 4
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PUSH
99048: LD_INT 5
99050: PUSH
99051: LD_INT 5
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: LD_INT 4
99060: PUSH
99061: LD_INT 5
99063: PUSH
99064: EMPTY
99065: LIST
99066: LIST
99067: PUSH
99068: LD_INT 3
99070: PUSH
99071: LD_INT 4
99073: PUSH
99074: EMPTY
99075: LIST
99076: LIST
99077: PUSH
99078: LD_INT 3
99080: PUSH
99081: LD_INT 3
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PUSH
99088: LD_INT 5
99090: PUSH
99091: LD_INT 3
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: PUSH
99098: LD_INT 3
99100: PUSH
99101: LD_INT 5
99103: PUSH
99104: EMPTY
99105: LIST
99106: LIST
99107: PUSH
99108: LD_INT 0
99110: PUSH
99111: LD_INT 3
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: PUSH
99118: LD_INT 0
99120: PUSH
99121: LD_INT 2
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PUSH
99128: LD_INT 1
99130: PUSH
99131: LD_INT 3
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 1
99140: PUSH
99141: LD_INT 4
99143: PUSH
99144: EMPTY
99145: LIST
99146: LIST
99147: PUSH
99148: LD_INT 0
99150: PUSH
99151: LD_INT 4
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PUSH
99158: LD_INT 1
99160: NEG
99161: PUSH
99162: LD_INT 3
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: LD_INT 1
99171: NEG
99172: PUSH
99173: LD_INT 2
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: PUSH
99180: LD_INT 2
99182: PUSH
99183: LD_INT 4
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: LD_INT 2
99192: NEG
99193: PUSH
99194: LD_INT 2
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: LD_INT 4
99203: NEG
99204: PUSH
99205: LD_INT 0
99207: PUSH
99208: EMPTY
99209: LIST
99210: LIST
99211: PUSH
99212: LD_INT 4
99214: NEG
99215: PUSH
99216: LD_INT 1
99218: NEG
99219: PUSH
99220: EMPTY
99221: LIST
99222: LIST
99223: PUSH
99224: LD_INT 3
99226: NEG
99227: PUSH
99228: LD_INT 0
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: PUSH
99235: LD_INT 3
99237: NEG
99238: PUSH
99239: LD_INT 1
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 4
99248: NEG
99249: PUSH
99250: LD_INT 1
99252: PUSH
99253: EMPTY
99254: LIST
99255: LIST
99256: PUSH
99257: LD_INT 5
99259: NEG
99260: PUSH
99261: LD_INT 0
99263: PUSH
99264: EMPTY
99265: LIST
99266: LIST
99267: PUSH
99268: LD_INT 5
99270: NEG
99271: PUSH
99272: LD_INT 1
99274: NEG
99275: PUSH
99276: EMPTY
99277: LIST
99278: LIST
99279: PUSH
99280: LD_INT 5
99282: NEG
99283: PUSH
99284: LD_INT 2
99286: NEG
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PUSH
99292: LD_INT 3
99294: NEG
99295: PUSH
99296: LD_INT 2
99298: PUSH
99299: EMPTY
99300: LIST
99301: LIST
99302: PUSH
99303: EMPTY
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: ST_TO_ADDR
// end ; end ;
99350: GO 99353
99352: POP
// case btype of b_depot , b_warehouse :
99353: LD_VAR 0 1
99357: PUSH
99358: LD_INT 0
99360: DOUBLE
99361: EQUAL
99362: IFTRUE 99372
99364: LD_INT 1
99366: DOUBLE
99367: EQUAL
99368: IFTRUE 99372
99370: GO 99573
99372: POP
// case nation of nation_american :
99373: LD_VAR 0 5
99377: PUSH
99378: LD_INT 1
99380: DOUBLE
99381: EQUAL
99382: IFTRUE 99386
99384: GO 99442
99386: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99387: LD_ADDR_VAR 0 9
99391: PUSH
99392: LD_VAR 0 11
99396: PUSH
99397: LD_VAR 0 12
99401: PUSH
99402: LD_VAR 0 13
99406: PUSH
99407: LD_VAR 0 14
99411: PUSH
99412: LD_VAR 0 15
99416: PUSH
99417: LD_VAR 0 16
99421: PUSH
99422: EMPTY
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: PUSH
99430: LD_VAR 0 4
99434: PUSH
99435: LD_INT 1
99437: PLUS
99438: ARRAY
99439: ST_TO_ADDR
99440: GO 99571
99442: LD_INT 2
99444: DOUBLE
99445: EQUAL
99446: IFTRUE 99450
99448: GO 99506
99450: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99451: LD_ADDR_VAR 0 9
99455: PUSH
99456: LD_VAR 0 17
99460: PUSH
99461: LD_VAR 0 18
99465: PUSH
99466: LD_VAR 0 19
99470: PUSH
99471: LD_VAR 0 20
99475: PUSH
99476: LD_VAR 0 21
99480: PUSH
99481: LD_VAR 0 22
99485: PUSH
99486: EMPTY
99487: LIST
99488: LIST
99489: LIST
99490: LIST
99491: LIST
99492: LIST
99493: PUSH
99494: LD_VAR 0 4
99498: PUSH
99499: LD_INT 1
99501: PLUS
99502: ARRAY
99503: ST_TO_ADDR
99504: GO 99571
99506: LD_INT 3
99508: DOUBLE
99509: EQUAL
99510: IFTRUE 99514
99512: GO 99570
99514: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99515: LD_ADDR_VAR 0 9
99519: PUSH
99520: LD_VAR 0 23
99524: PUSH
99525: LD_VAR 0 24
99529: PUSH
99530: LD_VAR 0 25
99534: PUSH
99535: LD_VAR 0 26
99539: PUSH
99540: LD_VAR 0 27
99544: PUSH
99545: LD_VAR 0 28
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: PUSH
99558: LD_VAR 0 4
99562: PUSH
99563: LD_INT 1
99565: PLUS
99566: ARRAY
99567: ST_TO_ADDR
99568: GO 99571
99570: POP
99571: GO 100126
99573: LD_INT 2
99575: DOUBLE
99576: EQUAL
99577: IFTRUE 99587
99579: LD_INT 3
99581: DOUBLE
99582: EQUAL
99583: IFTRUE 99587
99585: GO 99643
99587: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99588: LD_ADDR_VAR 0 9
99592: PUSH
99593: LD_VAR 0 29
99597: PUSH
99598: LD_VAR 0 30
99602: PUSH
99603: LD_VAR 0 31
99607: PUSH
99608: LD_VAR 0 32
99612: PUSH
99613: LD_VAR 0 33
99617: PUSH
99618: LD_VAR 0 34
99622: PUSH
99623: EMPTY
99624: LIST
99625: LIST
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: PUSH
99631: LD_VAR 0 4
99635: PUSH
99636: LD_INT 1
99638: PLUS
99639: ARRAY
99640: ST_TO_ADDR
99641: GO 100126
99643: LD_INT 16
99645: DOUBLE
99646: EQUAL
99647: IFTRUE 99705
99649: LD_INT 17
99651: DOUBLE
99652: EQUAL
99653: IFTRUE 99705
99655: LD_INT 18
99657: DOUBLE
99658: EQUAL
99659: IFTRUE 99705
99661: LD_INT 19
99663: DOUBLE
99664: EQUAL
99665: IFTRUE 99705
99667: LD_INT 22
99669: DOUBLE
99670: EQUAL
99671: IFTRUE 99705
99673: LD_INT 20
99675: DOUBLE
99676: EQUAL
99677: IFTRUE 99705
99679: LD_INT 21
99681: DOUBLE
99682: EQUAL
99683: IFTRUE 99705
99685: LD_INT 23
99687: DOUBLE
99688: EQUAL
99689: IFTRUE 99705
99691: LD_INT 24
99693: DOUBLE
99694: EQUAL
99695: IFTRUE 99705
99697: LD_INT 25
99699: DOUBLE
99700: EQUAL
99701: IFTRUE 99705
99703: GO 99761
99705: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99706: LD_ADDR_VAR 0 9
99710: PUSH
99711: LD_VAR 0 35
99715: PUSH
99716: LD_VAR 0 36
99720: PUSH
99721: LD_VAR 0 37
99725: PUSH
99726: LD_VAR 0 38
99730: PUSH
99731: LD_VAR 0 39
99735: PUSH
99736: LD_VAR 0 40
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: PUSH
99749: LD_VAR 0 4
99753: PUSH
99754: LD_INT 1
99756: PLUS
99757: ARRAY
99758: ST_TO_ADDR
99759: GO 100126
99761: LD_INT 6
99763: DOUBLE
99764: EQUAL
99765: IFTRUE 99817
99767: LD_INT 7
99769: DOUBLE
99770: EQUAL
99771: IFTRUE 99817
99773: LD_INT 8
99775: DOUBLE
99776: EQUAL
99777: IFTRUE 99817
99779: LD_INT 13
99781: DOUBLE
99782: EQUAL
99783: IFTRUE 99817
99785: LD_INT 12
99787: DOUBLE
99788: EQUAL
99789: IFTRUE 99817
99791: LD_INT 15
99793: DOUBLE
99794: EQUAL
99795: IFTRUE 99817
99797: LD_INT 11
99799: DOUBLE
99800: EQUAL
99801: IFTRUE 99817
99803: LD_INT 14
99805: DOUBLE
99806: EQUAL
99807: IFTRUE 99817
99809: LD_INT 10
99811: DOUBLE
99812: EQUAL
99813: IFTRUE 99817
99815: GO 99873
99817: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99818: LD_ADDR_VAR 0 9
99822: PUSH
99823: LD_VAR 0 41
99827: PUSH
99828: LD_VAR 0 42
99832: PUSH
99833: LD_VAR 0 43
99837: PUSH
99838: LD_VAR 0 44
99842: PUSH
99843: LD_VAR 0 45
99847: PUSH
99848: LD_VAR 0 46
99852: PUSH
99853: EMPTY
99854: LIST
99855: LIST
99856: LIST
99857: LIST
99858: LIST
99859: LIST
99860: PUSH
99861: LD_VAR 0 4
99865: PUSH
99866: LD_INT 1
99868: PLUS
99869: ARRAY
99870: ST_TO_ADDR
99871: GO 100126
99873: LD_INT 36
99875: DOUBLE
99876: EQUAL
99877: IFTRUE 99881
99879: GO 99937
99881: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99882: LD_ADDR_VAR 0 9
99886: PUSH
99887: LD_VAR 0 47
99891: PUSH
99892: LD_VAR 0 48
99896: PUSH
99897: LD_VAR 0 49
99901: PUSH
99902: LD_VAR 0 50
99906: PUSH
99907: LD_VAR 0 51
99911: PUSH
99912: LD_VAR 0 52
99916: PUSH
99917: EMPTY
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: PUSH
99925: LD_VAR 0 4
99929: PUSH
99930: LD_INT 1
99932: PLUS
99933: ARRAY
99934: ST_TO_ADDR
99935: GO 100126
99937: LD_INT 4
99939: DOUBLE
99940: EQUAL
99941: IFTRUE 99963
99943: LD_INT 5
99945: DOUBLE
99946: EQUAL
99947: IFTRUE 99963
99949: LD_INT 34
99951: DOUBLE
99952: EQUAL
99953: IFTRUE 99963
99955: LD_INT 37
99957: DOUBLE
99958: EQUAL
99959: IFTRUE 99963
99961: GO 100019
99963: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99964: LD_ADDR_VAR 0 9
99968: PUSH
99969: LD_VAR 0 53
99973: PUSH
99974: LD_VAR 0 54
99978: PUSH
99979: LD_VAR 0 55
99983: PUSH
99984: LD_VAR 0 56
99988: PUSH
99989: LD_VAR 0 57
99993: PUSH
99994: LD_VAR 0 58
99998: PUSH
99999: EMPTY
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: PUSH
100007: LD_VAR 0 4
100011: PUSH
100012: LD_INT 1
100014: PLUS
100015: ARRAY
100016: ST_TO_ADDR
100017: GO 100126
100019: LD_INT 31
100021: DOUBLE
100022: EQUAL
100023: IFTRUE 100069
100025: LD_INT 32
100027: DOUBLE
100028: EQUAL
100029: IFTRUE 100069
100031: LD_INT 33
100033: DOUBLE
100034: EQUAL
100035: IFTRUE 100069
100037: LD_INT 27
100039: DOUBLE
100040: EQUAL
100041: IFTRUE 100069
100043: LD_INT 26
100045: DOUBLE
100046: EQUAL
100047: IFTRUE 100069
100049: LD_INT 28
100051: DOUBLE
100052: EQUAL
100053: IFTRUE 100069
100055: LD_INT 29
100057: DOUBLE
100058: EQUAL
100059: IFTRUE 100069
100061: LD_INT 30
100063: DOUBLE
100064: EQUAL
100065: IFTRUE 100069
100067: GO 100125
100069: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
100070: LD_ADDR_VAR 0 9
100074: PUSH
100075: LD_VAR 0 59
100079: PUSH
100080: LD_VAR 0 60
100084: PUSH
100085: LD_VAR 0 61
100089: PUSH
100090: LD_VAR 0 62
100094: PUSH
100095: LD_VAR 0 63
100099: PUSH
100100: LD_VAR 0 64
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: PUSH
100113: LD_VAR 0 4
100117: PUSH
100118: LD_INT 1
100120: PLUS
100121: ARRAY
100122: ST_TO_ADDR
100123: GO 100126
100125: POP
// temp_list2 = [ ] ;
100126: LD_ADDR_VAR 0 10
100130: PUSH
100131: EMPTY
100132: ST_TO_ADDR
// for i in temp_list do
100133: LD_ADDR_VAR 0 8
100137: PUSH
100138: LD_VAR 0 9
100142: PUSH
100143: FOR_IN
100144: IFFALSE 100196
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100146: LD_ADDR_VAR 0 10
100150: PUSH
100151: LD_VAR 0 10
100155: PUSH
100156: LD_VAR 0 8
100160: PUSH
100161: LD_INT 1
100163: ARRAY
100164: PUSH
100165: LD_VAR 0 2
100169: PLUS
100170: PUSH
100171: LD_VAR 0 8
100175: PUSH
100176: LD_INT 2
100178: ARRAY
100179: PUSH
100180: LD_VAR 0 3
100184: PLUS
100185: PUSH
100186: EMPTY
100187: LIST
100188: LIST
100189: PUSH
100190: EMPTY
100191: LIST
100192: ADD
100193: ST_TO_ADDR
100194: GO 100143
100196: POP
100197: POP
// result = temp_list2 ;
100198: LD_ADDR_VAR 0 7
100202: PUSH
100203: LD_VAR 0 10
100207: ST_TO_ADDR
// end ;
100208: LD_VAR 0 7
100212: RET
// export function EnemyInRange ( unit , dist ) ; begin
100213: LD_INT 0
100215: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
100216: LD_ADDR_VAR 0 3
100220: PUSH
100221: LD_VAR 0 1
100225: PPUSH
100226: CALL_OW 255
100230: PPUSH
100231: LD_VAR 0 1
100235: PPUSH
100236: CALL_OW 250
100240: PPUSH
100241: LD_VAR 0 1
100245: PPUSH
100246: CALL_OW 251
100250: PPUSH
100251: LD_VAR 0 2
100255: PPUSH
100256: CALL 73615 0 4
100260: PUSH
100261: LD_INT 4
100263: ARRAY
100264: ST_TO_ADDR
// end ;
100265: LD_VAR 0 3
100269: RET
// export function PlayerSeeMe ( unit ) ; begin
100270: LD_INT 0
100272: PPUSH
// result := See ( your_side , unit ) ;
100273: LD_ADDR_VAR 0 2
100277: PUSH
100278: LD_OWVAR 2
100282: PPUSH
100283: LD_VAR 0 1
100287: PPUSH
100288: CALL_OW 292
100292: ST_TO_ADDR
// end ;
100293: LD_VAR 0 2
100297: RET
// export function ReverseDir ( unit ) ; begin
100298: LD_INT 0
100300: PPUSH
// if not unit then
100301: LD_VAR 0 1
100305: NOT
100306: IFFALSE 100310
// exit ;
100308: GO 100333
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
100310: LD_ADDR_VAR 0 2
100314: PUSH
100315: LD_VAR 0 1
100319: PPUSH
100320: CALL_OW 254
100324: PUSH
100325: LD_INT 3
100327: PLUS
100328: PUSH
100329: LD_INT 6
100331: MOD
100332: ST_TO_ADDR
// end ;
100333: LD_VAR 0 2
100337: RET
// export function ReverseArray ( array ) ; var i ; begin
100338: LD_INT 0
100340: PPUSH
100341: PPUSH
// if not array then
100342: LD_VAR 0 1
100346: NOT
100347: IFFALSE 100351
// exit ;
100349: GO 100406
// result := [ ] ;
100351: LD_ADDR_VAR 0 2
100355: PUSH
100356: EMPTY
100357: ST_TO_ADDR
// for i := array downto 1 do
100358: LD_ADDR_VAR 0 3
100362: PUSH
100363: DOUBLE
100364: LD_VAR 0 1
100368: INC
100369: ST_TO_ADDR
100370: LD_INT 1
100372: PUSH
100373: FOR_DOWNTO
100374: IFFALSE 100404
// result := Join ( result , array [ i ] ) ;
100376: LD_ADDR_VAR 0 2
100380: PUSH
100381: LD_VAR 0 2
100385: PPUSH
100386: LD_VAR 0 1
100390: PUSH
100391: LD_VAR 0 3
100395: ARRAY
100396: PPUSH
100397: CALL 105050 0 2
100401: ST_TO_ADDR
100402: GO 100373
100404: POP
100405: POP
// end ;
100406: LD_VAR 0 2
100410: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100411: LD_INT 0
100413: PPUSH
100414: PPUSH
100415: PPUSH
100416: PPUSH
100417: PPUSH
100418: PPUSH
// if not unit or not hexes then
100419: LD_VAR 0 1
100423: NOT
100424: PUSH
100425: LD_VAR 0 2
100429: NOT
100430: OR
100431: IFFALSE 100435
// exit ;
100433: GO 100558
// dist := 9999 ;
100435: LD_ADDR_VAR 0 5
100439: PUSH
100440: LD_INT 9999
100442: ST_TO_ADDR
// for i = 1 to hexes do
100443: LD_ADDR_VAR 0 4
100447: PUSH
100448: DOUBLE
100449: LD_INT 1
100451: DEC
100452: ST_TO_ADDR
100453: LD_VAR 0 2
100457: PUSH
100458: FOR_TO
100459: IFFALSE 100546
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100461: LD_ADDR_VAR 0 6
100465: PUSH
100466: LD_VAR 0 1
100470: PPUSH
100471: LD_VAR 0 2
100475: PUSH
100476: LD_VAR 0 4
100480: ARRAY
100481: PUSH
100482: LD_INT 1
100484: ARRAY
100485: PPUSH
100486: LD_VAR 0 2
100490: PUSH
100491: LD_VAR 0 4
100495: ARRAY
100496: PUSH
100497: LD_INT 2
100499: ARRAY
100500: PPUSH
100501: CALL_OW 297
100505: ST_TO_ADDR
// if tdist < dist then
100506: LD_VAR 0 6
100510: PUSH
100511: LD_VAR 0 5
100515: LESS
100516: IFFALSE 100544
// begin hex := hexes [ i ] ;
100518: LD_ADDR_VAR 0 8
100522: PUSH
100523: LD_VAR 0 2
100527: PUSH
100528: LD_VAR 0 4
100532: ARRAY
100533: ST_TO_ADDR
// dist := tdist ;
100534: LD_ADDR_VAR 0 5
100538: PUSH
100539: LD_VAR 0 6
100543: ST_TO_ADDR
// end ; end ;
100544: GO 100458
100546: POP
100547: POP
// result := hex ;
100548: LD_ADDR_VAR 0 3
100552: PUSH
100553: LD_VAR 0 8
100557: ST_TO_ADDR
// end ;
100558: LD_VAR 0 3
100562: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100563: LD_INT 0
100565: PPUSH
100566: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100567: LD_VAR 0 1
100571: NOT
100572: PUSH
100573: LD_VAR 0 1
100577: PUSH
100578: LD_INT 21
100580: PUSH
100581: LD_INT 2
100583: PUSH
100584: EMPTY
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 23
100590: PUSH
100591: LD_INT 2
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: PPUSH
100602: CALL_OW 69
100606: IN
100607: NOT
100608: OR
100609: IFFALSE 100613
// exit ;
100611: GO 100660
// for i = 1 to 3 do
100613: LD_ADDR_VAR 0 3
100617: PUSH
100618: DOUBLE
100619: LD_INT 1
100621: DEC
100622: ST_TO_ADDR
100623: LD_INT 3
100625: PUSH
100626: FOR_TO
100627: IFFALSE 100658
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100629: LD_VAR 0 1
100633: PPUSH
100634: CALL_OW 250
100638: PPUSH
100639: LD_VAR 0 1
100643: PPUSH
100644: CALL_OW 251
100648: PPUSH
100649: LD_INT 1
100651: PPUSH
100652: CALL_OW 453
100656: GO 100626
100658: POP
100659: POP
// end ;
100660: LD_VAR 0 2
100664: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100665: LD_INT 0
100667: PPUSH
100668: PPUSH
100669: PPUSH
100670: PPUSH
100671: PPUSH
100672: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100673: LD_VAR 0 1
100677: NOT
100678: PUSH
100679: LD_VAR 0 2
100683: NOT
100684: OR
100685: PUSH
100686: LD_VAR 0 1
100690: PPUSH
100691: CALL_OW 314
100695: OR
100696: IFFALSE 100700
// exit ;
100698: GO 101167
// if GetLives ( i ) < 250 then
100700: LD_VAR 0 4
100704: PPUSH
100705: CALL_OW 256
100709: PUSH
100710: LD_INT 250
100712: LESS
100713: IFFALSE 100726
// begin ComAutodestruct ( i ) ;
100715: LD_VAR 0 4
100719: PPUSH
100720: CALL 100563 0 1
// exit ;
100724: GO 101167
// end ; x := GetX ( enemy_unit ) ;
100726: LD_ADDR_VAR 0 7
100730: PUSH
100731: LD_VAR 0 2
100735: PPUSH
100736: CALL_OW 250
100740: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100741: LD_ADDR_VAR 0 8
100745: PUSH
100746: LD_VAR 0 2
100750: PPUSH
100751: CALL_OW 251
100755: ST_TO_ADDR
// if not x or not y then
100756: LD_VAR 0 7
100760: NOT
100761: PUSH
100762: LD_VAR 0 8
100766: NOT
100767: OR
100768: IFFALSE 100772
// exit ;
100770: GO 101167
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100772: LD_ADDR_VAR 0 6
100776: PUSH
100777: LD_VAR 0 7
100781: PPUSH
100782: LD_INT 0
100784: PPUSH
100785: LD_INT 4
100787: PPUSH
100788: CALL_OW 272
100792: PUSH
100793: LD_VAR 0 8
100797: PPUSH
100798: LD_INT 0
100800: PPUSH
100801: LD_INT 4
100803: PPUSH
100804: CALL_OW 273
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: PUSH
100813: LD_VAR 0 7
100817: PPUSH
100818: LD_INT 1
100820: PPUSH
100821: LD_INT 4
100823: PPUSH
100824: CALL_OW 272
100828: PUSH
100829: LD_VAR 0 8
100833: PPUSH
100834: LD_INT 1
100836: PPUSH
100837: LD_INT 4
100839: PPUSH
100840: CALL_OW 273
100844: PUSH
100845: EMPTY
100846: LIST
100847: LIST
100848: PUSH
100849: LD_VAR 0 7
100853: PPUSH
100854: LD_INT 2
100856: PPUSH
100857: LD_INT 4
100859: PPUSH
100860: CALL_OW 272
100864: PUSH
100865: LD_VAR 0 8
100869: PPUSH
100870: LD_INT 2
100872: PPUSH
100873: LD_INT 4
100875: PPUSH
100876: CALL_OW 273
100880: PUSH
100881: EMPTY
100882: LIST
100883: LIST
100884: PUSH
100885: LD_VAR 0 7
100889: PPUSH
100890: LD_INT 3
100892: PPUSH
100893: LD_INT 4
100895: PPUSH
100896: CALL_OW 272
100900: PUSH
100901: LD_VAR 0 8
100905: PPUSH
100906: LD_INT 3
100908: PPUSH
100909: LD_INT 4
100911: PPUSH
100912: CALL_OW 273
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: LD_VAR 0 7
100925: PPUSH
100926: LD_INT 4
100928: PPUSH
100929: LD_INT 4
100931: PPUSH
100932: CALL_OW 272
100936: PUSH
100937: LD_VAR 0 8
100941: PPUSH
100942: LD_INT 4
100944: PPUSH
100945: LD_INT 4
100947: PPUSH
100948: CALL_OW 273
100952: PUSH
100953: EMPTY
100954: LIST
100955: LIST
100956: PUSH
100957: LD_VAR 0 7
100961: PPUSH
100962: LD_INT 5
100964: PPUSH
100965: LD_INT 4
100967: PPUSH
100968: CALL_OW 272
100972: PUSH
100973: LD_VAR 0 8
100977: PPUSH
100978: LD_INT 5
100980: PPUSH
100981: LD_INT 4
100983: PPUSH
100984: CALL_OW 273
100988: PUSH
100989: EMPTY
100990: LIST
100991: LIST
100992: PUSH
100993: EMPTY
100994: LIST
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: ST_TO_ADDR
// for i = tmp downto 1 do
101001: LD_ADDR_VAR 0 4
101005: PUSH
101006: DOUBLE
101007: LD_VAR 0 6
101011: INC
101012: ST_TO_ADDR
101013: LD_INT 1
101015: PUSH
101016: FOR_DOWNTO
101017: IFFALSE 101118
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
101019: LD_VAR 0 6
101023: PUSH
101024: LD_VAR 0 4
101028: ARRAY
101029: PUSH
101030: LD_INT 1
101032: ARRAY
101033: PPUSH
101034: LD_VAR 0 6
101038: PUSH
101039: LD_VAR 0 4
101043: ARRAY
101044: PUSH
101045: LD_INT 2
101047: ARRAY
101048: PPUSH
101049: CALL_OW 488
101053: NOT
101054: PUSH
101055: LD_VAR 0 6
101059: PUSH
101060: LD_VAR 0 4
101064: ARRAY
101065: PUSH
101066: LD_INT 1
101068: ARRAY
101069: PPUSH
101070: LD_VAR 0 6
101074: PUSH
101075: LD_VAR 0 4
101079: ARRAY
101080: PUSH
101081: LD_INT 2
101083: ARRAY
101084: PPUSH
101085: CALL_OW 428
101089: PUSH
101090: LD_INT 0
101092: NONEQUAL
101093: OR
101094: IFFALSE 101116
// tmp := Delete ( tmp , i ) ;
101096: LD_ADDR_VAR 0 6
101100: PUSH
101101: LD_VAR 0 6
101105: PPUSH
101106: LD_VAR 0 4
101110: PPUSH
101111: CALL_OW 3
101115: ST_TO_ADDR
101116: GO 101016
101118: POP
101119: POP
// j := GetClosestHex ( unit , tmp ) ;
101120: LD_ADDR_VAR 0 5
101124: PUSH
101125: LD_VAR 0 1
101129: PPUSH
101130: LD_VAR 0 6
101134: PPUSH
101135: CALL 100411 0 2
101139: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101140: LD_VAR 0 1
101144: PPUSH
101145: LD_VAR 0 5
101149: PUSH
101150: LD_INT 1
101152: ARRAY
101153: PPUSH
101154: LD_VAR 0 5
101158: PUSH
101159: LD_INT 2
101161: ARRAY
101162: PPUSH
101163: CALL_OW 111
// end ;
101167: LD_VAR 0 3
101171: RET
// export function PrepareApemanSoldier ( ) ; begin
101172: LD_INT 0
101174: PPUSH
// uc_nation := 0 ;
101175: LD_ADDR_OWVAR 21
101179: PUSH
101180: LD_INT 0
101182: ST_TO_ADDR
// hc_sex := sex_male ;
101183: LD_ADDR_OWVAR 27
101187: PUSH
101188: LD_INT 1
101190: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101191: LD_ADDR_OWVAR 28
101195: PUSH
101196: LD_INT 15
101198: ST_TO_ADDR
// hc_gallery :=  ;
101199: LD_ADDR_OWVAR 33
101203: PUSH
101204: LD_STRING 
101206: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101207: LD_ADDR_OWVAR 31
101211: PUSH
101212: LD_INT 0
101214: PPUSH
101215: LD_INT 3
101217: PPUSH
101218: CALL_OW 12
101222: PUSH
101223: LD_INT 0
101225: PPUSH
101226: LD_INT 3
101228: PPUSH
101229: CALL_OW 12
101233: PUSH
101234: LD_INT 0
101236: PUSH
101237: LD_INT 0
101239: PUSH
101240: EMPTY
101241: LIST
101242: LIST
101243: LIST
101244: LIST
101245: ST_TO_ADDR
// end ;
101246: LD_VAR 0 1
101250: RET
// export function PrepareApemanEngineer ( ) ; begin
101251: LD_INT 0
101253: PPUSH
// uc_nation := 0 ;
101254: LD_ADDR_OWVAR 21
101258: PUSH
101259: LD_INT 0
101261: ST_TO_ADDR
// hc_sex := sex_male ;
101262: LD_ADDR_OWVAR 27
101266: PUSH
101267: LD_INT 1
101269: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
101270: LD_ADDR_OWVAR 28
101274: PUSH
101275: LD_INT 16
101277: ST_TO_ADDR
// hc_gallery :=  ;
101278: LD_ADDR_OWVAR 33
101282: PUSH
101283: LD_STRING 
101285: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101286: LD_ADDR_OWVAR 31
101290: PUSH
101291: LD_INT 0
101293: PPUSH
101294: LD_INT 3
101296: PPUSH
101297: CALL_OW 12
101301: PUSH
101302: LD_INT 0
101304: PPUSH
101305: LD_INT 3
101307: PPUSH
101308: CALL_OW 12
101312: PUSH
101313: LD_INT 0
101315: PUSH
101316: LD_INT 0
101318: PUSH
101319: EMPTY
101320: LIST
101321: LIST
101322: LIST
101323: LIST
101324: ST_TO_ADDR
// end ;
101325: LD_VAR 0 1
101329: RET
// export function PrepareApeman ( agressivity ) ; begin
101330: LD_INT 0
101332: PPUSH
// uc_side := 0 ;
101333: LD_ADDR_OWVAR 20
101337: PUSH
101338: LD_INT 0
101340: ST_TO_ADDR
// uc_nation := 0 ;
101341: LD_ADDR_OWVAR 21
101345: PUSH
101346: LD_INT 0
101348: ST_TO_ADDR
// hc_sex := sex_male ;
101349: LD_ADDR_OWVAR 27
101353: PUSH
101354: LD_INT 1
101356: ST_TO_ADDR
// hc_class := class_apeman ;
101357: LD_ADDR_OWVAR 28
101361: PUSH
101362: LD_INT 12
101364: ST_TO_ADDR
// hc_gallery :=  ;
101365: LD_ADDR_OWVAR 33
101369: PUSH
101370: LD_STRING 
101372: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101373: LD_ADDR_OWVAR 35
101377: PUSH
101378: LD_VAR 0 1
101382: NEG
101383: PPUSH
101384: LD_VAR 0 1
101388: PPUSH
101389: CALL_OW 12
101393: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
101394: LD_ADDR_OWVAR 31
101398: PUSH
101399: LD_INT 0
101401: PPUSH
101402: LD_INT 3
101404: PPUSH
101405: CALL_OW 12
101409: PUSH
101410: LD_INT 0
101412: PPUSH
101413: LD_INT 3
101415: PPUSH
101416: CALL_OW 12
101420: PUSH
101421: LD_INT 0
101423: PUSH
101424: LD_INT 0
101426: PUSH
101427: EMPTY
101428: LIST
101429: LIST
101430: LIST
101431: LIST
101432: ST_TO_ADDR
// end ;
101433: LD_VAR 0 2
101437: RET
// export function PrepareTiger ( agressivity ) ; begin
101438: LD_INT 0
101440: PPUSH
// uc_side := 0 ;
101441: LD_ADDR_OWVAR 20
101445: PUSH
101446: LD_INT 0
101448: ST_TO_ADDR
// uc_nation := 0 ;
101449: LD_ADDR_OWVAR 21
101453: PUSH
101454: LD_INT 0
101456: ST_TO_ADDR
// hc_class := class_tiger ;
101457: LD_ADDR_OWVAR 28
101461: PUSH
101462: LD_INT 14
101464: ST_TO_ADDR
// hc_gallery :=  ;
101465: LD_ADDR_OWVAR 33
101469: PUSH
101470: LD_STRING 
101472: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101473: LD_ADDR_OWVAR 35
101477: PUSH
101478: LD_VAR 0 1
101482: NEG
101483: PPUSH
101484: LD_VAR 0 1
101488: PPUSH
101489: CALL_OW 12
101493: ST_TO_ADDR
// end ;
101494: LD_VAR 0 2
101498: RET
// export function PrepareEnchidna ( ) ; begin
101499: LD_INT 0
101501: PPUSH
// uc_side := 0 ;
101502: LD_ADDR_OWVAR 20
101506: PUSH
101507: LD_INT 0
101509: ST_TO_ADDR
// uc_nation := 0 ;
101510: LD_ADDR_OWVAR 21
101514: PUSH
101515: LD_INT 0
101517: ST_TO_ADDR
// hc_class := class_baggie ;
101518: LD_ADDR_OWVAR 28
101522: PUSH
101523: LD_INT 13
101525: ST_TO_ADDR
// hc_gallery :=  ;
101526: LD_ADDR_OWVAR 33
101530: PUSH
101531: LD_STRING 
101533: ST_TO_ADDR
// end ;
101534: LD_VAR 0 1
101538: RET
// export function PrepareFrog ( ) ; begin
101539: LD_INT 0
101541: PPUSH
// uc_side := 0 ;
101542: LD_ADDR_OWVAR 20
101546: PUSH
101547: LD_INT 0
101549: ST_TO_ADDR
// uc_nation := 0 ;
101550: LD_ADDR_OWVAR 21
101554: PUSH
101555: LD_INT 0
101557: ST_TO_ADDR
// hc_class := class_frog ;
101558: LD_ADDR_OWVAR 28
101562: PUSH
101563: LD_INT 19
101565: ST_TO_ADDR
// hc_gallery :=  ;
101566: LD_ADDR_OWVAR 33
101570: PUSH
101571: LD_STRING 
101573: ST_TO_ADDR
// end ;
101574: LD_VAR 0 1
101578: RET
// export function PrepareFish ( ) ; begin
101579: LD_INT 0
101581: PPUSH
// uc_side := 0 ;
101582: LD_ADDR_OWVAR 20
101586: PUSH
101587: LD_INT 0
101589: ST_TO_ADDR
// uc_nation := 0 ;
101590: LD_ADDR_OWVAR 21
101594: PUSH
101595: LD_INT 0
101597: ST_TO_ADDR
// hc_class := class_fish ;
101598: LD_ADDR_OWVAR 28
101602: PUSH
101603: LD_INT 20
101605: ST_TO_ADDR
// hc_gallery :=  ;
101606: LD_ADDR_OWVAR 33
101610: PUSH
101611: LD_STRING 
101613: ST_TO_ADDR
// end ;
101614: LD_VAR 0 1
101618: RET
// export function PrepareBird ( ) ; begin
101619: LD_INT 0
101621: PPUSH
// uc_side := 0 ;
101622: LD_ADDR_OWVAR 20
101626: PUSH
101627: LD_INT 0
101629: ST_TO_ADDR
// uc_nation := 0 ;
101630: LD_ADDR_OWVAR 21
101634: PUSH
101635: LD_INT 0
101637: ST_TO_ADDR
// hc_class := class_phororhacos ;
101638: LD_ADDR_OWVAR 28
101642: PUSH
101643: LD_INT 18
101645: ST_TO_ADDR
// hc_gallery :=  ;
101646: LD_ADDR_OWVAR 33
101650: PUSH
101651: LD_STRING 
101653: ST_TO_ADDR
// end ;
101654: LD_VAR 0 1
101658: RET
// export function PrepareHorse ( ) ; begin
101659: LD_INT 0
101661: PPUSH
// uc_side := 0 ;
101662: LD_ADDR_OWVAR 20
101666: PUSH
101667: LD_INT 0
101669: ST_TO_ADDR
// uc_nation := 0 ;
101670: LD_ADDR_OWVAR 21
101674: PUSH
101675: LD_INT 0
101677: ST_TO_ADDR
// hc_class := class_horse ;
101678: LD_ADDR_OWVAR 28
101682: PUSH
101683: LD_INT 21
101685: ST_TO_ADDR
// hc_gallery :=  ;
101686: LD_ADDR_OWVAR 33
101690: PUSH
101691: LD_STRING 
101693: ST_TO_ADDR
// end ;
101694: LD_VAR 0 1
101698: RET
// export function PrepareMastodont ( ) ; begin
101699: LD_INT 0
101701: PPUSH
// uc_side := 0 ;
101702: LD_ADDR_OWVAR 20
101706: PUSH
101707: LD_INT 0
101709: ST_TO_ADDR
// uc_nation := 0 ;
101710: LD_ADDR_OWVAR 21
101714: PUSH
101715: LD_INT 0
101717: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101718: LD_ADDR_OWVAR 37
101722: PUSH
101723: LD_INT 31
101725: ST_TO_ADDR
// vc_control := control_rider ;
101726: LD_ADDR_OWVAR 38
101730: PUSH
101731: LD_INT 4
101733: ST_TO_ADDR
// end ;
101734: LD_VAR 0 1
101738: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101739: LD_INT 0
101741: PPUSH
101742: PPUSH
101743: PPUSH
// uc_side = 0 ;
101744: LD_ADDR_OWVAR 20
101748: PUSH
101749: LD_INT 0
101751: ST_TO_ADDR
// uc_nation = 0 ;
101752: LD_ADDR_OWVAR 21
101756: PUSH
101757: LD_INT 0
101759: ST_TO_ADDR
// InitHc_All ( ) ;
101760: CALL_OW 584
// InitVc ;
101764: CALL_OW 20
// if mastodonts then
101768: LD_VAR 0 6
101772: IFFALSE 101839
// for i = 1 to mastodonts do
101774: LD_ADDR_VAR 0 11
101778: PUSH
101779: DOUBLE
101780: LD_INT 1
101782: DEC
101783: ST_TO_ADDR
101784: LD_VAR 0 6
101788: PUSH
101789: FOR_TO
101790: IFFALSE 101837
// begin vc_chassis := 31 ;
101792: LD_ADDR_OWVAR 37
101796: PUSH
101797: LD_INT 31
101799: ST_TO_ADDR
// vc_control := control_rider ;
101800: LD_ADDR_OWVAR 38
101804: PUSH
101805: LD_INT 4
101807: ST_TO_ADDR
// animal := CreateVehicle ;
101808: LD_ADDR_VAR 0 12
101812: PUSH
101813: CALL_OW 45
101817: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101818: LD_VAR 0 12
101822: PPUSH
101823: LD_VAR 0 8
101827: PPUSH
101828: LD_INT 0
101830: PPUSH
101831: CALL 103967 0 3
// end ;
101835: GO 101789
101837: POP
101838: POP
// if horses then
101839: LD_VAR 0 5
101843: IFFALSE 101910
// for i = 1 to horses do
101845: LD_ADDR_VAR 0 11
101849: PUSH
101850: DOUBLE
101851: LD_INT 1
101853: DEC
101854: ST_TO_ADDR
101855: LD_VAR 0 5
101859: PUSH
101860: FOR_TO
101861: IFFALSE 101908
// begin hc_class := 21 ;
101863: LD_ADDR_OWVAR 28
101867: PUSH
101868: LD_INT 21
101870: ST_TO_ADDR
// hc_gallery :=  ;
101871: LD_ADDR_OWVAR 33
101875: PUSH
101876: LD_STRING 
101878: ST_TO_ADDR
// animal := CreateHuman ;
101879: LD_ADDR_VAR 0 12
101883: PUSH
101884: CALL_OW 44
101888: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101889: LD_VAR 0 12
101893: PPUSH
101894: LD_VAR 0 8
101898: PPUSH
101899: LD_INT 0
101901: PPUSH
101902: CALL 103967 0 3
// end ;
101906: GO 101860
101908: POP
101909: POP
// if birds then
101910: LD_VAR 0 1
101914: IFFALSE 101981
// for i = 1 to birds do
101916: LD_ADDR_VAR 0 11
101920: PUSH
101921: DOUBLE
101922: LD_INT 1
101924: DEC
101925: ST_TO_ADDR
101926: LD_VAR 0 1
101930: PUSH
101931: FOR_TO
101932: IFFALSE 101979
// begin hc_class = 18 ;
101934: LD_ADDR_OWVAR 28
101938: PUSH
101939: LD_INT 18
101941: ST_TO_ADDR
// hc_gallery =  ;
101942: LD_ADDR_OWVAR 33
101946: PUSH
101947: LD_STRING 
101949: ST_TO_ADDR
// animal := CreateHuman ;
101950: LD_ADDR_VAR 0 12
101954: PUSH
101955: CALL_OW 44
101959: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101960: LD_VAR 0 12
101964: PPUSH
101965: LD_VAR 0 8
101969: PPUSH
101970: LD_INT 0
101972: PPUSH
101973: CALL 103967 0 3
// end ;
101977: GO 101931
101979: POP
101980: POP
// if tigers then
101981: LD_VAR 0 2
101985: IFFALSE 102069
// for i = 1 to tigers do
101987: LD_ADDR_VAR 0 11
101991: PUSH
101992: DOUBLE
101993: LD_INT 1
101995: DEC
101996: ST_TO_ADDR
101997: LD_VAR 0 2
102001: PUSH
102002: FOR_TO
102003: IFFALSE 102067
// begin hc_class = class_tiger ;
102005: LD_ADDR_OWVAR 28
102009: PUSH
102010: LD_INT 14
102012: ST_TO_ADDR
// hc_gallery =  ;
102013: LD_ADDR_OWVAR 33
102017: PUSH
102018: LD_STRING 
102020: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
102021: LD_ADDR_OWVAR 35
102025: PUSH
102026: LD_INT 7
102028: NEG
102029: PPUSH
102030: LD_INT 7
102032: PPUSH
102033: CALL_OW 12
102037: ST_TO_ADDR
// animal := CreateHuman ;
102038: LD_ADDR_VAR 0 12
102042: PUSH
102043: CALL_OW 44
102047: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102048: LD_VAR 0 12
102052: PPUSH
102053: LD_VAR 0 8
102057: PPUSH
102058: LD_INT 0
102060: PPUSH
102061: CALL 103967 0 3
// end ;
102065: GO 102002
102067: POP
102068: POP
// if apemans then
102069: LD_VAR 0 3
102073: IFFALSE 102196
// for i = 1 to apemans do
102075: LD_ADDR_VAR 0 11
102079: PUSH
102080: DOUBLE
102081: LD_INT 1
102083: DEC
102084: ST_TO_ADDR
102085: LD_VAR 0 3
102089: PUSH
102090: FOR_TO
102091: IFFALSE 102194
// begin hc_class = class_apeman ;
102093: LD_ADDR_OWVAR 28
102097: PUSH
102098: LD_INT 12
102100: ST_TO_ADDR
// hc_gallery =  ;
102101: LD_ADDR_OWVAR 33
102105: PUSH
102106: LD_STRING 
102108: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102109: LD_ADDR_OWVAR 35
102113: PUSH
102114: LD_INT 2
102116: NEG
102117: PPUSH
102118: LD_INT 2
102120: PPUSH
102121: CALL_OW 12
102125: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102126: LD_ADDR_OWVAR 31
102130: PUSH
102131: LD_INT 1
102133: PPUSH
102134: LD_INT 3
102136: PPUSH
102137: CALL_OW 12
102141: PUSH
102142: LD_INT 1
102144: PPUSH
102145: LD_INT 3
102147: PPUSH
102148: CALL_OW 12
102152: PUSH
102153: LD_INT 0
102155: PUSH
102156: LD_INT 0
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: LIST
102163: LIST
102164: ST_TO_ADDR
// animal := CreateHuman ;
102165: LD_ADDR_VAR 0 12
102169: PUSH
102170: CALL_OW 44
102174: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102175: LD_VAR 0 12
102179: PPUSH
102180: LD_VAR 0 8
102184: PPUSH
102185: LD_INT 0
102187: PPUSH
102188: CALL 103967 0 3
// end ;
102192: GO 102090
102194: POP
102195: POP
// if enchidnas then
102196: LD_VAR 0 4
102200: IFFALSE 102267
// for i = 1 to enchidnas do
102202: LD_ADDR_VAR 0 11
102206: PUSH
102207: DOUBLE
102208: LD_INT 1
102210: DEC
102211: ST_TO_ADDR
102212: LD_VAR 0 4
102216: PUSH
102217: FOR_TO
102218: IFFALSE 102265
// begin hc_class = 13 ;
102220: LD_ADDR_OWVAR 28
102224: PUSH
102225: LD_INT 13
102227: ST_TO_ADDR
// hc_gallery =  ;
102228: LD_ADDR_OWVAR 33
102232: PUSH
102233: LD_STRING 
102235: ST_TO_ADDR
// animal := CreateHuman ;
102236: LD_ADDR_VAR 0 12
102240: PUSH
102241: CALL_OW 44
102245: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102246: LD_VAR 0 12
102250: PPUSH
102251: LD_VAR 0 8
102255: PPUSH
102256: LD_INT 0
102258: PPUSH
102259: CALL 103967 0 3
// end ;
102263: GO 102217
102265: POP
102266: POP
// if fishes then
102267: LD_VAR 0 7
102271: IFFALSE 102338
// for i = 1 to fishes do
102273: LD_ADDR_VAR 0 11
102277: PUSH
102278: DOUBLE
102279: LD_INT 1
102281: DEC
102282: ST_TO_ADDR
102283: LD_VAR 0 7
102287: PUSH
102288: FOR_TO
102289: IFFALSE 102336
// begin hc_class = 20 ;
102291: LD_ADDR_OWVAR 28
102295: PUSH
102296: LD_INT 20
102298: ST_TO_ADDR
// hc_gallery =  ;
102299: LD_ADDR_OWVAR 33
102303: PUSH
102304: LD_STRING 
102306: ST_TO_ADDR
// animal := CreateHuman ;
102307: LD_ADDR_VAR 0 12
102311: PUSH
102312: CALL_OW 44
102316: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
102317: LD_VAR 0 12
102321: PPUSH
102322: LD_VAR 0 9
102326: PPUSH
102327: LD_INT 0
102329: PPUSH
102330: CALL 103967 0 3
// end ;
102334: GO 102288
102336: POP
102337: POP
// end ;
102338: LD_VAR 0 10
102342: RET
// export function WantHeal ( sci , unit ) ; begin
102343: LD_INT 0
102345: PPUSH
// if GetTaskList ( sci ) > 0 then
102346: LD_VAR 0 1
102350: PPUSH
102351: CALL_OW 437
102355: PUSH
102356: LD_INT 0
102358: GREATER
102359: IFFALSE 102429
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
102361: LD_VAR 0 1
102365: PPUSH
102366: CALL_OW 437
102370: PUSH
102371: LD_INT 1
102373: ARRAY
102374: PUSH
102375: LD_INT 1
102377: ARRAY
102378: PUSH
102379: LD_STRING l
102381: EQUAL
102382: PUSH
102383: LD_VAR 0 1
102387: PPUSH
102388: CALL_OW 437
102392: PUSH
102393: LD_INT 1
102395: ARRAY
102396: PUSH
102397: LD_INT 4
102399: ARRAY
102400: PUSH
102401: LD_VAR 0 2
102405: EQUAL
102406: AND
102407: IFFALSE 102419
// result := true else
102409: LD_ADDR_VAR 0 3
102413: PUSH
102414: LD_INT 1
102416: ST_TO_ADDR
102417: GO 102427
// result := false ;
102419: LD_ADDR_VAR 0 3
102423: PUSH
102424: LD_INT 0
102426: ST_TO_ADDR
// end else
102427: GO 102437
// result := false ;
102429: LD_ADDR_VAR 0 3
102433: PUSH
102434: LD_INT 0
102436: ST_TO_ADDR
// end ;
102437: LD_VAR 0 3
102441: RET
// export function HealTarget ( sci ) ; begin
102442: LD_INT 0
102444: PPUSH
// if not sci then
102445: LD_VAR 0 1
102449: NOT
102450: IFFALSE 102454
// exit ;
102452: GO 102519
// result := 0 ;
102454: LD_ADDR_VAR 0 2
102458: PUSH
102459: LD_INT 0
102461: ST_TO_ADDR
// if GetTaskList ( sci ) then
102462: LD_VAR 0 1
102466: PPUSH
102467: CALL_OW 437
102471: IFFALSE 102519
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102473: LD_VAR 0 1
102477: PPUSH
102478: CALL_OW 437
102482: PUSH
102483: LD_INT 1
102485: ARRAY
102486: PUSH
102487: LD_INT 1
102489: ARRAY
102490: PUSH
102491: LD_STRING l
102493: EQUAL
102494: IFFALSE 102519
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102496: LD_ADDR_VAR 0 2
102500: PUSH
102501: LD_VAR 0 1
102505: PPUSH
102506: CALL_OW 437
102510: PUSH
102511: LD_INT 1
102513: ARRAY
102514: PUSH
102515: LD_INT 4
102517: ARRAY
102518: ST_TO_ADDR
// end ;
102519: LD_VAR 0 2
102523: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102524: LD_INT 0
102526: PPUSH
102527: PPUSH
102528: PPUSH
102529: PPUSH
// if not base_units then
102530: LD_VAR 0 1
102534: NOT
102535: IFFALSE 102539
// exit ;
102537: GO 102626
// result := false ;
102539: LD_ADDR_VAR 0 2
102543: PUSH
102544: LD_INT 0
102546: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102547: LD_ADDR_VAR 0 5
102551: PUSH
102552: LD_VAR 0 1
102556: PPUSH
102557: LD_INT 21
102559: PUSH
102560: LD_INT 3
102562: PUSH
102563: EMPTY
102564: LIST
102565: LIST
102566: PPUSH
102567: CALL_OW 72
102571: ST_TO_ADDR
// if not tmp then
102572: LD_VAR 0 5
102576: NOT
102577: IFFALSE 102581
// exit ;
102579: GO 102626
// for i in tmp do
102581: LD_ADDR_VAR 0 3
102585: PUSH
102586: LD_VAR 0 5
102590: PUSH
102591: FOR_IN
102592: IFFALSE 102624
// begin result := EnemyInRange ( i , 22 ) ;
102594: LD_ADDR_VAR 0 2
102598: PUSH
102599: LD_VAR 0 3
102603: PPUSH
102604: LD_INT 22
102606: PPUSH
102607: CALL 100213 0 2
102611: ST_TO_ADDR
// if result then
102612: LD_VAR 0 2
102616: IFFALSE 102622
// exit ;
102618: POP
102619: POP
102620: GO 102626
// end ;
102622: GO 102591
102624: POP
102625: POP
// end ;
102626: LD_VAR 0 2
102630: RET
// export function FilterByTag ( units , tag ) ; begin
102631: LD_INT 0
102633: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102634: LD_ADDR_VAR 0 3
102638: PUSH
102639: LD_VAR 0 1
102643: PPUSH
102644: LD_INT 120
102646: PUSH
102647: LD_VAR 0 2
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: PPUSH
102656: CALL_OW 72
102660: ST_TO_ADDR
// end ;
102661: LD_VAR 0 3
102665: RET
// export function IsDriver ( un ) ; begin
102666: LD_INT 0
102668: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102669: LD_ADDR_VAR 0 2
102673: PUSH
102674: LD_VAR 0 1
102678: PUSH
102679: LD_INT 55
102681: PUSH
102682: EMPTY
102683: LIST
102684: PPUSH
102685: CALL_OW 69
102689: IN
102690: ST_TO_ADDR
// end ;
102691: LD_VAR 0 2
102695: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102696: LD_INT 0
102698: PPUSH
102699: PPUSH
// list := [ ] ;
102700: LD_ADDR_VAR 0 5
102704: PUSH
102705: EMPTY
102706: ST_TO_ADDR
// case d of 0 :
102707: LD_VAR 0 3
102711: PUSH
102712: LD_INT 0
102714: DOUBLE
102715: EQUAL
102716: IFTRUE 102720
102718: GO 102853
102720: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102721: LD_ADDR_VAR 0 5
102725: PUSH
102726: LD_VAR 0 1
102730: PUSH
102731: LD_INT 4
102733: MINUS
102734: PUSH
102735: LD_VAR 0 2
102739: PUSH
102740: LD_INT 4
102742: MINUS
102743: PUSH
102744: LD_INT 2
102746: PUSH
102747: EMPTY
102748: LIST
102749: LIST
102750: LIST
102751: PUSH
102752: LD_VAR 0 1
102756: PUSH
102757: LD_INT 3
102759: MINUS
102760: PUSH
102761: LD_VAR 0 2
102765: PUSH
102766: LD_INT 1
102768: PUSH
102769: EMPTY
102770: LIST
102771: LIST
102772: LIST
102773: PUSH
102774: LD_VAR 0 1
102778: PUSH
102779: LD_INT 4
102781: PLUS
102782: PUSH
102783: LD_VAR 0 2
102787: PUSH
102788: LD_INT 4
102790: PUSH
102791: EMPTY
102792: LIST
102793: LIST
102794: LIST
102795: PUSH
102796: LD_VAR 0 1
102800: PUSH
102801: LD_INT 3
102803: PLUS
102804: PUSH
102805: LD_VAR 0 2
102809: PUSH
102810: LD_INT 3
102812: PLUS
102813: PUSH
102814: LD_INT 5
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: LIST
102821: PUSH
102822: LD_VAR 0 1
102826: PUSH
102827: LD_VAR 0 2
102831: PUSH
102832: LD_INT 4
102834: PLUS
102835: PUSH
102836: LD_INT 0
102838: PUSH
102839: EMPTY
102840: LIST
102841: LIST
102842: LIST
102843: PUSH
102844: EMPTY
102845: LIST
102846: LIST
102847: LIST
102848: LIST
102849: LIST
102850: ST_TO_ADDR
// end ; 1 :
102851: GO 103551
102853: LD_INT 1
102855: DOUBLE
102856: EQUAL
102857: IFTRUE 102861
102859: GO 102994
102861: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102862: LD_ADDR_VAR 0 5
102866: PUSH
102867: LD_VAR 0 1
102871: PUSH
102872: LD_VAR 0 2
102876: PUSH
102877: LD_INT 4
102879: MINUS
102880: PUSH
102881: LD_INT 3
102883: PUSH
102884: EMPTY
102885: LIST
102886: LIST
102887: LIST
102888: PUSH
102889: LD_VAR 0 1
102893: PUSH
102894: LD_INT 3
102896: MINUS
102897: PUSH
102898: LD_VAR 0 2
102902: PUSH
102903: LD_INT 3
102905: MINUS
102906: PUSH
102907: LD_INT 2
102909: PUSH
102910: EMPTY
102911: LIST
102912: LIST
102913: LIST
102914: PUSH
102915: LD_VAR 0 1
102919: PUSH
102920: LD_INT 4
102922: MINUS
102923: PUSH
102924: LD_VAR 0 2
102928: PUSH
102929: LD_INT 1
102931: PUSH
102932: EMPTY
102933: LIST
102934: LIST
102935: LIST
102936: PUSH
102937: LD_VAR 0 1
102941: PUSH
102942: LD_VAR 0 2
102946: PUSH
102947: LD_INT 3
102949: PLUS
102950: PUSH
102951: LD_INT 0
102953: PUSH
102954: EMPTY
102955: LIST
102956: LIST
102957: LIST
102958: PUSH
102959: LD_VAR 0 1
102963: PUSH
102964: LD_INT 4
102966: PLUS
102967: PUSH
102968: LD_VAR 0 2
102972: PUSH
102973: LD_INT 4
102975: PLUS
102976: PUSH
102977: LD_INT 5
102979: PUSH
102980: EMPTY
102981: LIST
102982: LIST
102983: LIST
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: LIST
102989: LIST
102990: LIST
102991: ST_TO_ADDR
// end ; 2 :
102992: GO 103551
102994: LD_INT 2
102996: DOUBLE
102997: EQUAL
102998: IFTRUE 103002
103000: GO 103131
103002: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103003: LD_ADDR_VAR 0 5
103007: PUSH
103008: LD_VAR 0 1
103012: PUSH
103013: LD_VAR 0 2
103017: PUSH
103018: LD_INT 3
103020: MINUS
103021: PUSH
103022: LD_INT 3
103024: PUSH
103025: EMPTY
103026: LIST
103027: LIST
103028: LIST
103029: PUSH
103030: LD_VAR 0 1
103034: PUSH
103035: LD_INT 4
103037: PLUS
103038: PUSH
103039: LD_VAR 0 2
103043: PUSH
103044: LD_INT 4
103046: PUSH
103047: EMPTY
103048: LIST
103049: LIST
103050: LIST
103051: PUSH
103052: LD_VAR 0 1
103056: PUSH
103057: LD_VAR 0 2
103061: PUSH
103062: LD_INT 4
103064: PLUS
103065: PUSH
103066: LD_INT 0
103068: PUSH
103069: EMPTY
103070: LIST
103071: LIST
103072: LIST
103073: PUSH
103074: LD_VAR 0 1
103078: PUSH
103079: LD_INT 3
103081: MINUS
103082: PUSH
103083: LD_VAR 0 2
103087: PUSH
103088: LD_INT 1
103090: PUSH
103091: EMPTY
103092: LIST
103093: LIST
103094: LIST
103095: PUSH
103096: LD_VAR 0 1
103100: PUSH
103101: LD_INT 4
103103: MINUS
103104: PUSH
103105: LD_VAR 0 2
103109: PUSH
103110: LD_INT 4
103112: MINUS
103113: PUSH
103114: LD_INT 2
103116: PUSH
103117: EMPTY
103118: LIST
103119: LIST
103120: LIST
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: LIST
103126: LIST
103127: LIST
103128: ST_TO_ADDR
// end ; 3 :
103129: GO 103551
103131: LD_INT 3
103133: DOUBLE
103134: EQUAL
103135: IFTRUE 103139
103137: GO 103272
103139: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103140: LD_ADDR_VAR 0 5
103144: PUSH
103145: LD_VAR 0 1
103149: PUSH
103150: LD_INT 3
103152: PLUS
103153: PUSH
103154: LD_VAR 0 2
103158: PUSH
103159: LD_INT 4
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: LIST
103166: PUSH
103167: LD_VAR 0 1
103171: PUSH
103172: LD_INT 4
103174: PLUS
103175: PUSH
103176: LD_VAR 0 2
103180: PUSH
103181: LD_INT 4
103183: PLUS
103184: PUSH
103185: LD_INT 5
103187: PUSH
103188: EMPTY
103189: LIST
103190: LIST
103191: LIST
103192: PUSH
103193: LD_VAR 0 1
103197: PUSH
103198: LD_INT 4
103200: MINUS
103201: PUSH
103202: LD_VAR 0 2
103206: PUSH
103207: LD_INT 1
103209: PUSH
103210: EMPTY
103211: LIST
103212: LIST
103213: LIST
103214: PUSH
103215: LD_VAR 0 1
103219: PUSH
103220: LD_VAR 0 2
103224: PUSH
103225: LD_INT 4
103227: MINUS
103228: PUSH
103229: LD_INT 3
103231: PUSH
103232: EMPTY
103233: LIST
103234: LIST
103235: LIST
103236: PUSH
103237: LD_VAR 0 1
103241: PUSH
103242: LD_INT 3
103244: MINUS
103245: PUSH
103246: LD_VAR 0 2
103250: PUSH
103251: LD_INT 3
103253: MINUS
103254: PUSH
103255: LD_INT 2
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: LIST
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: LIST
103267: LIST
103268: LIST
103269: ST_TO_ADDR
// end ; 4 :
103270: GO 103551
103272: LD_INT 4
103274: DOUBLE
103275: EQUAL
103276: IFTRUE 103280
103278: GO 103413
103280: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103281: LD_ADDR_VAR 0 5
103285: PUSH
103286: LD_VAR 0 1
103290: PUSH
103291: LD_VAR 0 2
103295: PUSH
103296: LD_INT 4
103298: PLUS
103299: PUSH
103300: LD_INT 0
103302: PUSH
103303: EMPTY
103304: LIST
103305: LIST
103306: LIST
103307: PUSH
103308: LD_VAR 0 1
103312: PUSH
103313: LD_INT 3
103315: PLUS
103316: PUSH
103317: LD_VAR 0 2
103321: PUSH
103322: LD_INT 3
103324: PLUS
103325: PUSH
103326: LD_INT 5
103328: PUSH
103329: EMPTY
103330: LIST
103331: LIST
103332: LIST
103333: PUSH
103334: LD_VAR 0 1
103338: PUSH
103339: LD_INT 4
103341: PLUS
103342: PUSH
103343: LD_VAR 0 2
103347: PUSH
103348: LD_INT 4
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: LIST
103355: PUSH
103356: LD_VAR 0 1
103360: PUSH
103361: LD_VAR 0 2
103365: PUSH
103366: LD_INT 3
103368: MINUS
103369: PUSH
103370: LD_INT 3
103372: PUSH
103373: EMPTY
103374: LIST
103375: LIST
103376: LIST
103377: PUSH
103378: LD_VAR 0 1
103382: PUSH
103383: LD_INT 4
103385: MINUS
103386: PUSH
103387: LD_VAR 0 2
103391: PUSH
103392: LD_INT 4
103394: MINUS
103395: PUSH
103396: LD_INT 2
103398: PUSH
103399: EMPTY
103400: LIST
103401: LIST
103402: LIST
103403: PUSH
103404: EMPTY
103405: LIST
103406: LIST
103407: LIST
103408: LIST
103409: LIST
103410: ST_TO_ADDR
// end ; 5 :
103411: GO 103551
103413: LD_INT 5
103415: DOUBLE
103416: EQUAL
103417: IFTRUE 103421
103419: GO 103550
103421: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103422: LD_ADDR_VAR 0 5
103426: PUSH
103427: LD_VAR 0 1
103431: PUSH
103432: LD_INT 4
103434: MINUS
103435: PUSH
103436: LD_VAR 0 2
103440: PUSH
103441: LD_INT 1
103443: PUSH
103444: EMPTY
103445: LIST
103446: LIST
103447: LIST
103448: PUSH
103449: LD_VAR 0 1
103453: PUSH
103454: LD_VAR 0 2
103458: PUSH
103459: LD_INT 4
103461: MINUS
103462: PUSH
103463: LD_INT 3
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: LIST
103470: PUSH
103471: LD_VAR 0 1
103475: PUSH
103476: LD_INT 4
103478: PLUS
103479: PUSH
103480: LD_VAR 0 2
103484: PUSH
103485: LD_INT 4
103487: PLUS
103488: PUSH
103489: LD_INT 5
103491: PUSH
103492: EMPTY
103493: LIST
103494: LIST
103495: LIST
103496: PUSH
103497: LD_VAR 0 1
103501: PUSH
103502: LD_INT 3
103504: PLUS
103505: PUSH
103506: LD_VAR 0 2
103510: PUSH
103511: LD_INT 4
103513: PUSH
103514: EMPTY
103515: LIST
103516: LIST
103517: LIST
103518: PUSH
103519: LD_VAR 0 1
103523: PUSH
103524: LD_VAR 0 2
103528: PUSH
103529: LD_INT 3
103531: PLUS
103532: PUSH
103533: LD_INT 0
103535: PUSH
103536: EMPTY
103537: LIST
103538: LIST
103539: LIST
103540: PUSH
103541: EMPTY
103542: LIST
103543: LIST
103544: LIST
103545: LIST
103546: LIST
103547: ST_TO_ADDR
// end ; end ;
103548: GO 103551
103550: POP
// result := list ;
103551: LD_ADDR_VAR 0 4
103555: PUSH
103556: LD_VAR 0 5
103560: ST_TO_ADDR
// end ;
103561: LD_VAR 0 4
103565: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103566: LD_INT 0
103568: PPUSH
103569: PPUSH
103570: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103571: LD_VAR 0 1
103575: NOT
103576: PUSH
103577: LD_VAR 0 2
103581: PUSH
103582: LD_INT 1
103584: PUSH
103585: LD_INT 2
103587: PUSH
103588: LD_INT 3
103590: PUSH
103591: LD_INT 4
103593: PUSH
103594: EMPTY
103595: LIST
103596: LIST
103597: LIST
103598: LIST
103599: IN
103600: NOT
103601: OR
103602: IFFALSE 103606
// exit ;
103604: GO 103689
// tmp := [ ] ;
103606: LD_ADDR_VAR 0 5
103610: PUSH
103611: EMPTY
103612: ST_TO_ADDR
// for i in units do
103613: LD_ADDR_VAR 0 4
103617: PUSH
103618: LD_VAR 0 1
103622: PUSH
103623: FOR_IN
103624: IFFALSE 103658
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
103626: LD_ADDR_VAR 0 5
103630: PUSH
103631: LD_VAR 0 5
103635: PPUSH
103636: LD_VAR 0 4
103640: PPUSH
103641: LD_VAR 0 2
103645: PPUSH
103646: CALL_OW 259
103650: PPUSH
103651: CALL 105050 0 2
103655: ST_TO_ADDR
103656: GO 103623
103658: POP
103659: POP
// if not tmp then
103660: LD_VAR 0 5
103664: NOT
103665: IFFALSE 103669
// exit ;
103667: GO 103689
// result := SortListByListDesc ( units , tmp ) ;
103669: LD_ADDR_VAR 0 3
103673: PUSH
103674: LD_VAR 0 1
103678: PPUSH
103679: LD_VAR 0 5
103683: PPUSH
103684: CALL_OW 77
103688: ST_TO_ADDR
// end ;
103689: LD_VAR 0 3
103693: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103694: LD_INT 0
103696: PPUSH
103697: PPUSH
103698: PPUSH
// result := false ;
103699: LD_ADDR_VAR 0 3
103703: PUSH
103704: LD_INT 0
103706: ST_TO_ADDR
// if not building then
103707: LD_VAR 0 2
103711: NOT
103712: IFFALSE 103716
// exit ;
103714: GO 103854
// x := GetX ( building ) ;
103716: LD_ADDR_VAR 0 4
103720: PUSH
103721: LD_VAR 0 2
103725: PPUSH
103726: CALL_OW 250
103730: ST_TO_ADDR
// y := GetY ( building ) ;
103731: LD_ADDR_VAR 0 5
103735: PUSH
103736: LD_VAR 0 2
103740: PPUSH
103741: CALL_OW 251
103745: ST_TO_ADDR
// if not x or not y then
103746: LD_VAR 0 4
103750: NOT
103751: PUSH
103752: LD_VAR 0 5
103756: NOT
103757: OR
103758: IFFALSE 103762
// exit ;
103760: GO 103854
// if GetTaskList ( unit ) then
103762: LD_VAR 0 1
103766: PPUSH
103767: CALL_OW 437
103771: IFFALSE 103854
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103773: LD_STRING e
103775: PUSH
103776: LD_VAR 0 1
103780: PPUSH
103781: CALL_OW 437
103785: PUSH
103786: LD_INT 1
103788: ARRAY
103789: PUSH
103790: LD_INT 1
103792: ARRAY
103793: EQUAL
103794: PUSH
103795: LD_VAR 0 4
103799: PUSH
103800: LD_VAR 0 1
103804: PPUSH
103805: CALL_OW 437
103809: PUSH
103810: LD_INT 1
103812: ARRAY
103813: PUSH
103814: LD_INT 2
103816: ARRAY
103817: EQUAL
103818: AND
103819: PUSH
103820: LD_VAR 0 5
103824: PUSH
103825: LD_VAR 0 1
103829: PPUSH
103830: CALL_OW 437
103834: PUSH
103835: LD_INT 1
103837: ARRAY
103838: PUSH
103839: LD_INT 3
103841: ARRAY
103842: EQUAL
103843: AND
103844: IFFALSE 103854
// result := true end ;
103846: LD_ADDR_VAR 0 3
103850: PUSH
103851: LD_INT 1
103853: ST_TO_ADDR
// end ;
103854: LD_VAR 0 3
103858: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103859: LD_INT 0
103861: PPUSH
// result := false ;
103862: LD_ADDR_VAR 0 4
103866: PUSH
103867: LD_INT 0
103869: ST_TO_ADDR
// if GetTaskList ( unit ) then
103870: LD_VAR 0 1
103874: PPUSH
103875: CALL_OW 437
103879: IFFALSE 103962
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103881: LD_STRING M
103883: PUSH
103884: LD_VAR 0 1
103888: PPUSH
103889: CALL_OW 437
103893: PUSH
103894: LD_INT 1
103896: ARRAY
103897: PUSH
103898: LD_INT 1
103900: ARRAY
103901: EQUAL
103902: PUSH
103903: LD_VAR 0 2
103907: PUSH
103908: LD_VAR 0 1
103912: PPUSH
103913: CALL_OW 437
103917: PUSH
103918: LD_INT 1
103920: ARRAY
103921: PUSH
103922: LD_INT 2
103924: ARRAY
103925: EQUAL
103926: AND
103927: PUSH
103928: LD_VAR 0 3
103932: PUSH
103933: LD_VAR 0 1
103937: PPUSH
103938: CALL_OW 437
103942: PUSH
103943: LD_INT 1
103945: ARRAY
103946: PUSH
103947: LD_INT 3
103949: ARRAY
103950: EQUAL
103951: AND
103952: IFFALSE 103962
// result := true ;
103954: LD_ADDR_VAR 0 4
103958: PUSH
103959: LD_INT 1
103961: ST_TO_ADDR
// end ; end ;
103962: LD_VAR 0 4
103966: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103967: LD_INT 0
103969: PPUSH
103970: PPUSH
103971: PPUSH
103972: PPUSH
// if not unit or not area then
103973: LD_VAR 0 1
103977: NOT
103978: PUSH
103979: LD_VAR 0 2
103983: NOT
103984: OR
103985: IFFALSE 103989
// exit ;
103987: GO 104153
// tmp := AreaToList ( area , i ) ;
103989: LD_ADDR_VAR 0 6
103993: PUSH
103994: LD_VAR 0 2
103998: PPUSH
103999: LD_VAR 0 5
104003: PPUSH
104004: CALL_OW 517
104008: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104009: LD_ADDR_VAR 0 5
104013: PUSH
104014: DOUBLE
104015: LD_INT 1
104017: DEC
104018: ST_TO_ADDR
104019: LD_VAR 0 6
104023: PUSH
104024: LD_INT 1
104026: ARRAY
104027: PUSH
104028: FOR_TO
104029: IFFALSE 104151
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104031: LD_ADDR_VAR 0 7
104035: PUSH
104036: LD_VAR 0 6
104040: PUSH
104041: LD_INT 1
104043: ARRAY
104044: PUSH
104045: LD_VAR 0 5
104049: ARRAY
104050: PUSH
104051: LD_VAR 0 6
104055: PUSH
104056: LD_INT 2
104058: ARRAY
104059: PUSH
104060: LD_VAR 0 5
104064: ARRAY
104065: PUSH
104066: EMPTY
104067: LIST
104068: LIST
104069: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104070: LD_VAR 0 7
104074: PUSH
104075: LD_INT 1
104077: ARRAY
104078: PPUSH
104079: LD_VAR 0 7
104083: PUSH
104084: LD_INT 2
104086: ARRAY
104087: PPUSH
104088: CALL_OW 428
104092: PUSH
104093: LD_INT 0
104095: EQUAL
104096: IFFALSE 104149
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104098: LD_VAR 0 1
104102: PPUSH
104103: LD_VAR 0 7
104107: PUSH
104108: LD_INT 1
104110: ARRAY
104111: PPUSH
104112: LD_VAR 0 7
104116: PUSH
104117: LD_INT 2
104119: ARRAY
104120: PPUSH
104121: LD_VAR 0 3
104125: PPUSH
104126: CALL_OW 48
// result := IsPlaced ( unit ) ;
104130: LD_ADDR_VAR 0 4
104134: PUSH
104135: LD_VAR 0 1
104139: PPUSH
104140: CALL_OW 305
104144: ST_TO_ADDR
// exit ;
104145: POP
104146: POP
104147: GO 104153
// end ; end ;
104149: GO 104028
104151: POP
104152: POP
// end ;
104153: LD_VAR 0 4
104157: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104158: LD_INT 0
104160: PPUSH
104161: PPUSH
104162: PPUSH
// if not side or side > 8 then
104163: LD_VAR 0 1
104167: NOT
104168: PUSH
104169: LD_VAR 0 1
104173: PUSH
104174: LD_INT 8
104176: GREATER
104177: OR
104178: IFFALSE 104182
// exit ;
104180: GO 104369
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104182: LD_ADDR_VAR 0 4
104186: PUSH
104187: LD_INT 22
104189: PUSH
104190: LD_VAR 0 1
104194: PUSH
104195: EMPTY
104196: LIST
104197: LIST
104198: PUSH
104199: LD_INT 21
104201: PUSH
104202: LD_INT 3
104204: PUSH
104205: EMPTY
104206: LIST
104207: LIST
104208: PUSH
104209: EMPTY
104210: LIST
104211: LIST
104212: PPUSH
104213: CALL_OW 69
104217: ST_TO_ADDR
// if not tmp then
104218: LD_VAR 0 4
104222: NOT
104223: IFFALSE 104227
// exit ;
104225: GO 104369
// enable_addtolog := true ;
104227: LD_ADDR_OWVAR 81
104231: PUSH
104232: LD_INT 1
104234: ST_TO_ADDR
// AddToLog ( [ ) ;
104235: LD_STRING [
104237: PPUSH
104238: CALL_OW 561
// for i in tmp do
104242: LD_ADDR_VAR 0 3
104246: PUSH
104247: LD_VAR 0 4
104251: PUSH
104252: FOR_IN
104253: IFFALSE 104360
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104255: LD_STRING [
104257: PUSH
104258: LD_VAR 0 3
104262: PPUSH
104263: CALL_OW 266
104267: STR
104268: PUSH
104269: LD_STRING , 
104271: STR
104272: PUSH
104273: LD_VAR 0 3
104277: PPUSH
104278: CALL_OW 250
104282: STR
104283: PUSH
104284: LD_STRING , 
104286: STR
104287: PUSH
104288: LD_VAR 0 3
104292: PPUSH
104293: CALL_OW 251
104297: STR
104298: PUSH
104299: LD_STRING , 
104301: STR
104302: PUSH
104303: LD_VAR 0 3
104307: PPUSH
104308: CALL_OW 254
104312: STR
104313: PUSH
104314: LD_STRING , 
104316: STR
104317: PUSH
104318: LD_VAR 0 3
104322: PPUSH
104323: LD_INT 1
104325: PPUSH
104326: CALL_OW 268
104330: STR
104331: PUSH
104332: LD_STRING , 
104334: STR
104335: PUSH
104336: LD_VAR 0 3
104340: PPUSH
104341: LD_INT 2
104343: PPUSH
104344: CALL_OW 268
104348: STR
104349: PUSH
104350: LD_STRING ],
104352: STR
104353: PPUSH
104354: CALL_OW 561
// end ;
104358: GO 104252
104360: POP
104361: POP
// AddToLog ( ]; ) ;
104362: LD_STRING ];
104364: PPUSH
104365: CALL_OW 561
// end ;
104369: LD_VAR 0 2
104373: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104374: LD_INT 0
104376: PPUSH
104377: PPUSH
104378: PPUSH
104379: PPUSH
104380: PPUSH
// if not area or not rate or not max then
104381: LD_VAR 0 1
104385: NOT
104386: PUSH
104387: LD_VAR 0 2
104391: NOT
104392: OR
104393: PUSH
104394: LD_VAR 0 4
104398: NOT
104399: OR
104400: IFFALSE 104404
// exit ;
104402: GO 104593
// while 1 do
104404: LD_INT 1
104406: IFFALSE 104593
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104408: LD_ADDR_VAR 0 9
104412: PUSH
104413: LD_VAR 0 1
104417: PPUSH
104418: LD_INT 1
104420: PPUSH
104421: CALL_OW 287
104425: PUSH
104426: LD_INT 10
104428: MUL
104429: ST_TO_ADDR
// r := rate / 10 ;
104430: LD_ADDR_VAR 0 7
104434: PUSH
104435: LD_VAR 0 2
104439: PUSH
104440: LD_INT 10
104442: DIVREAL
104443: ST_TO_ADDR
// time := 1 1$00 ;
104444: LD_ADDR_VAR 0 8
104448: PUSH
104449: LD_INT 2100
104451: ST_TO_ADDR
// if amount < min then
104452: LD_VAR 0 9
104456: PUSH
104457: LD_VAR 0 3
104461: LESS
104462: IFFALSE 104480
// r := r * 2 else
104464: LD_ADDR_VAR 0 7
104468: PUSH
104469: LD_VAR 0 7
104473: PUSH
104474: LD_INT 2
104476: MUL
104477: ST_TO_ADDR
104478: GO 104506
// if amount > max then
104480: LD_VAR 0 9
104484: PUSH
104485: LD_VAR 0 4
104489: GREATER
104490: IFFALSE 104506
// r := r / 2 ;
104492: LD_ADDR_VAR 0 7
104496: PUSH
104497: LD_VAR 0 7
104501: PUSH
104502: LD_INT 2
104504: DIVREAL
104505: ST_TO_ADDR
// time := time / r ;
104506: LD_ADDR_VAR 0 8
104510: PUSH
104511: LD_VAR 0 8
104515: PUSH
104516: LD_VAR 0 7
104520: DIVREAL
104521: ST_TO_ADDR
// if time < 0 then
104522: LD_VAR 0 8
104526: PUSH
104527: LD_INT 0
104529: LESS
104530: IFFALSE 104547
// time := time * - 1 ;
104532: LD_ADDR_VAR 0 8
104536: PUSH
104537: LD_VAR 0 8
104541: PUSH
104542: LD_INT 1
104544: NEG
104545: MUL
104546: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104547: LD_VAR 0 8
104551: PUSH
104552: LD_INT 35
104554: PPUSH
104555: LD_INT 875
104557: PPUSH
104558: CALL_OW 12
104562: PLUS
104563: PPUSH
104564: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104568: LD_INT 1
104570: PPUSH
104571: LD_INT 5
104573: PPUSH
104574: CALL_OW 12
104578: PPUSH
104579: LD_VAR 0 1
104583: PPUSH
104584: LD_INT 1
104586: PPUSH
104587: CALL_OW 55
// end ;
104591: GO 104404
// end ;
104593: LD_VAR 0 5
104597: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104598: LD_INT 0
104600: PPUSH
104601: PPUSH
104602: PPUSH
104603: PPUSH
104604: PPUSH
104605: PPUSH
104606: PPUSH
104607: PPUSH
// if not turrets or not factories then
104608: LD_VAR 0 1
104612: NOT
104613: PUSH
104614: LD_VAR 0 2
104618: NOT
104619: OR
104620: IFFALSE 104624
// exit ;
104622: GO 104931
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104624: LD_ADDR_VAR 0 10
104628: PUSH
104629: LD_INT 5
104631: PUSH
104632: LD_INT 6
104634: PUSH
104635: EMPTY
104636: LIST
104637: LIST
104638: PUSH
104639: LD_INT 2
104641: PUSH
104642: LD_INT 4
104644: PUSH
104645: EMPTY
104646: LIST
104647: LIST
104648: PUSH
104649: LD_INT 3
104651: PUSH
104652: LD_INT 5
104654: PUSH
104655: EMPTY
104656: LIST
104657: LIST
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: LIST
104663: PUSH
104664: LD_INT 24
104666: PUSH
104667: LD_INT 25
104669: PUSH
104670: EMPTY
104671: LIST
104672: LIST
104673: PUSH
104674: LD_INT 23
104676: PUSH
104677: LD_INT 27
104679: PUSH
104680: EMPTY
104681: LIST
104682: LIST
104683: PUSH
104684: EMPTY
104685: LIST
104686: LIST
104687: PUSH
104688: LD_INT 42
104690: PUSH
104691: LD_INT 43
104693: PUSH
104694: EMPTY
104695: LIST
104696: LIST
104697: PUSH
104698: LD_INT 44
104700: PUSH
104701: LD_INT 46
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: PUSH
104708: LD_INT 45
104710: PUSH
104711: LD_INT 47
104713: PUSH
104714: EMPTY
104715: LIST
104716: LIST
104717: PUSH
104718: EMPTY
104719: LIST
104720: LIST
104721: LIST
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: LIST
104727: ST_TO_ADDR
// result := [ ] ;
104728: LD_ADDR_VAR 0 3
104732: PUSH
104733: EMPTY
104734: ST_TO_ADDR
// for i in turrets do
104735: LD_ADDR_VAR 0 4
104739: PUSH
104740: LD_VAR 0 1
104744: PUSH
104745: FOR_IN
104746: IFFALSE 104929
// begin nat := GetNation ( i ) ;
104748: LD_ADDR_VAR 0 7
104752: PUSH
104753: LD_VAR 0 4
104757: PPUSH
104758: CALL_OW 248
104762: ST_TO_ADDR
// weapon := 0 ;
104763: LD_ADDR_VAR 0 8
104767: PUSH
104768: LD_INT 0
104770: ST_TO_ADDR
// if not nat then
104771: LD_VAR 0 7
104775: NOT
104776: IFFALSE 104780
// continue ;
104778: GO 104745
// for j in list [ nat ] do
104780: LD_ADDR_VAR 0 5
104784: PUSH
104785: LD_VAR 0 10
104789: PUSH
104790: LD_VAR 0 7
104794: ARRAY
104795: PUSH
104796: FOR_IN
104797: IFFALSE 104838
// if GetBWeapon ( i ) = j [ 1 ] then
104799: LD_VAR 0 4
104803: PPUSH
104804: CALL_OW 269
104808: PUSH
104809: LD_VAR 0 5
104813: PUSH
104814: LD_INT 1
104816: ARRAY
104817: EQUAL
104818: IFFALSE 104836
// begin weapon := j [ 2 ] ;
104820: LD_ADDR_VAR 0 8
104824: PUSH
104825: LD_VAR 0 5
104829: PUSH
104830: LD_INT 2
104832: ARRAY
104833: ST_TO_ADDR
// break ;
104834: GO 104838
// end ;
104836: GO 104796
104838: POP
104839: POP
// if not weapon then
104840: LD_VAR 0 8
104844: NOT
104845: IFFALSE 104849
// continue ;
104847: GO 104745
// for k in factories do
104849: LD_ADDR_VAR 0 6
104853: PUSH
104854: LD_VAR 0 2
104858: PUSH
104859: FOR_IN
104860: IFFALSE 104925
// begin weapons := AvailableWeaponList ( k ) ;
104862: LD_ADDR_VAR 0 9
104866: PUSH
104867: LD_VAR 0 6
104871: PPUSH
104872: CALL_OW 478
104876: ST_TO_ADDR
// if not weapons then
104877: LD_VAR 0 9
104881: NOT
104882: IFFALSE 104886
// continue ;
104884: GO 104859
// if weapon in weapons then
104886: LD_VAR 0 8
104890: PUSH
104891: LD_VAR 0 9
104895: IN
104896: IFFALSE 104923
// begin result := [ i , weapon ] ;
104898: LD_ADDR_VAR 0 3
104902: PUSH
104903: LD_VAR 0 4
104907: PUSH
104908: LD_VAR 0 8
104912: PUSH
104913: EMPTY
104914: LIST
104915: LIST
104916: ST_TO_ADDR
// exit ;
104917: POP
104918: POP
104919: POP
104920: POP
104921: GO 104931
// end ; end ;
104923: GO 104859
104925: POP
104926: POP
// end ;
104927: GO 104745
104929: POP
104930: POP
// end ;
104931: LD_VAR 0 3
104935: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104936: LD_INT 0
104938: PPUSH
// if not side or side > 8 then
104939: LD_VAR 0 3
104943: NOT
104944: PUSH
104945: LD_VAR 0 3
104949: PUSH
104950: LD_INT 8
104952: GREATER
104953: OR
104954: IFFALSE 104958
// exit ;
104956: GO 105017
// if not range then
104958: LD_VAR 0 4
104962: NOT
104963: IFFALSE 104974
// range := - 12 ;
104965: LD_ADDR_VAR 0 4
104969: PUSH
104970: LD_INT 12
104972: NEG
104973: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104974: LD_VAR 0 1
104978: PPUSH
104979: LD_VAR 0 2
104983: PPUSH
104984: LD_VAR 0 3
104988: PPUSH
104989: LD_VAR 0 4
104993: PPUSH
104994: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104998: LD_VAR 0 1
105002: PPUSH
105003: LD_VAR 0 2
105007: PPUSH
105008: LD_VAR 0 3
105012: PPUSH
105013: CALL_OW 331
// end ;
105017: LD_VAR 0 5
105021: RET
// export function Video ( mode ) ; begin
105022: LD_INT 0
105024: PPUSH
// ingame_video = mode ;
105025: LD_ADDR_OWVAR 52
105029: PUSH
105030: LD_VAR 0 1
105034: ST_TO_ADDR
// interface_hidden = mode ;
105035: LD_ADDR_OWVAR 54
105039: PUSH
105040: LD_VAR 0 1
105044: ST_TO_ADDR
// end ;
105045: LD_VAR 0 2
105049: RET
// export function Join ( array , element ) ; begin
105050: LD_INT 0
105052: PPUSH
// result := Replace ( array , array + 1 , element ) ;
105053: LD_ADDR_VAR 0 3
105057: PUSH
105058: LD_VAR 0 1
105062: PPUSH
105063: LD_VAR 0 1
105067: PUSH
105068: LD_INT 1
105070: PLUS
105071: PPUSH
105072: LD_VAR 0 2
105076: PPUSH
105077: CALL_OW 1
105081: ST_TO_ADDR
// end ;
105082: LD_VAR 0 3
105086: RET
// export function JoinUnion ( array , element ) ; begin
105087: LD_INT 0
105089: PPUSH
// result := array union element ;
105090: LD_ADDR_VAR 0 3
105094: PUSH
105095: LD_VAR 0 1
105099: PUSH
105100: LD_VAR 0 2
105104: UNION
105105: ST_TO_ADDR
// end ;
105106: LD_VAR 0 3
105110: RET
// export function GetBehemoths ( side ) ; begin
105111: LD_INT 0
105113: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105114: LD_ADDR_VAR 0 2
105118: PUSH
105119: LD_INT 22
105121: PUSH
105122: LD_VAR 0 1
105126: PUSH
105127: EMPTY
105128: LIST
105129: LIST
105130: PUSH
105131: LD_INT 31
105133: PUSH
105134: LD_INT 25
105136: PUSH
105137: EMPTY
105138: LIST
105139: LIST
105140: PUSH
105141: EMPTY
105142: LIST
105143: LIST
105144: PPUSH
105145: CALL_OW 69
105149: ST_TO_ADDR
// end ;
105150: LD_VAR 0 2
105154: RET
// export function Shuffle ( array ) ; var i , index ; begin
105155: LD_INT 0
105157: PPUSH
105158: PPUSH
105159: PPUSH
// result := [ ] ;
105160: LD_ADDR_VAR 0 2
105164: PUSH
105165: EMPTY
105166: ST_TO_ADDR
// if not array then
105167: LD_VAR 0 1
105171: NOT
105172: IFFALSE 105176
// exit ;
105174: GO 105275
// Randomize ;
105176: CALL_OW 10
// for i = array downto 1 do
105180: LD_ADDR_VAR 0 3
105184: PUSH
105185: DOUBLE
105186: LD_VAR 0 1
105190: INC
105191: ST_TO_ADDR
105192: LD_INT 1
105194: PUSH
105195: FOR_DOWNTO
105196: IFFALSE 105273
// begin index := rand ( 1 , array ) ;
105198: LD_ADDR_VAR 0 4
105202: PUSH
105203: LD_INT 1
105205: PPUSH
105206: LD_VAR 0 1
105210: PPUSH
105211: CALL_OW 12
105215: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105216: LD_ADDR_VAR 0 2
105220: PUSH
105221: LD_VAR 0 2
105225: PPUSH
105226: LD_VAR 0 2
105230: PUSH
105231: LD_INT 1
105233: PLUS
105234: PPUSH
105235: LD_VAR 0 1
105239: PUSH
105240: LD_VAR 0 4
105244: ARRAY
105245: PPUSH
105246: CALL_OW 2
105250: ST_TO_ADDR
// array := Delete ( array , index ) ;
105251: LD_ADDR_VAR 0 1
105255: PUSH
105256: LD_VAR 0 1
105260: PPUSH
105261: LD_VAR 0 4
105265: PPUSH
105266: CALL_OW 3
105270: ST_TO_ADDR
// end ;
105271: GO 105195
105273: POP
105274: POP
// end ;
105275: LD_VAR 0 2
105279: RET
// export function GetBaseMaterials ( base ) ; begin
105280: LD_INT 0
105282: PPUSH
// result := [ 0 , 0 , 0 ] ;
105283: LD_ADDR_VAR 0 2
105287: PUSH
105288: LD_INT 0
105290: PUSH
105291: LD_INT 0
105293: PUSH
105294: LD_INT 0
105296: PUSH
105297: EMPTY
105298: LIST
105299: LIST
105300: LIST
105301: ST_TO_ADDR
// if not base then
105302: LD_VAR 0 1
105306: NOT
105307: IFFALSE 105311
// exit ;
105309: GO 105360
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
105311: LD_ADDR_VAR 0 2
105315: PUSH
105316: LD_VAR 0 1
105320: PPUSH
105321: LD_INT 1
105323: PPUSH
105324: CALL_OW 275
105328: PUSH
105329: LD_VAR 0 1
105333: PPUSH
105334: LD_INT 2
105336: PPUSH
105337: CALL_OW 275
105341: PUSH
105342: LD_VAR 0 1
105346: PPUSH
105347: LD_INT 3
105349: PPUSH
105350: CALL_OW 275
105354: PUSH
105355: EMPTY
105356: LIST
105357: LIST
105358: LIST
105359: ST_TO_ADDR
// end ;
105360: LD_VAR 0 2
105364: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
105365: LD_INT 0
105367: PPUSH
105368: PPUSH
// result := array ;
105369: LD_ADDR_VAR 0 3
105373: PUSH
105374: LD_VAR 0 1
105378: ST_TO_ADDR
// if size >= result then
105379: LD_VAR 0 2
105383: PUSH
105384: LD_VAR 0 3
105388: GREATEREQUAL
105389: IFFALSE 105393
// exit ;
105391: GO 105443
// if size then
105393: LD_VAR 0 2
105397: IFFALSE 105443
// for i := array downto size do
105399: LD_ADDR_VAR 0 4
105403: PUSH
105404: DOUBLE
105405: LD_VAR 0 1
105409: INC
105410: ST_TO_ADDR
105411: LD_VAR 0 2
105415: PUSH
105416: FOR_DOWNTO
105417: IFFALSE 105441
// result := Delete ( result , result ) ;
105419: LD_ADDR_VAR 0 3
105423: PUSH
105424: LD_VAR 0 3
105428: PPUSH
105429: LD_VAR 0 3
105433: PPUSH
105434: CALL_OW 3
105438: ST_TO_ADDR
105439: GO 105416
105441: POP
105442: POP
// end ;
105443: LD_VAR 0 3
105447: RET
// export function ComExit ( unit ) ; var tmp ; begin
105448: LD_INT 0
105450: PPUSH
105451: PPUSH
// if not IsInUnit ( unit ) then
105452: LD_VAR 0 1
105456: PPUSH
105457: CALL_OW 310
105461: NOT
105462: IFFALSE 105466
// exit ;
105464: GO 105526
// tmp := IsInUnit ( unit ) ;
105466: LD_ADDR_VAR 0 3
105470: PUSH
105471: LD_VAR 0 1
105475: PPUSH
105476: CALL_OW 310
105480: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105481: LD_VAR 0 3
105485: PPUSH
105486: CALL_OW 247
105490: PUSH
105491: LD_INT 2
105493: EQUAL
105494: IFFALSE 105507
// ComExitVehicle ( unit ) else
105496: LD_VAR 0 1
105500: PPUSH
105501: CALL_OW 121
105505: GO 105516
// ComExitBuilding ( unit ) ;
105507: LD_VAR 0 1
105511: PPUSH
105512: CALL_OW 122
// result := tmp ;
105516: LD_ADDR_VAR 0 2
105520: PUSH
105521: LD_VAR 0 3
105525: ST_TO_ADDR
// end ;
105526: LD_VAR 0 2
105530: RET
// export function ComExitAll ( units ) ; var i ; begin
105531: LD_INT 0
105533: PPUSH
105534: PPUSH
// if not units then
105535: LD_VAR 0 1
105539: NOT
105540: IFFALSE 105544
// exit ;
105542: GO 105570
// for i in units do
105544: LD_ADDR_VAR 0 3
105548: PUSH
105549: LD_VAR 0 1
105553: PUSH
105554: FOR_IN
105555: IFFALSE 105568
// ComExit ( i ) ;
105557: LD_VAR 0 3
105561: PPUSH
105562: CALL 105448 0 1
105566: GO 105554
105568: POP
105569: POP
// end ;
105570: LD_VAR 0 2
105574: RET
// export function ResetHc ; begin
105575: LD_INT 0
105577: PPUSH
// InitHc ;
105578: CALL_OW 19
// hc_importance := 0 ;
105582: LD_ADDR_OWVAR 32
105586: PUSH
105587: LD_INT 0
105589: ST_TO_ADDR
// end ;
105590: LD_VAR 0 1
105594: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105595: LD_INT 0
105597: PPUSH
105598: PPUSH
105599: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105600: LD_ADDR_VAR 0 6
105604: PUSH
105605: LD_VAR 0 1
105609: PUSH
105610: LD_VAR 0 3
105614: PLUS
105615: PUSH
105616: LD_INT 2
105618: DIV
105619: ST_TO_ADDR
// if _x < 0 then
105620: LD_VAR 0 6
105624: PUSH
105625: LD_INT 0
105627: LESS
105628: IFFALSE 105645
// _x := _x * - 1 ;
105630: LD_ADDR_VAR 0 6
105634: PUSH
105635: LD_VAR 0 6
105639: PUSH
105640: LD_INT 1
105642: NEG
105643: MUL
105644: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105645: LD_ADDR_VAR 0 7
105649: PUSH
105650: LD_VAR 0 2
105654: PUSH
105655: LD_VAR 0 4
105659: PLUS
105660: PUSH
105661: LD_INT 2
105663: DIV
105664: ST_TO_ADDR
// if _y < 0 then
105665: LD_VAR 0 7
105669: PUSH
105670: LD_INT 0
105672: LESS
105673: IFFALSE 105690
// _y := _y * - 1 ;
105675: LD_ADDR_VAR 0 7
105679: PUSH
105680: LD_VAR 0 7
105684: PUSH
105685: LD_INT 1
105687: NEG
105688: MUL
105689: ST_TO_ADDR
// result := [ _x , _y ] ;
105690: LD_ADDR_VAR 0 5
105694: PUSH
105695: LD_VAR 0 6
105699: PUSH
105700: LD_VAR 0 7
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: ST_TO_ADDR
// end ;
105709: LD_VAR 0 5
105713: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105714: LD_INT 0
105716: PPUSH
105717: PPUSH
105718: PPUSH
105719: PPUSH
// task := GetTaskList ( unit ) ;
105720: LD_ADDR_VAR 0 7
105724: PUSH
105725: LD_VAR 0 1
105729: PPUSH
105730: CALL_OW 437
105734: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105735: LD_VAR 0 7
105739: NOT
105740: PUSH
105741: LD_VAR 0 1
105745: PPUSH
105746: LD_VAR 0 2
105750: PPUSH
105751: CALL_OW 308
105755: NOT
105756: AND
105757: IFFALSE 105761
// exit ;
105759: GO 105879
// if IsInArea ( unit , area ) then
105761: LD_VAR 0 1
105765: PPUSH
105766: LD_VAR 0 2
105770: PPUSH
105771: CALL_OW 308
105775: IFFALSE 105793
// begin ComMoveToArea ( unit , goAway ) ;
105777: LD_VAR 0 1
105781: PPUSH
105782: LD_VAR 0 3
105786: PPUSH
105787: CALL_OW 113
// exit ;
105791: GO 105879
// end ; if task [ 1 ] [ 1 ] <> M then
105793: LD_VAR 0 7
105797: PUSH
105798: LD_INT 1
105800: ARRAY
105801: PUSH
105802: LD_INT 1
105804: ARRAY
105805: PUSH
105806: LD_STRING M
105808: NONEQUAL
105809: IFFALSE 105813
// exit ;
105811: GO 105879
// x := task [ 1 ] [ 2 ] ;
105813: LD_ADDR_VAR 0 5
105817: PUSH
105818: LD_VAR 0 7
105822: PUSH
105823: LD_INT 1
105825: ARRAY
105826: PUSH
105827: LD_INT 2
105829: ARRAY
105830: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105831: LD_ADDR_VAR 0 6
105835: PUSH
105836: LD_VAR 0 7
105840: PUSH
105841: LD_INT 1
105843: ARRAY
105844: PUSH
105845: LD_INT 3
105847: ARRAY
105848: ST_TO_ADDR
// if InArea ( x , y , area ) then
105849: LD_VAR 0 5
105853: PPUSH
105854: LD_VAR 0 6
105858: PPUSH
105859: LD_VAR 0 2
105863: PPUSH
105864: CALL_OW 309
105868: IFFALSE 105879
// ComStop ( unit ) ;
105870: LD_VAR 0 1
105874: PPUSH
105875: CALL_OW 141
// end ;
105879: LD_VAR 0 4
105883: RET
// export function Abs ( value ) ; begin
105884: LD_INT 0
105886: PPUSH
// result := value ;
105887: LD_ADDR_VAR 0 2
105891: PUSH
105892: LD_VAR 0 1
105896: ST_TO_ADDR
// if value < 0 then
105897: LD_VAR 0 1
105901: PUSH
105902: LD_INT 0
105904: LESS
105905: IFFALSE 105922
// result := value * - 1 ;
105907: LD_ADDR_VAR 0 2
105911: PUSH
105912: LD_VAR 0 1
105916: PUSH
105917: LD_INT 1
105919: NEG
105920: MUL
105921: ST_TO_ADDR
// end ;
105922: LD_VAR 0 2
105926: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105927: LD_INT 0
105929: PPUSH
105930: PPUSH
105931: PPUSH
105932: PPUSH
105933: PPUSH
105934: PPUSH
105935: PPUSH
105936: PPUSH
// if not unit or not building then
105937: LD_VAR 0 1
105941: NOT
105942: PUSH
105943: LD_VAR 0 2
105947: NOT
105948: OR
105949: IFFALSE 105953
// exit ;
105951: GO 106179
// x := GetX ( building ) ;
105953: LD_ADDR_VAR 0 4
105957: PUSH
105958: LD_VAR 0 2
105962: PPUSH
105963: CALL_OW 250
105967: ST_TO_ADDR
// y := GetY ( building ) ;
105968: LD_ADDR_VAR 0 6
105972: PUSH
105973: LD_VAR 0 2
105977: PPUSH
105978: CALL_OW 251
105982: ST_TO_ADDR
// d := GetDir ( building ) ;
105983: LD_ADDR_VAR 0 8
105987: PUSH
105988: LD_VAR 0 2
105992: PPUSH
105993: CALL_OW 254
105997: ST_TO_ADDR
// r := 4 ;
105998: LD_ADDR_VAR 0 9
106002: PUSH
106003: LD_INT 4
106005: ST_TO_ADDR
// for i := 1 to 5 do
106006: LD_ADDR_VAR 0 10
106010: PUSH
106011: DOUBLE
106012: LD_INT 1
106014: DEC
106015: ST_TO_ADDR
106016: LD_INT 5
106018: PUSH
106019: FOR_TO
106020: IFFALSE 106177
// begin _x := ShiftX ( x , d , r + i ) ;
106022: LD_ADDR_VAR 0 5
106026: PUSH
106027: LD_VAR 0 4
106031: PPUSH
106032: LD_VAR 0 8
106036: PPUSH
106037: LD_VAR 0 9
106041: PUSH
106042: LD_VAR 0 10
106046: PLUS
106047: PPUSH
106048: CALL_OW 272
106052: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
106053: LD_ADDR_VAR 0 7
106057: PUSH
106058: LD_VAR 0 6
106062: PPUSH
106063: LD_VAR 0 8
106067: PPUSH
106068: LD_VAR 0 9
106072: PUSH
106073: LD_VAR 0 10
106077: PLUS
106078: PPUSH
106079: CALL_OW 273
106083: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
106084: LD_VAR 0 5
106088: PPUSH
106089: LD_VAR 0 7
106093: PPUSH
106094: CALL_OW 488
106098: PUSH
106099: LD_VAR 0 5
106103: PPUSH
106104: LD_VAR 0 7
106108: PPUSH
106109: CALL_OW 428
106113: PPUSH
106114: CALL_OW 247
106118: PUSH
106119: LD_INT 3
106121: PUSH
106122: LD_INT 2
106124: PUSH
106125: EMPTY
106126: LIST
106127: LIST
106128: IN
106129: NOT
106130: AND
106131: IFFALSE 106175
// begin ComMoveXY ( unit , _x , _y ) ;
106133: LD_VAR 0 1
106137: PPUSH
106138: LD_VAR 0 5
106142: PPUSH
106143: LD_VAR 0 7
106147: PPUSH
106148: CALL_OW 111
// result := [ _x , _y ] ;
106152: LD_ADDR_VAR 0 3
106156: PUSH
106157: LD_VAR 0 5
106161: PUSH
106162: LD_VAR 0 7
106166: PUSH
106167: EMPTY
106168: LIST
106169: LIST
106170: ST_TO_ADDR
// exit ;
106171: POP
106172: POP
106173: GO 106179
// end ; end ;
106175: GO 106019
106177: POP
106178: POP
// end ;
106179: LD_VAR 0 3
106183: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106184: LD_INT 0
106186: PPUSH
106187: PPUSH
106188: PPUSH
// result := 0 ;
106189: LD_ADDR_VAR 0 3
106193: PUSH
106194: LD_INT 0
106196: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106197: LD_VAR 0 1
106201: PUSH
106202: LD_INT 0
106204: LESS
106205: PUSH
106206: LD_VAR 0 1
106210: PUSH
106211: LD_INT 8
106213: GREATER
106214: OR
106215: PUSH
106216: LD_VAR 0 2
106220: PUSH
106221: LD_INT 0
106223: LESS
106224: OR
106225: PUSH
106226: LD_VAR 0 2
106230: PUSH
106231: LD_INT 8
106233: GREATER
106234: OR
106235: IFFALSE 106239
// exit ;
106237: GO 106314
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
106239: LD_ADDR_VAR 0 4
106243: PUSH
106244: LD_INT 22
106246: PUSH
106247: LD_VAR 0 2
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: PPUSH
106256: CALL_OW 69
106260: PUSH
106261: FOR_IN
106262: IFFALSE 106312
// begin un := UnitShoot ( i ) ;
106264: LD_ADDR_VAR 0 5
106268: PUSH
106269: LD_VAR 0 4
106273: PPUSH
106274: CALL_OW 504
106278: ST_TO_ADDR
// if GetSide ( un ) = side1 then
106279: LD_VAR 0 5
106283: PPUSH
106284: CALL_OW 255
106288: PUSH
106289: LD_VAR 0 1
106293: EQUAL
106294: IFFALSE 106310
// begin result := un ;
106296: LD_ADDR_VAR 0 3
106300: PUSH
106301: LD_VAR 0 5
106305: ST_TO_ADDR
// exit ;
106306: POP
106307: POP
106308: GO 106314
// end ; end ;
106310: GO 106261
106312: POP
106313: POP
// end ;
106314: LD_VAR 0 3
106318: RET
// export function GetCargoBay ( units ) ; begin
106319: LD_INT 0
106321: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
106322: LD_ADDR_VAR 0 2
106326: PUSH
106327: LD_VAR 0 1
106331: PPUSH
106332: LD_INT 2
106334: PUSH
106335: LD_INT 34
106337: PUSH
106338: LD_INT 12
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: PUSH
106345: LD_INT 34
106347: PUSH
106348: LD_INT 51
106350: PUSH
106351: EMPTY
106352: LIST
106353: LIST
106354: PUSH
106355: LD_INT 34
106357: PUSH
106358: LD_INT 32
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: PUSH
106365: LD_INT 34
106367: PUSH
106368: LD_INT 89
106370: PUSH
106371: EMPTY
106372: LIST
106373: LIST
106374: PUSH
106375: EMPTY
106376: LIST
106377: LIST
106378: LIST
106379: LIST
106380: LIST
106381: PPUSH
106382: CALL_OW 72
106386: ST_TO_ADDR
// end ;
106387: LD_VAR 0 2
106391: RET
// export function Negate ( value ) ; begin
106392: LD_INT 0
106394: PPUSH
// result := not value ;
106395: LD_ADDR_VAR 0 2
106399: PUSH
106400: LD_VAR 0 1
106404: NOT
106405: ST_TO_ADDR
// end ;
106406: LD_VAR 0 2
106410: RET
// export function Inc ( value ) ; begin
106411: LD_INT 0
106413: PPUSH
// result := value + 1 ;
106414: LD_ADDR_VAR 0 2
106418: PUSH
106419: LD_VAR 0 1
106423: PUSH
106424: LD_INT 1
106426: PLUS
106427: ST_TO_ADDR
// end ;
106428: LD_VAR 0 2
106432: RET
// export function Dec ( value ) ; begin
106433: LD_INT 0
106435: PPUSH
// result := value - 1 ;
106436: LD_ADDR_VAR 0 2
106440: PUSH
106441: LD_VAR 0 1
106445: PUSH
106446: LD_INT 1
106448: MINUS
106449: ST_TO_ADDR
// end ;
106450: LD_VAR 0 2
106454: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106455: LD_INT 0
106457: PPUSH
106458: PPUSH
106459: PPUSH
106460: PPUSH
106461: PPUSH
106462: PPUSH
106463: PPUSH
106464: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106465: LD_VAR 0 1
106469: PPUSH
106470: LD_VAR 0 2
106474: PPUSH
106475: CALL_OW 488
106479: NOT
106480: PUSH
106481: LD_VAR 0 3
106485: PPUSH
106486: LD_VAR 0 4
106490: PPUSH
106491: CALL_OW 488
106495: NOT
106496: OR
106497: IFFALSE 106510
// begin result := - 1 ;
106499: LD_ADDR_VAR 0 5
106503: PUSH
106504: LD_INT 1
106506: NEG
106507: ST_TO_ADDR
// exit ;
106508: GO 106745
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106510: LD_ADDR_VAR 0 12
106514: PUSH
106515: LD_VAR 0 1
106519: PPUSH
106520: LD_VAR 0 2
106524: PPUSH
106525: LD_VAR 0 3
106529: PPUSH
106530: LD_VAR 0 4
106534: PPUSH
106535: CALL 105595 0 4
106539: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106540: LD_ADDR_VAR 0 11
106544: PUSH
106545: LD_VAR 0 1
106549: PPUSH
106550: LD_VAR 0 2
106554: PPUSH
106555: LD_VAR 0 12
106559: PUSH
106560: LD_INT 1
106562: ARRAY
106563: PPUSH
106564: LD_VAR 0 12
106568: PUSH
106569: LD_INT 2
106571: ARRAY
106572: PPUSH
106573: CALL_OW 298
106577: ST_TO_ADDR
// distance := 9999 ;
106578: LD_ADDR_VAR 0 10
106582: PUSH
106583: LD_INT 9999
106585: ST_TO_ADDR
// for i := 0 to 5 do
106586: LD_ADDR_VAR 0 6
106590: PUSH
106591: DOUBLE
106592: LD_INT 0
106594: DEC
106595: ST_TO_ADDR
106596: LD_INT 5
106598: PUSH
106599: FOR_TO
106600: IFFALSE 106743
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106602: LD_ADDR_VAR 0 7
106606: PUSH
106607: LD_VAR 0 1
106611: PPUSH
106612: LD_VAR 0 6
106616: PPUSH
106617: LD_VAR 0 11
106621: PPUSH
106622: CALL_OW 272
106626: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106627: LD_ADDR_VAR 0 8
106631: PUSH
106632: LD_VAR 0 2
106636: PPUSH
106637: LD_VAR 0 6
106641: PPUSH
106642: LD_VAR 0 11
106646: PPUSH
106647: CALL_OW 273
106651: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106652: LD_VAR 0 7
106656: PPUSH
106657: LD_VAR 0 8
106661: PPUSH
106662: CALL_OW 488
106666: NOT
106667: IFFALSE 106671
// continue ;
106669: GO 106599
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106671: LD_ADDR_VAR 0 9
106675: PUSH
106676: LD_VAR 0 12
106680: PUSH
106681: LD_INT 1
106683: ARRAY
106684: PPUSH
106685: LD_VAR 0 12
106689: PUSH
106690: LD_INT 2
106692: ARRAY
106693: PPUSH
106694: LD_VAR 0 7
106698: PPUSH
106699: LD_VAR 0 8
106703: PPUSH
106704: CALL_OW 298
106708: ST_TO_ADDR
// if tmp < distance then
106709: LD_VAR 0 9
106713: PUSH
106714: LD_VAR 0 10
106718: LESS
106719: IFFALSE 106741
// begin result := i ;
106721: LD_ADDR_VAR 0 5
106725: PUSH
106726: LD_VAR 0 6
106730: ST_TO_ADDR
// distance := tmp ;
106731: LD_ADDR_VAR 0 10
106735: PUSH
106736: LD_VAR 0 9
106740: ST_TO_ADDR
// end ; end ;
106741: GO 106599
106743: POP
106744: POP
// end ;
106745: LD_VAR 0 5
106749: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106750: LD_INT 0
106752: PPUSH
106753: PPUSH
// if not driver or not IsInUnit ( driver ) then
106754: LD_VAR 0 1
106758: NOT
106759: PUSH
106760: LD_VAR 0 1
106764: PPUSH
106765: CALL_OW 310
106769: NOT
106770: OR
106771: IFFALSE 106775
// exit ;
106773: GO 106865
// vehicle := IsInUnit ( driver ) ;
106775: LD_ADDR_VAR 0 3
106779: PUSH
106780: LD_VAR 0 1
106784: PPUSH
106785: CALL_OW 310
106789: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106790: LD_VAR 0 1
106794: PPUSH
106795: LD_STRING \
106797: PUSH
106798: LD_INT 0
106800: PUSH
106801: LD_INT 0
106803: PUSH
106804: LD_INT 0
106806: PUSH
106807: LD_INT 0
106809: PUSH
106810: LD_INT 0
106812: PUSH
106813: LD_INT 0
106815: PUSH
106816: EMPTY
106817: LIST
106818: LIST
106819: LIST
106820: LIST
106821: LIST
106822: LIST
106823: LIST
106824: PUSH
106825: LD_STRING E
106827: PUSH
106828: LD_INT 0
106830: PUSH
106831: LD_INT 0
106833: PUSH
106834: LD_VAR 0 3
106838: PUSH
106839: LD_INT 0
106841: PUSH
106842: LD_INT 0
106844: PUSH
106845: LD_INT 0
106847: PUSH
106848: EMPTY
106849: LIST
106850: LIST
106851: LIST
106852: LIST
106853: LIST
106854: LIST
106855: LIST
106856: PUSH
106857: EMPTY
106858: LIST
106859: LIST
106860: PPUSH
106861: CALL_OW 446
// end ;
106865: LD_VAR 0 2
106869: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106870: LD_INT 0
106872: PPUSH
106873: PPUSH
// if not driver or not IsInUnit ( driver ) then
106874: LD_VAR 0 1
106878: NOT
106879: PUSH
106880: LD_VAR 0 1
106884: PPUSH
106885: CALL_OW 310
106889: NOT
106890: OR
106891: IFFALSE 106895
// exit ;
106893: GO 106985
// vehicle := IsInUnit ( driver ) ;
106895: LD_ADDR_VAR 0 3
106899: PUSH
106900: LD_VAR 0 1
106904: PPUSH
106905: CALL_OW 310
106909: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106910: LD_VAR 0 1
106914: PPUSH
106915: LD_STRING \
106917: PUSH
106918: LD_INT 0
106920: PUSH
106921: LD_INT 0
106923: PUSH
106924: LD_INT 0
106926: PUSH
106927: LD_INT 0
106929: PUSH
106930: LD_INT 0
106932: PUSH
106933: LD_INT 0
106935: PUSH
106936: EMPTY
106937: LIST
106938: LIST
106939: LIST
106940: LIST
106941: LIST
106942: LIST
106943: LIST
106944: PUSH
106945: LD_STRING E
106947: PUSH
106948: LD_INT 0
106950: PUSH
106951: LD_INT 0
106953: PUSH
106954: LD_VAR 0 3
106958: PUSH
106959: LD_INT 0
106961: PUSH
106962: LD_INT 0
106964: PUSH
106965: LD_INT 0
106967: PUSH
106968: EMPTY
106969: LIST
106970: LIST
106971: LIST
106972: LIST
106973: LIST
106974: LIST
106975: LIST
106976: PUSH
106977: EMPTY
106978: LIST
106979: LIST
106980: PPUSH
106981: CALL_OW 447
// end ;
106985: LD_VAR 0 2
106989: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106990: LD_INT 0
106992: PPUSH
106993: PPUSH
106994: PPUSH
// tmp := [ ] ;
106995: LD_ADDR_VAR 0 5
106999: PUSH
107000: EMPTY
107001: ST_TO_ADDR
// for i in units do
107002: LD_ADDR_VAR 0 4
107006: PUSH
107007: LD_VAR 0 1
107011: PUSH
107012: FOR_IN
107013: IFFALSE 107051
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
107015: LD_ADDR_VAR 0 5
107019: PUSH
107020: LD_VAR 0 5
107024: PPUSH
107025: LD_VAR 0 5
107029: PUSH
107030: LD_INT 1
107032: PLUS
107033: PPUSH
107034: LD_VAR 0 4
107038: PPUSH
107039: CALL_OW 256
107043: PPUSH
107044: CALL_OW 2
107048: ST_TO_ADDR
107049: GO 107012
107051: POP
107052: POP
// if not tmp then
107053: LD_VAR 0 5
107057: NOT
107058: IFFALSE 107062
// exit ;
107060: GO 107110
// if asc then
107062: LD_VAR 0 2
107066: IFFALSE 107090
// result := SortListByListAsc ( units , tmp ) else
107068: LD_ADDR_VAR 0 3
107072: PUSH
107073: LD_VAR 0 1
107077: PPUSH
107078: LD_VAR 0 5
107082: PPUSH
107083: CALL_OW 76
107087: ST_TO_ADDR
107088: GO 107110
// result := SortListByListDesc ( units , tmp ) ;
107090: LD_ADDR_VAR 0 3
107094: PUSH
107095: LD_VAR 0 1
107099: PPUSH
107100: LD_VAR 0 5
107104: PPUSH
107105: CALL_OW 77
107109: ST_TO_ADDR
// end ;
107110: LD_VAR 0 3
107114: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107115: LD_INT 0
107117: PPUSH
107118: PPUSH
// task := GetTaskList ( mech ) ;
107119: LD_ADDR_VAR 0 4
107123: PUSH
107124: LD_VAR 0 1
107128: PPUSH
107129: CALL_OW 437
107133: ST_TO_ADDR
// if not task then
107134: LD_VAR 0 4
107138: NOT
107139: IFFALSE 107143
// exit ;
107141: GO 107185
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107143: LD_ADDR_VAR 0 3
107147: PUSH
107148: LD_VAR 0 4
107152: PUSH
107153: LD_INT 1
107155: ARRAY
107156: PUSH
107157: LD_INT 1
107159: ARRAY
107160: PUSH
107161: LD_STRING r
107163: EQUAL
107164: PUSH
107165: LD_VAR 0 4
107169: PUSH
107170: LD_INT 1
107172: ARRAY
107173: PUSH
107174: LD_INT 4
107176: ARRAY
107177: PUSH
107178: LD_VAR 0 2
107182: EQUAL
107183: AND
107184: ST_TO_ADDR
// end ;
107185: LD_VAR 0 3
107189: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107190: LD_INT 0
107192: PPUSH
// SetDir ( unit , d ) ;
107193: LD_VAR 0 1
107197: PPUSH
107198: LD_VAR 0 4
107202: PPUSH
107203: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
107207: LD_VAR 0 1
107211: PPUSH
107212: LD_VAR 0 2
107216: PPUSH
107217: LD_VAR 0 3
107221: PPUSH
107222: LD_VAR 0 5
107226: PPUSH
107227: CALL_OW 48
// end ;
107231: LD_VAR 0 6
107235: RET
// export function ToNaturalNumber ( number ) ; begin
107236: LD_INT 0
107238: PPUSH
// result := number div 1 ;
107239: LD_ADDR_VAR 0 2
107243: PUSH
107244: LD_VAR 0 1
107248: PUSH
107249: LD_INT 1
107251: DIV
107252: ST_TO_ADDR
// if number < 0 then
107253: LD_VAR 0 1
107257: PUSH
107258: LD_INT 0
107260: LESS
107261: IFFALSE 107271
// result := 0 ;
107263: LD_ADDR_VAR 0 2
107267: PUSH
107268: LD_INT 0
107270: ST_TO_ADDR
// end ;
107271: LD_VAR 0 2
107275: RET
// export function SortByClass ( units , class ) ; var un ; begin
107276: LD_INT 0
107278: PPUSH
107279: PPUSH
// if not units or not class then
107280: LD_VAR 0 1
107284: NOT
107285: PUSH
107286: LD_VAR 0 2
107290: NOT
107291: OR
107292: IFFALSE 107296
// exit ;
107294: GO 107391
// result := [ ] ;
107296: LD_ADDR_VAR 0 3
107300: PUSH
107301: EMPTY
107302: ST_TO_ADDR
// for un in units do
107303: LD_ADDR_VAR 0 4
107307: PUSH
107308: LD_VAR 0 1
107312: PUSH
107313: FOR_IN
107314: IFFALSE 107389
// if GetClass ( un ) = class then
107316: LD_VAR 0 4
107320: PPUSH
107321: CALL_OW 257
107325: PUSH
107326: LD_VAR 0 2
107330: EQUAL
107331: IFFALSE 107358
// result := Insert ( result , 1 , un ) else
107333: LD_ADDR_VAR 0 3
107337: PUSH
107338: LD_VAR 0 3
107342: PPUSH
107343: LD_INT 1
107345: PPUSH
107346: LD_VAR 0 4
107350: PPUSH
107351: CALL_OW 2
107355: ST_TO_ADDR
107356: GO 107387
// result := Replace ( result , result + 1 , un ) ;
107358: LD_ADDR_VAR 0 3
107362: PUSH
107363: LD_VAR 0 3
107367: PPUSH
107368: LD_VAR 0 3
107372: PUSH
107373: LD_INT 1
107375: PLUS
107376: PPUSH
107377: LD_VAR 0 4
107381: PPUSH
107382: CALL_OW 1
107386: ST_TO_ADDR
107387: GO 107313
107389: POP
107390: POP
// end ;
107391: LD_VAR 0 3
107395: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
107396: LD_INT 0
107398: PPUSH
107399: PPUSH
107400: PPUSH
107401: PPUSH
107402: PPUSH
107403: PPUSH
107404: PPUSH
// result := [ ] ;
107405: LD_ADDR_VAR 0 4
107409: PUSH
107410: EMPTY
107411: ST_TO_ADDR
// if x - r < 0 then
107412: LD_VAR 0 1
107416: PUSH
107417: LD_VAR 0 3
107421: MINUS
107422: PUSH
107423: LD_INT 0
107425: LESS
107426: IFFALSE 107438
// min_x := 0 else
107428: LD_ADDR_VAR 0 8
107432: PUSH
107433: LD_INT 0
107435: ST_TO_ADDR
107436: GO 107454
// min_x := x - r ;
107438: LD_ADDR_VAR 0 8
107442: PUSH
107443: LD_VAR 0 1
107447: PUSH
107448: LD_VAR 0 3
107452: MINUS
107453: ST_TO_ADDR
// if y - r < 0 then
107454: LD_VAR 0 2
107458: PUSH
107459: LD_VAR 0 3
107463: MINUS
107464: PUSH
107465: LD_INT 0
107467: LESS
107468: IFFALSE 107480
// min_y := 0 else
107470: LD_ADDR_VAR 0 7
107474: PUSH
107475: LD_INT 0
107477: ST_TO_ADDR
107478: GO 107496
// min_y := y - r ;
107480: LD_ADDR_VAR 0 7
107484: PUSH
107485: LD_VAR 0 2
107489: PUSH
107490: LD_VAR 0 3
107494: MINUS
107495: ST_TO_ADDR
// max_x := x + r ;
107496: LD_ADDR_VAR 0 9
107500: PUSH
107501: LD_VAR 0 1
107505: PUSH
107506: LD_VAR 0 3
107510: PLUS
107511: ST_TO_ADDR
// max_y := y + r ;
107512: LD_ADDR_VAR 0 10
107516: PUSH
107517: LD_VAR 0 2
107521: PUSH
107522: LD_VAR 0 3
107526: PLUS
107527: ST_TO_ADDR
// for _x = min_x to max_x do
107528: LD_ADDR_VAR 0 5
107532: PUSH
107533: DOUBLE
107534: LD_VAR 0 8
107538: DEC
107539: ST_TO_ADDR
107540: LD_VAR 0 9
107544: PUSH
107545: FOR_TO
107546: IFFALSE 107647
// for _y = min_y to max_y do
107548: LD_ADDR_VAR 0 6
107552: PUSH
107553: DOUBLE
107554: LD_VAR 0 7
107558: DEC
107559: ST_TO_ADDR
107560: LD_VAR 0 10
107564: PUSH
107565: FOR_TO
107566: IFFALSE 107643
// begin if not ValidHex ( _x , _y ) then
107568: LD_VAR 0 5
107572: PPUSH
107573: LD_VAR 0 6
107577: PPUSH
107578: CALL_OW 488
107582: NOT
107583: IFFALSE 107587
// continue ;
107585: GO 107565
// if GetResourceTypeXY ( _x , _y ) then
107587: LD_VAR 0 5
107591: PPUSH
107592: LD_VAR 0 6
107596: PPUSH
107597: CALL_OW 283
107601: IFFALSE 107641
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107603: LD_ADDR_VAR 0 4
107607: PUSH
107608: LD_VAR 0 4
107612: PPUSH
107613: LD_VAR 0 4
107617: PUSH
107618: LD_INT 1
107620: PLUS
107621: PPUSH
107622: LD_VAR 0 5
107626: PUSH
107627: LD_VAR 0 6
107631: PUSH
107632: EMPTY
107633: LIST
107634: LIST
107635: PPUSH
107636: CALL_OW 1
107640: ST_TO_ADDR
// end ;
107641: GO 107565
107643: POP
107644: POP
107645: GO 107545
107647: POP
107648: POP
// end ;
107649: LD_VAR 0 4
107653: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107654: LD_INT 0
107656: PPUSH
107657: PPUSH
107658: PPUSH
107659: PPUSH
107660: PPUSH
107661: PPUSH
107662: PPUSH
107663: PPUSH
// if not units then
107664: LD_VAR 0 1
107668: NOT
107669: IFFALSE 107673
// exit ;
107671: GO 108197
// result := UnitFilter ( units , [ f_ok ] ) ;
107673: LD_ADDR_VAR 0 3
107677: PUSH
107678: LD_VAR 0 1
107682: PPUSH
107683: LD_INT 50
107685: PUSH
107686: EMPTY
107687: LIST
107688: PPUSH
107689: CALL_OW 72
107693: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107694: LD_ADDR_VAR 0 8
107698: PUSH
107699: LD_VAR 0 1
107703: PUSH
107704: LD_INT 1
107706: ARRAY
107707: PPUSH
107708: CALL_OW 255
107712: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107713: LD_ADDR_VAR 0 10
107717: PUSH
107718: LD_INT 29
107720: PUSH
107721: LD_INT 91
107723: PUSH
107724: LD_INT 49
107726: PUSH
107727: EMPTY
107728: LIST
107729: LIST
107730: LIST
107731: ST_TO_ADDR
// if not result then
107732: LD_VAR 0 3
107736: NOT
107737: IFFALSE 107741
// exit ;
107739: GO 108197
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107741: LD_ADDR_VAR 0 5
107745: PUSH
107746: LD_INT 81
107748: PUSH
107749: LD_VAR 0 8
107753: PUSH
107754: EMPTY
107755: LIST
107756: LIST
107757: PPUSH
107758: CALL_OW 69
107762: ST_TO_ADDR
// for i in result do
107763: LD_ADDR_VAR 0 4
107767: PUSH
107768: LD_VAR 0 3
107772: PUSH
107773: FOR_IN
107774: IFFALSE 108195
// begin tag := GetTag ( i ) + 1 ;
107776: LD_ADDR_VAR 0 9
107780: PUSH
107781: LD_VAR 0 4
107785: PPUSH
107786: CALL_OW 110
107790: PUSH
107791: LD_INT 1
107793: PLUS
107794: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107795: LD_ADDR_VAR 0 7
107799: PUSH
107800: LD_VAR 0 4
107804: PPUSH
107805: CALL_OW 250
107809: PPUSH
107810: LD_VAR 0 4
107814: PPUSH
107815: CALL_OW 251
107819: PPUSH
107820: LD_INT 6
107822: PPUSH
107823: CALL 107396 0 3
107827: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107828: LD_VAR 0 4
107832: PPUSH
107833: CALL_OW 247
107837: PUSH
107838: LD_INT 2
107840: EQUAL
107841: PUSH
107842: LD_VAR 0 7
107846: AND
107847: PUSH
107848: LD_VAR 0 4
107852: PPUSH
107853: CALL_OW 264
107857: PUSH
107858: LD_VAR 0 10
107862: IN
107863: NOT
107864: AND
107865: IFFALSE 107904
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107867: LD_VAR 0 4
107871: PPUSH
107872: LD_VAR 0 7
107876: PUSH
107877: LD_INT 1
107879: ARRAY
107880: PUSH
107881: LD_INT 1
107883: ARRAY
107884: PPUSH
107885: LD_VAR 0 7
107889: PUSH
107890: LD_INT 1
107892: ARRAY
107893: PUSH
107894: LD_INT 2
107896: ARRAY
107897: PPUSH
107898: CALL_OW 116
107902: GO 108193
// if path > tag then
107904: LD_VAR 0 2
107908: PUSH
107909: LD_VAR 0 9
107913: GREATER
107914: IFFALSE 108122
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107916: LD_ADDR_VAR 0 6
107920: PUSH
107921: LD_VAR 0 5
107925: PPUSH
107926: LD_INT 91
107928: PUSH
107929: LD_VAR 0 4
107933: PUSH
107934: LD_INT 8
107936: PUSH
107937: EMPTY
107938: LIST
107939: LIST
107940: LIST
107941: PPUSH
107942: CALL_OW 72
107946: ST_TO_ADDR
// if nearEnemy then
107947: LD_VAR 0 6
107951: IFFALSE 108020
// begin if GetWeapon ( i ) = ru_time_lapser then
107953: LD_VAR 0 4
107957: PPUSH
107958: CALL_OW 264
107962: PUSH
107963: LD_INT 49
107965: EQUAL
107966: IFFALSE 107994
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107968: LD_VAR 0 4
107972: PPUSH
107973: LD_VAR 0 6
107977: PPUSH
107978: LD_VAR 0 4
107982: PPUSH
107983: CALL_OW 74
107987: PPUSH
107988: CALL_OW 112
107992: GO 108018
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107994: LD_VAR 0 4
107998: PPUSH
107999: LD_VAR 0 6
108003: PPUSH
108004: LD_VAR 0 4
108008: PPUSH
108009: CALL_OW 74
108013: PPUSH
108014: CALL_OW 115
// end else
108018: GO 108120
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
108020: LD_VAR 0 4
108024: PPUSH
108025: LD_VAR 0 2
108029: PUSH
108030: LD_VAR 0 9
108034: ARRAY
108035: PUSH
108036: LD_INT 1
108038: ARRAY
108039: PPUSH
108040: LD_VAR 0 2
108044: PUSH
108045: LD_VAR 0 9
108049: ARRAY
108050: PUSH
108051: LD_INT 2
108053: ARRAY
108054: PPUSH
108055: CALL_OW 297
108059: PUSH
108060: LD_INT 6
108062: GREATER
108063: IFFALSE 108106
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
108065: LD_VAR 0 4
108069: PPUSH
108070: LD_VAR 0 2
108074: PUSH
108075: LD_VAR 0 9
108079: ARRAY
108080: PUSH
108081: LD_INT 1
108083: ARRAY
108084: PPUSH
108085: LD_VAR 0 2
108089: PUSH
108090: LD_VAR 0 9
108094: ARRAY
108095: PUSH
108096: LD_INT 2
108098: ARRAY
108099: PPUSH
108100: CALL_OW 114
108104: GO 108120
// SetTag ( i , tag ) ;
108106: LD_VAR 0 4
108110: PPUSH
108111: LD_VAR 0 9
108115: PPUSH
108116: CALL_OW 109
// end else
108120: GO 108193
// if enemy then
108122: LD_VAR 0 5
108126: IFFALSE 108193
// begin if GetWeapon ( i ) = ru_time_lapser then
108128: LD_VAR 0 4
108132: PPUSH
108133: CALL_OW 264
108137: PUSH
108138: LD_INT 49
108140: EQUAL
108141: IFFALSE 108169
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108143: LD_VAR 0 4
108147: PPUSH
108148: LD_VAR 0 5
108152: PPUSH
108153: LD_VAR 0 4
108157: PPUSH
108158: CALL_OW 74
108162: PPUSH
108163: CALL_OW 112
108167: GO 108193
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108169: LD_VAR 0 4
108173: PPUSH
108174: LD_VAR 0 5
108178: PPUSH
108179: LD_VAR 0 4
108183: PPUSH
108184: CALL_OW 74
108188: PPUSH
108189: CALL_OW 115
// end ; end ;
108193: GO 107773
108195: POP
108196: POP
// end ;
108197: LD_VAR 0 3
108201: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
108202: LD_INT 0
108204: PPUSH
108205: PPUSH
108206: PPUSH
// if not unit or IsInUnit ( unit ) then
108207: LD_VAR 0 1
108211: NOT
108212: PUSH
108213: LD_VAR 0 1
108217: PPUSH
108218: CALL_OW 310
108222: OR
108223: IFFALSE 108227
// exit ;
108225: GO 108318
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
108227: LD_ADDR_VAR 0 4
108231: PUSH
108232: LD_VAR 0 1
108236: PPUSH
108237: CALL_OW 250
108241: PPUSH
108242: LD_VAR 0 2
108246: PPUSH
108247: LD_INT 1
108249: PPUSH
108250: CALL_OW 272
108254: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
108255: LD_ADDR_VAR 0 5
108259: PUSH
108260: LD_VAR 0 1
108264: PPUSH
108265: CALL_OW 251
108269: PPUSH
108270: LD_VAR 0 2
108274: PPUSH
108275: LD_INT 1
108277: PPUSH
108278: CALL_OW 273
108282: ST_TO_ADDR
// if ValidHex ( x , y ) then
108283: LD_VAR 0 4
108287: PPUSH
108288: LD_VAR 0 5
108292: PPUSH
108293: CALL_OW 488
108297: IFFALSE 108318
// ComTurnXY ( unit , x , y ) ;
108299: LD_VAR 0 1
108303: PPUSH
108304: LD_VAR 0 4
108308: PPUSH
108309: LD_VAR 0 5
108313: PPUSH
108314: CALL_OW 118
// end ;
108318: LD_VAR 0 3
108322: RET
// export function SeeUnits ( side , units ) ; var i ; begin
108323: LD_INT 0
108325: PPUSH
108326: PPUSH
// result := false ;
108327: LD_ADDR_VAR 0 3
108331: PUSH
108332: LD_INT 0
108334: ST_TO_ADDR
// if not units then
108335: LD_VAR 0 2
108339: NOT
108340: IFFALSE 108344
// exit ;
108342: GO 108389
// for i in units do
108344: LD_ADDR_VAR 0 4
108348: PUSH
108349: LD_VAR 0 2
108353: PUSH
108354: FOR_IN
108355: IFFALSE 108387
// if See ( side , i ) then
108357: LD_VAR 0 1
108361: PPUSH
108362: LD_VAR 0 4
108366: PPUSH
108367: CALL_OW 292
108371: IFFALSE 108385
// begin result := true ;
108373: LD_ADDR_VAR 0 3
108377: PUSH
108378: LD_INT 1
108380: ST_TO_ADDR
// exit ;
108381: POP
108382: POP
108383: GO 108389
// end ;
108385: GO 108354
108387: POP
108388: POP
// end ;
108389: LD_VAR 0 3
108393: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
108394: LD_INT 0
108396: PPUSH
108397: PPUSH
108398: PPUSH
108399: PPUSH
// if not unit or not points then
108400: LD_VAR 0 1
108404: NOT
108405: PUSH
108406: LD_VAR 0 2
108410: NOT
108411: OR
108412: IFFALSE 108416
// exit ;
108414: GO 108506
// dist := 99999 ;
108416: LD_ADDR_VAR 0 5
108420: PUSH
108421: LD_INT 99999
108423: ST_TO_ADDR
// for i in points do
108424: LD_ADDR_VAR 0 4
108428: PUSH
108429: LD_VAR 0 2
108433: PUSH
108434: FOR_IN
108435: IFFALSE 108504
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108437: LD_ADDR_VAR 0 6
108441: PUSH
108442: LD_VAR 0 1
108446: PPUSH
108447: LD_VAR 0 4
108451: PUSH
108452: LD_INT 1
108454: ARRAY
108455: PPUSH
108456: LD_VAR 0 4
108460: PUSH
108461: LD_INT 2
108463: ARRAY
108464: PPUSH
108465: CALL_OW 297
108469: ST_TO_ADDR
// if tmpDist < dist then
108470: LD_VAR 0 6
108474: PUSH
108475: LD_VAR 0 5
108479: LESS
108480: IFFALSE 108502
// begin result := i ;
108482: LD_ADDR_VAR 0 3
108486: PUSH
108487: LD_VAR 0 4
108491: ST_TO_ADDR
// dist := tmpDist ;
108492: LD_ADDR_VAR 0 5
108496: PUSH
108497: LD_VAR 0 6
108501: ST_TO_ADDR
// end ; end ;
108502: GO 108434
108504: POP
108505: POP
// end ;
108506: LD_VAR 0 3
108510: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108511: LD_INT 0
108513: PPUSH
// uc_side := side ;
108514: LD_ADDR_OWVAR 20
108518: PUSH
108519: LD_VAR 0 1
108523: ST_TO_ADDR
// uc_nation := 3 ;
108524: LD_ADDR_OWVAR 21
108528: PUSH
108529: LD_INT 3
108531: ST_TO_ADDR
// vc_chassis := 25 ;
108532: LD_ADDR_OWVAR 37
108536: PUSH
108537: LD_INT 25
108539: ST_TO_ADDR
// vc_engine := engine_siberite ;
108540: LD_ADDR_OWVAR 39
108544: PUSH
108545: LD_INT 3
108547: ST_TO_ADDR
// vc_control := control_computer ;
108548: LD_ADDR_OWVAR 38
108552: PUSH
108553: LD_INT 3
108555: ST_TO_ADDR
// vc_weapon := 59 ;
108556: LD_ADDR_OWVAR 40
108560: PUSH
108561: LD_INT 59
108563: ST_TO_ADDR
// result := CreateVehicle ;
108564: LD_ADDR_VAR 0 5
108568: PUSH
108569: CALL_OW 45
108573: ST_TO_ADDR
// SetDir ( result , d ) ;
108574: LD_VAR 0 5
108578: PPUSH
108579: LD_VAR 0 4
108583: PPUSH
108584: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108588: LD_VAR 0 5
108592: PPUSH
108593: LD_VAR 0 2
108597: PPUSH
108598: LD_VAR 0 3
108602: PPUSH
108603: LD_INT 0
108605: PPUSH
108606: CALL_OW 48
// end ;
108610: LD_VAR 0 5
108614: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108615: LD_INT 0
108617: PPUSH
108618: PPUSH
108619: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108620: LD_ADDR_VAR 0 2
108624: PUSH
108625: LD_INT 0
108627: PUSH
108628: LD_INT 0
108630: PUSH
108631: LD_INT 0
108633: PUSH
108634: LD_INT 0
108636: PUSH
108637: EMPTY
108638: LIST
108639: LIST
108640: LIST
108641: LIST
108642: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108643: LD_VAR 0 1
108647: NOT
108648: PUSH
108649: LD_VAR 0 1
108653: PPUSH
108654: CALL_OW 264
108658: PUSH
108659: LD_INT 12
108661: PUSH
108662: LD_INT 51
108664: PUSH
108665: LD_INT 32
108667: PUSH
108668: LD_INT 89
108670: PUSH
108671: EMPTY
108672: LIST
108673: LIST
108674: LIST
108675: LIST
108676: IN
108677: NOT
108678: OR
108679: IFFALSE 108683
// exit ;
108681: GO 108781
// for i := 1 to 3 do
108683: LD_ADDR_VAR 0 3
108687: PUSH
108688: DOUBLE
108689: LD_INT 1
108691: DEC
108692: ST_TO_ADDR
108693: LD_INT 3
108695: PUSH
108696: FOR_TO
108697: IFFALSE 108779
// begin tmp := GetCargo ( cargo , i ) ;
108699: LD_ADDR_VAR 0 4
108703: PUSH
108704: LD_VAR 0 1
108708: PPUSH
108709: LD_VAR 0 3
108713: PPUSH
108714: CALL_OW 289
108718: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108719: LD_ADDR_VAR 0 2
108723: PUSH
108724: LD_VAR 0 2
108728: PPUSH
108729: LD_VAR 0 3
108733: PPUSH
108734: LD_VAR 0 4
108738: PPUSH
108739: CALL_OW 1
108743: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108744: LD_ADDR_VAR 0 2
108748: PUSH
108749: LD_VAR 0 2
108753: PPUSH
108754: LD_INT 4
108756: PPUSH
108757: LD_VAR 0 2
108761: PUSH
108762: LD_INT 4
108764: ARRAY
108765: PUSH
108766: LD_VAR 0 4
108770: PLUS
108771: PPUSH
108772: CALL_OW 1
108776: ST_TO_ADDR
// end ;
108777: GO 108696
108779: POP
108780: POP
// end ;
108781: LD_VAR 0 2
108785: RET
// export function Length ( array ) ; begin
108786: LD_INT 0
108788: PPUSH
// result := array + 0 ;
108789: LD_ADDR_VAR 0 2
108793: PUSH
108794: LD_VAR 0 1
108798: PUSH
108799: LD_INT 0
108801: PLUS
108802: ST_TO_ADDR
// end ;
108803: LD_VAR 0 2
108807: RET
// export function PrepareArray ( array ) ; begin
108808: LD_INT 0
108810: PPUSH
// result := array diff 0 ;
108811: LD_ADDR_VAR 0 2
108815: PUSH
108816: LD_VAR 0 1
108820: PUSH
108821: LD_INT 0
108823: DIFF
108824: ST_TO_ADDR
// if not result [ 1 ] then
108825: LD_VAR 0 2
108829: PUSH
108830: LD_INT 1
108832: ARRAY
108833: NOT
108834: IFFALSE 108854
// result := Delete ( result , 1 ) ;
108836: LD_ADDR_VAR 0 2
108840: PUSH
108841: LD_VAR 0 2
108845: PPUSH
108846: LD_INT 1
108848: PPUSH
108849: CALL_OW 3
108853: ST_TO_ADDR
// end ;
108854: LD_VAR 0 2
108858: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
108859: LD_INT 0
108861: PPUSH
108862: PPUSH
108863: PPUSH
108864: PPUSH
// sibRocketRange := 25 ;
108865: LD_ADDR_VAR 0 6
108869: PUSH
108870: LD_INT 25
108872: ST_TO_ADDR
// result := false ;
108873: LD_ADDR_VAR 0 4
108877: PUSH
108878: LD_INT 0
108880: ST_TO_ADDR
// for i := 0 to 5 do
108881: LD_ADDR_VAR 0 5
108885: PUSH
108886: DOUBLE
108887: LD_INT 0
108889: DEC
108890: ST_TO_ADDR
108891: LD_INT 5
108893: PUSH
108894: FOR_TO
108895: IFFALSE 108962
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
108897: LD_VAR 0 1
108901: PPUSH
108902: LD_VAR 0 5
108906: PPUSH
108907: LD_VAR 0 6
108911: PPUSH
108912: CALL_OW 272
108916: PPUSH
108917: LD_VAR 0 2
108921: PPUSH
108922: LD_VAR 0 5
108926: PPUSH
108927: LD_VAR 0 6
108931: PPUSH
108932: CALL_OW 273
108936: PPUSH
108937: LD_VAR 0 3
108941: PPUSH
108942: CALL_OW 309
108946: IFFALSE 108960
// begin result := true ;
108948: LD_ADDR_VAR 0 4
108952: PUSH
108953: LD_INT 1
108955: ST_TO_ADDR
// exit ;
108956: POP
108957: POP
108958: GO 108964
// end ;
108960: GO 108894
108962: POP
108963: POP
// end ;
108964: LD_VAR 0 4
108968: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
108969: LD_INT 0
108971: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
108972: LD_VAR 0 1
108976: PPUSH
108977: LD_VAR 0 2
108981: PPUSH
108982: LD_INT 0
108984: PPUSH
108985: LD_INT 0
108987: PPUSH
108988: LD_INT 1
108990: PPUSH
108991: LD_INT 0
108993: PPUSH
108994: CALL_OW 587
// end ; end_of_file end_of_file
108998: LD_VAR 0 3
109002: RET
// export globalGameSaveCounter ; every 0 0$1 do
109003: GO 109005
109005: DISABLE
// begin enable ;
109006: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
109007: LD_STRING updateTimer(
109009: PUSH
109010: LD_OWVAR 1
109014: STR
109015: PUSH
109016: LD_STRING );
109018: STR
109019: PPUSH
109020: CALL_OW 559
// end ;
109024: END
// every 0 0$1 do
109025: GO 109027
109027: DISABLE
// begin globalGameSaveCounter := 0 ;
109028: LD_ADDR_EXP 145
109032: PUSH
109033: LD_INT 0
109035: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
109036: LD_STRING setGameSaveCounter(0)
109038: PPUSH
109039: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
109043: LD_STRING initStreamRollete();
109045: PPUSH
109046: CALL_OW 559
// InitStreamMode ;
109050: CALL 110376 0 0
// DefineStreamItems ( false ) ;
109054: LD_INT 0
109056: PPUSH
109057: CALL 110840 0 1
// end ;
109061: END
// export function SOS_MapStart ( ) ; begin
109062: LD_INT 0
109064: PPUSH
// if streamModeActive then
109065: LD_EXP 146
109069: IFFALSE 109078
// DefineStreamItems ( true ) ;
109071: LD_INT 1
109073: PPUSH
109074: CALL 110840 0 1
// UpdateLuaVariables ( ) ;
109078: CALL 109095 0 0
// UpdateFactoryWaypoints ( ) ;
109082: CALL 123701 0 0
// UpdateWarehouseGatheringPoints ( ) ;
109086: CALL 123958 0 0
// end ;
109090: LD_VAR 0 1
109094: RET
// function UpdateLuaVariables ( ) ; begin
109095: LD_INT 0
109097: PPUSH
// if globalGameSaveCounter then
109098: LD_EXP 145
109102: IFFALSE 109136
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
109104: LD_ADDR_EXP 145
109108: PUSH
109109: LD_EXP 145
109113: PPUSH
109114: CALL 106411 0 1
109118: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
109119: LD_STRING setGameSaveCounter(
109121: PUSH
109122: LD_EXP 145
109126: STR
109127: PUSH
109128: LD_STRING )
109130: STR
109131: PPUSH
109132: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
109136: LD_STRING setGameDifficulty(
109138: PUSH
109139: LD_OWVAR 67
109143: STR
109144: PUSH
109145: LD_STRING )
109147: STR
109148: PPUSH
109149: CALL_OW 559
// end ;
109153: LD_VAR 0 1
109157: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
109158: LD_INT 0
109160: PPUSH
// if p2 = stream_mode then
109161: LD_VAR 0 2
109165: PUSH
109166: LD_INT 100
109168: EQUAL
109169: IFFALSE 110172
// begin if not StreamModeActive then
109171: LD_EXP 146
109175: NOT
109176: IFFALSE 109186
// StreamModeActive := true ;
109178: LD_ADDR_EXP 146
109182: PUSH
109183: LD_INT 1
109185: ST_TO_ADDR
// if p3 = 0 then
109186: LD_VAR 0 3
109190: PUSH
109191: LD_INT 0
109193: EQUAL
109194: IFFALSE 109200
// InitStreamMode ;
109196: CALL 110376 0 0
// if p3 = 1 then
109200: LD_VAR 0 3
109204: PUSH
109205: LD_INT 1
109207: EQUAL
109208: IFFALSE 109218
// sRocket := true ;
109210: LD_ADDR_EXP 151
109214: PUSH
109215: LD_INT 1
109217: ST_TO_ADDR
// if p3 = 2 then
109218: LD_VAR 0 3
109222: PUSH
109223: LD_INT 2
109225: EQUAL
109226: IFFALSE 109236
// sSpeed := true ;
109228: LD_ADDR_EXP 150
109232: PUSH
109233: LD_INT 1
109235: ST_TO_ADDR
// if p3 = 3 then
109236: LD_VAR 0 3
109240: PUSH
109241: LD_INT 3
109243: EQUAL
109244: IFFALSE 109254
// sEngine := true ;
109246: LD_ADDR_EXP 152
109250: PUSH
109251: LD_INT 1
109253: ST_TO_ADDR
// if p3 = 4 then
109254: LD_VAR 0 3
109258: PUSH
109259: LD_INT 4
109261: EQUAL
109262: IFFALSE 109272
// sSpec := true ;
109264: LD_ADDR_EXP 149
109268: PUSH
109269: LD_INT 1
109271: ST_TO_ADDR
// if p3 = 5 then
109272: LD_VAR 0 3
109276: PUSH
109277: LD_INT 5
109279: EQUAL
109280: IFFALSE 109290
// sLevel := true ;
109282: LD_ADDR_EXP 153
109286: PUSH
109287: LD_INT 1
109289: ST_TO_ADDR
// if p3 = 6 then
109290: LD_VAR 0 3
109294: PUSH
109295: LD_INT 6
109297: EQUAL
109298: IFFALSE 109308
// sArmoury := true ;
109300: LD_ADDR_EXP 154
109304: PUSH
109305: LD_INT 1
109307: ST_TO_ADDR
// if p3 = 7 then
109308: LD_VAR 0 3
109312: PUSH
109313: LD_INT 7
109315: EQUAL
109316: IFFALSE 109326
// sRadar := true ;
109318: LD_ADDR_EXP 155
109322: PUSH
109323: LD_INT 1
109325: ST_TO_ADDR
// if p3 = 8 then
109326: LD_VAR 0 3
109330: PUSH
109331: LD_INT 8
109333: EQUAL
109334: IFFALSE 109344
// sBunker := true ;
109336: LD_ADDR_EXP 156
109340: PUSH
109341: LD_INT 1
109343: ST_TO_ADDR
// if p3 = 9 then
109344: LD_VAR 0 3
109348: PUSH
109349: LD_INT 9
109351: EQUAL
109352: IFFALSE 109362
// sHack := true ;
109354: LD_ADDR_EXP 157
109358: PUSH
109359: LD_INT 1
109361: ST_TO_ADDR
// if p3 = 10 then
109362: LD_VAR 0 3
109366: PUSH
109367: LD_INT 10
109369: EQUAL
109370: IFFALSE 109380
// sFire := true ;
109372: LD_ADDR_EXP 158
109376: PUSH
109377: LD_INT 1
109379: ST_TO_ADDR
// if p3 = 11 then
109380: LD_VAR 0 3
109384: PUSH
109385: LD_INT 11
109387: EQUAL
109388: IFFALSE 109398
// sRefresh := true ;
109390: LD_ADDR_EXP 159
109394: PUSH
109395: LD_INT 1
109397: ST_TO_ADDR
// if p3 = 12 then
109398: LD_VAR 0 3
109402: PUSH
109403: LD_INT 12
109405: EQUAL
109406: IFFALSE 109416
// sExp := true ;
109408: LD_ADDR_EXP 160
109412: PUSH
109413: LD_INT 1
109415: ST_TO_ADDR
// if p3 = 13 then
109416: LD_VAR 0 3
109420: PUSH
109421: LD_INT 13
109423: EQUAL
109424: IFFALSE 109434
// sDepot := true ;
109426: LD_ADDR_EXP 161
109430: PUSH
109431: LD_INT 1
109433: ST_TO_ADDR
// if p3 = 14 then
109434: LD_VAR 0 3
109438: PUSH
109439: LD_INT 14
109441: EQUAL
109442: IFFALSE 109452
// sFlag := true ;
109444: LD_ADDR_EXP 162
109448: PUSH
109449: LD_INT 1
109451: ST_TO_ADDR
// if p3 = 15 then
109452: LD_VAR 0 3
109456: PUSH
109457: LD_INT 15
109459: EQUAL
109460: IFFALSE 109470
// sKamikadze := true ;
109462: LD_ADDR_EXP 170
109466: PUSH
109467: LD_INT 1
109469: ST_TO_ADDR
// if p3 = 16 then
109470: LD_VAR 0 3
109474: PUSH
109475: LD_INT 16
109477: EQUAL
109478: IFFALSE 109488
// sTroll := true ;
109480: LD_ADDR_EXP 171
109484: PUSH
109485: LD_INT 1
109487: ST_TO_ADDR
// if p3 = 17 then
109488: LD_VAR 0 3
109492: PUSH
109493: LD_INT 17
109495: EQUAL
109496: IFFALSE 109506
// sSlow := true ;
109498: LD_ADDR_EXP 172
109502: PUSH
109503: LD_INT 1
109505: ST_TO_ADDR
// if p3 = 18 then
109506: LD_VAR 0 3
109510: PUSH
109511: LD_INT 18
109513: EQUAL
109514: IFFALSE 109524
// sLack := true ;
109516: LD_ADDR_EXP 173
109520: PUSH
109521: LD_INT 1
109523: ST_TO_ADDR
// if p3 = 19 then
109524: LD_VAR 0 3
109528: PUSH
109529: LD_INT 19
109531: EQUAL
109532: IFFALSE 109542
// sTank := true ;
109534: LD_ADDR_EXP 175
109538: PUSH
109539: LD_INT 1
109541: ST_TO_ADDR
// if p3 = 20 then
109542: LD_VAR 0 3
109546: PUSH
109547: LD_INT 20
109549: EQUAL
109550: IFFALSE 109560
// sRemote := true ;
109552: LD_ADDR_EXP 176
109556: PUSH
109557: LD_INT 1
109559: ST_TO_ADDR
// if p3 = 21 then
109560: LD_VAR 0 3
109564: PUSH
109565: LD_INT 21
109567: EQUAL
109568: IFFALSE 109578
// sPowell := true ;
109570: LD_ADDR_EXP 177
109574: PUSH
109575: LD_INT 1
109577: ST_TO_ADDR
// if p3 = 22 then
109578: LD_VAR 0 3
109582: PUSH
109583: LD_INT 22
109585: EQUAL
109586: IFFALSE 109596
// sTeleport := true ;
109588: LD_ADDR_EXP 180
109592: PUSH
109593: LD_INT 1
109595: ST_TO_ADDR
// if p3 = 23 then
109596: LD_VAR 0 3
109600: PUSH
109601: LD_INT 23
109603: EQUAL
109604: IFFALSE 109614
// sOilTower := true ;
109606: LD_ADDR_EXP 182
109610: PUSH
109611: LD_INT 1
109613: ST_TO_ADDR
// if p3 = 24 then
109614: LD_VAR 0 3
109618: PUSH
109619: LD_INT 24
109621: EQUAL
109622: IFFALSE 109632
// sShovel := true ;
109624: LD_ADDR_EXP 183
109628: PUSH
109629: LD_INT 1
109631: ST_TO_ADDR
// if p3 = 25 then
109632: LD_VAR 0 3
109636: PUSH
109637: LD_INT 25
109639: EQUAL
109640: IFFALSE 109650
// sSheik := true ;
109642: LD_ADDR_EXP 184
109646: PUSH
109647: LD_INT 1
109649: ST_TO_ADDR
// if p3 = 26 then
109650: LD_VAR 0 3
109654: PUSH
109655: LD_INT 26
109657: EQUAL
109658: IFFALSE 109668
// sEarthquake := true ;
109660: LD_ADDR_EXP 186
109664: PUSH
109665: LD_INT 1
109667: ST_TO_ADDR
// if p3 = 27 then
109668: LD_VAR 0 3
109672: PUSH
109673: LD_INT 27
109675: EQUAL
109676: IFFALSE 109686
// sAI := true ;
109678: LD_ADDR_EXP 187
109682: PUSH
109683: LD_INT 1
109685: ST_TO_ADDR
// if p3 = 28 then
109686: LD_VAR 0 3
109690: PUSH
109691: LD_INT 28
109693: EQUAL
109694: IFFALSE 109704
// sCargo := true ;
109696: LD_ADDR_EXP 190
109700: PUSH
109701: LD_INT 1
109703: ST_TO_ADDR
// if p3 = 29 then
109704: LD_VAR 0 3
109708: PUSH
109709: LD_INT 29
109711: EQUAL
109712: IFFALSE 109722
// sDLaser := true ;
109714: LD_ADDR_EXP 191
109718: PUSH
109719: LD_INT 1
109721: ST_TO_ADDR
// if p3 = 30 then
109722: LD_VAR 0 3
109726: PUSH
109727: LD_INT 30
109729: EQUAL
109730: IFFALSE 109740
// sExchange := true ;
109732: LD_ADDR_EXP 192
109736: PUSH
109737: LD_INT 1
109739: ST_TO_ADDR
// if p3 = 31 then
109740: LD_VAR 0 3
109744: PUSH
109745: LD_INT 31
109747: EQUAL
109748: IFFALSE 109758
// sFac := true ;
109750: LD_ADDR_EXP 193
109754: PUSH
109755: LD_INT 1
109757: ST_TO_ADDR
// if p3 = 32 then
109758: LD_VAR 0 3
109762: PUSH
109763: LD_INT 32
109765: EQUAL
109766: IFFALSE 109776
// sPower := true ;
109768: LD_ADDR_EXP 194
109772: PUSH
109773: LD_INT 1
109775: ST_TO_ADDR
// if p3 = 33 then
109776: LD_VAR 0 3
109780: PUSH
109781: LD_INT 33
109783: EQUAL
109784: IFFALSE 109794
// sRandom := true ;
109786: LD_ADDR_EXP 195
109790: PUSH
109791: LD_INT 1
109793: ST_TO_ADDR
// if p3 = 34 then
109794: LD_VAR 0 3
109798: PUSH
109799: LD_INT 34
109801: EQUAL
109802: IFFALSE 109812
// sShield := true ;
109804: LD_ADDR_EXP 196
109808: PUSH
109809: LD_INT 1
109811: ST_TO_ADDR
// if p3 = 35 then
109812: LD_VAR 0 3
109816: PUSH
109817: LD_INT 35
109819: EQUAL
109820: IFFALSE 109830
// sTime := true ;
109822: LD_ADDR_EXP 197
109826: PUSH
109827: LD_INT 1
109829: ST_TO_ADDR
// if p3 = 36 then
109830: LD_VAR 0 3
109834: PUSH
109835: LD_INT 36
109837: EQUAL
109838: IFFALSE 109848
// sTools := true ;
109840: LD_ADDR_EXP 198
109844: PUSH
109845: LD_INT 1
109847: ST_TO_ADDR
// if p3 = 101 then
109848: LD_VAR 0 3
109852: PUSH
109853: LD_INT 101
109855: EQUAL
109856: IFFALSE 109866
// sSold := true ;
109858: LD_ADDR_EXP 163
109862: PUSH
109863: LD_INT 1
109865: ST_TO_ADDR
// if p3 = 102 then
109866: LD_VAR 0 3
109870: PUSH
109871: LD_INT 102
109873: EQUAL
109874: IFFALSE 109884
// sDiff := true ;
109876: LD_ADDR_EXP 164
109880: PUSH
109881: LD_INT 1
109883: ST_TO_ADDR
// if p3 = 103 then
109884: LD_VAR 0 3
109888: PUSH
109889: LD_INT 103
109891: EQUAL
109892: IFFALSE 109902
// sFog := true ;
109894: LD_ADDR_EXP 167
109898: PUSH
109899: LD_INT 1
109901: ST_TO_ADDR
// if p3 = 104 then
109902: LD_VAR 0 3
109906: PUSH
109907: LD_INT 104
109909: EQUAL
109910: IFFALSE 109920
// sReset := true ;
109912: LD_ADDR_EXP 168
109916: PUSH
109917: LD_INT 1
109919: ST_TO_ADDR
// if p3 = 105 then
109920: LD_VAR 0 3
109924: PUSH
109925: LD_INT 105
109927: EQUAL
109928: IFFALSE 109938
// sSun := true ;
109930: LD_ADDR_EXP 169
109934: PUSH
109935: LD_INT 1
109937: ST_TO_ADDR
// if p3 = 106 then
109938: LD_VAR 0 3
109942: PUSH
109943: LD_INT 106
109945: EQUAL
109946: IFFALSE 109956
// sTiger := true ;
109948: LD_ADDR_EXP 165
109952: PUSH
109953: LD_INT 1
109955: ST_TO_ADDR
// if p3 = 107 then
109956: LD_VAR 0 3
109960: PUSH
109961: LD_INT 107
109963: EQUAL
109964: IFFALSE 109974
// sBomb := true ;
109966: LD_ADDR_EXP 166
109970: PUSH
109971: LD_INT 1
109973: ST_TO_ADDR
// if p3 = 108 then
109974: LD_VAR 0 3
109978: PUSH
109979: LD_INT 108
109981: EQUAL
109982: IFFALSE 109992
// sWound := true ;
109984: LD_ADDR_EXP 174
109988: PUSH
109989: LD_INT 1
109991: ST_TO_ADDR
// if p3 = 109 then
109992: LD_VAR 0 3
109996: PUSH
109997: LD_INT 109
109999: EQUAL
110000: IFFALSE 110010
// sBetray := true ;
110002: LD_ADDR_EXP 178
110006: PUSH
110007: LD_INT 1
110009: ST_TO_ADDR
// if p3 = 110 then
110010: LD_VAR 0 3
110014: PUSH
110015: LD_INT 110
110017: EQUAL
110018: IFFALSE 110028
// sContamin := true ;
110020: LD_ADDR_EXP 179
110024: PUSH
110025: LD_INT 1
110027: ST_TO_ADDR
// if p3 = 111 then
110028: LD_VAR 0 3
110032: PUSH
110033: LD_INT 111
110035: EQUAL
110036: IFFALSE 110046
// sOil := true ;
110038: LD_ADDR_EXP 181
110042: PUSH
110043: LD_INT 1
110045: ST_TO_ADDR
// if p3 = 112 then
110046: LD_VAR 0 3
110050: PUSH
110051: LD_INT 112
110053: EQUAL
110054: IFFALSE 110064
// sStu := true ;
110056: LD_ADDR_EXP 185
110060: PUSH
110061: LD_INT 1
110063: ST_TO_ADDR
// if p3 = 113 then
110064: LD_VAR 0 3
110068: PUSH
110069: LD_INT 113
110071: EQUAL
110072: IFFALSE 110082
// sBazooka := true ;
110074: LD_ADDR_EXP 188
110078: PUSH
110079: LD_INT 1
110081: ST_TO_ADDR
// if p3 = 114 then
110082: LD_VAR 0 3
110086: PUSH
110087: LD_INT 114
110089: EQUAL
110090: IFFALSE 110100
// sMortar := true ;
110092: LD_ADDR_EXP 189
110096: PUSH
110097: LD_INT 1
110099: ST_TO_ADDR
// if p3 = 115 then
110100: LD_VAR 0 3
110104: PUSH
110105: LD_INT 115
110107: EQUAL
110108: IFFALSE 110118
// sRanger := true ;
110110: LD_ADDR_EXP 199
110114: PUSH
110115: LD_INT 1
110117: ST_TO_ADDR
// if p3 = 116 then
110118: LD_VAR 0 3
110122: PUSH
110123: LD_INT 116
110125: EQUAL
110126: IFFALSE 110136
// sComputer := true ;
110128: LD_ADDR_EXP 200
110132: PUSH
110133: LD_INT 1
110135: ST_TO_ADDR
// if p3 = 117 then
110136: LD_VAR 0 3
110140: PUSH
110141: LD_INT 117
110143: EQUAL
110144: IFFALSE 110154
// s30 := true ;
110146: LD_ADDR_EXP 201
110150: PUSH
110151: LD_INT 1
110153: ST_TO_ADDR
// if p3 = 118 then
110154: LD_VAR 0 3
110158: PUSH
110159: LD_INT 118
110161: EQUAL
110162: IFFALSE 110172
// s60 := true ;
110164: LD_ADDR_EXP 202
110168: PUSH
110169: LD_INT 1
110171: ST_TO_ADDR
// end ; if p2 = hack_mode then
110172: LD_VAR 0 2
110176: PUSH
110177: LD_INT 101
110179: EQUAL
110180: IFFALSE 110308
// begin case p3 of 1 :
110182: LD_VAR 0 3
110186: PUSH
110187: LD_INT 1
110189: DOUBLE
110190: EQUAL
110191: IFTRUE 110195
110193: GO 110202
110195: POP
// hHackUnlimitedResources ; 2 :
110196: CALL 122447 0 0
110200: GO 110308
110202: LD_INT 2
110204: DOUBLE
110205: EQUAL
110206: IFTRUE 110210
110208: GO 110217
110210: POP
// hHackSetLevel10 ; 3 :
110211: CALL 122580 0 0
110215: GO 110308
110217: LD_INT 3
110219: DOUBLE
110220: EQUAL
110221: IFTRUE 110225
110223: GO 110232
110225: POP
// hHackSetLevel10YourUnits ; 4 :
110226: CALL 122665 0 0
110230: GO 110308
110232: LD_INT 4
110234: DOUBLE
110235: EQUAL
110236: IFTRUE 110240
110238: GO 110247
110240: POP
// hHackInvincible ; 5 :
110241: CALL 123113 0 0
110245: GO 110308
110247: LD_INT 5
110249: DOUBLE
110250: EQUAL
110251: IFTRUE 110255
110253: GO 110262
110255: POP
// hHackInvisible ; 6 :
110256: CALL 123224 0 0
110260: GO 110308
110262: LD_INT 6
110264: DOUBLE
110265: EQUAL
110266: IFTRUE 110270
110268: GO 110277
110270: POP
// hHackChangeYourSide ; 7 :
110271: CALL 123281 0 0
110275: GO 110308
110277: LD_INT 7
110279: DOUBLE
110280: EQUAL
110281: IFTRUE 110285
110283: GO 110292
110285: POP
// hHackChangeUnitSide ; 8 :
110286: CALL 123323 0 0
110290: GO 110308
110292: LD_INT 8
110294: DOUBLE
110295: EQUAL
110296: IFTRUE 110300
110298: GO 110307
110300: POP
// hHackFog ; end ;
110301: CALL 123424 0 0
110305: GO 110308
110307: POP
// end ; if p2 = game_save_mode then
110308: LD_VAR 0 2
110312: PUSH
110313: LD_INT 102
110315: EQUAL
110316: IFFALSE 110371
// begin if p3 = 1 then
110318: LD_VAR 0 3
110322: PUSH
110323: LD_INT 1
110325: EQUAL
110326: IFFALSE 110338
// globalGameSaveCounter := p4 ;
110328: LD_ADDR_EXP 145
110332: PUSH
110333: LD_VAR 0 4
110337: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
110338: LD_VAR 0 3
110342: PUSH
110343: LD_INT 2
110345: EQUAL
110346: PUSH
110347: LD_EXP 145
110351: AND
110352: IFFALSE 110371
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110354: LD_STRING setGameSaveCounter(
110356: PUSH
110357: LD_EXP 145
110361: STR
110362: PUSH
110363: LD_STRING )
110365: STR
110366: PPUSH
110367: CALL_OW 559
// end ; end ;
110371: LD_VAR 0 7
110375: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
110376: LD_INT 0
110378: PPUSH
// streamModeActive := false ;
110379: LD_ADDR_EXP 146
110383: PUSH
110384: LD_INT 0
110386: ST_TO_ADDR
// normalCounter := 36 ;
110387: LD_ADDR_EXP 147
110391: PUSH
110392: LD_INT 36
110394: ST_TO_ADDR
// hardcoreCounter := 18 ;
110395: LD_ADDR_EXP 148
110399: PUSH
110400: LD_INT 18
110402: ST_TO_ADDR
// sRocket := false ;
110403: LD_ADDR_EXP 151
110407: PUSH
110408: LD_INT 0
110410: ST_TO_ADDR
// sSpeed := false ;
110411: LD_ADDR_EXP 150
110415: PUSH
110416: LD_INT 0
110418: ST_TO_ADDR
// sEngine := false ;
110419: LD_ADDR_EXP 152
110423: PUSH
110424: LD_INT 0
110426: ST_TO_ADDR
// sSpec := false ;
110427: LD_ADDR_EXP 149
110431: PUSH
110432: LD_INT 0
110434: ST_TO_ADDR
// sLevel := false ;
110435: LD_ADDR_EXP 153
110439: PUSH
110440: LD_INT 0
110442: ST_TO_ADDR
// sArmoury := false ;
110443: LD_ADDR_EXP 154
110447: PUSH
110448: LD_INT 0
110450: ST_TO_ADDR
// sRadar := false ;
110451: LD_ADDR_EXP 155
110455: PUSH
110456: LD_INT 0
110458: ST_TO_ADDR
// sBunker := false ;
110459: LD_ADDR_EXP 156
110463: PUSH
110464: LD_INT 0
110466: ST_TO_ADDR
// sHack := false ;
110467: LD_ADDR_EXP 157
110471: PUSH
110472: LD_INT 0
110474: ST_TO_ADDR
// sFire := false ;
110475: LD_ADDR_EXP 158
110479: PUSH
110480: LD_INT 0
110482: ST_TO_ADDR
// sRefresh := false ;
110483: LD_ADDR_EXP 159
110487: PUSH
110488: LD_INT 0
110490: ST_TO_ADDR
// sExp := false ;
110491: LD_ADDR_EXP 160
110495: PUSH
110496: LD_INT 0
110498: ST_TO_ADDR
// sDepot := false ;
110499: LD_ADDR_EXP 161
110503: PUSH
110504: LD_INT 0
110506: ST_TO_ADDR
// sFlag := false ;
110507: LD_ADDR_EXP 162
110511: PUSH
110512: LD_INT 0
110514: ST_TO_ADDR
// sKamikadze := false ;
110515: LD_ADDR_EXP 170
110519: PUSH
110520: LD_INT 0
110522: ST_TO_ADDR
// sTroll := false ;
110523: LD_ADDR_EXP 171
110527: PUSH
110528: LD_INT 0
110530: ST_TO_ADDR
// sSlow := false ;
110531: LD_ADDR_EXP 172
110535: PUSH
110536: LD_INT 0
110538: ST_TO_ADDR
// sLack := false ;
110539: LD_ADDR_EXP 173
110543: PUSH
110544: LD_INT 0
110546: ST_TO_ADDR
// sTank := false ;
110547: LD_ADDR_EXP 175
110551: PUSH
110552: LD_INT 0
110554: ST_TO_ADDR
// sRemote := false ;
110555: LD_ADDR_EXP 176
110559: PUSH
110560: LD_INT 0
110562: ST_TO_ADDR
// sPowell := false ;
110563: LD_ADDR_EXP 177
110567: PUSH
110568: LD_INT 0
110570: ST_TO_ADDR
// sTeleport := false ;
110571: LD_ADDR_EXP 180
110575: PUSH
110576: LD_INT 0
110578: ST_TO_ADDR
// sOilTower := false ;
110579: LD_ADDR_EXP 182
110583: PUSH
110584: LD_INT 0
110586: ST_TO_ADDR
// sShovel := false ;
110587: LD_ADDR_EXP 183
110591: PUSH
110592: LD_INT 0
110594: ST_TO_ADDR
// sSheik := false ;
110595: LD_ADDR_EXP 184
110599: PUSH
110600: LD_INT 0
110602: ST_TO_ADDR
// sEarthquake := false ;
110603: LD_ADDR_EXP 186
110607: PUSH
110608: LD_INT 0
110610: ST_TO_ADDR
// sAI := false ;
110611: LD_ADDR_EXP 187
110615: PUSH
110616: LD_INT 0
110618: ST_TO_ADDR
// sCargo := false ;
110619: LD_ADDR_EXP 190
110623: PUSH
110624: LD_INT 0
110626: ST_TO_ADDR
// sDLaser := false ;
110627: LD_ADDR_EXP 191
110631: PUSH
110632: LD_INT 0
110634: ST_TO_ADDR
// sExchange := false ;
110635: LD_ADDR_EXP 192
110639: PUSH
110640: LD_INT 0
110642: ST_TO_ADDR
// sFac := false ;
110643: LD_ADDR_EXP 193
110647: PUSH
110648: LD_INT 0
110650: ST_TO_ADDR
// sPower := false ;
110651: LD_ADDR_EXP 194
110655: PUSH
110656: LD_INT 0
110658: ST_TO_ADDR
// sRandom := false ;
110659: LD_ADDR_EXP 195
110663: PUSH
110664: LD_INT 0
110666: ST_TO_ADDR
// sShield := false ;
110667: LD_ADDR_EXP 196
110671: PUSH
110672: LD_INT 0
110674: ST_TO_ADDR
// sTime := false ;
110675: LD_ADDR_EXP 197
110679: PUSH
110680: LD_INT 0
110682: ST_TO_ADDR
// sTools := false ;
110683: LD_ADDR_EXP 198
110687: PUSH
110688: LD_INT 0
110690: ST_TO_ADDR
// sSold := false ;
110691: LD_ADDR_EXP 163
110695: PUSH
110696: LD_INT 0
110698: ST_TO_ADDR
// sDiff := false ;
110699: LD_ADDR_EXP 164
110703: PUSH
110704: LD_INT 0
110706: ST_TO_ADDR
// sFog := false ;
110707: LD_ADDR_EXP 167
110711: PUSH
110712: LD_INT 0
110714: ST_TO_ADDR
// sReset := false ;
110715: LD_ADDR_EXP 168
110719: PUSH
110720: LD_INT 0
110722: ST_TO_ADDR
// sSun := false ;
110723: LD_ADDR_EXP 169
110727: PUSH
110728: LD_INT 0
110730: ST_TO_ADDR
// sTiger := false ;
110731: LD_ADDR_EXP 165
110735: PUSH
110736: LD_INT 0
110738: ST_TO_ADDR
// sBomb := false ;
110739: LD_ADDR_EXP 166
110743: PUSH
110744: LD_INT 0
110746: ST_TO_ADDR
// sWound := false ;
110747: LD_ADDR_EXP 174
110751: PUSH
110752: LD_INT 0
110754: ST_TO_ADDR
// sBetray := false ;
110755: LD_ADDR_EXP 178
110759: PUSH
110760: LD_INT 0
110762: ST_TO_ADDR
// sContamin := false ;
110763: LD_ADDR_EXP 179
110767: PUSH
110768: LD_INT 0
110770: ST_TO_ADDR
// sOil := false ;
110771: LD_ADDR_EXP 181
110775: PUSH
110776: LD_INT 0
110778: ST_TO_ADDR
// sStu := false ;
110779: LD_ADDR_EXP 185
110783: PUSH
110784: LD_INT 0
110786: ST_TO_ADDR
// sBazooka := false ;
110787: LD_ADDR_EXP 188
110791: PUSH
110792: LD_INT 0
110794: ST_TO_ADDR
// sMortar := false ;
110795: LD_ADDR_EXP 189
110799: PUSH
110800: LD_INT 0
110802: ST_TO_ADDR
// sRanger := false ;
110803: LD_ADDR_EXP 199
110807: PUSH
110808: LD_INT 0
110810: ST_TO_ADDR
// sComputer := false ;
110811: LD_ADDR_EXP 200
110815: PUSH
110816: LD_INT 0
110818: ST_TO_ADDR
// s30 := false ;
110819: LD_ADDR_EXP 201
110823: PUSH
110824: LD_INT 0
110826: ST_TO_ADDR
// s60 := false ;
110827: LD_ADDR_EXP 202
110831: PUSH
110832: LD_INT 0
110834: ST_TO_ADDR
// end ;
110835: LD_VAR 0 1
110839: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110840: LD_INT 0
110842: PPUSH
110843: PPUSH
110844: PPUSH
110845: PPUSH
110846: PPUSH
110847: PPUSH
110848: PPUSH
// result := [ ] ;
110849: LD_ADDR_VAR 0 2
110853: PUSH
110854: EMPTY
110855: ST_TO_ADDR
// if campaign_id = 1 then
110856: LD_OWVAR 69
110860: PUSH
110861: LD_INT 1
110863: EQUAL
110864: IFFALSE 114030
// begin case mission_number of 1 :
110866: LD_OWVAR 70
110870: PUSH
110871: LD_INT 1
110873: DOUBLE
110874: EQUAL
110875: IFTRUE 110879
110877: GO 110955
110879: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110880: LD_ADDR_VAR 0 2
110884: PUSH
110885: LD_INT 2
110887: PUSH
110888: LD_INT 4
110890: PUSH
110891: LD_INT 11
110893: PUSH
110894: LD_INT 12
110896: PUSH
110897: LD_INT 15
110899: PUSH
110900: LD_INT 16
110902: PUSH
110903: LD_INT 22
110905: PUSH
110906: LD_INT 23
110908: PUSH
110909: LD_INT 26
110911: PUSH
110912: EMPTY
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: PUSH
110923: LD_INT 101
110925: PUSH
110926: LD_INT 102
110928: PUSH
110929: LD_INT 106
110931: PUSH
110932: LD_INT 116
110934: PUSH
110935: LD_INT 117
110937: PUSH
110938: LD_INT 118
110940: PUSH
110941: EMPTY
110942: LIST
110943: LIST
110944: LIST
110945: LIST
110946: LIST
110947: LIST
110948: PUSH
110949: EMPTY
110950: LIST
110951: LIST
110952: ST_TO_ADDR
110953: GO 114028
110955: LD_INT 2
110957: DOUBLE
110958: EQUAL
110959: IFTRUE 110963
110961: GO 111047
110963: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110964: LD_ADDR_VAR 0 2
110968: PUSH
110969: LD_INT 2
110971: PUSH
110972: LD_INT 4
110974: PUSH
110975: LD_INT 11
110977: PUSH
110978: LD_INT 12
110980: PUSH
110981: LD_INT 15
110983: PUSH
110984: LD_INT 16
110986: PUSH
110987: LD_INT 22
110989: PUSH
110990: LD_INT 23
110992: PUSH
110993: LD_INT 26
110995: PUSH
110996: EMPTY
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: LIST
111002: LIST
111003: LIST
111004: LIST
111005: LIST
111006: PUSH
111007: LD_INT 101
111009: PUSH
111010: LD_INT 102
111012: PUSH
111013: LD_INT 105
111015: PUSH
111016: LD_INT 106
111018: PUSH
111019: LD_INT 108
111021: PUSH
111022: LD_INT 116
111024: PUSH
111025: LD_INT 117
111027: PUSH
111028: LD_INT 118
111030: PUSH
111031: EMPTY
111032: LIST
111033: LIST
111034: LIST
111035: LIST
111036: LIST
111037: LIST
111038: LIST
111039: LIST
111040: PUSH
111041: EMPTY
111042: LIST
111043: LIST
111044: ST_TO_ADDR
111045: GO 114028
111047: LD_INT 3
111049: DOUBLE
111050: EQUAL
111051: IFTRUE 111055
111053: GO 111143
111055: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
111056: LD_ADDR_VAR 0 2
111060: PUSH
111061: LD_INT 2
111063: PUSH
111064: LD_INT 4
111066: PUSH
111067: LD_INT 5
111069: PUSH
111070: LD_INT 11
111072: PUSH
111073: LD_INT 12
111075: PUSH
111076: LD_INT 15
111078: PUSH
111079: LD_INT 16
111081: PUSH
111082: LD_INT 22
111084: PUSH
111085: LD_INT 26
111087: PUSH
111088: LD_INT 36
111090: PUSH
111091: EMPTY
111092: LIST
111093: LIST
111094: LIST
111095: LIST
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: PUSH
111103: LD_INT 101
111105: PUSH
111106: LD_INT 102
111108: PUSH
111109: LD_INT 105
111111: PUSH
111112: LD_INT 106
111114: PUSH
111115: LD_INT 108
111117: PUSH
111118: LD_INT 116
111120: PUSH
111121: LD_INT 117
111123: PUSH
111124: LD_INT 118
111126: PUSH
111127: EMPTY
111128: LIST
111129: LIST
111130: LIST
111131: LIST
111132: LIST
111133: LIST
111134: LIST
111135: LIST
111136: PUSH
111137: EMPTY
111138: LIST
111139: LIST
111140: ST_TO_ADDR
111141: GO 114028
111143: LD_INT 4
111145: DOUBLE
111146: EQUAL
111147: IFTRUE 111151
111149: GO 111247
111151: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
111152: LD_ADDR_VAR 0 2
111156: PUSH
111157: LD_INT 2
111159: PUSH
111160: LD_INT 4
111162: PUSH
111163: LD_INT 5
111165: PUSH
111166: LD_INT 8
111168: PUSH
111169: LD_INT 11
111171: PUSH
111172: LD_INT 12
111174: PUSH
111175: LD_INT 15
111177: PUSH
111178: LD_INT 16
111180: PUSH
111181: LD_INT 22
111183: PUSH
111184: LD_INT 23
111186: PUSH
111187: LD_INT 26
111189: PUSH
111190: LD_INT 36
111192: PUSH
111193: EMPTY
111194: LIST
111195: LIST
111196: LIST
111197: LIST
111198: LIST
111199: LIST
111200: LIST
111201: LIST
111202: LIST
111203: LIST
111204: LIST
111205: LIST
111206: PUSH
111207: LD_INT 101
111209: PUSH
111210: LD_INT 102
111212: PUSH
111213: LD_INT 105
111215: PUSH
111216: LD_INT 106
111218: PUSH
111219: LD_INT 108
111221: PUSH
111222: LD_INT 116
111224: PUSH
111225: LD_INT 117
111227: PUSH
111228: LD_INT 118
111230: PUSH
111231: EMPTY
111232: LIST
111233: LIST
111234: LIST
111235: LIST
111236: LIST
111237: LIST
111238: LIST
111239: LIST
111240: PUSH
111241: EMPTY
111242: LIST
111243: LIST
111244: ST_TO_ADDR
111245: GO 114028
111247: LD_INT 5
111249: DOUBLE
111250: EQUAL
111251: IFTRUE 111255
111253: GO 111367
111255: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
111256: LD_ADDR_VAR 0 2
111260: PUSH
111261: LD_INT 2
111263: PUSH
111264: LD_INT 4
111266: PUSH
111267: LD_INT 5
111269: PUSH
111270: LD_INT 6
111272: PUSH
111273: LD_INT 8
111275: PUSH
111276: LD_INT 11
111278: PUSH
111279: LD_INT 12
111281: PUSH
111282: LD_INT 15
111284: PUSH
111285: LD_INT 16
111287: PUSH
111288: LD_INT 22
111290: PUSH
111291: LD_INT 23
111293: PUSH
111294: LD_INT 25
111296: PUSH
111297: LD_INT 26
111299: PUSH
111300: LD_INT 36
111302: PUSH
111303: EMPTY
111304: LIST
111305: LIST
111306: LIST
111307: LIST
111308: LIST
111309: LIST
111310: LIST
111311: LIST
111312: LIST
111313: LIST
111314: LIST
111315: LIST
111316: LIST
111317: LIST
111318: PUSH
111319: LD_INT 101
111321: PUSH
111322: LD_INT 102
111324: PUSH
111325: LD_INT 105
111327: PUSH
111328: LD_INT 106
111330: PUSH
111331: LD_INT 108
111333: PUSH
111334: LD_INT 109
111336: PUSH
111337: LD_INT 112
111339: PUSH
111340: LD_INT 116
111342: PUSH
111343: LD_INT 117
111345: PUSH
111346: LD_INT 118
111348: PUSH
111349: EMPTY
111350: LIST
111351: LIST
111352: LIST
111353: LIST
111354: LIST
111355: LIST
111356: LIST
111357: LIST
111358: LIST
111359: LIST
111360: PUSH
111361: EMPTY
111362: LIST
111363: LIST
111364: ST_TO_ADDR
111365: GO 114028
111367: LD_INT 6
111369: DOUBLE
111370: EQUAL
111371: IFTRUE 111375
111373: GO 111507
111375: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
111376: LD_ADDR_VAR 0 2
111380: PUSH
111381: LD_INT 2
111383: PUSH
111384: LD_INT 4
111386: PUSH
111387: LD_INT 5
111389: PUSH
111390: LD_INT 6
111392: PUSH
111393: LD_INT 8
111395: PUSH
111396: LD_INT 11
111398: PUSH
111399: LD_INT 12
111401: PUSH
111402: LD_INT 15
111404: PUSH
111405: LD_INT 16
111407: PUSH
111408: LD_INT 20
111410: PUSH
111411: LD_INT 21
111413: PUSH
111414: LD_INT 22
111416: PUSH
111417: LD_INT 23
111419: PUSH
111420: LD_INT 25
111422: PUSH
111423: LD_INT 26
111425: PUSH
111426: LD_INT 30
111428: PUSH
111429: LD_INT 31
111431: PUSH
111432: LD_INT 32
111434: PUSH
111435: LD_INT 36
111437: PUSH
111438: EMPTY
111439: LIST
111440: LIST
111441: LIST
111442: LIST
111443: LIST
111444: LIST
111445: LIST
111446: LIST
111447: LIST
111448: LIST
111449: LIST
111450: LIST
111451: LIST
111452: LIST
111453: LIST
111454: LIST
111455: LIST
111456: LIST
111457: LIST
111458: PUSH
111459: LD_INT 101
111461: PUSH
111462: LD_INT 102
111464: PUSH
111465: LD_INT 105
111467: PUSH
111468: LD_INT 106
111470: PUSH
111471: LD_INT 108
111473: PUSH
111474: LD_INT 109
111476: PUSH
111477: LD_INT 112
111479: PUSH
111480: LD_INT 116
111482: PUSH
111483: LD_INT 117
111485: PUSH
111486: LD_INT 118
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: LIST
111493: LIST
111494: LIST
111495: LIST
111496: LIST
111497: LIST
111498: LIST
111499: LIST
111500: PUSH
111501: EMPTY
111502: LIST
111503: LIST
111504: ST_TO_ADDR
111505: GO 114028
111507: LD_INT 7
111509: DOUBLE
111510: EQUAL
111511: IFTRUE 111515
111513: GO 111627
111515: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
111516: LD_ADDR_VAR 0 2
111520: PUSH
111521: LD_INT 2
111523: PUSH
111524: LD_INT 4
111526: PUSH
111527: LD_INT 5
111529: PUSH
111530: LD_INT 7
111532: PUSH
111533: LD_INT 11
111535: PUSH
111536: LD_INT 12
111538: PUSH
111539: LD_INT 15
111541: PUSH
111542: LD_INT 16
111544: PUSH
111545: LD_INT 20
111547: PUSH
111548: LD_INT 21
111550: PUSH
111551: LD_INT 22
111553: PUSH
111554: LD_INT 23
111556: PUSH
111557: LD_INT 25
111559: PUSH
111560: LD_INT 26
111562: PUSH
111563: EMPTY
111564: LIST
111565: LIST
111566: LIST
111567: LIST
111568: LIST
111569: LIST
111570: LIST
111571: LIST
111572: LIST
111573: LIST
111574: LIST
111575: LIST
111576: LIST
111577: LIST
111578: PUSH
111579: LD_INT 101
111581: PUSH
111582: LD_INT 102
111584: PUSH
111585: LD_INT 103
111587: PUSH
111588: LD_INT 105
111590: PUSH
111591: LD_INT 106
111593: PUSH
111594: LD_INT 108
111596: PUSH
111597: LD_INT 112
111599: PUSH
111600: LD_INT 116
111602: PUSH
111603: LD_INT 117
111605: PUSH
111606: LD_INT 118
111608: PUSH
111609: EMPTY
111610: LIST
111611: LIST
111612: LIST
111613: LIST
111614: LIST
111615: LIST
111616: LIST
111617: LIST
111618: LIST
111619: LIST
111620: PUSH
111621: EMPTY
111622: LIST
111623: LIST
111624: ST_TO_ADDR
111625: GO 114028
111627: LD_INT 8
111629: DOUBLE
111630: EQUAL
111631: IFTRUE 111635
111633: GO 111775
111635: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
111636: LD_ADDR_VAR 0 2
111640: PUSH
111641: LD_INT 2
111643: PUSH
111644: LD_INT 4
111646: PUSH
111647: LD_INT 5
111649: PUSH
111650: LD_INT 6
111652: PUSH
111653: LD_INT 7
111655: PUSH
111656: LD_INT 8
111658: PUSH
111659: LD_INT 11
111661: PUSH
111662: LD_INT 12
111664: PUSH
111665: LD_INT 15
111667: PUSH
111668: LD_INT 16
111670: PUSH
111671: LD_INT 20
111673: PUSH
111674: LD_INT 21
111676: PUSH
111677: LD_INT 22
111679: PUSH
111680: LD_INT 23
111682: PUSH
111683: LD_INT 25
111685: PUSH
111686: LD_INT 26
111688: PUSH
111689: LD_INT 30
111691: PUSH
111692: LD_INT 31
111694: PUSH
111695: LD_INT 32
111697: PUSH
111698: LD_INT 36
111700: PUSH
111701: EMPTY
111702: LIST
111703: LIST
111704: LIST
111705: LIST
111706: LIST
111707: LIST
111708: LIST
111709: LIST
111710: LIST
111711: LIST
111712: LIST
111713: LIST
111714: LIST
111715: LIST
111716: LIST
111717: LIST
111718: LIST
111719: LIST
111720: LIST
111721: LIST
111722: PUSH
111723: LD_INT 101
111725: PUSH
111726: LD_INT 102
111728: PUSH
111729: LD_INT 103
111731: PUSH
111732: LD_INT 105
111734: PUSH
111735: LD_INT 106
111737: PUSH
111738: LD_INT 108
111740: PUSH
111741: LD_INT 109
111743: PUSH
111744: LD_INT 112
111746: PUSH
111747: LD_INT 116
111749: PUSH
111750: LD_INT 117
111752: PUSH
111753: LD_INT 118
111755: PUSH
111756: EMPTY
111757: LIST
111758: LIST
111759: LIST
111760: LIST
111761: LIST
111762: LIST
111763: LIST
111764: LIST
111765: LIST
111766: LIST
111767: LIST
111768: PUSH
111769: EMPTY
111770: LIST
111771: LIST
111772: ST_TO_ADDR
111773: GO 114028
111775: LD_INT 9
111777: DOUBLE
111778: EQUAL
111779: IFTRUE 111783
111781: GO 111931
111783: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111784: LD_ADDR_VAR 0 2
111788: PUSH
111789: LD_INT 2
111791: PUSH
111792: LD_INT 4
111794: PUSH
111795: LD_INT 5
111797: PUSH
111798: LD_INT 6
111800: PUSH
111801: LD_INT 7
111803: PUSH
111804: LD_INT 8
111806: PUSH
111807: LD_INT 11
111809: PUSH
111810: LD_INT 12
111812: PUSH
111813: LD_INT 15
111815: PUSH
111816: LD_INT 16
111818: PUSH
111819: LD_INT 20
111821: PUSH
111822: LD_INT 21
111824: PUSH
111825: LD_INT 22
111827: PUSH
111828: LD_INT 23
111830: PUSH
111831: LD_INT 25
111833: PUSH
111834: LD_INT 26
111836: PUSH
111837: LD_INT 28
111839: PUSH
111840: LD_INT 30
111842: PUSH
111843: LD_INT 31
111845: PUSH
111846: LD_INT 32
111848: PUSH
111849: LD_INT 36
111851: PUSH
111852: EMPTY
111853: LIST
111854: LIST
111855: LIST
111856: LIST
111857: LIST
111858: LIST
111859: LIST
111860: LIST
111861: LIST
111862: LIST
111863: LIST
111864: LIST
111865: LIST
111866: LIST
111867: LIST
111868: LIST
111869: LIST
111870: LIST
111871: LIST
111872: LIST
111873: LIST
111874: PUSH
111875: LD_INT 101
111877: PUSH
111878: LD_INT 102
111880: PUSH
111881: LD_INT 103
111883: PUSH
111884: LD_INT 105
111886: PUSH
111887: LD_INT 106
111889: PUSH
111890: LD_INT 108
111892: PUSH
111893: LD_INT 109
111895: PUSH
111896: LD_INT 112
111898: PUSH
111899: LD_INT 114
111901: PUSH
111902: LD_INT 116
111904: PUSH
111905: LD_INT 117
111907: PUSH
111908: LD_INT 118
111910: PUSH
111911: EMPTY
111912: LIST
111913: LIST
111914: LIST
111915: LIST
111916: LIST
111917: LIST
111918: LIST
111919: LIST
111920: LIST
111921: LIST
111922: LIST
111923: LIST
111924: PUSH
111925: EMPTY
111926: LIST
111927: LIST
111928: ST_TO_ADDR
111929: GO 114028
111931: LD_INT 10
111933: DOUBLE
111934: EQUAL
111935: IFTRUE 111939
111937: GO 112135
111939: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111940: LD_ADDR_VAR 0 2
111944: PUSH
111945: LD_INT 2
111947: PUSH
111948: LD_INT 4
111950: PUSH
111951: LD_INT 5
111953: PUSH
111954: LD_INT 6
111956: PUSH
111957: LD_INT 7
111959: PUSH
111960: LD_INT 8
111962: PUSH
111963: LD_INT 9
111965: PUSH
111966: LD_INT 10
111968: PUSH
111969: LD_INT 11
111971: PUSH
111972: LD_INT 12
111974: PUSH
111975: LD_INT 13
111977: PUSH
111978: LD_INT 14
111980: PUSH
111981: LD_INT 15
111983: PUSH
111984: LD_INT 16
111986: PUSH
111987: LD_INT 17
111989: PUSH
111990: LD_INT 18
111992: PUSH
111993: LD_INT 19
111995: PUSH
111996: LD_INT 20
111998: PUSH
111999: LD_INT 21
112001: PUSH
112002: LD_INT 22
112004: PUSH
112005: LD_INT 23
112007: PUSH
112008: LD_INT 24
112010: PUSH
112011: LD_INT 25
112013: PUSH
112014: LD_INT 26
112016: PUSH
112017: LD_INT 28
112019: PUSH
112020: LD_INT 30
112022: PUSH
112023: LD_INT 31
112025: PUSH
112026: LD_INT 32
112028: PUSH
112029: LD_INT 36
112031: PUSH
112032: EMPTY
112033: LIST
112034: LIST
112035: LIST
112036: LIST
112037: LIST
112038: LIST
112039: LIST
112040: LIST
112041: LIST
112042: LIST
112043: LIST
112044: LIST
112045: LIST
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: LIST
112055: LIST
112056: LIST
112057: LIST
112058: LIST
112059: LIST
112060: LIST
112061: LIST
112062: PUSH
112063: LD_INT 101
112065: PUSH
112066: LD_INT 102
112068: PUSH
112069: LD_INT 103
112071: PUSH
112072: LD_INT 104
112074: PUSH
112075: LD_INT 105
112077: PUSH
112078: LD_INT 106
112080: PUSH
112081: LD_INT 107
112083: PUSH
112084: LD_INT 108
112086: PUSH
112087: LD_INT 109
112089: PUSH
112090: LD_INT 110
112092: PUSH
112093: LD_INT 111
112095: PUSH
112096: LD_INT 112
112098: PUSH
112099: LD_INT 114
112101: PUSH
112102: LD_INT 116
112104: PUSH
112105: LD_INT 117
112107: PUSH
112108: LD_INT 118
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: LIST
112117: LIST
112118: LIST
112119: LIST
112120: LIST
112121: LIST
112122: LIST
112123: LIST
112124: LIST
112125: LIST
112126: LIST
112127: LIST
112128: PUSH
112129: EMPTY
112130: LIST
112131: LIST
112132: ST_TO_ADDR
112133: GO 114028
112135: LD_INT 11
112137: DOUBLE
112138: EQUAL
112139: IFTRUE 112143
112141: GO 112347
112143: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
112144: LD_ADDR_VAR 0 2
112148: PUSH
112149: LD_INT 2
112151: PUSH
112152: LD_INT 3
112154: PUSH
112155: LD_INT 4
112157: PUSH
112158: LD_INT 5
112160: PUSH
112161: LD_INT 6
112163: PUSH
112164: LD_INT 7
112166: PUSH
112167: LD_INT 8
112169: PUSH
112170: LD_INT 9
112172: PUSH
112173: LD_INT 10
112175: PUSH
112176: LD_INT 11
112178: PUSH
112179: LD_INT 12
112181: PUSH
112182: LD_INT 13
112184: PUSH
112185: LD_INT 14
112187: PUSH
112188: LD_INT 15
112190: PUSH
112191: LD_INT 16
112193: PUSH
112194: LD_INT 17
112196: PUSH
112197: LD_INT 18
112199: PUSH
112200: LD_INT 19
112202: PUSH
112203: LD_INT 20
112205: PUSH
112206: LD_INT 21
112208: PUSH
112209: LD_INT 22
112211: PUSH
112212: LD_INT 23
112214: PUSH
112215: LD_INT 24
112217: PUSH
112218: LD_INT 25
112220: PUSH
112221: LD_INT 26
112223: PUSH
112224: LD_INT 28
112226: PUSH
112227: LD_INT 30
112229: PUSH
112230: LD_INT 31
112232: PUSH
112233: LD_INT 32
112235: PUSH
112236: LD_INT 34
112238: PUSH
112239: LD_INT 36
112241: PUSH
112242: EMPTY
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: LIST
112252: LIST
112253: LIST
112254: LIST
112255: LIST
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: LIST
112266: LIST
112267: LIST
112268: LIST
112269: LIST
112270: LIST
112271: LIST
112272: LIST
112273: LIST
112274: PUSH
112275: LD_INT 101
112277: PUSH
112278: LD_INT 102
112280: PUSH
112281: LD_INT 103
112283: PUSH
112284: LD_INT 104
112286: PUSH
112287: LD_INT 105
112289: PUSH
112290: LD_INT 106
112292: PUSH
112293: LD_INT 107
112295: PUSH
112296: LD_INT 108
112298: PUSH
112299: LD_INT 109
112301: PUSH
112302: LD_INT 110
112304: PUSH
112305: LD_INT 111
112307: PUSH
112308: LD_INT 112
112310: PUSH
112311: LD_INT 114
112313: PUSH
112314: LD_INT 116
112316: PUSH
112317: LD_INT 117
112319: PUSH
112320: LD_INT 118
112322: PUSH
112323: EMPTY
112324: LIST
112325: LIST
112326: LIST
112327: LIST
112328: LIST
112329: LIST
112330: LIST
112331: LIST
112332: LIST
112333: LIST
112334: LIST
112335: LIST
112336: LIST
112337: LIST
112338: LIST
112339: LIST
112340: PUSH
112341: EMPTY
112342: LIST
112343: LIST
112344: ST_TO_ADDR
112345: GO 114028
112347: LD_INT 12
112349: DOUBLE
112350: EQUAL
112351: IFTRUE 112355
112353: GO 112575
112355: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
112356: LD_ADDR_VAR 0 2
112360: PUSH
112361: LD_INT 1
112363: PUSH
112364: LD_INT 2
112366: PUSH
112367: LD_INT 3
112369: PUSH
112370: LD_INT 4
112372: PUSH
112373: LD_INT 5
112375: PUSH
112376: LD_INT 6
112378: PUSH
112379: LD_INT 7
112381: PUSH
112382: LD_INT 8
112384: PUSH
112385: LD_INT 9
112387: PUSH
112388: LD_INT 10
112390: PUSH
112391: LD_INT 11
112393: PUSH
112394: LD_INT 12
112396: PUSH
112397: LD_INT 13
112399: PUSH
112400: LD_INT 14
112402: PUSH
112403: LD_INT 15
112405: PUSH
112406: LD_INT 16
112408: PUSH
112409: LD_INT 17
112411: PUSH
112412: LD_INT 18
112414: PUSH
112415: LD_INT 19
112417: PUSH
112418: LD_INT 20
112420: PUSH
112421: LD_INT 21
112423: PUSH
112424: LD_INT 22
112426: PUSH
112427: LD_INT 23
112429: PUSH
112430: LD_INT 24
112432: PUSH
112433: LD_INT 25
112435: PUSH
112436: LD_INT 26
112438: PUSH
112439: LD_INT 27
112441: PUSH
112442: LD_INT 28
112444: PUSH
112445: LD_INT 30
112447: PUSH
112448: LD_INT 31
112450: PUSH
112451: LD_INT 32
112453: PUSH
112454: LD_INT 33
112456: PUSH
112457: LD_INT 34
112459: PUSH
112460: LD_INT 36
112462: PUSH
112463: EMPTY
112464: LIST
112465: LIST
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: LIST
112497: LIST
112498: PUSH
112499: LD_INT 101
112501: PUSH
112502: LD_INT 102
112504: PUSH
112505: LD_INT 103
112507: PUSH
112508: LD_INT 104
112510: PUSH
112511: LD_INT 105
112513: PUSH
112514: LD_INT 106
112516: PUSH
112517: LD_INT 107
112519: PUSH
112520: LD_INT 108
112522: PUSH
112523: LD_INT 109
112525: PUSH
112526: LD_INT 110
112528: PUSH
112529: LD_INT 111
112531: PUSH
112532: LD_INT 112
112534: PUSH
112535: LD_INT 113
112537: PUSH
112538: LD_INT 114
112540: PUSH
112541: LD_INT 116
112543: PUSH
112544: LD_INT 117
112546: PUSH
112547: LD_INT 118
112549: PUSH
112550: EMPTY
112551: LIST
112552: LIST
112553: LIST
112554: LIST
112555: LIST
112556: LIST
112557: LIST
112558: LIST
112559: LIST
112560: LIST
112561: LIST
112562: LIST
112563: LIST
112564: LIST
112565: LIST
112566: LIST
112567: LIST
112568: PUSH
112569: EMPTY
112570: LIST
112571: LIST
112572: ST_TO_ADDR
112573: GO 114028
112575: LD_INT 13
112577: DOUBLE
112578: EQUAL
112579: IFTRUE 112583
112581: GO 112791
112583: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
112584: LD_ADDR_VAR 0 2
112588: PUSH
112589: LD_INT 1
112591: PUSH
112592: LD_INT 2
112594: PUSH
112595: LD_INT 3
112597: PUSH
112598: LD_INT 4
112600: PUSH
112601: LD_INT 5
112603: PUSH
112604: LD_INT 8
112606: PUSH
112607: LD_INT 9
112609: PUSH
112610: LD_INT 10
112612: PUSH
112613: LD_INT 11
112615: PUSH
112616: LD_INT 12
112618: PUSH
112619: LD_INT 14
112621: PUSH
112622: LD_INT 15
112624: PUSH
112625: LD_INT 16
112627: PUSH
112628: LD_INT 17
112630: PUSH
112631: LD_INT 18
112633: PUSH
112634: LD_INT 19
112636: PUSH
112637: LD_INT 20
112639: PUSH
112640: LD_INT 21
112642: PUSH
112643: LD_INT 22
112645: PUSH
112646: LD_INT 23
112648: PUSH
112649: LD_INT 24
112651: PUSH
112652: LD_INT 25
112654: PUSH
112655: LD_INT 26
112657: PUSH
112658: LD_INT 27
112660: PUSH
112661: LD_INT 28
112663: PUSH
112664: LD_INT 30
112666: PUSH
112667: LD_INT 31
112669: PUSH
112670: LD_INT 32
112672: PUSH
112673: LD_INT 33
112675: PUSH
112676: LD_INT 34
112678: PUSH
112679: LD_INT 36
112681: PUSH
112682: EMPTY
112683: LIST
112684: LIST
112685: LIST
112686: LIST
112687: LIST
112688: LIST
112689: LIST
112690: LIST
112691: LIST
112692: LIST
112693: LIST
112694: LIST
112695: LIST
112696: LIST
112697: LIST
112698: LIST
112699: LIST
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: PUSH
112715: LD_INT 101
112717: PUSH
112718: LD_INT 102
112720: PUSH
112721: LD_INT 103
112723: PUSH
112724: LD_INT 104
112726: PUSH
112727: LD_INT 105
112729: PUSH
112730: LD_INT 106
112732: PUSH
112733: LD_INT 107
112735: PUSH
112736: LD_INT 108
112738: PUSH
112739: LD_INT 109
112741: PUSH
112742: LD_INT 110
112744: PUSH
112745: LD_INT 111
112747: PUSH
112748: LD_INT 112
112750: PUSH
112751: LD_INT 113
112753: PUSH
112754: LD_INT 114
112756: PUSH
112757: LD_INT 116
112759: PUSH
112760: LD_INT 117
112762: PUSH
112763: LD_INT 118
112765: PUSH
112766: EMPTY
112767: LIST
112768: LIST
112769: LIST
112770: LIST
112771: LIST
112772: LIST
112773: LIST
112774: LIST
112775: LIST
112776: LIST
112777: LIST
112778: LIST
112779: LIST
112780: LIST
112781: LIST
112782: LIST
112783: LIST
112784: PUSH
112785: EMPTY
112786: LIST
112787: LIST
112788: ST_TO_ADDR
112789: GO 114028
112791: LD_INT 14
112793: DOUBLE
112794: EQUAL
112795: IFTRUE 112799
112797: GO 113023
112799: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112800: LD_ADDR_VAR 0 2
112804: PUSH
112805: LD_INT 1
112807: PUSH
112808: LD_INT 2
112810: PUSH
112811: LD_INT 3
112813: PUSH
112814: LD_INT 4
112816: PUSH
112817: LD_INT 5
112819: PUSH
112820: LD_INT 6
112822: PUSH
112823: LD_INT 7
112825: PUSH
112826: LD_INT 8
112828: PUSH
112829: LD_INT 9
112831: PUSH
112832: LD_INT 10
112834: PUSH
112835: LD_INT 11
112837: PUSH
112838: LD_INT 12
112840: PUSH
112841: LD_INT 13
112843: PUSH
112844: LD_INT 14
112846: PUSH
112847: LD_INT 15
112849: PUSH
112850: LD_INT 16
112852: PUSH
112853: LD_INT 17
112855: PUSH
112856: LD_INT 18
112858: PUSH
112859: LD_INT 19
112861: PUSH
112862: LD_INT 20
112864: PUSH
112865: LD_INT 21
112867: PUSH
112868: LD_INT 22
112870: PUSH
112871: LD_INT 23
112873: PUSH
112874: LD_INT 24
112876: PUSH
112877: LD_INT 25
112879: PUSH
112880: LD_INT 26
112882: PUSH
112883: LD_INT 27
112885: PUSH
112886: LD_INT 28
112888: PUSH
112889: LD_INT 29
112891: PUSH
112892: LD_INT 30
112894: PUSH
112895: LD_INT 31
112897: PUSH
112898: LD_INT 32
112900: PUSH
112901: LD_INT 33
112903: PUSH
112904: LD_INT 34
112906: PUSH
112907: LD_INT 36
112909: PUSH
112910: EMPTY
112911: LIST
112912: LIST
112913: LIST
112914: LIST
112915: LIST
112916: LIST
112917: LIST
112918: LIST
112919: LIST
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: LIST
112925: LIST
112926: LIST
112927: LIST
112928: LIST
112929: LIST
112930: LIST
112931: LIST
112932: LIST
112933: LIST
112934: LIST
112935: LIST
112936: LIST
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: LIST
112942: LIST
112943: LIST
112944: LIST
112945: LIST
112946: PUSH
112947: LD_INT 101
112949: PUSH
112950: LD_INT 102
112952: PUSH
112953: LD_INT 103
112955: PUSH
112956: LD_INT 104
112958: PUSH
112959: LD_INT 105
112961: PUSH
112962: LD_INT 106
112964: PUSH
112965: LD_INT 107
112967: PUSH
112968: LD_INT 108
112970: PUSH
112971: LD_INT 109
112973: PUSH
112974: LD_INT 110
112976: PUSH
112977: LD_INT 111
112979: PUSH
112980: LD_INT 112
112982: PUSH
112983: LD_INT 113
112985: PUSH
112986: LD_INT 114
112988: PUSH
112989: LD_INT 116
112991: PUSH
112992: LD_INT 117
112994: PUSH
112995: LD_INT 118
112997: PUSH
112998: EMPTY
112999: LIST
113000: LIST
113001: LIST
113002: LIST
113003: LIST
113004: LIST
113005: LIST
113006: LIST
113007: LIST
113008: LIST
113009: LIST
113010: LIST
113011: LIST
113012: LIST
113013: LIST
113014: LIST
113015: LIST
113016: PUSH
113017: EMPTY
113018: LIST
113019: LIST
113020: ST_TO_ADDR
113021: GO 114028
113023: LD_INT 15
113025: DOUBLE
113026: EQUAL
113027: IFTRUE 113031
113029: GO 113255
113031: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
113032: LD_ADDR_VAR 0 2
113036: PUSH
113037: LD_INT 1
113039: PUSH
113040: LD_INT 2
113042: PUSH
113043: LD_INT 3
113045: PUSH
113046: LD_INT 4
113048: PUSH
113049: LD_INT 5
113051: PUSH
113052: LD_INT 6
113054: PUSH
113055: LD_INT 7
113057: PUSH
113058: LD_INT 8
113060: PUSH
113061: LD_INT 9
113063: PUSH
113064: LD_INT 10
113066: PUSH
113067: LD_INT 11
113069: PUSH
113070: LD_INT 12
113072: PUSH
113073: LD_INT 13
113075: PUSH
113076: LD_INT 14
113078: PUSH
113079: LD_INT 15
113081: PUSH
113082: LD_INT 16
113084: PUSH
113085: LD_INT 17
113087: PUSH
113088: LD_INT 18
113090: PUSH
113091: LD_INT 19
113093: PUSH
113094: LD_INT 20
113096: PUSH
113097: LD_INT 21
113099: PUSH
113100: LD_INT 22
113102: PUSH
113103: LD_INT 23
113105: PUSH
113106: LD_INT 24
113108: PUSH
113109: LD_INT 25
113111: PUSH
113112: LD_INT 26
113114: PUSH
113115: LD_INT 27
113117: PUSH
113118: LD_INT 28
113120: PUSH
113121: LD_INT 29
113123: PUSH
113124: LD_INT 30
113126: PUSH
113127: LD_INT 31
113129: PUSH
113130: LD_INT 32
113132: PUSH
113133: LD_INT 33
113135: PUSH
113136: LD_INT 34
113138: PUSH
113139: LD_INT 36
113141: PUSH
113142: EMPTY
113143: LIST
113144: LIST
113145: LIST
113146: LIST
113147: LIST
113148: LIST
113149: LIST
113150: LIST
113151: LIST
113152: LIST
113153: LIST
113154: LIST
113155: LIST
113156: LIST
113157: LIST
113158: LIST
113159: LIST
113160: LIST
113161: LIST
113162: LIST
113163: LIST
113164: LIST
113165: LIST
113166: LIST
113167: LIST
113168: LIST
113169: LIST
113170: LIST
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: PUSH
113179: LD_INT 101
113181: PUSH
113182: LD_INT 102
113184: PUSH
113185: LD_INT 103
113187: PUSH
113188: LD_INT 104
113190: PUSH
113191: LD_INT 105
113193: PUSH
113194: LD_INT 106
113196: PUSH
113197: LD_INT 107
113199: PUSH
113200: LD_INT 108
113202: PUSH
113203: LD_INT 109
113205: PUSH
113206: LD_INT 110
113208: PUSH
113209: LD_INT 111
113211: PUSH
113212: LD_INT 112
113214: PUSH
113215: LD_INT 113
113217: PUSH
113218: LD_INT 114
113220: PUSH
113221: LD_INT 116
113223: PUSH
113224: LD_INT 117
113226: PUSH
113227: LD_INT 118
113229: PUSH
113230: EMPTY
113231: LIST
113232: LIST
113233: LIST
113234: LIST
113235: LIST
113236: LIST
113237: LIST
113238: LIST
113239: LIST
113240: LIST
113241: LIST
113242: LIST
113243: LIST
113244: LIST
113245: LIST
113246: LIST
113247: LIST
113248: PUSH
113249: EMPTY
113250: LIST
113251: LIST
113252: ST_TO_ADDR
113253: GO 114028
113255: LD_INT 16
113257: DOUBLE
113258: EQUAL
113259: IFTRUE 113263
113261: GO 113399
113263: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
113264: LD_ADDR_VAR 0 2
113268: PUSH
113269: LD_INT 2
113271: PUSH
113272: LD_INT 4
113274: PUSH
113275: LD_INT 5
113277: PUSH
113278: LD_INT 7
113280: PUSH
113281: LD_INT 11
113283: PUSH
113284: LD_INT 12
113286: PUSH
113287: LD_INT 15
113289: PUSH
113290: LD_INT 16
113292: PUSH
113293: LD_INT 20
113295: PUSH
113296: LD_INT 21
113298: PUSH
113299: LD_INT 22
113301: PUSH
113302: LD_INT 23
113304: PUSH
113305: LD_INT 25
113307: PUSH
113308: LD_INT 26
113310: PUSH
113311: LD_INT 30
113313: PUSH
113314: LD_INT 31
113316: PUSH
113317: LD_INT 32
113319: PUSH
113320: LD_INT 33
113322: PUSH
113323: LD_INT 34
113325: PUSH
113326: EMPTY
113327: LIST
113328: LIST
113329: LIST
113330: LIST
113331: LIST
113332: LIST
113333: LIST
113334: LIST
113335: LIST
113336: LIST
113337: LIST
113338: LIST
113339: LIST
113340: LIST
113341: LIST
113342: LIST
113343: LIST
113344: LIST
113345: LIST
113346: PUSH
113347: LD_INT 101
113349: PUSH
113350: LD_INT 102
113352: PUSH
113353: LD_INT 103
113355: PUSH
113356: LD_INT 106
113358: PUSH
113359: LD_INT 108
113361: PUSH
113362: LD_INT 112
113364: PUSH
113365: LD_INT 113
113367: PUSH
113368: LD_INT 114
113370: PUSH
113371: LD_INT 116
113373: PUSH
113374: LD_INT 117
113376: PUSH
113377: LD_INT 118
113379: PUSH
113380: EMPTY
113381: LIST
113382: LIST
113383: LIST
113384: LIST
113385: LIST
113386: LIST
113387: LIST
113388: LIST
113389: LIST
113390: LIST
113391: LIST
113392: PUSH
113393: EMPTY
113394: LIST
113395: LIST
113396: ST_TO_ADDR
113397: GO 114028
113399: LD_INT 17
113401: DOUBLE
113402: EQUAL
113403: IFTRUE 113407
113405: GO 113631
113407: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
113408: LD_ADDR_VAR 0 2
113412: PUSH
113413: LD_INT 1
113415: PUSH
113416: LD_INT 2
113418: PUSH
113419: LD_INT 3
113421: PUSH
113422: LD_INT 4
113424: PUSH
113425: LD_INT 5
113427: PUSH
113428: LD_INT 6
113430: PUSH
113431: LD_INT 7
113433: PUSH
113434: LD_INT 8
113436: PUSH
113437: LD_INT 9
113439: PUSH
113440: LD_INT 10
113442: PUSH
113443: LD_INT 11
113445: PUSH
113446: LD_INT 12
113448: PUSH
113449: LD_INT 13
113451: PUSH
113452: LD_INT 14
113454: PUSH
113455: LD_INT 15
113457: PUSH
113458: LD_INT 16
113460: PUSH
113461: LD_INT 17
113463: PUSH
113464: LD_INT 18
113466: PUSH
113467: LD_INT 19
113469: PUSH
113470: LD_INT 20
113472: PUSH
113473: LD_INT 21
113475: PUSH
113476: LD_INT 22
113478: PUSH
113479: LD_INT 23
113481: PUSH
113482: LD_INT 24
113484: PUSH
113485: LD_INT 25
113487: PUSH
113488: LD_INT 26
113490: PUSH
113491: LD_INT 27
113493: PUSH
113494: LD_INT 28
113496: PUSH
113497: LD_INT 29
113499: PUSH
113500: LD_INT 30
113502: PUSH
113503: LD_INT 31
113505: PUSH
113506: LD_INT 32
113508: PUSH
113509: LD_INT 33
113511: PUSH
113512: LD_INT 34
113514: PUSH
113515: LD_INT 36
113517: PUSH
113518: EMPTY
113519: LIST
113520: LIST
113521: LIST
113522: LIST
113523: LIST
113524: LIST
113525: LIST
113526: LIST
113527: LIST
113528: LIST
113529: LIST
113530: LIST
113531: LIST
113532: LIST
113533: LIST
113534: LIST
113535: LIST
113536: LIST
113537: LIST
113538: LIST
113539: LIST
113540: LIST
113541: LIST
113542: LIST
113543: LIST
113544: LIST
113545: LIST
113546: LIST
113547: LIST
113548: LIST
113549: LIST
113550: LIST
113551: LIST
113552: LIST
113553: LIST
113554: PUSH
113555: LD_INT 101
113557: PUSH
113558: LD_INT 102
113560: PUSH
113561: LD_INT 103
113563: PUSH
113564: LD_INT 104
113566: PUSH
113567: LD_INT 105
113569: PUSH
113570: LD_INT 106
113572: PUSH
113573: LD_INT 107
113575: PUSH
113576: LD_INT 108
113578: PUSH
113579: LD_INT 109
113581: PUSH
113582: LD_INT 110
113584: PUSH
113585: LD_INT 111
113587: PUSH
113588: LD_INT 112
113590: PUSH
113591: LD_INT 113
113593: PUSH
113594: LD_INT 114
113596: PUSH
113597: LD_INT 116
113599: PUSH
113600: LD_INT 117
113602: PUSH
113603: LD_INT 118
113605: PUSH
113606: EMPTY
113607: LIST
113608: LIST
113609: LIST
113610: LIST
113611: LIST
113612: LIST
113613: LIST
113614: LIST
113615: LIST
113616: LIST
113617: LIST
113618: LIST
113619: LIST
113620: LIST
113621: LIST
113622: LIST
113623: LIST
113624: PUSH
113625: EMPTY
113626: LIST
113627: LIST
113628: ST_TO_ADDR
113629: GO 114028
113631: LD_INT 18
113633: DOUBLE
113634: EQUAL
113635: IFTRUE 113639
113637: GO 113787
113639: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
113640: LD_ADDR_VAR 0 2
113644: PUSH
113645: LD_INT 2
113647: PUSH
113648: LD_INT 4
113650: PUSH
113651: LD_INT 5
113653: PUSH
113654: LD_INT 7
113656: PUSH
113657: LD_INT 11
113659: PUSH
113660: LD_INT 12
113662: PUSH
113663: LD_INT 15
113665: PUSH
113666: LD_INT 16
113668: PUSH
113669: LD_INT 20
113671: PUSH
113672: LD_INT 21
113674: PUSH
113675: LD_INT 22
113677: PUSH
113678: LD_INT 23
113680: PUSH
113681: LD_INT 25
113683: PUSH
113684: LD_INT 26
113686: PUSH
113687: LD_INT 30
113689: PUSH
113690: LD_INT 31
113692: PUSH
113693: LD_INT 32
113695: PUSH
113696: LD_INT 33
113698: PUSH
113699: LD_INT 34
113701: PUSH
113702: LD_INT 35
113704: PUSH
113705: LD_INT 36
113707: PUSH
113708: EMPTY
113709: LIST
113710: LIST
113711: LIST
113712: LIST
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: LIST
113719: LIST
113720: LIST
113721: LIST
113722: LIST
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: LIST
113728: LIST
113729: LIST
113730: PUSH
113731: LD_INT 101
113733: PUSH
113734: LD_INT 102
113736: PUSH
113737: LD_INT 103
113739: PUSH
113740: LD_INT 106
113742: PUSH
113743: LD_INT 108
113745: PUSH
113746: LD_INT 112
113748: PUSH
113749: LD_INT 113
113751: PUSH
113752: LD_INT 114
113754: PUSH
113755: LD_INT 115
113757: PUSH
113758: LD_INT 116
113760: PUSH
113761: LD_INT 117
113763: PUSH
113764: LD_INT 118
113766: PUSH
113767: EMPTY
113768: LIST
113769: LIST
113770: LIST
113771: LIST
113772: LIST
113773: LIST
113774: LIST
113775: LIST
113776: LIST
113777: LIST
113778: LIST
113779: LIST
113780: PUSH
113781: EMPTY
113782: LIST
113783: LIST
113784: ST_TO_ADDR
113785: GO 114028
113787: LD_INT 19
113789: DOUBLE
113790: EQUAL
113791: IFTRUE 113795
113793: GO 114027
113795: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113796: LD_ADDR_VAR 0 2
113800: PUSH
113801: LD_INT 1
113803: PUSH
113804: LD_INT 2
113806: PUSH
113807: LD_INT 3
113809: PUSH
113810: LD_INT 4
113812: PUSH
113813: LD_INT 5
113815: PUSH
113816: LD_INT 6
113818: PUSH
113819: LD_INT 7
113821: PUSH
113822: LD_INT 8
113824: PUSH
113825: LD_INT 9
113827: PUSH
113828: LD_INT 10
113830: PUSH
113831: LD_INT 11
113833: PUSH
113834: LD_INT 12
113836: PUSH
113837: LD_INT 13
113839: PUSH
113840: LD_INT 14
113842: PUSH
113843: LD_INT 15
113845: PUSH
113846: LD_INT 16
113848: PUSH
113849: LD_INT 17
113851: PUSH
113852: LD_INT 18
113854: PUSH
113855: LD_INT 19
113857: PUSH
113858: LD_INT 20
113860: PUSH
113861: LD_INT 21
113863: PUSH
113864: LD_INT 22
113866: PUSH
113867: LD_INT 23
113869: PUSH
113870: LD_INT 24
113872: PUSH
113873: LD_INT 25
113875: PUSH
113876: LD_INT 26
113878: PUSH
113879: LD_INT 27
113881: PUSH
113882: LD_INT 28
113884: PUSH
113885: LD_INT 29
113887: PUSH
113888: LD_INT 30
113890: PUSH
113891: LD_INT 31
113893: PUSH
113894: LD_INT 32
113896: PUSH
113897: LD_INT 33
113899: PUSH
113900: LD_INT 34
113902: PUSH
113903: LD_INT 35
113905: PUSH
113906: LD_INT 36
113908: PUSH
113909: EMPTY
113910: LIST
113911: LIST
113912: LIST
113913: LIST
113914: LIST
113915: LIST
113916: LIST
113917: LIST
113918: LIST
113919: LIST
113920: LIST
113921: LIST
113922: LIST
113923: LIST
113924: LIST
113925: LIST
113926: LIST
113927: LIST
113928: LIST
113929: LIST
113930: LIST
113931: LIST
113932: LIST
113933: LIST
113934: LIST
113935: LIST
113936: LIST
113937: LIST
113938: LIST
113939: LIST
113940: LIST
113941: LIST
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: PUSH
113947: LD_INT 101
113949: PUSH
113950: LD_INT 102
113952: PUSH
113953: LD_INT 103
113955: PUSH
113956: LD_INT 104
113958: PUSH
113959: LD_INT 105
113961: PUSH
113962: LD_INT 106
113964: PUSH
113965: LD_INT 107
113967: PUSH
113968: LD_INT 108
113970: PUSH
113971: LD_INT 109
113973: PUSH
113974: LD_INT 110
113976: PUSH
113977: LD_INT 111
113979: PUSH
113980: LD_INT 112
113982: PUSH
113983: LD_INT 113
113985: PUSH
113986: LD_INT 114
113988: PUSH
113989: LD_INT 115
113991: PUSH
113992: LD_INT 116
113994: PUSH
113995: LD_INT 117
113997: PUSH
113998: LD_INT 118
114000: PUSH
114001: EMPTY
114002: LIST
114003: LIST
114004: LIST
114005: LIST
114006: LIST
114007: LIST
114008: LIST
114009: LIST
114010: LIST
114011: LIST
114012: LIST
114013: LIST
114014: LIST
114015: LIST
114016: LIST
114017: LIST
114018: LIST
114019: LIST
114020: PUSH
114021: EMPTY
114022: LIST
114023: LIST
114024: ST_TO_ADDR
114025: GO 114028
114027: POP
// end else
114028: GO 114259
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
114030: LD_ADDR_VAR 0 2
114034: PUSH
114035: LD_INT 1
114037: PUSH
114038: LD_INT 2
114040: PUSH
114041: LD_INT 3
114043: PUSH
114044: LD_INT 4
114046: PUSH
114047: LD_INT 5
114049: PUSH
114050: LD_INT 6
114052: PUSH
114053: LD_INT 7
114055: PUSH
114056: LD_INT 8
114058: PUSH
114059: LD_INT 9
114061: PUSH
114062: LD_INT 10
114064: PUSH
114065: LD_INT 11
114067: PUSH
114068: LD_INT 12
114070: PUSH
114071: LD_INT 13
114073: PUSH
114074: LD_INT 14
114076: PUSH
114077: LD_INT 15
114079: PUSH
114080: LD_INT 16
114082: PUSH
114083: LD_INT 17
114085: PUSH
114086: LD_INT 18
114088: PUSH
114089: LD_INT 19
114091: PUSH
114092: LD_INT 20
114094: PUSH
114095: LD_INT 21
114097: PUSH
114098: LD_INT 22
114100: PUSH
114101: LD_INT 23
114103: PUSH
114104: LD_INT 24
114106: PUSH
114107: LD_INT 25
114109: PUSH
114110: LD_INT 26
114112: PUSH
114113: LD_INT 27
114115: PUSH
114116: LD_INT 28
114118: PUSH
114119: LD_INT 29
114121: PUSH
114122: LD_INT 30
114124: PUSH
114125: LD_INT 31
114127: PUSH
114128: LD_INT 32
114130: PUSH
114131: LD_INT 33
114133: PUSH
114134: LD_INT 34
114136: PUSH
114137: LD_INT 35
114139: PUSH
114140: LD_INT 36
114142: PUSH
114143: EMPTY
114144: LIST
114145: LIST
114146: LIST
114147: LIST
114148: LIST
114149: LIST
114150: LIST
114151: LIST
114152: LIST
114153: LIST
114154: LIST
114155: LIST
114156: LIST
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: LIST
114170: LIST
114171: LIST
114172: LIST
114173: LIST
114174: LIST
114175: LIST
114176: LIST
114177: LIST
114178: LIST
114179: LIST
114180: PUSH
114181: LD_INT 101
114183: PUSH
114184: LD_INT 102
114186: PUSH
114187: LD_INT 103
114189: PUSH
114190: LD_INT 104
114192: PUSH
114193: LD_INT 105
114195: PUSH
114196: LD_INT 106
114198: PUSH
114199: LD_INT 107
114201: PUSH
114202: LD_INT 108
114204: PUSH
114205: LD_INT 109
114207: PUSH
114208: LD_INT 110
114210: PUSH
114211: LD_INT 111
114213: PUSH
114214: LD_INT 112
114216: PUSH
114217: LD_INT 113
114219: PUSH
114220: LD_INT 114
114222: PUSH
114223: LD_INT 115
114225: PUSH
114226: LD_INT 116
114228: PUSH
114229: LD_INT 117
114231: PUSH
114232: LD_INT 118
114234: PUSH
114235: EMPTY
114236: LIST
114237: LIST
114238: LIST
114239: LIST
114240: LIST
114241: LIST
114242: LIST
114243: LIST
114244: LIST
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: LIST
114250: LIST
114251: LIST
114252: LIST
114253: LIST
114254: PUSH
114255: EMPTY
114256: LIST
114257: LIST
114258: ST_TO_ADDR
// if result then
114259: LD_VAR 0 2
114263: IFFALSE 115049
// begin normal :=  ;
114265: LD_ADDR_VAR 0 5
114269: PUSH
114270: LD_STRING 
114272: ST_TO_ADDR
// hardcore :=  ;
114273: LD_ADDR_VAR 0 6
114277: PUSH
114278: LD_STRING 
114280: ST_TO_ADDR
// active :=  ;
114281: LD_ADDR_VAR 0 7
114285: PUSH
114286: LD_STRING 
114288: ST_TO_ADDR
// for i = 1 to normalCounter do
114289: LD_ADDR_VAR 0 8
114293: PUSH
114294: DOUBLE
114295: LD_INT 1
114297: DEC
114298: ST_TO_ADDR
114299: LD_EXP 147
114303: PUSH
114304: FOR_TO
114305: IFFALSE 114406
// begin tmp := 0 ;
114307: LD_ADDR_VAR 0 3
114311: PUSH
114312: LD_STRING 0
114314: ST_TO_ADDR
// if result [ 1 ] then
114315: LD_VAR 0 2
114319: PUSH
114320: LD_INT 1
114322: ARRAY
114323: IFFALSE 114388
// if result [ 1 ] [ 1 ] = i then
114325: LD_VAR 0 2
114329: PUSH
114330: LD_INT 1
114332: ARRAY
114333: PUSH
114334: LD_INT 1
114336: ARRAY
114337: PUSH
114338: LD_VAR 0 8
114342: EQUAL
114343: IFFALSE 114388
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
114345: LD_ADDR_VAR 0 2
114349: PUSH
114350: LD_VAR 0 2
114354: PPUSH
114355: LD_INT 1
114357: PPUSH
114358: LD_VAR 0 2
114362: PUSH
114363: LD_INT 1
114365: ARRAY
114366: PPUSH
114367: LD_INT 1
114369: PPUSH
114370: CALL_OW 3
114374: PPUSH
114375: CALL_OW 1
114379: ST_TO_ADDR
// tmp := 1 ;
114380: LD_ADDR_VAR 0 3
114384: PUSH
114385: LD_STRING 1
114387: ST_TO_ADDR
// end ; normal := normal & tmp ;
114388: LD_ADDR_VAR 0 5
114392: PUSH
114393: LD_VAR 0 5
114397: PUSH
114398: LD_VAR 0 3
114402: STR
114403: ST_TO_ADDR
// end ;
114404: GO 114304
114406: POP
114407: POP
// for i = 1 to hardcoreCounter do
114408: LD_ADDR_VAR 0 8
114412: PUSH
114413: DOUBLE
114414: LD_INT 1
114416: DEC
114417: ST_TO_ADDR
114418: LD_EXP 148
114422: PUSH
114423: FOR_TO
114424: IFFALSE 114529
// begin tmp := 0 ;
114426: LD_ADDR_VAR 0 3
114430: PUSH
114431: LD_STRING 0
114433: ST_TO_ADDR
// if result [ 2 ] then
114434: LD_VAR 0 2
114438: PUSH
114439: LD_INT 2
114441: ARRAY
114442: IFFALSE 114511
// if result [ 2 ] [ 1 ] = 100 + i then
114444: LD_VAR 0 2
114448: PUSH
114449: LD_INT 2
114451: ARRAY
114452: PUSH
114453: LD_INT 1
114455: ARRAY
114456: PUSH
114457: LD_INT 100
114459: PUSH
114460: LD_VAR 0 8
114464: PLUS
114465: EQUAL
114466: IFFALSE 114511
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
114468: LD_ADDR_VAR 0 2
114472: PUSH
114473: LD_VAR 0 2
114477: PPUSH
114478: LD_INT 2
114480: PPUSH
114481: LD_VAR 0 2
114485: PUSH
114486: LD_INT 2
114488: ARRAY
114489: PPUSH
114490: LD_INT 1
114492: PPUSH
114493: CALL_OW 3
114497: PPUSH
114498: CALL_OW 1
114502: ST_TO_ADDR
// tmp := 1 ;
114503: LD_ADDR_VAR 0 3
114507: PUSH
114508: LD_STRING 1
114510: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
114511: LD_ADDR_VAR 0 6
114515: PUSH
114516: LD_VAR 0 6
114520: PUSH
114521: LD_VAR 0 3
114525: STR
114526: ST_TO_ADDR
// end ;
114527: GO 114423
114529: POP
114530: POP
// if isGameLoad then
114531: LD_VAR 0 1
114535: IFFALSE 115010
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
114537: LD_ADDR_VAR 0 4
114541: PUSH
114542: LD_EXP 151
114546: PUSH
114547: LD_EXP 150
114551: PUSH
114552: LD_EXP 152
114556: PUSH
114557: LD_EXP 149
114561: PUSH
114562: LD_EXP 153
114566: PUSH
114567: LD_EXP 154
114571: PUSH
114572: LD_EXP 155
114576: PUSH
114577: LD_EXP 156
114581: PUSH
114582: LD_EXP 157
114586: PUSH
114587: LD_EXP 158
114591: PUSH
114592: LD_EXP 159
114596: PUSH
114597: LD_EXP 160
114601: PUSH
114602: LD_EXP 161
114606: PUSH
114607: LD_EXP 162
114611: PUSH
114612: LD_EXP 170
114616: PUSH
114617: LD_EXP 171
114621: PUSH
114622: LD_EXP 172
114626: PUSH
114627: LD_EXP 173
114631: PUSH
114632: LD_EXP 175
114636: PUSH
114637: LD_EXP 176
114641: PUSH
114642: LD_EXP 177
114646: PUSH
114647: LD_EXP 180
114651: PUSH
114652: LD_EXP 182
114656: PUSH
114657: LD_EXP 183
114661: PUSH
114662: LD_EXP 184
114666: PUSH
114667: LD_EXP 186
114671: PUSH
114672: LD_EXP 187
114676: PUSH
114677: LD_EXP 190
114681: PUSH
114682: LD_EXP 191
114686: PUSH
114687: LD_EXP 192
114691: PUSH
114692: LD_EXP 193
114696: PUSH
114697: LD_EXP 194
114701: PUSH
114702: LD_EXP 195
114706: PUSH
114707: LD_EXP 196
114711: PUSH
114712: LD_EXP 197
114716: PUSH
114717: LD_EXP 198
114721: PUSH
114722: LD_EXP 163
114726: PUSH
114727: LD_EXP 164
114731: PUSH
114732: LD_EXP 167
114736: PUSH
114737: LD_EXP 168
114741: PUSH
114742: LD_EXP 169
114746: PUSH
114747: LD_EXP 165
114751: PUSH
114752: LD_EXP 166
114756: PUSH
114757: LD_EXP 174
114761: PUSH
114762: LD_EXP 178
114766: PUSH
114767: LD_EXP 179
114771: PUSH
114772: LD_EXP 181
114776: PUSH
114777: LD_EXP 185
114781: PUSH
114782: LD_EXP 188
114786: PUSH
114787: LD_EXP 189
114791: PUSH
114792: LD_EXP 199
114796: PUSH
114797: LD_EXP 200
114801: PUSH
114802: LD_EXP 201
114806: PUSH
114807: LD_EXP 202
114811: PUSH
114812: EMPTY
114813: LIST
114814: LIST
114815: LIST
114816: LIST
114817: LIST
114818: LIST
114819: LIST
114820: LIST
114821: LIST
114822: LIST
114823: LIST
114824: LIST
114825: LIST
114826: LIST
114827: LIST
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: LIST
114834: LIST
114835: LIST
114836: LIST
114837: LIST
114838: LIST
114839: LIST
114840: LIST
114841: LIST
114842: LIST
114843: LIST
114844: LIST
114845: LIST
114846: LIST
114847: LIST
114848: LIST
114849: LIST
114850: LIST
114851: LIST
114852: LIST
114853: LIST
114854: LIST
114855: LIST
114856: LIST
114857: LIST
114858: LIST
114859: LIST
114860: LIST
114861: LIST
114862: LIST
114863: LIST
114864: LIST
114865: LIST
114866: LIST
114867: ST_TO_ADDR
// tmp :=  ;
114868: LD_ADDR_VAR 0 3
114872: PUSH
114873: LD_STRING 
114875: ST_TO_ADDR
// for i = 1 to normalCounter do
114876: LD_ADDR_VAR 0 8
114880: PUSH
114881: DOUBLE
114882: LD_INT 1
114884: DEC
114885: ST_TO_ADDR
114886: LD_EXP 147
114890: PUSH
114891: FOR_TO
114892: IFFALSE 114928
// begin if flags [ i ] then
114894: LD_VAR 0 4
114898: PUSH
114899: LD_VAR 0 8
114903: ARRAY
114904: IFFALSE 114926
// tmp := tmp & i & ; ;
114906: LD_ADDR_VAR 0 3
114910: PUSH
114911: LD_VAR 0 3
114915: PUSH
114916: LD_VAR 0 8
114920: STR
114921: PUSH
114922: LD_STRING ;
114924: STR
114925: ST_TO_ADDR
// end ;
114926: GO 114891
114928: POP
114929: POP
// for i = 1 to hardcoreCounter do
114930: LD_ADDR_VAR 0 8
114934: PUSH
114935: DOUBLE
114936: LD_INT 1
114938: DEC
114939: ST_TO_ADDR
114940: LD_EXP 148
114944: PUSH
114945: FOR_TO
114946: IFFALSE 114992
// begin if flags [ normalCounter + i ] then
114948: LD_VAR 0 4
114952: PUSH
114953: LD_EXP 147
114957: PUSH
114958: LD_VAR 0 8
114962: PLUS
114963: ARRAY
114964: IFFALSE 114990
// tmp := tmp & ( 100 + i ) & ; ;
114966: LD_ADDR_VAR 0 3
114970: PUSH
114971: LD_VAR 0 3
114975: PUSH
114976: LD_INT 100
114978: PUSH
114979: LD_VAR 0 8
114983: PLUS
114984: STR
114985: PUSH
114986: LD_STRING ;
114988: STR
114989: ST_TO_ADDR
// end ;
114990: GO 114945
114992: POP
114993: POP
// if tmp then
114994: LD_VAR 0 3
114998: IFFALSE 115010
// active := tmp ;
115000: LD_ADDR_VAR 0 7
115004: PUSH
115005: LD_VAR 0 3
115009: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
115010: LD_STRING getStreamItemsFromMission("
115012: PUSH
115013: LD_VAR 0 5
115017: STR
115018: PUSH
115019: LD_STRING ","
115021: STR
115022: PUSH
115023: LD_VAR 0 6
115027: STR
115028: PUSH
115029: LD_STRING ","
115031: STR
115032: PUSH
115033: LD_VAR 0 7
115037: STR
115038: PUSH
115039: LD_STRING ")
115041: STR
115042: PPUSH
115043: CALL_OW 559
// end else
115047: GO 115056
// ToLua ( getStreamItemsFromMission("","","") ) ;
115049: LD_STRING getStreamItemsFromMission("","","")
115051: PPUSH
115052: CALL_OW 559
// end ;
115056: LD_VAR 0 2
115060: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
115061: LD_EXP 146
115065: PUSH
115066: LD_EXP 151
115070: AND
115071: IFFALSE 115195
115073: GO 115075
115075: DISABLE
115076: LD_INT 0
115078: PPUSH
115079: PPUSH
// begin enable ;
115080: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
115081: LD_ADDR_VAR 0 2
115085: PUSH
115086: LD_INT 22
115088: PUSH
115089: LD_OWVAR 2
115093: PUSH
115094: EMPTY
115095: LIST
115096: LIST
115097: PUSH
115098: LD_INT 2
115100: PUSH
115101: LD_INT 34
115103: PUSH
115104: LD_INT 7
115106: PUSH
115107: EMPTY
115108: LIST
115109: LIST
115110: PUSH
115111: LD_INT 34
115113: PUSH
115114: LD_INT 45
115116: PUSH
115117: EMPTY
115118: LIST
115119: LIST
115120: PUSH
115121: LD_INT 34
115123: PUSH
115124: LD_INT 28
115126: PUSH
115127: EMPTY
115128: LIST
115129: LIST
115130: PUSH
115131: LD_INT 34
115133: PUSH
115134: LD_INT 47
115136: PUSH
115137: EMPTY
115138: LIST
115139: LIST
115140: PUSH
115141: EMPTY
115142: LIST
115143: LIST
115144: LIST
115145: LIST
115146: LIST
115147: PUSH
115148: EMPTY
115149: LIST
115150: LIST
115151: PPUSH
115152: CALL_OW 69
115156: ST_TO_ADDR
// if not tmp then
115157: LD_VAR 0 2
115161: NOT
115162: IFFALSE 115166
// exit ;
115164: GO 115195
// for i in tmp do
115166: LD_ADDR_VAR 0 1
115170: PUSH
115171: LD_VAR 0 2
115175: PUSH
115176: FOR_IN
115177: IFFALSE 115193
// begin SetLives ( i , 0 ) ;
115179: LD_VAR 0 1
115183: PPUSH
115184: LD_INT 0
115186: PPUSH
115187: CALL_OW 234
// end ;
115191: GO 115176
115193: POP
115194: POP
// end ;
115195: PPOPN 2
115197: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
115198: LD_EXP 146
115202: PUSH
115203: LD_EXP 152
115207: AND
115208: IFFALSE 115292
115210: GO 115212
115212: DISABLE
115213: LD_INT 0
115215: PPUSH
115216: PPUSH
// begin enable ;
115217: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
115218: LD_ADDR_VAR 0 2
115222: PUSH
115223: LD_INT 22
115225: PUSH
115226: LD_OWVAR 2
115230: PUSH
115231: EMPTY
115232: LIST
115233: LIST
115234: PUSH
115235: LD_INT 32
115237: PUSH
115238: LD_INT 3
115240: PUSH
115241: EMPTY
115242: LIST
115243: LIST
115244: PUSH
115245: EMPTY
115246: LIST
115247: LIST
115248: PPUSH
115249: CALL_OW 69
115253: ST_TO_ADDR
// if not tmp then
115254: LD_VAR 0 2
115258: NOT
115259: IFFALSE 115263
// exit ;
115261: GO 115292
// for i in tmp do
115263: LD_ADDR_VAR 0 1
115267: PUSH
115268: LD_VAR 0 2
115272: PUSH
115273: FOR_IN
115274: IFFALSE 115290
// begin SetLives ( i , 0 ) ;
115276: LD_VAR 0 1
115280: PPUSH
115281: LD_INT 0
115283: PPUSH
115284: CALL_OW 234
// end ;
115288: GO 115273
115290: POP
115291: POP
// end ;
115292: PPOPN 2
115294: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
115295: LD_EXP 146
115299: PUSH
115300: LD_EXP 149
115304: AND
115305: IFFALSE 115398
115307: GO 115309
115309: DISABLE
115310: LD_INT 0
115312: PPUSH
// begin enable ;
115313: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
115314: LD_ADDR_VAR 0 1
115318: PUSH
115319: LD_INT 22
115321: PUSH
115322: LD_OWVAR 2
115326: PUSH
115327: EMPTY
115328: LIST
115329: LIST
115330: PUSH
115331: LD_INT 2
115333: PUSH
115334: LD_INT 25
115336: PUSH
115337: LD_INT 5
115339: PUSH
115340: EMPTY
115341: LIST
115342: LIST
115343: PUSH
115344: LD_INT 25
115346: PUSH
115347: LD_INT 9
115349: PUSH
115350: EMPTY
115351: LIST
115352: LIST
115353: PUSH
115354: LD_INT 25
115356: PUSH
115357: LD_INT 8
115359: PUSH
115360: EMPTY
115361: LIST
115362: LIST
115363: PUSH
115364: EMPTY
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: PUSH
115370: EMPTY
115371: LIST
115372: LIST
115373: PPUSH
115374: CALL_OW 69
115378: PUSH
115379: FOR_IN
115380: IFFALSE 115396
// begin SetClass ( i , 1 ) ;
115382: LD_VAR 0 1
115386: PPUSH
115387: LD_INT 1
115389: PPUSH
115390: CALL_OW 336
// end ;
115394: GO 115379
115396: POP
115397: POP
// end ;
115398: PPOPN 1
115400: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
115401: LD_EXP 146
115405: PUSH
115406: LD_EXP 150
115410: AND
115411: PUSH
115412: LD_OWVAR 65
115416: PUSH
115417: LD_INT 7
115419: LESS
115420: AND
115421: IFFALSE 115435
115423: GO 115425
115425: DISABLE
// begin enable ;
115426: ENABLE
// game_speed := 7 ;
115427: LD_ADDR_OWVAR 65
115431: PUSH
115432: LD_INT 7
115434: ST_TO_ADDR
// end ;
115435: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
115436: LD_EXP 146
115440: PUSH
115441: LD_EXP 153
115445: AND
115446: IFFALSE 115648
115448: GO 115450
115450: DISABLE
115451: LD_INT 0
115453: PPUSH
115454: PPUSH
115455: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
115456: LD_ADDR_VAR 0 3
115460: PUSH
115461: LD_INT 81
115463: PUSH
115464: LD_OWVAR 2
115468: PUSH
115469: EMPTY
115470: LIST
115471: LIST
115472: PUSH
115473: LD_INT 21
115475: PUSH
115476: LD_INT 1
115478: PUSH
115479: EMPTY
115480: LIST
115481: LIST
115482: PUSH
115483: EMPTY
115484: LIST
115485: LIST
115486: PPUSH
115487: CALL_OW 69
115491: ST_TO_ADDR
// if not tmp then
115492: LD_VAR 0 3
115496: NOT
115497: IFFALSE 115501
// exit ;
115499: GO 115648
// if tmp > 5 then
115501: LD_VAR 0 3
115505: PUSH
115506: LD_INT 5
115508: GREATER
115509: IFFALSE 115521
// k := 5 else
115511: LD_ADDR_VAR 0 2
115515: PUSH
115516: LD_INT 5
115518: ST_TO_ADDR
115519: GO 115531
// k := tmp ;
115521: LD_ADDR_VAR 0 2
115525: PUSH
115526: LD_VAR 0 3
115530: ST_TO_ADDR
// for i := 1 to k do
115531: LD_ADDR_VAR 0 1
115535: PUSH
115536: DOUBLE
115537: LD_INT 1
115539: DEC
115540: ST_TO_ADDR
115541: LD_VAR 0 2
115545: PUSH
115546: FOR_TO
115547: IFFALSE 115646
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
115549: LD_VAR 0 3
115553: PUSH
115554: LD_VAR 0 1
115558: ARRAY
115559: PPUSH
115560: LD_VAR 0 1
115564: PUSH
115565: LD_INT 4
115567: MOD
115568: PUSH
115569: LD_INT 1
115571: PLUS
115572: PPUSH
115573: CALL_OW 259
115577: PUSH
115578: LD_INT 10
115580: LESS
115581: IFFALSE 115644
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
115583: LD_VAR 0 3
115587: PUSH
115588: LD_VAR 0 1
115592: ARRAY
115593: PPUSH
115594: LD_VAR 0 1
115598: PUSH
115599: LD_INT 4
115601: MOD
115602: PUSH
115603: LD_INT 1
115605: PLUS
115606: PPUSH
115607: LD_VAR 0 3
115611: PUSH
115612: LD_VAR 0 1
115616: ARRAY
115617: PPUSH
115618: LD_VAR 0 1
115622: PUSH
115623: LD_INT 4
115625: MOD
115626: PUSH
115627: LD_INT 1
115629: PLUS
115630: PPUSH
115631: CALL_OW 259
115635: PUSH
115636: LD_INT 1
115638: PLUS
115639: PPUSH
115640: CALL_OW 237
115644: GO 115546
115646: POP
115647: POP
// end ;
115648: PPOPN 3
115650: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
115651: LD_EXP 146
115655: PUSH
115656: LD_EXP 154
115660: AND
115661: IFFALSE 115681
115663: GO 115665
115665: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
115666: LD_INT 4
115668: PPUSH
115669: LD_OWVAR 2
115673: PPUSH
115674: LD_INT 0
115676: PPUSH
115677: CALL_OW 324
115681: END
// every 0 0$1 trigger StreamModeActive and sShovel do
115682: LD_EXP 146
115686: PUSH
115687: LD_EXP 183
115691: AND
115692: IFFALSE 115712
115694: GO 115696
115696: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115697: LD_INT 19
115699: PPUSH
115700: LD_OWVAR 2
115704: PPUSH
115705: LD_INT 0
115707: PPUSH
115708: CALL_OW 324
115712: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115713: LD_EXP 146
115717: PUSH
115718: LD_EXP 155
115722: AND
115723: IFFALSE 115825
115725: GO 115727
115727: DISABLE
115728: LD_INT 0
115730: PPUSH
115731: PPUSH
// begin enable ;
115732: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115733: LD_ADDR_VAR 0 2
115737: PUSH
115738: LD_INT 22
115740: PUSH
115741: LD_OWVAR 2
115745: PUSH
115746: EMPTY
115747: LIST
115748: LIST
115749: PUSH
115750: LD_INT 2
115752: PUSH
115753: LD_INT 34
115755: PUSH
115756: LD_INT 11
115758: PUSH
115759: EMPTY
115760: LIST
115761: LIST
115762: PUSH
115763: LD_INT 34
115765: PUSH
115766: LD_INT 30
115768: PUSH
115769: EMPTY
115770: LIST
115771: LIST
115772: PUSH
115773: EMPTY
115774: LIST
115775: LIST
115776: LIST
115777: PUSH
115778: EMPTY
115779: LIST
115780: LIST
115781: PPUSH
115782: CALL_OW 69
115786: ST_TO_ADDR
// if not tmp then
115787: LD_VAR 0 2
115791: NOT
115792: IFFALSE 115796
// exit ;
115794: GO 115825
// for i in tmp do
115796: LD_ADDR_VAR 0 1
115800: PUSH
115801: LD_VAR 0 2
115805: PUSH
115806: FOR_IN
115807: IFFALSE 115823
// begin SetLives ( i , 0 ) ;
115809: LD_VAR 0 1
115813: PPUSH
115814: LD_INT 0
115816: PPUSH
115817: CALL_OW 234
// end ;
115821: GO 115806
115823: POP
115824: POP
// end ;
115825: PPOPN 2
115827: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115828: LD_EXP 146
115832: PUSH
115833: LD_EXP 156
115837: AND
115838: IFFALSE 115858
115840: GO 115842
115842: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115843: LD_INT 32
115845: PPUSH
115846: LD_OWVAR 2
115850: PPUSH
115851: LD_INT 0
115853: PPUSH
115854: CALL_OW 324
115858: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115859: LD_EXP 146
115863: PUSH
115864: LD_EXP 157
115868: AND
115869: IFFALSE 116050
115871: GO 115873
115873: DISABLE
115874: LD_INT 0
115876: PPUSH
115877: PPUSH
115878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115879: LD_ADDR_VAR 0 2
115883: PUSH
115884: LD_INT 22
115886: PUSH
115887: LD_OWVAR 2
115891: PUSH
115892: EMPTY
115893: LIST
115894: LIST
115895: PUSH
115896: LD_INT 33
115898: PUSH
115899: LD_INT 3
115901: PUSH
115902: EMPTY
115903: LIST
115904: LIST
115905: PUSH
115906: EMPTY
115907: LIST
115908: LIST
115909: PPUSH
115910: CALL_OW 69
115914: ST_TO_ADDR
// if not tmp then
115915: LD_VAR 0 2
115919: NOT
115920: IFFALSE 115924
// exit ;
115922: GO 116050
// side := 0 ;
115924: LD_ADDR_VAR 0 3
115928: PUSH
115929: LD_INT 0
115931: ST_TO_ADDR
// for i := 1 to 8 do
115932: LD_ADDR_VAR 0 1
115936: PUSH
115937: DOUBLE
115938: LD_INT 1
115940: DEC
115941: ST_TO_ADDR
115942: LD_INT 8
115944: PUSH
115945: FOR_TO
115946: IFFALSE 115994
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115948: LD_OWVAR 2
115952: PUSH
115953: LD_VAR 0 1
115957: NONEQUAL
115958: PUSH
115959: LD_OWVAR 2
115963: PPUSH
115964: LD_VAR 0 1
115968: PPUSH
115969: CALL_OW 81
115973: PUSH
115974: LD_INT 2
115976: EQUAL
115977: AND
115978: IFFALSE 115992
// begin side := i ;
115980: LD_ADDR_VAR 0 3
115984: PUSH
115985: LD_VAR 0 1
115989: ST_TO_ADDR
// break ;
115990: GO 115994
// end ;
115992: GO 115945
115994: POP
115995: POP
// if not side then
115996: LD_VAR 0 3
116000: NOT
116001: IFFALSE 116005
// exit ;
116003: GO 116050
// for i := 1 to tmp do
116005: LD_ADDR_VAR 0 1
116009: PUSH
116010: DOUBLE
116011: LD_INT 1
116013: DEC
116014: ST_TO_ADDR
116015: LD_VAR 0 2
116019: PUSH
116020: FOR_TO
116021: IFFALSE 116048
// if Prob ( 60 ) then
116023: LD_INT 60
116025: PPUSH
116026: CALL_OW 13
116030: IFFALSE 116046
// SetSide ( i , side ) ;
116032: LD_VAR 0 1
116036: PPUSH
116037: LD_VAR 0 3
116041: PPUSH
116042: CALL_OW 235
116046: GO 116020
116048: POP
116049: POP
// end ;
116050: PPOPN 3
116052: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
116053: LD_EXP 146
116057: PUSH
116058: LD_EXP 159
116062: AND
116063: IFFALSE 116182
116065: GO 116067
116067: DISABLE
116068: LD_INT 0
116070: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
116071: LD_ADDR_VAR 0 1
116075: PUSH
116076: LD_INT 22
116078: PUSH
116079: LD_OWVAR 2
116083: PUSH
116084: EMPTY
116085: LIST
116086: LIST
116087: PUSH
116088: LD_INT 21
116090: PUSH
116091: LD_INT 1
116093: PUSH
116094: EMPTY
116095: LIST
116096: LIST
116097: PUSH
116098: LD_INT 3
116100: PUSH
116101: LD_INT 23
116103: PUSH
116104: LD_INT 0
116106: PUSH
116107: EMPTY
116108: LIST
116109: LIST
116110: PUSH
116111: EMPTY
116112: LIST
116113: LIST
116114: PUSH
116115: EMPTY
116116: LIST
116117: LIST
116118: LIST
116119: PPUSH
116120: CALL_OW 69
116124: PUSH
116125: FOR_IN
116126: IFFALSE 116180
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
116128: LD_VAR 0 1
116132: PPUSH
116133: CALL_OW 257
116137: PUSH
116138: LD_INT 1
116140: PUSH
116141: LD_INT 2
116143: PUSH
116144: LD_INT 3
116146: PUSH
116147: LD_INT 4
116149: PUSH
116150: EMPTY
116151: LIST
116152: LIST
116153: LIST
116154: LIST
116155: IN
116156: IFFALSE 116178
// SetClass ( un , rand ( 1 , 4 ) ) ;
116158: LD_VAR 0 1
116162: PPUSH
116163: LD_INT 1
116165: PPUSH
116166: LD_INT 4
116168: PPUSH
116169: CALL_OW 12
116173: PPUSH
116174: CALL_OW 336
116178: GO 116125
116180: POP
116181: POP
// end ;
116182: PPOPN 1
116184: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
116185: LD_EXP 146
116189: PUSH
116190: LD_EXP 158
116194: AND
116195: IFFALSE 116274
116197: GO 116199
116199: DISABLE
116200: LD_INT 0
116202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116203: LD_ADDR_VAR 0 1
116207: PUSH
116208: LD_INT 22
116210: PUSH
116211: LD_OWVAR 2
116215: PUSH
116216: EMPTY
116217: LIST
116218: LIST
116219: PUSH
116220: LD_INT 21
116222: PUSH
116223: LD_INT 3
116225: PUSH
116226: EMPTY
116227: LIST
116228: LIST
116229: PUSH
116230: EMPTY
116231: LIST
116232: LIST
116233: PPUSH
116234: CALL_OW 69
116238: ST_TO_ADDR
// if not tmp then
116239: LD_VAR 0 1
116243: NOT
116244: IFFALSE 116248
// exit ;
116246: GO 116274
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
116248: LD_VAR 0 1
116252: PUSH
116253: LD_INT 1
116255: PPUSH
116256: LD_VAR 0 1
116260: PPUSH
116261: CALL_OW 12
116265: ARRAY
116266: PPUSH
116267: LD_INT 100
116269: PPUSH
116270: CALL_OW 234
// end ;
116274: PPOPN 1
116276: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
116277: LD_EXP 146
116281: PUSH
116282: LD_EXP 160
116286: AND
116287: IFFALSE 116385
116289: GO 116291
116291: DISABLE
116292: LD_INT 0
116294: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116295: LD_ADDR_VAR 0 1
116299: PUSH
116300: LD_INT 22
116302: PUSH
116303: LD_OWVAR 2
116307: PUSH
116308: EMPTY
116309: LIST
116310: LIST
116311: PUSH
116312: LD_INT 21
116314: PUSH
116315: LD_INT 1
116317: PUSH
116318: EMPTY
116319: LIST
116320: LIST
116321: PUSH
116322: EMPTY
116323: LIST
116324: LIST
116325: PPUSH
116326: CALL_OW 69
116330: ST_TO_ADDR
// if not tmp then
116331: LD_VAR 0 1
116335: NOT
116336: IFFALSE 116340
// exit ;
116338: GO 116385
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
116340: LD_VAR 0 1
116344: PUSH
116345: LD_INT 1
116347: PPUSH
116348: LD_VAR 0 1
116352: PPUSH
116353: CALL_OW 12
116357: ARRAY
116358: PPUSH
116359: LD_INT 1
116361: PPUSH
116362: LD_INT 4
116364: PPUSH
116365: CALL_OW 12
116369: PPUSH
116370: LD_INT 3000
116372: PPUSH
116373: LD_INT 9000
116375: PPUSH
116376: CALL_OW 12
116380: PPUSH
116381: CALL_OW 492
// end ;
116385: PPOPN 1
116387: END
// every 0 0$1 trigger StreamModeActive and sDepot do
116388: LD_EXP 146
116392: PUSH
116393: LD_EXP 161
116397: AND
116398: IFFALSE 116418
116400: GO 116402
116402: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
116403: LD_INT 1
116405: PPUSH
116406: LD_OWVAR 2
116410: PPUSH
116411: LD_INT 0
116413: PPUSH
116414: CALL_OW 324
116418: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
116419: LD_EXP 146
116423: PUSH
116424: LD_EXP 162
116428: AND
116429: IFFALSE 116512
116431: GO 116433
116433: DISABLE
116434: LD_INT 0
116436: PPUSH
116437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
116438: LD_ADDR_VAR 0 2
116442: PUSH
116443: LD_INT 22
116445: PUSH
116446: LD_OWVAR 2
116450: PUSH
116451: EMPTY
116452: LIST
116453: LIST
116454: PUSH
116455: LD_INT 21
116457: PUSH
116458: LD_INT 3
116460: PUSH
116461: EMPTY
116462: LIST
116463: LIST
116464: PUSH
116465: EMPTY
116466: LIST
116467: LIST
116468: PPUSH
116469: CALL_OW 69
116473: ST_TO_ADDR
// if not tmp then
116474: LD_VAR 0 2
116478: NOT
116479: IFFALSE 116483
// exit ;
116481: GO 116512
// for i in tmp do
116483: LD_ADDR_VAR 0 1
116487: PUSH
116488: LD_VAR 0 2
116492: PUSH
116493: FOR_IN
116494: IFFALSE 116510
// SetBLevel ( i , 10 ) ;
116496: LD_VAR 0 1
116500: PPUSH
116501: LD_INT 10
116503: PPUSH
116504: CALL_OW 241
116508: GO 116493
116510: POP
116511: POP
// end ;
116512: PPOPN 2
116514: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
116515: LD_EXP 146
116519: PUSH
116520: LD_EXP 163
116524: AND
116525: IFFALSE 116636
116527: GO 116529
116529: DISABLE
116530: LD_INT 0
116532: PPUSH
116533: PPUSH
116534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116535: LD_ADDR_VAR 0 3
116539: PUSH
116540: LD_INT 22
116542: PUSH
116543: LD_OWVAR 2
116547: PUSH
116548: EMPTY
116549: LIST
116550: LIST
116551: PUSH
116552: LD_INT 25
116554: PUSH
116555: LD_INT 1
116557: PUSH
116558: EMPTY
116559: LIST
116560: LIST
116561: PUSH
116562: EMPTY
116563: LIST
116564: LIST
116565: PPUSH
116566: CALL_OW 69
116570: ST_TO_ADDR
// if not tmp then
116571: LD_VAR 0 3
116575: NOT
116576: IFFALSE 116580
// exit ;
116578: GO 116636
// un := tmp [ rand ( 1 , tmp ) ] ;
116580: LD_ADDR_VAR 0 2
116584: PUSH
116585: LD_VAR 0 3
116589: PUSH
116590: LD_INT 1
116592: PPUSH
116593: LD_VAR 0 3
116597: PPUSH
116598: CALL_OW 12
116602: ARRAY
116603: ST_TO_ADDR
// if Crawls ( un ) then
116604: LD_VAR 0 2
116608: PPUSH
116609: CALL_OW 318
116613: IFFALSE 116624
// ComWalk ( un ) ;
116615: LD_VAR 0 2
116619: PPUSH
116620: CALL_OW 138
// SetClass ( un , class_sniper ) ;
116624: LD_VAR 0 2
116628: PPUSH
116629: LD_INT 5
116631: PPUSH
116632: CALL_OW 336
// end ;
116636: PPOPN 3
116638: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
116639: LD_EXP 146
116643: PUSH
116644: LD_EXP 164
116648: AND
116649: PUSH
116650: LD_OWVAR 67
116654: PUSH
116655: LD_INT 4
116657: LESS
116658: AND
116659: IFFALSE 116678
116661: GO 116663
116663: DISABLE
// begin Difficulty := Difficulty + 1 ;
116664: LD_ADDR_OWVAR 67
116668: PUSH
116669: LD_OWVAR 67
116673: PUSH
116674: LD_INT 1
116676: PLUS
116677: ST_TO_ADDR
// end ;
116678: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
116679: LD_EXP 146
116683: PUSH
116684: LD_EXP 165
116688: AND
116689: IFFALSE 116792
116691: GO 116693
116693: DISABLE
116694: LD_INT 0
116696: PPUSH
// begin for i := 1 to 5 do
116697: LD_ADDR_VAR 0 1
116701: PUSH
116702: DOUBLE
116703: LD_INT 1
116705: DEC
116706: ST_TO_ADDR
116707: LD_INT 5
116709: PUSH
116710: FOR_TO
116711: IFFALSE 116790
// begin uc_nation := nation_nature ;
116713: LD_ADDR_OWVAR 21
116717: PUSH
116718: LD_INT 0
116720: ST_TO_ADDR
// uc_side := 0 ;
116721: LD_ADDR_OWVAR 20
116725: PUSH
116726: LD_INT 0
116728: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116729: LD_ADDR_OWVAR 29
116733: PUSH
116734: LD_INT 12
116736: PUSH
116737: LD_INT 12
116739: PUSH
116740: EMPTY
116741: LIST
116742: LIST
116743: ST_TO_ADDR
// hc_agressivity := 20 ;
116744: LD_ADDR_OWVAR 35
116748: PUSH
116749: LD_INT 20
116751: ST_TO_ADDR
// hc_class := class_tiger ;
116752: LD_ADDR_OWVAR 28
116756: PUSH
116757: LD_INT 14
116759: ST_TO_ADDR
// hc_gallery :=  ;
116760: LD_ADDR_OWVAR 33
116764: PUSH
116765: LD_STRING 
116767: ST_TO_ADDR
// hc_name :=  ;
116768: LD_ADDR_OWVAR 26
116772: PUSH
116773: LD_STRING 
116775: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116776: CALL_OW 44
116780: PPUSH
116781: LD_INT 0
116783: PPUSH
116784: CALL_OW 51
// end ;
116788: GO 116710
116790: POP
116791: POP
// end ;
116792: PPOPN 1
116794: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116795: LD_EXP 146
116799: PUSH
116800: LD_EXP 166
116804: AND
116805: IFFALSE 116814
116807: GO 116809
116809: DISABLE
// StreamSibBomb ;
116810: CALL 116815 0 0
116814: END
// export function StreamSibBomb ; var i , x , y ; begin
116815: LD_INT 0
116817: PPUSH
116818: PPUSH
116819: PPUSH
116820: PPUSH
// result := false ;
116821: LD_ADDR_VAR 0 1
116825: PUSH
116826: LD_INT 0
116828: ST_TO_ADDR
// for i := 1 to 16 do
116829: LD_ADDR_VAR 0 2
116833: PUSH
116834: DOUBLE
116835: LD_INT 1
116837: DEC
116838: ST_TO_ADDR
116839: LD_INT 16
116841: PUSH
116842: FOR_TO
116843: IFFALSE 117042
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116845: LD_ADDR_VAR 0 3
116849: PUSH
116850: LD_INT 10
116852: PUSH
116853: LD_INT 20
116855: PUSH
116856: LD_INT 30
116858: PUSH
116859: LD_INT 40
116861: PUSH
116862: LD_INT 50
116864: PUSH
116865: LD_INT 60
116867: PUSH
116868: LD_INT 70
116870: PUSH
116871: LD_INT 80
116873: PUSH
116874: LD_INT 90
116876: PUSH
116877: LD_INT 100
116879: PUSH
116880: LD_INT 110
116882: PUSH
116883: LD_INT 120
116885: PUSH
116886: LD_INT 130
116888: PUSH
116889: LD_INT 140
116891: PUSH
116892: LD_INT 150
116894: PUSH
116895: EMPTY
116896: LIST
116897: LIST
116898: LIST
116899: LIST
116900: LIST
116901: LIST
116902: LIST
116903: LIST
116904: LIST
116905: LIST
116906: LIST
116907: LIST
116908: LIST
116909: LIST
116910: LIST
116911: PUSH
116912: LD_INT 1
116914: PPUSH
116915: LD_INT 15
116917: PPUSH
116918: CALL_OW 12
116922: ARRAY
116923: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116924: LD_ADDR_VAR 0 4
116928: PUSH
116929: LD_INT 10
116931: PUSH
116932: LD_INT 20
116934: PUSH
116935: LD_INT 30
116937: PUSH
116938: LD_INT 40
116940: PUSH
116941: LD_INT 50
116943: PUSH
116944: LD_INT 60
116946: PUSH
116947: LD_INT 70
116949: PUSH
116950: LD_INT 80
116952: PUSH
116953: LD_INT 90
116955: PUSH
116956: LD_INT 100
116958: PUSH
116959: LD_INT 110
116961: PUSH
116962: LD_INT 120
116964: PUSH
116965: LD_INT 130
116967: PUSH
116968: LD_INT 140
116970: PUSH
116971: LD_INT 150
116973: PUSH
116974: EMPTY
116975: LIST
116976: LIST
116977: LIST
116978: LIST
116979: LIST
116980: LIST
116981: LIST
116982: LIST
116983: LIST
116984: LIST
116985: LIST
116986: LIST
116987: LIST
116988: LIST
116989: LIST
116990: PUSH
116991: LD_INT 1
116993: PPUSH
116994: LD_INT 15
116996: PPUSH
116997: CALL_OW 12
117001: ARRAY
117002: ST_TO_ADDR
// if ValidHex ( x , y ) then
117003: LD_VAR 0 3
117007: PPUSH
117008: LD_VAR 0 4
117012: PPUSH
117013: CALL_OW 488
117017: IFFALSE 117040
// begin result := [ x , y ] ;
117019: LD_ADDR_VAR 0 1
117023: PUSH
117024: LD_VAR 0 3
117028: PUSH
117029: LD_VAR 0 4
117033: PUSH
117034: EMPTY
117035: LIST
117036: LIST
117037: ST_TO_ADDR
// break ;
117038: GO 117042
// end ; end ;
117040: GO 116842
117042: POP
117043: POP
// if result then
117044: LD_VAR 0 1
117048: IFFALSE 117108
// begin ToLua ( playSibBomb() ) ;
117050: LD_STRING playSibBomb()
117052: PPUSH
117053: CALL_OW 559
// wait ( 0 0$14 ) ;
117057: LD_INT 490
117059: PPUSH
117060: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
117064: LD_VAR 0 1
117068: PUSH
117069: LD_INT 1
117071: ARRAY
117072: PPUSH
117073: LD_VAR 0 1
117077: PUSH
117078: LD_INT 2
117080: ARRAY
117081: PPUSH
117082: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
117086: LD_VAR 0 1
117090: PUSH
117091: LD_INT 1
117093: ARRAY
117094: PPUSH
117095: LD_VAR 0 1
117099: PUSH
117100: LD_INT 2
117102: ARRAY
117103: PPUSH
117104: CALL_OW 429
// end ; end ;
117108: LD_VAR 0 1
117112: RET
// every 0 0$1 trigger StreamModeActive and sReset do
117113: LD_EXP 146
117117: PUSH
117118: LD_EXP 168
117122: AND
117123: IFFALSE 117135
117125: GO 117127
117127: DISABLE
// YouLost (  ) ;
117128: LD_STRING 
117130: PPUSH
117131: CALL_OW 104
117135: END
// every 0 0$1 trigger StreamModeActive and sFog do
117136: LD_EXP 146
117140: PUSH
117141: LD_EXP 167
117145: AND
117146: IFFALSE 117160
117148: GO 117150
117150: DISABLE
// FogOff ( your_side ) ;
117151: LD_OWVAR 2
117155: PPUSH
117156: CALL_OW 344
117160: END
// every 0 0$1 trigger StreamModeActive and sSun do
117161: LD_EXP 146
117165: PUSH
117166: LD_EXP 169
117170: AND
117171: IFFALSE 117199
117173: GO 117175
117175: DISABLE
// begin solar_recharge_percent := 0 ;
117176: LD_ADDR_OWVAR 79
117180: PUSH
117181: LD_INT 0
117183: ST_TO_ADDR
// wait ( 5 5$00 ) ;
117184: LD_INT 10500
117186: PPUSH
117187: CALL_OW 67
// solar_recharge_percent := 100 ;
117191: LD_ADDR_OWVAR 79
117195: PUSH
117196: LD_INT 100
117198: ST_TO_ADDR
// end ;
117199: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
117200: LD_EXP 146
117204: PUSH
117205: LD_EXP 170
117209: AND
117210: IFFALSE 117449
117212: GO 117214
117214: DISABLE
117215: LD_INT 0
117217: PPUSH
117218: PPUSH
117219: PPUSH
// begin tmp := [ ] ;
117220: LD_ADDR_VAR 0 3
117224: PUSH
117225: EMPTY
117226: ST_TO_ADDR
// for i := 1 to 6 do
117227: LD_ADDR_VAR 0 1
117231: PUSH
117232: DOUBLE
117233: LD_INT 1
117235: DEC
117236: ST_TO_ADDR
117237: LD_INT 6
117239: PUSH
117240: FOR_TO
117241: IFFALSE 117346
// begin uc_nation := nation_nature ;
117243: LD_ADDR_OWVAR 21
117247: PUSH
117248: LD_INT 0
117250: ST_TO_ADDR
// uc_side := 0 ;
117251: LD_ADDR_OWVAR 20
117255: PUSH
117256: LD_INT 0
117258: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117259: LD_ADDR_OWVAR 29
117263: PUSH
117264: LD_INT 12
117266: PUSH
117267: LD_INT 12
117269: PUSH
117270: EMPTY
117271: LIST
117272: LIST
117273: ST_TO_ADDR
// hc_agressivity := 20 ;
117274: LD_ADDR_OWVAR 35
117278: PUSH
117279: LD_INT 20
117281: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
117282: LD_ADDR_OWVAR 28
117286: PUSH
117287: LD_INT 17
117289: ST_TO_ADDR
// hc_gallery :=  ;
117290: LD_ADDR_OWVAR 33
117294: PUSH
117295: LD_STRING 
117297: ST_TO_ADDR
// hc_name :=  ;
117298: LD_ADDR_OWVAR 26
117302: PUSH
117303: LD_STRING 
117305: ST_TO_ADDR
// un := CreateHuman ;
117306: LD_ADDR_VAR 0 2
117310: PUSH
117311: CALL_OW 44
117315: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
117316: LD_VAR 0 2
117320: PPUSH
117321: LD_INT 1
117323: PPUSH
117324: CALL_OW 51
// tmp := tmp ^ un ;
117328: LD_ADDR_VAR 0 3
117332: PUSH
117333: LD_VAR 0 3
117337: PUSH
117338: LD_VAR 0 2
117342: ADD
117343: ST_TO_ADDR
// end ;
117344: GO 117240
117346: POP
117347: POP
// repeat wait ( 0 0$1 ) ;
117348: LD_INT 35
117350: PPUSH
117351: CALL_OW 67
// for un in tmp do
117355: LD_ADDR_VAR 0 2
117359: PUSH
117360: LD_VAR 0 3
117364: PUSH
117365: FOR_IN
117366: IFFALSE 117440
// begin if IsDead ( un ) then
117368: LD_VAR 0 2
117372: PPUSH
117373: CALL_OW 301
117377: IFFALSE 117397
// begin tmp := tmp diff un ;
117379: LD_ADDR_VAR 0 3
117383: PUSH
117384: LD_VAR 0 3
117388: PUSH
117389: LD_VAR 0 2
117393: DIFF
117394: ST_TO_ADDR
// continue ;
117395: GO 117365
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
117397: LD_VAR 0 2
117401: PPUSH
117402: LD_INT 3
117404: PUSH
117405: LD_INT 22
117407: PUSH
117408: LD_INT 0
117410: PUSH
117411: EMPTY
117412: LIST
117413: LIST
117414: PUSH
117415: EMPTY
117416: LIST
117417: LIST
117418: PPUSH
117419: CALL_OW 69
117423: PPUSH
117424: LD_VAR 0 2
117428: PPUSH
117429: CALL_OW 74
117433: PPUSH
117434: CALL_OW 115
// end ;
117438: GO 117365
117440: POP
117441: POP
// until not tmp ;
117442: LD_VAR 0 3
117446: NOT
117447: IFFALSE 117348
// end ;
117449: PPOPN 3
117451: END
// every 0 0$1 trigger StreamModeActive and sTroll do
117452: LD_EXP 146
117456: PUSH
117457: LD_EXP 171
117461: AND
117462: IFFALSE 117516
117464: GO 117466
117466: DISABLE
// begin ToLua ( displayTroll(); ) ;
117467: LD_STRING displayTroll();
117469: PPUSH
117470: CALL_OW 559
// wait ( 3 3$00 ) ;
117474: LD_INT 6300
117476: PPUSH
117477: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117481: LD_STRING hideTroll();
117483: PPUSH
117484: CALL_OW 559
// wait ( 1 1$00 ) ;
117488: LD_INT 2100
117490: PPUSH
117491: CALL_OW 67
// ToLua ( displayTroll(); ) ;
117495: LD_STRING displayTroll();
117497: PPUSH
117498: CALL_OW 559
// wait ( 1 1$00 ) ;
117502: LD_INT 2100
117504: PPUSH
117505: CALL_OW 67
// ToLua ( hideTroll(); ) ;
117509: LD_STRING hideTroll();
117511: PPUSH
117512: CALL_OW 559
// end ;
117516: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
117517: LD_EXP 146
117521: PUSH
117522: LD_EXP 172
117526: AND
117527: IFFALSE 117590
117529: GO 117531
117531: DISABLE
117532: LD_INT 0
117534: PPUSH
// begin p := 0 ;
117535: LD_ADDR_VAR 0 1
117539: PUSH
117540: LD_INT 0
117542: ST_TO_ADDR
// repeat game_speed := 1 ;
117543: LD_ADDR_OWVAR 65
117547: PUSH
117548: LD_INT 1
117550: ST_TO_ADDR
// wait ( 0 0$1 ) ;
117551: LD_INT 35
117553: PPUSH
117554: CALL_OW 67
// p := p + 1 ;
117558: LD_ADDR_VAR 0 1
117562: PUSH
117563: LD_VAR 0 1
117567: PUSH
117568: LD_INT 1
117570: PLUS
117571: ST_TO_ADDR
// until p >= 60 ;
117572: LD_VAR 0 1
117576: PUSH
117577: LD_INT 60
117579: GREATEREQUAL
117580: IFFALSE 117543
// game_speed := 4 ;
117582: LD_ADDR_OWVAR 65
117586: PUSH
117587: LD_INT 4
117589: ST_TO_ADDR
// end ;
117590: PPOPN 1
117592: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
117593: LD_EXP 146
117597: PUSH
117598: LD_EXP 173
117602: AND
117603: IFFALSE 117749
117605: GO 117607
117607: DISABLE
117608: LD_INT 0
117610: PPUSH
117611: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117612: LD_ADDR_VAR 0 1
117616: PUSH
117617: LD_INT 22
117619: PUSH
117620: LD_OWVAR 2
117624: PUSH
117625: EMPTY
117626: LIST
117627: LIST
117628: PUSH
117629: LD_INT 2
117631: PUSH
117632: LD_INT 30
117634: PUSH
117635: LD_INT 0
117637: PUSH
117638: EMPTY
117639: LIST
117640: LIST
117641: PUSH
117642: LD_INT 30
117644: PUSH
117645: LD_INT 1
117647: PUSH
117648: EMPTY
117649: LIST
117650: LIST
117651: PUSH
117652: EMPTY
117653: LIST
117654: LIST
117655: LIST
117656: PUSH
117657: EMPTY
117658: LIST
117659: LIST
117660: PPUSH
117661: CALL_OW 69
117665: ST_TO_ADDR
// if not depot then
117666: LD_VAR 0 1
117670: NOT
117671: IFFALSE 117675
// exit ;
117673: GO 117749
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
117675: LD_ADDR_VAR 0 2
117679: PUSH
117680: LD_VAR 0 1
117684: PUSH
117685: LD_INT 1
117687: PPUSH
117688: LD_VAR 0 1
117692: PPUSH
117693: CALL_OW 12
117697: ARRAY
117698: PPUSH
117699: CALL_OW 274
117703: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117704: LD_VAR 0 2
117708: PPUSH
117709: LD_INT 1
117711: PPUSH
117712: LD_INT 0
117714: PPUSH
117715: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117719: LD_VAR 0 2
117723: PPUSH
117724: LD_INT 2
117726: PPUSH
117727: LD_INT 0
117729: PPUSH
117730: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117734: LD_VAR 0 2
117738: PPUSH
117739: LD_INT 3
117741: PPUSH
117742: LD_INT 0
117744: PPUSH
117745: CALL_OW 277
// end ;
117749: PPOPN 2
117751: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117752: LD_EXP 146
117756: PUSH
117757: LD_EXP 174
117761: AND
117762: IFFALSE 117859
117764: GO 117766
117766: DISABLE
117767: LD_INT 0
117769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117770: LD_ADDR_VAR 0 1
117774: PUSH
117775: LD_INT 22
117777: PUSH
117778: LD_OWVAR 2
117782: PUSH
117783: EMPTY
117784: LIST
117785: LIST
117786: PUSH
117787: LD_INT 21
117789: PUSH
117790: LD_INT 1
117792: PUSH
117793: EMPTY
117794: LIST
117795: LIST
117796: PUSH
117797: LD_INT 3
117799: PUSH
117800: LD_INT 23
117802: PUSH
117803: LD_INT 0
117805: PUSH
117806: EMPTY
117807: LIST
117808: LIST
117809: PUSH
117810: EMPTY
117811: LIST
117812: LIST
117813: PUSH
117814: EMPTY
117815: LIST
117816: LIST
117817: LIST
117818: PPUSH
117819: CALL_OW 69
117823: ST_TO_ADDR
// if not tmp then
117824: LD_VAR 0 1
117828: NOT
117829: IFFALSE 117833
// exit ;
117831: GO 117859
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117833: LD_VAR 0 1
117837: PUSH
117838: LD_INT 1
117840: PPUSH
117841: LD_VAR 0 1
117845: PPUSH
117846: CALL_OW 12
117850: ARRAY
117851: PPUSH
117852: LD_INT 200
117854: PPUSH
117855: CALL_OW 234
// end ;
117859: PPOPN 1
117861: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117862: LD_EXP 146
117866: PUSH
117867: LD_EXP 175
117871: AND
117872: IFFALSE 117951
117874: GO 117876
117876: DISABLE
117877: LD_INT 0
117879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117880: LD_ADDR_VAR 0 1
117884: PUSH
117885: LD_INT 22
117887: PUSH
117888: LD_OWVAR 2
117892: PUSH
117893: EMPTY
117894: LIST
117895: LIST
117896: PUSH
117897: LD_INT 21
117899: PUSH
117900: LD_INT 2
117902: PUSH
117903: EMPTY
117904: LIST
117905: LIST
117906: PUSH
117907: EMPTY
117908: LIST
117909: LIST
117910: PPUSH
117911: CALL_OW 69
117915: ST_TO_ADDR
// if not tmp then
117916: LD_VAR 0 1
117920: NOT
117921: IFFALSE 117925
// exit ;
117923: GO 117951
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117925: LD_VAR 0 1
117929: PUSH
117930: LD_INT 1
117932: PPUSH
117933: LD_VAR 0 1
117937: PPUSH
117938: CALL_OW 12
117942: ARRAY
117943: PPUSH
117944: LD_INT 60
117946: PPUSH
117947: CALL_OW 234
// end ;
117951: PPOPN 1
117953: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117954: LD_EXP 146
117958: PUSH
117959: LD_EXP 176
117963: AND
117964: IFFALSE 118063
117966: GO 117968
117968: DISABLE
117969: LD_INT 0
117971: PPUSH
117972: PPUSH
// begin enable ;
117973: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117974: LD_ADDR_VAR 0 1
117978: PUSH
117979: LD_INT 22
117981: PUSH
117982: LD_OWVAR 2
117986: PUSH
117987: EMPTY
117988: LIST
117989: LIST
117990: PUSH
117991: LD_INT 61
117993: PUSH
117994: EMPTY
117995: LIST
117996: PUSH
117997: LD_INT 33
117999: PUSH
118000: LD_INT 2
118002: PUSH
118003: EMPTY
118004: LIST
118005: LIST
118006: PUSH
118007: EMPTY
118008: LIST
118009: LIST
118010: LIST
118011: PPUSH
118012: CALL_OW 69
118016: ST_TO_ADDR
// if not tmp then
118017: LD_VAR 0 1
118021: NOT
118022: IFFALSE 118026
// exit ;
118024: GO 118063
// for i in tmp do
118026: LD_ADDR_VAR 0 2
118030: PUSH
118031: LD_VAR 0 1
118035: PUSH
118036: FOR_IN
118037: IFFALSE 118061
// if IsControledBy ( i ) then
118039: LD_VAR 0 2
118043: PPUSH
118044: CALL_OW 312
118048: IFFALSE 118059
// ComUnlink ( i ) ;
118050: LD_VAR 0 2
118054: PPUSH
118055: CALL_OW 136
118059: GO 118036
118061: POP
118062: POP
// end ;
118063: PPOPN 2
118065: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
118066: LD_EXP 146
118070: PUSH
118071: LD_EXP 177
118075: AND
118076: IFFALSE 118216
118078: GO 118080
118080: DISABLE
118081: LD_INT 0
118083: PPUSH
118084: PPUSH
// begin ToLua ( displayPowell(); ) ;
118085: LD_STRING displayPowell();
118087: PPUSH
118088: CALL_OW 559
// uc_side := 0 ;
118092: LD_ADDR_OWVAR 20
118096: PUSH
118097: LD_INT 0
118099: ST_TO_ADDR
// uc_nation := 2 ;
118100: LD_ADDR_OWVAR 21
118104: PUSH
118105: LD_INT 2
118107: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
118108: LD_ADDR_OWVAR 37
118112: PUSH
118113: LD_INT 14
118115: ST_TO_ADDR
// vc_engine := engine_siberite ;
118116: LD_ADDR_OWVAR 39
118120: PUSH
118121: LD_INT 3
118123: ST_TO_ADDR
// vc_control := control_apeman ;
118124: LD_ADDR_OWVAR 38
118128: PUSH
118129: LD_INT 5
118131: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
118132: LD_ADDR_OWVAR 40
118136: PUSH
118137: LD_INT 29
118139: ST_TO_ADDR
// un := CreateVehicle ;
118140: LD_ADDR_VAR 0 2
118144: PUSH
118145: CALL_OW 45
118149: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118150: LD_VAR 0 2
118154: PPUSH
118155: LD_INT 1
118157: PPUSH
118158: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118162: LD_INT 35
118164: PPUSH
118165: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118169: LD_VAR 0 2
118173: PPUSH
118174: LD_INT 22
118176: PUSH
118177: LD_OWVAR 2
118181: PUSH
118182: EMPTY
118183: LIST
118184: LIST
118185: PPUSH
118186: CALL_OW 69
118190: PPUSH
118191: LD_VAR 0 2
118195: PPUSH
118196: CALL_OW 74
118200: PPUSH
118201: CALL_OW 115
// until IsDead ( un ) ;
118205: LD_VAR 0 2
118209: PPUSH
118210: CALL_OW 301
118214: IFFALSE 118162
// end ;
118216: PPOPN 2
118218: END
// every 0 0$1 trigger StreamModeActive and sStu do
118219: LD_EXP 146
118223: PUSH
118224: LD_EXP 185
118228: AND
118229: IFFALSE 118245
118231: GO 118233
118233: DISABLE
// begin ToLua ( displayStucuk(); ) ;
118234: LD_STRING displayStucuk();
118236: PPUSH
118237: CALL_OW 559
// ResetFog ;
118241: CALL_OW 335
// end ;
118245: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
118246: LD_EXP 146
118250: PUSH
118251: LD_EXP 178
118255: AND
118256: IFFALSE 118397
118258: GO 118260
118260: DISABLE
118261: LD_INT 0
118263: PPUSH
118264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118265: LD_ADDR_VAR 0 2
118269: PUSH
118270: LD_INT 22
118272: PUSH
118273: LD_OWVAR 2
118277: PUSH
118278: EMPTY
118279: LIST
118280: LIST
118281: PUSH
118282: LD_INT 21
118284: PUSH
118285: LD_INT 1
118287: PUSH
118288: EMPTY
118289: LIST
118290: LIST
118291: PUSH
118292: EMPTY
118293: LIST
118294: LIST
118295: PPUSH
118296: CALL_OW 69
118300: ST_TO_ADDR
// if not tmp then
118301: LD_VAR 0 2
118305: NOT
118306: IFFALSE 118310
// exit ;
118308: GO 118397
// un := tmp [ rand ( 1 , tmp ) ] ;
118310: LD_ADDR_VAR 0 1
118314: PUSH
118315: LD_VAR 0 2
118319: PUSH
118320: LD_INT 1
118322: PPUSH
118323: LD_VAR 0 2
118327: PPUSH
118328: CALL_OW 12
118332: ARRAY
118333: ST_TO_ADDR
// SetSide ( un , 0 ) ;
118334: LD_VAR 0 1
118338: PPUSH
118339: LD_INT 0
118341: PPUSH
118342: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
118346: LD_VAR 0 1
118350: PPUSH
118351: LD_OWVAR 3
118355: PUSH
118356: LD_VAR 0 1
118360: DIFF
118361: PPUSH
118362: LD_VAR 0 1
118366: PPUSH
118367: CALL_OW 74
118371: PPUSH
118372: CALL_OW 115
// wait ( 0 0$20 ) ;
118376: LD_INT 700
118378: PPUSH
118379: CALL_OW 67
// SetSide ( un , your_side ) ;
118383: LD_VAR 0 1
118387: PPUSH
118388: LD_OWVAR 2
118392: PPUSH
118393: CALL_OW 235
// end ;
118397: PPOPN 2
118399: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
118400: LD_EXP 146
118404: PUSH
118405: LD_EXP 179
118409: AND
118410: IFFALSE 118516
118412: GO 118414
118414: DISABLE
118415: LD_INT 0
118417: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118418: LD_ADDR_VAR 0 1
118422: PUSH
118423: LD_INT 22
118425: PUSH
118426: LD_OWVAR 2
118430: PUSH
118431: EMPTY
118432: LIST
118433: LIST
118434: PUSH
118435: LD_INT 2
118437: PUSH
118438: LD_INT 30
118440: PUSH
118441: LD_INT 0
118443: PUSH
118444: EMPTY
118445: LIST
118446: LIST
118447: PUSH
118448: LD_INT 30
118450: PUSH
118451: LD_INT 1
118453: PUSH
118454: EMPTY
118455: LIST
118456: LIST
118457: PUSH
118458: EMPTY
118459: LIST
118460: LIST
118461: LIST
118462: PUSH
118463: EMPTY
118464: LIST
118465: LIST
118466: PPUSH
118467: CALL_OW 69
118471: ST_TO_ADDR
// if not depot then
118472: LD_VAR 0 1
118476: NOT
118477: IFFALSE 118481
// exit ;
118479: GO 118516
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
118481: LD_VAR 0 1
118485: PUSH
118486: LD_INT 1
118488: ARRAY
118489: PPUSH
118490: CALL_OW 250
118494: PPUSH
118495: LD_VAR 0 1
118499: PUSH
118500: LD_INT 1
118502: ARRAY
118503: PPUSH
118504: CALL_OW 251
118508: PPUSH
118509: LD_INT 70
118511: PPUSH
118512: CALL_OW 495
// end ;
118516: PPOPN 1
118518: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
118519: LD_EXP 146
118523: PUSH
118524: LD_EXP 180
118528: AND
118529: IFFALSE 118740
118531: GO 118533
118533: DISABLE
118534: LD_INT 0
118536: PPUSH
118537: PPUSH
118538: PPUSH
118539: PPUSH
118540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
118541: LD_ADDR_VAR 0 5
118545: PUSH
118546: LD_INT 22
118548: PUSH
118549: LD_OWVAR 2
118553: PUSH
118554: EMPTY
118555: LIST
118556: LIST
118557: PUSH
118558: LD_INT 21
118560: PUSH
118561: LD_INT 1
118563: PUSH
118564: EMPTY
118565: LIST
118566: LIST
118567: PUSH
118568: EMPTY
118569: LIST
118570: LIST
118571: PPUSH
118572: CALL_OW 69
118576: ST_TO_ADDR
// if not tmp then
118577: LD_VAR 0 5
118581: NOT
118582: IFFALSE 118586
// exit ;
118584: GO 118740
// for i in tmp do
118586: LD_ADDR_VAR 0 1
118590: PUSH
118591: LD_VAR 0 5
118595: PUSH
118596: FOR_IN
118597: IFFALSE 118738
// begin d := rand ( 0 , 5 ) ;
118599: LD_ADDR_VAR 0 4
118603: PUSH
118604: LD_INT 0
118606: PPUSH
118607: LD_INT 5
118609: PPUSH
118610: CALL_OW 12
118614: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
118615: LD_ADDR_VAR 0 2
118619: PUSH
118620: LD_VAR 0 1
118624: PPUSH
118625: CALL_OW 250
118629: PPUSH
118630: LD_VAR 0 4
118634: PPUSH
118635: LD_INT 3
118637: PPUSH
118638: LD_INT 12
118640: PPUSH
118641: CALL_OW 12
118645: PPUSH
118646: CALL_OW 272
118650: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
118651: LD_ADDR_VAR 0 3
118655: PUSH
118656: LD_VAR 0 1
118660: PPUSH
118661: CALL_OW 251
118665: PPUSH
118666: LD_VAR 0 4
118670: PPUSH
118671: LD_INT 3
118673: PPUSH
118674: LD_INT 12
118676: PPUSH
118677: CALL_OW 12
118681: PPUSH
118682: CALL_OW 273
118686: ST_TO_ADDR
// if ValidHex ( x , y ) then
118687: LD_VAR 0 2
118691: PPUSH
118692: LD_VAR 0 3
118696: PPUSH
118697: CALL_OW 488
118701: IFFALSE 118736
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118703: LD_VAR 0 1
118707: PPUSH
118708: LD_VAR 0 2
118712: PPUSH
118713: LD_VAR 0 3
118717: PPUSH
118718: LD_INT 3
118720: PPUSH
118721: LD_INT 6
118723: PPUSH
118724: CALL_OW 12
118728: PPUSH
118729: LD_INT 1
118731: PPUSH
118732: CALL_OW 483
// end ;
118736: GO 118596
118738: POP
118739: POP
// end ;
118740: PPOPN 5
118742: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118743: LD_EXP 146
118747: PUSH
118748: LD_EXP 181
118752: AND
118753: IFFALSE 118847
118755: GO 118757
118757: DISABLE
118758: LD_INT 0
118760: PPUSH
118761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118762: LD_ADDR_VAR 0 2
118766: PUSH
118767: LD_INT 22
118769: PUSH
118770: LD_OWVAR 2
118774: PUSH
118775: EMPTY
118776: LIST
118777: LIST
118778: PUSH
118779: LD_INT 32
118781: PUSH
118782: LD_INT 1
118784: PUSH
118785: EMPTY
118786: LIST
118787: LIST
118788: PUSH
118789: LD_INT 21
118791: PUSH
118792: LD_INT 2
118794: PUSH
118795: EMPTY
118796: LIST
118797: LIST
118798: PUSH
118799: EMPTY
118800: LIST
118801: LIST
118802: LIST
118803: PPUSH
118804: CALL_OW 69
118808: ST_TO_ADDR
// if not tmp then
118809: LD_VAR 0 2
118813: NOT
118814: IFFALSE 118818
// exit ;
118816: GO 118847
// for i in tmp do
118818: LD_ADDR_VAR 0 1
118822: PUSH
118823: LD_VAR 0 2
118827: PUSH
118828: FOR_IN
118829: IFFALSE 118845
// SetFuel ( i , 0 ) ;
118831: LD_VAR 0 1
118835: PPUSH
118836: LD_INT 0
118838: PPUSH
118839: CALL_OW 240
118843: GO 118828
118845: POP
118846: POP
// end ;
118847: PPOPN 2
118849: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118850: LD_EXP 146
118854: PUSH
118855: LD_EXP 182
118859: AND
118860: IFFALSE 118926
118862: GO 118864
118864: DISABLE
118865: LD_INT 0
118867: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118868: LD_ADDR_VAR 0 1
118872: PUSH
118873: LD_INT 22
118875: PUSH
118876: LD_OWVAR 2
118880: PUSH
118881: EMPTY
118882: LIST
118883: LIST
118884: PUSH
118885: LD_INT 30
118887: PUSH
118888: LD_INT 29
118890: PUSH
118891: EMPTY
118892: LIST
118893: LIST
118894: PUSH
118895: EMPTY
118896: LIST
118897: LIST
118898: PPUSH
118899: CALL_OW 69
118903: ST_TO_ADDR
// if not tmp then
118904: LD_VAR 0 1
118908: NOT
118909: IFFALSE 118913
// exit ;
118911: GO 118926
// DestroyUnit ( tmp [ 1 ] ) ;
118913: LD_VAR 0 1
118917: PUSH
118918: LD_INT 1
118920: ARRAY
118921: PPUSH
118922: CALL_OW 65
// end ;
118926: PPOPN 1
118928: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118929: LD_EXP 146
118933: PUSH
118934: LD_EXP 184
118938: AND
118939: IFFALSE 119068
118941: GO 118943
118943: DISABLE
118944: LD_INT 0
118946: PPUSH
// begin uc_side := 0 ;
118947: LD_ADDR_OWVAR 20
118951: PUSH
118952: LD_INT 0
118954: ST_TO_ADDR
// uc_nation := nation_arabian ;
118955: LD_ADDR_OWVAR 21
118959: PUSH
118960: LD_INT 2
118962: ST_TO_ADDR
// hc_gallery :=  ;
118963: LD_ADDR_OWVAR 33
118967: PUSH
118968: LD_STRING 
118970: ST_TO_ADDR
// hc_name :=  ;
118971: LD_ADDR_OWVAR 26
118975: PUSH
118976: LD_STRING 
118978: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118979: LD_INT 1
118981: PPUSH
118982: LD_INT 11
118984: PPUSH
118985: LD_INT 10
118987: PPUSH
118988: CALL_OW 380
// un := CreateHuman ;
118992: LD_ADDR_VAR 0 1
118996: PUSH
118997: CALL_OW 44
119001: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119002: LD_VAR 0 1
119006: PPUSH
119007: LD_INT 1
119009: PPUSH
119010: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119014: LD_INT 35
119016: PPUSH
119017: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119021: LD_VAR 0 1
119025: PPUSH
119026: LD_INT 22
119028: PUSH
119029: LD_OWVAR 2
119033: PUSH
119034: EMPTY
119035: LIST
119036: LIST
119037: PPUSH
119038: CALL_OW 69
119042: PPUSH
119043: LD_VAR 0 1
119047: PPUSH
119048: CALL_OW 74
119052: PPUSH
119053: CALL_OW 115
// until IsDead ( un ) ;
119057: LD_VAR 0 1
119061: PPUSH
119062: CALL_OW 301
119066: IFFALSE 119014
// end ;
119068: PPOPN 1
119070: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
119071: LD_EXP 146
119075: PUSH
119076: LD_EXP 186
119080: AND
119081: IFFALSE 119093
119083: GO 119085
119085: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
119086: LD_STRING earthquake(getX(game), 0, 32)
119088: PPUSH
119089: CALL_OW 559
119093: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
119094: LD_EXP 146
119098: PUSH
119099: LD_EXP 187
119103: AND
119104: IFFALSE 119195
119106: GO 119108
119108: DISABLE
119109: LD_INT 0
119111: PPUSH
// begin enable ;
119112: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
119113: LD_ADDR_VAR 0 1
119117: PUSH
119118: LD_INT 22
119120: PUSH
119121: LD_OWVAR 2
119125: PUSH
119126: EMPTY
119127: LIST
119128: LIST
119129: PUSH
119130: LD_INT 21
119132: PUSH
119133: LD_INT 2
119135: PUSH
119136: EMPTY
119137: LIST
119138: LIST
119139: PUSH
119140: LD_INT 33
119142: PUSH
119143: LD_INT 3
119145: PUSH
119146: EMPTY
119147: LIST
119148: LIST
119149: PUSH
119150: EMPTY
119151: LIST
119152: LIST
119153: LIST
119154: PPUSH
119155: CALL_OW 69
119159: ST_TO_ADDR
// if not tmp then
119160: LD_VAR 0 1
119164: NOT
119165: IFFALSE 119169
// exit ;
119167: GO 119195
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119169: LD_VAR 0 1
119173: PUSH
119174: LD_INT 1
119176: PPUSH
119177: LD_VAR 0 1
119181: PPUSH
119182: CALL_OW 12
119186: ARRAY
119187: PPUSH
119188: LD_INT 1
119190: PPUSH
119191: CALL_OW 234
// end ;
119195: PPOPN 1
119197: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
119198: LD_EXP 146
119202: PUSH
119203: LD_EXP 188
119207: AND
119208: IFFALSE 119349
119210: GO 119212
119212: DISABLE
119213: LD_INT 0
119215: PPUSH
119216: PPUSH
119217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119218: LD_ADDR_VAR 0 3
119222: PUSH
119223: LD_INT 22
119225: PUSH
119226: LD_OWVAR 2
119230: PUSH
119231: EMPTY
119232: LIST
119233: LIST
119234: PUSH
119235: LD_INT 25
119237: PUSH
119238: LD_INT 1
119240: PUSH
119241: EMPTY
119242: LIST
119243: LIST
119244: PUSH
119245: EMPTY
119246: LIST
119247: LIST
119248: PPUSH
119249: CALL_OW 69
119253: ST_TO_ADDR
// if not tmp then
119254: LD_VAR 0 3
119258: NOT
119259: IFFALSE 119263
// exit ;
119261: GO 119349
// un := tmp [ rand ( 1 , tmp ) ] ;
119263: LD_ADDR_VAR 0 2
119267: PUSH
119268: LD_VAR 0 3
119272: PUSH
119273: LD_INT 1
119275: PPUSH
119276: LD_VAR 0 3
119280: PPUSH
119281: CALL_OW 12
119285: ARRAY
119286: ST_TO_ADDR
// if Crawls ( un ) then
119287: LD_VAR 0 2
119291: PPUSH
119292: CALL_OW 318
119296: IFFALSE 119307
// ComWalk ( un ) ;
119298: LD_VAR 0 2
119302: PPUSH
119303: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
119307: LD_VAR 0 2
119311: PPUSH
119312: LD_INT 9
119314: PPUSH
119315: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
119319: LD_INT 28
119321: PPUSH
119322: LD_OWVAR 2
119326: PPUSH
119327: LD_INT 2
119329: PPUSH
119330: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
119334: LD_INT 29
119336: PPUSH
119337: LD_OWVAR 2
119341: PPUSH
119342: LD_INT 2
119344: PPUSH
119345: CALL_OW 322
// end ;
119349: PPOPN 3
119351: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
119352: LD_EXP 146
119356: PUSH
119357: LD_EXP 189
119361: AND
119362: IFFALSE 119473
119364: GO 119366
119366: DISABLE
119367: LD_INT 0
119369: PPUSH
119370: PPUSH
119371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119372: LD_ADDR_VAR 0 3
119376: PUSH
119377: LD_INT 22
119379: PUSH
119380: LD_OWVAR 2
119384: PUSH
119385: EMPTY
119386: LIST
119387: LIST
119388: PUSH
119389: LD_INT 25
119391: PUSH
119392: LD_INT 1
119394: PUSH
119395: EMPTY
119396: LIST
119397: LIST
119398: PUSH
119399: EMPTY
119400: LIST
119401: LIST
119402: PPUSH
119403: CALL_OW 69
119407: ST_TO_ADDR
// if not tmp then
119408: LD_VAR 0 3
119412: NOT
119413: IFFALSE 119417
// exit ;
119415: GO 119473
// un := tmp [ rand ( 1 , tmp ) ] ;
119417: LD_ADDR_VAR 0 2
119421: PUSH
119422: LD_VAR 0 3
119426: PUSH
119427: LD_INT 1
119429: PPUSH
119430: LD_VAR 0 3
119434: PPUSH
119435: CALL_OW 12
119439: ARRAY
119440: ST_TO_ADDR
// if Crawls ( un ) then
119441: LD_VAR 0 2
119445: PPUSH
119446: CALL_OW 318
119450: IFFALSE 119461
// ComWalk ( un ) ;
119452: LD_VAR 0 2
119456: PPUSH
119457: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119461: LD_VAR 0 2
119465: PPUSH
119466: LD_INT 8
119468: PPUSH
119469: CALL_OW 336
// end ;
119473: PPOPN 3
119475: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
119476: LD_EXP 146
119480: PUSH
119481: LD_EXP 190
119485: AND
119486: IFFALSE 119630
119488: GO 119490
119490: DISABLE
119491: LD_INT 0
119493: PPUSH
119494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
119495: LD_ADDR_VAR 0 2
119499: PUSH
119500: LD_INT 22
119502: PUSH
119503: LD_OWVAR 2
119507: PUSH
119508: EMPTY
119509: LIST
119510: LIST
119511: PUSH
119512: LD_INT 21
119514: PUSH
119515: LD_INT 2
119517: PUSH
119518: EMPTY
119519: LIST
119520: LIST
119521: PUSH
119522: LD_INT 2
119524: PUSH
119525: LD_INT 34
119527: PUSH
119528: LD_INT 12
119530: PUSH
119531: EMPTY
119532: LIST
119533: LIST
119534: PUSH
119535: LD_INT 34
119537: PUSH
119538: LD_INT 51
119540: PUSH
119541: EMPTY
119542: LIST
119543: LIST
119544: PUSH
119545: LD_INT 34
119547: PUSH
119548: LD_INT 32
119550: PUSH
119551: EMPTY
119552: LIST
119553: LIST
119554: PUSH
119555: EMPTY
119556: LIST
119557: LIST
119558: LIST
119559: LIST
119560: PUSH
119561: EMPTY
119562: LIST
119563: LIST
119564: LIST
119565: PPUSH
119566: CALL_OW 69
119570: ST_TO_ADDR
// if not tmp then
119571: LD_VAR 0 2
119575: NOT
119576: IFFALSE 119580
// exit ;
119578: GO 119630
// for i in tmp do
119580: LD_ADDR_VAR 0 1
119584: PUSH
119585: LD_VAR 0 2
119589: PUSH
119590: FOR_IN
119591: IFFALSE 119628
// if GetCargo ( i , mat_artifact ) = 0 then
119593: LD_VAR 0 1
119597: PPUSH
119598: LD_INT 4
119600: PPUSH
119601: CALL_OW 289
119605: PUSH
119606: LD_INT 0
119608: EQUAL
119609: IFFALSE 119626
// SetCargo ( i , mat_siberit , 100 ) ;
119611: LD_VAR 0 1
119615: PPUSH
119616: LD_INT 3
119618: PPUSH
119619: LD_INT 100
119621: PPUSH
119622: CALL_OW 290
119626: GO 119590
119628: POP
119629: POP
// end ;
119630: PPOPN 2
119632: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
119633: LD_EXP 146
119637: PUSH
119638: LD_EXP 191
119642: AND
119643: IFFALSE 119826
119645: GO 119647
119647: DISABLE
119648: LD_INT 0
119650: PPUSH
119651: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
119652: LD_ADDR_VAR 0 2
119656: PUSH
119657: LD_INT 22
119659: PUSH
119660: LD_OWVAR 2
119664: PUSH
119665: EMPTY
119666: LIST
119667: LIST
119668: PPUSH
119669: CALL_OW 69
119673: ST_TO_ADDR
// if not tmp then
119674: LD_VAR 0 2
119678: NOT
119679: IFFALSE 119683
// exit ;
119681: GO 119826
// for i := 1 to 2 do
119683: LD_ADDR_VAR 0 1
119687: PUSH
119688: DOUBLE
119689: LD_INT 1
119691: DEC
119692: ST_TO_ADDR
119693: LD_INT 2
119695: PUSH
119696: FOR_TO
119697: IFFALSE 119824
// begin uc_side := your_side ;
119699: LD_ADDR_OWVAR 20
119703: PUSH
119704: LD_OWVAR 2
119708: ST_TO_ADDR
// uc_nation := nation_american ;
119709: LD_ADDR_OWVAR 21
119713: PUSH
119714: LD_INT 1
119716: ST_TO_ADDR
// vc_chassis := us_morphling ;
119717: LD_ADDR_OWVAR 37
119721: PUSH
119722: LD_INT 5
119724: ST_TO_ADDR
// vc_engine := engine_siberite ;
119725: LD_ADDR_OWVAR 39
119729: PUSH
119730: LD_INT 3
119732: ST_TO_ADDR
// vc_control := control_computer ;
119733: LD_ADDR_OWVAR 38
119737: PUSH
119738: LD_INT 3
119740: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119741: LD_ADDR_OWVAR 40
119745: PUSH
119746: LD_INT 10
119748: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119749: LD_VAR 0 2
119753: PUSH
119754: LD_INT 1
119756: ARRAY
119757: PPUSH
119758: CALL_OW 310
119762: NOT
119763: IFFALSE 119810
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119765: CALL_OW 45
119769: PPUSH
119770: LD_VAR 0 2
119774: PUSH
119775: LD_INT 1
119777: ARRAY
119778: PPUSH
119779: CALL_OW 250
119783: PPUSH
119784: LD_VAR 0 2
119788: PUSH
119789: LD_INT 1
119791: ARRAY
119792: PPUSH
119793: CALL_OW 251
119797: PPUSH
119798: LD_INT 12
119800: PPUSH
119801: LD_INT 1
119803: PPUSH
119804: CALL_OW 50
119808: GO 119822
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119810: CALL_OW 45
119814: PPUSH
119815: LD_INT 1
119817: PPUSH
119818: CALL_OW 51
// end ;
119822: GO 119696
119824: POP
119825: POP
// end ;
119826: PPOPN 2
119828: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119829: LD_EXP 146
119833: PUSH
119834: LD_EXP 192
119838: AND
119839: IFFALSE 120061
119841: GO 119843
119843: DISABLE
119844: LD_INT 0
119846: PPUSH
119847: PPUSH
119848: PPUSH
119849: PPUSH
119850: PPUSH
119851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119852: LD_ADDR_VAR 0 6
119856: PUSH
119857: LD_INT 22
119859: PUSH
119860: LD_OWVAR 2
119864: PUSH
119865: EMPTY
119866: LIST
119867: LIST
119868: PUSH
119869: LD_INT 21
119871: PUSH
119872: LD_INT 1
119874: PUSH
119875: EMPTY
119876: LIST
119877: LIST
119878: PUSH
119879: LD_INT 3
119881: PUSH
119882: LD_INT 23
119884: PUSH
119885: LD_INT 0
119887: PUSH
119888: EMPTY
119889: LIST
119890: LIST
119891: PUSH
119892: EMPTY
119893: LIST
119894: LIST
119895: PUSH
119896: EMPTY
119897: LIST
119898: LIST
119899: LIST
119900: PPUSH
119901: CALL_OW 69
119905: ST_TO_ADDR
// if not tmp then
119906: LD_VAR 0 6
119910: NOT
119911: IFFALSE 119915
// exit ;
119913: GO 120061
// s1 := rand ( 1 , 4 ) ;
119915: LD_ADDR_VAR 0 2
119919: PUSH
119920: LD_INT 1
119922: PPUSH
119923: LD_INT 4
119925: PPUSH
119926: CALL_OW 12
119930: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119931: LD_ADDR_VAR 0 4
119935: PUSH
119936: LD_VAR 0 6
119940: PUSH
119941: LD_INT 1
119943: ARRAY
119944: PPUSH
119945: LD_VAR 0 2
119949: PPUSH
119950: CALL_OW 259
119954: ST_TO_ADDR
// if s1 = 1 then
119955: LD_VAR 0 2
119959: PUSH
119960: LD_INT 1
119962: EQUAL
119963: IFFALSE 119983
// s2 := rand ( 2 , 4 ) else
119965: LD_ADDR_VAR 0 3
119969: PUSH
119970: LD_INT 2
119972: PPUSH
119973: LD_INT 4
119975: PPUSH
119976: CALL_OW 12
119980: ST_TO_ADDR
119981: GO 119991
// s2 := 1 ;
119983: LD_ADDR_VAR 0 3
119987: PUSH
119988: LD_INT 1
119990: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119991: LD_ADDR_VAR 0 5
119995: PUSH
119996: LD_VAR 0 6
120000: PUSH
120001: LD_INT 1
120003: ARRAY
120004: PPUSH
120005: LD_VAR 0 3
120009: PPUSH
120010: CALL_OW 259
120014: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
120015: LD_VAR 0 6
120019: PUSH
120020: LD_INT 1
120022: ARRAY
120023: PPUSH
120024: LD_VAR 0 2
120028: PPUSH
120029: LD_VAR 0 5
120033: PPUSH
120034: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
120038: LD_VAR 0 6
120042: PUSH
120043: LD_INT 1
120045: ARRAY
120046: PPUSH
120047: LD_VAR 0 3
120051: PPUSH
120052: LD_VAR 0 4
120056: PPUSH
120057: CALL_OW 237
// end ;
120061: PPOPN 6
120063: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
120064: LD_EXP 146
120068: PUSH
120069: LD_EXP 193
120073: AND
120074: IFFALSE 120153
120076: GO 120078
120078: DISABLE
120079: LD_INT 0
120081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
120082: LD_ADDR_VAR 0 1
120086: PUSH
120087: LD_INT 22
120089: PUSH
120090: LD_OWVAR 2
120094: PUSH
120095: EMPTY
120096: LIST
120097: LIST
120098: PUSH
120099: LD_INT 30
120101: PUSH
120102: LD_INT 3
120104: PUSH
120105: EMPTY
120106: LIST
120107: LIST
120108: PUSH
120109: EMPTY
120110: LIST
120111: LIST
120112: PPUSH
120113: CALL_OW 69
120117: ST_TO_ADDR
// if not tmp then
120118: LD_VAR 0 1
120122: NOT
120123: IFFALSE 120127
// exit ;
120125: GO 120153
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120127: LD_VAR 0 1
120131: PUSH
120132: LD_INT 1
120134: PPUSH
120135: LD_VAR 0 1
120139: PPUSH
120140: CALL_OW 12
120144: ARRAY
120145: PPUSH
120146: LD_INT 1
120148: PPUSH
120149: CALL_OW 234
// end ;
120153: PPOPN 1
120155: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
120156: LD_EXP 146
120160: PUSH
120161: LD_EXP 194
120165: AND
120166: IFFALSE 120278
120168: GO 120170
120170: DISABLE
120171: LD_INT 0
120173: PPUSH
120174: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
120175: LD_ADDR_VAR 0 2
120179: PUSH
120180: LD_INT 22
120182: PUSH
120183: LD_OWVAR 2
120187: PUSH
120188: EMPTY
120189: LIST
120190: LIST
120191: PUSH
120192: LD_INT 2
120194: PUSH
120195: LD_INT 30
120197: PUSH
120198: LD_INT 27
120200: PUSH
120201: EMPTY
120202: LIST
120203: LIST
120204: PUSH
120205: LD_INT 30
120207: PUSH
120208: LD_INT 26
120210: PUSH
120211: EMPTY
120212: LIST
120213: LIST
120214: PUSH
120215: LD_INT 30
120217: PUSH
120218: LD_INT 28
120220: PUSH
120221: EMPTY
120222: LIST
120223: LIST
120224: PUSH
120225: EMPTY
120226: LIST
120227: LIST
120228: LIST
120229: LIST
120230: PUSH
120231: EMPTY
120232: LIST
120233: LIST
120234: PPUSH
120235: CALL_OW 69
120239: ST_TO_ADDR
// if not tmp then
120240: LD_VAR 0 2
120244: NOT
120245: IFFALSE 120249
// exit ;
120247: GO 120278
// for i in tmp do
120249: LD_ADDR_VAR 0 1
120253: PUSH
120254: LD_VAR 0 2
120258: PUSH
120259: FOR_IN
120260: IFFALSE 120276
// SetLives ( i , 1 ) ;
120262: LD_VAR 0 1
120266: PPUSH
120267: LD_INT 1
120269: PPUSH
120270: CALL_OW 234
120274: GO 120259
120276: POP
120277: POP
// end ;
120278: PPOPN 2
120280: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
120281: LD_EXP 146
120285: PUSH
120286: LD_EXP 195
120290: AND
120291: IFFALSE 120578
120293: GO 120295
120295: DISABLE
120296: LD_INT 0
120298: PPUSH
120299: PPUSH
120300: PPUSH
// begin i := rand ( 1 , 7 ) ;
120301: LD_ADDR_VAR 0 1
120305: PUSH
120306: LD_INT 1
120308: PPUSH
120309: LD_INT 7
120311: PPUSH
120312: CALL_OW 12
120316: ST_TO_ADDR
// case i of 1 :
120317: LD_VAR 0 1
120321: PUSH
120322: LD_INT 1
120324: DOUBLE
120325: EQUAL
120326: IFTRUE 120330
120328: GO 120340
120330: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
120331: LD_STRING earthquake(getX(game), 0, 32)
120333: PPUSH
120334: CALL_OW 559
120338: GO 120578
120340: LD_INT 2
120342: DOUBLE
120343: EQUAL
120344: IFTRUE 120348
120346: GO 120362
120348: POP
// begin ToLua ( displayStucuk(); ) ;
120349: LD_STRING displayStucuk();
120351: PPUSH
120352: CALL_OW 559
// ResetFog ;
120356: CALL_OW 335
// end ; 3 :
120360: GO 120578
120362: LD_INT 3
120364: DOUBLE
120365: EQUAL
120366: IFTRUE 120370
120368: GO 120474
120370: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120371: LD_ADDR_VAR 0 2
120375: PUSH
120376: LD_INT 22
120378: PUSH
120379: LD_OWVAR 2
120383: PUSH
120384: EMPTY
120385: LIST
120386: LIST
120387: PUSH
120388: LD_INT 25
120390: PUSH
120391: LD_INT 1
120393: PUSH
120394: EMPTY
120395: LIST
120396: LIST
120397: PUSH
120398: EMPTY
120399: LIST
120400: LIST
120401: PPUSH
120402: CALL_OW 69
120406: ST_TO_ADDR
// if not tmp then
120407: LD_VAR 0 2
120411: NOT
120412: IFFALSE 120416
// exit ;
120414: GO 120578
// un := tmp [ rand ( 1 , tmp ) ] ;
120416: LD_ADDR_VAR 0 3
120420: PUSH
120421: LD_VAR 0 2
120425: PUSH
120426: LD_INT 1
120428: PPUSH
120429: LD_VAR 0 2
120433: PPUSH
120434: CALL_OW 12
120438: ARRAY
120439: ST_TO_ADDR
// if Crawls ( un ) then
120440: LD_VAR 0 3
120444: PPUSH
120445: CALL_OW 318
120449: IFFALSE 120460
// ComWalk ( un ) ;
120451: LD_VAR 0 3
120455: PPUSH
120456: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120460: LD_VAR 0 3
120464: PPUSH
120465: LD_INT 8
120467: PPUSH
120468: CALL_OW 336
// end ; 4 :
120472: GO 120578
120474: LD_INT 4
120476: DOUBLE
120477: EQUAL
120478: IFTRUE 120482
120480: GO 120556
120482: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120483: LD_ADDR_VAR 0 2
120487: PUSH
120488: LD_INT 22
120490: PUSH
120491: LD_OWVAR 2
120495: PUSH
120496: EMPTY
120497: LIST
120498: LIST
120499: PUSH
120500: LD_INT 30
120502: PUSH
120503: LD_INT 29
120505: PUSH
120506: EMPTY
120507: LIST
120508: LIST
120509: PUSH
120510: EMPTY
120511: LIST
120512: LIST
120513: PPUSH
120514: CALL_OW 69
120518: ST_TO_ADDR
// if not tmp then
120519: LD_VAR 0 2
120523: NOT
120524: IFFALSE 120528
// exit ;
120526: GO 120578
// CenterNowOnUnits ( tmp [ 1 ] ) ;
120528: LD_VAR 0 2
120532: PUSH
120533: LD_INT 1
120535: ARRAY
120536: PPUSH
120537: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
120541: LD_VAR 0 2
120545: PUSH
120546: LD_INT 1
120548: ARRAY
120549: PPUSH
120550: CALL_OW 65
// end ; 5 .. 7 :
120554: GO 120578
120556: LD_INT 5
120558: DOUBLE
120559: GREATEREQUAL
120560: IFFALSE 120568
120562: LD_INT 7
120564: DOUBLE
120565: LESSEQUAL
120566: IFTRUE 120570
120568: GO 120577
120570: POP
// StreamSibBomb ; end ;
120571: CALL 116815 0 0
120575: GO 120578
120577: POP
// end ;
120578: PPOPN 3
120580: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
120581: LD_EXP 146
120585: PUSH
120586: LD_EXP 196
120590: AND
120591: IFFALSE 120747
120593: GO 120595
120595: DISABLE
120596: LD_INT 0
120598: PPUSH
120599: PPUSH
120600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
120601: LD_ADDR_VAR 0 2
120605: PUSH
120606: LD_INT 81
120608: PUSH
120609: LD_OWVAR 2
120613: PUSH
120614: EMPTY
120615: LIST
120616: LIST
120617: PUSH
120618: LD_INT 2
120620: PUSH
120621: LD_INT 21
120623: PUSH
120624: LD_INT 1
120626: PUSH
120627: EMPTY
120628: LIST
120629: LIST
120630: PUSH
120631: LD_INT 21
120633: PUSH
120634: LD_INT 2
120636: PUSH
120637: EMPTY
120638: LIST
120639: LIST
120640: PUSH
120641: EMPTY
120642: LIST
120643: LIST
120644: LIST
120645: PUSH
120646: EMPTY
120647: LIST
120648: LIST
120649: PPUSH
120650: CALL_OW 69
120654: ST_TO_ADDR
// if not tmp then
120655: LD_VAR 0 2
120659: NOT
120660: IFFALSE 120664
// exit ;
120662: GO 120747
// p := 0 ;
120664: LD_ADDR_VAR 0 3
120668: PUSH
120669: LD_INT 0
120671: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120672: LD_INT 35
120674: PPUSH
120675: CALL_OW 67
// p := p + 1 ;
120679: LD_ADDR_VAR 0 3
120683: PUSH
120684: LD_VAR 0 3
120688: PUSH
120689: LD_INT 1
120691: PLUS
120692: ST_TO_ADDR
// for i in tmp do
120693: LD_ADDR_VAR 0 1
120697: PUSH
120698: LD_VAR 0 2
120702: PUSH
120703: FOR_IN
120704: IFFALSE 120735
// if GetLives ( i ) < 1000 then
120706: LD_VAR 0 1
120710: PPUSH
120711: CALL_OW 256
120715: PUSH
120716: LD_INT 1000
120718: LESS
120719: IFFALSE 120733
// SetLives ( i , 1000 ) ;
120721: LD_VAR 0 1
120725: PPUSH
120726: LD_INT 1000
120728: PPUSH
120729: CALL_OW 234
120733: GO 120703
120735: POP
120736: POP
// until p > 20 ;
120737: LD_VAR 0 3
120741: PUSH
120742: LD_INT 20
120744: GREATER
120745: IFFALSE 120672
// end ;
120747: PPOPN 3
120749: END
// every 0 0$1 trigger StreamModeActive and sTime do
120750: LD_EXP 146
120754: PUSH
120755: LD_EXP 197
120759: AND
120760: IFFALSE 120795
120762: GO 120764
120764: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120765: LD_INT 28
120767: PPUSH
120768: LD_OWVAR 2
120772: PPUSH
120773: LD_INT 2
120775: PPUSH
120776: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120780: LD_INT 30
120782: PPUSH
120783: LD_OWVAR 2
120787: PPUSH
120788: LD_INT 2
120790: PPUSH
120791: CALL_OW 322
// end ;
120795: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120796: LD_EXP 146
120800: PUSH
120801: LD_EXP 198
120805: AND
120806: IFFALSE 120927
120808: GO 120810
120810: DISABLE
120811: LD_INT 0
120813: PPUSH
120814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120815: LD_ADDR_VAR 0 2
120819: PUSH
120820: LD_INT 22
120822: PUSH
120823: LD_OWVAR 2
120827: PUSH
120828: EMPTY
120829: LIST
120830: LIST
120831: PUSH
120832: LD_INT 21
120834: PUSH
120835: LD_INT 1
120837: PUSH
120838: EMPTY
120839: LIST
120840: LIST
120841: PUSH
120842: LD_INT 3
120844: PUSH
120845: LD_INT 23
120847: PUSH
120848: LD_INT 0
120850: PUSH
120851: EMPTY
120852: LIST
120853: LIST
120854: PUSH
120855: EMPTY
120856: LIST
120857: LIST
120858: PUSH
120859: EMPTY
120860: LIST
120861: LIST
120862: LIST
120863: PPUSH
120864: CALL_OW 69
120868: ST_TO_ADDR
// if not tmp then
120869: LD_VAR 0 2
120873: NOT
120874: IFFALSE 120878
// exit ;
120876: GO 120927
// for i in tmp do
120878: LD_ADDR_VAR 0 1
120882: PUSH
120883: LD_VAR 0 2
120887: PUSH
120888: FOR_IN
120889: IFFALSE 120925
// begin if Crawls ( i ) then
120891: LD_VAR 0 1
120895: PPUSH
120896: CALL_OW 318
120900: IFFALSE 120911
// ComWalk ( i ) ;
120902: LD_VAR 0 1
120906: PPUSH
120907: CALL_OW 138
// SetClass ( i , 2 ) ;
120911: LD_VAR 0 1
120915: PPUSH
120916: LD_INT 2
120918: PPUSH
120919: CALL_OW 336
// end ;
120923: GO 120888
120925: POP
120926: POP
// end ;
120927: PPOPN 2
120929: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120930: LD_EXP 146
120934: PUSH
120935: LD_EXP 199
120939: AND
120940: IFFALSE 121228
120942: GO 120944
120944: DISABLE
120945: LD_INT 0
120947: PPUSH
120948: PPUSH
120949: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120950: LD_OWVAR 2
120954: PPUSH
120955: LD_INT 9
120957: PPUSH
120958: LD_INT 1
120960: PPUSH
120961: LD_INT 1
120963: PPUSH
120964: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120968: LD_INT 9
120970: PPUSH
120971: LD_OWVAR 2
120975: PPUSH
120976: CALL_OW 343
// uc_side := 9 ;
120980: LD_ADDR_OWVAR 20
120984: PUSH
120985: LD_INT 9
120987: ST_TO_ADDR
// uc_nation := 2 ;
120988: LD_ADDR_OWVAR 21
120992: PUSH
120993: LD_INT 2
120995: ST_TO_ADDR
// hc_name := Dark Warrior ;
120996: LD_ADDR_OWVAR 26
121000: PUSH
121001: LD_STRING Dark Warrior
121003: ST_TO_ADDR
// hc_gallery :=  ;
121004: LD_ADDR_OWVAR 33
121008: PUSH
121009: LD_STRING 
121011: ST_TO_ADDR
// hc_noskilllimit := true ;
121012: LD_ADDR_OWVAR 76
121016: PUSH
121017: LD_INT 1
121019: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
121020: LD_ADDR_OWVAR 31
121024: PUSH
121025: LD_INT 30
121027: PUSH
121028: LD_INT 30
121030: PUSH
121031: LD_INT 30
121033: PUSH
121034: LD_INT 30
121036: PUSH
121037: EMPTY
121038: LIST
121039: LIST
121040: LIST
121041: LIST
121042: ST_TO_ADDR
// un := CreateHuman ;
121043: LD_ADDR_VAR 0 3
121047: PUSH
121048: CALL_OW 44
121052: ST_TO_ADDR
// hc_noskilllimit := false ;
121053: LD_ADDR_OWVAR 76
121057: PUSH
121058: LD_INT 0
121060: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121061: LD_VAR 0 3
121065: PPUSH
121066: LD_INT 1
121068: PPUSH
121069: CALL_OW 51
// ToLua ( playRanger() ) ;
121073: LD_STRING playRanger()
121075: PPUSH
121076: CALL_OW 559
// p := 0 ;
121080: LD_ADDR_VAR 0 2
121084: PUSH
121085: LD_INT 0
121087: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121088: LD_INT 35
121090: PPUSH
121091: CALL_OW 67
// p := p + 1 ;
121095: LD_ADDR_VAR 0 2
121099: PUSH
121100: LD_VAR 0 2
121104: PUSH
121105: LD_INT 1
121107: PLUS
121108: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
121109: LD_VAR 0 3
121113: PPUSH
121114: CALL_OW 256
121118: PUSH
121119: LD_INT 1000
121121: LESS
121122: IFFALSE 121136
// SetLives ( un , 1000 ) ;
121124: LD_VAR 0 3
121128: PPUSH
121129: LD_INT 1000
121131: PPUSH
121132: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
121136: LD_VAR 0 3
121140: PPUSH
121141: LD_INT 81
121143: PUSH
121144: LD_OWVAR 2
121148: PUSH
121149: EMPTY
121150: LIST
121151: LIST
121152: PUSH
121153: LD_INT 91
121155: PUSH
121156: LD_VAR 0 3
121160: PUSH
121161: LD_INT 30
121163: PUSH
121164: EMPTY
121165: LIST
121166: LIST
121167: LIST
121168: PUSH
121169: EMPTY
121170: LIST
121171: LIST
121172: PPUSH
121173: CALL_OW 69
121177: PPUSH
121178: LD_VAR 0 3
121182: PPUSH
121183: CALL_OW 74
121187: PPUSH
121188: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
121192: LD_VAR 0 2
121196: PUSH
121197: LD_INT 80
121199: GREATER
121200: PUSH
121201: LD_VAR 0 3
121205: PPUSH
121206: CALL_OW 301
121210: OR
121211: IFFALSE 121088
// if un then
121213: LD_VAR 0 3
121217: IFFALSE 121228
// RemoveUnit ( un ) ;
121219: LD_VAR 0 3
121223: PPUSH
121224: CALL_OW 64
// end ;
121228: PPOPN 3
121230: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
121231: LD_EXP 200
121235: IFFALSE 121351
121237: GO 121239
121239: DISABLE
121240: LD_INT 0
121242: PPUSH
121243: PPUSH
121244: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
121245: LD_ADDR_VAR 0 2
121249: PUSH
121250: LD_INT 81
121252: PUSH
121253: LD_OWVAR 2
121257: PUSH
121258: EMPTY
121259: LIST
121260: LIST
121261: PUSH
121262: LD_INT 21
121264: PUSH
121265: LD_INT 1
121267: PUSH
121268: EMPTY
121269: LIST
121270: LIST
121271: PUSH
121272: EMPTY
121273: LIST
121274: LIST
121275: PPUSH
121276: CALL_OW 69
121280: ST_TO_ADDR
// ToLua ( playComputer() ) ;
121281: LD_STRING playComputer()
121283: PPUSH
121284: CALL_OW 559
// if not tmp then
121288: LD_VAR 0 2
121292: NOT
121293: IFFALSE 121297
// exit ;
121295: GO 121351
// for i in tmp do
121297: LD_ADDR_VAR 0 1
121301: PUSH
121302: LD_VAR 0 2
121306: PUSH
121307: FOR_IN
121308: IFFALSE 121349
// for j := 1 to 4 do
121310: LD_ADDR_VAR 0 3
121314: PUSH
121315: DOUBLE
121316: LD_INT 1
121318: DEC
121319: ST_TO_ADDR
121320: LD_INT 4
121322: PUSH
121323: FOR_TO
121324: IFFALSE 121345
// SetSkill ( i , j , 10 ) ;
121326: LD_VAR 0 1
121330: PPUSH
121331: LD_VAR 0 3
121335: PPUSH
121336: LD_INT 10
121338: PPUSH
121339: CALL_OW 237
121343: GO 121323
121345: POP
121346: POP
121347: GO 121307
121349: POP
121350: POP
// end ;
121351: PPOPN 3
121353: END
// every 0 0$1 trigger s30 do var i , tmp ;
121354: LD_EXP 201
121358: IFFALSE 121427
121360: GO 121362
121362: DISABLE
121363: LD_INT 0
121365: PPUSH
121366: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121367: LD_ADDR_VAR 0 2
121371: PUSH
121372: LD_INT 22
121374: PUSH
121375: LD_OWVAR 2
121379: PUSH
121380: EMPTY
121381: LIST
121382: LIST
121383: PPUSH
121384: CALL_OW 69
121388: ST_TO_ADDR
// if not tmp then
121389: LD_VAR 0 2
121393: NOT
121394: IFFALSE 121398
// exit ;
121396: GO 121427
// for i in tmp do
121398: LD_ADDR_VAR 0 1
121402: PUSH
121403: LD_VAR 0 2
121407: PUSH
121408: FOR_IN
121409: IFFALSE 121425
// SetLives ( i , 300 ) ;
121411: LD_VAR 0 1
121415: PPUSH
121416: LD_INT 300
121418: PPUSH
121419: CALL_OW 234
121423: GO 121408
121425: POP
121426: POP
// end ;
121427: PPOPN 2
121429: END
// every 0 0$1 trigger s60 do var i , tmp ;
121430: LD_EXP 202
121434: IFFALSE 121503
121436: GO 121438
121438: DISABLE
121439: LD_INT 0
121441: PPUSH
121442: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
121443: LD_ADDR_VAR 0 2
121447: PUSH
121448: LD_INT 22
121450: PUSH
121451: LD_OWVAR 2
121455: PUSH
121456: EMPTY
121457: LIST
121458: LIST
121459: PPUSH
121460: CALL_OW 69
121464: ST_TO_ADDR
// if not tmp then
121465: LD_VAR 0 2
121469: NOT
121470: IFFALSE 121474
// exit ;
121472: GO 121503
// for i in tmp do
121474: LD_ADDR_VAR 0 1
121478: PUSH
121479: LD_VAR 0 2
121483: PUSH
121484: FOR_IN
121485: IFFALSE 121501
// SetLives ( i , 600 ) ;
121487: LD_VAR 0 1
121491: PPUSH
121492: LD_INT 600
121494: PPUSH
121495: CALL_OW 234
121499: GO 121484
121501: POP
121502: POP
// end ;
121503: PPOPN 2
121505: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
121506: LD_INT 0
121508: PPUSH
// case cmd of 301 :
121509: LD_VAR 0 1
121513: PUSH
121514: LD_INT 301
121516: DOUBLE
121517: EQUAL
121518: IFTRUE 121522
121520: GO 121554
121522: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
121523: LD_VAR 0 6
121527: PPUSH
121528: LD_VAR 0 7
121532: PPUSH
121533: LD_VAR 0 8
121537: PPUSH
121538: LD_VAR 0 4
121542: PPUSH
121543: LD_VAR 0 5
121547: PPUSH
121548: CALL 122755 0 5
121552: GO 121675
121554: LD_INT 302
121556: DOUBLE
121557: EQUAL
121558: IFTRUE 121562
121560: GO 121599
121562: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
121563: LD_VAR 0 6
121567: PPUSH
121568: LD_VAR 0 7
121572: PPUSH
121573: LD_VAR 0 8
121577: PPUSH
121578: LD_VAR 0 9
121582: PPUSH
121583: LD_VAR 0 4
121587: PPUSH
121588: LD_VAR 0 5
121592: PPUSH
121593: CALL 122846 0 6
121597: GO 121675
121599: LD_INT 303
121601: DOUBLE
121602: EQUAL
121603: IFTRUE 121607
121605: GO 121644
121607: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
121608: LD_VAR 0 6
121612: PPUSH
121613: LD_VAR 0 7
121617: PPUSH
121618: LD_VAR 0 8
121622: PPUSH
121623: LD_VAR 0 9
121627: PPUSH
121628: LD_VAR 0 4
121632: PPUSH
121633: LD_VAR 0 5
121637: PPUSH
121638: CALL 121680 0 6
121642: GO 121675
121644: LD_INT 304
121646: DOUBLE
121647: EQUAL
121648: IFTRUE 121652
121650: GO 121674
121652: POP
// hHackTeleport ( unit , x , y ) ; end ;
121653: LD_VAR 0 2
121657: PPUSH
121658: LD_VAR 0 4
121662: PPUSH
121663: LD_VAR 0 5
121667: PPUSH
121668: CALL 123439 0 3
121672: GO 121675
121674: POP
// end ;
121675: LD_VAR 0 12
121679: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
121680: LD_INT 0
121682: PPUSH
121683: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
121684: LD_VAR 0 1
121688: PUSH
121689: LD_INT 1
121691: LESS
121692: PUSH
121693: LD_VAR 0 1
121697: PUSH
121698: LD_INT 3
121700: GREATER
121701: OR
121702: PUSH
121703: LD_VAR 0 5
121707: PPUSH
121708: LD_VAR 0 6
121712: PPUSH
121713: CALL_OW 428
121717: OR
121718: IFFALSE 121722
// exit ;
121720: GO 122442
// uc_side := your_side ;
121722: LD_ADDR_OWVAR 20
121726: PUSH
121727: LD_OWVAR 2
121731: ST_TO_ADDR
// uc_nation := nation ;
121732: LD_ADDR_OWVAR 21
121736: PUSH
121737: LD_VAR 0 1
121741: ST_TO_ADDR
// bc_level = 1 ;
121742: LD_ADDR_OWVAR 43
121746: PUSH
121747: LD_INT 1
121749: ST_TO_ADDR
// case btype of 1 :
121750: LD_VAR 0 2
121754: PUSH
121755: LD_INT 1
121757: DOUBLE
121758: EQUAL
121759: IFTRUE 121763
121761: GO 121774
121763: POP
// bc_type := b_depot ; 2 :
121764: LD_ADDR_OWVAR 42
121768: PUSH
121769: LD_INT 0
121771: ST_TO_ADDR
121772: GO 122386
121774: LD_INT 2
121776: DOUBLE
121777: EQUAL
121778: IFTRUE 121782
121780: GO 121793
121782: POP
// bc_type := b_warehouse ; 3 :
121783: LD_ADDR_OWVAR 42
121787: PUSH
121788: LD_INT 1
121790: ST_TO_ADDR
121791: GO 122386
121793: LD_INT 3
121795: DOUBLE
121796: EQUAL
121797: IFTRUE 121801
121799: GO 121812
121801: POP
// bc_type := b_lab ; 4 .. 9 :
121802: LD_ADDR_OWVAR 42
121806: PUSH
121807: LD_INT 6
121809: ST_TO_ADDR
121810: GO 122386
121812: LD_INT 4
121814: DOUBLE
121815: GREATEREQUAL
121816: IFFALSE 121824
121818: LD_INT 9
121820: DOUBLE
121821: LESSEQUAL
121822: IFTRUE 121826
121824: GO 121878
121826: POP
// begin bc_type := b_lab_half ;
121827: LD_ADDR_OWVAR 42
121831: PUSH
121832: LD_INT 7
121834: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121835: LD_ADDR_OWVAR 44
121839: PUSH
121840: LD_INT 10
121842: PUSH
121843: LD_INT 11
121845: PUSH
121846: LD_INT 12
121848: PUSH
121849: LD_INT 15
121851: PUSH
121852: LD_INT 14
121854: PUSH
121855: LD_INT 13
121857: PUSH
121858: EMPTY
121859: LIST
121860: LIST
121861: LIST
121862: LIST
121863: LIST
121864: LIST
121865: PUSH
121866: LD_VAR 0 2
121870: PUSH
121871: LD_INT 3
121873: MINUS
121874: ARRAY
121875: ST_TO_ADDR
// end ; 10 .. 13 :
121876: GO 122386
121878: LD_INT 10
121880: DOUBLE
121881: GREATEREQUAL
121882: IFFALSE 121890
121884: LD_INT 13
121886: DOUBLE
121887: LESSEQUAL
121888: IFTRUE 121892
121890: GO 121969
121892: POP
// begin bc_type := b_lab_full ;
121893: LD_ADDR_OWVAR 42
121897: PUSH
121898: LD_INT 8
121900: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121901: LD_ADDR_OWVAR 44
121905: PUSH
121906: LD_INT 10
121908: PUSH
121909: LD_INT 12
121911: PUSH
121912: LD_INT 14
121914: PUSH
121915: LD_INT 13
121917: PUSH
121918: EMPTY
121919: LIST
121920: LIST
121921: LIST
121922: LIST
121923: PUSH
121924: LD_VAR 0 2
121928: PUSH
121929: LD_INT 9
121931: MINUS
121932: ARRAY
121933: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121934: LD_ADDR_OWVAR 45
121938: PUSH
121939: LD_INT 11
121941: PUSH
121942: LD_INT 15
121944: PUSH
121945: LD_INT 12
121947: PUSH
121948: LD_INT 15
121950: PUSH
121951: EMPTY
121952: LIST
121953: LIST
121954: LIST
121955: LIST
121956: PUSH
121957: LD_VAR 0 2
121961: PUSH
121962: LD_INT 9
121964: MINUS
121965: ARRAY
121966: ST_TO_ADDR
// end ; 14 :
121967: GO 122386
121969: LD_INT 14
121971: DOUBLE
121972: EQUAL
121973: IFTRUE 121977
121975: GO 121988
121977: POP
// bc_type := b_workshop ; 15 :
121978: LD_ADDR_OWVAR 42
121982: PUSH
121983: LD_INT 2
121985: ST_TO_ADDR
121986: GO 122386
121988: LD_INT 15
121990: DOUBLE
121991: EQUAL
121992: IFTRUE 121996
121994: GO 122007
121996: POP
// bc_type := b_factory ; 16 :
121997: LD_ADDR_OWVAR 42
122001: PUSH
122002: LD_INT 3
122004: ST_TO_ADDR
122005: GO 122386
122007: LD_INT 16
122009: DOUBLE
122010: EQUAL
122011: IFTRUE 122015
122013: GO 122026
122015: POP
// bc_type := b_ext_gun ; 17 :
122016: LD_ADDR_OWVAR 42
122020: PUSH
122021: LD_INT 17
122023: ST_TO_ADDR
122024: GO 122386
122026: LD_INT 17
122028: DOUBLE
122029: EQUAL
122030: IFTRUE 122034
122032: GO 122062
122034: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
122035: LD_ADDR_OWVAR 42
122039: PUSH
122040: LD_INT 19
122042: PUSH
122043: LD_INT 23
122045: PUSH
122046: LD_INT 19
122048: PUSH
122049: EMPTY
122050: LIST
122051: LIST
122052: LIST
122053: PUSH
122054: LD_VAR 0 1
122058: ARRAY
122059: ST_TO_ADDR
122060: GO 122386
122062: LD_INT 18
122064: DOUBLE
122065: EQUAL
122066: IFTRUE 122070
122068: GO 122081
122070: POP
// bc_type := b_ext_radar ; 19 :
122071: LD_ADDR_OWVAR 42
122075: PUSH
122076: LD_INT 20
122078: ST_TO_ADDR
122079: GO 122386
122081: LD_INT 19
122083: DOUBLE
122084: EQUAL
122085: IFTRUE 122089
122087: GO 122100
122089: POP
// bc_type := b_ext_radio ; 20 :
122090: LD_ADDR_OWVAR 42
122094: PUSH
122095: LD_INT 22
122097: ST_TO_ADDR
122098: GO 122386
122100: LD_INT 20
122102: DOUBLE
122103: EQUAL
122104: IFTRUE 122108
122106: GO 122119
122108: POP
// bc_type := b_ext_siberium ; 21 :
122109: LD_ADDR_OWVAR 42
122113: PUSH
122114: LD_INT 21
122116: ST_TO_ADDR
122117: GO 122386
122119: LD_INT 21
122121: DOUBLE
122122: EQUAL
122123: IFTRUE 122127
122125: GO 122138
122127: POP
// bc_type := b_ext_computer ; 22 :
122128: LD_ADDR_OWVAR 42
122132: PUSH
122133: LD_INT 24
122135: ST_TO_ADDR
122136: GO 122386
122138: LD_INT 22
122140: DOUBLE
122141: EQUAL
122142: IFTRUE 122146
122144: GO 122157
122146: POP
// bc_type := b_ext_track ; 23 :
122147: LD_ADDR_OWVAR 42
122151: PUSH
122152: LD_INT 16
122154: ST_TO_ADDR
122155: GO 122386
122157: LD_INT 23
122159: DOUBLE
122160: EQUAL
122161: IFTRUE 122165
122163: GO 122176
122165: POP
// bc_type := b_ext_laser ; 24 :
122166: LD_ADDR_OWVAR 42
122170: PUSH
122171: LD_INT 25
122173: ST_TO_ADDR
122174: GO 122386
122176: LD_INT 24
122178: DOUBLE
122179: EQUAL
122180: IFTRUE 122184
122182: GO 122195
122184: POP
// bc_type := b_control_tower ; 25 :
122185: LD_ADDR_OWVAR 42
122189: PUSH
122190: LD_INT 36
122192: ST_TO_ADDR
122193: GO 122386
122195: LD_INT 25
122197: DOUBLE
122198: EQUAL
122199: IFTRUE 122203
122201: GO 122214
122203: POP
// bc_type := b_breastwork ; 26 :
122204: LD_ADDR_OWVAR 42
122208: PUSH
122209: LD_INT 31
122211: ST_TO_ADDR
122212: GO 122386
122214: LD_INT 26
122216: DOUBLE
122217: EQUAL
122218: IFTRUE 122222
122220: GO 122233
122222: POP
// bc_type := b_bunker ; 27 :
122223: LD_ADDR_OWVAR 42
122227: PUSH
122228: LD_INT 32
122230: ST_TO_ADDR
122231: GO 122386
122233: LD_INT 27
122235: DOUBLE
122236: EQUAL
122237: IFTRUE 122241
122239: GO 122252
122241: POP
// bc_type := b_turret ; 28 :
122242: LD_ADDR_OWVAR 42
122246: PUSH
122247: LD_INT 33
122249: ST_TO_ADDR
122250: GO 122386
122252: LD_INT 28
122254: DOUBLE
122255: EQUAL
122256: IFTRUE 122260
122258: GO 122271
122260: POP
// bc_type := b_armoury ; 29 :
122261: LD_ADDR_OWVAR 42
122265: PUSH
122266: LD_INT 4
122268: ST_TO_ADDR
122269: GO 122386
122271: LD_INT 29
122273: DOUBLE
122274: EQUAL
122275: IFTRUE 122279
122277: GO 122290
122279: POP
// bc_type := b_barracks ; 30 :
122280: LD_ADDR_OWVAR 42
122284: PUSH
122285: LD_INT 5
122287: ST_TO_ADDR
122288: GO 122386
122290: LD_INT 30
122292: DOUBLE
122293: EQUAL
122294: IFTRUE 122298
122296: GO 122309
122298: POP
// bc_type := b_solar_power ; 31 :
122299: LD_ADDR_OWVAR 42
122303: PUSH
122304: LD_INT 27
122306: ST_TO_ADDR
122307: GO 122386
122309: LD_INT 31
122311: DOUBLE
122312: EQUAL
122313: IFTRUE 122317
122315: GO 122328
122317: POP
// bc_type := b_oil_power ; 32 :
122318: LD_ADDR_OWVAR 42
122322: PUSH
122323: LD_INT 26
122325: ST_TO_ADDR
122326: GO 122386
122328: LD_INT 32
122330: DOUBLE
122331: EQUAL
122332: IFTRUE 122336
122334: GO 122347
122336: POP
// bc_type := b_siberite_power ; 33 :
122337: LD_ADDR_OWVAR 42
122341: PUSH
122342: LD_INT 28
122344: ST_TO_ADDR
122345: GO 122386
122347: LD_INT 33
122349: DOUBLE
122350: EQUAL
122351: IFTRUE 122355
122353: GO 122366
122355: POP
// bc_type := b_oil_mine ; 34 :
122356: LD_ADDR_OWVAR 42
122360: PUSH
122361: LD_INT 29
122363: ST_TO_ADDR
122364: GO 122386
122366: LD_INT 34
122368: DOUBLE
122369: EQUAL
122370: IFTRUE 122374
122372: GO 122385
122374: POP
// bc_type := b_siberite_mine ; end ;
122375: LD_ADDR_OWVAR 42
122379: PUSH
122380: LD_INT 30
122382: ST_TO_ADDR
122383: GO 122386
122385: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
122386: LD_ADDR_VAR 0 8
122390: PUSH
122391: LD_VAR 0 5
122395: PPUSH
122396: LD_VAR 0 6
122400: PPUSH
122401: LD_VAR 0 3
122405: PPUSH
122406: CALL_OW 47
122410: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
122411: LD_OWVAR 42
122415: PUSH
122416: LD_INT 32
122418: PUSH
122419: LD_INT 33
122421: PUSH
122422: EMPTY
122423: LIST
122424: LIST
122425: IN
122426: IFFALSE 122442
// PlaceWeaponTurret ( b , weapon ) ;
122428: LD_VAR 0 8
122432: PPUSH
122433: LD_VAR 0 4
122437: PPUSH
122438: CALL_OW 431
// end ;
122442: LD_VAR 0 7
122446: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
122447: LD_INT 0
122449: PPUSH
122450: PPUSH
122451: PPUSH
122452: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
122453: LD_ADDR_VAR 0 4
122457: PUSH
122458: LD_INT 22
122460: PUSH
122461: LD_OWVAR 2
122465: PUSH
122466: EMPTY
122467: LIST
122468: LIST
122469: PUSH
122470: LD_INT 2
122472: PUSH
122473: LD_INT 30
122475: PUSH
122476: LD_INT 0
122478: PUSH
122479: EMPTY
122480: LIST
122481: LIST
122482: PUSH
122483: LD_INT 30
122485: PUSH
122486: LD_INT 1
122488: PUSH
122489: EMPTY
122490: LIST
122491: LIST
122492: PUSH
122493: EMPTY
122494: LIST
122495: LIST
122496: LIST
122497: PUSH
122498: EMPTY
122499: LIST
122500: LIST
122501: PPUSH
122502: CALL_OW 69
122506: ST_TO_ADDR
// if not tmp then
122507: LD_VAR 0 4
122511: NOT
122512: IFFALSE 122516
// exit ;
122514: GO 122575
// for i in tmp do
122516: LD_ADDR_VAR 0 2
122520: PUSH
122521: LD_VAR 0 4
122525: PUSH
122526: FOR_IN
122527: IFFALSE 122573
// for j = 1 to 3 do
122529: LD_ADDR_VAR 0 3
122533: PUSH
122534: DOUBLE
122535: LD_INT 1
122537: DEC
122538: ST_TO_ADDR
122539: LD_INT 3
122541: PUSH
122542: FOR_TO
122543: IFFALSE 122569
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
122545: LD_VAR 0 2
122549: PPUSH
122550: CALL_OW 274
122554: PPUSH
122555: LD_VAR 0 3
122559: PPUSH
122560: LD_INT 99999
122562: PPUSH
122563: CALL_OW 277
122567: GO 122542
122569: POP
122570: POP
122571: GO 122526
122573: POP
122574: POP
// end ;
122575: LD_VAR 0 1
122579: RET
// export function hHackSetLevel10 ; var i , j ; begin
122580: LD_INT 0
122582: PPUSH
122583: PPUSH
122584: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122585: LD_ADDR_VAR 0 2
122589: PUSH
122590: LD_INT 21
122592: PUSH
122593: LD_INT 1
122595: PUSH
122596: EMPTY
122597: LIST
122598: LIST
122599: PPUSH
122600: CALL_OW 69
122604: PUSH
122605: FOR_IN
122606: IFFALSE 122658
// if IsSelected ( i ) then
122608: LD_VAR 0 2
122612: PPUSH
122613: CALL_OW 306
122617: IFFALSE 122656
// begin for j := 1 to 4 do
122619: LD_ADDR_VAR 0 3
122623: PUSH
122624: DOUBLE
122625: LD_INT 1
122627: DEC
122628: ST_TO_ADDR
122629: LD_INT 4
122631: PUSH
122632: FOR_TO
122633: IFFALSE 122654
// SetSkill ( i , j , 10 ) ;
122635: LD_VAR 0 2
122639: PPUSH
122640: LD_VAR 0 3
122644: PPUSH
122645: LD_INT 10
122647: PPUSH
122648: CALL_OW 237
122652: GO 122632
122654: POP
122655: POP
// end ;
122656: GO 122605
122658: POP
122659: POP
// end ;
122660: LD_VAR 0 1
122664: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
122665: LD_INT 0
122667: PPUSH
122668: PPUSH
122669: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
122670: LD_ADDR_VAR 0 2
122674: PUSH
122675: LD_INT 22
122677: PUSH
122678: LD_OWVAR 2
122682: PUSH
122683: EMPTY
122684: LIST
122685: LIST
122686: PUSH
122687: LD_INT 21
122689: PUSH
122690: LD_INT 1
122692: PUSH
122693: EMPTY
122694: LIST
122695: LIST
122696: PUSH
122697: EMPTY
122698: LIST
122699: LIST
122700: PPUSH
122701: CALL_OW 69
122705: PUSH
122706: FOR_IN
122707: IFFALSE 122748
// begin for j := 1 to 4 do
122709: LD_ADDR_VAR 0 3
122713: PUSH
122714: DOUBLE
122715: LD_INT 1
122717: DEC
122718: ST_TO_ADDR
122719: LD_INT 4
122721: PUSH
122722: FOR_TO
122723: IFFALSE 122744
// SetSkill ( i , j , 10 ) ;
122725: LD_VAR 0 2
122729: PPUSH
122730: LD_VAR 0 3
122734: PPUSH
122735: LD_INT 10
122737: PPUSH
122738: CALL_OW 237
122742: GO 122722
122744: POP
122745: POP
// end ;
122746: GO 122706
122748: POP
122749: POP
// end ;
122750: LD_VAR 0 1
122754: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122755: LD_INT 0
122757: PPUSH
// uc_side := your_side ;
122758: LD_ADDR_OWVAR 20
122762: PUSH
122763: LD_OWVAR 2
122767: ST_TO_ADDR
// uc_nation := nation ;
122768: LD_ADDR_OWVAR 21
122772: PUSH
122773: LD_VAR 0 1
122777: ST_TO_ADDR
// InitHc ;
122778: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122782: LD_INT 0
122784: PPUSH
122785: LD_VAR 0 2
122789: PPUSH
122790: LD_VAR 0 3
122794: PPUSH
122795: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122799: LD_VAR 0 4
122803: PPUSH
122804: LD_VAR 0 5
122808: PPUSH
122809: CALL_OW 428
122813: PUSH
122814: LD_INT 0
122816: EQUAL
122817: IFFALSE 122841
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122819: CALL_OW 44
122823: PPUSH
122824: LD_VAR 0 4
122828: PPUSH
122829: LD_VAR 0 5
122833: PPUSH
122834: LD_INT 1
122836: PPUSH
122837: CALL_OW 48
// end ;
122841: LD_VAR 0 6
122845: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122846: LD_INT 0
122848: PPUSH
122849: PPUSH
// uc_side := your_side ;
122850: LD_ADDR_OWVAR 20
122854: PUSH
122855: LD_OWVAR 2
122859: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122860: LD_VAR 0 1
122864: PUSH
122865: LD_INT 1
122867: PUSH
122868: LD_INT 2
122870: PUSH
122871: LD_INT 3
122873: PUSH
122874: LD_INT 4
122876: PUSH
122877: LD_INT 5
122879: PUSH
122880: EMPTY
122881: LIST
122882: LIST
122883: LIST
122884: LIST
122885: LIST
122886: IN
122887: IFFALSE 122899
// uc_nation := nation_american else
122889: LD_ADDR_OWVAR 21
122893: PUSH
122894: LD_INT 1
122896: ST_TO_ADDR
122897: GO 122942
// if chassis in [ 11 , 12 , 13 , 14 ] then
122899: LD_VAR 0 1
122903: PUSH
122904: LD_INT 11
122906: PUSH
122907: LD_INT 12
122909: PUSH
122910: LD_INT 13
122912: PUSH
122913: LD_INT 14
122915: PUSH
122916: EMPTY
122917: LIST
122918: LIST
122919: LIST
122920: LIST
122921: IN
122922: IFFALSE 122934
// uc_nation := nation_arabian else
122924: LD_ADDR_OWVAR 21
122928: PUSH
122929: LD_INT 2
122931: ST_TO_ADDR
122932: GO 122942
// uc_nation := nation_russian ;
122934: LD_ADDR_OWVAR 21
122938: PUSH
122939: LD_INT 3
122941: ST_TO_ADDR
// vc_chassis := chassis ;
122942: LD_ADDR_OWVAR 37
122946: PUSH
122947: LD_VAR 0 1
122951: ST_TO_ADDR
// vc_engine := engine ;
122952: LD_ADDR_OWVAR 39
122956: PUSH
122957: LD_VAR 0 2
122961: ST_TO_ADDR
// vc_control := control ;
122962: LD_ADDR_OWVAR 38
122966: PUSH
122967: LD_VAR 0 3
122971: ST_TO_ADDR
// vc_weapon := weapon ;
122972: LD_ADDR_OWVAR 40
122976: PUSH
122977: LD_VAR 0 4
122981: ST_TO_ADDR
// un := CreateVehicle ;
122982: LD_ADDR_VAR 0 8
122986: PUSH
122987: CALL_OW 45
122991: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122992: LD_VAR 0 8
122996: PPUSH
122997: LD_INT 0
122999: PPUSH
123000: LD_INT 5
123002: PPUSH
123003: CALL_OW 12
123007: PPUSH
123008: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
123012: LD_VAR 0 8
123016: PPUSH
123017: LD_VAR 0 5
123021: PPUSH
123022: LD_VAR 0 6
123026: PPUSH
123027: LD_INT 1
123029: PPUSH
123030: CALL_OW 48
// end ;
123034: LD_VAR 0 7
123038: RET
// export hInvincible ; every 1 do
123039: GO 123041
123041: DISABLE
// hInvincible := [ ] ;
123042: LD_ADDR_EXP 203
123046: PUSH
123047: EMPTY
123048: ST_TO_ADDR
123049: END
// every 10 do var i ;
123050: GO 123052
123052: DISABLE
123053: LD_INT 0
123055: PPUSH
// begin enable ;
123056: ENABLE
// if not hInvincible then
123057: LD_EXP 203
123061: NOT
123062: IFFALSE 123066
// exit ;
123064: GO 123110
// for i in hInvincible do
123066: LD_ADDR_VAR 0 1
123070: PUSH
123071: LD_EXP 203
123075: PUSH
123076: FOR_IN
123077: IFFALSE 123108
// if GetLives ( i ) < 1000 then
123079: LD_VAR 0 1
123083: PPUSH
123084: CALL_OW 256
123088: PUSH
123089: LD_INT 1000
123091: LESS
123092: IFFALSE 123106
// SetLives ( i , 1000 ) ;
123094: LD_VAR 0 1
123098: PPUSH
123099: LD_INT 1000
123101: PPUSH
123102: CALL_OW 234
123106: GO 123076
123108: POP
123109: POP
// end ;
123110: PPOPN 1
123112: END
// export function hHackInvincible ; var i ; begin
123113: LD_INT 0
123115: PPUSH
123116: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
123117: LD_ADDR_VAR 0 2
123121: PUSH
123122: LD_INT 2
123124: PUSH
123125: LD_INT 21
123127: PUSH
123128: LD_INT 1
123130: PUSH
123131: EMPTY
123132: LIST
123133: LIST
123134: PUSH
123135: LD_INT 21
123137: PUSH
123138: LD_INT 2
123140: PUSH
123141: EMPTY
123142: LIST
123143: LIST
123144: PUSH
123145: EMPTY
123146: LIST
123147: LIST
123148: LIST
123149: PPUSH
123150: CALL_OW 69
123154: PUSH
123155: FOR_IN
123156: IFFALSE 123217
// if IsSelected ( i ) then
123158: LD_VAR 0 2
123162: PPUSH
123163: CALL_OW 306
123167: IFFALSE 123215
// begin if i in hInvincible then
123169: LD_VAR 0 2
123173: PUSH
123174: LD_EXP 203
123178: IN
123179: IFFALSE 123199
// hInvincible := hInvincible diff i else
123181: LD_ADDR_EXP 203
123185: PUSH
123186: LD_EXP 203
123190: PUSH
123191: LD_VAR 0 2
123195: DIFF
123196: ST_TO_ADDR
123197: GO 123215
// hInvincible := hInvincible union i ;
123199: LD_ADDR_EXP 203
123203: PUSH
123204: LD_EXP 203
123208: PUSH
123209: LD_VAR 0 2
123213: UNION
123214: ST_TO_ADDR
// end ;
123215: GO 123155
123217: POP
123218: POP
// end ;
123219: LD_VAR 0 1
123223: RET
// export function hHackInvisible ; var i , j ; begin
123224: LD_INT 0
123226: PPUSH
123227: PPUSH
123228: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123229: LD_ADDR_VAR 0 2
123233: PUSH
123234: LD_INT 21
123236: PUSH
123237: LD_INT 1
123239: PUSH
123240: EMPTY
123241: LIST
123242: LIST
123243: PPUSH
123244: CALL_OW 69
123248: PUSH
123249: FOR_IN
123250: IFFALSE 123274
// if IsSelected ( i ) then
123252: LD_VAR 0 2
123256: PPUSH
123257: CALL_OW 306
123261: IFFALSE 123272
// ComForceInvisible ( i ) ;
123263: LD_VAR 0 2
123267: PPUSH
123268: CALL_OW 496
123272: GO 123249
123274: POP
123275: POP
// end ;
123276: LD_VAR 0 1
123280: RET
// export function hHackChangeYourSide ; begin
123281: LD_INT 0
123283: PPUSH
// if your_side = 8 then
123284: LD_OWVAR 2
123288: PUSH
123289: LD_INT 8
123291: EQUAL
123292: IFFALSE 123304
// your_side := 0 else
123294: LD_ADDR_OWVAR 2
123298: PUSH
123299: LD_INT 0
123301: ST_TO_ADDR
123302: GO 123318
// your_side := your_side + 1 ;
123304: LD_ADDR_OWVAR 2
123308: PUSH
123309: LD_OWVAR 2
123313: PUSH
123314: LD_INT 1
123316: PLUS
123317: ST_TO_ADDR
// end ;
123318: LD_VAR 0 1
123322: RET
// export function hHackChangeUnitSide ; var i , j ; begin
123323: LD_INT 0
123325: PPUSH
123326: PPUSH
123327: PPUSH
// for i in all_units do
123328: LD_ADDR_VAR 0 2
123332: PUSH
123333: LD_OWVAR 3
123337: PUSH
123338: FOR_IN
123339: IFFALSE 123417
// if IsSelected ( i ) then
123341: LD_VAR 0 2
123345: PPUSH
123346: CALL_OW 306
123350: IFFALSE 123415
// begin j := GetSide ( i ) ;
123352: LD_ADDR_VAR 0 3
123356: PUSH
123357: LD_VAR 0 2
123361: PPUSH
123362: CALL_OW 255
123366: ST_TO_ADDR
// if j = 8 then
123367: LD_VAR 0 3
123371: PUSH
123372: LD_INT 8
123374: EQUAL
123375: IFFALSE 123387
// j := 0 else
123377: LD_ADDR_VAR 0 3
123381: PUSH
123382: LD_INT 0
123384: ST_TO_ADDR
123385: GO 123401
// j := j + 1 ;
123387: LD_ADDR_VAR 0 3
123391: PUSH
123392: LD_VAR 0 3
123396: PUSH
123397: LD_INT 1
123399: PLUS
123400: ST_TO_ADDR
// SetSide ( i , j ) ;
123401: LD_VAR 0 2
123405: PPUSH
123406: LD_VAR 0 3
123410: PPUSH
123411: CALL_OW 235
// end ;
123415: GO 123338
123417: POP
123418: POP
// end ;
123419: LD_VAR 0 1
123423: RET
// export function hHackFog ; begin
123424: LD_INT 0
123426: PPUSH
// FogOff ( true ) ;
123427: LD_INT 1
123429: PPUSH
123430: CALL_OW 344
// end ;
123434: LD_VAR 0 1
123438: RET
// export function hHackTeleport ( unit , x , y ) ; begin
123439: LD_INT 0
123441: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
123442: LD_VAR 0 1
123446: PPUSH
123447: LD_VAR 0 2
123451: PPUSH
123452: LD_VAR 0 3
123456: PPUSH
123457: LD_INT 1
123459: PPUSH
123460: LD_INT 1
123462: PPUSH
123463: CALL_OW 483
// CenterOnXY ( x , y ) ;
123467: LD_VAR 0 2
123471: PPUSH
123472: LD_VAR 0 3
123476: PPUSH
123477: CALL_OW 84
// end ;
123481: LD_VAR 0 4
123485: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
123486: LD_INT 0
123488: PPUSH
123489: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
123490: LD_VAR 0 1
123494: NOT
123495: PUSH
123496: LD_VAR 0 2
123500: PPUSH
123501: LD_VAR 0 3
123505: PPUSH
123506: CALL_OW 488
123510: NOT
123511: OR
123512: PUSH
123513: LD_VAR 0 1
123517: PPUSH
123518: CALL_OW 266
123522: PUSH
123523: LD_INT 3
123525: NONEQUAL
123526: PUSH
123527: LD_VAR 0 1
123531: PPUSH
123532: CALL_OW 247
123536: PUSH
123537: LD_INT 1
123539: EQUAL
123540: NOT
123541: AND
123542: OR
123543: IFFALSE 123547
// exit ;
123545: GO 123696
// if GetType ( factory ) = unit_human then
123547: LD_VAR 0 1
123551: PPUSH
123552: CALL_OW 247
123556: PUSH
123557: LD_INT 1
123559: EQUAL
123560: IFFALSE 123577
// factory := IsInUnit ( factory ) ;
123562: LD_ADDR_VAR 0 1
123566: PUSH
123567: LD_VAR 0 1
123571: PPUSH
123572: CALL_OW 310
123576: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
123577: LD_VAR 0 1
123581: PPUSH
123582: CALL_OW 266
123586: PUSH
123587: LD_INT 3
123589: NONEQUAL
123590: IFFALSE 123594
// exit ;
123592: GO 123696
// if HexInfo ( x , y ) = factory then
123594: LD_VAR 0 2
123598: PPUSH
123599: LD_VAR 0 3
123603: PPUSH
123604: CALL_OW 428
123608: PUSH
123609: LD_VAR 0 1
123613: EQUAL
123614: IFFALSE 123641
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
123616: LD_ADDR_EXP 204
123620: PUSH
123621: LD_EXP 204
123625: PPUSH
123626: LD_VAR 0 1
123630: PPUSH
123631: LD_INT 0
123633: PPUSH
123634: CALL_OW 1
123638: ST_TO_ADDR
123639: GO 123692
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
123641: LD_ADDR_EXP 204
123645: PUSH
123646: LD_EXP 204
123650: PPUSH
123651: LD_VAR 0 1
123655: PPUSH
123656: LD_VAR 0 1
123660: PPUSH
123661: CALL_OW 255
123665: PUSH
123666: LD_VAR 0 1
123670: PUSH
123671: LD_VAR 0 2
123675: PUSH
123676: LD_VAR 0 3
123680: PUSH
123681: EMPTY
123682: LIST
123683: LIST
123684: LIST
123685: LIST
123686: PPUSH
123687: CALL_OW 1
123691: ST_TO_ADDR
// UpdateFactoryWaypoints ;
123692: CALL 123701 0 0
// end ;
123696: LD_VAR 0 4
123700: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123701: LD_INT 0
123703: PPUSH
123704: PPUSH
123705: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123706: LD_STRING resetFactoryWaypoint();
123708: PPUSH
123709: CALL_OW 559
// if factoryWaypoints then
123713: LD_EXP 204
123717: IFFALSE 123843
// begin list := PrepareArray ( factoryWaypoints ) ;
123719: LD_ADDR_VAR 0 3
123723: PUSH
123724: LD_EXP 204
123728: PPUSH
123729: CALL 108808 0 1
123733: ST_TO_ADDR
// for i := 1 to list do
123734: LD_ADDR_VAR 0 2
123738: PUSH
123739: DOUBLE
123740: LD_INT 1
123742: DEC
123743: ST_TO_ADDR
123744: LD_VAR 0 3
123748: PUSH
123749: FOR_TO
123750: IFFALSE 123841
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123752: LD_STRING setFactoryWaypointXY(
123754: PUSH
123755: LD_VAR 0 3
123759: PUSH
123760: LD_VAR 0 2
123764: ARRAY
123765: PUSH
123766: LD_INT 1
123768: ARRAY
123769: STR
123770: PUSH
123771: LD_STRING ,
123773: STR
123774: PUSH
123775: LD_VAR 0 3
123779: PUSH
123780: LD_VAR 0 2
123784: ARRAY
123785: PUSH
123786: LD_INT 2
123788: ARRAY
123789: STR
123790: PUSH
123791: LD_STRING ,
123793: STR
123794: PUSH
123795: LD_VAR 0 3
123799: PUSH
123800: LD_VAR 0 2
123804: ARRAY
123805: PUSH
123806: LD_INT 3
123808: ARRAY
123809: STR
123810: PUSH
123811: LD_STRING ,
123813: STR
123814: PUSH
123815: LD_VAR 0 3
123819: PUSH
123820: LD_VAR 0 2
123824: ARRAY
123825: PUSH
123826: LD_INT 4
123828: ARRAY
123829: STR
123830: PUSH
123831: LD_STRING )
123833: STR
123834: PPUSH
123835: CALL_OW 559
123839: GO 123749
123841: POP
123842: POP
// end ; end ;
123843: LD_VAR 0 1
123847: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123848: LD_INT 0
123850: PPUSH
// if HexInfo ( x , y ) = warehouse then
123851: LD_VAR 0 2
123855: PPUSH
123856: LD_VAR 0 3
123860: PPUSH
123861: CALL_OW 428
123865: PUSH
123866: LD_VAR 0 1
123870: EQUAL
123871: IFFALSE 123898
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123873: LD_ADDR_EXP 205
123877: PUSH
123878: LD_EXP 205
123882: PPUSH
123883: LD_VAR 0 1
123887: PPUSH
123888: LD_INT 0
123890: PPUSH
123891: CALL_OW 1
123895: ST_TO_ADDR
123896: GO 123949
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123898: LD_ADDR_EXP 205
123902: PUSH
123903: LD_EXP 205
123907: PPUSH
123908: LD_VAR 0 1
123912: PPUSH
123913: LD_VAR 0 1
123917: PPUSH
123918: CALL_OW 255
123922: PUSH
123923: LD_VAR 0 1
123927: PUSH
123928: LD_VAR 0 2
123932: PUSH
123933: LD_VAR 0 3
123937: PUSH
123938: EMPTY
123939: LIST
123940: LIST
123941: LIST
123942: LIST
123943: PPUSH
123944: CALL_OW 1
123948: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123949: CALL 123958 0 0
// end ;
123953: LD_VAR 0 4
123957: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123958: LD_INT 0
123960: PPUSH
123961: PPUSH
123962: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123963: LD_STRING resetWarehouseGatheringPoints();
123965: PPUSH
123966: CALL_OW 559
// if warehouseGatheringPoints then
123970: LD_EXP 205
123974: IFFALSE 124100
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123976: LD_ADDR_VAR 0 3
123980: PUSH
123981: LD_EXP 205
123985: PPUSH
123986: CALL 108808 0 1
123990: ST_TO_ADDR
// for i := 1 to list do
123991: LD_ADDR_VAR 0 2
123995: PUSH
123996: DOUBLE
123997: LD_INT 1
123999: DEC
124000: ST_TO_ADDR
124001: LD_VAR 0 3
124005: PUSH
124006: FOR_TO
124007: IFFALSE 124098
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124009: LD_STRING setWarehouseGatheringPointXY(
124011: PUSH
124012: LD_VAR 0 3
124016: PUSH
124017: LD_VAR 0 2
124021: ARRAY
124022: PUSH
124023: LD_INT 1
124025: ARRAY
124026: STR
124027: PUSH
124028: LD_STRING ,
124030: STR
124031: PUSH
124032: LD_VAR 0 3
124036: PUSH
124037: LD_VAR 0 2
124041: ARRAY
124042: PUSH
124043: LD_INT 2
124045: ARRAY
124046: STR
124047: PUSH
124048: LD_STRING ,
124050: STR
124051: PUSH
124052: LD_VAR 0 3
124056: PUSH
124057: LD_VAR 0 2
124061: ARRAY
124062: PUSH
124063: LD_INT 3
124065: ARRAY
124066: STR
124067: PUSH
124068: LD_STRING ,
124070: STR
124071: PUSH
124072: LD_VAR 0 3
124076: PUSH
124077: LD_VAR 0 2
124081: ARRAY
124082: PUSH
124083: LD_INT 4
124085: ARRAY
124086: STR
124087: PUSH
124088: LD_STRING )
124090: STR
124091: PPUSH
124092: CALL_OW 559
124096: GO 124006
124098: POP
124099: POP
// end ; end ;
124100: LD_VAR 0 1
124104: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
124105: LD_EXP 205
124109: IFFALSE 124794
124111: GO 124113
124113: DISABLE
124114: LD_INT 0
124116: PPUSH
124117: PPUSH
124118: PPUSH
124119: PPUSH
124120: PPUSH
124121: PPUSH
124122: PPUSH
124123: PPUSH
124124: PPUSH
// begin enable ;
124125: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
124126: LD_ADDR_VAR 0 3
124130: PUSH
124131: LD_EXP 205
124135: PPUSH
124136: CALL 108808 0 1
124140: ST_TO_ADDR
// if not list then
124141: LD_VAR 0 3
124145: NOT
124146: IFFALSE 124150
// exit ;
124148: GO 124794
// for i := 1 to list do
124150: LD_ADDR_VAR 0 1
124154: PUSH
124155: DOUBLE
124156: LD_INT 1
124158: DEC
124159: ST_TO_ADDR
124160: LD_VAR 0 3
124164: PUSH
124165: FOR_TO
124166: IFFALSE 124792
// begin depot := list [ i ] [ 2 ] ;
124168: LD_ADDR_VAR 0 8
124172: PUSH
124173: LD_VAR 0 3
124177: PUSH
124178: LD_VAR 0 1
124182: ARRAY
124183: PUSH
124184: LD_INT 2
124186: ARRAY
124187: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
124188: LD_ADDR_VAR 0 5
124192: PUSH
124193: LD_VAR 0 3
124197: PUSH
124198: LD_VAR 0 1
124202: ARRAY
124203: PUSH
124204: LD_INT 1
124206: ARRAY
124207: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
124208: LD_VAR 0 8
124212: PPUSH
124213: CALL_OW 301
124217: PUSH
124218: LD_VAR 0 5
124222: PUSH
124223: LD_VAR 0 8
124227: PPUSH
124228: CALL_OW 255
124232: NONEQUAL
124233: OR
124234: IFFALSE 124263
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
124236: LD_ADDR_EXP 205
124240: PUSH
124241: LD_EXP 205
124245: PPUSH
124246: LD_VAR 0 8
124250: PPUSH
124251: LD_INT 0
124253: PPUSH
124254: CALL_OW 1
124258: ST_TO_ADDR
// exit ;
124259: POP
124260: POP
124261: GO 124794
// end ; x := list [ i ] [ 3 ] ;
124263: LD_ADDR_VAR 0 6
124267: PUSH
124268: LD_VAR 0 3
124272: PUSH
124273: LD_VAR 0 1
124277: ARRAY
124278: PUSH
124279: LD_INT 3
124281: ARRAY
124282: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
124283: LD_ADDR_VAR 0 7
124287: PUSH
124288: LD_VAR 0 3
124292: PUSH
124293: LD_VAR 0 1
124297: ARRAY
124298: PUSH
124299: LD_INT 4
124301: ARRAY
124302: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
124303: LD_ADDR_VAR 0 9
124307: PUSH
124308: LD_VAR 0 6
124312: PPUSH
124313: LD_VAR 0 7
124317: PPUSH
124318: LD_INT 16
124320: PPUSH
124321: CALL 107396 0 3
124325: ST_TO_ADDR
// if not cratesNearbyPoint then
124326: LD_VAR 0 9
124330: NOT
124331: IFFALSE 124337
// exit ;
124333: POP
124334: POP
124335: GO 124794
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
124337: LD_ADDR_VAR 0 4
124341: PUSH
124342: LD_INT 22
124344: PUSH
124345: LD_VAR 0 5
124349: PUSH
124350: EMPTY
124351: LIST
124352: LIST
124353: PUSH
124354: LD_INT 3
124356: PUSH
124357: LD_INT 60
124359: PUSH
124360: EMPTY
124361: LIST
124362: PUSH
124363: EMPTY
124364: LIST
124365: LIST
124366: PUSH
124367: LD_INT 91
124369: PUSH
124370: LD_VAR 0 8
124374: PUSH
124375: LD_INT 6
124377: PUSH
124378: EMPTY
124379: LIST
124380: LIST
124381: LIST
124382: PUSH
124383: LD_INT 2
124385: PUSH
124386: LD_INT 25
124388: PUSH
124389: LD_INT 2
124391: PUSH
124392: EMPTY
124393: LIST
124394: LIST
124395: PUSH
124396: LD_INT 25
124398: PUSH
124399: LD_INT 16
124401: PUSH
124402: EMPTY
124403: LIST
124404: LIST
124405: PUSH
124406: EMPTY
124407: LIST
124408: LIST
124409: LIST
124410: PUSH
124411: EMPTY
124412: LIST
124413: LIST
124414: LIST
124415: LIST
124416: PPUSH
124417: CALL_OW 69
124421: PUSH
124422: LD_VAR 0 8
124426: PPUSH
124427: CALL_OW 313
124431: PPUSH
124432: LD_INT 3
124434: PUSH
124435: LD_INT 60
124437: PUSH
124438: EMPTY
124439: LIST
124440: PUSH
124441: EMPTY
124442: LIST
124443: LIST
124444: PUSH
124445: LD_INT 2
124447: PUSH
124448: LD_INT 25
124450: PUSH
124451: LD_INT 2
124453: PUSH
124454: EMPTY
124455: LIST
124456: LIST
124457: PUSH
124458: LD_INT 25
124460: PUSH
124461: LD_INT 16
124463: PUSH
124464: EMPTY
124465: LIST
124466: LIST
124467: PUSH
124468: EMPTY
124469: LIST
124470: LIST
124471: LIST
124472: PUSH
124473: EMPTY
124474: LIST
124475: LIST
124476: PPUSH
124477: CALL_OW 72
124481: UNION
124482: ST_TO_ADDR
// if tmp then
124483: LD_VAR 0 4
124487: IFFALSE 124567
// begin tmp := ShrinkArray ( tmp , 3 ) ;
124489: LD_ADDR_VAR 0 4
124493: PUSH
124494: LD_VAR 0 4
124498: PPUSH
124499: LD_INT 3
124501: PPUSH
124502: CALL 105365 0 2
124506: ST_TO_ADDR
// for j in tmp do
124507: LD_ADDR_VAR 0 2
124511: PUSH
124512: LD_VAR 0 4
124516: PUSH
124517: FOR_IN
124518: IFFALSE 124561
// begin if IsInUnit ( j ) then
124520: LD_VAR 0 2
124524: PPUSH
124525: CALL_OW 310
124529: IFFALSE 124540
// ComExit ( j ) ;
124531: LD_VAR 0 2
124535: PPUSH
124536: CALL 105448 0 1
// AddComCollect ( j , x , y ) ;
124540: LD_VAR 0 2
124544: PPUSH
124545: LD_VAR 0 6
124549: PPUSH
124550: LD_VAR 0 7
124554: PPUSH
124555: CALL_OW 177
// end ;
124559: GO 124517
124561: POP
124562: POP
// exit ;
124563: POP
124564: POP
124565: GO 124794
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
124567: LD_ADDR_VAR 0 4
124571: PUSH
124572: LD_INT 22
124574: PUSH
124575: LD_VAR 0 5
124579: PUSH
124580: EMPTY
124581: LIST
124582: LIST
124583: PUSH
124584: LD_INT 91
124586: PUSH
124587: LD_VAR 0 8
124591: PUSH
124592: LD_INT 8
124594: PUSH
124595: EMPTY
124596: LIST
124597: LIST
124598: LIST
124599: PUSH
124600: LD_INT 2
124602: PUSH
124603: LD_INT 34
124605: PUSH
124606: LD_INT 12
124608: PUSH
124609: EMPTY
124610: LIST
124611: LIST
124612: PUSH
124613: LD_INT 34
124615: PUSH
124616: LD_INT 51
124618: PUSH
124619: EMPTY
124620: LIST
124621: LIST
124622: PUSH
124623: LD_INT 34
124625: PUSH
124626: LD_INT 32
124628: PUSH
124629: EMPTY
124630: LIST
124631: LIST
124632: PUSH
124633: LD_INT 34
124635: PUSH
124636: LD_INT 89
124638: PUSH
124639: EMPTY
124640: LIST
124641: LIST
124642: PUSH
124643: EMPTY
124644: LIST
124645: LIST
124646: LIST
124647: LIST
124648: LIST
124649: PUSH
124650: EMPTY
124651: LIST
124652: LIST
124653: LIST
124654: PPUSH
124655: CALL_OW 69
124659: ST_TO_ADDR
// if tmp then
124660: LD_VAR 0 4
124664: IFFALSE 124790
// begin for j in tmp do
124666: LD_ADDR_VAR 0 2
124670: PUSH
124671: LD_VAR 0 4
124675: PUSH
124676: FOR_IN
124677: IFFALSE 124788
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
124679: LD_VAR 0 2
124683: PPUSH
124684: CALL_OW 262
124688: PUSH
124689: LD_INT 3
124691: EQUAL
124692: PUSH
124693: LD_VAR 0 2
124697: PPUSH
124698: CALL_OW 261
124702: PUSH
124703: LD_INT 20
124705: GREATER
124706: OR
124707: PUSH
124708: LD_VAR 0 2
124712: PPUSH
124713: CALL_OW 314
124717: NOT
124718: AND
124719: PUSH
124720: LD_VAR 0 2
124724: PPUSH
124725: CALL_OW 263
124729: PUSH
124730: LD_INT 1
124732: NONEQUAL
124733: PUSH
124734: LD_VAR 0 2
124738: PPUSH
124739: CALL_OW 311
124743: OR
124744: AND
124745: IFFALSE 124786
// begin ComCollect ( j , x , y ) ;
124747: LD_VAR 0 2
124751: PPUSH
124752: LD_VAR 0 6
124756: PPUSH
124757: LD_VAR 0 7
124761: PPUSH
124762: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124766: LD_VAR 0 2
124770: PPUSH
124771: LD_VAR 0 8
124775: PPUSH
124776: CALL_OW 172
// exit ;
124780: POP
124781: POP
124782: POP
124783: POP
124784: GO 124794
// end ;
124786: GO 124676
124788: POP
124789: POP
// end ; end ;
124790: GO 124165
124792: POP
124793: POP
// end ; end_of_file
124794: PPOPN 9
124796: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124797: LD_INT 0
124799: PPUSH
124800: PPUSH
124801: PPUSH
124802: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124803: LD_VAR 0 1
124807: PPUSH
124808: CALL_OW 264
124812: PUSH
124813: LD_INT 91
124815: EQUAL
124816: IFFALSE 124888
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124818: LD_INT 68
124820: PPUSH
124821: LD_VAR 0 1
124825: PPUSH
124826: CALL_OW 255
124830: PPUSH
124831: CALL_OW 321
124835: PUSH
124836: LD_INT 2
124838: EQUAL
124839: IFFALSE 124851
// eff := 70 else
124841: LD_ADDR_VAR 0 4
124845: PUSH
124846: LD_INT 70
124848: ST_TO_ADDR
124849: GO 124859
// eff := 30 ;
124851: LD_ADDR_VAR 0 4
124855: PUSH
124856: LD_INT 30
124858: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124859: LD_VAR 0 1
124863: PPUSH
124864: CALL_OW 250
124868: PPUSH
124869: LD_VAR 0 1
124873: PPUSH
124874: CALL_OW 251
124878: PPUSH
124879: LD_VAR 0 4
124883: PPUSH
124884: CALL_OW 495
// end ; end ;
124888: LD_VAR 0 2
124892: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124893: LD_INT 0
124895: PPUSH
// end ;
124896: LD_VAR 0 4
124900: RET
// export function SOS_Command ( cmd ) ; begin
124901: LD_INT 0
124903: PPUSH
// end ;
124904: LD_VAR 0 2
124908: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124909: LD_INT 0
124911: PPUSH
// end ;
124912: LD_VAR 0 6
124916: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124917: LD_INT 0
124919: PPUSH
124920: PPUSH
// if not vehicle or not factory then
124921: LD_VAR 0 1
124925: NOT
124926: PUSH
124927: LD_VAR 0 2
124931: NOT
124932: OR
124933: IFFALSE 124937
// exit ;
124935: GO 125168
// if factoryWaypoints >= factory then
124937: LD_EXP 204
124941: PUSH
124942: LD_VAR 0 2
124946: GREATEREQUAL
124947: IFFALSE 125168
// if factoryWaypoints [ factory ] then
124949: LD_EXP 204
124953: PUSH
124954: LD_VAR 0 2
124958: ARRAY
124959: IFFALSE 125168
// begin if GetControl ( vehicle ) = control_manual then
124961: LD_VAR 0 1
124965: PPUSH
124966: CALL_OW 263
124970: PUSH
124971: LD_INT 1
124973: EQUAL
124974: IFFALSE 125055
// begin driver := IsDrivenBy ( vehicle ) ;
124976: LD_ADDR_VAR 0 4
124980: PUSH
124981: LD_VAR 0 1
124985: PPUSH
124986: CALL_OW 311
124990: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124991: LD_VAR 0 4
124995: PPUSH
124996: LD_EXP 204
125000: PUSH
125001: LD_VAR 0 2
125005: ARRAY
125006: PUSH
125007: LD_INT 3
125009: ARRAY
125010: PPUSH
125011: LD_EXP 204
125015: PUSH
125016: LD_VAR 0 2
125020: ARRAY
125021: PUSH
125022: LD_INT 4
125024: ARRAY
125025: PPUSH
125026: CALL_OW 171
// AddComExitVehicle ( driver ) ;
125030: LD_VAR 0 4
125034: PPUSH
125035: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
125039: LD_VAR 0 4
125043: PPUSH
125044: LD_VAR 0 2
125048: PPUSH
125049: CALL_OW 180
// end else
125053: GO 125168
// if GetControl ( vehicle ) = control_remote then
125055: LD_VAR 0 1
125059: PPUSH
125060: CALL_OW 263
125064: PUSH
125065: LD_INT 2
125067: EQUAL
125068: IFFALSE 125129
// begin wait ( 0 0$2 ) ;
125070: LD_INT 70
125072: PPUSH
125073: CALL_OW 67
// if Connect ( vehicle ) then
125077: LD_VAR 0 1
125081: PPUSH
125082: CALL 75688 0 1
125086: IFFALSE 125127
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125088: LD_VAR 0 1
125092: PPUSH
125093: LD_EXP 204
125097: PUSH
125098: LD_VAR 0 2
125102: ARRAY
125103: PUSH
125104: LD_INT 3
125106: ARRAY
125107: PPUSH
125108: LD_EXP 204
125112: PUSH
125113: LD_VAR 0 2
125117: ARRAY
125118: PUSH
125119: LD_INT 4
125121: ARRAY
125122: PPUSH
125123: CALL_OW 171
// end else
125127: GO 125168
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125129: LD_VAR 0 1
125133: PPUSH
125134: LD_EXP 204
125138: PUSH
125139: LD_VAR 0 2
125143: ARRAY
125144: PUSH
125145: LD_INT 3
125147: ARRAY
125148: PPUSH
125149: LD_EXP 204
125153: PUSH
125154: LD_VAR 0 2
125158: ARRAY
125159: PUSH
125160: LD_INT 4
125162: ARRAY
125163: PPUSH
125164: CALL_OW 171
// end ; end ;
125168: LD_VAR 0 3
125172: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
125173: LD_INT 0
125175: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
125176: LD_VAR 0 1
125180: PUSH
125181: LD_INT 250
125183: EQUAL
125184: PUSH
125185: LD_VAR 0 2
125189: PPUSH
125190: CALL_OW 264
125194: PUSH
125195: LD_INT 81
125197: EQUAL
125198: AND
125199: IFFALSE 125220
// MinerPlaceMine ( unit , x , y ) ;
125201: LD_VAR 0 2
125205: PPUSH
125206: LD_VAR 0 4
125210: PPUSH
125211: LD_VAR 0 5
125215: PPUSH
125216: CALL 127605 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
125220: LD_VAR 0 1
125224: PUSH
125225: LD_INT 251
125227: EQUAL
125228: PUSH
125229: LD_VAR 0 2
125233: PPUSH
125234: CALL_OW 264
125238: PUSH
125239: LD_INT 81
125241: EQUAL
125242: AND
125243: IFFALSE 125264
// MinerDetonateMine ( unit , x , y ) ;
125245: LD_VAR 0 2
125249: PPUSH
125250: LD_VAR 0 4
125254: PPUSH
125255: LD_VAR 0 5
125259: PPUSH
125260: CALL 127880 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
125264: LD_VAR 0 1
125268: PUSH
125269: LD_INT 252
125271: EQUAL
125272: PUSH
125273: LD_VAR 0 2
125277: PPUSH
125278: CALL_OW 264
125282: PUSH
125283: LD_INT 81
125285: EQUAL
125286: AND
125287: IFFALSE 125308
// MinerCreateMinefield ( unit , x , y ) ;
125289: LD_VAR 0 2
125293: PPUSH
125294: LD_VAR 0 4
125298: PPUSH
125299: LD_VAR 0 5
125303: PPUSH
125304: CALL 128297 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
125308: LD_VAR 0 1
125312: PUSH
125313: LD_INT 253
125315: EQUAL
125316: PUSH
125317: LD_VAR 0 2
125321: PPUSH
125322: CALL_OW 257
125326: PUSH
125327: LD_INT 5
125329: EQUAL
125330: AND
125331: IFFALSE 125352
// ComBinocular ( unit , x , y ) ;
125333: LD_VAR 0 2
125337: PPUSH
125338: LD_VAR 0 4
125342: PPUSH
125343: LD_VAR 0 5
125347: PPUSH
125348: CALL 128666 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
125352: LD_VAR 0 1
125356: PUSH
125357: LD_INT 254
125359: EQUAL
125360: PUSH
125361: LD_VAR 0 2
125365: PPUSH
125366: CALL_OW 264
125370: PUSH
125371: LD_INT 99
125373: EQUAL
125374: AND
125375: PUSH
125376: LD_VAR 0 3
125380: PPUSH
125381: CALL_OW 263
125385: PUSH
125386: LD_INT 3
125388: EQUAL
125389: AND
125390: IFFALSE 125406
// HackDestroyVehicle ( unit , selectedUnit ) ;
125392: LD_VAR 0 2
125396: PPUSH
125397: LD_VAR 0 3
125401: PPUSH
125402: CALL 126969 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
125406: LD_VAR 0 1
125410: PUSH
125411: LD_INT 255
125413: EQUAL
125414: PUSH
125415: LD_VAR 0 2
125419: PPUSH
125420: CALL_OW 264
125424: PUSH
125425: LD_INT 14
125427: PUSH
125428: LD_INT 53
125430: PUSH
125431: EMPTY
125432: LIST
125433: LIST
125434: IN
125435: AND
125436: PUSH
125437: LD_VAR 0 4
125441: PPUSH
125442: LD_VAR 0 5
125446: PPUSH
125447: CALL_OW 488
125451: AND
125452: IFFALSE 125476
// CutTreeXYR ( unit , x , y , 12 ) ;
125454: LD_VAR 0 2
125458: PPUSH
125459: LD_VAR 0 4
125463: PPUSH
125464: LD_VAR 0 5
125468: PPUSH
125469: LD_INT 12
125471: PPUSH
125472: CALL 125539 0 4
// if cmd = 256 then
125476: LD_VAR 0 1
125480: PUSH
125481: LD_INT 256
125483: EQUAL
125484: IFFALSE 125505
// SetFactoryWaypoint ( unit , x , y ) ;
125486: LD_VAR 0 2
125490: PPUSH
125491: LD_VAR 0 4
125495: PPUSH
125496: LD_VAR 0 5
125500: PPUSH
125501: CALL 123486 0 3
// if cmd = 257 then
125505: LD_VAR 0 1
125509: PUSH
125510: LD_INT 257
125512: EQUAL
125513: IFFALSE 125534
// SetWarehouseGatheringPoint ( unit , x , y ) ;
125515: LD_VAR 0 2
125519: PPUSH
125520: LD_VAR 0 4
125524: PPUSH
125525: LD_VAR 0 5
125529: PPUSH
125530: CALL 123848 0 3
// end ;
125534: LD_VAR 0 6
125538: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
125539: LD_INT 0
125541: PPUSH
125542: PPUSH
125543: PPUSH
125544: PPUSH
125545: PPUSH
125546: PPUSH
125547: PPUSH
125548: PPUSH
125549: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
125550: LD_VAR 0 1
125554: NOT
125555: PUSH
125556: LD_VAR 0 2
125560: PPUSH
125561: LD_VAR 0 3
125565: PPUSH
125566: CALL_OW 488
125570: NOT
125571: OR
125572: PUSH
125573: LD_VAR 0 4
125577: NOT
125578: OR
125579: IFFALSE 125583
// exit ;
125581: GO 125923
// list := [ ] ;
125583: LD_ADDR_VAR 0 13
125587: PUSH
125588: EMPTY
125589: ST_TO_ADDR
// if x - r < 0 then
125590: LD_VAR 0 2
125594: PUSH
125595: LD_VAR 0 4
125599: MINUS
125600: PUSH
125601: LD_INT 0
125603: LESS
125604: IFFALSE 125616
// min_x := 0 else
125606: LD_ADDR_VAR 0 7
125610: PUSH
125611: LD_INT 0
125613: ST_TO_ADDR
125614: GO 125632
// min_x := x - r ;
125616: LD_ADDR_VAR 0 7
125620: PUSH
125621: LD_VAR 0 2
125625: PUSH
125626: LD_VAR 0 4
125630: MINUS
125631: ST_TO_ADDR
// if y - r < 0 then
125632: LD_VAR 0 3
125636: PUSH
125637: LD_VAR 0 4
125641: MINUS
125642: PUSH
125643: LD_INT 0
125645: LESS
125646: IFFALSE 125658
// min_y := 0 else
125648: LD_ADDR_VAR 0 8
125652: PUSH
125653: LD_INT 0
125655: ST_TO_ADDR
125656: GO 125674
// min_y := y - r ;
125658: LD_ADDR_VAR 0 8
125662: PUSH
125663: LD_VAR 0 3
125667: PUSH
125668: LD_VAR 0 4
125672: MINUS
125673: ST_TO_ADDR
// max_x := x + r ;
125674: LD_ADDR_VAR 0 9
125678: PUSH
125679: LD_VAR 0 2
125683: PUSH
125684: LD_VAR 0 4
125688: PLUS
125689: ST_TO_ADDR
// max_y := y + r ;
125690: LD_ADDR_VAR 0 10
125694: PUSH
125695: LD_VAR 0 3
125699: PUSH
125700: LD_VAR 0 4
125704: PLUS
125705: ST_TO_ADDR
// for _x = min_x to max_x do
125706: LD_ADDR_VAR 0 11
125710: PUSH
125711: DOUBLE
125712: LD_VAR 0 7
125716: DEC
125717: ST_TO_ADDR
125718: LD_VAR 0 9
125722: PUSH
125723: FOR_TO
125724: IFFALSE 125841
// for _y = min_y to max_y do
125726: LD_ADDR_VAR 0 12
125730: PUSH
125731: DOUBLE
125732: LD_VAR 0 8
125736: DEC
125737: ST_TO_ADDR
125738: LD_VAR 0 10
125742: PUSH
125743: FOR_TO
125744: IFFALSE 125837
// begin if not ValidHex ( _x , _y ) then
125746: LD_VAR 0 11
125750: PPUSH
125751: LD_VAR 0 12
125755: PPUSH
125756: CALL_OW 488
125760: NOT
125761: IFFALSE 125765
// continue ;
125763: GO 125743
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125765: LD_VAR 0 11
125769: PPUSH
125770: LD_VAR 0 12
125774: PPUSH
125775: CALL_OW 351
125779: PUSH
125780: LD_VAR 0 11
125784: PPUSH
125785: LD_VAR 0 12
125789: PPUSH
125790: CALL_OW 554
125794: AND
125795: IFFALSE 125835
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125797: LD_ADDR_VAR 0 13
125801: PUSH
125802: LD_VAR 0 13
125806: PPUSH
125807: LD_VAR 0 13
125811: PUSH
125812: LD_INT 1
125814: PLUS
125815: PPUSH
125816: LD_VAR 0 11
125820: PUSH
125821: LD_VAR 0 12
125825: PUSH
125826: EMPTY
125827: LIST
125828: LIST
125829: PPUSH
125830: CALL_OW 2
125834: ST_TO_ADDR
// end ;
125835: GO 125743
125837: POP
125838: POP
125839: GO 125723
125841: POP
125842: POP
// if not list then
125843: LD_VAR 0 13
125847: NOT
125848: IFFALSE 125852
// exit ;
125850: GO 125923
// for i in list do
125852: LD_ADDR_VAR 0 6
125856: PUSH
125857: LD_VAR 0 13
125861: PUSH
125862: FOR_IN
125863: IFFALSE 125921
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125865: LD_VAR 0 1
125869: PPUSH
125870: LD_STRING M
125872: PUSH
125873: LD_VAR 0 6
125877: PUSH
125878: LD_INT 1
125880: ARRAY
125881: PUSH
125882: LD_VAR 0 6
125886: PUSH
125887: LD_INT 2
125889: ARRAY
125890: PUSH
125891: LD_INT 0
125893: PUSH
125894: LD_INT 0
125896: PUSH
125897: LD_INT 0
125899: PUSH
125900: LD_INT 0
125902: PUSH
125903: EMPTY
125904: LIST
125905: LIST
125906: LIST
125907: LIST
125908: LIST
125909: LIST
125910: LIST
125911: PUSH
125912: EMPTY
125913: LIST
125914: PPUSH
125915: CALL_OW 447
125919: GO 125862
125921: POP
125922: POP
// end ;
125923: LD_VAR 0 5
125927: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125928: LD_EXP 207
125932: NOT
125933: IFFALSE 125983
125935: GO 125937
125937: DISABLE
// begin initHack := true ;
125938: LD_ADDR_EXP 207
125942: PUSH
125943: LD_INT 1
125945: ST_TO_ADDR
// hackTanks := [ ] ;
125946: LD_ADDR_EXP 208
125950: PUSH
125951: EMPTY
125952: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125953: LD_ADDR_EXP 209
125957: PUSH
125958: EMPTY
125959: ST_TO_ADDR
// hackLimit := 3 ;
125960: LD_ADDR_EXP 210
125964: PUSH
125965: LD_INT 3
125967: ST_TO_ADDR
// hackDist := 12 ;
125968: LD_ADDR_EXP 211
125972: PUSH
125973: LD_INT 12
125975: ST_TO_ADDR
// hackCounter := [ ] ;
125976: LD_ADDR_EXP 212
125980: PUSH
125981: EMPTY
125982: ST_TO_ADDR
// end ;
125983: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125984: LD_EXP 207
125988: PUSH
125989: LD_INT 34
125991: PUSH
125992: LD_INT 99
125994: PUSH
125995: EMPTY
125996: LIST
125997: LIST
125998: PPUSH
125999: CALL_OW 69
126003: AND
126004: IFFALSE 126257
126006: GO 126008
126008: DISABLE
126009: LD_INT 0
126011: PPUSH
126012: PPUSH
// begin enable ;
126013: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
126014: LD_ADDR_VAR 0 1
126018: PUSH
126019: LD_INT 34
126021: PUSH
126022: LD_INT 99
126024: PUSH
126025: EMPTY
126026: LIST
126027: LIST
126028: PPUSH
126029: CALL_OW 69
126033: PUSH
126034: FOR_IN
126035: IFFALSE 126255
// begin if not i in hackTanks then
126037: LD_VAR 0 1
126041: PUSH
126042: LD_EXP 208
126046: IN
126047: NOT
126048: IFFALSE 126131
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
126050: LD_ADDR_EXP 208
126054: PUSH
126055: LD_EXP 208
126059: PPUSH
126060: LD_EXP 208
126064: PUSH
126065: LD_INT 1
126067: PLUS
126068: PPUSH
126069: LD_VAR 0 1
126073: PPUSH
126074: CALL_OW 1
126078: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
126079: LD_ADDR_EXP 209
126083: PUSH
126084: LD_EXP 209
126088: PPUSH
126089: LD_EXP 209
126093: PUSH
126094: LD_INT 1
126096: PLUS
126097: PPUSH
126098: EMPTY
126099: PPUSH
126100: CALL_OW 1
126104: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
126105: LD_ADDR_EXP 212
126109: PUSH
126110: LD_EXP 212
126114: PPUSH
126115: LD_EXP 212
126119: PUSH
126120: LD_INT 1
126122: PLUS
126123: PPUSH
126124: EMPTY
126125: PPUSH
126126: CALL_OW 1
126130: ST_TO_ADDR
// end ; if not IsOk ( i ) then
126131: LD_VAR 0 1
126135: PPUSH
126136: CALL_OW 302
126140: NOT
126141: IFFALSE 126154
// begin HackUnlinkAll ( i ) ;
126143: LD_VAR 0 1
126147: PPUSH
126148: CALL 126260 0 1
// continue ;
126152: GO 126034
// end ; HackCheckCapturedStatus ( i ) ;
126154: LD_VAR 0 1
126158: PPUSH
126159: CALL 126703 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
126163: LD_ADDR_VAR 0 2
126167: PUSH
126168: LD_INT 81
126170: PUSH
126171: LD_VAR 0 1
126175: PPUSH
126176: CALL_OW 255
126180: PUSH
126181: EMPTY
126182: LIST
126183: LIST
126184: PUSH
126185: LD_INT 33
126187: PUSH
126188: LD_INT 3
126190: PUSH
126191: EMPTY
126192: LIST
126193: LIST
126194: PUSH
126195: LD_INT 91
126197: PUSH
126198: LD_VAR 0 1
126202: PUSH
126203: LD_EXP 211
126207: PUSH
126208: EMPTY
126209: LIST
126210: LIST
126211: LIST
126212: PUSH
126213: LD_INT 50
126215: PUSH
126216: EMPTY
126217: LIST
126218: PUSH
126219: EMPTY
126220: LIST
126221: LIST
126222: LIST
126223: LIST
126224: PPUSH
126225: CALL_OW 69
126229: ST_TO_ADDR
// if not tmp then
126230: LD_VAR 0 2
126234: NOT
126235: IFFALSE 126239
// continue ;
126237: GO 126034
// HackLink ( i , tmp ) ;
126239: LD_VAR 0 1
126243: PPUSH
126244: LD_VAR 0 2
126248: PPUSH
126249: CALL 126396 0 2
// end ;
126253: GO 126034
126255: POP
126256: POP
// end ;
126257: PPOPN 2
126259: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
126260: LD_INT 0
126262: PPUSH
126263: PPUSH
126264: PPUSH
// if not hack in hackTanks then
126265: LD_VAR 0 1
126269: PUSH
126270: LD_EXP 208
126274: IN
126275: NOT
126276: IFFALSE 126280
// exit ;
126278: GO 126391
// index := GetElementIndex ( hackTanks , hack ) ;
126280: LD_ADDR_VAR 0 4
126284: PUSH
126285: LD_EXP 208
126289: PPUSH
126290: LD_VAR 0 1
126294: PPUSH
126295: CALL 72504 0 2
126299: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
126300: LD_EXP 209
126304: PUSH
126305: LD_VAR 0 4
126309: ARRAY
126310: IFFALSE 126391
// begin for i in hackTanksCaptured [ index ] do
126312: LD_ADDR_VAR 0 3
126316: PUSH
126317: LD_EXP 209
126321: PUSH
126322: LD_VAR 0 4
126326: ARRAY
126327: PUSH
126328: FOR_IN
126329: IFFALSE 126355
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
126331: LD_VAR 0 3
126335: PUSH
126336: LD_INT 1
126338: ARRAY
126339: PPUSH
126340: LD_VAR 0 3
126344: PUSH
126345: LD_INT 2
126347: ARRAY
126348: PPUSH
126349: CALL_OW 235
126353: GO 126328
126355: POP
126356: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
126357: LD_ADDR_EXP 209
126361: PUSH
126362: LD_EXP 209
126366: PPUSH
126367: LD_VAR 0 4
126371: PPUSH
126372: EMPTY
126373: PPUSH
126374: CALL_OW 1
126378: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
126379: LD_VAR 0 1
126383: PPUSH
126384: LD_INT 0
126386: PPUSH
126387: CALL_OW 505
// end ; end ;
126391: LD_VAR 0 2
126395: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
126396: LD_INT 0
126398: PPUSH
126399: PPUSH
126400: PPUSH
// if not hack in hackTanks or not vehicles then
126401: LD_VAR 0 1
126405: PUSH
126406: LD_EXP 208
126410: IN
126411: NOT
126412: PUSH
126413: LD_VAR 0 2
126417: NOT
126418: OR
126419: IFFALSE 126423
// exit ;
126421: GO 126698
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
126423: LD_ADDR_VAR 0 2
126427: PUSH
126428: LD_VAR 0 1
126432: PPUSH
126433: LD_VAR 0 2
126437: PPUSH
126438: LD_INT 1
126440: PPUSH
126441: LD_INT 1
126443: PPUSH
126444: CALL 73154 0 4
126448: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
126449: LD_ADDR_VAR 0 5
126453: PUSH
126454: LD_EXP 208
126458: PPUSH
126459: LD_VAR 0 1
126463: PPUSH
126464: CALL 72504 0 2
126468: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
126469: LD_EXP 209
126473: PUSH
126474: LD_VAR 0 5
126478: ARRAY
126479: PUSH
126480: LD_EXP 210
126484: LESS
126485: IFFALSE 126674
// begin for i := 1 to vehicles do
126487: LD_ADDR_VAR 0 4
126491: PUSH
126492: DOUBLE
126493: LD_INT 1
126495: DEC
126496: ST_TO_ADDR
126497: LD_VAR 0 2
126501: PUSH
126502: FOR_TO
126503: IFFALSE 126672
// begin if hackTanksCaptured [ index ] = hackLimit then
126505: LD_EXP 209
126509: PUSH
126510: LD_VAR 0 5
126514: ARRAY
126515: PUSH
126516: LD_EXP 210
126520: EQUAL
126521: IFFALSE 126525
// break ;
126523: GO 126672
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
126525: LD_ADDR_EXP 212
126529: PUSH
126530: LD_EXP 212
126534: PPUSH
126535: LD_VAR 0 5
126539: PPUSH
126540: LD_EXP 212
126544: PUSH
126545: LD_VAR 0 5
126549: ARRAY
126550: PUSH
126551: LD_INT 1
126553: PLUS
126554: PPUSH
126555: CALL_OW 1
126559: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
126560: LD_ADDR_EXP 209
126564: PUSH
126565: LD_EXP 209
126569: PPUSH
126570: LD_VAR 0 5
126574: PUSH
126575: LD_EXP 209
126579: PUSH
126580: LD_VAR 0 5
126584: ARRAY
126585: PUSH
126586: LD_INT 1
126588: PLUS
126589: PUSH
126590: EMPTY
126591: LIST
126592: LIST
126593: PPUSH
126594: LD_VAR 0 2
126598: PUSH
126599: LD_VAR 0 4
126603: ARRAY
126604: PUSH
126605: LD_VAR 0 2
126609: PUSH
126610: LD_VAR 0 4
126614: ARRAY
126615: PPUSH
126616: CALL_OW 255
126620: PUSH
126621: EMPTY
126622: LIST
126623: LIST
126624: PPUSH
126625: CALL 72719 0 3
126629: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
126630: LD_VAR 0 2
126634: PUSH
126635: LD_VAR 0 4
126639: ARRAY
126640: PPUSH
126641: LD_VAR 0 1
126645: PPUSH
126646: CALL_OW 255
126650: PPUSH
126651: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
126655: LD_VAR 0 2
126659: PUSH
126660: LD_VAR 0 4
126664: ARRAY
126665: PPUSH
126666: CALL_OW 141
// end ;
126670: GO 126502
126672: POP
126673: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126674: LD_VAR 0 1
126678: PPUSH
126679: LD_EXP 209
126683: PUSH
126684: LD_VAR 0 5
126688: ARRAY
126689: PUSH
126690: LD_INT 0
126692: PLUS
126693: PPUSH
126694: CALL_OW 505
// end ;
126698: LD_VAR 0 3
126702: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126703: LD_INT 0
126705: PPUSH
126706: PPUSH
126707: PPUSH
126708: PPUSH
// if not hack in hackTanks then
126709: LD_VAR 0 1
126713: PUSH
126714: LD_EXP 208
126718: IN
126719: NOT
126720: IFFALSE 126724
// exit ;
126722: GO 126964
// index := GetElementIndex ( hackTanks , hack ) ;
126724: LD_ADDR_VAR 0 4
126728: PUSH
126729: LD_EXP 208
126733: PPUSH
126734: LD_VAR 0 1
126738: PPUSH
126739: CALL 72504 0 2
126743: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126744: LD_ADDR_VAR 0 3
126748: PUSH
126749: DOUBLE
126750: LD_EXP 209
126754: PUSH
126755: LD_VAR 0 4
126759: ARRAY
126760: INC
126761: ST_TO_ADDR
126762: LD_INT 1
126764: PUSH
126765: FOR_DOWNTO
126766: IFFALSE 126938
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126768: LD_ADDR_VAR 0 5
126772: PUSH
126773: LD_EXP 209
126777: PUSH
126778: LD_VAR 0 4
126782: ARRAY
126783: PUSH
126784: LD_VAR 0 3
126788: ARRAY
126789: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126790: LD_VAR 0 5
126794: PUSH
126795: LD_INT 1
126797: ARRAY
126798: PPUSH
126799: CALL_OW 302
126803: NOT
126804: PUSH
126805: LD_VAR 0 5
126809: PUSH
126810: LD_INT 1
126812: ARRAY
126813: PPUSH
126814: CALL_OW 255
126818: PUSH
126819: LD_VAR 0 1
126823: PPUSH
126824: CALL_OW 255
126828: NONEQUAL
126829: OR
126830: IFFALSE 126936
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126832: LD_VAR 0 5
126836: PUSH
126837: LD_INT 1
126839: ARRAY
126840: PPUSH
126841: CALL_OW 305
126845: PUSH
126846: LD_VAR 0 5
126850: PUSH
126851: LD_INT 1
126853: ARRAY
126854: PPUSH
126855: CALL_OW 255
126859: PUSH
126860: LD_VAR 0 1
126864: PPUSH
126865: CALL_OW 255
126869: EQUAL
126870: AND
126871: IFFALSE 126895
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126873: LD_VAR 0 5
126877: PUSH
126878: LD_INT 1
126880: ARRAY
126881: PPUSH
126882: LD_VAR 0 5
126886: PUSH
126887: LD_INT 2
126889: ARRAY
126890: PPUSH
126891: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126895: LD_ADDR_EXP 209
126899: PUSH
126900: LD_EXP 209
126904: PPUSH
126905: LD_VAR 0 4
126909: PPUSH
126910: LD_EXP 209
126914: PUSH
126915: LD_VAR 0 4
126919: ARRAY
126920: PPUSH
126921: LD_VAR 0 3
126925: PPUSH
126926: CALL_OW 3
126930: PPUSH
126931: CALL_OW 1
126935: ST_TO_ADDR
// end ; end ;
126936: GO 126765
126938: POP
126939: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126940: LD_VAR 0 1
126944: PPUSH
126945: LD_EXP 209
126949: PUSH
126950: LD_VAR 0 4
126954: ARRAY
126955: PUSH
126956: LD_INT 0
126958: PLUS
126959: PPUSH
126960: CALL_OW 505
// end ;
126964: LD_VAR 0 2
126968: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126969: LD_INT 0
126971: PPUSH
126972: PPUSH
126973: PPUSH
126974: PPUSH
// if not hack in hackTanks then
126975: LD_VAR 0 1
126979: PUSH
126980: LD_EXP 208
126984: IN
126985: NOT
126986: IFFALSE 126990
// exit ;
126988: GO 127075
// index := GetElementIndex ( hackTanks , hack ) ;
126990: LD_ADDR_VAR 0 5
126994: PUSH
126995: LD_EXP 208
126999: PPUSH
127000: LD_VAR 0 1
127004: PPUSH
127005: CALL 72504 0 2
127009: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
127010: LD_ADDR_VAR 0 4
127014: PUSH
127015: DOUBLE
127016: LD_INT 1
127018: DEC
127019: ST_TO_ADDR
127020: LD_EXP 209
127024: PUSH
127025: LD_VAR 0 5
127029: ARRAY
127030: PUSH
127031: FOR_TO
127032: IFFALSE 127073
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
127034: LD_EXP 209
127038: PUSH
127039: LD_VAR 0 5
127043: ARRAY
127044: PUSH
127045: LD_VAR 0 4
127049: ARRAY
127050: PUSH
127051: LD_INT 1
127053: ARRAY
127054: PUSH
127055: LD_VAR 0 2
127059: EQUAL
127060: IFFALSE 127071
// KillUnit ( vehicle ) ;
127062: LD_VAR 0 2
127066: PPUSH
127067: CALL_OW 66
127071: GO 127031
127073: POP
127074: POP
// end ;
127075: LD_VAR 0 3
127079: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
127080: LD_EXP 213
127084: NOT
127085: IFFALSE 127120
127087: GO 127089
127089: DISABLE
// begin initMiner := true ;
127090: LD_ADDR_EXP 213
127094: PUSH
127095: LD_INT 1
127097: ST_TO_ADDR
// minersList := [ ] ;
127098: LD_ADDR_EXP 214
127102: PUSH
127103: EMPTY
127104: ST_TO_ADDR
// minerMinesList := [ ] ;
127105: LD_ADDR_EXP 215
127109: PUSH
127110: EMPTY
127111: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
127112: LD_ADDR_EXP 216
127116: PUSH
127117: LD_INT 5
127119: ST_TO_ADDR
// end ;
127120: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
127121: LD_EXP 213
127125: PUSH
127126: LD_INT 34
127128: PUSH
127129: LD_INT 81
127131: PUSH
127132: EMPTY
127133: LIST
127134: LIST
127135: PPUSH
127136: CALL_OW 69
127140: AND
127141: IFFALSE 127602
127143: GO 127145
127145: DISABLE
127146: LD_INT 0
127148: PPUSH
127149: PPUSH
127150: PPUSH
127151: PPUSH
// begin enable ;
127152: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
127153: LD_ADDR_VAR 0 1
127157: PUSH
127158: LD_INT 34
127160: PUSH
127161: LD_INT 81
127163: PUSH
127164: EMPTY
127165: LIST
127166: LIST
127167: PPUSH
127168: CALL_OW 69
127172: PUSH
127173: FOR_IN
127174: IFFALSE 127246
// begin if not i in minersList then
127176: LD_VAR 0 1
127180: PUSH
127181: LD_EXP 214
127185: IN
127186: NOT
127187: IFFALSE 127244
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
127189: LD_ADDR_EXP 214
127193: PUSH
127194: LD_EXP 214
127198: PPUSH
127199: LD_EXP 214
127203: PUSH
127204: LD_INT 1
127206: PLUS
127207: PPUSH
127208: LD_VAR 0 1
127212: PPUSH
127213: CALL_OW 1
127217: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
127218: LD_ADDR_EXP 215
127222: PUSH
127223: LD_EXP 215
127227: PPUSH
127228: LD_EXP 215
127232: PUSH
127233: LD_INT 1
127235: PLUS
127236: PPUSH
127237: EMPTY
127238: PPUSH
127239: CALL_OW 1
127243: ST_TO_ADDR
// end end ;
127244: GO 127173
127246: POP
127247: POP
// for i := minerMinesList downto 1 do
127248: LD_ADDR_VAR 0 1
127252: PUSH
127253: DOUBLE
127254: LD_EXP 215
127258: INC
127259: ST_TO_ADDR
127260: LD_INT 1
127262: PUSH
127263: FOR_DOWNTO
127264: IFFALSE 127600
// begin if IsLive ( minersList [ i ] ) then
127266: LD_EXP 214
127270: PUSH
127271: LD_VAR 0 1
127275: ARRAY
127276: PPUSH
127277: CALL_OW 300
127281: IFFALSE 127309
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
127283: LD_EXP 214
127287: PUSH
127288: LD_VAR 0 1
127292: ARRAY
127293: PPUSH
127294: LD_EXP 215
127298: PUSH
127299: LD_VAR 0 1
127303: ARRAY
127304: PPUSH
127305: CALL_OW 505
// if not minerMinesList [ i ] then
127309: LD_EXP 215
127313: PUSH
127314: LD_VAR 0 1
127318: ARRAY
127319: NOT
127320: IFFALSE 127324
// continue ;
127322: GO 127263
// for j := minerMinesList [ i ] downto 1 do
127324: LD_ADDR_VAR 0 2
127328: PUSH
127329: DOUBLE
127330: LD_EXP 215
127334: PUSH
127335: LD_VAR 0 1
127339: ARRAY
127340: INC
127341: ST_TO_ADDR
127342: LD_INT 1
127344: PUSH
127345: FOR_DOWNTO
127346: IFFALSE 127596
// begin side := GetSide ( minersList [ i ] ) ;
127348: LD_ADDR_VAR 0 3
127352: PUSH
127353: LD_EXP 214
127357: PUSH
127358: LD_VAR 0 1
127362: ARRAY
127363: PPUSH
127364: CALL_OW 255
127368: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
127369: LD_ADDR_VAR 0 4
127373: PUSH
127374: LD_EXP 215
127378: PUSH
127379: LD_VAR 0 1
127383: ARRAY
127384: PUSH
127385: LD_VAR 0 2
127389: ARRAY
127390: PUSH
127391: LD_INT 1
127393: ARRAY
127394: PPUSH
127395: LD_EXP 215
127399: PUSH
127400: LD_VAR 0 1
127404: ARRAY
127405: PUSH
127406: LD_VAR 0 2
127410: ARRAY
127411: PUSH
127412: LD_INT 2
127414: ARRAY
127415: PPUSH
127416: CALL_OW 428
127420: ST_TO_ADDR
// if not tmp then
127421: LD_VAR 0 4
127425: NOT
127426: IFFALSE 127430
// continue ;
127428: GO 127345
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
127430: LD_VAR 0 4
127434: PUSH
127435: LD_INT 81
127437: PUSH
127438: LD_VAR 0 3
127442: PUSH
127443: EMPTY
127444: LIST
127445: LIST
127446: PPUSH
127447: CALL_OW 69
127451: IN
127452: PUSH
127453: LD_EXP 215
127457: PUSH
127458: LD_VAR 0 1
127462: ARRAY
127463: PUSH
127464: LD_VAR 0 2
127468: ARRAY
127469: PUSH
127470: LD_INT 1
127472: ARRAY
127473: PPUSH
127474: LD_EXP 215
127478: PUSH
127479: LD_VAR 0 1
127483: ARRAY
127484: PUSH
127485: LD_VAR 0 2
127489: ARRAY
127490: PUSH
127491: LD_INT 2
127493: ARRAY
127494: PPUSH
127495: CALL_OW 458
127499: AND
127500: IFFALSE 127594
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
127502: LD_EXP 215
127506: PUSH
127507: LD_VAR 0 1
127511: ARRAY
127512: PUSH
127513: LD_VAR 0 2
127517: ARRAY
127518: PUSH
127519: LD_INT 1
127521: ARRAY
127522: PPUSH
127523: LD_EXP 215
127527: PUSH
127528: LD_VAR 0 1
127532: ARRAY
127533: PUSH
127534: LD_VAR 0 2
127538: ARRAY
127539: PUSH
127540: LD_INT 2
127542: ARRAY
127543: PPUSH
127544: LD_VAR 0 3
127548: PPUSH
127549: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
127553: LD_ADDR_EXP 215
127557: PUSH
127558: LD_EXP 215
127562: PPUSH
127563: LD_VAR 0 1
127567: PPUSH
127568: LD_EXP 215
127572: PUSH
127573: LD_VAR 0 1
127577: ARRAY
127578: PPUSH
127579: LD_VAR 0 2
127583: PPUSH
127584: CALL_OW 3
127588: PPUSH
127589: CALL_OW 1
127593: ST_TO_ADDR
// end ; end ;
127594: GO 127345
127596: POP
127597: POP
// end ;
127598: GO 127263
127600: POP
127601: POP
// end ;
127602: PPOPN 4
127604: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
127605: LD_INT 0
127607: PPUSH
127608: PPUSH
// result := false ;
127609: LD_ADDR_VAR 0 4
127613: PUSH
127614: LD_INT 0
127616: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
127617: LD_VAR 0 1
127621: PPUSH
127622: CALL_OW 264
127626: PUSH
127627: LD_INT 81
127629: EQUAL
127630: NOT
127631: IFFALSE 127635
// exit ;
127633: GO 127875
// index := GetElementIndex ( minersList , unit ) ;
127635: LD_ADDR_VAR 0 5
127639: PUSH
127640: LD_EXP 214
127644: PPUSH
127645: LD_VAR 0 1
127649: PPUSH
127650: CALL 72504 0 2
127654: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
127655: LD_EXP 215
127659: PUSH
127660: LD_VAR 0 5
127664: ARRAY
127665: PUSH
127666: LD_EXP 216
127670: GREATEREQUAL
127671: IFFALSE 127675
// exit ;
127673: GO 127875
// ComMoveXY ( unit , x , y ) ;
127675: LD_VAR 0 1
127679: PPUSH
127680: LD_VAR 0 2
127684: PPUSH
127685: LD_VAR 0 3
127689: PPUSH
127690: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
127694: LD_INT 35
127696: PPUSH
127697: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127701: LD_VAR 0 1
127705: PPUSH
127706: LD_VAR 0 2
127710: PPUSH
127711: LD_VAR 0 3
127715: PPUSH
127716: CALL 103859 0 3
127720: NOT
127721: PUSH
127722: LD_VAR 0 1
127726: PPUSH
127727: CALL_OW 314
127731: AND
127732: IFFALSE 127736
// exit ;
127734: GO 127875
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127736: LD_VAR 0 2
127740: PPUSH
127741: LD_VAR 0 3
127745: PPUSH
127746: CALL_OW 428
127750: PUSH
127751: LD_VAR 0 1
127755: EQUAL
127756: PUSH
127757: LD_VAR 0 1
127761: PPUSH
127762: CALL_OW 314
127766: NOT
127767: AND
127768: IFFALSE 127694
// PlaySoundXY ( x , y , PlantMine ) ;
127770: LD_VAR 0 2
127774: PPUSH
127775: LD_VAR 0 3
127779: PPUSH
127780: LD_STRING PlantMine
127782: PPUSH
127783: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127787: LD_VAR 0 2
127791: PPUSH
127792: LD_VAR 0 3
127796: PPUSH
127797: LD_VAR 0 1
127801: PPUSH
127802: CALL_OW 255
127806: PPUSH
127807: LD_INT 0
127809: PPUSH
127810: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127814: LD_ADDR_EXP 215
127818: PUSH
127819: LD_EXP 215
127823: PPUSH
127824: LD_VAR 0 5
127828: PUSH
127829: LD_EXP 215
127833: PUSH
127834: LD_VAR 0 5
127838: ARRAY
127839: PUSH
127840: LD_INT 1
127842: PLUS
127843: PUSH
127844: EMPTY
127845: LIST
127846: LIST
127847: PPUSH
127848: LD_VAR 0 2
127852: PUSH
127853: LD_VAR 0 3
127857: PUSH
127858: EMPTY
127859: LIST
127860: LIST
127861: PPUSH
127862: CALL 72719 0 3
127866: ST_TO_ADDR
// result := true ;
127867: LD_ADDR_VAR 0 4
127871: PUSH
127872: LD_INT 1
127874: ST_TO_ADDR
// end ;
127875: LD_VAR 0 4
127879: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127880: LD_INT 0
127882: PPUSH
127883: PPUSH
127884: PPUSH
// if not unit in minersList then
127885: LD_VAR 0 1
127889: PUSH
127890: LD_EXP 214
127894: IN
127895: NOT
127896: IFFALSE 127900
// exit ;
127898: GO 128292
// index := GetElementIndex ( minersList , unit ) ;
127900: LD_ADDR_VAR 0 6
127904: PUSH
127905: LD_EXP 214
127909: PPUSH
127910: LD_VAR 0 1
127914: PPUSH
127915: CALL 72504 0 2
127919: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127920: LD_ADDR_VAR 0 5
127924: PUSH
127925: DOUBLE
127926: LD_EXP 215
127930: PUSH
127931: LD_VAR 0 6
127935: ARRAY
127936: INC
127937: ST_TO_ADDR
127938: LD_INT 1
127940: PUSH
127941: FOR_DOWNTO
127942: IFFALSE 128103
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127944: LD_EXP 215
127948: PUSH
127949: LD_VAR 0 6
127953: ARRAY
127954: PUSH
127955: LD_VAR 0 5
127959: ARRAY
127960: PUSH
127961: LD_INT 1
127963: ARRAY
127964: PUSH
127965: LD_VAR 0 2
127969: EQUAL
127970: PUSH
127971: LD_EXP 215
127975: PUSH
127976: LD_VAR 0 6
127980: ARRAY
127981: PUSH
127982: LD_VAR 0 5
127986: ARRAY
127987: PUSH
127988: LD_INT 2
127990: ARRAY
127991: PUSH
127992: LD_VAR 0 3
127996: EQUAL
127997: AND
127998: IFFALSE 128101
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128000: LD_EXP 215
128004: PUSH
128005: LD_VAR 0 6
128009: ARRAY
128010: PUSH
128011: LD_VAR 0 5
128015: ARRAY
128016: PUSH
128017: LD_INT 1
128019: ARRAY
128020: PPUSH
128021: LD_EXP 215
128025: PUSH
128026: LD_VAR 0 6
128030: ARRAY
128031: PUSH
128032: LD_VAR 0 5
128036: ARRAY
128037: PUSH
128038: LD_INT 2
128040: ARRAY
128041: PPUSH
128042: LD_VAR 0 1
128046: PPUSH
128047: CALL_OW 255
128051: PPUSH
128052: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128056: LD_ADDR_EXP 215
128060: PUSH
128061: LD_EXP 215
128065: PPUSH
128066: LD_VAR 0 6
128070: PPUSH
128071: LD_EXP 215
128075: PUSH
128076: LD_VAR 0 6
128080: ARRAY
128081: PPUSH
128082: LD_VAR 0 5
128086: PPUSH
128087: CALL_OW 3
128091: PPUSH
128092: CALL_OW 1
128096: ST_TO_ADDR
// exit ;
128097: POP
128098: POP
128099: GO 128292
// end ; end ;
128101: GO 127941
128103: POP
128104: POP
// for i := minerMinesList [ index ] downto 1 do
128105: LD_ADDR_VAR 0 5
128109: PUSH
128110: DOUBLE
128111: LD_EXP 215
128115: PUSH
128116: LD_VAR 0 6
128120: ARRAY
128121: INC
128122: ST_TO_ADDR
128123: LD_INT 1
128125: PUSH
128126: FOR_DOWNTO
128127: IFFALSE 128290
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
128129: LD_EXP 215
128133: PUSH
128134: LD_VAR 0 6
128138: ARRAY
128139: PUSH
128140: LD_VAR 0 5
128144: ARRAY
128145: PUSH
128146: LD_INT 1
128148: ARRAY
128149: PPUSH
128150: LD_EXP 215
128154: PUSH
128155: LD_VAR 0 6
128159: ARRAY
128160: PUSH
128161: LD_VAR 0 5
128165: ARRAY
128166: PUSH
128167: LD_INT 2
128169: ARRAY
128170: PPUSH
128171: LD_VAR 0 2
128175: PPUSH
128176: LD_VAR 0 3
128180: PPUSH
128181: CALL_OW 298
128185: PUSH
128186: LD_INT 6
128188: LESS
128189: IFFALSE 128288
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128191: LD_EXP 215
128195: PUSH
128196: LD_VAR 0 6
128200: ARRAY
128201: PUSH
128202: LD_VAR 0 5
128206: ARRAY
128207: PUSH
128208: LD_INT 1
128210: ARRAY
128211: PPUSH
128212: LD_EXP 215
128216: PUSH
128217: LD_VAR 0 6
128221: ARRAY
128222: PUSH
128223: LD_VAR 0 5
128227: ARRAY
128228: PUSH
128229: LD_INT 2
128231: ARRAY
128232: PPUSH
128233: LD_VAR 0 1
128237: PPUSH
128238: CALL_OW 255
128242: PPUSH
128243: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128247: LD_ADDR_EXP 215
128251: PUSH
128252: LD_EXP 215
128256: PPUSH
128257: LD_VAR 0 6
128261: PPUSH
128262: LD_EXP 215
128266: PUSH
128267: LD_VAR 0 6
128271: ARRAY
128272: PPUSH
128273: LD_VAR 0 5
128277: PPUSH
128278: CALL_OW 3
128282: PPUSH
128283: CALL_OW 1
128287: ST_TO_ADDR
// end ; end ;
128288: GO 128126
128290: POP
128291: POP
// end ;
128292: LD_VAR 0 4
128296: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
128297: LD_INT 0
128299: PPUSH
128300: PPUSH
128301: PPUSH
128302: PPUSH
128303: PPUSH
128304: PPUSH
128305: PPUSH
128306: PPUSH
128307: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
128308: LD_VAR 0 1
128312: PPUSH
128313: CALL_OW 264
128317: PUSH
128318: LD_INT 81
128320: EQUAL
128321: NOT
128322: PUSH
128323: LD_VAR 0 1
128327: PUSH
128328: LD_EXP 214
128332: IN
128333: NOT
128334: OR
128335: IFFALSE 128339
// exit ;
128337: GO 128661
// index := GetElementIndex ( minersList , unit ) ;
128339: LD_ADDR_VAR 0 6
128343: PUSH
128344: LD_EXP 214
128348: PPUSH
128349: LD_VAR 0 1
128353: PPUSH
128354: CALL 72504 0 2
128358: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
128359: LD_ADDR_VAR 0 8
128363: PUSH
128364: LD_EXP 216
128368: PUSH
128369: LD_EXP 215
128373: PUSH
128374: LD_VAR 0 6
128378: ARRAY
128379: MINUS
128380: ST_TO_ADDR
// if not minesFreeAmount then
128381: LD_VAR 0 8
128385: NOT
128386: IFFALSE 128390
// exit ;
128388: GO 128661
// tmp := [ ] ;
128390: LD_ADDR_VAR 0 7
128394: PUSH
128395: EMPTY
128396: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
128397: LD_ADDR_VAR 0 5
128401: PUSH
128402: DOUBLE
128403: LD_INT 1
128405: DEC
128406: ST_TO_ADDR
128407: LD_VAR 0 8
128411: PUSH
128412: FOR_TO
128413: IFFALSE 128608
// begin _d := rand ( 0 , 5 ) ;
128415: LD_ADDR_VAR 0 11
128419: PUSH
128420: LD_INT 0
128422: PPUSH
128423: LD_INT 5
128425: PPUSH
128426: CALL_OW 12
128430: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
128431: LD_ADDR_VAR 0 12
128435: PUSH
128436: LD_INT 2
128438: PPUSH
128439: LD_INT 6
128441: PPUSH
128442: CALL_OW 12
128446: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
128447: LD_ADDR_VAR 0 9
128451: PUSH
128452: LD_VAR 0 2
128456: PPUSH
128457: LD_VAR 0 11
128461: PPUSH
128462: LD_VAR 0 12
128466: PPUSH
128467: CALL_OW 272
128471: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
128472: LD_ADDR_VAR 0 10
128476: PUSH
128477: LD_VAR 0 3
128481: PPUSH
128482: LD_VAR 0 11
128486: PPUSH
128487: LD_VAR 0 12
128491: PPUSH
128492: CALL_OW 273
128496: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
128497: LD_VAR 0 9
128501: PPUSH
128502: LD_VAR 0 10
128506: PPUSH
128507: CALL_OW 488
128511: PUSH
128512: LD_VAR 0 9
128516: PUSH
128517: LD_VAR 0 10
128521: PUSH
128522: EMPTY
128523: LIST
128524: LIST
128525: PUSH
128526: LD_VAR 0 7
128530: IN
128531: NOT
128532: AND
128533: PUSH
128534: LD_VAR 0 9
128538: PPUSH
128539: LD_VAR 0 10
128543: PPUSH
128544: CALL_OW 458
128548: NOT
128549: AND
128550: IFFALSE 128592
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
128552: LD_ADDR_VAR 0 7
128556: PUSH
128557: LD_VAR 0 7
128561: PPUSH
128562: LD_VAR 0 7
128566: PUSH
128567: LD_INT 1
128569: PLUS
128570: PPUSH
128571: LD_VAR 0 9
128575: PUSH
128576: LD_VAR 0 10
128580: PUSH
128581: EMPTY
128582: LIST
128583: LIST
128584: PPUSH
128585: CALL_OW 1
128589: ST_TO_ADDR
128590: GO 128606
// i := i - 1 ;
128592: LD_ADDR_VAR 0 5
128596: PUSH
128597: LD_VAR 0 5
128601: PUSH
128602: LD_INT 1
128604: MINUS
128605: ST_TO_ADDR
// end ;
128606: GO 128412
128608: POP
128609: POP
// for i in tmp do
128610: LD_ADDR_VAR 0 5
128614: PUSH
128615: LD_VAR 0 7
128619: PUSH
128620: FOR_IN
128621: IFFALSE 128659
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
128623: LD_VAR 0 1
128627: PPUSH
128628: LD_VAR 0 5
128632: PUSH
128633: LD_INT 1
128635: ARRAY
128636: PPUSH
128637: LD_VAR 0 5
128641: PUSH
128642: LD_INT 2
128644: ARRAY
128645: PPUSH
128646: CALL 127605 0 3
128650: NOT
128651: IFFALSE 128657
// exit ;
128653: POP
128654: POP
128655: GO 128661
128657: GO 128620
128659: POP
128660: POP
// end ;
128661: LD_VAR 0 4
128665: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
128666: LD_INT 0
128668: PPUSH
128669: PPUSH
128670: PPUSH
128671: PPUSH
128672: PPUSH
128673: PPUSH
128674: PPUSH
// if not GetClass ( unit ) = class_sniper then
128675: LD_VAR 0 1
128679: PPUSH
128680: CALL_OW 257
128684: PUSH
128685: LD_INT 5
128687: EQUAL
128688: NOT
128689: IFFALSE 128693
// exit ;
128691: GO 129081
// dist := 8 ;
128693: LD_ADDR_VAR 0 5
128697: PUSH
128698: LD_INT 8
128700: ST_TO_ADDR
// viewRange := 12 ;
128701: LD_ADDR_VAR 0 7
128705: PUSH
128706: LD_INT 12
128708: ST_TO_ADDR
// side := GetSide ( unit ) ;
128709: LD_ADDR_VAR 0 6
128713: PUSH
128714: LD_VAR 0 1
128718: PPUSH
128719: CALL_OW 255
128723: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128724: LD_INT 61
128726: PPUSH
128727: LD_VAR 0 6
128731: PPUSH
128732: CALL_OW 321
128736: PUSH
128737: LD_INT 2
128739: EQUAL
128740: IFFALSE 128750
// viewRange := 16 ;
128742: LD_ADDR_VAR 0 7
128746: PUSH
128747: LD_INT 16
128749: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128750: LD_VAR 0 1
128754: PPUSH
128755: LD_VAR 0 2
128759: PPUSH
128760: LD_VAR 0 3
128764: PPUSH
128765: CALL_OW 297
128769: PUSH
128770: LD_VAR 0 5
128774: GREATER
128775: IFFALSE 128854
// begin ComMoveXY ( unit , x , y ) ;
128777: LD_VAR 0 1
128781: PPUSH
128782: LD_VAR 0 2
128786: PPUSH
128787: LD_VAR 0 3
128791: PPUSH
128792: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128796: LD_INT 35
128798: PPUSH
128799: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128803: LD_VAR 0 1
128807: PPUSH
128808: LD_VAR 0 2
128812: PPUSH
128813: LD_VAR 0 3
128817: PPUSH
128818: CALL 103859 0 3
128822: NOT
128823: IFFALSE 128827
// exit ;
128825: GO 129081
// until GetDistUnitXY ( unit , x , y ) < dist ;
128827: LD_VAR 0 1
128831: PPUSH
128832: LD_VAR 0 2
128836: PPUSH
128837: LD_VAR 0 3
128841: PPUSH
128842: CALL_OW 297
128846: PUSH
128847: LD_VAR 0 5
128851: LESS
128852: IFFALSE 128796
// end ; ComTurnXY ( unit , x , y ) ;
128854: LD_VAR 0 1
128858: PPUSH
128859: LD_VAR 0 2
128863: PPUSH
128864: LD_VAR 0 3
128868: PPUSH
128869: CALL_OW 118
// wait ( 5 ) ;
128873: LD_INT 5
128875: PPUSH
128876: CALL_OW 67
// _d := GetDir ( unit ) ;
128880: LD_ADDR_VAR 0 10
128884: PUSH
128885: LD_VAR 0 1
128889: PPUSH
128890: CALL_OW 254
128894: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128895: LD_ADDR_VAR 0 8
128899: PUSH
128900: LD_VAR 0 1
128904: PPUSH
128905: CALL_OW 250
128909: PPUSH
128910: LD_VAR 0 10
128914: PPUSH
128915: LD_VAR 0 5
128919: PPUSH
128920: CALL_OW 272
128924: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128925: LD_ADDR_VAR 0 9
128929: PUSH
128930: LD_VAR 0 1
128934: PPUSH
128935: CALL_OW 251
128939: PPUSH
128940: LD_VAR 0 10
128944: PPUSH
128945: LD_VAR 0 5
128949: PPUSH
128950: CALL_OW 273
128954: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128955: LD_VAR 0 8
128959: PPUSH
128960: LD_VAR 0 9
128964: PPUSH
128965: CALL_OW 488
128969: NOT
128970: IFFALSE 128974
// exit ;
128972: GO 129081
// ComAnimCustom ( unit , 1 ) ;
128974: LD_VAR 0 1
128978: PPUSH
128979: LD_INT 1
128981: PPUSH
128982: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128986: LD_VAR 0 8
128990: PPUSH
128991: LD_VAR 0 9
128995: PPUSH
128996: LD_VAR 0 6
129000: PPUSH
129001: LD_VAR 0 7
129005: PPUSH
129006: CALL_OW 330
// repeat wait ( 1 ) ;
129010: LD_INT 1
129012: PPUSH
129013: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
129017: LD_VAR 0 1
129021: PPUSH
129022: CALL_OW 316
129026: PUSH
129027: LD_VAR 0 1
129031: PPUSH
129032: CALL_OW 314
129036: OR
129037: PUSH
129038: LD_VAR 0 1
129042: PPUSH
129043: CALL_OW 302
129047: NOT
129048: OR
129049: PUSH
129050: LD_VAR 0 1
129054: PPUSH
129055: CALL_OW 301
129059: OR
129060: IFFALSE 129010
// RemoveSeeing ( _x , _y , side ) ;
129062: LD_VAR 0 8
129066: PPUSH
129067: LD_VAR 0 9
129071: PPUSH
129072: LD_VAR 0 6
129076: PPUSH
129077: CALL_OW 331
// end ; end_of_file
129081: LD_VAR 0 4
129085: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
129086: LD_INT 0
129088: PPUSH
129089: PPUSH
129090: PPUSH
129091: PPUSH
129092: PPUSH
129093: PPUSH
129094: PPUSH
129095: PPUSH
129096: PPUSH
129097: PPUSH
129098: PPUSH
129099: PPUSH
129100: PPUSH
129101: PPUSH
129102: PPUSH
129103: PPUSH
129104: PPUSH
129105: PPUSH
129106: PPUSH
129107: PPUSH
129108: PPUSH
129109: PPUSH
129110: PPUSH
129111: PPUSH
129112: PPUSH
129113: PPUSH
129114: PPUSH
129115: PPUSH
129116: PPUSH
129117: PPUSH
129118: PPUSH
129119: PPUSH
129120: PPUSH
129121: PPUSH
// if not list then
129122: LD_VAR 0 1
129126: NOT
129127: IFFALSE 129131
// exit ;
129129: GO 133790
// base := list [ 1 ] ;
129131: LD_ADDR_VAR 0 3
129135: PUSH
129136: LD_VAR 0 1
129140: PUSH
129141: LD_INT 1
129143: ARRAY
129144: ST_TO_ADDR
// group := list [ 2 ] ;
129145: LD_ADDR_VAR 0 4
129149: PUSH
129150: LD_VAR 0 1
129154: PUSH
129155: LD_INT 2
129157: ARRAY
129158: ST_TO_ADDR
// path := list [ 3 ] ;
129159: LD_ADDR_VAR 0 5
129163: PUSH
129164: LD_VAR 0 1
129168: PUSH
129169: LD_INT 3
129171: ARRAY
129172: ST_TO_ADDR
// flags := list [ 4 ] ;
129173: LD_ADDR_VAR 0 6
129177: PUSH
129178: LD_VAR 0 1
129182: PUSH
129183: LD_INT 4
129185: ARRAY
129186: ST_TO_ADDR
// mined := [ ] ;
129187: LD_ADDR_VAR 0 27
129191: PUSH
129192: EMPTY
129193: ST_TO_ADDR
// bombed := [ ] ;
129194: LD_ADDR_VAR 0 28
129198: PUSH
129199: EMPTY
129200: ST_TO_ADDR
// healers := [ ] ;
129201: LD_ADDR_VAR 0 31
129205: PUSH
129206: EMPTY
129207: ST_TO_ADDR
// to_heal := [ ] ;
129208: LD_ADDR_VAR 0 30
129212: PUSH
129213: EMPTY
129214: ST_TO_ADDR
// repairs := [ ] ;
129215: LD_ADDR_VAR 0 33
129219: PUSH
129220: EMPTY
129221: ST_TO_ADDR
// to_repair := [ ] ;
129222: LD_ADDR_VAR 0 32
129226: PUSH
129227: EMPTY
129228: ST_TO_ADDR
// if not group or not path then
129229: LD_VAR 0 4
129233: NOT
129234: PUSH
129235: LD_VAR 0 5
129239: NOT
129240: OR
129241: IFFALSE 129245
// exit ;
129243: GO 133790
// side := GetSide ( group [ 1 ] ) ;
129245: LD_ADDR_VAR 0 35
129249: PUSH
129250: LD_VAR 0 4
129254: PUSH
129255: LD_INT 1
129257: ARRAY
129258: PPUSH
129259: CALL_OW 255
129263: ST_TO_ADDR
// if flags then
129264: LD_VAR 0 6
129268: IFFALSE 129412
// begin f_ignore_area := flags [ 1 ] ;
129270: LD_ADDR_VAR 0 17
129274: PUSH
129275: LD_VAR 0 6
129279: PUSH
129280: LD_INT 1
129282: ARRAY
129283: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
129284: LD_ADDR_VAR 0 18
129288: PUSH
129289: LD_VAR 0 6
129293: PUSH
129294: LD_INT 2
129296: ARRAY
129297: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
129298: LD_ADDR_VAR 0 19
129302: PUSH
129303: LD_VAR 0 6
129307: PUSH
129308: LD_INT 3
129310: ARRAY
129311: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
129312: LD_ADDR_VAR 0 20
129316: PUSH
129317: LD_VAR 0 6
129321: PUSH
129322: LD_INT 4
129324: ARRAY
129325: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
129326: LD_ADDR_VAR 0 21
129330: PUSH
129331: LD_VAR 0 6
129335: PUSH
129336: LD_INT 5
129338: ARRAY
129339: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
129340: LD_ADDR_VAR 0 22
129344: PUSH
129345: LD_VAR 0 6
129349: PUSH
129350: LD_INT 6
129352: ARRAY
129353: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
129354: LD_ADDR_VAR 0 23
129358: PUSH
129359: LD_VAR 0 6
129363: PUSH
129364: LD_INT 7
129366: ARRAY
129367: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
129368: LD_ADDR_VAR 0 24
129372: PUSH
129373: LD_VAR 0 6
129377: PUSH
129378: LD_INT 8
129380: ARRAY
129381: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
129382: LD_ADDR_VAR 0 25
129386: PUSH
129387: LD_VAR 0 6
129391: PUSH
129392: LD_INT 9
129394: ARRAY
129395: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
129396: LD_ADDR_VAR 0 26
129400: PUSH
129401: LD_VAR 0 6
129405: PUSH
129406: LD_INT 10
129408: ARRAY
129409: ST_TO_ADDR
// end else
129410: GO 129492
// begin f_ignore_area := false ;
129412: LD_ADDR_VAR 0 17
129416: PUSH
129417: LD_INT 0
129419: ST_TO_ADDR
// f_capture := false ;
129420: LD_ADDR_VAR 0 18
129424: PUSH
129425: LD_INT 0
129427: ST_TO_ADDR
// f_ignore_civ := false ;
129428: LD_ADDR_VAR 0 19
129432: PUSH
129433: LD_INT 0
129435: ST_TO_ADDR
// f_murder := false ;
129436: LD_ADDR_VAR 0 20
129440: PUSH
129441: LD_INT 0
129443: ST_TO_ADDR
// f_mines := false ;
129444: LD_ADDR_VAR 0 21
129448: PUSH
129449: LD_INT 0
129451: ST_TO_ADDR
// f_repair := false ;
129452: LD_ADDR_VAR 0 22
129456: PUSH
129457: LD_INT 0
129459: ST_TO_ADDR
// f_heal := false ;
129460: LD_ADDR_VAR 0 23
129464: PUSH
129465: LD_INT 0
129467: ST_TO_ADDR
// f_spacetime := false ;
129468: LD_ADDR_VAR 0 24
129472: PUSH
129473: LD_INT 0
129475: ST_TO_ADDR
// f_attack_depot := false ;
129476: LD_ADDR_VAR 0 25
129480: PUSH
129481: LD_INT 0
129483: ST_TO_ADDR
// f_crawl := false ;
129484: LD_ADDR_VAR 0 26
129488: PUSH
129489: LD_INT 0
129491: ST_TO_ADDR
// end ; if f_heal then
129492: LD_VAR 0 23
129496: IFFALSE 129523
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
129498: LD_ADDR_VAR 0 31
129502: PUSH
129503: LD_VAR 0 4
129507: PPUSH
129508: LD_INT 25
129510: PUSH
129511: LD_INT 4
129513: PUSH
129514: EMPTY
129515: LIST
129516: LIST
129517: PPUSH
129518: CALL_OW 72
129522: ST_TO_ADDR
// if f_repair then
129523: LD_VAR 0 22
129527: IFFALSE 129554
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
129529: LD_ADDR_VAR 0 33
129533: PUSH
129534: LD_VAR 0 4
129538: PPUSH
129539: LD_INT 25
129541: PUSH
129542: LD_INT 3
129544: PUSH
129545: EMPTY
129546: LIST
129547: LIST
129548: PPUSH
129549: CALL_OW 72
129553: ST_TO_ADDR
// units_path := [ ] ;
129554: LD_ADDR_VAR 0 16
129558: PUSH
129559: EMPTY
129560: ST_TO_ADDR
// for i = 1 to group do
129561: LD_ADDR_VAR 0 7
129565: PUSH
129566: DOUBLE
129567: LD_INT 1
129569: DEC
129570: ST_TO_ADDR
129571: LD_VAR 0 4
129575: PUSH
129576: FOR_TO
129577: IFFALSE 129606
// units_path := Replace ( units_path , i , path ) ;
129579: LD_ADDR_VAR 0 16
129583: PUSH
129584: LD_VAR 0 16
129588: PPUSH
129589: LD_VAR 0 7
129593: PPUSH
129594: LD_VAR 0 5
129598: PPUSH
129599: CALL_OW 1
129603: ST_TO_ADDR
129604: GO 129576
129606: POP
129607: POP
// repeat for i = group downto 1 do
129608: LD_ADDR_VAR 0 7
129612: PUSH
129613: DOUBLE
129614: LD_VAR 0 4
129618: INC
129619: ST_TO_ADDR
129620: LD_INT 1
129622: PUSH
129623: FOR_DOWNTO
129624: IFFALSE 133746
// begin wait ( 5 ) ;
129626: LD_INT 5
129628: PPUSH
129629: CALL_OW 67
// tmp := [ ] ;
129633: LD_ADDR_VAR 0 14
129637: PUSH
129638: EMPTY
129639: ST_TO_ADDR
// attacking := false ;
129640: LD_ADDR_VAR 0 29
129644: PUSH
129645: LD_INT 0
129647: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
129648: LD_VAR 0 4
129652: PUSH
129653: LD_VAR 0 7
129657: ARRAY
129658: PPUSH
129659: CALL_OW 301
129663: PUSH
129664: LD_VAR 0 4
129668: PUSH
129669: LD_VAR 0 7
129673: ARRAY
129674: NOT
129675: OR
129676: IFFALSE 129785
// begin if GetType ( group [ i ] ) = unit_human then
129678: LD_VAR 0 4
129682: PUSH
129683: LD_VAR 0 7
129687: ARRAY
129688: PPUSH
129689: CALL_OW 247
129693: PUSH
129694: LD_INT 1
129696: EQUAL
129697: IFFALSE 129743
// begin to_heal := to_heal diff group [ i ] ;
129699: LD_ADDR_VAR 0 30
129703: PUSH
129704: LD_VAR 0 30
129708: PUSH
129709: LD_VAR 0 4
129713: PUSH
129714: LD_VAR 0 7
129718: ARRAY
129719: DIFF
129720: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129721: LD_ADDR_VAR 0 31
129725: PUSH
129726: LD_VAR 0 31
129730: PUSH
129731: LD_VAR 0 4
129735: PUSH
129736: LD_VAR 0 7
129740: ARRAY
129741: DIFF
129742: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129743: LD_ADDR_VAR 0 4
129747: PUSH
129748: LD_VAR 0 4
129752: PPUSH
129753: LD_VAR 0 7
129757: PPUSH
129758: CALL_OW 3
129762: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129763: LD_ADDR_VAR 0 16
129767: PUSH
129768: LD_VAR 0 16
129772: PPUSH
129773: LD_VAR 0 7
129777: PPUSH
129778: CALL_OW 3
129782: ST_TO_ADDR
// continue ;
129783: GO 129623
// end ; if f_repair then
129785: LD_VAR 0 22
129789: IFFALSE 130278
// begin if GetType ( group [ i ] ) = unit_vehicle then
129791: LD_VAR 0 4
129795: PUSH
129796: LD_VAR 0 7
129800: ARRAY
129801: PPUSH
129802: CALL_OW 247
129806: PUSH
129807: LD_INT 2
129809: EQUAL
129810: IFFALSE 130000
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129812: LD_VAR 0 4
129816: PUSH
129817: LD_VAR 0 7
129821: ARRAY
129822: PPUSH
129823: CALL_OW 256
129827: PUSH
129828: LD_INT 700
129830: LESS
129831: PUSH
129832: LD_VAR 0 4
129836: PUSH
129837: LD_VAR 0 7
129841: ARRAY
129842: PUSH
129843: LD_VAR 0 32
129847: IN
129848: NOT
129849: AND
129850: IFFALSE 129874
// to_repair := to_repair union group [ i ] ;
129852: LD_ADDR_VAR 0 32
129856: PUSH
129857: LD_VAR 0 32
129861: PUSH
129862: LD_VAR 0 4
129866: PUSH
129867: LD_VAR 0 7
129871: ARRAY
129872: UNION
129873: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129874: LD_VAR 0 4
129878: PUSH
129879: LD_VAR 0 7
129883: ARRAY
129884: PPUSH
129885: CALL_OW 256
129889: PUSH
129890: LD_INT 1000
129892: EQUAL
129893: PUSH
129894: LD_VAR 0 4
129898: PUSH
129899: LD_VAR 0 7
129903: ARRAY
129904: PUSH
129905: LD_VAR 0 32
129909: IN
129910: AND
129911: IFFALSE 129935
// to_repair := to_repair diff group [ i ] ;
129913: LD_ADDR_VAR 0 32
129917: PUSH
129918: LD_VAR 0 32
129922: PUSH
129923: LD_VAR 0 4
129927: PUSH
129928: LD_VAR 0 7
129932: ARRAY
129933: DIFF
129934: ST_TO_ADDR
// if group [ i ] in to_repair then
129935: LD_VAR 0 4
129939: PUSH
129940: LD_VAR 0 7
129944: ARRAY
129945: PUSH
129946: LD_VAR 0 32
129950: IN
129951: IFFALSE 129998
// begin if not IsInArea ( group [ i ] , f_repair ) then
129953: LD_VAR 0 4
129957: PUSH
129958: LD_VAR 0 7
129962: ARRAY
129963: PPUSH
129964: LD_VAR 0 22
129968: PPUSH
129969: CALL_OW 308
129973: NOT
129974: IFFALSE 129996
// ComMoveToArea ( group [ i ] , f_repair ) ;
129976: LD_VAR 0 4
129980: PUSH
129981: LD_VAR 0 7
129985: ARRAY
129986: PPUSH
129987: LD_VAR 0 22
129991: PPUSH
129992: CALL_OW 113
// continue ;
129996: GO 129623
// end ; end else
129998: GO 130278
// if group [ i ] in repairs then
130000: LD_VAR 0 4
130004: PUSH
130005: LD_VAR 0 7
130009: ARRAY
130010: PUSH
130011: LD_VAR 0 33
130015: IN
130016: IFFALSE 130278
// begin if IsInUnit ( group [ i ] ) then
130018: LD_VAR 0 4
130022: PUSH
130023: LD_VAR 0 7
130027: ARRAY
130028: PPUSH
130029: CALL_OW 310
130033: IFFALSE 130101
// begin z := IsInUnit ( group [ i ] ) ;
130035: LD_ADDR_VAR 0 13
130039: PUSH
130040: LD_VAR 0 4
130044: PUSH
130045: LD_VAR 0 7
130049: ARRAY
130050: PPUSH
130051: CALL_OW 310
130055: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
130056: LD_VAR 0 13
130060: PUSH
130061: LD_VAR 0 32
130065: IN
130066: PUSH
130067: LD_VAR 0 13
130071: PPUSH
130072: LD_VAR 0 22
130076: PPUSH
130077: CALL_OW 308
130081: AND
130082: IFFALSE 130099
// ComExitVehicle ( group [ i ] ) ;
130084: LD_VAR 0 4
130088: PUSH
130089: LD_VAR 0 7
130093: ARRAY
130094: PPUSH
130095: CALL_OW 121
// end else
130099: GO 130278
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
130101: LD_ADDR_VAR 0 13
130105: PUSH
130106: LD_VAR 0 4
130110: PPUSH
130111: LD_INT 95
130113: PUSH
130114: LD_VAR 0 22
130118: PUSH
130119: EMPTY
130120: LIST
130121: LIST
130122: PUSH
130123: LD_INT 58
130125: PUSH
130126: EMPTY
130127: LIST
130128: PUSH
130129: EMPTY
130130: LIST
130131: LIST
130132: PPUSH
130133: CALL_OW 72
130137: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
130138: LD_VAR 0 4
130142: PUSH
130143: LD_VAR 0 7
130147: ARRAY
130148: PPUSH
130149: CALL_OW 314
130153: NOT
130154: IFFALSE 130276
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
130156: LD_ADDR_VAR 0 10
130160: PUSH
130161: LD_VAR 0 13
130165: PPUSH
130166: LD_VAR 0 4
130170: PUSH
130171: LD_VAR 0 7
130175: ARRAY
130176: PPUSH
130177: CALL_OW 74
130181: ST_TO_ADDR
// if not x then
130182: LD_VAR 0 10
130186: NOT
130187: IFFALSE 130191
// continue ;
130189: GO 129623
// if GetLives ( x ) < 1000 then
130191: LD_VAR 0 10
130195: PPUSH
130196: CALL_OW 256
130200: PUSH
130201: LD_INT 1000
130203: LESS
130204: IFFALSE 130228
// ComRepairVehicle ( group [ i ] , x ) else
130206: LD_VAR 0 4
130210: PUSH
130211: LD_VAR 0 7
130215: ARRAY
130216: PPUSH
130217: LD_VAR 0 10
130221: PPUSH
130222: CALL_OW 129
130226: GO 130276
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
130228: LD_VAR 0 23
130232: PUSH
130233: LD_VAR 0 4
130237: PUSH
130238: LD_VAR 0 7
130242: ARRAY
130243: PPUSH
130244: CALL_OW 256
130248: PUSH
130249: LD_INT 1000
130251: LESS
130252: AND
130253: NOT
130254: IFFALSE 130276
// ComEnterUnit ( group [ i ] , x ) ;
130256: LD_VAR 0 4
130260: PUSH
130261: LD_VAR 0 7
130265: ARRAY
130266: PPUSH
130267: LD_VAR 0 10
130271: PPUSH
130272: CALL_OW 120
// end ; continue ;
130276: GO 129623
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
130278: LD_VAR 0 23
130282: PUSH
130283: LD_VAR 0 4
130287: PUSH
130288: LD_VAR 0 7
130292: ARRAY
130293: PPUSH
130294: CALL_OW 247
130298: PUSH
130299: LD_INT 1
130301: EQUAL
130302: AND
130303: IFFALSE 130781
// begin if group [ i ] in healers then
130305: LD_VAR 0 4
130309: PUSH
130310: LD_VAR 0 7
130314: ARRAY
130315: PUSH
130316: LD_VAR 0 31
130320: IN
130321: IFFALSE 130594
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
130323: LD_VAR 0 4
130327: PUSH
130328: LD_VAR 0 7
130332: ARRAY
130333: PPUSH
130334: LD_VAR 0 23
130338: PPUSH
130339: CALL_OW 308
130343: NOT
130344: PUSH
130345: LD_VAR 0 4
130349: PUSH
130350: LD_VAR 0 7
130354: ARRAY
130355: PPUSH
130356: CALL_OW 314
130360: NOT
130361: AND
130362: IFFALSE 130386
// ComMoveToArea ( group [ i ] , f_heal ) else
130364: LD_VAR 0 4
130368: PUSH
130369: LD_VAR 0 7
130373: ARRAY
130374: PPUSH
130375: LD_VAR 0 23
130379: PPUSH
130380: CALL_OW 113
130384: GO 130592
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
130386: LD_VAR 0 4
130390: PUSH
130391: LD_VAR 0 7
130395: ARRAY
130396: PPUSH
130397: CALL 102442 0 1
130401: PPUSH
130402: CALL_OW 256
130406: PUSH
130407: LD_INT 1000
130409: EQUAL
130410: IFFALSE 130429
// ComStop ( group [ i ] ) else
130412: LD_VAR 0 4
130416: PUSH
130417: LD_VAR 0 7
130421: ARRAY
130422: PPUSH
130423: CALL_OW 141
130427: GO 130592
// if not HasTask ( group [ i ] ) and to_heal then
130429: LD_VAR 0 4
130433: PUSH
130434: LD_VAR 0 7
130438: ARRAY
130439: PPUSH
130440: CALL_OW 314
130444: NOT
130445: PUSH
130446: LD_VAR 0 30
130450: AND
130451: IFFALSE 130592
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
130453: LD_ADDR_VAR 0 13
130457: PUSH
130458: LD_VAR 0 30
130462: PPUSH
130463: LD_INT 3
130465: PUSH
130466: LD_INT 54
130468: PUSH
130469: EMPTY
130470: LIST
130471: PUSH
130472: EMPTY
130473: LIST
130474: LIST
130475: PPUSH
130476: CALL_OW 72
130480: PPUSH
130481: LD_VAR 0 4
130485: PUSH
130486: LD_VAR 0 7
130490: ARRAY
130491: PPUSH
130492: CALL_OW 74
130496: ST_TO_ADDR
// if z then
130497: LD_VAR 0 13
130501: IFFALSE 130592
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
130503: LD_INT 91
130505: PUSH
130506: LD_VAR 0 13
130510: PUSH
130511: LD_INT 10
130513: PUSH
130514: EMPTY
130515: LIST
130516: LIST
130517: LIST
130518: PUSH
130519: LD_INT 81
130521: PUSH
130522: LD_VAR 0 13
130526: PPUSH
130527: CALL_OW 255
130531: PUSH
130532: EMPTY
130533: LIST
130534: LIST
130535: PUSH
130536: EMPTY
130537: LIST
130538: LIST
130539: PPUSH
130540: CALL_OW 69
130544: PUSH
130545: LD_INT 0
130547: EQUAL
130548: IFFALSE 130572
// ComHeal ( group [ i ] , z ) else
130550: LD_VAR 0 4
130554: PUSH
130555: LD_VAR 0 7
130559: ARRAY
130560: PPUSH
130561: LD_VAR 0 13
130565: PPUSH
130566: CALL_OW 128
130570: GO 130592
// ComMoveToArea ( group [ i ] , f_heal ) ;
130572: LD_VAR 0 4
130576: PUSH
130577: LD_VAR 0 7
130581: ARRAY
130582: PPUSH
130583: LD_VAR 0 23
130587: PPUSH
130588: CALL_OW 113
// end ; continue ;
130592: GO 129623
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
130594: LD_VAR 0 4
130598: PUSH
130599: LD_VAR 0 7
130603: ARRAY
130604: PPUSH
130605: CALL_OW 256
130609: PUSH
130610: LD_INT 700
130612: LESS
130613: PUSH
130614: LD_VAR 0 4
130618: PUSH
130619: LD_VAR 0 7
130623: ARRAY
130624: PUSH
130625: LD_VAR 0 30
130629: IN
130630: NOT
130631: AND
130632: IFFALSE 130656
// to_heal := to_heal union group [ i ] ;
130634: LD_ADDR_VAR 0 30
130638: PUSH
130639: LD_VAR 0 30
130643: PUSH
130644: LD_VAR 0 4
130648: PUSH
130649: LD_VAR 0 7
130653: ARRAY
130654: UNION
130655: ST_TO_ADDR
// if group [ i ] in to_heal then
130656: LD_VAR 0 4
130660: PUSH
130661: LD_VAR 0 7
130665: ARRAY
130666: PUSH
130667: LD_VAR 0 30
130671: IN
130672: IFFALSE 130781
// begin if GetLives ( group [ i ] ) = 1000 then
130674: LD_VAR 0 4
130678: PUSH
130679: LD_VAR 0 7
130683: ARRAY
130684: PPUSH
130685: CALL_OW 256
130689: PUSH
130690: LD_INT 1000
130692: EQUAL
130693: IFFALSE 130719
// to_heal := to_heal diff group [ i ] else
130695: LD_ADDR_VAR 0 30
130699: PUSH
130700: LD_VAR 0 30
130704: PUSH
130705: LD_VAR 0 4
130709: PUSH
130710: LD_VAR 0 7
130714: ARRAY
130715: DIFF
130716: ST_TO_ADDR
130717: GO 130781
// begin if not IsInArea ( group [ i ] , to_heal ) then
130719: LD_VAR 0 4
130723: PUSH
130724: LD_VAR 0 7
130728: ARRAY
130729: PPUSH
130730: LD_VAR 0 30
130734: PPUSH
130735: CALL_OW 308
130739: NOT
130740: IFFALSE 130764
// ComMoveToArea ( group [ i ] , f_heal ) else
130742: LD_VAR 0 4
130746: PUSH
130747: LD_VAR 0 7
130751: ARRAY
130752: PPUSH
130753: LD_VAR 0 23
130757: PPUSH
130758: CALL_OW 113
130762: GO 130779
// ComHold ( group [ i ] ) ;
130764: LD_VAR 0 4
130768: PUSH
130769: LD_VAR 0 7
130773: ARRAY
130774: PPUSH
130775: CALL_OW 140
// continue ;
130779: GO 129623
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130781: LD_VAR 0 4
130785: PUSH
130786: LD_VAR 0 7
130790: ARRAY
130791: PPUSH
130792: LD_INT 10
130794: PPUSH
130795: CALL 100213 0 2
130799: NOT
130800: PUSH
130801: LD_VAR 0 16
130805: PUSH
130806: LD_VAR 0 7
130810: ARRAY
130811: PUSH
130812: EMPTY
130813: EQUAL
130814: NOT
130815: AND
130816: IFFALSE 131082
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130818: LD_VAR 0 4
130822: PUSH
130823: LD_VAR 0 7
130827: ARRAY
130828: PPUSH
130829: CALL_OW 262
130833: PUSH
130834: LD_INT 1
130836: PUSH
130837: LD_INT 2
130839: PUSH
130840: EMPTY
130841: LIST
130842: LIST
130843: IN
130844: IFFALSE 130885
// if GetFuel ( group [ i ] ) < 10 then
130846: LD_VAR 0 4
130850: PUSH
130851: LD_VAR 0 7
130855: ARRAY
130856: PPUSH
130857: CALL_OW 261
130861: PUSH
130862: LD_INT 10
130864: LESS
130865: IFFALSE 130885
// SetFuel ( group [ i ] , 12 ) ;
130867: LD_VAR 0 4
130871: PUSH
130872: LD_VAR 0 7
130876: ARRAY
130877: PPUSH
130878: LD_INT 12
130880: PPUSH
130881: CALL_OW 240
// if units_path [ i ] then
130885: LD_VAR 0 16
130889: PUSH
130890: LD_VAR 0 7
130894: ARRAY
130895: IFFALSE 131080
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130897: LD_VAR 0 4
130901: PUSH
130902: LD_VAR 0 7
130906: ARRAY
130907: PPUSH
130908: LD_VAR 0 16
130912: PUSH
130913: LD_VAR 0 7
130917: ARRAY
130918: PUSH
130919: LD_INT 1
130921: ARRAY
130922: PUSH
130923: LD_INT 1
130925: ARRAY
130926: PPUSH
130927: LD_VAR 0 16
130931: PUSH
130932: LD_VAR 0 7
130936: ARRAY
130937: PUSH
130938: LD_INT 1
130940: ARRAY
130941: PUSH
130942: LD_INT 2
130944: ARRAY
130945: PPUSH
130946: CALL_OW 297
130950: PUSH
130951: LD_INT 6
130953: GREATER
130954: IFFALSE 131029
// begin if not HasTask ( group [ i ] ) then
130956: LD_VAR 0 4
130960: PUSH
130961: LD_VAR 0 7
130965: ARRAY
130966: PPUSH
130967: CALL_OW 314
130971: NOT
130972: IFFALSE 131027
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130974: LD_VAR 0 4
130978: PUSH
130979: LD_VAR 0 7
130983: ARRAY
130984: PPUSH
130985: LD_VAR 0 16
130989: PUSH
130990: LD_VAR 0 7
130994: ARRAY
130995: PUSH
130996: LD_INT 1
130998: ARRAY
130999: PUSH
131000: LD_INT 1
131002: ARRAY
131003: PPUSH
131004: LD_VAR 0 16
131008: PUSH
131009: LD_VAR 0 7
131013: ARRAY
131014: PUSH
131015: LD_INT 1
131017: ARRAY
131018: PUSH
131019: LD_INT 2
131021: ARRAY
131022: PPUSH
131023: CALL_OW 114
// end else
131027: GO 131080
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
131029: LD_ADDR_VAR 0 15
131033: PUSH
131034: LD_VAR 0 16
131038: PUSH
131039: LD_VAR 0 7
131043: ARRAY
131044: PPUSH
131045: LD_INT 1
131047: PPUSH
131048: CALL_OW 3
131052: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
131053: LD_ADDR_VAR 0 16
131057: PUSH
131058: LD_VAR 0 16
131062: PPUSH
131063: LD_VAR 0 7
131067: PPUSH
131068: LD_VAR 0 15
131072: PPUSH
131073: CALL_OW 1
131077: ST_TO_ADDR
// continue ;
131078: GO 129623
// end ; end ; end else
131080: GO 133744
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
131082: LD_ADDR_VAR 0 14
131086: PUSH
131087: LD_INT 81
131089: PUSH
131090: LD_VAR 0 4
131094: PUSH
131095: LD_VAR 0 7
131099: ARRAY
131100: PPUSH
131101: CALL_OW 255
131105: PUSH
131106: EMPTY
131107: LIST
131108: LIST
131109: PPUSH
131110: CALL_OW 69
131114: ST_TO_ADDR
// if not tmp then
131115: LD_VAR 0 14
131119: NOT
131120: IFFALSE 131124
// continue ;
131122: GO 129623
// if f_ignore_area then
131124: LD_VAR 0 17
131128: IFFALSE 131216
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
131130: LD_ADDR_VAR 0 15
131134: PUSH
131135: LD_VAR 0 14
131139: PPUSH
131140: LD_INT 3
131142: PUSH
131143: LD_INT 92
131145: PUSH
131146: LD_VAR 0 17
131150: PUSH
131151: LD_INT 1
131153: ARRAY
131154: PUSH
131155: LD_VAR 0 17
131159: PUSH
131160: LD_INT 2
131162: ARRAY
131163: PUSH
131164: LD_VAR 0 17
131168: PUSH
131169: LD_INT 3
131171: ARRAY
131172: PUSH
131173: EMPTY
131174: LIST
131175: LIST
131176: LIST
131177: LIST
131178: PUSH
131179: EMPTY
131180: LIST
131181: LIST
131182: PPUSH
131183: CALL_OW 72
131187: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131188: LD_VAR 0 14
131192: PUSH
131193: LD_VAR 0 15
131197: DIFF
131198: IFFALSE 131216
// tmp := tmp diff tmp2 ;
131200: LD_ADDR_VAR 0 14
131204: PUSH
131205: LD_VAR 0 14
131209: PUSH
131210: LD_VAR 0 15
131214: DIFF
131215: ST_TO_ADDR
// end ; if not f_murder then
131216: LD_VAR 0 20
131220: NOT
131221: IFFALSE 131279
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
131223: LD_ADDR_VAR 0 15
131227: PUSH
131228: LD_VAR 0 14
131232: PPUSH
131233: LD_INT 3
131235: PUSH
131236: LD_INT 50
131238: PUSH
131239: EMPTY
131240: LIST
131241: PUSH
131242: EMPTY
131243: LIST
131244: LIST
131245: PPUSH
131246: CALL_OW 72
131250: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
131251: LD_VAR 0 14
131255: PUSH
131256: LD_VAR 0 15
131260: DIFF
131261: IFFALSE 131279
// tmp := tmp diff tmp2 ;
131263: LD_ADDR_VAR 0 14
131267: PUSH
131268: LD_VAR 0 14
131272: PUSH
131273: LD_VAR 0 15
131277: DIFF
131278: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
131279: LD_ADDR_VAR 0 14
131283: PUSH
131284: LD_VAR 0 4
131288: PUSH
131289: LD_VAR 0 7
131293: ARRAY
131294: PPUSH
131295: LD_VAR 0 14
131299: PPUSH
131300: LD_INT 1
131302: PPUSH
131303: LD_INT 1
131305: PPUSH
131306: CALL 73154 0 4
131310: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
131311: LD_VAR 0 4
131315: PUSH
131316: LD_VAR 0 7
131320: ARRAY
131321: PPUSH
131322: CALL_OW 257
131326: PUSH
131327: LD_INT 1
131329: EQUAL
131330: IFFALSE 131778
// begin if WantPlant ( group [ i ] ) then
131332: LD_VAR 0 4
131336: PUSH
131337: LD_VAR 0 7
131341: ARRAY
131342: PPUSH
131343: CALL 72655 0 1
131347: IFFALSE 131351
// continue ;
131349: GO 129623
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
131351: LD_VAR 0 18
131355: PUSH
131356: LD_VAR 0 4
131360: PUSH
131361: LD_VAR 0 7
131365: ARRAY
131366: PPUSH
131367: CALL_OW 310
131371: NOT
131372: AND
131373: PUSH
131374: LD_VAR 0 14
131378: PUSH
131379: LD_INT 1
131381: ARRAY
131382: PUSH
131383: LD_VAR 0 14
131387: PPUSH
131388: LD_INT 21
131390: PUSH
131391: LD_INT 2
131393: PUSH
131394: EMPTY
131395: LIST
131396: LIST
131397: PUSH
131398: LD_INT 58
131400: PUSH
131401: EMPTY
131402: LIST
131403: PUSH
131404: EMPTY
131405: LIST
131406: LIST
131407: PPUSH
131408: CALL_OW 72
131412: IN
131413: AND
131414: IFFALSE 131450
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
131416: LD_VAR 0 4
131420: PUSH
131421: LD_VAR 0 7
131425: ARRAY
131426: PPUSH
131427: LD_VAR 0 14
131431: PUSH
131432: LD_INT 1
131434: ARRAY
131435: PPUSH
131436: CALL_OW 120
// attacking := true ;
131440: LD_ADDR_VAR 0 29
131444: PUSH
131445: LD_INT 1
131447: ST_TO_ADDR
// continue ;
131448: GO 129623
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
131450: LD_VAR 0 26
131454: PUSH
131455: LD_VAR 0 4
131459: PUSH
131460: LD_VAR 0 7
131464: ARRAY
131465: PPUSH
131466: CALL_OW 257
131470: PUSH
131471: LD_INT 1
131473: EQUAL
131474: AND
131475: PUSH
131476: LD_VAR 0 4
131480: PUSH
131481: LD_VAR 0 7
131485: ARRAY
131486: PPUSH
131487: CALL_OW 256
131491: PUSH
131492: LD_INT 800
131494: LESS
131495: AND
131496: PUSH
131497: LD_VAR 0 4
131501: PUSH
131502: LD_VAR 0 7
131506: ARRAY
131507: PPUSH
131508: CALL_OW 318
131512: NOT
131513: AND
131514: IFFALSE 131531
// ComCrawl ( group [ i ] ) ;
131516: LD_VAR 0 4
131520: PUSH
131521: LD_VAR 0 7
131525: ARRAY
131526: PPUSH
131527: CALL_OW 137
// if f_mines then
131531: LD_VAR 0 21
131535: IFFALSE 131778
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
131537: LD_VAR 0 14
131541: PUSH
131542: LD_INT 1
131544: ARRAY
131545: PPUSH
131546: CALL_OW 247
131550: PUSH
131551: LD_INT 3
131553: EQUAL
131554: PUSH
131555: LD_VAR 0 14
131559: PUSH
131560: LD_INT 1
131562: ARRAY
131563: PUSH
131564: LD_VAR 0 27
131568: IN
131569: NOT
131570: AND
131571: IFFALSE 131778
// begin x := GetX ( tmp [ 1 ] ) ;
131573: LD_ADDR_VAR 0 10
131577: PUSH
131578: LD_VAR 0 14
131582: PUSH
131583: LD_INT 1
131585: ARRAY
131586: PPUSH
131587: CALL_OW 250
131591: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
131592: LD_ADDR_VAR 0 11
131596: PUSH
131597: LD_VAR 0 14
131601: PUSH
131602: LD_INT 1
131604: ARRAY
131605: PPUSH
131606: CALL_OW 251
131610: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
131611: LD_ADDR_VAR 0 12
131615: PUSH
131616: LD_VAR 0 4
131620: PUSH
131621: LD_VAR 0 7
131625: ARRAY
131626: PPUSH
131627: CALL 100298 0 1
131631: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
131632: LD_VAR 0 4
131636: PUSH
131637: LD_VAR 0 7
131641: ARRAY
131642: PPUSH
131643: LD_VAR 0 10
131647: PPUSH
131648: LD_VAR 0 11
131652: PPUSH
131653: LD_VAR 0 14
131657: PUSH
131658: LD_INT 1
131660: ARRAY
131661: PPUSH
131662: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
131666: LD_VAR 0 4
131670: PUSH
131671: LD_VAR 0 7
131675: ARRAY
131676: PPUSH
131677: LD_VAR 0 10
131681: PPUSH
131682: LD_VAR 0 12
131686: PPUSH
131687: LD_INT 7
131689: PPUSH
131690: CALL_OW 272
131694: PPUSH
131695: LD_VAR 0 11
131699: PPUSH
131700: LD_VAR 0 12
131704: PPUSH
131705: LD_INT 7
131707: PPUSH
131708: CALL_OW 273
131712: PPUSH
131713: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131717: LD_VAR 0 4
131721: PUSH
131722: LD_VAR 0 7
131726: ARRAY
131727: PPUSH
131728: LD_INT 71
131730: PPUSH
131731: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131735: LD_ADDR_VAR 0 27
131739: PUSH
131740: LD_VAR 0 27
131744: PPUSH
131745: LD_VAR 0 27
131749: PUSH
131750: LD_INT 1
131752: PLUS
131753: PPUSH
131754: LD_VAR 0 14
131758: PUSH
131759: LD_INT 1
131761: ARRAY
131762: PPUSH
131763: CALL_OW 1
131767: ST_TO_ADDR
// attacking := true ;
131768: LD_ADDR_VAR 0 29
131772: PUSH
131773: LD_INT 1
131775: ST_TO_ADDR
// continue ;
131776: GO 129623
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131778: LD_VAR 0 4
131782: PUSH
131783: LD_VAR 0 7
131787: ARRAY
131788: PPUSH
131789: CALL_OW 257
131793: PUSH
131794: LD_INT 17
131796: EQUAL
131797: PUSH
131798: LD_VAR 0 4
131802: PUSH
131803: LD_VAR 0 7
131807: ARRAY
131808: PPUSH
131809: CALL_OW 110
131813: PUSH
131814: LD_INT 71
131816: EQUAL
131817: NOT
131818: AND
131819: IFFALSE 131965
// begin attacking := false ;
131821: LD_ADDR_VAR 0 29
131825: PUSH
131826: LD_INT 0
131828: ST_TO_ADDR
// k := 5 ;
131829: LD_ADDR_VAR 0 9
131833: PUSH
131834: LD_INT 5
131836: ST_TO_ADDR
// if tmp < k then
131837: LD_VAR 0 14
131841: PUSH
131842: LD_VAR 0 9
131846: LESS
131847: IFFALSE 131859
// k := tmp ;
131849: LD_ADDR_VAR 0 9
131853: PUSH
131854: LD_VAR 0 14
131858: ST_TO_ADDR
// for j = 1 to k do
131859: LD_ADDR_VAR 0 8
131863: PUSH
131864: DOUBLE
131865: LD_INT 1
131867: DEC
131868: ST_TO_ADDR
131869: LD_VAR 0 9
131873: PUSH
131874: FOR_TO
131875: IFFALSE 131963
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131877: LD_VAR 0 14
131881: PUSH
131882: LD_VAR 0 8
131886: ARRAY
131887: PUSH
131888: LD_VAR 0 14
131892: PPUSH
131893: LD_INT 58
131895: PUSH
131896: EMPTY
131897: LIST
131898: PPUSH
131899: CALL_OW 72
131903: IN
131904: NOT
131905: IFFALSE 131961
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131907: LD_VAR 0 4
131911: PUSH
131912: LD_VAR 0 7
131916: ARRAY
131917: PPUSH
131918: LD_VAR 0 14
131922: PUSH
131923: LD_VAR 0 8
131927: ARRAY
131928: PPUSH
131929: CALL_OW 115
// attacking := true ;
131933: LD_ADDR_VAR 0 29
131937: PUSH
131938: LD_INT 1
131940: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131941: LD_VAR 0 4
131945: PUSH
131946: LD_VAR 0 7
131950: ARRAY
131951: PPUSH
131952: LD_INT 71
131954: PPUSH
131955: CALL_OW 109
// continue ;
131959: GO 131874
// end ; end ;
131961: GO 131874
131963: POP
131964: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131965: LD_VAR 0 4
131969: PUSH
131970: LD_VAR 0 7
131974: ARRAY
131975: PPUSH
131976: CALL_OW 257
131980: PUSH
131981: LD_INT 8
131983: EQUAL
131984: PUSH
131985: LD_VAR 0 4
131989: PUSH
131990: LD_VAR 0 7
131994: ARRAY
131995: PPUSH
131996: CALL_OW 264
132000: PUSH
132001: LD_INT 28
132003: PUSH
132004: LD_INT 45
132006: PUSH
132007: LD_INT 7
132009: PUSH
132010: LD_INT 47
132012: PUSH
132013: EMPTY
132014: LIST
132015: LIST
132016: LIST
132017: LIST
132018: IN
132019: OR
132020: IFFALSE 132276
// begin attacking := false ;
132022: LD_ADDR_VAR 0 29
132026: PUSH
132027: LD_INT 0
132029: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
132030: LD_VAR 0 14
132034: PUSH
132035: LD_INT 1
132037: ARRAY
132038: PPUSH
132039: CALL_OW 266
132043: PUSH
132044: LD_INT 32
132046: PUSH
132047: LD_INT 31
132049: PUSH
132050: LD_INT 33
132052: PUSH
132053: LD_INT 4
132055: PUSH
132056: LD_INT 5
132058: PUSH
132059: EMPTY
132060: LIST
132061: LIST
132062: LIST
132063: LIST
132064: LIST
132065: IN
132066: IFFALSE 132252
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
132068: LD_ADDR_VAR 0 9
132072: PUSH
132073: LD_VAR 0 14
132077: PUSH
132078: LD_INT 1
132080: ARRAY
132081: PPUSH
132082: CALL_OW 266
132086: PPUSH
132087: LD_VAR 0 14
132091: PUSH
132092: LD_INT 1
132094: ARRAY
132095: PPUSH
132096: CALL_OW 250
132100: PPUSH
132101: LD_VAR 0 14
132105: PUSH
132106: LD_INT 1
132108: ARRAY
132109: PPUSH
132110: CALL_OW 251
132114: PPUSH
132115: LD_VAR 0 14
132119: PUSH
132120: LD_INT 1
132122: ARRAY
132123: PPUSH
132124: CALL_OW 254
132128: PPUSH
132129: LD_VAR 0 14
132133: PUSH
132134: LD_INT 1
132136: ARRAY
132137: PPUSH
132138: CALL_OW 248
132142: PPUSH
132143: LD_INT 0
132145: PPUSH
132146: CALL 81668 0 6
132150: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
132151: LD_ADDR_VAR 0 8
132155: PUSH
132156: LD_VAR 0 4
132160: PUSH
132161: LD_VAR 0 7
132165: ARRAY
132166: PPUSH
132167: LD_VAR 0 9
132171: PPUSH
132172: CALL 100411 0 2
132176: ST_TO_ADDR
// if j then
132177: LD_VAR 0 8
132181: IFFALSE 132250
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
132183: LD_VAR 0 8
132187: PUSH
132188: LD_INT 1
132190: ARRAY
132191: PPUSH
132192: LD_VAR 0 8
132196: PUSH
132197: LD_INT 2
132199: ARRAY
132200: PPUSH
132201: CALL_OW 488
132205: IFFALSE 132250
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
132207: LD_VAR 0 4
132211: PUSH
132212: LD_VAR 0 7
132216: ARRAY
132217: PPUSH
132218: LD_VAR 0 8
132222: PUSH
132223: LD_INT 1
132225: ARRAY
132226: PPUSH
132227: LD_VAR 0 8
132231: PUSH
132232: LD_INT 2
132234: ARRAY
132235: PPUSH
132236: CALL_OW 116
// attacking := true ;
132240: LD_ADDR_VAR 0 29
132244: PUSH
132245: LD_INT 1
132247: ST_TO_ADDR
// continue ;
132248: GO 129623
// end ; end else
132250: GO 132276
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132252: LD_VAR 0 4
132256: PUSH
132257: LD_VAR 0 7
132261: ARRAY
132262: PPUSH
132263: LD_VAR 0 14
132267: PUSH
132268: LD_INT 1
132270: ARRAY
132271: PPUSH
132272: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
132276: LD_VAR 0 4
132280: PUSH
132281: LD_VAR 0 7
132285: ARRAY
132286: PPUSH
132287: CALL_OW 265
132291: PUSH
132292: LD_INT 11
132294: EQUAL
132295: IFFALSE 132573
// begin k := 10 ;
132297: LD_ADDR_VAR 0 9
132301: PUSH
132302: LD_INT 10
132304: ST_TO_ADDR
// x := 0 ;
132305: LD_ADDR_VAR 0 10
132309: PUSH
132310: LD_INT 0
132312: ST_TO_ADDR
// if tmp < k then
132313: LD_VAR 0 14
132317: PUSH
132318: LD_VAR 0 9
132322: LESS
132323: IFFALSE 132335
// k := tmp ;
132325: LD_ADDR_VAR 0 9
132329: PUSH
132330: LD_VAR 0 14
132334: ST_TO_ADDR
// for j = k downto 1 do
132335: LD_ADDR_VAR 0 8
132339: PUSH
132340: DOUBLE
132341: LD_VAR 0 9
132345: INC
132346: ST_TO_ADDR
132347: LD_INT 1
132349: PUSH
132350: FOR_DOWNTO
132351: IFFALSE 132426
// begin if GetType ( tmp [ j ] ) = unit_human then
132353: LD_VAR 0 14
132357: PUSH
132358: LD_VAR 0 8
132362: ARRAY
132363: PPUSH
132364: CALL_OW 247
132368: PUSH
132369: LD_INT 1
132371: EQUAL
132372: IFFALSE 132424
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
132374: LD_VAR 0 4
132378: PUSH
132379: LD_VAR 0 7
132383: ARRAY
132384: PPUSH
132385: LD_VAR 0 14
132389: PUSH
132390: LD_VAR 0 8
132394: ARRAY
132395: PPUSH
132396: CALL 100665 0 2
// x := tmp [ j ] ;
132400: LD_ADDR_VAR 0 10
132404: PUSH
132405: LD_VAR 0 14
132409: PUSH
132410: LD_VAR 0 8
132414: ARRAY
132415: ST_TO_ADDR
// attacking := true ;
132416: LD_ADDR_VAR 0 29
132420: PUSH
132421: LD_INT 1
132423: ST_TO_ADDR
// end ; end ;
132424: GO 132350
132426: POP
132427: POP
// if not x then
132428: LD_VAR 0 10
132432: NOT
132433: IFFALSE 132573
// begin attacking := true ;
132435: LD_ADDR_VAR 0 29
132439: PUSH
132440: LD_INT 1
132442: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
132443: LD_VAR 0 4
132447: PUSH
132448: LD_VAR 0 7
132452: ARRAY
132453: PPUSH
132454: CALL_OW 250
132458: PPUSH
132459: LD_VAR 0 4
132463: PUSH
132464: LD_VAR 0 7
132468: ARRAY
132469: PPUSH
132470: CALL_OW 251
132474: PPUSH
132475: CALL_OW 546
132479: PUSH
132480: LD_INT 2
132482: ARRAY
132483: PUSH
132484: LD_VAR 0 14
132488: PUSH
132489: LD_INT 1
132491: ARRAY
132492: PPUSH
132493: CALL_OW 250
132497: PPUSH
132498: LD_VAR 0 14
132502: PUSH
132503: LD_INT 1
132505: ARRAY
132506: PPUSH
132507: CALL_OW 251
132511: PPUSH
132512: CALL_OW 546
132516: PUSH
132517: LD_INT 2
132519: ARRAY
132520: EQUAL
132521: IFFALSE 132549
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
132523: LD_VAR 0 4
132527: PUSH
132528: LD_VAR 0 7
132532: ARRAY
132533: PPUSH
132534: LD_VAR 0 14
132538: PUSH
132539: LD_INT 1
132541: ARRAY
132542: PPUSH
132543: CALL 100665 0 2
132547: GO 132573
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132549: LD_VAR 0 4
132553: PUSH
132554: LD_VAR 0 7
132558: ARRAY
132559: PPUSH
132560: LD_VAR 0 14
132564: PUSH
132565: LD_INT 1
132567: ARRAY
132568: PPUSH
132569: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
132573: LD_VAR 0 4
132577: PUSH
132578: LD_VAR 0 7
132582: ARRAY
132583: PPUSH
132584: CALL_OW 264
132588: PUSH
132589: LD_INT 29
132591: EQUAL
132592: IFFALSE 132958
// begin if WantsToAttack ( group [ i ] ) in bombed then
132594: LD_VAR 0 4
132598: PUSH
132599: LD_VAR 0 7
132603: ARRAY
132604: PPUSH
132605: CALL_OW 319
132609: PUSH
132610: LD_VAR 0 28
132614: IN
132615: IFFALSE 132619
// continue ;
132617: GO 129623
// k := 8 ;
132619: LD_ADDR_VAR 0 9
132623: PUSH
132624: LD_INT 8
132626: ST_TO_ADDR
// x := 0 ;
132627: LD_ADDR_VAR 0 10
132631: PUSH
132632: LD_INT 0
132634: ST_TO_ADDR
// if tmp < k then
132635: LD_VAR 0 14
132639: PUSH
132640: LD_VAR 0 9
132644: LESS
132645: IFFALSE 132657
// k := tmp ;
132647: LD_ADDR_VAR 0 9
132651: PUSH
132652: LD_VAR 0 14
132656: ST_TO_ADDR
// for j = 1 to k do
132657: LD_ADDR_VAR 0 8
132661: PUSH
132662: DOUBLE
132663: LD_INT 1
132665: DEC
132666: ST_TO_ADDR
132667: LD_VAR 0 9
132671: PUSH
132672: FOR_TO
132673: IFFALSE 132805
// begin if GetType ( tmp [ j ] ) = unit_building then
132675: LD_VAR 0 14
132679: PUSH
132680: LD_VAR 0 8
132684: ARRAY
132685: PPUSH
132686: CALL_OW 247
132690: PUSH
132691: LD_INT 3
132693: EQUAL
132694: IFFALSE 132803
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132696: LD_VAR 0 14
132700: PUSH
132701: LD_VAR 0 8
132705: ARRAY
132706: PUSH
132707: LD_VAR 0 28
132711: IN
132712: NOT
132713: PUSH
132714: LD_VAR 0 14
132718: PUSH
132719: LD_VAR 0 8
132723: ARRAY
132724: PPUSH
132725: CALL_OW 313
132729: AND
132730: IFFALSE 132803
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132732: LD_VAR 0 4
132736: PUSH
132737: LD_VAR 0 7
132741: ARRAY
132742: PPUSH
132743: LD_VAR 0 14
132747: PUSH
132748: LD_VAR 0 8
132752: ARRAY
132753: PPUSH
132754: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132758: LD_ADDR_VAR 0 28
132762: PUSH
132763: LD_VAR 0 28
132767: PPUSH
132768: LD_VAR 0 28
132772: PUSH
132773: LD_INT 1
132775: PLUS
132776: PPUSH
132777: LD_VAR 0 14
132781: PUSH
132782: LD_VAR 0 8
132786: ARRAY
132787: PPUSH
132788: CALL_OW 1
132792: ST_TO_ADDR
// attacking := true ;
132793: LD_ADDR_VAR 0 29
132797: PUSH
132798: LD_INT 1
132800: ST_TO_ADDR
// break ;
132801: GO 132805
// end ; end ;
132803: GO 132672
132805: POP
132806: POP
// if not attacking and f_attack_depot then
132807: LD_VAR 0 29
132811: NOT
132812: PUSH
132813: LD_VAR 0 25
132817: AND
132818: IFFALSE 132913
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132820: LD_ADDR_VAR 0 13
132824: PUSH
132825: LD_VAR 0 14
132829: PPUSH
132830: LD_INT 2
132832: PUSH
132833: LD_INT 30
132835: PUSH
132836: LD_INT 0
132838: PUSH
132839: EMPTY
132840: LIST
132841: LIST
132842: PUSH
132843: LD_INT 30
132845: PUSH
132846: LD_INT 1
132848: PUSH
132849: EMPTY
132850: LIST
132851: LIST
132852: PUSH
132853: EMPTY
132854: LIST
132855: LIST
132856: LIST
132857: PPUSH
132858: CALL_OW 72
132862: ST_TO_ADDR
// if z then
132863: LD_VAR 0 13
132867: IFFALSE 132913
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132869: LD_VAR 0 4
132873: PUSH
132874: LD_VAR 0 7
132878: ARRAY
132879: PPUSH
132880: LD_VAR 0 13
132884: PPUSH
132885: LD_VAR 0 4
132889: PUSH
132890: LD_VAR 0 7
132894: ARRAY
132895: PPUSH
132896: CALL_OW 74
132900: PPUSH
132901: CALL_OW 115
// attacking := true ;
132905: LD_ADDR_VAR 0 29
132909: PUSH
132910: LD_INT 1
132912: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132913: LD_VAR 0 4
132917: PUSH
132918: LD_VAR 0 7
132922: ARRAY
132923: PPUSH
132924: CALL_OW 256
132928: PUSH
132929: LD_INT 500
132931: LESS
132932: IFFALSE 132958
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132934: LD_VAR 0 4
132938: PUSH
132939: LD_VAR 0 7
132943: ARRAY
132944: PPUSH
132945: LD_VAR 0 14
132949: PUSH
132950: LD_INT 1
132952: ARRAY
132953: PPUSH
132954: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132958: LD_VAR 0 4
132962: PUSH
132963: LD_VAR 0 7
132967: ARRAY
132968: PPUSH
132969: CALL_OW 264
132973: PUSH
132974: LD_INT 49
132976: EQUAL
132977: IFFALSE 133098
// begin if not HasTask ( group [ i ] ) then
132979: LD_VAR 0 4
132983: PUSH
132984: LD_VAR 0 7
132988: ARRAY
132989: PPUSH
132990: CALL_OW 314
132994: NOT
132995: IFFALSE 133098
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132997: LD_ADDR_VAR 0 9
133001: PUSH
133002: LD_INT 81
133004: PUSH
133005: LD_VAR 0 4
133009: PUSH
133010: LD_VAR 0 7
133014: ARRAY
133015: PPUSH
133016: CALL_OW 255
133020: PUSH
133021: EMPTY
133022: LIST
133023: LIST
133024: PPUSH
133025: CALL_OW 69
133029: PPUSH
133030: LD_VAR 0 4
133034: PUSH
133035: LD_VAR 0 7
133039: ARRAY
133040: PPUSH
133041: CALL_OW 74
133045: ST_TO_ADDR
// if k then
133046: LD_VAR 0 9
133050: IFFALSE 133098
// if GetDistUnits ( group [ i ] , k ) > 10 then
133052: LD_VAR 0 4
133056: PUSH
133057: LD_VAR 0 7
133061: ARRAY
133062: PPUSH
133063: LD_VAR 0 9
133067: PPUSH
133068: CALL_OW 296
133072: PUSH
133073: LD_INT 10
133075: GREATER
133076: IFFALSE 133098
// ComMoveUnit ( group [ i ] , k ) ;
133078: LD_VAR 0 4
133082: PUSH
133083: LD_VAR 0 7
133087: ARRAY
133088: PPUSH
133089: LD_VAR 0 9
133093: PPUSH
133094: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
133098: LD_VAR 0 4
133102: PUSH
133103: LD_VAR 0 7
133107: ARRAY
133108: PPUSH
133109: CALL_OW 256
133113: PUSH
133114: LD_INT 250
133116: LESS
133117: PUSH
133118: LD_VAR 0 4
133122: PUSH
133123: LD_VAR 0 7
133127: ARRAY
133128: PUSH
133129: LD_INT 21
133131: PUSH
133132: LD_INT 2
133134: PUSH
133135: EMPTY
133136: LIST
133137: LIST
133138: PUSH
133139: LD_INT 23
133141: PUSH
133142: LD_INT 2
133144: PUSH
133145: EMPTY
133146: LIST
133147: LIST
133148: PUSH
133149: EMPTY
133150: LIST
133151: LIST
133152: PPUSH
133153: CALL_OW 69
133157: IN
133158: AND
133159: IFFALSE 133284
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
133161: LD_ADDR_VAR 0 9
133165: PUSH
133166: LD_OWVAR 3
133170: PUSH
133171: LD_VAR 0 4
133175: PUSH
133176: LD_VAR 0 7
133180: ARRAY
133181: DIFF
133182: PPUSH
133183: LD_VAR 0 4
133187: PUSH
133188: LD_VAR 0 7
133192: ARRAY
133193: PPUSH
133194: CALL_OW 74
133198: ST_TO_ADDR
// if not k then
133199: LD_VAR 0 9
133203: NOT
133204: IFFALSE 133208
// continue ;
133206: GO 129623
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
133208: LD_VAR 0 9
133212: PUSH
133213: LD_INT 81
133215: PUSH
133216: LD_VAR 0 4
133220: PUSH
133221: LD_VAR 0 7
133225: ARRAY
133226: PPUSH
133227: CALL_OW 255
133231: PUSH
133232: EMPTY
133233: LIST
133234: LIST
133235: PPUSH
133236: CALL_OW 69
133240: IN
133241: PUSH
133242: LD_VAR 0 9
133246: PPUSH
133247: LD_VAR 0 4
133251: PUSH
133252: LD_VAR 0 7
133256: ARRAY
133257: PPUSH
133258: CALL_OW 296
133262: PUSH
133263: LD_INT 5
133265: LESS
133266: AND
133267: IFFALSE 133284
// ComAutodestruct ( group [ i ] ) ;
133269: LD_VAR 0 4
133273: PUSH
133274: LD_VAR 0 7
133278: ARRAY
133279: PPUSH
133280: CALL 100563 0 1
// end ; if f_attack_depot then
133284: LD_VAR 0 25
133288: IFFALSE 133400
// begin k := 6 ;
133290: LD_ADDR_VAR 0 9
133294: PUSH
133295: LD_INT 6
133297: ST_TO_ADDR
// if tmp < k then
133298: LD_VAR 0 14
133302: PUSH
133303: LD_VAR 0 9
133307: LESS
133308: IFFALSE 133320
// k := tmp ;
133310: LD_ADDR_VAR 0 9
133314: PUSH
133315: LD_VAR 0 14
133319: ST_TO_ADDR
// for j = 1 to k do
133320: LD_ADDR_VAR 0 8
133324: PUSH
133325: DOUBLE
133326: LD_INT 1
133328: DEC
133329: ST_TO_ADDR
133330: LD_VAR 0 9
133334: PUSH
133335: FOR_TO
133336: IFFALSE 133398
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
133338: LD_VAR 0 8
133342: PPUSH
133343: CALL_OW 266
133347: PUSH
133348: LD_INT 0
133350: PUSH
133351: LD_INT 1
133353: PUSH
133354: EMPTY
133355: LIST
133356: LIST
133357: IN
133358: IFFALSE 133396
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133360: LD_VAR 0 4
133364: PUSH
133365: LD_VAR 0 7
133369: ARRAY
133370: PPUSH
133371: LD_VAR 0 14
133375: PUSH
133376: LD_VAR 0 8
133380: ARRAY
133381: PPUSH
133382: CALL_OW 115
// attacking := true ;
133386: LD_ADDR_VAR 0 29
133390: PUSH
133391: LD_INT 1
133393: ST_TO_ADDR
// break ;
133394: GO 133398
// end ;
133396: GO 133335
133398: POP
133399: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
133400: LD_VAR 0 4
133404: PUSH
133405: LD_VAR 0 7
133409: ARRAY
133410: PPUSH
133411: CALL_OW 302
133415: PUSH
133416: LD_VAR 0 29
133420: NOT
133421: AND
133422: IFFALSE 133744
// begin if GetTag ( group [ i ] ) = 71 then
133424: LD_VAR 0 4
133428: PUSH
133429: LD_VAR 0 7
133433: ARRAY
133434: PPUSH
133435: CALL_OW 110
133439: PUSH
133440: LD_INT 71
133442: EQUAL
133443: IFFALSE 133484
// begin if HasTask ( group [ i ] ) then
133445: LD_VAR 0 4
133449: PUSH
133450: LD_VAR 0 7
133454: ARRAY
133455: PPUSH
133456: CALL_OW 314
133460: IFFALSE 133466
// continue else
133462: GO 129623
133464: GO 133484
// SetTag ( group [ i ] , 0 ) ;
133466: LD_VAR 0 4
133470: PUSH
133471: LD_VAR 0 7
133475: ARRAY
133476: PPUSH
133477: LD_INT 0
133479: PPUSH
133480: CALL_OW 109
// end ; k := 8 ;
133484: LD_ADDR_VAR 0 9
133488: PUSH
133489: LD_INT 8
133491: ST_TO_ADDR
// x := 0 ;
133492: LD_ADDR_VAR 0 10
133496: PUSH
133497: LD_INT 0
133499: ST_TO_ADDR
// if tmp < k then
133500: LD_VAR 0 14
133504: PUSH
133505: LD_VAR 0 9
133509: LESS
133510: IFFALSE 133522
// k := tmp ;
133512: LD_ADDR_VAR 0 9
133516: PUSH
133517: LD_VAR 0 14
133521: ST_TO_ADDR
// for j = 1 to k do
133522: LD_ADDR_VAR 0 8
133526: PUSH
133527: DOUBLE
133528: LD_INT 1
133530: DEC
133531: ST_TO_ADDR
133532: LD_VAR 0 9
133536: PUSH
133537: FOR_TO
133538: IFFALSE 133636
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
133540: LD_VAR 0 14
133544: PUSH
133545: LD_VAR 0 8
133549: ARRAY
133550: PPUSH
133551: CALL_OW 247
133555: PUSH
133556: LD_INT 1
133558: EQUAL
133559: PUSH
133560: LD_VAR 0 14
133564: PUSH
133565: LD_VAR 0 8
133569: ARRAY
133570: PPUSH
133571: CALL_OW 256
133575: PUSH
133576: LD_INT 250
133578: LESS
133579: PUSH
133580: LD_VAR 0 20
133584: AND
133585: PUSH
133586: LD_VAR 0 20
133590: NOT
133591: PUSH
133592: LD_VAR 0 14
133596: PUSH
133597: LD_VAR 0 8
133601: ARRAY
133602: PPUSH
133603: CALL_OW 256
133607: PUSH
133608: LD_INT 250
133610: GREATEREQUAL
133611: AND
133612: OR
133613: AND
133614: IFFALSE 133634
// begin x := tmp [ j ] ;
133616: LD_ADDR_VAR 0 10
133620: PUSH
133621: LD_VAR 0 14
133625: PUSH
133626: LD_VAR 0 8
133630: ARRAY
133631: ST_TO_ADDR
// break ;
133632: GO 133636
// end ;
133634: GO 133537
133636: POP
133637: POP
// if x then
133638: LD_VAR 0 10
133642: IFFALSE 133666
// ComAttackUnit ( group [ i ] , x ) else
133644: LD_VAR 0 4
133648: PUSH
133649: LD_VAR 0 7
133653: ARRAY
133654: PPUSH
133655: LD_VAR 0 10
133659: PPUSH
133660: CALL_OW 115
133664: GO 133690
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133666: LD_VAR 0 4
133670: PUSH
133671: LD_VAR 0 7
133675: ARRAY
133676: PPUSH
133677: LD_VAR 0 14
133681: PUSH
133682: LD_INT 1
133684: ARRAY
133685: PPUSH
133686: CALL_OW 115
// if not HasTask ( group [ i ] ) then
133690: LD_VAR 0 4
133694: PUSH
133695: LD_VAR 0 7
133699: ARRAY
133700: PPUSH
133701: CALL_OW 314
133705: NOT
133706: IFFALSE 133744
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133708: LD_VAR 0 4
133712: PUSH
133713: LD_VAR 0 7
133717: ARRAY
133718: PPUSH
133719: LD_VAR 0 14
133723: PPUSH
133724: LD_VAR 0 4
133728: PUSH
133729: LD_VAR 0 7
133733: ARRAY
133734: PPUSH
133735: CALL_OW 74
133739: PPUSH
133740: CALL_OW 115
// end ; end ; end ;
133744: GO 129623
133746: POP
133747: POP
// wait ( 0 0$2 ) ;
133748: LD_INT 70
133750: PPUSH
133751: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133755: LD_VAR 0 4
133759: NOT
133760: PUSH
133761: LD_VAR 0 4
133765: PUSH
133766: EMPTY
133767: EQUAL
133768: OR
133769: PUSH
133770: LD_INT 81
133772: PUSH
133773: LD_VAR 0 35
133777: PUSH
133778: EMPTY
133779: LIST
133780: LIST
133781: PPUSH
133782: CALL_OW 69
133786: NOT
133787: OR
133788: IFFALSE 129608
// end ;
133790: LD_VAR 0 2
133794: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133795: LD_INT 0
133797: PPUSH
133798: PPUSH
133799: PPUSH
133800: PPUSH
133801: PPUSH
133802: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133803: LD_VAR 0 1
133807: NOT
133808: PUSH
133809: LD_EXP 100
133813: PUSH
133814: LD_VAR 0 1
133818: ARRAY
133819: NOT
133820: OR
133821: PUSH
133822: LD_VAR 0 2
133826: NOT
133827: OR
133828: IFFALSE 133832
// exit ;
133830: GO 134386
// side := mc_sides [ base ] ;
133832: LD_ADDR_VAR 0 6
133836: PUSH
133837: LD_EXP 126
133841: PUSH
133842: LD_VAR 0 1
133846: ARRAY
133847: ST_TO_ADDR
// if not side then
133848: LD_VAR 0 6
133852: NOT
133853: IFFALSE 133857
// exit ;
133855: GO 134386
// for i in solds do
133857: LD_ADDR_VAR 0 7
133861: PUSH
133862: LD_VAR 0 2
133866: PUSH
133867: FOR_IN
133868: IFFALSE 133929
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133870: LD_VAR 0 7
133874: PPUSH
133875: CALL_OW 310
133879: PPUSH
133880: CALL_OW 266
133884: PUSH
133885: LD_INT 32
133887: PUSH
133888: LD_INT 31
133890: PUSH
133891: EMPTY
133892: LIST
133893: LIST
133894: IN
133895: IFFALSE 133915
// solds := solds diff i else
133897: LD_ADDR_VAR 0 2
133901: PUSH
133902: LD_VAR 0 2
133906: PUSH
133907: LD_VAR 0 7
133911: DIFF
133912: ST_TO_ADDR
133913: GO 133927
// SetTag ( i , 18 ) ;
133915: LD_VAR 0 7
133919: PPUSH
133920: LD_INT 18
133922: PPUSH
133923: CALL_OW 109
133927: GO 133867
133929: POP
133930: POP
// if not solds then
133931: LD_VAR 0 2
133935: NOT
133936: IFFALSE 133940
// exit ;
133938: GO 134386
// repeat wait ( 0 0$2 ) ;
133940: LD_INT 70
133942: PPUSH
133943: CALL_OW 67
// enemy := mc_scan [ base ] ;
133947: LD_ADDR_VAR 0 4
133951: PUSH
133952: LD_EXP 123
133956: PUSH
133957: LD_VAR 0 1
133961: ARRAY
133962: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133963: LD_EXP 100
133967: PUSH
133968: LD_VAR 0 1
133972: ARRAY
133973: NOT
133974: PUSH
133975: LD_EXP 100
133979: PUSH
133980: LD_VAR 0 1
133984: ARRAY
133985: PUSH
133986: EMPTY
133987: EQUAL
133988: OR
133989: IFFALSE 134026
// begin for i in solds do
133991: LD_ADDR_VAR 0 7
133995: PUSH
133996: LD_VAR 0 2
134000: PUSH
134001: FOR_IN
134002: IFFALSE 134015
// ComStop ( i ) ;
134004: LD_VAR 0 7
134008: PPUSH
134009: CALL_OW 141
134013: GO 134001
134015: POP
134016: POP
// solds := [ ] ;
134017: LD_ADDR_VAR 0 2
134021: PUSH
134022: EMPTY
134023: ST_TO_ADDR
// exit ;
134024: GO 134386
// end ; for i in solds do
134026: LD_ADDR_VAR 0 7
134030: PUSH
134031: LD_VAR 0 2
134035: PUSH
134036: FOR_IN
134037: IFFALSE 134358
// begin if IsInUnit ( i ) then
134039: LD_VAR 0 7
134043: PPUSH
134044: CALL_OW 310
134048: IFFALSE 134059
// ComExitBuilding ( i ) ;
134050: LD_VAR 0 7
134054: PPUSH
134055: CALL_OW 122
// if GetLives ( i ) > 500 then
134059: LD_VAR 0 7
134063: PPUSH
134064: CALL_OW 256
134068: PUSH
134069: LD_INT 500
134071: GREATER
134072: IFFALSE 134125
// begin e := NearestUnitToUnit ( enemy , i ) ;
134074: LD_ADDR_VAR 0 5
134078: PUSH
134079: LD_VAR 0 4
134083: PPUSH
134084: LD_VAR 0 7
134088: PPUSH
134089: CALL_OW 74
134093: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
134094: LD_VAR 0 7
134098: PPUSH
134099: LD_VAR 0 5
134103: PPUSH
134104: CALL_OW 250
134108: PPUSH
134109: LD_VAR 0 5
134113: PPUSH
134114: CALL_OW 251
134118: PPUSH
134119: CALL_OW 114
// end else
134123: GO 134356
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
134125: LD_VAR 0 7
134129: PPUSH
134130: LD_EXP 100
134134: PUSH
134135: LD_VAR 0 1
134139: ARRAY
134140: PPUSH
134141: LD_INT 2
134143: PUSH
134144: LD_INT 30
134146: PUSH
134147: LD_INT 0
134149: PUSH
134150: EMPTY
134151: LIST
134152: LIST
134153: PUSH
134154: LD_INT 30
134156: PUSH
134157: LD_INT 1
134159: PUSH
134160: EMPTY
134161: LIST
134162: LIST
134163: PUSH
134164: LD_INT 30
134166: PUSH
134167: LD_INT 6
134169: PUSH
134170: EMPTY
134171: LIST
134172: LIST
134173: PUSH
134174: EMPTY
134175: LIST
134176: LIST
134177: LIST
134178: LIST
134179: PPUSH
134180: CALL_OW 72
134184: PPUSH
134185: LD_VAR 0 7
134189: PPUSH
134190: CALL_OW 74
134194: PPUSH
134195: CALL_OW 296
134199: PUSH
134200: LD_INT 10
134202: GREATER
134203: IFFALSE 134356
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
134205: LD_ADDR_VAR 0 8
134209: PUSH
134210: LD_EXP 100
134214: PUSH
134215: LD_VAR 0 1
134219: ARRAY
134220: PPUSH
134221: LD_INT 2
134223: PUSH
134224: LD_INT 30
134226: PUSH
134227: LD_INT 0
134229: PUSH
134230: EMPTY
134231: LIST
134232: LIST
134233: PUSH
134234: LD_INT 30
134236: PUSH
134237: LD_INT 1
134239: PUSH
134240: EMPTY
134241: LIST
134242: LIST
134243: PUSH
134244: LD_INT 30
134246: PUSH
134247: LD_INT 6
134249: PUSH
134250: EMPTY
134251: LIST
134252: LIST
134253: PUSH
134254: EMPTY
134255: LIST
134256: LIST
134257: LIST
134258: LIST
134259: PPUSH
134260: CALL_OW 72
134264: PPUSH
134265: LD_VAR 0 7
134269: PPUSH
134270: CALL_OW 74
134274: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
134275: LD_VAR 0 7
134279: PPUSH
134280: LD_VAR 0 8
134284: PPUSH
134285: CALL_OW 250
134289: PPUSH
134290: LD_INT 3
134292: PPUSH
134293: LD_INT 5
134295: PPUSH
134296: CALL_OW 272
134300: PPUSH
134301: LD_VAR 0 8
134305: PPUSH
134306: CALL_OW 251
134310: PPUSH
134311: LD_INT 3
134313: PPUSH
134314: LD_INT 5
134316: PPUSH
134317: CALL_OW 273
134321: PPUSH
134322: CALL_OW 111
// SetTag ( i , 0 ) ;
134326: LD_VAR 0 7
134330: PPUSH
134331: LD_INT 0
134333: PPUSH
134334: CALL_OW 109
// solds := solds diff i ;
134338: LD_ADDR_VAR 0 2
134342: PUSH
134343: LD_VAR 0 2
134347: PUSH
134348: LD_VAR 0 7
134352: DIFF
134353: ST_TO_ADDR
// continue ;
134354: GO 134036
// end ; end ;
134356: GO 134036
134358: POP
134359: POP
// until not solds or not enemy ;
134360: LD_VAR 0 2
134364: NOT
134365: PUSH
134366: LD_VAR 0 4
134370: NOT
134371: OR
134372: IFFALSE 133940
// MC_Reset ( base , 18 ) ;
134374: LD_VAR 0 1
134378: PPUSH
134379: LD_INT 18
134381: PPUSH
134382: CALL 41041 0 2
// end ;
134386: LD_VAR 0 3
134390: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
134391: LD_INT 0
134393: PPUSH
134394: PPUSH
134395: PPUSH
134396: PPUSH
134397: PPUSH
134398: PPUSH
134399: PPUSH
134400: PPUSH
134401: PPUSH
134402: PPUSH
134403: PPUSH
134404: PPUSH
134405: PPUSH
134406: PPUSH
134407: PPUSH
134408: PPUSH
134409: PPUSH
134410: PPUSH
134411: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
134412: LD_ADDR_VAR 0 12
134416: PUSH
134417: LD_EXP 100
134421: PUSH
134422: LD_VAR 0 1
134426: ARRAY
134427: PPUSH
134428: LD_INT 25
134430: PUSH
134431: LD_INT 3
134433: PUSH
134434: EMPTY
134435: LIST
134436: LIST
134437: PPUSH
134438: CALL_OW 72
134442: ST_TO_ADDR
// if mc_remote_driver [ base ] then
134443: LD_EXP 140
134447: PUSH
134448: LD_VAR 0 1
134452: ARRAY
134453: IFFALSE 134477
// mechs := mechs diff mc_remote_driver [ base ] ;
134455: LD_ADDR_VAR 0 12
134459: PUSH
134460: LD_VAR 0 12
134464: PUSH
134465: LD_EXP 140
134469: PUSH
134470: LD_VAR 0 1
134474: ARRAY
134475: DIFF
134476: ST_TO_ADDR
// for i in mechs do
134477: LD_ADDR_VAR 0 4
134481: PUSH
134482: LD_VAR 0 12
134486: PUSH
134487: FOR_IN
134488: IFFALSE 134523
// if GetTag ( i ) > 0 then
134490: LD_VAR 0 4
134494: PPUSH
134495: CALL_OW 110
134499: PUSH
134500: LD_INT 0
134502: GREATER
134503: IFFALSE 134521
// mechs := mechs diff i ;
134505: LD_ADDR_VAR 0 12
134509: PUSH
134510: LD_VAR 0 12
134514: PUSH
134515: LD_VAR 0 4
134519: DIFF
134520: ST_TO_ADDR
134521: GO 134487
134523: POP
134524: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
134525: LD_ADDR_VAR 0 8
134529: PUSH
134530: LD_EXP 100
134534: PUSH
134535: LD_VAR 0 1
134539: ARRAY
134540: PPUSH
134541: LD_INT 2
134543: PUSH
134544: LD_INT 25
134546: PUSH
134547: LD_INT 1
134549: PUSH
134550: EMPTY
134551: LIST
134552: LIST
134553: PUSH
134554: LD_INT 25
134556: PUSH
134557: LD_INT 5
134559: PUSH
134560: EMPTY
134561: LIST
134562: LIST
134563: PUSH
134564: LD_INT 25
134566: PUSH
134567: LD_INT 8
134569: PUSH
134570: EMPTY
134571: LIST
134572: LIST
134573: PUSH
134574: LD_INT 25
134576: PUSH
134577: LD_INT 9
134579: PUSH
134580: EMPTY
134581: LIST
134582: LIST
134583: PUSH
134584: EMPTY
134585: LIST
134586: LIST
134587: LIST
134588: LIST
134589: LIST
134590: PPUSH
134591: CALL_OW 72
134595: ST_TO_ADDR
// if not defenders and not solds then
134596: LD_VAR 0 2
134600: NOT
134601: PUSH
134602: LD_VAR 0 8
134606: NOT
134607: AND
134608: IFFALSE 134612
// exit ;
134610: GO 136382
// depot_under_attack := false ;
134612: LD_ADDR_VAR 0 16
134616: PUSH
134617: LD_INT 0
134619: ST_TO_ADDR
// sold_defenders := [ ] ;
134620: LD_ADDR_VAR 0 17
134624: PUSH
134625: EMPTY
134626: ST_TO_ADDR
// if mechs then
134627: LD_VAR 0 12
134631: IFFALSE 134784
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
134633: LD_ADDR_VAR 0 4
134637: PUSH
134638: LD_VAR 0 2
134642: PPUSH
134643: LD_INT 21
134645: PUSH
134646: LD_INT 2
134648: PUSH
134649: EMPTY
134650: LIST
134651: LIST
134652: PPUSH
134653: CALL_OW 72
134657: PUSH
134658: FOR_IN
134659: IFFALSE 134782
// begin if GetTag ( i ) <> 20 then
134661: LD_VAR 0 4
134665: PPUSH
134666: CALL_OW 110
134670: PUSH
134671: LD_INT 20
134673: NONEQUAL
134674: IFFALSE 134688
// SetTag ( i , 20 ) ;
134676: LD_VAR 0 4
134680: PPUSH
134681: LD_INT 20
134683: PPUSH
134684: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
134688: LD_VAR 0 4
134692: PPUSH
134693: CALL_OW 263
134697: PUSH
134698: LD_INT 1
134700: EQUAL
134701: PUSH
134702: LD_VAR 0 4
134706: PPUSH
134707: CALL_OW 311
134711: NOT
134712: AND
134713: IFFALSE 134780
// begin un := mechs [ 1 ] ;
134715: LD_ADDR_VAR 0 10
134719: PUSH
134720: LD_VAR 0 12
134724: PUSH
134725: LD_INT 1
134727: ARRAY
134728: ST_TO_ADDR
// ComExit ( un ) ;
134729: LD_VAR 0 10
134733: PPUSH
134734: CALL 105448 0 1
// AddComEnterUnit ( un , i ) ;
134738: LD_VAR 0 10
134742: PPUSH
134743: LD_VAR 0 4
134747: PPUSH
134748: CALL_OW 180
// SetTag ( un , 19 ) ;
134752: LD_VAR 0 10
134756: PPUSH
134757: LD_INT 19
134759: PPUSH
134760: CALL_OW 109
// mechs := mechs diff un ;
134764: LD_ADDR_VAR 0 12
134768: PUSH
134769: LD_VAR 0 12
134773: PUSH
134774: LD_VAR 0 10
134778: DIFF
134779: ST_TO_ADDR
// end ; end ;
134780: GO 134658
134782: POP
134783: POP
// if solds then
134784: LD_VAR 0 8
134788: IFFALSE 134847
// for i in solds do
134790: LD_ADDR_VAR 0 4
134794: PUSH
134795: LD_VAR 0 8
134799: PUSH
134800: FOR_IN
134801: IFFALSE 134845
// if not GetTag ( i ) then
134803: LD_VAR 0 4
134807: PPUSH
134808: CALL_OW 110
134812: NOT
134813: IFFALSE 134843
// begin defenders := defenders union i ;
134815: LD_ADDR_VAR 0 2
134819: PUSH
134820: LD_VAR 0 2
134824: PUSH
134825: LD_VAR 0 4
134829: UNION
134830: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134831: LD_VAR 0 4
134835: PPUSH
134836: LD_INT 18
134838: PPUSH
134839: CALL_OW 109
// end ;
134843: GO 134800
134845: POP
134846: POP
// repeat wait ( 0 0$2 ) ;
134847: LD_INT 70
134849: PPUSH
134850: CALL_OW 67
// enemy := mc_scan [ base ] ;
134854: LD_ADDR_VAR 0 21
134858: PUSH
134859: LD_EXP 123
134863: PUSH
134864: LD_VAR 0 1
134868: ARRAY
134869: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134870: LD_EXP 100
134874: PUSH
134875: LD_VAR 0 1
134879: ARRAY
134880: NOT
134881: PUSH
134882: LD_EXP 100
134886: PUSH
134887: LD_VAR 0 1
134891: ARRAY
134892: PUSH
134893: EMPTY
134894: EQUAL
134895: OR
134896: IFFALSE 134933
// begin for i in defenders do
134898: LD_ADDR_VAR 0 4
134902: PUSH
134903: LD_VAR 0 2
134907: PUSH
134908: FOR_IN
134909: IFFALSE 134922
// ComStop ( i ) ;
134911: LD_VAR 0 4
134915: PPUSH
134916: CALL_OW 141
134920: GO 134908
134922: POP
134923: POP
// defenders := [ ] ;
134924: LD_ADDR_VAR 0 2
134928: PUSH
134929: EMPTY
134930: ST_TO_ADDR
// exit ;
134931: GO 136382
// end ; for i in defenders do
134933: LD_ADDR_VAR 0 4
134937: PUSH
134938: LD_VAR 0 2
134942: PUSH
134943: FOR_IN
134944: IFFALSE 135842
// begin e := NearestUnitToUnit ( enemy , i ) ;
134946: LD_ADDR_VAR 0 13
134950: PUSH
134951: LD_VAR 0 21
134955: PPUSH
134956: LD_VAR 0 4
134960: PPUSH
134961: CALL_OW 74
134965: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134966: LD_ADDR_VAR 0 7
134970: PUSH
134971: LD_EXP 100
134975: PUSH
134976: LD_VAR 0 1
134980: ARRAY
134981: PPUSH
134982: LD_INT 2
134984: PUSH
134985: LD_INT 30
134987: PUSH
134988: LD_INT 0
134990: PUSH
134991: EMPTY
134992: LIST
134993: LIST
134994: PUSH
134995: LD_INT 30
134997: PUSH
134998: LD_INT 1
135000: PUSH
135001: EMPTY
135002: LIST
135003: LIST
135004: PUSH
135005: EMPTY
135006: LIST
135007: LIST
135008: LIST
135009: PPUSH
135010: CALL_OW 72
135014: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
135015: LD_ADDR_VAR 0 16
135019: PUSH
135020: LD_VAR 0 7
135024: NOT
135025: PUSH
135026: LD_VAR 0 7
135030: PPUSH
135031: LD_INT 3
135033: PUSH
135034: LD_INT 24
135036: PUSH
135037: LD_INT 600
135039: PUSH
135040: EMPTY
135041: LIST
135042: LIST
135043: PUSH
135044: EMPTY
135045: LIST
135046: LIST
135047: PPUSH
135048: CALL_OW 72
135052: OR
135053: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
135054: LD_VAR 0 4
135058: PPUSH
135059: CALL_OW 247
135063: PUSH
135064: LD_INT 2
135066: DOUBLE
135067: EQUAL
135068: IFTRUE 135072
135070: GO 135468
135072: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
135073: LD_VAR 0 4
135077: PPUSH
135078: CALL_OW 256
135082: PUSH
135083: LD_INT 1000
135085: EQUAL
135086: PUSH
135087: LD_VAR 0 4
135091: PPUSH
135092: LD_VAR 0 13
135096: PPUSH
135097: CALL_OW 296
135101: PUSH
135102: LD_INT 40
135104: LESS
135105: PUSH
135106: LD_VAR 0 13
135110: PPUSH
135111: LD_EXP 125
135115: PUSH
135116: LD_VAR 0 1
135120: ARRAY
135121: PPUSH
135122: CALL_OW 308
135126: OR
135127: AND
135128: IFFALSE 135250
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
135130: LD_VAR 0 4
135134: PPUSH
135135: CALL_OW 262
135139: PUSH
135140: LD_INT 1
135142: EQUAL
135143: PUSH
135144: LD_VAR 0 4
135148: PPUSH
135149: CALL_OW 261
135153: PUSH
135154: LD_INT 30
135156: LESS
135157: AND
135158: PUSH
135159: LD_VAR 0 7
135163: AND
135164: IFFALSE 135234
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
135166: LD_VAR 0 4
135170: PPUSH
135171: LD_VAR 0 7
135175: PPUSH
135176: LD_VAR 0 4
135180: PPUSH
135181: CALL_OW 74
135185: PPUSH
135186: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
135190: LD_VAR 0 4
135194: PPUSH
135195: LD_VAR 0 7
135199: PPUSH
135200: LD_VAR 0 4
135204: PPUSH
135205: CALL_OW 74
135209: PPUSH
135210: CALL_OW 296
135214: PUSH
135215: LD_INT 6
135217: LESS
135218: IFFALSE 135232
// SetFuel ( i , 100 ) ;
135220: LD_VAR 0 4
135224: PPUSH
135225: LD_INT 100
135227: PPUSH
135228: CALL_OW 240
// end else
135232: GO 135248
// ComAttackUnit ( i , e ) ;
135234: LD_VAR 0 4
135238: PPUSH
135239: LD_VAR 0 13
135243: PPUSH
135244: CALL_OW 115
// end else
135248: GO 135351
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
135250: LD_VAR 0 13
135254: PPUSH
135255: LD_EXP 125
135259: PUSH
135260: LD_VAR 0 1
135264: ARRAY
135265: PPUSH
135266: CALL_OW 308
135270: NOT
135271: PUSH
135272: LD_VAR 0 4
135276: PPUSH
135277: LD_VAR 0 13
135281: PPUSH
135282: CALL_OW 296
135286: PUSH
135287: LD_INT 40
135289: GREATEREQUAL
135290: AND
135291: PUSH
135292: LD_VAR 0 4
135296: PPUSH
135297: CALL_OW 256
135301: PUSH
135302: LD_INT 650
135304: LESSEQUAL
135305: OR
135306: PUSH
135307: LD_VAR 0 4
135311: PPUSH
135312: LD_EXP 124
135316: PUSH
135317: LD_VAR 0 1
135321: ARRAY
135322: PPUSH
135323: CALL_OW 308
135327: NOT
135328: AND
135329: IFFALSE 135351
// ComMoveToArea ( i , mc_parking [ base ] ) ;
135331: LD_VAR 0 4
135335: PPUSH
135336: LD_EXP 124
135340: PUSH
135341: LD_VAR 0 1
135345: ARRAY
135346: PPUSH
135347: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
135351: LD_VAR 0 4
135355: PPUSH
135356: CALL_OW 256
135360: PUSH
135361: LD_INT 1000
135363: LESS
135364: PUSH
135365: LD_VAR 0 4
135369: PPUSH
135370: CALL_OW 263
135374: PUSH
135375: LD_INT 1
135377: EQUAL
135378: AND
135379: PUSH
135380: LD_VAR 0 4
135384: PPUSH
135385: CALL_OW 311
135389: AND
135390: PUSH
135391: LD_VAR 0 4
135395: PPUSH
135396: LD_EXP 124
135400: PUSH
135401: LD_VAR 0 1
135405: ARRAY
135406: PPUSH
135407: CALL_OW 308
135411: AND
135412: IFFALSE 135466
// begin mech := IsDrivenBy ( i ) ;
135414: LD_ADDR_VAR 0 9
135418: PUSH
135419: LD_VAR 0 4
135423: PPUSH
135424: CALL_OW 311
135428: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
135429: LD_VAR 0 9
135433: PPUSH
135434: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
135438: LD_VAR 0 9
135442: PPUSH
135443: LD_VAR 0 4
135447: PPUSH
135448: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
135452: LD_VAR 0 9
135456: PPUSH
135457: LD_VAR 0 4
135461: PPUSH
135462: CALL_OW 180
// end ; end ; unit_human :
135466: GO 135813
135468: LD_INT 1
135470: DOUBLE
135471: EQUAL
135472: IFTRUE 135476
135474: GO 135812
135476: POP
// begin b := IsInUnit ( i ) ;
135477: LD_ADDR_VAR 0 18
135481: PUSH
135482: LD_VAR 0 4
135486: PPUSH
135487: CALL_OW 310
135491: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
135492: LD_ADDR_VAR 0 19
135496: PUSH
135497: LD_VAR 0 18
135501: NOT
135502: PUSH
135503: LD_VAR 0 18
135507: PPUSH
135508: CALL_OW 266
135512: PUSH
135513: LD_INT 32
135515: PUSH
135516: LD_INT 31
135518: PUSH
135519: EMPTY
135520: LIST
135521: LIST
135522: IN
135523: OR
135524: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
135525: LD_VAR 0 18
135529: PPUSH
135530: CALL_OW 266
135534: PUSH
135535: LD_INT 5
135537: EQUAL
135538: PUSH
135539: LD_VAR 0 4
135543: PPUSH
135544: CALL_OW 257
135548: PUSH
135549: LD_INT 1
135551: PUSH
135552: LD_INT 2
135554: PUSH
135555: LD_INT 3
135557: PUSH
135558: LD_INT 4
135560: PUSH
135561: EMPTY
135562: LIST
135563: LIST
135564: LIST
135565: LIST
135566: IN
135567: AND
135568: IFFALSE 135605
// begin class := AllowSpecClass ( i ) ;
135570: LD_ADDR_VAR 0 20
135574: PUSH
135575: LD_VAR 0 4
135579: PPUSH
135580: CALL 69368 0 1
135584: ST_TO_ADDR
// if class then
135585: LD_VAR 0 20
135589: IFFALSE 135605
// ComChangeProfession ( i , class ) ;
135591: LD_VAR 0 4
135595: PPUSH
135596: LD_VAR 0 20
135600: PPUSH
135601: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
135605: LD_VAR 0 16
135609: PUSH
135610: LD_VAR 0 2
135614: PPUSH
135615: LD_INT 21
135617: PUSH
135618: LD_INT 2
135620: PUSH
135621: EMPTY
135622: LIST
135623: LIST
135624: PPUSH
135625: CALL_OW 72
135629: PUSH
135630: LD_INT 1
135632: LESSEQUAL
135633: OR
135634: PUSH
135635: LD_VAR 0 19
135639: AND
135640: PUSH
135641: LD_VAR 0 4
135645: PUSH
135646: LD_VAR 0 17
135650: IN
135651: NOT
135652: AND
135653: IFFALSE 135746
// begin if b then
135655: LD_VAR 0 18
135659: IFFALSE 135708
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
135661: LD_VAR 0 18
135665: PPUSH
135666: LD_VAR 0 21
135670: PPUSH
135671: LD_VAR 0 18
135675: PPUSH
135676: CALL_OW 74
135680: PPUSH
135681: CALL_OW 296
135685: PUSH
135686: LD_INT 10
135688: LESS
135689: PUSH
135690: LD_VAR 0 18
135694: PPUSH
135695: CALL_OW 461
135699: PUSH
135700: LD_INT 7
135702: NONEQUAL
135703: AND
135704: IFFALSE 135708
// continue ;
135706: GO 134943
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135708: LD_ADDR_VAR 0 17
135712: PUSH
135713: LD_VAR 0 17
135717: PPUSH
135718: LD_VAR 0 17
135722: PUSH
135723: LD_INT 1
135725: PLUS
135726: PPUSH
135727: LD_VAR 0 4
135731: PPUSH
135732: CALL_OW 1
135736: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135737: LD_VAR 0 4
135741: PPUSH
135742: CALL_OW 122
// end ; if sold_defenders then
135746: LD_VAR 0 17
135750: IFFALSE 135810
// if i in sold_defenders then
135752: LD_VAR 0 4
135756: PUSH
135757: LD_VAR 0 17
135761: IN
135762: IFFALSE 135810
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135764: LD_VAR 0 4
135768: PPUSH
135769: CALL_OW 314
135773: NOT
135774: PUSH
135775: LD_VAR 0 4
135779: PPUSH
135780: LD_VAR 0 13
135784: PPUSH
135785: CALL_OW 296
135789: PUSH
135790: LD_INT 30
135792: LESS
135793: AND
135794: IFFALSE 135810
// ComAttackUnit ( i , e ) ;
135796: LD_VAR 0 4
135800: PPUSH
135801: LD_VAR 0 13
135805: PPUSH
135806: CALL_OW 115
// end ; end ; end ;
135810: GO 135813
135812: POP
// if IsDead ( i ) then
135813: LD_VAR 0 4
135817: PPUSH
135818: CALL_OW 301
135822: IFFALSE 135840
// defenders := defenders diff i ;
135824: LD_ADDR_VAR 0 2
135828: PUSH
135829: LD_VAR 0 2
135833: PUSH
135834: LD_VAR 0 4
135838: DIFF
135839: ST_TO_ADDR
// end ;
135840: GO 134943
135842: POP
135843: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135844: LD_VAR 0 21
135848: NOT
135849: PUSH
135850: LD_VAR 0 2
135854: NOT
135855: OR
135856: PUSH
135857: LD_EXP 100
135861: PUSH
135862: LD_VAR 0 1
135866: ARRAY
135867: NOT
135868: OR
135869: IFFALSE 134847
// MC_Reset ( base , 18 ) ;
135871: LD_VAR 0 1
135875: PPUSH
135876: LD_INT 18
135878: PPUSH
135879: CALL 41041 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135883: LD_ADDR_VAR 0 2
135887: PUSH
135888: LD_VAR 0 2
135892: PUSH
135893: LD_VAR 0 2
135897: PPUSH
135898: LD_INT 2
135900: PUSH
135901: LD_INT 25
135903: PUSH
135904: LD_INT 1
135906: PUSH
135907: EMPTY
135908: LIST
135909: LIST
135910: PUSH
135911: LD_INT 25
135913: PUSH
135914: LD_INT 5
135916: PUSH
135917: EMPTY
135918: LIST
135919: LIST
135920: PUSH
135921: LD_INT 25
135923: PUSH
135924: LD_INT 8
135926: PUSH
135927: EMPTY
135928: LIST
135929: LIST
135930: PUSH
135931: LD_INT 25
135933: PUSH
135934: LD_INT 9
135936: PUSH
135937: EMPTY
135938: LIST
135939: LIST
135940: PUSH
135941: EMPTY
135942: LIST
135943: LIST
135944: LIST
135945: LIST
135946: LIST
135947: PPUSH
135948: CALL_OW 72
135952: DIFF
135953: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135954: LD_VAR 0 21
135958: NOT
135959: PUSH
135960: LD_VAR 0 2
135964: PPUSH
135965: LD_INT 21
135967: PUSH
135968: LD_INT 2
135970: PUSH
135971: EMPTY
135972: LIST
135973: LIST
135974: PPUSH
135975: CALL_OW 72
135979: AND
135980: IFFALSE 136318
// begin tmp := FilterByTag ( defenders , 19 ) ;
135982: LD_ADDR_VAR 0 11
135986: PUSH
135987: LD_VAR 0 2
135991: PPUSH
135992: LD_INT 19
135994: PPUSH
135995: CALL 102631 0 2
135999: ST_TO_ADDR
// if tmp then
136000: LD_VAR 0 11
136004: IFFALSE 136074
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
136006: LD_ADDR_VAR 0 11
136010: PUSH
136011: LD_VAR 0 11
136015: PPUSH
136016: LD_INT 25
136018: PUSH
136019: LD_INT 3
136021: PUSH
136022: EMPTY
136023: LIST
136024: LIST
136025: PPUSH
136026: CALL_OW 72
136030: ST_TO_ADDR
// if tmp then
136031: LD_VAR 0 11
136035: IFFALSE 136074
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
136037: LD_ADDR_EXP 112
136041: PUSH
136042: LD_EXP 112
136046: PPUSH
136047: LD_VAR 0 1
136051: PPUSH
136052: LD_EXP 112
136056: PUSH
136057: LD_VAR 0 1
136061: ARRAY
136062: PUSH
136063: LD_VAR 0 11
136067: UNION
136068: PPUSH
136069: CALL_OW 1
136073: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
136074: LD_VAR 0 1
136078: PPUSH
136079: LD_INT 19
136081: PPUSH
136082: CALL 41041 0 2
// repeat wait ( 0 0$1 ) ;
136086: LD_INT 35
136088: PPUSH
136089: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136093: LD_EXP 100
136097: PUSH
136098: LD_VAR 0 1
136102: ARRAY
136103: NOT
136104: PUSH
136105: LD_EXP 100
136109: PUSH
136110: LD_VAR 0 1
136114: ARRAY
136115: PUSH
136116: EMPTY
136117: EQUAL
136118: OR
136119: IFFALSE 136156
// begin for i in defenders do
136121: LD_ADDR_VAR 0 4
136125: PUSH
136126: LD_VAR 0 2
136130: PUSH
136131: FOR_IN
136132: IFFALSE 136145
// ComStop ( i ) ;
136134: LD_VAR 0 4
136138: PPUSH
136139: CALL_OW 141
136143: GO 136131
136145: POP
136146: POP
// defenders := [ ] ;
136147: LD_ADDR_VAR 0 2
136151: PUSH
136152: EMPTY
136153: ST_TO_ADDR
// exit ;
136154: GO 136382
// end ; for i in defenders do
136156: LD_ADDR_VAR 0 4
136160: PUSH
136161: LD_VAR 0 2
136165: PUSH
136166: FOR_IN
136167: IFFALSE 136256
// begin if not IsInArea ( i , mc_parking [ base ] ) then
136169: LD_VAR 0 4
136173: PPUSH
136174: LD_EXP 124
136178: PUSH
136179: LD_VAR 0 1
136183: ARRAY
136184: PPUSH
136185: CALL_OW 308
136189: NOT
136190: IFFALSE 136214
// ComMoveToArea ( i , mc_parking [ base ] ) else
136192: LD_VAR 0 4
136196: PPUSH
136197: LD_EXP 124
136201: PUSH
136202: LD_VAR 0 1
136206: ARRAY
136207: PPUSH
136208: CALL_OW 113
136212: GO 136254
// if GetControl ( i ) = control_manual then
136214: LD_VAR 0 4
136218: PPUSH
136219: CALL_OW 263
136223: PUSH
136224: LD_INT 1
136226: EQUAL
136227: IFFALSE 136254
// if IsDrivenBy ( i ) then
136229: LD_VAR 0 4
136233: PPUSH
136234: CALL_OW 311
136238: IFFALSE 136254
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
136240: LD_VAR 0 4
136244: PPUSH
136245: CALL_OW 311
136249: PPUSH
136250: CALL_OW 121
// end ;
136254: GO 136166
136256: POP
136257: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
136258: LD_VAR 0 2
136262: PPUSH
136263: LD_INT 95
136265: PUSH
136266: LD_EXP 124
136270: PUSH
136271: LD_VAR 0 1
136275: ARRAY
136276: PUSH
136277: EMPTY
136278: LIST
136279: LIST
136280: PPUSH
136281: CALL_OW 72
136285: PUSH
136286: LD_VAR 0 2
136290: EQUAL
136291: PUSH
136292: LD_EXP 123
136296: PUSH
136297: LD_VAR 0 1
136301: ARRAY
136302: OR
136303: PUSH
136304: LD_EXP 100
136308: PUSH
136309: LD_VAR 0 1
136313: ARRAY
136314: NOT
136315: OR
136316: IFFALSE 136086
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
136318: LD_ADDR_EXP 122
136322: PUSH
136323: LD_EXP 122
136327: PPUSH
136328: LD_VAR 0 1
136332: PPUSH
136333: LD_VAR 0 2
136337: PPUSH
136338: LD_INT 21
136340: PUSH
136341: LD_INT 2
136343: PUSH
136344: EMPTY
136345: LIST
136346: LIST
136347: PPUSH
136348: CALL_OW 72
136352: PPUSH
136353: CALL_OW 1
136357: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
136358: LD_VAR 0 1
136362: PPUSH
136363: LD_INT 19
136365: PPUSH
136366: CALL 41041 0 2
// MC_Reset ( base , 20 ) ;
136370: LD_VAR 0 1
136374: PPUSH
136375: LD_INT 20
136377: PPUSH
136378: CALL 41041 0 2
// end ; end_of_file
136382: LD_VAR 0 3
136386: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
136387: LD_VAR 0 1
136391: PUSH
136392: LD_INT 200
136394: DOUBLE
136395: GREATEREQUAL
136396: IFFALSE 136404
136398: LD_INT 299
136400: DOUBLE
136401: LESSEQUAL
136402: IFTRUE 136406
136404: GO 136438
136406: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
136407: LD_VAR 0 1
136411: PPUSH
136412: LD_VAR 0 2
136416: PPUSH
136417: LD_VAR 0 3
136421: PPUSH
136422: LD_VAR 0 4
136426: PPUSH
136427: LD_VAR 0 5
136431: PPUSH
136432: CALL 125173 0 5
136436: GO 136515
136438: LD_INT 300
136440: DOUBLE
136441: GREATEREQUAL
136442: IFFALSE 136450
136444: LD_INT 399
136446: DOUBLE
136447: LESSEQUAL
136448: IFTRUE 136452
136450: GO 136514
136452: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
136453: LD_VAR 0 1
136457: PPUSH
136458: LD_VAR 0 2
136462: PPUSH
136463: LD_VAR 0 3
136467: PPUSH
136468: LD_VAR 0 4
136472: PPUSH
136473: LD_VAR 0 5
136477: PPUSH
136478: LD_VAR 0 6
136482: PPUSH
136483: LD_VAR 0 7
136487: PPUSH
136488: LD_VAR 0 8
136492: PPUSH
136493: LD_VAR 0 9
136497: PPUSH
136498: LD_VAR 0 10
136502: PPUSH
136503: LD_VAR 0 11
136507: PPUSH
136508: CALL 121506 0 11
136512: GO 136515
136514: POP
// end ;
136515: PPOPN 11
136517: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
136518: LD_VAR 0 1
136522: PPUSH
136523: LD_VAR 0 2
136527: PPUSH
136528: LD_VAR 0 3
136532: PPUSH
136533: LD_VAR 0 4
136537: PPUSH
136538: LD_VAR 0 5
136542: PPUSH
136543: CALL 124909 0 5
// end ; end_of_file
136547: PPOPN 5
136549: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
136550: LD_VAR 0 1
136554: PPUSH
136555: LD_VAR 0 2
136559: PPUSH
136560: LD_VAR 0 3
136564: PPUSH
136565: LD_VAR 0 4
136569: PPUSH
136570: LD_VAR 0 5
136574: PPUSH
136575: LD_VAR 0 6
136579: PPUSH
136580: CALL 109158 0 6
// end ;
136584: PPOPN 6
136586: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
136587: LD_INT 0
136589: PPUSH
// begin if not units then
136590: LD_VAR 0 1
136594: NOT
136595: IFFALSE 136599
// exit ;
136597: GO 136599
// end ;
136599: PPOPN 7
136601: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
136602: CALL 109062 0 0
// end ;
136606: PPOPN 1
136608: END
