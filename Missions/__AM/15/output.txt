// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 37863 0 0
// InitNature ;
  19: CALL 37731 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12104 0 0
// PrepareRussian ;
  40: CALL 7197 0 0
// PrepareLegion ;
  44: CALL 4352 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 16845 0 0
// MC_Start ( ) ;
  60: CALL 40043 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 62825 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 62918 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 62268 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62083 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 62825 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 62918 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62083 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 62268 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 62698 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 61746 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 62825 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 62918 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62083 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 62825 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 62918 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 61975 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 63236 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 62407 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 62698 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 62698 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63030 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62083 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 62649 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 68557 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 73397 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 73397 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 73397 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 73397 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 73397 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 68557 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 68557 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 68557 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 68557 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 68557 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 68557 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 68557 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 68557 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 68557 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 68557 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 68557 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 68557 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 68557 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 68557 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 68557 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// tmp := [ ] ;
3222: LD_ADDR_VAR 0 5
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// if JMMGirl <> 2 then
3229: LD_EXP 7
3233: PUSH
3234: LD_INT 2
3236: NONEQUAL
3237: IFFALSE 3261
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 43
3243: PUSH
3244: LD_STRING Lisa
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 68557 0 3
3260: ST_TO_ADDR
// if Lisa then
3261: LD_EXP 43
3265: IFFALSE 3283
// tmp := tmp ^ Lisa ;
3267: LD_ADDR_VAR 0 5
3271: PUSH
3272: LD_VAR 0 5
3276: PUSH
3277: LD_EXP 43
3281: ADD
3282: ST_TO_ADDR
// if JMMGirl < 3 then
3283: LD_EXP 7
3287: PUSH
3288: LD_INT 3
3290: LESS
3291: IFFALSE 3322
// begin Connie := NewCharacter ( Coonie ) ;
3293: LD_ADDR_EXP 55
3297: PUSH
3298: LD_STRING Coonie
3300: PPUSH
3301: CALL_OW 25
3305: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3306: LD_ADDR_VAR 0 5
3310: PUSH
3311: LD_VAR 0 5
3315: PUSH
3316: LD_EXP 55
3320: ADD
3321: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3322: LD_ADDR_EXP 44
3326: PUSH
3327: LD_STRING Donaldson
3329: PPUSH
3330: LD_EXP 1
3334: NOT
3335: PPUSH
3336: LD_STRING 13s_
3338: PPUSH
3339: CALL 68557 0 3
3343: ST_TO_ADDR
// if Donaldson then
3344: LD_EXP 44
3348: IFFALSE 3366
// tmp := tmp ^ Donaldson ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_VAR 0 5
3359: PUSH
3360: LD_EXP 44
3364: ADD
3365: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3366: LD_ADDR_EXP 45
3370: PUSH
3371: LD_STRING Bobby
3373: PPUSH
3374: LD_EXP 1
3378: NOT
3379: PPUSH
3380: LD_STRING 13s_
3382: PPUSH
3383: CALL 68557 0 3
3387: ST_TO_ADDR
// if Bobby then
3388: LD_EXP 45
3392: IFFALSE 3410
// tmp := tmp ^ Bobby ;
3394: LD_ADDR_VAR 0 5
3398: PUSH
3399: LD_VAR 0 5
3403: PUSH
3404: LD_EXP 45
3408: ADD
3409: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3410: LD_ADDR_EXP 46
3414: PUSH
3415: LD_STRING Cyrus
3417: PPUSH
3418: LD_EXP 1
3422: NOT
3423: PPUSH
3424: LD_STRING 13s_
3426: PPUSH
3427: CALL 68557 0 3
3431: ST_TO_ADDR
// if Cyrus then
3432: LD_EXP 46
3436: IFFALSE 3454
// tmp := tmp ^ Cyrus ;
3438: LD_ADDR_VAR 0 5
3442: PUSH
3443: LD_VAR 0 5
3447: PUSH
3448: LD_EXP 46
3452: ADD
3453: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3454: LD_ADDR_EXP 47
3458: PUSH
3459: LD_STRING Denis
3461: PPUSH
3462: LD_EXP 1
3466: NOT
3467: PPUSH
3468: LD_STRING 13s_
3470: PPUSH
3471: CALL 68557 0 3
3475: ST_TO_ADDR
// if not Denis then
3476: LD_EXP 47
3480: NOT
3481: IFFALSE 3505
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3483: LD_ADDR_EXP 47
3487: PUSH
3488: LD_STRING Denis
3490: PPUSH
3491: LD_EXP 1
3495: NOT
3496: PPUSH
3497: LD_STRING 13f_
3499: PPUSH
3500: CALL 68557 0 3
3504: ST_TO_ADDR
// if Denis then
3505: LD_EXP 47
3509: IFFALSE 3527
// tmp := tmp ^ Denis ;
3511: LD_ADDR_VAR 0 5
3515: PUSH
3516: LD_VAR 0 5
3520: PUSH
3521: LD_EXP 47
3525: ADD
3526: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3527: LD_ADDR_EXP 48
3531: PUSH
3532: LD_STRING Brown
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: LD_STRING 13s_
3543: PPUSH
3544: CALL 68557 0 3
3548: ST_TO_ADDR
// if Brown then
3549: LD_EXP 48
3553: IFFALSE 3571
// tmp := tmp ^ Brown ;
3555: LD_ADDR_VAR 0 5
3559: PUSH
3560: LD_VAR 0 5
3564: PUSH
3565: LD_EXP 48
3569: ADD
3570: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3571: LD_ADDR_EXP 49
3575: PUSH
3576: LD_STRING Gladstone
3578: PPUSH
3579: LD_EXP 1
3583: NOT
3584: PPUSH
3585: LD_STRING 13s_
3587: PPUSH
3588: CALL 68557 0 3
3592: ST_TO_ADDR
// if Gladstone then
3593: LD_EXP 49
3597: IFFALSE 3615
// tmp := tmp ^ Gladstone ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_VAR 0 5
3608: PUSH
3609: LD_EXP 49
3613: ADD
3614: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3615: LD_ADDR_EXP 50
3619: PUSH
3620: LD_STRING Houten
3622: PPUSH
3623: LD_EXP 1
3627: NOT
3628: PPUSH
3629: LD_STRING 13s_
3631: PPUSH
3632: CALL 68557 0 3
3636: ST_TO_ADDR
// if Houten then
3637: LD_EXP 50
3641: IFFALSE 3659
// tmp := tmp ^ Houten ;
3643: LD_ADDR_VAR 0 5
3647: PUSH
3648: LD_VAR 0 5
3652: PUSH
3653: LD_EXP 50
3657: ADD
3658: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3659: LD_ADDR_EXP 51
3663: PUSH
3664: LD_STRING Cornel
3666: PPUSH
3667: LD_EXP 1
3671: NOT
3672: PPUSH
3673: LD_STRING 13s_
3675: PPUSH
3676: CALL 68557 0 3
3680: ST_TO_ADDR
// if Cornel then
3681: LD_EXP 51
3685: IFFALSE 3703
// tmp := tmp ^ Cornel ;
3687: LD_ADDR_VAR 0 5
3691: PUSH
3692: LD_VAR 0 5
3696: PUSH
3697: LD_EXP 51
3701: ADD
3702: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3703: LD_ADDR_EXP 52
3707: PUSH
3708: LD_STRING Gary
3710: PPUSH
3711: LD_EXP 1
3715: NOT
3716: PPUSH
3717: LD_STRING 13s_
3719: PPUSH
3720: CALL 68557 0 3
3724: ST_TO_ADDR
// if Gary then
3725: LD_EXP 52
3729: IFFALSE 3747
// tmp := tmp ^ Gary ;
3731: LD_ADDR_VAR 0 5
3735: PUSH
3736: LD_VAR 0 5
3740: PUSH
3741: LD_EXP 52
3745: ADD
3746: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3747: LD_ADDR_EXP 53
3751: PUSH
3752: LD_STRING Frank
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: LD_STRING 13s_
3763: PPUSH
3764: CALL 68557 0 3
3768: ST_TO_ADDR
// if Frank then
3769: LD_EXP 53
3773: IFFALSE 3791
// tmp := tmp ^ Frank ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_VAR 0 5
3784: PUSH
3785: LD_EXP 53
3789: ADD
3790: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3791: LD_ADDR_EXP 54
3795: PUSH
3796: LD_STRING Kikuchi
3798: PPUSH
3799: LD_EXP 1
3803: NOT
3804: PPUSH
3805: LD_STRING 13s_
3807: PPUSH
3808: CALL 68557 0 3
3812: ST_TO_ADDR
// if Kikuchi then
3813: LD_EXP 54
3817: IFFALSE 3835
// tmp := tmp ^ Kikuchi ;
3819: LD_ADDR_VAR 0 5
3823: PUSH
3824: LD_VAR 0 5
3828: PUSH
3829: LD_EXP 54
3833: ADD
3834: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3835: LD_ADDR_EXP 57
3839: PUSH
3840: LD_STRING Mike
3842: PPUSH
3843: LD_EXP 1
3847: NOT
3848: PPUSH
3849: LD_STRING 10c_
3851: PPUSH
3852: CALL 68557 0 3
3856: ST_TO_ADDR
// if Mike then
3857: LD_EXP 57
3861: IFFALSE 3884
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3863: LD_EXP 57
3867: PPUSH
3868: LD_INT 61
3870: PPUSH
3871: LD_INT 89
3873: PPUSH
3874: LD_INT 8
3876: PPUSH
3877: LD_INT 0
3879: PPUSH
3880: CALL_OW 50
// vip := tmp ;
3884: LD_ADDR_EXP 61
3888: PUSH
3889: LD_VAR 0 5
3893: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_STRING 13s_others
3906: PPUSH
3907: CALL_OW 31
3911: UNION
3912: ST_TO_ADDR
// if tmp < 18 then
3913: LD_VAR 0 5
3917: PUSH
3918: LD_INT 18
3920: LESS
3921: IFFALSE 4014
// for i = 1 to 18 - tmp do
3923: LD_ADDR_VAR 0 2
3927: PUSH
3928: DOUBLE
3929: LD_INT 1
3931: DEC
3932: ST_TO_ADDR
3933: LD_INT 18
3935: PUSH
3936: LD_VAR 0 5
3940: MINUS
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4012
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3945: LD_INT 1
3947: PPUSH
3948: LD_VAR 0 2
3952: PUSH
3953: LD_INT 4
3955: MOD
3956: PUSH
3957: LD_INT 1
3959: PLUS
3960: PPUSH
3961: LD_INT 4
3963: PPUSH
3964: CALL_OW 380
// un := CreateHuman ;
3968: LD_ADDR_VAR 0 10
3972: PUSH
3973: CALL_OW 44
3977: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_VAR 0 10
3992: PPUSH
3993: CALL 105849 0 2
3997: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3998: LD_VAR 0 10
4002: PPUSH
4003: LD_INT 1
4005: PPUSH
4006: CALL_OW 109
// end ;
4010: GO 3942
4012: POP
4013: POP
// depot := HexInfo ( 53 , 94 ) ;
4014: LD_ADDR_VAR 0 6
4018: PUSH
4019: LD_INT 53
4021: PPUSH
4022: LD_INT 94
4024: PPUSH
4025: CALL_OW 428
4029: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4030: LD_ADDR_VAR 0 7
4034: PUSH
4035: LD_INT 56
4037: PPUSH
4038: LD_INT 101
4040: PPUSH
4041: CALL_OW 428
4045: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4046: LD_ADDR_VAR 0 8
4050: PUSH
4051: LD_INT 67
4053: PPUSH
4054: LD_INT 101
4056: PPUSH
4057: CALL_OW 428
4061: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4062: LD_ADDR_VAR 0 9
4066: PUSH
4067: LD_INT 54
4069: PPUSH
4070: LD_INT 85
4072: PPUSH
4073: CALL_OW 428
4077: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 8
4087: PUSH
4088: LD_VAR 0 6
4092: PUSH
4093: LD_VAR 0 9
4097: PUSH
4098: LD_VAR 0 7
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: ST_TO_ADDR
// for i in tmp do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_VAR 0 5
4118: PUSH
4119: FOR_IN
4120: IFFALSE 4208
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4122: LD_VAR 0 3
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PPUSH
4131: CALL_OW 313
4135: PUSH
4136: LD_INT 6
4138: EQUAL
4139: IFFALSE 4159
// b := Delete ( b , 1 ) ;
4141: LD_ADDR_VAR 0 3
4145: PUSH
4146: LD_VAR 0 3
4150: PPUSH
4151: LD_INT 1
4153: PPUSH
4154: CALL_OW 3
4158: ST_TO_ADDR
// if b then
4159: LD_VAR 0 3
4163: IFFALSE 4185
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4165: LD_VAR 0 2
4169: PPUSH
4170: LD_VAR 0 3
4174: PUSH
4175: LD_INT 1
4177: ARRAY
4178: PPUSH
4179: CALL_OW 52
4183: GO 4206
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4185: LD_VAR 0 2
4189: PPUSH
4190: LD_INT 61
4192: PPUSH
4193: LD_INT 89
4195: PPUSH
4196: LD_INT 8
4198: PPUSH
4199: LD_INT 0
4201: PPUSH
4202: CALL_OW 50
// end ;
4206: GO 4119
4208: POP
4209: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 1
4218: PPUSH
4219: LD_INT 12
4221: PPUSH
4222: LD_INT 100
4224: PPUSH
4225: CALL 73397 0 5
// veh := CreateVehicle ;
4229: LD_ADDR_VAR 0 4
4233: PUSH
4234: CALL_OW 45
4238: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4239: LD_VAR 0 4
4243: PPUSH
4244: LD_INT 4
4246: PPUSH
4247: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4251: LD_VAR 0 4
4255: PPUSH
4256: LD_INT 49
4258: PPUSH
4259: LD_INT 88
4261: PPUSH
4262: LD_INT 0
4264: PPUSH
4265: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4269: LD_VAR 0 4
4273: PPUSH
4274: LD_INT 1
4276: PPUSH
4277: LD_INT 100
4279: PPUSH
4280: CALL_OW 290
// uc_side := 0 ;
4284: LD_ADDR_OWVAR 20
4288: PUSH
4289: LD_INT 0
4291: ST_TO_ADDR
// uc_nation := 0 ;
4292: LD_ADDR_OWVAR 21
4296: PUSH
4297: LD_INT 0
4299: ST_TO_ADDR
// for i := 1 to 3 do
4300: LD_ADDR_VAR 0 2
4304: PUSH
4305: DOUBLE
4306: LD_INT 1
4308: DEC
4309: ST_TO_ADDR
4310: LD_INT 3
4312: PUSH
4313: FOR_TO
4314: IFFALSE 4345
// begin InitHc ;
4316: CALL_OW 19
// hc_class := class_apeman ;
4320: LD_ADDR_OWVAR 28
4324: PUSH
4325: LD_INT 12
4327: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4328: CALL_OW 44
4332: PPUSH
4333: LD_INT 13
4335: PPUSH
4336: LD_INT 0
4338: PPUSH
4339: CALL_OW 49
// end ;
4343: GO 4313
4345: POP
4346: POP
// end ; end_of_file
4347: LD_VAR 0 1
4351: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4352: LD_INT 0
4354: PPUSH
4355: PPUSH
4356: PPUSH
4357: PPUSH
4358: PPUSH
// side := 8 ;
4359: LD_ADDR_VAR 0 3
4363: PUSH
4364: LD_INT 8
4366: ST_TO_ADDR
// uc_side := side ;
4367: LD_ADDR_OWVAR 20
4371: PUSH
4372: LD_VAR 0 3
4376: ST_TO_ADDR
// uc_nation := 2 ;
4377: LD_ADDR_OWVAR 21
4381: PUSH
4382: LD_INT 2
4384: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4385: LD_ADDR_VAR 0 2
4389: PUSH
4390: LD_INT 22
4392: PUSH
4393: LD_VAR 0 3
4397: PUSH
4398: EMPTY
4399: LIST
4400: LIST
4401: PUSH
4402: LD_INT 21
4404: PUSH
4405: LD_INT 3
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PPUSH
4416: CALL_OW 69
4420: PUSH
4421: FOR_IN
4422: IFFALSE 4438
// SetBLevel ( i , 10 ) ;
4424: LD_VAR 0 2
4428: PPUSH
4429: LD_INT 10
4431: PPUSH
4432: CALL_OW 241
4436: GO 4421
4438: POP
4439: POP
// if KurtStatus then
4440: LD_EXP 3
4444: IFFALSE 4467
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4446: LD_ADDR_EXP 62
4450: PUSH
4451: LD_STRING Kurt
4453: PPUSH
4454: LD_INT 0
4456: PPUSH
4457: LD_STRING 
4459: PPUSH
4460: CALL 68557 0 3
4464: ST_TO_ADDR
4465: GO 4489
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4467: LD_ADDR_EXP 62
4471: PUSH
4472: LD_STRING AltKurt
4474: PPUSH
4475: LD_EXP 1
4479: NOT
4480: PPUSH
4481: LD_STRING 
4483: PPUSH
4484: CALL 68557 0 3
4488: ST_TO_ADDR
// if not Kurt then
4489: LD_EXP 62
4493: NOT
4494: IFFALSE 4520
// begin InitHc ;
4496: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4500: LD_INT 1
4502: PPUSH
4503: LD_INT 10
4505: PPUSH
4506: CALL_OW 381
// Kurt := CreateHuman ;
4510: LD_ADDR_EXP 62
4514: PUSH
4515: CALL_OW 44
4519: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4520: LD_EXP 62
4524: PPUSH
4525: LD_INT 324
4527: PPUSH
4528: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4532: LD_ADDR_EXP 63
4536: PUSH
4537: LD_STRING Kozlov
4539: PPUSH
4540: LD_INT 0
4542: PPUSH
4543: LD_STRING 
4545: PPUSH
4546: CALL 68557 0 3
4550: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4551: LD_EXP 63
4555: PPUSH
4556: LD_INT 22
4558: PUSH
4559: LD_INT 8
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 23
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 30
4578: PUSH
4579: LD_INT 8
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: LIST
4590: PPUSH
4591: CALL_OW 69
4595: PUSH
4596: LD_INT 1
4598: ARRAY
4599: PPUSH
4600: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4604: LD_EXP 63
4608: PPUSH
4609: LD_INT 3
4611: PPUSH
4612: LD_INT 10
4614: PPUSH
4615: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4619: LD_EXP 63
4623: PPUSH
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 10
4629: PPUSH
4630: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4634: LD_ADDR_VAR 0 5
4638: PUSH
4639: LD_INT 22
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PUSH
4651: LD_INT 30
4653: PUSH
4654: LD_INT 32
4656: PUSH
4657: EMPTY
4658: LIST
4659: LIST
4660: PUSH
4661: LD_INT 58
4663: PUSH
4664: EMPTY
4665: LIST
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: LIST
4671: PPUSH
4672: CALL_OW 69
4676: ST_TO_ADDR
// for i = 1 to 10 do
4677: LD_ADDR_VAR 0 2
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_INT 10
4689: PUSH
4690: FOR_TO
4691: IFFALSE 4763
// begin uc_nation := nation_nature ;
4693: LD_ADDR_OWVAR 21
4697: PUSH
4698: LD_INT 0
4700: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4701: LD_ADDR_OWVAR 28
4705: PUSH
4706: LD_INT 15
4708: ST_TO_ADDR
// hc_gallery :=  ;
4709: LD_ADDR_OWVAR 33
4713: PUSH
4714: LD_STRING 
4716: ST_TO_ADDR
// hc_name :=  ;
4717: LD_ADDR_OWVAR 26
4721: PUSH
4722: LD_STRING 
4724: ST_TO_ADDR
// un := CreateHuman ;
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: CALL_OW 44
4734: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4735: LD_VAR 0 4
4739: PPUSH
4740: LD_VAR 0 5
4744: PUSH
4745: LD_VAR 0 5
4749: PUSH
4750: LD_VAR 0 2
4754: MINUS
4755: ARRAY
4756: PPUSH
4757: CALL_OW 52
// end ;
4761: GO 4690
4763: POP
4764: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4765: LD_ADDR_VAR 0 5
4769: PUSH
4770: LD_STRING 12_kurt_squad
4772: PPUSH
4773: CALL_OW 31
4777: ST_TO_ADDR
// if tmp then
4778: LD_VAR 0 5
4782: IFFALSE 4816
// for i in tmp do
4784: LD_ADDR_VAR 0 2
4788: PUSH
4789: LD_VAR 0 5
4793: PUSH
4794: FOR_IN
4795: IFFALSE 4814
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4797: LD_VAR 0 2
4801: PPUSH
4802: LD_INT 5
4804: PPUSH
4805: LD_INT 0
4807: PPUSH
4808: CALL_OW 49
4812: GO 4794
4814: POP
4815: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4816: LD_INT 324
4818: PPUSH
4819: LD_INT 5
4821: PPUSH
4822: LD_STRING 
4824: PPUSH
4825: LD_INT 8
4827: PUSH
4828: LD_INT 9
4830: PUSH
4831: LD_INT 10
4833: PUSH
4834: LD_INT 10
4836: PUSH
4837: EMPTY
4838: LIST
4839: LIST
4840: LIST
4841: LIST
4842: PUSH
4843: LD_OWVAR 67
4847: ARRAY
4848: PPUSH
4849: LD_INT 3000
4851: PUSH
4852: LD_INT 500
4854: PUSH
4855: LD_INT 150
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: LIST
4862: PPUSH
4863: LD_INT 16
4865: PUSH
4866: LD_INT 6
4868: PUSH
4869: LD_INT 6
4871: PUSH
4872: LD_INT 8
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL 76841 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4885: LD_ADDR_EXP 100
4889: PUSH
4890: LD_EXP 100
4894: PPUSH
4895: LD_INT 3
4897: PPUSH
4898: LD_INT 22
4900: PUSH
4901: LD_VAR 0 3
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 23
4912: PUSH
4913: LD_INT 2
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: LD_INT 3
4922: PUSH
4923: LD_INT 21
4925: PUSH
4926: LD_INT 2
4928: PUSH
4929: EMPTY
4930: LIST
4931: LIST
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: LIST
4941: PPUSH
4942: CALL_OW 69
4946: PUSH
4947: LD_EXP 62
4951: DIFF
4952: PPUSH
4953: CALL_OW 1
4957: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4958: LD_INT 1
4960: PPUSH
4961: LD_INT 7
4963: PPUSH
4964: CALL_OW 383
// hc_name := Ali Hadrach ;
4968: LD_ADDR_OWVAR 26
4972: PUSH
4973: LD_STRING Ali Hadrach
4975: ST_TO_ADDR
// hc_face_number := 31 ;
4976: LD_ADDR_OWVAR 34
4980: PUSH
4981: LD_INT 31
4983: ST_TO_ADDR
// Friend := CreateHuman ;
4984: LD_ADDR_EXP 64
4988: PUSH
4989: CALL_OW 44
4993: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4994: LD_INT 14
4996: PPUSH
4997: LD_INT 3
4999: PPUSH
5000: LD_INT 1
5002: PPUSH
5003: LD_INT 29
5005: PPUSH
5006: LD_INT 100
5008: PPUSH
5009: CALL 73397 0 5
// powellBomb := CreateVehicle ;
5013: LD_ADDR_EXP 65
5017: PUSH
5018: CALL_OW 45
5022: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5023: LD_EXP 65
5027: PPUSH
5028: LD_INT 90
5030: PPUSH
5031: LD_INT 51
5033: PPUSH
5034: LD_INT 0
5036: PPUSH
5037: CALL_OW 48
// end ;
5041: LD_VAR 0 1
5045: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
// if IsLive ( kozlov_fac ) then
5051: LD_INT 332
5053: PPUSH
5054: CALL_OW 300
5058: IFFALSE 5062
// exit ;
5060: GO 5629
// ComExitBuilding ( Kozlov ) ;
5062: LD_EXP 63
5066: PPUSH
5067: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5071: LD_EXP 63
5075: PPUSH
5076: CALL_OW 257
5080: PUSH
5081: LD_INT 2
5083: NONEQUAL
5084: IFFALSE 5119
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5086: LD_EXP 63
5090: PPUSH
5091: LD_INT 324
5093: PPUSH
5094: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5098: LD_EXP 63
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5110: LD_EXP 63
5114: PPUSH
5115: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5119: LD_EXP 63
5123: PPUSH
5124: LD_INT 2
5126: PPUSH
5127: LD_INT 93
5129: PPUSH
5130: LD_INT 32
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5140: LD_INT 35
5142: PPUSH
5143: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5147: LD_INT 22
5149: PUSH
5150: LD_INT 8
5152: PUSH
5153: EMPTY
5154: LIST
5155: LIST
5156: PUSH
5157: LD_INT 30
5159: PUSH
5160: LD_INT 3
5162: PUSH
5163: EMPTY
5164: LIST
5165: LIST
5166: PUSH
5167: LD_INT 23
5169: PUSH
5170: LD_INT 3
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 57
5179: PUSH
5180: EMPTY
5181: LIST
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: CALL_OW 69
5193: IFFALSE 5140
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5195: LD_ADDR_VAR 0 2
5199: PUSH
5200: LD_INT 22
5202: PUSH
5203: LD_INT 8
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 30
5212: PUSH
5213: LD_INT 3
5215: PUSH
5216: EMPTY
5217: LIST
5218: LIST
5219: PUSH
5220: LD_INT 23
5222: PUSH
5223: LD_INT 3
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 57
5232: PUSH
5233: EMPTY
5234: LIST
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: PPUSH
5242: CALL_OW 69
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5251: LD_INT 22
5253: PUSH
5254: LD_INT 8
5256: PUSH
5257: EMPTY
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 23
5263: PUSH
5264: LD_INT 3
5266: PUSH
5267: EMPTY
5268: LIST
5269: LIST
5270: PUSH
5271: LD_INT 30
5273: PUSH
5274: LD_INT 21
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: EMPTY
5282: LIST
5283: LIST
5284: LIST
5285: PPUSH
5286: CALL_OW 69
5290: NOT
5291: IFFALSE 5369
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5293: LD_EXP 63
5297: PPUSH
5298: LD_INT 21
5300: PPUSH
5301: LD_INT 97
5303: PPUSH
5304: LD_INT 36
5306: PPUSH
5307: LD_INT 5
5309: PPUSH
5310: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5314: LD_INT 35
5316: PPUSH
5317: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5321: LD_INT 22
5323: PUSH
5324: LD_INT 8
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 23
5333: PUSH
5334: LD_INT 3
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 30
5343: PUSH
5344: LD_INT 21
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: PUSH
5351: LD_INT 57
5353: PUSH
5354: EMPTY
5355: LIST
5356: PUSH
5357: EMPTY
5358: LIST
5359: LIST
5360: LIST
5361: LIST
5362: PPUSH
5363: CALL_OW 69
5367: IFFALSE 5314
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5369: LD_INT 22
5371: PUSH
5372: LD_INT 8
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 23
5381: PUSH
5382: LD_INT 3
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: LD_INT 30
5391: PUSH
5392: LD_INT 18
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: LIST
5403: PPUSH
5404: CALL_OW 69
5408: NOT
5409: IFFALSE 5487
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5411: LD_EXP 63
5415: PPUSH
5416: LD_INT 18
5418: PPUSH
5419: LD_INT 89
5421: PPUSH
5422: LD_INT 32
5424: PPUSH
5425: LD_INT 1
5427: PPUSH
5428: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5432: LD_INT 35
5434: PPUSH
5435: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5439: LD_INT 22
5441: PUSH
5442: LD_INT 8
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 23
5451: PUSH
5452: LD_INT 3
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 30
5461: PUSH
5462: LD_INT 18
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 57
5471: PUSH
5472: EMPTY
5473: LIST
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: LIST
5479: LIST
5480: PPUSH
5481: CALL_OW 69
5485: IFFALSE 5432
// end ; lab := kozlov_lab ;
5487: LD_ADDR_VAR 0 3
5491: PUSH
5492: LD_INT 336
5494: ST_TO_ADDR
// if not lab then
5495: LD_VAR 0 3
5499: NOT
5500: IFFALSE 5504
// exit ;
5502: GO 5629
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5504: LD_EXP 63
5508: PPUSH
5509: LD_VAR 0 3
5513: PUSH
5514: LD_INT 1
5516: ARRAY
5517: PPUSH
5518: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5522: LD_EXP 63
5526: PPUSH
5527: LD_INT 4
5529: PPUSH
5530: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5534: LD_VAR 0 3
5538: PUSH
5539: LD_INT 1
5541: ARRAY
5542: PPUSH
5543: LD_INT 25
5545: PPUSH
5546: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5550: LD_INT 35
5552: PPUSH
5553: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5557: LD_INT 25
5559: PPUSH
5560: LD_INT 8
5562: PPUSH
5563: CALL_OW 321
5567: PUSH
5568: LD_INT 2
5570: EQUAL
5571: IFFALSE 5550
// ComExitBuilding ( Kozlov ) ;
5573: LD_EXP 63
5577: PPUSH
5578: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5582: LD_EXP 63
5586: PPUSH
5587: LD_VAR 0 2
5591: PPUSH
5592: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5596: LD_EXP 63
5600: PPUSH
5601: LD_INT 3
5603: PPUSH
5604: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5608: LD_VAR 0 2
5612: PPUSH
5613: LD_INT 23
5615: PPUSH
5616: LD_INT 3
5618: PPUSH
5619: LD_INT 1
5621: PPUSH
5622: LD_INT 48
5624: PPUSH
5625: CALL_OW 125
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5634: LD_EXP 22
5638: NOT
5639: PUSH
5640: LD_EXP 15
5644: PUSH
5645: LD_INT 6
5647: GREATEREQUAL
5648: AND
5649: IFFALSE 5730
5651: GO 5653
5653: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5654: LD_INT 3
5656: PPUSH
5657: LD_INT 3
5659: PPUSH
5660: CALL 62268 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5664: LD_INT 3
5666: PPUSH
5667: LD_INT 14
5669: PUSH
5670: LD_INT 1
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: LD_INT 28
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: LD_INT 28
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 14
5705: PUSH
5706: LD_INT 1
5708: PUSH
5709: LD_INT 1
5711: PUSH
5712: LD_INT 28
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: LIST
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: PPUSH
5726: CALL 62131 0 2
// end ;
5730: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5731: LD_EXP 22
5735: NOT
5736: PUSH
5737: LD_EXP 15
5741: PUSH
5742: LD_INT 6
5744: GREATEREQUAL
5745: AND
5746: PUSH
5747: LD_INT 3
5749: PPUSH
5750: LD_INT 1
5752: PPUSH
5753: CALL 63549 0 2
5757: NOT
5758: AND
5759: IFFALSE 6633
5761: GO 5763
5763: DISABLE
5764: LD_INT 0
5766: PPUSH
5767: PPUSH
5768: PPUSH
// begin enable ;
5769: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5770: LD_INT 22
5772: PUSH
5773: LD_INT 8
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 23
5782: PUSH
5783: LD_INT 2
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 30
5792: PUSH
5793: LD_INT 3
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL_OW 69
5809: NOT
5810: IFFALSE 5814
// exit ;
5812: GO 6633
// if Prob ( 40 ) then
5814: LD_INT 40
5816: PPUSH
5817: CALL_OW 13
5821: IFFALSE 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5823: LD_INT 3
5825: PPUSH
5826: LD_INT 14
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 28
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: LIST
5843: PUSH
5844: LD_INT 14
5846: PUSH
5847: LD_INT 1
5849: PUSH
5850: LD_INT 2
5852: PUSH
5853: LD_INT 28
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PUSH
5862: LD_INT 14
5864: PUSH
5865: LD_INT 1
5867: PUSH
5868: LD_INT 2
5870: PUSH
5871: LD_INT 28
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 14
5882: PUSH
5883: LD_INT 1
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: LD_INT 28
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 14
5900: PUSH
5901: LD_INT 1
5903: PUSH
5904: LD_INT 2
5906: PUSH
5907: LD_INT 28
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 14
5918: PUSH
5919: LD_INT 1
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: LD_INT 26
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL 62131 0 2
// end else
5946: GO 6155
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5948: LD_INT 3
5950: PPUSH
5951: LD_INT 14
5953: PUSH
5954: LD_INT 1
5956: PUSH
5957: LD_INT 2
5959: PUSH
5960: LD_INT 27
5962: PUSH
5963: LD_INT 26
5965: PUSH
5966: LD_INT 26
5968: PUSH
5969: LD_INT 28
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_OWVAR 67
5982: ARRAY
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: LD_INT 14
5992: PUSH
5993: LD_INT 1
5995: PUSH
5996: LD_INT 2
5998: PUSH
5999: LD_INT 27
6001: PUSH
6002: LD_INT 26
6004: PUSH
6005: LD_INT 26
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: LD_OWVAR 67
6021: ARRAY
6022: PUSH
6023: EMPTY
6024: LIST
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_INT 14
6031: PUSH
6032: LD_INT 1
6034: PUSH
6035: LD_INT 2
6037: PUSH
6038: LD_INT 26
6040: PUSH
6041: LD_INT 26
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 29
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: LIST
6054: LIST
6055: PUSH
6056: LD_OWVAR 67
6060: ARRAY
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: LIST
6067: PUSH
6068: LD_INT 13
6070: PUSH
6071: LD_INT 1
6073: PUSH
6074: LD_INT 2
6076: PUSH
6077: LD_INT 26
6079: PUSH
6080: LD_INT 29
6082: PUSH
6083: LD_INT 29
6085: PUSH
6086: LD_INT 29
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: LIST
6094: PUSH
6095: LD_OWVAR 67
6099: ARRAY
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_INT 13
6109: PUSH
6110: LD_INT 1
6112: PUSH
6113: LD_INT 2
6115: PUSH
6116: LD_INT 29
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: PUSH
6125: LD_INT 14
6127: PUSH
6128: LD_INT 1
6130: PUSH
6131: LD_INT 2
6133: PUSH
6134: LD_INT 26
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: LIST
6150: PPUSH
6151: CALL 62131 0 2
// end ; repeat wait ( 0 0$1 ) ;
6155: LD_INT 35
6157: PPUSH
6158: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6162: LD_INT 3
6164: PPUSH
6165: LD_INT 1
6167: PPUSH
6168: CALL 63549 0 2
6172: PUSH
6173: LD_INT 6
6175: GREATEREQUAL
6176: IFFALSE 6155
// wait ( 0 0$30 ) ;
6178: LD_INT 1050
6180: PPUSH
6181: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6185: LD_ADDR_VAR 0 2
6189: PUSH
6190: LD_INT 3
6192: PPUSH
6193: LD_INT 1
6195: PPUSH
6196: CALL 63549 0 2
6200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6201: LD_ADDR_EXP 119
6205: PUSH
6206: LD_EXP 119
6210: PPUSH
6211: LD_INT 3
6213: PPUSH
6214: LD_EXP 119
6218: PUSH
6219: LD_INT 3
6221: ARRAY
6222: PUSH
6223: LD_VAR 0 2
6227: DIFF
6228: PPUSH
6229: CALL_OW 1
6233: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6234: LD_ADDR_VAR 0 3
6238: PUSH
6239: LD_INT 0
6241: PPUSH
6242: LD_INT 2
6244: PPUSH
6245: CALL_OW 12
6249: ST_TO_ADDR
// if target then
6250: LD_VAR 0 3
6254: IFFALSE 6391
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6256: LD_ADDR_VAR 0 2
6260: PUSH
6261: LD_VAR 0 2
6265: PPUSH
6266: LD_INT 24
6268: PUSH
6269: LD_INT 250
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: PPUSH
6276: CALL_OW 72
6280: ST_TO_ADDR
// if not tmp then
6281: LD_VAR 0 2
6285: NOT
6286: IFFALSE 6290
// break ;
6288: GO 6389
// for i in tmp do
6290: LD_ADDR_VAR 0 1
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: FOR_IN
6301: IFFALSE 6341
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6303: LD_VAR 0 1
6307: PPUSH
6308: LD_INT 89
6310: PPUSH
6311: LD_INT 71
6313: PPUSH
6314: CALL_OW 297
6318: PUSH
6319: LD_INT 9
6321: GREATER
6322: IFFALSE 6339
// ComMoveXY ( i , 89 , 71 ) ;
6324: LD_VAR 0 1
6328: PPUSH
6329: LD_INT 89
6331: PPUSH
6332: LD_INT 71
6334: PPUSH
6335: CALL_OW 111
6339: GO 6300
6341: POP
6342: POP
// wait ( 0 0$1 ) ;
6343: LD_INT 35
6345: PPUSH
6346: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6350: LD_VAR 0 2
6354: PPUSH
6355: LD_INT 92
6357: PUSH
6358: LD_INT 89
6360: PUSH
6361: LD_INT 71
6363: PUSH
6364: LD_INT 9
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PPUSH
6373: CALL_OW 72
6377: PUSH
6378: LD_VAR 0 2
6382: PUSH
6383: LD_INT 1
6385: MINUS
6386: GREATEREQUAL
6387: IFFALSE 6256
// end else
6389: GO 6524
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6391: LD_ADDR_VAR 0 2
6395: PUSH
6396: LD_VAR 0 2
6400: PPUSH
6401: LD_INT 24
6403: PUSH
6404: LD_INT 250
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: PPUSH
6411: CALL_OW 72
6415: ST_TO_ADDR
// if not tmp then
6416: LD_VAR 0 2
6420: NOT
6421: IFFALSE 6425
// break ;
6423: GO 6524
// for i in tmp do
6425: LD_ADDR_VAR 0 1
6429: PUSH
6430: LD_VAR 0 2
6434: PUSH
6435: FOR_IN
6436: IFFALSE 6476
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6438: LD_VAR 0 1
6442: PPUSH
6443: LD_INT 125
6445: PPUSH
6446: LD_INT 129
6448: PPUSH
6449: CALL_OW 297
6453: PUSH
6454: LD_INT 9
6456: GREATER
6457: IFFALSE 6474
// ComMoveXY ( i , 125 , 129 ) ;
6459: LD_VAR 0 1
6463: PPUSH
6464: LD_INT 125
6466: PPUSH
6467: LD_INT 129
6469: PPUSH
6470: CALL_OW 111
6474: GO 6435
6476: POP
6477: POP
// wait ( 0 0$1 ) ;
6478: LD_INT 35
6480: PPUSH
6481: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6485: LD_VAR 0 2
6489: PPUSH
6490: LD_INT 92
6492: PUSH
6493: LD_INT 125
6495: PUSH
6496: LD_INT 129
6498: PUSH
6499: LD_INT 9
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PPUSH
6508: CALL_OW 72
6512: PUSH
6513: LD_VAR 0 2
6517: PUSH
6518: LD_INT 1
6520: MINUS
6521: GREATEREQUAL
6522: IFFALSE 6391
// end ; repeat wait ( 0 0$1 ) ;
6524: LD_INT 35
6526: PPUSH
6527: CALL_OW 67
// for i in tmp do
6531: LD_ADDR_VAR 0 1
6535: PUSH
6536: LD_VAR 0 2
6540: PUSH
6541: FOR_IN
6542: IFFALSE 6624
// begin if GetLives ( i ) > 251 then
6544: LD_VAR 0 1
6548: PPUSH
6549: CALL_OW 256
6553: PUSH
6554: LD_INT 251
6556: GREATER
6557: IFFALSE 6595
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 81
6566: PUSH
6567: LD_INT 8
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: PPUSH
6574: CALL_OW 69
6578: PPUSH
6579: LD_VAR 0 1
6583: PPUSH
6584: CALL_OW 74
6588: PPUSH
6589: CALL_OW 115
6593: GO 6622
// if IsDead ( i ) then
6595: LD_VAR 0 1
6599: PPUSH
6600: CALL_OW 301
6604: IFFALSE 6622
// tmp := tmp diff i ;
6606: LD_ADDR_VAR 0 2
6610: PUSH
6611: LD_VAR 0 2
6615: PUSH
6616: LD_VAR 0 1
6620: DIFF
6621: ST_TO_ADDR
// end ;
6622: GO 6541
6624: POP
6625: POP
// until not tmp ;
6626: LD_VAR 0 2
6630: NOT
6631: IFFALSE 6524
// end ;
6633: PPOPN 3
6635: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6636: LD_EXP 22
6640: NOT
6641: PUSH
6642: LD_EXP 15
6646: PUSH
6647: LD_INT 6
6649: GREATEREQUAL
6650: AND
6651: PUSH
6652: LD_OWVAR 67
6656: PUSH
6657: LD_INT 1
6659: GREATER
6660: AND
6661: IFFALSE 7194
6663: GO 6665
6665: DISABLE
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
// begin enable ;
6671: ENABLE
// tmp := [ ] ;
6672: LD_ADDR_VAR 0 3
6676: PUSH
6677: EMPTY
6678: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6679: LD_ADDR_VAR 0 1
6683: PUSH
6684: DOUBLE
6685: LD_INT 1
6687: DEC
6688: ST_TO_ADDR
6689: LD_INT 4
6691: PUSH
6692: LD_INT 6
6694: PUSH
6695: LD_INT 7
6697: PUSH
6698: LD_INT 8
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: LD_OWVAR 67
6711: ARRAY
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6874
// begin uc_side := 8 ;
6716: LD_ADDR_OWVAR 20
6720: PUSH
6721: LD_INT 8
6723: ST_TO_ADDR
// uc_nation := 2 ;
6724: LD_ADDR_OWVAR 21
6728: PUSH
6729: LD_INT 2
6731: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6732: LD_INT 13
6734: PUSH
6735: LD_INT 14
6737: PUSH
6738: EMPTY
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 1
6744: PPUSH
6745: LD_INT 2
6747: PPUSH
6748: CALL_OW 12
6752: ARRAY
6753: PPUSH
6754: LD_INT 1
6756: PPUSH
6757: LD_INT 5
6759: PPUSH
6760: LD_INT 27
6762: PUSH
6763: LD_INT 28
6765: PUSH
6766: LD_INT 26
6768: PUSH
6769: LD_INT 25
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 1
6780: PPUSH
6781: LD_INT 4
6783: PPUSH
6784: CALL_OW 12
6788: ARRAY
6789: PPUSH
6790: LD_INT 88
6792: PPUSH
6793: CALL 73397 0 5
// un := CreateVehicle ;
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: CALL_OW 45
6806: ST_TO_ADDR
// tmp := tmp ^ un ;
6807: LD_ADDR_VAR 0 3
6811: PUSH
6812: LD_VAR 0 3
6816: PUSH
6817: LD_VAR 0 2
6821: ADD
6822: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6823: LD_VAR 0 2
6827: PPUSH
6828: LD_INT 3
6830: PPUSH
6831: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6835: LD_VAR 0 2
6839: PPUSH
6840: LD_INT 30
6842: PPUSH
6843: LD_INT 0
6845: PPUSH
6846: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6850: LD_VAR 0 2
6854: PPUSH
6855: LD_INT 16
6857: PPUSH
6858: LD_INT 11
6860: PPUSH
6861: CALL_OW 111
// wait ( 0 0$2 ) ;
6865: LD_INT 70
6867: PPUSH
6868: CALL_OW 67
// end ;
6872: GO 6713
6874: POP
6875: POP
// for i = 1 to Difficulty do
6876: LD_ADDR_VAR 0 1
6880: PUSH
6881: DOUBLE
6882: LD_INT 1
6884: DEC
6885: ST_TO_ADDR
6886: LD_OWVAR 67
6890: PUSH
6891: FOR_TO
6892: IFFALSE 7021
// begin uc_side := 8 ;
6894: LD_ADDR_OWVAR 20
6898: PUSH
6899: LD_INT 8
6901: ST_TO_ADDR
// uc_nation := 2 ;
6902: LD_ADDR_OWVAR 21
6906: PUSH
6907: LD_INT 2
6909: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6910: LD_INT 0
6912: PPUSH
6913: LD_INT 8
6915: PPUSH
6916: LD_INT 8
6918: PUSH
6919: LD_INT 8
6921: PUSH
6922: LD_INT 9
6924: PUSH
6925: LD_INT 10
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_OWVAR 67
6938: ARRAY
6939: PPUSH
6940: CALL_OW 380
// un := CreateHuman ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: CALL_OW 44
6953: ST_TO_ADDR
// tmp := tmp ^ un ;
6954: LD_ADDR_VAR 0 3
6958: PUSH
6959: LD_VAR 0 3
6963: PUSH
6964: LD_VAR 0 2
6968: ADD
6969: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6970: LD_VAR 0 2
6974: PPUSH
6975: LD_INT 3
6977: PPUSH
6978: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6982: LD_VAR 0 2
6986: PPUSH
6987: LD_INT 30
6989: PPUSH
6990: LD_INT 0
6992: PPUSH
6993: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6997: LD_VAR 0 2
7001: PPUSH
7002: LD_INT 16
7004: PPUSH
7005: LD_INT 11
7007: PPUSH
7008: CALL_OW 111
// wait ( 0 0$2 ) ;
7012: LD_INT 70
7014: PPUSH
7015: CALL_OW 67
// end ;
7019: GO 6891
7021: POP
7022: POP
// repeat wait ( 0 0$1 ) ;
7023: LD_INT 35
7025: PPUSH
7026: CALL_OW 67
// if legionDestroyed then
7030: LD_EXP 22
7034: IFFALSE 7038
// exit ;
7036: GO 7194
// for i in tmp do
7038: LD_ADDR_VAR 0 1
7042: PUSH
7043: LD_VAR 0 3
7047: PUSH
7048: FOR_IN
7049: IFFALSE 7185
// begin if GetLives ( i ) > 250 then
7051: LD_VAR 0 1
7055: PPUSH
7056: CALL_OW 256
7060: PUSH
7061: LD_INT 250
7063: GREATER
7064: IFFALSE 7156
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7066: LD_INT 81
7068: PUSH
7069: LD_INT 8
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: PUSH
7076: LD_INT 91
7078: PUSH
7079: LD_VAR 0 1
7083: PUSH
7084: LD_INT 10
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL_OW 69
7100: NOT
7101: IFFALSE 7120
// ComAgressiveMove ( i , 67 , 110 ) else
7103: LD_VAR 0 1
7107: PPUSH
7108: LD_INT 67
7110: PPUSH
7111: LD_INT 110
7113: PPUSH
7114: CALL_OW 114
7118: GO 7154
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7120: LD_VAR 0 1
7124: PPUSH
7125: LD_INT 81
7127: PUSH
7128: LD_INT 8
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PPUSH
7135: CALL_OW 69
7139: PPUSH
7140: LD_VAR 0 1
7144: PPUSH
7145: CALL_OW 74
7149: PPUSH
7150: CALL_OW 115
// end else
7154: GO 7183
// if IsDead ( i ) then
7156: LD_VAR 0 1
7160: PPUSH
7161: CALL_OW 301
7165: IFFALSE 7183
// tmp := tmp diff i ;
7167: LD_ADDR_VAR 0 3
7171: PUSH
7172: LD_VAR 0 3
7176: PUSH
7177: LD_VAR 0 1
7181: DIFF
7182: ST_TO_ADDR
// end ;
7183: GO 7048
7185: POP
7186: POP
// until not tmp ;
7187: LD_VAR 0 3
7191: NOT
7192: IFFALSE 7023
// end ; end_of_file
7194: PPOPN 3
7196: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7197: LD_INT 0
7199: PPUSH
7200: PPUSH
7201: PPUSH
7202: PPUSH
7203: PPUSH
7204: PPUSH
7205: PPUSH
7206: PPUSH
7207: PPUSH
7208: PPUSH
// side := 3 ;
7209: LD_ADDR_VAR 0 6
7213: PUSH
7214: LD_INT 3
7216: ST_TO_ADDR
// uc_side := side ;
7217: LD_ADDR_OWVAR 20
7221: PUSH
7222: LD_VAR 0 6
7226: ST_TO_ADDR
// uc_nation := 3 ;
7227: LD_ADDR_OWVAR 21
7231: PUSH
7232: LD_INT 3
7234: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7235: LD_ADDR_VAR 0 2
7239: PUSH
7240: LD_INT 22
7242: PUSH
7243: LD_VAR 0 6
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 21
7254: PUSH
7255: LD_INT 3
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: PPUSH
7266: CALL_OW 69
7270: PUSH
7271: FOR_IN
7272: IFFALSE 7288
// SetBLevel ( i , 10 ) ;
7274: LD_VAR 0 2
7278: PPUSH
7279: LD_INT 10
7281: PPUSH
7282: CALL_OW 241
7286: GO 7271
7288: POP
7289: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7290: LD_ADDR_VAR 0 10
7294: PUSH
7295: LD_INT 22
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 30
7309: PUSH
7310: LD_INT 34
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PPUSH
7321: CALL_OW 69
7325: ST_TO_ADDR
// if teleport then
7326: LD_VAR 0 10
7330: IFFALSE 7351
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7332: LD_VAR 0 10
7336: PUSH
7337: LD_INT 1
7339: ARRAY
7340: PPUSH
7341: LD_INT 123
7343: PPUSH
7344: LD_INT 122
7346: PPUSH
7347: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7351: LD_ADDR_EXP 66
7355: PUSH
7356: LD_STRING Platonov
7358: PPUSH
7359: CALL_OW 25
7363: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7364: LD_ADDR_EXP 67
7368: PUSH
7369: LD_STRING Kovalyuk
7371: PPUSH
7372: CALL_OW 25
7376: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7377: LD_ADDR_EXP 69
7381: PUSH
7382: LD_STRING Yakotich
7384: PPUSH
7385: LD_EXP 1
7389: NOT
7390: PPUSH
7391: LD_STRING 09_
7393: PPUSH
7394: CALL 68557 0 3
7398: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7399: LD_ADDR_EXP 68
7403: PUSH
7404: LD_STRING Bystrov
7406: PPUSH
7407: CALL_OW 25
7411: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7412: LD_ADDR_EXP 70
7416: PUSH
7417: LD_STRING Gleb
7419: PPUSH
7420: CALL_OW 25
7424: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7425: LD_STRING 03_Cornel
7427: PPUSH
7428: CALL_OW 28
7432: IFFALSE 7480
// begin Bierezov := NewCharacter ( Mikhail ) ;
7434: LD_ADDR_EXP 71
7438: PUSH
7439: LD_STRING Mikhail
7441: PPUSH
7442: CALL_OW 25
7446: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7447: LD_EXP 71
7451: PPUSH
7452: LD_INT 197
7454: PPUSH
7455: LD_INT 111
7457: PPUSH
7458: LD_INT 9
7460: PPUSH
7461: LD_INT 0
7463: PPUSH
7464: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7468: LD_EXP 71
7472: PPUSH
7473: LD_INT 3
7475: PPUSH
7476: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7480: LD_EXP 66
7484: PPUSH
7485: LD_INT 126
7487: PPUSH
7488: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7492: LD_EXP 67
7496: PPUSH
7497: LD_INT 134
7499: PPUSH
7500: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7504: LD_EXP 69
7508: PPUSH
7509: LD_INT 197
7511: PPUSH
7512: LD_INT 111
7514: PPUSH
7515: LD_INT 9
7517: PPUSH
7518: LD_INT 0
7520: PPUSH
7521: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7525: LD_EXP 68
7529: PPUSH
7530: LD_INT 197
7532: PPUSH
7533: LD_INT 111
7535: PPUSH
7536: LD_INT 9
7538: PPUSH
7539: LD_INT 0
7541: PPUSH
7542: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7546: LD_EXP 70
7550: PPUSH
7551: LD_INT 197
7553: PPUSH
7554: LD_INT 111
7556: PPUSH
7557: LD_INT 9
7559: PPUSH
7560: LD_INT 0
7562: PPUSH
7563: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7567: LD_ADDR_VAR 0 5
7571: PUSH
7572: LD_INT 126
7574: PPUSH
7575: LD_INT 4
7577: PPUSH
7578: LD_STRING zhukov
7580: PPUSH
7581: LD_INT 9
7583: PUSH
7584: LD_INT 10
7586: PUSH
7587: LD_INT 10
7589: PUSH
7590: LD_INT 10
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: LD_OWVAR 67
7603: ARRAY
7604: PPUSH
7605: LD_INT 90000
7607: PUSH
7608: LD_INT 1000
7610: PUSH
7611: LD_INT 300
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: PPUSH
7619: LD_INT 18
7621: PUSH
7622: LD_INT 8
7624: PUSH
7625: LD_INT 13
7627: PUSH
7628: LD_INT 8
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL 76841 0 6
7641: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7642: LD_ADDR_EXP 100
7646: PUSH
7647: LD_EXP 100
7651: PPUSH
7652: LD_INT 2
7654: PPUSH
7655: LD_VAR 0 5
7659: PUSH
7660: LD_EXP 69
7664: PUSH
7665: LD_EXP 68
7669: PUSH
7670: LD_EXP 70
7674: PUSH
7675: LD_EXP 71
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: UNION
7686: PPUSH
7687: CALL_OW 1
7691: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7692: LD_ADDR_VAR 0 4
7696: PUSH
7697: LD_INT 267
7699: PPUSH
7700: CALL_OW 274
7704: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7705: LD_VAR 0 4
7709: PPUSH
7710: LD_INT 1
7712: PPUSH
7713: LD_INT 5000
7715: PPUSH
7716: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7720: LD_VAR 0 4
7724: PPUSH
7725: LD_INT 2
7727: PPUSH
7728: LD_INT 200
7730: PPUSH
7731: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7735: LD_VAR 0 4
7739: PPUSH
7740: LD_INT 3
7742: PPUSH
7743: LD_INT 200
7745: PPUSH
7746: CALL_OW 277
// for i := 1 to 6 do
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: DOUBLE
7756: LD_INT 1
7758: DEC
7759: ST_TO_ADDR
7760: LD_INT 6
7762: PUSH
7763: FOR_TO
7764: IFFALSE 7847
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7766: LD_INT 0
7768: PPUSH
7769: LD_INT 8
7771: PUSH
7772: LD_INT 9
7774: PUSH
7775: LD_INT 10
7777: PUSH
7778: LD_INT 10
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: LIST
7785: LIST
7786: PUSH
7787: LD_OWVAR 67
7791: ARRAY
7792: PPUSH
7793: CALL_OW 381
// un := CreateHuman ;
7797: LD_ADDR_VAR 0 8
7801: PUSH
7802: CALL_OW 44
7806: ST_TO_ADDR
// if i mod 2 = 0 then
7807: LD_VAR 0 2
7811: PUSH
7812: LD_INT 2
7814: MOD
7815: PUSH
7816: LD_INT 0
7818: EQUAL
7819: IFFALSE 7833
// SetClass ( un , class_bazooker ) ;
7821: LD_VAR 0 8
7825: PPUSH
7826: LD_INT 9
7828: PPUSH
7829: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
7833: LD_VAR 0 8
7837: PPUSH
7838: LD_INT 460
7840: PPUSH
7841: CALL_OW 52
// end ;
7845: GO 7763
7847: POP
7848: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
7849: LD_INT 21
7851: PPUSH
7852: LD_INT 3
7854: PPUSH
7855: LD_INT 3
7857: PPUSH
7858: LD_INT 52
7860: PPUSH
7861: LD_INT 100
7863: PPUSH
7864: CALL 73397 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
7868: CALL_OW 45
7872: PPUSH
7873: LD_INT 259
7875: PPUSH
7876: LD_INT 145
7878: PPUSH
7879: LD_INT 3
7881: PPUSH
7882: LD_INT 0
7884: PPUSH
7885: CALL 107989 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
7889: CALL_OW 45
7893: PPUSH
7894: LD_INT 245
7896: PPUSH
7897: LD_INT 139
7899: PPUSH
7900: LD_INT 3
7902: PPUSH
7903: LD_INT 0
7905: PPUSH
7906: CALL 107989 0 5
// behemoths := [ ] ;
7910: LD_ADDR_EXP 74
7914: PUSH
7915: EMPTY
7916: ST_TO_ADDR
// behemothBuilders := [ ] ;
7917: LD_ADDR_EXP 75
7921: PUSH
7922: EMPTY
7923: ST_TO_ADDR
// if Kovalyuk then
7924: LD_EXP 67
7928: IFFALSE 7950
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7930: LD_ADDR_EXP 75
7934: PUSH
7935: LD_EXP 75
7939: PPUSH
7940: LD_EXP 67
7944: PPUSH
7945: CALL 105849 0 2
7949: ST_TO_ADDR
// j := 3 ;
7950: LD_ADDR_VAR 0 3
7954: PUSH
7955: LD_INT 3
7957: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7958: LD_ADDR_VAR 0 2
7962: PUSH
7963: LD_INT 22
7965: PUSH
7966: LD_INT 3
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 25
7975: PUSH
7976: LD_INT 3
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PPUSH
7987: CALL_OW 69
7991: PUSH
7992: LD_EXP 67
7996: DIFF
7997: PUSH
7998: FOR_IN
7999: IFFALSE 8049
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8001: LD_ADDR_EXP 75
8005: PUSH
8006: LD_EXP 75
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL 105849 0 2
8020: ST_TO_ADDR
// j := j - 1 ;
8021: LD_ADDR_VAR 0 3
8025: PUSH
8026: LD_VAR 0 3
8030: PUSH
8031: LD_INT 1
8033: MINUS
8034: ST_TO_ADDR
// if j = 0 then
8035: LD_VAR 0 3
8039: PUSH
8040: LD_INT 0
8042: EQUAL
8043: IFFALSE 8047
// break ;
8045: GO 8049
// end ;
8047: GO 7998
8049: POP
8050: POP
// end ;
8051: LD_VAR 0 1
8055: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8056: LD_INT 0
8058: PPUSH
8059: PPUSH
8060: PPUSH
8061: PPUSH
8062: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8063: LD_ADDR_VAR 0 4
8067: PUSH
8068: LD_INT 209
8070: PUSH
8071: LD_INT 149
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: PUSH
8078: LD_INT 219
8080: PUSH
8081: LD_INT 154
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PUSH
8088: LD_INT 223
8090: PUSH
8091: LD_INT 149
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 232
8100: PUSH
8101: LD_INT 155
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: LIST
8113: ST_TO_ADDR
// if not behemothBuilders then
8114: LD_EXP 75
8118: NOT
8119: IFFALSE 8123
// exit ;
8121: GO 8254
// j := 1 ;
8123: LD_ADDR_VAR 0 3
8127: PUSH
8128: LD_INT 1
8130: ST_TO_ADDR
// for i in behemothBuilders do
8131: LD_ADDR_VAR 0 2
8135: PUSH
8136: LD_EXP 75
8140: PUSH
8141: FOR_IN
8142: IFFALSE 8252
// begin if GetClass ( i ) <> class_mechanic then
8144: LD_VAR 0 2
8148: PPUSH
8149: CALL_OW 257
8153: PUSH
8154: LD_INT 3
8156: NONEQUAL
8157: IFFALSE 8171
// SetClass ( i , class_mechanic ) ;
8159: LD_VAR 0 2
8163: PPUSH
8164: LD_INT 3
8166: PPUSH
8167: CALL_OW 336
// if IsInUnit ( i ) then
8171: LD_VAR 0 2
8175: PPUSH
8176: CALL_OW 310
8180: IFFALSE 8191
// ComExitBuilding ( i ) ;
8182: LD_VAR 0 2
8186: PPUSH
8187: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8191: LD_VAR 0 2
8195: PPUSH
8196: LD_INT 37
8198: PPUSH
8199: LD_VAR 0 4
8203: PUSH
8204: LD_VAR 0 3
8208: ARRAY
8209: PUSH
8210: LD_INT 1
8212: ARRAY
8213: PPUSH
8214: LD_VAR 0 4
8218: PUSH
8219: LD_VAR 0 3
8223: ARRAY
8224: PUSH
8225: LD_INT 2
8227: ARRAY
8228: PPUSH
8229: LD_INT 0
8231: PPUSH
8232: CALL_OW 230
// j := j + 1 ;
8236: LD_ADDR_VAR 0 3
8240: PUSH
8241: LD_VAR 0 3
8245: PUSH
8246: LD_INT 1
8248: PLUS
8249: ST_TO_ADDR
// end ;
8250: GO 8141
8252: POP
8253: POP
// end ;
8254: LD_VAR 0 1
8258: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8259: LD_INT 24
8261: PPUSH
8262: LD_INT 30
8264: PUSH
8265: LD_INT 37
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PPUSH
8272: CALL_OW 70
8276: IFFALSE 8289
8278: GO 8280
8280: DISABLE
// behemothUnderConstruct := true ;
8281: LD_ADDR_EXP 26
8285: PUSH
8286: LD_INT 1
8288: ST_TO_ADDR
8289: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8290: LD_INT 3
8292: PPUSH
8293: CALL 105910 0 1
8297: PUSH
8298: LD_INT 22
8300: PUSH
8301: LD_INT 3
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: LD_INT 30
8310: PUSH
8311: LD_INT 37
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: NOT
8327: AND
8328: IFFALSE 8514
8330: GO 8332
8332: DISABLE
8333: LD_INT 0
8335: PPUSH
8336: PPUSH
// begin enable ;
8337: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8338: LD_ADDR_VAR 0 2
8342: PUSH
8343: LD_INT 3
8345: PPUSH
8346: CALL 105910 0 1
8350: ST_TO_ADDR
// for i in tmp do
8351: LD_ADDR_VAR 0 1
8355: PUSH
8356: LD_VAR 0 2
8360: PUSH
8361: FOR_IN
8362: IFFALSE 8512
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8364: LD_VAR 0 1
8368: PPUSH
8369: LD_INT 9
8371: PPUSH
8372: CALL_OW 308
8376: PUSH
8377: LD_VAR 0 1
8381: PPUSH
8382: CALL_OW 110
8386: PUSH
8387: LD_INT 2
8389: EQUAL
8390: NOT
8391: AND
8392: IFFALSE 8406
// SetTag ( i , 2 ) ;
8394: LD_VAR 0 1
8398: PPUSH
8399: LD_INT 2
8401: PPUSH
8402: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8406: LD_INT 81
8408: PUSH
8409: LD_INT 3
8411: PUSH
8412: EMPTY
8413: LIST
8414: LIST
8415: PUSH
8416: LD_INT 91
8418: PUSH
8419: LD_VAR 0 1
8423: PUSH
8424: LD_INT 12
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: NOT
8441: PUSH
8442: LD_VAR 0 1
8446: PPUSH
8447: CALL_OW 110
8451: PUSH
8452: LD_INT 2
8454: EQUAL
8455: NOT
8456: AND
8457: IFFALSE 8476
// ComAgressiveMove ( i , 64 , 93 ) else
8459: LD_VAR 0 1
8463: PPUSH
8464: LD_INT 64
8466: PPUSH
8467: LD_INT 93
8469: PPUSH
8470: CALL_OW 114
8474: GO 8510
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8476: LD_VAR 0 1
8480: PPUSH
8481: LD_INT 81
8483: PUSH
8484: LD_INT 3
8486: PUSH
8487: EMPTY
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 69
8495: PPUSH
8496: LD_VAR 0 1
8500: PPUSH
8501: CALL_OW 74
8505: PPUSH
8506: CALL_OW 115
// end ;
8510: GO 8361
8512: POP
8513: POP
// end ;
8514: PPOPN 2
8516: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8517: LD_INT 0
8519: PPUSH
8520: PPUSH
8521: PPUSH
// result := [ ] ;
8522: LD_ADDR_VAR 0 2
8526: PUSH
8527: EMPTY
8528: ST_TO_ADDR
// uc_side := 6 ;
8529: LD_ADDR_OWVAR 20
8533: PUSH
8534: LD_INT 6
8536: ST_TO_ADDR
// uc_nation := 3 ;
8537: LD_ADDR_OWVAR 21
8541: PUSH
8542: LD_INT 3
8544: ST_TO_ADDR
// case strength of 1 :
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 1
8552: DOUBLE
8553: EQUAL
8554: IFTRUE 8558
8556: GO 8700
8558: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8559: LD_ADDR_VAR 0 3
8563: PUSH
8564: DOUBLE
8565: LD_INT 1
8567: DEC
8568: ST_TO_ADDR
8569: LD_INT 4
8571: PUSH
8572: LD_INT 5
8574: PUSH
8575: LD_INT 6
8577: PUSH
8578: LD_INT 7
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: PUSH
8587: LD_OWVAR 67
8591: ARRAY
8592: PUSH
8593: FOR_TO
8594: IFFALSE 8696
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8596: LD_INT 22
8598: PUSH
8599: LD_INT 24
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_VAR 0 3
8610: PUSH
8611: LD_INT 2
8613: MOD
8614: PUSH
8615: LD_INT 1
8617: PLUS
8618: ARRAY
8619: PPUSH
8620: LD_INT 1
8622: PUSH
8623: LD_INT 3
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 1
8632: PPUSH
8633: LD_INT 2
8635: PPUSH
8636: CALL_OW 12
8640: ARRAY
8641: PPUSH
8642: LD_INT 3
8644: PPUSH
8645: LD_INT 43
8647: PUSH
8648: LD_INT 44
8650: PUSH
8651: LD_INT 45
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: LIST
8658: PUSH
8659: LD_INT 1
8661: PPUSH
8662: LD_INT 3
8664: PPUSH
8665: CALL_OW 12
8669: ARRAY
8670: PPUSH
8671: LD_INT 80
8673: PPUSH
8674: CALL 73397 0 5
// result := result union CreateVehicle ;
8678: LD_ADDR_VAR 0 2
8682: PUSH
8683: LD_VAR 0 2
8687: PUSH
8688: CALL_OW 45
8692: UNION
8693: ST_TO_ADDR
// end ;
8694: GO 8593
8696: POP
8697: POP
// end ; 2 :
8698: GO 9695
8700: LD_INT 2
8702: DOUBLE
8703: EQUAL
8704: IFTRUE 8708
8706: GO 8876
8708: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8709: LD_ADDR_VAR 0 3
8713: PUSH
8714: DOUBLE
8715: LD_INT 1
8717: DEC
8718: ST_TO_ADDR
8719: LD_INT 5
8721: PUSH
8722: LD_INT 6
8724: PUSH
8725: LD_INT 7
8727: PUSH
8728: LD_INT 8
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: PUSH
8737: LD_OWVAR 67
8741: ARRAY
8742: PUSH
8743: FOR_TO
8744: IFFALSE 8872
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8746: LD_INT 22
8748: PUSH
8749: LD_INT 24
8751: PUSH
8752: LD_INT 24
8754: PUSH
8755: EMPTY
8756: LIST
8757: LIST
8758: LIST
8759: PUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 3
8767: MOD
8768: PUSH
8769: LD_INT 1
8771: PLUS
8772: ARRAY
8773: PPUSH
8774: LD_INT 1
8776: PUSH
8777: LD_INT 3
8779: PUSH
8780: EMPTY
8781: LIST
8782: LIST
8783: PUSH
8784: LD_INT 1
8786: PPUSH
8787: LD_INT 2
8789: PPUSH
8790: CALL_OW 12
8794: ARRAY
8795: PPUSH
8796: LD_INT 3
8798: PPUSH
8799: LD_INT 43
8801: PUSH
8802: LD_INT 44
8804: PUSH
8805: LD_INT 45
8807: PUSH
8808: LD_INT 44
8810: PUSH
8811: LD_INT 46
8813: PUSH
8814: LD_INT 46
8816: PUSH
8817: LD_INT 49
8819: PUSH
8820: LD_INT 49
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: LIST
8832: PUSH
8833: LD_VAR 0 3
8837: PUSH
8838: LD_INT 8
8840: MOD
8841: PUSH
8842: LD_INT 1
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 80
8849: PPUSH
8850: CALL 73397 0 5
// result := result union CreateVehicle ;
8854: LD_ADDR_VAR 0 2
8858: PUSH
8859: LD_VAR 0 2
8863: PUSH
8864: CALL_OW 45
8868: UNION
8869: ST_TO_ADDR
// end ;
8870: GO 8743
8872: POP
8873: POP
// end ; 3 :
8874: GO 9695
8876: LD_INT 3
8878: DOUBLE
8879: EQUAL
8880: IFTRUE 8884
8882: GO 9056
8884: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: DOUBLE
8891: LD_INT 1
8893: DEC
8894: ST_TO_ADDR
8895: LD_INT 6
8897: PUSH
8898: LD_INT 7
8900: PUSH
8901: LD_INT 8
8903: PUSH
8904: LD_INT 9
8906: PUSH
8907: EMPTY
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: PUSH
8913: LD_OWVAR 67
8917: ARRAY
8918: PUSH
8919: FOR_TO
8920: IFFALSE 9052
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8922: LD_INT 22
8924: PUSH
8925: LD_INT 24
8927: PUSH
8928: LD_INT 24
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: LD_VAR 0 3
8940: PUSH
8941: LD_INT 3
8943: MOD
8944: PUSH
8945: LD_INT 1
8947: PLUS
8948: ARRAY
8949: PPUSH
8950: LD_INT 1
8952: PUSH
8953: LD_INT 3
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_INT 2
8965: PPUSH
8966: CALL_OW 12
8970: ARRAY
8971: PPUSH
8972: LD_INT 3
8974: PPUSH
8975: LD_INT 43
8977: PUSH
8978: LD_INT 47
8980: PUSH
8981: LD_INT 45
8983: PUSH
8984: LD_INT 45
8986: PUSH
8987: LD_INT 46
8989: PUSH
8990: LD_INT 46
8992: PUSH
8993: LD_INT 49
8995: PUSH
8996: LD_INT 49
8998: PUSH
8999: LD_INT 49
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: LIST
9006: LIST
9007: LIST
9008: LIST
9009: LIST
9010: LIST
9011: LIST
9012: PUSH
9013: LD_VAR 0 3
9017: PUSH
9018: LD_INT 9
9020: MOD
9021: PUSH
9022: LD_INT 1
9024: PLUS
9025: ARRAY
9026: PPUSH
9027: LD_INT 80
9029: PPUSH
9030: CALL 73397 0 5
// result := result union CreateVehicle ;
9034: LD_ADDR_VAR 0 2
9038: PUSH
9039: LD_VAR 0 2
9043: PUSH
9044: CALL_OW 45
9048: UNION
9049: ST_TO_ADDR
// end ;
9050: GO 8919
9052: POP
9053: POP
// end ; 4 :
9054: GO 9695
9056: LD_INT 4
9058: DOUBLE
9059: EQUAL
9060: IFTRUE 9064
9062: GO 9694
9064: POP
// begin uc_nation := 3 ;
9065: LD_ADDR_OWVAR 21
9069: PUSH
9070: LD_INT 3
9072: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9073: LD_ADDR_VAR 0 3
9077: PUSH
9078: DOUBLE
9079: LD_INT 1
9081: DEC
9082: ST_TO_ADDR
9083: LD_INT 6
9085: PUSH
9086: LD_INT 8
9088: PUSH
9089: LD_INT 9
9091: PUSH
9092: LD_INT 10
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: PUSH
9107: FOR_TO
9108: IFFALSE 9240
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9110: LD_INT 22
9112: PUSH
9113: LD_INT 24
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: LIST
9123: PUSH
9124: LD_VAR 0 3
9128: PUSH
9129: LD_INT 3
9131: MOD
9132: PUSH
9133: LD_INT 1
9135: PLUS
9136: ARRAY
9137: PPUSH
9138: LD_INT 1
9140: PUSH
9141: LD_INT 3
9143: PUSH
9144: EMPTY
9145: LIST
9146: LIST
9147: PUSH
9148: LD_INT 1
9150: PPUSH
9151: LD_INT 2
9153: PPUSH
9154: CALL_OW 12
9158: ARRAY
9159: PPUSH
9160: LD_INT 3
9162: PPUSH
9163: LD_INT 45
9165: PUSH
9166: LD_INT 47
9168: PUSH
9169: LD_INT 47
9171: PUSH
9172: LD_INT 45
9174: PUSH
9175: LD_INT 46
9177: PUSH
9178: LD_INT 46
9180: PUSH
9181: LD_INT 49
9183: PUSH
9184: LD_INT 49
9186: PUSH
9187: LD_INT 49
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: LIST
9195: LIST
9196: LIST
9197: LIST
9198: LIST
9199: LIST
9200: PUSH
9201: LD_VAR 0 3
9205: PUSH
9206: LD_INT 9
9208: MOD
9209: PUSH
9210: LD_INT 1
9212: PLUS
9213: ARRAY
9214: PPUSH
9215: LD_INT 80
9217: PPUSH
9218: CALL 73397 0 5
// result := result union CreateVehicle ;
9222: LD_ADDR_VAR 0 2
9226: PUSH
9227: LD_VAR 0 2
9231: PUSH
9232: CALL_OW 45
9236: UNION
9237: ST_TO_ADDR
// end ;
9238: GO 9107
9240: POP
9241: POP
// if not KappaStatus then
9242: LD_EXP 2
9246: NOT
9247: IFFALSE 9482
// begin uc_nation := 1 ;
9249: LD_ADDR_OWVAR 21
9253: PUSH
9254: LD_INT 1
9256: ST_TO_ADDR
// for i = 1 to 3 do
9257: LD_ADDR_VAR 0 3
9261: PUSH
9262: DOUBLE
9263: LD_INT 1
9265: DEC
9266: ST_TO_ADDR
9267: LD_INT 3
9269: PUSH
9270: FOR_TO
9271: IFFALSE 9407
// begin j := rand ( 0 , 1 ) ;
9273: LD_ADDR_VAR 0 4
9277: PUSH
9278: LD_INT 0
9280: PPUSH
9281: LD_INT 1
9283: PPUSH
9284: CALL_OW 12
9288: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9289: LD_INT 3
9291: PUSH
9292: LD_INT 5
9294: PUSH
9295: LD_INT 5
9297: PUSH
9298: LD_INT 4
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: PUSH
9307: LD_VAR 0 4
9311: PUSH
9312: LD_INT 1
9314: PPUSH
9315: LD_INT 3
9317: PPUSH
9318: CALL_OW 12
9322: PLUS
9323: ARRAY
9324: PPUSH
9325: LD_INT 1
9327: PUSH
9328: LD_INT 3
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PUSH
9335: LD_INT 1
9337: PPUSH
9338: LD_INT 2
9340: PPUSH
9341: CALL_OW 12
9345: ARRAY
9346: PPUSH
9347: LD_INT 3
9349: PPUSH
9350: LD_INT 9
9352: PUSH
9353: LD_INT 7
9355: PUSH
9356: LD_INT 6
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 4
9368: PUSH
9369: LD_INT 1
9371: PPUSH
9372: LD_INT 2
9374: PPUSH
9375: CALL_OW 12
9379: PLUS
9380: ARRAY
9381: PPUSH
9382: LD_INT 85
9384: PPUSH
9385: CALL 73397 0 5
// result := result union CreateVehicle ;
9389: LD_ADDR_VAR 0 2
9393: PUSH
9394: LD_VAR 0 2
9398: PUSH
9399: CALL_OW 45
9403: UNION
9404: ST_TO_ADDR
// end ;
9405: GO 9270
9407: POP
9408: POP
// if vsevolodFirstAttack then
9409: LD_EXP 24
9413: IFFALSE 9480
// begin vsevolodFirstAttack := false ;
9415: LD_ADDR_EXP 24
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9423: LD_INT 5
9425: PPUSH
9426: LD_INT 3
9428: PPUSH
9429: LD_INT 1
9431: PPUSH
9432: LD_INT 6
9434: PPUSH
9435: LD_INT 100
9437: PPUSH
9438: CALL 73397 0 5
// sewiVeh := CreateVehicle ;
9442: LD_ADDR_EXP 73
9446: PUSH
9447: CALL_OW 45
9451: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9452: LD_EXP 73
9456: PPUSH
9457: LD_INT 1
9459: PPUSH
9460: CALL_OW 242
// result := result union sewiVeh ;
9464: LD_ADDR_VAR 0 2
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: LD_EXP 73
9478: UNION
9479: ST_TO_ADDR
// end ; end else
9480: GO 9692
// if vsevolodFirstAttack then
9482: LD_EXP 24
9486: IFFALSE 9692
// begin vsevolodFirstAttack := false ;
9488: LD_ADDR_EXP 24
9492: PUSH
9493: LD_INT 0
9495: ST_TO_ADDR
// uc_nation := 3 ;
9496: LD_ADDR_OWVAR 21
9500: PUSH
9501: LD_INT 3
9503: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9504: LD_ADDR_VAR 0 3
9508: PUSH
9509: DOUBLE
9510: LD_INT 1
9512: DEC
9513: ST_TO_ADDR
9514: LD_INT 2
9516: PUSH
9517: LD_OWVAR 67
9521: PLUS
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9632
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9526: LD_INT 22
9528: PUSH
9529: LD_INT 24
9531: PUSH
9532: LD_INT 24
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_VAR 0 3
9544: PUSH
9545: LD_INT 3
9547: MOD
9548: PUSH
9549: LD_INT 1
9551: PLUS
9552: ARRAY
9553: PPUSH
9554: LD_INT 1
9556: PUSH
9557: LD_INT 3
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 1
9566: PPUSH
9567: LD_INT 2
9569: PPUSH
9570: CALL_OW 12
9574: ARRAY
9575: PPUSH
9576: LD_INT 1
9578: PPUSH
9579: LD_INT 45
9581: PUSH
9582: LD_INT 47
9584: PUSH
9585: LD_INT 47
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: LIST
9592: PUSH
9593: LD_VAR 0 3
9597: PUSH
9598: LD_INT 3
9600: MOD
9601: PUSH
9602: LD_INT 1
9604: PLUS
9605: ARRAY
9606: PPUSH
9607: LD_INT 80
9609: PPUSH
9610: CALL 73397 0 5
// result := result union CreateVehicle ;
9614: LD_ADDR_VAR 0 2
9618: PUSH
9619: LD_VAR 0 2
9623: PUSH
9624: CALL_OW 45
9628: UNION
9629: ST_TO_ADDR
// end ;
9630: GO 9523
9632: POP
9633: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9634: LD_INT 24
9636: PPUSH
9637: LD_INT 3
9639: PPUSH
9640: LD_INT 1
9642: PPUSH
9643: LD_INT 47
9645: PPUSH
9646: LD_INT 100
9648: PPUSH
9649: CALL 73397 0 5
// sewiVeh := CreateVehicle ;
9653: LD_ADDR_EXP 73
9657: PUSH
9658: CALL_OW 45
9662: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9663: LD_EXP 73
9667: PPUSH
9668: LD_INT 6
9670: NEG
9671: PPUSH
9672: CALL_OW 242
// result := result union sewiVeh ;
9676: LD_ADDR_VAR 0 2
9680: PUSH
9681: LD_VAR 0 2
9685: PUSH
9686: LD_EXP 73
9690: UNION
9691: ST_TO_ADDR
// end ; end ; end ;
9692: GO 9695
9694: POP
// end ;
9695: LD_VAR 0 2
9699: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9700: LD_EXP 16
9704: IFFALSE 10424
9706: GO 9708
9708: DISABLE
9709: LD_INT 0
9711: PPUSH
9712: PPUSH
9713: PPUSH
9714: PPUSH
9715: PPUSH
9716: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9717: LD_ADDR_VAR 0 4
9721: PUSH
9722: LD_INT 11
9724: PUSH
9725: LD_INT 12
9727: PUSH
9728: EMPTY
9729: LIST
9730: LIST
9731: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9732: LD_ADDR_VAR 0 3
9736: PUSH
9737: LD_INT 11550
9739: PUSH
9740: LD_INT 10150
9742: PUSH
9743: LD_INT 9800
9745: PUSH
9746: LD_INT 9450
9748: PUSH
9749: EMPTY
9750: LIST
9751: LIST
9752: LIST
9753: LIST
9754: PUSH
9755: LD_OWVAR 67
9759: ARRAY
9760: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9761: LD_ADDR_VAR 0 6
9765: PUSH
9766: LD_INT 70
9768: PUSH
9769: LD_INT 118
9771: PUSH
9772: EMPTY
9773: LIST
9774: LIST
9775: PUSH
9776: LD_INT 78
9778: PUSH
9779: LD_INT 31
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PUSH
9786: EMPTY
9787: LIST
9788: LIST
9789: ST_TO_ADDR
// repeat if missionStage = 2 then
9790: LD_EXP 15
9794: PUSH
9795: LD_INT 2
9797: EQUAL
9798: IFFALSE 9809
// wait ( 1 1$30 ) else
9800: LD_INT 3150
9802: PPUSH
9803: CALL_OW 67
9807: GO 9818
// wait ( time ) ;
9809: LD_VAR 0 3
9813: PPUSH
9814: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9818: LD_EXP 15
9822: PUSH
9823: LD_INT 6
9825: EQUAL
9826: PUSH
9827: LD_OWVAR 67
9831: PUSH
9832: LD_INT 2
9834: GREATER
9835: OR
9836: IFFALSE 9864
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9838: LD_INT 51
9840: PPUSH
9841: LD_INT 6
9843: PPUSH
9844: LD_INT 2
9846: PPUSH
9847: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9851: LD_INT 57
9853: PPUSH
9854: LD_INT 6
9856: PPUSH
9857: LD_INT 2
9859: PPUSH
9860: CALL_OW 322
// end ; if missionStage = 8 then
9864: LD_EXP 15
9868: PUSH
9869: LD_INT 8
9871: EQUAL
9872: IFFALSE 9900
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9874: LD_INT 52
9876: PPUSH
9877: LD_INT 6
9879: PPUSH
9880: LD_INT 2
9882: PPUSH
9883: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9887: LD_INT 58
9889: PPUSH
9890: LD_INT 6
9892: PPUSH
9893: LD_INT 2
9895: PPUSH
9896: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
9900: LD_OWVAR 67
9904: PUSH
9905: LD_INT 4
9907: EQUAL
9908: PUSH
9909: LD_EXP 15
9913: PUSH
9914: LD_INT 10
9916: EQUAL
9917: OR
9918: IFFALSE 9946
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9920: LD_INT 53
9922: PPUSH
9923: LD_INT 6
9925: PPUSH
9926: LD_INT 2
9928: PPUSH
9929: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9933: LD_INT 59
9935: PPUSH
9936: LD_INT 6
9938: PPUSH
9939: LD_INT 2
9941: PPUSH
9942: CALL_OW 322
// end ; if activeAttacks then
9946: LD_EXP 16
9950: IFFALSE 10418
// begin if missionStage = 2 then
9952: LD_EXP 15
9956: PUSH
9957: LD_INT 2
9959: EQUAL
9960: IFFALSE 9970
// strength := 1 ;
9962: LD_ADDR_VAR 0 5
9966: PUSH
9967: LD_INT 1
9969: ST_TO_ADDR
// if missionStage > 2 then
9970: LD_EXP 15
9974: PUSH
9975: LD_INT 2
9977: GREATER
9978: IFFALSE 9988
// strength := 2 ;
9980: LD_ADDR_VAR 0 5
9984: PUSH
9985: LD_INT 2
9987: ST_TO_ADDR
// if missionStage > 6 then
9988: LD_EXP 15
9992: PUSH
9993: LD_INT 6
9995: GREATER
9996: IFFALSE 10006
// strength := 3 ;
9998: LD_ADDR_VAR 0 5
10002: PUSH
10003: LD_INT 3
10005: ST_TO_ADDR
// if missionStage > 10 then
10006: LD_EXP 15
10010: PUSH
10011: LD_INT 10
10013: GREATER
10014: IFFALSE 10024
// strength := 4 ;
10016: LD_ADDR_VAR 0 5
10020: PUSH
10021: LD_INT 4
10023: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10024: LD_ADDR_VAR 0 2
10028: PUSH
10029: LD_VAR 0 5
10033: PPUSH
10034: CALL 8517 0 1
10038: ST_TO_ADDR
// for i in tmp do
10039: LD_ADDR_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: FOR_IN
10050: IFFALSE 10308
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10052: LD_VAR 0 1
10056: PPUSH
10057: LD_VAR 0 4
10061: PUSH
10062: LD_INT 1
10064: PPUSH
10065: LD_INT 2
10067: PPUSH
10068: CALL_OW 12
10072: ARRAY
10073: PPUSH
10074: LD_INT 0
10076: PPUSH
10077: CALL_OW 49
// if i = sewiVeh then
10081: LD_VAR 0 1
10085: PUSH
10086: LD_EXP 73
10090: EQUAL
10091: IFFALSE 10128
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10093: LD_ADDR_EXP 72
10097: PUSH
10098: LD_STRING Vsevolod
10100: PPUSH
10101: LD_INT 0
10103: PPUSH
10104: LD_STRING 
10106: PPUSH
10107: CALL 68557 0 3
10111: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10112: LD_EXP 72
10116: PPUSH
10117: LD_VAR 0 1
10121: PPUSH
10122: CALL_OW 52
// end else
10126: GO 10209
// if GetControl ( i ) = control_manual then
10128: LD_VAR 0 1
10132: PPUSH
10133: CALL_OW 263
10137: PUSH
10138: LD_INT 1
10140: EQUAL
10141: IFFALSE 10209
// begin uc_side := 6 ;
10143: LD_ADDR_OWVAR 20
10147: PUSH
10148: LD_INT 6
10150: ST_TO_ADDR
// uc_nation := 3 ;
10151: LD_ADDR_OWVAR 21
10155: PUSH
10156: LD_INT 3
10158: ST_TO_ADDR
// hc_gallery :=  ;
10159: LD_ADDR_OWVAR 33
10163: PUSH
10164: LD_STRING 
10166: ST_TO_ADDR
// hc_name :=  ;
10167: LD_ADDR_OWVAR 26
10171: PUSH
10172: LD_STRING 
10174: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10175: LD_INT 0
10177: PPUSH
10178: LD_INT 3
10180: PPUSH
10181: LD_INT 10
10183: PPUSH
10184: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10188: CALL_OW 44
10192: PPUSH
10193: LD_VAR 0 1
10197: PPUSH
10198: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10202: LD_INT 10
10204: PPUSH
10205: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10209: LD_INT 1
10211: PPUSH
10212: LD_INT 3
10214: PPUSH
10215: CALL_OW 12
10219: PUSH
10220: LD_INT 1
10222: DOUBLE
10223: EQUAL
10224: IFTRUE 10228
10226: GO 10246
10228: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10229: LD_VAR 0 1
10233: PPUSH
10234: LD_INT 111
10236: PPUSH
10237: LD_INT 197
10239: PPUSH
10240: CALL_OW 111
10244: GO 10299
10246: LD_INT 2
10248: DOUBLE
10249: EQUAL
10250: IFTRUE 10254
10252: GO 10272
10254: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10255: LD_VAR 0 1
10259: PPUSH
10260: LD_INT 91
10262: PPUSH
10263: LD_INT 165
10265: PPUSH
10266: CALL_OW 111
10270: GO 10299
10272: LD_INT 3
10274: DOUBLE
10275: EQUAL
10276: IFTRUE 10280
10278: GO 10298
10280: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10281: LD_VAR 0 1
10285: PPUSH
10286: LD_INT 137
10288: PPUSH
10289: LD_INT 157
10291: PPUSH
10292: CALL_OW 111
10296: GO 10299
10298: POP
// wait ( 0 0$2 ) ;
10299: LD_INT 70
10301: PPUSH
10302: CALL_OW 67
// end ;
10306: GO 10049
10308: POP
10309: POP
// repeat wait ( 0 0$1 ) ;
10310: LD_INT 35
10312: PPUSH
10313: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10317: LD_ADDR_VAR 0 1
10321: PUSH
10322: LD_VAR 0 2
10326: PPUSH
10327: LD_INT 50
10329: PUSH
10330: EMPTY
10331: LIST
10332: PPUSH
10333: CALL_OW 72
10337: PUSH
10338: FOR_IN
10339: IFFALSE 10398
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10341: LD_VAR 0 1
10345: PPUSH
10346: LD_INT 108
10348: PUSH
10349: LD_INT 153
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PUSH
10356: LD_INT 105
10358: PUSH
10359: LD_INT 149
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: PUSH
10366: LD_INT 85
10368: PUSH
10369: LD_INT 131
10371: PUSH
10372: EMPTY
10373: LIST
10374: LIST
10375: PUSH
10376: LD_INT 64
10378: PUSH
10379: LD_INT 105
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: PPUSH
10392: CALL 108453 0 2
10396: GO 10338
10398: POP
10399: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10400: LD_VAR 0 2
10404: PPUSH
10405: LD_INT 50
10407: PUSH
10408: EMPTY
10409: LIST
10410: PPUSH
10411: CALL_OW 72
10415: NOT
10416: IFFALSE 10310
// end ; until russianDestroyed ;
10418: LD_EXP 21
10422: IFFALSE 9790
// end ;
10424: PPOPN 6
10426: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
10427: LD_EXP 21
10431: NOT
10432: PUSH
10433: LD_EXP 15
10437: PUSH
10438: LD_INT 6
10440: GREATEREQUAL
10441: AND
10442: IFFALSE 11381
10444: GO 10446
10446: DISABLE
10447: LD_INT 0
10449: PPUSH
10450: PPUSH
10451: PPUSH
10452: PPUSH
// begin enable ;
10453: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10454: LD_INT 22
10456: PUSH
10457: LD_INT 3
10459: PUSH
10460: EMPTY
10461: LIST
10462: LIST
10463: PUSH
10464: LD_INT 30
10466: PUSH
10467: LD_INT 3
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: PPUSH
10478: CALL_OW 69
10482: NOT
10483: IFFALSE 10487
// exit ;
10485: GO 11381
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10487: LD_ADDR_VAR 0 4
10491: PUSH
10492: LD_INT 22
10494: PUSH
10495: LD_INT 3
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: PUSH
10502: LD_INT 30
10504: PUSH
10505: LD_INT 34
10507: PUSH
10508: EMPTY
10509: LIST
10510: LIST
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PPUSH
10516: CALL_OW 69
10520: ST_TO_ADDR
// if Prob ( 40 ) then
10521: LD_INT 40
10523: PPUSH
10524: CALL_OW 13
10528: IFFALSE 10674
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10530: LD_INT 2
10532: PPUSH
10533: LD_INT 22
10535: PUSH
10536: LD_INT 3
10538: PUSH
10539: LD_INT 3
10541: PUSH
10542: LD_INT 49
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: PUSH
10551: LD_INT 22
10553: PUSH
10554: LD_INT 3
10556: PUSH
10557: LD_INT 3
10559: PUSH
10560: LD_INT 49
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: PUSH
10569: LD_INT 22
10571: PUSH
10572: LD_INT 3
10574: PUSH
10575: LD_INT 3
10577: PUSH
10578: LD_INT 49
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: PUSH
10587: LD_INT 24
10589: PUSH
10590: LD_INT 3
10592: PUSH
10593: LD_INT 3
10595: PUSH
10596: LD_INT 46
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: PUSH
10605: LD_INT 24
10607: PUSH
10608: LD_INT 3
10610: PUSH
10611: LD_INT 3
10613: PUSH
10614: LD_INT 46
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: PUSH
10623: LD_INT 24
10625: PUSH
10626: LD_INT 3
10628: PUSH
10629: LD_INT 3
10631: PUSH
10632: LD_INT 46
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: LIST
10639: LIST
10640: PUSH
10641: LD_INT 24
10643: PUSH
10644: LD_INT 3
10646: PUSH
10647: LD_INT 3
10649: PUSH
10650: LD_INT 46
10652: PUSH
10653: EMPTY
10654: LIST
10655: LIST
10656: LIST
10657: LIST
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: LIST
10666: LIST
10667: PPUSH
10668: CALL 62131 0 2
// end else
10672: GO 10816
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10674: LD_INT 2
10676: PPUSH
10677: LD_INT 24
10679: PUSH
10680: LD_INT 3
10682: PUSH
10683: LD_INT 3
10685: PUSH
10686: LD_INT 47
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: LIST
10693: LIST
10694: PUSH
10695: LD_INT 24
10697: PUSH
10698: LD_INT 3
10700: PUSH
10701: LD_INT 3
10703: PUSH
10704: LD_INT 47
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 24
10715: PUSH
10716: LD_INT 3
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: LD_INT 47
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: LIST
10730: PUSH
10731: LD_INT 24
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: LD_INT 3
10739: PUSH
10740: LD_INT 46
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: PUSH
10749: LD_INT 24
10751: PUSH
10752: LD_INT 3
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: LD_INT 46
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: LIST
10765: LIST
10766: PUSH
10767: LD_INT 24
10769: PUSH
10770: LD_INT 3
10772: PUSH
10773: LD_INT 3
10775: PUSH
10776: LD_INT 46
10778: PUSH
10779: EMPTY
10780: LIST
10781: LIST
10782: LIST
10783: LIST
10784: PUSH
10785: LD_INT 24
10787: PUSH
10788: LD_INT 3
10790: PUSH
10791: LD_INT 3
10793: PUSH
10794: LD_INT 46
10796: PUSH
10797: EMPTY
10798: LIST
10799: LIST
10800: LIST
10801: LIST
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: LIST
10810: LIST
10811: PPUSH
10812: CALL 62131 0 2
// end ; repeat wait ( 0 0$1 ) ;
10816: LD_INT 35
10818: PPUSH
10819: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10823: LD_INT 2
10825: PPUSH
10826: LD_INT 1
10828: PPUSH
10829: CALL 63549 0 2
10833: PUSH
10834: LD_INT 7
10836: GREATEREQUAL
10837: IFFALSE 10816
// wait ( 0 0$10 ) ;
10839: LD_INT 350
10841: PPUSH
10842: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_INT 2
10853: PPUSH
10854: LD_INT 1
10856: PPUSH
10857: CALL 63549 0 2
10861: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10862: LD_ADDR_EXP 119
10866: PUSH
10867: LD_EXP 119
10871: PPUSH
10872: LD_INT 2
10874: PPUSH
10875: LD_EXP 119
10879: PUSH
10880: LD_INT 2
10882: ARRAY
10883: PUSH
10884: LD_VAR 0 2
10888: DIFF
10889: PPUSH
10890: CALL_OW 1
10894: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10895: LD_ADDR_VAR 0 3
10899: PUSH
10900: LD_INT 0
10902: PPUSH
10903: LD_INT 1
10905: PPUSH
10906: CALL_OW 12
10910: ST_TO_ADDR
// if target then
10911: LD_VAR 0 3
10915: IFFALSE 11043
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10917: LD_ADDR_VAR 0 2
10921: PUSH
10922: LD_VAR 0 2
10926: PPUSH
10927: LD_INT 24
10929: PUSH
10930: LD_INT 250
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PPUSH
10937: CALL_OW 72
10941: ST_TO_ADDR
// for i in tmp do
10942: LD_ADDR_VAR 0 1
10946: PUSH
10947: LD_VAR 0 2
10951: PUSH
10952: FOR_IN
10953: IFFALSE 10993
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10955: LD_VAR 0 1
10959: PPUSH
10960: LD_INT 139
10962: PPUSH
10963: LD_INT 89
10965: PPUSH
10966: CALL_OW 297
10970: PUSH
10971: LD_INT 9
10973: GREATER
10974: IFFALSE 10991
// ComMoveXY ( i , 139 , 89 ) ;
10976: LD_VAR 0 1
10980: PPUSH
10981: LD_INT 139
10983: PPUSH
10984: LD_INT 89
10986: PPUSH
10987: CALL_OW 111
10991: GO 10952
10993: POP
10994: POP
// wait ( 0 0$1 ) ;
10995: LD_INT 35
10997: PPUSH
10998: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
11002: LD_VAR 0 2
11006: PPUSH
11007: LD_INT 92
11009: PUSH
11010: LD_INT 139
11012: PUSH
11013: LD_INT 89
11015: PUSH
11016: LD_INT 9
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 72
11029: PUSH
11030: LD_VAR 0 2
11034: PUSH
11035: LD_INT 1
11037: MINUS
11038: GREATEREQUAL
11039: IFFALSE 10917
// end else
11041: GO 11185
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11043: LD_VAR 0 2
11047: PPUSH
11048: LD_VAR 0 4
11052: PUSH
11053: LD_INT 1
11055: ARRAY
11056: PPUSH
11057: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11061: LD_ADDR_VAR 0 2
11065: PUSH
11066: LD_VAR 0 2
11070: PPUSH
11071: LD_INT 24
11073: PUSH
11074: LD_INT 250
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: PPUSH
11081: CALL_OW 72
11085: ST_TO_ADDR
// for i in tmp do
11086: LD_ADDR_VAR 0 1
11090: PUSH
11091: LD_VAR 0 2
11095: PUSH
11096: FOR_IN
11097: IFFALSE 11137
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11099: LD_VAR 0 1
11103: PPUSH
11104: LD_INT 124
11106: PPUSH
11107: LD_INT 139
11109: PPUSH
11110: CALL_OW 297
11114: PUSH
11115: LD_INT 9
11117: GREATER
11118: IFFALSE 11135
// ComMoveXY ( i , 124 , 139 ) ;
11120: LD_VAR 0 1
11124: PPUSH
11125: LD_INT 124
11127: PPUSH
11128: LD_INT 139
11130: PPUSH
11131: CALL_OW 111
11135: GO 11096
11137: POP
11138: POP
// wait ( 0 0$1 ) ;
11139: LD_INT 35
11141: PPUSH
11142: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11146: LD_VAR 0 2
11150: PPUSH
11151: LD_INT 92
11153: PUSH
11154: LD_INT 124
11156: PUSH
11157: LD_INT 139
11159: PUSH
11160: LD_INT 9
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: PPUSH
11169: CALL_OW 72
11173: PUSH
11174: LD_VAR 0 2
11178: PUSH
11179: LD_INT 1
11181: MINUS
11182: GREATEREQUAL
11183: IFFALSE 11061
// end ; repeat wait ( 0 0$1 ) ;
11185: LD_INT 35
11187: PPUSH
11188: CALL_OW 67
// for i in tmp do
11192: LD_ADDR_VAR 0 1
11196: PUSH
11197: LD_VAR 0 2
11201: PUSH
11202: FOR_IN
11203: IFFALSE 11372
// begin if GetLives ( i ) > 251 then
11205: LD_VAR 0 1
11209: PPUSH
11210: CALL_OW 256
11214: PUSH
11215: LD_INT 251
11217: GREATER
11218: IFFALSE 11343
// begin if GetWeapon ( i ) = ru_time_lapser then
11220: LD_VAR 0 1
11224: PPUSH
11225: CALL_OW 264
11229: PUSH
11230: LD_INT 49
11232: EQUAL
11233: IFFALSE 11289
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11235: LD_VAR 0 1
11239: PPUSH
11240: LD_INT 2
11242: PUSH
11243: LD_INT 22
11245: PUSH
11246: LD_INT 1
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 22
11255: PUSH
11256: LD_INT 8
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: LIST
11267: PPUSH
11268: CALL_OW 69
11272: PPUSH
11273: LD_VAR 0 1
11277: PPUSH
11278: CALL_OW 74
11282: PPUSH
11283: CALL_OW 112
11287: GO 11341
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11289: LD_VAR 0 1
11293: PPUSH
11294: LD_INT 2
11296: PUSH
11297: LD_INT 22
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 22
11309: PUSH
11310: LD_INT 8
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: LIST
11321: PPUSH
11322: CALL_OW 69
11326: PPUSH
11327: LD_VAR 0 1
11331: PPUSH
11332: CALL_OW 74
11336: PPUSH
11337: CALL_OW 115
// end else
11341: GO 11370
// if IsDead ( i ) then
11343: LD_VAR 0 1
11347: PPUSH
11348: CALL_OW 301
11352: IFFALSE 11370
// tmp := tmp diff i ;
11354: LD_ADDR_VAR 0 2
11358: PUSH
11359: LD_VAR 0 2
11363: PUSH
11364: LD_VAR 0 1
11368: DIFF
11369: ST_TO_ADDR
// end ;
11370: GO 11202
11372: POP
11373: POP
// until not tmp ;
11374: LD_VAR 0 2
11378: NOT
11379: IFFALSE 11185
// end ;
11381: PPOPN 4
11383: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11384: LD_EXP 15
11388: PUSH
11389: LD_INT 7
11391: GREATEREQUAL
11392: PUSH
11393: LD_OWVAR 67
11397: PUSH
11398: LD_INT 1
11400: GREATER
11401: AND
11402: IFFALSE 11586
11404: GO 11406
11406: DISABLE
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
// begin ruMobile := [ ] ;
11412: LD_ADDR_EXP 76
11416: PUSH
11417: EMPTY
11418: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11419: LD_ADDR_VAR 0 1
11423: PUSH
11424: DOUBLE
11425: LD_INT 1
11427: DEC
11428: ST_TO_ADDR
11429: LD_INT 3
11431: PUSH
11432: LD_INT 4
11434: PUSH
11435: LD_INT 5
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: LIST
11442: PUSH
11443: LD_OWVAR 67
11447: PUSH
11448: LD_INT 1
11450: MINUS
11451: ARRAY
11452: PUSH
11453: FOR_TO
11454: IFFALSE 11584
// begin uc_side := 3 ;
11456: LD_ADDR_OWVAR 20
11460: PUSH
11461: LD_INT 3
11463: ST_TO_ADDR
// uc_nation := 3 ;
11464: LD_ADDR_OWVAR 21
11468: PUSH
11469: LD_INT 3
11471: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11472: LD_INT 21
11474: PPUSH
11475: LD_INT 3
11477: PPUSH
11478: LD_INT 1
11480: PPUSH
11481: LD_INT 45
11483: PPUSH
11484: LD_INT 100
11486: PPUSH
11487: CALL 73397 0 5
// veh := CreateVehicle ;
11491: LD_ADDR_VAR 0 2
11495: PUSH
11496: CALL_OW 45
11500: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11501: LD_VAR 0 2
11505: PPUSH
11506: LD_INT 3
11508: PPUSH
11509: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11513: LD_VAR 0 2
11517: PPUSH
11518: LD_INT 29
11520: PPUSH
11521: LD_INT 0
11523: PPUSH
11524: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11528: LD_INT 0
11530: PPUSH
11531: LD_INT 10
11533: PPUSH
11534: CALL_OW 383
// un := CreateHuman ;
11538: LD_ADDR_VAR 0 3
11542: PUSH
11543: CALL_OW 44
11547: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11548: LD_VAR 0 3
11552: PPUSH
11553: LD_VAR 0 2
11557: PPUSH
11558: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11562: LD_ADDR_EXP 76
11566: PUSH
11567: LD_EXP 76
11571: PPUSH
11572: LD_VAR 0 2
11576: PPUSH
11577: CALL 105849 0 2
11581: ST_TO_ADDR
// end ;
11582: GO 11453
11584: POP
11585: POP
// end ;
11586: PPOPN 3
11588: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11589: LD_EXP 76
11593: IFFALSE 12101
11595: GO 11597
11597: DISABLE
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
// begin enable ;
11603: ENABLE
// if not ruMobile then
11604: LD_EXP 76
11608: NOT
11609: IFFALSE 11613
// exit ;
11611: GO 12101
// for i in ruMobile do
11613: LD_ADDR_VAR 0 1
11617: PUSH
11618: LD_EXP 76
11622: PUSH
11623: FOR_IN
11624: IFFALSE 12099
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11626: LD_VAR 0 1
11630: PPUSH
11631: CALL_OW 302
11635: NOT
11636: PUSH
11637: LD_VAR 0 1
11641: PPUSH
11642: CALL_OW 255
11646: PUSH
11647: LD_INT 3
11649: NONEQUAL
11650: OR
11651: IFFALSE 11671
// begin ruMobile := ruMobile diff i ;
11653: LD_ADDR_EXP 76
11657: PUSH
11658: LD_EXP 76
11662: PUSH
11663: LD_VAR 0 1
11667: DIFF
11668: ST_TO_ADDR
// continue ;
11669: GO 11623
// end ; if GetTag ( i ) = 300 then
11671: LD_VAR 0 1
11675: PPUSH
11676: CALL_OW 110
11680: PUSH
11681: LD_INT 300
11683: EQUAL
11684: IFFALSE 11734
// begin ComMoveXY ( i , 160 , 81 ) ;
11686: LD_VAR 0 1
11690: PPUSH
11691: LD_INT 160
11693: PPUSH
11694: LD_INT 81
11696: PPUSH
11697: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11701: LD_VAR 0 1
11705: PPUSH
11706: LD_INT 160
11708: PPUSH
11709: LD_INT 81
11711: PPUSH
11712: CALL_OW 297
11716: PUSH
11717: LD_INT 8
11719: LESS
11720: IFFALSE 11734
// SetTag ( i , 301 ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_INT 301
11729: PPUSH
11730: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11734: LD_VAR 0 1
11738: PPUSH
11739: CALL_OW 110
11743: PUSH
11744: LD_INT 301
11746: EQUAL
11747: IFFALSE 11790
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11749: LD_VAR 0 1
11753: PPUSH
11754: LD_INT 33
11756: PPUSH
11757: CALL_OW 308
11761: NOT
11762: IFFALSE 11778
// ComMoveToArea ( i , ruMobileParkingArea ) else
11764: LD_VAR 0 1
11768: PPUSH
11769: LD_INT 33
11771: PPUSH
11772: CALL_OW 113
11776: GO 11790
// SetTag ( i , 302 ) ;
11778: LD_VAR 0 1
11782: PPUSH
11783: LD_INT 302
11785: PPUSH
11786: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 110
11799: PUSH
11800: LD_INT 302
11802: EQUAL
11803: IFFALSE 11933
// begin if GetLives ( i ) < 1000 then
11805: LD_VAR 0 1
11809: PPUSH
11810: CALL_OW 256
11814: PUSH
11815: LD_INT 1000
11817: LESS
11818: IFFALSE 11910
// begin if not IsDrivenBy ( i ) then
11820: LD_VAR 0 1
11824: PPUSH
11825: CALL_OW 311
11829: NOT
11830: IFFALSE 11834
// continue ;
11832: GO 11623
// mech := IsDrivenBy ( i ) ;
11834: LD_ADDR_VAR 0 2
11838: PUSH
11839: LD_VAR 0 1
11843: PPUSH
11844: CALL_OW 311
11848: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11849: LD_VAR 0 2
11853: PPUSH
11854: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11858: LD_VAR 0 2
11862: PPUSH
11863: LD_VAR 0 1
11867: PPUSH
11868: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11872: LD_INT 35
11874: PPUSH
11875: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11879: LD_VAR 0 1
11883: PPUSH
11884: CALL_OW 256
11888: PUSH
11889: LD_INT 1000
11891: EQUAL
11892: IFFALSE 11872
// ComEnterUnit ( mech , i ) ;
11894: LD_VAR 0 2
11898: PPUSH
11899: LD_VAR 0 1
11903: PPUSH
11904: CALL_OW 120
// end else
11908: GO 11933
// if IsDrivenBy ( i ) then
11910: LD_VAR 0 1
11914: PPUSH
11915: CALL_OW 311
11919: IFFALSE 11933
// SetTag ( i , 0 ) ;
11921: LD_VAR 0 1
11925: PPUSH
11926: LD_INT 0
11928: PPUSH
11929: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11933: LD_VAR 0 1
11937: PPUSH
11938: CALL_OW 110
11942: PUSH
11943: LD_INT 300
11945: LESS
11946: IFFALSE 12097
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11948: LD_ADDR_VAR 0 3
11952: PUSH
11953: LD_INT 4
11955: PPUSH
11956: LD_INT 81
11958: PUSH
11959: LD_INT 3
11961: PUSH
11962: EMPTY
11963: LIST
11964: LIST
11965: PPUSH
11966: CALL_OW 70
11970: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11971: LD_VAR 0 1
11975: PPUSH
11976: CALL_OW 256
11980: PUSH
11981: LD_INT 650
11983: LESS
11984: IFFALSE 12009
// begin ComStop ( i ) ;
11986: LD_VAR 0 1
11990: PPUSH
11991: CALL_OW 141
// SetTag ( i , 300 ) ;
11995: LD_VAR 0 1
11999: PPUSH
12000: LD_INT 300
12002: PPUSH
12003: CALL_OW 109
// continue ;
12007: GO 11623
// end ; if enemy then
12009: LD_VAR 0 3
12013: IFFALSE 12053
// begin if not HasTask ( i ) then
12015: LD_VAR 0 1
12019: PPUSH
12020: CALL_OW 314
12024: NOT
12025: IFFALSE 12051
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12027: LD_VAR 0 1
12031: PPUSH
12032: LD_VAR 0 3
12036: PPUSH
12037: LD_VAR 0 1
12041: PPUSH
12042: CALL_OW 74
12046: PPUSH
12047: CALL_OW 115
// end else
12051: GO 12097
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12053: LD_VAR 0 1
12057: PPUSH
12058: LD_INT 158
12060: PUSH
12061: LD_INT 61
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: PUSH
12068: LD_INT 98
12070: PUSH
12071: LD_INT 100
12073: PUSH
12074: EMPTY
12075: LIST
12076: LIST
12077: PUSH
12078: LD_INT 78
12080: PUSH
12081: LD_INT 93
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL 108453 0 2
// end ; end ;
12097: GO 11623
12099: POP
12100: POP
// end ; end_of_file
12101: PPOPN 3
12103: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12104: LD_INT 0
12106: PPUSH
12107: PPUSH
12108: PPUSH
12109: PPUSH
12110: PPUSH
12111: PPUSH
12112: PPUSH
// side := 7 ;
12113: LD_ADDR_VAR 0 5
12117: PUSH
12118: LD_INT 7
12120: ST_TO_ADDR
// uc_side := side ;
12121: LD_ADDR_OWVAR 20
12125: PUSH
12126: LD_VAR 0 5
12130: ST_TO_ADDR
// uc_nation := 1 ;
12131: LD_ADDR_OWVAR 21
12135: PUSH
12136: LD_INT 1
12138: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12139: LD_ADDR_VAR 0 2
12143: PUSH
12144: LD_INT 22
12146: PUSH
12147: LD_VAR 0 5
12151: PUSH
12152: EMPTY
12153: LIST
12154: LIST
12155: PUSH
12156: LD_INT 21
12158: PUSH
12159: LD_INT 3
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PPUSH
12170: CALL_OW 69
12174: PUSH
12175: FOR_IN
12176: IFFALSE 12192
// SetBLevel ( i , 10 ) ;
12178: LD_VAR 0 2
12182: PPUSH
12183: LD_INT 10
12185: PPUSH
12186: CALL_OW 241
12190: GO 12175
12192: POP
12193: POP
// base := GetBase ( al_depot ) ;
12194: LD_ADDR_VAR 0 4
12198: PUSH
12199: LD_INT 2
12201: PPUSH
12202: CALL_OW 274
12206: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12207: LD_ADDR_VAR 0 6
12211: PUSH
12212: LD_INT 22
12214: PUSH
12215: LD_VAR 0 5
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: LD_INT 34
12229: PUSH
12230: EMPTY
12231: LIST
12232: LIST
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PPUSH
12238: CALL_OW 69
12242: ST_TO_ADDR
// if teleport then
12243: LD_VAR 0 6
12247: IFFALSE 12268
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12249: LD_VAR 0 6
12253: PUSH
12254: LD_INT 1
12256: ARRAY
12257: PPUSH
12258: LD_INT 262
12260: PPUSH
12261: LD_INT 119
12263: PPUSH
12264: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12268: LD_VAR 0 4
12272: PPUSH
12273: LD_INT 1
12275: PPUSH
12276: LD_INT 19500
12278: PPUSH
12279: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12283: LD_VAR 0 4
12287: PPUSH
12288: LD_INT 2
12290: PPUSH
12291: LD_INT 200
12293: PPUSH
12294: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12298: LD_VAR 0 4
12302: PPUSH
12303: LD_INT 3
12305: PPUSH
12306: LD_INT 650
12308: PPUSH
12309: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12313: LD_ADDR_EXP 77
12317: PUSH
12318: LD_STRING Roth
12320: PPUSH
12321: CALL_OW 25
12325: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12326: LD_ADDR_EXP 78
12330: PUSH
12331: LD_STRING Simms
12333: PPUSH
12334: LD_EXP 1
12338: NOT
12339: PPUSH
12340: LD_STRING 10c_
12342: PPUSH
12343: CALL 68557 0 3
12347: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12348: LD_EXP 78
12352: PPUSH
12353: LD_INT 4
12355: PPUSH
12356: CALL_OW 336
// if not Simms then
12360: LD_EXP 78
12364: NOT
12365: IFFALSE 12395
// begin uc_nation := 1 ;
12367: LD_ADDR_OWVAR 21
12371: PUSH
12372: LD_INT 1
12374: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12375: LD_INT 2
12377: PPUSH
12378: LD_INT 10
12380: PPUSH
12381: CALL_OW 384
// Simms := CreateHuman ;
12385: LD_ADDR_EXP 78
12389: PUSH
12390: CALL_OW 44
12394: ST_TO_ADDR
// end ; uc_nation := 3 ;
12395: LD_ADDR_OWVAR 21
12399: PUSH
12400: LD_INT 3
12402: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12403: LD_ADDR_EXP 79
12407: PUSH
12408: LD_STRING Kirilenkova
12410: PPUSH
12411: CALL_OW 25
12415: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12416: LD_ADDR_EXP 93
12420: PUSH
12421: LD_STRING Oblukov
12423: PPUSH
12424: CALL_OW 25
12428: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12429: LD_ADDR_EXP 80
12433: PUSH
12434: LD_STRING Dolgov
12436: PPUSH
12437: CALL_OW 25
12441: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12442: LD_ADDR_EXP 81
12446: PUSH
12447: LD_STRING Petrosyan
12449: PPUSH
12450: CALL_OW 25
12454: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12455: LD_ADDR_EXP 92
12459: PUSH
12460: LD_STRING Scholtze
12462: PPUSH
12463: CALL_OW 25
12467: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12468: LD_ADDR_EXP 91
12472: PUSH
12473: LD_STRING Kapitsova
12475: PPUSH
12476: CALL_OW 25
12480: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12481: LD_ADDR_EXP 82
12485: PUSH
12486: LD_STRING Petrovova
12488: PPUSH
12489: CALL_OW 25
12493: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12494: LD_ADDR_EXP 83
12498: PUSH
12499: LD_STRING Kuzmov
12501: PPUSH
12502: CALL_OW 25
12506: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12507: LD_ADDR_EXP 90
12511: PUSH
12512: LD_STRING Karamazov
12514: PPUSH
12515: CALL_OW 25
12519: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12520: LD_STRING 13_Lipshchin_1
12522: PPUSH
12523: LD_INT 0
12525: PPUSH
12526: CALL_OW 30
12530: IFFALSE 12545
// Lipshchin := NewCharacter ( Lipshchin ) ;
12532: LD_ADDR_EXP 84
12536: PUSH
12537: LD_STRING Lipshchin
12539: PPUSH
12540: CALL_OW 25
12544: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12545: LD_STRING 13_Titov_1
12547: PPUSH
12548: LD_INT 0
12550: PPUSH
12551: CALL_OW 30
12555: IFFALSE 12570
// Titov := NewCharacter ( Titov ) ;
12557: LD_ADDR_EXP 86
12561: PUSH
12562: LD_STRING Titov
12564: PPUSH
12565: CALL_OW 25
12569: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12570: LD_STRING 13_Gnyevko_1
12572: PPUSH
12573: LD_INT 0
12575: PPUSH
12576: CALL_OW 30
12580: IFFALSE 12595
// Gnyevko := NewCharacter ( Gnyevko ) ;
12582: LD_ADDR_EXP 85
12586: PUSH
12587: LD_STRING Gnyevko
12589: PPUSH
12590: CALL_OW 25
12594: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12595: LD_STRING 13_Xavier_1
12597: PPUSH
12598: LD_INT 0
12600: PPUSH
12601: CALL_OW 30
12605: IFFALSE 12620
// Xavier := NewCharacter ( Xavier2 ) ;
12607: LD_ADDR_EXP 87
12611: PUSH
12612: LD_STRING Xavier2
12614: PPUSH
12615: CALL_OW 25
12619: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12620: LD_STRING 13_Belkov_1
12622: PPUSH
12623: LD_INT 0
12625: PPUSH
12626: CALL_OW 30
12630: IFFALSE 12645
// Belkov := NewCharacter ( Belkov ) ;
12632: LD_ADDR_EXP 88
12636: PUSH
12637: LD_STRING Belkov
12639: PPUSH
12640: CALL_OW 25
12644: ST_TO_ADDR
// if not BurlakStatus then
12645: LD_EXP 9
12649: NOT
12650: IFFALSE 12665
// Burlak = NewCharacter ( Burlak ) ;
12652: LD_ADDR_EXP 89
12656: PUSH
12657: LD_STRING Burlak
12659: PPUSH
12660: CALL_OW 25
12664: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12665: LD_ADDR_VAR 0 3
12669: PUSH
12670: LD_EXP 77
12674: PUSH
12675: LD_EXP 79
12679: PUSH
12680: LD_EXP 93
12684: PUSH
12685: LD_EXP 80
12689: PUSH
12690: LD_EXP 81
12694: PUSH
12695: LD_EXP 92
12699: PUSH
12700: LD_EXP 91
12704: PUSH
12705: LD_EXP 82
12709: PUSH
12710: LD_EXP 83
12714: PUSH
12715: LD_EXP 90
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: LIST
12731: ST_TO_ADDR
// if Simms then
12732: LD_EXP 78
12736: IFFALSE 12754
// tmp := tmp ^ Simms ;
12738: LD_ADDR_VAR 0 3
12742: PUSH
12743: LD_VAR 0 3
12747: PUSH
12748: LD_EXP 78
12752: ADD
12753: ST_TO_ADDR
// if Titov then
12754: LD_EXP 86
12758: IFFALSE 12776
// tmp := tmp ^ Titov ;
12760: LD_ADDR_VAR 0 3
12764: PUSH
12765: LD_VAR 0 3
12769: PUSH
12770: LD_EXP 86
12774: ADD
12775: ST_TO_ADDR
// if Lipshchin then
12776: LD_EXP 84
12780: IFFALSE 12798
// tmp := tmp ^ Lipshchin ;
12782: LD_ADDR_VAR 0 3
12786: PUSH
12787: LD_VAR 0 3
12791: PUSH
12792: LD_EXP 84
12796: ADD
12797: ST_TO_ADDR
// if Gnyevko then
12798: LD_EXP 85
12802: IFFALSE 12820
// tmp := tmp ^ Gnyevko ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 3
12813: PUSH
12814: LD_EXP 85
12818: ADD
12819: ST_TO_ADDR
// if Xavier then
12820: LD_EXP 87
12824: IFFALSE 12842
// tmp := tmp ^ Xavier ;
12826: LD_ADDR_VAR 0 3
12830: PUSH
12831: LD_VAR 0 3
12835: PUSH
12836: LD_EXP 87
12840: ADD
12841: ST_TO_ADDR
// if Belkov then
12842: LD_EXP 88
12846: IFFALSE 12864
// tmp := tmp ^ Belkov ;
12848: LD_ADDR_VAR 0 3
12852: PUSH
12853: LD_VAR 0 3
12857: PUSH
12858: LD_EXP 88
12862: ADD
12863: ST_TO_ADDR
// if Burlak then
12864: LD_EXP 89
12868: IFFALSE 12886
// tmp := tmp ^ Burlak ;
12870: LD_ADDR_VAR 0 3
12874: PUSH
12875: LD_VAR 0 3
12879: PUSH
12880: LD_EXP 89
12884: ADD
12885: ST_TO_ADDR
// for i = 1 to 11 do
12886: LD_ADDR_VAR 0 2
12890: PUSH
12891: DOUBLE
12892: LD_INT 1
12894: DEC
12895: ST_TO_ADDR
12896: LD_INT 11
12898: PUSH
12899: FOR_TO
12900: IFFALSE 12968
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12902: LD_ADDR_OWVAR 21
12906: PUSH
12907: LD_INT 1
12909: PUSH
12910: LD_INT 3
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: PUSH
12917: LD_INT 1
12919: PPUSH
12920: LD_INT 2
12922: PPUSH
12923: CALL_OW 12
12927: ARRAY
12928: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
12929: LD_INT 0
12931: PPUSH
12932: LD_INT 1
12934: PPUSH
12935: LD_INT 4
12937: PPUSH
12938: CALL_OW 12
12942: PPUSH
12943: LD_INT 10
12945: PPUSH
12946: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12950: LD_ADDR_VAR 0 3
12954: PUSH
12955: LD_VAR 0 3
12959: PUSH
12960: CALL_OW 44
12964: ADD
12965: ST_TO_ADDR
// end ;
12966: GO 12899
12968: POP
12969: POP
// for i in tmp do
12970: LD_ADDR_VAR 0 2
12974: PUSH
12975: LD_VAR 0 3
12979: PUSH
12980: FOR_IN
12981: IFFALSE 13006
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12983: LD_VAR 0 2
12987: PPUSH
12988: LD_INT 260
12990: PPUSH
12991: LD_INT 235
12993: PPUSH
12994: LD_INT 8
12996: PPUSH
12997: LD_INT 0
12999: PPUSH
13000: CALL_OW 50
13004: GO 12980
13006: POP
13007: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13008: LD_ADDR_EXP 100
13012: PUSH
13013: LD_EXP 100
13017: PPUSH
13018: LD_INT 1
13020: PPUSH
13021: LD_INT 22
13023: PUSH
13024: LD_VAR 0 5
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 3
13035: PUSH
13036: LD_INT 21
13038: PUSH
13039: LD_INT 2
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PPUSH
13054: CALL_OW 69
13058: PUSH
13059: LD_EXP 77
13063: PUSH
13064: LD_EXP 78
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: DIFF
13073: PPUSH
13074: CALL_OW 1
13078: ST_TO_ADDR
// uc_side := 0 ;
13079: LD_ADDR_OWVAR 20
13083: PUSH
13084: LD_INT 0
13086: ST_TO_ADDR
// uc_nation := 0 ;
13087: LD_ADDR_OWVAR 21
13091: PUSH
13092: LD_INT 0
13094: ST_TO_ADDR
// for i = 1 to 5 do
13095: LD_ADDR_VAR 0 2
13099: PUSH
13100: DOUBLE
13101: LD_INT 1
13103: DEC
13104: ST_TO_ADDR
13105: LD_INT 5
13107: PUSH
13108: FOR_TO
13109: IFFALSE 13146
// begin InitHc ;
13111: CALL_OW 19
// hc_class := class_apeman ;
13115: LD_ADDR_OWVAR 28
13119: PUSH
13120: LD_INT 12
13122: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13123: CALL_OW 44
13127: PPUSH
13128: LD_INT 299
13130: PPUSH
13131: LD_INT 229
13133: PPUSH
13134: LD_INT 10
13136: PPUSH
13137: LD_INT 0
13139: PPUSH
13140: CALL_OW 50
// end ;
13144: GO 13108
13146: POP
13147: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13148: LD_EXP 77
13152: PPUSH
13153: LD_INT 259
13155: PPUSH
13156: LD_INT 235
13158: PPUSH
13159: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13163: LD_EXP 77
13167: PPUSH
13168: LD_INT 262
13170: PPUSH
13171: LD_INT 235
13173: PPUSH
13174: CALL_OW 178
// if Simms then
13178: LD_EXP 78
13182: IFFALSE 13213
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13184: LD_EXP 78
13188: PPUSH
13189: LD_INT 262
13191: PPUSH
13192: LD_INT 235
13194: PPUSH
13195: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13199: LD_EXP 78
13203: PPUSH
13204: LD_EXP 77
13208: PPUSH
13209: CALL_OW 179
// end ; uc_side := 7 ;
13213: LD_ADDR_OWVAR 20
13217: PUSH
13218: LD_INT 7
13220: ST_TO_ADDR
// uc_nation := 1 ;
13221: LD_ADDR_OWVAR 21
13225: PUSH
13226: LD_INT 1
13228: ST_TO_ADDR
// bc_type := b_control_tower ;
13229: LD_ADDR_OWVAR 42
13233: PUSH
13234: LD_INT 36
13236: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13237: LD_ADDR_VAR 0 7
13241: PUSH
13242: LD_INT 268
13244: PPUSH
13245: LD_INT 251
13247: PPUSH
13248: LD_INT 4
13250: PPUSH
13251: CALL_OW 47
13255: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13256: LD_INT 0
13258: PPUSH
13259: LD_INT 10
13261: PPUSH
13262: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13266: CALL_OW 44
13270: PPUSH
13271: LD_VAR 0 7
13275: PPUSH
13276: CALL_OW 52
// end ;
13280: LD_VAR 0 1
13284: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13285: LD_EXP 31
13289: PUSH
13290: LD_EXP 23
13294: NOT
13295: AND
13296: IFFALSE 13524
13298: GO 13300
13300: DISABLE
13301: LD_INT 0
13303: PPUSH
13304: PPUSH
13305: PPUSH
// begin enable ;
13306: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13307: LD_ADDR_VAR 0 2
13311: PUSH
13312: LD_INT 81
13314: PUSH
13315: LD_INT 7
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: PUSH
13322: LD_INT 2
13324: PUSH
13325: LD_INT 32
13327: PUSH
13328: LD_INT 3
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 30
13337: PUSH
13338: LD_INT 30
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: LD_INT 30
13347: PUSH
13348: LD_INT 28
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PUSH
13355: LD_INT 34
13357: PUSH
13358: LD_INT 49
13360: PUSH
13361: EMPTY
13362: LIST
13363: LIST
13364: PUSH
13365: LD_INT 34
13367: PUSH
13368: LD_INT 10
13370: PUSH
13371: EMPTY
13372: LIST
13373: LIST
13374: PUSH
13375: LD_INT 34
13377: PUSH
13378: LD_INT 8
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: EMPTY
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PPUSH
13398: CALL_OW 69
13402: ST_TO_ADDR
// if not tmp then
13403: LD_VAR 0 2
13407: NOT
13408: IFFALSE 13412
// exit ;
13410: GO 13524
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13412: LD_VAR 0 2
13416: PPUSH
13417: LD_INT 34
13419: PUSH
13420: LD_INT 8
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: PPUSH
13427: CALL_OW 72
13431: IFFALSE 13464
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13433: LD_ADDR_VAR 0 3
13437: PUSH
13438: LD_VAR 0 2
13442: PPUSH
13443: LD_INT 34
13445: PUSH
13446: LD_INT 8
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PPUSH
13453: CALL_OW 72
13457: PUSH
13458: LD_INT 1
13460: ARRAY
13461: ST_TO_ADDR
13462: GO 13488
// target := tmp [ rand ( 1 , tmp ) ] ;
13464: LD_ADDR_VAR 0 3
13468: PUSH
13469: LD_VAR 0 2
13473: PUSH
13474: LD_INT 1
13476: PPUSH
13477: LD_VAR 0 2
13481: PPUSH
13482: CALL_OW 12
13486: ARRAY
13487: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13488: LD_VAR 0 3
13492: PPUSH
13493: CALL_OW 255
13497: PUSH
13498: LD_INT 1
13500: EQUAL
13501: IFFALSE 13512
// CenterNowOnUnits ( target ) ;
13503: LD_VAR 0 3
13507: PPUSH
13508: CALL_OW 87
// SetLives ( target , 0 ) ;
13512: LD_VAR 0 3
13516: PPUSH
13517: LD_INT 0
13519: PPUSH
13520: CALL_OW 234
// end ;
13524: PPOPN 3
13526: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13527: LD_EXP 23
13531: NOT
13532: PUSH
13533: LD_EXP 31
13537: AND
13538: IFFALSE 14075
13540: GO 13542
13542: DISABLE
13543: LD_INT 0
13545: PPUSH
13546: PPUSH
13547: PPUSH
// begin uc_side := 7 ;
13548: LD_ADDR_OWVAR 20
13552: PUSH
13553: LD_INT 7
13555: ST_TO_ADDR
// uc_nation := 1 ;
13556: LD_ADDR_OWVAR 21
13560: PUSH
13561: LD_INT 1
13563: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
13564: LD_ADDR_VAR 0 3
13568: PUSH
13569: LD_INT 125
13571: PUSH
13572: LD_INT 163
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 185
13581: PUSH
13582: LD_INT 168
13584: PUSH
13585: EMPTY
13586: LIST
13587: LIST
13588: PUSH
13589: LD_INT 111
13591: PUSH
13592: LD_INT 97
13594: PUSH
13595: EMPTY
13596: LIST
13597: LIST
13598: PUSH
13599: LD_INT 94
13601: PUSH
13602: LD_INT 114
13604: PUSH
13605: EMPTY
13606: LIST
13607: LIST
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: PPUSH
13615: CALL 105954 0 1
13619: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13620: LD_ADDR_EXP 94
13624: PUSH
13625: EMPTY
13626: ST_TO_ADDR
// for i = 1 to Difficulty do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: DOUBLE
13633: LD_INT 1
13635: DEC
13636: ST_TO_ADDR
13637: LD_OWVAR 67
13641: PUSH
13642: FOR_TO
13643: IFFALSE 13801
// begin InitHc ;
13645: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13649: LD_INT 0
13651: PPUSH
13652: LD_INT 8
13654: PPUSH
13655: CALL_OW 381
// un := CreateHuman ;
13659: LD_ADDR_VAR 0 2
13663: PUSH
13664: CALL_OW 44
13668: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13669: LD_VAR 0 2
13673: PPUSH
13674: LD_INT 258
13676: PPUSH
13677: LD_INT 267
13679: PPUSH
13680: LD_INT 4
13682: PPUSH
13683: LD_INT 0
13685: PPUSH
13686: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13690: LD_ADDR_EXP 94
13694: PUSH
13695: LD_EXP 94
13699: PUSH
13700: LD_VAR 0 2
13704: UNION
13705: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PUSH
13716: LD_VAR 0 1
13720: ARRAY
13721: PUSH
13722: LD_INT 1
13724: ARRAY
13725: PPUSH
13726: LD_VAR 0 3
13730: PUSH
13731: LD_VAR 0 1
13735: ARRAY
13736: PUSH
13737: LD_INT 2
13739: ARRAY
13740: PPUSH
13741: LD_INT 4
13743: PPUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13751: LD_VAR 0 2
13755: PPUSH
13756: LD_VAR 0 3
13760: PUSH
13761: LD_VAR 0 1
13765: ARRAY
13766: PUSH
13767: LD_INT 1
13769: ARRAY
13770: PPUSH
13771: LD_VAR 0 3
13775: PUSH
13776: LD_VAR 0 1
13780: ARRAY
13781: PUSH
13782: LD_INT 2
13784: ARRAY
13785: PPUSH
13786: CALL_OW 171
// AddComInvisible ( un ) ;
13790: LD_VAR 0 2
13794: PPUSH
13795: CALL_OW 212
// end ;
13799: GO 13642
13801: POP
13802: POP
// repeat wait ( 0 0$20 ) ;
13803: LD_INT 700
13805: PPUSH
13806: CALL_OW 67
// for i in allianceSpecialForce do
13810: LD_ADDR_VAR 0 1
13814: PUSH
13815: LD_EXP 94
13819: PUSH
13820: FOR_IN
13821: IFFALSE 14060
// begin if IsInvisible ( i ) then
13823: LD_VAR 0 1
13827: PPUSH
13828: CALL_OW 571
13832: IFFALSE 14029
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_INT 22
13841: PUSH
13842: LD_INT 1
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: PUSH
13849: LD_INT 50
13851: PUSH
13852: EMPTY
13853: LIST
13854: PUSH
13855: LD_INT 56
13857: PUSH
13858: EMPTY
13859: LIST
13860: PUSH
13861: LD_INT 91
13863: PUSH
13864: LD_VAR 0 1
13868: PUSH
13869: LD_INT 25
13871: PUSH
13872: LD_INT 30
13874: PUSH
13875: LD_INT 35
13877: PUSH
13878: LD_INT 40
13880: PUSH
13881: EMPTY
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: PUSH
13887: LD_OWVAR 67
13891: ARRAY
13892: PUSH
13893: EMPTY
13894: LIST
13895: LIST
13896: LIST
13897: PUSH
13898: LD_INT 2
13900: PUSH
13901: LD_INT 25
13903: PUSH
13904: LD_INT 1
13906: PUSH
13907: EMPTY
13908: LIST
13909: LIST
13910: PUSH
13911: LD_INT 25
13913: PUSH
13914: LD_INT 2
13916: PUSH
13917: EMPTY
13918: LIST
13919: LIST
13920: PUSH
13921: LD_INT 25
13923: PUSH
13924: LD_INT 3
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: PUSH
13931: LD_INT 25
13933: PUSH
13934: LD_INT 4
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PUSH
13941: LD_INT 25
13943: PUSH
13944: LD_INT 5
13946: PUSH
13947: EMPTY
13948: LIST
13949: LIST
13950: PUSH
13951: LD_INT 25
13953: PUSH
13954: LD_INT 8
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: PPUSH
13977: CALL_OW 69
13981: ST_TO_ADDR
// if not tmp then
13982: LD_VAR 0 3
13986: NOT
13987: IFFALSE 13991
// continue ;
13989: GO 13820
// if Prob ( 30 * Difficulty ) then
13991: LD_INT 30
13993: PUSH
13994: LD_OWVAR 67
13998: MUL
13999: PPUSH
14000: CALL_OW 13
14004: IFFALSE 14029
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14006: LD_VAR 0 3
14010: PUSH
14011: LD_INT 1
14013: PPUSH
14014: LD_VAR 0 3
14018: PPUSH
14019: CALL_OW 12
14023: ARRAY
14024: PPUSH
14025: CALL 33799 0 1
// end ; if IsDead ( i ) then
14029: LD_VAR 0 1
14033: PPUSH
14034: CALL_OW 301
14038: IFFALSE 14058
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_EXP 94
14049: PUSH
14050: LD_VAR 0 1
14054: DIFF
14055: ST_TO_ADDR
// continue ;
14056: GO 13820
// end ; end ;
14058: GO 13820
14060: POP
14061: POP
// until allianceDestroyed or not allianceSpecialForce ;
14062: LD_EXP 23
14066: PUSH
14067: LD_EXP 94
14071: NOT
14072: OR
14073: IFFALSE 13803
// end ;
14075: PPOPN 3
14077: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14078: LD_EXP 31
14082: PUSH
14083: LD_INT 22
14085: PUSH
14086: LD_INT 1
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: PUSH
14093: LD_INT 2
14095: PUSH
14096: LD_INT 35
14098: PUSH
14099: LD_INT 8
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: PUSH
14106: LD_INT 34
14108: PUSH
14109: LD_INT 8
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: LIST
14120: PUSH
14121: EMPTY
14122: LIST
14123: LIST
14124: PPUSH
14125: CALL_OW 69
14129: AND
14130: IFFALSE 14530
14132: GO 14134
14134: DISABLE
14135: LD_INT 0
14137: PPUSH
14138: PPUSH
14139: PPUSH
14140: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14141: LD_ADDR_VAR 0 1
14145: PUSH
14146: DOUBLE
14147: LD_INT 1
14149: DEC
14150: ST_TO_ADDR
14151: LD_INT 6
14153: PUSH
14154: LD_INT 8
14156: PUSH
14157: LD_INT 10
14159: PUSH
14160: LD_INT 12
14162: PUSH
14163: EMPTY
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: PUSH
14169: LD_OWVAR 67
14173: ARRAY
14174: PUSH
14175: FOR_TO
14176: IFFALSE 14368
// begin uc_side := 7 ;
14178: LD_ADDR_OWVAR 20
14182: PUSH
14183: LD_INT 7
14185: ST_TO_ADDR
// uc_nation := 1 ;
14186: LD_ADDR_OWVAR 21
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14194: LD_INT 5
14196: PPUSH
14197: LD_INT 3
14199: PPUSH
14200: LD_INT 2
14202: PUSH
14203: LD_INT 3
14205: PUSH
14206: EMPTY
14207: LIST
14208: LIST
14209: PUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 2
14215: PPUSH
14216: CALL_OW 12
14220: ARRAY
14221: PPUSH
14222: LD_INT 6
14224: PUSH
14225: LD_INT 9
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: LD_INT 1
14234: PPUSH
14235: LD_INT 2
14237: PPUSH
14238: CALL_OW 12
14242: ARRAY
14243: PPUSH
14244: LD_INT 100
14246: PPUSH
14247: CALL 73397 0 5
// un := CreateVehicle ;
14251: LD_ADDR_VAR 0 2
14255: PUSH
14256: CALL_OW 45
14260: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14261: LD_VAR 0 2
14265: PPUSH
14266: LD_INT 4
14268: PPUSH
14269: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14273: LD_VAR 0 2
14277: PPUSH
14278: LD_INT 307
14280: PPUSH
14281: LD_INT 219
14283: PPUSH
14284: LD_INT 6
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 50
// if GetControl ( un ) = control_remote then
14294: LD_VAR 0 2
14298: PPUSH
14299: CALL_OW 263
14303: PUSH
14304: LD_INT 2
14306: EQUAL
14307: IFFALSE 14318
// Connect ( un ) ;
14309: LD_VAR 0 2
14313: PPUSH
14314: CALL 76488 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14318: LD_VAR 0 2
14322: PPUSH
14323: LD_INT 124
14325: PPUSH
14326: LD_INT 92
14328: PPUSH
14329: LD_INT 12
14331: PPUSH
14332: LD_INT 1
14334: PPUSH
14335: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_VAR 0 3
14348: PPUSH
14349: LD_VAR 0 2
14353: PPUSH
14354: CALL 105849 0 2
14358: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14359: LD_INT 10
14361: PPUSH
14362: CALL_OW 67
// end ;
14366: GO 14175
14368: POP
14369: POP
// repeat wait ( 0 0$2 ) ;
14370: LD_INT 70
14372: PPUSH
14373: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14377: LD_ADDR_VAR 0 4
14381: PUSH
14382: LD_INT 22
14384: PUSH
14385: LD_INT 1
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PUSH
14392: LD_INT 34
14394: PUSH
14395: LD_INT 8
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: PUSH
14402: EMPTY
14403: LIST
14404: LIST
14405: PPUSH
14406: CALL_OW 69
14410: ST_TO_ADDR
// if not e then
14411: LD_VAR 0 4
14415: NOT
14416: IFFALSE 14452
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14418: LD_ADDR_VAR 0 4
14422: PUSH
14423: LD_INT 22
14425: PUSH
14426: LD_INT 1
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: LD_INT 21
14435: PUSH
14436: LD_INT 2
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: EMPTY
14444: LIST
14445: LIST
14446: PPUSH
14447: CALL_OW 69
14451: ST_TO_ADDR
// for i in tmp do
14452: LD_ADDR_VAR 0 1
14456: PUSH
14457: LD_VAR 0 3
14461: PUSH
14462: FOR_IN
14463: IFFALSE 14521
// if not IsOK ( i ) then
14465: LD_VAR 0 1
14469: PPUSH
14470: CALL_OW 302
14474: NOT
14475: IFFALSE 14495
// tmp := tmp diff i else
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: LD_VAR 0 3
14486: PUSH
14487: LD_VAR 0 1
14491: DIFF
14492: ST_TO_ADDR
14493: GO 14519
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14495: LD_VAR 0 1
14499: PPUSH
14500: LD_VAR 0 4
14504: PPUSH
14505: LD_VAR 0 1
14509: PPUSH
14510: CALL_OW 74
14514: PPUSH
14515: CALL_OW 115
14519: GO 14462
14521: POP
14522: POP
// until not tmp ;
14523: LD_VAR 0 3
14527: NOT
14528: IFFALSE 14370
// end ;
14530: PPOPN 4
14532: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
14533: LD_EXP 23
14537: NOT
14538: PUSH
14539: LD_EXP 31
14543: AND
14544: IFFALSE 15494
14546: GO 14548
14548: DISABLE
14549: LD_INT 0
14551: PPUSH
14552: PPUSH
14553: PPUSH
14554: PPUSH
// begin enable ;
14555: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14556: LD_INT 22
14558: PUSH
14559: LD_INT 7
14561: PUSH
14562: EMPTY
14563: LIST
14564: LIST
14565: PUSH
14566: LD_INT 30
14568: PUSH
14569: LD_INT 3
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: PUSH
14576: EMPTY
14577: LIST
14578: LIST
14579: PPUSH
14580: CALL_OW 69
14584: NOT
14585: IFFALSE 14589
// exit ;
14587: GO 15494
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
14589: LD_ADDR_VAR 0 4
14593: PUSH
14594: LD_INT 22
14596: PUSH
14597: LD_INT 7
14599: PUSH
14600: EMPTY
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 30
14606: PUSH
14607: LD_INT 34
14609: PUSH
14610: EMPTY
14611: LIST
14612: LIST
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PPUSH
14618: CALL_OW 69
14622: ST_TO_ADDR
// if Prob ( 40 ) then
14623: LD_INT 40
14625: PPUSH
14626: CALL_OW 13
14630: IFFALSE 14776
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
14632: LD_INT 1
14634: PPUSH
14635: LD_INT 5
14637: PUSH
14638: LD_INT 3
14640: PUSH
14641: LD_INT 2
14643: PUSH
14644: LD_INT 6
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: PUSH
14653: LD_INT 5
14655: PUSH
14656: LD_INT 3
14658: PUSH
14659: LD_INT 2
14661: PUSH
14662: LD_INT 6
14664: PUSH
14665: EMPTY
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: PUSH
14671: LD_INT 5
14673: PUSH
14674: LD_INT 3
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: LD_INT 6
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: PUSH
14689: LD_INT 5
14691: PUSH
14692: LD_INT 3
14694: PUSH
14695: LD_INT 2
14697: PUSH
14698: LD_INT 9
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: PUSH
14707: LD_INT 24
14709: PUSH
14710: LD_INT 3
14712: PUSH
14713: LD_INT 3
14715: PUSH
14716: LD_INT 45
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: PUSH
14725: LD_INT 24
14727: PUSH
14728: LD_INT 3
14730: PUSH
14731: LD_INT 3
14733: PUSH
14734: LD_INT 47
14736: PUSH
14737: EMPTY
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: PUSH
14743: LD_INT 24
14745: PUSH
14746: LD_INT 3
14748: PUSH
14749: LD_INT 3
14751: PUSH
14752: LD_INT 45
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: PUSH
14761: EMPTY
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: PPUSH
14770: CALL 62131 0 2
// end else
14774: GO 14918
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14776: LD_INT 1
14778: PPUSH
14779: LD_INT 24
14781: PUSH
14782: LD_INT 3
14784: PUSH
14785: LD_INT 3
14787: PUSH
14788: LD_INT 47
14790: PUSH
14791: EMPTY
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: PUSH
14797: LD_INT 24
14799: PUSH
14800: LD_INT 3
14802: PUSH
14803: LD_INT 3
14805: PUSH
14806: LD_INT 47
14808: PUSH
14809: EMPTY
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: PUSH
14815: LD_INT 5
14817: PUSH
14818: LD_INT 3
14820: PUSH
14821: LD_INT 2
14823: PUSH
14824: LD_INT 9
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: PUSH
14833: LD_INT 5
14835: PUSH
14836: LD_INT 3
14838: PUSH
14839: LD_INT 2
14841: PUSH
14842: LD_INT 9
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 5
14853: PUSH
14854: LD_INT 3
14856: PUSH
14857: LD_INT 2
14859: PUSH
14860: LD_INT 9
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: PUSH
14869: LD_INT 24
14871: PUSH
14872: LD_INT 1
14874: PUSH
14875: LD_INT 3
14877: PUSH
14878: LD_INT 45
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: LIST
14885: LIST
14886: PUSH
14887: LD_INT 24
14889: PUSH
14890: LD_INT 1
14892: PUSH
14893: LD_INT 3
14895: PUSH
14896: LD_INT 45
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: LIST
14903: LIST
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: PPUSH
14914: CALL 62131 0 2
// end ; repeat wait ( 0 0$1 ) ;
14918: LD_INT 35
14920: PPUSH
14921: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14925: LD_INT 1
14927: PPUSH
14928: LD_INT 1
14930: PPUSH
14931: CALL 63549 0 2
14935: PUSH
14936: LD_INT 7
14938: GREATEREQUAL
14939: IFFALSE 14918
// wait ( 0 0$10 ) ;
14941: LD_INT 350
14943: PPUSH
14944: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14948: LD_ADDR_VAR 0 2
14952: PUSH
14953: LD_INT 1
14955: PPUSH
14956: LD_INT 1
14958: PPUSH
14959: CALL 63549 0 2
14963: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14964: LD_ADDR_EXP 119
14968: PUSH
14969: LD_EXP 119
14973: PPUSH
14974: LD_INT 1
14976: PPUSH
14977: LD_EXP 119
14981: PUSH
14982: LD_INT 1
14984: ARRAY
14985: PUSH
14986: LD_VAR 0 2
14990: DIFF
14991: PPUSH
14992: CALL_OW 1
14996: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14997: LD_ADDR_VAR 0 3
15001: PUSH
15002: LD_INT 0
15004: PPUSH
15005: LD_INT 1
15007: PPUSH
15008: CALL_OW 12
15012: ST_TO_ADDR
// if target then
15013: LD_VAR 0 3
15017: IFFALSE 15183
// begin for i in tmp do
15019: LD_ADDR_VAR 0 1
15023: PUSH
15024: LD_VAR 0 2
15028: PUSH
15029: FOR_IN
15030: IFFALSE 15055
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15032: LD_VAR 0 1
15036: PPUSH
15037: LD_INT 179
15039: PPUSH
15040: LD_INT 209
15042: PPUSH
15043: LD_INT 8
15045: PPUSH
15046: LD_INT 1
15048: PPUSH
15049: CALL_OW 483
15053: GO 15029
15055: POP
15056: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15057: LD_ADDR_VAR 0 2
15061: PUSH
15062: LD_VAR 0 2
15066: PPUSH
15067: LD_INT 24
15069: PUSH
15070: LD_INT 250
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PPUSH
15077: CALL_OW 72
15081: ST_TO_ADDR
// for i in tmp do
15082: LD_ADDR_VAR 0 1
15086: PUSH
15087: LD_VAR 0 2
15091: PUSH
15092: FOR_IN
15093: IFFALSE 15133
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15095: LD_VAR 0 1
15099: PPUSH
15100: LD_INT 179
15102: PPUSH
15103: LD_INT 209
15105: PPUSH
15106: CALL_OW 297
15110: PUSH
15111: LD_INT 9
15113: GREATER
15114: IFFALSE 15131
// ComMoveXY ( i , 179 , 209 ) ;
15116: LD_VAR 0 1
15120: PPUSH
15121: LD_INT 179
15123: PPUSH
15124: LD_INT 209
15126: PPUSH
15127: CALL_OW 111
15131: GO 15092
15133: POP
15134: POP
// wait ( 0 0$1 ) ;
15135: LD_INT 35
15137: PPUSH
15138: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_INT 92
15149: PUSH
15150: LD_INT 179
15152: PUSH
15153: LD_INT 209
15155: PUSH
15156: LD_INT 9
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: PPUSH
15165: CALL_OW 72
15169: PUSH
15170: LD_VAR 0 2
15174: PUSH
15175: LD_INT 1
15177: MINUS
15178: GREATEREQUAL
15179: IFFALSE 15057
// end else
15181: GO 15345
// begin for i in tmp do
15183: LD_ADDR_VAR 0 1
15187: PUSH
15188: LD_VAR 0 2
15192: PUSH
15193: FOR_IN
15194: IFFALSE 15219
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15196: LD_VAR 0 1
15200: PPUSH
15201: LD_INT 285
15203: PPUSH
15204: LD_INT 163
15206: PPUSH
15207: LD_INT 8
15209: PPUSH
15210: LD_INT 1
15212: PPUSH
15213: CALL_OW 483
15217: GO 15193
15219: POP
15220: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15221: LD_ADDR_VAR 0 2
15225: PUSH
15226: LD_VAR 0 2
15230: PPUSH
15231: LD_INT 24
15233: PUSH
15234: LD_INT 250
15236: PUSH
15237: EMPTY
15238: LIST
15239: LIST
15240: PPUSH
15241: CALL_OW 72
15245: ST_TO_ADDR
// for i in tmp do
15246: LD_ADDR_VAR 0 1
15250: PUSH
15251: LD_VAR 0 2
15255: PUSH
15256: FOR_IN
15257: IFFALSE 15297
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15259: LD_VAR 0 1
15263: PPUSH
15264: LD_INT 285
15266: PPUSH
15267: LD_INT 163
15269: PPUSH
15270: CALL_OW 297
15274: PUSH
15275: LD_INT 9
15277: GREATER
15278: IFFALSE 15295
// ComMoveXY ( i , 285 , 163 ) ;
15280: LD_VAR 0 1
15284: PPUSH
15285: LD_INT 285
15287: PPUSH
15288: LD_INT 163
15290: PPUSH
15291: CALL_OW 111
15295: GO 15256
15297: POP
15298: POP
// wait ( 0 0$1 ) ;
15299: LD_INT 35
15301: PPUSH
15302: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
15306: LD_VAR 0 2
15310: PPUSH
15311: LD_INT 92
15313: PUSH
15314: LD_INT 285
15316: PUSH
15317: LD_INT 163
15319: PUSH
15320: LD_INT 9
15322: PUSH
15323: EMPTY
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: PPUSH
15329: CALL_OW 72
15333: PUSH
15334: LD_VAR 0 2
15338: PUSH
15339: LD_INT 1
15341: MINUS
15342: GREATEREQUAL
15343: IFFALSE 15221
// end ; repeat wait ( 0 0$1 ) ;
15345: LD_INT 35
15347: PPUSH
15348: CALL_OW 67
// for i in tmp do
15352: LD_ADDR_VAR 0 1
15356: PUSH
15357: LD_VAR 0 2
15361: PUSH
15362: FOR_IN
15363: IFFALSE 15485
// if GetLives ( i ) > 251 then
15365: LD_VAR 0 1
15369: PPUSH
15370: CALL_OW 256
15374: PUSH
15375: LD_INT 251
15377: GREATER
15378: IFFALSE 15467
// begin if GetWeapon ( i ) = ru_time_lapser then
15380: LD_VAR 0 1
15384: PPUSH
15385: CALL_OW 264
15389: PUSH
15390: LD_INT 49
15392: EQUAL
15393: IFFALSE 15431
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15395: LD_VAR 0 1
15399: PPUSH
15400: LD_INT 81
15402: PUSH
15403: LD_INT 7
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: PPUSH
15410: CALL_OW 69
15414: PPUSH
15415: LD_VAR 0 1
15419: PPUSH
15420: CALL_OW 74
15424: PPUSH
15425: CALL_OW 112
15429: GO 15465
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15431: LD_VAR 0 1
15435: PPUSH
15436: LD_INT 81
15438: PUSH
15439: LD_INT 7
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PPUSH
15446: CALL_OW 69
15450: PPUSH
15451: LD_VAR 0 1
15455: PPUSH
15456: CALL_OW 74
15460: PPUSH
15461: CALL_OW 115
// end else
15465: GO 15483
// tmp := tmp diff i ;
15467: LD_ADDR_VAR 0 2
15471: PUSH
15472: LD_VAR 0 2
15476: PUSH
15477: LD_VAR 0 1
15481: DIFF
15482: ST_TO_ADDR
15483: GO 15362
15485: POP
15486: POP
// until not tmp ;
15487: LD_VAR 0 2
15491: NOT
15492: IFFALSE 15345
// end ;
15494: PPOPN 4
15496: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
15497: LD_EXP 31
15501: PUSH
15502: LD_EXP 77
15506: PPUSH
15507: CALL_OW 302
15511: AND
15512: PUSH
15513: LD_OWVAR 67
15517: PUSH
15518: LD_INT 2
15520: GREATER
15521: AND
15522: IFFALSE 15622
15524: GO 15526
15526: DISABLE
// begin enable ;
15527: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
15528: LD_EXP 77
15532: PPUSH
15533: LD_INT 245
15535: PPUSH
15536: LD_INT 234
15538: PPUSH
15539: CALL_OW 297
15543: PUSH
15544: LD_INT 6
15546: GREATER
15547: IFFALSE 15566
// ComMoveXY ( Roth , 245 , 234 ) else
15549: LD_EXP 77
15553: PPUSH
15554: LD_INT 245
15556: PPUSH
15557: LD_INT 234
15559: PPUSH
15560: CALL_OW 111
15564: GO 15622
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
15566: LD_EXP 77
15570: PPUSH
15571: LD_INT 259
15573: PUSH
15574: LD_INT 235
15576: PUSH
15577: EMPTY
15578: LIST
15579: LIST
15580: PUSH
15581: LD_INT 252
15583: PUSH
15584: LD_INT 209
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: PUSH
15591: LD_INT 275
15593: PUSH
15594: LD_INT 235
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: LIST
15605: PUSH
15606: LD_INT 1
15608: PPUSH
15609: LD_INT 3
15611: PPUSH
15612: CALL_OW 12
15616: ARRAY
15617: PPUSH
15618: CALL 109851 0 2
// end ; end_of_file
15622: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
15623: LD_INT 0
15625: PPUSH
15626: PPUSH
15627: PPUSH
15628: PPUSH
// missionStage := 13 ;
15629: LD_ADDR_EXP 15
15633: PUSH
15634: LD_INT 13
15636: ST_TO_ADDR
// uc_side := 2 ;
15637: LD_ADDR_OWVAR 20
15641: PUSH
15642: LD_INT 2
15644: ST_TO_ADDR
// uc_nation := 2 ;
15645: LD_ADDR_OWVAR 21
15649: PUSH
15650: LD_INT 2
15652: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
15653: LD_ADDR_EXP 95
15657: PUSH
15658: LD_STRING Omar
15660: PPUSH
15661: CALL_OW 25
15665: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
15666: LD_EXP 95
15670: PPUSH
15671: LD_INT 4
15673: PPUSH
15674: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
15678: LD_EXP 95
15682: PPUSH
15683: LD_INT 242
15685: PPUSH
15686: LD_INT 75
15688: PPUSH
15689: LD_INT 0
15691: PPUSH
15692: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
15696: LD_ADDR_EXP 96
15700: PUSH
15701: LD_STRING Heike
15703: PPUSH
15704: CALL_OW 25
15708: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
15709: LD_INT 14
15711: PPUSH
15712: LD_INT 3
15714: PPUSH
15715: LD_INT 1
15717: PPUSH
15718: LD_INT 27
15720: PPUSH
15721: LD_INT 100
15723: PPUSH
15724: CALL 73397 0 5
// veh := CreateVehicle ;
15728: LD_ADDR_VAR 0 3
15732: PUSH
15733: CALL_OW 45
15737: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
15738: LD_VAR 0 3
15742: PPUSH
15743: LD_INT 2
15745: NEG
15746: PPUSH
15747: CALL_OW 242
// SetDir ( veh , 4 ) ;
15751: LD_VAR 0 3
15755: PPUSH
15756: LD_INT 4
15758: PPUSH
15759: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
15763: LD_VAR 0 3
15767: PPUSH
15768: LD_INT 241
15770: PPUSH
15771: LD_INT 72
15773: PPUSH
15774: LD_INT 0
15776: PPUSH
15777: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
15781: LD_EXP 96
15785: PPUSH
15786: LD_VAR 0 3
15790: PPUSH
15791: CALL_OW 52
// if KhatamStatus then
15795: LD_EXP 8
15799: IFFALSE 15862
// begin Khatam := NewCharacter ( Khatam ) ;
15801: LD_ADDR_EXP 97
15805: PUSH
15806: LD_STRING Khatam
15808: PPUSH
15809: CALL_OW 25
15813: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
15814: LD_EXP 97
15818: PPUSH
15819: LD_INT 245
15821: PPUSH
15822: LD_INT 78
15824: PPUSH
15825: LD_INT 3
15827: PPUSH
15828: LD_INT 0
15830: PPUSH
15831: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
15835: LD_EXP 97
15839: PPUSH
15840: LD_INT 4
15842: PPUSH
15843: LD_INT 10
15845: PPUSH
15846: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
15850: LD_EXP 97
15854: PPUSH
15855: LD_INT 4
15857: PPUSH
15858: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
15862: LD_ADDR_VAR 0 2
15866: PUSH
15867: DOUBLE
15868: LD_INT 1
15870: DEC
15871: ST_TO_ADDR
15872: LD_INT 2
15874: PUSH
15875: LD_INT 2
15877: PUSH
15878: LD_INT 3
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: PUSH
15890: LD_OWVAR 67
15894: ARRAY
15895: PUSH
15896: FOR_TO
15897: IFFALSE 15963
// begin PrepareScientist ( false , 6 + Difficulty ) ;
15899: LD_INT 0
15901: PPUSH
15902: LD_INT 6
15904: PUSH
15905: LD_OWVAR 67
15909: PLUS
15910: PPUSH
15911: CALL_OW 384
// un := CreateHuman ;
15915: LD_ADDR_VAR 0 4
15919: PUSH
15920: CALL_OW 44
15924: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
15925: LD_VAR 0 4
15929: PPUSH
15930: LD_INT 28
15932: PUSH
15933: LD_INT 29
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: LD_VAR 0 2
15944: PUSH
15945: LD_INT 2
15947: MOD
15948: PUSH
15949: LD_INT 1
15951: PLUS
15952: ARRAY
15953: PPUSH
15954: LD_INT 0
15956: PPUSH
15957: CALL_OW 49
// end ;
15961: GO 15896
15963: POP
15964: POP
// for i = 1 to 6 do
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: DOUBLE
15971: LD_INT 1
15973: DEC
15974: ST_TO_ADDR
15975: LD_INT 6
15977: PUSH
15978: FOR_TO
15979: IFFALSE 16024
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15981: LD_INT 0
15983: PPUSH
15984: LD_INT 6
15986: PUSH
15987: LD_OWVAR 67
15991: PLUS
15992: PPUSH
15993: CALL_OW 381
// un := CreateHuman ;
15997: LD_ADDR_VAR 0 4
16001: PUSH
16002: CALL_OW 44
16006: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16007: LD_VAR 0 4
16011: PPUSH
16012: LD_INT 32
16014: PPUSH
16015: LD_INT 0
16017: PPUSH
16018: CALL_OW 49
// end ;
16022: GO 15978
16024: POP
16025: POP
// for i = 1 to 3 do
16026: LD_ADDR_VAR 0 2
16030: PUSH
16031: DOUBLE
16032: LD_INT 1
16034: DEC
16035: ST_TO_ADDR
16036: LD_INT 3
16038: PUSH
16039: FOR_TO
16040: IFFALSE 16088
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16042: LD_INT 0
16044: PPUSH
16045: LD_INT 8
16047: PPUSH
16048: LD_INT 6
16050: PUSH
16051: LD_OWVAR 67
16055: PLUS
16056: PPUSH
16057: CALL_OW 380
// un := CreateHuman ;
16061: LD_ADDR_VAR 0 4
16065: PUSH
16066: CALL_OW 44
16070: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16071: LD_VAR 0 4
16075: PPUSH
16076: LD_INT 32
16078: PPUSH
16079: LD_INT 0
16081: PPUSH
16082: CALL_OW 49
// end ;
16086: GO 16039
16088: POP
16089: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16090: LD_ADDR_VAR 0 2
16094: PUSH
16095: DOUBLE
16096: LD_INT 1
16098: DEC
16099: ST_TO_ADDR
16100: LD_INT 2
16102: PUSH
16103: LD_INT 3
16105: PUSH
16106: LD_INT 4
16108: PUSH
16109: LD_INT 4
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: LIST
16117: PUSH
16118: LD_OWVAR 67
16122: ARRAY
16123: PUSH
16124: FOR_TO
16125: IFFALSE 16215
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16127: LD_INT 14
16129: PPUSH
16130: LD_INT 2
16132: PPUSH
16133: LD_INT 1
16135: PPUSH
16136: LD_INT 28
16138: PPUSH
16139: LD_INT 80
16141: PPUSH
16142: CALL 73397 0 5
// veh := CreateVehicle ;
16146: LD_ADDR_VAR 0 3
16150: PUSH
16151: CALL_OW 45
16155: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16156: LD_VAR 0 3
16160: PPUSH
16161: LD_INT 3
16163: PPUSH
16164: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16168: LD_VAR 0 3
16172: PPUSH
16173: LD_INT 29
16175: PPUSH
16176: LD_INT 0
16178: PPUSH
16179: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16183: LD_INT 0
16185: PPUSH
16186: LD_INT 6
16188: PUSH
16189: LD_OWVAR 67
16193: PLUS
16194: PPUSH
16195: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16199: CALL_OW 44
16203: PPUSH
16204: LD_VAR 0 3
16208: PPUSH
16209: CALL_OW 52
// end ;
16213: GO 16124
16215: POP
16216: POP
// for i = 1 to 5 + Difficulty do
16217: LD_ADDR_VAR 0 2
16221: PUSH
16222: DOUBLE
16223: LD_INT 1
16225: DEC
16226: ST_TO_ADDR
16227: LD_INT 5
16229: PUSH
16230: LD_OWVAR 67
16234: PLUS
16235: PUSH
16236: FOR_TO
16237: IFFALSE 16364
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16239: LD_INT 14
16241: PPUSH
16242: LD_INT 1
16244: PPUSH
16245: LD_INT 3
16247: PPUSH
16248: CALL_OW 12
16252: PPUSH
16253: LD_INT 1
16255: PPUSH
16256: LD_INT 28
16258: PUSH
16259: LD_INT 26
16261: PUSH
16262: LD_INT 27
16264: PUSH
16265: LD_INT 25
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: LIST
16272: LIST
16273: PUSH
16274: LD_VAR 0 2
16278: PUSH
16279: LD_INT 4
16281: MOD
16282: PUSH
16283: LD_INT 1
16285: PLUS
16286: ARRAY
16287: PPUSH
16288: LD_INT 80
16290: PPUSH
16291: CALL 73397 0 5
// veh := CreateVehicle ;
16295: LD_ADDR_VAR 0 3
16299: PUSH
16300: CALL_OW 45
16304: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16305: LD_VAR 0 3
16309: PPUSH
16310: LD_INT 4
16312: PPUSH
16313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16317: LD_VAR 0 3
16321: PPUSH
16322: LD_INT 28
16324: PPUSH
16325: LD_INT 0
16327: PPUSH
16328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16332: LD_INT 0
16334: PPUSH
16335: LD_INT 6
16337: PUSH
16338: LD_OWVAR 67
16342: PLUS
16343: PPUSH
16344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16348: CALL_OW 44
16352: PPUSH
16353: LD_VAR 0 3
16357: PPUSH
16358: CALL_OW 52
// end ;
16362: GO 16236
16364: POP
16365: POP
// for i = 1 to Difficulty do
16366: LD_ADDR_VAR 0 2
16370: PUSH
16371: DOUBLE
16372: LD_INT 1
16374: DEC
16375: ST_TO_ADDR
16376: LD_OWVAR 67
16380: PUSH
16381: FOR_TO
16382: IFFALSE 16442
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16384: LD_INT 14
16386: PPUSH
16387: LD_INT 3
16389: PPUSH
16390: LD_INT 5
16392: PPUSH
16393: LD_INT 29
16395: PPUSH
16396: LD_INT 80
16398: PPUSH
16399: CALL 73397 0 5
// veh := CreateVehicle ;
16403: LD_ADDR_VAR 0 3
16407: PUSH
16408: CALL_OW 45
16412: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16413: LD_VAR 0 3
16417: PPUSH
16418: LD_INT 4
16420: PPUSH
16421: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16425: LD_VAR 0 3
16429: PPUSH
16430: LD_INT 28
16432: PPUSH
16433: LD_INT 0
16435: PPUSH
16436: CALL_OW 49
// end ;
16440: GO 16381
16442: POP
16443: POP
// end ;
16444: LD_VAR 0 1
16448: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16449: LD_INT 22
16451: PUSH
16452: LD_INT 2
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PPUSH
16459: CALL_OW 69
16463: IFFALSE 16842
16465: GO 16467
16467: DISABLE
16468: LD_INT 0
16470: PPUSH
16471: PPUSH
16472: PPUSH
16473: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
16474: LD_ADDR_VAR 0 3
16478: PUSH
16479: LD_INT 22
16481: PUSH
16482: LD_INT 2
16484: PUSH
16485: EMPTY
16486: LIST
16487: LIST
16488: PUSH
16489: LD_INT 25
16491: PUSH
16492: LD_INT 4
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PPUSH
16503: CALL_OW 69
16507: PUSH
16508: LD_EXP 97
16512: DIFF
16513: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
16514: LD_ADDR_VAR 0 2
16518: PUSH
16519: LD_INT 22
16521: PUSH
16522: LD_INT 2
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 97
16538: PUSH
16539: LD_VAR 0 3
16543: UNION
16544: DIFF
16545: ST_TO_ADDR
// if Khatam then
16546: LD_EXP 97
16550: IFFALSE 16567
// ComMoveXY ( Khatam , 211 , 92 ) ;
16552: LD_EXP 97
16556: PPUSH
16557: LD_INT 211
16559: PPUSH
16560: LD_INT 92
16562: PPUSH
16563: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
16567: LD_INT 197
16569: PPUSH
16570: LD_INT 80
16572: PPUSH
16573: LD_INT 2
16575: PPUSH
16576: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
16580: LD_INT 213
16582: PPUSH
16583: LD_INT 90
16585: PPUSH
16586: LD_INT 2
16588: PPUSH
16589: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
16593: LD_INT 215
16595: PPUSH
16596: LD_INT 129
16598: PPUSH
16599: LD_INT 2
16601: PPUSH
16602: CALL_OW 441
// if sci then
16606: LD_VAR 0 3
16610: IFFALSE 16631
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
16612: LD_VAR 0 3
16616: PUSH
16617: LD_INT 1
16619: ARRAY
16620: PPUSH
16621: LD_INT 197
16623: PPUSH
16624: LD_INT 80
16626: PPUSH
16627: CALL_OW 158
// if sci > 1 then
16631: LD_VAR 0 3
16635: PUSH
16636: LD_INT 1
16638: GREATER
16639: IFFALSE 16660
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
16641: LD_VAR 0 3
16645: PUSH
16646: LD_INT 2
16648: ARRAY
16649: PPUSH
16650: LD_INT 213
16652: PPUSH
16653: LD_INT 90
16655: PPUSH
16656: CALL_OW 158
// if sci > 2 then
16660: LD_VAR 0 3
16664: PUSH
16665: LD_INT 2
16667: GREATER
16668: IFFALSE 16689
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
16670: LD_VAR 0 3
16674: PUSH
16675: LD_INT 3
16677: ARRAY
16678: PPUSH
16679: LD_INT 215
16681: PPUSH
16682: LD_INT 129
16684: PPUSH
16685: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
16689: LD_VAR 0 2
16693: PPUSH
16694: LD_INT 195
16696: PPUSH
16697: LD_INT 102
16699: PPUSH
16700: CALL_OW 114
// wait ( 0 0$5 ) ;
16704: LD_INT 175
16706: PPUSH
16707: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
16711: LD_INT 70
16713: PPUSH
16714: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
16718: LD_ADDR_VAR 0 4
16722: PUSH
16723: LD_INT 92
16725: PUSH
16726: LD_INT 195
16728: PUSH
16729: LD_INT 102
16731: PUSH
16732: LD_INT 36
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: LIST
16739: LIST
16740: PUSH
16741: LD_INT 22
16743: PUSH
16744: LD_INT 1
16746: PUSH
16747: EMPTY
16748: LIST
16749: LIST
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: PPUSH
16755: CALL_OW 69
16759: ST_TO_ADDR
// for i in tmp do
16760: LD_ADDR_VAR 0 1
16764: PUSH
16765: LD_VAR 0 2
16769: PUSH
16770: FOR_IN
16771: IFFALSE 16822
// if enemy then
16773: LD_VAR 0 4
16777: IFFALSE 16805
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16779: LD_VAR 0 1
16783: PPUSH
16784: LD_VAR 0 4
16788: PPUSH
16789: LD_VAR 0 1
16793: PPUSH
16794: CALL_OW 74
16798: PPUSH
16799: CALL_OW 115
16803: GO 16820
// ComAgressiveMove ( i , 195 , 102 ) ;
16805: LD_VAR 0 1
16809: PPUSH
16810: LD_INT 195
16812: PPUSH
16813: LD_INT 102
16815: PPUSH
16816: CALL_OW 114
16820: GO 16770
16822: POP
16823: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
16824: LD_VAR 0 2
16828: PPUSH
16829: LD_INT 50
16831: PUSH
16832: EMPTY
16833: LIST
16834: PPUSH
16835: CALL_OW 72
16839: NOT
16840: IFFALSE 16711
// end ; end_of_file
16842: PPOPN 4
16844: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
16845: LD_INT 0
16847: PPUSH
16848: PPUSH
16849: PPUSH
16850: PPUSH
16851: PPUSH
16852: PPUSH
16853: PPUSH
16854: PPUSH
16855: PPUSH
// Video ( true ) ;
16856: LD_INT 1
16858: PPUSH
16859: CALL 105821 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
16863: LD_ADDR_VAR 0 5
16867: PUSH
16868: LD_INT 7
16870: PPUSH
16871: LD_INT 0
16873: PPUSH
16874: CALL_OW 517
16878: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
16879: LD_ADDR_VAR 0 2
16883: PUSH
16884: DOUBLE
16885: LD_INT 1
16887: DEC
16888: ST_TO_ADDR
16889: LD_VAR 0 5
16893: PUSH
16894: LD_INT 1
16896: ARRAY
16897: PUSH
16898: FOR_TO
16899: IFFALSE 16944
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
16901: LD_VAR 0 5
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: PUSH
16910: LD_VAR 0 2
16914: ARRAY
16915: PPUSH
16916: LD_VAR 0 5
16920: PUSH
16921: LD_INT 2
16923: ARRAY
16924: PUSH
16925: LD_VAR 0 2
16929: ARRAY
16930: PPUSH
16931: LD_INT 1
16933: PPUSH
16934: LD_INT 15
16936: NEG
16937: PPUSH
16938: CALL 105735 0 4
16942: GO 16898
16944: POP
16945: POP
// CenterNowOnUnits ( Powell ) ;
16946: LD_EXP 60
16950: PPUSH
16951: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
16955: LD_ADDR_VAR 0 5
16959: PUSH
16960: LD_EXP 58
16964: PUSH
16965: EMPTY
16966: LIST
16967: ST_TO_ADDR
// if GirlNewVeh then
16968: LD_EXP 59
16972: IFFALSE 16990
// tmp := tmp ^ GirlNewVeh ;
16974: LD_ADDR_VAR 0 5
16978: PUSH
16979: LD_VAR 0 5
16983: PUSH
16984: LD_EXP 59
16988: ADD
16989: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16990: LD_VAR 0 5
16994: PPUSH
16995: LD_INT 60
16997: PPUSH
16998: LD_INT 109
17000: PPUSH
17001: CALL_OW 111
// if KappaStatus then
17005: LD_EXP 2
17009: IFFALSE 17061
// begin Say ( JMM , D1nT-JMM-1 ) ;
17011: LD_EXP 40
17015: PPUSH
17016: LD_STRING D1nT-JMM-1
17018: PPUSH
17019: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17023: LD_EXP 60
17027: PPUSH
17028: LD_STRING D1T-Pow-1
17030: PPUSH
17031: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17035: LD_EXP 40
17039: PPUSH
17040: LD_STRING D1T-JMM-2
17042: PPUSH
17043: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17047: LD_EXP 60
17051: PPUSH
17052: LD_STRING D1T-Pow-2
17054: PPUSH
17055: CALL_OW 88
// end else
17059: GO 17267
// if JMMGirlStatus then
17061: LD_EXP 6
17065: IFFALSE 17210
// begin Say ( JMM , D1T-JMM-1 ) ;
17067: LD_EXP 40
17071: PPUSH
17072: LD_STRING D1T-JMM-1
17074: PPUSH
17075: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17079: LD_EXP 60
17083: PPUSH
17084: LD_STRING D1T-Pow-1
17086: PPUSH
17087: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17091: LD_EXP 40
17095: PPUSH
17096: LD_STRING D1T-JMM-3
17098: PPUSH
17099: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17103: LD_EXP 60
17107: PPUSH
17108: LD_STRING D1T-Pow-3
17110: PPUSH
17111: CALL_OW 88
// if JMMGirl then
17115: LD_EXP 7
17119: IFFALSE 17208
// begin case JMMGirl of 1 :
17121: LD_EXP 7
17125: PUSH
17126: LD_INT 1
17128: DOUBLE
17129: EQUAL
17130: IFTRUE 17134
17132: GO 17149
17134: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17135: LD_EXP 41
17139: PPUSH
17140: LD_STRING D1T-Joan-3
17142: PPUSH
17143: CALL_OW 88
17147: GO 17196
17149: LD_INT 2
17151: DOUBLE
17152: EQUAL
17153: IFTRUE 17157
17155: GO 17172
17157: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17158: LD_EXP 43
17162: PPUSH
17163: LD_STRING D1T-Lisa-3
17165: PPUSH
17166: CALL_OW 88
17170: GO 17196
17172: LD_INT 3
17174: DOUBLE
17175: EQUAL
17176: IFTRUE 17180
17178: GO 17195
17180: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17181: LD_EXP 55
17185: PPUSH
17186: LD_STRING D1T-Con-3
17188: PPUSH
17189: CALL_OW 88
17193: GO 17196
17195: POP
// Say ( Powell , D1T-Pow-4 ) ;
17196: LD_EXP 60
17200: PPUSH
17201: LD_STRING D1T-Pow-4
17203: PPUSH
17204: CALL_OW 88
// end ; end else
17208: GO 17267
// if not FastEnd then
17210: LD_EXP 11
17214: NOT
17215: IFFALSE 17243
// begin Say ( JMM , D1T-JMM-4 ) ;
17217: LD_EXP 40
17221: PPUSH
17222: LD_STRING D1T-JMM-4
17224: PPUSH
17225: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17229: LD_EXP 60
17233: PPUSH
17234: LD_STRING D1T-Pow-5
17236: PPUSH
17237: CALL_OW 88
// end else
17241: GO 17267
// begin Say ( JMM , D1nT-JMM-1 ) ;
17243: LD_EXP 40
17247: PPUSH
17248: LD_STRING D1nT-JMM-1
17250: PPUSH
17251: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17255: LD_EXP 60
17259: PPUSH
17260: LD_STRING D1nT-Pow-1
17262: PPUSH
17263: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17267: LD_INT 3
17269: PPUSH
17270: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17274: LD_EXP 58
17278: PPUSH
17279: CALL_OW 314
17283: NOT
17284: IFFALSE 17267
// ComExitVehicle ( JMM ) ;
17286: LD_EXP 40
17290: PPUSH
17291: CALL_OW 121
// repeat wait ( 3 ) ;
17295: LD_INT 3
17297: PPUSH
17298: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17302: LD_EXP 40
17306: PPUSH
17307: CALL_OW 310
17311: NOT
17312: IFFALSE 17295
// ComMoveXY ( JMM , 60 , 94 ) ;
17314: LD_EXP 40
17318: PPUSH
17319: LD_INT 60
17321: PPUSH
17322: LD_INT 94
17324: PPUSH
17325: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17329: LD_EXP 40
17333: PPUSH
17334: LD_EXP 60
17338: PPUSH
17339: CALL_OW 179
// if Joan then
17343: LD_EXP 41
17347: IFFALSE 17401
// begin ComExitVehicle ( Joan ) ;
17349: LD_EXP 41
17353: PPUSH
17354: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17358: LD_EXP 41
17362: PPUSH
17363: LD_INT 35
17365: PPUSH
17366: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17370: LD_EXP 41
17374: PPUSH
17375: LD_INT 65
17377: PPUSH
17378: LD_INT 104
17380: PPUSH
17381: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17385: LD_EXP 41
17389: PPUSH
17390: LD_EXP 40
17394: PPUSH
17395: CALL_OW 179
// end else
17399: GO 17535
// if Lisa and JMMGirl = 2 then
17401: LD_EXP 43
17405: PUSH
17406: LD_EXP 7
17410: PUSH
17411: LD_INT 2
17413: EQUAL
17414: AND
17415: IFFALSE 17469
// begin ComExitVehicle ( Lisa ) ;
17417: LD_EXP 43
17421: PPUSH
17422: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17426: LD_EXP 43
17430: PPUSH
17431: LD_INT 35
17433: PPUSH
17434: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17438: LD_EXP 43
17442: PPUSH
17443: LD_INT 65
17445: PPUSH
17446: LD_INT 104
17448: PPUSH
17449: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17453: LD_EXP 43
17457: PPUSH
17458: LD_EXP 40
17462: PPUSH
17463: CALL_OW 179
// end else
17467: GO 17535
// if Connie and JMMGirl = 3 then
17469: LD_EXP 55
17473: PUSH
17474: LD_EXP 7
17478: PUSH
17479: LD_INT 3
17481: EQUAL
17482: AND
17483: IFFALSE 17535
// begin ComExitVehicle ( Connie ) ;
17485: LD_EXP 55
17489: PPUSH
17490: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
17494: LD_EXP 55
17498: PPUSH
17499: LD_INT 35
17501: PPUSH
17502: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
17506: LD_EXP 55
17510: PPUSH
17511: LD_INT 65
17513: PPUSH
17514: LD_INT 104
17516: PPUSH
17517: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
17521: LD_EXP 55
17525: PPUSH
17526: LD_EXP 40
17530: PPUSH
17531: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
17535: LD_INT 35
17537: PPUSH
17538: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
17542: LD_EXP 40
17546: PPUSH
17547: LD_EXP 60
17551: PPUSH
17552: CALL_OW 296
17556: PUSH
17557: LD_INT 8
17559: LESS
17560: IFFALSE 17535
// wait ( 0 0$0.5 ) ;
17562: LD_INT 18
17564: PPUSH
17565: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
17569: LD_EXP 40
17573: PPUSH
17574: LD_STRING D1-JMM-1
17576: PPUSH
17577: CALL_OW 88
// async ;
17581: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
17582: LD_EXP 60
17586: PPUSH
17587: LD_STRING D1-Pow-1
17589: PPUSH
17590: CALL_OW 88
// if not dialogue_skipped then
17594: LD_OWVAR 59
17598: NOT
17599: IFFALSE 17608
// wait ( 0 0$2 ) ;
17601: LD_INT 70
17603: PPUSH
17604: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
17608: LD_INT 170
17610: PPUSH
17611: LD_INT 99
17613: PPUSH
17614: LD_INT 1
17616: PPUSH
17617: LD_INT 6
17619: NEG
17620: PPUSH
17621: CALL 105735 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
17625: LD_INT 174
17627: PPUSH
17628: LD_INT 115
17630: PPUSH
17631: LD_INT 1
17633: PPUSH
17634: LD_INT 6
17636: NEG
17637: PPUSH
17638: CALL 105735 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
17642: LD_INT 169
17644: PPUSH
17645: LD_INT 71
17647: PPUSH
17648: LD_INT 1
17650: PPUSH
17651: LD_INT 6
17653: NEG
17654: PPUSH
17655: CALL 105735 0 4
// if not dialogue_skipped then
17659: LD_OWVAR 59
17663: NOT
17664: IFFALSE 17683
// begin CenterOnXY ( 170 , 99 ) ;
17666: LD_INT 170
17668: PPUSH
17669: LD_INT 99
17671: PPUSH
17672: CALL_OW 84
// wait ( 0 0$2.3 ) ;
17676: LD_INT 80
17678: PPUSH
17679: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
17683: LD_INT 75
17685: PPUSH
17686: LD_INT 53
17688: PPUSH
17689: LD_INT 1
17691: PPUSH
17692: LD_INT 9
17694: NEG
17695: PPUSH
17696: CALL 105735 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
17700: LD_INT 54
17702: PPUSH
17703: LD_INT 42
17705: PPUSH
17706: LD_INT 1
17708: PPUSH
17709: LD_INT 9
17711: NEG
17712: PPUSH
17713: CALL 105735 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
17717: LD_INT 62
17719: PPUSH
17720: LD_INT 51
17722: PPUSH
17723: LD_INT 1
17725: PPUSH
17726: LD_INT 9
17728: NEG
17729: PPUSH
17730: CALL 105735 0 4
// if not dialogue_skipped then
17734: LD_OWVAR 59
17738: NOT
17739: IFFALSE 17758
// begin CenterOnXY ( 75 , 53 ) ;
17741: LD_INT 75
17743: PPUSH
17744: LD_INT 53
17746: PPUSH
17747: CALL_OW 84
// wait ( 0 0$4 ) ;
17751: LD_INT 140
17753: PPUSH
17754: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
17758: LD_EXP 60
17762: PPUSH
17763: CALL_OW 87
// if not dialogue_skipped then
17767: LD_OWVAR 59
17771: NOT
17772: IFFALSE 17781
// wait ( 0 0$2 ) ;
17774: LD_INT 70
17776: PPUSH
17777: CALL_OW 67
// sync ;
17781: SYNC
// Say ( JMM , D1-JMM-2 ) ;
17782: LD_EXP 40
17786: PPUSH
17787: LD_STRING D1-JMM-2
17789: PPUSH
17790: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
17794: LD_EXP 60
17798: PPUSH
17799: LD_STRING D1-Pow-2
17801: PPUSH
17802: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
17806: LD_EXP 40
17810: PPUSH
17811: LD_STRING D1-JMM-3
17813: PPUSH
17814: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
17818: LD_EXP 60
17822: PPUSH
17823: LD_STRING D1-Pow-3
17825: PPUSH
17826: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
17830: LD_EXP 40
17834: PPUSH
17835: LD_STRING D1-JMM-4
17837: PPUSH
17838: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
17842: LD_EXP 60
17846: PPUSH
17847: LD_STRING D1-Pow-4
17849: PPUSH
17850: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
17854: LD_EXP 40
17858: PPUSH
17859: LD_STRING D1-JMM-5
17861: PPUSH
17862: CALL_OW 88
// async ;
17866: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
17867: LD_EXP 60
17871: PPUSH
17872: LD_STRING D1-Pow-5
17874: PPUSH
17875: CALL_OW 88
// if not dialogue_skipped then
17879: LD_OWVAR 59
17883: NOT
17884: IFFALSE 17893
// wait ( 0 0$3.6 ) ;
17886: LD_INT 126
17888: PPUSH
17889: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
17893: LD_INT 134
17895: PPUSH
17896: LD_INT 210
17898: PPUSH
17899: LD_INT 1
17901: PPUSH
17902: LD_INT 11
17904: NEG
17905: PPUSH
17906: CALL 105735 0 4
// if not dialogue_skipped then
17910: LD_OWVAR 59
17914: NOT
17915: IFFALSE 17934
// begin CenterOnXY ( 134 , 210 ) ;
17917: LD_INT 134
17919: PPUSH
17920: LD_INT 210
17922: PPUSH
17923: CALL_OW 84
// wait ( 0 0$2 ) ;
17927: LD_INT 70
17929: PPUSH
17930: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
17934: LD_INT 101
17936: PPUSH
17937: LD_INT 159
17939: PPUSH
17940: LD_INT 1
17942: PPUSH
17943: LD_INT 10
17945: NEG
17946: PPUSH
17947: CALL 105735 0 4
// if not dialogue_skipped then
17951: LD_OWVAR 59
17955: NOT
17956: IFFALSE 17975
// begin CenterOnXY ( 101 , 159 ) ;
17958: LD_INT 101
17960: PPUSH
17961: LD_INT 159
17963: PPUSH
17964: CALL_OW 84
// wait ( 0 0$2 ) ;
17968: LD_INT 70
17970: PPUSH
17971: CALL_OW 67
// end ; sync ;
17975: SYNC
// CenterNowOnUnits ( Powell ) ;
17976: LD_EXP 60
17980: PPUSH
17981: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17985: LD_ADDR_VAR 0 6
17989: PUSH
17990: LD_INT 1
17992: PUSH
17993: LD_INT 2
17995: PUSH
17996: LD_INT 3
17998: PUSH
17999: LD_INT 4
18001: PUSH
18002: LD_INT 5
18004: PUSH
18005: LD_INT 6
18007: PUSH
18008: EMPTY
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: ST_TO_ADDR
// if not dialogue_skipped then
18016: LD_OWVAR 59
18020: NOT
18021: IFFALSE 18190
// begin game_speed := 4 ;
18023: LD_ADDR_OWVAR 65
18027: PUSH
18028: LD_INT 4
18030: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18031: LD_INT 210
18033: PPUSH
18034: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18038: LD_ADDR_VAR 0 7
18042: PUSH
18043: LD_STRING Q1
18045: PPUSH
18046: LD_VAR 0 6
18050: PPUSH
18051: CALL_OW 98
18055: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18056: LD_ADDR_VAR 0 7
18060: PUSH
18061: LD_STRING Q1
18063: PPUSH
18064: LD_VAR 0 6
18068: PPUSH
18069: CALL_OW 98
18073: ST_TO_ADDR
// options := options diff dec ;
18074: LD_ADDR_VAR 0 6
18078: PUSH
18079: LD_VAR 0 6
18083: PUSH
18084: LD_VAR 0 7
18088: DIFF
18089: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18090: LD_VAR 0 7
18094: PPUSH
18095: LD_VAR 0 6
18099: PPUSH
18100: CALL 19754 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18104: LD_VAR 0 7
18108: PUSH
18109: LD_INT 5
18111: PUSH
18112: LD_INT 6
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: IN
18119: PUSH
18120: LD_VAR 0 6
18124: PUSH
18125: LD_INT 2
18127: EQUAL
18128: OR
18129: IFFALSE 18056
// if not ( dec in [ 5 , 6 ] ) then
18131: LD_VAR 0 7
18135: PUSH
18136: LD_INT 5
18138: PUSH
18139: LD_INT 6
18141: PUSH
18142: EMPTY
18143: LIST
18144: LIST
18145: IN
18146: NOT
18147: IFFALSE 18190
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18149: LD_ADDR_VAR 0 7
18153: PUSH
18154: LD_STRING Q1a
18156: PPUSH
18157: LD_INT 1
18159: PUSH
18160: LD_INT 2
18162: PUSH
18163: EMPTY
18164: LIST
18165: LIST
18166: PPUSH
18167: CALL_OW 98
18171: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18172: LD_VAR 0 7
18176: PUSH
18177: LD_INT 4
18179: PLUS
18180: PPUSH
18181: LD_VAR 0 6
18185: PPUSH
18186: CALL 19754 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18190: LD_INT 81
18192: PPUSH
18193: LD_INT 127
18195: PPUSH
18196: CALL_OW 84
// amount := 8 ;
18200: LD_ADDR_VAR 0 8
18204: PUSH
18205: LD_INT 8
18207: ST_TO_ADDR
// macmilan_squad := [ ] ;
18208: LD_ADDR_VAR 0 9
18212: PUSH
18213: EMPTY
18214: ST_TO_ADDR
// if vip < amount then
18215: LD_EXP 61
18219: PUSH
18220: LD_VAR 0 8
18224: LESS
18225: IFFALSE 18269
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18227: LD_ADDR_VAR 0 5
18231: PUSH
18232: LD_EXP 61
18236: PUSH
18237: LD_INT 22
18239: PUSH
18240: LD_INT 4
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PUSH
18247: LD_INT 21
18249: PUSH
18250: LD_INT 1
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PPUSH
18261: CALL_OW 69
18265: UNION
18266: ST_TO_ADDR
18267: GO 18279
// tmp := vip ;
18269: LD_ADDR_VAR 0 5
18273: PUSH
18274: LD_EXP 61
18278: ST_TO_ADDR
// tmp := tmp diff Powell ;
18279: LD_ADDR_VAR 0 5
18283: PUSH
18284: LD_VAR 0 5
18288: PUSH
18289: LD_EXP 60
18293: DIFF
18294: ST_TO_ADDR
// if tmp < amount then
18295: LD_VAR 0 5
18299: PUSH
18300: LD_VAR 0 8
18304: LESS
18305: IFFALSE 18317
// amount := tmp ;
18307: LD_ADDR_VAR 0 8
18311: PUSH
18312: LD_VAR 0 5
18316: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18317: LD_VAR 0 5
18321: PUSH
18322: LD_INT 1
18324: ARRAY
18325: PPUSH
18326: CALL_OW 257
18330: PUSH
18331: LD_INT 2
18333: NONEQUAL
18334: IFFALSE 18432
// begin if IsInUnit ( tmp [ 1 ] ) then
18336: LD_VAR 0 5
18340: PUSH
18341: LD_INT 1
18343: ARRAY
18344: PPUSH
18345: CALL_OW 310
18349: IFFALSE 18364
// ComExitBuilding ( tmp [ 1 ] ) ;
18351: LD_VAR 0 5
18355: PUSH
18356: LD_INT 1
18358: ARRAY
18359: PPUSH
18360: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18364: LD_INT 387
18366: PPUSH
18367: CALL_OW 313
18371: PUSH
18372: LD_INT 6
18374: EQUAL
18375: IFFALSE 18400
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18377: LD_INT 387
18379: PPUSH
18380: CALL_OW 313
18384: PUSH
18385: LD_INT 1
18387: ARRAY
18388: PPUSH
18389: CALL_OW 122
// wait ( 3 ) ;
18393: LD_INT 3
18395: PPUSH
18396: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18400: LD_VAR 0 5
18404: PUSH
18405: LD_INT 1
18407: ARRAY
18408: PPUSH
18409: LD_INT 387
18411: PPUSH
18412: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18416: LD_VAR 0 5
18420: PUSH
18421: LD_INT 1
18423: ARRAY
18424: PPUSH
18425: LD_INT 2
18427: PPUSH
18428: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18432: LD_EXP 40
18436: PPUSH
18437: LD_INT 82
18439: PPUSH
18440: LD_INT 129
18442: PPUSH
18443: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18447: LD_EXP 40
18451: PPUSH
18452: LD_EXP 60
18456: PPUSH
18457: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18461: LD_INT 22
18463: PUSH
18464: LD_INT 1
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: PPUSH
18471: CALL_OW 69
18475: PUSH
18476: LD_EXP 40
18480: DIFF
18481: PPUSH
18482: LD_INT 84
18484: PPUSH
18485: LD_INT 128
18487: PPUSH
18488: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
18492: LD_INT 22
18494: PUSH
18495: LD_INT 1
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PPUSH
18502: CALL_OW 69
18506: PUSH
18507: LD_EXP 40
18511: DIFF
18512: PPUSH
18513: LD_EXP 40
18517: PPUSH
18518: CALL_OW 179
// for i = 1 to amount do
18522: LD_ADDR_VAR 0 2
18526: PUSH
18527: DOUBLE
18528: LD_INT 1
18530: DEC
18531: ST_TO_ADDR
18532: LD_VAR 0 8
18536: PUSH
18537: FOR_TO
18538: IFFALSE 18706
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
18540: LD_ADDR_VAR 0 9
18544: PUSH
18545: LD_VAR 0 9
18549: PUSH
18550: LD_VAR 0 5
18554: PUSH
18555: LD_VAR 0 2
18559: ARRAY
18560: ADD
18561: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
18562: LD_VAR 0 5
18566: PUSH
18567: LD_VAR 0 2
18571: ARRAY
18572: PPUSH
18573: CALL_OW 310
18577: IFFALSE 18594
// AddComExitBuilding ( tmp [ i ] ) ;
18579: LD_VAR 0 5
18583: PUSH
18584: LD_VAR 0 2
18588: ARRAY
18589: PPUSH
18590: CALL_OW 182
// if i = 2 and JMMNewVeh then
18594: LD_VAR 0 2
18598: PUSH
18599: LD_INT 2
18601: EQUAL
18602: PUSH
18603: LD_EXP 58
18607: AND
18608: IFFALSE 18666
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
18610: LD_VAR 0 5
18614: PUSH
18615: LD_VAR 0 2
18619: ARRAY
18620: PPUSH
18621: LD_EXP 58
18625: PPUSH
18626: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
18630: LD_VAR 0 5
18634: PUSH
18635: LD_VAR 0 2
18639: ARRAY
18640: PPUSH
18641: LD_INT 86
18643: PPUSH
18644: LD_INT 133
18646: PPUSH
18647: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
18651: LD_VAR 0 5
18655: PUSH
18656: LD_VAR 0 2
18660: ARRAY
18661: PPUSH
18662: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
18666: LD_VAR 0 5
18670: PUSH
18671: LD_VAR 0 2
18675: ARRAY
18676: PPUSH
18677: LD_INT 8
18679: PPUSH
18680: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
18684: LD_VAR 0 5
18688: PUSH
18689: LD_VAR 0 2
18693: ARRAY
18694: PPUSH
18695: LD_EXP 40
18699: PPUSH
18700: CALL_OW 179
// end ;
18704: GO 18537
18706: POP
18707: POP
// if GirlNewVeh then
18708: LD_EXP 59
18712: IFFALSE 18726
// SetSide ( GirlNewVeh , 4 ) ;
18714: LD_EXP 59
18718: PPUSH
18719: LD_INT 4
18721: PPUSH
18722: CALL_OW 235
// if Mike then
18726: LD_EXP 57
18730: IFFALSE 18767
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
18732: LD_ADDR_VAR 0 9
18736: PUSH
18737: LD_VAR 0 9
18741: PPUSH
18742: LD_EXP 57
18746: PPUSH
18747: CALL 105849 0 2
18751: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
18752: LD_EXP 57
18756: PPUSH
18757: LD_INT 86
18759: PPUSH
18760: LD_INT 133
18762: PPUSH
18763: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
18767: LD_INT 35
18769: PPUSH
18770: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
18774: LD_VAR 0 9
18778: PPUSH
18779: LD_INT 95
18781: PUSH
18782: LD_INT 9
18784: PUSH
18785: EMPTY
18786: LIST
18787: LIST
18788: PPUSH
18789: CALL_OW 72
18793: PUSH
18794: LD_INT 0
18796: EQUAL
18797: PUSH
18798: LD_EXP 40
18802: PPUSH
18803: LD_INT 9
18805: PPUSH
18806: CALL_OW 308
18810: NOT
18811: AND
18812: IFFALSE 18767
// wait ( 0 0$2 ) ;
18814: LD_INT 70
18816: PPUSH
18817: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
18821: LD_VAR 0 9
18825: PPUSH
18826: LD_INT 1
18828: PPUSH
18829: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
18833: LD_INT 21
18835: PUSH
18836: LD_INT 2
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: PUSH
18843: LD_INT 92
18845: PUSH
18846: LD_INT 83
18848: PUSH
18849: LD_INT 130
18851: PUSH
18852: LD_INT 10
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PPUSH
18865: CALL_OW 69
18869: PPUSH
18870: LD_INT 1
18872: PPUSH
18873: CALL_OW 235
// tick := 0 ;
18877: LD_ADDR_OWVAR 1
18881: PUSH
18882: LD_INT 0
18884: ST_TO_ADDR
// Video ( false ) ;
18885: LD_INT 0
18887: PPUSH
18888: CALL 105821 0 1
// ChangeMissionObjectives ( M1 ) ;
18892: LD_STRING M1
18894: PPUSH
18895: CALL_OW 337
// SaveForQuickRestart ;
18899: CALL_OW 22
// missionStart := true ;
18903: LD_ADDR_EXP 13
18907: PUSH
18908: LD_INT 1
18910: ST_TO_ADDR
// missionStage := 2 ;
18911: LD_ADDR_EXP 15
18915: PUSH
18916: LD_INT 2
18918: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18919: LD_INT 35
18921: PPUSH
18922: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
18926: LD_ADDR_VAR 0 5
18930: PUSH
18931: LD_INT 22
18933: PUSH
18934: LD_INT 4
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: PUSH
18941: LD_INT 21
18943: PUSH
18944: LD_INT 1
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: EMPTY
18952: LIST
18953: LIST
18954: PPUSH
18955: CALL_OW 69
18959: PUSH
18960: LD_EXP 60
18964: DIFF
18965: ST_TO_ADDR
// if not tmp then
18966: LD_VAR 0 5
18970: NOT
18971: IFFALSE 18986
// tmp := [ Powell ] ;
18973: LD_ADDR_VAR 0 5
18977: PUSH
18978: LD_EXP 60
18982: PUSH
18983: EMPTY
18984: LIST
18985: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
18986: LD_ADDR_VAR 0 4
18990: PUSH
18991: LD_INT 22
18993: PUSH
18994: LD_INT 4
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: PUSH
19001: LD_INT 34
19003: PUSH
19004: LD_INT 12
19006: PUSH
19007: EMPTY
19008: LIST
19009: LIST
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PPUSH
19015: CALL_OW 69
19019: PUSH
19020: LD_INT 1
19022: ARRAY
19023: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19024: LD_VAR 0 5
19028: PUSH
19029: LD_INT 1
19031: ARRAY
19032: PPUSH
19033: CALL_OW 310
19037: IFFALSE 19052
// ComExitBuilding ( tmp [ 1 ] ) ;
19039: LD_VAR 0 5
19043: PUSH
19044: LD_INT 1
19046: ARRAY
19047: PPUSH
19048: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19052: LD_VAR 0 5
19056: PUSH
19057: LD_INT 1
19059: ARRAY
19060: PPUSH
19061: LD_VAR 0 4
19065: PPUSH
19066: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19070: LD_VAR 0 5
19074: PUSH
19075: LD_INT 1
19077: ARRAY
19078: PPUSH
19079: LD_INT 80
19081: PPUSH
19082: LD_INT 136
19084: PPUSH
19085: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19089: LD_VAR 0 5
19093: PUSH
19094: LD_INT 1
19096: ARRAY
19097: PPUSH
19098: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19102: LD_VAR 0 5
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_INT 59
19113: PPUSH
19114: LD_INT 112
19116: PPUSH
19117: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19121: LD_VAR 0 5
19125: PUSH
19126: LD_INT 1
19128: ARRAY
19129: PPUSH
19130: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19134: LD_EXP 41
19138: PUSH
19139: LD_EXP 41
19143: PPUSH
19144: CALL_OW 255
19148: PUSH
19149: LD_INT 1
19151: EQUAL
19152: AND
19153: IFFALSE 19179
// begin Say ( Joan , D3W-Joan-1 ) ;
19155: LD_EXP 41
19159: PPUSH
19160: LD_STRING D3W-Joan-1
19162: PPUSH
19163: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19167: LD_EXP 40
19171: PPUSH
19172: LD_STRING D3W-JMM-1
19174: PPUSH
19175: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19179: LD_EXP 43
19183: PUSH
19184: LD_EXP 43
19188: PPUSH
19189: CALL_OW 255
19193: PUSH
19194: LD_INT 1
19196: EQUAL
19197: AND
19198: PUSH
19199: LD_EXP 43
19203: PUSH
19204: LD_EXP 61
19208: IN
19209: NOT
19210: AND
19211: IFFALSE 19237
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19213: LD_EXP 43
19217: PPUSH
19218: LD_STRING D3W-Lisa-1
19220: PPUSH
19221: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19225: LD_EXP 40
19229: PPUSH
19230: LD_STRING D3W-JMM-1
19232: PPUSH
19233: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19237: LD_EXP 55
19241: PUSH
19242: LD_EXP 55
19246: PPUSH
19247: CALL_OW 255
19251: PUSH
19252: LD_INT 1
19254: EQUAL
19255: AND
19256: IFFALSE 19282
// begin Say ( Connie , D3W-Con-1 ) ;
19258: LD_EXP 55
19262: PPUSH
19263: LD_STRING D3W-Con-1
19265: PPUSH
19266: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19270: LD_EXP 40
19274: PPUSH
19275: LD_STRING D3W-JMM-1
19277: PPUSH
19278: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19282: LD_INT 18
19284: PPUSH
19285: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19289: LD_EXP 43
19293: PUSH
19294: LD_EXP 61
19298: IN
19299: PUSH
19300: LD_EXP 43
19304: PPUSH
19305: CALL_OW 255
19309: PUSH
19310: LD_INT 1
19312: EQUAL
19313: AND
19314: IFFALSE 19330
// Say ( Lisa , D3nW-Lisa-1 ) else
19316: LD_EXP 43
19320: PPUSH
19321: LD_STRING D3nW-Lisa-1
19323: PPUSH
19324: CALL_OW 88
19328: GO 19574
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19330: LD_EXP 46
19334: PUSH
19335: LD_EXP 61
19339: IN
19340: PUSH
19341: LD_EXP 46
19345: PPUSH
19346: CALL_OW 255
19350: PUSH
19351: LD_INT 1
19353: EQUAL
19354: AND
19355: IFFALSE 19371
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19357: LD_EXP 46
19361: PPUSH
19362: LD_STRING D3nW-Cyrus-1
19364: PPUSH
19365: CALL_OW 88
19369: GO 19574
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19371: LD_EXP 45
19375: PUSH
19376: LD_EXP 61
19380: IN
19381: PUSH
19382: LD_EXP 45
19386: PPUSH
19387: CALL_OW 255
19391: PUSH
19392: LD_INT 1
19394: EQUAL
19395: AND
19396: IFFALSE 19412
// Say ( Bobby , D3nW-Bobby-1 ) else
19398: LD_EXP 45
19402: PPUSH
19403: LD_STRING D3nW-Bobby-1
19405: PPUSH
19406: CALL_OW 88
19410: GO 19574
// if Gary in vip and GetSide ( Gary ) = 1 then
19412: LD_EXP 52
19416: PUSH
19417: LD_EXP 61
19421: IN
19422: PUSH
19423: LD_EXP 52
19427: PPUSH
19428: CALL_OW 255
19432: PUSH
19433: LD_INT 1
19435: EQUAL
19436: AND
19437: IFFALSE 19453
// Say ( Gary , D3nW-Gary-1 ) else
19439: LD_EXP 52
19443: PPUSH
19444: LD_STRING D3nW-Gary-1
19446: PPUSH
19447: CALL_OW 88
19451: GO 19574
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19453: LD_EXP 44
19457: PUSH
19458: LD_EXP 61
19462: IN
19463: PUSH
19464: LD_EXP 44
19468: PPUSH
19469: CALL_OW 255
19473: PUSH
19474: LD_INT 1
19476: EQUAL
19477: AND
19478: IFFALSE 19494
// Say ( Donaldson , D3nW-Don-1 ) else
19480: LD_EXP 44
19484: PPUSH
19485: LD_STRING D3nW-Don-1
19487: PPUSH
19488: CALL_OW 88
19492: GO 19574
// if Cornel in vip and GetSide ( Cornel ) = 1 then
19494: LD_EXP 51
19498: PUSH
19499: LD_EXP 61
19503: IN
19504: PUSH
19505: LD_EXP 51
19509: PPUSH
19510: CALL_OW 255
19514: PUSH
19515: LD_INT 1
19517: EQUAL
19518: AND
19519: IFFALSE 19535
// Say ( Cornel , D3nW-Corn-1 ) else
19521: LD_EXP 51
19525: PPUSH
19526: LD_STRING D3nW-Corn-1
19528: PPUSH
19529: CALL_OW 88
19533: GO 19574
// if Frank in vip and GetSide ( Frank ) = 1 then
19535: LD_EXP 53
19539: PUSH
19540: LD_EXP 61
19544: IN
19545: PUSH
19546: LD_EXP 53
19550: PPUSH
19551: CALL_OW 255
19555: PUSH
19556: LD_INT 1
19558: EQUAL
19559: AND
19560: IFFALSE 19574
// Say ( Frank , D3nW-Frank-1 ) ;
19562: LD_EXP 53
19566: PPUSH
19567: LD_STRING D3nW-Frank-1
19569: PPUSH
19570: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
19574: LD_EXP 61
19578: PPUSH
19579: LD_INT 22
19581: PUSH
19582: LD_INT 1
19584: PUSH
19585: EMPTY
19586: LIST
19587: LIST
19588: PPUSH
19589: CALL_OW 72
19593: IFFALSE 19619
// begin Say ( JMM , D3nW-JMM-1 ) ;
19595: LD_EXP 40
19599: PPUSH
19600: LD_STRING D3nW-JMM-1
19602: PPUSH
19603: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
19607: LD_EXP 40
19611: PPUSH
19612: LD_STRING D3nW-JMM-1a
19614: PPUSH
19615: CALL_OW 88
// end ; t := 0 0$00 ;
19619: LD_ADDR_VAR 0 3
19623: PUSH
19624: LD_INT 0
19626: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19627: LD_INT 35
19629: PPUSH
19630: CALL_OW 67
// t := t + 0 0$1 ;
19634: LD_ADDR_VAR 0 3
19638: PUSH
19639: LD_VAR 0 3
19643: PUSH
19644: LD_INT 35
19646: PLUS
19647: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
19648: LD_INT 59
19650: PPUSH
19651: LD_INT 112
19653: PPUSH
19654: CALL_OW 428
19658: PUSH
19659: LD_VAR 0 3
19663: PUSH
19664: LD_INT 2100
19666: GREATER
19667: OR
19668: IFFALSE 19627
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
19670: LD_ADDR_EXP 100
19674: PUSH
19675: LD_EXP 100
19679: PPUSH
19680: LD_INT 4
19682: PPUSH
19683: LD_INT 22
19685: PUSH
19686: LD_INT 4
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: PUSH
19693: LD_INT 23
19695: PUSH
19696: LD_INT 1
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_INT 3
19705: PUSH
19706: LD_INT 21
19708: PUSH
19709: LD_INT 2
19711: PUSH
19712: EMPTY
19713: LIST
19714: LIST
19715: PUSH
19716: EMPTY
19717: LIST
19718: LIST
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: LIST
19724: PPUSH
19725: CALL_OW 69
19729: PUSH
19730: LD_EXP 60
19734: DIFF
19735: PPUSH
19736: CALL_OW 1
19740: ST_TO_ADDR
// activeAttacks := true ;
19741: LD_ADDR_EXP 16
19745: PUSH
19746: LD_INT 1
19748: ST_TO_ADDR
// end ;
19749: LD_VAR 0 1
19753: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
19754: LD_INT 0
19756: PPUSH
// case question of 1 :
19757: LD_VAR 0 1
19761: PUSH
19762: LD_INT 1
19764: DOUBLE
19765: EQUAL
19766: IFTRUE 19770
19768: GO 19821
19770: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
19771: LD_EXP 40
19775: PPUSH
19776: LD_STRING D2Mot-JMM-1
19778: PPUSH
19779: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
19783: LD_EXP 60
19787: PPUSH
19788: LD_STRING D2Mot-Pow-1
19790: PPUSH
19791: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
19795: LD_EXP 40
19799: PPUSH
19800: LD_STRING D2Mot-JMM-2
19802: PPUSH
19803: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
19807: LD_EXP 60
19811: PPUSH
19812: LD_STRING D2Mot-Pow-2
19814: PPUSH
19815: CALL_OW 88
// end ; 2 :
19819: GO 20172
19821: LD_INT 2
19823: DOUBLE
19824: EQUAL
19825: IFTRUE 19829
19827: GO 19905
19829: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
19830: LD_EXP 40
19834: PPUSH
19835: LD_STRING D2Rus-JMM-1
19837: PPUSH
19838: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
19842: LD_EXP 60
19846: PPUSH
19847: LD_STRING D2Rus-Pow-1
19849: PPUSH
19850: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
19854: LD_EXP 40
19858: PPUSH
19859: LD_STRING D2Rus-JMM-2
19861: PPUSH
19862: CALL_OW 88
// if not ( 3 in list_of_q ) then
19866: LD_INT 3
19868: PUSH
19869: LD_VAR 0 2
19873: IN
19874: NOT
19875: IFFALSE 19891
// Say ( Powell , D2Rus-Pow-2 ) else
19877: LD_EXP 60
19881: PPUSH
19882: LD_STRING D2Rus-Pow-2
19884: PPUSH
19885: CALL_OW 88
19889: GO 19903
// Say ( Powell , D2Rus-Pow-2a ) ;
19891: LD_EXP 60
19895: PPUSH
19896: LD_STRING D2Rus-Pow-2a
19898: PPUSH
19899: CALL_OW 88
// end ; 3 :
19903: GO 20172
19905: LD_INT 3
19907: DOUBLE
19908: EQUAL
19909: IFTRUE 19913
19911: GO 19998
19913: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
19914: LD_EXP 40
19918: PPUSH
19919: LD_STRING D2Leg-JMM-1
19921: PPUSH
19922: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
19926: LD_EXP 60
19930: PPUSH
19931: LD_STRING D2Leg-Pow-1
19933: PPUSH
19934: CALL_OW 88
// if 2 in list_of_q then
19938: LD_INT 2
19940: PUSH
19941: LD_VAR 0 2
19945: IN
19946: IFFALSE 19972
// begin Say ( JMM , D2Leg-JMM-2 ) ;
19948: LD_EXP 40
19952: PPUSH
19953: LD_STRING D2Leg-JMM-2
19955: PPUSH
19956: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
19960: LD_EXP 60
19964: PPUSH
19965: LD_STRING D2Leg-Pow-2
19967: PPUSH
19968: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
19972: LD_EXP 40
19976: PPUSH
19977: LD_STRING D2Leg-JMM-3
19979: PPUSH
19980: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
19984: LD_EXP 60
19988: PPUSH
19989: LD_STRING D2Leg-Pow-3
19991: PPUSH
19992: CALL_OW 88
// end ; 4 :
19996: GO 20172
19998: LD_INT 4
20000: DOUBLE
20001: EQUAL
20002: IFTRUE 20006
20004: GO 20081
20006: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20007: LD_EXP 40
20011: PPUSH
20012: LD_STRING D2Ar-JMM-1
20014: PPUSH
20015: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20019: LD_EXP 60
20023: PPUSH
20024: LD_STRING D2Ar-Pow-1
20026: PPUSH
20027: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20031: LD_EXP 40
20035: PPUSH
20036: LD_STRING D2Ar-JMM-2
20038: PPUSH
20039: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20043: LD_EXP 60
20047: PPUSH
20048: LD_STRING D2Ar-Pow-2
20050: PPUSH
20051: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20055: LD_EXP 40
20059: PPUSH
20060: LD_STRING D2Ar-JMM-3
20062: PPUSH
20063: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20067: LD_EXP 60
20071: PPUSH
20072: LD_STRING D2Ar-Pow-3
20074: PPUSH
20075: CALL_OW 88
// end ; 5 :
20079: GO 20172
20081: LD_INT 5
20083: DOUBLE
20084: EQUAL
20085: IFTRUE 20089
20087: GO 20104
20089: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20090: LD_EXP 40
20094: PPUSH
20095: LD_STRING D2Conf-JMM-1
20097: PPUSH
20098: CALL_OW 88
20102: GO 20172
20104: LD_INT 6
20106: DOUBLE
20107: EQUAL
20108: IFTRUE 20112
20110: GO 20171
20112: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20113: LD_EXP 40
20117: PPUSH
20118: LD_STRING D2Com-JMM-1
20120: PPUSH
20121: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20125: LD_EXP 60
20129: PPUSH
20130: LD_STRING D2Com-Pow-1
20132: PPUSH
20133: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20137: LD_EXP 40
20141: PPUSH
20142: LD_STRING D2Com-JMM-2
20144: PPUSH
20145: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20149: LD_EXP 60
20153: PPUSH
20154: LD_STRING D2Com-Pow-2
20156: PPUSH
20157: CALL_OW 88
// powellAngerQuery := true ;
20161: LD_ADDR_EXP 36
20165: PUSH
20166: LD_INT 1
20168: ST_TO_ADDR
// end ; end ;
20169: GO 20172
20171: POP
// end ;
20172: LD_VAR 0 3
20176: RET
// every 0 0$5 trigger missionStart do var tmp ;
20177: LD_EXP 13
20181: IFFALSE 20464
20183: GO 20185
20185: DISABLE
20186: LD_INT 0
20188: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20189: LD_INT 35
20191: PPUSH
20192: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20196: LD_INT 14
20198: PPUSH
20199: LD_INT 22
20201: PUSH
20202: LD_INT 1
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PPUSH
20209: CALL_OW 70
20213: PUSH
20214: LD_EXP 15
20218: PUSH
20219: LD_INT 2
20221: PUSH
20222: LD_INT 3
20224: PUSH
20225: LD_INT 4
20227: PUSH
20228: LD_INT 5
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: LIST
20235: LIST
20236: IN
20237: AND
20238: IFFALSE 20454
// begin powellAnger := powellAnger + 1 ;
20240: LD_ADDR_EXP 17
20244: PUSH
20245: LD_EXP 17
20249: PUSH
20250: LD_INT 1
20252: PLUS
20253: ST_TO_ADDR
// Video ( true ) ;
20254: LD_INT 1
20256: PPUSH
20257: CALL 105821 0 1
// CenterNowOnUnits ( tmp ) ;
20261: LD_VAR 0 1
20265: PPUSH
20266: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20270: LD_INT 14
20272: PPUSH
20273: LD_INT 22
20275: PUSH
20276: LD_INT 1
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: PPUSH
20283: CALL_OW 70
20287: PPUSH
20288: LD_INT 86
20290: PPUSH
20291: LD_INT 133
20293: PPUSH
20294: CALL_OW 111
// async ;
20298: ASYNC
// case powellAnger of 1 :
20299: LD_EXP 17
20303: PUSH
20304: LD_INT 1
20306: DOUBLE
20307: EQUAL
20308: IFTRUE 20312
20310: GO 20327
20312: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20313: LD_EXP 60
20317: PPUSH
20318: LD_STRING DBack1-Pow-1
20320: PPUSH
20321: CALL_OW 88
20325: GO 20374
20327: LD_INT 2
20329: DOUBLE
20330: EQUAL
20331: IFTRUE 20335
20333: GO 20350
20335: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20336: LD_EXP 60
20340: PPUSH
20341: LD_STRING DBack2-Pow-1
20343: PPUSH
20344: CALL_OW 88
20348: GO 20374
20350: LD_INT 3
20352: DOUBLE
20353: EQUAL
20354: IFTRUE 20358
20356: GO 20373
20358: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20359: LD_EXP 60
20363: PPUSH
20364: LD_STRING DBack3-Pow-1
20366: PPUSH
20367: CALL_OW 88
20371: GO 20374
20373: POP
// sync ;
20374: SYNC
// repeat wait ( 0 0$1 ) ;
20375: LD_INT 35
20377: PPUSH
20378: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20382: LD_INT 14
20384: PPUSH
20385: LD_INT 22
20387: PUSH
20388: LD_INT 1
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: PPUSH
20395: CALL_OW 70
20399: PPUSH
20400: LD_INT 86
20402: PPUSH
20403: LD_INT 133
20405: PPUSH
20406: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
20410: LD_INT 14
20412: PPUSH
20413: LD_INT 22
20415: PUSH
20416: LD_INT 1
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PPUSH
20423: CALL_OW 70
20427: NOT
20428: IFFALSE 20375
// if powellAnger >= 3 then
20430: LD_EXP 17
20434: PUSH
20435: LD_INT 3
20437: GREATEREQUAL
20438: IFFALSE 20447
// YouLost ( Dismissed ) ;
20440: LD_STRING Dismissed
20442: PPUSH
20443: CALL_OW 104
// Video ( false ) ;
20447: LD_INT 0
20449: PPUSH
20450: CALL 105821 0 1
// end ; until missionStage > 5 ;
20454: LD_EXP 15
20458: PUSH
20459: LD_INT 5
20461: GREATER
20462: IFFALSE 20189
// end ;
20464: PPOPN 1
20466: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
20467: LD_EXP 13
20471: PUSH
20472: LD_INT 22
20474: PUSH
20475: LD_INT 4
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: LD_INT 21
20484: PUSH
20485: LD_INT 2
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PPUSH
20496: CALL_OW 69
20500: PUSH
20501: LD_INT 4
20503: GREATEREQUAL
20504: AND
20505: PUSH
20506: LD_EXP 15
20510: PUSH
20511: LD_INT 2
20513: EQUAL
20514: AND
20515: IFFALSE 22705
20517: GO 20519
20519: DISABLE
20520: LD_INT 0
20522: PPUSH
20523: PPUSH
20524: PPUSH
20525: PPUSH
20526: PPUSH
20527: PPUSH
20528: PPUSH
20529: PPUSH
20530: PPUSH
20531: PPUSH
// begin missionStage := 3 ;
20532: LD_ADDR_EXP 15
20536: PUSH
20537: LD_INT 3
20539: ST_TO_ADDR
// retreat := false ;
20540: LD_ADDR_VAR 0 4
20544: PUSH
20545: LD_INT 0
20547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
20548: LD_ADDR_VAR 0 5
20552: PUSH
20553: LD_INT 22
20555: PUSH
20556: LD_INT 4
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: LD_INT 30
20565: PUSH
20566: LD_INT 4
20568: PUSH
20569: EMPTY
20570: LIST
20571: LIST
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PPUSH
20577: CALL_OW 69
20581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20582: LD_ADDR_VAR 0 6
20586: PUSH
20587: LD_INT 22
20589: PUSH
20590: LD_INT 4
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: PUSH
20597: LD_INT 30
20599: PUSH
20600: LD_INT 5
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: PPUSH
20611: CALL_OW 69
20615: ST_TO_ADDR
// if not bar then
20616: LD_VAR 0 6
20620: NOT
20621: IFFALSE 20674
// begin repeat wait ( 0 0$1 ) ;
20623: LD_INT 35
20625: PPUSH
20626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
20630: LD_INT 22
20632: PUSH
20633: LD_INT 4
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: LD_INT 3
20642: PUSH
20643: LD_INT 57
20645: PUSH
20646: EMPTY
20647: LIST
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: LD_INT 30
20655: PUSH
20656: LD_INT 5
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: LIST
20667: PPUSH
20668: CALL_OW 69
20672: IFFALSE 20623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20674: LD_ADDR_VAR 0 6
20678: PUSH
20679: LD_INT 22
20681: PUSH
20682: LD_INT 4
20684: PUSH
20685: EMPTY
20686: LIST
20687: LIST
20688: PUSH
20689: LD_INT 30
20691: PUSH
20692: LD_INT 5
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PPUSH
20703: CALL_OW 69
20707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20708: LD_INT 35
20710: PPUSH
20711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
20715: LD_EXP 119
20719: PUSH
20720: LD_INT 4
20722: ARRAY
20723: PUSH
20724: LD_INT 4
20726: GREATEREQUAL
20727: IFFALSE 20708
// tmp := [ ] ;
20729: LD_ADDR_VAR 0 2
20733: PUSH
20734: EMPTY
20735: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
20736: LD_ADDR_VAR 0 1
20740: PUSH
20741: LD_INT 22
20743: PUSH
20744: LD_INT 4
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: PUSH
20751: LD_INT 2
20753: PUSH
20754: LD_INT 25
20756: PUSH
20757: LD_INT 1
20759: PUSH
20760: EMPTY
20761: LIST
20762: LIST
20763: PUSH
20764: LD_INT 25
20766: PUSH
20767: LD_INT 2
20769: PUSH
20770: EMPTY
20771: LIST
20772: LIST
20773: PUSH
20774: LD_INT 25
20776: PUSH
20777: LD_INT 3
20779: PUSH
20780: EMPTY
20781: LIST
20782: LIST
20783: PUSH
20784: LD_INT 25
20786: PUSH
20787: LD_INT 4
20789: PUSH
20790: EMPTY
20791: LIST
20792: LIST
20793: PUSH
20794: LD_INT 25
20796: PUSH
20797: LD_INT 5
20799: PUSH
20800: EMPTY
20801: LIST
20802: LIST
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: PPUSH
20816: CALL_OW 69
20820: PUSH
20821: LD_EXP 60
20825: PUSH
20826: LD_EXP 61
20830: ADD
20831: DIFF
20832: PUSH
20833: FOR_IN
20834: IFFALSE 20898
// if GetTag ( i ) = 1 then
20836: LD_VAR 0 1
20840: PPUSH
20841: CALL_OW 110
20845: PUSH
20846: LD_INT 1
20848: EQUAL
20849: IFFALSE 20873
// tmp := Join ( tmp , i ) else
20851: LD_ADDR_VAR 0 2
20855: PUSH
20856: LD_VAR 0 2
20860: PPUSH
20861: LD_VAR 0 1
20865: PPUSH
20866: CALL 105849 0 2
20870: ST_TO_ADDR
20871: GO 20896
// tmp := Insert ( tmp , 1 , i ) ;
20873: LD_ADDR_VAR 0 2
20877: PUSH
20878: LD_VAR 0 2
20882: PPUSH
20883: LD_INT 1
20885: PPUSH
20886: LD_VAR 0 1
20890: PPUSH
20891: CALL_OW 2
20895: ST_TO_ADDR
20896: GO 20833
20898: POP
20899: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
20900: LD_ADDR_VAR 0 3
20904: PUSH
20905: LD_VAR 0 2
20909: PPUSH
20910: LD_INT 26
20912: PUSH
20913: LD_INT 1
20915: PUSH
20916: EMPTY
20917: LIST
20918: LIST
20919: PPUSH
20920: CALL_OW 72
20924: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
20925: LD_ADDR_VAR 0 2
20929: PUSH
20930: LD_VAR 0 2
20934: PUSH
20935: LD_VAR 0 3
20939: DIFF
20940: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
20941: LD_ADDR_VAR 0 2
20945: PUSH
20946: LD_VAR 0 2
20950: PPUSH
20951: LD_INT 3
20953: PPUSH
20954: CALL 104366 0 2
20958: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
20959: LD_ADDR_VAR 0 3
20963: PUSH
20964: LD_VAR 0 3
20968: PPUSH
20969: LD_INT 3
20971: PPUSH
20972: CALL 104366 0 2
20976: ST_TO_ADDR
// for i := 1 to 4 do
20977: LD_ADDR_VAR 0 1
20981: PUSH
20982: DOUBLE
20983: LD_INT 1
20985: DEC
20986: ST_TO_ADDR
20987: LD_INT 4
20989: PUSH
20990: FOR_TO
20991: IFFALSE 21144
// begin if tmp2 then
20993: LD_VAR 0 3
20997: IFFALSE 21065
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
20999: LD_ADDR_EXP 18
21003: PUSH
21004: LD_EXP 18
21008: PPUSH
21009: LD_INT 1
21011: PPUSH
21012: LD_EXP 18
21016: PUSH
21017: LD_INT 1
21019: ARRAY
21020: PUSH
21021: LD_VAR 0 3
21025: PUSH
21026: LD_VAR 0 3
21030: ARRAY
21031: ADD
21032: PPUSH
21033: CALL_OW 1
21037: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21038: LD_VAR 0 3
21042: PUSH
21043: LD_VAR 0 3
21047: ARRAY
21048: PPUSH
21049: LD_INT 1
21051: PPUSH
21052: CALL_OW 109
// tmp2 := [ ] ;
21056: LD_ADDR_VAR 0 3
21060: PUSH
21061: EMPTY
21062: ST_TO_ADDR
// end else
21063: GO 21142
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21065: LD_ADDR_EXP 18
21069: PUSH
21070: LD_EXP 18
21074: PPUSH
21075: LD_INT 1
21077: PPUSH
21078: LD_EXP 18
21082: PUSH
21083: LD_INT 1
21085: ARRAY
21086: PUSH
21087: LD_VAR 0 2
21091: PUSH
21092: LD_VAR 0 2
21096: ARRAY
21097: ADD
21098: PPUSH
21099: CALL_OW 1
21103: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21104: LD_VAR 0 2
21108: PUSH
21109: LD_VAR 0 2
21113: ARRAY
21114: PPUSH
21115: LD_INT 1
21117: PPUSH
21118: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21122: LD_ADDR_VAR 0 2
21126: PUSH
21127: LD_VAR 0 2
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: CALL_OW 3
21141: ST_TO_ADDR
// end ; end ;
21142: GO 20990
21144: POP
21145: POP
// if tmp2 then
21146: LD_VAR 0 3
21150: IFFALSE 21168
// tmp := tmp union tmp2 ;
21152: LD_ADDR_VAR 0 2
21156: PUSH
21157: LD_VAR 0 2
21161: PUSH
21162: LD_VAR 0 3
21166: UNION
21167: ST_TO_ADDR
// for i := 1 to 4 do
21168: LD_ADDR_VAR 0 1
21172: PUSH
21173: DOUBLE
21174: LD_INT 1
21176: DEC
21177: ST_TO_ADDR
21178: LD_INT 4
21180: PUSH
21181: FOR_TO
21182: IFFALSE 21231
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21184: LD_ADDR_EXP 18
21188: PUSH
21189: LD_EXP 18
21193: PPUSH
21194: LD_INT 2
21196: PPUSH
21197: LD_EXP 18
21201: PUSH
21202: LD_INT 2
21204: ARRAY
21205: PUSH
21206: LD_VAR 0 2
21210: PUSH
21211: LD_VAR 0 2
21215: PUSH
21216: LD_VAR 0 1
21220: MINUS
21221: ARRAY
21222: ADD
21223: PPUSH
21224: CALL_OW 1
21228: ST_TO_ADDR
21229: GO 21181
21231: POP
21232: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21233: LD_ADDR_EXP 100
21237: PUSH
21238: LD_EXP 100
21242: PPUSH
21243: LD_INT 4
21245: PPUSH
21246: LD_EXP 100
21250: PUSH
21251: LD_INT 4
21253: ARRAY
21254: PUSH
21255: LD_EXP 18
21259: PUSH
21260: LD_INT 1
21262: ARRAY
21263: DIFF
21264: PPUSH
21265: CALL_OW 1
21269: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21270: LD_VAR 0 5
21274: PUSH
21275: LD_INT 1
21277: ARRAY
21278: PPUSH
21279: CALL_OW 313
21283: IFFALSE 21338
// begin for i in UnitsInside ( arm [ 1 ] ) do
21285: LD_ADDR_VAR 0 1
21289: PUSH
21290: LD_VAR 0 5
21294: PUSH
21295: LD_INT 1
21297: ARRAY
21298: PPUSH
21299: CALL_OW 313
21303: PUSH
21304: FOR_IN
21305: IFFALSE 21336
// begin ComExitBuilding ( i ) ;
21307: LD_VAR 0 1
21311: PPUSH
21312: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21316: LD_VAR 0 1
21320: PPUSH
21321: LD_VAR 0 6
21325: PUSH
21326: LD_INT 1
21328: ARRAY
21329: PPUSH
21330: CALL_OW 180
// end ;
21334: GO 21304
21336: POP
21337: POP
// end ; wait ( 0 0$3 ) ;
21338: LD_INT 105
21340: PPUSH
21341: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21345: LD_ADDR_VAR 0 1
21349: PUSH
21350: LD_EXP 18
21354: PUSH
21355: LD_INT 1
21357: ARRAY
21358: PUSH
21359: FOR_IN
21360: IFFALSE 21467
// begin if IsInUnit ( i ) then
21362: LD_VAR 0 1
21366: PPUSH
21367: CALL_OW 310
21371: IFFALSE 21382
// ComExitBuilding ( i ) ;
21373: LD_VAR 0 1
21377: PPUSH
21378: CALL_OW 122
// if GetClass ( i ) <> 1 then
21382: LD_VAR 0 1
21386: PPUSH
21387: CALL_OW 257
21391: PUSH
21392: LD_INT 1
21394: NONEQUAL
21395: IFFALSE 21436
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
21397: LD_VAR 0 1
21401: PPUSH
21402: LD_VAR 0 5
21406: PUSH
21407: LD_INT 1
21409: ARRAY
21410: PPUSH
21411: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
21415: LD_VAR 0 1
21419: PPUSH
21420: LD_INT 1
21422: PPUSH
21423: CALL_OW 183
// AddComExitBuilding ( i ) ;
21427: LD_VAR 0 1
21431: PPUSH
21432: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
21436: LD_VAR 0 1
21440: PPUSH
21441: LD_INT 60
21443: PPUSH
21444: LD_INT 94
21446: PPUSH
21447: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
21451: LD_VAR 0 1
21455: PPUSH
21456: LD_EXP 60
21460: PPUSH
21461: CALL_OW 179
// end ;
21465: GO 21359
21467: POP
21468: POP
// wait ( 0 0$10 ) ;
21469: LD_INT 350
21471: PPUSH
21472: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
21476: LD_EXP 60
21480: PPUSH
21481: LD_STRING D4-Pow-1
21483: PPUSH
21484: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
21488: LD_ADDR_VAR 0 2
21492: PUSH
21493: LD_EXP 18
21497: PUSH
21498: LD_INT 1
21500: ARRAY
21501: PPUSH
21502: LD_INT 26
21504: PUSH
21505: LD_INT 1
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PPUSH
21512: CALL_OW 72
21516: ST_TO_ADDR
// if tmp then
21517: LD_VAR 0 2
21521: IFFALSE 21539
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
21523: LD_VAR 0 2
21527: PUSH
21528: LD_INT 1
21530: ARRAY
21531: PPUSH
21532: LD_STRING D4-Sol1-1
21534: PPUSH
21535: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
21539: LD_EXP 60
21543: PPUSH
21544: LD_STRING D4-Pow-2
21546: PPUSH
21547: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
21551: LD_ADDR_VAR 0 1
21555: PUSH
21556: DOUBLE
21557: LD_INT 1
21559: DEC
21560: ST_TO_ADDR
21561: LD_EXP 18
21565: PUSH
21566: LD_INT 1
21568: ARRAY
21569: PUSH
21570: FOR_TO
21571: IFFALSE 21664
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
21573: LD_EXP 18
21577: PUSH
21578: LD_INT 1
21580: ARRAY
21581: PUSH
21582: LD_VAR 0 1
21586: ARRAY
21587: PPUSH
21588: LD_EXP 119
21592: PUSH
21593: LD_INT 4
21595: ARRAY
21596: PUSH
21597: LD_INT 1
21599: ARRAY
21600: PPUSH
21601: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
21605: LD_ADDR_EXP 119
21609: PUSH
21610: LD_EXP 119
21614: PPUSH
21615: LD_INT 4
21617: PPUSH
21618: LD_EXP 119
21622: PUSH
21623: LD_INT 4
21625: ARRAY
21626: PPUSH
21627: LD_INT 1
21629: PPUSH
21630: CALL_OW 3
21634: PPUSH
21635: CALL_OW 1
21639: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
21640: LD_INT 8
21642: PPUSH
21643: LD_EXP 18
21647: PUSH
21648: LD_INT 1
21650: ARRAY
21651: PUSH
21652: LD_VAR 0 1
21656: ARRAY
21657: PPUSH
21658: CALL_OW 471
// end ;
21662: GO 21570
21664: POP
21665: POP
// repeat wait ( 0 0$1 ) ;
21666: LD_INT 35
21668: PPUSH
21669: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
21673: LD_EXP 18
21677: PUSH
21678: LD_INT 1
21680: ARRAY
21681: PPUSH
21682: LD_INT 55
21684: PUSH
21685: EMPTY
21686: LIST
21687: PPUSH
21688: CALL_OW 72
21692: PUSH
21693: LD_INT 4
21695: GREATEREQUAL
21696: IFFALSE 21666
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
21698: LD_EXP 18
21702: PUSH
21703: LD_INT 1
21705: ARRAY
21706: PPUSH
21707: LD_INT 69
21709: PPUSH
21710: LD_INT 94
21712: PPUSH
21713: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
21717: LD_EXP 18
21721: PUSH
21722: LD_INT 1
21724: ARRAY
21725: PPUSH
21726: LD_INT 82
21728: PPUSH
21729: LD_INT 83
21731: PPUSH
21732: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
21736: LD_EXP 18
21740: PUSH
21741: LD_INT 1
21743: ARRAY
21744: PPUSH
21745: LD_INT 77
21747: PPUSH
21748: LD_INT 69
21750: PPUSH
21751: CALL_OW 174
// repeat wait ( 3 ) ;
21755: LD_INT 3
21757: PPUSH
21758: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21762: LD_ADDR_VAR 0 1
21766: PUSH
21767: LD_EXP 18
21771: PUSH
21772: LD_INT 1
21774: ARRAY
21775: PUSH
21776: FOR_IN
21777: IFFALSE 21913
// begin if GetLives ( i ) < 990 then
21779: LD_VAR 0 1
21783: PPUSH
21784: CALL_OW 256
21788: PUSH
21789: LD_INT 990
21791: LESS
21792: IFFALSE 21806
// SetLives ( i , 1000 ) ;
21794: LD_VAR 0 1
21798: PPUSH
21799: LD_INT 1000
21801: PPUSH
21802: CALL_OW 234
// if not IsInUnit ( i ) then
21806: LD_VAR 0 1
21810: PPUSH
21811: CALL_OW 310
21815: NOT
21816: IFFALSE 21911
// begin if not HasTask ( i ) then
21818: LD_VAR 0 1
21822: PPUSH
21823: CALL_OW 314
21827: NOT
21828: IFFALSE 21845
// ComMoveXY ( i , 64 , 93 ) ;
21830: LD_VAR 0 1
21834: PPUSH
21835: LD_INT 64
21837: PPUSH
21838: LD_INT 93
21840: PPUSH
21841: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
21845: LD_VAR 0 4
21849: NOT
21850: PUSH
21851: LD_VAR 0 1
21855: PPUSH
21856: CALL_OW 258
21860: PUSH
21861: LD_INT 1
21863: EQUAL
21864: AND
21865: IFFALSE 21911
// begin retreat := true ;
21867: LD_ADDR_VAR 0 4
21871: PUSH
21872: LD_INT 1
21874: ST_TO_ADDR
// SetTag ( i , 2 ) ;
21875: LD_VAR 0 1
21879: PPUSH
21880: LD_INT 2
21882: PPUSH
21883: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_STRING D4a-Sol1-1
21894: PPUSH
21895: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
21899: LD_EXP 60
21903: PPUSH
21904: LD_STRING D4a-Pow-1
21906: PPUSH
21907: CALL_OW 88
// end ; end ; end ;
21911: GO 21776
21913: POP
21914: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
21915: LD_EXP 18
21919: PUSH
21920: LD_INT 1
21922: ARRAY
21923: PPUSH
21924: LD_INT 95
21926: PUSH
21927: LD_INT 9
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PUSH
21934: LD_INT 3
21936: PUSH
21937: LD_INT 55
21939: PUSH
21940: EMPTY
21941: LIST
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: PUSH
21947: EMPTY
21948: LIST
21949: LIST
21950: PPUSH
21951: CALL_OW 72
21955: PUSH
21956: LD_INT 4
21958: GREATEREQUAL
21959: IFFALSE 21755
// for i in powellSquadAttack [ 1 ] do
21961: LD_ADDR_VAR 0 1
21965: PUSH
21966: LD_EXP 18
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PUSH
21975: FOR_IN
21976: IFFALSE 22112
// begin if GetTag ( i ) = 2 then
21978: LD_VAR 0 1
21982: PPUSH
21983: CALL_OW 110
21987: PUSH
21988: LD_INT 2
21990: EQUAL
21991: IFFALSE 22053
// begin ComMoveXY ( i , 60 , 94 ) ;
21993: LD_VAR 0 1
21997: PPUSH
21998: LD_INT 60
22000: PPUSH
22001: LD_INT 94
22003: PPUSH
22004: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22008: LD_VAR 0 1
22012: PPUSH
22013: LD_EXP 60
22017: PPUSH
22018: CALL_OW 179
// wait ( 0 0$3 ) ;
22022: LD_INT 105
22024: PPUSH
22025: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22029: LD_VAR 0 1
22033: PPUSH
22034: LD_STRING D4a-Sol1-2
22036: PPUSH
22037: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22041: LD_EXP 60
22045: PPUSH
22046: LD_STRING D4a-Pow-2
22048: PPUSH
22049: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22053: LD_VAR 0 1
22057: PPUSH
22058: LD_INT 0
22060: PPUSH
22061: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22065: LD_ADDR_EXP 100
22069: PUSH
22070: LD_EXP 100
22074: PPUSH
22075: LD_INT 4
22077: PPUSH
22078: LD_EXP 100
22082: PUSH
22083: LD_INT 4
22085: ARRAY
22086: PUSH
22087: LD_VAR 0 1
22091: UNION
22092: PPUSH
22093: CALL_OW 1
22097: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22098: LD_INT 8
22100: PPUSH
22101: LD_VAR 0 1
22105: PPUSH
22106: CALL_OW 472
// end ;
22110: GO 21975
22112: POP
22113: POP
// wait ( 2 2$00 ) ;
22114: LD_INT 4200
22116: PPUSH
22117: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22121: LD_ADDR_VAR 0 9
22125: PUSH
22126: LD_INT 22
22128: PUSH
22129: LD_INT 4
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: LD_INT 30
22138: PUSH
22139: LD_INT 32
22141: PUSH
22142: EMPTY
22143: LIST
22144: LIST
22145: PUSH
22146: LD_INT 58
22148: PUSH
22149: EMPTY
22150: LIST
22151: PUSH
22152: EMPTY
22153: LIST
22154: LIST
22155: LIST
22156: PPUSH
22157: CALL_OW 69
22161: ST_TO_ADDR
// if tmp then
22162: LD_VAR 0 2
22166: IFFALSE 22406
// begin for i := 1 to tmp do
22168: LD_ADDR_VAR 0 1
22172: PUSH
22173: DOUBLE
22174: LD_INT 1
22176: DEC
22177: ST_TO_ADDR
22178: LD_VAR 0 2
22182: PUSH
22183: FOR_TO
22184: IFFALSE 22397
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22186: LD_ADDR_EXP 100
22190: PUSH
22191: LD_EXP 100
22195: PPUSH
22196: LD_INT 4
22198: PPUSH
22199: LD_EXP 100
22203: PUSH
22204: LD_INT 4
22206: ARRAY
22207: PUSH
22208: LD_VAR 0 2
22212: PUSH
22213: LD_VAR 0 1
22217: ARRAY
22218: DIFF
22219: PPUSH
22220: CALL_OW 1
22224: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22225: LD_ADDR_VAR 0 10
22229: PUSH
22230: LD_VAR 0 2
22234: PUSH
22235: LD_VAR 0 1
22239: ARRAY
22240: PPUSH
22241: CALL_OW 310
22245: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22246: LD_VAR 0 10
22250: PUSH
22251: LD_VAR 0 10
22255: PPUSH
22256: CALL_OW 266
22260: PUSH
22261: LD_INT 32
22263: EQUAL
22264: AND
22265: IFFALSE 22269
// continue ;
22267: GO 22183
// if t then
22269: LD_VAR 0 10
22273: IFFALSE 22290
// ComExitBuilding ( tmp [ i ] ) ;
22275: LD_VAR 0 2
22279: PUSH
22280: LD_VAR 0 1
22284: ARRAY
22285: PPUSH
22286: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22290: LD_VAR 0 2
22294: PUSH
22295: LD_VAR 0 1
22299: ARRAY
22300: PPUSH
22301: LD_VAR 0 5
22305: PUSH
22306: LD_INT 1
22308: ARRAY
22309: PPUSH
22310: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22314: LD_VAR 0 2
22318: PUSH
22319: LD_VAR 0 1
22323: ARRAY
22324: PPUSH
22325: LD_INT 1
22327: PPUSH
22328: CALL_OW 183
// if emptyTowers then
22332: LD_VAR 0 9
22336: IFFALSE 22395
// begin AddComExitBuilding ( tmp [ i ] ) ;
22338: LD_VAR 0 2
22342: PUSH
22343: LD_VAR 0 1
22347: ARRAY
22348: PPUSH
22349: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22353: LD_VAR 0 2
22357: PUSH
22358: LD_VAR 0 1
22362: ARRAY
22363: PPUSH
22364: LD_VAR 0 9
22368: PUSH
22369: LD_INT 1
22371: ARRAY
22372: PPUSH
22373: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
22377: LD_ADDR_VAR 0 9
22381: PUSH
22382: LD_VAR 0 9
22386: PPUSH
22387: LD_INT 1
22389: PPUSH
22390: CALL_OW 3
22394: ST_TO_ADDR
// end ; end ;
22395: GO 22183
22397: POP
22398: POP
// wait ( 0 0$30 ) ;
22399: LD_INT 1050
22401: PPUSH
22402: CALL_OW 67
// end ; uc_side := 6 ;
22406: LD_ADDR_OWVAR 20
22410: PUSH
22411: LD_INT 6
22413: ST_TO_ADDR
// uc_nation := 3 ;
22414: LD_ADDR_OWVAR 21
22418: PUSH
22419: LD_INT 3
22421: ST_TO_ADDR
// ru := [ ] ;
22422: LD_ADDR_VAR 0 7
22426: PUSH
22427: EMPTY
22428: ST_TO_ADDR
// for i = 1 to 5 do
22429: LD_ADDR_VAR 0 1
22433: PUSH
22434: DOUBLE
22435: LD_INT 1
22437: DEC
22438: ST_TO_ADDR
22439: LD_INT 5
22441: PUSH
22442: FOR_TO
22443: IFFALSE 22563
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
22445: LD_INT 22
22447: PUSH
22448: LD_INT 23
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: PUSH
22455: LD_INT 1
22457: PPUSH
22458: LD_INT 2
22460: PPUSH
22461: CALL_OW 12
22465: ARRAY
22466: PPUSH
22467: LD_INT 1
22469: PPUSH
22470: LD_INT 3
22472: PPUSH
22473: LD_INT 43
22475: PUSH
22476: LD_INT 44
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: PUSH
22483: LD_INT 1
22485: PPUSH
22486: LD_INT 2
22488: PPUSH
22489: CALL_OW 12
22493: ARRAY
22494: PPUSH
22495: LD_INT 89
22497: PPUSH
22498: CALL 73397 0 5
// un := CreateVehicle ;
22502: LD_ADDR_VAR 0 8
22506: PUSH
22507: CALL_OW 45
22511: ST_TO_ADDR
// SetDir ( un , 4 ) ;
22512: LD_VAR 0 8
22516: PPUSH
22517: LD_INT 4
22519: PPUSH
22520: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
22524: LD_VAR 0 8
22528: PPUSH
22529: LD_INT 136
22531: PPUSH
22532: LD_INT 90
22534: PPUSH
22535: LD_INT 8
22537: PPUSH
22538: LD_INT 0
22540: PPUSH
22541: CALL_OW 50
// ru := ru ^ un ;
22545: LD_ADDR_VAR 0 7
22549: PUSH
22550: LD_VAR 0 7
22554: PUSH
22555: LD_VAR 0 8
22559: ADD
22560: ST_TO_ADDR
// end ;
22561: GO 22442
22563: POP
22564: POP
// if ru then
22565: LD_VAR 0 7
22569: IFFALSE 22586
// ComAgressiveMove ( ru , 57 , 94 ) ;
22571: LD_VAR 0 7
22575: PPUSH
22576: LD_INT 57
22578: PPUSH
22579: LD_INT 94
22581: PPUSH
22582: CALL_OW 114
// wait ( 3 3$00 ) ;
22586: LD_INT 6300
22588: PPUSH
22589: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22593: LD_INT 4
22595: PPUSH
22596: LD_INT 3
22598: PUSH
22599: LD_INT 1
22601: PUSH
22602: LD_INT 1
22604: PUSH
22605: LD_INT 5
22607: PUSH
22608: EMPTY
22609: LIST
22610: LIST
22611: LIST
22612: LIST
22613: PUSH
22614: LD_INT 4
22616: PUSH
22617: LD_INT 1
22619: PUSH
22620: LD_INT 1
22622: PUSH
22623: LD_INT 6
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: LIST
22630: LIST
22631: PUSH
22632: LD_INT 4
22634: PUSH
22635: LD_INT 1
22637: PUSH
22638: LD_INT 1
22640: PUSH
22641: LD_INT 7
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: PUSH
22650: LD_INT 3
22652: PUSH
22653: LD_INT 1
22655: PUSH
22656: LD_INT 1
22658: PUSH
22659: LD_INT 7
22661: PUSH
22662: EMPTY
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: PUSH
22668: LD_INT 3
22670: PUSH
22671: LD_INT 1
22673: PUSH
22674: LD_INT 1
22676: PUSH
22677: LD_INT 5
22679: PUSH
22680: EMPTY
22681: LIST
22682: LIST
22683: LIST
22684: LIST
22685: PUSH
22686: EMPTY
22687: LIST
22688: LIST
22689: LIST
22690: LIST
22691: LIST
22692: PPUSH
22693: CALL 62083 0 2
// missionStage := 4 ;
22697: LD_ADDR_EXP 15
22701: PUSH
22702: LD_INT 4
22704: ST_TO_ADDR
// end ;
22705: PPOPN 10
22707: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
22708: LD_EXP 15
22712: PUSH
22713: LD_INT 4
22715: EQUAL
22716: PUSH
22717: LD_INT 22
22719: PUSH
22720: LD_INT 4
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: LD_INT 21
22729: PUSH
22730: LD_INT 2
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PPUSH
22741: CALL_OW 69
22745: PUSH
22746: LD_INT 5
22748: GREATEREQUAL
22749: AND
22750: IFFALSE 27017
22752: GO 22754
22754: DISABLE
22755: LD_INT 0
22757: PPUSH
22758: PPUSH
22759: PPUSH
22760: PPUSH
22761: PPUSH
22762: PPUSH
22763: PPUSH
22764: PPUSH
22765: PPUSH
22766: PPUSH
22767: PPUSH
22768: PPUSH
22769: PPUSH
// begin wait ( 0 0$10 ) ;
22770: LD_INT 350
22772: PPUSH
22773: CALL_OW 67
// missionStage := 5 ;
22777: LD_ADDR_EXP 15
22781: PUSH
22782: LD_INT 5
22784: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
22785: LD_ADDR_VAR 0 10
22789: PUSH
22790: LD_INT 22
22792: PUSH
22793: LD_INT 4
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PUSH
22800: LD_INT 2
22802: PUSH
22803: LD_INT 30
22805: PUSH
22806: LD_INT 4
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: PUSH
22813: LD_INT 30
22815: PUSH
22816: LD_INT 5
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: PUSH
22823: EMPTY
22824: LIST
22825: LIST
22826: LIST
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: PPUSH
22832: CALL_OW 69
22836: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
22837: LD_ADDR_VAR 0 6
22841: PUSH
22842: LD_INT 22
22844: PUSH
22845: LD_INT 4
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PUSH
22852: LD_INT 21
22854: PUSH
22855: LD_INT 1
22857: PUSH
22858: EMPTY
22859: LIST
22860: LIST
22861: PUSH
22862: LD_INT 3
22864: PUSH
22865: LD_INT 25
22867: PUSH
22868: LD_INT 16
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: LD_INT 3
22881: PUSH
22882: LD_INT 25
22884: PUSH
22885: LD_INT 12
22887: PUSH
22888: EMPTY
22889: LIST
22890: LIST
22891: PUSH
22892: EMPTY
22893: LIST
22894: LIST
22895: PUSH
22896: EMPTY
22897: LIST
22898: LIST
22899: LIST
22900: LIST
22901: PPUSH
22902: CALL_OW 69
22906: PUSH
22907: LD_EXP 60
22911: DIFF
22912: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
22913: LD_ADDR_VAR 0 9
22917: PUSH
22918: LD_INT 22
22920: PUSH
22921: LD_INT 4
22923: PUSH
22924: EMPTY
22925: LIST
22926: LIST
22927: PUSH
22928: LD_INT 30
22930: PUSH
22931: LD_INT 3
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: PUSH
22938: EMPTY
22939: LIST
22940: LIST
22941: PPUSH
22942: CALL_OW 69
22946: PUSH
22947: LD_INT 1
22949: ARRAY
22950: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
22951: LD_INT 350
22953: PPUSH
22954: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
22958: LD_EXP 119
22962: PUSH
22963: LD_INT 4
22965: ARRAY
22966: PUSH
22967: LD_INT 5
22969: LESS
22970: PUSH
22971: LD_VAR 0 9
22975: PPUSH
22976: CALL_OW 461
22980: PUSH
22981: LD_INT 2
22983: EQUAL
22984: AND
22985: IFFALSE 23015
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22987: LD_INT 4
22989: PPUSH
22990: LD_INT 3
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: LD_INT 1
22998: PUSH
22999: LD_INT 5
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: LIST
23006: LIST
23007: PUSH
23008: EMPTY
23009: LIST
23010: PPUSH
23011: CALL 62131 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23015: LD_EXP 119
23019: PUSH
23020: LD_INT 4
23022: ARRAY
23023: PUSH
23024: LD_INT 5
23026: GREATEREQUAL
23027: PUSH
23028: LD_EXP 119
23032: PUSH
23033: LD_INT 4
23035: ARRAY
23036: PPUSH
23037: LD_INT 58
23039: PUSH
23040: EMPTY
23041: LIST
23042: PPUSH
23043: CALL_OW 72
23047: PUSH
23048: LD_INT 5
23050: GREATEREQUAL
23051: AND
23052: IFFALSE 22951
// powellAllowRetreat := false ;
23054: LD_ADDR_EXP 19
23058: PUSH
23059: LD_INT 0
23061: ST_TO_ADDR
// activeAttacks := false ;
23062: LD_ADDR_EXP 16
23066: PUSH
23067: LD_INT 0
23069: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23070: LD_INT 35
23072: PPUSH
23073: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23077: LD_INT 22
23079: PUSH
23080: LD_INT 6
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PPUSH
23087: CALL_OW 69
23091: PUSH
23092: LD_INT 0
23094: EQUAL
23095: IFFALSE 23070
// tmp := mc_vehicles [ 4 ] ;
23097: LD_ADDR_VAR 0 3
23101: PUSH
23102: LD_EXP 119
23106: PUSH
23107: LD_INT 4
23109: ARRAY
23110: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23111: LD_ADDR_VAR 0 1
23115: PUSH
23116: DOUBLE
23117: LD_INT 1
23119: DEC
23120: ST_TO_ADDR
23121: LD_EXP 18
23125: PUSH
23126: FOR_TO
23127: IFFALSE 23388
// begin for j in powellSquadAttack [ i ] do
23129: LD_ADDR_VAR 0 2
23133: PUSH
23134: LD_EXP 18
23138: PUSH
23139: LD_VAR 0 1
23143: ARRAY
23144: PUSH
23145: FOR_IN
23146: IFFALSE 23384
// begin forces := forces diff j ;
23148: LD_ADDR_VAR 0 6
23152: PUSH
23153: LD_VAR 0 6
23157: PUSH
23158: LD_VAR 0 2
23162: DIFF
23163: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23164: LD_VAR 0 2
23168: PPUSH
23169: LD_INT 1
23171: PPUSH
23172: CALL_OW 109
// wait ( 0 0$2 ) ;
23176: LD_INT 70
23178: PPUSH
23179: CALL_OW 67
// if IsInUnit ( j ) then
23183: LD_VAR 0 2
23187: PPUSH
23188: CALL_OW 310
23192: IFFALSE 23203
// ComExitBuilding ( j ) ;
23194: LD_VAR 0 2
23198: PPUSH
23199: CALL_OW 122
// if GetClass ( j ) <> 1 then
23203: LD_VAR 0 2
23207: PPUSH
23208: CALL_OW 257
23212: PUSH
23213: LD_INT 1
23215: NONEQUAL
23216: IFFALSE 23296
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23218: LD_VAR 0 10
23222: PUSH
23223: LD_INT 1
23225: ARRAY
23226: PPUSH
23227: CALL_OW 313
23231: PUSH
23232: LD_INT 5
23234: GREATEREQUAL
23235: IFFALSE 23257
// AddComEnterUnit ( j , arm [ 2 ] ) else
23237: LD_VAR 0 2
23241: PPUSH
23242: LD_VAR 0 10
23246: PUSH
23247: LD_INT 2
23249: ARRAY
23250: PPUSH
23251: CALL_OW 180
23255: GO 23275
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23257: LD_VAR 0 2
23261: PPUSH
23262: LD_VAR 0 10
23266: PUSH
23267: LD_INT 1
23269: ARRAY
23270: PPUSH
23271: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23275: LD_VAR 0 2
23279: PPUSH
23280: LD_INT 1
23282: PPUSH
23283: CALL_OW 183
// AddComExitBuilding ( j ) ;
23287: LD_VAR 0 2
23291: PPUSH
23292: CALL_OW 182
// end ; if i = 2 then
23296: LD_VAR 0 1
23300: PUSH
23301: LD_INT 2
23303: EQUAL
23304: IFFALSE 23321
// AddComMoveXY ( j , 61 , 93 ) ;
23306: LD_VAR 0 2
23310: PPUSH
23311: LD_INT 61
23313: PPUSH
23314: LD_INT 93
23316: PPUSH
23317: CALL_OW 171
// if i = 1 then
23321: LD_VAR 0 1
23325: PUSH
23326: LD_INT 1
23328: EQUAL
23329: IFFALSE 23382
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23331: LD_VAR 0 2
23335: PPUSH
23336: LD_VAR 0 3
23340: PUSH
23341: LD_INT 1
23343: ARRAY
23344: PPUSH
23345: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23349: LD_ADDR_VAR 0 3
23353: PUSH
23354: LD_VAR 0 3
23358: PPUSH
23359: LD_INT 1
23361: PPUSH
23362: CALL_OW 3
23366: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
23367: LD_VAR 0 2
23371: PPUSH
23372: LD_INT 69
23374: PPUSH
23375: LD_INT 94
23377: PPUSH
23378: CALL_OW 171
// end ; end ;
23382: GO 23145
23384: POP
23385: POP
// end ;
23386: GO 23126
23388: POP
23389: POP
// wait ( 0 0$30 ) ;
23390: LD_INT 1050
23392: PPUSH
23393: CALL_OW 67
// MC_Kill ( 4 ) ;
23397: LD_INT 4
23399: PPUSH
23400: CALL 38120 0 1
// tmp := UnitsInside ( fac ) ;
23404: LD_ADDR_VAR 0 3
23408: PUSH
23409: LD_VAR 0 9
23413: PPUSH
23414: CALL_OW 313
23418: ST_TO_ADDR
// if tmp then
23419: LD_VAR 0 3
23423: IFFALSE 23544
// for i in tmp do
23425: LD_ADDR_VAR 0 1
23429: PUSH
23430: LD_VAR 0 3
23434: PUSH
23435: FOR_IN
23436: IFFALSE 23542
// begin ComExitBuilding ( i ) ;
23438: LD_VAR 0 1
23442: PPUSH
23443: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
23447: LD_VAR 0 10
23451: PUSH
23452: LD_INT 2
23454: ARRAY
23455: PPUSH
23456: CALL_OW 313
23460: PUSH
23461: LD_INT 6
23463: LESS
23464: IFFALSE 23486
// AddComEnterUnit ( i , arm [ 2 ] ) else
23466: LD_VAR 0 1
23470: PPUSH
23471: LD_VAR 0 10
23475: PUSH
23476: LD_INT 2
23478: ARRAY
23479: PPUSH
23480: CALL_OW 180
23484: GO 23540
// if UnitsInside ( arm [ 1 ] ) < 6 then
23486: LD_VAR 0 10
23490: PUSH
23491: LD_INT 1
23493: ARRAY
23494: PPUSH
23495: CALL_OW 313
23499: PUSH
23500: LD_INT 6
23502: LESS
23503: IFFALSE 23525
// AddComEnterUnit ( i , arm [ 1 ] ) else
23505: LD_VAR 0 1
23509: PPUSH
23510: LD_VAR 0 10
23514: PUSH
23515: LD_INT 1
23517: ARRAY
23518: PPUSH
23519: CALL_OW 180
23523: GO 23540
// AddComMoveXY ( i , 37 , 68 ) ;
23525: LD_VAR 0 1
23529: PPUSH
23530: LD_INT 37
23532: PPUSH
23533: LD_INT 68
23535: PPUSH
23536: CALL_OW 171
// end ;
23540: GO 23435
23542: POP
23543: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
23544: LD_ADDR_VAR 0 11
23548: PUSH
23549: LD_VAR 0 6
23553: PPUSH
23554: LD_INT 26
23556: PUSH
23557: LD_INT 1
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PPUSH
23564: CALL_OW 72
23568: PUSH
23569: LD_EXP 61
23573: DIFF
23574: ST_TO_ADDR
// if not speaker then
23575: LD_VAR 0 11
23579: NOT
23580: IFFALSE 23607
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
23582: LD_ADDR_VAR 0 11
23586: PUSH
23587: LD_VAR 0 6
23591: PPUSH
23592: LD_INT 26
23594: PUSH
23595: LD_INT 1
23597: PUSH
23598: EMPTY
23599: LIST
23600: LIST
23601: PPUSH
23602: CALL_OW 72
23606: ST_TO_ADDR
// if speaker then
23607: LD_VAR 0 11
23611: IFFALSE 23627
// speaker := speaker [ 1 ] ;
23613: LD_ADDR_VAR 0 11
23617: PUSH
23618: LD_VAR 0 11
23622: PUSH
23623: LD_INT 1
23625: ARRAY
23626: ST_TO_ADDR
// Video ( true ) ;
23627: LD_INT 1
23629: PPUSH
23630: CALL 105821 0 1
// CenterNowOnUnits ( Powell ) ;
23634: LD_EXP 60
23638: PPUSH
23639: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
23643: LD_ADDR_VAR 0 3
23647: PUSH
23648: LD_VAR 0 6
23652: PPUSH
23653: LD_INT 3
23655: PUSH
23656: LD_INT 25
23658: PUSH
23659: LD_INT 1
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PPUSH
23670: CALL_OW 72
23674: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23675: LD_ADDR_VAR 0 12
23679: PUSH
23680: LD_INT 22
23682: PUSH
23683: LD_INT 4
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: PUSH
23690: LD_INT 30
23692: PUSH
23693: LD_INT 32
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PUSH
23700: LD_INT 58
23702: PUSH
23703: EMPTY
23704: LIST
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: LIST
23710: PPUSH
23711: CALL_OW 69
23715: ST_TO_ADDR
// for i := 1 to 4 do
23716: LD_ADDR_VAR 0 1
23720: PUSH
23721: DOUBLE
23722: LD_INT 1
23724: DEC
23725: ST_TO_ADDR
23726: LD_INT 4
23728: PUSH
23729: FOR_TO
23730: IFFALSE 23876
// begin if IsInUnit ( tmp [ i ] ) then
23732: LD_VAR 0 3
23736: PUSH
23737: LD_VAR 0 1
23741: ARRAY
23742: PPUSH
23743: CALL_OW 310
23747: IFFALSE 23764
// ComExitBuilding ( tmp [ i ] ) ;
23749: LD_VAR 0 3
23753: PUSH
23754: LD_VAR 0 1
23758: ARRAY
23759: PPUSH
23760: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23764: LD_VAR 0 3
23768: PUSH
23769: LD_VAR 0 1
23773: ARRAY
23774: PPUSH
23775: LD_VAR 0 10
23779: PUSH
23780: LD_INT 1
23782: ARRAY
23783: PPUSH
23784: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23788: LD_VAR 0 3
23792: PUSH
23793: LD_VAR 0 1
23797: ARRAY
23798: PPUSH
23799: LD_INT 1
23801: PPUSH
23802: CALL_OW 183
// if Count ( emp_towers ) then
23806: LD_VAR 0 12
23810: PPUSH
23811: CALL 70659 0 1
23815: IFFALSE 23874
// begin AddComExitBuilding ( tmp [ i ] ) ;
23817: LD_VAR 0 3
23821: PUSH
23822: LD_VAR 0 1
23826: ARRAY
23827: PPUSH
23828: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
23832: LD_VAR 0 3
23836: PUSH
23837: LD_VAR 0 1
23841: ARRAY
23842: PPUSH
23843: LD_VAR 0 12
23847: PUSH
23848: LD_INT 1
23850: ARRAY
23851: PPUSH
23852: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
23856: LD_ADDR_VAR 0 12
23860: PUSH
23861: LD_VAR 0 12
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 3
23873: ST_TO_ADDR
// end ; end ;
23874: GO 23729
23876: POP
23877: POP
// wait ( 0 0$5 ) ;
23878: LD_INT 175
23880: PPUSH
23881: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
23885: LD_VAR 0 3
23889: PPUSH
23890: LD_INT 3
23892: PUSH
23893: LD_INT 54
23895: PUSH
23896: EMPTY
23897: LIST
23898: PUSH
23899: EMPTY
23900: LIST
23901: LIST
23902: PPUSH
23903: CALL_OW 72
23907: IFFALSE 23927
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
23909: LD_VAR 0 3
23913: PPUSH
23914: LD_VAR 0 10
23918: PUSH
23919: LD_INT 1
23921: ARRAY
23922: PPUSH
23923: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
23927: LD_ADDR_VAR 0 3
23931: PUSH
23932: LD_EXP 18
23936: PUSH
23937: LD_INT 1
23939: ARRAY
23940: PUSH
23941: LD_EXP 18
23945: PUSH
23946: LD_INT 2
23948: ARRAY
23949: ADD
23950: PPUSH
23951: LD_INT 26
23953: PUSH
23954: LD_INT 1
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: PPUSH
23961: CALL_OW 72
23965: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
23966: LD_ADDR_VAR 0 1
23970: PUSH
23971: LD_EXP 18
23975: PUSH
23976: LD_INT 2
23978: ARRAY
23979: PUSH
23980: FOR_IN
23981: IFFALSE 23999
// ComTurnUnit ( i , Powell ) ;
23983: LD_VAR 0 1
23987: PPUSH
23988: LD_EXP 60
23992: PPUSH
23993: CALL_OW 119
23997: GO 23980
23999: POP
24000: POP
// Say ( Powell , D5-Pow-1 ) ;
24001: LD_EXP 60
24005: PPUSH
24006: LD_STRING D5-Pow-1
24008: PPUSH
24009: CALL_OW 88
// if tmp then
24013: LD_VAR 0 3
24017: IFFALSE 24035
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24019: LD_VAR 0 3
24023: PUSH
24024: LD_INT 1
24026: ARRAY
24027: PPUSH
24028: LD_STRING D5-Sol2-1
24030: PPUSH
24031: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24035: LD_EXP 60
24039: PPUSH
24040: LD_STRING D5-Pow-2
24042: PPUSH
24043: CALL_OW 88
// if tmp > 1 then
24047: LD_VAR 0 3
24051: PUSH
24052: LD_INT 1
24054: GREATER
24055: IFFALSE 24073
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24057: LD_VAR 0 3
24061: PUSH
24062: LD_INT 2
24064: ARRAY
24065: PPUSH
24066: LD_STRING D5-Sol2-2
24068: PPUSH
24069: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24073: LD_EXP 60
24077: PPUSH
24078: LD_STRING D5-Pow-3
24080: PPUSH
24081: CALL_OW 88
// wait ( 0 0$1 ) ;
24085: LD_INT 35
24087: PPUSH
24088: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24092: LD_ADDR_VAR 0 3
24096: PUSH
24097: LD_EXP 18
24101: PUSH
24102: LD_INT 1
24104: ARRAY
24105: PUSH
24106: LD_EXP 18
24110: PUSH
24111: LD_INT 2
24113: ARRAY
24114: UNION
24115: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24116: LD_VAR 0 3
24120: PPUSH
24121: LD_INT 80
24123: PPUSH
24124: LD_INT 67
24126: PPUSH
24127: CALL_OW 114
// wait ( 0 0$2 ) ;
24131: LD_INT 70
24133: PPUSH
24134: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24138: LD_INT 79
24140: PPUSH
24141: LD_INT 72
24143: PPUSH
24144: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24148: LD_INT 70
24150: PPUSH
24151: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24155: LD_VAR 0 3
24159: PPUSH
24160: LD_INT 3
24162: PUSH
24163: LD_INT 24
24165: PUSH
24166: LD_INT 1000
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: PPUSH
24177: CALL_OW 72
24181: IFFALSE 24148
// Say ( Powell , D5a-Pow-1 ) ;
24183: LD_EXP 60
24187: PPUSH
24188: LD_STRING D5a-Pow-1
24190: PPUSH
24191: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24195: LD_EXP 60
24199: PPUSH
24200: LD_STRING D5a-Pow-1a
24202: PPUSH
24203: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24207: LD_INT 24
24209: PPUSH
24210: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24214: LD_EXP 60
24218: PPUSH
24219: LD_STRING D5a-Pow-1b
24221: PPUSH
24222: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24226: LD_INT 10
24228: PPUSH
24229: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24233: LD_EXP 60
24237: PPUSH
24238: LD_STRING D5a-Pow-1c
24240: PPUSH
24241: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24245: LD_VAR 0 3
24249: PPUSH
24250: LD_INT 68
24252: PPUSH
24253: LD_INT 63
24255: PPUSH
24256: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24260: LD_INT 18
24262: PPUSH
24263: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24267: LD_EXP 60
24271: PPUSH
24272: LD_STRING D5a-Pow-1d
24274: PPUSH
24275: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24279: LD_INT 35
24281: PPUSH
24282: CALL_OW 67
// if not HasTask ( tmp ) then
24286: LD_VAR 0 3
24290: PPUSH
24291: CALL_OW 314
24295: NOT
24296: IFFALSE 24313
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24298: LD_VAR 0 3
24302: PPUSH
24303: LD_INT 68
24305: PPUSH
24306: LD_INT 63
24308: PPUSH
24309: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24313: LD_VAR 0 3
24317: PPUSH
24318: LD_INT 24
24320: PUSH
24321: LD_INT 1
24323: PUSH
24324: EMPTY
24325: LIST
24326: LIST
24327: PPUSH
24328: CALL_OW 72
24332: NOT
24333: IFFALSE 24279
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24335: LD_ADDR_VAR 0 3
24339: PUSH
24340: LD_INT 22
24342: PUSH
24343: LD_INT 4
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: LD_INT 92
24352: PUSH
24353: LD_INT 60
24355: PUSH
24356: LD_INT 93
24358: PUSH
24359: LD_INT 10
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: PUSH
24368: LD_INT 3
24370: PUSH
24371: LD_INT 54
24373: PUSH
24374: EMPTY
24375: LIST
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: EMPTY
24382: LIST
24383: LIST
24384: LIST
24385: PPUSH
24386: CALL_OW 69
24390: PUSH
24391: LD_EXP 60
24395: DIFF
24396: ST_TO_ADDR
// if tmp then
24397: LD_VAR 0 3
24401: IFFALSE 24435
// for i in tmp do
24403: LD_ADDR_VAR 0 1
24407: PUSH
24408: LD_VAR 0 3
24412: PUSH
24413: FOR_IN
24414: IFFALSE 24433
// ComMoveXY ( i , 36 , 67 ) ;
24416: LD_VAR 0 1
24420: PPUSH
24421: LD_INT 36
24423: PPUSH
24424: LD_INT 67
24426: PPUSH
24427: CALL_OW 111
24431: GO 24413
24433: POP
24434: POP
// wait ( 0 0$3 ) ;
24435: LD_INT 105
24437: PPUSH
24438: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
24442: LD_VAR 0 11
24446: PPUSH
24447: LD_STRING D6-Sol3-1
24449: PPUSH
24450: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
24454: LD_EXP 60
24458: PPUSH
24459: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
24463: LD_EXP 60
24467: PPUSH
24468: LD_STRING D6-Pow-1
24470: PPUSH
24471: CALL_OW 88
// tmp := [ ] ;
24475: LD_ADDR_VAR 0 3
24479: PUSH
24480: EMPTY
24481: ST_TO_ADDR
// for i = 1 to 2 do
24482: LD_ADDR_VAR 0 1
24486: PUSH
24487: DOUBLE
24488: LD_INT 1
24490: DEC
24491: ST_TO_ADDR
24492: LD_INT 2
24494: PUSH
24495: FOR_TO
24496: IFFALSE 24610
// begin uc_side := 8 ;
24498: LD_ADDR_OWVAR 20
24502: PUSH
24503: LD_INT 8
24505: ST_TO_ADDR
// uc_nation := 2 ;
24506: LD_ADDR_OWVAR 21
24510: PUSH
24511: LD_INT 2
24513: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
24514: LD_INT 14
24516: PPUSH
24517: LD_INT 3
24519: PPUSH
24520: LD_INT 2
24522: PPUSH
24523: LD_INT 29
24525: PPUSH
24526: LD_INT 100
24528: PPUSH
24529: CALL 73397 0 5
// veh := CreateVehicle ;
24533: LD_ADDR_VAR 0 13
24537: PUSH
24538: CALL_OW 45
24542: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
24543: LD_VAR 0 13
24547: PPUSH
24548: LD_INT 4
24550: PPUSH
24551: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
24555: LD_VAR 0 13
24559: PPUSH
24560: LD_INT 99
24562: PPUSH
24563: LD_INT 83
24565: PPUSH
24566: LD_INT 3
24568: PPUSH
24569: LD_INT 0
24571: PPUSH
24572: CALL_OW 50
// wait ( 3 ) ;
24576: LD_INT 3
24578: PPUSH
24579: CALL_OW 67
// Connect ( veh ) ;
24583: LD_VAR 0 13
24587: PPUSH
24588: CALL 76488 0 1
// tmp := tmp ^ veh ;
24592: LD_ADDR_VAR 0 3
24596: PUSH
24597: LD_VAR 0 3
24601: PUSH
24602: LD_VAR 0 13
24606: ADD
24607: ST_TO_ADDR
// end ;
24608: GO 24495
24610: POP
24611: POP
// wait ( 0 0$1 ) ;
24612: LD_INT 35
24614: PPUSH
24615: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
24619: LD_INT 99
24621: PPUSH
24622: LD_INT 83
24624: PPUSH
24625: LD_INT 1
24627: PPUSH
24628: LD_INT 10
24630: PPUSH
24631: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
24635: LD_INT 99
24637: PPUSH
24638: LD_INT 83
24640: PPUSH
24641: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
24645: LD_VAR 0 11
24649: PPUSH
24650: LD_STRING D6-Sol3-2
24652: PPUSH
24653: CALL_OW 88
// async ;
24657: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
24658: LD_EXP 60
24662: PPUSH
24663: LD_STRING D6-Pow-2
24665: PPUSH
24666: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
24670: LD_VAR 0 3
24674: PUSH
24675: LD_INT 1
24677: ARRAY
24678: PPUSH
24679: LD_VAR 0 9
24683: PPUSH
24684: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
24688: LD_VAR 0 3
24692: PUSH
24693: LD_INT 2
24695: ARRAY
24696: PPUSH
24697: LD_INT 22
24699: PUSH
24700: LD_INT 4
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: LD_INT 21
24709: PUSH
24710: LD_INT 3
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: EMPTY
24718: LIST
24719: LIST
24720: PPUSH
24721: CALL_OW 69
24725: PPUSH
24726: LD_VAR 0 3
24730: PUSH
24731: LD_INT 2
24733: ARRAY
24734: PPUSH
24735: CALL_OW 74
24739: PPUSH
24740: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
24744: LD_EXP 60
24748: PPUSH
24749: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
24753: LD_INT 99
24755: PPUSH
24756: LD_INT 83
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 331
// repeat wait ( 4 ) ;
24766: LD_INT 4
24768: PPUSH
24769: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
24773: LD_VAR 0 3
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: CALL_OW 256
24786: PUSH
24787: LD_INT 1000
24789: LESS
24790: IFFALSE 24808
// SetLives ( tmp [ 1 ] , 1000 ) ;
24792: LD_VAR 0 3
24796: PUSH
24797: LD_INT 1
24799: ARRAY
24800: PPUSH
24801: LD_INT 1000
24803: PPUSH
24804: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
24808: LD_INT 22
24810: PUSH
24811: LD_INT 4
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: PUSH
24818: LD_INT 30
24820: PUSH
24821: LD_INT 3
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: EMPTY
24829: LIST
24830: LIST
24831: PPUSH
24832: CALL_OW 69
24836: PUSH
24837: LD_INT 0
24839: EQUAL
24840: IFFALSE 24766
// skirmish := false ;
24842: LD_ADDR_EXP 98
24846: PUSH
24847: LD_INT 0
24849: ST_TO_ADDR
// sync ;
24850: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
24851: LD_EXP 60
24855: PPUSH
24856: LD_STRING D6a-Pow-1
24858: PPUSH
24859: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
24863: LD_VAR 0 11
24867: PPUSH
24868: LD_STRING D6a-Sol3-1
24870: PPUSH
24871: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
24875: LD_EXP 60
24879: PPUSH
24880: LD_STRING D6a-Pow-2
24882: PPUSH
24883: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
24887: LD_VAR 0 11
24891: PPUSH
24892: LD_STRING D6a-Sol3-2
24894: PPUSH
24895: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
24899: LD_EXP 60
24903: PPUSH
24904: LD_STRING D6a-Pow-3
24906: PPUSH
24907: CALL_OW 88
// powellCenterCameraMode := true ;
24911: LD_ADDR_EXP 20
24915: PUSH
24916: LD_INT 1
24918: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
24919: LD_ADDR_VAR 0 1
24923: PUSH
24924: LD_INT 22
24926: PUSH
24927: LD_INT 8
24929: PUSH
24930: EMPTY
24931: LIST
24932: LIST
24933: PUSH
24934: LD_INT 25
24936: PUSH
24937: LD_INT 2
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PPUSH
24948: CALL_OW 69
24952: PUSH
24953: FOR_IN
24954: IFFALSE 25009
// begin SetTag ( i , 1 ) ;
24956: LD_VAR 0 1
24960: PPUSH
24961: LD_INT 1
24963: PPUSH
24964: CALL_OW 109
// ComExitBuilding ( i ) ;
24968: LD_VAR 0 1
24972: PPUSH
24973: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
24977: LD_VAR 0 1
24981: PPUSH
24982: LD_INT 35
24984: PPUSH
24985: LD_INT 6
24987: PPUSH
24988: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
24992: LD_VAR 0 1
24996: PPUSH
24997: LD_INT 53
24999: PPUSH
25000: LD_INT 4
25002: PPUSH
25003: CALL_OW 171
// end ;
25007: GO 24953
25009: POP
25010: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25011: LD_ADDR_VAR 0 3
25015: PUSH
25016: LD_INT 22
25018: PUSH
25019: LD_INT 4
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 21
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PUSH
25036: LD_INT 3
25038: PUSH
25039: LD_INT 34
25041: PUSH
25042: LD_INT 12
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: LIST
25057: PPUSH
25058: CALL_OW 69
25062: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: LD_EXP 60
25077: PPUSH
25078: CALL_OW 74
25082: PPUSH
25083: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_INT 100
25094: PPUSH
25095: LD_INT 88
25097: PPUSH
25098: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_INT 100
25109: PPUSH
25110: LD_INT 75
25112: PPUSH
25113: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25117: LD_EXP 60
25121: PPUSH
25122: LD_INT 88
25124: PPUSH
25125: LD_INT 53
25127: PPUSH
25128: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25132: LD_INT 8
25134: PPUSH
25135: LD_EXP 60
25139: PPUSH
25140: CALL_OW 471
// repeat wait ( 3 ) ;
25144: LD_INT 3
25146: PPUSH
25147: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25151: LD_INT 22
25153: PUSH
25154: LD_INT 4
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: LD_INT 92
25163: PUSH
25164: LD_INT 100
25166: PUSH
25167: LD_INT 75
25169: PUSH
25170: LD_INT 6
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: LIST
25177: LIST
25178: PUSH
25179: EMPTY
25180: LIST
25181: LIST
25182: PPUSH
25183: CALL_OW 69
25187: IFFALSE 25144
// async ;
25189: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25190: LD_EXP 60
25194: PPUSH
25195: LD_STRING D6b-Pow-1
25197: PPUSH
25198: CALL_OW 88
// repeat wait ( 3 ) ;
25202: LD_INT 3
25204: PPUSH
25205: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25209: LD_EXP 60
25213: PPUSH
25214: CALL_OW 310
25218: PPUSH
25219: CALL_OW 256
25223: PUSH
25224: LD_INT 1000
25226: LESS
25227: IFFALSE 25246
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25229: LD_EXP 60
25233: PPUSH
25234: CALL_OW 310
25238: PPUSH
25239: LD_INT 1000
25241: PPUSH
25242: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25246: LD_EXP 60
25250: PPUSH
25251: CALL_OW 256
25255: PUSH
25256: LD_INT 1000
25258: LESS
25259: IFFALSE 25273
// SetLives ( Powell , 1000 ) ;
25261: LD_EXP 60
25265: PPUSH
25266: LD_INT 1000
25268: PPUSH
25269: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25273: LD_EXP 60
25277: PPUSH
25278: LD_EXP 65
25282: PPUSH
25283: CALL_OW 296
25287: PUSH
25288: LD_INT 5
25290: LESS
25291: PUSH
25292: LD_EXP 60
25296: PPUSH
25297: CALL_OW 310
25301: PPUSH
25302: LD_EXP 65
25306: PPUSH
25307: CALL_OW 296
25311: PUSH
25312: LD_INT 5
25314: LESS
25315: OR
25316: IFFALSE 25335
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25318: LD_EXP 60
25322: PPUSH
25323: CALL_OW 310
25327: PPUSH
25328: LD_INT 100
25330: PPUSH
25331: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25335: LD_EXP 60
25339: PPUSH
25340: CALL_OW 310
25344: NOT
25345: IFFALSE 25202
// DoNotAttack ( 8 , powellBomb ) ;
25347: LD_INT 8
25349: PPUSH
25350: LD_EXP 65
25354: PPUSH
25355: CALL_OW 471
// game_speed := 4 ;
25359: LD_ADDR_OWVAR 65
25363: PUSH
25364: LD_INT 4
25366: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
25367: LD_EXP 60
25371: PPUSH
25372: LD_STRING D6b-Pow-1a
25374: PPUSH
25375: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
25379: LD_EXP 60
25383: PPUSH
25384: LD_EXP 65
25388: PPUSH
25389: CALL_OW 180
// sync ;
25393: SYNC
// repeat wait ( 0 0$1 ) ;
25394: LD_INT 35
25396: PPUSH
25397: CALL_OW 67
// until IsInUnit ( Powell ) ;
25401: LD_EXP 60
25405: PPUSH
25406: CALL_OW 310
25410: IFFALSE 25394
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
25412: LD_INT 8
25414: PPUSH
25415: LD_EXP 60
25419: PPUSH
25420: CALL_OW 310
25424: PPUSH
25425: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
25429: LD_EXP 60
25433: PPUSH
25434: LD_INT 91
25436: PPUSH
25437: LD_INT 44
25439: PPUSH
25440: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25444: LD_EXP 60
25448: PPUSH
25449: LD_INT 96
25451: PPUSH
25452: LD_INT 44
25454: PPUSH
25455: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25459: LD_EXP 60
25463: PPUSH
25464: LD_INT 96
25466: PPUSH
25467: LD_INT 41
25469: PPUSH
25470: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25474: LD_EXP 60
25478: PPUSH
25479: LD_INT 92
25481: PPUSH
25482: LD_INT 39
25484: PPUSH
25485: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25489: LD_EXP 60
25493: PPUSH
25494: LD_INT 88
25496: PPUSH
25497: LD_INT 41
25499: PPUSH
25500: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25504: LD_EXP 60
25508: PPUSH
25509: LD_INT 91
25511: PPUSH
25512: LD_INT 44
25514: PPUSH
25515: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25519: LD_EXP 60
25523: PPUSH
25524: LD_INT 96
25526: PPUSH
25527: LD_INT 44
25529: PPUSH
25530: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25534: LD_EXP 60
25538: PPUSH
25539: LD_INT 96
25541: PPUSH
25542: LD_INT 41
25544: PPUSH
25545: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25549: LD_EXP 60
25553: PPUSH
25554: LD_INT 92
25556: PPUSH
25557: LD_INT 39
25559: PPUSH
25560: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25564: LD_EXP 60
25568: PPUSH
25569: LD_INT 88
25571: PPUSH
25572: LD_INT 41
25574: PPUSH
25575: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25579: LD_EXP 60
25583: PPUSH
25584: LD_INT 91
25586: PPUSH
25587: LD_INT 44
25589: PPUSH
25590: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
25594: LD_EXP 60
25598: PPUSH
25599: LD_INT 93
25601: PPUSH
25602: LD_INT 39
25604: PPUSH
25605: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
25609: LD_EXP 60
25613: PPUSH
25614: LD_INT 93
25616: PPUSH
25617: LD_INT 36
25619: PPUSH
25620: CALL_OW 171
// wait ( 0 0$3.5 ) ;
25624: LD_INT 122
25626: PPUSH
25627: CALL_OW 67
// game_speed := 4 ;
25631: LD_ADDR_OWVAR 65
25635: PUSH
25636: LD_INT 4
25638: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
25639: LD_EXP 60
25643: PPUSH
25644: LD_STRING D6b-Pow-1b
25646: PPUSH
25647: CALL_OW 88
// tmp := [ ] ;
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: EMPTY
25657: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
25658: LD_ADDR_VAR 0 5
25662: PUSH
25663: LD_INT 78
25665: PUSH
25666: LD_INT 47
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: LD_INT 106
25675: PUSH
25676: LD_INT 53
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
25687: LD_ADDR_VAR 0 1
25691: PUSH
25692: LD_INT 22
25694: PUSH
25695: LD_INT 8
25697: PUSH
25698: EMPTY
25699: LIST
25700: LIST
25701: PUSH
25702: LD_INT 21
25704: PUSH
25705: LD_INT 3
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: PUSH
25712: LD_INT 92
25714: PUSH
25715: LD_INT 90
25717: PUSH
25718: LD_INT 52
25720: PUSH
25721: LD_INT 12
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: LIST
25728: LIST
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: LIST
25734: PPUSH
25735: CALL_OW 69
25739: PUSH
25740: FOR_IN
25741: IFFALSE 25766
// tmp := tmp ^ UnitsInside ( i ) ;
25743: LD_ADDR_VAR 0 3
25747: PUSH
25748: LD_VAR 0 3
25752: PUSH
25753: LD_VAR 0 1
25757: PPUSH
25758: CALL_OW 313
25762: ADD
25763: ST_TO_ADDR
25764: GO 25740
25766: POP
25767: POP
// for i in tmp do
25768: LD_ADDR_VAR 0 1
25772: PUSH
25773: LD_VAR 0 3
25777: PUSH
25778: FOR_IN
25779: IFFALSE 25941
// begin dist := 9999 ;
25781: LD_ADDR_VAR 0 8
25785: PUSH
25786: LD_INT 9999
25788: ST_TO_ADDR
// _xy := [ ] ;
25789: LD_ADDR_VAR 0 7
25793: PUSH
25794: EMPTY
25795: ST_TO_ADDR
// SetTag ( i , 1 ) ;
25796: LD_VAR 0 1
25800: PPUSH
25801: LD_INT 1
25803: PPUSH
25804: CALL_OW 109
// ComExitBuilding ( i ) ;
25808: LD_VAR 0 1
25812: PPUSH
25813: CALL_OW 122
// for j in xy do
25817: LD_ADDR_VAR 0 2
25821: PUSH
25822: LD_VAR 0 5
25826: PUSH
25827: FOR_IN
25828: IFFALSE 25910
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
25830: LD_VAR 0 1
25834: PPUSH
25835: LD_VAR 0 2
25839: PUSH
25840: LD_INT 1
25842: ARRAY
25843: PPUSH
25844: LD_VAR 0 2
25848: PUSH
25849: LD_INT 2
25851: ARRAY
25852: PPUSH
25853: CALL_OW 297
25857: PUSH
25858: LD_VAR 0 8
25862: LESS
25863: IFFALSE 25908
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
25865: LD_ADDR_VAR 0 8
25869: PUSH
25870: LD_VAR 0 1
25874: PPUSH
25875: LD_VAR 0 2
25879: PUSH
25880: LD_INT 1
25882: ARRAY
25883: PPUSH
25884: LD_VAR 0 2
25888: PUSH
25889: LD_INT 2
25891: ARRAY
25892: PPUSH
25893: CALL_OW 297
25897: ST_TO_ADDR
// _xy := j ;
25898: LD_ADDR_VAR 0 7
25902: PUSH
25903: LD_VAR 0 2
25907: ST_TO_ADDR
// end ;
25908: GO 25827
25910: POP
25911: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
25912: LD_VAR 0 1
25916: PPUSH
25917: LD_VAR 0 7
25921: PUSH
25922: LD_INT 1
25924: ARRAY
25925: PPUSH
25926: LD_VAR 0 7
25930: PUSH
25931: LD_INT 2
25933: ARRAY
25934: PPUSH
25935: CALL_OW 171
// end ;
25939: GO 25778
25941: POP
25942: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
25943: LD_ADDR_VAR 0 4
25947: PUSH
25948: LD_VAR 0 3
25952: PPUSH
25953: LD_INT 26
25955: PUSH
25956: LD_INT 1
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 25
25965: PUSH
25966: LD_INT 1
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL_OW 72
25981: ST_TO_ADDR
// if tmp2 < 2 then
25982: LD_VAR 0 4
25986: PUSH
25987: LD_INT 2
25989: LESS
25990: IFFALSE 26059
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
25992: LD_ADDR_VAR 0 4
25996: PUSH
25997: LD_INT 22
25999: PUSH
26000: LD_INT 8
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 26
26009: PUSH
26010: LD_INT 1
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 3
26019: PUSH
26020: LD_INT 25
26022: PUSH
26023: LD_INT 15
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: LIST
26038: PPUSH
26039: CALL_OW 69
26043: PUSH
26044: LD_EXP 62
26048: PUSH
26049: LD_EXP 63
26053: PUSH
26054: EMPTY
26055: LIST
26056: LIST
26057: DIFF
26058: ST_TO_ADDR
// if tmp2 then
26059: LD_VAR 0 4
26063: IFFALSE 26081
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26065: LD_VAR 0 4
26069: PUSH
26070: LD_INT 1
26072: ARRAY
26073: PPUSH
26074: LD_STRING D6b-ArSol1-1
26076: PPUSH
26077: CALL_OW 88
// async ;
26081: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26082: LD_EXP 60
26086: PPUSH
26087: LD_STRING D6b-Pow-2
26089: PPUSH
26090: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26094: LD_INT 18
26096: PPUSH
26097: CALL_OW 67
// if tmp2 > 1 then
26101: LD_VAR 0 4
26105: PUSH
26106: LD_INT 1
26108: GREATER
26109: IFFALSE 26127
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26111: LD_VAR 0 4
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: PPUSH
26120: LD_STRING D6b-ArSol2-1
26122: PPUSH
26123: CALL_OW 88
// sync ;
26127: SYNC
// repeat wait ( 5 ) ;
26128: LD_INT 5
26130: PPUSH
26131: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26135: LD_INT 93
26137: PPUSH
26138: LD_INT 36
26140: PPUSH
26141: CALL_OW 428
26145: PPUSH
26146: CALL_OW 255
26150: PUSH
26151: LD_INT 4
26153: EQUAL
26154: IFFALSE 26128
// DialogueOn ;
26156: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26160: LD_INT 10
26162: PPUSH
26163: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26167: LD_EXP 60
26171: PPUSH
26172: LD_STRING D6b-Pow-2a
26174: PPUSH
26175: CALL_OW 88
// DialogueOff ;
26179: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26183: LD_EXP 60
26187: PPUSH
26188: CALL_OW 310
26192: PPUSH
26193: LD_INT 332
26195: PPUSH
26196: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26200: LD_INT 93
26202: PPUSH
26203: LD_INT 35
26205: PPUSH
26206: LD_INT 1
26208: PPUSH
26209: LD_INT 6
26211: NEG
26212: PPUSH
26213: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26217: LD_INT 35
26219: PPUSH
26220: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26224: LD_INT 332
26226: PPUSH
26227: CALL_OW 256
26231: PUSH
26232: LD_INT 1000
26234: LESS
26235: PUSH
26236: LD_INT 332
26238: PPUSH
26239: CALL_OW 300
26243: AND
26244: IFFALSE 26256
// SetLives ( kozlov_fac , 0 ) ;
26246: LD_INT 332
26248: PPUSH
26249: LD_INT 0
26251: PPUSH
26252: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26256: LD_INT 332
26258: PPUSH
26259: CALL_OW 301
26263: PUSH
26264: LD_EXP 60
26268: PPUSH
26269: CALL_OW 301
26273: OR
26274: IFFALSE 26217
// game_speed := 4 ;
26276: LD_ADDR_OWVAR 65
26280: PUSH
26281: LD_INT 4
26283: ST_TO_ADDR
// powellCenterCameraMode := false ;
26284: LD_ADDR_EXP 20
26288: PUSH
26289: LD_INT 0
26291: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26292: LD_ADDR_VAR 0 1
26296: PUSH
26297: LD_VAR 0 3
26301: PUSH
26302: LD_INT 22
26304: PUSH
26305: LD_INT 8
26307: PUSH
26308: EMPTY
26309: LIST
26310: LIST
26311: PUSH
26312: LD_INT 25
26314: PUSH
26315: LD_INT 2
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PPUSH
26326: CALL_OW 69
26330: UNION
26331: PUSH
26332: FOR_IN
26333: IFFALSE 26349
// SetTag ( i , 0 ) ;
26335: LD_VAR 0 1
26339: PPUSH
26340: LD_INT 0
26342: PPUSH
26343: CALL_OW 109
26347: GO 26332
26349: POP
26350: POP
// wait ( 0 0$3 ) ;
26351: LD_INT 105
26353: PPUSH
26354: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26358: LD_INT 93
26360: PPUSH
26361: LD_INT 35
26363: PPUSH
26364: LD_INT 1
26366: PPUSH
26367: CALL_OW 331
// DialogueOn ;
26371: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
26375: LD_VAR 0 11
26379: PPUSH
26380: LD_STRING D6c-Sol3-1
26382: PPUSH
26383: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
26387: LD_INT 10
26389: PPUSH
26390: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
26394: LD_EXP 40
26398: PPUSH
26399: LD_STRING D6c-JMM-1
26401: PPUSH
26402: CALL_OW 88
// if Cyrus then
26406: LD_EXP 46
26410: IFFALSE 26424
// Say ( Cyrus , D6c-Cyrus-1 ) ;
26412: LD_EXP 46
26416: PPUSH
26417: LD_STRING D6c-Cyrus-1
26419: PPUSH
26420: CALL_OW 88
// if Bobby then
26424: LD_EXP 45
26428: IFFALSE 26442
// Say ( Bobby , D6c-Bobby-1 ) ;
26430: LD_EXP 45
26434: PPUSH
26435: LD_STRING D6c-Bobby-1
26437: PPUSH
26438: CALL_OW 88
// if Cornel then
26442: LD_EXP 51
26446: IFFALSE 26460
// Say ( Cornel , D6c-Corn-1 ) ;
26448: LD_EXP 51
26452: PPUSH
26453: LD_STRING D6c-Corn-1
26455: PPUSH
26456: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
26460: LD_ADDR_VAR 0 4
26464: PUSH
26465: LD_INT 2
26467: PUSH
26468: LD_INT 22
26470: PUSH
26471: LD_INT 1
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 22
26480: PUSH
26481: LD_INT 4
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 26
26495: PUSH
26496: LD_INT 1
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 23
26505: PUSH
26506: LD_INT 1
26508: PUSH
26509: EMPTY
26510: LIST
26511: LIST
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: LIST
26517: PPUSH
26518: CALL_OW 69
26522: PUSH
26523: LD_VAR 0 11
26527: PUSH
26528: LD_EXP 40
26532: UNION
26533: PUSH
26534: LD_EXP 61
26538: UNION
26539: DIFF
26540: ST_TO_ADDR
// if tmp2 then
26541: LD_VAR 0 4
26545: IFFALSE 26563
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
26547: LD_VAR 0 4
26551: PUSH
26552: LD_INT 1
26554: ARRAY
26555: PPUSH
26556: LD_STRING D6c-Sol1-1
26558: PPUSH
26559: CALL_OW 88
// if Lisa then
26563: LD_EXP 43
26567: IFFALSE 26581
// Say ( Lisa , D6c-Lisa-1 ) ;
26569: LD_EXP 43
26573: PPUSH
26574: LD_STRING D6c-Lisa-1
26576: PPUSH
26577: CALL_OW 88
// if Gary then
26581: LD_EXP 52
26585: IFFALSE 26599
// Say ( Gary , D6c-Gary-1 ) ;
26587: LD_EXP 52
26591: PPUSH
26592: LD_STRING D6c-Gary-1
26594: PPUSH
26595: CALL_OW 88
// if Donaldson then
26599: LD_EXP 44
26603: IFFALSE 26617
// Say ( Donaldson , D6c-Don-1 ) ;
26605: LD_EXP 44
26609: PPUSH
26610: LD_STRING D6c-Don-1
26612: PPUSH
26613: CALL_OW 88
// if tmp2 > 1 then
26617: LD_VAR 0 4
26621: PUSH
26622: LD_INT 1
26624: GREATER
26625: IFFALSE 26643
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
26627: LD_VAR 0 4
26631: PUSH
26632: LD_INT 2
26634: ARRAY
26635: PPUSH
26636: LD_STRING D6c-Sol2-1
26638: PPUSH
26639: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
26643: LD_VAR 0 11
26647: PPUSH
26648: LD_STRING D6c-Sol3-2
26650: PPUSH
26651: CALL_OW 88
// if IsInUnit ( JMM ) then
26655: LD_EXP 40
26659: PPUSH
26660: CALL_OW 310
26664: IFFALSE 26682
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
26666: LD_EXP 40
26670: PPUSH
26671: CALL_OW 310
26675: PPUSH
26676: CALL_OW 87
26680: GO 26691
// CenterNowOnUnits ( JMM ) ;
26682: LD_EXP 40
26686: PPUSH
26687: CALL_OW 87
// dwait ( 0 0$2 ) ;
26691: LD_INT 70
26693: PPUSH
26694: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
26698: LD_EXP 40
26702: PPUSH
26703: LD_STRING D6c-JMM-2
26705: PPUSH
26706: CALL_OW 88
// DialogueOff ;
26710: CALL_OW 7
// Video ( false ) ;
26714: LD_INT 0
26716: PPUSH
26717: CALL 105821 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
26721: LD_INT 22
26723: PUSH
26724: LD_INT 4
26726: PUSH
26727: EMPTY
26728: LIST
26729: LIST
26730: PPUSH
26731: CALL_OW 69
26735: PPUSH
26736: LD_INT 1
26738: PPUSH
26739: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
26743: LD_INT 4
26745: PPUSH
26746: LD_INT 4
26748: PPUSH
26749: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
26753: LD_ADDR_VAR 0 1
26757: PUSH
26758: LD_INT 4
26760: PPUSH
26761: LD_INT 1
26763: PPUSH
26764: LD_INT 2
26766: PPUSH
26767: CALL 68620 0 3
26771: PUSH
26772: FOR_IN
26773: IFFALSE 26810
// if GetTech ( i , 1 ) <> state_researched then
26775: LD_VAR 0 1
26779: PPUSH
26780: LD_INT 1
26782: PPUSH
26783: CALL_OW 321
26787: PUSH
26788: LD_INT 2
26790: NONEQUAL
26791: IFFALSE 26808
// SetTech ( i , 1 , state_researched ) ;
26793: LD_VAR 0 1
26797: PPUSH
26798: LD_INT 1
26800: PPUSH
26801: LD_INT 2
26803: PPUSH
26804: CALL_OW 322
26808: GO 26772
26810: POP
26811: POP
// missionStage := 6 ;
26812: LD_ADDR_EXP 15
26816: PUSH
26817: LD_INT 6
26819: ST_TO_ADDR
// activeAttacks := true ;
26820: LD_ADDR_EXP 16
26824: PUSH
26825: LD_INT 1
26827: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
26828: LD_STRING M2
26830: PPUSH
26831: CALL_OW 337
// SaveForQuickRestart ;
26835: CALL_OW 22
// wait ( 0 0$40 ) ;
26839: LD_INT 1400
26841: PPUSH
26842: CALL_OW 67
// DialogueOn ;
26846: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
26850: LD_EXP 64
26854: PPUSH
26855: LD_STRING D7-Friend-1
26857: PPUSH
26858: CALL 109768 0 2
// Say ( JMM , D7-JMM-1 ) ;
26862: LD_EXP 40
26866: PPUSH
26867: LD_STRING D7-JMM-1
26869: PPUSH
26870: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
26874: LD_EXP 64
26878: PPUSH
26879: LD_STRING D7-Friend-2
26881: PPUSH
26882: CALL 109768 0 2
// Say ( JMM , D7-JMM-2 ) ;
26886: LD_EXP 40
26890: PPUSH
26891: LD_STRING D7-JMM-2
26893: PPUSH
26894: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
26898: LD_EXP 64
26902: PPUSH
26903: LD_STRING D7-Friend-3
26905: PPUSH
26906: CALL 109768 0 2
// Say ( JMM , D7-JMM-3 ) ;
26910: LD_EXP 40
26914: PPUSH
26915: LD_STRING D7-JMM-3
26917: PPUSH
26918: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
26922: LD_EXP 64
26926: PPUSH
26927: LD_STRING D7-Friend-4
26929: PPUSH
26930: CALL 109768 0 2
// Say ( JMM , D7-JMM-4 ) ;
26934: LD_EXP 40
26938: PPUSH
26939: LD_STRING D7-JMM-4
26941: PPUSH
26942: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
26946: LD_EXP 64
26950: PPUSH
26951: LD_STRING D7-Friend-5
26953: PPUSH
26954: CALL 109768 0 2
// Say ( JMM , D7-JMM-5 ) ;
26958: LD_EXP 40
26962: PPUSH
26963: LD_STRING D7-JMM-5
26965: PPUSH
26966: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
26970: LD_EXP 64
26974: PPUSH
26975: LD_STRING D7-Friend-6
26977: PPUSH
26978: CALL 109768 0 2
// Say ( JMM , D7-JMM-6 ) ;
26982: LD_EXP 40
26986: PPUSH
26987: LD_STRING D7-JMM-6
26989: PPUSH
26990: CALL_OW 88
// DialogueOff ;
26994: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
26998: LD_STRING Mlegion
27000: PPUSH
27001: CALL_OW 337
// skirmish := true ;
27005: LD_ADDR_EXP 98
27009: PUSH
27010: LD_INT 1
27012: ST_TO_ADDR
// RebuildKozlovFactory ;
27013: CALL 5046 0 0
// end ;
27017: PPOPN 13
27019: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27020: LD_EXP 20
27024: PUSH
27025: LD_EXP 60
27029: PPUSH
27030: CALL_OW 300
27034: AND
27035: IFFALSE 27077
27037: GO 27039
27039: DISABLE
// begin enable ;
27040: ENABLE
// if IsInUnit ( Powell ) then
27041: LD_EXP 60
27045: PPUSH
27046: CALL_OW 310
27050: IFFALSE 27068
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27052: LD_EXP 60
27056: PPUSH
27057: CALL_OW 310
27061: PPUSH
27062: CALL_OW 85
27066: GO 27077
// CenterOnUnits ( Powell ) ;
27068: LD_EXP 60
27072: PPUSH
27073: CALL_OW 85
// end ;
27077: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27078: LD_INT 22
27080: PUSH
27081: LD_INT 8
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: LD_INT 34
27090: PUSH
27091: LD_INT 48
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PPUSH
27102: CALL_OW 69
27106: IFFALSE 27380
27108: GO 27110
27110: DISABLE
27111: LD_INT 0
27113: PPUSH
27114: PPUSH
// begin if missionStage < 9 then
27115: LD_EXP 15
27119: PUSH
27120: LD_INT 9
27122: LESS
27123: IFFALSE 27133
// missionStage := 9 ;
27125: LD_ADDR_EXP 15
27129: PUSH
27130: LD_INT 9
27132: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27133: LD_ADDR_VAR 0 1
27137: PUSH
27138: LD_INT 22
27140: PUSH
27141: LD_INT 8
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 34
27150: PUSH
27151: LD_INT 48
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PPUSH
27162: CALL_OW 69
27166: PUSH
27167: LD_INT 1
27169: ARRAY
27170: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27171: LD_INT 175
27173: PPUSH
27174: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27178: LD_EXP 12
27182: PUSH
27183: LD_EXP 3
27187: PUSH
27188: LD_INT 0
27190: PUSH
27191: LD_INT 2
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: IN
27198: OR
27199: IFFALSE 27222
// target := [ 68 , 108 , 1 ] else
27201: LD_ADDR_VAR 0 2
27205: PUSH
27206: LD_INT 68
27208: PUSH
27209: LD_INT 108
27211: PUSH
27212: LD_INT 1
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: LIST
27219: ST_TO_ADDR
27220: GO 27241
// target := [ 181 , 88 , 2 ] ;
27222: LD_ADDR_VAR 0 2
27226: PUSH
27227: LD_INT 181
27229: PUSH
27230: LD_INT 88
27232: PUSH
27233: LD_INT 2
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: LIST
27240: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27241: LD_VAR 0 1
27245: PPUSH
27246: LD_VAR 0 2
27250: PUSH
27251: LD_INT 1
27253: ARRAY
27254: PPUSH
27255: LD_VAR 0 2
27259: PUSH
27260: LD_INT 2
27262: ARRAY
27263: PPUSH
27264: CALL_OW 176
// if target [ 3 ] = 1 then
27268: LD_VAR 0 2
27272: PUSH
27273: LD_INT 3
27275: ARRAY
27276: PUSH
27277: LD_INT 1
27279: EQUAL
27280: IFFALSE 27296
// SayRadio ( Kurt , D12-Kurt-1 ) else
27282: LD_EXP 62
27286: PPUSH
27287: LD_STRING D12-Kurt-1
27289: PPUSH
27290: CALL_OW 94
27294: GO 27320
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27296: LD_EXP 62
27300: PPUSH
27301: LD_STRING D12a-Kurt-1
27303: PPUSH
27304: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27308: LD_EXP 77
27312: PPUSH
27313: LD_STRING D12a-Roth-1
27315: PPUSH
27316: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27320: LD_INT 350
27322: PPUSH
27323: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27327: LD_VAR 0 1
27331: PPUSH
27332: LD_INT 22
27334: PUSH
27335: LD_INT 8
27337: PUSH
27338: EMPTY
27339: LIST
27340: LIST
27341: PUSH
27342: LD_INT 23
27344: PUSH
27345: LD_INT 2
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: LD_INT 30
27354: PUSH
27355: LD_INT 3
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: LIST
27366: PPUSH
27367: CALL_OW 69
27371: PUSH
27372: LD_INT 1
27374: ARRAY
27375: PPUSH
27376: CALL_OW 228
// end ;
27380: PPOPN 2
27382: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
27383: LD_EXP 62
27387: PPUSH
27388: CALL_OW 256
27392: PUSH
27393: LD_INT 999
27395: LESS
27396: PUSH
27397: LD_INT 22
27399: PUSH
27400: LD_INT 8
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: LD_INT 21
27409: PUSH
27410: LD_INT 1
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 23
27419: PUSH
27420: LD_INT 2
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: LIST
27431: PPUSH
27432: CALL_OW 69
27436: PUSH
27437: LD_INT 9
27439: PUSH
27440: LD_INT 8
27442: PUSH
27443: LD_INT 7
27445: PUSH
27446: LD_INT 6
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: PUSH
27455: LD_OWVAR 67
27459: ARRAY
27460: LESSEQUAL
27461: OR
27462: PUSH
27463: LD_INT 22
27465: PUSH
27466: LD_INT 8
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 34
27475: PUSH
27476: LD_INT 48
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PPUSH
27487: CALL_OW 69
27491: NOT
27492: AND
27493: PUSH
27494: LD_EXP 62
27498: PPUSH
27499: CALL_OW 302
27503: AND
27504: PUSH
27505: LD_INT 5
27507: PPUSH
27508: LD_INT 22
27510: PUSH
27511: LD_INT 1
27513: PUSH
27514: EMPTY
27515: LIST
27516: LIST
27517: PPUSH
27518: CALL_OW 70
27522: AND
27523: IFFALSE 28267
27525: GO 27527
27527: DISABLE
27528: LD_INT 0
27530: PPUSH
27531: PPUSH
27532: PPUSH
// begin legionDestroyed := true ;
27533: LD_ADDR_EXP 22
27537: PUSH
27538: LD_INT 1
27540: ST_TO_ADDR
// DialogueOn ;
27541: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
27545: LD_EXP 40
27549: PPUSH
27550: LD_STRING D13-JMM-1
27552: PPUSH
27553: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
27557: LD_EXP 62
27561: PPUSH
27562: LD_STRING D13-Kurt-1
27564: PPUSH
27565: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
27569: LD_EXP 40
27573: PPUSH
27574: LD_STRING D13-JMM-2
27576: PPUSH
27577: CALL_OW 88
// if FakeInfo then
27581: LD_EXP 12
27585: IFFALSE 27605
// begin Say ( Kurt , D13-Kurt-2 ) ;
27587: LD_EXP 62
27591: PPUSH
27592: LD_STRING D13-Kurt-2
27594: PPUSH
27595: CALL_OW 88
// DialogueOff ;
27599: CALL_OW 7
// exit ;
27603: GO 28267
// end ; if not KurtStatus then
27605: LD_EXP 3
27609: NOT
27610: IFFALSE 27626
// Say ( Kurt , D13-Kurt-2b ) else
27612: LD_EXP 62
27616: PPUSH
27617: LD_STRING D13-Kurt-2b
27619: PPUSH
27620: CALL_OW 88
27624: GO 27638
// Say ( Kurt , D13-Kurt-2a ) ;
27626: LD_EXP 62
27630: PPUSH
27631: LD_STRING D13-Kurt-2a
27633: PPUSH
27634: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
27638: LD_EXP 40
27642: PPUSH
27643: LD_STRING D13-JMM-3
27645: PPUSH
27646: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
27650: LD_EXP 62
27654: PPUSH
27655: LD_STRING D13-Kurt-3
27657: PPUSH
27658: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
27662: LD_EXP 40
27666: PPUSH
27667: LD_STRING D13-JMM-4
27669: PPUSH
27670: CALL_OW 88
// DialogueOff ;
27674: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
27678: LD_STRING MlegionOut
27680: PPUSH
27681: CALL_OW 337
// MC_Kill ( 3 ) ;
27685: LD_INT 3
27687: PPUSH
27688: CALL 38120 0 1
// KillUnit ( Kozlov ) ;
27692: LD_EXP 63
27696: PPUSH
27697: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
27701: LD_ADDR_VAR 0 1
27705: PUSH
27706: LD_INT 22
27708: PUSH
27709: LD_INT 8
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 23
27718: PUSH
27719: LD_INT 3
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 3
27728: PUSH
27729: LD_INT 21
27731: PUSH
27732: LD_INT 33
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: LIST
27747: PPUSH
27748: CALL_OW 69
27752: PUSH
27753: FOR_IN
27754: IFFALSE 27767
// KillUnit ( i ) ;
27756: LD_VAR 0 1
27760: PPUSH
27761: CALL_OW 66
27765: GO 27753
27767: POP
27768: POP
// ChangeSideFog ( 8 , 1 ) ;
27769: LD_INT 8
27771: PPUSH
27772: LD_INT 1
27774: PPUSH
27775: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
27779: LD_ADDR_VAR 0 2
27783: PUSH
27784: LD_INT 22
27786: PUSH
27787: LD_INT 8
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 21
27796: PUSH
27797: LD_INT 1
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PPUSH
27808: CALL_OW 69
27812: PUSH
27813: LD_EXP 63
27817: PUSH
27818: LD_EXP 62
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: DIFF
27827: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
27828: LD_VAR 0 2
27832: PUSH
27833: LD_INT 6
27835: PUSH
27836: LD_INT 5
27838: PUSH
27839: LD_INT 4
27841: PUSH
27842: LD_INT 3
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: PUSH
27851: LD_OWVAR 67
27855: ARRAY
27856: GREATEREQUAL
27857: IFFALSE 28009
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
27859: LD_ADDR_VAR 0 3
27863: PUSH
27864: LD_INT 6
27866: PUSH
27867: LD_INT 5
27869: PUSH
27870: LD_INT 4
27872: PUSH
27873: LD_INT 3
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: PUSH
27882: LD_OWVAR 67
27886: ARRAY
27887: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
27888: LD_ADDR_VAR 0 1
27892: PUSH
27893: DOUBLE
27894: LD_VAR 0 2
27898: PUSH
27899: LD_VAR 0 3
27903: PUSH
27904: LD_INT 1
27906: PLUS
27907: MINUS
27908: INC
27909: ST_TO_ADDR
27910: LD_INT 1
27912: PUSH
27913: FOR_DOWNTO
27914: IFFALSE 28005
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
27916: LD_ADDR_EXP 38
27920: PUSH
27921: LD_EXP 38
27925: PUSH
27926: LD_VAR 0 2
27930: PUSH
27931: LD_VAR 0 1
27935: ARRAY
27936: ADD
27937: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
27938: LD_VAR 0 2
27942: PUSH
27943: LD_VAR 0 1
27947: ARRAY
27948: PPUSH
27949: CALL_OW 310
27953: IFFALSE 27970
// ComExit ( tmp [ i ] ) ;
27955: LD_VAR 0 2
27959: PUSH
27960: LD_VAR 0 1
27964: ARRAY
27965: PPUSH
27966: CALL 106247 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
27970: LD_VAR 0 2
27974: PUSH
27975: LD_VAR 0 1
27979: ARRAY
27980: PPUSH
27981: LD_INT 34
27983: PUSH
27984: LD_INT 0
27986: PPUSH
27987: LD_INT 6
27989: PPUSH
27990: CALL_OW 12
27994: PLUS
27995: PPUSH
27996: LD_INT 1
27998: PPUSH
27999: CALL_OW 171
// end ;
28003: GO 27913
28005: POP
28006: POP
// end else
28007: GO 28019
// x := tmp ;
28009: LD_ADDR_VAR 0 3
28013: PUSH
28014: LD_VAR 0 2
28018: ST_TO_ADDR
// for i := tmp downto tmp - x do
28019: LD_ADDR_VAR 0 1
28023: PUSH
28024: DOUBLE
28025: LD_VAR 0 2
28029: INC
28030: ST_TO_ADDR
28031: LD_VAR 0 2
28035: PUSH
28036: LD_VAR 0 3
28040: MINUS
28041: PUSH
28042: FOR_DOWNTO
28043: IFFALSE 28097
// begin if IsInUnit ( tmp [ i ] ) then
28045: LD_VAR 0 2
28049: PUSH
28050: LD_VAR 0 1
28054: ARRAY
28055: PPUSH
28056: CALL_OW 310
28060: IFFALSE 28077
// ComExit ( tmp [ i ] ) ;
28062: LD_VAR 0 2
28066: PUSH
28067: LD_VAR 0 1
28071: ARRAY
28072: PPUSH
28073: CALL 106247 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28077: LD_VAR 0 2
28081: PUSH
28082: LD_VAR 0 1
28086: ARRAY
28087: PPUSH
28088: LD_INT 1
28090: PPUSH
28091: CALL_OW 235
// end ;
28095: GO 28042
28097: POP
28098: POP
// wait ( 0 0$0.3 ) ;
28099: LD_INT 10
28101: PPUSH
28102: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28106: LD_ADDR_VAR 0 1
28110: PUSH
28111: LD_INT 22
28113: PUSH
28114: LD_INT 8
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 21
28123: PUSH
28124: LD_INT 2
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: PPUSH
28135: CALL_OW 69
28139: PUSH
28140: FOR_IN
28141: IFFALSE 28154
// KillUnit ( i ) ;
28143: LD_VAR 0 1
28147: PPUSH
28148: CALL_OW 66
28152: GO 28140
28154: POP
28155: POP
// SetSide ( Kurt , 1 ) ;
28156: LD_EXP 62
28160: PPUSH
28161: LD_INT 1
28163: PPUSH
28164: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28168: LD_INT 22
28170: PUSH
28171: LD_INT 8
28173: PUSH
28174: EMPTY
28175: LIST
28176: LIST
28177: PUSH
28178: LD_INT 21
28180: PUSH
28181: LD_INT 3
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PPUSH
28192: CALL_OW 69
28196: PPUSH
28197: LD_INT 1
28199: PPUSH
28200: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28204: LD_INT 8
28206: PPUSH
28207: LD_INT 1
28209: PPUSH
28210: LD_INT 1
28212: PPUSH
28213: LD_INT 1
28215: PPUSH
28216: CALL_OW 80
// wait ( 1 1$20 ) ;
28220: LD_INT 2800
28222: PPUSH
28223: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28227: LD_EXP 64
28231: PPUSH
28232: LD_INT 37
28234: PPUSH
28235: LD_INT 1
28237: PPUSH
28238: LD_INT 0
28240: PPUSH
28241: CALL_OW 48
// wait ( 0 0$1 ) ;
28245: LD_INT 35
28247: PPUSH
28248: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28252: LD_EXP 64
28256: PPUSH
28257: LD_INT 60
28259: PPUSH
28260: LD_INT 95
28262: PPUSH
28263: CALL_OW 111
// end ;
28267: PPOPN 3
28269: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28270: LD_EXP 22
28274: NOT
28275: PUSH
28276: LD_INT 22
28278: PUSH
28279: LD_INT 8
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 21
28288: PUSH
28289: LD_INT 1
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PPUSH
28300: CALL_OW 69
28304: PUSH
28305: LD_INT 0
28307: EQUAL
28308: AND
28309: IFFALSE 28329
28311: GO 28313
28313: DISABLE
// begin legionDestroyed := true ;
28314: LD_ADDR_EXP 22
28318: PUSH
28319: LD_INT 1
28321: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28322: LD_STRING MlegionOut
28324: PPUSH
28325: CALL_OW 337
// end ;
28329: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28330: LD_EXP 38
28334: IFFALSE 28409
28336: GO 28338
28338: DISABLE
28339: LD_INT 0
28341: PPUSH
// begin enable ;
28342: ENABLE
// for i in legionEscapeUnits do
28343: LD_ADDR_VAR 0 1
28347: PUSH
28348: LD_EXP 38
28352: PUSH
28353: FOR_IN
28354: IFFALSE 28407
// begin if IsInArea ( i , legionEscapeArea ) then
28356: LD_VAR 0 1
28360: PPUSH
28361: LD_INT 31
28363: PPUSH
28364: CALL_OW 308
28368: IFFALSE 28381
// RemoveUnit ( i ) else
28370: LD_VAR 0 1
28374: PPUSH
28375: CALL_OW 64
28379: GO 28405
// if not HasTask ( i ) then
28381: LD_VAR 0 1
28385: PPUSH
28386: CALL_OW 314
28390: NOT
28391: IFFALSE 28405
// ComMoveToArea ( i , legionEscapeArea ) ;
28393: LD_VAR 0 1
28397: PPUSH
28398: LD_INT 31
28400: PPUSH
28401: CALL_OW 113
// end ;
28405: GO 28353
28407: POP
28408: POP
// end ;
28409: PPOPN 1
28411: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
28412: LD_INT 1
28414: PPUSH
28415: LD_EXP 64
28419: PPUSH
28420: CALL_OW 292
28424: IFFALSE 28722
28426: GO 28428
28428: DISABLE
28429: LD_INT 0
28431: PPUSH
// begin wait ( 0 0$2 ) ;
28432: LD_INT 70
28434: PPUSH
28435: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28439: LD_EXP 64
28443: PPUSH
28444: CALL_OW 87
// DialogueOn ;
28448: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
28452: LD_EXP 40
28456: PPUSH
28457: LD_STRING D14-JMM-1
28459: PPUSH
28460: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
28464: LD_EXP 64
28468: PPUSH
28469: LD_STRING D14-Friend-1
28471: PPUSH
28472: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
28476: LD_EXP 40
28480: PPUSH
28481: LD_STRING D14-JMM-2
28483: PPUSH
28484: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
28488: LD_EXP 64
28492: PPUSH
28493: LD_STRING D14-Friend-2
28495: PPUSH
28496: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
28500: LD_EXP 40
28504: PPUSH
28505: LD_STRING D14-JMM-3
28507: PPUSH
28508: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
28512: LD_EXP 64
28516: PPUSH
28517: LD_STRING D14-Friend-3
28519: PPUSH
28520: CALL_OW 88
// DialogueOff ;
28524: CALL_OW 7
// dec = Query ( Q14 ) ;
28528: LD_ADDR_VAR 0 1
28532: PUSH
28533: LD_STRING Q14
28535: PPUSH
28536: CALL_OW 97
28540: ST_TO_ADDR
// if dec = 1 then
28541: LD_VAR 0 1
28545: PUSH
28546: LD_INT 1
28548: EQUAL
28549: IFFALSE 28583
// begin DialogueOn ;
28551: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
28555: LD_EXP 40
28559: PPUSH
28560: LD_STRING D14a-JMM-1
28562: PPUSH
28563: CALL_OW 88
// DialogueOff ;
28567: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28571: LD_EXP 64
28575: PPUSH
28576: LD_INT 1
28578: PPUSH
28579: CALL_OW 235
// end ; if dec = 2 then
28583: LD_VAR 0 1
28587: PUSH
28588: LD_INT 2
28590: EQUAL
28591: IFFALSE 28644
// begin DialogueOn ;
28593: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
28597: LD_EXP 40
28601: PPUSH
28602: LD_STRING D14b-JMM-1
28604: PPUSH
28605: CALL_OW 88
// DialogueOff ;
28609: CALL_OW 7
// wait ( 0 0$1 ) ;
28613: LD_INT 35
28615: PPUSH
28616: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
28620: LD_EXP 64
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 111
// AddComHold ( Friend ) ;
28635: LD_EXP 64
28639: PPUSH
28640: CALL_OW 200
// end ; if dec = 3 then
28644: LD_VAR 0 1
28648: PUSH
28649: LD_INT 3
28651: EQUAL
28652: IFFALSE 28722
// begin DialogueOn ;
28654: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
28658: LD_EXP 40
28662: PPUSH
28663: LD_STRING D14c-JMM-1
28665: PPUSH
28666: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
28670: LD_EXP 64
28674: PPUSH
28675: LD_STRING D14c-Friend-1
28677: PPUSH
28678: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
28682: LD_EXP 40
28686: PPUSH
28687: LD_STRING D14c-JMM-2
28689: PPUSH
28690: CALL_OW 88
// DialogueOff ;
28694: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
28698: LD_EXP 64
28702: PPUSH
28703: LD_INT 9
28705: PPUSH
28706: LD_INT 2
28708: PPUSH
28709: CALL_OW 111
// AddComHold ( Friend ) ;
28713: LD_EXP 64
28717: PPUSH
28718: CALL_OW 200
// end ; end ;
28722: PPOPN 1
28724: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
28725: LD_INT 9
28727: PPUSH
28728: LD_INT 2
28730: PPUSH
28731: CALL_OW 428
28735: PUSH
28736: LD_EXP 64
28740: EQUAL
28741: PUSH
28742: LD_EXP 64
28746: PPUSH
28747: CALL_OW 255
28751: PUSH
28752: LD_INT 8
28754: EQUAL
28755: AND
28756: IFFALSE 28770
28758: GO 28760
28760: DISABLE
// RemoveUnit ( Friend ) ;
28761: LD_EXP 64
28765: PPUSH
28766: CALL_OW 64
28770: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
28771: LD_EXP 14
28775: PUSH
28776: LD_INT 31500
28778: GREATEREQUAL
28779: PUSH
28780: LD_EXP 7
28784: AND
28785: PUSH
28786: LD_EXP 2
28790: AND
28791: IFFALSE 29221
28793: GO 28795
28795: DISABLE
28796: LD_INT 0
28798: PPUSH
28799: PPUSH
28800: PPUSH
// begin missionStage := 7 ;
28801: LD_ADDR_EXP 15
28805: PUSH
28806: LD_INT 7
28808: ST_TO_ADDR
// uc_side = 1 ;
28809: LD_ADDR_OWVAR 20
28813: PUSH
28814: LD_INT 1
28816: ST_TO_ADDR
// uc_nation = 1 ;
28817: LD_ADDR_OWVAR 21
28821: PUSH
28822: LD_INT 1
28824: ST_TO_ADDR
// for i = 1 to 5 do
28825: LD_ADDR_VAR 0 1
28829: PUSH
28830: DOUBLE
28831: LD_INT 1
28833: DEC
28834: ST_TO_ADDR
28835: LD_INT 5
28837: PUSH
28838: FOR_TO
28839: IFFALSE 28935
// begin vc_engine = 3 ;
28841: LD_ADDR_OWVAR 39
28845: PUSH
28846: LD_INT 3
28848: ST_TO_ADDR
// vc_control = 3 ;
28849: LD_ADDR_OWVAR 38
28853: PUSH
28854: LD_INT 3
28856: ST_TO_ADDR
// vc_chassis = 3 ;
28857: LD_ADDR_OWVAR 37
28861: PUSH
28862: LD_INT 3
28864: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28865: LD_ADDR_OWVAR 40
28869: PUSH
28870: LD_INT 5
28872: PUSH
28873: LD_INT 9
28875: PUSH
28876: LD_INT 7
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: PPUSH
28887: LD_INT 3
28889: PPUSH
28890: CALL_OW 12
28894: ARRAY
28895: ST_TO_ADDR
// veh = CreateVehicle ;
28896: LD_ADDR_VAR 0 2
28900: PUSH
28901: CALL_OW 45
28905: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28906: LD_VAR 0 2
28910: PPUSH
28911: LD_INT 1
28913: PPUSH
28914: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28918: LD_VAR 0 2
28922: PPUSH
28923: LD_INT 19
28925: PPUSH
28926: LD_INT 0
28928: PPUSH
28929: CALL_OW 49
// end ;
28933: GO 28838
28935: POP
28936: POP
// vc_engine = 3 ;
28937: LD_ADDR_OWVAR 39
28941: PUSH
28942: LD_INT 3
28944: ST_TO_ADDR
// vc_control = 1 ;
28945: LD_ADDR_OWVAR 38
28949: PUSH
28950: LD_INT 1
28952: ST_TO_ADDR
// vc_chassis = 3 ;
28953: LD_ADDR_OWVAR 37
28957: PUSH
28958: LD_INT 3
28960: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
28961: LD_ADDR_OWVAR 40
28965: PUSH
28966: LD_INT 5
28968: PUSH
28969: LD_INT 9
28971: PUSH
28972: LD_INT 7
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 1
28982: PPUSH
28983: LD_INT 3
28985: PPUSH
28986: CALL_OW 12
28990: ARRAY
28991: ST_TO_ADDR
// vehG = CreateVehicle ;
28992: LD_ADDR_VAR 0 3
28996: PUSH
28997: CALL_OW 45
29001: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29002: LD_VAR 0 3
29006: PPUSH
29007: LD_INT 1
29009: PPUSH
29010: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29014: LD_VAR 0 3
29018: PPUSH
29019: LD_INT 19
29021: PPUSH
29022: LD_INT 0
29024: PPUSH
29025: CALL_OW 49
// if JMMGirl = 1 then
29029: LD_EXP 7
29033: PUSH
29034: LD_INT 1
29036: EQUAL
29037: IFFALSE 29093
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29039: LD_ADDR_EXP 41
29043: PUSH
29044: LD_STRING Joan
29046: PPUSH
29047: LD_INT 1
29049: PPUSH
29050: LD_STRING 14_
29052: PPUSH
29053: CALL 68557 0 3
29057: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29058: LD_EXP 41
29062: PPUSH
29063: LD_VAR 0 3
29067: PPUSH
29068: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29072: LD_VAR 0 3
29076: PPUSH
29077: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29081: LD_EXP 41
29085: PPUSH
29086: LD_STRING D10BW-Joan-1
29088: PPUSH
29089: CALL_OW 94
// end ; if JMMGirl = 2 then
29093: LD_EXP 7
29097: PUSH
29098: LD_INT 2
29100: EQUAL
29101: IFFALSE 29157
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29103: LD_ADDR_EXP 43
29107: PUSH
29108: LD_STRING Lisa
29110: PPUSH
29111: LD_INT 1
29113: PPUSH
29114: LD_STRING 14_
29116: PPUSH
29117: CALL 68557 0 3
29121: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29122: LD_EXP 43
29126: PPUSH
29127: LD_VAR 0 3
29131: PPUSH
29132: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29136: LD_VAR 0 3
29140: PPUSH
29141: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29145: LD_EXP 43
29149: PPUSH
29150: LD_STRING D10BW-Lisa-1
29152: PPUSH
29153: CALL_OW 94
// end ; if JMMGirl = 3 then
29157: LD_EXP 7
29161: PUSH
29162: LD_INT 3
29164: EQUAL
29165: IFFALSE 29221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29167: LD_ADDR_EXP 55
29171: PUSH
29172: LD_STRING Connie
29174: PPUSH
29175: LD_INT 1
29177: PPUSH
29178: LD_STRING 14_
29180: PPUSH
29181: CALL 68557 0 3
29185: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29186: LD_EXP 55
29190: PPUSH
29191: LD_VAR 0 3
29195: PPUSH
29196: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29200: LD_VAR 0 3
29204: PPUSH
29205: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29209: LD_EXP 55
29213: PPUSH
29214: LD_STRING D10BW-Con-1
29216: PPUSH
29217: CALL_OW 94
// end ; end ;
29221: PPOPN 3
29223: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29224: LD_EXP 14
29228: PUSH
29229: LD_INT 94500
29231: GREATEREQUAL
29232: IFFALSE 29644
29234: GO 29236
29236: DISABLE
29237: LD_INT 0
29239: PPUSH
29240: PPUSH
29241: PPUSH
// begin tmp := PrepareStevensSquad ;
29242: LD_ADDR_VAR 0 3
29246: PUSH
29247: CALL 2323 0 0
29251: ST_TO_ADDR
// if not tmp then
29252: LD_VAR 0 3
29256: NOT
29257: IFFALSE 29261
// exit ;
29259: GO 29644
// uc_side := 1 ;
29261: LD_ADDR_OWVAR 20
29265: PUSH
29266: LD_INT 1
29268: ST_TO_ADDR
// uc_nation := 1 ;
29269: LD_ADDR_OWVAR 21
29273: PUSH
29274: LD_INT 1
29276: ST_TO_ADDR
// for i in tmp do
29277: LD_ADDR_VAR 0 1
29281: PUSH
29282: LD_VAR 0 3
29286: PUSH
29287: FOR_IN
29288: IFFALSE 29385
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29290: LD_INT 3
29292: PPUSH
29293: LD_INT 3
29295: PPUSH
29296: LD_INT 1
29298: PPUSH
29299: LD_INT 5
29301: PUSH
29302: LD_INT 9
29304: PUSH
29305: LD_INT 7
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: PPUSH
29316: LD_INT 3
29318: PPUSH
29319: CALL_OW 12
29323: ARRAY
29324: PPUSH
29325: LD_INT 40
29327: PPUSH
29328: CALL 73397 0 5
// veh := CreateVehicle ;
29332: LD_ADDR_VAR 0 2
29336: PUSH
29337: CALL_OW 45
29341: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29342: LD_VAR 0 2
29346: PPUSH
29347: LD_INT 1
29349: PPUSH
29350: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29354: LD_VAR 0 2
29358: PPUSH
29359: LD_INT 19
29361: PPUSH
29362: LD_INT 0
29364: PPUSH
29365: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
29369: LD_VAR 0 1
29373: PPUSH
29374: LD_VAR 0 2
29378: PPUSH
29379: CALL_OW 52
// end ;
29383: GO 29287
29385: POP
29386: POP
// missionStage := 8 ;
29387: LD_ADDR_EXP 15
29391: PUSH
29392: LD_INT 8
29394: ST_TO_ADDR
// DialogueOn ;
29395: CALL_OW 6
// if Stevens then
29399: LD_EXP 42
29403: IFFALSE 29517
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
29405: LD_EXP 42
29409: PPUSH
29410: CALL_OW 310
29414: PPUSH
29415: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
29419: LD_EXP 42
29423: PPUSH
29424: LD_STRING D8-Huck-1
29426: PPUSH
29427: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
29431: LD_EXP 40
29435: PPUSH
29436: LD_STRING D8-JMM-1
29438: PPUSH
29439: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
29443: LD_EXP 42
29447: PPUSH
29448: LD_STRING D8-Huck-2
29450: PPUSH
29451: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29455: LD_EXP 40
29459: PPUSH
29460: LD_STRING D8-JMM-2
29462: PPUSH
29463: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
29467: LD_EXP 42
29471: PPUSH
29472: LD_STRING D8-Huck-3
29474: PPUSH
29475: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29479: LD_EXP 40
29483: PPUSH
29484: LD_STRING D8-JMM-3
29486: PPUSH
29487: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
29491: LD_EXP 42
29495: PPUSH
29496: LD_STRING D8-Huck-4
29498: PPUSH
29499: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29503: LD_EXP 40
29507: PPUSH
29508: LD_STRING D8-JMM-4
29510: PPUSH
29511: CALL_OW 88
// end else
29515: GO 29627
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
29517: LD_EXP 56
29521: PPUSH
29522: CALL_OW 310
29526: PPUSH
29527: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
29531: LD_EXP 56
29535: PPUSH
29536: LD_STRING D8-Huck-1
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
29543: LD_EXP 40
29547: PPUSH
29548: LD_STRING D8-JMM-1a
29550: PPUSH
29551: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
29555: LD_EXP 56
29559: PPUSH
29560: LD_STRING D8-Huck-2
29562: PPUSH
29563: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29567: LD_EXP 40
29571: PPUSH
29572: LD_STRING D8-JMM-2
29574: PPUSH
29575: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
29579: LD_EXP 56
29583: PPUSH
29584: LD_STRING D8-Huck-3
29586: PPUSH
29587: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29591: LD_EXP 40
29595: PPUSH
29596: LD_STRING D8-JMM-3
29598: PPUSH
29599: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
29603: LD_EXP 56
29607: PPUSH
29608: LD_STRING D8-Huck-4
29610: PPUSH
29611: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29615: LD_EXP 40
29619: PPUSH
29620: LD_STRING D8-JMM-4
29622: PPUSH
29623: CALL_OW 88
// end ; DialogueOff ;
29627: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
29631: LD_INT 25
29633: PPUSH
29634: LD_INT 1
29636: PPUSH
29637: LD_INT 1
29639: PPUSH
29640: CALL_OW 322
// end ;
29644: PPOPN 3
29646: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
29647: LD_EXP 73
29651: PPUSH
29652: CALL_OW 302
29656: PUSH
29657: LD_INT 1
29659: PPUSH
29660: LD_EXP 73
29664: PPUSH
29665: CALL_OW 292
29669: AND
29670: IFFALSE 29921
29672: GO 29674
29674: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
29675: LD_EXP 73
29679: PPUSH
29680: CALL_OW 87
// DialogueOn ;
29684: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
29688: LD_EXP 40
29692: PPUSH
29693: LD_STRING D10nB-JMM-1
29695: PPUSH
29696: CALL_OW 88
// if BurlakStatus = 1 then
29700: LD_EXP 9
29704: PUSH
29705: LD_INT 1
29707: EQUAL
29708: IFFALSE 29722
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
29710: LD_EXP 72
29714: PPUSH
29715: LD_STRING D10nB-Vse-1a
29717: PPUSH
29718: CALL_OW 94
// end ; if BurlakStatus = 0 then
29722: LD_EXP 9
29726: PUSH
29727: LD_INT 0
29729: EQUAL
29730: IFFALSE 29744
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
29732: LD_EXP 72
29736: PPUSH
29737: LD_STRING D10nB-Vse-1
29739: PPUSH
29740: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
29744: LD_EXP 40
29748: PPUSH
29749: LD_STRING D10nB-JMM-2
29751: PPUSH
29752: CALL_OW 88
// if KappaStatus then
29756: LD_EXP 2
29760: IFFALSE 29774
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
29762: LD_EXP 72
29766: PPUSH
29767: LD_STRING D10nB-Vse-5a
29769: PPUSH
29770: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
29774: LD_EXP 2
29778: NOT
29779: PUSH
29780: LD_EXP 6
29784: PUSH
29785: LD_INT 0
29787: EQUAL
29788: AND
29789: IFFALSE 29917
// begin if JMMGirl = 1 then
29791: LD_EXP 7
29795: PUSH
29796: LD_INT 1
29798: EQUAL
29799: IFFALSE 29849
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
29801: LD_EXP 72
29805: PPUSH
29806: LD_STRING D10nB-Vse-2
29808: PPUSH
29809: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
29813: LD_EXP 40
29817: PPUSH
29818: LD_STRING D10nB-JMM-3
29820: PPUSH
29821: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
29825: LD_EXP 72
29829: PPUSH
29830: LD_STRING D10nB-Vse-3
29832: PPUSH
29833: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
29837: LD_EXP 40
29841: PPUSH
29842: LD_STRING D10nB-JMM-4
29844: PPUSH
29845: CALL_OW 88
// end ; if JMMGirl = 2 then
29849: LD_EXP 7
29853: PUSH
29854: LD_INT 2
29856: EQUAL
29857: IFFALSE 29883
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
29859: LD_EXP 72
29863: PPUSH
29864: LD_STRING D10nB-Vse-4
29866: PPUSH
29867: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
29871: LD_EXP 40
29875: PPUSH
29876: LD_STRING D10nB-JMM-5
29878: PPUSH
29879: CALL_OW 88
// end ; if JMMGirl = 3 then
29883: LD_EXP 7
29887: PUSH
29888: LD_INT 3
29890: EQUAL
29891: IFFALSE 29917
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
29893: LD_EXP 72
29897: PPUSH
29898: LD_STRING D10nB-Vse-5
29900: PPUSH
29901: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
29905: LD_EXP 40
29909: PPUSH
29910: LD_STRING D10nB-JMM-6
29912: PPUSH
29913: CALL_OW 88
// end ; end ; DialogueOff ;
29917: CALL_OW 7
// end ;
29921: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
29922: LD_EXP 14
29926: PUSH
29927: LD_INT 115500
29929: GREATEREQUAL
29930: PUSH
29931: LD_EXP 67
29935: PPUSH
29936: CALL_OW 302
29940: AND
29941: PUSH
29942: LD_INT 267
29944: PPUSH
29945: CALL_OW 302
29949: AND
29950: IFFALSE 30326
29952: GO 29954
29954: DISABLE
29955: LD_INT 0
29957: PPUSH
// begin missionStage := 10 ;
29958: LD_ADDR_EXP 15
29962: PUSH
29963: LD_INT 10
29965: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
29966: LD_ADDR_VAR 0 1
29970: PUSH
29971: LD_INT 22
29973: PUSH
29974: LD_INT 1
29976: PUSH
29977: EMPTY
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 23
29983: PUSH
29984: LD_INT 1
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 26
29993: PUSH
29994: LD_INT 1
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 3
30003: PUSH
30004: LD_INT 25
30006: PUSH
30007: LD_INT 12
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 3
30020: PUSH
30021: LD_INT 25
30023: PUSH
30024: LD_INT 16
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: PPUSH
30042: CALL_OW 69
30046: PUSH
30047: LD_EXP 40
30051: PUSH
30052: LD_EXP 62
30056: PUSH
30057: LD_EXP 42
30061: PUSH
30062: LD_EXP 56
30066: PUSH
30067: LD_EXP 43
30071: PUSH
30072: LD_EXP 44
30076: PUSH
30077: LD_EXP 45
30081: PUSH
30082: LD_EXP 46
30086: PUSH
30087: LD_EXP 47
30091: PUSH
30092: LD_EXP 48
30096: PUSH
30097: LD_EXP 49
30101: PUSH
30102: LD_EXP 50
30106: PUSH
30107: LD_EXP 51
30111: PUSH
30112: LD_EXP 52
30116: PUSH
30117: LD_EXP 53
30121: PUSH
30122: LD_EXP 54
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: LIST
30143: LIST
30144: DIFF
30145: ST_TO_ADDR
// if not tmp and Brown then
30146: LD_VAR 0 1
30150: NOT
30151: PUSH
30152: LD_EXP 48
30156: AND
30157: IFFALSE 30172
// tmp := [ Brown ] ;
30159: LD_ADDR_VAR 0 1
30163: PUSH
30164: LD_EXP 48
30168: PUSH
30169: EMPTY
30170: LIST
30171: ST_TO_ADDR
// DialogueOn ;
30172: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30176: LD_VAR 0 1
30180: PUSH
30181: LD_INT 1
30183: ARRAY
30184: PPUSH
30185: LD_STRING D11-Sol1-1
30187: PPUSH
30188: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30192: LD_EXP 66
30196: PPUSH
30197: LD_STRING D11-Pla-1
30199: PPUSH
30200: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30204: LD_EXP 67
30208: PPUSH
30209: LD_STRING D11-Kov-1
30211: PPUSH
30212: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30216: LD_EXP 66
30220: PPUSH
30221: LD_STRING D11-Pla-2
30223: PPUSH
30224: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30228: LD_VAR 0 1
30232: PUSH
30233: LD_INT 1
30235: ARRAY
30236: PPUSH
30237: LD_STRING D11-Sol1-2
30239: PPUSH
30240: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30244: LD_EXP 40
30248: PPUSH
30249: LD_STRING D11-JMM-2
30251: PPUSH
30252: CALL_OW 88
// DialogueOff ;
30256: CALL_OW 7
// allowBehemothConstruct := true ;
30260: LD_ADDR_EXP 25
30264: PUSH
30265: LD_INT 1
30267: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30268: LD_STRING M4
30270: PPUSH
30271: CALL_OW 337
// BuildBehemoths ;
30275: CALL 8056 0 0
// repeat wait ( 15 15$00 ) ;
30279: LD_INT 31500
30281: PPUSH
30282: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30286: LD_EXP 27
30290: IFFALSE 30294
// break ;
30292: GO 30326
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30294: LD_INT 267
30296: PPUSH
30297: CALL_OW 274
30301: PPUSH
30302: LD_INT 1
30304: PPUSH
30305: CALL_OW 275
30309: PUSH
30310: LD_INT 1000
30312: GREATEREQUAL
30313: IFFALSE 30319
// BuildBehemoths ;
30315: CALL 8056 0 0
// until not behemothBuilders ;
30319: LD_EXP 75
30323: NOT
30324: IFFALSE 30279
// end ;
30326: PPOPN 1
30328: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30329: LD_EXP 75
30333: NOT
30334: PUSH
30335: LD_EXP 28
30339: NOT
30340: AND
30341: PUSH
30342: LD_EXP 25
30346: AND
30347: IFFALSE 30367
30349: GO 30351
30351: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
30352: LD_STRING M4a
30354: PPUSH
30355: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
30359: LD_ADDR_EXP 27
30363: PUSH
30364: LD_INT 1
30366: ST_TO_ADDR
// end ;
30367: END
// every 0 0$1 trigger behemothDone do
30368: LD_EXP 28
30372: IFFALSE 30384
30374: GO 30376
30376: DISABLE
// ChangeMissionObjectives ( M4b ) ;
30377: LD_STRING M4b
30379: PPUSH
30380: CALL_OW 337
30384: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
30385: LD_EXP 29
30389: NOT
30390: IFFALSE 30586
30392: GO 30394
30394: DISABLE
30395: LD_INT 0
30397: PPUSH
30398: PPUSH
// begin enable ;
30399: ENABLE
// tmp := GetBehemoths ( 3 ) ;
30400: LD_ADDR_VAR 0 1
30404: PUSH
30405: LD_INT 3
30407: PPUSH
30408: CALL 105910 0 1
30412: ST_TO_ADDR
// if not tmp and not behemothDone then
30413: LD_VAR 0 1
30417: NOT
30418: PUSH
30419: LD_EXP 28
30423: NOT
30424: AND
30425: IFFALSE 30461
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
30427: LD_ADDR_VAR 0 1
30431: PUSH
30432: LD_INT 22
30434: PUSH
30435: LD_INT 3
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 30
30444: PUSH
30445: LD_INT 37
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PPUSH
30456: CALL_OW 69
30460: ST_TO_ADDR
// if not tmp then
30461: LD_VAR 0 1
30465: NOT
30466: IFFALSE 30470
// exit ;
30468: GO 30586
// for i in tmp do
30470: LD_ADDR_VAR 0 2
30474: PUSH
30475: LD_VAR 0 1
30479: PUSH
30480: FOR_IN
30481: IFFALSE 30584
// if See ( 1 , i ) then
30483: LD_INT 1
30485: PPUSH
30486: LD_VAR 0 2
30490: PPUSH
30491: CALL_OW 292
30495: IFFALSE 30582
// begin if GetType ( i ) = unit_building then
30497: LD_VAR 0 2
30501: PPUSH
30502: CALL_OW 247
30506: PUSH
30507: LD_INT 3
30509: EQUAL
30510: IFFALSE 30548
// begin disable ;
30512: DISABLE
// CenterNowOnUnits ( i ) ;
30513: LD_VAR 0 2
30517: PPUSH
30518: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
30522: LD_EXP 40
30526: PPUSH
30527: LD_STRING D17a-JMM-1
30529: PPUSH
30530: CALL_OW 88
// seeBehemoth := true ;
30534: LD_ADDR_EXP 29
30538: PUSH
30539: LD_INT 1
30541: ST_TO_ADDR
// exit ;
30542: POP
30543: POP
30544: GO 30586
// end else
30546: GO 30582
// begin disable ;
30548: DISABLE
// CenterNowOnUnits ( i ) ;
30549: LD_VAR 0 2
30553: PPUSH
30554: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
30558: LD_EXP 40
30562: PPUSH
30563: LD_STRING D17b-JMM-1
30565: PPUSH
30566: CALL_OW 88
// seeBehemoth := true ;
30570: LD_ADDR_EXP 29
30574: PUSH
30575: LD_INT 1
30577: ST_TO_ADDR
// exit ;
30578: POP
30579: POP
30580: GO 30586
// end ; end ;
30582: GO 30480
30584: POP
30585: POP
// end ;
30586: PPOPN 2
30588: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
30589: LD_EXP 14
30593: PUSH
30594: LD_INT 123200
30596: GREATEREQUAL
30597: IFFALSE 31797
30599: GO 30601
30601: DISABLE
30602: LD_INT 0
30604: PPUSH
30605: PPUSH
30606: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
30607: LD_INT 2
30609: PPUSH
30610: LD_INT 23
30612: PUSH
30613: LD_INT 3
30615: PUSH
30616: LD_INT 3
30618: PUSH
30619: LD_INT 48
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: PPUSH
30631: CALL 62131 0 2
// repeat wait ( 0 0$1 ) ;
30635: LD_INT 35
30637: PPUSH
30638: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
30642: LD_INT 22
30644: PUSH
30645: LD_INT 3
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 34
30654: PUSH
30655: LD_INT 48
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PPUSH
30666: CALL_OW 69
30670: IFFALSE 30635
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
30672: LD_ADDR_VAR 0 1
30676: PUSH
30677: LD_INT 22
30679: PUSH
30680: LD_INT 3
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 34
30689: PUSH
30690: LD_INT 48
30692: PUSH
30693: EMPTY
30694: LIST
30695: LIST
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PPUSH
30701: CALL_OW 69
30705: PUSH
30706: LD_INT 1
30708: ARRAY
30709: ST_TO_ADDR
// missionStage := 12 ;
30710: LD_ADDR_EXP 15
30714: PUSH
30715: LD_INT 12
30717: ST_TO_ADDR
// platonovHasBomb := true ;
30718: LD_ADDR_EXP 30
30722: PUSH
30723: LD_INT 1
30725: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
30726: LD_VAR 0 1
30730: PPUSH
30731: LD_INT 181
30733: PPUSH
30734: LD_INT 86
30736: PPUSH
30737: CALL_OW 171
// AddComHold ( bomb ) ;
30741: LD_VAR 0 1
30745: PPUSH
30746: CALL_OW 200
// wait ( 0 0$10 ) ;
30750: LD_INT 350
30752: PPUSH
30753: CALL_OW 67
// DialogueOn ;
30757: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
30761: LD_EXP 66
30765: PPUSH
30766: LD_STRING D15-Pla-1
30768: PPUSH
30769: CALL_OW 94
// dec = Query ( Q15a ) ;
30773: LD_ADDR_VAR 0 2
30777: PUSH
30778: LD_STRING Q15a
30780: PPUSH
30781: CALL_OW 97
30785: ST_TO_ADDR
// if dec = 1 then
30786: LD_VAR 0 2
30790: PUSH
30791: LD_INT 1
30793: EQUAL
30794: IFFALSE 30817
// begin Say ( JMM , D15a-JMM-1 ) ;
30796: LD_EXP 40
30800: PPUSH
30801: LD_STRING D15a-JMM-1
30803: PPUSH
30804: CALL_OW 88
// YouLost ( Surrender ) ;
30808: LD_STRING Surrender
30810: PPUSH
30811: CALL_OW 104
// exit ;
30815: GO 31797
// end ; if dec = 2 then
30817: LD_VAR 0 2
30821: PUSH
30822: LD_INT 2
30824: EQUAL
30825: IFFALSE 30894
// begin Say ( JMM , D15b-JMM-1 ) ;
30827: LD_EXP 40
30831: PPUSH
30832: LD_STRING D15b-JMM-1
30834: PPUSH
30835: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
30839: LD_EXP 66
30843: PPUSH
30844: LD_STRING D15b-Pla-1
30846: PPUSH
30847: CALL_OW 94
// DialogueOff ;
30851: CALL_OW 7
// wait ( 3 3$00 ) ;
30855: LD_INT 6300
30857: PPUSH
30858: CALL_OW 67
// DialogueOn ;
30862: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
30866: LD_EXP 40
30870: PPUSH
30871: LD_STRING D15d-JMM-1a
30873: PPUSH
30874: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30878: LD_EXP 66
30882: PPUSH
30883: LD_STRING D15d-Pla-1
30885: PPUSH
30886: CALL_OW 94
// DialogueOff ;
30890: CALL_OW 7
// end ; if dec = 3 then
30894: LD_VAR 0 2
30898: PUSH
30899: LD_INT 3
30901: EQUAL
30902: IFFALSE 30956
// begin Say ( JMM , D15c-JMM-1 ) ;
30904: LD_EXP 40
30908: PPUSH
30909: LD_STRING D15c-JMM-1
30911: PPUSH
30912: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
30916: LD_EXP 66
30920: PPUSH
30921: LD_STRING D15c-Pla-1
30923: PPUSH
30924: CALL_OW 94
// DialogueOff ;
30928: CALL_OW 7
// wait ( 0 0$15 ) ;
30932: LD_INT 525
30934: PPUSH
30935: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
30939: LD_VAR 0 1
30943: PPUSH
30944: LD_INT 60
30946: PPUSH
30947: LD_INT 95
30949: PPUSH
30950: CALL_OW 116
// exit ;
30954: GO 31797
// end ; if dec = 4 then
30956: LD_VAR 0 2
30960: PUSH
30961: LD_INT 4
30963: EQUAL
30964: IFFALSE 30994
// begin Say ( JMM , D15d-JMM-1 ) ;
30966: LD_EXP 40
30970: PPUSH
30971: LD_STRING D15d-JMM-1
30973: PPUSH
30974: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
30978: LD_EXP 66
30982: PPUSH
30983: LD_STRING D15d-Pla-1
30985: PPUSH
30986: CALL_OW 94
// DialogueOff ;
30990: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30994: LD_EXP 64
30998: PPUSH
30999: CALL_OW 302
31003: PUSH
31004: LD_EXP 64
31008: PPUSH
31009: CALL_OW 255
31013: PUSH
31014: LD_INT 1
31016: EQUAL
31017: AND
31018: PUSH
31019: LD_INT 22
31021: PUSH
31022: LD_INT 1
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 34
31031: PUSH
31032: LD_INT 8
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PPUSH
31043: CALL_OW 69
31047: NOT
31048: AND
31049: IFFALSE 31698
// begin SetSide ( Friend , 8 ) ;
31051: LD_EXP 64
31055: PPUSH
31056: LD_INT 8
31058: PPUSH
31059: CALL_OW 235
// if IsInUnit ( Friend ) then
31063: LD_EXP 64
31067: PPUSH
31068: CALL_OW 310
31072: IFFALSE 31083
// ComExitBuilding ( Friend ) ;
31074: LD_EXP 64
31078: PPUSH
31079: CALL_OW 122
// if IsDriver ( Friend ) then
31083: LD_EXP 64
31087: PPUSH
31088: CALL 103466 0 1
31092: IFFALSE 31103
// ComExitVehicle ( Friend ) ;
31094: LD_EXP 64
31098: PPUSH
31099: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31103: LD_EXP 64
31107: PPUSH
31108: LD_INT 9
31110: PPUSH
31111: LD_INT 2
31113: PPUSH
31114: CALL_OW 171
// wait ( 0 0$05 ) ;
31118: LD_INT 175
31120: PPUSH
31121: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31125: LD_EXP 64
31129: PPUSH
31130: CALL_OW 87
// DialogueOn ;
31134: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31138: LD_EXP 40
31142: PPUSH
31143: LD_STRING D16-JMM-1
31145: PPUSH
31146: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31150: LD_EXP 64
31154: PPUSH
31155: LD_STRING D16-Friend-1
31157: PPUSH
31158: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31162: LD_EXP 40
31166: PPUSH
31167: LD_STRING D16-JMM-2
31169: PPUSH
31170: CALL_OW 88
// DialogueOff ;
31174: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31178: LD_EXP 64
31182: PPUSH
31183: LD_INT 1
31185: PPUSH
31186: CALL_OW 235
// ComHold ( Friend ) ;
31190: LD_EXP 64
31194: PPUSH
31195: CALL_OW 140
// wait ( 0 0$20 ) ;
31199: LD_INT 700
31201: PPUSH
31202: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31206: LD_EXP 64
31210: PPUSH
31211: LD_INT 9
31213: PPUSH
31214: LD_INT 2
31216: PPUSH
31217: CALL_OW 297
31221: PUSH
31222: LD_INT 30
31224: LESS
31225: IFFALSE 31294
// begin SetSide ( Friend , 8 ) ;
31227: LD_EXP 64
31231: PPUSH
31232: LD_INT 8
31234: PPUSH
31235: CALL_OW 235
// if IsInUnit ( Friend ) then
31239: LD_EXP 64
31243: PPUSH
31244: CALL_OW 310
31248: IFFALSE 31259
// ComExitBuilding ( Friend ) ;
31250: LD_EXP 64
31254: PPUSH
31255: CALL_OW 122
// if IsDriver ( Friend ) then
31259: LD_EXP 64
31263: PPUSH
31264: CALL 103466 0 1
31268: IFFALSE 31279
// ComExitVehicle ( Friend ) ;
31270: LD_EXP 64
31274: PPUSH
31275: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31279: LD_EXP 64
31283: PPUSH
31284: LD_INT 9
31286: PPUSH
31287: LD_INT 2
31289: PPUSH
31290: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31294: LD_INT 1050
31296: PPUSH
31297: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31301: LD_INT 22
31303: PUSH
31304: LD_INT 1
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 34
31313: PUSH
31314: LD_INT 8
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PPUSH
31325: CALL_OW 69
31329: NOT
31330: IFFALSE 31676
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31332: LD_ADDR_VAR 0 3
31336: PUSH
31337: LD_INT 22
31339: PUSH
31340: LD_INT 1
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 26
31349: PUSH
31350: LD_INT 1
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 3
31359: PUSH
31360: LD_INT 25
31362: PUSH
31363: LD_INT 12
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 25
31372: PUSH
31373: LD_INT 16
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: LIST
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: LIST
31389: PPUSH
31390: CALL_OW 69
31394: PUSH
31395: LD_EXP 40
31399: PUSH
31400: LD_EXP 42
31404: PUSH
31405: LD_EXP 56
31409: PUSH
31410: LD_EXP 43
31414: PUSH
31415: LD_EXP 44
31419: PUSH
31420: LD_EXP 45
31424: PUSH
31425: LD_EXP 46
31429: PUSH
31430: LD_EXP 47
31434: PUSH
31435: LD_EXP 48
31439: PUSH
31440: LD_EXP 49
31444: PUSH
31445: LD_EXP 50
31449: PUSH
31450: LD_EXP 51
31454: PUSH
31455: LD_EXP 52
31459: PUSH
31460: LD_EXP 53
31464: PUSH
31465: LD_EXP 54
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: LIST
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: DIFF
31487: ST_TO_ADDR
// DialogueOn ;
31488: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
31492: LD_EXP 66
31496: PPUSH
31497: LD_STRING D16a-Pla-1
31499: PPUSH
31500: CALL_OW 94
// if Stevens then
31504: LD_EXP 42
31508: IFFALSE 31524
// Say ( Stevens , D16a-Huck-1 ) else
31510: LD_EXP 42
31514: PPUSH
31515: LD_STRING D16a-Huck-1
31517: PPUSH
31518: CALL_OW 88
31522: GO 31566
// if Baker then
31524: LD_EXP 56
31528: IFFALSE 31544
// Say ( Baker , D16a-Huck-1 ) else
31530: LD_EXP 56
31534: PPUSH
31535: LD_STRING D16a-Huck-1
31537: PPUSH
31538: CALL_OW 88
31542: GO 31566
// if tmp then
31544: LD_VAR 0 3
31548: IFFALSE 31566
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
31550: LD_VAR 0 3
31554: PUSH
31555: LD_INT 1
31557: ARRAY
31558: PPUSH
31559: LD_STRING D16a-Sol1-1
31561: PPUSH
31562: CALL_OW 88
// if GetSide ( Friend ) = 8 then
31566: LD_EXP 64
31570: PPUSH
31571: CALL_OW 255
31575: PUSH
31576: LD_INT 8
31578: EQUAL
31579: IFFALSE 31595
// Say ( JMM , D16a-JMM-1 ) else
31581: LD_EXP 40
31585: PPUSH
31586: LD_STRING D16a-JMM-1
31588: PPUSH
31589: CALL_OW 88
31593: GO 31655
// begin Say ( JMM , D16a-JMM-1a ) ;
31595: LD_EXP 40
31599: PPUSH
31600: LD_STRING D16a-JMM-1a
31602: PPUSH
31603: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
31607: LD_EXP 64
31611: PPUSH
31612: LD_STRING D16a-Friend-1
31614: PPUSH
31615: CALL_OW 88
// ComExitBuilding ( Friend ) ;
31619: LD_EXP 64
31623: PPUSH
31624: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
31628: LD_EXP 64
31632: PPUSH
31633: LD_INT 191
31635: PPUSH
31636: LD_INT 103
31638: PPUSH
31639: CALL_OW 171
// SetSide ( Friend , 3 ) ;
31643: LD_EXP 64
31647: PPUSH
31648: LD_INT 3
31650: PPUSH
31651: CALL_OW 235
// end ; DialogueOff ;
31655: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
31659: LD_VAR 0 1
31663: PPUSH
31664: LD_INT 60
31666: PPUSH
31667: LD_INT 95
31669: PPUSH
31670: CALL_OW 116
// end else
31674: GO 31696
// begin DialogueOn ;
31676: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31680: LD_EXP 66
31684: PPUSH
31685: LD_STRING D16c-Pla-1
31687: PPUSH
31688: CALL_OW 94
// DialogueOff ;
31692: CALL_OW 7
// end ; end else
31696: GO 31797
// begin wait ( 3 3$00 ) ;
31698: LD_INT 6300
31700: PPUSH
31701: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31705: LD_INT 22
31707: PUSH
31708: LD_INT 1
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 34
31717: PUSH
31718: LD_INT 8
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PPUSH
31729: CALL_OW 69
31733: NOT
31734: IFFALSE 31777
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
31736: LD_EXP 66
31740: PPUSH
31741: LD_STRING D16b-Pla-1
31743: PPUSH
31744: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
31748: LD_EXP 40
31752: PPUSH
31753: LD_STRING D16b-JMM-1
31755: PPUSH
31756: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
31760: LD_VAR 0 1
31764: PPUSH
31765: LD_INT 60
31767: PPUSH
31768: LD_INT 95
31770: PPUSH
31771: CALL_OW 116
// end else
31775: GO 31797
// begin DialogueOn ;
31777: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31781: LD_EXP 66
31785: PPUSH
31786: LD_STRING D16c-Pla-1
31788: PPUSH
31789: CALL_OW 94
// DialogueOff ;
31793: CALL_OW 7
// end ; end ; end ;
31797: PPOPN 3
31799: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
31800: LD_INT 25
31802: PPUSH
31803: LD_INT 1
31805: PPUSH
31806: CALL_OW 321
31810: PUSH
31811: LD_INT 2
31813: EQUAL
31814: PUSH
31815: LD_EXP 14
31819: PUSH
31820: LD_INT 126000
31822: GREATEREQUAL
31823: OR
31824: PUSH
31825: LD_EXP 23
31829: NOT
31830: AND
31831: PUSH
31832: LD_EXP 77
31836: PPUSH
31837: CALL_OW 302
31841: AND
31842: IFFALSE 32200
31844: GO 31846
31846: DISABLE
31847: LD_INT 0
31849: PPUSH
// begin missionStage := 11 ;
31850: LD_ADDR_EXP 15
31854: PUSH
31855: LD_INT 11
31857: ST_TO_ADDR
// DialogueOn ;
31858: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
31862: LD_EXP 77
31866: PPUSH
31867: LD_STRING D9-Roth-1
31869: PPUSH
31870: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
31874: LD_EXP 40
31878: PPUSH
31879: LD_STRING D9-JMM-1
31881: PPUSH
31882: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
31886: LD_EXP 77
31890: PPUSH
31891: LD_STRING D9-Roth-2
31893: PPUSH
31894: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
31898: LD_EXP 77
31902: PPUSH
31903: LD_STRING D9-Roth-2a
31905: PPUSH
31906: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
31910: LD_EXP 66
31914: PPUSH
31915: LD_STRING D9-Pla-2
31917: PPUSH
31918: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
31922: LD_EXP 77
31926: PPUSH
31927: LD_STRING D9-Roth-3
31929: PPUSH
31930: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
31934: LD_EXP 66
31938: PPUSH
31939: LD_STRING D9-Pla-3
31941: PPUSH
31942: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
31946: LD_EXP 77
31950: PPUSH
31951: LD_STRING D9-Roth-4
31953: PPUSH
31954: CALL_OW 94
// dec := Query ( Q9 ) ;
31958: LD_ADDR_VAR 0 1
31962: PUSH
31963: LD_STRING Q9
31965: PPUSH
31966: CALL_OW 97
31970: ST_TO_ADDR
// if dec = 1 then
31971: LD_VAR 0 1
31975: PUSH
31976: LD_INT 1
31978: EQUAL
31979: IFFALSE 31993
// SayRadio ( Roth , D9a-Roth-1 ) ;
31981: LD_EXP 77
31985: PPUSH
31986: LD_STRING D9a-Roth-1
31988: PPUSH
31989: CALL_OW 94
// if dec = 2 then
31993: LD_VAR 0 1
31997: PUSH
31998: LD_INT 2
32000: EQUAL
32001: IFFALSE 32027
// begin Say ( JMM , D9b-JMM-1 ) ;
32003: LD_EXP 40
32007: PPUSH
32008: LD_STRING D9b-JMM-1
32010: PPUSH
32011: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32015: LD_EXP 77
32019: PPUSH
32020: LD_STRING D9b-Roth-1
32022: PPUSH
32023: CALL_OW 94
// end ; if dec = 3 then
32027: LD_VAR 0 1
32031: PUSH
32032: LD_INT 3
32034: EQUAL
32035: IFFALSE 32097
// begin Say ( JMM , D9c-JMM-1 ) ;
32037: LD_EXP 40
32041: PPUSH
32042: LD_STRING D9c-JMM-1
32044: PPUSH
32045: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32049: LD_EXP 77
32053: PPUSH
32054: LD_STRING D9c-Roth-1
32056: PPUSH
32057: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32061: LD_EXP 40
32065: PPUSH
32066: LD_STRING D9c-JMM-2
32068: PPUSH
32069: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32073: LD_EXP 77
32077: PPUSH
32078: LD_STRING D9c-Roth-2
32080: PPUSH
32081: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32085: LD_EXP 40
32089: PPUSH
32090: LD_STRING D9c-JMM-3
32092: PPUSH
32093: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32097: LD_EXP 77
32101: PPUSH
32102: LD_STRING D9c-Roth-3
32104: PPUSH
32105: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32109: LD_EXP 77
32113: PPUSH
32114: LD_STRING D9cont-Roth-1
32116: PPUSH
32117: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32121: LD_EXP 40
32125: PPUSH
32126: LD_STRING D9cont-JMM-1
32128: PPUSH
32129: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32133: LD_EXP 77
32137: PPUSH
32138: LD_STRING D9cont-Roth-2
32140: PPUSH
32141: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32145: LD_EXP 40
32149: PPUSH
32150: LD_STRING D9cont-JMM-2
32152: PPUSH
32153: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32157: LD_EXP 77
32161: PPUSH
32162: LD_STRING D9cont-Roth-3
32164: PPUSH
32165: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32169: LD_EXP 40
32173: PPUSH
32174: LD_STRING D9cont-JMM-3
32176: PPUSH
32177: CALL_OW 88
// DialogueOff ;
32181: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32185: LD_STRING M3
32187: PPUSH
32188: CALL_OW 337
// allianceActive := true ;
32192: LD_ADDR_EXP 31
32196: PUSH
32197: LD_INT 1
32199: ST_TO_ADDR
// end ;
32200: PPOPN 1
32202: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32203: LD_INT 1
32205: PPUSH
32206: LD_INT 126
32208: PPUSH
32209: CALL_OW 292
32213: PUSH
32214: LD_EXP 66
32218: PPUSH
32219: CALL_OW 310
32223: AND
32224: IFFALSE 32304
32226: GO 32228
32228: DISABLE
32229: LD_INT 0
32231: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32232: LD_EXP 66
32236: PPUSH
32237: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32241: LD_ADDR_VAR 0 1
32245: PUSH
32246: LD_INT 4
32248: PPUSH
32249: LD_INT 22
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PPUSH
32259: CALL_OW 70
32263: PPUSH
32264: LD_EXP 66
32268: PPUSH
32269: CALL_OW 74
32273: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32274: LD_EXP 66
32278: PPUSH
32279: LD_VAR 0 1
32283: PUSH
32284: LD_INT 1
32286: ARRAY
32287: PPUSH
32288: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32292: LD_EXP 66
32296: PPUSH
32297: LD_STRING D18-Pla-1
32299: PPUSH
32300: CALL_OW 94
// end ;
32304: PPOPN 1
32306: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
32307: LD_EXP 66
32311: PPUSH
32312: CALL_OW 301
32316: PUSH
32317: LD_EXP 69
32321: PPUSH
32322: CALL_OW 301
32326: AND
32327: PUSH
32328: LD_INT 22
32330: PUSH
32331: LD_INT 3
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 21
32340: PUSH
32341: LD_INT 1
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 50
32350: PUSH
32351: EMPTY
32352: LIST
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: LIST
32358: PPUSH
32359: CALL_OW 69
32363: PUSH
32364: LD_INT 7
32366: PUSH
32367: LD_INT 8
32369: PUSH
32370: LD_INT 9
32372: PUSH
32373: LD_INT 10
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: PUSH
32382: LD_OWVAR 67
32386: ARRAY
32387: LESS
32388: AND
32389: IFFALSE 33188
32391: GO 32393
32393: DISABLE
32394: LD_INT 0
32396: PPUSH
32397: PPUSH
32398: PPUSH
32399: PPUSH
// begin MC_Kill ( 2 ) ;
32400: LD_INT 2
32402: PPUSH
32403: CALL 38120 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
32407: LD_INT 1
32409: PPUSH
32410: LD_INT 3
32412: PPUSH
32413: LD_INT 1
32415: PPUSH
32416: LD_INT 1
32418: PPUSH
32419: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
32423: LD_ADDR_VAR 0 2
32427: PUSH
32428: LD_INT 22
32430: PUSH
32431: LD_INT 3
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 21
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 50
32450: PUSH
32451: EMPTY
32452: LIST
32453: PUSH
32454: LD_INT 26
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: PPUSH
32470: CALL_OW 69
32474: ST_TO_ADDR
// if not tmp then
32475: LD_VAR 0 2
32479: NOT
32480: IFFALSE 32536
// begin uc_side = 3 ;
32482: LD_ADDR_OWVAR 20
32486: PUSH
32487: LD_INT 3
32489: ST_TO_ADDR
// uc_nation = 3 ;
32490: LD_ADDR_OWVAR 21
32494: PUSH
32495: LD_INT 3
32497: ST_TO_ADDR
// hc_name =  ;
32498: LD_ADDR_OWVAR 26
32502: PUSH
32503: LD_STRING 
32505: ST_TO_ADDR
// hc_gallery =  ;
32506: LD_ADDR_OWVAR 33
32510: PUSH
32511: LD_STRING 
32513: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
32514: LD_INT 1
32516: PPUSH
32517: LD_INT 10
32519: PPUSH
32520: CALL_OW 381
// tmp = CreateHuman ;
32524: LD_ADDR_VAR 0 2
32528: PUSH
32529: CALL_OW 44
32533: ST_TO_ADDR
// end else
32534: GO 32550
// tmp := tmp [ 1 ] ;
32536: LD_ADDR_VAR 0 2
32540: PUSH
32541: LD_VAR 0 2
32545: PUSH
32546: LD_INT 1
32548: ARRAY
32549: ST_TO_ADDR
// DialogueOn ;
32550: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
32554: LD_VAR 0 2
32558: PPUSH
32559: LD_STRING DSurrenderRussians-RSol1-1a
32561: PPUSH
32562: CALL_OW 94
// DialogueOff ;
32566: CALL_OW 7
// russianDestroyed := true ;
32570: LD_ADDR_EXP 21
32574: PUSH
32575: LD_INT 1
32577: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
32578: LD_ADDR_VAR 0 1
32582: PUSH
32583: LD_INT 22
32585: PUSH
32586: LD_INT 6
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PPUSH
32593: CALL_OW 69
32597: PUSH
32598: FOR_IN
32599: IFFALSE 32612
// KillUnit ( i ) ;
32601: LD_VAR 0 1
32605: PPUSH
32606: CALL_OW 66
32610: GO 32598
32612: POP
32613: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
32614: LD_INT 22
32616: PUSH
32617: LD_INT 3
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 21
32626: PUSH
32627: LD_INT 1
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PPUSH
32638: CALL_OW 69
32642: PPUSH
32643: CALL_OW 122
// wait ( 0 0$1 ) ;
32647: LD_INT 35
32649: PPUSH
32650: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
32654: LD_INT 22
32656: PUSH
32657: LD_INT 3
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 21
32666: PUSH
32667: LD_INT 1
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PPUSH
32678: CALL_OW 69
32682: PPUSH
32683: LD_INT 25
32685: PPUSH
32686: CALL_OW 173
// wait ( 0 0$35 ) ;
32690: LD_INT 1225
32692: PPUSH
32693: CALL_OW 67
// PrepareOmarInvasion ;
32697: CALL 15623 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
32701: LD_ADDR_VAR 0 2
32705: PUSH
32706: LD_EXP 95
32710: PPUSH
32711: CALL_OW 250
32715: PUSH
32716: LD_EXP 95
32720: PPUSH
32721: CALL_OW 251
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
32730: LD_VAR 0 2
32734: PUSH
32735: LD_INT 1
32737: ARRAY
32738: PPUSH
32739: LD_VAR 0 2
32743: PUSH
32744: LD_INT 2
32746: ARRAY
32747: PPUSH
32748: LD_INT 1
32750: PPUSH
32751: LD_INT 8
32753: NEG
32754: PPUSH
32755: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
32759: LD_EXP 95
32763: PPUSH
32764: CALL_OW 87
// DialogueOn ;
32768: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
32772: LD_EXP 40
32776: PPUSH
32777: LD_STRING D19-JMM-1
32779: PPUSH
32780: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 22
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 26
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 25
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 25
32824: PUSH
32825: LD_INT 2
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 25
32834: PUSH
32835: LD_INT 3
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 25
32844: PUSH
32845: LD_INT 4
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 25
32854: PUSH
32855: LD_INT 5
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 25
32864: PUSH
32865: LD_INT 8
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: LIST
32885: PPUSH
32886: CALL_OW 69
32890: PUSH
32891: LD_EXP 40
32895: PUSH
32896: LD_EXP 41
32900: PUSH
32901: LD_EXP 62
32905: PUSH
32906: LD_EXP 42
32910: PUSH
32911: LD_EXP 43
32915: PUSH
32916: LD_EXP 44
32920: PUSH
32921: LD_EXP 45
32925: PUSH
32926: LD_EXP 46
32930: PUSH
32931: LD_EXP 47
32935: PUSH
32936: LD_EXP 48
32940: PUSH
32941: LD_EXP 49
32945: PUSH
32946: LD_EXP 50
32950: PUSH
32951: LD_EXP 51
32955: PUSH
32956: LD_EXP 52
32960: PUSH
32961: LD_EXP 53
32965: PUSH
32966: LD_EXP 54
32970: PUSH
32971: LD_EXP 55
32975: PUSH
32976: LD_EXP 56
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: DIFF
33001: ST_TO_ADDR
// if tmp2 then
33002: LD_VAR 0 3
33006: IFFALSE 33024
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33008: LD_VAR 0 3
33012: PUSH
33013: LD_INT 1
33015: ARRAY
33016: PPUSH
33017: LD_STRING D19-Sol1-1
33019: PPUSH
33020: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33024: LD_EXP 40
33028: PPUSH
33029: LD_STRING D19-JMM-2
33031: PPUSH
33032: CALL_OW 88
// DialogueOff ;
33036: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33040: LD_VAR 0 2
33044: PUSH
33045: LD_INT 1
33047: ARRAY
33048: PPUSH
33049: LD_VAR 0 2
33053: PUSH
33054: LD_INT 2
33056: ARRAY
33057: PPUSH
33058: LD_INT 1
33060: PPUSH
33061: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33065: LD_STRING M5
33067: PPUSH
33068: CALL_OW 337
// omarOnMotherLode := false ;
33072: LD_ADDR_VAR 0 4
33076: PUSH
33077: LD_INT 0
33079: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33080: LD_INT 35
33082: PPUSH
33083: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33087: LD_EXP 95
33091: PPUSH
33092: LD_INT 215
33094: PPUSH
33095: LD_INT 100
33097: PPUSH
33098: CALL_OW 297
33102: PUSH
33103: LD_INT 10
33105: LESS
33106: PUSH
33107: LD_VAR 0 4
33111: NOT
33112: AND
33113: IFFALSE 33147
// begin omarOnMotherLode := true ;
33115: LD_ADDR_VAR 0 4
33119: PUSH
33120: LD_INT 1
33122: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33123: LD_EXP 40
33127: PPUSH
33128: LD_STRING D19b-JMM-1
33130: PPUSH
33131: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33135: LD_EXP 95
33139: PPUSH
33140: LD_STRING DOmarContam-Omar-1
33142: PPUSH
33143: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33147: LD_EXP 95
33151: PPUSH
33152: CALL_OW 301
33156: IFFALSE 33080
// Say ( JMM , D19a-JMM-1 ) ;
33158: LD_EXP 40
33162: PPUSH
33163: LD_STRING D19a-JMM-1
33165: PPUSH
33166: CALL_OW 88
// if Heike then
33170: LD_EXP 96
33174: IFFALSE 33188
// Say ( Heike , D19a-Hke-1 ) ;
33176: LD_EXP 96
33180: PPUSH
33181: LD_STRING D19a-Hke-1
33183: PPUSH
33184: CALL_OW 88
// end ;
33188: PPOPN 4
33190: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33191: LD_INT 22
33193: PUSH
33194: LD_INT 3
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 21
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PPUSH
33215: CALL_OW 69
33219: PUSH
33220: LD_EXP 21
33224: AND
33225: IFFALSE 33293
33227: GO 33229
33229: DISABLE
33230: LD_INT 0
33232: PPUSH
33233: PPUSH
// begin enable ;
33234: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33235: LD_ADDR_VAR 0 2
33239: PUSH
33240: LD_INT 25
33242: PPUSH
33243: LD_INT 22
33245: PUSH
33246: LD_INT 3
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PPUSH
33253: CALL_OW 70
33257: ST_TO_ADDR
// if not tmp then
33258: LD_VAR 0 2
33262: NOT
33263: IFFALSE 33267
// exit ;
33265: GO 33293
// for i in tmp do
33267: LD_ADDR_VAR 0 1
33271: PUSH
33272: LD_VAR 0 2
33276: PUSH
33277: FOR_IN
33278: IFFALSE 33291
// RemoveUnit ( i ) ;
33280: LD_VAR 0 1
33284: PPUSH
33285: CALL_OW 64
33289: GO 33277
33291: POP
33292: POP
// end ;
33293: PPOPN 2
33295: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
33296: LD_INT 22
33298: PUSH
33299: LD_INT 7
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 21
33308: PUSH
33309: LD_INT 1
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PPUSH
33320: CALL_OW 69
33324: PUSH
33325: LD_INT 6
33327: LESS
33328: IFFALSE 33796
33330: GO 33332
33332: DISABLE
33333: LD_INT 0
33335: PPUSH
33336: PPUSH
// begin MC_Kill ( 1 ) ;
33337: LD_INT 1
33339: PPUSH
33340: CALL 38120 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
33344: LD_INT 7
33346: PPUSH
33347: LD_INT 1
33349: PPUSH
33350: LD_INT 1
33352: PPUSH
33353: LD_INT 1
33355: PPUSH
33356: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
33360: LD_ADDR_VAR 0 1
33364: PUSH
33365: LD_INT 22
33367: PUSH
33368: LD_INT 7
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 26
33377: PUSH
33378: LD_INT 1
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PPUSH
33389: CALL_OW 69
33393: PUSH
33394: LD_EXP 77
33398: DIFF
33399: ST_TO_ADDR
// if tmp then
33400: LD_VAR 0 1
33404: IFFALSE 33422
// tmp := tmp [ 1 ] else
33406: LD_ADDR_VAR 0 1
33410: PUSH
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: ARRAY
33419: ST_TO_ADDR
33420: GO 33458
// begin uc_side := 7 ;
33422: LD_ADDR_OWVAR 20
33426: PUSH
33427: LD_INT 7
33429: ST_TO_ADDR
// uc_nation := 1 ;
33430: LD_ADDR_OWVAR 21
33434: PUSH
33435: LD_INT 1
33437: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
33438: LD_INT 1
33440: PPUSH
33441: LD_INT 8
33443: PPUSH
33444: CALL_OW 384
// tmp := CreateHuman ;
33448: LD_ADDR_VAR 0 1
33452: PUSH
33453: CALL_OW 44
33457: ST_TO_ADDR
// end ; DialogueOn ;
33458: CALL_OW 6
// if IsOK ( Roth ) then
33462: LD_EXP 77
33466: PPUSH
33467: CALL_OW 302
33471: IFFALSE 33485
// Say ( JMM , DAb-JMM-1 ) ;
33473: LD_EXP 40
33477: PPUSH
33478: LD_STRING DAb-JMM-1
33480: PPUSH
33481: CALL_OW 88
// if IsOK ( Roth ) then
33485: LD_EXP 77
33489: PPUSH
33490: CALL_OW 302
33494: IFFALSE 33518
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
33496: LD_EXP 77
33500: PPUSH
33501: LD_STRING DSurrenderAlliance-Roth-1
33503: PPUSH
33504: CALL_OW 88
// RothCaptured := true ;
33508: LD_ADDR_EXP 33
33512: PUSH
33513: LD_INT 1
33515: ST_TO_ADDR
// end else
33516: GO 33530
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
33518: LD_VAR 0 1
33522: PPUSH
33523: LD_STRING DSurrenderAlliance-Sci1-1
33525: PPUSH
33526: CALL_OW 88
// DialogueOff ;
33530: CALL_OW 7
// allianceDestroyed := true ;
33534: LD_ADDR_EXP 23
33538: PUSH
33539: LD_INT 1
33541: ST_TO_ADDR
// if capturedUnit = 0 then
33542: LD_EXP 34
33546: PUSH
33547: LD_INT 0
33549: EQUAL
33550: IFFALSE 33559
// SetAchievement ( ACH_ALLIANCE ) ;
33552: LD_STRING ACH_ALLIANCE
33554: PPUSH
33555: CALL_OW 543
// if trueAmericans then
33559: LD_EXP 35
33563: IFFALSE 33639
// begin if trueAmericans = 1 then
33565: LD_EXP 35
33569: PUSH
33570: LD_INT 1
33572: EQUAL
33573: IFFALSE 33589
// Say ( JMM , DAb-JMM-1a ) else
33575: LD_EXP 40
33579: PPUSH
33580: LD_STRING DAb-JMM-1a
33582: PPUSH
33583: CALL_OW 88
33587: GO 33601
// Say ( JMM , DAb-JMM-1b ) ;
33589: LD_EXP 40
33593: PPUSH
33594: LD_STRING DAb-JMM-1b
33596: PPUSH
33597: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
33601: LD_EXP 35
33605: PPUSH
33606: CALL_OW 87
// for i in trueAmericans do
33610: LD_ADDR_VAR 0 2
33614: PUSH
33615: LD_EXP 35
33619: PUSH
33620: FOR_IN
33621: IFFALSE 33637
// SetSide ( i , 1 ) ;
33623: LD_VAR 0 2
33627: PPUSH
33628: LD_INT 1
33630: PPUSH
33631: CALL_OW 235
33635: GO 33620
33637: POP
33638: POP
// end ; repeat wait ( 0 0$1 ) ;
33639: LD_INT 35
33641: PPUSH
33642: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
33646: LD_ADDR_VAR 0 2
33650: PUSH
33651: LD_INT 22
33653: PUSH
33654: LD_INT 7
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 21
33663: PUSH
33664: LD_INT 1
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PPUSH
33675: CALL_OW 69
33679: PUSH
33680: FOR_IN
33681: IFFALSE 33763
// begin if IsInUnit ( i ) then
33683: LD_VAR 0 2
33687: PPUSH
33688: CALL_OW 310
33692: IFFALSE 33703
// ComExitBuilding ( i ) ;
33694: LD_VAR 0 2
33698: PPUSH
33699: CALL_OW 122
// if IsDriver ( i ) then
33703: LD_VAR 0 2
33707: PPUSH
33708: CALL 103466 0 1
33712: IFFALSE 33723
// ComExitVehicle ( i ) ;
33714: LD_VAR 0 2
33718: PPUSH
33719: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
33723: LD_VAR 0 2
33727: PPUSH
33728: LD_INT 26
33730: PPUSH
33731: CALL_OW 308
33735: NOT
33736: IFFALSE 33752
// AddComMoveToArea ( i , allianceEscapeArea ) else
33738: LD_VAR 0 2
33742: PPUSH
33743: LD_INT 26
33745: PPUSH
33746: CALL_OW 173
33750: GO 33761
// RemoveUnit ( i ) ;
33752: LD_VAR 0 2
33756: PPUSH
33757: CALL_OW 64
// end ;
33761: GO 33680
33763: POP
33764: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
33765: LD_INT 22
33767: PUSH
33768: LD_INT 7
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 21
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PPUSH
33789: CALL_OW 69
33793: NOT
33794: IFFALSE 33639
// end ;
33796: PPOPN 2
33798: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
33799: LD_INT 0
33801: PPUSH
33802: PPUSH
// if not unit then
33803: LD_VAR 0 1
33807: NOT
33808: IFFALSE 33812
// exit ;
33810: GO 35320
// DoNotAttack ( 7 , unit ) ;
33812: LD_INT 7
33814: PPUSH
33815: LD_VAR 0 1
33819: PPUSH
33820: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
33824: LD_VAR 0 1
33828: PPUSH
33829: LD_INT 260
33831: PPUSH
33832: LD_INT 235
33834: PPUSH
33835: LD_INT 3
33837: PPUSH
33838: LD_INT 1
33840: PPUSH
33841: CALL_OW 483
// SetSide ( unit , 4 ) ;
33845: LD_VAR 0 1
33849: PPUSH
33850: LD_INT 4
33852: PPUSH
33853: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
33857: LD_ADDR_EXP 34
33861: PUSH
33862: LD_EXP 34
33866: PUSH
33867: LD_INT 1
33869: PLUS
33870: ST_TO_ADDR
// wait ( 0 0$2 ) ;
33871: LD_INT 70
33873: PPUSH
33874: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
33878: LD_INT 260
33880: PPUSH
33881: LD_INT 235
33883: PPUSH
33884: LD_INT 1
33886: PPUSH
33887: LD_INT 8
33889: NEG
33890: PPUSH
33891: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
33904: LD_VAR 0 1
33908: PPUSH
33909: LD_EXP 77
33913: PPUSH
33914: CALL_OW 119
// DialogueOn ;
33918: CALL_OW 6
// case unit of JMM :
33922: LD_VAR 0 1
33926: PUSH
33927: LD_EXP 40
33931: DOUBLE
33932: EQUAL
33933: IFTRUE 33937
33935: GO 33952
33937: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
33938: LD_EXP 40
33942: PPUSH
33943: LD_STRING DA1-JMM-1
33945: PPUSH
33946: CALL_OW 91
33950: GO 34394
33952: LD_EXP 41
33956: DOUBLE
33957: EQUAL
33958: IFTRUE 33962
33960: GO 33977
33962: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
33963: LD_EXP 41
33967: PPUSH
33968: LD_STRING DA1-Joan-1
33970: PPUSH
33971: CALL_OW 91
33975: GO 34394
33977: LD_EXP 43
33981: DOUBLE
33982: EQUAL
33983: IFTRUE 33987
33985: GO 34002
33987: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
33988: LD_EXP 43
33992: PPUSH
33993: LD_STRING DA1-Lisa-1
33995: PPUSH
33996: CALL_OW 91
34000: GO 34394
34002: LD_EXP 44
34006: DOUBLE
34007: EQUAL
34008: IFTRUE 34012
34010: GO 34027
34012: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34013: LD_EXP 44
34017: PPUSH
34018: LD_STRING DA1-Don-1
34020: PPUSH
34021: CALL_OW 91
34025: GO 34394
34027: LD_EXP 51
34031: DOUBLE
34032: EQUAL
34033: IFTRUE 34037
34035: GO 34052
34037: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34038: LD_EXP 51
34042: PPUSH
34043: LD_STRING DA1-Corn-1
34045: PPUSH
34046: CALL_OW 91
34050: GO 34394
34052: LD_EXP 47
34056: DOUBLE
34057: EQUAL
34058: IFTRUE 34062
34060: GO 34077
34062: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34063: LD_EXP 47
34067: PPUSH
34068: LD_STRING DA1-Den-1
34070: PPUSH
34071: CALL_OW 91
34075: GO 34394
34077: LD_EXP 45
34081: DOUBLE
34082: EQUAL
34083: IFTRUE 34087
34085: GO 34102
34087: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34088: LD_EXP 45
34092: PPUSH
34093: LD_STRING DA1-Bobby-1
34095: PPUSH
34096: CALL_OW 91
34100: GO 34394
34102: LD_EXP 49
34106: DOUBLE
34107: EQUAL
34108: IFTRUE 34112
34110: GO 34127
34112: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34113: LD_EXP 49
34117: PPUSH
34118: LD_STRING DA1-Glad-1
34120: PPUSH
34121: CALL_OW 91
34125: GO 34394
34127: LD_EXP 46
34131: DOUBLE
34132: EQUAL
34133: IFTRUE 34137
34135: GO 34152
34137: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34138: LD_EXP 46
34142: PPUSH
34143: LD_STRING DA1-Cyrus-1
34145: PPUSH
34146: CALL_OW 91
34150: GO 34394
34152: LD_EXP 42
34156: DOUBLE
34157: EQUAL
34158: IFTRUE 34162
34160: GO 34177
34162: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34163: LD_EXP 42
34167: PPUSH
34168: LD_STRING DA1-Huck-1
34170: PPUSH
34171: CALL_OW 91
34175: GO 34394
34177: LD_EXP 56
34181: DOUBLE
34182: EQUAL
34183: IFTRUE 34187
34185: GO 34202
34187: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34188: LD_EXP 56
34192: PPUSH
34193: LD_STRING DA1-Huck-1
34195: PPUSH
34196: CALL_OW 91
34200: GO 34394
34202: LD_EXP 48
34206: DOUBLE
34207: EQUAL
34208: IFTRUE 34212
34210: GO 34227
34212: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34213: LD_EXP 48
34217: PPUSH
34218: LD_STRING DA1-Brown-1
34220: PPUSH
34221: CALL_OW 91
34225: GO 34394
34227: LD_EXP 52
34231: DOUBLE
34232: EQUAL
34233: IFTRUE 34237
34235: GO 34252
34237: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34238: LD_EXP 52
34242: PPUSH
34243: LD_STRING DA1-Gary-1
34245: PPUSH
34246: CALL_OW 91
34250: GO 34394
34252: LD_EXP 55
34256: DOUBLE
34257: EQUAL
34258: IFTRUE 34262
34260: GO 34277
34262: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
34263: LD_EXP 55
34267: PPUSH
34268: LD_STRING DA1-Con-1
34270: PPUSH
34271: CALL_OW 91
34275: GO 34394
34277: LD_EXP 62
34281: DOUBLE
34282: EQUAL
34283: IFTRUE 34287
34285: GO 34302
34287: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
34288: LD_EXP 62
34292: PPUSH
34293: LD_STRING DA1-Kurt-1
34295: PPUSH
34296: CALL_OW 91
34300: GO 34394
34302: LD_EXP 54
34306: DOUBLE
34307: EQUAL
34308: IFTRUE 34312
34310: GO 34327
34312: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
34313: LD_EXP 54
34317: PPUSH
34318: LD_STRING DA1-Yam-1
34320: PPUSH
34321: CALL_OW 91
34325: GO 34394
34327: LD_EXP 53
34331: DOUBLE
34332: EQUAL
34333: IFTRUE 34337
34335: GO 34352
34337: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
34338: LD_EXP 53
34342: PPUSH
34343: LD_STRING DA1-Frank-1
34345: PPUSH
34346: CALL_OW 91
34350: GO 34394
34352: POP
// begin if GetSex ( unit ) = sex_male then
34353: LD_VAR 0 1
34357: PPUSH
34358: CALL_OW 258
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: IFFALSE 34382
// ForceSay ( unit , DA1-Sol1-1 ) else
34368: LD_VAR 0 1
34372: PPUSH
34373: LD_STRING DA1-Sol1-1
34375: PPUSH
34376: CALL_OW 91
34380: GO 34394
// ForceSay ( unit , DA1-FSol1-1 ) ;
34382: LD_VAR 0 1
34386: PPUSH
34387: LD_STRING DA1-FSol1-1
34389: PPUSH
34390: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
34394: LD_EXP 77
34398: PPUSH
34399: LD_STRING DA-Roth-1
34401: PPUSH
34402: CALL_OW 88
// if capturedUnit = 1 then
34406: LD_EXP 34
34410: PUSH
34411: LD_INT 1
34413: EQUAL
34414: IFFALSE 34442
// begin Say ( Simms , DA-Sim-1 ) ;
34416: LD_EXP 78
34420: PPUSH
34421: LD_STRING DA-Sim-1
34423: PPUSH
34424: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
34428: LD_EXP 77
34432: PPUSH
34433: LD_STRING DA-Roth-2
34435: PPUSH
34436: CALL_OW 88
// end else
34440: GO 34454
// Say ( Simms , DA-Sim-2 ) ;
34442: LD_EXP 78
34446: PPUSH
34447: LD_STRING DA-Sim-2
34449: PPUSH
34450: CALL_OW 88
// case unit of JMM :
34454: LD_VAR 0 1
34458: PUSH
34459: LD_EXP 40
34463: DOUBLE
34464: EQUAL
34465: IFTRUE 34469
34467: GO 34484
34469: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
34470: LD_EXP 40
34474: PPUSH
34475: LD_STRING DA1-JMM-1a
34477: PPUSH
34478: CALL_OW 91
34482: GO 35001
34484: LD_EXP 41
34488: DOUBLE
34489: EQUAL
34490: IFTRUE 34494
34492: GO 34509
34494: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
34495: LD_EXP 41
34499: PPUSH
34500: LD_STRING DA1-Joan-1a
34502: PPUSH
34503: CALL_OW 91
34507: GO 35001
34509: LD_EXP 43
34513: DOUBLE
34514: EQUAL
34515: IFTRUE 34519
34517: GO 34534
34519: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
34520: LD_EXP 43
34524: PPUSH
34525: LD_STRING DA1-Lisa-1a
34527: PPUSH
34528: CALL_OW 91
34532: GO 35001
34534: LD_EXP 44
34538: DOUBLE
34539: EQUAL
34540: IFTRUE 34544
34542: GO 34559
34544: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
34545: LD_EXP 44
34549: PPUSH
34550: LD_STRING DA1-Don-1a
34552: PPUSH
34553: CALL_OW 91
34557: GO 35001
34559: LD_EXP 51
34563: DOUBLE
34564: EQUAL
34565: IFTRUE 34569
34567: GO 34584
34569: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
34570: LD_EXP 51
34574: PPUSH
34575: LD_STRING DA1-Corn-1a
34577: PPUSH
34578: CALL_OW 91
34582: GO 35001
34584: LD_EXP 47
34588: DOUBLE
34589: EQUAL
34590: IFTRUE 34594
34592: GO 34609
34594: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
34595: LD_EXP 47
34599: PPUSH
34600: LD_STRING DA1-Den-1a
34602: PPUSH
34603: CALL_OW 91
34607: GO 35001
34609: LD_EXP 45
34613: DOUBLE
34614: EQUAL
34615: IFTRUE 34619
34617: GO 34634
34619: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
34620: LD_EXP 45
34624: PPUSH
34625: LD_STRING DA1-Bobby-1a
34627: PPUSH
34628: CALL_OW 91
34632: GO 35001
34634: LD_EXP 49
34638: DOUBLE
34639: EQUAL
34640: IFTRUE 34644
34642: GO 34659
34644: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
34645: LD_EXP 49
34649: PPUSH
34650: LD_STRING DA1-Glad-1a
34652: PPUSH
34653: CALL_OW 91
34657: GO 35001
34659: LD_EXP 46
34663: DOUBLE
34664: EQUAL
34665: IFTRUE 34669
34667: GO 34684
34669: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
34670: LD_EXP 46
34674: PPUSH
34675: LD_STRING DA1-Cyrus-1a
34677: PPUSH
34678: CALL_OW 91
34682: GO 35001
34684: LD_EXP 42
34688: DOUBLE
34689: EQUAL
34690: IFTRUE 34694
34692: GO 34709
34694: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
34695: LD_EXP 42
34699: PPUSH
34700: LD_STRING DA1-Huck-1a
34702: PPUSH
34703: CALL_OW 91
34707: GO 35001
34709: LD_EXP 56
34713: DOUBLE
34714: EQUAL
34715: IFTRUE 34719
34717: GO 34734
34719: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
34720: LD_EXP 56
34724: PPUSH
34725: LD_STRING DA1-Huck-1a
34727: PPUSH
34728: CALL_OW 91
34732: GO 35001
34734: LD_EXP 48
34738: DOUBLE
34739: EQUAL
34740: IFTRUE 34744
34742: GO 34759
34744: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
34745: LD_EXP 48
34749: PPUSH
34750: LD_STRING DA1-Brown-1a
34752: PPUSH
34753: CALL_OW 91
34757: GO 35001
34759: LD_EXP 52
34763: DOUBLE
34764: EQUAL
34765: IFTRUE 34769
34767: GO 34784
34769: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
34770: LD_EXP 52
34774: PPUSH
34775: LD_STRING DA1-Gary-1a
34777: PPUSH
34778: CALL_OW 91
34782: GO 35001
34784: LD_EXP 55
34788: DOUBLE
34789: EQUAL
34790: IFTRUE 34794
34792: GO 34819
34794: POP
// if JMMGirl = 3 then
34795: LD_EXP 7
34799: PUSH
34800: LD_INT 3
34802: EQUAL
34803: IFFALSE 34817
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
34805: LD_EXP 55
34809: PPUSH
34810: LD_STRING DA1-Con-1a
34812: PPUSH
34813: CALL_OW 91
34817: GO 35001
34819: LD_EXP 62
34823: DOUBLE
34824: EQUAL
34825: IFTRUE 34829
34827: GO 34844
34829: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
34830: LD_EXP 62
34834: PPUSH
34835: LD_STRING DA1-Kurt-1a
34837: PPUSH
34838: CALL_OW 91
34842: GO 35001
34844: LD_EXP 54
34848: DOUBLE
34849: EQUAL
34850: IFTRUE 34854
34852: GO 34869
34854: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
34855: LD_EXP 54
34859: PPUSH
34860: LD_STRING DA1-Yam-1a
34862: PPUSH
34863: CALL_OW 91
34867: GO 35001
34869: LD_EXP 53
34873: DOUBLE
34874: EQUAL
34875: IFTRUE 34879
34877: GO 34894
34879: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
34880: LD_EXP 53
34884: PPUSH
34885: LD_STRING DA1-Frank-1a
34887: PPUSH
34888: CALL_OW 91
34892: GO 35001
34894: POP
// begin join := rand ( 0 , 1 ) ;
34895: LD_ADDR_VAR 0 3
34899: PUSH
34900: LD_INT 0
34902: PPUSH
34903: LD_INT 1
34905: PPUSH
34906: CALL_OW 12
34910: ST_TO_ADDR
// if join then
34911: LD_VAR 0 3
34915: IFFALSE 34960
// begin if GetSex ( unit ) = sex_male then
34917: LD_VAR 0 1
34921: PPUSH
34922: CALL_OW 258
34926: PUSH
34927: LD_INT 1
34929: EQUAL
34930: IFFALSE 34946
// ForceSay ( unit , DA1-Sol1-1b ) else
34932: LD_VAR 0 1
34936: PPUSH
34937: LD_STRING DA1-Sol1-1b
34939: PPUSH
34940: CALL_OW 91
34944: GO 34958
// ForceSay ( unit , DA1-FSol1-1b ) ;
34946: LD_VAR 0 1
34950: PPUSH
34951: LD_STRING DA1-FSol1-1b
34953: PPUSH
34954: CALL_OW 91
// end else
34958: GO 35001
// begin if GetSex ( unit ) = sex_male then
34960: LD_VAR 0 1
34964: PPUSH
34965: CALL_OW 258
34969: PUSH
34970: LD_INT 1
34972: EQUAL
34973: IFFALSE 34989
// ForceSay ( unit , DA1-Sol1-1a ) else
34975: LD_VAR 0 1
34979: PPUSH
34980: LD_STRING DA1-Sol1-1a
34982: PPUSH
34983: CALL_OW 91
34987: GO 35001
// ForceSay ( unit , DA1-FSol1-1a ) ;
34989: LD_VAR 0 1
34993: PPUSH
34994: LD_STRING DA1-FSol1-1a
34996: PPUSH
34997: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35001: LD_VAR 0 1
35005: PUSH
35006: LD_EXP 40
35010: EQUAL
35011: IFFALSE 35022
// begin YouLost ( JMMCaptured ) ;
35013: LD_STRING JMMCaptured
35015: PPUSH
35016: CALL_OW 104
// exit ;
35020: GO 35320
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35022: LD_VAR 0 1
35026: PUSH
35027: LD_EXP 44
35031: PUSH
35032: LD_EXP 47
35036: PUSH
35037: LD_EXP 45
35041: PUSH
35042: LD_EXP 42
35046: PUSH
35047: LD_EXP 56
35051: PUSH
35052: LD_EXP 48
35056: PUSH
35057: LD_EXP 54
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: IN
35071: PUSH
35072: LD_VAR 0 3
35076: OR
35077: IFFALSE 35176
// begin Say ( Roth , DA-Roth-3 ) ;
35079: LD_EXP 77
35083: PPUSH
35084: LD_STRING DA-Roth-3
35086: PPUSH
35087: CALL_OW 88
// SetSide ( unit , 7 ) ;
35091: LD_VAR 0 1
35095: PPUSH
35096: LD_INT 7
35098: PPUSH
35099: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35103: LD_ADDR_EXP 100
35107: PUSH
35108: LD_EXP 100
35112: PPUSH
35113: LD_INT 1
35115: PPUSH
35116: LD_EXP 100
35120: PUSH
35121: LD_INT 1
35123: ARRAY
35124: PUSH
35125: LD_VAR 0 1
35129: ADD
35130: PPUSH
35131: CALL_OW 1
35135: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35136: LD_INT 260
35138: PPUSH
35139: LD_INT 235
35141: PPUSH
35142: LD_INT 1
35144: PPUSH
35145: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35149: LD_VAR 0 1
35153: PPUSH
35154: LD_INT 1000
35156: PPUSH
35157: CALL_OW 234
// DialogueOff ;
35161: CALL_OW 7
// ComFree ( unit ) ;
35165: LD_VAR 0 1
35169: PPUSH
35170: CALL_OW 139
// end else
35174: GO 35257
// begin Say ( Roth , DA-Roth-3a ) ;
35176: LD_EXP 77
35180: PPUSH
35181: LD_STRING DA-Roth-3a
35183: PPUSH
35184: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35188: LD_ADDR_EXP 35
35192: PUSH
35193: LD_EXP 35
35197: PUSH
35198: LD_VAR 0 1
35202: ADD
35203: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35204: LD_INT 260
35206: PPUSH
35207: LD_INT 235
35209: PPUSH
35210: LD_INT 1
35212: PPUSH
35213: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35217: LD_VAR 0 1
35221: PPUSH
35222: LD_INT 1000
35224: PPUSH
35225: CALL_OW 234
// DialogueOff ;
35229: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35233: LD_VAR 0 1
35237: PPUSH
35238: LD_INT 272
35240: PPUSH
35241: LD_INT 254
35243: PPUSH
35244: CALL_OW 111
// AddComHold ( unit ) ;
35248: LD_VAR 0 1
35252: PPUSH
35253: CALL_OW 200
// end ; if capturedUnit = 1 then
35257: LD_EXP 34
35261: PUSH
35262: LD_INT 1
35264: EQUAL
35265: IFFALSE 35320
// begin DialogueOn ;
35267: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
35271: LD_EXP 40
35275: PPUSH
35276: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
35280: LD_EXP 40
35284: PPUSH
35285: LD_STRING DAa-JMM-1
35287: PPUSH
35288: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
35292: LD_EXP 40
35296: PPUSH
35297: LD_STRING DAa-JMM-1a
35299: PPUSH
35300: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
35304: LD_EXP 40
35308: PPUSH
35309: LD_STRING DAa-JMM-1b
35311: PPUSH
35312: CALL_OW 88
// DialogueOff ;
35316: CALL_OW 7
// end ; end ;
35320: LD_VAR 0 2
35324: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
35325: LD_EXP 15
35329: PUSH
35330: LD_INT 13
35332: GREATEREQUAL
35333: PUSH
35334: LD_INT 22
35336: PUSH
35337: LD_INT 2
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 21
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PPUSH
35358: CALL_OW 69
35362: PUSH
35363: LD_INT 0
35365: EQUAL
35366: AND
35367: PUSH
35368: LD_INT 22
35370: PUSH
35371: LD_INT 2
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 33
35380: PUSH
35381: LD_INT 5
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 21
35390: PUSH
35391: LD_INT 2
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 50
35400: PUSH
35401: EMPTY
35402: LIST
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: PPUSH
35410: CALL_OW 69
35414: PUSH
35415: LD_INT 0
35417: EQUAL
35418: AND
35419: PUSH
35420: LD_EXP 21
35424: AND
35425: PUSH
35426: LD_EXP 22
35430: AND
35431: PUSH
35432: LD_EXP 23
35436: AND
35437: IFFALSE 36133
35439: GO 35441
35441: DISABLE
35442: LD_INT 0
35444: PPUSH
35445: PPUSH
35446: PPUSH
// begin m1 := false ;
35447: LD_ADDR_VAR 0 1
35451: PUSH
35452: LD_INT 0
35454: ST_TO_ADDR
// m2 := false ;
35455: LD_ADDR_VAR 0 2
35459: PUSH
35460: LD_INT 0
35462: ST_TO_ADDR
// m3 := false ;
35463: LD_ADDR_VAR 0 3
35467: PUSH
35468: LD_INT 0
35470: ST_TO_ADDR
// if not bombExploded then
35471: LD_EXP 37
35475: NOT
35476: IFFALSE 35485
// SetAchievement ( ACH_SIBROCKET ) ;
35478: LD_STRING ACH_SIBROCKET
35480: PPUSH
35481: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
35485: LD_EXP 64
35489: PPUSH
35490: CALL_OW 255
35494: PUSH
35495: LD_INT 1
35497: EQUAL
35498: PUSH
35499: LD_EXP 64
35503: PPUSH
35504: CALL_OW 302
35508: AND
35509: IFFALSE 35525
// begin wait ( 3 ) ;
35511: LD_INT 3
35513: PPUSH
35514: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
35518: LD_STRING ACH_OPO
35520: PPUSH
35521: CALL_OW 543
// end ; if tick <= 120 120$00 then
35525: LD_OWVAR 1
35529: PUSH
35530: LD_INT 252000
35532: LESSEQUAL
35533: IFFALSE 35549
// begin wait ( 3 ) ;
35535: LD_INT 3
35537: PPUSH
35538: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
35542: LD_STRING ACH_ASPEED_15
35544: PPUSH
35545: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
35549: LD_EXP 40
35553: PPUSH
35554: CALL_OW 87
// music_class := 5 ;
35558: LD_ADDR_OWVAR 72
35562: PUSH
35563: LD_INT 5
35565: ST_TO_ADDR
// music_nat := 5 ;
35566: LD_ADDR_OWVAR 71
35570: PUSH
35571: LD_INT 5
35573: ST_TO_ADDR
// DialogueOn ;
35574: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
35578: LD_EXP 40
35582: PPUSH
35583: LD_STRING D20-JMM-1
35585: PPUSH
35586: CALL_OW 88
// if IsOK ( Joan ) then
35590: LD_EXP 41
35594: PPUSH
35595: CALL_OW 302
35599: IFFALSE 35613
// Say ( Joan , D20-Joan-1 ) ;
35601: LD_EXP 41
35605: PPUSH
35606: LD_STRING D20-Joan-1
35608: PPUSH
35609: CALL_OW 88
// if IsOk ( Lisa ) then
35613: LD_EXP 43
35617: PPUSH
35618: CALL_OW 302
35622: IFFALSE 35636
// Say ( Lisa , D20-Lisa-1 ) ;
35624: LD_EXP 43
35628: PPUSH
35629: LD_STRING D20-Lisa-1
35631: PPUSH
35632: CALL_OW 88
// if IsOk ( Donaldson ) then
35636: LD_EXP 44
35640: PPUSH
35641: CALL_OW 302
35645: IFFALSE 35659
// Say ( Donaldson , D20-Don-1 ) ;
35647: LD_EXP 44
35651: PPUSH
35652: LD_STRING D20-Don-1
35654: PPUSH
35655: CALL_OW 88
// if IsOK ( Cornel ) then
35659: LD_EXP 51
35663: PPUSH
35664: CALL_OW 302
35668: IFFALSE 35682
// Say ( Cornel , D20-Corn-1 ) ;
35670: LD_EXP 51
35674: PPUSH
35675: LD_STRING D20-Corn-1
35677: PPUSH
35678: CALL_OW 88
// if IsOk ( Denis ) then
35682: LD_EXP 47
35686: PPUSH
35687: CALL_OW 302
35691: IFFALSE 35705
// Say ( Denis , D20-Den-1 ) ;
35693: LD_EXP 47
35697: PPUSH
35698: LD_STRING D20-Den-1
35700: PPUSH
35701: CALL_OW 88
// if IsOk ( Bobby ) then
35705: LD_EXP 45
35709: PPUSH
35710: CALL_OW 302
35714: IFFALSE 35728
// Say ( Bobby , D20-Bobby-1 ) ;
35716: LD_EXP 45
35720: PPUSH
35721: LD_STRING D20-Bobby-1
35723: PPUSH
35724: CALL_OW 88
// if IsOk ( Gladstone ) then
35728: LD_EXP 49
35732: PPUSH
35733: CALL_OW 302
35737: IFFALSE 35751
// Say ( Gladstone , D20-Glad-1 ) ;
35739: LD_EXP 49
35743: PPUSH
35744: LD_STRING D20-Glad-1
35746: PPUSH
35747: CALL_OW 88
// if IsOk ( Cyrus ) then
35751: LD_EXP 46
35755: PPUSH
35756: CALL_OW 302
35760: IFFALSE 35774
// Say ( Cyrus , D20-Cyrus-1 ) ;
35762: LD_EXP 46
35766: PPUSH
35767: LD_STRING D20-Cyrus-1
35769: PPUSH
35770: CALL_OW 88
// if IsOk ( Stevens ) then
35774: LD_EXP 42
35778: PPUSH
35779: CALL_OW 302
35783: IFFALSE 35797
// Say ( Stevens , D20-Huck-1 ) ;
35785: LD_EXP 42
35789: PPUSH
35790: LD_STRING D20-Huck-1
35792: PPUSH
35793: CALL_OW 88
// if IsOk ( Brown ) then
35797: LD_EXP 48
35801: PPUSH
35802: CALL_OW 302
35806: IFFALSE 35820
// Say ( Brown , D20-Brown-1 ) ;
35808: LD_EXP 48
35812: PPUSH
35813: LD_STRING D20-Brown-1
35815: PPUSH
35816: CALL_OW 88
// if IsOk ( Gary ) then
35820: LD_EXP 52
35824: PPUSH
35825: CALL_OW 302
35829: IFFALSE 35843
// Say ( Gary , D20-Gary-1 ) ;
35831: LD_EXP 52
35835: PPUSH
35836: LD_STRING D20-Gary-1
35838: PPUSH
35839: CALL_OW 88
// if IsOk ( Connie ) then
35843: LD_EXP 55
35847: PPUSH
35848: CALL_OW 302
35852: IFFALSE 35866
// Say ( Connie , D20-Con-1 ) ;
35854: LD_EXP 55
35858: PPUSH
35859: LD_STRING D20-Con-1
35861: PPUSH
35862: CALL_OW 88
// if IsOk ( Kurt ) then
35866: LD_EXP 62
35870: PPUSH
35871: CALL_OW 302
35875: IFFALSE 35889
// Say ( Kurt , D20-Kurt-1 ) ;
35877: LD_EXP 62
35881: PPUSH
35882: LD_STRING D20-Kurt-1
35884: PPUSH
35885: CALL_OW 88
// if IsOk ( Kikuchi ) then
35889: LD_EXP 54
35893: PPUSH
35894: CALL_OW 302
35898: IFFALSE 35912
// Say ( Kikuchi , D20-Yam-1 ) ;
35900: LD_EXP 54
35904: PPUSH
35905: LD_STRING D20-Yam-1
35907: PPUSH
35908: CALL_OW 88
// if IsOk ( Frank ) then
35912: LD_EXP 53
35916: PPUSH
35917: CALL_OW 302
35921: IFFALSE 35935
// Say ( Frank , D20-Frank-1 ) ;
35923: LD_EXP 53
35927: PPUSH
35928: LD_STRING D20-Frank-1
35930: PPUSH
35931: CALL_OW 88
// DialogueOff ;
35935: CALL_OW 7
// if RothCaptured then
35939: LD_EXP 33
35943: IFFALSE 35965
// begin m1 := true ;
35945: LD_ADDR_VAR 0 1
35949: PUSH
35950: LD_INT 1
35952: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
35953: LD_STRING Roth
35955: PPUSH
35956: LD_INT 1
35958: PPUSH
35959: CALL_OW 101
// end else
35963: GO 35976
// AddMedal ( Roth , - 1 ) ;
35965: LD_STRING Roth
35967: PPUSH
35968: LD_INT 1
35970: NEG
35971: PPUSH
35972: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
35976: LD_EXP 25
35980: NOT
35981: PUSH
35982: LD_EXP 27
35986: OR
35987: PUSH
35988: LD_EXP 28
35992: NOT
35993: OR
35994: IFFALSE 36016
// begin m2 := true ;
35996: LD_ADDR_VAR 0 2
36000: PUSH
36001: LD_INT 1
36003: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36004: LD_STRING Project
36006: PPUSH
36007: LD_INT 1
36009: PPUSH
36010: CALL_OW 101
// end else
36014: GO 36027
// AddMedal ( Project , - 1 ) ;
36016: LD_STRING Project
36018: PPUSH
36019: LD_INT 1
36021: NEG
36022: PPUSH
36023: CALL_OW 101
// if lostCounter = 0 then
36027: LD_EXP 32
36031: PUSH
36032: LD_INT 0
36034: EQUAL
36035: IFFALSE 36057
// begin m3 := true ;
36037: LD_ADDR_VAR 0 3
36041: PUSH
36042: LD_INT 1
36044: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36045: LD_STRING NoLosses
36047: PPUSH
36048: LD_INT 1
36050: PPUSH
36051: CALL_OW 101
// end else
36055: GO 36068
// AddMedal ( NoLosses , - 1 ) ;
36057: LD_STRING NoLosses
36059: PPUSH
36060: LD_INT 1
36062: NEG
36063: PPUSH
36064: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36068: LD_VAR 0 1
36072: PUSH
36073: LD_VAR 0 2
36077: AND
36078: PUSH
36079: LD_VAR 0 3
36083: AND
36084: PUSH
36085: LD_OWVAR 67
36089: PUSH
36090: LD_INT 3
36092: GREATEREQUAL
36093: AND
36094: IFFALSE 36106
// SetAchievementEX ( ACH_AMER , 15 ) ;
36096: LD_STRING ACH_AMER
36098: PPUSH
36099: LD_INT 15
36101: PPUSH
36102: CALL_OW 564
// GiveMedals ( MAIN ) ;
36106: LD_STRING MAIN
36108: PPUSH
36109: CALL_OW 102
// music_class := 4 ;
36113: LD_ADDR_OWVAR 72
36117: PUSH
36118: LD_INT 4
36120: ST_TO_ADDR
// music_nat := 1 ;
36121: LD_ADDR_OWVAR 71
36125: PUSH
36126: LD_INT 1
36128: ST_TO_ADDR
// YouWin ;
36129: CALL_OW 103
// end ; end_of_file
36133: PPOPN 3
36135: END
// export function CustomEvent ( event ) ; begin
36136: LD_INT 0
36138: PPUSH
// end ;
36139: LD_VAR 0 2
36143: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36144: LD_VAR 0 1
36148: PUSH
36149: LD_INT 1
36151: EQUAL
36152: PUSH
36153: LD_VAR 0 2
36157: PUSH
36158: LD_INT 4
36160: EQUAL
36161: AND
36162: PUSH
36163: LD_EXP 60
36167: PPUSH
36168: CALL_OW 300
36172: AND
36173: IFFALSE 36189
// begin wait ( 0 0$2 ) ;
36175: LD_INT 70
36177: PPUSH
36178: CALL_OW 67
// YouLost ( Dismissed ) ;
36182: LD_STRING Dismissed
36184: PPUSH
36185: CALL_OW 104
// end ; end ;
36189: PPOPN 2
36191: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
36192: LD_VAR 0 2
36196: PPUSH
36197: LD_VAR 0 3
36201: PPUSH
36202: LD_INT 18
36204: PPUSH
36205: CALL_OW 309
36209: IFFALSE 36218
// YouLost ( Motherlode3 ) ;
36211: LD_STRING Motherlode3
36213: PPUSH
36214: CALL_OW 104
// end ;
36218: PPOPN 3
36220: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
36221: LD_EXP 27
36225: NOT
36226: IFFALSE 36236
// behemothDone := true ;
36228: LD_ADDR_EXP 28
36232: PUSH
36233: LD_INT 1
36235: ST_TO_ADDR
// end ;
36236: PPOPN 1
36238: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
36239: LD_VAR 0 1
36243: PPUSH
36244: CALL_OW 255
36248: PUSH
36249: LD_INT 1
36251: EQUAL
36252: IFFALSE 36262
// bombExploded := true ;
36254: LD_ADDR_EXP 37
36258: PUSH
36259: LD_INT 1
36261: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
36262: LD_VAR 0 1
36266: PPUSH
36267: CALL_OW 255
36271: PUSH
36272: LD_INT 3
36274: EQUAL
36275: IFFALSE 36305
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
36277: LD_INT 2
36279: PPUSH
36280: LD_INT 23
36282: PUSH
36283: LD_INT 3
36285: PUSH
36286: LD_INT 3
36288: PUSH
36289: LD_INT 48
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: LIST
36296: LIST
36297: PUSH
36298: EMPTY
36299: LIST
36300: PPUSH
36301: CALL 62131 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
36305: LD_VAR 0 1
36309: PPUSH
36310: CALL_OW 255
36314: PUSH
36315: LD_INT 1
36317: EQUAL
36318: PUSH
36319: LD_EXP 64
36323: PPUSH
36324: CALL_OW 255
36328: PUSH
36329: LD_INT 1
36331: EQUAL
36332: AND
36333: PUSH
36334: LD_EXP 64
36338: PPUSH
36339: CALL_OW 302
36343: AND
36344: PUSH
36345: LD_EXP 30
36349: AND
36350: PUSH
36351: LD_INT 22
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 34
36363: PUSH
36364: LD_INT 48
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PPUSH
36375: CALL_OW 69
36379: AND
36380: PUSH
36381: LD_INT 22
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 34
36393: PUSH
36394: LD_INT 8
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PPUSH
36405: CALL_OW 69
36409: NOT
36410: AND
36411: IFFALSE 36463
// begin wait ( 0 0$5 ) ;
36413: LD_INT 175
36415: PPUSH
36416: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
36420: LD_INT 22
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 34
36432: PUSH
36433: LD_INT 48
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PPUSH
36444: CALL_OW 69
36448: PUSH
36449: LD_INT 1
36451: ARRAY
36452: PPUSH
36453: LD_INT 60
36455: PPUSH
36456: LD_INT 95
36458: PPUSH
36459: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
36463: LD_VAR 0 2
36467: PPUSH
36468: LD_VAR 0 3
36472: PPUSH
36473: LD_INT 18
36475: PPUSH
36476: CALL_OW 309
36480: PUSH
36481: LD_VAR 0 2
36485: PPUSH
36486: LD_VAR 0 3
36490: PPUSH
36491: LD_INT 18
36493: PPUSH
36494: CALL 109658 0 3
36498: OR
36499: IFFALSE 36546
// begin if GetSide ( unit ) = 1 then
36501: LD_VAR 0 1
36505: PPUSH
36506: CALL_OW 255
36510: PUSH
36511: LD_INT 1
36513: EQUAL
36514: IFFALSE 36532
// begin wait ( 0 0$6 ) ;
36516: LD_INT 210
36518: PPUSH
36519: CALL_OW 67
// YouLost ( Motherlode2 ) ;
36523: LD_STRING Motherlode2
36525: PPUSH
36526: CALL_OW 104
// end else
36530: GO 36546
// begin wait ( 0 0$6 ) ;
36532: LD_INT 210
36534: PPUSH
36535: CALL_OW 67
// YouLost ( Motherlode1 ) ;
36539: LD_STRING Motherlode1
36541: PPUSH
36542: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
36546: LD_VAR 0 1
36550: PPUSH
36551: CALL_OW 255
36555: PUSH
36556: LD_INT 3
36558: EQUAL
36559: IFFALSE 36580
// begin wait ( 0 0$5 ) ;
36561: LD_INT 175
36563: PPUSH
36564: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
36568: LD_EXP 66
36572: PPUSH
36573: LD_STRING D18-Pla-1
36575: PPUSH
36576: CALL_OW 94
// end ; end ;
36580: PPOPN 3
36582: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
36583: LD_VAR 0 1
36587: PPUSH
36588: CALL 125715 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
36592: LD_VAR 0 1
36596: PUSH
36597: LD_INT 22
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 21
36609: PUSH
36610: LD_INT 1
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 23
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: LIST
36631: PPUSH
36632: CALL_OW 69
36636: IN
36637: IFFALSE 36653
// lostCounter := lostCounter + 1 ;
36639: LD_ADDR_EXP 32
36643: PUSH
36644: LD_EXP 32
36648: PUSH
36649: LD_INT 1
36651: PLUS
36652: ST_TO_ADDR
// if un in behemothBuilders then
36653: LD_VAR 0 1
36657: PUSH
36658: LD_EXP 75
36662: IN
36663: IFFALSE 36683
// begin behemothBuilders := behemothBuilders diff un ;
36665: LD_ADDR_EXP 75
36669: PUSH
36670: LD_EXP 75
36674: PUSH
36675: LD_VAR 0 1
36679: DIFF
36680: ST_TO_ADDR
// exit ;
36681: GO 36713
// end ; if un = JMM then
36683: LD_VAR 0 1
36687: PUSH
36688: LD_EXP 40
36692: EQUAL
36693: IFFALSE 36704
// begin YouLost ( JMM ) ;
36695: LD_STRING JMM
36697: PPUSH
36698: CALL_OW 104
// exit ;
36702: GO 36713
// end ; MCE_UnitDestroyed ( un ) ;
36704: LD_VAR 0 1
36708: PPUSH
36709: CALL 65573 0 1
// end ;
36713: PPOPN 1
36715: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
36716: LD_VAR 0 1
36720: PPUSH
36721: LD_VAR 0 2
36725: PPUSH
36726: CALL 67905 0 2
// end ;
36730: PPOPN 2
36732: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
36733: LD_VAR 0 1
36737: PPUSH
36738: CALL 66973 0 1
// end ;
36742: PPOPN 1
36744: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
36745: LD_VAR 0 1
36749: PUSH
36750: LD_INT 22
36752: PUSH
36753: LD_INT 8
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 30
36762: PUSH
36763: LD_INT 2
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 23
36772: PUSH
36773: LD_INT 3
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: LIST
36784: PPUSH
36785: CALL_OW 69
36789: IN
36790: IFFALSE 36817
// begin ComUpgrade ( building ) ;
36792: LD_VAR 0 1
36796: PPUSH
36797: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
36801: LD_EXP 63
36805: PPUSH
36806: LD_VAR 0 1
36810: PPUSH
36811: CALL 76380 0 2
// exit ;
36815: GO 36826
// end ; MCE_BuildingComplete ( building ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: CALL 67214 0 1
// end ;
36826: PPOPN 1
36828: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
36829: LD_VAR 0 1
36833: PPUSH
36834: LD_VAR 0 2
36838: PPUSH
36839: CALL 65269 0 2
// end ;
36843: PPOPN 2
36845: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
36846: LD_VAR 0 1
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: LD_VAR 0 3
36860: PPUSH
36861: LD_VAR 0 4
36865: PPUSH
36866: LD_VAR 0 5
36870: PPUSH
36871: CALL 64889 0 5
// end ;
36875: PPOPN 5
36877: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
36878: LD_VAR 0 1
36882: PPUSH
36883: CALL_OW 255
36887: PUSH
36888: LD_INT 1
36890: EQUAL
36891: IFFALSE 36908
// amConstructCounter := Inc ( amConstructCounter ) ;
36893: LD_ADDR_EXP 39
36897: PUSH
36898: LD_EXP 39
36902: PPUSH
36903: CALL 107210 0 1
36907: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
36908: LD_VAR 0 1
36912: PPUSH
36913: LD_VAR 0 2
36917: PPUSH
36918: CALL 125835 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
36922: LD_VAR 0 1
36926: PPUSH
36927: LD_VAR 0 2
36931: PPUSH
36932: CALL 64442 0 2
// end ;
36936: PPOPN 2
36938: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
36939: LD_VAR 0 1
36943: PPUSH
36944: LD_VAR 0 2
36948: PPUSH
36949: LD_VAR 0 3
36953: PPUSH
36954: LD_VAR 0 4
36958: PPUSH
36959: CALL 64280 0 4
// end ;
36963: PPOPN 4
36965: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
36966: LD_VAR 0 1
36970: PPUSH
36971: LD_VAR 0 2
36975: PPUSH
36976: LD_VAR 0 3
36980: PPUSH
36981: CALL 64055 0 3
// end ;
36985: PPOPN 3
36987: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
36988: LD_VAR 0 1
36992: PPUSH
36993: LD_VAR 0 2
36997: PPUSH
36998: CALL 63940 0 2
// end ;
37002: PPOPN 2
37004: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37005: LD_VAR 0 1
37009: PPUSH
37010: LD_VAR 0 2
37014: PPUSH
37015: CALL 68200 0 2
// end ;
37019: PPOPN 2
37021: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37022: LD_VAR 0 1
37026: PUSH
37027: LD_INT 460
37029: EQUAL
37030: IFFALSE 37052
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37032: LD_VAR 0 2
37036: PPUSH
37037: LD_INT 227
37039: PPUSH
37040: LD_INT 136
37042: PPUSH
37043: CALL_OW 428
37047: PPUSH
37048: CALL_OW 120
// end ;
37052: PPOPN 2
37054: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37055: LD_VAR 0 1
37059: PPUSH
37060: CALL_OW 255
37064: PUSH
37065: LD_INT 4
37067: EQUAL
37068: PUSH
37069: LD_VAR 0 1
37073: PUSH
37074: LD_EXP 18
37078: PUSH
37079: LD_INT 1
37081: ARRAY
37082: IN
37083: AND
37084: PUSH
37085: LD_EXP 19
37089: AND
37090: IFFALSE 37109
// begin ComMoveXY ( driver , 61 , 93 ) ;
37092: LD_VAR 0 1
37096: PPUSH
37097: LD_INT 61
37099: PPUSH
37100: LD_INT 93
37102: PPUSH
37103: CALL_OW 111
// exit ;
37107: GO 37133
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37109: LD_VAR 0 1
37113: PPUSH
37114: LD_VAR 0 2
37118: PPUSH
37119: LD_VAR 0 3
37123: PPUSH
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL 68416 0 4
// end ;
37133: PPOPN 4
37135: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37136: LD_VAR 0 1
37140: PPUSH
37141: LD_VAR 0 2
37145: PPUSH
37146: CALL 63749 0 2
// end ;
37150: PPOPN 2
37152: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
37153: LD_VAR 0 1
37157: PPUSH
37158: CALL 125819 0 1
// end ; end_of_file
37162: PPOPN 1
37164: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
37165: LD_EXP 15
37169: PUSH
37170: LD_INT 2
37172: EQUAL
37173: IFFALSE 37676
37175: GO 37177
37177: DISABLE
37178: LD_INT 0
37180: PPUSH
37181: PPUSH
// begin time := 0 0$35 ;
37182: LD_ADDR_VAR 0 2
37186: PUSH
37187: LD_INT 1225
37189: ST_TO_ADDR
// repeat wait ( time ) ;
37190: LD_VAR 0 2
37194: PPUSH
37195: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
37199: LD_INT 1
37201: PPUSH
37202: LD_INT 5
37204: PPUSH
37205: CALL_OW 12
37209: PPUSH
37210: LD_INT 106
37212: PPUSH
37213: LD_INT 150
37215: PPUSH
37216: LD_INT 19
37218: PPUSH
37219: LD_INT 1
37221: PPUSH
37222: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
37226: LD_INT 455
37228: PPUSH
37229: LD_INT 770
37231: PPUSH
37232: CALL_OW 12
37236: PPUSH
37237: CALL_OW 67
// if Prob ( 50 ) then
37241: LD_INT 50
37243: PPUSH
37244: CALL_OW 13
37248: IFFALSE 37277
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
37250: LD_INT 1
37252: PPUSH
37253: LD_INT 5
37255: PPUSH
37256: CALL_OW 12
37260: PPUSH
37261: LD_INT 62
37263: PPUSH
37264: LD_INT 108
37266: PPUSH
37267: LD_INT 10
37269: PPUSH
37270: LD_INT 1
37272: PPUSH
37273: CALL_OW 56
// until missionStage > 4 ;
37277: LD_EXP 15
37281: PUSH
37282: LD_INT 4
37284: GREATER
37285: IFFALSE 37190
// repeat wait ( 0 0$1 ) ;
37287: LD_INT 35
37289: PPUSH
37290: CALL_OW 67
// until missionStage = 6 ;
37294: LD_EXP 15
37298: PUSH
37299: LD_INT 6
37301: EQUAL
37302: IFFALSE 37287
// time := 0 0$20 ;
37304: LD_ADDR_VAR 0 2
37308: PUSH
37309: LD_INT 700
37311: ST_TO_ADDR
// repeat wait ( time ) ;
37312: LD_VAR 0 2
37316: PPUSH
37317: CALL_OW 67
// if Prob ( 90 ) then
37321: LD_INT 90
37323: PPUSH
37324: CALL_OW 13
37328: IFFALSE 37371
// begin time := time + 0 0$2 ;
37330: LD_ADDR_VAR 0 2
37334: PUSH
37335: LD_VAR 0 2
37339: PUSH
37340: LD_INT 70
37342: PLUS
37343: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
37344: LD_INT 1
37346: PPUSH
37347: LD_INT 5
37349: PPUSH
37350: CALL_OW 12
37354: PPUSH
37355: LD_INT 106
37357: PPUSH
37358: LD_INT 89
37360: PPUSH
37361: LD_INT 45
37363: PPUSH
37364: LD_INT 1
37366: PPUSH
37367: CALL_OW 56
// end ; if Prob ( 45 ) then
37371: LD_INT 45
37373: PPUSH
37374: CALL_OW 13
37378: IFFALSE 37434
// begin for i := 1 to 4 do
37380: LD_ADDR_VAR 0 1
37384: PUSH
37385: DOUBLE
37386: LD_INT 1
37388: DEC
37389: ST_TO_ADDR
37390: LD_INT 4
37392: PUSH
37393: FOR_TO
37394: IFFALSE 37432
// begin wait ( 0 0$5 ) ;
37396: LD_INT 175
37398: PPUSH
37399: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
37403: LD_INT 1
37405: PPUSH
37406: LD_INT 5
37408: PPUSH
37409: CALL_OW 12
37413: PPUSH
37414: LD_INT 113
37416: PPUSH
37417: LD_INT 117
37419: PPUSH
37420: LD_INT 25
37422: PPUSH
37423: LD_INT 1
37425: PPUSH
37426: CALL_OW 56
// end ;
37430: GO 37393
37432: POP
37433: POP
// end ; if Prob ( 40 ) then
37434: LD_INT 40
37436: PPUSH
37437: CALL_OW 13
37441: IFFALSE 37487
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
37443: LD_INT 385
37445: PPUSH
37446: LD_INT 945
37448: PPUSH
37449: CALL_OW 12
37453: PPUSH
37454: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
37458: LD_INT 1
37460: PPUSH
37461: LD_INT 5
37463: PPUSH
37464: CALL_OW 12
37468: PPUSH
37469: LD_INT 21
37471: PPUSH
37472: LD_INT 26
37474: PPUSH
37475: LD_INT 12
37477: PPUSH
37478: LD_INT 1
37480: PPUSH
37481: CALL_OW 56
// end else
37485: GO 37523
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
37487: LD_INT 700
37489: PPUSH
37490: LD_INT 1225
37492: PPUSH
37493: CALL_OW 12
37497: PPUSH
37498: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
37502: LD_INT 1
37504: PPUSH
37505: LD_INT 5
37507: PPUSH
37508: CALL_OW 12
37512: PPUSH
37513: LD_INT 16
37515: PPUSH
37516: LD_INT 1
37518: PPUSH
37519: CALL_OW 55
// end ; if Prob ( 50 ) then
37523: LD_INT 50
37525: PPUSH
37526: CALL_OW 13
37530: IFFALSE 37576
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
37532: LD_INT 700
37534: PPUSH
37535: LD_INT 1050
37537: PPUSH
37538: CALL_OW 12
37542: PPUSH
37543: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
37547: LD_INT 1
37549: PPUSH
37550: LD_INT 5
37552: PPUSH
37553: CALL_OW 12
37557: PPUSH
37558: LD_INT 168
37560: PPUSH
37561: LD_INT 168
37563: PPUSH
37564: LD_INT 16
37566: PPUSH
37567: LD_INT 1
37569: PPUSH
37570: CALL_OW 56
// end else
37574: GO 37612
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
37576: LD_INT 350
37578: PPUSH
37579: LD_INT 525
37581: PPUSH
37582: CALL_OW 12
37586: PPUSH
37587: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
37591: LD_INT 1
37593: PPUSH
37594: LD_INT 5
37596: PPUSH
37597: CALL_OW 12
37601: PPUSH
37602: LD_INT 15
37604: PPUSH
37605: LD_INT 1
37607: PPUSH
37608: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
37612: LD_INT 175
37614: PPUSH
37615: LD_INT 315
37617: PPUSH
37618: CALL_OW 12
37622: PPUSH
37623: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
37627: LD_INT 1
37629: PPUSH
37630: LD_INT 5
37632: PPUSH
37633: CALL_OW 12
37637: PPUSH
37638: LD_INT 103
37640: PPUSH
37641: LD_INT 140
37643: PPUSH
37644: LD_INT 20
37646: PPUSH
37647: LD_INT 1
37649: PPUSH
37650: CALL_OW 56
// if time > 1 1$10 then
37654: LD_VAR 0 2
37658: PUSH
37659: LD_INT 2450
37661: GREATER
37662: IFFALSE 37672
// time := 0 0$30 ;
37664: LD_ADDR_VAR 0 2
37668: PUSH
37669: LD_INT 1050
37671: ST_TO_ADDR
// until false ;
37672: LD_INT 0
37674: IFFALSE 37312
// end ; end_of_file
37676: PPOPN 2
37678: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
37679: LD_EXP 13
37683: PUSH
37684: LD_EXP 15
37688: PUSH
37689: LD_INT 6
37691: GREATEREQUAL
37692: AND
37693: IFFALSE 37730
37695: GO 37697
37697: DISABLE
// begin enable ;
37698: ENABLE
// missionTime := missionTime + 0 0$1 ;
37699: LD_ADDR_EXP 14
37703: PUSH
37704: LD_EXP 14
37708: PUSH
37709: LD_INT 35
37711: PLUS
37712: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
37713: LD_ADDR_OWVAR 47
37717: PUSH
37718: LD_STRING #Am15-1
37720: PUSH
37721: LD_EXP 14
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: ST_TO_ADDR
// end ; end_of_file
37730: END
// export function InitNature ; begin
37731: LD_INT 0
37733: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
37734: LD_INT 3
37736: PPUSH
37737: LD_INT 3
37739: PPUSH
37740: LD_INT 2
37742: PPUSH
37743: LD_INT 1
37745: PPUSH
37746: LD_INT 1
37748: PPUSH
37749: LD_INT 0
37751: PPUSH
37752: LD_INT 0
37754: PPUSH
37755: LD_INT 20
37757: PPUSH
37758: LD_INT 0
37760: PPUSH
37761: CALL 102539 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
37765: LD_INT 2
37767: PPUSH
37768: LD_INT 1
37770: PPUSH
37771: LD_INT 1
37773: PPUSH
37774: LD_INT 1
37776: PPUSH
37777: LD_INT 1
37779: PPUSH
37780: LD_INT 0
37782: PPUSH
37783: LD_INT 0
37785: PPUSH
37786: LD_INT 21
37788: PPUSH
37789: LD_INT 0
37791: PPUSH
37792: CALL 102539 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
37796: LD_INT 4
37798: PPUSH
37799: LD_INT 1
37801: PPUSH
37802: LD_INT 2
37804: PPUSH
37805: LD_INT 4
37807: PPUSH
37808: LD_INT 2
37810: PPUSH
37811: LD_INT 1
37813: PPUSH
37814: LD_INT 0
37816: PPUSH
37817: LD_INT 22
37819: PPUSH
37820: LD_INT 0
37822: PPUSH
37823: CALL 102539 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
37827: LD_INT 0
37829: PPUSH
37830: LD_INT 0
37832: PPUSH
37833: LD_INT 0
37835: PPUSH
37836: LD_INT 0
37838: PPUSH
37839: LD_INT 0
37841: PPUSH
37842: LD_INT 0
37844: PPUSH
37845: LD_INT 9
37847: PPUSH
37848: LD_INT 0
37850: PPUSH
37851: LD_INT 23
37853: PPUSH
37854: CALL 102539 0 9
// end ; end_of_file
37858: LD_VAR 0 1
37862: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
37863: LD_INT 0
37865: PPUSH
37866: PPUSH
// skirmish := false ;
37867: LD_ADDR_EXP 98
37871: PUSH
37872: LD_INT 0
37874: ST_TO_ADDR
// debug_mc := false ;
37875: LD_ADDR_EXP 99
37879: PUSH
37880: LD_INT 0
37882: ST_TO_ADDR
// mc_bases := [ ] ;
37883: LD_ADDR_EXP 100
37887: PUSH
37888: EMPTY
37889: ST_TO_ADDR
// mc_sides := [ ] ;
37890: LD_ADDR_EXP 126
37894: PUSH
37895: EMPTY
37896: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
37897: LD_ADDR_EXP 101
37901: PUSH
37902: EMPTY
37903: ST_TO_ADDR
// mc_building_repairs := [ ] ;
37904: LD_ADDR_EXP 102
37908: PUSH
37909: EMPTY
37910: ST_TO_ADDR
// mc_need_heal := [ ] ;
37911: LD_ADDR_EXP 103
37915: PUSH
37916: EMPTY
37917: ST_TO_ADDR
// mc_healers := [ ] ;
37918: LD_ADDR_EXP 104
37922: PUSH
37923: EMPTY
37924: ST_TO_ADDR
// mc_build_list := [ ] ;
37925: LD_ADDR_EXP 105
37929: PUSH
37930: EMPTY
37931: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
37932: LD_ADDR_EXP 132
37936: PUSH
37937: EMPTY
37938: ST_TO_ADDR
// mc_builders := [ ] ;
37939: LD_ADDR_EXP 106
37943: PUSH
37944: EMPTY
37945: ST_TO_ADDR
// mc_construct_list := [ ] ;
37946: LD_ADDR_EXP 107
37950: PUSH
37951: EMPTY
37952: ST_TO_ADDR
// mc_turret_list := [ ] ;
37953: LD_ADDR_EXP 108
37957: PUSH
37958: EMPTY
37959: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
37960: LD_ADDR_EXP 109
37964: PUSH
37965: EMPTY
37966: ST_TO_ADDR
// mc_miners := [ ] ;
37967: LD_ADDR_EXP 114
37971: PUSH
37972: EMPTY
37973: ST_TO_ADDR
// mc_mines := [ ] ;
37974: LD_ADDR_EXP 113
37978: PUSH
37979: EMPTY
37980: ST_TO_ADDR
// mc_minefields := [ ] ;
37981: LD_ADDR_EXP 115
37985: PUSH
37986: EMPTY
37987: ST_TO_ADDR
// mc_crates := [ ] ;
37988: LD_ADDR_EXP 116
37992: PUSH
37993: EMPTY
37994: ST_TO_ADDR
// mc_crates_collector := [ ] ;
37995: LD_ADDR_EXP 117
37999: PUSH
38000: EMPTY
38001: ST_TO_ADDR
// mc_crates_area := [ ] ;
38002: LD_ADDR_EXP 118
38006: PUSH
38007: EMPTY
38008: ST_TO_ADDR
// mc_vehicles := [ ] ;
38009: LD_ADDR_EXP 119
38013: PUSH
38014: EMPTY
38015: ST_TO_ADDR
// mc_attack := [ ] ;
38016: LD_ADDR_EXP 120
38020: PUSH
38021: EMPTY
38022: ST_TO_ADDR
// mc_produce := [ ] ;
38023: LD_ADDR_EXP 121
38027: PUSH
38028: EMPTY
38029: ST_TO_ADDR
// mc_defender := [ ] ;
38030: LD_ADDR_EXP 122
38034: PUSH
38035: EMPTY
38036: ST_TO_ADDR
// mc_parking := [ ] ;
38037: LD_ADDR_EXP 124
38041: PUSH
38042: EMPTY
38043: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38044: LD_ADDR_EXP 110
38048: PUSH
38049: EMPTY
38050: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38051: LD_ADDR_EXP 112
38055: PUSH
38056: EMPTY
38057: ST_TO_ADDR
// mc_scan := [ ] ;
38058: LD_ADDR_EXP 123
38062: PUSH
38063: EMPTY
38064: ST_TO_ADDR
// mc_scan_area := [ ] ;
38065: LD_ADDR_EXP 125
38069: PUSH
38070: EMPTY
38071: ST_TO_ADDR
// mc_tech := [ ] ;
38072: LD_ADDR_EXP 127
38076: PUSH
38077: EMPTY
38078: ST_TO_ADDR
// mc_class := [ ] ;
38079: LD_ADDR_EXP 141
38083: PUSH
38084: EMPTY
38085: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38086: LD_ADDR_EXP 142
38090: PUSH
38091: EMPTY
38092: ST_TO_ADDR
// mc_is_defending := [ ] ;
38093: LD_ADDR_EXP 143
38097: PUSH
38098: EMPTY
38099: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38100: LD_ADDR_EXP 134
38104: PUSH
38105: EMPTY
38106: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38107: LD_ADDR_EXP 144
38111: PUSH
38112: LD_INT 0
38114: ST_TO_ADDR
// end ;
38115: LD_VAR 0 1
38119: RET
// export function MC_Kill ( base ) ; begin
38120: LD_INT 0
38122: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38123: LD_ADDR_EXP 100
38127: PUSH
38128: LD_EXP 100
38132: PPUSH
38133: LD_VAR 0 1
38137: PPUSH
38138: EMPTY
38139: PPUSH
38140: CALL_OW 1
38144: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38145: LD_ADDR_EXP 101
38149: PUSH
38150: LD_EXP 101
38154: PPUSH
38155: LD_VAR 0 1
38159: PPUSH
38160: EMPTY
38161: PPUSH
38162: CALL_OW 1
38166: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38167: LD_ADDR_EXP 102
38171: PUSH
38172: LD_EXP 102
38176: PPUSH
38177: LD_VAR 0 1
38181: PPUSH
38182: EMPTY
38183: PPUSH
38184: CALL_OW 1
38188: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38189: LD_ADDR_EXP 103
38193: PUSH
38194: LD_EXP 103
38198: PPUSH
38199: LD_VAR 0 1
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL_OW 1
38210: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38211: LD_ADDR_EXP 104
38215: PUSH
38216: LD_EXP 104
38220: PPUSH
38221: LD_VAR 0 1
38225: PPUSH
38226: EMPTY
38227: PPUSH
38228: CALL_OW 1
38232: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38233: LD_ADDR_EXP 105
38237: PUSH
38238: LD_EXP 105
38242: PPUSH
38243: LD_VAR 0 1
38247: PPUSH
38248: EMPTY
38249: PPUSH
38250: CALL_OW 1
38254: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38255: LD_ADDR_EXP 106
38259: PUSH
38260: LD_EXP 106
38264: PPUSH
38265: LD_VAR 0 1
38269: PPUSH
38270: EMPTY
38271: PPUSH
38272: CALL_OW 1
38276: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38277: LD_ADDR_EXP 107
38281: PUSH
38282: LD_EXP 107
38286: PPUSH
38287: LD_VAR 0 1
38291: PPUSH
38292: EMPTY
38293: PPUSH
38294: CALL_OW 1
38298: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38299: LD_ADDR_EXP 108
38303: PUSH
38304: LD_EXP 108
38308: PPUSH
38309: LD_VAR 0 1
38313: PPUSH
38314: EMPTY
38315: PPUSH
38316: CALL_OW 1
38320: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38321: LD_ADDR_EXP 109
38325: PUSH
38326: LD_EXP 109
38330: PPUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: EMPTY
38337: PPUSH
38338: CALL_OW 1
38342: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38343: LD_ADDR_EXP 110
38347: PUSH
38348: LD_EXP 110
38352: PPUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: EMPTY
38359: PPUSH
38360: CALL_OW 1
38364: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38365: LD_ADDR_EXP 111
38369: PUSH
38370: LD_EXP 111
38374: PPUSH
38375: LD_VAR 0 1
38379: PPUSH
38380: LD_INT 0
38382: PPUSH
38383: CALL_OW 1
38387: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38388: LD_ADDR_EXP 112
38392: PUSH
38393: LD_EXP 112
38397: PPUSH
38398: LD_VAR 0 1
38402: PPUSH
38403: EMPTY
38404: PPUSH
38405: CALL_OW 1
38409: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38410: LD_ADDR_EXP 113
38414: PUSH
38415: LD_EXP 113
38419: PPUSH
38420: LD_VAR 0 1
38424: PPUSH
38425: EMPTY
38426: PPUSH
38427: CALL_OW 1
38431: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38432: LD_ADDR_EXP 114
38436: PUSH
38437: LD_EXP 114
38441: PPUSH
38442: LD_VAR 0 1
38446: PPUSH
38447: EMPTY
38448: PPUSH
38449: CALL_OW 1
38453: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38454: LD_ADDR_EXP 115
38458: PUSH
38459: LD_EXP 115
38463: PPUSH
38464: LD_VAR 0 1
38468: PPUSH
38469: EMPTY
38470: PPUSH
38471: CALL_OW 1
38475: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38476: LD_ADDR_EXP 116
38480: PUSH
38481: LD_EXP 116
38485: PPUSH
38486: LD_VAR 0 1
38490: PPUSH
38491: EMPTY
38492: PPUSH
38493: CALL_OW 1
38497: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38498: LD_ADDR_EXP 117
38502: PUSH
38503: LD_EXP 117
38507: PPUSH
38508: LD_VAR 0 1
38512: PPUSH
38513: EMPTY
38514: PPUSH
38515: CALL_OW 1
38519: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38520: LD_ADDR_EXP 118
38524: PUSH
38525: LD_EXP 118
38529: PPUSH
38530: LD_VAR 0 1
38534: PPUSH
38535: EMPTY
38536: PPUSH
38537: CALL_OW 1
38541: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38542: LD_ADDR_EXP 119
38546: PUSH
38547: LD_EXP 119
38551: PPUSH
38552: LD_VAR 0 1
38556: PPUSH
38557: EMPTY
38558: PPUSH
38559: CALL_OW 1
38563: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38564: LD_ADDR_EXP 120
38568: PUSH
38569: LD_EXP 120
38573: PPUSH
38574: LD_VAR 0 1
38578: PPUSH
38579: EMPTY
38580: PPUSH
38581: CALL_OW 1
38585: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38586: LD_ADDR_EXP 121
38590: PUSH
38591: LD_EXP 121
38595: PPUSH
38596: LD_VAR 0 1
38600: PPUSH
38601: EMPTY
38602: PPUSH
38603: CALL_OW 1
38607: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38608: LD_ADDR_EXP 122
38612: PUSH
38613: LD_EXP 122
38617: PPUSH
38618: LD_VAR 0 1
38622: PPUSH
38623: EMPTY
38624: PPUSH
38625: CALL_OW 1
38629: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38630: LD_ADDR_EXP 123
38634: PUSH
38635: LD_EXP 123
38639: PPUSH
38640: LD_VAR 0 1
38644: PPUSH
38645: EMPTY
38646: PPUSH
38647: CALL_OW 1
38651: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38652: LD_ADDR_EXP 124
38656: PUSH
38657: LD_EXP 124
38661: PPUSH
38662: LD_VAR 0 1
38666: PPUSH
38667: EMPTY
38668: PPUSH
38669: CALL_OW 1
38673: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38674: LD_ADDR_EXP 125
38678: PUSH
38679: LD_EXP 125
38683: PPUSH
38684: LD_VAR 0 1
38688: PPUSH
38689: EMPTY
38690: PPUSH
38691: CALL_OW 1
38695: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38696: LD_ADDR_EXP 127
38700: PUSH
38701: LD_EXP 127
38705: PPUSH
38706: LD_VAR 0 1
38710: PPUSH
38711: EMPTY
38712: PPUSH
38713: CALL_OW 1
38717: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38718: LD_ADDR_EXP 129
38722: PUSH
38723: LD_EXP 129
38727: PPUSH
38728: LD_VAR 0 1
38732: PPUSH
38733: EMPTY
38734: PPUSH
38735: CALL_OW 1
38739: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38740: LD_ADDR_EXP 130
38744: PUSH
38745: LD_EXP 130
38749: PPUSH
38750: LD_VAR 0 1
38754: PPUSH
38755: EMPTY
38756: PPUSH
38757: CALL_OW 1
38761: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38762: LD_ADDR_EXP 131
38766: PUSH
38767: LD_EXP 131
38771: PPUSH
38772: LD_VAR 0 1
38776: PPUSH
38777: EMPTY
38778: PPUSH
38779: CALL_OW 1
38783: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38784: LD_ADDR_EXP 132
38788: PUSH
38789: LD_EXP 132
38793: PPUSH
38794: LD_VAR 0 1
38798: PPUSH
38799: EMPTY
38800: PPUSH
38801: CALL_OW 1
38805: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38806: LD_ADDR_EXP 133
38810: PUSH
38811: LD_EXP 133
38815: PPUSH
38816: LD_VAR 0 1
38820: PPUSH
38821: EMPTY
38822: PPUSH
38823: CALL_OW 1
38827: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38828: LD_ADDR_EXP 134
38832: PUSH
38833: LD_EXP 134
38837: PPUSH
38838: LD_VAR 0 1
38842: PPUSH
38843: EMPTY
38844: PPUSH
38845: CALL_OW 1
38849: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38850: LD_ADDR_EXP 135
38854: PUSH
38855: LD_EXP 135
38859: PPUSH
38860: LD_VAR 0 1
38864: PPUSH
38865: EMPTY
38866: PPUSH
38867: CALL_OW 1
38871: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38872: LD_ADDR_EXP 136
38876: PUSH
38877: LD_EXP 136
38881: PPUSH
38882: LD_VAR 0 1
38886: PPUSH
38887: EMPTY
38888: PPUSH
38889: CALL_OW 1
38893: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38894: LD_ADDR_EXP 137
38898: PUSH
38899: LD_EXP 137
38903: PPUSH
38904: LD_VAR 0 1
38908: PPUSH
38909: EMPTY
38910: PPUSH
38911: CALL_OW 1
38915: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38916: LD_ADDR_EXP 138
38920: PUSH
38921: LD_EXP 138
38925: PPUSH
38926: LD_VAR 0 1
38930: PPUSH
38931: EMPTY
38932: PPUSH
38933: CALL_OW 1
38937: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38938: LD_ADDR_EXP 139
38942: PUSH
38943: LD_EXP 139
38947: PPUSH
38948: LD_VAR 0 1
38952: PPUSH
38953: EMPTY
38954: PPUSH
38955: CALL_OW 1
38959: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38960: LD_ADDR_EXP 140
38964: PUSH
38965: LD_EXP 140
38969: PPUSH
38970: LD_VAR 0 1
38974: PPUSH
38975: EMPTY
38976: PPUSH
38977: CALL_OW 1
38981: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38982: LD_ADDR_EXP 141
38986: PUSH
38987: LD_EXP 141
38991: PPUSH
38992: LD_VAR 0 1
38996: PPUSH
38997: EMPTY
38998: PPUSH
38999: CALL_OW 1
39003: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39004: LD_ADDR_EXP 142
39008: PUSH
39009: LD_EXP 142
39013: PPUSH
39014: LD_VAR 0 1
39018: PPUSH
39019: LD_INT 0
39021: PPUSH
39022: CALL_OW 1
39026: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39027: LD_ADDR_EXP 143
39031: PUSH
39032: LD_EXP 143
39036: PPUSH
39037: LD_VAR 0 1
39041: PPUSH
39042: LD_INT 0
39044: PPUSH
39045: CALL_OW 1
39049: ST_TO_ADDR
// end ;
39050: LD_VAR 0 2
39054: RET
// export function MC_Add ( side , units ) ; var base ; begin
39055: LD_INT 0
39057: PPUSH
39058: PPUSH
// base := mc_bases + 1 ;
39059: LD_ADDR_VAR 0 4
39063: PUSH
39064: LD_EXP 100
39068: PUSH
39069: LD_INT 1
39071: PLUS
39072: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39073: LD_ADDR_EXP 126
39077: PUSH
39078: LD_EXP 126
39082: PPUSH
39083: LD_VAR 0 4
39087: PPUSH
39088: LD_VAR 0 1
39092: PPUSH
39093: CALL_OW 1
39097: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39098: LD_ADDR_EXP 100
39102: PUSH
39103: LD_EXP 100
39107: PPUSH
39108: LD_VAR 0 4
39112: PPUSH
39113: LD_VAR 0 2
39117: PPUSH
39118: CALL_OW 1
39122: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39123: LD_ADDR_EXP 101
39127: PUSH
39128: LD_EXP 101
39132: PPUSH
39133: LD_VAR 0 4
39137: PPUSH
39138: EMPTY
39139: PPUSH
39140: CALL_OW 1
39144: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39145: LD_ADDR_EXP 102
39149: PUSH
39150: LD_EXP 102
39154: PPUSH
39155: LD_VAR 0 4
39159: PPUSH
39160: EMPTY
39161: PPUSH
39162: CALL_OW 1
39166: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39167: LD_ADDR_EXP 103
39171: PUSH
39172: LD_EXP 103
39176: PPUSH
39177: LD_VAR 0 4
39181: PPUSH
39182: EMPTY
39183: PPUSH
39184: CALL_OW 1
39188: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39189: LD_ADDR_EXP 104
39193: PUSH
39194: LD_EXP 104
39198: PPUSH
39199: LD_VAR 0 4
39203: PPUSH
39204: EMPTY
39205: PPUSH
39206: CALL_OW 1
39210: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39211: LD_ADDR_EXP 105
39215: PUSH
39216: LD_EXP 105
39220: PPUSH
39221: LD_VAR 0 4
39225: PPUSH
39226: EMPTY
39227: PPUSH
39228: CALL_OW 1
39232: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39233: LD_ADDR_EXP 106
39237: PUSH
39238: LD_EXP 106
39242: PPUSH
39243: LD_VAR 0 4
39247: PPUSH
39248: EMPTY
39249: PPUSH
39250: CALL_OW 1
39254: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39255: LD_ADDR_EXP 107
39259: PUSH
39260: LD_EXP 107
39264: PPUSH
39265: LD_VAR 0 4
39269: PPUSH
39270: EMPTY
39271: PPUSH
39272: CALL_OW 1
39276: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39277: LD_ADDR_EXP 108
39281: PUSH
39282: LD_EXP 108
39286: PPUSH
39287: LD_VAR 0 4
39291: PPUSH
39292: EMPTY
39293: PPUSH
39294: CALL_OW 1
39298: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39299: LD_ADDR_EXP 109
39303: PUSH
39304: LD_EXP 109
39308: PPUSH
39309: LD_VAR 0 4
39313: PPUSH
39314: EMPTY
39315: PPUSH
39316: CALL_OW 1
39320: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39321: LD_ADDR_EXP 110
39325: PUSH
39326: LD_EXP 110
39330: PPUSH
39331: LD_VAR 0 4
39335: PPUSH
39336: EMPTY
39337: PPUSH
39338: CALL_OW 1
39342: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39343: LD_ADDR_EXP 111
39347: PUSH
39348: LD_EXP 111
39352: PPUSH
39353: LD_VAR 0 4
39357: PPUSH
39358: LD_INT 0
39360: PPUSH
39361: CALL_OW 1
39365: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39366: LD_ADDR_EXP 112
39370: PUSH
39371: LD_EXP 112
39375: PPUSH
39376: LD_VAR 0 4
39380: PPUSH
39381: EMPTY
39382: PPUSH
39383: CALL_OW 1
39387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39388: LD_ADDR_EXP 113
39392: PUSH
39393: LD_EXP 113
39397: PPUSH
39398: LD_VAR 0 4
39402: PPUSH
39403: EMPTY
39404: PPUSH
39405: CALL_OW 1
39409: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39410: LD_ADDR_EXP 114
39414: PUSH
39415: LD_EXP 114
39419: PPUSH
39420: LD_VAR 0 4
39424: PPUSH
39425: EMPTY
39426: PPUSH
39427: CALL_OW 1
39431: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39432: LD_ADDR_EXP 115
39436: PUSH
39437: LD_EXP 115
39441: PPUSH
39442: LD_VAR 0 4
39446: PPUSH
39447: EMPTY
39448: PPUSH
39449: CALL_OW 1
39453: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39454: LD_ADDR_EXP 116
39458: PUSH
39459: LD_EXP 116
39463: PPUSH
39464: LD_VAR 0 4
39468: PPUSH
39469: EMPTY
39470: PPUSH
39471: CALL_OW 1
39475: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39476: LD_ADDR_EXP 117
39480: PUSH
39481: LD_EXP 117
39485: PPUSH
39486: LD_VAR 0 4
39490: PPUSH
39491: EMPTY
39492: PPUSH
39493: CALL_OW 1
39497: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39498: LD_ADDR_EXP 118
39502: PUSH
39503: LD_EXP 118
39507: PPUSH
39508: LD_VAR 0 4
39512: PPUSH
39513: EMPTY
39514: PPUSH
39515: CALL_OW 1
39519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39520: LD_ADDR_EXP 119
39524: PUSH
39525: LD_EXP 119
39529: PPUSH
39530: LD_VAR 0 4
39534: PPUSH
39535: EMPTY
39536: PPUSH
39537: CALL_OW 1
39541: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39542: LD_ADDR_EXP 120
39546: PUSH
39547: LD_EXP 120
39551: PPUSH
39552: LD_VAR 0 4
39556: PPUSH
39557: EMPTY
39558: PPUSH
39559: CALL_OW 1
39563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39564: LD_ADDR_EXP 121
39568: PUSH
39569: LD_EXP 121
39573: PPUSH
39574: LD_VAR 0 4
39578: PPUSH
39579: EMPTY
39580: PPUSH
39581: CALL_OW 1
39585: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39586: LD_ADDR_EXP 122
39590: PUSH
39591: LD_EXP 122
39595: PPUSH
39596: LD_VAR 0 4
39600: PPUSH
39601: EMPTY
39602: PPUSH
39603: CALL_OW 1
39607: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39608: LD_ADDR_EXP 123
39612: PUSH
39613: LD_EXP 123
39617: PPUSH
39618: LD_VAR 0 4
39622: PPUSH
39623: EMPTY
39624: PPUSH
39625: CALL_OW 1
39629: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39630: LD_ADDR_EXP 124
39634: PUSH
39635: LD_EXP 124
39639: PPUSH
39640: LD_VAR 0 4
39644: PPUSH
39645: EMPTY
39646: PPUSH
39647: CALL_OW 1
39651: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39652: LD_ADDR_EXP 125
39656: PUSH
39657: LD_EXP 125
39661: PPUSH
39662: LD_VAR 0 4
39666: PPUSH
39667: EMPTY
39668: PPUSH
39669: CALL_OW 1
39673: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39674: LD_ADDR_EXP 127
39678: PUSH
39679: LD_EXP 127
39683: PPUSH
39684: LD_VAR 0 4
39688: PPUSH
39689: EMPTY
39690: PPUSH
39691: CALL_OW 1
39695: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39696: LD_ADDR_EXP 129
39700: PUSH
39701: LD_EXP 129
39705: PPUSH
39706: LD_VAR 0 4
39710: PPUSH
39711: EMPTY
39712: PPUSH
39713: CALL_OW 1
39717: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39718: LD_ADDR_EXP 130
39722: PUSH
39723: LD_EXP 130
39727: PPUSH
39728: LD_VAR 0 4
39732: PPUSH
39733: EMPTY
39734: PPUSH
39735: CALL_OW 1
39739: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39740: LD_ADDR_EXP 131
39744: PUSH
39745: LD_EXP 131
39749: PPUSH
39750: LD_VAR 0 4
39754: PPUSH
39755: EMPTY
39756: PPUSH
39757: CALL_OW 1
39761: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39762: LD_ADDR_EXP 132
39766: PUSH
39767: LD_EXP 132
39771: PPUSH
39772: LD_VAR 0 4
39776: PPUSH
39777: EMPTY
39778: PPUSH
39779: CALL_OW 1
39783: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39784: LD_ADDR_EXP 133
39788: PUSH
39789: LD_EXP 133
39793: PPUSH
39794: LD_VAR 0 4
39798: PPUSH
39799: EMPTY
39800: PPUSH
39801: CALL_OW 1
39805: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39806: LD_ADDR_EXP 134
39810: PUSH
39811: LD_EXP 134
39815: PPUSH
39816: LD_VAR 0 4
39820: PPUSH
39821: EMPTY
39822: PPUSH
39823: CALL_OW 1
39827: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39828: LD_ADDR_EXP 135
39832: PUSH
39833: LD_EXP 135
39837: PPUSH
39838: LD_VAR 0 4
39842: PPUSH
39843: EMPTY
39844: PPUSH
39845: CALL_OW 1
39849: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39850: LD_ADDR_EXP 136
39854: PUSH
39855: LD_EXP 136
39859: PPUSH
39860: LD_VAR 0 4
39864: PPUSH
39865: EMPTY
39866: PPUSH
39867: CALL_OW 1
39871: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39872: LD_ADDR_EXP 137
39876: PUSH
39877: LD_EXP 137
39881: PPUSH
39882: LD_VAR 0 4
39886: PPUSH
39887: EMPTY
39888: PPUSH
39889: CALL_OW 1
39893: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39894: LD_ADDR_EXP 138
39898: PUSH
39899: LD_EXP 138
39903: PPUSH
39904: LD_VAR 0 4
39908: PPUSH
39909: EMPTY
39910: PPUSH
39911: CALL_OW 1
39915: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39916: LD_ADDR_EXP 139
39920: PUSH
39921: LD_EXP 139
39925: PPUSH
39926: LD_VAR 0 4
39930: PPUSH
39931: EMPTY
39932: PPUSH
39933: CALL_OW 1
39937: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39938: LD_ADDR_EXP 140
39942: PUSH
39943: LD_EXP 140
39947: PPUSH
39948: LD_VAR 0 4
39952: PPUSH
39953: EMPTY
39954: PPUSH
39955: CALL_OW 1
39959: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39960: LD_ADDR_EXP 141
39964: PUSH
39965: LD_EXP 141
39969: PPUSH
39970: LD_VAR 0 4
39974: PPUSH
39975: EMPTY
39976: PPUSH
39977: CALL_OW 1
39981: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39982: LD_ADDR_EXP 142
39986: PUSH
39987: LD_EXP 142
39991: PPUSH
39992: LD_VAR 0 4
39996: PPUSH
39997: LD_INT 0
39999: PPUSH
40000: CALL_OW 1
40004: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40005: LD_ADDR_EXP 143
40009: PUSH
40010: LD_EXP 143
40014: PPUSH
40015: LD_VAR 0 4
40019: PPUSH
40020: LD_INT 0
40022: PPUSH
40023: CALL_OW 1
40027: ST_TO_ADDR
// result := base ;
40028: LD_ADDR_VAR 0 3
40032: PUSH
40033: LD_VAR 0 4
40037: ST_TO_ADDR
// end ;
40038: LD_VAR 0 3
40042: RET
// export function MC_Start ( ) ; var i ; begin
40043: LD_INT 0
40045: PPUSH
40046: PPUSH
// for i = 1 to mc_bases do
40047: LD_ADDR_VAR 0 2
40051: PUSH
40052: DOUBLE
40053: LD_INT 1
40055: DEC
40056: ST_TO_ADDR
40057: LD_EXP 100
40061: PUSH
40062: FOR_TO
40063: IFFALSE 41163
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40065: LD_ADDR_EXP 100
40069: PUSH
40070: LD_EXP 100
40074: PPUSH
40075: LD_VAR 0 2
40079: PPUSH
40080: LD_EXP 100
40084: PUSH
40085: LD_VAR 0 2
40089: ARRAY
40090: PUSH
40091: LD_INT 0
40093: DIFF
40094: PPUSH
40095: CALL_OW 1
40099: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40100: LD_ADDR_EXP 101
40104: PUSH
40105: LD_EXP 101
40109: PPUSH
40110: LD_VAR 0 2
40114: PPUSH
40115: EMPTY
40116: PPUSH
40117: CALL_OW 1
40121: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40122: LD_ADDR_EXP 102
40126: PUSH
40127: LD_EXP 102
40131: PPUSH
40132: LD_VAR 0 2
40136: PPUSH
40137: EMPTY
40138: PPUSH
40139: CALL_OW 1
40143: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
40144: LD_ADDR_EXP 103
40148: PUSH
40149: LD_EXP 103
40153: PPUSH
40154: LD_VAR 0 2
40158: PPUSH
40159: EMPTY
40160: PPUSH
40161: CALL_OW 1
40165: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
40166: LD_ADDR_EXP 104
40170: PUSH
40171: LD_EXP 104
40175: PPUSH
40176: LD_VAR 0 2
40180: PPUSH
40181: EMPTY
40182: PUSH
40183: EMPTY
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PPUSH
40189: CALL_OW 1
40193: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
40194: LD_ADDR_EXP 105
40198: PUSH
40199: LD_EXP 105
40203: PPUSH
40204: LD_VAR 0 2
40208: PPUSH
40209: EMPTY
40210: PPUSH
40211: CALL_OW 1
40215: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
40216: LD_ADDR_EXP 132
40220: PUSH
40221: LD_EXP 132
40225: PPUSH
40226: LD_VAR 0 2
40230: PPUSH
40231: EMPTY
40232: PPUSH
40233: CALL_OW 1
40237: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
40238: LD_ADDR_EXP 106
40242: PUSH
40243: LD_EXP 106
40247: PPUSH
40248: LD_VAR 0 2
40252: PPUSH
40253: EMPTY
40254: PPUSH
40255: CALL_OW 1
40259: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
40260: LD_ADDR_EXP 107
40264: PUSH
40265: LD_EXP 107
40269: PPUSH
40270: LD_VAR 0 2
40274: PPUSH
40275: EMPTY
40276: PPUSH
40277: CALL_OW 1
40281: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
40282: LD_ADDR_EXP 108
40286: PUSH
40287: LD_EXP 108
40291: PPUSH
40292: LD_VAR 0 2
40296: PPUSH
40297: LD_EXP 100
40301: PUSH
40302: LD_VAR 0 2
40306: ARRAY
40307: PPUSH
40308: LD_INT 2
40310: PUSH
40311: LD_INT 30
40313: PUSH
40314: LD_INT 32
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 30
40323: PUSH
40324: LD_INT 33
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: LIST
40335: PPUSH
40336: CALL_OW 72
40340: PPUSH
40341: CALL_OW 1
40345: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
40346: LD_ADDR_EXP 109
40350: PUSH
40351: LD_EXP 109
40355: PPUSH
40356: LD_VAR 0 2
40360: PPUSH
40361: LD_EXP 100
40365: PUSH
40366: LD_VAR 0 2
40370: ARRAY
40371: PPUSH
40372: LD_INT 2
40374: PUSH
40375: LD_INT 30
40377: PUSH
40378: LD_INT 32
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 30
40387: PUSH
40388: LD_INT 31
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 58
40402: PUSH
40403: EMPTY
40404: LIST
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PPUSH
40410: CALL_OW 72
40414: PPUSH
40415: CALL_OW 1
40419: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
40420: LD_ADDR_EXP 110
40424: PUSH
40425: LD_EXP 110
40429: PPUSH
40430: LD_VAR 0 2
40434: PPUSH
40435: EMPTY
40436: PPUSH
40437: CALL_OW 1
40441: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
40442: LD_ADDR_EXP 114
40446: PUSH
40447: LD_EXP 114
40451: PPUSH
40452: LD_VAR 0 2
40456: PPUSH
40457: EMPTY
40458: PPUSH
40459: CALL_OW 1
40463: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
40464: LD_ADDR_EXP 113
40468: PUSH
40469: LD_EXP 113
40473: PPUSH
40474: LD_VAR 0 2
40478: PPUSH
40479: EMPTY
40480: PPUSH
40481: CALL_OW 1
40485: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
40486: LD_ADDR_EXP 115
40490: PUSH
40491: LD_EXP 115
40495: PPUSH
40496: LD_VAR 0 2
40500: PPUSH
40501: EMPTY
40502: PPUSH
40503: CALL_OW 1
40507: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
40508: LD_ADDR_EXP 116
40512: PUSH
40513: LD_EXP 116
40517: PPUSH
40518: LD_VAR 0 2
40522: PPUSH
40523: EMPTY
40524: PPUSH
40525: CALL_OW 1
40529: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
40530: LD_ADDR_EXP 117
40534: PUSH
40535: LD_EXP 117
40539: PPUSH
40540: LD_VAR 0 2
40544: PPUSH
40545: EMPTY
40546: PPUSH
40547: CALL_OW 1
40551: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
40552: LD_ADDR_EXP 118
40556: PUSH
40557: LD_EXP 118
40561: PPUSH
40562: LD_VAR 0 2
40566: PPUSH
40567: EMPTY
40568: PPUSH
40569: CALL_OW 1
40573: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
40574: LD_ADDR_EXP 119
40578: PUSH
40579: LD_EXP 119
40583: PPUSH
40584: LD_VAR 0 2
40588: PPUSH
40589: EMPTY
40590: PPUSH
40591: CALL_OW 1
40595: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
40596: LD_ADDR_EXP 120
40600: PUSH
40601: LD_EXP 120
40605: PPUSH
40606: LD_VAR 0 2
40610: PPUSH
40611: EMPTY
40612: PPUSH
40613: CALL_OW 1
40617: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
40618: LD_ADDR_EXP 121
40622: PUSH
40623: LD_EXP 121
40627: PPUSH
40628: LD_VAR 0 2
40632: PPUSH
40633: EMPTY
40634: PPUSH
40635: CALL_OW 1
40639: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40640: LD_ADDR_EXP 122
40644: PUSH
40645: LD_EXP 122
40649: PPUSH
40650: LD_VAR 0 2
40654: PPUSH
40655: EMPTY
40656: PPUSH
40657: CALL_OW 1
40661: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
40662: LD_ADDR_EXP 111
40666: PUSH
40667: LD_EXP 111
40671: PPUSH
40672: LD_VAR 0 2
40676: PPUSH
40677: LD_INT 0
40679: PPUSH
40680: CALL_OW 1
40684: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
40685: LD_ADDR_EXP 124
40689: PUSH
40690: LD_EXP 124
40694: PPUSH
40695: LD_VAR 0 2
40699: PPUSH
40700: LD_INT 0
40702: PPUSH
40703: CALL_OW 1
40707: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
40708: LD_ADDR_EXP 112
40712: PUSH
40713: LD_EXP 112
40717: PPUSH
40718: LD_VAR 0 2
40722: PPUSH
40723: EMPTY
40724: PPUSH
40725: CALL_OW 1
40729: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
40730: LD_ADDR_EXP 123
40734: PUSH
40735: LD_EXP 123
40739: PPUSH
40740: LD_VAR 0 2
40744: PPUSH
40745: LD_INT 0
40747: PPUSH
40748: CALL_OW 1
40752: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
40753: LD_ADDR_EXP 125
40757: PUSH
40758: LD_EXP 125
40762: PPUSH
40763: LD_VAR 0 2
40767: PPUSH
40768: EMPTY
40769: PPUSH
40770: CALL_OW 1
40774: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
40775: LD_ADDR_EXP 128
40779: PUSH
40780: LD_EXP 128
40784: PPUSH
40785: LD_VAR 0 2
40789: PPUSH
40790: LD_INT 0
40792: PPUSH
40793: CALL_OW 1
40797: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
40798: LD_ADDR_EXP 129
40802: PUSH
40803: LD_EXP 129
40807: PPUSH
40808: LD_VAR 0 2
40812: PPUSH
40813: EMPTY
40814: PPUSH
40815: CALL_OW 1
40819: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
40820: LD_ADDR_EXP 130
40824: PUSH
40825: LD_EXP 130
40829: PPUSH
40830: LD_VAR 0 2
40834: PPUSH
40835: EMPTY
40836: PPUSH
40837: CALL_OW 1
40841: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40842: LD_ADDR_EXP 131
40846: PUSH
40847: LD_EXP 131
40851: PPUSH
40852: LD_VAR 0 2
40856: PPUSH
40857: EMPTY
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
40864: LD_ADDR_EXP 133
40868: PUSH
40869: LD_EXP 133
40873: PPUSH
40874: LD_VAR 0 2
40878: PPUSH
40879: LD_EXP 100
40883: PUSH
40884: LD_VAR 0 2
40888: ARRAY
40889: PPUSH
40890: LD_INT 2
40892: PUSH
40893: LD_INT 30
40895: PUSH
40896: LD_INT 6
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 30
40905: PUSH
40906: LD_INT 7
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 30
40915: PUSH
40916: LD_INT 8
40918: PUSH
40919: EMPTY
40920: LIST
40921: LIST
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: PPUSH
40929: CALL_OW 72
40933: PPUSH
40934: CALL_OW 1
40938: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
40939: LD_ADDR_EXP 134
40943: PUSH
40944: LD_EXP 134
40948: PPUSH
40949: LD_VAR 0 2
40953: PPUSH
40954: EMPTY
40955: PPUSH
40956: CALL_OW 1
40960: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
40961: LD_ADDR_EXP 135
40965: PUSH
40966: LD_EXP 135
40970: PPUSH
40971: LD_VAR 0 2
40975: PPUSH
40976: EMPTY
40977: PPUSH
40978: CALL_OW 1
40982: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
40983: LD_ADDR_EXP 136
40987: PUSH
40988: LD_EXP 136
40992: PPUSH
40993: LD_VAR 0 2
40997: PPUSH
40998: EMPTY
40999: PPUSH
41000: CALL_OW 1
41004: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41005: LD_ADDR_EXP 137
41009: PUSH
41010: LD_EXP 137
41014: PPUSH
41015: LD_VAR 0 2
41019: PPUSH
41020: EMPTY
41021: PPUSH
41022: CALL_OW 1
41026: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41027: LD_ADDR_EXP 138
41031: PUSH
41032: LD_EXP 138
41036: PPUSH
41037: LD_VAR 0 2
41041: PPUSH
41042: EMPTY
41043: PPUSH
41044: CALL_OW 1
41048: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41049: LD_ADDR_EXP 139
41053: PUSH
41054: LD_EXP 139
41058: PPUSH
41059: LD_VAR 0 2
41063: PPUSH
41064: EMPTY
41065: PPUSH
41066: CALL_OW 1
41070: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41071: LD_ADDR_EXP 140
41075: PUSH
41076: LD_EXP 140
41080: PPUSH
41081: LD_VAR 0 2
41085: PPUSH
41086: EMPTY
41087: PPUSH
41088: CALL_OW 1
41092: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41093: LD_ADDR_EXP 141
41097: PUSH
41098: LD_EXP 141
41102: PPUSH
41103: LD_VAR 0 2
41107: PPUSH
41108: EMPTY
41109: PPUSH
41110: CALL_OW 1
41114: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41115: LD_ADDR_EXP 142
41119: PUSH
41120: LD_EXP 142
41124: PPUSH
41125: LD_VAR 0 2
41129: PPUSH
41130: LD_INT 0
41132: PPUSH
41133: CALL_OW 1
41137: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
41138: LD_ADDR_EXP 143
41142: PUSH
41143: LD_EXP 143
41147: PPUSH
41148: LD_VAR 0 2
41152: PPUSH
41153: LD_INT 0
41155: PPUSH
41156: CALL_OW 1
41160: ST_TO_ADDR
// end ;
41161: GO 40062
41163: POP
41164: POP
// MC_InitSides ( ) ;
41165: CALL 41451 0 0
// MC_InitResearch ( ) ;
41169: CALL 41190 0 0
// CustomInitMacro ( ) ;
41173: CALL 475 0 0
// skirmish := true ;
41177: LD_ADDR_EXP 98
41181: PUSH
41182: LD_INT 1
41184: ST_TO_ADDR
// end ;
41185: LD_VAR 0 1
41189: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
41190: LD_INT 0
41192: PPUSH
41193: PPUSH
41194: PPUSH
41195: PPUSH
41196: PPUSH
41197: PPUSH
// if not mc_bases then
41198: LD_EXP 100
41202: NOT
41203: IFFALSE 41207
// exit ;
41205: GO 41446
// for i = 1 to 8 do
41207: LD_ADDR_VAR 0 2
41211: PUSH
41212: DOUBLE
41213: LD_INT 1
41215: DEC
41216: ST_TO_ADDR
41217: LD_INT 8
41219: PUSH
41220: FOR_TO
41221: IFFALSE 41247
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
41223: LD_ADDR_EXP 127
41227: PUSH
41228: LD_EXP 127
41232: PPUSH
41233: LD_VAR 0 2
41237: PPUSH
41238: EMPTY
41239: PPUSH
41240: CALL_OW 1
41244: ST_TO_ADDR
41245: GO 41220
41247: POP
41248: POP
// tmp := [ ] ;
41249: LD_ADDR_VAR 0 5
41253: PUSH
41254: EMPTY
41255: ST_TO_ADDR
// for i = 1 to mc_sides do
41256: LD_ADDR_VAR 0 2
41260: PUSH
41261: DOUBLE
41262: LD_INT 1
41264: DEC
41265: ST_TO_ADDR
41266: LD_EXP 126
41270: PUSH
41271: FOR_TO
41272: IFFALSE 41330
// if not mc_sides [ i ] in tmp then
41274: LD_EXP 126
41278: PUSH
41279: LD_VAR 0 2
41283: ARRAY
41284: PUSH
41285: LD_VAR 0 5
41289: IN
41290: NOT
41291: IFFALSE 41328
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
41293: LD_ADDR_VAR 0 5
41297: PUSH
41298: LD_VAR 0 5
41302: PPUSH
41303: LD_VAR 0 5
41307: PUSH
41308: LD_INT 1
41310: PLUS
41311: PPUSH
41312: LD_EXP 126
41316: PUSH
41317: LD_VAR 0 2
41321: ARRAY
41322: PPUSH
41323: CALL_OW 2
41327: ST_TO_ADDR
41328: GO 41271
41330: POP
41331: POP
// if not tmp then
41332: LD_VAR 0 5
41336: NOT
41337: IFFALSE 41341
// exit ;
41339: GO 41446
// for j in tmp do
41341: LD_ADDR_VAR 0 3
41345: PUSH
41346: LD_VAR 0 5
41350: PUSH
41351: FOR_IN
41352: IFFALSE 41444
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
41354: LD_ADDR_VAR 0 6
41358: PUSH
41359: LD_INT 22
41361: PUSH
41362: LD_VAR 0 3
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PPUSH
41371: CALL_OW 69
41375: ST_TO_ADDR
// if not un then
41376: LD_VAR 0 6
41380: NOT
41381: IFFALSE 41385
// continue ;
41383: GO 41351
// nation := GetNation ( un [ 1 ] ) ;
41385: LD_ADDR_VAR 0 4
41389: PUSH
41390: LD_VAR 0 6
41394: PUSH
41395: LD_INT 1
41397: ARRAY
41398: PPUSH
41399: CALL_OW 248
41403: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
41404: LD_ADDR_EXP 127
41408: PUSH
41409: LD_EXP 127
41413: PPUSH
41414: LD_VAR 0 3
41418: PPUSH
41419: LD_VAR 0 3
41423: PPUSH
41424: LD_VAR 0 4
41428: PPUSH
41429: LD_INT 1
41431: PPUSH
41432: CALL 68620 0 3
41436: PPUSH
41437: CALL_OW 1
41441: ST_TO_ADDR
// end ;
41442: GO 41351
41444: POP
41445: POP
// end ;
41446: LD_VAR 0 1
41450: RET
// export function MC_InitSides ( ) ; var i ; begin
41451: LD_INT 0
41453: PPUSH
41454: PPUSH
// if not mc_bases then
41455: LD_EXP 100
41459: NOT
41460: IFFALSE 41464
// exit ;
41462: GO 41538
// for i = 1 to mc_bases do
41464: LD_ADDR_VAR 0 2
41468: PUSH
41469: DOUBLE
41470: LD_INT 1
41472: DEC
41473: ST_TO_ADDR
41474: LD_EXP 100
41478: PUSH
41479: FOR_TO
41480: IFFALSE 41536
// if mc_bases [ i ] then
41482: LD_EXP 100
41486: PUSH
41487: LD_VAR 0 2
41491: ARRAY
41492: IFFALSE 41534
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
41494: LD_ADDR_EXP 126
41498: PUSH
41499: LD_EXP 126
41503: PPUSH
41504: LD_VAR 0 2
41508: PPUSH
41509: LD_EXP 100
41513: PUSH
41514: LD_VAR 0 2
41518: ARRAY
41519: PUSH
41520: LD_INT 1
41522: ARRAY
41523: PPUSH
41524: CALL_OW 255
41528: PPUSH
41529: CALL_OW 1
41533: ST_TO_ADDR
41534: GO 41479
41536: POP
41537: POP
// end ;
41538: LD_VAR 0 1
41542: RET
// every 0 0$03 trigger skirmish do
41543: LD_EXP 98
41547: IFFALSE 41701
41549: GO 41551
41551: DISABLE
// begin enable ;
41552: ENABLE
// MC_CheckBuildings ( ) ;
41553: CALL 46199 0 0
// MC_CheckPeopleLife ( ) ;
41557: CALL 46360 0 0
// RaiseSailEvent ( 100 ) ;
41561: LD_INT 100
41563: PPUSH
41564: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
41568: LD_INT 103
41570: PPUSH
41571: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
41575: LD_INT 104
41577: PPUSH
41578: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
41582: LD_INT 105
41584: PPUSH
41585: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
41589: LD_INT 106
41591: PPUSH
41592: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
41596: LD_INT 107
41598: PPUSH
41599: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
41603: LD_INT 108
41605: PPUSH
41606: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
41610: LD_INT 109
41612: PPUSH
41613: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
41617: LD_INT 110
41619: PPUSH
41620: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
41624: LD_INT 111
41626: PPUSH
41627: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
41631: LD_INT 112
41633: PPUSH
41634: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
41638: LD_INT 113
41640: PPUSH
41641: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
41645: LD_INT 120
41647: PPUSH
41648: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
41652: LD_INT 121
41654: PPUSH
41655: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
41659: LD_INT 122
41661: PPUSH
41662: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
41666: LD_INT 123
41668: PPUSH
41669: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
41673: LD_INT 124
41675: PPUSH
41676: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
41680: LD_INT 125
41682: PPUSH
41683: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
41687: LD_INT 126
41689: PPUSH
41690: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
41694: LD_INT 200
41696: PPUSH
41697: CALL_OW 427
// end ;
41701: END
// on SailEvent ( event ) do begin if event < 100 then
41702: LD_VAR 0 1
41706: PUSH
41707: LD_INT 100
41709: LESS
41710: IFFALSE 41721
// CustomEvent ( event ) ;
41712: LD_VAR 0 1
41716: PPUSH
41717: CALL 36136 0 1
// if event = 100 then
41721: LD_VAR 0 1
41725: PUSH
41726: LD_INT 100
41728: EQUAL
41729: IFFALSE 41735
// MC_ClassManager ( ) ;
41731: CALL 42127 0 0
// if event = 101 then
41735: LD_VAR 0 1
41739: PUSH
41740: LD_INT 101
41742: EQUAL
41743: IFFALSE 41749
// MC_RepairBuildings ( ) ;
41745: CALL 46945 0 0
// if event = 102 then
41749: LD_VAR 0 1
41753: PUSH
41754: LD_INT 102
41756: EQUAL
41757: IFFALSE 41763
// MC_Heal ( ) ;
41759: CALL 47880 0 0
// if event = 103 then
41763: LD_VAR 0 1
41767: PUSH
41768: LD_INT 103
41770: EQUAL
41771: IFFALSE 41777
// MC_Build ( ) ;
41773: CALL 48302 0 0
// if event = 104 then
41777: LD_VAR 0 1
41781: PUSH
41782: LD_INT 104
41784: EQUAL
41785: IFFALSE 41791
// MC_TurretWeapon ( ) ;
41787: CALL 49936 0 0
// if event = 105 then
41791: LD_VAR 0 1
41795: PUSH
41796: LD_INT 105
41798: EQUAL
41799: IFFALSE 41805
// MC_BuildUpgrade ( ) ;
41801: CALL 49487 0 0
// if event = 106 then
41805: LD_VAR 0 1
41809: PUSH
41810: LD_INT 106
41812: EQUAL
41813: IFFALSE 41819
// MC_PlantMines ( ) ;
41815: CALL 50366 0 0
// if event = 107 then
41819: LD_VAR 0 1
41823: PUSH
41824: LD_INT 107
41826: EQUAL
41827: IFFALSE 41833
// MC_CollectCrates ( ) ;
41829: CALL 51164 0 0
// if event = 108 then
41833: LD_VAR 0 1
41837: PUSH
41838: LD_INT 108
41840: EQUAL
41841: IFFALSE 41847
// MC_LinkRemoteControl ( ) ;
41843: CALL 53014 0 0
// if event = 109 then
41847: LD_VAR 0 1
41851: PUSH
41852: LD_INT 109
41854: EQUAL
41855: IFFALSE 41861
// MC_ProduceVehicle ( ) ;
41857: CALL 53195 0 0
// if event = 110 then
41861: LD_VAR 0 1
41865: PUSH
41866: LD_INT 110
41868: EQUAL
41869: IFFALSE 41875
// MC_SendAttack ( ) ;
41871: CALL 53661 0 0
// if event = 111 then
41875: LD_VAR 0 1
41879: PUSH
41880: LD_INT 111
41882: EQUAL
41883: IFFALSE 41889
// MC_Defend ( ) ;
41885: CALL 53769 0 0
// if event = 112 then
41889: LD_VAR 0 1
41893: PUSH
41894: LD_INT 112
41896: EQUAL
41897: IFFALSE 41903
// MC_Research ( ) ;
41899: CALL 54649 0 0
// if event = 113 then
41903: LD_VAR 0 1
41907: PUSH
41908: LD_INT 113
41910: EQUAL
41911: IFFALSE 41917
// MC_MinesTrigger ( ) ;
41913: CALL 55763 0 0
// if event = 120 then
41917: LD_VAR 0 1
41921: PUSH
41922: LD_INT 120
41924: EQUAL
41925: IFFALSE 41931
// MC_RepairVehicle ( ) ;
41927: CALL 55862 0 0
// if event = 121 then
41931: LD_VAR 0 1
41935: PUSH
41936: LD_INT 121
41938: EQUAL
41939: IFFALSE 41945
// MC_TameApe ( ) ;
41941: CALL 56631 0 0
// if event = 122 then
41945: LD_VAR 0 1
41949: PUSH
41950: LD_INT 122
41952: EQUAL
41953: IFFALSE 41959
// MC_ChangeApeClass ( ) ;
41955: CALL 57460 0 0
// if event = 123 then
41959: LD_VAR 0 1
41963: PUSH
41964: LD_INT 123
41966: EQUAL
41967: IFFALSE 41973
// MC_Bazooka ( ) ;
41969: CALL 58110 0 0
// if event = 124 then
41973: LD_VAR 0 1
41977: PUSH
41978: LD_INT 124
41980: EQUAL
41981: IFFALSE 41987
// MC_TeleportExit ( ) ;
41983: CALL 58308 0 0
// if event = 125 then
41987: LD_VAR 0 1
41991: PUSH
41992: LD_INT 125
41994: EQUAL
41995: IFFALSE 42001
// MC_Deposits ( ) ;
41997: CALL 58955 0 0
// if event = 126 then
42001: LD_VAR 0 1
42005: PUSH
42006: LD_INT 126
42008: EQUAL
42009: IFFALSE 42015
// MC_RemoteDriver ( ) ;
42011: CALL 59580 0 0
// if event = 200 then
42015: LD_VAR 0 1
42019: PUSH
42020: LD_INT 200
42022: EQUAL
42023: IFFALSE 42029
// MC_Idle ( ) ;
42025: CALL 61487 0 0
// end ;
42029: PPOPN 1
42031: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42032: LD_INT 0
42034: PPUSH
42035: PPUSH
// if not mc_bases [ base ] or not tag then
42036: LD_EXP 100
42040: PUSH
42041: LD_VAR 0 1
42045: ARRAY
42046: NOT
42047: PUSH
42048: LD_VAR 0 2
42052: NOT
42053: OR
42054: IFFALSE 42058
// exit ;
42056: GO 42122
// for i in mc_bases [ base ] union mc_ape [ base ] do
42058: LD_ADDR_VAR 0 4
42062: PUSH
42063: LD_EXP 100
42067: PUSH
42068: LD_VAR 0 1
42072: ARRAY
42073: PUSH
42074: LD_EXP 129
42078: PUSH
42079: LD_VAR 0 1
42083: ARRAY
42084: UNION
42085: PUSH
42086: FOR_IN
42087: IFFALSE 42120
// if GetTag ( i ) = tag then
42089: LD_VAR 0 4
42093: PPUSH
42094: CALL_OW 110
42098: PUSH
42099: LD_VAR 0 2
42103: EQUAL
42104: IFFALSE 42118
// SetTag ( i , 0 ) ;
42106: LD_VAR 0 4
42110: PPUSH
42111: LD_INT 0
42113: PPUSH
42114: CALL_OW 109
42118: GO 42086
42120: POP
42121: POP
// end ;
42122: LD_VAR 0 3
42126: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
42127: LD_INT 0
42129: PPUSH
42130: PPUSH
42131: PPUSH
42132: PPUSH
42133: PPUSH
42134: PPUSH
42135: PPUSH
42136: PPUSH
// if not mc_bases then
42137: LD_EXP 100
42141: NOT
42142: IFFALSE 42146
// exit ;
42144: GO 42604
// for i = 1 to mc_bases do
42146: LD_ADDR_VAR 0 2
42150: PUSH
42151: DOUBLE
42152: LD_INT 1
42154: DEC
42155: ST_TO_ADDR
42156: LD_EXP 100
42160: PUSH
42161: FOR_TO
42162: IFFALSE 42602
// begin tmp := MC_ClassCheckReq ( i ) ;
42164: LD_ADDR_VAR 0 4
42168: PUSH
42169: LD_VAR 0 2
42173: PPUSH
42174: CALL 42609 0 1
42178: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
42179: LD_ADDR_EXP 141
42183: PUSH
42184: LD_EXP 141
42188: PPUSH
42189: LD_VAR 0 2
42193: PPUSH
42194: LD_VAR 0 4
42198: PPUSH
42199: CALL_OW 1
42203: ST_TO_ADDR
// if not tmp then
42204: LD_VAR 0 4
42208: NOT
42209: IFFALSE 42213
// continue ;
42211: GO 42161
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
42213: LD_ADDR_VAR 0 6
42217: PUSH
42218: LD_EXP 100
42222: PUSH
42223: LD_VAR 0 2
42227: ARRAY
42228: PPUSH
42229: LD_INT 2
42231: PUSH
42232: LD_INT 30
42234: PUSH
42235: LD_INT 4
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 30
42244: PUSH
42245: LD_INT 5
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: LIST
42256: PPUSH
42257: CALL_OW 72
42261: PUSH
42262: LD_EXP 100
42266: PUSH
42267: LD_VAR 0 2
42271: ARRAY
42272: PPUSH
42273: LD_INT 2
42275: PUSH
42276: LD_INT 30
42278: PUSH
42279: LD_INT 0
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: LD_INT 30
42288: PUSH
42289: LD_INT 1
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: LIST
42300: PPUSH
42301: CALL_OW 72
42305: PUSH
42306: LD_EXP 100
42310: PUSH
42311: LD_VAR 0 2
42315: ARRAY
42316: PPUSH
42317: LD_INT 30
42319: PUSH
42320: LD_INT 3
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PPUSH
42327: CALL_OW 72
42331: PUSH
42332: LD_EXP 100
42336: PUSH
42337: LD_VAR 0 2
42341: ARRAY
42342: PPUSH
42343: LD_INT 2
42345: PUSH
42346: LD_INT 30
42348: PUSH
42349: LD_INT 6
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: PUSH
42356: LD_INT 30
42358: PUSH
42359: LD_INT 7
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 30
42368: PUSH
42369: LD_INT 8
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: PPUSH
42382: CALL_OW 72
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: LIST
42391: LIST
42392: ST_TO_ADDR
// for j = 1 to 4 do
42393: LD_ADDR_VAR 0 3
42397: PUSH
42398: DOUBLE
42399: LD_INT 1
42401: DEC
42402: ST_TO_ADDR
42403: LD_INT 4
42405: PUSH
42406: FOR_TO
42407: IFFALSE 42598
// begin if not tmp [ j ] then
42409: LD_VAR 0 4
42413: PUSH
42414: LD_VAR 0 3
42418: ARRAY
42419: NOT
42420: IFFALSE 42424
// continue ;
42422: GO 42406
// for p in tmp [ j ] do
42424: LD_ADDR_VAR 0 5
42428: PUSH
42429: LD_VAR 0 4
42433: PUSH
42434: LD_VAR 0 3
42438: ARRAY
42439: PUSH
42440: FOR_IN
42441: IFFALSE 42594
// begin if not b [ j ] then
42443: LD_VAR 0 6
42447: PUSH
42448: LD_VAR 0 3
42452: ARRAY
42453: NOT
42454: IFFALSE 42458
// break ;
42456: GO 42594
// e := 0 ;
42458: LD_ADDR_VAR 0 7
42462: PUSH
42463: LD_INT 0
42465: ST_TO_ADDR
// for k in b [ j ] do
42466: LD_ADDR_VAR 0 8
42470: PUSH
42471: LD_VAR 0 6
42475: PUSH
42476: LD_VAR 0 3
42480: ARRAY
42481: PUSH
42482: FOR_IN
42483: IFFALSE 42510
// if IsNotFull ( k ) then
42485: LD_VAR 0 8
42489: PPUSH
42490: CALL 70741 0 1
42494: IFFALSE 42508
// begin e := k ;
42496: LD_ADDR_VAR 0 7
42500: PUSH
42501: LD_VAR 0 8
42505: ST_TO_ADDR
// break ;
42506: GO 42510
// end ;
42508: GO 42482
42510: POP
42511: POP
// if e and not UnitGoingToBuilding ( p , e ) then
42512: LD_VAR 0 7
42516: PUSH
42517: LD_VAR 0 5
42521: PPUSH
42522: LD_VAR 0 7
42526: PPUSH
42527: CALL 104494 0 2
42531: NOT
42532: AND
42533: IFFALSE 42592
// begin if IsInUnit ( p ) then
42535: LD_VAR 0 5
42539: PPUSH
42540: CALL_OW 310
42544: IFFALSE 42555
// ComExitBuilding ( p ) ;
42546: LD_VAR 0 5
42550: PPUSH
42551: CALL_OW 122
// ComEnterUnit ( p , e ) ;
42555: LD_VAR 0 5
42559: PPUSH
42560: LD_VAR 0 7
42564: PPUSH
42565: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
42569: LD_VAR 0 5
42573: PPUSH
42574: LD_VAR 0 3
42578: PPUSH
42579: CALL_OW 183
// AddComExitBuilding ( p ) ;
42583: LD_VAR 0 5
42587: PPUSH
42588: CALL_OW 182
// end ; end ;
42592: GO 42440
42594: POP
42595: POP
// end ;
42596: GO 42406
42598: POP
42599: POP
// end ;
42600: GO 42161
42602: POP
42603: POP
// end ;
42604: LD_VAR 0 1
42608: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
42609: LD_INT 0
42611: PPUSH
42612: PPUSH
42613: PPUSH
42614: PPUSH
42615: PPUSH
42616: PPUSH
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42623: LD_VAR 0 1
42627: NOT
42628: PUSH
42629: LD_EXP 100
42633: PUSH
42634: LD_VAR 0 1
42638: ARRAY
42639: NOT
42640: OR
42641: PUSH
42642: LD_EXP 100
42646: PUSH
42647: LD_VAR 0 1
42651: ARRAY
42652: PPUSH
42653: LD_INT 2
42655: PUSH
42656: LD_INT 30
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 30
42668: PUSH
42669: LD_INT 1
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: LIST
42680: PPUSH
42681: CALL_OW 72
42685: NOT
42686: OR
42687: IFFALSE 42691
// exit ;
42689: GO 46194
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42691: LD_ADDR_VAR 0 4
42695: PUSH
42696: LD_EXP 100
42700: PUSH
42701: LD_VAR 0 1
42705: ARRAY
42706: PPUSH
42707: LD_INT 2
42709: PUSH
42710: LD_INT 25
42712: PUSH
42713: LD_INT 1
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 25
42722: PUSH
42723: LD_INT 2
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 25
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 25
42742: PUSH
42743: LD_INT 4
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 25
42752: PUSH
42753: LD_INT 5
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 25
42762: PUSH
42763: LD_INT 8
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: LD_INT 25
42772: PUSH
42773: LD_INT 9
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: PPUSH
42790: CALL_OW 72
42794: ST_TO_ADDR
// if not tmp then
42795: LD_VAR 0 4
42799: NOT
42800: IFFALSE 42804
// exit ;
42802: GO 46194
// for i in tmp do
42804: LD_ADDR_VAR 0 3
42808: PUSH
42809: LD_VAR 0 4
42813: PUSH
42814: FOR_IN
42815: IFFALSE 42846
// if GetTag ( i ) then
42817: LD_VAR 0 3
42821: PPUSH
42822: CALL_OW 110
42826: IFFALSE 42844
// tmp := tmp diff i ;
42828: LD_ADDR_VAR 0 4
42832: PUSH
42833: LD_VAR 0 4
42837: PUSH
42838: LD_VAR 0 3
42842: DIFF
42843: ST_TO_ADDR
42844: GO 42814
42846: POP
42847: POP
// if not tmp then
42848: LD_VAR 0 4
42852: NOT
42853: IFFALSE 42857
// exit ;
42855: GO 46194
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42857: LD_ADDR_VAR 0 5
42861: PUSH
42862: LD_EXP 100
42866: PUSH
42867: LD_VAR 0 1
42871: ARRAY
42872: PPUSH
42873: LD_INT 2
42875: PUSH
42876: LD_INT 25
42878: PUSH
42879: LD_INT 1
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 25
42888: PUSH
42889: LD_INT 5
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: LD_INT 25
42898: PUSH
42899: LD_INT 8
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 25
42908: PUSH
42909: LD_INT 9
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: PPUSH
42923: CALL_OW 72
42927: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
42928: LD_ADDR_VAR 0 6
42932: PUSH
42933: LD_EXP 100
42937: PUSH
42938: LD_VAR 0 1
42942: ARRAY
42943: PPUSH
42944: LD_INT 25
42946: PUSH
42947: LD_INT 2
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PPUSH
42954: CALL_OW 72
42958: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
42959: LD_ADDR_VAR 0 7
42963: PUSH
42964: LD_EXP 100
42968: PUSH
42969: LD_VAR 0 1
42973: ARRAY
42974: PPUSH
42975: LD_INT 25
42977: PUSH
42978: LD_INT 3
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PPUSH
42985: CALL_OW 72
42989: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
42990: LD_ADDR_VAR 0 8
42994: PUSH
42995: LD_EXP 100
42999: PUSH
43000: LD_VAR 0 1
43004: ARRAY
43005: PPUSH
43006: LD_INT 25
43008: PUSH
43009: LD_INT 4
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 24
43018: PUSH
43019: LD_INT 251
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PPUSH
43030: CALL_OW 72
43034: ST_TO_ADDR
// if mc_is_defending [ base ] then
43035: LD_EXP 143
43039: PUSH
43040: LD_VAR 0 1
43044: ARRAY
43045: IFFALSE 43506
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43047: LD_ADDR_EXP 142
43051: PUSH
43052: LD_EXP 142
43056: PPUSH
43057: LD_VAR 0 1
43061: PPUSH
43062: LD_INT 4
43064: PPUSH
43065: CALL_OW 1
43069: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43070: LD_ADDR_VAR 0 12
43074: PUSH
43075: LD_EXP 100
43079: PUSH
43080: LD_VAR 0 1
43084: ARRAY
43085: PPUSH
43086: LD_INT 2
43088: PUSH
43089: LD_INT 30
43091: PUSH
43092: LD_INT 4
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 30
43101: PUSH
43102: LD_INT 5
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: LIST
43113: PPUSH
43114: CALL_OW 72
43118: ST_TO_ADDR
// if not b then
43119: LD_VAR 0 12
43123: NOT
43124: IFFALSE 43128
// exit ;
43126: GO 46194
// p := [ ] ;
43128: LD_ADDR_VAR 0 11
43132: PUSH
43133: EMPTY
43134: ST_TO_ADDR
// if sci >= 2 then
43135: LD_VAR 0 8
43139: PUSH
43140: LD_INT 2
43142: GREATEREQUAL
43143: IFFALSE 43174
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
43145: LD_ADDR_VAR 0 8
43149: PUSH
43150: LD_VAR 0 8
43154: PUSH
43155: LD_INT 1
43157: ARRAY
43158: PUSH
43159: LD_VAR 0 8
43163: PUSH
43164: LD_INT 2
43166: ARRAY
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: ST_TO_ADDR
43172: GO 43235
// if sci = 1 then
43174: LD_VAR 0 8
43178: PUSH
43179: LD_INT 1
43181: EQUAL
43182: IFFALSE 43203
// sci := [ sci [ 1 ] ] else
43184: LD_ADDR_VAR 0 8
43188: PUSH
43189: LD_VAR 0 8
43193: PUSH
43194: LD_INT 1
43196: ARRAY
43197: PUSH
43198: EMPTY
43199: LIST
43200: ST_TO_ADDR
43201: GO 43235
// if sci = 0 then
43203: LD_VAR 0 8
43207: PUSH
43208: LD_INT 0
43210: EQUAL
43211: IFFALSE 43235
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
43213: LD_ADDR_VAR 0 11
43217: PUSH
43218: LD_VAR 0 4
43222: PPUSH
43223: LD_INT 4
43225: PPUSH
43226: CALL 104366 0 2
43230: PUSH
43231: LD_INT 1
43233: ARRAY
43234: ST_TO_ADDR
// if eng > 4 then
43235: LD_VAR 0 6
43239: PUSH
43240: LD_INT 4
43242: GREATER
43243: IFFALSE 43289
// for i = eng downto 4 do
43245: LD_ADDR_VAR 0 3
43249: PUSH
43250: DOUBLE
43251: LD_VAR 0 6
43255: INC
43256: ST_TO_ADDR
43257: LD_INT 4
43259: PUSH
43260: FOR_DOWNTO
43261: IFFALSE 43287
// eng := eng diff eng [ i ] ;
43263: LD_ADDR_VAR 0 6
43267: PUSH
43268: LD_VAR 0 6
43272: PUSH
43273: LD_VAR 0 6
43277: PUSH
43278: LD_VAR 0 3
43282: ARRAY
43283: DIFF
43284: ST_TO_ADDR
43285: GO 43260
43287: POP
43288: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
43289: LD_ADDR_VAR 0 4
43293: PUSH
43294: LD_VAR 0 4
43298: PUSH
43299: LD_VAR 0 5
43303: PUSH
43304: LD_VAR 0 6
43308: UNION
43309: PUSH
43310: LD_VAR 0 7
43314: UNION
43315: PUSH
43316: LD_VAR 0 8
43320: UNION
43321: DIFF
43322: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
43323: LD_ADDR_VAR 0 13
43327: PUSH
43328: LD_EXP 100
43332: PUSH
43333: LD_VAR 0 1
43337: ARRAY
43338: PPUSH
43339: LD_INT 2
43341: PUSH
43342: LD_INT 30
43344: PUSH
43345: LD_INT 32
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 30
43354: PUSH
43355: LD_INT 31
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: LIST
43366: PPUSH
43367: CALL_OW 72
43371: PUSH
43372: LD_EXP 100
43376: PUSH
43377: LD_VAR 0 1
43381: ARRAY
43382: PPUSH
43383: LD_INT 2
43385: PUSH
43386: LD_INT 30
43388: PUSH
43389: LD_INT 4
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 30
43398: PUSH
43399: LD_INT 5
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: LIST
43410: PPUSH
43411: CALL_OW 72
43415: PUSH
43416: LD_INT 6
43418: MUL
43419: PLUS
43420: ST_TO_ADDR
// if bcount < tmp then
43421: LD_VAR 0 13
43425: PUSH
43426: LD_VAR 0 4
43430: LESS
43431: IFFALSE 43477
// for i = tmp downto bcount do
43433: LD_ADDR_VAR 0 3
43437: PUSH
43438: DOUBLE
43439: LD_VAR 0 4
43443: INC
43444: ST_TO_ADDR
43445: LD_VAR 0 13
43449: PUSH
43450: FOR_DOWNTO
43451: IFFALSE 43475
// tmp := Delete ( tmp , tmp ) ;
43453: LD_ADDR_VAR 0 4
43457: PUSH
43458: LD_VAR 0 4
43462: PPUSH
43463: LD_VAR 0 4
43467: PPUSH
43468: CALL_OW 3
43472: ST_TO_ADDR
43473: GO 43450
43475: POP
43476: POP
// result := [ tmp , 0 , 0 , p ] ;
43477: LD_ADDR_VAR 0 2
43481: PUSH
43482: LD_VAR 0 4
43486: PUSH
43487: LD_INT 0
43489: PUSH
43490: LD_INT 0
43492: PUSH
43493: LD_VAR 0 11
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: ST_TO_ADDR
// exit ;
43504: GO 46194
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43506: LD_EXP 100
43510: PUSH
43511: LD_VAR 0 1
43515: ARRAY
43516: PPUSH
43517: LD_INT 2
43519: PUSH
43520: LD_INT 30
43522: PUSH
43523: LD_INT 6
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 30
43532: PUSH
43533: LD_INT 7
43535: PUSH
43536: EMPTY
43537: LIST
43538: LIST
43539: PUSH
43540: LD_INT 30
43542: PUSH
43543: LD_INT 8
43545: PUSH
43546: EMPTY
43547: LIST
43548: LIST
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: PPUSH
43556: CALL_OW 72
43560: NOT
43561: PUSH
43562: LD_EXP 100
43566: PUSH
43567: LD_VAR 0 1
43571: ARRAY
43572: PPUSH
43573: LD_INT 30
43575: PUSH
43576: LD_INT 3
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: PPUSH
43583: CALL_OW 72
43587: NOT
43588: AND
43589: IFFALSE 43661
// begin if eng = tmp then
43591: LD_VAR 0 6
43595: PUSH
43596: LD_VAR 0 4
43600: EQUAL
43601: IFFALSE 43605
// exit ;
43603: GO 46194
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
43605: LD_ADDR_EXP 142
43609: PUSH
43610: LD_EXP 142
43614: PPUSH
43615: LD_VAR 0 1
43619: PPUSH
43620: LD_INT 1
43622: PPUSH
43623: CALL_OW 1
43627: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
43628: LD_ADDR_VAR 0 2
43632: PUSH
43633: LD_INT 0
43635: PUSH
43636: LD_VAR 0 4
43640: PUSH
43641: LD_VAR 0 6
43645: DIFF
43646: PUSH
43647: LD_INT 0
43649: PUSH
43650: LD_INT 0
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: LIST
43657: LIST
43658: ST_TO_ADDR
// exit ;
43659: GO 46194
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43661: LD_EXP 127
43665: PUSH
43666: LD_EXP 126
43670: PUSH
43671: LD_VAR 0 1
43675: ARRAY
43676: ARRAY
43677: PUSH
43678: LD_EXP 100
43682: PUSH
43683: LD_VAR 0 1
43687: ARRAY
43688: PPUSH
43689: LD_INT 2
43691: PUSH
43692: LD_INT 30
43694: PUSH
43695: LD_INT 6
43697: PUSH
43698: EMPTY
43699: LIST
43700: LIST
43701: PUSH
43702: LD_INT 30
43704: PUSH
43705: LD_INT 7
43707: PUSH
43708: EMPTY
43709: LIST
43710: LIST
43711: PUSH
43712: LD_INT 30
43714: PUSH
43715: LD_INT 8
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: PPUSH
43728: CALL_OW 72
43732: AND
43733: PUSH
43734: LD_EXP 100
43738: PUSH
43739: LD_VAR 0 1
43743: ARRAY
43744: PPUSH
43745: LD_INT 30
43747: PUSH
43748: LD_INT 3
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PPUSH
43755: CALL_OW 72
43759: NOT
43760: AND
43761: IFFALSE 43975
// begin if sci >= 6 then
43763: LD_VAR 0 8
43767: PUSH
43768: LD_INT 6
43770: GREATEREQUAL
43771: IFFALSE 43775
// exit ;
43773: GO 46194
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
43775: LD_ADDR_EXP 142
43779: PUSH
43780: LD_EXP 142
43784: PPUSH
43785: LD_VAR 0 1
43789: PPUSH
43790: LD_INT 2
43792: PPUSH
43793: CALL_OW 1
43797: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
43798: LD_ADDR_VAR 0 9
43802: PUSH
43803: LD_VAR 0 4
43807: PUSH
43808: LD_VAR 0 8
43812: DIFF
43813: PPUSH
43814: LD_INT 4
43816: PPUSH
43817: CALL 104366 0 2
43821: ST_TO_ADDR
// p := [ ] ;
43822: LD_ADDR_VAR 0 11
43826: PUSH
43827: EMPTY
43828: ST_TO_ADDR
// if sci < 6 and sort > 6 then
43829: LD_VAR 0 8
43833: PUSH
43834: LD_INT 6
43836: LESS
43837: PUSH
43838: LD_VAR 0 9
43842: PUSH
43843: LD_INT 6
43845: GREATER
43846: AND
43847: IFFALSE 43928
// begin for i = 1 to 6 - sci do
43849: LD_ADDR_VAR 0 3
43853: PUSH
43854: DOUBLE
43855: LD_INT 1
43857: DEC
43858: ST_TO_ADDR
43859: LD_INT 6
43861: PUSH
43862: LD_VAR 0 8
43866: MINUS
43867: PUSH
43868: FOR_TO
43869: IFFALSE 43924
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
43871: LD_ADDR_VAR 0 11
43875: PUSH
43876: LD_VAR 0 11
43880: PPUSH
43881: LD_VAR 0 11
43885: PUSH
43886: LD_INT 1
43888: PLUS
43889: PPUSH
43890: LD_VAR 0 9
43894: PUSH
43895: LD_INT 1
43897: ARRAY
43898: PPUSH
43899: CALL_OW 2
43903: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
43904: LD_ADDR_VAR 0 9
43908: PUSH
43909: LD_VAR 0 9
43913: PPUSH
43914: LD_INT 1
43916: PPUSH
43917: CALL_OW 3
43921: ST_TO_ADDR
// end ;
43922: GO 43868
43924: POP
43925: POP
// end else
43926: GO 43948
// if sort then
43928: LD_VAR 0 9
43932: IFFALSE 43948
// p := sort [ 1 ] ;
43934: LD_ADDR_VAR 0 11
43938: PUSH
43939: LD_VAR 0 9
43943: PUSH
43944: LD_INT 1
43946: ARRAY
43947: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
43948: LD_ADDR_VAR 0 2
43952: PUSH
43953: LD_INT 0
43955: PUSH
43956: LD_INT 0
43958: PUSH
43959: LD_INT 0
43961: PUSH
43962: LD_VAR 0 11
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: ST_TO_ADDR
// exit ;
43973: GO 46194
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43975: LD_EXP 127
43979: PUSH
43980: LD_EXP 126
43984: PUSH
43985: LD_VAR 0 1
43989: ARRAY
43990: ARRAY
43991: PUSH
43992: LD_EXP 100
43996: PUSH
43997: LD_VAR 0 1
44001: ARRAY
44002: PPUSH
44003: LD_INT 2
44005: PUSH
44006: LD_INT 30
44008: PUSH
44009: LD_INT 6
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 30
44018: PUSH
44019: LD_INT 7
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 30
44028: PUSH
44029: LD_INT 8
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: PPUSH
44042: CALL_OW 72
44046: AND
44047: PUSH
44048: LD_EXP 100
44052: PUSH
44053: LD_VAR 0 1
44057: ARRAY
44058: PPUSH
44059: LD_INT 30
44061: PUSH
44062: LD_INT 3
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PPUSH
44069: CALL_OW 72
44073: AND
44074: IFFALSE 44808
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44076: LD_ADDR_EXP 142
44080: PUSH
44081: LD_EXP 142
44085: PPUSH
44086: LD_VAR 0 1
44090: PPUSH
44091: LD_INT 3
44093: PPUSH
44094: CALL_OW 1
44098: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44099: LD_ADDR_VAR 0 2
44103: PUSH
44104: LD_INT 0
44106: PUSH
44107: LD_INT 0
44109: PUSH
44110: LD_INT 0
44112: PUSH
44113: LD_INT 0
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: ST_TO_ADDR
// if not eng then
44122: LD_VAR 0 6
44126: NOT
44127: IFFALSE 44190
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
44129: LD_ADDR_VAR 0 11
44133: PUSH
44134: LD_VAR 0 4
44138: PPUSH
44139: LD_INT 2
44141: PPUSH
44142: CALL 104366 0 2
44146: PUSH
44147: LD_INT 1
44149: ARRAY
44150: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
44151: LD_ADDR_VAR 0 2
44155: PUSH
44156: LD_VAR 0 2
44160: PPUSH
44161: LD_INT 2
44163: PPUSH
44164: LD_VAR 0 11
44168: PPUSH
44169: CALL_OW 1
44173: ST_TO_ADDR
// tmp := tmp diff p ;
44174: LD_ADDR_VAR 0 4
44178: PUSH
44179: LD_VAR 0 4
44183: PUSH
44184: LD_VAR 0 11
44188: DIFF
44189: ST_TO_ADDR
// end ; if tmp and sci < 6 then
44190: LD_VAR 0 4
44194: PUSH
44195: LD_VAR 0 8
44199: PUSH
44200: LD_INT 6
44202: LESS
44203: AND
44204: IFFALSE 44392
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
44206: LD_ADDR_VAR 0 9
44210: PUSH
44211: LD_VAR 0 4
44215: PUSH
44216: LD_VAR 0 8
44220: PUSH
44221: LD_VAR 0 7
44225: UNION
44226: DIFF
44227: PPUSH
44228: LD_INT 4
44230: PPUSH
44231: CALL 104366 0 2
44235: ST_TO_ADDR
// p := [ ] ;
44236: LD_ADDR_VAR 0 11
44240: PUSH
44241: EMPTY
44242: ST_TO_ADDR
// if sort then
44243: LD_VAR 0 9
44247: IFFALSE 44363
// for i = 1 to 6 - sci do
44249: LD_ADDR_VAR 0 3
44253: PUSH
44254: DOUBLE
44255: LD_INT 1
44257: DEC
44258: ST_TO_ADDR
44259: LD_INT 6
44261: PUSH
44262: LD_VAR 0 8
44266: MINUS
44267: PUSH
44268: FOR_TO
44269: IFFALSE 44361
// begin if i = sort then
44271: LD_VAR 0 3
44275: PUSH
44276: LD_VAR 0 9
44280: EQUAL
44281: IFFALSE 44285
// break ;
44283: GO 44361
// if GetClass ( i ) = 4 then
44285: LD_VAR 0 3
44289: PPUSH
44290: CALL_OW 257
44294: PUSH
44295: LD_INT 4
44297: EQUAL
44298: IFFALSE 44302
// continue ;
44300: GO 44268
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44302: LD_ADDR_VAR 0 11
44306: PUSH
44307: LD_VAR 0 11
44311: PPUSH
44312: LD_VAR 0 11
44316: PUSH
44317: LD_INT 1
44319: PLUS
44320: PPUSH
44321: LD_VAR 0 9
44325: PUSH
44326: LD_VAR 0 3
44330: ARRAY
44331: PPUSH
44332: CALL_OW 2
44336: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44337: LD_ADDR_VAR 0 4
44341: PUSH
44342: LD_VAR 0 4
44346: PUSH
44347: LD_VAR 0 9
44351: PUSH
44352: LD_VAR 0 3
44356: ARRAY
44357: DIFF
44358: ST_TO_ADDR
// end ;
44359: GO 44268
44361: POP
44362: POP
// if p then
44363: LD_VAR 0 11
44367: IFFALSE 44392
// result := Replace ( result , 4 , p ) ;
44369: LD_ADDR_VAR 0 2
44373: PUSH
44374: LD_VAR 0 2
44378: PPUSH
44379: LD_INT 4
44381: PPUSH
44382: LD_VAR 0 11
44386: PPUSH
44387: CALL_OW 1
44391: ST_TO_ADDR
// end ; if tmp and mech < 6 then
44392: LD_VAR 0 4
44396: PUSH
44397: LD_VAR 0 7
44401: PUSH
44402: LD_INT 6
44404: LESS
44405: AND
44406: IFFALSE 44594
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44408: LD_ADDR_VAR 0 9
44412: PUSH
44413: LD_VAR 0 4
44417: PUSH
44418: LD_VAR 0 8
44422: PUSH
44423: LD_VAR 0 7
44427: UNION
44428: DIFF
44429: PPUSH
44430: LD_INT 3
44432: PPUSH
44433: CALL 104366 0 2
44437: ST_TO_ADDR
// p := [ ] ;
44438: LD_ADDR_VAR 0 11
44442: PUSH
44443: EMPTY
44444: ST_TO_ADDR
// if sort then
44445: LD_VAR 0 9
44449: IFFALSE 44565
// for i = 1 to 6 - mech do
44451: LD_ADDR_VAR 0 3
44455: PUSH
44456: DOUBLE
44457: LD_INT 1
44459: DEC
44460: ST_TO_ADDR
44461: LD_INT 6
44463: PUSH
44464: LD_VAR 0 7
44468: MINUS
44469: PUSH
44470: FOR_TO
44471: IFFALSE 44563
// begin if i = sort then
44473: LD_VAR 0 3
44477: PUSH
44478: LD_VAR 0 9
44482: EQUAL
44483: IFFALSE 44487
// break ;
44485: GO 44563
// if GetClass ( i ) = 3 then
44487: LD_VAR 0 3
44491: PPUSH
44492: CALL_OW 257
44496: PUSH
44497: LD_INT 3
44499: EQUAL
44500: IFFALSE 44504
// continue ;
44502: GO 44470
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44504: LD_ADDR_VAR 0 11
44508: PUSH
44509: LD_VAR 0 11
44513: PPUSH
44514: LD_VAR 0 11
44518: PUSH
44519: LD_INT 1
44521: PLUS
44522: PPUSH
44523: LD_VAR 0 9
44527: PUSH
44528: LD_VAR 0 3
44532: ARRAY
44533: PPUSH
44534: CALL_OW 2
44538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44539: LD_ADDR_VAR 0 4
44543: PUSH
44544: LD_VAR 0 4
44548: PUSH
44549: LD_VAR 0 9
44553: PUSH
44554: LD_VAR 0 3
44558: ARRAY
44559: DIFF
44560: ST_TO_ADDR
// end ;
44561: GO 44470
44563: POP
44564: POP
// if p then
44565: LD_VAR 0 11
44569: IFFALSE 44594
// result := Replace ( result , 3 , p ) ;
44571: LD_ADDR_VAR 0 2
44575: PUSH
44576: LD_VAR 0 2
44580: PPUSH
44581: LD_INT 3
44583: PPUSH
44584: LD_VAR 0 11
44588: PPUSH
44589: CALL_OW 1
44593: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
44594: LD_VAR 0 4
44598: PUSH
44599: LD_INT 6
44601: GREATER
44602: PUSH
44603: LD_VAR 0 6
44607: PUSH
44608: LD_INT 6
44610: LESS
44611: AND
44612: IFFALSE 44806
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44614: LD_ADDR_VAR 0 9
44618: PUSH
44619: LD_VAR 0 4
44623: PUSH
44624: LD_VAR 0 8
44628: PUSH
44629: LD_VAR 0 7
44633: UNION
44634: PUSH
44635: LD_VAR 0 6
44639: UNION
44640: DIFF
44641: PPUSH
44642: LD_INT 2
44644: PPUSH
44645: CALL 104366 0 2
44649: ST_TO_ADDR
// p := [ ] ;
44650: LD_ADDR_VAR 0 11
44654: PUSH
44655: EMPTY
44656: ST_TO_ADDR
// if sort then
44657: LD_VAR 0 9
44661: IFFALSE 44777
// for i = 1 to 6 - eng do
44663: LD_ADDR_VAR 0 3
44667: PUSH
44668: DOUBLE
44669: LD_INT 1
44671: DEC
44672: ST_TO_ADDR
44673: LD_INT 6
44675: PUSH
44676: LD_VAR 0 6
44680: MINUS
44681: PUSH
44682: FOR_TO
44683: IFFALSE 44775
// begin if i = sort then
44685: LD_VAR 0 3
44689: PUSH
44690: LD_VAR 0 9
44694: EQUAL
44695: IFFALSE 44699
// break ;
44697: GO 44775
// if GetClass ( i ) = 2 then
44699: LD_VAR 0 3
44703: PPUSH
44704: CALL_OW 257
44708: PUSH
44709: LD_INT 2
44711: EQUAL
44712: IFFALSE 44716
// continue ;
44714: GO 44682
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44716: LD_ADDR_VAR 0 11
44720: PUSH
44721: LD_VAR 0 11
44725: PPUSH
44726: LD_VAR 0 11
44730: PUSH
44731: LD_INT 1
44733: PLUS
44734: PPUSH
44735: LD_VAR 0 9
44739: PUSH
44740: LD_VAR 0 3
44744: ARRAY
44745: PPUSH
44746: CALL_OW 2
44750: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44751: LD_ADDR_VAR 0 4
44755: PUSH
44756: LD_VAR 0 4
44760: PUSH
44761: LD_VAR 0 9
44765: PUSH
44766: LD_VAR 0 3
44770: ARRAY
44771: DIFF
44772: ST_TO_ADDR
// end ;
44773: GO 44682
44775: POP
44776: POP
// if p then
44777: LD_VAR 0 11
44781: IFFALSE 44806
// result := Replace ( result , 2 , p ) ;
44783: LD_ADDR_VAR 0 2
44787: PUSH
44788: LD_VAR 0 2
44792: PPUSH
44793: LD_INT 2
44795: PPUSH
44796: LD_VAR 0 11
44800: PPUSH
44801: CALL_OW 1
44805: ST_TO_ADDR
// end ; exit ;
44806: GO 46194
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
44808: LD_EXP 127
44812: PUSH
44813: LD_EXP 126
44817: PUSH
44818: LD_VAR 0 1
44822: ARRAY
44823: ARRAY
44824: NOT
44825: PUSH
44826: LD_EXP 100
44830: PUSH
44831: LD_VAR 0 1
44835: ARRAY
44836: PPUSH
44837: LD_INT 30
44839: PUSH
44840: LD_INT 3
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PPUSH
44847: CALL_OW 72
44851: AND
44852: PUSH
44853: LD_EXP 105
44857: PUSH
44858: LD_VAR 0 1
44862: ARRAY
44863: AND
44864: IFFALSE 45472
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
44866: LD_ADDR_EXP 142
44870: PUSH
44871: LD_EXP 142
44875: PPUSH
44876: LD_VAR 0 1
44880: PPUSH
44881: LD_INT 5
44883: PPUSH
44884: CALL_OW 1
44888: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44889: LD_ADDR_VAR 0 2
44893: PUSH
44894: LD_INT 0
44896: PUSH
44897: LD_INT 0
44899: PUSH
44900: LD_INT 0
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: ST_TO_ADDR
// if sci > 1 then
44912: LD_VAR 0 8
44916: PUSH
44917: LD_INT 1
44919: GREATER
44920: IFFALSE 44948
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
44922: LD_ADDR_VAR 0 4
44926: PUSH
44927: LD_VAR 0 4
44931: PUSH
44932: LD_VAR 0 8
44936: PUSH
44937: LD_VAR 0 8
44941: PUSH
44942: LD_INT 1
44944: ARRAY
44945: DIFF
44946: DIFF
44947: ST_TO_ADDR
// if tmp and not sci then
44948: LD_VAR 0 4
44952: PUSH
44953: LD_VAR 0 8
44957: NOT
44958: AND
44959: IFFALSE 45028
// begin sort := SortBySkill ( tmp , 4 ) ;
44961: LD_ADDR_VAR 0 9
44965: PUSH
44966: LD_VAR 0 4
44970: PPUSH
44971: LD_INT 4
44973: PPUSH
44974: CALL 104366 0 2
44978: ST_TO_ADDR
// if sort then
44979: LD_VAR 0 9
44983: IFFALSE 44999
// p := sort [ 1 ] ;
44985: LD_ADDR_VAR 0 11
44989: PUSH
44990: LD_VAR 0 9
44994: PUSH
44995: LD_INT 1
44997: ARRAY
44998: ST_TO_ADDR
// if p then
44999: LD_VAR 0 11
45003: IFFALSE 45028
// result := Replace ( result , 4 , p ) ;
45005: LD_ADDR_VAR 0 2
45009: PUSH
45010: LD_VAR 0 2
45014: PPUSH
45015: LD_INT 4
45017: PPUSH
45018: LD_VAR 0 11
45022: PPUSH
45023: CALL_OW 1
45027: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45028: LD_ADDR_VAR 0 4
45032: PUSH
45033: LD_VAR 0 4
45037: PUSH
45038: LD_VAR 0 7
45042: DIFF
45043: ST_TO_ADDR
// if tmp and mech < 6 then
45044: LD_VAR 0 4
45048: PUSH
45049: LD_VAR 0 7
45053: PUSH
45054: LD_INT 6
45056: LESS
45057: AND
45058: IFFALSE 45246
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45060: LD_ADDR_VAR 0 9
45064: PUSH
45065: LD_VAR 0 4
45069: PUSH
45070: LD_VAR 0 8
45074: PUSH
45075: LD_VAR 0 7
45079: UNION
45080: DIFF
45081: PPUSH
45082: LD_INT 3
45084: PPUSH
45085: CALL 104366 0 2
45089: ST_TO_ADDR
// p := [ ] ;
45090: LD_ADDR_VAR 0 11
45094: PUSH
45095: EMPTY
45096: ST_TO_ADDR
// if sort then
45097: LD_VAR 0 9
45101: IFFALSE 45217
// for i = 1 to 6 - mech do
45103: LD_ADDR_VAR 0 3
45107: PUSH
45108: DOUBLE
45109: LD_INT 1
45111: DEC
45112: ST_TO_ADDR
45113: LD_INT 6
45115: PUSH
45116: LD_VAR 0 7
45120: MINUS
45121: PUSH
45122: FOR_TO
45123: IFFALSE 45215
// begin if i = sort then
45125: LD_VAR 0 3
45129: PUSH
45130: LD_VAR 0 9
45134: EQUAL
45135: IFFALSE 45139
// break ;
45137: GO 45215
// if GetClass ( i ) = 3 then
45139: LD_VAR 0 3
45143: PPUSH
45144: CALL_OW 257
45148: PUSH
45149: LD_INT 3
45151: EQUAL
45152: IFFALSE 45156
// continue ;
45154: GO 45122
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45156: LD_ADDR_VAR 0 11
45160: PUSH
45161: LD_VAR 0 11
45165: PPUSH
45166: LD_VAR 0 11
45170: PUSH
45171: LD_INT 1
45173: PLUS
45174: PPUSH
45175: LD_VAR 0 9
45179: PUSH
45180: LD_VAR 0 3
45184: ARRAY
45185: PPUSH
45186: CALL_OW 2
45190: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45191: LD_ADDR_VAR 0 4
45195: PUSH
45196: LD_VAR 0 4
45200: PUSH
45201: LD_VAR 0 9
45205: PUSH
45206: LD_VAR 0 3
45210: ARRAY
45211: DIFF
45212: ST_TO_ADDR
// end ;
45213: GO 45122
45215: POP
45216: POP
// if p then
45217: LD_VAR 0 11
45221: IFFALSE 45246
// result := Replace ( result , 3 , p ) ;
45223: LD_ADDR_VAR 0 2
45227: PUSH
45228: LD_VAR 0 2
45232: PPUSH
45233: LD_INT 3
45235: PPUSH
45236: LD_VAR 0 11
45240: PPUSH
45241: CALL_OW 1
45245: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45246: LD_ADDR_VAR 0 4
45250: PUSH
45251: LD_VAR 0 4
45255: PUSH
45256: LD_VAR 0 6
45260: DIFF
45261: ST_TO_ADDR
// if tmp and eng < 6 then
45262: LD_VAR 0 4
45266: PUSH
45267: LD_VAR 0 6
45271: PUSH
45272: LD_INT 6
45274: LESS
45275: AND
45276: IFFALSE 45470
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45278: LD_ADDR_VAR 0 9
45282: PUSH
45283: LD_VAR 0 4
45287: PUSH
45288: LD_VAR 0 8
45292: PUSH
45293: LD_VAR 0 7
45297: UNION
45298: PUSH
45299: LD_VAR 0 6
45303: UNION
45304: DIFF
45305: PPUSH
45306: LD_INT 2
45308: PPUSH
45309: CALL 104366 0 2
45313: ST_TO_ADDR
// p := [ ] ;
45314: LD_ADDR_VAR 0 11
45318: PUSH
45319: EMPTY
45320: ST_TO_ADDR
// if sort then
45321: LD_VAR 0 9
45325: IFFALSE 45441
// for i = 1 to 6 - eng do
45327: LD_ADDR_VAR 0 3
45331: PUSH
45332: DOUBLE
45333: LD_INT 1
45335: DEC
45336: ST_TO_ADDR
45337: LD_INT 6
45339: PUSH
45340: LD_VAR 0 6
45344: MINUS
45345: PUSH
45346: FOR_TO
45347: IFFALSE 45439
// begin if i = sort then
45349: LD_VAR 0 3
45353: PUSH
45354: LD_VAR 0 9
45358: EQUAL
45359: IFFALSE 45363
// break ;
45361: GO 45439
// if GetClass ( i ) = 2 then
45363: LD_VAR 0 3
45367: PPUSH
45368: CALL_OW 257
45372: PUSH
45373: LD_INT 2
45375: EQUAL
45376: IFFALSE 45380
// continue ;
45378: GO 45346
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45380: LD_ADDR_VAR 0 11
45384: PUSH
45385: LD_VAR 0 11
45389: PPUSH
45390: LD_VAR 0 11
45394: PUSH
45395: LD_INT 1
45397: PLUS
45398: PPUSH
45399: LD_VAR 0 9
45403: PUSH
45404: LD_VAR 0 3
45408: ARRAY
45409: PPUSH
45410: CALL_OW 2
45414: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45415: LD_ADDR_VAR 0 4
45419: PUSH
45420: LD_VAR 0 4
45424: PUSH
45425: LD_VAR 0 9
45429: PUSH
45430: LD_VAR 0 3
45434: ARRAY
45435: DIFF
45436: ST_TO_ADDR
// end ;
45437: GO 45346
45439: POP
45440: POP
// if p then
45441: LD_VAR 0 11
45445: IFFALSE 45470
// result := Replace ( result , 2 , p ) ;
45447: LD_ADDR_VAR 0 2
45451: PUSH
45452: LD_VAR 0 2
45456: PPUSH
45457: LD_INT 2
45459: PPUSH
45460: LD_VAR 0 11
45464: PPUSH
45465: CALL_OW 1
45469: ST_TO_ADDR
// end ; exit ;
45470: GO 46194
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
45472: LD_EXP 127
45476: PUSH
45477: LD_EXP 126
45481: PUSH
45482: LD_VAR 0 1
45486: ARRAY
45487: ARRAY
45488: NOT
45489: PUSH
45490: LD_EXP 100
45494: PUSH
45495: LD_VAR 0 1
45499: ARRAY
45500: PPUSH
45501: LD_INT 30
45503: PUSH
45504: LD_INT 3
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PPUSH
45511: CALL_OW 72
45515: AND
45516: PUSH
45517: LD_EXP 105
45521: PUSH
45522: LD_VAR 0 1
45526: ARRAY
45527: NOT
45528: AND
45529: IFFALSE 46194
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
45531: LD_ADDR_EXP 142
45535: PUSH
45536: LD_EXP 142
45540: PPUSH
45541: LD_VAR 0 1
45545: PPUSH
45546: LD_INT 6
45548: PPUSH
45549: CALL_OW 1
45553: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45554: LD_ADDR_VAR 0 2
45558: PUSH
45559: LD_INT 0
45561: PUSH
45562: LD_INT 0
45564: PUSH
45565: LD_INT 0
45567: PUSH
45568: LD_INT 0
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: ST_TO_ADDR
// if sci >= 1 then
45577: LD_VAR 0 8
45581: PUSH
45582: LD_INT 1
45584: GREATEREQUAL
45585: IFFALSE 45607
// tmp := tmp diff sci [ 1 ] ;
45587: LD_ADDR_VAR 0 4
45591: PUSH
45592: LD_VAR 0 4
45596: PUSH
45597: LD_VAR 0 8
45601: PUSH
45602: LD_INT 1
45604: ARRAY
45605: DIFF
45606: ST_TO_ADDR
// if tmp and not sci then
45607: LD_VAR 0 4
45611: PUSH
45612: LD_VAR 0 8
45616: NOT
45617: AND
45618: IFFALSE 45687
// begin sort := SortBySkill ( tmp , 4 ) ;
45620: LD_ADDR_VAR 0 9
45624: PUSH
45625: LD_VAR 0 4
45629: PPUSH
45630: LD_INT 4
45632: PPUSH
45633: CALL 104366 0 2
45637: ST_TO_ADDR
// if sort then
45638: LD_VAR 0 9
45642: IFFALSE 45658
// p := sort [ 1 ] ;
45644: LD_ADDR_VAR 0 11
45648: PUSH
45649: LD_VAR 0 9
45653: PUSH
45654: LD_INT 1
45656: ARRAY
45657: ST_TO_ADDR
// if p then
45658: LD_VAR 0 11
45662: IFFALSE 45687
// result := Replace ( result , 4 , p ) ;
45664: LD_ADDR_VAR 0 2
45668: PUSH
45669: LD_VAR 0 2
45673: PPUSH
45674: LD_INT 4
45676: PPUSH
45677: LD_VAR 0 11
45681: PPUSH
45682: CALL_OW 1
45686: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45687: LD_ADDR_VAR 0 4
45691: PUSH
45692: LD_VAR 0 4
45696: PUSH
45697: LD_VAR 0 7
45701: DIFF
45702: ST_TO_ADDR
// if tmp and mech < 6 then
45703: LD_VAR 0 4
45707: PUSH
45708: LD_VAR 0 7
45712: PUSH
45713: LD_INT 6
45715: LESS
45716: AND
45717: IFFALSE 45899
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
45719: LD_ADDR_VAR 0 9
45723: PUSH
45724: LD_VAR 0 4
45728: PUSH
45729: LD_VAR 0 7
45733: DIFF
45734: PPUSH
45735: LD_INT 3
45737: PPUSH
45738: CALL 104366 0 2
45742: ST_TO_ADDR
// p := [ ] ;
45743: LD_ADDR_VAR 0 11
45747: PUSH
45748: EMPTY
45749: ST_TO_ADDR
// if sort then
45750: LD_VAR 0 9
45754: IFFALSE 45870
// for i = 1 to 6 - mech do
45756: LD_ADDR_VAR 0 3
45760: PUSH
45761: DOUBLE
45762: LD_INT 1
45764: DEC
45765: ST_TO_ADDR
45766: LD_INT 6
45768: PUSH
45769: LD_VAR 0 7
45773: MINUS
45774: PUSH
45775: FOR_TO
45776: IFFALSE 45868
// begin if i = sort then
45778: LD_VAR 0 3
45782: PUSH
45783: LD_VAR 0 9
45787: EQUAL
45788: IFFALSE 45792
// break ;
45790: GO 45868
// if GetClass ( i ) = 3 then
45792: LD_VAR 0 3
45796: PPUSH
45797: CALL_OW 257
45801: PUSH
45802: LD_INT 3
45804: EQUAL
45805: IFFALSE 45809
// continue ;
45807: GO 45775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45809: LD_ADDR_VAR 0 11
45813: PUSH
45814: LD_VAR 0 11
45818: PPUSH
45819: LD_VAR 0 11
45823: PUSH
45824: LD_INT 1
45826: PLUS
45827: PPUSH
45828: LD_VAR 0 9
45832: PUSH
45833: LD_VAR 0 3
45837: ARRAY
45838: PPUSH
45839: CALL_OW 2
45843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45844: LD_ADDR_VAR 0 4
45848: PUSH
45849: LD_VAR 0 4
45853: PUSH
45854: LD_VAR 0 9
45858: PUSH
45859: LD_VAR 0 3
45863: ARRAY
45864: DIFF
45865: ST_TO_ADDR
// end ;
45866: GO 45775
45868: POP
45869: POP
// if p then
45870: LD_VAR 0 11
45874: IFFALSE 45899
// result := Replace ( result , 3 , p ) ;
45876: LD_ADDR_VAR 0 2
45880: PUSH
45881: LD_VAR 0 2
45885: PPUSH
45886: LD_INT 3
45888: PPUSH
45889: LD_VAR 0 11
45893: PPUSH
45894: CALL_OW 1
45898: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45899: LD_ADDR_VAR 0 4
45903: PUSH
45904: LD_VAR 0 4
45908: PUSH
45909: LD_VAR 0 6
45913: DIFF
45914: ST_TO_ADDR
// if tmp and eng < 4 then
45915: LD_VAR 0 4
45919: PUSH
45920: LD_VAR 0 6
45924: PUSH
45925: LD_INT 4
45927: LESS
45928: AND
45929: IFFALSE 46119
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
45931: LD_ADDR_VAR 0 9
45935: PUSH
45936: LD_VAR 0 4
45940: PUSH
45941: LD_VAR 0 7
45945: PUSH
45946: LD_VAR 0 6
45950: UNION
45951: DIFF
45952: PPUSH
45953: LD_INT 2
45955: PPUSH
45956: CALL 104366 0 2
45960: ST_TO_ADDR
// p := [ ] ;
45961: LD_ADDR_VAR 0 11
45965: PUSH
45966: EMPTY
45967: ST_TO_ADDR
// if sort then
45968: LD_VAR 0 9
45972: IFFALSE 46088
// for i = 1 to 4 - eng do
45974: LD_ADDR_VAR 0 3
45978: PUSH
45979: DOUBLE
45980: LD_INT 1
45982: DEC
45983: ST_TO_ADDR
45984: LD_INT 4
45986: PUSH
45987: LD_VAR 0 6
45991: MINUS
45992: PUSH
45993: FOR_TO
45994: IFFALSE 46086
// begin if i = sort then
45996: LD_VAR 0 3
46000: PUSH
46001: LD_VAR 0 9
46005: EQUAL
46006: IFFALSE 46010
// break ;
46008: GO 46086
// if GetClass ( i ) = 2 then
46010: LD_VAR 0 3
46014: PPUSH
46015: CALL_OW 257
46019: PUSH
46020: LD_INT 2
46022: EQUAL
46023: IFFALSE 46027
// continue ;
46025: GO 45993
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46027: LD_ADDR_VAR 0 11
46031: PUSH
46032: LD_VAR 0 11
46036: PPUSH
46037: LD_VAR 0 11
46041: PUSH
46042: LD_INT 1
46044: PLUS
46045: PPUSH
46046: LD_VAR 0 9
46050: PUSH
46051: LD_VAR 0 3
46055: ARRAY
46056: PPUSH
46057: CALL_OW 2
46061: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46062: LD_ADDR_VAR 0 4
46066: PUSH
46067: LD_VAR 0 4
46071: PUSH
46072: LD_VAR 0 9
46076: PUSH
46077: LD_VAR 0 3
46081: ARRAY
46082: DIFF
46083: ST_TO_ADDR
// end ;
46084: GO 45993
46086: POP
46087: POP
// if p then
46088: LD_VAR 0 11
46092: IFFALSE 46117
// result := Replace ( result , 2 , p ) ;
46094: LD_ADDR_VAR 0 2
46098: PUSH
46099: LD_VAR 0 2
46103: PPUSH
46104: LD_INT 2
46106: PPUSH
46107: LD_VAR 0 11
46111: PPUSH
46112: CALL_OW 1
46116: ST_TO_ADDR
// end else
46117: GO 46163
// for i = eng downto 5 do
46119: LD_ADDR_VAR 0 3
46123: PUSH
46124: DOUBLE
46125: LD_VAR 0 6
46129: INC
46130: ST_TO_ADDR
46131: LD_INT 5
46133: PUSH
46134: FOR_DOWNTO
46135: IFFALSE 46161
// tmp := tmp union eng [ i ] ;
46137: LD_ADDR_VAR 0 4
46141: PUSH
46142: LD_VAR 0 4
46146: PUSH
46147: LD_VAR 0 6
46151: PUSH
46152: LD_VAR 0 3
46156: ARRAY
46157: UNION
46158: ST_TO_ADDR
46159: GO 46134
46161: POP
46162: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
46163: LD_ADDR_VAR 0 2
46167: PUSH
46168: LD_VAR 0 2
46172: PPUSH
46173: LD_INT 1
46175: PPUSH
46176: LD_VAR 0 4
46180: PUSH
46181: LD_VAR 0 5
46185: DIFF
46186: PPUSH
46187: CALL_OW 1
46191: ST_TO_ADDR
// exit ;
46192: GO 46194
// end ; end ;
46194: LD_VAR 0 2
46198: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
46199: LD_INT 0
46201: PPUSH
46202: PPUSH
46203: PPUSH
// if not mc_bases then
46204: LD_EXP 100
46208: NOT
46209: IFFALSE 46213
// exit ;
46211: GO 46355
// for i = 1 to mc_bases do
46213: LD_ADDR_VAR 0 2
46217: PUSH
46218: DOUBLE
46219: LD_INT 1
46221: DEC
46222: ST_TO_ADDR
46223: LD_EXP 100
46227: PUSH
46228: FOR_TO
46229: IFFALSE 46346
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
46231: LD_ADDR_VAR 0 3
46235: PUSH
46236: LD_EXP 100
46240: PUSH
46241: LD_VAR 0 2
46245: ARRAY
46246: PPUSH
46247: LD_INT 21
46249: PUSH
46250: LD_INT 3
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: LD_INT 2
46262: PUSH
46263: LD_INT 30
46265: PUSH
46266: LD_INT 29
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: PUSH
46273: LD_INT 30
46275: PUSH
46276: LD_INT 30
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: LIST
46287: PUSH
46288: EMPTY
46289: LIST
46290: LIST
46291: PUSH
46292: LD_INT 3
46294: PUSH
46295: LD_INT 24
46297: PUSH
46298: LD_INT 1000
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: LIST
46313: PPUSH
46314: CALL_OW 72
46318: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
46319: LD_ADDR_EXP 101
46323: PUSH
46324: LD_EXP 101
46328: PPUSH
46329: LD_VAR 0 2
46333: PPUSH
46334: LD_VAR 0 3
46338: PPUSH
46339: CALL_OW 1
46343: ST_TO_ADDR
// end ;
46344: GO 46228
46346: POP
46347: POP
// RaiseSailEvent ( 101 ) ;
46348: LD_INT 101
46350: PPUSH
46351: CALL_OW 427
// end ;
46355: LD_VAR 0 1
46359: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
46360: LD_INT 0
46362: PPUSH
46363: PPUSH
46364: PPUSH
46365: PPUSH
46366: PPUSH
46367: PPUSH
46368: PPUSH
// if not mc_bases then
46369: LD_EXP 100
46373: NOT
46374: IFFALSE 46378
// exit ;
46376: GO 46940
// for i = 1 to mc_bases do
46378: LD_ADDR_VAR 0 2
46382: PUSH
46383: DOUBLE
46384: LD_INT 1
46386: DEC
46387: ST_TO_ADDR
46388: LD_EXP 100
46392: PUSH
46393: FOR_TO
46394: IFFALSE 46931
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
46396: LD_ADDR_VAR 0 5
46400: PUSH
46401: LD_EXP 100
46405: PUSH
46406: LD_VAR 0 2
46410: ARRAY
46411: PUSH
46412: LD_EXP 129
46416: PUSH
46417: LD_VAR 0 2
46421: ARRAY
46422: UNION
46423: PPUSH
46424: LD_INT 21
46426: PUSH
46427: LD_INT 1
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: PUSH
46434: LD_INT 1
46436: PUSH
46437: LD_INT 3
46439: PUSH
46440: LD_INT 54
46442: PUSH
46443: EMPTY
46444: LIST
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 3
46452: PUSH
46453: LD_INT 24
46455: PUSH
46456: LD_INT 1000
46458: PUSH
46459: EMPTY
46460: LIST
46461: LIST
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: LIST
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PPUSH
46476: CALL_OW 72
46480: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
46481: LD_ADDR_VAR 0 6
46485: PUSH
46486: LD_EXP 100
46490: PUSH
46491: LD_VAR 0 2
46495: ARRAY
46496: PPUSH
46497: LD_INT 21
46499: PUSH
46500: LD_INT 1
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: PUSH
46507: LD_INT 1
46509: PUSH
46510: LD_INT 3
46512: PUSH
46513: LD_INT 54
46515: PUSH
46516: EMPTY
46517: LIST
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 3
46525: PUSH
46526: LD_INT 24
46528: PUSH
46529: LD_INT 250
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: LIST
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PPUSH
46549: CALL_OW 72
46553: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
46554: LD_ADDR_VAR 0 7
46558: PUSH
46559: LD_VAR 0 5
46563: PUSH
46564: LD_VAR 0 6
46568: DIFF
46569: ST_TO_ADDR
// if not need_heal_1 then
46570: LD_VAR 0 6
46574: NOT
46575: IFFALSE 46608
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
46577: LD_ADDR_EXP 103
46581: PUSH
46582: LD_EXP 103
46586: PPUSH
46587: LD_VAR 0 2
46591: PUSH
46592: LD_INT 1
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PPUSH
46599: EMPTY
46600: PPUSH
46601: CALL 73519 0 3
46605: ST_TO_ADDR
46606: GO 46678
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
46608: LD_ADDR_EXP 103
46612: PUSH
46613: LD_EXP 103
46617: PPUSH
46618: LD_VAR 0 2
46622: PUSH
46623: LD_INT 1
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PPUSH
46630: LD_EXP 103
46634: PUSH
46635: LD_VAR 0 2
46639: ARRAY
46640: PUSH
46641: LD_INT 1
46643: ARRAY
46644: PPUSH
46645: LD_INT 3
46647: PUSH
46648: LD_INT 24
46650: PUSH
46651: LD_INT 1000
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: PPUSH
46662: CALL_OW 72
46666: PUSH
46667: LD_VAR 0 6
46671: UNION
46672: PPUSH
46673: CALL 73519 0 3
46677: ST_TO_ADDR
// if not need_heal_2 then
46678: LD_VAR 0 7
46682: NOT
46683: IFFALSE 46716
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
46685: LD_ADDR_EXP 103
46689: PUSH
46690: LD_EXP 103
46694: PPUSH
46695: LD_VAR 0 2
46699: PUSH
46700: LD_INT 2
46702: PUSH
46703: EMPTY
46704: LIST
46705: LIST
46706: PPUSH
46707: EMPTY
46708: PPUSH
46709: CALL 73519 0 3
46713: ST_TO_ADDR
46714: GO 46748
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
46716: LD_ADDR_EXP 103
46720: PUSH
46721: LD_EXP 103
46725: PPUSH
46726: LD_VAR 0 2
46730: PUSH
46731: LD_INT 2
46733: PUSH
46734: EMPTY
46735: LIST
46736: LIST
46737: PPUSH
46738: LD_VAR 0 7
46742: PPUSH
46743: CALL 73519 0 3
46747: ST_TO_ADDR
// if need_heal_2 then
46748: LD_VAR 0 7
46752: IFFALSE 46913
// for j in need_heal_2 do
46754: LD_ADDR_VAR 0 3
46758: PUSH
46759: LD_VAR 0 7
46763: PUSH
46764: FOR_IN
46765: IFFALSE 46911
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46767: LD_ADDR_VAR 0 5
46771: PUSH
46772: LD_EXP 100
46776: PUSH
46777: LD_VAR 0 2
46781: ARRAY
46782: PPUSH
46783: LD_INT 2
46785: PUSH
46786: LD_INT 30
46788: PUSH
46789: LD_INT 6
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: PUSH
46796: LD_INT 30
46798: PUSH
46799: LD_INT 7
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 30
46808: PUSH
46809: LD_INT 8
46811: PUSH
46812: EMPTY
46813: LIST
46814: LIST
46815: PUSH
46816: LD_INT 30
46818: PUSH
46819: LD_INT 0
46821: PUSH
46822: EMPTY
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 30
46828: PUSH
46829: LD_INT 1
46831: PUSH
46832: EMPTY
46833: LIST
46834: LIST
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: PPUSH
46844: CALL_OW 72
46848: ST_TO_ADDR
// if tmp then
46849: LD_VAR 0 5
46853: IFFALSE 46909
// begin k := NearestUnitToUnit ( tmp , j ) ;
46855: LD_ADDR_VAR 0 4
46859: PUSH
46860: LD_VAR 0 5
46864: PPUSH
46865: LD_VAR 0 3
46869: PPUSH
46870: CALL_OW 74
46874: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
46875: LD_VAR 0 3
46879: PPUSH
46880: LD_VAR 0 4
46884: PPUSH
46885: CALL_OW 296
46889: PUSH
46890: LD_INT 5
46892: GREATER
46893: IFFALSE 46909
// ComMoveToNearbyEntrance ( j , k ) ;
46895: LD_VAR 0 3
46899: PPUSH
46900: LD_VAR 0 4
46904: PPUSH
46905: CALL 106726 0 2
// end ; end ;
46909: GO 46764
46911: POP
46912: POP
// if not need_heal_1 and not need_heal_2 then
46913: LD_VAR 0 6
46917: NOT
46918: PUSH
46919: LD_VAR 0 7
46923: NOT
46924: AND
46925: IFFALSE 46929
// continue ;
46927: GO 46393
// end ;
46929: GO 46393
46931: POP
46932: POP
// RaiseSailEvent ( 102 ) ;
46933: LD_INT 102
46935: PPUSH
46936: CALL_OW 427
// end ;
46940: LD_VAR 0 1
46944: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
46945: LD_INT 0
46947: PPUSH
46948: PPUSH
46949: PPUSH
46950: PPUSH
46951: PPUSH
46952: PPUSH
46953: PPUSH
46954: PPUSH
// if not mc_bases then
46955: LD_EXP 100
46959: NOT
46960: IFFALSE 46964
// exit ;
46962: GO 47875
// for i = 1 to mc_bases do
46964: LD_ADDR_VAR 0 2
46968: PUSH
46969: DOUBLE
46970: LD_INT 1
46972: DEC
46973: ST_TO_ADDR
46974: LD_EXP 100
46978: PUSH
46979: FOR_TO
46980: IFFALSE 47873
// begin if not mc_building_need_repair [ i ] then
46982: LD_EXP 101
46986: PUSH
46987: LD_VAR 0 2
46991: ARRAY
46992: NOT
46993: IFFALSE 47178
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
46995: LD_ADDR_VAR 0 6
46999: PUSH
47000: LD_EXP 119
47004: PUSH
47005: LD_VAR 0 2
47009: ARRAY
47010: PPUSH
47011: LD_INT 3
47013: PUSH
47014: LD_INT 24
47016: PUSH
47017: LD_INT 1000
47019: PUSH
47020: EMPTY
47021: LIST
47022: LIST
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PUSH
47028: LD_INT 2
47030: PUSH
47031: LD_INT 34
47033: PUSH
47034: LD_INT 13
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 34
47043: PUSH
47044: LD_INT 52
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 34
47053: PUSH
47054: LD_INT 88
47056: PUSH
47057: EMPTY
47058: LIST
47059: LIST
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: PUSH
47067: EMPTY
47068: LIST
47069: LIST
47070: PPUSH
47071: CALL_OW 72
47075: ST_TO_ADDR
// if cranes then
47076: LD_VAR 0 6
47080: IFFALSE 47142
// for j in cranes do
47082: LD_ADDR_VAR 0 3
47086: PUSH
47087: LD_VAR 0 6
47091: PUSH
47092: FOR_IN
47093: IFFALSE 47140
// if not IsInArea ( j , mc_parking [ i ] ) then
47095: LD_VAR 0 3
47099: PPUSH
47100: LD_EXP 124
47104: PUSH
47105: LD_VAR 0 2
47109: ARRAY
47110: PPUSH
47111: CALL_OW 308
47115: NOT
47116: IFFALSE 47138
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47118: LD_VAR 0 3
47122: PPUSH
47123: LD_EXP 124
47127: PUSH
47128: LD_VAR 0 2
47132: ARRAY
47133: PPUSH
47134: CALL_OW 113
47138: GO 47092
47140: POP
47141: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
47142: LD_ADDR_EXP 102
47146: PUSH
47147: LD_EXP 102
47151: PPUSH
47152: LD_VAR 0 2
47156: PPUSH
47157: EMPTY
47158: PPUSH
47159: CALL_OW 1
47163: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
47164: LD_VAR 0 2
47168: PPUSH
47169: LD_INT 101
47171: PPUSH
47172: CALL 42032 0 2
// continue ;
47176: GO 46979
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
47178: LD_ADDR_EXP 106
47182: PUSH
47183: LD_EXP 106
47187: PPUSH
47188: LD_VAR 0 2
47192: PPUSH
47193: EMPTY
47194: PPUSH
47195: CALL_OW 1
47199: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47200: LD_VAR 0 2
47204: PPUSH
47205: LD_INT 103
47207: PPUSH
47208: CALL 42032 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
47212: LD_ADDR_VAR 0 5
47216: PUSH
47217: LD_EXP 100
47221: PUSH
47222: LD_VAR 0 2
47226: ARRAY
47227: PUSH
47228: LD_EXP 129
47232: PUSH
47233: LD_VAR 0 2
47237: ARRAY
47238: UNION
47239: PPUSH
47240: LD_INT 2
47242: PUSH
47243: LD_INT 25
47245: PUSH
47246: LD_INT 2
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: PUSH
47253: LD_INT 25
47255: PUSH
47256: LD_INT 16
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: LIST
47267: PUSH
47268: EMPTY
47269: LIST
47270: PPUSH
47271: CALL_OW 72
47275: ST_TO_ADDR
// if mc_need_heal [ i ] then
47276: LD_EXP 103
47280: PUSH
47281: LD_VAR 0 2
47285: ARRAY
47286: IFFALSE 47330
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
47288: LD_ADDR_VAR 0 5
47292: PUSH
47293: LD_VAR 0 5
47297: PUSH
47298: LD_EXP 103
47302: PUSH
47303: LD_VAR 0 2
47307: ARRAY
47308: PUSH
47309: LD_INT 1
47311: ARRAY
47312: PUSH
47313: LD_EXP 103
47317: PUSH
47318: LD_VAR 0 2
47322: ARRAY
47323: PUSH
47324: LD_INT 2
47326: ARRAY
47327: UNION
47328: DIFF
47329: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
47330: LD_ADDR_VAR 0 6
47334: PUSH
47335: LD_EXP 119
47339: PUSH
47340: LD_VAR 0 2
47344: ARRAY
47345: PPUSH
47346: LD_INT 2
47348: PUSH
47349: LD_INT 34
47351: PUSH
47352: LD_INT 13
47354: PUSH
47355: EMPTY
47356: LIST
47357: LIST
47358: PUSH
47359: LD_INT 34
47361: PUSH
47362: LD_INT 52
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PUSH
47369: LD_INT 34
47371: PUSH
47372: LD_INT 88
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: PPUSH
47385: CALL_OW 72
47389: ST_TO_ADDR
// if cranes then
47390: LD_VAR 0 6
47394: IFFALSE 47562
// begin for j in cranes do
47396: LD_ADDR_VAR 0 3
47400: PUSH
47401: LD_VAR 0 6
47405: PUSH
47406: FOR_IN
47407: IFFALSE 47560
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
47409: LD_VAR 0 3
47413: PPUSH
47414: CALL_OW 256
47418: PUSH
47419: LD_INT 1000
47421: EQUAL
47422: PUSH
47423: LD_VAR 0 3
47427: PPUSH
47428: CALL_OW 314
47432: NOT
47433: AND
47434: IFFALSE 47500
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
47436: LD_ADDR_VAR 0 8
47440: PUSH
47441: LD_EXP 101
47445: PUSH
47446: LD_VAR 0 2
47450: ARRAY
47451: PPUSH
47452: LD_VAR 0 3
47456: PPUSH
47457: CALL_OW 74
47461: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
47462: LD_VAR 0 8
47466: PPUSH
47467: LD_INT 16
47469: PPUSH
47470: CALL 76116 0 2
47474: PUSH
47475: LD_INT 4
47477: ARRAY
47478: PUSH
47479: LD_INT 10
47481: LESS
47482: IFFALSE 47498
// ComRepairBuilding ( j , to_repair ) ;
47484: LD_VAR 0 3
47488: PPUSH
47489: LD_VAR 0 8
47493: PPUSH
47494: CALL_OW 130
// end else
47498: GO 47558
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
47500: LD_VAR 0 3
47504: PPUSH
47505: CALL_OW 256
47509: PUSH
47510: LD_INT 500
47512: LESS
47513: PUSH
47514: LD_VAR 0 3
47518: PPUSH
47519: LD_EXP 124
47523: PUSH
47524: LD_VAR 0 2
47528: ARRAY
47529: PPUSH
47530: CALL_OW 308
47534: NOT
47535: AND
47536: IFFALSE 47558
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47538: LD_VAR 0 3
47542: PPUSH
47543: LD_EXP 124
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: PPUSH
47554: CALL_OW 113
// end ;
47558: GO 47406
47560: POP
47561: POP
// end ; if tmp > 3 then
47562: LD_VAR 0 5
47566: PUSH
47567: LD_INT 3
47569: GREATER
47570: IFFALSE 47590
// tmp := ShrinkArray ( tmp , 4 ) ;
47572: LD_ADDR_VAR 0 5
47576: PUSH
47577: LD_VAR 0 5
47581: PPUSH
47582: LD_INT 4
47584: PPUSH
47585: CALL 106164 0 2
47589: ST_TO_ADDR
// if not tmp then
47590: LD_VAR 0 5
47594: NOT
47595: IFFALSE 47599
// continue ;
47597: GO 46979
// for j in tmp do
47599: LD_ADDR_VAR 0 3
47603: PUSH
47604: LD_VAR 0 5
47608: PUSH
47609: FOR_IN
47610: IFFALSE 47869
// begin if IsInUnit ( j ) then
47612: LD_VAR 0 3
47616: PPUSH
47617: CALL_OW 310
47621: IFFALSE 47632
// ComExitBuilding ( j ) ;
47623: LD_VAR 0 3
47627: PPUSH
47628: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
47632: LD_VAR 0 3
47636: PUSH
47637: LD_EXP 102
47641: PUSH
47642: LD_VAR 0 2
47646: ARRAY
47647: IN
47648: NOT
47649: IFFALSE 47707
// begin SetTag ( j , 101 ) ;
47651: LD_VAR 0 3
47655: PPUSH
47656: LD_INT 101
47658: PPUSH
47659: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
47663: LD_ADDR_EXP 102
47667: PUSH
47668: LD_EXP 102
47672: PPUSH
47673: LD_VAR 0 2
47677: PUSH
47678: LD_EXP 102
47682: PUSH
47683: LD_VAR 0 2
47687: ARRAY
47688: PUSH
47689: LD_INT 1
47691: PLUS
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: PPUSH
47697: LD_VAR 0 3
47701: PPUSH
47702: CALL 73519 0 3
47706: ST_TO_ADDR
// end ; wait ( 1 ) ;
47707: LD_INT 1
47709: PPUSH
47710: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
47714: LD_ADDR_VAR 0 7
47718: PUSH
47719: LD_EXP 101
47723: PUSH
47724: LD_VAR 0 2
47728: ARRAY
47729: ST_TO_ADDR
// if mc_scan [ i ] then
47730: LD_EXP 123
47734: PUSH
47735: LD_VAR 0 2
47739: ARRAY
47740: IFFALSE 47802
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
47742: LD_ADDR_VAR 0 7
47746: PUSH
47747: LD_EXP 101
47751: PUSH
47752: LD_VAR 0 2
47756: ARRAY
47757: PPUSH
47758: LD_INT 3
47760: PUSH
47761: LD_INT 30
47763: PUSH
47764: LD_INT 32
47766: PUSH
47767: EMPTY
47768: LIST
47769: LIST
47770: PUSH
47771: LD_INT 30
47773: PUSH
47774: LD_INT 33
47776: PUSH
47777: EMPTY
47778: LIST
47779: LIST
47780: PUSH
47781: LD_INT 30
47783: PUSH
47784: LD_INT 31
47786: PUSH
47787: EMPTY
47788: LIST
47789: LIST
47790: PUSH
47791: EMPTY
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: PPUSH
47797: CALL_OW 72
47801: ST_TO_ADDR
// if not to_repair_tmp then
47802: LD_VAR 0 7
47806: NOT
47807: IFFALSE 47811
// continue ;
47809: GO 47609
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
47811: LD_ADDR_VAR 0 8
47815: PUSH
47816: LD_VAR 0 7
47820: PPUSH
47821: LD_VAR 0 3
47825: PPUSH
47826: CALL_OW 74
47830: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
47831: LD_VAR 0 8
47835: PPUSH
47836: LD_INT 16
47838: PPUSH
47839: CALL 76116 0 2
47843: PUSH
47844: LD_INT 4
47846: ARRAY
47847: PUSH
47848: LD_INT 14
47850: LESS
47851: IFFALSE 47867
// ComRepairBuilding ( j , to_repair ) ;
47853: LD_VAR 0 3
47857: PPUSH
47858: LD_VAR 0 8
47862: PPUSH
47863: CALL_OW 130
// end ;
47867: GO 47609
47869: POP
47870: POP
// end ;
47871: GO 46979
47873: POP
47874: POP
// end ;
47875: LD_VAR 0 1
47879: RET
// export function MC_Heal ; var i , j , tmp ; begin
47880: LD_INT 0
47882: PPUSH
47883: PPUSH
47884: PPUSH
47885: PPUSH
// if not mc_bases then
47886: LD_EXP 100
47890: NOT
47891: IFFALSE 47895
// exit ;
47893: GO 48297
// for i = 1 to mc_bases do
47895: LD_ADDR_VAR 0 2
47899: PUSH
47900: DOUBLE
47901: LD_INT 1
47903: DEC
47904: ST_TO_ADDR
47905: LD_EXP 100
47909: PUSH
47910: FOR_TO
47911: IFFALSE 48295
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
47913: LD_EXP 103
47917: PUSH
47918: LD_VAR 0 2
47922: ARRAY
47923: PUSH
47924: LD_INT 1
47926: ARRAY
47927: NOT
47928: PUSH
47929: LD_EXP 103
47933: PUSH
47934: LD_VAR 0 2
47938: ARRAY
47939: PUSH
47940: LD_INT 2
47942: ARRAY
47943: NOT
47944: AND
47945: IFFALSE 47983
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
47947: LD_ADDR_EXP 104
47951: PUSH
47952: LD_EXP 104
47956: PPUSH
47957: LD_VAR 0 2
47961: PPUSH
47962: EMPTY
47963: PPUSH
47964: CALL_OW 1
47968: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
47969: LD_VAR 0 2
47973: PPUSH
47974: LD_INT 102
47976: PPUSH
47977: CALL 42032 0 2
// continue ;
47981: GO 47910
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
47983: LD_ADDR_VAR 0 4
47987: PUSH
47988: LD_EXP 100
47992: PUSH
47993: LD_VAR 0 2
47997: ARRAY
47998: PPUSH
47999: LD_INT 25
48001: PUSH
48002: LD_INT 4
48004: PUSH
48005: EMPTY
48006: LIST
48007: LIST
48008: PPUSH
48009: CALL_OW 72
48013: ST_TO_ADDR
// if not tmp then
48014: LD_VAR 0 4
48018: NOT
48019: IFFALSE 48023
// continue ;
48021: GO 47910
// if mc_taming [ i ] then
48023: LD_EXP 131
48027: PUSH
48028: LD_VAR 0 2
48032: ARRAY
48033: IFFALSE 48057
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48035: LD_ADDR_EXP 131
48039: PUSH
48040: LD_EXP 131
48044: PPUSH
48045: LD_VAR 0 2
48049: PPUSH
48050: EMPTY
48051: PPUSH
48052: CALL_OW 1
48056: ST_TO_ADDR
// for j in tmp do
48057: LD_ADDR_VAR 0 3
48061: PUSH
48062: LD_VAR 0 4
48066: PUSH
48067: FOR_IN
48068: IFFALSE 48291
// begin if IsInUnit ( j ) then
48070: LD_VAR 0 3
48074: PPUSH
48075: CALL_OW 310
48079: IFFALSE 48090
// ComExitBuilding ( j ) ;
48081: LD_VAR 0 3
48085: PPUSH
48086: CALL_OW 122
// if not j in mc_healers [ i ] then
48090: LD_VAR 0 3
48094: PUSH
48095: LD_EXP 104
48099: PUSH
48100: LD_VAR 0 2
48104: ARRAY
48105: IN
48106: NOT
48107: IFFALSE 48153
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48109: LD_ADDR_EXP 104
48113: PUSH
48114: LD_EXP 104
48118: PPUSH
48119: LD_VAR 0 2
48123: PUSH
48124: LD_EXP 104
48128: PUSH
48129: LD_VAR 0 2
48133: ARRAY
48134: PUSH
48135: LD_INT 1
48137: PLUS
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PPUSH
48143: LD_VAR 0 3
48147: PPUSH
48148: CALL 73519 0 3
48152: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
48153: LD_VAR 0 3
48157: PPUSH
48158: CALL_OW 110
48162: PUSH
48163: LD_INT 102
48165: NONEQUAL
48166: IFFALSE 48180
// SetTag ( j , 102 ) ;
48168: LD_VAR 0 3
48172: PPUSH
48173: LD_INT 102
48175: PPUSH
48176: CALL_OW 109
// Wait ( 3 ) ;
48180: LD_INT 3
48182: PPUSH
48183: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
48187: LD_EXP 103
48191: PUSH
48192: LD_VAR 0 2
48196: ARRAY
48197: PUSH
48198: LD_INT 1
48200: ARRAY
48201: IFFALSE 48233
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
48203: LD_VAR 0 3
48207: PPUSH
48208: LD_EXP 103
48212: PUSH
48213: LD_VAR 0 2
48217: ARRAY
48218: PUSH
48219: LD_INT 1
48221: ARRAY
48222: PUSH
48223: LD_INT 1
48225: ARRAY
48226: PPUSH
48227: CALL_OW 128
48231: GO 48289
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
48233: LD_VAR 0 3
48237: PPUSH
48238: CALL_OW 314
48242: NOT
48243: PUSH
48244: LD_EXP 103
48248: PUSH
48249: LD_VAR 0 2
48253: ARRAY
48254: PUSH
48255: LD_INT 2
48257: ARRAY
48258: AND
48259: IFFALSE 48289
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
48261: LD_VAR 0 3
48265: PPUSH
48266: LD_EXP 103
48270: PUSH
48271: LD_VAR 0 2
48275: ARRAY
48276: PUSH
48277: LD_INT 2
48279: ARRAY
48280: PUSH
48281: LD_INT 1
48283: ARRAY
48284: PPUSH
48285: CALL_OW 128
// end ;
48289: GO 48067
48291: POP
48292: POP
// end ;
48293: GO 47910
48295: POP
48296: POP
// end ;
48297: LD_VAR 0 1
48301: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
48302: LD_INT 0
48304: PPUSH
48305: PPUSH
48306: PPUSH
48307: PPUSH
48308: PPUSH
48309: PPUSH
// if not mc_bases then
48310: LD_EXP 100
48314: NOT
48315: IFFALSE 48319
// exit ;
48317: GO 49482
// for i = 1 to mc_bases do
48319: LD_ADDR_VAR 0 2
48323: PUSH
48324: DOUBLE
48325: LD_INT 1
48327: DEC
48328: ST_TO_ADDR
48329: LD_EXP 100
48333: PUSH
48334: FOR_TO
48335: IFFALSE 49480
// begin if mc_scan [ i ] then
48337: LD_EXP 123
48341: PUSH
48342: LD_VAR 0 2
48346: ARRAY
48347: IFFALSE 48351
// continue ;
48349: GO 48334
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
48351: LD_EXP 105
48355: PUSH
48356: LD_VAR 0 2
48360: ARRAY
48361: NOT
48362: PUSH
48363: LD_EXP 107
48367: PUSH
48368: LD_VAR 0 2
48372: ARRAY
48373: NOT
48374: AND
48375: PUSH
48376: LD_EXP 106
48380: PUSH
48381: LD_VAR 0 2
48385: ARRAY
48386: AND
48387: IFFALSE 48425
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
48389: LD_ADDR_EXP 106
48393: PUSH
48394: LD_EXP 106
48398: PPUSH
48399: LD_VAR 0 2
48403: PPUSH
48404: EMPTY
48405: PPUSH
48406: CALL_OW 1
48410: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48411: LD_VAR 0 2
48415: PPUSH
48416: LD_INT 103
48418: PPUSH
48419: CALL 42032 0 2
// continue ;
48423: GO 48334
// end ; if mc_construct_list [ i ] then
48425: LD_EXP 107
48429: PUSH
48430: LD_VAR 0 2
48434: ARRAY
48435: IFFALSE 48655
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48437: LD_ADDR_VAR 0 5
48441: PUSH
48442: LD_EXP 100
48446: PUSH
48447: LD_VAR 0 2
48451: ARRAY
48452: PPUSH
48453: LD_INT 25
48455: PUSH
48456: LD_INT 2
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PPUSH
48463: CALL_OW 72
48467: PUSH
48468: LD_EXP 102
48472: PUSH
48473: LD_VAR 0 2
48477: ARRAY
48478: DIFF
48479: ST_TO_ADDR
// if not tmp then
48480: LD_VAR 0 5
48484: NOT
48485: IFFALSE 48489
// continue ;
48487: GO 48334
// for j in tmp do
48489: LD_ADDR_VAR 0 3
48493: PUSH
48494: LD_VAR 0 5
48498: PUSH
48499: FOR_IN
48500: IFFALSE 48651
// begin if not mc_builders [ i ] then
48502: LD_EXP 106
48506: PUSH
48507: LD_VAR 0 2
48511: ARRAY
48512: NOT
48513: IFFALSE 48571
// begin SetTag ( j , 103 ) ;
48515: LD_VAR 0 3
48519: PPUSH
48520: LD_INT 103
48522: PPUSH
48523: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48527: LD_ADDR_EXP 106
48531: PUSH
48532: LD_EXP 106
48536: PPUSH
48537: LD_VAR 0 2
48541: PUSH
48542: LD_EXP 106
48546: PUSH
48547: LD_VAR 0 2
48551: ARRAY
48552: PUSH
48553: LD_INT 1
48555: PLUS
48556: PUSH
48557: EMPTY
48558: LIST
48559: LIST
48560: PPUSH
48561: LD_VAR 0 3
48565: PPUSH
48566: CALL 73519 0 3
48570: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48571: LD_VAR 0 3
48575: PPUSH
48576: CALL_OW 310
48580: IFFALSE 48591
// ComExitBuilding ( j ) ;
48582: LD_VAR 0 3
48586: PPUSH
48587: CALL_OW 122
// wait ( 3 ) ;
48591: LD_INT 3
48593: PPUSH
48594: CALL_OW 67
// if not mc_construct_list [ i ] then
48598: LD_EXP 107
48602: PUSH
48603: LD_VAR 0 2
48607: ARRAY
48608: NOT
48609: IFFALSE 48613
// break ;
48611: GO 48651
// if not HasTask ( j ) then
48613: LD_VAR 0 3
48617: PPUSH
48618: CALL_OW 314
48622: NOT
48623: IFFALSE 48649
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
48625: LD_VAR 0 3
48629: PPUSH
48630: LD_EXP 107
48634: PUSH
48635: LD_VAR 0 2
48639: ARRAY
48640: PUSH
48641: LD_INT 1
48643: ARRAY
48644: PPUSH
48645: CALL 76380 0 2
// end ;
48649: GO 48499
48651: POP
48652: POP
// end else
48653: GO 49478
// if mc_build_list [ i ] then
48655: LD_EXP 105
48659: PUSH
48660: LD_VAR 0 2
48664: ARRAY
48665: IFFALSE 49478
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
48667: LD_EXP 105
48671: PUSH
48672: LD_VAR 0 2
48676: ARRAY
48677: PUSH
48678: LD_INT 1
48680: ARRAY
48681: PUSH
48682: LD_INT 1
48684: ARRAY
48685: PPUSH
48686: CALL 76204 0 1
48690: PUSH
48691: LD_EXP 100
48695: PUSH
48696: LD_VAR 0 2
48700: ARRAY
48701: PPUSH
48702: LD_INT 2
48704: PUSH
48705: LD_INT 30
48707: PUSH
48708: LD_INT 2
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: PUSH
48715: LD_INT 30
48717: PUSH
48718: LD_INT 3
48720: PUSH
48721: EMPTY
48722: LIST
48723: LIST
48724: PUSH
48725: EMPTY
48726: LIST
48727: LIST
48728: LIST
48729: PPUSH
48730: CALL_OW 72
48734: NOT
48735: AND
48736: IFFALSE 48841
// begin for j = 1 to mc_build_list [ i ] do
48738: LD_ADDR_VAR 0 3
48742: PUSH
48743: DOUBLE
48744: LD_INT 1
48746: DEC
48747: ST_TO_ADDR
48748: LD_EXP 105
48752: PUSH
48753: LD_VAR 0 2
48757: ARRAY
48758: PUSH
48759: FOR_TO
48760: IFFALSE 48839
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
48762: LD_EXP 105
48766: PUSH
48767: LD_VAR 0 2
48771: ARRAY
48772: PUSH
48773: LD_VAR 0 3
48777: ARRAY
48778: PUSH
48779: LD_INT 1
48781: ARRAY
48782: PUSH
48783: LD_INT 2
48785: EQUAL
48786: IFFALSE 48837
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
48788: LD_ADDR_EXP 105
48792: PUSH
48793: LD_EXP 105
48797: PPUSH
48798: LD_VAR 0 2
48802: PPUSH
48803: LD_EXP 105
48807: PUSH
48808: LD_VAR 0 2
48812: ARRAY
48813: PPUSH
48814: LD_VAR 0 3
48818: PPUSH
48819: LD_INT 1
48821: PPUSH
48822: LD_INT 0
48824: PPUSH
48825: CALL 72937 0 4
48829: PPUSH
48830: CALL_OW 1
48834: ST_TO_ADDR
// break ;
48835: GO 48839
// end ;
48837: GO 48759
48839: POP
48840: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48841: LD_ADDR_VAR 0 6
48845: PUSH
48846: LD_EXP 100
48850: PUSH
48851: LD_VAR 0 2
48855: ARRAY
48856: PPUSH
48857: LD_INT 2
48859: PUSH
48860: LD_INT 30
48862: PUSH
48863: LD_INT 0
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 30
48872: PUSH
48873: LD_INT 1
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: LIST
48884: PPUSH
48885: CALL_OW 72
48889: ST_TO_ADDR
// for k := 1 to depot do
48890: LD_ADDR_VAR 0 4
48894: PUSH
48895: DOUBLE
48896: LD_INT 1
48898: DEC
48899: ST_TO_ADDR
48900: LD_VAR 0 6
48904: PUSH
48905: FOR_TO
48906: IFFALSE 49476
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
48908: LD_EXP 105
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: PUSH
48919: LD_INT 1
48921: ARRAY
48922: PUSH
48923: LD_INT 1
48925: ARRAY
48926: PUSH
48927: LD_INT 0
48929: EQUAL
48930: PUSH
48931: LD_VAR 0 6
48935: PUSH
48936: LD_VAR 0 4
48940: ARRAY
48941: PPUSH
48942: LD_EXP 105
48946: PUSH
48947: LD_VAR 0 2
48951: ARRAY
48952: PUSH
48953: LD_INT 1
48955: ARRAY
48956: PUSH
48957: LD_INT 1
48959: ARRAY
48960: PPUSH
48961: LD_EXP 105
48965: PUSH
48966: LD_VAR 0 2
48970: ARRAY
48971: PUSH
48972: LD_INT 1
48974: ARRAY
48975: PUSH
48976: LD_INT 2
48978: ARRAY
48979: PPUSH
48980: LD_EXP 105
48984: PUSH
48985: LD_VAR 0 2
48989: ARRAY
48990: PUSH
48991: LD_INT 1
48993: ARRAY
48994: PUSH
48995: LD_INT 3
48997: ARRAY
48998: PPUSH
48999: LD_EXP 105
49003: PUSH
49004: LD_VAR 0 2
49008: ARRAY
49009: PUSH
49010: LD_INT 1
49012: ARRAY
49013: PUSH
49014: LD_INT 4
49016: ARRAY
49017: PPUSH
49018: CALL 81616 0 5
49022: OR
49023: IFFALSE 49304
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49025: LD_ADDR_VAR 0 5
49029: PUSH
49030: LD_EXP 100
49034: PUSH
49035: LD_VAR 0 2
49039: ARRAY
49040: PPUSH
49041: LD_INT 25
49043: PUSH
49044: LD_INT 2
49046: PUSH
49047: EMPTY
49048: LIST
49049: LIST
49050: PPUSH
49051: CALL_OW 72
49055: PUSH
49056: LD_EXP 102
49060: PUSH
49061: LD_VAR 0 2
49065: ARRAY
49066: DIFF
49067: ST_TO_ADDR
// if not tmp then
49068: LD_VAR 0 5
49072: NOT
49073: IFFALSE 49077
// continue ;
49075: GO 48905
// for j in tmp do
49077: LD_ADDR_VAR 0 3
49081: PUSH
49082: LD_VAR 0 5
49086: PUSH
49087: FOR_IN
49088: IFFALSE 49300
// begin if not mc_builders [ i ] then
49090: LD_EXP 106
49094: PUSH
49095: LD_VAR 0 2
49099: ARRAY
49100: NOT
49101: IFFALSE 49159
// begin SetTag ( j , 103 ) ;
49103: LD_VAR 0 3
49107: PPUSH
49108: LD_INT 103
49110: PPUSH
49111: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49115: LD_ADDR_EXP 106
49119: PUSH
49120: LD_EXP 106
49124: PPUSH
49125: LD_VAR 0 2
49129: PUSH
49130: LD_EXP 106
49134: PUSH
49135: LD_VAR 0 2
49139: ARRAY
49140: PUSH
49141: LD_INT 1
49143: PLUS
49144: PUSH
49145: EMPTY
49146: LIST
49147: LIST
49148: PPUSH
49149: LD_VAR 0 3
49153: PPUSH
49154: CALL 73519 0 3
49158: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49159: LD_VAR 0 3
49163: PPUSH
49164: CALL_OW 310
49168: IFFALSE 49179
// ComExitBuilding ( j ) ;
49170: LD_VAR 0 3
49174: PPUSH
49175: CALL_OW 122
// wait ( 3 ) ;
49179: LD_INT 3
49181: PPUSH
49182: CALL_OW 67
// if not mc_build_list [ i ] then
49186: LD_EXP 105
49190: PUSH
49191: LD_VAR 0 2
49195: ARRAY
49196: NOT
49197: IFFALSE 49201
// break ;
49199: GO 49300
// if not HasTask ( j ) then
49201: LD_VAR 0 3
49205: PPUSH
49206: CALL_OW 314
49210: NOT
49211: IFFALSE 49298
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
49213: LD_VAR 0 3
49217: PPUSH
49218: LD_EXP 105
49222: PUSH
49223: LD_VAR 0 2
49227: ARRAY
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PUSH
49233: LD_INT 1
49235: ARRAY
49236: PPUSH
49237: LD_EXP 105
49241: PUSH
49242: LD_VAR 0 2
49246: ARRAY
49247: PUSH
49248: LD_INT 1
49250: ARRAY
49251: PUSH
49252: LD_INT 2
49254: ARRAY
49255: PPUSH
49256: LD_EXP 105
49260: PUSH
49261: LD_VAR 0 2
49265: ARRAY
49266: PUSH
49267: LD_INT 1
49269: ARRAY
49270: PUSH
49271: LD_INT 3
49273: ARRAY
49274: PPUSH
49275: LD_EXP 105
49279: PUSH
49280: LD_VAR 0 2
49284: ARRAY
49285: PUSH
49286: LD_INT 1
49288: ARRAY
49289: PUSH
49290: LD_INT 4
49292: ARRAY
49293: PPUSH
49294: CALL_OW 145
// end ;
49298: GO 49087
49300: POP
49301: POP
// end else
49302: GO 49474
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
49304: LD_EXP 100
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: PPUSH
49315: LD_EXP 105
49319: PUSH
49320: LD_VAR 0 2
49324: ARRAY
49325: PUSH
49326: LD_INT 1
49328: ARRAY
49329: PUSH
49330: LD_INT 1
49332: ARRAY
49333: PPUSH
49334: LD_EXP 105
49338: PUSH
49339: LD_VAR 0 2
49343: ARRAY
49344: PUSH
49345: LD_INT 1
49347: ARRAY
49348: PUSH
49349: LD_INT 2
49351: ARRAY
49352: PPUSH
49353: LD_EXP 105
49357: PUSH
49358: LD_VAR 0 2
49362: ARRAY
49363: PUSH
49364: LD_INT 1
49366: ARRAY
49367: PUSH
49368: LD_INT 3
49370: ARRAY
49371: PPUSH
49372: LD_EXP 105
49376: PUSH
49377: LD_VAR 0 2
49381: ARRAY
49382: PUSH
49383: LD_INT 1
49385: ARRAY
49386: PUSH
49387: LD_INT 4
49389: ARRAY
49390: PPUSH
49391: LD_EXP 100
49395: PUSH
49396: LD_VAR 0 2
49400: ARRAY
49401: PPUSH
49402: LD_INT 21
49404: PUSH
49405: LD_INT 3
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PPUSH
49412: CALL_OW 72
49416: PPUSH
49417: EMPTY
49418: PPUSH
49419: CALL 80370 0 7
49423: NOT
49424: IFFALSE 49474
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
49426: LD_ADDR_EXP 105
49430: PUSH
49431: LD_EXP 105
49435: PPUSH
49436: LD_VAR 0 2
49440: PPUSH
49441: LD_EXP 105
49445: PUSH
49446: LD_VAR 0 2
49450: ARRAY
49451: PPUSH
49452: LD_INT 1
49454: PPUSH
49455: LD_INT 1
49457: NEG
49458: PPUSH
49459: LD_INT 0
49461: PPUSH
49462: CALL 72937 0 4
49466: PPUSH
49467: CALL_OW 1
49471: ST_TO_ADDR
// continue ;
49472: GO 48905
// end ; end ;
49474: GO 48905
49476: POP
49477: POP
// end ; end ;
49478: GO 48334
49480: POP
49481: POP
// end ;
49482: LD_VAR 0 1
49486: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
49487: LD_INT 0
49489: PPUSH
49490: PPUSH
49491: PPUSH
49492: PPUSH
49493: PPUSH
49494: PPUSH
// if not mc_bases then
49495: LD_EXP 100
49499: NOT
49500: IFFALSE 49504
// exit ;
49502: GO 49931
// for i = 1 to mc_bases do
49504: LD_ADDR_VAR 0 2
49508: PUSH
49509: DOUBLE
49510: LD_INT 1
49512: DEC
49513: ST_TO_ADDR
49514: LD_EXP 100
49518: PUSH
49519: FOR_TO
49520: IFFALSE 49929
// begin tmp := mc_build_upgrade [ i ] ;
49522: LD_ADDR_VAR 0 4
49526: PUSH
49527: LD_EXP 132
49531: PUSH
49532: LD_VAR 0 2
49536: ARRAY
49537: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
49538: LD_ADDR_VAR 0 6
49542: PUSH
49543: LD_EXP 133
49547: PUSH
49548: LD_VAR 0 2
49552: ARRAY
49553: PPUSH
49554: LD_INT 2
49556: PUSH
49557: LD_INT 30
49559: PUSH
49560: LD_INT 6
49562: PUSH
49563: EMPTY
49564: LIST
49565: LIST
49566: PUSH
49567: LD_INT 30
49569: PUSH
49570: LD_INT 7
49572: PUSH
49573: EMPTY
49574: LIST
49575: LIST
49576: PUSH
49577: EMPTY
49578: LIST
49579: LIST
49580: LIST
49581: PPUSH
49582: CALL_OW 72
49586: ST_TO_ADDR
// if not tmp and not lab then
49587: LD_VAR 0 4
49591: NOT
49592: PUSH
49593: LD_VAR 0 6
49597: NOT
49598: AND
49599: IFFALSE 49603
// continue ;
49601: GO 49519
// if tmp then
49603: LD_VAR 0 4
49607: IFFALSE 49727
// for j in tmp do
49609: LD_ADDR_VAR 0 3
49613: PUSH
49614: LD_VAR 0 4
49618: PUSH
49619: FOR_IN
49620: IFFALSE 49725
// begin if UpgradeCost ( j ) then
49622: LD_VAR 0 3
49626: PPUSH
49627: CALL 80030 0 1
49631: IFFALSE 49723
// begin ComUpgrade ( j ) ;
49633: LD_VAR 0 3
49637: PPUSH
49638: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
49642: LD_ADDR_EXP 132
49646: PUSH
49647: LD_EXP 132
49651: PPUSH
49652: LD_VAR 0 2
49656: PPUSH
49657: LD_EXP 132
49661: PUSH
49662: LD_VAR 0 2
49666: ARRAY
49667: PUSH
49668: LD_VAR 0 3
49672: DIFF
49673: PPUSH
49674: CALL_OW 1
49678: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
49679: LD_ADDR_EXP 107
49683: PUSH
49684: LD_EXP 107
49688: PPUSH
49689: LD_VAR 0 2
49693: PUSH
49694: LD_EXP 107
49698: PUSH
49699: LD_VAR 0 2
49703: ARRAY
49704: PUSH
49705: LD_INT 1
49707: PLUS
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PPUSH
49713: LD_VAR 0 3
49717: PPUSH
49718: CALL 73519 0 3
49722: ST_TO_ADDR
// end ; end ;
49723: GO 49619
49725: POP
49726: POP
// if not lab or not mc_lab_upgrade [ i ] then
49727: LD_VAR 0 6
49731: NOT
49732: PUSH
49733: LD_EXP 134
49737: PUSH
49738: LD_VAR 0 2
49742: ARRAY
49743: NOT
49744: OR
49745: IFFALSE 49749
// continue ;
49747: GO 49519
// for j in lab do
49749: LD_ADDR_VAR 0 3
49753: PUSH
49754: LD_VAR 0 6
49758: PUSH
49759: FOR_IN
49760: IFFALSE 49925
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
49762: LD_VAR 0 3
49766: PPUSH
49767: CALL_OW 266
49771: PUSH
49772: LD_INT 6
49774: PUSH
49775: LD_INT 7
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: IN
49782: PUSH
49783: LD_VAR 0 3
49787: PPUSH
49788: CALL_OW 461
49792: PUSH
49793: LD_INT 1
49795: NONEQUAL
49796: AND
49797: IFFALSE 49923
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
49799: LD_VAR 0 3
49803: PPUSH
49804: LD_EXP 134
49808: PUSH
49809: LD_VAR 0 2
49813: ARRAY
49814: PUSH
49815: LD_INT 1
49817: ARRAY
49818: PPUSH
49819: CALL 80235 0 2
49823: IFFALSE 49923
// begin ComCancel ( j ) ;
49825: LD_VAR 0 3
49829: PPUSH
49830: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
49834: LD_VAR 0 3
49838: PPUSH
49839: LD_EXP 134
49843: PUSH
49844: LD_VAR 0 2
49848: ARRAY
49849: PUSH
49850: LD_INT 1
49852: ARRAY
49853: PPUSH
49854: CALL_OW 207
// if not j in mc_construct_list [ i ] then
49858: LD_VAR 0 3
49862: PUSH
49863: LD_EXP 107
49867: PUSH
49868: LD_VAR 0 2
49872: ARRAY
49873: IN
49874: NOT
49875: IFFALSE 49921
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
49877: LD_ADDR_EXP 107
49881: PUSH
49882: LD_EXP 107
49886: PPUSH
49887: LD_VAR 0 2
49891: PUSH
49892: LD_EXP 107
49896: PUSH
49897: LD_VAR 0 2
49901: ARRAY
49902: PUSH
49903: LD_INT 1
49905: PLUS
49906: PUSH
49907: EMPTY
49908: LIST
49909: LIST
49910: PPUSH
49911: LD_VAR 0 3
49915: PPUSH
49916: CALL 73519 0 3
49920: ST_TO_ADDR
// break ;
49921: GO 49925
// end ; end ; end ;
49923: GO 49759
49925: POP
49926: POP
// end ;
49927: GO 49519
49929: POP
49930: POP
// end ;
49931: LD_VAR 0 1
49935: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
49936: LD_INT 0
49938: PPUSH
49939: PPUSH
49940: PPUSH
49941: PPUSH
49942: PPUSH
49943: PPUSH
49944: PPUSH
49945: PPUSH
49946: PPUSH
// if not mc_bases then
49947: LD_EXP 100
49951: NOT
49952: IFFALSE 49956
// exit ;
49954: GO 50361
// for i = 1 to mc_bases do
49956: LD_ADDR_VAR 0 2
49960: PUSH
49961: DOUBLE
49962: LD_INT 1
49964: DEC
49965: ST_TO_ADDR
49966: LD_EXP 100
49970: PUSH
49971: FOR_TO
49972: IFFALSE 50359
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
49974: LD_EXP 108
49978: PUSH
49979: LD_VAR 0 2
49983: ARRAY
49984: NOT
49985: PUSH
49986: LD_EXP 100
49990: PUSH
49991: LD_VAR 0 2
49995: ARRAY
49996: PPUSH
49997: LD_INT 30
49999: PUSH
50000: LD_INT 3
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PPUSH
50007: CALL_OW 72
50011: NOT
50012: OR
50013: IFFALSE 50017
// continue ;
50015: GO 49971
// busy := false ;
50017: LD_ADDR_VAR 0 8
50021: PUSH
50022: LD_INT 0
50024: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50025: LD_ADDR_VAR 0 4
50029: PUSH
50030: LD_EXP 100
50034: PUSH
50035: LD_VAR 0 2
50039: ARRAY
50040: PPUSH
50041: LD_INT 30
50043: PUSH
50044: LD_INT 3
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PPUSH
50051: CALL_OW 72
50055: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50056: LD_ADDR_VAR 0 6
50060: PUSH
50061: LD_EXP 108
50065: PUSH
50066: LD_VAR 0 2
50070: ARRAY
50071: PPUSH
50072: LD_INT 2
50074: PUSH
50075: LD_INT 30
50077: PUSH
50078: LD_INT 32
50080: PUSH
50081: EMPTY
50082: LIST
50083: LIST
50084: PUSH
50085: LD_INT 30
50087: PUSH
50088: LD_INT 33
50090: PUSH
50091: EMPTY
50092: LIST
50093: LIST
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: LIST
50099: PPUSH
50100: CALL_OW 72
50104: ST_TO_ADDR
// if not t then
50105: LD_VAR 0 6
50109: NOT
50110: IFFALSE 50114
// continue ;
50112: GO 49971
// for j in tmp do
50114: LD_ADDR_VAR 0 3
50118: PUSH
50119: LD_VAR 0 4
50123: PUSH
50124: FOR_IN
50125: IFFALSE 50155
// if not BuildingStatus ( j ) = bs_idle then
50127: LD_VAR 0 3
50131: PPUSH
50132: CALL_OW 461
50136: PUSH
50137: LD_INT 2
50139: EQUAL
50140: NOT
50141: IFFALSE 50153
// begin busy := true ;
50143: LD_ADDR_VAR 0 8
50147: PUSH
50148: LD_INT 1
50150: ST_TO_ADDR
// break ;
50151: GO 50155
// end ;
50153: GO 50124
50155: POP
50156: POP
// if busy then
50157: LD_VAR 0 8
50161: IFFALSE 50165
// continue ;
50163: GO 49971
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
50165: LD_ADDR_VAR 0 7
50169: PUSH
50170: LD_VAR 0 6
50174: PPUSH
50175: LD_INT 35
50177: PUSH
50178: LD_INT 0
50180: PUSH
50181: EMPTY
50182: LIST
50183: LIST
50184: PPUSH
50185: CALL_OW 72
50189: ST_TO_ADDR
// if tw then
50190: LD_VAR 0 7
50194: IFFALSE 50271
// begin tw := tw [ 1 ] ;
50196: LD_ADDR_VAR 0 7
50200: PUSH
50201: LD_VAR 0 7
50205: PUSH
50206: LD_INT 1
50208: ARRAY
50209: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
50210: LD_ADDR_VAR 0 9
50214: PUSH
50215: LD_VAR 0 7
50219: PPUSH
50220: LD_EXP 125
50224: PUSH
50225: LD_VAR 0 2
50229: ARRAY
50230: PPUSH
50231: CALL 78527 0 2
50235: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
50236: LD_EXP 139
50240: PUSH
50241: LD_VAR 0 2
50245: ARRAY
50246: IFFALSE 50269
// if not weapon in mc_allowed_tower_weapons [ i ] then
50248: LD_VAR 0 9
50252: PUSH
50253: LD_EXP 139
50257: PUSH
50258: LD_VAR 0 2
50262: ARRAY
50263: IN
50264: NOT
50265: IFFALSE 50269
// continue ;
50267: GO 49971
// end else
50269: GO 50334
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
50271: LD_ADDR_VAR 0 5
50275: PUSH
50276: LD_EXP 108
50280: PUSH
50281: LD_VAR 0 2
50285: ARRAY
50286: PPUSH
50287: LD_VAR 0 4
50291: PPUSH
50292: CALL 105397 0 2
50296: ST_TO_ADDR
// if not tmp2 then
50297: LD_VAR 0 5
50301: NOT
50302: IFFALSE 50306
// continue ;
50304: GO 49971
// tw := tmp2 [ 1 ] ;
50306: LD_ADDR_VAR 0 7
50310: PUSH
50311: LD_VAR 0 5
50315: PUSH
50316: LD_INT 1
50318: ARRAY
50319: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
50320: LD_ADDR_VAR 0 9
50324: PUSH
50325: LD_VAR 0 5
50329: PUSH
50330: LD_INT 2
50332: ARRAY
50333: ST_TO_ADDR
// end ; if not weapon then
50334: LD_VAR 0 9
50338: NOT
50339: IFFALSE 50343
// continue ;
50341: GO 49971
// ComPlaceWeapon ( tw , weapon ) ;
50343: LD_VAR 0 7
50347: PPUSH
50348: LD_VAR 0 9
50352: PPUSH
50353: CALL_OW 148
// end ;
50357: GO 49971
50359: POP
50360: POP
// end ;
50361: LD_VAR 0 1
50365: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
50366: LD_INT 0
50368: PPUSH
50369: PPUSH
50370: PPUSH
50371: PPUSH
50372: PPUSH
50373: PPUSH
50374: PPUSH
// if not mc_bases then
50375: LD_EXP 100
50379: NOT
50380: IFFALSE 50384
// exit ;
50382: GO 51159
// for i = 1 to mc_bases do
50384: LD_ADDR_VAR 0 2
50388: PUSH
50389: DOUBLE
50390: LD_INT 1
50392: DEC
50393: ST_TO_ADDR
50394: LD_EXP 100
50398: PUSH
50399: FOR_TO
50400: IFFALSE 51157
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
50402: LD_EXP 113
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: NOT
50413: PUSH
50414: LD_EXP 113
50418: PUSH
50419: LD_VAR 0 2
50423: ARRAY
50424: PUSH
50425: LD_EXP 114
50429: PUSH
50430: LD_VAR 0 2
50434: ARRAY
50435: EQUAL
50436: OR
50437: PUSH
50438: LD_EXP 123
50442: PUSH
50443: LD_VAR 0 2
50447: ARRAY
50448: OR
50449: IFFALSE 50453
// continue ;
50451: GO 50399
// if mc_miners [ i ] then
50453: LD_EXP 114
50457: PUSH
50458: LD_VAR 0 2
50462: ARRAY
50463: IFFALSE 50844
// begin for j = mc_miners [ i ] downto 1 do
50465: LD_ADDR_VAR 0 3
50469: PUSH
50470: DOUBLE
50471: LD_EXP 114
50475: PUSH
50476: LD_VAR 0 2
50480: ARRAY
50481: INC
50482: ST_TO_ADDR
50483: LD_INT 1
50485: PUSH
50486: FOR_DOWNTO
50487: IFFALSE 50842
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
50489: LD_EXP 114
50493: PUSH
50494: LD_VAR 0 2
50498: ARRAY
50499: PUSH
50500: LD_VAR 0 3
50504: ARRAY
50505: PPUSH
50506: CALL_OW 301
50510: PUSH
50511: LD_EXP 114
50515: PUSH
50516: LD_VAR 0 2
50520: ARRAY
50521: PUSH
50522: LD_VAR 0 3
50526: ARRAY
50527: PPUSH
50528: CALL_OW 257
50532: PUSH
50533: LD_INT 1
50535: NONEQUAL
50536: OR
50537: IFFALSE 50600
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
50539: LD_ADDR_VAR 0 5
50543: PUSH
50544: LD_EXP 114
50548: PUSH
50549: LD_VAR 0 2
50553: ARRAY
50554: PUSH
50555: LD_EXP 114
50559: PUSH
50560: LD_VAR 0 2
50564: ARRAY
50565: PUSH
50566: LD_VAR 0 3
50570: ARRAY
50571: DIFF
50572: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
50573: LD_ADDR_EXP 114
50577: PUSH
50578: LD_EXP 114
50582: PPUSH
50583: LD_VAR 0 2
50587: PPUSH
50588: LD_VAR 0 5
50592: PPUSH
50593: CALL_OW 1
50597: ST_TO_ADDR
// continue ;
50598: GO 50486
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
50600: LD_EXP 114
50604: PUSH
50605: LD_VAR 0 2
50609: ARRAY
50610: PUSH
50611: LD_VAR 0 3
50615: ARRAY
50616: PPUSH
50617: CALL_OW 257
50621: PUSH
50622: LD_INT 1
50624: EQUAL
50625: PUSH
50626: LD_EXP 114
50630: PUSH
50631: LD_VAR 0 2
50635: ARRAY
50636: PUSH
50637: LD_VAR 0 3
50641: ARRAY
50642: PPUSH
50643: CALL_OW 459
50647: NOT
50648: AND
50649: PUSH
50650: LD_EXP 114
50654: PUSH
50655: LD_VAR 0 2
50659: ARRAY
50660: PUSH
50661: LD_VAR 0 3
50665: ARRAY
50666: PPUSH
50667: CALL_OW 314
50671: NOT
50672: AND
50673: IFFALSE 50840
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
50675: LD_EXP 114
50679: PUSH
50680: LD_VAR 0 2
50684: ARRAY
50685: PUSH
50686: LD_VAR 0 3
50690: ARRAY
50691: PPUSH
50692: CALL_OW 310
50696: IFFALSE 50719
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
50698: LD_EXP 114
50702: PUSH
50703: LD_VAR 0 2
50707: ARRAY
50708: PUSH
50709: LD_VAR 0 3
50713: ARRAY
50714: PPUSH
50715: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
50719: LD_EXP 114
50723: PUSH
50724: LD_VAR 0 2
50728: ARRAY
50729: PUSH
50730: LD_VAR 0 3
50734: ARRAY
50735: PPUSH
50736: CALL_OW 314
50740: NOT
50741: IFFALSE 50840
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
50743: LD_ADDR_VAR 0 7
50747: PUSH
50748: LD_VAR 0 3
50752: PUSH
50753: LD_EXP 113
50757: PUSH
50758: LD_VAR 0 2
50762: ARRAY
50763: PPUSH
50764: CALL 70659 0 1
50768: MOD
50769: PUSH
50770: LD_INT 1
50772: PLUS
50773: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
50774: LD_EXP 114
50778: PUSH
50779: LD_VAR 0 2
50783: ARRAY
50784: PUSH
50785: LD_VAR 0 3
50789: ARRAY
50790: PPUSH
50791: LD_EXP 113
50795: PUSH
50796: LD_VAR 0 2
50800: ARRAY
50801: PUSH
50802: LD_VAR 0 7
50806: ARRAY
50807: PUSH
50808: LD_INT 1
50810: ARRAY
50811: PPUSH
50812: LD_EXP 113
50816: PUSH
50817: LD_VAR 0 2
50821: ARRAY
50822: PUSH
50823: LD_VAR 0 7
50827: ARRAY
50828: PUSH
50829: LD_INT 2
50831: ARRAY
50832: PPUSH
50833: LD_INT 0
50835: PPUSH
50836: CALL_OW 193
// end ; end ; end ;
50840: GO 50486
50842: POP
50843: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
50844: LD_ADDR_VAR 0 5
50848: PUSH
50849: LD_EXP 100
50853: PUSH
50854: LD_VAR 0 2
50858: ARRAY
50859: PPUSH
50860: LD_INT 2
50862: PUSH
50863: LD_INT 30
50865: PUSH
50866: LD_INT 4
50868: PUSH
50869: EMPTY
50870: LIST
50871: LIST
50872: PUSH
50873: LD_INT 30
50875: PUSH
50876: LD_INT 5
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: PUSH
50883: LD_INT 30
50885: PUSH
50886: LD_INT 32
50888: PUSH
50889: EMPTY
50890: LIST
50891: LIST
50892: PUSH
50893: EMPTY
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: PPUSH
50899: CALL_OW 72
50903: ST_TO_ADDR
// if not tmp then
50904: LD_VAR 0 5
50908: NOT
50909: IFFALSE 50913
// continue ;
50911: GO 50399
// list := [ ] ;
50913: LD_ADDR_VAR 0 6
50917: PUSH
50918: EMPTY
50919: ST_TO_ADDR
// for j in tmp do
50920: LD_ADDR_VAR 0 3
50924: PUSH
50925: LD_VAR 0 5
50929: PUSH
50930: FOR_IN
50931: IFFALSE 51000
// begin for k in UnitsInside ( j ) do
50933: LD_ADDR_VAR 0 4
50937: PUSH
50938: LD_VAR 0 3
50942: PPUSH
50943: CALL_OW 313
50947: PUSH
50948: FOR_IN
50949: IFFALSE 50996
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
50951: LD_VAR 0 4
50955: PPUSH
50956: CALL_OW 257
50960: PUSH
50961: LD_INT 1
50963: EQUAL
50964: PUSH
50965: LD_VAR 0 4
50969: PPUSH
50970: CALL_OW 459
50974: NOT
50975: AND
50976: IFFALSE 50994
// list := list ^ k ;
50978: LD_ADDR_VAR 0 6
50982: PUSH
50983: LD_VAR 0 6
50987: PUSH
50988: LD_VAR 0 4
50992: ADD
50993: ST_TO_ADDR
50994: GO 50948
50996: POP
50997: POP
// end ;
50998: GO 50930
51000: POP
51001: POP
// list := list diff mc_miners [ i ] ;
51002: LD_ADDR_VAR 0 6
51006: PUSH
51007: LD_VAR 0 6
51011: PUSH
51012: LD_EXP 114
51016: PUSH
51017: LD_VAR 0 2
51021: ARRAY
51022: DIFF
51023: ST_TO_ADDR
// if not list then
51024: LD_VAR 0 6
51028: NOT
51029: IFFALSE 51033
// continue ;
51031: GO 50399
// k := mc_mines [ i ] - mc_miners [ i ] ;
51033: LD_ADDR_VAR 0 4
51037: PUSH
51038: LD_EXP 113
51042: PUSH
51043: LD_VAR 0 2
51047: ARRAY
51048: PUSH
51049: LD_EXP 114
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: MINUS
51060: ST_TO_ADDR
// if k > list then
51061: LD_VAR 0 4
51065: PUSH
51066: LD_VAR 0 6
51070: GREATER
51071: IFFALSE 51083
// k := list ;
51073: LD_ADDR_VAR 0 4
51077: PUSH
51078: LD_VAR 0 6
51082: ST_TO_ADDR
// for j = 1 to k do
51083: LD_ADDR_VAR 0 3
51087: PUSH
51088: DOUBLE
51089: LD_INT 1
51091: DEC
51092: ST_TO_ADDR
51093: LD_VAR 0 4
51097: PUSH
51098: FOR_TO
51099: IFFALSE 51153
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51101: LD_ADDR_EXP 114
51105: PUSH
51106: LD_EXP 114
51110: PPUSH
51111: LD_VAR 0 2
51115: PUSH
51116: LD_EXP 114
51120: PUSH
51121: LD_VAR 0 2
51125: ARRAY
51126: PUSH
51127: LD_INT 1
51129: PLUS
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PPUSH
51135: LD_VAR 0 6
51139: PUSH
51140: LD_VAR 0 3
51144: ARRAY
51145: PPUSH
51146: CALL 73519 0 3
51150: ST_TO_ADDR
51151: GO 51098
51153: POP
51154: POP
// end ;
51155: GO 50399
51157: POP
51158: POP
// end ;
51159: LD_VAR 0 1
51163: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
51164: LD_INT 0
51166: PPUSH
51167: PPUSH
51168: PPUSH
51169: PPUSH
51170: PPUSH
51171: PPUSH
51172: PPUSH
51173: PPUSH
51174: PPUSH
51175: PPUSH
51176: PPUSH
// if not mc_bases then
51177: LD_EXP 100
51181: NOT
51182: IFFALSE 51186
// exit ;
51184: GO 53009
// for i = 1 to mc_bases do
51186: LD_ADDR_VAR 0 2
51190: PUSH
51191: DOUBLE
51192: LD_INT 1
51194: DEC
51195: ST_TO_ADDR
51196: LD_EXP 100
51200: PUSH
51201: FOR_TO
51202: IFFALSE 53007
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
51204: LD_EXP 100
51208: PUSH
51209: LD_VAR 0 2
51213: ARRAY
51214: NOT
51215: PUSH
51216: LD_EXP 107
51220: PUSH
51221: LD_VAR 0 2
51225: ARRAY
51226: OR
51227: IFFALSE 51231
// continue ;
51229: GO 51201
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
51231: LD_EXP 116
51235: PUSH
51236: LD_VAR 0 2
51240: ARRAY
51241: NOT
51242: PUSH
51243: LD_EXP 117
51247: PUSH
51248: LD_VAR 0 2
51252: ARRAY
51253: AND
51254: IFFALSE 51292
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51256: LD_ADDR_EXP 117
51260: PUSH
51261: LD_EXP 117
51265: PPUSH
51266: LD_VAR 0 2
51270: PPUSH
51271: EMPTY
51272: PPUSH
51273: CALL_OW 1
51277: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
51278: LD_VAR 0 2
51282: PPUSH
51283: LD_INT 107
51285: PPUSH
51286: CALL 42032 0 2
// continue ;
51290: GO 51201
// end ; target := [ ] ;
51292: LD_ADDR_VAR 0 7
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51299: LD_ADDR_VAR 0 6
51303: PUSH
51304: LD_EXP 100
51308: PUSH
51309: LD_VAR 0 2
51313: ARRAY
51314: PUSH
51315: LD_INT 1
51317: ARRAY
51318: PPUSH
51319: CALL_OW 255
51323: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51324: LD_ADDR_VAR 0 9
51328: PUSH
51329: LD_EXP 100
51333: PUSH
51334: LD_VAR 0 2
51338: ARRAY
51339: PPUSH
51340: LD_INT 2
51342: PUSH
51343: LD_INT 30
51345: PUSH
51346: LD_INT 0
51348: PUSH
51349: EMPTY
51350: LIST
51351: LIST
51352: PUSH
51353: LD_INT 30
51355: PUSH
51356: LD_INT 1
51358: PUSH
51359: EMPTY
51360: LIST
51361: LIST
51362: PUSH
51363: EMPTY
51364: LIST
51365: LIST
51366: LIST
51367: PPUSH
51368: CALL_OW 72
51372: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
51373: LD_ADDR_VAR 0 3
51377: PUSH
51378: DOUBLE
51379: LD_EXP 116
51383: PUSH
51384: LD_VAR 0 2
51388: ARRAY
51389: INC
51390: ST_TO_ADDR
51391: LD_INT 1
51393: PUSH
51394: FOR_DOWNTO
51395: IFFALSE 51640
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
51397: LD_EXP 116
51401: PUSH
51402: LD_VAR 0 2
51406: ARRAY
51407: PUSH
51408: LD_VAR 0 3
51412: ARRAY
51413: PUSH
51414: LD_INT 2
51416: ARRAY
51417: PPUSH
51418: LD_EXP 116
51422: PUSH
51423: LD_VAR 0 2
51427: ARRAY
51428: PUSH
51429: LD_VAR 0 3
51433: ARRAY
51434: PUSH
51435: LD_INT 3
51437: ARRAY
51438: PPUSH
51439: CALL_OW 488
51443: PUSH
51444: LD_EXP 116
51448: PUSH
51449: LD_VAR 0 2
51453: ARRAY
51454: PUSH
51455: LD_VAR 0 3
51459: ARRAY
51460: PUSH
51461: LD_INT 2
51463: ARRAY
51464: PPUSH
51465: LD_EXP 116
51469: PUSH
51470: LD_VAR 0 2
51474: ARRAY
51475: PUSH
51476: LD_VAR 0 3
51480: ARRAY
51481: PUSH
51482: LD_INT 3
51484: ARRAY
51485: PPUSH
51486: CALL_OW 284
51490: PUSH
51491: LD_INT 0
51493: EQUAL
51494: AND
51495: IFFALSE 51550
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
51497: LD_ADDR_VAR 0 5
51501: PUSH
51502: LD_EXP 116
51506: PUSH
51507: LD_VAR 0 2
51511: ARRAY
51512: PPUSH
51513: LD_VAR 0 3
51517: PPUSH
51518: CALL_OW 3
51522: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
51523: LD_ADDR_EXP 116
51527: PUSH
51528: LD_EXP 116
51532: PPUSH
51533: LD_VAR 0 2
51537: PPUSH
51538: LD_VAR 0 5
51542: PPUSH
51543: CALL_OW 1
51547: ST_TO_ADDR
// continue ;
51548: GO 51394
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
51550: LD_VAR 0 6
51554: PPUSH
51555: LD_EXP 116
51559: PUSH
51560: LD_VAR 0 2
51564: ARRAY
51565: PUSH
51566: LD_VAR 0 3
51570: ARRAY
51571: PUSH
51572: LD_INT 2
51574: ARRAY
51575: PPUSH
51576: LD_EXP 116
51580: PUSH
51581: LD_VAR 0 2
51585: ARRAY
51586: PUSH
51587: LD_VAR 0 3
51591: ARRAY
51592: PUSH
51593: LD_INT 3
51595: ARRAY
51596: PPUSH
51597: LD_INT 30
51599: PPUSH
51600: CALL 74415 0 4
51604: PUSH
51605: LD_INT 4
51607: ARRAY
51608: PUSH
51609: LD_INT 0
51611: EQUAL
51612: IFFALSE 51638
// begin target := mc_crates [ i ] [ j ] ;
51614: LD_ADDR_VAR 0 7
51618: PUSH
51619: LD_EXP 116
51623: PUSH
51624: LD_VAR 0 2
51628: ARRAY
51629: PUSH
51630: LD_VAR 0 3
51634: ARRAY
51635: ST_TO_ADDR
// break ;
51636: GO 51640
// end ; end ;
51638: GO 51394
51640: POP
51641: POP
// if not target then
51642: LD_VAR 0 7
51646: NOT
51647: IFFALSE 51651
// continue ;
51649: GO 51201
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
51651: LD_ADDR_VAR 0 8
51655: PUSH
51656: LD_EXP 119
51660: PUSH
51661: LD_VAR 0 2
51665: ARRAY
51666: PPUSH
51667: LD_INT 2
51669: PUSH
51670: LD_INT 3
51672: PUSH
51673: LD_INT 58
51675: PUSH
51676: EMPTY
51677: LIST
51678: PUSH
51679: EMPTY
51680: LIST
51681: LIST
51682: PUSH
51683: LD_INT 61
51685: PUSH
51686: EMPTY
51687: LIST
51688: PUSH
51689: LD_INT 33
51691: PUSH
51692: LD_INT 5
51694: PUSH
51695: EMPTY
51696: LIST
51697: LIST
51698: PUSH
51699: LD_INT 33
51701: PUSH
51702: LD_INT 3
51704: PUSH
51705: EMPTY
51706: LIST
51707: LIST
51708: PUSH
51709: EMPTY
51710: LIST
51711: LIST
51712: LIST
51713: LIST
51714: LIST
51715: PUSH
51716: LD_INT 2
51718: PUSH
51719: LD_INT 34
51721: PUSH
51722: LD_INT 32
51724: PUSH
51725: EMPTY
51726: LIST
51727: LIST
51728: PUSH
51729: LD_INT 34
51731: PUSH
51732: LD_INT 51
51734: PUSH
51735: EMPTY
51736: LIST
51737: LIST
51738: PUSH
51739: LD_INT 34
51741: PUSH
51742: LD_INT 12
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: PUSH
51749: EMPTY
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: PUSH
51755: EMPTY
51756: LIST
51757: LIST
51758: PPUSH
51759: CALL_OW 72
51763: ST_TO_ADDR
// if not cargo then
51764: LD_VAR 0 8
51768: NOT
51769: IFFALSE 52475
// begin if mc_crates_collector [ i ] < 5 then
51771: LD_EXP 117
51775: PUSH
51776: LD_VAR 0 2
51780: ARRAY
51781: PUSH
51782: LD_INT 5
51784: LESS
51785: IFFALSE 52151
// begin if mc_ape [ i ] then
51787: LD_EXP 129
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: IFFALSE 51844
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
51799: LD_ADDR_VAR 0 5
51803: PUSH
51804: LD_EXP 129
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PPUSH
51815: LD_INT 25
51817: PUSH
51818: LD_INT 16
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: PUSH
51825: LD_INT 24
51827: PUSH
51828: LD_INT 750
51830: PUSH
51831: EMPTY
51832: LIST
51833: LIST
51834: PUSH
51835: EMPTY
51836: LIST
51837: LIST
51838: PPUSH
51839: CALL_OW 72
51843: ST_TO_ADDR
// if not tmp then
51844: LD_VAR 0 5
51848: NOT
51849: IFFALSE 51896
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
51851: LD_ADDR_VAR 0 5
51855: PUSH
51856: LD_EXP 100
51860: PUSH
51861: LD_VAR 0 2
51865: ARRAY
51866: PPUSH
51867: LD_INT 25
51869: PUSH
51870: LD_INT 2
51872: PUSH
51873: EMPTY
51874: LIST
51875: LIST
51876: PUSH
51877: LD_INT 24
51879: PUSH
51880: LD_INT 750
51882: PUSH
51883: EMPTY
51884: LIST
51885: LIST
51886: PUSH
51887: EMPTY
51888: LIST
51889: LIST
51890: PPUSH
51891: CALL_OW 72
51895: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
51896: LD_EXP 129
51900: PUSH
51901: LD_VAR 0 2
51905: ARRAY
51906: PUSH
51907: LD_EXP 100
51911: PUSH
51912: LD_VAR 0 2
51916: ARRAY
51917: PPUSH
51918: LD_INT 25
51920: PUSH
51921: LD_INT 2
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PUSH
51928: LD_INT 24
51930: PUSH
51931: LD_INT 750
51933: PUSH
51934: EMPTY
51935: LIST
51936: LIST
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: PPUSH
51942: CALL_OW 72
51946: AND
51947: PUSH
51948: LD_VAR 0 5
51952: PUSH
51953: LD_INT 5
51955: LESS
51956: AND
51957: IFFALSE 52039
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
51959: LD_ADDR_VAR 0 3
51963: PUSH
51964: LD_EXP 100
51968: PUSH
51969: LD_VAR 0 2
51973: ARRAY
51974: PPUSH
51975: LD_INT 25
51977: PUSH
51978: LD_INT 2
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: PUSH
51985: LD_INT 24
51987: PUSH
51988: LD_INT 750
51990: PUSH
51991: EMPTY
51992: LIST
51993: LIST
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PPUSH
51999: CALL_OW 72
52003: PUSH
52004: FOR_IN
52005: IFFALSE 52037
// begin tmp := tmp union j ;
52007: LD_ADDR_VAR 0 5
52011: PUSH
52012: LD_VAR 0 5
52016: PUSH
52017: LD_VAR 0 3
52021: UNION
52022: ST_TO_ADDR
// if tmp >= 5 then
52023: LD_VAR 0 5
52027: PUSH
52028: LD_INT 5
52030: GREATEREQUAL
52031: IFFALSE 52035
// break ;
52033: GO 52037
// end ;
52035: GO 52004
52037: POP
52038: POP
// end ; if not tmp then
52039: LD_VAR 0 5
52043: NOT
52044: IFFALSE 52048
// continue ;
52046: GO 51201
// for j in tmp do
52048: LD_ADDR_VAR 0 3
52052: PUSH
52053: LD_VAR 0 5
52057: PUSH
52058: FOR_IN
52059: IFFALSE 52149
// if not GetTag ( j ) then
52061: LD_VAR 0 3
52065: PPUSH
52066: CALL_OW 110
52070: NOT
52071: IFFALSE 52147
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52073: LD_ADDR_EXP 117
52077: PUSH
52078: LD_EXP 117
52082: PPUSH
52083: LD_VAR 0 2
52087: PUSH
52088: LD_EXP 117
52092: PUSH
52093: LD_VAR 0 2
52097: ARRAY
52098: PUSH
52099: LD_INT 1
52101: PLUS
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PPUSH
52107: LD_VAR 0 3
52111: PPUSH
52112: CALL 73519 0 3
52116: ST_TO_ADDR
// SetTag ( j , 107 ) ;
52117: LD_VAR 0 3
52121: PPUSH
52122: LD_INT 107
52124: PPUSH
52125: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
52129: LD_EXP 117
52133: PUSH
52134: LD_VAR 0 2
52138: ARRAY
52139: PUSH
52140: LD_INT 5
52142: GREATEREQUAL
52143: IFFALSE 52147
// break ;
52145: GO 52149
// end ;
52147: GO 52058
52149: POP
52150: POP
// end ; if mc_crates_collector [ i ] and target then
52151: LD_EXP 117
52155: PUSH
52156: LD_VAR 0 2
52160: ARRAY
52161: PUSH
52162: LD_VAR 0 7
52166: AND
52167: IFFALSE 52473
// begin if mc_crates_collector [ i ] < target [ 1 ] then
52169: LD_EXP 117
52173: PUSH
52174: LD_VAR 0 2
52178: ARRAY
52179: PUSH
52180: LD_VAR 0 7
52184: PUSH
52185: LD_INT 1
52187: ARRAY
52188: LESS
52189: IFFALSE 52209
// tmp := mc_crates_collector [ i ] else
52191: LD_ADDR_VAR 0 5
52195: PUSH
52196: LD_EXP 117
52200: PUSH
52201: LD_VAR 0 2
52205: ARRAY
52206: ST_TO_ADDR
52207: GO 52223
// tmp := target [ 1 ] ;
52209: LD_ADDR_VAR 0 5
52213: PUSH
52214: LD_VAR 0 7
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: ST_TO_ADDR
// k := 0 ;
52223: LD_ADDR_VAR 0 4
52227: PUSH
52228: LD_INT 0
52230: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
52231: LD_ADDR_VAR 0 3
52235: PUSH
52236: LD_EXP 117
52240: PUSH
52241: LD_VAR 0 2
52245: ARRAY
52246: PUSH
52247: FOR_IN
52248: IFFALSE 52471
// begin k := k + 1 ;
52250: LD_ADDR_VAR 0 4
52254: PUSH
52255: LD_VAR 0 4
52259: PUSH
52260: LD_INT 1
52262: PLUS
52263: ST_TO_ADDR
// if k > tmp then
52264: LD_VAR 0 4
52268: PUSH
52269: LD_VAR 0 5
52273: GREATER
52274: IFFALSE 52278
// break ;
52276: GO 52471
// if not GetClass ( j ) in [ 2 , 16 ] then
52278: LD_VAR 0 3
52282: PPUSH
52283: CALL_OW 257
52287: PUSH
52288: LD_INT 2
52290: PUSH
52291: LD_INT 16
52293: PUSH
52294: EMPTY
52295: LIST
52296: LIST
52297: IN
52298: NOT
52299: IFFALSE 52352
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
52301: LD_ADDR_EXP 117
52305: PUSH
52306: LD_EXP 117
52310: PPUSH
52311: LD_VAR 0 2
52315: PPUSH
52316: LD_EXP 117
52320: PUSH
52321: LD_VAR 0 2
52325: ARRAY
52326: PUSH
52327: LD_VAR 0 3
52331: DIFF
52332: PPUSH
52333: CALL_OW 1
52337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52338: LD_VAR 0 3
52342: PPUSH
52343: LD_INT 0
52345: PPUSH
52346: CALL_OW 109
// continue ;
52350: GO 52247
// end ; if IsInUnit ( j ) then
52352: LD_VAR 0 3
52356: PPUSH
52357: CALL_OW 310
52361: IFFALSE 52372
// ComExitBuilding ( j ) ;
52363: LD_VAR 0 3
52367: PPUSH
52368: CALL_OW 122
// wait ( 3 ) ;
52372: LD_INT 3
52374: PPUSH
52375: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
52379: LD_VAR 0 3
52383: PPUSH
52384: CALL_OW 314
52388: PUSH
52389: LD_VAR 0 6
52393: PPUSH
52394: LD_VAR 0 7
52398: PUSH
52399: LD_INT 2
52401: ARRAY
52402: PPUSH
52403: LD_VAR 0 7
52407: PUSH
52408: LD_INT 3
52410: ARRAY
52411: PPUSH
52412: LD_INT 30
52414: PPUSH
52415: CALL 74415 0 4
52419: PUSH
52420: LD_INT 4
52422: ARRAY
52423: AND
52424: IFFALSE 52442
// ComStandNearbyBuilding ( j , depot ) else
52426: LD_VAR 0 3
52430: PPUSH
52431: LD_VAR 0 9
52435: PPUSH
52436: CALL 70121 0 2
52440: GO 52469
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52442: LD_VAR 0 3
52446: PPUSH
52447: LD_VAR 0 7
52451: PUSH
52452: LD_INT 2
52454: ARRAY
52455: PPUSH
52456: LD_VAR 0 7
52460: PUSH
52461: LD_INT 3
52463: ARRAY
52464: PPUSH
52465: CALL_OW 117
// end ;
52469: GO 52247
52471: POP
52472: POP
// end ; end else
52473: GO 53005
// begin for j in cargo do
52475: LD_ADDR_VAR 0 3
52479: PUSH
52480: LD_VAR 0 8
52484: PUSH
52485: FOR_IN
52486: IFFALSE 53003
// begin if GetTag ( j ) <> 0 then
52488: LD_VAR 0 3
52492: PPUSH
52493: CALL_OW 110
52497: PUSH
52498: LD_INT 0
52500: NONEQUAL
52501: IFFALSE 52505
// continue ;
52503: GO 52485
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
52505: LD_VAR 0 3
52509: PPUSH
52510: CALL_OW 256
52514: PUSH
52515: LD_INT 1000
52517: LESS
52518: PUSH
52519: LD_VAR 0 3
52523: PPUSH
52524: LD_EXP 124
52528: PUSH
52529: LD_VAR 0 2
52533: ARRAY
52534: PPUSH
52535: CALL_OW 308
52539: NOT
52540: AND
52541: IFFALSE 52563
// ComMoveToArea ( j , mc_parking [ i ] ) ;
52543: LD_VAR 0 3
52547: PPUSH
52548: LD_EXP 124
52552: PUSH
52553: LD_VAR 0 2
52557: ARRAY
52558: PPUSH
52559: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
52563: LD_VAR 0 3
52567: PPUSH
52568: CALL_OW 256
52572: PUSH
52573: LD_INT 1000
52575: LESS
52576: PUSH
52577: LD_VAR 0 3
52581: PPUSH
52582: LD_EXP 124
52586: PUSH
52587: LD_VAR 0 2
52591: ARRAY
52592: PPUSH
52593: CALL_OW 308
52597: AND
52598: IFFALSE 52602
// continue ;
52600: GO 52485
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
52602: LD_VAR 0 3
52606: PPUSH
52607: CALL_OW 262
52611: PUSH
52612: LD_INT 2
52614: EQUAL
52615: PUSH
52616: LD_VAR 0 3
52620: PPUSH
52621: CALL_OW 261
52625: PUSH
52626: LD_INT 15
52628: LESS
52629: AND
52630: IFFALSE 52634
// continue ;
52632: GO 52485
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
52634: LD_VAR 0 3
52638: PPUSH
52639: CALL_OW 262
52643: PUSH
52644: LD_INT 1
52646: EQUAL
52647: PUSH
52648: LD_VAR 0 3
52652: PPUSH
52653: CALL_OW 261
52657: PUSH
52658: LD_INT 10
52660: LESS
52661: AND
52662: IFFALSE 52942
// begin if not depot then
52664: LD_VAR 0 9
52668: NOT
52669: IFFALSE 52673
// continue ;
52671: GO 52485
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
52673: LD_VAR 0 3
52677: PPUSH
52678: LD_VAR 0 9
52682: PPUSH
52683: LD_VAR 0 3
52687: PPUSH
52688: CALL_OW 74
52692: PPUSH
52693: CALL_OW 296
52697: PUSH
52698: LD_INT 6
52700: LESS
52701: IFFALSE 52717
// SetFuel ( j , 100 ) else
52703: LD_VAR 0 3
52707: PPUSH
52708: LD_INT 100
52710: PPUSH
52711: CALL_OW 240
52715: GO 52942
// if GetFuel ( j ) = 0 then
52717: LD_VAR 0 3
52721: PPUSH
52722: CALL_OW 261
52726: PUSH
52727: LD_INT 0
52729: EQUAL
52730: IFFALSE 52942
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
52732: LD_ADDR_EXP 119
52736: PUSH
52737: LD_EXP 119
52741: PPUSH
52742: LD_VAR 0 2
52746: PPUSH
52747: LD_EXP 119
52751: PUSH
52752: LD_VAR 0 2
52756: ARRAY
52757: PUSH
52758: LD_VAR 0 3
52762: DIFF
52763: PPUSH
52764: CALL_OW 1
52768: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
52769: LD_VAR 0 3
52773: PPUSH
52774: CALL_OW 263
52778: PUSH
52779: LD_INT 1
52781: EQUAL
52782: IFFALSE 52798
// ComExitVehicle ( IsInUnit ( j ) ) ;
52784: LD_VAR 0 3
52788: PPUSH
52789: CALL_OW 310
52793: PPUSH
52794: CALL_OW 121
// if GetControl ( j ) = control_remote then
52798: LD_VAR 0 3
52802: PPUSH
52803: CALL_OW 263
52807: PUSH
52808: LD_INT 2
52810: EQUAL
52811: IFFALSE 52822
// ComUnlink ( j ) ;
52813: LD_VAR 0 3
52817: PPUSH
52818: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
52822: LD_ADDR_VAR 0 10
52826: PUSH
52827: LD_VAR 0 2
52831: PPUSH
52832: LD_INT 3
52834: PPUSH
52835: CALL 62586 0 2
52839: ST_TO_ADDR
// if fac then
52840: LD_VAR 0 10
52844: IFFALSE 52940
// begin for k in fac do
52846: LD_ADDR_VAR 0 4
52850: PUSH
52851: LD_VAR 0 10
52855: PUSH
52856: FOR_IN
52857: IFFALSE 52938
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
52859: LD_ADDR_VAR 0 11
52863: PUSH
52864: LD_VAR 0 10
52868: PPUSH
52869: LD_VAR 0 3
52873: PPUSH
52874: CALL_OW 265
52878: PPUSH
52879: LD_VAR 0 3
52883: PPUSH
52884: CALL_OW 262
52888: PPUSH
52889: LD_VAR 0 3
52893: PPUSH
52894: CALL_OW 263
52898: PPUSH
52899: LD_VAR 0 3
52903: PPUSH
52904: CALL_OW 264
52908: PPUSH
52909: CALL 71017 0 5
52913: ST_TO_ADDR
// if components then
52914: LD_VAR 0 11
52918: IFFALSE 52936
// begin MC_InsertProduceList ( i , components ) ;
52920: LD_VAR 0 2
52924: PPUSH
52925: LD_VAR 0 11
52929: PPUSH
52930: CALL 62131 0 2
// break ;
52934: GO 52938
// end ; end ;
52936: GO 52856
52938: POP
52939: POP
// end ; continue ;
52940: GO 52485
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
52942: LD_VAR 0 3
52946: PPUSH
52947: LD_INT 1
52949: PPUSH
52950: CALL_OW 289
52954: PUSH
52955: LD_INT 100
52957: LESS
52958: PUSH
52959: LD_VAR 0 3
52963: PPUSH
52964: CALL_OW 314
52968: NOT
52969: AND
52970: IFFALSE 52999
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52972: LD_VAR 0 3
52976: PPUSH
52977: LD_VAR 0 7
52981: PUSH
52982: LD_INT 2
52984: ARRAY
52985: PPUSH
52986: LD_VAR 0 7
52990: PUSH
52991: LD_INT 3
52993: ARRAY
52994: PPUSH
52995: CALL_OW 117
// break ;
52999: GO 53003
// end ;
53001: GO 52485
53003: POP
53004: POP
// end ; end ;
53005: GO 51201
53007: POP
53008: POP
// end ;
53009: LD_VAR 0 1
53013: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53014: LD_INT 0
53016: PPUSH
53017: PPUSH
53018: PPUSH
53019: PPUSH
// if not mc_bases then
53020: LD_EXP 100
53024: NOT
53025: IFFALSE 53029
// exit ;
53027: GO 53190
// for i = 1 to mc_bases do
53029: LD_ADDR_VAR 0 2
53033: PUSH
53034: DOUBLE
53035: LD_INT 1
53037: DEC
53038: ST_TO_ADDR
53039: LD_EXP 100
53043: PUSH
53044: FOR_TO
53045: IFFALSE 53188
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53047: LD_ADDR_VAR 0 4
53051: PUSH
53052: LD_EXP 119
53056: PUSH
53057: LD_VAR 0 2
53061: ARRAY
53062: PUSH
53063: LD_EXP 122
53067: PUSH
53068: LD_VAR 0 2
53072: ARRAY
53073: UNION
53074: PPUSH
53075: LD_INT 33
53077: PUSH
53078: LD_INT 2
53080: PUSH
53081: EMPTY
53082: LIST
53083: LIST
53084: PPUSH
53085: CALL_OW 72
53089: ST_TO_ADDR
// if tmp then
53090: LD_VAR 0 4
53094: IFFALSE 53186
// for j in tmp do
53096: LD_ADDR_VAR 0 3
53100: PUSH
53101: LD_VAR 0 4
53105: PUSH
53106: FOR_IN
53107: IFFALSE 53184
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53109: LD_VAR 0 3
53113: PPUSH
53114: CALL_OW 312
53118: NOT
53119: PUSH
53120: LD_VAR 0 3
53124: PPUSH
53125: CALL_OW 256
53129: PUSH
53130: LD_INT 250
53132: GREATEREQUAL
53133: AND
53134: IFFALSE 53147
// Connect ( j ) else
53136: LD_VAR 0 3
53140: PPUSH
53141: CALL 76488 0 1
53145: GO 53182
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
53147: LD_VAR 0 3
53151: PPUSH
53152: CALL_OW 256
53156: PUSH
53157: LD_INT 250
53159: LESS
53160: PUSH
53161: LD_VAR 0 3
53165: PPUSH
53166: CALL_OW 312
53170: AND
53171: IFFALSE 53182
// ComUnlink ( j ) ;
53173: LD_VAR 0 3
53177: PPUSH
53178: CALL_OW 136
53182: GO 53106
53184: POP
53185: POP
// end ;
53186: GO 53044
53188: POP
53189: POP
// end ;
53190: LD_VAR 0 1
53194: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
53195: LD_INT 0
53197: PPUSH
53198: PPUSH
53199: PPUSH
53200: PPUSH
53201: PPUSH
// if not mc_bases then
53202: LD_EXP 100
53206: NOT
53207: IFFALSE 53211
// exit ;
53209: GO 53656
// for i = 1 to mc_bases do
53211: LD_ADDR_VAR 0 2
53215: PUSH
53216: DOUBLE
53217: LD_INT 1
53219: DEC
53220: ST_TO_ADDR
53221: LD_EXP 100
53225: PUSH
53226: FOR_TO
53227: IFFALSE 53654
// begin if not mc_produce [ i ] then
53229: LD_EXP 121
53233: PUSH
53234: LD_VAR 0 2
53238: ARRAY
53239: NOT
53240: IFFALSE 53244
// continue ;
53242: GO 53226
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53244: LD_ADDR_VAR 0 5
53248: PUSH
53249: LD_EXP 100
53253: PUSH
53254: LD_VAR 0 2
53258: ARRAY
53259: PPUSH
53260: LD_INT 30
53262: PUSH
53263: LD_INT 3
53265: PUSH
53266: EMPTY
53267: LIST
53268: LIST
53269: PPUSH
53270: CALL_OW 72
53274: ST_TO_ADDR
// if not fac then
53275: LD_VAR 0 5
53279: NOT
53280: IFFALSE 53284
// continue ;
53282: GO 53226
// for j in fac do
53284: LD_ADDR_VAR 0 3
53288: PUSH
53289: LD_VAR 0 5
53293: PUSH
53294: FOR_IN
53295: IFFALSE 53650
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
53297: LD_VAR 0 3
53301: PPUSH
53302: CALL_OW 461
53306: PUSH
53307: LD_INT 2
53309: NONEQUAL
53310: PUSH
53311: LD_VAR 0 3
53315: PPUSH
53316: LD_INT 15
53318: PPUSH
53319: CALL 76116 0 2
53323: PUSH
53324: LD_INT 4
53326: ARRAY
53327: OR
53328: IFFALSE 53332
// continue ;
53330: GO 53294
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
53332: LD_VAR 0 3
53336: PPUSH
53337: LD_EXP 121
53341: PUSH
53342: LD_VAR 0 2
53346: ARRAY
53347: PUSH
53348: LD_INT 1
53350: ARRAY
53351: PUSH
53352: LD_INT 1
53354: ARRAY
53355: PPUSH
53356: LD_EXP 121
53360: PUSH
53361: LD_VAR 0 2
53365: ARRAY
53366: PUSH
53367: LD_INT 1
53369: ARRAY
53370: PUSH
53371: LD_INT 2
53373: ARRAY
53374: PPUSH
53375: LD_EXP 121
53379: PUSH
53380: LD_VAR 0 2
53384: ARRAY
53385: PUSH
53386: LD_INT 1
53388: ARRAY
53389: PUSH
53390: LD_INT 3
53392: ARRAY
53393: PPUSH
53394: LD_EXP 121
53398: PUSH
53399: LD_VAR 0 2
53403: ARRAY
53404: PUSH
53405: LD_INT 1
53407: ARRAY
53408: PUSH
53409: LD_INT 4
53411: ARRAY
53412: PPUSH
53413: CALL_OW 448
53417: PUSH
53418: LD_VAR 0 3
53422: PPUSH
53423: LD_EXP 121
53427: PUSH
53428: LD_VAR 0 2
53432: ARRAY
53433: PUSH
53434: LD_INT 1
53436: ARRAY
53437: PUSH
53438: LD_INT 1
53440: ARRAY
53441: PUSH
53442: LD_EXP 121
53446: PUSH
53447: LD_VAR 0 2
53451: ARRAY
53452: PUSH
53453: LD_INT 1
53455: ARRAY
53456: PUSH
53457: LD_INT 2
53459: ARRAY
53460: PUSH
53461: LD_EXP 121
53465: PUSH
53466: LD_VAR 0 2
53470: ARRAY
53471: PUSH
53472: LD_INT 1
53474: ARRAY
53475: PUSH
53476: LD_INT 3
53478: ARRAY
53479: PUSH
53480: LD_EXP 121
53484: PUSH
53485: LD_VAR 0 2
53489: ARRAY
53490: PUSH
53491: LD_INT 1
53493: ARRAY
53494: PUSH
53495: LD_INT 4
53497: ARRAY
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: LIST
53503: LIST
53504: PPUSH
53505: CALL 79883 0 2
53509: AND
53510: IFFALSE 53648
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
53512: LD_VAR 0 3
53516: PPUSH
53517: LD_EXP 121
53521: PUSH
53522: LD_VAR 0 2
53526: ARRAY
53527: PUSH
53528: LD_INT 1
53530: ARRAY
53531: PUSH
53532: LD_INT 1
53534: ARRAY
53535: PPUSH
53536: LD_EXP 121
53540: PUSH
53541: LD_VAR 0 2
53545: ARRAY
53546: PUSH
53547: LD_INT 1
53549: ARRAY
53550: PUSH
53551: LD_INT 2
53553: ARRAY
53554: PPUSH
53555: LD_EXP 121
53559: PUSH
53560: LD_VAR 0 2
53564: ARRAY
53565: PUSH
53566: LD_INT 1
53568: ARRAY
53569: PUSH
53570: LD_INT 3
53572: ARRAY
53573: PPUSH
53574: LD_EXP 121
53578: PUSH
53579: LD_VAR 0 2
53583: ARRAY
53584: PUSH
53585: LD_INT 1
53587: ARRAY
53588: PUSH
53589: LD_INT 4
53591: ARRAY
53592: PPUSH
53593: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
53597: LD_ADDR_VAR 0 4
53601: PUSH
53602: LD_EXP 121
53606: PUSH
53607: LD_VAR 0 2
53611: ARRAY
53612: PPUSH
53613: LD_INT 1
53615: PPUSH
53616: CALL_OW 3
53620: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
53621: LD_ADDR_EXP 121
53625: PUSH
53626: LD_EXP 121
53630: PPUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: LD_VAR 0 4
53640: PPUSH
53641: CALL_OW 1
53645: ST_TO_ADDR
// break ;
53646: GO 53650
// end ; end ;
53648: GO 53294
53650: POP
53651: POP
// end ;
53652: GO 53226
53654: POP
53655: POP
// end ;
53656: LD_VAR 0 1
53660: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
53661: LD_INT 0
53663: PPUSH
53664: PPUSH
53665: PPUSH
// if not mc_bases then
53666: LD_EXP 100
53670: NOT
53671: IFFALSE 53675
// exit ;
53673: GO 53764
// for i = 1 to mc_bases do
53675: LD_ADDR_VAR 0 2
53679: PUSH
53680: DOUBLE
53681: LD_INT 1
53683: DEC
53684: ST_TO_ADDR
53685: LD_EXP 100
53689: PUSH
53690: FOR_TO
53691: IFFALSE 53762
// begin if mc_attack [ i ] then
53693: LD_EXP 120
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: IFFALSE 53760
// begin tmp := mc_attack [ i ] [ 1 ] ;
53705: LD_ADDR_VAR 0 3
53709: PUSH
53710: LD_EXP 120
53714: PUSH
53715: LD_VAR 0 2
53719: ARRAY
53720: PUSH
53721: LD_INT 1
53723: ARRAY
53724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53725: LD_ADDR_EXP 120
53729: PUSH
53730: LD_EXP 120
53734: PPUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: EMPTY
53741: PPUSH
53742: CALL_OW 1
53746: ST_TO_ADDR
// Attack ( tmp ) ;
53747: LD_VAR 0 3
53751: PPUSH
53752: CALL 130004 0 1
// exit ;
53756: POP
53757: POP
53758: GO 53764
// end ; end ;
53760: GO 53690
53762: POP
53763: POP
// end ;
53764: LD_VAR 0 1
53768: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
53769: LD_INT 0
53771: PPUSH
53772: PPUSH
53773: PPUSH
53774: PPUSH
53775: PPUSH
53776: PPUSH
53777: PPUSH
// if not mc_bases then
53778: LD_EXP 100
53782: NOT
53783: IFFALSE 53787
// exit ;
53785: GO 54644
// for i = 1 to mc_bases do
53787: LD_ADDR_VAR 0 2
53791: PUSH
53792: DOUBLE
53793: LD_INT 1
53795: DEC
53796: ST_TO_ADDR
53797: LD_EXP 100
53801: PUSH
53802: FOR_TO
53803: IFFALSE 54642
// begin if not mc_bases [ i ] then
53805: LD_EXP 100
53809: PUSH
53810: LD_VAR 0 2
53814: ARRAY
53815: NOT
53816: IFFALSE 53820
// continue ;
53818: GO 53802
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
53820: LD_ADDR_VAR 0 7
53824: PUSH
53825: LD_EXP 100
53829: PUSH
53830: LD_VAR 0 2
53834: ARRAY
53835: PUSH
53836: LD_INT 1
53838: ARRAY
53839: PPUSH
53840: CALL 70343 0 1
53844: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
53845: LD_ADDR_EXP 123
53849: PUSH
53850: LD_EXP 123
53854: PPUSH
53855: LD_VAR 0 2
53859: PPUSH
53860: LD_EXP 100
53864: PUSH
53865: LD_VAR 0 2
53869: ARRAY
53870: PUSH
53871: LD_INT 1
53873: ARRAY
53874: PPUSH
53875: CALL_OW 255
53879: PPUSH
53880: LD_EXP 125
53884: PUSH
53885: LD_VAR 0 2
53889: ARRAY
53890: PPUSH
53891: CALL 70308 0 2
53895: PPUSH
53896: CALL_OW 1
53900: ST_TO_ADDR
// if not mc_scan [ i ] then
53901: LD_EXP 123
53905: PUSH
53906: LD_VAR 0 2
53910: ARRAY
53911: NOT
53912: IFFALSE 54090
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53914: LD_ADDR_EXP 143
53918: PUSH
53919: LD_EXP 143
53923: PPUSH
53924: LD_VAR 0 2
53928: PPUSH
53929: LD_INT 0
53931: PPUSH
53932: CALL_OW 1
53936: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53937: LD_ADDR_VAR 0 4
53941: PUSH
53942: LD_EXP 100
53946: PUSH
53947: LD_VAR 0 2
53951: ARRAY
53952: PPUSH
53953: LD_INT 2
53955: PUSH
53956: LD_INT 25
53958: PUSH
53959: LD_INT 5
53961: PUSH
53962: EMPTY
53963: LIST
53964: LIST
53965: PUSH
53966: LD_INT 25
53968: PUSH
53969: LD_INT 8
53971: PUSH
53972: EMPTY
53973: LIST
53974: LIST
53975: PUSH
53976: LD_INT 25
53978: PUSH
53979: LD_INT 9
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: LIST
53990: LIST
53991: PPUSH
53992: CALL_OW 72
53996: ST_TO_ADDR
// if not tmp then
53997: LD_VAR 0 4
54001: NOT
54002: IFFALSE 54006
// continue ;
54004: GO 53802
// for j in tmp do
54006: LD_ADDR_VAR 0 3
54010: PUSH
54011: LD_VAR 0 4
54015: PUSH
54016: FOR_IN
54017: IFFALSE 54088
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54019: LD_VAR 0 3
54023: PPUSH
54024: CALL_OW 310
54028: PPUSH
54029: CALL_OW 266
54033: PUSH
54034: LD_INT 5
54036: EQUAL
54037: PUSH
54038: LD_VAR 0 3
54042: PPUSH
54043: CALL_OW 257
54047: PUSH
54048: LD_INT 1
54050: EQUAL
54051: AND
54052: PUSH
54053: LD_VAR 0 3
54057: PPUSH
54058: CALL_OW 459
54062: NOT
54063: AND
54064: PUSH
54065: LD_VAR 0 7
54069: AND
54070: IFFALSE 54086
// ComChangeProfession ( j , class ) ;
54072: LD_VAR 0 3
54076: PPUSH
54077: LD_VAR 0 7
54081: PPUSH
54082: CALL_OW 123
54086: GO 54016
54088: POP
54089: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54090: LD_EXP 123
54094: PUSH
54095: LD_VAR 0 2
54099: ARRAY
54100: PUSH
54101: LD_EXP 143
54105: PUSH
54106: LD_VAR 0 2
54110: ARRAY
54111: NOT
54112: AND
54113: PUSH
54114: LD_EXP 122
54118: PUSH
54119: LD_VAR 0 2
54123: ARRAY
54124: NOT
54125: AND
54126: PUSH
54127: LD_EXP 100
54131: PUSH
54132: LD_VAR 0 2
54136: ARRAY
54137: PPUSH
54138: LD_INT 50
54140: PUSH
54141: EMPTY
54142: LIST
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: LD_INT 30
54149: PUSH
54150: LD_INT 32
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: LD_INT 30
54159: PUSH
54160: LD_INT 33
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: PUSH
54167: LD_INT 30
54169: PUSH
54170: LD_INT 4
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: PUSH
54177: LD_INT 30
54179: PUSH
54180: LD_INT 5
54182: PUSH
54183: EMPTY
54184: LIST
54185: LIST
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: LIST
54191: LIST
54192: LIST
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: PPUSH
54198: CALL_OW 72
54202: PUSH
54203: LD_INT 4
54205: LESS
54206: PUSH
54207: LD_EXP 100
54211: PUSH
54212: LD_VAR 0 2
54216: ARRAY
54217: PPUSH
54218: LD_INT 3
54220: PUSH
54221: LD_INT 24
54223: PUSH
54224: LD_INT 1000
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PUSH
54231: EMPTY
54232: LIST
54233: LIST
54234: PUSH
54235: LD_INT 2
54237: PUSH
54238: LD_INT 30
54240: PUSH
54241: LD_INT 0
54243: PUSH
54244: EMPTY
54245: LIST
54246: LIST
54247: PUSH
54248: LD_INT 30
54250: PUSH
54251: LD_INT 1
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PUSH
54258: EMPTY
54259: LIST
54260: LIST
54261: LIST
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: PPUSH
54267: CALL_OW 72
54271: OR
54272: AND
54273: IFFALSE 54524
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54275: LD_ADDR_EXP 143
54279: PUSH
54280: LD_EXP 143
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: LD_INT 1
54292: PPUSH
54293: CALL_OW 1
54297: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54298: LD_ADDR_VAR 0 4
54302: PUSH
54303: LD_EXP 100
54307: PUSH
54308: LD_VAR 0 2
54312: ARRAY
54313: PPUSH
54314: LD_INT 2
54316: PUSH
54317: LD_INT 25
54319: PUSH
54320: LD_INT 1
54322: PUSH
54323: EMPTY
54324: LIST
54325: LIST
54326: PUSH
54327: LD_INT 25
54329: PUSH
54330: LD_INT 5
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PUSH
54337: LD_INT 25
54339: PUSH
54340: LD_INT 8
54342: PUSH
54343: EMPTY
54344: LIST
54345: LIST
54346: PUSH
54347: LD_INT 25
54349: PUSH
54350: LD_INT 9
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: LIST
54363: PPUSH
54364: CALL_OW 72
54368: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
54369: LD_ADDR_VAR 0 4
54373: PUSH
54374: LD_VAR 0 4
54378: PUSH
54379: LD_VAR 0 4
54383: PPUSH
54384: LD_INT 18
54386: PPUSH
54387: CALL 103431 0 2
54391: DIFF
54392: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
54393: LD_VAR 0 4
54397: NOT
54398: PUSH
54399: LD_EXP 100
54403: PUSH
54404: LD_VAR 0 2
54408: ARRAY
54409: PPUSH
54410: LD_INT 2
54412: PUSH
54413: LD_INT 30
54415: PUSH
54416: LD_INT 4
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PUSH
54423: LD_INT 30
54425: PUSH
54426: LD_INT 5
54428: PUSH
54429: EMPTY
54430: LIST
54431: LIST
54432: PUSH
54433: EMPTY
54434: LIST
54435: LIST
54436: LIST
54437: PPUSH
54438: CALL_OW 72
54442: NOT
54443: AND
54444: IFFALSE 54506
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
54446: LD_ADDR_VAR 0 4
54450: PUSH
54451: LD_EXP 100
54455: PUSH
54456: LD_VAR 0 2
54460: ARRAY
54461: PPUSH
54462: LD_INT 2
54464: PUSH
54465: LD_INT 25
54467: PUSH
54468: LD_INT 2
54470: PUSH
54471: EMPTY
54472: LIST
54473: LIST
54474: PUSH
54475: LD_INT 25
54477: PUSH
54478: LD_INT 3
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: PUSH
54485: LD_INT 25
54487: PUSH
54488: LD_INT 4
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: PPUSH
54501: CALL_OW 72
54505: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
54506: LD_VAR 0 2
54510: PPUSH
54511: LD_VAR 0 4
54515: PPUSH
54516: CALL 134713 0 2
// exit ;
54520: POP
54521: POP
54522: GO 54644
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
54524: LD_EXP 123
54528: PUSH
54529: LD_VAR 0 2
54533: ARRAY
54534: PUSH
54535: LD_EXP 143
54539: PUSH
54540: LD_VAR 0 2
54544: ARRAY
54545: NOT
54546: AND
54547: PUSH
54548: LD_EXP 122
54552: PUSH
54553: LD_VAR 0 2
54557: ARRAY
54558: AND
54559: IFFALSE 54640
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54561: LD_ADDR_EXP 143
54565: PUSH
54566: LD_EXP 143
54570: PPUSH
54571: LD_VAR 0 2
54575: PPUSH
54576: LD_INT 1
54578: PPUSH
54579: CALL_OW 1
54583: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
54584: LD_ADDR_VAR 0 4
54588: PUSH
54589: LD_EXP 122
54593: PUSH
54594: LD_VAR 0 2
54598: ARRAY
54599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54600: LD_ADDR_EXP 122
54604: PUSH
54605: LD_EXP 122
54609: PPUSH
54610: LD_VAR 0 2
54614: PPUSH
54615: EMPTY
54616: PPUSH
54617: CALL_OW 1
54621: ST_TO_ADDR
// Defend ( i , tmp ) ;
54622: LD_VAR 0 2
54626: PPUSH
54627: LD_VAR 0 4
54631: PPUSH
54632: CALL 135309 0 2
// exit ;
54636: POP
54637: POP
54638: GO 54644
// end ; end ;
54640: GO 53802
54642: POP
54643: POP
// end ;
54644: LD_VAR 0 1
54648: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
54649: LD_INT 0
54651: PPUSH
54652: PPUSH
54653: PPUSH
54654: PPUSH
54655: PPUSH
54656: PPUSH
54657: PPUSH
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
// if not mc_bases then
54662: LD_EXP 100
54666: NOT
54667: IFFALSE 54671
// exit ;
54669: GO 55758
// for i = 1 to mc_bases do
54671: LD_ADDR_VAR 0 2
54675: PUSH
54676: DOUBLE
54677: LD_INT 1
54679: DEC
54680: ST_TO_ADDR
54681: LD_EXP 100
54685: PUSH
54686: FOR_TO
54687: IFFALSE 55756
// begin tmp := mc_lab [ i ] ;
54689: LD_ADDR_VAR 0 6
54693: PUSH
54694: LD_EXP 133
54698: PUSH
54699: LD_VAR 0 2
54703: ARRAY
54704: ST_TO_ADDR
// if not tmp then
54705: LD_VAR 0 6
54709: NOT
54710: IFFALSE 54714
// continue ;
54712: GO 54686
// idle_lab := 0 ;
54714: LD_ADDR_VAR 0 11
54718: PUSH
54719: LD_INT 0
54721: ST_TO_ADDR
// for j in tmp do
54722: LD_ADDR_VAR 0 3
54726: PUSH
54727: LD_VAR 0 6
54731: PUSH
54732: FOR_IN
54733: IFFALSE 55752
// begin researching := false ;
54735: LD_ADDR_VAR 0 10
54739: PUSH
54740: LD_INT 0
54742: ST_TO_ADDR
// side := GetSide ( j ) ;
54743: LD_ADDR_VAR 0 4
54747: PUSH
54748: LD_VAR 0 3
54752: PPUSH
54753: CALL_OW 255
54757: ST_TO_ADDR
// if not mc_tech [ side ] then
54758: LD_EXP 127
54762: PUSH
54763: LD_VAR 0 4
54767: ARRAY
54768: NOT
54769: IFFALSE 54773
// continue ;
54771: GO 54732
// if BuildingStatus ( j ) = bs_idle then
54773: LD_VAR 0 3
54777: PPUSH
54778: CALL_OW 461
54782: PUSH
54783: LD_INT 2
54785: EQUAL
54786: IFFALSE 54974
// begin if idle_lab and UnitsInside ( j ) < 6 then
54788: LD_VAR 0 11
54792: PUSH
54793: LD_VAR 0 3
54797: PPUSH
54798: CALL_OW 313
54802: PUSH
54803: LD_INT 6
54805: LESS
54806: AND
54807: IFFALSE 54878
// begin tmp2 := UnitsInside ( idle_lab ) ;
54809: LD_ADDR_VAR 0 9
54813: PUSH
54814: LD_VAR 0 11
54818: PPUSH
54819: CALL_OW 313
54823: ST_TO_ADDR
// if tmp2 then
54824: LD_VAR 0 9
54828: IFFALSE 54870
// for x in tmp2 do
54830: LD_ADDR_VAR 0 7
54834: PUSH
54835: LD_VAR 0 9
54839: PUSH
54840: FOR_IN
54841: IFFALSE 54868
// begin ComExitBuilding ( x ) ;
54843: LD_VAR 0 7
54847: PPUSH
54848: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54852: LD_VAR 0 7
54856: PPUSH
54857: LD_VAR 0 3
54861: PPUSH
54862: CALL_OW 180
// end ;
54866: GO 54840
54868: POP
54869: POP
// idle_lab := 0 ;
54870: LD_ADDR_VAR 0 11
54874: PUSH
54875: LD_INT 0
54877: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
54878: LD_ADDR_VAR 0 5
54882: PUSH
54883: LD_EXP 127
54887: PUSH
54888: LD_VAR 0 4
54892: ARRAY
54893: PUSH
54894: FOR_IN
54895: IFFALSE 54955
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
54897: LD_VAR 0 3
54901: PPUSH
54902: LD_VAR 0 5
54906: PPUSH
54907: CALL_OW 430
54911: PUSH
54912: LD_VAR 0 4
54916: PPUSH
54917: LD_VAR 0 5
54921: PPUSH
54922: CALL 69413 0 2
54926: AND
54927: IFFALSE 54953
// begin researching := true ;
54929: LD_ADDR_VAR 0 10
54933: PUSH
54934: LD_INT 1
54936: ST_TO_ADDR
// ComResearch ( j , t ) ;
54937: LD_VAR 0 3
54941: PPUSH
54942: LD_VAR 0 5
54946: PPUSH
54947: CALL_OW 124
// break ;
54951: GO 54955
// end ;
54953: GO 54894
54955: POP
54956: POP
// if not researching then
54957: LD_VAR 0 10
54961: NOT
54962: IFFALSE 54974
// idle_lab := j ;
54964: LD_ADDR_VAR 0 11
54968: PUSH
54969: LD_VAR 0 3
54973: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
54974: LD_VAR 0 3
54978: PPUSH
54979: CALL_OW 461
54983: PUSH
54984: LD_INT 10
54986: EQUAL
54987: IFFALSE 55575
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
54989: LD_EXP 129
54993: PUSH
54994: LD_VAR 0 2
54998: ARRAY
54999: NOT
55000: PUSH
55001: LD_EXP 130
55005: PUSH
55006: LD_VAR 0 2
55010: ARRAY
55011: NOT
55012: AND
55013: PUSH
55014: LD_EXP 127
55018: PUSH
55019: LD_VAR 0 4
55023: ARRAY
55024: PUSH
55025: LD_INT 1
55027: GREATER
55028: AND
55029: IFFALSE 55160
// begin ComCancel ( j ) ;
55031: LD_VAR 0 3
55035: PPUSH
55036: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55040: LD_ADDR_EXP 127
55044: PUSH
55045: LD_EXP 127
55049: PPUSH
55050: LD_VAR 0 4
55054: PPUSH
55055: LD_EXP 127
55059: PUSH
55060: LD_VAR 0 4
55064: ARRAY
55065: PPUSH
55066: LD_EXP 127
55070: PUSH
55071: LD_VAR 0 4
55075: ARRAY
55076: PUSH
55077: LD_INT 1
55079: MINUS
55080: PPUSH
55081: LD_EXP 127
55085: PUSH
55086: LD_VAR 0 4
55090: ARRAY
55091: PPUSH
55092: LD_INT 0
55094: PPUSH
55095: CALL 72937 0 4
55099: PPUSH
55100: CALL_OW 1
55104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55105: LD_ADDR_EXP 127
55109: PUSH
55110: LD_EXP 127
55114: PPUSH
55115: LD_VAR 0 4
55119: PPUSH
55120: LD_EXP 127
55124: PUSH
55125: LD_VAR 0 4
55129: ARRAY
55130: PPUSH
55131: LD_EXP 127
55135: PUSH
55136: LD_VAR 0 4
55140: ARRAY
55141: PPUSH
55142: LD_INT 1
55144: PPUSH
55145: LD_INT 0
55147: PPUSH
55148: CALL 72937 0 4
55152: PPUSH
55153: CALL_OW 1
55157: ST_TO_ADDR
// continue ;
55158: GO 54732
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
55160: LD_EXP 129
55164: PUSH
55165: LD_VAR 0 2
55169: ARRAY
55170: PUSH
55171: LD_EXP 130
55175: PUSH
55176: LD_VAR 0 2
55180: ARRAY
55181: NOT
55182: AND
55183: IFFALSE 55310
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
55185: LD_ADDR_EXP 130
55189: PUSH
55190: LD_EXP 130
55194: PPUSH
55195: LD_VAR 0 2
55199: PUSH
55200: LD_EXP 130
55204: PUSH
55205: LD_VAR 0 2
55209: ARRAY
55210: PUSH
55211: LD_INT 1
55213: PLUS
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: PPUSH
55219: LD_EXP 129
55223: PUSH
55224: LD_VAR 0 2
55228: ARRAY
55229: PUSH
55230: LD_INT 1
55232: ARRAY
55233: PPUSH
55234: CALL 73519 0 3
55238: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
55239: LD_EXP 129
55243: PUSH
55244: LD_VAR 0 2
55248: ARRAY
55249: PUSH
55250: LD_INT 1
55252: ARRAY
55253: PPUSH
55254: LD_INT 112
55256: PPUSH
55257: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
55261: LD_ADDR_VAR 0 9
55265: PUSH
55266: LD_EXP 129
55270: PUSH
55271: LD_VAR 0 2
55275: ARRAY
55276: PPUSH
55277: LD_INT 1
55279: PPUSH
55280: CALL_OW 3
55284: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
55285: LD_ADDR_EXP 129
55289: PUSH
55290: LD_EXP 129
55294: PPUSH
55295: LD_VAR 0 2
55299: PPUSH
55300: LD_VAR 0 9
55304: PPUSH
55305: CALL_OW 1
55309: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
55310: LD_EXP 129
55314: PUSH
55315: LD_VAR 0 2
55319: ARRAY
55320: PUSH
55321: LD_EXP 130
55325: PUSH
55326: LD_VAR 0 2
55330: ARRAY
55331: AND
55332: PUSH
55333: LD_EXP 130
55337: PUSH
55338: LD_VAR 0 2
55342: ARRAY
55343: PUSH
55344: LD_INT 1
55346: ARRAY
55347: PPUSH
55348: CALL_OW 310
55352: NOT
55353: AND
55354: PUSH
55355: LD_VAR 0 3
55359: PPUSH
55360: CALL_OW 313
55364: PUSH
55365: LD_INT 6
55367: EQUAL
55368: AND
55369: IFFALSE 55425
// begin tmp2 := UnitsInside ( j ) ;
55371: LD_ADDR_VAR 0 9
55375: PUSH
55376: LD_VAR 0 3
55380: PPUSH
55381: CALL_OW 313
55385: ST_TO_ADDR
// if tmp2 = 6 then
55386: LD_VAR 0 9
55390: PUSH
55391: LD_INT 6
55393: EQUAL
55394: IFFALSE 55425
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
55396: LD_VAR 0 9
55400: PUSH
55401: LD_INT 1
55403: ARRAY
55404: PPUSH
55405: LD_INT 112
55407: PPUSH
55408: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
55412: LD_VAR 0 9
55416: PUSH
55417: LD_INT 1
55419: ARRAY
55420: PPUSH
55421: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
55425: LD_EXP 130
55429: PUSH
55430: LD_VAR 0 2
55434: ARRAY
55435: PUSH
55436: LD_EXP 130
55440: PUSH
55441: LD_VAR 0 2
55445: ARRAY
55446: PUSH
55447: LD_INT 1
55449: ARRAY
55450: PPUSH
55451: CALL_OW 314
55455: NOT
55456: AND
55457: PUSH
55458: LD_EXP 130
55462: PUSH
55463: LD_VAR 0 2
55467: ARRAY
55468: PUSH
55469: LD_INT 1
55471: ARRAY
55472: PPUSH
55473: CALL_OW 310
55477: NOT
55478: AND
55479: IFFALSE 55505
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
55481: LD_EXP 130
55485: PUSH
55486: LD_VAR 0 2
55490: ARRAY
55491: PUSH
55492: LD_INT 1
55494: ARRAY
55495: PPUSH
55496: LD_VAR 0 3
55500: PPUSH
55501: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
55505: LD_EXP 130
55509: PUSH
55510: LD_VAR 0 2
55514: ARRAY
55515: PUSH
55516: LD_INT 1
55518: ARRAY
55519: PPUSH
55520: CALL_OW 310
55524: PUSH
55525: LD_EXP 130
55529: PUSH
55530: LD_VAR 0 2
55534: ARRAY
55535: PUSH
55536: LD_INT 1
55538: ARRAY
55539: PPUSH
55540: CALL_OW 310
55544: PPUSH
55545: CALL_OW 461
55549: PUSH
55550: LD_INT 3
55552: NONEQUAL
55553: AND
55554: IFFALSE 55575
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
55556: LD_EXP 130
55560: PUSH
55561: LD_VAR 0 2
55565: ARRAY
55566: PUSH
55567: LD_INT 1
55569: ARRAY
55570: PPUSH
55571: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
55575: LD_VAR 0 3
55579: PPUSH
55580: CALL_OW 461
55584: PUSH
55585: LD_INT 6
55587: EQUAL
55588: PUSH
55589: LD_VAR 0 6
55593: PUSH
55594: LD_INT 1
55596: GREATER
55597: AND
55598: IFFALSE 55750
// begin sci := [ ] ;
55600: LD_ADDR_VAR 0 8
55604: PUSH
55605: EMPTY
55606: ST_TO_ADDR
// for x in ( tmp diff j ) do
55607: LD_ADDR_VAR 0 7
55611: PUSH
55612: LD_VAR 0 6
55616: PUSH
55617: LD_VAR 0 3
55621: DIFF
55622: PUSH
55623: FOR_IN
55624: IFFALSE 55676
// begin if sci = 6 then
55626: LD_VAR 0 8
55630: PUSH
55631: LD_INT 6
55633: EQUAL
55634: IFFALSE 55638
// break ;
55636: GO 55676
// if BuildingStatus ( x ) = bs_idle then
55638: LD_VAR 0 7
55642: PPUSH
55643: CALL_OW 461
55647: PUSH
55648: LD_INT 2
55650: EQUAL
55651: IFFALSE 55674
// sci := sci ^ UnitsInside ( x ) ;
55653: LD_ADDR_VAR 0 8
55657: PUSH
55658: LD_VAR 0 8
55662: PUSH
55663: LD_VAR 0 7
55667: PPUSH
55668: CALL_OW 313
55672: ADD
55673: ST_TO_ADDR
// end ;
55674: GO 55623
55676: POP
55677: POP
// if not sci then
55678: LD_VAR 0 8
55682: NOT
55683: IFFALSE 55687
// continue ;
55685: GO 54732
// for x in sci do
55687: LD_ADDR_VAR 0 7
55691: PUSH
55692: LD_VAR 0 8
55696: PUSH
55697: FOR_IN
55698: IFFALSE 55748
// if IsInUnit ( x ) and not HasTask ( x ) then
55700: LD_VAR 0 7
55704: PPUSH
55705: CALL_OW 310
55709: PUSH
55710: LD_VAR 0 7
55714: PPUSH
55715: CALL_OW 314
55719: NOT
55720: AND
55721: IFFALSE 55746
// begin ComExitBuilding ( x ) ;
55723: LD_VAR 0 7
55727: PPUSH
55728: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55732: LD_VAR 0 7
55736: PPUSH
55737: LD_VAR 0 3
55741: PPUSH
55742: CALL_OW 180
// end ;
55746: GO 55697
55748: POP
55749: POP
// end ; end ;
55750: GO 54732
55752: POP
55753: POP
// end ;
55754: GO 54686
55756: POP
55757: POP
// end ;
55758: LD_VAR 0 1
55762: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
55763: LD_INT 0
55765: PPUSH
55766: PPUSH
// if not mc_bases then
55767: LD_EXP 100
55771: NOT
55772: IFFALSE 55776
// exit ;
55774: GO 55857
// for i = 1 to mc_bases do
55776: LD_ADDR_VAR 0 2
55780: PUSH
55781: DOUBLE
55782: LD_INT 1
55784: DEC
55785: ST_TO_ADDR
55786: LD_EXP 100
55790: PUSH
55791: FOR_TO
55792: IFFALSE 55855
// if mc_mines [ i ] and mc_miners [ i ] then
55794: LD_EXP 113
55798: PUSH
55799: LD_VAR 0 2
55803: ARRAY
55804: PUSH
55805: LD_EXP 114
55809: PUSH
55810: LD_VAR 0 2
55814: ARRAY
55815: AND
55816: IFFALSE 55853
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
55818: LD_EXP 114
55822: PUSH
55823: LD_VAR 0 2
55827: ARRAY
55828: PUSH
55829: LD_INT 1
55831: ARRAY
55832: PPUSH
55833: CALL_OW 255
55837: PPUSH
55838: LD_EXP 113
55842: PUSH
55843: LD_VAR 0 2
55847: ARRAY
55848: PPUSH
55849: CALL 70496 0 2
55853: GO 55791
55855: POP
55856: POP
// end ;
55857: LD_VAR 0 1
55861: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
55862: LD_INT 0
55864: PPUSH
55865: PPUSH
55866: PPUSH
55867: PPUSH
55868: PPUSH
55869: PPUSH
55870: PPUSH
55871: PPUSH
// if not mc_bases or not mc_parking then
55872: LD_EXP 100
55876: NOT
55877: PUSH
55878: LD_EXP 124
55882: NOT
55883: OR
55884: IFFALSE 55888
// exit ;
55886: GO 56626
// for i = 1 to mc_bases do
55888: LD_ADDR_VAR 0 2
55892: PUSH
55893: DOUBLE
55894: LD_INT 1
55896: DEC
55897: ST_TO_ADDR
55898: LD_EXP 100
55902: PUSH
55903: FOR_TO
55904: IFFALSE 56624
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
55906: LD_EXP 100
55910: PUSH
55911: LD_VAR 0 2
55915: ARRAY
55916: NOT
55917: PUSH
55918: LD_EXP 124
55922: PUSH
55923: LD_VAR 0 2
55927: ARRAY
55928: NOT
55929: OR
55930: IFFALSE 55934
// continue ;
55932: GO 55903
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
55934: LD_ADDR_VAR 0 5
55938: PUSH
55939: LD_EXP 100
55943: PUSH
55944: LD_VAR 0 2
55948: ARRAY
55949: PUSH
55950: LD_INT 1
55952: ARRAY
55953: PPUSH
55954: CALL_OW 255
55958: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55959: LD_ADDR_VAR 0 6
55963: PUSH
55964: LD_EXP 100
55968: PUSH
55969: LD_VAR 0 2
55973: ARRAY
55974: PPUSH
55975: LD_INT 30
55977: PUSH
55978: LD_INT 3
55980: PUSH
55981: EMPTY
55982: LIST
55983: LIST
55984: PPUSH
55985: CALL_OW 72
55989: ST_TO_ADDR
// if not fac then
55990: LD_VAR 0 6
55994: NOT
55995: IFFALSE 56046
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55997: LD_ADDR_VAR 0 6
56001: PUSH
56002: LD_EXP 100
56006: PUSH
56007: LD_VAR 0 2
56011: ARRAY
56012: PPUSH
56013: LD_INT 2
56015: PUSH
56016: LD_INT 30
56018: PUSH
56019: LD_INT 0
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: PUSH
56026: LD_INT 30
56028: PUSH
56029: LD_INT 1
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PUSH
56036: EMPTY
56037: LIST
56038: LIST
56039: LIST
56040: PPUSH
56041: CALL_OW 72
56045: ST_TO_ADDR
// if not fac then
56046: LD_VAR 0 6
56050: NOT
56051: IFFALSE 56055
// continue ;
56053: GO 55903
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56055: LD_ADDR_VAR 0 7
56059: PUSH
56060: LD_EXP 124
56064: PUSH
56065: LD_VAR 0 2
56069: ARRAY
56070: PPUSH
56071: LD_INT 22
56073: PUSH
56074: LD_VAR 0 5
56078: PUSH
56079: EMPTY
56080: LIST
56081: LIST
56082: PUSH
56083: LD_INT 21
56085: PUSH
56086: LD_INT 2
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PUSH
56093: LD_INT 3
56095: PUSH
56096: LD_INT 60
56098: PUSH
56099: EMPTY
56100: LIST
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: LD_INT 3
56108: PUSH
56109: LD_INT 24
56111: PUSH
56112: LD_INT 1000
56114: PUSH
56115: EMPTY
56116: LIST
56117: LIST
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: PUSH
56123: EMPTY
56124: LIST
56125: LIST
56126: LIST
56127: LIST
56128: PPUSH
56129: CALL_OW 70
56133: ST_TO_ADDR
// for j in fac do
56134: LD_ADDR_VAR 0 3
56138: PUSH
56139: LD_VAR 0 6
56143: PUSH
56144: FOR_IN
56145: IFFALSE 56240
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56147: LD_ADDR_VAR 0 7
56151: PUSH
56152: LD_VAR 0 7
56156: PUSH
56157: LD_INT 22
56159: PUSH
56160: LD_VAR 0 5
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: PUSH
56169: LD_INT 91
56171: PUSH
56172: LD_VAR 0 3
56176: PUSH
56177: LD_INT 15
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: LIST
56184: PUSH
56185: LD_INT 21
56187: PUSH
56188: LD_INT 2
56190: PUSH
56191: EMPTY
56192: LIST
56193: LIST
56194: PUSH
56195: LD_INT 3
56197: PUSH
56198: LD_INT 60
56200: PUSH
56201: EMPTY
56202: LIST
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: PUSH
56208: LD_INT 3
56210: PUSH
56211: LD_INT 24
56213: PUSH
56214: LD_INT 1000
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: PUSH
56221: EMPTY
56222: LIST
56223: LIST
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: LIST
56229: LIST
56230: LIST
56231: PPUSH
56232: CALL_OW 69
56236: UNION
56237: ST_TO_ADDR
56238: GO 56144
56240: POP
56241: POP
// if not vehs then
56242: LD_VAR 0 7
56246: NOT
56247: IFFALSE 56273
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56249: LD_ADDR_EXP 112
56253: PUSH
56254: LD_EXP 112
56258: PPUSH
56259: LD_VAR 0 2
56263: PPUSH
56264: EMPTY
56265: PPUSH
56266: CALL_OW 1
56270: ST_TO_ADDR
// continue ;
56271: GO 55903
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56273: LD_ADDR_VAR 0 8
56277: PUSH
56278: LD_EXP 100
56282: PUSH
56283: LD_VAR 0 2
56287: ARRAY
56288: PPUSH
56289: LD_INT 30
56291: PUSH
56292: LD_INT 3
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: PPUSH
56299: CALL_OW 72
56303: ST_TO_ADDR
// if tmp then
56304: LD_VAR 0 8
56308: IFFALSE 56411
// begin for j in tmp do
56310: LD_ADDR_VAR 0 3
56314: PUSH
56315: LD_VAR 0 8
56319: PUSH
56320: FOR_IN
56321: IFFALSE 56409
// for k in UnitsInside ( j ) do
56323: LD_ADDR_VAR 0 4
56327: PUSH
56328: LD_VAR 0 3
56332: PPUSH
56333: CALL_OW 313
56337: PUSH
56338: FOR_IN
56339: IFFALSE 56405
// if k then
56341: LD_VAR 0 4
56345: IFFALSE 56403
// if not k in mc_repair_vehicle [ i ] then
56347: LD_VAR 0 4
56351: PUSH
56352: LD_EXP 112
56356: PUSH
56357: LD_VAR 0 2
56361: ARRAY
56362: IN
56363: NOT
56364: IFFALSE 56403
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
56366: LD_ADDR_EXP 112
56370: PUSH
56371: LD_EXP 112
56375: PPUSH
56376: LD_VAR 0 2
56380: PPUSH
56381: LD_EXP 112
56385: PUSH
56386: LD_VAR 0 2
56390: ARRAY
56391: PUSH
56392: LD_VAR 0 4
56396: UNION
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
56403: GO 56338
56405: POP
56406: POP
56407: GO 56320
56409: POP
56410: POP
// end ; if not mc_repair_vehicle [ i ] then
56411: LD_EXP 112
56415: PUSH
56416: LD_VAR 0 2
56420: ARRAY
56421: NOT
56422: IFFALSE 56426
// continue ;
56424: GO 55903
// for j in mc_repair_vehicle [ i ] do
56426: LD_ADDR_VAR 0 3
56430: PUSH
56431: LD_EXP 112
56435: PUSH
56436: LD_VAR 0 2
56440: ARRAY
56441: PUSH
56442: FOR_IN
56443: IFFALSE 56620
// begin if GetClass ( j ) <> 3 then
56445: LD_VAR 0 3
56449: PPUSH
56450: CALL_OW 257
56454: PUSH
56455: LD_INT 3
56457: NONEQUAL
56458: IFFALSE 56499
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
56460: LD_ADDR_EXP 112
56464: PUSH
56465: LD_EXP 112
56469: PPUSH
56470: LD_VAR 0 2
56474: PPUSH
56475: LD_EXP 112
56479: PUSH
56480: LD_VAR 0 2
56484: ARRAY
56485: PUSH
56486: LD_VAR 0 3
56490: DIFF
56491: PPUSH
56492: CALL_OW 1
56496: ST_TO_ADDR
// continue ;
56497: GO 56442
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56499: LD_VAR 0 3
56503: PPUSH
56504: CALL_OW 311
56508: NOT
56509: PUSH
56510: LD_VAR 0 3
56514: PUSH
56515: LD_EXP 103
56519: PUSH
56520: LD_VAR 0 2
56524: ARRAY
56525: PUSH
56526: LD_INT 1
56528: ARRAY
56529: IN
56530: NOT
56531: AND
56532: PUSH
56533: LD_VAR 0 3
56537: PUSH
56538: LD_EXP 103
56542: PUSH
56543: LD_VAR 0 2
56547: ARRAY
56548: PUSH
56549: LD_INT 2
56551: ARRAY
56552: IN
56553: NOT
56554: AND
56555: IFFALSE 56618
// begin if IsInUnit ( j ) then
56557: LD_VAR 0 3
56561: PPUSH
56562: CALL_OW 310
56566: IFFALSE 56579
// ComExitBuilding ( j ) else
56568: LD_VAR 0 3
56572: PPUSH
56573: CALL_OW 122
56577: GO 56618
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
56579: LD_VAR 0 3
56583: PPUSH
56584: LD_VAR 0 7
56588: PUSH
56589: LD_INT 1
56591: ARRAY
56592: PPUSH
56593: CALL 107914 0 2
56597: NOT
56598: IFFALSE 56618
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
56600: LD_VAR 0 3
56604: PPUSH
56605: LD_VAR 0 7
56609: PUSH
56610: LD_INT 1
56612: ARRAY
56613: PPUSH
56614: CALL_OW 129
// end ; end ;
56618: GO 56442
56620: POP
56621: POP
// end ;
56622: GO 55903
56624: POP
56625: POP
// end ;
56626: LD_VAR 0 1
56630: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
56631: LD_INT 0
56633: PPUSH
56634: PPUSH
56635: PPUSH
56636: PPUSH
56637: PPUSH
56638: PPUSH
56639: PPUSH
56640: PPUSH
56641: PPUSH
56642: PPUSH
56643: PPUSH
// if not mc_bases then
56644: LD_EXP 100
56648: NOT
56649: IFFALSE 56653
// exit ;
56651: GO 57455
// for i = 1 to mc_bases do
56653: LD_ADDR_VAR 0 2
56657: PUSH
56658: DOUBLE
56659: LD_INT 1
56661: DEC
56662: ST_TO_ADDR
56663: LD_EXP 100
56667: PUSH
56668: FOR_TO
56669: IFFALSE 57453
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
56671: LD_EXP 128
56675: PUSH
56676: LD_VAR 0 2
56680: ARRAY
56681: NOT
56682: PUSH
56683: LD_EXP 103
56687: PUSH
56688: LD_VAR 0 2
56692: ARRAY
56693: PUSH
56694: LD_INT 1
56696: ARRAY
56697: OR
56698: PUSH
56699: LD_EXP 103
56703: PUSH
56704: LD_VAR 0 2
56708: ARRAY
56709: PUSH
56710: LD_INT 2
56712: ARRAY
56713: OR
56714: PUSH
56715: LD_EXP 126
56719: PUSH
56720: LD_VAR 0 2
56724: ARRAY
56725: PPUSH
56726: LD_INT 1
56728: PPUSH
56729: CALL_OW 325
56733: NOT
56734: OR
56735: PUSH
56736: LD_EXP 123
56740: PUSH
56741: LD_VAR 0 2
56745: ARRAY
56746: OR
56747: IFFALSE 56751
// continue ;
56749: GO 56668
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
56751: LD_ADDR_VAR 0 8
56755: PUSH
56756: LD_EXP 100
56760: PUSH
56761: LD_VAR 0 2
56765: ARRAY
56766: PPUSH
56767: LD_INT 25
56769: PUSH
56770: LD_INT 4
56772: PUSH
56773: EMPTY
56774: LIST
56775: LIST
56776: PUSH
56777: LD_INT 50
56779: PUSH
56780: EMPTY
56781: LIST
56782: PUSH
56783: LD_INT 3
56785: PUSH
56786: LD_INT 60
56788: PUSH
56789: EMPTY
56790: LIST
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: LIST
56800: PPUSH
56801: CALL_OW 72
56805: PUSH
56806: LD_EXP 104
56810: PUSH
56811: LD_VAR 0 2
56815: ARRAY
56816: DIFF
56817: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56818: LD_ADDR_VAR 0 9
56822: PUSH
56823: LD_EXP 100
56827: PUSH
56828: LD_VAR 0 2
56832: ARRAY
56833: PPUSH
56834: LD_INT 2
56836: PUSH
56837: LD_INT 30
56839: PUSH
56840: LD_INT 0
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: PUSH
56847: LD_INT 30
56849: PUSH
56850: LD_INT 1
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: LIST
56861: PPUSH
56862: CALL_OW 72
56866: ST_TO_ADDR
// if not tmp or not dep then
56867: LD_VAR 0 8
56871: NOT
56872: PUSH
56873: LD_VAR 0 9
56877: NOT
56878: OR
56879: IFFALSE 56883
// continue ;
56881: GO 56668
// side := GetSide ( tmp [ 1 ] ) ;
56883: LD_ADDR_VAR 0 11
56887: PUSH
56888: LD_VAR 0 8
56892: PUSH
56893: LD_INT 1
56895: ARRAY
56896: PPUSH
56897: CALL_OW 255
56901: ST_TO_ADDR
// dep := dep [ 1 ] ;
56902: LD_ADDR_VAR 0 9
56906: PUSH
56907: LD_VAR 0 9
56911: PUSH
56912: LD_INT 1
56914: ARRAY
56915: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
56916: LD_ADDR_VAR 0 7
56920: PUSH
56921: LD_EXP 128
56925: PUSH
56926: LD_VAR 0 2
56930: ARRAY
56931: PPUSH
56932: LD_INT 22
56934: PUSH
56935: LD_INT 0
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: PUSH
56942: LD_INT 25
56944: PUSH
56945: LD_INT 12
56947: PUSH
56948: EMPTY
56949: LIST
56950: LIST
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: PPUSH
56956: CALL_OW 70
56960: PUSH
56961: LD_INT 22
56963: PUSH
56964: LD_INT 0
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: LD_INT 25
56973: PUSH
56974: LD_INT 12
56976: PUSH
56977: EMPTY
56978: LIST
56979: LIST
56980: PUSH
56981: LD_INT 91
56983: PUSH
56984: LD_VAR 0 9
56988: PUSH
56989: LD_INT 20
56991: PUSH
56992: EMPTY
56993: LIST
56994: LIST
56995: LIST
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: LIST
57001: PPUSH
57002: CALL_OW 69
57006: UNION
57007: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57008: LD_ADDR_VAR 0 10
57012: PUSH
57013: LD_EXP 128
57017: PUSH
57018: LD_VAR 0 2
57022: ARRAY
57023: PPUSH
57024: LD_INT 81
57026: PUSH
57027: LD_VAR 0 11
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: PPUSH
57036: CALL_OW 70
57040: ST_TO_ADDR
// if not apes or danger_at_area then
57041: LD_VAR 0 7
57045: NOT
57046: PUSH
57047: LD_VAR 0 10
57051: OR
57052: IFFALSE 57102
// begin if mc_taming [ i ] then
57054: LD_EXP 131
57058: PUSH
57059: LD_VAR 0 2
57063: ARRAY
57064: IFFALSE 57100
// begin MC_Reset ( i , 121 ) ;
57066: LD_VAR 0 2
57070: PPUSH
57071: LD_INT 121
57073: PPUSH
57074: CALL 42032 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57078: LD_ADDR_EXP 131
57082: PUSH
57083: LD_EXP 131
57087: PPUSH
57088: LD_VAR 0 2
57092: PPUSH
57093: EMPTY
57094: PPUSH
57095: CALL_OW 1
57099: ST_TO_ADDR
// end ; continue ;
57100: GO 56668
// end ; for j in tmp do
57102: LD_ADDR_VAR 0 3
57106: PUSH
57107: LD_VAR 0 8
57111: PUSH
57112: FOR_IN
57113: IFFALSE 57449
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
57115: LD_VAR 0 3
57119: PUSH
57120: LD_EXP 131
57124: PUSH
57125: LD_VAR 0 2
57129: ARRAY
57130: IN
57131: NOT
57132: PUSH
57133: LD_EXP 131
57137: PUSH
57138: LD_VAR 0 2
57142: ARRAY
57143: PUSH
57144: LD_INT 3
57146: LESS
57147: AND
57148: IFFALSE 57206
// begin SetTag ( j , 121 ) ;
57150: LD_VAR 0 3
57154: PPUSH
57155: LD_INT 121
57157: PPUSH
57158: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
57162: LD_ADDR_EXP 131
57166: PUSH
57167: LD_EXP 131
57171: PPUSH
57172: LD_VAR 0 2
57176: PUSH
57177: LD_EXP 131
57181: PUSH
57182: LD_VAR 0 2
57186: ARRAY
57187: PUSH
57188: LD_INT 1
57190: PLUS
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: PPUSH
57196: LD_VAR 0 3
57200: PPUSH
57201: CALL 73519 0 3
57205: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
57206: LD_VAR 0 3
57210: PUSH
57211: LD_EXP 131
57215: PUSH
57216: LD_VAR 0 2
57220: ARRAY
57221: IN
57222: IFFALSE 57447
// begin if GetClass ( j ) <> 4 then
57224: LD_VAR 0 3
57228: PPUSH
57229: CALL_OW 257
57233: PUSH
57234: LD_INT 4
57236: NONEQUAL
57237: IFFALSE 57290
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
57239: LD_ADDR_EXP 131
57243: PUSH
57244: LD_EXP 131
57248: PPUSH
57249: LD_VAR 0 2
57253: PPUSH
57254: LD_EXP 131
57258: PUSH
57259: LD_VAR 0 2
57263: ARRAY
57264: PUSH
57265: LD_VAR 0 3
57269: DIFF
57270: PPUSH
57271: CALL_OW 1
57275: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57276: LD_VAR 0 3
57280: PPUSH
57281: LD_INT 0
57283: PPUSH
57284: CALL_OW 109
// continue ;
57288: GO 57112
// end ; if IsInUnit ( j ) then
57290: LD_VAR 0 3
57294: PPUSH
57295: CALL_OW 310
57299: IFFALSE 57310
// ComExitBuilding ( j ) ;
57301: LD_VAR 0 3
57305: PPUSH
57306: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
57310: LD_ADDR_VAR 0 6
57314: PUSH
57315: LD_VAR 0 7
57319: PPUSH
57320: LD_VAR 0 3
57324: PPUSH
57325: CALL_OW 74
57329: ST_TO_ADDR
// if not ape then
57330: LD_VAR 0 6
57334: NOT
57335: IFFALSE 57339
// break ;
57337: GO 57449
// x := GetX ( ape ) ;
57339: LD_ADDR_VAR 0 4
57343: PUSH
57344: LD_VAR 0 6
57348: PPUSH
57349: CALL_OW 250
57353: ST_TO_ADDR
// y := GetY ( ape ) ;
57354: LD_ADDR_VAR 0 5
57358: PUSH
57359: LD_VAR 0 6
57363: PPUSH
57364: CALL_OW 251
57368: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
57369: LD_VAR 0 4
57373: PPUSH
57374: LD_VAR 0 5
57378: PPUSH
57379: CALL_OW 488
57383: NOT
57384: PUSH
57385: LD_VAR 0 11
57389: PPUSH
57390: LD_VAR 0 4
57394: PPUSH
57395: LD_VAR 0 5
57399: PPUSH
57400: LD_INT 20
57402: PPUSH
57403: CALL 74415 0 4
57407: PUSH
57408: LD_INT 4
57410: ARRAY
57411: OR
57412: IFFALSE 57416
// break ;
57414: GO 57449
// if not HasTask ( j ) then
57416: LD_VAR 0 3
57420: PPUSH
57421: CALL_OW 314
57425: NOT
57426: IFFALSE 57447
// ComTameXY ( j , x , y ) ;
57428: LD_VAR 0 3
57432: PPUSH
57433: LD_VAR 0 4
57437: PPUSH
57438: LD_VAR 0 5
57442: PPUSH
57443: CALL_OW 131
// end ; end ;
57447: GO 57112
57449: POP
57450: POP
// end ;
57451: GO 56668
57453: POP
57454: POP
// end ;
57455: LD_VAR 0 1
57459: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
57460: LD_INT 0
57462: PPUSH
57463: PPUSH
57464: PPUSH
57465: PPUSH
57466: PPUSH
57467: PPUSH
57468: PPUSH
57469: PPUSH
// if not mc_bases then
57470: LD_EXP 100
57474: NOT
57475: IFFALSE 57479
// exit ;
57477: GO 58105
// for i = 1 to mc_bases do
57479: LD_ADDR_VAR 0 2
57483: PUSH
57484: DOUBLE
57485: LD_INT 1
57487: DEC
57488: ST_TO_ADDR
57489: LD_EXP 100
57493: PUSH
57494: FOR_TO
57495: IFFALSE 58103
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
57497: LD_EXP 129
57501: PUSH
57502: LD_VAR 0 2
57506: ARRAY
57507: NOT
57508: PUSH
57509: LD_EXP 129
57513: PUSH
57514: LD_VAR 0 2
57518: ARRAY
57519: PPUSH
57520: LD_INT 25
57522: PUSH
57523: LD_INT 12
57525: PUSH
57526: EMPTY
57527: LIST
57528: LIST
57529: PPUSH
57530: CALL_OW 72
57534: NOT
57535: OR
57536: IFFALSE 57540
// continue ;
57538: GO 57494
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
57540: LD_ADDR_VAR 0 5
57544: PUSH
57545: LD_EXP 129
57549: PUSH
57550: LD_VAR 0 2
57554: ARRAY
57555: PUSH
57556: LD_INT 1
57558: ARRAY
57559: PPUSH
57560: CALL_OW 255
57564: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
57565: LD_VAR 0 5
57569: PPUSH
57570: LD_INT 2
57572: PPUSH
57573: CALL_OW 325
57577: IFFALSE 57830
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
57579: LD_ADDR_VAR 0 4
57583: PUSH
57584: LD_EXP 129
57588: PUSH
57589: LD_VAR 0 2
57593: ARRAY
57594: PPUSH
57595: LD_INT 25
57597: PUSH
57598: LD_INT 16
57600: PUSH
57601: EMPTY
57602: LIST
57603: LIST
57604: PPUSH
57605: CALL_OW 72
57609: ST_TO_ADDR
// if tmp < 6 then
57610: LD_VAR 0 4
57614: PUSH
57615: LD_INT 6
57617: LESS
57618: IFFALSE 57830
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57620: LD_ADDR_VAR 0 6
57624: PUSH
57625: LD_EXP 100
57629: PUSH
57630: LD_VAR 0 2
57634: ARRAY
57635: PPUSH
57636: LD_INT 2
57638: PUSH
57639: LD_INT 30
57641: PUSH
57642: LD_INT 0
57644: PUSH
57645: EMPTY
57646: LIST
57647: LIST
57648: PUSH
57649: LD_INT 30
57651: PUSH
57652: LD_INT 1
57654: PUSH
57655: EMPTY
57656: LIST
57657: LIST
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: LIST
57663: PPUSH
57664: CALL_OW 72
57668: ST_TO_ADDR
// if depot then
57669: LD_VAR 0 6
57673: IFFALSE 57830
// begin selected := 0 ;
57675: LD_ADDR_VAR 0 7
57679: PUSH
57680: LD_INT 0
57682: ST_TO_ADDR
// for j in depot do
57683: LD_ADDR_VAR 0 3
57687: PUSH
57688: LD_VAR 0 6
57692: PUSH
57693: FOR_IN
57694: IFFALSE 57725
// begin if UnitsInside ( j ) < 6 then
57696: LD_VAR 0 3
57700: PPUSH
57701: CALL_OW 313
57705: PUSH
57706: LD_INT 6
57708: LESS
57709: IFFALSE 57723
// begin selected := j ;
57711: LD_ADDR_VAR 0 7
57715: PUSH
57716: LD_VAR 0 3
57720: ST_TO_ADDR
// break ;
57721: GO 57725
// end ; end ;
57723: GO 57693
57725: POP
57726: POP
// if selected then
57727: LD_VAR 0 7
57731: IFFALSE 57830
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
57733: LD_ADDR_VAR 0 3
57737: PUSH
57738: LD_EXP 129
57742: PUSH
57743: LD_VAR 0 2
57747: ARRAY
57748: PPUSH
57749: LD_INT 25
57751: PUSH
57752: LD_INT 12
57754: PUSH
57755: EMPTY
57756: LIST
57757: LIST
57758: PPUSH
57759: CALL_OW 72
57763: PUSH
57764: FOR_IN
57765: IFFALSE 57828
// if not HasTask ( j ) then
57767: LD_VAR 0 3
57771: PPUSH
57772: CALL_OW 314
57776: NOT
57777: IFFALSE 57826
// begin if not IsInUnit ( j ) then
57779: LD_VAR 0 3
57783: PPUSH
57784: CALL_OW 310
57788: NOT
57789: IFFALSE 57805
// ComEnterUnit ( j , selected ) ;
57791: LD_VAR 0 3
57795: PPUSH
57796: LD_VAR 0 7
57800: PPUSH
57801: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
57805: LD_VAR 0 3
57809: PPUSH
57810: LD_INT 16
57812: PPUSH
57813: CALL_OW 183
// AddComExitBuilding ( j ) ;
57817: LD_VAR 0 3
57821: PPUSH
57822: CALL_OW 182
// end ;
57826: GO 57764
57828: POP
57829: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
57830: LD_VAR 0 5
57834: PPUSH
57835: LD_INT 11
57837: PPUSH
57838: CALL_OW 325
57842: IFFALSE 58101
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
57844: LD_ADDR_VAR 0 4
57848: PUSH
57849: LD_EXP 129
57853: PUSH
57854: LD_VAR 0 2
57858: ARRAY
57859: PPUSH
57860: LD_INT 25
57862: PUSH
57863: LD_INT 16
57865: PUSH
57866: EMPTY
57867: LIST
57868: LIST
57869: PPUSH
57870: CALL_OW 72
57874: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
57875: LD_VAR 0 4
57879: PUSH
57880: LD_INT 6
57882: GREATEREQUAL
57883: PUSH
57884: LD_VAR 0 5
57888: PPUSH
57889: LD_INT 2
57891: PPUSH
57892: CALL_OW 325
57896: NOT
57897: OR
57898: IFFALSE 58101
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57900: LD_ADDR_VAR 0 8
57904: PUSH
57905: LD_EXP 100
57909: PUSH
57910: LD_VAR 0 2
57914: ARRAY
57915: PPUSH
57916: LD_INT 2
57918: PUSH
57919: LD_INT 30
57921: PUSH
57922: LD_INT 4
57924: PUSH
57925: EMPTY
57926: LIST
57927: LIST
57928: PUSH
57929: LD_INT 30
57931: PUSH
57932: LD_INT 5
57934: PUSH
57935: EMPTY
57936: LIST
57937: LIST
57938: PUSH
57939: EMPTY
57940: LIST
57941: LIST
57942: LIST
57943: PPUSH
57944: CALL_OW 72
57948: ST_TO_ADDR
// if barracks then
57949: LD_VAR 0 8
57953: IFFALSE 58101
// begin selected := 0 ;
57955: LD_ADDR_VAR 0 7
57959: PUSH
57960: LD_INT 0
57962: ST_TO_ADDR
// for j in barracks do
57963: LD_ADDR_VAR 0 3
57967: PUSH
57968: LD_VAR 0 8
57972: PUSH
57973: FOR_IN
57974: IFFALSE 58005
// begin if UnitsInside ( j ) < 6 then
57976: LD_VAR 0 3
57980: PPUSH
57981: CALL_OW 313
57985: PUSH
57986: LD_INT 6
57988: LESS
57989: IFFALSE 58003
// begin selected := j ;
57991: LD_ADDR_VAR 0 7
57995: PUSH
57996: LD_VAR 0 3
58000: ST_TO_ADDR
// break ;
58001: GO 58005
// end ; end ;
58003: GO 57973
58005: POP
58006: POP
// if selected then
58007: LD_VAR 0 7
58011: IFFALSE 58101
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58013: LD_ADDR_VAR 0 3
58017: PUSH
58018: LD_EXP 129
58022: PUSH
58023: LD_VAR 0 2
58027: ARRAY
58028: PPUSH
58029: LD_INT 25
58031: PUSH
58032: LD_INT 12
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: PPUSH
58039: CALL_OW 72
58043: PUSH
58044: FOR_IN
58045: IFFALSE 58099
// if not IsInUnit ( j ) and not HasTask ( j ) then
58047: LD_VAR 0 3
58051: PPUSH
58052: CALL_OW 310
58056: NOT
58057: PUSH
58058: LD_VAR 0 3
58062: PPUSH
58063: CALL_OW 314
58067: NOT
58068: AND
58069: IFFALSE 58097
// begin ComEnterUnit ( j , selected ) ;
58071: LD_VAR 0 3
58075: PPUSH
58076: LD_VAR 0 7
58080: PPUSH
58081: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58085: LD_VAR 0 3
58089: PPUSH
58090: LD_INT 15
58092: PPUSH
58093: CALL_OW 183
// end ;
58097: GO 58044
58099: POP
58100: POP
// end ; end ; end ; end ; end ;
58101: GO 57494
58103: POP
58104: POP
// end ;
58105: LD_VAR 0 1
58109: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58110: LD_INT 0
58112: PPUSH
58113: PPUSH
58114: PPUSH
58115: PPUSH
// if not mc_bases then
58116: LD_EXP 100
58120: NOT
58121: IFFALSE 58125
// exit ;
58123: GO 58303
// for i = 1 to mc_bases do
58125: LD_ADDR_VAR 0 2
58129: PUSH
58130: DOUBLE
58131: LD_INT 1
58133: DEC
58134: ST_TO_ADDR
58135: LD_EXP 100
58139: PUSH
58140: FOR_TO
58141: IFFALSE 58301
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
58143: LD_ADDR_VAR 0 4
58147: PUSH
58148: LD_EXP 100
58152: PUSH
58153: LD_VAR 0 2
58157: ARRAY
58158: PPUSH
58159: LD_INT 25
58161: PUSH
58162: LD_INT 9
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: PPUSH
58169: CALL_OW 72
58173: ST_TO_ADDR
// if not tmp then
58174: LD_VAR 0 4
58178: NOT
58179: IFFALSE 58183
// continue ;
58181: GO 58140
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
58183: LD_EXP 126
58187: PUSH
58188: LD_VAR 0 2
58192: ARRAY
58193: PPUSH
58194: LD_INT 29
58196: PPUSH
58197: CALL_OW 325
58201: NOT
58202: PUSH
58203: LD_EXP 126
58207: PUSH
58208: LD_VAR 0 2
58212: ARRAY
58213: PPUSH
58214: LD_INT 28
58216: PPUSH
58217: CALL_OW 325
58221: NOT
58222: AND
58223: IFFALSE 58227
// continue ;
58225: GO 58140
// for j in tmp do
58227: LD_ADDR_VAR 0 3
58231: PUSH
58232: LD_VAR 0 4
58236: PUSH
58237: FOR_IN
58238: IFFALSE 58297
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58240: LD_VAR 0 3
58244: PUSH
58245: LD_EXP 103
58249: PUSH
58250: LD_VAR 0 2
58254: ARRAY
58255: PUSH
58256: LD_INT 1
58258: ARRAY
58259: IN
58260: NOT
58261: PUSH
58262: LD_VAR 0 3
58266: PUSH
58267: LD_EXP 103
58271: PUSH
58272: LD_VAR 0 2
58276: ARRAY
58277: PUSH
58278: LD_INT 2
58280: ARRAY
58281: IN
58282: NOT
58283: AND
58284: IFFALSE 58295
// ComSpaceTimeShoot ( j ) ;
58286: LD_VAR 0 3
58290: PPUSH
58291: CALL 69504 0 1
58295: GO 58237
58297: POP
58298: POP
// end ;
58299: GO 58140
58301: POP
58302: POP
// end ;
58303: LD_VAR 0 1
58307: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
58308: LD_INT 0
58310: PPUSH
58311: PPUSH
58312: PPUSH
58313: PPUSH
58314: PPUSH
58315: PPUSH
58316: PPUSH
58317: PPUSH
58318: PPUSH
// if not mc_bases then
58319: LD_EXP 100
58323: NOT
58324: IFFALSE 58328
// exit ;
58326: GO 58950
// for i = 1 to mc_bases do
58328: LD_ADDR_VAR 0 2
58332: PUSH
58333: DOUBLE
58334: LD_INT 1
58336: DEC
58337: ST_TO_ADDR
58338: LD_EXP 100
58342: PUSH
58343: FOR_TO
58344: IFFALSE 58948
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
58346: LD_EXP 135
58350: PUSH
58351: LD_VAR 0 2
58355: ARRAY
58356: NOT
58357: PUSH
58358: LD_INT 38
58360: PPUSH
58361: LD_EXP 126
58365: PUSH
58366: LD_VAR 0 2
58370: ARRAY
58371: PPUSH
58372: CALL_OW 321
58376: PUSH
58377: LD_INT 2
58379: NONEQUAL
58380: OR
58381: IFFALSE 58385
// continue ;
58383: GO 58343
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
58385: LD_ADDR_VAR 0 8
58389: PUSH
58390: LD_EXP 100
58394: PUSH
58395: LD_VAR 0 2
58399: ARRAY
58400: PPUSH
58401: LD_INT 30
58403: PUSH
58404: LD_INT 34
58406: PUSH
58407: EMPTY
58408: LIST
58409: LIST
58410: PPUSH
58411: CALL_OW 72
58415: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
58416: LD_ADDR_VAR 0 9
58420: PUSH
58421: LD_EXP 100
58425: PUSH
58426: LD_VAR 0 2
58430: ARRAY
58431: PPUSH
58432: LD_INT 25
58434: PUSH
58435: LD_INT 4
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: PPUSH
58442: CALL_OW 72
58446: PPUSH
58447: LD_INT 0
58449: PPUSH
58450: CALL 103431 0 2
58454: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
58455: LD_VAR 0 9
58459: NOT
58460: PUSH
58461: LD_VAR 0 8
58465: NOT
58466: OR
58467: PUSH
58468: LD_EXP 100
58472: PUSH
58473: LD_VAR 0 2
58477: ARRAY
58478: PPUSH
58479: LD_INT 124
58481: PPUSH
58482: CALL 103431 0 2
58486: OR
58487: IFFALSE 58491
// continue ;
58489: GO 58343
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
58491: LD_EXP 136
58495: PUSH
58496: LD_VAR 0 2
58500: ARRAY
58501: PUSH
58502: LD_EXP 135
58506: PUSH
58507: LD_VAR 0 2
58511: ARRAY
58512: LESS
58513: PUSH
58514: LD_EXP 136
58518: PUSH
58519: LD_VAR 0 2
58523: ARRAY
58524: PUSH
58525: LD_VAR 0 8
58529: LESS
58530: AND
58531: IFFALSE 58946
// begin tmp := sci [ 1 ] ;
58533: LD_ADDR_VAR 0 7
58537: PUSH
58538: LD_VAR 0 9
58542: PUSH
58543: LD_INT 1
58545: ARRAY
58546: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
58547: LD_VAR 0 7
58551: PPUSH
58552: LD_INT 124
58554: PPUSH
58555: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
58559: LD_ADDR_VAR 0 3
58563: PUSH
58564: DOUBLE
58565: LD_EXP 135
58569: PUSH
58570: LD_VAR 0 2
58574: ARRAY
58575: INC
58576: ST_TO_ADDR
58577: LD_EXP 135
58581: PUSH
58582: LD_VAR 0 2
58586: ARRAY
58587: PUSH
58588: FOR_DOWNTO
58589: IFFALSE 58932
// begin if IsInUnit ( tmp ) then
58591: LD_VAR 0 7
58595: PPUSH
58596: CALL_OW 310
58600: IFFALSE 58611
// ComExitBuilding ( tmp ) ;
58602: LD_VAR 0 7
58606: PPUSH
58607: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
58611: LD_INT 35
58613: PPUSH
58614: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
58618: LD_VAR 0 7
58622: PPUSH
58623: CALL_OW 310
58627: NOT
58628: PUSH
58629: LD_VAR 0 7
58633: PPUSH
58634: CALL_OW 314
58638: NOT
58639: AND
58640: IFFALSE 58611
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
58642: LD_ADDR_VAR 0 6
58646: PUSH
58647: LD_VAR 0 7
58651: PPUSH
58652: CALL_OW 250
58656: PUSH
58657: LD_VAR 0 7
58661: PPUSH
58662: CALL_OW 251
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
58671: LD_INT 35
58673: PPUSH
58674: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
58678: LD_ADDR_VAR 0 4
58682: PUSH
58683: LD_EXP 135
58687: PUSH
58688: LD_VAR 0 2
58692: ARRAY
58693: PUSH
58694: LD_VAR 0 3
58698: ARRAY
58699: PUSH
58700: LD_INT 1
58702: ARRAY
58703: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
58704: LD_ADDR_VAR 0 5
58708: PUSH
58709: LD_EXP 135
58713: PUSH
58714: LD_VAR 0 2
58718: ARRAY
58719: PUSH
58720: LD_VAR 0 3
58724: ARRAY
58725: PUSH
58726: LD_INT 2
58728: ARRAY
58729: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
58730: LD_VAR 0 7
58734: PPUSH
58735: LD_INT 10
58737: PPUSH
58738: CALL 76116 0 2
58742: PUSH
58743: LD_INT 4
58745: ARRAY
58746: IFFALSE 58784
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
58748: LD_VAR 0 7
58752: PPUSH
58753: LD_VAR 0 6
58757: PUSH
58758: LD_INT 1
58760: ARRAY
58761: PPUSH
58762: LD_VAR 0 6
58766: PUSH
58767: LD_INT 2
58769: ARRAY
58770: PPUSH
58771: CALL_OW 111
// wait ( 0 0$10 ) ;
58775: LD_INT 350
58777: PPUSH
58778: CALL_OW 67
// end else
58782: GO 58810
// begin ComMoveXY ( tmp , x , y ) ;
58784: LD_VAR 0 7
58788: PPUSH
58789: LD_VAR 0 4
58793: PPUSH
58794: LD_VAR 0 5
58798: PPUSH
58799: CALL_OW 111
// wait ( 0 0$3 ) ;
58803: LD_INT 105
58805: PPUSH
58806: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
58810: LD_VAR 0 7
58814: PPUSH
58815: LD_VAR 0 4
58819: PPUSH
58820: LD_VAR 0 5
58824: PPUSH
58825: CALL_OW 307
58829: IFFALSE 58671
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
58831: LD_VAR 0 7
58835: PPUSH
58836: LD_VAR 0 4
58840: PPUSH
58841: LD_VAR 0 5
58845: PPUSH
58846: LD_VAR 0 8
58850: PUSH
58851: LD_VAR 0 3
58855: ARRAY
58856: PPUSH
58857: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
58861: LD_INT 35
58863: PPUSH
58864: CALL_OW 67
// until not HasTask ( tmp ) ;
58868: LD_VAR 0 7
58872: PPUSH
58873: CALL_OW 314
58877: NOT
58878: IFFALSE 58861
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
58880: LD_ADDR_EXP 136
58884: PUSH
58885: LD_EXP 136
58889: PPUSH
58890: LD_VAR 0 2
58894: PUSH
58895: LD_EXP 136
58899: PUSH
58900: LD_VAR 0 2
58904: ARRAY
58905: PUSH
58906: LD_INT 1
58908: PLUS
58909: PUSH
58910: EMPTY
58911: LIST
58912: LIST
58913: PPUSH
58914: LD_VAR 0 8
58918: PUSH
58919: LD_VAR 0 3
58923: ARRAY
58924: PPUSH
58925: CALL 73519 0 3
58929: ST_TO_ADDR
// end ;
58930: GO 58588
58932: POP
58933: POP
// MC_Reset ( i , 124 ) ;
58934: LD_VAR 0 2
58938: PPUSH
58939: LD_INT 124
58941: PPUSH
58942: CALL 42032 0 2
// end ; end ;
58946: GO 58343
58948: POP
58949: POP
// end ;
58950: LD_VAR 0 1
58954: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
58955: LD_INT 0
58957: PPUSH
58958: PPUSH
58959: PPUSH
// if not mc_bases then
58960: LD_EXP 100
58964: NOT
58965: IFFALSE 58969
// exit ;
58967: GO 59575
// for i = 1 to mc_bases do
58969: LD_ADDR_VAR 0 2
58973: PUSH
58974: DOUBLE
58975: LD_INT 1
58977: DEC
58978: ST_TO_ADDR
58979: LD_EXP 100
58983: PUSH
58984: FOR_TO
58985: IFFALSE 59573
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
58987: LD_ADDR_VAR 0 3
58991: PUSH
58992: LD_EXP 100
58996: PUSH
58997: LD_VAR 0 2
59001: ARRAY
59002: PPUSH
59003: LD_INT 25
59005: PUSH
59006: LD_INT 4
59008: PUSH
59009: EMPTY
59010: LIST
59011: LIST
59012: PPUSH
59013: CALL_OW 72
59017: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59018: LD_VAR 0 3
59022: NOT
59023: PUSH
59024: LD_EXP 137
59028: PUSH
59029: LD_VAR 0 2
59033: ARRAY
59034: NOT
59035: OR
59036: PUSH
59037: LD_EXP 100
59041: PUSH
59042: LD_VAR 0 2
59046: ARRAY
59047: PPUSH
59048: LD_INT 2
59050: PUSH
59051: LD_INT 30
59053: PUSH
59054: LD_INT 0
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PUSH
59061: LD_INT 30
59063: PUSH
59064: LD_INT 1
59066: PUSH
59067: EMPTY
59068: LIST
59069: LIST
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: LIST
59075: PPUSH
59076: CALL_OW 72
59080: NOT
59081: OR
59082: IFFALSE 59132
// begin if mc_deposits_finder [ i ] then
59084: LD_EXP 138
59088: PUSH
59089: LD_VAR 0 2
59093: ARRAY
59094: IFFALSE 59130
// begin MC_Reset ( i , 125 ) ;
59096: LD_VAR 0 2
59100: PPUSH
59101: LD_INT 125
59103: PPUSH
59104: CALL 42032 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59108: LD_ADDR_EXP 138
59112: PUSH
59113: LD_EXP 138
59117: PPUSH
59118: LD_VAR 0 2
59122: PPUSH
59123: EMPTY
59124: PPUSH
59125: CALL_OW 1
59129: ST_TO_ADDR
// end ; continue ;
59130: GO 58984
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
59132: LD_EXP 137
59136: PUSH
59137: LD_VAR 0 2
59141: ARRAY
59142: PUSH
59143: LD_INT 1
59145: ARRAY
59146: PUSH
59147: LD_INT 3
59149: ARRAY
59150: PUSH
59151: LD_INT 1
59153: EQUAL
59154: PUSH
59155: LD_INT 20
59157: PPUSH
59158: LD_EXP 126
59162: PUSH
59163: LD_VAR 0 2
59167: ARRAY
59168: PPUSH
59169: CALL_OW 321
59173: PUSH
59174: LD_INT 2
59176: NONEQUAL
59177: AND
59178: IFFALSE 59228
// begin if mc_deposits_finder [ i ] then
59180: LD_EXP 138
59184: PUSH
59185: LD_VAR 0 2
59189: ARRAY
59190: IFFALSE 59226
// begin MC_Reset ( i , 125 ) ;
59192: LD_VAR 0 2
59196: PPUSH
59197: LD_INT 125
59199: PPUSH
59200: CALL 42032 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59204: LD_ADDR_EXP 138
59208: PUSH
59209: LD_EXP 138
59213: PPUSH
59214: LD_VAR 0 2
59218: PPUSH
59219: EMPTY
59220: PPUSH
59221: CALL_OW 1
59225: ST_TO_ADDR
// end ; continue ;
59226: GO 58984
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
59228: LD_EXP 137
59232: PUSH
59233: LD_VAR 0 2
59237: ARRAY
59238: PUSH
59239: LD_INT 1
59241: ARRAY
59242: PUSH
59243: LD_INT 1
59245: ARRAY
59246: PPUSH
59247: LD_EXP 137
59251: PUSH
59252: LD_VAR 0 2
59256: ARRAY
59257: PUSH
59258: LD_INT 1
59260: ARRAY
59261: PUSH
59262: LD_INT 2
59264: ARRAY
59265: PPUSH
59266: LD_EXP 126
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: PPUSH
59277: CALL_OW 440
59281: IFFALSE 59324
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
59283: LD_ADDR_EXP 137
59287: PUSH
59288: LD_EXP 137
59292: PPUSH
59293: LD_VAR 0 2
59297: PPUSH
59298: LD_EXP 137
59302: PUSH
59303: LD_VAR 0 2
59307: ARRAY
59308: PPUSH
59309: LD_INT 1
59311: PPUSH
59312: CALL_OW 3
59316: PPUSH
59317: CALL_OW 1
59321: ST_TO_ADDR
59322: GO 59571
// begin if not mc_deposits_finder [ i ] then
59324: LD_EXP 138
59328: PUSH
59329: LD_VAR 0 2
59333: ARRAY
59334: NOT
59335: IFFALSE 59387
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
59337: LD_ADDR_EXP 138
59341: PUSH
59342: LD_EXP 138
59346: PPUSH
59347: LD_VAR 0 2
59351: PPUSH
59352: LD_VAR 0 3
59356: PUSH
59357: LD_INT 1
59359: ARRAY
59360: PUSH
59361: EMPTY
59362: LIST
59363: PPUSH
59364: CALL_OW 1
59368: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
59369: LD_VAR 0 3
59373: PUSH
59374: LD_INT 1
59376: ARRAY
59377: PPUSH
59378: LD_INT 125
59380: PPUSH
59381: CALL_OW 109
// end else
59385: GO 59571
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
59387: LD_EXP 138
59391: PUSH
59392: LD_VAR 0 2
59396: ARRAY
59397: PUSH
59398: LD_INT 1
59400: ARRAY
59401: PPUSH
59402: CALL_OW 310
59406: IFFALSE 59429
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
59408: LD_EXP 138
59412: PUSH
59413: LD_VAR 0 2
59417: ARRAY
59418: PUSH
59419: LD_INT 1
59421: ARRAY
59422: PPUSH
59423: CALL_OW 122
59427: GO 59571
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
59429: LD_EXP 138
59433: PUSH
59434: LD_VAR 0 2
59438: ARRAY
59439: PUSH
59440: LD_INT 1
59442: ARRAY
59443: PPUSH
59444: CALL_OW 314
59448: NOT
59449: PUSH
59450: LD_EXP 138
59454: PUSH
59455: LD_VAR 0 2
59459: ARRAY
59460: PUSH
59461: LD_INT 1
59463: ARRAY
59464: PPUSH
59465: LD_EXP 137
59469: PUSH
59470: LD_VAR 0 2
59474: ARRAY
59475: PUSH
59476: LD_INT 1
59478: ARRAY
59479: PUSH
59480: LD_INT 1
59482: ARRAY
59483: PPUSH
59484: LD_EXP 137
59488: PUSH
59489: LD_VAR 0 2
59493: ARRAY
59494: PUSH
59495: LD_INT 1
59497: ARRAY
59498: PUSH
59499: LD_INT 2
59501: ARRAY
59502: PPUSH
59503: CALL_OW 297
59507: PUSH
59508: LD_INT 6
59510: GREATER
59511: AND
59512: IFFALSE 59571
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
59514: LD_EXP 138
59518: PUSH
59519: LD_VAR 0 2
59523: ARRAY
59524: PUSH
59525: LD_INT 1
59527: ARRAY
59528: PPUSH
59529: LD_EXP 137
59533: PUSH
59534: LD_VAR 0 2
59538: ARRAY
59539: PUSH
59540: LD_INT 1
59542: ARRAY
59543: PUSH
59544: LD_INT 1
59546: ARRAY
59547: PPUSH
59548: LD_EXP 137
59552: PUSH
59553: LD_VAR 0 2
59557: ARRAY
59558: PUSH
59559: LD_INT 1
59561: ARRAY
59562: PUSH
59563: LD_INT 2
59565: ARRAY
59566: PPUSH
59567: CALL_OW 111
// end ; end ; end ;
59571: GO 58984
59573: POP
59574: POP
// end ;
59575: LD_VAR 0 1
59579: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
59580: LD_INT 0
59582: PPUSH
59583: PPUSH
59584: PPUSH
59585: PPUSH
59586: PPUSH
59587: PPUSH
59588: PPUSH
59589: PPUSH
59590: PPUSH
59591: PPUSH
59592: PPUSH
// if not mc_bases then
59593: LD_EXP 100
59597: NOT
59598: IFFALSE 59602
// exit ;
59600: GO 60542
// for i = 1 to mc_bases do
59602: LD_ADDR_VAR 0 2
59606: PUSH
59607: DOUBLE
59608: LD_INT 1
59610: DEC
59611: ST_TO_ADDR
59612: LD_EXP 100
59616: PUSH
59617: FOR_TO
59618: IFFALSE 60540
// begin if not mc_bases [ i ] or mc_scan [ i ] then
59620: LD_EXP 100
59624: PUSH
59625: LD_VAR 0 2
59629: ARRAY
59630: NOT
59631: PUSH
59632: LD_EXP 123
59636: PUSH
59637: LD_VAR 0 2
59641: ARRAY
59642: OR
59643: IFFALSE 59647
// continue ;
59645: GO 59617
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
59647: LD_ADDR_VAR 0 7
59651: PUSH
59652: LD_EXP 100
59656: PUSH
59657: LD_VAR 0 2
59661: ARRAY
59662: PUSH
59663: LD_INT 1
59665: ARRAY
59666: PPUSH
59667: CALL_OW 248
59671: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
59672: LD_VAR 0 7
59676: PUSH
59677: LD_INT 3
59679: EQUAL
59680: PUSH
59681: LD_EXP 119
59685: PUSH
59686: LD_VAR 0 2
59690: ARRAY
59691: PUSH
59692: LD_EXP 122
59696: PUSH
59697: LD_VAR 0 2
59701: ARRAY
59702: UNION
59703: PPUSH
59704: LD_INT 33
59706: PUSH
59707: LD_INT 2
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: PPUSH
59714: CALL_OW 72
59718: NOT
59719: OR
59720: IFFALSE 59724
// continue ;
59722: GO 59617
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
59724: LD_ADDR_VAR 0 9
59728: PUSH
59729: LD_EXP 100
59733: PUSH
59734: LD_VAR 0 2
59738: ARRAY
59739: PPUSH
59740: LD_INT 30
59742: PUSH
59743: LD_INT 36
59745: PUSH
59746: EMPTY
59747: LIST
59748: LIST
59749: PPUSH
59750: CALL_OW 72
59754: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
59755: LD_ADDR_VAR 0 10
59759: PUSH
59760: LD_EXP 119
59764: PUSH
59765: LD_VAR 0 2
59769: ARRAY
59770: PPUSH
59771: LD_INT 34
59773: PUSH
59774: LD_INT 31
59776: PUSH
59777: EMPTY
59778: LIST
59779: LIST
59780: PPUSH
59781: CALL_OW 72
59785: ST_TO_ADDR
// if not cts and not mcts then
59786: LD_VAR 0 9
59790: NOT
59791: PUSH
59792: LD_VAR 0 10
59796: NOT
59797: AND
59798: IFFALSE 59802
// continue ;
59800: GO 59617
// x := cts ;
59802: LD_ADDR_VAR 0 11
59806: PUSH
59807: LD_VAR 0 9
59811: ST_TO_ADDR
// if not x then
59812: LD_VAR 0 11
59816: NOT
59817: IFFALSE 59829
// x := mcts ;
59819: LD_ADDR_VAR 0 11
59823: PUSH
59824: LD_VAR 0 10
59828: ST_TO_ADDR
// if not x then
59829: LD_VAR 0 11
59833: NOT
59834: IFFALSE 59838
// continue ;
59836: GO 59617
// if mc_remote_driver [ i ] then
59838: LD_EXP 140
59842: PUSH
59843: LD_VAR 0 2
59847: ARRAY
59848: IFFALSE 60235
// for j in mc_remote_driver [ i ] do
59850: LD_ADDR_VAR 0 3
59854: PUSH
59855: LD_EXP 140
59859: PUSH
59860: LD_VAR 0 2
59864: ARRAY
59865: PUSH
59866: FOR_IN
59867: IFFALSE 60233
// begin if GetClass ( j ) <> 3 then
59869: LD_VAR 0 3
59873: PPUSH
59874: CALL_OW 257
59878: PUSH
59879: LD_INT 3
59881: NONEQUAL
59882: IFFALSE 59935
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
59884: LD_ADDR_EXP 140
59888: PUSH
59889: LD_EXP 140
59893: PPUSH
59894: LD_VAR 0 2
59898: PPUSH
59899: LD_EXP 140
59903: PUSH
59904: LD_VAR 0 2
59908: ARRAY
59909: PUSH
59910: LD_VAR 0 3
59914: DIFF
59915: PPUSH
59916: CALL_OW 1
59920: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59921: LD_VAR 0 3
59925: PPUSH
59926: LD_INT 0
59928: PPUSH
59929: CALL_OW 109
// continue ;
59933: GO 59866
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
59935: LD_EXP 119
59939: PUSH
59940: LD_VAR 0 2
59944: ARRAY
59945: PPUSH
59946: LD_INT 34
59948: PUSH
59949: LD_INT 31
59951: PUSH
59952: EMPTY
59953: LIST
59954: LIST
59955: PUSH
59956: LD_INT 58
59958: PUSH
59959: EMPTY
59960: LIST
59961: PUSH
59962: EMPTY
59963: LIST
59964: LIST
59965: PPUSH
59966: CALL_OW 72
59970: PUSH
59971: LD_VAR 0 3
59975: PPUSH
59976: CALL 103466 0 1
59980: NOT
59981: AND
59982: IFFALSE 60053
// begin if IsInUnit ( j ) then
59984: LD_VAR 0 3
59988: PPUSH
59989: CALL_OW 310
59993: IFFALSE 60004
// ComExitBuilding ( j ) ;
59995: LD_VAR 0 3
59999: PPUSH
60000: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60004: LD_VAR 0 3
60008: PPUSH
60009: LD_EXP 119
60013: PUSH
60014: LD_VAR 0 2
60018: ARRAY
60019: PPUSH
60020: LD_INT 34
60022: PUSH
60023: LD_INT 31
60025: PUSH
60026: EMPTY
60027: LIST
60028: LIST
60029: PUSH
60030: LD_INT 58
60032: PUSH
60033: EMPTY
60034: LIST
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: PPUSH
60040: CALL_OW 72
60044: PUSH
60045: LD_INT 1
60047: ARRAY
60048: PPUSH
60049: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60053: LD_VAR 0 3
60057: PPUSH
60058: CALL_OW 310
60062: NOT
60063: PUSH
60064: LD_VAR 0 3
60068: PPUSH
60069: CALL_OW 310
60073: PPUSH
60074: CALL_OW 266
60078: PUSH
60079: LD_INT 36
60081: NONEQUAL
60082: PUSH
60083: LD_VAR 0 3
60087: PPUSH
60088: CALL 103466 0 1
60092: NOT
60093: AND
60094: OR
60095: IFFALSE 60231
// begin if IsInUnit ( j ) then
60097: LD_VAR 0 3
60101: PPUSH
60102: CALL_OW 310
60106: IFFALSE 60117
// ComExitBuilding ( j ) ;
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 122
// ct := 0 ;
60117: LD_ADDR_VAR 0 8
60121: PUSH
60122: LD_INT 0
60124: ST_TO_ADDR
// for k in x do
60125: LD_ADDR_VAR 0 4
60129: PUSH
60130: LD_VAR 0 11
60134: PUSH
60135: FOR_IN
60136: IFFALSE 60209
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
60138: LD_VAR 0 4
60142: PPUSH
60143: CALL_OW 264
60147: PUSH
60148: LD_INT 31
60150: EQUAL
60151: PUSH
60152: LD_VAR 0 4
60156: PPUSH
60157: CALL_OW 311
60161: NOT
60162: AND
60163: PUSH
60164: LD_VAR 0 4
60168: PPUSH
60169: CALL_OW 266
60173: PUSH
60174: LD_INT 36
60176: EQUAL
60177: PUSH
60178: LD_VAR 0 4
60182: PPUSH
60183: CALL_OW 313
60187: PUSH
60188: LD_INT 3
60190: LESS
60191: AND
60192: OR
60193: IFFALSE 60207
// begin ct := k ;
60195: LD_ADDR_VAR 0 8
60199: PUSH
60200: LD_VAR 0 4
60204: ST_TO_ADDR
// break ;
60205: GO 60209
// end ;
60207: GO 60135
60209: POP
60210: POP
// if ct then
60211: LD_VAR 0 8
60215: IFFALSE 60231
// ComEnterUnit ( j , ct ) ;
60217: LD_VAR 0 3
60221: PPUSH
60222: LD_VAR 0 8
60226: PPUSH
60227: CALL_OW 120
// end ; end ;
60231: GO 59866
60233: POP
60234: POP
// places := 0 ;
60235: LD_ADDR_VAR 0 5
60239: PUSH
60240: LD_INT 0
60242: ST_TO_ADDR
// for j = 1 to x do
60243: LD_ADDR_VAR 0 3
60247: PUSH
60248: DOUBLE
60249: LD_INT 1
60251: DEC
60252: ST_TO_ADDR
60253: LD_VAR 0 11
60257: PUSH
60258: FOR_TO
60259: IFFALSE 60335
// if GetWeapon ( x [ j ] ) = ar_control_tower then
60261: LD_VAR 0 11
60265: PUSH
60266: LD_VAR 0 3
60270: ARRAY
60271: PPUSH
60272: CALL_OW 264
60276: PUSH
60277: LD_INT 31
60279: EQUAL
60280: IFFALSE 60298
// places := places + 1 else
60282: LD_ADDR_VAR 0 5
60286: PUSH
60287: LD_VAR 0 5
60291: PUSH
60292: LD_INT 1
60294: PLUS
60295: ST_TO_ADDR
60296: GO 60333
// if GetBType ( x [ j ] ) = b_control_tower then
60298: LD_VAR 0 11
60302: PUSH
60303: LD_VAR 0 3
60307: ARRAY
60308: PPUSH
60309: CALL_OW 266
60313: PUSH
60314: LD_INT 36
60316: EQUAL
60317: IFFALSE 60333
// places := places + 3 ;
60319: LD_ADDR_VAR 0 5
60323: PUSH
60324: LD_VAR 0 5
60328: PUSH
60329: LD_INT 3
60331: PLUS
60332: ST_TO_ADDR
60333: GO 60258
60335: POP
60336: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
60337: LD_VAR 0 5
60341: PUSH
60342: LD_INT 0
60344: EQUAL
60345: PUSH
60346: LD_VAR 0 5
60350: PUSH
60351: LD_EXP 140
60355: PUSH
60356: LD_VAR 0 2
60360: ARRAY
60361: LESSEQUAL
60362: OR
60363: IFFALSE 60367
// continue ;
60365: GO 59617
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
60367: LD_ADDR_VAR 0 6
60371: PUSH
60372: LD_EXP 100
60376: PUSH
60377: LD_VAR 0 2
60381: ARRAY
60382: PPUSH
60383: LD_INT 25
60385: PUSH
60386: LD_INT 3
60388: PUSH
60389: EMPTY
60390: LIST
60391: LIST
60392: PPUSH
60393: CALL_OW 72
60397: PUSH
60398: LD_EXP 140
60402: PUSH
60403: LD_VAR 0 2
60407: ARRAY
60408: DIFF
60409: PPUSH
60410: LD_INT 3
60412: PPUSH
60413: CALL 104366 0 2
60417: ST_TO_ADDR
// for j in tmp do
60418: LD_ADDR_VAR 0 3
60422: PUSH
60423: LD_VAR 0 6
60427: PUSH
60428: FOR_IN
60429: IFFALSE 60464
// if GetTag ( j ) > 0 then
60431: LD_VAR 0 3
60435: PPUSH
60436: CALL_OW 110
60440: PUSH
60441: LD_INT 0
60443: GREATER
60444: IFFALSE 60462
// tmp := tmp diff j ;
60446: LD_ADDR_VAR 0 6
60450: PUSH
60451: LD_VAR 0 6
60455: PUSH
60456: LD_VAR 0 3
60460: DIFF
60461: ST_TO_ADDR
60462: GO 60428
60464: POP
60465: POP
// if not tmp then
60466: LD_VAR 0 6
60470: NOT
60471: IFFALSE 60475
// continue ;
60473: GO 59617
// if places then
60475: LD_VAR 0 5
60479: IFFALSE 60538
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
60481: LD_ADDR_EXP 140
60485: PUSH
60486: LD_EXP 140
60490: PPUSH
60491: LD_VAR 0 2
60495: PPUSH
60496: LD_EXP 140
60500: PUSH
60501: LD_VAR 0 2
60505: ARRAY
60506: PUSH
60507: LD_VAR 0 6
60511: PUSH
60512: LD_INT 1
60514: ARRAY
60515: UNION
60516: PPUSH
60517: CALL_OW 1
60521: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
60522: LD_VAR 0 6
60526: PUSH
60527: LD_INT 1
60529: ARRAY
60530: PPUSH
60531: LD_INT 126
60533: PPUSH
60534: CALL_OW 109
// end ; end ;
60538: GO 59617
60540: POP
60541: POP
// end ;
60542: LD_VAR 0 1
60546: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
60547: LD_INT 0
60549: PPUSH
60550: PPUSH
60551: PPUSH
60552: PPUSH
60553: PPUSH
60554: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
60555: LD_VAR 0 1
60559: NOT
60560: PUSH
60561: LD_VAR 0 2
60565: NOT
60566: OR
60567: PUSH
60568: LD_VAR 0 3
60572: NOT
60573: OR
60574: PUSH
60575: LD_VAR 0 4
60579: PUSH
60580: LD_INT 1
60582: PUSH
60583: LD_INT 2
60585: PUSH
60586: LD_INT 3
60588: PUSH
60589: LD_INT 4
60591: PUSH
60592: LD_INT 5
60594: PUSH
60595: LD_INT 8
60597: PUSH
60598: LD_INT 9
60600: PUSH
60601: LD_INT 15
60603: PUSH
60604: LD_INT 16
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: LIST
60611: LIST
60612: LIST
60613: LIST
60614: LIST
60615: LIST
60616: LIST
60617: IN
60618: NOT
60619: OR
60620: IFFALSE 60624
// exit ;
60622: GO 61482
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
60624: LD_ADDR_VAR 0 2
60628: PUSH
60629: LD_VAR 0 2
60633: PPUSH
60634: LD_INT 21
60636: PUSH
60637: LD_INT 3
60639: PUSH
60640: EMPTY
60641: LIST
60642: LIST
60643: PUSH
60644: LD_INT 24
60646: PUSH
60647: LD_INT 250
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: PUSH
60654: EMPTY
60655: LIST
60656: LIST
60657: PPUSH
60658: CALL_OW 72
60662: ST_TO_ADDR
// case class of 1 , 15 :
60663: LD_VAR 0 4
60667: PUSH
60668: LD_INT 1
60670: DOUBLE
60671: EQUAL
60672: IFTRUE 60682
60674: LD_INT 15
60676: DOUBLE
60677: EQUAL
60678: IFTRUE 60682
60680: GO 60767
60682: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
60683: LD_ADDR_VAR 0 8
60687: PUSH
60688: LD_VAR 0 2
60692: PPUSH
60693: LD_INT 2
60695: PUSH
60696: LD_INT 30
60698: PUSH
60699: LD_INT 32
60701: PUSH
60702: EMPTY
60703: LIST
60704: LIST
60705: PUSH
60706: LD_INT 30
60708: PUSH
60709: LD_INT 31
60711: PUSH
60712: EMPTY
60713: LIST
60714: LIST
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: LIST
60720: PPUSH
60721: CALL_OW 72
60725: PUSH
60726: LD_VAR 0 2
60730: PPUSH
60731: LD_INT 2
60733: PUSH
60734: LD_INT 30
60736: PUSH
60737: LD_INT 4
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 30
60746: PUSH
60747: LD_INT 5
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: PPUSH
60759: CALL_OW 72
60763: ADD
60764: ST_TO_ADDR
60765: GO 61013
60767: LD_INT 2
60769: DOUBLE
60770: EQUAL
60771: IFTRUE 60781
60773: LD_INT 16
60775: DOUBLE
60776: EQUAL
60777: IFTRUE 60781
60779: GO 60827
60781: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
60782: LD_ADDR_VAR 0 8
60786: PUSH
60787: LD_VAR 0 2
60791: PPUSH
60792: LD_INT 2
60794: PUSH
60795: LD_INT 30
60797: PUSH
60798: LD_INT 0
60800: PUSH
60801: EMPTY
60802: LIST
60803: LIST
60804: PUSH
60805: LD_INT 30
60807: PUSH
60808: LD_INT 1
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PUSH
60815: EMPTY
60816: LIST
60817: LIST
60818: LIST
60819: PPUSH
60820: CALL_OW 72
60824: ST_TO_ADDR
60825: GO 61013
60827: LD_INT 3
60829: DOUBLE
60830: EQUAL
60831: IFTRUE 60835
60833: GO 60881
60835: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
60836: LD_ADDR_VAR 0 8
60840: PUSH
60841: LD_VAR 0 2
60845: PPUSH
60846: LD_INT 2
60848: PUSH
60849: LD_INT 30
60851: PUSH
60852: LD_INT 2
60854: PUSH
60855: EMPTY
60856: LIST
60857: LIST
60858: PUSH
60859: LD_INT 30
60861: PUSH
60862: LD_INT 3
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: EMPTY
60870: LIST
60871: LIST
60872: LIST
60873: PPUSH
60874: CALL_OW 72
60878: ST_TO_ADDR
60879: GO 61013
60881: LD_INT 4
60883: DOUBLE
60884: EQUAL
60885: IFTRUE 60889
60887: GO 60946
60889: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
60890: LD_ADDR_VAR 0 8
60894: PUSH
60895: LD_VAR 0 2
60899: PPUSH
60900: LD_INT 2
60902: PUSH
60903: LD_INT 30
60905: PUSH
60906: LD_INT 6
60908: PUSH
60909: EMPTY
60910: LIST
60911: LIST
60912: PUSH
60913: LD_INT 30
60915: PUSH
60916: LD_INT 7
60918: PUSH
60919: EMPTY
60920: LIST
60921: LIST
60922: PUSH
60923: LD_INT 30
60925: PUSH
60926: LD_INT 8
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: EMPTY
60934: LIST
60935: LIST
60936: LIST
60937: LIST
60938: PPUSH
60939: CALL_OW 72
60943: ST_TO_ADDR
60944: GO 61013
60946: LD_INT 5
60948: DOUBLE
60949: EQUAL
60950: IFTRUE 60966
60952: LD_INT 8
60954: DOUBLE
60955: EQUAL
60956: IFTRUE 60966
60958: LD_INT 9
60960: DOUBLE
60961: EQUAL
60962: IFTRUE 60966
60964: GO 61012
60966: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
60967: LD_ADDR_VAR 0 8
60971: PUSH
60972: LD_VAR 0 2
60976: PPUSH
60977: LD_INT 2
60979: PUSH
60980: LD_INT 30
60982: PUSH
60983: LD_INT 4
60985: PUSH
60986: EMPTY
60987: LIST
60988: LIST
60989: PUSH
60990: LD_INT 30
60992: PUSH
60993: LD_INT 5
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PUSH
61000: EMPTY
61001: LIST
61002: LIST
61003: LIST
61004: PPUSH
61005: CALL_OW 72
61009: ST_TO_ADDR
61010: GO 61013
61012: POP
// if not tmp then
61013: LD_VAR 0 8
61017: NOT
61018: IFFALSE 61022
// exit ;
61020: GO 61482
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61022: LD_VAR 0 4
61026: PUSH
61027: LD_INT 1
61029: PUSH
61030: LD_INT 15
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: IN
61037: PUSH
61038: LD_EXP 109
61042: PUSH
61043: LD_VAR 0 1
61047: ARRAY
61048: AND
61049: IFFALSE 61205
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61051: LD_ADDR_VAR 0 9
61055: PUSH
61056: LD_EXP 109
61060: PUSH
61061: LD_VAR 0 1
61065: ARRAY
61066: PUSH
61067: LD_INT 1
61069: ARRAY
61070: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61071: LD_VAR 0 9
61075: PUSH
61076: LD_EXP 110
61080: PUSH
61081: LD_VAR 0 1
61085: ARRAY
61086: IN
61087: NOT
61088: IFFALSE 61203
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61090: LD_ADDR_EXP 110
61094: PUSH
61095: LD_EXP 110
61099: PPUSH
61100: LD_VAR 0 1
61104: PUSH
61105: LD_EXP 110
61109: PUSH
61110: LD_VAR 0 1
61114: ARRAY
61115: PUSH
61116: LD_INT 1
61118: PLUS
61119: PUSH
61120: EMPTY
61121: LIST
61122: LIST
61123: PPUSH
61124: LD_VAR 0 9
61128: PPUSH
61129: CALL 73519 0 3
61133: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
61134: LD_ADDR_EXP 109
61138: PUSH
61139: LD_EXP 109
61143: PPUSH
61144: LD_VAR 0 1
61148: PPUSH
61149: LD_EXP 109
61153: PUSH
61154: LD_VAR 0 1
61158: ARRAY
61159: PUSH
61160: LD_VAR 0 9
61164: DIFF
61165: PPUSH
61166: CALL_OW 1
61170: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
61171: LD_VAR 0 3
61175: PPUSH
61176: LD_EXP 110
61180: PUSH
61181: LD_VAR 0 1
61185: ARRAY
61186: PUSH
61187: LD_EXP 110
61191: PUSH
61192: LD_VAR 0 1
61196: ARRAY
61197: ARRAY
61198: PPUSH
61199: CALL_OW 120
// end ; exit ;
61203: GO 61482
// end ; if tmp > 1 then
61205: LD_VAR 0 8
61209: PUSH
61210: LD_INT 1
61212: GREATER
61213: IFFALSE 61317
// for i = 2 to tmp do
61215: LD_ADDR_VAR 0 6
61219: PUSH
61220: DOUBLE
61221: LD_INT 2
61223: DEC
61224: ST_TO_ADDR
61225: LD_VAR 0 8
61229: PUSH
61230: FOR_TO
61231: IFFALSE 61315
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
61233: LD_VAR 0 8
61237: PUSH
61238: LD_VAR 0 6
61242: ARRAY
61243: PPUSH
61244: CALL_OW 461
61248: PUSH
61249: LD_INT 6
61251: EQUAL
61252: IFFALSE 61313
// begin x := tmp [ i ] ;
61254: LD_ADDR_VAR 0 9
61258: PUSH
61259: LD_VAR 0 8
61263: PUSH
61264: LD_VAR 0 6
61268: ARRAY
61269: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
61270: LD_ADDR_VAR 0 8
61274: PUSH
61275: LD_VAR 0 8
61279: PPUSH
61280: LD_VAR 0 6
61284: PPUSH
61285: CALL_OW 3
61289: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
61290: LD_ADDR_VAR 0 8
61294: PUSH
61295: LD_VAR 0 8
61299: PPUSH
61300: LD_INT 1
61302: PPUSH
61303: LD_VAR 0 9
61307: PPUSH
61308: CALL_OW 2
61312: ST_TO_ADDR
// end ;
61313: GO 61230
61315: POP
61316: POP
// for i in tmp do
61317: LD_ADDR_VAR 0 6
61321: PUSH
61322: LD_VAR 0 8
61326: PUSH
61327: FOR_IN
61328: IFFALSE 61355
// begin if IsNotFull ( i ) then
61330: LD_VAR 0 6
61334: PPUSH
61335: CALL 70741 0 1
61339: IFFALSE 61353
// begin j := i ;
61341: LD_ADDR_VAR 0 7
61345: PUSH
61346: LD_VAR 0 6
61350: ST_TO_ADDR
// break ;
61351: GO 61355
// end ; end ;
61353: GO 61327
61355: POP
61356: POP
// if j then
61357: LD_VAR 0 7
61361: IFFALSE 61379
// ComEnterUnit ( unit , j ) else
61363: LD_VAR 0 3
61367: PPUSH
61368: LD_VAR 0 7
61372: PPUSH
61373: CALL_OW 120
61377: GO 61482
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61379: LD_ADDR_VAR 0 10
61383: PUSH
61384: LD_VAR 0 2
61388: PPUSH
61389: LD_INT 2
61391: PUSH
61392: LD_INT 30
61394: PUSH
61395: LD_INT 0
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PUSH
61402: LD_INT 30
61404: PUSH
61405: LD_INT 1
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: LIST
61416: PPUSH
61417: CALL_OW 72
61421: ST_TO_ADDR
// if depot then
61422: LD_VAR 0 10
61426: IFFALSE 61482
// begin depot := NearestUnitToUnit ( depot , unit ) ;
61428: LD_ADDR_VAR 0 10
61432: PUSH
61433: LD_VAR 0 10
61437: PPUSH
61438: LD_VAR 0 3
61442: PPUSH
61443: CALL_OW 74
61447: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
61448: LD_VAR 0 3
61452: PPUSH
61453: LD_VAR 0 10
61457: PPUSH
61458: CALL_OW 296
61462: PUSH
61463: LD_INT 10
61465: GREATER
61466: IFFALSE 61482
// ComStandNearbyBuilding ( unit , depot ) ;
61468: LD_VAR 0 3
61472: PPUSH
61473: LD_VAR 0 10
61477: PPUSH
61478: CALL 70121 0 2
// end ; end ; end ;
61482: LD_VAR 0 5
61486: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
61487: LD_INT 0
61489: PPUSH
61490: PPUSH
61491: PPUSH
61492: PPUSH
// if not mc_bases then
61493: LD_EXP 100
61497: NOT
61498: IFFALSE 61502
// exit ;
61500: GO 61741
// for i = 1 to mc_bases do
61502: LD_ADDR_VAR 0 2
61506: PUSH
61507: DOUBLE
61508: LD_INT 1
61510: DEC
61511: ST_TO_ADDR
61512: LD_EXP 100
61516: PUSH
61517: FOR_TO
61518: IFFALSE 61739
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
61520: LD_ADDR_VAR 0 4
61524: PUSH
61525: LD_EXP 100
61529: PUSH
61530: LD_VAR 0 2
61534: ARRAY
61535: PPUSH
61536: LD_INT 21
61538: PUSH
61539: LD_INT 1
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: PPUSH
61546: CALL_OW 72
61550: PUSH
61551: LD_EXP 129
61555: PUSH
61556: LD_VAR 0 2
61560: ARRAY
61561: UNION
61562: ST_TO_ADDR
// if not tmp then
61563: LD_VAR 0 4
61567: NOT
61568: IFFALSE 61572
// continue ;
61570: GO 61517
// for j in tmp do
61572: LD_ADDR_VAR 0 3
61576: PUSH
61577: LD_VAR 0 4
61581: PUSH
61582: FOR_IN
61583: IFFALSE 61735
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
61585: LD_VAR 0 3
61589: PPUSH
61590: CALL_OW 110
61594: NOT
61595: PUSH
61596: LD_VAR 0 3
61600: PPUSH
61601: CALL_OW 314
61605: NOT
61606: AND
61607: PUSH
61608: LD_VAR 0 3
61612: PPUSH
61613: CALL_OW 311
61617: NOT
61618: AND
61619: PUSH
61620: LD_VAR 0 3
61624: PPUSH
61625: CALL_OW 310
61629: NOT
61630: AND
61631: PUSH
61632: LD_VAR 0 3
61636: PUSH
61637: LD_EXP 103
61641: PUSH
61642: LD_VAR 0 2
61646: ARRAY
61647: PUSH
61648: LD_INT 1
61650: ARRAY
61651: IN
61652: NOT
61653: AND
61654: PUSH
61655: LD_VAR 0 3
61659: PUSH
61660: LD_EXP 103
61664: PUSH
61665: LD_VAR 0 2
61669: ARRAY
61670: PUSH
61671: LD_INT 2
61673: ARRAY
61674: IN
61675: NOT
61676: AND
61677: PUSH
61678: LD_VAR 0 3
61682: PUSH
61683: LD_EXP 112
61687: PUSH
61688: LD_VAR 0 2
61692: ARRAY
61693: IN
61694: NOT
61695: AND
61696: IFFALSE 61733
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
61698: LD_VAR 0 2
61702: PPUSH
61703: LD_EXP 100
61707: PUSH
61708: LD_VAR 0 2
61712: ARRAY
61713: PPUSH
61714: LD_VAR 0 3
61718: PPUSH
61719: LD_VAR 0 3
61723: PPUSH
61724: CALL_OW 257
61728: PPUSH
61729: CALL 60547 0 4
// end ;
61733: GO 61582
61735: POP
61736: POP
// end ;
61737: GO 61517
61739: POP
61740: POP
// end ;
61741: LD_VAR 0 1
61745: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
61746: LD_INT 0
61748: PPUSH
61749: PPUSH
61750: PPUSH
61751: PPUSH
61752: PPUSH
61753: PPUSH
// if not mc_bases [ base ] then
61754: LD_EXP 100
61758: PUSH
61759: LD_VAR 0 1
61763: ARRAY
61764: NOT
61765: IFFALSE 61769
// exit ;
61767: GO 61970
// tmp := [ ] ;
61769: LD_ADDR_VAR 0 6
61773: PUSH
61774: EMPTY
61775: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
61776: LD_ADDR_VAR 0 7
61780: PUSH
61781: LD_VAR 0 3
61785: PPUSH
61786: LD_INT 0
61788: PPUSH
61789: CALL_OW 517
61793: ST_TO_ADDR
// if not list then
61794: LD_VAR 0 7
61798: NOT
61799: IFFALSE 61803
// exit ;
61801: GO 61970
// c := Count ( list [ 1 ] ) ;
61803: LD_ADDR_VAR 0 9
61807: PUSH
61808: LD_VAR 0 7
61812: PUSH
61813: LD_INT 1
61815: ARRAY
61816: PPUSH
61817: CALL 70659 0 1
61821: ST_TO_ADDR
// if amount > c then
61822: LD_VAR 0 2
61826: PUSH
61827: LD_VAR 0 9
61831: GREATER
61832: IFFALSE 61844
// amount := c ;
61834: LD_ADDR_VAR 0 2
61838: PUSH
61839: LD_VAR 0 9
61843: ST_TO_ADDR
// for i := 1 to amount do
61844: LD_ADDR_VAR 0 5
61848: PUSH
61849: DOUBLE
61850: LD_INT 1
61852: DEC
61853: ST_TO_ADDR
61854: LD_VAR 0 2
61858: PUSH
61859: FOR_TO
61860: IFFALSE 61918
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
61862: LD_ADDR_VAR 0 6
61866: PUSH
61867: LD_VAR 0 6
61871: PPUSH
61872: LD_VAR 0 5
61876: PPUSH
61877: LD_VAR 0 7
61881: PUSH
61882: LD_INT 1
61884: ARRAY
61885: PUSH
61886: LD_VAR 0 5
61890: ARRAY
61891: PUSH
61892: LD_VAR 0 7
61896: PUSH
61897: LD_INT 2
61899: ARRAY
61900: PUSH
61901: LD_VAR 0 5
61905: ARRAY
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PPUSH
61911: CALL_OW 1
61915: ST_TO_ADDR
61916: GO 61859
61918: POP
61919: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
61920: LD_ADDR_EXP 113
61924: PUSH
61925: LD_EXP 113
61929: PPUSH
61930: LD_VAR 0 1
61934: PPUSH
61935: LD_VAR 0 6
61939: PPUSH
61940: CALL_OW 1
61944: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
61945: LD_ADDR_EXP 115
61949: PUSH
61950: LD_EXP 115
61954: PPUSH
61955: LD_VAR 0 1
61959: PPUSH
61960: LD_VAR 0 3
61964: PPUSH
61965: CALL_OW 1
61969: ST_TO_ADDR
// end ;
61970: LD_VAR 0 4
61974: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
61975: LD_INT 0
61977: PPUSH
// if not mc_bases [ base ] then
61978: LD_EXP 100
61982: PUSH
61983: LD_VAR 0 1
61987: ARRAY
61988: NOT
61989: IFFALSE 61993
// exit ;
61991: GO 62018
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
61993: LD_ADDR_EXP 105
61997: PUSH
61998: LD_EXP 105
62002: PPUSH
62003: LD_VAR 0 1
62007: PPUSH
62008: LD_VAR 0 2
62012: PPUSH
62013: CALL_OW 1
62017: ST_TO_ADDR
// end ;
62018: LD_VAR 0 3
62022: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62023: LD_INT 0
62025: PPUSH
// if not mc_bases [ base ] then
62026: LD_EXP 100
62030: PUSH
62031: LD_VAR 0 1
62035: ARRAY
62036: NOT
62037: IFFALSE 62041
// exit ;
62039: GO 62078
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62041: LD_ADDR_EXP 105
62045: PUSH
62046: LD_EXP 105
62050: PPUSH
62051: LD_VAR 0 1
62055: PPUSH
62056: LD_EXP 105
62060: PUSH
62061: LD_VAR 0 1
62065: ARRAY
62066: PUSH
62067: LD_VAR 0 2
62071: UNION
62072: PPUSH
62073: CALL_OW 1
62077: ST_TO_ADDR
// end ;
62078: LD_VAR 0 3
62082: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62083: LD_INT 0
62085: PPUSH
// if not mc_bases [ base ] then
62086: LD_EXP 100
62090: PUSH
62091: LD_VAR 0 1
62095: ARRAY
62096: NOT
62097: IFFALSE 62101
// exit ;
62099: GO 62126
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62101: LD_ADDR_EXP 121
62105: PUSH
62106: LD_EXP 121
62110: PPUSH
62111: LD_VAR 0 1
62115: PPUSH
62116: LD_VAR 0 2
62120: PPUSH
62121: CALL_OW 1
62125: ST_TO_ADDR
// end ;
62126: LD_VAR 0 3
62130: RET
// export function MC_InsertProduceList ( base , components ) ; begin
62131: LD_INT 0
62133: PPUSH
// if not mc_bases [ base ] then
62134: LD_EXP 100
62138: PUSH
62139: LD_VAR 0 1
62143: ARRAY
62144: NOT
62145: IFFALSE 62149
// exit ;
62147: GO 62186
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
62149: LD_ADDR_EXP 121
62153: PUSH
62154: LD_EXP 121
62158: PPUSH
62159: LD_VAR 0 1
62163: PPUSH
62164: LD_EXP 121
62168: PUSH
62169: LD_VAR 0 1
62173: ARRAY
62174: PUSH
62175: LD_VAR 0 2
62179: ADD
62180: PPUSH
62181: CALL_OW 1
62185: ST_TO_ADDR
// end ;
62186: LD_VAR 0 3
62190: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
62191: LD_INT 0
62193: PPUSH
// if not mc_bases [ base ] then
62194: LD_EXP 100
62198: PUSH
62199: LD_VAR 0 1
62203: ARRAY
62204: NOT
62205: IFFALSE 62209
// exit ;
62207: GO 62263
// mc_defender := Replace ( mc_defender , base , deflist ) ;
62209: LD_ADDR_EXP 122
62213: PUSH
62214: LD_EXP 122
62218: PPUSH
62219: LD_VAR 0 1
62223: PPUSH
62224: LD_VAR 0 2
62228: PPUSH
62229: CALL_OW 1
62233: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
62234: LD_ADDR_EXP 111
62238: PUSH
62239: LD_EXP 111
62243: PPUSH
62244: LD_VAR 0 1
62248: PPUSH
62249: LD_VAR 0 2
62253: PUSH
62254: LD_INT 0
62256: PLUS
62257: PPUSH
62258: CALL_OW 1
62262: ST_TO_ADDR
// end ;
62263: LD_VAR 0 3
62267: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
62268: LD_INT 0
62270: PPUSH
// if not mc_bases [ base ] then
62271: LD_EXP 100
62275: PUSH
62276: LD_VAR 0 1
62280: ARRAY
62281: NOT
62282: IFFALSE 62286
// exit ;
62284: GO 62311
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
62286: LD_ADDR_EXP 111
62290: PUSH
62291: LD_EXP 111
62295: PPUSH
62296: LD_VAR 0 1
62300: PPUSH
62301: LD_VAR 0 2
62305: PPUSH
62306: CALL_OW 1
62310: ST_TO_ADDR
// end ;
62311: LD_VAR 0 3
62315: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
62316: LD_INT 0
62318: PPUSH
62319: PPUSH
62320: PPUSH
62321: PPUSH
// if not mc_bases [ base ] then
62322: LD_EXP 100
62326: PUSH
62327: LD_VAR 0 1
62331: ARRAY
62332: NOT
62333: IFFALSE 62337
// exit ;
62335: GO 62402
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
62337: LD_ADDR_EXP 120
62341: PUSH
62342: LD_EXP 120
62346: PPUSH
62347: LD_VAR 0 1
62351: PUSH
62352: LD_EXP 120
62356: PUSH
62357: LD_VAR 0 1
62361: ARRAY
62362: PUSH
62363: LD_INT 1
62365: PLUS
62366: PUSH
62367: EMPTY
62368: LIST
62369: LIST
62370: PPUSH
62371: LD_VAR 0 1
62375: PUSH
62376: LD_VAR 0 2
62380: PUSH
62381: LD_VAR 0 3
62385: PUSH
62386: LD_VAR 0 4
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: LIST
62395: LIST
62396: PPUSH
62397: CALL 73519 0 3
62401: ST_TO_ADDR
// end ;
62402: LD_VAR 0 5
62406: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
62407: LD_INT 0
62409: PPUSH
// if not mc_bases [ base ] then
62410: LD_EXP 100
62414: PUSH
62415: LD_VAR 0 1
62419: ARRAY
62420: NOT
62421: IFFALSE 62425
// exit ;
62423: GO 62450
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
62425: LD_ADDR_EXP 137
62429: PUSH
62430: LD_EXP 137
62434: PPUSH
62435: LD_VAR 0 1
62439: PPUSH
62440: LD_VAR 0 2
62444: PPUSH
62445: CALL_OW 1
62449: ST_TO_ADDR
// end ;
62450: LD_VAR 0 3
62454: RET
// export function MC_GetMinesField ( base ) ; begin
62455: LD_INT 0
62457: PPUSH
// result := mc_mines [ base ] ;
62458: LD_ADDR_VAR 0 2
62462: PUSH
62463: LD_EXP 113
62467: PUSH
62468: LD_VAR 0 1
62472: ARRAY
62473: ST_TO_ADDR
// end ;
62474: LD_VAR 0 2
62478: RET
// export function MC_GetProduceList ( base ) ; begin
62479: LD_INT 0
62481: PPUSH
// result := mc_produce [ base ] ;
62482: LD_ADDR_VAR 0 2
62486: PUSH
62487: LD_EXP 121
62491: PUSH
62492: LD_VAR 0 1
62496: ARRAY
62497: ST_TO_ADDR
// end ;
62498: LD_VAR 0 2
62502: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
62503: LD_INT 0
62505: PPUSH
62506: PPUSH
// if not mc_bases then
62507: LD_EXP 100
62511: NOT
62512: IFFALSE 62516
// exit ;
62514: GO 62581
// if mc_bases [ base ] then
62516: LD_EXP 100
62520: PUSH
62521: LD_VAR 0 1
62525: ARRAY
62526: IFFALSE 62581
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62528: LD_ADDR_VAR 0 3
62532: PUSH
62533: LD_EXP 100
62537: PUSH
62538: LD_VAR 0 1
62542: ARRAY
62543: PPUSH
62544: LD_INT 30
62546: PUSH
62547: LD_VAR 0 2
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PPUSH
62556: CALL_OW 72
62560: ST_TO_ADDR
// if result then
62561: LD_VAR 0 3
62565: IFFALSE 62581
// result := result [ 1 ] ;
62567: LD_ADDR_VAR 0 3
62571: PUSH
62572: LD_VAR 0 3
62576: PUSH
62577: LD_INT 1
62579: ARRAY
62580: ST_TO_ADDR
// end ; end ;
62581: LD_VAR 0 3
62585: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
62586: LD_INT 0
62588: PPUSH
62589: PPUSH
// if not mc_bases then
62590: LD_EXP 100
62594: NOT
62595: IFFALSE 62599
// exit ;
62597: GO 62644
// if mc_bases [ base ] then
62599: LD_EXP 100
62603: PUSH
62604: LD_VAR 0 1
62608: ARRAY
62609: IFFALSE 62644
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62611: LD_ADDR_VAR 0 3
62615: PUSH
62616: LD_EXP 100
62620: PUSH
62621: LD_VAR 0 1
62625: ARRAY
62626: PPUSH
62627: LD_INT 30
62629: PUSH
62630: LD_VAR 0 2
62634: PUSH
62635: EMPTY
62636: LIST
62637: LIST
62638: PPUSH
62639: CALL_OW 72
62643: ST_TO_ADDR
// end ;
62644: LD_VAR 0 3
62648: RET
// export function MC_SetTame ( base , area ) ; begin
62649: LD_INT 0
62651: PPUSH
// if not mc_bases or not base then
62652: LD_EXP 100
62656: NOT
62657: PUSH
62658: LD_VAR 0 1
62662: NOT
62663: OR
62664: IFFALSE 62668
// exit ;
62666: GO 62693
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
62668: LD_ADDR_EXP 128
62672: PUSH
62673: LD_EXP 128
62677: PPUSH
62678: LD_VAR 0 1
62682: PPUSH
62683: LD_VAR 0 2
62687: PPUSH
62688: CALL_OW 1
62692: ST_TO_ADDR
// end ;
62693: LD_VAR 0 3
62697: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
62698: LD_INT 0
62700: PPUSH
62701: PPUSH
// if not mc_bases or not base then
62702: LD_EXP 100
62706: NOT
62707: PUSH
62708: LD_VAR 0 1
62712: NOT
62713: OR
62714: IFFALSE 62718
// exit ;
62716: GO 62820
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62718: LD_ADDR_VAR 0 4
62722: PUSH
62723: LD_EXP 100
62727: PUSH
62728: LD_VAR 0 1
62732: ARRAY
62733: PPUSH
62734: LD_INT 30
62736: PUSH
62737: LD_VAR 0 2
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: PPUSH
62746: CALL_OW 72
62750: ST_TO_ADDR
// if not tmp then
62751: LD_VAR 0 4
62755: NOT
62756: IFFALSE 62760
// exit ;
62758: GO 62820
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
62760: LD_ADDR_EXP 132
62764: PUSH
62765: LD_EXP 132
62769: PPUSH
62770: LD_VAR 0 1
62774: PPUSH
62775: LD_EXP 132
62779: PUSH
62780: LD_VAR 0 1
62784: ARRAY
62785: PPUSH
62786: LD_EXP 132
62790: PUSH
62791: LD_VAR 0 1
62795: ARRAY
62796: PUSH
62797: LD_INT 1
62799: PLUS
62800: PPUSH
62801: LD_VAR 0 4
62805: PUSH
62806: LD_INT 1
62808: ARRAY
62809: PPUSH
62810: CALL_OW 2
62814: PPUSH
62815: CALL_OW 1
62819: ST_TO_ADDR
// end ;
62820: LD_VAR 0 3
62824: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
62825: LD_INT 0
62827: PPUSH
62828: PPUSH
// if not mc_bases or not base or not kinds then
62829: LD_EXP 100
62833: NOT
62834: PUSH
62835: LD_VAR 0 1
62839: NOT
62840: OR
62841: PUSH
62842: LD_VAR 0 2
62846: NOT
62847: OR
62848: IFFALSE 62852
// exit ;
62850: GO 62913
// for i in kinds do
62852: LD_ADDR_VAR 0 4
62856: PUSH
62857: LD_VAR 0 2
62861: PUSH
62862: FOR_IN
62863: IFFALSE 62911
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
62865: LD_ADDR_EXP 134
62869: PUSH
62870: LD_EXP 134
62874: PPUSH
62875: LD_VAR 0 1
62879: PUSH
62880: LD_EXP 134
62884: PUSH
62885: LD_VAR 0 1
62889: ARRAY
62890: PUSH
62891: LD_INT 1
62893: PLUS
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: PPUSH
62899: LD_VAR 0 4
62903: PPUSH
62904: CALL 73519 0 3
62908: ST_TO_ADDR
62909: GO 62862
62911: POP
62912: POP
// end ;
62913: LD_VAR 0 3
62917: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
62918: LD_INT 0
62920: PPUSH
// if not mc_bases or not base or not areas then
62921: LD_EXP 100
62925: NOT
62926: PUSH
62927: LD_VAR 0 1
62931: NOT
62932: OR
62933: PUSH
62934: LD_VAR 0 2
62938: NOT
62939: OR
62940: IFFALSE 62944
// exit ;
62942: GO 62969
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
62944: LD_ADDR_EXP 118
62948: PUSH
62949: LD_EXP 118
62953: PPUSH
62954: LD_VAR 0 1
62958: PPUSH
62959: LD_VAR 0 2
62963: PPUSH
62964: CALL_OW 1
62968: ST_TO_ADDR
// end ;
62969: LD_VAR 0 3
62973: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
62974: LD_INT 0
62976: PPUSH
// if not mc_bases or not base or not teleports_exit then
62977: LD_EXP 100
62981: NOT
62982: PUSH
62983: LD_VAR 0 1
62987: NOT
62988: OR
62989: PUSH
62990: LD_VAR 0 2
62994: NOT
62995: OR
62996: IFFALSE 63000
// exit ;
62998: GO 63025
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63000: LD_ADDR_EXP 135
63004: PUSH
63005: LD_EXP 135
63009: PPUSH
63010: LD_VAR 0 1
63014: PPUSH
63015: LD_VAR 0 2
63019: PPUSH
63020: CALL_OW 1
63024: ST_TO_ADDR
// end ;
63025: LD_VAR 0 3
63029: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63030: LD_INT 0
63032: PPUSH
63033: PPUSH
63034: PPUSH
// if not mc_bases or not base or not ext_list then
63035: LD_EXP 100
63039: NOT
63040: PUSH
63041: LD_VAR 0 1
63045: NOT
63046: OR
63047: PUSH
63048: LD_VAR 0 5
63052: NOT
63053: OR
63054: IFFALSE 63058
// exit ;
63056: GO 63231
// tmp := GetFacExtXYD ( x , y , d ) ;
63058: LD_ADDR_VAR 0 8
63062: PUSH
63063: LD_VAR 0 2
63067: PPUSH
63068: LD_VAR 0 3
63072: PPUSH
63073: LD_VAR 0 4
63077: PPUSH
63078: CALL 103496 0 3
63082: ST_TO_ADDR
// if not tmp then
63083: LD_VAR 0 8
63087: NOT
63088: IFFALSE 63092
// exit ;
63090: GO 63231
// for i in tmp do
63092: LD_ADDR_VAR 0 7
63096: PUSH
63097: LD_VAR 0 8
63101: PUSH
63102: FOR_IN
63103: IFFALSE 63229
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63105: LD_ADDR_EXP 105
63109: PUSH
63110: LD_EXP 105
63114: PPUSH
63115: LD_VAR 0 1
63119: PPUSH
63120: LD_EXP 105
63124: PUSH
63125: LD_VAR 0 1
63129: ARRAY
63130: PPUSH
63131: LD_EXP 105
63135: PUSH
63136: LD_VAR 0 1
63140: ARRAY
63141: PUSH
63142: LD_INT 1
63144: PLUS
63145: PPUSH
63146: LD_VAR 0 5
63150: PUSH
63151: LD_INT 1
63153: ARRAY
63154: PUSH
63155: LD_VAR 0 7
63159: PUSH
63160: LD_INT 1
63162: ARRAY
63163: PUSH
63164: LD_VAR 0 7
63168: PUSH
63169: LD_INT 2
63171: ARRAY
63172: PUSH
63173: LD_VAR 0 7
63177: PUSH
63178: LD_INT 3
63180: ARRAY
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: LIST
63187: PPUSH
63188: CALL_OW 2
63192: PPUSH
63193: CALL_OW 1
63197: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
63198: LD_ADDR_VAR 0 5
63202: PUSH
63203: LD_VAR 0 5
63207: PPUSH
63208: LD_INT 1
63210: PPUSH
63211: CALL_OW 3
63215: ST_TO_ADDR
// if not ext_list then
63216: LD_VAR 0 5
63220: NOT
63221: IFFALSE 63227
// exit ;
63223: POP
63224: POP
63225: GO 63231
// end ;
63227: GO 63102
63229: POP
63230: POP
// end ;
63231: LD_VAR 0 6
63235: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
63236: LD_INT 0
63238: PPUSH
// if not mc_bases or not base or not weapon_list then
63239: LD_EXP 100
63243: NOT
63244: PUSH
63245: LD_VAR 0 1
63249: NOT
63250: OR
63251: PUSH
63252: LD_VAR 0 2
63256: NOT
63257: OR
63258: IFFALSE 63262
// exit ;
63260: GO 63287
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
63262: LD_ADDR_EXP 139
63266: PUSH
63267: LD_EXP 139
63271: PPUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: LD_VAR 0 2
63281: PPUSH
63282: CALL_OW 1
63286: ST_TO_ADDR
// end ;
63287: LD_VAR 0 3
63291: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
63292: LD_INT 0
63294: PPUSH
// if not mc_bases or not base or not tech_list then
63295: LD_EXP 100
63299: NOT
63300: PUSH
63301: LD_VAR 0 1
63305: NOT
63306: OR
63307: PUSH
63308: LD_VAR 0 2
63312: NOT
63313: OR
63314: IFFALSE 63318
// exit ;
63316: GO 63343
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
63318: LD_ADDR_EXP 127
63322: PUSH
63323: LD_EXP 127
63327: PPUSH
63328: LD_VAR 0 1
63332: PPUSH
63333: LD_VAR 0 2
63337: PPUSH
63338: CALL_OW 1
63342: ST_TO_ADDR
// end ;
63343: LD_VAR 0 3
63347: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
63348: LD_INT 0
63350: PPUSH
// if not mc_bases or not parking_area or not base then
63351: LD_EXP 100
63355: NOT
63356: PUSH
63357: LD_VAR 0 2
63361: NOT
63362: OR
63363: PUSH
63364: LD_VAR 0 1
63368: NOT
63369: OR
63370: IFFALSE 63374
// exit ;
63372: GO 63399
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
63374: LD_ADDR_EXP 124
63378: PUSH
63379: LD_EXP 124
63383: PPUSH
63384: LD_VAR 0 1
63388: PPUSH
63389: LD_VAR 0 2
63393: PPUSH
63394: CALL_OW 1
63398: ST_TO_ADDR
// end ;
63399: LD_VAR 0 3
63403: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
63404: LD_INT 0
63406: PPUSH
// if not mc_bases or not base or not scan_area then
63407: LD_EXP 100
63411: NOT
63412: PUSH
63413: LD_VAR 0 1
63417: NOT
63418: OR
63419: PUSH
63420: LD_VAR 0 2
63424: NOT
63425: OR
63426: IFFALSE 63430
// exit ;
63428: GO 63455
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
63430: LD_ADDR_EXP 125
63434: PUSH
63435: LD_EXP 125
63439: PPUSH
63440: LD_VAR 0 1
63444: PPUSH
63445: LD_VAR 0 2
63449: PPUSH
63450: CALL_OW 1
63454: ST_TO_ADDR
// end ;
63455: LD_VAR 0 3
63459: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
63460: LD_INT 0
63462: PPUSH
63463: PPUSH
// if not mc_bases or not base then
63464: LD_EXP 100
63468: NOT
63469: PUSH
63470: LD_VAR 0 1
63474: NOT
63475: OR
63476: IFFALSE 63480
// exit ;
63478: GO 63544
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
63480: LD_ADDR_VAR 0 3
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: LD_INT 2
63490: PUSH
63491: LD_INT 3
63493: PUSH
63494: LD_INT 4
63496: PUSH
63497: LD_INT 11
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
63507: LD_ADDR_EXP 127
63511: PUSH
63512: LD_EXP 127
63516: PPUSH
63517: LD_VAR 0 1
63521: PPUSH
63522: LD_EXP 127
63526: PUSH
63527: LD_VAR 0 1
63531: ARRAY
63532: PUSH
63533: LD_VAR 0 3
63537: DIFF
63538: PPUSH
63539: CALL_OW 1
63543: ST_TO_ADDR
// end ;
63544: LD_VAR 0 2
63548: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
63549: LD_INT 0
63551: PPUSH
// result := mc_vehicles [ base ] ;
63552: LD_ADDR_VAR 0 3
63556: PUSH
63557: LD_EXP 119
63561: PUSH
63562: LD_VAR 0 1
63566: ARRAY
63567: ST_TO_ADDR
// if onlyCombat then
63568: LD_VAR 0 2
63572: IFFALSE 63744
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
63574: LD_ADDR_VAR 0 3
63578: PUSH
63579: LD_VAR 0 3
63583: PUSH
63584: LD_VAR 0 3
63588: PPUSH
63589: LD_INT 2
63591: PUSH
63592: LD_INT 34
63594: PUSH
63595: LD_INT 12
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 34
63604: PUSH
63605: LD_INT 51
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 34
63614: PUSH
63615: LD_INT 89
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 34
63624: PUSH
63625: LD_INT 32
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 34
63634: PUSH
63635: LD_INT 13
63637: PUSH
63638: EMPTY
63639: LIST
63640: LIST
63641: PUSH
63642: LD_INT 34
63644: PUSH
63645: LD_INT 52
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PUSH
63652: LD_INT 34
63654: PUSH
63655: LD_INT 88
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 34
63664: PUSH
63665: LD_INT 14
63667: PUSH
63668: EMPTY
63669: LIST
63670: LIST
63671: PUSH
63672: LD_INT 34
63674: PUSH
63675: LD_INT 53
63677: PUSH
63678: EMPTY
63679: LIST
63680: LIST
63681: PUSH
63682: LD_INT 34
63684: PUSH
63685: LD_INT 98
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: PUSH
63692: LD_INT 34
63694: PUSH
63695: LD_INT 31
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: PUSH
63702: LD_INT 34
63704: PUSH
63705: LD_INT 48
63707: PUSH
63708: EMPTY
63709: LIST
63710: LIST
63711: PUSH
63712: LD_INT 34
63714: PUSH
63715: LD_INT 8
63717: PUSH
63718: EMPTY
63719: LIST
63720: LIST
63721: PUSH
63722: EMPTY
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: PPUSH
63738: CALL_OW 72
63742: DIFF
63743: ST_TO_ADDR
// end ; end_of_file
63744: LD_VAR 0 3
63748: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
63749: LD_INT 0
63751: PPUSH
63752: PPUSH
63753: PPUSH
// if not mc_bases or not skirmish then
63754: LD_EXP 100
63758: NOT
63759: PUSH
63760: LD_EXP 98
63764: NOT
63765: OR
63766: IFFALSE 63770
// exit ;
63768: GO 63935
// for i = 1 to mc_bases do
63770: LD_ADDR_VAR 0 4
63774: PUSH
63775: DOUBLE
63776: LD_INT 1
63778: DEC
63779: ST_TO_ADDR
63780: LD_EXP 100
63784: PUSH
63785: FOR_TO
63786: IFFALSE 63933
// begin if sci in mc_bases [ i ] then
63788: LD_VAR 0 2
63792: PUSH
63793: LD_EXP 100
63797: PUSH
63798: LD_VAR 0 4
63802: ARRAY
63803: IN
63804: IFFALSE 63931
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
63806: LD_ADDR_EXP 129
63810: PUSH
63811: LD_EXP 129
63815: PPUSH
63816: LD_VAR 0 4
63820: PUSH
63821: LD_EXP 129
63825: PUSH
63826: LD_VAR 0 4
63830: ARRAY
63831: PUSH
63832: LD_INT 1
63834: PLUS
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: PPUSH
63840: LD_VAR 0 1
63844: PPUSH
63845: CALL 73519 0 3
63849: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
63850: LD_ADDR_VAR 0 5
63854: PUSH
63855: LD_EXP 100
63859: PUSH
63860: LD_VAR 0 4
63864: ARRAY
63865: PPUSH
63866: LD_INT 2
63868: PUSH
63869: LD_INT 30
63871: PUSH
63872: LD_INT 0
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: LD_INT 30
63881: PUSH
63882: LD_INT 1
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: LIST
63893: PPUSH
63894: CALL_OW 72
63898: PPUSH
63899: LD_VAR 0 1
63903: PPUSH
63904: CALL_OW 74
63908: ST_TO_ADDR
// if tmp then
63909: LD_VAR 0 5
63913: IFFALSE 63929
// ComStandNearbyBuilding ( ape , tmp ) ;
63915: LD_VAR 0 1
63919: PPUSH
63920: LD_VAR 0 5
63924: PPUSH
63925: CALL 70121 0 2
// break ;
63929: GO 63933
// end ; end ;
63931: GO 63785
63933: POP
63934: POP
// end ;
63935: LD_VAR 0 3
63939: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
63940: LD_INT 0
63942: PPUSH
63943: PPUSH
63944: PPUSH
// if not mc_bases or not skirmish then
63945: LD_EXP 100
63949: NOT
63950: PUSH
63951: LD_EXP 98
63955: NOT
63956: OR
63957: IFFALSE 63961
// exit ;
63959: GO 64050
// for i = 1 to mc_bases do
63961: LD_ADDR_VAR 0 4
63965: PUSH
63966: DOUBLE
63967: LD_INT 1
63969: DEC
63970: ST_TO_ADDR
63971: LD_EXP 100
63975: PUSH
63976: FOR_TO
63977: IFFALSE 64048
// begin if building in mc_busy_turret_list [ i ] then
63979: LD_VAR 0 1
63983: PUSH
63984: LD_EXP 110
63988: PUSH
63989: LD_VAR 0 4
63993: ARRAY
63994: IN
63995: IFFALSE 64046
// begin tmp := mc_busy_turret_list [ i ] diff building ;
63997: LD_ADDR_VAR 0 5
64001: PUSH
64002: LD_EXP 110
64006: PUSH
64007: LD_VAR 0 4
64011: ARRAY
64012: PUSH
64013: LD_VAR 0 1
64017: DIFF
64018: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64019: LD_ADDR_EXP 110
64023: PUSH
64024: LD_EXP 110
64028: PPUSH
64029: LD_VAR 0 4
64033: PPUSH
64034: LD_VAR 0 5
64038: PPUSH
64039: CALL_OW 1
64043: ST_TO_ADDR
// break ;
64044: GO 64048
// end ; end ;
64046: GO 63976
64048: POP
64049: POP
// end ;
64050: LD_VAR 0 3
64054: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64055: LD_INT 0
64057: PPUSH
64058: PPUSH
64059: PPUSH
// if not mc_bases or not skirmish then
64060: LD_EXP 100
64064: NOT
64065: PUSH
64066: LD_EXP 98
64070: NOT
64071: OR
64072: IFFALSE 64076
// exit ;
64074: GO 64275
// for i = 1 to mc_bases do
64076: LD_ADDR_VAR 0 5
64080: PUSH
64081: DOUBLE
64082: LD_INT 1
64084: DEC
64085: ST_TO_ADDR
64086: LD_EXP 100
64090: PUSH
64091: FOR_TO
64092: IFFALSE 64273
// if building in mc_bases [ i ] then
64094: LD_VAR 0 1
64098: PUSH
64099: LD_EXP 100
64103: PUSH
64104: LD_VAR 0 5
64108: ARRAY
64109: IN
64110: IFFALSE 64271
// begin tmp := mc_bases [ i ] diff building ;
64112: LD_ADDR_VAR 0 6
64116: PUSH
64117: LD_EXP 100
64121: PUSH
64122: LD_VAR 0 5
64126: ARRAY
64127: PUSH
64128: LD_VAR 0 1
64132: DIFF
64133: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
64134: LD_ADDR_EXP 100
64138: PUSH
64139: LD_EXP 100
64143: PPUSH
64144: LD_VAR 0 5
64148: PPUSH
64149: LD_VAR 0 6
64153: PPUSH
64154: CALL_OW 1
64158: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
64159: LD_VAR 0 1
64163: PUSH
64164: LD_EXP 108
64168: PUSH
64169: LD_VAR 0 5
64173: ARRAY
64174: IN
64175: IFFALSE 64214
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
64177: LD_ADDR_EXP 108
64181: PUSH
64182: LD_EXP 108
64186: PPUSH
64187: LD_VAR 0 5
64191: PPUSH
64192: LD_EXP 108
64196: PUSH
64197: LD_VAR 0 5
64201: ARRAY
64202: PUSH
64203: LD_VAR 0 1
64207: DIFF
64208: PPUSH
64209: CALL_OW 1
64213: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
64214: LD_VAR 0 1
64218: PUSH
64219: LD_EXP 109
64223: PUSH
64224: LD_VAR 0 5
64228: ARRAY
64229: IN
64230: IFFALSE 64269
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
64232: LD_ADDR_EXP 109
64236: PUSH
64237: LD_EXP 109
64241: PPUSH
64242: LD_VAR 0 5
64246: PPUSH
64247: LD_EXP 109
64251: PUSH
64252: LD_VAR 0 5
64256: ARRAY
64257: PUSH
64258: LD_VAR 0 1
64262: DIFF
64263: PPUSH
64264: CALL_OW 1
64268: ST_TO_ADDR
// break ;
64269: GO 64273
// end ;
64271: GO 64091
64273: POP
64274: POP
// end ;
64275: LD_VAR 0 4
64279: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
64280: LD_INT 0
64282: PPUSH
64283: PPUSH
64284: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
64285: LD_EXP 100
64289: NOT
64290: PUSH
64291: LD_EXP 98
64295: NOT
64296: OR
64297: PUSH
64298: LD_VAR 0 3
64302: PUSH
64303: LD_EXP 126
64307: IN
64308: NOT
64309: OR
64310: IFFALSE 64314
// exit ;
64312: GO 64437
// for i = 1 to mc_vehicles do
64314: LD_ADDR_VAR 0 6
64318: PUSH
64319: DOUBLE
64320: LD_INT 1
64322: DEC
64323: ST_TO_ADDR
64324: LD_EXP 119
64328: PUSH
64329: FOR_TO
64330: IFFALSE 64435
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
64332: LD_VAR 0 2
64336: PUSH
64337: LD_EXP 119
64341: PUSH
64342: LD_VAR 0 6
64346: ARRAY
64347: IN
64348: PUSH
64349: LD_VAR 0 1
64353: PUSH
64354: LD_EXP 119
64358: PUSH
64359: LD_VAR 0 6
64363: ARRAY
64364: IN
64365: OR
64366: IFFALSE 64433
// begin tmp := mc_vehicles [ i ] diff old ;
64368: LD_ADDR_VAR 0 7
64372: PUSH
64373: LD_EXP 119
64377: PUSH
64378: LD_VAR 0 6
64382: ARRAY
64383: PUSH
64384: LD_VAR 0 2
64388: DIFF
64389: ST_TO_ADDR
// tmp := tmp diff new ;
64390: LD_ADDR_VAR 0 7
64394: PUSH
64395: LD_VAR 0 7
64399: PUSH
64400: LD_VAR 0 1
64404: DIFF
64405: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
64406: LD_ADDR_EXP 119
64410: PUSH
64411: LD_EXP 119
64415: PPUSH
64416: LD_VAR 0 6
64420: PPUSH
64421: LD_VAR 0 7
64425: PPUSH
64426: CALL_OW 1
64430: ST_TO_ADDR
// break ;
64431: GO 64435
// end ;
64433: GO 64329
64435: POP
64436: POP
// end ;
64437: LD_VAR 0 5
64441: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
64442: LD_INT 0
64444: PPUSH
64445: PPUSH
64446: PPUSH
64447: PPUSH
// if not mc_bases or not skirmish then
64448: LD_EXP 100
64452: NOT
64453: PUSH
64454: LD_EXP 98
64458: NOT
64459: OR
64460: IFFALSE 64464
// exit ;
64462: GO 64884
// repeat wait ( 0 0$1 ) ;
64464: LD_INT 35
64466: PPUSH
64467: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
64471: LD_EXP 144
64475: NOT
64476: IFFALSE 64464
// mc_block_vehicle_constructed_thread := true ;
64478: LD_ADDR_EXP 144
64482: PUSH
64483: LD_INT 1
64485: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
64486: LD_ADDR_VAR 0 5
64490: PUSH
64491: LD_VAR 0 1
64495: PPUSH
64496: CALL_OW 255
64500: ST_TO_ADDR
// for i = 1 to mc_bases do
64501: LD_ADDR_VAR 0 4
64505: PUSH
64506: DOUBLE
64507: LD_INT 1
64509: DEC
64510: ST_TO_ADDR
64511: LD_EXP 100
64515: PUSH
64516: FOR_TO
64517: IFFALSE 64874
// begin if factory in mc_bases [ i ] then
64519: LD_VAR 0 2
64523: PUSH
64524: LD_EXP 100
64528: PUSH
64529: LD_VAR 0 4
64533: ARRAY
64534: IN
64535: IFFALSE 64872
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
64537: LD_EXP 122
64541: PUSH
64542: LD_VAR 0 4
64546: ARRAY
64547: PUSH
64548: LD_EXP 111
64552: PUSH
64553: LD_VAR 0 4
64557: ARRAY
64558: LESS
64559: PUSH
64560: LD_VAR 0 1
64564: PPUSH
64565: CALL_OW 264
64569: PUSH
64570: LD_INT 31
64572: PUSH
64573: LD_INT 32
64575: PUSH
64576: LD_INT 51
64578: PUSH
64579: LD_INT 89
64581: PUSH
64582: LD_INT 12
64584: PUSH
64585: LD_INT 30
64587: PUSH
64588: LD_INT 98
64590: PUSH
64591: LD_INT 11
64593: PUSH
64594: LD_INT 53
64596: PUSH
64597: LD_INT 14
64599: PUSH
64600: LD_INT 91
64602: PUSH
64603: LD_INT 29
64605: PUSH
64606: LD_INT 99
64608: PUSH
64609: LD_INT 13
64611: PUSH
64612: LD_INT 52
64614: PUSH
64615: LD_INT 88
64617: PUSH
64618: LD_INT 48
64620: PUSH
64621: LD_INT 8
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: LIST
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: LIST
64640: LIST
64641: LIST
64642: LIST
64643: IN
64644: NOT
64645: AND
64646: IFFALSE 64694
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
64648: LD_ADDR_EXP 122
64652: PUSH
64653: LD_EXP 122
64657: PPUSH
64658: LD_VAR 0 4
64662: PUSH
64663: LD_EXP 122
64667: PUSH
64668: LD_VAR 0 4
64672: ARRAY
64673: PUSH
64674: LD_INT 1
64676: PLUS
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PPUSH
64682: LD_VAR 0 1
64686: PPUSH
64687: CALL 73519 0 3
64691: ST_TO_ADDR
64692: GO 64738
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
64694: LD_ADDR_EXP 119
64698: PUSH
64699: LD_EXP 119
64703: PPUSH
64704: LD_VAR 0 4
64708: PUSH
64709: LD_EXP 119
64713: PUSH
64714: LD_VAR 0 4
64718: ARRAY
64719: PUSH
64720: LD_INT 1
64722: PLUS
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PPUSH
64728: LD_VAR 0 1
64732: PPUSH
64733: CALL 73519 0 3
64737: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
64738: LD_ADDR_EXP 144
64742: PUSH
64743: LD_INT 0
64745: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
64746: LD_VAR 0 1
64750: PPUSH
64751: CALL_OW 263
64755: PUSH
64756: LD_INT 2
64758: EQUAL
64759: IFFALSE 64788
// begin repeat wait ( 0 0$3 ) ;
64761: LD_INT 105
64763: PPUSH
64764: CALL_OW 67
// Connect ( vehicle ) ;
64768: LD_VAR 0 1
64772: PPUSH
64773: CALL 76488 0 1
// until IsControledBy ( vehicle ) ;
64777: LD_VAR 0 1
64781: PPUSH
64782: CALL_OW 312
64786: IFFALSE 64761
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
64788: LD_VAR 0 1
64792: PPUSH
64793: LD_EXP 124
64797: PUSH
64798: LD_VAR 0 4
64802: ARRAY
64803: PPUSH
64804: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
64808: LD_VAR 0 1
64812: PPUSH
64813: CALL_OW 263
64817: PUSH
64818: LD_INT 1
64820: NONEQUAL
64821: IFFALSE 64825
// break ;
64823: GO 64874
// repeat wait ( 0 0$1 ) ;
64825: LD_INT 35
64827: PPUSH
64828: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
64832: LD_VAR 0 1
64836: PPUSH
64837: LD_EXP 124
64841: PUSH
64842: LD_VAR 0 4
64846: ARRAY
64847: PPUSH
64848: CALL_OW 308
64852: IFFALSE 64825
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
64854: LD_VAR 0 1
64858: PPUSH
64859: CALL_OW 311
64863: PPUSH
64864: CALL_OW 121
// exit ;
64868: POP
64869: POP
64870: GO 64884
// end ; end ;
64872: GO 64516
64874: POP
64875: POP
// mc_block_vehicle_constructed_thread := false ;
64876: LD_ADDR_EXP 144
64880: PUSH
64881: LD_INT 0
64883: ST_TO_ADDR
// end ;
64884: LD_VAR 0 3
64888: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
64889: LD_INT 0
64891: PPUSH
64892: PPUSH
64893: PPUSH
64894: PPUSH
// if not mc_bases or not skirmish then
64895: LD_EXP 100
64899: NOT
64900: PUSH
64901: LD_EXP 98
64905: NOT
64906: OR
64907: IFFALSE 64911
// exit ;
64909: GO 65264
// repeat wait ( 0 0$1 ) ;
64911: LD_INT 35
64913: PPUSH
64914: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
64918: LD_VAR 0 2
64922: PPUSH
64923: LD_VAR 0 3
64927: PPUSH
64928: CALL_OW 284
64932: IFFALSE 64911
// if GetResourceTypeXY ( x , y ) = mat_artefact then
64934: LD_VAR 0 2
64938: PPUSH
64939: LD_VAR 0 3
64943: PPUSH
64944: CALL_OW 283
64948: PUSH
64949: LD_INT 4
64951: EQUAL
64952: IFFALSE 64956
// exit ;
64954: GO 65264
// for i = 1 to mc_bases do
64956: LD_ADDR_VAR 0 7
64960: PUSH
64961: DOUBLE
64962: LD_INT 1
64964: DEC
64965: ST_TO_ADDR
64966: LD_EXP 100
64970: PUSH
64971: FOR_TO
64972: IFFALSE 65262
// begin if mc_crates_area [ i ] then
64974: LD_EXP 118
64978: PUSH
64979: LD_VAR 0 7
64983: ARRAY
64984: IFFALSE 65095
// for j in mc_crates_area [ i ] do
64986: LD_ADDR_VAR 0 8
64990: PUSH
64991: LD_EXP 118
64995: PUSH
64996: LD_VAR 0 7
65000: ARRAY
65001: PUSH
65002: FOR_IN
65003: IFFALSE 65093
// if InArea ( x , y , j ) then
65005: LD_VAR 0 2
65009: PPUSH
65010: LD_VAR 0 3
65014: PPUSH
65015: LD_VAR 0 8
65019: PPUSH
65020: CALL_OW 309
65024: IFFALSE 65091
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65026: LD_ADDR_EXP 116
65030: PUSH
65031: LD_EXP 116
65035: PPUSH
65036: LD_VAR 0 7
65040: PUSH
65041: LD_EXP 116
65045: PUSH
65046: LD_VAR 0 7
65050: ARRAY
65051: PUSH
65052: LD_INT 1
65054: PLUS
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PPUSH
65060: LD_VAR 0 4
65064: PUSH
65065: LD_VAR 0 2
65069: PUSH
65070: LD_VAR 0 3
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: LIST
65079: PPUSH
65080: CALL 73519 0 3
65084: ST_TO_ADDR
// exit ;
65085: POP
65086: POP
65087: POP
65088: POP
65089: GO 65264
// end ;
65091: GO 65002
65093: POP
65094: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65095: LD_ADDR_VAR 0 9
65099: PUSH
65100: LD_EXP 100
65104: PUSH
65105: LD_VAR 0 7
65109: ARRAY
65110: PPUSH
65111: LD_INT 2
65113: PUSH
65114: LD_INT 30
65116: PUSH
65117: LD_INT 0
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 30
65126: PUSH
65127: LD_INT 1
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: LIST
65138: PPUSH
65139: CALL_OW 72
65143: ST_TO_ADDR
// if not depot then
65144: LD_VAR 0 9
65148: NOT
65149: IFFALSE 65153
// continue ;
65151: GO 64971
// for j in depot do
65153: LD_ADDR_VAR 0 8
65157: PUSH
65158: LD_VAR 0 9
65162: PUSH
65163: FOR_IN
65164: IFFALSE 65258
// if GetDistUnitXY ( j , x , y ) < 30 then
65166: LD_VAR 0 8
65170: PPUSH
65171: LD_VAR 0 2
65175: PPUSH
65176: LD_VAR 0 3
65180: PPUSH
65181: CALL_OW 297
65185: PUSH
65186: LD_INT 30
65188: LESS
65189: IFFALSE 65256
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65191: LD_ADDR_EXP 116
65195: PUSH
65196: LD_EXP 116
65200: PPUSH
65201: LD_VAR 0 7
65205: PUSH
65206: LD_EXP 116
65210: PUSH
65211: LD_VAR 0 7
65215: ARRAY
65216: PUSH
65217: LD_INT 1
65219: PLUS
65220: PUSH
65221: EMPTY
65222: LIST
65223: LIST
65224: PPUSH
65225: LD_VAR 0 4
65229: PUSH
65230: LD_VAR 0 2
65234: PUSH
65235: LD_VAR 0 3
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: LIST
65244: PPUSH
65245: CALL 73519 0 3
65249: ST_TO_ADDR
// exit ;
65250: POP
65251: POP
65252: POP
65253: POP
65254: GO 65264
// end ;
65256: GO 65163
65258: POP
65259: POP
// end ;
65260: GO 64971
65262: POP
65263: POP
// end ;
65264: LD_VAR 0 6
65268: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
65269: LD_INT 0
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
// if not mc_bases or not skirmish then
65275: LD_EXP 100
65279: NOT
65280: PUSH
65281: LD_EXP 98
65285: NOT
65286: OR
65287: IFFALSE 65291
// exit ;
65289: GO 65568
// side := GetSide ( lab ) ;
65291: LD_ADDR_VAR 0 4
65295: PUSH
65296: LD_VAR 0 2
65300: PPUSH
65301: CALL_OW 255
65305: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
65306: LD_VAR 0 4
65310: PUSH
65311: LD_EXP 126
65315: IN
65316: NOT
65317: PUSH
65318: LD_EXP 127
65322: NOT
65323: OR
65324: PUSH
65325: LD_EXP 100
65329: NOT
65330: OR
65331: IFFALSE 65335
// exit ;
65333: GO 65568
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
65335: LD_ADDR_EXP 127
65339: PUSH
65340: LD_EXP 127
65344: PPUSH
65345: LD_VAR 0 4
65349: PPUSH
65350: LD_EXP 127
65354: PUSH
65355: LD_VAR 0 4
65359: ARRAY
65360: PUSH
65361: LD_VAR 0 1
65365: DIFF
65366: PPUSH
65367: CALL_OW 1
65371: ST_TO_ADDR
// for i = 1 to mc_bases do
65372: LD_ADDR_VAR 0 5
65376: PUSH
65377: DOUBLE
65378: LD_INT 1
65380: DEC
65381: ST_TO_ADDR
65382: LD_EXP 100
65386: PUSH
65387: FOR_TO
65388: IFFALSE 65566
// begin if lab in mc_bases [ i ] then
65390: LD_VAR 0 2
65394: PUSH
65395: LD_EXP 100
65399: PUSH
65400: LD_VAR 0 5
65404: ARRAY
65405: IN
65406: IFFALSE 65564
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
65408: LD_VAR 0 1
65412: PUSH
65413: LD_INT 11
65415: PUSH
65416: LD_INT 4
65418: PUSH
65419: LD_INT 3
65421: PUSH
65422: LD_INT 2
65424: PUSH
65425: EMPTY
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: IN
65431: PUSH
65432: LD_EXP 130
65436: PUSH
65437: LD_VAR 0 5
65441: ARRAY
65442: AND
65443: IFFALSE 65564
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
65445: LD_ADDR_VAR 0 6
65449: PUSH
65450: LD_EXP 130
65454: PUSH
65455: LD_VAR 0 5
65459: ARRAY
65460: PUSH
65461: LD_INT 1
65463: ARRAY
65464: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65465: LD_ADDR_EXP 130
65469: PUSH
65470: LD_EXP 130
65474: PPUSH
65475: LD_VAR 0 5
65479: PPUSH
65480: EMPTY
65481: PPUSH
65482: CALL_OW 1
65486: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
65487: LD_VAR 0 6
65491: PPUSH
65492: LD_INT 0
65494: PPUSH
65495: CALL_OW 109
// ComExitBuilding ( tmp ) ;
65499: LD_VAR 0 6
65503: PPUSH
65504: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
65508: LD_ADDR_EXP 129
65512: PUSH
65513: LD_EXP 129
65517: PPUSH
65518: LD_VAR 0 5
65522: PPUSH
65523: LD_EXP 129
65527: PUSH
65528: LD_VAR 0 5
65532: ARRAY
65533: PPUSH
65534: LD_INT 1
65536: PPUSH
65537: LD_VAR 0 6
65541: PPUSH
65542: CALL_OW 2
65546: PPUSH
65547: CALL_OW 1
65551: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
65552: LD_VAR 0 5
65556: PPUSH
65557: LD_INT 112
65559: PPUSH
65560: CALL 42032 0 2
// end ; end ; end ;
65564: GO 65387
65566: POP
65567: POP
// end ;
65568: LD_VAR 0 3
65572: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
65573: LD_INT 0
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
65579: PPUSH
65580: PPUSH
65581: PPUSH
65582: PPUSH
// if not mc_bases or not skirmish then
65583: LD_EXP 100
65587: NOT
65588: PUSH
65589: LD_EXP 98
65593: NOT
65594: OR
65595: IFFALSE 65599
// exit ;
65597: GO 66968
// for i = 1 to mc_bases do
65599: LD_ADDR_VAR 0 3
65603: PUSH
65604: DOUBLE
65605: LD_INT 1
65607: DEC
65608: ST_TO_ADDR
65609: LD_EXP 100
65613: PUSH
65614: FOR_TO
65615: IFFALSE 66966
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
65617: LD_VAR 0 1
65621: PUSH
65622: LD_EXP 100
65626: PUSH
65627: LD_VAR 0 3
65631: ARRAY
65632: IN
65633: PUSH
65634: LD_VAR 0 1
65638: PUSH
65639: LD_EXP 107
65643: PUSH
65644: LD_VAR 0 3
65648: ARRAY
65649: IN
65650: OR
65651: PUSH
65652: LD_VAR 0 1
65656: PUSH
65657: LD_EXP 122
65661: PUSH
65662: LD_VAR 0 3
65666: ARRAY
65667: IN
65668: OR
65669: PUSH
65670: LD_VAR 0 1
65674: PUSH
65675: LD_EXP 119
65679: PUSH
65680: LD_VAR 0 3
65684: ARRAY
65685: IN
65686: OR
65687: PUSH
65688: LD_VAR 0 1
65692: PUSH
65693: LD_EXP 129
65697: PUSH
65698: LD_VAR 0 3
65702: ARRAY
65703: IN
65704: OR
65705: PUSH
65706: LD_VAR 0 1
65710: PUSH
65711: LD_EXP 130
65715: PUSH
65716: LD_VAR 0 3
65720: ARRAY
65721: IN
65722: OR
65723: IFFALSE 66964
// begin if un in mc_ape [ i ] then
65725: LD_VAR 0 1
65729: PUSH
65730: LD_EXP 129
65734: PUSH
65735: LD_VAR 0 3
65739: ARRAY
65740: IN
65741: IFFALSE 65780
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
65743: LD_ADDR_EXP 129
65747: PUSH
65748: LD_EXP 129
65752: PPUSH
65753: LD_VAR 0 3
65757: PPUSH
65758: LD_EXP 129
65762: PUSH
65763: LD_VAR 0 3
65767: ARRAY
65768: PUSH
65769: LD_VAR 0 1
65773: DIFF
65774: PPUSH
65775: CALL_OW 1
65779: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
65780: LD_VAR 0 1
65784: PUSH
65785: LD_EXP 130
65789: PUSH
65790: LD_VAR 0 3
65794: ARRAY
65795: IN
65796: IFFALSE 65820
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65798: LD_ADDR_EXP 130
65802: PUSH
65803: LD_EXP 130
65807: PPUSH
65808: LD_VAR 0 3
65812: PPUSH
65813: EMPTY
65814: PPUSH
65815: CALL_OW 1
65819: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
65820: LD_VAR 0 1
65824: PPUSH
65825: CALL_OW 247
65829: PUSH
65830: LD_INT 2
65832: EQUAL
65833: PUSH
65834: LD_VAR 0 1
65838: PPUSH
65839: CALL_OW 110
65843: PUSH
65844: LD_INT 20
65846: EQUAL
65847: PUSH
65848: LD_VAR 0 1
65852: PUSH
65853: LD_EXP 122
65857: PUSH
65858: LD_VAR 0 3
65862: ARRAY
65863: IN
65864: OR
65865: PUSH
65866: LD_VAR 0 1
65870: PPUSH
65871: CALL_OW 264
65875: PUSH
65876: LD_INT 12
65878: PUSH
65879: LD_INT 51
65881: PUSH
65882: LD_INT 89
65884: PUSH
65885: LD_INT 32
65887: PUSH
65888: LD_INT 13
65890: PUSH
65891: LD_INT 52
65893: PUSH
65894: LD_INT 31
65896: PUSH
65897: EMPTY
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: IN
65906: OR
65907: AND
65908: IFFALSE 66216
// begin if un in mc_defender [ i ] then
65910: LD_VAR 0 1
65914: PUSH
65915: LD_EXP 122
65919: PUSH
65920: LD_VAR 0 3
65924: ARRAY
65925: IN
65926: IFFALSE 65965
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65928: LD_ADDR_EXP 122
65932: PUSH
65933: LD_EXP 122
65937: PPUSH
65938: LD_VAR 0 3
65942: PPUSH
65943: LD_EXP 122
65947: PUSH
65948: LD_VAR 0 3
65952: ARRAY
65953: PUSH
65954: LD_VAR 0 1
65958: DIFF
65959: PPUSH
65960: CALL_OW 1
65964: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
65965: LD_ADDR_VAR 0 8
65969: PUSH
65970: LD_VAR 0 3
65974: PPUSH
65975: LD_INT 3
65977: PPUSH
65978: CALL 62586 0 2
65982: ST_TO_ADDR
// if fac then
65983: LD_VAR 0 8
65987: IFFALSE 66216
// begin for j in fac do
65989: LD_ADDR_VAR 0 4
65993: PUSH
65994: LD_VAR 0 8
65998: PUSH
65999: FOR_IN
66000: IFFALSE 66214
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66002: LD_ADDR_VAR 0 9
66006: PUSH
66007: LD_VAR 0 8
66011: PPUSH
66012: LD_VAR 0 1
66016: PPUSH
66017: CALL_OW 265
66021: PPUSH
66022: LD_VAR 0 1
66026: PPUSH
66027: CALL_OW 262
66031: PPUSH
66032: LD_VAR 0 1
66036: PPUSH
66037: CALL_OW 263
66041: PPUSH
66042: LD_VAR 0 1
66046: PPUSH
66047: CALL_OW 264
66051: PPUSH
66052: CALL 71017 0 5
66056: ST_TO_ADDR
// if components then
66057: LD_VAR 0 9
66061: IFFALSE 66212
// begin if GetWeapon ( un ) = ar_control_tower then
66063: LD_VAR 0 1
66067: PPUSH
66068: CALL_OW 264
66072: PUSH
66073: LD_INT 31
66075: EQUAL
66076: IFFALSE 66193
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66078: LD_VAR 0 1
66082: PPUSH
66083: CALL_OW 311
66087: PPUSH
66088: LD_INT 0
66090: PPUSH
66091: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66095: LD_ADDR_EXP 140
66099: PUSH
66100: LD_EXP 140
66104: PPUSH
66105: LD_VAR 0 3
66109: PPUSH
66110: LD_EXP 140
66114: PUSH
66115: LD_VAR 0 3
66119: ARRAY
66120: PUSH
66121: LD_VAR 0 1
66125: PPUSH
66126: CALL_OW 311
66130: DIFF
66131: PPUSH
66132: CALL_OW 1
66136: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
66137: LD_ADDR_VAR 0 7
66141: PUSH
66142: LD_EXP 121
66146: PUSH
66147: LD_VAR 0 3
66151: ARRAY
66152: PPUSH
66153: LD_INT 1
66155: PPUSH
66156: LD_VAR 0 9
66160: PPUSH
66161: CALL_OW 2
66165: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66166: LD_ADDR_EXP 121
66170: PUSH
66171: LD_EXP 121
66175: PPUSH
66176: LD_VAR 0 3
66180: PPUSH
66181: LD_VAR 0 7
66185: PPUSH
66186: CALL_OW 1
66190: ST_TO_ADDR
// end else
66191: GO 66210
// MC_InsertProduceList ( i , [ components ] ) ;
66193: LD_VAR 0 3
66197: PPUSH
66198: LD_VAR 0 9
66202: PUSH
66203: EMPTY
66204: LIST
66205: PPUSH
66206: CALL 62131 0 2
// break ;
66210: GO 66214
// end ; end ;
66212: GO 65999
66214: POP
66215: POP
// end ; end ; if GetType ( un ) = unit_building then
66216: LD_VAR 0 1
66220: PPUSH
66221: CALL_OW 247
66225: PUSH
66226: LD_INT 3
66228: EQUAL
66229: IFFALSE 66632
// begin btype := GetBType ( un ) ;
66231: LD_ADDR_VAR 0 5
66235: PUSH
66236: LD_VAR 0 1
66240: PPUSH
66241: CALL_OW 266
66245: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
66246: LD_VAR 0 5
66250: PUSH
66251: LD_INT 29
66253: PUSH
66254: LD_INT 30
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: IN
66261: IFFALSE 66334
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
66263: LD_VAR 0 1
66267: PPUSH
66268: CALL_OW 250
66272: PPUSH
66273: LD_VAR 0 1
66277: PPUSH
66278: CALL_OW 251
66282: PPUSH
66283: LD_VAR 0 1
66287: PPUSH
66288: CALL_OW 255
66292: PPUSH
66293: CALL_OW 440
66297: NOT
66298: IFFALSE 66334
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
66300: LD_VAR 0 1
66304: PPUSH
66305: CALL_OW 250
66309: PPUSH
66310: LD_VAR 0 1
66314: PPUSH
66315: CALL_OW 251
66319: PPUSH
66320: LD_VAR 0 1
66324: PPUSH
66325: CALL_OW 255
66329: PPUSH
66330: CALL_OW 441
// end ; if btype = b_warehouse then
66334: LD_VAR 0 5
66338: PUSH
66339: LD_INT 1
66341: EQUAL
66342: IFFALSE 66360
// begin btype := b_depot ;
66344: LD_ADDR_VAR 0 5
66348: PUSH
66349: LD_INT 0
66351: ST_TO_ADDR
// pos := 1 ;
66352: LD_ADDR_VAR 0 6
66356: PUSH
66357: LD_INT 1
66359: ST_TO_ADDR
// end ; if btype = b_factory then
66360: LD_VAR 0 5
66364: PUSH
66365: LD_INT 3
66367: EQUAL
66368: IFFALSE 66386
// begin btype := b_workshop ;
66370: LD_ADDR_VAR 0 5
66374: PUSH
66375: LD_INT 2
66377: ST_TO_ADDR
// pos := 1 ;
66378: LD_ADDR_VAR 0 6
66382: PUSH
66383: LD_INT 1
66385: ST_TO_ADDR
// end ; if btype = b_barracks then
66386: LD_VAR 0 5
66390: PUSH
66391: LD_INT 5
66393: EQUAL
66394: IFFALSE 66404
// btype := b_armoury ;
66396: LD_ADDR_VAR 0 5
66400: PUSH
66401: LD_INT 4
66403: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
66404: LD_VAR 0 5
66408: PUSH
66409: LD_INT 7
66411: PUSH
66412: LD_INT 8
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: IN
66419: IFFALSE 66429
// btype := b_lab ;
66421: LD_ADDR_VAR 0 5
66425: PUSH
66426: LD_INT 6
66428: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
66429: LD_ADDR_EXP 105
66433: PUSH
66434: LD_EXP 105
66438: PPUSH
66439: LD_VAR 0 3
66443: PUSH
66444: LD_EXP 105
66448: PUSH
66449: LD_VAR 0 3
66453: ARRAY
66454: PUSH
66455: LD_INT 1
66457: PLUS
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PPUSH
66463: LD_VAR 0 5
66467: PUSH
66468: LD_VAR 0 1
66472: PPUSH
66473: CALL_OW 250
66477: PUSH
66478: LD_VAR 0 1
66482: PPUSH
66483: CALL_OW 251
66487: PUSH
66488: LD_VAR 0 1
66492: PPUSH
66493: CALL_OW 254
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: PPUSH
66504: CALL 73519 0 3
66508: ST_TO_ADDR
// if pos = 1 then
66509: LD_VAR 0 6
66513: PUSH
66514: LD_INT 1
66516: EQUAL
66517: IFFALSE 66632
// begin tmp := mc_build_list [ i ] ;
66519: LD_ADDR_VAR 0 7
66523: PUSH
66524: LD_EXP 105
66528: PUSH
66529: LD_VAR 0 3
66533: ARRAY
66534: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66535: LD_VAR 0 7
66539: PPUSH
66540: LD_INT 2
66542: PUSH
66543: LD_INT 30
66545: PUSH
66546: LD_INT 0
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: LD_INT 30
66555: PUSH
66556: LD_INT 1
66558: PUSH
66559: EMPTY
66560: LIST
66561: LIST
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: LIST
66567: PPUSH
66568: CALL_OW 72
66572: IFFALSE 66582
// pos := 2 ;
66574: LD_ADDR_VAR 0 6
66578: PUSH
66579: LD_INT 2
66581: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
66582: LD_ADDR_VAR 0 7
66586: PUSH
66587: LD_VAR 0 7
66591: PPUSH
66592: LD_VAR 0 6
66596: PPUSH
66597: LD_VAR 0 7
66601: PPUSH
66602: CALL 73845 0 3
66606: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
66607: LD_ADDR_EXP 105
66611: PUSH
66612: LD_EXP 105
66616: PPUSH
66617: LD_VAR 0 3
66621: PPUSH
66622: LD_VAR 0 7
66626: PPUSH
66627: CALL_OW 1
66631: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
66632: LD_VAR 0 1
66636: PUSH
66637: LD_EXP 100
66641: PUSH
66642: LD_VAR 0 3
66646: ARRAY
66647: IN
66648: IFFALSE 66687
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
66650: LD_ADDR_EXP 100
66654: PUSH
66655: LD_EXP 100
66659: PPUSH
66660: LD_VAR 0 3
66664: PPUSH
66665: LD_EXP 100
66669: PUSH
66670: LD_VAR 0 3
66674: ARRAY
66675: PUSH
66676: LD_VAR 0 1
66680: DIFF
66681: PPUSH
66682: CALL_OW 1
66686: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
66687: LD_VAR 0 1
66691: PUSH
66692: LD_EXP 107
66696: PUSH
66697: LD_VAR 0 3
66701: ARRAY
66702: IN
66703: IFFALSE 66742
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
66705: LD_ADDR_EXP 107
66709: PUSH
66710: LD_EXP 107
66714: PPUSH
66715: LD_VAR 0 3
66719: PPUSH
66720: LD_EXP 107
66724: PUSH
66725: LD_VAR 0 3
66729: ARRAY
66730: PUSH
66731: LD_VAR 0 1
66735: DIFF
66736: PPUSH
66737: CALL_OW 1
66741: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
66742: LD_VAR 0 1
66746: PUSH
66747: LD_EXP 119
66751: PUSH
66752: LD_VAR 0 3
66756: ARRAY
66757: IN
66758: IFFALSE 66797
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
66760: LD_ADDR_EXP 119
66764: PUSH
66765: LD_EXP 119
66769: PPUSH
66770: LD_VAR 0 3
66774: PPUSH
66775: LD_EXP 119
66779: PUSH
66780: LD_VAR 0 3
66784: ARRAY
66785: PUSH
66786: LD_VAR 0 1
66790: DIFF
66791: PPUSH
66792: CALL_OW 1
66796: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
66797: LD_VAR 0 1
66801: PUSH
66802: LD_EXP 122
66806: PUSH
66807: LD_VAR 0 3
66811: ARRAY
66812: IN
66813: IFFALSE 66852
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66815: LD_ADDR_EXP 122
66819: PUSH
66820: LD_EXP 122
66824: PPUSH
66825: LD_VAR 0 3
66829: PPUSH
66830: LD_EXP 122
66834: PUSH
66835: LD_VAR 0 3
66839: ARRAY
66840: PUSH
66841: LD_VAR 0 1
66845: DIFF
66846: PPUSH
66847: CALL_OW 1
66851: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
66852: LD_VAR 0 1
66856: PUSH
66857: LD_EXP 109
66861: PUSH
66862: LD_VAR 0 3
66866: ARRAY
66867: IN
66868: IFFALSE 66907
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
66870: LD_ADDR_EXP 109
66874: PUSH
66875: LD_EXP 109
66879: PPUSH
66880: LD_VAR 0 3
66884: PPUSH
66885: LD_EXP 109
66889: PUSH
66890: LD_VAR 0 3
66894: ARRAY
66895: PUSH
66896: LD_VAR 0 1
66900: DIFF
66901: PPUSH
66902: CALL_OW 1
66906: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
66907: LD_VAR 0 1
66911: PUSH
66912: LD_EXP 108
66916: PUSH
66917: LD_VAR 0 3
66921: ARRAY
66922: IN
66923: IFFALSE 66962
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
66925: LD_ADDR_EXP 108
66929: PUSH
66930: LD_EXP 108
66934: PPUSH
66935: LD_VAR 0 3
66939: PPUSH
66940: LD_EXP 108
66944: PUSH
66945: LD_VAR 0 3
66949: ARRAY
66950: PUSH
66951: LD_VAR 0 1
66955: DIFF
66956: PPUSH
66957: CALL_OW 1
66961: ST_TO_ADDR
// end ; break ;
66962: GO 66966
// end ;
66964: GO 65614
66966: POP
66967: POP
// end ;
66968: LD_VAR 0 2
66972: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
66973: LD_INT 0
66975: PPUSH
66976: PPUSH
66977: PPUSH
// if not mc_bases or not skirmish then
66978: LD_EXP 100
66982: NOT
66983: PUSH
66984: LD_EXP 98
66988: NOT
66989: OR
66990: IFFALSE 66994
// exit ;
66992: GO 67209
// for i = 1 to mc_bases do
66994: LD_ADDR_VAR 0 3
66998: PUSH
66999: DOUBLE
67000: LD_INT 1
67002: DEC
67003: ST_TO_ADDR
67004: LD_EXP 100
67008: PUSH
67009: FOR_TO
67010: IFFALSE 67207
// begin if building in mc_construct_list [ i ] then
67012: LD_VAR 0 1
67016: PUSH
67017: LD_EXP 107
67021: PUSH
67022: LD_VAR 0 3
67026: ARRAY
67027: IN
67028: IFFALSE 67205
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67030: LD_ADDR_EXP 107
67034: PUSH
67035: LD_EXP 107
67039: PPUSH
67040: LD_VAR 0 3
67044: PPUSH
67045: LD_EXP 107
67049: PUSH
67050: LD_VAR 0 3
67054: ARRAY
67055: PUSH
67056: LD_VAR 0 1
67060: DIFF
67061: PPUSH
67062: CALL_OW 1
67066: ST_TO_ADDR
// if building in mc_lab [ i ] then
67067: LD_VAR 0 1
67071: PUSH
67072: LD_EXP 133
67076: PUSH
67077: LD_VAR 0 3
67081: ARRAY
67082: IN
67083: IFFALSE 67138
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67085: LD_ADDR_EXP 134
67089: PUSH
67090: LD_EXP 134
67094: PPUSH
67095: LD_VAR 0 3
67099: PPUSH
67100: LD_EXP 134
67104: PUSH
67105: LD_VAR 0 3
67109: ARRAY
67110: PPUSH
67111: LD_INT 1
67113: PPUSH
67114: LD_EXP 134
67118: PUSH
67119: LD_VAR 0 3
67123: ARRAY
67124: PPUSH
67125: LD_INT 0
67127: PPUSH
67128: CALL 72937 0 4
67132: PPUSH
67133: CALL_OW 1
67137: ST_TO_ADDR
// if not building in mc_bases [ i ] then
67138: LD_VAR 0 1
67142: PUSH
67143: LD_EXP 100
67147: PUSH
67148: LD_VAR 0 3
67152: ARRAY
67153: IN
67154: NOT
67155: IFFALSE 67201
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67157: LD_ADDR_EXP 100
67161: PUSH
67162: LD_EXP 100
67166: PPUSH
67167: LD_VAR 0 3
67171: PUSH
67172: LD_EXP 100
67176: PUSH
67177: LD_VAR 0 3
67181: ARRAY
67182: PUSH
67183: LD_INT 1
67185: PLUS
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PPUSH
67191: LD_VAR 0 1
67195: PPUSH
67196: CALL 73519 0 3
67200: ST_TO_ADDR
// exit ;
67201: POP
67202: POP
67203: GO 67209
// end ; end ;
67205: GO 67009
67207: POP
67208: POP
// end ;
67209: LD_VAR 0 2
67213: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
67214: LD_INT 0
67216: PPUSH
67217: PPUSH
67218: PPUSH
67219: PPUSH
67220: PPUSH
67221: PPUSH
67222: PPUSH
// if not mc_bases or not skirmish then
67223: LD_EXP 100
67227: NOT
67228: PUSH
67229: LD_EXP 98
67233: NOT
67234: OR
67235: IFFALSE 67239
// exit ;
67237: GO 67900
// for i = 1 to mc_bases do
67239: LD_ADDR_VAR 0 3
67243: PUSH
67244: DOUBLE
67245: LD_INT 1
67247: DEC
67248: ST_TO_ADDR
67249: LD_EXP 100
67253: PUSH
67254: FOR_TO
67255: IFFALSE 67898
// begin if building in mc_construct_list [ i ] then
67257: LD_VAR 0 1
67261: PUSH
67262: LD_EXP 107
67266: PUSH
67267: LD_VAR 0 3
67271: ARRAY
67272: IN
67273: IFFALSE 67896
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67275: LD_ADDR_EXP 107
67279: PUSH
67280: LD_EXP 107
67284: PPUSH
67285: LD_VAR 0 3
67289: PPUSH
67290: LD_EXP 107
67294: PUSH
67295: LD_VAR 0 3
67299: ARRAY
67300: PUSH
67301: LD_VAR 0 1
67305: DIFF
67306: PPUSH
67307: CALL_OW 1
67311: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67312: LD_ADDR_EXP 100
67316: PUSH
67317: LD_EXP 100
67321: PPUSH
67322: LD_VAR 0 3
67326: PUSH
67327: LD_EXP 100
67331: PUSH
67332: LD_VAR 0 3
67336: ARRAY
67337: PUSH
67338: LD_INT 1
67340: PLUS
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PPUSH
67346: LD_VAR 0 1
67350: PPUSH
67351: CALL 73519 0 3
67355: ST_TO_ADDR
// btype := GetBType ( building ) ;
67356: LD_ADDR_VAR 0 5
67360: PUSH
67361: LD_VAR 0 1
67365: PPUSH
67366: CALL_OW 266
67370: ST_TO_ADDR
// side := GetSide ( building ) ;
67371: LD_ADDR_VAR 0 8
67375: PUSH
67376: LD_VAR 0 1
67380: PPUSH
67381: CALL_OW 255
67385: ST_TO_ADDR
// if btype = b_lab then
67386: LD_VAR 0 5
67390: PUSH
67391: LD_INT 6
67393: EQUAL
67394: IFFALSE 67444
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
67396: LD_ADDR_EXP 133
67400: PUSH
67401: LD_EXP 133
67405: PPUSH
67406: LD_VAR 0 3
67410: PUSH
67411: LD_EXP 133
67415: PUSH
67416: LD_VAR 0 3
67420: ARRAY
67421: PUSH
67422: LD_INT 1
67424: PLUS
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PPUSH
67430: LD_VAR 0 1
67434: PPUSH
67435: CALL 73519 0 3
67439: ST_TO_ADDR
// exit ;
67440: POP
67441: POP
67442: GO 67900
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
67444: LD_VAR 0 5
67448: PUSH
67449: LD_INT 0
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: LD_INT 4
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: LIST
67462: IN
67463: IFFALSE 67587
// begin if btype = b_armoury then
67465: LD_VAR 0 5
67469: PUSH
67470: LD_INT 4
67472: EQUAL
67473: IFFALSE 67483
// btype := b_barracks ;
67475: LD_ADDR_VAR 0 5
67479: PUSH
67480: LD_INT 5
67482: ST_TO_ADDR
// if btype = b_depot then
67483: LD_VAR 0 5
67487: PUSH
67488: LD_INT 0
67490: EQUAL
67491: IFFALSE 67501
// btype := b_warehouse ;
67493: LD_ADDR_VAR 0 5
67497: PUSH
67498: LD_INT 1
67500: ST_TO_ADDR
// if btype = b_workshop then
67501: LD_VAR 0 5
67505: PUSH
67506: LD_INT 2
67508: EQUAL
67509: IFFALSE 67519
// btype := b_factory ;
67511: LD_ADDR_VAR 0 5
67515: PUSH
67516: LD_INT 3
67518: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
67519: LD_VAR 0 5
67523: PPUSH
67524: LD_VAR 0 8
67528: PPUSH
67529: CALL_OW 323
67533: PUSH
67534: LD_INT 1
67536: EQUAL
67537: IFFALSE 67583
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
67539: LD_ADDR_EXP 132
67543: PUSH
67544: LD_EXP 132
67548: PPUSH
67549: LD_VAR 0 3
67553: PUSH
67554: LD_EXP 132
67558: PUSH
67559: LD_VAR 0 3
67563: ARRAY
67564: PUSH
67565: LD_INT 1
67567: PLUS
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PPUSH
67573: LD_VAR 0 1
67577: PPUSH
67578: CALL 73519 0 3
67582: ST_TO_ADDR
// exit ;
67583: POP
67584: POP
67585: GO 67900
// end ; if btype in [ b_bunker , b_turret ] then
67587: LD_VAR 0 5
67591: PUSH
67592: LD_INT 32
67594: PUSH
67595: LD_INT 33
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: IN
67602: IFFALSE 67892
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
67604: LD_ADDR_EXP 108
67608: PUSH
67609: LD_EXP 108
67613: PPUSH
67614: LD_VAR 0 3
67618: PUSH
67619: LD_EXP 108
67623: PUSH
67624: LD_VAR 0 3
67628: ARRAY
67629: PUSH
67630: LD_INT 1
67632: PLUS
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PPUSH
67638: LD_VAR 0 1
67642: PPUSH
67643: CALL 73519 0 3
67647: ST_TO_ADDR
// if btype = b_bunker then
67648: LD_VAR 0 5
67652: PUSH
67653: LD_INT 32
67655: EQUAL
67656: IFFALSE 67892
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67658: LD_ADDR_EXP 109
67662: PUSH
67663: LD_EXP 109
67667: PPUSH
67668: LD_VAR 0 3
67672: PUSH
67673: LD_EXP 109
67677: PUSH
67678: LD_VAR 0 3
67682: ARRAY
67683: PUSH
67684: LD_INT 1
67686: PLUS
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PPUSH
67692: LD_VAR 0 1
67696: PPUSH
67697: CALL 73519 0 3
67701: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
67702: LD_ADDR_VAR 0 6
67706: PUSH
67707: LD_EXP 100
67711: PUSH
67712: LD_VAR 0 3
67716: ARRAY
67717: PPUSH
67718: LD_INT 25
67720: PUSH
67721: LD_INT 1
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 3
67730: PUSH
67731: LD_INT 54
67733: PUSH
67734: EMPTY
67735: LIST
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: EMPTY
67742: LIST
67743: LIST
67744: PPUSH
67745: CALL_OW 72
67749: ST_TO_ADDR
// if tmp then
67750: LD_VAR 0 6
67754: IFFALSE 67760
// exit ;
67756: POP
67757: POP
67758: GO 67900
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67760: LD_ADDR_VAR 0 6
67764: PUSH
67765: LD_EXP 100
67769: PUSH
67770: LD_VAR 0 3
67774: ARRAY
67775: PPUSH
67776: LD_INT 2
67778: PUSH
67779: LD_INT 30
67781: PUSH
67782: LD_INT 4
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 30
67791: PUSH
67792: LD_INT 5
67794: PUSH
67795: EMPTY
67796: LIST
67797: LIST
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: LIST
67803: PPUSH
67804: CALL_OW 72
67808: ST_TO_ADDR
// if not tmp then
67809: LD_VAR 0 6
67813: NOT
67814: IFFALSE 67820
// exit ;
67816: POP
67817: POP
67818: GO 67900
// for j in tmp do
67820: LD_ADDR_VAR 0 4
67824: PUSH
67825: LD_VAR 0 6
67829: PUSH
67830: FOR_IN
67831: IFFALSE 67890
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
67833: LD_ADDR_VAR 0 7
67837: PUSH
67838: LD_VAR 0 4
67842: PPUSH
67843: CALL_OW 313
67847: PPUSH
67848: LD_INT 25
67850: PUSH
67851: LD_INT 1
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PPUSH
67858: CALL_OW 72
67862: ST_TO_ADDR
// if units then
67863: LD_VAR 0 7
67867: IFFALSE 67888
// begin ComExitBuilding ( units [ 1 ] ) ;
67869: LD_VAR 0 7
67873: PUSH
67874: LD_INT 1
67876: ARRAY
67877: PPUSH
67878: CALL_OW 122
// exit ;
67882: POP
67883: POP
67884: POP
67885: POP
67886: GO 67900
// end ; end ;
67888: GO 67830
67890: POP
67891: POP
// end ; end ; exit ;
67892: POP
67893: POP
67894: GO 67900
// end ; end ;
67896: GO 67254
67898: POP
67899: POP
// end ;
67900: LD_VAR 0 2
67904: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
67905: LD_INT 0
67907: PPUSH
67908: PPUSH
67909: PPUSH
67910: PPUSH
67911: PPUSH
67912: PPUSH
67913: PPUSH
// if not mc_bases or not skirmish then
67914: LD_EXP 100
67918: NOT
67919: PUSH
67920: LD_EXP 98
67924: NOT
67925: OR
67926: IFFALSE 67930
// exit ;
67928: GO 68195
// btype := GetBType ( building ) ;
67930: LD_ADDR_VAR 0 6
67934: PUSH
67935: LD_VAR 0 1
67939: PPUSH
67940: CALL_OW 266
67944: ST_TO_ADDR
// x := GetX ( building ) ;
67945: LD_ADDR_VAR 0 7
67949: PUSH
67950: LD_VAR 0 1
67954: PPUSH
67955: CALL_OW 250
67959: ST_TO_ADDR
// y := GetY ( building ) ;
67960: LD_ADDR_VAR 0 8
67964: PUSH
67965: LD_VAR 0 1
67969: PPUSH
67970: CALL_OW 251
67974: ST_TO_ADDR
// d := GetDir ( building ) ;
67975: LD_ADDR_VAR 0 9
67979: PUSH
67980: LD_VAR 0 1
67984: PPUSH
67985: CALL_OW 254
67989: ST_TO_ADDR
// for i = 1 to mc_bases do
67990: LD_ADDR_VAR 0 4
67994: PUSH
67995: DOUBLE
67996: LD_INT 1
67998: DEC
67999: ST_TO_ADDR
68000: LD_EXP 100
68004: PUSH
68005: FOR_TO
68006: IFFALSE 68193
// begin if not mc_build_list [ i ] then
68008: LD_EXP 105
68012: PUSH
68013: LD_VAR 0 4
68017: ARRAY
68018: NOT
68019: IFFALSE 68023
// continue ;
68021: GO 68005
// for j := 1 to mc_build_list [ i ] do
68023: LD_ADDR_VAR 0 5
68027: PUSH
68028: DOUBLE
68029: LD_INT 1
68031: DEC
68032: ST_TO_ADDR
68033: LD_EXP 105
68037: PUSH
68038: LD_VAR 0 4
68042: ARRAY
68043: PUSH
68044: FOR_TO
68045: IFFALSE 68189
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68047: LD_VAR 0 6
68051: PUSH
68052: LD_VAR 0 7
68056: PUSH
68057: LD_VAR 0 8
68061: PUSH
68062: LD_VAR 0 9
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: PPUSH
68073: LD_EXP 105
68077: PUSH
68078: LD_VAR 0 4
68082: ARRAY
68083: PUSH
68084: LD_VAR 0 5
68088: ARRAY
68089: PPUSH
68090: CALL 79699 0 2
68094: IFFALSE 68187
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68096: LD_ADDR_EXP 105
68100: PUSH
68101: LD_EXP 105
68105: PPUSH
68106: LD_VAR 0 4
68110: PPUSH
68111: LD_EXP 105
68115: PUSH
68116: LD_VAR 0 4
68120: ARRAY
68121: PPUSH
68122: LD_VAR 0 5
68126: PPUSH
68127: CALL_OW 3
68131: PPUSH
68132: CALL_OW 1
68136: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
68137: LD_ADDR_EXP 107
68141: PUSH
68142: LD_EXP 107
68146: PPUSH
68147: LD_VAR 0 4
68151: PUSH
68152: LD_EXP 107
68156: PUSH
68157: LD_VAR 0 4
68161: ARRAY
68162: PUSH
68163: LD_INT 1
68165: PLUS
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PPUSH
68171: LD_VAR 0 1
68175: PPUSH
68176: CALL 73519 0 3
68180: ST_TO_ADDR
// exit ;
68181: POP
68182: POP
68183: POP
68184: POP
68185: GO 68195
// end ;
68187: GO 68044
68189: POP
68190: POP
// end ;
68191: GO 68005
68193: POP
68194: POP
// end ;
68195: LD_VAR 0 3
68199: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
68200: LD_INT 0
68202: PPUSH
68203: PPUSH
68204: PPUSH
// if not mc_bases or not skirmish then
68205: LD_EXP 100
68209: NOT
68210: PUSH
68211: LD_EXP 98
68215: NOT
68216: OR
68217: IFFALSE 68221
// exit ;
68219: GO 68411
// for i = 1 to mc_bases do
68221: LD_ADDR_VAR 0 4
68225: PUSH
68226: DOUBLE
68227: LD_INT 1
68229: DEC
68230: ST_TO_ADDR
68231: LD_EXP 100
68235: PUSH
68236: FOR_TO
68237: IFFALSE 68324
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
68239: LD_VAR 0 1
68243: PUSH
68244: LD_EXP 108
68248: PUSH
68249: LD_VAR 0 4
68253: ARRAY
68254: IN
68255: PUSH
68256: LD_VAR 0 1
68260: PUSH
68261: LD_EXP 109
68265: PUSH
68266: LD_VAR 0 4
68270: ARRAY
68271: IN
68272: NOT
68273: AND
68274: IFFALSE 68322
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68276: LD_ADDR_EXP 109
68280: PUSH
68281: LD_EXP 109
68285: PPUSH
68286: LD_VAR 0 4
68290: PUSH
68291: LD_EXP 109
68295: PUSH
68296: LD_VAR 0 4
68300: ARRAY
68301: PUSH
68302: LD_INT 1
68304: PLUS
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PPUSH
68310: LD_VAR 0 1
68314: PPUSH
68315: CALL 73519 0 3
68319: ST_TO_ADDR
// break ;
68320: GO 68324
// end ; end ;
68322: GO 68236
68324: POP
68325: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
68326: LD_VAR 0 1
68330: PPUSH
68331: CALL_OW 257
68335: PUSH
68336: LD_EXP 126
68340: IN
68341: PUSH
68342: LD_VAR 0 1
68346: PPUSH
68347: CALL_OW 266
68351: PUSH
68352: LD_INT 5
68354: EQUAL
68355: AND
68356: PUSH
68357: LD_VAR 0 2
68361: PPUSH
68362: CALL_OW 110
68366: PUSH
68367: LD_INT 18
68369: NONEQUAL
68370: AND
68371: IFFALSE 68411
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
68373: LD_VAR 0 2
68377: PPUSH
68378: CALL_OW 257
68382: PUSH
68383: LD_INT 5
68385: PUSH
68386: LD_INT 8
68388: PUSH
68389: LD_INT 9
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: LIST
68396: IN
68397: IFFALSE 68411
// SetClass ( unit , 1 ) ;
68399: LD_VAR 0 2
68403: PPUSH
68404: LD_INT 1
68406: PPUSH
68407: CALL_OW 336
// end ;
68411: LD_VAR 0 3
68415: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
68416: LD_INT 0
68418: PPUSH
68419: PPUSH
// if not mc_bases or not skirmish then
68420: LD_EXP 100
68424: NOT
68425: PUSH
68426: LD_EXP 98
68430: NOT
68431: OR
68432: IFFALSE 68436
// exit ;
68434: GO 68552
// if GetLives ( abandoned_vehicle ) > 250 then
68436: LD_VAR 0 2
68440: PPUSH
68441: CALL_OW 256
68445: PUSH
68446: LD_INT 250
68448: GREATER
68449: IFFALSE 68453
// exit ;
68451: GO 68552
// for i = 1 to mc_bases do
68453: LD_ADDR_VAR 0 6
68457: PUSH
68458: DOUBLE
68459: LD_INT 1
68461: DEC
68462: ST_TO_ADDR
68463: LD_EXP 100
68467: PUSH
68468: FOR_TO
68469: IFFALSE 68550
// begin if driver in mc_bases [ i ] then
68471: LD_VAR 0 1
68475: PUSH
68476: LD_EXP 100
68480: PUSH
68481: LD_VAR 0 6
68485: ARRAY
68486: IN
68487: IFFALSE 68548
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
68489: LD_VAR 0 1
68493: PPUSH
68494: LD_EXP 100
68498: PUSH
68499: LD_VAR 0 6
68503: ARRAY
68504: PPUSH
68505: LD_INT 2
68507: PUSH
68508: LD_INT 30
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 30
68520: PUSH
68521: LD_INT 1
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: LIST
68532: PPUSH
68533: CALL_OW 72
68537: PUSH
68538: LD_INT 1
68540: ARRAY
68541: PPUSH
68542: CALL 106726 0 2
// break ;
68546: GO 68550
// end ; end ;
68548: GO 68468
68550: POP
68551: POP
// end ; end_of_file
68552: LD_VAR 0 5
68556: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
68557: LD_INT 0
68559: PPUSH
68560: PPUSH
// if exist_mode then
68561: LD_VAR 0 2
68565: IFFALSE 68590
// unit := CreateCharacter ( prefix & ident ) else
68567: LD_ADDR_VAR 0 5
68571: PUSH
68572: LD_VAR 0 3
68576: PUSH
68577: LD_VAR 0 1
68581: STR
68582: PPUSH
68583: CALL_OW 34
68587: ST_TO_ADDR
68588: GO 68605
// unit := NewCharacter ( ident ) ;
68590: LD_ADDR_VAR 0 5
68594: PUSH
68595: LD_VAR 0 1
68599: PPUSH
68600: CALL_OW 25
68604: ST_TO_ADDR
// result := unit ;
68605: LD_ADDR_VAR 0 4
68609: PUSH
68610: LD_VAR 0 5
68614: ST_TO_ADDR
// end ;
68615: LD_VAR 0 4
68619: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
68620: LD_INT 0
68622: PPUSH
68623: PPUSH
// if not side or not nation then
68624: LD_VAR 0 1
68628: NOT
68629: PUSH
68630: LD_VAR 0 2
68634: NOT
68635: OR
68636: IFFALSE 68640
// exit ;
68638: GO 69408
// case nation of nation_american :
68640: LD_VAR 0 2
68644: PUSH
68645: LD_INT 1
68647: DOUBLE
68648: EQUAL
68649: IFTRUE 68653
68651: GO 68867
68653: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
68654: LD_ADDR_VAR 0 4
68658: PUSH
68659: LD_INT 35
68661: PUSH
68662: LD_INT 45
68664: PUSH
68665: LD_INT 46
68667: PUSH
68668: LD_INT 47
68670: PUSH
68671: LD_INT 82
68673: PUSH
68674: LD_INT 83
68676: PUSH
68677: LD_INT 84
68679: PUSH
68680: LD_INT 85
68682: PUSH
68683: LD_INT 86
68685: PUSH
68686: LD_INT 1
68688: PUSH
68689: LD_INT 2
68691: PUSH
68692: LD_INT 6
68694: PUSH
68695: LD_INT 15
68697: PUSH
68698: LD_INT 16
68700: PUSH
68701: LD_INT 7
68703: PUSH
68704: LD_INT 12
68706: PUSH
68707: LD_INT 13
68709: PUSH
68710: LD_INT 10
68712: PUSH
68713: LD_INT 14
68715: PUSH
68716: LD_INT 20
68718: PUSH
68719: LD_INT 21
68721: PUSH
68722: LD_INT 22
68724: PUSH
68725: LD_INT 25
68727: PUSH
68728: LD_INT 32
68730: PUSH
68731: LD_INT 27
68733: PUSH
68734: LD_INT 36
68736: PUSH
68737: LD_INT 69
68739: PUSH
68740: LD_INT 39
68742: PUSH
68743: LD_INT 34
68745: PUSH
68746: LD_INT 40
68748: PUSH
68749: LD_INT 48
68751: PUSH
68752: LD_INT 49
68754: PUSH
68755: LD_INT 50
68757: PUSH
68758: LD_INT 51
68760: PUSH
68761: LD_INT 52
68763: PUSH
68764: LD_INT 53
68766: PUSH
68767: LD_INT 54
68769: PUSH
68770: LD_INT 55
68772: PUSH
68773: LD_INT 56
68775: PUSH
68776: LD_INT 57
68778: PUSH
68779: LD_INT 58
68781: PUSH
68782: LD_INT 59
68784: PUSH
68785: LD_INT 60
68787: PUSH
68788: LD_INT 61
68790: PUSH
68791: LD_INT 62
68793: PUSH
68794: LD_INT 80
68796: PUSH
68797: LD_INT 82
68799: PUSH
68800: LD_INT 83
68802: PUSH
68803: LD_INT 84
68805: PUSH
68806: LD_INT 85
68808: PUSH
68809: LD_INT 86
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: LIST
68818: LIST
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: LIST
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: ST_TO_ADDR
68865: GO 69332
68867: LD_INT 2
68869: DOUBLE
68870: EQUAL
68871: IFTRUE 68875
68873: GO 69101
68875: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
68876: LD_ADDR_VAR 0 4
68880: PUSH
68881: LD_INT 35
68883: PUSH
68884: LD_INT 45
68886: PUSH
68887: LD_INT 46
68889: PUSH
68890: LD_INT 47
68892: PUSH
68893: LD_INT 82
68895: PUSH
68896: LD_INT 83
68898: PUSH
68899: LD_INT 84
68901: PUSH
68902: LD_INT 85
68904: PUSH
68905: LD_INT 87
68907: PUSH
68908: LD_INT 70
68910: PUSH
68911: LD_INT 1
68913: PUSH
68914: LD_INT 11
68916: PUSH
68917: LD_INT 3
68919: PUSH
68920: LD_INT 4
68922: PUSH
68923: LD_INT 5
68925: PUSH
68926: LD_INT 6
68928: PUSH
68929: LD_INT 15
68931: PUSH
68932: LD_INT 18
68934: PUSH
68935: LD_INT 7
68937: PUSH
68938: LD_INT 17
68940: PUSH
68941: LD_INT 8
68943: PUSH
68944: LD_INT 20
68946: PUSH
68947: LD_INT 21
68949: PUSH
68950: LD_INT 22
68952: PUSH
68953: LD_INT 72
68955: PUSH
68956: LD_INT 26
68958: PUSH
68959: LD_INT 69
68961: PUSH
68962: LD_INT 39
68964: PUSH
68965: LD_INT 40
68967: PUSH
68968: LD_INT 41
68970: PUSH
68971: LD_INT 42
68973: PUSH
68974: LD_INT 43
68976: PUSH
68977: LD_INT 48
68979: PUSH
68980: LD_INT 49
68982: PUSH
68983: LD_INT 50
68985: PUSH
68986: LD_INT 51
68988: PUSH
68989: LD_INT 52
68991: PUSH
68992: LD_INT 53
68994: PUSH
68995: LD_INT 54
68997: PUSH
68998: LD_INT 55
69000: PUSH
69001: LD_INT 56
69003: PUSH
69004: LD_INT 60
69006: PUSH
69007: LD_INT 61
69009: PUSH
69010: LD_INT 62
69012: PUSH
69013: LD_INT 66
69015: PUSH
69016: LD_INT 67
69018: PUSH
69019: LD_INT 68
69021: PUSH
69022: LD_INT 81
69024: PUSH
69025: LD_INT 82
69027: PUSH
69028: LD_INT 83
69030: PUSH
69031: LD_INT 84
69033: PUSH
69034: LD_INT 85
69036: PUSH
69037: LD_INT 87
69039: PUSH
69040: LD_INT 88
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: LIST
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: ST_TO_ADDR
69099: GO 69332
69101: LD_INT 3
69103: DOUBLE
69104: EQUAL
69105: IFTRUE 69109
69107: GO 69331
69109: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69110: LD_ADDR_VAR 0 4
69114: PUSH
69115: LD_INT 46
69117: PUSH
69118: LD_INT 47
69120: PUSH
69121: LD_INT 1
69123: PUSH
69124: LD_INT 2
69126: PUSH
69127: LD_INT 82
69129: PUSH
69130: LD_INT 83
69132: PUSH
69133: LD_INT 84
69135: PUSH
69136: LD_INT 85
69138: PUSH
69139: LD_INT 86
69141: PUSH
69142: LD_INT 11
69144: PUSH
69145: LD_INT 9
69147: PUSH
69148: LD_INT 20
69150: PUSH
69151: LD_INT 19
69153: PUSH
69154: LD_INT 21
69156: PUSH
69157: LD_INT 24
69159: PUSH
69160: LD_INT 22
69162: PUSH
69163: LD_INT 25
69165: PUSH
69166: LD_INT 28
69168: PUSH
69169: LD_INT 29
69171: PUSH
69172: LD_INT 30
69174: PUSH
69175: LD_INT 31
69177: PUSH
69178: LD_INT 37
69180: PUSH
69181: LD_INT 38
69183: PUSH
69184: LD_INT 32
69186: PUSH
69187: LD_INT 27
69189: PUSH
69190: LD_INT 33
69192: PUSH
69193: LD_INT 69
69195: PUSH
69196: LD_INT 39
69198: PUSH
69199: LD_INT 34
69201: PUSH
69202: LD_INT 40
69204: PUSH
69205: LD_INT 71
69207: PUSH
69208: LD_INT 23
69210: PUSH
69211: LD_INT 44
69213: PUSH
69214: LD_INT 48
69216: PUSH
69217: LD_INT 49
69219: PUSH
69220: LD_INT 50
69222: PUSH
69223: LD_INT 51
69225: PUSH
69226: LD_INT 52
69228: PUSH
69229: LD_INT 53
69231: PUSH
69232: LD_INT 54
69234: PUSH
69235: LD_INT 55
69237: PUSH
69238: LD_INT 56
69240: PUSH
69241: LD_INT 57
69243: PUSH
69244: LD_INT 58
69246: PUSH
69247: LD_INT 59
69249: PUSH
69250: LD_INT 63
69252: PUSH
69253: LD_INT 64
69255: PUSH
69256: LD_INT 65
69258: PUSH
69259: LD_INT 82
69261: PUSH
69262: LD_INT 83
69264: PUSH
69265: LD_INT 84
69267: PUSH
69268: LD_INT 85
69270: PUSH
69271: LD_INT 86
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: LIST
69302: LIST
69303: LIST
69304: LIST
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: LIST
69310: LIST
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: ST_TO_ADDR
69329: GO 69332
69331: POP
// if state > - 1 and state < 3 then
69332: LD_VAR 0 3
69336: PUSH
69337: LD_INT 1
69339: NEG
69340: GREATER
69341: PUSH
69342: LD_VAR 0 3
69346: PUSH
69347: LD_INT 3
69349: LESS
69350: AND
69351: IFFALSE 69408
// for i in result do
69353: LD_ADDR_VAR 0 5
69357: PUSH
69358: LD_VAR 0 4
69362: PUSH
69363: FOR_IN
69364: IFFALSE 69406
// if GetTech ( i , side ) <> state then
69366: LD_VAR 0 5
69370: PPUSH
69371: LD_VAR 0 1
69375: PPUSH
69376: CALL_OW 321
69380: PUSH
69381: LD_VAR 0 3
69385: NONEQUAL
69386: IFFALSE 69404
// result := result diff i ;
69388: LD_ADDR_VAR 0 4
69392: PUSH
69393: LD_VAR 0 4
69397: PUSH
69398: LD_VAR 0 5
69402: DIFF
69403: ST_TO_ADDR
69404: GO 69363
69406: POP
69407: POP
// end ;
69408: LD_VAR 0 4
69412: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
69413: LD_INT 0
69415: PPUSH
69416: PPUSH
69417: PPUSH
// result := true ;
69418: LD_ADDR_VAR 0 3
69422: PUSH
69423: LD_INT 1
69425: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
69426: LD_ADDR_VAR 0 5
69430: PUSH
69431: LD_VAR 0 2
69435: PPUSH
69436: CALL_OW 480
69440: ST_TO_ADDR
// if not tmp then
69441: LD_VAR 0 5
69445: NOT
69446: IFFALSE 69450
// exit ;
69448: GO 69499
// for i in tmp do
69450: LD_ADDR_VAR 0 4
69454: PUSH
69455: LD_VAR 0 5
69459: PUSH
69460: FOR_IN
69461: IFFALSE 69497
// if GetTech ( i , side ) <> state_researched then
69463: LD_VAR 0 4
69467: PPUSH
69468: LD_VAR 0 1
69472: PPUSH
69473: CALL_OW 321
69477: PUSH
69478: LD_INT 2
69480: NONEQUAL
69481: IFFALSE 69495
// begin result := false ;
69483: LD_ADDR_VAR 0 3
69487: PUSH
69488: LD_INT 0
69490: ST_TO_ADDR
// exit ;
69491: POP
69492: POP
69493: GO 69499
// end ;
69495: GO 69460
69497: POP
69498: POP
// end ;
69499: LD_VAR 0 3
69503: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
69504: LD_INT 0
69506: PPUSH
69507: PPUSH
69508: PPUSH
69509: PPUSH
69510: PPUSH
69511: PPUSH
69512: PPUSH
69513: PPUSH
69514: PPUSH
69515: PPUSH
69516: PPUSH
69517: PPUSH
69518: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
69519: LD_VAR 0 1
69523: NOT
69524: PUSH
69525: LD_VAR 0 1
69529: PPUSH
69530: CALL_OW 257
69534: PUSH
69535: LD_INT 9
69537: NONEQUAL
69538: OR
69539: IFFALSE 69543
// exit ;
69541: GO 70116
// side := GetSide ( unit ) ;
69543: LD_ADDR_VAR 0 9
69547: PUSH
69548: LD_VAR 0 1
69552: PPUSH
69553: CALL_OW 255
69557: ST_TO_ADDR
// tech_space := tech_spacanom ;
69558: LD_ADDR_VAR 0 12
69562: PUSH
69563: LD_INT 29
69565: ST_TO_ADDR
// tech_time := tech_taurad ;
69566: LD_ADDR_VAR 0 13
69570: PUSH
69571: LD_INT 28
69573: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
69574: LD_ADDR_VAR 0 11
69578: PUSH
69579: LD_VAR 0 1
69583: PPUSH
69584: CALL_OW 310
69588: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
69589: LD_VAR 0 11
69593: PPUSH
69594: CALL_OW 247
69598: PUSH
69599: LD_INT 2
69601: EQUAL
69602: IFFALSE 69606
// exit ;
69604: GO 70116
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69606: LD_ADDR_VAR 0 8
69610: PUSH
69611: LD_INT 81
69613: PUSH
69614: LD_VAR 0 9
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: LD_INT 3
69625: PUSH
69626: LD_INT 21
69628: PUSH
69629: LD_INT 3
69631: PUSH
69632: EMPTY
69633: LIST
69634: LIST
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PPUSH
69644: CALL_OW 69
69648: ST_TO_ADDR
// if not tmp then
69649: LD_VAR 0 8
69653: NOT
69654: IFFALSE 69658
// exit ;
69656: GO 70116
// if in_unit then
69658: LD_VAR 0 11
69662: IFFALSE 69686
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
69664: LD_ADDR_VAR 0 10
69668: PUSH
69669: LD_VAR 0 8
69673: PPUSH
69674: LD_VAR 0 11
69678: PPUSH
69679: CALL_OW 74
69683: ST_TO_ADDR
69684: GO 69706
// enemy := NearestUnitToUnit ( tmp , unit ) ;
69686: LD_ADDR_VAR 0 10
69690: PUSH
69691: LD_VAR 0 8
69695: PPUSH
69696: LD_VAR 0 1
69700: PPUSH
69701: CALL_OW 74
69705: ST_TO_ADDR
// if not enemy then
69706: LD_VAR 0 10
69710: NOT
69711: IFFALSE 69715
// exit ;
69713: GO 70116
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
69715: LD_VAR 0 11
69719: PUSH
69720: LD_VAR 0 11
69724: PPUSH
69725: LD_VAR 0 10
69729: PPUSH
69730: CALL_OW 296
69734: PUSH
69735: LD_INT 13
69737: GREATER
69738: AND
69739: PUSH
69740: LD_VAR 0 1
69744: PPUSH
69745: LD_VAR 0 10
69749: PPUSH
69750: CALL_OW 296
69754: PUSH
69755: LD_INT 12
69757: GREATER
69758: OR
69759: IFFALSE 69763
// exit ;
69761: GO 70116
// missile := [ 1 ] ;
69763: LD_ADDR_VAR 0 14
69767: PUSH
69768: LD_INT 1
69770: PUSH
69771: EMPTY
69772: LIST
69773: ST_TO_ADDR
// if Researched ( side , tech_space ) then
69774: LD_VAR 0 9
69778: PPUSH
69779: LD_VAR 0 12
69783: PPUSH
69784: CALL_OW 325
69788: IFFALSE 69817
// missile := Replace ( missile , missile + 1 , 2 ) ;
69790: LD_ADDR_VAR 0 14
69794: PUSH
69795: LD_VAR 0 14
69799: PPUSH
69800: LD_VAR 0 14
69804: PUSH
69805: LD_INT 1
69807: PLUS
69808: PPUSH
69809: LD_INT 2
69811: PPUSH
69812: CALL_OW 1
69816: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
69817: LD_VAR 0 9
69821: PPUSH
69822: LD_VAR 0 13
69826: PPUSH
69827: CALL_OW 325
69831: PUSH
69832: LD_VAR 0 10
69836: PPUSH
69837: CALL_OW 255
69841: PPUSH
69842: LD_VAR 0 13
69846: PPUSH
69847: CALL_OW 325
69851: NOT
69852: AND
69853: IFFALSE 69882
// missile := Replace ( missile , missile + 1 , 3 ) ;
69855: LD_ADDR_VAR 0 14
69859: PUSH
69860: LD_VAR 0 14
69864: PPUSH
69865: LD_VAR 0 14
69869: PUSH
69870: LD_INT 1
69872: PLUS
69873: PPUSH
69874: LD_INT 3
69876: PPUSH
69877: CALL_OW 1
69881: ST_TO_ADDR
// if missile < 2 then
69882: LD_VAR 0 14
69886: PUSH
69887: LD_INT 2
69889: LESS
69890: IFFALSE 69894
// exit ;
69892: GO 70116
// x := GetX ( enemy ) ;
69894: LD_ADDR_VAR 0 4
69898: PUSH
69899: LD_VAR 0 10
69903: PPUSH
69904: CALL_OW 250
69908: ST_TO_ADDR
// y := GetY ( enemy ) ;
69909: LD_ADDR_VAR 0 5
69913: PUSH
69914: LD_VAR 0 10
69918: PPUSH
69919: CALL_OW 251
69923: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
69924: LD_ADDR_VAR 0 6
69928: PUSH
69929: LD_VAR 0 4
69933: PUSH
69934: LD_INT 1
69936: NEG
69937: PPUSH
69938: LD_INT 1
69940: PPUSH
69941: CALL_OW 12
69945: PLUS
69946: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
69947: LD_ADDR_VAR 0 7
69951: PUSH
69952: LD_VAR 0 5
69956: PUSH
69957: LD_INT 1
69959: NEG
69960: PPUSH
69961: LD_INT 1
69963: PPUSH
69964: CALL_OW 12
69968: PLUS
69969: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
69970: LD_VAR 0 6
69974: PPUSH
69975: LD_VAR 0 7
69979: PPUSH
69980: CALL_OW 488
69984: NOT
69985: IFFALSE 70007
// begin _x := x ;
69987: LD_ADDR_VAR 0 6
69991: PUSH
69992: LD_VAR 0 4
69996: ST_TO_ADDR
// _y := y ;
69997: LD_ADDR_VAR 0 7
70001: PUSH
70002: LD_VAR 0 5
70006: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70007: LD_ADDR_VAR 0 3
70011: PUSH
70012: LD_INT 1
70014: PPUSH
70015: LD_VAR 0 14
70019: PPUSH
70020: CALL_OW 12
70024: ST_TO_ADDR
// case i of 1 :
70025: LD_VAR 0 3
70029: PUSH
70030: LD_INT 1
70032: DOUBLE
70033: EQUAL
70034: IFTRUE 70038
70036: GO 70055
70038: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70039: LD_VAR 0 1
70043: PPUSH
70044: LD_VAR 0 10
70048: PPUSH
70049: CALL_OW 115
70053: GO 70116
70055: LD_INT 2
70057: DOUBLE
70058: EQUAL
70059: IFTRUE 70063
70061: GO 70085
70063: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70064: LD_VAR 0 1
70068: PPUSH
70069: LD_VAR 0 6
70073: PPUSH
70074: LD_VAR 0 7
70078: PPUSH
70079: CALL_OW 153
70083: GO 70116
70085: LD_INT 3
70087: DOUBLE
70088: EQUAL
70089: IFTRUE 70093
70091: GO 70115
70093: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70094: LD_VAR 0 1
70098: PPUSH
70099: LD_VAR 0 6
70103: PPUSH
70104: LD_VAR 0 7
70108: PPUSH
70109: CALL_OW 154
70113: GO 70116
70115: POP
// end ;
70116: LD_VAR 0 2
70120: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
70121: LD_INT 0
70123: PPUSH
70124: PPUSH
70125: PPUSH
70126: PPUSH
70127: PPUSH
70128: PPUSH
// if not unit or not building then
70129: LD_VAR 0 1
70133: NOT
70134: PUSH
70135: LD_VAR 0 2
70139: NOT
70140: OR
70141: IFFALSE 70145
// exit ;
70143: GO 70303
// x := GetX ( building ) ;
70145: LD_ADDR_VAR 0 5
70149: PUSH
70150: LD_VAR 0 2
70154: PPUSH
70155: CALL_OW 250
70159: ST_TO_ADDR
// y := GetY ( building ) ;
70160: LD_ADDR_VAR 0 6
70164: PUSH
70165: LD_VAR 0 2
70169: PPUSH
70170: CALL_OW 251
70174: ST_TO_ADDR
// for i = 0 to 5 do
70175: LD_ADDR_VAR 0 4
70179: PUSH
70180: DOUBLE
70181: LD_INT 0
70183: DEC
70184: ST_TO_ADDR
70185: LD_INT 5
70187: PUSH
70188: FOR_TO
70189: IFFALSE 70301
// begin _x := ShiftX ( x , i , 3 ) ;
70191: LD_ADDR_VAR 0 7
70195: PUSH
70196: LD_VAR 0 5
70200: PPUSH
70201: LD_VAR 0 4
70205: PPUSH
70206: LD_INT 3
70208: PPUSH
70209: CALL_OW 272
70213: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
70214: LD_ADDR_VAR 0 8
70218: PUSH
70219: LD_VAR 0 6
70223: PPUSH
70224: LD_VAR 0 4
70228: PPUSH
70229: LD_INT 3
70231: PPUSH
70232: CALL_OW 273
70236: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70237: LD_VAR 0 7
70241: PPUSH
70242: LD_VAR 0 8
70246: PPUSH
70247: CALL_OW 488
70251: NOT
70252: IFFALSE 70256
// continue ;
70254: GO 70188
// if HexInfo ( _x , _y ) = 0 then
70256: LD_VAR 0 7
70260: PPUSH
70261: LD_VAR 0 8
70265: PPUSH
70266: CALL_OW 428
70270: PUSH
70271: LD_INT 0
70273: EQUAL
70274: IFFALSE 70299
// begin ComMoveXY ( unit , _x , _y ) ;
70276: LD_VAR 0 1
70280: PPUSH
70281: LD_VAR 0 7
70285: PPUSH
70286: LD_VAR 0 8
70290: PPUSH
70291: CALL_OW 111
// exit ;
70295: POP
70296: POP
70297: GO 70303
// end ; end ;
70299: GO 70188
70301: POP
70302: POP
// end ;
70303: LD_VAR 0 3
70307: RET
// export function ScanBase ( side , base_area ) ; begin
70308: LD_INT 0
70310: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
70311: LD_ADDR_VAR 0 3
70315: PUSH
70316: LD_VAR 0 2
70320: PPUSH
70321: LD_INT 81
70323: PUSH
70324: LD_VAR 0 1
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PPUSH
70333: CALL_OW 70
70337: ST_TO_ADDR
// end ;
70338: LD_VAR 0 3
70342: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
70343: LD_INT 0
70345: PPUSH
70346: PPUSH
70347: PPUSH
70348: PPUSH
// result := false ;
70349: LD_ADDR_VAR 0 2
70353: PUSH
70354: LD_INT 0
70356: ST_TO_ADDR
// side := GetSide ( unit ) ;
70357: LD_ADDR_VAR 0 3
70361: PUSH
70362: LD_VAR 0 1
70366: PPUSH
70367: CALL_OW 255
70371: ST_TO_ADDR
// nat := GetNation ( unit ) ;
70372: LD_ADDR_VAR 0 4
70376: PUSH
70377: LD_VAR 0 1
70381: PPUSH
70382: CALL_OW 248
70386: ST_TO_ADDR
// case nat of 1 :
70387: LD_VAR 0 4
70391: PUSH
70392: LD_INT 1
70394: DOUBLE
70395: EQUAL
70396: IFTRUE 70400
70398: GO 70411
70400: POP
// tech := tech_lassight ; 2 :
70401: LD_ADDR_VAR 0 5
70405: PUSH
70406: LD_INT 12
70408: ST_TO_ADDR
70409: GO 70450
70411: LD_INT 2
70413: DOUBLE
70414: EQUAL
70415: IFTRUE 70419
70417: GO 70430
70419: POP
// tech := tech_mortar ; 3 :
70420: LD_ADDR_VAR 0 5
70424: PUSH
70425: LD_INT 41
70427: ST_TO_ADDR
70428: GO 70450
70430: LD_INT 3
70432: DOUBLE
70433: EQUAL
70434: IFTRUE 70438
70436: GO 70449
70438: POP
// tech := tech_bazooka ; end ;
70439: LD_ADDR_VAR 0 5
70443: PUSH
70444: LD_INT 44
70446: ST_TO_ADDR
70447: GO 70450
70449: POP
// if Researched ( side , tech ) then
70450: LD_VAR 0 3
70454: PPUSH
70455: LD_VAR 0 5
70459: PPUSH
70460: CALL_OW 325
70464: IFFALSE 70491
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
70466: LD_ADDR_VAR 0 2
70470: PUSH
70471: LD_INT 5
70473: PUSH
70474: LD_INT 8
70476: PUSH
70477: LD_INT 9
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: LIST
70484: PUSH
70485: LD_VAR 0 4
70489: ARRAY
70490: ST_TO_ADDR
// end ;
70491: LD_VAR 0 2
70495: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
70496: LD_INT 0
70498: PPUSH
70499: PPUSH
70500: PPUSH
// if not mines then
70501: LD_VAR 0 2
70505: NOT
70506: IFFALSE 70510
// exit ;
70508: GO 70654
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70510: LD_ADDR_VAR 0 5
70514: PUSH
70515: LD_INT 81
70517: PUSH
70518: LD_VAR 0 1
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: PUSH
70527: LD_INT 3
70529: PUSH
70530: LD_INT 21
70532: PUSH
70533: LD_INT 3
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PPUSH
70548: CALL_OW 69
70552: ST_TO_ADDR
// for i in mines do
70553: LD_ADDR_VAR 0 4
70557: PUSH
70558: LD_VAR 0 2
70562: PUSH
70563: FOR_IN
70564: IFFALSE 70652
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
70566: LD_VAR 0 4
70570: PUSH
70571: LD_INT 1
70573: ARRAY
70574: PPUSH
70575: LD_VAR 0 4
70579: PUSH
70580: LD_INT 2
70582: ARRAY
70583: PPUSH
70584: CALL_OW 458
70588: NOT
70589: IFFALSE 70593
// continue ;
70591: GO 70563
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
70593: LD_VAR 0 4
70597: PUSH
70598: LD_INT 1
70600: ARRAY
70601: PPUSH
70602: LD_VAR 0 4
70606: PUSH
70607: LD_INT 2
70609: ARRAY
70610: PPUSH
70611: CALL_OW 428
70615: PUSH
70616: LD_VAR 0 5
70620: IN
70621: IFFALSE 70650
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
70623: LD_VAR 0 4
70627: PUSH
70628: LD_INT 1
70630: ARRAY
70631: PPUSH
70632: LD_VAR 0 4
70636: PUSH
70637: LD_INT 2
70639: ARRAY
70640: PPUSH
70641: LD_VAR 0 1
70645: PPUSH
70646: CALL_OW 456
// end ;
70650: GO 70563
70652: POP
70653: POP
// end ;
70654: LD_VAR 0 3
70658: RET
// export function Count ( array ) ; begin
70659: LD_INT 0
70661: PPUSH
// result := array + 0 ;
70662: LD_ADDR_VAR 0 2
70666: PUSH
70667: LD_VAR 0 1
70671: PUSH
70672: LD_INT 0
70674: PLUS
70675: ST_TO_ADDR
// end ;
70676: LD_VAR 0 2
70680: RET
// export function IsEmpty ( building ) ; begin
70681: LD_INT 0
70683: PPUSH
// if not building then
70684: LD_VAR 0 1
70688: NOT
70689: IFFALSE 70693
// exit ;
70691: GO 70736
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
70693: LD_ADDR_VAR 0 2
70697: PUSH
70698: LD_VAR 0 1
70702: PUSH
70703: LD_INT 22
70705: PUSH
70706: LD_VAR 0 1
70710: PPUSH
70711: CALL_OW 255
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 58
70722: PUSH
70723: EMPTY
70724: LIST
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PPUSH
70730: CALL_OW 69
70734: IN
70735: ST_TO_ADDR
// end ;
70736: LD_VAR 0 2
70740: RET
// export function IsNotFull ( building ) ; var places ; begin
70741: LD_INT 0
70743: PPUSH
70744: PPUSH
// if not building then
70745: LD_VAR 0 1
70749: NOT
70750: IFFALSE 70754
// exit ;
70752: GO 70782
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
70754: LD_ADDR_VAR 0 2
70758: PUSH
70759: LD_VAR 0 1
70763: PPUSH
70764: LD_INT 3
70766: PUSH
70767: LD_INT 62
70769: PUSH
70770: EMPTY
70771: LIST
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PPUSH
70777: CALL_OW 72
70781: ST_TO_ADDR
// end ;
70782: LD_VAR 0 2
70786: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
70787: LD_INT 0
70789: PPUSH
70790: PPUSH
70791: PPUSH
70792: PPUSH
// tmp := [ ] ;
70793: LD_ADDR_VAR 0 3
70797: PUSH
70798: EMPTY
70799: ST_TO_ADDR
// list := [ ] ;
70800: LD_ADDR_VAR 0 5
70804: PUSH
70805: EMPTY
70806: ST_TO_ADDR
// for i = 16 to 25 do
70807: LD_ADDR_VAR 0 4
70811: PUSH
70812: DOUBLE
70813: LD_INT 16
70815: DEC
70816: ST_TO_ADDR
70817: LD_INT 25
70819: PUSH
70820: FOR_TO
70821: IFFALSE 70894
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
70823: LD_ADDR_VAR 0 3
70827: PUSH
70828: LD_VAR 0 3
70832: PUSH
70833: LD_INT 22
70835: PUSH
70836: LD_VAR 0 1
70840: PPUSH
70841: CALL_OW 255
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 91
70852: PUSH
70853: LD_VAR 0 1
70857: PUSH
70858: LD_INT 6
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 30
70868: PUSH
70869: LD_VAR 0 4
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: LIST
70882: PUSH
70883: EMPTY
70884: LIST
70885: PPUSH
70886: CALL_OW 69
70890: ADD
70891: ST_TO_ADDR
70892: GO 70820
70894: POP
70895: POP
// for i = 1 to tmp do
70896: LD_ADDR_VAR 0 4
70900: PUSH
70901: DOUBLE
70902: LD_INT 1
70904: DEC
70905: ST_TO_ADDR
70906: LD_VAR 0 3
70910: PUSH
70911: FOR_TO
70912: IFFALSE 71000
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
70914: LD_ADDR_VAR 0 5
70918: PUSH
70919: LD_VAR 0 5
70923: PUSH
70924: LD_VAR 0 3
70928: PUSH
70929: LD_VAR 0 4
70933: ARRAY
70934: PPUSH
70935: CALL_OW 266
70939: PUSH
70940: LD_VAR 0 3
70944: PUSH
70945: LD_VAR 0 4
70949: ARRAY
70950: PPUSH
70951: CALL_OW 250
70955: PUSH
70956: LD_VAR 0 3
70960: PUSH
70961: LD_VAR 0 4
70965: ARRAY
70966: PPUSH
70967: CALL_OW 251
70971: PUSH
70972: LD_VAR 0 3
70976: PUSH
70977: LD_VAR 0 4
70981: ARRAY
70982: PPUSH
70983: CALL_OW 254
70987: PUSH
70988: EMPTY
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: PUSH
70994: EMPTY
70995: LIST
70996: ADD
70997: ST_TO_ADDR
70998: GO 70911
71000: POP
71001: POP
// result := list ;
71002: LD_ADDR_VAR 0 2
71006: PUSH
71007: LD_VAR 0 5
71011: ST_TO_ADDR
// end ;
71012: LD_VAR 0 2
71016: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71017: LD_INT 0
71019: PPUSH
71020: PPUSH
71021: PPUSH
71022: PPUSH
71023: PPUSH
71024: PPUSH
71025: PPUSH
// if not factory then
71026: LD_VAR 0 1
71030: NOT
71031: IFFALSE 71035
// exit ;
71033: GO 71628
// if control = control_apeman then
71035: LD_VAR 0 4
71039: PUSH
71040: LD_INT 5
71042: EQUAL
71043: IFFALSE 71152
// begin tmp := UnitsInside ( factory ) ;
71045: LD_ADDR_VAR 0 8
71049: PUSH
71050: LD_VAR 0 1
71054: PPUSH
71055: CALL_OW 313
71059: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71060: LD_VAR 0 8
71064: PPUSH
71065: LD_INT 25
71067: PUSH
71068: LD_INT 12
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PPUSH
71075: CALL_OW 72
71079: NOT
71080: IFFALSE 71090
// control := control_manual ;
71082: LD_ADDR_VAR 0 4
71086: PUSH
71087: LD_INT 1
71089: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71090: LD_ADDR_VAR 0 8
71094: PUSH
71095: LD_VAR 0 1
71099: PPUSH
71100: CALL 70787 0 1
71104: ST_TO_ADDR
// if tmp then
71105: LD_VAR 0 8
71109: IFFALSE 71152
// begin for i in tmp do
71111: LD_ADDR_VAR 0 7
71115: PUSH
71116: LD_VAR 0 8
71120: PUSH
71121: FOR_IN
71122: IFFALSE 71150
// if i [ 1 ] = b_ext_radio then
71124: LD_VAR 0 7
71128: PUSH
71129: LD_INT 1
71131: ARRAY
71132: PUSH
71133: LD_INT 22
71135: EQUAL
71136: IFFALSE 71148
// begin control := control_remote ;
71138: LD_ADDR_VAR 0 4
71142: PUSH
71143: LD_INT 2
71145: ST_TO_ADDR
// break ;
71146: GO 71150
// end ;
71148: GO 71121
71150: POP
71151: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71152: LD_VAR 0 1
71156: PPUSH
71157: LD_VAR 0 2
71161: PPUSH
71162: LD_VAR 0 3
71166: PPUSH
71167: LD_VAR 0 4
71171: PPUSH
71172: LD_VAR 0 5
71176: PPUSH
71177: CALL_OW 448
71181: IFFALSE 71216
// begin result := [ chassis , engine , control , weapon ] ;
71183: LD_ADDR_VAR 0 6
71187: PUSH
71188: LD_VAR 0 2
71192: PUSH
71193: LD_VAR 0 3
71197: PUSH
71198: LD_VAR 0 4
71202: PUSH
71203: LD_VAR 0 5
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: ST_TO_ADDR
// exit ;
71214: GO 71628
// end ; _chassis := AvailableChassisList ( factory ) ;
71216: LD_ADDR_VAR 0 9
71220: PUSH
71221: LD_VAR 0 1
71225: PPUSH
71226: CALL_OW 475
71230: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
71231: LD_ADDR_VAR 0 11
71235: PUSH
71236: LD_VAR 0 1
71240: PPUSH
71241: CALL_OW 476
71245: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
71246: LD_ADDR_VAR 0 12
71250: PUSH
71251: LD_VAR 0 1
71255: PPUSH
71256: CALL_OW 477
71260: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
71261: LD_ADDR_VAR 0 10
71265: PUSH
71266: LD_VAR 0 1
71270: PPUSH
71271: CALL_OW 478
71275: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
71276: LD_VAR 0 9
71280: NOT
71281: PUSH
71282: LD_VAR 0 11
71286: NOT
71287: OR
71288: PUSH
71289: LD_VAR 0 12
71293: NOT
71294: OR
71295: PUSH
71296: LD_VAR 0 10
71300: NOT
71301: OR
71302: IFFALSE 71337
// begin result := [ chassis , engine , control , weapon ] ;
71304: LD_ADDR_VAR 0 6
71308: PUSH
71309: LD_VAR 0 2
71313: PUSH
71314: LD_VAR 0 3
71318: PUSH
71319: LD_VAR 0 4
71323: PUSH
71324: LD_VAR 0 5
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: ST_TO_ADDR
// exit ;
71335: GO 71628
// end ; if not chassis in _chassis then
71337: LD_VAR 0 2
71341: PUSH
71342: LD_VAR 0 9
71346: IN
71347: NOT
71348: IFFALSE 71374
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
71350: LD_ADDR_VAR 0 2
71354: PUSH
71355: LD_VAR 0 9
71359: PUSH
71360: LD_INT 1
71362: PPUSH
71363: LD_VAR 0 9
71367: PPUSH
71368: CALL_OW 12
71372: ARRAY
71373: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
71374: LD_VAR 0 2
71378: PPUSH
71379: LD_VAR 0 3
71383: PPUSH
71384: CALL 71633 0 2
71388: NOT
71389: IFFALSE 71448
// repeat engine := _engine [ 1 ] ;
71391: LD_ADDR_VAR 0 3
71395: PUSH
71396: LD_VAR 0 11
71400: PUSH
71401: LD_INT 1
71403: ARRAY
71404: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
71405: LD_ADDR_VAR 0 11
71409: PUSH
71410: LD_VAR 0 11
71414: PPUSH
71415: LD_INT 1
71417: PPUSH
71418: CALL_OW 3
71422: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
71423: LD_VAR 0 2
71427: PPUSH
71428: LD_VAR 0 3
71432: PPUSH
71433: CALL 71633 0 2
71437: PUSH
71438: LD_VAR 0 11
71442: PUSH
71443: EMPTY
71444: EQUAL
71445: OR
71446: IFFALSE 71391
// if not control in _control then
71448: LD_VAR 0 4
71452: PUSH
71453: LD_VAR 0 12
71457: IN
71458: NOT
71459: IFFALSE 71485
// control := _control [ rand ( 1 , _control ) ] ;
71461: LD_ADDR_VAR 0 4
71465: PUSH
71466: LD_VAR 0 12
71470: PUSH
71471: LD_INT 1
71473: PPUSH
71474: LD_VAR 0 12
71478: PPUSH
71479: CALL_OW 12
71483: ARRAY
71484: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
71485: LD_VAR 0 2
71489: PPUSH
71490: LD_VAR 0 5
71494: PPUSH
71495: CALL 71853 0 2
71499: NOT
71500: IFFALSE 71559
// repeat weapon := _weapon [ 1 ] ;
71502: LD_ADDR_VAR 0 5
71506: PUSH
71507: LD_VAR 0 10
71511: PUSH
71512: LD_INT 1
71514: ARRAY
71515: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
71516: LD_ADDR_VAR 0 10
71520: PUSH
71521: LD_VAR 0 10
71525: PPUSH
71526: LD_INT 1
71528: PPUSH
71529: CALL_OW 3
71533: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
71534: LD_VAR 0 2
71538: PPUSH
71539: LD_VAR 0 5
71543: PPUSH
71544: CALL 71853 0 2
71548: PUSH
71549: LD_VAR 0 10
71553: PUSH
71554: EMPTY
71555: EQUAL
71556: OR
71557: IFFALSE 71502
// result := [ ] ;
71559: LD_ADDR_VAR 0 6
71563: PUSH
71564: EMPTY
71565: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71566: LD_VAR 0 1
71570: PPUSH
71571: LD_VAR 0 2
71575: PPUSH
71576: LD_VAR 0 3
71580: PPUSH
71581: LD_VAR 0 4
71585: PPUSH
71586: LD_VAR 0 5
71590: PPUSH
71591: CALL_OW 448
71595: IFFALSE 71628
// result := [ chassis , engine , control , weapon ] ;
71597: LD_ADDR_VAR 0 6
71601: PUSH
71602: LD_VAR 0 2
71606: PUSH
71607: LD_VAR 0 3
71611: PUSH
71612: LD_VAR 0 4
71616: PUSH
71617: LD_VAR 0 5
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: ST_TO_ADDR
// end ;
71628: LD_VAR 0 6
71632: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
71633: LD_INT 0
71635: PPUSH
// if not chassis or not engine then
71636: LD_VAR 0 1
71640: NOT
71641: PUSH
71642: LD_VAR 0 2
71646: NOT
71647: OR
71648: IFFALSE 71652
// exit ;
71650: GO 71848
// case engine of engine_solar :
71652: LD_VAR 0 2
71656: PUSH
71657: LD_INT 2
71659: DOUBLE
71660: EQUAL
71661: IFTRUE 71665
71663: GO 71703
71665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
71666: LD_ADDR_VAR 0 3
71670: PUSH
71671: LD_INT 11
71673: PUSH
71674: LD_INT 12
71676: PUSH
71677: LD_INT 13
71679: PUSH
71680: LD_INT 14
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: LD_INT 2
71688: PUSH
71689: LD_INT 3
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: ST_TO_ADDR
71701: GO 71832
71703: LD_INT 1
71705: DOUBLE
71706: EQUAL
71707: IFTRUE 71711
71709: GO 71773
71711: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
71712: LD_ADDR_VAR 0 3
71716: PUSH
71717: LD_INT 11
71719: PUSH
71720: LD_INT 12
71722: PUSH
71723: LD_INT 13
71725: PUSH
71726: LD_INT 14
71728: PUSH
71729: LD_INT 1
71731: PUSH
71732: LD_INT 2
71734: PUSH
71735: LD_INT 3
71737: PUSH
71738: LD_INT 4
71740: PUSH
71741: LD_INT 5
71743: PUSH
71744: LD_INT 21
71746: PUSH
71747: LD_INT 23
71749: PUSH
71750: LD_INT 22
71752: PUSH
71753: LD_INT 24
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: ST_TO_ADDR
71771: GO 71832
71773: LD_INT 3
71775: DOUBLE
71776: EQUAL
71777: IFTRUE 71781
71779: GO 71831
71781: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71782: LD_ADDR_VAR 0 3
71786: PUSH
71787: LD_INT 13
71789: PUSH
71790: LD_INT 14
71792: PUSH
71793: LD_INT 2
71795: PUSH
71796: LD_INT 3
71798: PUSH
71799: LD_INT 4
71801: PUSH
71802: LD_INT 5
71804: PUSH
71805: LD_INT 21
71807: PUSH
71808: LD_INT 22
71810: PUSH
71811: LD_INT 23
71813: PUSH
71814: LD_INT 24
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: ST_TO_ADDR
71829: GO 71832
71831: POP
// result := ( chassis in result ) ;
71832: LD_ADDR_VAR 0 3
71836: PUSH
71837: LD_VAR 0 1
71841: PUSH
71842: LD_VAR 0 3
71846: IN
71847: ST_TO_ADDR
// end ;
71848: LD_VAR 0 3
71852: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
71853: LD_INT 0
71855: PPUSH
// if not chassis or not weapon then
71856: LD_VAR 0 1
71860: NOT
71861: PUSH
71862: LD_VAR 0 2
71866: NOT
71867: OR
71868: IFFALSE 71872
// exit ;
71870: GO 72932
// case weapon of us_machine_gun :
71872: LD_VAR 0 2
71876: PUSH
71877: LD_INT 2
71879: DOUBLE
71880: EQUAL
71881: IFTRUE 71885
71883: GO 71915
71885: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
71886: LD_ADDR_VAR 0 3
71890: PUSH
71891: LD_INT 1
71893: PUSH
71894: LD_INT 2
71896: PUSH
71897: LD_INT 3
71899: PUSH
71900: LD_INT 4
71902: PUSH
71903: LD_INT 5
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: ST_TO_ADDR
71913: GO 72916
71915: LD_INT 3
71917: DOUBLE
71918: EQUAL
71919: IFTRUE 71923
71921: GO 71953
71923: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
71924: LD_ADDR_VAR 0 3
71928: PUSH
71929: LD_INT 1
71931: PUSH
71932: LD_INT 2
71934: PUSH
71935: LD_INT 3
71937: PUSH
71938: LD_INT 4
71940: PUSH
71941: LD_INT 5
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: ST_TO_ADDR
71951: GO 72916
71953: LD_INT 11
71955: DOUBLE
71956: EQUAL
71957: IFTRUE 71961
71959: GO 71991
71961: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
71962: LD_ADDR_VAR 0 3
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: LD_INT 2
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: LD_INT 4
71978: PUSH
71979: LD_INT 5
71981: PUSH
71982: EMPTY
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: ST_TO_ADDR
71989: GO 72916
71991: LD_INT 4
71993: DOUBLE
71994: EQUAL
71995: IFTRUE 71999
71997: GO 72025
71999: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72000: LD_ADDR_VAR 0 3
72004: PUSH
72005: LD_INT 2
72007: PUSH
72008: LD_INT 3
72010: PUSH
72011: LD_INT 4
72013: PUSH
72014: LD_INT 5
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: ST_TO_ADDR
72023: GO 72916
72025: LD_INT 5
72027: DOUBLE
72028: EQUAL
72029: IFTRUE 72033
72031: GO 72059
72033: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72034: LD_ADDR_VAR 0 3
72038: PUSH
72039: LD_INT 2
72041: PUSH
72042: LD_INT 3
72044: PUSH
72045: LD_INT 4
72047: PUSH
72048: LD_INT 5
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: ST_TO_ADDR
72057: GO 72916
72059: LD_INT 9
72061: DOUBLE
72062: EQUAL
72063: IFTRUE 72067
72065: GO 72093
72067: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72068: LD_ADDR_VAR 0 3
72072: PUSH
72073: LD_INT 2
72075: PUSH
72076: LD_INT 3
72078: PUSH
72079: LD_INT 4
72081: PUSH
72082: LD_INT 5
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: LIST
72089: LIST
72090: ST_TO_ADDR
72091: GO 72916
72093: LD_INT 7
72095: DOUBLE
72096: EQUAL
72097: IFTRUE 72101
72099: GO 72127
72101: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72102: LD_ADDR_VAR 0 3
72106: PUSH
72107: LD_INT 2
72109: PUSH
72110: LD_INT 3
72112: PUSH
72113: LD_INT 4
72115: PUSH
72116: LD_INT 5
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: ST_TO_ADDR
72125: GO 72916
72127: LD_INT 12
72129: DOUBLE
72130: EQUAL
72131: IFTRUE 72135
72133: GO 72161
72135: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
72136: LD_ADDR_VAR 0 3
72140: PUSH
72141: LD_INT 2
72143: PUSH
72144: LD_INT 3
72146: PUSH
72147: LD_INT 4
72149: PUSH
72150: LD_INT 5
72152: PUSH
72153: EMPTY
72154: LIST
72155: LIST
72156: LIST
72157: LIST
72158: ST_TO_ADDR
72159: GO 72916
72161: LD_INT 13
72163: DOUBLE
72164: EQUAL
72165: IFTRUE 72169
72167: GO 72195
72169: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
72170: LD_ADDR_VAR 0 3
72174: PUSH
72175: LD_INT 2
72177: PUSH
72178: LD_INT 3
72180: PUSH
72181: LD_INT 4
72183: PUSH
72184: LD_INT 5
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: ST_TO_ADDR
72193: GO 72916
72195: LD_INT 14
72197: DOUBLE
72198: EQUAL
72199: IFTRUE 72203
72201: GO 72221
72203: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
72204: LD_ADDR_VAR 0 3
72208: PUSH
72209: LD_INT 4
72211: PUSH
72212: LD_INT 5
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: ST_TO_ADDR
72219: GO 72916
72221: LD_INT 6
72223: DOUBLE
72224: EQUAL
72225: IFTRUE 72229
72227: GO 72247
72229: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
72230: LD_ADDR_VAR 0 3
72234: PUSH
72235: LD_INT 4
72237: PUSH
72238: LD_INT 5
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: ST_TO_ADDR
72245: GO 72916
72247: LD_INT 10
72249: DOUBLE
72250: EQUAL
72251: IFTRUE 72255
72253: GO 72273
72255: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
72256: LD_ADDR_VAR 0 3
72260: PUSH
72261: LD_INT 4
72263: PUSH
72264: LD_INT 5
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: ST_TO_ADDR
72271: GO 72916
72273: LD_INT 22
72275: DOUBLE
72276: EQUAL
72277: IFTRUE 72281
72279: GO 72307
72281: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
72282: LD_ADDR_VAR 0 3
72286: PUSH
72287: LD_INT 11
72289: PUSH
72290: LD_INT 12
72292: PUSH
72293: LD_INT 13
72295: PUSH
72296: LD_INT 14
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: ST_TO_ADDR
72305: GO 72916
72307: LD_INT 23
72309: DOUBLE
72310: EQUAL
72311: IFTRUE 72315
72313: GO 72341
72315: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
72316: LD_ADDR_VAR 0 3
72320: PUSH
72321: LD_INT 11
72323: PUSH
72324: LD_INT 12
72326: PUSH
72327: LD_INT 13
72329: PUSH
72330: LD_INT 14
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: ST_TO_ADDR
72339: GO 72916
72341: LD_INT 24
72343: DOUBLE
72344: EQUAL
72345: IFTRUE 72349
72347: GO 72375
72349: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
72350: LD_ADDR_VAR 0 3
72354: PUSH
72355: LD_INT 11
72357: PUSH
72358: LD_INT 12
72360: PUSH
72361: LD_INT 13
72363: PUSH
72364: LD_INT 14
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: ST_TO_ADDR
72373: GO 72916
72375: LD_INT 30
72377: DOUBLE
72378: EQUAL
72379: IFTRUE 72383
72381: GO 72409
72383: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
72384: LD_ADDR_VAR 0 3
72388: PUSH
72389: LD_INT 11
72391: PUSH
72392: LD_INT 12
72394: PUSH
72395: LD_INT 13
72397: PUSH
72398: LD_INT 14
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: LIST
72405: LIST
72406: ST_TO_ADDR
72407: GO 72916
72409: LD_INT 25
72411: DOUBLE
72412: EQUAL
72413: IFTRUE 72417
72415: GO 72435
72417: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
72418: LD_ADDR_VAR 0 3
72422: PUSH
72423: LD_INT 13
72425: PUSH
72426: LD_INT 14
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: ST_TO_ADDR
72433: GO 72916
72435: LD_INT 27
72437: DOUBLE
72438: EQUAL
72439: IFTRUE 72443
72441: GO 72461
72443: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
72444: LD_ADDR_VAR 0 3
72448: PUSH
72449: LD_INT 13
72451: PUSH
72452: LD_INT 14
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: ST_TO_ADDR
72459: GO 72916
72461: LD_INT 92
72463: DOUBLE
72464: EQUAL
72465: IFTRUE 72469
72467: GO 72495
72469: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
72470: LD_ADDR_VAR 0 3
72474: PUSH
72475: LD_INT 11
72477: PUSH
72478: LD_INT 12
72480: PUSH
72481: LD_INT 13
72483: PUSH
72484: LD_INT 14
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: ST_TO_ADDR
72493: GO 72916
72495: LD_INT 28
72497: DOUBLE
72498: EQUAL
72499: IFTRUE 72503
72501: GO 72521
72503: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
72504: LD_ADDR_VAR 0 3
72508: PUSH
72509: LD_INT 13
72511: PUSH
72512: LD_INT 14
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: ST_TO_ADDR
72519: GO 72916
72521: LD_INT 29
72523: DOUBLE
72524: EQUAL
72525: IFTRUE 72529
72527: GO 72547
72529: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
72530: LD_ADDR_VAR 0 3
72534: PUSH
72535: LD_INT 13
72537: PUSH
72538: LD_INT 14
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: ST_TO_ADDR
72545: GO 72916
72547: LD_INT 31
72549: DOUBLE
72550: EQUAL
72551: IFTRUE 72555
72553: GO 72573
72555: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
72556: LD_ADDR_VAR 0 3
72560: PUSH
72561: LD_INT 13
72563: PUSH
72564: LD_INT 14
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: ST_TO_ADDR
72571: GO 72916
72573: LD_INT 26
72575: DOUBLE
72576: EQUAL
72577: IFTRUE 72581
72579: GO 72599
72581: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
72582: LD_ADDR_VAR 0 3
72586: PUSH
72587: LD_INT 13
72589: PUSH
72590: LD_INT 14
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: ST_TO_ADDR
72597: GO 72916
72599: LD_INT 42
72601: DOUBLE
72602: EQUAL
72603: IFTRUE 72607
72605: GO 72633
72607: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
72608: LD_ADDR_VAR 0 3
72612: PUSH
72613: LD_INT 21
72615: PUSH
72616: LD_INT 22
72618: PUSH
72619: LD_INT 23
72621: PUSH
72622: LD_INT 24
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: ST_TO_ADDR
72631: GO 72916
72633: LD_INT 43
72635: DOUBLE
72636: EQUAL
72637: IFTRUE 72641
72639: GO 72667
72641: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
72642: LD_ADDR_VAR 0 3
72646: PUSH
72647: LD_INT 21
72649: PUSH
72650: LD_INT 22
72652: PUSH
72653: LD_INT 23
72655: PUSH
72656: LD_INT 24
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: ST_TO_ADDR
72665: GO 72916
72667: LD_INT 44
72669: DOUBLE
72670: EQUAL
72671: IFTRUE 72675
72673: GO 72701
72675: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
72676: LD_ADDR_VAR 0 3
72680: PUSH
72681: LD_INT 21
72683: PUSH
72684: LD_INT 22
72686: PUSH
72687: LD_INT 23
72689: PUSH
72690: LD_INT 24
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: LIST
72697: LIST
72698: ST_TO_ADDR
72699: GO 72916
72701: LD_INT 45
72703: DOUBLE
72704: EQUAL
72705: IFTRUE 72709
72707: GO 72735
72709: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
72710: LD_ADDR_VAR 0 3
72714: PUSH
72715: LD_INT 21
72717: PUSH
72718: LD_INT 22
72720: PUSH
72721: LD_INT 23
72723: PUSH
72724: LD_INT 24
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: LIST
72731: LIST
72732: ST_TO_ADDR
72733: GO 72916
72735: LD_INT 49
72737: DOUBLE
72738: EQUAL
72739: IFTRUE 72743
72741: GO 72769
72743: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
72744: LD_ADDR_VAR 0 3
72748: PUSH
72749: LD_INT 21
72751: PUSH
72752: LD_INT 22
72754: PUSH
72755: LD_INT 23
72757: PUSH
72758: LD_INT 24
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: ST_TO_ADDR
72767: GO 72916
72769: LD_INT 51
72771: DOUBLE
72772: EQUAL
72773: IFTRUE 72777
72775: GO 72803
72777: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
72778: LD_ADDR_VAR 0 3
72782: PUSH
72783: LD_INT 21
72785: PUSH
72786: LD_INT 22
72788: PUSH
72789: LD_INT 23
72791: PUSH
72792: LD_INT 24
72794: PUSH
72795: EMPTY
72796: LIST
72797: LIST
72798: LIST
72799: LIST
72800: ST_TO_ADDR
72801: GO 72916
72803: LD_INT 52
72805: DOUBLE
72806: EQUAL
72807: IFTRUE 72811
72809: GO 72837
72811: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
72812: LD_ADDR_VAR 0 3
72816: PUSH
72817: LD_INT 21
72819: PUSH
72820: LD_INT 22
72822: PUSH
72823: LD_INT 23
72825: PUSH
72826: LD_INT 24
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: ST_TO_ADDR
72835: GO 72916
72837: LD_INT 53
72839: DOUBLE
72840: EQUAL
72841: IFTRUE 72845
72843: GO 72863
72845: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
72846: LD_ADDR_VAR 0 3
72850: PUSH
72851: LD_INT 23
72853: PUSH
72854: LD_INT 24
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: ST_TO_ADDR
72861: GO 72916
72863: LD_INT 46
72865: DOUBLE
72866: EQUAL
72867: IFTRUE 72871
72869: GO 72889
72871: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
72872: LD_ADDR_VAR 0 3
72876: PUSH
72877: LD_INT 23
72879: PUSH
72880: LD_INT 24
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: ST_TO_ADDR
72887: GO 72916
72889: LD_INT 47
72891: DOUBLE
72892: EQUAL
72893: IFTRUE 72897
72895: GO 72915
72897: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72898: LD_ADDR_VAR 0 3
72902: PUSH
72903: LD_INT 23
72905: PUSH
72906: LD_INT 24
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: ST_TO_ADDR
72913: GO 72916
72915: POP
// result := ( chassis in result ) ;
72916: LD_ADDR_VAR 0 3
72920: PUSH
72921: LD_VAR 0 1
72925: PUSH
72926: LD_VAR 0 3
72930: IN
72931: ST_TO_ADDR
// end ;
72932: LD_VAR 0 3
72936: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
72937: LD_INT 0
72939: PPUSH
72940: PPUSH
72941: PPUSH
72942: PPUSH
72943: PPUSH
72944: PPUSH
72945: PPUSH
// result := array ;
72946: LD_ADDR_VAR 0 5
72950: PUSH
72951: LD_VAR 0 1
72955: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
72956: LD_VAR 0 1
72960: NOT
72961: PUSH
72962: LD_VAR 0 2
72966: NOT
72967: OR
72968: PUSH
72969: LD_VAR 0 3
72973: NOT
72974: OR
72975: PUSH
72976: LD_VAR 0 2
72980: PUSH
72981: LD_VAR 0 1
72985: GREATER
72986: OR
72987: PUSH
72988: LD_VAR 0 3
72992: PUSH
72993: LD_VAR 0 1
72997: GREATER
72998: OR
72999: IFFALSE 73003
// exit ;
73001: GO 73299
// if direction then
73003: LD_VAR 0 4
73007: IFFALSE 73071
// begin d := 1 ;
73009: LD_ADDR_VAR 0 9
73013: PUSH
73014: LD_INT 1
73016: ST_TO_ADDR
// if i_from > i_to then
73017: LD_VAR 0 2
73021: PUSH
73022: LD_VAR 0 3
73026: GREATER
73027: IFFALSE 73053
// length := ( array - i_from ) + i_to else
73029: LD_ADDR_VAR 0 11
73033: PUSH
73034: LD_VAR 0 1
73038: PUSH
73039: LD_VAR 0 2
73043: MINUS
73044: PUSH
73045: LD_VAR 0 3
73049: PLUS
73050: ST_TO_ADDR
73051: GO 73069
// length := i_to - i_from ;
73053: LD_ADDR_VAR 0 11
73057: PUSH
73058: LD_VAR 0 3
73062: PUSH
73063: LD_VAR 0 2
73067: MINUS
73068: ST_TO_ADDR
// end else
73069: GO 73132
// begin d := - 1 ;
73071: LD_ADDR_VAR 0 9
73075: PUSH
73076: LD_INT 1
73078: NEG
73079: ST_TO_ADDR
// if i_from > i_to then
73080: LD_VAR 0 2
73084: PUSH
73085: LD_VAR 0 3
73089: GREATER
73090: IFFALSE 73110
// length := i_from - i_to else
73092: LD_ADDR_VAR 0 11
73096: PUSH
73097: LD_VAR 0 2
73101: PUSH
73102: LD_VAR 0 3
73106: MINUS
73107: ST_TO_ADDR
73108: GO 73132
// length := ( array - i_to ) + i_from ;
73110: LD_ADDR_VAR 0 11
73114: PUSH
73115: LD_VAR 0 1
73119: PUSH
73120: LD_VAR 0 3
73124: MINUS
73125: PUSH
73126: LD_VAR 0 2
73130: PLUS
73131: ST_TO_ADDR
// end ; if not length then
73132: LD_VAR 0 11
73136: NOT
73137: IFFALSE 73141
// exit ;
73139: GO 73299
// tmp := array ;
73141: LD_ADDR_VAR 0 10
73145: PUSH
73146: LD_VAR 0 1
73150: ST_TO_ADDR
// for i = 1 to length do
73151: LD_ADDR_VAR 0 6
73155: PUSH
73156: DOUBLE
73157: LD_INT 1
73159: DEC
73160: ST_TO_ADDR
73161: LD_VAR 0 11
73165: PUSH
73166: FOR_TO
73167: IFFALSE 73287
// begin for j = 1 to array do
73169: LD_ADDR_VAR 0 7
73173: PUSH
73174: DOUBLE
73175: LD_INT 1
73177: DEC
73178: ST_TO_ADDR
73179: LD_VAR 0 1
73183: PUSH
73184: FOR_TO
73185: IFFALSE 73273
// begin k := j + d ;
73187: LD_ADDR_VAR 0 8
73191: PUSH
73192: LD_VAR 0 7
73196: PUSH
73197: LD_VAR 0 9
73201: PLUS
73202: ST_TO_ADDR
// if k > array then
73203: LD_VAR 0 8
73207: PUSH
73208: LD_VAR 0 1
73212: GREATER
73213: IFFALSE 73223
// k := 1 ;
73215: LD_ADDR_VAR 0 8
73219: PUSH
73220: LD_INT 1
73222: ST_TO_ADDR
// if not k then
73223: LD_VAR 0 8
73227: NOT
73228: IFFALSE 73240
// k := array ;
73230: LD_ADDR_VAR 0 8
73234: PUSH
73235: LD_VAR 0 1
73239: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
73240: LD_ADDR_VAR 0 10
73244: PUSH
73245: LD_VAR 0 10
73249: PPUSH
73250: LD_VAR 0 8
73254: PPUSH
73255: LD_VAR 0 1
73259: PUSH
73260: LD_VAR 0 7
73264: ARRAY
73265: PPUSH
73266: CALL_OW 1
73270: ST_TO_ADDR
// end ;
73271: GO 73184
73273: POP
73274: POP
// array := tmp ;
73275: LD_ADDR_VAR 0 1
73279: PUSH
73280: LD_VAR 0 10
73284: ST_TO_ADDR
// end ;
73285: GO 73166
73287: POP
73288: POP
// result := array ;
73289: LD_ADDR_VAR 0 5
73293: PUSH
73294: LD_VAR 0 1
73298: ST_TO_ADDR
// end ;
73299: LD_VAR 0 5
73303: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
73304: LD_INT 0
73306: PPUSH
73307: PPUSH
// result := 0 ;
73308: LD_ADDR_VAR 0 3
73312: PUSH
73313: LD_INT 0
73315: ST_TO_ADDR
// if not array or not value in array then
73316: LD_VAR 0 1
73320: NOT
73321: PUSH
73322: LD_VAR 0 2
73326: PUSH
73327: LD_VAR 0 1
73331: IN
73332: NOT
73333: OR
73334: IFFALSE 73338
// exit ;
73336: GO 73392
// for i = 1 to array do
73338: LD_ADDR_VAR 0 4
73342: PUSH
73343: DOUBLE
73344: LD_INT 1
73346: DEC
73347: ST_TO_ADDR
73348: LD_VAR 0 1
73352: PUSH
73353: FOR_TO
73354: IFFALSE 73390
// if value = array [ i ] then
73356: LD_VAR 0 2
73360: PUSH
73361: LD_VAR 0 1
73365: PUSH
73366: LD_VAR 0 4
73370: ARRAY
73371: EQUAL
73372: IFFALSE 73388
// begin result := i ;
73374: LD_ADDR_VAR 0 3
73378: PUSH
73379: LD_VAR 0 4
73383: ST_TO_ADDR
// exit ;
73384: POP
73385: POP
73386: GO 73392
// end ;
73388: GO 73353
73390: POP
73391: POP
// end ;
73392: LD_VAR 0 3
73396: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
73397: LD_INT 0
73399: PPUSH
// vc_chassis := chassis ;
73400: LD_ADDR_OWVAR 37
73404: PUSH
73405: LD_VAR 0 1
73409: ST_TO_ADDR
// vc_engine := engine ;
73410: LD_ADDR_OWVAR 39
73414: PUSH
73415: LD_VAR 0 2
73419: ST_TO_ADDR
// vc_control := control ;
73420: LD_ADDR_OWVAR 38
73424: PUSH
73425: LD_VAR 0 3
73429: ST_TO_ADDR
// vc_weapon := weapon ;
73430: LD_ADDR_OWVAR 40
73434: PUSH
73435: LD_VAR 0 4
73439: ST_TO_ADDR
// vc_fuel_battery := fuel ;
73440: LD_ADDR_OWVAR 41
73444: PUSH
73445: LD_VAR 0 5
73449: ST_TO_ADDR
// end ;
73450: LD_VAR 0 6
73454: RET
// export function WantPlant ( unit ) ; var task ; begin
73455: LD_INT 0
73457: PPUSH
73458: PPUSH
// result := false ;
73459: LD_ADDR_VAR 0 2
73463: PUSH
73464: LD_INT 0
73466: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
73467: LD_ADDR_VAR 0 3
73471: PUSH
73472: LD_VAR 0 1
73476: PPUSH
73477: CALL_OW 437
73481: ST_TO_ADDR
// if task then
73482: LD_VAR 0 3
73486: IFFALSE 73514
// if task [ 1 ] [ 1 ] = p then
73488: LD_VAR 0 3
73492: PUSH
73493: LD_INT 1
73495: ARRAY
73496: PUSH
73497: LD_INT 1
73499: ARRAY
73500: PUSH
73501: LD_STRING p
73503: EQUAL
73504: IFFALSE 73514
// result := true ;
73506: LD_ADDR_VAR 0 2
73510: PUSH
73511: LD_INT 1
73513: ST_TO_ADDR
// end ;
73514: LD_VAR 0 2
73518: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
73519: LD_INT 0
73521: PPUSH
73522: PPUSH
73523: PPUSH
73524: PPUSH
// if pos < 1 then
73525: LD_VAR 0 2
73529: PUSH
73530: LD_INT 1
73532: LESS
73533: IFFALSE 73537
// exit ;
73535: GO 73840
// if pos = 1 then
73537: LD_VAR 0 2
73541: PUSH
73542: LD_INT 1
73544: EQUAL
73545: IFFALSE 73578
// result := Replace ( arr , pos [ 1 ] , value ) else
73547: LD_ADDR_VAR 0 4
73551: PUSH
73552: LD_VAR 0 1
73556: PPUSH
73557: LD_VAR 0 2
73561: PUSH
73562: LD_INT 1
73564: ARRAY
73565: PPUSH
73566: LD_VAR 0 3
73570: PPUSH
73571: CALL_OW 1
73575: ST_TO_ADDR
73576: GO 73840
// begin tmp := arr ;
73578: LD_ADDR_VAR 0 6
73582: PUSH
73583: LD_VAR 0 1
73587: ST_TO_ADDR
// s_arr := [ tmp ] ;
73588: LD_ADDR_VAR 0 7
73592: PUSH
73593: LD_VAR 0 6
73597: PUSH
73598: EMPTY
73599: LIST
73600: ST_TO_ADDR
// for i = 1 to pos - 1 do
73601: LD_ADDR_VAR 0 5
73605: PUSH
73606: DOUBLE
73607: LD_INT 1
73609: DEC
73610: ST_TO_ADDR
73611: LD_VAR 0 2
73615: PUSH
73616: LD_INT 1
73618: MINUS
73619: PUSH
73620: FOR_TO
73621: IFFALSE 73666
// begin tmp := tmp [ pos [ i ] ] ;
73623: LD_ADDR_VAR 0 6
73627: PUSH
73628: LD_VAR 0 6
73632: PUSH
73633: LD_VAR 0 2
73637: PUSH
73638: LD_VAR 0 5
73642: ARRAY
73643: ARRAY
73644: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
73645: LD_ADDR_VAR 0 7
73649: PUSH
73650: LD_VAR 0 7
73654: PUSH
73655: LD_VAR 0 6
73659: PUSH
73660: EMPTY
73661: LIST
73662: ADD
73663: ST_TO_ADDR
// end ;
73664: GO 73620
73666: POP
73667: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
73668: LD_ADDR_VAR 0 6
73672: PUSH
73673: LD_VAR 0 6
73677: PPUSH
73678: LD_VAR 0 2
73682: PUSH
73683: LD_VAR 0 2
73687: ARRAY
73688: PPUSH
73689: LD_VAR 0 3
73693: PPUSH
73694: CALL_OW 1
73698: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
73699: LD_ADDR_VAR 0 7
73703: PUSH
73704: LD_VAR 0 7
73708: PPUSH
73709: LD_VAR 0 7
73713: PPUSH
73714: LD_VAR 0 6
73718: PPUSH
73719: CALL_OW 1
73723: ST_TO_ADDR
// for i = s_arr downto 2 do
73724: LD_ADDR_VAR 0 5
73728: PUSH
73729: DOUBLE
73730: LD_VAR 0 7
73734: INC
73735: ST_TO_ADDR
73736: LD_INT 2
73738: PUSH
73739: FOR_DOWNTO
73740: IFFALSE 73824
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
73742: LD_ADDR_VAR 0 6
73746: PUSH
73747: LD_VAR 0 7
73751: PUSH
73752: LD_VAR 0 5
73756: PUSH
73757: LD_INT 1
73759: MINUS
73760: ARRAY
73761: PPUSH
73762: LD_VAR 0 2
73766: PUSH
73767: LD_VAR 0 5
73771: PUSH
73772: LD_INT 1
73774: MINUS
73775: ARRAY
73776: PPUSH
73777: LD_VAR 0 7
73781: PUSH
73782: LD_VAR 0 5
73786: ARRAY
73787: PPUSH
73788: CALL_OW 1
73792: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
73793: LD_ADDR_VAR 0 7
73797: PUSH
73798: LD_VAR 0 7
73802: PPUSH
73803: LD_VAR 0 5
73807: PUSH
73808: LD_INT 1
73810: MINUS
73811: PPUSH
73812: LD_VAR 0 6
73816: PPUSH
73817: CALL_OW 1
73821: ST_TO_ADDR
// end ;
73822: GO 73739
73824: POP
73825: POP
// result := s_arr [ 1 ] ;
73826: LD_ADDR_VAR 0 4
73830: PUSH
73831: LD_VAR 0 7
73835: PUSH
73836: LD_INT 1
73838: ARRAY
73839: ST_TO_ADDR
// end ; end ;
73840: LD_VAR 0 4
73844: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
73845: LD_INT 0
73847: PPUSH
73848: PPUSH
// if not list then
73849: LD_VAR 0 1
73853: NOT
73854: IFFALSE 73858
// exit ;
73856: GO 73949
// i := list [ pos1 ] ;
73858: LD_ADDR_VAR 0 5
73862: PUSH
73863: LD_VAR 0 1
73867: PUSH
73868: LD_VAR 0 2
73872: ARRAY
73873: ST_TO_ADDR
// if not i then
73874: LD_VAR 0 5
73878: NOT
73879: IFFALSE 73883
// exit ;
73881: GO 73949
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
73883: LD_ADDR_VAR 0 1
73887: PUSH
73888: LD_VAR 0 1
73892: PPUSH
73893: LD_VAR 0 2
73897: PPUSH
73898: LD_VAR 0 1
73902: PUSH
73903: LD_VAR 0 3
73907: ARRAY
73908: PPUSH
73909: CALL_OW 1
73913: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
73914: LD_ADDR_VAR 0 1
73918: PUSH
73919: LD_VAR 0 1
73923: PPUSH
73924: LD_VAR 0 3
73928: PPUSH
73929: LD_VAR 0 5
73933: PPUSH
73934: CALL_OW 1
73938: ST_TO_ADDR
// result := list ;
73939: LD_ADDR_VAR 0 4
73943: PUSH
73944: LD_VAR 0 1
73948: ST_TO_ADDR
// end ;
73949: LD_VAR 0 4
73953: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
73954: LD_INT 0
73956: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
73957: LD_ADDR_VAR 0 5
73961: PUSH
73962: LD_VAR 0 1
73966: PPUSH
73967: CALL_OW 250
73971: PPUSH
73972: LD_VAR 0 1
73976: PPUSH
73977: CALL_OW 251
73981: PPUSH
73982: LD_VAR 0 2
73986: PPUSH
73987: LD_VAR 0 3
73991: PPUSH
73992: LD_VAR 0 4
73996: PPUSH
73997: CALL 74007 0 5
74001: ST_TO_ADDR
// end ;
74002: LD_VAR 0 5
74006: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
74007: LD_INT 0
74009: PPUSH
74010: PPUSH
74011: PPUSH
74012: PPUSH
// if not list then
74013: LD_VAR 0 3
74017: NOT
74018: IFFALSE 74022
// exit ;
74020: GO 74410
// result := [ ] ;
74022: LD_ADDR_VAR 0 6
74026: PUSH
74027: EMPTY
74028: ST_TO_ADDR
// for i in list do
74029: LD_ADDR_VAR 0 7
74033: PUSH
74034: LD_VAR 0 3
74038: PUSH
74039: FOR_IN
74040: IFFALSE 74242
// begin tmp := GetDistUnitXY ( i , x , y ) ;
74042: LD_ADDR_VAR 0 9
74046: PUSH
74047: LD_VAR 0 7
74051: PPUSH
74052: LD_VAR 0 1
74056: PPUSH
74057: LD_VAR 0 2
74061: PPUSH
74062: CALL_OW 297
74066: ST_TO_ADDR
// if not result then
74067: LD_VAR 0 6
74071: NOT
74072: IFFALSE 74098
// result := [ [ i , tmp ] ] else
74074: LD_ADDR_VAR 0 6
74078: PUSH
74079: LD_VAR 0 7
74083: PUSH
74084: LD_VAR 0 9
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: EMPTY
74094: LIST
74095: ST_TO_ADDR
74096: GO 74240
// begin if result [ result ] [ 2 ] < tmp then
74098: LD_VAR 0 6
74102: PUSH
74103: LD_VAR 0 6
74107: ARRAY
74108: PUSH
74109: LD_INT 2
74111: ARRAY
74112: PUSH
74113: LD_VAR 0 9
74117: LESS
74118: IFFALSE 74160
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
74120: LD_ADDR_VAR 0 6
74124: PUSH
74125: LD_VAR 0 6
74129: PPUSH
74130: LD_VAR 0 6
74134: PUSH
74135: LD_INT 1
74137: PLUS
74138: PPUSH
74139: LD_VAR 0 7
74143: PUSH
74144: LD_VAR 0 9
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PPUSH
74153: CALL_OW 2
74157: ST_TO_ADDR
74158: GO 74240
// for j = 1 to result do
74160: LD_ADDR_VAR 0 8
74164: PUSH
74165: DOUBLE
74166: LD_INT 1
74168: DEC
74169: ST_TO_ADDR
74170: LD_VAR 0 6
74174: PUSH
74175: FOR_TO
74176: IFFALSE 74238
// begin if tmp < result [ j ] [ 2 ] then
74178: LD_VAR 0 9
74182: PUSH
74183: LD_VAR 0 6
74187: PUSH
74188: LD_VAR 0 8
74192: ARRAY
74193: PUSH
74194: LD_INT 2
74196: ARRAY
74197: LESS
74198: IFFALSE 74236
// begin result := Insert ( result , j , [ i , tmp ] ) ;
74200: LD_ADDR_VAR 0 6
74204: PUSH
74205: LD_VAR 0 6
74209: PPUSH
74210: LD_VAR 0 8
74214: PPUSH
74215: LD_VAR 0 7
74219: PUSH
74220: LD_VAR 0 9
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PPUSH
74229: CALL_OW 2
74233: ST_TO_ADDR
// break ;
74234: GO 74238
// end ; end ;
74236: GO 74175
74238: POP
74239: POP
// end ; end ;
74240: GO 74039
74242: POP
74243: POP
// if result and not asc then
74244: LD_VAR 0 6
74248: PUSH
74249: LD_VAR 0 4
74253: NOT
74254: AND
74255: IFFALSE 74330
// begin tmp := result ;
74257: LD_ADDR_VAR 0 9
74261: PUSH
74262: LD_VAR 0 6
74266: ST_TO_ADDR
// for i = tmp downto 1 do
74267: LD_ADDR_VAR 0 7
74271: PUSH
74272: DOUBLE
74273: LD_VAR 0 9
74277: INC
74278: ST_TO_ADDR
74279: LD_INT 1
74281: PUSH
74282: FOR_DOWNTO
74283: IFFALSE 74328
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
74285: LD_ADDR_VAR 0 6
74289: PUSH
74290: LD_VAR 0 6
74294: PPUSH
74295: LD_VAR 0 9
74299: PUSH
74300: LD_VAR 0 7
74304: MINUS
74305: PUSH
74306: LD_INT 1
74308: PLUS
74309: PPUSH
74310: LD_VAR 0 9
74314: PUSH
74315: LD_VAR 0 7
74319: ARRAY
74320: PPUSH
74321: CALL_OW 1
74325: ST_TO_ADDR
74326: GO 74282
74328: POP
74329: POP
// end ; tmp := [ ] ;
74330: LD_ADDR_VAR 0 9
74334: PUSH
74335: EMPTY
74336: ST_TO_ADDR
// if mode then
74337: LD_VAR 0 5
74341: IFFALSE 74410
// begin for i = 1 to result do
74343: LD_ADDR_VAR 0 7
74347: PUSH
74348: DOUBLE
74349: LD_INT 1
74351: DEC
74352: ST_TO_ADDR
74353: LD_VAR 0 6
74357: PUSH
74358: FOR_TO
74359: IFFALSE 74398
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
74361: LD_ADDR_VAR 0 9
74365: PUSH
74366: LD_VAR 0 9
74370: PPUSH
74371: LD_VAR 0 7
74375: PPUSH
74376: LD_VAR 0 6
74380: PUSH
74381: LD_VAR 0 7
74385: ARRAY
74386: PUSH
74387: LD_INT 1
74389: ARRAY
74390: PPUSH
74391: CALL_OW 1
74395: ST_TO_ADDR
74396: GO 74358
74398: POP
74399: POP
// result := tmp ;
74400: LD_ADDR_VAR 0 6
74404: PUSH
74405: LD_VAR 0 9
74409: ST_TO_ADDR
// end ; end ;
74410: LD_VAR 0 6
74414: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
74415: LD_INT 0
74417: PPUSH
74418: PPUSH
74419: PPUSH
74420: PPUSH
74421: PPUSH
74422: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
74423: LD_ADDR_VAR 0 5
74427: PUSH
74428: LD_INT 0
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: LD_INT 0
74436: PUSH
74437: EMPTY
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: ST_TO_ADDR
// if not x or not y then
74445: LD_VAR 0 2
74449: NOT
74450: PUSH
74451: LD_VAR 0 3
74455: NOT
74456: OR
74457: IFFALSE 74461
// exit ;
74459: GO 76111
// if not range then
74461: LD_VAR 0 4
74465: NOT
74466: IFFALSE 74476
// range := 10 ;
74468: LD_ADDR_VAR 0 4
74472: PUSH
74473: LD_INT 10
74475: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
74476: LD_ADDR_VAR 0 8
74480: PUSH
74481: LD_INT 81
74483: PUSH
74484: LD_VAR 0 1
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 92
74495: PUSH
74496: LD_VAR 0 2
74500: PUSH
74501: LD_VAR 0 3
74505: PUSH
74506: LD_VAR 0 4
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 3
74519: PUSH
74520: LD_INT 21
74522: PUSH
74523: LD_INT 3
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: LIST
74538: PPUSH
74539: CALL_OW 69
74543: ST_TO_ADDR
// if not tmp then
74544: LD_VAR 0 8
74548: NOT
74549: IFFALSE 74553
// exit ;
74551: GO 76111
// for i in tmp do
74553: LD_ADDR_VAR 0 6
74557: PUSH
74558: LD_VAR 0 8
74562: PUSH
74563: FOR_IN
74564: IFFALSE 76086
// begin points := [ 0 , 0 , 0 ] ;
74566: LD_ADDR_VAR 0 9
74570: PUSH
74571: LD_INT 0
74573: PUSH
74574: LD_INT 0
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: LIST
74584: ST_TO_ADDR
// bpoints := 1 ;
74585: LD_ADDR_VAR 0 10
74589: PUSH
74590: LD_INT 1
74592: ST_TO_ADDR
// case GetType ( i ) of unit_human :
74593: LD_VAR 0 6
74597: PPUSH
74598: CALL_OW 247
74602: PUSH
74603: LD_INT 1
74605: DOUBLE
74606: EQUAL
74607: IFTRUE 74611
74609: GO 75189
74611: POP
// begin if GetClass ( i ) = 1 then
74612: LD_VAR 0 6
74616: PPUSH
74617: CALL_OW 257
74621: PUSH
74622: LD_INT 1
74624: EQUAL
74625: IFFALSE 74646
// points := [ 10 , 5 , 3 ] ;
74627: LD_ADDR_VAR 0 9
74631: PUSH
74632: LD_INT 10
74634: PUSH
74635: LD_INT 5
74637: PUSH
74638: LD_INT 3
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: LIST
74645: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
74646: LD_VAR 0 6
74650: PPUSH
74651: CALL_OW 257
74655: PUSH
74656: LD_INT 2
74658: PUSH
74659: LD_INT 3
74661: PUSH
74662: LD_INT 4
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: LIST
74669: IN
74670: IFFALSE 74691
// points := [ 3 , 2 , 1 ] ;
74672: LD_ADDR_VAR 0 9
74676: PUSH
74677: LD_INT 3
74679: PUSH
74680: LD_INT 2
74682: PUSH
74683: LD_INT 1
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: LIST
74690: ST_TO_ADDR
// if GetClass ( i ) = 5 then
74691: LD_VAR 0 6
74695: PPUSH
74696: CALL_OW 257
74700: PUSH
74701: LD_INT 5
74703: EQUAL
74704: IFFALSE 74725
// points := [ 130 , 5 , 2 ] ;
74706: LD_ADDR_VAR 0 9
74710: PUSH
74711: LD_INT 130
74713: PUSH
74714: LD_INT 5
74716: PUSH
74717: LD_INT 2
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: LIST
74724: ST_TO_ADDR
// if GetClass ( i ) = 8 then
74725: LD_VAR 0 6
74729: PPUSH
74730: CALL_OW 257
74734: PUSH
74735: LD_INT 8
74737: EQUAL
74738: IFFALSE 74759
// points := [ 35 , 35 , 30 ] ;
74740: LD_ADDR_VAR 0 9
74744: PUSH
74745: LD_INT 35
74747: PUSH
74748: LD_INT 35
74750: PUSH
74751: LD_INT 30
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: LIST
74758: ST_TO_ADDR
// if GetClass ( i ) = 9 then
74759: LD_VAR 0 6
74763: PPUSH
74764: CALL_OW 257
74768: PUSH
74769: LD_INT 9
74771: EQUAL
74772: IFFALSE 74793
// points := [ 20 , 55 , 40 ] ;
74774: LD_ADDR_VAR 0 9
74778: PUSH
74779: LD_INT 20
74781: PUSH
74782: LD_INT 55
74784: PUSH
74785: LD_INT 40
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: LIST
74792: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
74793: LD_VAR 0 6
74797: PPUSH
74798: CALL_OW 257
74802: PUSH
74803: LD_INT 12
74805: PUSH
74806: LD_INT 16
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: IN
74813: IFFALSE 74834
// points := [ 5 , 3 , 2 ] ;
74815: LD_ADDR_VAR 0 9
74819: PUSH
74820: LD_INT 5
74822: PUSH
74823: LD_INT 3
74825: PUSH
74826: LD_INT 2
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: LIST
74833: ST_TO_ADDR
// if GetClass ( i ) = 17 then
74834: LD_VAR 0 6
74838: PPUSH
74839: CALL_OW 257
74843: PUSH
74844: LD_INT 17
74846: EQUAL
74847: IFFALSE 74868
// points := [ 100 , 50 , 75 ] ;
74849: LD_ADDR_VAR 0 9
74853: PUSH
74854: LD_INT 100
74856: PUSH
74857: LD_INT 50
74859: PUSH
74860: LD_INT 75
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: LIST
74867: ST_TO_ADDR
// if GetClass ( i ) = 15 then
74868: LD_VAR 0 6
74872: PPUSH
74873: CALL_OW 257
74877: PUSH
74878: LD_INT 15
74880: EQUAL
74881: IFFALSE 74902
// points := [ 10 , 5 , 3 ] ;
74883: LD_ADDR_VAR 0 9
74887: PUSH
74888: LD_INT 10
74890: PUSH
74891: LD_INT 5
74893: PUSH
74894: LD_INT 3
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: LIST
74901: ST_TO_ADDR
// if GetClass ( i ) = 14 then
74902: LD_VAR 0 6
74906: PPUSH
74907: CALL_OW 257
74911: PUSH
74912: LD_INT 14
74914: EQUAL
74915: IFFALSE 74936
// points := [ 10 , 0 , 0 ] ;
74917: LD_ADDR_VAR 0 9
74921: PUSH
74922: LD_INT 10
74924: PUSH
74925: LD_INT 0
74927: PUSH
74928: LD_INT 0
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: LIST
74935: ST_TO_ADDR
// if GetClass ( i ) = 11 then
74936: LD_VAR 0 6
74940: PPUSH
74941: CALL_OW 257
74945: PUSH
74946: LD_INT 11
74948: EQUAL
74949: IFFALSE 74970
// points := [ 30 , 10 , 5 ] ;
74951: LD_ADDR_VAR 0 9
74955: PUSH
74956: LD_INT 30
74958: PUSH
74959: LD_INT 10
74961: PUSH
74962: LD_INT 5
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: LIST
74969: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
74970: LD_VAR 0 1
74974: PPUSH
74975: LD_INT 5
74977: PPUSH
74978: CALL_OW 321
74982: PUSH
74983: LD_INT 2
74985: EQUAL
74986: IFFALSE 75003
// bpoints := bpoints * 1.8 ;
74988: LD_ADDR_VAR 0 10
74992: PUSH
74993: LD_VAR 0 10
74997: PUSH
74998: LD_REAL  1.80000000000000E+0000
75001: MUL
75002: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
75003: LD_VAR 0 6
75007: PPUSH
75008: CALL_OW 257
75012: PUSH
75013: LD_INT 1
75015: PUSH
75016: LD_INT 2
75018: PUSH
75019: LD_INT 3
75021: PUSH
75022: LD_INT 4
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: IN
75031: PUSH
75032: LD_VAR 0 1
75036: PPUSH
75037: LD_INT 51
75039: PPUSH
75040: CALL_OW 321
75044: PUSH
75045: LD_INT 2
75047: EQUAL
75048: AND
75049: IFFALSE 75066
// bpoints := bpoints * 1.2 ;
75051: LD_ADDR_VAR 0 10
75055: PUSH
75056: LD_VAR 0 10
75060: PUSH
75061: LD_REAL  1.20000000000000E+0000
75064: MUL
75065: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
75066: LD_VAR 0 6
75070: PPUSH
75071: CALL_OW 257
75075: PUSH
75076: LD_INT 5
75078: PUSH
75079: LD_INT 7
75081: PUSH
75082: LD_INT 9
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: LIST
75089: IN
75090: PUSH
75091: LD_VAR 0 1
75095: PPUSH
75096: LD_INT 52
75098: PPUSH
75099: CALL_OW 321
75103: PUSH
75104: LD_INT 2
75106: EQUAL
75107: AND
75108: IFFALSE 75125
// bpoints := bpoints * 1.5 ;
75110: LD_ADDR_VAR 0 10
75114: PUSH
75115: LD_VAR 0 10
75119: PUSH
75120: LD_REAL  1.50000000000000E+0000
75123: MUL
75124: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
75125: LD_VAR 0 1
75129: PPUSH
75130: LD_INT 66
75132: PPUSH
75133: CALL_OW 321
75137: PUSH
75138: LD_INT 2
75140: EQUAL
75141: IFFALSE 75158
// bpoints := bpoints * 1.1 ;
75143: LD_ADDR_VAR 0 10
75147: PUSH
75148: LD_VAR 0 10
75152: PUSH
75153: LD_REAL  1.10000000000000E+0000
75156: MUL
75157: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
75158: LD_ADDR_VAR 0 10
75162: PUSH
75163: LD_VAR 0 10
75167: PUSH
75168: LD_VAR 0 6
75172: PPUSH
75173: LD_INT 1
75175: PPUSH
75176: CALL_OW 259
75180: PUSH
75181: LD_REAL  1.15000000000000E+0000
75184: MUL
75185: MUL
75186: ST_TO_ADDR
// end ; unit_vehicle :
75187: GO 76015
75189: LD_INT 2
75191: DOUBLE
75192: EQUAL
75193: IFTRUE 75197
75195: GO 76003
75197: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
75198: LD_VAR 0 6
75202: PPUSH
75203: CALL_OW 264
75207: PUSH
75208: LD_INT 2
75210: PUSH
75211: LD_INT 42
75213: PUSH
75214: LD_INT 24
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: LIST
75221: IN
75222: IFFALSE 75243
// points := [ 25 , 5 , 3 ] ;
75224: LD_ADDR_VAR 0 9
75228: PUSH
75229: LD_INT 25
75231: PUSH
75232: LD_INT 5
75234: PUSH
75235: LD_INT 3
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: LIST
75242: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
75243: LD_VAR 0 6
75247: PPUSH
75248: CALL_OW 264
75252: PUSH
75253: LD_INT 4
75255: PUSH
75256: LD_INT 43
75258: PUSH
75259: LD_INT 25
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: LIST
75266: IN
75267: IFFALSE 75288
// points := [ 40 , 15 , 5 ] ;
75269: LD_ADDR_VAR 0 9
75273: PUSH
75274: LD_INT 40
75276: PUSH
75277: LD_INT 15
75279: PUSH
75280: LD_INT 5
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: LIST
75287: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
75288: LD_VAR 0 6
75292: PPUSH
75293: CALL_OW 264
75297: PUSH
75298: LD_INT 3
75300: PUSH
75301: LD_INT 23
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: IN
75308: IFFALSE 75329
// points := [ 7 , 25 , 8 ] ;
75310: LD_ADDR_VAR 0 9
75314: PUSH
75315: LD_INT 7
75317: PUSH
75318: LD_INT 25
75320: PUSH
75321: LD_INT 8
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: LIST
75328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
75329: LD_VAR 0 6
75333: PPUSH
75334: CALL_OW 264
75338: PUSH
75339: LD_INT 5
75341: PUSH
75342: LD_INT 27
75344: PUSH
75345: LD_INT 44
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: LIST
75352: IN
75353: IFFALSE 75374
// points := [ 14 , 50 , 16 ] ;
75355: LD_ADDR_VAR 0 9
75359: PUSH
75360: LD_INT 14
75362: PUSH
75363: LD_INT 50
75365: PUSH
75366: LD_INT 16
75368: PUSH
75369: EMPTY
75370: LIST
75371: LIST
75372: LIST
75373: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
75374: LD_VAR 0 6
75378: PPUSH
75379: CALL_OW 264
75383: PUSH
75384: LD_INT 6
75386: PUSH
75387: LD_INT 46
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: IN
75394: IFFALSE 75415
// points := [ 32 , 120 , 70 ] ;
75396: LD_ADDR_VAR 0 9
75400: PUSH
75401: LD_INT 32
75403: PUSH
75404: LD_INT 120
75406: PUSH
75407: LD_INT 70
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: LIST
75414: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
75415: LD_VAR 0 6
75419: PPUSH
75420: CALL_OW 264
75424: PUSH
75425: LD_INT 7
75427: PUSH
75428: LD_INT 28
75430: PUSH
75431: LD_INT 45
75433: PUSH
75434: LD_INT 92
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: LIST
75441: LIST
75442: IN
75443: IFFALSE 75464
// points := [ 35 , 20 , 45 ] ;
75445: LD_ADDR_VAR 0 9
75449: PUSH
75450: LD_INT 35
75452: PUSH
75453: LD_INT 20
75455: PUSH
75456: LD_INT 45
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: LIST
75463: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
75464: LD_VAR 0 6
75468: PPUSH
75469: CALL_OW 264
75473: PUSH
75474: LD_INT 47
75476: PUSH
75477: EMPTY
75478: LIST
75479: IN
75480: IFFALSE 75501
// points := [ 67 , 45 , 75 ] ;
75482: LD_ADDR_VAR 0 9
75486: PUSH
75487: LD_INT 67
75489: PUSH
75490: LD_INT 45
75492: PUSH
75493: LD_INT 75
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: LIST
75500: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
75501: LD_VAR 0 6
75505: PPUSH
75506: CALL_OW 264
75510: PUSH
75511: LD_INT 26
75513: PUSH
75514: EMPTY
75515: LIST
75516: IN
75517: IFFALSE 75538
// points := [ 120 , 30 , 80 ] ;
75519: LD_ADDR_VAR 0 9
75523: PUSH
75524: LD_INT 120
75526: PUSH
75527: LD_INT 30
75529: PUSH
75530: LD_INT 80
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: LIST
75537: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
75538: LD_VAR 0 6
75542: PPUSH
75543: CALL_OW 264
75547: PUSH
75548: LD_INT 22
75550: PUSH
75551: EMPTY
75552: LIST
75553: IN
75554: IFFALSE 75575
// points := [ 40 , 1 , 1 ] ;
75556: LD_ADDR_VAR 0 9
75560: PUSH
75561: LD_INT 40
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: LIST
75574: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
75575: LD_VAR 0 6
75579: PPUSH
75580: CALL_OW 264
75584: PUSH
75585: LD_INT 29
75587: PUSH
75588: EMPTY
75589: LIST
75590: IN
75591: IFFALSE 75612
// points := [ 70 , 200 , 400 ] ;
75593: LD_ADDR_VAR 0 9
75597: PUSH
75598: LD_INT 70
75600: PUSH
75601: LD_INT 200
75603: PUSH
75604: LD_INT 400
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
75612: LD_VAR 0 6
75616: PPUSH
75617: CALL_OW 264
75621: PUSH
75622: LD_INT 14
75624: PUSH
75625: LD_INT 53
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: IN
75632: IFFALSE 75653
// points := [ 40 , 10 , 20 ] ;
75634: LD_ADDR_VAR 0 9
75638: PUSH
75639: LD_INT 40
75641: PUSH
75642: LD_INT 10
75644: PUSH
75645: LD_INT 20
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: LIST
75652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
75653: LD_VAR 0 6
75657: PPUSH
75658: CALL_OW 264
75662: PUSH
75663: LD_INT 9
75665: PUSH
75666: EMPTY
75667: LIST
75668: IN
75669: IFFALSE 75690
// points := [ 5 , 70 , 20 ] ;
75671: LD_ADDR_VAR 0 9
75675: PUSH
75676: LD_INT 5
75678: PUSH
75679: LD_INT 70
75681: PUSH
75682: LD_INT 20
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: LIST
75689: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
75690: LD_VAR 0 6
75694: PPUSH
75695: CALL_OW 264
75699: PUSH
75700: LD_INT 10
75702: PUSH
75703: EMPTY
75704: LIST
75705: IN
75706: IFFALSE 75727
// points := [ 35 , 110 , 70 ] ;
75708: LD_ADDR_VAR 0 9
75712: PUSH
75713: LD_INT 35
75715: PUSH
75716: LD_INT 110
75718: PUSH
75719: LD_INT 70
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: LIST
75726: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
75727: LD_VAR 0 6
75731: PPUSH
75732: CALL_OW 265
75736: PUSH
75737: LD_INT 25
75739: EQUAL
75740: IFFALSE 75761
// points := [ 80 , 65 , 100 ] ;
75742: LD_ADDR_VAR 0 9
75746: PUSH
75747: LD_INT 80
75749: PUSH
75750: LD_INT 65
75752: PUSH
75753: LD_INT 100
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: LIST
75760: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
75761: LD_VAR 0 6
75765: PPUSH
75766: CALL_OW 263
75770: PUSH
75771: LD_INT 1
75773: EQUAL
75774: IFFALSE 75809
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
75776: LD_ADDR_VAR 0 10
75780: PUSH
75781: LD_VAR 0 10
75785: PUSH
75786: LD_VAR 0 6
75790: PPUSH
75791: CALL_OW 311
75795: PPUSH
75796: LD_INT 3
75798: PPUSH
75799: CALL_OW 259
75803: PUSH
75804: LD_INT 4
75806: MUL
75807: MUL
75808: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
75809: LD_VAR 0 6
75813: PPUSH
75814: CALL_OW 263
75818: PUSH
75819: LD_INT 2
75821: EQUAL
75822: IFFALSE 75873
// begin j := IsControledBy ( i ) ;
75824: LD_ADDR_VAR 0 7
75828: PUSH
75829: LD_VAR 0 6
75833: PPUSH
75834: CALL_OW 312
75838: ST_TO_ADDR
// if j then
75839: LD_VAR 0 7
75843: IFFALSE 75873
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
75845: LD_ADDR_VAR 0 10
75849: PUSH
75850: LD_VAR 0 10
75854: PUSH
75855: LD_VAR 0 7
75859: PPUSH
75860: LD_INT 3
75862: PPUSH
75863: CALL_OW 259
75867: PUSH
75868: LD_INT 3
75870: MUL
75871: MUL
75872: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
75873: LD_VAR 0 6
75877: PPUSH
75878: CALL_OW 264
75882: PUSH
75883: LD_INT 5
75885: PUSH
75886: LD_INT 6
75888: PUSH
75889: LD_INT 46
75891: PUSH
75892: LD_INT 44
75894: PUSH
75895: LD_INT 47
75897: PUSH
75898: LD_INT 45
75900: PUSH
75901: LD_INT 28
75903: PUSH
75904: LD_INT 7
75906: PUSH
75907: LD_INT 27
75909: PUSH
75910: LD_INT 29
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: IN
75925: PUSH
75926: LD_VAR 0 1
75930: PPUSH
75931: LD_INT 52
75933: PPUSH
75934: CALL_OW 321
75938: PUSH
75939: LD_INT 2
75941: EQUAL
75942: AND
75943: IFFALSE 75960
// bpoints := bpoints * 1.2 ;
75945: LD_ADDR_VAR 0 10
75949: PUSH
75950: LD_VAR 0 10
75954: PUSH
75955: LD_REAL  1.20000000000000E+0000
75958: MUL
75959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
75960: LD_VAR 0 6
75964: PPUSH
75965: CALL_OW 264
75969: PUSH
75970: LD_INT 6
75972: PUSH
75973: LD_INT 46
75975: PUSH
75976: LD_INT 47
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: LIST
75983: IN
75984: IFFALSE 76001
// bpoints := bpoints * 1.2 ;
75986: LD_ADDR_VAR 0 10
75990: PUSH
75991: LD_VAR 0 10
75995: PUSH
75996: LD_REAL  1.20000000000000E+0000
75999: MUL
76000: ST_TO_ADDR
// end ; unit_building :
76001: GO 76015
76003: LD_INT 3
76005: DOUBLE
76006: EQUAL
76007: IFTRUE 76011
76009: GO 76014
76011: POP
// ; end ;
76012: GO 76015
76014: POP
// for j = 1 to 3 do
76015: LD_ADDR_VAR 0 7
76019: PUSH
76020: DOUBLE
76021: LD_INT 1
76023: DEC
76024: ST_TO_ADDR
76025: LD_INT 3
76027: PUSH
76028: FOR_TO
76029: IFFALSE 76082
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
76031: LD_ADDR_VAR 0 5
76035: PUSH
76036: LD_VAR 0 5
76040: PPUSH
76041: LD_VAR 0 7
76045: PPUSH
76046: LD_VAR 0 5
76050: PUSH
76051: LD_VAR 0 7
76055: ARRAY
76056: PUSH
76057: LD_VAR 0 9
76061: PUSH
76062: LD_VAR 0 7
76066: ARRAY
76067: PUSH
76068: LD_VAR 0 10
76072: MUL
76073: PLUS
76074: PPUSH
76075: CALL_OW 1
76079: ST_TO_ADDR
76080: GO 76028
76082: POP
76083: POP
// end ;
76084: GO 74563
76086: POP
76087: POP
// result := Replace ( result , 4 , tmp ) ;
76088: LD_ADDR_VAR 0 5
76092: PUSH
76093: LD_VAR 0 5
76097: PPUSH
76098: LD_INT 4
76100: PPUSH
76101: LD_VAR 0 8
76105: PPUSH
76106: CALL_OW 1
76110: ST_TO_ADDR
// end ;
76111: LD_VAR 0 5
76115: RET
// export function DangerAtRange ( unit , range ) ; begin
76116: LD_INT 0
76118: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
76119: LD_ADDR_VAR 0 3
76123: PUSH
76124: LD_VAR 0 1
76128: PPUSH
76129: CALL_OW 255
76133: PPUSH
76134: LD_VAR 0 1
76138: PPUSH
76139: CALL_OW 250
76143: PPUSH
76144: LD_VAR 0 1
76148: PPUSH
76149: CALL_OW 251
76153: PPUSH
76154: LD_VAR 0 2
76158: PPUSH
76159: CALL 74415 0 4
76163: ST_TO_ADDR
// end ;
76164: LD_VAR 0 3
76168: RET
// export function DangerInArea ( side , area ) ; begin
76169: LD_INT 0
76171: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
76172: LD_ADDR_VAR 0 3
76176: PUSH
76177: LD_VAR 0 2
76181: PPUSH
76182: LD_INT 81
76184: PUSH
76185: LD_VAR 0 1
76189: PUSH
76190: EMPTY
76191: LIST
76192: LIST
76193: PPUSH
76194: CALL_OW 70
76198: ST_TO_ADDR
// end ;
76199: LD_VAR 0 3
76203: RET
// export function IsExtension ( b ) ; begin
76204: LD_INT 0
76206: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
76207: LD_ADDR_VAR 0 2
76211: PUSH
76212: LD_VAR 0 1
76216: PUSH
76217: LD_INT 23
76219: PUSH
76220: LD_INT 20
76222: PUSH
76223: LD_INT 22
76225: PUSH
76226: LD_INT 17
76228: PUSH
76229: LD_INT 24
76231: PUSH
76232: LD_INT 21
76234: PUSH
76235: LD_INT 19
76237: PUSH
76238: LD_INT 16
76240: PUSH
76241: LD_INT 25
76243: PUSH
76244: LD_INT 18
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: LIST
76258: IN
76259: ST_TO_ADDR
// end ;
76260: LD_VAR 0 2
76264: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
76265: LD_INT 0
76267: PPUSH
76268: PPUSH
76269: PPUSH
// result := [ ] ;
76270: LD_ADDR_VAR 0 4
76274: PUSH
76275: EMPTY
76276: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
76277: LD_ADDR_VAR 0 5
76281: PUSH
76282: LD_VAR 0 2
76286: PPUSH
76287: LD_INT 21
76289: PUSH
76290: LD_INT 3
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PPUSH
76297: CALL_OW 70
76301: ST_TO_ADDR
// if not tmp then
76302: LD_VAR 0 5
76306: NOT
76307: IFFALSE 76311
// exit ;
76309: GO 76375
// if checkLink then
76311: LD_VAR 0 3
76315: IFFALSE 76365
// begin for i in tmp do
76317: LD_ADDR_VAR 0 6
76321: PUSH
76322: LD_VAR 0 5
76326: PUSH
76327: FOR_IN
76328: IFFALSE 76363
// if GetBase ( i ) <> base then
76330: LD_VAR 0 6
76334: PPUSH
76335: CALL_OW 274
76339: PUSH
76340: LD_VAR 0 1
76344: NONEQUAL
76345: IFFALSE 76361
// ComLinkToBase ( base , i ) ;
76347: LD_VAR 0 1
76351: PPUSH
76352: LD_VAR 0 6
76356: PPUSH
76357: CALL_OW 169
76361: GO 76327
76363: POP
76364: POP
// end ; result := tmp ;
76365: LD_ADDR_VAR 0 4
76369: PUSH
76370: LD_VAR 0 5
76374: ST_TO_ADDR
// end ;
76375: LD_VAR 0 4
76379: RET
// export function ComComplete ( units , b ) ; var i ; begin
76380: LD_INT 0
76382: PPUSH
76383: PPUSH
// if not units then
76384: LD_VAR 0 1
76388: NOT
76389: IFFALSE 76393
// exit ;
76391: GO 76483
// for i in units do
76393: LD_ADDR_VAR 0 4
76397: PUSH
76398: LD_VAR 0 1
76402: PUSH
76403: FOR_IN
76404: IFFALSE 76481
// if BuildingStatus ( b ) = bs_build then
76406: LD_VAR 0 2
76410: PPUSH
76411: CALL_OW 461
76415: PUSH
76416: LD_INT 1
76418: EQUAL
76419: IFFALSE 76479
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
76421: LD_VAR 0 4
76425: PPUSH
76426: LD_STRING h
76428: PUSH
76429: LD_VAR 0 2
76433: PPUSH
76434: CALL_OW 250
76438: PUSH
76439: LD_VAR 0 2
76443: PPUSH
76444: CALL_OW 251
76448: PUSH
76449: LD_VAR 0 2
76453: PUSH
76454: LD_INT 0
76456: PUSH
76457: LD_INT 0
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: EMPTY
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: PUSH
76472: EMPTY
76473: LIST
76474: PPUSH
76475: CALL_OW 446
76479: GO 76403
76481: POP
76482: POP
// end ;
76483: LD_VAR 0 3
76487: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
76488: LD_INT 0
76490: PPUSH
76491: PPUSH
76492: PPUSH
76493: PPUSH
76494: PPUSH
76495: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
76496: LD_VAR 0 1
76500: NOT
76501: PUSH
76502: LD_VAR 0 1
76506: PPUSH
76507: CALL_OW 263
76511: PUSH
76512: LD_INT 2
76514: NONEQUAL
76515: OR
76516: IFFALSE 76520
// exit ;
76518: GO 76836
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
76520: LD_ADDR_VAR 0 6
76524: PUSH
76525: LD_INT 22
76527: PUSH
76528: LD_VAR 0 1
76532: PPUSH
76533: CALL_OW 255
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 2
76544: PUSH
76545: LD_INT 30
76547: PUSH
76548: LD_INT 36
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 34
76557: PUSH
76558: LD_INT 31
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: LIST
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PPUSH
76574: CALL_OW 69
76578: ST_TO_ADDR
// if not tmp then
76579: LD_VAR 0 6
76583: NOT
76584: IFFALSE 76588
// exit ;
76586: GO 76836
// result := [ ] ;
76588: LD_ADDR_VAR 0 2
76592: PUSH
76593: EMPTY
76594: ST_TO_ADDR
// for i in tmp do
76595: LD_ADDR_VAR 0 3
76599: PUSH
76600: LD_VAR 0 6
76604: PUSH
76605: FOR_IN
76606: IFFALSE 76677
// begin t := UnitsInside ( i ) ;
76608: LD_ADDR_VAR 0 4
76612: PUSH
76613: LD_VAR 0 3
76617: PPUSH
76618: CALL_OW 313
76622: ST_TO_ADDR
// if t then
76623: LD_VAR 0 4
76627: IFFALSE 76675
// for j in t do
76629: LD_ADDR_VAR 0 7
76633: PUSH
76634: LD_VAR 0 4
76638: PUSH
76639: FOR_IN
76640: IFFALSE 76673
// result := Replace ( result , result + 1 , j ) ;
76642: LD_ADDR_VAR 0 2
76646: PUSH
76647: LD_VAR 0 2
76651: PPUSH
76652: LD_VAR 0 2
76656: PUSH
76657: LD_INT 1
76659: PLUS
76660: PPUSH
76661: LD_VAR 0 7
76665: PPUSH
76666: CALL_OW 1
76670: ST_TO_ADDR
76671: GO 76639
76673: POP
76674: POP
// end ;
76675: GO 76605
76677: POP
76678: POP
// if not result then
76679: LD_VAR 0 2
76683: NOT
76684: IFFALSE 76688
// exit ;
76686: GO 76836
// mech := result [ 1 ] ;
76688: LD_ADDR_VAR 0 5
76692: PUSH
76693: LD_VAR 0 2
76697: PUSH
76698: LD_INT 1
76700: ARRAY
76701: ST_TO_ADDR
// if result > 1 then
76702: LD_VAR 0 2
76706: PUSH
76707: LD_INT 1
76709: GREATER
76710: IFFALSE 76822
// begin for i = 2 to result do
76712: LD_ADDR_VAR 0 3
76716: PUSH
76717: DOUBLE
76718: LD_INT 2
76720: DEC
76721: ST_TO_ADDR
76722: LD_VAR 0 2
76726: PUSH
76727: FOR_TO
76728: IFFALSE 76820
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
76730: LD_ADDR_VAR 0 4
76734: PUSH
76735: LD_VAR 0 2
76739: PUSH
76740: LD_VAR 0 3
76744: ARRAY
76745: PPUSH
76746: LD_INT 3
76748: PPUSH
76749: CALL_OW 259
76753: PUSH
76754: LD_VAR 0 2
76758: PUSH
76759: LD_VAR 0 3
76763: ARRAY
76764: PPUSH
76765: CALL_OW 432
76769: MINUS
76770: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
76771: LD_VAR 0 4
76775: PUSH
76776: LD_VAR 0 5
76780: PPUSH
76781: LD_INT 3
76783: PPUSH
76784: CALL_OW 259
76788: PUSH
76789: LD_VAR 0 5
76793: PPUSH
76794: CALL_OW 432
76798: MINUS
76799: GREATEREQUAL
76800: IFFALSE 76818
// mech := result [ i ] ;
76802: LD_ADDR_VAR 0 5
76806: PUSH
76807: LD_VAR 0 2
76811: PUSH
76812: LD_VAR 0 3
76816: ARRAY
76817: ST_TO_ADDR
// end ;
76818: GO 76727
76820: POP
76821: POP
// end ; ComLinkTo ( vehicle , mech ) ;
76822: LD_VAR 0 1
76826: PPUSH
76827: LD_VAR 0 5
76831: PPUSH
76832: CALL_OW 135
// end ;
76836: LD_VAR 0 2
76840: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
76841: LD_INT 0
76843: PPUSH
76844: PPUSH
76845: PPUSH
76846: PPUSH
76847: PPUSH
76848: PPUSH
76849: PPUSH
76850: PPUSH
76851: PPUSH
76852: PPUSH
76853: PPUSH
76854: PPUSH
76855: PPUSH
// result := [ ] ;
76856: LD_ADDR_VAR 0 7
76860: PUSH
76861: EMPTY
76862: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
76863: LD_VAR 0 1
76867: PPUSH
76868: CALL_OW 266
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: LD_INT 1
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: IN
76883: NOT
76884: IFFALSE 76888
// exit ;
76886: GO 78522
// if name then
76888: LD_VAR 0 3
76892: IFFALSE 76908
// SetBName ( base_dep , name ) ;
76894: LD_VAR 0 1
76898: PPUSH
76899: LD_VAR 0 3
76903: PPUSH
76904: CALL_OW 500
// base := GetBase ( base_dep ) ;
76908: LD_ADDR_VAR 0 15
76912: PUSH
76913: LD_VAR 0 1
76917: PPUSH
76918: CALL_OW 274
76922: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
76923: LD_ADDR_VAR 0 16
76927: PUSH
76928: LD_VAR 0 1
76932: PPUSH
76933: CALL_OW 255
76937: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
76938: LD_ADDR_VAR 0 17
76942: PUSH
76943: LD_VAR 0 1
76947: PPUSH
76948: CALL_OW 248
76952: ST_TO_ADDR
// if sources then
76953: LD_VAR 0 5
76957: IFFALSE 77004
// for i = 1 to 3 do
76959: LD_ADDR_VAR 0 8
76963: PUSH
76964: DOUBLE
76965: LD_INT 1
76967: DEC
76968: ST_TO_ADDR
76969: LD_INT 3
76971: PUSH
76972: FOR_TO
76973: IFFALSE 77002
// AddResourceType ( base , i , sources [ i ] ) ;
76975: LD_VAR 0 15
76979: PPUSH
76980: LD_VAR 0 8
76984: PPUSH
76985: LD_VAR 0 5
76989: PUSH
76990: LD_VAR 0 8
76994: ARRAY
76995: PPUSH
76996: CALL_OW 276
77000: GO 76972
77002: POP
77003: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
77004: LD_ADDR_VAR 0 18
77008: PUSH
77009: LD_VAR 0 15
77013: PPUSH
77014: LD_VAR 0 2
77018: PPUSH
77019: LD_INT 1
77021: PPUSH
77022: CALL 76265 0 3
77026: ST_TO_ADDR
// InitHc ;
77027: CALL_OW 19
// InitUc ;
77031: CALL_OW 18
// uc_side := side ;
77035: LD_ADDR_OWVAR 20
77039: PUSH
77040: LD_VAR 0 16
77044: ST_TO_ADDR
// uc_nation := nation ;
77045: LD_ADDR_OWVAR 21
77049: PUSH
77050: LD_VAR 0 17
77054: ST_TO_ADDR
// if buildings then
77055: LD_VAR 0 18
77059: IFFALSE 78381
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
77061: LD_ADDR_VAR 0 19
77065: PUSH
77066: LD_VAR 0 18
77070: PPUSH
77071: LD_INT 2
77073: PUSH
77074: LD_INT 30
77076: PUSH
77077: LD_INT 29
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 30
77086: PUSH
77087: LD_INT 30
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: LIST
77098: PPUSH
77099: CALL_OW 72
77103: ST_TO_ADDR
// if tmp then
77104: LD_VAR 0 19
77108: IFFALSE 77156
// for i in tmp do
77110: LD_ADDR_VAR 0 8
77114: PUSH
77115: LD_VAR 0 19
77119: PUSH
77120: FOR_IN
77121: IFFALSE 77154
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
77123: LD_VAR 0 8
77127: PPUSH
77128: CALL_OW 250
77132: PPUSH
77133: LD_VAR 0 8
77137: PPUSH
77138: CALL_OW 251
77142: PPUSH
77143: LD_VAR 0 16
77147: PPUSH
77148: CALL_OW 441
77152: GO 77120
77154: POP
77155: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
77156: LD_VAR 0 18
77160: PPUSH
77161: LD_INT 2
77163: PUSH
77164: LD_INT 30
77166: PUSH
77167: LD_INT 32
77169: PUSH
77170: EMPTY
77171: LIST
77172: LIST
77173: PUSH
77174: LD_INT 30
77176: PUSH
77177: LD_INT 33
77179: PUSH
77180: EMPTY
77181: LIST
77182: LIST
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: LIST
77188: PPUSH
77189: CALL_OW 72
77193: IFFALSE 77281
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
77195: LD_ADDR_VAR 0 8
77199: PUSH
77200: LD_VAR 0 18
77204: PPUSH
77205: LD_INT 2
77207: PUSH
77208: LD_INT 30
77210: PUSH
77211: LD_INT 32
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 30
77220: PUSH
77221: LD_INT 33
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: LIST
77232: PPUSH
77233: CALL_OW 72
77237: PUSH
77238: FOR_IN
77239: IFFALSE 77279
// begin if not GetBWeapon ( i ) then
77241: LD_VAR 0 8
77245: PPUSH
77246: CALL_OW 269
77250: NOT
77251: IFFALSE 77277
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
77253: LD_VAR 0 8
77257: PPUSH
77258: LD_VAR 0 8
77262: PPUSH
77263: LD_VAR 0 2
77267: PPUSH
77268: CALL 78527 0 2
77272: PPUSH
77273: CALL_OW 431
// end ;
77277: GO 77238
77279: POP
77280: POP
// end ; for i = 1 to personel do
77281: LD_ADDR_VAR 0 8
77285: PUSH
77286: DOUBLE
77287: LD_INT 1
77289: DEC
77290: ST_TO_ADDR
77291: LD_VAR 0 6
77295: PUSH
77296: FOR_TO
77297: IFFALSE 78361
// begin if i > 4 then
77299: LD_VAR 0 8
77303: PUSH
77304: LD_INT 4
77306: GREATER
77307: IFFALSE 77311
// break ;
77309: GO 78361
// case i of 1 :
77311: LD_VAR 0 8
77315: PUSH
77316: LD_INT 1
77318: DOUBLE
77319: EQUAL
77320: IFTRUE 77324
77322: GO 77404
77324: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
77325: LD_ADDR_VAR 0 12
77329: PUSH
77330: LD_VAR 0 18
77334: PPUSH
77335: LD_INT 22
77337: PUSH
77338: LD_VAR 0 16
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 58
77349: PUSH
77350: EMPTY
77351: LIST
77352: PUSH
77353: LD_INT 2
77355: PUSH
77356: LD_INT 30
77358: PUSH
77359: LD_INT 32
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 30
77368: PUSH
77369: LD_INT 4
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 30
77378: PUSH
77379: LD_INT 5
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: LIST
77390: LIST
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: LIST
77396: PPUSH
77397: CALL_OW 72
77401: ST_TO_ADDR
77402: GO 77626
77404: LD_INT 2
77406: DOUBLE
77407: EQUAL
77408: IFTRUE 77412
77410: GO 77474
77412: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
77413: LD_ADDR_VAR 0 12
77417: PUSH
77418: LD_VAR 0 18
77422: PPUSH
77423: LD_INT 22
77425: PUSH
77426: LD_VAR 0 16
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 2
77437: PUSH
77438: LD_INT 30
77440: PUSH
77441: LD_INT 0
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 30
77450: PUSH
77451: LD_INT 1
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: LIST
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PPUSH
77467: CALL_OW 72
77471: ST_TO_ADDR
77472: GO 77626
77474: LD_INT 3
77476: DOUBLE
77477: EQUAL
77478: IFTRUE 77482
77480: GO 77544
77482: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
77483: LD_ADDR_VAR 0 12
77487: PUSH
77488: LD_VAR 0 18
77492: PPUSH
77493: LD_INT 22
77495: PUSH
77496: LD_VAR 0 16
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 2
77507: PUSH
77508: LD_INT 30
77510: PUSH
77511: LD_INT 2
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 30
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: LIST
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PPUSH
77537: CALL_OW 72
77541: ST_TO_ADDR
77542: GO 77626
77544: LD_INT 4
77546: DOUBLE
77547: EQUAL
77548: IFTRUE 77552
77550: GO 77625
77552: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
77553: LD_ADDR_VAR 0 12
77557: PUSH
77558: LD_VAR 0 18
77562: PPUSH
77563: LD_INT 22
77565: PUSH
77566: LD_VAR 0 16
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 2
77577: PUSH
77578: LD_INT 30
77580: PUSH
77581: LD_INT 6
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 30
77590: PUSH
77591: LD_INT 7
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PUSH
77598: LD_INT 30
77600: PUSH
77601: LD_INT 8
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: PPUSH
77618: CALL_OW 72
77622: ST_TO_ADDR
77623: GO 77626
77625: POP
// if i = 1 then
77626: LD_VAR 0 8
77630: PUSH
77631: LD_INT 1
77633: EQUAL
77634: IFFALSE 77745
// begin tmp := [ ] ;
77636: LD_ADDR_VAR 0 19
77640: PUSH
77641: EMPTY
77642: ST_TO_ADDR
// for j in f do
77643: LD_ADDR_VAR 0 9
77647: PUSH
77648: LD_VAR 0 12
77652: PUSH
77653: FOR_IN
77654: IFFALSE 77727
// if GetBType ( j ) = b_bunker then
77656: LD_VAR 0 9
77660: PPUSH
77661: CALL_OW 266
77665: PUSH
77666: LD_INT 32
77668: EQUAL
77669: IFFALSE 77696
// tmp := Insert ( tmp , 1 , j ) else
77671: LD_ADDR_VAR 0 19
77675: PUSH
77676: LD_VAR 0 19
77680: PPUSH
77681: LD_INT 1
77683: PPUSH
77684: LD_VAR 0 9
77688: PPUSH
77689: CALL_OW 2
77693: ST_TO_ADDR
77694: GO 77725
// tmp := Insert ( tmp , tmp + 1 , j ) ;
77696: LD_ADDR_VAR 0 19
77700: PUSH
77701: LD_VAR 0 19
77705: PPUSH
77706: LD_VAR 0 19
77710: PUSH
77711: LD_INT 1
77713: PLUS
77714: PPUSH
77715: LD_VAR 0 9
77719: PPUSH
77720: CALL_OW 2
77724: ST_TO_ADDR
77725: GO 77653
77727: POP
77728: POP
// if tmp then
77729: LD_VAR 0 19
77733: IFFALSE 77745
// f := tmp ;
77735: LD_ADDR_VAR 0 12
77739: PUSH
77740: LD_VAR 0 19
77744: ST_TO_ADDR
// end ; x := personel [ i ] ;
77745: LD_ADDR_VAR 0 13
77749: PUSH
77750: LD_VAR 0 6
77754: PUSH
77755: LD_VAR 0 8
77759: ARRAY
77760: ST_TO_ADDR
// if x = - 1 then
77761: LD_VAR 0 13
77765: PUSH
77766: LD_INT 1
77768: NEG
77769: EQUAL
77770: IFFALSE 77979
// begin for j in f do
77772: LD_ADDR_VAR 0 9
77776: PUSH
77777: LD_VAR 0 12
77781: PUSH
77782: FOR_IN
77783: IFFALSE 77975
// repeat InitHc ;
77785: CALL_OW 19
// if GetBType ( j ) = b_barracks then
77789: LD_VAR 0 9
77793: PPUSH
77794: CALL_OW 266
77798: PUSH
77799: LD_INT 5
77801: EQUAL
77802: IFFALSE 77872
// begin if UnitsInside ( j ) < 3 then
77804: LD_VAR 0 9
77808: PPUSH
77809: CALL_OW 313
77813: PUSH
77814: LD_INT 3
77816: LESS
77817: IFFALSE 77853
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77819: LD_INT 0
77821: PPUSH
77822: LD_INT 5
77824: PUSH
77825: LD_INT 8
77827: PUSH
77828: LD_INT 9
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: LIST
77835: PUSH
77836: LD_VAR 0 17
77840: ARRAY
77841: PPUSH
77842: LD_VAR 0 4
77846: PPUSH
77847: CALL_OW 380
77851: GO 77870
// PrepareHuman ( false , i , skill ) ;
77853: LD_INT 0
77855: PPUSH
77856: LD_VAR 0 8
77860: PPUSH
77861: LD_VAR 0 4
77865: PPUSH
77866: CALL_OW 380
// end else
77870: GO 77889
// PrepareHuman ( false , i , skill ) ;
77872: LD_INT 0
77874: PPUSH
77875: LD_VAR 0 8
77879: PPUSH
77880: LD_VAR 0 4
77884: PPUSH
77885: CALL_OW 380
// un := CreateHuman ;
77889: LD_ADDR_VAR 0 14
77893: PUSH
77894: CALL_OW 44
77898: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77899: LD_ADDR_VAR 0 7
77903: PUSH
77904: LD_VAR 0 7
77908: PPUSH
77909: LD_INT 1
77911: PPUSH
77912: LD_VAR 0 14
77916: PPUSH
77917: CALL_OW 2
77921: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
77922: LD_VAR 0 14
77926: PPUSH
77927: LD_VAR 0 9
77931: PPUSH
77932: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
77936: LD_VAR 0 9
77940: PPUSH
77941: CALL_OW 313
77945: PUSH
77946: LD_INT 6
77948: EQUAL
77949: PUSH
77950: LD_VAR 0 9
77954: PPUSH
77955: CALL_OW 266
77959: PUSH
77960: LD_INT 32
77962: PUSH
77963: LD_INT 31
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: IN
77970: OR
77971: IFFALSE 77785
77973: GO 77782
77975: POP
77976: POP
// end else
77977: GO 78359
// for j = 1 to x do
77979: LD_ADDR_VAR 0 9
77983: PUSH
77984: DOUBLE
77985: LD_INT 1
77987: DEC
77988: ST_TO_ADDR
77989: LD_VAR 0 13
77993: PUSH
77994: FOR_TO
77995: IFFALSE 78357
// begin InitHc ;
77997: CALL_OW 19
// if not f then
78001: LD_VAR 0 12
78005: NOT
78006: IFFALSE 78095
// begin PrepareHuman ( false , i , skill ) ;
78008: LD_INT 0
78010: PPUSH
78011: LD_VAR 0 8
78015: PPUSH
78016: LD_VAR 0 4
78020: PPUSH
78021: CALL_OW 380
// un := CreateHuman ;
78025: LD_ADDR_VAR 0 14
78029: PUSH
78030: CALL_OW 44
78034: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78035: LD_ADDR_VAR 0 7
78039: PUSH
78040: LD_VAR 0 7
78044: PPUSH
78045: LD_INT 1
78047: PPUSH
78048: LD_VAR 0 14
78052: PPUSH
78053: CALL_OW 2
78057: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78058: LD_VAR 0 14
78062: PPUSH
78063: LD_VAR 0 1
78067: PPUSH
78068: CALL_OW 250
78072: PPUSH
78073: LD_VAR 0 1
78077: PPUSH
78078: CALL_OW 251
78082: PPUSH
78083: LD_INT 10
78085: PPUSH
78086: LD_INT 0
78088: PPUSH
78089: CALL_OW 50
// continue ;
78093: GO 77994
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
78095: LD_VAR 0 12
78099: PUSH
78100: LD_INT 1
78102: ARRAY
78103: PPUSH
78104: CALL_OW 313
78108: PUSH
78109: LD_VAR 0 12
78113: PUSH
78114: LD_INT 1
78116: ARRAY
78117: PPUSH
78118: CALL_OW 266
78122: PUSH
78123: LD_INT 32
78125: PUSH
78126: LD_INT 31
78128: PUSH
78129: EMPTY
78130: LIST
78131: LIST
78132: IN
78133: AND
78134: PUSH
78135: LD_VAR 0 12
78139: PUSH
78140: LD_INT 1
78142: ARRAY
78143: PPUSH
78144: CALL_OW 313
78148: PUSH
78149: LD_INT 6
78151: EQUAL
78152: OR
78153: IFFALSE 78173
// f := Delete ( f , 1 ) ;
78155: LD_ADDR_VAR 0 12
78159: PUSH
78160: LD_VAR 0 12
78164: PPUSH
78165: LD_INT 1
78167: PPUSH
78168: CALL_OW 3
78172: ST_TO_ADDR
// if not f then
78173: LD_VAR 0 12
78177: NOT
78178: IFFALSE 78196
// begin x := x + 2 ;
78180: LD_ADDR_VAR 0 13
78184: PUSH
78185: LD_VAR 0 13
78189: PUSH
78190: LD_INT 2
78192: PLUS
78193: ST_TO_ADDR
// continue ;
78194: GO 77994
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
78196: LD_VAR 0 12
78200: PUSH
78201: LD_INT 1
78203: ARRAY
78204: PPUSH
78205: CALL_OW 266
78209: PUSH
78210: LD_INT 5
78212: EQUAL
78213: IFFALSE 78287
// begin if UnitsInside ( f [ 1 ] ) < 3 then
78215: LD_VAR 0 12
78219: PUSH
78220: LD_INT 1
78222: ARRAY
78223: PPUSH
78224: CALL_OW 313
78228: PUSH
78229: LD_INT 3
78231: LESS
78232: IFFALSE 78268
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78234: LD_INT 0
78236: PPUSH
78237: LD_INT 5
78239: PUSH
78240: LD_INT 8
78242: PUSH
78243: LD_INT 9
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: LIST
78250: PUSH
78251: LD_VAR 0 17
78255: ARRAY
78256: PPUSH
78257: LD_VAR 0 4
78261: PPUSH
78262: CALL_OW 380
78266: GO 78285
// PrepareHuman ( false , i , skill ) ;
78268: LD_INT 0
78270: PPUSH
78271: LD_VAR 0 8
78275: PPUSH
78276: LD_VAR 0 4
78280: PPUSH
78281: CALL_OW 380
// end else
78285: GO 78304
// PrepareHuman ( false , i , skill ) ;
78287: LD_INT 0
78289: PPUSH
78290: LD_VAR 0 8
78294: PPUSH
78295: LD_VAR 0 4
78299: PPUSH
78300: CALL_OW 380
// un := CreateHuman ;
78304: LD_ADDR_VAR 0 14
78308: PUSH
78309: CALL_OW 44
78313: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78314: LD_ADDR_VAR 0 7
78318: PUSH
78319: LD_VAR 0 7
78323: PPUSH
78324: LD_INT 1
78326: PPUSH
78327: LD_VAR 0 14
78331: PPUSH
78332: CALL_OW 2
78336: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
78337: LD_VAR 0 14
78341: PPUSH
78342: LD_VAR 0 12
78346: PUSH
78347: LD_INT 1
78349: ARRAY
78350: PPUSH
78351: CALL_OW 52
// end ;
78355: GO 77994
78357: POP
78358: POP
// end ;
78359: GO 77296
78361: POP
78362: POP
// result := result ^ buildings ;
78363: LD_ADDR_VAR 0 7
78367: PUSH
78368: LD_VAR 0 7
78372: PUSH
78373: LD_VAR 0 18
78377: ADD
78378: ST_TO_ADDR
// end else
78379: GO 78522
// begin for i = 1 to personel do
78381: LD_ADDR_VAR 0 8
78385: PUSH
78386: DOUBLE
78387: LD_INT 1
78389: DEC
78390: ST_TO_ADDR
78391: LD_VAR 0 6
78395: PUSH
78396: FOR_TO
78397: IFFALSE 78520
// begin if i > 4 then
78399: LD_VAR 0 8
78403: PUSH
78404: LD_INT 4
78406: GREATER
78407: IFFALSE 78411
// break ;
78409: GO 78520
// x := personel [ i ] ;
78411: LD_ADDR_VAR 0 13
78415: PUSH
78416: LD_VAR 0 6
78420: PUSH
78421: LD_VAR 0 8
78425: ARRAY
78426: ST_TO_ADDR
// if x = - 1 then
78427: LD_VAR 0 13
78431: PUSH
78432: LD_INT 1
78434: NEG
78435: EQUAL
78436: IFFALSE 78440
// continue ;
78438: GO 78396
// PrepareHuman ( false , i , skill ) ;
78440: LD_INT 0
78442: PPUSH
78443: LD_VAR 0 8
78447: PPUSH
78448: LD_VAR 0 4
78452: PPUSH
78453: CALL_OW 380
// un := CreateHuman ;
78457: LD_ADDR_VAR 0 14
78461: PUSH
78462: CALL_OW 44
78466: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78467: LD_VAR 0 14
78471: PPUSH
78472: LD_VAR 0 1
78476: PPUSH
78477: CALL_OW 250
78481: PPUSH
78482: LD_VAR 0 1
78486: PPUSH
78487: CALL_OW 251
78491: PPUSH
78492: LD_INT 10
78494: PPUSH
78495: LD_INT 0
78497: PPUSH
78498: CALL_OW 50
// result := result ^ un ;
78502: LD_ADDR_VAR 0 7
78506: PUSH
78507: LD_VAR 0 7
78511: PUSH
78512: LD_VAR 0 14
78516: ADD
78517: ST_TO_ADDR
// end ;
78518: GO 78396
78520: POP
78521: POP
// end ; end ;
78522: LD_VAR 0 7
78526: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
78527: LD_INT 0
78529: PPUSH
78530: PPUSH
78531: PPUSH
78532: PPUSH
78533: PPUSH
78534: PPUSH
78535: PPUSH
78536: PPUSH
78537: PPUSH
78538: PPUSH
78539: PPUSH
78540: PPUSH
78541: PPUSH
78542: PPUSH
78543: PPUSH
78544: PPUSH
// result := false ;
78545: LD_ADDR_VAR 0 3
78549: PUSH
78550: LD_INT 0
78552: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
78553: LD_VAR 0 1
78557: NOT
78558: PUSH
78559: LD_VAR 0 1
78563: PPUSH
78564: CALL_OW 266
78568: PUSH
78569: LD_INT 32
78571: PUSH
78572: LD_INT 33
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: IN
78579: NOT
78580: OR
78581: IFFALSE 78585
// exit ;
78583: GO 79694
// nat := GetNation ( tower ) ;
78585: LD_ADDR_VAR 0 12
78589: PUSH
78590: LD_VAR 0 1
78594: PPUSH
78595: CALL_OW 248
78599: ST_TO_ADDR
// side := GetSide ( tower ) ;
78600: LD_ADDR_VAR 0 16
78604: PUSH
78605: LD_VAR 0 1
78609: PPUSH
78610: CALL_OW 255
78614: ST_TO_ADDR
// x := GetX ( tower ) ;
78615: LD_ADDR_VAR 0 10
78619: PUSH
78620: LD_VAR 0 1
78624: PPUSH
78625: CALL_OW 250
78629: ST_TO_ADDR
// y := GetY ( tower ) ;
78630: LD_ADDR_VAR 0 11
78634: PUSH
78635: LD_VAR 0 1
78639: PPUSH
78640: CALL_OW 251
78644: ST_TO_ADDR
// if not x or not y then
78645: LD_VAR 0 10
78649: NOT
78650: PUSH
78651: LD_VAR 0 11
78655: NOT
78656: OR
78657: IFFALSE 78661
// exit ;
78659: GO 79694
// weapon := 0 ;
78661: LD_ADDR_VAR 0 18
78665: PUSH
78666: LD_INT 0
78668: ST_TO_ADDR
// fac_list := [ ] ;
78669: LD_ADDR_VAR 0 17
78673: PUSH
78674: EMPTY
78675: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
78676: LD_ADDR_VAR 0 6
78680: PUSH
78681: LD_VAR 0 1
78685: PPUSH
78686: CALL_OW 274
78690: PPUSH
78691: LD_VAR 0 2
78695: PPUSH
78696: LD_INT 0
78698: PPUSH
78699: CALL 76265 0 3
78703: PPUSH
78704: LD_INT 30
78706: PUSH
78707: LD_INT 3
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PPUSH
78714: CALL_OW 72
78718: ST_TO_ADDR
// if not factories then
78719: LD_VAR 0 6
78723: NOT
78724: IFFALSE 78728
// exit ;
78726: GO 79694
// for i in factories do
78728: LD_ADDR_VAR 0 8
78732: PUSH
78733: LD_VAR 0 6
78737: PUSH
78738: FOR_IN
78739: IFFALSE 78764
// fac_list := fac_list union AvailableWeaponList ( i ) ;
78741: LD_ADDR_VAR 0 17
78745: PUSH
78746: LD_VAR 0 17
78750: PUSH
78751: LD_VAR 0 8
78755: PPUSH
78756: CALL_OW 478
78760: UNION
78761: ST_TO_ADDR
78762: GO 78738
78764: POP
78765: POP
// if not fac_list then
78766: LD_VAR 0 17
78770: NOT
78771: IFFALSE 78775
// exit ;
78773: GO 79694
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
78775: LD_ADDR_VAR 0 5
78779: PUSH
78780: LD_INT 4
78782: PUSH
78783: LD_INT 5
78785: PUSH
78786: LD_INT 9
78788: PUSH
78789: LD_INT 10
78791: PUSH
78792: LD_INT 6
78794: PUSH
78795: LD_INT 7
78797: PUSH
78798: LD_INT 11
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 27
78812: PUSH
78813: LD_INT 28
78815: PUSH
78816: LD_INT 26
78818: PUSH
78819: LD_INT 30
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 43
78830: PUSH
78831: LD_INT 44
78833: PUSH
78834: LD_INT 46
78836: PUSH
78837: LD_INT 45
78839: PUSH
78840: LD_INT 47
78842: PUSH
78843: LD_INT 49
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: LIST
78858: PUSH
78859: LD_VAR 0 12
78863: ARRAY
78864: ST_TO_ADDR
// list := list isect fac_list ;
78865: LD_ADDR_VAR 0 5
78869: PUSH
78870: LD_VAR 0 5
78874: PUSH
78875: LD_VAR 0 17
78879: ISECT
78880: ST_TO_ADDR
// if not list then
78881: LD_VAR 0 5
78885: NOT
78886: IFFALSE 78890
// exit ;
78888: GO 79694
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
78890: LD_VAR 0 12
78894: PUSH
78895: LD_INT 3
78897: EQUAL
78898: PUSH
78899: LD_INT 49
78901: PUSH
78902: LD_VAR 0 5
78906: IN
78907: AND
78908: PUSH
78909: LD_INT 31
78911: PPUSH
78912: LD_VAR 0 16
78916: PPUSH
78917: CALL_OW 321
78921: PUSH
78922: LD_INT 2
78924: EQUAL
78925: AND
78926: IFFALSE 78986
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
78928: LD_INT 22
78930: PUSH
78931: LD_VAR 0 16
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 35
78942: PUSH
78943: LD_INT 49
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 91
78952: PUSH
78953: LD_VAR 0 1
78957: PUSH
78958: LD_INT 10
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: LIST
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: LIST
78970: PPUSH
78971: CALL_OW 69
78975: NOT
78976: IFFALSE 78986
// weapon := ru_time_lapser ;
78978: LD_ADDR_VAR 0 18
78982: PUSH
78983: LD_INT 49
78985: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
78986: LD_VAR 0 12
78990: PUSH
78991: LD_INT 1
78993: PUSH
78994: LD_INT 2
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: IN
79001: PUSH
79002: LD_INT 11
79004: PUSH
79005: LD_VAR 0 5
79009: IN
79010: PUSH
79011: LD_INT 30
79013: PUSH
79014: LD_VAR 0 5
79018: IN
79019: OR
79020: AND
79021: PUSH
79022: LD_INT 6
79024: PPUSH
79025: LD_VAR 0 16
79029: PPUSH
79030: CALL_OW 321
79034: PUSH
79035: LD_INT 2
79037: EQUAL
79038: AND
79039: IFFALSE 79204
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
79041: LD_INT 22
79043: PUSH
79044: LD_VAR 0 16
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 2
79055: PUSH
79056: LD_INT 35
79058: PUSH
79059: LD_INT 11
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PUSH
79066: LD_INT 35
79068: PUSH
79069: LD_INT 30
79071: PUSH
79072: EMPTY
79073: LIST
79074: LIST
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 91
79083: PUSH
79084: LD_VAR 0 1
79088: PUSH
79089: LD_INT 18
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: LIST
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: LIST
79101: PPUSH
79102: CALL_OW 69
79106: NOT
79107: PUSH
79108: LD_INT 22
79110: PUSH
79111: LD_VAR 0 16
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 2
79122: PUSH
79123: LD_INT 30
79125: PUSH
79126: LD_INT 32
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 30
79135: PUSH
79136: LD_INT 33
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 91
79150: PUSH
79151: LD_VAR 0 1
79155: PUSH
79156: LD_INT 12
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: LIST
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: LIST
79168: PUSH
79169: EMPTY
79170: LIST
79171: PPUSH
79172: CALL_OW 69
79176: PUSH
79177: LD_INT 2
79179: GREATER
79180: AND
79181: IFFALSE 79204
// weapon := [ us_radar , ar_radar ] [ nat ] ;
79183: LD_ADDR_VAR 0 18
79187: PUSH
79188: LD_INT 11
79190: PUSH
79191: LD_INT 30
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_VAR 0 12
79202: ARRAY
79203: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
79204: LD_VAR 0 18
79208: NOT
79209: PUSH
79210: LD_INT 40
79212: PPUSH
79213: LD_VAR 0 16
79217: PPUSH
79218: CALL_OW 321
79222: PUSH
79223: LD_INT 2
79225: EQUAL
79226: AND
79227: PUSH
79228: LD_INT 7
79230: PUSH
79231: LD_VAR 0 5
79235: IN
79236: PUSH
79237: LD_INT 28
79239: PUSH
79240: LD_VAR 0 5
79244: IN
79245: OR
79246: PUSH
79247: LD_INT 45
79249: PUSH
79250: LD_VAR 0 5
79254: IN
79255: OR
79256: AND
79257: IFFALSE 79511
// begin hex := GetHexInfo ( x , y ) ;
79259: LD_ADDR_VAR 0 4
79263: PUSH
79264: LD_VAR 0 10
79268: PPUSH
79269: LD_VAR 0 11
79273: PPUSH
79274: CALL_OW 546
79278: ST_TO_ADDR
// if hex [ 1 ] then
79279: LD_VAR 0 4
79283: PUSH
79284: LD_INT 1
79286: ARRAY
79287: IFFALSE 79291
// exit ;
79289: GO 79694
// height := hex [ 2 ] ;
79291: LD_ADDR_VAR 0 15
79295: PUSH
79296: LD_VAR 0 4
79300: PUSH
79301: LD_INT 2
79303: ARRAY
79304: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
79305: LD_ADDR_VAR 0 14
79309: PUSH
79310: LD_INT 0
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: LD_INT 3
79318: PUSH
79319: LD_INT 5
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: ST_TO_ADDR
// for i in tmp do
79328: LD_ADDR_VAR 0 8
79332: PUSH
79333: LD_VAR 0 14
79337: PUSH
79338: FOR_IN
79339: IFFALSE 79509
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
79341: LD_ADDR_VAR 0 9
79345: PUSH
79346: LD_VAR 0 10
79350: PPUSH
79351: LD_VAR 0 8
79355: PPUSH
79356: LD_INT 5
79358: PPUSH
79359: CALL_OW 272
79363: PUSH
79364: LD_VAR 0 11
79368: PPUSH
79369: LD_VAR 0 8
79373: PPUSH
79374: LD_INT 5
79376: PPUSH
79377: CALL_OW 273
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79386: LD_VAR 0 9
79390: PUSH
79391: LD_INT 1
79393: ARRAY
79394: PPUSH
79395: LD_VAR 0 9
79399: PUSH
79400: LD_INT 2
79402: ARRAY
79403: PPUSH
79404: CALL_OW 488
79408: IFFALSE 79507
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
79410: LD_ADDR_VAR 0 4
79414: PUSH
79415: LD_VAR 0 9
79419: PUSH
79420: LD_INT 1
79422: ARRAY
79423: PPUSH
79424: LD_VAR 0 9
79428: PUSH
79429: LD_INT 2
79431: ARRAY
79432: PPUSH
79433: CALL_OW 546
79437: ST_TO_ADDR
// if hex [ 1 ] then
79438: LD_VAR 0 4
79442: PUSH
79443: LD_INT 1
79445: ARRAY
79446: IFFALSE 79450
// continue ;
79448: GO 79338
// h := hex [ 2 ] ;
79450: LD_ADDR_VAR 0 13
79454: PUSH
79455: LD_VAR 0 4
79459: PUSH
79460: LD_INT 2
79462: ARRAY
79463: ST_TO_ADDR
// if h + 7 < height then
79464: LD_VAR 0 13
79468: PUSH
79469: LD_INT 7
79471: PLUS
79472: PUSH
79473: LD_VAR 0 15
79477: LESS
79478: IFFALSE 79507
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
79480: LD_ADDR_VAR 0 18
79484: PUSH
79485: LD_INT 7
79487: PUSH
79488: LD_INT 28
79490: PUSH
79491: LD_INT 45
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: LIST
79498: PUSH
79499: LD_VAR 0 12
79503: ARRAY
79504: ST_TO_ADDR
// break ;
79505: GO 79509
// end ; end ; end ;
79507: GO 79338
79509: POP
79510: POP
// end ; if not weapon then
79511: LD_VAR 0 18
79515: NOT
79516: IFFALSE 79576
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
79518: LD_ADDR_VAR 0 5
79522: PUSH
79523: LD_VAR 0 5
79527: PUSH
79528: LD_INT 11
79530: PUSH
79531: LD_INT 30
79533: PUSH
79534: LD_INT 49
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: LIST
79541: DIFF
79542: ST_TO_ADDR
// if not list then
79543: LD_VAR 0 5
79547: NOT
79548: IFFALSE 79552
// exit ;
79550: GO 79694
// weapon := list [ rand ( 1 , list ) ] ;
79552: LD_ADDR_VAR 0 18
79556: PUSH
79557: LD_VAR 0 5
79561: PUSH
79562: LD_INT 1
79564: PPUSH
79565: LD_VAR 0 5
79569: PPUSH
79570: CALL_OW 12
79574: ARRAY
79575: ST_TO_ADDR
// end ; if weapon then
79576: LD_VAR 0 18
79580: IFFALSE 79694
// begin tmp := CostOfWeapon ( weapon ) ;
79582: LD_ADDR_VAR 0 14
79586: PUSH
79587: LD_VAR 0 18
79591: PPUSH
79592: CALL_OW 451
79596: ST_TO_ADDR
// j := GetBase ( tower ) ;
79597: LD_ADDR_VAR 0 9
79601: PUSH
79602: LD_VAR 0 1
79606: PPUSH
79607: CALL_OW 274
79611: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
79612: LD_VAR 0 9
79616: PPUSH
79617: LD_INT 1
79619: PPUSH
79620: CALL_OW 275
79624: PUSH
79625: LD_VAR 0 14
79629: PUSH
79630: LD_INT 1
79632: ARRAY
79633: GREATEREQUAL
79634: PUSH
79635: LD_VAR 0 9
79639: PPUSH
79640: LD_INT 2
79642: PPUSH
79643: CALL_OW 275
79647: PUSH
79648: LD_VAR 0 14
79652: PUSH
79653: LD_INT 2
79655: ARRAY
79656: GREATEREQUAL
79657: AND
79658: PUSH
79659: LD_VAR 0 9
79663: PPUSH
79664: LD_INT 3
79666: PPUSH
79667: CALL_OW 275
79671: PUSH
79672: LD_VAR 0 14
79676: PUSH
79677: LD_INT 3
79679: ARRAY
79680: GREATEREQUAL
79681: AND
79682: IFFALSE 79694
// result := weapon ;
79684: LD_ADDR_VAR 0 3
79688: PUSH
79689: LD_VAR 0 18
79693: ST_TO_ADDR
// end ; end ;
79694: LD_VAR 0 3
79698: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
79699: LD_INT 0
79701: PPUSH
79702: PPUSH
// result := true ;
79703: LD_ADDR_VAR 0 3
79707: PUSH
79708: LD_INT 1
79710: ST_TO_ADDR
// if array1 = array2 then
79711: LD_VAR 0 1
79715: PUSH
79716: LD_VAR 0 2
79720: EQUAL
79721: IFFALSE 79781
// begin for i = 1 to array1 do
79723: LD_ADDR_VAR 0 4
79727: PUSH
79728: DOUBLE
79729: LD_INT 1
79731: DEC
79732: ST_TO_ADDR
79733: LD_VAR 0 1
79737: PUSH
79738: FOR_TO
79739: IFFALSE 79777
// if array1 [ i ] <> array2 [ i ] then
79741: LD_VAR 0 1
79745: PUSH
79746: LD_VAR 0 4
79750: ARRAY
79751: PUSH
79752: LD_VAR 0 2
79756: PUSH
79757: LD_VAR 0 4
79761: ARRAY
79762: NONEQUAL
79763: IFFALSE 79775
// begin result := false ;
79765: LD_ADDR_VAR 0 3
79769: PUSH
79770: LD_INT 0
79772: ST_TO_ADDR
// break ;
79773: GO 79777
// end ;
79775: GO 79738
79777: POP
79778: POP
// end else
79779: GO 79789
// result := false ;
79781: LD_ADDR_VAR 0 3
79785: PUSH
79786: LD_INT 0
79788: ST_TO_ADDR
// end ;
79789: LD_VAR 0 3
79793: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
79794: LD_INT 0
79796: PPUSH
79797: PPUSH
// if not array1 or not array2 then
79798: LD_VAR 0 1
79802: NOT
79803: PUSH
79804: LD_VAR 0 2
79808: NOT
79809: OR
79810: IFFALSE 79814
// exit ;
79812: GO 79878
// result := true ;
79814: LD_ADDR_VAR 0 3
79818: PUSH
79819: LD_INT 1
79821: ST_TO_ADDR
// for i = 1 to array1 do
79822: LD_ADDR_VAR 0 4
79826: PUSH
79827: DOUBLE
79828: LD_INT 1
79830: DEC
79831: ST_TO_ADDR
79832: LD_VAR 0 1
79836: PUSH
79837: FOR_TO
79838: IFFALSE 79876
// if array1 [ i ] <> array2 [ i ] then
79840: LD_VAR 0 1
79844: PUSH
79845: LD_VAR 0 4
79849: ARRAY
79850: PUSH
79851: LD_VAR 0 2
79855: PUSH
79856: LD_VAR 0 4
79860: ARRAY
79861: NONEQUAL
79862: IFFALSE 79874
// begin result := false ;
79864: LD_ADDR_VAR 0 3
79868: PUSH
79869: LD_INT 0
79871: ST_TO_ADDR
// break ;
79872: GO 79876
// end ;
79874: GO 79837
79876: POP
79877: POP
// end ;
79878: LD_VAR 0 3
79882: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
79883: LD_INT 0
79885: PPUSH
79886: PPUSH
79887: PPUSH
// pom := GetBase ( fac ) ;
79888: LD_ADDR_VAR 0 5
79892: PUSH
79893: LD_VAR 0 1
79897: PPUSH
79898: CALL_OW 274
79902: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
79903: LD_ADDR_VAR 0 4
79907: PUSH
79908: LD_VAR 0 2
79912: PUSH
79913: LD_INT 1
79915: ARRAY
79916: PPUSH
79917: LD_VAR 0 2
79921: PUSH
79922: LD_INT 2
79924: ARRAY
79925: PPUSH
79926: LD_VAR 0 2
79930: PUSH
79931: LD_INT 3
79933: ARRAY
79934: PPUSH
79935: LD_VAR 0 2
79939: PUSH
79940: LD_INT 4
79942: ARRAY
79943: PPUSH
79944: CALL_OW 449
79948: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79949: LD_ADDR_VAR 0 3
79953: PUSH
79954: LD_VAR 0 5
79958: PPUSH
79959: LD_INT 1
79961: PPUSH
79962: CALL_OW 275
79966: PUSH
79967: LD_VAR 0 4
79971: PUSH
79972: LD_INT 1
79974: ARRAY
79975: GREATEREQUAL
79976: PUSH
79977: LD_VAR 0 5
79981: PPUSH
79982: LD_INT 2
79984: PPUSH
79985: CALL_OW 275
79989: PUSH
79990: LD_VAR 0 4
79994: PUSH
79995: LD_INT 2
79997: ARRAY
79998: GREATEREQUAL
79999: AND
80000: PUSH
80001: LD_VAR 0 5
80005: PPUSH
80006: LD_INT 3
80008: PPUSH
80009: CALL_OW 275
80013: PUSH
80014: LD_VAR 0 4
80018: PUSH
80019: LD_INT 3
80021: ARRAY
80022: GREATEREQUAL
80023: AND
80024: ST_TO_ADDR
// end ;
80025: LD_VAR 0 3
80029: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
80030: LD_INT 0
80032: PPUSH
80033: PPUSH
80034: PPUSH
80035: PPUSH
// pom := GetBase ( building ) ;
80036: LD_ADDR_VAR 0 3
80040: PUSH
80041: LD_VAR 0 1
80045: PPUSH
80046: CALL_OW 274
80050: ST_TO_ADDR
// if not pom then
80051: LD_VAR 0 3
80055: NOT
80056: IFFALSE 80060
// exit ;
80058: GO 80230
// btype := GetBType ( building ) ;
80060: LD_ADDR_VAR 0 5
80064: PUSH
80065: LD_VAR 0 1
80069: PPUSH
80070: CALL_OW 266
80074: ST_TO_ADDR
// if btype = b_armoury then
80075: LD_VAR 0 5
80079: PUSH
80080: LD_INT 4
80082: EQUAL
80083: IFFALSE 80093
// btype := b_barracks ;
80085: LD_ADDR_VAR 0 5
80089: PUSH
80090: LD_INT 5
80092: ST_TO_ADDR
// if btype = b_depot then
80093: LD_VAR 0 5
80097: PUSH
80098: LD_INT 0
80100: EQUAL
80101: IFFALSE 80111
// btype := b_warehouse ;
80103: LD_ADDR_VAR 0 5
80107: PUSH
80108: LD_INT 1
80110: ST_TO_ADDR
// if btype = b_workshop then
80111: LD_VAR 0 5
80115: PUSH
80116: LD_INT 2
80118: EQUAL
80119: IFFALSE 80129
// btype := b_factory ;
80121: LD_ADDR_VAR 0 5
80125: PUSH
80126: LD_INT 3
80128: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80129: LD_ADDR_VAR 0 4
80133: PUSH
80134: LD_VAR 0 5
80138: PPUSH
80139: LD_VAR 0 1
80143: PPUSH
80144: CALL_OW 248
80148: PPUSH
80149: CALL_OW 450
80153: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80154: LD_ADDR_VAR 0 2
80158: PUSH
80159: LD_VAR 0 3
80163: PPUSH
80164: LD_INT 1
80166: PPUSH
80167: CALL_OW 275
80171: PUSH
80172: LD_VAR 0 4
80176: PUSH
80177: LD_INT 1
80179: ARRAY
80180: GREATEREQUAL
80181: PUSH
80182: LD_VAR 0 3
80186: PPUSH
80187: LD_INT 2
80189: PPUSH
80190: CALL_OW 275
80194: PUSH
80195: LD_VAR 0 4
80199: PUSH
80200: LD_INT 2
80202: ARRAY
80203: GREATEREQUAL
80204: AND
80205: PUSH
80206: LD_VAR 0 3
80210: PPUSH
80211: LD_INT 3
80213: PPUSH
80214: CALL_OW 275
80218: PUSH
80219: LD_VAR 0 4
80223: PUSH
80224: LD_INT 3
80226: ARRAY
80227: GREATEREQUAL
80228: AND
80229: ST_TO_ADDR
// end ;
80230: LD_VAR 0 2
80234: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
80235: LD_INT 0
80237: PPUSH
80238: PPUSH
80239: PPUSH
// pom := GetBase ( building ) ;
80240: LD_ADDR_VAR 0 4
80244: PUSH
80245: LD_VAR 0 1
80249: PPUSH
80250: CALL_OW 274
80254: ST_TO_ADDR
// if not pom then
80255: LD_VAR 0 4
80259: NOT
80260: IFFALSE 80264
// exit ;
80262: GO 80365
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80264: LD_ADDR_VAR 0 5
80268: PUSH
80269: LD_VAR 0 2
80273: PPUSH
80274: LD_VAR 0 1
80278: PPUSH
80279: CALL_OW 248
80283: PPUSH
80284: CALL_OW 450
80288: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80289: LD_ADDR_VAR 0 3
80293: PUSH
80294: LD_VAR 0 4
80298: PPUSH
80299: LD_INT 1
80301: PPUSH
80302: CALL_OW 275
80306: PUSH
80307: LD_VAR 0 5
80311: PUSH
80312: LD_INT 1
80314: ARRAY
80315: GREATEREQUAL
80316: PUSH
80317: LD_VAR 0 4
80321: PPUSH
80322: LD_INT 2
80324: PPUSH
80325: CALL_OW 275
80329: PUSH
80330: LD_VAR 0 5
80334: PUSH
80335: LD_INT 2
80337: ARRAY
80338: GREATEREQUAL
80339: AND
80340: PUSH
80341: LD_VAR 0 4
80345: PPUSH
80346: LD_INT 3
80348: PPUSH
80349: CALL_OW 275
80353: PUSH
80354: LD_VAR 0 5
80358: PUSH
80359: LD_INT 3
80361: ARRAY
80362: GREATEREQUAL
80363: AND
80364: ST_TO_ADDR
// end ;
80365: LD_VAR 0 3
80369: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
80370: LD_INT 0
80372: PPUSH
80373: PPUSH
80374: PPUSH
80375: PPUSH
80376: PPUSH
80377: PPUSH
80378: PPUSH
80379: PPUSH
80380: PPUSH
80381: PPUSH
80382: PPUSH
// result := false ;
80383: LD_ADDR_VAR 0 8
80387: PUSH
80388: LD_INT 0
80390: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
80391: LD_VAR 0 5
80395: NOT
80396: PUSH
80397: LD_VAR 0 1
80401: NOT
80402: OR
80403: PUSH
80404: LD_VAR 0 2
80408: NOT
80409: OR
80410: PUSH
80411: LD_VAR 0 3
80415: NOT
80416: OR
80417: IFFALSE 80421
// exit ;
80419: GO 81235
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
80421: LD_ADDR_VAR 0 14
80425: PUSH
80426: LD_VAR 0 1
80430: PPUSH
80431: LD_VAR 0 2
80435: PPUSH
80436: LD_VAR 0 3
80440: PPUSH
80441: LD_VAR 0 4
80445: PPUSH
80446: LD_VAR 0 5
80450: PUSH
80451: LD_INT 1
80453: ARRAY
80454: PPUSH
80455: CALL_OW 248
80459: PPUSH
80460: LD_INT 0
80462: PPUSH
80463: CALL 82468 0 6
80467: ST_TO_ADDR
// if not hexes then
80468: LD_VAR 0 14
80472: NOT
80473: IFFALSE 80477
// exit ;
80475: GO 81235
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
80477: LD_ADDR_VAR 0 17
80481: PUSH
80482: LD_VAR 0 5
80486: PPUSH
80487: LD_INT 22
80489: PUSH
80490: LD_VAR 0 13
80494: PPUSH
80495: CALL_OW 255
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PUSH
80504: LD_INT 2
80506: PUSH
80507: LD_INT 30
80509: PUSH
80510: LD_INT 0
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 30
80519: PUSH
80520: LD_INT 1
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: LIST
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PPUSH
80536: CALL_OW 72
80540: ST_TO_ADDR
// for i = 1 to hexes do
80541: LD_ADDR_VAR 0 9
80545: PUSH
80546: DOUBLE
80547: LD_INT 1
80549: DEC
80550: ST_TO_ADDR
80551: LD_VAR 0 14
80555: PUSH
80556: FOR_TO
80557: IFFALSE 81233
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80559: LD_ADDR_VAR 0 13
80563: PUSH
80564: LD_VAR 0 14
80568: PUSH
80569: LD_VAR 0 9
80573: ARRAY
80574: PUSH
80575: LD_INT 1
80577: ARRAY
80578: PPUSH
80579: LD_VAR 0 14
80583: PUSH
80584: LD_VAR 0 9
80588: ARRAY
80589: PUSH
80590: LD_INT 2
80592: ARRAY
80593: PPUSH
80594: CALL_OW 428
80598: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
80599: LD_VAR 0 14
80603: PUSH
80604: LD_VAR 0 9
80608: ARRAY
80609: PUSH
80610: LD_INT 1
80612: ARRAY
80613: PPUSH
80614: LD_VAR 0 14
80618: PUSH
80619: LD_VAR 0 9
80623: ARRAY
80624: PUSH
80625: LD_INT 2
80627: ARRAY
80628: PPUSH
80629: CALL_OW 351
80633: PUSH
80634: LD_VAR 0 14
80638: PUSH
80639: LD_VAR 0 9
80643: ARRAY
80644: PUSH
80645: LD_INT 1
80647: ARRAY
80648: PPUSH
80649: LD_VAR 0 14
80653: PUSH
80654: LD_VAR 0 9
80658: ARRAY
80659: PUSH
80660: LD_INT 2
80662: ARRAY
80663: PPUSH
80664: CALL_OW 488
80668: NOT
80669: OR
80670: PUSH
80671: LD_VAR 0 13
80675: PPUSH
80676: CALL_OW 247
80680: PUSH
80681: LD_INT 3
80683: EQUAL
80684: OR
80685: IFFALSE 80691
// exit ;
80687: POP
80688: POP
80689: GO 81235
// if not tmp then
80691: LD_VAR 0 13
80695: NOT
80696: IFFALSE 80700
// continue ;
80698: GO 80556
// result := true ;
80700: LD_ADDR_VAR 0 8
80704: PUSH
80705: LD_INT 1
80707: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
80708: LD_VAR 0 6
80712: PUSH
80713: LD_VAR 0 13
80717: PPUSH
80718: CALL_OW 247
80722: PUSH
80723: LD_INT 2
80725: EQUAL
80726: AND
80727: PUSH
80728: LD_VAR 0 13
80732: PPUSH
80733: CALL_OW 263
80737: PUSH
80738: LD_INT 1
80740: EQUAL
80741: AND
80742: IFFALSE 80906
// begin if IsDrivenBy ( tmp ) then
80744: LD_VAR 0 13
80748: PPUSH
80749: CALL_OW 311
80753: IFFALSE 80757
// continue ;
80755: GO 80556
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
80757: LD_VAR 0 6
80761: PPUSH
80762: LD_INT 3
80764: PUSH
80765: LD_INT 60
80767: PUSH
80768: EMPTY
80769: LIST
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 3
80777: PUSH
80778: LD_INT 55
80780: PUSH
80781: EMPTY
80782: LIST
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PPUSH
80792: CALL_OW 72
80796: IFFALSE 80904
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
80798: LD_ADDR_VAR 0 18
80802: PUSH
80803: LD_VAR 0 6
80807: PPUSH
80808: LD_INT 3
80810: PUSH
80811: LD_INT 60
80813: PUSH
80814: EMPTY
80815: LIST
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 3
80823: PUSH
80824: LD_INT 55
80826: PUSH
80827: EMPTY
80828: LIST
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PPUSH
80838: CALL_OW 72
80842: PUSH
80843: LD_INT 1
80845: ARRAY
80846: ST_TO_ADDR
// if IsInUnit ( driver ) then
80847: LD_VAR 0 18
80851: PPUSH
80852: CALL_OW 310
80856: IFFALSE 80867
// ComExit ( driver ) ;
80858: LD_VAR 0 18
80862: PPUSH
80863: CALL 106247 0 1
// AddComEnterUnit ( driver , tmp ) ;
80867: LD_VAR 0 18
80871: PPUSH
80872: LD_VAR 0 13
80876: PPUSH
80877: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
80881: LD_VAR 0 18
80885: PPUSH
80886: LD_VAR 0 7
80890: PPUSH
80891: CALL_OW 173
// AddComExitVehicle ( driver ) ;
80895: LD_VAR 0 18
80899: PPUSH
80900: CALL_OW 181
// end ; continue ;
80904: GO 80556
// end ; if not cleaners or not tmp in cleaners then
80906: LD_VAR 0 6
80910: NOT
80911: PUSH
80912: LD_VAR 0 13
80916: PUSH
80917: LD_VAR 0 6
80921: IN
80922: NOT
80923: OR
80924: IFFALSE 81231
// begin if dep then
80926: LD_VAR 0 17
80930: IFFALSE 81066
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
80932: LD_ADDR_VAR 0 16
80936: PUSH
80937: LD_VAR 0 17
80941: PUSH
80942: LD_INT 1
80944: ARRAY
80945: PPUSH
80946: CALL_OW 250
80950: PPUSH
80951: LD_VAR 0 17
80955: PUSH
80956: LD_INT 1
80958: ARRAY
80959: PPUSH
80960: CALL_OW 254
80964: PPUSH
80965: LD_INT 5
80967: PPUSH
80968: CALL_OW 272
80972: PUSH
80973: LD_VAR 0 17
80977: PUSH
80978: LD_INT 1
80980: ARRAY
80981: PPUSH
80982: CALL_OW 251
80986: PPUSH
80987: LD_VAR 0 17
80991: PUSH
80992: LD_INT 1
80994: ARRAY
80995: PPUSH
80996: CALL_OW 254
81000: PPUSH
81001: LD_INT 5
81003: PPUSH
81004: CALL_OW 273
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
81013: LD_VAR 0 16
81017: PUSH
81018: LD_INT 1
81020: ARRAY
81021: PPUSH
81022: LD_VAR 0 16
81026: PUSH
81027: LD_INT 2
81029: ARRAY
81030: PPUSH
81031: CALL_OW 488
81035: IFFALSE 81066
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
81037: LD_VAR 0 13
81041: PPUSH
81042: LD_VAR 0 16
81046: PUSH
81047: LD_INT 1
81049: ARRAY
81050: PPUSH
81051: LD_VAR 0 16
81055: PUSH
81056: LD_INT 2
81058: ARRAY
81059: PPUSH
81060: CALL_OW 111
// continue ;
81064: GO 80556
// end ; end ; r := GetDir ( tmp ) ;
81066: LD_ADDR_VAR 0 15
81070: PUSH
81071: LD_VAR 0 13
81075: PPUSH
81076: CALL_OW 254
81080: ST_TO_ADDR
// if r = 5 then
81081: LD_VAR 0 15
81085: PUSH
81086: LD_INT 5
81088: EQUAL
81089: IFFALSE 81099
// r := 0 ;
81091: LD_ADDR_VAR 0 15
81095: PUSH
81096: LD_INT 0
81098: ST_TO_ADDR
// for j = r to 5 do
81099: LD_ADDR_VAR 0 10
81103: PUSH
81104: DOUBLE
81105: LD_VAR 0 15
81109: DEC
81110: ST_TO_ADDR
81111: LD_INT 5
81113: PUSH
81114: FOR_TO
81115: IFFALSE 81229
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
81117: LD_ADDR_VAR 0 11
81121: PUSH
81122: LD_VAR 0 13
81126: PPUSH
81127: CALL_OW 250
81131: PPUSH
81132: LD_VAR 0 10
81136: PPUSH
81137: LD_INT 2
81139: PPUSH
81140: CALL_OW 272
81144: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
81145: LD_ADDR_VAR 0 12
81149: PUSH
81150: LD_VAR 0 13
81154: PPUSH
81155: CALL_OW 251
81159: PPUSH
81160: LD_VAR 0 10
81164: PPUSH
81165: LD_INT 2
81167: PPUSH
81168: CALL_OW 273
81172: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
81173: LD_VAR 0 11
81177: PPUSH
81178: LD_VAR 0 12
81182: PPUSH
81183: CALL_OW 488
81187: PUSH
81188: LD_VAR 0 11
81192: PPUSH
81193: LD_VAR 0 12
81197: PPUSH
81198: CALL_OW 428
81202: NOT
81203: AND
81204: IFFALSE 81227
// begin ComMoveXY ( tmp , _x , _y ) ;
81206: LD_VAR 0 13
81210: PPUSH
81211: LD_VAR 0 11
81215: PPUSH
81216: LD_VAR 0 12
81220: PPUSH
81221: CALL_OW 111
// break ;
81225: GO 81229
// end ; end ;
81227: GO 81114
81229: POP
81230: POP
// end ; end ;
81231: GO 80556
81233: POP
81234: POP
// end ;
81235: LD_VAR 0 8
81239: RET
// export function BuildingTechInvented ( side , btype ) ; begin
81240: LD_INT 0
81242: PPUSH
// result := true ;
81243: LD_ADDR_VAR 0 3
81247: PUSH
81248: LD_INT 1
81250: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
81251: LD_VAR 0 2
81255: PUSH
81256: LD_INT 24
81258: DOUBLE
81259: EQUAL
81260: IFTRUE 81270
81262: LD_INT 33
81264: DOUBLE
81265: EQUAL
81266: IFTRUE 81270
81268: GO 81295
81270: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
81271: LD_ADDR_VAR 0 3
81275: PUSH
81276: LD_INT 32
81278: PPUSH
81279: LD_VAR 0 1
81283: PPUSH
81284: CALL_OW 321
81288: PUSH
81289: LD_INT 2
81291: EQUAL
81292: ST_TO_ADDR
81293: GO 81611
81295: LD_INT 20
81297: DOUBLE
81298: EQUAL
81299: IFTRUE 81303
81301: GO 81328
81303: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
81304: LD_ADDR_VAR 0 3
81308: PUSH
81309: LD_INT 6
81311: PPUSH
81312: LD_VAR 0 1
81316: PPUSH
81317: CALL_OW 321
81321: PUSH
81322: LD_INT 2
81324: EQUAL
81325: ST_TO_ADDR
81326: GO 81611
81328: LD_INT 22
81330: DOUBLE
81331: EQUAL
81332: IFTRUE 81342
81334: LD_INT 36
81336: DOUBLE
81337: EQUAL
81338: IFTRUE 81342
81340: GO 81367
81342: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
81343: LD_ADDR_VAR 0 3
81347: PUSH
81348: LD_INT 15
81350: PPUSH
81351: LD_VAR 0 1
81355: PPUSH
81356: CALL_OW 321
81360: PUSH
81361: LD_INT 2
81363: EQUAL
81364: ST_TO_ADDR
81365: GO 81611
81367: LD_INT 30
81369: DOUBLE
81370: EQUAL
81371: IFTRUE 81375
81373: GO 81400
81375: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
81376: LD_ADDR_VAR 0 3
81380: PUSH
81381: LD_INT 20
81383: PPUSH
81384: LD_VAR 0 1
81388: PPUSH
81389: CALL_OW 321
81393: PUSH
81394: LD_INT 2
81396: EQUAL
81397: ST_TO_ADDR
81398: GO 81611
81400: LD_INT 28
81402: DOUBLE
81403: EQUAL
81404: IFTRUE 81414
81406: LD_INT 21
81408: DOUBLE
81409: EQUAL
81410: IFTRUE 81414
81412: GO 81439
81414: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
81415: LD_ADDR_VAR 0 3
81419: PUSH
81420: LD_INT 21
81422: PPUSH
81423: LD_VAR 0 1
81427: PPUSH
81428: CALL_OW 321
81432: PUSH
81433: LD_INT 2
81435: EQUAL
81436: ST_TO_ADDR
81437: GO 81611
81439: LD_INT 16
81441: DOUBLE
81442: EQUAL
81443: IFTRUE 81447
81445: GO 81472
81447: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
81448: LD_ADDR_VAR 0 3
81452: PUSH
81453: LD_INT 84
81455: PPUSH
81456: LD_VAR 0 1
81460: PPUSH
81461: CALL_OW 321
81465: PUSH
81466: LD_INT 2
81468: EQUAL
81469: ST_TO_ADDR
81470: GO 81611
81472: LD_INT 19
81474: DOUBLE
81475: EQUAL
81476: IFTRUE 81486
81478: LD_INT 23
81480: DOUBLE
81481: EQUAL
81482: IFTRUE 81486
81484: GO 81511
81486: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
81487: LD_ADDR_VAR 0 3
81491: PUSH
81492: LD_INT 83
81494: PPUSH
81495: LD_VAR 0 1
81499: PPUSH
81500: CALL_OW 321
81504: PUSH
81505: LD_INT 2
81507: EQUAL
81508: ST_TO_ADDR
81509: GO 81611
81511: LD_INT 17
81513: DOUBLE
81514: EQUAL
81515: IFTRUE 81519
81517: GO 81544
81519: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
81520: LD_ADDR_VAR 0 3
81524: PUSH
81525: LD_INT 39
81527: PPUSH
81528: LD_VAR 0 1
81532: PPUSH
81533: CALL_OW 321
81537: PUSH
81538: LD_INT 2
81540: EQUAL
81541: ST_TO_ADDR
81542: GO 81611
81544: LD_INT 18
81546: DOUBLE
81547: EQUAL
81548: IFTRUE 81552
81550: GO 81577
81552: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
81553: LD_ADDR_VAR 0 3
81557: PUSH
81558: LD_INT 40
81560: PPUSH
81561: LD_VAR 0 1
81565: PPUSH
81566: CALL_OW 321
81570: PUSH
81571: LD_INT 2
81573: EQUAL
81574: ST_TO_ADDR
81575: GO 81611
81577: LD_INT 27
81579: DOUBLE
81580: EQUAL
81581: IFTRUE 81585
81583: GO 81610
81585: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
81586: LD_ADDR_VAR 0 3
81590: PUSH
81591: LD_INT 35
81593: PPUSH
81594: LD_VAR 0 1
81598: PPUSH
81599: CALL_OW 321
81603: PUSH
81604: LD_INT 2
81606: EQUAL
81607: ST_TO_ADDR
81608: GO 81611
81610: POP
// end ;
81611: LD_VAR 0 3
81615: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
81616: LD_INT 0
81618: PPUSH
81619: PPUSH
81620: PPUSH
81621: PPUSH
81622: PPUSH
81623: PPUSH
81624: PPUSH
81625: PPUSH
81626: PPUSH
81627: PPUSH
81628: PPUSH
// result := false ;
81629: LD_ADDR_VAR 0 6
81633: PUSH
81634: LD_INT 0
81636: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
81637: LD_VAR 0 1
81641: NOT
81642: PUSH
81643: LD_VAR 0 1
81647: PPUSH
81648: CALL_OW 266
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: IN
81663: NOT
81664: OR
81665: PUSH
81666: LD_VAR 0 2
81670: NOT
81671: OR
81672: PUSH
81673: LD_VAR 0 5
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: LD_INT 1
81683: PUSH
81684: LD_INT 2
81686: PUSH
81687: LD_INT 3
81689: PUSH
81690: LD_INT 4
81692: PUSH
81693: LD_INT 5
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: IN
81704: NOT
81705: OR
81706: PUSH
81707: LD_VAR 0 3
81711: PPUSH
81712: LD_VAR 0 4
81716: PPUSH
81717: CALL_OW 488
81721: NOT
81722: OR
81723: IFFALSE 81727
// exit ;
81725: GO 82463
// side := GetSide ( depot ) ;
81727: LD_ADDR_VAR 0 9
81731: PUSH
81732: LD_VAR 0 1
81736: PPUSH
81737: CALL_OW 255
81741: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
81742: LD_VAR 0 9
81746: PPUSH
81747: LD_VAR 0 2
81751: PPUSH
81752: CALL 81240 0 2
81756: NOT
81757: IFFALSE 81761
// exit ;
81759: GO 82463
// pom := GetBase ( depot ) ;
81761: LD_ADDR_VAR 0 10
81765: PUSH
81766: LD_VAR 0 1
81770: PPUSH
81771: CALL_OW 274
81775: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
81776: LD_ADDR_VAR 0 11
81780: PUSH
81781: LD_VAR 0 2
81785: PPUSH
81786: LD_VAR 0 1
81790: PPUSH
81791: CALL_OW 248
81795: PPUSH
81796: CALL_OW 450
81800: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
81801: LD_VAR 0 10
81805: PPUSH
81806: LD_INT 1
81808: PPUSH
81809: CALL_OW 275
81813: PUSH
81814: LD_VAR 0 11
81818: PUSH
81819: LD_INT 1
81821: ARRAY
81822: GREATEREQUAL
81823: PUSH
81824: LD_VAR 0 10
81828: PPUSH
81829: LD_INT 2
81831: PPUSH
81832: CALL_OW 275
81836: PUSH
81837: LD_VAR 0 11
81841: PUSH
81842: LD_INT 2
81844: ARRAY
81845: GREATEREQUAL
81846: AND
81847: PUSH
81848: LD_VAR 0 10
81852: PPUSH
81853: LD_INT 3
81855: PPUSH
81856: CALL_OW 275
81860: PUSH
81861: LD_VAR 0 11
81865: PUSH
81866: LD_INT 3
81868: ARRAY
81869: GREATEREQUAL
81870: AND
81871: NOT
81872: IFFALSE 81876
// exit ;
81874: GO 82463
// if GetBType ( depot ) = b_depot then
81876: LD_VAR 0 1
81880: PPUSH
81881: CALL_OW 266
81885: PUSH
81886: LD_INT 0
81888: EQUAL
81889: IFFALSE 81901
// dist := 28 else
81891: LD_ADDR_VAR 0 14
81895: PUSH
81896: LD_INT 28
81898: ST_TO_ADDR
81899: GO 81909
// dist := 36 ;
81901: LD_ADDR_VAR 0 14
81905: PUSH
81906: LD_INT 36
81908: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
81909: LD_VAR 0 1
81913: PPUSH
81914: LD_VAR 0 3
81918: PPUSH
81919: LD_VAR 0 4
81923: PPUSH
81924: CALL_OW 297
81928: PUSH
81929: LD_VAR 0 14
81933: GREATER
81934: IFFALSE 81938
// exit ;
81936: GO 82463
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
81938: LD_ADDR_VAR 0 12
81942: PUSH
81943: LD_VAR 0 2
81947: PPUSH
81948: LD_VAR 0 3
81952: PPUSH
81953: LD_VAR 0 4
81957: PPUSH
81958: LD_VAR 0 5
81962: PPUSH
81963: LD_VAR 0 1
81967: PPUSH
81968: CALL_OW 248
81972: PPUSH
81973: LD_INT 0
81975: PPUSH
81976: CALL 82468 0 6
81980: ST_TO_ADDR
// if not hexes then
81981: LD_VAR 0 12
81985: NOT
81986: IFFALSE 81990
// exit ;
81988: GO 82463
// hex := GetHexInfo ( x , y ) ;
81990: LD_ADDR_VAR 0 15
81994: PUSH
81995: LD_VAR 0 3
81999: PPUSH
82000: LD_VAR 0 4
82004: PPUSH
82005: CALL_OW 546
82009: ST_TO_ADDR
// if hex [ 1 ] then
82010: LD_VAR 0 15
82014: PUSH
82015: LD_INT 1
82017: ARRAY
82018: IFFALSE 82022
// exit ;
82020: GO 82463
// height := hex [ 2 ] ;
82022: LD_ADDR_VAR 0 13
82026: PUSH
82027: LD_VAR 0 15
82031: PUSH
82032: LD_INT 2
82034: ARRAY
82035: ST_TO_ADDR
// for i = 1 to hexes do
82036: LD_ADDR_VAR 0 7
82040: PUSH
82041: DOUBLE
82042: LD_INT 1
82044: DEC
82045: ST_TO_ADDR
82046: LD_VAR 0 12
82050: PUSH
82051: FOR_TO
82052: IFFALSE 82382
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
82054: LD_VAR 0 12
82058: PUSH
82059: LD_VAR 0 7
82063: ARRAY
82064: PUSH
82065: LD_INT 1
82067: ARRAY
82068: PPUSH
82069: LD_VAR 0 12
82073: PUSH
82074: LD_VAR 0 7
82078: ARRAY
82079: PUSH
82080: LD_INT 2
82082: ARRAY
82083: PPUSH
82084: CALL_OW 488
82088: NOT
82089: PUSH
82090: LD_VAR 0 12
82094: PUSH
82095: LD_VAR 0 7
82099: ARRAY
82100: PUSH
82101: LD_INT 1
82103: ARRAY
82104: PPUSH
82105: LD_VAR 0 12
82109: PUSH
82110: LD_VAR 0 7
82114: ARRAY
82115: PUSH
82116: LD_INT 2
82118: ARRAY
82119: PPUSH
82120: CALL_OW 428
82124: PUSH
82125: LD_INT 0
82127: GREATER
82128: OR
82129: PUSH
82130: LD_VAR 0 12
82134: PUSH
82135: LD_VAR 0 7
82139: ARRAY
82140: PUSH
82141: LD_INT 1
82143: ARRAY
82144: PPUSH
82145: LD_VAR 0 12
82149: PUSH
82150: LD_VAR 0 7
82154: ARRAY
82155: PUSH
82156: LD_INT 2
82158: ARRAY
82159: PPUSH
82160: CALL_OW 351
82164: OR
82165: IFFALSE 82171
// exit ;
82167: POP
82168: POP
82169: GO 82463
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82171: LD_ADDR_VAR 0 8
82175: PUSH
82176: LD_VAR 0 12
82180: PUSH
82181: LD_VAR 0 7
82185: ARRAY
82186: PUSH
82187: LD_INT 1
82189: ARRAY
82190: PPUSH
82191: LD_VAR 0 12
82195: PUSH
82196: LD_VAR 0 7
82200: ARRAY
82201: PUSH
82202: LD_INT 2
82204: ARRAY
82205: PPUSH
82206: CALL_OW 546
82210: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
82211: LD_VAR 0 8
82215: PUSH
82216: LD_INT 1
82218: ARRAY
82219: PUSH
82220: LD_VAR 0 8
82224: PUSH
82225: LD_INT 2
82227: ARRAY
82228: PUSH
82229: LD_VAR 0 13
82233: PUSH
82234: LD_INT 2
82236: PLUS
82237: GREATER
82238: OR
82239: PUSH
82240: LD_VAR 0 8
82244: PUSH
82245: LD_INT 2
82247: ARRAY
82248: PUSH
82249: LD_VAR 0 13
82253: PUSH
82254: LD_INT 2
82256: MINUS
82257: LESS
82258: OR
82259: PUSH
82260: LD_VAR 0 8
82264: PUSH
82265: LD_INT 3
82267: ARRAY
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: LD_INT 8
82274: PUSH
82275: LD_INT 9
82277: PUSH
82278: LD_INT 10
82280: PUSH
82281: LD_INT 11
82283: PUSH
82284: LD_INT 12
82286: PUSH
82287: LD_INT 13
82289: PUSH
82290: LD_INT 16
82292: PUSH
82293: LD_INT 17
82295: PUSH
82296: LD_INT 18
82298: PUSH
82299: LD_INT 19
82301: PUSH
82302: LD_INT 20
82304: PUSH
82305: LD_INT 21
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: IN
82323: NOT
82324: OR
82325: PUSH
82326: LD_VAR 0 8
82330: PUSH
82331: LD_INT 5
82333: ARRAY
82334: NOT
82335: OR
82336: PUSH
82337: LD_VAR 0 8
82341: PUSH
82342: LD_INT 6
82344: ARRAY
82345: PUSH
82346: LD_INT 1
82348: PUSH
82349: LD_INT 2
82351: PUSH
82352: LD_INT 7
82354: PUSH
82355: LD_INT 9
82357: PUSH
82358: LD_INT 10
82360: PUSH
82361: LD_INT 11
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: LIST
82368: LIST
82369: LIST
82370: LIST
82371: IN
82372: NOT
82373: OR
82374: IFFALSE 82380
// exit ;
82376: POP
82377: POP
82378: GO 82463
// end ;
82380: GO 82051
82382: POP
82383: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
82384: LD_VAR 0 9
82388: PPUSH
82389: LD_VAR 0 3
82393: PPUSH
82394: LD_VAR 0 4
82398: PPUSH
82399: LD_INT 20
82401: PPUSH
82402: CALL 74415 0 4
82406: PUSH
82407: LD_INT 4
82409: ARRAY
82410: IFFALSE 82414
// exit ;
82412: GO 82463
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
82414: LD_VAR 0 2
82418: PUSH
82419: LD_INT 29
82421: PUSH
82422: LD_INT 30
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: IN
82429: PUSH
82430: LD_VAR 0 3
82434: PPUSH
82435: LD_VAR 0 4
82439: PPUSH
82440: LD_VAR 0 9
82444: PPUSH
82445: CALL_OW 440
82449: NOT
82450: AND
82451: IFFALSE 82455
// exit ;
82453: GO 82463
// result := true ;
82455: LD_ADDR_VAR 0 6
82459: PUSH
82460: LD_INT 1
82462: ST_TO_ADDR
// end ;
82463: LD_VAR 0 6
82467: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
82468: LD_INT 0
82470: PPUSH
82471: PPUSH
82472: PPUSH
82473: PPUSH
82474: PPUSH
82475: PPUSH
82476: PPUSH
82477: PPUSH
82478: PPUSH
82479: PPUSH
82480: PPUSH
82481: PPUSH
82482: PPUSH
82483: PPUSH
82484: PPUSH
82485: PPUSH
82486: PPUSH
82487: PPUSH
82488: PPUSH
82489: PPUSH
82490: PPUSH
82491: PPUSH
82492: PPUSH
82493: PPUSH
82494: PPUSH
82495: PPUSH
82496: PPUSH
82497: PPUSH
82498: PPUSH
82499: PPUSH
82500: PPUSH
82501: PPUSH
82502: PPUSH
82503: PPUSH
82504: PPUSH
82505: PPUSH
82506: PPUSH
82507: PPUSH
82508: PPUSH
82509: PPUSH
82510: PPUSH
82511: PPUSH
82512: PPUSH
82513: PPUSH
82514: PPUSH
82515: PPUSH
82516: PPUSH
82517: PPUSH
82518: PPUSH
82519: PPUSH
82520: PPUSH
82521: PPUSH
82522: PPUSH
82523: PPUSH
82524: PPUSH
82525: PPUSH
82526: PPUSH
82527: PPUSH
// result = [ ] ;
82528: LD_ADDR_VAR 0 7
82532: PUSH
82533: EMPTY
82534: ST_TO_ADDR
// temp_list = [ ] ;
82535: LD_ADDR_VAR 0 9
82539: PUSH
82540: EMPTY
82541: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
82542: LD_VAR 0 4
82546: PUSH
82547: LD_INT 0
82549: PUSH
82550: LD_INT 1
82552: PUSH
82553: LD_INT 2
82555: PUSH
82556: LD_INT 3
82558: PUSH
82559: LD_INT 4
82561: PUSH
82562: LD_INT 5
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: IN
82573: NOT
82574: PUSH
82575: LD_VAR 0 1
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: LD_INT 1
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: IN
82590: PUSH
82591: LD_VAR 0 5
82595: PUSH
82596: LD_INT 1
82598: PUSH
82599: LD_INT 2
82601: PUSH
82602: LD_INT 3
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: LIST
82609: IN
82610: NOT
82611: AND
82612: OR
82613: IFFALSE 82617
// exit ;
82615: GO 101008
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
82617: LD_VAR 0 1
82621: PUSH
82622: LD_INT 6
82624: PUSH
82625: LD_INT 7
82627: PUSH
82628: LD_INT 8
82630: PUSH
82631: LD_INT 13
82633: PUSH
82634: LD_INT 12
82636: PUSH
82637: LD_INT 15
82639: PUSH
82640: LD_INT 11
82642: PUSH
82643: LD_INT 14
82645: PUSH
82646: LD_INT 10
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: IN
82660: IFFALSE 82670
// btype = b_lab ;
82662: LD_ADDR_VAR 0 1
82666: PUSH
82667: LD_INT 6
82669: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
82670: LD_VAR 0 6
82674: PUSH
82675: LD_INT 0
82677: PUSH
82678: LD_INT 1
82680: PUSH
82681: LD_INT 2
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: LIST
82688: IN
82689: NOT
82690: PUSH
82691: LD_VAR 0 1
82695: PUSH
82696: LD_INT 0
82698: PUSH
82699: LD_INT 1
82701: PUSH
82702: LD_INT 2
82704: PUSH
82705: LD_INT 3
82707: PUSH
82708: LD_INT 6
82710: PUSH
82711: LD_INT 36
82713: PUSH
82714: LD_INT 4
82716: PUSH
82717: LD_INT 5
82719: PUSH
82720: LD_INT 31
82722: PUSH
82723: LD_INT 32
82725: PUSH
82726: LD_INT 33
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: IN
82742: NOT
82743: PUSH
82744: LD_VAR 0 6
82748: PUSH
82749: LD_INT 1
82751: EQUAL
82752: AND
82753: OR
82754: PUSH
82755: LD_VAR 0 1
82759: PUSH
82760: LD_INT 2
82762: PUSH
82763: LD_INT 3
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: IN
82770: NOT
82771: PUSH
82772: LD_VAR 0 6
82776: PUSH
82777: LD_INT 2
82779: EQUAL
82780: AND
82781: OR
82782: IFFALSE 82792
// mode = 0 ;
82784: LD_ADDR_VAR 0 6
82788: PUSH
82789: LD_INT 0
82791: ST_TO_ADDR
// case mode of 0 :
82792: LD_VAR 0 6
82796: PUSH
82797: LD_INT 0
82799: DOUBLE
82800: EQUAL
82801: IFTRUE 82805
82803: GO 94258
82805: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
82806: LD_ADDR_VAR 0 11
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 0
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 0
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 1
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: LD_INT 1
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: NEG
82865: PUSH
82866: LD_INT 0
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: LD_INT 1
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 1
82887: NEG
82888: PUSH
82889: LD_INT 2
82891: NEG
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 0
82899: PUSH
82900: LD_INT 2
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: PUSH
82911: LD_INT 1
82913: NEG
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PUSH
82919: LD_INT 1
82921: PUSH
82922: LD_INT 2
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 0
82931: PUSH
82932: LD_INT 2
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 1
82941: NEG
82942: PUSH
82943: LD_INT 1
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 1
82952: PUSH
82953: LD_INT 3
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: LD_INT 3
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 1
82972: NEG
82973: PUSH
82974: LD_INT 2
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: EMPTY
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82999: LD_ADDR_VAR 0 12
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 0
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 0
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: LD_INT 1
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: NEG
83058: PUSH
83059: LD_INT 0
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 1
83068: NEG
83069: PUSH
83070: LD_INT 1
83072: NEG
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: LD_INT 1
83080: PUSH
83081: LD_INT 1
83083: NEG
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: PUSH
83089: LD_INT 2
83091: PUSH
83092: LD_INT 0
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: LD_INT 1
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 1
83111: NEG
83112: PUSH
83113: LD_INT 1
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 2
83122: NEG
83123: PUSH
83124: LD_INT 0
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 2
83133: NEG
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 2
83145: NEG
83146: PUSH
83147: LD_INT 1
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 3
83156: NEG
83157: PUSH
83158: LD_INT 0
83160: PUSH
83161: EMPTY
83162: LIST
83163: LIST
83164: PUSH
83165: LD_INT 3
83167: NEG
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: LIST
83185: LIST
83186: LIST
83187: LIST
83188: LIST
83189: LIST
83190: LIST
83191: LIST
83192: LIST
83193: LIST
83194: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83195: LD_ADDR_VAR 0 13
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: LD_INT 1
83215: NEG
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 1
83223: PUSH
83224: LD_INT 0
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 1
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 0
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 1
83253: NEG
83254: PUSH
83255: LD_INT 0
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 1
83264: NEG
83265: PUSH
83266: LD_INT 1
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: NEG
83277: PUSH
83278: LD_INT 2
83280: NEG
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: PUSH
83286: LD_INT 2
83288: PUSH
83289: LD_INT 1
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: PUSH
83299: LD_INT 2
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: PUSH
83309: LD_INT 2
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 2
83318: NEG
83319: PUSH
83320: LD_INT 1
83322: NEG
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: NEG
83331: PUSH
83332: LD_INT 2
83334: NEG
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 2
83342: NEG
83343: PUSH
83344: LD_INT 3
83346: NEG
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 3
83354: NEG
83355: PUSH
83356: LD_INT 2
83358: NEG
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 3
83366: NEG
83367: PUSH
83368: LD_INT 3
83370: NEG
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83394: LD_ADDR_VAR 0 14
83398: PUSH
83399: LD_INT 0
83401: PUSH
83402: LD_INT 0
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: PUSH
83409: LD_INT 0
83411: PUSH
83412: LD_INT 1
83414: NEG
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 1
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 1
83432: PUSH
83433: LD_INT 1
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 0
83442: PUSH
83443: LD_INT 1
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: NEG
83453: PUSH
83454: LD_INT 0
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: NEG
83476: PUSH
83477: LD_INT 2
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 0
83487: PUSH
83488: LD_INT 2
83490: NEG
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 1
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 1
83509: PUSH
83510: LD_INT 2
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 0
83519: PUSH
83520: LD_INT 2
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PUSH
83527: LD_INT 1
83529: NEG
83530: PUSH
83531: LD_INT 1
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: LD_INT 1
83540: NEG
83541: PUSH
83542: LD_INT 3
83544: NEG
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 0
83552: PUSH
83553: LD_INT 3
83555: NEG
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 1
83563: PUSH
83564: LD_INT 2
83566: NEG
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83590: LD_ADDR_VAR 0 15
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: LD_INT 0
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: LD_INT 1
83610: NEG
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: PUSH
83619: LD_INT 0
83621: PUSH
83622: EMPTY
83623: LIST
83624: LIST
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: LD_INT 1
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: LD_INT 1
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: LD_INT 0
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 1
83659: NEG
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: PUSH
83672: LD_INT 1
83674: NEG
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: LD_INT 1
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 1
83702: NEG
83703: PUSH
83704: LD_INT 1
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 2
83713: NEG
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 2
83724: NEG
83725: PUSH
83726: LD_INT 1
83728: NEG
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 2
83736: PUSH
83737: LD_INT 1
83739: NEG
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 3
83747: PUSH
83748: LD_INT 0
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 3
83757: PUSH
83758: LD_INT 1
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: LIST
83781: LIST
83782: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83783: LD_ADDR_VAR 0 16
83787: PUSH
83788: LD_INT 0
83790: PUSH
83791: LD_INT 0
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PUSH
83798: LD_INT 0
83800: PUSH
83801: LD_INT 1
83803: NEG
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 1
83811: PUSH
83812: LD_INT 0
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 1
83821: PUSH
83822: LD_INT 1
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PUSH
83829: LD_INT 0
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 1
83841: NEG
83842: PUSH
83843: LD_INT 0
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PUSH
83850: LD_INT 1
83852: NEG
83853: PUSH
83854: LD_INT 1
83856: NEG
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 1
83864: NEG
83865: PUSH
83866: LD_INT 2
83868: NEG
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: LD_INT 2
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 2
83886: PUSH
83887: LD_INT 2
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: LD_INT 2
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 2
83906: NEG
83907: PUSH
83908: LD_INT 1
83910: NEG
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 2
83918: NEG
83919: PUSH
83920: LD_INT 2
83922: NEG
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 3
83930: PUSH
83931: LD_INT 2
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 3
83940: PUSH
83941: LD_INT 3
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 2
83950: PUSH
83951: LD_INT 3
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83976: LD_ADDR_VAR 0 17
83980: PUSH
83981: LD_INT 0
83983: PUSH
83984: LD_INT 0
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: LD_INT 0
83993: PUSH
83994: LD_INT 1
83996: NEG
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 1
84004: PUSH
84005: LD_INT 0
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 1
84014: PUSH
84015: LD_INT 1
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 0
84024: PUSH
84025: LD_INT 1
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: PUSH
84032: LD_INT 1
84034: NEG
84035: PUSH
84036: LD_INT 0
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 1
84045: NEG
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: LD_INT 2
84061: NEG
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 0
84069: PUSH
84070: LD_INT 2
84072: NEG
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 1
84080: PUSH
84081: LD_INT 1
84083: NEG
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: PUSH
84089: LD_INT 2
84091: PUSH
84092: LD_INT 0
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 2
84101: PUSH
84102: LD_INT 1
84104: PUSH
84105: EMPTY
84106: LIST
84107: LIST
84108: PUSH
84109: LD_INT 2
84111: PUSH
84112: LD_INT 2
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 1
84121: PUSH
84122: LD_INT 2
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 2
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 1
84141: NEG
84142: PUSH
84143: LD_INT 1
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 2
84152: NEG
84153: PUSH
84154: LD_INT 0
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: LD_INT 2
84163: NEG
84164: PUSH
84165: LD_INT 1
84167: NEG
84168: PUSH
84169: EMPTY
84170: LIST
84171: LIST
84172: PUSH
84173: LD_INT 2
84175: NEG
84176: PUSH
84177: LD_INT 2
84179: NEG
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84206: LD_ADDR_VAR 0 18
84210: PUSH
84211: LD_INT 0
84213: PUSH
84214: LD_INT 0
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: LD_INT 0
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: PUSH
84232: LD_INT 1
84234: PUSH
84235: LD_INT 0
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: PUSH
84242: LD_INT 1
84244: PUSH
84245: LD_INT 1
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 0
84254: PUSH
84255: LD_INT 1
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: LD_INT 0
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: LD_INT 1
84275: NEG
84276: PUSH
84277: LD_INT 1
84279: NEG
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 1
84287: NEG
84288: PUSH
84289: LD_INT 2
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 0
84299: PUSH
84300: LD_INT 2
84302: NEG
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 1
84310: PUSH
84311: LD_INT 1
84313: NEG
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 2
84321: PUSH
84322: LD_INT 0
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: LD_INT 2
84331: PUSH
84332: LD_INT 1
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PUSH
84339: LD_INT 2
84341: PUSH
84342: LD_INT 2
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 1
84351: PUSH
84352: LD_INT 2
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 0
84361: PUSH
84362: LD_INT 2
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: NEG
84372: PUSH
84373: LD_INT 1
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 2
84382: NEG
84383: PUSH
84384: LD_INT 0
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 2
84393: NEG
84394: PUSH
84395: LD_INT 1
84397: NEG
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 2
84405: NEG
84406: PUSH
84407: LD_INT 2
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84436: LD_ADDR_VAR 0 19
84440: PUSH
84441: LD_INT 0
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 0
84453: PUSH
84454: LD_INT 1
84456: NEG
84457: PUSH
84458: EMPTY
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 1
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: PUSH
84472: LD_INT 1
84474: PUSH
84475: LD_INT 1
84477: PUSH
84478: EMPTY
84479: LIST
84480: LIST
84481: PUSH
84482: LD_INT 0
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 1
84494: NEG
84495: PUSH
84496: LD_INT 0
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: LD_INT 1
84505: NEG
84506: PUSH
84507: LD_INT 1
84509: NEG
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: LD_INT 2
84521: NEG
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 0
84529: PUSH
84530: LD_INT 2
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 2
84551: PUSH
84552: LD_INT 0
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 2
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 2
84571: PUSH
84572: LD_INT 2
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: LD_INT 2
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 1
84601: NEG
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 2
84612: NEG
84613: PUSH
84614: LD_INT 0
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 2
84623: NEG
84624: PUSH
84625: LD_INT 1
84627: NEG
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 2
84635: NEG
84636: PUSH
84637: LD_INT 2
84639: NEG
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84666: LD_ADDR_VAR 0 20
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: LD_INT 1
84686: NEG
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: PUSH
84695: LD_INT 0
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 0
84714: PUSH
84715: LD_INT 1
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 1
84724: NEG
84725: PUSH
84726: LD_INT 0
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 1
84735: NEG
84736: PUSH
84737: LD_INT 1
84739: NEG
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: LD_INT 2
84751: NEG
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 0
84759: PUSH
84760: LD_INT 2
84762: NEG
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 1
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 2
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 2
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 2
84801: PUSH
84802: LD_INT 2
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: LD_INT 1
84811: PUSH
84812: LD_INT 2
84814: PUSH
84815: EMPTY
84816: LIST
84817: LIST
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: LD_INT 2
84824: PUSH
84825: EMPTY
84826: LIST
84827: LIST
84828: PUSH
84829: LD_INT 1
84831: NEG
84832: PUSH
84833: LD_INT 1
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 2
84842: NEG
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 2
84853: NEG
84854: PUSH
84855: LD_INT 1
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84896: LD_ADDR_VAR 0 21
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: LD_INT 0
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 0
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 1
84924: PUSH
84925: LD_INT 0
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 1
84934: PUSH
84935: LD_INT 1
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 0
84944: PUSH
84945: LD_INT 1
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: LD_INT 0
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: PUSH
84963: LD_INT 1
84965: NEG
84966: PUSH
84967: LD_INT 1
84969: NEG
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: NEG
84978: PUSH
84979: LD_INT 2
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 0
84989: PUSH
84990: LD_INT 2
84992: NEG
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: PUSH
85001: LD_INT 1
85003: NEG
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 2
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 2
85021: PUSH
85022: LD_INT 1
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 2
85031: PUSH
85032: LD_INT 2
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 1
85041: PUSH
85042: LD_INT 2
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: LD_INT 0
85051: PUSH
85052: LD_INT 2
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 1
85061: NEG
85062: PUSH
85063: LD_INT 1
85065: PUSH
85066: EMPTY
85067: LIST
85068: LIST
85069: PUSH
85070: LD_INT 2
85072: NEG
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 2
85083: NEG
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_INT 2
85095: NEG
85096: PUSH
85097: LD_INT 2
85099: NEG
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85126: LD_ADDR_VAR 0 22
85130: PUSH
85131: LD_INT 0
85133: PUSH
85134: LD_INT 0
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: PUSH
85155: LD_INT 0
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: PUSH
85165: LD_INT 1
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 0
85174: PUSH
85175: LD_INT 1
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 1
85184: NEG
85185: PUSH
85186: LD_INT 0
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 1
85195: NEG
85196: PUSH
85197: LD_INT 1
85199: NEG
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 1
85207: NEG
85208: PUSH
85209: LD_INT 2
85211: NEG
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: PUSH
85217: LD_INT 0
85219: PUSH
85220: LD_INT 2
85222: NEG
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 2
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 2
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: LD_INT 2
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 1
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 0
85281: PUSH
85282: LD_INT 2
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 1
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 2
85302: NEG
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 2
85313: NEG
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 2
85325: NEG
85326: PUSH
85327: LD_INT 2
85329: NEG
85330: PUSH
85331: EMPTY
85332: LIST
85333: LIST
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: LIST
85339: LIST
85340: LIST
85341: LIST
85342: LIST
85343: LIST
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
85356: LD_ADDR_VAR 0 23
85360: PUSH
85361: LD_INT 0
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 0
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: EMPTY
85379: LIST
85380: LIST
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: LD_INT 0
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: LD_INT 1
85394: PUSH
85395: LD_INT 1
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: PUSH
85402: LD_INT 0
85404: PUSH
85405: LD_INT 1
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: NEG
85415: PUSH
85416: LD_INT 0
85418: PUSH
85419: EMPTY
85420: LIST
85421: LIST
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: LD_INT 1
85429: NEG
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: PUSH
85435: LD_INT 1
85437: NEG
85438: PUSH
85439: LD_INT 2
85441: NEG
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 0
85449: PUSH
85450: LD_INT 2
85452: NEG
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 1
85460: PUSH
85461: LD_INT 1
85463: NEG
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: LD_INT 2
85471: PUSH
85472: LD_INT 0
85474: PUSH
85475: EMPTY
85476: LIST
85477: LIST
85478: PUSH
85479: LD_INT 2
85481: PUSH
85482: LD_INT 1
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PUSH
85489: LD_INT 2
85491: PUSH
85492: LD_INT 2
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 1
85501: PUSH
85502: LD_INT 2
85504: PUSH
85505: EMPTY
85506: LIST
85507: LIST
85508: PUSH
85509: LD_INT 0
85511: PUSH
85512: LD_INT 2
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: PUSH
85519: LD_INT 1
85521: NEG
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 2
85532: NEG
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 2
85543: NEG
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 2
85555: NEG
85556: PUSH
85557: LD_INT 2
85559: NEG
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PUSH
85565: LD_INT 2
85567: NEG
85568: PUSH
85569: LD_INT 3
85571: NEG
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 1
85579: NEG
85580: PUSH
85581: LD_INT 3
85583: NEG
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 1
85591: PUSH
85592: LD_INT 2
85594: NEG
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 2
85602: PUSH
85603: LD_INT 1
85605: NEG
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: LIST
85618: LIST
85619: LIST
85620: LIST
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: LIST
85631: LIST
85632: LIST
85633: LIST
85634: LIST
85635: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
85636: LD_ADDR_VAR 0 24
85640: PUSH
85641: LD_INT 0
85643: PUSH
85644: LD_INT 0
85646: PUSH
85647: EMPTY
85648: LIST
85649: LIST
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: LD_INT 1
85656: NEG
85657: PUSH
85658: EMPTY
85659: LIST
85660: LIST
85661: PUSH
85662: LD_INT 1
85664: PUSH
85665: LD_INT 0
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 1
85674: PUSH
85675: LD_INT 1
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 0
85684: PUSH
85685: LD_INT 1
85687: PUSH
85688: EMPTY
85689: LIST
85690: LIST
85691: PUSH
85692: LD_INT 1
85694: NEG
85695: PUSH
85696: LD_INT 0
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 1
85705: NEG
85706: PUSH
85707: LD_INT 1
85709: NEG
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 1
85717: NEG
85718: PUSH
85719: LD_INT 2
85721: NEG
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 0
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 1
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 2
85751: PUSH
85752: LD_INT 0
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 2
85761: PUSH
85762: LD_INT 1
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 2
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: PUSH
85782: LD_INT 2
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 0
85791: PUSH
85792: LD_INT 2
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: NEG
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 2
85812: NEG
85813: PUSH
85814: LD_INT 0
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: LD_INT 2
85823: NEG
85824: PUSH
85825: LD_INT 1
85827: NEG
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 2
85835: NEG
85836: PUSH
85837: LD_INT 2
85839: NEG
85840: PUSH
85841: EMPTY
85842: LIST
85843: LIST
85844: PUSH
85845: LD_INT 1
85847: PUSH
85848: LD_INT 2
85850: NEG
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 2
85858: PUSH
85859: LD_INT 1
85861: NEG
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 3
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 3
85879: PUSH
85880: LD_INT 2
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
85912: LD_ADDR_VAR 0 25
85916: PUSH
85917: LD_INT 0
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 0
85929: PUSH
85930: LD_INT 1
85932: NEG
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 1
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 1
85950: PUSH
85951: LD_INT 1
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 0
85960: PUSH
85961: LD_INT 1
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: PUSH
85968: LD_INT 1
85970: NEG
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: EMPTY
85976: LIST
85977: LIST
85978: PUSH
85979: LD_INT 1
85981: NEG
85982: PUSH
85983: LD_INT 1
85985: NEG
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 1
85993: NEG
85994: PUSH
85995: LD_INT 2
85997: NEG
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 0
86005: PUSH
86006: LD_INT 2
86008: NEG
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: LD_INT 1
86019: NEG
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 2
86027: PUSH
86028: LD_INT 0
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 2
86037: PUSH
86038: LD_INT 1
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: LD_INT 2
86047: PUSH
86048: LD_INT 2
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 1
86057: PUSH
86058: LD_INT 2
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 0
86067: PUSH
86068: LD_INT 2
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 1
86077: NEG
86078: PUSH
86079: LD_INT 1
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: PUSH
86086: LD_INT 2
86088: NEG
86089: PUSH
86090: LD_INT 0
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PUSH
86097: LD_INT 2
86099: NEG
86100: PUSH
86101: LD_INT 1
86103: NEG
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 2
86111: NEG
86112: PUSH
86113: LD_INT 2
86115: NEG
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 3
86123: PUSH
86124: LD_INT 1
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 3
86133: PUSH
86134: LD_INT 2
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 2
86143: PUSH
86144: LD_INT 3
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 1
86153: PUSH
86154: LD_INT 3
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
86186: LD_ADDR_VAR 0 26
86190: PUSH
86191: LD_INT 0
86193: PUSH
86194: LD_INT 0
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 0
86203: PUSH
86204: LD_INT 1
86206: NEG
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 1
86214: PUSH
86215: LD_INT 0
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: LD_INT 1
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 1
86244: NEG
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 1
86267: NEG
86268: PUSH
86269: LD_INT 2
86271: NEG
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: LD_INT 2
86282: NEG
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 1
86290: PUSH
86291: LD_INT 1
86293: NEG
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 2
86301: PUSH
86302: LD_INT 0
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: LD_INT 2
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 1
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: LD_INT 2
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 1
86351: NEG
86352: PUSH
86353: LD_INT 1
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 2
86362: NEG
86363: PUSH
86364: LD_INT 0
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 2
86373: NEG
86374: PUSH
86375: LD_INT 1
86377: NEG
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 2
86385: NEG
86386: PUSH
86387: LD_INT 2
86389: NEG
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 2
86397: PUSH
86398: LD_INT 3
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: LD_INT 3
86410: PUSH
86411: EMPTY
86412: LIST
86413: LIST
86414: PUSH
86415: LD_INT 1
86417: NEG
86418: PUSH
86419: LD_INT 2
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 2
86428: NEG
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: LIST
86453: LIST
86454: LIST
86455: LIST
86456: LIST
86457: LIST
86458: LIST
86459: LIST
86460: LIST
86461: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86462: LD_ADDR_VAR 0 27
86466: PUSH
86467: LD_INT 0
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 0
86479: PUSH
86480: LD_INT 1
86482: NEG
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: LD_INT 0
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 1
86500: PUSH
86501: LD_INT 1
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 0
86510: PUSH
86511: LD_INT 1
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 1
86520: NEG
86521: PUSH
86522: LD_INT 0
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: LD_INT 1
86535: NEG
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 1
86543: NEG
86544: PUSH
86545: LD_INT 2
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 0
86555: PUSH
86556: LD_INT 2
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: LD_INT 1
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 2
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 2
86587: PUSH
86588: LD_INT 1
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 2
86597: PUSH
86598: LD_INT 2
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: LD_INT 2
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 0
86617: PUSH
86618: LD_INT 2
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PUSH
86625: LD_INT 1
86627: NEG
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 2
86638: NEG
86639: PUSH
86640: LD_INT 0
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 2
86649: NEG
86650: PUSH
86651: LD_INT 1
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 2
86661: NEG
86662: PUSH
86663: LD_INT 2
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 1
86673: NEG
86674: PUSH
86675: LD_INT 2
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 2
86684: NEG
86685: PUSH
86686: LD_INT 1
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 3
86695: NEG
86696: PUSH
86697: LD_INT 1
86699: NEG
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 3
86707: NEG
86708: PUSH
86709: LD_INT 2
86711: NEG
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86742: LD_ADDR_VAR 0 28
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: LD_INT 1
86762: NEG
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 1
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: PUSH
86788: LD_INT 0
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 1
86800: NEG
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 1
86811: NEG
86812: PUSH
86813: LD_INT 1
86815: NEG
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 1
86823: NEG
86824: PUSH
86825: LD_INT 2
86827: NEG
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 0
86835: PUSH
86836: LD_INT 2
86838: NEG
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: PUSH
86844: LD_INT 1
86846: PUSH
86847: LD_INT 1
86849: NEG
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: PUSH
86855: LD_INT 2
86857: PUSH
86858: LD_INT 0
86860: PUSH
86861: EMPTY
86862: LIST
86863: LIST
86864: PUSH
86865: LD_INT 2
86867: PUSH
86868: LD_INT 1
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PUSH
86875: LD_INT 2
86877: PUSH
86878: LD_INT 2
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 1
86887: PUSH
86888: LD_INT 2
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: LD_INT 2
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 1
86907: NEG
86908: PUSH
86909: LD_INT 1
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 2
86918: NEG
86919: PUSH
86920: LD_INT 0
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 2
86929: NEG
86930: PUSH
86931: LD_INT 1
86933: NEG
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 2
86941: NEG
86942: PUSH
86943: LD_INT 2
86945: NEG
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 2
86953: NEG
86954: PUSH
86955: LD_INT 3
86957: NEG
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 1
86965: NEG
86966: PUSH
86967: LD_INT 3
86969: NEG
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 3
86977: NEG
86978: PUSH
86979: LD_INT 1
86981: NEG
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 3
86989: NEG
86990: PUSH
86991: LD_INT 2
86993: NEG
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87024: LD_ADDR_VAR 0 29
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: LD_INT 1
87044: NEG
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 0
87072: PUSH
87073: LD_INT 1
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 1
87093: NEG
87094: PUSH
87095: LD_INT 1
87097: NEG
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: LD_INT 2
87109: NEG
87110: PUSH
87111: EMPTY
87112: LIST
87113: LIST
87114: PUSH
87115: LD_INT 0
87117: PUSH
87118: LD_INT 2
87120: NEG
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 1
87128: PUSH
87129: LD_INT 1
87131: NEG
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 2
87139: PUSH
87140: LD_INT 0
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 2
87149: PUSH
87150: LD_INT 1
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 1
87159: PUSH
87160: LD_INT 2
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 2
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: LD_INT 1
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 2
87190: NEG
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 2
87202: NEG
87203: PUSH
87204: LD_INT 2
87206: NEG
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 2
87214: NEG
87215: PUSH
87216: LD_INT 3
87218: NEG
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 2
87226: PUSH
87227: LD_INT 1
87229: NEG
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 3
87237: PUSH
87238: LD_INT 1
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: PUSH
87248: LD_INT 3
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: NEG
87258: PUSH
87259: LD_INT 2
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 3
87268: NEG
87269: PUSH
87270: LD_INT 2
87272: NEG
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: LIST
87291: LIST
87292: LIST
87293: LIST
87294: LIST
87295: LIST
87296: LIST
87297: LIST
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87303: LD_ADDR_VAR 0 30
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: LD_INT 0
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 0
87320: PUSH
87321: LD_INT 1
87323: NEG
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: PUSH
87332: LD_INT 0
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: LD_INT 1
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: LD_INT 1
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 1
87361: NEG
87362: PUSH
87363: LD_INT 0
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: LD_INT 1
87376: NEG
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 1
87384: NEG
87385: PUSH
87386: LD_INT 2
87388: NEG
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: LD_INT 2
87399: NEG
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 1
87407: PUSH
87408: LD_INT 1
87410: NEG
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 2
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 2
87438: PUSH
87439: LD_INT 2
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: PUSH
87446: LD_INT 1
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 1
87458: NEG
87459: PUSH
87460: LD_INT 1
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 2
87469: NEG
87470: PUSH
87471: LD_INT 0
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 2
87480: NEG
87481: PUSH
87482: LD_INT 1
87484: NEG
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 1
87492: NEG
87493: PUSH
87494: LD_INT 3
87496: NEG
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 2
87507: NEG
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 3
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 2
87525: PUSH
87526: LD_INT 3
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 2
87535: NEG
87536: PUSH
87537: LD_INT 1
87539: PUSH
87540: EMPTY
87541: LIST
87542: LIST
87543: PUSH
87544: LD_INT 3
87546: NEG
87547: PUSH
87548: LD_INT 1
87550: NEG
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87581: LD_ADDR_VAR 0 31
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: LD_INT 0
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 0
87598: PUSH
87599: LD_INT 1
87601: NEG
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: PUSH
87610: LD_INT 0
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 1
87619: PUSH
87620: LD_INT 1
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 0
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 1
87639: NEG
87640: PUSH
87641: LD_INT 0
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: LD_INT 1
87654: NEG
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 1
87662: NEG
87663: PUSH
87664: LD_INT 2
87666: NEG
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 1
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 2
87685: PUSH
87686: LD_INT 0
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: PUSH
87693: LD_INT 2
87695: PUSH
87696: LD_INT 1
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 2
87705: PUSH
87706: LD_INT 2
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 1
87715: PUSH
87716: LD_INT 2
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 0
87725: PUSH
87726: LD_INT 2
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: LD_INT 1
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 2
87746: NEG
87747: PUSH
87748: LD_INT 1
87750: NEG
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 2
87758: NEG
87759: PUSH
87760: LD_INT 2
87762: NEG
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 2
87770: NEG
87771: PUSH
87772: LD_INT 3
87774: NEG
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 2
87782: PUSH
87783: LD_INT 1
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 3
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 1
87803: PUSH
87804: LD_INT 3
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 2
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 3
87824: NEG
87825: PUSH
87826: LD_INT 2
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87859: LD_ADDR_VAR 0 32
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: LD_INT 1
87879: NEG
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PUSH
87885: LD_INT 1
87887: PUSH
87888: LD_INT 0
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 1
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: LD_INT 1
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 1
87917: NEG
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 1
87928: NEG
87929: PUSH
87930: LD_INT 1
87932: NEG
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 1
87940: NEG
87941: PUSH
87942: LD_INT 2
87944: NEG
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 0
87952: PUSH
87953: LD_INT 2
87955: NEG
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: LD_INT 1
87966: NEG
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 2
87974: PUSH
87975: LD_INT 1
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 2
87984: PUSH
87985: LD_INT 2
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 1
87994: PUSH
87995: LD_INT 2
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_INT 2
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: LD_INT 1
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 2
88025: NEG
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 2
88036: NEG
88037: PUSH
88038: LD_INT 1
88040: NEG
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 1
88048: NEG
88049: PUSH
88050: LD_INT 3
88052: NEG
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 1
88060: PUSH
88061: LD_INT 2
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 3
88071: PUSH
88072: LD_INT 2
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PUSH
88079: LD_INT 2
88081: PUSH
88082: LD_INT 3
88084: PUSH
88085: EMPTY
88086: LIST
88087: LIST
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: LD_INT 1
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 3
88102: NEG
88103: PUSH
88104: LD_INT 1
88106: NEG
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88137: LD_ADDR_VAR 0 33
88141: PUSH
88142: LD_INT 0
88144: PUSH
88145: LD_INT 0
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 0
88154: PUSH
88155: LD_INT 1
88157: NEG
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: LD_INT 0
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: LD_INT 1
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 0
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 1
88195: NEG
88196: PUSH
88197: LD_INT 0
88199: PUSH
88200: EMPTY
88201: LIST
88202: LIST
88203: PUSH
88204: LD_INT 1
88206: NEG
88207: PUSH
88208: LD_INT 1
88210: NEG
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 2
88222: NEG
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: PUSH
88231: LD_INT 1
88233: NEG
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 2
88241: PUSH
88242: LD_INT 0
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 2
88251: PUSH
88252: LD_INT 1
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 1
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 0
88271: PUSH
88272: LD_INT 2
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: LD_INT 1
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 2
88292: NEG
88293: PUSH
88294: LD_INT 0
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: NEG
88304: PUSH
88305: LD_INT 1
88307: NEG
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 2
88315: NEG
88316: PUSH
88317: LD_INT 2
88319: NEG
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: LD_INT 2
88327: NEG
88328: PUSH
88329: LD_INT 3
88331: NEG
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: LD_INT 1
88342: NEG
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 3
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 1
88360: PUSH
88361: LD_INT 3
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 1
88370: NEG
88371: PUSH
88372: LD_INT 2
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 3
88381: NEG
88382: PUSH
88383: LD_INT 2
88385: NEG
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88416: LD_ADDR_VAR 0 34
88420: PUSH
88421: LD_INT 0
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 0
88433: PUSH
88434: LD_INT 1
88436: NEG
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 1
88444: PUSH
88445: LD_INT 0
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 1
88454: PUSH
88455: LD_INT 1
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 0
88464: PUSH
88465: LD_INT 1
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: LD_INT 0
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 1
88485: NEG
88486: PUSH
88487: LD_INT 1
88489: NEG
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 1
88497: NEG
88498: PUSH
88499: LD_INT 2
88501: NEG
88502: PUSH
88503: EMPTY
88504: LIST
88505: LIST
88506: PUSH
88507: LD_INT 0
88509: PUSH
88510: LD_INT 2
88512: NEG
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 1
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: EMPTY
88526: LIST
88527: LIST
88528: PUSH
88529: LD_INT 2
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 2
88541: PUSH
88542: LD_INT 2
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 1
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: LD_INT 1
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 2
88572: NEG
88573: PUSH
88574: LD_INT 0
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 2
88583: NEG
88584: PUSH
88585: LD_INT 1
88587: NEG
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 2
88595: NEG
88596: PUSH
88597: LD_INT 2
88599: NEG
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: LD_INT 3
88611: NEG
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 1
88619: PUSH
88620: LD_INT 2
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 3
88630: PUSH
88631: LD_INT 2
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 2
88640: PUSH
88641: LD_INT 3
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 2
88650: NEG
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 3
88661: NEG
88662: PUSH
88663: LD_INT 1
88665: NEG
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
88696: LD_ADDR_VAR 0 35
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 1
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: LD_INT 1
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 1
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 1
88754: NEG
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: LD_INT 1
88769: NEG
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 2
88777: PUSH
88778: LD_INT 1
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 2
88787: NEG
88788: PUSH
88789: LD_INT 1
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
88808: LD_ADDR_VAR 0 36
88812: PUSH
88813: LD_INT 0
88815: PUSH
88816: LD_INT 0
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 0
88825: PUSH
88826: LD_INT 1
88828: NEG
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 1
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 1
88846: PUSH
88847: LD_INT 1
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 0
88856: PUSH
88857: LD_INT 1
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: LD_INT 1
88866: NEG
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: PUSH
88879: LD_INT 1
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: NEG
88890: PUSH
88891: LD_INT 2
88893: NEG
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 1
88901: PUSH
88902: LD_INT 2
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88920: LD_ADDR_VAR 0 37
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: LD_INT 0
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 0
88937: PUSH
88938: LD_INT 1
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 1
88948: PUSH
88949: LD_INT 0
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: LD_INT 0
88968: PUSH
88969: LD_INT 1
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 1
88978: NEG
88979: PUSH
88980: LD_INT 0
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 1
88989: NEG
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: LD_INT 1
89004: NEG
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 1
89012: NEG
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89032: LD_ADDR_VAR 0 38
89036: PUSH
89037: LD_INT 0
89039: PUSH
89040: LD_INT 0
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 0
89049: PUSH
89050: LD_INT 1
89052: NEG
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 1
89060: PUSH
89061: LD_INT 0
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 1
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 0
89080: PUSH
89081: LD_INT 1
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 1
89090: NEG
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 1
89101: NEG
89102: PUSH
89103: LD_INT 1
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: PUSH
89114: LD_INT 1
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 2
89123: NEG
89124: PUSH
89125: LD_INT 1
89127: NEG
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89144: LD_ADDR_VAR 0 39
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: LD_INT 0
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 0
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 1
89172: PUSH
89173: LD_INT 0
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: PUSH
89180: LD_INT 1
89182: PUSH
89183: LD_INT 1
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 1
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: NEG
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: NEG
89226: PUSH
89227: LD_INT 2
89229: NEG
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 1
89237: PUSH
89238: LD_INT 2
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89256: LD_ADDR_VAR 0 40
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: LD_INT 0
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 0
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 1
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 1
89294: PUSH
89295: LD_INT 1
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 1
89314: NEG
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 1
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: NEG
89349: PUSH
89350: LD_INT 1
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89368: LD_ADDR_VAR 0 41
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: LD_INT 0
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 0
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 1
89396: PUSH
89397: LD_INT 0
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PUSH
89404: LD_INT 1
89406: PUSH
89407: LD_INT 1
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: PUSH
89414: LD_INT 0
89416: PUSH
89417: LD_INT 1
89419: PUSH
89420: EMPTY
89421: LIST
89422: LIST
89423: PUSH
89424: LD_INT 1
89426: NEG
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 1
89437: NEG
89438: PUSH
89439: LD_INT 1
89441: NEG
89442: PUSH
89443: EMPTY
89444: LIST
89445: LIST
89446: PUSH
89447: LD_INT 1
89449: NEG
89450: PUSH
89451: LD_INT 2
89453: NEG
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 1
89461: PUSH
89462: LD_INT 1
89464: NEG
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 2
89472: PUSH
89473: LD_INT 0
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 2
89482: PUSH
89483: LD_INT 1
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 2
89492: PUSH
89493: LD_INT 2
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 1
89502: PUSH
89503: LD_INT 2
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: NEG
89513: PUSH
89514: LD_INT 1
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 2
89534: NEG
89535: PUSH
89536: LD_INT 1
89538: NEG
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 2
89546: NEG
89547: PUSH
89548: LD_INT 2
89550: NEG
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: PUSH
89556: LD_INT 2
89558: NEG
89559: PUSH
89560: LD_INT 3
89562: NEG
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 2
89570: PUSH
89571: LD_INT 1
89573: NEG
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 3
89581: PUSH
89582: LD_INT 0
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 3
89591: PUSH
89592: LD_INT 1
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 3
89601: PUSH
89602: LD_INT 2
89604: PUSH
89605: EMPTY
89606: LIST
89607: LIST
89608: PUSH
89609: LD_INT 3
89611: PUSH
89612: LD_INT 3
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 2
89621: PUSH
89622: LD_INT 3
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: PUSH
89629: LD_INT 2
89631: NEG
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 3
89642: NEG
89643: PUSH
89644: LD_INT 0
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 3
89653: NEG
89654: PUSH
89655: LD_INT 1
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 3
89665: NEG
89666: PUSH
89667: LD_INT 2
89669: NEG
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 3
89677: NEG
89678: PUSH
89679: LD_INT 3
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89718: LD_ADDR_VAR 0 42
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: LD_INT 0
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 0
89735: PUSH
89736: LD_INT 1
89738: NEG
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 1
89746: PUSH
89747: LD_INT 0
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: PUSH
89754: LD_INT 1
89756: PUSH
89757: LD_INT 1
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 0
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: LD_INT 1
89776: NEG
89777: PUSH
89778: LD_INT 0
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: LD_INT 1
89791: NEG
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 1
89799: NEG
89800: PUSH
89801: LD_INT 2
89803: NEG
89804: PUSH
89805: EMPTY
89806: LIST
89807: LIST
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: LD_INT 2
89814: NEG
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: LD_INT 1
89822: PUSH
89823: LD_INT 1
89825: NEG
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: PUSH
89834: LD_INT 1
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 2
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 1
89853: PUSH
89854: LD_INT 2
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: LD_INT 2
89866: PUSH
89867: EMPTY
89868: LIST
89869: LIST
89870: PUSH
89871: LD_INT 1
89873: NEG
89874: PUSH
89875: LD_INT 1
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 2
89884: NEG
89885: PUSH
89886: LD_INT 1
89888: NEG
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 2
89896: NEG
89897: PUSH
89898: LD_INT 2
89900: NEG
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 2
89908: NEG
89909: PUSH
89910: LD_INT 3
89912: NEG
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 1
89920: NEG
89921: PUSH
89922: LD_INT 3
89924: NEG
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 0
89932: PUSH
89933: LD_INT 3
89935: NEG
89936: PUSH
89937: EMPTY
89938: LIST
89939: LIST
89940: PUSH
89941: LD_INT 1
89943: PUSH
89944: LD_INT 2
89946: NEG
89947: PUSH
89948: EMPTY
89949: LIST
89950: LIST
89951: PUSH
89952: LD_INT 3
89954: PUSH
89955: LD_INT 2
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 3
89964: PUSH
89965: LD_INT 3
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 2
89974: PUSH
89975: LD_INT 3
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: PUSH
89985: LD_INT 3
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 0
89994: PUSH
89995: LD_INT 3
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 1
90004: NEG
90005: PUSH
90006: LD_INT 2
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 3
90015: NEG
90016: PUSH
90017: LD_INT 2
90019: NEG
90020: PUSH
90021: EMPTY
90022: LIST
90023: LIST
90024: PUSH
90025: LD_INT 3
90027: NEG
90028: PUSH
90029: LD_INT 3
90031: NEG
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90068: LD_ADDR_VAR 0 43
90072: PUSH
90073: LD_INT 0
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 0
90085: PUSH
90086: LD_INT 1
90088: NEG
90089: PUSH
90090: EMPTY
90091: LIST
90092: LIST
90093: PUSH
90094: LD_INT 1
90096: PUSH
90097: LD_INT 0
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 1
90106: PUSH
90107: LD_INT 1
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: LD_INT 1
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 1
90126: NEG
90127: PUSH
90128: LD_INT 0
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 1
90137: NEG
90138: PUSH
90139: LD_INT 1
90141: NEG
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: PUSH
90147: LD_INT 1
90149: NEG
90150: PUSH
90151: LD_INT 2
90153: NEG
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 0
90161: PUSH
90162: LD_INT 2
90164: NEG
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 1
90172: PUSH
90173: LD_INT 1
90175: NEG
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 2
90183: PUSH
90184: LD_INT 0
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 2
90193: PUSH
90194: LD_INT 1
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 1
90203: PUSH
90204: LD_INT 2
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 0
90213: PUSH
90214: LD_INT 2
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: LD_INT 1
90223: NEG
90224: PUSH
90225: LD_INT 1
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: LD_INT 2
90234: NEG
90235: PUSH
90236: LD_INT 0
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 2
90245: NEG
90246: PUSH
90247: LD_INT 1
90249: NEG
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PUSH
90255: LD_INT 1
90257: NEG
90258: PUSH
90259: LD_INT 3
90261: NEG
90262: PUSH
90263: EMPTY
90264: LIST
90265: LIST
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: LD_INT 3
90272: NEG
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 1
90280: PUSH
90281: LD_INT 2
90283: NEG
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: LD_INT 1
90294: NEG
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 3
90302: PUSH
90303: LD_INT 0
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 3
90312: PUSH
90313: LD_INT 1
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 1
90322: PUSH
90323: LD_INT 3
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: LD_INT 3
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 1
90342: NEG
90343: PUSH
90344: LD_INT 2
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: LD_INT 1
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 3
90364: NEG
90365: PUSH
90366: LD_INT 0
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 3
90375: NEG
90376: PUSH
90377: LD_INT 1
90379: NEG
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90416: LD_ADDR_VAR 0 44
90420: PUSH
90421: LD_INT 0
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 1
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: LD_INT 0
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: LD_INT 1
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 0
90464: PUSH
90465: LD_INT 1
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 1
90474: NEG
90475: PUSH
90476: LD_INT 0
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: NEG
90486: PUSH
90487: LD_INT 1
90489: NEG
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 1
90497: NEG
90498: PUSH
90499: LD_INT 2
90501: NEG
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: LD_INT 1
90512: NEG
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: PUSH
90518: LD_INT 2
90520: PUSH
90521: LD_INT 0
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: PUSH
90528: LD_INT 2
90530: PUSH
90531: LD_INT 1
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: LD_INT 2
90540: PUSH
90541: LD_INT 2
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 1
90550: PUSH
90551: LD_INT 2
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: LD_INT 1
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 2
90571: NEG
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 2
90582: NEG
90583: PUSH
90584: LD_INT 1
90586: NEG
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: LD_INT 2
90594: NEG
90595: PUSH
90596: LD_INT 2
90598: NEG
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 2
90606: NEG
90607: PUSH
90608: LD_INT 3
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 2
90618: PUSH
90619: LD_INT 1
90621: NEG
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 3
90629: PUSH
90630: LD_INT 0
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 3
90639: PUSH
90640: LD_INT 1
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 3
90649: PUSH
90650: LD_INT 2
90652: PUSH
90653: EMPTY
90654: LIST
90655: LIST
90656: PUSH
90657: LD_INT 3
90659: PUSH
90660: LD_INT 3
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 2
90669: PUSH
90670: LD_INT 3
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PUSH
90677: LD_INT 2
90679: NEG
90680: PUSH
90681: LD_INT 1
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 3
90690: NEG
90691: PUSH
90692: LD_INT 0
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: PUSH
90699: LD_INT 3
90701: NEG
90702: PUSH
90703: LD_INT 1
90705: NEG
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 3
90713: NEG
90714: PUSH
90715: LD_INT 2
90717: NEG
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 3
90725: NEG
90726: PUSH
90727: LD_INT 3
90729: NEG
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90766: LD_ADDR_VAR 0 45
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 0
90783: PUSH
90784: LD_INT 1
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: LD_INT 0
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 1
90804: PUSH
90805: LD_INT 1
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 0
90814: PUSH
90815: LD_INT 1
90817: PUSH
90818: EMPTY
90819: LIST
90820: LIST
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: PUSH
90833: LD_INT 1
90835: NEG
90836: PUSH
90837: LD_INT 1
90839: NEG
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 1
90847: NEG
90848: PUSH
90849: LD_INT 2
90851: NEG
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 0
90859: PUSH
90860: LD_INT 2
90862: NEG
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 2
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 2
90891: PUSH
90892: LD_INT 2
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: LD_INT 2
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 0
90911: PUSH
90912: LD_INT 2
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: LD_INT 1
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: LD_INT 2
90932: NEG
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 2
90944: NEG
90945: PUSH
90946: LD_INT 2
90948: NEG
90949: PUSH
90950: EMPTY
90951: LIST
90952: LIST
90953: PUSH
90954: LD_INT 2
90956: NEG
90957: PUSH
90958: LD_INT 3
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: NEG
90969: PUSH
90970: LD_INT 3
90972: NEG
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: LD_INT 3
90983: NEG
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 1
90991: PUSH
90992: LD_INT 2
90994: NEG
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: LD_INT 3
91002: PUSH
91003: LD_INT 2
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 3
91012: PUSH
91013: LD_INT 3
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 2
91022: PUSH
91023: LD_INT 3
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 1
91032: PUSH
91033: LD_INT 3
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: LD_INT 3
91045: PUSH
91046: EMPTY
91047: LIST
91048: LIST
91049: PUSH
91050: LD_INT 1
91052: NEG
91053: PUSH
91054: LD_INT 2
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 3
91063: NEG
91064: PUSH
91065: LD_INT 2
91067: NEG
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 3
91075: NEG
91076: PUSH
91077: LD_INT 3
91079: NEG
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: LIST
91111: LIST
91112: LIST
91113: LIST
91114: LIST
91115: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91116: LD_ADDR_VAR 0 46
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 0
91133: PUSH
91134: LD_INT 1
91136: NEG
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: LD_INT 0
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 1
91154: PUSH
91155: LD_INT 1
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 0
91164: PUSH
91165: LD_INT 1
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: LD_INT 1
91174: NEG
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 1
91185: NEG
91186: PUSH
91187: LD_INT 1
91189: NEG
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 1
91197: NEG
91198: PUSH
91199: LD_INT 2
91201: NEG
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: LD_INT 2
91212: NEG
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: PUSH
91218: LD_INT 1
91220: PUSH
91221: LD_INT 1
91223: NEG
91224: PUSH
91225: EMPTY
91226: LIST
91227: LIST
91228: PUSH
91229: LD_INT 2
91231: PUSH
91232: LD_INT 0
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 2
91241: PUSH
91242: LD_INT 1
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: PUSH
91249: LD_INT 1
91251: PUSH
91252: LD_INT 2
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 1
91271: NEG
91272: PUSH
91273: LD_INT 1
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 2
91282: NEG
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 2
91293: NEG
91294: PUSH
91295: LD_INT 1
91297: NEG
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: LD_INT 3
91309: NEG
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: LD_INT 3
91320: NEG
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 1
91328: PUSH
91329: LD_INT 2
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 2
91339: PUSH
91340: LD_INT 1
91342: NEG
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 3
91350: PUSH
91351: LD_INT 0
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 3
91360: PUSH
91361: LD_INT 1
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 3
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 0
91380: PUSH
91381: LD_INT 3
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 1
91390: NEG
91391: PUSH
91392: LD_INT 2
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 2
91401: NEG
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 3
91412: NEG
91413: PUSH
91414: LD_INT 0
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 3
91423: NEG
91424: PUSH
91425: LD_INT 1
91427: NEG
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91464: LD_ADDR_VAR 0 47
91468: PUSH
91469: LD_INT 0
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 0
91481: PUSH
91482: LD_INT 1
91484: NEG
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 1
91492: PUSH
91493: LD_INT 0
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 1
91502: PUSH
91503: LD_INT 1
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: LD_INT 0
91512: PUSH
91513: LD_INT 1
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 1
91522: NEG
91523: PUSH
91524: LD_INT 0
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 1
91533: NEG
91534: PUSH
91535: LD_INT 1
91537: NEG
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 1
91545: NEG
91546: PUSH
91547: LD_INT 2
91549: NEG
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 0
91557: PUSH
91558: LD_INT 2
91560: NEG
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: LD_INT 1
91568: PUSH
91569: LD_INT 1
91571: NEG
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 2
91579: NEG
91580: PUSH
91581: LD_INT 1
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 2
91591: NEG
91592: PUSH
91593: LD_INT 2
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91615: LD_ADDR_VAR 0 48
91619: PUSH
91620: LD_INT 0
91622: PUSH
91623: LD_INT 0
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 0
91632: PUSH
91633: LD_INT 1
91635: NEG
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 1
91643: PUSH
91644: LD_INT 0
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 1
91653: PUSH
91654: LD_INT 1
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 0
91663: PUSH
91664: LD_INT 1
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 1
91673: NEG
91674: PUSH
91675: LD_INT 0
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 1
91696: NEG
91697: PUSH
91698: LD_INT 2
91700: NEG
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: LD_INT 2
91711: NEG
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PUSH
91717: LD_INT 1
91719: PUSH
91720: LD_INT 1
91722: NEG
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: LD_INT 2
91730: PUSH
91731: LD_INT 0
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 2
91740: PUSH
91741: LD_INT 1
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91762: LD_ADDR_VAR 0 49
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 0
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: LD_INT 1
91782: NEG
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 1
91790: PUSH
91791: LD_INT 0
91793: PUSH
91794: EMPTY
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 1
91800: PUSH
91801: LD_INT 1
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 0
91810: PUSH
91811: LD_INT 1
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 1
91820: NEG
91821: PUSH
91822: LD_INT 0
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: PUSH
91829: LD_INT 1
91831: NEG
91832: PUSH
91833: LD_INT 1
91835: NEG
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 1
91843: PUSH
91844: LD_INT 1
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 0
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 2
91864: PUSH
91865: LD_INT 1
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 2
91874: PUSH
91875: LD_INT 2
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 1
91884: PUSH
91885: LD_INT 2
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91906: LD_ADDR_VAR 0 50
91910: PUSH
91911: LD_INT 0
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 0
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 1
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 0
91954: PUSH
91955: LD_INT 1
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 1
91964: NEG
91965: PUSH
91966: LD_INT 0
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 1
91975: NEG
91976: PUSH
91977: LD_INT 1
91979: NEG
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 2
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: EMPTY
91992: LIST
91993: LIST
91994: PUSH
91995: LD_INT 2
91997: PUSH
91998: LD_INT 2
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 1
92007: PUSH
92008: LD_INT 2
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: LD_INT 2
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: PUSH
92025: LD_INT 1
92027: NEG
92028: PUSH
92029: LD_INT 1
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: LIST
92040: LIST
92041: LIST
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92050: LD_ADDR_VAR 0 51
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: LD_INT 0
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 0
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 0
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 1
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 1
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: LD_INT 1
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 1
92131: PUSH
92132: LD_INT 2
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 0
92141: PUSH
92142: LD_INT 2
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 1
92151: NEG
92152: PUSH
92153: LD_INT 1
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: PUSH
92160: LD_INT 2
92162: NEG
92163: PUSH
92164: LD_INT 0
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: PUSH
92171: LD_INT 2
92173: NEG
92174: PUSH
92175: LD_INT 1
92177: NEG
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: LIST
92191: LIST
92192: LIST
92193: LIST
92194: LIST
92195: LIST
92196: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92197: LD_ADDR_VAR 0 52
92201: PUSH
92202: LD_INT 0
92204: PUSH
92205: LD_INT 0
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: PUSH
92212: LD_INT 0
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 1
92225: PUSH
92226: LD_INT 0
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 1
92235: PUSH
92236: LD_INT 1
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: LD_INT 0
92245: PUSH
92246: LD_INT 1
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 1
92255: NEG
92256: PUSH
92257: LD_INT 0
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 1
92266: NEG
92267: PUSH
92268: LD_INT 1
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 1
92278: NEG
92279: PUSH
92280: LD_INT 2
92282: NEG
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: PUSH
92288: LD_INT 1
92290: NEG
92291: PUSH
92292: LD_INT 1
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 2
92301: NEG
92302: PUSH
92303: LD_INT 0
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 2
92312: NEG
92313: PUSH
92314: LD_INT 1
92316: NEG
92317: PUSH
92318: EMPTY
92319: LIST
92320: LIST
92321: PUSH
92322: LD_INT 2
92324: NEG
92325: PUSH
92326: LD_INT 2
92328: NEG
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: EMPTY
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92348: LD_ADDR_VAR 0 53
92352: PUSH
92353: LD_INT 0
92355: PUSH
92356: LD_INT 0
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 0
92365: PUSH
92366: LD_INT 1
92368: NEG
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 1
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: PUSH
92384: LD_INT 1
92386: PUSH
92387: LD_INT 1
92389: PUSH
92390: EMPTY
92391: LIST
92392: LIST
92393: PUSH
92394: LD_INT 0
92396: PUSH
92397: LD_INT 1
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 1
92406: NEG
92407: PUSH
92408: LD_INT 0
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 1
92417: NEG
92418: PUSH
92419: LD_INT 1
92421: NEG
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 1
92429: NEG
92430: PUSH
92431: LD_INT 2
92433: NEG
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 0
92441: PUSH
92442: LD_INT 2
92444: NEG
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: PUSH
92450: LD_INT 1
92452: PUSH
92453: LD_INT 1
92455: NEG
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 2
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 2
92473: PUSH
92474: LD_INT 1
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 2
92483: PUSH
92484: LD_INT 2
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 1
92493: PUSH
92494: LD_INT 2
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 0
92503: PUSH
92504: LD_INT 2
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 1
92513: NEG
92514: PUSH
92515: LD_INT 1
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 2
92524: NEG
92525: PUSH
92526: LD_INT 0
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 2
92535: NEG
92536: PUSH
92537: LD_INT 1
92539: NEG
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 2
92547: NEG
92548: PUSH
92549: LD_INT 2
92551: NEG
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92578: LD_ADDR_VAR 0 54
92582: PUSH
92583: LD_INT 0
92585: PUSH
92586: LD_INT 0
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 0
92595: PUSH
92596: LD_INT 1
92598: NEG
92599: PUSH
92600: EMPTY
92601: LIST
92602: LIST
92603: PUSH
92604: LD_INT 1
92606: PUSH
92607: LD_INT 0
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 1
92616: PUSH
92617: LD_INT 1
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: LD_INT 0
92626: PUSH
92627: LD_INT 1
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 1
92636: NEG
92637: PUSH
92638: LD_INT 0
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 1
92647: NEG
92648: PUSH
92649: LD_INT 1
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 1
92659: NEG
92660: PUSH
92661: LD_INT 2
92663: NEG
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 0
92671: PUSH
92672: LD_INT 2
92674: NEG
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 1
92682: PUSH
92683: LD_INT 1
92685: NEG
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 2
92693: PUSH
92694: LD_INT 0
92696: PUSH
92697: EMPTY
92698: LIST
92699: LIST
92700: PUSH
92701: LD_INT 2
92703: PUSH
92704: LD_INT 1
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 2
92713: PUSH
92714: LD_INT 2
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 1
92723: PUSH
92724: LD_INT 2
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 0
92733: PUSH
92734: LD_INT 2
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 1
92743: NEG
92744: PUSH
92745: LD_INT 1
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: LD_INT 2
92754: NEG
92755: PUSH
92756: LD_INT 0
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 2
92765: NEG
92766: PUSH
92767: LD_INT 1
92769: NEG
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 2
92777: NEG
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92808: LD_ADDR_VAR 0 55
92812: PUSH
92813: LD_INT 0
92815: PUSH
92816: LD_INT 0
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 0
92825: PUSH
92826: LD_INT 1
92828: NEG
92829: PUSH
92830: EMPTY
92831: LIST
92832: LIST
92833: PUSH
92834: LD_INT 1
92836: PUSH
92837: LD_INT 0
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: LD_INT 1
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 0
92856: PUSH
92857: LD_INT 1
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: LD_INT 1
92866: NEG
92867: PUSH
92868: LD_INT 0
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 1
92877: NEG
92878: PUSH
92879: LD_INT 1
92881: NEG
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 1
92889: NEG
92890: PUSH
92891: LD_INT 2
92893: NEG
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 0
92901: PUSH
92902: LD_INT 2
92904: NEG
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: LD_INT 1
92912: PUSH
92913: LD_INT 1
92915: NEG
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PUSH
92921: LD_INT 2
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 2
92933: PUSH
92934: LD_INT 1
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 2
92943: PUSH
92944: LD_INT 2
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: PUSH
92954: LD_INT 2
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: LD_INT 2
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 1
92973: NEG
92974: PUSH
92975: LD_INT 1
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: LD_INT 2
92984: NEG
92985: PUSH
92986: LD_INT 0
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PUSH
92993: LD_INT 2
92995: NEG
92996: PUSH
92997: LD_INT 1
92999: NEG
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 2
93007: NEG
93008: PUSH
93009: LD_INT 2
93011: NEG
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: LIST
93034: LIST
93035: LIST
93036: LIST
93037: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93038: LD_ADDR_VAR 0 56
93042: PUSH
93043: LD_INT 0
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 0
93055: PUSH
93056: LD_INT 1
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 1
93066: PUSH
93067: LD_INT 0
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 1
93076: PUSH
93077: LD_INT 1
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 0
93086: PUSH
93087: LD_INT 1
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 1
93096: NEG
93097: PUSH
93098: LD_INT 0
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: LD_INT 1
93107: NEG
93108: PUSH
93109: LD_INT 1
93111: NEG
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: PUSH
93117: LD_INT 1
93119: NEG
93120: PUSH
93121: LD_INT 2
93123: NEG
93124: PUSH
93125: EMPTY
93126: LIST
93127: LIST
93128: PUSH
93129: LD_INT 0
93131: PUSH
93132: LD_INT 2
93134: NEG
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 1
93142: PUSH
93143: LD_INT 1
93145: NEG
93146: PUSH
93147: EMPTY
93148: LIST
93149: LIST
93150: PUSH
93151: LD_INT 2
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: EMPTY
93158: LIST
93159: LIST
93160: PUSH
93161: LD_INT 2
93163: PUSH
93164: LD_INT 1
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 2
93173: PUSH
93174: LD_INT 2
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 1
93183: PUSH
93184: LD_INT 2
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PUSH
93191: LD_INT 0
93193: PUSH
93194: LD_INT 2
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 1
93203: NEG
93204: PUSH
93205: LD_INT 1
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: PUSH
93212: LD_INT 2
93214: NEG
93215: PUSH
93216: LD_INT 0
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 2
93225: NEG
93226: PUSH
93227: LD_INT 1
93229: NEG
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PUSH
93235: LD_INT 2
93237: NEG
93238: PUSH
93239: LD_INT 2
93241: NEG
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: LIST
93266: LIST
93267: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93268: LD_ADDR_VAR 0 57
93272: PUSH
93273: LD_INT 0
93275: PUSH
93276: LD_INT 0
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: LD_INT 1
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 1
93296: PUSH
93297: LD_INT 0
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: PUSH
93304: LD_INT 1
93306: PUSH
93307: LD_INT 1
93309: PUSH
93310: EMPTY
93311: LIST
93312: LIST
93313: PUSH
93314: LD_INT 0
93316: PUSH
93317: LD_INT 1
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 1
93326: NEG
93327: PUSH
93328: LD_INT 0
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 1
93337: NEG
93338: PUSH
93339: LD_INT 1
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: NEG
93350: PUSH
93351: LD_INT 2
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 0
93361: PUSH
93362: LD_INT 2
93364: NEG
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 1
93372: PUSH
93373: LD_INT 1
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 2
93383: PUSH
93384: LD_INT 0
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 2
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 2
93403: PUSH
93404: LD_INT 2
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 1
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 1
93433: NEG
93434: PUSH
93435: LD_INT 1
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 2
93444: NEG
93445: PUSH
93446: LD_INT 0
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 2
93455: NEG
93456: PUSH
93457: LD_INT 1
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 2
93467: NEG
93468: PUSH
93469: LD_INT 2
93471: NEG
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93498: LD_ADDR_VAR 0 58
93502: PUSH
93503: LD_INT 0
93505: PUSH
93506: LD_INT 0
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PUSH
93513: LD_INT 0
93515: PUSH
93516: LD_INT 1
93518: NEG
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 1
93526: PUSH
93527: LD_INT 0
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: LD_INT 1
93536: PUSH
93537: LD_INT 1
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 0
93546: PUSH
93547: LD_INT 1
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 1
93556: NEG
93557: PUSH
93558: LD_INT 0
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: LD_INT 1
93567: NEG
93568: PUSH
93569: LD_INT 1
93571: NEG
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 1
93579: NEG
93580: PUSH
93581: LD_INT 2
93583: NEG
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 0
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: LD_INT 1
93602: PUSH
93603: LD_INT 1
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 2
93613: PUSH
93614: LD_INT 0
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 2
93623: PUSH
93624: LD_INT 1
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 2
93633: PUSH
93634: LD_INT 2
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 1
93643: PUSH
93644: LD_INT 2
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 0
93653: PUSH
93654: LD_INT 2
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 1
93663: NEG
93664: PUSH
93665: LD_INT 1
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: LD_INT 2
93674: NEG
93675: PUSH
93676: LD_INT 0
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: LD_INT 2
93685: NEG
93686: PUSH
93687: LD_INT 1
93689: NEG
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: LD_INT 2
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93728: LD_ADDR_VAR 0 59
93732: PUSH
93733: LD_INT 0
93735: PUSH
93736: LD_INT 0
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 0
93745: PUSH
93746: LD_INT 1
93748: NEG
93749: PUSH
93750: EMPTY
93751: LIST
93752: LIST
93753: PUSH
93754: LD_INT 1
93756: PUSH
93757: LD_INT 0
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 1
93766: PUSH
93767: LD_INT 1
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 0
93776: PUSH
93777: LD_INT 1
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 1
93786: NEG
93787: PUSH
93788: LD_INT 0
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: LD_INT 1
93797: NEG
93798: PUSH
93799: LD_INT 1
93801: NEG
93802: PUSH
93803: EMPTY
93804: LIST
93805: LIST
93806: PUSH
93807: EMPTY
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93816: LD_ADDR_VAR 0 60
93820: PUSH
93821: LD_INT 0
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 0
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 1
93844: PUSH
93845: LD_INT 0
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: LD_INT 1
93854: PUSH
93855: LD_INT 1
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 0
93864: PUSH
93865: LD_INT 1
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 1
93874: NEG
93875: PUSH
93876: LD_INT 0
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 1
93885: NEG
93886: PUSH
93887: LD_INT 1
93889: NEG
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93904: LD_ADDR_VAR 0 61
93908: PUSH
93909: LD_INT 0
93911: PUSH
93912: LD_INT 0
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 0
93921: PUSH
93922: LD_INT 1
93924: NEG
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 1
93932: PUSH
93933: LD_INT 0
93935: PUSH
93936: EMPTY
93937: LIST
93938: LIST
93939: PUSH
93940: LD_INT 1
93942: PUSH
93943: LD_INT 1
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 0
93952: PUSH
93953: LD_INT 1
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 1
93962: NEG
93963: PUSH
93964: LD_INT 0
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 1
93973: NEG
93974: PUSH
93975: LD_INT 1
93977: NEG
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
93992: LD_ADDR_VAR 0 62
93996: PUSH
93997: LD_INT 0
93999: PUSH
94000: LD_INT 0
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 0
94009: PUSH
94010: LD_INT 1
94012: NEG
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 1
94020: PUSH
94021: LD_INT 0
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: LD_INT 1
94030: PUSH
94031: LD_INT 1
94033: PUSH
94034: EMPTY
94035: LIST
94036: LIST
94037: PUSH
94038: LD_INT 0
94040: PUSH
94041: LD_INT 1
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 1
94050: NEG
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 1
94061: NEG
94062: PUSH
94063: LD_INT 1
94065: NEG
94066: PUSH
94067: EMPTY
94068: LIST
94069: LIST
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94080: LD_ADDR_VAR 0 63
94084: PUSH
94085: LD_INT 0
94087: PUSH
94088: LD_INT 0
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 0
94097: PUSH
94098: LD_INT 1
94100: NEG
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PUSH
94106: LD_INT 1
94108: PUSH
94109: LD_INT 0
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 1
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 0
94128: PUSH
94129: LD_INT 1
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 1
94138: NEG
94139: PUSH
94140: LD_INT 0
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PUSH
94147: LD_INT 1
94149: NEG
94150: PUSH
94151: LD_INT 1
94153: NEG
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: LIST
94167: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94168: LD_ADDR_VAR 0 64
94172: PUSH
94173: LD_INT 0
94175: PUSH
94176: LD_INT 0
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 0
94185: PUSH
94186: LD_INT 1
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 1
94196: PUSH
94197: LD_INT 0
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PUSH
94204: LD_INT 1
94206: PUSH
94207: LD_INT 1
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: PUSH
94214: LD_INT 0
94216: PUSH
94217: LD_INT 1
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 1
94226: NEG
94227: PUSH
94228: LD_INT 0
94230: PUSH
94231: EMPTY
94232: LIST
94233: LIST
94234: PUSH
94235: LD_INT 1
94237: NEG
94238: PUSH
94239: LD_INT 1
94241: NEG
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: ST_TO_ADDR
// end ; 1 :
94256: GO 100153
94258: LD_INT 1
94260: DOUBLE
94261: EQUAL
94262: IFTRUE 94266
94264: GO 96889
94266: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94267: LD_ADDR_VAR 0 11
94271: PUSH
94272: LD_INT 1
94274: NEG
94275: PUSH
94276: LD_INT 3
94278: NEG
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 0
94286: PUSH
94287: LD_INT 3
94289: NEG
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 1
94297: PUSH
94298: LD_INT 2
94300: NEG
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: LIST
94310: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94311: LD_ADDR_VAR 0 12
94315: PUSH
94316: LD_INT 2
94318: PUSH
94319: LD_INT 1
94321: NEG
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 3
94329: PUSH
94330: LD_INT 0
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 3
94339: PUSH
94340: LD_INT 1
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: LIST
94351: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94352: LD_ADDR_VAR 0 13
94356: PUSH
94357: LD_INT 3
94359: PUSH
94360: LD_INT 2
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: PUSH
94367: LD_INT 3
94369: PUSH
94370: LD_INT 3
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 2
94379: PUSH
94380: LD_INT 3
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: LIST
94391: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94392: LD_ADDR_VAR 0 14
94396: PUSH
94397: LD_INT 1
94399: PUSH
94400: LD_INT 3
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 0
94409: PUSH
94410: LD_INT 3
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 1
94419: NEG
94420: PUSH
94421: LD_INT 2
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: PUSH
94428: EMPTY
94429: LIST
94430: LIST
94431: LIST
94432: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94433: LD_ADDR_VAR 0 15
94437: PUSH
94438: LD_INT 2
94440: NEG
94441: PUSH
94442: LD_INT 1
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 3
94451: NEG
94452: PUSH
94453: LD_INT 0
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 3
94462: NEG
94463: PUSH
94464: LD_INT 1
94466: NEG
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: LIST
94476: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94477: LD_ADDR_VAR 0 16
94481: PUSH
94482: LD_INT 2
94484: NEG
94485: PUSH
94486: LD_INT 3
94488: NEG
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 3
94496: NEG
94497: PUSH
94498: LD_INT 2
94500: NEG
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 3
94508: NEG
94509: PUSH
94510: LD_INT 3
94512: NEG
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: LIST
94522: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94523: LD_ADDR_VAR 0 17
94527: PUSH
94528: LD_INT 1
94530: NEG
94531: PUSH
94532: LD_INT 3
94534: NEG
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: PUSH
94540: LD_INT 0
94542: PUSH
94543: LD_INT 3
94545: NEG
94546: PUSH
94547: EMPTY
94548: LIST
94549: LIST
94550: PUSH
94551: LD_INT 1
94553: PUSH
94554: LD_INT 2
94556: NEG
94557: PUSH
94558: EMPTY
94559: LIST
94560: LIST
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: LIST
94566: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94567: LD_ADDR_VAR 0 18
94571: PUSH
94572: LD_INT 2
94574: PUSH
94575: LD_INT 1
94577: NEG
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 3
94585: PUSH
94586: LD_INT 0
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 3
94595: PUSH
94596: LD_INT 1
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: EMPTY
94604: LIST
94605: LIST
94606: LIST
94607: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94608: LD_ADDR_VAR 0 19
94612: PUSH
94613: LD_INT 3
94615: PUSH
94616: LD_INT 2
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 3
94625: PUSH
94626: LD_INT 3
94628: PUSH
94629: EMPTY
94630: LIST
94631: LIST
94632: PUSH
94633: LD_INT 2
94635: PUSH
94636: LD_INT 3
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: LIST
94647: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94648: LD_ADDR_VAR 0 20
94652: PUSH
94653: LD_INT 1
94655: PUSH
94656: LD_INT 3
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 0
94665: PUSH
94666: LD_INT 3
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: LD_INT 1
94675: NEG
94676: PUSH
94677: LD_INT 2
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: LIST
94688: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94689: LD_ADDR_VAR 0 21
94693: PUSH
94694: LD_INT 2
94696: NEG
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 3
94707: NEG
94708: PUSH
94709: LD_INT 0
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 3
94718: NEG
94719: PUSH
94720: LD_INT 1
94722: NEG
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: LIST
94732: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94733: LD_ADDR_VAR 0 22
94737: PUSH
94738: LD_INT 2
94740: NEG
94741: PUSH
94742: LD_INT 3
94744: NEG
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 3
94752: NEG
94753: PUSH
94754: LD_INT 2
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 3
94764: NEG
94765: PUSH
94766: LD_INT 3
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: LIST
94778: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
94779: LD_ADDR_VAR 0 23
94783: PUSH
94784: LD_INT 0
94786: PUSH
94787: LD_INT 3
94789: NEG
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: LD_INT 1
94797: NEG
94798: PUSH
94799: LD_INT 4
94801: NEG
94802: PUSH
94803: EMPTY
94804: LIST
94805: LIST
94806: PUSH
94807: LD_INT 1
94809: PUSH
94810: LD_INT 3
94812: NEG
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: LIST
94822: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
94823: LD_ADDR_VAR 0 24
94827: PUSH
94828: LD_INT 3
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 3
94840: PUSH
94841: LD_INT 1
94843: NEG
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 4
94851: PUSH
94852: LD_INT 1
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: LIST
94863: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
94864: LD_ADDR_VAR 0 25
94868: PUSH
94869: LD_INT 3
94871: PUSH
94872: LD_INT 3
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 4
94881: PUSH
94882: LD_INT 3
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 3
94891: PUSH
94892: LD_INT 4
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: LIST
94903: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
94904: LD_ADDR_VAR 0 26
94908: PUSH
94909: LD_INT 0
94911: PUSH
94912: LD_INT 3
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 1
94921: PUSH
94922: LD_INT 4
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 1
94931: NEG
94932: PUSH
94933: LD_INT 3
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: LIST
94944: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
94945: LD_ADDR_VAR 0 27
94949: PUSH
94950: LD_INT 3
94952: NEG
94953: PUSH
94954: LD_INT 0
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 3
94963: NEG
94964: PUSH
94965: LD_INT 1
94967: PUSH
94968: EMPTY
94969: LIST
94970: LIST
94971: PUSH
94972: LD_INT 4
94974: NEG
94975: PUSH
94976: LD_INT 1
94978: NEG
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: LIST
94988: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
94989: LD_ADDR_VAR 0 28
94993: PUSH
94994: LD_INT 3
94996: NEG
94997: PUSH
94998: LD_INT 3
95000: NEG
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 3
95008: NEG
95009: PUSH
95010: LD_INT 4
95012: NEG
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 4
95020: NEG
95021: PUSH
95022: LD_INT 3
95024: NEG
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: LIST
95034: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
95035: LD_ADDR_VAR 0 29
95039: PUSH
95040: LD_INT 1
95042: NEG
95043: PUSH
95044: LD_INT 3
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 0
95054: PUSH
95055: LD_INT 3
95057: NEG
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 1
95065: PUSH
95066: LD_INT 2
95068: NEG
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 1
95076: NEG
95077: PUSH
95078: LD_INT 4
95080: NEG
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 0
95088: PUSH
95089: LD_INT 4
95091: NEG
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PUSH
95097: LD_INT 1
95099: PUSH
95100: LD_INT 3
95102: NEG
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 1
95110: NEG
95111: PUSH
95112: LD_INT 5
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 0
95122: PUSH
95123: LD_INT 5
95125: NEG
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 1
95133: PUSH
95134: LD_INT 4
95136: NEG
95137: PUSH
95138: EMPTY
95139: LIST
95140: LIST
95141: PUSH
95142: LD_INT 1
95144: NEG
95145: PUSH
95146: LD_INT 6
95148: NEG
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PUSH
95154: LD_INT 0
95156: PUSH
95157: LD_INT 6
95159: NEG
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 1
95167: PUSH
95168: LD_INT 5
95170: NEG
95171: PUSH
95172: EMPTY
95173: LIST
95174: LIST
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
95190: LD_ADDR_VAR 0 30
95194: PUSH
95195: LD_INT 2
95197: PUSH
95198: LD_INT 1
95200: NEG
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: LD_INT 3
95208: PUSH
95209: LD_INT 0
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 3
95218: PUSH
95219: LD_INT 1
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 3
95228: PUSH
95229: LD_INT 1
95231: NEG
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 4
95239: PUSH
95240: LD_INT 0
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 4
95249: PUSH
95250: LD_INT 1
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 4
95259: PUSH
95260: LD_INT 1
95262: NEG
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 5
95270: PUSH
95271: LD_INT 0
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 5
95280: PUSH
95281: LD_INT 1
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 5
95290: PUSH
95291: LD_INT 1
95293: NEG
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 6
95301: PUSH
95302: LD_INT 0
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 6
95311: PUSH
95312: LD_INT 1
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
95333: LD_ADDR_VAR 0 31
95337: PUSH
95338: LD_INT 3
95340: PUSH
95341: LD_INT 2
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: PUSH
95348: LD_INT 3
95350: PUSH
95351: LD_INT 3
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 2
95360: PUSH
95361: LD_INT 3
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 4
95370: PUSH
95371: LD_INT 3
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: PUSH
95378: LD_INT 4
95380: PUSH
95381: LD_INT 4
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 3
95390: PUSH
95391: LD_INT 4
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: LD_INT 5
95400: PUSH
95401: LD_INT 4
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 5
95410: PUSH
95411: LD_INT 5
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 4
95420: PUSH
95421: LD_INT 5
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 6
95430: PUSH
95431: LD_INT 5
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 6
95440: PUSH
95441: LD_INT 6
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PUSH
95448: LD_INT 5
95450: PUSH
95451: LD_INT 6
95453: PUSH
95454: EMPTY
95455: LIST
95456: LIST
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
95472: LD_ADDR_VAR 0 32
95476: PUSH
95477: LD_INT 1
95479: PUSH
95480: LD_INT 3
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 0
95489: PUSH
95490: LD_INT 3
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 1
95499: NEG
95500: PUSH
95501: LD_INT 2
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 1
95510: PUSH
95511: LD_INT 4
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 0
95520: PUSH
95521: LD_INT 4
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: LD_INT 1
95530: NEG
95531: PUSH
95532: LD_INT 3
95534: PUSH
95535: EMPTY
95536: LIST
95537: LIST
95538: PUSH
95539: LD_INT 1
95541: PUSH
95542: LD_INT 5
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 0
95551: PUSH
95552: LD_INT 5
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: PUSH
95559: LD_INT 1
95561: NEG
95562: PUSH
95563: LD_INT 4
95565: PUSH
95566: EMPTY
95567: LIST
95568: LIST
95569: PUSH
95570: LD_INT 1
95572: PUSH
95573: LD_INT 6
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: LD_INT 0
95582: PUSH
95583: LD_INT 6
95585: PUSH
95586: EMPTY
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 1
95592: NEG
95593: PUSH
95594: LD_INT 5
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
95615: LD_ADDR_VAR 0 33
95619: PUSH
95620: LD_INT 2
95622: NEG
95623: PUSH
95624: LD_INT 1
95626: PUSH
95627: EMPTY
95628: LIST
95629: LIST
95630: PUSH
95631: LD_INT 3
95633: NEG
95634: PUSH
95635: LD_INT 0
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: PUSH
95642: LD_INT 3
95644: NEG
95645: PUSH
95646: LD_INT 1
95648: NEG
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: PUSH
95654: LD_INT 3
95656: NEG
95657: PUSH
95658: LD_INT 1
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 4
95667: NEG
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 4
95678: NEG
95679: PUSH
95680: LD_INT 1
95682: NEG
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 4
95690: NEG
95691: PUSH
95692: LD_INT 1
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 5
95701: NEG
95702: PUSH
95703: LD_INT 0
95705: PUSH
95706: EMPTY
95707: LIST
95708: LIST
95709: PUSH
95710: LD_INT 5
95712: NEG
95713: PUSH
95714: LD_INT 1
95716: NEG
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 5
95724: NEG
95725: PUSH
95726: LD_INT 1
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: PUSH
95733: LD_INT 6
95735: NEG
95736: PUSH
95737: LD_INT 0
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 6
95746: NEG
95747: PUSH
95748: LD_INT 1
95750: NEG
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
95770: LD_ADDR_VAR 0 34
95774: PUSH
95775: LD_INT 2
95777: NEG
95778: PUSH
95779: LD_INT 3
95781: NEG
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 3
95789: NEG
95790: PUSH
95791: LD_INT 2
95793: NEG
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 3
95801: NEG
95802: PUSH
95803: LD_INT 3
95805: NEG
95806: PUSH
95807: EMPTY
95808: LIST
95809: LIST
95810: PUSH
95811: LD_INT 3
95813: NEG
95814: PUSH
95815: LD_INT 4
95817: NEG
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 4
95825: NEG
95826: PUSH
95827: LD_INT 3
95829: NEG
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 4
95837: NEG
95838: PUSH
95839: LD_INT 4
95841: NEG
95842: PUSH
95843: EMPTY
95844: LIST
95845: LIST
95846: PUSH
95847: LD_INT 4
95849: NEG
95850: PUSH
95851: LD_INT 5
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 5
95861: NEG
95862: PUSH
95863: LD_INT 4
95865: NEG
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 5
95873: NEG
95874: PUSH
95875: LD_INT 5
95877: NEG
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 5
95885: NEG
95886: PUSH
95887: LD_INT 6
95889: NEG
95890: PUSH
95891: EMPTY
95892: LIST
95893: LIST
95894: PUSH
95895: LD_INT 6
95897: NEG
95898: PUSH
95899: LD_INT 5
95901: NEG
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 6
95909: NEG
95910: PUSH
95911: LD_INT 6
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: EMPTY
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
95933: LD_ADDR_VAR 0 41
95937: PUSH
95938: LD_INT 0
95940: PUSH
95941: LD_INT 2
95943: NEG
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 1
95951: NEG
95952: PUSH
95953: LD_INT 3
95955: NEG
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 1
95963: PUSH
95964: LD_INT 2
95966: NEG
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: LIST
95976: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
95977: LD_ADDR_VAR 0 42
95981: PUSH
95982: LD_INT 2
95984: PUSH
95985: LD_INT 0
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: PUSH
95992: LD_INT 2
95994: PUSH
95995: LD_INT 1
95997: NEG
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: LD_INT 3
96005: PUSH
96006: LD_INT 1
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: LIST
96017: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
96018: LD_ADDR_VAR 0 43
96022: PUSH
96023: LD_INT 2
96025: PUSH
96026: LD_INT 2
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: PUSH
96033: LD_INT 3
96035: PUSH
96036: LD_INT 2
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: PUSH
96043: LD_INT 2
96045: PUSH
96046: LD_INT 3
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: PUSH
96053: EMPTY
96054: LIST
96055: LIST
96056: LIST
96057: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
96058: LD_ADDR_VAR 0 44
96062: PUSH
96063: LD_INT 0
96065: PUSH
96066: LD_INT 2
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 1
96075: PUSH
96076: LD_INT 3
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 1
96085: NEG
96086: PUSH
96087: LD_INT 2
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: LIST
96098: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
96099: LD_ADDR_VAR 0 45
96103: PUSH
96104: LD_INT 2
96106: NEG
96107: PUSH
96108: LD_INT 0
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: PUSH
96115: LD_INT 2
96117: NEG
96118: PUSH
96119: LD_INT 1
96121: PUSH
96122: EMPTY
96123: LIST
96124: LIST
96125: PUSH
96126: LD_INT 3
96128: NEG
96129: PUSH
96130: LD_INT 1
96132: NEG
96133: PUSH
96134: EMPTY
96135: LIST
96136: LIST
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: LIST
96142: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
96143: LD_ADDR_VAR 0 46
96147: PUSH
96148: LD_INT 2
96150: NEG
96151: PUSH
96152: LD_INT 2
96154: NEG
96155: PUSH
96156: EMPTY
96157: LIST
96158: LIST
96159: PUSH
96160: LD_INT 2
96162: NEG
96163: PUSH
96164: LD_INT 3
96166: NEG
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: PUSH
96172: LD_INT 3
96174: NEG
96175: PUSH
96176: LD_INT 2
96178: NEG
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: LIST
96188: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
96189: LD_ADDR_VAR 0 47
96193: PUSH
96194: LD_INT 2
96196: NEG
96197: PUSH
96198: LD_INT 3
96200: NEG
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: PUSH
96206: LD_INT 1
96208: NEG
96209: PUSH
96210: LD_INT 3
96212: NEG
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
96222: LD_ADDR_VAR 0 48
96226: PUSH
96227: LD_INT 1
96229: PUSH
96230: LD_INT 2
96232: NEG
96233: PUSH
96234: EMPTY
96235: LIST
96236: LIST
96237: PUSH
96238: LD_INT 2
96240: PUSH
96241: LD_INT 1
96243: NEG
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: EMPTY
96250: LIST
96251: LIST
96252: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
96253: LD_ADDR_VAR 0 49
96257: PUSH
96258: LD_INT 3
96260: PUSH
96261: LD_INT 1
96263: PUSH
96264: EMPTY
96265: LIST
96266: LIST
96267: PUSH
96268: LD_INT 3
96270: PUSH
96271: LD_INT 2
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
96282: LD_ADDR_VAR 0 50
96286: PUSH
96287: LD_INT 2
96289: PUSH
96290: LD_INT 3
96292: PUSH
96293: EMPTY
96294: LIST
96295: LIST
96296: PUSH
96297: LD_INT 1
96299: PUSH
96300: LD_INT 3
96302: PUSH
96303: EMPTY
96304: LIST
96305: LIST
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
96311: LD_ADDR_VAR 0 51
96315: PUSH
96316: LD_INT 1
96318: NEG
96319: PUSH
96320: LD_INT 2
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 2
96329: NEG
96330: PUSH
96331: LD_INT 1
96333: PUSH
96334: EMPTY
96335: LIST
96336: LIST
96337: PUSH
96338: EMPTY
96339: LIST
96340: LIST
96341: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
96342: LD_ADDR_VAR 0 52
96346: PUSH
96347: LD_INT 3
96349: NEG
96350: PUSH
96351: LD_INT 1
96353: NEG
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PUSH
96359: LD_INT 3
96361: NEG
96362: PUSH
96363: LD_INT 2
96365: NEG
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96375: LD_ADDR_VAR 0 53
96379: PUSH
96380: LD_INT 1
96382: NEG
96383: PUSH
96384: LD_INT 3
96386: NEG
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 0
96394: PUSH
96395: LD_INT 3
96397: NEG
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 1
96405: PUSH
96406: LD_INT 2
96408: NEG
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: LIST
96418: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96419: LD_ADDR_VAR 0 54
96423: PUSH
96424: LD_INT 2
96426: PUSH
96427: LD_INT 1
96429: NEG
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 3
96437: PUSH
96438: LD_INT 0
96440: PUSH
96441: EMPTY
96442: LIST
96443: LIST
96444: PUSH
96445: LD_INT 3
96447: PUSH
96448: LD_INT 1
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: LIST
96459: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96460: LD_ADDR_VAR 0 55
96464: PUSH
96465: LD_INT 3
96467: PUSH
96468: LD_INT 2
96470: PUSH
96471: EMPTY
96472: LIST
96473: LIST
96474: PUSH
96475: LD_INT 3
96477: PUSH
96478: LD_INT 3
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: PUSH
96485: LD_INT 2
96487: PUSH
96488: LD_INT 3
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: LIST
96499: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96500: LD_ADDR_VAR 0 56
96504: PUSH
96505: LD_INT 1
96507: PUSH
96508: LD_INT 3
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 0
96517: PUSH
96518: LD_INT 3
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 1
96527: NEG
96528: PUSH
96529: LD_INT 2
96531: PUSH
96532: EMPTY
96533: LIST
96534: LIST
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: LIST
96540: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96541: LD_ADDR_VAR 0 57
96545: PUSH
96546: LD_INT 2
96548: NEG
96549: PUSH
96550: LD_INT 1
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 3
96559: NEG
96560: PUSH
96561: LD_INT 0
96563: PUSH
96564: EMPTY
96565: LIST
96566: LIST
96567: PUSH
96568: LD_INT 3
96570: NEG
96571: PUSH
96572: LD_INT 1
96574: NEG
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: LIST
96584: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96585: LD_ADDR_VAR 0 58
96589: PUSH
96590: LD_INT 2
96592: NEG
96593: PUSH
96594: LD_INT 3
96596: NEG
96597: PUSH
96598: EMPTY
96599: LIST
96600: LIST
96601: PUSH
96602: LD_INT 3
96604: NEG
96605: PUSH
96606: LD_INT 2
96608: NEG
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 3
96616: NEG
96617: PUSH
96618: LD_INT 3
96620: NEG
96621: PUSH
96622: EMPTY
96623: LIST
96624: LIST
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: LIST
96630: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
96631: LD_ADDR_VAR 0 59
96635: PUSH
96636: LD_INT 1
96638: NEG
96639: PUSH
96640: LD_INT 2
96642: NEG
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 0
96650: PUSH
96651: LD_INT 2
96653: NEG
96654: PUSH
96655: EMPTY
96656: LIST
96657: LIST
96658: PUSH
96659: LD_INT 1
96661: PUSH
96662: LD_INT 1
96664: NEG
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: LIST
96674: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
96675: LD_ADDR_VAR 0 60
96679: PUSH
96680: LD_INT 1
96682: PUSH
96683: LD_INT 1
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 2
96693: PUSH
96694: LD_INT 0
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: PUSH
96701: LD_INT 2
96703: PUSH
96704: LD_INT 1
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: LIST
96715: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
96716: LD_ADDR_VAR 0 61
96720: PUSH
96721: LD_INT 2
96723: PUSH
96724: LD_INT 1
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 2
96733: PUSH
96734: LD_INT 2
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: PUSH
96741: LD_INT 1
96743: PUSH
96744: LD_INT 2
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: LIST
96755: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
96756: LD_ADDR_VAR 0 62
96760: PUSH
96761: LD_INT 1
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 0
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: LD_INT 1
96783: NEG
96784: PUSH
96785: LD_INT 1
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: LIST
96796: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
96797: LD_ADDR_VAR 0 63
96801: PUSH
96802: LD_INT 1
96804: NEG
96805: PUSH
96806: LD_INT 1
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: LD_INT 2
96815: NEG
96816: PUSH
96817: LD_INT 0
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 2
96826: NEG
96827: PUSH
96828: LD_INT 1
96830: NEG
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: LIST
96840: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96841: LD_ADDR_VAR 0 64
96845: PUSH
96846: LD_INT 1
96848: NEG
96849: PUSH
96850: LD_INT 2
96852: NEG
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 2
96860: NEG
96861: PUSH
96862: LD_INT 1
96864: NEG
96865: PUSH
96866: EMPTY
96867: LIST
96868: LIST
96869: PUSH
96870: LD_INT 2
96872: NEG
96873: PUSH
96874: LD_INT 2
96876: NEG
96877: PUSH
96878: EMPTY
96879: LIST
96880: LIST
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: LIST
96886: ST_TO_ADDR
// end ; 2 :
96887: GO 100153
96889: LD_INT 2
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96897
96895: GO 100152
96897: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
96898: LD_ADDR_VAR 0 29
96902: PUSH
96903: LD_INT 4
96905: PUSH
96906: LD_INT 0
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: LD_INT 1
96918: NEG
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 5
96926: PUSH
96927: LD_INT 0
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: LD_INT 5
96936: PUSH
96937: LD_INT 1
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 4
96946: PUSH
96947: LD_INT 1
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: PUSH
96954: LD_INT 3
96956: PUSH
96957: LD_INT 0
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 3
96966: PUSH
96967: LD_INT 1
96969: NEG
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 3
96977: PUSH
96978: LD_INT 2
96980: NEG
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: LD_INT 5
96988: PUSH
96989: LD_INT 2
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 3
96998: PUSH
96999: LD_INT 3
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_INT 3
97008: PUSH
97009: LD_INT 2
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: LD_INT 4
97018: PUSH
97019: LD_INT 3
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 4
97028: PUSH
97029: LD_INT 4
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: LD_INT 3
97038: PUSH
97039: LD_INT 4
97041: PUSH
97042: EMPTY
97043: LIST
97044: LIST
97045: PUSH
97046: LD_INT 2
97048: PUSH
97049: LD_INT 3
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 2
97058: PUSH
97059: LD_INT 2
97061: PUSH
97062: EMPTY
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 4
97068: PUSH
97069: LD_INT 2
97071: PUSH
97072: EMPTY
97073: LIST
97074: LIST
97075: PUSH
97076: LD_INT 2
97078: PUSH
97079: LD_INT 4
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: LD_INT 0
97088: PUSH
97089: LD_INT 4
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: LD_INT 0
97098: PUSH
97099: LD_INT 3
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 1
97108: PUSH
97109: LD_INT 4
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PUSH
97116: LD_INT 1
97118: PUSH
97119: LD_INT 5
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 0
97128: PUSH
97129: LD_INT 5
97131: PUSH
97132: EMPTY
97133: LIST
97134: LIST
97135: PUSH
97136: LD_INT 1
97138: NEG
97139: PUSH
97140: LD_INT 4
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 1
97149: NEG
97150: PUSH
97151: LD_INT 3
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: PUSH
97158: LD_INT 2
97160: PUSH
97161: LD_INT 5
97163: PUSH
97164: EMPTY
97165: LIST
97166: LIST
97167: PUSH
97168: LD_INT 2
97170: NEG
97171: PUSH
97172: LD_INT 3
97174: PUSH
97175: EMPTY
97176: LIST
97177: LIST
97178: PUSH
97179: LD_INT 3
97181: NEG
97182: PUSH
97183: LD_INT 0
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: PUSH
97190: LD_INT 3
97192: NEG
97193: PUSH
97194: LD_INT 1
97196: NEG
97197: PUSH
97198: EMPTY
97199: LIST
97200: LIST
97201: PUSH
97202: LD_INT 2
97204: NEG
97205: PUSH
97206: LD_INT 0
97208: PUSH
97209: EMPTY
97210: LIST
97211: LIST
97212: PUSH
97213: LD_INT 2
97215: NEG
97216: PUSH
97217: LD_INT 1
97219: PUSH
97220: EMPTY
97221: LIST
97222: LIST
97223: PUSH
97224: LD_INT 3
97226: NEG
97227: PUSH
97228: LD_INT 1
97230: PUSH
97231: EMPTY
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 4
97237: NEG
97238: PUSH
97239: LD_INT 0
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 4
97248: NEG
97249: PUSH
97250: LD_INT 1
97252: NEG
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 4
97260: NEG
97261: PUSH
97262: LD_INT 2
97264: NEG
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: PUSH
97270: LD_INT 2
97272: NEG
97273: PUSH
97274: LD_INT 2
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: PUSH
97281: LD_INT 4
97283: NEG
97284: PUSH
97285: LD_INT 4
97287: NEG
97288: PUSH
97289: EMPTY
97290: LIST
97291: LIST
97292: PUSH
97293: LD_INT 4
97295: NEG
97296: PUSH
97297: LD_INT 5
97299: NEG
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: PUSH
97305: LD_INT 3
97307: NEG
97308: PUSH
97309: LD_INT 4
97311: NEG
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: LD_INT 3
97319: NEG
97320: PUSH
97321: LD_INT 3
97323: NEG
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: LD_INT 4
97331: NEG
97332: PUSH
97333: LD_INT 3
97335: NEG
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: PUSH
97341: LD_INT 5
97343: NEG
97344: PUSH
97345: LD_INT 4
97347: NEG
97348: PUSH
97349: EMPTY
97350: LIST
97351: LIST
97352: PUSH
97353: LD_INT 5
97355: NEG
97356: PUSH
97357: LD_INT 5
97359: NEG
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 3
97367: NEG
97368: PUSH
97369: LD_INT 5
97371: NEG
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: PUSH
97377: LD_INT 5
97379: NEG
97380: PUSH
97381: LD_INT 3
97383: NEG
97384: PUSH
97385: EMPTY
97386: LIST
97387: LIST
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
97436: LD_ADDR_VAR 0 30
97440: PUSH
97441: LD_INT 4
97443: PUSH
97444: LD_INT 4
97446: PUSH
97447: EMPTY
97448: LIST
97449: LIST
97450: PUSH
97451: LD_INT 4
97453: PUSH
97454: LD_INT 3
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: PUSH
97461: LD_INT 5
97463: PUSH
97464: LD_INT 4
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: PUSH
97471: LD_INT 5
97473: PUSH
97474: LD_INT 5
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: PUSH
97481: LD_INT 4
97483: PUSH
97484: LD_INT 5
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: LD_INT 3
97493: PUSH
97494: LD_INT 4
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 3
97503: PUSH
97504: LD_INT 3
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 5
97513: PUSH
97514: LD_INT 3
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: LD_INT 3
97523: PUSH
97524: LD_INT 5
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 0
97533: PUSH
97534: LD_INT 3
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 0
97543: PUSH
97544: LD_INT 2
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: PUSH
97551: LD_INT 1
97553: PUSH
97554: LD_INT 3
97556: PUSH
97557: EMPTY
97558: LIST
97559: LIST
97560: PUSH
97561: LD_INT 1
97563: PUSH
97564: LD_INT 4
97566: PUSH
97567: EMPTY
97568: LIST
97569: LIST
97570: PUSH
97571: LD_INT 0
97573: PUSH
97574: LD_INT 4
97576: PUSH
97577: EMPTY
97578: LIST
97579: LIST
97580: PUSH
97581: LD_INT 1
97583: NEG
97584: PUSH
97585: LD_INT 3
97587: PUSH
97588: EMPTY
97589: LIST
97590: LIST
97591: PUSH
97592: LD_INT 1
97594: NEG
97595: PUSH
97596: LD_INT 2
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: LD_INT 2
97605: PUSH
97606: LD_INT 4
97608: PUSH
97609: EMPTY
97610: LIST
97611: LIST
97612: PUSH
97613: LD_INT 2
97615: NEG
97616: PUSH
97617: LD_INT 2
97619: PUSH
97620: EMPTY
97621: LIST
97622: LIST
97623: PUSH
97624: LD_INT 4
97626: NEG
97627: PUSH
97628: LD_INT 0
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: PUSH
97635: LD_INT 4
97637: NEG
97638: PUSH
97639: LD_INT 1
97641: NEG
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: PUSH
97647: LD_INT 3
97649: NEG
97650: PUSH
97651: LD_INT 0
97653: PUSH
97654: EMPTY
97655: LIST
97656: LIST
97657: PUSH
97658: LD_INT 3
97660: NEG
97661: PUSH
97662: LD_INT 1
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: PUSH
97669: LD_INT 4
97671: NEG
97672: PUSH
97673: LD_INT 1
97675: PUSH
97676: EMPTY
97677: LIST
97678: LIST
97679: PUSH
97680: LD_INT 5
97682: NEG
97683: PUSH
97684: LD_INT 0
97686: PUSH
97687: EMPTY
97688: LIST
97689: LIST
97690: PUSH
97691: LD_INT 5
97693: NEG
97694: PUSH
97695: LD_INT 1
97697: NEG
97698: PUSH
97699: EMPTY
97700: LIST
97701: LIST
97702: PUSH
97703: LD_INT 5
97705: NEG
97706: PUSH
97707: LD_INT 2
97709: NEG
97710: PUSH
97711: EMPTY
97712: LIST
97713: LIST
97714: PUSH
97715: LD_INT 3
97717: NEG
97718: PUSH
97719: LD_INT 2
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 3
97728: NEG
97729: PUSH
97730: LD_INT 3
97732: NEG
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: LD_INT 3
97740: NEG
97741: PUSH
97742: LD_INT 4
97744: NEG
97745: PUSH
97746: EMPTY
97747: LIST
97748: LIST
97749: PUSH
97750: LD_INT 2
97752: NEG
97753: PUSH
97754: LD_INT 3
97756: NEG
97757: PUSH
97758: EMPTY
97759: LIST
97760: LIST
97761: PUSH
97762: LD_INT 2
97764: NEG
97765: PUSH
97766: LD_INT 2
97768: NEG
97769: PUSH
97770: EMPTY
97771: LIST
97772: LIST
97773: PUSH
97774: LD_INT 3
97776: NEG
97777: PUSH
97778: LD_INT 2
97780: NEG
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: PUSH
97786: LD_INT 4
97788: NEG
97789: PUSH
97790: LD_INT 3
97792: NEG
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 4
97800: NEG
97801: PUSH
97802: LD_INT 4
97804: NEG
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 2
97812: NEG
97813: PUSH
97814: LD_INT 4
97816: NEG
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: LD_INT 4
97824: NEG
97825: PUSH
97826: LD_INT 2
97828: NEG
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: PUSH
97834: LD_INT 0
97836: PUSH
97837: LD_INT 4
97839: NEG
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: PUSH
97845: LD_INT 0
97847: PUSH
97848: LD_INT 5
97850: NEG
97851: PUSH
97852: EMPTY
97853: LIST
97854: LIST
97855: PUSH
97856: LD_INT 1
97858: PUSH
97859: LD_INT 4
97861: NEG
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: PUSH
97867: LD_INT 1
97869: PUSH
97870: LD_INT 3
97872: NEG
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: LD_INT 0
97880: PUSH
97881: LD_INT 3
97883: NEG
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: LD_INT 1
97891: NEG
97892: PUSH
97893: LD_INT 4
97895: NEG
97896: PUSH
97897: EMPTY
97898: LIST
97899: LIST
97900: PUSH
97901: LD_INT 1
97903: NEG
97904: PUSH
97905: LD_INT 5
97907: NEG
97908: PUSH
97909: EMPTY
97910: LIST
97911: LIST
97912: PUSH
97913: LD_INT 2
97915: PUSH
97916: LD_INT 3
97918: NEG
97919: PUSH
97920: EMPTY
97921: LIST
97922: LIST
97923: PUSH
97924: LD_INT 2
97926: NEG
97927: PUSH
97928: LD_INT 5
97930: NEG
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: LIST
97943: LIST
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: LIST
97949: LIST
97950: LIST
97951: LIST
97952: LIST
97953: LIST
97954: LIST
97955: LIST
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
97983: LD_ADDR_VAR 0 31
97987: PUSH
97988: LD_INT 0
97990: PUSH
97991: LD_INT 4
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: PUSH
97998: LD_INT 0
98000: PUSH
98001: LD_INT 3
98003: PUSH
98004: EMPTY
98005: LIST
98006: LIST
98007: PUSH
98008: LD_INT 1
98010: PUSH
98011: LD_INT 4
98013: PUSH
98014: EMPTY
98015: LIST
98016: LIST
98017: PUSH
98018: LD_INT 1
98020: PUSH
98021: LD_INT 5
98023: PUSH
98024: EMPTY
98025: LIST
98026: LIST
98027: PUSH
98028: LD_INT 0
98030: PUSH
98031: LD_INT 5
98033: PUSH
98034: EMPTY
98035: LIST
98036: LIST
98037: PUSH
98038: LD_INT 1
98040: NEG
98041: PUSH
98042: LD_INT 4
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: PUSH
98049: LD_INT 1
98051: NEG
98052: PUSH
98053: LD_INT 3
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 2
98062: PUSH
98063: LD_INT 5
98065: PUSH
98066: EMPTY
98067: LIST
98068: LIST
98069: PUSH
98070: LD_INT 2
98072: NEG
98073: PUSH
98074: LD_INT 3
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 3
98083: NEG
98084: PUSH
98085: LD_INT 0
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PUSH
98092: LD_INT 3
98094: NEG
98095: PUSH
98096: LD_INT 1
98098: NEG
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PUSH
98104: LD_INT 2
98106: NEG
98107: PUSH
98108: LD_INT 0
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: LD_INT 2
98117: NEG
98118: PUSH
98119: LD_INT 1
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 3
98128: NEG
98129: PUSH
98130: LD_INT 1
98132: PUSH
98133: EMPTY
98134: LIST
98135: LIST
98136: PUSH
98137: LD_INT 4
98139: NEG
98140: PUSH
98141: LD_INT 0
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: PUSH
98148: LD_INT 4
98150: NEG
98151: PUSH
98152: LD_INT 1
98154: NEG
98155: PUSH
98156: EMPTY
98157: LIST
98158: LIST
98159: PUSH
98160: LD_INT 4
98162: NEG
98163: PUSH
98164: LD_INT 2
98166: NEG
98167: PUSH
98168: EMPTY
98169: LIST
98170: LIST
98171: PUSH
98172: LD_INT 2
98174: NEG
98175: PUSH
98176: LD_INT 2
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PUSH
98183: LD_INT 4
98185: NEG
98186: PUSH
98187: LD_INT 4
98189: NEG
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 4
98197: NEG
98198: PUSH
98199: LD_INT 5
98201: NEG
98202: PUSH
98203: EMPTY
98204: LIST
98205: LIST
98206: PUSH
98207: LD_INT 3
98209: NEG
98210: PUSH
98211: LD_INT 4
98213: NEG
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: LD_INT 3
98221: NEG
98222: PUSH
98223: LD_INT 3
98225: NEG
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: PUSH
98231: LD_INT 4
98233: NEG
98234: PUSH
98235: LD_INT 3
98237: NEG
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PUSH
98243: LD_INT 5
98245: NEG
98246: PUSH
98247: LD_INT 4
98249: NEG
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 5
98257: NEG
98258: PUSH
98259: LD_INT 5
98261: NEG
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: LD_INT 3
98269: NEG
98270: PUSH
98271: LD_INT 5
98273: NEG
98274: PUSH
98275: EMPTY
98276: LIST
98277: LIST
98278: PUSH
98279: LD_INT 5
98281: NEG
98282: PUSH
98283: LD_INT 3
98285: NEG
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PUSH
98291: LD_INT 0
98293: PUSH
98294: LD_INT 3
98296: NEG
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: PUSH
98302: LD_INT 0
98304: PUSH
98305: LD_INT 4
98307: NEG
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PUSH
98313: LD_INT 1
98315: PUSH
98316: LD_INT 3
98318: NEG
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: PUSH
98324: LD_INT 1
98326: PUSH
98327: LD_INT 2
98329: NEG
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: PUSH
98335: LD_INT 0
98337: PUSH
98338: LD_INT 2
98340: NEG
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 1
98348: NEG
98349: PUSH
98350: LD_INT 3
98352: NEG
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: PUSH
98358: LD_INT 1
98360: NEG
98361: PUSH
98362: LD_INT 4
98364: NEG
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: PUSH
98370: LD_INT 2
98372: PUSH
98373: LD_INT 2
98375: NEG
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PUSH
98381: LD_INT 2
98383: NEG
98384: PUSH
98385: LD_INT 4
98387: NEG
98388: PUSH
98389: EMPTY
98390: LIST
98391: LIST
98392: PUSH
98393: LD_INT 4
98395: PUSH
98396: LD_INT 0
98398: PUSH
98399: EMPTY
98400: LIST
98401: LIST
98402: PUSH
98403: LD_INT 4
98405: PUSH
98406: LD_INT 1
98408: NEG
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 5
98416: PUSH
98417: LD_INT 0
98419: PUSH
98420: EMPTY
98421: LIST
98422: LIST
98423: PUSH
98424: LD_INT 5
98426: PUSH
98427: LD_INT 1
98429: PUSH
98430: EMPTY
98431: LIST
98432: LIST
98433: PUSH
98434: LD_INT 4
98436: PUSH
98437: LD_INT 1
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: PUSH
98444: LD_INT 3
98446: PUSH
98447: LD_INT 0
98449: PUSH
98450: EMPTY
98451: LIST
98452: LIST
98453: PUSH
98454: LD_INT 3
98456: PUSH
98457: LD_INT 1
98459: NEG
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: PUSH
98465: LD_INT 3
98467: PUSH
98468: LD_INT 2
98470: NEG
98471: PUSH
98472: EMPTY
98473: LIST
98474: LIST
98475: PUSH
98476: LD_INT 5
98478: PUSH
98479: LD_INT 2
98481: PUSH
98482: EMPTY
98483: LIST
98484: LIST
98485: PUSH
98486: EMPTY
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: LIST
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
98533: LD_ADDR_VAR 0 32
98537: PUSH
98538: LD_INT 4
98540: NEG
98541: PUSH
98542: LD_INT 0
98544: PUSH
98545: EMPTY
98546: LIST
98547: LIST
98548: PUSH
98549: LD_INT 4
98551: NEG
98552: PUSH
98553: LD_INT 1
98555: NEG
98556: PUSH
98557: EMPTY
98558: LIST
98559: LIST
98560: PUSH
98561: LD_INT 3
98563: NEG
98564: PUSH
98565: LD_INT 0
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 3
98574: NEG
98575: PUSH
98576: LD_INT 1
98578: PUSH
98579: EMPTY
98580: LIST
98581: LIST
98582: PUSH
98583: LD_INT 4
98585: NEG
98586: PUSH
98587: LD_INT 1
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: LD_INT 5
98596: NEG
98597: PUSH
98598: LD_INT 0
98600: PUSH
98601: EMPTY
98602: LIST
98603: LIST
98604: PUSH
98605: LD_INT 5
98607: NEG
98608: PUSH
98609: LD_INT 1
98611: NEG
98612: PUSH
98613: EMPTY
98614: LIST
98615: LIST
98616: PUSH
98617: LD_INT 5
98619: NEG
98620: PUSH
98621: LD_INT 2
98623: NEG
98624: PUSH
98625: EMPTY
98626: LIST
98627: LIST
98628: PUSH
98629: LD_INT 3
98631: NEG
98632: PUSH
98633: LD_INT 2
98635: PUSH
98636: EMPTY
98637: LIST
98638: LIST
98639: PUSH
98640: LD_INT 3
98642: NEG
98643: PUSH
98644: LD_INT 3
98646: NEG
98647: PUSH
98648: EMPTY
98649: LIST
98650: LIST
98651: PUSH
98652: LD_INT 3
98654: NEG
98655: PUSH
98656: LD_INT 4
98658: NEG
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 2
98666: NEG
98667: PUSH
98668: LD_INT 3
98670: NEG
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_INT 2
98678: NEG
98679: PUSH
98680: LD_INT 2
98682: NEG
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 3
98690: NEG
98691: PUSH
98692: LD_INT 2
98694: NEG
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: LD_INT 4
98702: NEG
98703: PUSH
98704: LD_INT 3
98706: NEG
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 4
98714: NEG
98715: PUSH
98716: LD_INT 4
98718: NEG
98719: PUSH
98720: EMPTY
98721: LIST
98722: LIST
98723: PUSH
98724: LD_INT 2
98726: NEG
98727: PUSH
98728: LD_INT 4
98730: NEG
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 4
98738: NEG
98739: PUSH
98740: LD_INT 2
98742: NEG
98743: PUSH
98744: EMPTY
98745: LIST
98746: LIST
98747: PUSH
98748: LD_INT 0
98750: PUSH
98751: LD_INT 4
98753: NEG
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: PUSH
98759: LD_INT 0
98761: PUSH
98762: LD_INT 5
98764: NEG
98765: PUSH
98766: EMPTY
98767: LIST
98768: LIST
98769: PUSH
98770: LD_INT 1
98772: PUSH
98773: LD_INT 4
98775: NEG
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_INT 1
98783: PUSH
98784: LD_INT 3
98786: NEG
98787: PUSH
98788: EMPTY
98789: LIST
98790: LIST
98791: PUSH
98792: LD_INT 0
98794: PUSH
98795: LD_INT 3
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 1
98805: NEG
98806: PUSH
98807: LD_INT 4
98809: NEG
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: PUSH
98815: LD_INT 1
98817: NEG
98818: PUSH
98819: LD_INT 5
98821: NEG
98822: PUSH
98823: EMPTY
98824: LIST
98825: LIST
98826: PUSH
98827: LD_INT 2
98829: PUSH
98830: LD_INT 3
98832: NEG
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: PUSH
98838: LD_INT 2
98840: NEG
98841: PUSH
98842: LD_INT 5
98844: NEG
98845: PUSH
98846: EMPTY
98847: LIST
98848: LIST
98849: PUSH
98850: LD_INT 3
98852: PUSH
98853: LD_INT 0
98855: PUSH
98856: EMPTY
98857: LIST
98858: LIST
98859: PUSH
98860: LD_INT 3
98862: PUSH
98863: LD_INT 1
98865: NEG
98866: PUSH
98867: EMPTY
98868: LIST
98869: LIST
98870: PUSH
98871: LD_INT 4
98873: PUSH
98874: LD_INT 0
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_INT 4
98883: PUSH
98884: LD_INT 1
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: PUSH
98891: LD_INT 3
98893: PUSH
98894: LD_INT 1
98896: PUSH
98897: EMPTY
98898: LIST
98899: LIST
98900: PUSH
98901: LD_INT 2
98903: PUSH
98904: LD_INT 0
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: PUSH
98911: LD_INT 2
98913: PUSH
98914: LD_INT 1
98916: NEG
98917: PUSH
98918: EMPTY
98919: LIST
98920: LIST
98921: PUSH
98922: LD_INT 2
98924: PUSH
98925: LD_INT 2
98927: NEG
98928: PUSH
98929: EMPTY
98930: LIST
98931: LIST
98932: PUSH
98933: LD_INT 4
98935: PUSH
98936: LD_INT 2
98938: PUSH
98939: EMPTY
98940: LIST
98941: LIST
98942: PUSH
98943: LD_INT 4
98945: PUSH
98946: LD_INT 4
98948: PUSH
98949: EMPTY
98950: LIST
98951: LIST
98952: PUSH
98953: LD_INT 4
98955: PUSH
98956: LD_INT 3
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: PUSH
98963: LD_INT 5
98965: PUSH
98966: LD_INT 4
98968: PUSH
98969: EMPTY
98970: LIST
98971: LIST
98972: PUSH
98973: LD_INT 5
98975: PUSH
98976: LD_INT 5
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: PUSH
98983: LD_INT 4
98985: PUSH
98986: LD_INT 5
98988: PUSH
98989: EMPTY
98990: LIST
98991: LIST
98992: PUSH
98993: LD_INT 3
98995: PUSH
98996: LD_INT 4
98998: PUSH
98999: EMPTY
99000: LIST
99001: LIST
99002: PUSH
99003: LD_INT 3
99005: PUSH
99006: LD_INT 3
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PUSH
99013: LD_INT 5
99015: PUSH
99016: LD_INT 3
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: PUSH
99023: LD_INT 3
99025: PUSH
99026: LD_INT 5
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: EMPTY
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
99080: LD_ADDR_VAR 0 33
99084: PUSH
99085: LD_INT 4
99087: NEG
99088: PUSH
99089: LD_INT 4
99091: NEG
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: PUSH
99097: LD_INT 4
99099: NEG
99100: PUSH
99101: LD_INT 5
99103: NEG
99104: PUSH
99105: EMPTY
99106: LIST
99107: LIST
99108: PUSH
99109: LD_INT 3
99111: NEG
99112: PUSH
99113: LD_INT 4
99115: NEG
99116: PUSH
99117: EMPTY
99118: LIST
99119: LIST
99120: PUSH
99121: LD_INT 3
99123: NEG
99124: PUSH
99125: LD_INT 3
99127: NEG
99128: PUSH
99129: EMPTY
99130: LIST
99131: LIST
99132: PUSH
99133: LD_INT 4
99135: NEG
99136: PUSH
99137: LD_INT 3
99139: NEG
99140: PUSH
99141: EMPTY
99142: LIST
99143: LIST
99144: PUSH
99145: LD_INT 5
99147: NEG
99148: PUSH
99149: LD_INT 4
99151: NEG
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PUSH
99157: LD_INT 5
99159: NEG
99160: PUSH
99161: LD_INT 5
99163: NEG
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PUSH
99169: LD_INT 3
99171: NEG
99172: PUSH
99173: LD_INT 5
99175: NEG
99176: PUSH
99177: EMPTY
99178: LIST
99179: LIST
99180: PUSH
99181: LD_INT 5
99183: NEG
99184: PUSH
99185: LD_INT 3
99187: NEG
99188: PUSH
99189: EMPTY
99190: LIST
99191: LIST
99192: PUSH
99193: LD_INT 0
99195: PUSH
99196: LD_INT 3
99198: NEG
99199: PUSH
99200: EMPTY
99201: LIST
99202: LIST
99203: PUSH
99204: LD_INT 0
99206: PUSH
99207: LD_INT 4
99209: NEG
99210: PUSH
99211: EMPTY
99212: LIST
99213: LIST
99214: PUSH
99215: LD_INT 1
99217: PUSH
99218: LD_INT 3
99220: NEG
99221: PUSH
99222: EMPTY
99223: LIST
99224: LIST
99225: PUSH
99226: LD_INT 1
99228: PUSH
99229: LD_INT 2
99231: NEG
99232: PUSH
99233: EMPTY
99234: LIST
99235: LIST
99236: PUSH
99237: LD_INT 0
99239: PUSH
99240: LD_INT 2
99242: NEG
99243: PUSH
99244: EMPTY
99245: LIST
99246: LIST
99247: PUSH
99248: LD_INT 1
99250: NEG
99251: PUSH
99252: LD_INT 3
99254: NEG
99255: PUSH
99256: EMPTY
99257: LIST
99258: LIST
99259: PUSH
99260: LD_INT 1
99262: NEG
99263: PUSH
99264: LD_INT 4
99266: NEG
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PUSH
99272: LD_INT 2
99274: PUSH
99275: LD_INT 2
99277: NEG
99278: PUSH
99279: EMPTY
99280: LIST
99281: LIST
99282: PUSH
99283: LD_INT 2
99285: NEG
99286: PUSH
99287: LD_INT 4
99289: NEG
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: PUSH
99295: LD_INT 4
99297: PUSH
99298: LD_INT 0
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: PUSH
99305: LD_INT 4
99307: PUSH
99308: LD_INT 1
99310: NEG
99311: PUSH
99312: EMPTY
99313: LIST
99314: LIST
99315: PUSH
99316: LD_INT 5
99318: PUSH
99319: LD_INT 0
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: PUSH
99326: LD_INT 5
99328: PUSH
99329: LD_INT 1
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PUSH
99336: LD_INT 4
99338: PUSH
99339: LD_INT 1
99341: PUSH
99342: EMPTY
99343: LIST
99344: LIST
99345: PUSH
99346: LD_INT 3
99348: PUSH
99349: LD_INT 0
99351: PUSH
99352: EMPTY
99353: LIST
99354: LIST
99355: PUSH
99356: LD_INT 3
99358: PUSH
99359: LD_INT 1
99361: NEG
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: LD_INT 3
99369: PUSH
99370: LD_INT 2
99372: NEG
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: PUSH
99378: LD_INT 5
99380: PUSH
99381: LD_INT 2
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: PUSH
99388: LD_INT 3
99390: PUSH
99391: LD_INT 3
99393: PUSH
99394: EMPTY
99395: LIST
99396: LIST
99397: PUSH
99398: LD_INT 3
99400: PUSH
99401: LD_INT 2
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PUSH
99408: LD_INT 4
99410: PUSH
99411: LD_INT 3
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: PUSH
99418: LD_INT 4
99420: PUSH
99421: LD_INT 4
99423: PUSH
99424: EMPTY
99425: LIST
99426: LIST
99427: PUSH
99428: LD_INT 3
99430: PUSH
99431: LD_INT 4
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: PUSH
99438: LD_INT 2
99440: PUSH
99441: LD_INT 3
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PUSH
99448: LD_INT 2
99450: PUSH
99451: LD_INT 2
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PUSH
99458: LD_INT 4
99460: PUSH
99461: LD_INT 2
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: PUSH
99468: LD_INT 2
99470: PUSH
99471: LD_INT 4
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: PUSH
99478: LD_INT 0
99480: PUSH
99481: LD_INT 4
99483: PUSH
99484: EMPTY
99485: LIST
99486: LIST
99487: PUSH
99488: LD_INT 0
99490: PUSH
99491: LD_INT 3
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 1
99500: PUSH
99501: LD_INT 4
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: PUSH
99508: LD_INT 1
99510: PUSH
99511: LD_INT 5
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: PUSH
99518: LD_INT 0
99520: PUSH
99521: LD_INT 5
99523: PUSH
99524: EMPTY
99525: LIST
99526: LIST
99527: PUSH
99528: LD_INT 1
99530: NEG
99531: PUSH
99532: LD_INT 4
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: PUSH
99539: LD_INT 1
99541: NEG
99542: PUSH
99543: LD_INT 3
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: PUSH
99550: LD_INT 2
99552: PUSH
99553: LD_INT 5
99555: PUSH
99556: EMPTY
99557: LIST
99558: LIST
99559: PUSH
99560: LD_INT 2
99562: NEG
99563: PUSH
99564: LD_INT 3
99566: PUSH
99567: EMPTY
99568: LIST
99569: LIST
99570: PUSH
99571: EMPTY
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: LIST
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
99618: LD_ADDR_VAR 0 34
99622: PUSH
99623: LD_INT 0
99625: PUSH
99626: LD_INT 4
99628: NEG
99629: PUSH
99630: EMPTY
99631: LIST
99632: LIST
99633: PUSH
99634: LD_INT 0
99636: PUSH
99637: LD_INT 5
99639: NEG
99640: PUSH
99641: EMPTY
99642: LIST
99643: LIST
99644: PUSH
99645: LD_INT 1
99647: PUSH
99648: LD_INT 4
99650: NEG
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PUSH
99656: LD_INT 1
99658: PUSH
99659: LD_INT 3
99661: NEG
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: PUSH
99667: LD_INT 0
99669: PUSH
99670: LD_INT 3
99672: NEG
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: PUSH
99678: LD_INT 1
99680: NEG
99681: PUSH
99682: LD_INT 4
99684: NEG
99685: PUSH
99686: EMPTY
99687: LIST
99688: LIST
99689: PUSH
99690: LD_INT 1
99692: NEG
99693: PUSH
99694: LD_INT 5
99696: NEG
99697: PUSH
99698: EMPTY
99699: LIST
99700: LIST
99701: PUSH
99702: LD_INT 2
99704: PUSH
99705: LD_INT 3
99707: NEG
99708: PUSH
99709: EMPTY
99710: LIST
99711: LIST
99712: PUSH
99713: LD_INT 2
99715: NEG
99716: PUSH
99717: LD_INT 5
99719: NEG
99720: PUSH
99721: EMPTY
99722: LIST
99723: LIST
99724: PUSH
99725: LD_INT 3
99727: PUSH
99728: LD_INT 0
99730: PUSH
99731: EMPTY
99732: LIST
99733: LIST
99734: PUSH
99735: LD_INT 3
99737: PUSH
99738: LD_INT 1
99740: NEG
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: PUSH
99746: LD_INT 4
99748: PUSH
99749: LD_INT 0
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: PUSH
99756: LD_INT 4
99758: PUSH
99759: LD_INT 1
99761: PUSH
99762: EMPTY
99763: LIST
99764: LIST
99765: PUSH
99766: LD_INT 3
99768: PUSH
99769: LD_INT 1
99771: PUSH
99772: EMPTY
99773: LIST
99774: LIST
99775: PUSH
99776: LD_INT 2
99778: PUSH
99779: LD_INT 0
99781: PUSH
99782: EMPTY
99783: LIST
99784: LIST
99785: PUSH
99786: LD_INT 2
99788: PUSH
99789: LD_INT 1
99791: NEG
99792: PUSH
99793: EMPTY
99794: LIST
99795: LIST
99796: PUSH
99797: LD_INT 2
99799: PUSH
99800: LD_INT 2
99802: NEG
99803: PUSH
99804: EMPTY
99805: LIST
99806: LIST
99807: PUSH
99808: LD_INT 4
99810: PUSH
99811: LD_INT 2
99813: PUSH
99814: EMPTY
99815: LIST
99816: LIST
99817: PUSH
99818: LD_INT 4
99820: PUSH
99821: LD_INT 4
99823: PUSH
99824: EMPTY
99825: LIST
99826: LIST
99827: PUSH
99828: LD_INT 4
99830: PUSH
99831: LD_INT 3
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: PUSH
99838: LD_INT 5
99840: PUSH
99841: LD_INT 4
99843: PUSH
99844: EMPTY
99845: LIST
99846: LIST
99847: PUSH
99848: LD_INT 5
99850: PUSH
99851: LD_INT 5
99853: PUSH
99854: EMPTY
99855: LIST
99856: LIST
99857: PUSH
99858: LD_INT 4
99860: PUSH
99861: LD_INT 5
99863: PUSH
99864: EMPTY
99865: LIST
99866: LIST
99867: PUSH
99868: LD_INT 3
99870: PUSH
99871: LD_INT 4
99873: PUSH
99874: EMPTY
99875: LIST
99876: LIST
99877: PUSH
99878: LD_INT 3
99880: PUSH
99881: LD_INT 3
99883: PUSH
99884: EMPTY
99885: LIST
99886: LIST
99887: PUSH
99888: LD_INT 5
99890: PUSH
99891: LD_INT 3
99893: PUSH
99894: EMPTY
99895: LIST
99896: LIST
99897: PUSH
99898: LD_INT 3
99900: PUSH
99901: LD_INT 5
99903: PUSH
99904: EMPTY
99905: LIST
99906: LIST
99907: PUSH
99908: LD_INT 0
99910: PUSH
99911: LD_INT 3
99913: PUSH
99914: EMPTY
99915: LIST
99916: LIST
99917: PUSH
99918: LD_INT 0
99920: PUSH
99921: LD_INT 2
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PUSH
99928: LD_INT 1
99930: PUSH
99931: LD_INT 3
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: PUSH
99938: LD_INT 1
99940: PUSH
99941: LD_INT 4
99943: PUSH
99944: EMPTY
99945: LIST
99946: LIST
99947: PUSH
99948: LD_INT 0
99950: PUSH
99951: LD_INT 4
99953: PUSH
99954: EMPTY
99955: LIST
99956: LIST
99957: PUSH
99958: LD_INT 1
99960: NEG
99961: PUSH
99962: LD_INT 3
99964: PUSH
99965: EMPTY
99966: LIST
99967: LIST
99968: PUSH
99969: LD_INT 1
99971: NEG
99972: PUSH
99973: LD_INT 2
99975: PUSH
99976: EMPTY
99977: LIST
99978: LIST
99979: PUSH
99980: LD_INT 2
99982: PUSH
99983: LD_INT 4
99985: PUSH
99986: EMPTY
99987: LIST
99988: LIST
99989: PUSH
99990: LD_INT 2
99992: NEG
99993: PUSH
99994: LD_INT 2
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: PUSH
100001: LD_INT 4
100003: NEG
100004: PUSH
100005: LD_INT 0
100007: PUSH
100008: EMPTY
100009: LIST
100010: LIST
100011: PUSH
100012: LD_INT 4
100014: NEG
100015: PUSH
100016: LD_INT 1
100018: NEG
100019: PUSH
100020: EMPTY
100021: LIST
100022: LIST
100023: PUSH
100024: LD_INT 3
100026: NEG
100027: PUSH
100028: LD_INT 0
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PUSH
100035: LD_INT 3
100037: NEG
100038: PUSH
100039: LD_INT 1
100041: PUSH
100042: EMPTY
100043: LIST
100044: LIST
100045: PUSH
100046: LD_INT 4
100048: NEG
100049: PUSH
100050: LD_INT 1
100052: PUSH
100053: EMPTY
100054: LIST
100055: LIST
100056: PUSH
100057: LD_INT 5
100059: NEG
100060: PUSH
100061: LD_INT 0
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: PUSH
100068: LD_INT 5
100070: NEG
100071: PUSH
100072: LD_INT 1
100074: NEG
100075: PUSH
100076: EMPTY
100077: LIST
100078: LIST
100079: PUSH
100080: LD_INT 5
100082: NEG
100083: PUSH
100084: LD_INT 2
100086: NEG
100087: PUSH
100088: EMPTY
100089: LIST
100090: LIST
100091: PUSH
100092: LD_INT 3
100094: NEG
100095: PUSH
100096: LD_INT 2
100098: PUSH
100099: EMPTY
100100: LIST
100101: LIST
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: LIST
100112: LIST
100113: LIST
100114: LIST
100115: LIST
100116: LIST
100117: LIST
100118: LIST
100119: LIST
100120: LIST
100121: LIST
100122: LIST
100123: LIST
100124: LIST
100125: LIST
100126: LIST
100127: LIST
100128: LIST
100129: LIST
100130: LIST
100131: LIST
100132: LIST
100133: LIST
100134: LIST
100135: LIST
100136: LIST
100137: LIST
100138: LIST
100139: LIST
100140: LIST
100141: LIST
100142: LIST
100143: LIST
100144: LIST
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: ST_TO_ADDR
// end ; end ;
100150: GO 100153
100152: POP
// case btype of b_depot , b_warehouse :
100153: LD_VAR 0 1
100157: PUSH
100158: LD_INT 0
100160: DOUBLE
100161: EQUAL
100162: IFTRUE 100172
100164: LD_INT 1
100166: DOUBLE
100167: EQUAL
100168: IFTRUE 100172
100170: GO 100373
100172: POP
// case nation of nation_american :
100173: LD_VAR 0 5
100177: PUSH
100178: LD_INT 1
100180: DOUBLE
100181: EQUAL
100182: IFTRUE 100186
100184: GO 100242
100186: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
100187: LD_ADDR_VAR 0 9
100191: PUSH
100192: LD_VAR 0 11
100196: PUSH
100197: LD_VAR 0 12
100201: PUSH
100202: LD_VAR 0 13
100206: PUSH
100207: LD_VAR 0 14
100211: PUSH
100212: LD_VAR 0 15
100216: PUSH
100217: LD_VAR 0 16
100221: PUSH
100222: EMPTY
100223: LIST
100224: LIST
100225: LIST
100226: LIST
100227: LIST
100228: LIST
100229: PUSH
100230: LD_VAR 0 4
100234: PUSH
100235: LD_INT 1
100237: PLUS
100238: ARRAY
100239: ST_TO_ADDR
100240: GO 100371
100242: LD_INT 2
100244: DOUBLE
100245: EQUAL
100246: IFTRUE 100250
100248: GO 100306
100250: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
100251: LD_ADDR_VAR 0 9
100255: PUSH
100256: LD_VAR 0 17
100260: PUSH
100261: LD_VAR 0 18
100265: PUSH
100266: LD_VAR 0 19
100270: PUSH
100271: LD_VAR 0 20
100275: PUSH
100276: LD_VAR 0 21
100280: PUSH
100281: LD_VAR 0 22
100285: PUSH
100286: EMPTY
100287: LIST
100288: LIST
100289: LIST
100290: LIST
100291: LIST
100292: LIST
100293: PUSH
100294: LD_VAR 0 4
100298: PUSH
100299: LD_INT 1
100301: PLUS
100302: ARRAY
100303: ST_TO_ADDR
100304: GO 100371
100306: LD_INT 3
100308: DOUBLE
100309: EQUAL
100310: IFTRUE 100314
100312: GO 100370
100314: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
100315: LD_ADDR_VAR 0 9
100319: PUSH
100320: LD_VAR 0 23
100324: PUSH
100325: LD_VAR 0 24
100329: PUSH
100330: LD_VAR 0 25
100334: PUSH
100335: LD_VAR 0 26
100339: PUSH
100340: LD_VAR 0 27
100344: PUSH
100345: LD_VAR 0 28
100349: PUSH
100350: EMPTY
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: PUSH
100358: LD_VAR 0 4
100362: PUSH
100363: LD_INT 1
100365: PLUS
100366: ARRAY
100367: ST_TO_ADDR
100368: GO 100371
100370: POP
100371: GO 100926
100373: LD_INT 2
100375: DOUBLE
100376: EQUAL
100377: IFTRUE 100387
100379: LD_INT 3
100381: DOUBLE
100382: EQUAL
100383: IFTRUE 100387
100385: GO 100443
100387: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
100388: LD_ADDR_VAR 0 9
100392: PUSH
100393: LD_VAR 0 29
100397: PUSH
100398: LD_VAR 0 30
100402: PUSH
100403: LD_VAR 0 31
100407: PUSH
100408: LD_VAR 0 32
100412: PUSH
100413: LD_VAR 0 33
100417: PUSH
100418: LD_VAR 0 34
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: PUSH
100431: LD_VAR 0 4
100435: PUSH
100436: LD_INT 1
100438: PLUS
100439: ARRAY
100440: ST_TO_ADDR
100441: GO 100926
100443: LD_INT 16
100445: DOUBLE
100446: EQUAL
100447: IFTRUE 100505
100449: LD_INT 17
100451: DOUBLE
100452: EQUAL
100453: IFTRUE 100505
100455: LD_INT 18
100457: DOUBLE
100458: EQUAL
100459: IFTRUE 100505
100461: LD_INT 19
100463: DOUBLE
100464: EQUAL
100465: IFTRUE 100505
100467: LD_INT 22
100469: DOUBLE
100470: EQUAL
100471: IFTRUE 100505
100473: LD_INT 20
100475: DOUBLE
100476: EQUAL
100477: IFTRUE 100505
100479: LD_INT 21
100481: DOUBLE
100482: EQUAL
100483: IFTRUE 100505
100485: LD_INT 23
100487: DOUBLE
100488: EQUAL
100489: IFTRUE 100505
100491: LD_INT 24
100493: DOUBLE
100494: EQUAL
100495: IFTRUE 100505
100497: LD_INT 25
100499: DOUBLE
100500: EQUAL
100501: IFTRUE 100505
100503: GO 100561
100505: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
100506: LD_ADDR_VAR 0 9
100510: PUSH
100511: LD_VAR 0 35
100515: PUSH
100516: LD_VAR 0 36
100520: PUSH
100521: LD_VAR 0 37
100525: PUSH
100526: LD_VAR 0 38
100530: PUSH
100531: LD_VAR 0 39
100535: PUSH
100536: LD_VAR 0 40
100540: PUSH
100541: EMPTY
100542: LIST
100543: LIST
100544: LIST
100545: LIST
100546: LIST
100547: LIST
100548: PUSH
100549: LD_VAR 0 4
100553: PUSH
100554: LD_INT 1
100556: PLUS
100557: ARRAY
100558: ST_TO_ADDR
100559: GO 100926
100561: LD_INT 6
100563: DOUBLE
100564: EQUAL
100565: IFTRUE 100617
100567: LD_INT 7
100569: DOUBLE
100570: EQUAL
100571: IFTRUE 100617
100573: LD_INT 8
100575: DOUBLE
100576: EQUAL
100577: IFTRUE 100617
100579: LD_INT 13
100581: DOUBLE
100582: EQUAL
100583: IFTRUE 100617
100585: LD_INT 12
100587: DOUBLE
100588: EQUAL
100589: IFTRUE 100617
100591: LD_INT 15
100593: DOUBLE
100594: EQUAL
100595: IFTRUE 100617
100597: LD_INT 11
100599: DOUBLE
100600: EQUAL
100601: IFTRUE 100617
100603: LD_INT 14
100605: DOUBLE
100606: EQUAL
100607: IFTRUE 100617
100609: LD_INT 10
100611: DOUBLE
100612: EQUAL
100613: IFTRUE 100617
100615: GO 100673
100617: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
100618: LD_ADDR_VAR 0 9
100622: PUSH
100623: LD_VAR 0 41
100627: PUSH
100628: LD_VAR 0 42
100632: PUSH
100633: LD_VAR 0 43
100637: PUSH
100638: LD_VAR 0 44
100642: PUSH
100643: LD_VAR 0 45
100647: PUSH
100648: LD_VAR 0 46
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: PUSH
100661: LD_VAR 0 4
100665: PUSH
100666: LD_INT 1
100668: PLUS
100669: ARRAY
100670: ST_TO_ADDR
100671: GO 100926
100673: LD_INT 36
100675: DOUBLE
100676: EQUAL
100677: IFTRUE 100681
100679: GO 100737
100681: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
100682: LD_ADDR_VAR 0 9
100686: PUSH
100687: LD_VAR 0 47
100691: PUSH
100692: LD_VAR 0 48
100696: PUSH
100697: LD_VAR 0 49
100701: PUSH
100702: LD_VAR 0 50
100706: PUSH
100707: LD_VAR 0 51
100711: PUSH
100712: LD_VAR 0 52
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: LIST
100721: LIST
100722: LIST
100723: LIST
100724: PUSH
100725: LD_VAR 0 4
100729: PUSH
100730: LD_INT 1
100732: PLUS
100733: ARRAY
100734: ST_TO_ADDR
100735: GO 100926
100737: LD_INT 4
100739: DOUBLE
100740: EQUAL
100741: IFTRUE 100763
100743: LD_INT 5
100745: DOUBLE
100746: EQUAL
100747: IFTRUE 100763
100749: LD_INT 34
100751: DOUBLE
100752: EQUAL
100753: IFTRUE 100763
100755: LD_INT 37
100757: DOUBLE
100758: EQUAL
100759: IFTRUE 100763
100761: GO 100819
100763: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
100764: LD_ADDR_VAR 0 9
100768: PUSH
100769: LD_VAR 0 53
100773: PUSH
100774: LD_VAR 0 54
100778: PUSH
100779: LD_VAR 0 55
100783: PUSH
100784: LD_VAR 0 56
100788: PUSH
100789: LD_VAR 0 57
100793: PUSH
100794: LD_VAR 0 58
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: LIST
100803: LIST
100804: LIST
100805: LIST
100806: PUSH
100807: LD_VAR 0 4
100811: PUSH
100812: LD_INT 1
100814: PLUS
100815: ARRAY
100816: ST_TO_ADDR
100817: GO 100926
100819: LD_INT 31
100821: DOUBLE
100822: EQUAL
100823: IFTRUE 100869
100825: LD_INT 32
100827: DOUBLE
100828: EQUAL
100829: IFTRUE 100869
100831: LD_INT 33
100833: DOUBLE
100834: EQUAL
100835: IFTRUE 100869
100837: LD_INT 27
100839: DOUBLE
100840: EQUAL
100841: IFTRUE 100869
100843: LD_INT 26
100845: DOUBLE
100846: EQUAL
100847: IFTRUE 100869
100849: LD_INT 28
100851: DOUBLE
100852: EQUAL
100853: IFTRUE 100869
100855: LD_INT 29
100857: DOUBLE
100858: EQUAL
100859: IFTRUE 100869
100861: LD_INT 30
100863: DOUBLE
100864: EQUAL
100865: IFTRUE 100869
100867: GO 100925
100869: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
100870: LD_ADDR_VAR 0 9
100874: PUSH
100875: LD_VAR 0 59
100879: PUSH
100880: LD_VAR 0 60
100884: PUSH
100885: LD_VAR 0 61
100889: PUSH
100890: LD_VAR 0 62
100894: PUSH
100895: LD_VAR 0 63
100899: PUSH
100900: LD_VAR 0 64
100904: PUSH
100905: EMPTY
100906: LIST
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: LIST
100912: PUSH
100913: LD_VAR 0 4
100917: PUSH
100918: LD_INT 1
100920: PLUS
100921: ARRAY
100922: ST_TO_ADDR
100923: GO 100926
100925: POP
// temp_list2 = [ ] ;
100926: LD_ADDR_VAR 0 10
100930: PUSH
100931: EMPTY
100932: ST_TO_ADDR
// for i in temp_list do
100933: LD_ADDR_VAR 0 8
100937: PUSH
100938: LD_VAR 0 9
100942: PUSH
100943: FOR_IN
100944: IFFALSE 100996
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
100946: LD_ADDR_VAR 0 10
100950: PUSH
100951: LD_VAR 0 10
100955: PUSH
100956: LD_VAR 0 8
100960: PUSH
100961: LD_INT 1
100963: ARRAY
100964: PUSH
100965: LD_VAR 0 2
100969: PLUS
100970: PUSH
100971: LD_VAR 0 8
100975: PUSH
100976: LD_INT 2
100978: ARRAY
100979: PUSH
100980: LD_VAR 0 3
100984: PLUS
100985: PUSH
100986: EMPTY
100987: LIST
100988: LIST
100989: PUSH
100990: EMPTY
100991: LIST
100992: ADD
100993: ST_TO_ADDR
100994: GO 100943
100996: POP
100997: POP
// result = temp_list2 ;
100998: LD_ADDR_VAR 0 7
101002: PUSH
101003: LD_VAR 0 10
101007: ST_TO_ADDR
// end ;
101008: LD_VAR 0 7
101012: RET
// export function EnemyInRange ( unit , dist ) ; begin
101013: LD_INT 0
101015: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
101016: LD_ADDR_VAR 0 3
101020: PUSH
101021: LD_VAR 0 1
101025: PPUSH
101026: CALL_OW 255
101030: PPUSH
101031: LD_VAR 0 1
101035: PPUSH
101036: CALL_OW 250
101040: PPUSH
101041: LD_VAR 0 1
101045: PPUSH
101046: CALL_OW 251
101050: PPUSH
101051: LD_VAR 0 2
101055: PPUSH
101056: CALL 74415 0 4
101060: PUSH
101061: LD_INT 4
101063: ARRAY
101064: ST_TO_ADDR
// end ;
101065: LD_VAR 0 3
101069: RET
// export function PlayerSeeMe ( unit ) ; begin
101070: LD_INT 0
101072: PPUSH
// result := See ( your_side , unit ) ;
101073: LD_ADDR_VAR 0 2
101077: PUSH
101078: LD_OWVAR 2
101082: PPUSH
101083: LD_VAR 0 1
101087: PPUSH
101088: CALL_OW 292
101092: ST_TO_ADDR
// end ;
101093: LD_VAR 0 2
101097: RET
// export function ReverseDir ( unit ) ; begin
101098: LD_INT 0
101100: PPUSH
// if not unit then
101101: LD_VAR 0 1
101105: NOT
101106: IFFALSE 101110
// exit ;
101108: GO 101133
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
101110: LD_ADDR_VAR 0 2
101114: PUSH
101115: LD_VAR 0 1
101119: PPUSH
101120: CALL_OW 254
101124: PUSH
101125: LD_INT 3
101127: PLUS
101128: PUSH
101129: LD_INT 6
101131: MOD
101132: ST_TO_ADDR
// end ;
101133: LD_VAR 0 2
101137: RET
// export function ReverseArray ( array ) ; var i ; begin
101138: LD_INT 0
101140: PPUSH
101141: PPUSH
// if not array then
101142: LD_VAR 0 1
101146: NOT
101147: IFFALSE 101151
// exit ;
101149: GO 101206
// result := [ ] ;
101151: LD_ADDR_VAR 0 2
101155: PUSH
101156: EMPTY
101157: ST_TO_ADDR
// for i := array downto 1 do
101158: LD_ADDR_VAR 0 3
101162: PUSH
101163: DOUBLE
101164: LD_VAR 0 1
101168: INC
101169: ST_TO_ADDR
101170: LD_INT 1
101172: PUSH
101173: FOR_DOWNTO
101174: IFFALSE 101204
// result := Join ( result , array [ i ] ) ;
101176: LD_ADDR_VAR 0 2
101180: PUSH
101181: LD_VAR 0 2
101185: PPUSH
101186: LD_VAR 0 1
101190: PUSH
101191: LD_VAR 0 3
101195: ARRAY
101196: PPUSH
101197: CALL 105849 0 2
101201: ST_TO_ADDR
101202: GO 101173
101204: POP
101205: POP
// end ;
101206: LD_VAR 0 2
101210: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
101211: LD_INT 0
101213: PPUSH
101214: PPUSH
101215: PPUSH
101216: PPUSH
101217: PPUSH
101218: PPUSH
// if not unit or not hexes then
101219: LD_VAR 0 1
101223: NOT
101224: PUSH
101225: LD_VAR 0 2
101229: NOT
101230: OR
101231: IFFALSE 101235
// exit ;
101233: GO 101358
// dist := 9999 ;
101235: LD_ADDR_VAR 0 5
101239: PUSH
101240: LD_INT 9999
101242: ST_TO_ADDR
// for i = 1 to hexes do
101243: LD_ADDR_VAR 0 4
101247: PUSH
101248: DOUBLE
101249: LD_INT 1
101251: DEC
101252: ST_TO_ADDR
101253: LD_VAR 0 2
101257: PUSH
101258: FOR_TO
101259: IFFALSE 101346
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
101261: LD_ADDR_VAR 0 6
101265: PUSH
101266: LD_VAR 0 1
101270: PPUSH
101271: LD_VAR 0 2
101275: PUSH
101276: LD_VAR 0 4
101280: ARRAY
101281: PUSH
101282: LD_INT 1
101284: ARRAY
101285: PPUSH
101286: LD_VAR 0 2
101290: PUSH
101291: LD_VAR 0 4
101295: ARRAY
101296: PUSH
101297: LD_INT 2
101299: ARRAY
101300: PPUSH
101301: CALL_OW 297
101305: ST_TO_ADDR
// if tdist < dist then
101306: LD_VAR 0 6
101310: PUSH
101311: LD_VAR 0 5
101315: LESS
101316: IFFALSE 101344
// begin hex := hexes [ i ] ;
101318: LD_ADDR_VAR 0 8
101322: PUSH
101323: LD_VAR 0 2
101327: PUSH
101328: LD_VAR 0 4
101332: ARRAY
101333: ST_TO_ADDR
// dist := tdist ;
101334: LD_ADDR_VAR 0 5
101338: PUSH
101339: LD_VAR 0 6
101343: ST_TO_ADDR
// end ; end ;
101344: GO 101258
101346: POP
101347: POP
// result := hex ;
101348: LD_ADDR_VAR 0 3
101352: PUSH
101353: LD_VAR 0 8
101357: ST_TO_ADDR
// end ;
101358: LD_VAR 0 3
101362: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
101363: LD_INT 0
101365: PPUSH
101366: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
101367: LD_VAR 0 1
101371: NOT
101372: PUSH
101373: LD_VAR 0 1
101377: PUSH
101378: LD_INT 21
101380: PUSH
101381: LD_INT 2
101383: PUSH
101384: EMPTY
101385: LIST
101386: LIST
101387: PUSH
101388: LD_INT 23
101390: PUSH
101391: LD_INT 2
101393: PUSH
101394: EMPTY
101395: LIST
101396: LIST
101397: PUSH
101398: EMPTY
101399: LIST
101400: LIST
101401: PPUSH
101402: CALL_OW 69
101406: IN
101407: NOT
101408: OR
101409: IFFALSE 101413
// exit ;
101411: GO 101460
// for i = 1 to 3 do
101413: LD_ADDR_VAR 0 3
101417: PUSH
101418: DOUBLE
101419: LD_INT 1
101421: DEC
101422: ST_TO_ADDR
101423: LD_INT 3
101425: PUSH
101426: FOR_TO
101427: IFFALSE 101458
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
101429: LD_VAR 0 1
101433: PPUSH
101434: CALL_OW 250
101438: PPUSH
101439: LD_VAR 0 1
101443: PPUSH
101444: CALL_OW 251
101448: PPUSH
101449: LD_INT 1
101451: PPUSH
101452: CALL_OW 453
101456: GO 101426
101458: POP
101459: POP
// end ;
101460: LD_VAR 0 2
101464: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
101465: LD_INT 0
101467: PPUSH
101468: PPUSH
101469: PPUSH
101470: PPUSH
101471: PPUSH
101472: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
101473: LD_VAR 0 1
101477: NOT
101478: PUSH
101479: LD_VAR 0 2
101483: NOT
101484: OR
101485: PUSH
101486: LD_VAR 0 1
101490: PPUSH
101491: CALL_OW 314
101495: OR
101496: IFFALSE 101500
// exit ;
101498: GO 101967
// if GetLives ( i ) < 250 then
101500: LD_VAR 0 4
101504: PPUSH
101505: CALL_OW 256
101509: PUSH
101510: LD_INT 250
101512: LESS
101513: IFFALSE 101526
// begin ComAutodestruct ( i ) ;
101515: LD_VAR 0 4
101519: PPUSH
101520: CALL 101363 0 1
// exit ;
101524: GO 101967
// end ; x := GetX ( enemy_unit ) ;
101526: LD_ADDR_VAR 0 7
101530: PUSH
101531: LD_VAR 0 2
101535: PPUSH
101536: CALL_OW 250
101540: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
101541: LD_ADDR_VAR 0 8
101545: PUSH
101546: LD_VAR 0 2
101550: PPUSH
101551: CALL_OW 251
101555: ST_TO_ADDR
// if not x or not y then
101556: LD_VAR 0 7
101560: NOT
101561: PUSH
101562: LD_VAR 0 8
101566: NOT
101567: OR
101568: IFFALSE 101572
// exit ;
101570: GO 101967
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
101572: LD_ADDR_VAR 0 6
101576: PUSH
101577: LD_VAR 0 7
101581: PPUSH
101582: LD_INT 0
101584: PPUSH
101585: LD_INT 4
101587: PPUSH
101588: CALL_OW 272
101592: PUSH
101593: LD_VAR 0 8
101597: PPUSH
101598: LD_INT 0
101600: PPUSH
101601: LD_INT 4
101603: PPUSH
101604: CALL_OW 273
101608: PUSH
101609: EMPTY
101610: LIST
101611: LIST
101612: PUSH
101613: LD_VAR 0 7
101617: PPUSH
101618: LD_INT 1
101620: PPUSH
101621: LD_INT 4
101623: PPUSH
101624: CALL_OW 272
101628: PUSH
101629: LD_VAR 0 8
101633: PPUSH
101634: LD_INT 1
101636: PPUSH
101637: LD_INT 4
101639: PPUSH
101640: CALL_OW 273
101644: PUSH
101645: EMPTY
101646: LIST
101647: LIST
101648: PUSH
101649: LD_VAR 0 7
101653: PPUSH
101654: LD_INT 2
101656: PPUSH
101657: LD_INT 4
101659: PPUSH
101660: CALL_OW 272
101664: PUSH
101665: LD_VAR 0 8
101669: PPUSH
101670: LD_INT 2
101672: PPUSH
101673: LD_INT 4
101675: PPUSH
101676: CALL_OW 273
101680: PUSH
101681: EMPTY
101682: LIST
101683: LIST
101684: PUSH
101685: LD_VAR 0 7
101689: PPUSH
101690: LD_INT 3
101692: PPUSH
101693: LD_INT 4
101695: PPUSH
101696: CALL_OW 272
101700: PUSH
101701: LD_VAR 0 8
101705: PPUSH
101706: LD_INT 3
101708: PPUSH
101709: LD_INT 4
101711: PPUSH
101712: CALL_OW 273
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PUSH
101721: LD_VAR 0 7
101725: PPUSH
101726: LD_INT 4
101728: PPUSH
101729: LD_INT 4
101731: PPUSH
101732: CALL_OW 272
101736: PUSH
101737: LD_VAR 0 8
101741: PPUSH
101742: LD_INT 4
101744: PPUSH
101745: LD_INT 4
101747: PPUSH
101748: CALL_OW 273
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: PUSH
101757: LD_VAR 0 7
101761: PPUSH
101762: LD_INT 5
101764: PPUSH
101765: LD_INT 4
101767: PPUSH
101768: CALL_OW 272
101772: PUSH
101773: LD_VAR 0 8
101777: PPUSH
101778: LD_INT 5
101780: PPUSH
101781: LD_INT 4
101783: PPUSH
101784: CALL_OW 273
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: PUSH
101793: EMPTY
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: LIST
101800: ST_TO_ADDR
// for i = tmp downto 1 do
101801: LD_ADDR_VAR 0 4
101805: PUSH
101806: DOUBLE
101807: LD_VAR 0 6
101811: INC
101812: ST_TO_ADDR
101813: LD_INT 1
101815: PUSH
101816: FOR_DOWNTO
101817: IFFALSE 101918
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
101819: LD_VAR 0 6
101823: PUSH
101824: LD_VAR 0 4
101828: ARRAY
101829: PUSH
101830: LD_INT 1
101832: ARRAY
101833: PPUSH
101834: LD_VAR 0 6
101838: PUSH
101839: LD_VAR 0 4
101843: ARRAY
101844: PUSH
101845: LD_INT 2
101847: ARRAY
101848: PPUSH
101849: CALL_OW 488
101853: NOT
101854: PUSH
101855: LD_VAR 0 6
101859: PUSH
101860: LD_VAR 0 4
101864: ARRAY
101865: PUSH
101866: LD_INT 1
101868: ARRAY
101869: PPUSH
101870: LD_VAR 0 6
101874: PUSH
101875: LD_VAR 0 4
101879: ARRAY
101880: PUSH
101881: LD_INT 2
101883: ARRAY
101884: PPUSH
101885: CALL_OW 428
101889: PUSH
101890: LD_INT 0
101892: NONEQUAL
101893: OR
101894: IFFALSE 101916
// tmp := Delete ( tmp , i ) ;
101896: LD_ADDR_VAR 0 6
101900: PUSH
101901: LD_VAR 0 6
101905: PPUSH
101906: LD_VAR 0 4
101910: PPUSH
101911: CALL_OW 3
101915: ST_TO_ADDR
101916: GO 101816
101918: POP
101919: POP
// j := GetClosestHex ( unit , tmp ) ;
101920: LD_ADDR_VAR 0 5
101924: PUSH
101925: LD_VAR 0 1
101929: PPUSH
101930: LD_VAR 0 6
101934: PPUSH
101935: CALL 101211 0 2
101939: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
101940: LD_VAR 0 1
101944: PPUSH
101945: LD_VAR 0 5
101949: PUSH
101950: LD_INT 1
101952: ARRAY
101953: PPUSH
101954: LD_VAR 0 5
101958: PUSH
101959: LD_INT 2
101961: ARRAY
101962: PPUSH
101963: CALL_OW 111
// end ;
101967: LD_VAR 0 3
101971: RET
// export function PrepareApemanSoldier ( ) ; begin
101972: LD_INT 0
101974: PPUSH
// uc_nation := 0 ;
101975: LD_ADDR_OWVAR 21
101979: PUSH
101980: LD_INT 0
101982: ST_TO_ADDR
// hc_sex := sex_male ;
101983: LD_ADDR_OWVAR 27
101987: PUSH
101988: LD_INT 1
101990: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
101991: LD_ADDR_OWVAR 28
101995: PUSH
101996: LD_INT 15
101998: ST_TO_ADDR
// hc_gallery :=  ;
101999: LD_ADDR_OWVAR 33
102003: PUSH
102004: LD_STRING 
102006: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102007: LD_ADDR_OWVAR 31
102011: PUSH
102012: LD_INT 0
102014: PPUSH
102015: LD_INT 3
102017: PPUSH
102018: CALL_OW 12
102022: PUSH
102023: LD_INT 0
102025: PPUSH
102026: LD_INT 3
102028: PPUSH
102029: CALL_OW 12
102033: PUSH
102034: LD_INT 0
102036: PUSH
102037: LD_INT 0
102039: PUSH
102040: EMPTY
102041: LIST
102042: LIST
102043: LIST
102044: LIST
102045: ST_TO_ADDR
// end ;
102046: LD_VAR 0 1
102050: RET
// export function PrepareApemanEngineer ( ) ; begin
102051: LD_INT 0
102053: PPUSH
// uc_nation := 0 ;
102054: LD_ADDR_OWVAR 21
102058: PUSH
102059: LD_INT 0
102061: ST_TO_ADDR
// hc_sex := sex_male ;
102062: LD_ADDR_OWVAR 27
102066: PUSH
102067: LD_INT 1
102069: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
102070: LD_ADDR_OWVAR 28
102074: PUSH
102075: LD_INT 16
102077: ST_TO_ADDR
// hc_gallery :=  ;
102078: LD_ADDR_OWVAR 33
102082: PUSH
102083: LD_STRING 
102085: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102086: LD_ADDR_OWVAR 31
102090: PUSH
102091: LD_INT 0
102093: PPUSH
102094: LD_INT 3
102096: PPUSH
102097: CALL_OW 12
102101: PUSH
102102: LD_INT 0
102104: PPUSH
102105: LD_INT 3
102107: PPUSH
102108: CALL_OW 12
102112: PUSH
102113: LD_INT 0
102115: PUSH
102116: LD_INT 0
102118: PUSH
102119: EMPTY
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: ST_TO_ADDR
// end ;
102125: LD_VAR 0 1
102129: RET
// export function PrepareApeman ( agressivity ) ; begin
102130: LD_INT 0
102132: PPUSH
// uc_side := 0 ;
102133: LD_ADDR_OWVAR 20
102137: PUSH
102138: LD_INT 0
102140: ST_TO_ADDR
// uc_nation := 0 ;
102141: LD_ADDR_OWVAR 21
102145: PUSH
102146: LD_INT 0
102148: ST_TO_ADDR
// hc_sex := sex_male ;
102149: LD_ADDR_OWVAR 27
102153: PUSH
102154: LD_INT 1
102156: ST_TO_ADDR
// hc_class := class_apeman ;
102157: LD_ADDR_OWVAR 28
102161: PUSH
102162: LD_INT 12
102164: ST_TO_ADDR
// hc_gallery :=  ;
102165: LD_ADDR_OWVAR 33
102169: PUSH
102170: LD_STRING 
102172: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102173: LD_ADDR_OWVAR 35
102177: PUSH
102178: LD_VAR 0 1
102182: NEG
102183: PPUSH
102184: LD_VAR 0 1
102188: PPUSH
102189: CALL_OW 12
102193: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102194: LD_ADDR_OWVAR 31
102198: PUSH
102199: LD_INT 0
102201: PPUSH
102202: LD_INT 3
102204: PPUSH
102205: CALL_OW 12
102209: PUSH
102210: LD_INT 0
102212: PPUSH
102213: LD_INT 3
102215: PPUSH
102216: CALL_OW 12
102220: PUSH
102221: LD_INT 0
102223: PUSH
102224: LD_INT 0
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: ST_TO_ADDR
// end ;
102233: LD_VAR 0 2
102237: RET
// export function PrepareTiger ( agressivity ) ; begin
102238: LD_INT 0
102240: PPUSH
// uc_side := 0 ;
102241: LD_ADDR_OWVAR 20
102245: PUSH
102246: LD_INT 0
102248: ST_TO_ADDR
// uc_nation := 0 ;
102249: LD_ADDR_OWVAR 21
102253: PUSH
102254: LD_INT 0
102256: ST_TO_ADDR
// hc_class := class_tiger ;
102257: LD_ADDR_OWVAR 28
102261: PUSH
102262: LD_INT 14
102264: ST_TO_ADDR
// hc_gallery :=  ;
102265: LD_ADDR_OWVAR 33
102269: PUSH
102270: LD_STRING 
102272: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102273: LD_ADDR_OWVAR 35
102277: PUSH
102278: LD_VAR 0 1
102282: NEG
102283: PPUSH
102284: LD_VAR 0 1
102288: PPUSH
102289: CALL_OW 12
102293: ST_TO_ADDR
// end ;
102294: LD_VAR 0 2
102298: RET
// export function PrepareEnchidna ( ) ; begin
102299: LD_INT 0
102301: PPUSH
// uc_side := 0 ;
102302: LD_ADDR_OWVAR 20
102306: PUSH
102307: LD_INT 0
102309: ST_TO_ADDR
// uc_nation := 0 ;
102310: LD_ADDR_OWVAR 21
102314: PUSH
102315: LD_INT 0
102317: ST_TO_ADDR
// hc_class := class_baggie ;
102318: LD_ADDR_OWVAR 28
102322: PUSH
102323: LD_INT 13
102325: ST_TO_ADDR
// hc_gallery :=  ;
102326: LD_ADDR_OWVAR 33
102330: PUSH
102331: LD_STRING 
102333: ST_TO_ADDR
// end ;
102334: LD_VAR 0 1
102338: RET
// export function PrepareFrog ( ) ; begin
102339: LD_INT 0
102341: PPUSH
// uc_side := 0 ;
102342: LD_ADDR_OWVAR 20
102346: PUSH
102347: LD_INT 0
102349: ST_TO_ADDR
// uc_nation := 0 ;
102350: LD_ADDR_OWVAR 21
102354: PUSH
102355: LD_INT 0
102357: ST_TO_ADDR
// hc_class := class_frog ;
102358: LD_ADDR_OWVAR 28
102362: PUSH
102363: LD_INT 19
102365: ST_TO_ADDR
// hc_gallery :=  ;
102366: LD_ADDR_OWVAR 33
102370: PUSH
102371: LD_STRING 
102373: ST_TO_ADDR
// end ;
102374: LD_VAR 0 1
102378: RET
// export function PrepareFish ( ) ; begin
102379: LD_INT 0
102381: PPUSH
// uc_side := 0 ;
102382: LD_ADDR_OWVAR 20
102386: PUSH
102387: LD_INT 0
102389: ST_TO_ADDR
// uc_nation := 0 ;
102390: LD_ADDR_OWVAR 21
102394: PUSH
102395: LD_INT 0
102397: ST_TO_ADDR
// hc_class := class_fish ;
102398: LD_ADDR_OWVAR 28
102402: PUSH
102403: LD_INT 20
102405: ST_TO_ADDR
// hc_gallery :=  ;
102406: LD_ADDR_OWVAR 33
102410: PUSH
102411: LD_STRING 
102413: ST_TO_ADDR
// end ;
102414: LD_VAR 0 1
102418: RET
// export function PrepareBird ( ) ; begin
102419: LD_INT 0
102421: PPUSH
// uc_side := 0 ;
102422: LD_ADDR_OWVAR 20
102426: PUSH
102427: LD_INT 0
102429: ST_TO_ADDR
// uc_nation := 0 ;
102430: LD_ADDR_OWVAR 21
102434: PUSH
102435: LD_INT 0
102437: ST_TO_ADDR
// hc_class := class_phororhacos ;
102438: LD_ADDR_OWVAR 28
102442: PUSH
102443: LD_INT 18
102445: ST_TO_ADDR
// hc_gallery :=  ;
102446: LD_ADDR_OWVAR 33
102450: PUSH
102451: LD_STRING 
102453: ST_TO_ADDR
// end ;
102454: LD_VAR 0 1
102458: RET
// export function PrepareHorse ( ) ; begin
102459: LD_INT 0
102461: PPUSH
// uc_side := 0 ;
102462: LD_ADDR_OWVAR 20
102466: PUSH
102467: LD_INT 0
102469: ST_TO_ADDR
// uc_nation := 0 ;
102470: LD_ADDR_OWVAR 21
102474: PUSH
102475: LD_INT 0
102477: ST_TO_ADDR
// hc_class := class_horse ;
102478: LD_ADDR_OWVAR 28
102482: PUSH
102483: LD_INT 21
102485: ST_TO_ADDR
// hc_gallery :=  ;
102486: LD_ADDR_OWVAR 33
102490: PUSH
102491: LD_STRING 
102493: ST_TO_ADDR
// end ;
102494: LD_VAR 0 1
102498: RET
// export function PrepareMastodont ( ) ; begin
102499: LD_INT 0
102501: PPUSH
// uc_side := 0 ;
102502: LD_ADDR_OWVAR 20
102506: PUSH
102507: LD_INT 0
102509: ST_TO_ADDR
// uc_nation := 0 ;
102510: LD_ADDR_OWVAR 21
102514: PUSH
102515: LD_INT 0
102517: ST_TO_ADDR
// vc_chassis := class_mastodont ;
102518: LD_ADDR_OWVAR 37
102522: PUSH
102523: LD_INT 31
102525: ST_TO_ADDR
// vc_control := control_rider ;
102526: LD_ADDR_OWVAR 38
102530: PUSH
102531: LD_INT 4
102533: ST_TO_ADDR
// end ;
102534: LD_VAR 0 1
102538: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
102539: LD_INT 0
102541: PPUSH
102542: PPUSH
102543: PPUSH
// uc_side = 0 ;
102544: LD_ADDR_OWVAR 20
102548: PUSH
102549: LD_INT 0
102551: ST_TO_ADDR
// uc_nation = 0 ;
102552: LD_ADDR_OWVAR 21
102556: PUSH
102557: LD_INT 0
102559: ST_TO_ADDR
// InitHc_All ( ) ;
102560: CALL_OW 584
// InitVc ;
102564: CALL_OW 20
// if mastodonts then
102568: LD_VAR 0 6
102572: IFFALSE 102639
// for i = 1 to mastodonts do
102574: LD_ADDR_VAR 0 11
102578: PUSH
102579: DOUBLE
102580: LD_INT 1
102582: DEC
102583: ST_TO_ADDR
102584: LD_VAR 0 6
102588: PUSH
102589: FOR_TO
102590: IFFALSE 102637
// begin vc_chassis := 31 ;
102592: LD_ADDR_OWVAR 37
102596: PUSH
102597: LD_INT 31
102599: ST_TO_ADDR
// vc_control := control_rider ;
102600: LD_ADDR_OWVAR 38
102604: PUSH
102605: LD_INT 4
102607: ST_TO_ADDR
// animal := CreateVehicle ;
102608: LD_ADDR_VAR 0 12
102612: PUSH
102613: CALL_OW 45
102617: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102618: LD_VAR 0 12
102622: PPUSH
102623: LD_VAR 0 8
102627: PPUSH
102628: LD_INT 0
102630: PPUSH
102631: CALL 104767 0 3
// end ;
102635: GO 102589
102637: POP
102638: POP
// if horses then
102639: LD_VAR 0 5
102643: IFFALSE 102710
// for i = 1 to horses do
102645: LD_ADDR_VAR 0 11
102649: PUSH
102650: DOUBLE
102651: LD_INT 1
102653: DEC
102654: ST_TO_ADDR
102655: LD_VAR 0 5
102659: PUSH
102660: FOR_TO
102661: IFFALSE 102708
// begin hc_class := 21 ;
102663: LD_ADDR_OWVAR 28
102667: PUSH
102668: LD_INT 21
102670: ST_TO_ADDR
// hc_gallery :=  ;
102671: LD_ADDR_OWVAR 33
102675: PUSH
102676: LD_STRING 
102678: ST_TO_ADDR
// animal := CreateHuman ;
102679: LD_ADDR_VAR 0 12
102683: PUSH
102684: CALL_OW 44
102688: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102689: LD_VAR 0 12
102693: PPUSH
102694: LD_VAR 0 8
102698: PPUSH
102699: LD_INT 0
102701: PPUSH
102702: CALL 104767 0 3
// end ;
102706: GO 102660
102708: POP
102709: POP
// if birds then
102710: LD_VAR 0 1
102714: IFFALSE 102781
// for i = 1 to birds do
102716: LD_ADDR_VAR 0 11
102720: PUSH
102721: DOUBLE
102722: LD_INT 1
102724: DEC
102725: ST_TO_ADDR
102726: LD_VAR 0 1
102730: PUSH
102731: FOR_TO
102732: IFFALSE 102779
// begin hc_class = 18 ;
102734: LD_ADDR_OWVAR 28
102738: PUSH
102739: LD_INT 18
102741: ST_TO_ADDR
// hc_gallery =  ;
102742: LD_ADDR_OWVAR 33
102746: PUSH
102747: LD_STRING 
102749: ST_TO_ADDR
// animal := CreateHuman ;
102750: LD_ADDR_VAR 0 12
102754: PUSH
102755: CALL_OW 44
102759: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102760: LD_VAR 0 12
102764: PPUSH
102765: LD_VAR 0 8
102769: PPUSH
102770: LD_INT 0
102772: PPUSH
102773: CALL 104767 0 3
// end ;
102777: GO 102731
102779: POP
102780: POP
// if tigers then
102781: LD_VAR 0 2
102785: IFFALSE 102869
// for i = 1 to tigers do
102787: LD_ADDR_VAR 0 11
102791: PUSH
102792: DOUBLE
102793: LD_INT 1
102795: DEC
102796: ST_TO_ADDR
102797: LD_VAR 0 2
102801: PUSH
102802: FOR_TO
102803: IFFALSE 102867
// begin hc_class = class_tiger ;
102805: LD_ADDR_OWVAR 28
102809: PUSH
102810: LD_INT 14
102812: ST_TO_ADDR
// hc_gallery =  ;
102813: LD_ADDR_OWVAR 33
102817: PUSH
102818: LD_STRING 
102820: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
102821: LD_ADDR_OWVAR 35
102825: PUSH
102826: LD_INT 7
102828: NEG
102829: PPUSH
102830: LD_INT 7
102832: PPUSH
102833: CALL_OW 12
102837: ST_TO_ADDR
// animal := CreateHuman ;
102838: LD_ADDR_VAR 0 12
102842: PUSH
102843: CALL_OW 44
102847: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102848: LD_VAR 0 12
102852: PPUSH
102853: LD_VAR 0 8
102857: PPUSH
102858: LD_INT 0
102860: PPUSH
102861: CALL 104767 0 3
// end ;
102865: GO 102802
102867: POP
102868: POP
// if apemans then
102869: LD_VAR 0 3
102873: IFFALSE 102996
// for i = 1 to apemans do
102875: LD_ADDR_VAR 0 11
102879: PUSH
102880: DOUBLE
102881: LD_INT 1
102883: DEC
102884: ST_TO_ADDR
102885: LD_VAR 0 3
102889: PUSH
102890: FOR_TO
102891: IFFALSE 102994
// begin hc_class = class_apeman ;
102893: LD_ADDR_OWVAR 28
102897: PUSH
102898: LD_INT 12
102900: ST_TO_ADDR
// hc_gallery =  ;
102901: LD_ADDR_OWVAR 33
102905: PUSH
102906: LD_STRING 
102908: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
102909: LD_ADDR_OWVAR 35
102913: PUSH
102914: LD_INT 2
102916: NEG
102917: PPUSH
102918: LD_INT 2
102920: PPUSH
102921: CALL_OW 12
102925: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
102926: LD_ADDR_OWVAR 31
102930: PUSH
102931: LD_INT 1
102933: PPUSH
102934: LD_INT 3
102936: PPUSH
102937: CALL_OW 12
102941: PUSH
102942: LD_INT 1
102944: PPUSH
102945: LD_INT 3
102947: PPUSH
102948: CALL_OW 12
102952: PUSH
102953: LD_INT 0
102955: PUSH
102956: LD_INT 0
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: LIST
102963: LIST
102964: ST_TO_ADDR
// animal := CreateHuman ;
102965: LD_ADDR_VAR 0 12
102969: PUSH
102970: CALL_OW 44
102974: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102975: LD_VAR 0 12
102979: PPUSH
102980: LD_VAR 0 8
102984: PPUSH
102985: LD_INT 0
102987: PPUSH
102988: CALL 104767 0 3
// end ;
102992: GO 102890
102994: POP
102995: POP
// if enchidnas then
102996: LD_VAR 0 4
103000: IFFALSE 103067
// for i = 1 to enchidnas do
103002: LD_ADDR_VAR 0 11
103006: PUSH
103007: DOUBLE
103008: LD_INT 1
103010: DEC
103011: ST_TO_ADDR
103012: LD_VAR 0 4
103016: PUSH
103017: FOR_TO
103018: IFFALSE 103065
// begin hc_class = 13 ;
103020: LD_ADDR_OWVAR 28
103024: PUSH
103025: LD_INT 13
103027: ST_TO_ADDR
// hc_gallery =  ;
103028: LD_ADDR_OWVAR 33
103032: PUSH
103033: LD_STRING 
103035: ST_TO_ADDR
// animal := CreateHuman ;
103036: LD_ADDR_VAR 0 12
103040: PUSH
103041: CALL_OW 44
103045: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103046: LD_VAR 0 12
103050: PPUSH
103051: LD_VAR 0 8
103055: PPUSH
103056: LD_INT 0
103058: PPUSH
103059: CALL 104767 0 3
// end ;
103063: GO 103017
103065: POP
103066: POP
// if fishes then
103067: LD_VAR 0 7
103071: IFFALSE 103138
// for i = 1 to fishes do
103073: LD_ADDR_VAR 0 11
103077: PUSH
103078: DOUBLE
103079: LD_INT 1
103081: DEC
103082: ST_TO_ADDR
103083: LD_VAR 0 7
103087: PUSH
103088: FOR_TO
103089: IFFALSE 103136
// begin hc_class = 20 ;
103091: LD_ADDR_OWVAR 28
103095: PUSH
103096: LD_INT 20
103098: ST_TO_ADDR
// hc_gallery =  ;
103099: LD_ADDR_OWVAR 33
103103: PUSH
103104: LD_STRING 
103106: ST_TO_ADDR
// animal := CreateHuman ;
103107: LD_ADDR_VAR 0 12
103111: PUSH
103112: CALL_OW 44
103116: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
103117: LD_VAR 0 12
103121: PPUSH
103122: LD_VAR 0 9
103126: PPUSH
103127: LD_INT 0
103129: PPUSH
103130: CALL 104767 0 3
// end ;
103134: GO 103088
103136: POP
103137: POP
// end ;
103138: LD_VAR 0 10
103142: RET
// export function WantHeal ( sci , unit ) ; begin
103143: LD_INT 0
103145: PPUSH
// if GetTaskList ( sci ) > 0 then
103146: LD_VAR 0 1
103150: PPUSH
103151: CALL_OW 437
103155: PUSH
103156: LD_INT 0
103158: GREATER
103159: IFFALSE 103229
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
103161: LD_VAR 0 1
103165: PPUSH
103166: CALL_OW 437
103170: PUSH
103171: LD_INT 1
103173: ARRAY
103174: PUSH
103175: LD_INT 1
103177: ARRAY
103178: PUSH
103179: LD_STRING l
103181: EQUAL
103182: PUSH
103183: LD_VAR 0 1
103187: PPUSH
103188: CALL_OW 437
103192: PUSH
103193: LD_INT 1
103195: ARRAY
103196: PUSH
103197: LD_INT 4
103199: ARRAY
103200: PUSH
103201: LD_VAR 0 2
103205: EQUAL
103206: AND
103207: IFFALSE 103219
// result := true else
103209: LD_ADDR_VAR 0 3
103213: PUSH
103214: LD_INT 1
103216: ST_TO_ADDR
103217: GO 103227
// result := false ;
103219: LD_ADDR_VAR 0 3
103223: PUSH
103224: LD_INT 0
103226: ST_TO_ADDR
// end else
103227: GO 103237
// result := false ;
103229: LD_ADDR_VAR 0 3
103233: PUSH
103234: LD_INT 0
103236: ST_TO_ADDR
// end ;
103237: LD_VAR 0 3
103241: RET
// export function HealTarget ( sci ) ; begin
103242: LD_INT 0
103244: PPUSH
// if not sci then
103245: LD_VAR 0 1
103249: NOT
103250: IFFALSE 103254
// exit ;
103252: GO 103319
// result := 0 ;
103254: LD_ADDR_VAR 0 2
103258: PUSH
103259: LD_INT 0
103261: ST_TO_ADDR
// if GetTaskList ( sci ) then
103262: LD_VAR 0 1
103266: PPUSH
103267: CALL_OW 437
103271: IFFALSE 103319
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
103273: LD_VAR 0 1
103277: PPUSH
103278: CALL_OW 437
103282: PUSH
103283: LD_INT 1
103285: ARRAY
103286: PUSH
103287: LD_INT 1
103289: ARRAY
103290: PUSH
103291: LD_STRING l
103293: EQUAL
103294: IFFALSE 103319
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
103296: LD_ADDR_VAR 0 2
103300: PUSH
103301: LD_VAR 0 1
103305: PPUSH
103306: CALL_OW 437
103310: PUSH
103311: LD_INT 1
103313: ARRAY
103314: PUSH
103315: LD_INT 4
103317: ARRAY
103318: ST_TO_ADDR
// end ;
103319: LD_VAR 0 2
103323: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103324: LD_INT 0
103326: PPUSH
103327: PPUSH
103328: PPUSH
103329: PPUSH
// if not base_units then
103330: LD_VAR 0 1
103334: NOT
103335: IFFALSE 103339
// exit ;
103337: GO 103426
// result := false ;
103339: LD_ADDR_VAR 0 2
103343: PUSH
103344: LD_INT 0
103346: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103347: LD_ADDR_VAR 0 5
103351: PUSH
103352: LD_VAR 0 1
103356: PPUSH
103357: LD_INT 21
103359: PUSH
103360: LD_INT 3
103362: PUSH
103363: EMPTY
103364: LIST
103365: LIST
103366: PPUSH
103367: CALL_OW 72
103371: ST_TO_ADDR
// if not tmp then
103372: LD_VAR 0 5
103376: NOT
103377: IFFALSE 103381
// exit ;
103379: GO 103426
// for i in tmp do
103381: LD_ADDR_VAR 0 3
103385: PUSH
103386: LD_VAR 0 5
103390: PUSH
103391: FOR_IN
103392: IFFALSE 103424
// begin result := EnemyInRange ( i , 22 ) ;
103394: LD_ADDR_VAR 0 2
103398: PUSH
103399: LD_VAR 0 3
103403: PPUSH
103404: LD_INT 22
103406: PPUSH
103407: CALL 101013 0 2
103411: ST_TO_ADDR
// if result then
103412: LD_VAR 0 2
103416: IFFALSE 103422
// exit ;
103418: POP
103419: POP
103420: GO 103426
// end ;
103422: GO 103391
103424: POP
103425: POP
// end ;
103426: LD_VAR 0 2
103430: RET
// export function FilterByTag ( units , tag ) ; begin
103431: LD_INT 0
103433: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
103434: LD_ADDR_VAR 0 3
103438: PUSH
103439: LD_VAR 0 1
103443: PPUSH
103444: LD_INT 120
103446: PUSH
103447: LD_VAR 0 2
103451: PUSH
103452: EMPTY
103453: LIST
103454: LIST
103455: PPUSH
103456: CALL_OW 72
103460: ST_TO_ADDR
// end ;
103461: LD_VAR 0 3
103465: RET
// export function IsDriver ( un ) ; begin
103466: LD_INT 0
103468: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103469: LD_ADDR_VAR 0 2
103473: PUSH
103474: LD_VAR 0 1
103478: PUSH
103479: LD_INT 55
103481: PUSH
103482: EMPTY
103483: LIST
103484: PPUSH
103485: CALL_OW 69
103489: IN
103490: ST_TO_ADDR
// end ;
103491: LD_VAR 0 2
103495: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103496: LD_INT 0
103498: PPUSH
103499: PPUSH
// list := [ ] ;
103500: LD_ADDR_VAR 0 5
103504: PUSH
103505: EMPTY
103506: ST_TO_ADDR
// case d of 0 :
103507: LD_VAR 0 3
103511: PUSH
103512: LD_INT 0
103514: DOUBLE
103515: EQUAL
103516: IFTRUE 103520
103518: GO 103653
103520: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103521: LD_ADDR_VAR 0 5
103525: PUSH
103526: LD_VAR 0 1
103530: PUSH
103531: LD_INT 4
103533: MINUS
103534: PUSH
103535: LD_VAR 0 2
103539: PUSH
103540: LD_INT 4
103542: MINUS
103543: PUSH
103544: LD_INT 2
103546: PUSH
103547: EMPTY
103548: LIST
103549: LIST
103550: LIST
103551: PUSH
103552: LD_VAR 0 1
103556: PUSH
103557: LD_INT 3
103559: MINUS
103560: PUSH
103561: LD_VAR 0 2
103565: PUSH
103566: LD_INT 1
103568: PUSH
103569: EMPTY
103570: LIST
103571: LIST
103572: LIST
103573: PUSH
103574: LD_VAR 0 1
103578: PUSH
103579: LD_INT 4
103581: PLUS
103582: PUSH
103583: LD_VAR 0 2
103587: PUSH
103588: LD_INT 4
103590: PUSH
103591: EMPTY
103592: LIST
103593: LIST
103594: LIST
103595: PUSH
103596: LD_VAR 0 1
103600: PUSH
103601: LD_INT 3
103603: PLUS
103604: PUSH
103605: LD_VAR 0 2
103609: PUSH
103610: LD_INT 3
103612: PLUS
103613: PUSH
103614: LD_INT 5
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: LIST
103621: PUSH
103622: LD_VAR 0 1
103626: PUSH
103627: LD_VAR 0 2
103631: PUSH
103632: LD_INT 4
103634: PLUS
103635: PUSH
103636: LD_INT 0
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: LIST
103643: PUSH
103644: EMPTY
103645: LIST
103646: LIST
103647: LIST
103648: LIST
103649: LIST
103650: ST_TO_ADDR
// end ; 1 :
103651: GO 104351
103653: LD_INT 1
103655: DOUBLE
103656: EQUAL
103657: IFTRUE 103661
103659: GO 103794
103661: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103662: LD_ADDR_VAR 0 5
103666: PUSH
103667: LD_VAR 0 1
103671: PUSH
103672: LD_VAR 0 2
103676: PUSH
103677: LD_INT 4
103679: MINUS
103680: PUSH
103681: LD_INT 3
103683: PUSH
103684: EMPTY
103685: LIST
103686: LIST
103687: LIST
103688: PUSH
103689: LD_VAR 0 1
103693: PUSH
103694: LD_INT 3
103696: MINUS
103697: PUSH
103698: LD_VAR 0 2
103702: PUSH
103703: LD_INT 3
103705: MINUS
103706: PUSH
103707: LD_INT 2
103709: PUSH
103710: EMPTY
103711: LIST
103712: LIST
103713: LIST
103714: PUSH
103715: LD_VAR 0 1
103719: PUSH
103720: LD_INT 4
103722: MINUS
103723: PUSH
103724: LD_VAR 0 2
103728: PUSH
103729: LD_INT 1
103731: PUSH
103732: EMPTY
103733: LIST
103734: LIST
103735: LIST
103736: PUSH
103737: LD_VAR 0 1
103741: PUSH
103742: LD_VAR 0 2
103746: PUSH
103747: LD_INT 3
103749: PLUS
103750: PUSH
103751: LD_INT 0
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: LIST
103758: PUSH
103759: LD_VAR 0 1
103763: PUSH
103764: LD_INT 4
103766: PLUS
103767: PUSH
103768: LD_VAR 0 2
103772: PUSH
103773: LD_INT 4
103775: PLUS
103776: PUSH
103777: LD_INT 5
103779: PUSH
103780: EMPTY
103781: LIST
103782: LIST
103783: LIST
103784: PUSH
103785: EMPTY
103786: LIST
103787: LIST
103788: LIST
103789: LIST
103790: LIST
103791: ST_TO_ADDR
// end ; 2 :
103792: GO 104351
103794: LD_INT 2
103796: DOUBLE
103797: EQUAL
103798: IFTRUE 103802
103800: GO 103931
103802: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103803: LD_ADDR_VAR 0 5
103807: PUSH
103808: LD_VAR 0 1
103812: PUSH
103813: LD_VAR 0 2
103817: PUSH
103818: LD_INT 3
103820: MINUS
103821: PUSH
103822: LD_INT 3
103824: PUSH
103825: EMPTY
103826: LIST
103827: LIST
103828: LIST
103829: PUSH
103830: LD_VAR 0 1
103834: PUSH
103835: LD_INT 4
103837: PLUS
103838: PUSH
103839: LD_VAR 0 2
103843: PUSH
103844: LD_INT 4
103846: PUSH
103847: EMPTY
103848: LIST
103849: LIST
103850: LIST
103851: PUSH
103852: LD_VAR 0 1
103856: PUSH
103857: LD_VAR 0 2
103861: PUSH
103862: LD_INT 4
103864: PLUS
103865: PUSH
103866: LD_INT 0
103868: PUSH
103869: EMPTY
103870: LIST
103871: LIST
103872: LIST
103873: PUSH
103874: LD_VAR 0 1
103878: PUSH
103879: LD_INT 3
103881: MINUS
103882: PUSH
103883: LD_VAR 0 2
103887: PUSH
103888: LD_INT 1
103890: PUSH
103891: EMPTY
103892: LIST
103893: LIST
103894: LIST
103895: PUSH
103896: LD_VAR 0 1
103900: PUSH
103901: LD_INT 4
103903: MINUS
103904: PUSH
103905: LD_VAR 0 2
103909: PUSH
103910: LD_INT 4
103912: MINUS
103913: PUSH
103914: LD_INT 2
103916: PUSH
103917: EMPTY
103918: LIST
103919: LIST
103920: LIST
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: LIST
103926: LIST
103927: LIST
103928: ST_TO_ADDR
// end ; 3 :
103929: GO 104351
103931: LD_INT 3
103933: DOUBLE
103934: EQUAL
103935: IFTRUE 103939
103937: GO 104072
103939: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103940: LD_ADDR_VAR 0 5
103944: PUSH
103945: LD_VAR 0 1
103949: PUSH
103950: LD_INT 3
103952: PLUS
103953: PUSH
103954: LD_VAR 0 2
103958: PUSH
103959: LD_INT 4
103961: PUSH
103962: EMPTY
103963: LIST
103964: LIST
103965: LIST
103966: PUSH
103967: LD_VAR 0 1
103971: PUSH
103972: LD_INT 4
103974: PLUS
103975: PUSH
103976: LD_VAR 0 2
103980: PUSH
103981: LD_INT 4
103983: PLUS
103984: PUSH
103985: LD_INT 5
103987: PUSH
103988: EMPTY
103989: LIST
103990: LIST
103991: LIST
103992: PUSH
103993: LD_VAR 0 1
103997: PUSH
103998: LD_INT 4
104000: MINUS
104001: PUSH
104002: LD_VAR 0 2
104006: PUSH
104007: LD_INT 1
104009: PUSH
104010: EMPTY
104011: LIST
104012: LIST
104013: LIST
104014: PUSH
104015: LD_VAR 0 1
104019: PUSH
104020: LD_VAR 0 2
104024: PUSH
104025: LD_INT 4
104027: MINUS
104028: PUSH
104029: LD_INT 3
104031: PUSH
104032: EMPTY
104033: LIST
104034: LIST
104035: LIST
104036: PUSH
104037: LD_VAR 0 1
104041: PUSH
104042: LD_INT 3
104044: MINUS
104045: PUSH
104046: LD_VAR 0 2
104050: PUSH
104051: LD_INT 3
104053: MINUS
104054: PUSH
104055: LD_INT 2
104057: PUSH
104058: EMPTY
104059: LIST
104060: LIST
104061: LIST
104062: PUSH
104063: EMPTY
104064: LIST
104065: LIST
104066: LIST
104067: LIST
104068: LIST
104069: ST_TO_ADDR
// end ; 4 :
104070: GO 104351
104072: LD_INT 4
104074: DOUBLE
104075: EQUAL
104076: IFTRUE 104080
104078: GO 104213
104080: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104081: LD_ADDR_VAR 0 5
104085: PUSH
104086: LD_VAR 0 1
104090: PUSH
104091: LD_VAR 0 2
104095: PUSH
104096: LD_INT 4
104098: PLUS
104099: PUSH
104100: LD_INT 0
104102: PUSH
104103: EMPTY
104104: LIST
104105: LIST
104106: LIST
104107: PUSH
104108: LD_VAR 0 1
104112: PUSH
104113: LD_INT 3
104115: PLUS
104116: PUSH
104117: LD_VAR 0 2
104121: PUSH
104122: LD_INT 3
104124: PLUS
104125: PUSH
104126: LD_INT 5
104128: PUSH
104129: EMPTY
104130: LIST
104131: LIST
104132: LIST
104133: PUSH
104134: LD_VAR 0 1
104138: PUSH
104139: LD_INT 4
104141: PLUS
104142: PUSH
104143: LD_VAR 0 2
104147: PUSH
104148: LD_INT 4
104150: PUSH
104151: EMPTY
104152: LIST
104153: LIST
104154: LIST
104155: PUSH
104156: LD_VAR 0 1
104160: PUSH
104161: LD_VAR 0 2
104165: PUSH
104166: LD_INT 3
104168: MINUS
104169: PUSH
104170: LD_INT 3
104172: PUSH
104173: EMPTY
104174: LIST
104175: LIST
104176: LIST
104177: PUSH
104178: LD_VAR 0 1
104182: PUSH
104183: LD_INT 4
104185: MINUS
104186: PUSH
104187: LD_VAR 0 2
104191: PUSH
104192: LD_INT 4
104194: MINUS
104195: PUSH
104196: LD_INT 2
104198: PUSH
104199: EMPTY
104200: LIST
104201: LIST
104202: LIST
104203: PUSH
104204: EMPTY
104205: LIST
104206: LIST
104207: LIST
104208: LIST
104209: LIST
104210: ST_TO_ADDR
// end ; 5 :
104211: GO 104351
104213: LD_INT 5
104215: DOUBLE
104216: EQUAL
104217: IFTRUE 104221
104219: GO 104350
104221: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104222: LD_ADDR_VAR 0 5
104226: PUSH
104227: LD_VAR 0 1
104231: PUSH
104232: LD_INT 4
104234: MINUS
104235: PUSH
104236: LD_VAR 0 2
104240: PUSH
104241: LD_INT 1
104243: PUSH
104244: EMPTY
104245: LIST
104246: LIST
104247: LIST
104248: PUSH
104249: LD_VAR 0 1
104253: PUSH
104254: LD_VAR 0 2
104258: PUSH
104259: LD_INT 4
104261: MINUS
104262: PUSH
104263: LD_INT 3
104265: PUSH
104266: EMPTY
104267: LIST
104268: LIST
104269: LIST
104270: PUSH
104271: LD_VAR 0 1
104275: PUSH
104276: LD_INT 4
104278: PLUS
104279: PUSH
104280: LD_VAR 0 2
104284: PUSH
104285: LD_INT 4
104287: PLUS
104288: PUSH
104289: LD_INT 5
104291: PUSH
104292: EMPTY
104293: LIST
104294: LIST
104295: LIST
104296: PUSH
104297: LD_VAR 0 1
104301: PUSH
104302: LD_INT 3
104304: PLUS
104305: PUSH
104306: LD_VAR 0 2
104310: PUSH
104311: LD_INT 4
104313: PUSH
104314: EMPTY
104315: LIST
104316: LIST
104317: LIST
104318: PUSH
104319: LD_VAR 0 1
104323: PUSH
104324: LD_VAR 0 2
104328: PUSH
104329: LD_INT 3
104331: PLUS
104332: PUSH
104333: LD_INT 0
104335: PUSH
104336: EMPTY
104337: LIST
104338: LIST
104339: LIST
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: LIST
104345: LIST
104346: LIST
104347: ST_TO_ADDR
// end ; end ;
104348: GO 104351
104350: POP
// result := list ;
104351: LD_ADDR_VAR 0 4
104355: PUSH
104356: LD_VAR 0 5
104360: ST_TO_ADDR
// end ;
104361: LD_VAR 0 4
104365: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
104366: LD_INT 0
104368: PPUSH
104369: PPUSH
104370: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
104371: LD_VAR 0 1
104375: NOT
104376: PUSH
104377: LD_VAR 0 2
104381: PUSH
104382: LD_INT 1
104384: PUSH
104385: LD_INT 2
104387: PUSH
104388: LD_INT 3
104390: PUSH
104391: LD_INT 4
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: IN
104400: NOT
104401: OR
104402: IFFALSE 104406
// exit ;
104404: GO 104489
// tmp := [ ] ;
104406: LD_ADDR_VAR 0 5
104410: PUSH
104411: EMPTY
104412: ST_TO_ADDR
// for i in units do
104413: LD_ADDR_VAR 0 4
104417: PUSH
104418: LD_VAR 0 1
104422: PUSH
104423: FOR_IN
104424: IFFALSE 104458
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
104426: LD_ADDR_VAR 0 5
104430: PUSH
104431: LD_VAR 0 5
104435: PPUSH
104436: LD_VAR 0 4
104440: PPUSH
104441: LD_VAR 0 2
104445: PPUSH
104446: CALL_OW 259
104450: PPUSH
104451: CALL 105849 0 2
104455: ST_TO_ADDR
104456: GO 104423
104458: POP
104459: POP
// if not tmp then
104460: LD_VAR 0 5
104464: NOT
104465: IFFALSE 104469
// exit ;
104467: GO 104489
// result := SortListByListDesc ( units , tmp ) ;
104469: LD_ADDR_VAR 0 3
104473: PUSH
104474: LD_VAR 0 1
104478: PPUSH
104479: LD_VAR 0 5
104483: PPUSH
104484: CALL_OW 77
104488: ST_TO_ADDR
// end ;
104489: LD_VAR 0 3
104493: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104494: LD_INT 0
104496: PPUSH
104497: PPUSH
104498: PPUSH
// result := false ;
104499: LD_ADDR_VAR 0 3
104503: PUSH
104504: LD_INT 0
104506: ST_TO_ADDR
// if not building then
104507: LD_VAR 0 2
104511: NOT
104512: IFFALSE 104516
// exit ;
104514: GO 104654
// x := GetX ( building ) ;
104516: LD_ADDR_VAR 0 4
104520: PUSH
104521: LD_VAR 0 2
104525: PPUSH
104526: CALL_OW 250
104530: ST_TO_ADDR
// y := GetY ( building ) ;
104531: LD_ADDR_VAR 0 5
104535: PUSH
104536: LD_VAR 0 2
104540: PPUSH
104541: CALL_OW 251
104545: ST_TO_ADDR
// if not x or not y then
104546: LD_VAR 0 4
104550: NOT
104551: PUSH
104552: LD_VAR 0 5
104556: NOT
104557: OR
104558: IFFALSE 104562
// exit ;
104560: GO 104654
// if GetTaskList ( unit ) then
104562: LD_VAR 0 1
104566: PPUSH
104567: CALL_OW 437
104571: IFFALSE 104654
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104573: LD_STRING e
104575: PUSH
104576: LD_VAR 0 1
104580: PPUSH
104581: CALL_OW 437
104585: PUSH
104586: LD_INT 1
104588: ARRAY
104589: PUSH
104590: LD_INT 1
104592: ARRAY
104593: EQUAL
104594: PUSH
104595: LD_VAR 0 4
104599: PUSH
104600: LD_VAR 0 1
104604: PPUSH
104605: CALL_OW 437
104609: PUSH
104610: LD_INT 1
104612: ARRAY
104613: PUSH
104614: LD_INT 2
104616: ARRAY
104617: EQUAL
104618: AND
104619: PUSH
104620: LD_VAR 0 5
104624: PUSH
104625: LD_VAR 0 1
104629: PPUSH
104630: CALL_OW 437
104634: PUSH
104635: LD_INT 1
104637: ARRAY
104638: PUSH
104639: LD_INT 3
104641: ARRAY
104642: EQUAL
104643: AND
104644: IFFALSE 104654
// result := true end ;
104646: LD_ADDR_VAR 0 3
104650: PUSH
104651: LD_INT 1
104653: ST_TO_ADDR
// end ;
104654: LD_VAR 0 3
104658: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
104659: LD_INT 0
104661: PPUSH
// result := false ;
104662: LD_ADDR_VAR 0 4
104666: PUSH
104667: LD_INT 0
104669: ST_TO_ADDR
// if GetTaskList ( unit ) then
104670: LD_VAR 0 1
104674: PPUSH
104675: CALL_OW 437
104679: IFFALSE 104762
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104681: LD_STRING M
104683: PUSH
104684: LD_VAR 0 1
104688: PPUSH
104689: CALL_OW 437
104693: PUSH
104694: LD_INT 1
104696: ARRAY
104697: PUSH
104698: LD_INT 1
104700: ARRAY
104701: EQUAL
104702: PUSH
104703: LD_VAR 0 2
104707: PUSH
104708: LD_VAR 0 1
104712: PPUSH
104713: CALL_OW 437
104717: PUSH
104718: LD_INT 1
104720: ARRAY
104721: PUSH
104722: LD_INT 2
104724: ARRAY
104725: EQUAL
104726: AND
104727: PUSH
104728: LD_VAR 0 3
104732: PUSH
104733: LD_VAR 0 1
104737: PPUSH
104738: CALL_OW 437
104742: PUSH
104743: LD_INT 1
104745: ARRAY
104746: PUSH
104747: LD_INT 3
104749: ARRAY
104750: EQUAL
104751: AND
104752: IFFALSE 104762
// result := true ;
104754: LD_ADDR_VAR 0 4
104758: PUSH
104759: LD_INT 1
104761: ST_TO_ADDR
// end ; end ;
104762: LD_VAR 0 4
104766: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104767: LD_INT 0
104769: PPUSH
104770: PPUSH
104771: PPUSH
104772: PPUSH
// if not unit or not area then
104773: LD_VAR 0 1
104777: NOT
104778: PUSH
104779: LD_VAR 0 2
104783: NOT
104784: OR
104785: IFFALSE 104789
// exit ;
104787: GO 104952
// tmp := AreaToList ( area , i ) ;
104789: LD_ADDR_VAR 0 6
104793: PUSH
104794: LD_VAR 0 2
104798: PPUSH
104799: LD_VAR 0 5
104803: PPUSH
104804: CALL_OW 517
104808: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104809: LD_ADDR_VAR 0 5
104813: PUSH
104814: DOUBLE
104815: LD_INT 1
104817: DEC
104818: ST_TO_ADDR
104819: LD_VAR 0 6
104823: PUSH
104824: LD_INT 1
104826: ARRAY
104827: PUSH
104828: FOR_TO
104829: IFFALSE 104950
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104831: LD_ADDR_VAR 0 7
104835: PUSH
104836: LD_VAR 0 6
104840: PUSH
104841: LD_INT 1
104843: ARRAY
104844: PUSH
104845: LD_VAR 0 5
104849: ARRAY
104850: PUSH
104851: LD_VAR 0 6
104855: PUSH
104856: LD_INT 2
104858: ARRAY
104859: PUSH
104860: LD_VAR 0 5
104864: ARRAY
104865: PUSH
104866: EMPTY
104867: LIST
104868: LIST
104869: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
104870: LD_INT 92
104872: PUSH
104873: LD_VAR 0 7
104877: PUSH
104878: LD_INT 1
104880: ARRAY
104881: PUSH
104882: LD_VAR 0 7
104886: PUSH
104887: LD_INT 2
104889: ARRAY
104890: PUSH
104891: LD_INT 3
104893: PUSH
104894: EMPTY
104895: LIST
104896: LIST
104897: LIST
104898: LIST
104899: PPUSH
104900: CALL_OW 69
104904: PUSH
104905: LD_INT 0
104907: EQUAL
104908: IFFALSE 104948
// begin PlaceUnitArea ( unit , area , mode ) ;
104910: LD_VAR 0 1
104914: PPUSH
104915: LD_VAR 0 2
104919: PPUSH
104920: LD_VAR 0 3
104924: PPUSH
104925: CALL_OW 49
// result := IsPlaced ( unit ) ;
104929: LD_ADDR_VAR 0 4
104933: PUSH
104934: LD_VAR 0 1
104938: PPUSH
104939: CALL_OW 305
104943: ST_TO_ADDR
// exit ;
104944: POP
104945: POP
104946: GO 104952
// end ; end ;
104948: GO 104828
104950: POP
104951: POP
// end ;
104952: LD_VAR 0 4
104956: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104957: LD_INT 0
104959: PPUSH
104960: PPUSH
104961: PPUSH
// if not side or side > 8 then
104962: LD_VAR 0 1
104966: NOT
104967: PUSH
104968: LD_VAR 0 1
104972: PUSH
104973: LD_INT 8
104975: GREATER
104976: OR
104977: IFFALSE 104981
// exit ;
104979: GO 105168
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104981: LD_ADDR_VAR 0 4
104985: PUSH
104986: LD_INT 22
104988: PUSH
104989: LD_VAR 0 1
104993: PUSH
104994: EMPTY
104995: LIST
104996: LIST
104997: PUSH
104998: LD_INT 21
105000: PUSH
105001: LD_INT 3
105003: PUSH
105004: EMPTY
105005: LIST
105006: LIST
105007: PUSH
105008: EMPTY
105009: LIST
105010: LIST
105011: PPUSH
105012: CALL_OW 69
105016: ST_TO_ADDR
// if not tmp then
105017: LD_VAR 0 4
105021: NOT
105022: IFFALSE 105026
// exit ;
105024: GO 105168
// enable_addtolog := true ;
105026: LD_ADDR_OWVAR 81
105030: PUSH
105031: LD_INT 1
105033: ST_TO_ADDR
// AddToLog ( [ ) ;
105034: LD_STRING [
105036: PPUSH
105037: CALL_OW 561
// for i in tmp do
105041: LD_ADDR_VAR 0 3
105045: PUSH
105046: LD_VAR 0 4
105050: PUSH
105051: FOR_IN
105052: IFFALSE 105159
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105054: LD_STRING [
105056: PUSH
105057: LD_VAR 0 3
105061: PPUSH
105062: CALL_OW 266
105066: STR
105067: PUSH
105068: LD_STRING , 
105070: STR
105071: PUSH
105072: LD_VAR 0 3
105076: PPUSH
105077: CALL_OW 250
105081: STR
105082: PUSH
105083: LD_STRING , 
105085: STR
105086: PUSH
105087: LD_VAR 0 3
105091: PPUSH
105092: CALL_OW 251
105096: STR
105097: PUSH
105098: LD_STRING , 
105100: STR
105101: PUSH
105102: LD_VAR 0 3
105106: PPUSH
105107: CALL_OW 254
105111: STR
105112: PUSH
105113: LD_STRING , 
105115: STR
105116: PUSH
105117: LD_VAR 0 3
105121: PPUSH
105122: LD_INT 1
105124: PPUSH
105125: CALL_OW 268
105129: STR
105130: PUSH
105131: LD_STRING , 
105133: STR
105134: PUSH
105135: LD_VAR 0 3
105139: PPUSH
105140: LD_INT 2
105142: PPUSH
105143: CALL_OW 268
105147: STR
105148: PUSH
105149: LD_STRING ],
105151: STR
105152: PPUSH
105153: CALL_OW 561
// end ;
105157: GO 105051
105159: POP
105160: POP
// AddToLog ( ]; ) ;
105161: LD_STRING ];
105163: PPUSH
105164: CALL_OW 561
// end ;
105168: LD_VAR 0 2
105172: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105173: LD_INT 0
105175: PPUSH
105176: PPUSH
105177: PPUSH
105178: PPUSH
105179: PPUSH
// if not area or not rate or not max then
105180: LD_VAR 0 1
105184: NOT
105185: PUSH
105186: LD_VAR 0 2
105190: NOT
105191: OR
105192: PUSH
105193: LD_VAR 0 4
105197: NOT
105198: OR
105199: IFFALSE 105203
// exit ;
105201: GO 105392
// while 1 do
105203: LD_INT 1
105205: IFFALSE 105392
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105207: LD_ADDR_VAR 0 9
105211: PUSH
105212: LD_VAR 0 1
105216: PPUSH
105217: LD_INT 1
105219: PPUSH
105220: CALL_OW 287
105224: PUSH
105225: LD_INT 10
105227: MUL
105228: ST_TO_ADDR
// r := rate / 10 ;
105229: LD_ADDR_VAR 0 7
105233: PUSH
105234: LD_VAR 0 2
105238: PUSH
105239: LD_INT 10
105241: DIVREAL
105242: ST_TO_ADDR
// time := 1 1$00 ;
105243: LD_ADDR_VAR 0 8
105247: PUSH
105248: LD_INT 2100
105250: ST_TO_ADDR
// if amount < min then
105251: LD_VAR 0 9
105255: PUSH
105256: LD_VAR 0 3
105260: LESS
105261: IFFALSE 105279
// r := r * 2 else
105263: LD_ADDR_VAR 0 7
105267: PUSH
105268: LD_VAR 0 7
105272: PUSH
105273: LD_INT 2
105275: MUL
105276: ST_TO_ADDR
105277: GO 105305
// if amount > max then
105279: LD_VAR 0 9
105283: PUSH
105284: LD_VAR 0 4
105288: GREATER
105289: IFFALSE 105305
// r := r / 2 ;
105291: LD_ADDR_VAR 0 7
105295: PUSH
105296: LD_VAR 0 7
105300: PUSH
105301: LD_INT 2
105303: DIVREAL
105304: ST_TO_ADDR
// time := time / r ;
105305: LD_ADDR_VAR 0 8
105309: PUSH
105310: LD_VAR 0 8
105314: PUSH
105315: LD_VAR 0 7
105319: DIVREAL
105320: ST_TO_ADDR
// if time < 0 then
105321: LD_VAR 0 8
105325: PUSH
105326: LD_INT 0
105328: LESS
105329: IFFALSE 105346
// time := time * - 1 ;
105331: LD_ADDR_VAR 0 8
105335: PUSH
105336: LD_VAR 0 8
105340: PUSH
105341: LD_INT 1
105343: NEG
105344: MUL
105345: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
105346: LD_VAR 0 8
105350: PUSH
105351: LD_INT 35
105353: PPUSH
105354: LD_INT 875
105356: PPUSH
105357: CALL_OW 12
105361: PLUS
105362: PPUSH
105363: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105367: LD_INT 1
105369: PPUSH
105370: LD_INT 5
105372: PPUSH
105373: CALL_OW 12
105377: PPUSH
105378: LD_VAR 0 1
105382: PPUSH
105383: LD_INT 1
105385: PPUSH
105386: CALL_OW 55
// end ;
105390: GO 105203
// end ;
105392: LD_VAR 0 5
105396: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105397: LD_INT 0
105399: PPUSH
105400: PPUSH
105401: PPUSH
105402: PPUSH
105403: PPUSH
105404: PPUSH
105405: PPUSH
105406: PPUSH
// if not turrets or not factories then
105407: LD_VAR 0 1
105411: NOT
105412: PUSH
105413: LD_VAR 0 2
105417: NOT
105418: OR
105419: IFFALSE 105423
// exit ;
105421: GO 105730
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105423: LD_ADDR_VAR 0 10
105427: PUSH
105428: LD_INT 5
105430: PUSH
105431: LD_INT 6
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: PUSH
105438: LD_INT 2
105440: PUSH
105441: LD_INT 4
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: PUSH
105448: LD_INT 3
105450: PUSH
105451: LD_INT 5
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: PUSH
105458: EMPTY
105459: LIST
105460: LIST
105461: LIST
105462: PUSH
105463: LD_INT 24
105465: PUSH
105466: LD_INT 25
105468: PUSH
105469: EMPTY
105470: LIST
105471: LIST
105472: PUSH
105473: LD_INT 23
105475: PUSH
105476: LD_INT 27
105478: PUSH
105479: EMPTY
105480: LIST
105481: LIST
105482: PUSH
105483: EMPTY
105484: LIST
105485: LIST
105486: PUSH
105487: LD_INT 42
105489: PUSH
105490: LD_INT 43
105492: PUSH
105493: EMPTY
105494: LIST
105495: LIST
105496: PUSH
105497: LD_INT 44
105499: PUSH
105500: LD_INT 46
105502: PUSH
105503: EMPTY
105504: LIST
105505: LIST
105506: PUSH
105507: LD_INT 45
105509: PUSH
105510: LD_INT 47
105512: PUSH
105513: EMPTY
105514: LIST
105515: LIST
105516: PUSH
105517: EMPTY
105518: LIST
105519: LIST
105520: LIST
105521: PUSH
105522: EMPTY
105523: LIST
105524: LIST
105525: LIST
105526: ST_TO_ADDR
// result := [ ] ;
105527: LD_ADDR_VAR 0 3
105531: PUSH
105532: EMPTY
105533: ST_TO_ADDR
// for i in turrets do
105534: LD_ADDR_VAR 0 4
105538: PUSH
105539: LD_VAR 0 1
105543: PUSH
105544: FOR_IN
105545: IFFALSE 105728
// begin nat := GetNation ( i ) ;
105547: LD_ADDR_VAR 0 7
105551: PUSH
105552: LD_VAR 0 4
105556: PPUSH
105557: CALL_OW 248
105561: ST_TO_ADDR
// weapon := 0 ;
105562: LD_ADDR_VAR 0 8
105566: PUSH
105567: LD_INT 0
105569: ST_TO_ADDR
// if not nat then
105570: LD_VAR 0 7
105574: NOT
105575: IFFALSE 105579
// continue ;
105577: GO 105544
// for j in list [ nat ] do
105579: LD_ADDR_VAR 0 5
105583: PUSH
105584: LD_VAR 0 10
105588: PUSH
105589: LD_VAR 0 7
105593: ARRAY
105594: PUSH
105595: FOR_IN
105596: IFFALSE 105637
// if GetBWeapon ( i ) = j [ 1 ] then
105598: LD_VAR 0 4
105602: PPUSH
105603: CALL_OW 269
105607: PUSH
105608: LD_VAR 0 5
105612: PUSH
105613: LD_INT 1
105615: ARRAY
105616: EQUAL
105617: IFFALSE 105635
// begin weapon := j [ 2 ] ;
105619: LD_ADDR_VAR 0 8
105623: PUSH
105624: LD_VAR 0 5
105628: PUSH
105629: LD_INT 2
105631: ARRAY
105632: ST_TO_ADDR
// break ;
105633: GO 105637
// end ;
105635: GO 105595
105637: POP
105638: POP
// if not weapon then
105639: LD_VAR 0 8
105643: NOT
105644: IFFALSE 105648
// continue ;
105646: GO 105544
// for k in factories do
105648: LD_ADDR_VAR 0 6
105652: PUSH
105653: LD_VAR 0 2
105657: PUSH
105658: FOR_IN
105659: IFFALSE 105724
// begin weapons := AvailableWeaponList ( k ) ;
105661: LD_ADDR_VAR 0 9
105665: PUSH
105666: LD_VAR 0 6
105670: PPUSH
105671: CALL_OW 478
105675: ST_TO_ADDR
// if not weapons then
105676: LD_VAR 0 9
105680: NOT
105681: IFFALSE 105685
// continue ;
105683: GO 105658
// if weapon in weapons then
105685: LD_VAR 0 8
105689: PUSH
105690: LD_VAR 0 9
105694: IN
105695: IFFALSE 105722
// begin result := [ i , weapon ] ;
105697: LD_ADDR_VAR 0 3
105701: PUSH
105702: LD_VAR 0 4
105706: PUSH
105707: LD_VAR 0 8
105711: PUSH
105712: EMPTY
105713: LIST
105714: LIST
105715: ST_TO_ADDR
// exit ;
105716: POP
105717: POP
105718: POP
105719: POP
105720: GO 105730
// end ; end ;
105722: GO 105658
105724: POP
105725: POP
// end ;
105726: GO 105544
105728: POP
105729: POP
// end ;
105730: LD_VAR 0 3
105734: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105735: LD_INT 0
105737: PPUSH
// if not side or side > 8 then
105738: LD_VAR 0 3
105742: NOT
105743: PUSH
105744: LD_VAR 0 3
105748: PUSH
105749: LD_INT 8
105751: GREATER
105752: OR
105753: IFFALSE 105757
// exit ;
105755: GO 105816
// if not range then
105757: LD_VAR 0 4
105761: NOT
105762: IFFALSE 105773
// range := - 12 ;
105764: LD_ADDR_VAR 0 4
105768: PUSH
105769: LD_INT 12
105771: NEG
105772: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105773: LD_VAR 0 1
105777: PPUSH
105778: LD_VAR 0 2
105782: PPUSH
105783: LD_VAR 0 3
105787: PPUSH
105788: LD_VAR 0 4
105792: PPUSH
105793: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105797: LD_VAR 0 1
105801: PPUSH
105802: LD_VAR 0 2
105806: PPUSH
105807: LD_VAR 0 3
105811: PPUSH
105812: CALL_OW 331
// end ;
105816: LD_VAR 0 5
105820: RET
// export function Video ( mode ) ; begin
105821: LD_INT 0
105823: PPUSH
// ingame_video = mode ;
105824: LD_ADDR_OWVAR 52
105828: PUSH
105829: LD_VAR 0 1
105833: ST_TO_ADDR
// interface_hidden = mode ;
105834: LD_ADDR_OWVAR 54
105838: PUSH
105839: LD_VAR 0 1
105843: ST_TO_ADDR
// end ;
105844: LD_VAR 0 2
105848: RET
// export function Join ( array , element ) ; begin
105849: LD_INT 0
105851: PPUSH
// result := Replace ( array , array + 1 , element ) ;
105852: LD_ADDR_VAR 0 3
105856: PUSH
105857: LD_VAR 0 1
105861: PPUSH
105862: LD_VAR 0 1
105866: PUSH
105867: LD_INT 1
105869: PLUS
105870: PPUSH
105871: LD_VAR 0 2
105875: PPUSH
105876: CALL_OW 1
105880: ST_TO_ADDR
// end ;
105881: LD_VAR 0 3
105885: RET
// export function JoinUnion ( array , element ) ; begin
105886: LD_INT 0
105888: PPUSH
// result := array union element ;
105889: LD_ADDR_VAR 0 3
105893: PUSH
105894: LD_VAR 0 1
105898: PUSH
105899: LD_VAR 0 2
105903: UNION
105904: ST_TO_ADDR
// end ;
105905: LD_VAR 0 3
105909: RET
// export function GetBehemoths ( side ) ; begin
105910: LD_INT 0
105912: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
105913: LD_ADDR_VAR 0 2
105917: PUSH
105918: LD_INT 22
105920: PUSH
105921: LD_VAR 0 1
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: PUSH
105930: LD_INT 31
105932: PUSH
105933: LD_INT 25
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: PUSH
105940: EMPTY
105941: LIST
105942: LIST
105943: PPUSH
105944: CALL_OW 69
105948: ST_TO_ADDR
// end ;
105949: LD_VAR 0 2
105953: RET
// export function Shuffle ( array ) ; var i , index ; begin
105954: LD_INT 0
105956: PPUSH
105957: PPUSH
105958: PPUSH
// result := [ ] ;
105959: LD_ADDR_VAR 0 2
105963: PUSH
105964: EMPTY
105965: ST_TO_ADDR
// if not array then
105966: LD_VAR 0 1
105970: NOT
105971: IFFALSE 105975
// exit ;
105973: GO 106074
// Randomize ;
105975: CALL_OW 10
// for i = array downto 1 do
105979: LD_ADDR_VAR 0 3
105983: PUSH
105984: DOUBLE
105985: LD_VAR 0 1
105989: INC
105990: ST_TO_ADDR
105991: LD_INT 1
105993: PUSH
105994: FOR_DOWNTO
105995: IFFALSE 106072
// begin index := rand ( 1 , array ) ;
105997: LD_ADDR_VAR 0 4
106001: PUSH
106002: LD_INT 1
106004: PPUSH
106005: LD_VAR 0 1
106009: PPUSH
106010: CALL_OW 12
106014: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106015: LD_ADDR_VAR 0 2
106019: PUSH
106020: LD_VAR 0 2
106024: PPUSH
106025: LD_VAR 0 2
106029: PUSH
106030: LD_INT 1
106032: PLUS
106033: PPUSH
106034: LD_VAR 0 1
106038: PUSH
106039: LD_VAR 0 4
106043: ARRAY
106044: PPUSH
106045: CALL_OW 2
106049: ST_TO_ADDR
// array := Delete ( array , index ) ;
106050: LD_ADDR_VAR 0 1
106054: PUSH
106055: LD_VAR 0 1
106059: PPUSH
106060: LD_VAR 0 4
106064: PPUSH
106065: CALL_OW 3
106069: ST_TO_ADDR
// end ;
106070: GO 105994
106072: POP
106073: POP
// end ;
106074: LD_VAR 0 2
106078: RET
// export function GetBaseMaterials ( base ) ; begin
106079: LD_INT 0
106081: PPUSH
// result := [ 0 , 0 , 0 ] ;
106082: LD_ADDR_VAR 0 2
106086: PUSH
106087: LD_INT 0
106089: PUSH
106090: LD_INT 0
106092: PUSH
106093: LD_INT 0
106095: PUSH
106096: EMPTY
106097: LIST
106098: LIST
106099: LIST
106100: ST_TO_ADDR
// if not base then
106101: LD_VAR 0 1
106105: NOT
106106: IFFALSE 106110
// exit ;
106108: GO 106159
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
106110: LD_ADDR_VAR 0 2
106114: PUSH
106115: LD_VAR 0 1
106119: PPUSH
106120: LD_INT 1
106122: PPUSH
106123: CALL_OW 275
106127: PUSH
106128: LD_VAR 0 1
106132: PPUSH
106133: LD_INT 2
106135: PPUSH
106136: CALL_OW 275
106140: PUSH
106141: LD_VAR 0 1
106145: PPUSH
106146: LD_INT 3
106148: PPUSH
106149: CALL_OW 275
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: LIST
106158: ST_TO_ADDR
// end ;
106159: LD_VAR 0 2
106163: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
106164: LD_INT 0
106166: PPUSH
106167: PPUSH
// result := array ;
106168: LD_ADDR_VAR 0 3
106172: PUSH
106173: LD_VAR 0 1
106177: ST_TO_ADDR
// if size >= result then
106178: LD_VAR 0 2
106182: PUSH
106183: LD_VAR 0 3
106187: GREATEREQUAL
106188: IFFALSE 106192
// exit ;
106190: GO 106242
// if size then
106192: LD_VAR 0 2
106196: IFFALSE 106242
// for i := array downto size do
106198: LD_ADDR_VAR 0 4
106202: PUSH
106203: DOUBLE
106204: LD_VAR 0 1
106208: INC
106209: ST_TO_ADDR
106210: LD_VAR 0 2
106214: PUSH
106215: FOR_DOWNTO
106216: IFFALSE 106240
// result := Delete ( result , result ) ;
106218: LD_ADDR_VAR 0 3
106222: PUSH
106223: LD_VAR 0 3
106227: PPUSH
106228: LD_VAR 0 3
106232: PPUSH
106233: CALL_OW 3
106237: ST_TO_ADDR
106238: GO 106215
106240: POP
106241: POP
// end ;
106242: LD_VAR 0 3
106246: RET
// export function ComExit ( unit ) ; var tmp ; begin
106247: LD_INT 0
106249: PPUSH
106250: PPUSH
// if not IsInUnit ( unit ) then
106251: LD_VAR 0 1
106255: PPUSH
106256: CALL_OW 310
106260: NOT
106261: IFFALSE 106265
// exit ;
106263: GO 106325
// tmp := IsInUnit ( unit ) ;
106265: LD_ADDR_VAR 0 3
106269: PUSH
106270: LD_VAR 0 1
106274: PPUSH
106275: CALL_OW 310
106279: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
106280: LD_VAR 0 3
106284: PPUSH
106285: CALL_OW 247
106289: PUSH
106290: LD_INT 2
106292: EQUAL
106293: IFFALSE 106306
// ComExitVehicle ( unit ) else
106295: LD_VAR 0 1
106299: PPUSH
106300: CALL_OW 121
106304: GO 106315
// ComExitBuilding ( unit ) ;
106306: LD_VAR 0 1
106310: PPUSH
106311: CALL_OW 122
// result := tmp ;
106315: LD_ADDR_VAR 0 2
106319: PUSH
106320: LD_VAR 0 3
106324: ST_TO_ADDR
// end ;
106325: LD_VAR 0 2
106329: RET
// export function ComExitAll ( units ) ; var i ; begin
106330: LD_INT 0
106332: PPUSH
106333: PPUSH
// if not units then
106334: LD_VAR 0 1
106338: NOT
106339: IFFALSE 106343
// exit ;
106341: GO 106369
// for i in units do
106343: LD_ADDR_VAR 0 3
106347: PUSH
106348: LD_VAR 0 1
106352: PUSH
106353: FOR_IN
106354: IFFALSE 106367
// ComExit ( i ) ;
106356: LD_VAR 0 3
106360: PPUSH
106361: CALL 106247 0 1
106365: GO 106353
106367: POP
106368: POP
// end ;
106369: LD_VAR 0 2
106373: RET
// export function ResetHc ; begin
106374: LD_INT 0
106376: PPUSH
// InitHc ;
106377: CALL_OW 19
// hc_importance := 0 ;
106381: LD_ADDR_OWVAR 32
106385: PUSH
106386: LD_INT 0
106388: ST_TO_ADDR
// end ;
106389: LD_VAR 0 1
106393: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
106394: LD_INT 0
106396: PPUSH
106397: PPUSH
106398: PPUSH
// _x := ( x1 + x2 ) div 2 ;
106399: LD_ADDR_VAR 0 6
106403: PUSH
106404: LD_VAR 0 1
106408: PUSH
106409: LD_VAR 0 3
106413: PLUS
106414: PUSH
106415: LD_INT 2
106417: DIV
106418: ST_TO_ADDR
// if _x < 0 then
106419: LD_VAR 0 6
106423: PUSH
106424: LD_INT 0
106426: LESS
106427: IFFALSE 106444
// _x := _x * - 1 ;
106429: LD_ADDR_VAR 0 6
106433: PUSH
106434: LD_VAR 0 6
106438: PUSH
106439: LD_INT 1
106441: NEG
106442: MUL
106443: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
106444: LD_ADDR_VAR 0 7
106448: PUSH
106449: LD_VAR 0 2
106453: PUSH
106454: LD_VAR 0 4
106458: PLUS
106459: PUSH
106460: LD_INT 2
106462: DIV
106463: ST_TO_ADDR
// if _y < 0 then
106464: LD_VAR 0 7
106468: PUSH
106469: LD_INT 0
106471: LESS
106472: IFFALSE 106489
// _y := _y * - 1 ;
106474: LD_ADDR_VAR 0 7
106478: PUSH
106479: LD_VAR 0 7
106483: PUSH
106484: LD_INT 1
106486: NEG
106487: MUL
106488: ST_TO_ADDR
// result := [ _x , _y ] ;
106489: LD_ADDR_VAR 0 5
106493: PUSH
106494: LD_VAR 0 6
106498: PUSH
106499: LD_VAR 0 7
106503: PUSH
106504: EMPTY
106505: LIST
106506: LIST
106507: ST_TO_ADDR
// end ;
106508: LD_VAR 0 5
106512: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
106513: LD_INT 0
106515: PPUSH
106516: PPUSH
106517: PPUSH
106518: PPUSH
// task := GetTaskList ( unit ) ;
106519: LD_ADDR_VAR 0 7
106523: PUSH
106524: LD_VAR 0 1
106528: PPUSH
106529: CALL_OW 437
106533: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
106534: LD_VAR 0 7
106538: NOT
106539: PUSH
106540: LD_VAR 0 1
106544: PPUSH
106545: LD_VAR 0 2
106549: PPUSH
106550: CALL_OW 308
106554: NOT
106555: AND
106556: IFFALSE 106560
// exit ;
106558: GO 106678
// if IsInArea ( unit , area ) then
106560: LD_VAR 0 1
106564: PPUSH
106565: LD_VAR 0 2
106569: PPUSH
106570: CALL_OW 308
106574: IFFALSE 106592
// begin ComMoveToArea ( unit , goAway ) ;
106576: LD_VAR 0 1
106580: PPUSH
106581: LD_VAR 0 3
106585: PPUSH
106586: CALL_OW 113
// exit ;
106590: GO 106678
// end ; if task [ 1 ] [ 1 ] <> M then
106592: LD_VAR 0 7
106596: PUSH
106597: LD_INT 1
106599: ARRAY
106600: PUSH
106601: LD_INT 1
106603: ARRAY
106604: PUSH
106605: LD_STRING M
106607: NONEQUAL
106608: IFFALSE 106612
// exit ;
106610: GO 106678
// x := task [ 1 ] [ 2 ] ;
106612: LD_ADDR_VAR 0 5
106616: PUSH
106617: LD_VAR 0 7
106621: PUSH
106622: LD_INT 1
106624: ARRAY
106625: PUSH
106626: LD_INT 2
106628: ARRAY
106629: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
106630: LD_ADDR_VAR 0 6
106634: PUSH
106635: LD_VAR 0 7
106639: PUSH
106640: LD_INT 1
106642: ARRAY
106643: PUSH
106644: LD_INT 3
106646: ARRAY
106647: ST_TO_ADDR
// if InArea ( x , y , area ) then
106648: LD_VAR 0 5
106652: PPUSH
106653: LD_VAR 0 6
106657: PPUSH
106658: LD_VAR 0 2
106662: PPUSH
106663: CALL_OW 309
106667: IFFALSE 106678
// ComStop ( unit ) ;
106669: LD_VAR 0 1
106673: PPUSH
106674: CALL_OW 141
// end ;
106678: LD_VAR 0 4
106682: RET
// export function Abs ( value ) ; begin
106683: LD_INT 0
106685: PPUSH
// result := value ;
106686: LD_ADDR_VAR 0 2
106690: PUSH
106691: LD_VAR 0 1
106695: ST_TO_ADDR
// if value < 0 then
106696: LD_VAR 0 1
106700: PUSH
106701: LD_INT 0
106703: LESS
106704: IFFALSE 106721
// result := value * - 1 ;
106706: LD_ADDR_VAR 0 2
106710: PUSH
106711: LD_VAR 0 1
106715: PUSH
106716: LD_INT 1
106718: NEG
106719: MUL
106720: ST_TO_ADDR
// end ;
106721: LD_VAR 0 2
106725: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
106726: LD_INT 0
106728: PPUSH
106729: PPUSH
106730: PPUSH
106731: PPUSH
106732: PPUSH
106733: PPUSH
106734: PPUSH
106735: PPUSH
// if not unit or not building then
106736: LD_VAR 0 1
106740: NOT
106741: PUSH
106742: LD_VAR 0 2
106746: NOT
106747: OR
106748: IFFALSE 106752
// exit ;
106750: GO 106978
// x := GetX ( building ) ;
106752: LD_ADDR_VAR 0 4
106756: PUSH
106757: LD_VAR 0 2
106761: PPUSH
106762: CALL_OW 250
106766: ST_TO_ADDR
// y := GetY ( building ) ;
106767: LD_ADDR_VAR 0 6
106771: PUSH
106772: LD_VAR 0 2
106776: PPUSH
106777: CALL_OW 251
106781: ST_TO_ADDR
// d := GetDir ( building ) ;
106782: LD_ADDR_VAR 0 8
106786: PUSH
106787: LD_VAR 0 2
106791: PPUSH
106792: CALL_OW 254
106796: ST_TO_ADDR
// r := 4 ;
106797: LD_ADDR_VAR 0 9
106801: PUSH
106802: LD_INT 4
106804: ST_TO_ADDR
// for i := 1 to 5 do
106805: LD_ADDR_VAR 0 10
106809: PUSH
106810: DOUBLE
106811: LD_INT 1
106813: DEC
106814: ST_TO_ADDR
106815: LD_INT 5
106817: PUSH
106818: FOR_TO
106819: IFFALSE 106976
// begin _x := ShiftX ( x , d , r + i ) ;
106821: LD_ADDR_VAR 0 5
106825: PUSH
106826: LD_VAR 0 4
106830: PPUSH
106831: LD_VAR 0 8
106835: PPUSH
106836: LD_VAR 0 9
106840: PUSH
106841: LD_VAR 0 10
106845: PLUS
106846: PPUSH
106847: CALL_OW 272
106851: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
106852: LD_ADDR_VAR 0 7
106856: PUSH
106857: LD_VAR 0 6
106861: PPUSH
106862: LD_VAR 0 8
106866: PPUSH
106867: LD_VAR 0 9
106871: PUSH
106872: LD_VAR 0 10
106876: PLUS
106877: PPUSH
106878: CALL_OW 273
106882: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
106883: LD_VAR 0 5
106887: PPUSH
106888: LD_VAR 0 7
106892: PPUSH
106893: CALL_OW 488
106897: PUSH
106898: LD_VAR 0 5
106902: PPUSH
106903: LD_VAR 0 7
106907: PPUSH
106908: CALL_OW 428
106912: PPUSH
106913: CALL_OW 247
106917: PUSH
106918: LD_INT 3
106920: PUSH
106921: LD_INT 2
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: IN
106928: NOT
106929: AND
106930: IFFALSE 106974
// begin ComMoveXY ( unit , _x , _y ) ;
106932: LD_VAR 0 1
106936: PPUSH
106937: LD_VAR 0 5
106941: PPUSH
106942: LD_VAR 0 7
106946: PPUSH
106947: CALL_OW 111
// result := [ _x , _y ] ;
106951: LD_ADDR_VAR 0 3
106955: PUSH
106956: LD_VAR 0 5
106960: PUSH
106961: LD_VAR 0 7
106965: PUSH
106966: EMPTY
106967: LIST
106968: LIST
106969: ST_TO_ADDR
// exit ;
106970: POP
106971: POP
106972: GO 106978
// end ; end ;
106974: GO 106818
106976: POP
106977: POP
// end ;
106978: LD_VAR 0 3
106982: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
106983: LD_INT 0
106985: PPUSH
106986: PPUSH
106987: PPUSH
// result := 0 ;
106988: LD_ADDR_VAR 0 3
106992: PUSH
106993: LD_INT 0
106995: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
106996: LD_VAR 0 1
107000: PUSH
107001: LD_INT 0
107003: LESS
107004: PUSH
107005: LD_VAR 0 1
107009: PUSH
107010: LD_INT 8
107012: GREATER
107013: OR
107014: PUSH
107015: LD_VAR 0 2
107019: PUSH
107020: LD_INT 0
107022: LESS
107023: OR
107024: PUSH
107025: LD_VAR 0 2
107029: PUSH
107030: LD_INT 8
107032: GREATER
107033: OR
107034: IFFALSE 107038
// exit ;
107036: GO 107113
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
107038: LD_ADDR_VAR 0 4
107042: PUSH
107043: LD_INT 22
107045: PUSH
107046: LD_VAR 0 2
107050: PUSH
107051: EMPTY
107052: LIST
107053: LIST
107054: PPUSH
107055: CALL_OW 69
107059: PUSH
107060: FOR_IN
107061: IFFALSE 107111
// begin un := UnitShoot ( i ) ;
107063: LD_ADDR_VAR 0 5
107067: PUSH
107068: LD_VAR 0 4
107072: PPUSH
107073: CALL_OW 504
107077: ST_TO_ADDR
// if GetSide ( un ) = side1 then
107078: LD_VAR 0 5
107082: PPUSH
107083: CALL_OW 255
107087: PUSH
107088: LD_VAR 0 1
107092: EQUAL
107093: IFFALSE 107109
// begin result := un ;
107095: LD_ADDR_VAR 0 3
107099: PUSH
107100: LD_VAR 0 5
107104: ST_TO_ADDR
// exit ;
107105: POP
107106: POP
107107: GO 107113
// end ; end ;
107109: GO 107060
107111: POP
107112: POP
// end ;
107113: LD_VAR 0 3
107117: RET
// export function GetCargoBay ( units ) ; begin
107118: LD_INT 0
107120: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
107121: LD_ADDR_VAR 0 2
107125: PUSH
107126: LD_VAR 0 1
107130: PPUSH
107131: LD_INT 2
107133: PUSH
107134: LD_INT 34
107136: PUSH
107137: LD_INT 12
107139: PUSH
107140: EMPTY
107141: LIST
107142: LIST
107143: PUSH
107144: LD_INT 34
107146: PUSH
107147: LD_INT 51
107149: PUSH
107150: EMPTY
107151: LIST
107152: LIST
107153: PUSH
107154: LD_INT 34
107156: PUSH
107157: LD_INT 32
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: PUSH
107164: LD_INT 34
107166: PUSH
107167: LD_INT 89
107169: PUSH
107170: EMPTY
107171: LIST
107172: LIST
107173: PUSH
107174: EMPTY
107175: LIST
107176: LIST
107177: LIST
107178: LIST
107179: LIST
107180: PPUSH
107181: CALL_OW 72
107185: ST_TO_ADDR
// end ;
107186: LD_VAR 0 2
107190: RET
// export function Negate ( value ) ; begin
107191: LD_INT 0
107193: PPUSH
// result := not value ;
107194: LD_ADDR_VAR 0 2
107198: PUSH
107199: LD_VAR 0 1
107203: NOT
107204: ST_TO_ADDR
// end ;
107205: LD_VAR 0 2
107209: RET
// export function Inc ( value ) ; begin
107210: LD_INT 0
107212: PPUSH
// result := value + 1 ;
107213: LD_ADDR_VAR 0 2
107217: PUSH
107218: LD_VAR 0 1
107222: PUSH
107223: LD_INT 1
107225: PLUS
107226: ST_TO_ADDR
// end ;
107227: LD_VAR 0 2
107231: RET
// export function Dec ( value ) ; begin
107232: LD_INT 0
107234: PPUSH
// result := value - 1 ;
107235: LD_ADDR_VAR 0 2
107239: PUSH
107240: LD_VAR 0 1
107244: PUSH
107245: LD_INT 1
107247: MINUS
107248: ST_TO_ADDR
// end ;
107249: LD_VAR 0 2
107253: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
107254: LD_INT 0
107256: PPUSH
107257: PPUSH
107258: PPUSH
107259: PPUSH
107260: PPUSH
107261: PPUSH
107262: PPUSH
107263: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
107264: LD_VAR 0 1
107268: PPUSH
107269: LD_VAR 0 2
107273: PPUSH
107274: CALL_OW 488
107278: NOT
107279: PUSH
107280: LD_VAR 0 3
107284: PPUSH
107285: LD_VAR 0 4
107289: PPUSH
107290: CALL_OW 488
107294: NOT
107295: OR
107296: IFFALSE 107309
// begin result := - 1 ;
107298: LD_ADDR_VAR 0 5
107302: PUSH
107303: LD_INT 1
107305: NEG
107306: ST_TO_ADDR
// exit ;
107307: GO 107544
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
107309: LD_ADDR_VAR 0 12
107313: PUSH
107314: LD_VAR 0 1
107318: PPUSH
107319: LD_VAR 0 2
107323: PPUSH
107324: LD_VAR 0 3
107328: PPUSH
107329: LD_VAR 0 4
107333: PPUSH
107334: CALL 106394 0 4
107338: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
107339: LD_ADDR_VAR 0 11
107343: PUSH
107344: LD_VAR 0 1
107348: PPUSH
107349: LD_VAR 0 2
107353: PPUSH
107354: LD_VAR 0 12
107358: PUSH
107359: LD_INT 1
107361: ARRAY
107362: PPUSH
107363: LD_VAR 0 12
107367: PUSH
107368: LD_INT 2
107370: ARRAY
107371: PPUSH
107372: CALL_OW 298
107376: ST_TO_ADDR
// distance := 9999 ;
107377: LD_ADDR_VAR 0 10
107381: PUSH
107382: LD_INT 9999
107384: ST_TO_ADDR
// for i := 0 to 5 do
107385: LD_ADDR_VAR 0 6
107389: PUSH
107390: DOUBLE
107391: LD_INT 0
107393: DEC
107394: ST_TO_ADDR
107395: LD_INT 5
107397: PUSH
107398: FOR_TO
107399: IFFALSE 107542
// begin _x := ShiftX ( x1 , i , centerDist ) ;
107401: LD_ADDR_VAR 0 7
107405: PUSH
107406: LD_VAR 0 1
107410: PPUSH
107411: LD_VAR 0 6
107415: PPUSH
107416: LD_VAR 0 11
107420: PPUSH
107421: CALL_OW 272
107425: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
107426: LD_ADDR_VAR 0 8
107430: PUSH
107431: LD_VAR 0 2
107435: PPUSH
107436: LD_VAR 0 6
107440: PPUSH
107441: LD_VAR 0 11
107445: PPUSH
107446: CALL_OW 273
107450: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107451: LD_VAR 0 7
107455: PPUSH
107456: LD_VAR 0 8
107460: PPUSH
107461: CALL_OW 488
107465: NOT
107466: IFFALSE 107470
// continue ;
107468: GO 107398
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
107470: LD_ADDR_VAR 0 9
107474: PUSH
107475: LD_VAR 0 12
107479: PUSH
107480: LD_INT 1
107482: ARRAY
107483: PPUSH
107484: LD_VAR 0 12
107488: PUSH
107489: LD_INT 2
107491: ARRAY
107492: PPUSH
107493: LD_VAR 0 7
107497: PPUSH
107498: LD_VAR 0 8
107502: PPUSH
107503: CALL_OW 298
107507: ST_TO_ADDR
// if tmp < distance then
107508: LD_VAR 0 9
107512: PUSH
107513: LD_VAR 0 10
107517: LESS
107518: IFFALSE 107540
// begin result := i ;
107520: LD_ADDR_VAR 0 5
107524: PUSH
107525: LD_VAR 0 6
107529: ST_TO_ADDR
// distance := tmp ;
107530: LD_ADDR_VAR 0 10
107534: PUSH
107535: LD_VAR 0 9
107539: ST_TO_ADDR
// end ; end ;
107540: GO 107398
107542: POP
107543: POP
// end ;
107544: LD_VAR 0 5
107548: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107549: LD_INT 0
107551: PPUSH
107552: PPUSH
// if not driver or not IsInUnit ( driver ) then
107553: LD_VAR 0 1
107557: NOT
107558: PUSH
107559: LD_VAR 0 1
107563: PPUSH
107564: CALL_OW 310
107568: NOT
107569: OR
107570: IFFALSE 107574
// exit ;
107572: GO 107664
// vehicle := IsInUnit ( driver ) ;
107574: LD_ADDR_VAR 0 3
107578: PUSH
107579: LD_VAR 0 1
107583: PPUSH
107584: CALL_OW 310
107588: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107589: LD_VAR 0 1
107593: PPUSH
107594: LD_STRING \
107596: PUSH
107597: LD_INT 0
107599: PUSH
107600: LD_INT 0
107602: PUSH
107603: LD_INT 0
107605: PUSH
107606: LD_INT 0
107608: PUSH
107609: LD_INT 0
107611: PUSH
107612: LD_INT 0
107614: PUSH
107615: EMPTY
107616: LIST
107617: LIST
107618: LIST
107619: LIST
107620: LIST
107621: LIST
107622: LIST
107623: PUSH
107624: LD_STRING E
107626: PUSH
107627: LD_INT 0
107629: PUSH
107630: LD_INT 0
107632: PUSH
107633: LD_VAR 0 3
107637: PUSH
107638: LD_INT 0
107640: PUSH
107641: LD_INT 0
107643: PUSH
107644: LD_INT 0
107646: PUSH
107647: EMPTY
107648: LIST
107649: LIST
107650: LIST
107651: LIST
107652: LIST
107653: LIST
107654: LIST
107655: PUSH
107656: EMPTY
107657: LIST
107658: LIST
107659: PPUSH
107660: CALL_OW 446
// end ;
107664: LD_VAR 0 2
107668: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107669: LD_INT 0
107671: PPUSH
107672: PPUSH
// if not driver or not IsInUnit ( driver ) then
107673: LD_VAR 0 1
107677: NOT
107678: PUSH
107679: LD_VAR 0 1
107683: PPUSH
107684: CALL_OW 310
107688: NOT
107689: OR
107690: IFFALSE 107694
// exit ;
107692: GO 107784
// vehicle := IsInUnit ( driver ) ;
107694: LD_ADDR_VAR 0 3
107698: PUSH
107699: LD_VAR 0 1
107703: PPUSH
107704: CALL_OW 310
107708: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107709: LD_VAR 0 1
107713: PPUSH
107714: LD_STRING \
107716: PUSH
107717: LD_INT 0
107719: PUSH
107720: LD_INT 0
107722: PUSH
107723: LD_INT 0
107725: PUSH
107726: LD_INT 0
107728: PUSH
107729: LD_INT 0
107731: PUSH
107732: LD_INT 0
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: LIST
107739: LIST
107740: LIST
107741: LIST
107742: LIST
107743: PUSH
107744: LD_STRING E
107746: PUSH
107747: LD_INT 0
107749: PUSH
107750: LD_INT 0
107752: PUSH
107753: LD_VAR 0 3
107757: PUSH
107758: LD_INT 0
107760: PUSH
107761: LD_INT 0
107763: PUSH
107764: LD_INT 0
107766: PUSH
107767: EMPTY
107768: LIST
107769: LIST
107770: LIST
107771: LIST
107772: LIST
107773: LIST
107774: LIST
107775: PUSH
107776: EMPTY
107777: LIST
107778: LIST
107779: PPUSH
107780: CALL_OW 447
// end ;
107784: LD_VAR 0 2
107788: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
107789: LD_INT 0
107791: PPUSH
107792: PPUSH
107793: PPUSH
// tmp := [ ] ;
107794: LD_ADDR_VAR 0 5
107798: PUSH
107799: EMPTY
107800: ST_TO_ADDR
// for i in units do
107801: LD_ADDR_VAR 0 4
107805: PUSH
107806: LD_VAR 0 1
107810: PUSH
107811: FOR_IN
107812: IFFALSE 107850
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
107814: LD_ADDR_VAR 0 5
107818: PUSH
107819: LD_VAR 0 5
107823: PPUSH
107824: LD_VAR 0 5
107828: PUSH
107829: LD_INT 1
107831: PLUS
107832: PPUSH
107833: LD_VAR 0 4
107837: PPUSH
107838: CALL_OW 256
107842: PPUSH
107843: CALL_OW 2
107847: ST_TO_ADDR
107848: GO 107811
107850: POP
107851: POP
// if not tmp then
107852: LD_VAR 0 5
107856: NOT
107857: IFFALSE 107861
// exit ;
107859: GO 107909
// if asc then
107861: LD_VAR 0 2
107865: IFFALSE 107889
// result := SortListByListAsc ( units , tmp ) else
107867: LD_ADDR_VAR 0 3
107871: PUSH
107872: LD_VAR 0 1
107876: PPUSH
107877: LD_VAR 0 5
107881: PPUSH
107882: CALL_OW 76
107886: ST_TO_ADDR
107887: GO 107909
// result := SortListByListDesc ( units , tmp ) ;
107889: LD_ADDR_VAR 0 3
107893: PUSH
107894: LD_VAR 0 1
107898: PPUSH
107899: LD_VAR 0 5
107903: PPUSH
107904: CALL_OW 77
107908: ST_TO_ADDR
// end ;
107909: LD_VAR 0 3
107913: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
107914: LD_INT 0
107916: PPUSH
107917: PPUSH
// task := GetTaskList ( mech ) ;
107918: LD_ADDR_VAR 0 4
107922: PUSH
107923: LD_VAR 0 1
107927: PPUSH
107928: CALL_OW 437
107932: ST_TO_ADDR
// if not task then
107933: LD_VAR 0 4
107937: NOT
107938: IFFALSE 107942
// exit ;
107940: GO 107984
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
107942: LD_ADDR_VAR 0 3
107946: PUSH
107947: LD_VAR 0 4
107951: PUSH
107952: LD_INT 1
107954: ARRAY
107955: PUSH
107956: LD_INT 1
107958: ARRAY
107959: PUSH
107960: LD_STRING r
107962: EQUAL
107963: PUSH
107964: LD_VAR 0 4
107968: PUSH
107969: LD_INT 1
107971: ARRAY
107972: PUSH
107973: LD_INT 4
107975: ARRAY
107976: PUSH
107977: LD_VAR 0 2
107981: EQUAL
107982: AND
107983: ST_TO_ADDR
// end ;
107984: LD_VAR 0 3
107988: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
107989: LD_INT 0
107991: PPUSH
// SetDir ( unit , d ) ;
107992: LD_VAR 0 1
107996: PPUSH
107997: LD_VAR 0 4
108001: PPUSH
108002: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
108006: LD_VAR 0 1
108010: PPUSH
108011: LD_VAR 0 2
108015: PPUSH
108016: LD_VAR 0 3
108020: PPUSH
108021: LD_VAR 0 5
108025: PPUSH
108026: CALL_OW 48
// end ;
108030: LD_VAR 0 6
108034: RET
// export function ToNaturalNumber ( number ) ; begin
108035: LD_INT 0
108037: PPUSH
// result := number div 1 ;
108038: LD_ADDR_VAR 0 2
108042: PUSH
108043: LD_VAR 0 1
108047: PUSH
108048: LD_INT 1
108050: DIV
108051: ST_TO_ADDR
// if number < 0 then
108052: LD_VAR 0 1
108056: PUSH
108057: LD_INT 0
108059: LESS
108060: IFFALSE 108070
// result := 0 ;
108062: LD_ADDR_VAR 0 2
108066: PUSH
108067: LD_INT 0
108069: ST_TO_ADDR
// end ;
108070: LD_VAR 0 2
108074: RET
// export function SortByClass ( units , class ) ; var un ; begin
108075: LD_INT 0
108077: PPUSH
108078: PPUSH
// if not units or not class then
108079: LD_VAR 0 1
108083: NOT
108084: PUSH
108085: LD_VAR 0 2
108089: NOT
108090: OR
108091: IFFALSE 108095
// exit ;
108093: GO 108190
// result := [ ] ;
108095: LD_ADDR_VAR 0 3
108099: PUSH
108100: EMPTY
108101: ST_TO_ADDR
// for un in units do
108102: LD_ADDR_VAR 0 4
108106: PUSH
108107: LD_VAR 0 1
108111: PUSH
108112: FOR_IN
108113: IFFALSE 108188
// if GetClass ( un ) = class then
108115: LD_VAR 0 4
108119: PPUSH
108120: CALL_OW 257
108124: PUSH
108125: LD_VAR 0 2
108129: EQUAL
108130: IFFALSE 108157
// result := Insert ( result , 1 , un ) else
108132: LD_ADDR_VAR 0 3
108136: PUSH
108137: LD_VAR 0 3
108141: PPUSH
108142: LD_INT 1
108144: PPUSH
108145: LD_VAR 0 4
108149: PPUSH
108150: CALL_OW 2
108154: ST_TO_ADDR
108155: GO 108186
// result := Replace ( result , result + 1 , un ) ;
108157: LD_ADDR_VAR 0 3
108161: PUSH
108162: LD_VAR 0 3
108166: PPUSH
108167: LD_VAR 0 3
108171: PUSH
108172: LD_INT 1
108174: PLUS
108175: PPUSH
108176: LD_VAR 0 4
108180: PPUSH
108181: CALL_OW 1
108185: ST_TO_ADDR
108186: GO 108112
108188: POP
108189: POP
// end ;
108190: LD_VAR 0 3
108194: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
108195: LD_INT 0
108197: PPUSH
108198: PPUSH
108199: PPUSH
108200: PPUSH
108201: PPUSH
108202: PPUSH
108203: PPUSH
// result := [ ] ;
108204: LD_ADDR_VAR 0 4
108208: PUSH
108209: EMPTY
108210: ST_TO_ADDR
// if x - r < 0 then
108211: LD_VAR 0 1
108215: PUSH
108216: LD_VAR 0 3
108220: MINUS
108221: PUSH
108222: LD_INT 0
108224: LESS
108225: IFFALSE 108237
// min_x := 0 else
108227: LD_ADDR_VAR 0 8
108231: PUSH
108232: LD_INT 0
108234: ST_TO_ADDR
108235: GO 108253
// min_x := x - r ;
108237: LD_ADDR_VAR 0 8
108241: PUSH
108242: LD_VAR 0 1
108246: PUSH
108247: LD_VAR 0 3
108251: MINUS
108252: ST_TO_ADDR
// if y - r < 0 then
108253: LD_VAR 0 2
108257: PUSH
108258: LD_VAR 0 3
108262: MINUS
108263: PUSH
108264: LD_INT 0
108266: LESS
108267: IFFALSE 108279
// min_y := 0 else
108269: LD_ADDR_VAR 0 7
108273: PUSH
108274: LD_INT 0
108276: ST_TO_ADDR
108277: GO 108295
// min_y := y - r ;
108279: LD_ADDR_VAR 0 7
108283: PUSH
108284: LD_VAR 0 2
108288: PUSH
108289: LD_VAR 0 3
108293: MINUS
108294: ST_TO_ADDR
// max_x := x + r ;
108295: LD_ADDR_VAR 0 9
108299: PUSH
108300: LD_VAR 0 1
108304: PUSH
108305: LD_VAR 0 3
108309: PLUS
108310: ST_TO_ADDR
// max_y := y + r ;
108311: LD_ADDR_VAR 0 10
108315: PUSH
108316: LD_VAR 0 2
108320: PUSH
108321: LD_VAR 0 3
108325: PLUS
108326: ST_TO_ADDR
// for _x = min_x to max_x do
108327: LD_ADDR_VAR 0 5
108331: PUSH
108332: DOUBLE
108333: LD_VAR 0 8
108337: DEC
108338: ST_TO_ADDR
108339: LD_VAR 0 9
108343: PUSH
108344: FOR_TO
108345: IFFALSE 108446
// for _y = min_y to max_y do
108347: LD_ADDR_VAR 0 6
108351: PUSH
108352: DOUBLE
108353: LD_VAR 0 7
108357: DEC
108358: ST_TO_ADDR
108359: LD_VAR 0 10
108363: PUSH
108364: FOR_TO
108365: IFFALSE 108442
// begin if not ValidHex ( _x , _y ) then
108367: LD_VAR 0 5
108371: PPUSH
108372: LD_VAR 0 6
108376: PPUSH
108377: CALL_OW 488
108381: NOT
108382: IFFALSE 108386
// continue ;
108384: GO 108364
// if GetResourceTypeXY ( _x , _y ) then
108386: LD_VAR 0 5
108390: PPUSH
108391: LD_VAR 0 6
108395: PPUSH
108396: CALL_OW 283
108400: IFFALSE 108440
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
108402: LD_ADDR_VAR 0 4
108406: PUSH
108407: LD_VAR 0 4
108411: PPUSH
108412: LD_VAR 0 4
108416: PUSH
108417: LD_INT 1
108419: PLUS
108420: PPUSH
108421: LD_VAR 0 5
108425: PUSH
108426: LD_VAR 0 6
108430: PUSH
108431: EMPTY
108432: LIST
108433: LIST
108434: PPUSH
108435: CALL_OW 1
108439: ST_TO_ADDR
// end ;
108440: GO 108364
108442: POP
108443: POP
108444: GO 108344
108446: POP
108447: POP
// end ;
108448: LD_VAR 0 4
108452: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
108453: LD_INT 0
108455: PPUSH
108456: PPUSH
108457: PPUSH
108458: PPUSH
108459: PPUSH
108460: PPUSH
108461: PPUSH
108462: PPUSH
// if not units then
108463: LD_VAR 0 1
108467: NOT
108468: IFFALSE 108472
// exit ;
108470: GO 108996
// result := UnitFilter ( units , [ f_ok ] ) ;
108472: LD_ADDR_VAR 0 3
108476: PUSH
108477: LD_VAR 0 1
108481: PPUSH
108482: LD_INT 50
108484: PUSH
108485: EMPTY
108486: LIST
108487: PPUSH
108488: CALL_OW 72
108492: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
108493: LD_ADDR_VAR 0 8
108497: PUSH
108498: LD_VAR 0 1
108502: PUSH
108503: LD_INT 1
108505: ARRAY
108506: PPUSH
108507: CALL_OW 255
108511: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
108512: LD_ADDR_VAR 0 10
108516: PUSH
108517: LD_INT 29
108519: PUSH
108520: LD_INT 91
108522: PUSH
108523: LD_INT 49
108525: PUSH
108526: EMPTY
108527: LIST
108528: LIST
108529: LIST
108530: ST_TO_ADDR
// if not result then
108531: LD_VAR 0 3
108535: NOT
108536: IFFALSE 108540
// exit ;
108538: GO 108996
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
108540: LD_ADDR_VAR 0 5
108544: PUSH
108545: LD_INT 81
108547: PUSH
108548: LD_VAR 0 8
108552: PUSH
108553: EMPTY
108554: LIST
108555: LIST
108556: PPUSH
108557: CALL_OW 69
108561: ST_TO_ADDR
// for i in result do
108562: LD_ADDR_VAR 0 4
108566: PUSH
108567: LD_VAR 0 3
108571: PUSH
108572: FOR_IN
108573: IFFALSE 108994
// begin tag := GetTag ( i ) + 1 ;
108575: LD_ADDR_VAR 0 9
108579: PUSH
108580: LD_VAR 0 4
108584: PPUSH
108585: CALL_OW 110
108589: PUSH
108590: LD_INT 1
108592: PLUS
108593: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
108594: LD_ADDR_VAR 0 7
108598: PUSH
108599: LD_VAR 0 4
108603: PPUSH
108604: CALL_OW 250
108608: PPUSH
108609: LD_VAR 0 4
108613: PPUSH
108614: CALL_OW 251
108618: PPUSH
108619: LD_INT 6
108621: PPUSH
108622: CALL 108195 0 3
108626: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
108627: LD_VAR 0 4
108631: PPUSH
108632: CALL_OW 247
108636: PUSH
108637: LD_INT 2
108639: EQUAL
108640: PUSH
108641: LD_VAR 0 7
108645: AND
108646: PUSH
108647: LD_VAR 0 4
108651: PPUSH
108652: CALL_OW 264
108656: PUSH
108657: LD_VAR 0 10
108661: IN
108662: NOT
108663: AND
108664: IFFALSE 108703
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
108666: LD_VAR 0 4
108670: PPUSH
108671: LD_VAR 0 7
108675: PUSH
108676: LD_INT 1
108678: ARRAY
108679: PUSH
108680: LD_INT 1
108682: ARRAY
108683: PPUSH
108684: LD_VAR 0 7
108688: PUSH
108689: LD_INT 1
108691: ARRAY
108692: PUSH
108693: LD_INT 2
108695: ARRAY
108696: PPUSH
108697: CALL_OW 116
108701: GO 108992
// if path > tag then
108703: LD_VAR 0 2
108707: PUSH
108708: LD_VAR 0 9
108712: GREATER
108713: IFFALSE 108921
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
108715: LD_ADDR_VAR 0 6
108719: PUSH
108720: LD_VAR 0 5
108724: PPUSH
108725: LD_INT 91
108727: PUSH
108728: LD_VAR 0 4
108732: PUSH
108733: LD_INT 8
108735: PUSH
108736: EMPTY
108737: LIST
108738: LIST
108739: LIST
108740: PPUSH
108741: CALL_OW 72
108745: ST_TO_ADDR
// if nearEnemy then
108746: LD_VAR 0 6
108750: IFFALSE 108819
// begin if GetWeapon ( i ) = ru_time_lapser then
108752: LD_VAR 0 4
108756: PPUSH
108757: CALL_OW 264
108761: PUSH
108762: LD_INT 49
108764: EQUAL
108765: IFFALSE 108793
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
108767: LD_VAR 0 4
108771: PPUSH
108772: LD_VAR 0 6
108776: PPUSH
108777: LD_VAR 0 4
108781: PPUSH
108782: CALL_OW 74
108786: PPUSH
108787: CALL_OW 112
108791: GO 108817
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
108793: LD_VAR 0 4
108797: PPUSH
108798: LD_VAR 0 6
108802: PPUSH
108803: LD_VAR 0 4
108807: PPUSH
108808: CALL_OW 74
108812: PPUSH
108813: CALL_OW 115
// end else
108817: GO 108919
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
108819: LD_VAR 0 4
108823: PPUSH
108824: LD_VAR 0 2
108828: PUSH
108829: LD_VAR 0 9
108833: ARRAY
108834: PUSH
108835: LD_INT 1
108837: ARRAY
108838: PPUSH
108839: LD_VAR 0 2
108843: PUSH
108844: LD_VAR 0 9
108848: ARRAY
108849: PUSH
108850: LD_INT 2
108852: ARRAY
108853: PPUSH
108854: CALL_OW 297
108858: PUSH
108859: LD_INT 6
108861: GREATER
108862: IFFALSE 108905
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
108864: LD_VAR 0 4
108868: PPUSH
108869: LD_VAR 0 2
108873: PUSH
108874: LD_VAR 0 9
108878: ARRAY
108879: PUSH
108880: LD_INT 1
108882: ARRAY
108883: PPUSH
108884: LD_VAR 0 2
108888: PUSH
108889: LD_VAR 0 9
108893: ARRAY
108894: PUSH
108895: LD_INT 2
108897: ARRAY
108898: PPUSH
108899: CALL_OW 114
108903: GO 108919
// SetTag ( i , tag ) ;
108905: LD_VAR 0 4
108909: PPUSH
108910: LD_VAR 0 9
108914: PPUSH
108915: CALL_OW 109
// end else
108919: GO 108992
// if enemy then
108921: LD_VAR 0 5
108925: IFFALSE 108992
// begin if GetWeapon ( i ) = ru_time_lapser then
108927: LD_VAR 0 4
108931: PPUSH
108932: CALL_OW 264
108936: PUSH
108937: LD_INT 49
108939: EQUAL
108940: IFFALSE 108968
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
108942: LD_VAR 0 4
108946: PPUSH
108947: LD_VAR 0 5
108951: PPUSH
108952: LD_VAR 0 4
108956: PPUSH
108957: CALL_OW 74
108961: PPUSH
108962: CALL_OW 112
108966: GO 108992
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
108968: LD_VAR 0 4
108972: PPUSH
108973: LD_VAR 0 5
108977: PPUSH
108978: LD_VAR 0 4
108982: PPUSH
108983: CALL_OW 74
108987: PPUSH
108988: CALL_OW 115
// end ; end ;
108992: GO 108572
108994: POP
108995: POP
// end ;
108996: LD_VAR 0 3
109000: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
109001: LD_INT 0
109003: PPUSH
109004: PPUSH
109005: PPUSH
// if not unit or IsInUnit ( unit ) then
109006: LD_VAR 0 1
109010: NOT
109011: PUSH
109012: LD_VAR 0 1
109016: PPUSH
109017: CALL_OW 310
109021: OR
109022: IFFALSE 109026
// exit ;
109024: GO 109117
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
109026: LD_ADDR_VAR 0 4
109030: PUSH
109031: LD_VAR 0 1
109035: PPUSH
109036: CALL_OW 250
109040: PPUSH
109041: LD_VAR 0 2
109045: PPUSH
109046: LD_INT 1
109048: PPUSH
109049: CALL_OW 272
109053: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
109054: LD_ADDR_VAR 0 5
109058: PUSH
109059: LD_VAR 0 1
109063: PPUSH
109064: CALL_OW 251
109068: PPUSH
109069: LD_VAR 0 2
109073: PPUSH
109074: LD_INT 1
109076: PPUSH
109077: CALL_OW 273
109081: ST_TO_ADDR
// if ValidHex ( x , y ) then
109082: LD_VAR 0 4
109086: PPUSH
109087: LD_VAR 0 5
109091: PPUSH
109092: CALL_OW 488
109096: IFFALSE 109117
// ComTurnXY ( unit , x , y ) ;
109098: LD_VAR 0 1
109102: PPUSH
109103: LD_VAR 0 4
109107: PPUSH
109108: LD_VAR 0 5
109112: PPUSH
109113: CALL_OW 118
// end ;
109117: LD_VAR 0 3
109121: RET
// export function SeeUnits ( side , units ) ; var i ; begin
109122: LD_INT 0
109124: PPUSH
109125: PPUSH
// result := false ;
109126: LD_ADDR_VAR 0 3
109130: PUSH
109131: LD_INT 0
109133: ST_TO_ADDR
// if not units then
109134: LD_VAR 0 2
109138: NOT
109139: IFFALSE 109143
// exit ;
109141: GO 109188
// for i in units do
109143: LD_ADDR_VAR 0 4
109147: PUSH
109148: LD_VAR 0 2
109152: PUSH
109153: FOR_IN
109154: IFFALSE 109186
// if See ( side , i ) then
109156: LD_VAR 0 1
109160: PPUSH
109161: LD_VAR 0 4
109165: PPUSH
109166: CALL_OW 292
109170: IFFALSE 109184
// begin result := true ;
109172: LD_ADDR_VAR 0 3
109176: PUSH
109177: LD_INT 1
109179: ST_TO_ADDR
// exit ;
109180: POP
109181: POP
109182: GO 109188
// end ;
109184: GO 109153
109186: POP
109187: POP
// end ;
109188: LD_VAR 0 3
109192: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
109193: LD_INT 0
109195: PPUSH
109196: PPUSH
109197: PPUSH
109198: PPUSH
// if not unit or not points then
109199: LD_VAR 0 1
109203: NOT
109204: PUSH
109205: LD_VAR 0 2
109209: NOT
109210: OR
109211: IFFALSE 109215
// exit ;
109213: GO 109305
// dist := 99999 ;
109215: LD_ADDR_VAR 0 5
109219: PUSH
109220: LD_INT 99999
109222: ST_TO_ADDR
// for i in points do
109223: LD_ADDR_VAR 0 4
109227: PUSH
109228: LD_VAR 0 2
109232: PUSH
109233: FOR_IN
109234: IFFALSE 109303
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
109236: LD_ADDR_VAR 0 6
109240: PUSH
109241: LD_VAR 0 1
109245: PPUSH
109246: LD_VAR 0 4
109250: PUSH
109251: LD_INT 1
109253: ARRAY
109254: PPUSH
109255: LD_VAR 0 4
109259: PUSH
109260: LD_INT 2
109262: ARRAY
109263: PPUSH
109264: CALL_OW 297
109268: ST_TO_ADDR
// if tmpDist < dist then
109269: LD_VAR 0 6
109273: PUSH
109274: LD_VAR 0 5
109278: LESS
109279: IFFALSE 109301
// begin result := i ;
109281: LD_ADDR_VAR 0 3
109285: PUSH
109286: LD_VAR 0 4
109290: ST_TO_ADDR
// dist := tmpDist ;
109291: LD_ADDR_VAR 0 5
109295: PUSH
109296: LD_VAR 0 6
109300: ST_TO_ADDR
// end ; end ;
109301: GO 109233
109303: POP
109304: POP
// end ;
109305: LD_VAR 0 3
109309: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
109310: LD_INT 0
109312: PPUSH
// uc_side := side ;
109313: LD_ADDR_OWVAR 20
109317: PUSH
109318: LD_VAR 0 1
109322: ST_TO_ADDR
// uc_nation := 3 ;
109323: LD_ADDR_OWVAR 21
109327: PUSH
109328: LD_INT 3
109330: ST_TO_ADDR
// vc_chassis := 25 ;
109331: LD_ADDR_OWVAR 37
109335: PUSH
109336: LD_INT 25
109338: ST_TO_ADDR
// vc_engine := engine_siberite ;
109339: LD_ADDR_OWVAR 39
109343: PUSH
109344: LD_INT 3
109346: ST_TO_ADDR
// vc_control := control_computer ;
109347: LD_ADDR_OWVAR 38
109351: PUSH
109352: LD_INT 3
109354: ST_TO_ADDR
// vc_weapon := 59 ;
109355: LD_ADDR_OWVAR 40
109359: PUSH
109360: LD_INT 59
109362: ST_TO_ADDR
// result := CreateVehicle ;
109363: LD_ADDR_VAR 0 5
109367: PUSH
109368: CALL_OW 45
109372: ST_TO_ADDR
// SetDir ( result , d ) ;
109373: LD_VAR 0 5
109377: PPUSH
109378: LD_VAR 0 4
109382: PPUSH
109383: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
109387: LD_VAR 0 5
109391: PPUSH
109392: LD_VAR 0 2
109396: PPUSH
109397: LD_VAR 0 3
109401: PPUSH
109402: LD_INT 0
109404: PPUSH
109405: CALL_OW 48
// end ;
109409: LD_VAR 0 5
109413: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
109414: LD_INT 0
109416: PPUSH
109417: PPUSH
109418: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
109419: LD_ADDR_VAR 0 2
109423: PUSH
109424: LD_INT 0
109426: PUSH
109427: LD_INT 0
109429: PUSH
109430: LD_INT 0
109432: PUSH
109433: LD_INT 0
109435: PUSH
109436: EMPTY
109437: LIST
109438: LIST
109439: LIST
109440: LIST
109441: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
109442: LD_VAR 0 1
109446: NOT
109447: PUSH
109448: LD_VAR 0 1
109452: PPUSH
109453: CALL_OW 264
109457: PUSH
109458: LD_INT 12
109460: PUSH
109461: LD_INT 51
109463: PUSH
109464: LD_INT 32
109466: PUSH
109467: LD_INT 89
109469: PUSH
109470: EMPTY
109471: LIST
109472: LIST
109473: LIST
109474: LIST
109475: IN
109476: NOT
109477: OR
109478: IFFALSE 109482
// exit ;
109480: GO 109580
// for i := 1 to 3 do
109482: LD_ADDR_VAR 0 3
109486: PUSH
109487: DOUBLE
109488: LD_INT 1
109490: DEC
109491: ST_TO_ADDR
109492: LD_INT 3
109494: PUSH
109495: FOR_TO
109496: IFFALSE 109578
// begin tmp := GetCargo ( cargo , i ) ;
109498: LD_ADDR_VAR 0 4
109502: PUSH
109503: LD_VAR 0 1
109507: PPUSH
109508: LD_VAR 0 3
109512: PPUSH
109513: CALL_OW 289
109517: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
109518: LD_ADDR_VAR 0 2
109522: PUSH
109523: LD_VAR 0 2
109527: PPUSH
109528: LD_VAR 0 3
109532: PPUSH
109533: LD_VAR 0 4
109537: PPUSH
109538: CALL_OW 1
109542: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
109543: LD_ADDR_VAR 0 2
109547: PUSH
109548: LD_VAR 0 2
109552: PPUSH
109553: LD_INT 4
109555: PPUSH
109556: LD_VAR 0 2
109560: PUSH
109561: LD_INT 4
109563: ARRAY
109564: PUSH
109565: LD_VAR 0 4
109569: PLUS
109570: PPUSH
109571: CALL_OW 1
109575: ST_TO_ADDR
// end ;
109576: GO 109495
109578: POP
109579: POP
// end ;
109580: LD_VAR 0 2
109584: RET
// export function Length ( array ) ; begin
109585: LD_INT 0
109587: PPUSH
// result := array + 0 ;
109588: LD_ADDR_VAR 0 2
109592: PUSH
109593: LD_VAR 0 1
109597: PUSH
109598: LD_INT 0
109600: PLUS
109601: ST_TO_ADDR
// end ;
109602: LD_VAR 0 2
109606: RET
// export function PrepareArray ( array ) ; begin
109607: LD_INT 0
109609: PPUSH
// result := array diff 0 ;
109610: LD_ADDR_VAR 0 2
109614: PUSH
109615: LD_VAR 0 1
109619: PUSH
109620: LD_INT 0
109622: DIFF
109623: ST_TO_ADDR
// if not result [ 1 ] then
109624: LD_VAR 0 2
109628: PUSH
109629: LD_INT 1
109631: ARRAY
109632: NOT
109633: IFFALSE 109653
// result := Delete ( result , 1 ) ;
109635: LD_ADDR_VAR 0 2
109639: PUSH
109640: LD_VAR 0 2
109644: PPUSH
109645: LD_INT 1
109647: PPUSH
109648: CALL_OW 3
109652: ST_TO_ADDR
// end ;
109653: LD_VAR 0 2
109657: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
109658: LD_INT 0
109660: PPUSH
109661: PPUSH
109662: PPUSH
109663: PPUSH
// sibRocketRange := 25 ;
109664: LD_ADDR_VAR 0 6
109668: PUSH
109669: LD_INT 25
109671: ST_TO_ADDR
// result := false ;
109672: LD_ADDR_VAR 0 4
109676: PUSH
109677: LD_INT 0
109679: ST_TO_ADDR
// for i := 0 to 5 do
109680: LD_ADDR_VAR 0 5
109684: PUSH
109685: DOUBLE
109686: LD_INT 0
109688: DEC
109689: ST_TO_ADDR
109690: LD_INT 5
109692: PUSH
109693: FOR_TO
109694: IFFALSE 109761
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
109696: LD_VAR 0 1
109700: PPUSH
109701: LD_VAR 0 5
109705: PPUSH
109706: LD_VAR 0 6
109710: PPUSH
109711: CALL_OW 272
109715: PPUSH
109716: LD_VAR 0 2
109720: PPUSH
109721: LD_VAR 0 5
109725: PPUSH
109726: LD_VAR 0 6
109730: PPUSH
109731: CALL_OW 273
109735: PPUSH
109736: LD_VAR 0 3
109740: PPUSH
109741: CALL_OW 309
109745: IFFALSE 109759
// begin result := true ;
109747: LD_ADDR_VAR 0 4
109751: PUSH
109752: LD_INT 1
109754: ST_TO_ADDR
// exit ;
109755: POP
109756: POP
109757: GO 109763
// end ;
109759: GO 109693
109761: POP
109762: POP
// end ;
109763: LD_VAR 0 4
109767: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
109768: LD_INT 0
109770: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
109771: LD_VAR 0 1
109775: PPUSH
109776: LD_VAR 0 2
109780: PPUSH
109781: LD_INT 0
109783: PPUSH
109784: LD_INT 0
109786: PPUSH
109787: LD_INT 1
109789: PPUSH
109790: LD_INT 0
109792: PPUSH
109793: CALL_OW 587
// end ;
109797: LD_VAR 0 3
109801: RET
// export function CenterOnNow ( unit ) ; begin
109802: LD_INT 0
109804: PPUSH
// result := IsInUnit ( unit ) ;
109805: LD_ADDR_VAR 0 2
109809: PUSH
109810: LD_VAR 0 1
109814: PPUSH
109815: CALL_OW 310
109819: ST_TO_ADDR
// if not result then
109820: LD_VAR 0 2
109824: NOT
109825: IFFALSE 109837
// result := unit ;
109827: LD_ADDR_VAR 0 2
109831: PUSH
109832: LD_VAR 0 1
109836: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
109837: LD_VAR 0 1
109841: PPUSH
109842: CALL_OW 87
// end ;
109846: LD_VAR 0 2
109850: RET
// export function ComMoveHex ( unit , hex ) ; begin
109851: LD_INT 0
109853: PPUSH
// if not hex then
109854: LD_VAR 0 2
109858: NOT
109859: IFFALSE 109863
// exit ;
109861: GO 109916
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
109863: LD_VAR 0 2
109867: PUSH
109868: LD_INT 1
109870: ARRAY
109871: PPUSH
109872: LD_VAR 0 2
109876: PUSH
109877: LD_INT 2
109879: ARRAY
109880: PPUSH
109881: CALL_OW 428
109885: IFFALSE 109889
// exit ;
109887: GO 109916
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
109889: LD_VAR 0 1
109893: PPUSH
109894: LD_VAR 0 2
109898: PUSH
109899: LD_INT 1
109901: ARRAY
109902: PPUSH
109903: LD_VAR 0 2
109907: PUSH
109908: LD_INT 2
109910: ARRAY
109911: PPUSH
109912: CALL_OW 111
// end ; end_of_file end_of_file
109916: LD_VAR 0 3
109920: RET
// export globalGameSaveCounter ; every 0 0$1 do
109921: GO 109923
109923: DISABLE
// begin enable ;
109924: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
109925: LD_STRING updateTimer(
109927: PUSH
109928: LD_OWVAR 1
109932: STR
109933: PUSH
109934: LD_STRING );
109936: STR
109937: PPUSH
109938: CALL_OW 559
// end ;
109942: END
// every 0 0$1 do
109943: GO 109945
109945: DISABLE
// begin globalGameSaveCounter := 0 ;
109946: LD_ADDR_EXP 145
109950: PUSH
109951: LD_INT 0
109953: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
109954: LD_STRING setGameSaveCounter(0)
109956: PPUSH
109957: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
109961: LD_STRING initStreamRollete();
109963: PPUSH
109964: CALL_OW 559
// InitStreamMode ;
109968: CALL 111294 0 0
// DefineStreamItems ( false ) ;
109972: LD_INT 0
109974: PPUSH
109975: CALL 111758 0 1
// end ;
109979: END
// export function SOS_MapStart ( ) ; begin
109980: LD_INT 0
109982: PPUSH
// if streamModeActive then
109983: LD_EXP 146
109987: IFFALSE 109996
// DefineStreamItems ( true ) ;
109989: LD_INT 1
109991: PPUSH
109992: CALL 111758 0 1
// UpdateLuaVariables ( ) ;
109996: CALL 110013 0 0
// UpdateFactoryWaypoints ( ) ;
110000: CALL 124619 0 0
// UpdateWarehouseGatheringPoints ( ) ;
110004: CALL 124876 0 0
// end ;
110008: LD_VAR 0 1
110012: RET
// function UpdateLuaVariables ( ) ; begin
110013: LD_INT 0
110015: PPUSH
// if globalGameSaveCounter then
110016: LD_EXP 145
110020: IFFALSE 110054
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
110022: LD_ADDR_EXP 145
110026: PUSH
110027: LD_EXP 145
110031: PPUSH
110032: CALL 107210 0 1
110036: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110037: LD_STRING setGameSaveCounter(
110039: PUSH
110040: LD_EXP 145
110044: STR
110045: PUSH
110046: LD_STRING )
110048: STR
110049: PPUSH
110050: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
110054: LD_STRING setGameDifficulty(
110056: PUSH
110057: LD_OWVAR 67
110061: STR
110062: PUSH
110063: LD_STRING )
110065: STR
110066: PPUSH
110067: CALL_OW 559
// end ;
110071: LD_VAR 0 1
110075: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
110076: LD_INT 0
110078: PPUSH
// if p2 = stream_mode then
110079: LD_VAR 0 2
110083: PUSH
110084: LD_INT 100
110086: EQUAL
110087: IFFALSE 111090
// begin if not StreamModeActive then
110089: LD_EXP 146
110093: NOT
110094: IFFALSE 110104
// StreamModeActive := true ;
110096: LD_ADDR_EXP 146
110100: PUSH
110101: LD_INT 1
110103: ST_TO_ADDR
// if p3 = 0 then
110104: LD_VAR 0 3
110108: PUSH
110109: LD_INT 0
110111: EQUAL
110112: IFFALSE 110118
// InitStreamMode ;
110114: CALL 111294 0 0
// if p3 = 1 then
110118: LD_VAR 0 3
110122: PUSH
110123: LD_INT 1
110125: EQUAL
110126: IFFALSE 110136
// sRocket := true ;
110128: LD_ADDR_EXP 151
110132: PUSH
110133: LD_INT 1
110135: ST_TO_ADDR
// if p3 = 2 then
110136: LD_VAR 0 3
110140: PUSH
110141: LD_INT 2
110143: EQUAL
110144: IFFALSE 110154
// sSpeed := true ;
110146: LD_ADDR_EXP 150
110150: PUSH
110151: LD_INT 1
110153: ST_TO_ADDR
// if p3 = 3 then
110154: LD_VAR 0 3
110158: PUSH
110159: LD_INT 3
110161: EQUAL
110162: IFFALSE 110172
// sEngine := true ;
110164: LD_ADDR_EXP 152
110168: PUSH
110169: LD_INT 1
110171: ST_TO_ADDR
// if p3 = 4 then
110172: LD_VAR 0 3
110176: PUSH
110177: LD_INT 4
110179: EQUAL
110180: IFFALSE 110190
// sSpec := true ;
110182: LD_ADDR_EXP 149
110186: PUSH
110187: LD_INT 1
110189: ST_TO_ADDR
// if p3 = 5 then
110190: LD_VAR 0 3
110194: PUSH
110195: LD_INT 5
110197: EQUAL
110198: IFFALSE 110208
// sLevel := true ;
110200: LD_ADDR_EXP 153
110204: PUSH
110205: LD_INT 1
110207: ST_TO_ADDR
// if p3 = 6 then
110208: LD_VAR 0 3
110212: PUSH
110213: LD_INT 6
110215: EQUAL
110216: IFFALSE 110226
// sArmoury := true ;
110218: LD_ADDR_EXP 154
110222: PUSH
110223: LD_INT 1
110225: ST_TO_ADDR
// if p3 = 7 then
110226: LD_VAR 0 3
110230: PUSH
110231: LD_INT 7
110233: EQUAL
110234: IFFALSE 110244
// sRadar := true ;
110236: LD_ADDR_EXP 155
110240: PUSH
110241: LD_INT 1
110243: ST_TO_ADDR
// if p3 = 8 then
110244: LD_VAR 0 3
110248: PUSH
110249: LD_INT 8
110251: EQUAL
110252: IFFALSE 110262
// sBunker := true ;
110254: LD_ADDR_EXP 156
110258: PUSH
110259: LD_INT 1
110261: ST_TO_ADDR
// if p3 = 9 then
110262: LD_VAR 0 3
110266: PUSH
110267: LD_INT 9
110269: EQUAL
110270: IFFALSE 110280
// sHack := true ;
110272: LD_ADDR_EXP 157
110276: PUSH
110277: LD_INT 1
110279: ST_TO_ADDR
// if p3 = 10 then
110280: LD_VAR 0 3
110284: PUSH
110285: LD_INT 10
110287: EQUAL
110288: IFFALSE 110298
// sFire := true ;
110290: LD_ADDR_EXP 158
110294: PUSH
110295: LD_INT 1
110297: ST_TO_ADDR
// if p3 = 11 then
110298: LD_VAR 0 3
110302: PUSH
110303: LD_INT 11
110305: EQUAL
110306: IFFALSE 110316
// sRefresh := true ;
110308: LD_ADDR_EXP 159
110312: PUSH
110313: LD_INT 1
110315: ST_TO_ADDR
// if p3 = 12 then
110316: LD_VAR 0 3
110320: PUSH
110321: LD_INT 12
110323: EQUAL
110324: IFFALSE 110334
// sExp := true ;
110326: LD_ADDR_EXP 160
110330: PUSH
110331: LD_INT 1
110333: ST_TO_ADDR
// if p3 = 13 then
110334: LD_VAR 0 3
110338: PUSH
110339: LD_INT 13
110341: EQUAL
110342: IFFALSE 110352
// sDepot := true ;
110344: LD_ADDR_EXP 161
110348: PUSH
110349: LD_INT 1
110351: ST_TO_ADDR
// if p3 = 14 then
110352: LD_VAR 0 3
110356: PUSH
110357: LD_INT 14
110359: EQUAL
110360: IFFALSE 110370
// sFlag := true ;
110362: LD_ADDR_EXP 162
110366: PUSH
110367: LD_INT 1
110369: ST_TO_ADDR
// if p3 = 15 then
110370: LD_VAR 0 3
110374: PUSH
110375: LD_INT 15
110377: EQUAL
110378: IFFALSE 110388
// sKamikadze := true ;
110380: LD_ADDR_EXP 170
110384: PUSH
110385: LD_INT 1
110387: ST_TO_ADDR
// if p3 = 16 then
110388: LD_VAR 0 3
110392: PUSH
110393: LD_INT 16
110395: EQUAL
110396: IFFALSE 110406
// sTroll := true ;
110398: LD_ADDR_EXP 171
110402: PUSH
110403: LD_INT 1
110405: ST_TO_ADDR
// if p3 = 17 then
110406: LD_VAR 0 3
110410: PUSH
110411: LD_INT 17
110413: EQUAL
110414: IFFALSE 110424
// sSlow := true ;
110416: LD_ADDR_EXP 172
110420: PUSH
110421: LD_INT 1
110423: ST_TO_ADDR
// if p3 = 18 then
110424: LD_VAR 0 3
110428: PUSH
110429: LD_INT 18
110431: EQUAL
110432: IFFALSE 110442
// sLack := true ;
110434: LD_ADDR_EXP 173
110438: PUSH
110439: LD_INT 1
110441: ST_TO_ADDR
// if p3 = 19 then
110442: LD_VAR 0 3
110446: PUSH
110447: LD_INT 19
110449: EQUAL
110450: IFFALSE 110460
// sTank := true ;
110452: LD_ADDR_EXP 175
110456: PUSH
110457: LD_INT 1
110459: ST_TO_ADDR
// if p3 = 20 then
110460: LD_VAR 0 3
110464: PUSH
110465: LD_INT 20
110467: EQUAL
110468: IFFALSE 110478
// sRemote := true ;
110470: LD_ADDR_EXP 176
110474: PUSH
110475: LD_INT 1
110477: ST_TO_ADDR
// if p3 = 21 then
110478: LD_VAR 0 3
110482: PUSH
110483: LD_INT 21
110485: EQUAL
110486: IFFALSE 110496
// sPowell := true ;
110488: LD_ADDR_EXP 177
110492: PUSH
110493: LD_INT 1
110495: ST_TO_ADDR
// if p3 = 22 then
110496: LD_VAR 0 3
110500: PUSH
110501: LD_INT 22
110503: EQUAL
110504: IFFALSE 110514
// sTeleport := true ;
110506: LD_ADDR_EXP 180
110510: PUSH
110511: LD_INT 1
110513: ST_TO_ADDR
// if p3 = 23 then
110514: LD_VAR 0 3
110518: PUSH
110519: LD_INT 23
110521: EQUAL
110522: IFFALSE 110532
// sOilTower := true ;
110524: LD_ADDR_EXP 182
110528: PUSH
110529: LD_INT 1
110531: ST_TO_ADDR
// if p3 = 24 then
110532: LD_VAR 0 3
110536: PUSH
110537: LD_INT 24
110539: EQUAL
110540: IFFALSE 110550
// sShovel := true ;
110542: LD_ADDR_EXP 183
110546: PUSH
110547: LD_INT 1
110549: ST_TO_ADDR
// if p3 = 25 then
110550: LD_VAR 0 3
110554: PUSH
110555: LD_INT 25
110557: EQUAL
110558: IFFALSE 110568
// sSheik := true ;
110560: LD_ADDR_EXP 184
110564: PUSH
110565: LD_INT 1
110567: ST_TO_ADDR
// if p3 = 26 then
110568: LD_VAR 0 3
110572: PUSH
110573: LD_INT 26
110575: EQUAL
110576: IFFALSE 110586
// sEarthquake := true ;
110578: LD_ADDR_EXP 186
110582: PUSH
110583: LD_INT 1
110585: ST_TO_ADDR
// if p3 = 27 then
110586: LD_VAR 0 3
110590: PUSH
110591: LD_INT 27
110593: EQUAL
110594: IFFALSE 110604
// sAI := true ;
110596: LD_ADDR_EXP 187
110600: PUSH
110601: LD_INT 1
110603: ST_TO_ADDR
// if p3 = 28 then
110604: LD_VAR 0 3
110608: PUSH
110609: LD_INT 28
110611: EQUAL
110612: IFFALSE 110622
// sCargo := true ;
110614: LD_ADDR_EXP 190
110618: PUSH
110619: LD_INT 1
110621: ST_TO_ADDR
// if p3 = 29 then
110622: LD_VAR 0 3
110626: PUSH
110627: LD_INT 29
110629: EQUAL
110630: IFFALSE 110640
// sDLaser := true ;
110632: LD_ADDR_EXP 191
110636: PUSH
110637: LD_INT 1
110639: ST_TO_ADDR
// if p3 = 30 then
110640: LD_VAR 0 3
110644: PUSH
110645: LD_INT 30
110647: EQUAL
110648: IFFALSE 110658
// sExchange := true ;
110650: LD_ADDR_EXP 192
110654: PUSH
110655: LD_INT 1
110657: ST_TO_ADDR
// if p3 = 31 then
110658: LD_VAR 0 3
110662: PUSH
110663: LD_INT 31
110665: EQUAL
110666: IFFALSE 110676
// sFac := true ;
110668: LD_ADDR_EXP 193
110672: PUSH
110673: LD_INT 1
110675: ST_TO_ADDR
// if p3 = 32 then
110676: LD_VAR 0 3
110680: PUSH
110681: LD_INT 32
110683: EQUAL
110684: IFFALSE 110694
// sPower := true ;
110686: LD_ADDR_EXP 194
110690: PUSH
110691: LD_INT 1
110693: ST_TO_ADDR
// if p3 = 33 then
110694: LD_VAR 0 3
110698: PUSH
110699: LD_INT 33
110701: EQUAL
110702: IFFALSE 110712
// sRandom := true ;
110704: LD_ADDR_EXP 195
110708: PUSH
110709: LD_INT 1
110711: ST_TO_ADDR
// if p3 = 34 then
110712: LD_VAR 0 3
110716: PUSH
110717: LD_INT 34
110719: EQUAL
110720: IFFALSE 110730
// sShield := true ;
110722: LD_ADDR_EXP 196
110726: PUSH
110727: LD_INT 1
110729: ST_TO_ADDR
// if p3 = 35 then
110730: LD_VAR 0 3
110734: PUSH
110735: LD_INT 35
110737: EQUAL
110738: IFFALSE 110748
// sTime := true ;
110740: LD_ADDR_EXP 197
110744: PUSH
110745: LD_INT 1
110747: ST_TO_ADDR
// if p3 = 36 then
110748: LD_VAR 0 3
110752: PUSH
110753: LD_INT 36
110755: EQUAL
110756: IFFALSE 110766
// sTools := true ;
110758: LD_ADDR_EXP 198
110762: PUSH
110763: LD_INT 1
110765: ST_TO_ADDR
// if p3 = 101 then
110766: LD_VAR 0 3
110770: PUSH
110771: LD_INT 101
110773: EQUAL
110774: IFFALSE 110784
// sSold := true ;
110776: LD_ADDR_EXP 163
110780: PUSH
110781: LD_INT 1
110783: ST_TO_ADDR
// if p3 = 102 then
110784: LD_VAR 0 3
110788: PUSH
110789: LD_INT 102
110791: EQUAL
110792: IFFALSE 110802
// sDiff := true ;
110794: LD_ADDR_EXP 164
110798: PUSH
110799: LD_INT 1
110801: ST_TO_ADDR
// if p3 = 103 then
110802: LD_VAR 0 3
110806: PUSH
110807: LD_INT 103
110809: EQUAL
110810: IFFALSE 110820
// sFog := true ;
110812: LD_ADDR_EXP 167
110816: PUSH
110817: LD_INT 1
110819: ST_TO_ADDR
// if p3 = 104 then
110820: LD_VAR 0 3
110824: PUSH
110825: LD_INT 104
110827: EQUAL
110828: IFFALSE 110838
// sReset := true ;
110830: LD_ADDR_EXP 168
110834: PUSH
110835: LD_INT 1
110837: ST_TO_ADDR
// if p3 = 105 then
110838: LD_VAR 0 3
110842: PUSH
110843: LD_INT 105
110845: EQUAL
110846: IFFALSE 110856
// sSun := true ;
110848: LD_ADDR_EXP 169
110852: PUSH
110853: LD_INT 1
110855: ST_TO_ADDR
// if p3 = 106 then
110856: LD_VAR 0 3
110860: PUSH
110861: LD_INT 106
110863: EQUAL
110864: IFFALSE 110874
// sTiger := true ;
110866: LD_ADDR_EXP 165
110870: PUSH
110871: LD_INT 1
110873: ST_TO_ADDR
// if p3 = 107 then
110874: LD_VAR 0 3
110878: PUSH
110879: LD_INT 107
110881: EQUAL
110882: IFFALSE 110892
// sBomb := true ;
110884: LD_ADDR_EXP 166
110888: PUSH
110889: LD_INT 1
110891: ST_TO_ADDR
// if p3 = 108 then
110892: LD_VAR 0 3
110896: PUSH
110897: LD_INT 108
110899: EQUAL
110900: IFFALSE 110910
// sWound := true ;
110902: LD_ADDR_EXP 174
110906: PUSH
110907: LD_INT 1
110909: ST_TO_ADDR
// if p3 = 109 then
110910: LD_VAR 0 3
110914: PUSH
110915: LD_INT 109
110917: EQUAL
110918: IFFALSE 110928
// sBetray := true ;
110920: LD_ADDR_EXP 178
110924: PUSH
110925: LD_INT 1
110927: ST_TO_ADDR
// if p3 = 110 then
110928: LD_VAR 0 3
110932: PUSH
110933: LD_INT 110
110935: EQUAL
110936: IFFALSE 110946
// sContamin := true ;
110938: LD_ADDR_EXP 179
110942: PUSH
110943: LD_INT 1
110945: ST_TO_ADDR
// if p3 = 111 then
110946: LD_VAR 0 3
110950: PUSH
110951: LD_INT 111
110953: EQUAL
110954: IFFALSE 110964
// sOil := true ;
110956: LD_ADDR_EXP 181
110960: PUSH
110961: LD_INT 1
110963: ST_TO_ADDR
// if p3 = 112 then
110964: LD_VAR 0 3
110968: PUSH
110969: LD_INT 112
110971: EQUAL
110972: IFFALSE 110982
// sStu := true ;
110974: LD_ADDR_EXP 185
110978: PUSH
110979: LD_INT 1
110981: ST_TO_ADDR
// if p3 = 113 then
110982: LD_VAR 0 3
110986: PUSH
110987: LD_INT 113
110989: EQUAL
110990: IFFALSE 111000
// sBazooka := true ;
110992: LD_ADDR_EXP 188
110996: PUSH
110997: LD_INT 1
110999: ST_TO_ADDR
// if p3 = 114 then
111000: LD_VAR 0 3
111004: PUSH
111005: LD_INT 114
111007: EQUAL
111008: IFFALSE 111018
// sMortar := true ;
111010: LD_ADDR_EXP 189
111014: PUSH
111015: LD_INT 1
111017: ST_TO_ADDR
// if p3 = 115 then
111018: LD_VAR 0 3
111022: PUSH
111023: LD_INT 115
111025: EQUAL
111026: IFFALSE 111036
// sRanger := true ;
111028: LD_ADDR_EXP 199
111032: PUSH
111033: LD_INT 1
111035: ST_TO_ADDR
// if p3 = 116 then
111036: LD_VAR 0 3
111040: PUSH
111041: LD_INT 116
111043: EQUAL
111044: IFFALSE 111054
// sComputer := true ;
111046: LD_ADDR_EXP 200
111050: PUSH
111051: LD_INT 1
111053: ST_TO_ADDR
// if p3 = 117 then
111054: LD_VAR 0 3
111058: PUSH
111059: LD_INT 117
111061: EQUAL
111062: IFFALSE 111072
// s30 := true ;
111064: LD_ADDR_EXP 201
111068: PUSH
111069: LD_INT 1
111071: ST_TO_ADDR
// if p3 = 118 then
111072: LD_VAR 0 3
111076: PUSH
111077: LD_INT 118
111079: EQUAL
111080: IFFALSE 111090
// s60 := true ;
111082: LD_ADDR_EXP 202
111086: PUSH
111087: LD_INT 1
111089: ST_TO_ADDR
// end ; if p2 = hack_mode then
111090: LD_VAR 0 2
111094: PUSH
111095: LD_INT 101
111097: EQUAL
111098: IFFALSE 111226
// begin case p3 of 1 :
111100: LD_VAR 0 3
111104: PUSH
111105: LD_INT 1
111107: DOUBLE
111108: EQUAL
111109: IFTRUE 111113
111111: GO 111120
111113: POP
// hHackUnlimitedResources ; 2 :
111114: CALL 123365 0 0
111118: GO 111226
111120: LD_INT 2
111122: DOUBLE
111123: EQUAL
111124: IFTRUE 111128
111126: GO 111135
111128: POP
// hHackSetLevel10 ; 3 :
111129: CALL 123498 0 0
111133: GO 111226
111135: LD_INT 3
111137: DOUBLE
111138: EQUAL
111139: IFTRUE 111143
111141: GO 111150
111143: POP
// hHackSetLevel10YourUnits ; 4 :
111144: CALL 123583 0 0
111148: GO 111226
111150: LD_INT 4
111152: DOUBLE
111153: EQUAL
111154: IFTRUE 111158
111156: GO 111165
111158: POP
// hHackInvincible ; 5 :
111159: CALL 124031 0 0
111163: GO 111226
111165: LD_INT 5
111167: DOUBLE
111168: EQUAL
111169: IFTRUE 111173
111171: GO 111180
111173: POP
// hHackInvisible ; 6 :
111174: CALL 124142 0 0
111178: GO 111226
111180: LD_INT 6
111182: DOUBLE
111183: EQUAL
111184: IFTRUE 111188
111186: GO 111195
111188: POP
// hHackChangeYourSide ; 7 :
111189: CALL 124199 0 0
111193: GO 111226
111195: LD_INT 7
111197: DOUBLE
111198: EQUAL
111199: IFTRUE 111203
111201: GO 111210
111203: POP
// hHackChangeUnitSide ; 8 :
111204: CALL 124241 0 0
111208: GO 111226
111210: LD_INT 8
111212: DOUBLE
111213: EQUAL
111214: IFTRUE 111218
111216: GO 111225
111218: POP
// hHackFog ; end ;
111219: CALL 124342 0 0
111223: GO 111226
111225: POP
// end ; if p2 = game_save_mode then
111226: LD_VAR 0 2
111230: PUSH
111231: LD_INT 102
111233: EQUAL
111234: IFFALSE 111289
// begin if p3 = 1 then
111236: LD_VAR 0 3
111240: PUSH
111241: LD_INT 1
111243: EQUAL
111244: IFFALSE 111256
// globalGameSaveCounter := p4 ;
111246: LD_ADDR_EXP 145
111250: PUSH
111251: LD_VAR 0 4
111255: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
111256: LD_VAR 0 3
111260: PUSH
111261: LD_INT 2
111263: EQUAL
111264: PUSH
111265: LD_EXP 145
111269: AND
111270: IFFALSE 111289
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
111272: LD_STRING setGameSaveCounter(
111274: PUSH
111275: LD_EXP 145
111279: STR
111280: PUSH
111281: LD_STRING )
111283: STR
111284: PPUSH
111285: CALL_OW 559
// end ; end ;
111289: LD_VAR 0 7
111293: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
111294: LD_INT 0
111296: PPUSH
// streamModeActive := false ;
111297: LD_ADDR_EXP 146
111301: PUSH
111302: LD_INT 0
111304: ST_TO_ADDR
// normalCounter := 36 ;
111305: LD_ADDR_EXP 147
111309: PUSH
111310: LD_INT 36
111312: ST_TO_ADDR
// hardcoreCounter := 18 ;
111313: LD_ADDR_EXP 148
111317: PUSH
111318: LD_INT 18
111320: ST_TO_ADDR
// sRocket := false ;
111321: LD_ADDR_EXP 151
111325: PUSH
111326: LD_INT 0
111328: ST_TO_ADDR
// sSpeed := false ;
111329: LD_ADDR_EXP 150
111333: PUSH
111334: LD_INT 0
111336: ST_TO_ADDR
// sEngine := false ;
111337: LD_ADDR_EXP 152
111341: PUSH
111342: LD_INT 0
111344: ST_TO_ADDR
// sSpec := false ;
111345: LD_ADDR_EXP 149
111349: PUSH
111350: LD_INT 0
111352: ST_TO_ADDR
// sLevel := false ;
111353: LD_ADDR_EXP 153
111357: PUSH
111358: LD_INT 0
111360: ST_TO_ADDR
// sArmoury := false ;
111361: LD_ADDR_EXP 154
111365: PUSH
111366: LD_INT 0
111368: ST_TO_ADDR
// sRadar := false ;
111369: LD_ADDR_EXP 155
111373: PUSH
111374: LD_INT 0
111376: ST_TO_ADDR
// sBunker := false ;
111377: LD_ADDR_EXP 156
111381: PUSH
111382: LD_INT 0
111384: ST_TO_ADDR
// sHack := false ;
111385: LD_ADDR_EXP 157
111389: PUSH
111390: LD_INT 0
111392: ST_TO_ADDR
// sFire := false ;
111393: LD_ADDR_EXP 158
111397: PUSH
111398: LD_INT 0
111400: ST_TO_ADDR
// sRefresh := false ;
111401: LD_ADDR_EXP 159
111405: PUSH
111406: LD_INT 0
111408: ST_TO_ADDR
// sExp := false ;
111409: LD_ADDR_EXP 160
111413: PUSH
111414: LD_INT 0
111416: ST_TO_ADDR
// sDepot := false ;
111417: LD_ADDR_EXP 161
111421: PUSH
111422: LD_INT 0
111424: ST_TO_ADDR
// sFlag := false ;
111425: LD_ADDR_EXP 162
111429: PUSH
111430: LD_INT 0
111432: ST_TO_ADDR
// sKamikadze := false ;
111433: LD_ADDR_EXP 170
111437: PUSH
111438: LD_INT 0
111440: ST_TO_ADDR
// sTroll := false ;
111441: LD_ADDR_EXP 171
111445: PUSH
111446: LD_INT 0
111448: ST_TO_ADDR
// sSlow := false ;
111449: LD_ADDR_EXP 172
111453: PUSH
111454: LD_INT 0
111456: ST_TO_ADDR
// sLack := false ;
111457: LD_ADDR_EXP 173
111461: PUSH
111462: LD_INT 0
111464: ST_TO_ADDR
// sTank := false ;
111465: LD_ADDR_EXP 175
111469: PUSH
111470: LD_INT 0
111472: ST_TO_ADDR
// sRemote := false ;
111473: LD_ADDR_EXP 176
111477: PUSH
111478: LD_INT 0
111480: ST_TO_ADDR
// sPowell := false ;
111481: LD_ADDR_EXP 177
111485: PUSH
111486: LD_INT 0
111488: ST_TO_ADDR
// sTeleport := false ;
111489: LD_ADDR_EXP 180
111493: PUSH
111494: LD_INT 0
111496: ST_TO_ADDR
// sOilTower := false ;
111497: LD_ADDR_EXP 182
111501: PUSH
111502: LD_INT 0
111504: ST_TO_ADDR
// sShovel := false ;
111505: LD_ADDR_EXP 183
111509: PUSH
111510: LD_INT 0
111512: ST_TO_ADDR
// sSheik := false ;
111513: LD_ADDR_EXP 184
111517: PUSH
111518: LD_INT 0
111520: ST_TO_ADDR
// sEarthquake := false ;
111521: LD_ADDR_EXP 186
111525: PUSH
111526: LD_INT 0
111528: ST_TO_ADDR
// sAI := false ;
111529: LD_ADDR_EXP 187
111533: PUSH
111534: LD_INT 0
111536: ST_TO_ADDR
// sCargo := false ;
111537: LD_ADDR_EXP 190
111541: PUSH
111542: LD_INT 0
111544: ST_TO_ADDR
// sDLaser := false ;
111545: LD_ADDR_EXP 191
111549: PUSH
111550: LD_INT 0
111552: ST_TO_ADDR
// sExchange := false ;
111553: LD_ADDR_EXP 192
111557: PUSH
111558: LD_INT 0
111560: ST_TO_ADDR
// sFac := false ;
111561: LD_ADDR_EXP 193
111565: PUSH
111566: LD_INT 0
111568: ST_TO_ADDR
// sPower := false ;
111569: LD_ADDR_EXP 194
111573: PUSH
111574: LD_INT 0
111576: ST_TO_ADDR
// sRandom := false ;
111577: LD_ADDR_EXP 195
111581: PUSH
111582: LD_INT 0
111584: ST_TO_ADDR
// sShield := false ;
111585: LD_ADDR_EXP 196
111589: PUSH
111590: LD_INT 0
111592: ST_TO_ADDR
// sTime := false ;
111593: LD_ADDR_EXP 197
111597: PUSH
111598: LD_INT 0
111600: ST_TO_ADDR
// sTools := false ;
111601: LD_ADDR_EXP 198
111605: PUSH
111606: LD_INT 0
111608: ST_TO_ADDR
// sSold := false ;
111609: LD_ADDR_EXP 163
111613: PUSH
111614: LD_INT 0
111616: ST_TO_ADDR
// sDiff := false ;
111617: LD_ADDR_EXP 164
111621: PUSH
111622: LD_INT 0
111624: ST_TO_ADDR
// sFog := false ;
111625: LD_ADDR_EXP 167
111629: PUSH
111630: LD_INT 0
111632: ST_TO_ADDR
// sReset := false ;
111633: LD_ADDR_EXP 168
111637: PUSH
111638: LD_INT 0
111640: ST_TO_ADDR
// sSun := false ;
111641: LD_ADDR_EXP 169
111645: PUSH
111646: LD_INT 0
111648: ST_TO_ADDR
// sTiger := false ;
111649: LD_ADDR_EXP 165
111653: PUSH
111654: LD_INT 0
111656: ST_TO_ADDR
// sBomb := false ;
111657: LD_ADDR_EXP 166
111661: PUSH
111662: LD_INT 0
111664: ST_TO_ADDR
// sWound := false ;
111665: LD_ADDR_EXP 174
111669: PUSH
111670: LD_INT 0
111672: ST_TO_ADDR
// sBetray := false ;
111673: LD_ADDR_EXP 178
111677: PUSH
111678: LD_INT 0
111680: ST_TO_ADDR
// sContamin := false ;
111681: LD_ADDR_EXP 179
111685: PUSH
111686: LD_INT 0
111688: ST_TO_ADDR
// sOil := false ;
111689: LD_ADDR_EXP 181
111693: PUSH
111694: LD_INT 0
111696: ST_TO_ADDR
// sStu := false ;
111697: LD_ADDR_EXP 185
111701: PUSH
111702: LD_INT 0
111704: ST_TO_ADDR
// sBazooka := false ;
111705: LD_ADDR_EXP 188
111709: PUSH
111710: LD_INT 0
111712: ST_TO_ADDR
// sMortar := false ;
111713: LD_ADDR_EXP 189
111717: PUSH
111718: LD_INT 0
111720: ST_TO_ADDR
// sRanger := false ;
111721: LD_ADDR_EXP 199
111725: PUSH
111726: LD_INT 0
111728: ST_TO_ADDR
// sComputer := false ;
111729: LD_ADDR_EXP 200
111733: PUSH
111734: LD_INT 0
111736: ST_TO_ADDR
// s30 := false ;
111737: LD_ADDR_EXP 201
111741: PUSH
111742: LD_INT 0
111744: ST_TO_ADDR
// s60 := false ;
111745: LD_ADDR_EXP 202
111749: PUSH
111750: LD_INT 0
111752: ST_TO_ADDR
// end ;
111753: LD_VAR 0 1
111757: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
111758: LD_INT 0
111760: PPUSH
111761: PPUSH
111762: PPUSH
111763: PPUSH
111764: PPUSH
111765: PPUSH
111766: PPUSH
// result := [ ] ;
111767: LD_ADDR_VAR 0 2
111771: PUSH
111772: EMPTY
111773: ST_TO_ADDR
// if campaign_id = 1 then
111774: LD_OWVAR 69
111778: PUSH
111779: LD_INT 1
111781: EQUAL
111782: IFFALSE 114948
// begin case mission_number of 1 :
111784: LD_OWVAR 70
111788: PUSH
111789: LD_INT 1
111791: DOUBLE
111792: EQUAL
111793: IFTRUE 111797
111795: GO 111873
111797: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
111798: LD_ADDR_VAR 0 2
111802: PUSH
111803: LD_INT 2
111805: PUSH
111806: LD_INT 4
111808: PUSH
111809: LD_INT 11
111811: PUSH
111812: LD_INT 12
111814: PUSH
111815: LD_INT 15
111817: PUSH
111818: LD_INT 16
111820: PUSH
111821: LD_INT 22
111823: PUSH
111824: LD_INT 23
111826: PUSH
111827: LD_INT 26
111829: PUSH
111830: EMPTY
111831: LIST
111832: LIST
111833: LIST
111834: LIST
111835: LIST
111836: LIST
111837: LIST
111838: LIST
111839: LIST
111840: PUSH
111841: LD_INT 101
111843: PUSH
111844: LD_INT 102
111846: PUSH
111847: LD_INT 106
111849: PUSH
111850: LD_INT 116
111852: PUSH
111853: LD_INT 117
111855: PUSH
111856: LD_INT 118
111858: PUSH
111859: EMPTY
111860: LIST
111861: LIST
111862: LIST
111863: LIST
111864: LIST
111865: LIST
111866: PUSH
111867: EMPTY
111868: LIST
111869: LIST
111870: ST_TO_ADDR
111871: GO 114946
111873: LD_INT 2
111875: DOUBLE
111876: EQUAL
111877: IFTRUE 111881
111879: GO 111965
111881: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
111882: LD_ADDR_VAR 0 2
111886: PUSH
111887: LD_INT 2
111889: PUSH
111890: LD_INT 4
111892: PUSH
111893: LD_INT 11
111895: PUSH
111896: LD_INT 12
111898: PUSH
111899: LD_INT 15
111901: PUSH
111902: LD_INT 16
111904: PUSH
111905: LD_INT 22
111907: PUSH
111908: LD_INT 23
111910: PUSH
111911: LD_INT 26
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: LIST
111918: LIST
111919: LIST
111920: LIST
111921: LIST
111922: LIST
111923: LIST
111924: PUSH
111925: LD_INT 101
111927: PUSH
111928: LD_INT 102
111930: PUSH
111931: LD_INT 105
111933: PUSH
111934: LD_INT 106
111936: PUSH
111937: LD_INT 108
111939: PUSH
111940: LD_INT 116
111942: PUSH
111943: LD_INT 117
111945: PUSH
111946: LD_INT 118
111948: PUSH
111949: EMPTY
111950: LIST
111951: LIST
111952: LIST
111953: LIST
111954: LIST
111955: LIST
111956: LIST
111957: LIST
111958: PUSH
111959: EMPTY
111960: LIST
111961: LIST
111962: ST_TO_ADDR
111963: GO 114946
111965: LD_INT 3
111967: DOUBLE
111968: EQUAL
111969: IFTRUE 111973
111971: GO 112061
111973: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
111974: LD_ADDR_VAR 0 2
111978: PUSH
111979: LD_INT 2
111981: PUSH
111982: LD_INT 4
111984: PUSH
111985: LD_INT 5
111987: PUSH
111988: LD_INT 11
111990: PUSH
111991: LD_INT 12
111993: PUSH
111994: LD_INT 15
111996: PUSH
111997: LD_INT 16
111999: PUSH
112000: LD_INT 22
112002: PUSH
112003: LD_INT 26
112005: PUSH
112006: LD_INT 36
112008: PUSH
112009: EMPTY
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: LIST
112020: PUSH
112021: LD_INT 101
112023: PUSH
112024: LD_INT 102
112026: PUSH
112027: LD_INT 105
112029: PUSH
112030: LD_INT 106
112032: PUSH
112033: LD_INT 108
112035: PUSH
112036: LD_INT 116
112038: PUSH
112039: LD_INT 117
112041: PUSH
112042: LD_INT 118
112044: PUSH
112045: EMPTY
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: LIST
112051: LIST
112052: LIST
112053: LIST
112054: PUSH
112055: EMPTY
112056: LIST
112057: LIST
112058: ST_TO_ADDR
112059: GO 114946
112061: LD_INT 4
112063: DOUBLE
112064: EQUAL
112065: IFTRUE 112069
112067: GO 112165
112069: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
112070: LD_ADDR_VAR 0 2
112074: PUSH
112075: LD_INT 2
112077: PUSH
112078: LD_INT 4
112080: PUSH
112081: LD_INT 5
112083: PUSH
112084: LD_INT 8
112086: PUSH
112087: LD_INT 11
112089: PUSH
112090: LD_INT 12
112092: PUSH
112093: LD_INT 15
112095: PUSH
112096: LD_INT 16
112098: PUSH
112099: LD_INT 22
112101: PUSH
112102: LD_INT 23
112104: PUSH
112105: LD_INT 26
112107: PUSH
112108: LD_INT 36
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: LIST
112117: LIST
112118: LIST
112119: LIST
112120: LIST
112121: LIST
112122: LIST
112123: LIST
112124: PUSH
112125: LD_INT 101
112127: PUSH
112128: LD_INT 102
112130: PUSH
112131: LD_INT 105
112133: PUSH
112134: LD_INT 106
112136: PUSH
112137: LD_INT 108
112139: PUSH
112140: LD_INT 116
112142: PUSH
112143: LD_INT 117
112145: PUSH
112146: LD_INT 118
112148: PUSH
112149: EMPTY
112150: LIST
112151: LIST
112152: LIST
112153: LIST
112154: LIST
112155: LIST
112156: LIST
112157: LIST
112158: PUSH
112159: EMPTY
112160: LIST
112161: LIST
112162: ST_TO_ADDR
112163: GO 114946
112165: LD_INT 5
112167: DOUBLE
112168: EQUAL
112169: IFTRUE 112173
112171: GO 112285
112173: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
112174: LD_ADDR_VAR 0 2
112178: PUSH
112179: LD_INT 2
112181: PUSH
112182: LD_INT 4
112184: PUSH
112185: LD_INT 5
112187: PUSH
112188: LD_INT 6
112190: PUSH
112191: LD_INT 8
112193: PUSH
112194: LD_INT 11
112196: PUSH
112197: LD_INT 12
112199: PUSH
112200: LD_INT 15
112202: PUSH
112203: LD_INT 16
112205: PUSH
112206: LD_INT 22
112208: PUSH
112209: LD_INT 23
112211: PUSH
112212: LD_INT 25
112214: PUSH
112215: LD_INT 26
112217: PUSH
112218: LD_INT 36
112220: PUSH
112221: EMPTY
112222: LIST
112223: LIST
112224: LIST
112225: LIST
112226: LIST
112227: LIST
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: PUSH
112237: LD_INT 101
112239: PUSH
112240: LD_INT 102
112242: PUSH
112243: LD_INT 105
112245: PUSH
112246: LD_INT 106
112248: PUSH
112249: LD_INT 108
112251: PUSH
112252: LD_INT 109
112254: PUSH
112255: LD_INT 112
112257: PUSH
112258: LD_INT 116
112260: PUSH
112261: LD_INT 117
112263: PUSH
112264: LD_INT 118
112266: PUSH
112267: EMPTY
112268: LIST
112269: LIST
112270: LIST
112271: LIST
112272: LIST
112273: LIST
112274: LIST
112275: LIST
112276: LIST
112277: LIST
112278: PUSH
112279: EMPTY
112280: LIST
112281: LIST
112282: ST_TO_ADDR
112283: GO 114946
112285: LD_INT 6
112287: DOUBLE
112288: EQUAL
112289: IFTRUE 112293
112291: GO 112425
112293: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
112294: LD_ADDR_VAR 0 2
112298: PUSH
112299: LD_INT 2
112301: PUSH
112302: LD_INT 4
112304: PUSH
112305: LD_INT 5
112307: PUSH
112308: LD_INT 6
112310: PUSH
112311: LD_INT 8
112313: PUSH
112314: LD_INT 11
112316: PUSH
112317: LD_INT 12
112319: PUSH
112320: LD_INT 15
112322: PUSH
112323: LD_INT 16
112325: PUSH
112326: LD_INT 20
112328: PUSH
112329: LD_INT 21
112331: PUSH
112332: LD_INT 22
112334: PUSH
112335: LD_INT 23
112337: PUSH
112338: LD_INT 25
112340: PUSH
112341: LD_INT 26
112343: PUSH
112344: LD_INT 30
112346: PUSH
112347: LD_INT 31
112349: PUSH
112350: LD_INT 32
112352: PUSH
112353: LD_INT 36
112355: PUSH
112356: EMPTY
112357: LIST
112358: LIST
112359: LIST
112360: LIST
112361: LIST
112362: LIST
112363: LIST
112364: LIST
112365: LIST
112366: LIST
112367: LIST
112368: LIST
112369: LIST
112370: LIST
112371: LIST
112372: LIST
112373: LIST
112374: LIST
112375: LIST
112376: PUSH
112377: LD_INT 101
112379: PUSH
112380: LD_INT 102
112382: PUSH
112383: LD_INT 105
112385: PUSH
112386: LD_INT 106
112388: PUSH
112389: LD_INT 108
112391: PUSH
112392: LD_INT 109
112394: PUSH
112395: LD_INT 112
112397: PUSH
112398: LD_INT 116
112400: PUSH
112401: LD_INT 117
112403: PUSH
112404: LD_INT 118
112406: PUSH
112407: EMPTY
112408: LIST
112409: LIST
112410: LIST
112411: LIST
112412: LIST
112413: LIST
112414: LIST
112415: LIST
112416: LIST
112417: LIST
112418: PUSH
112419: EMPTY
112420: LIST
112421: LIST
112422: ST_TO_ADDR
112423: GO 114946
112425: LD_INT 7
112427: DOUBLE
112428: EQUAL
112429: IFTRUE 112433
112431: GO 112545
112433: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
112434: LD_ADDR_VAR 0 2
112438: PUSH
112439: LD_INT 2
112441: PUSH
112442: LD_INT 4
112444: PUSH
112445: LD_INT 5
112447: PUSH
112448: LD_INT 7
112450: PUSH
112451: LD_INT 11
112453: PUSH
112454: LD_INT 12
112456: PUSH
112457: LD_INT 15
112459: PUSH
112460: LD_INT 16
112462: PUSH
112463: LD_INT 20
112465: PUSH
112466: LD_INT 21
112468: PUSH
112469: LD_INT 22
112471: PUSH
112472: LD_INT 23
112474: PUSH
112475: LD_INT 25
112477: PUSH
112478: LD_INT 26
112480: PUSH
112481: EMPTY
112482: LIST
112483: LIST
112484: LIST
112485: LIST
112486: LIST
112487: LIST
112488: LIST
112489: LIST
112490: LIST
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: PUSH
112497: LD_INT 101
112499: PUSH
112500: LD_INT 102
112502: PUSH
112503: LD_INT 103
112505: PUSH
112506: LD_INT 105
112508: PUSH
112509: LD_INT 106
112511: PUSH
112512: LD_INT 108
112514: PUSH
112515: LD_INT 112
112517: PUSH
112518: LD_INT 116
112520: PUSH
112521: LD_INT 117
112523: PUSH
112524: LD_INT 118
112526: PUSH
112527: EMPTY
112528: LIST
112529: LIST
112530: LIST
112531: LIST
112532: LIST
112533: LIST
112534: LIST
112535: LIST
112536: LIST
112537: LIST
112538: PUSH
112539: EMPTY
112540: LIST
112541: LIST
112542: ST_TO_ADDR
112543: GO 114946
112545: LD_INT 8
112547: DOUBLE
112548: EQUAL
112549: IFTRUE 112553
112551: GO 112693
112553: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
112554: LD_ADDR_VAR 0 2
112558: PUSH
112559: LD_INT 2
112561: PUSH
112562: LD_INT 4
112564: PUSH
112565: LD_INT 5
112567: PUSH
112568: LD_INT 6
112570: PUSH
112571: LD_INT 7
112573: PUSH
112574: LD_INT 8
112576: PUSH
112577: LD_INT 11
112579: PUSH
112580: LD_INT 12
112582: PUSH
112583: LD_INT 15
112585: PUSH
112586: LD_INT 16
112588: PUSH
112589: LD_INT 20
112591: PUSH
112592: LD_INT 21
112594: PUSH
112595: LD_INT 22
112597: PUSH
112598: LD_INT 23
112600: PUSH
112601: LD_INT 25
112603: PUSH
112604: LD_INT 26
112606: PUSH
112607: LD_INT 30
112609: PUSH
112610: LD_INT 31
112612: PUSH
112613: LD_INT 32
112615: PUSH
112616: LD_INT 36
112618: PUSH
112619: EMPTY
112620: LIST
112621: LIST
112622: LIST
112623: LIST
112624: LIST
112625: LIST
112626: LIST
112627: LIST
112628: LIST
112629: LIST
112630: LIST
112631: LIST
112632: LIST
112633: LIST
112634: LIST
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: PUSH
112641: LD_INT 101
112643: PUSH
112644: LD_INT 102
112646: PUSH
112647: LD_INT 103
112649: PUSH
112650: LD_INT 105
112652: PUSH
112653: LD_INT 106
112655: PUSH
112656: LD_INT 108
112658: PUSH
112659: LD_INT 109
112661: PUSH
112662: LD_INT 112
112664: PUSH
112665: LD_INT 116
112667: PUSH
112668: LD_INT 117
112670: PUSH
112671: LD_INT 118
112673: PUSH
112674: EMPTY
112675: LIST
112676: LIST
112677: LIST
112678: LIST
112679: LIST
112680: LIST
112681: LIST
112682: LIST
112683: LIST
112684: LIST
112685: LIST
112686: PUSH
112687: EMPTY
112688: LIST
112689: LIST
112690: ST_TO_ADDR
112691: GO 114946
112693: LD_INT 9
112695: DOUBLE
112696: EQUAL
112697: IFTRUE 112701
112699: GO 112849
112701: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
112702: LD_ADDR_VAR 0 2
112706: PUSH
112707: LD_INT 2
112709: PUSH
112710: LD_INT 4
112712: PUSH
112713: LD_INT 5
112715: PUSH
112716: LD_INT 6
112718: PUSH
112719: LD_INT 7
112721: PUSH
112722: LD_INT 8
112724: PUSH
112725: LD_INT 11
112727: PUSH
112728: LD_INT 12
112730: PUSH
112731: LD_INT 15
112733: PUSH
112734: LD_INT 16
112736: PUSH
112737: LD_INT 20
112739: PUSH
112740: LD_INT 21
112742: PUSH
112743: LD_INT 22
112745: PUSH
112746: LD_INT 23
112748: PUSH
112749: LD_INT 25
112751: PUSH
112752: LD_INT 26
112754: PUSH
112755: LD_INT 28
112757: PUSH
112758: LD_INT 30
112760: PUSH
112761: LD_INT 31
112763: PUSH
112764: LD_INT 32
112766: PUSH
112767: LD_INT 36
112769: PUSH
112770: EMPTY
112771: LIST
112772: LIST
112773: LIST
112774: LIST
112775: LIST
112776: LIST
112777: LIST
112778: LIST
112779: LIST
112780: LIST
112781: LIST
112782: LIST
112783: LIST
112784: LIST
112785: LIST
112786: LIST
112787: LIST
112788: LIST
112789: LIST
112790: LIST
112791: LIST
112792: PUSH
112793: LD_INT 101
112795: PUSH
112796: LD_INT 102
112798: PUSH
112799: LD_INT 103
112801: PUSH
112802: LD_INT 105
112804: PUSH
112805: LD_INT 106
112807: PUSH
112808: LD_INT 108
112810: PUSH
112811: LD_INT 109
112813: PUSH
112814: LD_INT 112
112816: PUSH
112817: LD_INT 114
112819: PUSH
112820: LD_INT 116
112822: PUSH
112823: LD_INT 117
112825: PUSH
112826: LD_INT 118
112828: PUSH
112829: EMPTY
112830: LIST
112831: LIST
112832: LIST
112833: LIST
112834: LIST
112835: LIST
112836: LIST
112837: LIST
112838: LIST
112839: LIST
112840: LIST
112841: LIST
112842: PUSH
112843: EMPTY
112844: LIST
112845: LIST
112846: ST_TO_ADDR
112847: GO 114946
112849: LD_INT 10
112851: DOUBLE
112852: EQUAL
112853: IFTRUE 112857
112855: GO 113053
112857: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
112858: LD_ADDR_VAR 0 2
112862: PUSH
112863: LD_INT 2
112865: PUSH
112866: LD_INT 4
112868: PUSH
112869: LD_INT 5
112871: PUSH
112872: LD_INT 6
112874: PUSH
112875: LD_INT 7
112877: PUSH
112878: LD_INT 8
112880: PUSH
112881: LD_INT 9
112883: PUSH
112884: LD_INT 10
112886: PUSH
112887: LD_INT 11
112889: PUSH
112890: LD_INT 12
112892: PUSH
112893: LD_INT 13
112895: PUSH
112896: LD_INT 14
112898: PUSH
112899: LD_INT 15
112901: PUSH
112902: LD_INT 16
112904: PUSH
112905: LD_INT 17
112907: PUSH
112908: LD_INT 18
112910: PUSH
112911: LD_INT 19
112913: PUSH
112914: LD_INT 20
112916: PUSH
112917: LD_INT 21
112919: PUSH
112920: LD_INT 22
112922: PUSH
112923: LD_INT 23
112925: PUSH
112926: LD_INT 24
112928: PUSH
112929: LD_INT 25
112931: PUSH
112932: LD_INT 26
112934: PUSH
112935: LD_INT 28
112937: PUSH
112938: LD_INT 30
112940: PUSH
112941: LD_INT 31
112943: PUSH
112944: LD_INT 32
112946: PUSH
112947: LD_INT 36
112949: PUSH
112950: EMPTY
112951: LIST
112952: LIST
112953: LIST
112954: LIST
112955: LIST
112956: LIST
112957: LIST
112958: LIST
112959: LIST
112960: LIST
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: LIST
112969: LIST
112970: LIST
112971: LIST
112972: LIST
112973: LIST
112974: LIST
112975: LIST
112976: LIST
112977: LIST
112978: LIST
112979: LIST
112980: PUSH
112981: LD_INT 101
112983: PUSH
112984: LD_INT 102
112986: PUSH
112987: LD_INT 103
112989: PUSH
112990: LD_INT 104
112992: PUSH
112993: LD_INT 105
112995: PUSH
112996: LD_INT 106
112998: PUSH
112999: LD_INT 107
113001: PUSH
113002: LD_INT 108
113004: PUSH
113005: LD_INT 109
113007: PUSH
113008: LD_INT 110
113010: PUSH
113011: LD_INT 111
113013: PUSH
113014: LD_INT 112
113016: PUSH
113017: LD_INT 114
113019: PUSH
113020: LD_INT 116
113022: PUSH
113023: LD_INT 117
113025: PUSH
113026: LD_INT 118
113028: PUSH
113029: EMPTY
113030: LIST
113031: LIST
113032: LIST
113033: LIST
113034: LIST
113035: LIST
113036: LIST
113037: LIST
113038: LIST
113039: LIST
113040: LIST
113041: LIST
113042: LIST
113043: LIST
113044: LIST
113045: LIST
113046: PUSH
113047: EMPTY
113048: LIST
113049: LIST
113050: ST_TO_ADDR
113051: GO 114946
113053: LD_INT 11
113055: DOUBLE
113056: EQUAL
113057: IFTRUE 113061
113059: GO 113265
113061: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
113062: LD_ADDR_VAR 0 2
113066: PUSH
113067: LD_INT 2
113069: PUSH
113070: LD_INT 3
113072: PUSH
113073: LD_INT 4
113075: PUSH
113076: LD_INT 5
113078: PUSH
113079: LD_INT 6
113081: PUSH
113082: LD_INT 7
113084: PUSH
113085: LD_INT 8
113087: PUSH
113088: LD_INT 9
113090: PUSH
113091: LD_INT 10
113093: PUSH
113094: LD_INT 11
113096: PUSH
113097: LD_INT 12
113099: PUSH
113100: LD_INT 13
113102: PUSH
113103: LD_INT 14
113105: PUSH
113106: LD_INT 15
113108: PUSH
113109: LD_INT 16
113111: PUSH
113112: LD_INT 17
113114: PUSH
113115: LD_INT 18
113117: PUSH
113118: LD_INT 19
113120: PUSH
113121: LD_INT 20
113123: PUSH
113124: LD_INT 21
113126: PUSH
113127: LD_INT 22
113129: PUSH
113130: LD_INT 23
113132: PUSH
113133: LD_INT 24
113135: PUSH
113136: LD_INT 25
113138: PUSH
113139: LD_INT 26
113141: PUSH
113142: LD_INT 28
113144: PUSH
113145: LD_INT 30
113147: PUSH
113148: LD_INT 31
113150: PUSH
113151: LD_INT 32
113153: PUSH
113154: LD_INT 34
113156: PUSH
113157: LD_INT 36
113159: PUSH
113160: EMPTY
113161: LIST
113162: LIST
113163: LIST
113164: LIST
113165: LIST
113166: LIST
113167: LIST
113168: LIST
113169: LIST
113170: LIST
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: LIST
113179: LIST
113180: LIST
113181: LIST
113182: LIST
113183: LIST
113184: LIST
113185: LIST
113186: LIST
113187: LIST
113188: LIST
113189: LIST
113190: LIST
113191: LIST
113192: PUSH
113193: LD_INT 101
113195: PUSH
113196: LD_INT 102
113198: PUSH
113199: LD_INT 103
113201: PUSH
113202: LD_INT 104
113204: PUSH
113205: LD_INT 105
113207: PUSH
113208: LD_INT 106
113210: PUSH
113211: LD_INT 107
113213: PUSH
113214: LD_INT 108
113216: PUSH
113217: LD_INT 109
113219: PUSH
113220: LD_INT 110
113222: PUSH
113223: LD_INT 111
113225: PUSH
113226: LD_INT 112
113228: PUSH
113229: LD_INT 114
113231: PUSH
113232: LD_INT 116
113234: PUSH
113235: LD_INT 117
113237: PUSH
113238: LD_INT 118
113240: PUSH
113241: EMPTY
113242: LIST
113243: LIST
113244: LIST
113245: LIST
113246: LIST
113247: LIST
113248: LIST
113249: LIST
113250: LIST
113251: LIST
113252: LIST
113253: LIST
113254: LIST
113255: LIST
113256: LIST
113257: LIST
113258: PUSH
113259: EMPTY
113260: LIST
113261: LIST
113262: ST_TO_ADDR
113263: GO 114946
113265: LD_INT 12
113267: DOUBLE
113268: EQUAL
113269: IFTRUE 113273
113271: GO 113493
113273: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
113274: LD_ADDR_VAR 0 2
113278: PUSH
113279: LD_INT 1
113281: PUSH
113282: LD_INT 2
113284: PUSH
113285: LD_INT 3
113287: PUSH
113288: LD_INT 4
113290: PUSH
113291: LD_INT 5
113293: PUSH
113294: LD_INT 6
113296: PUSH
113297: LD_INT 7
113299: PUSH
113300: LD_INT 8
113302: PUSH
113303: LD_INT 9
113305: PUSH
113306: LD_INT 10
113308: PUSH
113309: LD_INT 11
113311: PUSH
113312: LD_INT 12
113314: PUSH
113315: LD_INT 13
113317: PUSH
113318: LD_INT 14
113320: PUSH
113321: LD_INT 15
113323: PUSH
113324: LD_INT 16
113326: PUSH
113327: LD_INT 17
113329: PUSH
113330: LD_INT 18
113332: PUSH
113333: LD_INT 19
113335: PUSH
113336: LD_INT 20
113338: PUSH
113339: LD_INT 21
113341: PUSH
113342: LD_INT 22
113344: PUSH
113345: LD_INT 23
113347: PUSH
113348: LD_INT 24
113350: PUSH
113351: LD_INT 25
113353: PUSH
113354: LD_INT 26
113356: PUSH
113357: LD_INT 27
113359: PUSH
113360: LD_INT 28
113362: PUSH
113363: LD_INT 30
113365: PUSH
113366: LD_INT 31
113368: PUSH
113369: LD_INT 32
113371: PUSH
113372: LD_INT 33
113374: PUSH
113375: LD_INT 34
113377: PUSH
113378: LD_INT 36
113380: PUSH
113381: EMPTY
113382: LIST
113383: LIST
113384: LIST
113385: LIST
113386: LIST
113387: LIST
113388: LIST
113389: LIST
113390: LIST
113391: LIST
113392: LIST
113393: LIST
113394: LIST
113395: LIST
113396: LIST
113397: LIST
113398: LIST
113399: LIST
113400: LIST
113401: LIST
113402: LIST
113403: LIST
113404: LIST
113405: LIST
113406: LIST
113407: LIST
113408: LIST
113409: LIST
113410: LIST
113411: LIST
113412: LIST
113413: LIST
113414: LIST
113415: LIST
113416: PUSH
113417: LD_INT 101
113419: PUSH
113420: LD_INT 102
113422: PUSH
113423: LD_INT 103
113425: PUSH
113426: LD_INT 104
113428: PUSH
113429: LD_INT 105
113431: PUSH
113432: LD_INT 106
113434: PUSH
113435: LD_INT 107
113437: PUSH
113438: LD_INT 108
113440: PUSH
113441: LD_INT 109
113443: PUSH
113444: LD_INT 110
113446: PUSH
113447: LD_INT 111
113449: PUSH
113450: LD_INT 112
113452: PUSH
113453: LD_INT 113
113455: PUSH
113456: LD_INT 114
113458: PUSH
113459: LD_INT 116
113461: PUSH
113462: LD_INT 117
113464: PUSH
113465: LD_INT 118
113467: PUSH
113468: EMPTY
113469: LIST
113470: LIST
113471: LIST
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: LIST
113486: PUSH
113487: EMPTY
113488: LIST
113489: LIST
113490: ST_TO_ADDR
113491: GO 114946
113493: LD_INT 13
113495: DOUBLE
113496: EQUAL
113497: IFTRUE 113501
113499: GO 113709
113501: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
113502: LD_ADDR_VAR 0 2
113506: PUSH
113507: LD_INT 1
113509: PUSH
113510: LD_INT 2
113512: PUSH
113513: LD_INT 3
113515: PUSH
113516: LD_INT 4
113518: PUSH
113519: LD_INT 5
113521: PUSH
113522: LD_INT 8
113524: PUSH
113525: LD_INT 9
113527: PUSH
113528: LD_INT 10
113530: PUSH
113531: LD_INT 11
113533: PUSH
113534: LD_INT 12
113536: PUSH
113537: LD_INT 14
113539: PUSH
113540: LD_INT 15
113542: PUSH
113543: LD_INT 16
113545: PUSH
113546: LD_INT 17
113548: PUSH
113549: LD_INT 18
113551: PUSH
113552: LD_INT 19
113554: PUSH
113555: LD_INT 20
113557: PUSH
113558: LD_INT 21
113560: PUSH
113561: LD_INT 22
113563: PUSH
113564: LD_INT 23
113566: PUSH
113567: LD_INT 24
113569: PUSH
113570: LD_INT 25
113572: PUSH
113573: LD_INT 26
113575: PUSH
113576: LD_INT 27
113578: PUSH
113579: LD_INT 28
113581: PUSH
113582: LD_INT 30
113584: PUSH
113585: LD_INT 31
113587: PUSH
113588: LD_INT 32
113590: PUSH
113591: LD_INT 33
113593: PUSH
113594: LD_INT 34
113596: PUSH
113597: LD_INT 36
113599: PUSH
113600: EMPTY
113601: LIST
113602: LIST
113603: LIST
113604: LIST
113605: LIST
113606: LIST
113607: LIST
113608: LIST
113609: LIST
113610: LIST
113611: LIST
113612: LIST
113613: LIST
113614: LIST
113615: LIST
113616: LIST
113617: LIST
113618: LIST
113619: LIST
113620: LIST
113621: LIST
113622: LIST
113623: LIST
113624: LIST
113625: LIST
113626: LIST
113627: LIST
113628: LIST
113629: LIST
113630: LIST
113631: LIST
113632: PUSH
113633: LD_INT 101
113635: PUSH
113636: LD_INT 102
113638: PUSH
113639: LD_INT 103
113641: PUSH
113642: LD_INT 104
113644: PUSH
113645: LD_INT 105
113647: PUSH
113648: LD_INT 106
113650: PUSH
113651: LD_INT 107
113653: PUSH
113654: LD_INT 108
113656: PUSH
113657: LD_INT 109
113659: PUSH
113660: LD_INT 110
113662: PUSH
113663: LD_INT 111
113665: PUSH
113666: LD_INT 112
113668: PUSH
113669: LD_INT 113
113671: PUSH
113672: LD_INT 114
113674: PUSH
113675: LD_INT 116
113677: PUSH
113678: LD_INT 117
113680: PUSH
113681: LD_INT 118
113683: PUSH
113684: EMPTY
113685: LIST
113686: LIST
113687: LIST
113688: LIST
113689: LIST
113690: LIST
113691: LIST
113692: LIST
113693: LIST
113694: LIST
113695: LIST
113696: LIST
113697: LIST
113698: LIST
113699: LIST
113700: LIST
113701: LIST
113702: PUSH
113703: EMPTY
113704: LIST
113705: LIST
113706: ST_TO_ADDR
113707: GO 114946
113709: LD_INT 14
113711: DOUBLE
113712: EQUAL
113713: IFTRUE 113717
113715: GO 113941
113717: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
113718: LD_ADDR_VAR 0 2
113722: PUSH
113723: LD_INT 1
113725: PUSH
113726: LD_INT 2
113728: PUSH
113729: LD_INT 3
113731: PUSH
113732: LD_INT 4
113734: PUSH
113735: LD_INT 5
113737: PUSH
113738: LD_INT 6
113740: PUSH
113741: LD_INT 7
113743: PUSH
113744: LD_INT 8
113746: PUSH
113747: LD_INT 9
113749: PUSH
113750: LD_INT 10
113752: PUSH
113753: LD_INT 11
113755: PUSH
113756: LD_INT 12
113758: PUSH
113759: LD_INT 13
113761: PUSH
113762: LD_INT 14
113764: PUSH
113765: LD_INT 15
113767: PUSH
113768: LD_INT 16
113770: PUSH
113771: LD_INT 17
113773: PUSH
113774: LD_INT 18
113776: PUSH
113777: LD_INT 19
113779: PUSH
113780: LD_INT 20
113782: PUSH
113783: LD_INT 21
113785: PUSH
113786: LD_INT 22
113788: PUSH
113789: LD_INT 23
113791: PUSH
113792: LD_INT 24
113794: PUSH
113795: LD_INT 25
113797: PUSH
113798: LD_INT 26
113800: PUSH
113801: LD_INT 27
113803: PUSH
113804: LD_INT 28
113806: PUSH
113807: LD_INT 29
113809: PUSH
113810: LD_INT 30
113812: PUSH
113813: LD_INT 31
113815: PUSH
113816: LD_INT 32
113818: PUSH
113819: LD_INT 33
113821: PUSH
113822: LD_INT 34
113824: PUSH
113825: LD_INT 36
113827: PUSH
113828: EMPTY
113829: LIST
113830: LIST
113831: LIST
113832: LIST
113833: LIST
113834: LIST
113835: LIST
113836: LIST
113837: LIST
113838: LIST
113839: LIST
113840: LIST
113841: LIST
113842: LIST
113843: LIST
113844: LIST
113845: LIST
113846: LIST
113847: LIST
113848: LIST
113849: LIST
113850: LIST
113851: LIST
113852: LIST
113853: LIST
113854: LIST
113855: LIST
113856: LIST
113857: LIST
113858: LIST
113859: LIST
113860: LIST
113861: LIST
113862: LIST
113863: LIST
113864: PUSH
113865: LD_INT 101
113867: PUSH
113868: LD_INT 102
113870: PUSH
113871: LD_INT 103
113873: PUSH
113874: LD_INT 104
113876: PUSH
113877: LD_INT 105
113879: PUSH
113880: LD_INT 106
113882: PUSH
113883: LD_INT 107
113885: PUSH
113886: LD_INT 108
113888: PUSH
113889: LD_INT 109
113891: PUSH
113892: LD_INT 110
113894: PUSH
113895: LD_INT 111
113897: PUSH
113898: LD_INT 112
113900: PUSH
113901: LD_INT 113
113903: PUSH
113904: LD_INT 114
113906: PUSH
113907: LD_INT 116
113909: PUSH
113910: LD_INT 117
113912: PUSH
113913: LD_INT 118
113915: PUSH
113916: EMPTY
113917: LIST
113918: LIST
113919: LIST
113920: LIST
113921: LIST
113922: LIST
113923: LIST
113924: LIST
113925: LIST
113926: LIST
113927: LIST
113928: LIST
113929: LIST
113930: LIST
113931: LIST
113932: LIST
113933: LIST
113934: PUSH
113935: EMPTY
113936: LIST
113937: LIST
113938: ST_TO_ADDR
113939: GO 114946
113941: LD_INT 15
113943: DOUBLE
113944: EQUAL
113945: IFTRUE 113949
113947: GO 114173
113949: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
113950: LD_ADDR_VAR 0 2
113954: PUSH
113955: LD_INT 1
113957: PUSH
113958: LD_INT 2
113960: PUSH
113961: LD_INT 3
113963: PUSH
113964: LD_INT 4
113966: PUSH
113967: LD_INT 5
113969: PUSH
113970: LD_INT 6
113972: PUSH
113973: LD_INT 7
113975: PUSH
113976: LD_INT 8
113978: PUSH
113979: LD_INT 9
113981: PUSH
113982: LD_INT 10
113984: PUSH
113985: LD_INT 11
113987: PUSH
113988: LD_INT 12
113990: PUSH
113991: LD_INT 13
113993: PUSH
113994: LD_INT 14
113996: PUSH
113997: LD_INT 15
113999: PUSH
114000: LD_INT 16
114002: PUSH
114003: LD_INT 17
114005: PUSH
114006: LD_INT 18
114008: PUSH
114009: LD_INT 19
114011: PUSH
114012: LD_INT 20
114014: PUSH
114015: LD_INT 21
114017: PUSH
114018: LD_INT 22
114020: PUSH
114021: LD_INT 23
114023: PUSH
114024: LD_INT 24
114026: PUSH
114027: LD_INT 25
114029: PUSH
114030: LD_INT 26
114032: PUSH
114033: LD_INT 27
114035: PUSH
114036: LD_INT 28
114038: PUSH
114039: LD_INT 29
114041: PUSH
114042: LD_INT 30
114044: PUSH
114045: LD_INT 31
114047: PUSH
114048: LD_INT 32
114050: PUSH
114051: LD_INT 33
114053: PUSH
114054: LD_INT 34
114056: PUSH
114057: LD_INT 36
114059: PUSH
114060: EMPTY
114061: LIST
114062: LIST
114063: LIST
114064: LIST
114065: LIST
114066: LIST
114067: LIST
114068: LIST
114069: LIST
114070: LIST
114071: LIST
114072: LIST
114073: LIST
114074: LIST
114075: LIST
114076: LIST
114077: LIST
114078: LIST
114079: LIST
114080: LIST
114081: LIST
114082: LIST
114083: LIST
114084: LIST
114085: LIST
114086: LIST
114087: LIST
114088: LIST
114089: LIST
114090: LIST
114091: LIST
114092: LIST
114093: LIST
114094: LIST
114095: LIST
114096: PUSH
114097: LD_INT 101
114099: PUSH
114100: LD_INT 102
114102: PUSH
114103: LD_INT 103
114105: PUSH
114106: LD_INT 104
114108: PUSH
114109: LD_INT 105
114111: PUSH
114112: LD_INT 106
114114: PUSH
114115: LD_INT 107
114117: PUSH
114118: LD_INT 108
114120: PUSH
114121: LD_INT 109
114123: PUSH
114124: LD_INT 110
114126: PUSH
114127: LD_INT 111
114129: PUSH
114130: LD_INT 112
114132: PUSH
114133: LD_INT 113
114135: PUSH
114136: LD_INT 114
114138: PUSH
114139: LD_INT 116
114141: PUSH
114142: LD_INT 117
114144: PUSH
114145: LD_INT 118
114147: PUSH
114148: EMPTY
114149: LIST
114150: LIST
114151: LIST
114152: LIST
114153: LIST
114154: LIST
114155: LIST
114156: LIST
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: PUSH
114167: EMPTY
114168: LIST
114169: LIST
114170: ST_TO_ADDR
114171: GO 114946
114173: LD_INT 16
114175: DOUBLE
114176: EQUAL
114177: IFTRUE 114181
114179: GO 114317
114181: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
114182: LD_ADDR_VAR 0 2
114186: PUSH
114187: LD_INT 2
114189: PUSH
114190: LD_INT 4
114192: PUSH
114193: LD_INT 5
114195: PUSH
114196: LD_INT 7
114198: PUSH
114199: LD_INT 11
114201: PUSH
114202: LD_INT 12
114204: PUSH
114205: LD_INT 15
114207: PUSH
114208: LD_INT 16
114210: PUSH
114211: LD_INT 20
114213: PUSH
114214: LD_INT 21
114216: PUSH
114217: LD_INT 22
114219: PUSH
114220: LD_INT 23
114222: PUSH
114223: LD_INT 25
114225: PUSH
114226: LD_INT 26
114228: PUSH
114229: LD_INT 30
114231: PUSH
114232: LD_INT 31
114234: PUSH
114235: LD_INT 32
114237: PUSH
114238: LD_INT 33
114240: PUSH
114241: LD_INT 34
114243: PUSH
114244: EMPTY
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: LIST
114250: LIST
114251: LIST
114252: LIST
114253: LIST
114254: LIST
114255: LIST
114256: LIST
114257: LIST
114258: LIST
114259: LIST
114260: LIST
114261: LIST
114262: LIST
114263: LIST
114264: PUSH
114265: LD_INT 101
114267: PUSH
114268: LD_INT 102
114270: PUSH
114271: LD_INT 103
114273: PUSH
114274: LD_INT 106
114276: PUSH
114277: LD_INT 108
114279: PUSH
114280: LD_INT 112
114282: PUSH
114283: LD_INT 113
114285: PUSH
114286: LD_INT 114
114288: PUSH
114289: LD_INT 116
114291: PUSH
114292: LD_INT 117
114294: PUSH
114295: LD_INT 118
114297: PUSH
114298: EMPTY
114299: LIST
114300: LIST
114301: LIST
114302: LIST
114303: LIST
114304: LIST
114305: LIST
114306: LIST
114307: LIST
114308: LIST
114309: LIST
114310: PUSH
114311: EMPTY
114312: LIST
114313: LIST
114314: ST_TO_ADDR
114315: GO 114946
114317: LD_INT 17
114319: DOUBLE
114320: EQUAL
114321: IFTRUE 114325
114323: GO 114549
114325: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
114326: LD_ADDR_VAR 0 2
114330: PUSH
114331: LD_INT 1
114333: PUSH
114334: LD_INT 2
114336: PUSH
114337: LD_INT 3
114339: PUSH
114340: LD_INT 4
114342: PUSH
114343: LD_INT 5
114345: PUSH
114346: LD_INT 6
114348: PUSH
114349: LD_INT 7
114351: PUSH
114352: LD_INT 8
114354: PUSH
114355: LD_INT 9
114357: PUSH
114358: LD_INT 10
114360: PUSH
114361: LD_INT 11
114363: PUSH
114364: LD_INT 12
114366: PUSH
114367: LD_INT 13
114369: PUSH
114370: LD_INT 14
114372: PUSH
114373: LD_INT 15
114375: PUSH
114376: LD_INT 16
114378: PUSH
114379: LD_INT 17
114381: PUSH
114382: LD_INT 18
114384: PUSH
114385: LD_INT 19
114387: PUSH
114388: LD_INT 20
114390: PUSH
114391: LD_INT 21
114393: PUSH
114394: LD_INT 22
114396: PUSH
114397: LD_INT 23
114399: PUSH
114400: LD_INT 24
114402: PUSH
114403: LD_INT 25
114405: PUSH
114406: LD_INT 26
114408: PUSH
114409: LD_INT 27
114411: PUSH
114412: LD_INT 28
114414: PUSH
114415: LD_INT 29
114417: PUSH
114418: LD_INT 30
114420: PUSH
114421: LD_INT 31
114423: PUSH
114424: LD_INT 32
114426: PUSH
114427: LD_INT 33
114429: PUSH
114430: LD_INT 34
114432: PUSH
114433: LD_INT 36
114435: PUSH
114436: EMPTY
114437: LIST
114438: LIST
114439: LIST
114440: LIST
114441: LIST
114442: LIST
114443: LIST
114444: LIST
114445: LIST
114446: LIST
114447: LIST
114448: LIST
114449: LIST
114450: LIST
114451: LIST
114452: LIST
114453: LIST
114454: LIST
114455: LIST
114456: LIST
114457: LIST
114458: LIST
114459: LIST
114460: LIST
114461: LIST
114462: LIST
114463: LIST
114464: LIST
114465: LIST
114466: LIST
114467: LIST
114468: LIST
114469: LIST
114470: LIST
114471: LIST
114472: PUSH
114473: LD_INT 101
114475: PUSH
114476: LD_INT 102
114478: PUSH
114479: LD_INT 103
114481: PUSH
114482: LD_INT 104
114484: PUSH
114485: LD_INT 105
114487: PUSH
114488: LD_INT 106
114490: PUSH
114491: LD_INT 107
114493: PUSH
114494: LD_INT 108
114496: PUSH
114497: LD_INT 109
114499: PUSH
114500: LD_INT 110
114502: PUSH
114503: LD_INT 111
114505: PUSH
114506: LD_INT 112
114508: PUSH
114509: LD_INT 113
114511: PUSH
114512: LD_INT 114
114514: PUSH
114515: LD_INT 116
114517: PUSH
114518: LD_INT 117
114520: PUSH
114521: LD_INT 118
114523: PUSH
114524: EMPTY
114525: LIST
114526: LIST
114527: LIST
114528: LIST
114529: LIST
114530: LIST
114531: LIST
114532: LIST
114533: LIST
114534: LIST
114535: LIST
114536: LIST
114537: LIST
114538: LIST
114539: LIST
114540: LIST
114541: LIST
114542: PUSH
114543: EMPTY
114544: LIST
114545: LIST
114546: ST_TO_ADDR
114547: GO 114946
114549: LD_INT 18
114551: DOUBLE
114552: EQUAL
114553: IFTRUE 114557
114555: GO 114705
114557: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
114558: LD_ADDR_VAR 0 2
114562: PUSH
114563: LD_INT 2
114565: PUSH
114566: LD_INT 4
114568: PUSH
114569: LD_INT 5
114571: PUSH
114572: LD_INT 7
114574: PUSH
114575: LD_INT 11
114577: PUSH
114578: LD_INT 12
114580: PUSH
114581: LD_INT 15
114583: PUSH
114584: LD_INT 16
114586: PUSH
114587: LD_INT 20
114589: PUSH
114590: LD_INT 21
114592: PUSH
114593: LD_INT 22
114595: PUSH
114596: LD_INT 23
114598: PUSH
114599: LD_INT 25
114601: PUSH
114602: LD_INT 26
114604: PUSH
114605: LD_INT 30
114607: PUSH
114608: LD_INT 31
114610: PUSH
114611: LD_INT 32
114613: PUSH
114614: LD_INT 33
114616: PUSH
114617: LD_INT 34
114619: PUSH
114620: LD_INT 35
114622: PUSH
114623: LD_INT 36
114625: PUSH
114626: EMPTY
114627: LIST
114628: LIST
114629: LIST
114630: LIST
114631: LIST
114632: LIST
114633: LIST
114634: LIST
114635: LIST
114636: LIST
114637: LIST
114638: LIST
114639: LIST
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: LIST
114645: LIST
114646: LIST
114647: LIST
114648: PUSH
114649: LD_INT 101
114651: PUSH
114652: LD_INT 102
114654: PUSH
114655: LD_INT 103
114657: PUSH
114658: LD_INT 106
114660: PUSH
114661: LD_INT 108
114663: PUSH
114664: LD_INT 112
114666: PUSH
114667: LD_INT 113
114669: PUSH
114670: LD_INT 114
114672: PUSH
114673: LD_INT 115
114675: PUSH
114676: LD_INT 116
114678: PUSH
114679: LD_INT 117
114681: PUSH
114682: LD_INT 118
114684: PUSH
114685: EMPTY
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: LIST
114694: LIST
114695: LIST
114696: LIST
114697: LIST
114698: PUSH
114699: EMPTY
114700: LIST
114701: LIST
114702: ST_TO_ADDR
114703: GO 114946
114705: LD_INT 19
114707: DOUBLE
114708: EQUAL
114709: IFTRUE 114713
114711: GO 114945
114713: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
114714: LD_ADDR_VAR 0 2
114718: PUSH
114719: LD_INT 1
114721: PUSH
114722: LD_INT 2
114724: PUSH
114725: LD_INT 3
114727: PUSH
114728: LD_INT 4
114730: PUSH
114731: LD_INT 5
114733: PUSH
114734: LD_INT 6
114736: PUSH
114737: LD_INT 7
114739: PUSH
114740: LD_INT 8
114742: PUSH
114743: LD_INT 9
114745: PUSH
114746: LD_INT 10
114748: PUSH
114749: LD_INT 11
114751: PUSH
114752: LD_INT 12
114754: PUSH
114755: LD_INT 13
114757: PUSH
114758: LD_INT 14
114760: PUSH
114761: LD_INT 15
114763: PUSH
114764: LD_INT 16
114766: PUSH
114767: LD_INT 17
114769: PUSH
114770: LD_INT 18
114772: PUSH
114773: LD_INT 19
114775: PUSH
114776: LD_INT 20
114778: PUSH
114779: LD_INT 21
114781: PUSH
114782: LD_INT 22
114784: PUSH
114785: LD_INT 23
114787: PUSH
114788: LD_INT 24
114790: PUSH
114791: LD_INT 25
114793: PUSH
114794: LD_INT 26
114796: PUSH
114797: LD_INT 27
114799: PUSH
114800: LD_INT 28
114802: PUSH
114803: LD_INT 29
114805: PUSH
114806: LD_INT 30
114808: PUSH
114809: LD_INT 31
114811: PUSH
114812: LD_INT 32
114814: PUSH
114815: LD_INT 33
114817: PUSH
114818: LD_INT 34
114820: PUSH
114821: LD_INT 35
114823: PUSH
114824: LD_INT 36
114826: PUSH
114827: EMPTY
114828: LIST
114829: LIST
114830: LIST
114831: LIST
114832: LIST
114833: LIST
114834: LIST
114835: LIST
114836: LIST
114837: LIST
114838: LIST
114839: LIST
114840: LIST
114841: LIST
114842: LIST
114843: LIST
114844: LIST
114845: LIST
114846: LIST
114847: LIST
114848: LIST
114849: LIST
114850: LIST
114851: LIST
114852: LIST
114853: LIST
114854: LIST
114855: LIST
114856: LIST
114857: LIST
114858: LIST
114859: LIST
114860: LIST
114861: LIST
114862: LIST
114863: LIST
114864: PUSH
114865: LD_INT 101
114867: PUSH
114868: LD_INT 102
114870: PUSH
114871: LD_INT 103
114873: PUSH
114874: LD_INT 104
114876: PUSH
114877: LD_INT 105
114879: PUSH
114880: LD_INT 106
114882: PUSH
114883: LD_INT 107
114885: PUSH
114886: LD_INT 108
114888: PUSH
114889: LD_INT 109
114891: PUSH
114892: LD_INT 110
114894: PUSH
114895: LD_INT 111
114897: PUSH
114898: LD_INT 112
114900: PUSH
114901: LD_INT 113
114903: PUSH
114904: LD_INT 114
114906: PUSH
114907: LD_INT 115
114909: PUSH
114910: LD_INT 116
114912: PUSH
114913: LD_INT 117
114915: PUSH
114916: LD_INT 118
114918: PUSH
114919: EMPTY
114920: LIST
114921: LIST
114922: LIST
114923: LIST
114924: LIST
114925: LIST
114926: LIST
114927: LIST
114928: LIST
114929: LIST
114930: LIST
114931: LIST
114932: LIST
114933: LIST
114934: LIST
114935: LIST
114936: LIST
114937: LIST
114938: PUSH
114939: EMPTY
114940: LIST
114941: LIST
114942: ST_TO_ADDR
114943: GO 114946
114945: POP
// end else
114946: GO 115177
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
114948: LD_ADDR_VAR 0 2
114952: PUSH
114953: LD_INT 1
114955: PUSH
114956: LD_INT 2
114958: PUSH
114959: LD_INT 3
114961: PUSH
114962: LD_INT 4
114964: PUSH
114965: LD_INT 5
114967: PUSH
114968: LD_INT 6
114970: PUSH
114971: LD_INT 7
114973: PUSH
114974: LD_INT 8
114976: PUSH
114977: LD_INT 9
114979: PUSH
114980: LD_INT 10
114982: PUSH
114983: LD_INT 11
114985: PUSH
114986: LD_INT 12
114988: PUSH
114989: LD_INT 13
114991: PUSH
114992: LD_INT 14
114994: PUSH
114995: LD_INT 15
114997: PUSH
114998: LD_INT 16
115000: PUSH
115001: LD_INT 17
115003: PUSH
115004: LD_INT 18
115006: PUSH
115007: LD_INT 19
115009: PUSH
115010: LD_INT 20
115012: PUSH
115013: LD_INT 21
115015: PUSH
115016: LD_INT 22
115018: PUSH
115019: LD_INT 23
115021: PUSH
115022: LD_INT 24
115024: PUSH
115025: LD_INT 25
115027: PUSH
115028: LD_INT 26
115030: PUSH
115031: LD_INT 27
115033: PUSH
115034: LD_INT 28
115036: PUSH
115037: LD_INT 29
115039: PUSH
115040: LD_INT 30
115042: PUSH
115043: LD_INT 31
115045: PUSH
115046: LD_INT 32
115048: PUSH
115049: LD_INT 33
115051: PUSH
115052: LD_INT 34
115054: PUSH
115055: LD_INT 35
115057: PUSH
115058: LD_INT 36
115060: PUSH
115061: EMPTY
115062: LIST
115063: LIST
115064: LIST
115065: LIST
115066: LIST
115067: LIST
115068: LIST
115069: LIST
115070: LIST
115071: LIST
115072: LIST
115073: LIST
115074: LIST
115075: LIST
115076: LIST
115077: LIST
115078: LIST
115079: LIST
115080: LIST
115081: LIST
115082: LIST
115083: LIST
115084: LIST
115085: LIST
115086: LIST
115087: LIST
115088: LIST
115089: LIST
115090: LIST
115091: LIST
115092: LIST
115093: LIST
115094: LIST
115095: LIST
115096: LIST
115097: LIST
115098: PUSH
115099: LD_INT 101
115101: PUSH
115102: LD_INT 102
115104: PUSH
115105: LD_INT 103
115107: PUSH
115108: LD_INT 104
115110: PUSH
115111: LD_INT 105
115113: PUSH
115114: LD_INT 106
115116: PUSH
115117: LD_INT 107
115119: PUSH
115120: LD_INT 108
115122: PUSH
115123: LD_INT 109
115125: PUSH
115126: LD_INT 110
115128: PUSH
115129: LD_INT 111
115131: PUSH
115132: LD_INT 112
115134: PUSH
115135: LD_INT 113
115137: PUSH
115138: LD_INT 114
115140: PUSH
115141: LD_INT 115
115143: PUSH
115144: LD_INT 116
115146: PUSH
115147: LD_INT 117
115149: PUSH
115150: LD_INT 118
115152: PUSH
115153: EMPTY
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: LIST
115160: LIST
115161: LIST
115162: LIST
115163: LIST
115164: LIST
115165: LIST
115166: LIST
115167: LIST
115168: LIST
115169: LIST
115170: LIST
115171: LIST
115172: PUSH
115173: EMPTY
115174: LIST
115175: LIST
115176: ST_TO_ADDR
// if result then
115177: LD_VAR 0 2
115181: IFFALSE 115967
// begin normal :=  ;
115183: LD_ADDR_VAR 0 5
115187: PUSH
115188: LD_STRING 
115190: ST_TO_ADDR
// hardcore :=  ;
115191: LD_ADDR_VAR 0 6
115195: PUSH
115196: LD_STRING 
115198: ST_TO_ADDR
// active :=  ;
115199: LD_ADDR_VAR 0 7
115203: PUSH
115204: LD_STRING 
115206: ST_TO_ADDR
// for i = 1 to normalCounter do
115207: LD_ADDR_VAR 0 8
115211: PUSH
115212: DOUBLE
115213: LD_INT 1
115215: DEC
115216: ST_TO_ADDR
115217: LD_EXP 147
115221: PUSH
115222: FOR_TO
115223: IFFALSE 115324
// begin tmp := 0 ;
115225: LD_ADDR_VAR 0 3
115229: PUSH
115230: LD_STRING 0
115232: ST_TO_ADDR
// if result [ 1 ] then
115233: LD_VAR 0 2
115237: PUSH
115238: LD_INT 1
115240: ARRAY
115241: IFFALSE 115306
// if result [ 1 ] [ 1 ] = i then
115243: LD_VAR 0 2
115247: PUSH
115248: LD_INT 1
115250: ARRAY
115251: PUSH
115252: LD_INT 1
115254: ARRAY
115255: PUSH
115256: LD_VAR 0 8
115260: EQUAL
115261: IFFALSE 115306
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
115263: LD_ADDR_VAR 0 2
115267: PUSH
115268: LD_VAR 0 2
115272: PPUSH
115273: LD_INT 1
115275: PPUSH
115276: LD_VAR 0 2
115280: PUSH
115281: LD_INT 1
115283: ARRAY
115284: PPUSH
115285: LD_INT 1
115287: PPUSH
115288: CALL_OW 3
115292: PPUSH
115293: CALL_OW 1
115297: ST_TO_ADDR
// tmp := 1 ;
115298: LD_ADDR_VAR 0 3
115302: PUSH
115303: LD_STRING 1
115305: ST_TO_ADDR
// end ; normal := normal & tmp ;
115306: LD_ADDR_VAR 0 5
115310: PUSH
115311: LD_VAR 0 5
115315: PUSH
115316: LD_VAR 0 3
115320: STR
115321: ST_TO_ADDR
// end ;
115322: GO 115222
115324: POP
115325: POP
// for i = 1 to hardcoreCounter do
115326: LD_ADDR_VAR 0 8
115330: PUSH
115331: DOUBLE
115332: LD_INT 1
115334: DEC
115335: ST_TO_ADDR
115336: LD_EXP 148
115340: PUSH
115341: FOR_TO
115342: IFFALSE 115447
// begin tmp := 0 ;
115344: LD_ADDR_VAR 0 3
115348: PUSH
115349: LD_STRING 0
115351: ST_TO_ADDR
// if result [ 2 ] then
115352: LD_VAR 0 2
115356: PUSH
115357: LD_INT 2
115359: ARRAY
115360: IFFALSE 115429
// if result [ 2 ] [ 1 ] = 100 + i then
115362: LD_VAR 0 2
115366: PUSH
115367: LD_INT 2
115369: ARRAY
115370: PUSH
115371: LD_INT 1
115373: ARRAY
115374: PUSH
115375: LD_INT 100
115377: PUSH
115378: LD_VAR 0 8
115382: PLUS
115383: EQUAL
115384: IFFALSE 115429
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
115386: LD_ADDR_VAR 0 2
115390: PUSH
115391: LD_VAR 0 2
115395: PPUSH
115396: LD_INT 2
115398: PPUSH
115399: LD_VAR 0 2
115403: PUSH
115404: LD_INT 2
115406: ARRAY
115407: PPUSH
115408: LD_INT 1
115410: PPUSH
115411: CALL_OW 3
115415: PPUSH
115416: CALL_OW 1
115420: ST_TO_ADDR
// tmp := 1 ;
115421: LD_ADDR_VAR 0 3
115425: PUSH
115426: LD_STRING 1
115428: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
115429: LD_ADDR_VAR 0 6
115433: PUSH
115434: LD_VAR 0 6
115438: PUSH
115439: LD_VAR 0 3
115443: STR
115444: ST_TO_ADDR
// end ;
115445: GO 115341
115447: POP
115448: POP
// if isGameLoad then
115449: LD_VAR 0 1
115453: IFFALSE 115928
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
115455: LD_ADDR_VAR 0 4
115459: PUSH
115460: LD_EXP 151
115464: PUSH
115465: LD_EXP 150
115469: PUSH
115470: LD_EXP 152
115474: PUSH
115475: LD_EXP 149
115479: PUSH
115480: LD_EXP 153
115484: PUSH
115485: LD_EXP 154
115489: PUSH
115490: LD_EXP 155
115494: PUSH
115495: LD_EXP 156
115499: PUSH
115500: LD_EXP 157
115504: PUSH
115505: LD_EXP 158
115509: PUSH
115510: LD_EXP 159
115514: PUSH
115515: LD_EXP 160
115519: PUSH
115520: LD_EXP 161
115524: PUSH
115525: LD_EXP 162
115529: PUSH
115530: LD_EXP 170
115534: PUSH
115535: LD_EXP 171
115539: PUSH
115540: LD_EXP 172
115544: PUSH
115545: LD_EXP 173
115549: PUSH
115550: LD_EXP 175
115554: PUSH
115555: LD_EXP 176
115559: PUSH
115560: LD_EXP 177
115564: PUSH
115565: LD_EXP 180
115569: PUSH
115570: LD_EXP 182
115574: PUSH
115575: LD_EXP 183
115579: PUSH
115580: LD_EXP 184
115584: PUSH
115585: LD_EXP 186
115589: PUSH
115590: LD_EXP 187
115594: PUSH
115595: LD_EXP 190
115599: PUSH
115600: LD_EXP 191
115604: PUSH
115605: LD_EXP 192
115609: PUSH
115610: LD_EXP 193
115614: PUSH
115615: LD_EXP 194
115619: PUSH
115620: LD_EXP 195
115624: PUSH
115625: LD_EXP 196
115629: PUSH
115630: LD_EXP 197
115634: PUSH
115635: LD_EXP 198
115639: PUSH
115640: LD_EXP 163
115644: PUSH
115645: LD_EXP 164
115649: PUSH
115650: LD_EXP 167
115654: PUSH
115655: LD_EXP 168
115659: PUSH
115660: LD_EXP 169
115664: PUSH
115665: LD_EXP 165
115669: PUSH
115670: LD_EXP 166
115674: PUSH
115675: LD_EXP 174
115679: PUSH
115680: LD_EXP 178
115684: PUSH
115685: LD_EXP 179
115689: PUSH
115690: LD_EXP 181
115694: PUSH
115695: LD_EXP 185
115699: PUSH
115700: LD_EXP 188
115704: PUSH
115705: LD_EXP 189
115709: PUSH
115710: LD_EXP 199
115714: PUSH
115715: LD_EXP 200
115719: PUSH
115720: LD_EXP 201
115724: PUSH
115725: LD_EXP 202
115729: PUSH
115730: EMPTY
115731: LIST
115732: LIST
115733: LIST
115734: LIST
115735: LIST
115736: LIST
115737: LIST
115738: LIST
115739: LIST
115740: LIST
115741: LIST
115742: LIST
115743: LIST
115744: LIST
115745: LIST
115746: LIST
115747: LIST
115748: LIST
115749: LIST
115750: LIST
115751: LIST
115752: LIST
115753: LIST
115754: LIST
115755: LIST
115756: LIST
115757: LIST
115758: LIST
115759: LIST
115760: LIST
115761: LIST
115762: LIST
115763: LIST
115764: LIST
115765: LIST
115766: LIST
115767: LIST
115768: LIST
115769: LIST
115770: LIST
115771: LIST
115772: LIST
115773: LIST
115774: LIST
115775: LIST
115776: LIST
115777: LIST
115778: LIST
115779: LIST
115780: LIST
115781: LIST
115782: LIST
115783: LIST
115784: LIST
115785: ST_TO_ADDR
// tmp :=  ;
115786: LD_ADDR_VAR 0 3
115790: PUSH
115791: LD_STRING 
115793: ST_TO_ADDR
// for i = 1 to normalCounter do
115794: LD_ADDR_VAR 0 8
115798: PUSH
115799: DOUBLE
115800: LD_INT 1
115802: DEC
115803: ST_TO_ADDR
115804: LD_EXP 147
115808: PUSH
115809: FOR_TO
115810: IFFALSE 115846
// begin if flags [ i ] then
115812: LD_VAR 0 4
115816: PUSH
115817: LD_VAR 0 8
115821: ARRAY
115822: IFFALSE 115844
// tmp := tmp & i & ; ;
115824: LD_ADDR_VAR 0 3
115828: PUSH
115829: LD_VAR 0 3
115833: PUSH
115834: LD_VAR 0 8
115838: STR
115839: PUSH
115840: LD_STRING ;
115842: STR
115843: ST_TO_ADDR
// end ;
115844: GO 115809
115846: POP
115847: POP
// for i = 1 to hardcoreCounter do
115848: LD_ADDR_VAR 0 8
115852: PUSH
115853: DOUBLE
115854: LD_INT 1
115856: DEC
115857: ST_TO_ADDR
115858: LD_EXP 148
115862: PUSH
115863: FOR_TO
115864: IFFALSE 115910
// begin if flags [ normalCounter + i ] then
115866: LD_VAR 0 4
115870: PUSH
115871: LD_EXP 147
115875: PUSH
115876: LD_VAR 0 8
115880: PLUS
115881: ARRAY
115882: IFFALSE 115908
// tmp := tmp & ( 100 + i ) & ; ;
115884: LD_ADDR_VAR 0 3
115888: PUSH
115889: LD_VAR 0 3
115893: PUSH
115894: LD_INT 100
115896: PUSH
115897: LD_VAR 0 8
115901: PLUS
115902: STR
115903: PUSH
115904: LD_STRING ;
115906: STR
115907: ST_TO_ADDR
// end ;
115908: GO 115863
115910: POP
115911: POP
// if tmp then
115912: LD_VAR 0 3
115916: IFFALSE 115928
// active := tmp ;
115918: LD_ADDR_VAR 0 7
115922: PUSH
115923: LD_VAR 0 3
115927: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
115928: LD_STRING getStreamItemsFromMission("
115930: PUSH
115931: LD_VAR 0 5
115935: STR
115936: PUSH
115937: LD_STRING ","
115939: STR
115940: PUSH
115941: LD_VAR 0 6
115945: STR
115946: PUSH
115947: LD_STRING ","
115949: STR
115950: PUSH
115951: LD_VAR 0 7
115955: STR
115956: PUSH
115957: LD_STRING ")
115959: STR
115960: PPUSH
115961: CALL_OW 559
// end else
115965: GO 115974
// ToLua ( getStreamItemsFromMission("","","") ) ;
115967: LD_STRING getStreamItemsFromMission("","","")
115969: PPUSH
115970: CALL_OW 559
// end ;
115974: LD_VAR 0 2
115978: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
115979: LD_EXP 146
115983: PUSH
115984: LD_EXP 151
115988: AND
115989: IFFALSE 116113
115991: GO 115993
115993: DISABLE
115994: LD_INT 0
115996: PPUSH
115997: PPUSH
// begin enable ;
115998: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
115999: LD_ADDR_VAR 0 2
116003: PUSH
116004: LD_INT 22
116006: PUSH
116007: LD_OWVAR 2
116011: PUSH
116012: EMPTY
116013: LIST
116014: LIST
116015: PUSH
116016: LD_INT 2
116018: PUSH
116019: LD_INT 34
116021: PUSH
116022: LD_INT 7
116024: PUSH
116025: EMPTY
116026: LIST
116027: LIST
116028: PUSH
116029: LD_INT 34
116031: PUSH
116032: LD_INT 45
116034: PUSH
116035: EMPTY
116036: LIST
116037: LIST
116038: PUSH
116039: LD_INT 34
116041: PUSH
116042: LD_INT 28
116044: PUSH
116045: EMPTY
116046: LIST
116047: LIST
116048: PUSH
116049: LD_INT 34
116051: PUSH
116052: LD_INT 47
116054: PUSH
116055: EMPTY
116056: LIST
116057: LIST
116058: PUSH
116059: EMPTY
116060: LIST
116061: LIST
116062: LIST
116063: LIST
116064: LIST
116065: PUSH
116066: EMPTY
116067: LIST
116068: LIST
116069: PPUSH
116070: CALL_OW 69
116074: ST_TO_ADDR
// if not tmp then
116075: LD_VAR 0 2
116079: NOT
116080: IFFALSE 116084
// exit ;
116082: GO 116113
// for i in tmp do
116084: LD_ADDR_VAR 0 1
116088: PUSH
116089: LD_VAR 0 2
116093: PUSH
116094: FOR_IN
116095: IFFALSE 116111
// begin SetLives ( i , 0 ) ;
116097: LD_VAR 0 1
116101: PPUSH
116102: LD_INT 0
116104: PPUSH
116105: CALL_OW 234
// end ;
116109: GO 116094
116111: POP
116112: POP
// end ;
116113: PPOPN 2
116115: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
116116: LD_EXP 146
116120: PUSH
116121: LD_EXP 152
116125: AND
116126: IFFALSE 116210
116128: GO 116130
116130: DISABLE
116131: LD_INT 0
116133: PPUSH
116134: PPUSH
// begin enable ;
116135: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
116136: LD_ADDR_VAR 0 2
116140: PUSH
116141: LD_INT 22
116143: PUSH
116144: LD_OWVAR 2
116148: PUSH
116149: EMPTY
116150: LIST
116151: LIST
116152: PUSH
116153: LD_INT 32
116155: PUSH
116156: LD_INT 3
116158: PUSH
116159: EMPTY
116160: LIST
116161: LIST
116162: PUSH
116163: EMPTY
116164: LIST
116165: LIST
116166: PPUSH
116167: CALL_OW 69
116171: ST_TO_ADDR
// if not tmp then
116172: LD_VAR 0 2
116176: NOT
116177: IFFALSE 116181
// exit ;
116179: GO 116210
// for i in tmp do
116181: LD_ADDR_VAR 0 1
116185: PUSH
116186: LD_VAR 0 2
116190: PUSH
116191: FOR_IN
116192: IFFALSE 116208
// begin SetLives ( i , 0 ) ;
116194: LD_VAR 0 1
116198: PPUSH
116199: LD_INT 0
116201: PPUSH
116202: CALL_OW 234
// end ;
116206: GO 116191
116208: POP
116209: POP
// end ;
116210: PPOPN 2
116212: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
116213: LD_EXP 146
116217: PUSH
116218: LD_EXP 149
116222: AND
116223: IFFALSE 116316
116225: GO 116227
116227: DISABLE
116228: LD_INT 0
116230: PPUSH
// begin enable ;
116231: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
116232: LD_ADDR_VAR 0 1
116236: PUSH
116237: LD_INT 22
116239: PUSH
116240: LD_OWVAR 2
116244: PUSH
116245: EMPTY
116246: LIST
116247: LIST
116248: PUSH
116249: LD_INT 2
116251: PUSH
116252: LD_INT 25
116254: PUSH
116255: LD_INT 5
116257: PUSH
116258: EMPTY
116259: LIST
116260: LIST
116261: PUSH
116262: LD_INT 25
116264: PUSH
116265: LD_INT 9
116267: PUSH
116268: EMPTY
116269: LIST
116270: LIST
116271: PUSH
116272: LD_INT 25
116274: PUSH
116275: LD_INT 8
116277: PUSH
116278: EMPTY
116279: LIST
116280: LIST
116281: PUSH
116282: EMPTY
116283: LIST
116284: LIST
116285: LIST
116286: LIST
116287: PUSH
116288: EMPTY
116289: LIST
116290: LIST
116291: PPUSH
116292: CALL_OW 69
116296: PUSH
116297: FOR_IN
116298: IFFALSE 116314
// begin SetClass ( i , 1 ) ;
116300: LD_VAR 0 1
116304: PPUSH
116305: LD_INT 1
116307: PPUSH
116308: CALL_OW 336
// end ;
116312: GO 116297
116314: POP
116315: POP
// end ;
116316: PPOPN 1
116318: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
116319: LD_EXP 146
116323: PUSH
116324: LD_EXP 150
116328: AND
116329: PUSH
116330: LD_OWVAR 65
116334: PUSH
116335: LD_INT 7
116337: LESS
116338: AND
116339: IFFALSE 116353
116341: GO 116343
116343: DISABLE
// begin enable ;
116344: ENABLE
// game_speed := 7 ;
116345: LD_ADDR_OWVAR 65
116349: PUSH
116350: LD_INT 7
116352: ST_TO_ADDR
// end ;
116353: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
116354: LD_EXP 146
116358: PUSH
116359: LD_EXP 153
116363: AND
116364: IFFALSE 116566
116366: GO 116368
116368: DISABLE
116369: LD_INT 0
116371: PPUSH
116372: PPUSH
116373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
116374: LD_ADDR_VAR 0 3
116378: PUSH
116379: LD_INT 81
116381: PUSH
116382: LD_OWVAR 2
116386: PUSH
116387: EMPTY
116388: LIST
116389: LIST
116390: PUSH
116391: LD_INT 21
116393: PUSH
116394: LD_INT 1
116396: PUSH
116397: EMPTY
116398: LIST
116399: LIST
116400: PUSH
116401: EMPTY
116402: LIST
116403: LIST
116404: PPUSH
116405: CALL_OW 69
116409: ST_TO_ADDR
// if not tmp then
116410: LD_VAR 0 3
116414: NOT
116415: IFFALSE 116419
// exit ;
116417: GO 116566
// if tmp > 5 then
116419: LD_VAR 0 3
116423: PUSH
116424: LD_INT 5
116426: GREATER
116427: IFFALSE 116439
// k := 5 else
116429: LD_ADDR_VAR 0 2
116433: PUSH
116434: LD_INT 5
116436: ST_TO_ADDR
116437: GO 116449
// k := tmp ;
116439: LD_ADDR_VAR 0 2
116443: PUSH
116444: LD_VAR 0 3
116448: ST_TO_ADDR
// for i := 1 to k do
116449: LD_ADDR_VAR 0 1
116453: PUSH
116454: DOUBLE
116455: LD_INT 1
116457: DEC
116458: ST_TO_ADDR
116459: LD_VAR 0 2
116463: PUSH
116464: FOR_TO
116465: IFFALSE 116564
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
116467: LD_VAR 0 3
116471: PUSH
116472: LD_VAR 0 1
116476: ARRAY
116477: PPUSH
116478: LD_VAR 0 1
116482: PUSH
116483: LD_INT 4
116485: MOD
116486: PUSH
116487: LD_INT 1
116489: PLUS
116490: PPUSH
116491: CALL_OW 259
116495: PUSH
116496: LD_INT 10
116498: LESS
116499: IFFALSE 116562
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
116501: LD_VAR 0 3
116505: PUSH
116506: LD_VAR 0 1
116510: ARRAY
116511: PPUSH
116512: LD_VAR 0 1
116516: PUSH
116517: LD_INT 4
116519: MOD
116520: PUSH
116521: LD_INT 1
116523: PLUS
116524: PPUSH
116525: LD_VAR 0 3
116529: PUSH
116530: LD_VAR 0 1
116534: ARRAY
116535: PPUSH
116536: LD_VAR 0 1
116540: PUSH
116541: LD_INT 4
116543: MOD
116544: PUSH
116545: LD_INT 1
116547: PLUS
116548: PPUSH
116549: CALL_OW 259
116553: PUSH
116554: LD_INT 1
116556: PLUS
116557: PPUSH
116558: CALL_OW 237
116562: GO 116464
116564: POP
116565: POP
// end ;
116566: PPOPN 3
116568: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
116569: LD_EXP 146
116573: PUSH
116574: LD_EXP 154
116578: AND
116579: IFFALSE 116599
116581: GO 116583
116583: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
116584: LD_INT 4
116586: PPUSH
116587: LD_OWVAR 2
116591: PPUSH
116592: LD_INT 0
116594: PPUSH
116595: CALL_OW 324
116599: END
// every 0 0$1 trigger StreamModeActive and sShovel do
116600: LD_EXP 146
116604: PUSH
116605: LD_EXP 183
116609: AND
116610: IFFALSE 116630
116612: GO 116614
116614: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
116615: LD_INT 19
116617: PPUSH
116618: LD_OWVAR 2
116622: PPUSH
116623: LD_INT 0
116625: PPUSH
116626: CALL_OW 324
116630: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
116631: LD_EXP 146
116635: PUSH
116636: LD_EXP 155
116640: AND
116641: IFFALSE 116743
116643: GO 116645
116645: DISABLE
116646: LD_INT 0
116648: PPUSH
116649: PPUSH
// begin enable ;
116650: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
116651: LD_ADDR_VAR 0 2
116655: PUSH
116656: LD_INT 22
116658: PUSH
116659: LD_OWVAR 2
116663: PUSH
116664: EMPTY
116665: LIST
116666: LIST
116667: PUSH
116668: LD_INT 2
116670: PUSH
116671: LD_INT 34
116673: PUSH
116674: LD_INT 11
116676: PUSH
116677: EMPTY
116678: LIST
116679: LIST
116680: PUSH
116681: LD_INT 34
116683: PUSH
116684: LD_INT 30
116686: PUSH
116687: EMPTY
116688: LIST
116689: LIST
116690: PUSH
116691: EMPTY
116692: LIST
116693: LIST
116694: LIST
116695: PUSH
116696: EMPTY
116697: LIST
116698: LIST
116699: PPUSH
116700: CALL_OW 69
116704: ST_TO_ADDR
// if not tmp then
116705: LD_VAR 0 2
116709: NOT
116710: IFFALSE 116714
// exit ;
116712: GO 116743
// for i in tmp do
116714: LD_ADDR_VAR 0 1
116718: PUSH
116719: LD_VAR 0 2
116723: PUSH
116724: FOR_IN
116725: IFFALSE 116741
// begin SetLives ( i , 0 ) ;
116727: LD_VAR 0 1
116731: PPUSH
116732: LD_INT 0
116734: PPUSH
116735: CALL_OW 234
// end ;
116739: GO 116724
116741: POP
116742: POP
// end ;
116743: PPOPN 2
116745: END
// every 0 0$1 trigger StreamModeActive and sBunker do
116746: LD_EXP 146
116750: PUSH
116751: LD_EXP 156
116755: AND
116756: IFFALSE 116776
116758: GO 116760
116760: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
116761: LD_INT 32
116763: PPUSH
116764: LD_OWVAR 2
116768: PPUSH
116769: LD_INT 0
116771: PPUSH
116772: CALL_OW 324
116776: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
116777: LD_EXP 146
116781: PUSH
116782: LD_EXP 157
116786: AND
116787: IFFALSE 116968
116789: GO 116791
116791: DISABLE
116792: LD_INT 0
116794: PPUSH
116795: PPUSH
116796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
116797: LD_ADDR_VAR 0 2
116801: PUSH
116802: LD_INT 22
116804: PUSH
116805: LD_OWVAR 2
116809: PUSH
116810: EMPTY
116811: LIST
116812: LIST
116813: PUSH
116814: LD_INT 33
116816: PUSH
116817: LD_INT 3
116819: PUSH
116820: EMPTY
116821: LIST
116822: LIST
116823: PUSH
116824: EMPTY
116825: LIST
116826: LIST
116827: PPUSH
116828: CALL_OW 69
116832: ST_TO_ADDR
// if not tmp then
116833: LD_VAR 0 2
116837: NOT
116838: IFFALSE 116842
// exit ;
116840: GO 116968
// side := 0 ;
116842: LD_ADDR_VAR 0 3
116846: PUSH
116847: LD_INT 0
116849: ST_TO_ADDR
// for i := 1 to 8 do
116850: LD_ADDR_VAR 0 1
116854: PUSH
116855: DOUBLE
116856: LD_INT 1
116858: DEC
116859: ST_TO_ADDR
116860: LD_INT 8
116862: PUSH
116863: FOR_TO
116864: IFFALSE 116912
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
116866: LD_OWVAR 2
116870: PUSH
116871: LD_VAR 0 1
116875: NONEQUAL
116876: PUSH
116877: LD_OWVAR 2
116881: PPUSH
116882: LD_VAR 0 1
116886: PPUSH
116887: CALL_OW 81
116891: PUSH
116892: LD_INT 2
116894: EQUAL
116895: AND
116896: IFFALSE 116910
// begin side := i ;
116898: LD_ADDR_VAR 0 3
116902: PUSH
116903: LD_VAR 0 1
116907: ST_TO_ADDR
// break ;
116908: GO 116912
// end ;
116910: GO 116863
116912: POP
116913: POP
// if not side then
116914: LD_VAR 0 3
116918: NOT
116919: IFFALSE 116923
// exit ;
116921: GO 116968
// for i := 1 to tmp do
116923: LD_ADDR_VAR 0 1
116927: PUSH
116928: DOUBLE
116929: LD_INT 1
116931: DEC
116932: ST_TO_ADDR
116933: LD_VAR 0 2
116937: PUSH
116938: FOR_TO
116939: IFFALSE 116966
// if Prob ( 60 ) then
116941: LD_INT 60
116943: PPUSH
116944: CALL_OW 13
116948: IFFALSE 116964
// SetSide ( i , side ) ;
116950: LD_VAR 0 1
116954: PPUSH
116955: LD_VAR 0 3
116959: PPUSH
116960: CALL_OW 235
116964: GO 116938
116966: POP
116967: POP
// end ;
116968: PPOPN 3
116970: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
116971: LD_EXP 146
116975: PUSH
116976: LD_EXP 159
116980: AND
116981: IFFALSE 117100
116983: GO 116985
116985: DISABLE
116986: LD_INT 0
116988: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
116989: LD_ADDR_VAR 0 1
116993: PUSH
116994: LD_INT 22
116996: PUSH
116997: LD_OWVAR 2
117001: PUSH
117002: EMPTY
117003: LIST
117004: LIST
117005: PUSH
117006: LD_INT 21
117008: PUSH
117009: LD_INT 1
117011: PUSH
117012: EMPTY
117013: LIST
117014: LIST
117015: PUSH
117016: LD_INT 3
117018: PUSH
117019: LD_INT 23
117021: PUSH
117022: LD_INT 0
117024: PUSH
117025: EMPTY
117026: LIST
117027: LIST
117028: PUSH
117029: EMPTY
117030: LIST
117031: LIST
117032: PUSH
117033: EMPTY
117034: LIST
117035: LIST
117036: LIST
117037: PPUSH
117038: CALL_OW 69
117042: PUSH
117043: FOR_IN
117044: IFFALSE 117098
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
117046: LD_VAR 0 1
117050: PPUSH
117051: CALL_OW 257
117055: PUSH
117056: LD_INT 1
117058: PUSH
117059: LD_INT 2
117061: PUSH
117062: LD_INT 3
117064: PUSH
117065: LD_INT 4
117067: PUSH
117068: EMPTY
117069: LIST
117070: LIST
117071: LIST
117072: LIST
117073: IN
117074: IFFALSE 117096
// SetClass ( un , rand ( 1 , 4 ) ) ;
117076: LD_VAR 0 1
117080: PPUSH
117081: LD_INT 1
117083: PPUSH
117084: LD_INT 4
117086: PPUSH
117087: CALL_OW 12
117091: PPUSH
117092: CALL_OW 336
117096: GO 117043
117098: POP
117099: POP
// end ;
117100: PPOPN 1
117102: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
117103: LD_EXP 146
117107: PUSH
117108: LD_EXP 158
117112: AND
117113: IFFALSE 117192
117115: GO 117117
117117: DISABLE
117118: LD_INT 0
117120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117121: LD_ADDR_VAR 0 1
117125: PUSH
117126: LD_INT 22
117128: PUSH
117129: LD_OWVAR 2
117133: PUSH
117134: EMPTY
117135: LIST
117136: LIST
117137: PUSH
117138: LD_INT 21
117140: PUSH
117141: LD_INT 3
117143: PUSH
117144: EMPTY
117145: LIST
117146: LIST
117147: PUSH
117148: EMPTY
117149: LIST
117150: LIST
117151: PPUSH
117152: CALL_OW 69
117156: ST_TO_ADDR
// if not tmp then
117157: LD_VAR 0 1
117161: NOT
117162: IFFALSE 117166
// exit ;
117164: GO 117192
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
117166: LD_VAR 0 1
117170: PUSH
117171: LD_INT 1
117173: PPUSH
117174: LD_VAR 0 1
117178: PPUSH
117179: CALL_OW 12
117183: ARRAY
117184: PPUSH
117185: LD_INT 100
117187: PPUSH
117188: CALL_OW 234
// end ;
117192: PPOPN 1
117194: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
117195: LD_EXP 146
117199: PUSH
117200: LD_EXP 160
117204: AND
117205: IFFALSE 117303
117207: GO 117209
117209: DISABLE
117210: LD_INT 0
117212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117213: LD_ADDR_VAR 0 1
117217: PUSH
117218: LD_INT 22
117220: PUSH
117221: LD_OWVAR 2
117225: PUSH
117226: EMPTY
117227: LIST
117228: LIST
117229: PUSH
117230: LD_INT 21
117232: PUSH
117233: LD_INT 1
117235: PUSH
117236: EMPTY
117237: LIST
117238: LIST
117239: PUSH
117240: EMPTY
117241: LIST
117242: LIST
117243: PPUSH
117244: CALL_OW 69
117248: ST_TO_ADDR
// if not tmp then
117249: LD_VAR 0 1
117253: NOT
117254: IFFALSE 117258
// exit ;
117256: GO 117303
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
117258: LD_VAR 0 1
117262: PUSH
117263: LD_INT 1
117265: PPUSH
117266: LD_VAR 0 1
117270: PPUSH
117271: CALL_OW 12
117275: ARRAY
117276: PPUSH
117277: LD_INT 1
117279: PPUSH
117280: LD_INT 4
117282: PPUSH
117283: CALL_OW 12
117287: PPUSH
117288: LD_INT 3000
117290: PPUSH
117291: LD_INT 9000
117293: PPUSH
117294: CALL_OW 12
117298: PPUSH
117299: CALL_OW 492
// end ;
117303: PPOPN 1
117305: END
// every 0 0$1 trigger StreamModeActive and sDepot do
117306: LD_EXP 146
117310: PUSH
117311: LD_EXP 161
117315: AND
117316: IFFALSE 117336
117318: GO 117320
117320: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
117321: LD_INT 1
117323: PPUSH
117324: LD_OWVAR 2
117328: PPUSH
117329: LD_INT 0
117331: PPUSH
117332: CALL_OW 324
117336: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
117337: LD_EXP 146
117341: PUSH
117342: LD_EXP 162
117346: AND
117347: IFFALSE 117430
117349: GO 117351
117351: DISABLE
117352: LD_INT 0
117354: PPUSH
117355: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117356: LD_ADDR_VAR 0 2
117360: PUSH
117361: LD_INT 22
117363: PUSH
117364: LD_OWVAR 2
117368: PUSH
117369: EMPTY
117370: LIST
117371: LIST
117372: PUSH
117373: LD_INT 21
117375: PUSH
117376: LD_INT 3
117378: PUSH
117379: EMPTY
117380: LIST
117381: LIST
117382: PUSH
117383: EMPTY
117384: LIST
117385: LIST
117386: PPUSH
117387: CALL_OW 69
117391: ST_TO_ADDR
// if not tmp then
117392: LD_VAR 0 2
117396: NOT
117397: IFFALSE 117401
// exit ;
117399: GO 117430
// for i in tmp do
117401: LD_ADDR_VAR 0 1
117405: PUSH
117406: LD_VAR 0 2
117410: PUSH
117411: FOR_IN
117412: IFFALSE 117428
// SetBLevel ( i , 10 ) ;
117414: LD_VAR 0 1
117418: PPUSH
117419: LD_INT 10
117421: PPUSH
117422: CALL_OW 241
117426: GO 117411
117428: POP
117429: POP
// end ;
117430: PPOPN 2
117432: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
117433: LD_EXP 146
117437: PUSH
117438: LD_EXP 163
117442: AND
117443: IFFALSE 117554
117445: GO 117447
117447: DISABLE
117448: LD_INT 0
117450: PPUSH
117451: PPUSH
117452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117453: LD_ADDR_VAR 0 3
117457: PUSH
117458: LD_INT 22
117460: PUSH
117461: LD_OWVAR 2
117465: PUSH
117466: EMPTY
117467: LIST
117468: LIST
117469: PUSH
117470: LD_INT 25
117472: PUSH
117473: LD_INT 1
117475: PUSH
117476: EMPTY
117477: LIST
117478: LIST
117479: PUSH
117480: EMPTY
117481: LIST
117482: LIST
117483: PPUSH
117484: CALL_OW 69
117488: ST_TO_ADDR
// if not tmp then
117489: LD_VAR 0 3
117493: NOT
117494: IFFALSE 117498
// exit ;
117496: GO 117554
// un := tmp [ rand ( 1 , tmp ) ] ;
117498: LD_ADDR_VAR 0 2
117502: PUSH
117503: LD_VAR 0 3
117507: PUSH
117508: LD_INT 1
117510: PPUSH
117511: LD_VAR 0 3
117515: PPUSH
117516: CALL_OW 12
117520: ARRAY
117521: ST_TO_ADDR
// if Crawls ( un ) then
117522: LD_VAR 0 2
117526: PPUSH
117527: CALL_OW 318
117531: IFFALSE 117542
// ComWalk ( un ) ;
117533: LD_VAR 0 2
117537: PPUSH
117538: CALL_OW 138
// SetClass ( un , class_sniper ) ;
117542: LD_VAR 0 2
117546: PPUSH
117547: LD_INT 5
117549: PPUSH
117550: CALL_OW 336
// end ;
117554: PPOPN 3
117556: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
117557: LD_EXP 146
117561: PUSH
117562: LD_EXP 164
117566: AND
117567: PUSH
117568: LD_OWVAR 67
117572: PUSH
117573: LD_INT 4
117575: LESS
117576: AND
117577: IFFALSE 117596
117579: GO 117581
117581: DISABLE
// begin Difficulty := Difficulty + 1 ;
117582: LD_ADDR_OWVAR 67
117586: PUSH
117587: LD_OWVAR 67
117591: PUSH
117592: LD_INT 1
117594: PLUS
117595: ST_TO_ADDR
// end ;
117596: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
117597: LD_EXP 146
117601: PUSH
117602: LD_EXP 165
117606: AND
117607: IFFALSE 117710
117609: GO 117611
117611: DISABLE
117612: LD_INT 0
117614: PPUSH
// begin for i := 1 to 5 do
117615: LD_ADDR_VAR 0 1
117619: PUSH
117620: DOUBLE
117621: LD_INT 1
117623: DEC
117624: ST_TO_ADDR
117625: LD_INT 5
117627: PUSH
117628: FOR_TO
117629: IFFALSE 117708
// begin uc_nation := nation_nature ;
117631: LD_ADDR_OWVAR 21
117635: PUSH
117636: LD_INT 0
117638: ST_TO_ADDR
// uc_side := 0 ;
117639: LD_ADDR_OWVAR 20
117643: PUSH
117644: LD_INT 0
117646: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117647: LD_ADDR_OWVAR 29
117651: PUSH
117652: LD_INT 12
117654: PUSH
117655: LD_INT 12
117657: PUSH
117658: EMPTY
117659: LIST
117660: LIST
117661: ST_TO_ADDR
// hc_agressivity := 20 ;
117662: LD_ADDR_OWVAR 35
117666: PUSH
117667: LD_INT 20
117669: ST_TO_ADDR
// hc_class := class_tiger ;
117670: LD_ADDR_OWVAR 28
117674: PUSH
117675: LD_INT 14
117677: ST_TO_ADDR
// hc_gallery :=  ;
117678: LD_ADDR_OWVAR 33
117682: PUSH
117683: LD_STRING 
117685: ST_TO_ADDR
// hc_name :=  ;
117686: LD_ADDR_OWVAR 26
117690: PUSH
117691: LD_STRING 
117693: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
117694: CALL_OW 44
117698: PPUSH
117699: LD_INT 0
117701: PPUSH
117702: CALL_OW 51
// end ;
117706: GO 117628
117708: POP
117709: POP
// end ;
117710: PPOPN 1
117712: END
// every 0 0$1 trigger StreamModeActive and sBomb do
117713: LD_EXP 146
117717: PUSH
117718: LD_EXP 166
117722: AND
117723: IFFALSE 117732
117725: GO 117727
117727: DISABLE
// StreamSibBomb ;
117728: CALL 117733 0 0
117732: END
// export function StreamSibBomb ; var i , x , y ; begin
117733: LD_INT 0
117735: PPUSH
117736: PPUSH
117737: PPUSH
117738: PPUSH
// result := false ;
117739: LD_ADDR_VAR 0 1
117743: PUSH
117744: LD_INT 0
117746: ST_TO_ADDR
// for i := 1 to 16 do
117747: LD_ADDR_VAR 0 2
117751: PUSH
117752: DOUBLE
117753: LD_INT 1
117755: DEC
117756: ST_TO_ADDR
117757: LD_INT 16
117759: PUSH
117760: FOR_TO
117761: IFFALSE 117960
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
117763: LD_ADDR_VAR 0 3
117767: PUSH
117768: LD_INT 10
117770: PUSH
117771: LD_INT 20
117773: PUSH
117774: LD_INT 30
117776: PUSH
117777: LD_INT 40
117779: PUSH
117780: LD_INT 50
117782: PUSH
117783: LD_INT 60
117785: PUSH
117786: LD_INT 70
117788: PUSH
117789: LD_INT 80
117791: PUSH
117792: LD_INT 90
117794: PUSH
117795: LD_INT 100
117797: PUSH
117798: LD_INT 110
117800: PUSH
117801: LD_INT 120
117803: PUSH
117804: LD_INT 130
117806: PUSH
117807: LD_INT 140
117809: PUSH
117810: LD_INT 150
117812: PUSH
117813: EMPTY
117814: LIST
117815: LIST
117816: LIST
117817: LIST
117818: LIST
117819: LIST
117820: LIST
117821: LIST
117822: LIST
117823: LIST
117824: LIST
117825: LIST
117826: LIST
117827: LIST
117828: LIST
117829: PUSH
117830: LD_INT 1
117832: PPUSH
117833: LD_INT 15
117835: PPUSH
117836: CALL_OW 12
117840: ARRAY
117841: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
117842: LD_ADDR_VAR 0 4
117846: PUSH
117847: LD_INT 10
117849: PUSH
117850: LD_INT 20
117852: PUSH
117853: LD_INT 30
117855: PUSH
117856: LD_INT 40
117858: PUSH
117859: LD_INT 50
117861: PUSH
117862: LD_INT 60
117864: PUSH
117865: LD_INT 70
117867: PUSH
117868: LD_INT 80
117870: PUSH
117871: LD_INT 90
117873: PUSH
117874: LD_INT 100
117876: PUSH
117877: LD_INT 110
117879: PUSH
117880: LD_INT 120
117882: PUSH
117883: LD_INT 130
117885: PUSH
117886: LD_INT 140
117888: PUSH
117889: LD_INT 150
117891: PUSH
117892: EMPTY
117893: LIST
117894: LIST
117895: LIST
117896: LIST
117897: LIST
117898: LIST
117899: LIST
117900: LIST
117901: LIST
117902: LIST
117903: LIST
117904: LIST
117905: LIST
117906: LIST
117907: LIST
117908: PUSH
117909: LD_INT 1
117911: PPUSH
117912: LD_INT 15
117914: PPUSH
117915: CALL_OW 12
117919: ARRAY
117920: ST_TO_ADDR
// if ValidHex ( x , y ) then
117921: LD_VAR 0 3
117925: PPUSH
117926: LD_VAR 0 4
117930: PPUSH
117931: CALL_OW 488
117935: IFFALSE 117958
// begin result := [ x , y ] ;
117937: LD_ADDR_VAR 0 1
117941: PUSH
117942: LD_VAR 0 3
117946: PUSH
117947: LD_VAR 0 4
117951: PUSH
117952: EMPTY
117953: LIST
117954: LIST
117955: ST_TO_ADDR
// break ;
117956: GO 117960
// end ; end ;
117958: GO 117760
117960: POP
117961: POP
// if result then
117962: LD_VAR 0 1
117966: IFFALSE 118026
// begin ToLua ( playSibBomb() ) ;
117968: LD_STRING playSibBomb()
117970: PPUSH
117971: CALL_OW 559
// wait ( 0 0$14 ) ;
117975: LD_INT 490
117977: PPUSH
117978: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
117982: LD_VAR 0 1
117986: PUSH
117987: LD_INT 1
117989: ARRAY
117990: PPUSH
117991: LD_VAR 0 1
117995: PUSH
117996: LD_INT 2
117998: ARRAY
117999: PPUSH
118000: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
118004: LD_VAR 0 1
118008: PUSH
118009: LD_INT 1
118011: ARRAY
118012: PPUSH
118013: LD_VAR 0 1
118017: PUSH
118018: LD_INT 2
118020: ARRAY
118021: PPUSH
118022: CALL_OW 429
// end ; end ;
118026: LD_VAR 0 1
118030: RET
// every 0 0$1 trigger StreamModeActive and sReset do
118031: LD_EXP 146
118035: PUSH
118036: LD_EXP 168
118040: AND
118041: IFFALSE 118053
118043: GO 118045
118045: DISABLE
// YouLost (  ) ;
118046: LD_STRING 
118048: PPUSH
118049: CALL_OW 104
118053: END
// every 0 0$1 trigger StreamModeActive and sFog do
118054: LD_EXP 146
118058: PUSH
118059: LD_EXP 167
118063: AND
118064: IFFALSE 118078
118066: GO 118068
118068: DISABLE
// FogOff ( your_side ) ;
118069: LD_OWVAR 2
118073: PPUSH
118074: CALL_OW 344
118078: END
// every 0 0$1 trigger StreamModeActive and sSun do
118079: LD_EXP 146
118083: PUSH
118084: LD_EXP 169
118088: AND
118089: IFFALSE 118117
118091: GO 118093
118093: DISABLE
// begin solar_recharge_percent := 0 ;
118094: LD_ADDR_OWVAR 79
118098: PUSH
118099: LD_INT 0
118101: ST_TO_ADDR
// wait ( 5 5$00 ) ;
118102: LD_INT 10500
118104: PPUSH
118105: CALL_OW 67
// solar_recharge_percent := 100 ;
118109: LD_ADDR_OWVAR 79
118113: PUSH
118114: LD_INT 100
118116: ST_TO_ADDR
// end ;
118117: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
118118: LD_EXP 146
118122: PUSH
118123: LD_EXP 170
118127: AND
118128: IFFALSE 118367
118130: GO 118132
118132: DISABLE
118133: LD_INT 0
118135: PPUSH
118136: PPUSH
118137: PPUSH
// begin tmp := [ ] ;
118138: LD_ADDR_VAR 0 3
118142: PUSH
118143: EMPTY
118144: ST_TO_ADDR
// for i := 1 to 6 do
118145: LD_ADDR_VAR 0 1
118149: PUSH
118150: DOUBLE
118151: LD_INT 1
118153: DEC
118154: ST_TO_ADDR
118155: LD_INT 6
118157: PUSH
118158: FOR_TO
118159: IFFALSE 118264
// begin uc_nation := nation_nature ;
118161: LD_ADDR_OWVAR 21
118165: PUSH
118166: LD_INT 0
118168: ST_TO_ADDR
// uc_side := 0 ;
118169: LD_ADDR_OWVAR 20
118173: PUSH
118174: LD_INT 0
118176: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
118177: LD_ADDR_OWVAR 29
118181: PUSH
118182: LD_INT 12
118184: PUSH
118185: LD_INT 12
118187: PUSH
118188: EMPTY
118189: LIST
118190: LIST
118191: ST_TO_ADDR
// hc_agressivity := 20 ;
118192: LD_ADDR_OWVAR 35
118196: PUSH
118197: LD_INT 20
118199: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
118200: LD_ADDR_OWVAR 28
118204: PUSH
118205: LD_INT 17
118207: ST_TO_ADDR
// hc_gallery :=  ;
118208: LD_ADDR_OWVAR 33
118212: PUSH
118213: LD_STRING 
118215: ST_TO_ADDR
// hc_name :=  ;
118216: LD_ADDR_OWVAR 26
118220: PUSH
118221: LD_STRING 
118223: ST_TO_ADDR
// un := CreateHuman ;
118224: LD_ADDR_VAR 0 2
118228: PUSH
118229: CALL_OW 44
118233: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
118234: LD_VAR 0 2
118238: PPUSH
118239: LD_INT 1
118241: PPUSH
118242: CALL_OW 51
// tmp := tmp ^ un ;
118246: LD_ADDR_VAR 0 3
118250: PUSH
118251: LD_VAR 0 3
118255: PUSH
118256: LD_VAR 0 2
118260: ADD
118261: ST_TO_ADDR
// end ;
118262: GO 118158
118264: POP
118265: POP
// repeat wait ( 0 0$1 ) ;
118266: LD_INT 35
118268: PPUSH
118269: CALL_OW 67
// for un in tmp do
118273: LD_ADDR_VAR 0 2
118277: PUSH
118278: LD_VAR 0 3
118282: PUSH
118283: FOR_IN
118284: IFFALSE 118358
// begin if IsDead ( un ) then
118286: LD_VAR 0 2
118290: PPUSH
118291: CALL_OW 301
118295: IFFALSE 118315
// begin tmp := tmp diff un ;
118297: LD_ADDR_VAR 0 3
118301: PUSH
118302: LD_VAR 0 3
118306: PUSH
118307: LD_VAR 0 2
118311: DIFF
118312: ST_TO_ADDR
// continue ;
118313: GO 118283
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
118315: LD_VAR 0 2
118319: PPUSH
118320: LD_INT 3
118322: PUSH
118323: LD_INT 22
118325: PUSH
118326: LD_INT 0
118328: PUSH
118329: EMPTY
118330: LIST
118331: LIST
118332: PUSH
118333: EMPTY
118334: LIST
118335: LIST
118336: PPUSH
118337: CALL_OW 69
118341: PPUSH
118342: LD_VAR 0 2
118346: PPUSH
118347: CALL_OW 74
118351: PPUSH
118352: CALL_OW 115
// end ;
118356: GO 118283
118358: POP
118359: POP
// until not tmp ;
118360: LD_VAR 0 3
118364: NOT
118365: IFFALSE 118266
// end ;
118367: PPOPN 3
118369: END
// every 0 0$1 trigger StreamModeActive and sTroll do
118370: LD_EXP 146
118374: PUSH
118375: LD_EXP 171
118379: AND
118380: IFFALSE 118434
118382: GO 118384
118384: DISABLE
// begin ToLua ( displayTroll(); ) ;
118385: LD_STRING displayTroll();
118387: PPUSH
118388: CALL_OW 559
// wait ( 3 3$00 ) ;
118392: LD_INT 6300
118394: PPUSH
118395: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118399: LD_STRING hideTroll();
118401: PPUSH
118402: CALL_OW 559
// wait ( 1 1$00 ) ;
118406: LD_INT 2100
118408: PPUSH
118409: CALL_OW 67
// ToLua ( displayTroll(); ) ;
118413: LD_STRING displayTroll();
118415: PPUSH
118416: CALL_OW 559
// wait ( 1 1$00 ) ;
118420: LD_INT 2100
118422: PPUSH
118423: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118427: LD_STRING hideTroll();
118429: PPUSH
118430: CALL_OW 559
// end ;
118434: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
118435: LD_EXP 146
118439: PUSH
118440: LD_EXP 172
118444: AND
118445: IFFALSE 118508
118447: GO 118449
118449: DISABLE
118450: LD_INT 0
118452: PPUSH
// begin p := 0 ;
118453: LD_ADDR_VAR 0 1
118457: PUSH
118458: LD_INT 0
118460: ST_TO_ADDR
// repeat game_speed := 1 ;
118461: LD_ADDR_OWVAR 65
118465: PUSH
118466: LD_INT 1
118468: ST_TO_ADDR
// wait ( 0 0$1 ) ;
118469: LD_INT 35
118471: PPUSH
118472: CALL_OW 67
// p := p + 1 ;
118476: LD_ADDR_VAR 0 1
118480: PUSH
118481: LD_VAR 0 1
118485: PUSH
118486: LD_INT 1
118488: PLUS
118489: ST_TO_ADDR
// until p >= 60 ;
118490: LD_VAR 0 1
118494: PUSH
118495: LD_INT 60
118497: GREATEREQUAL
118498: IFFALSE 118461
// game_speed := 4 ;
118500: LD_ADDR_OWVAR 65
118504: PUSH
118505: LD_INT 4
118507: ST_TO_ADDR
// end ;
118508: PPOPN 1
118510: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
118511: LD_EXP 146
118515: PUSH
118516: LD_EXP 173
118520: AND
118521: IFFALSE 118667
118523: GO 118525
118525: DISABLE
118526: LD_INT 0
118528: PPUSH
118529: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118530: LD_ADDR_VAR 0 1
118534: PUSH
118535: LD_INT 22
118537: PUSH
118538: LD_OWVAR 2
118542: PUSH
118543: EMPTY
118544: LIST
118545: LIST
118546: PUSH
118547: LD_INT 2
118549: PUSH
118550: LD_INT 30
118552: PUSH
118553: LD_INT 0
118555: PUSH
118556: EMPTY
118557: LIST
118558: LIST
118559: PUSH
118560: LD_INT 30
118562: PUSH
118563: LD_INT 1
118565: PUSH
118566: EMPTY
118567: LIST
118568: LIST
118569: PUSH
118570: EMPTY
118571: LIST
118572: LIST
118573: LIST
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PPUSH
118579: CALL_OW 69
118583: ST_TO_ADDR
// if not depot then
118584: LD_VAR 0 1
118588: NOT
118589: IFFALSE 118593
// exit ;
118591: GO 118667
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
118593: LD_ADDR_VAR 0 2
118597: PUSH
118598: LD_VAR 0 1
118602: PUSH
118603: LD_INT 1
118605: PPUSH
118606: LD_VAR 0 1
118610: PPUSH
118611: CALL_OW 12
118615: ARRAY
118616: PPUSH
118617: CALL_OW 274
118621: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
118622: LD_VAR 0 2
118626: PPUSH
118627: LD_INT 1
118629: PPUSH
118630: LD_INT 0
118632: PPUSH
118633: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
118637: LD_VAR 0 2
118641: PPUSH
118642: LD_INT 2
118644: PPUSH
118645: LD_INT 0
118647: PPUSH
118648: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
118652: LD_VAR 0 2
118656: PPUSH
118657: LD_INT 3
118659: PPUSH
118660: LD_INT 0
118662: PPUSH
118663: CALL_OW 277
// end ;
118667: PPOPN 2
118669: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
118670: LD_EXP 146
118674: PUSH
118675: LD_EXP 174
118679: AND
118680: IFFALSE 118777
118682: GO 118684
118684: DISABLE
118685: LD_INT 0
118687: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118688: LD_ADDR_VAR 0 1
118692: PUSH
118693: LD_INT 22
118695: PUSH
118696: LD_OWVAR 2
118700: PUSH
118701: EMPTY
118702: LIST
118703: LIST
118704: PUSH
118705: LD_INT 21
118707: PUSH
118708: LD_INT 1
118710: PUSH
118711: EMPTY
118712: LIST
118713: LIST
118714: PUSH
118715: LD_INT 3
118717: PUSH
118718: LD_INT 23
118720: PUSH
118721: LD_INT 0
118723: PUSH
118724: EMPTY
118725: LIST
118726: LIST
118727: PUSH
118728: EMPTY
118729: LIST
118730: LIST
118731: PUSH
118732: EMPTY
118733: LIST
118734: LIST
118735: LIST
118736: PPUSH
118737: CALL_OW 69
118741: ST_TO_ADDR
// if not tmp then
118742: LD_VAR 0 1
118746: NOT
118747: IFFALSE 118751
// exit ;
118749: GO 118777
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
118751: LD_VAR 0 1
118755: PUSH
118756: LD_INT 1
118758: PPUSH
118759: LD_VAR 0 1
118763: PPUSH
118764: CALL_OW 12
118768: ARRAY
118769: PPUSH
118770: LD_INT 200
118772: PPUSH
118773: CALL_OW 234
// end ;
118777: PPOPN 1
118779: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
118780: LD_EXP 146
118784: PUSH
118785: LD_EXP 175
118789: AND
118790: IFFALSE 118869
118792: GO 118794
118794: DISABLE
118795: LD_INT 0
118797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
118798: LD_ADDR_VAR 0 1
118802: PUSH
118803: LD_INT 22
118805: PUSH
118806: LD_OWVAR 2
118810: PUSH
118811: EMPTY
118812: LIST
118813: LIST
118814: PUSH
118815: LD_INT 21
118817: PUSH
118818: LD_INT 2
118820: PUSH
118821: EMPTY
118822: LIST
118823: LIST
118824: PUSH
118825: EMPTY
118826: LIST
118827: LIST
118828: PPUSH
118829: CALL_OW 69
118833: ST_TO_ADDR
// if not tmp then
118834: LD_VAR 0 1
118838: NOT
118839: IFFALSE 118843
// exit ;
118841: GO 118869
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
118843: LD_VAR 0 1
118847: PUSH
118848: LD_INT 1
118850: PPUSH
118851: LD_VAR 0 1
118855: PPUSH
118856: CALL_OW 12
118860: ARRAY
118861: PPUSH
118862: LD_INT 60
118864: PPUSH
118865: CALL_OW 234
// end ;
118869: PPOPN 1
118871: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
118872: LD_EXP 146
118876: PUSH
118877: LD_EXP 176
118881: AND
118882: IFFALSE 118981
118884: GO 118886
118886: DISABLE
118887: LD_INT 0
118889: PPUSH
118890: PPUSH
// begin enable ;
118891: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
118892: LD_ADDR_VAR 0 1
118896: PUSH
118897: LD_INT 22
118899: PUSH
118900: LD_OWVAR 2
118904: PUSH
118905: EMPTY
118906: LIST
118907: LIST
118908: PUSH
118909: LD_INT 61
118911: PUSH
118912: EMPTY
118913: LIST
118914: PUSH
118915: LD_INT 33
118917: PUSH
118918: LD_INT 2
118920: PUSH
118921: EMPTY
118922: LIST
118923: LIST
118924: PUSH
118925: EMPTY
118926: LIST
118927: LIST
118928: LIST
118929: PPUSH
118930: CALL_OW 69
118934: ST_TO_ADDR
// if not tmp then
118935: LD_VAR 0 1
118939: NOT
118940: IFFALSE 118944
// exit ;
118942: GO 118981
// for i in tmp do
118944: LD_ADDR_VAR 0 2
118948: PUSH
118949: LD_VAR 0 1
118953: PUSH
118954: FOR_IN
118955: IFFALSE 118979
// if IsControledBy ( i ) then
118957: LD_VAR 0 2
118961: PPUSH
118962: CALL_OW 312
118966: IFFALSE 118977
// ComUnlink ( i ) ;
118968: LD_VAR 0 2
118972: PPUSH
118973: CALL_OW 136
118977: GO 118954
118979: POP
118980: POP
// end ;
118981: PPOPN 2
118983: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
118984: LD_EXP 146
118988: PUSH
118989: LD_EXP 177
118993: AND
118994: IFFALSE 119134
118996: GO 118998
118998: DISABLE
118999: LD_INT 0
119001: PPUSH
119002: PPUSH
// begin ToLua ( displayPowell(); ) ;
119003: LD_STRING displayPowell();
119005: PPUSH
119006: CALL_OW 559
// uc_side := 0 ;
119010: LD_ADDR_OWVAR 20
119014: PUSH
119015: LD_INT 0
119017: ST_TO_ADDR
// uc_nation := 2 ;
119018: LD_ADDR_OWVAR 21
119022: PUSH
119023: LD_INT 2
119025: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
119026: LD_ADDR_OWVAR 37
119030: PUSH
119031: LD_INT 14
119033: ST_TO_ADDR
// vc_engine := engine_siberite ;
119034: LD_ADDR_OWVAR 39
119038: PUSH
119039: LD_INT 3
119041: ST_TO_ADDR
// vc_control := control_apeman ;
119042: LD_ADDR_OWVAR 38
119046: PUSH
119047: LD_INT 5
119049: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
119050: LD_ADDR_OWVAR 40
119054: PUSH
119055: LD_INT 29
119057: ST_TO_ADDR
// un := CreateVehicle ;
119058: LD_ADDR_VAR 0 2
119062: PUSH
119063: CALL_OW 45
119067: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119068: LD_VAR 0 2
119072: PPUSH
119073: LD_INT 1
119075: PPUSH
119076: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119080: LD_INT 35
119082: PPUSH
119083: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119087: LD_VAR 0 2
119091: PPUSH
119092: LD_INT 22
119094: PUSH
119095: LD_OWVAR 2
119099: PUSH
119100: EMPTY
119101: LIST
119102: LIST
119103: PPUSH
119104: CALL_OW 69
119108: PPUSH
119109: LD_VAR 0 2
119113: PPUSH
119114: CALL_OW 74
119118: PPUSH
119119: CALL_OW 115
// until IsDead ( un ) ;
119123: LD_VAR 0 2
119127: PPUSH
119128: CALL_OW 301
119132: IFFALSE 119080
// end ;
119134: PPOPN 2
119136: END
// every 0 0$1 trigger StreamModeActive and sStu do
119137: LD_EXP 146
119141: PUSH
119142: LD_EXP 185
119146: AND
119147: IFFALSE 119163
119149: GO 119151
119151: DISABLE
// begin ToLua ( displayStucuk(); ) ;
119152: LD_STRING displayStucuk();
119154: PPUSH
119155: CALL_OW 559
// ResetFog ;
119159: CALL_OW 335
// end ;
119163: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
119164: LD_EXP 146
119168: PUSH
119169: LD_EXP 178
119173: AND
119174: IFFALSE 119315
119176: GO 119178
119178: DISABLE
119179: LD_INT 0
119181: PPUSH
119182: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119183: LD_ADDR_VAR 0 2
119187: PUSH
119188: LD_INT 22
119190: PUSH
119191: LD_OWVAR 2
119195: PUSH
119196: EMPTY
119197: LIST
119198: LIST
119199: PUSH
119200: LD_INT 21
119202: PUSH
119203: LD_INT 1
119205: PUSH
119206: EMPTY
119207: LIST
119208: LIST
119209: PUSH
119210: EMPTY
119211: LIST
119212: LIST
119213: PPUSH
119214: CALL_OW 69
119218: ST_TO_ADDR
// if not tmp then
119219: LD_VAR 0 2
119223: NOT
119224: IFFALSE 119228
// exit ;
119226: GO 119315
// un := tmp [ rand ( 1 , tmp ) ] ;
119228: LD_ADDR_VAR 0 1
119232: PUSH
119233: LD_VAR 0 2
119237: PUSH
119238: LD_INT 1
119240: PPUSH
119241: LD_VAR 0 2
119245: PPUSH
119246: CALL_OW 12
119250: ARRAY
119251: ST_TO_ADDR
// SetSide ( un , 0 ) ;
119252: LD_VAR 0 1
119256: PPUSH
119257: LD_INT 0
119259: PPUSH
119260: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
119264: LD_VAR 0 1
119268: PPUSH
119269: LD_OWVAR 3
119273: PUSH
119274: LD_VAR 0 1
119278: DIFF
119279: PPUSH
119280: LD_VAR 0 1
119284: PPUSH
119285: CALL_OW 74
119289: PPUSH
119290: CALL_OW 115
// wait ( 0 0$20 ) ;
119294: LD_INT 700
119296: PPUSH
119297: CALL_OW 67
// SetSide ( un , your_side ) ;
119301: LD_VAR 0 1
119305: PPUSH
119306: LD_OWVAR 2
119310: PPUSH
119311: CALL_OW 235
// end ;
119315: PPOPN 2
119317: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
119318: LD_EXP 146
119322: PUSH
119323: LD_EXP 179
119327: AND
119328: IFFALSE 119434
119330: GO 119332
119332: DISABLE
119333: LD_INT 0
119335: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
119336: LD_ADDR_VAR 0 1
119340: PUSH
119341: LD_INT 22
119343: PUSH
119344: LD_OWVAR 2
119348: PUSH
119349: EMPTY
119350: LIST
119351: LIST
119352: PUSH
119353: LD_INT 2
119355: PUSH
119356: LD_INT 30
119358: PUSH
119359: LD_INT 0
119361: PUSH
119362: EMPTY
119363: LIST
119364: LIST
119365: PUSH
119366: LD_INT 30
119368: PUSH
119369: LD_INT 1
119371: PUSH
119372: EMPTY
119373: LIST
119374: LIST
119375: PUSH
119376: EMPTY
119377: LIST
119378: LIST
119379: LIST
119380: PUSH
119381: EMPTY
119382: LIST
119383: LIST
119384: PPUSH
119385: CALL_OW 69
119389: ST_TO_ADDR
// if not depot then
119390: LD_VAR 0 1
119394: NOT
119395: IFFALSE 119399
// exit ;
119397: GO 119434
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
119399: LD_VAR 0 1
119403: PUSH
119404: LD_INT 1
119406: ARRAY
119407: PPUSH
119408: CALL_OW 250
119412: PPUSH
119413: LD_VAR 0 1
119417: PUSH
119418: LD_INT 1
119420: ARRAY
119421: PPUSH
119422: CALL_OW 251
119426: PPUSH
119427: LD_INT 70
119429: PPUSH
119430: CALL_OW 495
// end ;
119434: PPOPN 1
119436: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
119437: LD_EXP 146
119441: PUSH
119442: LD_EXP 180
119446: AND
119447: IFFALSE 119658
119449: GO 119451
119451: DISABLE
119452: LD_INT 0
119454: PPUSH
119455: PPUSH
119456: PPUSH
119457: PPUSH
119458: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119459: LD_ADDR_VAR 0 5
119463: PUSH
119464: LD_INT 22
119466: PUSH
119467: LD_OWVAR 2
119471: PUSH
119472: EMPTY
119473: LIST
119474: LIST
119475: PUSH
119476: LD_INT 21
119478: PUSH
119479: LD_INT 1
119481: PUSH
119482: EMPTY
119483: LIST
119484: LIST
119485: PUSH
119486: EMPTY
119487: LIST
119488: LIST
119489: PPUSH
119490: CALL_OW 69
119494: ST_TO_ADDR
// if not tmp then
119495: LD_VAR 0 5
119499: NOT
119500: IFFALSE 119504
// exit ;
119502: GO 119658
// for i in tmp do
119504: LD_ADDR_VAR 0 1
119508: PUSH
119509: LD_VAR 0 5
119513: PUSH
119514: FOR_IN
119515: IFFALSE 119656
// begin d := rand ( 0 , 5 ) ;
119517: LD_ADDR_VAR 0 4
119521: PUSH
119522: LD_INT 0
119524: PPUSH
119525: LD_INT 5
119527: PPUSH
119528: CALL_OW 12
119532: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
119533: LD_ADDR_VAR 0 2
119537: PUSH
119538: LD_VAR 0 1
119542: PPUSH
119543: CALL_OW 250
119547: PPUSH
119548: LD_VAR 0 4
119552: PPUSH
119553: LD_INT 3
119555: PPUSH
119556: LD_INT 12
119558: PPUSH
119559: CALL_OW 12
119563: PPUSH
119564: CALL_OW 272
119568: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
119569: LD_ADDR_VAR 0 3
119573: PUSH
119574: LD_VAR 0 1
119578: PPUSH
119579: CALL_OW 251
119583: PPUSH
119584: LD_VAR 0 4
119588: PPUSH
119589: LD_INT 3
119591: PPUSH
119592: LD_INT 12
119594: PPUSH
119595: CALL_OW 12
119599: PPUSH
119600: CALL_OW 273
119604: ST_TO_ADDR
// if ValidHex ( x , y ) then
119605: LD_VAR 0 2
119609: PPUSH
119610: LD_VAR 0 3
119614: PPUSH
119615: CALL_OW 488
119619: IFFALSE 119654
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
119621: LD_VAR 0 1
119625: PPUSH
119626: LD_VAR 0 2
119630: PPUSH
119631: LD_VAR 0 3
119635: PPUSH
119636: LD_INT 3
119638: PPUSH
119639: LD_INT 6
119641: PPUSH
119642: CALL_OW 12
119646: PPUSH
119647: LD_INT 1
119649: PPUSH
119650: CALL_OW 483
// end ;
119654: GO 119514
119656: POP
119657: POP
// end ;
119658: PPOPN 5
119660: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
119661: LD_EXP 146
119665: PUSH
119666: LD_EXP 181
119670: AND
119671: IFFALSE 119765
119673: GO 119675
119675: DISABLE
119676: LD_INT 0
119678: PPUSH
119679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
119680: LD_ADDR_VAR 0 2
119684: PUSH
119685: LD_INT 22
119687: PUSH
119688: LD_OWVAR 2
119692: PUSH
119693: EMPTY
119694: LIST
119695: LIST
119696: PUSH
119697: LD_INT 32
119699: PUSH
119700: LD_INT 1
119702: PUSH
119703: EMPTY
119704: LIST
119705: LIST
119706: PUSH
119707: LD_INT 21
119709: PUSH
119710: LD_INT 2
119712: PUSH
119713: EMPTY
119714: LIST
119715: LIST
119716: PUSH
119717: EMPTY
119718: LIST
119719: LIST
119720: LIST
119721: PPUSH
119722: CALL_OW 69
119726: ST_TO_ADDR
// if not tmp then
119727: LD_VAR 0 2
119731: NOT
119732: IFFALSE 119736
// exit ;
119734: GO 119765
// for i in tmp do
119736: LD_ADDR_VAR 0 1
119740: PUSH
119741: LD_VAR 0 2
119745: PUSH
119746: FOR_IN
119747: IFFALSE 119763
// SetFuel ( i , 0 ) ;
119749: LD_VAR 0 1
119753: PPUSH
119754: LD_INT 0
119756: PPUSH
119757: CALL_OW 240
119761: GO 119746
119763: POP
119764: POP
// end ;
119765: PPOPN 2
119767: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
119768: LD_EXP 146
119772: PUSH
119773: LD_EXP 182
119777: AND
119778: IFFALSE 119844
119780: GO 119782
119782: DISABLE
119783: LD_INT 0
119785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
119786: LD_ADDR_VAR 0 1
119790: PUSH
119791: LD_INT 22
119793: PUSH
119794: LD_OWVAR 2
119798: PUSH
119799: EMPTY
119800: LIST
119801: LIST
119802: PUSH
119803: LD_INT 30
119805: PUSH
119806: LD_INT 29
119808: PUSH
119809: EMPTY
119810: LIST
119811: LIST
119812: PUSH
119813: EMPTY
119814: LIST
119815: LIST
119816: PPUSH
119817: CALL_OW 69
119821: ST_TO_ADDR
// if not tmp then
119822: LD_VAR 0 1
119826: NOT
119827: IFFALSE 119831
// exit ;
119829: GO 119844
// DestroyUnit ( tmp [ 1 ] ) ;
119831: LD_VAR 0 1
119835: PUSH
119836: LD_INT 1
119838: ARRAY
119839: PPUSH
119840: CALL_OW 65
// end ;
119844: PPOPN 1
119846: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
119847: LD_EXP 146
119851: PUSH
119852: LD_EXP 184
119856: AND
119857: IFFALSE 119986
119859: GO 119861
119861: DISABLE
119862: LD_INT 0
119864: PPUSH
// begin uc_side := 0 ;
119865: LD_ADDR_OWVAR 20
119869: PUSH
119870: LD_INT 0
119872: ST_TO_ADDR
// uc_nation := nation_arabian ;
119873: LD_ADDR_OWVAR 21
119877: PUSH
119878: LD_INT 2
119880: ST_TO_ADDR
// hc_gallery :=  ;
119881: LD_ADDR_OWVAR 33
119885: PUSH
119886: LD_STRING 
119888: ST_TO_ADDR
// hc_name :=  ;
119889: LD_ADDR_OWVAR 26
119893: PUSH
119894: LD_STRING 
119896: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
119897: LD_INT 1
119899: PPUSH
119900: LD_INT 11
119902: PPUSH
119903: LD_INT 10
119905: PPUSH
119906: CALL_OW 380
// un := CreateHuman ;
119910: LD_ADDR_VAR 0 1
119914: PUSH
119915: CALL_OW 44
119919: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119920: LD_VAR 0 1
119924: PPUSH
119925: LD_INT 1
119927: PPUSH
119928: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119932: LD_INT 35
119934: PPUSH
119935: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119939: LD_VAR 0 1
119943: PPUSH
119944: LD_INT 22
119946: PUSH
119947: LD_OWVAR 2
119951: PUSH
119952: EMPTY
119953: LIST
119954: LIST
119955: PPUSH
119956: CALL_OW 69
119960: PPUSH
119961: LD_VAR 0 1
119965: PPUSH
119966: CALL_OW 74
119970: PPUSH
119971: CALL_OW 115
// until IsDead ( un ) ;
119975: LD_VAR 0 1
119979: PPUSH
119980: CALL_OW 301
119984: IFFALSE 119932
// end ;
119986: PPOPN 1
119988: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
119989: LD_EXP 146
119993: PUSH
119994: LD_EXP 186
119998: AND
119999: IFFALSE 120011
120001: GO 120003
120003: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
120004: LD_STRING earthquake(getX(game), 0, 32)
120006: PPUSH
120007: CALL_OW 559
120011: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
120012: LD_EXP 146
120016: PUSH
120017: LD_EXP 187
120021: AND
120022: IFFALSE 120113
120024: GO 120026
120026: DISABLE
120027: LD_INT 0
120029: PPUSH
// begin enable ;
120030: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
120031: LD_ADDR_VAR 0 1
120035: PUSH
120036: LD_INT 22
120038: PUSH
120039: LD_OWVAR 2
120043: PUSH
120044: EMPTY
120045: LIST
120046: LIST
120047: PUSH
120048: LD_INT 21
120050: PUSH
120051: LD_INT 2
120053: PUSH
120054: EMPTY
120055: LIST
120056: LIST
120057: PUSH
120058: LD_INT 33
120060: PUSH
120061: LD_INT 3
120063: PUSH
120064: EMPTY
120065: LIST
120066: LIST
120067: PUSH
120068: EMPTY
120069: LIST
120070: LIST
120071: LIST
120072: PPUSH
120073: CALL_OW 69
120077: ST_TO_ADDR
// if not tmp then
120078: LD_VAR 0 1
120082: NOT
120083: IFFALSE 120087
// exit ;
120085: GO 120113
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120087: LD_VAR 0 1
120091: PUSH
120092: LD_INT 1
120094: PPUSH
120095: LD_VAR 0 1
120099: PPUSH
120100: CALL_OW 12
120104: ARRAY
120105: PPUSH
120106: LD_INT 1
120108: PPUSH
120109: CALL_OW 234
// end ;
120113: PPOPN 1
120115: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
120116: LD_EXP 146
120120: PUSH
120121: LD_EXP 188
120125: AND
120126: IFFALSE 120267
120128: GO 120130
120130: DISABLE
120131: LD_INT 0
120133: PPUSH
120134: PPUSH
120135: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120136: LD_ADDR_VAR 0 3
120140: PUSH
120141: LD_INT 22
120143: PUSH
120144: LD_OWVAR 2
120148: PUSH
120149: EMPTY
120150: LIST
120151: LIST
120152: PUSH
120153: LD_INT 25
120155: PUSH
120156: LD_INT 1
120158: PUSH
120159: EMPTY
120160: LIST
120161: LIST
120162: PUSH
120163: EMPTY
120164: LIST
120165: LIST
120166: PPUSH
120167: CALL_OW 69
120171: ST_TO_ADDR
// if not tmp then
120172: LD_VAR 0 3
120176: NOT
120177: IFFALSE 120181
// exit ;
120179: GO 120267
// un := tmp [ rand ( 1 , tmp ) ] ;
120181: LD_ADDR_VAR 0 2
120185: PUSH
120186: LD_VAR 0 3
120190: PUSH
120191: LD_INT 1
120193: PPUSH
120194: LD_VAR 0 3
120198: PPUSH
120199: CALL_OW 12
120203: ARRAY
120204: ST_TO_ADDR
// if Crawls ( un ) then
120205: LD_VAR 0 2
120209: PPUSH
120210: CALL_OW 318
120214: IFFALSE 120225
// ComWalk ( un ) ;
120216: LD_VAR 0 2
120220: PPUSH
120221: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
120225: LD_VAR 0 2
120229: PPUSH
120230: LD_INT 9
120232: PPUSH
120233: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
120237: LD_INT 28
120239: PPUSH
120240: LD_OWVAR 2
120244: PPUSH
120245: LD_INT 2
120247: PPUSH
120248: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
120252: LD_INT 29
120254: PPUSH
120255: LD_OWVAR 2
120259: PPUSH
120260: LD_INT 2
120262: PPUSH
120263: CALL_OW 322
// end ;
120267: PPOPN 3
120269: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
120270: LD_EXP 146
120274: PUSH
120275: LD_EXP 189
120279: AND
120280: IFFALSE 120391
120282: GO 120284
120284: DISABLE
120285: LD_INT 0
120287: PPUSH
120288: PPUSH
120289: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120290: LD_ADDR_VAR 0 3
120294: PUSH
120295: LD_INT 22
120297: PUSH
120298: LD_OWVAR 2
120302: PUSH
120303: EMPTY
120304: LIST
120305: LIST
120306: PUSH
120307: LD_INT 25
120309: PUSH
120310: LD_INT 1
120312: PUSH
120313: EMPTY
120314: LIST
120315: LIST
120316: PUSH
120317: EMPTY
120318: LIST
120319: LIST
120320: PPUSH
120321: CALL_OW 69
120325: ST_TO_ADDR
// if not tmp then
120326: LD_VAR 0 3
120330: NOT
120331: IFFALSE 120335
// exit ;
120333: GO 120391
// un := tmp [ rand ( 1 , tmp ) ] ;
120335: LD_ADDR_VAR 0 2
120339: PUSH
120340: LD_VAR 0 3
120344: PUSH
120345: LD_INT 1
120347: PPUSH
120348: LD_VAR 0 3
120352: PPUSH
120353: CALL_OW 12
120357: ARRAY
120358: ST_TO_ADDR
// if Crawls ( un ) then
120359: LD_VAR 0 2
120363: PPUSH
120364: CALL_OW 318
120368: IFFALSE 120379
// ComWalk ( un ) ;
120370: LD_VAR 0 2
120374: PPUSH
120375: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120379: LD_VAR 0 2
120383: PPUSH
120384: LD_INT 8
120386: PPUSH
120387: CALL_OW 336
// end ;
120391: PPOPN 3
120393: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
120394: LD_EXP 146
120398: PUSH
120399: LD_EXP 190
120403: AND
120404: IFFALSE 120548
120406: GO 120408
120408: DISABLE
120409: LD_INT 0
120411: PPUSH
120412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
120413: LD_ADDR_VAR 0 2
120417: PUSH
120418: LD_INT 22
120420: PUSH
120421: LD_OWVAR 2
120425: PUSH
120426: EMPTY
120427: LIST
120428: LIST
120429: PUSH
120430: LD_INT 21
120432: PUSH
120433: LD_INT 2
120435: PUSH
120436: EMPTY
120437: LIST
120438: LIST
120439: PUSH
120440: LD_INT 2
120442: PUSH
120443: LD_INT 34
120445: PUSH
120446: LD_INT 12
120448: PUSH
120449: EMPTY
120450: LIST
120451: LIST
120452: PUSH
120453: LD_INT 34
120455: PUSH
120456: LD_INT 51
120458: PUSH
120459: EMPTY
120460: LIST
120461: LIST
120462: PUSH
120463: LD_INT 34
120465: PUSH
120466: LD_INT 32
120468: PUSH
120469: EMPTY
120470: LIST
120471: LIST
120472: PUSH
120473: EMPTY
120474: LIST
120475: LIST
120476: LIST
120477: LIST
120478: PUSH
120479: EMPTY
120480: LIST
120481: LIST
120482: LIST
120483: PPUSH
120484: CALL_OW 69
120488: ST_TO_ADDR
// if not tmp then
120489: LD_VAR 0 2
120493: NOT
120494: IFFALSE 120498
// exit ;
120496: GO 120548
// for i in tmp do
120498: LD_ADDR_VAR 0 1
120502: PUSH
120503: LD_VAR 0 2
120507: PUSH
120508: FOR_IN
120509: IFFALSE 120546
// if GetCargo ( i , mat_artifact ) = 0 then
120511: LD_VAR 0 1
120515: PPUSH
120516: LD_INT 4
120518: PPUSH
120519: CALL_OW 289
120523: PUSH
120524: LD_INT 0
120526: EQUAL
120527: IFFALSE 120544
// SetCargo ( i , mat_siberit , 100 ) ;
120529: LD_VAR 0 1
120533: PPUSH
120534: LD_INT 3
120536: PPUSH
120537: LD_INT 100
120539: PPUSH
120540: CALL_OW 290
120544: GO 120508
120546: POP
120547: POP
// end ;
120548: PPOPN 2
120550: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
120551: LD_EXP 146
120555: PUSH
120556: LD_EXP 191
120560: AND
120561: IFFALSE 120744
120563: GO 120565
120565: DISABLE
120566: LD_INT 0
120568: PPUSH
120569: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120570: LD_ADDR_VAR 0 2
120574: PUSH
120575: LD_INT 22
120577: PUSH
120578: LD_OWVAR 2
120582: PUSH
120583: EMPTY
120584: LIST
120585: LIST
120586: PPUSH
120587: CALL_OW 69
120591: ST_TO_ADDR
// if not tmp then
120592: LD_VAR 0 2
120596: NOT
120597: IFFALSE 120601
// exit ;
120599: GO 120744
// for i := 1 to 2 do
120601: LD_ADDR_VAR 0 1
120605: PUSH
120606: DOUBLE
120607: LD_INT 1
120609: DEC
120610: ST_TO_ADDR
120611: LD_INT 2
120613: PUSH
120614: FOR_TO
120615: IFFALSE 120742
// begin uc_side := your_side ;
120617: LD_ADDR_OWVAR 20
120621: PUSH
120622: LD_OWVAR 2
120626: ST_TO_ADDR
// uc_nation := nation_american ;
120627: LD_ADDR_OWVAR 21
120631: PUSH
120632: LD_INT 1
120634: ST_TO_ADDR
// vc_chassis := us_morphling ;
120635: LD_ADDR_OWVAR 37
120639: PUSH
120640: LD_INT 5
120642: ST_TO_ADDR
// vc_engine := engine_siberite ;
120643: LD_ADDR_OWVAR 39
120647: PUSH
120648: LD_INT 3
120650: ST_TO_ADDR
// vc_control := control_computer ;
120651: LD_ADDR_OWVAR 38
120655: PUSH
120656: LD_INT 3
120658: ST_TO_ADDR
// vc_weapon := us_double_laser ;
120659: LD_ADDR_OWVAR 40
120663: PUSH
120664: LD_INT 10
120666: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
120667: LD_VAR 0 2
120671: PUSH
120672: LD_INT 1
120674: ARRAY
120675: PPUSH
120676: CALL_OW 310
120680: NOT
120681: IFFALSE 120728
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
120683: CALL_OW 45
120687: PPUSH
120688: LD_VAR 0 2
120692: PUSH
120693: LD_INT 1
120695: ARRAY
120696: PPUSH
120697: CALL_OW 250
120701: PPUSH
120702: LD_VAR 0 2
120706: PUSH
120707: LD_INT 1
120709: ARRAY
120710: PPUSH
120711: CALL_OW 251
120715: PPUSH
120716: LD_INT 12
120718: PPUSH
120719: LD_INT 1
120721: PPUSH
120722: CALL_OW 50
120726: GO 120740
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
120728: CALL_OW 45
120732: PPUSH
120733: LD_INT 1
120735: PPUSH
120736: CALL_OW 51
// end ;
120740: GO 120614
120742: POP
120743: POP
// end ;
120744: PPOPN 2
120746: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
120747: LD_EXP 146
120751: PUSH
120752: LD_EXP 192
120756: AND
120757: IFFALSE 120979
120759: GO 120761
120761: DISABLE
120762: LD_INT 0
120764: PPUSH
120765: PPUSH
120766: PPUSH
120767: PPUSH
120768: PPUSH
120769: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120770: LD_ADDR_VAR 0 6
120774: PUSH
120775: LD_INT 22
120777: PUSH
120778: LD_OWVAR 2
120782: PUSH
120783: EMPTY
120784: LIST
120785: LIST
120786: PUSH
120787: LD_INT 21
120789: PUSH
120790: LD_INT 1
120792: PUSH
120793: EMPTY
120794: LIST
120795: LIST
120796: PUSH
120797: LD_INT 3
120799: PUSH
120800: LD_INT 23
120802: PUSH
120803: LD_INT 0
120805: PUSH
120806: EMPTY
120807: LIST
120808: LIST
120809: PUSH
120810: EMPTY
120811: LIST
120812: LIST
120813: PUSH
120814: EMPTY
120815: LIST
120816: LIST
120817: LIST
120818: PPUSH
120819: CALL_OW 69
120823: ST_TO_ADDR
// if not tmp then
120824: LD_VAR 0 6
120828: NOT
120829: IFFALSE 120833
// exit ;
120831: GO 120979
// s1 := rand ( 1 , 4 ) ;
120833: LD_ADDR_VAR 0 2
120837: PUSH
120838: LD_INT 1
120840: PPUSH
120841: LD_INT 4
120843: PPUSH
120844: CALL_OW 12
120848: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
120849: LD_ADDR_VAR 0 4
120853: PUSH
120854: LD_VAR 0 6
120858: PUSH
120859: LD_INT 1
120861: ARRAY
120862: PPUSH
120863: LD_VAR 0 2
120867: PPUSH
120868: CALL_OW 259
120872: ST_TO_ADDR
// if s1 = 1 then
120873: LD_VAR 0 2
120877: PUSH
120878: LD_INT 1
120880: EQUAL
120881: IFFALSE 120901
// s2 := rand ( 2 , 4 ) else
120883: LD_ADDR_VAR 0 3
120887: PUSH
120888: LD_INT 2
120890: PPUSH
120891: LD_INT 4
120893: PPUSH
120894: CALL_OW 12
120898: ST_TO_ADDR
120899: GO 120909
// s2 := 1 ;
120901: LD_ADDR_VAR 0 3
120905: PUSH
120906: LD_INT 1
120908: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
120909: LD_ADDR_VAR 0 5
120913: PUSH
120914: LD_VAR 0 6
120918: PUSH
120919: LD_INT 1
120921: ARRAY
120922: PPUSH
120923: LD_VAR 0 3
120927: PPUSH
120928: CALL_OW 259
120932: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
120933: LD_VAR 0 6
120937: PUSH
120938: LD_INT 1
120940: ARRAY
120941: PPUSH
120942: LD_VAR 0 2
120946: PPUSH
120947: LD_VAR 0 5
120951: PPUSH
120952: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
120956: LD_VAR 0 6
120960: PUSH
120961: LD_INT 1
120963: ARRAY
120964: PPUSH
120965: LD_VAR 0 3
120969: PPUSH
120970: LD_VAR 0 4
120974: PPUSH
120975: CALL_OW 237
// end ;
120979: PPOPN 6
120981: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
120982: LD_EXP 146
120986: PUSH
120987: LD_EXP 193
120991: AND
120992: IFFALSE 121071
120994: GO 120996
120996: DISABLE
120997: LD_INT 0
120999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
121000: LD_ADDR_VAR 0 1
121004: PUSH
121005: LD_INT 22
121007: PUSH
121008: LD_OWVAR 2
121012: PUSH
121013: EMPTY
121014: LIST
121015: LIST
121016: PUSH
121017: LD_INT 30
121019: PUSH
121020: LD_INT 3
121022: PUSH
121023: EMPTY
121024: LIST
121025: LIST
121026: PUSH
121027: EMPTY
121028: LIST
121029: LIST
121030: PPUSH
121031: CALL_OW 69
121035: ST_TO_ADDR
// if not tmp then
121036: LD_VAR 0 1
121040: NOT
121041: IFFALSE 121045
// exit ;
121043: GO 121071
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
121045: LD_VAR 0 1
121049: PUSH
121050: LD_INT 1
121052: PPUSH
121053: LD_VAR 0 1
121057: PPUSH
121058: CALL_OW 12
121062: ARRAY
121063: PPUSH
121064: LD_INT 1
121066: PPUSH
121067: CALL_OW 234
// end ;
121071: PPOPN 1
121073: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
121074: LD_EXP 146
121078: PUSH
121079: LD_EXP 194
121083: AND
121084: IFFALSE 121196
121086: GO 121088
121088: DISABLE
121089: LD_INT 0
121091: PPUSH
121092: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
121093: LD_ADDR_VAR 0 2
121097: PUSH
121098: LD_INT 22
121100: PUSH
121101: LD_OWVAR 2
121105: PUSH
121106: EMPTY
121107: LIST
121108: LIST
121109: PUSH
121110: LD_INT 2
121112: PUSH
121113: LD_INT 30
121115: PUSH
121116: LD_INT 27
121118: PUSH
121119: EMPTY
121120: LIST
121121: LIST
121122: PUSH
121123: LD_INT 30
121125: PUSH
121126: LD_INT 26
121128: PUSH
121129: EMPTY
121130: LIST
121131: LIST
121132: PUSH
121133: LD_INT 30
121135: PUSH
121136: LD_INT 28
121138: PUSH
121139: EMPTY
121140: LIST
121141: LIST
121142: PUSH
121143: EMPTY
121144: LIST
121145: LIST
121146: LIST
121147: LIST
121148: PUSH
121149: EMPTY
121150: LIST
121151: LIST
121152: PPUSH
121153: CALL_OW 69
121157: ST_TO_ADDR
// if not tmp then
121158: LD_VAR 0 2
121162: NOT
121163: IFFALSE 121167
// exit ;
121165: GO 121196
// for i in tmp do
121167: LD_ADDR_VAR 0 1
121171: PUSH
121172: LD_VAR 0 2
121176: PUSH
121177: FOR_IN
121178: IFFALSE 121194
// SetLives ( i , 1 ) ;
121180: LD_VAR 0 1
121184: PPUSH
121185: LD_INT 1
121187: PPUSH
121188: CALL_OW 234
121192: GO 121177
121194: POP
121195: POP
// end ;
121196: PPOPN 2
121198: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
121199: LD_EXP 146
121203: PUSH
121204: LD_EXP 195
121208: AND
121209: IFFALSE 121496
121211: GO 121213
121213: DISABLE
121214: LD_INT 0
121216: PPUSH
121217: PPUSH
121218: PPUSH
// begin i := rand ( 1 , 7 ) ;
121219: LD_ADDR_VAR 0 1
121223: PUSH
121224: LD_INT 1
121226: PPUSH
121227: LD_INT 7
121229: PPUSH
121230: CALL_OW 12
121234: ST_TO_ADDR
// case i of 1 :
121235: LD_VAR 0 1
121239: PUSH
121240: LD_INT 1
121242: DOUBLE
121243: EQUAL
121244: IFTRUE 121248
121246: GO 121258
121248: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
121249: LD_STRING earthquake(getX(game), 0, 32)
121251: PPUSH
121252: CALL_OW 559
121256: GO 121496
121258: LD_INT 2
121260: DOUBLE
121261: EQUAL
121262: IFTRUE 121266
121264: GO 121280
121266: POP
// begin ToLua ( displayStucuk(); ) ;
121267: LD_STRING displayStucuk();
121269: PPUSH
121270: CALL_OW 559
// ResetFog ;
121274: CALL_OW 335
// end ; 3 :
121278: GO 121496
121280: LD_INT 3
121282: DOUBLE
121283: EQUAL
121284: IFTRUE 121288
121286: GO 121392
121288: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121289: LD_ADDR_VAR 0 2
121293: PUSH
121294: LD_INT 22
121296: PUSH
121297: LD_OWVAR 2
121301: PUSH
121302: EMPTY
121303: LIST
121304: LIST
121305: PUSH
121306: LD_INT 25
121308: PUSH
121309: LD_INT 1
121311: PUSH
121312: EMPTY
121313: LIST
121314: LIST
121315: PUSH
121316: EMPTY
121317: LIST
121318: LIST
121319: PPUSH
121320: CALL_OW 69
121324: ST_TO_ADDR
// if not tmp then
121325: LD_VAR 0 2
121329: NOT
121330: IFFALSE 121334
// exit ;
121332: GO 121496
// un := tmp [ rand ( 1 , tmp ) ] ;
121334: LD_ADDR_VAR 0 3
121338: PUSH
121339: LD_VAR 0 2
121343: PUSH
121344: LD_INT 1
121346: PPUSH
121347: LD_VAR 0 2
121351: PPUSH
121352: CALL_OW 12
121356: ARRAY
121357: ST_TO_ADDR
// if Crawls ( un ) then
121358: LD_VAR 0 3
121362: PPUSH
121363: CALL_OW 318
121367: IFFALSE 121378
// ComWalk ( un ) ;
121369: LD_VAR 0 3
121373: PPUSH
121374: CALL_OW 138
// SetClass ( un , class_mortar ) ;
121378: LD_VAR 0 3
121382: PPUSH
121383: LD_INT 8
121385: PPUSH
121386: CALL_OW 336
// end ; 4 :
121390: GO 121496
121392: LD_INT 4
121394: DOUBLE
121395: EQUAL
121396: IFTRUE 121400
121398: GO 121474
121400: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
121401: LD_ADDR_VAR 0 2
121405: PUSH
121406: LD_INT 22
121408: PUSH
121409: LD_OWVAR 2
121413: PUSH
121414: EMPTY
121415: LIST
121416: LIST
121417: PUSH
121418: LD_INT 30
121420: PUSH
121421: LD_INT 29
121423: PUSH
121424: EMPTY
121425: LIST
121426: LIST
121427: PUSH
121428: EMPTY
121429: LIST
121430: LIST
121431: PPUSH
121432: CALL_OW 69
121436: ST_TO_ADDR
// if not tmp then
121437: LD_VAR 0 2
121441: NOT
121442: IFFALSE 121446
// exit ;
121444: GO 121496
// CenterNowOnUnits ( tmp [ 1 ] ) ;
121446: LD_VAR 0 2
121450: PUSH
121451: LD_INT 1
121453: ARRAY
121454: PPUSH
121455: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
121459: LD_VAR 0 2
121463: PUSH
121464: LD_INT 1
121466: ARRAY
121467: PPUSH
121468: CALL_OW 65
// end ; 5 .. 7 :
121472: GO 121496
121474: LD_INT 5
121476: DOUBLE
121477: GREATEREQUAL
121478: IFFALSE 121486
121480: LD_INT 7
121482: DOUBLE
121483: LESSEQUAL
121484: IFTRUE 121488
121486: GO 121495
121488: POP
// StreamSibBomb ; end ;
121489: CALL 117733 0 0
121493: GO 121496
121495: POP
// end ;
121496: PPOPN 3
121498: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
121499: LD_EXP 146
121503: PUSH
121504: LD_EXP 196
121508: AND
121509: IFFALSE 121665
121511: GO 121513
121513: DISABLE
121514: LD_INT 0
121516: PPUSH
121517: PPUSH
121518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
121519: LD_ADDR_VAR 0 2
121523: PUSH
121524: LD_INT 81
121526: PUSH
121527: LD_OWVAR 2
121531: PUSH
121532: EMPTY
121533: LIST
121534: LIST
121535: PUSH
121536: LD_INT 2
121538: PUSH
121539: LD_INT 21
121541: PUSH
121542: LD_INT 1
121544: PUSH
121545: EMPTY
121546: LIST
121547: LIST
121548: PUSH
121549: LD_INT 21
121551: PUSH
121552: LD_INT 2
121554: PUSH
121555: EMPTY
121556: LIST
121557: LIST
121558: PUSH
121559: EMPTY
121560: LIST
121561: LIST
121562: LIST
121563: PUSH
121564: EMPTY
121565: LIST
121566: LIST
121567: PPUSH
121568: CALL_OW 69
121572: ST_TO_ADDR
// if not tmp then
121573: LD_VAR 0 2
121577: NOT
121578: IFFALSE 121582
// exit ;
121580: GO 121665
// p := 0 ;
121582: LD_ADDR_VAR 0 3
121586: PUSH
121587: LD_INT 0
121589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121590: LD_INT 35
121592: PPUSH
121593: CALL_OW 67
// p := p + 1 ;
121597: LD_ADDR_VAR 0 3
121601: PUSH
121602: LD_VAR 0 3
121606: PUSH
121607: LD_INT 1
121609: PLUS
121610: ST_TO_ADDR
// for i in tmp do
121611: LD_ADDR_VAR 0 1
121615: PUSH
121616: LD_VAR 0 2
121620: PUSH
121621: FOR_IN
121622: IFFALSE 121653
// if GetLives ( i ) < 1000 then
121624: LD_VAR 0 1
121628: PPUSH
121629: CALL_OW 256
121633: PUSH
121634: LD_INT 1000
121636: LESS
121637: IFFALSE 121651
// SetLives ( i , 1000 ) ;
121639: LD_VAR 0 1
121643: PPUSH
121644: LD_INT 1000
121646: PPUSH
121647: CALL_OW 234
121651: GO 121621
121653: POP
121654: POP
// until p > 20 ;
121655: LD_VAR 0 3
121659: PUSH
121660: LD_INT 20
121662: GREATER
121663: IFFALSE 121590
// end ;
121665: PPOPN 3
121667: END
// every 0 0$1 trigger StreamModeActive and sTime do
121668: LD_EXP 146
121672: PUSH
121673: LD_EXP 197
121677: AND
121678: IFFALSE 121713
121680: GO 121682
121682: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
121683: LD_INT 28
121685: PPUSH
121686: LD_OWVAR 2
121690: PPUSH
121691: LD_INT 2
121693: PPUSH
121694: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
121698: LD_INT 30
121700: PPUSH
121701: LD_OWVAR 2
121705: PPUSH
121706: LD_INT 2
121708: PPUSH
121709: CALL_OW 322
// end ;
121713: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
121714: LD_EXP 146
121718: PUSH
121719: LD_EXP 198
121723: AND
121724: IFFALSE 121845
121726: GO 121728
121728: DISABLE
121729: LD_INT 0
121731: PPUSH
121732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121733: LD_ADDR_VAR 0 2
121737: PUSH
121738: LD_INT 22
121740: PUSH
121741: LD_OWVAR 2
121745: PUSH
121746: EMPTY
121747: LIST
121748: LIST
121749: PUSH
121750: LD_INT 21
121752: PUSH
121753: LD_INT 1
121755: PUSH
121756: EMPTY
121757: LIST
121758: LIST
121759: PUSH
121760: LD_INT 3
121762: PUSH
121763: LD_INT 23
121765: PUSH
121766: LD_INT 0
121768: PUSH
121769: EMPTY
121770: LIST
121771: LIST
121772: PUSH
121773: EMPTY
121774: LIST
121775: LIST
121776: PUSH
121777: EMPTY
121778: LIST
121779: LIST
121780: LIST
121781: PPUSH
121782: CALL_OW 69
121786: ST_TO_ADDR
// if not tmp then
121787: LD_VAR 0 2
121791: NOT
121792: IFFALSE 121796
// exit ;
121794: GO 121845
// for i in tmp do
121796: LD_ADDR_VAR 0 1
121800: PUSH
121801: LD_VAR 0 2
121805: PUSH
121806: FOR_IN
121807: IFFALSE 121843
// begin if Crawls ( i ) then
121809: LD_VAR 0 1
121813: PPUSH
121814: CALL_OW 318
121818: IFFALSE 121829
// ComWalk ( i ) ;
121820: LD_VAR 0 1
121824: PPUSH
121825: CALL_OW 138
// SetClass ( i , 2 ) ;
121829: LD_VAR 0 1
121833: PPUSH
121834: LD_INT 2
121836: PPUSH
121837: CALL_OW 336
// end ;
121841: GO 121806
121843: POP
121844: POP
// end ;
121845: PPOPN 2
121847: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
121848: LD_EXP 146
121852: PUSH
121853: LD_EXP 199
121857: AND
121858: IFFALSE 122146
121860: GO 121862
121862: DISABLE
121863: LD_INT 0
121865: PPUSH
121866: PPUSH
121867: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
121868: LD_OWVAR 2
121872: PPUSH
121873: LD_INT 9
121875: PPUSH
121876: LD_INT 1
121878: PPUSH
121879: LD_INT 1
121881: PPUSH
121882: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
121886: LD_INT 9
121888: PPUSH
121889: LD_OWVAR 2
121893: PPUSH
121894: CALL_OW 343
// uc_side := 9 ;
121898: LD_ADDR_OWVAR 20
121902: PUSH
121903: LD_INT 9
121905: ST_TO_ADDR
// uc_nation := 2 ;
121906: LD_ADDR_OWVAR 21
121910: PUSH
121911: LD_INT 2
121913: ST_TO_ADDR
// hc_name := Dark Warrior ;
121914: LD_ADDR_OWVAR 26
121918: PUSH
121919: LD_STRING Dark Warrior
121921: ST_TO_ADDR
// hc_gallery :=  ;
121922: LD_ADDR_OWVAR 33
121926: PUSH
121927: LD_STRING 
121929: ST_TO_ADDR
// hc_noskilllimit := true ;
121930: LD_ADDR_OWVAR 76
121934: PUSH
121935: LD_INT 1
121937: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
121938: LD_ADDR_OWVAR 31
121942: PUSH
121943: LD_INT 30
121945: PUSH
121946: LD_INT 30
121948: PUSH
121949: LD_INT 30
121951: PUSH
121952: LD_INT 30
121954: PUSH
121955: EMPTY
121956: LIST
121957: LIST
121958: LIST
121959: LIST
121960: ST_TO_ADDR
// un := CreateHuman ;
121961: LD_ADDR_VAR 0 3
121965: PUSH
121966: CALL_OW 44
121970: ST_TO_ADDR
// hc_noskilllimit := false ;
121971: LD_ADDR_OWVAR 76
121975: PUSH
121976: LD_INT 0
121978: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121979: LD_VAR 0 3
121983: PPUSH
121984: LD_INT 1
121986: PPUSH
121987: CALL_OW 51
// ToLua ( playRanger() ) ;
121991: LD_STRING playRanger()
121993: PPUSH
121994: CALL_OW 559
// p := 0 ;
121998: LD_ADDR_VAR 0 2
122002: PUSH
122003: LD_INT 0
122005: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
122006: LD_INT 35
122008: PPUSH
122009: CALL_OW 67
// p := p + 1 ;
122013: LD_ADDR_VAR 0 2
122017: PUSH
122018: LD_VAR 0 2
122022: PUSH
122023: LD_INT 1
122025: PLUS
122026: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
122027: LD_VAR 0 3
122031: PPUSH
122032: CALL_OW 256
122036: PUSH
122037: LD_INT 1000
122039: LESS
122040: IFFALSE 122054
// SetLives ( un , 1000 ) ;
122042: LD_VAR 0 3
122046: PPUSH
122047: LD_INT 1000
122049: PPUSH
122050: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
122054: LD_VAR 0 3
122058: PPUSH
122059: LD_INT 81
122061: PUSH
122062: LD_OWVAR 2
122066: PUSH
122067: EMPTY
122068: LIST
122069: LIST
122070: PUSH
122071: LD_INT 91
122073: PUSH
122074: LD_VAR 0 3
122078: PUSH
122079: LD_INT 30
122081: PUSH
122082: EMPTY
122083: LIST
122084: LIST
122085: LIST
122086: PUSH
122087: EMPTY
122088: LIST
122089: LIST
122090: PPUSH
122091: CALL_OW 69
122095: PPUSH
122096: LD_VAR 0 3
122100: PPUSH
122101: CALL_OW 74
122105: PPUSH
122106: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
122110: LD_VAR 0 2
122114: PUSH
122115: LD_INT 80
122117: GREATER
122118: PUSH
122119: LD_VAR 0 3
122123: PPUSH
122124: CALL_OW 301
122128: OR
122129: IFFALSE 122006
// if un then
122131: LD_VAR 0 3
122135: IFFALSE 122146
// RemoveUnit ( un ) ;
122137: LD_VAR 0 3
122141: PPUSH
122142: CALL_OW 64
// end ;
122146: PPOPN 3
122148: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
122149: LD_EXP 200
122153: IFFALSE 122269
122155: GO 122157
122157: DISABLE
122158: LD_INT 0
122160: PPUSH
122161: PPUSH
122162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
122163: LD_ADDR_VAR 0 2
122167: PUSH
122168: LD_INT 81
122170: PUSH
122171: LD_OWVAR 2
122175: PUSH
122176: EMPTY
122177: LIST
122178: LIST
122179: PUSH
122180: LD_INT 21
122182: PUSH
122183: LD_INT 1
122185: PUSH
122186: EMPTY
122187: LIST
122188: LIST
122189: PUSH
122190: EMPTY
122191: LIST
122192: LIST
122193: PPUSH
122194: CALL_OW 69
122198: ST_TO_ADDR
// ToLua ( playComputer() ) ;
122199: LD_STRING playComputer()
122201: PPUSH
122202: CALL_OW 559
// if not tmp then
122206: LD_VAR 0 2
122210: NOT
122211: IFFALSE 122215
// exit ;
122213: GO 122269
// for i in tmp do
122215: LD_ADDR_VAR 0 1
122219: PUSH
122220: LD_VAR 0 2
122224: PUSH
122225: FOR_IN
122226: IFFALSE 122267
// for j := 1 to 4 do
122228: LD_ADDR_VAR 0 3
122232: PUSH
122233: DOUBLE
122234: LD_INT 1
122236: DEC
122237: ST_TO_ADDR
122238: LD_INT 4
122240: PUSH
122241: FOR_TO
122242: IFFALSE 122263
// SetSkill ( i , j , 10 ) ;
122244: LD_VAR 0 1
122248: PPUSH
122249: LD_VAR 0 3
122253: PPUSH
122254: LD_INT 10
122256: PPUSH
122257: CALL_OW 237
122261: GO 122241
122263: POP
122264: POP
122265: GO 122225
122267: POP
122268: POP
// end ;
122269: PPOPN 3
122271: END
// every 0 0$1 trigger s30 do var i , tmp ;
122272: LD_EXP 201
122276: IFFALSE 122345
122278: GO 122280
122280: DISABLE
122281: LD_INT 0
122283: PPUSH
122284: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122285: LD_ADDR_VAR 0 2
122289: PUSH
122290: LD_INT 22
122292: PUSH
122293: LD_OWVAR 2
122297: PUSH
122298: EMPTY
122299: LIST
122300: LIST
122301: PPUSH
122302: CALL_OW 69
122306: ST_TO_ADDR
// if not tmp then
122307: LD_VAR 0 2
122311: NOT
122312: IFFALSE 122316
// exit ;
122314: GO 122345
// for i in tmp do
122316: LD_ADDR_VAR 0 1
122320: PUSH
122321: LD_VAR 0 2
122325: PUSH
122326: FOR_IN
122327: IFFALSE 122343
// SetLives ( i , 300 ) ;
122329: LD_VAR 0 1
122333: PPUSH
122334: LD_INT 300
122336: PPUSH
122337: CALL_OW 234
122341: GO 122326
122343: POP
122344: POP
// end ;
122345: PPOPN 2
122347: END
// every 0 0$1 trigger s60 do var i , tmp ;
122348: LD_EXP 202
122352: IFFALSE 122421
122354: GO 122356
122356: DISABLE
122357: LD_INT 0
122359: PPUSH
122360: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122361: LD_ADDR_VAR 0 2
122365: PUSH
122366: LD_INT 22
122368: PUSH
122369: LD_OWVAR 2
122373: PUSH
122374: EMPTY
122375: LIST
122376: LIST
122377: PPUSH
122378: CALL_OW 69
122382: ST_TO_ADDR
// if not tmp then
122383: LD_VAR 0 2
122387: NOT
122388: IFFALSE 122392
// exit ;
122390: GO 122421
// for i in tmp do
122392: LD_ADDR_VAR 0 1
122396: PUSH
122397: LD_VAR 0 2
122401: PUSH
122402: FOR_IN
122403: IFFALSE 122419
// SetLives ( i , 600 ) ;
122405: LD_VAR 0 1
122409: PPUSH
122410: LD_INT 600
122412: PPUSH
122413: CALL_OW 234
122417: GO 122402
122419: POP
122420: POP
// end ;
122421: PPOPN 2
122423: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
122424: LD_INT 0
122426: PPUSH
// case cmd of 301 :
122427: LD_VAR 0 1
122431: PUSH
122432: LD_INT 301
122434: DOUBLE
122435: EQUAL
122436: IFTRUE 122440
122438: GO 122472
122440: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
122441: LD_VAR 0 6
122445: PPUSH
122446: LD_VAR 0 7
122450: PPUSH
122451: LD_VAR 0 8
122455: PPUSH
122456: LD_VAR 0 4
122460: PPUSH
122461: LD_VAR 0 5
122465: PPUSH
122466: CALL 123673 0 5
122470: GO 122593
122472: LD_INT 302
122474: DOUBLE
122475: EQUAL
122476: IFTRUE 122480
122478: GO 122517
122480: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
122481: LD_VAR 0 6
122485: PPUSH
122486: LD_VAR 0 7
122490: PPUSH
122491: LD_VAR 0 8
122495: PPUSH
122496: LD_VAR 0 9
122500: PPUSH
122501: LD_VAR 0 4
122505: PPUSH
122506: LD_VAR 0 5
122510: PPUSH
122511: CALL 123764 0 6
122515: GO 122593
122517: LD_INT 303
122519: DOUBLE
122520: EQUAL
122521: IFTRUE 122525
122523: GO 122562
122525: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
122526: LD_VAR 0 6
122530: PPUSH
122531: LD_VAR 0 7
122535: PPUSH
122536: LD_VAR 0 8
122540: PPUSH
122541: LD_VAR 0 9
122545: PPUSH
122546: LD_VAR 0 4
122550: PPUSH
122551: LD_VAR 0 5
122555: PPUSH
122556: CALL 122598 0 6
122560: GO 122593
122562: LD_INT 304
122564: DOUBLE
122565: EQUAL
122566: IFTRUE 122570
122568: GO 122592
122570: POP
// hHackTeleport ( unit , x , y ) ; end ;
122571: LD_VAR 0 2
122575: PPUSH
122576: LD_VAR 0 4
122580: PPUSH
122581: LD_VAR 0 5
122585: PPUSH
122586: CALL 124357 0 3
122590: GO 122593
122592: POP
// end ;
122593: LD_VAR 0 12
122597: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
122598: LD_INT 0
122600: PPUSH
122601: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
122602: LD_VAR 0 1
122606: PUSH
122607: LD_INT 1
122609: LESS
122610: PUSH
122611: LD_VAR 0 1
122615: PUSH
122616: LD_INT 3
122618: GREATER
122619: OR
122620: PUSH
122621: LD_VAR 0 5
122625: PPUSH
122626: LD_VAR 0 6
122630: PPUSH
122631: CALL_OW 428
122635: OR
122636: IFFALSE 122640
// exit ;
122638: GO 123360
// uc_side := your_side ;
122640: LD_ADDR_OWVAR 20
122644: PUSH
122645: LD_OWVAR 2
122649: ST_TO_ADDR
// uc_nation := nation ;
122650: LD_ADDR_OWVAR 21
122654: PUSH
122655: LD_VAR 0 1
122659: ST_TO_ADDR
// bc_level = 1 ;
122660: LD_ADDR_OWVAR 43
122664: PUSH
122665: LD_INT 1
122667: ST_TO_ADDR
// case btype of 1 :
122668: LD_VAR 0 2
122672: PUSH
122673: LD_INT 1
122675: DOUBLE
122676: EQUAL
122677: IFTRUE 122681
122679: GO 122692
122681: POP
// bc_type := b_depot ; 2 :
122682: LD_ADDR_OWVAR 42
122686: PUSH
122687: LD_INT 0
122689: ST_TO_ADDR
122690: GO 123304
122692: LD_INT 2
122694: DOUBLE
122695: EQUAL
122696: IFTRUE 122700
122698: GO 122711
122700: POP
// bc_type := b_warehouse ; 3 :
122701: LD_ADDR_OWVAR 42
122705: PUSH
122706: LD_INT 1
122708: ST_TO_ADDR
122709: GO 123304
122711: LD_INT 3
122713: DOUBLE
122714: EQUAL
122715: IFTRUE 122719
122717: GO 122730
122719: POP
// bc_type := b_lab ; 4 .. 9 :
122720: LD_ADDR_OWVAR 42
122724: PUSH
122725: LD_INT 6
122727: ST_TO_ADDR
122728: GO 123304
122730: LD_INT 4
122732: DOUBLE
122733: GREATEREQUAL
122734: IFFALSE 122742
122736: LD_INT 9
122738: DOUBLE
122739: LESSEQUAL
122740: IFTRUE 122744
122742: GO 122796
122744: POP
// begin bc_type := b_lab_half ;
122745: LD_ADDR_OWVAR 42
122749: PUSH
122750: LD_INT 7
122752: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
122753: LD_ADDR_OWVAR 44
122757: PUSH
122758: LD_INT 10
122760: PUSH
122761: LD_INT 11
122763: PUSH
122764: LD_INT 12
122766: PUSH
122767: LD_INT 15
122769: PUSH
122770: LD_INT 14
122772: PUSH
122773: LD_INT 13
122775: PUSH
122776: EMPTY
122777: LIST
122778: LIST
122779: LIST
122780: LIST
122781: LIST
122782: LIST
122783: PUSH
122784: LD_VAR 0 2
122788: PUSH
122789: LD_INT 3
122791: MINUS
122792: ARRAY
122793: ST_TO_ADDR
// end ; 10 .. 13 :
122794: GO 123304
122796: LD_INT 10
122798: DOUBLE
122799: GREATEREQUAL
122800: IFFALSE 122808
122802: LD_INT 13
122804: DOUBLE
122805: LESSEQUAL
122806: IFTRUE 122810
122808: GO 122887
122810: POP
// begin bc_type := b_lab_full ;
122811: LD_ADDR_OWVAR 42
122815: PUSH
122816: LD_INT 8
122818: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
122819: LD_ADDR_OWVAR 44
122823: PUSH
122824: LD_INT 10
122826: PUSH
122827: LD_INT 12
122829: PUSH
122830: LD_INT 14
122832: PUSH
122833: LD_INT 13
122835: PUSH
122836: EMPTY
122837: LIST
122838: LIST
122839: LIST
122840: LIST
122841: PUSH
122842: LD_VAR 0 2
122846: PUSH
122847: LD_INT 9
122849: MINUS
122850: ARRAY
122851: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
122852: LD_ADDR_OWVAR 45
122856: PUSH
122857: LD_INT 11
122859: PUSH
122860: LD_INT 15
122862: PUSH
122863: LD_INT 12
122865: PUSH
122866: LD_INT 15
122868: PUSH
122869: EMPTY
122870: LIST
122871: LIST
122872: LIST
122873: LIST
122874: PUSH
122875: LD_VAR 0 2
122879: PUSH
122880: LD_INT 9
122882: MINUS
122883: ARRAY
122884: ST_TO_ADDR
// end ; 14 :
122885: GO 123304
122887: LD_INT 14
122889: DOUBLE
122890: EQUAL
122891: IFTRUE 122895
122893: GO 122906
122895: POP
// bc_type := b_workshop ; 15 :
122896: LD_ADDR_OWVAR 42
122900: PUSH
122901: LD_INT 2
122903: ST_TO_ADDR
122904: GO 123304
122906: LD_INT 15
122908: DOUBLE
122909: EQUAL
122910: IFTRUE 122914
122912: GO 122925
122914: POP
// bc_type := b_factory ; 16 :
122915: LD_ADDR_OWVAR 42
122919: PUSH
122920: LD_INT 3
122922: ST_TO_ADDR
122923: GO 123304
122925: LD_INT 16
122927: DOUBLE
122928: EQUAL
122929: IFTRUE 122933
122931: GO 122944
122933: POP
// bc_type := b_ext_gun ; 17 :
122934: LD_ADDR_OWVAR 42
122938: PUSH
122939: LD_INT 17
122941: ST_TO_ADDR
122942: GO 123304
122944: LD_INT 17
122946: DOUBLE
122947: EQUAL
122948: IFTRUE 122952
122950: GO 122980
122952: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
122953: LD_ADDR_OWVAR 42
122957: PUSH
122958: LD_INT 19
122960: PUSH
122961: LD_INT 23
122963: PUSH
122964: LD_INT 19
122966: PUSH
122967: EMPTY
122968: LIST
122969: LIST
122970: LIST
122971: PUSH
122972: LD_VAR 0 1
122976: ARRAY
122977: ST_TO_ADDR
122978: GO 123304
122980: LD_INT 18
122982: DOUBLE
122983: EQUAL
122984: IFTRUE 122988
122986: GO 122999
122988: POP
// bc_type := b_ext_radar ; 19 :
122989: LD_ADDR_OWVAR 42
122993: PUSH
122994: LD_INT 20
122996: ST_TO_ADDR
122997: GO 123304
122999: LD_INT 19
123001: DOUBLE
123002: EQUAL
123003: IFTRUE 123007
123005: GO 123018
123007: POP
// bc_type := b_ext_radio ; 20 :
123008: LD_ADDR_OWVAR 42
123012: PUSH
123013: LD_INT 22
123015: ST_TO_ADDR
123016: GO 123304
123018: LD_INT 20
123020: DOUBLE
123021: EQUAL
123022: IFTRUE 123026
123024: GO 123037
123026: POP
// bc_type := b_ext_siberium ; 21 :
123027: LD_ADDR_OWVAR 42
123031: PUSH
123032: LD_INT 21
123034: ST_TO_ADDR
123035: GO 123304
123037: LD_INT 21
123039: DOUBLE
123040: EQUAL
123041: IFTRUE 123045
123043: GO 123056
123045: POP
// bc_type := b_ext_computer ; 22 :
123046: LD_ADDR_OWVAR 42
123050: PUSH
123051: LD_INT 24
123053: ST_TO_ADDR
123054: GO 123304
123056: LD_INT 22
123058: DOUBLE
123059: EQUAL
123060: IFTRUE 123064
123062: GO 123075
123064: POP
// bc_type := b_ext_track ; 23 :
123065: LD_ADDR_OWVAR 42
123069: PUSH
123070: LD_INT 16
123072: ST_TO_ADDR
123073: GO 123304
123075: LD_INT 23
123077: DOUBLE
123078: EQUAL
123079: IFTRUE 123083
123081: GO 123094
123083: POP
// bc_type := b_ext_laser ; 24 :
123084: LD_ADDR_OWVAR 42
123088: PUSH
123089: LD_INT 25
123091: ST_TO_ADDR
123092: GO 123304
123094: LD_INT 24
123096: DOUBLE
123097: EQUAL
123098: IFTRUE 123102
123100: GO 123113
123102: POP
// bc_type := b_control_tower ; 25 :
123103: LD_ADDR_OWVAR 42
123107: PUSH
123108: LD_INT 36
123110: ST_TO_ADDR
123111: GO 123304
123113: LD_INT 25
123115: DOUBLE
123116: EQUAL
123117: IFTRUE 123121
123119: GO 123132
123121: POP
// bc_type := b_breastwork ; 26 :
123122: LD_ADDR_OWVAR 42
123126: PUSH
123127: LD_INT 31
123129: ST_TO_ADDR
123130: GO 123304
123132: LD_INT 26
123134: DOUBLE
123135: EQUAL
123136: IFTRUE 123140
123138: GO 123151
123140: POP
// bc_type := b_bunker ; 27 :
123141: LD_ADDR_OWVAR 42
123145: PUSH
123146: LD_INT 32
123148: ST_TO_ADDR
123149: GO 123304
123151: LD_INT 27
123153: DOUBLE
123154: EQUAL
123155: IFTRUE 123159
123157: GO 123170
123159: POP
// bc_type := b_turret ; 28 :
123160: LD_ADDR_OWVAR 42
123164: PUSH
123165: LD_INT 33
123167: ST_TO_ADDR
123168: GO 123304
123170: LD_INT 28
123172: DOUBLE
123173: EQUAL
123174: IFTRUE 123178
123176: GO 123189
123178: POP
// bc_type := b_armoury ; 29 :
123179: LD_ADDR_OWVAR 42
123183: PUSH
123184: LD_INT 4
123186: ST_TO_ADDR
123187: GO 123304
123189: LD_INT 29
123191: DOUBLE
123192: EQUAL
123193: IFTRUE 123197
123195: GO 123208
123197: POP
// bc_type := b_barracks ; 30 :
123198: LD_ADDR_OWVAR 42
123202: PUSH
123203: LD_INT 5
123205: ST_TO_ADDR
123206: GO 123304
123208: LD_INT 30
123210: DOUBLE
123211: EQUAL
123212: IFTRUE 123216
123214: GO 123227
123216: POP
// bc_type := b_solar_power ; 31 :
123217: LD_ADDR_OWVAR 42
123221: PUSH
123222: LD_INT 27
123224: ST_TO_ADDR
123225: GO 123304
123227: LD_INT 31
123229: DOUBLE
123230: EQUAL
123231: IFTRUE 123235
123233: GO 123246
123235: POP
// bc_type := b_oil_power ; 32 :
123236: LD_ADDR_OWVAR 42
123240: PUSH
123241: LD_INT 26
123243: ST_TO_ADDR
123244: GO 123304
123246: LD_INT 32
123248: DOUBLE
123249: EQUAL
123250: IFTRUE 123254
123252: GO 123265
123254: POP
// bc_type := b_siberite_power ; 33 :
123255: LD_ADDR_OWVAR 42
123259: PUSH
123260: LD_INT 28
123262: ST_TO_ADDR
123263: GO 123304
123265: LD_INT 33
123267: DOUBLE
123268: EQUAL
123269: IFTRUE 123273
123271: GO 123284
123273: POP
// bc_type := b_oil_mine ; 34 :
123274: LD_ADDR_OWVAR 42
123278: PUSH
123279: LD_INT 29
123281: ST_TO_ADDR
123282: GO 123304
123284: LD_INT 34
123286: DOUBLE
123287: EQUAL
123288: IFTRUE 123292
123290: GO 123303
123292: POP
// bc_type := b_siberite_mine ; end ;
123293: LD_ADDR_OWVAR 42
123297: PUSH
123298: LD_INT 30
123300: ST_TO_ADDR
123301: GO 123304
123303: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
123304: LD_ADDR_VAR 0 8
123308: PUSH
123309: LD_VAR 0 5
123313: PPUSH
123314: LD_VAR 0 6
123318: PPUSH
123319: LD_VAR 0 3
123323: PPUSH
123324: CALL_OW 47
123328: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
123329: LD_OWVAR 42
123333: PUSH
123334: LD_INT 32
123336: PUSH
123337: LD_INT 33
123339: PUSH
123340: EMPTY
123341: LIST
123342: LIST
123343: IN
123344: IFFALSE 123360
// PlaceWeaponTurret ( b , weapon ) ;
123346: LD_VAR 0 8
123350: PPUSH
123351: LD_VAR 0 4
123355: PPUSH
123356: CALL_OW 431
// end ;
123360: LD_VAR 0 7
123364: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
123365: LD_INT 0
123367: PPUSH
123368: PPUSH
123369: PPUSH
123370: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123371: LD_ADDR_VAR 0 4
123375: PUSH
123376: LD_INT 22
123378: PUSH
123379: LD_OWVAR 2
123383: PUSH
123384: EMPTY
123385: LIST
123386: LIST
123387: PUSH
123388: LD_INT 2
123390: PUSH
123391: LD_INT 30
123393: PUSH
123394: LD_INT 0
123396: PUSH
123397: EMPTY
123398: LIST
123399: LIST
123400: PUSH
123401: LD_INT 30
123403: PUSH
123404: LD_INT 1
123406: PUSH
123407: EMPTY
123408: LIST
123409: LIST
123410: PUSH
123411: EMPTY
123412: LIST
123413: LIST
123414: LIST
123415: PUSH
123416: EMPTY
123417: LIST
123418: LIST
123419: PPUSH
123420: CALL_OW 69
123424: ST_TO_ADDR
// if not tmp then
123425: LD_VAR 0 4
123429: NOT
123430: IFFALSE 123434
// exit ;
123432: GO 123493
// for i in tmp do
123434: LD_ADDR_VAR 0 2
123438: PUSH
123439: LD_VAR 0 4
123443: PUSH
123444: FOR_IN
123445: IFFALSE 123491
// for j = 1 to 3 do
123447: LD_ADDR_VAR 0 3
123451: PUSH
123452: DOUBLE
123453: LD_INT 1
123455: DEC
123456: ST_TO_ADDR
123457: LD_INT 3
123459: PUSH
123460: FOR_TO
123461: IFFALSE 123487
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
123463: LD_VAR 0 2
123467: PPUSH
123468: CALL_OW 274
123472: PPUSH
123473: LD_VAR 0 3
123477: PPUSH
123478: LD_INT 99999
123480: PPUSH
123481: CALL_OW 277
123485: GO 123460
123487: POP
123488: POP
123489: GO 123444
123491: POP
123492: POP
// end ;
123493: LD_VAR 0 1
123497: RET
// export function hHackSetLevel10 ; var i , j ; begin
123498: LD_INT 0
123500: PPUSH
123501: PPUSH
123502: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123503: LD_ADDR_VAR 0 2
123507: PUSH
123508: LD_INT 21
123510: PUSH
123511: LD_INT 1
123513: PUSH
123514: EMPTY
123515: LIST
123516: LIST
123517: PPUSH
123518: CALL_OW 69
123522: PUSH
123523: FOR_IN
123524: IFFALSE 123576
// if IsSelected ( i ) then
123526: LD_VAR 0 2
123530: PPUSH
123531: CALL_OW 306
123535: IFFALSE 123574
// begin for j := 1 to 4 do
123537: LD_ADDR_VAR 0 3
123541: PUSH
123542: DOUBLE
123543: LD_INT 1
123545: DEC
123546: ST_TO_ADDR
123547: LD_INT 4
123549: PUSH
123550: FOR_TO
123551: IFFALSE 123572
// SetSkill ( i , j , 10 ) ;
123553: LD_VAR 0 2
123557: PPUSH
123558: LD_VAR 0 3
123562: PPUSH
123563: LD_INT 10
123565: PPUSH
123566: CALL_OW 237
123570: GO 123550
123572: POP
123573: POP
// end ;
123574: GO 123523
123576: POP
123577: POP
// end ;
123578: LD_VAR 0 1
123582: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
123583: LD_INT 0
123585: PPUSH
123586: PPUSH
123587: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
123588: LD_ADDR_VAR 0 2
123592: PUSH
123593: LD_INT 22
123595: PUSH
123596: LD_OWVAR 2
123600: PUSH
123601: EMPTY
123602: LIST
123603: LIST
123604: PUSH
123605: LD_INT 21
123607: PUSH
123608: LD_INT 1
123610: PUSH
123611: EMPTY
123612: LIST
123613: LIST
123614: PUSH
123615: EMPTY
123616: LIST
123617: LIST
123618: PPUSH
123619: CALL_OW 69
123623: PUSH
123624: FOR_IN
123625: IFFALSE 123666
// begin for j := 1 to 4 do
123627: LD_ADDR_VAR 0 3
123631: PUSH
123632: DOUBLE
123633: LD_INT 1
123635: DEC
123636: ST_TO_ADDR
123637: LD_INT 4
123639: PUSH
123640: FOR_TO
123641: IFFALSE 123662
// SetSkill ( i , j , 10 ) ;
123643: LD_VAR 0 2
123647: PPUSH
123648: LD_VAR 0 3
123652: PPUSH
123653: LD_INT 10
123655: PPUSH
123656: CALL_OW 237
123660: GO 123640
123662: POP
123663: POP
// end ;
123664: GO 123624
123666: POP
123667: POP
// end ;
123668: LD_VAR 0 1
123672: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
123673: LD_INT 0
123675: PPUSH
// uc_side := your_side ;
123676: LD_ADDR_OWVAR 20
123680: PUSH
123681: LD_OWVAR 2
123685: ST_TO_ADDR
// uc_nation := nation ;
123686: LD_ADDR_OWVAR 21
123690: PUSH
123691: LD_VAR 0 1
123695: ST_TO_ADDR
// InitHc ;
123696: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
123700: LD_INT 0
123702: PPUSH
123703: LD_VAR 0 2
123707: PPUSH
123708: LD_VAR 0 3
123712: PPUSH
123713: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
123717: LD_VAR 0 4
123721: PPUSH
123722: LD_VAR 0 5
123726: PPUSH
123727: CALL_OW 428
123731: PUSH
123732: LD_INT 0
123734: EQUAL
123735: IFFALSE 123759
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
123737: CALL_OW 44
123741: PPUSH
123742: LD_VAR 0 4
123746: PPUSH
123747: LD_VAR 0 5
123751: PPUSH
123752: LD_INT 1
123754: PPUSH
123755: CALL_OW 48
// end ;
123759: LD_VAR 0 6
123763: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
123764: LD_INT 0
123766: PPUSH
123767: PPUSH
// uc_side := your_side ;
123768: LD_ADDR_OWVAR 20
123772: PUSH
123773: LD_OWVAR 2
123777: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
123778: LD_VAR 0 1
123782: PUSH
123783: LD_INT 1
123785: PUSH
123786: LD_INT 2
123788: PUSH
123789: LD_INT 3
123791: PUSH
123792: LD_INT 4
123794: PUSH
123795: LD_INT 5
123797: PUSH
123798: EMPTY
123799: LIST
123800: LIST
123801: LIST
123802: LIST
123803: LIST
123804: IN
123805: IFFALSE 123817
// uc_nation := nation_american else
123807: LD_ADDR_OWVAR 21
123811: PUSH
123812: LD_INT 1
123814: ST_TO_ADDR
123815: GO 123860
// if chassis in [ 11 , 12 , 13 , 14 ] then
123817: LD_VAR 0 1
123821: PUSH
123822: LD_INT 11
123824: PUSH
123825: LD_INT 12
123827: PUSH
123828: LD_INT 13
123830: PUSH
123831: LD_INT 14
123833: PUSH
123834: EMPTY
123835: LIST
123836: LIST
123837: LIST
123838: LIST
123839: IN
123840: IFFALSE 123852
// uc_nation := nation_arabian else
123842: LD_ADDR_OWVAR 21
123846: PUSH
123847: LD_INT 2
123849: ST_TO_ADDR
123850: GO 123860
// uc_nation := nation_russian ;
123852: LD_ADDR_OWVAR 21
123856: PUSH
123857: LD_INT 3
123859: ST_TO_ADDR
// vc_chassis := chassis ;
123860: LD_ADDR_OWVAR 37
123864: PUSH
123865: LD_VAR 0 1
123869: ST_TO_ADDR
// vc_engine := engine ;
123870: LD_ADDR_OWVAR 39
123874: PUSH
123875: LD_VAR 0 2
123879: ST_TO_ADDR
// vc_control := control ;
123880: LD_ADDR_OWVAR 38
123884: PUSH
123885: LD_VAR 0 3
123889: ST_TO_ADDR
// vc_weapon := weapon ;
123890: LD_ADDR_OWVAR 40
123894: PUSH
123895: LD_VAR 0 4
123899: ST_TO_ADDR
// un := CreateVehicle ;
123900: LD_ADDR_VAR 0 8
123904: PUSH
123905: CALL_OW 45
123909: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
123910: LD_VAR 0 8
123914: PPUSH
123915: LD_INT 0
123917: PPUSH
123918: LD_INT 5
123920: PPUSH
123921: CALL_OW 12
123925: PPUSH
123926: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
123930: LD_VAR 0 8
123934: PPUSH
123935: LD_VAR 0 5
123939: PPUSH
123940: LD_VAR 0 6
123944: PPUSH
123945: LD_INT 1
123947: PPUSH
123948: CALL_OW 48
// end ;
123952: LD_VAR 0 7
123956: RET
// export hInvincible ; every 1 do
123957: GO 123959
123959: DISABLE
// hInvincible := [ ] ;
123960: LD_ADDR_EXP 203
123964: PUSH
123965: EMPTY
123966: ST_TO_ADDR
123967: END
// every 10 do var i ;
123968: GO 123970
123970: DISABLE
123971: LD_INT 0
123973: PPUSH
// begin enable ;
123974: ENABLE
// if not hInvincible then
123975: LD_EXP 203
123979: NOT
123980: IFFALSE 123984
// exit ;
123982: GO 124028
// for i in hInvincible do
123984: LD_ADDR_VAR 0 1
123988: PUSH
123989: LD_EXP 203
123993: PUSH
123994: FOR_IN
123995: IFFALSE 124026
// if GetLives ( i ) < 1000 then
123997: LD_VAR 0 1
124001: PPUSH
124002: CALL_OW 256
124006: PUSH
124007: LD_INT 1000
124009: LESS
124010: IFFALSE 124024
// SetLives ( i , 1000 ) ;
124012: LD_VAR 0 1
124016: PPUSH
124017: LD_INT 1000
124019: PPUSH
124020: CALL_OW 234
124024: GO 123994
124026: POP
124027: POP
// end ;
124028: PPOPN 1
124030: END
// export function hHackInvincible ; var i ; begin
124031: LD_INT 0
124033: PPUSH
124034: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
124035: LD_ADDR_VAR 0 2
124039: PUSH
124040: LD_INT 2
124042: PUSH
124043: LD_INT 21
124045: PUSH
124046: LD_INT 1
124048: PUSH
124049: EMPTY
124050: LIST
124051: LIST
124052: PUSH
124053: LD_INT 21
124055: PUSH
124056: LD_INT 2
124058: PUSH
124059: EMPTY
124060: LIST
124061: LIST
124062: PUSH
124063: EMPTY
124064: LIST
124065: LIST
124066: LIST
124067: PPUSH
124068: CALL_OW 69
124072: PUSH
124073: FOR_IN
124074: IFFALSE 124135
// if IsSelected ( i ) then
124076: LD_VAR 0 2
124080: PPUSH
124081: CALL_OW 306
124085: IFFALSE 124133
// begin if i in hInvincible then
124087: LD_VAR 0 2
124091: PUSH
124092: LD_EXP 203
124096: IN
124097: IFFALSE 124117
// hInvincible := hInvincible diff i else
124099: LD_ADDR_EXP 203
124103: PUSH
124104: LD_EXP 203
124108: PUSH
124109: LD_VAR 0 2
124113: DIFF
124114: ST_TO_ADDR
124115: GO 124133
// hInvincible := hInvincible union i ;
124117: LD_ADDR_EXP 203
124121: PUSH
124122: LD_EXP 203
124126: PUSH
124127: LD_VAR 0 2
124131: UNION
124132: ST_TO_ADDR
// end ;
124133: GO 124073
124135: POP
124136: POP
// end ;
124137: LD_VAR 0 1
124141: RET
// export function hHackInvisible ; var i , j ; begin
124142: LD_INT 0
124144: PPUSH
124145: PPUSH
124146: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
124147: LD_ADDR_VAR 0 2
124151: PUSH
124152: LD_INT 21
124154: PUSH
124155: LD_INT 1
124157: PUSH
124158: EMPTY
124159: LIST
124160: LIST
124161: PPUSH
124162: CALL_OW 69
124166: PUSH
124167: FOR_IN
124168: IFFALSE 124192
// if IsSelected ( i ) then
124170: LD_VAR 0 2
124174: PPUSH
124175: CALL_OW 306
124179: IFFALSE 124190
// ComForceInvisible ( i ) ;
124181: LD_VAR 0 2
124185: PPUSH
124186: CALL_OW 496
124190: GO 124167
124192: POP
124193: POP
// end ;
124194: LD_VAR 0 1
124198: RET
// export function hHackChangeYourSide ; begin
124199: LD_INT 0
124201: PPUSH
// if your_side = 8 then
124202: LD_OWVAR 2
124206: PUSH
124207: LD_INT 8
124209: EQUAL
124210: IFFALSE 124222
// your_side := 0 else
124212: LD_ADDR_OWVAR 2
124216: PUSH
124217: LD_INT 0
124219: ST_TO_ADDR
124220: GO 124236
// your_side := your_side + 1 ;
124222: LD_ADDR_OWVAR 2
124226: PUSH
124227: LD_OWVAR 2
124231: PUSH
124232: LD_INT 1
124234: PLUS
124235: ST_TO_ADDR
// end ;
124236: LD_VAR 0 1
124240: RET
// export function hHackChangeUnitSide ; var i , j ; begin
124241: LD_INT 0
124243: PPUSH
124244: PPUSH
124245: PPUSH
// for i in all_units do
124246: LD_ADDR_VAR 0 2
124250: PUSH
124251: LD_OWVAR 3
124255: PUSH
124256: FOR_IN
124257: IFFALSE 124335
// if IsSelected ( i ) then
124259: LD_VAR 0 2
124263: PPUSH
124264: CALL_OW 306
124268: IFFALSE 124333
// begin j := GetSide ( i ) ;
124270: LD_ADDR_VAR 0 3
124274: PUSH
124275: LD_VAR 0 2
124279: PPUSH
124280: CALL_OW 255
124284: ST_TO_ADDR
// if j = 8 then
124285: LD_VAR 0 3
124289: PUSH
124290: LD_INT 8
124292: EQUAL
124293: IFFALSE 124305
// j := 0 else
124295: LD_ADDR_VAR 0 3
124299: PUSH
124300: LD_INT 0
124302: ST_TO_ADDR
124303: GO 124319
// j := j + 1 ;
124305: LD_ADDR_VAR 0 3
124309: PUSH
124310: LD_VAR 0 3
124314: PUSH
124315: LD_INT 1
124317: PLUS
124318: ST_TO_ADDR
// SetSide ( i , j ) ;
124319: LD_VAR 0 2
124323: PPUSH
124324: LD_VAR 0 3
124328: PPUSH
124329: CALL_OW 235
// end ;
124333: GO 124256
124335: POP
124336: POP
// end ;
124337: LD_VAR 0 1
124341: RET
// export function hHackFog ; begin
124342: LD_INT 0
124344: PPUSH
// FogOff ( true ) ;
124345: LD_INT 1
124347: PPUSH
124348: CALL_OW 344
// end ;
124352: LD_VAR 0 1
124356: RET
// export function hHackTeleport ( unit , x , y ) ; begin
124357: LD_INT 0
124359: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
124360: LD_VAR 0 1
124364: PPUSH
124365: LD_VAR 0 2
124369: PPUSH
124370: LD_VAR 0 3
124374: PPUSH
124375: LD_INT 1
124377: PPUSH
124378: LD_INT 1
124380: PPUSH
124381: CALL_OW 483
// CenterOnXY ( x , y ) ;
124385: LD_VAR 0 2
124389: PPUSH
124390: LD_VAR 0 3
124394: PPUSH
124395: CALL_OW 84
// end ;
124399: LD_VAR 0 4
124403: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
124404: LD_INT 0
124406: PPUSH
124407: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
124408: LD_VAR 0 1
124412: NOT
124413: PUSH
124414: LD_VAR 0 2
124418: PPUSH
124419: LD_VAR 0 3
124423: PPUSH
124424: CALL_OW 488
124428: NOT
124429: OR
124430: PUSH
124431: LD_VAR 0 1
124435: PPUSH
124436: CALL_OW 266
124440: PUSH
124441: LD_INT 3
124443: NONEQUAL
124444: PUSH
124445: LD_VAR 0 1
124449: PPUSH
124450: CALL_OW 247
124454: PUSH
124455: LD_INT 1
124457: EQUAL
124458: NOT
124459: AND
124460: OR
124461: IFFALSE 124465
// exit ;
124463: GO 124614
// if GetType ( factory ) = unit_human then
124465: LD_VAR 0 1
124469: PPUSH
124470: CALL_OW 247
124474: PUSH
124475: LD_INT 1
124477: EQUAL
124478: IFFALSE 124495
// factory := IsInUnit ( factory ) ;
124480: LD_ADDR_VAR 0 1
124484: PUSH
124485: LD_VAR 0 1
124489: PPUSH
124490: CALL_OW 310
124494: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
124495: LD_VAR 0 1
124499: PPUSH
124500: CALL_OW 266
124504: PUSH
124505: LD_INT 3
124507: NONEQUAL
124508: IFFALSE 124512
// exit ;
124510: GO 124614
// if HexInfo ( x , y ) = factory then
124512: LD_VAR 0 2
124516: PPUSH
124517: LD_VAR 0 3
124521: PPUSH
124522: CALL_OW 428
124526: PUSH
124527: LD_VAR 0 1
124531: EQUAL
124532: IFFALSE 124559
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
124534: LD_ADDR_EXP 204
124538: PUSH
124539: LD_EXP 204
124543: PPUSH
124544: LD_VAR 0 1
124548: PPUSH
124549: LD_INT 0
124551: PPUSH
124552: CALL_OW 1
124556: ST_TO_ADDR
124557: GO 124610
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
124559: LD_ADDR_EXP 204
124563: PUSH
124564: LD_EXP 204
124568: PPUSH
124569: LD_VAR 0 1
124573: PPUSH
124574: LD_VAR 0 1
124578: PPUSH
124579: CALL_OW 255
124583: PUSH
124584: LD_VAR 0 1
124588: PUSH
124589: LD_VAR 0 2
124593: PUSH
124594: LD_VAR 0 3
124598: PUSH
124599: EMPTY
124600: LIST
124601: LIST
124602: LIST
124603: LIST
124604: PPUSH
124605: CALL_OW 1
124609: ST_TO_ADDR
// UpdateFactoryWaypoints ;
124610: CALL 124619 0 0
// end ;
124614: LD_VAR 0 4
124618: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
124619: LD_INT 0
124621: PPUSH
124622: PPUSH
124623: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
124624: LD_STRING resetFactoryWaypoint();
124626: PPUSH
124627: CALL_OW 559
// if factoryWaypoints then
124631: LD_EXP 204
124635: IFFALSE 124761
// begin list := PrepareArray ( factoryWaypoints ) ;
124637: LD_ADDR_VAR 0 3
124641: PUSH
124642: LD_EXP 204
124646: PPUSH
124647: CALL 109607 0 1
124651: ST_TO_ADDR
// for i := 1 to list do
124652: LD_ADDR_VAR 0 2
124656: PUSH
124657: DOUBLE
124658: LD_INT 1
124660: DEC
124661: ST_TO_ADDR
124662: LD_VAR 0 3
124666: PUSH
124667: FOR_TO
124668: IFFALSE 124759
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124670: LD_STRING setFactoryWaypointXY(
124672: PUSH
124673: LD_VAR 0 3
124677: PUSH
124678: LD_VAR 0 2
124682: ARRAY
124683: PUSH
124684: LD_INT 1
124686: ARRAY
124687: STR
124688: PUSH
124689: LD_STRING ,
124691: STR
124692: PUSH
124693: LD_VAR 0 3
124697: PUSH
124698: LD_VAR 0 2
124702: ARRAY
124703: PUSH
124704: LD_INT 2
124706: ARRAY
124707: STR
124708: PUSH
124709: LD_STRING ,
124711: STR
124712: PUSH
124713: LD_VAR 0 3
124717: PUSH
124718: LD_VAR 0 2
124722: ARRAY
124723: PUSH
124724: LD_INT 3
124726: ARRAY
124727: STR
124728: PUSH
124729: LD_STRING ,
124731: STR
124732: PUSH
124733: LD_VAR 0 3
124737: PUSH
124738: LD_VAR 0 2
124742: ARRAY
124743: PUSH
124744: LD_INT 4
124746: ARRAY
124747: STR
124748: PUSH
124749: LD_STRING )
124751: STR
124752: PPUSH
124753: CALL_OW 559
124757: GO 124667
124759: POP
124760: POP
// end ; end ;
124761: LD_VAR 0 1
124765: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
124766: LD_INT 0
124768: PPUSH
// if HexInfo ( x , y ) = warehouse then
124769: LD_VAR 0 2
124773: PPUSH
124774: LD_VAR 0 3
124778: PPUSH
124779: CALL_OW 428
124783: PUSH
124784: LD_VAR 0 1
124788: EQUAL
124789: IFFALSE 124816
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
124791: LD_ADDR_EXP 205
124795: PUSH
124796: LD_EXP 205
124800: PPUSH
124801: LD_VAR 0 1
124805: PPUSH
124806: LD_INT 0
124808: PPUSH
124809: CALL_OW 1
124813: ST_TO_ADDR
124814: GO 124867
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
124816: LD_ADDR_EXP 205
124820: PUSH
124821: LD_EXP 205
124825: PPUSH
124826: LD_VAR 0 1
124830: PPUSH
124831: LD_VAR 0 1
124835: PPUSH
124836: CALL_OW 255
124840: PUSH
124841: LD_VAR 0 1
124845: PUSH
124846: LD_VAR 0 2
124850: PUSH
124851: LD_VAR 0 3
124855: PUSH
124856: EMPTY
124857: LIST
124858: LIST
124859: LIST
124860: LIST
124861: PPUSH
124862: CALL_OW 1
124866: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
124867: CALL 124876 0 0
// end ;
124871: LD_VAR 0 4
124875: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
124876: LD_INT 0
124878: PPUSH
124879: PPUSH
124880: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
124881: LD_STRING resetWarehouseGatheringPoints();
124883: PPUSH
124884: CALL_OW 559
// if warehouseGatheringPoints then
124888: LD_EXP 205
124892: IFFALSE 125018
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
124894: LD_ADDR_VAR 0 3
124898: PUSH
124899: LD_EXP 205
124903: PPUSH
124904: CALL 109607 0 1
124908: ST_TO_ADDR
// for i := 1 to list do
124909: LD_ADDR_VAR 0 2
124913: PUSH
124914: DOUBLE
124915: LD_INT 1
124917: DEC
124918: ST_TO_ADDR
124919: LD_VAR 0 3
124923: PUSH
124924: FOR_TO
124925: IFFALSE 125016
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
124927: LD_STRING setWarehouseGatheringPointXY(
124929: PUSH
124930: LD_VAR 0 3
124934: PUSH
124935: LD_VAR 0 2
124939: ARRAY
124940: PUSH
124941: LD_INT 1
124943: ARRAY
124944: STR
124945: PUSH
124946: LD_STRING ,
124948: STR
124949: PUSH
124950: LD_VAR 0 3
124954: PUSH
124955: LD_VAR 0 2
124959: ARRAY
124960: PUSH
124961: LD_INT 2
124963: ARRAY
124964: STR
124965: PUSH
124966: LD_STRING ,
124968: STR
124969: PUSH
124970: LD_VAR 0 3
124974: PUSH
124975: LD_VAR 0 2
124979: ARRAY
124980: PUSH
124981: LD_INT 3
124983: ARRAY
124984: STR
124985: PUSH
124986: LD_STRING ,
124988: STR
124989: PUSH
124990: LD_VAR 0 3
124994: PUSH
124995: LD_VAR 0 2
124999: ARRAY
125000: PUSH
125001: LD_INT 4
125003: ARRAY
125004: STR
125005: PUSH
125006: LD_STRING )
125008: STR
125009: PPUSH
125010: CALL_OW 559
125014: GO 124924
125016: POP
125017: POP
// end ; end ;
125018: LD_VAR 0 1
125022: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
125023: LD_EXP 205
125027: IFFALSE 125712
125029: GO 125031
125031: DISABLE
125032: LD_INT 0
125034: PPUSH
125035: PPUSH
125036: PPUSH
125037: PPUSH
125038: PPUSH
125039: PPUSH
125040: PPUSH
125041: PPUSH
125042: PPUSH
// begin enable ;
125043: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
125044: LD_ADDR_VAR 0 3
125048: PUSH
125049: LD_EXP 205
125053: PPUSH
125054: CALL 109607 0 1
125058: ST_TO_ADDR
// if not list then
125059: LD_VAR 0 3
125063: NOT
125064: IFFALSE 125068
// exit ;
125066: GO 125712
// for i := 1 to list do
125068: LD_ADDR_VAR 0 1
125072: PUSH
125073: DOUBLE
125074: LD_INT 1
125076: DEC
125077: ST_TO_ADDR
125078: LD_VAR 0 3
125082: PUSH
125083: FOR_TO
125084: IFFALSE 125710
// begin depot := list [ i ] [ 2 ] ;
125086: LD_ADDR_VAR 0 8
125090: PUSH
125091: LD_VAR 0 3
125095: PUSH
125096: LD_VAR 0 1
125100: ARRAY
125101: PUSH
125102: LD_INT 2
125104: ARRAY
125105: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
125106: LD_ADDR_VAR 0 5
125110: PUSH
125111: LD_VAR 0 3
125115: PUSH
125116: LD_VAR 0 1
125120: ARRAY
125121: PUSH
125122: LD_INT 1
125124: ARRAY
125125: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
125126: LD_VAR 0 8
125130: PPUSH
125131: CALL_OW 301
125135: PUSH
125136: LD_VAR 0 5
125140: PUSH
125141: LD_VAR 0 8
125145: PPUSH
125146: CALL_OW 255
125150: NONEQUAL
125151: OR
125152: IFFALSE 125181
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
125154: LD_ADDR_EXP 205
125158: PUSH
125159: LD_EXP 205
125163: PPUSH
125164: LD_VAR 0 8
125168: PPUSH
125169: LD_INT 0
125171: PPUSH
125172: CALL_OW 1
125176: ST_TO_ADDR
// exit ;
125177: POP
125178: POP
125179: GO 125712
// end ; x := list [ i ] [ 3 ] ;
125181: LD_ADDR_VAR 0 6
125185: PUSH
125186: LD_VAR 0 3
125190: PUSH
125191: LD_VAR 0 1
125195: ARRAY
125196: PUSH
125197: LD_INT 3
125199: ARRAY
125200: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
125201: LD_ADDR_VAR 0 7
125205: PUSH
125206: LD_VAR 0 3
125210: PUSH
125211: LD_VAR 0 1
125215: ARRAY
125216: PUSH
125217: LD_INT 4
125219: ARRAY
125220: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
125221: LD_ADDR_VAR 0 9
125225: PUSH
125226: LD_VAR 0 6
125230: PPUSH
125231: LD_VAR 0 7
125235: PPUSH
125236: LD_INT 16
125238: PPUSH
125239: CALL 108195 0 3
125243: ST_TO_ADDR
// if not cratesNearbyPoint then
125244: LD_VAR 0 9
125248: NOT
125249: IFFALSE 125255
// exit ;
125251: POP
125252: POP
125253: GO 125712
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
125255: LD_ADDR_VAR 0 4
125259: PUSH
125260: LD_INT 22
125262: PUSH
125263: LD_VAR 0 5
125267: PUSH
125268: EMPTY
125269: LIST
125270: LIST
125271: PUSH
125272: LD_INT 3
125274: PUSH
125275: LD_INT 60
125277: PUSH
125278: EMPTY
125279: LIST
125280: PUSH
125281: EMPTY
125282: LIST
125283: LIST
125284: PUSH
125285: LD_INT 91
125287: PUSH
125288: LD_VAR 0 8
125292: PUSH
125293: LD_INT 6
125295: PUSH
125296: EMPTY
125297: LIST
125298: LIST
125299: LIST
125300: PUSH
125301: LD_INT 2
125303: PUSH
125304: LD_INT 25
125306: PUSH
125307: LD_INT 2
125309: PUSH
125310: EMPTY
125311: LIST
125312: LIST
125313: PUSH
125314: LD_INT 25
125316: PUSH
125317: LD_INT 16
125319: PUSH
125320: EMPTY
125321: LIST
125322: LIST
125323: PUSH
125324: EMPTY
125325: LIST
125326: LIST
125327: LIST
125328: PUSH
125329: EMPTY
125330: LIST
125331: LIST
125332: LIST
125333: LIST
125334: PPUSH
125335: CALL_OW 69
125339: PUSH
125340: LD_VAR 0 8
125344: PPUSH
125345: CALL_OW 313
125349: PPUSH
125350: LD_INT 3
125352: PUSH
125353: LD_INT 60
125355: PUSH
125356: EMPTY
125357: LIST
125358: PUSH
125359: EMPTY
125360: LIST
125361: LIST
125362: PUSH
125363: LD_INT 2
125365: PUSH
125366: LD_INT 25
125368: PUSH
125369: LD_INT 2
125371: PUSH
125372: EMPTY
125373: LIST
125374: LIST
125375: PUSH
125376: LD_INT 25
125378: PUSH
125379: LD_INT 16
125381: PUSH
125382: EMPTY
125383: LIST
125384: LIST
125385: PUSH
125386: EMPTY
125387: LIST
125388: LIST
125389: LIST
125390: PUSH
125391: EMPTY
125392: LIST
125393: LIST
125394: PPUSH
125395: CALL_OW 72
125399: UNION
125400: ST_TO_ADDR
// if tmp then
125401: LD_VAR 0 4
125405: IFFALSE 125485
// begin tmp := ShrinkArray ( tmp , 3 ) ;
125407: LD_ADDR_VAR 0 4
125411: PUSH
125412: LD_VAR 0 4
125416: PPUSH
125417: LD_INT 3
125419: PPUSH
125420: CALL 106164 0 2
125424: ST_TO_ADDR
// for j in tmp do
125425: LD_ADDR_VAR 0 2
125429: PUSH
125430: LD_VAR 0 4
125434: PUSH
125435: FOR_IN
125436: IFFALSE 125479
// begin if IsInUnit ( j ) then
125438: LD_VAR 0 2
125442: PPUSH
125443: CALL_OW 310
125447: IFFALSE 125458
// ComExit ( j ) ;
125449: LD_VAR 0 2
125453: PPUSH
125454: CALL 106247 0 1
// AddComCollect ( j , x , y ) ;
125458: LD_VAR 0 2
125462: PPUSH
125463: LD_VAR 0 6
125467: PPUSH
125468: LD_VAR 0 7
125472: PPUSH
125473: CALL_OW 177
// end ;
125477: GO 125435
125479: POP
125480: POP
// exit ;
125481: POP
125482: POP
125483: GO 125712
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
125485: LD_ADDR_VAR 0 4
125489: PUSH
125490: LD_INT 22
125492: PUSH
125493: LD_VAR 0 5
125497: PUSH
125498: EMPTY
125499: LIST
125500: LIST
125501: PUSH
125502: LD_INT 91
125504: PUSH
125505: LD_VAR 0 8
125509: PUSH
125510: LD_INT 8
125512: PUSH
125513: EMPTY
125514: LIST
125515: LIST
125516: LIST
125517: PUSH
125518: LD_INT 2
125520: PUSH
125521: LD_INT 34
125523: PUSH
125524: LD_INT 12
125526: PUSH
125527: EMPTY
125528: LIST
125529: LIST
125530: PUSH
125531: LD_INT 34
125533: PUSH
125534: LD_INT 51
125536: PUSH
125537: EMPTY
125538: LIST
125539: LIST
125540: PUSH
125541: LD_INT 34
125543: PUSH
125544: LD_INT 32
125546: PUSH
125547: EMPTY
125548: LIST
125549: LIST
125550: PUSH
125551: LD_INT 34
125553: PUSH
125554: LD_INT 89
125556: PUSH
125557: EMPTY
125558: LIST
125559: LIST
125560: PUSH
125561: EMPTY
125562: LIST
125563: LIST
125564: LIST
125565: LIST
125566: LIST
125567: PUSH
125568: EMPTY
125569: LIST
125570: LIST
125571: LIST
125572: PPUSH
125573: CALL_OW 69
125577: ST_TO_ADDR
// if tmp then
125578: LD_VAR 0 4
125582: IFFALSE 125708
// begin for j in tmp do
125584: LD_ADDR_VAR 0 2
125588: PUSH
125589: LD_VAR 0 4
125593: PUSH
125594: FOR_IN
125595: IFFALSE 125706
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
125597: LD_VAR 0 2
125601: PPUSH
125602: CALL_OW 262
125606: PUSH
125607: LD_INT 3
125609: EQUAL
125610: PUSH
125611: LD_VAR 0 2
125615: PPUSH
125616: CALL_OW 261
125620: PUSH
125621: LD_INT 20
125623: GREATER
125624: OR
125625: PUSH
125626: LD_VAR 0 2
125630: PPUSH
125631: CALL_OW 314
125635: NOT
125636: AND
125637: PUSH
125638: LD_VAR 0 2
125642: PPUSH
125643: CALL_OW 263
125647: PUSH
125648: LD_INT 1
125650: NONEQUAL
125651: PUSH
125652: LD_VAR 0 2
125656: PPUSH
125657: CALL_OW 311
125661: OR
125662: AND
125663: IFFALSE 125704
// begin ComCollect ( j , x , y ) ;
125665: LD_VAR 0 2
125669: PPUSH
125670: LD_VAR 0 6
125674: PPUSH
125675: LD_VAR 0 7
125679: PPUSH
125680: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
125684: LD_VAR 0 2
125688: PPUSH
125689: LD_VAR 0 8
125693: PPUSH
125694: CALL_OW 172
// exit ;
125698: POP
125699: POP
125700: POP
125701: POP
125702: GO 125712
// end ;
125704: GO 125594
125706: POP
125707: POP
// end ; end ;
125708: GO 125083
125710: POP
125711: POP
// end ; end_of_file
125712: PPOPN 9
125714: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
125715: LD_INT 0
125717: PPUSH
125718: PPUSH
125719: PPUSH
125720: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
125721: LD_VAR 0 1
125725: PPUSH
125726: CALL_OW 264
125730: PUSH
125731: LD_INT 91
125733: EQUAL
125734: IFFALSE 125806
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
125736: LD_INT 68
125738: PPUSH
125739: LD_VAR 0 1
125743: PPUSH
125744: CALL_OW 255
125748: PPUSH
125749: CALL_OW 321
125753: PUSH
125754: LD_INT 2
125756: EQUAL
125757: IFFALSE 125769
// eff := 70 else
125759: LD_ADDR_VAR 0 4
125763: PUSH
125764: LD_INT 70
125766: ST_TO_ADDR
125767: GO 125777
// eff := 30 ;
125769: LD_ADDR_VAR 0 4
125773: PUSH
125774: LD_INT 30
125776: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
125777: LD_VAR 0 1
125781: PPUSH
125782: CALL_OW 250
125786: PPUSH
125787: LD_VAR 0 1
125791: PPUSH
125792: CALL_OW 251
125796: PPUSH
125797: LD_VAR 0 4
125801: PPUSH
125802: CALL_OW 495
// end ; end ;
125806: LD_VAR 0 2
125810: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
125811: LD_INT 0
125813: PPUSH
// end ;
125814: LD_VAR 0 4
125818: RET
// export function SOS_Command ( cmd ) ; begin
125819: LD_INT 0
125821: PPUSH
// end ;
125822: LD_VAR 0 2
125826: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
125827: LD_INT 0
125829: PPUSH
// end ;
125830: LD_VAR 0 6
125834: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
125835: LD_INT 0
125837: PPUSH
125838: PPUSH
// if not vehicle or not factory then
125839: LD_VAR 0 1
125843: NOT
125844: PUSH
125845: LD_VAR 0 2
125849: NOT
125850: OR
125851: IFFALSE 125855
// exit ;
125853: GO 126086
// if factoryWaypoints >= factory then
125855: LD_EXP 204
125859: PUSH
125860: LD_VAR 0 2
125864: GREATEREQUAL
125865: IFFALSE 126086
// if factoryWaypoints [ factory ] then
125867: LD_EXP 204
125871: PUSH
125872: LD_VAR 0 2
125876: ARRAY
125877: IFFALSE 126086
// begin if GetControl ( vehicle ) = control_manual then
125879: LD_VAR 0 1
125883: PPUSH
125884: CALL_OW 263
125888: PUSH
125889: LD_INT 1
125891: EQUAL
125892: IFFALSE 125973
// begin driver := IsDrivenBy ( vehicle ) ;
125894: LD_ADDR_VAR 0 4
125898: PUSH
125899: LD_VAR 0 1
125903: PPUSH
125904: CALL_OW 311
125908: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
125909: LD_VAR 0 4
125913: PPUSH
125914: LD_EXP 204
125918: PUSH
125919: LD_VAR 0 2
125923: ARRAY
125924: PUSH
125925: LD_INT 3
125927: ARRAY
125928: PPUSH
125929: LD_EXP 204
125933: PUSH
125934: LD_VAR 0 2
125938: ARRAY
125939: PUSH
125940: LD_INT 4
125942: ARRAY
125943: PPUSH
125944: CALL_OW 171
// AddComExitVehicle ( driver ) ;
125948: LD_VAR 0 4
125952: PPUSH
125953: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
125957: LD_VAR 0 4
125961: PPUSH
125962: LD_VAR 0 2
125966: PPUSH
125967: CALL_OW 180
// end else
125971: GO 126086
// if GetControl ( vehicle ) = control_remote then
125973: LD_VAR 0 1
125977: PPUSH
125978: CALL_OW 263
125982: PUSH
125983: LD_INT 2
125985: EQUAL
125986: IFFALSE 126047
// begin wait ( 0 0$2 ) ;
125988: LD_INT 70
125990: PPUSH
125991: CALL_OW 67
// if Connect ( vehicle ) then
125995: LD_VAR 0 1
125999: PPUSH
126000: CALL 76488 0 1
126004: IFFALSE 126045
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126006: LD_VAR 0 1
126010: PPUSH
126011: LD_EXP 204
126015: PUSH
126016: LD_VAR 0 2
126020: ARRAY
126021: PUSH
126022: LD_INT 3
126024: ARRAY
126025: PPUSH
126026: LD_EXP 204
126030: PUSH
126031: LD_VAR 0 2
126035: ARRAY
126036: PUSH
126037: LD_INT 4
126039: ARRAY
126040: PPUSH
126041: CALL_OW 171
// end else
126045: GO 126086
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126047: LD_VAR 0 1
126051: PPUSH
126052: LD_EXP 204
126056: PUSH
126057: LD_VAR 0 2
126061: ARRAY
126062: PUSH
126063: LD_INT 3
126065: ARRAY
126066: PPUSH
126067: LD_EXP 204
126071: PUSH
126072: LD_VAR 0 2
126076: ARRAY
126077: PUSH
126078: LD_INT 4
126080: ARRAY
126081: PPUSH
126082: CALL_OW 171
// end ; end ;
126086: LD_VAR 0 3
126090: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
126091: LD_INT 0
126093: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
126094: LD_VAR 0 1
126098: PUSH
126099: LD_INT 250
126101: EQUAL
126102: PUSH
126103: LD_VAR 0 2
126107: PPUSH
126108: CALL_OW 264
126112: PUSH
126113: LD_INT 81
126115: EQUAL
126116: AND
126117: IFFALSE 126138
// MinerPlaceMine ( unit , x , y ) ;
126119: LD_VAR 0 2
126123: PPUSH
126124: LD_VAR 0 4
126128: PPUSH
126129: LD_VAR 0 5
126133: PPUSH
126134: CALL 128523 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
126138: LD_VAR 0 1
126142: PUSH
126143: LD_INT 251
126145: EQUAL
126146: PUSH
126147: LD_VAR 0 2
126151: PPUSH
126152: CALL_OW 264
126156: PUSH
126157: LD_INT 81
126159: EQUAL
126160: AND
126161: IFFALSE 126182
// MinerDetonateMine ( unit , x , y ) ;
126163: LD_VAR 0 2
126167: PPUSH
126168: LD_VAR 0 4
126172: PPUSH
126173: LD_VAR 0 5
126177: PPUSH
126178: CALL 128798 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
126182: LD_VAR 0 1
126186: PUSH
126187: LD_INT 252
126189: EQUAL
126190: PUSH
126191: LD_VAR 0 2
126195: PPUSH
126196: CALL_OW 264
126200: PUSH
126201: LD_INT 81
126203: EQUAL
126204: AND
126205: IFFALSE 126226
// MinerCreateMinefield ( unit , x , y ) ;
126207: LD_VAR 0 2
126211: PPUSH
126212: LD_VAR 0 4
126216: PPUSH
126217: LD_VAR 0 5
126221: PPUSH
126222: CALL 129215 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
126226: LD_VAR 0 1
126230: PUSH
126231: LD_INT 253
126233: EQUAL
126234: PUSH
126235: LD_VAR 0 2
126239: PPUSH
126240: CALL_OW 257
126244: PUSH
126245: LD_INT 5
126247: EQUAL
126248: AND
126249: IFFALSE 126270
// ComBinocular ( unit , x , y ) ;
126251: LD_VAR 0 2
126255: PPUSH
126256: LD_VAR 0 4
126260: PPUSH
126261: LD_VAR 0 5
126265: PPUSH
126266: CALL 129584 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
126270: LD_VAR 0 1
126274: PUSH
126275: LD_INT 254
126277: EQUAL
126278: PUSH
126279: LD_VAR 0 2
126283: PPUSH
126284: CALL_OW 264
126288: PUSH
126289: LD_INT 99
126291: EQUAL
126292: AND
126293: PUSH
126294: LD_VAR 0 3
126298: PPUSH
126299: CALL_OW 263
126303: PUSH
126304: LD_INT 3
126306: EQUAL
126307: AND
126308: IFFALSE 126324
// HackDestroyVehicle ( unit , selectedUnit ) ;
126310: LD_VAR 0 2
126314: PPUSH
126315: LD_VAR 0 3
126319: PPUSH
126320: CALL 127887 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
126324: LD_VAR 0 1
126328: PUSH
126329: LD_INT 255
126331: EQUAL
126332: PUSH
126333: LD_VAR 0 2
126337: PPUSH
126338: CALL_OW 264
126342: PUSH
126343: LD_INT 14
126345: PUSH
126346: LD_INT 53
126348: PUSH
126349: EMPTY
126350: LIST
126351: LIST
126352: IN
126353: AND
126354: PUSH
126355: LD_VAR 0 4
126359: PPUSH
126360: LD_VAR 0 5
126364: PPUSH
126365: CALL_OW 488
126369: AND
126370: IFFALSE 126394
// CutTreeXYR ( unit , x , y , 12 ) ;
126372: LD_VAR 0 2
126376: PPUSH
126377: LD_VAR 0 4
126381: PPUSH
126382: LD_VAR 0 5
126386: PPUSH
126387: LD_INT 12
126389: PPUSH
126390: CALL 126457 0 4
// if cmd = 256 then
126394: LD_VAR 0 1
126398: PUSH
126399: LD_INT 256
126401: EQUAL
126402: IFFALSE 126423
// SetFactoryWaypoint ( unit , x , y ) ;
126404: LD_VAR 0 2
126408: PPUSH
126409: LD_VAR 0 4
126413: PPUSH
126414: LD_VAR 0 5
126418: PPUSH
126419: CALL 124404 0 3
// if cmd = 257 then
126423: LD_VAR 0 1
126427: PUSH
126428: LD_INT 257
126430: EQUAL
126431: IFFALSE 126452
// SetWarehouseGatheringPoint ( unit , x , y ) ;
126433: LD_VAR 0 2
126437: PPUSH
126438: LD_VAR 0 4
126442: PPUSH
126443: LD_VAR 0 5
126447: PPUSH
126448: CALL 124766 0 3
// end ;
126452: LD_VAR 0 6
126456: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
126457: LD_INT 0
126459: PPUSH
126460: PPUSH
126461: PPUSH
126462: PPUSH
126463: PPUSH
126464: PPUSH
126465: PPUSH
126466: PPUSH
126467: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
126468: LD_VAR 0 1
126472: NOT
126473: PUSH
126474: LD_VAR 0 2
126478: PPUSH
126479: LD_VAR 0 3
126483: PPUSH
126484: CALL_OW 488
126488: NOT
126489: OR
126490: PUSH
126491: LD_VAR 0 4
126495: NOT
126496: OR
126497: IFFALSE 126501
// exit ;
126499: GO 126841
// list := [ ] ;
126501: LD_ADDR_VAR 0 13
126505: PUSH
126506: EMPTY
126507: ST_TO_ADDR
// if x - r < 0 then
126508: LD_VAR 0 2
126512: PUSH
126513: LD_VAR 0 4
126517: MINUS
126518: PUSH
126519: LD_INT 0
126521: LESS
126522: IFFALSE 126534
// min_x := 0 else
126524: LD_ADDR_VAR 0 7
126528: PUSH
126529: LD_INT 0
126531: ST_TO_ADDR
126532: GO 126550
// min_x := x - r ;
126534: LD_ADDR_VAR 0 7
126538: PUSH
126539: LD_VAR 0 2
126543: PUSH
126544: LD_VAR 0 4
126548: MINUS
126549: ST_TO_ADDR
// if y - r < 0 then
126550: LD_VAR 0 3
126554: PUSH
126555: LD_VAR 0 4
126559: MINUS
126560: PUSH
126561: LD_INT 0
126563: LESS
126564: IFFALSE 126576
// min_y := 0 else
126566: LD_ADDR_VAR 0 8
126570: PUSH
126571: LD_INT 0
126573: ST_TO_ADDR
126574: GO 126592
// min_y := y - r ;
126576: LD_ADDR_VAR 0 8
126580: PUSH
126581: LD_VAR 0 3
126585: PUSH
126586: LD_VAR 0 4
126590: MINUS
126591: ST_TO_ADDR
// max_x := x + r ;
126592: LD_ADDR_VAR 0 9
126596: PUSH
126597: LD_VAR 0 2
126601: PUSH
126602: LD_VAR 0 4
126606: PLUS
126607: ST_TO_ADDR
// max_y := y + r ;
126608: LD_ADDR_VAR 0 10
126612: PUSH
126613: LD_VAR 0 3
126617: PUSH
126618: LD_VAR 0 4
126622: PLUS
126623: ST_TO_ADDR
// for _x = min_x to max_x do
126624: LD_ADDR_VAR 0 11
126628: PUSH
126629: DOUBLE
126630: LD_VAR 0 7
126634: DEC
126635: ST_TO_ADDR
126636: LD_VAR 0 9
126640: PUSH
126641: FOR_TO
126642: IFFALSE 126759
// for _y = min_y to max_y do
126644: LD_ADDR_VAR 0 12
126648: PUSH
126649: DOUBLE
126650: LD_VAR 0 8
126654: DEC
126655: ST_TO_ADDR
126656: LD_VAR 0 10
126660: PUSH
126661: FOR_TO
126662: IFFALSE 126755
// begin if not ValidHex ( _x , _y ) then
126664: LD_VAR 0 11
126668: PPUSH
126669: LD_VAR 0 12
126673: PPUSH
126674: CALL_OW 488
126678: NOT
126679: IFFALSE 126683
// continue ;
126681: GO 126661
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
126683: LD_VAR 0 11
126687: PPUSH
126688: LD_VAR 0 12
126692: PPUSH
126693: CALL_OW 351
126697: PUSH
126698: LD_VAR 0 11
126702: PPUSH
126703: LD_VAR 0 12
126707: PPUSH
126708: CALL_OW 554
126712: AND
126713: IFFALSE 126753
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
126715: LD_ADDR_VAR 0 13
126719: PUSH
126720: LD_VAR 0 13
126724: PPUSH
126725: LD_VAR 0 13
126729: PUSH
126730: LD_INT 1
126732: PLUS
126733: PPUSH
126734: LD_VAR 0 11
126738: PUSH
126739: LD_VAR 0 12
126743: PUSH
126744: EMPTY
126745: LIST
126746: LIST
126747: PPUSH
126748: CALL_OW 2
126752: ST_TO_ADDR
// end ;
126753: GO 126661
126755: POP
126756: POP
126757: GO 126641
126759: POP
126760: POP
// if not list then
126761: LD_VAR 0 13
126765: NOT
126766: IFFALSE 126770
// exit ;
126768: GO 126841
// for i in list do
126770: LD_ADDR_VAR 0 6
126774: PUSH
126775: LD_VAR 0 13
126779: PUSH
126780: FOR_IN
126781: IFFALSE 126839
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
126783: LD_VAR 0 1
126787: PPUSH
126788: LD_STRING M
126790: PUSH
126791: LD_VAR 0 6
126795: PUSH
126796: LD_INT 1
126798: ARRAY
126799: PUSH
126800: LD_VAR 0 6
126804: PUSH
126805: LD_INT 2
126807: ARRAY
126808: PUSH
126809: LD_INT 0
126811: PUSH
126812: LD_INT 0
126814: PUSH
126815: LD_INT 0
126817: PUSH
126818: LD_INT 0
126820: PUSH
126821: EMPTY
126822: LIST
126823: LIST
126824: LIST
126825: LIST
126826: LIST
126827: LIST
126828: LIST
126829: PUSH
126830: EMPTY
126831: LIST
126832: PPUSH
126833: CALL_OW 447
126837: GO 126780
126839: POP
126840: POP
// end ;
126841: LD_VAR 0 5
126845: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
126846: LD_EXP 207
126850: NOT
126851: IFFALSE 126901
126853: GO 126855
126855: DISABLE
// begin initHack := true ;
126856: LD_ADDR_EXP 207
126860: PUSH
126861: LD_INT 1
126863: ST_TO_ADDR
// hackTanks := [ ] ;
126864: LD_ADDR_EXP 208
126868: PUSH
126869: EMPTY
126870: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
126871: LD_ADDR_EXP 209
126875: PUSH
126876: EMPTY
126877: ST_TO_ADDR
// hackLimit := 3 ;
126878: LD_ADDR_EXP 210
126882: PUSH
126883: LD_INT 3
126885: ST_TO_ADDR
// hackDist := 12 ;
126886: LD_ADDR_EXP 211
126890: PUSH
126891: LD_INT 12
126893: ST_TO_ADDR
// hackCounter := [ ] ;
126894: LD_ADDR_EXP 212
126898: PUSH
126899: EMPTY
126900: ST_TO_ADDR
// end ;
126901: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
126902: LD_EXP 207
126906: PUSH
126907: LD_INT 34
126909: PUSH
126910: LD_INT 99
126912: PUSH
126913: EMPTY
126914: LIST
126915: LIST
126916: PPUSH
126917: CALL_OW 69
126921: AND
126922: IFFALSE 127175
126924: GO 126926
126926: DISABLE
126927: LD_INT 0
126929: PPUSH
126930: PPUSH
// begin enable ;
126931: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
126932: LD_ADDR_VAR 0 1
126936: PUSH
126937: LD_INT 34
126939: PUSH
126940: LD_INT 99
126942: PUSH
126943: EMPTY
126944: LIST
126945: LIST
126946: PPUSH
126947: CALL_OW 69
126951: PUSH
126952: FOR_IN
126953: IFFALSE 127173
// begin if not i in hackTanks then
126955: LD_VAR 0 1
126959: PUSH
126960: LD_EXP 208
126964: IN
126965: NOT
126966: IFFALSE 127049
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
126968: LD_ADDR_EXP 208
126972: PUSH
126973: LD_EXP 208
126977: PPUSH
126978: LD_EXP 208
126982: PUSH
126983: LD_INT 1
126985: PLUS
126986: PPUSH
126987: LD_VAR 0 1
126991: PPUSH
126992: CALL_OW 1
126996: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
126997: LD_ADDR_EXP 209
127001: PUSH
127002: LD_EXP 209
127006: PPUSH
127007: LD_EXP 209
127011: PUSH
127012: LD_INT 1
127014: PLUS
127015: PPUSH
127016: EMPTY
127017: PPUSH
127018: CALL_OW 1
127022: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
127023: LD_ADDR_EXP 212
127027: PUSH
127028: LD_EXP 212
127032: PPUSH
127033: LD_EXP 212
127037: PUSH
127038: LD_INT 1
127040: PLUS
127041: PPUSH
127042: EMPTY
127043: PPUSH
127044: CALL_OW 1
127048: ST_TO_ADDR
// end ; if not IsOk ( i ) then
127049: LD_VAR 0 1
127053: PPUSH
127054: CALL_OW 302
127058: NOT
127059: IFFALSE 127072
// begin HackUnlinkAll ( i ) ;
127061: LD_VAR 0 1
127065: PPUSH
127066: CALL 127178 0 1
// continue ;
127070: GO 126952
// end ; HackCheckCapturedStatus ( i ) ;
127072: LD_VAR 0 1
127076: PPUSH
127077: CALL 127621 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
127081: LD_ADDR_VAR 0 2
127085: PUSH
127086: LD_INT 81
127088: PUSH
127089: LD_VAR 0 1
127093: PPUSH
127094: CALL_OW 255
127098: PUSH
127099: EMPTY
127100: LIST
127101: LIST
127102: PUSH
127103: LD_INT 33
127105: PUSH
127106: LD_INT 3
127108: PUSH
127109: EMPTY
127110: LIST
127111: LIST
127112: PUSH
127113: LD_INT 91
127115: PUSH
127116: LD_VAR 0 1
127120: PUSH
127121: LD_EXP 211
127125: PUSH
127126: EMPTY
127127: LIST
127128: LIST
127129: LIST
127130: PUSH
127131: LD_INT 50
127133: PUSH
127134: EMPTY
127135: LIST
127136: PUSH
127137: EMPTY
127138: LIST
127139: LIST
127140: LIST
127141: LIST
127142: PPUSH
127143: CALL_OW 69
127147: ST_TO_ADDR
// if not tmp then
127148: LD_VAR 0 2
127152: NOT
127153: IFFALSE 127157
// continue ;
127155: GO 126952
// HackLink ( i , tmp ) ;
127157: LD_VAR 0 1
127161: PPUSH
127162: LD_VAR 0 2
127166: PPUSH
127167: CALL 127314 0 2
// end ;
127171: GO 126952
127173: POP
127174: POP
// end ;
127175: PPOPN 2
127177: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
127178: LD_INT 0
127180: PPUSH
127181: PPUSH
127182: PPUSH
// if not hack in hackTanks then
127183: LD_VAR 0 1
127187: PUSH
127188: LD_EXP 208
127192: IN
127193: NOT
127194: IFFALSE 127198
// exit ;
127196: GO 127309
// index := GetElementIndex ( hackTanks , hack ) ;
127198: LD_ADDR_VAR 0 4
127202: PUSH
127203: LD_EXP 208
127207: PPUSH
127208: LD_VAR 0 1
127212: PPUSH
127213: CALL 73304 0 2
127217: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
127218: LD_EXP 209
127222: PUSH
127223: LD_VAR 0 4
127227: ARRAY
127228: IFFALSE 127309
// begin for i in hackTanksCaptured [ index ] do
127230: LD_ADDR_VAR 0 3
127234: PUSH
127235: LD_EXP 209
127239: PUSH
127240: LD_VAR 0 4
127244: ARRAY
127245: PUSH
127246: FOR_IN
127247: IFFALSE 127273
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
127249: LD_VAR 0 3
127253: PUSH
127254: LD_INT 1
127256: ARRAY
127257: PPUSH
127258: LD_VAR 0 3
127262: PUSH
127263: LD_INT 2
127265: ARRAY
127266: PPUSH
127267: CALL_OW 235
127271: GO 127246
127273: POP
127274: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
127275: LD_ADDR_EXP 209
127279: PUSH
127280: LD_EXP 209
127284: PPUSH
127285: LD_VAR 0 4
127289: PPUSH
127290: EMPTY
127291: PPUSH
127292: CALL_OW 1
127296: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
127297: LD_VAR 0 1
127301: PPUSH
127302: LD_INT 0
127304: PPUSH
127305: CALL_OW 505
// end ; end ;
127309: LD_VAR 0 2
127313: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
127314: LD_INT 0
127316: PPUSH
127317: PPUSH
127318: PPUSH
// if not hack in hackTanks or not vehicles then
127319: LD_VAR 0 1
127323: PUSH
127324: LD_EXP 208
127328: IN
127329: NOT
127330: PUSH
127331: LD_VAR 0 2
127335: NOT
127336: OR
127337: IFFALSE 127341
// exit ;
127339: GO 127616
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
127341: LD_ADDR_VAR 0 2
127345: PUSH
127346: LD_VAR 0 1
127350: PPUSH
127351: LD_VAR 0 2
127355: PPUSH
127356: LD_INT 1
127358: PPUSH
127359: LD_INT 1
127361: PPUSH
127362: CALL 73954 0 4
127366: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
127367: LD_ADDR_VAR 0 5
127371: PUSH
127372: LD_EXP 208
127376: PPUSH
127377: LD_VAR 0 1
127381: PPUSH
127382: CALL 73304 0 2
127386: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
127387: LD_EXP 209
127391: PUSH
127392: LD_VAR 0 5
127396: ARRAY
127397: PUSH
127398: LD_EXP 210
127402: LESS
127403: IFFALSE 127592
// begin for i := 1 to vehicles do
127405: LD_ADDR_VAR 0 4
127409: PUSH
127410: DOUBLE
127411: LD_INT 1
127413: DEC
127414: ST_TO_ADDR
127415: LD_VAR 0 2
127419: PUSH
127420: FOR_TO
127421: IFFALSE 127590
// begin if hackTanksCaptured [ index ] = hackLimit then
127423: LD_EXP 209
127427: PUSH
127428: LD_VAR 0 5
127432: ARRAY
127433: PUSH
127434: LD_EXP 210
127438: EQUAL
127439: IFFALSE 127443
// break ;
127441: GO 127590
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
127443: LD_ADDR_EXP 212
127447: PUSH
127448: LD_EXP 212
127452: PPUSH
127453: LD_VAR 0 5
127457: PPUSH
127458: LD_EXP 212
127462: PUSH
127463: LD_VAR 0 5
127467: ARRAY
127468: PUSH
127469: LD_INT 1
127471: PLUS
127472: PPUSH
127473: CALL_OW 1
127477: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
127478: LD_ADDR_EXP 209
127482: PUSH
127483: LD_EXP 209
127487: PPUSH
127488: LD_VAR 0 5
127492: PUSH
127493: LD_EXP 209
127497: PUSH
127498: LD_VAR 0 5
127502: ARRAY
127503: PUSH
127504: LD_INT 1
127506: PLUS
127507: PUSH
127508: EMPTY
127509: LIST
127510: LIST
127511: PPUSH
127512: LD_VAR 0 2
127516: PUSH
127517: LD_VAR 0 4
127521: ARRAY
127522: PUSH
127523: LD_VAR 0 2
127527: PUSH
127528: LD_VAR 0 4
127532: ARRAY
127533: PPUSH
127534: CALL_OW 255
127538: PUSH
127539: EMPTY
127540: LIST
127541: LIST
127542: PPUSH
127543: CALL 73519 0 3
127547: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
127548: LD_VAR 0 2
127552: PUSH
127553: LD_VAR 0 4
127557: ARRAY
127558: PPUSH
127559: LD_VAR 0 1
127563: PPUSH
127564: CALL_OW 255
127568: PPUSH
127569: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
127573: LD_VAR 0 2
127577: PUSH
127578: LD_VAR 0 4
127582: ARRAY
127583: PPUSH
127584: CALL_OW 141
// end ;
127588: GO 127420
127590: POP
127591: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127592: LD_VAR 0 1
127596: PPUSH
127597: LD_EXP 209
127601: PUSH
127602: LD_VAR 0 5
127606: ARRAY
127607: PUSH
127608: LD_INT 0
127610: PLUS
127611: PPUSH
127612: CALL_OW 505
// end ;
127616: LD_VAR 0 3
127620: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
127621: LD_INT 0
127623: PPUSH
127624: PPUSH
127625: PPUSH
127626: PPUSH
// if not hack in hackTanks then
127627: LD_VAR 0 1
127631: PUSH
127632: LD_EXP 208
127636: IN
127637: NOT
127638: IFFALSE 127642
// exit ;
127640: GO 127882
// index := GetElementIndex ( hackTanks , hack ) ;
127642: LD_ADDR_VAR 0 4
127646: PUSH
127647: LD_EXP 208
127651: PPUSH
127652: LD_VAR 0 1
127656: PPUSH
127657: CALL 73304 0 2
127661: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
127662: LD_ADDR_VAR 0 3
127666: PUSH
127667: DOUBLE
127668: LD_EXP 209
127672: PUSH
127673: LD_VAR 0 4
127677: ARRAY
127678: INC
127679: ST_TO_ADDR
127680: LD_INT 1
127682: PUSH
127683: FOR_DOWNTO
127684: IFFALSE 127856
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
127686: LD_ADDR_VAR 0 5
127690: PUSH
127691: LD_EXP 209
127695: PUSH
127696: LD_VAR 0 4
127700: ARRAY
127701: PUSH
127702: LD_VAR 0 3
127706: ARRAY
127707: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
127708: LD_VAR 0 5
127712: PUSH
127713: LD_INT 1
127715: ARRAY
127716: PPUSH
127717: CALL_OW 302
127721: NOT
127722: PUSH
127723: LD_VAR 0 5
127727: PUSH
127728: LD_INT 1
127730: ARRAY
127731: PPUSH
127732: CALL_OW 255
127736: PUSH
127737: LD_VAR 0 1
127741: PPUSH
127742: CALL_OW 255
127746: NONEQUAL
127747: OR
127748: IFFALSE 127854
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
127750: LD_VAR 0 5
127754: PUSH
127755: LD_INT 1
127757: ARRAY
127758: PPUSH
127759: CALL_OW 305
127763: PUSH
127764: LD_VAR 0 5
127768: PUSH
127769: LD_INT 1
127771: ARRAY
127772: PPUSH
127773: CALL_OW 255
127777: PUSH
127778: LD_VAR 0 1
127782: PPUSH
127783: CALL_OW 255
127787: EQUAL
127788: AND
127789: IFFALSE 127813
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
127791: LD_VAR 0 5
127795: PUSH
127796: LD_INT 1
127798: ARRAY
127799: PPUSH
127800: LD_VAR 0 5
127804: PUSH
127805: LD_INT 2
127807: ARRAY
127808: PPUSH
127809: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
127813: LD_ADDR_EXP 209
127817: PUSH
127818: LD_EXP 209
127822: PPUSH
127823: LD_VAR 0 4
127827: PPUSH
127828: LD_EXP 209
127832: PUSH
127833: LD_VAR 0 4
127837: ARRAY
127838: PPUSH
127839: LD_VAR 0 3
127843: PPUSH
127844: CALL_OW 3
127848: PPUSH
127849: CALL_OW 1
127853: ST_TO_ADDR
// end ; end ;
127854: GO 127683
127856: POP
127857: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127858: LD_VAR 0 1
127862: PPUSH
127863: LD_EXP 209
127867: PUSH
127868: LD_VAR 0 4
127872: ARRAY
127873: PUSH
127874: LD_INT 0
127876: PLUS
127877: PPUSH
127878: CALL_OW 505
// end ;
127882: LD_VAR 0 2
127886: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
127887: LD_INT 0
127889: PPUSH
127890: PPUSH
127891: PPUSH
127892: PPUSH
// if not hack in hackTanks then
127893: LD_VAR 0 1
127897: PUSH
127898: LD_EXP 208
127902: IN
127903: NOT
127904: IFFALSE 127908
// exit ;
127906: GO 127993
// index := GetElementIndex ( hackTanks , hack ) ;
127908: LD_ADDR_VAR 0 5
127912: PUSH
127913: LD_EXP 208
127917: PPUSH
127918: LD_VAR 0 1
127922: PPUSH
127923: CALL 73304 0 2
127927: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
127928: LD_ADDR_VAR 0 4
127932: PUSH
127933: DOUBLE
127934: LD_INT 1
127936: DEC
127937: ST_TO_ADDR
127938: LD_EXP 209
127942: PUSH
127943: LD_VAR 0 5
127947: ARRAY
127948: PUSH
127949: FOR_TO
127950: IFFALSE 127991
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
127952: LD_EXP 209
127956: PUSH
127957: LD_VAR 0 5
127961: ARRAY
127962: PUSH
127963: LD_VAR 0 4
127967: ARRAY
127968: PUSH
127969: LD_INT 1
127971: ARRAY
127972: PUSH
127973: LD_VAR 0 2
127977: EQUAL
127978: IFFALSE 127989
// KillUnit ( vehicle ) ;
127980: LD_VAR 0 2
127984: PPUSH
127985: CALL_OW 66
127989: GO 127949
127991: POP
127992: POP
// end ;
127993: LD_VAR 0 3
127997: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
127998: LD_EXP 213
128002: NOT
128003: IFFALSE 128038
128005: GO 128007
128007: DISABLE
// begin initMiner := true ;
128008: LD_ADDR_EXP 213
128012: PUSH
128013: LD_INT 1
128015: ST_TO_ADDR
// minersList := [ ] ;
128016: LD_ADDR_EXP 214
128020: PUSH
128021: EMPTY
128022: ST_TO_ADDR
// minerMinesList := [ ] ;
128023: LD_ADDR_EXP 215
128027: PUSH
128028: EMPTY
128029: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
128030: LD_ADDR_EXP 216
128034: PUSH
128035: LD_INT 5
128037: ST_TO_ADDR
// end ;
128038: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
128039: LD_EXP 213
128043: PUSH
128044: LD_INT 34
128046: PUSH
128047: LD_INT 81
128049: PUSH
128050: EMPTY
128051: LIST
128052: LIST
128053: PPUSH
128054: CALL_OW 69
128058: AND
128059: IFFALSE 128520
128061: GO 128063
128063: DISABLE
128064: LD_INT 0
128066: PPUSH
128067: PPUSH
128068: PPUSH
128069: PPUSH
// begin enable ;
128070: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
128071: LD_ADDR_VAR 0 1
128075: PUSH
128076: LD_INT 34
128078: PUSH
128079: LD_INT 81
128081: PUSH
128082: EMPTY
128083: LIST
128084: LIST
128085: PPUSH
128086: CALL_OW 69
128090: PUSH
128091: FOR_IN
128092: IFFALSE 128164
// begin if not i in minersList then
128094: LD_VAR 0 1
128098: PUSH
128099: LD_EXP 214
128103: IN
128104: NOT
128105: IFFALSE 128162
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
128107: LD_ADDR_EXP 214
128111: PUSH
128112: LD_EXP 214
128116: PPUSH
128117: LD_EXP 214
128121: PUSH
128122: LD_INT 1
128124: PLUS
128125: PPUSH
128126: LD_VAR 0 1
128130: PPUSH
128131: CALL_OW 1
128135: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
128136: LD_ADDR_EXP 215
128140: PUSH
128141: LD_EXP 215
128145: PPUSH
128146: LD_EXP 215
128150: PUSH
128151: LD_INT 1
128153: PLUS
128154: PPUSH
128155: EMPTY
128156: PPUSH
128157: CALL_OW 1
128161: ST_TO_ADDR
// end end ;
128162: GO 128091
128164: POP
128165: POP
// for i := minerMinesList downto 1 do
128166: LD_ADDR_VAR 0 1
128170: PUSH
128171: DOUBLE
128172: LD_EXP 215
128176: INC
128177: ST_TO_ADDR
128178: LD_INT 1
128180: PUSH
128181: FOR_DOWNTO
128182: IFFALSE 128518
// begin if IsLive ( minersList [ i ] ) then
128184: LD_EXP 214
128188: PUSH
128189: LD_VAR 0 1
128193: ARRAY
128194: PPUSH
128195: CALL_OW 300
128199: IFFALSE 128227
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
128201: LD_EXP 214
128205: PUSH
128206: LD_VAR 0 1
128210: ARRAY
128211: PPUSH
128212: LD_EXP 215
128216: PUSH
128217: LD_VAR 0 1
128221: ARRAY
128222: PPUSH
128223: CALL_OW 505
// if not minerMinesList [ i ] then
128227: LD_EXP 215
128231: PUSH
128232: LD_VAR 0 1
128236: ARRAY
128237: NOT
128238: IFFALSE 128242
// continue ;
128240: GO 128181
// for j := minerMinesList [ i ] downto 1 do
128242: LD_ADDR_VAR 0 2
128246: PUSH
128247: DOUBLE
128248: LD_EXP 215
128252: PUSH
128253: LD_VAR 0 1
128257: ARRAY
128258: INC
128259: ST_TO_ADDR
128260: LD_INT 1
128262: PUSH
128263: FOR_DOWNTO
128264: IFFALSE 128514
// begin side := GetSide ( minersList [ i ] ) ;
128266: LD_ADDR_VAR 0 3
128270: PUSH
128271: LD_EXP 214
128275: PUSH
128276: LD_VAR 0 1
128280: ARRAY
128281: PPUSH
128282: CALL_OW 255
128286: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
128287: LD_ADDR_VAR 0 4
128291: PUSH
128292: LD_EXP 215
128296: PUSH
128297: LD_VAR 0 1
128301: ARRAY
128302: PUSH
128303: LD_VAR 0 2
128307: ARRAY
128308: PUSH
128309: LD_INT 1
128311: ARRAY
128312: PPUSH
128313: LD_EXP 215
128317: PUSH
128318: LD_VAR 0 1
128322: ARRAY
128323: PUSH
128324: LD_VAR 0 2
128328: ARRAY
128329: PUSH
128330: LD_INT 2
128332: ARRAY
128333: PPUSH
128334: CALL_OW 428
128338: ST_TO_ADDR
// if not tmp then
128339: LD_VAR 0 4
128343: NOT
128344: IFFALSE 128348
// continue ;
128346: GO 128263
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
128348: LD_VAR 0 4
128352: PUSH
128353: LD_INT 81
128355: PUSH
128356: LD_VAR 0 3
128360: PUSH
128361: EMPTY
128362: LIST
128363: LIST
128364: PPUSH
128365: CALL_OW 69
128369: IN
128370: PUSH
128371: LD_EXP 215
128375: PUSH
128376: LD_VAR 0 1
128380: ARRAY
128381: PUSH
128382: LD_VAR 0 2
128386: ARRAY
128387: PUSH
128388: LD_INT 1
128390: ARRAY
128391: PPUSH
128392: LD_EXP 215
128396: PUSH
128397: LD_VAR 0 1
128401: ARRAY
128402: PUSH
128403: LD_VAR 0 2
128407: ARRAY
128408: PUSH
128409: LD_INT 2
128411: ARRAY
128412: PPUSH
128413: CALL_OW 458
128417: AND
128418: IFFALSE 128512
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
128420: LD_EXP 215
128424: PUSH
128425: LD_VAR 0 1
128429: ARRAY
128430: PUSH
128431: LD_VAR 0 2
128435: ARRAY
128436: PUSH
128437: LD_INT 1
128439: ARRAY
128440: PPUSH
128441: LD_EXP 215
128445: PUSH
128446: LD_VAR 0 1
128450: ARRAY
128451: PUSH
128452: LD_VAR 0 2
128456: ARRAY
128457: PUSH
128458: LD_INT 2
128460: ARRAY
128461: PPUSH
128462: LD_VAR 0 3
128466: PPUSH
128467: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
128471: LD_ADDR_EXP 215
128475: PUSH
128476: LD_EXP 215
128480: PPUSH
128481: LD_VAR 0 1
128485: PPUSH
128486: LD_EXP 215
128490: PUSH
128491: LD_VAR 0 1
128495: ARRAY
128496: PPUSH
128497: LD_VAR 0 2
128501: PPUSH
128502: CALL_OW 3
128506: PPUSH
128507: CALL_OW 1
128511: ST_TO_ADDR
// end ; end ;
128512: GO 128263
128514: POP
128515: POP
// end ;
128516: GO 128181
128518: POP
128519: POP
// end ;
128520: PPOPN 4
128522: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
128523: LD_INT 0
128525: PPUSH
128526: PPUSH
// result := false ;
128527: LD_ADDR_VAR 0 4
128531: PUSH
128532: LD_INT 0
128534: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
128535: LD_VAR 0 1
128539: PPUSH
128540: CALL_OW 264
128544: PUSH
128545: LD_INT 81
128547: EQUAL
128548: NOT
128549: IFFALSE 128553
// exit ;
128551: GO 128793
// index := GetElementIndex ( minersList , unit ) ;
128553: LD_ADDR_VAR 0 5
128557: PUSH
128558: LD_EXP 214
128562: PPUSH
128563: LD_VAR 0 1
128567: PPUSH
128568: CALL 73304 0 2
128572: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
128573: LD_EXP 215
128577: PUSH
128578: LD_VAR 0 5
128582: ARRAY
128583: PUSH
128584: LD_EXP 216
128588: GREATEREQUAL
128589: IFFALSE 128593
// exit ;
128591: GO 128793
// ComMoveXY ( unit , x , y ) ;
128593: LD_VAR 0 1
128597: PPUSH
128598: LD_VAR 0 2
128602: PPUSH
128603: LD_VAR 0 3
128607: PPUSH
128608: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128612: LD_INT 35
128614: PPUSH
128615: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
128619: LD_VAR 0 1
128623: PPUSH
128624: LD_VAR 0 2
128628: PPUSH
128629: LD_VAR 0 3
128633: PPUSH
128634: CALL 104659 0 3
128638: NOT
128639: PUSH
128640: LD_VAR 0 1
128644: PPUSH
128645: CALL_OW 314
128649: AND
128650: IFFALSE 128654
// exit ;
128652: GO 128793
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
128654: LD_VAR 0 2
128658: PPUSH
128659: LD_VAR 0 3
128663: PPUSH
128664: CALL_OW 428
128668: PUSH
128669: LD_VAR 0 1
128673: EQUAL
128674: PUSH
128675: LD_VAR 0 1
128679: PPUSH
128680: CALL_OW 314
128684: NOT
128685: AND
128686: IFFALSE 128612
// PlaySoundXY ( x , y , PlantMine ) ;
128688: LD_VAR 0 2
128692: PPUSH
128693: LD_VAR 0 3
128697: PPUSH
128698: LD_STRING PlantMine
128700: PPUSH
128701: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
128705: LD_VAR 0 2
128709: PPUSH
128710: LD_VAR 0 3
128714: PPUSH
128715: LD_VAR 0 1
128719: PPUSH
128720: CALL_OW 255
128724: PPUSH
128725: LD_INT 0
128727: PPUSH
128728: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
128732: LD_ADDR_EXP 215
128736: PUSH
128737: LD_EXP 215
128741: PPUSH
128742: LD_VAR 0 5
128746: PUSH
128747: LD_EXP 215
128751: PUSH
128752: LD_VAR 0 5
128756: ARRAY
128757: PUSH
128758: LD_INT 1
128760: PLUS
128761: PUSH
128762: EMPTY
128763: LIST
128764: LIST
128765: PPUSH
128766: LD_VAR 0 2
128770: PUSH
128771: LD_VAR 0 3
128775: PUSH
128776: EMPTY
128777: LIST
128778: LIST
128779: PPUSH
128780: CALL 73519 0 3
128784: ST_TO_ADDR
// result := true ;
128785: LD_ADDR_VAR 0 4
128789: PUSH
128790: LD_INT 1
128792: ST_TO_ADDR
// end ;
128793: LD_VAR 0 4
128797: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
128798: LD_INT 0
128800: PPUSH
128801: PPUSH
128802: PPUSH
// if not unit in minersList then
128803: LD_VAR 0 1
128807: PUSH
128808: LD_EXP 214
128812: IN
128813: NOT
128814: IFFALSE 128818
// exit ;
128816: GO 129210
// index := GetElementIndex ( minersList , unit ) ;
128818: LD_ADDR_VAR 0 6
128822: PUSH
128823: LD_EXP 214
128827: PPUSH
128828: LD_VAR 0 1
128832: PPUSH
128833: CALL 73304 0 2
128837: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
128838: LD_ADDR_VAR 0 5
128842: PUSH
128843: DOUBLE
128844: LD_EXP 215
128848: PUSH
128849: LD_VAR 0 6
128853: ARRAY
128854: INC
128855: ST_TO_ADDR
128856: LD_INT 1
128858: PUSH
128859: FOR_DOWNTO
128860: IFFALSE 129021
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
128862: LD_EXP 215
128866: PUSH
128867: LD_VAR 0 6
128871: ARRAY
128872: PUSH
128873: LD_VAR 0 5
128877: ARRAY
128878: PUSH
128879: LD_INT 1
128881: ARRAY
128882: PUSH
128883: LD_VAR 0 2
128887: EQUAL
128888: PUSH
128889: LD_EXP 215
128893: PUSH
128894: LD_VAR 0 6
128898: ARRAY
128899: PUSH
128900: LD_VAR 0 5
128904: ARRAY
128905: PUSH
128906: LD_INT 2
128908: ARRAY
128909: PUSH
128910: LD_VAR 0 3
128914: EQUAL
128915: AND
128916: IFFALSE 129019
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
128918: LD_EXP 215
128922: PUSH
128923: LD_VAR 0 6
128927: ARRAY
128928: PUSH
128929: LD_VAR 0 5
128933: ARRAY
128934: PUSH
128935: LD_INT 1
128937: ARRAY
128938: PPUSH
128939: LD_EXP 215
128943: PUSH
128944: LD_VAR 0 6
128948: ARRAY
128949: PUSH
128950: LD_VAR 0 5
128954: ARRAY
128955: PUSH
128956: LD_INT 2
128958: ARRAY
128959: PPUSH
128960: LD_VAR 0 1
128964: PPUSH
128965: CALL_OW 255
128969: PPUSH
128970: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
128974: LD_ADDR_EXP 215
128978: PUSH
128979: LD_EXP 215
128983: PPUSH
128984: LD_VAR 0 6
128988: PPUSH
128989: LD_EXP 215
128993: PUSH
128994: LD_VAR 0 6
128998: ARRAY
128999: PPUSH
129000: LD_VAR 0 5
129004: PPUSH
129005: CALL_OW 3
129009: PPUSH
129010: CALL_OW 1
129014: ST_TO_ADDR
// exit ;
129015: POP
129016: POP
129017: GO 129210
// end ; end ;
129019: GO 128859
129021: POP
129022: POP
// for i := minerMinesList [ index ] downto 1 do
129023: LD_ADDR_VAR 0 5
129027: PUSH
129028: DOUBLE
129029: LD_EXP 215
129033: PUSH
129034: LD_VAR 0 6
129038: ARRAY
129039: INC
129040: ST_TO_ADDR
129041: LD_INT 1
129043: PUSH
129044: FOR_DOWNTO
129045: IFFALSE 129208
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
129047: LD_EXP 215
129051: PUSH
129052: LD_VAR 0 6
129056: ARRAY
129057: PUSH
129058: LD_VAR 0 5
129062: ARRAY
129063: PUSH
129064: LD_INT 1
129066: ARRAY
129067: PPUSH
129068: LD_EXP 215
129072: PUSH
129073: LD_VAR 0 6
129077: ARRAY
129078: PUSH
129079: LD_VAR 0 5
129083: ARRAY
129084: PUSH
129085: LD_INT 2
129087: ARRAY
129088: PPUSH
129089: LD_VAR 0 2
129093: PPUSH
129094: LD_VAR 0 3
129098: PPUSH
129099: CALL_OW 298
129103: PUSH
129104: LD_INT 6
129106: LESS
129107: IFFALSE 129206
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
129109: LD_EXP 215
129113: PUSH
129114: LD_VAR 0 6
129118: ARRAY
129119: PUSH
129120: LD_VAR 0 5
129124: ARRAY
129125: PUSH
129126: LD_INT 1
129128: ARRAY
129129: PPUSH
129130: LD_EXP 215
129134: PUSH
129135: LD_VAR 0 6
129139: ARRAY
129140: PUSH
129141: LD_VAR 0 5
129145: ARRAY
129146: PUSH
129147: LD_INT 2
129149: ARRAY
129150: PPUSH
129151: LD_VAR 0 1
129155: PPUSH
129156: CALL_OW 255
129160: PPUSH
129161: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
129165: LD_ADDR_EXP 215
129169: PUSH
129170: LD_EXP 215
129174: PPUSH
129175: LD_VAR 0 6
129179: PPUSH
129180: LD_EXP 215
129184: PUSH
129185: LD_VAR 0 6
129189: ARRAY
129190: PPUSH
129191: LD_VAR 0 5
129195: PPUSH
129196: CALL_OW 3
129200: PPUSH
129201: CALL_OW 1
129205: ST_TO_ADDR
// end ; end ;
129206: GO 129044
129208: POP
129209: POP
// end ;
129210: LD_VAR 0 4
129214: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
129215: LD_INT 0
129217: PPUSH
129218: PPUSH
129219: PPUSH
129220: PPUSH
129221: PPUSH
129222: PPUSH
129223: PPUSH
129224: PPUSH
129225: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
129226: LD_VAR 0 1
129230: PPUSH
129231: CALL_OW 264
129235: PUSH
129236: LD_INT 81
129238: EQUAL
129239: NOT
129240: PUSH
129241: LD_VAR 0 1
129245: PUSH
129246: LD_EXP 214
129250: IN
129251: NOT
129252: OR
129253: IFFALSE 129257
// exit ;
129255: GO 129579
// index := GetElementIndex ( minersList , unit ) ;
129257: LD_ADDR_VAR 0 6
129261: PUSH
129262: LD_EXP 214
129266: PPUSH
129267: LD_VAR 0 1
129271: PPUSH
129272: CALL 73304 0 2
129276: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
129277: LD_ADDR_VAR 0 8
129281: PUSH
129282: LD_EXP 216
129286: PUSH
129287: LD_EXP 215
129291: PUSH
129292: LD_VAR 0 6
129296: ARRAY
129297: MINUS
129298: ST_TO_ADDR
// if not minesFreeAmount then
129299: LD_VAR 0 8
129303: NOT
129304: IFFALSE 129308
// exit ;
129306: GO 129579
// tmp := [ ] ;
129308: LD_ADDR_VAR 0 7
129312: PUSH
129313: EMPTY
129314: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
129315: LD_ADDR_VAR 0 5
129319: PUSH
129320: DOUBLE
129321: LD_INT 1
129323: DEC
129324: ST_TO_ADDR
129325: LD_VAR 0 8
129329: PUSH
129330: FOR_TO
129331: IFFALSE 129526
// begin _d := rand ( 0 , 5 ) ;
129333: LD_ADDR_VAR 0 11
129337: PUSH
129338: LD_INT 0
129340: PPUSH
129341: LD_INT 5
129343: PPUSH
129344: CALL_OW 12
129348: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
129349: LD_ADDR_VAR 0 12
129353: PUSH
129354: LD_INT 2
129356: PPUSH
129357: LD_INT 6
129359: PPUSH
129360: CALL_OW 12
129364: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
129365: LD_ADDR_VAR 0 9
129369: PUSH
129370: LD_VAR 0 2
129374: PPUSH
129375: LD_VAR 0 11
129379: PPUSH
129380: LD_VAR 0 12
129384: PPUSH
129385: CALL_OW 272
129389: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
129390: LD_ADDR_VAR 0 10
129394: PUSH
129395: LD_VAR 0 3
129399: PPUSH
129400: LD_VAR 0 11
129404: PPUSH
129405: LD_VAR 0 12
129409: PPUSH
129410: CALL_OW 273
129414: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
129415: LD_VAR 0 9
129419: PPUSH
129420: LD_VAR 0 10
129424: PPUSH
129425: CALL_OW 488
129429: PUSH
129430: LD_VAR 0 9
129434: PUSH
129435: LD_VAR 0 10
129439: PUSH
129440: EMPTY
129441: LIST
129442: LIST
129443: PUSH
129444: LD_VAR 0 7
129448: IN
129449: NOT
129450: AND
129451: PUSH
129452: LD_VAR 0 9
129456: PPUSH
129457: LD_VAR 0 10
129461: PPUSH
129462: CALL_OW 458
129466: NOT
129467: AND
129468: IFFALSE 129510
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
129470: LD_ADDR_VAR 0 7
129474: PUSH
129475: LD_VAR 0 7
129479: PPUSH
129480: LD_VAR 0 7
129484: PUSH
129485: LD_INT 1
129487: PLUS
129488: PPUSH
129489: LD_VAR 0 9
129493: PUSH
129494: LD_VAR 0 10
129498: PUSH
129499: EMPTY
129500: LIST
129501: LIST
129502: PPUSH
129503: CALL_OW 1
129507: ST_TO_ADDR
129508: GO 129524
// i := i - 1 ;
129510: LD_ADDR_VAR 0 5
129514: PUSH
129515: LD_VAR 0 5
129519: PUSH
129520: LD_INT 1
129522: MINUS
129523: ST_TO_ADDR
// end ;
129524: GO 129330
129526: POP
129527: POP
// for i in tmp do
129528: LD_ADDR_VAR 0 5
129532: PUSH
129533: LD_VAR 0 7
129537: PUSH
129538: FOR_IN
129539: IFFALSE 129577
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
129541: LD_VAR 0 1
129545: PPUSH
129546: LD_VAR 0 5
129550: PUSH
129551: LD_INT 1
129553: ARRAY
129554: PPUSH
129555: LD_VAR 0 5
129559: PUSH
129560: LD_INT 2
129562: ARRAY
129563: PPUSH
129564: CALL 128523 0 3
129568: NOT
129569: IFFALSE 129575
// exit ;
129571: POP
129572: POP
129573: GO 129579
129575: GO 129538
129577: POP
129578: POP
// end ;
129579: LD_VAR 0 4
129583: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
129584: LD_INT 0
129586: PPUSH
129587: PPUSH
129588: PPUSH
129589: PPUSH
129590: PPUSH
129591: PPUSH
129592: PPUSH
// if not GetClass ( unit ) = class_sniper then
129593: LD_VAR 0 1
129597: PPUSH
129598: CALL_OW 257
129602: PUSH
129603: LD_INT 5
129605: EQUAL
129606: NOT
129607: IFFALSE 129611
// exit ;
129609: GO 129999
// dist := 8 ;
129611: LD_ADDR_VAR 0 5
129615: PUSH
129616: LD_INT 8
129618: ST_TO_ADDR
// viewRange := 12 ;
129619: LD_ADDR_VAR 0 7
129623: PUSH
129624: LD_INT 12
129626: ST_TO_ADDR
// side := GetSide ( unit ) ;
129627: LD_ADDR_VAR 0 6
129631: PUSH
129632: LD_VAR 0 1
129636: PPUSH
129637: CALL_OW 255
129641: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
129642: LD_INT 61
129644: PPUSH
129645: LD_VAR 0 6
129649: PPUSH
129650: CALL_OW 321
129654: PUSH
129655: LD_INT 2
129657: EQUAL
129658: IFFALSE 129668
// viewRange := 16 ;
129660: LD_ADDR_VAR 0 7
129664: PUSH
129665: LD_INT 16
129667: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
129668: LD_VAR 0 1
129672: PPUSH
129673: LD_VAR 0 2
129677: PPUSH
129678: LD_VAR 0 3
129682: PPUSH
129683: CALL_OW 297
129687: PUSH
129688: LD_VAR 0 5
129692: GREATER
129693: IFFALSE 129772
// begin ComMoveXY ( unit , x , y ) ;
129695: LD_VAR 0 1
129699: PPUSH
129700: LD_VAR 0 2
129704: PPUSH
129705: LD_VAR 0 3
129709: PPUSH
129710: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
129714: LD_INT 35
129716: PPUSH
129717: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
129721: LD_VAR 0 1
129725: PPUSH
129726: LD_VAR 0 2
129730: PPUSH
129731: LD_VAR 0 3
129735: PPUSH
129736: CALL 104659 0 3
129740: NOT
129741: IFFALSE 129745
// exit ;
129743: GO 129999
// until GetDistUnitXY ( unit , x , y ) < dist ;
129745: LD_VAR 0 1
129749: PPUSH
129750: LD_VAR 0 2
129754: PPUSH
129755: LD_VAR 0 3
129759: PPUSH
129760: CALL_OW 297
129764: PUSH
129765: LD_VAR 0 5
129769: LESS
129770: IFFALSE 129714
// end ; ComTurnXY ( unit , x , y ) ;
129772: LD_VAR 0 1
129776: PPUSH
129777: LD_VAR 0 2
129781: PPUSH
129782: LD_VAR 0 3
129786: PPUSH
129787: CALL_OW 118
// wait ( 5 ) ;
129791: LD_INT 5
129793: PPUSH
129794: CALL_OW 67
// _d := GetDir ( unit ) ;
129798: LD_ADDR_VAR 0 10
129802: PUSH
129803: LD_VAR 0 1
129807: PPUSH
129808: CALL_OW 254
129812: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
129813: LD_ADDR_VAR 0 8
129817: PUSH
129818: LD_VAR 0 1
129822: PPUSH
129823: CALL_OW 250
129827: PPUSH
129828: LD_VAR 0 10
129832: PPUSH
129833: LD_VAR 0 5
129837: PPUSH
129838: CALL_OW 272
129842: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
129843: LD_ADDR_VAR 0 9
129847: PUSH
129848: LD_VAR 0 1
129852: PPUSH
129853: CALL_OW 251
129857: PPUSH
129858: LD_VAR 0 10
129862: PPUSH
129863: LD_VAR 0 5
129867: PPUSH
129868: CALL_OW 273
129872: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
129873: LD_VAR 0 8
129877: PPUSH
129878: LD_VAR 0 9
129882: PPUSH
129883: CALL_OW 488
129887: NOT
129888: IFFALSE 129892
// exit ;
129890: GO 129999
// ComAnimCustom ( unit , 1 ) ;
129892: LD_VAR 0 1
129896: PPUSH
129897: LD_INT 1
129899: PPUSH
129900: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
129904: LD_VAR 0 8
129908: PPUSH
129909: LD_VAR 0 9
129913: PPUSH
129914: LD_VAR 0 6
129918: PPUSH
129919: LD_VAR 0 7
129923: PPUSH
129924: CALL_OW 330
// repeat wait ( 1 ) ;
129928: LD_INT 1
129930: PPUSH
129931: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
129935: LD_VAR 0 1
129939: PPUSH
129940: CALL_OW 316
129944: PUSH
129945: LD_VAR 0 1
129949: PPUSH
129950: CALL_OW 314
129954: OR
129955: PUSH
129956: LD_VAR 0 1
129960: PPUSH
129961: CALL_OW 302
129965: NOT
129966: OR
129967: PUSH
129968: LD_VAR 0 1
129972: PPUSH
129973: CALL_OW 301
129977: OR
129978: IFFALSE 129928
// RemoveSeeing ( _x , _y , side ) ;
129980: LD_VAR 0 8
129984: PPUSH
129985: LD_VAR 0 9
129989: PPUSH
129990: LD_VAR 0 6
129994: PPUSH
129995: CALL_OW 331
// end ; end_of_file
129999: LD_VAR 0 4
130003: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
130004: LD_INT 0
130006: PPUSH
130007: PPUSH
130008: PPUSH
130009: PPUSH
130010: PPUSH
130011: PPUSH
130012: PPUSH
130013: PPUSH
130014: PPUSH
130015: PPUSH
130016: PPUSH
130017: PPUSH
130018: PPUSH
130019: PPUSH
130020: PPUSH
130021: PPUSH
130022: PPUSH
130023: PPUSH
130024: PPUSH
130025: PPUSH
130026: PPUSH
130027: PPUSH
130028: PPUSH
130029: PPUSH
130030: PPUSH
130031: PPUSH
130032: PPUSH
130033: PPUSH
130034: PPUSH
130035: PPUSH
130036: PPUSH
130037: PPUSH
130038: PPUSH
130039: PPUSH
// if not list then
130040: LD_VAR 0 1
130044: NOT
130045: IFFALSE 130049
// exit ;
130047: GO 134708
// base := list [ 1 ] ;
130049: LD_ADDR_VAR 0 3
130053: PUSH
130054: LD_VAR 0 1
130058: PUSH
130059: LD_INT 1
130061: ARRAY
130062: ST_TO_ADDR
// group := list [ 2 ] ;
130063: LD_ADDR_VAR 0 4
130067: PUSH
130068: LD_VAR 0 1
130072: PUSH
130073: LD_INT 2
130075: ARRAY
130076: ST_TO_ADDR
// path := list [ 3 ] ;
130077: LD_ADDR_VAR 0 5
130081: PUSH
130082: LD_VAR 0 1
130086: PUSH
130087: LD_INT 3
130089: ARRAY
130090: ST_TO_ADDR
// flags := list [ 4 ] ;
130091: LD_ADDR_VAR 0 6
130095: PUSH
130096: LD_VAR 0 1
130100: PUSH
130101: LD_INT 4
130103: ARRAY
130104: ST_TO_ADDR
// mined := [ ] ;
130105: LD_ADDR_VAR 0 27
130109: PUSH
130110: EMPTY
130111: ST_TO_ADDR
// bombed := [ ] ;
130112: LD_ADDR_VAR 0 28
130116: PUSH
130117: EMPTY
130118: ST_TO_ADDR
// healers := [ ] ;
130119: LD_ADDR_VAR 0 31
130123: PUSH
130124: EMPTY
130125: ST_TO_ADDR
// to_heal := [ ] ;
130126: LD_ADDR_VAR 0 30
130130: PUSH
130131: EMPTY
130132: ST_TO_ADDR
// repairs := [ ] ;
130133: LD_ADDR_VAR 0 33
130137: PUSH
130138: EMPTY
130139: ST_TO_ADDR
// to_repair := [ ] ;
130140: LD_ADDR_VAR 0 32
130144: PUSH
130145: EMPTY
130146: ST_TO_ADDR
// if not group or not path then
130147: LD_VAR 0 4
130151: NOT
130152: PUSH
130153: LD_VAR 0 5
130157: NOT
130158: OR
130159: IFFALSE 130163
// exit ;
130161: GO 134708
// side := GetSide ( group [ 1 ] ) ;
130163: LD_ADDR_VAR 0 35
130167: PUSH
130168: LD_VAR 0 4
130172: PUSH
130173: LD_INT 1
130175: ARRAY
130176: PPUSH
130177: CALL_OW 255
130181: ST_TO_ADDR
// if flags then
130182: LD_VAR 0 6
130186: IFFALSE 130330
// begin f_ignore_area := flags [ 1 ] ;
130188: LD_ADDR_VAR 0 17
130192: PUSH
130193: LD_VAR 0 6
130197: PUSH
130198: LD_INT 1
130200: ARRAY
130201: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
130202: LD_ADDR_VAR 0 18
130206: PUSH
130207: LD_VAR 0 6
130211: PUSH
130212: LD_INT 2
130214: ARRAY
130215: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
130216: LD_ADDR_VAR 0 19
130220: PUSH
130221: LD_VAR 0 6
130225: PUSH
130226: LD_INT 3
130228: ARRAY
130229: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
130230: LD_ADDR_VAR 0 20
130234: PUSH
130235: LD_VAR 0 6
130239: PUSH
130240: LD_INT 4
130242: ARRAY
130243: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
130244: LD_ADDR_VAR 0 21
130248: PUSH
130249: LD_VAR 0 6
130253: PUSH
130254: LD_INT 5
130256: ARRAY
130257: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
130258: LD_ADDR_VAR 0 22
130262: PUSH
130263: LD_VAR 0 6
130267: PUSH
130268: LD_INT 6
130270: ARRAY
130271: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
130272: LD_ADDR_VAR 0 23
130276: PUSH
130277: LD_VAR 0 6
130281: PUSH
130282: LD_INT 7
130284: ARRAY
130285: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
130286: LD_ADDR_VAR 0 24
130290: PUSH
130291: LD_VAR 0 6
130295: PUSH
130296: LD_INT 8
130298: ARRAY
130299: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
130300: LD_ADDR_VAR 0 25
130304: PUSH
130305: LD_VAR 0 6
130309: PUSH
130310: LD_INT 9
130312: ARRAY
130313: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
130314: LD_ADDR_VAR 0 26
130318: PUSH
130319: LD_VAR 0 6
130323: PUSH
130324: LD_INT 10
130326: ARRAY
130327: ST_TO_ADDR
// end else
130328: GO 130410
// begin f_ignore_area := false ;
130330: LD_ADDR_VAR 0 17
130334: PUSH
130335: LD_INT 0
130337: ST_TO_ADDR
// f_capture := false ;
130338: LD_ADDR_VAR 0 18
130342: PUSH
130343: LD_INT 0
130345: ST_TO_ADDR
// f_ignore_civ := false ;
130346: LD_ADDR_VAR 0 19
130350: PUSH
130351: LD_INT 0
130353: ST_TO_ADDR
// f_murder := false ;
130354: LD_ADDR_VAR 0 20
130358: PUSH
130359: LD_INT 0
130361: ST_TO_ADDR
// f_mines := false ;
130362: LD_ADDR_VAR 0 21
130366: PUSH
130367: LD_INT 0
130369: ST_TO_ADDR
// f_repair := false ;
130370: LD_ADDR_VAR 0 22
130374: PUSH
130375: LD_INT 0
130377: ST_TO_ADDR
// f_heal := false ;
130378: LD_ADDR_VAR 0 23
130382: PUSH
130383: LD_INT 0
130385: ST_TO_ADDR
// f_spacetime := false ;
130386: LD_ADDR_VAR 0 24
130390: PUSH
130391: LD_INT 0
130393: ST_TO_ADDR
// f_attack_depot := false ;
130394: LD_ADDR_VAR 0 25
130398: PUSH
130399: LD_INT 0
130401: ST_TO_ADDR
// f_crawl := false ;
130402: LD_ADDR_VAR 0 26
130406: PUSH
130407: LD_INT 0
130409: ST_TO_ADDR
// end ; if f_heal then
130410: LD_VAR 0 23
130414: IFFALSE 130441
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
130416: LD_ADDR_VAR 0 31
130420: PUSH
130421: LD_VAR 0 4
130425: PPUSH
130426: LD_INT 25
130428: PUSH
130429: LD_INT 4
130431: PUSH
130432: EMPTY
130433: LIST
130434: LIST
130435: PPUSH
130436: CALL_OW 72
130440: ST_TO_ADDR
// if f_repair then
130441: LD_VAR 0 22
130445: IFFALSE 130472
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
130447: LD_ADDR_VAR 0 33
130451: PUSH
130452: LD_VAR 0 4
130456: PPUSH
130457: LD_INT 25
130459: PUSH
130460: LD_INT 3
130462: PUSH
130463: EMPTY
130464: LIST
130465: LIST
130466: PPUSH
130467: CALL_OW 72
130471: ST_TO_ADDR
// units_path := [ ] ;
130472: LD_ADDR_VAR 0 16
130476: PUSH
130477: EMPTY
130478: ST_TO_ADDR
// for i = 1 to group do
130479: LD_ADDR_VAR 0 7
130483: PUSH
130484: DOUBLE
130485: LD_INT 1
130487: DEC
130488: ST_TO_ADDR
130489: LD_VAR 0 4
130493: PUSH
130494: FOR_TO
130495: IFFALSE 130524
// units_path := Replace ( units_path , i , path ) ;
130497: LD_ADDR_VAR 0 16
130501: PUSH
130502: LD_VAR 0 16
130506: PPUSH
130507: LD_VAR 0 7
130511: PPUSH
130512: LD_VAR 0 5
130516: PPUSH
130517: CALL_OW 1
130521: ST_TO_ADDR
130522: GO 130494
130524: POP
130525: POP
// repeat for i = group downto 1 do
130526: LD_ADDR_VAR 0 7
130530: PUSH
130531: DOUBLE
130532: LD_VAR 0 4
130536: INC
130537: ST_TO_ADDR
130538: LD_INT 1
130540: PUSH
130541: FOR_DOWNTO
130542: IFFALSE 134664
// begin wait ( 5 ) ;
130544: LD_INT 5
130546: PPUSH
130547: CALL_OW 67
// tmp := [ ] ;
130551: LD_ADDR_VAR 0 14
130555: PUSH
130556: EMPTY
130557: ST_TO_ADDR
// attacking := false ;
130558: LD_ADDR_VAR 0 29
130562: PUSH
130563: LD_INT 0
130565: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
130566: LD_VAR 0 4
130570: PUSH
130571: LD_VAR 0 7
130575: ARRAY
130576: PPUSH
130577: CALL_OW 301
130581: PUSH
130582: LD_VAR 0 4
130586: PUSH
130587: LD_VAR 0 7
130591: ARRAY
130592: NOT
130593: OR
130594: IFFALSE 130703
// begin if GetType ( group [ i ] ) = unit_human then
130596: LD_VAR 0 4
130600: PUSH
130601: LD_VAR 0 7
130605: ARRAY
130606: PPUSH
130607: CALL_OW 247
130611: PUSH
130612: LD_INT 1
130614: EQUAL
130615: IFFALSE 130661
// begin to_heal := to_heal diff group [ i ] ;
130617: LD_ADDR_VAR 0 30
130621: PUSH
130622: LD_VAR 0 30
130626: PUSH
130627: LD_VAR 0 4
130631: PUSH
130632: LD_VAR 0 7
130636: ARRAY
130637: DIFF
130638: ST_TO_ADDR
// healers := healers diff group [ i ] ;
130639: LD_ADDR_VAR 0 31
130643: PUSH
130644: LD_VAR 0 31
130648: PUSH
130649: LD_VAR 0 4
130653: PUSH
130654: LD_VAR 0 7
130658: ARRAY
130659: DIFF
130660: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
130661: LD_ADDR_VAR 0 4
130665: PUSH
130666: LD_VAR 0 4
130670: PPUSH
130671: LD_VAR 0 7
130675: PPUSH
130676: CALL_OW 3
130680: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
130681: LD_ADDR_VAR 0 16
130685: PUSH
130686: LD_VAR 0 16
130690: PPUSH
130691: LD_VAR 0 7
130695: PPUSH
130696: CALL_OW 3
130700: ST_TO_ADDR
// continue ;
130701: GO 130541
// end ; if f_repair then
130703: LD_VAR 0 22
130707: IFFALSE 131196
// begin if GetType ( group [ i ] ) = unit_vehicle then
130709: LD_VAR 0 4
130713: PUSH
130714: LD_VAR 0 7
130718: ARRAY
130719: PPUSH
130720: CALL_OW 247
130724: PUSH
130725: LD_INT 2
130727: EQUAL
130728: IFFALSE 130918
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
130730: LD_VAR 0 4
130734: PUSH
130735: LD_VAR 0 7
130739: ARRAY
130740: PPUSH
130741: CALL_OW 256
130745: PUSH
130746: LD_INT 700
130748: LESS
130749: PUSH
130750: LD_VAR 0 4
130754: PUSH
130755: LD_VAR 0 7
130759: ARRAY
130760: PUSH
130761: LD_VAR 0 32
130765: IN
130766: NOT
130767: AND
130768: IFFALSE 130792
// to_repair := to_repair union group [ i ] ;
130770: LD_ADDR_VAR 0 32
130774: PUSH
130775: LD_VAR 0 32
130779: PUSH
130780: LD_VAR 0 4
130784: PUSH
130785: LD_VAR 0 7
130789: ARRAY
130790: UNION
130791: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
130792: LD_VAR 0 4
130796: PUSH
130797: LD_VAR 0 7
130801: ARRAY
130802: PPUSH
130803: CALL_OW 256
130807: PUSH
130808: LD_INT 1000
130810: EQUAL
130811: PUSH
130812: LD_VAR 0 4
130816: PUSH
130817: LD_VAR 0 7
130821: ARRAY
130822: PUSH
130823: LD_VAR 0 32
130827: IN
130828: AND
130829: IFFALSE 130853
// to_repair := to_repair diff group [ i ] ;
130831: LD_ADDR_VAR 0 32
130835: PUSH
130836: LD_VAR 0 32
130840: PUSH
130841: LD_VAR 0 4
130845: PUSH
130846: LD_VAR 0 7
130850: ARRAY
130851: DIFF
130852: ST_TO_ADDR
// if group [ i ] in to_repair then
130853: LD_VAR 0 4
130857: PUSH
130858: LD_VAR 0 7
130862: ARRAY
130863: PUSH
130864: LD_VAR 0 32
130868: IN
130869: IFFALSE 130916
// begin if not IsInArea ( group [ i ] , f_repair ) then
130871: LD_VAR 0 4
130875: PUSH
130876: LD_VAR 0 7
130880: ARRAY
130881: PPUSH
130882: LD_VAR 0 22
130886: PPUSH
130887: CALL_OW 308
130891: NOT
130892: IFFALSE 130914
// ComMoveToArea ( group [ i ] , f_repair ) ;
130894: LD_VAR 0 4
130898: PUSH
130899: LD_VAR 0 7
130903: ARRAY
130904: PPUSH
130905: LD_VAR 0 22
130909: PPUSH
130910: CALL_OW 113
// continue ;
130914: GO 130541
// end ; end else
130916: GO 131196
// if group [ i ] in repairs then
130918: LD_VAR 0 4
130922: PUSH
130923: LD_VAR 0 7
130927: ARRAY
130928: PUSH
130929: LD_VAR 0 33
130933: IN
130934: IFFALSE 131196
// begin if IsInUnit ( group [ i ] ) then
130936: LD_VAR 0 4
130940: PUSH
130941: LD_VAR 0 7
130945: ARRAY
130946: PPUSH
130947: CALL_OW 310
130951: IFFALSE 131019
// begin z := IsInUnit ( group [ i ] ) ;
130953: LD_ADDR_VAR 0 13
130957: PUSH
130958: LD_VAR 0 4
130962: PUSH
130963: LD_VAR 0 7
130967: ARRAY
130968: PPUSH
130969: CALL_OW 310
130973: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
130974: LD_VAR 0 13
130978: PUSH
130979: LD_VAR 0 32
130983: IN
130984: PUSH
130985: LD_VAR 0 13
130989: PPUSH
130990: LD_VAR 0 22
130994: PPUSH
130995: CALL_OW 308
130999: AND
131000: IFFALSE 131017
// ComExitVehicle ( group [ i ] ) ;
131002: LD_VAR 0 4
131006: PUSH
131007: LD_VAR 0 7
131011: ARRAY
131012: PPUSH
131013: CALL_OW 121
// end else
131017: GO 131196
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
131019: LD_ADDR_VAR 0 13
131023: PUSH
131024: LD_VAR 0 4
131028: PPUSH
131029: LD_INT 95
131031: PUSH
131032: LD_VAR 0 22
131036: PUSH
131037: EMPTY
131038: LIST
131039: LIST
131040: PUSH
131041: LD_INT 58
131043: PUSH
131044: EMPTY
131045: LIST
131046: PUSH
131047: EMPTY
131048: LIST
131049: LIST
131050: PPUSH
131051: CALL_OW 72
131055: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
131056: LD_VAR 0 4
131060: PUSH
131061: LD_VAR 0 7
131065: ARRAY
131066: PPUSH
131067: CALL_OW 314
131071: NOT
131072: IFFALSE 131194
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
131074: LD_ADDR_VAR 0 10
131078: PUSH
131079: LD_VAR 0 13
131083: PPUSH
131084: LD_VAR 0 4
131088: PUSH
131089: LD_VAR 0 7
131093: ARRAY
131094: PPUSH
131095: CALL_OW 74
131099: ST_TO_ADDR
// if not x then
131100: LD_VAR 0 10
131104: NOT
131105: IFFALSE 131109
// continue ;
131107: GO 130541
// if GetLives ( x ) < 1000 then
131109: LD_VAR 0 10
131113: PPUSH
131114: CALL_OW 256
131118: PUSH
131119: LD_INT 1000
131121: LESS
131122: IFFALSE 131146
// ComRepairVehicle ( group [ i ] , x ) else
131124: LD_VAR 0 4
131128: PUSH
131129: LD_VAR 0 7
131133: ARRAY
131134: PPUSH
131135: LD_VAR 0 10
131139: PPUSH
131140: CALL_OW 129
131144: GO 131194
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
131146: LD_VAR 0 23
131150: PUSH
131151: LD_VAR 0 4
131155: PUSH
131156: LD_VAR 0 7
131160: ARRAY
131161: PPUSH
131162: CALL_OW 256
131166: PUSH
131167: LD_INT 1000
131169: LESS
131170: AND
131171: NOT
131172: IFFALSE 131194
// ComEnterUnit ( group [ i ] , x ) ;
131174: LD_VAR 0 4
131178: PUSH
131179: LD_VAR 0 7
131183: ARRAY
131184: PPUSH
131185: LD_VAR 0 10
131189: PPUSH
131190: CALL_OW 120
// end ; continue ;
131194: GO 130541
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
131196: LD_VAR 0 23
131200: PUSH
131201: LD_VAR 0 4
131205: PUSH
131206: LD_VAR 0 7
131210: ARRAY
131211: PPUSH
131212: CALL_OW 247
131216: PUSH
131217: LD_INT 1
131219: EQUAL
131220: AND
131221: IFFALSE 131699
// begin if group [ i ] in healers then
131223: LD_VAR 0 4
131227: PUSH
131228: LD_VAR 0 7
131232: ARRAY
131233: PUSH
131234: LD_VAR 0 31
131238: IN
131239: IFFALSE 131512
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
131241: LD_VAR 0 4
131245: PUSH
131246: LD_VAR 0 7
131250: ARRAY
131251: PPUSH
131252: LD_VAR 0 23
131256: PPUSH
131257: CALL_OW 308
131261: NOT
131262: PUSH
131263: LD_VAR 0 4
131267: PUSH
131268: LD_VAR 0 7
131272: ARRAY
131273: PPUSH
131274: CALL_OW 314
131278: NOT
131279: AND
131280: IFFALSE 131304
// ComMoveToArea ( group [ i ] , f_heal ) else
131282: LD_VAR 0 4
131286: PUSH
131287: LD_VAR 0 7
131291: ARRAY
131292: PPUSH
131293: LD_VAR 0 23
131297: PPUSH
131298: CALL_OW 113
131302: GO 131510
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
131304: LD_VAR 0 4
131308: PUSH
131309: LD_VAR 0 7
131313: ARRAY
131314: PPUSH
131315: CALL 103242 0 1
131319: PPUSH
131320: CALL_OW 256
131324: PUSH
131325: LD_INT 1000
131327: EQUAL
131328: IFFALSE 131347
// ComStop ( group [ i ] ) else
131330: LD_VAR 0 4
131334: PUSH
131335: LD_VAR 0 7
131339: ARRAY
131340: PPUSH
131341: CALL_OW 141
131345: GO 131510
// if not HasTask ( group [ i ] ) and to_heal then
131347: LD_VAR 0 4
131351: PUSH
131352: LD_VAR 0 7
131356: ARRAY
131357: PPUSH
131358: CALL_OW 314
131362: NOT
131363: PUSH
131364: LD_VAR 0 30
131368: AND
131369: IFFALSE 131510
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
131371: LD_ADDR_VAR 0 13
131375: PUSH
131376: LD_VAR 0 30
131380: PPUSH
131381: LD_INT 3
131383: PUSH
131384: LD_INT 54
131386: PUSH
131387: EMPTY
131388: LIST
131389: PUSH
131390: EMPTY
131391: LIST
131392: LIST
131393: PPUSH
131394: CALL_OW 72
131398: PPUSH
131399: LD_VAR 0 4
131403: PUSH
131404: LD_VAR 0 7
131408: ARRAY
131409: PPUSH
131410: CALL_OW 74
131414: ST_TO_ADDR
// if z then
131415: LD_VAR 0 13
131419: IFFALSE 131510
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
131421: LD_INT 91
131423: PUSH
131424: LD_VAR 0 13
131428: PUSH
131429: LD_INT 10
131431: PUSH
131432: EMPTY
131433: LIST
131434: LIST
131435: LIST
131436: PUSH
131437: LD_INT 81
131439: PUSH
131440: LD_VAR 0 13
131444: PPUSH
131445: CALL_OW 255
131449: PUSH
131450: EMPTY
131451: LIST
131452: LIST
131453: PUSH
131454: EMPTY
131455: LIST
131456: LIST
131457: PPUSH
131458: CALL_OW 69
131462: PUSH
131463: LD_INT 0
131465: EQUAL
131466: IFFALSE 131490
// ComHeal ( group [ i ] , z ) else
131468: LD_VAR 0 4
131472: PUSH
131473: LD_VAR 0 7
131477: ARRAY
131478: PPUSH
131479: LD_VAR 0 13
131483: PPUSH
131484: CALL_OW 128
131488: GO 131510
// ComMoveToArea ( group [ i ] , f_heal ) ;
131490: LD_VAR 0 4
131494: PUSH
131495: LD_VAR 0 7
131499: ARRAY
131500: PPUSH
131501: LD_VAR 0 23
131505: PPUSH
131506: CALL_OW 113
// end ; continue ;
131510: GO 130541
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
131512: LD_VAR 0 4
131516: PUSH
131517: LD_VAR 0 7
131521: ARRAY
131522: PPUSH
131523: CALL_OW 256
131527: PUSH
131528: LD_INT 700
131530: LESS
131531: PUSH
131532: LD_VAR 0 4
131536: PUSH
131537: LD_VAR 0 7
131541: ARRAY
131542: PUSH
131543: LD_VAR 0 30
131547: IN
131548: NOT
131549: AND
131550: IFFALSE 131574
// to_heal := to_heal union group [ i ] ;
131552: LD_ADDR_VAR 0 30
131556: PUSH
131557: LD_VAR 0 30
131561: PUSH
131562: LD_VAR 0 4
131566: PUSH
131567: LD_VAR 0 7
131571: ARRAY
131572: UNION
131573: ST_TO_ADDR
// if group [ i ] in to_heal then
131574: LD_VAR 0 4
131578: PUSH
131579: LD_VAR 0 7
131583: ARRAY
131584: PUSH
131585: LD_VAR 0 30
131589: IN
131590: IFFALSE 131699
// begin if GetLives ( group [ i ] ) = 1000 then
131592: LD_VAR 0 4
131596: PUSH
131597: LD_VAR 0 7
131601: ARRAY
131602: PPUSH
131603: CALL_OW 256
131607: PUSH
131608: LD_INT 1000
131610: EQUAL
131611: IFFALSE 131637
// to_heal := to_heal diff group [ i ] else
131613: LD_ADDR_VAR 0 30
131617: PUSH
131618: LD_VAR 0 30
131622: PUSH
131623: LD_VAR 0 4
131627: PUSH
131628: LD_VAR 0 7
131632: ARRAY
131633: DIFF
131634: ST_TO_ADDR
131635: GO 131699
// begin if not IsInArea ( group [ i ] , to_heal ) then
131637: LD_VAR 0 4
131641: PUSH
131642: LD_VAR 0 7
131646: ARRAY
131647: PPUSH
131648: LD_VAR 0 30
131652: PPUSH
131653: CALL_OW 308
131657: NOT
131658: IFFALSE 131682
// ComMoveToArea ( group [ i ] , f_heal ) else
131660: LD_VAR 0 4
131664: PUSH
131665: LD_VAR 0 7
131669: ARRAY
131670: PPUSH
131671: LD_VAR 0 23
131675: PPUSH
131676: CALL_OW 113
131680: GO 131697
// ComHold ( group [ i ] ) ;
131682: LD_VAR 0 4
131686: PUSH
131687: LD_VAR 0 7
131691: ARRAY
131692: PPUSH
131693: CALL_OW 140
// continue ;
131697: GO 130541
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
131699: LD_VAR 0 4
131703: PUSH
131704: LD_VAR 0 7
131708: ARRAY
131709: PPUSH
131710: LD_INT 10
131712: PPUSH
131713: CALL 101013 0 2
131717: NOT
131718: PUSH
131719: LD_VAR 0 16
131723: PUSH
131724: LD_VAR 0 7
131728: ARRAY
131729: PUSH
131730: EMPTY
131731: EQUAL
131732: NOT
131733: AND
131734: IFFALSE 132000
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
131736: LD_VAR 0 4
131740: PUSH
131741: LD_VAR 0 7
131745: ARRAY
131746: PPUSH
131747: CALL_OW 262
131751: PUSH
131752: LD_INT 1
131754: PUSH
131755: LD_INT 2
131757: PUSH
131758: EMPTY
131759: LIST
131760: LIST
131761: IN
131762: IFFALSE 131803
// if GetFuel ( group [ i ] ) < 10 then
131764: LD_VAR 0 4
131768: PUSH
131769: LD_VAR 0 7
131773: ARRAY
131774: PPUSH
131775: CALL_OW 261
131779: PUSH
131780: LD_INT 10
131782: LESS
131783: IFFALSE 131803
// SetFuel ( group [ i ] , 12 ) ;
131785: LD_VAR 0 4
131789: PUSH
131790: LD_VAR 0 7
131794: ARRAY
131795: PPUSH
131796: LD_INT 12
131798: PPUSH
131799: CALL_OW 240
// if units_path [ i ] then
131803: LD_VAR 0 16
131807: PUSH
131808: LD_VAR 0 7
131812: ARRAY
131813: IFFALSE 131998
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
131815: LD_VAR 0 4
131819: PUSH
131820: LD_VAR 0 7
131824: ARRAY
131825: PPUSH
131826: LD_VAR 0 16
131830: PUSH
131831: LD_VAR 0 7
131835: ARRAY
131836: PUSH
131837: LD_INT 1
131839: ARRAY
131840: PUSH
131841: LD_INT 1
131843: ARRAY
131844: PPUSH
131845: LD_VAR 0 16
131849: PUSH
131850: LD_VAR 0 7
131854: ARRAY
131855: PUSH
131856: LD_INT 1
131858: ARRAY
131859: PUSH
131860: LD_INT 2
131862: ARRAY
131863: PPUSH
131864: CALL_OW 297
131868: PUSH
131869: LD_INT 6
131871: GREATER
131872: IFFALSE 131947
// begin if not HasTask ( group [ i ] ) then
131874: LD_VAR 0 4
131878: PUSH
131879: LD_VAR 0 7
131883: ARRAY
131884: PPUSH
131885: CALL_OW 314
131889: NOT
131890: IFFALSE 131945
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
131892: LD_VAR 0 4
131896: PUSH
131897: LD_VAR 0 7
131901: ARRAY
131902: PPUSH
131903: LD_VAR 0 16
131907: PUSH
131908: LD_VAR 0 7
131912: ARRAY
131913: PUSH
131914: LD_INT 1
131916: ARRAY
131917: PUSH
131918: LD_INT 1
131920: ARRAY
131921: PPUSH
131922: LD_VAR 0 16
131926: PUSH
131927: LD_VAR 0 7
131931: ARRAY
131932: PUSH
131933: LD_INT 1
131935: ARRAY
131936: PUSH
131937: LD_INT 2
131939: ARRAY
131940: PPUSH
131941: CALL_OW 114
// end else
131945: GO 131998
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
131947: LD_ADDR_VAR 0 15
131951: PUSH
131952: LD_VAR 0 16
131956: PUSH
131957: LD_VAR 0 7
131961: ARRAY
131962: PPUSH
131963: LD_INT 1
131965: PPUSH
131966: CALL_OW 3
131970: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
131971: LD_ADDR_VAR 0 16
131975: PUSH
131976: LD_VAR 0 16
131980: PPUSH
131981: LD_VAR 0 7
131985: PPUSH
131986: LD_VAR 0 15
131990: PPUSH
131991: CALL_OW 1
131995: ST_TO_ADDR
// continue ;
131996: GO 130541
// end ; end ; end else
131998: GO 134662
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
132000: LD_ADDR_VAR 0 14
132004: PUSH
132005: LD_INT 81
132007: PUSH
132008: LD_VAR 0 4
132012: PUSH
132013: LD_VAR 0 7
132017: ARRAY
132018: PPUSH
132019: CALL_OW 255
132023: PUSH
132024: EMPTY
132025: LIST
132026: LIST
132027: PPUSH
132028: CALL_OW 69
132032: ST_TO_ADDR
// if not tmp then
132033: LD_VAR 0 14
132037: NOT
132038: IFFALSE 132042
// continue ;
132040: GO 130541
// if f_ignore_area then
132042: LD_VAR 0 17
132046: IFFALSE 132134
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
132048: LD_ADDR_VAR 0 15
132052: PUSH
132053: LD_VAR 0 14
132057: PPUSH
132058: LD_INT 3
132060: PUSH
132061: LD_INT 92
132063: PUSH
132064: LD_VAR 0 17
132068: PUSH
132069: LD_INT 1
132071: ARRAY
132072: PUSH
132073: LD_VAR 0 17
132077: PUSH
132078: LD_INT 2
132080: ARRAY
132081: PUSH
132082: LD_VAR 0 17
132086: PUSH
132087: LD_INT 3
132089: ARRAY
132090: PUSH
132091: EMPTY
132092: LIST
132093: LIST
132094: LIST
132095: LIST
132096: PUSH
132097: EMPTY
132098: LIST
132099: LIST
132100: PPUSH
132101: CALL_OW 72
132105: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132106: LD_VAR 0 14
132110: PUSH
132111: LD_VAR 0 15
132115: DIFF
132116: IFFALSE 132134
// tmp := tmp diff tmp2 ;
132118: LD_ADDR_VAR 0 14
132122: PUSH
132123: LD_VAR 0 14
132127: PUSH
132128: LD_VAR 0 15
132132: DIFF
132133: ST_TO_ADDR
// end ; if not f_murder then
132134: LD_VAR 0 20
132138: NOT
132139: IFFALSE 132197
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
132141: LD_ADDR_VAR 0 15
132145: PUSH
132146: LD_VAR 0 14
132150: PPUSH
132151: LD_INT 3
132153: PUSH
132154: LD_INT 50
132156: PUSH
132157: EMPTY
132158: LIST
132159: PUSH
132160: EMPTY
132161: LIST
132162: LIST
132163: PPUSH
132164: CALL_OW 72
132168: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132169: LD_VAR 0 14
132173: PUSH
132174: LD_VAR 0 15
132178: DIFF
132179: IFFALSE 132197
// tmp := tmp diff tmp2 ;
132181: LD_ADDR_VAR 0 14
132185: PUSH
132186: LD_VAR 0 14
132190: PUSH
132191: LD_VAR 0 15
132195: DIFF
132196: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
132197: LD_ADDR_VAR 0 14
132201: PUSH
132202: LD_VAR 0 4
132206: PUSH
132207: LD_VAR 0 7
132211: ARRAY
132212: PPUSH
132213: LD_VAR 0 14
132217: PPUSH
132218: LD_INT 1
132220: PPUSH
132221: LD_INT 1
132223: PPUSH
132224: CALL 73954 0 4
132228: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
132229: LD_VAR 0 4
132233: PUSH
132234: LD_VAR 0 7
132238: ARRAY
132239: PPUSH
132240: CALL_OW 257
132244: PUSH
132245: LD_INT 1
132247: EQUAL
132248: IFFALSE 132696
// begin if WantPlant ( group [ i ] ) then
132250: LD_VAR 0 4
132254: PUSH
132255: LD_VAR 0 7
132259: ARRAY
132260: PPUSH
132261: CALL 73455 0 1
132265: IFFALSE 132269
// continue ;
132267: GO 130541
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
132269: LD_VAR 0 18
132273: PUSH
132274: LD_VAR 0 4
132278: PUSH
132279: LD_VAR 0 7
132283: ARRAY
132284: PPUSH
132285: CALL_OW 310
132289: NOT
132290: AND
132291: PUSH
132292: LD_VAR 0 14
132296: PUSH
132297: LD_INT 1
132299: ARRAY
132300: PUSH
132301: LD_VAR 0 14
132305: PPUSH
132306: LD_INT 21
132308: PUSH
132309: LD_INT 2
132311: PUSH
132312: EMPTY
132313: LIST
132314: LIST
132315: PUSH
132316: LD_INT 58
132318: PUSH
132319: EMPTY
132320: LIST
132321: PUSH
132322: EMPTY
132323: LIST
132324: LIST
132325: PPUSH
132326: CALL_OW 72
132330: IN
132331: AND
132332: IFFALSE 132368
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
132334: LD_VAR 0 4
132338: PUSH
132339: LD_VAR 0 7
132343: ARRAY
132344: PPUSH
132345: LD_VAR 0 14
132349: PUSH
132350: LD_INT 1
132352: ARRAY
132353: PPUSH
132354: CALL_OW 120
// attacking := true ;
132358: LD_ADDR_VAR 0 29
132362: PUSH
132363: LD_INT 1
132365: ST_TO_ADDR
// continue ;
132366: GO 130541
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
132368: LD_VAR 0 26
132372: PUSH
132373: LD_VAR 0 4
132377: PUSH
132378: LD_VAR 0 7
132382: ARRAY
132383: PPUSH
132384: CALL_OW 257
132388: PUSH
132389: LD_INT 1
132391: EQUAL
132392: AND
132393: PUSH
132394: LD_VAR 0 4
132398: PUSH
132399: LD_VAR 0 7
132403: ARRAY
132404: PPUSH
132405: CALL_OW 256
132409: PUSH
132410: LD_INT 800
132412: LESS
132413: AND
132414: PUSH
132415: LD_VAR 0 4
132419: PUSH
132420: LD_VAR 0 7
132424: ARRAY
132425: PPUSH
132426: CALL_OW 318
132430: NOT
132431: AND
132432: IFFALSE 132449
// ComCrawl ( group [ i ] ) ;
132434: LD_VAR 0 4
132438: PUSH
132439: LD_VAR 0 7
132443: ARRAY
132444: PPUSH
132445: CALL_OW 137
// if f_mines then
132449: LD_VAR 0 21
132453: IFFALSE 132696
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
132455: LD_VAR 0 14
132459: PUSH
132460: LD_INT 1
132462: ARRAY
132463: PPUSH
132464: CALL_OW 247
132468: PUSH
132469: LD_INT 3
132471: EQUAL
132472: PUSH
132473: LD_VAR 0 14
132477: PUSH
132478: LD_INT 1
132480: ARRAY
132481: PUSH
132482: LD_VAR 0 27
132486: IN
132487: NOT
132488: AND
132489: IFFALSE 132696
// begin x := GetX ( tmp [ 1 ] ) ;
132491: LD_ADDR_VAR 0 10
132495: PUSH
132496: LD_VAR 0 14
132500: PUSH
132501: LD_INT 1
132503: ARRAY
132504: PPUSH
132505: CALL_OW 250
132509: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
132510: LD_ADDR_VAR 0 11
132514: PUSH
132515: LD_VAR 0 14
132519: PUSH
132520: LD_INT 1
132522: ARRAY
132523: PPUSH
132524: CALL_OW 251
132528: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
132529: LD_ADDR_VAR 0 12
132533: PUSH
132534: LD_VAR 0 4
132538: PUSH
132539: LD_VAR 0 7
132543: ARRAY
132544: PPUSH
132545: CALL 101098 0 1
132549: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
132550: LD_VAR 0 4
132554: PUSH
132555: LD_VAR 0 7
132559: ARRAY
132560: PPUSH
132561: LD_VAR 0 10
132565: PPUSH
132566: LD_VAR 0 11
132570: PPUSH
132571: LD_VAR 0 14
132575: PUSH
132576: LD_INT 1
132578: ARRAY
132579: PPUSH
132580: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
132584: LD_VAR 0 4
132588: PUSH
132589: LD_VAR 0 7
132593: ARRAY
132594: PPUSH
132595: LD_VAR 0 10
132599: PPUSH
132600: LD_VAR 0 12
132604: PPUSH
132605: LD_INT 7
132607: PPUSH
132608: CALL_OW 272
132612: PPUSH
132613: LD_VAR 0 11
132617: PPUSH
132618: LD_VAR 0 12
132622: PPUSH
132623: LD_INT 7
132625: PPUSH
132626: CALL_OW 273
132630: PPUSH
132631: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
132635: LD_VAR 0 4
132639: PUSH
132640: LD_VAR 0 7
132644: ARRAY
132645: PPUSH
132646: LD_INT 71
132648: PPUSH
132649: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
132653: LD_ADDR_VAR 0 27
132657: PUSH
132658: LD_VAR 0 27
132662: PPUSH
132663: LD_VAR 0 27
132667: PUSH
132668: LD_INT 1
132670: PLUS
132671: PPUSH
132672: LD_VAR 0 14
132676: PUSH
132677: LD_INT 1
132679: ARRAY
132680: PPUSH
132681: CALL_OW 1
132685: ST_TO_ADDR
// attacking := true ;
132686: LD_ADDR_VAR 0 29
132690: PUSH
132691: LD_INT 1
132693: ST_TO_ADDR
// continue ;
132694: GO 130541
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
132696: LD_VAR 0 4
132700: PUSH
132701: LD_VAR 0 7
132705: ARRAY
132706: PPUSH
132707: CALL_OW 257
132711: PUSH
132712: LD_INT 17
132714: EQUAL
132715: PUSH
132716: LD_VAR 0 4
132720: PUSH
132721: LD_VAR 0 7
132725: ARRAY
132726: PPUSH
132727: CALL_OW 110
132731: PUSH
132732: LD_INT 71
132734: EQUAL
132735: NOT
132736: AND
132737: IFFALSE 132883
// begin attacking := false ;
132739: LD_ADDR_VAR 0 29
132743: PUSH
132744: LD_INT 0
132746: ST_TO_ADDR
// k := 5 ;
132747: LD_ADDR_VAR 0 9
132751: PUSH
132752: LD_INT 5
132754: ST_TO_ADDR
// if tmp < k then
132755: LD_VAR 0 14
132759: PUSH
132760: LD_VAR 0 9
132764: LESS
132765: IFFALSE 132777
// k := tmp ;
132767: LD_ADDR_VAR 0 9
132771: PUSH
132772: LD_VAR 0 14
132776: ST_TO_ADDR
// for j = 1 to k do
132777: LD_ADDR_VAR 0 8
132781: PUSH
132782: DOUBLE
132783: LD_INT 1
132785: DEC
132786: ST_TO_ADDR
132787: LD_VAR 0 9
132791: PUSH
132792: FOR_TO
132793: IFFALSE 132881
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
132795: LD_VAR 0 14
132799: PUSH
132800: LD_VAR 0 8
132804: ARRAY
132805: PUSH
132806: LD_VAR 0 14
132810: PPUSH
132811: LD_INT 58
132813: PUSH
132814: EMPTY
132815: LIST
132816: PPUSH
132817: CALL_OW 72
132821: IN
132822: NOT
132823: IFFALSE 132879
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132825: LD_VAR 0 4
132829: PUSH
132830: LD_VAR 0 7
132834: ARRAY
132835: PPUSH
132836: LD_VAR 0 14
132840: PUSH
132841: LD_VAR 0 8
132845: ARRAY
132846: PPUSH
132847: CALL_OW 115
// attacking := true ;
132851: LD_ADDR_VAR 0 29
132855: PUSH
132856: LD_INT 1
132858: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
132859: LD_VAR 0 4
132863: PUSH
132864: LD_VAR 0 7
132868: ARRAY
132869: PPUSH
132870: LD_INT 71
132872: PPUSH
132873: CALL_OW 109
// continue ;
132877: GO 132792
// end ; end ;
132879: GO 132792
132881: POP
132882: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
132883: LD_VAR 0 4
132887: PUSH
132888: LD_VAR 0 7
132892: ARRAY
132893: PPUSH
132894: CALL_OW 257
132898: PUSH
132899: LD_INT 8
132901: EQUAL
132902: PUSH
132903: LD_VAR 0 4
132907: PUSH
132908: LD_VAR 0 7
132912: ARRAY
132913: PPUSH
132914: CALL_OW 264
132918: PUSH
132919: LD_INT 28
132921: PUSH
132922: LD_INT 45
132924: PUSH
132925: LD_INT 7
132927: PUSH
132928: LD_INT 47
132930: PUSH
132931: EMPTY
132932: LIST
132933: LIST
132934: LIST
132935: LIST
132936: IN
132937: OR
132938: IFFALSE 133194
// begin attacking := false ;
132940: LD_ADDR_VAR 0 29
132944: PUSH
132945: LD_INT 0
132947: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
132948: LD_VAR 0 14
132952: PUSH
132953: LD_INT 1
132955: ARRAY
132956: PPUSH
132957: CALL_OW 266
132961: PUSH
132962: LD_INT 32
132964: PUSH
132965: LD_INT 31
132967: PUSH
132968: LD_INT 33
132970: PUSH
132971: LD_INT 4
132973: PUSH
132974: LD_INT 5
132976: PUSH
132977: EMPTY
132978: LIST
132979: LIST
132980: LIST
132981: LIST
132982: LIST
132983: IN
132984: IFFALSE 133170
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
132986: LD_ADDR_VAR 0 9
132990: PUSH
132991: LD_VAR 0 14
132995: PUSH
132996: LD_INT 1
132998: ARRAY
132999: PPUSH
133000: CALL_OW 266
133004: PPUSH
133005: LD_VAR 0 14
133009: PUSH
133010: LD_INT 1
133012: ARRAY
133013: PPUSH
133014: CALL_OW 250
133018: PPUSH
133019: LD_VAR 0 14
133023: PUSH
133024: LD_INT 1
133026: ARRAY
133027: PPUSH
133028: CALL_OW 251
133032: PPUSH
133033: LD_VAR 0 14
133037: PUSH
133038: LD_INT 1
133040: ARRAY
133041: PPUSH
133042: CALL_OW 254
133046: PPUSH
133047: LD_VAR 0 14
133051: PUSH
133052: LD_INT 1
133054: ARRAY
133055: PPUSH
133056: CALL_OW 248
133060: PPUSH
133061: LD_INT 0
133063: PPUSH
133064: CALL 82468 0 6
133068: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
133069: LD_ADDR_VAR 0 8
133073: PUSH
133074: LD_VAR 0 4
133078: PUSH
133079: LD_VAR 0 7
133083: ARRAY
133084: PPUSH
133085: LD_VAR 0 9
133089: PPUSH
133090: CALL 101211 0 2
133094: ST_TO_ADDR
// if j then
133095: LD_VAR 0 8
133099: IFFALSE 133168
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
133101: LD_VAR 0 8
133105: PUSH
133106: LD_INT 1
133108: ARRAY
133109: PPUSH
133110: LD_VAR 0 8
133114: PUSH
133115: LD_INT 2
133117: ARRAY
133118: PPUSH
133119: CALL_OW 488
133123: IFFALSE 133168
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
133125: LD_VAR 0 4
133129: PUSH
133130: LD_VAR 0 7
133134: ARRAY
133135: PPUSH
133136: LD_VAR 0 8
133140: PUSH
133141: LD_INT 1
133143: ARRAY
133144: PPUSH
133145: LD_VAR 0 8
133149: PUSH
133150: LD_INT 2
133152: ARRAY
133153: PPUSH
133154: CALL_OW 116
// attacking := true ;
133158: LD_ADDR_VAR 0 29
133162: PUSH
133163: LD_INT 1
133165: ST_TO_ADDR
// continue ;
133166: GO 130541
// end ; end else
133168: GO 133194
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133170: LD_VAR 0 4
133174: PUSH
133175: LD_VAR 0 7
133179: ARRAY
133180: PPUSH
133181: LD_VAR 0 14
133185: PUSH
133186: LD_INT 1
133188: ARRAY
133189: PPUSH
133190: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
133194: LD_VAR 0 4
133198: PUSH
133199: LD_VAR 0 7
133203: ARRAY
133204: PPUSH
133205: CALL_OW 265
133209: PUSH
133210: LD_INT 11
133212: EQUAL
133213: IFFALSE 133491
// begin k := 10 ;
133215: LD_ADDR_VAR 0 9
133219: PUSH
133220: LD_INT 10
133222: ST_TO_ADDR
// x := 0 ;
133223: LD_ADDR_VAR 0 10
133227: PUSH
133228: LD_INT 0
133230: ST_TO_ADDR
// if tmp < k then
133231: LD_VAR 0 14
133235: PUSH
133236: LD_VAR 0 9
133240: LESS
133241: IFFALSE 133253
// k := tmp ;
133243: LD_ADDR_VAR 0 9
133247: PUSH
133248: LD_VAR 0 14
133252: ST_TO_ADDR
// for j = k downto 1 do
133253: LD_ADDR_VAR 0 8
133257: PUSH
133258: DOUBLE
133259: LD_VAR 0 9
133263: INC
133264: ST_TO_ADDR
133265: LD_INT 1
133267: PUSH
133268: FOR_DOWNTO
133269: IFFALSE 133344
// begin if GetType ( tmp [ j ] ) = unit_human then
133271: LD_VAR 0 14
133275: PUSH
133276: LD_VAR 0 8
133280: ARRAY
133281: PPUSH
133282: CALL_OW 247
133286: PUSH
133287: LD_INT 1
133289: EQUAL
133290: IFFALSE 133342
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
133292: LD_VAR 0 4
133296: PUSH
133297: LD_VAR 0 7
133301: ARRAY
133302: PPUSH
133303: LD_VAR 0 14
133307: PUSH
133308: LD_VAR 0 8
133312: ARRAY
133313: PPUSH
133314: CALL 101465 0 2
// x := tmp [ j ] ;
133318: LD_ADDR_VAR 0 10
133322: PUSH
133323: LD_VAR 0 14
133327: PUSH
133328: LD_VAR 0 8
133332: ARRAY
133333: ST_TO_ADDR
// attacking := true ;
133334: LD_ADDR_VAR 0 29
133338: PUSH
133339: LD_INT 1
133341: ST_TO_ADDR
// end ; end ;
133342: GO 133268
133344: POP
133345: POP
// if not x then
133346: LD_VAR 0 10
133350: NOT
133351: IFFALSE 133491
// begin attacking := true ;
133353: LD_ADDR_VAR 0 29
133357: PUSH
133358: LD_INT 1
133360: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
133361: LD_VAR 0 4
133365: PUSH
133366: LD_VAR 0 7
133370: ARRAY
133371: PPUSH
133372: CALL_OW 250
133376: PPUSH
133377: LD_VAR 0 4
133381: PUSH
133382: LD_VAR 0 7
133386: ARRAY
133387: PPUSH
133388: CALL_OW 251
133392: PPUSH
133393: CALL_OW 546
133397: PUSH
133398: LD_INT 2
133400: ARRAY
133401: PUSH
133402: LD_VAR 0 14
133406: PUSH
133407: LD_INT 1
133409: ARRAY
133410: PPUSH
133411: CALL_OW 250
133415: PPUSH
133416: LD_VAR 0 14
133420: PUSH
133421: LD_INT 1
133423: ARRAY
133424: PPUSH
133425: CALL_OW 251
133429: PPUSH
133430: CALL_OW 546
133434: PUSH
133435: LD_INT 2
133437: ARRAY
133438: EQUAL
133439: IFFALSE 133467
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
133441: LD_VAR 0 4
133445: PUSH
133446: LD_VAR 0 7
133450: ARRAY
133451: PPUSH
133452: LD_VAR 0 14
133456: PUSH
133457: LD_INT 1
133459: ARRAY
133460: PPUSH
133461: CALL 101465 0 2
133465: GO 133491
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133467: LD_VAR 0 4
133471: PUSH
133472: LD_VAR 0 7
133476: ARRAY
133477: PPUSH
133478: LD_VAR 0 14
133482: PUSH
133483: LD_INT 1
133485: ARRAY
133486: PPUSH
133487: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
133491: LD_VAR 0 4
133495: PUSH
133496: LD_VAR 0 7
133500: ARRAY
133501: PPUSH
133502: CALL_OW 264
133506: PUSH
133507: LD_INT 29
133509: EQUAL
133510: IFFALSE 133876
// begin if WantsToAttack ( group [ i ] ) in bombed then
133512: LD_VAR 0 4
133516: PUSH
133517: LD_VAR 0 7
133521: ARRAY
133522: PPUSH
133523: CALL_OW 319
133527: PUSH
133528: LD_VAR 0 28
133532: IN
133533: IFFALSE 133537
// continue ;
133535: GO 130541
// k := 8 ;
133537: LD_ADDR_VAR 0 9
133541: PUSH
133542: LD_INT 8
133544: ST_TO_ADDR
// x := 0 ;
133545: LD_ADDR_VAR 0 10
133549: PUSH
133550: LD_INT 0
133552: ST_TO_ADDR
// if tmp < k then
133553: LD_VAR 0 14
133557: PUSH
133558: LD_VAR 0 9
133562: LESS
133563: IFFALSE 133575
// k := tmp ;
133565: LD_ADDR_VAR 0 9
133569: PUSH
133570: LD_VAR 0 14
133574: ST_TO_ADDR
// for j = 1 to k do
133575: LD_ADDR_VAR 0 8
133579: PUSH
133580: DOUBLE
133581: LD_INT 1
133583: DEC
133584: ST_TO_ADDR
133585: LD_VAR 0 9
133589: PUSH
133590: FOR_TO
133591: IFFALSE 133723
// begin if GetType ( tmp [ j ] ) = unit_building then
133593: LD_VAR 0 14
133597: PUSH
133598: LD_VAR 0 8
133602: ARRAY
133603: PPUSH
133604: CALL_OW 247
133608: PUSH
133609: LD_INT 3
133611: EQUAL
133612: IFFALSE 133721
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
133614: LD_VAR 0 14
133618: PUSH
133619: LD_VAR 0 8
133623: ARRAY
133624: PUSH
133625: LD_VAR 0 28
133629: IN
133630: NOT
133631: PUSH
133632: LD_VAR 0 14
133636: PUSH
133637: LD_VAR 0 8
133641: ARRAY
133642: PPUSH
133643: CALL_OW 313
133647: AND
133648: IFFALSE 133721
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133650: LD_VAR 0 4
133654: PUSH
133655: LD_VAR 0 7
133659: ARRAY
133660: PPUSH
133661: LD_VAR 0 14
133665: PUSH
133666: LD_VAR 0 8
133670: ARRAY
133671: PPUSH
133672: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
133676: LD_ADDR_VAR 0 28
133680: PUSH
133681: LD_VAR 0 28
133685: PPUSH
133686: LD_VAR 0 28
133690: PUSH
133691: LD_INT 1
133693: PLUS
133694: PPUSH
133695: LD_VAR 0 14
133699: PUSH
133700: LD_VAR 0 8
133704: ARRAY
133705: PPUSH
133706: CALL_OW 1
133710: ST_TO_ADDR
// attacking := true ;
133711: LD_ADDR_VAR 0 29
133715: PUSH
133716: LD_INT 1
133718: ST_TO_ADDR
// break ;
133719: GO 133723
// end ; end ;
133721: GO 133590
133723: POP
133724: POP
// if not attacking and f_attack_depot then
133725: LD_VAR 0 29
133729: NOT
133730: PUSH
133731: LD_VAR 0 25
133735: AND
133736: IFFALSE 133831
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
133738: LD_ADDR_VAR 0 13
133742: PUSH
133743: LD_VAR 0 14
133747: PPUSH
133748: LD_INT 2
133750: PUSH
133751: LD_INT 30
133753: PUSH
133754: LD_INT 0
133756: PUSH
133757: EMPTY
133758: LIST
133759: LIST
133760: PUSH
133761: LD_INT 30
133763: PUSH
133764: LD_INT 1
133766: PUSH
133767: EMPTY
133768: LIST
133769: LIST
133770: PUSH
133771: EMPTY
133772: LIST
133773: LIST
133774: LIST
133775: PPUSH
133776: CALL_OW 72
133780: ST_TO_ADDR
// if z then
133781: LD_VAR 0 13
133785: IFFALSE 133831
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
133787: LD_VAR 0 4
133791: PUSH
133792: LD_VAR 0 7
133796: ARRAY
133797: PPUSH
133798: LD_VAR 0 13
133802: PPUSH
133803: LD_VAR 0 4
133807: PUSH
133808: LD_VAR 0 7
133812: ARRAY
133813: PPUSH
133814: CALL_OW 74
133818: PPUSH
133819: CALL_OW 115
// attacking := true ;
133823: LD_ADDR_VAR 0 29
133827: PUSH
133828: LD_INT 1
133830: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
133831: LD_VAR 0 4
133835: PUSH
133836: LD_VAR 0 7
133840: ARRAY
133841: PPUSH
133842: CALL_OW 256
133846: PUSH
133847: LD_INT 500
133849: LESS
133850: IFFALSE 133876
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133852: LD_VAR 0 4
133856: PUSH
133857: LD_VAR 0 7
133861: ARRAY
133862: PPUSH
133863: LD_VAR 0 14
133867: PUSH
133868: LD_INT 1
133870: ARRAY
133871: PPUSH
133872: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
133876: LD_VAR 0 4
133880: PUSH
133881: LD_VAR 0 7
133885: ARRAY
133886: PPUSH
133887: CALL_OW 264
133891: PUSH
133892: LD_INT 49
133894: EQUAL
133895: IFFALSE 134016
// begin if not HasTask ( group [ i ] ) then
133897: LD_VAR 0 4
133901: PUSH
133902: LD_VAR 0 7
133906: ARRAY
133907: PPUSH
133908: CALL_OW 314
133912: NOT
133913: IFFALSE 134016
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
133915: LD_ADDR_VAR 0 9
133919: PUSH
133920: LD_INT 81
133922: PUSH
133923: LD_VAR 0 4
133927: PUSH
133928: LD_VAR 0 7
133932: ARRAY
133933: PPUSH
133934: CALL_OW 255
133938: PUSH
133939: EMPTY
133940: LIST
133941: LIST
133942: PPUSH
133943: CALL_OW 69
133947: PPUSH
133948: LD_VAR 0 4
133952: PUSH
133953: LD_VAR 0 7
133957: ARRAY
133958: PPUSH
133959: CALL_OW 74
133963: ST_TO_ADDR
// if k then
133964: LD_VAR 0 9
133968: IFFALSE 134016
// if GetDistUnits ( group [ i ] , k ) > 10 then
133970: LD_VAR 0 4
133974: PUSH
133975: LD_VAR 0 7
133979: ARRAY
133980: PPUSH
133981: LD_VAR 0 9
133985: PPUSH
133986: CALL_OW 296
133990: PUSH
133991: LD_INT 10
133993: GREATER
133994: IFFALSE 134016
// ComMoveUnit ( group [ i ] , k ) ;
133996: LD_VAR 0 4
134000: PUSH
134001: LD_VAR 0 7
134005: ARRAY
134006: PPUSH
134007: LD_VAR 0 9
134011: PPUSH
134012: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
134016: LD_VAR 0 4
134020: PUSH
134021: LD_VAR 0 7
134025: ARRAY
134026: PPUSH
134027: CALL_OW 256
134031: PUSH
134032: LD_INT 250
134034: LESS
134035: PUSH
134036: LD_VAR 0 4
134040: PUSH
134041: LD_VAR 0 7
134045: ARRAY
134046: PUSH
134047: LD_INT 21
134049: PUSH
134050: LD_INT 2
134052: PUSH
134053: EMPTY
134054: LIST
134055: LIST
134056: PUSH
134057: LD_INT 23
134059: PUSH
134060: LD_INT 2
134062: PUSH
134063: EMPTY
134064: LIST
134065: LIST
134066: PUSH
134067: EMPTY
134068: LIST
134069: LIST
134070: PPUSH
134071: CALL_OW 69
134075: IN
134076: AND
134077: IFFALSE 134202
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
134079: LD_ADDR_VAR 0 9
134083: PUSH
134084: LD_OWVAR 3
134088: PUSH
134089: LD_VAR 0 4
134093: PUSH
134094: LD_VAR 0 7
134098: ARRAY
134099: DIFF
134100: PPUSH
134101: LD_VAR 0 4
134105: PUSH
134106: LD_VAR 0 7
134110: ARRAY
134111: PPUSH
134112: CALL_OW 74
134116: ST_TO_ADDR
// if not k then
134117: LD_VAR 0 9
134121: NOT
134122: IFFALSE 134126
// continue ;
134124: GO 130541
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
134126: LD_VAR 0 9
134130: PUSH
134131: LD_INT 81
134133: PUSH
134134: LD_VAR 0 4
134138: PUSH
134139: LD_VAR 0 7
134143: ARRAY
134144: PPUSH
134145: CALL_OW 255
134149: PUSH
134150: EMPTY
134151: LIST
134152: LIST
134153: PPUSH
134154: CALL_OW 69
134158: IN
134159: PUSH
134160: LD_VAR 0 9
134164: PPUSH
134165: LD_VAR 0 4
134169: PUSH
134170: LD_VAR 0 7
134174: ARRAY
134175: PPUSH
134176: CALL_OW 296
134180: PUSH
134181: LD_INT 5
134183: LESS
134184: AND
134185: IFFALSE 134202
// ComAutodestruct ( group [ i ] ) ;
134187: LD_VAR 0 4
134191: PUSH
134192: LD_VAR 0 7
134196: ARRAY
134197: PPUSH
134198: CALL 101363 0 1
// end ; if f_attack_depot then
134202: LD_VAR 0 25
134206: IFFALSE 134318
// begin k := 6 ;
134208: LD_ADDR_VAR 0 9
134212: PUSH
134213: LD_INT 6
134215: ST_TO_ADDR
// if tmp < k then
134216: LD_VAR 0 14
134220: PUSH
134221: LD_VAR 0 9
134225: LESS
134226: IFFALSE 134238
// k := tmp ;
134228: LD_ADDR_VAR 0 9
134232: PUSH
134233: LD_VAR 0 14
134237: ST_TO_ADDR
// for j = 1 to k do
134238: LD_ADDR_VAR 0 8
134242: PUSH
134243: DOUBLE
134244: LD_INT 1
134246: DEC
134247: ST_TO_ADDR
134248: LD_VAR 0 9
134252: PUSH
134253: FOR_TO
134254: IFFALSE 134316
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
134256: LD_VAR 0 8
134260: PPUSH
134261: CALL_OW 266
134265: PUSH
134266: LD_INT 0
134268: PUSH
134269: LD_INT 1
134271: PUSH
134272: EMPTY
134273: LIST
134274: LIST
134275: IN
134276: IFFALSE 134314
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
134278: LD_VAR 0 4
134282: PUSH
134283: LD_VAR 0 7
134287: ARRAY
134288: PPUSH
134289: LD_VAR 0 14
134293: PUSH
134294: LD_VAR 0 8
134298: ARRAY
134299: PPUSH
134300: CALL_OW 115
// attacking := true ;
134304: LD_ADDR_VAR 0 29
134308: PUSH
134309: LD_INT 1
134311: ST_TO_ADDR
// break ;
134312: GO 134316
// end ;
134314: GO 134253
134316: POP
134317: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
134318: LD_VAR 0 4
134322: PUSH
134323: LD_VAR 0 7
134327: ARRAY
134328: PPUSH
134329: CALL_OW 302
134333: PUSH
134334: LD_VAR 0 29
134338: NOT
134339: AND
134340: IFFALSE 134662
// begin if GetTag ( group [ i ] ) = 71 then
134342: LD_VAR 0 4
134346: PUSH
134347: LD_VAR 0 7
134351: ARRAY
134352: PPUSH
134353: CALL_OW 110
134357: PUSH
134358: LD_INT 71
134360: EQUAL
134361: IFFALSE 134402
// begin if HasTask ( group [ i ] ) then
134363: LD_VAR 0 4
134367: PUSH
134368: LD_VAR 0 7
134372: ARRAY
134373: PPUSH
134374: CALL_OW 314
134378: IFFALSE 134384
// continue else
134380: GO 130541
134382: GO 134402
// SetTag ( group [ i ] , 0 ) ;
134384: LD_VAR 0 4
134388: PUSH
134389: LD_VAR 0 7
134393: ARRAY
134394: PPUSH
134395: LD_INT 0
134397: PPUSH
134398: CALL_OW 109
// end ; k := 8 ;
134402: LD_ADDR_VAR 0 9
134406: PUSH
134407: LD_INT 8
134409: ST_TO_ADDR
// x := 0 ;
134410: LD_ADDR_VAR 0 10
134414: PUSH
134415: LD_INT 0
134417: ST_TO_ADDR
// if tmp < k then
134418: LD_VAR 0 14
134422: PUSH
134423: LD_VAR 0 9
134427: LESS
134428: IFFALSE 134440
// k := tmp ;
134430: LD_ADDR_VAR 0 9
134434: PUSH
134435: LD_VAR 0 14
134439: ST_TO_ADDR
// for j = 1 to k do
134440: LD_ADDR_VAR 0 8
134444: PUSH
134445: DOUBLE
134446: LD_INT 1
134448: DEC
134449: ST_TO_ADDR
134450: LD_VAR 0 9
134454: PUSH
134455: FOR_TO
134456: IFFALSE 134554
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
134458: LD_VAR 0 14
134462: PUSH
134463: LD_VAR 0 8
134467: ARRAY
134468: PPUSH
134469: CALL_OW 247
134473: PUSH
134474: LD_INT 1
134476: EQUAL
134477: PUSH
134478: LD_VAR 0 14
134482: PUSH
134483: LD_VAR 0 8
134487: ARRAY
134488: PPUSH
134489: CALL_OW 256
134493: PUSH
134494: LD_INT 250
134496: LESS
134497: PUSH
134498: LD_VAR 0 20
134502: AND
134503: PUSH
134504: LD_VAR 0 20
134508: NOT
134509: PUSH
134510: LD_VAR 0 14
134514: PUSH
134515: LD_VAR 0 8
134519: ARRAY
134520: PPUSH
134521: CALL_OW 256
134525: PUSH
134526: LD_INT 250
134528: GREATEREQUAL
134529: AND
134530: OR
134531: AND
134532: IFFALSE 134552
// begin x := tmp [ j ] ;
134534: LD_ADDR_VAR 0 10
134538: PUSH
134539: LD_VAR 0 14
134543: PUSH
134544: LD_VAR 0 8
134548: ARRAY
134549: ST_TO_ADDR
// break ;
134550: GO 134554
// end ;
134552: GO 134455
134554: POP
134555: POP
// if x then
134556: LD_VAR 0 10
134560: IFFALSE 134584
// ComAttackUnit ( group [ i ] , x ) else
134562: LD_VAR 0 4
134566: PUSH
134567: LD_VAR 0 7
134571: ARRAY
134572: PPUSH
134573: LD_VAR 0 10
134577: PPUSH
134578: CALL_OW 115
134582: GO 134608
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134584: LD_VAR 0 4
134588: PUSH
134589: LD_VAR 0 7
134593: ARRAY
134594: PPUSH
134595: LD_VAR 0 14
134599: PUSH
134600: LD_INT 1
134602: ARRAY
134603: PPUSH
134604: CALL_OW 115
// if not HasTask ( group [ i ] ) then
134608: LD_VAR 0 4
134612: PUSH
134613: LD_VAR 0 7
134617: ARRAY
134618: PPUSH
134619: CALL_OW 314
134623: NOT
134624: IFFALSE 134662
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
134626: LD_VAR 0 4
134630: PUSH
134631: LD_VAR 0 7
134635: ARRAY
134636: PPUSH
134637: LD_VAR 0 14
134641: PPUSH
134642: LD_VAR 0 4
134646: PUSH
134647: LD_VAR 0 7
134651: ARRAY
134652: PPUSH
134653: CALL_OW 74
134657: PPUSH
134658: CALL_OW 115
// end ; end ; end ;
134662: GO 130541
134664: POP
134665: POP
// wait ( 0 0$2 ) ;
134666: LD_INT 70
134668: PPUSH
134669: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
134673: LD_VAR 0 4
134677: NOT
134678: PUSH
134679: LD_VAR 0 4
134683: PUSH
134684: EMPTY
134685: EQUAL
134686: OR
134687: PUSH
134688: LD_INT 81
134690: PUSH
134691: LD_VAR 0 35
134695: PUSH
134696: EMPTY
134697: LIST
134698: LIST
134699: PPUSH
134700: CALL_OW 69
134704: NOT
134705: OR
134706: IFFALSE 130526
// end ;
134708: LD_VAR 0 2
134712: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
134713: LD_INT 0
134715: PPUSH
134716: PPUSH
134717: PPUSH
134718: PPUSH
134719: PPUSH
134720: PPUSH
// if not base or not mc_bases [ base ] or not solds then
134721: LD_VAR 0 1
134725: NOT
134726: PUSH
134727: LD_EXP 100
134731: PUSH
134732: LD_VAR 0 1
134736: ARRAY
134737: NOT
134738: OR
134739: PUSH
134740: LD_VAR 0 2
134744: NOT
134745: OR
134746: IFFALSE 134750
// exit ;
134748: GO 135304
// side := mc_sides [ base ] ;
134750: LD_ADDR_VAR 0 6
134754: PUSH
134755: LD_EXP 126
134759: PUSH
134760: LD_VAR 0 1
134764: ARRAY
134765: ST_TO_ADDR
// if not side then
134766: LD_VAR 0 6
134770: NOT
134771: IFFALSE 134775
// exit ;
134773: GO 135304
// for i in solds do
134775: LD_ADDR_VAR 0 7
134779: PUSH
134780: LD_VAR 0 2
134784: PUSH
134785: FOR_IN
134786: IFFALSE 134847
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
134788: LD_VAR 0 7
134792: PPUSH
134793: CALL_OW 310
134797: PPUSH
134798: CALL_OW 266
134802: PUSH
134803: LD_INT 32
134805: PUSH
134806: LD_INT 31
134808: PUSH
134809: EMPTY
134810: LIST
134811: LIST
134812: IN
134813: IFFALSE 134833
// solds := solds diff i else
134815: LD_ADDR_VAR 0 2
134819: PUSH
134820: LD_VAR 0 2
134824: PUSH
134825: LD_VAR 0 7
134829: DIFF
134830: ST_TO_ADDR
134831: GO 134845
// SetTag ( i , 18 ) ;
134833: LD_VAR 0 7
134837: PPUSH
134838: LD_INT 18
134840: PPUSH
134841: CALL_OW 109
134845: GO 134785
134847: POP
134848: POP
// if not solds then
134849: LD_VAR 0 2
134853: NOT
134854: IFFALSE 134858
// exit ;
134856: GO 135304
// repeat wait ( 0 0$2 ) ;
134858: LD_INT 70
134860: PPUSH
134861: CALL_OW 67
// enemy := mc_scan [ base ] ;
134865: LD_ADDR_VAR 0 4
134869: PUSH
134870: LD_EXP 123
134874: PUSH
134875: LD_VAR 0 1
134879: ARRAY
134880: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134881: LD_EXP 100
134885: PUSH
134886: LD_VAR 0 1
134890: ARRAY
134891: NOT
134892: PUSH
134893: LD_EXP 100
134897: PUSH
134898: LD_VAR 0 1
134902: ARRAY
134903: PUSH
134904: EMPTY
134905: EQUAL
134906: OR
134907: IFFALSE 134944
// begin for i in solds do
134909: LD_ADDR_VAR 0 7
134913: PUSH
134914: LD_VAR 0 2
134918: PUSH
134919: FOR_IN
134920: IFFALSE 134933
// ComStop ( i ) ;
134922: LD_VAR 0 7
134926: PPUSH
134927: CALL_OW 141
134931: GO 134919
134933: POP
134934: POP
// solds := [ ] ;
134935: LD_ADDR_VAR 0 2
134939: PUSH
134940: EMPTY
134941: ST_TO_ADDR
// exit ;
134942: GO 135304
// end ; for i in solds do
134944: LD_ADDR_VAR 0 7
134948: PUSH
134949: LD_VAR 0 2
134953: PUSH
134954: FOR_IN
134955: IFFALSE 135276
// begin if IsInUnit ( i ) then
134957: LD_VAR 0 7
134961: PPUSH
134962: CALL_OW 310
134966: IFFALSE 134977
// ComExitBuilding ( i ) ;
134968: LD_VAR 0 7
134972: PPUSH
134973: CALL_OW 122
// if GetLives ( i ) > 500 then
134977: LD_VAR 0 7
134981: PPUSH
134982: CALL_OW 256
134986: PUSH
134987: LD_INT 500
134989: GREATER
134990: IFFALSE 135043
// begin e := NearestUnitToUnit ( enemy , i ) ;
134992: LD_ADDR_VAR 0 5
134996: PUSH
134997: LD_VAR 0 4
135001: PPUSH
135002: LD_VAR 0 7
135006: PPUSH
135007: CALL_OW 74
135011: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
135012: LD_VAR 0 7
135016: PPUSH
135017: LD_VAR 0 5
135021: PPUSH
135022: CALL_OW 250
135026: PPUSH
135027: LD_VAR 0 5
135031: PPUSH
135032: CALL_OW 251
135036: PPUSH
135037: CALL_OW 114
// end else
135041: GO 135274
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
135043: LD_VAR 0 7
135047: PPUSH
135048: LD_EXP 100
135052: PUSH
135053: LD_VAR 0 1
135057: ARRAY
135058: PPUSH
135059: LD_INT 2
135061: PUSH
135062: LD_INT 30
135064: PUSH
135065: LD_INT 0
135067: PUSH
135068: EMPTY
135069: LIST
135070: LIST
135071: PUSH
135072: LD_INT 30
135074: PUSH
135075: LD_INT 1
135077: PUSH
135078: EMPTY
135079: LIST
135080: LIST
135081: PUSH
135082: LD_INT 30
135084: PUSH
135085: LD_INT 6
135087: PUSH
135088: EMPTY
135089: LIST
135090: LIST
135091: PUSH
135092: EMPTY
135093: LIST
135094: LIST
135095: LIST
135096: LIST
135097: PPUSH
135098: CALL_OW 72
135102: PPUSH
135103: LD_VAR 0 7
135107: PPUSH
135108: CALL_OW 74
135112: PPUSH
135113: CALL_OW 296
135117: PUSH
135118: LD_INT 10
135120: GREATER
135121: IFFALSE 135274
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
135123: LD_ADDR_VAR 0 8
135127: PUSH
135128: LD_EXP 100
135132: PUSH
135133: LD_VAR 0 1
135137: ARRAY
135138: PPUSH
135139: LD_INT 2
135141: PUSH
135142: LD_INT 30
135144: PUSH
135145: LD_INT 0
135147: PUSH
135148: EMPTY
135149: LIST
135150: LIST
135151: PUSH
135152: LD_INT 30
135154: PUSH
135155: LD_INT 1
135157: PUSH
135158: EMPTY
135159: LIST
135160: LIST
135161: PUSH
135162: LD_INT 30
135164: PUSH
135165: LD_INT 6
135167: PUSH
135168: EMPTY
135169: LIST
135170: LIST
135171: PUSH
135172: EMPTY
135173: LIST
135174: LIST
135175: LIST
135176: LIST
135177: PPUSH
135178: CALL_OW 72
135182: PPUSH
135183: LD_VAR 0 7
135187: PPUSH
135188: CALL_OW 74
135192: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
135193: LD_VAR 0 7
135197: PPUSH
135198: LD_VAR 0 8
135202: PPUSH
135203: CALL_OW 250
135207: PPUSH
135208: LD_INT 3
135210: PPUSH
135211: LD_INT 5
135213: PPUSH
135214: CALL_OW 272
135218: PPUSH
135219: LD_VAR 0 8
135223: PPUSH
135224: CALL_OW 251
135228: PPUSH
135229: LD_INT 3
135231: PPUSH
135232: LD_INT 5
135234: PPUSH
135235: CALL_OW 273
135239: PPUSH
135240: CALL_OW 111
// SetTag ( i , 0 ) ;
135244: LD_VAR 0 7
135248: PPUSH
135249: LD_INT 0
135251: PPUSH
135252: CALL_OW 109
// solds := solds diff i ;
135256: LD_ADDR_VAR 0 2
135260: PUSH
135261: LD_VAR 0 2
135265: PUSH
135266: LD_VAR 0 7
135270: DIFF
135271: ST_TO_ADDR
// continue ;
135272: GO 134954
// end ; end ;
135274: GO 134954
135276: POP
135277: POP
// until not solds or not enemy ;
135278: LD_VAR 0 2
135282: NOT
135283: PUSH
135284: LD_VAR 0 4
135288: NOT
135289: OR
135290: IFFALSE 134858
// MC_Reset ( base , 18 ) ;
135292: LD_VAR 0 1
135296: PPUSH
135297: LD_INT 18
135299: PPUSH
135300: CALL 42032 0 2
// end ;
135304: LD_VAR 0 3
135308: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
135309: LD_INT 0
135311: PPUSH
135312: PPUSH
135313: PPUSH
135314: PPUSH
135315: PPUSH
135316: PPUSH
135317: PPUSH
135318: PPUSH
135319: PPUSH
135320: PPUSH
135321: PPUSH
135322: PPUSH
135323: PPUSH
135324: PPUSH
135325: PPUSH
135326: PPUSH
135327: PPUSH
135328: PPUSH
135329: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
135330: LD_ADDR_VAR 0 12
135334: PUSH
135335: LD_EXP 100
135339: PUSH
135340: LD_VAR 0 1
135344: ARRAY
135345: PPUSH
135346: LD_INT 25
135348: PUSH
135349: LD_INT 3
135351: PUSH
135352: EMPTY
135353: LIST
135354: LIST
135355: PPUSH
135356: CALL_OW 72
135360: ST_TO_ADDR
// if mc_remote_driver [ base ] then
135361: LD_EXP 140
135365: PUSH
135366: LD_VAR 0 1
135370: ARRAY
135371: IFFALSE 135395
// mechs := mechs diff mc_remote_driver [ base ] ;
135373: LD_ADDR_VAR 0 12
135377: PUSH
135378: LD_VAR 0 12
135382: PUSH
135383: LD_EXP 140
135387: PUSH
135388: LD_VAR 0 1
135392: ARRAY
135393: DIFF
135394: ST_TO_ADDR
// for i in mechs do
135395: LD_ADDR_VAR 0 4
135399: PUSH
135400: LD_VAR 0 12
135404: PUSH
135405: FOR_IN
135406: IFFALSE 135441
// if GetTag ( i ) > 0 then
135408: LD_VAR 0 4
135412: PPUSH
135413: CALL_OW 110
135417: PUSH
135418: LD_INT 0
135420: GREATER
135421: IFFALSE 135439
// mechs := mechs diff i ;
135423: LD_ADDR_VAR 0 12
135427: PUSH
135428: LD_VAR 0 12
135432: PUSH
135433: LD_VAR 0 4
135437: DIFF
135438: ST_TO_ADDR
135439: GO 135405
135441: POP
135442: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135443: LD_ADDR_VAR 0 8
135447: PUSH
135448: LD_EXP 100
135452: PUSH
135453: LD_VAR 0 1
135457: ARRAY
135458: PPUSH
135459: LD_INT 2
135461: PUSH
135462: LD_INT 25
135464: PUSH
135465: LD_INT 1
135467: PUSH
135468: EMPTY
135469: LIST
135470: LIST
135471: PUSH
135472: LD_INT 25
135474: PUSH
135475: LD_INT 5
135477: PUSH
135478: EMPTY
135479: LIST
135480: LIST
135481: PUSH
135482: LD_INT 25
135484: PUSH
135485: LD_INT 8
135487: PUSH
135488: EMPTY
135489: LIST
135490: LIST
135491: PUSH
135492: LD_INT 25
135494: PUSH
135495: LD_INT 9
135497: PUSH
135498: EMPTY
135499: LIST
135500: LIST
135501: PUSH
135502: EMPTY
135503: LIST
135504: LIST
135505: LIST
135506: LIST
135507: LIST
135508: PPUSH
135509: CALL_OW 72
135513: ST_TO_ADDR
// if not defenders and not solds then
135514: LD_VAR 0 2
135518: NOT
135519: PUSH
135520: LD_VAR 0 8
135524: NOT
135525: AND
135526: IFFALSE 135530
// exit ;
135528: GO 137300
// depot_under_attack := false ;
135530: LD_ADDR_VAR 0 16
135534: PUSH
135535: LD_INT 0
135537: ST_TO_ADDR
// sold_defenders := [ ] ;
135538: LD_ADDR_VAR 0 17
135542: PUSH
135543: EMPTY
135544: ST_TO_ADDR
// if mechs then
135545: LD_VAR 0 12
135549: IFFALSE 135702
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
135551: LD_ADDR_VAR 0 4
135555: PUSH
135556: LD_VAR 0 2
135560: PPUSH
135561: LD_INT 21
135563: PUSH
135564: LD_INT 2
135566: PUSH
135567: EMPTY
135568: LIST
135569: LIST
135570: PPUSH
135571: CALL_OW 72
135575: PUSH
135576: FOR_IN
135577: IFFALSE 135700
// begin if GetTag ( i ) <> 20 then
135579: LD_VAR 0 4
135583: PPUSH
135584: CALL_OW 110
135588: PUSH
135589: LD_INT 20
135591: NONEQUAL
135592: IFFALSE 135606
// SetTag ( i , 20 ) ;
135594: LD_VAR 0 4
135598: PPUSH
135599: LD_INT 20
135601: PPUSH
135602: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
135606: LD_VAR 0 4
135610: PPUSH
135611: CALL_OW 263
135615: PUSH
135616: LD_INT 1
135618: EQUAL
135619: PUSH
135620: LD_VAR 0 4
135624: PPUSH
135625: CALL_OW 311
135629: NOT
135630: AND
135631: IFFALSE 135698
// begin un := mechs [ 1 ] ;
135633: LD_ADDR_VAR 0 10
135637: PUSH
135638: LD_VAR 0 12
135642: PUSH
135643: LD_INT 1
135645: ARRAY
135646: ST_TO_ADDR
// ComExit ( un ) ;
135647: LD_VAR 0 10
135651: PPUSH
135652: CALL 106247 0 1
// AddComEnterUnit ( un , i ) ;
135656: LD_VAR 0 10
135660: PPUSH
135661: LD_VAR 0 4
135665: PPUSH
135666: CALL_OW 180
// SetTag ( un , 19 ) ;
135670: LD_VAR 0 10
135674: PPUSH
135675: LD_INT 19
135677: PPUSH
135678: CALL_OW 109
// mechs := mechs diff un ;
135682: LD_ADDR_VAR 0 12
135686: PUSH
135687: LD_VAR 0 12
135691: PUSH
135692: LD_VAR 0 10
135696: DIFF
135697: ST_TO_ADDR
// end ; end ;
135698: GO 135576
135700: POP
135701: POP
// if solds then
135702: LD_VAR 0 8
135706: IFFALSE 135765
// for i in solds do
135708: LD_ADDR_VAR 0 4
135712: PUSH
135713: LD_VAR 0 8
135717: PUSH
135718: FOR_IN
135719: IFFALSE 135763
// if not GetTag ( i ) then
135721: LD_VAR 0 4
135725: PPUSH
135726: CALL_OW 110
135730: NOT
135731: IFFALSE 135761
// begin defenders := defenders union i ;
135733: LD_ADDR_VAR 0 2
135737: PUSH
135738: LD_VAR 0 2
135742: PUSH
135743: LD_VAR 0 4
135747: UNION
135748: ST_TO_ADDR
// SetTag ( i , 18 ) ;
135749: LD_VAR 0 4
135753: PPUSH
135754: LD_INT 18
135756: PPUSH
135757: CALL_OW 109
// end ;
135761: GO 135718
135763: POP
135764: POP
// repeat wait ( 0 0$2 ) ;
135765: LD_INT 70
135767: PPUSH
135768: CALL_OW 67
// enemy := mc_scan [ base ] ;
135772: LD_ADDR_VAR 0 21
135776: PUSH
135777: LD_EXP 123
135781: PUSH
135782: LD_VAR 0 1
135786: ARRAY
135787: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135788: LD_EXP 100
135792: PUSH
135793: LD_VAR 0 1
135797: ARRAY
135798: NOT
135799: PUSH
135800: LD_EXP 100
135804: PUSH
135805: LD_VAR 0 1
135809: ARRAY
135810: PUSH
135811: EMPTY
135812: EQUAL
135813: OR
135814: IFFALSE 135851
// begin for i in defenders do
135816: LD_ADDR_VAR 0 4
135820: PUSH
135821: LD_VAR 0 2
135825: PUSH
135826: FOR_IN
135827: IFFALSE 135840
// ComStop ( i ) ;
135829: LD_VAR 0 4
135833: PPUSH
135834: CALL_OW 141
135838: GO 135826
135840: POP
135841: POP
// defenders := [ ] ;
135842: LD_ADDR_VAR 0 2
135846: PUSH
135847: EMPTY
135848: ST_TO_ADDR
// exit ;
135849: GO 137300
// end ; for i in defenders do
135851: LD_ADDR_VAR 0 4
135855: PUSH
135856: LD_VAR 0 2
135860: PUSH
135861: FOR_IN
135862: IFFALSE 136760
// begin e := NearestUnitToUnit ( enemy , i ) ;
135864: LD_ADDR_VAR 0 13
135868: PUSH
135869: LD_VAR 0 21
135873: PPUSH
135874: LD_VAR 0 4
135878: PPUSH
135879: CALL_OW 74
135883: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
135884: LD_ADDR_VAR 0 7
135888: PUSH
135889: LD_EXP 100
135893: PUSH
135894: LD_VAR 0 1
135898: ARRAY
135899: PPUSH
135900: LD_INT 2
135902: PUSH
135903: LD_INT 30
135905: PUSH
135906: LD_INT 0
135908: PUSH
135909: EMPTY
135910: LIST
135911: LIST
135912: PUSH
135913: LD_INT 30
135915: PUSH
135916: LD_INT 1
135918: PUSH
135919: EMPTY
135920: LIST
135921: LIST
135922: PUSH
135923: EMPTY
135924: LIST
135925: LIST
135926: LIST
135927: PPUSH
135928: CALL_OW 72
135932: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
135933: LD_ADDR_VAR 0 16
135937: PUSH
135938: LD_VAR 0 7
135942: NOT
135943: PUSH
135944: LD_VAR 0 7
135948: PPUSH
135949: LD_INT 3
135951: PUSH
135952: LD_INT 24
135954: PUSH
135955: LD_INT 600
135957: PUSH
135958: EMPTY
135959: LIST
135960: LIST
135961: PUSH
135962: EMPTY
135963: LIST
135964: LIST
135965: PPUSH
135966: CALL_OW 72
135970: OR
135971: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
135972: LD_VAR 0 4
135976: PPUSH
135977: CALL_OW 247
135981: PUSH
135982: LD_INT 2
135984: DOUBLE
135985: EQUAL
135986: IFTRUE 135990
135988: GO 136386
135990: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
135991: LD_VAR 0 4
135995: PPUSH
135996: CALL_OW 256
136000: PUSH
136001: LD_INT 1000
136003: EQUAL
136004: PUSH
136005: LD_VAR 0 4
136009: PPUSH
136010: LD_VAR 0 13
136014: PPUSH
136015: CALL_OW 296
136019: PUSH
136020: LD_INT 40
136022: LESS
136023: PUSH
136024: LD_VAR 0 13
136028: PPUSH
136029: LD_EXP 125
136033: PUSH
136034: LD_VAR 0 1
136038: ARRAY
136039: PPUSH
136040: CALL_OW 308
136044: OR
136045: AND
136046: IFFALSE 136168
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
136048: LD_VAR 0 4
136052: PPUSH
136053: CALL_OW 262
136057: PUSH
136058: LD_INT 1
136060: EQUAL
136061: PUSH
136062: LD_VAR 0 4
136066: PPUSH
136067: CALL_OW 261
136071: PUSH
136072: LD_INT 30
136074: LESS
136075: AND
136076: PUSH
136077: LD_VAR 0 7
136081: AND
136082: IFFALSE 136152
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
136084: LD_VAR 0 4
136088: PPUSH
136089: LD_VAR 0 7
136093: PPUSH
136094: LD_VAR 0 4
136098: PPUSH
136099: CALL_OW 74
136103: PPUSH
136104: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
136108: LD_VAR 0 4
136112: PPUSH
136113: LD_VAR 0 7
136117: PPUSH
136118: LD_VAR 0 4
136122: PPUSH
136123: CALL_OW 74
136127: PPUSH
136128: CALL_OW 296
136132: PUSH
136133: LD_INT 6
136135: LESS
136136: IFFALSE 136150
// SetFuel ( i , 100 ) ;
136138: LD_VAR 0 4
136142: PPUSH
136143: LD_INT 100
136145: PPUSH
136146: CALL_OW 240
// end else
136150: GO 136166
// ComAttackUnit ( i , e ) ;
136152: LD_VAR 0 4
136156: PPUSH
136157: LD_VAR 0 13
136161: PPUSH
136162: CALL_OW 115
// end else
136166: GO 136269
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
136168: LD_VAR 0 13
136172: PPUSH
136173: LD_EXP 125
136177: PUSH
136178: LD_VAR 0 1
136182: ARRAY
136183: PPUSH
136184: CALL_OW 308
136188: NOT
136189: PUSH
136190: LD_VAR 0 4
136194: PPUSH
136195: LD_VAR 0 13
136199: PPUSH
136200: CALL_OW 296
136204: PUSH
136205: LD_INT 40
136207: GREATEREQUAL
136208: AND
136209: PUSH
136210: LD_VAR 0 4
136214: PPUSH
136215: CALL_OW 256
136219: PUSH
136220: LD_INT 650
136222: LESSEQUAL
136223: OR
136224: PUSH
136225: LD_VAR 0 4
136229: PPUSH
136230: LD_EXP 124
136234: PUSH
136235: LD_VAR 0 1
136239: ARRAY
136240: PPUSH
136241: CALL_OW 308
136245: NOT
136246: AND
136247: IFFALSE 136269
// ComMoveToArea ( i , mc_parking [ base ] ) ;
136249: LD_VAR 0 4
136253: PPUSH
136254: LD_EXP 124
136258: PUSH
136259: LD_VAR 0 1
136263: ARRAY
136264: PPUSH
136265: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
136269: LD_VAR 0 4
136273: PPUSH
136274: CALL_OW 256
136278: PUSH
136279: LD_INT 1000
136281: LESS
136282: PUSH
136283: LD_VAR 0 4
136287: PPUSH
136288: CALL_OW 263
136292: PUSH
136293: LD_INT 1
136295: EQUAL
136296: AND
136297: PUSH
136298: LD_VAR 0 4
136302: PPUSH
136303: CALL_OW 311
136307: AND
136308: PUSH
136309: LD_VAR 0 4
136313: PPUSH
136314: LD_EXP 124
136318: PUSH
136319: LD_VAR 0 1
136323: ARRAY
136324: PPUSH
136325: CALL_OW 308
136329: AND
136330: IFFALSE 136384
// begin mech := IsDrivenBy ( i ) ;
136332: LD_ADDR_VAR 0 9
136336: PUSH
136337: LD_VAR 0 4
136341: PPUSH
136342: CALL_OW 311
136346: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
136347: LD_VAR 0 9
136351: PPUSH
136352: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
136356: LD_VAR 0 9
136360: PPUSH
136361: LD_VAR 0 4
136365: PPUSH
136366: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
136370: LD_VAR 0 9
136374: PPUSH
136375: LD_VAR 0 4
136379: PPUSH
136380: CALL_OW 180
// end ; end ; unit_human :
136384: GO 136731
136386: LD_INT 1
136388: DOUBLE
136389: EQUAL
136390: IFTRUE 136394
136392: GO 136730
136394: POP
// begin b := IsInUnit ( i ) ;
136395: LD_ADDR_VAR 0 18
136399: PUSH
136400: LD_VAR 0 4
136404: PPUSH
136405: CALL_OW 310
136409: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
136410: LD_ADDR_VAR 0 19
136414: PUSH
136415: LD_VAR 0 18
136419: NOT
136420: PUSH
136421: LD_VAR 0 18
136425: PPUSH
136426: CALL_OW 266
136430: PUSH
136431: LD_INT 32
136433: PUSH
136434: LD_INT 31
136436: PUSH
136437: EMPTY
136438: LIST
136439: LIST
136440: IN
136441: OR
136442: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
136443: LD_VAR 0 18
136447: PPUSH
136448: CALL_OW 266
136452: PUSH
136453: LD_INT 5
136455: EQUAL
136456: PUSH
136457: LD_VAR 0 4
136461: PPUSH
136462: CALL_OW 257
136466: PUSH
136467: LD_INT 1
136469: PUSH
136470: LD_INT 2
136472: PUSH
136473: LD_INT 3
136475: PUSH
136476: LD_INT 4
136478: PUSH
136479: EMPTY
136480: LIST
136481: LIST
136482: LIST
136483: LIST
136484: IN
136485: AND
136486: IFFALSE 136523
// begin class := AllowSpecClass ( i ) ;
136488: LD_ADDR_VAR 0 20
136492: PUSH
136493: LD_VAR 0 4
136497: PPUSH
136498: CALL 70343 0 1
136502: ST_TO_ADDR
// if class then
136503: LD_VAR 0 20
136507: IFFALSE 136523
// ComChangeProfession ( i , class ) ;
136509: LD_VAR 0 4
136513: PPUSH
136514: LD_VAR 0 20
136518: PPUSH
136519: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
136523: LD_VAR 0 16
136527: PUSH
136528: LD_VAR 0 2
136532: PPUSH
136533: LD_INT 21
136535: PUSH
136536: LD_INT 2
136538: PUSH
136539: EMPTY
136540: LIST
136541: LIST
136542: PPUSH
136543: CALL_OW 72
136547: PUSH
136548: LD_INT 1
136550: LESSEQUAL
136551: OR
136552: PUSH
136553: LD_VAR 0 19
136557: AND
136558: PUSH
136559: LD_VAR 0 4
136563: PUSH
136564: LD_VAR 0 17
136568: IN
136569: NOT
136570: AND
136571: IFFALSE 136664
// begin if b then
136573: LD_VAR 0 18
136577: IFFALSE 136626
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
136579: LD_VAR 0 18
136583: PPUSH
136584: LD_VAR 0 21
136588: PPUSH
136589: LD_VAR 0 18
136593: PPUSH
136594: CALL_OW 74
136598: PPUSH
136599: CALL_OW 296
136603: PUSH
136604: LD_INT 10
136606: LESS
136607: PUSH
136608: LD_VAR 0 18
136612: PPUSH
136613: CALL_OW 461
136617: PUSH
136618: LD_INT 7
136620: NONEQUAL
136621: AND
136622: IFFALSE 136626
// continue ;
136624: GO 135861
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
136626: LD_ADDR_VAR 0 17
136630: PUSH
136631: LD_VAR 0 17
136635: PPUSH
136636: LD_VAR 0 17
136640: PUSH
136641: LD_INT 1
136643: PLUS
136644: PPUSH
136645: LD_VAR 0 4
136649: PPUSH
136650: CALL_OW 1
136654: ST_TO_ADDR
// ComExitBuilding ( i ) ;
136655: LD_VAR 0 4
136659: PPUSH
136660: CALL_OW 122
// end ; if sold_defenders then
136664: LD_VAR 0 17
136668: IFFALSE 136728
// if i in sold_defenders then
136670: LD_VAR 0 4
136674: PUSH
136675: LD_VAR 0 17
136679: IN
136680: IFFALSE 136728
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
136682: LD_VAR 0 4
136686: PPUSH
136687: CALL_OW 314
136691: NOT
136692: PUSH
136693: LD_VAR 0 4
136697: PPUSH
136698: LD_VAR 0 13
136702: PPUSH
136703: CALL_OW 296
136707: PUSH
136708: LD_INT 30
136710: LESS
136711: AND
136712: IFFALSE 136728
// ComAttackUnit ( i , e ) ;
136714: LD_VAR 0 4
136718: PPUSH
136719: LD_VAR 0 13
136723: PPUSH
136724: CALL_OW 115
// end ; end ; end ;
136728: GO 136731
136730: POP
// if IsDead ( i ) then
136731: LD_VAR 0 4
136735: PPUSH
136736: CALL_OW 301
136740: IFFALSE 136758
// defenders := defenders diff i ;
136742: LD_ADDR_VAR 0 2
136746: PUSH
136747: LD_VAR 0 2
136751: PUSH
136752: LD_VAR 0 4
136756: DIFF
136757: ST_TO_ADDR
// end ;
136758: GO 135861
136760: POP
136761: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
136762: LD_VAR 0 21
136766: NOT
136767: PUSH
136768: LD_VAR 0 2
136772: NOT
136773: OR
136774: PUSH
136775: LD_EXP 100
136779: PUSH
136780: LD_VAR 0 1
136784: ARRAY
136785: NOT
136786: OR
136787: IFFALSE 135765
// MC_Reset ( base , 18 ) ;
136789: LD_VAR 0 1
136793: PPUSH
136794: LD_INT 18
136796: PPUSH
136797: CALL 42032 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
136801: LD_ADDR_VAR 0 2
136805: PUSH
136806: LD_VAR 0 2
136810: PUSH
136811: LD_VAR 0 2
136815: PPUSH
136816: LD_INT 2
136818: PUSH
136819: LD_INT 25
136821: PUSH
136822: LD_INT 1
136824: PUSH
136825: EMPTY
136826: LIST
136827: LIST
136828: PUSH
136829: LD_INT 25
136831: PUSH
136832: LD_INT 5
136834: PUSH
136835: EMPTY
136836: LIST
136837: LIST
136838: PUSH
136839: LD_INT 25
136841: PUSH
136842: LD_INT 8
136844: PUSH
136845: EMPTY
136846: LIST
136847: LIST
136848: PUSH
136849: LD_INT 25
136851: PUSH
136852: LD_INT 9
136854: PUSH
136855: EMPTY
136856: LIST
136857: LIST
136858: PUSH
136859: EMPTY
136860: LIST
136861: LIST
136862: LIST
136863: LIST
136864: LIST
136865: PPUSH
136866: CALL_OW 72
136870: DIFF
136871: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
136872: LD_VAR 0 21
136876: NOT
136877: PUSH
136878: LD_VAR 0 2
136882: PPUSH
136883: LD_INT 21
136885: PUSH
136886: LD_INT 2
136888: PUSH
136889: EMPTY
136890: LIST
136891: LIST
136892: PPUSH
136893: CALL_OW 72
136897: AND
136898: IFFALSE 137236
// begin tmp := FilterByTag ( defenders , 19 ) ;
136900: LD_ADDR_VAR 0 11
136904: PUSH
136905: LD_VAR 0 2
136909: PPUSH
136910: LD_INT 19
136912: PPUSH
136913: CALL 103431 0 2
136917: ST_TO_ADDR
// if tmp then
136918: LD_VAR 0 11
136922: IFFALSE 136992
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
136924: LD_ADDR_VAR 0 11
136928: PUSH
136929: LD_VAR 0 11
136933: PPUSH
136934: LD_INT 25
136936: PUSH
136937: LD_INT 3
136939: PUSH
136940: EMPTY
136941: LIST
136942: LIST
136943: PPUSH
136944: CALL_OW 72
136948: ST_TO_ADDR
// if tmp then
136949: LD_VAR 0 11
136953: IFFALSE 136992
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
136955: LD_ADDR_EXP 112
136959: PUSH
136960: LD_EXP 112
136964: PPUSH
136965: LD_VAR 0 1
136969: PPUSH
136970: LD_EXP 112
136974: PUSH
136975: LD_VAR 0 1
136979: ARRAY
136980: PUSH
136981: LD_VAR 0 11
136985: UNION
136986: PPUSH
136987: CALL_OW 1
136991: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
136992: LD_VAR 0 1
136996: PPUSH
136997: LD_INT 19
136999: PPUSH
137000: CALL 42032 0 2
// repeat wait ( 0 0$1 ) ;
137004: LD_INT 35
137006: PPUSH
137007: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137011: LD_EXP 100
137015: PUSH
137016: LD_VAR 0 1
137020: ARRAY
137021: NOT
137022: PUSH
137023: LD_EXP 100
137027: PUSH
137028: LD_VAR 0 1
137032: ARRAY
137033: PUSH
137034: EMPTY
137035: EQUAL
137036: OR
137037: IFFALSE 137074
// begin for i in defenders do
137039: LD_ADDR_VAR 0 4
137043: PUSH
137044: LD_VAR 0 2
137048: PUSH
137049: FOR_IN
137050: IFFALSE 137063
// ComStop ( i ) ;
137052: LD_VAR 0 4
137056: PPUSH
137057: CALL_OW 141
137061: GO 137049
137063: POP
137064: POP
// defenders := [ ] ;
137065: LD_ADDR_VAR 0 2
137069: PUSH
137070: EMPTY
137071: ST_TO_ADDR
// exit ;
137072: GO 137300
// end ; for i in defenders do
137074: LD_ADDR_VAR 0 4
137078: PUSH
137079: LD_VAR 0 2
137083: PUSH
137084: FOR_IN
137085: IFFALSE 137174
// begin if not IsInArea ( i , mc_parking [ base ] ) then
137087: LD_VAR 0 4
137091: PPUSH
137092: LD_EXP 124
137096: PUSH
137097: LD_VAR 0 1
137101: ARRAY
137102: PPUSH
137103: CALL_OW 308
137107: NOT
137108: IFFALSE 137132
// ComMoveToArea ( i , mc_parking [ base ] ) else
137110: LD_VAR 0 4
137114: PPUSH
137115: LD_EXP 124
137119: PUSH
137120: LD_VAR 0 1
137124: ARRAY
137125: PPUSH
137126: CALL_OW 113
137130: GO 137172
// if GetControl ( i ) = control_manual then
137132: LD_VAR 0 4
137136: PPUSH
137137: CALL_OW 263
137141: PUSH
137142: LD_INT 1
137144: EQUAL
137145: IFFALSE 137172
// if IsDrivenBy ( i ) then
137147: LD_VAR 0 4
137151: PPUSH
137152: CALL_OW 311
137156: IFFALSE 137172
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
137158: LD_VAR 0 4
137162: PPUSH
137163: CALL_OW 311
137167: PPUSH
137168: CALL_OW 121
// end ;
137172: GO 137084
137174: POP
137175: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
137176: LD_VAR 0 2
137180: PPUSH
137181: LD_INT 95
137183: PUSH
137184: LD_EXP 124
137188: PUSH
137189: LD_VAR 0 1
137193: ARRAY
137194: PUSH
137195: EMPTY
137196: LIST
137197: LIST
137198: PPUSH
137199: CALL_OW 72
137203: PUSH
137204: LD_VAR 0 2
137208: EQUAL
137209: PUSH
137210: LD_EXP 123
137214: PUSH
137215: LD_VAR 0 1
137219: ARRAY
137220: OR
137221: PUSH
137222: LD_EXP 100
137226: PUSH
137227: LD_VAR 0 1
137231: ARRAY
137232: NOT
137233: OR
137234: IFFALSE 137004
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
137236: LD_ADDR_EXP 122
137240: PUSH
137241: LD_EXP 122
137245: PPUSH
137246: LD_VAR 0 1
137250: PPUSH
137251: LD_VAR 0 2
137255: PPUSH
137256: LD_INT 21
137258: PUSH
137259: LD_INT 2
137261: PUSH
137262: EMPTY
137263: LIST
137264: LIST
137265: PPUSH
137266: CALL_OW 72
137270: PPUSH
137271: CALL_OW 1
137275: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
137276: LD_VAR 0 1
137280: PPUSH
137281: LD_INT 19
137283: PPUSH
137284: CALL 42032 0 2
// MC_Reset ( base , 20 ) ;
137288: LD_VAR 0 1
137292: PPUSH
137293: LD_INT 20
137295: PPUSH
137296: CALL 42032 0 2
// end ; end_of_file
137300: LD_VAR 0 3
137304: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
137305: LD_VAR 0 1
137309: PUSH
137310: LD_INT 200
137312: DOUBLE
137313: GREATEREQUAL
137314: IFFALSE 137322
137316: LD_INT 299
137318: DOUBLE
137319: LESSEQUAL
137320: IFTRUE 137324
137322: GO 137356
137324: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
137325: LD_VAR 0 1
137329: PPUSH
137330: LD_VAR 0 2
137334: PPUSH
137335: LD_VAR 0 3
137339: PPUSH
137340: LD_VAR 0 4
137344: PPUSH
137345: LD_VAR 0 5
137349: PPUSH
137350: CALL 126091 0 5
137354: GO 137433
137356: LD_INT 300
137358: DOUBLE
137359: GREATEREQUAL
137360: IFFALSE 137368
137362: LD_INT 399
137364: DOUBLE
137365: LESSEQUAL
137366: IFTRUE 137370
137368: GO 137432
137370: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
137371: LD_VAR 0 1
137375: PPUSH
137376: LD_VAR 0 2
137380: PPUSH
137381: LD_VAR 0 3
137385: PPUSH
137386: LD_VAR 0 4
137390: PPUSH
137391: LD_VAR 0 5
137395: PPUSH
137396: LD_VAR 0 6
137400: PPUSH
137401: LD_VAR 0 7
137405: PPUSH
137406: LD_VAR 0 8
137410: PPUSH
137411: LD_VAR 0 9
137415: PPUSH
137416: LD_VAR 0 10
137420: PPUSH
137421: LD_VAR 0 11
137425: PPUSH
137426: CALL 122424 0 11
137430: GO 137433
137432: POP
// end ;
137433: PPOPN 11
137435: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
137436: LD_VAR 0 1
137440: PPUSH
137441: LD_VAR 0 2
137445: PPUSH
137446: LD_VAR 0 3
137450: PPUSH
137451: LD_VAR 0 4
137455: PPUSH
137456: LD_VAR 0 5
137460: PPUSH
137461: CALL 125827 0 5
// end ; end_of_file
137465: PPOPN 5
137467: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
137468: LD_VAR 0 1
137472: PPUSH
137473: LD_VAR 0 2
137477: PPUSH
137478: LD_VAR 0 3
137482: PPUSH
137483: LD_VAR 0 4
137487: PPUSH
137488: LD_VAR 0 5
137492: PPUSH
137493: LD_VAR 0 6
137497: PPUSH
137498: CALL 110076 0 6
// end ;
137502: PPOPN 6
137504: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
137505: LD_INT 0
137507: PPUSH
// begin if not units then
137508: LD_VAR 0 1
137512: NOT
137513: IFFALSE 137517
// exit ;
137515: GO 137517
// end ;
137517: PPOPN 7
137519: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
137520: CALL 109980 0 0
// end ;
137524: PPOPN 1
137526: END
