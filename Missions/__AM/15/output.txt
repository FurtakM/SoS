// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33783 0 0
// InitNature ;
  19: CALL 33607 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10881 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14788 0 0
// MC_Start ( ) ;
  60: CALL 35895 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58060 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58153 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57503 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57318 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58060 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58153 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57318 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57503 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 57933 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57000 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58060 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58153 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57318 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58060 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58153 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57210 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58471 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57642 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 57933 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 57933 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58265 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57318 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 57884 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 63488 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 70239 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 70239 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 70239 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 70239 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 70239 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 63488 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 63488 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 63488 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 63488 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 63488 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 63488 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 63488 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 63488 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 63488 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 63488 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 63488 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 63488 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 63488 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 63488 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 63488 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 63488 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 63488 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 63488 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 63488 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 63488 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 63488 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 63488 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 63488 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 63488 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 63488 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 63488 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 63488 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 63488 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 70239 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 63488 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 63488 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 63488 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 73648 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 70239 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57503 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57366 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 58784 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57366 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57366 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 58784 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 58784 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 70239 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 73648 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 105984 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 105984 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106032 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106032 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 70239 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 6
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 70239 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 6
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 70239 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 7
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 70239 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 70239 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 70239 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 70239 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 70239 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9891
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 8400
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: IFFALSE 9361
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9335: LD_INT 53
9337: PPUSH
9338: LD_INT 6
9340: PPUSH
9341: LD_INT 2
9343: PPUSH
9344: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9348: LD_INT 59
9350: PPUSH
9351: LD_INT 6
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: CALL_OW 322
// end ; if activeAttacks then
9361: LD_EXP 16
9365: IFFALSE 9885
// begin if missionStage = 2 then
9367: LD_EXP 15
9371: PUSH
9372: LD_INT 2
9374: EQUAL
9375: IFFALSE 9385
// strength := 1 ;
9377: LD_ADDR_VAR 0 5
9381: PUSH
9382: LD_INT 1
9384: ST_TO_ADDR
// if missionStage > 2 then
9385: LD_EXP 15
9389: PUSH
9390: LD_INT 2
9392: GREATER
9393: IFFALSE 9403
// strength := 2 ;
9395: LD_ADDR_VAR 0 5
9399: PUSH
9400: LD_INT 2
9402: ST_TO_ADDR
// if missionStage > 6 then
9403: LD_EXP 15
9407: PUSH
9408: LD_INT 6
9410: GREATER
9411: IFFALSE 9421
// strength := 3 ;
9413: LD_ADDR_VAR 0 5
9417: PUSH
9418: LD_INT 3
9420: ST_TO_ADDR
// if missionStage > 10 then
9421: LD_EXP 15
9425: PUSH
9426: LD_INT 10
9428: GREATER
9429: IFFALSE 9439
// strength := 4 ;
9431: LD_ADDR_VAR 0 5
9435: PUSH
9436: LD_INT 4
9438: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9439: LD_ADDR_VAR 0 2
9443: PUSH
9444: LD_VAR 0 5
9448: PPUSH
9449: CALL 8011 0 1
9453: ST_TO_ADDR
// for i in tmp do
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: FOR_IN
9465: IFFALSE 9565
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9467: LD_VAR 0 1
9471: PPUSH
9472: LD_VAR 0 4
9476: PUSH
9477: LD_INT 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: CALL_OW 12
9487: ARRAY
9488: PPUSH
9489: LD_INT 0
9491: PPUSH
9492: CALL_OW 49
// if i = sewiVeh then
9496: LD_VAR 0 1
9500: PUSH
9501: LD_EXP 68
9505: EQUAL
9506: IFFALSE 9541
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9508: LD_ADDR_EXP 67
9512: PUSH
9513: LD_STRING Vsevolod
9515: PPUSH
9516: LD_INT 0
9518: PPUSH
9519: LD_STRING 
9521: PPUSH
9522: CALL 63488 0 3
9526: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9527: LD_EXP 67
9531: PPUSH
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9541: LD_VAR 0 1
9545: PPUSH
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 197
9551: PPUSH
9552: CALL_OW 111
// wait ( 0 0$2 ) ;
9556: LD_INT 70
9558: PPUSH
9559: CALL_OW 67
// end ;
9563: GO 9464
9565: POP
9566: POP
// repeat wait ( 0 0$1 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// for i in tmp do
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: FOR_IN
9585: IFFALSE 9866
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9587: LD_INT 81
9589: PUSH
9590: LD_INT 6
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 91
9599: PUSH
9600: LD_VAR 0 1
9604: PUSH
9605: LD_INT 12
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL_OW 69
9621: IFFALSE 9679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9623: LD_VAR 0 1
9627: PPUSH
9628: LD_INT 81
9630: PUSH
9631: LD_INT 6
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: LD_INT 91
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: LD_INT 12
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: LIST
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PPUSH
9658: CALL_OW 69
9662: PPUSH
9663: LD_VAR 0 1
9667: PPUSH
9668: CALL_OW 74
9672: PPUSH
9673: CALL_OW 115
9677: GO 9864
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9679: LD_INT 9
9681: PPUSH
9682: LD_INT 81
9684: PUSH
9685: LD_INT 6
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PPUSH
9692: CALL_OW 70
9696: IFFALSE 9830
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9698: LD_VAR 0 1
9702: PPUSH
9703: LD_VAR 0 6
9707: PUSH
9708: LD_INT 1
9710: ARRAY
9711: PUSH
9712: LD_INT 1
9714: ARRAY
9715: PPUSH
9716: LD_VAR 0 6
9720: PUSH
9721: LD_INT 1
9723: ARRAY
9724: PUSH
9725: LD_INT 2
9727: ARRAY
9728: PPUSH
9729: CALL_OW 297
9733: PUSH
9734: LD_INT 10
9736: GREATER
9737: PUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 9
9745: PPUSH
9746: CALL_OW 308
9750: NOT
9751: AND
9752: IFFALSE 9791
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9754: LD_VAR 0 1
9758: PPUSH
9759: LD_VAR 0 6
9763: PUSH
9764: LD_INT 1
9766: ARRAY
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PPUSH
9772: LD_VAR 0 6
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PUSH
9781: LD_INT 2
9783: ARRAY
9784: PPUSH
9785: CALL_OW 114
9789: GO 9828
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: LD_INT 81
9801: PUSH
9802: LD_INT 6
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PPUSH
9809: CALL_OW 70
9813: PPUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: CALL_OW 74
9823: PPUSH
9824: CALL_OW 115
// end else
9828: GO 9864
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9830: LD_VAR 0 1
9834: PPUSH
9835: LD_INT 81
9837: PUSH
9838: LD_INT 6
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PPUSH
9845: CALL_OW 69
9849: PPUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 74
9859: PPUSH
9860: CALL_OW 115
// end ;
9864: GO 9584
9866: POP
9867: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9868: LD_INT 22
9870: PUSH
9871: LD_INT 6
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 69
9882: NOT
9883: IFFALSE 9567
// end ; until russianDestroyed ;
9885: LD_EXP 21
9889: IFFALSE 9225
// end ;
9891: PPOPN 6
9893: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 21
9898: NOT
9899: PUSH
9900: LD_EXP 15
9904: PUSH
9905: LD_INT 6
9907: GREATEREQUAL
9908: AND
9909: PUSH
9910: LD_INT 2
9912: PPUSH
9913: LD_INT 1
9915: PPUSH
9916: CALL 58784 0 2
9920: NOT
9921: AND
9922: IFFALSE 10878
9924: GO 9926
9926: DISABLE
9927: LD_INT 0
9929: PPUSH
9930: PPUSH
9931: PPUSH
9932: PPUSH
// begin enable ;
9933: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: NOT
9963: IFFALSE 9967
// exit ;
9965: GO 10878
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9967: LD_ADDR_VAR 0 4
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 30
9984: PUSH
9985: LD_INT 34
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: ST_TO_ADDR
// if Prob ( 40 ) then
10001: LD_INT 40
10003: PPUSH
10004: CALL_OW 13
10008: IFFALSE 10135
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10010: LD_INT 2
10012: PPUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 49
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL 57366 0 2
// end else
10133: GO 10258
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10135: LD_INT 2
10137: PPUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 47
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 46
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: PPUSH
10254: CALL 57366 0 2
// end ; if Difficulty > 1 then
10258: LD_OWVAR 67
10262: PUSH
10263: LD_INT 1
10265: GREATER
10266: IFFALSE 10296
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10268: LD_INT 2
10270: PPUSH
10271: LD_INT 24
10273: PUSH
10274: LD_INT 3
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: LD_INT 47
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: PUSH
10289: EMPTY
10290: LIST
10291: PPUSH
10292: CALL 57366 0 2
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10303: LD_INT 2
10305: PPUSH
10306: LD_INT 1
10308: PPUSH
10309: CALL 58784 0 2
10313: PUSH
10314: LD_INT 6
10316: PUSH
10317: LD_INT 7
10319: PUSH
10320: LD_INT 7
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: LD_OWVAR 67
10332: ARRAY
10333: GREATEREQUAL
10334: IFFALSE 10296
// wait ( 0 0$30 ) ;
10336: LD_INT 1050
10338: PPUSH
10339: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10343: LD_ADDR_VAR 0 2
10347: PUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_INT 1
10353: PPUSH
10354: CALL 58784 0 2
10358: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10359: LD_ADDR_EXP 118
10363: PUSH
10364: LD_EXP 118
10368: PPUSH
10369: LD_INT 2
10371: PPUSH
10372: LD_EXP 118
10376: PUSH
10377: LD_INT 2
10379: ARRAY
10380: PUSH
10381: LD_VAR 0 2
10385: DIFF
10386: PPUSH
10387: CALL_OW 1
10391: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10392: LD_ADDR_VAR 0 3
10396: PUSH
10397: LD_INT 0
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: ST_TO_ADDR
// if target then
10408: LD_VAR 0 3
10412: IFFALSE 10540
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10414: LD_ADDR_VAR 0 2
10418: PUSH
10419: LD_VAR 0 2
10423: PPUSH
10424: LD_INT 24
10426: PUSH
10427: LD_INT 250
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 72
10438: ST_TO_ADDR
// for i in tmp do
10439: LD_ADDR_VAR 0 1
10443: PUSH
10444: LD_VAR 0 2
10448: PUSH
10449: FOR_IN
10450: IFFALSE 10490
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 297
10467: PUSH
10468: LD_INT 9
10470: GREATER
10471: IFFALSE 10488
// ComMoveXY ( i , 139 , 89 ) ;
10473: LD_VAR 0 1
10477: PPUSH
10478: LD_INT 139
10480: PPUSH
10481: LD_INT 89
10483: PPUSH
10484: CALL_OW 111
10488: GO 10449
10490: POP
10491: POP
// wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10499: LD_VAR 0 2
10503: PPUSH
10504: LD_INT 92
10506: PUSH
10507: LD_INT 139
10509: PUSH
10510: LD_INT 89
10512: PUSH
10513: LD_INT 9
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PPUSH
10522: CALL_OW 72
10526: PUSH
10527: LD_VAR 0 2
10531: PUSH
10532: LD_INT 1
10534: MINUS
10535: GREATEREQUAL
10536: IFFALSE 10414
// end else
10538: GO 10682
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10540: LD_VAR 0 2
10544: PPUSH
10545: LD_VAR 0 4
10549: PUSH
10550: LD_INT 1
10552: ARRAY
10553: PPUSH
10554: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_INT 24
10570: PUSH
10571: LD_INT 250
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 72
10582: ST_TO_ADDR
// for i in tmp do
10583: LD_ADDR_VAR 0 1
10587: PUSH
10588: LD_VAR 0 2
10592: PUSH
10593: FOR_IN
10594: IFFALSE 10634
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 297
10611: PUSH
10612: LD_INT 9
10614: GREATER
10615: IFFALSE 10632
// ComMoveXY ( i , 124 , 139 ) ;
10617: LD_VAR 0 1
10621: PPUSH
10622: LD_INT 124
10624: PPUSH
10625: LD_INT 139
10627: PPUSH
10628: CALL_OW 111
10632: GO 10593
10634: POP
10635: POP
// wait ( 0 0$1 ) ;
10636: LD_INT 35
10638: PPUSH
10639: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10643: LD_VAR 0 2
10647: PPUSH
10648: LD_INT 92
10650: PUSH
10651: LD_INT 124
10653: PUSH
10654: LD_INT 139
10656: PUSH
10657: LD_INT 9
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 72
10670: PUSH
10671: LD_VAR 0 2
10675: PUSH
10676: LD_INT 1
10678: MINUS
10679: GREATEREQUAL
10680: IFFALSE 10558
// end ; repeat wait ( 0 0$1 ) ;
10682: LD_INT 35
10684: PPUSH
10685: CALL_OW 67
// for i in tmp do
10689: LD_ADDR_VAR 0 1
10693: PUSH
10694: LD_VAR 0 2
10698: PUSH
10699: FOR_IN
10700: IFFALSE 10869
// begin if GetLives ( i ) > 251 then
10702: LD_VAR 0 1
10706: PPUSH
10707: CALL_OW 256
10711: PUSH
10712: LD_INT 251
10714: GREATER
10715: IFFALSE 10840
// begin if GetWeapon ( i ) = ru_time_lapser then
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 264
10726: PUSH
10727: LD_INT 49
10729: EQUAL
10730: IFFALSE 10786
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 2
10739: PUSH
10740: LD_INT 22
10742: PUSH
10743: LD_INT 1
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 8
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PPUSH
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 74
10779: PPUSH
10780: CALL_OW 112
10784: GO 10838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10786: LD_VAR 0 1
10790: PPUSH
10791: LD_INT 2
10793: PUSH
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 8
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: PPUSH
10819: CALL_OW 69
10823: PPUSH
10824: LD_VAR 0 1
10828: PPUSH
10829: CALL_OW 74
10833: PPUSH
10834: CALL_OW 115
// end else
10838: GO 10867
// if IsDead ( i ) then
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 301
10849: IFFALSE 10867
// tmp := tmp diff i ;
10851: LD_ADDR_VAR 0 2
10855: PUSH
10856: LD_VAR 0 2
10860: PUSH
10861: LD_VAR 0 1
10865: DIFF
10866: ST_TO_ADDR
// end ;
10867: GO 10699
10869: POP
10870: POP
// until not tmp ;
10871: LD_VAR 0 2
10875: NOT
10876: IFFALSE 10682
// end ; end_of_file
10878: PPOPN 4
10880: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
10887: PPUSH
10888: PPUSH
// side := 7 ;
10889: LD_ADDR_VAR 0 5
10893: PUSH
10894: LD_INT 7
10896: ST_TO_ADDR
// uc_side := side ;
10897: LD_ADDR_OWVAR 20
10901: PUSH
10902: LD_VAR 0 5
10906: ST_TO_ADDR
// uc_nation := 1 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 1
10914: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10915: LD_ADDR_VAR 0 2
10919: PUSH
10920: LD_INT 22
10922: PUSH
10923: LD_VAR 0 5
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 3
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: FOR_IN
10952: IFFALSE 10968
// SetBLevel ( i , 10 ) ;
10954: LD_VAR 0 2
10958: PPUSH
10959: LD_INT 10
10961: PPUSH
10962: CALL_OW 241
10966: GO 10951
10968: POP
10969: POP
// base := GetBase ( al_depot ) ;
10970: LD_ADDR_VAR 0 4
10974: PUSH
10975: LD_INT 2
10977: PPUSH
10978: CALL_OW 274
10982: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10983: LD_ADDR_VAR 0 6
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_VAR 0 5
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 30
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: PPUSH
11014: CALL_OW 69
11018: ST_TO_ADDR
// if teleport then
11019: LD_VAR 0 6
11023: IFFALSE 11044
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11025: LD_VAR 0 6
11029: PUSH
11030: LD_INT 1
11032: ARRAY
11033: PPUSH
11034: LD_INT 262
11036: PPUSH
11037: LD_INT 119
11039: PPUSH
11040: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11044: LD_VAR 0 4
11048: PPUSH
11049: LD_INT 1
11051: PPUSH
11052: LD_INT 19500
11054: PPUSH
11055: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11059: LD_VAR 0 4
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: LD_INT 200
11069: PPUSH
11070: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11074: LD_VAR 0 4
11078: PPUSH
11079: LD_INT 3
11081: PPUSH
11082: LD_INT 650
11084: PPUSH
11085: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11089: LD_ADDR_EXP 71
11093: PUSH
11094: LD_STRING Roth
11096: PPUSH
11097: CALL_OW 25
11101: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11102: LD_ADDR_EXP 72
11106: PUSH
11107: LD_STRING Simms
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_STRING 10c_
11118: PPUSH
11119: CALL 63488 0 3
11123: ST_TO_ADDR
// if not Simms then
11124: LD_EXP 72
11128: NOT
11129: IFFALSE 11159
// begin uc_nation := 1 ;
11131: LD_ADDR_OWVAR 21
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11139: LD_INT 2
11141: PPUSH
11142: LD_INT 10
11144: PPUSH
11145: CALL_OW 384
// Simms := CreateHuman ;
11149: LD_ADDR_EXP 72
11153: PUSH
11154: CALL_OW 44
11158: ST_TO_ADDR
// end ; uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11167: LD_ADDR_EXP 73
11171: PUSH
11172: LD_STRING Kirilenkova
11174: PPUSH
11175: CALL_OW 25
11179: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11180: LD_ADDR_EXP 87
11184: PUSH
11185: LD_STRING Oblukov
11187: PPUSH
11188: CALL_OW 25
11192: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11193: LD_ADDR_EXP 74
11197: PUSH
11198: LD_STRING Dolgov
11200: PPUSH
11201: CALL_OW 25
11205: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11206: LD_ADDR_EXP 75
11210: PUSH
11211: LD_STRING Petrosyan
11213: PPUSH
11214: CALL_OW 25
11218: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11219: LD_ADDR_EXP 86
11223: PUSH
11224: LD_STRING Scholtze
11226: PPUSH
11227: CALL_OW 25
11231: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11232: LD_ADDR_EXP 85
11236: PUSH
11237: LD_STRING Kapitsova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11245: LD_ADDR_EXP 76
11249: PUSH
11250: LD_STRING Petrovova
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Kuzmov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11271: LD_ADDR_EXP 84
11275: PUSH
11276: LD_STRING Karamazov
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11284: LD_STRING 13_Lipshchin_1
11286: PPUSH
11287: LD_INT 0
11289: PPUSH
11290: CALL_OW 30
11294: IFFALSE 11309
// Lipshchin := NewCharacter ( Lipshchin ) ;
11296: LD_ADDR_EXP 78
11300: PUSH
11301: LD_STRING Lipshchin
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11309: LD_STRING 13_Titov_1
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: CALL_OW 30
11319: IFFALSE 11334
// Titov := NewCharacter ( Titov ) ;
11321: LD_ADDR_EXP 80
11325: PUSH
11326: LD_STRING Titov
11328: PPUSH
11329: CALL_OW 25
11333: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11334: LD_STRING 13_Gnyevko_1
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL_OW 30
11344: IFFALSE 11359
// Gnyevko := NewCharacter ( Gnyevko ) ;
11346: LD_ADDR_EXP 79
11350: PUSH
11351: LD_STRING Gnyevko
11353: PPUSH
11354: CALL_OW 25
11358: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11359: LD_STRING 13_Xavier_1
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL_OW 30
11369: IFFALSE 11384
// Xavier := NewCharacter ( Xavier2 ) ;
11371: LD_ADDR_EXP 81
11375: PUSH
11376: LD_STRING Xavier2
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11384: LD_STRING 13_Belkov_1
11386: PPUSH
11387: LD_INT 0
11389: PPUSH
11390: CALL_OW 30
11394: IFFALSE 11409
// Belkov := NewCharacter ( Belkov ) ;
11396: LD_ADDR_EXP 82
11400: PUSH
11401: LD_STRING Belkov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// if not BurlakStatus then
11409: LD_EXP 9
11413: NOT
11414: IFFALSE 11429
// Burlak = NewCharacter ( Burlak ) ;
11416: LD_ADDR_EXP 83
11420: PUSH
11421: LD_STRING Burlak
11423: PPUSH
11424: CALL_OW 25
11428: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11429: LD_ADDR_VAR 0 3
11433: PUSH
11434: LD_EXP 71
11438: PUSH
11439: LD_EXP 73
11443: PUSH
11444: LD_EXP 87
11448: PUSH
11449: LD_EXP 74
11453: PUSH
11454: LD_EXP 75
11458: PUSH
11459: LD_EXP 86
11463: PUSH
11464: LD_EXP 85
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_EXP 77
11478: PUSH
11479: LD_EXP 84
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: ST_TO_ADDR
// if Simms then
11496: LD_EXP 72
11500: IFFALSE 11518
// tmp := tmp ^ Simms ;
11502: LD_ADDR_VAR 0 3
11506: PUSH
11507: LD_VAR 0 3
11511: PUSH
11512: LD_EXP 72
11516: ADD
11517: ST_TO_ADDR
// if Titov then
11518: LD_EXP 80
11522: IFFALSE 11540
// tmp := tmp ^ Titov ;
11524: LD_ADDR_VAR 0 3
11528: PUSH
11529: LD_VAR 0 3
11533: PUSH
11534: LD_EXP 80
11538: ADD
11539: ST_TO_ADDR
// if Lipshchin then
11540: LD_EXP 78
11544: IFFALSE 11562
// tmp := tmp ^ Lipshchin ;
11546: LD_ADDR_VAR 0 3
11550: PUSH
11551: LD_VAR 0 3
11555: PUSH
11556: LD_EXP 78
11560: ADD
11561: ST_TO_ADDR
// if Gnyevko then
11562: LD_EXP 79
11566: IFFALSE 11584
// tmp := tmp ^ Gnyevko ;
11568: LD_ADDR_VAR 0 3
11572: PUSH
11573: LD_VAR 0 3
11577: PUSH
11578: LD_EXP 79
11582: ADD
11583: ST_TO_ADDR
// if Xavier then
11584: LD_EXP 81
11588: IFFALSE 11606
// tmp := tmp ^ Xavier ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_VAR 0 3
11599: PUSH
11600: LD_EXP 81
11604: ADD
11605: ST_TO_ADDR
// if Belkov then
11606: LD_EXP 82
11610: IFFALSE 11628
// tmp := tmp ^ Belkov ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 3
11621: PUSH
11622: LD_EXP 82
11626: ADD
11627: ST_TO_ADDR
// if Burlak then
11628: LD_EXP 83
11632: IFFALSE 11650
// tmp := tmp ^ Burlak ;
11634: LD_ADDR_VAR 0 3
11638: PUSH
11639: LD_VAR 0 3
11643: PUSH
11644: LD_EXP 83
11648: ADD
11649: ST_TO_ADDR
// for i = 1 to 8 do
11650: LD_ADDR_VAR 0 2
11654: PUSH
11655: DOUBLE
11656: LD_INT 1
11658: DEC
11659: ST_TO_ADDR
11660: LD_INT 8
11662: PUSH
11663: FOR_TO
11664: IFFALSE 11730
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11666: LD_ADDR_OWVAR 21
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: LD_INT 3
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 1
11683: PPUSH
11684: LD_INT 2
11686: PPUSH
11687: CALL_OW 12
11691: ARRAY
11692: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11693: LD_INT 0
11695: PPUSH
11696: LD_VAR 0 2
11700: PUSH
11701: LD_INT 2
11703: DIV
11704: PPUSH
11705: LD_INT 10
11707: PPUSH
11708: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11712: LD_ADDR_VAR 0 3
11716: PUSH
11717: LD_VAR 0 3
11721: PUSH
11722: CALL_OW 44
11726: ADD
11727: ST_TO_ADDR
// end ;
11728: GO 11663
11730: POP
11731: POP
// for i in tmp do
11732: LD_ADDR_VAR 0 2
11736: PUSH
11737: LD_VAR 0 3
11741: PUSH
11742: FOR_IN
11743: IFFALSE 11768
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_INT 260
11752: PPUSH
11753: LD_INT 235
11755: PPUSH
11756: LD_INT 8
11758: PPUSH
11759: LD_INT 0
11761: PPUSH
11762: CALL_OW 50
11766: GO 11742
11768: POP
11769: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11770: LD_ADDR_EXP 99
11774: PUSH
11775: LD_EXP 99
11779: PPUSH
11780: LD_INT 1
11782: PPUSH
11783: LD_INT 22
11785: PUSH
11786: LD_VAR 0 5
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: LD_INT 3
11797: PUSH
11798: LD_INT 21
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PPUSH
11816: CALL_OW 69
11820: PUSH
11821: LD_EXP 71
11825: PUSH
11826: LD_EXP 72
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: DIFF
11835: PPUSH
11836: CALL_OW 1
11840: ST_TO_ADDR
// uc_side := 0 ;
11841: LD_ADDR_OWVAR 20
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// uc_nation := 0 ;
11849: LD_ADDR_OWVAR 21
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// for i = 1 to 5 do
11857: LD_ADDR_VAR 0 2
11861: PUSH
11862: DOUBLE
11863: LD_INT 1
11865: DEC
11866: ST_TO_ADDR
11867: LD_INT 5
11869: PUSH
11870: FOR_TO
11871: IFFALSE 11908
// begin InitHc ;
11873: CALL_OW 19
// hc_class := class_apeman ;
11877: LD_ADDR_OWVAR 28
11881: PUSH
11882: LD_INT 12
11884: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11885: CALL_OW 44
11889: PPUSH
11890: LD_INT 299
11892: PPUSH
11893: LD_INT 229
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: LD_INT 0
11901: PPUSH
11902: CALL_OW 50
// end ;
11906: GO 11870
11908: POP
11909: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11910: LD_EXP 71
11914: PPUSH
11915: LD_INT 259
11917: PPUSH
11918: LD_INT 235
11920: PPUSH
11921: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11925: LD_EXP 71
11929: PPUSH
11930: LD_INT 262
11932: PPUSH
11933: LD_INT 235
11935: PPUSH
11936: CALL_OW 178
// if Simms then
11940: LD_EXP 72
11944: IFFALSE 11975
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11946: LD_EXP 72
11950: PPUSH
11951: LD_INT 262
11953: PPUSH
11954: LD_INT 235
11956: PPUSH
11957: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11961: LD_EXP 72
11965: PPUSH
11966: LD_EXP 71
11970: PPUSH
11971: CALL_OW 179
// end ; end ;
11975: LD_VAR 0 1
11979: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11980: LD_EXP 31
11984: PUSH
11985: LD_EXP 23
11989: NOT
11990: AND
11991: IFFALSE 12167
11993: GO 11995
11995: DISABLE
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
12000: PPUSH
// begin enable ;
12001: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12002: LD_ADDR_VAR 0 2
12006: PUSH
12007: LD_INT 81
12009: PUSH
12010: LD_INT 7
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: LD_INT 32
12022: PUSH
12023: LD_INT 3
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 30
12032: PUSH
12033: LD_INT 30
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 28
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 34
12052: PUSH
12053: LD_INT 49
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 10
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 8
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL_OW 69
12097: ST_TO_ADDR
// if not tmp then
12098: LD_VAR 0 2
12102: NOT
12103: IFFALSE 12107
// exit ;
12105: GO 12167
// target := tmp [ rand ( 1 , tmp ) ] ;
12107: LD_ADDR_VAR 0 3
12111: PUSH
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 1
12119: PPUSH
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 12
12129: ARRAY
12130: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12131: LD_VAR 0 3
12135: PPUSH
12136: CALL_OW 255
12140: PUSH
12141: LD_INT 1
12143: EQUAL
12144: IFFALSE 12155
// CenterNowOnUnits ( target ) ;
12146: LD_VAR 0 3
12150: PPUSH
12151: CALL_OW 87
// SetLives ( target , 0 ) ;
12155: LD_VAR 0 3
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 234
// end ;
12167: PPOPN 3
12169: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12170: LD_EXP 23
12174: NOT
12175: PUSH
12176: LD_EXP 31
12180: AND
12181: IFFALSE 12703
12183: GO 12185
12185: DISABLE
12186: LD_INT 0
12188: PPUSH
12189: PPUSH
12190: PPUSH
// begin uc_side := 7 ;
12191: LD_ADDR_OWVAR 20
12195: PUSH
12196: LD_INT 7
12198: ST_TO_ADDR
// uc_nation := 1 ;
12199: LD_ADDR_OWVAR 21
12203: PUSH
12204: LD_INT 1
12206: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12207: LD_ADDR_VAR 0 3
12211: PUSH
12212: LD_INT 125
12214: PUSH
12215: LD_INT 163
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 185
12224: PUSH
12225: LD_INT 168
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 111
12234: PUSH
12235: LD_INT 97
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: PPUSH
12247: CALL 106076 0 1
12251: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12252: LD_ADDR_EXP 88
12256: PUSH
12257: EMPTY
12258: ST_TO_ADDR
// for i = 1 to Difficulty do
12259: LD_ADDR_VAR 0 1
12263: PUSH
12264: DOUBLE
12265: LD_INT 1
12267: DEC
12268: ST_TO_ADDR
12269: LD_OWVAR 67
12273: PUSH
12274: FOR_TO
12275: IFFALSE 12433
// begin InitHc ;
12277: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12281: LD_INT 0
12283: PPUSH
12284: LD_INT 8
12286: PPUSH
12287: CALL_OW 381
// un := CreateHuman ;
12291: LD_ADDR_VAR 0 2
12295: PUSH
12296: CALL_OW 44
12300: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 258
12308: PPUSH
12309: LD_INT 267
12311: PPUSH
12312: LD_INT 4
12314: PPUSH
12315: LD_INT 0
12317: PPUSH
12318: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12322: LD_ADDR_EXP 88
12326: PUSH
12327: LD_EXP 88
12331: PUSH
12332: LD_VAR 0 2
12336: UNION
12337: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12338: LD_VAR 0 2
12342: PPUSH
12343: LD_VAR 0 3
12347: PUSH
12348: LD_VAR 0 1
12352: ARRAY
12353: PUSH
12354: LD_INT 1
12356: ARRAY
12357: PPUSH
12358: LD_VAR 0 3
12362: PUSH
12363: LD_VAR 0 1
12367: ARRAY
12368: PUSH
12369: LD_INT 2
12371: ARRAY
12372: PPUSH
12373: LD_INT 4
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12383: LD_VAR 0 2
12387: PPUSH
12388: LD_VAR 0 3
12392: PUSH
12393: LD_VAR 0 1
12397: ARRAY
12398: PUSH
12399: LD_INT 1
12401: ARRAY
12402: PPUSH
12403: LD_VAR 0 3
12407: PUSH
12408: LD_VAR 0 1
12412: ARRAY
12413: PUSH
12414: LD_INT 2
12416: ARRAY
12417: PPUSH
12418: CALL_OW 171
// AddComInvisible ( un ) ;
12422: LD_VAR 0 2
12426: PPUSH
12427: CALL_OW 212
// end ;
12431: GO 12274
12433: POP
12434: POP
// repeat wait ( 0 0$20 ) ;
12435: LD_INT 700
12437: PPUSH
12438: CALL_OW 67
// for i in allianceSpecialForce do
12442: LD_ADDR_VAR 0 1
12446: PUSH
12447: LD_EXP 88
12451: PUSH
12452: FOR_IN
12453: IFFALSE 12688
// begin if IsInvisible ( i ) then
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 571
12464: IFFALSE 12657
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12466: LD_ADDR_VAR 0 3
12470: PUSH
12471: LD_INT 22
12473: PUSH
12474: LD_INT 1
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: PUSH
12481: LD_INT 50
12483: PUSH
12484: EMPTY
12485: LIST
12486: PUSH
12487: LD_INT 56
12489: PUSH
12490: EMPTY
12491: LIST
12492: PUSH
12493: LD_INT 91
12495: PUSH
12496: LD_VAR 0 1
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 30
12506: PUSH
12507: LD_INT 35
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PUSH
12515: LD_OWVAR 67
12519: ARRAY
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 25
12531: PUSH
12532: LD_INT 1
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 3
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 4
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 5
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 8
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: ST_TO_ADDR
// if not tmp then
12610: LD_VAR 0 3
12614: NOT
12615: IFFALSE 12619
// continue ;
12617: GO 12452
// if Prob ( 30 * Difficulty ) then
12619: LD_INT 30
12621: PUSH
12622: LD_OWVAR 67
12626: MUL
12627: PPUSH
12628: CALL_OW 13
12632: IFFALSE 12657
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12634: LD_VAR 0 3
12638: PUSH
12639: LD_INT 1
12641: PPUSH
12642: LD_VAR 0 3
12646: PPUSH
12647: CALL_OW 12
12651: ARRAY
12652: PPUSH
12653: CALL 30114 0 1
// end ; if IsDead ( i ) then
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 301
12666: IFFALSE 12686
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12668: LD_ADDR_EXP 88
12672: PUSH
12673: LD_EXP 88
12677: PUSH
12678: LD_VAR 0 1
12682: DIFF
12683: ST_TO_ADDR
// continue ;
12684: GO 12452
// end ; end ;
12686: GO 12452
12688: POP
12689: POP
// until allianceDestroyed or not allianceSpecialForce ;
12690: LD_EXP 23
12694: PUSH
12695: LD_EXP 88
12699: NOT
12700: OR
12701: IFFALSE 12435
// end ;
12703: PPOPN 3
12705: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12706: LD_EXP 23
12710: NOT
12711: PUSH
12712: LD_EXP 31
12716: AND
12717: PUSH
12718: LD_INT 1
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL 58784 0 2
12728: NOT
12729: AND
12730: IFFALSE 13697
12732: GO 12734
12734: DISABLE
12735: LD_INT 0
12737: PPUSH
12738: PPUSH
12739: PPUSH
12740: PPUSH
// begin enable ;
12741: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 3
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: NOT
12771: IFFALSE 12775
// exit ;
12773: GO 13697
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12775: LD_ADDR_VAR 0 4
12779: PUSH
12780: LD_INT 22
12782: PUSH
12783: LD_INT 7
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 30
12792: PUSH
12793: LD_INT 34
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PPUSH
12804: CALL_OW 69
12808: ST_TO_ADDR
// if Prob ( 40 ) then
12809: LD_INT 40
12811: PPUSH
12812: CALL_OW 13
12816: IFFALSE 12943
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 5
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: LD_INT 2
12829: PUSH
12830: LD_INT 6
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 5
12841: PUSH
12842: LD_INT 3
12844: PUSH
12845: LD_INT 2
12847: PUSH
12848: LD_INT 6
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: LD_INT 6
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 45
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 24
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 3
12901: PUSH
12902: LD_INT 47
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 24
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 3
12919: PUSH
12920: LD_INT 45
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: PPUSH
12937: CALL 57366 0 2
// end else
12941: GO 13066
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 47
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 5
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 9
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 5
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: LD_INT 2
13008: PUSH
13009: LD_INT 9
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: PUSH
13018: LD_INT 24
13020: PUSH
13021: LD_INT 1
13023: PUSH
13024: LD_INT 3
13026: PUSH
13027: LD_INT 45
13029: PUSH
13030: EMPTY
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 24
13038: PUSH
13039: LD_INT 1
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: LD_INT 45
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL 57366 0 2
// end ; if Difficulty > 1 then
13066: LD_OWVAR 67
13070: PUSH
13071: LD_INT 1
13073: GREATER
13074: IFFALSE 13104
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 24
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 47
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: EMPTY
13098: LIST
13099: PPUSH
13100: CALL 57366 0 2
// repeat wait ( 0 0$1 ) ;
13104: LD_INT 35
13106: PPUSH
13107: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 1
13116: PPUSH
13117: CALL 58784 0 2
13121: PUSH
13122: LD_INT 6
13124: PUSH
13125: LD_INT 7
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_OWVAR 67
13140: ARRAY
13141: GREATEREQUAL
13142: IFFALSE 13104
// wait ( 0 0$40 ) ;
13144: LD_INT 1400
13146: PPUSH
13147: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13151: LD_ADDR_VAR 0 2
13155: PUSH
13156: LD_INT 1
13158: PPUSH
13159: LD_INT 1
13161: PPUSH
13162: CALL 58784 0 2
13166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13167: LD_ADDR_EXP 118
13171: PUSH
13172: LD_EXP 118
13176: PPUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_EXP 118
13184: PUSH
13185: LD_INT 1
13187: ARRAY
13188: PUSH
13189: LD_VAR 0 2
13193: DIFF
13194: PPUSH
13195: CALL_OW 1
13199: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13200: LD_ADDR_VAR 0 3
13204: PUSH
13205: LD_INT 0
13207: PPUSH
13208: LD_INT 1
13210: PPUSH
13211: CALL_OW 12
13215: ST_TO_ADDR
// if target then
13216: LD_VAR 0 3
13220: IFFALSE 13386
// begin for i in tmp do
13222: LD_ADDR_VAR 0 1
13226: PUSH
13227: LD_VAR 0 2
13231: PUSH
13232: FOR_IN
13233: IFFALSE 13258
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: LD_INT 179
13242: PPUSH
13243: LD_INT 209
13245: PPUSH
13246: LD_INT 8
13248: PPUSH
13249: LD_INT 1
13251: PPUSH
13252: CALL_OW 483
13256: GO 13232
13258: POP
13259: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13260: LD_ADDR_VAR 0 2
13264: PUSH
13265: LD_VAR 0 2
13269: PPUSH
13270: LD_INT 24
13272: PUSH
13273: LD_INT 250
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PPUSH
13280: CALL_OW 72
13284: ST_TO_ADDR
// for i in tmp do
13285: LD_ADDR_VAR 0 1
13289: PUSH
13290: LD_VAR 0 2
13294: PUSH
13295: FOR_IN
13296: IFFALSE 13336
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 179
13305: PPUSH
13306: LD_INT 209
13308: PPUSH
13309: CALL_OW 297
13313: PUSH
13314: LD_INT 9
13316: GREATER
13317: IFFALSE 13334
// ComMoveXY ( i , 179 , 209 ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_INT 179
13326: PPUSH
13327: LD_INT 209
13329: PPUSH
13330: CALL_OW 111
13334: GO 13295
13336: POP
13337: POP
// wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_INT 92
13352: PUSH
13353: LD_INT 179
13355: PUSH
13356: LD_INT 209
13358: PUSH
13359: LD_INT 9
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PPUSH
13368: CALL_OW 72
13372: PUSH
13373: LD_VAR 0 2
13377: PUSH
13378: LD_INT 1
13380: MINUS
13381: GREATEREQUAL
13382: IFFALSE 13260
// end else
13384: GO 13548
// begin for i in tmp do
13386: LD_ADDR_VAR 0 1
13390: PUSH
13391: LD_VAR 0 2
13395: PUSH
13396: FOR_IN
13397: IFFALSE 13422
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13399: LD_VAR 0 1
13403: PPUSH
13404: LD_INT 285
13406: PPUSH
13407: LD_INT 163
13409: PPUSH
13410: LD_INT 8
13412: PPUSH
13413: LD_INT 1
13415: PPUSH
13416: CALL_OW 483
13420: GO 13396
13422: POP
13423: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: LD_VAR 0 2
13433: PPUSH
13434: LD_INT 24
13436: PUSH
13437: LD_INT 250
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PPUSH
13444: CALL_OW 72
13448: ST_TO_ADDR
// for i in tmp do
13449: LD_ADDR_VAR 0 1
13453: PUSH
13454: LD_VAR 0 2
13458: PUSH
13459: FOR_IN
13460: IFFALSE 13500
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13462: LD_VAR 0 1
13466: PPUSH
13467: LD_INT 285
13469: PPUSH
13470: LD_INT 163
13472: PPUSH
13473: CALL_OW 297
13477: PUSH
13478: LD_INT 9
13480: GREATER
13481: IFFALSE 13498
// ComMoveXY ( i , 285 , 163 ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: LD_INT 285
13490: PPUSH
13491: LD_INT 163
13493: PPUSH
13494: CALL_OW 111
13498: GO 13459
13500: POP
13501: POP
// wait ( 0 0$1 ) ;
13502: LD_INT 35
13504: PPUSH
13505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13509: LD_VAR 0 2
13513: PPUSH
13514: LD_INT 92
13516: PUSH
13517: LD_INT 285
13519: PUSH
13520: LD_INT 163
13522: PUSH
13523: LD_INT 9
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 72
13536: PUSH
13537: LD_VAR 0 2
13541: PUSH
13542: LD_INT 1
13544: MINUS
13545: GREATEREQUAL
13546: IFFALSE 13424
// end ; repeat wait ( 0 0$1 ) ;
13548: LD_INT 35
13550: PPUSH
13551: CALL_OW 67
// for i in tmp do
13555: LD_ADDR_VAR 0 1
13559: PUSH
13560: LD_VAR 0 2
13564: PUSH
13565: FOR_IN
13566: IFFALSE 13688
// if GetLives ( i ) > 251 then
13568: LD_VAR 0 1
13572: PPUSH
13573: CALL_OW 256
13577: PUSH
13578: LD_INT 251
13580: GREATER
13581: IFFALSE 13670
// begin if GetWeapon ( i ) = ru_time_lapser then
13583: LD_VAR 0 1
13587: PPUSH
13588: CALL_OW 264
13592: PUSH
13593: LD_INT 49
13595: EQUAL
13596: IFFALSE 13634
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13598: LD_VAR 0 1
13602: PPUSH
13603: LD_INT 81
13605: PUSH
13606: LD_INT 7
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PPUSH
13618: LD_VAR 0 1
13622: PPUSH
13623: CALL_OW 74
13627: PPUSH
13628: CALL_OW 112
13632: GO 13668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13634: LD_VAR 0 1
13638: PPUSH
13639: LD_INT 81
13641: PUSH
13642: LD_INT 7
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: PPUSH
13654: LD_VAR 0 1
13658: PPUSH
13659: CALL_OW 74
13663: PPUSH
13664: CALL_OW 115
// end else
13668: GO 13686
// tmp := tmp diff i ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_VAR 0 2
13679: PUSH
13680: LD_VAR 0 1
13684: DIFF
13685: ST_TO_ADDR
13686: GO 13565
13688: POP
13689: POP
// until not tmp ;
13690: LD_VAR 0 2
13694: NOT
13695: IFFALSE 13548
// end ; end_of_file
13697: PPOPN 4
13699: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13700: LD_INT 0
13702: PPUSH
13703: PPUSH
13704: PPUSH
13705: PPUSH
// missionStage := 13 ;
13706: LD_ADDR_EXP 15
13710: PUSH
13711: LD_INT 13
13713: ST_TO_ADDR
// uc_side := 2 ;
13714: LD_ADDR_OWVAR 20
13718: PUSH
13719: LD_INT 2
13721: ST_TO_ADDR
// uc_nation := 2 ;
13722: LD_ADDR_OWVAR 21
13726: PUSH
13727: LD_INT 2
13729: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13730: LD_ADDR_EXP 89
13734: PUSH
13735: LD_STRING Omar
13737: PPUSH
13738: CALL_OW 25
13742: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13743: LD_EXP 89
13747: PPUSH
13748: LD_INT 4
13750: PPUSH
13751: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13755: LD_EXP 89
13759: PPUSH
13760: LD_INT 242
13762: PPUSH
13763: LD_INT 75
13765: PPUSH
13766: LD_INT 0
13768: PPUSH
13769: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13773: LD_ADDR_EXP 90
13777: PUSH
13778: LD_STRING Heike
13780: PPUSH
13781: CALL_OW 25
13785: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13786: LD_INT 14
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_INT 27
13797: PPUSH
13798: LD_INT 100
13800: PPUSH
13801: CALL 70239 0 5
// veh := CreateVehicle ;
13805: LD_ADDR_VAR 0 3
13809: PUSH
13810: CALL_OW 45
13814: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13815: LD_VAR 0 3
13819: PPUSH
13820: LD_INT 1
13822: PPUSH
13823: CALL_OW 242
// SetDir ( veh , 4 ) ;
13827: LD_VAR 0 3
13831: PPUSH
13832: LD_INT 4
13834: PPUSH
13835: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13839: LD_VAR 0 3
13843: PPUSH
13844: LD_INT 241
13846: PPUSH
13847: LD_INT 72
13849: PPUSH
13850: LD_INT 0
13852: PPUSH
13853: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13857: LD_EXP 90
13861: PPUSH
13862: LD_VAR 0 3
13866: PPUSH
13867: CALL_OW 52
// if KhatamStatus then
13871: LD_EXP 8
13875: IFFALSE 13926
// begin Khatam := NewCharacter ( Khatam ) ;
13877: LD_ADDR_EXP 91
13881: PUSH
13882: LD_STRING Khatam
13884: PPUSH
13885: CALL_OW 25
13889: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13890: LD_EXP 91
13894: PPUSH
13895: LD_INT 245
13897: PPUSH
13898: LD_INT 78
13900: PPUSH
13901: LD_INT 3
13903: PPUSH
13904: LD_INT 0
13906: PPUSH
13907: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13911: LD_EXP 91
13915: PPUSH
13916: LD_INT 4
13918: PPUSH
13919: LD_INT 10
13921: PPUSH
13922: CALL_OW 237
// end ; for i = 1 to Difficulty do
13926: LD_ADDR_VAR 0 2
13930: PUSH
13931: DOUBLE
13932: LD_INT 1
13934: DEC
13935: ST_TO_ADDR
13936: LD_OWVAR 67
13940: PUSH
13941: FOR_TO
13942: IFFALSE 14008
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13944: LD_INT 0
13946: PPUSH
13947: LD_INT 7
13949: PUSH
13950: LD_OWVAR 67
13954: PLUS
13955: PPUSH
13956: CALL_OW 384
// un := CreateHuman ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: CALL_OW 44
13969: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13970: LD_VAR 0 4
13974: PPUSH
13975: LD_INT 28
13977: PUSH
13978: LD_INT 29
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: LD_VAR 0 2
13989: PUSH
13990: LD_INT 2
13992: MOD
13993: PUSH
13994: LD_INT 1
13996: PLUS
13997: ARRAY
13998: PPUSH
13999: LD_INT 0
14001: PPUSH
14002: CALL_OW 49
// end ;
14006: GO 13941
14008: POP
14009: POP
// for i = 1 to 6 do
14010: LD_ADDR_VAR 0 2
14014: PUSH
14015: DOUBLE
14016: LD_INT 1
14018: DEC
14019: ST_TO_ADDR
14020: LD_INT 6
14022: PUSH
14023: FOR_TO
14024: IFFALSE 14069
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14026: LD_INT 0
14028: PPUSH
14029: LD_INT 7
14031: PUSH
14032: LD_OWVAR 67
14036: PLUS
14037: PPUSH
14038: CALL_OW 381
// un := CreateHuman ;
14042: LD_ADDR_VAR 0 4
14046: PUSH
14047: CALL_OW 44
14051: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14052: LD_VAR 0 4
14056: PPUSH
14057: LD_INT 28
14059: PPUSH
14060: LD_INT 0
14062: PPUSH
14063: CALL_OW 49
// end ;
14067: GO 14023
14069: POP
14070: POP
// for i = 1 to 3 do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_INT 3
14083: PUSH
14084: FOR_TO
14085: IFFALSE 14133
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14087: LD_INT 0
14089: PPUSH
14090: LD_INT 8
14092: PPUSH
14093: LD_INT 7
14095: PUSH
14096: LD_OWVAR 67
14100: PLUS
14101: PPUSH
14102: CALL_OW 380
// un := CreateHuman ;
14106: LD_ADDR_VAR 0 4
14110: PUSH
14111: CALL_OW 44
14115: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14116: LD_VAR 0 4
14120: PPUSH
14121: LD_INT 28
14123: PPUSH
14124: LD_INT 0
14126: PPUSH
14127: CALL_OW 49
// end ;
14131: GO 14084
14133: POP
14134: POP
// for i = 1 to 3 do
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: DOUBLE
14141: LD_INT 1
14143: DEC
14144: ST_TO_ADDR
14145: LD_INT 3
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14239
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14151: LD_INT 14
14153: PPUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 1
14159: PPUSH
14160: LD_INT 28
14162: PPUSH
14163: LD_INT 80
14165: PPUSH
14166: CALL 70239 0 5
// veh := CreateVehicle ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: CALL_OW 45
14179: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14180: LD_VAR 0 3
14184: PPUSH
14185: LD_INT 3
14187: PPUSH
14188: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14192: LD_VAR 0 3
14196: PPUSH
14197: LD_INT 29
14199: PPUSH
14200: LD_INT 0
14202: PPUSH
14203: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14207: LD_INT 0
14209: PPUSH
14210: LD_INT 7
14212: PUSH
14213: LD_OWVAR 67
14217: PLUS
14218: PPUSH
14219: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14223: CALL_OW 44
14227: PPUSH
14228: LD_VAR 0 3
14232: PPUSH
14233: CALL_OW 52
// end ;
14237: GO 14148
14239: POP
14240: POP
// for i = 1 to 5 + Difficulty do
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: DOUBLE
14247: LD_INT 1
14249: DEC
14250: ST_TO_ADDR
14251: LD_INT 5
14253: PUSH
14254: LD_OWVAR 67
14258: PLUS
14259: PUSH
14260: FOR_TO
14261: IFFALSE 14388
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14263: LD_INT 14
14265: PPUSH
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: CALL_OW 12
14276: PPUSH
14277: LD_INT 1
14279: PPUSH
14280: LD_INT 28
14282: PUSH
14283: LD_INT 26
14285: PUSH
14286: LD_INT 27
14288: PUSH
14289: LD_INT 25
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: LD_VAR 0 2
14302: PUSH
14303: LD_INT 4
14305: MOD
14306: PUSH
14307: LD_INT 1
14309: PLUS
14310: ARRAY
14311: PPUSH
14312: LD_INT 80
14314: PPUSH
14315: CALL 70239 0 5
// veh := CreateVehicle ;
14319: LD_ADDR_VAR 0 3
14323: PUSH
14324: CALL_OW 45
14328: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14329: LD_VAR 0 3
14333: PPUSH
14334: LD_INT 4
14336: PPUSH
14337: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14341: LD_VAR 0 3
14345: PPUSH
14346: LD_INT 28
14348: PPUSH
14349: LD_INT 0
14351: PPUSH
14352: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14356: LD_INT 0
14358: PPUSH
14359: LD_INT 7
14361: PUSH
14362: LD_OWVAR 67
14366: PLUS
14367: PPUSH
14368: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14372: CALL_OW 44
14376: PPUSH
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 52
// end ;
14386: GO 14260
14388: POP
14389: POP
// for i = 1 to 3 do
14390: LD_ADDR_VAR 0 2
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_INT 3
14402: PUSH
14403: FOR_TO
14404: IFFALSE 14464
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14406: LD_INT 14
14408: PPUSH
14409: LD_INT 3
14411: PPUSH
14412: LD_INT 5
14414: PPUSH
14415: LD_INT 29
14417: PPUSH
14418: LD_INT 80
14420: PPUSH
14421: CALL 70239 0 5
// veh := CreateVehicle ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: CALL_OW 45
14434: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14435: LD_VAR 0 3
14439: PPUSH
14440: LD_INT 4
14442: PPUSH
14443: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14447: LD_VAR 0 3
14451: PPUSH
14452: LD_INT 28
14454: PPUSH
14455: LD_INT 0
14457: PPUSH
14458: CALL_OW 49
// end ;
14462: GO 14403
14464: POP
14465: POP
// end ;
14466: LD_VAR 0 1
14470: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14471: LD_INT 22
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PPUSH
14481: CALL_OW 69
14485: IFFALSE 14785
14487: GO 14489
14489: DISABLE
14490: LD_INT 0
14492: PPUSH
14493: PPUSH
14494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14495: LD_ADDR_VAR 0 3
14499: PUSH
14500: LD_INT 22
14502: PUSH
14503: LD_INT 2
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: LD_INT 25
14512: PUSH
14513: LD_INT 4
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: PPUSH
14524: CALL_OW 69
14528: PUSH
14529: LD_EXP 91
14533: DIFF
14534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 22
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PPUSH
14550: CALL_OW 69
14554: PUSH
14555: LD_EXP 91
14559: PUSH
14560: LD_VAR 0 3
14564: UNION
14565: DIFF
14566: ST_TO_ADDR
// if Khatam then
14567: LD_EXP 91
14571: IFFALSE 14588
// ComMoveXY ( Khatam , 211 , 92 ) ;
14573: LD_EXP 91
14577: PPUSH
14578: LD_INT 211
14580: PPUSH
14581: LD_INT 92
14583: PPUSH
14584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14588: LD_INT 197
14590: PPUSH
14591: LD_INT 80
14593: PPUSH
14594: LD_INT 2
14596: PPUSH
14597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14601: LD_INT 213
14603: PPUSH
14604: LD_INT 90
14606: PPUSH
14607: LD_INT 2
14609: PPUSH
14610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14614: LD_INT 215
14616: PPUSH
14617: LD_INT 129
14619: PPUSH
14620: LD_INT 2
14622: PPUSH
14623: CALL_OW 441
// if sci then
14627: LD_VAR 0 3
14631: IFFALSE 14652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14633: LD_VAR 0 3
14637: PUSH
14638: LD_INT 1
14640: ARRAY
14641: PPUSH
14642: LD_INT 197
14644: PPUSH
14645: LD_INT 80
14647: PPUSH
14648: CALL_OW 158
// if sci > 1 then
14652: LD_VAR 0 3
14656: PUSH
14657: LD_INT 1
14659: GREATER
14660: IFFALSE 14681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 2
14669: ARRAY
14670: PPUSH
14671: LD_INT 213
14673: PPUSH
14674: LD_INT 90
14676: PPUSH
14677: CALL_OW 158
// if sci > 2 then
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 2
14688: GREATER
14689: IFFALSE 14710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 3
14698: ARRAY
14699: PPUSH
14700: LD_INT 215
14702: PPUSH
14703: LD_INT 129
14705: PPUSH
14706: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14710: LD_INT 35
14712: PPUSH
14713: CALL_OW 67
// for i in tmp do
14717: LD_ADDR_VAR 0 1
14721: PUSH
14722: LD_VAR 0 2
14726: PUSH
14727: FOR_IN
14728: IFFALSE 14766
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_INT 81
14737: PUSH
14738: LD_INT 2
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PPUSH
14745: CALL_OW 69
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: PPUSH
14760: CALL_OW 115
14764: GO 14727
14766: POP
14767: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14768: LD_INT 22
14770: PUSH
14771: LD_INT 2
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: PPUSH
14778: CALL_OW 69
14782: NOT
14783: IFFALSE 14710
// end ; end_of_file
14785: PPOPN 3
14787: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14788: LD_INT 0
14790: PPUSH
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
// Video ( true ) ;
14799: LD_INT 1
14801: PPUSH
14802: CALL 105956 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14806: LD_ADDR_VAR 0 5
14810: PUSH
14811: LD_INT 7
14813: PPUSH
14814: LD_INT 0
14816: PPUSH
14817: CALL_OW 517
14821: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14822: LD_ADDR_VAR 0 2
14826: PUSH
14827: DOUBLE
14828: LD_INT 1
14830: DEC
14831: ST_TO_ADDR
14832: LD_VAR 0 5
14836: PUSH
14837: LD_INT 1
14839: ARRAY
14840: PUSH
14841: FOR_TO
14842: IFFALSE 14887
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14844: LD_VAR 0 5
14848: PUSH
14849: LD_INT 1
14851: ARRAY
14852: PUSH
14853: LD_VAR 0 2
14857: ARRAY
14858: PPUSH
14859: LD_VAR 0 5
14863: PUSH
14864: LD_INT 2
14866: ARRAY
14867: PUSH
14868: LD_VAR 0 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 1
14876: PPUSH
14877: LD_INT 15
14879: NEG
14880: PPUSH
14881: CALL 105870 0 4
14885: GO 14841
14887: POP
14888: POP
// CenterNowOnUnits ( Powell ) ;
14889: LD_EXP 55
14893: PPUSH
14894: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14898: LD_ADDR_VAR 0 5
14902: PUSH
14903: LD_EXP 53
14907: PUSH
14908: EMPTY
14909: LIST
14910: ST_TO_ADDR
// if GirlNewVeh then
14911: LD_EXP 54
14915: IFFALSE 14933
// tmp := tmp ^ GirlNewVeh ;
14917: LD_ADDR_VAR 0 5
14921: PUSH
14922: LD_VAR 0 5
14926: PUSH
14927: LD_EXP 54
14931: ADD
14932: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14933: LD_VAR 0 5
14937: PPUSH
14938: LD_INT 60
14940: PPUSH
14941: LD_INT 109
14943: PPUSH
14944: CALL_OW 111
// if KappaStatus then
14948: LD_EXP 2
14952: IFFALSE 15004
// begin Say ( JMM , D1nT-JMM-1 ) ;
14954: LD_EXP 36
14958: PPUSH
14959: LD_STRING D1nT-JMM-1
14961: PPUSH
14962: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14966: LD_EXP 55
14970: PPUSH
14971: LD_STRING D1T-Pow-1
14973: PPUSH
14974: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14978: LD_EXP 36
14982: PPUSH
14983: LD_STRING D1T-JMM-2
14985: PPUSH
14986: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14990: LD_EXP 55
14994: PPUSH
14995: LD_STRING D1T-Pow-2
14997: PPUSH
14998: CALL_OW 88
// end else
15002: GO 15210
// if JMMGirlStatus then
15004: LD_EXP 6
15008: IFFALSE 15153
// begin Say ( JMM , D1T-JMM-1 ) ;
15010: LD_EXP 36
15014: PPUSH
15015: LD_STRING D1T-JMM-1
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15022: LD_EXP 55
15026: PPUSH
15027: LD_STRING D1T-Pow-1
15029: PPUSH
15030: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15034: LD_EXP 36
15038: PPUSH
15039: LD_STRING D1T-JMM-3
15041: PPUSH
15042: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15046: LD_EXP 55
15050: PPUSH
15051: LD_STRING D1T-Pow-3
15053: PPUSH
15054: CALL_OW 88
// if JMMGirl then
15058: LD_EXP 7
15062: IFFALSE 15151
// begin case JMMGirl of 1 :
15064: LD_EXP 7
15068: PUSH
15069: LD_INT 1
15071: DOUBLE
15072: EQUAL
15073: IFTRUE 15077
15075: GO 15092
15077: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15078: LD_EXP 37
15082: PPUSH
15083: LD_STRING D1T-Joan-3
15085: PPUSH
15086: CALL_OW 88
15090: GO 15139
15092: LD_INT 2
15094: DOUBLE
15095: EQUAL
15096: IFTRUE 15100
15098: GO 15115
15100: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15101: LD_EXP 39
15105: PPUSH
15106: LD_STRING D1T-Lisa-3
15108: PPUSH
15109: CALL_OW 88
15113: GO 15139
15115: LD_INT 3
15117: DOUBLE
15118: EQUAL
15119: IFTRUE 15123
15121: GO 15138
15123: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15124: LD_EXP 51
15128: PPUSH
15129: LD_STRING D1T-Con-3
15131: PPUSH
15132: CALL_OW 88
15136: GO 15139
15138: POP
// Say ( Powell , D1T-Pow-4 ) ;
15139: LD_EXP 55
15143: PPUSH
15144: LD_STRING D1T-Pow-4
15146: PPUSH
15147: CALL_OW 88
// end ; end else
15151: GO 15210
// if not FastEnd then
15153: LD_EXP 11
15157: NOT
15158: IFFALSE 15186
// begin Say ( JMM , D1T-JMM-4 ) ;
15160: LD_EXP 36
15164: PPUSH
15165: LD_STRING D1T-JMM-4
15167: PPUSH
15168: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15172: LD_EXP 55
15176: PPUSH
15177: LD_STRING D1T-Pow-5
15179: PPUSH
15180: CALL_OW 88
// end else
15184: GO 15210
// begin Say ( JMM , D1nT-JMM-1 ) ;
15186: LD_EXP 36
15190: PPUSH
15191: LD_STRING D1nT-JMM-1
15193: PPUSH
15194: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15198: LD_EXP 55
15202: PPUSH
15203: LD_STRING D1nT-Pow-1
15205: PPUSH
15206: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15210: LD_INT 35
15212: PPUSH
15213: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15217: LD_EXP 53
15221: PPUSH
15222: CALL_OW 314
15226: NOT
15227: IFFALSE 15210
// ComExitVehicle ( JMM ) ;
15229: LD_EXP 36
15233: PPUSH
15234: CALL_OW 121
// wait ( 3 ) ;
15238: LD_INT 3
15240: PPUSH
15241: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15245: LD_EXP 36
15249: PPUSH
15250: LD_INT 60
15252: PPUSH
15253: LD_INT 94
15255: PPUSH
15256: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15260: LD_EXP 36
15264: PPUSH
15265: LD_EXP 55
15269: PPUSH
15270: CALL_OW 179
// if Joan then
15274: LD_EXP 37
15278: IFFALSE 15332
// begin ComExitVehicle ( Joan ) ;
15280: LD_EXP 37
15284: PPUSH
15285: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15289: LD_EXP 37
15293: PPUSH
15294: LD_INT 35
15296: PPUSH
15297: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15301: LD_EXP 37
15305: PPUSH
15306: LD_INT 65
15308: PPUSH
15309: LD_INT 104
15311: PPUSH
15312: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15316: LD_EXP 37
15320: PPUSH
15321: LD_EXP 36
15325: PPUSH
15326: CALL_OW 179
// end else
15330: GO 15466
// if Lisa and JMMGirl = 2 then
15332: LD_EXP 39
15336: PUSH
15337: LD_EXP 7
15341: PUSH
15342: LD_INT 2
15344: EQUAL
15345: AND
15346: IFFALSE 15400
// begin ComExitVehicle ( Lisa ) ;
15348: LD_EXP 39
15352: PPUSH
15353: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15357: LD_EXP 39
15361: PPUSH
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_INT 65
15376: PPUSH
15377: LD_INT 104
15379: PPUSH
15380: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15384: LD_EXP 39
15388: PPUSH
15389: LD_EXP 36
15393: PPUSH
15394: CALL_OW 179
// end else
15398: GO 15466
// if Connie and JMMGirl = 3 then
15400: LD_EXP 51
15404: PUSH
15405: LD_EXP 7
15409: PUSH
15410: LD_INT 3
15412: EQUAL
15413: AND
15414: IFFALSE 15466
// begin ComExitVehicle ( Connie ) ;
15416: LD_EXP 51
15420: PPUSH
15421: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15425: LD_EXP 51
15429: PPUSH
15430: LD_INT 35
15432: PPUSH
15433: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15437: LD_EXP 51
15441: PPUSH
15442: LD_INT 65
15444: PPUSH
15445: LD_INT 104
15447: PPUSH
15448: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15452: LD_EXP 51
15456: PPUSH
15457: LD_EXP 36
15461: PPUSH
15462: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15473: LD_EXP 36
15477: PPUSH
15478: LD_EXP 55
15482: PPUSH
15483: CALL_OW 296
15487: PUSH
15488: LD_INT 6
15490: LESS
15491: IFFALSE 15466
// wait ( 0 0$0.5 ) ;
15493: LD_INT 18
15495: PPUSH
15496: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15500: LD_EXP 36
15504: PPUSH
15505: LD_STRING D1-JMM-1
15507: PPUSH
15508: CALL_OW 88
// async ;
15512: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15513: LD_EXP 55
15517: PPUSH
15518: LD_STRING D1-Pow-1
15520: PPUSH
15521: CALL_OW 88
// if not dialogue_skipped then
15525: LD_OWVAR 59
15529: NOT
15530: IFFALSE 15539
// wait ( 0 0$2 ) ;
15532: LD_INT 70
15534: PPUSH
15535: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15539: LD_INT 170
15541: PPUSH
15542: LD_INT 99
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 6
15550: NEG
15551: PPUSH
15552: CALL 105870 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15556: LD_INT 174
15558: PPUSH
15559: LD_INT 115
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 6
15567: NEG
15568: PPUSH
15569: CALL 105870 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15573: LD_INT 169
15575: PPUSH
15576: LD_INT 71
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 6
15584: NEG
15585: PPUSH
15586: CALL 105870 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 170 , 99 ) ;
15597: LD_INT 170
15599: PPUSH
15600: LD_INT 99
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15607: LD_INT 80
15609: PPUSH
15610: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15614: LD_INT 75
15616: PPUSH
15617: LD_INT 53
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: LD_INT 9
15625: NEG
15626: PPUSH
15627: CALL 105870 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15631: LD_INT 54
15633: PPUSH
15634: LD_INT 42
15636: PPUSH
15637: LD_INT 1
15639: PPUSH
15640: LD_INT 9
15642: NEG
15643: PPUSH
15644: CALL 105870 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15648: LD_INT 62
15650: PPUSH
15651: LD_INT 51
15653: PPUSH
15654: LD_INT 1
15656: PPUSH
15657: LD_INT 9
15659: NEG
15660: PPUSH
15661: CALL 105870 0 4
// if not dialogue_skipped then
15665: LD_OWVAR 59
15669: NOT
15670: IFFALSE 15689
// begin CenterOnXY ( 75 , 53 ) ;
15672: LD_INT 75
15674: PPUSH
15675: LD_INT 53
15677: PPUSH
15678: CALL_OW 84
// wait ( 0 0$4 ) ;
15682: LD_INT 140
15684: PPUSH
15685: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15689: LD_EXP 55
15693: PPUSH
15694: CALL_OW 87
// if not dialogue_skipped then
15698: LD_OWVAR 59
15702: NOT
15703: IFFALSE 15712
// wait ( 0 0$2 ) ;
15705: LD_INT 70
15707: PPUSH
15708: CALL_OW 67
// sync ;
15712: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15713: LD_EXP 36
15717: PPUSH
15718: LD_STRING D1-JMM-2
15720: PPUSH
15721: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15725: LD_EXP 55
15729: PPUSH
15730: LD_STRING D1-Pow-2
15732: PPUSH
15733: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15737: LD_EXP 36
15741: PPUSH
15742: LD_STRING D1-JMM-3
15744: PPUSH
15745: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15749: LD_EXP 55
15753: PPUSH
15754: LD_STRING D1-Pow-3
15756: PPUSH
15757: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15761: LD_EXP 36
15765: PPUSH
15766: LD_STRING D1-JMM-4
15768: PPUSH
15769: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15773: LD_EXP 55
15777: PPUSH
15778: LD_STRING D1-Pow-4
15780: PPUSH
15781: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15785: LD_EXP 36
15789: PPUSH
15790: LD_STRING D1-JMM-5
15792: PPUSH
15793: CALL_OW 88
// async ;
15797: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15798: LD_EXP 55
15802: PPUSH
15803: LD_STRING D1-Pow-5
15805: PPUSH
15806: CALL_OW 88
// if not dialogue_skipped then
15810: LD_OWVAR 59
15814: NOT
15815: IFFALSE 15824
// wait ( 0 0$3.6 ) ;
15817: LD_INT 126
15819: PPUSH
15820: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15824: LD_INT 134
15826: PPUSH
15827: LD_INT 210
15829: PPUSH
15830: LD_INT 1
15832: PPUSH
15833: LD_INT 11
15835: NEG
15836: PPUSH
15837: CALL 105870 0 4
// if not dialogue_skipped then
15841: LD_OWVAR 59
15845: NOT
15846: IFFALSE 15865
// begin CenterOnXY ( 134 , 210 ) ;
15848: LD_INT 134
15850: PPUSH
15851: LD_INT 210
15853: PPUSH
15854: CALL_OW 84
// wait ( 0 0$2 ) ;
15858: LD_INT 70
15860: PPUSH
15861: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15865: LD_INT 101
15867: PPUSH
15868: LD_INT 159
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: LD_INT 10
15876: NEG
15877: PPUSH
15878: CALL 105870 0 4
// if not dialogue_skipped then
15882: LD_OWVAR 59
15886: NOT
15887: IFFALSE 15906
// begin CenterOnXY ( 101 , 159 ) ;
15889: LD_INT 101
15891: PPUSH
15892: LD_INT 159
15894: PPUSH
15895: CALL_OW 84
// wait ( 0 0$2 ) ;
15899: LD_INT 70
15901: PPUSH
15902: CALL_OW 67
// end ; sync ;
15906: SYNC
// CenterNowOnUnits ( Powell ) ;
15907: LD_EXP 55
15911: PPUSH
15912: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 3
15929: PUSH
15930: LD_INT 4
15932: PUSH
15933: LD_INT 5
15935: PUSH
15936: LD_INT 6
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: LIST
15946: ST_TO_ADDR
// if not dialogue_skipped then
15947: LD_OWVAR 59
15951: NOT
15952: IFFALSE 16121
// begin game_speed := 4 ;
15954: LD_ADDR_OWVAR 65
15958: PUSH
15959: LD_INT 4
15961: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15962: LD_INT 210
15964: PPUSH
15965: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15969: LD_ADDR_VAR 0 7
15973: PUSH
15974: LD_STRING Q1
15976: PPUSH
15977: LD_VAR 0 6
15981: PPUSH
15982: CALL_OW 98
15986: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15987: LD_ADDR_VAR 0 7
15991: PUSH
15992: LD_STRING Q1
15994: PPUSH
15995: LD_VAR 0 6
15999: PPUSH
16000: CALL_OW 98
16004: ST_TO_ADDR
// options = options diff dec ;
16005: LD_ADDR_VAR 0 6
16009: PUSH
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 7
16019: DIFF
16020: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16021: LD_VAR 0 7
16025: PPUSH
16026: LD_VAR 0 6
16030: PPUSH
16031: CALL 17424 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16035: LD_VAR 0 7
16039: PUSH
16040: LD_INT 5
16042: PUSH
16043: LD_INT 6
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: IN
16050: PUSH
16051: LD_VAR 0 6
16055: PUSH
16056: LD_INT 2
16058: EQUAL
16059: OR
16060: IFFALSE 15987
// if not ( dec in [ 5 , 6 ] ) then
16062: LD_VAR 0 7
16066: PUSH
16067: LD_INT 5
16069: PUSH
16070: LD_INT 6
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: IN
16077: NOT
16078: IFFALSE 16121
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16080: LD_ADDR_VAR 0 7
16084: PUSH
16085: LD_STRING Q1a
16087: PPUSH
16088: LD_INT 1
16090: PUSH
16091: LD_INT 2
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PPUSH
16098: CALL_OW 98
16102: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16103: LD_VAR 0 7
16107: PUSH
16108: LD_INT 4
16110: PLUS
16111: PPUSH
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL 17424 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16121: LD_INT 81
16123: PPUSH
16124: LD_INT 127
16126: PPUSH
16127: CALL_OW 84
// amount := 5 ;
16131: LD_ADDR_VAR 0 8
16135: PUSH
16136: LD_INT 5
16138: ST_TO_ADDR
// macmilan_squad := [ ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: EMPTY
16145: ST_TO_ADDR
// if vip < amount then
16146: LD_EXP 56
16150: PUSH
16151: LD_VAR 0 8
16155: LESS
16156: IFFALSE 16200
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16158: LD_ADDR_VAR 0 5
16162: PUSH
16163: LD_EXP 56
16167: PUSH
16168: LD_INT 22
16170: PUSH
16171: LD_INT 4
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 21
16180: PUSH
16181: LD_INT 1
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 69
16196: UNION
16197: ST_TO_ADDR
16198: GO 16210
// tmp := vip ;
16200: LD_ADDR_VAR 0 5
16204: PUSH
16205: LD_EXP 56
16209: ST_TO_ADDR
// tmp := tmp diff Powell ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_VAR 0 5
16219: PUSH
16220: LD_EXP 55
16224: DIFF
16225: ST_TO_ADDR
// if tmp < amount then
16226: LD_VAR 0 5
16230: PUSH
16231: LD_VAR 0 8
16235: LESS
16236: IFFALSE 16248
// amount := tmp ;
16238: LD_ADDR_VAR 0 8
16242: PUSH
16243: LD_VAR 0 5
16247: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16248: LD_VAR 0 5
16252: PUSH
16253: LD_INT 1
16255: ARRAY
16256: PPUSH
16257: CALL_OW 257
16261: PUSH
16262: LD_INT 2
16264: NONEQUAL
16265: IFFALSE 16327
// begin if IsInUnit ( tmp [ 1 ] ) then
16267: LD_VAR 0 5
16271: PUSH
16272: LD_INT 1
16274: ARRAY
16275: PPUSH
16276: CALL_OW 310
16280: IFFALSE 16295
// ComExitBuilding ( tmp [ 1 ] ) ;
16282: LD_VAR 0 5
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: PPUSH
16291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16295: LD_VAR 0 5
16299: PUSH
16300: LD_INT 1
16302: ARRAY
16303: PPUSH
16304: LD_INT 387
16306: PPUSH
16307: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16311: LD_VAR 0 5
16315: PUSH
16316: LD_INT 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 2
16322: PPUSH
16323: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16327: LD_EXP 36
16331: PPUSH
16332: LD_INT 82
16334: PPUSH
16335: LD_INT 129
16337: PPUSH
16338: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16342: LD_EXP 36
16346: PPUSH
16347: LD_EXP 55
16351: PPUSH
16352: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16356: LD_INT 22
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PPUSH
16366: CALL_OW 69
16370: PUSH
16371: LD_EXP 36
16375: DIFF
16376: PPUSH
16377: LD_INT 84
16379: PPUSH
16380: LD_INT 128
16382: PPUSH
16383: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 69
16401: PUSH
16402: LD_EXP 36
16406: DIFF
16407: PPUSH
16408: LD_EXP 36
16412: PPUSH
16413: CALL_OW 179
// for i = 1 to amount do
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: DOUBLE
16423: LD_INT 1
16425: DEC
16426: ST_TO_ADDR
16427: LD_VAR 0 8
16431: PUSH
16432: FOR_TO
16433: IFFALSE 16601
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16435: LD_ADDR_VAR 0 9
16439: PUSH
16440: LD_VAR 0 9
16444: PUSH
16445: LD_VAR 0 5
16449: PUSH
16450: LD_VAR 0 2
16454: ARRAY
16455: ADD
16456: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16457: LD_VAR 0 5
16461: PUSH
16462: LD_VAR 0 2
16466: ARRAY
16467: PPUSH
16468: CALL_OW 310
16472: IFFALSE 16489
// AddComExitBuilding ( tmp [ i ] ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_VAR 0 2
16483: ARRAY
16484: PPUSH
16485: CALL_OW 182
// if i = 2 and JMMNewVeh then
16489: LD_VAR 0 2
16493: PUSH
16494: LD_INT 2
16496: EQUAL
16497: PUSH
16498: LD_EXP 53
16502: AND
16503: IFFALSE 16561
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16505: LD_VAR 0 5
16509: PUSH
16510: LD_VAR 0 2
16514: ARRAY
16515: PPUSH
16516: LD_EXP 53
16520: PPUSH
16521: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16525: LD_VAR 0 5
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: LD_INT 86
16538: PPUSH
16539: LD_INT 133
16541: PPUSH
16542: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16546: LD_VAR 0 5
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 2
16570: ARRAY
16571: PPUSH
16572: LD_INT 8
16574: PPUSH
16575: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16579: LD_VAR 0 5
16583: PUSH
16584: LD_VAR 0 2
16588: ARRAY
16589: PPUSH
16590: LD_EXP 36
16594: PPUSH
16595: CALL_OW 179
// end ;
16599: GO 16432
16601: POP
16602: POP
// if GirlNewVeh then
16603: LD_EXP 54
16607: IFFALSE 16621
// SetSide ( GirlNewVeh , 4 ) ;
16609: LD_EXP 54
16613: PPUSH
16614: LD_INT 4
16616: PPUSH
16617: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16621: LD_INT 35
16623: PPUSH
16624: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16628: LD_VAR 0 9
16632: PPUSH
16633: LD_INT 95
16635: PUSH
16636: LD_INT 9
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 72
16647: PUSH
16648: LD_INT 0
16650: EQUAL
16651: PUSH
16652: LD_EXP 36
16656: PPUSH
16657: LD_INT 9
16659: PPUSH
16660: CALL_OW 308
16664: NOT
16665: AND
16666: IFFALSE 16621
// wait ( 0 0$2 ) ;
16668: LD_INT 70
16670: PPUSH
16671: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16675: LD_VAR 0 9
16679: PPUSH
16680: LD_INT 1
16682: PPUSH
16683: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16687: LD_INT 21
16689: PUSH
16690: LD_INT 2
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 92
16699: PUSH
16700: LD_INT 83
16702: PUSH
16703: LD_INT 130
16705: PUSH
16706: LD_INT 10
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PPUSH
16719: CALL_OW 69
16723: PPUSH
16724: LD_INT 1
16726: PPUSH
16727: CALL_OW 235
// Video ( false ) ;
16731: LD_INT 0
16733: PPUSH
16734: CALL 105956 0 1
// ChangeMissionObjectives ( M1 ) ;
16738: LD_STRING M1
16740: PPUSH
16741: CALL_OW 337
// SaveForQuickRestart ;
16745: CALL_OW 22
// missionStart := true ;
16749: LD_ADDR_EXP 13
16753: PUSH
16754: LD_INT 1
16756: ST_TO_ADDR
// missionStage := 2 ;
16757: LD_ADDR_EXP 15
16761: PUSH
16762: LD_INT 2
16764: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16765: LD_INT 105
16767: PPUSH
16768: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16772: LD_ADDR_VAR 0 5
16776: PUSH
16777: LD_INT 22
16779: PUSH
16780: LD_INT 4
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: PUSH
16806: LD_EXP 55
16810: DIFF
16811: ST_TO_ADDR
// if not tmp then
16812: LD_VAR 0 5
16816: NOT
16817: IFFALSE 16832
// tmp := [ Powell ] ;
16819: LD_ADDR_VAR 0 5
16823: PUSH
16824: LD_EXP 55
16828: PUSH
16829: EMPTY
16830: LIST
16831: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16832: LD_ADDR_EXP 99
16836: PUSH
16837: LD_EXP 99
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 4
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 23
16857: PUSH
16858: LD_INT 1
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 3
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 2
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: LIST
16886: PPUSH
16887: CALL_OW 69
16891: PUSH
16892: LD_EXP 55
16896: DIFF
16897: PPUSH
16898: CALL_OW 1
16902: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16903: LD_ADDR_VAR 0 4
16907: PUSH
16908: LD_INT 22
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 34
16920: PUSH
16921: LD_INT 12
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16941: LD_VAR 0 5
16945: PUSH
16946: LD_INT 1
16948: ARRAY
16949: PPUSH
16950: CALL_OW 310
16954: IFFALSE 16969
// ComExitBuilding ( tmp [ 1 ] ) ;
16956: LD_VAR 0 5
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16969: LD_VAR 0 5
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PPUSH
16983: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16987: LD_VAR 0 5
16991: PUSH
16992: LD_INT 1
16994: ARRAY
16995: PPUSH
16996: LD_INT 80
16998: PPUSH
16999: LD_INT 136
17001: PPUSH
17002: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17006: LD_VAR 0 5
17010: PUSH
17011: LD_INT 1
17013: ARRAY
17014: PPUSH
17015: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17019: LD_VAR 0 5
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PPUSH
17028: LD_INT 59
17030: PPUSH
17031: LD_INT 112
17033: PPUSH
17034: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17038: LD_VAR 0 5
17042: PUSH
17043: LD_INT 1
17045: ARRAY
17046: PPUSH
17047: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17051: LD_EXP 39
17055: PUSH
17056: LD_EXP 56
17060: IN
17061: PUSH
17062: LD_EXP 39
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 1
17074: EQUAL
17075: AND
17076: IFFALSE 17092
// Say ( Lisa , D3nW-Lisa-1 ) else
17078: LD_EXP 39
17082: PPUSH
17083: LD_STRING D3nW-Lisa-1
17085: PPUSH
17086: CALL_OW 88
17090: GO 17336
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17092: LD_EXP 42
17096: PUSH
17097: LD_EXP 56
17101: IN
17102: PUSH
17103: LD_EXP 42
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17133
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17119: LD_EXP 42
17123: PPUSH
17124: LD_STRING D3nW-Cyrus-1
17126: PPUSH
17127: CALL_OW 88
17131: GO 17336
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17133: LD_EXP 41
17137: PUSH
17138: LD_EXP 56
17142: IN
17143: PUSH
17144: LD_EXP 41
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 1
17156: EQUAL
17157: AND
17158: IFFALSE 17174
// Say ( Bobby , D3nW-Bobby-1 ) else
17160: LD_EXP 41
17164: PPUSH
17165: LD_STRING D3nW-Bobby-1
17167: PPUSH
17168: CALL_OW 88
17172: GO 17336
// if Gary in vip and GetSide ( Gary ) = 1 then
17174: LD_EXP 48
17178: PUSH
17179: LD_EXP 56
17183: IN
17184: PUSH
17185: LD_EXP 48
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: AND
17199: IFFALSE 17215
// Say ( Gary , D3nW-Gary-1 ) else
17201: LD_EXP 48
17205: PPUSH
17206: LD_STRING D3nW-Gary-1
17208: PPUSH
17209: CALL_OW 88
17213: GO 17336
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17215: LD_EXP 40
17219: PUSH
17220: LD_EXP 56
17224: IN
17225: PUSH
17226: LD_EXP 40
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 1
17238: EQUAL
17239: AND
17240: IFFALSE 17256
// Say ( Donaldson , D3nW-Don-1 ) else
17242: LD_EXP 40
17246: PPUSH
17247: LD_STRING D3nW-Don-1
17249: PPUSH
17250: CALL_OW 88
17254: GO 17336
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17256: LD_EXP 47
17260: PUSH
17261: LD_EXP 56
17265: IN
17266: PUSH
17267: LD_EXP 47
17271: PPUSH
17272: CALL_OW 255
17276: PUSH
17277: LD_INT 1
17279: EQUAL
17280: AND
17281: IFFALSE 17297
// Say ( Cornel , D3nW-Corn-1 ) else
17283: LD_EXP 47
17287: PPUSH
17288: LD_STRING D3nW-Corn-1
17290: PPUSH
17291: CALL_OW 88
17295: GO 17336
// if Frank in vip and GetSide ( Frank ) = 1 then
17297: LD_EXP 49
17301: PUSH
17302: LD_EXP 56
17306: IN
17307: PUSH
17308: LD_EXP 49
17312: PPUSH
17313: CALL_OW 255
17317: PUSH
17318: LD_INT 1
17320: EQUAL
17321: AND
17322: IFFALSE 17336
// Say ( Frank , D3nW-Frank-1 ) ;
17324: LD_EXP 49
17328: PPUSH
17329: LD_STRING D3nW-Frank-1
17331: PPUSH
17332: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17336: LD_EXP 36
17340: PPUSH
17341: LD_STRING D3nW-JMM-1
17343: PPUSH
17344: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17348: LD_EXP 36
17352: PPUSH
17353: LD_STRING D3nW-JMM-1a
17355: PPUSH
17356: CALL_OW 88
// t := 0 0$00 ;
17360: LD_ADDR_VAR 0 3
17364: PUSH
17365: LD_INT 0
17367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17368: LD_INT 35
17370: PPUSH
17371: CALL_OW 67
// t := t + 0 0$1 ;
17375: LD_ADDR_VAR 0 3
17379: PUSH
17380: LD_VAR 0 3
17384: PUSH
17385: LD_INT 35
17387: PLUS
17388: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17389: LD_INT 59
17391: PPUSH
17392: LD_INT 112
17394: PPUSH
17395: CALL_OW 428
17399: PUSH
17400: LD_VAR 0 3
17404: PUSH
17405: LD_INT 2100
17407: GREATER
17408: OR
17409: IFFALSE 17368
// activeAttacks := true ;
17411: LD_ADDR_EXP 16
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
// end ;
17419: LD_VAR 0 1
17423: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17424: LD_INT 0
17426: PPUSH
// case question of 1 :
17427: LD_VAR 0 1
17431: PUSH
17432: LD_INT 1
17434: DOUBLE
17435: EQUAL
17436: IFTRUE 17440
17438: GO 17491
17440: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17441: LD_EXP 36
17445: PPUSH
17446: LD_STRING D2Mot-JMM-1
17448: PPUSH
17449: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17453: LD_EXP 55
17457: PPUSH
17458: LD_STRING D2Mot-Pow-1
17460: PPUSH
17461: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17465: LD_EXP 36
17469: PPUSH
17470: LD_STRING D2Mot-JMM-2
17472: PPUSH
17473: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17477: LD_EXP 55
17481: PPUSH
17482: LD_STRING D2Mot-Pow-2
17484: PPUSH
17485: CALL_OW 88
// end ; 2 :
17489: GO 17834
17491: LD_INT 2
17493: DOUBLE
17494: EQUAL
17495: IFTRUE 17499
17497: GO 17575
17499: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Rus-JMM-1
17507: PPUSH
17508: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17512: LD_EXP 55
17516: PPUSH
17517: LD_STRING D2Rus-Pow-1
17519: PPUSH
17520: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17524: LD_EXP 36
17528: PPUSH
17529: LD_STRING D2Rus-JMM-2
17531: PPUSH
17532: CALL_OW 88
// if not ( 3 in list_of_q ) then
17536: LD_INT 3
17538: PUSH
17539: LD_VAR 0 2
17543: IN
17544: NOT
17545: IFFALSE 17561
// Say ( Powell , D2Rus-Pow-2 ) else
17547: LD_EXP 55
17551: PPUSH
17552: LD_STRING D2Rus-Pow-2
17554: PPUSH
17555: CALL_OW 88
17559: GO 17573
// Say ( Powell , D2Rus-Pow-2a ) ;
17561: LD_EXP 55
17565: PPUSH
17566: LD_STRING D2Rus-Pow-2a
17568: PPUSH
17569: CALL_OW 88
// end ; 3 :
17573: GO 17834
17575: LD_INT 3
17577: DOUBLE
17578: EQUAL
17579: IFTRUE 17583
17581: GO 17668
17583: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17584: LD_EXP 36
17588: PPUSH
17589: LD_STRING D2Leg-JMM-1
17591: PPUSH
17592: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17596: LD_EXP 55
17600: PPUSH
17601: LD_STRING D2Leg-Pow-1
17603: PPUSH
17604: CALL_OW 88
// if 2 in list_of_q then
17608: LD_INT 2
17610: PUSH
17611: LD_VAR 0 2
17615: IN
17616: IFFALSE 17642
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17618: LD_EXP 36
17622: PPUSH
17623: LD_STRING D2Leg-JMM-2
17625: PPUSH
17626: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17630: LD_EXP 55
17634: PPUSH
17635: LD_STRING D2Leg-Pow-2
17637: PPUSH
17638: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17642: LD_EXP 36
17646: PPUSH
17647: LD_STRING D2Leg-JMM-3
17649: PPUSH
17650: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17654: LD_EXP 55
17658: PPUSH
17659: LD_STRING D2Leg-Pow-3
17661: PPUSH
17662: CALL_OW 88
// end ; 4 :
17666: GO 17834
17668: LD_INT 4
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17751
17676: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17677: LD_EXP 36
17681: PPUSH
17682: LD_STRING D2Ar-JMM-1
17684: PPUSH
17685: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17689: LD_EXP 55
17693: PPUSH
17694: LD_STRING D2Ar-Pow-1
17696: PPUSH
17697: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Ar-JMM-2
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Ar-Pow-2
17720: PPUSH
17721: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17725: LD_EXP 36
17729: PPUSH
17730: LD_STRING D2Ar-JMM-3
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17737: LD_EXP 55
17741: PPUSH
17742: LD_STRING D2Ar-Pow-3
17744: PPUSH
17745: CALL_OW 88
// end ; 5 :
17749: GO 17834
17751: LD_INT 5
17753: DOUBLE
17754: EQUAL
17755: IFTRUE 17759
17757: GO 17774
17759: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17760: LD_EXP 36
17764: PPUSH
17765: LD_STRING D2Conf-JMM-1
17767: PPUSH
17768: CALL_OW 88
17772: GO 17834
17774: LD_INT 6
17776: DOUBLE
17777: EQUAL
17778: IFTRUE 17782
17780: GO 17833
17782: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17783: LD_EXP 36
17787: PPUSH
17788: LD_STRING D2Com-JMM-1
17790: PPUSH
17791: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17795: LD_EXP 55
17799: PPUSH
17800: LD_STRING D2Com-Pow-1
17802: PPUSH
17803: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17807: LD_EXP 36
17811: PPUSH
17812: LD_STRING D2Com-JMM-2
17814: PPUSH
17815: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17819: LD_EXP 55
17823: PPUSH
17824: LD_STRING D2Com-Pow-2
17826: PPUSH
17827: CALL_OW 88
// end ; end ;
17831: GO 17834
17833: POP
// end ;
17834: LD_VAR 0 3
17838: RET
// every 0 0$5 trigger missionStart do var tmp ;
17839: LD_EXP 13
17843: IFFALSE 18126
17845: GO 17847
17847: DISABLE
17848: LD_INT 0
17850: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17851: LD_INT 35
17853: PPUSH
17854: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17858: LD_INT 14
17860: PPUSH
17861: LD_INT 22
17863: PUSH
17864: LD_INT 1
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PPUSH
17871: CALL_OW 70
17875: PUSH
17876: LD_EXP 15
17880: PUSH
17881: LD_INT 2
17883: PUSH
17884: LD_INT 3
17886: PUSH
17887: LD_INT 4
17889: PUSH
17890: LD_INT 5
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: IN
17899: AND
17900: IFFALSE 18116
// begin powellAnger := powellAnger + 1 ;
17902: LD_ADDR_EXP 17
17906: PUSH
17907: LD_EXP 17
17911: PUSH
17912: LD_INT 1
17914: PLUS
17915: ST_TO_ADDR
// Video ( true ) ;
17916: LD_INT 1
17918: PPUSH
17919: CALL 105956 0 1
// CenterNowOnUnits ( tmp ) ;
17923: LD_VAR 0 1
17927: PPUSH
17928: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17932: LD_INT 14
17934: PPUSH
17935: LD_INT 22
17937: PUSH
17938: LD_INT 1
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PPUSH
17945: CALL_OW 70
17949: PPUSH
17950: LD_INT 86
17952: PPUSH
17953: LD_INT 133
17955: PPUSH
17956: CALL_OW 111
// async ;
17960: ASYNC
// case powellAnger of 1 :
17961: LD_EXP 17
17965: PUSH
17966: LD_INT 1
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 17989
17974: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17975: LD_EXP 55
17979: PPUSH
17980: LD_STRING DBack1-Pow-1
17982: PPUSH
17983: CALL_OW 88
17987: GO 18036
17989: LD_INT 2
17991: DOUBLE
17992: EQUAL
17993: IFTRUE 17997
17995: GO 18012
17997: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17998: LD_EXP 55
18002: PPUSH
18003: LD_STRING DBack2-Pow-1
18005: PPUSH
18006: CALL_OW 88
18010: GO 18036
18012: LD_INT 3
18014: DOUBLE
18015: EQUAL
18016: IFTRUE 18020
18018: GO 18035
18020: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18021: LD_EXP 55
18025: PPUSH
18026: LD_STRING DBack3-Pow-1
18028: PPUSH
18029: CALL_OW 88
18033: GO 18036
18035: POP
// sync ;
18036: SYNC
// repeat wait ( 0 0$1 ) ;
18037: LD_INT 35
18039: PPUSH
18040: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18044: LD_INT 14
18046: PPUSH
18047: LD_INT 22
18049: PUSH
18050: LD_INT 1
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PPUSH
18057: CALL_OW 70
18061: PPUSH
18062: LD_INT 86
18064: PPUSH
18065: LD_INT 133
18067: PPUSH
18068: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18072: LD_INT 14
18074: PPUSH
18075: LD_INT 22
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PPUSH
18085: CALL_OW 70
18089: NOT
18090: IFFALSE 18037
// if powellAnger >= 3 then
18092: LD_EXP 17
18096: PUSH
18097: LD_INT 3
18099: GREATEREQUAL
18100: IFFALSE 18109
// YouLost ( Dismissed ) ;
18102: LD_STRING Dismissed
18104: PPUSH
18105: CALL_OW 104
// Video ( false ) ;
18109: LD_INT 0
18111: PPUSH
18112: CALL 105956 0 1
// end ; until missionStage > 5 ;
18116: LD_EXP 15
18120: PUSH
18121: LD_INT 5
18123: GREATER
18124: IFFALSE 17851
// end ;
18126: PPOPN 1
18128: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18129: LD_EXP 13
18133: PUSH
18134: LD_INT 22
18136: PUSH
18137: LD_INT 4
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: PUSH
18144: LD_INT 21
18146: PUSH
18147: LD_INT 2
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PPUSH
18158: CALL_OW 69
18162: PUSH
18163: LD_INT 4
18165: GREATEREQUAL
18166: AND
18167: PUSH
18168: LD_EXP 15
18172: PUSH
18173: LD_INT 2
18175: EQUAL
18176: AND
18177: IFFALSE 20000
18179: GO 18181
18181: DISABLE
18182: LD_INT 0
18184: PPUSH
18185: PPUSH
18186: PPUSH
18187: PPUSH
18188: PPUSH
18189: PPUSH
18190: PPUSH
18191: PPUSH
// begin missionStage := 3 ;
18192: LD_ADDR_EXP 15
18196: PUSH
18197: LD_INT 3
18199: ST_TO_ADDR
// retreat := false ;
18200: LD_ADDR_VAR 0 4
18204: PUSH
18205: LD_INT 0
18207: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18208: LD_ADDR_VAR 0 5
18212: PUSH
18213: LD_INT 22
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: PUSH
18223: LD_INT 30
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PPUSH
18237: CALL_OW 69
18241: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18242: LD_ADDR_VAR 0 6
18246: PUSH
18247: LD_INT 22
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 5
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PPUSH
18271: CALL_OW 69
18275: ST_TO_ADDR
// if not bar then
18276: LD_VAR 0 6
18280: NOT
18281: IFFALSE 18334
// begin repeat wait ( 0 0$1 ) ;
18283: LD_INT 35
18285: PPUSH
18286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18290: LD_INT 22
18292: PUSH
18293: LD_INT 4
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 3
18302: PUSH
18303: LD_INT 57
18305: PUSH
18306: EMPTY
18307: LIST
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 5
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: PPUSH
18328: CALL_OW 69
18332: IFFALSE 18283
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18334: LD_ADDR_VAR 0 6
18338: PUSH
18339: LD_INT 22
18341: PUSH
18342: LD_INT 4
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 5
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 69
18367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18368: LD_INT 35
18370: PPUSH
18371: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18375: LD_EXP 118
18379: PUSH
18380: LD_INT 4
18382: ARRAY
18383: PUSH
18384: LD_INT 4
18386: GREATEREQUAL
18387: IFFALSE 18368
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18389: LD_ADDR_VAR 0 2
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 4
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 2
18406: PUSH
18407: LD_INT 25
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 2
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 3
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 5
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL_OW 69
18473: PUSH
18474: LD_EXP 55
18478: PUSH
18479: LD_EXP 56
18483: ADD
18484: DIFF
18485: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18486: LD_ADDR_VAR 0 3
18490: PUSH
18491: LD_VAR 0 2
18495: PPUSH
18496: LD_INT 26
18498: PUSH
18499: LD_INT 1
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: PPUSH
18506: CALL_OW 72
18510: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18511: LD_ADDR_VAR 0 2
18515: PUSH
18516: LD_VAR 0 2
18520: PUSH
18521: LD_VAR 0 3
18525: DIFF
18526: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18527: LD_ADDR_VAR 0 2
18531: PUSH
18532: LD_VAR 0 2
18536: PPUSH
18537: LD_INT 1
18539: PPUSH
18540: CALL 104609 0 2
18544: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18545: LD_ADDR_VAR 0 3
18549: PUSH
18550: LD_VAR 0 3
18554: PPUSH
18555: LD_INT 1
18557: PPUSH
18558: CALL 104609 0 2
18562: ST_TO_ADDR
// for i = 1 to 4 do
18563: LD_ADDR_VAR 0 1
18567: PUSH
18568: DOUBLE
18569: LD_INT 1
18571: DEC
18572: ST_TO_ADDR
18573: LD_INT 4
18575: PUSH
18576: FOR_TO
18577: IFFALSE 18743
// begin if tmp2 then
18579: LD_VAR 0 3
18583: IFFALSE 18664
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18585: LD_ADDR_EXP 18
18589: PUSH
18590: LD_EXP 18
18594: PPUSH
18595: LD_INT 1
18597: PPUSH
18598: LD_EXP 18
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: ARRAY
18617: ADD
18618: PPUSH
18619: CALL_OW 1
18623: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18624: LD_VAR 0 3
18628: PUSH
18629: LD_VAR 0 3
18633: ARRAY
18634: PPUSH
18635: LD_INT 1
18637: PPUSH
18638: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_VAR 0 3
18651: PPUSH
18652: LD_VAR 0 3
18656: PPUSH
18657: CALL_OW 3
18661: ST_TO_ADDR
// end else
18662: GO 18741
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18664: LD_ADDR_EXP 18
18668: PUSH
18669: LD_EXP 18
18673: PPUSH
18674: LD_INT 1
18676: PPUSH
18677: LD_EXP 18
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PUSH
18686: LD_VAR 0 2
18690: PUSH
18691: LD_VAR 0 2
18695: ARRAY
18696: ADD
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18703: LD_VAR 0 2
18707: PUSH
18708: LD_VAR 0 2
18712: ARRAY
18713: PPUSH
18714: LD_INT 1
18716: PPUSH
18717: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18721: LD_ADDR_VAR 0 2
18725: PUSH
18726: LD_VAR 0 2
18730: PPUSH
18731: LD_VAR 0 2
18735: PPUSH
18736: CALL_OW 3
18740: ST_TO_ADDR
// end ; end ;
18741: GO 18576
18743: POP
18744: POP
// if tmp2 then
18745: LD_VAR 0 3
18749: IFFALSE 18767
// tmp := tmp union tmp2 ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_VAR 0 3
18765: UNION
18766: ST_TO_ADDR
// for i = 1 to 4 do
18767: LD_ADDR_VAR 0 1
18771: PUSH
18772: DOUBLE
18773: LD_INT 1
18775: DEC
18776: ST_TO_ADDR
18777: LD_INT 4
18779: PUSH
18780: FOR_TO
18781: IFFALSE 18830
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18783: LD_ADDR_EXP 18
18787: PUSH
18788: LD_EXP 18
18792: PPUSH
18793: LD_INT 2
18795: PPUSH
18796: LD_EXP 18
18800: PUSH
18801: LD_INT 2
18803: ARRAY
18804: PUSH
18805: LD_VAR 0 2
18809: PUSH
18810: LD_VAR 0 2
18814: PUSH
18815: LD_VAR 0 1
18819: MINUS
18820: ARRAY
18821: ADD
18822: PPUSH
18823: CALL_OW 1
18827: ST_TO_ADDR
18828: GO 18780
18830: POP
18831: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18832: LD_ADDR_EXP 99
18836: PUSH
18837: LD_EXP 99
18841: PPUSH
18842: LD_INT 4
18844: PPUSH
18845: LD_EXP 99
18849: PUSH
18850: LD_INT 4
18852: ARRAY
18853: PUSH
18854: LD_EXP 18
18858: PUSH
18859: LD_INT 1
18861: ARRAY
18862: DIFF
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18869: LD_VAR 0 5
18873: PUSH
18874: LD_INT 1
18876: ARRAY
18877: PPUSH
18878: CALL_OW 313
18882: IFFALSE 18937
// begin for i in UnitsInside ( arm [ 1 ] ) do
18884: LD_ADDR_VAR 0 1
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: LD_INT 1
18896: ARRAY
18897: PPUSH
18898: CALL_OW 313
18902: PUSH
18903: FOR_IN
18904: IFFALSE 18935
// begin ComExitBuilding ( i ) ;
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18915: LD_VAR 0 1
18919: PPUSH
18920: LD_VAR 0 6
18924: PUSH
18925: LD_INT 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 180
// end ;
18933: GO 18903
18935: POP
18936: POP
// end ; wait ( 0 0$3 ) ;
18937: LD_INT 105
18939: PPUSH
18940: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18944: LD_ADDR_VAR 0 1
18948: PUSH
18949: LD_EXP 18
18953: PUSH
18954: LD_INT 1
18956: ARRAY
18957: PUSH
18958: FOR_IN
18959: IFFALSE 19066
// begin if IsInUnit ( i ) then
18961: LD_VAR 0 1
18965: PPUSH
18966: CALL_OW 310
18970: IFFALSE 18981
// ComExitBuilding ( i ) ;
18972: LD_VAR 0 1
18976: PPUSH
18977: CALL_OW 122
// if GetClass ( i ) <> 1 then
18981: LD_VAR 0 1
18985: PPUSH
18986: CALL_OW 257
18990: PUSH
18991: LD_INT 1
18993: NONEQUAL
18994: IFFALSE 19035
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18996: LD_VAR 0 1
19000: PPUSH
19001: LD_VAR 0 5
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PPUSH
19010: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 183
// AddComExitBuilding ( i ) ;
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19035: LD_VAR 0 1
19039: PPUSH
19040: LD_INT 60
19042: PPUSH
19043: LD_INT 94
19045: PPUSH
19046: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19050: LD_VAR 0 1
19054: PPUSH
19055: LD_EXP 55
19059: PPUSH
19060: CALL_OW 179
// end ;
19064: GO 18958
19066: POP
19067: POP
// wait ( 0 0$15 ) ;
19068: LD_INT 525
19070: PPUSH
19071: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19075: LD_EXP 55
19079: PPUSH
19080: LD_STRING D4-Pow-1
19082: PPUSH
19083: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19087: LD_ADDR_VAR 0 2
19091: PUSH
19092: LD_EXP 18
19096: PUSH
19097: LD_INT 1
19099: ARRAY
19100: PPUSH
19101: LD_INT 26
19103: PUSH
19104: LD_INT 1
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: ST_TO_ADDR
// if tmp then
19116: LD_VAR 0 2
19120: IFFALSE 19138
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19122: LD_VAR 0 2
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: LD_STRING D4-Sol1-1
19133: PPUSH
19134: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19138: LD_EXP 55
19142: PPUSH
19143: LD_STRING D4-Pow-2
19145: PPUSH
19146: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: DOUBLE
19156: LD_INT 1
19158: DEC
19159: ST_TO_ADDR
19160: LD_EXP 18
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: FOR_TO
19170: IFFALSE 19263
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19172: LD_EXP 18
19176: PUSH
19177: LD_INT 1
19179: ARRAY
19180: PUSH
19181: LD_VAR 0 1
19185: ARRAY
19186: PPUSH
19187: LD_EXP 118
19191: PUSH
19192: LD_INT 4
19194: ARRAY
19195: PUSH
19196: LD_INT 1
19198: ARRAY
19199: PPUSH
19200: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19204: LD_ADDR_EXP 118
19208: PUSH
19209: LD_EXP 118
19213: PPUSH
19214: LD_INT 4
19216: PPUSH
19217: LD_EXP 118
19221: PUSH
19222: LD_INT 4
19224: ARRAY
19225: PPUSH
19226: LD_INT 1
19228: PPUSH
19229: CALL_OW 3
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19239: LD_INT 8
19241: PPUSH
19242: LD_EXP 18
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: PUSH
19251: LD_VAR 0 1
19255: ARRAY
19256: PPUSH
19257: CALL_OW 471
// end ;
19261: GO 19169
19263: POP
19264: POP
// repeat wait ( 0 0$1 ) ;
19265: LD_INT 35
19267: PPUSH
19268: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19272: LD_EXP 18
19276: PUSH
19277: LD_INT 1
19279: ARRAY
19280: PPUSH
19281: LD_INT 55
19283: PUSH
19284: EMPTY
19285: LIST
19286: PPUSH
19287: CALL_OW 72
19291: PUSH
19292: LD_INT 4
19294: GREATEREQUAL
19295: IFFALSE 19265
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19297: LD_EXP 18
19301: PUSH
19302: LD_INT 1
19304: ARRAY
19305: PPUSH
19306: LD_INT 69
19308: PPUSH
19309: LD_INT 94
19311: PPUSH
19312: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19316: LD_EXP 18
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: PPUSH
19325: LD_INT 82
19327: PPUSH
19328: LD_INT 83
19330: PPUSH
19331: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19335: LD_EXP 18
19339: PUSH
19340: LD_INT 1
19342: ARRAY
19343: PPUSH
19344: LD_INT 77
19346: PPUSH
19347: LD_INT 69
19349: PPUSH
19350: CALL_OW 174
// repeat wait ( 3 ) ;
19354: LD_INT 3
19356: PPUSH
19357: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19361: LD_ADDR_VAR 0 1
19365: PUSH
19366: LD_EXP 18
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: PUSH
19375: FOR_IN
19376: IFFALSE 19512
// begin if GetLives ( i ) < 990 then
19378: LD_VAR 0 1
19382: PPUSH
19383: CALL_OW 256
19387: PUSH
19388: LD_INT 990
19390: LESS
19391: IFFALSE 19405
// SetLives ( i , 1000 ) ;
19393: LD_VAR 0 1
19397: PPUSH
19398: LD_INT 1000
19400: PPUSH
19401: CALL_OW 234
// if not IsInUnit ( i ) then
19405: LD_VAR 0 1
19409: PPUSH
19410: CALL_OW 310
19414: NOT
19415: IFFALSE 19510
// begin if not HasTask ( i ) then
19417: LD_VAR 0 1
19421: PPUSH
19422: CALL_OW 314
19426: NOT
19427: IFFALSE 19444
// ComMoveXY ( i , 64 , 93 ) ;
19429: LD_VAR 0 1
19433: PPUSH
19434: LD_INT 64
19436: PPUSH
19437: LD_INT 93
19439: PPUSH
19440: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19444: LD_VAR 0 4
19448: NOT
19449: PUSH
19450: LD_VAR 0 1
19454: PPUSH
19455: CALL_OW 258
19459: PUSH
19460: LD_INT 1
19462: EQUAL
19463: AND
19464: IFFALSE 19510
// begin retreat := true ;
19466: LD_ADDR_VAR 0 4
19470: PUSH
19471: LD_INT 1
19473: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 2
19481: PPUSH
19482: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: LD_STRING D4a-Sol1-1
19493: PPUSH
19494: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19498: LD_EXP 55
19502: PPUSH
19503: LD_STRING D4a-Pow-1
19505: PPUSH
19506: CALL_OW 88
// end ; end ; end ;
19510: GO 19375
19512: POP
19513: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19514: LD_EXP 18
19518: PUSH
19519: LD_INT 1
19521: ARRAY
19522: PPUSH
19523: LD_INT 95
19525: PUSH
19526: LD_INT 9
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 3
19535: PUSH
19536: LD_INT 55
19538: PUSH
19539: EMPTY
19540: LIST
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 72
19554: PUSH
19555: LD_INT 4
19557: GREATEREQUAL
19558: IFFALSE 19354
// for i in powellSquadAttack [ 1 ] do
19560: LD_ADDR_VAR 0 1
19564: PUSH
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19711
// begin if GetTag ( i ) = 2 then
19577: LD_VAR 0 1
19581: PPUSH
19582: CALL_OW 110
19586: PUSH
19587: LD_INT 2
19589: EQUAL
19590: IFFALSE 19652
// begin ComMoveXY ( i , 60 , 94 ) ;
19592: LD_VAR 0 1
19596: PPUSH
19597: LD_INT 60
19599: PPUSH
19600: LD_INT 94
19602: PPUSH
19603: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_EXP 55
19616: PPUSH
19617: CALL_OW 179
// wait ( 0 0$3 ) ;
19621: LD_INT 105
19623: PPUSH
19624: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_STRING D4a-Sol1-2
19635: PPUSH
19636: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19640: LD_EXP 55
19644: PPUSH
19645: LD_STRING D4a-Pow-2
19647: PPUSH
19648: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19652: LD_VAR 0 1
19656: PPUSH
19657: LD_INT 0
19659: PPUSH
19660: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19664: LD_ADDR_EXP 99
19668: PUSH
19669: LD_EXP 99
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 99
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PUSH
19686: LD_VAR 0 1
19690: UNION
19691: PPUSH
19692: CALL_OW 1
19696: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19697: LD_INT 8
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 472
// end ;
19709: GO 19574
19711: POP
19712: POP
// wait ( 4 4$00 ) ;
19713: LD_INT 8400
19715: PPUSH
19716: CALL_OW 67
// uc_side := 6 ;
19720: LD_ADDR_OWVAR 20
19724: PUSH
19725: LD_INT 6
19727: ST_TO_ADDR
// uc_nation := 3 ;
19728: LD_ADDR_OWVAR 21
19732: PUSH
19733: LD_INT 3
19735: ST_TO_ADDR
// ru := [ ] ;
19736: LD_ADDR_VAR 0 7
19740: PUSH
19741: EMPTY
19742: ST_TO_ADDR
// for i = 1 to 4 do
19743: LD_ADDR_VAR 0 1
19747: PUSH
19748: DOUBLE
19749: LD_INT 1
19751: DEC
19752: ST_TO_ADDR
19753: LD_INT 4
19755: PUSH
19756: FOR_TO
19757: IFFALSE 19858
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19759: LD_INT 22
19761: PPUSH
19762: LD_INT 1
19764: PPUSH
19765: LD_INT 3
19767: PPUSH
19768: LD_INT 43
19770: PUSH
19771: LD_INT 44
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: LD_INT 1
19780: PPUSH
19781: LD_INT 2
19783: PPUSH
19784: CALL_OW 12
19788: ARRAY
19789: PPUSH
19790: LD_INT 89
19792: PPUSH
19793: CALL 70239 0 5
// un := CreateVehicle ;
19797: LD_ADDR_VAR 0 8
19801: PUSH
19802: CALL_OW 45
19806: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19807: LD_VAR 0 8
19811: PPUSH
19812: LD_INT 4
19814: PPUSH
19815: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19819: LD_VAR 0 8
19823: PPUSH
19824: LD_INT 136
19826: PPUSH
19827: LD_INT 90
19829: PPUSH
19830: LD_INT 8
19832: PPUSH
19833: LD_INT 0
19835: PPUSH
19836: CALL_OW 50
// ru := ru ^ un ;
19840: LD_ADDR_VAR 0 7
19844: PUSH
19845: LD_VAR 0 7
19849: PUSH
19850: LD_VAR 0 8
19854: ADD
19855: ST_TO_ADDR
// end ;
19856: GO 19756
19858: POP
19859: POP
// if ru then
19860: LD_VAR 0 7
19864: IFFALSE 19881
// ComAgressiveMove ( ru , 80 , 92 ) ;
19866: LD_VAR 0 7
19870: PPUSH
19871: LD_INT 80
19873: PPUSH
19874: LD_INT 92
19876: PPUSH
19877: CALL_OW 114
// wait ( 8 8$00 ) ;
19881: LD_INT 16800
19883: PPUSH
19884: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19888: LD_INT 4
19890: PPUSH
19891: LD_INT 3
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 1
19899: PUSH
19900: LD_INT 5
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: PUSH
19909: LD_INT 4
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: LD_INT 1
19917: PUSH
19918: LD_INT 6
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: LD_INT 4
19929: PUSH
19930: LD_INT 1
19932: PUSH
19933: LD_INT 1
19935: PUSH
19936: LD_INT 7
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: PUSH
19945: LD_INT 3
19947: PUSH
19948: LD_INT 1
19950: PUSH
19951: LD_INT 1
19953: PUSH
19954: LD_INT 7
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: LD_INT 1
19968: PUSH
19969: LD_INT 1
19971: PUSH
19972: LD_INT 5
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL 57318 0 2
// missionStage := 4 ;
19992: LD_ADDR_EXP 15
19996: PUSH
19997: LD_INT 4
19999: ST_TO_ADDR
// end ;
20000: PPOPN 8
20002: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20003: LD_EXP 15
20007: PUSH
20008: LD_INT 4
20010: EQUAL
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 4
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 2
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: PUSH
20041: LD_INT 5
20043: GREATEREQUAL
20044: AND
20045: IFFALSE 24138
20047: GO 20049
20049: DISABLE
20050: LD_INT 0
20052: PPUSH
20053: PPUSH
20054: PPUSH
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
20061: PPUSH
20062: PPUSH
20063: PPUSH
20064: PPUSH
// begin missionStage := 5 ;
20065: LD_ADDR_EXP 15
20069: PUSH
20070: LD_INT 5
20072: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20073: LD_ADDR_VAR 0 10
20077: PUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 30
20093: PUSH
20094: LD_INT 4
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 5
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: EMPTY
20112: LIST
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL_OW 69
20124: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20125: LD_ADDR_VAR 0 6
20129: PUSH
20130: LD_INT 22
20132: PUSH
20133: LD_INT 4
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: PUSH
20140: LD_INT 21
20142: PUSH
20143: LD_INT 1
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 3
20152: PUSH
20153: LD_INT 25
20155: PUSH
20156: LD_INT 16
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: LD_INT 25
20172: PUSH
20173: LD_INT 12
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: PPUSH
20190: CALL_OW 69
20194: PUSH
20195: LD_EXP 55
20199: DIFF
20200: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20201: LD_ADDR_VAR 0 9
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 4
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PUSH
20216: LD_INT 30
20218: PUSH
20219: LD_INT 3
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PPUSH
20230: CALL_OW 69
20234: PUSH
20235: LD_INT 1
20237: ARRAY
20238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20239: LD_INT 35
20241: PPUSH
20242: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20246: LD_EXP 118
20250: PUSH
20251: LD_INT 4
20253: ARRAY
20254: PUSH
20255: LD_INT 5
20257: GREATEREQUAL
20258: PUSH
20259: LD_EXP 118
20263: PUSH
20264: LD_INT 4
20266: ARRAY
20267: PPUSH
20268: LD_INT 58
20270: PUSH
20271: EMPTY
20272: LIST
20273: PPUSH
20274: CALL_OW 72
20278: PUSH
20279: LD_INT 5
20281: GREATEREQUAL
20282: AND
20283: IFFALSE 20239
// powellAllowRetreat := false ;
20285: LD_ADDR_EXP 19
20289: PUSH
20290: LD_INT 0
20292: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20293: LD_INT 700
20295: PPUSH
20296: CALL_OW 67
// activeAttacks := false ;
20300: LD_ADDR_EXP 16
20304: PUSH
20305: LD_INT 0
20307: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20308: LD_INT 35
20310: PPUSH
20311: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20315: LD_INT 22
20317: PUSH
20318: LD_INT 6
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PPUSH
20325: CALL_OW 69
20329: PUSH
20330: LD_INT 0
20332: EQUAL
20333: IFFALSE 20308
// tmp := mc_vehicles [ 4 ] ;
20335: LD_ADDR_VAR 0 3
20339: PUSH
20340: LD_EXP 118
20344: PUSH
20345: LD_INT 4
20347: ARRAY
20348: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20349: LD_ADDR_VAR 0 1
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_EXP 18
20363: PUSH
20364: FOR_TO
20365: IFFALSE 20626
// begin for j in powellSquadAttack [ i ] do
20367: LD_ADDR_VAR 0 2
20371: PUSH
20372: LD_EXP 18
20376: PUSH
20377: LD_VAR 0 1
20381: ARRAY
20382: PUSH
20383: FOR_IN
20384: IFFALSE 20622
// begin forces := forces diff j ;
20386: LD_ADDR_VAR 0 6
20390: PUSH
20391: LD_VAR 0 6
20395: PUSH
20396: LD_VAR 0 2
20400: DIFF
20401: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20402: LD_VAR 0 2
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 109
// wait ( 0 0$2 ) ;
20414: LD_INT 70
20416: PPUSH
20417: CALL_OW 67
// if IsInUnit ( j ) then
20421: LD_VAR 0 2
20425: PPUSH
20426: CALL_OW 310
20430: IFFALSE 20441
// ComExitBuilding ( j ) ;
20432: LD_VAR 0 2
20436: PPUSH
20437: CALL_OW 122
// if GetClass ( j ) <> 1 then
20441: LD_VAR 0 2
20445: PPUSH
20446: CALL_OW 257
20450: PUSH
20451: LD_INT 1
20453: NONEQUAL
20454: IFFALSE 20534
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20456: LD_VAR 0 10
20460: PUSH
20461: LD_INT 1
20463: ARRAY
20464: PPUSH
20465: CALL_OW 313
20469: PUSH
20470: LD_INT 5
20472: GREATEREQUAL
20473: IFFALSE 20495
// AddComEnterUnit ( j , arm [ 2 ] ) else
20475: LD_VAR 0 2
20479: PPUSH
20480: LD_VAR 0 10
20484: PUSH
20485: LD_INT 2
20487: ARRAY
20488: PPUSH
20489: CALL_OW 180
20493: GO 20513
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20495: LD_VAR 0 2
20499: PPUSH
20500: LD_VAR 0 10
20504: PUSH
20505: LD_INT 1
20507: ARRAY
20508: PPUSH
20509: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20513: LD_VAR 0 2
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: CALL_OW 183
// AddComExitBuilding ( j ) ;
20525: LD_VAR 0 2
20529: PPUSH
20530: CALL_OW 182
// end ; if i = 2 then
20534: LD_VAR 0 1
20538: PUSH
20539: LD_INT 2
20541: EQUAL
20542: IFFALSE 20559
// AddComMoveXY ( j , 61 , 93 ) ;
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_INT 61
20551: PPUSH
20552: LD_INT 93
20554: PPUSH
20555: CALL_OW 171
// if i = 1 then
20559: LD_VAR 0 1
20563: PUSH
20564: LD_INT 1
20566: EQUAL
20567: IFFALSE 20620
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20569: LD_VAR 0 2
20573: PPUSH
20574: LD_VAR 0 3
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PPUSH
20583: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20587: LD_ADDR_VAR 0 3
20591: PUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 3
20604: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20605: LD_VAR 0 2
20609: PPUSH
20610: LD_INT 69
20612: PPUSH
20613: LD_INT 94
20615: PPUSH
20616: CALL_OW 171
// end ; end ;
20620: GO 20383
20622: POP
20623: POP
// end ;
20624: GO 20364
20626: POP
20627: POP
// wait ( 0 0$55 ) ;
20628: LD_INT 1925
20630: PPUSH
20631: CALL_OW 67
// MC_Kill ( 4 ) ;
20635: LD_INT 4
20637: PPUSH
20638: CALL 34018 0 1
// tmp := UnitsInside ( fac ) ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 9
20651: PPUSH
20652: CALL_OW 313
20656: ST_TO_ADDR
// if tmp then
20657: LD_VAR 0 3
20661: IFFALSE 20782
// for i in tmp do
20663: LD_ADDR_VAR 0 1
20667: PUSH
20668: LD_VAR 0 3
20672: PUSH
20673: FOR_IN
20674: IFFALSE 20780
// begin ComExitBuilding ( i ) ;
20676: LD_VAR 0 1
20680: PPUSH
20681: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 2
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 6
20701: LESS
20702: IFFALSE 20724
// AddComEnterUnit ( i , arm [ 2 ] ) else
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20778
// if UnitsInside ( arm [ 1 ] ) < 6 then
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 313
20737: PUSH
20738: LD_INT 6
20740: LESS
20741: IFFALSE 20763
// AddComEnterUnit ( i , arm [ 1 ] ) else
20743: LD_VAR 0 1
20747: PPUSH
20748: LD_VAR 0 10
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: PPUSH
20757: CALL_OW 180
20761: GO 20778
// AddComMoveXY ( i , 37 , 68 ) ;
20763: LD_VAR 0 1
20767: PPUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 68
20773: PPUSH
20774: CALL_OW 171
// end ;
20778: GO 20673
20780: POP
20781: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20782: LD_ADDR_VAR 0 11
20786: PUSH
20787: LD_VAR 0 6
20791: PPUSH
20792: LD_INT 26
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 72
20806: PUSH
20807: LD_EXP 56
20811: DIFF
20812: ST_TO_ADDR
// if not speaker then
20813: LD_VAR 0 11
20817: NOT
20818: IFFALSE 20845
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20820: LD_ADDR_VAR 0 11
20824: PUSH
20825: LD_VAR 0 6
20829: PPUSH
20830: LD_INT 26
20832: PUSH
20833: LD_INT 1
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: PPUSH
20840: CALL_OW 72
20844: ST_TO_ADDR
// if speaker then
20845: LD_VAR 0 11
20849: IFFALSE 20865
// speaker := speaker [ 1 ] ;
20851: LD_ADDR_VAR 0 11
20855: PUSH
20856: LD_VAR 0 11
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: ST_TO_ADDR
// Video ( true ) ;
20865: LD_INT 1
20867: PPUSH
20868: CALL 105956 0 1
// CenterNowOnUnits ( Powell ) ;
20872: LD_EXP 55
20876: PPUSH
20877: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20881: LD_ADDR_VAR 0 3
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_INT 3
20893: PUSH
20894: LD_INT 25
20896: PUSH
20897: LD_INT 1
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: PPUSH
20908: CALL_OW 72
20912: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20913: LD_ADDR_VAR 0 12
20917: PUSH
20918: LD_INT 22
20920: PUSH
20921: LD_INT 4
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: PUSH
20928: LD_INT 30
20930: PUSH
20931: LD_INT 32
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 58
20940: PUSH
20941: EMPTY
20942: LIST
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: LIST
20948: PPUSH
20949: CALL_OW 69
20953: ST_TO_ADDR
// for i = 1 to 6 do
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: DOUBLE
20960: LD_INT 1
20962: DEC
20963: ST_TO_ADDR
20964: LD_INT 6
20966: PUSH
20967: FOR_TO
20968: IFFALSE 21109
// begin if IsInUnit ( tmp [ i ] ) then
20970: LD_VAR 0 3
20974: PUSH
20975: LD_VAR 0 1
20979: ARRAY
20980: PPUSH
20981: CALL_OW 310
20985: IFFALSE 21002
// ComExitBuilding ( tmp [ i ] ) ;
20987: LD_VAR 0 3
20991: PUSH
20992: LD_VAR 0 1
20996: ARRAY
20997: PPUSH
20998: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21002: LD_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: ARRAY
21012: PPUSH
21013: LD_VAR 0 10
21017: PUSH
21018: LD_INT 1
21020: ARRAY
21021: PPUSH
21022: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21026: LD_VAR 0 3
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: PPUSH
21037: LD_INT 1
21039: PPUSH
21040: CALL_OW 183
// if emp_towers then
21044: LD_VAR 0 12
21048: IFFALSE 21107
// begin AddComExitBuilding ( tmp [ i ] ) ;
21050: LD_VAR 0 3
21054: PUSH
21055: LD_VAR 0 1
21059: ARRAY
21060: PPUSH
21061: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21065: LD_VAR 0 3
21069: PUSH
21070: LD_VAR 0 1
21074: ARRAY
21075: PPUSH
21076: LD_VAR 0 12
21080: PUSH
21081: LD_INT 1
21083: ARRAY
21084: PPUSH
21085: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21089: LD_ADDR_VAR 0 12
21093: PUSH
21094: LD_VAR 0 12
21098: PPUSH
21099: LD_INT 1
21101: PPUSH
21102: CALL_OW 3
21106: ST_TO_ADDR
// end ; end ;
21107: GO 20967
21109: POP
21110: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_EXP 18
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PUSH
21125: LD_EXP 18
21129: PUSH
21130: LD_INT 2
21132: ARRAY
21133: ADD
21134: PPUSH
21135: LD_INT 26
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PPUSH
21145: CALL_OW 72
21149: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21150: LD_ADDR_VAR 0 1
21154: PUSH
21155: LD_EXP 18
21159: PUSH
21160: LD_INT 2
21162: ARRAY
21163: PUSH
21164: FOR_IN
21165: IFFALSE 21183
// ComTurnUnit ( i , Powell ) ;
21167: LD_VAR 0 1
21171: PPUSH
21172: LD_EXP 55
21176: PPUSH
21177: CALL_OW 119
21181: GO 21164
21183: POP
21184: POP
// Say ( Powell , D5-Pow-1 ) ;
21185: LD_EXP 55
21189: PPUSH
21190: LD_STRING D5-Pow-1
21192: PPUSH
21193: CALL_OW 88
// if tmp then
21197: LD_VAR 0 3
21201: IFFALSE 21219
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21203: LD_VAR 0 3
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: LD_STRING D5-Sol2-1
21214: PPUSH
21215: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21219: LD_EXP 55
21223: PPUSH
21224: LD_STRING D5-Pow-2
21226: PPUSH
21227: CALL_OW 88
// if tmp > 1 then
21231: LD_VAR 0 3
21235: PUSH
21236: LD_INT 1
21238: GREATER
21239: IFFALSE 21257
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 2
21248: ARRAY
21249: PPUSH
21250: LD_STRING D5-Sol2-2
21252: PPUSH
21253: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21257: LD_EXP 55
21261: PPUSH
21262: LD_STRING D5-Pow-3
21264: PPUSH
21265: CALL_OW 88
// wait ( 0 0$1 ) ;
21269: LD_INT 35
21271: PPUSH
21272: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21276: LD_ADDR_VAR 0 3
21280: PUSH
21281: LD_EXP 18
21285: PUSH
21286: LD_INT 1
21288: ARRAY
21289: PUSH
21290: LD_EXP 18
21294: PUSH
21295: LD_INT 2
21297: ARRAY
21298: UNION
21299: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21300: LD_VAR 0 3
21304: PPUSH
21305: LD_INT 80
21307: PPUSH
21308: LD_INT 67
21310: PPUSH
21311: CALL_OW 114
// wait ( 0 0$2 ) ;
21315: LD_INT 70
21317: PPUSH
21318: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21322: LD_INT 79
21324: PPUSH
21325: LD_INT 72
21327: PPUSH
21328: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21332: LD_INT 35
21334: PPUSH
21335: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21339: LD_VAR 0 3
21343: PPUSH
21344: LD_INT 3
21346: PUSH
21347: LD_INT 24
21349: PUSH
21350: LD_INT 1000
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PPUSH
21361: CALL_OW 72
21365: IFFALSE 21332
// Say ( Powell , D5a-Pow-1 ) ;
21367: LD_EXP 55
21371: PPUSH
21372: LD_STRING D5a-Pow-1
21374: PPUSH
21375: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21379: LD_EXP 55
21383: PPUSH
21384: LD_STRING D5a-Pow-1a
21386: PPUSH
21387: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21391: LD_INT 10
21393: PPUSH
21394: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21398: LD_EXP 55
21402: PPUSH
21403: LD_STRING D5a-Pow-1b
21405: PPUSH
21406: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21410: LD_EXP 55
21414: PPUSH
21415: LD_STRING D5a-Pow-1c
21417: PPUSH
21418: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21422: LD_EXP 55
21426: PPUSH
21427: LD_STRING D5a-Pow-1d
21429: PPUSH
21430: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21434: LD_INT 35
21436: PPUSH
21437: CALL_OW 67
// if not HasTask ( tmp ) then
21441: LD_VAR 0 3
21445: PPUSH
21446: CALL_OW 314
21450: NOT
21451: IFFALSE 21468
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21453: LD_VAR 0 3
21457: PPUSH
21458: LD_INT 80
21460: PPUSH
21461: LD_INT 67
21463: PPUSH
21464: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21468: LD_VAR 0 3
21472: PPUSH
21473: LD_INT 24
21475: PUSH
21476: LD_INT 1
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 72
21487: NOT
21488: IFFALSE 21434
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21490: LD_ADDR_VAR 0 3
21494: PUSH
21495: LD_INT 22
21497: PUSH
21498: LD_INT 4
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 92
21507: PUSH
21508: LD_INT 60
21510: PUSH
21511: LD_INT 93
21513: PUSH
21514: LD_INT 10
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: LD_INT 54
21528: PUSH
21529: EMPTY
21530: LIST
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: EMPTY
21537: LIST
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 69
21545: PUSH
21546: LD_EXP 55
21550: DIFF
21551: ST_TO_ADDR
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21590
// for i in tmp do
21558: LD_ADDR_VAR 0 1
21562: PUSH
21563: LD_VAR 0 3
21567: PUSH
21568: FOR_IN
21569: IFFALSE 21588
// ComMoveXY ( i , 36 , 67 ) ;
21571: LD_VAR 0 1
21575: PPUSH
21576: LD_INT 36
21578: PPUSH
21579: LD_INT 67
21581: PPUSH
21582: CALL_OW 111
21586: GO 21568
21588: POP
21589: POP
// wait ( 0 0$3 ) ;
21590: LD_INT 105
21592: PPUSH
21593: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21597: LD_VAR 0 11
21601: PPUSH
21602: LD_STRING D6-Sol3-1
21604: PPUSH
21605: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21609: LD_EXP 55
21613: PPUSH
21614: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21618: LD_EXP 55
21622: PPUSH
21623: LD_STRING D6-Pow-1
21625: PPUSH
21626: CALL_OW 88
// tmp := [ ] ;
21630: LD_ADDR_VAR 0 3
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// for i = 1 to 2 do
21637: LD_ADDR_VAR 0 1
21641: PUSH
21642: DOUBLE
21643: LD_INT 1
21645: DEC
21646: ST_TO_ADDR
21647: LD_INT 2
21649: PUSH
21650: FOR_TO
21651: IFFALSE 21765
// begin uc_side := 8 ;
21653: LD_ADDR_OWVAR 20
21657: PUSH
21658: LD_INT 8
21660: ST_TO_ADDR
// uc_nation := 2 ;
21661: LD_ADDR_OWVAR 21
21665: PUSH
21666: LD_INT 2
21668: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21669: LD_INT 14
21671: PPUSH
21672: LD_INT 3
21674: PPUSH
21675: LD_INT 2
21677: PPUSH
21678: LD_INT 29
21680: PPUSH
21681: LD_INT 100
21683: PPUSH
21684: CALL 70239 0 5
// veh := CreateVehicle ;
21688: LD_ADDR_VAR 0 13
21692: PUSH
21693: CALL_OW 45
21697: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21698: LD_VAR 0 13
21702: PPUSH
21703: LD_INT 4
21705: PPUSH
21706: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21710: LD_VAR 0 13
21714: PPUSH
21715: LD_INT 99
21717: PPUSH
21718: LD_INT 83
21720: PPUSH
21721: LD_INT 6
21723: PPUSH
21724: LD_INT 0
21726: PPUSH
21727: CALL_OW 50
// wait ( 3 ) ;
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 67
// Connect ( veh ) ;
21738: LD_VAR 0 13
21742: PPUSH
21743: CALL 73294 0 1
// tmp := tmp ^ veh ;
21747: LD_ADDR_VAR 0 3
21751: PUSH
21752: LD_VAR 0 3
21756: PUSH
21757: LD_VAR 0 13
21761: ADD
21762: ST_TO_ADDR
// end ;
21763: GO 21650
21765: POP
21766: POP
// wait ( 0 0$1 ) ;
21767: LD_INT 35
21769: PPUSH
21770: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21774: LD_INT 99
21776: PPUSH
21777: LD_INT 83
21779: PPUSH
21780: LD_INT 1
21782: PPUSH
21783: LD_INT 10
21785: PPUSH
21786: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21790: LD_INT 99
21792: PPUSH
21793: LD_INT 83
21795: PPUSH
21796: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21800: LD_VAR 0 11
21804: PPUSH
21805: LD_STRING D6-Sol3-2
21807: PPUSH
21808: CALL_OW 88
// async ;
21812: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21813: LD_EXP 55
21817: PPUSH
21818: LD_STRING D6-Pow-2
21820: PPUSH
21821: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21825: LD_VAR 0 3
21829: PUSH
21830: LD_INT 1
21832: ARRAY
21833: PPUSH
21834: LD_VAR 0 9
21838: PPUSH
21839: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 2
21850: ARRAY
21851: PPUSH
21852: LD_INT 22
21854: PUSH
21855: LD_INT 4
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 21
21864: PUSH
21865: LD_INT 3
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PPUSH
21876: CALL_OW 69
21880: PPUSH
21881: LD_VAR 0 3
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PPUSH
21890: CALL_OW 74
21894: PPUSH
21895: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21899: LD_EXP 55
21903: PPUSH
21904: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21908: LD_INT 99
21910: PPUSH
21911: LD_INT 83
21913: PPUSH
21914: LD_INT 1
21916: PPUSH
21917: CALL_OW 331
// repeat wait ( 4 ) ;
21921: LD_INT 4
21923: PPUSH
21924: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21928: LD_VAR 0 3
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PPUSH
21937: CALL_OW 256
21941: PUSH
21942: LD_INT 1000
21944: LESS
21945: IFFALSE 21963
// SetLives ( tmp [ 1 ] , 1000 ) ;
21947: LD_VAR 0 3
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PPUSH
21956: LD_INT 1000
21958: PPUSH
21959: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21963: LD_INT 22
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 30
21975: PUSH
21976: LD_INT 3
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PPUSH
21987: CALL_OW 69
21991: PUSH
21992: LD_INT 0
21994: EQUAL
21995: IFFALSE 21921
// sync ;
21997: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21998: LD_EXP 55
22002: PPUSH
22003: LD_STRING D6a-Pow-1
22005: PPUSH
22006: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22010: LD_VAR 0 11
22014: PPUSH
22015: LD_STRING D6a-Sol3-1
22017: PPUSH
22018: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22022: LD_EXP 55
22026: PPUSH
22027: LD_STRING D6a-Pow-2
22029: PPUSH
22030: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22034: LD_VAR 0 11
22038: PPUSH
22039: LD_STRING D6a-Sol3-2
22041: PPUSH
22042: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22046: LD_EXP 55
22050: PPUSH
22051: LD_STRING D6a-Pow-3
22053: PPUSH
22054: CALL_OW 88
// powellCenterCameraMode := true ;
22058: LD_ADDR_EXP 20
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22066: LD_ADDR_VAR 0 1
22070: PUSH
22071: LD_INT 22
22073: PUSH
22074: LD_INT 8
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 25
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 69
22099: PUSH
22100: FOR_IN
22101: IFFALSE 22156
// begin SetTag ( i , 1 ) ;
22103: LD_VAR 0 1
22107: PPUSH
22108: LD_INT 1
22110: PPUSH
22111: CALL_OW 109
// ComExitBuilding ( i ) ;
22115: LD_VAR 0 1
22119: PPUSH
22120: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22124: LD_VAR 0 1
22128: PPUSH
22129: LD_INT 35
22131: PPUSH
22132: LD_INT 6
22134: PPUSH
22135: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22139: LD_VAR 0 1
22143: PPUSH
22144: LD_INT 53
22146: PPUSH
22147: LD_INT 4
22149: PPUSH
22150: CALL_OW 171
// end ;
22154: GO 22100
22156: POP
22157: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22158: LD_ADDR_VAR 0 3
22162: PUSH
22163: LD_INT 22
22165: PUSH
22166: LD_INT 4
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: PUSH
22173: LD_INT 21
22175: PUSH
22176: LD_INT 2
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 3
22185: PUSH
22186: LD_INT 34
22188: PUSH
22189: LD_INT 12
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: PPUSH
22205: CALL_OW 69
22209: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22210: LD_EXP 55
22214: PPUSH
22215: LD_VAR 0 3
22219: PPUSH
22220: LD_EXP 55
22224: PPUSH
22225: CALL_OW 74
22229: PPUSH
22230: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22234: LD_EXP 55
22238: PPUSH
22239: LD_INT 100
22241: PPUSH
22242: LD_INT 88
22244: PPUSH
22245: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22249: LD_EXP 55
22253: PPUSH
22254: LD_INT 100
22256: PPUSH
22257: LD_INT 75
22259: PPUSH
22260: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22264: LD_EXP 55
22268: PPUSH
22269: LD_INT 88
22271: PPUSH
22272: LD_INT 53
22274: PPUSH
22275: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22279: LD_INT 8
22281: PPUSH
22282: LD_EXP 55
22286: PPUSH
22287: CALL_OW 471
// repeat wait ( 3 ) ;
22291: LD_INT 3
22293: PPUSH
22294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22298: LD_INT 22
22300: PUSH
22301: LD_INT 4
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: LD_INT 92
22310: PUSH
22311: LD_INT 100
22313: PUSH
22314: LD_INT 75
22316: PUSH
22317: LD_INT 6
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 69
22334: IFFALSE 22291
// async ;
22336: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22337: LD_EXP 55
22341: PPUSH
22342: LD_STRING D6b-Pow-1
22344: PPUSH
22345: CALL_OW 88
// repeat wait ( 3 ) ;
22349: LD_INT 3
22351: PPUSH
22352: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22356: LD_EXP 55
22360: PPUSH
22361: CALL_OW 310
22365: PPUSH
22366: CALL_OW 256
22370: PUSH
22371: LD_INT 1000
22373: LESS
22374: IFFALSE 22393
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22376: LD_EXP 55
22380: PPUSH
22381: CALL_OW 310
22385: PPUSH
22386: LD_INT 1000
22388: PPUSH
22389: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22393: LD_EXP 55
22397: PPUSH
22398: CALL_OW 256
22402: PUSH
22403: LD_INT 1000
22405: LESS
22406: IFFALSE 22420
// SetLives ( Powell , 1000 ) ;
22408: LD_EXP 55
22412: PPUSH
22413: LD_INT 1000
22415: PPUSH
22416: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22420: LD_EXP 55
22424: PPUSH
22425: LD_EXP 60
22429: PPUSH
22430: CALL_OW 296
22434: PUSH
22435: LD_INT 5
22437: LESS
22438: PUSH
22439: LD_EXP 55
22443: PPUSH
22444: CALL_OW 310
22448: PPUSH
22449: LD_EXP 60
22453: PPUSH
22454: CALL_OW 296
22458: PUSH
22459: LD_INT 5
22461: LESS
22462: OR
22463: IFFALSE 22482
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22465: LD_EXP 55
22469: PPUSH
22470: CALL_OW 310
22474: PPUSH
22475: LD_INT 100
22477: PPUSH
22478: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22482: LD_EXP 55
22486: PPUSH
22487: CALL_OW 310
22491: NOT
22492: IFFALSE 22349
// game_speed := 4 ;
22494: LD_ADDR_OWVAR 65
22498: PUSH
22499: LD_INT 4
22501: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22502: LD_EXP 55
22506: PPUSH
22507: LD_STRING D6b-Pow-1a
22509: PPUSH
22510: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22514: LD_EXP 55
22518: PPUSH
22519: LD_EXP 60
22523: PPUSH
22524: CALL_OW 180
// sync ;
22528: SYNC
// repeat wait ( 0 0$1 ) ;
22529: LD_INT 35
22531: PPUSH
22532: CALL_OW 67
// until IsInUnit ( Powell ) ;
22536: LD_EXP 55
22540: PPUSH
22541: CALL_OW 310
22545: IFFALSE 22529
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22547: LD_INT 8
22549: PPUSH
22550: LD_EXP 55
22554: PPUSH
22555: CALL_OW 310
22559: PPUSH
22560: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22564: LD_EXP 55
22568: PPUSH
22569: LD_INT 91
22571: PPUSH
22572: LD_INT 44
22574: PPUSH
22575: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22579: LD_EXP 55
22583: PPUSH
22584: LD_INT 96
22586: PPUSH
22587: LD_INT 44
22589: PPUSH
22590: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22594: LD_EXP 55
22598: PPUSH
22599: LD_INT 96
22601: PPUSH
22602: LD_INT 41
22604: PPUSH
22605: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22609: LD_EXP 55
22613: PPUSH
22614: LD_INT 92
22616: PPUSH
22617: LD_INT 39
22619: PPUSH
22620: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22624: LD_EXP 55
22628: PPUSH
22629: LD_INT 88
22631: PPUSH
22632: LD_INT 41
22634: PPUSH
22635: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22639: LD_EXP 55
22643: PPUSH
22644: LD_INT 91
22646: PPUSH
22647: LD_INT 44
22649: PPUSH
22650: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22654: LD_EXP 55
22658: PPUSH
22659: LD_INT 96
22661: PPUSH
22662: LD_INT 44
22664: PPUSH
22665: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22669: LD_EXP 55
22673: PPUSH
22674: LD_INT 96
22676: PPUSH
22677: LD_INT 41
22679: PPUSH
22680: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22684: LD_EXP 55
22688: PPUSH
22689: LD_INT 92
22691: PPUSH
22692: LD_INT 39
22694: PPUSH
22695: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22699: LD_EXP 55
22703: PPUSH
22704: LD_INT 88
22706: PPUSH
22707: LD_INT 41
22709: PPUSH
22710: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22714: LD_EXP 55
22718: PPUSH
22719: LD_INT 91
22721: PPUSH
22722: LD_INT 44
22724: PPUSH
22725: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22729: LD_EXP 55
22733: PPUSH
22734: LD_INT 93
22736: PPUSH
22737: LD_INT 39
22739: PPUSH
22740: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22744: LD_EXP 55
22748: PPUSH
22749: LD_INT 93
22751: PPUSH
22752: LD_INT 36
22754: PPUSH
22755: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22759: LD_INT 122
22761: PPUSH
22762: CALL_OW 67
// game_speed := 4 ;
22766: LD_ADDR_OWVAR 65
22770: PUSH
22771: LD_INT 4
22773: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22774: LD_EXP 55
22778: PPUSH
22779: LD_STRING D6b-Pow-1b
22781: PPUSH
22782: CALL_OW 88
// tmp := [ ] ;
22786: LD_ADDR_VAR 0 3
22790: PUSH
22791: EMPTY
22792: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22793: LD_ADDR_VAR 0 5
22797: PUSH
22798: LD_INT 78
22800: PUSH
22801: LD_INT 47
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 106
22810: PUSH
22811: LD_INT 53
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22822: LD_ADDR_VAR 0 1
22826: PUSH
22827: LD_INT 22
22829: PUSH
22830: LD_INT 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 21
22839: PUSH
22840: LD_INT 3
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 92
22849: PUSH
22850: LD_INT 90
22852: PUSH
22853: LD_INT 52
22855: PUSH
22856: LD_INT 12
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 69
22874: PUSH
22875: FOR_IN
22876: IFFALSE 22901
// tmp := tmp ^ UnitsInside ( i ) ;
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 313
22897: ADD
22898: ST_TO_ADDR
22899: GO 22875
22901: POP
22902: POP
// for i in tmp do
22903: LD_ADDR_VAR 0 1
22907: PUSH
22908: LD_VAR 0 3
22912: PUSH
22913: FOR_IN
22914: IFFALSE 23076
// begin dist := 9999 ;
22916: LD_ADDR_VAR 0 8
22920: PUSH
22921: LD_INT 9999
22923: ST_TO_ADDR
// _xy := [ ] ;
22924: LD_ADDR_VAR 0 7
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22931: LD_VAR 0 1
22935: PPUSH
22936: LD_INT 1
22938: PPUSH
22939: CALL_OW 109
// ComExitBuilding ( i ) ;
22943: LD_VAR 0 1
22947: PPUSH
22948: CALL_OW 122
// for j in xy do
22952: LD_ADDR_VAR 0 2
22956: PUSH
22957: LD_VAR 0 5
22961: PUSH
22962: FOR_IN
22963: IFFALSE 23045
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 2
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 297
22992: PUSH
22993: LD_VAR 0 8
22997: LESS
22998: IFFALSE 23043
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23000: LD_ADDR_VAR 0 8
23004: PUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: LD_VAR 0 2
23014: PUSH
23015: LD_INT 1
23017: ARRAY
23018: PPUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_INT 2
23026: ARRAY
23027: PPUSH
23028: CALL_OW 297
23032: ST_TO_ADDR
// _xy := j ;
23033: LD_ADDR_VAR 0 7
23037: PUSH
23038: LD_VAR 0 2
23042: ST_TO_ADDR
// end ;
23043: GO 22962
23045: POP
23046: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23047: LD_VAR 0 1
23051: PPUSH
23052: LD_VAR 0 7
23056: PUSH
23057: LD_INT 1
23059: ARRAY
23060: PPUSH
23061: LD_VAR 0 7
23065: PUSH
23066: LD_INT 2
23068: ARRAY
23069: PPUSH
23070: CALL_OW 171
// end ;
23074: GO 22913
23076: POP
23077: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23078: LD_ADDR_VAR 0 4
23082: PUSH
23083: LD_VAR 0 3
23087: PPUSH
23088: LD_INT 26
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 25
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 72
23116: ST_TO_ADDR
// if tmp2 < 2 then
23117: LD_VAR 0 4
23121: PUSH
23122: LD_INT 2
23124: LESS
23125: IFFALSE 23194
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23127: LD_ADDR_VAR 0 4
23131: PUSH
23132: LD_INT 22
23134: PUSH
23135: LD_INT 8
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PUSH
23142: LD_INT 26
23144: PUSH
23145: LD_INT 1
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 3
23154: PUSH
23155: LD_INT 25
23157: PUSH
23158: LD_INT 15
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: LIST
23173: PPUSH
23174: CALL_OW 69
23178: PUSH
23179: LD_EXP 57
23183: PUSH
23184: LD_EXP 58
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: DIFF
23193: ST_TO_ADDR
// if tmp2 then
23194: LD_VAR 0 4
23198: IFFALSE 23216
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23200: LD_VAR 0 4
23204: PUSH
23205: LD_INT 1
23207: ARRAY
23208: PPUSH
23209: LD_STRING D6b-ArSol1-1
23211: PPUSH
23212: CALL_OW 88
// async ;
23216: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23217: LD_EXP 55
23221: PPUSH
23222: LD_STRING D6b-Pow-2
23224: PPUSH
23225: CALL_OW 88
// wait ( 0 0$1 ) ;
23229: LD_INT 35
23231: PPUSH
23232: CALL_OW 67
// if tmp2 > 1 then
23236: LD_VAR 0 4
23240: PUSH
23241: LD_INT 1
23243: GREATER
23244: IFFALSE 23262
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23246: LD_VAR 0 4
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: LD_STRING D6b-ArSol2-1
23257: PPUSH
23258: CALL_OW 88
// sync ;
23262: SYNC
// repeat wait ( 5 ) ;
23263: LD_INT 5
23265: PPUSH
23266: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23270: LD_INT 93
23272: PPUSH
23273: LD_INT 36
23275: PPUSH
23276: CALL_OW 428
23280: PPUSH
23281: CALL_OW 255
23285: PUSH
23286: LD_INT 4
23288: EQUAL
23289: IFFALSE 23263
// DialogueOn ;
23291: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23295: LD_INT 10
23297: PPUSH
23298: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23302: LD_EXP 55
23306: PPUSH
23307: LD_STRING D6b-Pow-2a
23309: PPUSH
23310: CALL_OW 88
// DialogueOff ;
23314: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23318: LD_EXP 55
23322: PPUSH
23323: CALL_OW 310
23327: PPUSH
23328: LD_INT 332
23330: PPUSH
23331: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23335: LD_INT 93
23337: PPUSH
23338: LD_INT 35
23340: PPUSH
23341: LD_INT 1
23343: PPUSH
23344: LD_INT 6
23346: NEG
23347: PPUSH
23348: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23352: LD_INT 35
23354: PPUSH
23355: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23359: LD_INT 332
23361: PPUSH
23362: CALL_OW 256
23366: PUSH
23367: LD_INT 1000
23369: LESS
23370: PUSH
23371: LD_INT 332
23373: PPUSH
23374: CALL_OW 300
23378: AND
23379: IFFALSE 23391
// SetLives ( kozlov_fac , 0 ) ;
23381: LD_INT 332
23383: PPUSH
23384: LD_INT 0
23386: PPUSH
23387: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23391: LD_INT 332
23393: PPUSH
23394: CALL_OW 301
23398: PUSH
23399: LD_EXP 55
23403: PPUSH
23404: CALL_OW 301
23408: OR
23409: IFFALSE 23352
// game_speed := 4 ;
23411: LD_ADDR_OWVAR 65
23415: PUSH
23416: LD_INT 4
23418: ST_TO_ADDR
// powellCenterCameraMode := false ;
23419: LD_ADDR_EXP 20
23423: PUSH
23424: LD_INT 0
23426: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23427: LD_ADDR_VAR 0 1
23431: PUSH
23432: LD_VAR 0 3
23436: PUSH
23437: LD_INT 22
23439: PUSH
23440: LD_INT 8
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 25
23449: PUSH
23450: LD_INT 2
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PPUSH
23461: CALL_OW 69
23465: UNION
23466: PUSH
23467: FOR_IN
23468: IFFALSE 23484
// SetTag ( i , 0 ) ;
23470: LD_VAR 0 1
23474: PPUSH
23475: LD_INT 0
23477: PPUSH
23478: CALL_OW 109
23482: GO 23467
23484: POP
23485: POP
// wait ( 0 0$3 ) ;
23486: LD_INT 105
23488: PPUSH
23489: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23493: LD_INT 93
23495: PPUSH
23496: LD_INT 35
23498: PPUSH
23499: LD_INT 1
23501: PPUSH
23502: CALL_OW 331
// DialogueOn ;
23506: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23510: LD_VAR 0 11
23514: PPUSH
23515: LD_STRING D6c-Sol3-1
23517: PPUSH
23518: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23522: LD_INT 10
23524: PPUSH
23525: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23529: LD_EXP 36
23533: PPUSH
23534: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23538: LD_EXP 36
23542: PPUSH
23543: LD_STRING D6c-JMM-1
23545: PPUSH
23546: CALL_OW 88
// if Cyrus then
23550: LD_EXP 42
23554: IFFALSE 23568
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23556: LD_EXP 42
23560: PPUSH
23561: LD_STRING D6c-Cyrus-1
23563: PPUSH
23564: CALL_OW 88
// if Bobby then
23568: LD_EXP 41
23572: IFFALSE 23586
// Say ( Bobby , D6c-Bobby-1 ) ;
23574: LD_EXP 41
23578: PPUSH
23579: LD_STRING D6c-Bobby-1
23581: PPUSH
23582: CALL_OW 88
// if Cornel then
23586: LD_EXP 47
23590: IFFALSE 23604
// Say ( Cornel , D6c-Corn-1 ) ;
23592: LD_EXP 47
23596: PPUSH
23597: LD_STRING D6c-Corn-1
23599: PPUSH
23600: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23604: LD_ADDR_VAR 0 4
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 22
23624: PUSH
23625: LD_INT 4
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 26
23639: PUSH
23640: LD_INT 1
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 3
23649: PUSH
23650: LD_INT 25
23652: PUSH
23653: LD_INT 16
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 25
23662: PUSH
23663: LD_INT 12
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: LD_VAR 0 11
23689: PUSH
23690: LD_EXP 36
23694: UNION
23695: PUSH
23696: LD_EXP 56
23700: UNION
23701: PUSH
23702: EMPTY
23703: LIST
23704: DIFF
23705: ST_TO_ADDR
// if tmp2 then
23706: LD_VAR 0 4
23710: IFFALSE 23728
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23712: LD_VAR 0 4
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PPUSH
23721: LD_STRING D6c-Sol1-1
23723: PPUSH
23724: CALL_OW 88
// if Lisa then
23728: LD_EXP 39
23732: IFFALSE 23746
// Say ( Lisa , D6c-Lisa-1 ) ;
23734: LD_EXP 39
23738: PPUSH
23739: LD_STRING D6c-Lisa-1
23741: PPUSH
23742: CALL_OW 88
// if Gary then
23746: LD_EXP 48
23750: IFFALSE 23764
// Say ( Gary , D6c-Gary-1 ) ;
23752: LD_EXP 48
23756: PPUSH
23757: LD_STRING D6c-Gary-1
23759: PPUSH
23760: CALL_OW 88
// if Donaldson then
23764: LD_EXP 40
23768: IFFALSE 23782
// Say ( Donaldson , D6c-Don-1 ) ;
23770: LD_EXP 40
23774: PPUSH
23775: LD_STRING D6c-Don-1
23777: PPUSH
23778: CALL_OW 88
// if tmp2 > 1 then
23782: LD_VAR 0 4
23786: PUSH
23787: LD_INT 1
23789: GREATER
23790: IFFALSE 23808
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23792: LD_VAR 0 4
23796: PUSH
23797: LD_INT 2
23799: ARRAY
23800: PPUSH
23801: LD_STRING D6c-Sol2-1
23803: PPUSH
23804: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23808: LD_VAR 0 11
23812: PPUSH
23813: LD_STRING D6c-Sol3-2
23815: PPUSH
23816: CALL_OW 88
// dwait ( 0 0$1 ) ;
23820: LD_INT 35
23822: PPUSH
23823: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23827: LD_EXP 36
23831: PPUSH
23832: LD_STRING D6c-JMM-2
23834: PPUSH
23835: CALL_OW 88
// DialogueOff ;
23839: CALL_OW 7
// Video ( false ) ;
23843: LD_INT 0
23845: PPUSH
23846: CALL 105956 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23850: LD_INT 22
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 69
23864: PPUSH
23865: LD_INT 1
23867: PPUSH
23868: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23872: LD_INT 4
23874: PPUSH
23875: LD_INT 4
23877: PPUSH
23878: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23882: LD_ADDR_VAR 0 1
23886: PUSH
23887: LD_INT 4
23889: PPUSH
23890: LD_INT 1
23892: PPUSH
23893: LD_INT 2
23895: PPUSH
23896: CALL 63551 0 3
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23939
// if GetTech ( i , 1 ) <> state_researched then
23904: LD_VAR 0 1
23908: PPUSH
23909: LD_INT 1
23911: PPUSH
23912: CALL_OW 321
23916: PUSH
23917: LD_INT 2
23919: NONEQUAL
23920: IFFALSE 23937
// SetTech ( i , 1 , state_researched ) ;
23922: LD_VAR 0 1
23926: PPUSH
23927: LD_INT 1
23929: PPUSH
23930: LD_INT 2
23932: PPUSH
23933: CALL_OW 322
23937: GO 23901
23939: POP
23940: POP
// missionStage := 6 ;
23941: LD_ADDR_EXP 15
23945: PUSH
23946: LD_INT 6
23948: ST_TO_ADDR
// activeAttacks := true ;
23949: LD_ADDR_EXP 16
23953: PUSH
23954: LD_INT 1
23956: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23957: LD_STRING M2
23959: PPUSH
23960: CALL_OW 337
// SaveForQuickRestart ;
23964: CALL_OW 22
// wait ( 0 0$40 ) ;
23968: LD_INT 1400
23970: PPUSH
23971: CALL_OW 67
// DialogueOn ;
23975: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23979: LD_EXP 59
23983: PPUSH
23984: LD_STRING D7-Friend-1
23986: PPUSH
23987: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23991: LD_EXP 36
23995: PPUSH
23996: LD_STRING D7-JMM-1
23998: PPUSH
23999: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24003: LD_EXP 59
24007: PPUSH
24008: LD_STRING D7-Friend-2
24010: PPUSH
24011: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24015: LD_EXP 36
24019: PPUSH
24020: LD_STRING D7-JMM-2
24022: PPUSH
24023: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24027: LD_EXP 59
24031: PPUSH
24032: LD_STRING D7-Friend-3
24034: PPUSH
24035: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24039: LD_EXP 36
24043: PPUSH
24044: LD_STRING D7-JMM-3
24046: PPUSH
24047: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24051: LD_EXP 59
24055: PPUSH
24056: LD_STRING D7-Friend-4
24058: PPUSH
24059: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24063: LD_EXP 36
24067: PPUSH
24068: LD_STRING D7-JMM-4
24070: PPUSH
24071: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24075: LD_EXP 59
24079: PPUSH
24080: LD_STRING D7-Friend-5
24082: PPUSH
24083: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24087: LD_EXP 36
24091: PPUSH
24092: LD_STRING D7-JMM-5
24094: PPUSH
24095: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24099: LD_EXP 59
24103: PPUSH
24104: LD_STRING D7-Friend-6
24106: PPUSH
24107: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24111: LD_EXP 36
24115: PPUSH
24116: LD_STRING D7-JMM-6
24118: PPUSH
24119: CALL_OW 88
// DialogueOff ;
24123: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24127: LD_STRING Mlegion
24129: PPUSH
24130: CALL_OW 337
// RebuildKozlovFactory ;
24134: CALL 4773 0 0
// end ;
24138: PPOPN 13
24140: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24141: LD_EXP 20
24145: PUSH
24146: LD_EXP 55
24150: PPUSH
24151: CALL_OW 300
24155: AND
24156: IFFALSE 24198
24158: GO 24160
24160: DISABLE
// begin enable ;
24161: ENABLE
// if IsInUnit ( Powell ) then
24162: LD_EXP 55
24166: PPUSH
24167: CALL_OW 310
24171: IFFALSE 24189
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24173: LD_EXP 55
24177: PPUSH
24178: CALL_OW 310
24182: PPUSH
24183: CALL_OW 85
24187: GO 24198
// CenterOnUnits ( Powell ) ;
24189: LD_EXP 55
24193: PPUSH
24194: CALL_OW 85
// end ;
24198: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24199: LD_INT 22
24201: PUSH
24202: LD_INT 8
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 34
24211: PUSH
24212: LD_INT 48
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PPUSH
24223: CALL_OW 69
24227: IFFALSE 24490
24229: GO 24231
24231: DISABLE
24232: LD_INT 0
24234: PPUSH
24235: PPUSH
// begin if missionStage < 9 then
24236: LD_EXP 15
24240: PUSH
24241: LD_INT 9
24243: LESS
24244: IFFALSE 24254
// missionStage := 9 ;
24246: LD_ADDR_EXP 15
24250: PUSH
24251: LD_INT 9
24253: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24254: LD_ADDR_VAR 0 1
24258: PUSH
24259: LD_INT 22
24261: PUSH
24262: LD_INT 8
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 34
24271: PUSH
24272: LD_INT 48
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PPUSH
24283: CALL_OW 69
24287: PUSH
24288: LD_INT 1
24290: ARRAY
24291: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24292: LD_INT 175
24294: PPUSH
24295: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24299: LD_EXP 12
24303: PUSH
24304: LD_EXP 3
24308: PUSH
24309: LD_INT 0
24311: PUSH
24312: LD_INT 2
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: IN
24319: OR
24320: IFFALSE 24343
// target := [ 68 , 108 , 1 ] else
24322: LD_ADDR_VAR 0 2
24326: PUSH
24327: LD_INT 68
24329: PUSH
24330: LD_INT 108
24332: PUSH
24333: LD_INT 1
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: ST_TO_ADDR
24341: GO 24362
// target := [ 181 , 88 , 2 ] ;
24343: LD_ADDR_VAR 0 2
24347: PUSH
24348: LD_INT 181
24350: PUSH
24351: LD_INT 88
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24362: LD_VAR 0 1
24366: PPUSH
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: PPUSH
24376: LD_VAR 0 2
24380: PUSH
24381: LD_INT 2
24383: ARRAY
24384: PPUSH
24385: CALL_OW 176
// if target [ 3 ] = 1 then
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 3
24396: ARRAY
24397: PUSH
24398: LD_INT 1
24400: EQUAL
24401: IFFALSE 24417
// SayRadio ( Kurt , D12-Kurt-1 ) else
24403: LD_EXP 57
24407: PPUSH
24408: LD_STRING D12-Kurt-1
24410: PPUSH
24411: CALL_OW 94
24415: GO 24441
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24417: LD_EXP 57
24421: PPUSH
24422: LD_STRING D12a-Kurt-1
24424: PPUSH
24425: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24429: LD_EXP 71
24433: PPUSH
24434: LD_STRING D12a-Roth-1
24436: PPUSH
24437: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24441: LD_INT 350
24443: PPUSH
24444: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24448: LD_VAR 0 1
24452: PPUSH
24453: LD_INT 22
24455: PUSH
24456: LD_INT 8
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 3
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 69
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 228
// end ;
24490: PPOPN 2
24492: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24493: LD_INT 22
24495: PUSH
24496: LD_INT 8
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: PUSH
24503: LD_INT 21
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 23
24515: PUSH
24516: LD_INT 2
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: EMPTY
24524: LIST
24525: LIST
24526: LIST
24527: PPUSH
24528: CALL_OW 69
24532: PUSH
24533: LD_INT 8
24535: PUSH
24536: LD_INT 7
24538: PUSH
24539: LD_INT 6
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: LIST
24546: PUSH
24547: LD_OWVAR 67
24551: ARRAY
24552: LESSEQUAL
24553: PUSH
24554: LD_INT 22
24556: PUSH
24557: LD_INT 8
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 34
24566: PUSH
24567: LD_INT 48
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PPUSH
24578: CALL_OW 69
24582: NOT
24583: AND
24584: PUSH
24585: LD_EXP 57
24589: PPUSH
24590: CALL_OW 302
24594: AND
24595: IFFALSE 24912
24597: GO 24599
24599: DISABLE
// begin DialogueOn ;
24600: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24604: LD_EXP 36
24608: PPUSH
24609: LD_STRING D13-JMM-1
24611: PPUSH
24612: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24616: LD_EXP 57
24620: PPUSH
24621: LD_STRING D13-Kurt-1
24623: PPUSH
24624: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24628: LD_EXP 36
24632: PPUSH
24633: LD_STRING D13-JMM-2
24635: PPUSH
24636: CALL_OW 88
// if FakeInfo then
24640: LD_EXP 12
24644: IFFALSE 24664
// begin Say ( Kurt , D13-Kurt-2 ) ;
24646: LD_EXP 57
24650: PPUSH
24651: LD_STRING D13-Kurt-2
24653: PPUSH
24654: CALL_OW 88
// DialogueOff ;
24658: CALL_OW 7
// exit ;
24662: GO 24912
// end ; if not KurtStatus then
24664: LD_EXP 3
24668: NOT
24669: IFFALSE 24685
// Say ( Kurt , D13-Kurt-2b ) else
24671: LD_EXP 57
24675: PPUSH
24676: LD_STRING D13-Kurt-2b
24678: PPUSH
24679: CALL_OW 88
24683: GO 24697
// Say ( Kurt , D13-Kurt-2a ) ;
24685: LD_EXP 57
24689: PPUSH
24690: LD_STRING D13-Kurt-2a
24692: PPUSH
24693: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24697: LD_EXP 57
24701: PPUSH
24702: LD_STRING D13-Kurt-2a
24704: PPUSH
24705: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24709: LD_EXP 36
24713: PPUSH
24714: LD_STRING D13-JMM-3
24716: PPUSH
24717: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24721: LD_EXP 57
24725: PPUSH
24726: LD_STRING D13-Kurt-3
24728: PPUSH
24729: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24733: LD_EXP 36
24737: PPUSH
24738: LD_STRING D13-JMM-4
24740: PPUSH
24741: CALL_OW 88
// DialogueOff ;
24745: CALL_OW 7
// MC_Kill ( 3 ) ;
24749: LD_INT 3
24751: PPUSH
24752: CALL 34018 0 1
// KillUnit ( Kozlov ) ;
24756: LD_EXP 58
24760: PPUSH
24761: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24765: LD_INT 22
24767: PUSH
24768: LD_INT 8
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 21
24777: PUSH
24778: LD_INT 3
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 23
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 69
24815: PUSH
24816: LD_INT 1
24818: ARRAY
24819: PPUSH
24820: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24824: LD_INT 8
24826: PPUSH
24827: LD_INT 1
24829: PPUSH
24830: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24834: LD_INT 22
24836: PUSH
24837: LD_INT 8
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 69
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24856: LD_INT 8
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_INT 1
24867: PPUSH
24868: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24872: LD_EXP 59
24876: PPUSH
24877: LD_INT 37
24879: PPUSH
24880: LD_INT 1
24882: PPUSH
24883: LD_INT 0
24885: PPUSH
24886: CALL_OW 48
// wait ( 0 0$1 ) ;
24890: LD_INT 35
24892: PPUSH
24893: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24897: LD_EXP 59
24901: PPUSH
24902: LD_INT 60
24904: PPUSH
24905: LD_INT 95
24907: PPUSH
24908: CALL_OW 111
// end ;
24912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24913: LD_INT 22
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 21
24925: PUSH
24926: LD_INT 1
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PPUSH
24937: CALL_OW 69
24941: PUSH
24942: LD_INT 0
24944: EQUAL
24945: IFFALSE 24965
24947: GO 24949
24949: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24950: LD_STRING MlegionOut
24952: PPUSH
24953: CALL_OW 337
// legionDestroyed := true ;
24957: LD_ADDR_EXP 22
24961: PUSH
24962: LD_INT 1
24964: ST_TO_ADDR
// end ;
24965: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24966: LD_INT 1
24968: PPUSH
24969: LD_EXP 59
24973: PPUSH
24974: CALL_OW 292
24978: IFFALSE 25278
24980: GO 24982
24982: DISABLE
24983: LD_INT 0
24985: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24986: LD_EXP 59
24990: PPUSH
24991: CALL_OW 87
// DialogueOn ;
24995: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24999: LD_EXP 36
25003: PPUSH
25004: LD_STRING D14-JMM-1
25006: PPUSH
25007: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25011: LD_EXP 59
25015: PPUSH
25016: LD_STRING D14-Friend-1
25018: PPUSH
25019: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25023: LD_EXP 36
25027: PPUSH
25028: LD_STRING D14-JMM-2
25030: PPUSH
25031: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25035: LD_EXP 59
25039: PPUSH
25040: LD_STRING D14-Friend-2
25042: PPUSH
25043: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25047: LD_EXP 36
25051: PPUSH
25052: LD_STRING D14-JMM-3
25054: PPUSH
25055: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25059: LD_EXP 59
25063: PPUSH
25064: LD_STRING D14-Friend-3
25066: PPUSH
25067: CALL_OW 88
// DialogueOff ;
25071: CALL_OW 7
// dec = Query ( Q14 ) ;
25075: LD_ADDR_VAR 0 1
25079: PUSH
25080: LD_STRING Q14
25082: PPUSH
25083: CALL_OW 97
25087: ST_TO_ADDR
// if dec = 1 then
25088: LD_VAR 0 1
25092: PUSH
25093: LD_INT 1
25095: EQUAL
25096: IFFALSE 25130
// begin DialogueOn ;
25098: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25102: LD_EXP 36
25106: PPUSH
25107: LD_STRING D14a-JMM-1
25109: PPUSH
25110: CALL_OW 88
// DialogueOff ;
25114: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25118: LD_EXP 59
25122: PPUSH
25123: LD_INT 1
25125: PPUSH
25126: CALL_OW 235
// end ; if dec = 2 then
25130: LD_VAR 0 1
25134: PUSH
25135: LD_INT 2
25137: EQUAL
25138: IFFALSE 25184
// begin DialogueOn ;
25140: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25144: LD_EXP 36
25148: PPUSH
25149: LD_STRING D14b-JMM-1
25151: PPUSH
25152: CALL_OW 88
// DialogueOff ;
25156: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25160: LD_EXP 59
25164: PPUSH
25165: LD_INT 9
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 111
// AddComHold ( Friend ) ;
25175: LD_EXP 59
25179: PPUSH
25180: CALL_OW 200
// end ; if dec = 3 then
25184: LD_VAR 0 1
25188: PUSH
25189: LD_INT 3
25191: EQUAL
25192: IFFALSE 25278
// begin DialogueOn ;
25194: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25198: LD_EXP 36
25202: PPUSH
25203: LD_STRING D14c-JMM-1
25205: PPUSH
25206: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25210: LD_EXP 59
25214: PPUSH
25215: LD_STRING D14c-Friend-1
25217: PPUSH
25218: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25222: LD_EXP 36
25226: PPUSH
25227: LD_STRING D14c-JMM-2
25229: PPUSH
25230: CALL_OW 88
// DialogueOff ;
25234: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: LD_INT 2
25246: PPUSH
25247: LD_INT 1
25249: PPUSH
25250: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25254: LD_EXP 59
25258: PPUSH
25259: LD_INT 9
25261: PPUSH
25262: LD_INT 2
25264: PPUSH
25265: CALL_OW 111
// AddComHold ( Friend ) ;
25269: LD_EXP 59
25273: PPUSH
25274: CALL_OW 200
// end ; end ;
25278: PPOPN 1
25280: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25281: LD_INT 9
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: CALL_OW 428
25291: PUSH
25292: LD_EXP 59
25296: EQUAL
25297: PUSH
25298: LD_EXP 59
25302: PPUSH
25303: CALL_OW 255
25307: PUSH
25308: LD_INT 8
25310: EQUAL
25311: AND
25312: IFFALSE 25326
25314: GO 25316
25316: DISABLE
// RemoveUnit ( Friend ) ;
25317: LD_EXP 59
25321: PPUSH
25322: CALL_OW 64
25326: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25327: LD_EXP 14
25331: PUSH
25332: LD_INT 31500
25334: GREATEREQUAL
25335: PUSH
25336: LD_EXP 7
25340: AND
25341: PUSH
25342: LD_EXP 2
25346: AND
25347: IFFALSE 25777
25349: GO 25351
25351: DISABLE
25352: LD_INT 0
25354: PPUSH
25355: PPUSH
25356: PPUSH
// begin missionStage := 7 ;
25357: LD_ADDR_EXP 15
25361: PUSH
25362: LD_INT 7
25364: ST_TO_ADDR
// uc_side = 1 ;
25365: LD_ADDR_OWVAR 20
25369: PUSH
25370: LD_INT 1
25372: ST_TO_ADDR
// uc_nation = 1 ;
25373: LD_ADDR_OWVAR 21
25377: PUSH
25378: LD_INT 1
25380: ST_TO_ADDR
// for i = 1 to 5 do
25381: LD_ADDR_VAR 0 1
25385: PUSH
25386: DOUBLE
25387: LD_INT 1
25389: DEC
25390: ST_TO_ADDR
25391: LD_INT 5
25393: PUSH
25394: FOR_TO
25395: IFFALSE 25491
// begin vc_engine = 3 ;
25397: LD_ADDR_OWVAR 39
25401: PUSH
25402: LD_INT 3
25404: ST_TO_ADDR
// vc_control = 3 ;
25405: LD_ADDR_OWVAR 38
25409: PUSH
25410: LD_INT 3
25412: ST_TO_ADDR
// vc_chassis = 3 ;
25413: LD_ADDR_OWVAR 37
25417: PUSH
25418: LD_INT 3
25420: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25421: LD_ADDR_OWVAR 40
25425: PUSH
25426: LD_INT 5
25428: PUSH
25429: LD_INT 9
25431: PUSH
25432: LD_INT 7
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 1
25442: PPUSH
25443: LD_INT 3
25445: PPUSH
25446: CALL_OW 12
25450: ARRAY
25451: ST_TO_ADDR
// veh = CreateVehicle ;
25452: LD_ADDR_VAR 0 2
25456: PUSH
25457: CALL_OW 45
25461: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 1
25469: PPUSH
25470: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25474: LD_VAR 0 2
25478: PPUSH
25479: LD_INT 19
25481: PPUSH
25482: LD_INT 0
25484: PPUSH
25485: CALL_OW 49
// end ;
25489: GO 25394
25491: POP
25492: POP
// vc_engine = 3 ;
25493: LD_ADDR_OWVAR 39
25497: PUSH
25498: LD_INT 3
25500: ST_TO_ADDR
// vc_control = 1 ;
25501: LD_ADDR_OWVAR 38
25505: PUSH
25506: LD_INT 1
25508: ST_TO_ADDR
// vc_chassis = 3 ;
25509: LD_ADDR_OWVAR 37
25513: PUSH
25514: LD_INT 3
25516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25517: LD_ADDR_OWVAR 40
25521: PUSH
25522: LD_INT 5
25524: PUSH
25525: LD_INT 9
25527: PUSH
25528: LD_INT 7
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 1
25538: PPUSH
25539: LD_INT 3
25541: PPUSH
25542: CALL_OW 12
25546: ARRAY
25547: ST_TO_ADDR
// vehG = CreateVehicle ;
25548: LD_ADDR_VAR 0 3
25552: PUSH
25553: CALL_OW 45
25557: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25558: LD_VAR 0 3
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25570: LD_VAR 0 3
25574: PPUSH
25575: LD_INT 19
25577: PPUSH
25578: LD_INT 0
25580: PPUSH
25581: CALL_OW 49
// if JMMGirl = 1 then
25585: LD_EXP 7
25589: PUSH
25590: LD_INT 1
25592: EQUAL
25593: IFFALSE 25649
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25595: LD_ADDR_EXP 37
25599: PUSH
25600: LD_STRING Joan
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: LD_STRING 14_
25608: PPUSH
25609: CALL 63488 0 3
25613: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25614: LD_EXP 37
25618: PPUSH
25619: LD_VAR 0 3
25623: PPUSH
25624: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25628: LD_VAR 0 3
25632: PPUSH
25633: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25637: LD_EXP 37
25641: PPUSH
25642: LD_STRING D10BW-Joan-1
25644: PPUSH
25645: CALL_OW 94
// end ; if JMMGirl = 2 then
25649: LD_EXP 7
25653: PUSH
25654: LD_INT 2
25656: EQUAL
25657: IFFALSE 25713
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25659: LD_ADDR_EXP 39
25663: PUSH
25664: LD_STRING Lisa
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: LD_STRING 14_
25672: PPUSH
25673: CALL 63488 0 3
25677: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25678: LD_EXP 39
25682: PPUSH
25683: LD_VAR 0 3
25687: PPUSH
25688: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25692: LD_VAR 0 3
25696: PPUSH
25697: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25701: LD_EXP 39
25705: PPUSH
25706: LD_STRING D10BW-Lisa-1
25708: PPUSH
25709: CALL_OW 94
// end ; if JMMGirl = 3 then
25713: LD_EXP 7
25717: PUSH
25718: LD_INT 3
25720: EQUAL
25721: IFFALSE 25777
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25723: LD_ADDR_EXP 51
25727: PUSH
25728: LD_STRING Connie
25730: PPUSH
25731: LD_INT 1
25733: PPUSH
25734: LD_STRING 14_
25736: PPUSH
25737: CALL 63488 0 3
25741: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25742: LD_EXP 51
25746: PPUSH
25747: LD_VAR 0 3
25751: PPUSH
25752: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25756: LD_VAR 0 3
25760: PPUSH
25761: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25765: LD_EXP 39
25769: PPUSH
25770: LD_STRING D10BW-Con-1
25772: PPUSH
25773: CALL_OW 94
// end ; end ;
25777: PPOPN 3
25779: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25780: LD_EXP 14
25784: PUSH
25785: LD_INT 94500
25787: GREATEREQUAL
25788: IFFALSE 26200
25790: GO 25792
25792: DISABLE
25793: LD_INT 0
25795: PPUSH
25796: PPUSH
25797: PPUSH
// begin tmp := PrepareStevensSquad ;
25798: LD_ADDR_VAR 0 3
25802: PUSH
25803: CALL 2147 0 0
25807: ST_TO_ADDR
// if not tmp then
25808: LD_VAR 0 3
25812: NOT
25813: IFFALSE 25817
// exit ;
25815: GO 26200
// uc_side := 1 ;
25817: LD_ADDR_OWVAR 20
25821: PUSH
25822: LD_INT 1
25824: ST_TO_ADDR
// uc_nation := 1 ;
25825: LD_ADDR_OWVAR 21
25829: PUSH
25830: LD_INT 1
25832: ST_TO_ADDR
// for i in tmp do
25833: LD_ADDR_VAR 0 1
25837: PUSH
25838: LD_VAR 0 3
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25941
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25846: LD_INT 3
25848: PPUSH
25849: LD_INT 3
25851: PPUSH
25852: LD_INT 1
25854: PPUSH
25855: LD_INT 5
25857: PUSH
25858: LD_INT 9
25860: PUSH
25861: LD_INT 7
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_INT 3
25874: PPUSH
25875: CALL_OW 12
25879: ARRAY
25880: PPUSH
25881: LD_INT 40
25883: PPUSH
25884: CALL 70239 0 5
// veh := CreateVehicle ;
25888: LD_ADDR_VAR 0 2
25892: PUSH
25893: CALL_OW 45
25897: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25898: LD_VAR 0 2
25902: PPUSH
25903: LD_INT 1
25905: PPUSH
25906: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25910: LD_VAR 0 2
25914: PPUSH
25915: LD_INT 19
25917: PPUSH
25918: LD_INT 0
25920: PPUSH
25921: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25925: LD_VAR 0 1
25929: PPUSH
25930: LD_VAR 0 2
25934: PPUSH
25935: CALL_OW 52
// end ;
25939: GO 25843
25941: POP
25942: POP
// missionStage := 8 ;
25943: LD_ADDR_EXP 15
25947: PUSH
25948: LD_INT 8
25950: ST_TO_ADDR
// DialogueOn ;
25951: CALL_OW 6
// if Stevens then
25955: LD_EXP 38
25959: IFFALSE 26073
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25961: LD_EXP 38
25965: PPUSH
25966: CALL_OW 310
25970: PPUSH
25971: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25975: LD_EXP 38
25979: PPUSH
25980: LD_STRING D8-Huck-1
25982: PPUSH
25983: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25987: LD_EXP 36
25991: PPUSH
25992: LD_STRING D8-JMM-1
25994: PPUSH
25995: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25999: LD_EXP 38
26003: PPUSH
26004: LD_STRING D8-Huck-2
26006: PPUSH
26007: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26011: LD_EXP 36
26015: PPUSH
26016: LD_STRING D8-JMM-2
26018: PPUSH
26019: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26023: LD_EXP 38
26027: PPUSH
26028: LD_STRING D8-Huck-3
26030: PPUSH
26031: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26035: LD_EXP 36
26039: PPUSH
26040: LD_STRING D8-JMM-3
26042: PPUSH
26043: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26047: LD_EXP 38
26051: PPUSH
26052: LD_STRING D8-Huck-4
26054: PPUSH
26055: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26059: LD_EXP 36
26063: PPUSH
26064: LD_STRING D8-JMM-4
26066: PPUSH
26067: CALL_OW 88
// end else
26071: GO 26183
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26073: LD_EXP 52
26077: PPUSH
26078: CALL_OW 310
26082: PPUSH
26083: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26087: LD_EXP 52
26091: PPUSH
26092: LD_STRING D8-Huck-1
26094: PPUSH
26095: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26099: LD_EXP 36
26103: PPUSH
26104: LD_STRING D8-JMM-1a
26106: PPUSH
26107: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26111: LD_EXP 52
26115: PPUSH
26116: LD_STRING D8-Huck-2
26118: PPUSH
26119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26123: LD_EXP 36
26127: PPUSH
26128: LD_STRING D8-JMM-2
26130: PPUSH
26131: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26135: LD_EXP 52
26139: PPUSH
26140: LD_STRING D8-Huck-3
26142: PPUSH
26143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26147: LD_EXP 36
26151: PPUSH
26152: LD_STRING D8-JMM-3
26154: PPUSH
26155: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26159: LD_EXP 52
26163: PPUSH
26164: LD_STRING D8-Huck-4
26166: PPUSH
26167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26171: LD_EXP 36
26175: PPUSH
26176: LD_STRING D8-JMM-4
26178: PPUSH
26179: CALL_OW 88
// end ; DialogueOff ;
26183: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26187: LD_INT 25
26189: PPUSH
26190: LD_INT 1
26192: PPUSH
26193: LD_INT 1
26195: PPUSH
26196: CALL_OW 322
// end ;
26200: PPOPN 3
26202: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26203: LD_INT 1
26205: PPUSH
26206: LD_EXP 68
26210: PPUSH
26211: CALL_OW 292
26215: IFFALSE 26466
26217: GO 26219
26219: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26220: LD_EXP 68
26224: PPUSH
26225: CALL_OW 87
// DialogueOn ;
26229: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26233: LD_EXP 36
26237: PPUSH
26238: LD_STRING D10nB-JMM-1
26240: PPUSH
26241: CALL_OW 88
// if BurlakStatus = 1 then
26245: LD_EXP 9
26249: PUSH
26250: LD_INT 1
26252: EQUAL
26253: IFFALSE 26267
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26255: LD_EXP 67
26259: PPUSH
26260: LD_STRING D10nB-Vse-1a
26262: PPUSH
26263: CALL_OW 94
// end ; if BurlakStatus = 0 then
26267: LD_EXP 9
26271: PUSH
26272: LD_INT 0
26274: EQUAL
26275: IFFALSE 26289
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26277: LD_EXP 67
26281: PPUSH
26282: LD_STRING D10nB-Vse-1
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26289: LD_EXP 36
26293: PPUSH
26294: LD_STRING D10nB-JMM-2
26296: PPUSH
26297: CALL_OW 88
// if KappaStatus then
26301: LD_EXP 2
26305: IFFALSE 26319
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26307: LD_EXP 67
26311: PPUSH
26312: LD_STRING D10nB-Vse-5a
26314: PPUSH
26315: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26319: LD_EXP 2
26323: NOT
26324: PUSH
26325: LD_EXP 6
26329: PUSH
26330: LD_INT 0
26332: EQUAL
26333: AND
26334: IFFALSE 26462
// begin if JMMGirl = 1 then
26336: LD_EXP 7
26340: PUSH
26341: LD_INT 1
26343: EQUAL
26344: IFFALSE 26394
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26346: LD_EXP 67
26350: PPUSH
26351: LD_STRING D10nB-Vse-2
26353: PPUSH
26354: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26358: LD_EXP 36
26362: PPUSH
26363: LD_STRING D10nB-JMM-3
26365: PPUSH
26366: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26370: LD_EXP 67
26374: PPUSH
26375: LD_STRING D10nB-Vse-3
26377: PPUSH
26378: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26382: LD_EXP 36
26386: PPUSH
26387: LD_STRING D10nB-JMM-4
26389: PPUSH
26390: CALL_OW 88
// end ; if JMMGirl = 2 then
26394: LD_EXP 7
26398: PUSH
26399: LD_INT 2
26401: EQUAL
26402: IFFALSE 26428
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26404: LD_EXP 67
26408: PPUSH
26409: LD_STRING D10nB-Vse-4
26411: PPUSH
26412: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26416: LD_EXP 36
26420: PPUSH
26421: LD_STRING D10nB-JMM-5
26423: PPUSH
26424: CALL_OW 88
// end ; if JMMGirl = 3 then
26428: LD_EXP 7
26432: PUSH
26433: LD_INT 3
26435: EQUAL
26436: IFFALSE 26462
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26438: LD_EXP 67
26442: PPUSH
26443: LD_STRING D10nB-Vse-5
26445: PPUSH
26446: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26450: LD_EXP 36
26454: PPUSH
26455: LD_STRING D10nB-JMM-6
26457: PPUSH
26458: CALL_OW 88
// end ; end ; DialogueOff ;
26462: CALL_OW 7
// end ;
26466: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26467: LD_EXP 14
26471: PUSH
26472: LD_INT 115500
26474: GREATEREQUAL
26475: IFFALSE 26834
26477: GO 26479
26479: DISABLE
26480: LD_INT 0
26482: PPUSH
// begin missionStage := 10 ;
26483: LD_ADDR_EXP 15
26487: PUSH
26488: LD_INT 10
26490: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26491: LD_ADDR_VAR 0 1
26495: PUSH
26496: LD_INT 22
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 26
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 3
26518: PUSH
26519: LD_INT 25
26521: PUSH
26522: LD_INT 12
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 3
26535: PUSH
26536: LD_INT 25
26538: PUSH
26539: LD_INT 16
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL_OW 69
26560: PUSH
26561: LD_EXP 36
26565: PUSH
26566: LD_EXP 38
26570: PUSH
26571: LD_EXP 52
26575: PUSH
26576: LD_EXP 39
26580: PUSH
26581: LD_EXP 40
26585: PUSH
26586: LD_EXP 41
26590: PUSH
26591: LD_EXP 42
26595: PUSH
26596: LD_EXP 43
26600: PUSH
26601: LD_EXP 44
26605: PUSH
26606: LD_EXP 45
26610: PUSH
26611: LD_EXP 46
26615: PUSH
26616: LD_EXP 47
26620: PUSH
26621: LD_EXP 48
26625: PUSH
26626: LD_EXP 49
26630: PUSH
26631: LD_EXP 50
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: DIFF
26653: ST_TO_ADDR
// if not tmp and Brown then
26654: LD_VAR 0 1
26658: NOT
26659: PUSH
26660: LD_EXP 44
26664: AND
26665: IFFALSE 26680
// tmp := [ Brown ] ;
26667: LD_ADDR_VAR 0 1
26671: PUSH
26672: LD_EXP 44
26676: PUSH
26677: EMPTY
26678: LIST
26679: ST_TO_ADDR
// DialogueOn ;
26680: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 1
26691: ARRAY
26692: PPUSH
26693: LD_STRING D11-Sol1-1
26695: PPUSH
26696: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26700: LD_EXP 61
26704: PPUSH
26705: LD_STRING D11-Pla-1
26707: PPUSH
26708: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26712: LD_EXP 62
26716: PPUSH
26717: LD_STRING D11-Kov-1
26719: PPUSH
26720: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26724: LD_EXP 61
26728: PPUSH
26729: LD_STRING D11-Pla-2
26731: PPUSH
26732: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26736: LD_VAR 0 1
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: PPUSH
26745: LD_STRING D11-Sol1-2
26747: PPUSH
26748: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26752: LD_EXP 36
26756: PPUSH
26757: LD_STRING D11-JMM-2
26759: PPUSH
26760: CALL_OW 88
// DialogueOff ;
26764: CALL_OW 7
// allowBehemothConstruct := true ;
26768: LD_ADDR_EXP 25
26772: PUSH
26773: LD_INT 1
26775: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26776: LD_STRING M4
26778: PPUSH
26779: CALL_OW 337
// BuildBehemoths ;
26783: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26787: LD_INT 31500
26789: PPUSH
26790: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26794: LD_EXP 27
26798: IFFALSE 26802
// break ;
26800: GO 26834
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26802: LD_INT 267
26804: PPUSH
26805: CALL_OW 274
26809: PPUSH
26810: LD_INT 1
26812: PPUSH
26813: CALL_OW 275
26817: PUSH
26818: LD_INT 1000
26820: GREATEREQUAL
26821: IFFALSE 26827
// BuildBehemoths ;
26823: CALL 7577 0 0
// until not behemothBuilders ;
26827: LD_EXP 70
26831: NOT
26832: IFFALSE 26787
// end ;
26834: PPOPN 1
26836: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26837: LD_EXP 70
26841: NOT
26842: PUSH
26843: LD_EXP 28
26847: NOT
26848: AND
26849: PUSH
26850: LD_EXP 25
26854: AND
26855: IFFALSE 26875
26857: GO 26859
26859: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26860: LD_STRING M4a
26862: PPUSH
26863: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26867: LD_ADDR_EXP 27
26871: PUSH
26872: LD_INT 1
26874: ST_TO_ADDR
// end ;
26875: END
// every 0 0$1 trigger behemothDone do
26876: LD_EXP 28
26880: IFFALSE 26892
26882: GO 26884
26884: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26885: LD_STRING M4b
26887: PPUSH
26888: CALL_OW 337
26892: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26893: LD_EXP 29
26897: NOT
26898: IFFALSE 27094
26900: GO 26902
26902: DISABLE
26903: LD_INT 0
26905: PPUSH
26906: PPUSH
// begin enable ;
26907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26908: LD_ADDR_VAR 0 1
26912: PUSH
26913: LD_INT 3
26915: PPUSH
26916: CALL 106032 0 1
26920: ST_TO_ADDR
// if not tmp and not behemothDone then
26921: LD_VAR 0 1
26925: NOT
26926: PUSH
26927: LD_EXP 28
26931: NOT
26932: AND
26933: IFFALSE 26969
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26935: LD_ADDR_VAR 0 1
26939: PUSH
26940: LD_INT 22
26942: PUSH
26943: LD_INT 3
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 37
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 69
26968: ST_TO_ADDR
// if not tmp then
26969: LD_VAR 0 1
26973: NOT
26974: IFFALSE 26978
// exit ;
26976: GO 27094
// for i in tmp do
26978: LD_ADDR_VAR 0 2
26982: PUSH
26983: LD_VAR 0 1
26987: PUSH
26988: FOR_IN
26989: IFFALSE 27092
// if See ( 1 , i ) then
26991: LD_INT 1
26993: PPUSH
26994: LD_VAR 0 2
26998: PPUSH
26999: CALL_OW 292
27003: IFFALSE 27090
// begin if GetType ( i ) = unit_building then
27005: LD_VAR 0 2
27009: PPUSH
27010: CALL_OW 247
27014: PUSH
27015: LD_INT 3
27017: EQUAL
27018: IFFALSE 27056
// begin CenterNowOnUnits ( i ) ;
27020: LD_VAR 0 2
27024: PPUSH
27025: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27029: LD_EXP 36
27033: PPUSH
27034: LD_STRING D17a-JMM-1
27036: PPUSH
27037: CALL_OW 88
// seeBehemoth := true ;
27041: LD_ADDR_EXP 29
27045: PUSH
27046: LD_INT 1
27048: ST_TO_ADDR
// disable ;
27049: DISABLE
// exit ;
27050: POP
27051: POP
27052: GO 27094
// end else
27054: GO 27090
// begin CenterNowOnUnits ( i ) ;
27056: LD_VAR 0 2
27060: PPUSH
27061: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27065: LD_EXP 36
27069: PPUSH
27070: LD_STRING D17b-JMM-1
27072: PPUSH
27073: CALL_OW 88
// seeBehemoth := true ;
27077: LD_ADDR_EXP 29
27081: PUSH
27082: LD_INT 1
27084: ST_TO_ADDR
// disable ;
27085: DISABLE
// exit ;
27086: POP
27087: POP
27088: GO 27094
// end ; end ;
27090: GO 26988
27092: POP
27093: POP
// end ;
27094: PPOPN 2
27096: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27097: LD_EXP 14
27101: PUSH
27102: LD_INT 116550
27104: GREATEREQUAL
27105: IFFALSE 28281
27107: GO 27109
27109: DISABLE
27110: LD_INT 0
27112: PPUSH
27113: PPUSH
27114: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27115: LD_INT 2
27117: PPUSH
27118: LD_INT 23
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: LD_INT 3
27126: PUSH
27127: LD_INT 48
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: PUSH
27136: EMPTY
27137: LIST
27138: PPUSH
27139: CALL 57366 0 2
// repeat wait ( 0 0$1 ) ;
27143: LD_INT 35
27145: PPUSH
27146: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27150: LD_INT 22
27152: PUSH
27153: LD_INT 3
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 34
27162: PUSH
27163: LD_INT 48
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PPUSH
27174: CALL_OW 69
27178: IFFALSE 27143
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27180: LD_ADDR_VAR 0 1
27184: PUSH
27185: LD_INT 22
27187: PUSH
27188: LD_INT 3
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 34
27197: PUSH
27198: LD_INT 48
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PPUSH
27209: CALL_OW 69
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: ST_TO_ADDR
// missionStage := 12 ;
27218: LD_ADDR_EXP 15
27222: PUSH
27223: LD_INT 12
27225: ST_TO_ADDR
// platonovHasBomb := true ;
27226: LD_ADDR_EXP 30
27230: PUSH
27231: LD_INT 1
27233: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27234: LD_VAR 0 1
27238: PPUSH
27239: LD_INT 181
27241: PPUSH
27242: LD_INT 86
27244: PPUSH
27245: CALL_OW 171
// AddComHold ( bomb ) ;
27249: LD_VAR 0 1
27253: PPUSH
27254: CALL_OW 200
// wait ( 0 0$10 ) ;
27258: LD_INT 350
27260: PPUSH
27261: CALL_OW 67
// DialogueOn ;
27265: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27269: LD_EXP 61
27273: PPUSH
27274: LD_STRING D15-Pla-1
27276: PPUSH
27277: CALL_OW 94
// dec = Query ( Q15a ) ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: LD_STRING Q15a
27288: PPUSH
27289: CALL_OW 97
27293: ST_TO_ADDR
// if dec = 1 then
27294: LD_VAR 0 2
27298: PUSH
27299: LD_INT 1
27301: EQUAL
27302: IFFALSE 27325
// begin Say ( JMM , D15a-JMM-1 ) ;
27304: LD_EXP 36
27308: PPUSH
27309: LD_STRING D15a-JMM-1
27311: PPUSH
27312: CALL_OW 88
// YouLost ( Surrender ) ;
27316: LD_STRING Surrender
27318: PPUSH
27319: CALL_OW 104
// exit ;
27323: GO 28281
// end ; if dec = 2 then
27325: LD_VAR 0 2
27329: PUSH
27330: LD_INT 2
27332: EQUAL
27333: IFFALSE 27402
// begin Say ( JMM , D15b-JMM-1 ) ;
27335: LD_EXP 36
27339: PPUSH
27340: LD_STRING D15b-JMM-1
27342: PPUSH
27343: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27347: LD_EXP 61
27351: PPUSH
27352: LD_STRING D15b-Pla-1
27354: PPUSH
27355: CALL_OW 94
// DialogueOff ;
27359: CALL_OW 7
// wait ( 3 3$00 ) ;
27363: LD_INT 6300
27365: PPUSH
27366: CALL_OW 67
// DialogueOn ;
27370: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27374: LD_EXP 36
27378: PPUSH
27379: LD_STRING D15d-JMM-1a
27381: PPUSH
27382: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27386: LD_EXP 61
27390: PPUSH
27391: LD_STRING D15d-Pla-1
27393: PPUSH
27394: CALL_OW 94
// DialogueOff ;
27398: CALL_OW 7
// end ; if dec = 3 then
27402: LD_VAR 0 2
27406: PUSH
27407: LD_INT 3
27409: EQUAL
27410: IFFALSE 27464
// begin Say ( JMM , D15c-JMM-1 ) ;
27412: LD_EXP 36
27416: PPUSH
27417: LD_STRING D15c-JMM-1
27419: PPUSH
27420: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27424: LD_EXP 61
27428: PPUSH
27429: LD_STRING D15c-Pla-1
27431: PPUSH
27432: CALL_OW 94
// DialogueOff ;
27436: CALL_OW 7
// wait ( 0 0$15 ) ;
27440: LD_INT 525
27442: PPUSH
27443: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 60
27454: PPUSH
27455: LD_INT 95
27457: PPUSH
27458: CALL_OW 116
// exit ;
27462: GO 28281
// end ; if dec = 4 then
27464: LD_VAR 0 2
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27502
// begin Say ( JMM , D15d-JMM-1 ) ;
27474: LD_EXP 36
27478: PPUSH
27479: LD_STRING D15d-JMM-1
27481: PPUSH
27482: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27486: LD_EXP 61
27490: PPUSH
27491: LD_STRING D15d-Pla-1
27493: PPUSH
27494: CALL_OW 94
// DialogueOff ;
27498: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27502: LD_EXP 59
27506: PPUSH
27507: CALL_OW 302
27511: PUSH
27512: LD_EXP 59
27516: PPUSH
27517: CALL_OW 255
27521: PUSH
27522: LD_INT 1
27524: EQUAL
27525: AND
27526: PUSH
27527: LD_INT 22
27529: PUSH
27530: LD_INT 1
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 34
27539: PUSH
27540: LD_INT 8
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PPUSH
27551: CALL_OW 69
27555: NOT
27556: AND
27557: IFFALSE 28182
// begin SetSide ( Friend , 8 ) ;
27559: LD_EXP 59
27563: PPUSH
27564: LD_INT 8
27566: PPUSH
27567: CALL_OW 235
// if IsInUnit ( Friend ) then
27571: LD_EXP 59
27575: PPUSH
27576: CALL_OW 310
27580: IFFALSE 27591
// ComExitBuilding ( Friend ) ;
27582: LD_EXP 59
27586: PPUSH
27587: CALL_OW 122
// if IsDriver ( Friend ) then
27591: LD_EXP 59
27595: PPUSH
27596: CALL 103709 0 1
27600: IFFALSE 27611
// ComExitVehicle ( Friend ) ;
27602: LD_EXP 59
27606: PPUSH
27607: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27611: LD_EXP 59
27615: PPUSH
27616: LD_INT 9
27618: PPUSH
27619: LD_INT 2
27621: PPUSH
27622: CALL_OW 171
// wait ( 0 0$05 ) ;
27626: LD_INT 175
27628: PPUSH
27629: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27633: LD_EXP 59
27637: PPUSH
27638: CALL_OW 87
// DialogueOn ;
27642: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27646: LD_EXP 36
27650: PPUSH
27651: LD_STRING D16-JMM-1
27653: PPUSH
27654: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27658: LD_EXP 59
27662: PPUSH
27663: LD_STRING D16-Friend-1
27665: PPUSH
27666: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27670: LD_EXP 36
27674: PPUSH
27675: LD_STRING D16-JMM-2
27677: PPUSH
27678: CALL_OW 88
// DialogueOff ;
27682: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27686: LD_EXP 59
27690: PPUSH
27691: LD_INT 1
27693: PPUSH
27694: CALL_OW 235
// ComHold ( Friend ) ;
27698: LD_EXP 59
27702: PPUSH
27703: CALL_OW 140
// wait ( 0 0$20 ) ;
27707: LD_INT 700
27709: PPUSH
27710: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27714: LD_EXP 59
27718: PPUSH
27719: LD_INT 9
27721: PPUSH
27722: LD_INT 2
27724: PPUSH
27725: CALL_OW 297
27729: PUSH
27730: LD_INT 30
27732: LESS
27733: IFFALSE 27802
// begin SetSide ( Friend , 8 ) ;
27735: LD_EXP 59
27739: PPUSH
27740: LD_INT 8
27742: PPUSH
27743: CALL_OW 235
// if IsInUnit ( Friend ) then
27747: LD_EXP 59
27751: PPUSH
27752: CALL_OW 310
27756: IFFALSE 27767
// ComExitBuilding ( Friend ) ;
27758: LD_EXP 59
27762: PPUSH
27763: CALL_OW 122
// if IsDriver ( Friend ) then
27767: LD_EXP 59
27771: PPUSH
27772: CALL 103709 0 1
27776: IFFALSE 27787
// ComExitVehicle ( Friend ) ;
27778: LD_EXP 59
27782: PPUSH
27783: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27787: LD_EXP 59
27791: PPUSH
27792: LD_INT 9
27794: PPUSH
27795: LD_INT 2
27797: PPUSH
27798: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27802: LD_INT 1050
27804: PPUSH
27805: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27809: LD_INT 22
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 34
27821: PUSH
27822: LD_INT 8
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: NOT
27838: IFFALSE 28160
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_INT 22
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 26
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 3
27867: PUSH
27868: LD_INT 25
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 25
27880: PUSH
27881: LD_INT 16
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 69
27902: PUSH
27903: LD_EXP 36
27907: PUSH
27908: LD_EXP 38
27912: PUSH
27913: LD_EXP 52
27917: PUSH
27918: LD_EXP 39
27922: PUSH
27923: LD_EXP 40
27927: PUSH
27928: LD_EXP 41
27932: PUSH
27933: LD_EXP 42
27937: PUSH
27938: LD_EXP 43
27942: PUSH
27943: LD_EXP 44
27947: PUSH
27948: LD_EXP 45
27952: PUSH
27953: LD_EXP 46
27957: PUSH
27958: LD_EXP 47
27962: PUSH
27963: LD_EXP 48
27967: PUSH
27968: LD_EXP 49
27972: PUSH
27973: LD_EXP 50
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: DIFF
27995: ST_TO_ADDR
// DialogueOn ;
27996: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28000: LD_EXP 61
28004: PPUSH
28005: LD_STRING D16a-Pla-1
28007: PPUSH
28008: CALL_OW 94
// if Stevens then
28012: LD_EXP 38
28016: IFFALSE 28032
// Say ( Stevens , D16a-Huck-1 ) else
28018: LD_EXP 38
28022: PPUSH
28023: LD_STRING D16a-Huck-1
28025: PPUSH
28026: CALL_OW 88
28030: GO 28074
// if Baker then
28032: LD_EXP 52
28036: IFFALSE 28052
// Say ( Baker , D16a-Huck-1 ) else
28038: LD_EXP 52
28042: PPUSH
28043: LD_STRING D16a-Huck-1
28045: PPUSH
28046: CALL_OW 88
28050: GO 28074
// if tmp then
28052: LD_VAR 0 3
28056: IFFALSE 28074
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28058: LD_VAR 0 3
28062: PUSH
28063: LD_INT 1
28065: ARRAY
28066: PPUSH
28067: LD_STRING D16a-Sol1-1
28069: PPUSH
28070: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28074: LD_EXP 59
28078: PPUSH
28079: CALL_OW 255
28083: PUSH
28084: LD_INT 8
28086: EQUAL
28087: IFFALSE 28103
// Say ( JMM , D16a-JMM-1 ) else
28089: LD_EXP 36
28093: PPUSH
28094: LD_STRING D16a-JMM-1
28096: PPUSH
28097: CALL_OW 88
28101: GO 28139
// begin Say ( JMM , D16a-JMM-1a ) ;
28103: LD_EXP 36
28107: PPUSH
28108: LD_STRING D16a-JMM-1a
28110: PPUSH
28111: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28115: LD_EXP 59
28119: PPUSH
28120: LD_STRING D16a-Friend-1
28122: PPUSH
28123: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28127: LD_EXP 59
28131: PPUSH
28132: LD_INT 3
28134: PPUSH
28135: CALL_OW 235
// end ; DialogueOff ;
28139: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28143: LD_VAR 0 1
28147: PPUSH
28148: LD_INT 60
28150: PPUSH
28151: LD_INT 95
28153: PPUSH
28154: CALL_OW 116
// end else
28158: GO 28180
// begin DialogueOn ;
28160: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28164: LD_EXP 61
28168: PPUSH
28169: LD_STRING D16c-Pla-
28171: PPUSH
28172: CALL_OW 94
// DialogueOff ;
28176: CALL_OW 7
// end ; end else
28180: GO 28281
// begin wait ( 3 3$00 ) ;
28182: LD_INT 6300
28184: PPUSH
28185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28189: LD_INT 22
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 8
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: NOT
28218: IFFALSE 28261
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28220: LD_EXP 61
28224: PPUSH
28225: LD_STRING D16b-Pla-1
28227: PPUSH
28228: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28232: LD_EXP 36
28236: PPUSH
28237: LD_STRING D16b-JMM-
28239: PPUSH
28240: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28244: LD_VAR 0 1
28248: PPUSH
28249: LD_INT 60
28251: PPUSH
28252: LD_INT 95
28254: PPUSH
28255: CALL_OW 116
// end else
28259: GO 28281
// begin DialogueOn ;
28261: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28265: LD_EXP 61
28269: PPUSH
28270: LD_STRING D16c-Pla-
28272: PPUSH
28273: CALL_OW 94
// DialogueOff ;
28277: CALL_OW 7
// end ; end ; end ;
28281: PPOPN 3
28283: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28284: LD_EXP 14
28288: PUSH
28289: LD_INT 126000
28291: GREATEREQUAL
28292: PUSH
28293: LD_EXP 23
28297: NOT
28298: AND
28299: PUSH
28300: LD_EXP 71
28304: PPUSH
28305: CALL_OW 302
28309: AND
28310: IFFALSE 28668
28312: GO 28314
28314: DISABLE
28315: LD_INT 0
28317: PPUSH
// begin missionStage = 11 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 11
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28330: LD_EXP 71
28334: PPUSH
28335: LD_STRING D9-Roth-1
28337: PPUSH
28338: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28342: LD_EXP 36
28346: PPUSH
28347: LD_STRING D9-JMM-1
28349: PPUSH
28350: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28354: LD_EXP 71
28358: PPUSH
28359: LD_STRING D9-Roth-2
28361: PPUSH
28362: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28366: LD_EXP 71
28370: PPUSH
28371: LD_STRING D9-Roth-2a
28373: PPUSH
28374: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28378: LD_EXP 61
28382: PPUSH
28383: LD_STRING D9-Pla-2
28385: PPUSH
28386: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28390: LD_EXP 71
28394: PPUSH
28395: LD_STRING D9-Roth-3
28397: PPUSH
28398: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28402: LD_EXP 61
28406: PPUSH
28407: LD_STRING D9-Pla-3
28409: PPUSH
28410: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28414: LD_EXP 71
28418: PPUSH
28419: LD_STRING D9-Roth-4
28421: PPUSH
28422: CALL_OW 94
// dec = Query ( Q9 ) ;
28426: LD_ADDR_VAR 0 1
28430: PUSH
28431: LD_STRING Q9
28433: PPUSH
28434: CALL_OW 97
28438: ST_TO_ADDR
// if dec = 1 then
28439: LD_VAR 0 1
28443: PUSH
28444: LD_INT 1
28446: EQUAL
28447: IFFALSE 28461
// SayRadio ( Roth , D9a-Roth-1 ) ;
28449: LD_EXP 71
28453: PPUSH
28454: LD_STRING D9a-Roth-1
28456: PPUSH
28457: CALL_OW 94
// if dec = 2 then
28461: LD_VAR 0 1
28465: PUSH
28466: LD_INT 2
28468: EQUAL
28469: IFFALSE 28495
// begin Say ( JMM , D9b-JMM-1 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9b-JMM-1
28478: PPUSH
28479: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9b-Roth-1
28490: PPUSH
28491: CALL_OW 94
// end ; if dec = 3 then
28495: LD_VAR 0 1
28499: PUSH
28500: LD_INT 3
28502: EQUAL
28503: IFFALSE 28565
// begin Say ( JMM , D9c-JMM-1 ) ;
28505: LD_EXP 36
28509: PPUSH
28510: LD_STRING D9c-JMM-1
28512: PPUSH
28513: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28517: LD_EXP 71
28521: PPUSH
28522: LD_STRING D9c-Roth-1
28524: PPUSH
28525: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28529: LD_EXP 36
28533: PPUSH
28534: LD_STRING D9c-JMM-2
28536: PPUSH
28537: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28541: LD_EXP 71
28545: PPUSH
28546: LD_STRING D9c-Roth-2
28548: PPUSH
28549: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28553: LD_EXP 36
28557: PPUSH
28558: LD_STRING D9c-JMM-3
28560: PPUSH
28561: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28565: LD_EXP 71
28569: PPUSH
28570: LD_STRING D9c-Roth-3
28572: PPUSH
28573: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28577: LD_EXP 71
28581: PPUSH
28582: LD_STRING D9cont-Roth-1
28584: PPUSH
28585: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28589: LD_EXP 36
28593: PPUSH
28594: LD_STRING D9cont-JMM-1
28596: PPUSH
28597: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28601: LD_EXP 71
28605: PPUSH
28606: LD_STRING D9cont-Roth-2
28608: PPUSH
28609: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28613: LD_EXP 36
28617: PPUSH
28618: LD_STRING D9cont-JMM-2
28620: PPUSH
28621: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28625: LD_EXP 71
28629: PPUSH
28630: LD_STRING D9cont-Roth-3
28632: PPUSH
28633: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28637: LD_EXP 36
28641: PPUSH
28642: LD_STRING D9cont-JMM-3
28644: PPUSH
28645: CALL_OW 88
// DialogueOff ;
28649: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28653: LD_STRING M3
28655: PPUSH
28656: CALL_OW 337
// allianceActive := true ;
28660: LD_ADDR_EXP 31
28664: PUSH
28665: LD_INT 1
28667: ST_TO_ADDR
// end ;
28668: PPOPN 1
28670: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28671: LD_EXP 61
28675: PPUSH
28676: CALL_OW 301
28680: PUSH
28681: LD_EXP 64
28685: PPUSH
28686: CALL_OW 301
28690: AND
28691: PUSH
28692: LD_INT 22
28694: PUSH
28695: LD_INT 3
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 21
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 50
28714: PUSH
28715: EMPTY
28716: LIST
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: LIST
28722: PPUSH
28723: CALL_OW 69
28727: PUSH
28728: LD_INT 7
28730: PUSH
28731: LD_INT 8
28733: PUSH
28734: LD_INT 9
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: LIST
28741: PUSH
28742: LD_OWVAR 67
28746: ARRAY
28747: LESS
28748: AND
28749: IFFALSE 29520
28751: GO 28753
28753: DISABLE
28754: LD_INT 0
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
// begin MC_Kill ( 1 ) ;
28760: LD_INT 1
28762: PPUSH
28763: CALL 34018 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28767: LD_INT 1
28769: PPUSH
28770: LD_INT 3
28772: PPUSH
28773: LD_INT 1
28775: PPUSH
28776: LD_INT 1
28778: PPUSH
28779: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28783: LD_ADDR_VAR 0 1
28787: PUSH
28788: LD_INT 22
28790: PUSH
28791: LD_INT 3
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 21
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 24
28810: PUSH
28811: LD_INT 900
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: LIST
28822: PPUSH
28823: CALL_OW 69
28827: PUSH
28828: FOR_IN
28829: IFFALSE 28860
// if GetSex ( i ) = sex_male then
28831: LD_VAR 0 1
28835: PPUSH
28836: CALL_OW 258
28840: PUSH
28841: LD_INT 1
28843: EQUAL
28844: IFFALSE 28858
// begin tmp = i ;
28846: LD_ADDR_VAR 0 2
28850: PUSH
28851: LD_VAR 0 1
28855: ST_TO_ADDR
// break ;
28856: GO 28860
// end ;
28858: GO 28828
28860: POP
28861: POP
// if tmp = 0 then
28862: LD_VAR 0 2
28866: PUSH
28867: LD_INT 0
28869: EQUAL
28870: IFFALSE 28924
// begin uc_side = 3 ;
28872: LD_ADDR_OWVAR 20
28876: PUSH
28877: LD_INT 3
28879: ST_TO_ADDR
// uc_nation = 3 ;
28880: LD_ADDR_OWVAR 21
28884: PUSH
28885: LD_INT 3
28887: ST_TO_ADDR
// hc_name =  ;
28888: LD_ADDR_OWVAR 26
28892: PUSH
28893: LD_STRING 
28895: ST_TO_ADDR
// hc_gallery =  ;
28896: LD_ADDR_OWVAR 33
28900: PUSH
28901: LD_STRING 
28903: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28904: LD_INT 1
28906: PPUSH
28907: LD_INT 10
28909: PPUSH
28910: CALL_OW 381
// tmp = CreateHuman ;
28914: LD_ADDR_VAR 0 2
28918: PUSH
28919: CALL_OW 44
28923: ST_TO_ADDR
// end ; DialogueOn ;
28924: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28928: LD_VAR 0 2
28932: PPUSH
28933: LD_STRING DSurrenderRussians-RSol1-1a
28935: PPUSH
28936: CALL_OW 88
// DialogueOff ;
28940: CALL_OW 7
// russianDestroyed := true ;
28944: LD_ADDR_EXP 21
28948: PUSH
28949: LD_INT 1
28951: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28952: LD_INT 22
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 21
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PPUSH
28976: CALL_OW 69
28980: PPUSH
28981: CALL_OW 122
// wait ( 0 0$1 ) ;
28985: LD_INT 35
28987: PPUSH
28988: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28992: LD_INT 22
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 21
29004: PUSH
29005: LD_INT 1
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PPUSH
29016: CALL_OW 69
29020: PPUSH
29021: LD_INT 25
29023: PPUSH
29024: CALL_OW 173
// wait ( 0 0$10 ) ;
29028: LD_INT 350
29030: PPUSH
29031: CALL_OW 67
// PrepareOmarInvasion ;
29035: CALL 13700 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29039: LD_ADDR_VAR 0 2
29043: PUSH
29044: LD_EXP 89
29048: PPUSH
29049: CALL_OW 250
29053: PUSH
29054: LD_EXP 89
29058: PPUSH
29059: CALL_OW 251
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29068: LD_VAR 0 2
29072: PUSH
29073: LD_INT 1
29075: ARRAY
29076: PPUSH
29077: LD_VAR 0 2
29081: PUSH
29082: LD_INT 2
29084: ARRAY
29085: PPUSH
29086: LD_INT 1
29088: PPUSH
29089: LD_INT 8
29091: NEG
29092: PPUSH
29093: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29097: LD_EXP 89
29101: PPUSH
29102: CALL_OW 87
// DialogueOn ;
29106: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29110: LD_EXP 36
29114: PPUSH
29115: LD_STRING D19-JMM-1
29117: PPUSH
29118: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29122: LD_ADDR_VAR 0 3
29126: PUSH
29127: LD_INT 22
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 26
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: PUSH
29150: LD_INT 25
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 25
29162: PUSH
29163: LD_INT 2
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 25
29172: PUSH
29173: LD_INT 3
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 25
29182: PUSH
29183: LD_INT 4
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 25
29192: PUSH
29193: LD_INT 5
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 25
29202: PUSH
29203: LD_INT 8
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 69
29228: PUSH
29229: LD_EXP 36
29233: PUSH
29234: LD_EXP 37
29238: PUSH
29239: LD_EXP 38
29243: PUSH
29244: LD_EXP 39
29248: PUSH
29249: LD_EXP 40
29253: PUSH
29254: LD_EXP 41
29258: PUSH
29259: LD_EXP 42
29263: PUSH
29264: LD_EXP 43
29268: PUSH
29269: LD_EXP 44
29273: PUSH
29274: LD_EXP 45
29278: PUSH
29279: LD_EXP 46
29283: PUSH
29284: LD_EXP 47
29288: PUSH
29289: LD_EXP 48
29293: PUSH
29294: LD_EXP 49
29298: PUSH
29299: LD_EXP 50
29303: PUSH
29304: LD_EXP 51
29308: PUSH
29309: LD_EXP 52
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: DIFF
29333: ST_TO_ADDR
// if tmp2 then
29334: LD_VAR 0 3
29338: IFFALSE 29356
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29340: LD_VAR 0 3
29344: PUSH
29345: LD_INT 1
29347: ARRAY
29348: PPUSH
29349: LD_STRING D19-Sol1-1
29351: PPUSH
29352: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29356: LD_EXP 36
29360: PPUSH
29361: LD_STRING D19-JMM-2
29363: PPUSH
29364: CALL_OW 88
// DialogueOff ;
29368: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29372: LD_VAR 0 2
29376: PUSH
29377: LD_INT 1
29379: ARRAY
29380: PPUSH
29381: LD_VAR 0 2
29385: PUSH
29386: LD_INT 2
29388: ARRAY
29389: PPUSH
29390: LD_INT 1
29392: PPUSH
29393: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29397: LD_STRING M5
29399: PPUSH
29400: CALL_OW 337
// omarOnMotherLode := false ;
29404: LD_ADDR_VAR 0 4
29408: PUSH
29409: LD_INT 0
29411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29412: LD_INT 35
29414: PPUSH
29415: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29419: LD_EXP 89
29423: PPUSH
29424: LD_INT 215
29426: PPUSH
29427: LD_INT 100
29429: PPUSH
29430: CALL_OW 297
29434: PUSH
29435: LD_INT 10
29437: LESS
29438: PUSH
29439: LD_VAR 0 4
29443: NOT
29444: AND
29445: IFFALSE 29479
// begin omarOnMotherLode := true ;
29447: LD_ADDR_VAR 0 4
29451: PUSH
29452: LD_INT 1
29454: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29455: LD_EXP 36
29459: PPUSH
29460: LD_STRING D19b-JMM-1
29462: PPUSH
29463: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29467: LD_EXP 89
29471: PPUSH
29472: LD_STRING DOmarContam-Omar-1
29474: PPUSH
29475: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29479: LD_EXP 89
29483: PPUSH
29484: CALL_OW 301
29488: IFFALSE 29412
// Say ( JMM , D19a-JMM-1 ) ;
29490: LD_EXP 36
29494: PPUSH
29495: LD_STRING D19a-JMM-1
29497: PPUSH
29498: CALL_OW 88
// if Heike then
29502: LD_EXP 90
29506: IFFALSE 29520
// Say ( Heike , D19a-Hke-1 ) ;
29508: LD_EXP 90
29512: PPUSH
29513: LD_STRING D19a-Hke-1
29515: PPUSH
29516: CALL_OW 88
// end ;
29520: PPOPN 4
29522: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29523: LD_INT 22
29525: PUSH
29526: LD_INT 3
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 21
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL_OW 69
29551: PUSH
29552: LD_EXP 21
29556: AND
29557: IFFALSE 29625
29559: GO 29561
29561: DISABLE
29562: LD_INT 0
29564: PPUSH
29565: PPUSH
// begin enable ;
29566: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29567: LD_ADDR_VAR 0 2
29571: PUSH
29572: LD_INT 25
29574: PPUSH
29575: LD_INT 22
29577: PUSH
29578: LD_INT 3
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PPUSH
29585: CALL_OW 70
29589: ST_TO_ADDR
// if not tmp then
29590: LD_VAR 0 2
29594: NOT
29595: IFFALSE 29599
// exit ;
29597: GO 29625
// for i in tmp do
29599: LD_ADDR_VAR 0 1
29603: PUSH
29604: LD_VAR 0 2
29608: PUSH
29609: FOR_IN
29610: IFFALSE 29623
// RemoveUnit ( i ) ;
29612: LD_VAR 0 1
29616: PPUSH
29617: CALL_OW 64
29621: GO 29609
29623: POP
29624: POP
// end ;
29625: PPOPN 2
29627: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29628: LD_INT 22
29630: PUSH
29631: LD_INT 7
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 21
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PPUSH
29652: CALL_OW 69
29656: PUSH
29657: LD_INT 6
29659: LESS
29660: IFFALSE 30111
29662: GO 29664
29664: DISABLE
29665: LD_INT 0
29667: PPUSH
29668: PPUSH
// begin MC_Kill ( 1 ) ;
29669: LD_INT 1
29671: PPUSH
29672: CALL 34018 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29676: LD_INT 7
29678: PPUSH
29679: LD_INT 1
29681: PPUSH
29682: LD_INT 1
29684: PPUSH
29685: LD_INT 1
29687: PPUSH
29688: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29692: LD_ADDR_VAR 0 1
29696: PUSH
29697: LD_INT 22
29699: PUSH
29700: LD_INT 7
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 26
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PPUSH
29721: CALL_OW 69
29725: PUSH
29726: LD_EXP 71
29730: DIFF
29731: ST_TO_ADDR
// if tmp then
29732: LD_VAR 0 1
29736: IFFALSE 29754
// tmp := tmp [ 1 ] else
29738: LD_ADDR_VAR 0 1
29742: PUSH
29743: LD_VAR 0 1
29747: PUSH
29748: LD_INT 1
29750: ARRAY
29751: ST_TO_ADDR
29752: GO 29790
// begin uc_side := 7 ;
29754: LD_ADDR_OWVAR 20
29758: PUSH
29759: LD_INT 7
29761: ST_TO_ADDR
// uc_nation := 1 ;
29762: LD_ADDR_OWVAR 21
29766: PUSH
29767: LD_INT 1
29769: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 8
29775: PPUSH
29776: CALL_OW 384
// tmp := CreateHuman ;
29780: LD_ADDR_VAR 0 1
29784: PUSH
29785: CALL_OW 44
29789: ST_TO_ADDR
// end ; DialogueOn ;
29790: CALL_OW 6
// if IsOK ( Roth ) then
29794: LD_EXP 71
29798: PPUSH
29799: CALL_OW 302
29803: IFFALSE 29817
// Say ( JMM , DAb-JMM-1 ) ;
29805: LD_EXP 36
29809: PPUSH
29810: LD_STRING DAb-JMM-1
29812: PPUSH
29813: CALL_OW 88
// if IsOK ( Roth ) then
29817: LD_EXP 71
29821: PPUSH
29822: CALL_OW 302
29826: IFFALSE 29850
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29828: LD_EXP 71
29832: PPUSH
29833: LD_STRING DSurrenderAlliance-Roth-1
29835: PPUSH
29836: CALL_OW 88
// RothCaptured := true ;
29840: LD_ADDR_EXP 33
29844: PUSH
29845: LD_INT 1
29847: ST_TO_ADDR
// end else
29848: GO 29862
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29850: LD_VAR 0 1
29854: PPUSH
29855: LD_STRING DSurrenderAlliance-Sci1-1
29857: PPUSH
29858: CALL_OW 88
// DialogueOff ;
29862: CALL_OW 7
// allianceDestroyed := true ;
29866: LD_ADDR_EXP 23
29870: PUSH
29871: LD_INT 1
29873: ST_TO_ADDR
// if trueAmericans then
29874: LD_EXP 35
29878: IFFALSE 29954
// begin if trueAmericans = 1 then
29880: LD_EXP 35
29884: PUSH
29885: LD_INT 1
29887: EQUAL
29888: IFFALSE 29904
// Say ( JMM , DAb-JMM-1a ) else
29890: LD_EXP 36
29894: PPUSH
29895: LD_STRING DAb-JMM-1a
29897: PPUSH
29898: CALL_OW 88
29902: GO 29916
// Say ( JMM , DAb-JMM-1b ) ;
29904: LD_EXP 36
29908: PPUSH
29909: LD_STRING DAb-JMM-1b
29911: PPUSH
29912: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29916: LD_EXP 35
29920: PPUSH
29921: CALL_OW 87
// for i in trueAmericans do
29925: LD_ADDR_VAR 0 2
29929: PUSH
29930: LD_EXP 35
29934: PUSH
29935: FOR_IN
29936: IFFALSE 29952
// SetSide ( i , 1 ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: CALL_OW 235
29950: GO 29935
29952: POP
29953: POP
// end ; repeat wait ( 0 0$1 ) ;
29954: LD_INT 35
29956: PPUSH
29957: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29961: LD_ADDR_VAR 0 2
29965: PUSH
29966: LD_INT 22
29968: PUSH
29969: LD_INT 7
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 21
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 69
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30078
// begin if IsInUnit ( i ) then
29998: LD_VAR 0 2
30002: PPUSH
30003: CALL_OW 310
30007: IFFALSE 30018
// ComExitBuilding ( i ) ;
30009: LD_VAR 0 2
30013: PPUSH
30014: CALL_OW 122
// if IsDriver ( i ) then
30018: LD_VAR 0 2
30022: PPUSH
30023: CALL 103709 0 1
30027: IFFALSE 30038
// ComExitVehicle ( i ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30038: LD_VAR 0 2
30042: PPUSH
30043: LD_INT 26
30045: PPUSH
30046: CALL_OW 308
30050: NOT
30051: IFFALSE 30067
// AddComMoveToArea ( i , allianceEscapeArea ) else
30053: LD_VAR 0 2
30057: PPUSH
30058: LD_INT 26
30060: PPUSH
30061: CALL_OW 173
30065: GO 30076
// RemoveUnit ( i ) ;
30067: LD_VAR 0 2
30071: PPUSH
30072: CALL_OW 64
// end ;
30076: GO 29995
30078: POP
30079: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30080: LD_INT 22
30082: PUSH
30083: LD_INT 7
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 21
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: CALL_OW 69
30108: NOT
30109: IFFALSE 29954
// end ;
30111: PPOPN 2
30113: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30114: LD_INT 0
30116: PPUSH
30117: PPUSH
// if not unit then
30118: LD_VAR 0 1
30122: NOT
30123: IFFALSE 30127
// exit ;
30125: GO 31625
// DoNotAttack ( 7 , unit ) ;
30127: LD_INT 7
30129: PPUSH
30130: LD_VAR 0 1
30134: PPUSH
30135: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30139: LD_VAR 0 1
30143: PPUSH
30144: LD_INT 260
30146: PPUSH
30147: LD_INT 235
30149: PPUSH
30150: LD_INT 3
30152: PPUSH
30153: LD_INT 1
30155: PPUSH
30156: CALL_OW 483
// SetSide ( unit , 4 ) ;
30160: LD_VAR 0 1
30164: PPUSH
30165: LD_INT 4
30167: PPUSH
30168: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30172: LD_ADDR_EXP 34
30176: PUSH
30177: LD_EXP 34
30181: PUSH
30182: LD_INT 1
30184: PLUS
30185: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30186: LD_INT 70
30188: PPUSH
30189: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30193: LD_INT 260
30195: PPUSH
30196: LD_INT 235
30198: PPUSH
30199: LD_INT 1
30201: PPUSH
30202: LD_INT 8
30204: NEG
30205: PPUSH
30206: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30210: LD_VAR 0 1
30214: PPUSH
30215: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30219: LD_VAR 0 1
30223: PPUSH
30224: LD_EXP 71
30228: PPUSH
30229: CALL_OW 119
// DialogueOn ;
30233: CALL_OW 6
// case unit of JMM :
30237: LD_VAR 0 1
30241: PUSH
30242: LD_EXP 36
30246: DOUBLE
30247: EQUAL
30248: IFTRUE 30252
30250: GO 30267
30252: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30253: LD_EXP 36
30257: PPUSH
30258: LD_STRING DA1-JMM-1
30260: PPUSH
30261: CALL_OW 91
30265: GO 30709
30267: LD_EXP 37
30271: DOUBLE
30272: EQUAL
30273: IFTRUE 30277
30275: GO 30292
30277: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30278: LD_EXP 37
30282: PPUSH
30283: LD_STRING DA1-Joan-1
30285: PPUSH
30286: CALL_OW 91
30290: GO 30709
30292: LD_EXP 39
30296: DOUBLE
30297: EQUAL
30298: IFTRUE 30302
30300: GO 30317
30302: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30303: LD_EXP 39
30307: PPUSH
30308: LD_STRING DA1-Lisa-1
30310: PPUSH
30311: CALL_OW 91
30315: GO 30709
30317: LD_EXP 40
30321: DOUBLE
30322: EQUAL
30323: IFTRUE 30327
30325: GO 30342
30327: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30328: LD_EXP 40
30332: PPUSH
30333: LD_STRING DA1-Don-1
30335: PPUSH
30336: CALL_OW 91
30340: GO 30709
30342: LD_EXP 47
30346: DOUBLE
30347: EQUAL
30348: IFTRUE 30352
30350: GO 30367
30352: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30353: LD_EXP 47
30357: PPUSH
30358: LD_STRING DA1-Corn-1
30360: PPUSH
30361: CALL_OW 91
30365: GO 30709
30367: LD_EXP 43
30371: DOUBLE
30372: EQUAL
30373: IFTRUE 30377
30375: GO 30392
30377: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30378: LD_EXP 43
30382: PPUSH
30383: LD_STRING DA1-Den-1
30385: PPUSH
30386: CALL_OW 91
30390: GO 30709
30392: LD_EXP 41
30396: DOUBLE
30397: EQUAL
30398: IFTRUE 30402
30400: GO 30417
30402: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30403: LD_EXP 41
30407: PPUSH
30408: LD_STRING DA1-Bobby-1
30410: PPUSH
30411: CALL_OW 91
30415: GO 30709
30417: LD_EXP 45
30421: DOUBLE
30422: EQUAL
30423: IFTRUE 30427
30425: GO 30442
30427: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30428: LD_EXP 45
30432: PPUSH
30433: LD_STRING DA1-Glad-1
30435: PPUSH
30436: CALL_OW 91
30440: GO 30709
30442: LD_EXP 42
30446: DOUBLE
30447: EQUAL
30448: IFTRUE 30452
30450: GO 30467
30452: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30453: LD_EXP 42
30457: PPUSH
30458: LD_STRING DA1-Cyrus-1
30460: PPUSH
30461: CALL_OW 91
30465: GO 30709
30467: LD_EXP 38
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30492
30477: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30478: LD_EXP 38
30482: PPUSH
30483: LD_STRING DA1-Huck-1
30485: PPUSH
30486: CALL_OW 91
30490: GO 30709
30492: LD_EXP 52
30496: DOUBLE
30497: EQUAL
30498: IFTRUE 30502
30500: GO 30517
30502: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30503: LD_EXP 52
30507: PPUSH
30508: LD_STRING DA1-Huck-1
30510: PPUSH
30511: CALL_OW 91
30515: GO 30709
30517: LD_EXP 44
30521: DOUBLE
30522: EQUAL
30523: IFTRUE 30527
30525: GO 30542
30527: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30528: LD_EXP 44
30532: PPUSH
30533: LD_STRING DA1-Brown-1
30535: PPUSH
30536: CALL_OW 91
30540: GO 30709
30542: LD_EXP 48
30546: DOUBLE
30547: EQUAL
30548: IFTRUE 30552
30550: GO 30567
30552: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30553: LD_EXP 48
30557: PPUSH
30558: LD_STRING DA1-Gary-1
30560: PPUSH
30561: CALL_OW 91
30565: GO 30709
30567: LD_EXP 51
30571: DOUBLE
30572: EQUAL
30573: IFTRUE 30577
30575: GO 30592
30577: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30578: LD_EXP 51
30582: PPUSH
30583: LD_STRING DA1-Con-1
30585: PPUSH
30586: CALL_OW 91
30590: GO 30709
30592: LD_EXP 57
30596: DOUBLE
30597: EQUAL
30598: IFTRUE 30602
30600: GO 30617
30602: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30603: LD_EXP 57
30607: PPUSH
30608: LD_STRING DA1-Kurt-1
30610: PPUSH
30611: CALL_OW 91
30615: GO 30709
30617: LD_EXP 50
30621: DOUBLE
30622: EQUAL
30623: IFTRUE 30627
30625: GO 30642
30627: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30628: LD_EXP 50
30632: PPUSH
30633: LD_STRING DA1-Yam-1
30635: PPUSH
30636: CALL_OW 91
30640: GO 30709
30642: LD_EXP 49
30646: DOUBLE
30647: EQUAL
30648: IFTRUE 30652
30650: GO 30667
30652: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30653: LD_EXP 49
30657: PPUSH
30658: LD_STRING DA1-Frank-1
30660: PPUSH
30661: CALL_OW 91
30665: GO 30709
30667: POP
// begin if GetSex ( unit ) = sex_male then
30668: LD_VAR 0 1
30672: PPUSH
30673: CALL_OW 258
30677: PUSH
30678: LD_INT 1
30680: EQUAL
30681: IFFALSE 30697
// ForceSay ( unit , DA1-Sol1-1 ) else
30683: LD_VAR 0 1
30687: PPUSH
30688: LD_STRING DA1-Sol1-1
30690: PPUSH
30691: CALL_OW 91
30695: GO 30709
// ForceSay ( unit , DA1-FSol1-1 ) ;
30697: LD_VAR 0 1
30701: PPUSH
30702: LD_STRING DA1-FSol1-1
30704: PPUSH
30705: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30709: LD_EXP 71
30713: PPUSH
30714: LD_STRING DA-Roth-1
30716: PPUSH
30717: CALL_OW 88
// if capturedUnit = 1 then
30721: LD_EXP 34
30725: PUSH
30726: LD_INT 1
30728: EQUAL
30729: IFFALSE 30757
// begin Say ( Simms , DA-Sim-1 ) ;
30731: LD_EXP 72
30735: PPUSH
30736: LD_STRING DA-Sim-1
30738: PPUSH
30739: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30743: LD_EXP 71
30747: PPUSH
30748: LD_STRING DA-Roth-2
30750: PPUSH
30751: CALL_OW 88
// end else
30755: GO 30769
// Say ( Simms , DA-Sim-2 ) ;
30757: LD_EXP 72
30761: PPUSH
30762: LD_STRING DA-Sim-2
30764: PPUSH
30765: CALL_OW 88
// case unit of JMM :
30769: LD_VAR 0 1
30773: PUSH
30774: LD_EXP 36
30778: DOUBLE
30779: EQUAL
30780: IFTRUE 30784
30782: GO 30799
30784: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30785: LD_EXP 36
30789: PPUSH
30790: LD_STRING DA1-JMM-1a
30792: PPUSH
30793: CALL_OW 91
30797: GO 31306
30799: LD_EXP 37
30803: DOUBLE
30804: EQUAL
30805: IFTRUE 30809
30807: GO 30824
30809: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30810: LD_EXP 37
30814: PPUSH
30815: LD_STRING DA1-Joan-1a
30817: PPUSH
30818: CALL_OW 91
30822: GO 31306
30824: LD_EXP 39
30828: DOUBLE
30829: EQUAL
30830: IFTRUE 30834
30832: GO 30849
30834: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30835: LD_EXP 39
30839: PPUSH
30840: LD_STRING DA1-Lisa-1a
30842: PPUSH
30843: CALL_OW 91
30847: GO 31306
30849: LD_EXP 40
30853: DOUBLE
30854: EQUAL
30855: IFTRUE 30859
30857: GO 30874
30859: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30860: LD_EXP 40
30864: PPUSH
30865: LD_STRING DA1-Don-1a
30867: PPUSH
30868: CALL_OW 91
30872: GO 31306
30874: LD_EXP 47
30878: DOUBLE
30879: EQUAL
30880: IFTRUE 30884
30882: GO 30899
30884: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30885: LD_EXP 47
30889: PPUSH
30890: LD_STRING DA1-Corn-1a
30892: PPUSH
30893: CALL_OW 91
30897: GO 31306
30899: LD_EXP 43
30903: DOUBLE
30904: EQUAL
30905: IFTRUE 30909
30907: GO 30924
30909: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30910: LD_EXP 43
30914: PPUSH
30915: LD_STRING DA1-Den-1a
30917: PPUSH
30918: CALL_OW 91
30922: GO 31306
30924: LD_EXP 41
30928: DOUBLE
30929: EQUAL
30930: IFTRUE 30934
30932: GO 30949
30934: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30935: LD_EXP 41
30939: PPUSH
30940: LD_STRING DA1-Bobby-1a
30942: PPUSH
30943: CALL_OW 91
30947: GO 31306
30949: LD_EXP 45
30953: DOUBLE
30954: EQUAL
30955: IFTRUE 30959
30957: GO 30974
30959: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30960: LD_EXP 45
30964: PPUSH
30965: LD_STRING DA1-Glad-1a
30967: PPUSH
30968: CALL_OW 91
30972: GO 31306
30974: LD_EXP 42
30978: DOUBLE
30979: EQUAL
30980: IFTRUE 30984
30982: GO 30999
30984: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30985: LD_EXP 42
30989: PPUSH
30990: LD_STRING DA1-Cyrus-1a
30992: PPUSH
30993: CALL_OW 91
30997: GO 31306
30999: LD_EXP 38
31003: DOUBLE
31004: EQUAL
31005: IFTRUE 31009
31007: GO 31024
31009: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31010: LD_EXP 38
31014: PPUSH
31015: LD_STRING DA1-Huck-1a
31017: PPUSH
31018: CALL_OW 91
31022: GO 31306
31024: LD_EXP 52
31028: DOUBLE
31029: EQUAL
31030: IFTRUE 31034
31032: GO 31049
31034: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31035: LD_EXP 52
31039: PPUSH
31040: LD_STRING DA1-Huck-1a
31042: PPUSH
31043: CALL_OW 91
31047: GO 31306
31049: LD_EXP 44
31053: DOUBLE
31054: EQUAL
31055: IFTRUE 31059
31057: GO 31074
31059: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31060: LD_EXP 44
31064: PPUSH
31065: LD_STRING DA1-Brown-1a
31067: PPUSH
31068: CALL_OW 91
31072: GO 31306
31074: LD_EXP 48
31078: DOUBLE
31079: EQUAL
31080: IFTRUE 31084
31082: GO 31099
31084: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31085: LD_EXP 48
31089: PPUSH
31090: LD_STRING DA1-Gary-1a
31092: PPUSH
31093: CALL_OW 91
31097: GO 31306
31099: LD_EXP 51
31103: DOUBLE
31104: EQUAL
31105: IFTRUE 31109
31107: GO 31124
31109: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31110: LD_EXP 51
31114: PPUSH
31115: LD_STRING DA1-Con-1a
31117: PPUSH
31118: CALL_OW 91
31122: GO 31306
31124: LD_EXP 57
31128: DOUBLE
31129: EQUAL
31130: IFTRUE 31134
31132: GO 31149
31134: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31135: LD_EXP 57
31139: PPUSH
31140: LD_STRING DA1-Kurt-1a
31142: PPUSH
31143: CALL_OW 91
31147: GO 31306
31149: LD_EXP 50
31153: DOUBLE
31154: EQUAL
31155: IFTRUE 31159
31157: GO 31174
31159: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31160: LD_EXP 50
31164: PPUSH
31165: LD_STRING DA1-Yam-1a
31167: PPUSH
31168: CALL_OW 91
31172: GO 31306
31174: LD_EXP 49
31178: DOUBLE
31179: EQUAL
31180: IFTRUE 31184
31182: GO 31199
31184: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31185: LD_EXP 49
31189: PPUSH
31190: LD_STRING DA1-Frank-1a
31192: PPUSH
31193: CALL_OW 91
31197: GO 31306
31199: POP
// begin join := rand ( 0 , 1 ) ;
31200: LD_ADDR_VAR 0 3
31204: PUSH
31205: LD_INT 0
31207: PPUSH
31208: LD_INT 1
31210: PPUSH
31211: CALL_OW 12
31215: ST_TO_ADDR
// if join then
31216: LD_VAR 0 3
31220: IFFALSE 31265
// begin if GetSex ( unit ) = sex_male then
31222: LD_VAR 0 1
31226: PPUSH
31227: CALL_OW 258
31231: PUSH
31232: LD_INT 1
31234: EQUAL
31235: IFFALSE 31251
// ForceSay ( unit , DA1-Sol1-1b ) else
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_STRING DA1-Sol1-1b
31244: PPUSH
31245: CALL_OW 91
31249: GO 31263
// ForceSay ( unit , DA1-FSol1-1b ) ;
31251: LD_VAR 0 1
31255: PPUSH
31256: LD_STRING DA1-FSol1-1b
31258: PPUSH
31259: CALL_OW 91
// end else
31263: GO 31306
// begin if GetSex ( unit ) = sex_male then
31265: LD_VAR 0 1
31269: PPUSH
31270: CALL_OW 258
31274: PUSH
31275: LD_INT 1
31277: EQUAL
31278: IFFALSE 31294
// ForceSay ( unit , DA1-Sol1-1a ) else
31280: LD_VAR 0 1
31284: PPUSH
31285: LD_STRING DA1-Sol1-1a
31287: PPUSH
31288: CALL_OW 91
31292: GO 31306
// ForceSay ( unit , DA1-FSol1-1a ) ;
31294: LD_VAR 0 1
31298: PPUSH
31299: LD_STRING DA1-FSol1-1a
31301: PPUSH
31302: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31306: LD_VAR 0 1
31310: PUSH
31311: LD_EXP 36
31315: EQUAL
31316: IFFALSE 31327
// begin YouLost ( JMMCaptured ) ;
31318: LD_STRING JMMCaptured
31320: PPUSH
31321: CALL_OW 104
// exit ;
31325: GO 31625
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31327: LD_VAR 0 1
31331: PUSH
31332: LD_EXP 40
31336: PUSH
31337: LD_EXP 43
31341: PUSH
31342: LD_EXP 41
31346: PUSH
31347: LD_EXP 38
31351: PUSH
31352: LD_EXP 52
31356: PUSH
31357: LD_EXP 44
31361: PUSH
31362: LD_EXP 50
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: IN
31376: PUSH
31377: LD_VAR 0 3
31381: OR
31382: IFFALSE 31481
// begin Say ( Roth , DA-Roth-3 ) ;
31384: LD_EXP 71
31388: PPUSH
31389: LD_STRING DA-Roth-3
31391: PPUSH
31392: CALL_OW 88
// SetSide ( unit , 7 ) ;
31396: LD_VAR 0 1
31400: PPUSH
31401: LD_INT 7
31403: PPUSH
31404: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31408: LD_ADDR_EXP 99
31412: PUSH
31413: LD_EXP 99
31417: PPUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_EXP 99
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 1
31434: ADD
31435: PPUSH
31436: CALL_OW 1
31440: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31441: LD_INT 260
31443: PPUSH
31444: LD_INT 235
31446: PPUSH
31447: LD_INT 1
31449: PPUSH
31450: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31454: LD_VAR 0 1
31458: PPUSH
31459: LD_INT 1000
31461: PPUSH
31462: CALL_OW 234
// DialogueOff ;
31466: CALL_OW 7
// ComFree ( unit ) ;
31470: LD_VAR 0 1
31474: PPUSH
31475: CALL_OW 139
// end else
31479: GO 31562
// begin Say ( Roth , DA-Roth-3a ) ;
31481: LD_EXP 71
31485: PPUSH
31486: LD_STRING DA-Roth-3a
31488: PPUSH
31489: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31493: LD_ADDR_EXP 35
31497: PUSH
31498: LD_EXP 35
31502: PUSH
31503: LD_VAR 0 1
31507: ADD
31508: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31509: LD_INT 260
31511: PPUSH
31512: LD_INT 235
31514: PPUSH
31515: LD_INT 1
31517: PPUSH
31518: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31522: LD_VAR 0 1
31526: PPUSH
31527: LD_INT 1000
31529: PPUSH
31530: CALL_OW 234
// DialogueOff ;
31534: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31538: LD_VAR 0 1
31542: PPUSH
31543: LD_INT 272
31545: PPUSH
31546: LD_INT 254
31548: PPUSH
31549: CALL_OW 111
// AddComHold ( unit ) ;
31553: LD_VAR 0 1
31557: PPUSH
31558: CALL_OW 200
// end ; if capturedUnit = 1 then
31562: LD_EXP 34
31566: PUSH
31567: LD_INT 1
31569: EQUAL
31570: IFFALSE 31625
// begin DialogueOn ;
31572: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31576: LD_EXP 36
31580: PPUSH
31581: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31585: LD_EXP 36
31589: PPUSH
31590: LD_STRING DAa-JMM-1
31592: PPUSH
31593: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31597: LD_EXP 36
31601: PPUSH
31602: LD_STRING DAa-JMM-1a
31604: PPUSH
31605: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31609: LD_EXP 36
31613: PPUSH
31614: LD_STRING DAa-JMM-1b
31616: PPUSH
31617: CALL_OW 88
// DialogueOff ;
31621: CALL_OW 7
// end ; end ;
31625: LD_VAR 0 2
31629: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31630: LD_EXP 15
31634: PUSH
31635: LD_INT 13
31637: GREATEREQUAL
31638: PUSH
31639: LD_INT 22
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 21
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PPUSH
31663: CALL_OW 69
31667: PUSH
31668: LD_INT 0
31670: EQUAL
31671: AND
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 2
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 2
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 50
31695: PUSH
31696: EMPTY
31697: LIST
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: LIST
31703: PPUSH
31704: CALL_OW 69
31708: PUSH
31709: LD_INT 0
31711: EQUAL
31712: AND
31713: PUSH
31714: LD_EXP 21
31718: AND
31719: PUSH
31720: LD_EXP 22
31724: AND
31725: PUSH
31726: LD_EXP 23
31730: AND
31731: IFFALSE 32212
31733: GO 31735
31735: DISABLE
// begin DialogueOn ;
31736: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31740: LD_EXP 36
31744: PPUSH
31745: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31749: LD_EXP 36
31753: PPUSH
31754: LD_STRING D20-JMM-1
31756: PPUSH
31757: CALL_OW 88
// if IsOK ( Joan ) then
31761: LD_EXP 37
31765: PPUSH
31766: CALL_OW 302
31770: IFFALSE 31784
// Say ( Joan , D20-Joan-1 ) ;
31772: LD_EXP 37
31776: PPUSH
31777: LD_STRING D20-Joan-1
31779: PPUSH
31780: CALL_OW 88
// if IsOk ( Lisa ) then
31784: LD_EXP 39
31788: PPUSH
31789: CALL_OW 302
31793: IFFALSE 31807
// Say ( Lisa , D20-Lisa-1 ) ;
31795: LD_EXP 39
31799: PPUSH
31800: LD_STRING D20-Lisa-1
31802: PPUSH
31803: CALL_OW 88
// if IsOk ( Donaldson ) then
31807: LD_EXP 40
31811: PPUSH
31812: CALL_OW 302
31816: IFFALSE 31830
// Say ( Donaldson , D20-Don-1 ) ;
31818: LD_EXP 40
31822: PPUSH
31823: LD_STRING D20-Don-1
31825: PPUSH
31826: CALL_OW 88
// if IsOK ( Cornel ) then
31830: LD_EXP 47
31834: PPUSH
31835: CALL_OW 302
31839: IFFALSE 31853
// Say ( Cornel , D20-Corn-1 ) ;
31841: LD_EXP 47
31845: PPUSH
31846: LD_STRING D20-Corn-1
31848: PPUSH
31849: CALL_OW 88
// if IsOk ( Denis ) then
31853: LD_EXP 43
31857: PPUSH
31858: CALL_OW 302
31862: IFFALSE 31876
// Say ( Denis , D20-Den-1 ) ;
31864: LD_EXP 43
31868: PPUSH
31869: LD_STRING D20-Den-1
31871: PPUSH
31872: CALL_OW 88
// if IsOk ( Bobby ) then
31876: LD_EXP 41
31880: PPUSH
31881: CALL_OW 302
31885: IFFALSE 31899
// Say ( Bobby , D20-Bobby-1 ) ;
31887: LD_EXP 41
31891: PPUSH
31892: LD_STRING D20-Bobby-1
31894: PPUSH
31895: CALL_OW 88
// if IsOk ( Gladstone ) then
31899: LD_EXP 45
31903: PPUSH
31904: CALL_OW 302
31908: IFFALSE 31922
// Say ( Gladstone , D20-Glad-1 ) ;
31910: LD_EXP 45
31914: PPUSH
31915: LD_STRING D20-Glad-1
31917: PPUSH
31918: CALL_OW 88
// if IsOk ( Cyrus ) then
31922: LD_EXP 42
31926: PPUSH
31927: CALL_OW 302
31931: IFFALSE 31945
// Say ( Cyrus , D20-Cyrus-1 ) ;
31933: LD_EXP 42
31937: PPUSH
31938: LD_STRING D20-Cyrus-1
31940: PPUSH
31941: CALL_OW 88
// if IsOk ( Stevens ) then
31945: LD_EXP 38
31949: PPUSH
31950: CALL_OW 302
31954: IFFALSE 31968
// Say ( Stevens , D20-Huck-1 ) ;
31956: LD_EXP 38
31960: PPUSH
31961: LD_STRING D20-Huck-1
31963: PPUSH
31964: CALL_OW 88
// if IsOk ( Brown ) then
31968: LD_EXP 44
31972: PPUSH
31973: CALL_OW 302
31977: IFFALSE 31991
// Say ( Brown , D20-Brown-1 ) ;
31979: LD_EXP 44
31983: PPUSH
31984: LD_STRING D20-Brown-1
31986: PPUSH
31987: CALL_OW 88
// if IsOk ( Gary ) then
31991: LD_EXP 48
31995: PPUSH
31996: CALL_OW 302
32000: IFFALSE 32014
// Say ( Gary , D20-Gary-1 ) ;
32002: LD_EXP 48
32006: PPUSH
32007: LD_STRING D20-Gary-1
32009: PPUSH
32010: CALL_OW 88
// if IsOk ( Connie ) then
32014: LD_EXP 51
32018: PPUSH
32019: CALL_OW 302
32023: IFFALSE 32037
// Say ( Connie , D20-Con-1 ) ;
32025: LD_EXP 51
32029: PPUSH
32030: LD_STRING D20-Con-1
32032: PPUSH
32033: CALL_OW 88
// if IsOk ( Kurt ) then
32037: LD_EXP 57
32041: PPUSH
32042: CALL_OW 302
32046: IFFALSE 32060
// Say ( Kurt , D20-Kurt-1 ) ;
32048: LD_EXP 57
32052: PPUSH
32053: LD_STRING D20-Kurt-1
32055: PPUSH
32056: CALL_OW 88
// if IsOk ( Kikuchi ) then
32060: LD_EXP 50
32064: PPUSH
32065: CALL_OW 302
32069: IFFALSE 32083
// Say ( Kikuchi , D20-Yam-1 ) ;
32071: LD_EXP 50
32075: PPUSH
32076: LD_STRING D20-Yam-1
32078: PPUSH
32079: CALL_OW 88
// if IsOk ( Frank ) then
32083: LD_EXP 49
32087: PPUSH
32088: CALL_OW 302
32092: IFFALSE 32106
// Say ( Frank , D20-Frank-1 ) ;
32094: LD_EXP 49
32098: PPUSH
32099: LD_STRING D20-Frank-1
32101: PPUSH
32102: CALL_OW 88
// DialogueOff ;
32106: CALL_OW 7
// if RothCaptured then
32110: LD_EXP 33
32114: IFFALSE 32128
// AddMedal ( Roth , 1 ) else
32116: LD_STRING Roth
32118: PPUSH
32119: LD_INT 1
32121: PPUSH
32122: CALL_OW 101
32126: GO 32139
// AddMedal ( Roth , - 1 ) ;
32128: LD_STRING Roth
32130: PPUSH
32131: LD_INT 1
32133: NEG
32134: PPUSH
32135: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32139: LD_EXP 27
32143: IFFALSE 32157
// AddMedal ( Project , 1 ) else
32145: LD_STRING Project
32147: PPUSH
32148: LD_INT 1
32150: PPUSH
32151: CALL_OW 101
32155: GO 32168
// AddMedal ( Project , - 1 ) ;
32157: LD_STRING Project
32159: PPUSH
32160: LD_INT 1
32162: NEG
32163: PPUSH
32164: CALL_OW 101
// if lostCounter = 0 then
32168: LD_EXP 32
32172: PUSH
32173: LD_INT 0
32175: EQUAL
32176: IFFALSE 32190
// AddMedal ( NoLosses , 1 ) else
32178: LD_STRING NoLosses
32180: PPUSH
32181: LD_INT 1
32183: PPUSH
32184: CALL_OW 101
32188: GO 32201
// AddMedal ( NoLosses , - 1 ) ;
32190: LD_STRING NoLosses
32192: PPUSH
32193: LD_INT 1
32195: NEG
32196: PPUSH
32197: CALL_OW 101
// GiveMedals ( MAIN ) ;
32201: LD_STRING MAIN
32203: PPUSH
32204: CALL_OW 102
// YouWin ;
32208: CALL_OW 103
// end ; end_of_file
32212: END
// export function CustomEvent ( event ) ; begin
32213: LD_INT 0
32215: PPUSH
// end ;
32216: LD_VAR 0 2
32220: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32221: LD_VAR 0 1
32225: PUSH
32226: LD_INT 1
32228: EQUAL
32229: PUSH
32230: LD_VAR 0 2
32234: PUSH
32235: LD_INT 4
32237: EQUAL
32238: AND
32239: PUSH
32240: LD_EXP 55
32244: PPUSH
32245: CALL_OW 300
32249: AND
32250: IFFALSE 32266
// begin wait ( 0 0$2 ) ;
32252: LD_INT 70
32254: PPUSH
32255: CALL_OW 67
// YouLost ( Dismissed ) ;
32259: LD_STRING Dismissed
32261: PPUSH
32262: CALL_OW 104
// end ; end ;
32266: PPOPN 2
32268: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32269: LD_VAR 0 2
32273: PPUSH
32274: LD_VAR 0 3
32278: PPUSH
32279: LD_INT 18
32281: PPUSH
32282: CALL_OW 309
32286: IFFALSE 32295
// YouLost ( Motherlode3 ) ;
32288: LD_STRING Motherlode3
32290: PPUSH
32291: CALL_OW 104
// end ;
32295: PPOPN 3
32297: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32298: LD_EXP 27
32302: NOT
32303: IFFALSE 32313
// behemothDone := true ;
32305: LD_ADDR_EXP 28
32309: PUSH
32310: LD_INT 1
32312: ST_TO_ADDR
// end ;
32313: PPOPN 1
32315: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32316: LD_VAR 0 1
32320: PPUSH
32321: CALL_OW 255
32325: PUSH
32326: LD_INT 1
32328: EQUAL
32329: PUSH
32330: LD_EXP 30
32334: AND
32335: PUSH
32336: LD_INT 22
32338: PUSH
32339: LD_INT 3
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 34
32348: PUSH
32349: LD_INT 48
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PPUSH
32360: CALL_OW 69
32364: AND
32365: PUSH
32366: LD_INT 22
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 34
32378: PUSH
32379: LD_INT 8
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PPUSH
32390: CALL_OW 69
32394: NOT
32395: AND
32396: IFFALSE 32448
// begin wait ( 0 0$5 ) ;
32398: LD_INT 175
32400: PPUSH
32401: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32405: LD_INT 22
32407: PUSH
32408: LD_INT 3
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PUSH
32415: LD_INT 34
32417: PUSH
32418: LD_INT 48
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PPUSH
32429: CALL_OW 69
32433: PUSH
32434: LD_INT 1
32436: ARRAY
32437: PPUSH
32438: LD_INT 60
32440: PPUSH
32441: LD_INT 95
32443: PPUSH
32444: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32448: LD_VAR 0 2
32452: PPUSH
32453: LD_VAR 0 3
32457: PPUSH
32458: LD_INT 18
32460: PPUSH
32461: CALL_OW 309
32465: IFFALSE 32525
// begin if GetSide ( unit ) = 1 then
32467: LD_VAR 0 1
32471: PPUSH
32472: CALL_OW 255
32476: PUSH
32477: LD_INT 1
32479: EQUAL
32480: IFFALSE 32496
// begin wait ( 0 0$6 ) ;
32482: LD_INT 210
32484: PPUSH
32485: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32489: LD_STRING Motherlode2
32491: PPUSH
32492: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32496: LD_VAR 0 1
32500: PPUSH
32501: CALL_OW 255
32505: PUSH
32506: LD_INT 8
32508: EQUAL
32509: IFFALSE 32525
// begin wait ( 0 0$6 ) ;
32511: LD_INT 210
32513: PPUSH
32514: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32518: LD_STRING Motherlode1
32520: PPUSH
32521: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32525: LD_VAR 0 1
32529: PPUSH
32530: CALL_OW 255
32534: PUSH
32535: LD_INT 3
32537: EQUAL
32538: IFFALSE 32559
// begin wait ( 0 0$5 ) ;
32540: LD_INT 175
32542: PPUSH
32543: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32547: LD_EXP 61
32551: PPUSH
32552: LD_STRING D18-Pla-1
32554: PPUSH
32555: CALL_OW 94
// end ; end ;
32559: PPOPN 3
32561: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32562: LD_VAR 0 1
32566: PUSH
32567: LD_EXP 70
32571: IN
32572: IFFALSE 32592
// begin behemothBuilders := behemothBuilders diff un ;
32574: LD_ADDR_EXP 70
32578: PUSH
32579: LD_EXP 70
32583: PUSH
32584: LD_VAR 0 1
32588: DIFF
32589: ST_TO_ADDR
// exit ;
32590: GO 32690
// end ; if un = JMM then
32592: LD_VAR 0 1
32596: PUSH
32597: LD_EXP 36
32601: EQUAL
32602: IFFALSE 32613
// begin YouLost ( JMM ) ;
32604: LD_STRING JMM
32606: PPUSH
32607: CALL_OW 104
// exit ;
32611: GO 32690
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32613: LD_VAR 0 1
32617: PUSH
32618: LD_INT 22
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: LD_INT 3
32630: PUSH
32631: LD_INT 25
32633: PUSH
32634: LD_INT 16
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 25
32643: PUSH
32644: LD_INT 12
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PPUSH
32660: CALL_OW 69
32664: IN
32665: IFFALSE 32681
// lostCounter := lostCounter + 1 ;
32667: LD_ADDR_EXP 32
32671: PUSH
32672: LD_EXP 32
32676: PUSH
32677: LD_INT 1
32679: PLUS
32680: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32681: LD_VAR 0 1
32685: PPUSH
32686: CALL 60758 0 1
// end ;
32690: PPOPN 1
32692: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32693: LD_VAR 0 1
32697: PPUSH
32698: LD_VAR 0 2
32702: PPUSH
32703: CALL 62870 0 2
// end ;
32707: PPOPN 2
32709: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32710: LD_VAR 0 1
32714: PPUSH
32715: CALL 61938 0 1
// end ;
32719: PPOPN 1
32721: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32722: LD_VAR 0 1
32726: PUSH
32727: LD_INT 22
32729: PUSH
32730: LD_INT 8
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 30
32739: PUSH
32740: LD_INT 2
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 23
32749: PUSH
32750: LD_INT 3
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: LIST
32761: PPUSH
32762: CALL_OW 69
32766: IN
32767: IFFALSE 32794
// begin ComUpgrade ( building ) ;
32769: LD_VAR 0 1
32773: PPUSH
32774: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32778: LD_EXP 58
32782: PPUSH
32783: LD_VAR 0 1
32787: PPUSH
32788: CALL 73212 0 2
// exit ;
32792: GO 32803
// end ; MCE_BuildingComplete ( building ) ;
32794: LD_VAR 0 1
32798: PPUSH
32799: CALL 62179 0 1
// end ;
32803: PPOPN 1
32805: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: LD_VAR 0 2
32815: PPUSH
32816: CALL 60454 0 2
// end ;
32820: PPOPN 2
32822: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32823: LD_VAR 0 1
32827: PPUSH
32828: LD_VAR 0 2
32832: PPUSH
32833: LD_VAR 0 3
32837: PPUSH
32838: LD_VAR 0 4
32842: PPUSH
32843: LD_VAR 0 5
32847: PPUSH
32848: CALL 60074 0 5
// end ;
32852: PPOPN 5
32854: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32855: LD_VAR 0 1
32859: PPUSH
32860: LD_VAR 0 2
32864: PPUSH
32865: CALL 59670 0 2
// end ;
32869: PPOPN 2
32871: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32872: LD_VAR 0 1
32876: PPUSH
32877: LD_VAR 0 2
32881: PPUSH
32882: LD_VAR 0 3
32886: PPUSH
32887: LD_VAR 0 4
32891: PPUSH
32892: CALL 59508 0 4
// end ;
32896: PPOPN 4
32898: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32899: LD_VAR 0 1
32903: PPUSH
32904: LD_VAR 0 2
32908: PPUSH
32909: LD_VAR 0 3
32913: PPUSH
32914: CALL 59283 0 3
// end ;
32918: PPOPN 3
32920: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32921: LD_VAR 0 1
32925: PPUSH
32926: LD_VAR 0 2
32930: PPUSH
32931: CALL 59168 0 2
// end ;
32935: PPOPN 2
32937: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32938: LD_VAR 0 1
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: CALL 63131 0 2
// end ;
32952: PPOPN 2
32954: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32955: LD_VAR 0 1
32959: PPUSH
32960: CALL_OW 255
32964: PUSH
32965: LD_INT 4
32967: EQUAL
32968: PUSH
32969: LD_VAR 0 1
32973: PUSH
32974: LD_EXP 18
32978: PUSH
32979: LD_INT 1
32981: ARRAY
32982: IN
32983: AND
32984: PUSH
32985: LD_EXP 19
32989: AND
32990: IFFALSE 33009
// begin ComMoveXY ( driver , 61 , 93 ) ;
32992: LD_VAR 0 1
32996: PPUSH
32997: LD_INT 61
32999: PPUSH
33000: LD_INT 93
33002: PPUSH
33003: CALL_OW 111
// exit ;
33007: GO 33033
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33009: LD_VAR 0 1
33013: PPUSH
33014: LD_VAR 0 2
33018: PPUSH
33019: LD_VAR 0 3
33023: PPUSH
33024: LD_VAR 0 4
33028: PPUSH
33029: CALL 63347 0 4
// end ;
33033: PPOPN 4
33035: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33036: LD_VAR 0 1
33040: PPUSH
33041: LD_VAR 0 2
33045: PPUSH
33046: CALL 58977 0 2
// end ;
33050: PPOPN 2
33052: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33053: LD_VAR 0 1
33057: PPUSH
33058: CALL 106299 0 1
// end ; end_of_file
33062: PPOPN 1
33064: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33065: LD_EXP 15
33069: PUSH
33070: LD_INT 2
33072: EQUAL
33073: IFFALSE 33552
33075: GO 33077
33077: DISABLE
33078: LD_INT 0
33080: PPUSH
// begin time := 0 0$40 ;
33081: LD_ADDR_VAR 0 1
33085: PUSH
33086: LD_INT 1400
33088: ST_TO_ADDR
// repeat wait ( time ) ;
33089: LD_VAR 0 1
33093: PPUSH
33094: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33098: LD_INT 1
33100: PPUSH
33101: LD_INT 5
33103: PPUSH
33104: CALL_OW 12
33108: PPUSH
33109: LD_INT 106
33111: PPUSH
33112: LD_INT 150
33114: PPUSH
33115: LD_INT 19
33117: PPUSH
33118: LD_INT 1
33120: PPUSH
33121: CALL_OW 56
// time := time + 0 0$9 ;
33125: LD_ADDR_VAR 0 1
33129: PUSH
33130: LD_VAR 0 1
33134: PUSH
33135: LD_INT 315
33137: PLUS
33138: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33139: LD_INT 455
33141: PPUSH
33142: LD_INT 840
33144: PPUSH
33145: CALL_OW 12
33149: PPUSH
33150: CALL_OW 67
// if Prob ( 50 ) then
33154: LD_INT 50
33156: PPUSH
33157: CALL_OW 13
33161: IFFALSE 33190
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33163: LD_INT 1
33165: PPUSH
33166: LD_INT 5
33168: PPUSH
33169: CALL_OW 12
33173: PPUSH
33174: LD_INT 62
33176: PPUSH
33177: LD_INT 108
33179: PPUSH
33180: LD_INT 10
33182: PPUSH
33183: LD_INT 1
33185: PPUSH
33186: CALL_OW 56
// until missionStage > 4 ;
33190: LD_EXP 15
33194: PUSH
33195: LD_INT 4
33197: GREATER
33198: IFFALSE 33089
// repeat wait ( 0 0$1 ) ;
33200: LD_INT 35
33202: PPUSH
33203: CALL_OW 67
// until missionStage = 6 ;
33207: LD_EXP 15
33211: PUSH
33212: LD_INT 6
33214: EQUAL
33215: IFFALSE 33200
// time := 0 0$50 ;
33217: LD_ADDR_VAR 0 1
33221: PUSH
33222: LD_INT 1750
33224: ST_TO_ADDR
// repeat wait ( time ) ;
33225: LD_VAR 0 1
33229: PPUSH
33230: CALL_OW 67
// if Prob ( 50 ) then
33234: LD_INT 50
33236: PPUSH
33237: CALL_OW 13
33241: IFFALSE 33270
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33243: LD_INT 1
33245: PPUSH
33246: LD_INT 5
33248: PPUSH
33249: CALL_OW 12
33253: PPUSH
33254: LD_INT 106
33256: PPUSH
33257: LD_INT 89
33259: PPUSH
33260: LD_INT 45
33262: PPUSH
33263: LD_INT 1
33265: PPUSH
33266: CALL_OW 56
// time := time + 0 0$3 ;
33270: LD_ADDR_VAR 0 1
33274: PUSH
33275: LD_VAR 0 1
33279: PUSH
33280: LD_INT 105
33282: PLUS
33283: ST_TO_ADDR
// if Prob ( 30 ) then
33284: LD_INT 30
33286: PPUSH
33287: CALL_OW 13
33291: IFFALSE 33337
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33293: LD_INT 525
33295: PPUSH
33296: LD_INT 735
33298: PPUSH
33299: CALL_OW 12
33303: PPUSH
33304: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33308: LD_INT 1
33310: PPUSH
33311: LD_INT 5
33313: PPUSH
33314: CALL_OW 12
33318: PPUSH
33319: LD_INT 21
33321: PPUSH
33322: LD_INT 26
33324: PPUSH
33325: LD_INT 12
33327: PPUSH
33328: LD_INT 1
33330: PPUSH
33331: CALL_OW 56
// end else
33335: GO 33373
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33337: LD_INT 700
33339: PPUSH
33340: LD_INT 1225
33342: PPUSH
33343: CALL_OW 12
33347: PPUSH
33348: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33352: LD_INT 1
33354: PPUSH
33355: LD_INT 5
33357: PPUSH
33358: CALL_OW 12
33362: PPUSH
33363: LD_INT 16
33365: PPUSH
33366: LD_INT 1
33368: PPUSH
33369: CALL_OW 55
// end ; if Prob ( 50 ) then
33373: LD_INT 50
33375: PPUSH
33376: CALL_OW 13
33380: IFFALSE 33426
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33382: LD_INT 700
33384: PPUSH
33385: LD_INT 1050
33387: PPUSH
33388: CALL_OW 12
33392: PPUSH
33393: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33397: LD_INT 1
33399: PPUSH
33400: LD_INT 5
33402: PPUSH
33403: CALL_OW 12
33407: PPUSH
33408: LD_INT 181
33410: PPUSH
33411: LD_INT 218
33413: PPUSH
33414: LD_INT 16
33416: PPUSH
33417: LD_INT 1
33419: PPUSH
33420: CALL_OW 56
// end else
33424: GO 33462
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33426: LD_INT 350
33428: PPUSH
33429: LD_INT 525
33431: PPUSH
33432: CALL_OW 12
33436: PPUSH
33437: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33441: LD_INT 1
33443: PPUSH
33444: LD_INT 5
33446: PPUSH
33447: CALL_OW 12
33451: PPUSH
33452: LD_INT 15
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33462: LD_INT 45
33464: PUSH
33465: LD_INT 32
33467: PUSH
33468: LD_INT 25
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: LIST
33475: PUSH
33476: LD_OWVAR 67
33480: ARRAY
33481: PPUSH
33482: CALL_OW 13
33486: IFFALSE 33530
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33488: LD_INT 525
33490: PPUSH
33491: LD_INT 875
33493: PPUSH
33494: CALL_OW 12
33498: PPUSH
33499: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33503: LD_INT 1
33505: PPUSH
33506: LD_INT 5
33508: PPUSH
33509: CALL_OW 12
33513: PPUSH
33514: LD_INT 103
33516: PPUSH
33517: LD_INT 140
33519: PPUSH
33520: LD_INT 20
33522: PPUSH
33523: LD_INT 1
33525: PPUSH
33526: CALL_OW 56
// end ; if time > 2 2$20 then
33530: LD_VAR 0 1
33534: PUSH
33535: LD_INT 4900
33537: GREATER
33538: IFFALSE 33548
// time := 0 0$50 ;
33540: LD_ADDR_VAR 0 1
33544: PUSH
33545: LD_INT 1750
33547: ST_TO_ADDR
// until false ;
33548: LD_INT 0
33550: IFFALSE 33225
// end ; end_of_file
33552: PPOPN 1
33554: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33555: LD_EXP 13
33559: PUSH
33560: LD_EXP 15
33564: PUSH
33565: LD_INT 6
33567: GREATEREQUAL
33568: AND
33569: IFFALSE 33606
33571: GO 33573
33573: DISABLE
// begin enable ;
33574: ENABLE
// missionTime := missionTime + 0 0$1 ;
33575: LD_ADDR_EXP 14
33579: PUSH
33580: LD_EXP 14
33584: PUSH
33585: LD_INT 35
33587: PLUS
33588: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33589: LD_ADDR_OWVAR 47
33593: PUSH
33594: LD_STRING #Am15-1
33596: PUSH
33597: LD_EXP 14
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: ST_TO_ADDR
// end ; end_of_file
33606: END
// export function InitNature ; begin
33607: LD_INT 0
33609: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33610: LD_INT 3
33612: PPUSH
33613: LD_INT 3
33615: PPUSH
33616: LD_INT 2
33618: PPUSH
33619: LD_INT 1
33621: PPUSH
33622: LD_INT 1
33624: PPUSH
33625: LD_INT 0
33627: PPUSH
33628: LD_INT 0
33630: PPUSH
33631: LD_INT 20
33633: PPUSH
33634: LD_INT 0
33636: PPUSH
33637: CALL 98053 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33641: LD_INT 2
33643: PPUSH
33644: LD_INT 1
33646: PPUSH
33647: LD_INT 1
33649: PPUSH
33650: LD_INT 1
33652: PPUSH
33653: LD_INT 1
33655: PPUSH
33656: LD_INT 0
33658: PPUSH
33659: LD_INT 0
33661: PPUSH
33662: LD_INT 21
33664: PPUSH
33665: LD_INT 0
33667: PPUSH
33668: CALL 98053 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33672: LD_INT 4
33674: PPUSH
33675: LD_INT 1
33677: PPUSH
33678: LD_INT 2
33680: PPUSH
33681: LD_INT 4
33683: PPUSH
33684: LD_INT 2
33686: PPUSH
33687: LD_INT 1
33689: PPUSH
33690: LD_INT 0
33692: PPUSH
33693: LD_INT 22
33695: PPUSH
33696: LD_INT 0
33698: PPUSH
33699: CALL 98053 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33703: LD_INT 0
33705: PPUSH
33706: LD_INT 0
33708: PPUSH
33709: LD_INT 0
33711: PPUSH
33712: LD_INT 0
33714: PPUSH
33715: LD_INT 0
33717: PPUSH
33718: LD_INT 0
33720: PPUSH
33721: LD_INT 9
33723: PPUSH
33724: LD_INT 0
33726: PPUSH
33727: LD_INT 23
33729: PPUSH
33730: CALL 98053 0 9
// end ; end_of_file
33734: LD_VAR 0 1
33738: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33739: GO 33741
33741: DISABLE
// begin ru_radar := 98 ;
33742: LD_ADDR_EXP 92
33746: PUSH
33747: LD_INT 98
33749: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33750: LD_ADDR_EXP 93
33754: PUSH
33755: LD_INT 89
33757: ST_TO_ADDR
// us_hack := 99 ;
33758: LD_ADDR_EXP 94
33762: PUSH
33763: LD_INT 99
33765: ST_TO_ADDR
// us_artillery := 97 ;
33766: LD_ADDR_EXP 95
33770: PUSH
33771: LD_INT 97
33773: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33774: LD_ADDR_EXP 96
33778: PUSH
33779: LD_INT 91
33781: ST_TO_ADDR
// end ; end_of_file
33782: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33783: LD_INT 0
33785: PPUSH
33786: PPUSH
// skirmish := false ;
33787: LD_ADDR_EXP 97
33791: PUSH
33792: LD_INT 0
33794: ST_TO_ADDR
// debug_mc := false ;
33795: LD_ADDR_EXP 98
33799: PUSH
33800: LD_INT 0
33802: ST_TO_ADDR
// mc_bases := [ ] ;
33803: LD_ADDR_EXP 99
33807: PUSH
33808: EMPTY
33809: ST_TO_ADDR
// mc_sides := [ ] ;
33810: LD_ADDR_EXP 125
33814: PUSH
33815: EMPTY
33816: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33817: LD_ADDR_EXP 100
33821: PUSH
33822: EMPTY
33823: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33824: LD_ADDR_EXP 101
33828: PUSH
33829: EMPTY
33830: ST_TO_ADDR
// mc_need_heal := [ ] ;
33831: LD_ADDR_EXP 102
33835: PUSH
33836: EMPTY
33837: ST_TO_ADDR
// mc_healers := [ ] ;
33838: LD_ADDR_EXP 103
33842: PUSH
33843: EMPTY
33844: ST_TO_ADDR
// mc_build_list := [ ] ;
33845: LD_ADDR_EXP 104
33849: PUSH
33850: EMPTY
33851: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33852: LD_ADDR_EXP 131
33856: PUSH
33857: EMPTY
33858: ST_TO_ADDR
// mc_builders := [ ] ;
33859: LD_ADDR_EXP 105
33863: PUSH
33864: EMPTY
33865: ST_TO_ADDR
// mc_construct_list := [ ] ;
33866: LD_ADDR_EXP 106
33870: PUSH
33871: EMPTY
33872: ST_TO_ADDR
// mc_turret_list := [ ] ;
33873: LD_ADDR_EXP 107
33877: PUSH
33878: EMPTY
33879: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33880: LD_ADDR_EXP 108
33884: PUSH
33885: EMPTY
33886: ST_TO_ADDR
// mc_miners := [ ] ;
33887: LD_ADDR_EXP 113
33891: PUSH
33892: EMPTY
33893: ST_TO_ADDR
// mc_mines := [ ] ;
33894: LD_ADDR_EXP 112
33898: PUSH
33899: EMPTY
33900: ST_TO_ADDR
// mc_minefields := [ ] ;
33901: LD_ADDR_EXP 114
33905: PUSH
33906: EMPTY
33907: ST_TO_ADDR
// mc_crates := [ ] ;
33908: LD_ADDR_EXP 115
33912: PUSH
33913: EMPTY
33914: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33915: LD_ADDR_EXP 116
33919: PUSH
33920: EMPTY
33921: ST_TO_ADDR
// mc_crates_area := [ ] ;
33922: LD_ADDR_EXP 117
33926: PUSH
33927: EMPTY
33928: ST_TO_ADDR
// mc_vehicles := [ ] ;
33929: LD_ADDR_EXP 118
33933: PUSH
33934: EMPTY
33935: ST_TO_ADDR
// mc_attack := [ ] ;
33936: LD_ADDR_EXP 119
33940: PUSH
33941: EMPTY
33942: ST_TO_ADDR
// mc_produce := [ ] ;
33943: LD_ADDR_EXP 120
33947: PUSH
33948: EMPTY
33949: ST_TO_ADDR
// mc_defender := [ ] ;
33950: LD_ADDR_EXP 121
33954: PUSH
33955: EMPTY
33956: ST_TO_ADDR
// mc_parking := [ ] ;
33957: LD_ADDR_EXP 123
33961: PUSH
33962: EMPTY
33963: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33964: LD_ADDR_EXP 109
33968: PUSH
33969: EMPTY
33970: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33971: LD_ADDR_EXP 111
33975: PUSH
33976: EMPTY
33977: ST_TO_ADDR
// mc_scan := [ ] ;
33978: LD_ADDR_EXP 122
33982: PUSH
33983: EMPTY
33984: ST_TO_ADDR
// mc_scan_area := [ ] ;
33985: LD_ADDR_EXP 124
33989: PUSH
33990: EMPTY
33991: ST_TO_ADDR
// mc_tech := [ ] ;
33992: LD_ADDR_EXP 126
33996: PUSH
33997: EMPTY
33998: ST_TO_ADDR
// mc_class := [ ] ;
33999: LD_ADDR_EXP 140
34003: PUSH
34004: EMPTY
34005: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34006: LD_ADDR_EXP 141
34010: PUSH
34011: EMPTY
34012: ST_TO_ADDR
// end ;
34013: LD_VAR 0 1
34017: RET
// export function MC_Kill ( base ) ; begin
34018: LD_INT 0
34020: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34021: LD_ADDR_EXP 99
34025: PUSH
34026: LD_EXP 99
34030: PPUSH
34031: LD_VAR 0 1
34035: PPUSH
34036: EMPTY
34037: PPUSH
34038: CALL_OW 1
34042: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34043: LD_ADDR_EXP 100
34047: PUSH
34048: LD_EXP 100
34052: PPUSH
34053: LD_VAR 0 1
34057: PPUSH
34058: EMPTY
34059: PPUSH
34060: CALL_OW 1
34064: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34065: LD_ADDR_EXP 101
34069: PUSH
34070: LD_EXP 101
34074: PPUSH
34075: LD_VAR 0 1
34079: PPUSH
34080: EMPTY
34081: PPUSH
34082: CALL_OW 1
34086: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34087: LD_ADDR_EXP 102
34091: PUSH
34092: LD_EXP 102
34096: PPUSH
34097: LD_VAR 0 1
34101: PPUSH
34102: EMPTY
34103: PPUSH
34104: CALL_OW 1
34108: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34109: LD_ADDR_EXP 103
34113: PUSH
34114: LD_EXP 103
34118: PPUSH
34119: LD_VAR 0 1
34123: PPUSH
34124: EMPTY
34125: PPUSH
34126: CALL_OW 1
34130: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34131: LD_ADDR_EXP 104
34135: PUSH
34136: LD_EXP 104
34140: PPUSH
34141: LD_VAR 0 1
34145: PPUSH
34146: EMPTY
34147: PPUSH
34148: CALL_OW 1
34152: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34153: LD_ADDR_EXP 105
34157: PUSH
34158: LD_EXP 105
34162: PPUSH
34163: LD_VAR 0 1
34167: PPUSH
34168: EMPTY
34169: PPUSH
34170: CALL_OW 1
34174: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34175: LD_ADDR_EXP 106
34179: PUSH
34180: LD_EXP 106
34184: PPUSH
34185: LD_VAR 0 1
34189: PPUSH
34190: EMPTY
34191: PPUSH
34192: CALL_OW 1
34196: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34197: LD_ADDR_EXP 107
34201: PUSH
34202: LD_EXP 107
34206: PPUSH
34207: LD_VAR 0 1
34211: PPUSH
34212: EMPTY
34213: PPUSH
34214: CALL_OW 1
34218: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34219: LD_ADDR_EXP 108
34223: PUSH
34224: LD_EXP 108
34228: PPUSH
34229: LD_VAR 0 1
34233: PPUSH
34234: EMPTY
34235: PPUSH
34236: CALL_OW 1
34240: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34241: LD_ADDR_EXP 109
34245: PUSH
34246: LD_EXP 109
34250: PPUSH
34251: LD_VAR 0 1
34255: PPUSH
34256: EMPTY
34257: PPUSH
34258: CALL_OW 1
34262: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34263: LD_ADDR_EXP 110
34267: PUSH
34268: LD_EXP 110
34272: PPUSH
34273: LD_VAR 0 1
34277: PPUSH
34278: LD_INT 0
34280: PPUSH
34281: CALL_OW 1
34285: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34286: LD_ADDR_EXP 111
34290: PUSH
34291: LD_EXP 111
34295: PPUSH
34296: LD_VAR 0 1
34300: PPUSH
34301: EMPTY
34302: PPUSH
34303: CALL_OW 1
34307: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34308: LD_ADDR_EXP 112
34312: PUSH
34313: LD_EXP 112
34317: PPUSH
34318: LD_VAR 0 1
34322: PPUSH
34323: EMPTY
34324: PPUSH
34325: CALL_OW 1
34329: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34330: LD_ADDR_EXP 113
34334: PUSH
34335: LD_EXP 113
34339: PPUSH
34340: LD_VAR 0 1
34344: PPUSH
34345: EMPTY
34346: PPUSH
34347: CALL_OW 1
34351: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34352: LD_ADDR_EXP 114
34356: PUSH
34357: LD_EXP 114
34361: PPUSH
34362: LD_VAR 0 1
34366: PPUSH
34367: EMPTY
34368: PPUSH
34369: CALL_OW 1
34373: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34374: LD_ADDR_EXP 115
34378: PUSH
34379: LD_EXP 115
34383: PPUSH
34384: LD_VAR 0 1
34388: PPUSH
34389: EMPTY
34390: PPUSH
34391: CALL_OW 1
34395: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34396: LD_ADDR_EXP 116
34400: PUSH
34401: LD_EXP 116
34405: PPUSH
34406: LD_VAR 0 1
34410: PPUSH
34411: EMPTY
34412: PPUSH
34413: CALL_OW 1
34417: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34418: LD_ADDR_EXP 117
34422: PUSH
34423: LD_EXP 117
34427: PPUSH
34428: LD_VAR 0 1
34432: PPUSH
34433: EMPTY
34434: PPUSH
34435: CALL_OW 1
34439: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34440: LD_ADDR_EXP 118
34444: PUSH
34445: LD_EXP 118
34449: PPUSH
34450: LD_VAR 0 1
34454: PPUSH
34455: EMPTY
34456: PPUSH
34457: CALL_OW 1
34461: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34462: LD_ADDR_EXP 119
34466: PUSH
34467: LD_EXP 119
34471: PPUSH
34472: LD_VAR 0 1
34476: PPUSH
34477: EMPTY
34478: PPUSH
34479: CALL_OW 1
34483: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34484: LD_ADDR_EXP 120
34488: PUSH
34489: LD_EXP 120
34493: PPUSH
34494: LD_VAR 0 1
34498: PPUSH
34499: EMPTY
34500: PPUSH
34501: CALL_OW 1
34505: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34506: LD_ADDR_EXP 121
34510: PUSH
34511: LD_EXP 121
34515: PPUSH
34516: LD_VAR 0 1
34520: PPUSH
34521: EMPTY
34522: PPUSH
34523: CALL_OW 1
34527: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34528: LD_ADDR_EXP 122
34532: PUSH
34533: LD_EXP 122
34537: PPUSH
34538: LD_VAR 0 1
34542: PPUSH
34543: EMPTY
34544: PPUSH
34545: CALL_OW 1
34549: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34550: LD_ADDR_EXP 123
34554: PUSH
34555: LD_EXP 123
34559: PPUSH
34560: LD_VAR 0 1
34564: PPUSH
34565: EMPTY
34566: PPUSH
34567: CALL_OW 1
34571: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34572: LD_ADDR_EXP 124
34576: PUSH
34577: LD_EXP 124
34581: PPUSH
34582: LD_VAR 0 1
34586: PPUSH
34587: EMPTY
34588: PPUSH
34589: CALL_OW 1
34593: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34594: LD_ADDR_EXP 126
34598: PUSH
34599: LD_EXP 126
34603: PPUSH
34604: LD_VAR 0 1
34608: PPUSH
34609: EMPTY
34610: PPUSH
34611: CALL_OW 1
34615: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34616: LD_ADDR_EXP 128
34620: PUSH
34621: LD_EXP 128
34625: PPUSH
34626: LD_VAR 0 1
34630: PPUSH
34631: EMPTY
34632: PPUSH
34633: CALL_OW 1
34637: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34638: LD_ADDR_EXP 129
34642: PUSH
34643: LD_EXP 129
34647: PPUSH
34648: LD_VAR 0 1
34652: PPUSH
34653: EMPTY
34654: PPUSH
34655: CALL_OW 1
34659: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34660: LD_ADDR_EXP 130
34664: PUSH
34665: LD_EXP 130
34669: PPUSH
34670: LD_VAR 0 1
34674: PPUSH
34675: EMPTY
34676: PPUSH
34677: CALL_OW 1
34681: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34682: LD_ADDR_EXP 131
34686: PUSH
34687: LD_EXP 131
34691: PPUSH
34692: LD_VAR 0 1
34696: PPUSH
34697: EMPTY
34698: PPUSH
34699: CALL_OW 1
34703: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34704: LD_ADDR_EXP 132
34708: PUSH
34709: LD_EXP 132
34713: PPUSH
34714: LD_VAR 0 1
34718: PPUSH
34719: EMPTY
34720: PPUSH
34721: CALL_OW 1
34725: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34726: LD_ADDR_EXP 133
34730: PUSH
34731: LD_EXP 133
34735: PPUSH
34736: LD_VAR 0 1
34740: PPUSH
34741: EMPTY
34742: PPUSH
34743: CALL_OW 1
34747: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34748: LD_ADDR_EXP 134
34752: PUSH
34753: LD_EXP 134
34757: PPUSH
34758: LD_VAR 0 1
34762: PPUSH
34763: EMPTY
34764: PPUSH
34765: CALL_OW 1
34769: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34770: LD_ADDR_EXP 135
34774: PUSH
34775: LD_EXP 135
34779: PPUSH
34780: LD_VAR 0 1
34784: PPUSH
34785: EMPTY
34786: PPUSH
34787: CALL_OW 1
34791: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34792: LD_ADDR_EXP 136
34796: PUSH
34797: LD_EXP 136
34801: PPUSH
34802: LD_VAR 0 1
34806: PPUSH
34807: EMPTY
34808: PPUSH
34809: CALL_OW 1
34813: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34814: LD_ADDR_EXP 137
34818: PUSH
34819: LD_EXP 137
34823: PPUSH
34824: LD_VAR 0 1
34828: PPUSH
34829: EMPTY
34830: PPUSH
34831: CALL_OW 1
34835: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34836: LD_ADDR_EXP 138
34840: PUSH
34841: LD_EXP 138
34845: PPUSH
34846: LD_VAR 0 1
34850: PPUSH
34851: EMPTY
34852: PPUSH
34853: CALL_OW 1
34857: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34858: LD_ADDR_EXP 139
34862: PUSH
34863: LD_EXP 139
34867: PPUSH
34868: LD_VAR 0 1
34872: PPUSH
34873: EMPTY
34874: PPUSH
34875: CALL_OW 1
34879: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34880: LD_ADDR_EXP 140
34884: PUSH
34885: LD_EXP 140
34889: PPUSH
34890: LD_VAR 0 1
34894: PPUSH
34895: EMPTY
34896: PPUSH
34897: CALL_OW 1
34901: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34902: LD_ADDR_EXP 141
34906: PUSH
34907: LD_EXP 141
34911: PPUSH
34912: LD_VAR 0 1
34916: PPUSH
34917: LD_INT 0
34919: PPUSH
34920: CALL_OW 1
34924: ST_TO_ADDR
// end ;
34925: LD_VAR 0 2
34929: RET
// export function MC_Add ( side , units ) ; var base ; begin
34930: LD_INT 0
34932: PPUSH
34933: PPUSH
// base := mc_bases + 1 ;
34934: LD_ADDR_VAR 0 4
34938: PUSH
34939: LD_EXP 99
34943: PUSH
34944: LD_INT 1
34946: PLUS
34947: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34948: LD_ADDR_EXP 125
34952: PUSH
34953: LD_EXP 125
34957: PPUSH
34958: LD_VAR 0 4
34962: PPUSH
34963: LD_VAR 0 1
34967: PPUSH
34968: CALL_OW 1
34972: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34973: LD_ADDR_EXP 99
34977: PUSH
34978: LD_EXP 99
34982: PPUSH
34983: LD_VAR 0 4
34987: PPUSH
34988: LD_VAR 0 2
34992: PPUSH
34993: CALL_OW 1
34997: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34998: LD_ADDR_EXP 100
35002: PUSH
35003: LD_EXP 100
35007: PPUSH
35008: LD_VAR 0 4
35012: PPUSH
35013: EMPTY
35014: PPUSH
35015: CALL_OW 1
35019: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35020: LD_ADDR_EXP 101
35024: PUSH
35025: LD_EXP 101
35029: PPUSH
35030: LD_VAR 0 4
35034: PPUSH
35035: EMPTY
35036: PPUSH
35037: CALL_OW 1
35041: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35042: LD_ADDR_EXP 102
35046: PUSH
35047: LD_EXP 102
35051: PPUSH
35052: LD_VAR 0 4
35056: PPUSH
35057: EMPTY
35058: PPUSH
35059: CALL_OW 1
35063: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35064: LD_ADDR_EXP 103
35068: PUSH
35069: LD_EXP 103
35073: PPUSH
35074: LD_VAR 0 4
35078: PPUSH
35079: EMPTY
35080: PPUSH
35081: CALL_OW 1
35085: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35086: LD_ADDR_EXP 104
35090: PUSH
35091: LD_EXP 104
35095: PPUSH
35096: LD_VAR 0 4
35100: PPUSH
35101: EMPTY
35102: PPUSH
35103: CALL_OW 1
35107: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35108: LD_ADDR_EXP 105
35112: PUSH
35113: LD_EXP 105
35117: PPUSH
35118: LD_VAR 0 4
35122: PPUSH
35123: EMPTY
35124: PPUSH
35125: CALL_OW 1
35129: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35130: LD_ADDR_EXP 106
35134: PUSH
35135: LD_EXP 106
35139: PPUSH
35140: LD_VAR 0 4
35144: PPUSH
35145: EMPTY
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35152: LD_ADDR_EXP 107
35156: PUSH
35157: LD_EXP 107
35161: PPUSH
35162: LD_VAR 0 4
35166: PPUSH
35167: EMPTY
35168: PPUSH
35169: CALL_OW 1
35173: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35174: LD_ADDR_EXP 108
35178: PUSH
35179: LD_EXP 108
35183: PPUSH
35184: LD_VAR 0 4
35188: PPUSH
35189: EMPTY
35190: PPUSH
35191: CALL_OW 1
35195: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35196: LD_ADDR_EXP 109
35200: PUSH
35201: LD_EXP 109
35205: PPUSH
35206: LD_VAR 0 4
35210: PPUSH
35211: EMPTY
35212: PPUSH
35213: CALL_OW 1
35217: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35218: LD_ADDR_EXP 110
35222: PUSH
35223: LD_EXP 110
35227: PPUSH
35228: LD_VAR 0 4
35232: PPUSH
35233: LD_INT 0
35235: PPUSH
35236: CALL_OW 1
35240: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35241: LD_ADDR_EXP 111
35245: PUSH
35246: LD_EXP 111
35250: PPUSH
35251: LD_VAR 0 4
35255: PPUSH
35256: EMPTY
35257: PPUSH
35258: CALL_OW 1
35262: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35263: LD_ADDR_EXP 112
35267: PUSH
35268: LD_EXP 112
35272: PPUSH
35273: LD_VAR 0 4
35277: PPUSH
35278: EMPTY
35279: PPUSH
35280: CALL_OW 1
35284: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35285: LD_ADDR_EXP 113
35289: PUSH
35290: LD_EXP 113
35294: PPUSH
35295: LD_VAR 0 4
35299: PPUSH
35300: EMPTY
35301: PPUSH
35302: CALL_OW 1
35306: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35307: LD_ADDR_EXP 114
35311: PUSH
35312: LD_EXP 114
35316: PPUSH
35317: LD_VAR 0 4
35321: PPUSH
35322: EMPTY
35323: PPUSH
35324: CALL_OW 1
35328: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35329: LD_ADDR_EXP 115
35333: PUSH
35334: LD_EXP 115
35338: PPUSH
35339: LD_VAR 0 4
35343: PPUSH
35344: EMPTY
35345: PPUSH
35346: CALL_OW 1
35350: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35351: LD_ADDR_EXP 116
35355: PUSH
35356: LD_EXP 116
35360: PPUSH
35361: LD_VAR 0 4
35365: PPUSH
35366: EMPTY
35367: PPUSH
35368: CALL_OW 1
35372: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35373: LD_ADDR_EXP 117
35377: PUSH
35378: LD_EXP 117
35382: PPUSH
35383: LD_VAR 0 4
35387: PPUSH
35388: EMPTY
35389: PPUSH
35390: CALL_OW 1
35394: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35395: LD_ADDR_EXP 118
35399: PUSH
35400: LD_EXP 118
35404: PPUSH
35405: LD_VAR 0 4
35409: PPUSH
35410: EMPTY
35411: PPUSH
35412: CALL_OW 1
35416: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35417: LD_ADDR_EXP 119
35421: PUSH
35422: LD_EXP 119
35426: PPUSH
35427: LD_VAR 0 4
35431: PPUSH
35432: EMPTY
35433: PPUSH
35434: CALL_OW 1
35438: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35439: LD_ADDR_EXP 120
35443: PUSH
35444: LD_EXP 120
35448: PPUSH
35449: LD_VAR 0 4
35453: PPUSH
35454: EMPTY
35455: PPUSH
35456: CALL_OW 1
35460: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35461: LD_ADDR_EXP 121
35465: PUSH
35466: LD_EXP 121
35470: PPUSH
35471: LD_VAR 0 4
35475: PPUSH
35476: EMPTY
35477: PPUSH
35478: CALL_OW 1
35482: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35483: LD_ADDR_EXP 122
35487: PUSH
35488: LD_EXP 122
35492: PPUSH
35493: LD_VAR 0 4
35497: PPUSH
35498: EMPTY
35499: PPUSH
35500: CALL_OW 1
35504: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35505: LD_ADDR_EXP 123
35509: PUSH
35510: LD_EXP 123
35514: PPUSH
35515: LD_VAR 0 4
35519: PPUSH
35520: EMPTY
35521: PPUSH
35522: CALL_OW 1
35526: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35527: LD_ADDR_EXP 124
35531: PUSH
35532: LD_EXP 124
35536: PPUSH
35537: LD_VAR 0 4
35541: PPUSH
35542: EMPTY
35543: PPUSH
35544: CALL_OW 1
35548: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35549: LD_ADDR_EXP 126
35553: PUSH
35554: LD_EXP 126
35558: PPUSH
35559: LD_VAR 0 4
35563: PPUSH
35564: EMPTY
35565: PPUSH
35566: CALL_OW 1
35570: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35571: LD_ADDR_EXP 128
35575: PUSH
35576: LD_EXP 128
35580: PPUSH
35581: LD_VAR 0 4
35585: PPUSH
35586: EMPTY
35587: PPUSH
35588: CALL_OW 1
35592: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35593: LD_ADDR_EXP 129
35597: PUSH
35598: LD_EXP 129
35602: PPUSH
35603: LD_VAR 0 4
35607: PPUSH
35608: EMPTY
35609: PPUSH
35610: CALL_OW 1
35614: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35615: LD_ADDR_EXP 130
35619: PUSH
35620: LD_EXP 130
35624: PPUSH
35625: LD_VAR 0 4
35629: PPUSH
35630: EMPTY
35631: PPUSH
35632: CALL_OW 1
35636: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35637: LD_ADDR_EXP 131
35641: PUSH
35642: LD_EXP 131
35646: PPUSH
35647: LD_VAR 0 4
35651: PPUSH
35652: EMPTY
35653: PPUSH
35654: CALL_OW 1
35658: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35659: LD_ADDR_EXP 132
35663: PUSH
35664: LD_EXP 132
35668: PPUSH
35669: LD_VAR 0 4
35673: PPUSH
35674: EMPTY
35675: PPUSH
35676: CALL_OW 1
35680: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35681: LD_ADDR_EXP 133
35685: PUSH
35686: LD_EXP 133
35690: PPUSH
35691: LD_VAR 0 4
35695: PPUSH
35696: EMPTY
35697: PPUSH
35698: CALL_OW 1
35702: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35703: LD_ADDR_EXP 134
35707: PUSH
35708: LD_EXP 134
35712: PPUSH
35713: LD_VAR 0 4
35717: PPUSH
35718: EMPTY
35719: PPUSH
35720: CALL_OW 1
35724: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35725: LD_ADDR_EXP 135
35729: PUSH
35730: LD_EXP 135
35734: PPUSH
35735: LD_VAR 0 4
35739: PPUSH
35740: EMPTY
35741: PPUSH
35742: CALL_OW 1
35746: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35747: LD_ADDR_EXP 136
35751: PUSH
35752: LD_EXP 136
35756: PPUSH
35757: LD_VAR 0 4
35761: PPUSH
35762: EMPTY
35763: PPUSH
35764: CALL_OW 1
35768: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35769: LD_ADDR_EXP 137
35773: PUSH
35774: LD_EXP 137
35778: PPUSH
35779: LD_VAR 0 4
35783: PPUSH
35784: EMPTY
35785: PPUSH
35786: CALL_OW 1
35790: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35791: LD_ADDR_EXP 138
35795: PUSH
35796: LD_EXP 138
35800: PPUSH
35801: LD_VAR 0 4
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35813: LD_ADDR_EXP 139
35817: PUSH
35818: LD_EXP 139
35822: PPUSH
35823: LD_VAR 0 4
35827: PPUSH
35828: EMPTY
35829: PPUSH
35830: CALL_OW 1
35834: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35835: LD_ADDR_EXP 140
35839: PUSH
35840: LD_EXP 140
35844: PPUSH
35845: LD_VAR 0 4
35849: PPUSH
35850: EMPTY
35851: PPUSH
35852: CALL_OW 1
35856: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35857: LD_ADDR_EXP 141
35861: PUSH
35862: LD_EXP 141
35866: PPUSH
35867: LD_VAR 0 4
35871: PPUSH
35872: LD_INT 0
35874: PPUSH
35875: CALL_OW 1
35879: ST_TO_ADDR
// result := base ;
35880: LD_ADDR_VAR 0 3
35884: PUSH
35885: LD_VAR 0 4
35889: ST_TO_ADDR
// end ;
35890: LD_VAR 0 3
35894: RET
// export function MC_Start ( ) ; var i ; begin
35895: LD_INT 0
35897: PPUSH
35898: PPUSH
// for i = 1 to mc_bases do
35899: LD_ADDR_VAR 0 2
35903: PUSH
35904: DOUBLE
35905: LD_INT 1
35907: DEC
35908: ST_TO_ADDR
35909: LD_EXP 99
35913: PUSH
35914: FOR_TO
35915: IFFALSE 36992
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35917: LD_ADDR_EXP 99
35921: PUSH
35922: LD_EXP 99
35926: PPUSH
35927: LD_VAR 0 2
35931: PPUSH
35932: LD_EXP 99
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 0
35945: DIFF
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35952: LD_ADDR_EXP 100
35956: PUSH
35957: LD_EXP 100
35961: PPUSH
35962: LD_VAR 0 2
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35974: LD_ADDR_EXP 101
35978: PUSH
35979: LD_EXP 101
35983: PPUSH
35984: LD_VAR 0 2
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35996: LD_ADDR_EXP 102
36000: PUSH
36001: LD_EXP 102
36005: PPUSH
36006: LD_VAR 0 2
36010: PPUSH
36011: EMPTY
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36018: LD_ADDR_EXP 103
36022: PUSH
36023: LD_EXP 103
36027: PPUSH
36028: LD_VAR 0 2
36032: PPUSH
36033: EMPTY
36034: PUSH
36035: EMPTY
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PPUSH
36041: CALL_OW 1
36045: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36046: LD_ADDR_EXP 104
36050: PUSH
36051: LD_EXP 104
36055: PPUSH
36056: LD_VAR 0 2
36060: PPUSH
36061: EMPTY
36062: PPUSH
36063: CALL_OW 1
36067: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36068: LD_ADDR_EXP 131
36072: PUSH
36073: LD_EXP 131
36077: PPUSH
36078: LD_VAR 0 2
36082: PPUSH
36083: EMPTY
36084: PPUSH
36085: CALL_OW 1
36089: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36090: LD_ADDR_EXP 105
36094: PUSH
36095: LD_EXP 105
36099: PPUSH
36100: LD_VAR 0 2
36104: PPUSH
36105: EMPTY
36106: PPUSH
36107: CALL_OW 1
36111: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36112: LD_ADDR_EXP 106
36116: PUSH
36117: LD_EXP 106
36121: PPUSH
36122: LD_VAR 0 2
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL_OW 1
36133: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36134: LD_ADDR_EXP 107
36138: PUSH
36139: LD_EXP 107
36143: PPUSH
36144: LD_VAR 0 2
36148: PPUSH
36149: LD_EXP 99
36153: PUSH
36154: LD_VAR 0 2
36158: ARRAY
36159: PPUSH
36160: LD_INT 2
36162: PUSH
36163: LD_INT 30
36165: PUSH
36166: LD_INT 32
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 30
36175: PUSH
36176: LD_INT 33
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: LIST
36187: PPUSH
36188: CALL_OW 72
36192: PPUSH
36193: CALL_OW 1
36197: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36198: LD_ADDR_EXP 108
36202: PUSH
36203: LD_EXP 108
36207: PPUSH
36208: LD_VAR 0 2
36212: PPUSH
36213: LD_EXP 99
36217: PUSH
36218: LD_VAR 0 2
36222: ARRAY
36223: PPUSH
36224: LD_INT 2
36226: PUSH
36227: LD_INT 30
36229: PUSH
36230: LD_INT 32
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 30
36239: PUSH
36240: LD_INT 31
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 58
36254: PUSH
36255: EMPTY
36256: LIST
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PPUSH
36262: CALL_OW 72
36266: PPUSH
36267: CALL_OW 1
36271: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36272: LD_ADDR_EXP 109
36276: PUSH
36277: LD_EXP 109
36281: PPUSH
36282: LD_VAR 0 2
36286: PPUSH
36287: EMPTY
36288: PPUSH
36289: CALL_OW 1
36293: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36294: LD_ADDR_EXP 113
36298: PUSH
36299: LD_EXP 113
36303: PPUSH
36304: LD_VAR 0 2
36308: PPUSH
36309: EMPTY
36310: PPUSH
36311: CALL_OW 1
36315: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36316: LD_ADDR_EXP 112
36320: PUSH
36321: LD_EXP 112
36325: PPUSH
36326: LD_VAR 0 2
36330: PPUSH
36331: EMPTY
36332: PPUSH
36333: CALL_OW 1
36337: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36338: LD_ADDR_EXP 114
36342: PUSH
36343: LD_EXP 114
36347: PPUSH
36348: LD_VAR 0 2
36352: PPUSH
36353: EMPTY
36354: PPUSH
36355: CALL_OW 1
36359: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36360: LD_ADDR_EXP 115
36364: PUSH
36365: LD_EXP 115
36369: PPUSH
36370: LD_VAR 0 2
36374: PPUSH
36375: EMPTY
36376: PPUSH
36377: CALL_OW 1
36381: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36382: LD_ADDR_EXP 116
36386: PUSH
36387: LD_EXP 116
36391: PPUSH
36392: LD_VAR 0 2
36396: PPUSH
36397: EMPTY
36398: PPUSH
36399: CALL_OW 1
36403: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36404: LD_ADDR_EXP 117
36408: PUSH
36409: LD_EXP 117
36413: PPUSH
36414: LD_VAR 0 2
36418: PPUSH
36419: EMPTY
36420: PPUSH
36421: CALL_OW 1
36425: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36426: LD_ADDR_EXP 118
36430: PUSH
36431: LD_EXP 118
36435: PPUSH
36436: LD_VAR 0 2
36440: PPUSH
36441: EMPTY
36442: PPUSH
36443: CALL_OW 1
36447: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36448: LD_ADDR_EXP 119
36452: PUSH
36453: LD_EXP 119
36457: PPUSH
36458: LD_VAR 0 2
36462: PPUSH
36463: EMPTY
36464: PPUSH
36465: CALL_OW 1
36469: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36470: LD_ADDR_EXP 120
36474: PUSH
36475: LD_EXP 120
36479: PPUSH
36480: LD_VAR 0 2
36484: PPUSH
36485: EMPTY
36486: PPUSH
36487: CALL_OW 1
36491: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36492: LD_ADDR_EXP 121
36496: PUSH
36497: LD_EXP 121
36501: PPUSH
36502: LD_VAR 0 2
36506: PPUSH
36507: EMPTY
36508: PPUSH
36509: CALL_OW 1
36513: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36514: LD_ADDR_EXP 110
36518: PUSH
36519: LD_EXP 110
36523: PPUSH
36524: LD_VAR 0 2
36528: PPUSH
36529: LD_INT 0
36531: PPUSH
36532: CALL_OW 1
36536: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36537: LD_ADDR_EXP 123
36541: PUSH
36542: LD_EXP 123
36546: PPUSH
36547: LD_VAR 0 2
36551: PPUSH
36552: LD_INT 0
36554: PPUSH
36555: CALL_OW 1
36559: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36560: LD_ADDR_EXP 111
36564: PUSH
36565: LD_EXP 111
36569: PPUSH
36570: LD_VAR 0 2
36574: PPUSH
36575: EMPTY
36576: PPUSH
36577: CALL_OW 1
36581: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36582: LD_ADDR_EXP 122
36586: PUSH
36587: LD_EXP 122
36591: PPUSH
36592: LD_VAR 0 2
36596: PPUSH
36597: LD_INT 0
36599: PPUSH
36600: CALL_OW 1
36604: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36605: LD_ADDR_EXP 124
36609: PUSH
36610: LD_EXP 124
36614: PPUSH
36615: LD_VAR 0 2
36619: PPUSH
36620: EMPTY
36621: PPUSH
36622: CALL_OW 1
36626: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36627: LD_ADDR_EXP 127
36631: PUSH
36632: LD_EXP 127
36636: PPUSH
36637: LD_VAR 0 2
36641: PPUSH
36642: LD_INT 0
36644: PPUSH
36645: CALL_OW 1
36649: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36650: LD_ADDR_EXP 128
36654: PUSH
36655: LD_EXP 128
36659: PPUSH
36660: LD_VAR 0 2
36664: PPUSH
36665: EMPTY
36666: PPUSH
36667: CALL_OW 1
36671: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36672: LD_ADDR_EXP 129
36676: PUSH
36677: LD_EXP 129
36681: PPUSH
36682: LD_VAR 0 2
36686: PPUSH
36687: EMPTY
36688: PPUSH
36689: CALL_OW 1
36693: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36694: LD_ADDR_EXP 130
36698: PUSH
36699: LD_EXP 130
36703: PPUSH
36704: LD_VAR 0 2
36708: PPUSH
36709: EMPTY
36710: PPUSH
36711: CALL_OW 1
36715: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36716: LD_ADDR_EXP 132
36720: PUSH
36721: LD_EXP 132
36725: PPUSH
36726: LD_VAR 0 2
36730: PPUSH
36731: LD_EXP 99
36735: PUSH
36736: LD_VAR 0 2
36740: ARRAY
36741: PPUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 30
36747: PUSH
36748: LD_INT 6
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 30
36757: PUSH
36758: LD_INT 7
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 30
36767: PUSH
36768: LD_INT 8
36770: PUSH
36771: EMPTY
36772: LIST
36773: LIST
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: PPUSH
36781: CALL_OW 72
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36791: LD_ADDR_EXP 133
36795: PUSH
36796: LD_EXP 133
36800: PPUSH
36801: LD_VAR 0 2
36805: PPUSH
36806: EMPTY
36807: PPUSH
36808: CALL_OW 1
36812: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36813: LD_ADDR_EXP 134
36817: PUSH
36818: LD_EXP 134
36822: PPUSH
36823: LD_VAR 0 2
36827: PPUSH
36828: EMPTY
36829: PPUSH
36830: CALL_OW 1
36834: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36835: LD_ADDR_EXP 135
36839: PUSH
36840: LD_EXP 135
36844: PPUSH
36845: LD_VAR 0 2
36849: PPUSH
36850: EMPTY
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36857: LD_ADDR_EXP 136
36861: PUSH
36862: LD_EXP 136
36866: PPUSH
36867: LD_VAR 0 2
36871: PPUSH
36872: EMPTY
36873: PPUSH
36874: CALL_OW 1
36878: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36879: LD_ADDR_EXP 137
36883: PUSH
36884: LD_EXP 137
36888: PPUSH
36889: LD_VAR 0 2
36893: PPUSH
36894: EMPTY
36895: PPUSH
36896: CALL_OW 1
36900: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36901: LD_ADDR_EXP 138
36905: PUSH
36906: LD_EXP 138
36910: PPUSH
36911: LD_VAR 0 2
36915: PPUSH
36916: EMPTY
36917: PPUSH
36918: CALL_OW 1
36922: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36923: LD_ADDR_EXP 139
36927: PUSH
36928: LD_EXP 139
36932: PPUSH
36933: LD_VAR 0 2
36937: PPUSH
36938: EMPTY
36939: PPUSH
36940: CALL_OW 1
36944: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36945: LD_ADDR_EXP 140
36949: PUSH
36950: LD_EXP 140
36954: PPUSH
36955: LD_VAR 0 2
36959: PPUSH
36960: EMPTY
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36967: LD_ADDR_EXP 141
36971: PUSH
36972: LD_EXP 141
36976: PPUSH
36977: LD_VAR 0 2
36981: PPUSH
36982: LD_INT 0
36984: PPUSH
36985: CALL_OW 1
36989: ST_TO_ADDR
// end ;
36990: GO 35914
36992: POP
36993: POP
// MC_InitSides ( ) ;
36994: CALL 37280 0 0
// MC_InitResearch ( ) ;
36998: CALL 37019 0 0
// CustomInitMacro ( ) ;
37002: CALL 444 0 0
// skirmish := true ;
37006: LD_ADDR_EXP 97
37010: PUSH
37011: LD_INT 1
37013: ST_TO_ADDR
// end ;
37014: LD_VAR 0 1
37018: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37019: LD_INT 0
37021: PPUSH
37022: PPUSH
37023: PPUSH
37024: PPUSH
37025: PPUSH
37026: PPUSH
// if not mc_bases then
37027: LD_EXP 99
37031: NOT
37032: IFFALSE 37036
// exit ;
37034: GO 37275
// for i = 1 to 8 do
37036: LD_ADDR_VAR 0 2
37040: PUSH
37041: DOUBLE
37042: LD_INT 1
37044: DEC
37045: ST_TO_ADDR
37046: LD_INT 8
37048: PUSH
37049: FOR_TO
37050: IFFALSE 37076
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37052: LD_ADDR_EXP 126
37056: PUSH
37057: LD_EXP 126
37061: PPUSH
37062: LD_VAR 0 2
37066: PPUSH
37067: EMPTY
37068: PPUSH
37069: CALL_OW 1
37073: ST_TO_ADDR
37074: GO 37049
37076: POP
37077: POP
// tmp := [ ] ;
37078: LD_ADDR_VAR 0 5
37082: PUSH
37083: EMPTY
37084: ST_TO_ADDR
// for i = 1 to mc_sides do
37085: LD_ADDR_VAR 0 2
37089: PUSH
37090: DOUBLE
37091: LD_INT 1
37093: DEC
37094: ST_TO_ADDR
37095: LD_EXP 125
37099: PUSH
37100: FOR_TO
37101: IFFALSE 37159
// if not mc_sides [ i ] in tmp then
37103: LD_EXP 125
37107: PUSH
37108: LD_VAR 0 2
37112: ARRAY
37113: PUSH
37114: LD_VAR 0 5
37118: IN
37119: NOT
37120: IFFALSE 37157
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37122: LD_ADDR_VAR 0 5
37126: PUSH
37127: LD_VAR 0 5
37131: PPUSH
37132: LD_VAR 0 5
37136: PUSH
37137: LD_INT 1
37139: PLUS
37140: PPUSH
37141: LD_EXP 125
37145: PUSH
37146: LD_VAR 0 2
37150: ARRAY
37151: PPUSH
37152: CALL_OW 2
37156: ST_TO_ADDR
37157: GO 37100
37159: POP
37160: POP
// if not tmp then
37161: LD_VAR 0 5
37165: NOT
37166: IFFALSE 37170
// exit ;
37168: GO 37275
// for j in tmp do
37170: LD_ADDR_VAR 0 3
37174: PUSH
37175: LD_VAR 0 5
37179: PUSH
37180: FOR_IN
37181: IFFALSE 37273
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37183: LD_ADDR_VAR 0 6
37187: PUSH
37188: LD_INT 22
37190: PUSH
37191: LD_VAR 0 3
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PPUSH
37200: CALL_OW 69
37204: ST_TO_ADDR
// if not un then
37205: LD_VAR 0 6
37209: NOT
37210: IFFALSE 37214
// continue ;
37212: GO 37180
// nation := GetNation ( un [ 1 ] ) ;
37214: LD_ADDR_VAR 0 4
37218: PUSH
37219: LD_VAR 0 6
37223: PUSH
37224: LD_INT 1
37226: ARRAY
37227: PPUSH
37228: CALL_OW 248
37232: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37233: LD_ADDR_EXP 126
37237: PUSH
37238: LD_EXP 126
37242: PPUSH
37243: LD_VAR 0 3
37247: PPUSH
37248: LD_VAR 0 3
37252: PPUSH
37253: LD_VAR 0 4
37257: PPUSH
37258: LD_INT 1
37260: PPUSH
37261: CALL 63551 0 3
37265: PPUSH
37266: CALL_OW 1
37270: ST_TO_ADDR
// end ;
37271: GO 37180
37273: POP
37274: POP
// end ;
37275: LD_VAR 0 1
37279: RET
// export function MC_InitSides ( ) ; var i ; begin
37280: LD_INT 0
37282: PPUSH
37283: PPUSH
// if not mc_bases then
37284: LD_EXP 99
37288: NOT
37289: IFFALSE 37293
// exit ;
37291: GO 37367
// for i = 1 to mc_bases do
37293: LD_ADDR_VAR 0 2
37297: PUSH
37298: DOUBLE
37299: LD_INT 1
37301: DEC
37302: ST_TO_ADDR
37303: LD_EXP 99
37307: PUSH
37308: FOR_TO
37309: IFFALSE 37365
// if mc_bases [ i ] then
37311: LD_EXP 99
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: IFFALSE 37363
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37323: LD_ADDR_EXP 125
37327: PUSH
37328: LD_EXP 125
37332: PPUSH
37333: LD_VAR 0 2
37337: PPUSH
37338: LD_EXP 99
37342: PUSH
37343: LD_VAR 0 2
37347: ARRAY
37348: PUSH
37349: LD_INT 1
37351: ARRAY
37352: PPUSH
37353: CALL_OW 255
37357: PPUSH
37358: CALL_OW 1
37362: ST_TO_ADDR
37363: GO 37308
37365: POP
37366: POP
// end ;
37367: LD_VAR 0 1
37371: RET
// every 0 0$01 trigger skirmish do
37372: LD_EXP 97
37376: IFFALSE 37530
37378: GO 37380
37380: DISABLE
// begin enable ;
37381: ENABLE
// MC_CheckBuildings ( ) ;
37382: CALL 42028 0 0
// MC_CheckPeopleLife ( ) ;
37386: CALL 42153 0 0
// RaiseSailEvent ( 100 ) ;
37390: LD_INT 100
37392: PPUSH
37393: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37397: LD_INT 103
37399: PPUSH
37400: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37404: LD_INT 104
37406: PPUSH
37407: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37411: LD_INT 105
37413: PPUSH
37414: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37418: LD_INT 106
37420: PPUSH
37421: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37425: LD_INT 107
37427: PPUSH
37428: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37432: LD_INT 108
37434: PPUSH
37435: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37439: LD_INT 109
37441: PPUSH
37442: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37446: LD_INT 110
37448: PPUSH
37449: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37453: LD_INT 111
37455: PPUSH
37456: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37460: LD_INT 112
37462: PPUSH
37463: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37467: LD_INT 113
37469: PPUSH
37470: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37474: LD_INT 120
37476: PPUSH
37477: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37481: LD_INT 121
37483: PPUSH
37484: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37488: LD_INT 122
37490: PPUSH
37491: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37495: LD_INT 123
37497: PPUSH
37498: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37502: LD_INT 124
37504: PPUSH
37505: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37509: LD_INT 125
37511: PPUSH
37512: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37516: LD_INT 126
37518: PPUSH
37519: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37523: LD_INT 200
37525: PPUSH
37526: CALL_OW 427
// end ;
37530: END
// on SailEvent ( event ) do begin if event < 100 then
37531: LD_VAR 0 1
37535: PUSH
37536: LD_INT 100
37538: LESS
37539: IFFALSE 37550
// CustomEvent ( event ) ;
37541: LD_VAR 0 1
37545: PPUSH
37546: CALL 32213 0 1
// if event = 100 then
37550: LD_VAR 0 1
37554: PUSH
37555: LD_INT 100
37557: EQUAL
37558: IFFALSE 37564
// MC_ClassManager ( ) ;
37560: CALL 37956 0 0
// if event = 101 then
37564: LD_VAR 0 1
37568: PUSH
37569: LD_INT 101
37571: EQUAL
37572: IFFALSE 37578
// MC_RepairBuildings ( ) ;
37574: CALL 42749 0 0
// if event = 102 then
37578: LD_VAR 0 1
37582: PUSH
37583: LD_INT 102
37585: EQUAL
37586: IFFALSE 37592
// MC_Heal ( ) ;
37588: CALL 43481 0 0
// if event = 103 then
37592: LD_VAR 0 1
37596: PUSH
37597: LD_INT 103
37599: EQUAL
37600: IFFALSE 37606
// MC_Build ( ) ;
37602: CALL 43903 0 0
// if event = 104 then
37606: LD_VAR 0 1
37610: PUSH
37611: LD_INT 104
37613: EQUAL
37614: IFFALSE 37620
// MC_TurretWeapon ( ) ;
37616: CALL 45516 0 0
// if event = 105 then
37620: LD_VAR 0 1
37624: PUSH
37625: LD_INT 105
37627: EQUAL
37628: IFFALSE 37634
// MC_BuildUpgrade ( ) ;
37630: CALL 45067 0 0
// if event = 106 then
37634: LD_VAR 0 1
37638: PUSH
37639: LD_INT 106
37641: EQUAL
37642: IFFALSE 37648
// MC_PlantMines ( ) ;
37644: CALL 45946 0 0
// if event = 107 then
37648: LD_VAR 0 1
37652: PUSH
37653: LD_INT 107
37655: EQUAL
37656: IFFALSE 37662
// MC_CollectCrates ( ) ;
37658: CALL 46980 0 0
// if event = 108 then
37662: LD_VAR 0 1
37666: PUSH
37667: LD_INT 108
37669: EQUAL
37670: IFFALSE 37676
// MC_LinkRemoteControl ( ) ;
37672: CALL 48756 0 0
// if event = 109 then
37676: LD_VAR 0 1
37680: PUSH
37681: LD_INT 109
37683: EQUAL
37684: IFFALSE 37690
// MC_ProduceVehicle ( ) ;
37686: CALL 48937 0 0
// if event = 110 then
37690: LD_VAR 0 1
37694: PUSH
37695: LD_INT 110
37697: EQUAL
37698: IFFALSE 37704
// MC_SendAttack ( ) ;
37700: CALL 49403 0 0
// if event = 111 then
37704: LD_VAR 0 1
37708: PUSH
37709: LD_INT 111
37711: EQUAL
37712: IFFALSE 37718
// MC_Defend ( ) ;
37714: CALL 49511 0 0
// if event = 112 then
37718: LD_VAR 0 1
37722: PUSH
37723: LD_INT 112
37725: EQUAL
37726: IFFALSE 37732
// MC_Research ( ) ;
37728: CALL 50116 0 0
// if event = 113 then
37732: LD_VAR 0 1
37736: PUSH
37737: LD_INT 113
37739: EQUAL
37740: IFFALSE 37746
// MC_MinesTrigger ( ) ;
37742: CALL 51230 0 0
// if event = 120 then
37746: LD_VAR 0 1
37750: PUSH
37751: LD_INT 120
37753: EQUAL
37754: IFFALSE 37760
// MC_RepairVehicle ( ) ;
37756: CALL 51329 0 0
// if event = 121 then
37760: LD_VAR 0 1
37764: PUSH
37765: LD_INT 121
37767: EQUAL
37768: IFFALSE 37774
// MC_TameApe ( ) ;
37770: CALL 52059 0 0
// if event = 122 then
37774: LD_VAR 0 1
37778: PUSH
37779: LD_INT 122
37781: EQUAL
37782: IFFALSE 37788
// MC_ChangeApeClass ( ) ;
37784: CALL 52888 0 0
// if event = 123 then
37788: LD_VAR 0 1
37792: PUSH
37793: LD_INT 123
37795: EQUAL
37796: IFFALSE 37802
// MC_Bazooka ( ) ;
37798: CALL 53538 0 0
// if event = 124 then
37802: LD_VAR 0 1
37806: PUSH
37807: LD_INT 124
37809: EQUAL
37810: IFFALSE 37816
// MC_TeleportExit ( ) ;
37812: CALL 53736 0 0
// if event = 125 then
37816: LD_VAR 0 1
37820: PUSH
37821: LD_INT 125
37823: EQUAL
37824: IFFALSE 37830
// MC_Deposits ( ) ;
37826: CALL 54383 0 0
// if event = 126 then
37830: LD_VAR 0 1
37834: PUSH
37835: LD_INT 126
37837: EQUAL
37838: IFFALSE 37844
// MC_RemoteDriver ( ) ;
37840: CALL 55008 0 0
// if event = 200 then
37844: LD_VAR 0 1
37848: PUSH
37849: LD_INT 200
37851: EQUAL
37852: IFFALSE 37858
// MC_Idle ( ) ;
37854: CALL 56741 0 0
// end ;
37858: PPOPN 1
37860: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37861: LD_INT 0
37863: PPUSH
37864: PPUSH
// if not mc_bases [ base ] or not tag then
37865: LD_EXP 99
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: NOT
37876: PUSH
37877: LD_VAR 0 2
37881: NOT
37882: OR
37883: IFFALSE 37887
// exit ;
37885: GO 37951
// for i in mc_bases [ base ] union mc_ape [ base ] do
37887: LD_ADDR_VAR 0 4
37891: PUSH
37892: LD_EXP 99
37896: PUSH
37897: LD_VAR 0 1
37901: ARRAY
37902: PUSH
37903: LD_EXP 128
37907: PUSH
37908: LD_VAR 0 1
37912: ARRAY
37913: UNION
37914: PUSH
37915: FOR_IN
37916: IFFALSE 37949
// if GetTag ( i ) = tag then
37918: LD_VAR 0 4
37922: PPUSH
37923: CALL_OW 110
37927: PUSH
37928: LD_VAR 0 2
37932: EQUAL
37933: IFFALSE 37947
// SetTag ( i , 0 ) ;
37935: LD_VAR 0 4
37939: PPUSH
37940: LD_INT 0
37942: PPUSH
37943: CALL_OW 109
37947: GO 37915
37949: POP
37950: POP
// end ;
37951: LD_VAR 0 3
37955: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37956: LD_INT 0
37958: PPUSH
37959: PPUSH
37960: PPUSH
37961: PPUSH
37962: PPUSH
37963: PPUSH
37964: PPUSH
37965: PPUSH
// if not mc_bases then
37966: LD_EXP 99
37970: NOT
37971: IFFALSE 37975
// exit ;
37973: GO 38433
// for i = 1 to mc_bases do
37975: LD_ADDR_VAR 0 2
37979: PUSH
37980: DOUBLE
37981: LD_INT 1
37983: DEC
37984: ST_TO_ADDR
37985: LD_EXP 99
37989: PUSH
37990: FOR_TO
37991: IFFALSE 38431
// begin tmp := MC_ClassCheckReq ( i ) ;
37993: LD_ADDR_VAR 0 4
37997: PUSH
37998: LD_VAR 0 2
38002: PPUSH
38003: CALL 38438 0 1
38007: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38008: LD_ADDR_EXP 140
38012: PUSH
38013: LD_EXP 140
38017: PPUSH
38018: LD_VAR 0 2
38022: PPUSH
38023: LD_VAR 0 4
38027: PPUSH
38028: CALL_OW 1
38032: ST_TO_ADDR
// if not tmp then
38033: LD_VAR 0 4
38037: NOT
38038: IFFALSE 38042
// continue ;
38040: GO 37990
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38042: LD_ADDR_VAR 0 6
38046: PUSH
38047: LD_EXP 99
38051: PUSH
38052: LD_VAR 0 2
38056: ARRAY
38057: PPUSH
38058: LD_INT 2
38060: PUSH
38061: LD_INT 30
38063: PUSH
38064: LD_INT 4
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 30
38073: PUSH
38074: LD_INT 5
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: LIST
38085: PPUSH
38086: CALL_OW 72
38090: PUSH
38091: LD_EXP 99
38095: PUSH
38096: LD_VAR 0 2
38100: ARRAY
38101: PPUSH
38102: LD_INT 2
38104: PUSH
38105: LD_INT 30
38107: PUSH
38108: LD_INT 0
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 30
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: LIST
38129: PPUSH
38130: CALL_OW 72
38134: PUSH
38135: LD_EXP 99
38139: PUSH
38140: LD_VAR 0 2
38144: ARRAY
38145: PPUSH
38146: LD_INT 30
38148: PUSH
38149: LD_INT 3
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PPUSH
38156: CALL_OW 72
38160: PUSH
38161: LD_EXP 99
38165: PUSH
38166: LD_VAR 0 2
38170: ARRAY
38171: PPUSH
38172: LD_INT 2
38174: PUSH
38175: LD_INT 30
38177: PUSH
38178: LD_INT 6
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: PUSH
38185: LD_INT 30
38187: PUSH
38188: LD_INT 7
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 30
38197: PUSH
38198: LD_INT 8
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: LIST
38209: LIST
38210: PPUSH
38211: CALL_OW 72
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: LIST
38220: LIST
38221: ST_TO_ADDR
// for j = 1 to 4 do
38222: LD_ADDR_VAR 0 3
38226: PUSH
38227: DOUBLE
38228: LD_INT 1
38230: DEC
38231: ST_TO_ADDR
38232: LD_INT 4
38234: PUSH
38235: FOR_TO
38236: IFFALSE 38427
// begin if not tmp [ j ] then
38238: LD_VAR 0 4
38242: PUSH
38243: LD_VAR 0 3
38247: ARRAY
38248: NOT
38249: IFFALSE 38253
// continue ;
38251: GO 38235
// for p in tmp [ j ] do
38253: LD_ADDR_VAR 0 5
38257: PUSH
38258: LD_VAR 0 4
38262: PUSH
38263: LD_VAR 0 3
38267: ARRAY
38268: PUSH
38269: FOR_IN
38270: IFFALSE 38423
// begin if not b [ j ] then
38272: LD_VAR 0 6
38276: PUSH
38277: LD_VAR 0 3
38281: ARRAY
38282: NOT
38283: IFFALSE 38287
// break ;
38285: GO 38423
// e := 0 ;
38287: LD_ADDR_VAR 0 7
38291: PUSH
38292: LD_INT 0
38294: ST_TO_ADDR
// for k in b [ j ] do
38295: LD_ADDR_VAR 0 8
38299: PUSH
38300: LD_VAR 0 6
38304: PUSH
38305: LD_VAR 0 3
38309: ARRAY
38310: PUSH
38311: FOR_IN
38312: IFFALSE 38339
// if IsNotFull ( k ) then
38314: LD_VAR 0 8
38318: PPUSH
38319: CALL 67627 0 1
38323: IFFALSE 38337
// begin e := k ;
38325: LD_ADDR_VAR 0 7
38329: PUSH
38330: LD_VAR 0 8
38334: ST_TO_ADDR
// break ;
38335: GO 38339
// end ;
38337: GO 38311
38339: POP
38340: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38341: LD_VAR 0 7
38345: PUSH
38346: LD_VAR 0 5
38350: PPUSH
38351: LD_VAR 0 7
38355: PPUSH
38356: CALL 104746 0 2
38360: NOT
38361: AND
38362: IFFALSE 38421
// begin if IsInUnit ( p ) then
38364: LD_VAR 0 5
38368: PPUSH
38369: CALL_OW 310
38373: IFFALSE 38384
// ComExitBuilding ( p ) ;
38375: LD_VAR 0 5
38379: PPUSH
38380: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38384: LD_VAR 0 5
38388: PPUSH
38389: LD_VAR 0 7
38393: PPUSH
38394: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38398: LD_VAR 0 5
38402: PPUSH
38403: LD_VAR 0 3
38407: PPUSH
38408: CALL_OW 183
// AddComExitBuilding ( p ) ;
38412: LD_VAR 0 5
38416: PPUSH
38417: CALL_OW 182
// end ; end ;
38421: GO 38269
38423: POP
38424: POP
// end ;
38425: GO 38235
38427: POP
38428: POP
// end ;
38429: GO 37990
38431: POP
38432: POP
// end ;
38433: LD_VAR 0 1
38437: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38438: LD_INT 0
38440: PPUSH
38441: PPUSH
38442: PPUSH
38443: PPUSH
38444: PPUSH
38445: PPUSH
38446: PPUSH
38447: PPUSH
38448: PPUSH
38449: PPUSH
38450: PPUSH
38451: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38452: LD_VAR 0 1
38456: NOT
38457: PUSH
38458: LD_EXP 99
38462: PUSH
38463: LD_VAR 0 1
38467: ARRAY
38468: NOT
38469: OR
38470: PUSH
38471: LD_EXP 99
38475: PUSH
38476: LD_VAR 0 1
38480: ARRAY
38481: PPUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 30
38487: PUSH
38488: LD_INT 0
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 30
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: LIST
38509: PPUSH
38510: CALL_OW 72
38514: NOT
38515: OR
38516: IFFALSE 38520
// exit ;
38518: GO 42023
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38520: LD_ADDR_VAR 0 4
38524: PUSH
38525: LD_EXP 99
38529: PUSH
38530: LD_VAR 0 1
38534: ARRAY
38535: PPUSH
38536: LD_INT 2
38538: PUSH
38539: LD_INT 25
38541: PUSH
38542: LD_INT 1
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 25
38551: PUSH
38552: LD_INT 2
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 25
38561: PUSH
38562: LD_INT 3
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: PUSH
38569: LD_INT 25
38571: PUSH
38572: LD_INT 4
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 25
38581: PUSH
38582: LD_INT 5
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 25
38591: PUSH
38592: LD_INT 8
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 25
38601: PUSH
38602: LD_INT 9
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: PPUSH
38619: CALL_OW 72
38623: ST_TO_ADDR
// if not tmp then
38624: LD_VAR 0 4
38628: NOT
38629: IFFALSE 38633
// exit ;
38631: GO 42023
// for i in tmp do
38633: LD_ADDR_VAR 0 3
38637: PUSH
38638: LD_VAR 0 4
38642: PUSH
38643: FOR_IN
38644: IFFALSE 38675
// if GetTag ( i ) then
38646: LD_VAR 0 3
38650: PPUSH
38651: CALL_OW 110
38655: IFFALSE 38673
// tmp := tmp diff i ;
38657: LD_ADDR_VAR 0 4
38661: PUSH
38662: LD_VAR 0 4
38666: PUSH
38667: LD_VAR 0 3
38671: DIFF
38672: ST_TO_ADDR
38673: GO 38643
38675: POP
38676: POP
// if not tmp then
38677: LD_VAR 0 4
38681: NOT
38682: IFFALSE 38686
// exit ;
38684: GO 42023
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38686: LD_ADDR_VAR 0 5
38690: PUSH
38691: LD_EXP 99
38695: PUSH
38696: LD_VAR 0 1
38700: ARRAY
38701: PPUSH
38702: LD_INT 2
38704: PUSH
38705: LD_INT 25
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 25
38717: PUSH
38718: LD_INT 5
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 25
38727: PUSH
38728: LD_INT 8
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 25
38737: PUSH
38738: LD_INT 9
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: PPUSH
38752: CALL_OW 72
38756: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38757: LD_ADDR_VAR 0 6
38761: PUSH
38762: LD_EXP 99
38766: PUSH
38767: LD_VAR 0 1
38771: ARRAY
38772: PPUSH
38773: LD_INT 25
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PPUSH
38783: CALL_OW 72
38787: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38788: LD_ADDR_VAR 0 7
38792: PUSH
38793: LD_EXP 99
38797: PUSH
38798: LD_VAR 0 1
38802: ARRAY
38803: PPUSH
38804: LD_INT 25
38806: PUSH
38807: LD_INT 3
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PPUSH
38814: CALL_OW 72
38818: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38819: LD_ADDR_VAR 0 8
38823: PUSH
38824: LD_EXP 99
38828: PUSH
38829: LD_VAR 0 1
38833: ARRAY
38834: PPUSH
38835: LD_INT 25
38837: PUSH
38838: LD_INT 4
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 24
38847: PUSH
38848: LD_INT 251
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PPUSH
38859: CALL_OW 72
38863: ST_TO_ADDR
// if mc_scan [ base ] then
38864: LD_EXP 122
38868: PUSH
38869: LD_VAR 0 1
38873: ARRAY
38874: IFFALSE 39335
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38876: LD_ADDR_EXP 141
38880: PUSH
38881: LD_EXP 141
38885: PPUSH
38886: LD_VAR 0 1
38890: PPUSH
38891: LD_INT 4
38893: PPUSH
38894: CALL_OW 1
38898: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38899: LD_ADDR_VAR 0 12
38903: PUSH
38904: LD_EXP 99
38908: PUSH
38909: LD_VAR 0 1
38913: ARRAY
38914: PPUSH
38915: LD_INT 2
38917: PUSH
38918: LD_INT 30
38920: PUSH
38921: LD_INT 4
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 30
38930: PUSH
38931: LD_INT 5
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: LIST
38942: PPUSH
38943: CALL_OW 72
38947: ST_TO_ADDR
// if not b then
38948: LD_VAR 0 12
38952: NOT
38953: IFFALSE 38957
// exit ;
38955: GO 42023
// p := [ ] ;
38957: LD_ADDR_VAR 0 11
38961: PUSH
38962: EMPTY
38963: ST_TO_ADDR
// if sci >= 2 then
38964: LD_VAR 0 8
38968: PUSH
38969: LD_INT 2
38971: GREATEREQUAL
38972: IFFALSE 39003
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38974: LD_ADDR_VAR 0 8
38978: PUSH
38979: LD_VAR 0 8
38983: PUSH
38984: LD_INT 1
38986: ARRAY
38987: PUSH
38988: LD_VAR 0 8
38992: PUSH
38993: LD_INT 2
38995: ARRAY
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: ST_TO_ADDR
39001: GO 39064
// if sci = 1 then
39003: LD_VAR 0 8
39007: PUSH
39008: LD_INT 1
39010: EQUAL
39011: IFFALSE 39032
// sci := [ sci [ 1 ] ] else
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 8
39022: PUSH
39023: LD_INT 1
39025: ARRAY
39026: PUSH
39027: EMPTY
39028: LIST
39029: ST_TO_ADDR
39030: GO 39064
// if sci = 0 then
39032: LD_VAR 0 8
39036: PUSH
39037: LD_INT 0
39039: EQUAL
39040: IFFALSE 39064
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39042: LD_ADDR_VAR 0 11
39046: PUSH
39047: LD_VAR 0 4
39051: PPUSH
39052: LD_INT 4
39054: PPUSH
39055: CALL 104609 0 2
39059: PUSH
39060: LD_INT 1
39062: ARRAY
39063: ST_TO_ADDR
// if eng > 4 then
39064: LD_VAR 0 6
39068: PUSH
39069: LD_INT 4
39071: GREATER
39072: IFFALSE 39118
// for i = eng downto 4 do
39074: LD_ADDR_VAR 0 3
39078: PUSH
39079: DOUBLE
39080: LD_VAR 0 6
39084: INC
39085: ST_TO_ADDR
39086: LD_INT 4
39088: PUSH
39089: FOR_DOWNTO
39090: IFFALSE 39116
// eng := eng diff eng [ i ] ;
39092: LD_ADDR_VAR 0 6
39096: PUSH
39097: LD_VAR 0 6
39101: PUSH
39102: LD_VAR 0 6
39106: PUSH
39107: LD_VAR 0 3
39111: ARRAY
39112: DIFF
39113: ST_TO_ADDR
39114: GO 39089
39116: POP
39117: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39118: LD_ADDR_VAR 0 4
39122: PUSH
39123: LD_VAR 0 4
39127: PUSH
39128: LD_VAR 0 5
39132: PUSH
39133: LD_VAR 0 6
39137: UNION
39138: PUSH
39139: LD_VAR 0 7
39143: UNION
39144: PUSH
39145: LD_VAR 0 8
39149: UNION
39150: DIFF
39151: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39152: LD_ADDR_VAR 0 13
39156: PUSH
39157: LD_EXP 99
39161: PUSH
39162: LD_VAR 0 1
39166: ARRAY
39167: PPUSH
39168: LD_INT 2
39170: PUSH
39171: LD_INT 30
39173: PUSH
39174: LD_INT 32
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 30
39183: PUSH
39184: LD_INT 31
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: LIST
39195: PPUSH
39196: CALL_OW 72
39200: PUSH
39201: LD_EXP 99
39205: PUSH
39206: LD_VAR 0 1
39210: ARRAY
39211: PPUSH
39212: LD_INT 2
39214: PUSH
39215: LD_INT 30
39217: PUSH
39218: LD_INT 4
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 30
39227: PUSH
39228: LD_INT 5
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: LIST
39239: PPUSH
39240: CALL_OW 72
39244: PUSH
39245: LD_INT 6
39247: MUL
39248: PLUS
39249: ST_TO_ADDR
// if bcount < tmp then
39250: LD_VAR 0 13
39254: PUSH
39255: LD_VAR 0 4
39259: LESS
39260: IFFALSE 39306
// for i = tmp downto bcount do
39262: LD_ADDR_VAR 0 3
39266: PUSH
39267: DOUBLE
39268: LD_VAR 0 4
39272: INC
39273: ST_TO_ADDR
39274: LD_VAR 0 13
39278: PUSH
39279: FOR_DOWNTO
39280: IFFALSE 39304
// tmp := Delete ( tmp , tmp ) ;
39282: LD_ADDR_VAR 0 4
39286: PUSH
39287: LD_VAR 0 4
39291: PPUSH
39292: LD_VAR 0 4
39296: PPUSH
39297: CALL_OW 3
39301: ST_TO_ADDR
39302: GO 39279
39304: POP
39305: POP
// result := [ tmp , 0 , 0 , p ] ;
39306: LD_ADDR_VAR 0 2
39310: PUSH
39311: LD_VAR 0 4
39315: PUSH
39316: LD_INT 0
39318: PUSH
39319: LD_INT 0
39321: PUSH
39322: LD_VAR 0 11
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: LIST
39331: LIST
39332: ST_TO_ADDR
// exit ;
39333: GO 42023
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39335: LD_EXP 99
39339: PUSH
39340: LD_VAR 0 1
39344: ARRAY
39345: PPUSH
39346: LD_INT 2
39348: PUSH
39349: LD_INT 30
39351: PUSH
39352: LD_INT 6
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 30
39361: PUSH
39362: LD_INT 7
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 30
39371: PUSH
39372: LD_INT 8
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: PPUSH
39385: CALL_OW 72
39389: NOT
39390: PUSH
39391: LD_EXP 99
39395: PUSH
39396: LD_VAR 0 1
39400: ARRAY
39401: PPUSH
39402: LD_INT 30
39404: PUSH
39405: LD_INT 3
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PPUSH
39412: CALL_OW 72
39416: NOT
39417: AND
39418: IFFALSE 39490
// begin if eng = tmp then
39420: LD_VAR 0 6
39424: PUSH
39425: LD_VAR 0 4
39429: EQUAL
39430: IFFALSE 39434
// exit ;
39432: GO 42023
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39434: LD_ADDR_EXP 141
39438: PUSH
39439: LD_EXP 141
39443: PPUSH
39444: LD_VAR 0 1
39448: PPUSH
39449: LD_INT 1
39451: PPUSH
39452: CALL_OW 1
39456: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39457: LD_ADDR_VAR 0 2
39461: PUSH
39462: LD_INT 0
39464: PUSH
39465: LD_VAR 0 4
39469: PUSH
39470: LD_VAR 0 6
39474: DIFF
39475: PUSH
39476: LD_INT 0
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: LIST
39486: LIST
39487: ST_TO_ADDR
// exit ;
39488: GO 42023
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39490: LD_EXP 126
39494: PUSH
39495: LD_EXP 125
39499: PUSH
39500: LD_VAR 0 1
39504: ARRAY
39505: ARRAY
39506: PUSH
39507: LD_EXP 99
39511: PUSH
39512: LD_VAR 0 1
39516: ARRAY
39517: PPUSH
39518: LD_INT 2
39520: PUSH
39521: LD_INT 30
39523: PUSH
39524: LD_INT 6
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 30
39533: PUSH
39534: LD_INT 7
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 30
39543: PUSH
39544: LD_INT 8
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: PPUSH
39557: CALL_OW 72
39561: AND
39562: PUSH
39563: LD_EXP 99
39567: PUSH
39568: LD_VAR 0 1
39572: ARRAY
39573: PPUSH
39574: LD_INT 30
39576: PUSH
39577: LD_INT 3
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PPUSH
39584: CALL_OW 72
39588: NOT
39589: AND
39590: IFFALSE 39804
// begin if sci >= 6 then
39592: LD_VAR 0 8
39596: PUSH
39597: LD_INT 6
39599: GREATEREQUAL
39600: IFFALSE 39604
// exit ;
39602: GO 42023
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39604: LD_ADDR_EXP 141
39608: PUSH
39609: LD_EXP 141
39613: PPUSH
39614: LD_VAR 0 1
39618: PPUSH
39619: LD_INT 2
39621: PPUSH
39622: CALL_OW 1
39626: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39627: LD_ADDR_VAR 0 9
39631: PUSH
39632: LD_VAR 0 4
39636: PUSH
39637: LD_VAR 0 8
39641: DIFF
39642: PPUSH
39643: LD_INT 4
39645: PPUSH
39646: CALL 104609 0 2
39650: ST_TO_ADDR
// p := [ ] ;
39651: LD_ADDR_VAR 0 11
39655: PUSH
39656: EMPTY
39657: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39658: LD_VAR 0 8
39662: PUSH
39663: LD_INT 6
39665: LESS
39666: PUSH
39667: LD_VAR 0 9
39671: PUSH
39672: LD_INT 6
39674: GREATER
39675: AND
39676: IFFALSE 39757
// begin for i = 1 to 6 - sci do
39678: LD_ADDR_VAR 0 3
39682: PUSH
39683: DOUBLE
39684: LD_INT 1
39686: DEC
39687: ST_TO_ADDR
39688: LD_INT 6
39690: PUSH
39691: LD_VAR 0 8
39695: MINUS
39696: PUSH
39697: FOR_TO
39698: IFFALSE 39753
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39700: LD_ADDR_VAR 0 11
39704: PUSH
39705: LD_VAR 0 11
39709: PPUSH
39710: LD_VAR 0 11
39714: PUSH
39715: LD_INT 1
39717: PLUS
39718: PPUSH
39719: LD_VAR 0 9
39723: PUSH
39724: LD_INT 1
39726: ARRAY
39727: PPUSH
39728: CALL_OW 2
39732: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39733: LD_ADDR_VAR 0 9
39737: PUSH
39738: LD_VAR 0 9
39742: PPUSH
39743: LD_INT 1
39745: PPUSH
39746: CALL_OW 3
39750: ST_TO_ADDR
// end ;
39751: GO 39697
39753: POP
39754: POP
// end else
39755: GO 39777
// if sort then
39757: LD_VAR 0 9
39761: IFFALSE 39777
// p := sort [ 1 ] ;
39763: LD_ADDR_VAR 0 11
39767: PUSH
39768: LD_VAR 0 9
39772: PUSH
39773: LD_INT 1
39775: ARRAY
39776: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39777: LD_ADDR_VAR 0 2
39781: PUSH
39782: LD_INT 0
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: LD_VAR 0 11
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: ST_TO_ADDR
// exit ;
39802: GO 42023
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39804: LD_EXP 126
39808: PUSH
39809: LD_EXP 125
39813: PUSH
39814: LD_VAR 0 1
39818: ARRAY
39819: ARRAY
39820: PUSH
39821: LD_EXP 99
39825: PUSH
39826: LD_VAR 0 1
39830: ARRAY
39831: PPUSH
39832: LD_INT 2
39834: PUSH
39835: LD_INT 30
39837: PUSH
39838: LD_INT 6
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 30
39847: PUSH
39848: LD_INT 7
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 30
39857: PUSH
39858: LD_INT 8
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: PPUSH
39871: CALL_OW 72
39875: AND
39876: PUSH
39877: LD_EXP 99
39881: PUSH
39882: LD_VAR 0 1
39886: ARRAY
39887: PPUSH
39888: LD_INT 30
39890: PUSH
39891: LD_INT 3
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PPUSH
39898: CALL_OW 72
39902: AND
39903: IFFALSE 40637
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39905: LD_ADDR_EXP 141
39909: PUSH
39910: LD_EXP 141
39914: PPUSH
39915: LD_VAR 0 1
39919: PPUSH
39920: LD_INT 3
39922: PPUSH
39923: CALL_OW 1
39927: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39928: LD_ADDR_VAR 0 2
39932: PUSH
39933: LD_INT 0
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: ST_TO_ADDR
// if not eng then
39951: LD_VAR 0 6
39955: NOT
39956: IFFALSE 40019
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39958: LD_ADDR_VAR 0 11
39962: PUSH
39963: LD_VAR 0 4
39967: PPUSH
39968: LD_INT 2
39970: PPUSH
39971: CALL 104609 0 2
39975: PUSH
39976: LD_INT 1
39978: ARRAY
39979: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39980: LD_ADDR_VAR 0 2
39984: PUSH
39985: LD_VAR 0 2
39989: PPUSH
39990: LD_INT 2
39992: PPUSH
39993: LD_VAR 0 11
39997: PPUSH
39998: CALL_OW 1
40002: ST_TO_ADDR
// tmp := tmp diff p ;
40003: LD_ADDR_VAR 0 4
40007: PUSH
40008: LD_VAR 0 4
40012: PUSH
40013: LD_VAR 0 11
40017: DIFF
40018: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40019: LD_VAR 0 4
40023: PUSH
40024: LD_VAR 0 8
40028: PUSH
40029: LD_INT 6
40031: LESS
40032: AND
40033: IFFALSE 40221
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40035: LD_ADDR_VAR 0 9
40039: PUSH
40040: LD_VAR 0 4
40044: PUSH
40045: LD_VAR 0 8
40049: PUSH
40050: LD_VAR 0 7
40054: UNION
40055: DIFF
40056: PPUSH
40057: LD_INT 4
40059: PPUSH
40060: CALL 104609 0 2
40064: ST_TO_ADDR
// p := [ ] ;
40065: LD_ADDR_VAR 0 11
40069: PUSH
40070: EMPTY
40071: ST_TO_ADDR
// if sort then
40072: LD_VAR 0 9
40076: IFFALSE 40192
// for i = 1 to 6 - sci do
40078: LD_ADDR_VAR 0 3
40082: PUSH
40083: DOUBLE
40084: LD_INT 1
40086: DEC
40087: ST_TO_ADDR
40088: LD_INT 6
40090: PUSH
40091: LD_VAR 0 8
40095: MINUS
40096: PUSH
40097: FOR_TO
40098: IFFALSE 40190
// begin if i = sort then
40100: LD_VAR 0 3
40104: PUSH
40105: LD_VAR 0 9
40109: EQUAL
40110: IFFALSE 40114
// break ;
40112: GO 40190
// if GetClass ( i ) = 4 then
40114: LD_VAR 0 3
40118: PPUSH
40119: CALL_OW 257
40123: PUSH
40124: LD_INT 4
40126: EQUAL
40127: IFFALSE 40131
// continue ;
40129: GO 40097
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40131: LD_ADDR_VAR 0 11
40135: PUSH
40136: LD_VAR 0 11
40140: PPUSH
40141: LD_VAR 0 11
40145: PUSH
40146: LD_INT 1
40148: PLUS
40149: PPUSH
40150: LD_VAR 0 9
40154: PUSH
40155: LD_VAR 0 3
40159: ARRAY
40160: PPUSH
40161: CALL_OW 2
40165: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40166: LD_ADDR_VAR 0 4
40170: PUSH
40171: LD_VAR 0 4
40175: PUSH
40176: LD_VAR 0 9
40180: PUSH
40181: LD_VAR 0 3
40185: ARRAY
40186: DIFF
40187: ST_TO_ADDR
// end ;
40188: GO 40097
40190: POP
40191: POP
// if p then
40192: LD_VAR 0 11
40196: IFFALSE 40221
// result := Replace ( result , 4 , p ) ;
40198: LD_ADDR_VAR 0 2
40202: PUSH
40203: LD_VAR 0 2
40207: PPUSH
40208: LD_INT 4
40210: PPUSH
40211: LD_VAR 0 11
40215: PPUSH
40216: CALL_OW 1
40220: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40221: LD_VAR 0 4
40225: PUSH
40226: LD_VAR 0 7
40230: PUSH
40231: LD_INT 6
40233: LESS
40234: AND
40235: IFFALSE 40423
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40237: LD_ADDR_VAR 0 9
40241: PUSH
40242: LD_VAR 0 4
40246: PUSH
40247: LD_VAR 0 8
40251: PUSH
40252: LD_VAR 0 7
40256: UNION
40257: DIFF
40258: PPUSH
40259: LD_INT 3
40261: PPUSH
40262: CALL 104609 0 2
40266: ST_TO_ADDR
// p := [ ] ;
40267: LD_ADDR_VAR 0 11
40271: PUSH
40272: EMPTY
40273: ST_TO_ADDR
// if sort then
40274: LD_VAR 0 9
40278: IFFALSE 40394
// for i = 1 to 6 - mech do
40280: LD_ADDR_VAR 0 3
40284: PUSH
40285: DOUBLE
40286: LD_INT 1
40288: DEC
40289: ST_TO_ADDR
40290: LD_INT 6
40292: PUSH
40293: LD_VAR 0 7
40297: MINUS
40298: PUSH
40299: FOR_TO
40300: IFFALSE 40392
// begin if i = sort then
40302: LD_VAR 0 3
40306: PUSH
40307: LD_VAR 0 9
40311: EQUAL
40312: IFFALSE 40316
// break ;
40314: GO 40392
// if GetClass ( i ) = 3 then
40316: LD_VAR 0 3
40320: PPUSH
40321: CALL_OW 257
40325: PUSH
40326: LD_INT 3
40328: EQUAL
40329: IFFALSE 40333
// continue ;
40331: GO 40299
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40333: LD_ADDR_VAR 0 11
40337: PUSH
40338: LD_VAR 0 11
40342: PPUSH
40343: LD_VAR 0 11
40347: PUSH
40348: LD_INT 1
40350: PLUS
40351: PPUSH
40352: LD_VAR 0 9
40356: PUSH
40357: LD_VAR 0 3
40361: ARRAY
40362: PPUSH
40363: CALL_OW 2
40367: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40368: LD_ADDR_VAR 0 4
40372: PUSH
40373: LD_VAR 0 4
40377: PUSH
40378: LD_VAR 0 9
40382: PUSH
40383: LD_VAR 0 3
40387: ARRAY
40388: DIFF
40389: ST_TO_ADDR
// end ;
40390: GO 40299
40392: POP
40393: POP
// if p then
40394: LD_VAR 0 11
40398: IFFALSE 40423
// result := Replace ( result , 3 , p ) ;
40400: LD_ADDR_VAR 0 2
40404: PUSH
40405: LD_VAR 0 2
40409: PPUSH
40410: LD_INT 3
40412: PPUSH
40413: LD_VAR 0 11
40417: PPUSH
40418: CALL_OW 1
40422: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40423: LD_VAR 0 4
40427: PUSH
40428: LD_INT 6
40430: GREATER
40431: PUSH
40432: LD_VAR 0 6
40436: PUSH
40437: LD_INT 6
40439: LESS
40440: AND
40441: IFFALSE 40635
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40443: LD_ADDR_VAR 0 9
40447: PUSH
40448: LD_VAR 0 4
40452: PUSH
40453: LD_VAR 0 8
40457: PUSH
40458: LD_VAR 0 7
40462: UNION
40463: PUSH
40464: LD_VAR 0 6
40468: UNION
40469: DIFF
40470: PPUSH
40471: LD_INT 2
40473: PPUSH
40474: CALL 104609 0 2
40478: ST_TO_ADDR
// p := [ ] ;
40479: LD_ADDR_VAR 0 11
40483: PUSH
40484: EMPTY
40485: ST_TO_ADDR
// if sort then
40486: LD_VAR 0 9
40490: IFFALSE 40606
// for i = 1 to 6 - eng do
40492: LD_ADDR_VAR 0 3
40496: PUSH
40497: DOUBLE
40498: LD_INT 1
40500: DEC
40501: ST_TO_ADDR
40502: LD_INT 6
40504: PUSH
40505: LD_VAR 0 6
40509: MINUS
40510: PUSH
40511: FOR_TO
40512: IFFALSE 40604
// begin if i = sort then
40514: LD_VAR 0 3
40518: PUSH
40519: LD_VAR 0 9
40523: EQUAL
40524: IFFALSE 40528
// break ;
40526: GO 40604
// if GetClass ( i ) = 2 then
40528: LD_VAR 0 3
40532: PPUSH
40533: CALL_OW 257
40537: PUSH
40538: LD_INT 2
40540: EQUAL
40541: IFFALSE 40545
// continue ;
40543: GO 40511
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40545: LD_ADDR_VAR 0 11
40549: PUSH
40550: LD_VAR 0 11
40554: PPUSH
40555: LD_VAR 0 11
40559: PUSH
40560: LD_INT 1
40562: PLUS
40563: PPUSH
40564: LD_VAR 0 9
40568: PUSH
40569: LD_VAR 0 3
40573: ARRAY
40574: PPUSH
40575: CALL_OW 2
40579: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40580: LD_ADDR_VAR 0 4
40584: PUSH
40585: LD_VAR 0 4
40589: PUSH
40590: LD_VAR 0 9
40594: PUSH
40595: LD_VAR 0 3
40599: ARRAY
40600: DIFF
40601: ST_TO_ADDR
// end ;
40602: GO 40511
40604: POP
40605: POP
// if p then
40606: LD_VAR 0 11
40610: IFFALSE 40635
// result := Replace ( result , 2 , p ) ;
40612: LD_ADDR_VAR 0 2
40616: PUSH
40617: LD_VAR 0 2
40621: PPUSH
40622: LD_INT 2
40624: PPUSH
40625: LD_VAR 0 11
40629: PPUSH
40630: CALL_OW 1
40634: ST_TO_ADDR
// end ; exit ;
40635: GO 42023
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40637: LD_EXP 126
40641: PUSH
40642: LD_EXP 125
40646: PUSH
40647: LD_VAR 0 1
40651: ARRAY
40652: ARRAY
40653: NOT
40654: PUSH
40655: LD_EXP 99
40659: PUSH
40660: LD_VAR 0 1
40664: ARRAY
40665: PPUSH
40666: LD_INT 30
40668: PUSH
40669: LD_INT 3
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PPUSH
40676: CALL_OW 72
40680: AND
40681: PUSH
40682: LD_EXP 104
40686: PUSH
40687: LD_VAR 0 1
40691: ARRAY
40692: AND
40693: IFFALSE 41301
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40695: LD_ADDR_EXP 141
40699: PUSH
40700: LD_EXP 141
40704: PPUSH
40705: LD_VAR 0 1
40709: PPUSH
40710: LD_INT 5
40712: PPUSH
40713: CALL_OW 1
40717: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40718: LD_ADDR_VAR 0 2
40722: PUSH
40723: LD_INT 0
40725: PUSH
40726: LD_INT 0
40728: PUSH
40729: LD_INT 0
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: LIST
40739: LIST
40740: ST_TO_ADDR
// if sci > 1 then
40741: LD_VAR 0 8
40745: PUSH
40746: LD_INT 1
40748: GREATER
40749: IFFALSE 40777
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40751: LD_ADDR_VAR 0 4
40755: PUSH
40756: LD_VAR 0 4
40760: PUSH
40761: LD_VAR 0 8
40765: PUSH
40766: LD_VAR 0 8
40770: PUSH
40771: LD_INT 1
40773: ARRAY
40774: DIFF
40775: DIFF
40776: ST_TO_ADDR
// if tmp and not sci then
40777: LD_VAR 0 4
40781: PUSH
40782: LD_VAR 0 8
40786: NOT
40787: AND
40788: IFFALSE 40857
// begin sort := SortBySkill ( tmp , 4 ) ;
40790: LD_ADDR_VAR 0 9
40794: PUSH
40795: LD_VAR 0 4
40799: PPUSH
40800: LD_INT 4
40802: PPUSH
40803: CALL 104609 0 2
40807: ST_TO_ADDR
// if sort then
40808: LD_VAR 0 9
40812: IFFALSE 40828
// p := sort [ 1 ] ;
40814: LD_ADDR_VAR 0 11
40818: PUSH
40819: LD_VAR 0 9
40823: PUSH
40824: LD_INT 1
40826: ARRAY
40827: ST_TO_ADDR
// if p then
40828: LD_VAR 0 11
40832: IFFALSE 40857
// result := Replace ( result , 4 , p ) ;
40834: LD_ADDR_VAR 0 2
40838: PUSH
40839: LD_VAR 0 2
40843: PPUSH
40844: LD_INT 4
40846: PPUSH
40847: LD_VAR 0 11
40851: PPUSH
40852: CALL_OW 1
40856: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40857: LD_ADDR_VAR 0 4
40861: PUSH
40862: LD_VAR 0 4
40866: PUSH
40867: LD_VAR 0 7
40871: DIFF
40872: ST_TO_ADDR
// if tmp and mech < 6 then
40873: LD_VAR 0 4
40877: PUSH
40878: LD_VAR 0 7
40882: PUSH
40883: LD_INT 6
40885: LESS
40886: AND
40887: IFFALSE 41075
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40889: LD_ADDR_VAR 0 9
40893: PUSH
40894: LD_VAR 0 4
40898: PUSH
40899: LD_VAR 0 8
40903: PUSH
40904: LD_VAR 0 7
40908: UNION
40909: DIFF
40910: PPUSH
40911: LD_INT 3
40913: PPUSH
40914: CALL 104609 0 2
40918: ST_TO_ADDR
// p := [ ] ;
40919: LD_ADDR_VAR 0 11
40923: PUSH
40924: EMPTY
40925: ST_TO_ADDR
// if sort then
40926: LD_VAR 0 9
40930: IFFALSE 41046
// for i = 1 to 6 - mech do
40932: LD_ADDR_VAR 0 3
40936: PUSH
40937: DOUBLE
40938: LD_INT 1
40940: DEC
40941: ST_TO_ADDR
40942: LD_INT 6
40944: PUSH
40945: LD_VAR 0 7
40949: MINUS
40950: PUSH
40951: FOR_TO
40952: IFFALSE 41044
// begin if i = sort then
40954: LD_VAR 0 3
40958: PUSH
40959: LD_VAR 0 9
40963: EQUAL
40964: IFFALSE 40968
// break ;
40966: GO 41044
// if GetClass ( i ) = 3 then
40968: LD_VAR 0 3
40972: PPUSH
40973: CALL_OW 257
40977: PUSH
40978: LD_INT 3
40980: EQUAL
40981: IFFALSE 40985
// continue ;
40983: GO 40951
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40985: LD_ADDR_VAR 0 11
40989: PUSH
40990: LD_VAR 0 11
40994: PPUSH
40995: LD_VAR 0 11
40999: PUSH
41000: LD_INT 1
41002: PLUS
41003: PPUSH
41004: LD_VAR 0 9
41008: PUSH
41009: LD_VAR 0 3
41013: ARRAY
41014: PPUSH
41015: CALL_OW 2
41019: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41020: LD_ADDR_VAR 0 4
41024: PUSH
41025: LD_VAR 0 4
41029: PUSH
41030: LD_VAR 0 9
41034: PUSH
41035: LD_VAR 0 3
41039: ARRAY
41040: DIFF
41041: ST_TO_ADDR
// end ;
41042: GO 40951
41044: POP
41045: POP
// if p then
41046: LD_VAR 0 11
41050: IFFALSE 41075
// result := Replace ( result , 3 , p ) ;
41052: LD_ADDR_VAR 0 2
41056: PUSH
41057: LD_VAR 0 2
41061: PPUSH
41062: LD_INT 3
41064: PPUSH
41065: LD_VAR 0 11
41069: PPUSH
41070: CALL_OW 1
41074: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41075: LD_ADDR_VAR 0 4
41079: PUSH
41080: LD_VAR 0 4
41084: PUSH
41085: LD_VAR 0 6
41089: DIFF
41090: ST_TO_ADDR
// if tmp and eng < 6 then
41091: LD_VAR 0 4
41095: PUSH
41096: LD_VAR 0 6
41100: PUSH
41101: LD_INT 6
41103: LESS
41104: AND
41105: IFFALSE 41299
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41107: LD_ADDR_VAR 0 9
41111: PUSH
41112: LD_VAR 0 4
41116: PUSH
41117: LD_VAR 0 8
41121: PUSH
41122: LD_VAR 0 7
41126: UNION
41127: PUSH
41128: LD_VAR 0 6
41132: UNION
41133: DIFF
41134: PPUSH
41135: LD_INT 2
41137: PPUSH
41138: CALL 104609 0 2
41142: ST_TO_ADDR
// p := [ ] ;
41143: LD_ADDR_VAR 0 11
41147: PUSH
41148: EMPTY
41149: ST_TO_ADDR
// if sort then
41150: LD_VAR 0 9
41154: IFFALSE 41270
// for i = 1 to 6 - eng do
41156: LD_ADDR_VAR 0 3
41160: PUSH
41161: DOUBLE
41162: LD_INT 1
41164: DEC
41165: ST_TO_ADDR
41166: LD_INT 6
41168: PUSH
41169: LD_VAR 0 6
41173: MINUS
41174: PUSH
41175: FOR_TO
41176: IFFALSE 41268
// begin if i = sort then
41178: LD_VAR 0 3
41182: PUSH
41183: LD_VAR 0 9
41187: EQUAL
41188: IFFALSE 41192
// break ;
41190: GO 41268
// if GetClass ( i ) = 2 then
41192: LD_VAR 0 3
41196: PPUSH
41197: CALL_OW 257
41201: PUSH
41202: LD_INT 2
41204: EQUAL
41205: IFFALSE 41209
// continue ;
41207: GO 41175
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41209: LD_ADDR_VAR 0 11
41213: PUSH
41214: LD_VAR 0 11
41218: PPUSH
41219: LD_VAR 0 11
41223: PUSH
41224: LD_INT 1
41226: PLUS
41227: PPUSH
41228: LD_VAR 0 9
41232: PUSH
41233: LD_VAR 0 3
41237: ARRAY
41238: PPUSH
41239: CALL_OW 2
41243: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41244: LD_ADDR_VAR 0 4
41248: PUSH
41249: LD_VAR 0 4
41253: PUSH
41254: LD_VAR 0 9
41258: PUSH
41259: LD_VAR 0 3
41263: ARRAY
41264: DIFF
41265: ST_TO_ADDR
// end ;
41266: GO 41175
41268: POP
41269: POP
// if p then
41270: LD_VAR 0 11
41274: IFFALSE 41299
// result := Replace ( result , 2 , p ) ;
41276: LD_ADDR_VAR 0 2
41280: PUSH
41281: LD_VAR 0 2
41285: PPUSH
41286: LD_INT 2
41288: PPUSH
41289: LD_VAR 0 11
41293: PPUSH
41294: CALL_OW 1
41298: ST_TO_ADDR
// end ; exit ;
41299: GO 42023
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41301: LD_EXP 126
41305: PUSH
41306: LD_EXP 125
41310: PUSH
41311: LD_VAR 0 1
41315: ARRAY
41316: ARRAY
41317: NOT
41318: PUSH
41319: LD_EXP 99
41323: PUSH
41324: LD_VAR 0 1
41328: ARRAY
41329: PPUSH
41330: LD_INT 30
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PPUSH
41340: CALL_OW 72
41344: AND
41345: PUSH
41346: LD_EXP 104
41350: PUSH
41351: LD_VAR 0 1
41355: ARRAY
41356: NOT
41357: AND
41358: IFFALSE 42023
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41360: LD_ADDR_EXP 141
41364: PUSH
41365: LD_EXP 141
41369: PPUSH
41370: LD_VAR 0 1
41374: PPUSH
41375: LD_INT 6
41377: PPUSH
41378: CALL_OW 1
41382: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41383: LD_ADDR_VAR 0 2
41387: PUSH
41388: LD_INT 0
41390: PUSH
41391: LD_INT 0
41393: PUSH
41394: LD_INT 0
41396: PUSH
41397: LD_INT 0
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: ST_TO_ADDR
// if sci >= 1 then
41406: LD_VAR 0 8
41410: PUSH
41411: LD_INT 1
41413: GREATEREQUAL
41414: IFFALSE 41436
// tmp := tmp diff sci [ 1 ] ;
41416: LD_ADDR_VAR 0 4
41420: PUSH
41421: LD_VAR 0 4
41425: PUSH
41426: LD_VAR 0 8
41430: PUSH
41431: LD_INT 1
41433: ARRAY
41434: DIFF
41435: ST_TO_ADDR
// if tmp and not sci then
41436: LD_VAR 0 4
41440: PUSH
41441: LD_VAR 0 8
41445: NOT
41446: AND
41447: IFFALSE 41516
// begin sort := SortBySkill ( tmp , 4 ) ;
41449: LD_ADDR_VAR 0 9
41453: PUSH
41454: LD_VAR 0 4
41458: PPUSH
41459: LD_INT 4
41461: PPUSH
41462: CALL 104609 0 2
41466: ST_TO_ADDR
// if sort then
41467: LD_VAR 0 9
41471: IFFALSE 41487
// p := sort [ 1 ] ;
41473: LD_ADDR_VAR 0 11
41477: PUSH
41478: LD_VAR 0 9
41482: PUSH
41483: LD_INT 1
41485: ARRAY
41486: ST_TO_ADDR
// if p then
41487: LD_VAR 0 11
41491: IFFALSE 41516
// result := Replace ( result , 4 , p ) ;
41493: LD_ADDR_VAR 0 2
41497: PUSH
41498: LD_VAR 0 2
41502: PPUSH
41503: LD_INT 4
41505: PPUSH
41506: LD_VAR 0 11
41510: PPUSH
41511: CALL_OW 1
41515: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41516: LD_ADDR_VAR 0 4
41520: PUSH
41521: LD_VAR 0 4
41525: PUSH
41526: LD_VAR 0 7
41530: DIFF
41531: ST_TO_ADDR
// if tmp and mech < 6 then
41532: LD_VAR 0 4
41536: PUSH
41537: LD_VAR 0 7
41541: PUSH
41542: LD_INT 6
41544: LESS
41545: AND
41546: IFFALSE 41728
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41548: LD_ADDR_VAR 0 9
41552: PUSH
41553: LD_VAR 0 4
41557: PUSH
41558: LD_VAR 0 7
41562: DIFF
41563: PPUSH
41564: LD_INT 3
41566: PPUSH
41567: CALL 104609 0 2
41571: ST_TO_ADDR
// p := [ ] ;
41572: LD_ADDR_VAR 0 11
41576: PUSH
41577: EMPTY
41578: ST_TO_ADDR
// if sort then
41579: LD_VAR 0 9
41583: IFFALSE 41699
// for i = 1 to 6 - mech do
41585: LD_ADDR_VAR 0 3
41589: PUSH
41590: DOUBLE
41591: LD_INT 1
41593: DEC
41594: ST_TO_ADDR
41595: LD_INT 6
41597: PUSH
41598: LD_VAR 0 7
41602: MINUS
41603: PUSH
41604: FOR_TO
41605: IFFALSE 41697
// begin if i = sort then
41607: LD_VAR 0 3
41611: PUSH
41612: LD_VAR 0 9
41616: EQUAL
41617: IFFALSE 41621
// break ;
41619: GO 41697
// if GetClass ( i ) = 3 then
41621: LD_VAR 0 3
41625: PPUSH
41626: CALL_OW 257
41630: PUSH
41631: LD_INT 3
41633: EQUAL
41634: IFFALSE 41638
// continue ;
41636: GO 41604
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41638: LD_ADDR_VAR 0 11
41642: PUSH
41643: LD_VAR 0 11
41647: PPUSH
41648: LD_VAR 0 11
41652: PUSH
41653: LD_INT 1
41655: PLUS
41656: PPUSH
41657: LD_VAR 0 9
41661: PUSH
41662: LD_VAR 0 3
41666: ARRAY
41667: PPUSH
41668: CALL_OW 2
41672: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41673: LD_ADDR_VAR 0 4
41677: PUSH
41678: LD_VAR 0 4
41682: PUSH
41683: LD_VAR 0 9
41687: PUSH
41688: LD_VAR 0 3
41692: ARRAY
41693: DIFF
41694: ST_TO_ADDR
// end ;
41695: GO 41604
41697: POP
41698: POP
// if p then
41699: LD_VAR 0 11
41703: IFFALSE 41728
// result := Replace ( result , 3 , p ) ;
41705: LD_ADDR_VAR 0 2
41709: PUSH
41710: LD_VAR 0 2
41714: PPUSH
41715: LD_INT 3
41717: PPUSH
41718: LD_VAR 0 11
41722: PPUSH
41723: CALL_OW 1
41727: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41728: LD_ADDR_VAR 0 4
41732: PUSH
41733: LD_VAR 0 4
41737: PUSH
41738: LD_VAR 0 6
41742: DIFF
41743: ST_TO_ADDR
// if tmp and eng < 4 then
41744: LD_VAR 0 4
41748: PUSH
41749: LD_VAR 0 6
41753: PUSH
41754: LD_INT 4
41756: LESS
41757: AND
41758: IFFALSE 41948
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41760: LD_ADDR_VAR 0 9
41764: PUSH
41765: LD_VAR 0 4
41769: PUSH
41770: LD_VAR 0 7
41774: PUSH
41775: LD_VAR 0 6
41779: UNION
41780: DIFF
41781: PPUSH
41782: LD_INT 2
41784: PPUSH
41785: CALL 104609 0 2
41789: ST_TO_ADDR
// p := [ ] ;
41790: LD_ADDR_VAR 0 11
41794: PUSH
41795: EMPTY
41796: ST_TO_ADDR
// if sort then
41797: LD_VAR 0 9
41801: IFFALSE 41917
// for i = 1 to 4 - eng do
41803: LD_ADDR_VAR 0 3
41807: PUSH
41808: DOUBLE
41809: LD_INT 1
41811: DEC
41812: ST_TO_ADDR
41813: LD_INT 4
41815: PUSH
41816: LD_VAR 0 6
41820: MINUS
41821: PUSH
41822: FOR_TO
41823: IFFALSE 41915
// begin if i = sort then
41825: LD_VAR 0 3
41829: PUSH
41830: LD_VAR 0 9
41834: EQUAL
41835: IFFALSE 41839
// break ;
41837: GO 41915
// if GetClass ( i ) = 2 then
41839: LD_VAR 0 3
41843: PPUSH
41844: CALL_OW 257
41848: PUSH
41849: LD_INT 2
41851: EQUAL
41852: IFFALSE 41856
// continue ;
41854: GO 41822
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41856: LD_ADDR_VAR 0 11
41860: PUSH
41861: LD_VAR 0 11
41865: PPUSH
41866: LD_VAR 0 11
41870: PUSH
41871: LD_INT 1
41873: PLUS
41874: PPUSH
41875: LD_VAR 0 9
41879: PUSH
41880: LD_VAR 0 3
41884: ARRAY
41885: PPUSH
41886: CALL_OW 2
41890: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41891: LD_ADDR_VAR 0 4
41895: PUSH
41896: LD_VAR 0 4
41900: PUSH
41901: LD_VAR 0 9
41905: PUSH
41906: LD_VAR 0 3
41910: ARRAY
41911: DIFF
41912: ST_TO_ADDR
// end ;
41913: GO 41822
41915: POP
41916: POP
// if p then
41917: LD_VAR 0 11
41921: IFFALSE 41946
// result := Replace ( result , 2 , p ) ;
41923: LD_ADDR_VAR 0 2
41927: PUSH
41928: LD_VAR 0 2
41932: PPUSH
41933: LD_INT 2
41935: PPUSH
41936: LD_VAR 0 11
41940: PPUSH
41941: CALL_OW 1
41945: ST_TO_ADDR
// end else
41946: GO 41992
// for i = eng downto 5 do
41948: LD_ADDR_VAR 0 3
41952: PUSH
41953: DOUBLE
41954: LD_VAR 0 6
41958: INC
41959: ST_TO_ADDR
41960: LD_INT 5
41962: PUSH
41963: FOR_DOWNTO
41964: IFFALSE 41990
// tmp := tmp union eng [ i ] ;
41966: LD_ADDR_VAR 0 4
41970: PUSH
41971: LD_VAR 0 4
41975: PUSH
41976: LD_VAR 0 6
41980: PUSH
41981: LD_VAR 0 3
41985: ARRAY
41986: UNION
41987: ST_TO_ADDR
41988: GO 41963
41990: POP
41991: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41992: LD_ADDR_VAR 0 2
41996: PUSH
41997: LD_VAR 0 2
42001: PPUSH
42002: LD_INT 1
42004: PPUSH
42005: LD_VAR 0 4
42009: PUSH
42010: LD_VAR 0 5
42014: DIFF
42015: PPUSH
42016: CALL_OW 1
42020: ST_TO_ADDR
// exit ;
42021: GO 42023
// end ; end ;
42023: LD_VAR 0 2
42027: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42028: LD_INT 0
42030: PPUSH
42031: PPUSH
42032: PPUSH
// if not mc_bases then
42033: LD_EXP 99
42037: NOT
42038: IFFALSE 42042
// exit ;
42040: GO 42148
// for i = 1 to mc_bases do
42042: LD_ADDR_VAR 0 2
42046: PUSH
42047: DOUBLE
42048: LD_INT 1
42050: DEC
42051: ST_TO_ADDR
42052: LD_EXP 99
42056: PUSH
42057: FOR_TO
42058: IFFALSE 42139
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42060: LD_ADDR_VAR 0 3
42064: PUSH
42065: LD_EXP 99
42069: PUSH
42070: LD_VAR 0 2
42074: ARRAY
42075: PPUSH
42076: LD_INT 21
42078: PUSH
42079: LD_INT 3
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: LD_INT 3
42088: PUSH
42089: LD_INT 24
42091: PUSH
42092: LD_INT 1000
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PPUSH
42107: CALL_OW 72
42111: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42112: LD_ADDR_EXP 100
42116: PUSH
42117: LD_EXP 100
42121: PPUSH
42122: LD_VAR 0 2
42126: PPUSH
42127: LD_VAR 0 3
42131: PPUSH
42132: CALL_OW 1
42136: ST_TO_ADDR
// end ;
42137: GO 42057
42139: POP
42140: POP
// RaiseSailEvent ( 101 ) ;
42141: LD_INT 101
42143: PPUSH
42144: CALL_OW 427
// end ;
42148: LD_VAR 0 1
42152: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42153: LD_INT 0
42155: PPUSH
42156: PPUSH
42157: PPUSH
42158: PPUSH
42159: PPUSH
42160: PPUSH
42161: PPUSH
// if not mc_bases then
42162: LD_EXP 99
42166: NOT
42167: IFFALSE 42171
// exit ;
42169: GO 42744
// for i = 1 to mc_bases do
42171: LD_ADDR_VAR 0 2
42175: PUSH
42176: DOUBLE
42177: LD_INT 1
42179: DEC
42180: ST_TO_ADDR
42181: LD_EXP 99
42185: PUSH
42186: FOR_TO
42187: IFFALSE 42735
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42189: LD_ADDR_VAR 0 5
42193: PUSH
42194: LD_EXP 99
42198: PUSH
42199: LD_VAR 0 2
42203: ARRAY
42204: PUSH
42205: LD_EXP 128
42209: PUSH
42210: LD_VAR 0 2
42214: ARRAY
42215: UNION
42216: PPUSH
42217: LD_INT 21
42219: PUSH
42220: LD_INT 1
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: LD_INT 3
42232: PUSH
42233: LD_INT 54
42235: PUSH
42236: EMPTY
42237: LIST
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 24
42248: PUSH
42249: LD_INT 800
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: LIST
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PPUSH
42269: CALL_OW 72
42273: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42274: LD_ADDR_VAR 0 6
42278: PUSH
42279: LD_EXP 99
42283: PUSH
42284: LD_VAR 0 2
42288: ARRAY
42289: PPUSH
42290: LD_INT 21
42292: PUSH
42293: LD_INT 1
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 1
42302: PUSH
42303: LD_INT 3
42305: PUSH
42306: LD_INT 54
42308: PUSH
42309: EMPTY
42310: LIST
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 3
42318: PUSH
42319: LD_INT 24
42321: PUSH
42322: LD_INT 250
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PPUSH
42342: CALL_OW 72
42346: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42347: LD_ADDR_VAR 0 7
42351: PUSH
42352: LD_VAR 0 5
42356: PUSH
42357: LD_VAR 0 6
42361: DIFF
42362: ST_TO_ADDR
// if not need_heal_1 then
42363: LD_VAR 0 6
42367: NOT
42368: IFFALSE 42401
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42370: LD_ADDR_EXP 102
42374: PUSH
42375: LD_EXP 102
42379: PPUSH
42380: LD_VAR 0 2
42384: PUSH
42385: LD_INT 1
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PPUSH
42392: EMPTY
42393: PPUSH
42394: CALL 70361 0 3
42398: ST_TO_ADDR
42399: GO 42471
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42401: LD_ADDR_EXP 102
42405: PUSH
42406: LD_EXP 102
42410: PPUSH
42411: LD_VAR 0 2
42415: PUSH
42416: LD_INT 1
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PPUSH
42423: LD_EXP 102
42427: PUSH
42428: LD_VAR 0 2
42432: ARRAY
42433: PUSH
42434: LD_INT 1
42436: ARRAY
42437: PPUSH
42438: LD_INT 3
42440: PUSH
42441: LD_INT 24
42443: PUSH
42444: LD_INT 1000
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PPUSH
42455: CALL_OW 72
42459: PUSH
42460: LD_VAR 0 6
42464: UNION
42465: PPUSH
42466: CALL 70361 0 3
42470: ST_TO_ADDR
// if not need_heal_2 then
42471: LD_VAR 0 7
42475: NOT
42476: IFFALSE 42509
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42478: LD_ADDR_EXP 102
42482: PUSH
42483: LD_EXP 102
42487: PPUSH
42488: LD_VAR 0 2
42492: PUSH
42493: LD_INT 2
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PPUSH
42500: EMPTY
42501: PPUSH
42502: CALL 70361 0 3
42506: ST_TO_ADDR
42507: GO 42541
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42509: LD_ADDR_EXP 102
42513: PUSH
42514: LD_EXP 102
42518: PPUSH
42519: LD_VAR 0 2
42523: PUSH
42524: LD_INT 2
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PPUSH
42531: LD_VAR 0 7
42535: PPUSH
42536: CALL 70361 0 3
42540: ST_TO_ADDR
// if need_heal_2 then
42541: LD_VAR 0 7
42545: IFFALSE 42717
// for j in need_heal_2 do
42547: LD_ADDR_VAR 0 3
42551: PUSH
42552: LD_VAR 0 7
42556: PUSH
42557: FOR_IN
42558: IFFALSE 42715
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42560: LD_ADDR_VAR 0 5
42564: PUSH
42565: LD_EXP 99
42569: PUSH
42570: LD_VAR 0 2
42574: ARRAY
42575: PPUSH
42576: LD_INT 2
42578: PUSH
42579: LD_INT 30
42581: PUSH
42582: LD_INT 6
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 30
42591: PUSH
42592: LD_INT 7
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 30
42601: PUSH
42602: LD_INT 8
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 30
42611: PUSH
42612: LD_INT 0
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: PUSH
42619: LD_INT 30
42621: PUSH
42622: LD_INT 1
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 25
42631: PUSH
42632: LD_INT 4
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: LIST
42643: LIST
42644: LIST
42645: LIST
42646: LIST
42647: PPUSH
42648: CALL_OW 72
42652: ST_TO_ADDR
// if tmp then
42653: LD_VAR 0 5
42657: IFFALSE 42713
// begin k := NearestUnitToUnit ( tmp , j ) ;
42659: LD_ADDR_VAR 0 4
42663: PUSH
42664: LD_VAR 0 5
42668: PPUSH
42669: LD_VAR 0 3
42673: PPUSH
42674: CALL_OW 74
42678: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42679: LD_VAR 0 3
42683: PPUSH
42684: LD_VAR 0 4
42688: PPUSH
42689: CALL_OW 296
42693: PUSH
42694: LD_INT 7
42696: GREATER
42697: IFFALSE 42713
// ComMoveUnit ( j , k ) ;
42699: LD_VAR 0 3
42703: PPUSH
42704: LD_VAR 0 4
42708: PPUSH
42709: CALL_OW 112
// end ; end ;
42713: GO 42557
42715: POP
42716: POP
// if not need_heal_1 and not need_heal_2 then
42717: LD_VAR 0 6
42721: NOT
42722: PUSH
42723: LD_VAR 0 7
42727: NOT
42728: AND
42729: IFFALSE 42733
// continue ;
42731: GO 42186
// end ;
42733: GO 42186
42735: POP
42736: POP
// RaiseSailEvent ( 102 ) ;
42737: LD_INT 102
42739: PPUSH
42740: CALL_OW 427
// end ;
42744: LD_VAR 0 1
42748: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42749: LD_INT 0
42751: PPUSH
42752: PPUSH
42753: PPUSH
42754: PPUSH
42755: PPUSH
42756: PPUSH
// if not mc_bases then
42757: LD_EXP 99
42761: NOT
42762: IFFALSE 42766
// exit ;
42764: GO 43476
// for i = 1 to mc_bases do
42766: LD_ADDR_VAR 0 2
42770: PUSH
42771: DOUBLE
42772: LD_INT 1
42774: DEC
42775: ST_TO_ADDR
42776: LD_EXP 99
42780: PUSH
42781: FOR_TO
42782: IFFALSE 43474
// begin if not mc_building_need_repair [ i ] then
42784: LD_EXP 100
42788: PUSH
42789: LD_VAR 0 2
42793: ARRAY
42794: NOT
42795: IFFALSE 42969
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42797: LD_ADDR_VAR 0 6
42801: PUSH
42802: LD_EXP 118
42806: PUSH
42807: LD_VAR 0 2
42811: ARRAY
42812: PPUSH
42813: LD_INT 3
42815: PUSH
42816: LD_INT 24
42818: PUSH
42819: LD_INT 1000
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: PUSH
42830: LD_INT 2
42832: PUSH
42833: LD_INT 34
42835: PUSH
42836: LD_INT 13
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 34
42845: PUSH
42846: LD_INT 52
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: LIST
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PPUSH
42862: CALL_OW 72
42866: ST_TO_ADDR
// if cranes then
42867: LD_VAR 0 6
42871: IFFALSE 42933
// for j in cranes do
42873: LD_ADDR_VAR 0 3
42877: PUSH
42878: LD_VAR 0 6
42882: PUSH
42883: FOR_IN
42884: IFFALSE 42931
// if not IsInArea ( j , mc_parking [ i ] ) then
42886: LD_VAR 0 3
42890: PPUSH
42891: LD_EXP 123
42895: PUSH
42896: LD_VAR 0 2
42900: ARRAY
42901: PPUSH
42902: CALL_OW 308
42906: NOT
42907: IFFALSE 42929
// ComMoveToArea ( j , mc_parking [ i ] ) ;
42909: LD_VAR 0 3
42913: PPUSH
42914: LD_EXP 123
42918: PUSH
42919: LD_VAR 0 2
42923: ARRAY
42924: PPUSH
42925: CALL_OW 113
42929: GO 42883
42931: POP
42932: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42933: LD_ADDR_EXP 101
42937: PUSH
42938: LD_EXP 101
42942: PPUSH
42943: LD_VAR 0 2
42947: PPUSH
42948: EMPTY
42949: PPUSH
42950: CALL_OW 1
42954: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42955: LD_VAR 0 2
42959: PPUSH
42960: LD_INT 101
42962: PPUSH
42963: CALL 37861 0 2
// continue ;
42967: GO 42781
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42969: LD_ADDR_EXP 105
42973: PUSH
42974: LD_EXP 105
42978: PPUSH
42979: LD_VAR 0 2
42983: PPUSH
42984: EMPTY
42985: PPUSH
42986: CALL_OW 1
42990: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42991: LD_VAR 0 2
42995: PPUSH
42996: LD_INT 103
42998: PPUSH
42999: CALL 37861 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43003: LD_ADDR_VAR 0 5
43007: PUSH
43008: LD_EXP 99
43012: PUSH
43013: LD_VAR 0 2
43017: ARRAY
43018: PUSH
43019: LD_EXP 128
43023: PUSH
43024: LD_VAR 0 2
43028: ARRAY
43029: UNION
43030: PPUSH
43031: LD_INT 2
43033: PUSH
43034: LD_INT 25
43036: PUSH
43037: LD_INT 2
43039: PUSH
43040: EMPTY
43041: LIST
43042: LIST
43043: PUSH
43044: LD_INT 25
43046: PUSH
43047: LD_INT 16
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: PPUSH
43062: CALL_OW 72
43066: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43067: LD_ADDR_VAR 0 6
43071: PUSH
43072: LD_EXP 118
43076: PUSH
43077: LD_VAR 0 2
43081: ARRAY
43082: PPUSH
43083: LD_INT 2
43085: PUSH
43086: LD_INT 34
43088: PUSH
43089: LD_INT 13
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: LD_INT 34
43098: PUSH
43099: LD_INT 52
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: LIST
43110: PPUSH
43111: CALL_OW 72
43115: ST_TO_ADDR
// if cranes then
43116: LD_VAR 0 6
43120: IFFALSE 43256
// begin for j in cranes do
43122: LD_ADDR_VAR 0 3
43126: PUSH
43127: LD_VAR 0 6
43131: PUSH
43132: FOR_IN
43133: IFFALSE 43254
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43135: LD_VAR 0 3
43139: PPUSH
43140: CALL_OW 256
43144: PUSH
43145: LD_INT 500
43147: GREATEREQUAL
43148: PUSH
43149: LD_VAR 0 3
43153: PPUSH
43154: CALL_OW 314
43158: NOT
43159: AND
43160: IFFALSE 43194
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43162: LD_VAR 0 3
43166: PPUSH
43167: LD_EXP 100
43171: PUSH
43172: LD_VAR 0 2
43176: ARRAY
43177: PPUSH
43178: LD_VAR 0 3
43182: PPUSH
43183: CALL_OW 74
43187: PPUSH
43188: CALL_OW 130
43192: GO 43252
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43194: LD_VAR 0 3
43198: PPUSH
43199: CALL_OW 256
43203: PUSH
43204: LD_INT 500
43206: LESS
43207: PUSH
43208: LD_VAR 0 3
43212: PPUSH
43213: LD_EXP 123
43217: PUSH
43218: LD_VAR 0 2
43222: ARRAY
43223: PPUSH
43224: CALL_OW 308
43228: NOT
43229: AND
43230: IFFALSE 43252
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43232: LD_VAR 0 3
43236: PPUSH
43237: LD_EXP 123
43241: PUSH
43242: LD_VAR 0 2
43246: ARRAY
43247: PPUSH
43248: CALL_OW 113
43252: GO 43132
43254: POP
43255: POP
// end ; if not tmp then
43256: LD_VAR 0 5
43260: NOT
43261: IFFALSE 43265
// continue ;
43263: GO 42781
// for j in tmp do
43265: LD_ADDR_VAR 0 3
43269: PUSH
43270: LD_VAR 0 5
43274: PUSH
43275: FOR_IN
43276: IFFALSE 43470
// begin if mc_need_heal [ i ] then
43278: LD_EXP 102
43282: PUSH
43283: LD_VAR 0 2
43287: ARRAY
43288: IFFALSE 43336
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43290: LD_VAR 0 3
43294: PUSH
43295: LD_EXP 102
43299: PUSH
43300: LD_VAR 0 2
43304: ARRAY
43305: PUSH
43306: LD_INT 1
43308: ARRAY
43309: IN
43310: PUSH
43311: LD_VAR 0 3
43315: PUSH
43316: LD_EXP 102
43320: PUSH
43321: LD_VAR 0 2
43325: ARRAY
43326: PUSH
43327: LD_INT 2
43329: ARRAY
43330: IN
43331: OR
43332: IFFALSE 43336
// continue ;
43334: GO 43275
// if IsInUnit ( j ) then
43336: LD_VAR 0 3
43340: PPUSH
43341: CALL_OW 310
43345: IFFALSE 43356
// ComExitBuilding ( j ) ;
43347: LD_VAR 0 3
43351: PPUSH
43352: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43356: LD_VAR 0 3
43360: PUSH
43361: LD_EXP 101
43365: PUSH
43366: LD_VAR 0 2
43370: ARRAY
43371: IN
43372: NOT
43373: IFFALSE 43431
// begin SetTag ( j , 101 ) ;
43375: LD_VAR 0 3
43379: PPUSH
43380: LD_INT 101
43382: PPUSH
43383: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43387: LD_ADDR_EXP 101
43391: PUSH
43392: LD_EXP 101
43396: PPUSH
43397: LD_VAR 0 2
43401: PUSH
43402: LD_EXP 101
43406: PUSH
43407: LD_VAR 0 2
43411: ARRAY
43412: PUSH
43413: LD_INT 1
43415: PLUS
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PPUSH
43421: LD_VAR 0 3
43425: PPUSH
43426: CALL 70361 0 3
43430: ST_TO_ADDR
// end ; wait ( 1 ) ;
43431: LD_INT 1
43433: PPUSH
43434: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43438: LD_VAR 0 3
43442: PPUSH
43443: LD_EXP 100
43447: PUSH
43448: LD_VAR 0 2
43452: ARRAY
43453: PPUSH
43454: LD_VAR 0 3
43458: PPUSH
43459: CALL_OW 74
43463: PPUSH
43464: CALL_OW 130
// end ;
43468: GO 43275
43470: POP
43471: POP
// end ;
43472: GO 42781
43474: POP
43475: POP
// end ;
43476: LD_VAR 0 1
43480: RET
// export function MC_Heal ; var i , j , tmp ; begin
43481: LD_INT 0
43483: PPUSH
43484: PPUSH
43485: PPUSH
43486: PPUSH
// if not mc_bases then
43487: LD_EXP 99
43491: NOT
43492: IFFALSE 43496
// exit ;
43494: GO 43898
// for i = 1 to mc_bases do
43496: LD_ADDR_VAR 0 2
43500: PUSH
43501: DOUBLE
43502: LD_INT 1
43504: DEC
43505: ST_TO_ADDR
43506: LD_EXP 99
43510: PUSH
43511: FOR_TO
43512: IFFALSE 43896
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43514: LD_EXP 102
43518: PUSH
43519: LD_VAR 0 2
43523: ARRAY
43524: PUSH
43525: LD_INT 1
43527: ARRAY
43528: NOT
43529: PUSH
43530: LD_EXP 102
43534: PUSH
43535: LD_VAR 0 2
43539: ARRAY
43540: PUSH
43541: LD_INT 2
43543: ARRAY
43544: NOT
43545: AND
43546: IFFALSE 43584
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43548: LD_ADDR_EXP 103
43552: PUSH
43553: LD_EXP 103
43557: PPUSH
43558: LD_VAR 0 2
43562: PPUSH
43563: EMPTY
43564: PPUSH
43565: CALL_OW 1
43569: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43570: LD_VAR 0 2
43574: PPUSH
43575: LD_INT 102
43577: PPUSH
43578: CALL 37861 0 2
// continue ;
43582: GO 43511
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43584: LD_ADDR_VAR 0 4
43588: PUSH
43589: LD_EXP 99
43593: PUSH
43594: LD_VAR 0 2
43598: ARRAY
43599: PPUSH
43600: LD_INT 25
43602: PUSH
43603: LD_INT 4
43605: PUSH
43606: EMPTY
43607: LIST
43608: LIST
43609: PPUSH
43610: CALL_OW 72
43614: ST_TO_ADDR
// if not tmp then
43615: LD_VAR 0 4
43619: NOT
43620: IFFALSE 43624
// continue ;
43622: GO 43511
// if mc_taming [ i ] then
43624: LD_EXP 130
43628: PUSH
43629: LD_VAR 0 2
43633: ARRAY
43634: IFFALSE 43658
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43636: LD_ADDR_EXP 130
43640: PUSH
43641: LD_EXP 130
43645: PPUSH
43646: LD_VAR 0 2
43650: PPUSH
43651: EMPTY
43652: PPUSH
43653: CALL_OW 1
43657: ST_TO_ADDR
// for j in tmp do
43658: LD_ADDR_VAR 0 3
43662: PUSH
43663: LD_VAR 0 4
43667: PUSH
43668: FOR_IN
43669: IFFALSE 43892
// begin if IsInUnit ( j ) then
43671: LD_VAR 0 3
43675: PPUSH
43676: CALL_OW 310
43680: IFFALSE 43691
// ComExitBuilding ( j ) ;
43682: LD_VAR 0 3
43686: PPUSH
43687: CALL_OW 122
// if not j in mc_healers [ i ] then
43691: LD_VAR 0 3
43695: PUSH
43696: LD_EXP 103
43700: PUSH
43701: LD_VAR 0 2
43705: ARRAY
43706: IN
43707: NOT
43708: IFFALSE 43754
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43710: LD_ADDR_EXP 103
43714: PUSH
43715: LD_EXP 103
43719: PPUSH
43720: LD_VAR 0 2
43724: PUSH
43725: LD_EXP 103
43729: PUSH
43730: LD_VAR 0 2
43734: ARRAY
43735: PUSH
43736: LD_INT 1
43738: PLUS
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PPUSH
43744: LD_VAR 0 3
43748: PPUSH
43749: CALL 70361 0 3
43753: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43754: LD_VAR 0 3
43758: PPUSH
43759: CALL_OW 110
43763: PUSH
43764: LD_INT 102
43766: NONEQUAL
43767: IFFALSE 43781
// SetTag ( j , 102 ) ;
43769: LD_VAR 0 3
43773: PPUSH
43774: LD_INT 102
43776: PPUSH
43777: CALL_OW 109
// Wait ( 3 ) ;
43781: LD_INT 3
43783: PPUSH
43784: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43788: LD_EXP 102
43792: PUSH
43793: LD_VAR 0 2
43797: ARRAY
43798: PUSH
43799: LD_INT 1
43801: ARRAY
43802: IFFALSE 43834
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43804: LD_VAR 0 3
43808: PPUSH
43809: LD_EXP 102
43813: PUSH
43814: LD_VAR 0 2
43818: ARRAY
43819: PUSH
43820: LD_INT 1
43822: ARRAY
43823: PUSH
43824: LD_INT 1
43826: ARRAY
43827: PPUSH
43828: CALL_OW 128
43832: GO 43890
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43834: LD_VAR 0 3
43838: PPUSH
43839: CALL_OW 314
43843: NOT
43844: PUSH
43845: LD_EXP 102
43849: PUSH
43850: LD_VAR 0 2
43854: ARRAY
43855: PUSH
43856: LD_INT 2
43858: ARRAY
43859: AND
43860: IFFALSE 43890
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43862: LD_VAR 0 3
43866: PPUSH
43867: LD_EXP 102
43871: PUSH
43872: LD_VAR 0 2
43876: ARRAY
43877: PUSH
43878: LD_INT 2
43880: ARRAY
43881: PUSH
43882: LD_INT 1
43884: ARRAY
43885: PPUSH
43886: CALL_OW 128
// end ;
43890: GO 43668
43892: POP
43893: POP
// end ;
43894: GO 43511
43896: POP
43897: POP
// end ;
43898: LD_VAR 0 1
43902: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43903: LD_INT 0
43905: PPUSH
43906: PPUSH
43907: PPUSH
43908: PPUSH
43909: PPUSH
// if not mc_bases then
43910: LD_EXP 99
43914: NOT
43915: IFFALSE 43919
// exit ;
43917: GO 45062
// for i = 1 to mc_bases do
43919: LD_ADDR_VAR 0 2
43923: PUSH
43924: DOUBLE
43925: LD_INT 1
43927: DEC
43928: ST_TO_ADDR
43929: LD_EXP 99
43933: PUSH
43934: FOR_TO
43935: IFFALSE 45060
// begin if mc_scan [ i ] then
43937: LD_EXP 122
43941: PUSH
43942: LD_VAR 0 2
43946: ARRAY
43947: IFFALSE 43951
// continue ;
43949: GO 43934
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43951: LD_EXP 104
43955: PUSH
43956: LD_VAR 0 2
43960: ARRAY
43961: NOT
43962: PUSH
43963: LD_EXP 106
43967: PUSH
43968: LD_VAR 0 2
43972: ARRAY
43973: NOT
43974: AND
43975: PUSH
43976: LD_EXP 105
43980: PUSH
43981: LD_VAR 0 2
43985: ARRAY
43986: AND
43987: IFFALSE 44025
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43989: LD_ADDR_EXP 105
43993: PUSH
43994: LD_EXP 105
43998: PPUSH
43999: LD_VAR 0 2
44003: PPUSH
44004: EMPTY
44005: PPUSH
44006: CALL_OW 1
44010: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44011: LD_VAR 0 2
44015: PPUSH
44016: LD_INT 103
44018: PPUSH
44019: CALL 37861 0 2
// continue ;
44023: GO 43934
// end ; if mc_construct_list [ i ] then
44025: LD_EXP 106
44029: PUSH
44030: LD_VAR 0 2
44034: ARRAY
44035: IFFALSE 44255
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44037: LD_ADDR_VAR 0 4
44041: PUSH
44042: LD_EXP 99
44046: PUSH
44047: LD_VAR 0 2
44051: ARRAY
44052: PPUSH
44053: LD_INT 25
44055: PUSH
44056: LD_INT 2
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PPUSH
44063: CALL_OW 72
44067: PUSH
44068: LD_EXP 101
44072: PUSH
44073: LD_VAR 0 2
44077: ARRAY
44078: DIFF
44079: ST_TO_ADDR
// if not tmp then
44080: LD_VAR 0 4
44084: NOT
44085: IFFALSE 44089
// continue ;
44087: GO 43934
// for j in tmp do
44089: LD_ADDR_VAR 0 3
44093: PUSH
44094: LD_VAR 0 4
44098: PUSH
44099: FOR_IN
44100: IFFALSE 44251
// begin if not mc_builders [ i ] then
44102: LD_EXP 105
44106: PUSH
44107: LD_VAR 0 2
44111: ARRAY
44112: NOT
44113: IFFALSE 44171
// begin SetTag ( j , 103 ) ;
44115: LD_VAR 0 3
44119: PPUSH
44120: LD_INT 103
44122: PPUSH
44123: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44127: LD_ADDR_EXP 105
44131: PUSH
44132: LD_EXP 105
44136: PPUSH
44137: LD_VAR 0 2
44141: PUSH
44142: LD_EXP 105
44146: PUSH
44147: LD_VAR 0 2
44151: ARRAY
44152: PUSH
44153: LD_INT 1
44155: PLUS
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PPUSH
44161: LD_VAR 0 3
44165: PPUSH
44166: CALL 70361 0 3
44170: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44171: LD_VAR 0 3
44175: PPUSH
44176: CALL_OW 310
44180: IFFALSE 44191
// ComExitBuilding ( j ) ;
44182: LD_VAR 0 3
44186: PPUSH
44187: CALL_OW 122
// wait ( 3 ) ;
44191: LD_INT 3
44193: PPUSH
44194: CALL_OW 67
// if not mc_construct_list [ i ] then
44198: LD_EXP 106
44202: PUSH
44203: LD_VAR 0 2
44207: ARRAY
44208: NOT
44209: IFFALSE 44213
// break ;
44211: GO 44251
// if not HasTask ( j ) then
44213: LD_VAR 0 3
44217: PPUSH
44218: CALL_OW 314
44222: NOT
44223: IFFALSE 44249
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44225: LD_VAR 0 3
44229: PPUSH
44230: LD_EXP 106
44234: PUSH
44235: LD_VAR 0 2
44239: ARRAY
44240: PUSH
44241: LD_INT 1
44243: ARRAY
44244: PPUSH
44245: CALL 73212 0 2
// end ;
44249: GO 44099
44251: POP
44252: POP
// end else
44253: GO 45058
// if mc_build_list [ i ] then
44255: LD_EXP 104
44259: PUSH
44260: LD_VAR 0 2
44264: ARRAY
44265: IFFALSE 45058
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44267: LD_ADDR_VAR 0 5
44271: PUSH
44272: LD_EXP 99
44276: PUSH
44277: LD_VAR 0 2
44281: ARRAY
44282: PPUSH
44283: LD_INT 2
44285: PUSH
44286: LD_INT 30
44288: PUSH
44289: LD_INT 0
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 30
44298: PUSH
44299: LD_INT 1
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: LIST
44310: PPUSH
44311: CALL_OW 72
44315: ST_TO_ADDR
// if depot then
44316: LD_VAR 0 5
44320: IFFALSE 44338
// depot := depot [ 1 ] else
44322: LD_ADDR_VAR 0 5
44326: PUSH
44327: LD_VAR 0 5
44331: PUSH
44332: LD_INT 1
44334: ARRAY
44335: ST_TO_ADDR
44336: GO 44346
// depot := 0 ;
44338: LD_ADDR_VAR 0 5
44342: PUSH
44343: LD_INT 0
44345: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44346: LD_EXP 104
44350: PUSH
44351: LD_VAR 0 2
44355: ARRAY
44356: PUSH
44357: LD_INT 1
44359: ARRAY
44360: PUSH
44361: LD_INT 1
44363: ARRAY
44364: PPUSH
44365: CALL 73042 0 1
44369: PUSH
44370: LD_EXP 99
44374: PUSH
44375: LD_VAR 0 2
44379: ARRAY
44380: PPUSH
44381: LD_INT 2
44383: PUSH
44384: LD_INT 30
44386: PUSH
44387: LD_INT 2
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 30
44396: PUSH
44397: LD_INT 3
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: PPUSH
44409: CALL_OW 72
44413: NOT
44414: AND
44415: IFFALSE 44520
// begin for j = 1 to mc_build_list [ i ] do
44417: LD_ADDR_VAR 0 3
44421: PUSH
44422: DOUBLE
44423: LD_INT 1
44425: DEC
44426: ST_TO_ADDR
44427: LD_EXP 104
44431: PUSH
44432: LD_VAR 0 2
44436: ARRAY
44437: PUSH
44438: FOR_TO
44439: IFFALSE 44518
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44441: LD_EXP 104
44445: PUSH
44446: LD_VAR 0 2
44450: ARRAY
44451: PUSH
44452: LD_VAR 0 3
44456: ARRAY
44457: PUSH
44458: LD_INT 1
44460: ARRAY
44461: PUSH
44462: LD_INT 2
44464: EQUAL
44465: IFFALSE 44516
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44467: LD_ADDR_EXP 104
44471: PUSH
44472: LD_EXP 104
44476: PPUSH
44477: LD_VAR 0 2
44481: PPUSH
44482: LD_EXP 104
44486: PUSH
44487: LD_VAR 0 2
44491: ARRAY
44492: PPUSH
44493: LD_VAR 0 3
44497: PPUSH
44498: LD_INT 1
44500: PPUSH
44501: LD_INT 0
44503: PPUSH
44504: CALL 69779 0 4
44508: PPUSH
44509: CALL_OW 1
44513: ST_TO_ADDR
// break ;
44514: GO 44518
// end ;
44516: GO 44438
44518: POP
44519: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44520: LD_EXP 104
44524: PUSH
44525: LD_VAR 0 2
44529: ARRAY
44530: PUSH
44531: LD_INT 1
44533: ARRAY
44534: PUSH
44535: LD_INT 1
44537: ARRAY
44538: PUSH
44539: LD_INT 0
44541: EQUAL
44542: PUSH
44543: LD_VAR 0 5
44547: PUSH
44548: LD_VAR 0 5
44552: PPUSH
44553: LD_EXP 104
44557: PUSH
44558: LD_VAR 0 2
44562: ARRAY
44563: PUSH
44564: LD_INT 1
44566: ARRAY
44567: PUSH
44568: LD_INT 1
44570: ARRAY
44571: PPUSH
44572: LD_EXP 104
44576: PUSH
44577: LD_VAR 0 2
44581: ARRAY
44582: PUSH
44583: LD_INT 1
44585: ARRAY
44586: PUSH
44587: LD_INT 2
44589: ARRAY
44590: PPUSH
44591: LD_EXP 104
44595: PUSH
44596: LD_VAR 0 2
44600: ARRAY
44601: PUSH
44602: LD_INT 1
44604: ARRAY
44605: PUSH
44606: LD_INT 3
44608: ARRAY
44609: PPUSH
44610: LD_EXP 104
44614: PUSH
44615: LD_VAR 0 2
44619: ARRAY
44620: PUSH
44621: LD_INT 1
44623: ARRAY
44624: PUSH
44625: LD_INT 4
44627: ARRAY
44628: PPUSH
44629: CALL 77776 0 5
44633: AND
44634: OR
44635: IFFALSE 44916
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44637: LD_ADDR_VAR 0 4
44641: PUSH
44642: LD_EXP 99
44646: PUSH
44647: LD_VAR 0 2
44651: ARRAY
44652: PPUSH
44653: LD_INT 25
44655: PUSH
44656: LD_INT 2
44658: PUSH
44659: EMPTY
44660: LIST
44661: LIST
44662: PPUSH
44663: CALL_OW 72
44667: PUSH
44668: LD_EXP 101
44672: PUSH
44673: LD_VAR 0 2
44677: ARRAY
44678: DIFF
44679: ST_TO_ADDR
// if not tmp then
44680: LD_VAR 0 4
44684: NOT
44685: IFFALSE 44689
// continue ;
44687: GO 43934
// for j in tmp do
44689: LD_ADDR_VAR 0 3
44693: PUSH
44694: LD_VAR 0 4
44698: PUSH
44699: FOR_IN
44700: IFFALSE 44912
// begin if not mc_builders [ i ] then
44702: LD_EXP 105
44706: PUSH
44707: LD_VAR 0 2
44711: ARRAY
44712: NOT
44713: IFFALSE 44771
// begin SetTag ( j , 103 ) ;
44715: LD_VAR 0 3
44719: PPUSH
44720: LD_INT 103
44722: PPUSH
44723: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44727: LD_ADDR_EXP 105
44731: PUSH
44732: LD_EXP 105
44736: PPUSH
44737: LD_VAR 0 2
44741: PUSH
44742: LD_EXP 105
44746: PUSH
44747: LD_VAR 0 2
44751: ARRAY
44752: PUSH
44753: LD_INT 1
44755: PLUS
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PPUSH
44761: LD_VAR 0 3
44765: PPUSH
44766: CALL 70361 0 3
44770: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44771: LD_VAR 0 3
44775: PPUSH
44776: CALL_OW 310
44780: IFFALSE 44791
// ComExitBuilding ( j ) ;
44782: LD_VAR 0 3
44786: PPUSH
44787: CALL_OW 122
// wait ( 3 ) ;
44791: LD_INT 3
44793: PPUSH
44794: CALL_OW 67
// if not mc_build_list [ i ] then
44798: LD_EXP 104
44802: PUSH
44803: LD_VAR 0 2
44807: ARRAY
44808: NOT
44809: IFFALSE 44813
// break ;
44811: GO 44912
// if not HasTask ( j ) then
44813: LD_VAR 0 3
44817: PPUSH
44818: CALL_OW 314
44822: NOT
44823: IFFALSE 44910
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44825: LD_VAR 0 3
44829: PPUSH
44830: LD_EXP 104
44834: PUSH
44835: LD_VAR 0 2
44839: ARRAY
44840: PUSH
44841: LD_INT 1
44843: ARRAY
44844: PUSH
44845: LD_INT 1
44847: ARRAY
44848: PPUSH
44849: LD_EXP 104
44853: PUSH
44854: LD_VAR 0 2
44858: ARRAY
44859: PUSH
44860: LD_INT 1
44862: ARRAY
44863: PUSH
44864: LD_INT 2
44866: ARRAY
44867: PPUSH
44868: LD_EXP 104
44872: PUSH
44873: LD_VAR 0 2
44877: ARRAY
44878: PUSH
44879: LD_INT 1
44881: ARRAY
44882: PUSH
44883: LD_INT 3
44885: ARRAY
44886: PPUSH
44887: LD_EXP 104
44891: PUSH
44892: LD_VAR 0 2
44896: ARRAY
44897: PUSH
44898: LD_INT 1
44900: ARRAY
44901: PUSH
44902: LD_INT 4
44904: ARRAY
44905: PPUSH
44906: CALL_OW 145
// end ;
44910: GO 44699
44912: POP
44913: POP
// end else
44914: GO 45058
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44916: LD_EXP 99
44920: PUSH
44921: LD_VAR 0 2
44925: ARRAY
44926: PPUSH
44927: LD_EXP 104
44931: PUSH
44932: LD_VAR 0 2
44936: ARRAY
44937: PUSH
44938: LD_INT 1
44940: ARRAY
44941: PUSH
44942: LD_INT 1
44944: ARRAY
44945: PPUSH
44946: LD_EXP 104
44950: PUSH
44951: LD_VAR 0 2
44955: ARRAY
44956: PUSH
44957: LD_INT 1
44959: ARRAY
44960: PUSH
44961: LD_INT 2
44963: ARRAY
44964: PPUSH
44965: LD_EXP 104
44969: PUSH
44970: LD_VAR 0 2
44974: ARRAY
44975: PUSH
44976: LD_INT 1
44978: ARRAY
44979: PUSH
44980: LD_INT 3
44982: ARRAY
44983: PPUSH
44984: LD_EXP 104
44988: PUSH
44989: LD_VAR 0 2
44993: ARRAY
44994: PUSH
44995: LD_INT 1
44997: ARRAY
44998: PUSH
44999: LD_INT 4
45001: ARRAY
45002: PPUSH
45003: CALL 77112 0 5
45007: NOT
45008: IFFALSE 45058
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45010: LD_ADDR_EXP 104
45014: PUSH
45015: LD_EXP 104
45019: PPUSH
45020: LD_VAR 0 2
45024: PPUSH
45025: LD_EXP 104
45029: PUSH
45030: LD_VAR 0 2
45034: ARRAY
45035: PPUSH
45036: LD_INT 1
45038: PPUSH
45039: LD_INT 1
45041: NEG
45042: PPUSH
45043: LD_INT 0
45045: PPUSH
45046: CALL 69779 0 4
45050: PPUSH
45051: CALL_OW 1
45055: ST_TO_ADDR
// continue ;
45056: GO 43934
// end ; end ; end ;
45058: GO 43934
45060: POP
45061: POP
// end ;
45062: LD_VAR 0 1
45066: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45067: LD_INT 0
45069: PPUSH
45070: PPUSH
45071: PPUSH
45072: PPUSH
45073: PPUSH
45074: PPUSH
// if not mc_bases then
45075: LD_EXP 99
45079: NOT
45080: IFFALSE 45084
// exit ;
45082: GO 45511
// for i = 1 to mc_bases do
45084: LD_ADDR_VAR 0 2
45088: PUSH
45089: DOUBLE
45090: LD_INT 1
45092: DEC
45093: ST_TO_ADDR
45094: LD_EXP 99
45098: PUSH
45099: FOR_TO
45100: IFFALSE 45509
// begin tmp := mc_build_upgrade [ i ] ;
45102: LD_ADDR_VAR 0 4
45106: PUSH
45107: LD_EXP 131
45111: PUSH
45112: LD_VAR 0 2
45116: ARRAY
45117: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45118: LD_ADDR_VAR 0 6
45122: PUSH
45123: LD_EXP 132
45127: PUSH
45128: LD_VAR 0 2
45132: ARRAY
45133: PPUSH
45134: LD_INT 2
45136: PUSH
45137: LD_INT 30
45139: PUSH
45140: LD_INT 6
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: PUSH
45147: LD_INT 30
45149: PUSH
45150: LD_INT 7
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: LIST
45161: PPUSH
45162: CALL_OW 72
45166: ST_TO_ADDR
// if not tmp and not lab then
45167: LD_VAR 0 4
45171: NOT
45172: PUSH
45173: LD_VAR 0 6
45177: NOT
45178: AND
45179: IFFALSE 45183
// continue ;
45181: GO 45099
// if tmp then
45183: LD_VAR 0 4
45187: IFFALSE 45307
// for j in tmp do
45189: LD_ADDR_VAR 0 3
45193: PUSH
45194: LD_VAR 0 4
45198: PUSH
45199: FOR_IN
45200: IFFALSE 45305
// begin if UpgradeCost ( j ) then
45202: LD_VAR 0 3
45206: PPUSH
45207: CALL 76772 0 1
45211: IFFALSE 45303
// begin ComUpgrade ( j ) ;
45213: LD_VAR 0 3
45217: PPUSH
45218: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45222: LD_ADDR_EXP 131
45226: PUSH
45227: LD_EXP 131
45231: PPUSH
45232: LD_VAR 0 2
45236: PPUSH
45237: LD_EXP 131
45241: PUSH
45242: LD_VAR 0 2
45246: ARRAY
45247: PUSH
45248: LD_VAR 0 3
45252: DIFF
45253: PPUSH
45254: CALL_OW 1
45258: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45259: LD_ADDR_EXP 106
45263: PUSH
45264: LD_EXP 106
45268: PPUSH
45269: LD_VAR 0 2
45273: PUSH
45274: LD_EXP 106
45278: PUSH
45279: LD_VAR 0 2
45283: ARRAY
45284: PUSH
45285: LD_INT 1
45287: PLUS
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PPUSH
45293: LD_VAR 0 3
45297: PPUSH
45298: CALL 70361 0 3
45302: ST_TO_ADDR
// end ; end ;
45303: GO 45199
45305: POP
45306: POP
// if not lab or not mc_lab_upgrade [ i ] then
45307: LD_VAR 0 6
45311: NOT
45312: PUSH
45313: LD_EXP 133
45317: PUSH
45318: LD_VAR 0 2
45322: ARRAY
45323: NOT
45324: OR
45325: IFFALSE 45329
// continue ;
45327: GO 45099
// for j in lab do
45329: LD_ADDR_VAR 0 3
45333: PUSH
45334: LD_VAR 0 6
45338: PUSH
45339: FOR_IN
45340: IFFALSE 45505
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45342: LD_VAR 0 3
45346: PPUSH
45347: CALL_OW 266
45351: PUSH
45352: LD_INT 6
45354: PUSH
45355: LD_INT 7
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: IN
45362: PUSH
45363: LD_VAR 0 3
45367: PPUSH
45368: CALL_OW 461
45372: PUSH
45373: LD_INT 1
45375: NONEQUAL
45376: AND
45377: IFFALSE 45503
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45379: LD_VAR 0 3
45383: PPUSH
45384: LD_EXP 133
45388: PUSH
45389: LD_VAR 0 2
45393: ARRAY
45394: PUSH
45395: LD_INT 1
45397: ARRAY
45398: PPUSH
45399: CALL 76977 0 2
45403: IFFALSE 45503
// begin ComCancel ( j ) ;
45405: LD_VAR 0 3
45409: PPUSH
45410: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45414: LD_VAR 0 3
45418: PPUSH
45419: LD_EXP 133
45423: PUSH
45424: LD_VAR 0 2
45428: ARRAY
45429: PUSH
45430: LD_INT 1
45432: ARRAY
45433: PPUSH
45434: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45438: LD_VAR 0 3
45442: PUSH
45443: LD_EXP 106
45447: PUSH
45448: LD_VAR 0 2
45452: ARRAY
45453: IN
45454: NOT
45455: IFFALSE 45501
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45457: LD_ADDR_EXP 106
45461: PUSH
45462: LD_EXP 106
45466: PPUSH
45467: LD_VAR 0 2
45471: PUSH
45472: LD_EXP 106
45476: PUSH
45477: LD_VAR 0 2
45481: ARRAY
45482: PUSH
45483: LD_INT 1
45485: PLUS
45486: PUSH
45487: EMPTY
45488: LIST
45489: LIST
45490: PPUSH
45491: LD_VAR 0 3
45495: PPUSH
45496: CALL 70361 0 3
45500: ST_TO_ADDR
// break ;
45501: GO 45505
// end ; end ; end ;
45503: GO 45339
45505: POP
45506: POP
// end ;
45507: GO 45099
45509: POP
45510: POP
// end ;
45511: LD_VAR 0 1
45515: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45516: LD_INT 0
45518: PPUSH
45519: PPUSH
45520: PPUSH
45521: PPUSH
45522: PPUSH
45523: PPUSH
45524: PPUSH
45525: PPUSH
45526: PPUSH
// if not mc_bases then
45527: LD_EXP 99
45531: NOT
45532: IFFALSE 45536
// exit ;
45534: GO 45941
// for i = 1 to mc_bases do
45536: LD_ADDR_VAR 0 2
45540: PUSH
45541: DOUBLE
45542: LD_INT 1
45544: DEC
45545: ST_TO_ADDR
45546: LD_EXP 99
45550: PUSH
45551: FOR_TO
45552: IFFALSE 45939
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45554: LD_EXP 107
45558: PUSH
45559: LD_VAR 0 2
45563: ARRAY
45564: NOT
45565: PUSH
45566: LD_EXP 99
45570: PUSH
45571: LD_VAR 0 2
45575: ARRAY
45576: PPUSH
45577: LD_INT 30
45579: PUSH
45580: LD_INT 3
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PPUSH
45587: CALL_OW 72
45591: NOT
45592: OR
45593: IFFALSE 45597
// continue ;
45595: GO 45551
// busy := false ;
45597: LD_ADDR_VAR 0 8
45601: PUSH
45602: LD_INT 0
45604: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45605: LD_ADDR_VAR 0 4
45609: PUSH
45610: LD_EXP 99
45614: PUSH
45615: LD_VAR 0 2
45619: ARRAY
45620: PPUSH
45621: LD_INT 30
45623: PUSH
45624: LD_INT 3
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PPUSH
45631: CALL_OW 72
45635: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45636: LD_ADDR_VAR 0 6
45640: PUSH
45641: LD_EXP 107
45645: PUSH
45646: LD_VAR 0 2
45650: ARRAY
45651: PPUSH
45652: LD_INT 2
45654: PUSH
45655: LD_INT 30
45657: PUSH
45658: LD_INT 32
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 30
45667: PUSH
45668: LD_INT 33
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: PUSH
45675: EMPTY
45676: LIST
45677: LIST
45678: LIST
45679: PPUSH
45680: CALL_OW 72
45684: ST_TO_ADDR
// if not t then
45685: LD_VAR 0 6
45689: NOT
45690: IFFALSE 45694
// continue ;
45692: GO 45551
// for j in tmp do
45694: LD_ADDR_VAR 0 3
45698: PUSH
45699: LD_VAR 0 4
45703: PUSH
45704: FOR_IN
45705: IFFALSE 45735
// if not BuildingStatus ( j ) = bs_idle then
45707: LD_VAR 0 3
45711: PPUSH
45712: CALL_OW 461
45716: PUSH
45717: LD_INT 2
45719: EQUAL
45720: NOT
45721: IFFALSE 45733
// begin busy := true ;
45723: LD_ADDR_VAR 0 8
45727: PUSH
45728: LD_INT 1
45730: ST_TO_ADDR
// break ;
45731: GO 45735
// end ;
45733: GO 45704
45735: POP
45736: POP
// if busy then
45737: LD_VAR 0 8
45741: IFFALSE 45745
// continue ;
45743: GO 45551
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45745: LD_ADDR_VAR 0 7
45749: PUSH
45750: LD_VAR 0 6
45754: PPUSH
45755: LD_INT 35
45757: PUSH
45758: LD_INT 0
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PPUSH
45765: CALL_OW 72
45769: ST_TO_ADDR
// if tw then
45770: LD_VAR 0 7
45774: IFFALSE 45851
// begin tw := tw [ 1 ] ;
45776: LD_ADDR_VAR 0 7
45780: PUSH
45781: LD_VAR 0 7
45785: PUSH
45786: LD_INT 1
45788: ARRAY
45789: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45790: LD_ADDR_VAR 0 9
45794: PUSH
45795: LD_VAR 0 7
45799: PPUSH
45800: LD_EXP 124
45804: PUSH
45805: LD_VAR 0 2
45809: ARRAY
45810: PPUSH
45811: CALL 75331 0 2
45815: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45816: LD_EXP 138
45820: PUSH
45821: LD_VAR 0 2
45825: ARRAY
45826: IFFALSE 45849
// if not weapon in mc_allowed_tower_weapons [ i ] then
45828: LD_VAR 0 9
45832: PUSH
45833: LD_EXP 138
45837: PUSH
45838: LD_VAR 0 2
45842: ARRAY
45843: IN
45844: NOT
45845: IFFALSE 45849
// continue ;
45847: GO 45551
// end else
45849: GO 45914
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45851: LD_ADDR_VAR 0 5
45855: PUSH
45856: LD_EXP 107
45860: PUSH
45861: LD_VAR 0 2
45865: ARRAY
45866: PPUSH
45867: LD_VAR 0 4
45871: PPUSH
45872: CALL 105532 0 2
45876: ST_TO_ADDR
// if not tmp2 then
45877: LD_VAR 0 5
45881: NOT
45882: IFFALSE 45886
// continue ;
45884: GO 45551
// tw := tmp2 [ 1 ] ;
45886: LD_ADDR_VAR 0 7
45890: PUSH
45891: LD_VAR 0 5
45895: PUSH
45896: LD_INT 1
45898: ARRAY
45899: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45900: LD_ADDR_VAR 0 9
45904: PUSH
45905: LD_VAR 0 5
45909: PUSH
45910: LD_INT 2
45912: ARRAY
45913: ST_TO_ADDR
// end ; if not weapon then
45914: LD_VAR 0 9
45918: NOT
45919: IFFALSE 45923
// continue ;
45921: GO 45551
// ComPlaceWeapon ( tw , weapon ) ;
45923: LD_VAR 0 7
45927: PPUSH
45928: LD_VAR 0 9
45932: PPUSH
45933: CALL_OW 148
// end ;
45937: GO 45551
45939: POP
45940: POP
// end ;
45941: LD_VAR 0 1
45945: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45946: LD_INT 0
45948: PPUSH
45949: PPUSH
45950: PPUSH
45951: PPUSH
45952: PPUSH
45953: PPUSH
// if not mc_bases then
45954: LD_EXP 99
45958: NOT
45959: IFFALSE 45963
// exit ;
45961: GO 46975
// for i = 1 to mc_bases do
45963: LD_ADDR_VAR 0 2
45967: PUSH
45968: DOUBLE
45969: LD_INT 1
45971: DEC
45972: ST_TO_ADDR
45973: LD_EXP 99
45977: PUSH
45978: FOR_TO
45979: IFFALSE 46973
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45981: LD_EXP 112
45985: PUSH
45986: LD_VAR 0 2
45990: ARRAY
45991: NOT
45992: PUSH
45993: LD_EXP 112
45997: PUSH
45998: LD_VAR 0 2
46002: ARRAY
46003: PUSH
46004: LD_EXP 113
46008: PUSH
46009: LD_VAR 0 2
46013: ARRAY
46014: EQUAL
46015: OR
46016: IFFALSE 46020
// continue ;
46018: GO 45978
// if mc_miners [ i ] then
46020: LD_EXP 113
46024: PUSH
46025: LD_VAR 0 2
46029: ARRAY
46030: IFFALSE 46660
// begin k := 1 ;
46032: LD_ADDR_VAR 0 4
46036: PUSH
46037: LD_INT 1
46039: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46040: LD_ADDR_VAR 0 3
46044: PUSH
46045: DOUBLE
46046: LD_EXP 113
46050: PUSH
46051: LD_VAR 0 2
46055: ARRAY
46056: INC
46057: ST_TO_ADDR
46058: LD_INT 1
46060: PUSH
46061: FOR_DOWNTO
46062: IFFALSE 46658
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46064: LD_EXP 113
46068: PUSH
46069: LD_VAR 0 2
46073: ARRAY
46074: PUSH
46075: LD_VAR 0 3
46079: ARRAY
46080: PPUSH
46081: CALL_OW 301
46085: PUSH
46086: LD_EXP 113
46090: PUSH
46091: LD_VAR 0 2
46095: ARRAY
46096: PUSH
46097: LD_VAR 0 3
46101: ARRAY
46102: PPUSH
46103: CALL_OW 257
46107: PUSH
46108: LD_INT 1
46110: NONEQUAL
46111: OR
46112: IFFALSE 46175
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46114: LD_ADDR_VAR 0 5
46118: PUSH
46119: LD_EXP 113
46123: PUSH
46124: LD_VAR 0 2
46128: ARRAY
46129: PUSH
46130: LD_EXP 113
46134: PUSH
46135: LD_VAR 0 2
46139: ARRAY
46140: PUSH
46141: LD_VAR 0 3
46145: ARRAY
46146: DIFF
46147: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46148: LD_ADDR_EXP 113
46152: PUSH
46153: LD_EXP 113
46157: PPUSH
46158: LD_VAR 0 2
46162: PPUSH
46163: LD_VAR 0 5
46167: PPUSH
46168: CALL_OW 1
46172: ST_TO_ADDR
// continue ;
46173: GO 46061
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46175: LD_EXP 113
46179: PUSH
46180: LD_VAR 0 2
46184: ARRAY
46185: PUSH
46186: LD_VAR 0 3
46190: ARRAY
46191: PPUSH
46192: CALL 70297 0 1
46196: PUSH
46197: LD_EXP 113
46201: PUSH
46202: LD_VAR 0 2
46206: ARRAY
46207: PUSH
46208: LD_VAR 0 3
46212: ARRAY
46213: PPUSH
46214: CALL_OW 255
46218: PPUSH
46219: LD_EXP 112
46223: PUSH
46224: LD_VAR 0 2
46228: ARRAY
46229: PUSH
46230: LD_VAR 0 4
46234: ARRAY
46235: PUSH
46236: LD_INT 1
46238: ARRAY
46239: PPUSH
46240: LD_EXP 112
46244: PUSH
46245: LD_VAR 0 2
46249: ARRAY
46250: PUSH
46251: LD_VAR 0 4
46255: ARRAY
46256: PUSH
46257: LD_INT 2
46259: ARRAY
46260: PPUSH
46261: LD_INT 15
46263: PPUSH
46264: CALL 71257 0 4
46268: PUSH
46269: LD_INT 4
46271: ARRAY
46272: PUSH
46273: LD_EXP 113
46277: PUSH
46278: LD_VAR 0 2
46282: ARRAY
46283: PUSH
46284: LD_VAR 0 3
46288: ARRAY
46289: PPUSH
46290: LD_INT 10
46292: PPUSH
46293: CALL 72954 0 2
46297: PUSH
46298: LD_INT 4
46300: ARRAY
46301: OR
46302: AND
46303: IFFALSE 46326
// ComStop ( mc_miners [ i ] [ j ] ) ;
46305: LD_EXP 113
46309: PUSH
46310: LD_VAR 0 2
46314: ARRAY
46315: PUSH
46316: LD_VAR 0 3
46320: ARRAY
46321: PPUSH
46322: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46326: LD_EXP 113
46330: PUSH
46331: LD_VAR 0 2
46335: ARRAY
46336: PUSH
46337: LD_VAR 0 3
46341: ARRAY
46342: PPUSH
46343: CALL_OW 257
46347: PUSH
46348: LD_INT 1
46350: EQUAL
46351: PUSH
46352: LD_EXP 113
46356: PUSH
46357: LD_VAR 0 2
46361: ARRAY
46362: PUSH
46363: LD_VAR 0 3
46367: ARRAY
46368: PPUSH
46369: CALL_OW 459
46373: NOT
46374: AND
46375: PUSH
46376: LD_EXP 113
46380: PUSH
46381: LD_VAR 0 2
46385: ARRAY
46386: PUSH
46387: LD_VAR 0 3
46391: ARRAY
46392: PPUSH
46393: CALL_OW 255
46397: PPUSH
46398: LD_EXP 112
46402: PUSH
46403: LD_VAR 0 2
46407: ARRAY
46408: PUSH
46409: LD_VAR 0 4
46413: ARRAY
46414: PUSH
46415: LD_INT 1
46417: ARRAY
46418: PPUSH
46419: LD_EXP 112
46423: PUSH
46424: LD_VAR 0 2
46428: ARRAY
46429: PUSH
46430: LD_VAR 0 4
46434: ARRAY
46435: PUSH
46436: LD_INT 2
46438: ARRAY
46439: PPUSH
46440: LD_INT 15
46442: PPUSH
46443: CALL 71257 0 4
46447: PUSH
46448: LD_INT 4
46450: ARRAY
46451: PUSH
46452: LD_INT 0
46454: EQUAL
46455: AND
46456: PUSH
46457: LD_EXP 113
46461: PUSH
46462: LD_VAR 0 2
46466: ARRAY
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: PPUSH
46474: CALL_OW 314
46478: NOT
46479: AND
46480: IFFALSE 46656
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46482: LD_EXP 113
46486: PUSH
46487: LD_VAR 0 2
46491: ARRAY
46492: PUSH
46493: LD_VAR 0 3
46497: ARRAY
46498: PPUSH
46499: CALL_OW 310
46503: IFFALSE 46526
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46505: LD_EXP 113
46509: PUSH
46510: LD_VAR 0 2
46514: ARRAY
46515: PUSH
46516: LD_VAR 0 3
46520: ARRAY
46521: PPUSH
46522: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46526: LD_EXP 113
46530: PUSH
46531: LD_VAR 0 2
46535: ARRAY
46536: PUSH
46537: LD_VAR 0 3
46541: ARRAY
46542: PPUSH
46543: CALL_OW 314
46547: NOT
46548: IFFALSE 46616
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46550: LD_EXP 113
46554: PUSH
46555: LD_VAR 0 2
46559: ARRAY
46560: PUSH
46561: LD_VAR 0 3
46565: ARRAY
46566: PPUSH
46567: LD_EXP 112
46571: PUSH
46572: LD_VAR 0 2
46576: ARRAY
46577: PUSH
46578: LD_VAR 0 4
46582: ARRAY
46583: PUSH
46584: LD_INT 1
46586: ARRAY
46587: PPUSH
46588: LD_EXP 112
46592: PUSH
46593: LD_VAR 0 2
46597: ARRAY
46598: PUSH
46599: LD_VAR 0 4
46603: ARRAY
46604: PUSH
46605: LD_INT 2
46607: ARRAY
46608: PPUSH
46609: LD_INT 0
46611: PPUSH
46612: CALL_OW 193
// k := k + 1 ;
46616: LD_ADDR_VAR 0 4
46620: PUSH
46621: LD_VAR 0 4
46625: PUSH
46626: LD_INT 1
46628: PLUS
46629: ST_TO_ADDR
// if k > mc_mines [ i ] then
46630: LD_VAR 0 4
46634: PUSH
46635: LD_EXP 112
46639: PUSH
46640: LD_VAR 0 2
46644: ARRAY
46645: GREATER
46646: IFFALSE 46656
// k := 1 ;
46648: LD_ADDR_VAR 0 4
46652: PUSH
46653: LD_INT 1
46655: ST_TO_ADDR
// end ; end ;
46656: GO 46061
46658: POP
46659: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46660: LD_ADDR_VAR 0 5
46664: PUSH
46665: LD_EXP 99
46669: PUSH
46670: LD_VAR 0 2
46674: ARRAY
46675: PPUSH
46676: LD_INT 2
46678: PUSH
46679: LD_INT 30
46681: PUSH
46682: LD_INT 4
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 30
46691: PUSH
46692: LD_INT 5
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 30
46701: PUSH
46702: LD_INT 32
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: EMPTY
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: PPUSH
46715: CALL_OW 72
46719: ST_TO_ADDR
// if not tmp then
46720: LD_VAR 0 5
46724: NOT
46725: IFFALSE 46729
// continue ;
46727: GO 45978
// list := [ ] ;
46729: LD_ADDR_VAR 0 6
46733: PUSH
46734: EMPTY
46735: ST_TO_ADDR
// for j in tmp do
46736: LD_ADDR_VAR 0 3
46740: PUSH
46741: LD_VAR 0 5
46745: PUSH
46746: FOR_IN
46747: IFFALSE 46816
// begin for k in UnitsInside ( j ) do
46749: LD_ADDR_VAR 0 4
46753: PUSH
46754: LD_VAR 0 3
46758: PPUSH
46759: CALL_OW 313
46763: PUSH
46764: FOR_IN
46765: IFFALSE 46812
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46767: LD_VAR 0 4
46771: PPUSH
46772: CALL_OW 257
46776: PUSH
46777: LD_INT 1
46779: EQUAL
46780: PUSH
46781: LD_VAR 0 4
46785: PPUSH
46786: CALL_OW 459
46790: NOT
46791: AND
46792: IFFALSE 46810
// list := list ^ k ;
46794: LD_ADDR_VAR 0 6
46798: PUSH
46799: LD_VAR 0 6
46803: PUSH
46804: LD_VAR 0 4
46808: ADD
46809: ST_TO_ADDR
46810: GO 46764
46812: POP
46813: POP
// end ;
46814: GO 46746
46816: POP
46817: POP
// list := list diff mc_miners [ i ] ;
46818: LD_ADDR_VAR 0 6
46822: PUSH
46823: LD_VAR 0 6
46827: PUSH
46828: LD_EXP 113
46832: PUSH
46833: LD_VAR 0 2
46837: ARRAY
46838: DIFF
46839: ST_TO_ADDR
// if not list then
46840: LD_VAR 0 6
46844: NOT
46845: IFFALSE 46849
// continue ;
46847: GO 45978
// k := mc_mines [ i ] - mc_miners [ i ] ;
46849: LD_ADDR_VAR 0 4
46853: PUSH
46854: LD_EXP 112
46858: PUSH
46859: LD_VAR 0 2
46863: ARRAY
46864: PUSH
46865: LD_EXP 113
46869: PUSH
46870: LD_VAR 0 2
46874: ARRAY
46875: MINUS
46876: ST_TO_ADDR
// if k > list then
46877: LD_VAR 0 4
46881: PUSH
46882: LD_VAR 0 6
46886: GREATER
46887: IFFALSE 46899
// k := list ;
46889: LD_ADDR_VAR 0 4
46893: PUSH
46894: LD_VAR 0 6
46898: ST_TO_ADDR
// for j = 1 to k do
46899: LD_ADDR_VAR 0 3
46903: PUSH
46904: DOUBLE
46905: LD_INT 1
46907: DEC
46908: ST_TO_ADDR
46909: LD_VAR 0 4
46913: PUSH
46914: FOR_TO
46915: IFFALSE 46969
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46917: LD_ADDR_EXP 113
46921: PUSH
46922: LD_EXP 113
46926: PPUSH
46927: LD_VAR 0 2
46931: PUSH
46932: LD_EXP 113
46936: PUSH
46937: LD_VAR 0 2
46941: ARRAY
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: PUSH
46947: EMPTY
46948: LIST
46949: LIST
46950: PPUSH
46951: LD_VAR 0 6
46955: PUSH
46956: LD_VAR 0 3
46960: ARRAY
46961: PPUSH
46962: CALL 70361 0 3
46966: ST_TO_ADDR
46967: GO 46914
46969: POP
46970: POP
// end ;
46971: GO 45978
46973: POP
46974: POP
// end ;
46975: LD_VAR 0 1
46979: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46980: LD_INT 0
46982: PPUSH
46983: PPUSH
46984: PPUSH
46985: PPUSH
46986: PPUSH
46987: PPUSH
46988: PPUSH
46989: PPUSH
46990: PPUSH
46991: PPUSH
// if not mc_bases then
46992: LD_EXP 99
46996: NOT
46997: IFFALSE 47001
// exit ;
46999: GO 48751
// for i = 1 to mc_bases do
47001: LD_ADDR_VAR 0 2
47005: PUSH
47006: DOUBLE
47007: LD_INT 1
47009: DEC
47010: ST_TO_ADDR
47011: LD_EXP 99
47015: PUSH
47016: FOR_TO
47017: IFFALSE 48749
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47019: LD_EXP 99
47023: PUSH
47024: LD_VAR 0 2
47028: ARRAY
47029: NOT
47030: PUSH
47031: LD_EXP 106
47035: PUSH
47036: LD_VAR 0 2
47040: ARRAY
47041: OR
47042: IFFALSE 47046
// continue ;
47044: GO 47016
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47046: LD_EXP 115
47050: PUSH
47051: LD_VAR 0 2
47055: ARRAY
47056: NOT
47057: PUSH
47058: LD_EXP 116
47062: PUSH
47063: LD_VAR 0 2
47067: ARRAY
47068: AND
47069: IFFALSE 47107
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47071: LD_ADDR_EXP 116
47075: PUSH
47076: LD_EXP 116
47080: PPUSH
47081: LD_VAR 0 2
47085: PPUSH
47086: EMPTY
47087: PPUSH
47088: CALL_OW 1
47092: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47093: LD_VAR 0 2
47097: PPUSH
47098: LD_INT 107
47100: PPUSH
47101: CALL 37861 0 2
// continue ;
47105: GO 47016
// end ; target := [ ] ;
47107: LD_ADDR_VAR 0 6
47111: PUSH
47112: EMPTY
47113: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47114: LD_ADDR_VAR 0 3
47118: PUSH
47119: DOUBLE
47120: LD_EXP 115
47124: PUSH
47125: LD_VAR 0 2
47129: ARRAY
47130: INC
47131: ST_TO_ADDR
47132: LD_INT 1
47134: PUSH
47135: FOR_DOWNTO
47136: IFFALSE 47396
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47138: LD_EXP 115
47142: PUSH
47143: LD_VAR 0 2
47147: ARRAY
47148: PUSH
47149: LD_VAR 0 3
47153: ARRAY
47154: PUSH
47155: LD_INT 2
47157: ARRAY
47158: PPUSH
47159: LD_EXP 115
47163: PUSH
47164: LD_VAR 0 2
47168: ARRAY
47169: PUSH
47170: LD_VAR 0 3
47174: ARRAY
47175: PUSH
47176: LD_INT 3
47178: ARRAY
47179: PPUSH
47180: CALL_OW 488
47184: PUSH
47185: LD_EXP 115
47189: PUSH
47190: LD_VAR 0 2
47194: ARRAY
47195: PUSH
47196: LD_VAR 0 3
47200: ARRAY
47201: PUSH
47202: LD_INT 2
47204: ARRAY
47205: PPUSH
47206: LD_EXP 115
47210: PUSH
47211: LD_VAR 0 2
47215: ARRAY
47216: PUSH
47217: LD_VAR 0 3
47221: ARRAY
47222: PUSH
47223: LD_INT 3
47225: ARRAY
47226: PPUSH
47227: CALL_OW 284
47231: PUSH
47232: LD_INT 0
47234: EQUAL
47235: AND
47236: IFFALSE 47291
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47238: LD_ADDR_VAR 0 5
47242: PUSH
47243: LD_EXP 115
47247: PUSH
47248: LD_VAR 0 2
47252: ARRAY
47253: PPUSH
47254: LD_VAR 0 3
47258: PPUSH
47259: CALL_OW 3
47263: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47264: LD_ADDR_EXP 115
47268: PUSH
47269: LD_EXP 115
47273: PPUSH
47274: LD_VAR 0 2
47278: PPUSH
47279: LD_VAR 0 5
47283: PPUSH
47284: CALL_OW 1
47288: ST_TO_ADDR
// continue ;
47289: GO 47135
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47291: LD_EXP 99
47295: PUSH
47296: LD_VAR 0 2
47300: ARRAY
47301: PUSH
47302: LD_INT 1
47304: ARRAY
47305: PPUSH
47306: CALL_OW 255
47310: PPUSH
47311: LD_EXP 115
47315: PUSH
47316: LD_VAR 0 2
47320: ARRAY
47321: PUSH
47322: LD_VAR 0 3
47326: ARRAY
47327: PUSH
47328: LD_INT 2
47330: ARRAY
47331: PPUSH
47332: LD_EXP 115
47336: PUSH
47337: LD_VAR 0 2
47341: ARRAY
47342: PUSH
47343: LD_VAR 0 3
47347: ARRAY
47348: PUSH
47349: LD_INT 3
47351: ARRAY
47352: PPUSH
47353: LD_INT 30
47355: PPUSH
47356: CALL 71257 0 4
47360: PUSH
47361: LD_INT 4
47363: ARRAY
47364: PUSH
47365: LD_INT 0
47367: EQUAL
47368: IFFALSE 47394
// begin target := mc_crates [ i ] [ j ] ;
47370: LD_ADDR_VAR 0 6
47374: PUSH
47375: LD_EXP 115
47379: PUSH
47380: LD_VAR 0 2
47384: ARRAY
47385: PUSH
47386: LD_VAR 0 3
47390: ARRAY
47391: ST_TO_ADDR
// break ;
47392: GO 47396
// end ; end ;
47394: GO 47135
47396: POP
47397: POP
// if not target then
47398: LD_VAR 0 6
47402: NOT
47403: IFFALSE 47407
// continue ;
47405: GO 47016
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47407: LD_ADDR_VAR 0 7
47411: PUSH
47412: LD_EXP 118
47416: PUSH
47417: LD_VAR 0 2
47421: ARRAY
47422: PPUSH
47423: LD_INT 2
47425: PUSH
47426: LD_INT 3
47428: PUSH
47429: LD_INT 58
47431: PUSH
47432: EMPTY
47433: LIST
47434: PUSH
47435: EMPTY
47436: LIST
47437: LIST
47438: PUSH
47439: LD_INT 61
47441: PUSH
47442: EMPTY
47443: LIST
47444: PUSH
47445: LD_INT 33
47447: PUSH
47448: LD_INT 5
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: LD_INT 33
47457: PUSH
47458: LD_INT 3
47460: PUSH
47461: EMPTY
47462: LIST
47463: LIST
47464: PUSH
47465: EMPTY
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: PUSH
47472: LD_INT 2
47474: PUSH
47475: LD_INT 34
47477: PUSH
47478: LD_INT 32
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_INT 34
47487: PUSH
47488: LD_INT 51
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PUSH
47495: LD_INT 34
47497: PUSH
47498: LD_INT 12
47500: PUSH
47501: EMPTY
47502: LIST
47503: LIST
47504: PUSH
47505: EMPTY
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: PUSH
47511: EMPTY
47512: LIST
47513: LIST
47514: PPUSH
47515: CALL_OW 72
47519: ST_TO_ADDR
// if not cargo then
47520: LD_VAR 0 7
47524: NOT
47525: IFFALSE 48168
// begin if mc_crates_collector [ i ] < 5 then
47527: LD_EXP 116
47531: PUSH
47532: LD_VAR 0 2
47536: ARRAY
47537: PUSH
47538: LD_INT 5
47540: LESS
47541: IFFALSE 47907
// begin if mc_ape [ i ] then
47543: LD_EXP 128
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: IFFALSE 47600
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47555: LD_ADDR_VAR 0 5
47559: PUSH
47560: LD_EXP 128
47564: PUSH
47565: LD_VAR 0 2
47569: ARRAY
47570: PPUSH
47571: LD_INT 25
47573: PUSH
47574: LD_INT 16
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 24
47583: PUSH
47584: LD_INT 750
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PPUSH
47595: CALL_OW 72
47599: ST_TO_ADDR
// if not tmp then
47600: LD_VAR 0 5
47604: NOT
47605: IFFALSE 47652
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47607: LD_ADDR_VAR 0 5
47611: PUSH
47612: LD_EXP 99
47616: PUSH
47617: LD_VAR 0 2
47621: ARRAY
47622: PPUSH
47623: LD_INT 25
47625: PUSH
47626: LD_INT 2
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: PUSH
47633: LD_INT 24
47635: PUSH
47636: LD_INT 750
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: PUSH
47643: EMPTY
47644: LIST
47645: LIST
47646: PPUSH
47647: CALL_OW 72
47651: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47652: LD_EXP 128
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_EXP 99
47667: PUSH
47668: LD_VAR 0 2
47672: ARRAY
47673: PPUSH
47674: LD_INT 25
47676: PUSH
47677: LD_INT 2
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 24
47686: PUSH
47687: LD_INT 750
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PPUSH
47698: CALL_OW 72
47702: AND
47703: PUSH
47704: LD_VAR 0 5
47708: PUSH
47709: LD_INT 5
47711: LESS
47712: AND
47713: IFFALSE 47795
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47715: LD_ADDR_VAR 0 3
47719: PUSH
47720: LD_EXP 99
47724: PUSH
47725: LD_VAR 0 2
47729: ARRAY
47730: PPUSH
47731: LD_INT 25
47733: PUSH
47734: LD_INT 2
47736: PUSH
47737: EMPTY
47738: LIST
47739: LIST
47740: PUSH
47741: LD_INT 24
47743: PUSH
47744: LD_INT 750
47746: PUSH
47747: EMPTY
47748: LIST
47749: LIST
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: PPUSH
47755: CALL_OW 72
47759: PUSH
47760: FOR_IN
47761: IFFALSE 47793
// begin tmp := tmp union j ;
47763: LD_ADDR_VAR 0 5
47767: PUSH
47768: LD_VAR 0 5
47772: PUSH
47773: LD_VAR 0 3
47777: UNION
47778: ST_TO_ADDR
// if tmp >= 5 then
47779: LD_VAR 0 5
47783: PUSH
47784: LD_INT 5
47786: GREATEREQUAL
47787: IFFALSE 47791
// break ;
47789: GO 47793
// end ;
47791: GO 47760
47793: POP
47794: POP
// end ; if not tmp then
47795: LD_VAR 0 5
47799: NOT
47800: IFFALSE 47804
// continue ;
47802: GO 47016
// for j in tmp do
47804: LD_ADDR_VAR 0 3
47808: PUSH
47809: LD_VAR 0 5
47813: PUSH
47814: FOR_IN
47815: IFFALSE 47905
// if not GetTag ( j ) then
47817: LD_VAR 0 3
47821: PPUSH
47822: CALL_OW 110
47826: NOT
47827: IFFALSE 47903
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47829: LD_ADDR_EXP 116
47833: PUSH
47834: LD_EXP 116
47838: PPUSH
47839: LD_VAR 0 2
47843: PUSH
47844: LD_EXP 116
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: PUSH
47855: LD_INT 1
47857: PLUS
47858: PUSH
47859: EMPTY
47860: LIST
47861: LIST
47862: PPUSH
47863: LD_VAR 0 3
47867: PPUSH
47868: CALL 70361 0 3
47872: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47873: LD_VAR 0 3
47877: PPUSH
47878: LD_INT 107
47880: PPUSH
47881: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47885: LD_EXP 116
47889: PUSH
47890: LD_VAR 0 2
47894: ARRAY
47895: PUSH
47896: LD_INT 5
47898: GREATEREQUAL
47899: IFFALSE 47903
// break ;
47901: GO 47905
// end ;
47903: GO 47814
47905: POP
47906: POP
// end ; if mc_crates_collector [ i ] and target then
47907: LD_EXP 116
47911: PUSH
47912: LD_VAR 0 2
47916: ARRAY
47917: PUSH
47918: LD_VAR 0 6
47922: AND
47923: IFFALSE 48166
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47925: LD_EXP 116
47929: PUSH
47930: LD_VAR 0 2
47934: ARRAY
47935: PUSH
47936: LD_VAR 0 6
47940: PUSH
47941: LD_INT 1
47943: ARRAY
47944: LESS
47945: IFFALSE 47965
// tmp := mc_crates_collector [ i ] else
47947: LD_ADDR_VAR 0 5
47951: PUSH
47952: LD_EXP 116
47956: PUSH
47957: LD_VAR 0 2
47961: ARRAY
47962: ST_TO_ADDR
47963: GO 47979
// tmp := target [ 1 ] ;
47965: LD_ADDR_VAR 0 5
47969: PUSH
47970: LD_VAR 0 6
47974: PUSH
47975: LD_INT 1
47977: ARRAY
47978: ST_TO_ADDR
// k := 0 ;
47979: LD_ADDR_VAR 0 4
47983: PUSH
47984: LD_INT 0
47986: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47987: LD_ADDR_VAR 0 3
47991: PUSH
47992: LD_EXP 116
47996: PUSH
47997: LD_VAR 0 2
48001: ARRAY
48002: PUSH
48003: FOR_IN
48004: IFFALSE 48164
// begin k := k + 1 ;
48006: LD_ADDR_VAR 0 4
48010: PUSH
48011: LD_VAR 0 4
48015: PUSH
48016: LD_INT 1
48018: PLUS
48019: ST_TO_ADDR
// if k > tmp then
48020: LD_VAR 0 4
48024: PUSH
48025: LD_VAR 0 5
48029: GREATER
48030: IFFALSE 48034
// break ;
48032: GO 48164
// if not GetClass ( j ) in [ 2 , 16 ] then
48034: LD_VAR 0 3
48038: PPUSH
48039: CALL_OW 257
48043: PUSH
48044: LD_INT 2
48046: PUSH
48047: LD_INT 16
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: IN
48054: NOT
48055: IFFALSE 48108
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48057: LD_ADDR_EXP 116
48061: PUSH
48062: LD_EXP 116
48066: PPUSH
48067: LD_VAR 0 2
48071: PPUSH
48072: LD_EXP 116
48076: PUSH
48077: LD_VAR 0 2
48081: ARRAY
48082: PUSH
48083: LD_VAR 0 3
48087: DIFF
48088: PPUSH
48089: CALL_OW 1
48093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48094: LD_VAR 0 3
48098: PPUSH
48099: LD_INT 0
48101: PPUSH
48102: CALL_OW 109
// continue ;
48106: GO 48003
// end ; if IsInUnit ( j ) then
48108: LD_VAR 0 3
48112: PPUSH
48113: CALL_OW 310
48117: IFFALSE 48128
// ComExitBuilding ( j ) ;
48119: LD_VAR 0 3
48123: PPUSH
48124: CALL_OW 122
// wait ( 3 ) ;
48128: LD_INT 3
48130: PPUSH
48131: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48135: LD_VAR 0 3
48139: PPUSH
48140: LD_VAR 0 6
48144: PUSH
48145: LD_INT 2
48147: ARRAY
48148: PPUSH
48149: LD_VAR 0 6
48153: PUSH
48154: LD_INT 3
48156: ARRAY
48157: PPUSH
48158: CALL_OW 117
// end ;
48162: GO 48003
48164: POP
48165: POP
// end ; end else
48166: GO 48747
// begin for j in cargo do
48168: LD_ADDR_VAR 0 3
48172: PUSH
48173: LD_VAR 0 7
48177: PUSH
48178: FOR_IN
48179: IFFALSE 48745
// begin if GetTag ( j ) <> 0 then
48181: LD_VAR 0 3
48185: PPUSH
48186: CALL_OW 110
48190: PUSH
48191: LD_INT 0
48193: NONEQUAL
48194: IFFALSE 48198
// continue ;
48196: GO 48178
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48198: LD_VAR 0 3
48202: PPUSH
48203: CALL_OW 256
48207: PUSH
48208: LD_INT 1000
48210: LESS
48211: PUSH
48212: LD_VAR 0 3
48216: PPUSH
48217: LD_EXP 123
48221: PUSH
48222: LD_VAR 0 2
48226: ARRAY
48227: PPUSH
48228: CALL_OW 308
48232: NOT
48233: AND
48234: IFFALSE 48256
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48236: LD_VAR 0 3
48240: PPUSH
48241: LD_EXP 123
48245: PUSH
48246: LD_VAR 0 2
48250: ARRAY
48251: PPUSH
48252: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48256: LD_VAR 0 3
48260: PPUSH
48261: CALL_OW 256
48265: PUSH
48266: LD_INT 1000
48268: LESS
48269: PUSH
48270: LD_VAR 0 3
48274: PPUSH
48275: LD_EXP 123
48279: PUSH
48280: LD_VAR 0 2
48284: ARRAY
48285: PPUSH
48286: CALL_OW 308
48290: AND
48291: IFFALSE 48295
// continue ;
48293: GO 48178
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48295: LD_VAR 0 3
48299: PPUSH
48300: CALL_OW 262
48304: PUSH
48305: LD_INT 2
48307: EQUAL
48308: PUSH
48309: LD_VAR 0 3
48313: PPUSH
48314: CALL_OW 261
48318: PUSH
48319: LD_INT 15
48321: LESS
48322: AND
48323: IFFALSE 48327
// continue ;
48325: GO 48178
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48327: LD_VAR 0 3
48331: PPUSH
48332: CALL_OW 262
48336: PUSH
48337: LD_INT 1
48339: EQUAL
48340: PUSH
48341: LD_VAR 0 3
48345: PPUSH
48346: CALL_OW 261
48350: PUSH
48351: LD_INT 10
48353: LESS
48354: AND
48355: IFFALSE 48684
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48357: LD_ADDR_VAR 0 8
48361: PUSH
48362: LD_EXP 99
48366: PUSH
48367: LD_VAR 0 2
48371: ARRAY
48372: PPUSH
48373: LD_INT 2
48375: PUSH
48376: LD_INT 30
48378: PUSH
48379: LD_INT 0
48381: PUSH
48382: EMPTY
48383: LIST
48384: LIST
48385: PUSH
48386: LD_INT 30
48388: PUSH
48389: LD_INT 1
48391: PUSH
48392: EMPTY
48393: LIST
48394: LIST
48395: PUSH
48396: EMPTY
48397: LIST
48398: LIST
48399: LIST
48400: PPUSH
48401: CALL_OW 72
48405: ST_TO_ADDR
// if not depot then
48406: LD_VAR 0 8
48410: NOT
48411: IFFALSE 48415
// continue ;
48413: GO 48178
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48415: LD_VAR 0 3
48419: PPUSH
48420: LD_VAR 0 8
48424: PPUSH
48425: LD_VAR 0 3
48429: PPUSH
48430: CALL_OW 74
48434: PPUSH
48435: CALL_OW 296
48439: PUSH
48440: LD_INT 6
48442: LESS
48443: IFFALSE 48459
// SetFuel ( j , 100 ) else
48445: LD_VAR 0 3
48449: PPUSH
48450: LD_INT 100
48452: PPUSH
48453: CALL_OW 240
48457: GO 48684
// if GetFuel ( j ) = 0 then
48459: LD_VAR 0 3
48463: PPUSH
48464: CALL_OW 261
48468: PUSH
48469: LD_INT 0
48471: EQUAL
48472: IFFALSE 48684
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48474: LD_ADDR_EXP 118
48478: PUSH
48479: LD_EXP 118
48483: PPUSH
48484: LD_VAR 0 2
48488: PPUSH
48489: LD_EXP 118
48493: PUSH
48494: LD_VAR 0 2
48498: ARRAY
48499: PUSH
48500: LD_VAR 0 3
48504: DIFF
48505: PPUSH
48506: CALL_OW 1
48510: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48511: LD_VAR 0 3
48515: PPUSH
48516: CALL_OW 263
48520: PUSH
48521: LD_INT 1
48523: EQUAL
48524: IFFALSE 48540
// ComExitVehicle ( IsInUnit ( j ) ) ;
48526: LD_VAR 0 3
48530: PPUSH
48531: CALL_OW 310
48535: PPUSH
48536: CALL_OW 121
// if GetControl ( j ) = control_remote then
48540: LD_VAR 0 3
48544: PPUSH
48545: CALL_OW 263
48549: PUSH
48550: LD_INT 2
48552: EQUAL
48553: IFFALSE 48564
// ComUnlink ( j ) ;
48555: LD_VAR 0 3
48559: PPUSH
48560: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48564: LD_ADDR_VAR 0 9
48568: PUSH
48569: LD_VAR 0 2
48573: PPUSH
48574: LD_INT 3
48576: PPUSH
48577: CALL 57821 0 2
48581: ST_TO_ADDR
// if fac then
48582: LD_VAR 0 9
48586: IFFALSE 48682
// begin for k in fac do
48588: LD_ADDR_VAR 0 4
48592: PUSH
48593: LD_VAR 0 9
48597: PUSH
48598: FOR_IN
48599: IFFALSE 48680
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48601: LD_ADDR_VAR 0 10
48605: PUSH
48606: LD_VAR 0 9
48610: PPUSH
48611: LD_VAR 0 3
48615: PPUSH
48616: CALL_OW 265
48620: PPUSH
48621: LD_VAR 0 3
48625: PPUSH
48626: CALL_OW 262
48630: PPUSH
48631: LD_VAR 0 3
48635: PPUSH
48636: CALL_OW 263
48640: PPUSH
48641: LD_VAR 0 3
48645: PPUSH
48646: CALL_OW 264
48650: PPUSH
48651: CALL 67893 0 5
48655: ST_TO_ADDR
// if components then
48656: LD_VAR 0 10
48660: IFFALSE 48678
// begin MC_InsertProduceList ( i , components ) ;
48662: LD_VAR 0 2
48666: PPUSH
48667: LD_VAR 0 10
48671: PPUSH
48672: CALL 57366 0 2
// break ;
48676: GO 48680
// end ; end ;
48678: GO 48598
48680: POP
48681: POP
// end ; continue ;
48682: GO 48178
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48684: LD_VAR 0 3
48688: PPUSH
48689: LD_INT 1
48691: PPUSH
48692: CALL_OW 289
48696: PUSH
48697: LD_INT 100
48699: LESS
48700: PUSH
48701: LD_VAR 0 3
48705: PPUSH
48706: CALL_OW 314
48710: NOT
48711: AND
48712: IFFALSE 48741
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48714: LD_VAR 0 3
48718: PPUSH
48719: LD_VAR 0 6
48723: PUSH
48724: LD_INT 2
48726: ARRAY
48727: PPUSH
48728: LD_VAR 0 6
48732: PUSH
48733: LD_INT 3
48735: ARRAY
48736: PPUSH
48737: CALL_OW 117
// break ;
48741: GO 48745
// end ;
48743: GO 48178
48745: POP
48746: POP
// end ; end ;
48747: GO 47016
48749: POP
48750: POP
// end ;
48751: LD_VAR 0 1
48755: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48756: LD_INT 0
48758: PPUSH
48759: PPUSH
48760: PPUSH
48761: PPUSH
// if not mc_bases then
48762: LD_EXP 99
48766: NOT
48767: IFFALSE 48771
// exit ;
48769: GO 48932
// for i = 1 to mc_bases do
48771: LD_ADDR_VAR 0 2
48775: PUSH
48776: DOUBLE
48777: LD_INT 1
48779: DEC
48780: ST_TO_ADDR
48781: LD_EXP 99
48785: PUSH
48786: FOR_TO
48787: IFFALSE 48930
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48789: LD_ADDR_VAR 0 4
48793: PUSH
48794: LD_EXP 118
48798: PUSH
48799: LD_VAR 0 2
48803: ARRAY
48804: PUSH
48805: LD_EXP 121
48809: PUSH
48810: LD_VAR 0 2
48814: ARRAY
48815: UNION
48816: PPUSH
48817: LD_INT 33
48819: PUSH
48820: LD_INT 2
48822: PUSH
48823: EMPTY
48824: LIST
48825: LIST
48826: PPUSH
48827: CALL_OW 72
48831: ST_TO_ADDR
// if tmp then
48832: LD_VAR 0 4
48836: IFFALSE 48928
// for j in tmp do
48838: LD_ADDR_VAR 0 3
48842: PUSH
48843: LD_VAR 0 4
48847: PUSH
48848: FOR_IN
48849: IFFALSE 48926
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48851: LD_VAR 0 3
48855: PPUSH
48856: CALL_OW 312
48860: NOT
48861: PUSH
48862: LD_VAR 0 3
48866: PPUSH
48867: CALL_OW 256
48871: PUSH
48872: LD_INT 250
48874: GREATEREQUAL
48875: AND
48876: IFFALSE 48889
// Connect ( j ) else
48878: LD_VAR 0 3
48882: PPUSH
48883: CALL 73294 0 1
48887: GO 48924
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48889: LD_VAR 0 3
48893: PPUSH
48894: CALL_OW 256
48898: PUSH
48899: LD_INT 250
48901: LESS
48902: PUSH
48903: LD_VAR 0 3
48907: PPUSH
48908: CALL_OW 312
48912: AND
48913: IFFALSE 48924
// ComUnlink ( j ) ;
48915: LD_VAR 0 3
48919: PPUSH
48920: CALL_OW 136
48924: GO 48848
48926: POP
48927: POP
// end ;
48928: GO 48786
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 1
48936: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48937: LD_INT 0
48939: PPUSH
48940: PPUSH
48941: PPUSH
48942: PPUSH
48943: PPUSH
// if not mc_bases then
48944: LD_EXP 99
48948: NOT
48949: IFFALSE 48953
// exit ;
48951: GO 49398
// for i = 1 to mc_bases do
48953: LD_ADDR_VAR 0 2
48957: PUSH
48958: DOUBLE
48959: LD_INT 1
48961: DEC
48962: ST_TO_ADDR
48963: LD_EXP 99
48967: PUSH
48968: FOR_TO
48969: IFFALSE 49396
// begin if not mc_produce [ i ] then
48971: LD_EXP 120
48975: PUSH
48976: LD_VAR 0 2
48980: ARRAY
48981: NOT
48982: IFFALSE 48986
// continue ;
48984: GO 48968
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48986: LD_ADDR_VAR 0 5
48990: PUSH
48991: LD_EXP 99
48995: PUSH
48996: LD_VAR 0 2
49000: ARRAY
49001: PPUSH
49002: LD_INT 30
49004: PUSH
49005: LD_INT 3
49007: PUSH
49008: EMPTY
49009: LIST
49010: LIST
49011: PPUSH
49012: CALL_OW 72
49016: ST_TO_ADDR
// if not fac then
49017: LD_VAR 0 5
49021: NOT
49022: IFFALSE 49026
// continue ;
49024: GO 48968
// for j in fac do
49026: LD_ADDR_VAR 0 3
49030: PUSH
49031: LD_VAR 0 5
49035: PUSH
49036: FOR_IN
49037: IFFALSE 49392
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49039: LD_VAR 0 3
49043: PPUSH
49044: CALL_OW 461
49048: PUSH
49049: LD_INT 2
49051: NONEQUAL
49052: PUSH
49053: LD_VAR 0 3
49057: PPUSH
49058: LD_INT 15
49060: PPUSH
49061: CALL 72954 0 2
49065: PUSH
49066: LD_INT 4
49068: ARRAY
49069: OR
49070: IFFALSE 49074
// continue ;
49072: GO 49036
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49074: LD_VAR 0 3
49078: PPUSH
49079: LD_EXP 120
49083: PUSH
49084: LD_VAR 0 2
49088: ARRAY
49089: PUSH
49090: LD_INT 1
49092: ARRAY
49093: PUSH
49094: LD_INT 1
49096: ARRAY
49097: PPUSH
49098: LD_EXP 120
49102: PUSH
49103: LD_VAR 0 2
49107: ARRAY
49108: PUSH
49109: LD_INT 1
49111: ARRAY
49112: PUSH
49113: LD_INT 2
49115: ARRAY
49116: PPUSH
49117: LD_EXP 120
49121: PUSH
49122: LD_VAR 0 2
49126: ARRAY
49127: PUSH
49128: LD_INT 1
49130: ARRAY
49131: PUSH
49132: LD_INT 3
49134: ARRAY
49135: PPUSH
49136: LD_EXP 120
49140: PUSH
49141: LD_VAR 0 2
49145: ARRAY
49146: PUSH
49147: LD_INT 1
49149: ARRAY
49150: PUSH
49151: LD_INT 4
49153: ARRAY
49154: PPUSH
49155: CALL_OW 448
49159: PUSH
49160: LD_VAR 0 3
49164: PPUSH
49165: LD_EXP 120
49169: PUSH
49170: LD_VAR 0 2
49174: ARRAY
49175: PUSH
49176: LD_INT 1
49178: ARRAY
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PUSH
49184: LD_EXP 120
49188: PUSH
49189: LD_VAR 0 2
49193: ARRAY
49194: PUSH
49195: LD_INT 1
49197: ARRAY
49198: PUSH
49199: LD_INT 2
49201: ARRAY
49202: PUSH
49203: LD_EXP 120
49207: PUSH
49208: LD_VAR 0 2
49212: ARRAY
49213: PUSH
49214: LD_INT 1
49216: ARRAY
49217: PUSH
49218: LD_INT 3
49220: ARRAY
49221: PUSH
49222: LD_EXP 120
49226: PUSH
49227: LD_VAR 0 2
49231: ARRAY
49232: PUSH
49233: LD_INT 1
49235: ARRAY
49236: PUSH
49237: LD_INT 4
49239: ARRAY
49240: PUSH
49241: EMPTY
49242: LIST
49243: LIST
49244: LIST
49245: LIST
49246: PPUSH
49247: CALL 76625 0 2
49251: AND
49252: IFFALSE 49390
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49254: LD_VAR 0 3
49258: PPUSH
49259: LD_EXP 120
49263: PUSH
49264: LD_VAR 0 2
49268: ARRAY
49269: PUSH
49270: LD_INT 1
49272: ARRAY
49273: PUSH
49274: LD_INT 1
49276: ARRAY
49277: PPUSH
49278: LD_EXP 120
49282: PUSH
49283: LD_VAR 0 2
49287: ARRAY
49288: PUSH
49289: LD_INT 1
49291: ARRAY
49292: PUSH
49293: LD_INT 2
49295: ARRAY
49296: PPUSH
49297: LD_EXP 120
49301: PUSH
49302: LD_VAR 0 2
49306: ARRAY
49307: PUSH
49308: LD_INT 1
49310: ARRAY
49311: PUSH
49312: LD_INT 3
49314: ARRAY
49315: PPUSH
49316: LD_EXP 120
49320: PUSH
49321: LD_VAR 0 2
49325: ARRAY
49326: PUSH
49327: LD_INT 1
49329: ARRAY
49330: PUSH
49331: LD_INT 4
49333: ARRAY
49334: PPUSH
49335: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49339: LD_ADDR_VAR 0 4
49343: PUSH
49344: LD_EXP 120
49348: PUSH
49349: LD_VAR 0 2
49353: ARRAY
49354: PPUSH
49355: LD_INT 1
49357: PPUSH
49358: CALL_OW 3
49362: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49363: LD_ADDR_EXP 120
49367: PUSH
49368: LD_EXP 120
49372: PPUSH
49373: LD_VAR 0 2
49377: PPUSH
49378: LD_VAR 0 4
49382: PPUSH
49383: CALL_OW 1
49387: ST_TO_ADDR
// break ;
49388: GO 49392
// end ; end ;
49390: GO 49036
49392: POP
49393: POP
// end ;
49394: GO 48968
49396: POP
49397: POP
// end ;
49398: LD_VAR 0 1
49402: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49403: LD_INT 0
49405: PPUSH
49406: PPUSH
49407: PPUSH
// if not mc_bases then
49408: LD_EXP 99
49412: NOT
49413: IFFALSE 49417
// exit ;
49415: GO 49506
// for i = 1 to mc_bases do
49417: LD_ADDR_VAR 0 2
49421: PUSH
49422: DOUBLE
49423: LD_INT 1
49425: DEC
49426: ST_TO_ADDR
49427: LD_EXP 99
49431: PUSH
49432: FOR_TO
49433: IFFALSE 49504
// begin if mc_attack [ i ] then
49435: LD_EXP 119
49439: PUSH
49440: LD_VAR 0 2
49444: ARRAY
49445: IFFALSE 49502
// begin tmp := mc_attack [ i ] [ 1 ] ;
49447: LD_ADDR_VAR 0 3
49451: PUSH
49452: LD_EXP 119
49456: PUSH
49457: LD_VAR 0 2
49461: ARRAY
49462: PUSH
49463: LD_INT 1
49465: ARRAY
49466: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49467: LD_ADDR_EXP 119
49471: PUSH
49472: LD_EXP 119
49476: PPUSH
49477: LD_VAR 0 2
49481: PPUSH
49482: EMPTY
49483: PPUSH
49484: CALL_OW 1
49488: ST_TO_ADDR
// Attack ( tmp ) ;
49489: LD_VAR 0 3
49493: PPUSH
49494: CALL 98838 0 1
// exit ;
49498: POP
49499: POP
49500: GO 49506
// end ; end ;
49502: GO 49432
49504: POP
49505: POP
// end ;
49506: LD_VAR 0 1
49510: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49511: LD_INT 0
49513: PPUSH
49514: PPUSH
49515: PPUSH
49516: PPUSH
49517: PPUSH
49518: PPUSH
49519: PPUSH
// if not mc_bases then
49520: LD_EXP 99
49524: NOT
49525: IFFALSE 49529
// exit ;
49527: GO 50111
// for i = 1 to mc_bases do
49529: LD_ADDR_VAR 0 2
49533: PUSH
49534: DOUBLE
49535: LD_INT 1
49537: DEC
49538: ST_TO_ADDR
49539: LD_EXP 99
49543: PUSH
49544: FOR_TO
49545: IFFALSE 50109
// begin if not mc_bases [ i ] then
49547: LD_EXP 99
49551: PUSH
49552: LD_VAR 0 2
49556: ARRAY
49557: NOT
49558: IFFALSE 49562
// continue ;
49560: GO 49544
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49562: LD_ADDR_VAR 0 7
49566: PUSH
49567: LD_EXP 99
49571: PUSH
49572: LD_VAR 0 2
49576: ARRAY
49577: PUSH
49578: LD_INT 1
49580: ARRAY
49581: PPUSH
49582: CALL 67197 0 1
49586: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49587: LD_ADDR_EXP 122
49591: PUSH
49592: LD_EXP 122
49596: PPUSH
49597: LD_VAR 0 2
49601: PPUSH
49602: LD_EXP 99
49606: PUSH
49607: LD_VAR 0 2
49611: ARRAY
49612: PUSH
49613: LD_INT 1
49615: ARRAY
49616: PPUSH
49617: CALL_OW 255
49621: PPUSH
49622: LD_EXP 124
49626: PUSH
49627: LD_VAR 0 2
49631: ARRAY
49632: PPUSH
49633: CALL 65115 0 2
49637: PPUSH
49638: CALL_OW 1
49642: ST_TO_ADDR
// if not mc_scan [ i ] then
49643: LD_EXP 122
49647: PUSH
49648: LD_VAR 0 2
49652: ARRAY
49653: NOT
49654: IFFALSE 49809
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49656: LD_ADDR_VAR 0 4
49660: PUSH
49661: LD_EXP 99
49665: PUSH
49666: LD_VAR 0 2
49670: ARRAY
49671: PPUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 25
49677: PUSH
49678: LD_INT 5
49680: PUSH
49681: EMPTY
49682: LIST
49683: LIST
49684: PUSH
49685: LD_INT 25
49687: PUSH
49688: LD_INT 8
49690: PUSH
49691: EMPTY
49692: LIST
49693: LIST
49694: PUSH
49695: LD_INT 25
49697: PUSH
49698: LD_INT 9
49700: PUSH
49701: EMPTY
49702: LIST
49703: LIST
49704: PUSH
49705: EMPTY
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: PPUSH
49711: CALL_OW 72
49715: ST_TO_ADDR
// if not tmp then
49716: LD_VAR 0 4
49720: NOT
49721: IFFALSE 49725
// continue ;
49723: GO 49544
// for j in tmp do
49725: LD_ADDR_VAR 0 3
49729: PUSH
49730: LD_VAR 0 4
49734: PUSH
49735: FOR_IN
49736: IFFALSE 49807
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49738: LD_VAR 0 3
49742: PPUSH
49743: CALL_OW 310
49747: PPUSH
49748: CALL_OW 266
49752: PUSH
49753: LD_INT 5
49755: EQUAL
49756: PUSH
49757: LD_VAR 0 3
49761: PPUSH
49762: CALL_OW 257
49766: PUSH
49767: LD_INT 1
49769: EQUAL
49770: AND
49771: PUSH
49772: LD_VAR 0 3
49776: PPUSH
49777: CALL_OW 459
49781: NOT
49782: AND
49783: PUSH
49784: LD_VAR 0 7
49788: AND
49789: IFFALSE 49805
// ComChangeProfession ( j , class ) ;
49791: LD_VAR 0 3
49795: PPUSH
49796: LD_VAR 0 7
49800: PPUSH
49801: CALL_OW 123
49805: GO 49735
49807: POP
49808: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49809: LD_EXP 122
49813: PUSH
49814: LD_VAR 0 2
49818: ARRAY
49819: PUSH
49820: LD_EXP 121
49824: PUSH
49825: LD_VAR 0 2
49829: ARRAY
49830: NOT
49831: AND
49832: PUSH
49833: LD_EXP 99
49837: PUSH
49838: LD_VAR 0 2
49842: ARRAY
49843: PPUSH
49844: LD_INT 30
49846: PUSH
49847: LD_INT 32
49849: PUSH
49850: EMPTY
49851: LIST
49852: LIST
49853: PPUSH
49854: CALL_OW 72
49858: NOT
49859: AND
49860: PUSH
49861: LD_EXP 99
49865: PUSH
49866: LD_VAR 0 2
49870: ARRAY
49871: PPUSH
49872: LD_INT 2
49874: PUSH
49875: LD_INT 30
49877: PUSH
49878: LD_INT 4
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: PUSH
49885: LD_INT 30
49887: PUSH
49888: LD_INT 5
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: EMPTY
49896: LIST
49897: LIST
49898: LIST
49899: PPUSH
49900: CALL_OW 72
49904: NOT
49905: AND
49906: IFFALSE 50038
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49908: LD_ADDR_VAR 0 4
49912: PUSH
49913: LD_EXP 99
49917: PUSH
49918: LD_VAR 0 2
49922: ARRAY
49923: PPUSH
49924: LD_INT 2
49926: PUSH
49927: LD_INT 25
49929: PUSH
49930: LD_INT 1
49932: PUSH
49933: EMPTY
49934: LIST
49935: LIST
49936: PUSH
49937: LD_INT 25
49939: PUSH
49940: LD_INT 5
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: LD_INT 25
49949: PUSH
49950: LD_INT 8
49952: PUSH
49953: EMPTY
49954: LIST
49955: LIST
49956: PUSH
49957: LD_INT 25
49959: PUSH
49960: LD_INT 9
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: LIST
49973: PPUSH
49974: CALL_OW 72
49978: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49979: LD_ADDR_VAR 0 4
49983: PUSH
49984: LD_VAR 0 4
49988: PUSH
49989: LD_VAR 0 4
49993: PPUSH
49994: LD_INT 18
49996: PPUSH
49997: CALL 103621 0 2
50001: DIFF
50002: ST_TO_ADDR
// if tmp then
50003: LD_VAR 0 4
50007: IFFALSE 50038
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50009: LD_VAR 0 2
50013: PPUSH
50014: LD_VAR 0 4
50018: PPUSH
50019: LD_EXP 124
50023: PUSH
50024: LD_VAR 0 2
50028: ARRAY
50029: PPUSH
50030: CALL 65150 0 3
// exit ;
50034: POP
50035: POP
50036: GO 50111
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50038: LD_EXP 122
50042: PUSH
50043: LD_VAR 0 2
50047: ARRAY
50048: PUSH
50049: LD_EXP 121
50053: PUSH
50054: LD_VAR 0 2
50058: ARRAY
50059: AND
50060: IFFALSE 50107
// begin tmp := mc_defender [ i ] ;
50062: LD_ADDR_VAR 0 4
50066: PUSH
50067: LD_EXP 121
50071: PUSH
50072: LD_VAR 0 2
50076: ARRAY
50077: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50078: LD_VAR 0 2
50082: PPUSH
50083: LD_VAR 0 4
50087: PPUSH
50088: LD_EXP 122
50092: PUSH
50093: LD_VAR 0 2
50097: ARRAY
50098: PPUSH
50099: CALL 65648 0 3
// exit ;
50103: POP
50104: POP
50105: GO 50111
// end ; end ;
50107: GO 49544
50109: POP
50110: POP
// end ;
50111: LD_VAR 0 1
50115: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50116: LD_INT 0
50118: PPUSH
50119: PPUSH
50120: PPUSH
50121: PPUSH
50122: PPUSH
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
50127: PPUSH
50128: PPUSH
// if not mc_bases then
50129: LD_EXP 99
50133: NOT
50134: IFFALSE 50138
// exit ;
50136: GO 51225
// for i = 1 to mc_bases do
50138: LD_ADDR_VAR 0 2
50142: PUSH
50143: DOUBLE
50144: LD_INT 1
50146: DEC
50147: ST_TO_ADDR
50148: LD_EXP 99
50152: PUSH
50153: FOR_TO
50154: IFFALSE 51223
// begin tmp := mc_lab [ i ] ;
50156: LD_ADDR_VAR 0 6
50160: PUSH
50161: LD_EXP 132
50165: PUSH
50166: LD_VAR 0 2
50170: ARRAY
50171: ST_TO_ADDR
// if not tmp then
50172: LD_VAR 0 6
50176: NOT
50177: IFFALSE 50181
// continue ;
50179: GO 50153
// idle_lab := 0 ;
50181: LD_ADDR_VAR 0 11
50185: PUSH
50186: LD_INT 0
50188: ST_TO_ADDR
// for j in tmp do
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_VAR 0 6
50198: PUSH
50199: FOR_IN
50200: IFFALSE 51219
// begin researching := false ;
50202: LD_ADDR_VAR 0 10
50206: PUSH
50207: LD_INT 0
50209: ST_TO_ADDR
// side := GetSide ( j ) ;
50210: LD_ADDR_VAR 0 4
50214: PUSH
50215: LD_VAR 0 3
50219: PPUSH
50220: CALL_OW 255
50224: ST_TO_ADDR
// if not mc_tech [ side ] then
50225: LD_EXP 126
50229: PUSH
50230: LD_VAR 0 4
50234: ARRAY
50235: NOT
50236: IFFALSE 50240
// continue ;
50238: GO 50199
// if BuildingStatus ( j ) = bs_idle then
50240: LD_VAR 0 3
50244: PPUSH
50245: CALL_OW 461
50249: PUSH
50250: LD_INT 2
50252: EQUAL
50253: IFFALSE 50441
// begin if idle_lab and UnitsInside ( j ) < 6 then
50255: LD_VAR 0 11
50259: PUSH
50260: LD_VAR 0 3
50264: PPUSH
50265: CALL_OW 313
50269: PUSH
50270: LD_INT 6
50272: LESS
50273: AND
50274: IFFALSE 50345
// begin tmp2 := UnitsInside ( idle_lab ) ;
50276: LD_ADDR_VAR 0 9
50280: PUSH
50281: LD_VAR 0 11
50285: PPUSH
50286: CALL_OW 313
50290: ST_TO_ADDR
// if tmp2 then
50291: LD_VAR 0 9
50295: IFFALSE 50337
// for x in tmp2 do
50297: LD_ADDR_VAR 0 7
50301: PUSH
50302: LD_VAR 0 9
50306: PUSH
50307: FOR_IN
50308: IFFALSE 50335
// begin ComExitBuilding ( x ) ;
50310: LD_VAR 0 7
50314: PPUSH
50315: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50319: LD_VAR 0 7
50323: PPUSH
50324: LD_VAR 0 3
50328: PPUSH
50329: CALL_OW 180
// end ;
50333: GO 50307
50335: POP
50336: POP
// idle_lab := 0 ;
50337: LD_ADDR_VAR 0 11
50341: PUSH
50342: LD_INT 0
50344: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50345: LD_ADDR_VAR 0 5
50349: PUSH
50350: LD_EXP 126
50354: PUSH
50355: LD_VAR 0 4
50359: ARRAY
50360: PUSH
50361: FOR_IN
50362: IFFALSE 50422
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50364: LD_VAR 0 3
50368: PPUSH
50369: LD_VAR 0 5
50373: PPUSH
50374: CALL_OW 430
50378: PUSH
50379: LD_VAR 0 4
50383: PPUSH
50384: LD_VAR 0 5
50388: PPUSH
50389: CALL 64220 0 2
50393: AND
50394: IFFALSE 50420
// begin researching := true ;
50396: LD_ADDR_VAR 0 10
50400: PUSH
50401: LD_INT 1
50403: ST_TO_ADDR
// ComResearch ( j , t ) ;
50404: LD_VAR 0 3
50408: PPUSH
50409: LD_VAR 0 5
50413: PPUSH
50414: CALL_OW 124
// break ;
50418: GO 50422
// end ;
50420: GO 50361
50422: POP
50423: POP
// if not researching then
50424: LD_VAR 0 10
50428: NOT
50429: IFFALSE 50441
// idle_lab := j ;
50431: LD_ADDR_VAR 0 11
50435: PUSH
50436: LD_VAR 0 3
50440: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50441: LD_VAR 0 3
50445: PPUSH
50446: CALL_OW 461
50450: PUSH
50451: LD_INT 10
50453: EQUAL
50454: IFFALSE 51042
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50456: LD_EXP 128
50460: PUSH
50461: LD_VAR 0 2
50465: ARRAY
50466: NOT
50467: PUSH
50468: LD_EXP 129
50472: PUSH
50473: LD_VAR 0 2
50477: ARRAY
50478: NOT
50479: AND
50480: PUSH
50481: LD_EXP 126
50485: PUSH
50486: LD_VAR 0 4
50490: ARRAY
50491: PUSH
50492: LD_INT 1
50494: GREATER
50495: AND
50496: IFFALSE 50627
// begin ComCancel ( j ) ;
50498: LD_VAR 0 3
50502: PPUSH
50503: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50507: LD_ADDR_EXP 126
50511: PUSH
50512: LD_EXP 126
50516: PPUSH
50517: LD_VAR 0 4
50521: PPUSH
50522: LD_EXP 126
50526: PUSH
50527: LD_VAR 0 4
50531: ARRAY
50532: PPUSH
50533: LD_EXP 126
50537: PUSH
50538: LD_VAR 0 4
50542: ARRAY
50543: PUSH
50544: LD_INT 1
50546: MINUS
50547: PPUSH
50548: LD_EXP 126
50552: PUSH
50553: LD_VAR 0 4
50557: ARRAY
50558: PPUSH
50559: LD_INT 0
50561: PPUSH
50562: CALL 69779 0 4
50566: PPUSH
50567: CALL_OW 1
50571: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50572: LD_ADDR_EXP 126
50576: PUSH
50577: LD_EXP 126
50581: PPUSH
50582: LD_VAR 0 4
50586: PPUSH
50587: LD_EXP 126
50591: PUSH
50592: LD_VAR 0 4
50596: ARRAY
50597: PPUSH
50598: LD_EXP 126
50602: PUSH
50603: LD_VAR 0 4
50607: ARRAY
50608: PPUSH
50609: LD_INT 1
50611: PPUSH
50612: LD_INT 0
50614: PPUSH
50615: CALL 69779 0 4
50619: PPUSH
50620: CALL_OW 1
50624: ST_TO_ADDR
// continue ;
50625: GO 50199
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50627: LD_EXP 128
50631: PUSH
50632: LD_VAR 0 2
50636: ARRAY
50637: PUSH
50638: LD_EXP 129
50642: PUSH
50643: LD_VAR 0 2
50647: ARRAY
50648: NOT
50649: AND
50650: IFFALSE 50777
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50652: LD_ADDR_EXP 129
50656: PUSH
50657: LD_EXP 129
50661: PPUSH
50662: LD_VAR 0 2
50666: PUSH
50667: LD_EXP 129
50671: PUSH
50672: LD_VAR 0 2
50676: ARRAY
50677: PUSH
50678: LD_INT 1
50680: PLUS
50681: PUSH
50682: EMPTY
50683: LIST
50684: LIST
50685: PPUSH
50686: LD_EXP 128
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: PUSH
50697: LD_INT 1
50699: ARRAY
50700: PPUSH
50701: CALL 70361 0 3
50705: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50706: LD_EXP 128
50710: PUSH
50711: LD_VAR 0 2
50715: ARRAY
50716: PUSH
50717: LD_INT 1
50719: ARRAY
50720: PPUSH
50721: LD_INT 112
50723: PPUSH
50724: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50728: LD_ADDR_VAR 0 9
50732: PUSH
50733: LD_EXP 128
50737: PUSH
50738: LD_VAR 0 2
50742: ARRAY
50743: PPUSH
50744: LD_INT 1
50746: PPUSH
50747: CALL_OW 3
50751: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50752: LD_ADDR_EXP 128
50756: PUSH
50757: LD_EXP 128
50761: PPUSH
50762: LD_VAR 0 2
50766: PPUSH
50767: LD_VAR 0 9
50771: PPUSH
50772: CALL_OW 1
50776: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50777: LD_EXP 128
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PUSH
50788: LD_EXP 129
50792: PUSH
50793: LD_VAR 0 2
50797: ARRAY
50798: AND
50799: PUSH
50800: LD_EXP 129
50804: PUSH
50805: LD_VAR 0 2
50809: ARRAY
50810: PUSH
50811: LD_INT 1
50813: ARRAY
50814: PPUSH
50815: CALL_OW 310
50819: NOT
50820: AND
50821: PUSH
50822: LD_VAR 0 3
50826: PPUSH
50827: CALL_OW 313
50831: PUSH
50832: LD_INT 6
50834: EQUAL
50835: AND
50836: IFFALSE 50892
// begin tmp2 := UnitsInside ( j ) ;
50838: LD_ADDR_VAR 0 9
50842: PUSH
50843: LD_VAR 0 3
50847: PPUSH
50848: CALL_OW 313
50852: ST_TO_ADDR
// if tmp2 = 6 then
50853: LD_VAR 0 9
50857: PUSH
50858: LD_INT 6
50860: EQUAL
50861: IFFALSE 50892
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50863: LD_VAR 0 9
50867: PUSH
50868: LD_INT 1
50870: ARRAY
50871: PPUSH
50872: LD_INT 112
50874: PPUSH
50875: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50879: LD_VAR 0 9
50883: PUSH
50884: LD_INT 1
50886: ARRAY
50887: PPUSH
50888: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50892: LD_EXP 129
50896: PUSH
50897: LD_VAR 0 2
50901: ARRAY
50902: PUSH
50903: LD_EXP 129
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: PUSH
50914: LD_INT 1
50916: ARRAY
50917: PPUSH
50918: CALL_OW 314
50922: NOT
50923: AND
50924: PUSH
50925: LD_EXP 129
50929: PUSH
50930: LD_VAR 0 2
50934: ARRAY
50935: PUSH
50936: LD_INT 1
50938: ARRAY
50939: PPUSH
50940: CALL_OW 310
50944: NOT
50945: AND
50946: IFFALSE 50972
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50948: LD_EXP 129
50952: PUSH
50953: LD_VAR 0 2
50957: ARRAY
50958: PUSH
50959: LD_INT 1
50961: ARRAY
50962: PPUSH
50963: LD_VAR 0 3
50967: PPUSH
50968: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50972: LD_EXP 129
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: PUSH
50983: LD_INT 1
50985: ARRAY
50986: PPUSH
50987: CALL_OW 310
50991: PUSH
50992: LD_EXP 129
50996: PUSH
50997: LD_VAR 0 2
51001: ARRAY
51002: PUSH
51003: LD_INT 1
51005: ARRAY
51006: PPUSH
51007: CALL_OW 310
51011: PPUSH
51012: CALL_OW 461
51016: PUSH
51017: LD_INT 3
51019: NONEQUAL
51020: AND
51021: IFFALSE 51042
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51023: LD_EXP 129
51027: PUSH
51028: LD_VAR 0 2
51032: ARRAY
51033: PUSH
51034: LD_INT 1
51036: ARRAY
51037: PPUSH
51038: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51042: LD_VAR 0 3
51046: PPUSH
51047: CALL_OW 461
51051: PUSH
51052: LD_INT 6
51054: EQUAL
51055: PUSH
51056: LD_VAR 0 6
51060: PUSH
51061: LD_INT 1
51063: GREATER
51064: AND
51065: IFFALSE 51217
// begin sci := [ ] ;
51067: LD_ADDR_VAR 0 8
51071: PUSH
51072: EMPTY
51073: ST_TO_ADDR
// for x in ( tmp diff j ) do
51074: LD_ADDR_VAR 0 7
51078: PUSH
51079: LD_VAR 0 6
51083: PUSH
51084: LD_VAR 0 3
51088: DIFF
51089: PUSH
51090: FOR_IN
51091: IFFALSE 51143
// begin if sci = 6 then
51093: LD_VAR 0 8
51097: PUSH
51098: LD_INT 6
51100: EQUAL
51101: IFFALSE 51105
// break ;
51103: GO 51143
// if BuildingStatus ( x ) = bs_idle then
51105: LD_VAR 0 7
51109: PPUSH
51110: CALL_OW 461
51114: PUSH
51115: LD_INT 2
51117: EQUAL
51118: IFFALSE 51141
// sci := sci ^ UnitsInside ( x ) ;
51120: LD_ADDR_VAR 0 8
51124: PUSH
51125: LD_VAR 0 8
51129: PUSH
51130: LD_VAR 0 7
51134: PPUSH
51135: CALL_OW 313
51139: ADD
51140: ST_TO_ADDR
// end ;
51141: GO 51090
51143: POP
51144: POP
// if not sci then
51145: LD_VAR 0 8
51149: NOT
51150: IFFALSE 51154
// continue ;
51152: GO 50199
// for x in sci do
51154: LD_ADDR_VAR 0 7
51158: PUSH
51159: LD_VAR 0 8
51163: PUSH
51164: FOR_IN
51165: IFFALSE 51215
// if IsInUnit ( x ) and not HasTask ( x ) then
51167: LD_VAR 0 7
51171: PPUSH
51172: CALL_OW 310
51176: PUSH
51177: LD_VAR 0 7
51181: PPUSH
51182: CALL_OW 314
51186: NOT
51187: AND
51188: IFFALSE 51213
// begin ComExitBuilding ( x ) ;
51190: LD_VAR 0 7
51194: PPUSH
51195: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51199: LD_VAR 0 7
51203: PPUSH
51204: LD_VAR 0 3
51208: PPUSH
51209: CALL_OW 180
// end ;
51213: GO 51164
51215: POP
51216: POP
// end ; end ;
51217: GO 50199
51219: POP
51220: POP
// end ;
51221: GO 50153
51223: POP
51224: POP
// end ;
51225: LD_VAR 0 1
51229: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51230: LD_INT 0
51232: PPUSH
51233: PPUSH
// if not mc_bases then
51234: LD_EXP 99
51238: NOT
51239: IFFALSE 51243
// exit ;
51241: GO 51324
// for i = 1 to mc_bases do
51243: LD_ADDR_VAR 0 2
51247: PUSH
51248: DOUBLE
51249: LD_INT 1
51251: DEC
51252: ST_TO_ADDR
51253: LD_EXP 99
51257: PUSH
51258: FOR_TO
51259: IFFALSE 51322
// if mc_mines [ i ] and mc_miners [ i ] then
51261: LD_EXP 112
51265: PUSH
51266: LD_VAR 0 2
51270: ARRAY
51271: PUSH
51272: LD_EXP 113
51276: PUSH
51277: LD_VAR 0 2
51281: ARRAY
51282: AND
51283: IFFALSE 51320
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51285: LD_EXP 113
51289: PUSH
51290: LD_VAR 0 2
51294: ARRAY
51295: PUSH
51296: LD_INT 1
51298: ARRAY
51299: PPUSH
51300: CALL_OW 255
51304: PPUSH
51305: LD_EXP 112
51309: PUSH
51310: LD_VAR 0 2
51314: ARRAY
51315: PPUSH
51316: CALL 67350 0 2
51320: GO 51258
51322: POP
51323: POP
// end ;
51324: LD_VAR 0 1
51328: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51329: LD_INT 0
51331: PPUSH
51332: PPUSH
51333: PPUSH
51334: PPUSH
51335: PPUSH
51336: PPUSH
51337: PPUSH
51338: PPUSH
// if not mc_bases or not mc_parking then
51339: LD_EXP 99
51343: NOT
51344: PUSH
51345: LD_EXP 123
51349: NOT
51350: OR
51351: IFFALSE 51355
// exit ;
51353: GO 52054
// for i = 1 to mc_bases do
51355: LD_ADDR_VAR 0 2
51359: PUSH
51360: DOUBLE
51361: LD_INT 1
51363: DEC
51364: ST_TO_ADDR
51365: LD_EXP 99
51369: PUSH
51370: FOR_TO
51371: IFFALSE 52052
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51373: LD_EXP 99
51377: PUSH
51378: LD_VAR 0 2
51382: ARRAY
51383: NOT
51384: PUSH
51385: LD_EXP 123
51389: PUSH
51390: LD_VAR 0 2
51394: ARRAY
51395: NOT
51396: OR
51397: IFFALSE 51401
// continue ;
51399: GO 51370
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51401: LD_ADDR_VAR 0 5
51405: PUSH
51406: LD_EXP 99
51410: PUSH
51411: LD_VAR 0 2
51415: ARRAY
51416: PUSH
51417: LD_INT 1
51419: ARRAY
51420: PPUSH
51421: CALL_OW 255
51425: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51426: LD_ADDR_VAR 0 6
51430: PUSH
51431: LD_EXP 99
51435: PUSH
51436: LD_VAR 0 2
51440: ARRAY
51441: PPUSH
51442: LD_INT 30
51444: PUSH
51445: LD_INT 3
51447: PUSH
51448: EMPTY
51449: LIST
51450: LIST
51451: PPUSH
51452: CALL_OW 72
51456: ST_TO_ADDR
// if not fac then
51457: LD_VAR 0 6
51461: NOT
51462: IFFALSE 51513
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51464: LD_ADDR_VAR 0 6
51468: PUSH
51469: LD_EXP 99
51473: PUSH
51474: LD_VAR 0 2
51478: ARRAY
51479: PPUSH
51480: LD_INT 2
51482: PUSH
51483: LD_INT 30
51485: PUSH
51486: LD_INT 0
51488: PUSH
51489: EMPTY
51490: LIST
51491: LIST
51492: PUSH
51493: LD_INT 30
51495: PUSH
51496: LD_INT 1
51498: PUSH
51499: EMPTY
51500: LIST
51501: LIST
51502: PUSH
51503: EMPTY
51504: LIST
51505: LIST
51506: LIST
51507: PPUSH
51508: CALL_OW 72
51512: ST_TO_ADDR
// if not fac then
51513: LD_VAR 0 6
51517: NOT
51518: IFFALSE 51522
// continue ;
51520: GO 51370
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51522: LD_ADDR_VAR 0 7
51526: PUSH
51527: LD_EXP 123
51531: PUSH
51532: LD_VAR 0 2
51536: ARRAY
51537: PPUSH
51538: LD_INT 22
51540: PUSH
51541: LD_VAR 0 5
51545: PUSH
51546: EMPTY
51547: LIST
51548: LIST
51549: PUSH
51550: LD_INT 21
51552: PUSH
51553: LD_INT 2
51555: PUSH
51556: EMPTY
51557: LIST
51558: LIST
51559: PUSH
51560: LD_INT 3
51562: PUSH
51563: LD_INT 24
51565: PUSH
51566: LD_INT 1000
51568: PUSH
51569: EMPTY
51570: LIST
51571: LIST
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PUSH
51577: EMPTY
51578: LIST
51579: LIST
51580: LIST
51581: PPUSH
51582: CALL_OW 70
51586: ST_TO_ADDR
// for j in fac do
51587: LD_ADDR_VAR 0 3
51591: PUSH
51592: LD_VAR 0 6
51596: PUSH
51597: FOR_IN
51598: IFFALSE 51679
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51600: LD_ADDR_VAR 0 7
51604: PUSH
51605: LD_VAR 0 7
51609: PUSH
51610: LD_INT 22
51612: PUSH
51613: LD_VAR 0 5
51617: PUSH
51618: EMPTY
51619: LIST
51620: LIST
51621: PUSH
51622: LD_INT 91
51624: PUSH
51625: LD_VAR 0 3
51629: PUSH
51630: LD_INT 15
51632: PUSH
51633: EMPTY
51634: LIST
51635: LIST
51636: LIST
51637: PUSH
51638: LD_INT 21
51640: PUSH
51641: LD_INT 2
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: PUSH
51648: LD_INT 3
51650: PUSH
51651: LD_INT 24
51653: PUSH
51654: LD_INT 1000
51656: PUSH
51657: EMPTY
51658: LIST
51659: LIST
51660: PUSH
51661: EMPTY
51662: LIST
51663: LIST
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: LIST
51669: LIST
51670: PPUSH
51671: CALL_OW 69
51675: UNION
51676: ST_TO_ADDR
51677: GO 51597
51679: POP
51680: POP
// if not vehs then
51681: LD_VAR 0 7
51685: NOT
51686: IFFALSE 51712
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51688: LD_ADDR_EXP 111
51692: PUSH
51693: LD_EXP 111
51697: PPUSH
51698: LD_VAR 0 2
51702: PPUSH
51703: EMPTY
51704: PPUSH
51705: CALL_OW 1
51709: ST_TO_ADDR
// continue ;
51710: GO 51370
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51712: LD_ADDR_VAR 0 8
51716: PUSH
51717: LD_EXP 99
51721: PUSH
51722: LD_VAR 0 2
51726: ARRAY
51727: PPUSH
51728: LD_INT 30
51730: PUSH
51731: LD_INT 3
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: PPUSH
51738: CALL_OW 72
51742: ST_TO_ADDR
// if tmp then
51743: LD_VAR 0 8
51747: IFFALSE 51850
// begin for j in tmp do
51749: LD_ADDR_VAR 0 3
51753: PUSH
51754: LD_VAR 0 8
51758: PUSH
51759: FOR_IN
51760: IFFALSE 51848
// for k in UnitsInside ( j ) do
51762: LD_ADDR_VAR 0 4
51766: PUSH
51767: LD_VAR 0 3
51771: PPUSH
51772: CALL_OW 313
51776: PUSH
51777: FOR_IN
51778: IFFALSE 51844
// if k then
51780: LD_VAR 0 4
51784: IFFALSE 51842
// if not k in mc_repair_vehicle [ i ] then
51786: LD_VAR 0 4
51790: PUSH
51791: LD_EXP 111
51795: PUSH
51796: LD_VAR 0 2
51800: ARRAY
51801: IN
51802: NOT
51803: IFFALSE 51842
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51805: LD_ADDR_EXP 111
51809: PUSH
51810: LD_EXP 111
51814: PPUSH
51815: LD_VAR 0 2
51819: PPUSH
51820: LD_EXP 111
51824: PUSH
51825: LD_VAR 0 2
51829: ARRAY
51830: PUSH
51831: LD_VAR 0 4
51835: UNION
51836: PPUSH
51837: CALL_OW 1
51841: ST_TO_ADDR
51842: GO 51777
51844: POP
51845: POP
51846: GO 51759
51848: POP
51849: POP
// end ; if not mc_repair_vehicle [ i ] then
51850: LD_EXP 111
51854: PUSH
51855: LD_VAR 0 2
51859: ARRAY
51860: NOT
51861: IFFALSE 51865
// continue ;
51863: GO 51370
// for j in mc_repair_vehicle [ i ] do
51865: LD_ADDR_VAR 0 3
51869: PUSH
51870: LD_EXP 111
51874: PUSH
51875: LD_VAR 0 2
51879: ARRAY
51880: PUSH
51881: FOR_IN
51882: IFFALSE 52048
// begin if GetClass ( j ) <> 3 then
51884: LD_VAR 0 3
51888: PPUSH
51889: CALL_OW 257
51893: PUSH
51894: LD_INT 3
51896: NONEQUAL
51897: IFFALSE 51938
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51899: LD_ADDR_EXP 111
51903: PUSH
51904: LD_EXP 111
51908: PPUSH
51909: LD_VAR 0 2
51913: PPUSH
51914: LD_EXP 111
51918: PUSH
51919: LD_VAR 0 2
51923: ARRAY
51924: PUSH
51925: LD_VAR 0 3
51929: DIFF
51930: PPUSH
51931: CALL_OW 1
51935: ST_TO_ADDR
// continue ;
51936: GO 51881
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51938: LD_VAR 0 3
51942: PPUSH
51943: CALL_OW 311
51947: NOT
51948: PUSH
51949: LD_VAR 0 3
51953: PUSH
51954: LD_EXP 102
51958: PUSH
51959: LD_VAR 0 2
51963: ARRAY
51964: PUSH
51965: LD_INT 1
51967: ARRAY
51968: IN
51969: NOT
51970: AND
51971: PUSH
51972: LD_VAR 0 3
51976: PUSH
51977: LD_EXP 102
51981: PUSH
51982: LD_VAR 0 2
51986: ARRAY
51987: PUSH
51988: LD_INT 2
51990: ARRAY
51991: IN
51992: NOT
51993: AND
51994: IFFALSE 52046
// begin if IsInUnit ( j ) then
51996: LD_VAR 0 3
52000: PPUSH
52001: CALL_OW 310
52005: IFFALSE 52016
// ComExitBuilding ( j ) ;
52007: LD_VAR 0 3
52011: PPUSH
52012: CALL_OW 122
// if not HasTask ( j ) then
52016: LD_VAR 0 3
52020: PPUSH
52021: CALL_OW 314
52025: NOT
52026: IFFALSE 52046
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52028: LD_VAR 0 3
52032: PPUSH
52033: LD_VAR 0 7
52037: PUSH
52038: LD_INT 1
52040: ARRAY
52041: PPUSH
52042: CALL_OW 189
// end ; end ;
52046: GO 51881
52048: POP
52049: POP
// end ;
52050: GO 51370
52052: POP
52053: POP
// end ;
52054: LD_VAR 0 1
52058: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52059: LD_INT 0
52061: PPUSH
52062: PPUSH
52063: PPUSH
52064: PPUSH
52065: PPUSH
52066: PPUSH
52067: PPUSH
52068: PPUSH
52069: PPUSH
52070: PPUSH
52071: PPUSH
// if not mc_bases then
52072: LD_EXP 99
52076: NOT
52077: IFFALSE 52081
// exit ;
52079: GO 52883
// for i = 1 to mc_bases do
52081: LD_ADDR_VAR 0 2
52085: PUSH
52086: DOUBLE
52087: LD_INT 1
52089: DEC
52090: ST_TO_ADDR
52091: LD_EXP 99
52095: PUSH
52096: FOR_TO
52097: IFFALSE 52881
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52099: LD_EXP 127
52103: PUSH
52104: LD_VAR 0 2
52108: ARRAY
52109: NOT
52110: PUSH
52111: LD_EXP 102
52115: PUSH
52116: LD_VAR 0 2
52120: ARRAY
52121: PUSH
52122: LD_INT 1
52124: ARRAY
52125: OR
52126: PUSH
52127: LD_EXP 102
52131: PUSH
52132: LD_VAR 0 2
52136: ARRAY
52137: PUSH
52138: LD_INT 2
52140: ARRAY
52141: OR
52142: PUSH
52143: LD_EXP 125
52147: PUSH
52148: LD_VAR 0 2
52152: ARRAY
52153: PPUSH
52154: LD_INT 1
52156: PPUSH
52157: CALL_OW 325
52161: NOT
52162: OR
52163: PUSH
52164: LD_EXP 122
52168: PUSH
52169: LD_VAR 0 2
52173: ARRAY
52174: OR
52175: IFFALSE 52179
// continue ;
52177: GO 52096
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52179: LD_ADDR_VAR 0 8
52183: PUSH
52184: LD_EXP 99
52188: PUSH
52189: LD_VAR 0 2
52193: ARRAY
52194: PPUSH
52195: LD_INT 25
52197: PUSH
52198: LD_INT 4
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PUSH
52205: LD_INT 50
52207: PUSH
52208: EMPTY
52209: LIST
52210: PUSH
52211: LD_INT 3
52213: PUSH
52214: LD_INT 60
52216: PUSH
52217: EMPTY
52218: LIST
52219: PUSH
52220: EMPTY
52221: LIST
52222: LIST
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: LIST
52228: PPUSH
52229: CALL_OW 72
52233: PUSH
52234: LD_EXP 103
52238: PUSH
52239: LD_VAR 0 2
52243: ARRAY
52244: DIFF
52245: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52246: LD_ADDR_VAR 0 9
52250: PUSH
52251: LD_EXP 99
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PPUSH
52262: LD_INT 2
52264: PUSH
52265: LD_INT 30
52267: PUSH
52268: LD_INT 0
52270: PUSH
52271: EMPTY
52272: LIST
52273: LIST
52274: PUSH
52275: LD_INT 30
52277: PUSH
52278: LD_INT 1
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: LIST
52289: PPUSH
52290: CALL_OW 72
52294: ST_TO_ADDR
// if not tmp or not dep then
52295: LD_VAR 0 8
52299: NOT
52300: PUSH
52301: LD_VAR 0 9
52305: NOT
52306: OR
52307: IFFALSE 52311
// continue ;
52309: GO 52096
// side := GetSide ( tmp [ 1 ] ) ;
52311: LD_ADDR_VAR 0 11
52315: PUSH
52316: LD_VAR 0 8
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PPUSH
52325: CALL_OW 255
52329: ST_TO_ADDR
// dep := dep [ 1 ] ;
52330: LD_ADDR_VAR 0 9
52334: PUSH
52335: LD_VAR 0 9
52339: PUSH
52340: LD_INT 1
52342: ARRAY
52343: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52344: LD_ADDR_VAR 0 7
52348: PUSH
52349: LD_EXP 127
52353: PUSH
52354: LD_VAR 0 2
52358: ARRAY
52359: PPUSH
52360: LD_INT 22
52362: PUSH
52363: LD_INT 0
52365: PUSH
52366: EMPTY
52367: LIST
52368: LIST
52369: PUSH
52370: LD_INT 25
52372: PUSH
52373: LD_INT 12
52375: PUSH
52376: EMPTY
52377: LIST
52378: LIST
52379: PUSH
52380: EMPTY
52381: LIST
52382: LIST
52383: PPUSH
52384: CALL_OW 70
52388: PUSH
52389: LD_INT 22
52391: PUSH
52392: LD_INT 0
52394: PUSH
52395: EMPTY
52396: LIST
52397: LIST
52398: PUSH
52399: LD_INT 25
52401: PUSH
52402: LD_INT 12
52404: PUSH
52405: EMPTY
52406: LIST
52407: LIST
52408: PUSH
52409: LD_INT 91
52411: PUSH
52412: LD_VAR 0 9
52416: PUSH
52417: LD_INT 20
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: LIST
52424: PUSH
52425: EMPTY
52426: LIST
52427: LIST
52428: LIST
52429: PPUSH
52430: CALL_OW 69
52434: UNION
52435: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52436: LD_ADDR_VAR 0 10
52440: PUSH
52441: LD_EXP 127
52445: PUSH
52446: LD_VAR 0 2
52450: ARRAY
52451: PPUSH
52452: LD_INT 81
52454: PUSH
52455: LD_VAR 0 11
52459: PUSH
52460: EMPTY
52461: LIST
52462: LIST
52463: PPUSH
52464: CALL_OW 70
52468: ST_TO_ADDR
// if not apes or danger_at_area then
52469: LD_VAR 0 7
52473: NOT
52474: PUSH
52475: LD_VAR 0 10
52479: OR
52480: IFFALSE 52530
// begin if mc_taming [ i ] then
52482: LD_EXP 130
52486: PUSH
52487: LD_VAR 0 2
52491: ARRAY
52492: IFFALSE 52528
// begin MC_Reset ( i , 121 ) ;
52494: LD_VAR 0 2
52498: PPUSH
52499: LD_INT 121
52501: PPUSH
52502: CALL 37861 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52506: LD_ADDR_EXP 130
52510: PUSH
52511: LD_EXP 130
52515: PPUSH
52516: LD_VAR 0 2
52520: PPUSH
52521: EMPTY
52522: PPUSH
52523: CALL_OW 1
52527: ST_TO_ADDR
// end ; continue ;
52528: GO 52096
// end ; for j in tmp do
52530: LD_ADDR_VAR 0 3
52534: PUSH
52535: LD_VAR 0 8
52539: PUSH
52540: FOR_IN
52541: IFFALSE 52877
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52543: LD_VAR 0 3
52547: PUSH
52548: LD_EXP 130
52552: PUSH
52553: LD_VAR 0 2
52557: ARRAY
52558: IN
52559: NOT
52560: PUSH
52561: LD_EXP 130
52565: PUSH
52566: LD_VAR 0 2
52570: ARRAY
52571: PUSH
52572: LD_INT 3
52574: LESS
52575: AND
52576: IFFALSE 52634
// begin SetTag ( j , 121 ) ;
52578: LD_VAR 0 3
52582: PPUSH
52583: LD_INT 121
52585: PPUSH
52586: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52590: LD_ADDR_EXP 130
52594: PUSH
52595: LD_EXP 130
52599: PPUSH
52600: LD_VAR 0 2
52604: PUSH
52605: LD_EXP 130
52609: PUSH
52610: LD_VAR 0 2
52614: ARRAY
52615: PUSH
52616: LD_INT 1
52618: PLUS
52619: PUSH
52620: EMPTY
52621: LIST
52622: LIST
52623: PPUSH
52624: LD_VAR 0 3
52628: PPUSH
52629: CALL 70361 0 3
52633: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52634: LD_VAR 0 3
52638: PUSH
52639: LD_EXP 130
52643: PUSH
52644: LD_VAR 0 2
52648: ARRAY
52649: IN
52650: IFFALSE 52875
// begin if GetClass ( j ) <> 4 then
52652: LD_VAR 0 3
52656: PPUSH
52657: CALL_OW 257
52661: PUSH
52662: LD_INT 4
52664: NONEQUAL
52665: IFFALSE 52718
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52667: LD_ADDR_EXP 130
52671: PUSH
52672: LD_EXP 130
52676: PPUSH
52677: LD_VAR 0 2
52681: PPUSH
52682: LD_EXP 130
52686: PUSH
52687: LD_VAR 0 2
52691: ARRAY
52692: PUSH
52693: LD_VAR 0 3
52697: DIFF
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52704: LD_VAR 0 3
52708: PPUSH
52709: LD_INT 0
52711: PPUSH
52712: CALL_OW 109
// continue ;
52716: GO 52540
// end ; if IsInUnit ( j ) then
52718: LD_VAR 0 3
52722: PPUSH
52723: CALL_OW 310
52727: IFFALSE 52738
// ComExitBuilding ( j ) ;
52729: LD_VAR 0 3
52733: PPUSH
52734: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52738: LD_ADDR_VAR 0 6
52742: PUSH
52743: LD_VAR 0 7
52747: PPUSH
52748: LD_VAR 0 3
52752: PPUSH
52753: CALL_OW 74
52757: ST_TO_ADDR
// if not ape then
52758: LD_VAR 0 6
52762: NOT
52763: IFFALSE 52767
// break ;
52765: GO 52877
// x := GetX ( ape ) ;
52767: LD_ADDR_VAR 0 4
52771: PUSH
52772: LD_VAR 0 6
52776: PPUSH
52777: CALL_OW 250
52781: ST_TO_ADDR
// y := GetY ( ape ) ;
52782: LD_ADDR_VAR 0 5
52786: PUSH
52787: LD_VAR 0 6
52791: PPUSH
52792: CALL_OW 251
52796: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52797: LD_VAR 0 4
52801: PPUSH
52802: LD_VAR 0 5
52806: PPUSH
52807: CALL_OW 488
52811: NOT
52812: PUSH
52813: LD_VAR 0 11
52817: PPUSH
52818: LD_VAR 0 4
52822: PPUSH
52823: LD_VAR 0 5
52827: PPUSH
52828: LD_INT 20
52830: PPUSH
52831: CALL 71257 0 4
52835: PUSH
52836: LD_INT 4
52838: ARRAY
52839: OR
52840: IFFALSE 52844
// break ;
52842: GO 52877
// if not HasTask ( j ) then
52844: LD_VAR 0 3
52848: PPUSH
52849: CALL_OW 314
52853: NOT
52854: IFFALSE 52875
// ComTameXY ( j , x , y ) ;
52856: LD_VAR 0 3
52860: PPUSH
52861: LD_VAR 0 4
52865: PPUSH
52866: LD_VAR 0 5
52870: PPUSH
52871: CALL_OW 131
// end ; end ;
52875: GO 52540
52877: POP
52878: POP
// end ;
52879: GO 52096
52881: POP
52882: POP
// end ;
52883: LD_VAR 0 1
52887: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52888: LD_INT 0
52890: PPUSH
52891: PPUSH
52892: PPUSH
52893: PPUSH
52894: PPUSH
52895: PPUSH
52896: PPUSH
52897: PPUSH
// if not mc_bases then
52898: LD_EXP 99
52902: NOT
52903: IFFALSE 52907
// exit ;
52905: GO 53533
// for i = 1 to mc_bases do
52907: LD_ADDR_VAR 0 2
52911: PUSH
52912: DOUBLE
52913: LD_INT 1
52915: DEC
52916: ST_TO_ADDR
52917: LD_EXP 99
52921: PUSH
52922: FOR_TO
52923: IFFALSE 53531
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52925: LD_EXP 128
52929: PUSH
52930: LD_VAR 0 2
52934: ARRAY
52935: NOT
52936: PUSH
52937: LD_EXP 128
52941: PUSH
52942: LD_VAR 0 2
52946: ARRAY
52947: PPUSH
52948: LD_INT 25
52950: PUSH
52951: LD_INT 12
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: PPUSH
52958: CALL_OW 72
52962: NOT
52963: OR
52964: IFFALSE 52968
// continue ;
52966: GO 52922
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52968: LD_ADDR_VAR 0 5
52972: PUSH
52973: LD_EXP 128
52977: PUSH
52978: LD_VAR 0 2
52982: ARRAY
52983: PUSH
52984: LD_INT 1
52986: ARRAY
52987: PPUSH
52988: CALL_OW 255
52992: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52993: LD_VAR 0 5
52997: PPUSH
52998: LD_INT 2
53000: PPUSH
53001: CALL_OW 325
53005: IFFALSE 53258
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53007: LD_ADDR_VAR 0 4
53011: PUSH
53012: LD_EXP 128
53016: PUSH
53017: LD_VAR 0 2
53021: ARRAY
53022: PPUSH
53023: LD_INT 25
53025: PUSH
53026: LD_INT 16
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: PPUSH
53033: CALL_OW 72
53037: ST_TO_ADDR
// if tmp < 6 then
53038: LD_VAR 0 4
53042: PUSH
53043: LD_INT 6
53045: LESS
53046: IFFALSE 53258
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53048: LD_ADDR_VAR 0 6
53052: PUSH
53053: LD_EXP 99
53057: PUSH
53058: LD_VAR 0 2
53062: ARRAY
53063: PPUSH
53064: LD_INT 2
53066: PUSH
53067: LD_INT 30
53069: PUSH
53070: LD_INT 0
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PUSH
53077: LD_INT 30
53079: PUSH
53080: LD_INT 1
53082: PUSH
53083: EMPTY
53084: LIST
53085: LIST
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: LIST
53091: PPUSH
53092: CALL_OW 72
53096: ST_TO_ADDR
// if depot then
53097: LD_VAR 0 6
53101: IFFALSE 53258
// begin selected := 0 ;
53103: LD_ADDR_VAR 0 7
53107: PUSH
53108: LD_INT 0
53110: ST_TO_ADDR
// for j in depot do
53111: LD_ADDR_VAR 0 3
53115: PUSH
53116: LD_VAR 0 6
53120: PUSH
53121: FOR_IN
53122: IFFALSE 53153
// begin if UnitsInside ( j ) < 6 then
53124: LD_VAR 0 3
53128: PPUSH
53129: CALL_OW 313
53133: PUSH
53134: LD_INT 6
53136: LESS
53137: IFFALSE 53151
// begin selected := j ;
53139: LD_ADDR_VAR 0 7
53143: PUSH
53144: LD_VAR 0 3
53148: ST_TO_ADDR
// break ;
53149: GO 53153
// end ; end ;
53151: GO 53121
53153: POP
53154: POP
// if selected then
53155: LD_VAR 0 7
53159: IFFALSE 53258
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53161: LD_ADDR_VAR 0 3
53165: PUSH
53166: LD_EXP 128
53170: PUSH
53171: LD_VAR 0 2
53175: ARRAY
53176: PPUSH
53177: LD_INT 25
53179: PUSH
53180: LD_INT 12
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PPUSH
53187: CALL_OW 72
53191: PUSH
53192: FOR_IN
53193: IFFALSE 53256
// if not HasTask ( j ) then
53195: LD_VAR 0 3
53199: PPUSH
53200: CALL_OW 314
53204: NOT
53205: IFFALSE 53254
// begin if not IsInUnit ( j ) then
53207: LD_VAR 0 3
53211: PPUSH
53212: CALL_OW 310
53216: NOT
53217: IFFALSE 53233
// ComEnterUnit ( j , selected ) ;
53219: LD_VAR 0 3
53223: PPUSH
53224: LD_VAR 0 7
53228: PPUSH
53229: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53233: LD_VAR 0 3
53237: PPUSH
53238: LD_INT 16
53240: PPUSH
53241: CALL_OW 183
// AddComExitBuilding ( j ) ;
53245: LD_VAR 0 3
53249: PPUSH
53250: CALL_OW 182
// end ;
53254: GO 53192
53256: POP
53257: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53258: LD_VAR 0 5
53262: PPUSH
53263: LD_INT 11
53265: PPUSH
53266: CALL_OW 325
53270: IFFALSE 53529
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53272: LD_ADDR_VAR 0 4
53276: PUSH
53277: LD_EXP 128
53281: PUSH
53282: LD_VAR 0 2
53286: ARRAY
53287: PPUSH
53288: LD_INT 25
53290: PUSH
53291: LD_INT 16
53293: PUSH
53294: EMPTY
53295: LIST
53296: LIST
53297: PPUSH
53298: CALL_OW 72
53302: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53303: LD_VAR 0 4
53307: PUSH
53308: LD_INT 6
53310: GREATEREQUAL
53311: PUSH
53312: LD_VAR 0 5
53316: PPUSH
53317: LD_INT 2
53319: PPUSH
53320: CALL_OW 325
53324: NOT
53325: OR
53326: IFFALSE 53529
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53328: LD_ADDR_VAR 0 8
53332: PUSH
53333: LD_EXP 99
53337: PUSH
53338: LD_VAR 0 2
53342: ARRAY
53343: PPUSH
53344: LD_INT 2
53346: PUSH
53347: LD_INT 30
53349: PUSH
53350: LD_INT 4
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: PUSH
53357: LD_INT 30
53359: PUSH
53360: LD_INT 5
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: LIST
53371: PPUSH
53372: CALL_OW 72
53376: ST_TO_ADDR
// if barracks then
53377: LD_VAR 0 8
53381: IFFALSE 53529
// begin selected := 0 ;
53383: LD_ADDR_VAR 0 7
53387: PUSH
53388: LD_INT 0
53390: ST_TO_ADDR
// for j in barracks do
53391: LD_ADDR_VAR 0 3
53395: PUSH
53396: LD_VAR 0 8
53400: PUSH
53401: FOR_IN
53402: IFFALSE 53433
// begin if UnitsInside ( j ) < 6 then
53404: LD_VAR 0 3
53408: PPUSH
53409: CALL_OW 313
53413: PUSH
53414: LD_INT 6
53416: LESS
53417: IFFALSE 53431
// begin selected := j ;
53419: LD_ADDR_VAR 0 7
53423: PUSH
53424: LD_VAR 0 3
53428: ST_TO_ADDR
// break ;
53429: GO 53433
// end ; end ;
53431: GO 53401
53433: POP
53434: POP
// if selected then
53435: LD_VAR 0 7
53439: IFFALSE 53529
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53441: LD_ADDR_VAR 0 3
53445: PUSH
53446: LD_EXP 128
53450: PUSH
53451: LD_VAR 0 2
53455: ARRAY
53456: PPUSH
53457: LD_INT 25
53459: PUSH
53460: LD_INT 12
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: PPUSH
53467: CALL_OW 72
53471: PUSH
53472: FOR_IN
53473: IFFALSE 53527
// if not IsInUnit ( j ) and not HasTask ( j ) then
53475: LD_VAR 0 3
53479: PPUSH
53480: CALL_OW 310
53484: NOT
53485: PUSH
53486: LD_VAR 0 3
53490: PPUSH
53491: CALL_OW 314
53495: NOT
53496: AND
53497: IFFALSE 53525
// begin ComEnterUnit ( j , selected ) ;
53499: LD_VAR 0 3
53503: PPUSH
53504: LD_VAR 0 7
53508: PPUSH
53509: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53513: LD_VAR 0 3
53517: PPUSH
53518: LD_INT 15
53520: PPUSH
53521: CALL_OW 183
// end ;
53525: GO 53472
53527: POP
53528: POP
// end ; end ; end ; end ; end ;
53529: GO 52922
53531: POP
53532: POP
// end ;
53533: LD_VAR 0 1
53537: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53538: LD_INT 0
53540: PPUSH
53541: PPUSH
53542: PPUSH
53543: PPUSH
// if not mc_bases then
53544: LD_EXP 99
53548: NOT
53549: IFFALSE 53553
// exit ;
53551: GO 53731
// for i = 1 to mc_bases do
53553: LD_ADDR_VAR 0 2
53557: PUSH
53558: DOUBLE
53559: LD_INT 1
53561: DEC
53562: ST_TO_ADDR
53563: LD_EXP 99
53567: PUSH
53568: FOR_TO
53569: IFFALSE 53729
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53571: LD_ADDR_VAR 0 4
53575: PUSH
53576: LD_EXP 99
53580: PUSH
53581: LD_VAR 0 2
53585: ARRAY
53586: PPUSH
53587: LD_INT 25
53589: PUSH
53590: LD_INT 9
53592: PUSH
53593: EMPTY
53594: LIST
53595: LIST
53596: PPUSH
53597: CALL_OW 72
53601: ST_TO_ADDR
// if not tmp then
53602: LD_VAR 0 4
53606: NOT
53607: IFFALSE 53611
// continue ;
53609: GO 53568
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53611: LD_EXP 125
53615: PUSH
53616: LD_VAR 0 2
53620: ARRAY
53621: PPUSH
53622: LD_INT 29
53624: PPUSH
53625: CALL_OW 325
53629: NOT
53630: PUSH
53631: LD_EXP 125
53635: PUSH
53636: LD_VAR 0 2
53640: ARRAY
53641: PPUSH
53642: LD_INT 28
53644: PPUSH
53645: CALL_OW 325
53649: NOT
53650: AND
53651: IFFALSE 53655
// continue ;
53653: GO 53568
// for j in tmp do
53655: LD_ADDR_VAR 0 3
53659: PUSH
53660: LD_VAR 0 4
53664: PUSH
53665: FOR_IN
53666: IFFALSE 53725
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53668: LD_VAR 0 3
53672: PUSH
53673: LD_EXP 102
53677: PUSH
53678: LD_VAR 0 2
53682: ARRAY
53683: PUSH
53684: LD_INT 1
53686: ARRAY
53687: IN
53688: NOT
53689: PUSH
53690: LD_VAR 0 3
53694: PUSH
53695: LD_EXP 102
53699: PUSH
53700: LD_VAR 0 2
53704: ARRAY
53705: PUSH
53706: LD_INT 2
53708: ARRAY
53709: IN
53710: NOT
53711: AND
53712: IFFALSE 53723
// ComSpaceTimeShoot ( j ) ;
53714: LD_VAR 0 3
53718: PPUSH
53719: CALL 64311 0 1
53723: GO 53665
53725: POP
53726: POP
// end ;
53727: GO 53568
53729: POP
53730: POP
// end ;
53731: LD_VAR 0 1
53735: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53736: LD_INT 0
53738: PPUSH
53739: PPUSH
53740: PPUSH
53741: PPUSH
53742: PPUSH
53743: PPUSH
53744: PPUSH
53745: PPUSH
53746: PPUSH
// if not mc_bases then
53747: LD_EXP 99
53751: NOT
53752: IFFALSE 53756
// exit ;
53754: GO 54378
// for i = 1 to mc_bases do
53756: LD_ADDR_VAR 0 2
53760: PUSH
53761: DOUBLE
53762: LD_INT 1
53764: DEC
53765: ST_TO_ADDR
53766: LD_EXP 99
53770: PUSH
53771: FOR_TO
53772: IFFALSE 54376
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53774: LD_EXP 134
53778: PUSH
53779: LD_VAR 0 2
53783: ARRAY
53784: NOT
53785: PUSH
53786: LD_INT 38
53788: PPUSH
53789: LD_EXP 125
53793: PUSH
53794: LD_VAR 0 2
53798: ARRAY
53799: PPUSH
53800: CALL_OW 321
53804: PUSH
53805: LD_INT 2
53807: NONEQUAL
53808: OR
53809: IFFALSE 53813
// continue ;
53811: GO 53771
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53813: LD_ADDR_VAR 0 8
53817: PUSH
53818: LD_EXP 99
53822: PUSH
53823: LD_VAR 0 2
53827: ARRAY
53828: PPUSH
53829: LD_INT 30
53831: PUSH
53832: LD_INT 34
53834: PUSH
53835: EMPTY
53836: LIST
53837: LIST
53838: PPUSH
53839: CALL_OW 72
53843: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53844: LD_ADDR_VAR 0 9
53848: PUSH
53849: LD_EXP 99
53853: PUSH
53854: LD_VAR 0 2
53858: ARRAY
53859: PPUSH
53860: LD_INT 25
53862: PUSH
53863: LD_INT 4
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: PPUSH
53870: CALL_OW 72
53874: PPUSH
53875: LD_INT 0
53877: PPUSH
53878: CALL 103621 0 2
53882: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53883: LD_VAR 0 9
53887: NOT
53888: PUSH
53889: LD_VAR 0 8
53893: NOT
53894: OR
53895: PUSH
53896: LD_EXP 99
53900: PUSH
53901: LD_VAR 0 2
53905: ARRAY
53906: PPUSH
53907: LD_INT 124
53909: PPUSH
53910: CALL 103621 0 2
53914: OR
53915: IFFALSE 53919
// continue ;
53917: GO 53771
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53919: LD_EXP 135
53923: PUSH
53924: LD_VAR 0 2
53928: ARRAY
53929: PUSH
53930: LD_EXP 134
53934: PUSH
53935: LD_VAR 0 2
53939: ARRAY
53940: LESS
53941: PUSH
53942: LD_EXP 135
53946: PUSH
53947: LD_VAR 0 2
53951: ARRAY
53952: PUSH
53953: LD_VAR 0 8
53957: LESS
53958: AND
53959: IFFALSE 54374
// begin tmp := sci [ 1 ] ;
53961: LD_ADDR_VAR 0 7
53965: PUSH
53966: LD_VAR 0 9
53970: PUSH
53971: LD_INT 1
53973: ARRAY
53974: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53975: LD_VAR 0 7
53979: PPUSH
53980: LD_INT 124
53982: PPUSH
53983: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53987: LD_ADDR_VAR 0 3
53991: PUSH
53992: DOUBLE
53993: LD_EXP 134
53997: PUSH
53998: LD_VAR 0 2
54002: ARRAY
54003: INC
54004: ST_TO_ADDR
54005: LD_EXP 134
54009: PUSH
54010: LD_VAR 0 2
54014: ARRAY
54015: PUSH
54016: FOR_DOWNTO
54017: IFFALSE 54360
// begin if IsInUnit ( tmp ) then
54019: LD_VAR 0 7
54023: PPUSH
54024: CALL_OW 310
54028: IFFALSE 54039
// ComExitBuilding ( tmp ) ;
54030: LD_VAR 0 7
54034: PPUSH
54035: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54039: LD_INT 35
54041: PPUSH
54042: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54046: LD_VAR 0 7
54050: PPUSH
54051: CALL_OW 310
54055: NOT
54056: PUSH
54057: LD_VAR 0 7
54061: PPUSH
54062: CALL_OW 314
54066: NOT
54067: AND
54068: IFFALSE 54039
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54070: LD_ADDR_VAR 0 6
54074: PUSH
54075: LD_VAR 0 7
54079: PPUSH
54080: CALL_OW 250
54084: PUSH
54085: LD_VAR 0 7
54089: PPUSH
54090: CALL_OW 251
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54099: LD_INT 35
54101: PPUSH
54102: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54106: LD_ADDR_VAR 0 4
54110: PUSH
54111: LD_EXP 134
54115: PUSH
54116: LD_VAR 0 2
54120: ARRAY
54121: PUSH
54122: LD_VAR 0 3
54126: ARRAY
54127: PUSH
54128: LD_INT 1
54130: ARRAY
54131: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54132: LD_ADDR_VAR 0 5
54136: PUSH
54137: LD_EXP 134
54141: PUSH
54142: LD_VAR 0 2
54146: ARRAY
54147: PUSH
54148: LD_VAR 0 3
54152: ARRAY
54153: PUSH
54154: LD_INT 2
54156: ARRAY
54157: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54158: LD_VAR 0 7
54162: PPUSH
54163: LD_INT 10
54165: PPUSH
54166: CALL 72954 0 2
54170: PUSH
54171: LD_INT 4
54173: ARRAY
54174: IFFALSE 54212
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54176: LD_VAR 0 7
54180: PPUSH
54181: LD_VAR 0 6
54185: PUSH
54186: LD_INT 1
54188: ARRAY
54189: PPUSH
54190: LD_VAR 0 6
54194: PUSH
54195: LD_INT 2
54197: ARRAY
54198: PPUSH
54199: CALL_OW 111
// wait ( 0 0$10 ) ;
54203: LD_INT 350
54205: PPUSH
54206: CALL_OW 67
// end else
54210: GO 54238
// begin ComMoveXY ( tmp , x , y ) ;
54212: LD_VAR 0 7
54216: PPUSH
54217: LD_VAR 0 4
54221: PPUSH
54222: LD_VAR 0 5
54226: PPUSH
54227: CALL_OW 111
// wait ( 0 0$3 ) ;
54231: LD_INT 105
54233: PPUSH
54234: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54238: LD_VAR 0 7
54242: PPUSH
54243: LD_VAR 0 4
54247: PPUSH
54248: LD_VAR 0 5
54252: PPUSH
54253: CALL_OW 307
54257: IFFALSE 54099
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54259: LD_VAR 0 7
54263: PPUSH
54264: LD_VAR 0 4
54268: PPUSH
54269: LD_VAR 0 5
54273: PPUSH
54274: LD_VAR 0 8
54278: PUSH
54279: LD_VAR 0 3
54283: ARRAY
54284: PPUSH
54285: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54289: LD_INT 35
54291: PPUSH
54292: CALL_OW 67
// until not HasTask ( tmp ) ;
54296: LD_VAR 0 7
54300: PPUSH
54301: CALL_OW 314
54305: NOT
54306: IFFALSE 54289
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54308: LD_ADDR_EXP 135
54312: PUSH
54313: LD_EXP 135
54317: PPUSH
54318: LD_VAR 0 2
54322: PUSH
54323: LD_EXP 135
54327: PUSH
54328: LD_VAR 0 2
54332: ARRAY
54333: PUSH
54334: LD_INT 1
54336: PLUS
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: PPUSH
54342: LD_VAR 0 8
54346: PUSH
54347: LD_VAR 0 3
54351: ARRAY
54352: PPUSH
54353: CALL 70361 0 3
54357: ST_TO_ADDR
// end ;
54358: GO 54016
54360: POP
54361: POP
// MC_Reset ( i , 124 ) ;
54362: LD_VAR 0 2
54366: PPUSH
54367: LD_INT 124
54369: PPUSH
54370: CALL 37861 0 2
// end ; end ;
54374: GO 53771
54376: POP
54377: POP
// end ;
54378: LD_VAR 0 1
54382: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54383: LD_INT 0
54385: PPUSH
54386: PPUSH
54387: PPUSH
// if not mc_bases then
54388: LD_EXP 99
54392: NOT
54393: IFFALSE 54397
// exit ;
54395: GO 55003
// for i = 1 to mc_bases do
54397: LD_ADDR_VAR 0 2
54401: PUSH
54402: DOUBLE
54403: LD_INT 1
54405: DEC
54406: ST_TO_ADDR
54407: LD_EXP 99
54411: PUSH
54412: FOR_TO
54413: IFFALSE 55001
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54415: LD_ADDR_VAR 0 3
54419: PUSH
54420: LD_EXP 99
54424: PUSH
54425: LD_VAR 0 2
54429: ARRAY
54430: PPUSH
54431: LD_INT 25
54433: PUSH
54434: LD_INT 4
54436: PUSH
54437: EMPTY
54438: LIST
54439: LIST
54440: PPUSH
54441: CALL_OW 72
54445: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54446: LD_VAR 0 3
54450: NOT
54451: PUSH
54452: LD_EXP 136
54456: PUSH
54457: LD_VAR 0 2
54461: ARRAY
54462: NOT
54463: OR
54464: PUSH
54465: LD_EXP 99
54469: PUSH
54470: LD_VAR 0 2
54474: ARRAY
54475: PPUSH
54476: LD_INT 2
54478: PUSH
54479: LD_INT 30
54481: PUSH
54482: LD_INT 0
54484: PUSH
54485: EMPTY
54486: LIST
54487: LIST
54488: PUSH
54489: LD_INT 30
54491: PUSH
54492: LD_INT 1
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: PUSH
54499: EMPTY
54500: LIST
54501: LIST
54502: LIST
54503: PPUSH
54504: CALL_OW 72
54508: NOT
54509: OR
54510: IFFALSE 54560
// begin if mc_deposits_finder [ i ] then
54512: LD_EXP 137
54516: PUSH
54517: LD_VAR 0 2
54521: ARRAY
54522: IFFALSE 54558
// begin MC_Reset ( i , 125 ) ;
54524: LD_VAR 0 2
54528: PPUSH
54529: LD_INT 125
54531: PPUSH
54532: CALL 37861 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54536: LD_ADDR_EXP 137
54540: PUSH
54541: LD_EXP 137
54545: PPUSH
54546: LD_VAR 0 2
54550: PPUSH
54551: EMPTY
54552: PPUSH
54553: CALL_OW 1
54557: ST_TO_ADDR
// end ; continue ;
54558: GO 54412
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54560: LD_EXP 136
54564: PUSH
54565: LD_VAR 0 2
54569: ARRAY
54570: PUSH
54571: LD_INT 1
54573: ARRAY
54574: PUSH
54575: LD_INT 3
54577: ARRAY
54578: PUSH
54579: LD_INT 1
54581: EQUAL
54582: PUSH
54583: LD_INT 20
54585: PPUSH
54586: LD_EXP 125
54590: PUSH
54591: LD_VAR 0 2
54595: ARRAY
54596: PPUSH
54597: CALL_OW 321
54601: PUSH
54602: LD_INT 2
54604: NONEQUAL
54605: AND
54606: IFFALSE 54656
// begin if mc_deposits_finder [ i ] then
54608: LD_EXP 137
54612: PUSH
54613: LD_VAR 0 2
54617: ARRAY
54618: IFFALSE 54654
// begin MC_Reset ( i , 125 ) ;
54620: LD_VAR 0 2
54624: PPUSH
54625: LD_INT 125
54627: PPUSH
54628: CALL 37861 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54632: LD_ADDR_EXP 137
54636: PUSH
54637: LD_EXP 137
54641: PPUSH
54642: LD_VAR 0 2
54646: PPUSH
54647: EMPTY
54648: PPUSH
54649: CALL_OW 1
54653: ST_TO_ADDR
// end ; continue ;
54654: GO 54412
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54656: LD_EXP 136
54660: PUSH
54661: LD_VAR 0 2
54665: ARRAY
54666: PUSH
54667: LD_INT 1
54669: ARRAY
54670: PUSH
54671: LD_INT 1
54673: ARRAY
54674: PPUSH
54675: LD_EXP 136
54679: PUSH
54680: LD_VAR 0 2
54684: ARRAY
54685: PUSH
54686: LD_INT 1
54688: ARRAY
54689: PUSH
54690: LD_INT 2
54692: ARRAY
54693: PPUSH
54694: LD_EXP 125
54698: PUSH
54699: LD_VAR 0 2
54703: ARRAY
54704: PPUSH
54705: CALL_OW 440
54709: IFFALSE 54752
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54711: LD_ADDR_EXP 136
54715: PUSH
54716: LD_EXP 136
54720: PPUSH
54721: LD_VAR 0 2
54725: PPUSH
54726: LD_EXP 136
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PPUSH
54737: LD_INT 1
54739: PPUSH
54740: CALL_OW 3
54744: PPUSH
54745: CALL_OW 1
54749: ST_TO_ADDR
54750: GO 54999
// begin if not mc_deposits_finder [ i ] then
54752: LD_EXP 137
54756: PUSH
54757: LD_VAR 0 2
54761: ARRAY
54762: NOT
54763: IFFALSE 54815
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54765: LD_ADDR_EXP 137
54769: PUSH
54770: LD_EXP 137
54774: PPUSH
54775: LD_VAR 0 2
54779: PPUSH
54780: LD_VAR 0 3
54784: PUSH
54785: LD_INT 1
54787: ARRAY
54788: PUSH
54789: EMPTY
54790: LIST
54791: PPUSH
54792: CALL_OW 1
54796: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54797: LD_VAR 0 3
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PPUSH
54806: LD_INT 125
54808: PPUSH
54809: CALL_OW 109
// end else
54813: GO 54999
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54815: LD_EXP 137
54819: PUSH
54820: LD_VAR 0 2
54824: ARRAY
54825: PUSH
54826: LD_INT 1
54828: ARRAY
54829: PPUSH
54830: CALL_OW 310
54834: IFFALSE 54857
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54836: LD_EXP 137
54840: PUSH
54841: LD_VAR 0 2
54845: ARRAY
54846: PUSH
54847: LD_INT 1
54849: ARRAY
54850: PPUSH
54851: CALL_OW 122
54855: GO 54999
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54857: LD_EXP 137
54861: PUSH
54862: LD_VAR 0 2
54866: ARRAY
54867: PUSH
54868: LD_INT 1
54870: ARRAY
54871: PPUSH
54872: CALL_OW 314
54876: NOT
54877: PUSH
54878: LD_EXP 137
54882: PUSH
54883: LD_VAR 0 2
54887: ARRAY
54888: PUSH
54889: LD_INT 1
54891: ARRAY
54892: PPUSH
54893: LD_EXP 136
54897: PUSH
54898: LD_VAR 0 2
54902: ARRAY
54903: PUSH
54904: LD_INT 1
54906: ARRAY
54907: PUSH
54908: LD_INT 1
54910: ARRAY
54911: PPUSH
54912: LD_EXP 136
54916: PUSH
54917: LD_VAR 0 2
54921: ARRAY
54922: PUSH
54923: LD_INT 1
54925: ARRAY
54926: PUSH
54927: LD_INT 2
54929: ARRAY
54930: PPUSH
54931: CALL_OW 297
54935: PUSH
54936: LD_INT 6
54938: GREATER
54939: AND
54940: IFFALSE 54999
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54942: LD_EXP 137
54946: PUSH
54947: LD_VAR 0 2
54951: ARRAY
54952: PUSH
54953: LD_INT 1
54955: ARRAY
54956: PPUSH
54957: LD_EXP 136
54961: PUSH
54962: LD_VAR 0 2
54966: ARRAY
54967: PUSH
54968: LD_INT 1
54970: ARRAY
54971: PUSH
54972: LD_INT 1
54974: ARRAY
54975: PPUSH
54976: LD_EXP 136
54980: PUSH
54981: LD_VAR 0 2
54985: ARRAY
54986: PUSH
54987: LD_INT 1
54989: ARRAY
54990: PUSH
54991: LD_INT 2
54993: ARRAY
54994: PPUSH
54995: CALL_OW 111
// end ; end ; end ;
54999: GO 54412
55001: POP
55002: POP
// end ;
55003: LD_VAR 0 1
55007: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55008: LD_INT 0
55010: PPUSH
55011: PPUSH
55012: PPUSH
55013: PPUSH
55014: PPUSH
55015: PPUSH
55016: PPUSH
55017: PPUSH
55018: PPUSH
55019: PPUSH
55020: PPUSH
// if not mc_bases then
55021: LD_EXP 99
55025: NOT
55026: IFFALSE 55030
// exit ;
55028: GO 55754
// for i = 1 to mc_bases do
55030: LD_ADDR_VAR 0 2
55034: PUSH
55035: DOUBLE
55036: LD_INT 1
55038: DEC
55039: ST_TO_ADDR
55040: LD_EXP 99
55044: PUSH
55045: FOR_TO
55046: IFFALSE 55752
// begin if not mc_bases [ i ] then
55048: LD_EXP 99
55052: PUSH
55053: LD_VAR 0 2
55057: ARRAY
55058: NOT
55059: IFFALSE 55063
// continue ;
55061: GO 55045
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55063: LD_ADDR_VAR 0 7
55067: PUSH
55068: LD_EXP 99
55072: PUSH
55073: LD_VAR 0 2
55077: ARRAY
55078: PUSH
55079: LD_INT 1
55081: ARRAY
55082: PPUSH
55083: CALL_OW 248
55087: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55088: LD_VAR 0 7
55092: PUSH
55093: LD_INT 3
55095: EQUAL
55096: PUSH
55097: LD_EXP 118
55101: PUSH
55102: LD_VAR 0 2
55106: ARRAY
55107: PUSH
55108: LD_EXP 121
55112: PUSH
55113: LD_VAR 0 2
55117: ARRAY
55118: UNION
55119: PPUSH
55120: LD_INT 33
55122: PUSH
55123: LD_INT 2
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: PPUSH
55130: CALL_OW 72
55134: NOT
55135: OR
55136: IFFALSE 55140
// continue ;
55138: GO 55045
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55140: LD_ADDR_VAR 0 9
55144: PUSH
55145: LD_EXP 99
55149: PUSH
55150: LD_VAR 0 2
55154: ARRAY
55155: PPUSH
55156: LD_INT 30
55158: PUSH
55159: LD_INT 36
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: PPUSH
55166: CALL_OW 72
55170: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55171: LD_ADDR_VAR 0 10
55175: PUSH
55176: LD_EXP 118
55180: PUSH
55181: LD_VAR 0 2
55185: ARRAY
55186: PPUSH
55187: LD_INT 34
55189: PUSH
55190: LD_INT 31
55192: PUSH
55193: EMPTY
55194: LIST
55195: LIST
55196: PPUSH
55197: CALL_OW 72
55201: ST_TO_ADDR
// if not cts and not mcts then
55202: LD_VAR 0 9
55206: NOT
55207: PUSH
55208: LD_VAR 0 10
55212: NOT
55213: AND
55214: IFFALSE 55218
// continue ;
55216: GO 55045
// x := cts ;
55218: LD_ADDR_VAR 0 11
55222: PUSH
55223: LD_VAR 0 9
55227: ST_TO_ADDR
// if not x then
55228: LD_VAR 0 11
55232: NOT
55233: IFFALSE 55245
// x := mcts ;
55235: LD_ADDR_VAR 0 11
55239: PUSH
55240: LD_VAR 0 10
55244: ST_TO_ADDR
// if mc_remote_driver [ i ] then
55245: LD_EXP 139
55249: PUSH
55250: LD_VAR 0 2
55254: ARRAY
55255: IFFALSE 55524
// for j in mc_remote_driver [ i ] do
55257: LD_ADDR_VAR 0 3
55261: PUSH
55262: LD_EXP 139
55266: PUSH
55267: LD_VAR 0 2
55271: ARRAY
55272: PUSH
55273: FOR_IN
55274: IFFALSE 55522
// begin if GetClass ( j ) <> 3 then
55276: LD_VAR 0 3
55280: PPUSH
55281: CALL_OW 257
55285: PUSH
55286: LD_INT 3
55288: NONEQUAL
55289: IFFALSE 55342
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55291: LD_ADDR_EXP 139
55295: PUSH
55296: LD_EXP 139
55300: PPUSH
55301: LD_VAR 0 2
55305: PPUSH
55306: LD_EXP 139
55310: PUSH
55311: LD_VAR 0 2
55315: ARRAY
55316: PUSH
55317: LD_VAR 0 3
55321: DIFF
55322: PPUSH
55323: CALL_OW 1
55327: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55328: LD_VAR 0 3
55332: PPUSH
55333: LD_INT 0
55335: PPUSH
55336: CALL_OW 109
// continue ;
55340: GO 55273
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55342: LD_VAR 0 3
55346: PPUSH
55347: CALL_OW 310
55351: NOT
55352: PUSH
55353: LD_VAR 0 3
55357: PPUSH
55358: CALL_OW 310
55362: PPUSH
55363: CALL_OW 266
55367: PUSH
55368: LD_INT 36
55370: NONEQUAL
55371: PUSH
55372: LD_VAR 0 3
55376: PPUSH
55377: CALL 103709 0 1
55381: NOT
55382: AND
55383: OR
55384: IFFALSE 55520
// begin if IsInUnit ( j ) then
55386: LD_VAR 0 3
55390: PPUSH
55391: CALL_OW 310
55395: IFFALSE 55406
// ComExitBuilding ( j ) ;
55397: LD_VAR 0 3
55401: PPUSH
55402: CALL_OW 122
// ct := 0 ;
55406: LD_ADDR_VAR 0 8
55410: PUSH
55411: LD_INT 0
55413: ST_TO_ADDR
// for k in x do
55414: LD_ADDR_VAR 0 4
55418: PUSH
55419: LD_VAR 0 11
55423: PUSH
55424: FOR_IN
55425: IFFALSE 55498
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55427: LD_VAR 0 4
55431: PPUSH
55432: CALL_OW 264
55436: PUSH
55437: LD_INT 31
55439: EQUAL
55440: PUSH
55441: LD_VAR 0 4
55445: PPUSH
55446: CALL_OW 311
55450: NOT
55451: AND
55452: PUSH
55453: LD_VAR 0 4
55457: PPUSH
55458: CALL_OW 266
55462: PUSH
55463: LD_INT 36
55465: EQUAL
55466: PUSH
55467: LD_VAR 0 4
55471: PPUSH
55472: CALL_OW 313
55476: PUSH
55477: LD_INT 3
55479: LESS
55480: AND
55481: OR
55482: IFFALSE 55496
// begin ct := k ;
55484: LD_ADDR_VAR 0 8
55488: PUSH
55489: LD_VAR 0 4
55493: ST_TO_ADDR
// break ;
55494: GO 55498
// end ;
55496: GO 55424
55498: POP
55499: POP
// if ct then
55500: LD_VAR 0 8
55504: IFFALSE 55520
// ComEnterUnit ( j , ct ) ;
55506: LD_VAR 0 3
55510: PPUSH
55511: LD_VAR 0 8
55515: PPUSH
55516: CALL_OW 120
// end ; end ;
55520: GO 55273
55522: POP
55523: POP
// places := 0 ;
55524: LD_ADDR_VAR 0 5
55528: PUSH
55529: LD_INT 0
55531: ST_TO_ADDR
// for j = 1 to x do
55532: LD_ADDR_VAR 0 3
55536: PUSH
55537: DOUBLE
55538: LD_INT 1
55540: DEC
55541: ST_TO_ADDR
55542: LD_VAR 0 11
55546: PUSH
55547: FOR_TO
55548: IFFALSE 55603
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55550: LD_VAR 0 11
55554: PUSH
55555: LD_VAR 0 3
55559: ARRAY
55560: PPUSH
55561: CALL_OW 264
55565: PUSH
55566: LD_INT 31
55568: EQUAL
55569: IFFALSE 55587
// places := places + 1 else
55571: LD_ADDR_VAR 0 5
55575: PUSH
55576: LD_VAR 0 5
55580: PUSH
55581: LD_INT 1
55583: PLUS
55584: ST_TO_ADDR
55585: GO 55601
// places := places + 3 ;
55587: LD_ADDR_VAR 0 5
55591: PUSH
55592: LD_VAR 0 5
55596: PUSH
55597: LD_INT 3
55599: PLUS
55600: ST_TO_ADDR
55601: GO 55547
55603: POP
55604: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55605: LD_ADDR_VAR 0 6
55609: PUSH
55610: LD_EXP 99
55614: PUSH
55615: LD_VAR 0 2
55619: ARRAY
55620: PPUSH
55621: LD_INT 25
55623: PUSH
55624: LD_INT 3
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: PPUSH
55631: CALL_OW 72
55635: PUSH
55636: LD_EXP 139
55640: PUSH
55641: LD_VAR 0 2
55645: ARRAY
55646: DIFF
55647: PPUSH
55648: LD_INT 3
55650: PPUSH
55651: CALL 104609 0 2
55655: ST_TO_ADDR
// if not tmp then
55656: LD_VAR 0 6
55660: NOT
55661: IFFALSE 55665
// continue ;
55663: GO 55045
// places := places - mc_remote_driver [ i ] ;
55665: LD_ADDR_VAR 0 5
55669: PUSH
55670: LD_VAR 0 5
55674: PUSH
55675: LD_EXP 139
55679: PUSH
55680: LD_VAR 0 2
55684: ARRAY
55685: MINUS
55686: ST_TO_ADDR
// if places then
55687: LD_VAR 0 5
55691: IFFALSE 55750
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55693: LD_ADDR_EXP 139
55697: PUSH
55698: LD_EXP 139
55702: PPUSH
55703: LD_VAR 0 2
55707: PPUSH
55708: LD_EXP 139
55712: PUSH
55713: LD_VAR 0 2
55717: ARRAY
55718: PUSH
55719: LD_VAR 0 6
55723: PUSH
55724: LD_INT 1
55726: ARRAY
55727: UNION
55728: PPUSH
55729: CALL_OW 1
55733: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55734: LD_VAR 0 6
55738: PUSH
55739: LD_INT 1
55741: ARRAY
55742: PPUSH
55743: LD_INT 126
55745: PPUSH
55746: CALL_OW 109
// end ; end ;
55750: GO 55045
55752: POP
55753: POP
// end ;
55754: LD_VAR 0 1
55758: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55759: LD_INT 0
55761: PPUSH
55762: PPUSH
55763: PPUSH
55764: PPUSH
55765: PPUSH
55766: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55767: LD_VAR 0 1
55771: NOT
55772: PUSH
55773: LD_VAR 0 2
55777: NOT
55778: OR
55779: PUSH
55780: LD_VAR 0 3
55784: NOT
55785: OR
55786: PUSH
55787: LD_VAR 0 4
55791: PUSH
55792: LD_INT 1
55794: PUSH
55795: LD_INT 2
55797: PUSH
55798: LD_INT 3
55800: PUSH
55801: LD_INT 4
55803: PUSH
55804: LD_INT 5
55806: PUSH
55807: LD_INT 8
55809: PUSH
55810: LD_INT 9
55812: PUSH
55813: LD_INT 15
55815: PUSH
55816: LD_INT 16
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: LIST
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: IN
55830: NOT
55831: OR
55832: IFFALSE 55836
// exit ;
55834: GO 56736
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55836: LD_ADDR_VAR 0 2
55840: PUSH
55841: LD_VAR 0 2
55845: PPUSH
55846: LD_INT 21
55848: PUSH
55849: LD_INT 3
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: PUSH
55856: LD_INT 24
55858: PUSH
55859: LD_INT 250
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: PUSH
55866: EMPTY
55867: LIST
55868: LIST
55869: PPUSH
55870: CALL_OW 72
55874: ST_TO_ADDR
// case class of 1 , 15 :
55875: LD_VAR 0 4
55879: PUSH
55880: LD_INT 1
55882: DOUBLE
55883: EQUAL
55884: IFTRUE 55894
55886: LD_INT 15
55888: DOUBLE
55889: EQUAL
55890: IFTRUE 55894
55892: GO 55979
55894: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55895: LD_ADDR_VAR 0 8
55899: PUSH
55900: LD_VAR 0 2
55904: PPUSH
55905: LD_INT 2
55907: PUSH
55908: LD_INT 30
55910: PUSH
55911: LD_INT 32
55913: PUSH
55914: EMPTY
55915: LIST
55916: LIST
55917: PUSH
55918: LD_INT 30
55920: PUSH
55921: LD_INT 31
55923: PUSH
55924: EMPTY
55925: LIST
55926: LIST
55927: PUSH
55928: EMPTY
55929: LIST
55930: LIST
55931: LIST
55932: PPUSH
55933: CALL_OW 72
55937: PUSH
55938: LD_VAR 0 2
55942: PPUSH
55943: LD_INT 2
55945: PUSH
55946: LD_INT 30
55948: PUSH
55949: LD_INT 4
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: PUSH
55956: LD_INT 30
55958: PUSH
55959: LD_INT 5
55961: PUSH
55962: EMPTY
55963: LIST
55964: LIST
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: LIST
55970: PPUSH
55971: CALL_OW 72
55975: ADD
55976: ST_TO_ADDR
55977: GO 56225
55979: LD_INT 2
55981: DOUBLE
55982: EQUAL
55983: IFTRUE 55993
55985: LD_INT 16
55987: DOUBLE
55988: EQUAL
55989: IFTRUE 55993
55991: GO 56039
55993: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55994: LD_ADDR_VAR 0 8
55998: PUSH
55999: LD_VAR 0 2
56003: PPUSH
56004: LD_INT 2
56006: PUSH
56007: LD_INT 30
56009: PUSH
56010: LD_INT 0
56012: PUSH
56013: EMPTY
56014: LIST
56015: LIST
56016: PUSH
56017: LD_INT 30
56019: PUSH
56020: LD_INT 1
56022: PUSH
56023: EMPTY
56024: LIST
56025: LIST
56026: PUSH
56027: EMPTY
56028: LIST
56029: LIST
56030: LIST
56031: PPUSH
56032: CALL_OW 72
56036: ST_TO_ADDR
56037: GO 56225
56039: LD_INT 3
56041: DOUBLE
56042: EQUAL
56043: IFTRUE 56047
56045: GO 56093
56047: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56048: LD_ADDR_VAR 0 8
56052: PUSH
56053: LD_VAR 0 2
56057: PPUSH
56058: LD_INT 2
56060: PUSH
56061: LD_INT 30
56063: PUSH
56064: LD_INT 2
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: PUSH
56071: LD_INT 30
56073: PUSH
56074: LD_INT 3
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: PPUSH
56086: CALL_OW 72
56090: ST_TO_ADDR
56091: GO 56225
56093: LD_INT 4
56095: DOUBLE
56096: EQUAL
56097: IFTRUE 56101
56099: GO 56158
56101: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56102: LD_ADDR_VAR 0 8
56106: PUSH
56107: LD_VAR 0 2
56111: PPUSH
56112: LD_INT 2
56114: PUSH
56115: LD_INT 30
56117: PUSH
56118: LD_INT 6
56120: PUSH
56121: EMPTY
56122: LIST
56123: LIST
56124: PUSH
56125: LD_INT 30
56127: PUSH
56128: LD_INT 7
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: PUSH
56135: LD_INT 30
56137: PUSH
56138: LD_INT 8
56140: PUSH
56141: EMPTY
56142: LIST
56143: LIST
56144: PUSH
56145: EMPTY
56146: LIST
56147: LIST
56148: LIST
56149: LIST
56150: PPUSH
56151: CALL_OW 72
56155: ST_TO_ADDR
56156: GO 56225
56158: LD_INT 5
56160: DOUBLE
56161: EQUAL
56162: IFTRUE 56178
56164: LD_INT 8
56166: DOUBLE
56167: EQUAL
56168: IFTRUE 56178
56170: LD_INT 9
56172: DOUBLE
56173: EQUAL
56174: IFTRUE 56178
56176: GO 56224
56178: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56179: LD_ADDR_VAR 0 8
56183: PUSH
56184: LD_VAR 0 2
56188: PPUSH
56189: LD_INT 2
56191: PUSH
56192: LD_INT 30
56194: PUSH
56195: LD_INT 4
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PUSH
56202: LD_INT 30
56204: PUSH
56205: LD_INT 5
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: LIST
56216: PPUSH
56217: CALL_OW 72
56221: ST_TO_ADDR
56222: GO 56225
56224: POP
// if not tmp then
56225: LD_VAR 0 8
56229: NOT
56230: IFFALSE 56234
// exit ;
56232: GO 56736
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56234: LD_VAR 0 4
56238: PUSH
56239: LD_INT 1
56241: PUSH
56242: LD_INT 15
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: IN
56249: PUSH
56250: LD_EXP 108
56254: PUSH
56255: LD_VAR 0 1
56259: ARRAY
56260: AND
56261: IFFALSE 56417
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56263: LD_ADDR_VAR 0 9
56267: PUSH
56268: LD_EXP 108
56272: PUSH
56273: LD_VAR 0 1
56277: ARRAY
56278: PUSH
56279: LD_INT 1
56281: ARRAY
56282: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56283: LD_VAR 0 9
56287: PUSH
56288: LD_EXP 109
56292: PUSH
56293: LD_VAR 0 1
56297: ARRAY
56298: IN
56299: NOT
56300: IFFALSE 56415
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56302: LD_ADDR_EXP 109
56306: PUSH
56307: LD_EXP 109
56311: PPUSH
56312: LD_VAR 0 1
56316: PUSH
56317: LD_EXP 109
56321: PUSH
56322: LD_VAR 0 1
56326: ARRAY
56327: PUSH
56328: LD_INT 1
56330: PLUS
56331: PUSH
56332: EMPTY
56333: LIST
56334: LIST
56335: PPUSH
56336: LD_VAR 0 9
56340: PPUSH
56341: CALL 70361 0 3
56345: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56346: LD_ADDR_EXP 108
56350: PUSH
56351: LD_EXP 108
56355: PPUSH
56356: LD_VAR 0 1
56360: PPUSH
56361: LD_EXP 108
56365: PUSH
56366: LD_VAR 0 1
56370: ARRAY
56371: PUSH
56372: LD_VAR 0 9
56376: DIFF
56377: PPUSH
56378: CALL_OW 1
56382: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56383: LD_VAR 0 3
56387: PPUSH
56388: LD_EXP 109
56392: PUSH
56393: LD_VAR 0 1
56397: ARRAY
56398: PUSH
56399: LD_EXP 109
56403: PUSH
56404: LD_VAR 0 1
56408: ARRAY
56409: ARRAY
56410: PPUSH
56411: CALL_OW 120
// end ; exit ;
56415: GO 56736
// end ; if tmp > 1 then
56417: LD_VAR 0 8
56421: PUSH
56422: LD_INT 1
56424: GREATER
56425: IFFALSE 56529
// for i = 2 to tmp do
56427: LD_ADDR_VAR 0 6
56431: PUSH
56432: DOUBLE
56433: LD_INT 2
56435: DEC
56436: ST_TO_ADDR
56437: LD_VAR 0 8
56441: PUSH
56442: FOR_TO
56443: IFFALSE 56527
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56445: LD_VAR 0 8
56449: PUSH
56450: LD_VAR 0 6
56454: ARRAY
56455: PPUSH
56456: CALL_OW 461
56460: PUSH
56461: LD_INT 6
56463: EQUAL
56464: IFFALSE 56525
// begin x := tmp [ i ] ;
56466: LD_ADDR_VAR 0 9
56470: PUSH
56471: LD_VAR 0 8
56475: PUSH
56476: LD_VAR 0 6
56480: ARRAY
56481: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56482: LD_ADDR_VAR 0 8
56486: PUSH
56487: LD_VAR 0 8
56491: PPUSH
56492: LD_VAR 0 6
56496: PPUSH
56497: CALL_OW 3
56501: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56502: LD_ADDR_VAR 0 8
56506: PUSH
56507: LD_VAR 0 8
56511: PPUSH
56512: LD_INT 1
56514: PPUSH
56515: LD_VAR 0 9
56519: PPUSH
56520: CALL_OW 2
56524: ST_TO_ADDR
// end ;
56525: GO 56442
56527: POP
56528: POP
// for i in tmp do
56529: LD_ADDR_VAR 0 6
56533: PUSH
56534: LD_VAR 0 8
56538: PUSH
56539: FOR_IN
56540: IFFALSE 56609
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56542: LD_VAR 0 6
56546: PPUSH
56547: CALL_OW 313
56551: PUSH
56552: LD_INT 6
56554: LESS
56555: PUSH
56556: LD_VAR 0 6
56560: PPUSH
56561: CALL_OW 266
56565: PUSH
56566: LD_INT 31
56568: PUSH
56569: LD_INT 32
56571: PUSH
56572: EMPTY
56573: LIST
56574: LIST
56575: IN
56576: NOT
56577: AND
56578: PUSH
56579: LD_VAR 0 6
56583: PPUSH
56584: CALL_OW 313
56588: PUSH
56589: LD_INT 0
56591: EQUAL
56592: OR
56593: IFFALSE 56607
// begin j := i ;
56595: LD_ADDR_VAR 0 7
56599: PUSH
56600: LD_VAR 0 6
56604: ST_TO_ADDR
// break ;
56605: GO 56609
// end ; end ;
56607: GO 56539
56609: POP
56610: POP
// if j then
56611: LD_VAR 0 7
56615: IFFALSE 56633
// ComEnterUnit ( unit , j ) else
56617: LD_VAR 0 3
56621: PPUSH
56622: LD_VAR 0 7
56626: PPUSH
56627: CALL_OW 120
56631: GO 56736
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56633: LD_ADDR_VAR 0 10
56637: PUSH
56638: LD_VAR 0 2
56642: PPUSH
56643: LD_INT 2
56645: PUSH
56646: LD_INT 30
56648: PUSH
56649: LD_INT 0
56651: PUSH
56652: EMPTY
56653: LIST
56654: LIST
56655: PUSH
56656: LD_INT 30
56658: PUSH
56659: LD_INT 1
56661: PUSH
56662: EMPTY
56663: LIST
56664: LIST
56665: PUSH
56666: EMPTY
56667: LIST
56668: LIST
56669: LIST
56670: PPUSH
56671: CALL_OW 72
56675: ST_TO_ADDR
// if depot then
56676: LD_VAR 0 10
56680: IFFALSE 56736
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56682: LD_ADDR_VAR 0 10
56686: PUSH
56687: LD_VAR 0 10
56691: PPUSH
56692: LD_VAR 0 3
56696: PPUSH
56697: CALL_OW 74
56701: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56702: LD_VAR 0 3
56706: PPUSH
56707: LD_VAR 0 10
56711: PPUSH
56712: CALL_OW 296
56716: PUSH
56717: LD_INT 10
56719: GREATER
56720: IFFALSE 56736
// ComStandNearbyBuilding ( unit , depot ) ;
56722: LD_VAR 0 3
56726: PPUSH
56727: LD_VAR 0 10
56731: PPUSH
56732: CALL 64928 0 2
// end ; end ; end ;
56736: LD_VAR 0 5
56740: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56741: LD_INT 0
56743: PPUSH
56744: PPUSH
56745: PPUSH
56746: PPUSH
// if not mc_bases then
56747: LD_EXP 99
56751: NOT
56752: IFFALSE 56756
// exit ;
56754: GO 56995
// for i = 1 to mc_bases do
56756: LD_ADDR_VAR 0 2
56760: PUSH
56761: DOUBLE
56762: LD_INT 1
56764: DEC
56765: ST_TO_ADDR
56766: LD_EXP 99
56770: PUSH
56771: FOR_TO
56772: IFFALSE 56993
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56774: LD_ADDR_VAR 0 4
56778: PUSH
56779: LD_EXP 99
56783: PUSH
56784: LD_VAR 0 2
56788: ARRAY
56789: PPUSH
56790: LD_INT 21
56792: PUSH
56793: LD_INT 1
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PPUSH
56800: CALL_OW 72
56804: PUSH
56805: LD_EXP 128
56809: PUSH
56810: LD_VAR 0 2
56814: ARRAY
56815: UNION
56816: ST_TO_ADDR
// if not tmp then
56817: LD_VAR 0 4
56821: NOT
56822: IFFALSE 56826
// continue ;
56824: GO 56771
// for j in tmp do
56826: LD_ADDR_VAR 0 3
56830: PUSH
56831: LD_VAR 0 4
56835: PUSH
56836: FOR_IN
56837: IFFALSE 56989
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56839: LD_VAR 0 3
56843: PPUSH
56844: CALL_OW 110
56848: NOT
56849: PUSH
56850: LD_VAR 0 3
56854: PPUSH
56855: CALL_OW 314
56859: NOT
56860: AND
56861: PUSH
56862: LD_VAR 0 3
56866: PPUSH
56867: CALL_OW 311
56871: NOT
56872: AND
56873: PUSH
56874: LD_VAR 0 3
56878: PPUSH
56879: CALL_OW 310
56883: NOT
56884: AND
56885: PUSH
56886: LD_VAR 0 3
56890: PUSH
56891: LD_EXP 102
56895: PUSH
56896: LD_VAR 0 2
56900: ARRAY
56901: PUSH
56902: LD_INT 1
56904: ARRAY
56905: IN
56906: NOT
56907: AND
56908: PUSH
56909: LD_VAR 0 3
56913: PUSH
56914: LD_EXP 102
56918: PUSH
56919: LD_VAR 0 2
56923: ARRAY
56924: PUSH
56925: LD_INT 2
56927: ARRAY
56928: IN
56929: NOT
56930: AND
56931: PUSH
56932: LD_VAR 0 3
56936: PUSH
56937: LD_EXP 111
56941: PUSH
56942: LD_VAR 0 2
56946: ARRAY
56947: IN
56948: NOT
56949: AND
56950: IFFALSE 56987
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56952: LD_VAR 0 2
56956: PPUSH
56957: LD_EXP 99
56961: PUSH
56962: LD_VAR 0 2
56966: ARRAY
56967: PPUSH
56968: LD_VAR 0 3
56972: PPUSH
56973: LD_VAR 0 3
56977: PPUSH
56978: CALL_OW 257
56982: PPUSH
56983: CALL 55759 0 4
// end ;
56987: GO 56836
56989: POP
56990: POP
// end ;
56991: GO 56771
56993: POP
56994: POP
// end ;
56995: LD_VAR 0 1
56999: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57000: LD_INT 0
57002: PPUSH
57003: PPUSH
57004: PPUSH
57005: PPUSH
57006: PPUSH
57007: PPUSH
// if not mc_bases [ base ] then
57008: LD_EXP 99
57012: PUSH
57013: LD_VAR 0 1
57017: ARRAY
57018: NOT
57019: IFFALSE 57023
// exit ;
57021: GO 57205
// tmp := [ ] ;
57023: LD_ADDR_VAR 0 6
57027: PUSH
57028: EMPTY
57029: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57030: LD_ADDR_VAR 0 7
57034: PUSH
57035: LD_VAR 0 3
57039: PPUSH
57040: LD_INT 0
57042: PPUSH
57043: CALL_OW 517
57047: ST_TO_ADDR
// if not list then
57048: LD_VAR 0 7
57052: NOT
57053: IFFALSE 57057
// exit ;
57055: GO 57205
// for i = 1 to amount do
57057: LD_ADDR_VAR 0 5
57061: PUSH
57062: DOUBLE
57063: LD_INT 1
57065: DEC
57066: ST_TO_ADDR
57067: LD_VAR 0 2
57071: PUSH
57072: FOR_TO
57073: IFFALSE 57153
// begin x := rand ( 1 , list [ 1 ] ) ;
57075: LD_ADDR_VAR 0 8
57079: PUSH
57080: LD_INT 1
57082: PPUSH
57083: LD_VAR 0 7
57087: PUSH
57088: LD_INT 1
57090: ARRAY
57091: PPUSH
57092: CALL_OW 12
57096: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57097: LD_ADDR_VAR 0 6
57101: PUSH
57102: LD_VAR 0 6
57106: PPUSH
57107: LD_VAR 0 5
57111: PPUSH
57112: LD_VAR 0 7
57116: PUSH
57117: LD_INT 1
57119: ARRAY
57120: PUSH
57121: LD_VAR 0 8
57125: ARRAY
57126: PUSH
57127: LD_VAR 0 7
57131: PUSH
57132: LD_INT 2
57134: ARRAY
57135: PUSH
57136: LD_VAR 0 8
57140: ARRAY
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: PPUSH
57146: CALL_OW 1
57150: ST_TO_ADDR
// end ;
57151: GO 57072
57153: POP
57154: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57155: LD_ADDR_EXP 112
57159: PUSH
57160: LD_EXP 112
57164: PPUSH
57165: LD_VAR 0 1
57169: PPUSH
57170: LD_VAR 0 6
57174: PPUSH
57175: CALL_OW 1
57179: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57180: LD_ADDR_EXP 114
57184: PUSH
57185: LD_EXP 114
57189: PPUSH
57190: LD_VAR 0 1
57194: PPUSH
57195: LD_VAR 0 3
57199: PPUSH
57200: CALL_OW 1
57204: ST_TO_ADDR
// end ;
57205: LD_VAR 0 4
57209: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57210: LD_INT 0
57212: PPUSH
// if not mc_bases [ base ] then
57213: LD_EXP 99
57217: PUSH
57218: LD_VAR 0 1
57222: ARRAY
57223: NOT
57224: IFFALSE 57228
// exit ;
57226: GO 57253
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57228: LD_ADDR_EXP 104
57232: PUSH
57233: LD_EXP 104
57237: PPUSH
57238: LD_VAR 0 1
57242: PPUSH
57243: LD_VAR 0 2
57247: PPUSH
57248: CALL_OW 1
57252: ST_TO_ADDR
// end ;
57253: LD_VAR 0 3
57257: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57258: LD_INT 0
57260: PPUSH
// if not mc_bases [ base ] then
57261: LD_EXP 99
57265: PUSH
57266: LD_VAR 0 1
57270: ARRAY
57271: NOT
57272: IFFALSE 57276
// exit ;
57274: GO 57313
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57276: LD_ADDR_EXP 104
57280: PUSH
57281: LD_EXP 104
57285: PPUSH
57286: LD_VAR 0 1
57290: PPUSH
57291: LD_EXP 104
57295: PUSH
57296: LD_VAR 0 1
57300: ARRAY
57301: PUSH
57302: LD_VAR 0 2
57306: UNION
57307: PPUSH
57308: CALL_OW 1
57312: ST_TO_ADDR
// end ;
57313: LD_VAR 0 3
57317: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57318: LD_INT 0
57320: PPUSH
// if not mc_bases [ base ] then
57321: LD_EXP 99
57325: PUSH
57326: LD_VAR 0 1
57330: ARRAY
57331: NOT
57332: IFFALSE 57336
// exit ;
57334: GO 57361
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57336: LD_ADDR_EXP 120
57340: PUSH
57341: LD_EXP 120
57345: PPUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: LD_VAR 0 2
57355: PPUSH
57356: CALL_OW 1
57360: ST_TO_ADDR
// end ;
57361: LD_VAR 0 3
57365: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57366: LD_INT 0
57368: PPUSH
// if not mc_bases [ base ] then
57369: LD_EXP 99
57373: PUSH
57374: LD_VAR 0 1
57378: ARRAY
57379: NOT
57380: IFFALSE 57384
// exit ;
57382: GO 57421
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57384: LD_ADDR_EXP 120
57388: PUSH
57389: LD_EXP 120
57393: PPUSH
57394: LD_VAR 0 1
57398: PPUSH
57399: LD_EXP 120
57403: PUSH
57404: LD_VAR 0 1
57408: ARRAY
57409: PUSH
57410: LD_VAR 0 2
57414: ADD
57415: PPUSH
57416: CALL_OW 1
57420: ST_TO_ADDR
// end ;
57421: LD_VAR 0 3
57425: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57426: LD_INT 0
57428: PPUSH
// if not mc_bases [ base ] then
57429: LD_EXP 99
57433: PUSH
57434: LD_VAR 0 1
57438: ARRAY
57439: NOT
57440: IFFALSE 57444
// exit ;
57442: GO 57498
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57444: LD_ADDR_EXP 121
57448: PUSH
57449: LD_EXP 121
57453: PPUSH
57454: LD_VAR 0 1
57458: PPUSH
57459: LD_VAR 0 2
57463: PPUSH
57464: CALL_OW 1
57468: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57469: LD_ADDR_EXP 110
57473: PUSH
57474: LD_EXP 110
57478: PPUSH
57479: LD_VAR 0 1
57483: PPUSH
57484: LD_VAR 0 2
57488: PUSH
57489: LD_INT 0
57491: PLUS
57492: PPUSH
57493: CALL_OW 1
57497: ST_TO_ADDR
// end ;
57498: LD_VAR 0 3
57502: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57503: LD_INT 0
57505: PPUSH
// if not mc_bases [ base ] then
57506: LD_EXP 99
57510: PUSH
57511: LD_VAR 0 1
57515: ARRAY
57516: NOT
57517: IFFALSE 57521
// exit ;
57519: GO 57546
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57521: LD_ADDR_EXP 110
57525: PUSH
57526: LD_EXP 110
57530: PPUSH
57531: LD_VAR 0 1
57535: PPUSH
57536: LD_VAR 0 2
57540: PPUSH
57541: CALL_OW 1
57545: ST_TO_ADDR
// end ;
57546: LD_VAR 0 3
57550: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57551: LD_INT 0
57553: PPUSH
57554: PPUSH
57555: PPUSH
57556: PPUSH
// if not mc_bases [ base ] then
57557: LD_EXP 99
57561: PUSH
57562: LD_VAR 0 1
57566: ARRAY
57567: NOT
57568: IFFALSE 57572
// exit ;
57570: GO 57637
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57572: LD_ADDR_EXP 119
57576: PUSH
57577: LD_EXP 119
57581: PPUSH
57582: LD_VAR 0 1
57586: PUSH
57587: LD_EXP 119
57591: PUSH
57592: LD_VAR 0 1
57596: ARRAY
57597: PUSH
57598: LD_INT 1
57600: PLUS
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PPUSH
57606: LD_VAR 0 1
57610: PUSH
57611: LD_VAR 0 2
57615: PUSH
57616: LD_VAR 0 3
57620: PUSH
57621: LD_VAR 0 4
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: LIST
57630: LIST
57631: PPUSH
57632: CALL 70361 0 3
57636: ST_TO_ADDR
// end ;
57637: LD_VAR 0 5
57641: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57642: LD_INT 0
57644: PPUSH
// if not mc_bases [ base ] then
57645: LD_EXP 99
57649: PUSH
57650: LD_VAR 0 1
57654: ARRAY
57655: NOT
57656: IFFALSE 57660
// exit ;
57658: GO 57685
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57660: LD_ADDR_EXP 136
57664: PUSH
57665: LD_EXP 136
57669: PPUSH
57670: LD_VAR 0 1
57674: PPUSH
57675: LD_VAR 0 2
57679: PPUSH
57680: CALL_OW 1
57684: ST_TO_ADDR
// end ;
57685: LD_VAR 0 3
57689: RET
// export function MC_GetMinesField ( base ) ; begin
57690: LD_INT 0
57692: PPUSH
// result := mc_mines [ base ] ;
57693: LD_ADDR_VAR 0 2
57697: PUSH
57698: LD_EXP 112
57702: PUSH
57703: LD_VAR 0 1
57707: ARRAY
57708: ST_TO_ADDR
// end ;
57709: LD_VAR 0 2
57713: RET
// export function MC_GetProduceList ( base ) ; begin
57714: LD_INT 0
57716: PPUSH
// result := mc_produce [ base ] ;
57717: LD_ADDR_VAR 0 2
57721: PUSH
57722: LD_EXP 120
57726: PUSH
57727: LD_VAR 0 1
57731: ARRAY
57732: ST_TO_ADDR
// end ;
57733: LD_VAR 0 2
57737: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57738: LD_INT 0
57740: PPUSH
57741: PPUSH
// if not mc_bases then
57742: LD_EXP 99
57746: NOT
57747: IFFALSE 57751
// exit ;
57749: GO 57816
// if mc_bases [ base ] then
57751: LD_EXP 99
57755: PUSH
57756: LD_VAR 0 1
57760: ARRAY
57761: IFFALSE 57816
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57763: LD_ADDR_VAR 0 3
57767: PUSH
57768: LD_EXP 99
57772: PUSH
57773: LD_VAR 0 1
57777: ARRAY
57778: PPUSH
57779: LD_INT 30
57781: PUSH
57782: LD_VAR 0 2
57786: PUSH
57787: EMPTY
57788: LIST
57789: LIST
57790: PPUSH
57791: CALL_OW 72
57795: ST_TO_ADDR
// if result then
57796: LD_VAR 0 3
57800: IFFALSE 57816
// result := result [ 1 ] ;
57802: LD_ADDR_VAR 0 3
57806: PUSH
57807: LD_VAR 0 3
57811: PUSH
57812: LD_INT 1
57814: ARRAY
57815: ST_TO_ADDR
// end ; end ;
57816: LD_VAR 0 3
57820: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
57821: LD_INT 0
57823: PPUSH
57824: PPUSH
// if not mc_bases then
57825: LD_EXP 99
57829: NOT
57830: IFFALSE 57834
// exit ;
57832: GO 57879
// if mc_bases [ base ] then
57834: LD_EXP 99
57838: PUSH
57839: LD_VAR 0 1
57843: ARRAY
57844: IFFALSE 57879
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57846: LD_ADDR_VAR 0 3
57850: PUSH
57851: LD_EXP 99
57855: PUSH
57856: LD_VAR 0 1
57860: ARRAY
57861: PPUSH
57862: LD_INT 30
57864: PUSH
57865: LD_VAR 0 2
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PPUSH
57874: CALL_OW 72
57878: ST_TO_ADDR
// end ;
57879: LD_VAR 0 3
57883: RET
// export function MC_SetTame ( base , area ) ; begin
57884: LD_INT 0
57886: PPUSH
// if not mc_bases or not base then
57887: LD_EXP 99
57891: NOT
57892: PUSH
57893: LD_VAR 0 1
57897: NOT
57898: OR
57899: IFFALSE 57903
// exit ;
57901: GO 57928
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57903: LD_ADDR_EXP 127
57907: PUSH
57908: LD_EXP 127
57912: PPUSH
57913: LD_VAR 0 1
57917: PPUSH
57918: LD_VAR 0 2
57922: PPUSH
57923: CALL_OW 1
57927: ST_TO_ADDR
// end ;
57928: LD_VAR 0 3
57932: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57933: LD_INT 0
57935: PPUSH
57936: PPUSH
// if not mc_bases or not base then
57937: LD_EXP 99
57941: NOT
57942: PUSH
57943: LD_VAR 0 1
57947: NOT
57948: OR
57949: IFFALSE 57953
// exit ;
57951: GO 58055
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57953: LD_ADDR_VAR 0 4
57957: PUSH
57958: LD_EXP 99
57962: PUSH
57963: LD_VAR 0 1
57967: ARRAY
57968: PPUSH
57969: LD_INT 30
57971: PUSH
57972: LD_VAR 0 2
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: PPUSH
57981: CALL_OW 72
57985: ST_TO_ADDR
// if not tmp then
57986: LD_VAR 0 4
57990: NOT
57991: IFFALSE 57995
// exit ;
57993: GO 58055
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57995: LD_ADDR_EXP 131
57999: PUSH
58000: LD_EXP 131
58004: PPUSH
58005: LD_VAR 0 1
58009: PPUSH
58010: LD_EXP 131
58014: PUSH
58015: LD_VAR 0 1
58019: ARRAY
58020: PPUSH
58021: LD_EXP 131
58025: PUSH
58026: LD_VAR 0 1
58030: ARRAY
58031: PUSH
58032: LD_INT 1
58034: PLUS
58035: PPUSH
58036: LD_VAR 0 4
58040: PUSH
58041: LD_INT 1
58043: ARRAY
58044: PPUSH
58045: CALL_OW 2
58049: PPUSH
58050: CALL_OW 1
58054: ST_TO_ADDR
// end ;
58055: LD_VAR 0 3
58059: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58060: LD_INT 0
58062: PPUSH
58063: PPUSH
// if not mc_bases or not base or not kinds then
58064: LD_EXP 99
58068: NOT
58069: PUSH
58070: LD_VAR 0 1
58074: NOT
58075: OR
58076: PUSH
58077: LD_VAR 0 2
58081: NOT
58082: OR
58083: IFFALSE 58087
// exit ;
58085: GO 58148
// for i in kinds do
58087: LD_ADDR_VAR 0 4
58091: PUSH
58092: LD_VAR 0 2
58096: PUSH
58097: FOR_IN
58098: IFFALSE 58146
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58100: LD_ADDR_EXP 133
58104: PUSH
58105: LD_EXP 133
58109: PPUSH
58110: LD_VAR 0 1
58114: PUSH
58115: LD_EXP 133
58119: PUSH
58120: LD_VAR 0 1
58124: ARRAY
58125: PUSH
58126: LD_INT 1
58128: PLUS
58129: PUSH
58130: EMPTY
58131: LIST
58132: LIST
58133: PPUSH
58134: LD_VAR 0 4
58138: PPUSH
58139: CALL 70361 0 3
58143: ST_TO_ADDR
58144: GO 58097
58146: POP
58147: POP
// end ;
58148: LD_VAR 0 3
58152: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58153: LD_INT 0
58155: PPUSH
// if not mc_bases or not base or not areas then
58156: LD_EXP 99
58160: NOT
58161: PUSH
58162: LD_VAR 0 1
58166: NOT
58167: OR
58168: PUSH
58169: LD_VAR 0 2
58173: NOT
58174: OR
58175: IFFALSE 58179
// exit ;
58177: GO 58204
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58179: LD_ADDR_EXP 117
58183: PUSH
58184: LD_EXP 117
58188: PPUSH
58189: LD_VAR 0 1
58193: PPUSH
58194: LD_VAR 0 2
58198: PPUSH
58199: CALL_OW 1
58203: ST_TO_ADDR
// end ;
58204: LD_VAR 0 3
58208: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58209: LD_INT 0
58211: PPUSH
// if not mc_bases or not base or not teleports_exit then
58212: LD_EXP 99
58216: NOT
58217: PUSH
58218: LD_VAR 0 1
58222: NOT
58223: OR
58224: PUSH
58225: LD_VAR 0 2
58229: NOT
58230: OR
58231: IFFALSE 58235
// exit ;
58233: GO 58260
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58235: LD_ADDR_EXP 134
58239: PUSH
58240: LD_EXP 134
58244: PPUSH
58245: LD_VAR 0 1
58249: PPUSH
58250: LD_VAR 0 2
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// end ;
58260: LD_VAR 0 3
58264: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58265: LD_INT 0
58267: PPUSH
58268: PPUSH
58269: PPUSH
// if not mc_bases or not base or not ext_list then
58270: LD_EXP 99
58274: NOT
58275: PUSH
58276: LD_VAR 0 1
58280: NOT
58281: OR
58282: PUSH
58283: LD_VAR 0 5
58287: NOT
58288: OR
58289: IFFALSE 58293
// exit ;
58291: GO 58466
// tmp := GetFacExtXYD ( x , y , d ) ;
58293: LD_ADDR_VAR 0 8
58297: PUSH
58298: LD_VAR 0 2
58302: PPUSH
58303: LD_VAR 0 3
58307: PPUSH
58308: LD_VAR 0 4
58312: PPUSH
58313: CALL 103739 0 3
58317: ST_TO_ADDR
// if not tmp then
58318: LD_VAR 0 8
58322: NOT
58323: IFFALSE 58327
// exit ;
58325: GO 58466
// for i in tmp do
58327: LD_ADDR_VAR 0 7
58331: PUSH
58332: LD_VAR 0 8
58336: PUSH
58337: FOR_IN
58338: IFFALSE 58464
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58340: LD_ADDR_EXP 104
58344: PUSH
58345: LD_EXP 104
58349: PPUSH
58350: LD_VAR 0 1
58354: PPUSH
58355: LD_EXP 104
58359: PUSH
58360: LD_VAR 0 1
58364: ARRAY
58365: PPUSH
58366: LD_EXP 104
58370: PUSH
58371: LD_VAR 0 1
58375: ARRAY
58376: PUSH
58377: LD_INT 1
58379: PLUS
58380: PPUSH
58381: LD_VAR 0 5
58385: PUSH
58386: LD_INT 1
58388: ARRAY
58389: PUSH
58390: LD_VAR 0 7
58394: PUSH
58395: LD_INT 1
58397: ARRAY
58398: PUSH
58399: LD_VAR 0 7
58403: PUSH
58404: LD_INT 2
58406: ARRAY
58407: PUSH
58408: LD_VAR 0 7
58412: PUSH
58413: LD_INT 3
58415: ARRAY
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: LIST
58421: LIST
58422: PPUSH
58423: CALL_OW 2
58427: PPUSH
58428: CALL_OW 1
58432: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58433: LD_ADDR_VAR 0 5
58437: PUSH
58438: LD_VAR 0 5
58442: PPUSH
58443: LD_INT 1
58445: PPUSH
58446: CALL_OW 3
58450: ST_TO_ADDR
// if not ext_list then
58451: LD_VAR 0 5
58455: NOT
58456: IFFALSE 58462
// exit ;
58458: POP
58459: POP
58460: GO 58466
// end ;
58462: GO 58337
58464: POP
58465: POP
// end ;
58466: LD_VAR 0 6
58470: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58471: LD_INT 0
58473: PPUSH
// if not mc_bases or not base or not weapon_list then
58474: LD_EXP 99
58478: NOT
58479: PUSH
58480: LD_VAR 0 1
58484: NOT
58485: OR
58486: PUSH
58487: LD_VAR 0 2
58491: NOT
58492: OR
58493: IFFALSE 58497
// exit ;
58495: GO 58522
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58497: LD_ADDR_EXP 138
58501: PUSH
58502: LD_EXP 138
58506: PPUSH
58507: LD_VAR 0 1
58511: PPUSH
58512: LD_VAR 0 2
58516: PPUSH
58517: CALL_OW 1
58521: ST_TO_ADDR
// end ;
58522: LD_VAR 0 3
58526: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58527: LD_INT 0
58529: PPUSH
// if not mc_bases or not base or not tech_list then
58530: LD_EXP 99
58534: NOT
58535: PUSH
58536: LD_VAR 0 1
58540: NOT
58541: OR
58542: PUSH
58543: LD_VAR 0 2
58547: NOT
58548: OR
58549: IFFALSE 58553
// exit ;
58551: GO 58578
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58553: LD_ADDR_EXP 126
58557: PUSH
58558: LD_EXP 126
58562: PPUSH
58563: LD_VAR 0 1
58567: PPUSH
58568: LD_VAR 0 2
58572: PPUSH
58573: CALL_OW 1
58577: ST_TO_ADDR
// end ;
58578: LD_VAR 0 3
58582: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58583: LD_INT 0
58585: PPUSH
// if not mc_bases or not parking_area or not base then
58586: LD_EXP 99
58590: NOT
58591: PUSH
58592: LD_VAR 0 2
58596: NOT
58597: OR
58598: PUSH
58599: LD_VAR 0 1
58603: NOT
58604: OR
58605: IFFALSE 58609
// exit ;
58607: GO 58634
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58609: LD_ADDR_EXP 123
58613: PUSH
58614: LD_EXP 123
58618: PPUSH
58619: LD_VAR 0 1
58623: PPUSH
58624: LD_VAR 0 2
58628: PPUSH
58629: CALL_OW 1
58633: ST_TO_ADDR
// end ;
58634: LD_VAR 0 3
58638: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58639: LD_INT 0
58641: PPUSH
// if not mc_bases or not base or not scan_area then
58642: LD_EXP 99
58646: NOT
58647: PUSH
58648: LD_VAR 0 1
58652: NOT
58653: OR
58654: PUSH
58655: LD_VAR 0 2
58659: NOT
58660: OR
58661: IFFALSE 58665
// exit ;
58663: GO 58690
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58665: LD_ADDR_EXP 124
58669: PUSH
58670: LD_EXP 124
58674: PPUSH
58675: LD_VAR 0 1
58679: PPUSH
58680: LD_VAR 0 2
58684: PPUSH
58685: CALL_OW 1
58689: ST_TO_ADDR
// end ;
58690: LD_VAR 0 3
58694: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58695: LD_INT 0
58697: PPUSH
58698: PPUSH
// if not mc_bases or not base then
58699: LD_EXP 99
58703: NOT
58704: PUSH
58705: LD_VAR 0 1
58709: NOT
58710: OR
58711: IFFALSE 58715
// exit ;
58713: GO 58779
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58715: LD_ADDR_VAR 0 3
58719: PUSH
58720: LD_INT 1
58722: PUSH
58723: LD_INT 2
58725: PUSH
58726: LD_INT 3
58728: PUSH
58729: LD_INT 4
58731: PUSH
58732: LD_INT 11
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: LIST
58739: LIST
58740: LIST
58741: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58742: LD_ADDR_EXP 126
58746: PUSH
58747: LD_EXP 126
58751: PPUSH
58752: LD_VAR 0 1
58756: PPUSH
58757: LD_EXP 126
58761: PUSH
58762: LD_VAR 0 1
58766: ARRAY
58767: PUSH
58768: LD_VAR 0 3
58772: DIFF
58773: PPUSH
58774: CALL_OW 1
58778: ST_TO_ADDR
// end ;
58779: LD_VAR 0 2
58783: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58784: LD_INT 0
58786: PPUSH
// result := mc_vehicles [ base ] ;
58787: LD_ADDR_VAR 0 3
58791: PUSH
58792: LD_EXP 118
58796: PUSH
58797: LD_VAR 0 1
58801: ARRAY
58802: ST_TO_ADDR
// if onlyCombat then
58803: LD_VAR 0 2
58807: IFFALSE 58972
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58809: LD_ADDR_VAR 0 3
58813: PUSH
58814: LD_VAR 0 3
58818: PUSH
58819: LD_VAR 0 3
58823: PPUSH
58824: LD_INT 2
58826: PUSH
58827: LD_INT 34
58829: PUSH
58830: LD_INT 12
58832: PUSH
58833: EMPTY
58834: LIST
58835: LIST
58836: PUSH
58837: LD_INT 34
58839: PUSH
58840: LD_INT 51
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: PUSH
58847: LD_INT 34
58849: PUSH
58850: LD_EXP 93
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PUSH
58859: LD_INT 34
58861: PUSH
58862: LD_INT 32
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: LD_INT 34
58871: PUSH
58872: LD_INT 13
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 34
58881: PUSH
58882: LD_INT 52
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: PUSH
58889: LD_INT 34
58891: PUSH
58892: LD_INT 14
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: LD_INT 34
58901: PUSH
58902: LD_INT 53
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: PUSH
58909: LD_INT 34
58911: PUSH
58912: LD_EXP 92
58916: PUSH
58917: EMPTY
58918: LIST
58919: LIST
58920: PUSH
58921: LD_INT 34
58923: PUSH
58924: LD_INT 31
58926: PUSH
58927: EMPTY
58928: LIST
58929: LIST
58930: PUSH
58931: LD_INT 34
58933: PUSH
58934: LD_INT 48
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: PUSH
58941: LD_INT 34
58943: PUSH
58944: LD_INT 8
58946: PUSH
58947: EMPTY
58948: LIST
58949: LIST
58950: PUSH
58951: EMPTY
58952: LIST
58953: LIST
58954: LIST
58955: LIST
58956: LIST
58957: LIST
58958: LIST
58959: LIST
58960: LIST
58961: LIST
58962: LIST
58963: LIST
58964: LIST
58965: PPUSH
58966: CALL_OW 72
58970: DIFF
58971: ST_TO_ADDR
// end ; end_of_file
58972: LD_VAR 0 3
58976: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58977: LD_INT 0
58979: PPUSH
58980: PPUSH
58981: PPUSH
// if not mc_bases or not skirmish then
58982: LD_EXP 99
58986: NOT
58987: PUSH
58988: LD_EXP 97
58992: NOT
58993: OR
58994: IFFALSE 58998
// exit ;
58996: GO 59163
// for i = 1 to mc_bases do
58998: LD_ADDR_VAR 0 4
59002: PUSH
59003: DOUBLE
59004: LD_INT 1
59006: DEC
59007: ST_TO_ADDR
59008: LD_EXP 99
59012: PUSH
59013: FOR_TO
59014: IFFALSE 59161
// begin if sci in mc_bases [ i ] then
59016: LD_VAR 0 2
59020: PUSH
59021: LD_EXP 99
59025: PUSH
59026: LD_VAR 0 4
59030: ARRAY
59031: IN
59032: IFFALSE 59159
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59034: LD_ADDR_EXP 128
59038: PUSH
59039: LD_EXP 128
59043: PPUSH
59044: LD_VAR 0 4
59048: PUSH
59049: LD_EXP 128
59053: PUSH
59054: LD_VAR 0 4
59058: ARRAY
59059: PUSH
59060: LD_INT 1
59062: PLUS
59063: PUSH
59064: EMPTY
59065: LIST
59066: LIST
59067: PPUSH
59068: LD_VAR 0 1
59072: PPUSH
59073: CALL 70361 0 3
59077: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59078: LD_ADDR_VAR 0 5
59082: PUSH
59083: LD_EXP 99
59087: PUSH
59088: LD_VAR 0 4
59092: ARRAY
59093: PPUSH
59094: LD_INT 2
59096: PUSH
59097: LD_INT 30
59099: PUSH
59100: LD_INT 0
59102: PUSH
59103: EMPTY
59104: LIST
59105: LIST
59106: PUSH
59107: LD_INT 30
59109: PUSH
59110: LD_INT 1
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: LIST
59121: PPUSH
59122: CALL_OW 72
59126: PPUSH
59127: LD_VAR 0 1
59131: PPUSH
59132: CALL_OW 74
59136: ST_TO_ADDR
// if tmp then
59137: LD_VAR 0 5
59141: IFFALSE 59157
// ComStandNearbyBuilding ( ape , tmp ) ;
59143: LD_VAR 0 1
59147: PPUSH
59148: LD_VAR 0 5
59152: PPUSH
59153: CALL 64928 0 2
// break ;
59157: GO 59161
// end ; end ;
59159: GO 59013
59161: POP
59162: POP
// end ;
59163: LD_VAR 0 3
59167: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59168: LD_INT 0
59170: PPUSH
59171: PPUSH
59172: PPUSH
// if not mc_bases or not skirmish then
59173: LD_EXP 99
59177: NOT
59178: PUSH
59179: LD_EXP 97
59183: NOT
59184: OR
59185: IFFALSE 59189
// exit ;
59187: GO 59278
// for i = 1 to mc_bases do
59189: LD_ADDR_VAR 0 4
59193: PUSH
59194: DOUBLE
59195: LD_INT 1
59197: DEC
59198: ST_TO_ADDR
59199: LD_EXP 99
59203: PUSH
59204: FOR_TO
59205: IFFALSE 59276
// begin if building in mc_busy_turret_list [ i ] then
59207: LD_VAR 0 1
59211: PUSH
59212: LD_EXP 109
59216: PUSH
59217: LD_VAR 0 4
59221: ARRAY
59222: IN
59223: IFFALSE 59274
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59225: LD_ADDR_VAR 0 5
59229: PUSH
59230: LD_EXP 109
59234: PUSH
59235: LD_VAR 0 4
59239: ARRAY
59240: PUSH
59241: LD_VAR 0 1
59245: DIFF
59246: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59247: LD_ADDR_EXP 109
59251: PUSH
59252: LD_EXP 109
59256: PPUSH
59257: LD_VAR 0 4
59261: PPUSH
59262: LD_VAR 0 5
59266: PPUSH
59267: CALL_OW 1
59271: ST_TO_ADDR
// break ;
59272: GO 59276
// end ; end ;
59274: GO 59204
59276: POP
59277: POP
// end ;
59278: LD_VAR 0 3
59282: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59283: LD_INT 0
59285: PPUSH
59286: PPUSH
59287: PPUSH
// if not mc_bases or not skirmish then
59288: LD_EXP 99
59292: NOT
59293: PUSH
59294: LD_EXP 97
59298: NOT
59299: OR
59300: IFFALSE 59304
// exit ;
59302: GO 59503
// for i = 1 to mc_bases do
59304: LD_ADDR_VAR 0 5
59308: PUSH
59309: DOUBLE
59310: LD_INT 1
59312: DEC
59313: ST_TO_ADDR
59314: LD_EXP 99
59318: PUSH
59319: FOR_TO
59320: IFFALSE 59501
// if building in mc_bases [ i ] then
59322: LD_VAR 0 1
59326: PUSH
59327: LD_EXP 99
59331: PUSH
59332: LD_VAR 0 5
59336: ARRAY
59337: IN
59338: IFFALSE 59499
// begin tmp := mc_bases [ i ] diff building ;
59340: LD_ADDR_VAR 0 6
59344: PUSH
59345: LD_EXP 99
59349: PUSH
59350: LD_VAR 0 5
59354: ARRAY
59355: PUSH
59356: LD_VAR 0 1
59360: DIFF
59361: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59362: LD_ADDR_EXP 99
59366: PUSH
59367: LD_EXP 99
59371: PPUSH
59372: LD_VAR 0 5
59376: PPUSH
59377: LD_VAR 0 6
59381: PPUSH
59382: CALL_OW 1
59386: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59387: LD_VAR 0 1
59391: PUSH
59392: LD_EXP 107
59396: PUSH
59397: LD_VAR 0 5
59401: ARRAY
59402: IN
59403: IFFALSE 59442
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59405: LD_ADDR_EXP 107
59409: PUSH
59410: LD_EXP 107
59414: PPUSH
59415: LD_VAR 0 5
59419: PPUSH
59420: LD_EXP 107
59424: PUSH
59425: LD_VAR 0 5
59429: ARRAY
59430: PUSH
59431: LD_VAR 0 1
59435: DIFF
59436: PPUSH
59437: CALL_OW 1
59441: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59442: LD_VAR 0 1
59446: PUSH
59447: LD_EXP 108
59451: PUSH
59452: LD_VAR 0 5
59456: ARRAY
59457: IN
59458: IFFALSE 59497
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59460: LD_ADDR_EXP 108
59464: PUSH
59465: LD_EXP 108
59469: PPUSH
59470: LD_VAR 0 5
59474: PPUSH
59475: LD_EXP 108
59479: PUSH
59480: LD_VAR 0 5
59484: ARRAY
59485: PUSH
59486: LD_VAR 0 1
59490: DIFF
59491: PPUSH
59492: CALL_OW 1
59496: ST_TO_ADDR
// break ;
59497: GO 59501
// end ;
59499: GO 59319
59501: POP
59502: POP
// end ;
59503: LD_VAR 0 4
59507: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59508: LD_INT 0
59510: PPUSH
59511: PPUSH
59512: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59513: LD_EXP 99
59517: NOT
59518: PUSH
59519: LD_EXP 97
59523: NOT
59524: OR
59525: PUSH
59526: LD_VAR 0 3
59530: PUSH
59531: LD_EXP 125
59535: IN
59536: NOT
59537: OR
59538: IFFALSE 59542
// exit ;
59540: GO 59665
// for i = 1 to mc_vehicles do
59542: LD_ADDR_VAR 0 6
59546: PUSH
59547: DOUBLE
59548: LD_INT 1
59550: DEC
59551: ST_TO_ADDR
59552: LD_EXP 118
59556: PUSH
59557: FOR_TO
59558: IFFALSE 59663
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59560: LD_VAR 0 2
59564: PUSH
59565: LD_EXP 118
59569: PUSH
59570: LD_VAR 0 6
59574: ARRAY
59575: IN
59576: PUSH
59577: LD_VAR 0 1
59581: PUSH
59582: LD_EXP 118
59586: PUSH
59587: LD_VAR 0 6
59591: ARRAY
59592: IN
59593: OR
59594: IFFALSE 59661
// begin tmp := mc_vehicles [ i ] diff old ;
59596: LD_ADDR_VAR 0 7
59600: PUSH
59601: LD_EXP 118
59605: PUSH
59606: LD_VAR 0 6
59610: ARRAY
59611: PUSH
59612: LD_VAR 0 2
59616: DIFF
59617: ST_TO_ADDR
// tmp := tmp diff new ;
59618: LD_ADDR_VAR 0 7
59622: PUSH
59623: LD_VAR 0 7
59627: PUSH
59628: LD_VAR 0 1
59632: DIFF
59633: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59634: LD_ADDR_EXP 118
59638: PUSH
59639: LD_EXP 118
59643: PPUSH
59644: LD_VAR 0 6
59648: PPUSH
59649: LD_VAR 0 7
59653: PPUSH
59654: CALL_OW 1
59658: ST_TO_ADDR
// break ;
59659: GO 59663
// end ;
59661: GO 59557
59663: POP
59664: POP
// end ;
59665: LD_VAR 0 5
59669: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59670: LD_INT 0
59672: PPUSH
59673: PPUSH
59674: PPUSH
59675: PPUSH
// if not mc_bases or not skirmish then
59676: LD_EXP 99
59680: NOT
59681: PUSH
59682: LD_EXP 97
59686: NOT
59687: OR
59688: IFFALSE 59692
// exit ;
59690: GO 60069
// side := GetSide ( vehicle ) ;
59692: LD_ADDR_VAR 0 5
59696: PUSH
59697: LD_VAR 0 1
59701: PPUSH
59702: CALL_OW 255
59706: ST_TO_ADDR
// for i = 1 to mc_bases do
59707: LD_ADDR_VAR 0 4
59711: PUSH
59712: DOUBLE
59713: LD_INT 1
59715: DEC
59716: ST_TO_ADDR
59717: LD_EXP 99
59721: PUSH
59722: FOR_TO
59723: IFFALSE 60067
// begin if factory in mc_bases [ i ] then
59725: LD_VAR 0 2
59729: PUSH
59730: LD_EXP 99
59734: PUSH
59735: LD_VAR 0 4
59739: ARRAY
59740: IN
59741: IFFALSE 60065
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59743: LD_EXP 121
59747: PUSH
59748: LD_VAR 0 4
59752: ARRAY
59753: PUSH
59754: LD_EXP 110
59758: PUSH
59759: LD_VAR 0 4
59763: ARRAY
59764: LESS
59765: PUSH
59766: LD_VAR 0 1
59770: PPUSH
59771: CALL_OW 264
59775: PUSH
59776: LD_INT 31
59778: PUSH
59779: LD_INT 32
59781: PUSH
59782: LD_INT 51
59784: PUSH
59785: LD_EXP 93
59789: PUSH
59790: LD_INT 12
59792: PUSH
59793: LD_INT 30
59795: PUSH
59796: LD_EXP 92
59800: PUSH
59801: LD_INT 11
59803: PUSH
59804: LD_INT 53
59806: PUSH
59807: LD_INT 14
59809: PUSH
59810: LD_EXP 96
59814: PUSH
59815: LD_INT 29
59817: PUSH
59818: LD_EXP 94
59822: PUSH
59823: LD_INT 13
59825: PUSH
59826: LD_INT 52
59828: PUSH
59829: LD_INT 48
59831: PUSH
59832: LD_INT 8
59834: PUSH
59835: EMPTY
59836: LIST
59837: LIST
59838: LIST
59839: LIST
59840: LIST
59841: LIST
59842: LIST
59843: LIST
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: LIST
59849: LIST
59850: LIST
59851: LIST
59852: LIST
59853: IN
59854: NOT
59855: AND
59856: IFFALSE 59904
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59858: LD_ADDR_EXP 121
59862: PUSH
59863: LD_EXP 121
59867: PPUSH
59868: LD_VAR 0 4
59872: PUSH
59873: LD_EXP 121
59877: PUSH
59878: LD_VAR 0 4
59882: ARRAY
59883: PUSH
59884: LD_INT 1
59886: PLUS
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: PPUSH
59892: LD_VAR 0 1
59896: PPUSH
59897: CALL 70361 0 3
59901: ST_TO_ADDR
59902: GO 59948
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59904: LD_ADDR_EXP 118
59908: PUSH
59909: LD_EXP 118
59913: PPUSH
59914: LD_VAR 0 4
59918: PUSH
59919: LD_EXP 118
59923: PUSH
59924: LD_VAR 0 4
59928: ARRAY
59929: PUSH
59930: LD_INT 1
59932: PLUS
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: PPUSH
59938: LD_VAR 0 1
59942: PPUSH
59943: CALL 70361 0 3
59947: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59948: LD_VAR 0 1
59952: PPUSH
59953: CALL_OW 263
59957: PUSH
59958: LD_INT 2
59960: EQUAL
59961: IFFALSE 59981
// begin repeat wait ( 0 0$1 ) ;
59963: LD_INT 35
59965: PPUSH
59966: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59970: LD_VAR 0 1
59974: PPUSH
59975: CALL_OW 312
59979: IFFALSE 59963
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59981: LD_VAR 0 1
59985: PPUSH
59986: LD_EXP 123
59990: PUSH
59991: LD_VAR 0 4
59995: ARRAY
59996: PPUSH
59997: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60001: LD_VAR 0 1
60005: PPUSH
60006: CALL_OW 263
60010: PUSH
60011: LD_INT 1
60013: NONEQUAL
60014: IFFALSE 60018
// break ;
60016: GO 60067
// repeat wait ( 0 0$1 ) ;
60018: LD_INT 35
60020: PPUSH
60021: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60025: LD_VAR 0 1
60029: PPUSH
60030: LD_EXP 123
60034: PUSH
60035: LD_VAR 0 4
60039: ARRAY
60040: PPUSH
60041: CALL_OW 308
60045: IFFALSE 60018
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60047: LD_VAR 0 1
60051: PPUSH
60052: CALL_OW 311
60056: PPUSH
60057: CALL_OW 121
// exit ;
60061: POP
60062: POP
60063: GO 60069
// end ; end ;
60065: GO 59722
60067: POP
60068: POP
// end ;
60069: LD_VAR 0 3
60073: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60074: LD_INT 0
60076: PPUSH
60077: PPUSH
60078: PPUSH
60079: PPUSH
// if not mc_bases or not skirmish then
60080: LD_EXP 99
60084: NOT
60085: PUSH
60086: LD_EXP 97
60090: NOT
60091: OR
60092: IFFALSE 60096
// exit ;
60094: GO 60449
// repeat wait ( 0 0$1 ) ;
60096: LD_INT 35
60098: PPUSH
60099: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60103: LD_VAR 0 2
60107: PPUSH
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 284
60117: IFFALSE 60096
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60119: LD_VAR 0 2
60123: PPUSH
60124: LD_VAR 0 3
60128: PPUSH
60129: CALL_OW 283
60133: PUSH
60134: LD_INT 4
60136: EQUAL
60137: IFFALSE 60141
// exit ;
60139: GO 60449
// for i = 1 to mc_bases do
60141: LD_ADDR_VAR 0 7
60145: PUSH
60146: DOUBLE
60147: LD_INT 1
60149: DEC
60150: ST_TO_ADDR
60151: LD_EXP 99
60155: PUSH
60156: FOR_TO
60157: IFFALSE 60447
// begin if mc_crates_area [ i ] then
60159: LD_EXP 117
60163: PUSH
60164: LD_VAR 0 7
60168: ARRAY
60169: IFFALSE 60280
// for j in mc_crates_area [ i ] do
60171: LD_ADDR_VAR 0 8
60175: PUSH
60176: LD_EXP 117
60180: PUSH
60181: LD_VAR 0 7
60185: ARRAY
60186: PUSH
60187: FOR_IN
60188: IFFALSE 60278
// if InArea ( x , y , j ) then
60190: LD_VAR 0 2
60194: PPUSH
60195: LD_VAR 0 3
60199: PPUSH
60200: LD_VAR 0 8
60204: PPUSH
60205: CALL_OW 309
60209: IFFALSE 60276
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60211: LD_ADDR_EXP 115
60215: PUSH
60216: LD_EXP 115
60220: PPUSH
60221: LD_VAR 0 7
60225: PUSH
60226: LD_EXP 115
60230: PUSH
60231: LD_VAR 0 7
60235: ARRAY
60236: PUSH
60237: LD_INT 1
60239: PLUS
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PPUSH
60245: LD_VAR 0 4
60249: PUSH
60250: LD_VAR 0 2
60254: PUSH
60255: LD_VAR 0 3
60259: PUSH
60260: EMPTY
60261: LIST
60262: LIST
60263: LIST
60264: PPUSH
60265: CALL 70361 0 3
60269: ST_TO_ADDR
// exit ;
60270: POP
60271: POP
60272: POP
60273: POP
60274: GO 60449
// end ;
60276: GO 60187
60278: POP
60279: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60280: LD_ADDR_VAR 0 9
60284: PUSH
60285: LD_EXP 99
60289: PUSH
60290: LD_VAR 0 7
60294: ARRAY
60295: PPUSH
60296: LD_INT 2
60298: PUSH
60299: LD_INT 30
60301: PUSH
60302: LD_INT 0
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PUSH
60309: LD_INT 30
60311: PUSH
60312: LD_INT 1
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: LIST
60323: PPUSH
60324: CALL_OW 72
60328: ST_TO_ADDR
// if not depot then
60329: LD_VAR 0 9
60333: NOT
60334: IFFALSE 60338
// continue ;
60336: GO 60156
// for j in depot do
60338: LD_ADDR_VAR 0 8
60342: PUSH
60343: LD_VAR 0 9
60347: PUSH
60348: FOR_IN
60349: IFFALSE 60443
// if GetDistUnitXY ( j , x , y ) < 30 then
60351: LD_VAR 0 8
60355: PPUSH
60356: LD_VAR 0 2
60360: PPUSH
60361: LD_VAR 0 3
60365: PPUSH
60366: CALL_OW 297
60370: PUSH
60371: LD_INT 30
60373: LESS
60374: IFFALSE 60441
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60376: LD_ADDR_EXP 115
60380: PUSH
60381: LD_EXP 115
60385: PPUSH
60386: LD_VAR 0 7
60390: PUSH
60391: LD_EXP 115
60395: PUSH
60396: LD_VAR 0 7
60400: ARRAY
60401: PUSH
60402: LD_INT 1
60404: PLUS
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PPUSH
60410: LD_VAR 0 4
60414: PUSH
60415: LD_VAR 0 2
60419: PUSH
60420: LD_VAR 0 3
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: LIST
60429: PPUSH
60430: CALL 70361 0 3
60434: ST_TO_ADDR
// exit ;
60435: POP
60436: POP
60437: POP
60438: POP
60439: GO 60449
// end ;
60441: GO 60348
60443: POP
60444: POP
// end ;
60445: GO 60156
60447: POP
60448: POP
// end ;
60449: LD_VAR 0 6
60453: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60454: LD_INT 0
60456: PPUSH
60457: PPUSH
60458: PPUSH
60459: PPUSH
// if not mc_bases or not skirmish then
60460: LD_EXP 99
60464: NOT
60465: PUSH
60466: LD_EXP 97
60470: NOT
60471: OR
60472: IFFALSE 60476
// exit ;
60474: GO 60753
// side := GetSide ( lab ) ;
60476: LD_ADDR_VAR 0 4
60480: PUSH
60481: LD_VAR 0 2
60485: PPUSH
60486: CALL_OW 255
60490: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60491: LD_VAR 0 4
60495: PUSH
60496: LD_EXP 125
60500: IN
60501: NOT
60502: PUSH
60503: LD_EXP 126
60507: NOT
60508: OR
60509: PUSH
60510: LD_EXP 99
60514: NOT
60515: OR
60516: IFFALSE 60520
// exit ;
60518: GO 60753
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60520: LD_ADDR_EXP 126
60524: PUSH
60525: LD_EXP 126
60529: PPUSH
60530: LD_VAR 0 4
60534: PPUSH
60535: LD_EXP 126
60539: PUSH
60540: LD_VAR 0 4
60544: ARRAY
60545: PUSH
60546: LD_VAR 0 1
60550: DIFF
60551: PPUSH
60552: CALL_OW 1
60556: ST_TO_ADDR
// for i = 1 to mc_bases do
60557: LD_ADDR_VAR 0 5
60561: PUSH
60562: DOUBLE
60563: LD_INT 1
60565: DEC
60566: ST_TO_ADDR
60567: LD_EXP 99
60571: PUSH
60572: FOR_TO
60573: IFFALSE 60751
// begin if lab in mc_bases [ i ] then
60575: LD_VAR 0 2
60579: PUSH
60580: LD_EXP 99
60584: PUSH
60585: LD_VAR 0 5
60589: ARRAY
60590: IN
60591: IFFALSE 60749
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60593: LD_VAR 0 1
60597: PUSH
60598: LD_INT 11
60600: PUSH
60601: LD_INT 4
60603: PUSH
60604: LD_INT 3
60606: PUSH
60607: LD_INT 2
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: LIST
60614: LIST
60615: IN
60616: PUSH
60617: LD_EXP 129
60621: PUSH
60622: LD_VAR 0 5
60626: ARRAY
60627: AND
60628: IFFALSE 60749
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60630: LD_ADDR_VAR 0 6
60634: PUSH
60635: LD_EXP 129
60639: PUSH
60640: LD_VAR 0 5
60644: ARRAY
60645: PUSH
60646: LD_INT 1
60648: ARRAY
60649: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60650: LD_ADDR_EXP 129
60654: PUSH
60655: LD_EXP 129
60659: PPUSH
60660: LD_VAR 0 5
60664: PPUSH
60665: EMPTY
60666: PPUSH
60667: CALL_OW 1
60671: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60672: LD_VAR 0 6
60676: PPUSH
60677: LD_INT 0
60679: PPUSH
60680: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60684: LD_VAR 0 6
60688: PPUSH
60689: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60693: LD_ADDR_EXP 128
60697: PUSH
60698: LD_EXP 128
60702: PPUSH
60703: LD_VAR 0 5
60707: PPUSH
60708: LD_EXP 128
60712: PUSH
60713: LD_VAR 0 5
60717: ARRAY
60718: PPUSH
60719: LD_INT 1
60721: PPUSH
60722: LD_VAR 0 6
60726: PPUSH
60727: CALL_OW 2
60731: PPUSH
60732: CALL_OW 1
60736: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60737: LD_VAR 0 5
60741: PPUSH
60742: LD_INT 112
60744: PPUSH
60745: CALL 37861 0 2
// end ; end ; end ;
60749: GO 60572
60751: POP
60752: POP
// end ;
60753: LD_VAR 0 3
60757: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60758: LD_INT 0
60760: PPUSH
60761: PPUSH
60762: PPUSH
60763: PPUSH
60764: PPUSH
60765: PPUSH
60766: PPUSH
60767: PPUSH
// if not mc_bases or not skirmish then
60768: LD_EXP 99
60772: NOT
60773: PUSH
60774: LD_EXP 97
60778: NOT
60779: OR
60780: IFFALSE 60784
// exit ;
60782: GO 61933
// for i = 1 to mc_bases do
60784: LD_ADDR_VAR 0 3
60788: PUSH
60789: DOUBLE
60790: LD_INT 1
60792: DEC
60793: ST_TO_ADDR
60794: LD_EXP 99
60798: PUSH
60799: FOR_TO
60800: IFFALSE 61931
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60802: LD_VAR 0 1
60806: PUSH
60807: LD_EXP 99
60811: PUSH
60812: LD_VAR 0 3
60816: ARRAY
60817: IN
60818: PUSH
60819: LD_VAR 0 1
60823: PUSH
60824: LD_EXP 106
60828: PUSH
60829: LD_VAR 0 3
60833: ARRAY
60834: IN
60835: OR
60836: PUSH
60837: LD_VAR 0 1
60841: PUSH
60842: LD_EXP 121
60846: PUSH
60847: LD_VAR 0 3
60851: ARRAY
60852: IN
60853: OR
60854: PUSH
60855: LD_VAR 0 1
60859: PUSH
60860: LD_EXP 118
60864: PUSH
60865: LD_VAR 0 3
60869: ARRAY
60870: IN
60871: OR
60872: PUSH
60873: LD_VAR 0 1
60877: PUSH
60878: LD_EXP 128
60882: PUSH
60883: LD_VAR 0 3
60887: ARRAY
60888: IN
60889: OR
60890: PUSH
60891: LD_VAR 0 1
60895: PUSH
60896: LD_EXP 129
60900: PUSH
60901: LD_VAR 0 3
60905: ARRAY
60906: IN
60907: OR
60908: IFFALSE 61929
// begin if un in mc_ape [ i ] then
60910: LD_VAR 0 1
60914: PUSH
60915: LD_EXP 128
60919: PUSH
60920: LD_VAR 0 3
60924: ARRAY
60925: IN
60926: IFFALSE 60965
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60928: LD_ADDR_EXP 128
60932: PUSH
60933: LD_EXP 128
60937: PPUSH
60938: LD_VAR 0 3
60942: PPUSH
60943: LD_EXP 128
60947: PUSH
60948: LD_VAR 0 3
60952: ARRAY
60953: PUSH
60954: LD_VAR 0 1
60958: DIFF
60959: PPUSH
60960: CALL_OW 1
60964: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60965: LD_VAR 0 1
60969: PUSH
60970: LD_EXP 129
60974: PUSH
60975: LD_VAR 0 3
60979: ARRAY
60980: IN
60981: IFFALSE 61005
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60983: LD_ADDR_EXP 129
60987: PUSH
60988: LD_EXP 129
60992: PPUSH
60993: LD_VAR 0 3
60997: PPUSH
60998: EMPTY
60999: PPUSH
61000: CALL_OW 1
61004: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
61005: LD_VAR 0 1
61009: PPUSH
61010: CALL_OW 247
61014: PUSH
61015: LD_INT 2
61017: EQUAL
61018: PUSH
61019: LD_VAR 0 1
61023: PPUSH
61024: CALL_OW 110
61028: PUSH
61029: LD_INT 20
61031: EQUAL
61032: PUSH
61033: LD_VAR 0 1
61037: PUSH
61038: LD_EXP 121
61042: PUSH
61043: LD_VAR 0 3
61047: ARRAY
61048: IN
61049: OR
61050: PUSH
61051: LD_VAR 0 1
61055: PPUSH
61056: CALL_OW 264
61060: PUSH
61061: LD_INT 12
61063: PUSH
61064: LD_INT 51
61066: PUSH
61067: LD_EXP 93
61071: PUSH
61072: LD_INT 32
61074: PUSH
61075: LD_INT 13
61077: PUSH
61078: LD_INT 52
61080: PUSH
61081: EMPTY
61082: LIST
61083: LIST
61084: LIST
61085: LIST
61086: LIST
61087: LIST
61088: IN
61089: OR
61090: AND
61091: IFFALSE 61269
// begin if un in mc_defender [ i ] then
61093: LD_VAR 0 1
61097: PUSH
61098: LD_EXP 121
61102: PUSH
61103: LD_VAR 0 3
61107: ARRAY
61108: IN
61109: IFFALSE 61148
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61111: LD_ADDR_EXP 121
61115: PUSH
61116: LD_EXP 121
61120: PPUSH
61121: LD_VAR 0 3
61125: PPUSH
61126: LD_EXP 121
61130: PUSH
61131: LD_VAR 0 3
61135: ARRAY
61136: PUSH
61137: LD_VAR 0 1
61141: DIFF
61142: PPUSH
61143: CALL_OW 1
61147: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61148: LD_ADDR_VAR 0 8
61152: PUSH
61153: LD_VAR 0 3
61157: PPUSH
61158: LD_INT 3
61160: PPUSH
61161: CALL 57821 0 2
61165: ST_TO_ADDR
// if fac then
61166: LD_VAR 0 8
61170: IFFALSE 61269
// begin for j in fac do
61172: LD_ADDR_VAR 0 4
61176: PUSH
61177: LD_VAR 0 8
61181: PUSH
61182: FOR_IN
61183: IFFALSE 61267
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61185: LD_ADDR_VAR 0 9
61189: PUSH
61190: LD_VAR 0 8
61194: PPUSH
61195: LD_VAR 0 1
61199: PPUSH
61200: CALL_OW 265
61204: PPUSH
61205: LD_VAR 0 1
61209: PPUSH
61210: CALL_OW 262
61214: PPUSH
61215: LD_VAR 0 1
61219: PPUSH
61220: CALL_OW 263
61224: PPUSH
61225: LD_VAR 0 1
61229: PPUSH
61230: CALL_OW 264
61234: PPUSH
61235: CALL 67893 0 5
61239: ST_TO_ADDR
// if components then
61240: LD_VAR 0 9
61244: IFFALSE 61265
// begin MC_InsertProduceList ( i , [ components ] ) ;
61246: LD_VAR 0 3
61250: PPUSH
61251: LD_VAR 0 9
61255: PUSH
61256: EMPTY
61257: LIST
61258: PPUSH
61259: CALL 57366 0 2
// break ;
61263: GO 61267
// end ; end ;
61265: GO 61182
61267: POP
61268: POP
// end ; end ; if GetType ( un ) = unit_building then
61269: LD_VAR 0 1
61273: PPUSH
61274: CALL_OW 247
61278: PUSH
61279: LD_INT 3
61281: EQUAL
61282: IFFALSE 61597
// begin btype := GetBType ( un ) ;
61284: LD_ADDR_VAR 0 5
61288: PUSH
61289: LD_VAR 0 1
61293: PPUSH
61294: CALL_OW 266
61298: ST_TO_ADDR
// if btype = b_warehouse then
61299: LD_VAR 0 5
61303: PUSH
61304: LD_INT 1
61306: EQUAL
61307: IFFALSE 61325
// begin btype := b_depot ;
61309: LD_ADDR_VAR 0 5
61313: PUSH
61314: LD_INT 0
61316: ST_TO_ADDR
// pos := 1 ;
61317: LD_ADDR_VAR 0 6
61321: PUSH
61322: LD_INT 1
61324: ST_TO_ADDR
// end ; if btype = b_factory then
61325: LD_VAR 0 5
61329: PUSH
61330: LD_INT 3
61332: EQUAL
61333: IFFALSE 61351
// begin btype := b_workshop ;
61335: LD_ADDR_VAR 0 5
61339: PUSH
61340: LD_INT 2
61342: ST_TO_ADDR
// pos := 1 ;
61343: LD_ADDR_VAR 0 6
61347: PUSH
61348: LD_INT 1
61350: ST_TO_ADDR
// end ; if btype = b_barracks then
61351: LD_VAR 0 5
61355: PUSH
61356: LD_INT 5
61358: EQUAL
61359: IFFALSE 61369
// btype := b_armoury ;
61361: LD_ADDR_VAR 0 5
61365: PUSH
61366: LD_INT 4
61368: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61369: LD_VAR 0 5
61373: PUSH
61374: LD_INT 7
61376: PUSH
61377: LD_INT 8
61379: PUSH
61380: EMPTY
61381: LIST
61382: LIST
61383: IN
61384: IFFALSE 61394
// btype := b_lab ;
61386: LD_ADDR_VAR 0 5
61390: PUSH
61391: LD_INT 6
61393: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61394: LD_ADDR_EXP 104
61398: PUSH
61399: LD_EXP 104
61403: PPUSH
61404: LD_VAR 0 3
61408: PUSH
61409: LD_EXP 104
61413: PUSH
61414: LD_VAR 0 3
61418: ARRAY
61419: PUSH
61420: LD_INT 1
61422: PLUS
61423: PUSH
61424: EMPTY
61425: LIST
61426: LIST
61427: PPUSH
61428: LD_VAR 0 5
61432: PUSH
61433: LD_VAR 0 1
61437: PPUSH
61438: CALL_OW 250
61442: PUSH
61443: LD_VAR 0 1
61447: PPUSH
61448: CALL_OW 251
61452: PUSH
61453: LD_VAR 0 1
61457: PPUSH
61458: CALL_OW 254
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: LIST
61467: LIST
61468: PPUSH
61469: CALL 70361 0 3
61473: ST_TO_ADDR
// if pos = 1 then
61474: LD_VAR 0 6
61478: PUSH
61479: LD_INT 1
61481: EQUAL
61482: IFFALSE 61597
// begin tmp := mc_build_list [ i ] ;
61484: LD_ADDR_VAR 0 7
61488: PUSH
61489: LD_EXP 104
61493: PUSH
61494: LD_VAR 0 3
61498: ARRAY
61499: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61500: LD_VAR 0 7
61504: PPUSH
61505: LD_INT 2
61507: PUSH
61508: LD_INT 30
61510: PUSH
61511: LD_INT 0
61513: PUSH
61514: EMPTY
61515: LIST
61516: LIST
61517: PUSH
61518: LD_INT 30
61520: PUSH
61521: LD_INT 1
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: LIST
61532: PPUSH
61533: CALL_OW 72
61537: IFFALSE 61547
// pos := 2 ;
61539: LD_ADDR_VAR 0 6
61543: PUSH
61544: LD_INT 2
61546: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
61547: LD_ADDR_VAR 0 7
61551: PUSH
61552: LD_VAR 0 7
61556: PPUSH
61557: LD_VAR 0 6
61561: PPUSH
61562: LD_VAR 0 7
61566: PPUSH
61567: CALL 70687 0 3
61571: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61572: LD_ADDR_EXP 104
61576: PUSH
61577: LD_EXP 104
61581: PPUSH
61582: LD_VAR 0 3
61586: PPUSH
61587: LD_VAR 0 7
61591: PPUSH
61592: CALL_OW 1
61596: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61597: LD_VAR 0 1
61601: PUSH
61602: LD_EXP 99
61606: PUSH
61607: LD_VAR 0 3
61611: ARRAY
61612: IN
61613: IFFALSE 61652
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61615: LD_ADDR_EXP 99
61619: PUSH
61620: LD_EXP 99
61624: PPUSH
61625: LD_VAR 0 3
61629: PPUSH
61630: LD_EXP 99
61634: PUSH
61635: LD_VAR 0 3
61639: ARRAY
61640: PUSH
61641: LD_VAR 0 1
61645: DIFF
61646: PPUSH
61647: CALL_OW 1
61651: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61652: LD_VAR 0 1
61656: PUSH
61657: LD_EXP 106
61661: PUSH
61662: LD_VAR 0 3
61666: ARRAY
61667: IN
61668: IFFALSE 61707
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61670: LD_ADDR_EXP 106
61674: PUSH
61675: LD_EXP 106
61679: PPUSH
61680: LD_VAR 0 3
61684: PPUSH
61685: LD_EXP 106
61689: PUSH
61690: LD_VAR 0 3
61694: ARRAY
61695: PUSH
61696: LD_VAR 0 1
61700: DIFF
61701: PPUSH
61702: CALL_OW 1
61706: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61707: LD_VAR 0 1
61711: PUSH
61712: LD_EXP 118
61716: PUSH
61717: LD_VAR 0 3
61721: ARRAY
61722: IN
61723: IFFALSE 61762
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61725: LD_ADDR_EXP 118
61729: PUSH
61730: LD_EXP 118
61734: PPUSH
61735: LD_VAR 0 3
61739: PPUSH
61740: LD_EXP 118
61744: PUSH
61745: LD_VAR 0 3
61749: ARRAY
61750: PUSH
61751: LD_VAR 0 1
61755: DIFF
61756: PPUSH
61757: CALL_OW 1
61761: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61762: LD_VAR 0 1
61766: PUSH
61767: LD_EXP 121
61771: PUSH
61772: LD_VAR 0 3
61776: ARRAY
61777: IN
61778: IFFALSE 61817
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61780: LD_ADDR_EXP 121
61784: PUSH
61785: LD_EXP 121
61789: PPUSH
61790: LD_VAR 0 3
61794: PPUSH
61795: LD_EXP 121
61799: PUSH
61800: LD_VAR 0 3
61804: ARRAY
61805: PUSH
61806: LD_VAR 0 1
61810: DIFF
61811: PPUSH
61812: CALL_OW 1
61816: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61817: LD_VAR 0 1
61821: PUSH
61822: LD_EXP 108
61826: PUSH
61827: LD_VAR 0 3
61831: ARRAY
61832: IN
61833: IFFALSE 61872
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61835: LD_ADDR_EXP 108
61839: PUSH
61840: LD_EXP 108
61844: PPUSH
61845: LD_VAR 0 3
61849: PPUSH
61850: LD_EXP 108
61854: PUSH
61855: LD_VAR 0 3
61859: ARRAY
61860: PUSH
61861: LD_VAR 0 1
61865: DIFF
61866: PPUSH
61867: CALL_OW 1
61871: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61872: LD_VAR 0 1
61876: PUSH
61877: LD_EXP 107
61881: PUSH
61882: LD_VAR 0 3
61886: ARRAY
61887: IN
61888: IFFALSE 61927
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61890: LD_ADDR_EXP 107
61894: PUSH
61895: LD_EXP 107
61899: PPUSH
61900: LD_VAR 0 3
61904: PPUSH
61905: LD_EXP 107
61909: PUSH
61910: LD_VAR 0 3
61914: ARRAY
61915: PUSH
61916: LD_VAR 0 1
61920: DIFF
61921: PPUSH
61922: CALL_OW 1
61926: ST_TO_ADDR
// end ; break ;
61927: GO 61931
// end ;
61929: GO 60799
61931: POP
61932: POP
// end ;
61933: LD_VAR 0 2
61937: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61938: LD_INT 0
61940: PPUSH
61941: PPUSH
61942: PPUSH
// if not mc_bases or not skirmish then
61943: LD_EXP 99
61947: NOT
61948: PUSH
61949: LD_EXP 97
61953: NOT
61954: OR
61955: IFFALSE 61959
// exit ;
61957: GO 62174
// for i = 1 to mc_bases do
61959: LD_ADDR_VAR 0 3
61963: PUSH
61964: DOUBLE
61965: LD_INT 1
61967: DEC
61968: ST_TO_ADDR
61969: LD_EXP 99
61973: PUSH
61974: FOR_TO
61975: IFFALSE 62172
// begin if building in mc_construct_list [ i ] then
61977: LD_VAR 0 1
61981: PUSH
61982: LD_EXP 106
61986: PUSH
61987: LD_VAR 0 3
61991: ARRAY
61992: IN
61993: IFFALSE 62170
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61995: LD_ADDR_EXP 106
61999: PUSH
62000: LD_EXP 106
62004: PPUSH
62005: LD_VAR 0 3
62009: PPUSH
62010: LD_EXP 106
62014: PUSH
62015: LD_VAR 0 3
62019: ARRAY
62020: PUSH
62021: LD_VAR 0 1
62025: DIFF
62026: PPUSH
62027: CALL_OW 1
62031: ST_TO_ADDR
// if building in mc_lab [ i ] then
62032: LD_VAR 0 1
62036: PUSH
62037: LD_EXP 132
62041: PUSH
62042: LD_VAR 0 3
62046: ARRAY
62047: IN
62048: IFFALSE 62103
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62050: LD_ADDR_EXP 133
62054: PUSH
62055: LD_EXP 133
62059: PPUSH
62060: LD_VAR 0 3
62064: PPUSH
62065: LD_EXP 133
62069: PUSH
62070: LD_VAR 0 3
62074: ARRAY
62075: PPUSH
62076: LD_INT 1
62078: PPUSH
62079: LD_EXP 133
62083: PUSH
62084: LD_VAR 0 3
62088: ARRAY
62089: PPUSH
62090: LD_INT 0
62092: PPUSH
62093: CALL 69779 0 4
62097: PPUSH
62098: CALL_OW 1
62102: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62103: LD_VAR 0 1
62107: PUSH
62108: LD_EXP 99
62112: PUSH
62113: LD_VAR 0 3
62117: ARRAY
62118: IN
62119: NOT
62120: IFFALSE 62166
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62122: LD_ADDR_EXP 99
62126: PUSH
62127: LD_EXP 99
62131: PPUSH
62132: LD_VAR 0 3
62136: PUSH
62137: LD_EXP 99
62141: PUSH
62142: LD_VAR 0 3
62146: ARRAY
62147: PUSH
62148: LD_INT 1
62150: PLUS
62151: PUSH
62152: EMPTY
62153: LIST
62154: LIST
62155: PPUSH
62156: LD_VAR 0 1
62160: PPUSH
62161: CALL 70361 0 3
62165: ST_TO_ADDR
// exit ;
62166: POP
62167: POP
62168: GO 62174
// end ; end ;
62170: GO 61974
62172: POP
62173: POP
// end ;
62174: LD_VAR 0 2
62178: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62179: LD_INT 0
62181: PPUSH
62182: PPUSH
62183: PPUSH
62184: PPUSH
62185: PPUSH
62186: PPUSH
62187: PPUSH
// if not mc_bases or not skirmish then
62188: LD_EXP 99
62192: NOT
62193: PUSH
62194: LD_EXP 97
62198: NOT
62199: OR
62200: IFFALSE 62204
// exit ;
62202: GO 62865
// for i = 1 to mc_bases do
62204: LD_ADDR_VAR 0 3
62208: PUSH
62209: DOUBLE
62210: LD_INT 1
62212: DEC
62213: ST_TO_ADDR
62214: LD_EXP 99
62218: PUSH
62219: FOR_TO
62220: IFFALSE 62863
// begin if building in mc_construct_list [ i ] then
62222: LD_VAR 0 1
62226: PUSH
62227: LD_EXP 106
62231: PUSH
62232: LD_VAR 0 3
62236: ARRAY
62237: IN
62238: IFFALSE 62861
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62240: LD_ADDR_EXP 106
62244: PUSH
62245: LD_EXP 106
62249: PPUSH
62250: LD_VAR 0 3
62254: PPUSH
62255: LD_EXP 106
62259: PUSH
62260: LD_VAR 0 3
62264: ARRAY
62265: PUSH
62266: LD_VAR 0 1
62270: DIFF
62271: PPUSH
62272: CALL_OW 1
62276: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62277: LD_ADDR_EXP 99
62281: PUSH
62282: LD_EXP 99
62286: PPUSH
62287: LD_VAR 0 3
62291: PUSH
62292: LD_EXP 99
62296: PUSH
62297: LD_VAR 0 3
62301: ARRAY
62302: PUSH
62303: LD_INT 1
62305: PLUS
62306: PUSH
62307: EMPTY
62308: LIST
62309: LIST
62310: PPUSH
62311: LD_VAR 0 1
62315: PPUSH
62316: CALL 70361 0 3
62320: ST_TO_ADDR
// btype := GetBType ( building ) ;
62321: LD_ADDR_VAR 0 5
62325: PUSH
62326: LD_VAR 0 1
62330: PPUSH
62331: CALL_OW 266
62335: ST_TO_ADDR
// side := GetSide ( building ) ;
62336: LD_ADDR_VAR 0 8
62340: PUSH
62341: LD_VAR 0 1
62345: PPUSH
62346: CALL_OW 255
62350: ST_TO_ADDR
// if btype = b_lab then
62351: LD_VAR 0 5
62355: PUSH
62356: LD_INT 6
62358: EQUAL
62359: IFFALSE 62409
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62361: LD_ADDR_EXP 132
62365: PUSH
62366: LD_EXP 132
62370: PPUSH
62371: LD_VAR 0 3
62375: PUSH
62376: LD_EXP 132
62380: PUSH
62381: LD_VAR 0 3
62385: ARRAY
62386: PUSH
62387: LD_INT 1
62389: PLUS
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: PPUSH
62395: LD_VAR 0 1
62399: PPUSH
62400: CALL 70361 0 3
62404: ST_TO_ADDR
// exit ;
62405: POP
62406: POP
62407: GO 62865
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62409: LD_VAR 0 5
62413: PUSH
62414: LD_INT 0
62416: PUSH
62417: LD_INT 2
62419: PUSH
62420: LD_INT 4
62422: PUSH
62423: EMPTY
62424: LIST
62425: LIST
62426: LIST
62427: IN
62428: IFFALSE 62552
// begin if btype = b_armoury then
62430: LD_VAR 0 5
62434: PUSH
62435: LD_INT 4
62437: EQUAL
62438: IFFALSE 62448
// btype := b_barracks ;
62440: LD_ADDR_VAR 0 5
62444: PUSH
62445: LD_INT 5
62447: ST_TO_ADDR
// if btype = b_depot then
62448: LD_VAR 0 5
62452: PUSH
62453: LD_INT 0
62455: EQUAL
62456: IFFALSE 62466
// btype := b_warehouse ;
62458: LD_ADDR_VAR 0 5
62462: PUSH
62463: LD_INT 1
62465: ST_TO_ADDR
// if btype = b_workshop then
62466: LD_VAR 0 5
62470: PUSH
62471: LD_INT 2
62473: EQUAL
62474: IFFALSE 62484
// btype := b_factory ;
62476: LD_ADDR_VAR 0 5
62480: PUSH
62481: LD_INT 3
62483: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
62484: LD_VAR 0 5
62488: PPUSH
62489: LD_VAR 0 8
62493: PPUSH
62494: CALL_OW 323
62498: PUSH
62499: LD_INT 1
62501: EQUAL
62502: IFFALSE 62548
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
62504: LD_ADDR_EXP 131
62508: PUSH
62509: LD_EXP 131
62513: PPUSH
62514: LD_VAR 0 3
62518: PUSH
62519: LD_EXP 131
62523: PUSH
62524: LD_VAR 0 3
62528: ARRAY
62529: PUSH
62530: LD_INT 1
62532: PLUS
62533: PUSH
62534: EMPTY
62535: LIST
62536: LIST
62537: PPUSH
62538: LD_VAR 0 1
62542: PPUSH
62543: CALL 70361 0 3
62547: ST_TO_ADDR
// exit ;
62548: POP
62549: POP
62550: GO 62865
// end ; if btype in [ b_bunker , b_turret ] then
62552: LD_VAR 0 5
62556: PUSH
62557: LD_INT 32
62559: PUSH
62560: LD_INT 33
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: IN
62567: IFFALSE 62857
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62569: LD_ADDR_EXP 107
62573: PUSH
62574: LD_EXP 107
62578: PPUSH
62579: LD_VAR 0 3
62583: PUSH
62584: LD_EXP 107
62588: PUSH
62589: LD_VAR 0 3
62593: ARRAY
62594: PUSH
62595: LD_INT 1
62597: PLUS
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: PPUSH
62603: LD_VAR 0 1
62607: PPUSH
62608: CALL 70361 0 3
62612: ST_TO_ADDR
// if btype = b_bunker then
62613: LD_VAR 0 5
62617: PUSH
62618: LD_INT 32
62620: EQUAL
62621: IFFALSE 62857
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62623: LD_ADDR_EXP 108
62627: PUSH
62628: LD_EXP 108
62632: PPUSH
62633: LD_VAR 0 3
62637: PUSH
62638: LD_EXP 108
62642: PUSH
62643: LD_VAR 0 3
62647: ARRAY
62648: PUSH
62649: LD_INT 1
62651: PLUS
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PPUSH
62657: LD_VAR 0 1
62661: PPUSH
62662: CALL 70361 0 3
62666: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62667: LD_ADDR_VAR 0 6
62671: PUSH
62672: LD_EXP 99
62676: PUSH
62677: LD_VAR 0 3
62681: ARRAY
62682: PPUSH
62683: LD_INT 25
62685: PUSH
62686: LD_INT 1
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_INT 3
62695: PUSH
62696: LD_INT 54
62698: PUSH
62699: EMPTY
62700: LIST
62701: PUSH
62702: EMPTY
62703: LIST
62704: LIST
62705: PUSH
62706: EMPTY
62707: LIST
62708: LIST
62709: PPUSH
62710: CALL_OW 72
62714: ST_TO_ADDR
// if tmp then
62715: LD_VAR 0 6
62719: IFFALSE 62725
// exit ;
62721: POP
62722: POP
62723: GO 62865
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62725: LD_ADDR_VAR 0 6
62729: PUSH
62730: LD_EXP 99
62734: PUSH
62735: LD_VAR 0 3
62739: ARRAY
62740: PPUSH
62741: LD_INT 2
62743: PUSH
62744: LD_INT 30
62746: PUSH
62747: LD_INT 4
62749: PUSH
62750: EMPTY
62751: LIST
62752: LIST
62753: PUSH
62754: LD_INT 30
62756: PUSH
62757: LD_INT 5
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: PUSH
62764: EMPTY
62765: LIST
62766: LIST
62767: LIST
62768: PPUSH
62769: CALL_OW 72
62773: ST_TO_ADDR
// if not tmp then
62774: LD_VAR 0 6
62778: NOT
62779: IFFALSE 62785
// exit ;
62781: POP
62782: POP
62783: GO 62865
// for j in tmp do
62785: LD_ADDR_VAR 0 4
62789: PUSH
62790: LD_VAR 0 6
62794: PUSH
62795: FOR_IN
62796: IFFALSE 62855
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62798: LD_ADDR_VAR 0 7
62802: PUSH
62803: LD_VAR 0 4
62807: PPUSH
62808: CALL_OW 313
62812: PPUSH
62813: LD_INT 25
62815: PUSH
62816: LD_INT 1
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PPUSH
62823: CALL_OW 72
62827: ST_TO_ADDR
// if units then
62828: LD_VAR 0 7
62832: IFFALSE 62853
// begin ComExitBuilding ( units [ 1 ] ) ;
62834: LD_VAR 0 7
62838: PUSH
62839: LD_INT 1
62841: ARRAY
62842: PPUSH
62843: CALL_OW 122
// exit ;
62847: POP
62848: POP
62849: POP
62850: POP
62851: GO 62865
// end ; end ;
62853: GO 62795
62855: POP
62856: POP
// end ; end ; exit ;
62857: POP
62858: POP
62859: GO 62865
// end ; end ;
62861: GO 62219
62863: POP
62864: POP
// end ;
62865: LD_VAR 0 2
62869: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62870: LD_INT 0
62872: PPUSH
62873: PPUSH
62874: PPUSH
62875: PPUSH
62876: PPUSH
62877: PPUSH
62878: PPUSH
// if not mc_bases or not skirmish then
62879: LD_EXP 99
62883: NOT
62884: PUSH
62885: LD_EXP 97
62889: NOT
62890: OR
62891: IFFALSE 62895
// exit ;
62893: GO 63126
// btype := GetBType ( building ) ;
62895: LD_ADDR_VAR 0 6
62899: PUSH
62900: LD_VAR 0 1
62904: PPUSH
62905: CALL_OW 266
62909: ST_TO_ADDR
// x := GetX ( building ) ;
62910: LD_ADDR_VAR 0 7
62914: PUSH
62915: LD_VAR 0 1
62919: PPUSH
62920: CALL_OW 250
62924: ST_TO_ADDR
// y := GetY ( building ) ;
62925: LD_ADDR_VAR 0 8
62929: PUSH
62930: LD_VAR 0 1
62934: PPUSH
62935: CALL_OW 251
62939: ST_TO_ADDR
// d := GetDir ( building ) ;
62940: LD_ADDR_VAR 0 9
62944: PUSH
62945: LD_VAR 0 1
62949: PPUSH
62950: CALL_OW 254
62954: ST_TO_ADDR
// for i = 1 to mc_bases do
62955: LD_ADDR_VAR 0 4
62959: PUSH
62960: DOUBLE
62961: LD_INT 1
62963: DEC
62964: ST_TO_ADDR
62965: LD_EXP 99
62969: PUSH
62970: FOR_TO
62971: IFFALSE 63124
// begin if not mc_build_list [ i ] then
62973: LD_EXP 104
62977: PUSH
62978: LD_VAR 0 4
62982: ARRAY
62983: NOT
62984: IFFALSE 62988
// continue ;
62986: GO 62970
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62988: LD_VAR 0 6
62992: PUSH
62993: LD_VAR 0 7
62997: PUSH
62998: LD_VAR 0 8
63002: PUSH
63003: LD_VAR 0 9
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: PPUSH
63014: LD_EXP 104
63018: PUSH
63019: LD_VAR 0 4
63023: ARRAY
63024: PUSH
63025: LD_INT 1
63027: ARRAY
63028: PPUSH
63029: CALL 76530 0 2
63033: IFFALSE 63122
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63035: LD_ADDR_EXP 104
63039: PUSH
63040: LD_EXP 104
63044: PPUSH
63045: LD_VAR 0 4
63049: PPUSH
63050: LD_EXP 104
63054: PUSH
63055: LD_VAR 0 4
63059: ARRAY
63060: PPUSH
63061: LD_INT 1
63063: PPUSH
63064: CALL_OW 3
63068: PPUSH
63069: CALL_OW 1
63073: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63074: LD_ADDR_EXP 106
63078: PUSH
63079: LD_EXP 106
63083: PPUSH
63084: LD_VAR 0 4
63088: PUSH
63089: LD_EXP 106
63093: PUSH
63094: LD_VAR 0 4
63098: ARRAY
63099: PUSH
63100: LD_INT 1
63102: PLUS
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PPUSH
63108: LD_VAR 0 1
63112: PPUSH
63113: CALL 70361 0 3
63117: ST_TO_ADDR
// exit ;
63118: POP
63119: POP
63120: GO 63126
// end ; end ;
63122: GO 62970
63124: POP
63125: POP
// end ;
63126: LD_VAR 0 3
63130: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63131: LD_INT 0
63133: PPUSH
63134: PPUSH
63135: PPUSH
// if not mc_bases or not skirmish then
63136: LD_EXP 99
63140: NOT
63141: PUSH
63142: LD_EXP 97
63146: NOT
63147: OR
63148: IFFALSE 63152
// exit ;
63150: GO 63342
// for i = 1 to mc_bases do
63152: LD_ADDR_VAR 0 4
63156: PUSH
63157: DOUBLE
63158: LD_INT 1
63160: DEC
63161: ST_TO_ADDR
63162: LD_EXP 99
63166: PUSH
63167: FOR_TO
63168: IFFALSE 63255
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63170: LD_VAR 0 1
63174: PUSH
63175: LD_EXP 107
63179: PUSH
63180: LD_VAR 0 4
63184: ARRAY
63185: IN
63186: PUSH
63187: LD_VAR 0 1
63191: PUSH
63192: LD_EXP 108
63196: PUSH
63197: LD_VAR 0 4
63201: ARRAY
63202: IN
63203: NOT
63204: AND
63205: IFFALSE 63253
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63207: LD_ADDR_EXP 108
63211: PUSH
63212: LD_EXP 108
63216: PPUSH
63217: LD_VAR 0 4
63221: PUSH
63222: LD_EXP 108
63226: PUSH
63227: LD_VAR 0 4
63231: ARRAY
63232: PUSH
63233: LD_INT 1
63235: PLUS
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PPUSH
63241: LD_VAR 0 1
63245: PPUSH
63246: CALL 70361 0 3
63250: ST_TO_ADDR
// break ;
63251: GO 63255
// end ; end ;
63253: GO 63167
63255: POP
63256: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63257: LD_VAR 0 1
63261: PPUSH
63262: CALL_OW 257
63266: PUSH
63267: LD_EXP 125
63271: IN
63272: PUSH
63273: LD_VAR 0 1
63277: PPUSH
63278: CALL_OW 266
63282: PUSH
63283: LD_INT 5
63285: EQUAL
63286: AND
63287: PUSH
63288: LD_VAR 0 2
63292: PPUSH
63293: CALL_OW 110
63297: PUSH
63298: LD_INT 18
63300: NONEQUAL
63301: AND
63302: IFFALSE 63342
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63304: LD_VAR 0 2
63308: PPUSH
63309: CALL_OW 257
63313: PUSH
63314: LD_INT 5
63316: PUSH
63317: LD_INT 8
63319: PUSH
63320: LD_INT 9
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: LIST
63327: IN
63328: IFFALSE 63342
// SetClass ( unit , 1 ) ;
63330: LD_VAR 0 2
63334: PPUSH
63335: LD_INT 1
63337: PPUSH
63338: CALL_OW 336
// end ;
63342: LD_VAR 0 3
63346: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63347: LD_INT 0
63349: PPUSH
63350: PPUSH
// if not mc_bases or not skirmish then
63351: LD_EXP 99
63355: NOT
63356: PUSH
63357: LD_EXP 97
63361: NOT
63362: OR
63363: IFFALSE 63367
// exit ;
63365: GO 63483
// if GetLives ( abandoned_vehicle ) > 250 then
63367: LD_VAR 0 2
63371: PPUSH
63372: CALL_OW 256
63376: PUSH
63377: LD_INT 250
63379: GREATER
63380: IFFALSE 63384
// exit ;
63382: GO 63483
// for i = 1 to mc_bases do
63384: LD_ADDR_VAR 0 6
63388: PUSH
63389: DOUBLE
63390: LD_INT 1
63392: DEC
63393: ST_TO_ADDR
63394: LD_EXP 99
63398: PUSH
63399: FOR_TO
63400: IFFALSE 63481
// begin if driver in mc_bases [ i ] then
63402: LD_VAR 0 1
63406: PUSH
63407: LD_EXP 99
63411: PUSH
63412: LD_VAR 0 6
63416: ARRAY
63417: IN
63418: IFFALSE 63479
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63420: LD_VAR 0 1
63424: PPUSH
63425: LD_EXP 99
63429: PUSH
63430: LD_VAR 0 6
63434: ARRAY
63435: PPUSH
63436: LD_INT 2
63438: PUSH
63439: LD_INT 30
63441: PUSH
63442: LD_INT 0
63444: PUSH
63445: EMPTY
63446: LIST
63447: LIST
63448: PUSH
63449: LD_INT 30
63451: PUSH
63452: LD_INT 1
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PUSH
63459: EMPTY
63460: LIST
63461: LIST
63462: LIST
63463: PPUSH
63464: CALL_OW 72
63468: PUSH
63469: LD_INT 1
63471: ARRAY
63472: PPUSH
63473: CALL_OW 112
// break ;
63477: GO 63481
// end ; end ;
63479: GO 63399
63481: POP
63482: POP
// end ; end_of_file
63483: LD_VAR 0 5
63487: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63488: LD_INT 0
63490: PPUSH
63491: PPUSH
// if exist_mode then
63492: LD_VAR 0 2
63496: IFFALSE 63521
// unit := CreateCharacter ( prefix & ident ) else
63498: LD_ADDR_VAR 0 5
63502: PUSH
63503: LD_VAR 0 3
63507: PUSH
63508: LD_VAR 0 1
63512: STR
63513: PPUSH
63514: CALL_OW 34
63518: ST_TO_ADDR
63519: GO 63536
// unit := NewCharacter ( ident ) ;
63521: LD_ADDR_VAR 0 5
63525: PUSH
63526: LD_VAR 0 1
63530: PPUSH
63531: CALL_OW 25
63535: ST_TO_ADDR
// result := unit ;
63536: LD_ADDR_VAR 0 4
63540: PUSH
63541: LD_VAR 0 5
63545: ST_TO_ADDR
// end ;
63546: LD_VAR 0 4
63550: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63551: LD_INT 0
63553: PPUSH
63554: PPUSH
// if not side or not nation then
63555: LD_VAR 0 1
63559: NOT
63560: PUSH
63561: LD_VAR 0 2
63565: NOT
63566: OR
63567: IFFALSE 63571
// exit ;
63569: GO 64215
// case nation of nation_american :
63571: LD_VAR 0 2
63575: PUSH
63576: LD_INT 1
63578: DOUBLE
63579: EQUAL
63580: IFTRUE 63584
63582: GO 63758
63584: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
63585: LD_ADDR_VAR 0 4
63589: PUSH
63590: LD_INT 35
63592: PUSH
63593: LD_INT 45
63595: PUSH
63596: LD_INT 46
63598: PUSH
63599: LD_INT 47
63601: PUSH
63602: LD_INT 1
63604: PUSH
63605: LD_INT 2
63607: PUSH
63608: LD_INT 6
63610: PUSH
63611: LD_INT 15
63613: PUSH
63614: LD_INT 16
63616: PUSH
63617: LD_INT 7
63619: PUSH
63620: LD_INT 12
63622: PUSH
63623: LD_INT 13
63625: PUSH
63626: LD_INT 10
63628: PUSH
63629: LD_INT 14
63631: PUSH
63632: LD_INT 20
63634: PUSH
63635: LD_INT 21
63637: PUSH
63638: LD_INT 22
63640: PUSH
63641: LD_INT 25
63643: PUSH
63644: LD_INT 32
63646: PUSH
63647: LD_INT 27
63649: PUSH
63650: LD_INT 36
63652: PUSH
63653: LD_INT 69
63655: PUSH
63656: LD_INT 39
63658: PUSH
63659: LD_INT 34
63661: PUSH
63662: LD_INT 40
63664: PUSH
63665: LD_INT 48
63667: PUSH
63668: LD_INT 49
63670: PUSH
63671: LD_INT 50
63673: PUSH
63674: LD_INT 51
63676: PUSH
63677: LD_INT 52
63679: PUSH
63680: LD_INT 53
63682: PUSH
63683: LD_INT 54
63685: PUSH
63686: LD_INT 55
63688: PUSH
63689: LD_INT 56
63691: PUSH
63692: LD_INT 57
63694: PUSH
63695: LD_INT 58
63697: PUSH
63698: LD_INT 59
63700: PUSH
63701: LD_INT 60
63703: PUSH
63704: LD_INT 61
63706: PUSH
63707: LD_INT 62
63709: PUSH
63710: LD_INT 80
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: LIST
63745: LIST
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: ST_TO_ADDR
63756: GO 64139
63758: LD_INT 2
63760: DOUBLE
63761: EQUAL
63762: IFTRUE 63766
63764: GO 63948
63766: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
63767: LD_ADDR_VAR 0 4
63771: PUSH
63772: LD_INT 35
63774: PUSH
63775: LD_INT 45
63777: PUSH
63778: LD_INT 46
63780: PUSH
63781: LD_INT 47
63783: PUSH
63784: LD_INT 70
63786: PUSH
63787: LD_INT 1
63789: PUSH
63790: LD_INT 11
63792: PUSH
63793: LD_INT 3
63795: PUSH
63796: LD_INT 4
63798: PUSH
63799: LD_INT 5
63801: PUSH
63802: LD_INT 6
63804: PUSH
63805: LD_INT 15
63807: PUSH
63808: LD_INT 18
63810: PUSH
63811: LD_INT 7
63813: PUSH
63814: LD_INT 17
63816: PUSH
63817: LD_INT 8
63819: PUSH
63820: LD_INT 20
63822: PUSH
63823: LD_INT 21
63825: PUSH
63826: LD_INT 22
63828: PUSH
63829: LD_INT 72
63831: PUSH
63832: LD_INT 26
63834: PUSH
63835: LD_INT 69
63837: PUSH
63838: LD_INT 39
63840: PUSH
63841: LD_INT 40
63843: PUSH
63844: LD_INT 41
63846: PUSH
63847: LD_INT 42
63849: PUSH
63850: LD_INT 43
63852: PUSH
63853: LD_INT 48
63855: PUSH
63856: LD_INT 49
63858: PUSH
63859: LD_INT 50
63861: PUSH
63862: LD_INT 51
63864: PUSH
63865: LD_INT 52
63867: PUSH
63868: LD_INT 53
63870: PUSH
63871: LD_INT 54
63873: PUSH
63874: LD_INT 55
63876: PUSH
63877: LD_INT 56
63879: PUSH
63880: LD_INT 60
63882: PUSH
63883: LD_INT 61
63885: PUSH
63886: LD_INT 62
63888: PUSH
63889: LD_INT 66
63891: PUSH
63892: LD_INT 67
63894: PUSH
63895: LD_INT 68
63897: PUSH
63898: LD_INT 81
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: LIST
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: ST_TO_ADDR
63946: GO 64139
63948: LD_INT 3
63950: DOUBLE
63951: EQUAL
63952: IFTRUE 63956
63954: GO 64138
63956: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63957: LD_ADDR_VAR 0 4
63961: PUSH
63962: LD_INT 46
63964: PUSH
63965: LD_INT 47
63967: PUSH
63968: LD_INT 1
63970: PUSH
63971: LD_INT 2
63973: PUSH
63974: LD_INT 11
63976: PUSH
63977: LD_INT 9
63979: PUSH
63980: LD_INT 20
63982: PUSH
63983: LD_INT 19
63985: PUSH
63986: LD_INT 21
63988: PUSH
63989: LD_INT 24
63991: PUSH
63992: LD_INT 22
63994: PUSH
63995: LD_INT 25
63997: PUSH
63998: LD_INT 28
64000: PUSH
64001: LD_INT 29
64003: PUSH
64004: LD_INT 30
64006: PUSH
64007: LD_INT 31
64009: PUSH
64010: LD_INT 37
64012: PUSH
64013: LD_INT 38
64015: PUSH
64016: LD_INT 32
64018: PUSH
64019: LD_INT 27
64021: PUSH
64022: LD_INT 33
64024: PUSH
64025: LD_INT 69
64027: PUSH
64028: LD_INT 39
64030: PUSH
64031: LD_INT 34
64033: PUSH
64034: LD_INT 40
64036: PUSH
64037: LD_INT 71
64039: PUSH
64040: LD_INT 23
64042: PUSH
64043: LD_INT 44
64045: PUSH
64046: LD_INT 48
64048: PUSH
64049: LD_INT 49
64051: PUSH
64052: LD_INT 50
64054: PUSH
64055: LD_INT 51
64057: PUSH
64058: LD_INT 52
64060: PUSH
64061: LD_INT 53
64063: PUSH
64064: LD_INT 54
64066: PUSH
64067: LD_INT 55
64069: PUSH
64070: LD_INT 56
64072: PUSH
64073: LD_INT 57
64075: PUSH
64076: LD_INT 58
64078: PUSH
64079: LD_INT 59
64081: PUSH
64082: LD_INT 63
64084: PUSH
64085: LD_INT 64
64087: PUSH
64088: LD_INT 65
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: ST_TO_ADDR
64136: GO 64139
64138: POP
// if state > - 1 and state < 3 then
64139: LD_VAR 0 3
64143: PUSH
64144: LD_INT 1
64146: NEG
64147: GREATER
64148: PUSH
64149: LD_VAR 0 3
64153: PUSH
64154: LD_INT 3
64156: LESS
64157: AND
64158: IFFALSE 64215
// for i in result do
64160: LD_ADDR_VAR 0 5
64164: PUSH
64165: LD_VAR 0 4
64169: PUSH
64170: FOR_IN
64171: IFFALSE 64213
// if GetTech ( i , side ) <> state then
64173: LD_VAR 0 5
64177: PPUSH
64178: LD_VAR 0 1
64182: PPUSH
64183: CALL_OW 321
64187: PUSH
64188: LD_VAR 0 3
64192: NONEQUAL
64193: IFFALSE 64211
// result := result diff i ;
64195: LD_ADDR_VAR 0 4
64199: PUSH
64200: LD_VAR 0 4
64204: PUSH
64205: LD_VAR 0 5
64209: DIFF
64210: ST_TO_ADDR
64211: GO 64170
64213: POP
64214: POP
// end ;
64215: LD_VAR 0 4
64219: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64220: LD_INT 0
64222: PPUSH
64223: PPUSH
64224: PPUSH
// result := true ;
64225: LD_ADDR_VAR 0 3
64229: PUSH
64230: LD_INT 1
64232: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64233: LD_ADDR_VAR 0 5
64237: PUSH
64238: LD_VAR 0 2
64242: PPUSH
64243: CALL_OW 480
64247: ST_TO_ADDR
// if not tmp then
64248: LD_VAR 0 5
64252: NOT
64253: IFFALSE 64257
// exit ;
64255: GO 64306
// for i in tmp do
64257: LD_ADDR_VAR 0 4
64261: PUSH
64262: LD_VAR 0 5
64266: PUSH
64267: FOR_IN
64268: IFFALSE 64304
// if GetTech ( i , side ) <> state_researched then
64270: LD_VAR 0 4
64274: PPUSH
64275: LD_VAR 0 1
64279: PPUSH
64280: CALL_OW 321
64284: PUSH
64285: LD_INT 2
64287: NONEQUAL
64288: IFFALSE 64302
// begin result := false ;
64290: LD_ADDR_VAR 0 3
64294: PUSH
64295: LD_INT 0
64297: ST_TO_ADDR
// exit ;
64298: POP
64299: POP
64300: GO 64306
// end ;
64302: GO 64267
64304: POP
64305: POP
// end ;
64306: LD_VAR 0 3
64310: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64311: LD_INT 0
64313: PPUSH
64314: PPUSH
64315: PPUSH
64316: PPUSH
64317: PPUSH
64318: PPUSH
64319: PPUSH
64320: PPUSH
64321: PPUSH
64322: PPUSH
64323: PPUSH
64324: PPUSH
64325: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64326: LD_VAR 0 1
64330: NOT
64331: PUSH
64332: LD_VAR 0 1
64336: PPUSH
64337: CALL_OW 257
64341: PUSH
64342: LD_INT 9
64344: NONEQUAL
64345: OR
64346: IFFALSE 64350
// exit ;
64348: GO 64923
// side := GetSide ( unit ) ;
64350: LD_ADDR_VAR 0 9
64354: PUSH
64355: LD_VAR 0 1
64359: PPUSH
64360: CALL_OW 255
64364: ST_TO_ADDR
// tech_space := tech_spacanom ;
64365: LD_ADDR_VAR 0 12
64369: PUSH
64370: LD_INT 29
64372: ST_TO_ADDR
// tech_time := tech_taurad ;
64373: LD_ADDR_VAR 0 13
64377: PUSH
64378: LD_INT 28
64380: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64381: LD_ADDR_VAR 0 11
64385: PUSH
64386: LD_VAR 0 1
64390: PPUSH
64391: CALL_OW 310
64395: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64396: LD_VAR 0 11
64400: PPUSH
64401: CALL_OW 247
64405: PUSH
64406: LD_INT 2
64408: EQUAL
64409: IFFALSE 64413
// exit ;
64411: GO 64923
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64413: LD_ADDR_VAR 0 8
64417: PUSH
64418: LD_INT 81
64420: PUSH
64421: LD_VAR 0 9
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 3
64432: PUSH
64433: LD_INT 21
64435: PUSH
64436: LD_INT 3
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: EMPTY
64444: LIST
64445: LIST
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PPUSH
64451: CALL_OW 69
64455: ST_TO_ADDR
// if not tmp then
64456: LD_VAR 0 8
64460: NOT
64461: IFFALSE 64465
// exit ;
64463: GO 64923
// if in_unit then
64465: LD_VAR 0 11
64469: IFFALSE 64493
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64471: LD_ADDR_VAR 0 10
64475: PUSH
64476: LD_VAR 0 8
64480: PPUSH
64481: LD_VAR 0 11
64485: PPUSH
64486: CALL_OW 74
64490: ST_TO_ADDR
64491: GO 64513
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64493: LD_ADDR_VAR 0 10
64497: PUSH
64498: LD_VAR 0 8
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: CALL_OW 74
64512: ST_TO_ADDR
// if not enemy then
64513: LD_VAR 0 10
64517: NOT
64518: IFFALSE 64522
// exit ;
64520: GO 64923
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64522: LD_VAR 0 11
64526: PUSH
64527: LD_VAR 0 11
64531: PPUSH
64532: LD_VAR 0 10
64536: PPUSH
64537: CALL_OW 296
64541: PUSH
64542: LD_INT 13
64544: GREATER
64545: AND
64546: PUSH
64547: LD_VAR 0 1
64551: PPUSH
64552: LD_VAR 0 10
64556: PPUSH
64557: CALL_OW 296
64561: PUSH
64562: LD_INT 12
64564: GREATER
64565: OR
64566: IFFALSE 64570
// exit ;
64568: GO 64923
// missile := [ 1 ] ;
64570: LD_ADDR_VAR 0 14
64574: PUSH
64575: LD_INT 1
64577: PUSH
64578: EMPTY
64579: LIST
64580: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64581: LD_VAR 0 9
64585: PPUSH
64586: LD_VAR 0 12
64590: PPUSH
64591: CALL_OW 325
64595: IFFALSE 64624
// missile := Insert ( missile , missile + 1 , 2 ) ;
64597: LD_ADDR_VAR 0 14
64601: PUSH
64602: LD_VAR 0 14
64606: PPUSH
64607: LD_VAR 0 14
64611: PUSH
64612: LD_INT 1
64614: PLUS
64615: PPUSH
64616: LD_INT 2
64618: PPUSH
64619: CALL_OW 2
64623: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64624: LD_VAR 0 9
64628: PPUSH
64629: LD_VAR 0 13
64633: PPUSH
64634: CALL_OW 325
64638: PUSH
64639: LD_VAR 0 10
64643: PPUSH
64644: CALL_OW 255
64648: PPUSH
64649: LD_VAR 0 13
64653: PPUSH
64654: CALL_OW 325
64658: NOT
64659: AND
64660: IFFALSE 64689
// missile := Insert ( missile , missile + 1 , 3 ) ;
64662: LD_ADDR_VAR 0 14
64666: PUSH
64667: LD_VAR 0 14
64671: PPUSH
64672: LD_VAR 0 14
64676: PUSH
64677: LD_INT 1
64679: PLUS
64680: PPUSH
64681: LD_INT 3
64683: PPUSH
64684: CALL_OW 2
64688: ST_TO_ADDR
// if missile < 2 then
64689: LD_VAR 0 14
64693: PUSH
64694: LD_INT 2
64696: LESS
64697: IFFALSE 64701
// exit ;
64699: GO 64923
// x := GetX ( enemy ) ;
64701: LD_ADDR_VAR 0 4
64705: PUSH
64706: LD_VAR 0 10
64710: PPUSH
64711: CALL_OW 250
64715: ST_TO_ADDR
// y := GetY ( enemy ) ;
64716: LD_ADDR_VAR 0 5
64720: PUSH
64721: LD_VAR 0 10
64725: PPUSH
64726: CALL_OW 251
64730: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64731: LD_ADDR_VAR 0 6
64735: PUSH
64736: LD_VAR 0 4
64740: PUSH
64741: LD_INT 1
64743: NEG
64744: PPUSH
64745: LD_INT 1
64747: PPUSH
64748: CALL_OW 12
64752: PLUS
64753: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64754: LD_ADDR_VAR 0 7
64758: PUSH
64759: LD_VAR 0 5
64763: PUSH
64764: LD_INT 1
64766: NEG
64767: PPUSH
64768: LD_INT 1
64770: PPUSH
64771: CALL_OW 12
64775: PLUS
64776: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64777: LD_VAR 0 6
64781: PPUSH
64782: LD_VAR 0 7
64786: PPUSH
64787: CALL_OW 488
64791: NOT
64792: IFFALSE 64814
// begin _x := x ;
64794: LD_ADDR_VAR 0 6
64798: PUSH
64799: LD_VAR 0 4
64803: ST_TO_ADDR
// _y := y ;
64804: LD_ADDR_VAR 0 7
64808: PUSH
64809: LD_VAR 0 5
64813: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64814: LD_ADDR_VAR 0 3
64818: PUSH
64819: LD_INT 1
64821: PPUSH
64822: LD_VAR 0 14
64826: PPUSH
64827: CALL_OW 12
64831: ST_TO_ADDR
// case i of 1 :
64832: LD_VAR 0 3
64836: PUSH
64837: LD_INT 1
64839: DOUBLE
64840: EQUAL
64841: IFTRUE 64845
64843: GO 64862
64845: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64846: LD_VAR 0 1
64850: PPUSH
64851: LD_VAR 0 10
64855: PPUSH
64856: CALL_OW 115
64860: GO 64923
64862: LD_INT 2
64864: DOUBLE
64865: EQUAL
64866: IFTRUE 64870
64868: GO 64892
64870: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64871: LD_VAR 0 1
64875: PPUSH
64876: LD_VAR 0 6
64880: PPUSH
64881: LD_VAR 0 7
64885: PPUSH
64886: CALL_OW 153
64890: GO 64923
64892: LD_INT 3
64894: DOUBLE
64895: EQUAL
64896: IFTRUE 64900
64898: GO 64922
64900: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64901: LD_VAR 0 1
64905: PPUSH
64906: LD_VAR 0 6
64910: PPUSH
64911: LD_VAR 0 7
64915: PPUSH
64916: CALL_OW 154
64920: GO 64923
64922: POP
// end ;
64923: LD_VAR 0 2
64927: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64928: LD_INT 0
64930: PPUSH
64931: PPUSH
64932: PPUSH
64933: PPUSH
64934: PPUSH
64935: PPUSH
// if not unit or not building then
64936: LD_VAR 0 1
64940: NOT
64941: PUSH
64942: LD_VAR 0 2
64946: NOT
64947: OR
64948: IFFALSE 64952
// exit ;
64950: GO 65110
// x := GetX ( building ) ;
64952: LD_ADDR_VAR 0 5
64956: PUSH
64957: LD_VAR 0 2
64961: PPUSH
64962: CALL_OW 250
64966: ST_TO_ADDR
// y := GetY ( building ) ;
64967: LD_ADDR_VAR 0 6
64971: PUSH
64972: LD_VAR 0 2
64976: PPUSH
64977: CALL_OW 251
64981: ST_TO_ADDR
// for i = 0 to 5 do
64982: LD_ADDR_VAR 0 4
64986: PUSH
64987: DOUBLE
64988: LD_INT 0
64990: DEC
64991: ST_TO_ADDR
64992: LD_INT 5
64994: PUSH
64995: FOR_TO
64996: IFFALSE 65108
// begin _x := ShiftX ( x , i , 3 ) ;
64998: LD_ADDR_VAR 0 7
65002: PUSH
65003: LD_VAR 0 5
65007: PPUSH
65008: LD_VAR 0 4
65012: PPUSH
65013: LD_INT 3
65015: PPUSH
65016: CALL_OW 272
65020: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65021: LD_ADDR_VAR 0 8
65025: PUSH
65026: LD_VAR 0 6
65030: PPUSH
65031: LD_VAR 0 4
65035: PPUSH
65036: LD_INT 3
65038: PPUSH
65039: CALL_OW 273
65043: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65044: LD_VAR 0 7
65048: PPUSH
65049: LD_VAR 0 8
65053: PPUSH
65054: CALL_OW 488
65058: NOT
65059: IFFALSE 65063
// continue ;
65061: GO 64995
// if HexInfo ( _x , _y ) = 0 then
65063: LD_VAR 0 7
65067: PPUSH
65068: LD_VAR 0 8
65072: PPUSH
65073: CALL_OW 428
65077: PUSH
65078: LD_INT 0
65080: EQUAL
65081: IFFALSE 65106
// begin ComMoveXY ( unit , _x , _y ) ;
65083: LD_VAR 0 1
65087: PPUSH
65088: LD_VAR 0 7
65092: PPUSH
65093: LD_VAR 0 8
65097: PPUSH
65098: CALL_OW 111
// exit ;
65102: POP
65103: POP
65104: GO 65110
// end ; end ;
65106: GO 64995
65108: POP
65109: POP
// end ;
65110: LD_VAR 0 3
65114: RET
// export function ScanBase ( side , base_area ) ; begin
65115: LD_INT 0
65117: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65118: LD_ADDR_VAR 0 3
65122: PUSH
65123: LD_VAR 0 2
65127: PPUSH
65128: LD_INT 81
65130: PUSH
65131: LD_VAR 0 1
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: PPUSH
65140: CALL_OW 70
65144: ST_TO_ADDR
// end ;
65145: LD_VAR 0 3
65149: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65150: LD_INT 0
65152: PPUSH
65153: PPUSH
65154: PPUSH
65155: PPUSH
65156: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65157: LD_VAR 0 1
65161: NOT
65162: PUSH
65163: LD_EXP 99
65167: PUSH
65168: LD_VAR 0 1
65172: ARRAY
65173: NOT
65174: OR
65175: PUSH
65176: LD_VAR 0 2
65180: NOT
65181: OR
65182: PUSH
65183: LD_VAR 0 3
65187: NOT
65188: OR
65189: IFFALSE 65193
// exit ;
65191: GO 65643
// side := mc_sides [ base ] ;
65193: LD_ADDR_VAR 0 6
65197: PUSH
65198: LD_EXP 125
65202: PUSH
65203: LD_VAR 0 1
65207: ARRAY
65208: ST_TO_ADDR
// if not side then
65209: LD_VAR 0 6
65213: NOT
65214: IFFALSE 65218
// exit ;
65216: GO 65643
// for i in solds do
65218: LD_ADDR_VAR 0 7
65222: PUSH
65223: LD_VAR 0 2
65227: PUSH
65228: FOR_IN
65229: IFFALSE 65290
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65231: LD_VAR 0 7
65235: PPUSH
65236: CALL_OW 310
65240: PPUSH
65241: CALL_OW 266
65245: PUSH
65246: LD_INT 32
65248: PUSH
65249: LD_INT 31
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: IN
65256: IFFALSE 65276
// solds := solds diff i else
65258: LD_ADDR_VAR 0 2
65262: PUSH
65263: LD_VAR 0 2
65267: PUSH
65268: LD_VAR 0 7
65272: DIFF
65273: ST_TO_ADDR
65274: GO 65288
// SetTag ( i , 18 ) ;
65276: LD_VAR 0 7
65280: PPUSH
65281: LD_INT 18
65283: PPUSH
65284: CALL_OW 109
65288: GO 65228
65290: POP
65291: POP
// if not solds then
65292: LD_VAR 0 2
65296: NOT
65297: IFFALSE 65301
// exit ;
65299: GO 65643
// repeat wait ( 0 0$1 ) ;
65301: LD_INT 35
65303: PPUSH
65304: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65308: LD_ADDR_VAR 0 5
65312: PUSH
65313: LD_VAR 0 6
65317: PPUSH
65318: LD_VAR 0 3
65322: PPUSH
65323: CALL 65115 0 2
65327: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
65328: LD_VAR 0 5
65332: NOT
65333: PUSH
65334: LD_VAR 0 5
65338: PUSH
65339: LD_INT 3
65341: GREATER
65342: OR
65343: PUSH
65344: LD_EXP 121
65348: PUSH
65349: LD_VAR 0 1
65353: ARRAY
65354: OR
65355: IFFALSE 65396
// begin for i in solds do
65357: LD_ADDR_VAR 0 7
65361: PUSH
65362: LD_VAR 0 2
65366: PUSH
65367: FOR_IN
65368: IFFALSE 65392
// if HasTask ( i ) then
65370: LD_VAR 0 7
65374: PPUSH
65375: CALL_OW 314
65379: IFFALSE 65390
// ComStop ( i ) ;
65381: LD_VAR 0 7
65385: PPUSH
65386: CALL_OW 141
65390: GO 65367
65392: POP
65393: POP
// break ;
65394: GO 65631
// end ; for i in solds do
65396: LD_ADDR_VAR 0 7
65400: PUSH
65401: LD_VAR 0 2
65405: PUSH
65406: FOR_IN
65407: IFFALSE 65623
// begin if IsInUnit ( i ) then
65409: LD_VAR 0 7
65413: PPUSH
65414: CALL_OW 310
65418: IFFALSE 65429
// ComExitBuilding ( i ) ;
65420: LD_VAR 0 7
65424: PPUSH
65425: CALL_OW 122
// if GetLives ( i ) > 333 then
65429: LD_VAR 0 7
65433: PPUSH
65434: CALL_OW 256
65438: PUSH
65439: LD_INT 333
65441: GREATER
65442: IFFALSE 65470
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
65444: LD_VAR 0 7
65448: PPUSH
65449: LD_VAR 0 5
65453: PPUSH
65454: LD_VAR 0 7
65458: PPUSH
65459: CALL_OW 74
65463: PPUSH
65464: CALL_OW 115
65468: GO 65621
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
65470: LD_ADDR_VAR 0 8
65474: PUSH
65475: LD_EXP 99
65479: PUSH
65480: LD_VAR 0 1
65484: ARRAY
65485: PPUSH
65486: LD_INT 2
65488: PUSH
65489: LD_INT 30
65491: PUSH
65492: LD_INT 0
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 30
65501: PUSH
65502: LD_INT 1
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 30
65511: PUSH
65512: LD_INT 6
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: LIST
65523: LIST
65524: PPUSH
65525: CALL_OW 72
65529: PPUSH
65530: LD_VAR 0 7
65534: PPUSH
65535: CALL_OW 74
65539: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
65540: LD_VAR 0 7
65544: PPUSH
65545: LD_VAR 0 8
65549: PPUSH
65550: CALL_OW 250
65554: PPUSH
65555: LD_INT 3
65557: PPUSH
65558: LD_INT 5
65560: PPUSH
65561: CALL_OW 272
65565: PPUSH
65566: LD_VAR 0 8
65570: PPUSH
65571: CALL_OW 251
65575: PPUSH
65576: LD_INT 3
65578: PPUSH
65579: LD_INT 5
65581: PPUSH
65582: CALL_OW 273
65586: PPUSH
65587: CALL_OW 111
// SetTag ( i , 0 ) ;
65591: LD_VAR 0 7
65595: PPUSH
65596: LD_INT 0
65598: PPUSH
65599: CALL_OW 109
// solds := solds diff i ;
65603: LD_ADDR_VAR 0 2
65607: PUSH
65608: LD_VAR 0 2
65612: PUSH
65613: LD_VAR 0 7
65617: DIFF
65618: ST_TO_ADDR
// continue ;
65619: GO 65406
// end ; end ;
65621: GO 65406
65623: POP
65624: POP
// until solds ;
65625: LD_VAR 0 2
65629: IFFALSE 65301
// MC_Reset ( base , 18 ) ;
65631: LD_VAR 0 1
65635: PPUSH
65636: LD_INT 18
65638: PPUSH
65639: CALL 37861 0 2
// end ;
65643: LD_VAR 0 4
65647: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65648: LD_INT 0
65650: PPUSH
65651: PPUSH
65652: PPUSH
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
65662: PPUSH
65663: PPUSH
65664: PPUSH
65665: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65666: LD_ADDR_VAR 0 12
65670: PUSH
65671: LD_EXP 99
65675: PUSH
65676: LD_VAR 0 1
65680: ARRAY
65681: PPUSH
65682: LD_INT 25
65684: PUSH
65685: LD_INT 3
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PPUSH
65692: CALL_OW 72
65696: ST_TO_ADDR
// if mc_remote_driver [ base ] then
65697: LD_EXP 139
65701: PUSH
65702: LD_VAR 0 1
65706: ARRAY
65707: IFFALSE 65731
// mechs := mechs diff mc_remote_driver [ base ] ;
65709: LD_ADDR_VAR 0 12
65713: PUSH
65714: LD_VAR 0 12
65718: PUSH
65719: LD_EXP 139
65723: PUSH
65724: LD_VAR 0 1
65728: ARRAY
65729: DIFF
65730: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65731: LD_ADDR_VAR 0 8
65735: PUSH
65736: LD_EXP 99
65740: PUSH
65741: LD_VAR 0 1
65745: ARRAY
65746: PPUSH
65747: LD_INT 2
65749: PUSH
65750: LD_INT 25
65752: PUSH
65753: LD_INT 1
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: PUSH
65760: LD_INT 25
65762: PUSH
65763: LD_INT 5
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 25
65772: PUSH
65773: LD_INT 8
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 25
65782: PUSH
65783: LD_INT 9
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: LIST
65794: LIST
65795: LIST
65796: PPUSH
65797: CALL_OW 72
65801: ST_TO_ADDR
// if not defenders and not solds then
65802: LD_VAR 0 2
65806: NOT
65807: PUSH
65808: LD_VAR 0 8
65812: NOT
65813: AND
65814: IFFALSE 65818
// exit ;
65816: GO 67192
// depot_under_attack := false ;
65818: LD_ADDR_VAR 0 16
65822: PUSH
65823: LD_INT 0
65825: ST_TO_ADDR
// sold_defenders := [ ] ;
65826: LD_ADDR_VAR 0 17
65830: PUSH
65831: EMPTY
65832: ST_TO_ADDR
// if mechs then
65833: LD_VAR 0 12
65837: IFFALSE 65966
// for i in defenders do
65839: LD_ADDR_VAR 0 5
65843: PUSH
65844: LD_VAR 0 2
65848: PUSH
65849: FOR_IN
65850: IFFALSE 65964
// begin SetTag ( i , 20 ) ;
65852: LD_VAR 0 5
65856: PPUSH
65857: LD_INT 20
65859: PPUSH
65860: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65864: LD_VAR 0 5
65868: PPUSH
65869: CALL_OW 263
65873: PUSH
65874: LD_INT 1
65876: EQUAL
65877: PUSH
65878: LD_VAR 0 5
65882: PPUSH
65883: CALL_OW 311
65887: NOT
65888: AND
65889: PUSH
65890: LD_VAR 0 12
65894: AND
65895: IFFALSE 65962
// begin un := mechs [ 1 ] ;
65897: LD_ADDR_VAR 0 10
65901: PUSH
65902: LD_VAR 0 12
65906: PUSH
65907: LD_INT 1
65909: ARRAY
65910: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65911: LD_VAR 0 10
65915: PPUSH
65916: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65920: LD_VAR 0 10
65924: PPUSH
65925: LD_VAR 0 5
65929: PPUSH
65930: CALL_OW 180
// SetTag ( un , 19 ) ;
65934: LD_VAR 0 10
65938: PPUSH
65939: LD_INT 19
65941: PPUSH
65942: CALL_OW 109
// mechs := mechs diff un ;
65946: LD_ADDR_VAR 0 12
65950: PUSH
65951: LD_VAR 0 12
65955: PUSH
65956: LD_VAR 0 10
65960: DIFF
65961: ST_TO_ADDR
// end ; end ;
65962: GO 65849
65964: POP
65965: POP
// if solds then
65966: LD_VAR 0 8
65970: IFFALSE 66029
// for i in solds do
65972: LD_ADDR_VAR 0 5
65976: PUSH
65977: LD_VAR 0 8
65981: PUSH
65982: FOR_IN
65983: IFFALSE 66027
// if not GetTag ( i ) then
65985: LD_VAR 0 5
65989: PPUSH
65990: CALL_OW 110
65994: NOT
65995: IFFALSE 66025
// begin defenders := defenders union i ;
65997: LD_ADDR_VAR 0 2
66001: PUSH
66002: LD_VAR 0 2
66006: PUSH
66007: LD_VAR 0 5
66011: UNION
66012: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66013: LD_VAR 0 5
66017: PPUSH
66018: LD_INT 18
66020: PPUSH
66021: CALL_OW 109
// end ;
66025: GO 65982
66027: POP
66028: POP
// repeat wait ( 0 0$1 ) ;
66029: LD_INT 35
66031: PPUSH
66032: CALL_OW 67
// enemy := mc_scan [ base ] ;
66036: LD_ADDR_VAR 0 3
66040: PUSH
66041: LD_EXP 122
66045: PUSH
66046: LD_VAR 0 1
66050: ARRAY
66051: ST_TO_ADDR
// for i in defenders do
66052: LD_ADDR_VAR 0 5
66056: PUSH
66057: LD_VAR 0 2
66061: PUSH
66062: FOR_IN
66063: IFFALSE 66793
// begin e := NearestUnitToUnit ( enemy , i ) ;
66065: LD_ADDR_VAR 0 13
66069: PUSH
66070: LD_VAR 0 3
66074: PPUSH
66075: LD_VAR 0 5
66079: PPUSH
66080: CALL_OW 74
66084: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66085: LD_ADDR_VAR 0 16
66089: PUSH
66090: LD_EXP 99
66094: PUSH
66095: LD_VAR 0 1
66099: ARRAY
66100: PPUSH
66101: LD_INT 2
66103: PUSH
66104: LD_INT 30
66106: PUSH
66107: LD_INT 0
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PUSH
66114: LD_INT 30
66116: PUSH
66117: LD_INT 1
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: EMPTY
66125: LIST
66126: LIST
66127: LIST
66128: PPUSH
66129: CALL_OW 72
66133: NOT
66134: PUSH
66135: LD_EXP 99
66139: PUSH
66140: LD_VAR 0 1
66144: ARRAY
66145: PPUSH
66146: LD_INT 2
66148: PUSH
66149: LD_INT 30
66151: PUSH
66152: LD_INT 0
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: PUSH
66159: LD_INT 30
66161: PUSH
66162: LD_INT 1
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: LIST
66173: PPUSH
66174: CALL_OW 72
66178: PPUSH
66179: CALL_OW 256
66183: PUSH
66184: LD_INT 600
66186: LESS
66187: OR
66188: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66189: LD_VAR 0 5
66193: PPUSH
66194: CALL_OW 247
66198: PUSH
66199: LD_INT 2
66201: DOUBLE
66202: EQUAL
66203: IFTRUE 66207
66205: GO 66499
66207: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66208: LD_VAR 0 5
66212: PPUSH
66213: CALL_OW 256
66217: PUSH
66218: LD_INT 650
66220: GREATER
66221: PUSH
66222: LD_VAR 0 5
66226: PPUSH
66227: LD_VAR 0 13
66231: PPUSH
66232: CALL_OW 296
66236: PUSH
66237: LD_INT 40
66239: LESS
66240: PUSH
66241: LD_VAR 0 13
66245: PPUSH
66246: LD_EXP 124
66250: PUSH
66251: LD_VAR 0 1
66255: ARRAY
66256: PPUSH
66257: CALL_OW 308
66261: OR
66262: AND
66263: IFFALSE 66281
// ComAttackUnit ( i , e ) else
66265: LD_VAR 0 5
66269: PPUSH
66270: LD_VAR 0 13
66274: PPUSH
66275: CALL_OW 115
66279: GO 66382
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
66281: LD_VAR 0 13
66285: PPUSH
66286: LD_EXP 124
66290: PUSH
66291: LD_VAR 0 1
66295: ARRAY
66296: PPUSH
66297: CALL_OW 308
66301: NOT
66302: PUSH
66303: LD_VAR 0 5
66307: PPUSH
66308: LD_VAR 0 13
66312: PPUSH
66313: CALL_OW 296
66317: PUSH
66318: LD_INT 40
66320: GREATEREQUAL
66321: AND
66322: PUSH
66323: LD_VAR 0 5
66327: PPUSH
66328: CALL_OW 256
66332: PUSH
66333: LD_INT 650
66335: LESSEQUAL
66336: OR
66337: PUSH
66338: LD_VAR 0 5
66342: PPUSH
66343: LD_EXP 123
66347: PUSH
66348: LD_VAR 0 1
66352: ARRAY
66353: PPUSH
66354: CALL_OW 308
66358: NOT
66359: AND
66360: IFFALSE 66382
// ComMoveToArea ( i , mc_parking [ base ] ) ;
66362: LD_VAR 0 5
66366: PPUSH
66367: LD_EXP 123
66371: PUSH
66372: LD_VAR 0 1
66376: ARRAY
66377: PPUSH
66378: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
66382: LD_VAR 0 5
66386: PPUSH
66387: CALL_OW 256
66391: PUSH
66392: LD_INT 998
66394: LESS
66395: PUSH
66396: LD_VAR 0 5
66400: PPUSH
66401: CALL_OW 263
66405: PUSH
66406: LD_INT 1
66408: EQUAL
66409: AND
66410: PUSH
66411: LD_VAR 0 5
66415: PPUSH
66416: CALL_OW 311
66420: AND
66421: PUSH
66422: LD_VAR 0 5
66426: PPUSH
66427: LD_EXP 123
66431: PUSH
66432: LD_VAR 0 1
66436: ARRAY
66437: PPUSH
66438: CALL_OW 308
66442: AND
66443: IFFALSE 66497
// begin mech := IsDrivenBy ( i ) ;
66445: LD_ADDR_VAR 0 9
66449: PUSH
66450: LD_VAR 0 5
66454: PPUSH
66455: CALL_OW 311
66459: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
66460: LD_VAR 0 9
66464: PPUSH
66465: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
66469: LD_VAR 0 9
66473: PPUSH
66474: LD_VAR 0 5
66478: PPUSH
66479: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
66483: LD_VAR 0 9
66487: PPUSH
66488: LD_VAR 0 5
66492: PPUSH
66493: CALL_OW 180
// end ; end ; unit_human :
66497: GO 66764
66499: LD_INT 1
66501: DOUBLE
66502: EQUAL
66503: IFTRUE 66507
66505: GO 66763
66507: POP
// begin b := IsInUnit ( i ) ;
66508: LD_ADDR_VAR 0 18
66512: PUSH
66513: LD_VAR 0 5
66517: PPUSH
66518: CALL_OW 310
66522: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
66523: LD_ADDR_VAR 0 19
66527: PUSH
66528: LD_VAR 0 18
66532: NOT
66533: PUSH
66534: LD_VAR 0 18
66538: PPUSH
66539: CALL_OW 266
66543: PUSH
66544: LD_INT 32
66546: PUSH
66547: LD_INT 31
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: IN
66554: OR
66555: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
66556: LD_VAR 0 16
66560: PUSH
66561: LD_VAR 0 2
66565: PPUSH
66566: LD_INT 21
66568: PUSH
66569: LD_INT 2
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PPUSH
66576: CALL_OW 72
66580: PUSH
66581: LD_INT 1
66583: LESSEQUAL
66584: OR
66585: PUSH
66586: LD_VAR 0 19
66590: AND
66591: PUSH
66592: LD_VAR 0 5
66596: PUSH
66597: LD_VAR 0 17
66601: IN
66602: NOT
66603: AND
66604: IFFALSE 66697
// begin if b then
66606: LD_VAR 0 18
66610: IFFALSE 66659
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
66612: LD_VAR 0 18
66616: PPUSH
66617: LD_VAR 0 3
66621: PPUSH
66622: LD_VAR 0 18
66626: PPUSH
66627: CALL_OW 74
66631: PPUSH
66632: CALL_OW 296
66636: PUSH
66637: LD_INT 10
66639: LESS
66640: PUSH
66641: LD_VAR 0 18
66645: PPUSH
66646: CALL_OW 461
66650: PUSH
66651: LD_INT 7
66653: NONEQUAL
66654: AND
66655: IFFALSE 66659
// continue ;
66657: GO 66062
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66659: LD_ADDR_VAR 0 17
66663: PUSH
66664: LD_VAR 0 17
66668: PPUSH
66669: LD_VAR 0 17
66673: PUSH
66674: LD_INT 1
66676: PLUS
66677: PPUSH
66678: LD_VAR 0 5
66682: PPUSH
66683: CALL_OW 1
66687: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66688: LD_VAR 0 5
66692: PPUSH
66693: CALL_OW 122
// end ; if sold_defenders then
66697: LD_VAR 0 17
66701: IFFALSE 66761
// if i in sold_defenders then
66703: LD_VAR 0 5
66707: PUSH
66708: LD_VAR 0 17
66712: IN
66713: IFFALSE 66761
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66715: LD_VAR 0 5
66719: PPUSH
66720: CALL_OW 314
66724: NOT
66725: PUSH
66726: LD_VAR 0 5
66730: PPUSH
66731: LD_VAR 0 13
66735: PPUSH
66736: CALL_OW 296
66740: PUSH
66741: LD_INT 30
66743: LESS
66744: AND
66745: IFFALSE 66761
// ComAttackUnit ( i , e ) ;
66747: LD_VAR 0 5
66751: PPUSH
66752: LD_VAR 0 13
66756: PPUSH
66757: CALL_OW 115
// end ; end ; end ;
66761: GO 66764
66763: POP
// if IsDead ( i ) then
66764: LD_VAR 0 5
66768: PPUSH
66769: CALL_OW 301
66773: IFFALSE 66791
// defenders := defenders diff i ;
66775: LD_ADDR_VAR 0 2
66779: PUSH
66780: LD_VAR 0 2
66784: PUSH
66785: LD_VAR 0 5
66789: DIFF
66790: ST_TO_ADDR
// end ;
66791: GO 66062
66793: POP
66794: POP
// until not enemy or not defenders ;
66795: LD_VAR 0 3
66799: NOT
66800: PUSH
66801: LD_VAR 0 2
66805: NOT
66806: OR
66807: IFFALSE 66029
// MC_Reset ( base , 18 ) ;
66809: LD_VAR 0 1
66813: PPUSH
66814: LD_INT 18
66816: PPUSH
66817: CALL 37861 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66821: LD_ADDR_VAR 0 2
66825: PUSH
66826: LD_VAR 0 2
66830: PUSH
66831: LD_VAR 0 2
66835: PPUSH
66836: LD_INT 2
66838: PUSH
66839: LD_INT 25
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 25
66851: PUSH
66852: LD_INT 5
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 25
66861: PUSH
66862: LD_INT 8
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 25
66871: PUSH
66872: LD_INT 9
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: PPUSH
66886: CALL_OW 72
66890: DIFF
66891: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66892: LD_VAR 0 3
66896: NOT
66897: PUSH
66898: LD_VAR 0 2
66902: PPUSH
66903: LD_INT 21
66905: PUSH
66906: LD_INT 2
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PPUSH
66913: CALL_OW 72
66917: AND
66918: IFFALSE 67180
// begin tmp := FilterByTag ( defenders , 19 ) ;
66920: LD_ADDR_VAR 0 11
66924: PUSH
66925: LD_VAR 0 2
66929: PPUSH
66930: LD_INT 19
66932: PPUSH
66933: CALL 103621 0 2
66937: ST_TO_ADDR
// if tmp then
66938: LD_VAR 0 11
66942: IFFALSE 67012
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66944: LD_ADDR_VAR 0 11
66948: PUSH
66949: LD_VAR 0 11
66953: PPUSH
66954: LD_INT 25
66956: PUSH
66957: LD_INT 3
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PPUSH
66964: CALL_OW 72
66968: ST_TO_ADDR
// if tmp then
66969: LD_VAR 0 11
66973: IFFALSE 67012
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66975: LD_ADDR_EXP 111
66979: PUSH
66980: LD_EXP 111
66984: PPUSH
66985: LD_VAR 0 1
66989: PPUSH
66990: LD_EXP 111
66994: PUSH
66995: LD_VAR 0 1
66999: ARRAY
67000: PUSH
67001: LD_VAR 0 11
67005: UNION
67006: PPUSH
67007: CALL_OW 1
67011: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67012: LD_VAR 0 1
67016: PPUSH
67017: LD_INT 19
67019: PPUSH
67020: CALL 37861 0 2
// repeat wait ( 0 0$1 ) ;
67024: LD_INT 35
67026: PPUSH
67027: CALL_OW 67
// for i in defenders do
67031: LD_ADDR_VAR 0 5
67035: PUSH
67036: LD_VAR 0 2
67040: PUSH
67041: FOR_IN
67042: IFFALSE 67131
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67044: LD_VAR 0 5
67048: PPUSH
67049: LD_EXP 123
67053: PUSH
67054: LD_VAR 0 1
67058: ARRAY
67059: PPUSH
67060: CALL_OW 308
67064: NOT
67065: IFFALSE 67089
// ComMoveToArea ( i , mc_parking [ base ] ) else
67067: LD_VAR 0 5
67071: PPUSH
67072: LD_EXP 123
67076: PUSH
67077: LD_VAR 0 1
67081: ARRAY
67082: PPUSH
67083: CALL_OW 113
67087: GO 67129
// if GetControl ( i ) = control_manual then
67089: LD_VAR 0 5
67093: PPUSH
67094: CALL_OW 263
67098: PUSH
67099: LD_INT 1
67101: EQUAL
67102: IFFALSE 67129
// if IsDrivenBy ( i ) then
67104: LD_VAR 0 5
67108: PPUSH
67109: CALL_OW 311
67113: IFFALSE 67129
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67115: LD_VAR 0 5
67119: PPUSH
67120: CALL_OW 311
67124: PPUSH
67125: CALL_OW 121
// end ;
67129: GO 67041
67131: POP
67132: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
67133: LD_VAR 0 2
67137: PPUSH
67138: LD_INT 95
67140: PUSH
67141: LD_EXP 123
67145: PUSH
67146: LD_VAR 0 1
67150: ARRAY
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PPUSH
67156: CALL_OW 72
67160: PUSH
67161: LD_VAR 0 2
67165: EQUAL
67166: PUSH
67167: LD_EXP 122
67171: PUSH
67172: LD_VAR 0 1
67176: ARRAY
67177: OR
67178: IFFALSE 67024
// end ; MC_Reset ( base , 20 ) ;
67180: LD_VAR 0 1
67184: PPUSH
67185: LD_INT 20
67187: PPUSH
67188: CALL 37861 0 2
// end ;
67192: LD_VAR 0 4
67196: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67197: LD_INT 0
67199: PPUSH
67200: PPUSH
67201: PPUSH
67202: PPUSH
// result := false ;
67203: LD_ADDR_VAR 0 2
67207: PUSH
67208: LD_INT 0
67210: ST_TO_ADDR
// side := GetSide ( unit ) ;
67211: LD_ADDR_VAR 0 3
67215: PUSH
67216: LD_VAR 0 1
67220: PPUSH
67221: CALL_OW 255
67225: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67226: LD_ADDR_VAR 0 4
67230: PUSH
67231: LD_VAR 0 1
67235: PPUSH
67236: CALL_OW 248
67240: ST_TO_ADDR
// case nat of 1 :
67241: LD_VAR 0 4
67245: PUSH
67246: LD_INT 1
67248: DOUBLE
67249: EQUAL
67250: IFTRUE 67254
67252: GO 67265
67254: POP
// tech := tech_lassight ; 2 :
67255: LD_ADDR_VAR 0 5
67259: PUSH
67260: LD_INT 12
67262: ST_TO_ADDR
67263: GO 67304
67265: LD_INT 2
67267: DOUBLE
67268: EQUAL
67269: IFTRUE 67273
67271: GO 67284
67273: POP
// tech := tech_mortar ; 3 :
67274: LD_ADDR_VAR 0 5
67278: PUSH
67279: LD_INT 41
67281: ST_TO_ADDR
67282: GO 67304
67284: LD_INT 3
67286: DOUBLE
67287: EQUAL
67288: IFTRUE 67292
67290: GO 67303
67292: POP
// tech := tech_bazooka ; end ;
67293: LD_ADDR_VAR 0 5
67297: PUSH
67298: LD_INT 44
67300: ST_TO_ADDR
67301: GO 67304
67303: POP
// if Researched ( side , tech ) then
67304: LD_VAR 0 3
67308: PPUSH
67309: LD_VAR 0 5
67313: PPUSH
67314: CALL_OW 325
67318: IFFALSE 67345
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67320: LD_ADDR_VAR 0 2
67324: PUSH
67325: LD_INT 5
67327: PUSH
67328: LD_INT 8
67330: PUSH
67331: LD_INT 9
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: LIST
67338: PUSH
67339: LD_VAR 0 4
67343: ARRAY
67344: ST_TO_ADDR
// end ;
67345: LD_VAR 0 2
67349: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67350: LD_INT 0
67352: PPUSH
67353: PPUSH
67354: PPUSH
// if not mines then
67355: LD_VAR 0 2
67359: NOT
67360: IFFALSE 67364
// exit ;
67362: GO 67508
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67364: LD_ADDR_VAR 0 5
67368: PUSH
67369: LD_INT 81
67371: PUSH
67372: LD_VAR 0 1
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 3
67383: PUSH
67384: LD_INT 21
67386: PUSH
67387: LD_INT 3
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PPUSH
67402: CALL_OW 69
67406: ST_TO_ADDR
// for i in mines do
67407: LD_ADDR_VAR 0 4
67411: PUSH
67412: LD_VAR 0 2
67416: PUSH
67417: FOR_IN
67418: IFFALSE 67506
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67420: LD_VAR 0 4
67424: PUSH
67425: LD_INT 1
67427: ARRAY
67428: PPUSH
67429: LD_VAR 0 4
67433: PUSH
67434: LD_INT 2
67436: ARRAY
67437: PPUSH
67438: CALL_OW 458
67442: NOT
67443: IFFALSE 67447
// continue ;
67445: GO 67417
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67447: LD_VAR 0 4
67451: PUSH
67452: LD_INT 1
67454: ARRAY
67455: PPUSH
67456: LD_VAR 0 4
67460: PUSH
67461: LD_INT 2
67463: ARRAY
67464: PPUSH
67465: CALL_OW 428
67469: PUSH
67470: LD_VAR 0 5
67474: IN
67475: IFFALSE 67504
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67477: LD_VAR 0 4
67481: PUSH
67482: LD_INT 1
67484: ARRAY
67485: PPUSH
67486: LD_VAR 0 4
67490: PUSH
67491: LD_INT 2
67493: ARRAY
67494: PPUSH
67495: LD_VAR 0 1
67499: PPUSH
67500: CALL_OW 456
// end ;
67504: GO 67417
67506: POP
67507: POP
// end ;
67508: LD_VAR 0 3
67512: RET
// export function Count ( array ) ; var i ; begin
67513: LD_INT 0
67515: PPUSH
67516: PPUSH
// result := 0 ;
67517: LD_ADDR_VAR 0 2
67521: PUSH
67522: LD_INT 0
67524: ST_TO_ADDR
// for i in array do
67525: LD_ADDR_VAR 0 3
67529: PUSH
67530: LD_VAR 0 1
67534: PUSH
67535: FOR_IN
67536: IFFALSE 67560
// if i then
67538: LD_VAR 0 3
67542: IFFALSE 67558
// result := result + 1 ;
67544: LD_ADDR_VAR 0 2
67548: PUSH
67549: LD_VAR 0 2
67553: PUSH
67554: LD_INT 1
67556: PLUS
67557: ST_TO_ADDR
67558: GO 67535
67560: POP
67561: POP
// end ;
67562: LD_VAR 0 2
67566: RET
// export function IsEmpty ( building ) ; begin
67567: LD_INT 0
67569: PPUSH
// if not building then
67570: LD_VAR 0 1
67574: NOT
67575: IFFALSE 67579
// exit ;
67577: GO 67622
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67579: LD_ADDR_VAR 0 2
67583: PUSH
67584: LD_VAR 0 1
67588: PUSH
67589: LD_INT 22
67591: PUSH
67592: LD_VAR 0 1
67596: PPUSH
67597: CALL_OW 255
67601: PUSH
67602: EMPTY
67603: LIST
67604: LIST
67605: PUSH
67606: LD_INT 58
67608: PUSH
67609: EMPTY
67610: LIST
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PPUSH
67616: CALL_OW 69
67620: IN
67621: ST_TO_ADDR
// end ;
67622: LD_VAR 0 2
67626: RET
// export function IsNotFull ( building ) ; begin
67627: LD_INT 0
67629: PPUSH
// if not building then
67630: LD_VAR 0 1
67634: NOT
67635: IFFALSE 67639
// exit ;
67637: GO 67658
// result := UnitsInside ( building ) < 6 ;
67639: LD_ADDR_VAR 0 2
67643: PUSH
67644: LD_VAR 0 1
67648: PPUSH
67649: CALL_OW 313
67653: PUSH
67654: LD_INT 6
67656: LESS
67657: ST_TO_ADDR
// end ;
67658: LD_VAR 0 2
67662: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67663: LD_INT 0
67665: PPUSH
67666: PPUSH
67667: PPUSH
67668: PPUSH
// tmp := [ ] ;
67669: LD_ADDR_VAR 0 3
67673: PUSH
67674: EMPTY
67675: ST_TO_ADDR
// list := [ ] ;
67676: LD_ADDR_VAR 0 5
67680: PUSH
67681: EMPTY
67682: ST_TO_ADDR
// for i = 16 to 25 do
67683: LD_ADDR_VAR 0 4
67687: PUSH
67688: DOUBLE
67689: LD_INT 16
67691: DEC
67692: ST_TO_ADDR
67693: LD_INT 25
67695: PUSH
67696: FOR_TO
67697: IFFALSE 67770
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67699: LD_ADDR_VAR 0 3
67703: PUSH
67704: LD_VAR 0 3
67708: PUSH
67709: LD_INT 22
67711: PUSH
67712: LD_VAR 0 1
67716: PPUSH
67717: CALL_OW 255
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 91
67728: PUSH
67729: LD_VAR 0 1
67733: PUSH
67734: LD_INT 6
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: LIST
67741: PUSH
67742: LD_INT 30
67744: PUSH
67745: LD_VAR 0 4
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: LIST
67758: PUSH
67759: EMPTY
67760: LIST
67761: PPUSH
67762: CALL_OW 69
67766: ADD
67767: ST_TO_ADDR
67768: GO 67696
67770: POP
67771: POP
// for i = 1 to tmp do
67772: LD_ADDR_VAR 0 4
67776: PUSH
67777: DOUBLE
67778: LD_INT 1
67780: DEC
67781: ST_TO_ADDR
67782: LD_VAR 0 3
67786: PUSH
67787: FOR_TO
67788: IFFALSE 67876
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67790: LD_ADDR_VAR 0 5
67794: PUSH
67795: LD_VAR 0 5
67799: PUSH
67800: LD_VAR 0 3
67804: PUSH
67805: LD_VAR 0 4
67809: ARRAY
67810: PPUSH
67811: CALL_OW 266
67815: PUSH
67816: LD_VAR 0 3
67820: PUSH
67821: LD_VAR 0 4
67825: ARRAY
67826: PPUSH
67827: CALL_OW 250
67831: PUSH
67832: LD_VAR 0 3
67836: PUSH
67837: LD_VAR 0 4
67841: ARRAY
67842: PPUSH
67843: CALL_OW 251
67847: PUSH
67848: LD_VAR 0 3
67852: PUSH
67853: LD_VAR 0 4
67857: ARRAY
67858: PPUSH
67859: CALL_OW 254
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: PUSH
67870: EMPTY
67871: LIST
67872: ADD
67873: ST_TO_ADDR
67874: GO 67787
67876: POP
67877: POP
// result := list ;
67878: LD_ADDR_VAR 0 2
67882: PUSH
67883: LD_VAR 0 5
67887: ST_TO_ADDR
// end ;
67888: LD_VAR 0 2
67892: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67893: LD_INT 0
67895: PPUSH
67896: PPUSH
67897: PPUSH
67898: PPUSH
67899: PPUSH
67900: PPUSH
67901: PPUSH
// if not factory then
67902: LD_VAR 0 1
67906: NOT
67907: IFFALSE 67911
// exit ;
67909: GO 68504
// if control = control_apeman then
67911: LD_VAR 0 4
67915: PUSH
67916: LD_INT 5
67918: EQUAL
67919: IFFALSE 68028
// begin tmp := UnitsInside ( factory ) ;
67921: LD_ADDR_VAR 0 8
67925: PUSH
67926: LD_VAR 0 1
67930: PPUSH
67931: CALL_OW 313
67935: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67936: LD_VAR 0 8
67940: PPUSH
67941: LD_INT 25
67943: PUSH
67944: LD_INT 12
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PPUSH
67951: CALL_OW 72
67955: NOT
67956: IFFALSE 67966
// control := control_manual ;
67958: LD_ADDR_VAR 0 4
67962: PUSH
67963: LD_INT 1
67965: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67966: LD_ADDR_VAR 0 8
67970: PUSH
67971: LD_VAR 0 1
67975: PPUSH
67976: CALL 67663 0 1
67980: ST_TO_ADDR
// if tmp then
67981: LD_VAR 0 8
67985: IFFALSE 68028
// begin for i in tmp do
67987: LD_ADDR_VAR 0 7
67991: PUSH
67992: LD_VAR 0 8
67996: PUSH
67997: FOR_IN
67998: IFFALSE 68026
// if i [ 1 ] = b_ext_radio then
68000: LD_VAR 0 7
68004: PUSH
68005: LD_INT 1
68007: ARRAY
68008: PUSH
68009: LD_INT 22
68011: EQUAL
68012: IFFALSE 68024
// begin control := control_remote ;
68014: LD_ADDR_VAR 0 4
68018: PUSH
68019: LD_INT 2
68021: ST_TO_ADDR
// break ;
68022: GO 68026
// end ;
68024: GO 67997
68026: POP
68027: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68028: LD_VAR 0 1
68032: PPUSH
68033: LD_VAR 0 2
68037: PPUSH
68038: LD_VAR 0 3
68042: PPUSH
68043: LD_VAR 0 4
68047: PPUSH
68048: LD_VAR 0 5
68052: PPUSH
68053: CALL_OW 448
68057: IFFALSE 68092
// begin result := [ chassis , engine , control , weapon ] ;
68059: LD_ADDR_VAR 0 6
68063: PUSH
68064: LD_VAR 0 2
68068: PUSH
68069: LD_VAR 0 3
68073: PUSH
68074: LD_VAR 0 4
68078: PUSH
68079: LD_VAR 0 5
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: LIST
68088: LIST
68089: ST_TO_ADDR
// exit ;
68090: GO 68504
// end ; _chassis := AvailableChassisList ( factory ) ;
68092: LD_ADDR_VAR 0 9
68096: PUSH
68097: LD_VAR 0 1
68101: PPUSH
68102: CALL_OW 475
68106: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68107: LD_ADDR_VAR 0 11
68111: PUSH
68112: LD_VAR 0 1
68116: PPUSH
68117: CALL_OW 476
68121: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68122: LD_ADDR_VAR 0 12
68126: PUSH
68127: LD_VAR 0 1
68131: PPUSH
68132: CALL_OW 477
68136: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68137: LD_ADDR_VAR 0 10
68141: PUSH
68142: LD_VAR 0 1
68146: PPUSH
68147: CALL_OW 478
68151: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68152: LD_VAR 0 9
68156: NOT
68157: PUSH
68158: LD_VAR 0 11
68162: NOT
68163: OR
68164: PUSH
68165: LD_VAR 0 12
68169: NOT
68170: OR
68171: PUSH
68172: LD_VAR 0 10
68176: NOT
68177: OR
68178: IFFALSE 68213
// begin result := [ chassis , engine , control , weapon ] ;
68180: LD_ADDR_VAR 0 6
68184: PUSH
68185: LD_VAR 0 2
68189: PUSH
68190: LD_VAR 0 3
68194: PUSH
68195: LD_VAR 0 4
68199: PUSH
68200: LD_VAR 0 5
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: ST_TO_ADDR
// exit ;
68211: GO 68504
// end ; if not chassis in _chassis then
68213: LD_VAR 0 2
68217: PUSH
68218: LD_VAR 0 9
68222: IN
68223: NOT
68224: IFFALSE 68250
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68226: LD_ADDR_VAR 0 2
68230: PUSH
68231: LD_VAR 0 9
68235: PUSH
68236: LD_INT 1
68238: PPUSH
68239: LD_VAR 0 9
68243: PPUSH
68244: CALL_OW 12
68248: ARRAY
68249: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68250: LD_VAR 0 2
68254: PPUSH
68255: LD_VAR 0 3
68259: PPUSH
68260: CALL 68509 0 2
68264: NOT
68265: IFFALSE 68324
// repeat engine := _engine [ 1 ] ;
68267: LD_ADDR_VAR 0 3
68271: PUSH
68272: LD_VAR 0 11
68276: PUSH
68277: LD_INT 1
68279: ARRAY
68280: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68281: LD_ADDR_VAR 0 11
68285: PUSH
68286: LD_VAR 0 11
68290: PPUSH
68291: LD_INT 1
68293: PPUSH
68294: CALL_OW 3
68298: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68299: LD_VAR 0 2
68303: PPUSH
68304: LD_VAR 0 3
68308: PPUSH
68309: CALL 68509 0 2
68313: PUSH
68314: LD_VAR 0 11
68318: PUSH
68319: EMPTY
68320: EQUAL
68321: OR
68322: IFFALSE 68267
// if not control in _control then
68324: LD_VAR 0 4
68328: PUSH
68329: LD_VAR 0 12
68333: IN
68334: NOT
68335: IFFALSE 68361
// control := _control [ rand ( 1 , _control ) ] ;
68337: LD_ADDR_VAR 0 4
68341: PUSH
68342: LD_VAR 0 12
68346: PUSH
68347: LD_INT 1
68349: PPUSH
68350: LD_VAR 0 12
68354: PPUSH
68355: CALL_OW 12
68359: ARRAY
68360: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68361: LD_VAR 0 2
68365: PPUSH
68366: LD_VAR 0 5
68370: PPUSH
68371: CALL 68729 0 2
68375: NOT
68376: IFFALSE 68435
// repeat weapon := _weapon [ 1 ] ;
68378: LD_ADDR_VAR 0 5
68382: PUSH
68383: LD_VAR 0 10
68387: PUSH
68388: LD_INT 1
68390: ARRAY
68391: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68392: LD_ADDR_VAR 0 10
68396: PUSH
68397: LD_VAR 0 10
68401: PPUSH
68402: LD_INT 1
68404: PPUSH
68405: CALL_OW 3
68409: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68410: LD_VAR 0 2
68414: PPUSH
68415: LD_VAR 0 5
68419: PPUSH
68420: CALL 68729 0 2
68424: PUSH
68425: LD_VAR 0 10
68429: PUSH
68430: EMPTY
68431: EQUAL
68432: OR
68433: IFFALSE 68378
// result := [ ] ;
68435: LD_ADDR_VAR 0 6
68439: PUSH
68440: EMPTY
68441: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68442: LD_VAR 0 1
68446: PPUSH
68447: LD_VAR 0 2
68451: PPUSH
68452: LD_VAR 0 3
68456: PPUSH
68457: LD_VAR 0 4
68461: PPUSH
68462: LD_VAR 0 5
68466: PPUSH
68467: CALL_OW 448
68471: IFFALSE 68504
// result := [ chassis , engine , control , weapon ] ;
68473: LD_ADDR_VAR 0 6
68477: PUSH
68478: LD_VAR 0 2
68482: PUSH
68483: LD_VAR 0 3
68487: PUSH
68488: LD_VAR 0 4
68492: PUSH
68493: LD_VAR 0 5
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: ST_TO_ADDR
// end ;
68504: LD_VAR 0 6
68508: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68509: LD_INT 0
68511: PPUSH
// if not chassis or not engine then
68512: LD_VAR 0 1
68516: NOT
68517: PUSH
68518: LD_VAR 0 2
68522: NOT
68523: OR
68524: IFFALSE 68528
// exit ;
68526: GO 68724
// case engine of engine_solar :
68528: LD_VAR 0 2
68532: PUSH
68533: LD_INT 2
68535: DOUBLE
68536: EQUAL
68537: IFTRUE 68541
68539: GO 68579
68541: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68542: LD_ADDR_VAR 0 3
68546: PUSH
68547: LD_INT 11
68549: PUSH
68550: LD_INT 12
68552: PUSH
68553: LD_INT 13
68555: PUSH
68556: LD_INT 14
68558: PUSH
68559: LD_INT 1
68561: PUSH
68562: LD_INT 2
68564: PUSH
68565: LD_INT 3
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: LIST
68572: LIST
68573: LIST
68574: LIST
68575: LIST
68576: ST_TO_ADDR
68577: GO 68708
68579: LD_INT 1
68581: DOUBLE
68582: EQUAL
68583: IFTRUE 68587
68585: GO 68649
68587: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68588: LD_ADDR_VAR 0 3
68592: PUSH
68593: LD_INT 11
68595: PUSH
68596: LD_INT 12
68598: PUSH
68599: LD_INT 13
68601: PUSH
68602: LD_INT 14
68604: PUSH
68605: LD_INT 1
68607: PUSH
68608: LD_INT 2
68610: PUSH
68611: LD_INT 3
68613: PUSH
68614: LD_INT 4
68616: PUSH
68617: LD_INT 5
68619: PUSH
68620: LD_INT 21
68622: PUSH
68623: LD_INT 23
68625: PUSH
68626: LD_INT 22
68628: PUSH
68629: LD_INT 24
68631: PUSH
68632: EMPTY
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: ST_TO_ADDR
68647: GO 68708
68649: LD_INT 3
68651: DOUBLE
68652: EQUAL
68653: IFTRUE 68657
68655: GO 68707
68657: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68658: LD_ADDR_VAR 0 3
68662: PUSH
68663: LD_INT 13
68665: PUSH
68666: LD_INT 14
68668: PUSH
68669: LD_INT 2
68671: PUSH
68672: LD_INT 3
68674: PUSH
68675: LD_INT 4
68677: PUSH
68678: LD_INT 5
68680: PUSH
68681: LD_INT 21
68683: PUSH
68684: LD_INT 22
68686: PUSH
68687: LD_INT 23
68689: PUSH
68690: LD_INT 24
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: ST_TO_ADDR
68705: GO 68708
68707: POP
// result := ( chassis in result ) ;
68708: LD_ADDR_VAR 0 3
68712: PUSH
68713: LD_VAR 0 1
68717: PUSH
68718: LD_VAR 0 3
68722: IN
68723: ST_TO_ADDR
// end ;
68724: LD_VAR 0 3
68728: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68729: LD_INT 0
68731: PPUSH
// if not chassis or not weapon then
68732: LD_VAR 0 1
68736: NOT
68737: PUSH
68738: LD_VAR 0 2
68742: NOT
68743: OR
68744: IFFALSE 68748
// exit ;
68746: GO 69774
// case weapon of us_machine_gun :
68748: LD_VAR 0 2
68752: PUSH
68753: LD_INT 2
68755: DOUBLE
68756: EQUAL
68757: IFTRUE 68761
68759: GO 68791
68761: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68762: LD_ADDR_VAR 0 3
68766: PUSH
68767: LD_INT 1
68769: PUSH
68770: LD_INT 2
68772: PUSH
68773: LD_INT 3
68775: PUSH
68776: LD_INT 4
68778: PUSH
68779: LD_INT 5
68781: PUSH
68782: EMPTY
68783: LIST
68784: LIST
68785: LIST
68786: LIST
68787: LIST
68788: ST_TO_ADDR
68789: GO 69758
68791: LD_INT 3
68793: DOUBLE
68794: EQUAL
68795: IFTRUE 68799
68797: GO 68829
68799: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68800: LD_ADDR_VAR 0 3
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: LD_INT 2
68810: PUSH
68811: LD_INT 3
68813: PUSH
68814: LD_INT 4
68816: PUSH
68817: LD_INT 5
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: ST_TO_ADDR
68827: GO 69758
68829: LD_INT 11
68831: DOUBLE
68832: EQUAL
68833: IFTRUE 68837
68835: GO 68867
68837: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68838: LD_ADDR_VAR 0 3
68842: PUSH
68843: LD_INT 1
68845: PUSH
68846: LD_INT 2
68848: PUSH
68849: LD_INT 3
68851: PUSH
68852: LD_INT 4
68854: PUSH
68855: LD_INT 5
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: ST_TO_ADDR
68865: GO 69758
68867: LD_INT 4
68869: DOUBLE
68870: EQUAL
68871: IFTRUE 68875
68873: GO 68901
68875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68876: LD_ADDR_VAR 0 3
68880: PUSH
68881: LD_INT 2
68883: PUSH
68884: LD_INT 3
68886: PUSH
68887: LD_INT 4
68889: PUSH
68890: LD_INT 5
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: ST_TO_ADDR
68899: GO 69758
68901: LD_INT 5
68903: DOUBLE
68904: EQUAL
68905: IFTRUE 68909
68907: GO 68935
68909: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68910: LD_ADDR_VAR 0 3
68914: PUSH
68915: LD_INT 2
68917: PUSH
68918: LD_INT 3
68920: PUSH
68921: LD_INT 4
68923: PUSH
68924: LD_INT 5
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: LIST
68931: LIST
68932: ST_TO_ADDR
68933: GO 69758
68935: LD_INT 9
68937: DOUBLE
68938: EQUAL
68939: IFTRUE 68943
68941: GO 68969
68943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68944: LD_ADDR_VAR 0 3
68948: PUSH
68949: LD_INT 2
68951: PUSH
68952: LD_INT 3
68954: PUSH
68955: LD_INT 4
68957: PUSH
68958: LD_INT 5
68960: PUSH
68961: EMPTY
68962: LIST
68963: LIST
68964: LIST
68965: LIST
68966: ST_TO_ADDR
68967: GO 69758
68969: LD_INT 7
68971: DOUBLE
68972: EQUAL
68973: IFTRUE 68977
68975: GO 69003
68977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68978: LD_ADDR_VAR 0 3
68982: PUSH
68983: LD_INT 2
68985: PUSH
68986: LD_INT 3
68988: PUSH
68989: LD_INT 4
68991: PUSH
68992: LD_INT 5
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: LIST
68999: LIST
69000: ST_TO_ADDR
69001: GO 69758
69003: LD_INT 12
69005: DOUBLE
69006: EQUAL
69007: IFTRUE 69011
69009: GO 69037
69011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69012: LD_ADDR_VAR 0 3
69016: PUSH
69017: LD_INT 2
69019: PUSH
69020: LD_INT 3
69022: PUSH
69023: LD_INT 4
69025: PUSH
69026: LD_INT 5
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: LIST
69033: LIST
69034: ST_TO_ADDR
69035: GO 69758
69037: LD_INT 13
69039: DOUBLE
69040: EQUAL
69041: IFTRUE 69045
69043: GO 69071
69045: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69046: LD_ADDR_VAR 0 3
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: LD_INT 3
69056: PUSH
69057: LD_INT 4
69059: PUSH
69060: LD_INT 5
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: ST_TO_ADDR
69069: GO 69758
69071: LD_INT 14
69073: DOUBLE
69074: EQUAL
69075: IFTRUE 69079
69077: GO 69097
69079: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69080: LD_ADDR_VAR 0 3
69084: PUSH
69085: LD_INT 4
69087: PUSH
69088: LD_INT 5
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: ST_TO_ADDR
69095: GO 69758
69097: LD_INT 6
69099: DOUBLE
69100: EQUAL
69101: IFTRUE 69105
69103: GO 69123
69105: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69106: LD_ADDR_VAR 0 3
69110: PUSH
69111: LD_INT 4
69113: PUSH
69114: LD_INT 5
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: ST_TO_ADDR
69121: GO 69758
69123: LD_INT 10
69125: DOUBLE
69126: EQUAL
69127: IFTRUE 69131
69129: GO 69149
69131: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69132: LD_ADDR_VAR 0 3
69136: PUSH
69137: LD_INT 4
69139: PUSH
69140: LD_INT 5
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: ST_TO_ADDR
69147: GO 69758
69149: LD_INT 22
69151: DOUBLE
69152: EQUAL
69153: IFTRUE 69157
69155: GO 69183
69157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69158: LD_ADDR_VAR 0 3
69162: PUSH
69163: LD_INT 11
69165: PUSH
69166: LD_INT 12
69168: PUSH
69169: LD_INT 13
69171: PUSH
69172: LD_INT 14
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: ST_TO_ADDR
69181: GO 69758
69183: LD_INT 23
69185: DOUBLE
69186: EQUAL
69187: IFTRUE 69191
69189: GO 69217
69191: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69192: LD_ADDR_VAR 0 3
69196: PUSH
69197: LD_INT 11
69199: PUSH
69200: LD_INT 12
69202: PUSH
69203: LD_INT 13
69205: PUSH
69206: LD_INT 14
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: LIST
69213: LIST
69214: ST_TO_ADDR
69215: GO 69758
69217: LD_INT 24
69219: DOUBLE
69220: EQUAL
69221: IFTRUE 69225
69223: GO 69251
69225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69226: LD_ADDR_VAR 0 3
69230: PUSH
69231: LD_INT 11
69233: PUSH
69234: LD_INT 12
69236: PUSH
69237: LD_INT 13
69239: PUSH
69240: LD_INT 14
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: ST_TO_ADDR
69249: GO 69758
69251: LD_INT 30
69253: DOUBLE
69254: EQUAL
69255: IFTRUE 69259
69257: GO 69285
69259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69260: LD_ADDR_VAR 0 3
69264: PUSH
69265: LD_INT 11
69267: PUSH
69268: LD_INT 12
69270: PUSH
69271: LD_INT 13
69273: PUSH
69274: LD_INT 14
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: ST_TO_ADDR
69283: GO 69758
69285: LD_INT 25
69287: DOUBLE
69288: EQUAL
69289: IFTRUE 69293
69291: GO 69311
69293: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69294: LD_ADDR_VAR 0 3
69298: PUSH
69299: LD_INT 13
69301: PUSH
69302: LD_INT 14
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: ST_TO_ADDR
69309: GO 69758
69311: LD_INT 27
69313: DOUBLE
69314: EQUAL
69315: IFTRUE 69319
69317: GO 69337
69319: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69320: LD_ADDR_VAR 0 3
69324: PUSH
69325: LD_INT 13
69327: PUSH
69328: LD_INT 14
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: ST_TO_ADDR
69335: GO 69758
69337: LD_INT 28
69339: DOUBLE
69340: EQUAL
69341: IFTRUE 69345
69343: GO 69363
69345: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69346: LD_ADDR_VAR 0 3
69350: PUSH
69351: LD_INT 13
69353: PUSH
69354: LD_INT 14
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: ST_TO_ADDR
69361: GO 69758
69363: LD_INT 29
69365: DOUBLE
69366: EQUAL
69367: IFTRUE 69371
69369: GO 69389
69371: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69372: LD_ADDR_VAR 0 3
69376: PUSH
69377: LD_INT 13
69379: PUSH
69380: LD_INT 14
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: ST_TO_ADDR
69387: GO 69758
69389: LD_INT 31
69391: DOUBLE
69392: EQUAL
69393: IFTRUE 69397
69395: GO 69415
69397: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69398: LD_ADDR_VAR 0 3
69402: PUSH
69403: LD_INT 13
69405: PUSH
69406: LD_INT 14
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: ST_TO_ADDR
69413: GO 69758
69415: LD_INT 26
69417: DOUBLE
69418: EQUAL
69419: IFTRUE 69423
69421: GO 69441
69423: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69424: LD_ADDR_VAR 0 3
69428: PUSH
69429: LD_INT 13
69431: PUSH
69432: LD_INT 14
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: ST_TO_ADDR
69439: GO 69758
69441: LD_INT 42
69443: DOUBLE
69444: EQUAL
69445: IFTRUE 69449
69447: GO 69475
69449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69450: LD_ADDR_VAR 0 3
69454: PUSH
69455: LD_INT 21
69457: PUSH
69458: LD_INT 22
69460: PUSH
69461: LD_INT 23
69463: PUSH
69464: LD_INT 24
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: ST_TO_ADDR
69473: GO 69758
69475: LD_INT 43
69477: DOUBLE
69478: EQUAL
69479: IFTRUE 69483
69481: GO 69509
69483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69484: LD_ADDR_VAR 0 3
69488: PUSH
69489: LD_INT 21
69491: PUSH
69492: LD_INT 22
69494: PUSH
69495: LD_INT 23
69497: PUSH
69498: LD_INT 24
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: ST_TO_ADDR
69507: GO 69758
69509: LD_INT 44
69511: DOUBLE
69512: EQUAL
69513: IFTRUE 69517
69515: GO 69543
69517: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69518: LD_ADDR_VAR 0 3
69522: PUSH
69523: LD_INT 21
69525: PUSH
69526: LD_INT 22
69528: PUSH
69529: LD_INT 23
69531: PUSH
69532: LD_INT 24
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: LIST
69539: LIST
69540: ST_TO_ADDR
69541: GO 69758
69543: LD_INT 45
69545: DOUBLE
69546: EQUAL
69547: IFTRUE 69551
69549: GO 69577
69551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69552: LD_ADDR_VAR 0 3
69556: PUSH
69557: LD_INT 21
69559: PUSH
69560: LD_INT 22
69562: PUSH
69563: LD_INT 23
69565: PUSH
69566: LD_INT 24
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: LIST
69573: LIST
69574: ST_TO_ADDR
69575: GO 69758
69577: LD_INT 49
69579: DOUBLE
69580: EQUAL
69581: IFTRUE 69585
69583: GO 69611
69585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69586: LD_ADDR_VAR 0 3
69590: PUSH
69591: LD_INT 21
69593: PUSH
69594: LD_INT 22
69596: PUSH
69597: LD_INT 23
69599: PUSH
69600: LD_INT 24
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
69609: GO 69758
69611: LD_INT 51
69613: DOUBLE
69614: EQUAL
69615: IFTRUE 69619
69617: GO 69645
69619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69620: LD_ADDR_VAR 0 3
69624: PUSH
69625: LD_INT 21
69627: PUSH
69628: LD_INT 22
69630: PUSH
69631: LD_INT 23
69633: PUSH
69634: LD_INT 24
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: ST_TO_ADDR
69643: GO 69758
69645: LD_INT 52
69647: DOUBLE
69648: EQUAL
69649: IFTRUE 69653
69651: GO 69679
69653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69654: LD_ADDR_VAR 0 3
69658: PUSH
69659: LD_INT 21
69661: PUSH
69662: LD_INT 22
69664: PUSH
69665: LD_INT 23
69667: PUSH
69668: LD_INT 24
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: ST_TO_ADDR
69677: GO 69758
69679: LD_INT 53
69681: DOUBLE
69682: EQUAL
69683: IFTRUE 69687
69685: GO 69705
69687: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69688: LD_ADDR_VAR 0 3
69692: PUSH
69693: LD_INT 23
69695: PUSH
69696: LD_INT 24
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: ST_TO_ADDR
69703: GO 69758
69705: LD_INT 46
69707: DOUBLE
69708: EQUAL
69709: IFTRUE 69713
69711: GO 69731
69713: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69714: LD_ADDR_VAR 0 3
69718: PUSH
69719: LD_INT 23
69721: PUSH
69722: LD_INT 24
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: ST_TO_ADDR
69729: GO 69758
69731: LD_INT 47
69733: DOUBLE
69734: EQUAL
69735: IFTRUE 69739
69737: GO 69757
69739: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69740: LD_ADDR_VAR 0 3
69744: PUSH
69745: LD_INT 23
69747: PUSH
69748: LD_INT 24
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: ST_TO_ADDR
69755: GO 69758
69757: POP
// result := ( chassis in result ) ;
69758: LD_ADDR_VAR 0 3
69762: PUSH
69763: LD_VAR 0 1
69767: PUSH
69768: LD_VAR 0 3
69772: IN
69773: ST_TO_ADDR
// end ;
69774: LD_VAR 0 3
69778: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69779: LD_INT 0
69781: PPUSH
69782: PPUSH
69783: PPUSH
69784: PPUSH
69785: PPUSH
69786: PPUSH
69787: PPUSH
// result := array ;
69788: LD_ADDR_VAR 0 5
69792: PUSH
69793: LD_VAR 0 1
69797: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69798: LD_VAR 0 1
69802: NOT
69803: PUSH
69804: LD_VAR 0 2
69808: NOT
69809: OR
69810: PUSH
69811: LD_VAR 0 3
69815: NOT
69816: OR
69817: PUSH
69818: LD_VAR 0 2
69822: PUSH
69823: LD_VAR 0 1
69827: GREATER
69828: OR
69829: PUSH
69830: LD_VAR 0 3
69834: PUSH
69835: LD_VAR 0 1
69839: GREATER
69840: OR
69841: IFFALSE 69845
// exit ;
69843: GO 70141
// if direction then
69845: LD_VAR 0 4
69849: IFFALSE 69913
// begin d := 1 ;
69851: LD_ADDR_VAR 0 9
69855: PUSH
69856: LD_INT 1
69858: ST_TO_ADDR
// if i_from > i_to then
69859: LD_VAR 0 2
69863: PUSH
69864: LD_VAR 0 3
69868: GREATER
69869: IFFALSE 69895
// length := ( array - i_from ) + i_to else
69871: LD_ADDR_VAR 0 11
69875: PUSH
69876: LD_VAR 0 1
69880: PUSH
69881: LD_VAR 0 2
69885: MINUS
69886: PUSH
69887: LD_VAR 0 3
69891: PLUS
69892: ST_TO_ADDR
69893: GO 69911
// length := i_to - i_from ;
69895: LD_ADDR_VAR 0 11
69899: PUSH
69900: LD_VAR 0 3
69904: PUSH
69905: LD_VAR 0 2
69909: MINUS
69910: ST_TO_ADDR
// end else
69911: GO 69974
// begin d := - 1 ;
69913: LD_ADDR_VAR 0 9
69917: PUSH
69918: LD_INT 1
69920: NEG
69921: ST_TO_ADDR
// if i_from > i_to then
69922: LD_VAR 0 2
69926: PUSH
69927: LD_VAR 0 3
69931: GREATER
69932: IFFALSE 69952
// length := i_from - i_to else
69934: LD_ADDR_VAR 0 11
69938: PUSH
69939: LD_VAR 0 2
69943: PUSH
69944: LD_VAR 0 3
69948: MINUS
69949: ST_TO_ADDR
69950: GO 69974
// length := ( array - i_to ) + i_from ;
69952: LD_ADDR_VAR 0 11
69956: PUSH
69957: LD_VAR 0 1
69961: PUSH
69962: LD_VAR 0 3
69966: MINUS
69967: PUSH
69968: LD_VAR 0 2
69972: PLUS
69973: ST_TO_ADDR
// end ; if not length then
69974: LD_VAR 0 11
69978: NOT
69979: IFFALSE 69983
// exit ;
69981: GO 70141
// tmp := array ;
69983: LD_ADDR_VAR 0 10
69987: PUSH
69988: LD_VAR 0 1
69992: ST_TO_ADDR
// for i = 1 to length do
69993: LD_ADDR_VAR 0 6
69997: PUSH
69998: DOUBLE
69999: LD_INT 1
70001: DEC
70002: ST_TO_ADDR
70003: LD_VAR 0 11
70007: PUSH
70008: FOR_TO
70009: IFFALSE 70129
// begin for j = 1 to array do
70011: LD_ADDR_VAR 0 7
70015: PUSH
70016: DOUBLE
70017: LD_INT 1
70019: DEC
70020: ST_TO_ADDR
70021: LD_VAR 0 1
70025: PUSH
70026: FOR_TO
70027: IFFALSE 70115
// begin k := j + d ;
70029: LD_ADDR_VAR 0 8
70033: PUSH
70034: LD_VAR 0 7
70038: PUSH
70039: LD_VAR 0 9
70043: PLUS
70044: ST_TO_ADDR
// if k > array then
70045: LD_VAR 0 8
70049: PUSH
70050: LD_VAR 0 1
70054: GREATER
70055: IFFALSE 70065
// k := 1 ;
70057: LD_ADDR_VAR 0 8
70061: PUSH
70062: LD_INT 1
70064: ST_TO_ADDR
// if not k then
70065: LD_VAR 0 8
70069: NOT
70070: IFFALSE 70082
// k := array ;
70072: LD_ADDR_VAR 0 8
70076: PUSH
70077: LD_VAR 0 1
70081: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70082: LD_ADDR_VAR 0 10
70086: PUSH
70087: LD_VAR 0 10
70091: PPUSH
70092: LD_VAR 0 8
70096: PPUSH
70097: LD_VAR 0 1
70101: PUSH
70102: LD_VAR 0 7
70106: ARRAY
70107: PPUSH
70108: CALL_OW 1
70112: ST_TO_ADDR
// end ;
70113: GO 70026
70115: POP
70116: POP
// array := tmp ;
70117: LD_ADDR_VAR 0 1
70121: PUSH
70122: LD_VAR 0 10
70126: ST_TO_ADDR
// end ;
70127: GO 70008
70129: POP
70130: POP
// result := array ;
70131: LD_ADDR_VAR 0 5
70135: PUSH
70136: LD_VAR 0 1
70140: ST_TO_ADDR
// end ;
70141: LD_VAR 0 5
70145: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70146: LD_INT 0
70148: PPUSH
70149: PPUSH
// result := 0 ;
70150: LD_ADDR_VAR 0 3
70154: PUSH
70155: LD_INT 0
70157: ST_TO_ADDR
// if not array or not value in array then
70158: LD_VAR 0 1
70162: NOT
70163: PUSH
70164: LD_VAR 0 2
70168: PUSH
70169: LD_VAR 0 1
70173: IN
70174: NOT
70175: OR
70176: IFFALSE 70180
// exit ;
70178: GO 70234
// for i = 1 to array do
70180: LD_ADDR_VAR 0 4
70184: PUSH
70185: DOUBLE
70186: LD_INT 1
70188: DEC
70189: ST_TO_ADDR
70190: LD_VAR 0 1
70194: PUSH
70195: FOR_TO
70196: IFFALSE 70232
// if value = array [ i ] then
70198: LD_VAR 0 2
70202: PUSH
70203: LD_VAR 0 1
70207: PUSH
70208: LD_VAR 0 4
70212: ARRAY
70213: EQUAL
70214: IFFALSE 70230
// begin result := i ;
70216: LD_ADDR_VAR 0 3
70220: PUSH
70221: LD_VAR 0 4
70225: ST_TO_ADDR
// exit ;
70226: POP
70227: POP
70228: GO 70234
// end ;
70230: GO 70195
70232: POP
70233: POP
// end ;
70234: LD_VAR 0 3
70238: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70239: LD_INT 0
70241: PPUSH
// vc_chassis := chassis ;
70242: LD_ADDR_OWVAR 37
70246: PUSH
70247: LD_VAR 0 1
70251: ST_TO_ADDR
// vc_engine := engine ;
70252: LD_ADDR_OWVAR 39
70256: PUSH
70257: LD_VAR 0 2
70261: ST_TO_ADDR
// vc_control := control ;
70262: LD_ADDR_OWVAR 38
70266: PUSH
70267: LD_VAR 0 3
70271: ST_TO_ADDR
// vc_weapon := weapon ;
70272: LD_ADDR_OWVAR 40
70276: PUSH
70277: LD_VAR 0 4
70281: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70282: LD_ADDR_OWVAR 41
70286: PUSH
70287: LD_VAR 0 5
70291: ST_TO_ADDR
// end ;
70292: LD_VAR 0 6
70296: RET
// export function WantPlant ( unit ) ; var task ; begin
70297: LD_INT 0
70299: PPUSH
70300: PPUSH
// result := false ;
70301: LD_ADDR_VAR 0 2
70305: PUSH
70306: LD_INT 0
70308: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70309: LD_ADDR_VAR 0 3
70313: PUSH
70314: LD_VAR 0 1
70318: PPUSH
70319: CALL_OW 437
70323: ST_TO_ADDR
// if task then
70324: LD_VAR 0 3
70328: IFFALSE 70356
// if task [ 1 ] [ 1 ] = p then
70330: LD_VAR 0 3
70334: PUSH
70335: LD_INT 1
70337: ARRAY
70338: PUSH
70339: LD_INT 1
70341: ARRAY
70342: PUSH
70343: LD_STRING p
70345: EQUAL
70346: IFFALSE 70356
// result := true ;
70348: LD_ADDR_VAR 0 2
70352: PUSH
70353: LD_INT 1
70355: ST_TO_ADDR
// end ;
70356: LD_VAR 0 2
70360: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70361: LD_INT 0
70363: PPUSH
70364: PPUSH
70365: PPUSH
70366: PPUSH
// if pos < 1 then
70367: LD_VAR 0 2
70371: PUSH
70372: LD_INT 1
70374: LESS
70375: IFFALSE 70379
// exit ;
70377: GO 70682
// if pos = 1 then
70379: LD_VAR 0 2
70383: PUSH
70384: LD_INT 1
70386: EQUAL
70387: IFFALSE 70420
// result := Replace ( arr , pos [ 1 ] , value ) else
70389: LD_ADDR_VAR 0 4
70393: PUSH
70394: LD_VAR 0 1
70398: PPUSH
70399: LD_VAR 0 2
70403: PUSH
70404: LD_INT 1
70406: ARRAY
70407: PPUSH
70408: LD_VAR 0 3
70412: PPUSH
70413: CALL_OW 1
70417: ST_TO_ADDR
70418: GO 70682
// begin tmp := arr ;
70420: LD_ADDR_VAR 0 6
70424: PUSH
70425: LD_VAR 0 1
70429: ST_TO_ADDR
// s_arr := [ tmp ] ;
70430: LD_ADDR_VAR 0 7
70434: PUSH
70435: LD_VAR 0 6
70439: PUSH
70440: EMPTY
70441: LIST
70442: ST_TO_ADDR
// for i = 1 to pos - 1 do
70443: LD_ADDR_VAR 0 5
70447: PUSH
70448: DOUBLE
70449: LD_INT 1
70451: DEC
70452: ST_TO_ADDR
70453: LD_VAR 0 2
70457: PUSH
70458: LD_INT 1
70460: MINUS
70461: PUSH
70462: FOR_TO
70463: IFFALSE 70508
// begin tmp := tmp [ pos [ i ] ] ;
70465: LD_ADDR_VAR 0 6
70469: PUSH
70470: LD_VAR 0 6
70474: PUSH
70475: LD_VAR 0 2
70479: PUSH
70480: LD_VAR 0 5
70484: ARRAY
70485: ARRAY
70486: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70487: LD_ADDR_VAR 0 7
70491: PUSH
70492: LD_VAR 0 7
70496: PUSH
70497: LD_VAR 0 6
70501: PUSH
70502: EMPTY
70503: LIST
70504: ADD
70505: ST_TO_ADDR
// end ;
70506: GO 70462
70508: POP
70509: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70510: LD_ADDR_VAR 0 6
70514: PUSH
70515: LD_VAR 0 6
70519: PPUSH
70520: LD_VAR 0 2
70524: PUSH
70525: LD_VAR 0 2
70529: ARRAY
70530: PPUSH
70531: LD_VAR 0 3
70535: PPUSH
70536: CALL_OW 1
70540: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70541: LD_ADDR_VAR 0 7
70545: PUSH
70546: LD_VAR 0 7
70550: PPUSH
70551: LD_VAR 0 7
70555: PPUSH
70556: LD_VAR 0 6
70560: PPUSH
70561: CALL_OW 1
70565: ST_TO_ADDR
// for i = s_arr downto 2 do
70566: LD_ADDR_VAR 0 5
70570: PUSH
70571: DOUBLE
70572: LD_VAR 0 7
70576: INC
70577: ST_TO_ADDR
70578: LD_INT 2
70580: PUSH
70581: FOR_DOWNTO
70582: IFFALSE 70666
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70584: LD_ADDR_VAR 0 6
70588: PUSH
70589: LD_VAR 0 7
70593: PUSH
70594: LD_VAR 0 5
70598: PUSH
70599: LD_INT 1
70601: MINUS
70602: ARRAY
70603: PPUSH
70604: LD_VAR 0 2
70608: PUSH
70609: LD_VAR 0 5
70613: PUSH
70614: LD_INT 1
70616: MINUS
70617: ARRAY
70618: PPUSH
70619: LD_VAR 0 7
70623: PUSH
70624: LD_VAR 0 5
70628: ARRAY
70629: PPUSH
70630: CALL_OW 1
70634: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70635: LD_ADDR_VAR 0 7
70639: PUSH
70640: LD_VAR 0 7
70644: PPUSH
70645: LD_VAR 0 5
70649: PUSH
70650: LD_INT 1
70652: MINUS
70653: PPUSH
70654: LD_VAR 0 6
70658: PPUSH
70659: CALL_OW 1
70663: ST_TO_ADDR
// end ;
70664: GO 70581
70666: POP
70667: POP
// result := s_arr [ 1 ] ;
70668: LD_ADDR_VAR 0 4
70672: PUSH
70673: LD_VAR 0 7
70677: PUSH
70678: LD_INT 1
70680: ARRAY
70681: ST_TO_ADDR
// end ; end ;
70682: LD_VAR 0 4
70686: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70687: LD_INT 0
70689: PPUSH
70690: PPUSH
// if not list then
70691: LD_VAR 0 1
70695: NOT
70696: IFFALSE 70700
// exit ;
70698: GO 70791
// i := list [ pos1 ] ;
70700: LD_ADDR_VAR 0 5
70704: PUSH
70705: LD_VAR 0 1
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: ST_TO_ADDR
// if not i then
70716: LD_VAR 0 5
70720: NOT
70721: IFFALSE 70725
// exit ;
70723: GO 70791
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70725: LD_ADDR_VAR 0 1
70729: PUSH
70730: LD_VAR 0 1
70734: PPUSH
70735: LD_VAR 0 2
70739: PPUSH
70740: LD_VAR 0 1
70744: PUSH
70745: LD_VAR 0 3
70749: ARRAY
70750: PPUSH
70751: CALL_OW 1
70755: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70756: LD_ADDR_VAR 0 1
70760: PUSH
70761: LD_VAR 0 1
70765: PPUSH
70766: LD_VAR 0 3
70770: PPUSH
70771: LD_VAR 0 5
70775: PPUSH
70776: CALL_OW 1
70780: ST_TO_ADDR
// result := list ;
70781: LD_ADDR_VAR 0 4
70785: PUSH
70786: LD_VAR 0 1
70790: ST_TO_ADDR
// end ;
70791: LD_VAR 0 4
70795: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70796: LD_INT 0
70798: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70799: LD_ADDR_VAR 0 5
70803: PUSH
70804: LD_VAR 0 1
70808: PPUSH
70809: CALL_OW 250
70813: PPUSH
70814: LD_VAR 0 1
70818: PPUSH
70819: CALL_OW 251
70823: PPUSH
70824: LD_VAR 0 2
70828: PPUSH
70829: LD_VAR 0 3
70833: PPUSH
70834: LD_VAR 0 4
70838: PPUSH
70839: CALL 70849 0 5
70843: ST_TO_ADDR
// end ;
70844: LD_VAR 0 5
70848: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70849: LD_INT 0
70851: PPUSH
70852: PPUSH
70853: PPUSH
70854: PPUSH
// if not list then
70855: LD_VAR 0 3
70859: NOT
70860: IFFALSE 70864
// exit ;
70862: GO 71252
// result := [ ] ;
70864: LD_ADDR_VAR 0 6
70868: PUSH
70869: EMPTY
70870: ST_TO_ADDR
// for i in list do
70871: LD_ADDR_VAR 0 7
70875: PUSH
70876: LD_VAR 0 3
70880: PUSH
70881: FOR_IN
70882: IFFALSE 71084
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70884: LD_ADDR_VAR 0 9
70888: PUSH
70889: LD_VAR 0 7
70893: PPUSH
70894: LD_VAR 0 1
70898: PPUSH
70899: LD_VAR 0 2
70903: PPUSH
70904: CALL_OW 297
70908: ST_TO_ADDR
// if not result then
70909: LD_VAR 0 6
70913: NOT
70914: IFFALSE 70940
// result := [ [ i , tmp ] ] else
70916: LD_ADDR_VAR 0 6
70920: PUSH
70921: LD_VAR 0 7
70925: PUSH
70926: LD_VAR 0 9
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: EMPTY
70936: LIST
70937: ST_TO_ADDR
70938: GO 71082
// begin if result [ result ] [ 2 ] < tmp then
70940: LD_VAR 0 6
70944: PUSH
70945: LD_VAR 0 6
70949: ARRAY
70950: PUSH
70951: LD_INT 2
70953: ARRAY
70954: PUSH
70955: LD_VAR 0 9
70959: LESS
70960: IFFALSE 71002
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70962: LD_ADDR_VAR 0 6
70966: PUSH
70967: LD_VAR 0 6
70971: PPUSH
70972: LD_VAR 0 6
70976: PUSH
70977: LD_INT 1
70979: PLUS
70980: PPUSH
70981: LD_VAR 0 7
70985: PUSH
70986: LD_VAR 0 9
70990: PUSH
70991: EMPTY
70992: LIST
70993: LIST
70994: PPUSH
70995: CALL_OW 2
70999: ST_TO_ADDR
71000: GO 71082
// for j = 1 to result do
71002: LD_ADDR_VAR 0 8
71006: PUSH
71007: DOUBLE
71008: LD_INT 1
71010: DEC
71011: ST_TO_ADDR
71012: LD_VAR 0 6
71016: PUSH
71017: FOR_TO
71018: IFFALSE 71080
// begin if tmp < result [ j ] [ 2 ] then
71020: LD_VAR 0 9
71024: PUSH
71025: LD_VAR 0 6
71029: PUSH
71030: LD_VAR 0 8
71034: ARRAY
71035: PUSH
71036: LD_INT 2
71038: ARRAY
71039: LESS
71040: IFFALSE 71078
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71042: LD_ADDR_VAR 0 6
71046: PUSH
71047: LD_VAR 0 6
71051: PPUSH
71052: LD_VAR 0 8
71056: PPUSH
71057: LD_VAR 0 7
71061: PUSH
71062: LD_VAR 0 9
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PPUSH
71071: CALL_OW 2
71075: ST_TO_ADDR
// break ;
71076: GO 71080
// end ; end ;
71078: GO 71017
71080: POP
71081: POP
// end ; end ;
71082: GO 70881
71084: POP
71085: POP
// if result and not asc then
71086: LD_VAR 0 6
71090: PUSH
71091: LD_VAR 0 4
71095: NOT
71096: AND
71097: IFFALSE 71172
// begin tmp := result ;
71099: LD_ADDR_VAR 0 9
71103: PUSH
71104: LD_VAR 0 6
71108: ST_TO_ADDR
// for i = tmp downto 1 do
71109: LD_ADDR_VAR 0 7
71113: PUSH
71114: DOUBLE
71115: LD_VAR 0 9
71119: INC
71120: ST_TO_ADDR
71121: LD_INT 1
71123: PUSH
71124: FOR_DOWNTO
71125: IFFALSE 71170
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71127: LD_ADDR_VAR 0 6
71131: PUSH
71132: LD_VAR 0 6
71136: PPUSH
71137: LD_VAR 0 9
71141: PUSH
71142: LD_VAR 0 7
71146: MINUS
71147: PUSH
71148: LD_INT 1
71150: PLUS
71151: PPUSH
71152: LD_VAR 0 9
71156: PUSH
71157: LD_VAR 0 7
71161: ARRAY
71162: PPUSH
71163: CALL_OW 1
71167: ST_TO_ADDR
71168: GO 71124
71170: POP
71171: POP
// end ; tmp := [ ] ;
71172: LD_ADDR_VAR 0 9
71176: PUSH
71177: EMPTY
71178: ST_TO_ADDR
// if mode then
71179: LD_VAR 0 5
71183: IFFALSE 71252
// begin for i = 1 to result do
71185: LD_ADDR_VAR 0 7
71189: PUSH
71190: DOUBLE
71191: LD_INT 1
71193: DEC
71194: ST_TO_ADDR
71195: LD_VAR 0 6
71199: PUSH
71200: FOR_TO
71201: IFFALSE 71240
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71203: LD_ADDR_VAR 0 9
71207: PUSH
71208: LD_VAR 0 9
71212: PPUSH
71213: LD_VAR 0 7
71217: PPUSH
71218: LD_VAR 0 6
71222: PUSH
71223: LD_VAR 0 7
71227: ARRAY
71228: PUSH
71229: LD_INT 1
71231: ARRAY
71232: PPUSH
71233: CALL_OW 1
71237: ST_TO_ADDR
71238: GO 71200
71240: POP
71241: POP
// result := tmp ;
71242: LD_ADDR_VAR 0 6
71246: PUSH
71247: LD_VAR 0 9
71251: ST_TO_ADDR
// end ; end ;
71252: LD_VAR 0 6
71256: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71257: LD_INT 0
71259: PPUSH
71260: PPUSH
71261: PPUSH
71262: PPUSH
71263: PPUSH
71264: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71265: LD_ADDR_VAR 0 5
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: EMPTY
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: ST_TO_ADDR
// if not x or not y then
71287: LD_VAR 0 2
71291: NOT
71292: PUSH
71293: LD_VAR 0 3
71297: NOT
71298: OR
71299: IFFALSE 71303
// exit ;
71301: GO 72949
// if not range then
71303: LD_VAR 0 4
71307: NOT
71308: IFFALSE 71318
// range := 10 ;
71310: LD_ADDR_VAR 0 4
71314: PUSH
71315: LD_INT 10
71317: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71318: LD_ADDR_VAR 0 8
71322: PUSH
71323: LD_INT 81
71325: PUSH
71326: LD_VAR 0 1
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 92
71337: PUSH
71338: LD_VAR 0 2
71342: PUSH
71343: LD_VAR 0 3
71347: PUSH
71348: LD_VAR 0 4
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: PUSH
71359: LD_INT 3
71361: PUSH
71362: LD_INT 21
71364: PUSH
71365: LD_INT 3
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: LIST
71380: PPUSH
71381: CALL_OW 69
71385: ST_TO_ADDR
// if not tmp then
71386: LD_VAR 0 8
71390: NOT
71391: IFFALSE 71395
// exit ;
71393: GO 72949
// for i in tmp do
71395: LD_ADDR_VAR 0 6
71399: PUSH
71400: LD_VAR 0 8
71404: PUSH
71405: FOR_IN
71406: IFFALSE 72924
// begin points := [ 0 , 0 , 0 ] ;
71408: LD_ADDR_VAR 0 9
71412: PUSH
71413: LD_INT 0
71415: PUSH
71416: LD_INT 0
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: EMPTY
71423: LIST
71424: LIST
71425: LIST
71426: ST_TO_ADDR
// bpoints := 1 ;
71427: LD_ADDR_VAR 0 10
71431: PUSH
71432: LD_INT 1
71434: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71435: LD_VAR 0 6
71439: PPUSH
71440: CALL_OW 247
71444: PUSH
71445: LD_INT 1
71447: DOUBLE
71448: EQUAL
71449: IFTRUE 71453
71451: GO 72031
71453: POP
// begin if GetClass ( i ) = 1 then
71454: LD_VAR 0 6
71458: PPUSH
71459: CALL_OW 257
71463: PUSH
71464: LD_INT 1
71466: EQUAL
71467: IFFALSE 71488
// points := [ 10 , 5 , 3 ] ;
71469: LD_ADDR_VAR 0 9
71473: PUSH
71474: LD_INT 10
71476: PUSH
71477: LD_INT 5
71479: PUSH
71480: LD_INT 3
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: LIST
71487: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71488: LD_VAR 0 6
71492: PPUSH
71493: CALL_OW 257
71497: PUSH
71498: LD_INT 2
71500: PUSH
71501: LD_INT 3
71503: PUSH
71504: LD_INT 4
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: LIST
71511: IN
71512: IFFALSE 71533
// points := [ 3 , 2 , 1 ] ;
71514: LD_ADDR_VAR 0 9
71518: PUSH
71519: LD_INT 3
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: LD_INT 1
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71533: LD_VAR 0 6
71537: PPUSH
71538: CALL_OW 257
71542: PUSH
71543: LD_INT 5
71545: EQUAL
71546: IFFALSE 71567
// points := [ 130 , 5 , 2 ] ;
71548: LD_ADDR_VAR 0 9
71552: PUSH
71553: LD_INT 130
71555: PUSH
71556: LD_INT 5
71558: PUSH
71559: LD_INT 2
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: LIST
71566: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71567: LD_VAR 0 6
71571: PPUSH
71572: CALL_OW 257
71576: PUSH
71577: LD_INT 8
71579: EQUAL
71580: IFFALSE 71601
// points := [ 35 , 35 , 30 ] ;
71582: LD_ADDR_VAR 0 9
71586: PUSH
71587: LD_INT 35
71589: PUSH
71590: LD_INT 35
71592: PUSH
71593: LD_INT 30
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: LIST
71600: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71601: LD_VAR 0 6
71605: PPUSH
71606: CALL_OW 257
71610: PUSH
71611: LD_INT 9
71613: EQUAL
71614: IFFALSE 71635
// points := [ 20 , 55 , 40 ] ;
71616: LD_ADDR_VAR 0 9
71620: PUSH
71621: LD_INT 20
71623: PUSH
71624: LD_INT 55
71626: PUSH
71627: LD_INT 40
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: LIST
71634: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71635: LD_VAR 0 6
71639: PPUSH
71640: CALL_OW 257
71644: PUSH
71645: LD_INT 12
71647: PUSH
71648: LD_INT 16
71650: PUSH
71651: EMPTY
71652: LIST
71653: LIST
71654: IN
71655: IFFALSE 71676
// points := [ 5 , 3 , 2 ] ;
71657: LD_ADDR_VAR 0 9
71661: PUSH
71662: LD_INT 5
71664: PUSH
71665: LD_INT 3
71667: PUSH
71668: LD_INT 2
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: LIST
71675: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71676: LD_VAR 0 6
71680: PPUSH
71681: CALL_OW 257
71685: PUSH
71686: LD_INT 17
71688: EQUAL
71689: IFFALSE 71710
// points := [ 100 , 50 , 75 ] ;
71691: LD_ADDR_VAR 0 9
71695: PUSH
71696: LD_INT 100
71698: PUSH
71699: LD_INT 50
71701: PUSH
71702: LD_INT 75
71704: PUSH
71705: EMPTY
71706: LIST
71707: LIST
71708: LIST
71709: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71710: LD_VAR 0 6
71714: PPUSH
71715: CALL_OW 257
71719: PUSH
71720: LD_INT 15
71722: EQUAL
71723: IFFALSE 71744
// points := [ 10 , 5 , 3 ] ;
71725: LD_ADDR_VAR 0 9
71729: PUSH
71730: LD_INT 10
71732: PUSH
71733: LD_INT 5
71735: PUSH
71736: LD_INT 3
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: LIST
71743: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71744: LD_VAR 0 6
71748: PPUSH
71749: CALL_OW 257
71753: PUSH
71754: LD_INT 14
71756: EQUAL
71757: IFFALSE 71778
// points := [ 10 , 0 , 0 ] ;
71759: LD_ADDR_VAR 0 9
71763: PUSH
71764: LD_INT 10
71766: PUSH
71767: LD_INT 0
71769: PUSH
71770: LD_INT 0
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: LIST
71777: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71778: LD_VAR 0 6
71782: PPUSH
71783: CALL_OW 257
71787: PUSH
71788: LD_INT 11
71790: EQUAL
71791: IFFALSE 71812
// points := [ 30 , 10 , 5 ] ;
71793: LD_ADDR_VAR 0 9
71797: PUSH
71798: LD_INT 30
71800: PUSH
71801: LD_INT 10
71803: PUSH
71804: LD_INT 5
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: LIST
71811: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71812: LD_VAR 0 1
71816: PPUSH
71817: LD_INT 5
71819: PPUSH
71820: CALL_OW 321
71824: PUSH
71825: LD_INT 2
71827: EQUAL
71828: IFFALSE 71845
// bpoints := bpoints * 1.8 ;
71830: LD_ADDR_VAR 0 10
71834: PUSH
71835: LD_VAR 0 10
71839: PUSH
71840: LD_REAL  1.80000000000000E+0000
71843: MUL
71844: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71845: LD_VAR 0 6
71849: PPUSH
71850: CALL_OW 257
71854: PUSH
71855: LD_INT 1
71857: PUSH
71858: LD_INT 2
71860: PUSH
71861: LD_INT 3
71863: PUSH
71864: LD_INT 4
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: IN
71873: PUSH
71874: LD_VAR 0 1
71878: PPUSH
71879: LD_INT 51
71881: PPUSH
71882: CALL_OW 321
71886: PUSH
71887: LD_INT 2
71889: EQUAL
71890: AND
71891: IFFALSE 71908
// bpoints := bpoints * 1.2 ;
71893: LD_ADDR_VAR 0 10
71897: PUSH
71898: LD_VAR 0 10
71902: PUSH
71903: LD_REAL  1.20000000000000E+0000
71906: MUL
71907: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71908: LD_VAR 0 6
71912: PPUSH
71913: CALL_OW 257
71917: PUSH
71918: LD_INT 5
71920: PUSH
71921: LD_INT 7
71923: PUSH
71924: LD_INT 9
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: LIST
71931: IN
71932: PUSH
71933: LD_VAR 0 1
71937: PPUSH
71938: LD_INT 52
71940: PPUSH
71941: CALL_OW 321
71945: PUSH
71946: LD_INT 2
71948: EQUAL
71949: AND
71950: IFFALSE 71967
// bpoints := bpoints * 1.5 ;
71952: LD_ADDR_VAR 0 10
71956: PUSH
71957: LD_VAR 0 10
71961: PUSH
71962: LD_REAL  1.50000000000000E+0000
71965: MUL
71966: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71967: LD_VAR 0 1
71971: PPUSH
71972: LD_INT 66
71974: PPUSH
71975: CALL_OW 321
71979: PUSH
71980: LD_INT 2
71982: EQUAL
71983: IFFALSE 72000
// bpoints := bpoints * 1.1 ;
71985: LD_ADDR_VAR 0 10
71989: PUSH
71990: LD_VAR 0 10
71994: PUSH
71995: LD_REAL  1.10000000000000E+0000
71998: MUL
71999: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72000: LD_ADDR_VAR 0 10
72004: PUSH
72005: LD_VAR 0 10
72009: PUSH
72010: LD_VAR 0 6
72014: PPUSH
72015: LD_INT 1
72017: PPUSH
72018: CALL_OW 259
72022: PUSH
72023: LD_REAL  1.15000000000000E+0000
72026: MUL
72027: MUL
72028: ST_TO_ADDR
// end ; unit_vehicle :
72029: GO 72853
72031: LD_INT 2
72033: DOUBLE
72034: EQUAL
72035: IFTRUE 72039
72037: GO 72841
72039: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72040: LD_VAR 0 6
72044: PPUSH
72045: CALL_OW 264
72049: PUSH
72050: LD_INT 2
72052: PUSH
72053: LD_INT 42
72055: PUSH
72056: LD_INT 24
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: LIST
72063: IN
72064: IFFALSE 72085
// points := [ 25 , 5 , 3 ] ;
72066: LD_ADDR_VAR 0 9
72070: PUSH
72071: LD_INT 25
72073: PUSH
72074: LD_INT 5
72076: PUSH
72077: LD_INT 3
72079: PUSH
72080: EMPTY
72081: LIST
72082: LIST
72083: LIST
72084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72085: LD_VAR 0 6
72089: PPUSH
72090: CALL_OW 264
72094: PUSH
72095: LD_INT 4
72097: PUSH
72098: LD_INT 43
72100: PUSH
72101: LD_INT 25
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: LIST
72108: IN
72109: IFFALSE 72130
// points := [ 40 , 15 , 5 ] ;
72111: LD_ADDR_VAR 0 9
72115: PUSH
72116: LD_INT 40
72118: PUSH
72119: LD_INT 15
72121: PUSH
72122: LD_INT 5
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: LIST
72129: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72130: LD_VAR 0 6
72134: PPUSH
72135: CALL_OW 264
72139: PUSH
72140: LD_INT 3
72142: PUSH
72143: LD_INT 23
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: IN
72150: IFFALSE 72171
// points := [ 7 , 25 , 8 ] ;
72152: LD_ADDR_VAR 0 9
72156: PUSH
72157: LD_INT 7
72159: PUSH
72160: LD_INT 25
72162: PUSH
72163: LD_INT 8
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: LIST
72170: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72171: LD_VAR 0 6
72175: PPUSH
72176: CALL_OW 264
72180: PUSH
72181: LD_INT 5
72183: PUSH
72184: LD_INT 27
72186: PUSH
72187: LD_INT 44
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: LIST
72194: IN
72195: IFFALSE 72216
// points := [ 14 , 50 , 16 ] ;
72197: LD_ADDR_VAR 0 9
72201: PUSH
72202: LD_INT 14
72204: PUSH
72205: LD_INT 50
72207: PUSH
72208: LD_INT 16
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: LIST
72215: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72216: LD_VAR 0 6
72220: PPUSH
72221: CALL_OW 264
72225: PUSH
72226: LD_INT 6
72228: PUSH
72229: LD_INT 46
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: IN
72236: IFFALSE 72257
// points := [ 32 , 120 , 70 ] ;
72238: LD_ADDR_VAR 0 9
72242: PUSH
72243: LD_INT 32
72245: PUSH
72246: LD_INT 120
72248: PUSH
72249: LD_INT 70
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: LIST
72256: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72257: LD_VAR 0 6
72261: PPUSH
72262: CALL_OW 264
72266: PUSH
72267: LD_INT 7
72269: PUSH
72270: LD_INT 28
72272: PUSH
72273: LD_INT 45
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: LIST
72280: IN
72281: IFFALSE 72302
// points := [ 35 , 20 , 45 ] ;
72283: LD_ADDR_VAR 0 9
72287: PUSH
72288: LD_INT 35
72290: PUSH
72291: LD_INT 20
72293: PUSH
72294: LD_INT 45
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: LIST
72301: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72302: LD_VAR 0 6
72306: PPUSH
72307: CALL_OW 264
72311: PUSH
72312: LD_INT 47
72314: PUSH
72315: EMPTY
72316: LIST
72317: IN
72318: IFFALSE 72339
// points := [ 67 , 45 , 75 ] ;
72320: LD_ADDR_VAR 0 9
72324: PUSH
72325: LD_INT 67
72327: PUSH
72328: LD_INT 45
72330: PUSH
72331: LD_INT 75
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: LIST
72338: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72339: LD_VAR 0 6
72343: PPUSH
72344: CALL_OW 264
72348: PUSH
72349: LD_INT 26
72351: PUSH
72352: EMPTY
72353: LIST
72354: IN
72355: IFFALSE 72376
// points := [ 120 , 30 , 80 ] ;
72357: LD_ADDR_VAR 0 9
72361: PUSH
72362: LD_INT 120
72364: PUSH
72365: LD_INT 30
72367: PUSH
72368: LD_INT 80
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: LIST
72375: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72376: LD_VAR 0 6
72380: PPUSH
72381: CALL_OW 264
72385: PUSH
72386: LD_INT 22
72388: PUSH
72389: EMPTY
72390: LIST
72391: IN
72392: IFFALSE 72413
// points := [ 40 , 1 , 1 ] ;
72394: LD_ADDR_VAR 0 9
72398: PUSH
72399: LD_INT 40
72401: PUSH
72402: LD_INT 1
72404: PUSH
72405: LD_INT 1
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: LIST
72412: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72413: LD_VAR 0 6
72417: PPUSH
72418: CALL_OW 264
72422: PUSH
72423: LD_INT 29
72425: PUSH
72426: EMPTY
72427: LIST
72428: IN
72429: IFFALSE 72450
// points := [ 70 , 200 , 400 ] ;
72431: LD_ADDR_VAR 0 9
72435: PUSH
72436: LD_INT 70
72438: PUSH
72439: LD_INT 200
72441: PUSH
72442: LD_INT 400
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: LIST
72449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72450: LD_VAR 0 6
72454: PPUSH
72455: CALL_OW 264
72459: PUSH
72460: LD_INT 14
72462: PUSH
72463: LD_INT 53
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: IN
72470: IFFALSE 72491
// points := [ 40 , 10 , 20 ] ;
72472: LD_ADDR_VAR 0 9
72476: PUSH
72477: LD_INT 40
72479: PUSH
72480: LD_INT 10
72482: PUSH
72483: LD_INT 20
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: LIST
72490: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72491: LD_VAR 0 6
72495: PPUSH
72496: CALL_OW 264
72500: PUSH
72501: LD_INT 9
72503: PUSH
72504: EMPTY
72505: LIST
72506: IN
72507: IFFALSE 72528
// points := [ 5 , 70 , 20 ] ;
72509: LD_ADDR_VAR 0 9
72513: PUSH
72514: LD_INT 5
72516: PUSH
72517: LD_INT 70
72519: PUSH
72520: LD_INT 20
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: LIST
72527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72528: LD_VAR 0 6
72532: PPUSH
72533: CALL_OW 264
72537: PUSH
72538: LD_INT 10
72540: PUSH
72541: EMPTY
72542: LIST
72543: IN
72544: IFFALSE 72565
// points := [ 35 , 110 , 70 ] ;
72546: LD_ADDR_VAR 0 9
72550: PUSH
72551: LD_INT 35
72553: PUSH
72554: LD_INT 110
72556: PUSH
72557: LD_INT 70
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: LIST
72564: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72565: LD_VAR 0 6
72569: PPUSH
72570: CALL_OW 265
72574: PUSH
72575: LD_INT 25
72577: EQUAL
72578: IFFALSE 72599
// points := [ 80 , 65 , 100 ] ;
72580: LD_ADDR_VAR 0 9
72584: PUSH
72585: LD_INT 80
72587: PUSH
72588: LD_INT 65
72590: PUSH
72591: LD_INT 100
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: LIST
72598: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72599: LD_VAR 0 6
72603: PPUSH
72604: CALL_OW 263
72608: PUSH
72609: LD_INT 1
72611: EQUAL
72612: IFFALSE 72647
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72614: LD_ADDR_VAR 0 10
72618: PUSH
72619: LD_VAR 0 10
72623: PUSH
72624: LD_VAR 0 6
72628: PPUSH
72629: CALL_OW 311
72633: PPUSH
72634: LD_INT 3
72636: PPUSH
72637: CALL_OW 259
72641: PUSH
72642: LD_INT 4
72644: MUL
72645: MUL
72646: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72647: LD_VAR 0 6
72651: PPUSH
72652: CALL_OW 263
72656: PUSH
72657: LD_INT 2
72659: EQUAL
72660: IFFALSE 72711
// begin j := IsControledBy ( i ) ;
72662: LD_ADDR_VAR 0 7
72666: PUSH
72667: LD_VAR 0 6
72671: PPUSH
72672: CALL_OW 312
72676: ST_TO_ADDR
// if j then
72677: LD_VAR 0 7
72681: IFFALSE 72711
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72683: LD_ADDR_VAR 0 10
72687: PUSH
72688: LD_VAR 0 10
72692: PUSH
72693: LD_VAR 0 7
72697: PPUSH
72698: LD_INT 3
72700: PPUSH
72701: CALL_OW 259
72705: PUSH
72706: LD_INT 3
72708: MUL
72709: MUL
72710: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72711: LD_VAR 0 6
72715: PPUSH
72716: CALL_OW 264
72720: PUSH
72721: LD_INT 5
72723: PUSH
72724: LD_INT 6
72726: PUSH
72727: LD_INT 46
72729: PUSH
72730: LD_INT 44
72732: PUSH
72733: LD_INT 47
72735: PUSH
72736: LD_INT 45
72738: PUSH
72739: LD_INT 28
72741: PUSH
72742: LD_INT 7
72744: PUSH
72745: LD_INT 27
72747: PUSH
72748: LD_INT 29
72750: PUSH
72751: EMPTY
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: LIST
72759: LIST
72760: LIST
72761: LIST
72762: IN
72763: PUSH
72764: LD_VAR 0 1
72768: PPUSH
72769: LD_INT 52
72771: PPUSH
72772: CALL_OW 321
72776: PUSH
72777: LD_INT 2
72779: EQUAL
72780: AND
72781: IFFALSE 72798
// bpoints := bpoints * 1.2 ;
72783: LD_ADDR_VAR 0 10
72787: PUSH
72788: LD_VAR 0 10
72792: PUSH
72793: LD_REAL  1.20000000000000E+0000
72796: MUL
72797: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72798: LD_VAR 0 6
72802: PPUSH
72803: CALL_OW 264
72807: PUSH
72808: LD_INT 6
72810: PUSH
72811: LD_INT 46
72813: PUSH
72814: LD_INT 47
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: LIST
72821: IN
72822: IFFALSE 72839
// bpoints := bpoints * 1.2 ;
72824: LD_ADDR_VAR 0 10
72828: PUSH
72829: LD_VAR 0 10
72833: PUSH
72834: LD_REAL  1.20000000000000E+0000
72837: MUL
72838: ST_TO_ADDR
// end ; unit_building :
72839: GO 72853
72841: LD_INT 3
72843: DOUBLE
72844: EQUAL
72845: IFTRUE 72849
72847: GO 72852
72849: POP
// ; end ;
72850: GO 72853
72852: POP
// for j = 1 to 3 do
72853: LD_ADDR_VAR 0 7
72857: PUSH
72858: DOUBLE
72859: LD_INT 1
72861: DEC
72862: ST_TO_ADDR
72863: LD_INT 3
72865: PUSH
72866: FOR_TO
72867: IFFALSE 72920
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72869: LD_ADDR_VAR 0 5
72873: PUSH
72874: LD_VAR 0 5
72878: PPUSH
72879: LD_VAR 0 7
72883: PPUSH
72884: LD_VAR 0 5
72888: PUSH
72889: LD_VAR 0 7
72893: ARRAY
72894: PUSH
72895: LD_VAR 0 9
72899: PUSH
72900: LD_VAR 0 7
72904: ARRAY
72905: PUSH
72906: LD_VAR 0 10
72910: MUL
72911: PLUS
72912: PPUSH
72913: CALL_OW 1
72917: ST_TO_ADDR
72918: GO 72866
72920: POP
72921: POP
// end ;
72922: GO 71405
72924: POP
72925: POP
// result := Replace ( result , 4 , tmp ) ;
72926: LD_ADDR_VAR 0 5
72930: PUSH
72931: LD_VAR 0 5
72935: PPUSH
72936: LD_INT 4
72938: PPUSH
72939: LD_VAR 0 8
72943: PPUSH
72944: CALL_OW 1
72948: ST_TO_ADDR
// end ;
72949: LD_VAR 0 5
72953: RET
// export function DangerAtRange ( unit , range ) ; begin
72954: LD_INT 0
72956: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72957: LD_ADDR_VAR 0 3
72961: PUSH
72962: LD_VAR 0 1
72966: PPUSH
72967: CALL_OW 255
72971: PPUSH
72972: LD_VAR 0 1
72976: PPUSH
72977: CALL_OW 250
72981: PPUSH
72982: LD_VAR 0 1
72986: PPUSH
72987: CALL_OW 251
72991: PPUSH
72992: LD_VAR 0 2
72996: PPUSH
72997: CALL 71257 0 4
73001: ST_TO_ADDR
// end ;
73002: LD_VAR 0 3
73006: RET
// export function DangerInArea ( side , area ) ; begin
73007: LD_INT 0
73009: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73010: LD_ADDR_VAR 0 3
73014: PUSH
73015: LD_VAR 0 2
73019: PPUSH
73020: LD_INT 81
73022: PUSH
73023: LD_VAR 0 1
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PPUSH
73032: CALL_OW 70
73036: ST_TO_ADDR
// end ;
73037: LD_VAR 0 3
73041: RET
// export function IsExtension ( b ) ; begin
73042: LD_INT 0
73044: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73045: LD_ADDR_VAR 0 2
73049: PUSH
73050: LD_VAR 0 1
73054: PUSH
73055: LD_INT 23
73057: PUSH
73058: LD_INT 20
73060: PUSH
73061: LD_INT 22
73063: PUSH
73064: LD_INT 17
73066: PUSH
73067: LD_INT 24
73069: PUSH
73070: LD_INT 21
73072: PUSH
73073: LD_INT 19
73075: PUSH
73076: LD_INT 16
73078: PUSH
73079: LD_INT 25
73081: PUSH
73082: LD_INT 18
73084: PUSH
73085: EMPTY
73086: LIST
73087: LIST
73088: LIST
73089: LIST
73090: LIST
73091: LIST
73092: LIST
73093: LIST
73094: LIST
73095: LIST
73096: IN
73097: ST_TO_ADDR
// end ;
73098: LD_VAR 0 2
73102: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73103: LD_INT 0
73105: PPUSH
73106: PPUSH
73107: PPUSH
// result := [ ] ;
73108: LD_ADDR_VAR 0 3
73112: PUSH
73113: EMPTY
73114: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73115: LD_ADDR_VAR 0 4
73119: PUSH
73120: LD_VAR 0 2
73124: PPUSH
73125: LD_INT 21
73127: PUSH
73128: LD_INT 3
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PPUSH
73135: CALL_OW 70
73139: ST_TO_ADDR
// if not tmp then
73140: LD_VAR 0 4
73144: NOT
73145: IFFALSE 73149
// exit ;
73147: GO 73207
// for i in tmp do
73149: LD_ADDR_VAR 0 5
73153: PUSH
73154: LD_VAR 0 4
73158: PUSH
73159: FOR_IN
73160: IFFALSE 73195
// if GetBase ( i ) <> base then
73162: LD_VAR 0 5
73166: PPUSH
73167: CALL_OW 274
73171: PUSH
73172: LD_VAR 0 1
73176: NONEQUAL
73177: IFFALSE 73193
// ComLinkToBase ( base , i ) ;
73179: LD_VAR 0 1
73183: PPUSH
73184: LD_VAR 0 5
73188: PPUSH
73189: CALL_OW 169
73193: GO 73159
73195: POP
73196: POP
// result := tmp ;
73197: LD_ADDR_VAR 0 3
73201: PUSH
73202: LD_VAR 0 4
73206: ST_TO_ADDR
// end ;
73207: LD_VAR 0 3
73211: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73212: LD_INT 0
73214: PPUSH
73215: PPUSH
// if BuildingStatus ( b ) = bs_build then
73216: LD_VAR 0 2
73220: PPUSH
73221: CALL_OW 461
73225: PUSH
73226: LD_INT 1
73228: EQUAL
73229: IFFALSE 73289
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73231: LD_VAR 0 1
73235: PPUSH
73236: LD_STRING h
73238: PUSH
73239: LD_VAR 0 2
73243: PPUSH
73244: CALL_OW 250
73248: PUSH
73249: LD_VAR 0 2
73253: PPUSH
73254: CALL_OW 251
73258: PUSH
73259: LD_VAR 0 2
73263: PUSH
73264: LD_INT 0
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 0
73272: PUSH
73273: EMPTY
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: PUSH
73282: EMPTY
73283: LIST
73284: PPUSH
73285: CALL_OW 446
// end ;
73289: LD_VAR 0 3
73293: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73294: LD_INT 0
73296: PPUSH
73297: PPUSH
73298: PPUSH
73299: PPUSH
73300: PPUSH
73301: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73302: LD_VAR 0 1
73306: NOT
73307: PUSH
73308: LD_VAR 0 1
73312: PPUSH
73313: CALL_OW 263
73317: PUSH
73318: LD_INT 2
73320: EQUAL
73321: NOT
73322: OR
73323: IFFALSE 73327
// exit ;
73325: GO 73643
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73327: LD_ADDR_VAR 0 6
73331: PUSH
73332: LD_INT 22
73334: PUSH
73335: LD_VAR 0 1
73339: PPUSH
73340: CALL_OW 255
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: PUSH
73349: LD_INT 2
73351: PUSH
73352: LD_INT 30
73354: PUSH
73355: LD_INT 36
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 34
73364: PUSH
73365: LD_INT 31
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: LIST
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PPUSH
73381: CALL_OW 69
73385: ST_TO_ADDR
// if not tmp then
73386: LD_VAR 0 6
73390: NOT
73391: IFFALSE 73395
// exit ;
73393: GO 73643
// result := [ ] ;
73395: LD_ADDR_VAR 0 2
73399: PUSH
73400: EMPTY
73401: ST_TO_ADDR
// for i in tmp do
73402: LD_ADDR_VAR 0 3
73406: PUSH
73407: LD_VAR 0 6
73411: PUSH
73412: FOR_IN
73413: IFFALSE 73484
// begin t := UnitsInside ( i ) ;
73415: LD_ADDR_VAR 0 4
73419: PUSH
73420: LD_VAR 0 3
73424: PPUSH
73425: CALL_OW 313
73429: ST_TO_ADDR
// if t then
73430: LD_VAR 0 4
73434: IFFALSE 73482
// for j in t do
73436: LD_ADDR_VAR 0 7
73440: PUSH
73441: LD_VAR 0 4
73445: PUSH
73446: FOR_IN
73447: IFFALSE 73480
// result := Insert ( result , result + 1 , j ) ;
73449: LD_ADDR_VAR 0 2
73453: PUSH
73454: LD_VAR 0 2
73458: PPUSH
73459: LD_VAR 0 2
73463: PUSH
73464: LD_INT 1
73466: PLUS
73467: PPUSH
73468: LD_VAR 0 7
73472: PPUSH
73473: CALL_OW 2
73477: ST_TO_ADDR
73478: GO 73446
73480: POP
73481: POP
// end ;
73482: GO 73412
73484: POP
73485: POP
// if not result then
73486: LD_VAR 0 2
73490: NOT
73491: IFFALSE 73495
// exit ;
73493: GO 73643
// mech := result [ 1 ] ;
73495: LD_ADDR_VAR 0 5
73499: PUSH
73500: LD_VAR 0 2
73504: PUSH
73505: LD_INT 1
73507: ARRAY
73508: ST_TO_ADDR
// if result > 1 then
73509: LD_VAR 0 2
73513: PUSH
73514: LD_INT 1
73516: GREATER
73517: IFFALSE 73629
// for i = 2 to result do
73519: LD_ADDR_VAR 0 3
73523: PUSH
73524: DOUBLE
73525: LD_INT 2
73527: DEC
73528: ST_TO_ADDR
73529: LD_VAR 0 2
73533: PUSH
73534: FOR_TO
73535: IFFALSE 73627
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73537: LD_ADDR_VAR 0 4
73541: PUSH
73542: LD_VAR 0 2
73546: PUSH
73547: LD_VAR 0 3
73551: ARRAY
73552: PPUSH
73553: LD_INT 3
73555: PPUSH
73556: CALL_OW 259
73560: PUSH
73561: LD_VAR 0 2
73565: PUSH
73566: LD_VAR 0 3
73570: ARRAY
73571: PPUSH
73572: CALL_OW 432
73576: MINUS
73577: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73578: LD_VAR 0 4
73582: PUSH
73583: LD_VAR 0 5
73587: PPUSH
73588: LD_INT 3
73590: PPUSH
73591: CALL_OW 259
73595: PUSH
73596: LD_VAR 0 5
73600: PPUSH
73601: CALL_OW 432
73605: MINUS
73606: GREATEREQUAL
73607: IFFALSE 73625
// mech := result [ i ] ;
73609: LD_ADDR_VAR 0 5
73613: PUSH
73614: LD_VAR 0 2
73618: PUSH
73619: LD_VAR 0 3
73623: ARRAY
73624: ST_TO_ADDR
// end ;
73625: GO 73534
73627: POP
73628: POP
// ComLinkTo ( vehicle , mech ) ;
73629: LD_VAR 0 1
73633: PPUSH
73634: LD_VAR 0 5
73638: PPUSH
73639: CALL_OW 135
// end ;
73643: LD_VAR 0 2
73647: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73648: LD_INT 0
73650: PPUSH
73651: PPUSH
73652: PPUSH
73653: PPUSH
73654: PPUSH
73655: PPUSH
73656: PPUSH
73657: PPUSH
73658: PPUSH
73659: PPUSH
73660: PPUSH
73661: PPUSH
73662: PPUSH
// result := [ ] ;
73663: LD_ADDR_VAR 0 7
73667: PUSH
73668: EMPTY
73669: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73670: LD_VAR 0 1
73674: PPUSH
73675: CALL_OW 266
73679: PUSH
73680: LD_INT 0
73682: PUSH
73683: LD_INT 1
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: IN
73690: NOT
73691: IFFALSE 73695
// exit ;
73693: GO 75326
// if name then
73695: LD_VAR 0 3
73699: IFFALSE 73715
// SetBName ( base_dep , name ) ;
73701: LD_VAR 0 1
73705: PPUSH
73706: LD_VAR 0 3
73710: PPUSH
73711: CALL_OW 500
// base := GetBase ( base_dep ) ;
73715: LD_ADDR_VAR 0 15
73719: PUSH
73720: LD_VAR 0 1
73724: PPUSH
73725: CALL_OW 274
73729: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73730: LD_ADDR_VAR 0 16
73734: PUSH
73735: LD_VAR 0 1
73739: PPUSH
73740: CALL_OW 255
73744: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73745: LD_ADDR_VAR 0 17
73749: PUSH
73750: LD_VAR 0 1
73754: PPUSH
73755: CALL_OW 248
73759: ST_TO_ADDR
// if sources then
73760: LD_VAR 0 5
73764: IFFALSE 73811
// for i = 1 to 3 do
73766: LD_ADDR_VAR 0 8
73770: PUSH
73771: DOUBLE
73772: LD_INT 1
73774: DEC
73775: ST_TO_ADDR
73776: LD_INT 3
73778: PUSH
73779: FOR_TO
73780: IFFALSE 73809
// AddResourceType ( base , i , sources [ i ] ) ;
73782: LD_VAR 0 15
73786: PPUSH
73787: LD_VAR 0 8
73791: PPUSH
73792: LD_VAR 0 5
73796: PUSH
73797: LD_VAR 0 8
73801: ARRAY
73802: PPUSH
73803: CALL_OW 276
73807: GO 73779
73809: POP
73810: POP
// buildings := GetBaseBuildings ( base , area ) ;
73811: LD_ADDR_VAR 0 18
73815: PUSH
73816: LD_VAR 0 15
73820: PPUSH
73821: LD_VAR 0 2
73825: PPUSH
73826: CALL 73103 0 2
73830: ST_TO_ADDR
// InitHc ;
73831: CALL_OW 19
// InitUc ;
73835: CALL_OW 18
// uc_side := side ;
73839: LD_ADDR_OWVAR 20
73843: PUSH
73844: LD_VAR 0 16
73848: ST_TO_ADDR
// uc_nation := nation ;
73849: LD_ADDR_OWVAR 21
73853: PUSH
73854: LD_VAR 0 17
73858: ST_TO_ADDR
// if buildings then
73859: LD_VAR 0 18
73863: IFFALSE 75185
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73865: LD_ADDR_VAR 0 19
73869: PUSH
73870: LD_VAR 0 18
73874: PPUSH
73875: LD_INT 2
73877: PUSH
73878: LD_INT 30
73880: PUSH
73881: LD_INT 29
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 30
73890: PUSH
73891: LD_INT 30
73893: PUSH
73894: EMPTY
73895: LIST
73896: LIST
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: LIST
73902: PPUSH
73903: CALL_OW 72
73907: ST_TO_ADDR
// if tmp then
73908: LD_VAR 0 19
73912: IFFALSE 73960
// for i in tmp do
73914: LD_ADDR_VAR 0 8
73918: PUSH
73919: LD_VAR 0 19
73923: PUSH
73924: FOR_IN
73925: IFFALSE 73958
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73927: LD_VAR 0 8
73931: PPUSH
73932: CALL_OW 250
73936: PPUSH
73937: LD_VAR 0 8
73941: PPUSH
73942: CALL_OW 251
73946: PPUSH
73947: LD_VAR 0 16
73951: PPUSH
73952: CALL_OW 441
73956: GO 73924
73958: POP
73959: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73960: LD_VAR 0 18
73964: PPUSH
73965: LD_INT 2
73967: PUSH
73968: LD_INT 30
73970: PUSH
73971: LD_INT 32
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 30
73980: PUSH
73981: LD_INT 33
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: LIST
73992: PPUSH
73993: CALL_OW 72
73997: IFFALSE 74085
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73999: LD_ADDR_VAR 0 8
74003: PUSH
74004: LD_VAR 0 18
74008: PPUSH
74009: LD_INT 2
74011: PUSH
74012: LD_INT 30
74014: PUSH
74015: LD_INT 32
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 30
74024: PUSH
74025: LD_INT 33
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: LIST
74036: PPUSH
74037: CALL_OW 72
74041: PUSH
74042: FOR_IN
74043: IFFALSE 74083
// begin if not GetBWeapon ( i ) then
74045: LD_VAR 0 8
74049: PPUSH
74050: CALL_OW 269
74054: NOT
74055: IFFALSE 74081
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74057: LD_VAR 0 8
74061: PPUSH
74062: LD_VAR 0 8
74066: PPUSH
74067: LD_VAR 0 2
74071: PPUSH
74072: CALL 75331 0 2
74076: PPUSH
74077: CALL_OW 431
// end ;
74081: GO 74042
74083: POP
74084: POP
// end ; for i = 1 to personel do
74085: LD_ADDR_VAR 0 8
74089: PUSH
74090: DOUBLE
74091: LD_INT 1
74093: DEC
74094: ST_TO_ADDR
74095: LD_VAR 0 6
74099: PUSH
74100: FOR_TO
74101: IFFALSE 75165
// begin if i > 4 then
74103: LD_VAR 0 8
74107: PUSH
74108: LD_INT 4
74110: GREATER
74111: IFFALSE 74115
// break ;
74113: GO 75165
// case i of 1 :
74115: LD_VAR 0 8
74119: PUSH
74120: LD_INT 1
74122: DOUBLE
74123: EQUAL
74124: IFTRUE 74128
74126: GO 74208
74128: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74129: LD_ADDR_VAR 0 12
74133: PUSH
74134: LD_VAR 0 18
74138: PPUSH
74139: LD_INT 22
74141: PUSH
74142: LD_VAR 0 16
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 58
74153: PUSH
74154: EMPTY
74155: LIST
74156: PUSH
74157: LD_INT 2
74159: PUSH
74160: LD_INT 30
74162: PUSH
74163: LD_INT 32
74165: PUSH
74166: EMPTY
74167: LIST
74168: LIST
74169: PUSH
74170: LD_INT 30
74172: PUSH
74173: LD_INT 4
74175: PUSH
74176: EMPTY
74177: LIST
74178: LIST
74179: PUSH
74180: LD_INT 30
74182: PUSH
74183: LD_INT 5
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: EMPTY
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: LIST
74200: PPUSH
74201: CALL_OW 72
74205: ST_TO_ADDR
74206: GO 74430
74208: LD_INT 2
74210: DOUBLE
74211: EQUAL
74212: IFTRUE 74216
74214: GO 74278
74216: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74217: LD_ADDR_VAR 0 12
74221: PUSH
74222: LD_VAR 0 18
74226: PPUSH
74227: LD_INT 22
74229: PUSH
74230: LD_VAR 0 16
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 2
74241: PUSH
74242: LD_INT 30
74244: PUSH
74245: LD_INT 0
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 30
74254: PUSH
74255: LD_INT 1
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: LIST
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PPUSH
74271: CALL_OW 72
74275: ST_TO_ADDR
74276: GO 74430
74278: LD_INT 3
74280: DOUBLE
74281: EQUAL
74282: IFTRUE 74286
74284: GO 74348
74286: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74287: LD_ADDR_VAR 0 12
74291: PUSH
74292: LD_VAR 0 18
74296: PPUSH
74297: LD_INT 22
74299: PUSH
74300: LD_VAR 0 16
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 2
74311: PUSH
74312: LD_INT 30
74314: PUSH
74315: LD_INT 2
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 30
74324: PUSH
74325: LD_INT 3
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: LIST
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PPUSH
74341: CALL_OW 72
74345: ST_TO_ADDR
74346: GO 74430
74348: LD_INT 4
74350: DOUBLE
74351: EQUAL
74352: IFTRUE 74356
74354: GO 74429
74356: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74357: LD_ADDR_VAR 0 12
74361: PUSH
74362: LD_VAR 0 18
74366: PPUSH
74367: LD_INT 22
74369: PUSH
74370: LD_VAR 0 16
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 2
74381: PUSH
74382: LD_INT 30
74384: PUSH
74385: LD_INT 6
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 30
74394: PUSH
74395: LD_INT 7
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 30
74404: PUSH
74405: LD_INT 8
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: LIST
74416: LIST
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: PPUSH
74422: CALL_OW 72
74426: ST_TO_ADDR
74427: GO 74430
74429: POP
// if i = 1 then
74430: LD_VAR 0 8
74434: PUSH
74435: LD_INT 1
74437: EQUAL
74438: IFFALSE 74549
// begin tmp := [ ] ;
74440: LD_ADDR_VAR 0 19
74444: PUSH
74445: EMPTY
74446: ST_TO_ADDR
// for j in f do
74447: LD_ADDR_VAR 0 9
74451: PUSH
74452: LD_VAR 0 12
74456: PUSH
74457: FOR_IN
74458: IFFALSE 74531
// if GetBType ( j ) = b_bunker then
74460: LD_VAR 0 9
74464: PPUSH
74465: CALL_OW 266
74469: PUSH
74470: LD_INT 32
74472: EQUAL
74473: IFFALSE 74500
// tmp := Insert ( tmp , 1 , j ) else
74475: LD_ADDR_VAR 0 19
74479: PUSH
74480: LD_VAR 0 19
74484: PPUSH
74485: LD_INT 1
74487: PPUSH
74488: LD_VAR 0 9
74492: PPUSH
74493: CALL_OW 2
74497: ST_TO_ADDR
74498: GO 74529
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74500: LD_ADDR_VAR 0 19
74504: PUSH
74505: LD_VAR 0 19
74509: PPUSH
74510: LD_VAR 0 19
74514: PUSH
74515: LD_INT 1
74517: PLUS
74518: PPUSH
74519: LD_VAR 0 9
74523: PPUSH
74524: CALL_OW 2
74528: ST_TO_ADDR
74529: GO 74457
74531: POP
74532: POP
// if tmp then
74533: LD_VAR 0 19
74537: IFFALSE 74549
// f := tmp ;
74539: LD_ADDR_VAR 0 12
74543: PUSH
74544: LD_VAR 0 19
74548: ST_TO_ADDR
// end ; x := personel [ i ] ;
74549: LD_ADDR_VAR 0 13
74553: PUSH
74554: LD_VAR 0 6
74558: PUSH
74559: LD_VAR 0 8
74563: ARRAY
74564: ST_TO_ADDR
// if x = - 1 then
74565: LD_VAR 0 13
74569: PUSH
74570: LD_INT 1
74572: NEG
74573: EQUAL
74574: IFFALSE 74783
// begin for j in f do
74576: LD_ADDR_VAR 0 9
74580: PUSH
74581: LD_VAR 0 12
74585: PUSH
74586: FOR_IN
74587: IFFALSE 74779
// repeat InitHc ;
74589: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74593: LD_VAR 0 9
74597: PPUSH
74598: CALL_OW 266
74602: PUSH
74603: LD_INT 5
74605: EQUAL
74606: IFFALSE 74676
// begin if UnitsInside ( j ) < 3 then
74608: LD_VAR 0 9
74612: PPUSH
74613: CALL_OW 313
74617: PUSH
74618: LD_INT 3
74620: LESS
74621: IFFALSE 74657
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74623: LD_INT 0
74625: PPUSH
74626: LD_INT 5
74628: PUSH
74629: LD_INT 8
74631: PUSH
74632: LD_INT 9
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: LIST
74639: PUSH
74640: LD_VAR 0 17
74644: ARRAY
74645: PPUSH
74646: LD_VAR 0 4
74650: PPUSH
74651: CALL_OW 380
74655: GO 74674
// PrepareHuman ( false , i , skill ) ;
74657: LD_INT 0
74659: PPUSH
74660: LD_VAR 0 8
74664: PPUSH
74665: LD_VAR 0 4
74669: PPUSH
74670: CALL_OW 380
// end else
74674: GO 74693
// PrepareHuman ( false , i , skill ) ;
74676: LD_INT 0
74678: PPUSH
74679: LD_VAR 0 8
74683: PPUSH
74684: LD_VAR 0 4
74688: PPUSH
74689: CALL_OW 380
// un := CreateHuman ;
74693: LD_ADDR_VAR 0 14
74697: PUSH
74698: CALL_OW 44
74702: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74703: LD_ADDR_VAR 0 7
74707: PUSH
74708: LD_VAR 0 7
74712: PPUSH
74713: LD_INT 1
74715: PPUSH
74716: LD_VAR 0 14
74720: PPUSH
74721: CALL_OW 2
74725: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74726: LD_VAR 0 14
74730: PPUSH
74731: LD_VAR 0 9
74735: PPUSH
74736: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74740: LD_VAR 0 9
74744: PPUSH
74745: CALL_OW 313
74749: PUSH
74750: LD_INT 6
74752: EQUAL
74753: PUSH
74754: LD_VAR 0 9
74758: PPUSH
74759: CALL_OW 266
74763: PUSH
74764: LD_INT 32
74766: PUSH
74767: LD_INT 31
74769: PUSH
74770: EMPTY
74771: LIST
74772: LIST
74773: IN
74774: OR
74775: IFFALSE 74589
74777: GO 74586
74779: POP
74780: POP
// end else
74781: GO 75163
// for j = 1 to x do
74783: LD_ADDR_VAR 0 9
74787: PUSH
74788: DOUBLE
74789: LD_INT 1
74791: DEC
74792: ST_TO_ADDR
74793: LD_VAR 0 13
74797: PUSH
74798: FOR_TO
74799: IFFALSE 75161
// begin InitHc ;
74801: CALL_OW 19
// if not f then
74805: LD_VAR 0 12
74809: NOT
74810: IFFALSE 74899
// begin PrepareHuman ( false , i , skill ) ;
74812: LD_INT 0
74814: PPUSH
74815: LD_VAR 0 8
74819: PPUSH
74820: LD_VAR 0 4
74824: PPUSH
74825: CALL_OW 380
// un := CreateHuman ;
74829: LD_ADDR_VAR 0 14
74833: PUSH
74834: CALL_OW 44
74838: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74839: LD_ADDR_VAR 0 7
74843: PUSH
74844: LD_VAR 0 7
74848: PPUSH
74849: LD_INT 1
74851: PPUSH
74852: LD_VAR 0 14
74856: PPUSH
74857: CALL_OW 2
74861: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74862: LD_VAR 0 14
74866: PPUSH
74867: LD_VAR 0 1
74871: PPUSH
74872: CALL_OW 250
74876: PPUSH
74877: LD_VAR 0 1
74881: PPUSH
74882: CALL_OW 251
74886: PPUSH
74887: LD_INT 10
74889: PPUSH
74890: LD_INT 0
74892: PPUSH
74893: CALL_OW 50
// continue ;
74897: GO 74798
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74899: LD_VAR 0 12
74903: PUSH
74904: LD_INT 1
74906: ARRAY
74907: PPUSH
74908: CALL_OW 313
74912: PUSH
74913: LD_VAR 0 12
74917: PUSH
74918: LD_INT 1
74920: ARRAY
74921: PPUSH
74922: CALL_OW 266
74926: PUSH
74927: LD_INT 32
74929: PUSH
74930: LD_INT 31
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: IN
74937: AND
74938: PUSH
74939: LD_VAR 0 12
74943: PUSH
74944: LD_INT 1
74946: ARRAY
74947: PPUSH
74948: CALL_OW 313
74952: PUSH
74953: LD_INT 6
74955: EQUAL
74956: OR
74957: IFFALSE 74977
// f := Delete ( f , 1 ) ;
74959: LD_ADDR_VAR 0 12
74963: PUSH
74964: LD_VAR 0 12
74968: PPUSH
74969: LD_INT 1
74971: PPUSH
74972: CALL_OW 3
74976: ST_TO_ADDR
// if not f then
74977: LD_VAR 0 12
74981: NOT
74982: IFFALSE 75000
// begin x := x + 2 ;
74984: LD_ADDR_VAR 0 13
74988: PUSH
74989: LD_VAR 0 13
74993: PUSH
74994: LD_INT 2
74996: PLUS
74997: ST_TO_ADDR
// continue ;
74998: GO 74798
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75000: LD_VAR 0 12
75004: PUSH
75005: LD_INT 1
75007: ARRAY
75008: PPUSH
75009: CALL_OW 266
75013: PUSH
75014: LD_INT 5
75016: EQUAL
75017: IFFALSE 75091
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75019: LD_VAR 0 12
75023: PUSH
75024: LD_INT 1
75026: ARRAY
75027: PPUSH
75028: CALL_OW 313
75032: PUSH
75033: LD_INT 3
75035: LESS
75036: IFFALSE 75072
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75038: LD_INT 0
75040: PPUSH
75041: LD_INT 5
75043: PUSH
75044: LD_INT 8
75046: PUSH
75047: LD_INT 9
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: LIST
75054: PUSH
75055: LD_VAR 0 17
75059: ARRAY
75060: PPUSH
75061: LD_VAR 0 4
75065: PPUSH
75066: CALL_OW 380
75070: GO 75089
// PrepareHuman ( false , i , skill ) ;
75072: LD_INT 0
75074: PPUSH
75075: LD_VAR 0 8
75079: PPUSH
75080: LD_VAR 0 4
75084: PPUSH
75085: CALL_OW 380
// end else
75089: GO 75108
// PrepareHuman ( false , i , skill ) ;
75091: LD_INT 0
75093: PPUSH
75094: LD_VAR 0 8
75098: PPUSH
75099: LD_VAR 0 4
75103: PPUSH
75104: CALL_OW 380
// un := CreateHuman ;
75108: LD_ADDR_VAR 0 14
75112: PUSH
75113: CALL_OW 44
75117: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75118: LD_ADDR_VAR 0 7
75122: PUSH
75123: LD_VAR 0 7
75127: PPUSH
75128: LD_INT 1
75130: PPUSH
75131: LD_VAR 0 14
75135: PPUSH
75136: CALL_OW 2
75140: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75141: LD_VAR 0 14
75145: PPUSH
75146: LD_VAR 0 12
75150: PUSH
75151: LD_INT 1
75153: ARRAY
75154: PPUSH
75155: CALL_OW 52
// end ;
75159: GO 74798
75161: POP
75162: POP
// end ;
75163: GO 74100
75165: POP
75166: POP
// result := result ^ buildings ;
75167: LD_ADDR_VAR 0 7
75171: PUSH
75172: LD_VAR 0 7
75176: PUSH
75177: LD_VAR 0 18
75181: ADD
75182: ST_TO_ADDR
// end else
75183: GO 75326
// begin for i = 1 to personel do
75185: LD_ADDR_VAR 0 8
75189: PUSH
75190: DOUBLE
75191: LD_INT 1
75193: DEC
75194: ST_TO_ADDR
75195: LD_VAR 0 6
75199: PUSH
75200: FOR_TO
75201: IFFALSE 75324
// begin if i > 4 then
75203: LD_VAR 0 8
75207: PUSH
75208: LD_INT 4
75210: GREATER
75211: IFFALSE 75215
// break ;
75213: GO 75324
// x := personel [ i ] ;
75215: LD_ADDR_VAR 0 13
75219: PUSH
75220: LD_VAR 0 6
75224: PUSH
75225: LD_VAR 0 8
75229: ARRAY
75230: ST_TO_ADDR
// if x = - 1 then
75231: LD_VAR 0 13
75235: PUSH
75236: LD_INT 1
75238: NEG
75239: EQUAL
75240: IFFALSE 75244
// continue ;
75242: GO 75200
// PrepareHuman ( false , i , skill ) ;
75244: LD_INT 0
75246: PPUSH
75247: LD_VAR 0 8
75251: PPUSH
75252: LD_VAR 0 4
75256: PPUSH
75257: CALL_OW 380
// un := CreateHuman ;
75261: LD_ADDR_VAR 0 14
75265: PUSH
75266: CALL_OW 44
75270: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75271: LD_VAR 0 14
75275: PPUSH
75276: LD_VAR 0 1
75280: PPUSH
75281: CALL_OW 250
75285: PPUSH
75286: LD_VAR 0 1
75290: PPUSH
75291: CALL_OW 251
75295: PPUSH
75296: LD_INT 10
75298: PPUSH
75299: LD_INT 0
75301: PPUSH
75302: CALL_OW 50
// result := result ^ un ;
75306: LD_ADDR_VAR 0 7
75310: PUSH
75311: LD_VAR 0 7
75315: PUSH
75316: LD_VAR 0 14
75320: ADD
75321: ST_TO_ADDR
// end ;
75322: GO 75200
75324: POP
75325: POP
// end ; end ;
75326: LD_VAR 0 7
75330: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75331: LD_INT 0
75333: PPUSH
75334: PPUSH
75335: PPUSH
75336: PPUSH
75337: PPUSH
75338: PPUSH
75339: PPUSH
75340: PPUSH
75341: PPUSH
75342: PPUSH
75343: PPUSH
75344: PPUSH
75345: PPUSH
75346: PPUSH
75347: PPUSH
75348: PPUSH
// result := false ;
75349: LD_ADDR_VAR 0 3
75353: PUSH
75354: LD_INT 0
75356: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75357: LD_VAR 0 1
75361: NOT
75362: PUSH
75363: LD_VAR 0 1
75367: PPUSH
75368: CALL_OW 266
75372: PUSH
75373: LD_INT 32
75375: PUSH
75376: LD_INT 33
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: IN
75383: NOT
75384: OR
75385: IFFALSE 75389
// exit ;
75387: GO 76525
// nat := GetNation ( tower ) ;
75389: LD_ADDR_VAR 0 12
75393: PUSH
75394: LD_VAR 0 1
75398: PPUSH
75399: CALL_OW 248
75403: ST_TO_ADDR
// side := GetSide ( tower ) ;
75404: LD_ADDR_VAR 0 16
75408: PUSH
75409: LD_VAR 0 1
75413: PPUSH
75414: CALL_OW 255
75418: ST_TO_ADDR
// x := GetX ( tower ) ;
75419: LD_ADDR_VAR 0 10
75423: PUSH
75424: LD_VAR 0 1
75428: PPUSH
75429: CALL_OW 250
75433: ST_TO_ADDR
// y := GetY ( tower ) ;
75434: LD_ADDR_VAR 0 11
75438: PUSH
75439: LD_VAR 0 1
75443: PPUSH
75444: CALL_OW 251
75448: ST_TO_ADDR
// if not x or not y then
75449: LD_VAR 0 10
75453: NOT
75454: PUSH
75455: LD_VAR 0 11
75459: NOT
75460: OR
75461: IFFALSE 75465
// exit ;
75463: GO 76525
// weapon := 0 ;
75465: LD_ADDR_VAR 0 18
75469: PUSH
75470: LD_INT 0
75472: ST_TO_ADDR
// fac_list := [ ] ;
75473: LD_ADDR_VAR 0 17
75477: PUSH
75478: EMPTY
75479: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75480: LD_ADDR_VAR 0 6
75484: PUSH
75485: LD_VAR 0 1
75489: PPUSH
75490: CALL_OW 274
75494: PPUSH
75495: LD_VAR 0 2
75499: PPUSH
75500: CALL 73103 0 2
75504: PPUSH
75505: LD_INT 30
75507: PUSH
75508: LD_INT 3
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PPUSH
75515: CALL_OW 72
75519: ST_TO_ADDR
// if not factories then
75520: LD_VAR 0 6
75524: NOT
75525: IFFALSE 75529
// exit ;
75527: GO 76525
// for i in factories do
75529: LD_ADDR_VAR 0 8
75533: PUSH
75534: LD_VAR 0 6
75538: PUSH
75539: FOR_IN
75540: IFFALSE 75565
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75542: LD_ADDR_VAR 0 17
75546: PUSH
75547: LD_VAR 0 17
75551: PUSH
75552: LD_VAR 0 8
75556: PPUSH
75557: CALL_OW 478
75561: UNION
75562: ST_TO_ADDR
75563: GO 75539
75565: POP
75566: POP
// if not fac_list then
75567: LD_VAR 0 17
75571: NOT
75572: IFFALSE 75576
// exit ;
75574: GO 76525
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75576: LD_ADDR_VAR 0 5
75580: PUSH
75581: LD_INT 4
75583: PUSH
75584: LD_INT 5
75586: PUSH
75587: LD_INT 9
75589: PUSH
75590: LD_INT 10
75592: PUSH
75593: LD_INT 6
75595: PUSH
75596: LD_INT 7
75598: PUSH
75599: LD_INT 11
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 27
75613: PUSH
75614: LD_INT 28
75616: PUSH
75617: LD_INT 26
75619: PUSH
75620: LD_INT 30
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 43
75631: PUSH
75632: LD_INT 44
75634: PUSH
75635: LD_INT 46
75637: PUSH
75638: LD_INT 45
75640: PUSH
75641: LD_INT 47
75643: PUSH
75644: LD_INT 49
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: LIST
75651: LIST
75652: LIST
75653: LIST
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: LIST
75659: PUSH
75660: LD_VAR 0 12
75664: ARRAY
75665: ST_TO_ADDR
// for i in list do
75666: LD_ADDR_VAR 0 8
75670: PUSH
75671: LD_VAR 0 5
75675: PUSH
75676: FOR_IN
75677: IFFALSE 75710
// if not i in fac_list then
75679: LD_VAR 0 8
75683: PUSH
75684: LD_VAR 0 17
75688: IN
75689: NOT
75690: IFFALSE 75708
// list := list diff i ;
75692: LD_ADDR_VAR 0 5
75696: PUSH
75697: LD_VAR 0 5
75701: PUSH
75702: LD_VAR 0 8
75706: DIFF
75707: ST_TO_ADDR
75708: GO 75676
75710: POP
75711: POP
// if not list then
75712: LD_VAR 0 5
75716: NOT
75717: IFFALSE 75721
// exit ;
75719: GO 76525
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75721: LD_VAR 0 12
75725: PUSH
75726: LD_INT 3
75728: EQUAL
75729: PUSH
75730: LD_INT 49
75732: PUSH
75733: LD_VAR 0 5
75737: IN
75738: AND
75739: PUSH
75740: LD_INT 31
75742: PPUSH
75743: LD_VAR 0 16
75747: PPUSH
75748: CALL_OW 321
75752: PUSH
75753: LD_INT 2
75755: EQUAL
75756: AND
75757: IFFALSE 75817
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75759: LD_INT 22
75761: PUSH
75762: LD_VAR 0 16
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 35
75773: PUSH
75774: LD_INT 49
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 91
75783: PUSH
75784: LD_VAR 0 1
75788: PUSH
75789: LD_INT 10
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: LIST
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: LIST
75801: PPUSH
75802: CALL_OW 69
75806: NOT
75807: IFFALSE 75817
// weapon := ru_time_lapser ;
75809: LD_ADDR_VAR 0 18
75813: PUSH
75814: LD_INT 49
75816: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75817: LD_VAR 0 12
75821: PUSH
75822: LD_INT 1
75824: PUSH
75825: LD_INT 2
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: IN
75832: PUSH
75833: LD_INT 11
75835: PUSH
75836: LD_VAR 0 5
75840: IN
75841: PUSH
75842: LD_INT 30
75844: PUSH
75845: LD_VAR 0 5
75849: IN
75850: OR
75851: AND
75852: PUSH
75853: LD_INT 6
75855: PPUSH
75856: LD_VAR 0 16
75860: PPUSH
75861: CALL_OW 321
75865: PUSH
75866: LD_INT 2
75868: EQUAL
75869: AND
75870: IFFALSE 76035
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75872: LD_INT 22
75874: PUSH
75875: LD_VAR 0 16
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 2
75886: PUSH
75887: LD_INT 35
75889: PUSH
75890: LD_INT 11
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 35
75899: PUSH
75900: LD_INT 30
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 91
75914: PUSH
75915: LD_VAR 0 1
75919: PUSH
75920: LD_INT 18
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: LIST
75927: PUSH
75928: EMPTY
75929: LIST
75930: LIST
75931: LIST
75932: PPUSH
75933: CALL_OW 69
75937: NOT
75938: PUSH
75939: LD_INT 22
75941: PUSH
75942: LD_VAR 0 16
75946: PUSH
75947: EMPTY
75948: LIST
75949: LIST
75950: PUSH
75951: LD_INT 2
75953: PUSH
75954: LD_INT 30
75956: PUSH
75957: LD_INT 32
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: LD_INT 30
75966: PUSH
75967: LD_INT 33
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: LIST
75978: PUSH
75979: LD_INT 91
75981: PUSH
75982: LD_VAR 0 1
75986: PUSH
75987: LD_INT 12
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: LIST
75994: PUSH
75995: EMPTY
75996: LIST
75997: LIST
75998: LIST
75999: PUSH
76000: EMPTY
76001: LIST
76002: PPUSH
76003: CALL_OW 69
76007: PUSH
76008: LD_INT 2
76010: GREATER
76011: AND
76012: IFFALSE 76035
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76014: LD_ADDR_VAR 0 18
76018: PUSH
76019: LD_INT 11
76021: PUSH
76022: LD_INT 30
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_VAR 0 12
76033: ARRAY
76034: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76035: LD_VAR 0 18
76039: NOT
76040: PUSH
76041: LD_INT 40
76043: PPUSH
76044: LD_VAR 0 16
76048: PPUSH
76049: CALL_OW 321
76053: PUSH
76054: LD_INT 2
76056: EQUAL
76057: AND
76058: PUSH
76059: LD_INT 7
76061: PUSH
76062: LD_VAR 0 5
76066: IN
76067: PUSH
76068: LD_INT 28
76070: PUSH
76071: LD_VAR 0 5
76075: IN
76076: OR
76077: PUSH
76078: LD_INT 45
76080: PUSH
76081: LD_VAR 0 5
76085: IN
76086: OR
76087: AND
76088: IFFALSE 76342
// begin hex := GetHexInfo ( x , y ) ;
76090: LD_ADDR_VAR 0 4
76094: PUSH
76095: LD_VAR 0 10
76099: PPUSH
76100: LD_VAR 0 11
76104: PPUSH
76105: CALL_OW 546
76109: ST_TO_ADDR
// if hex [ 1 ] then
76110: LD_VAR 0 4
76114: PUSH
76115: LD_INT 1
76117: ARRAY
76118: IFFALSE 76122
// exit ;
76120: GO 76525
// height := hex [ 2 ] ;
76122: LD_ADDR_VAR 0 15
76126: PUSH
76127: LD_VAR 0 4
76131: PUSH
76132: LD_INT 2
76134: ARRAY
76135: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76136: LD_ADDR_VAR 0 14
76140: PUSH
76141: LD_INT 0
76143: PUSH
76144: LD_INT 2
76146: PUSH
76147: LD_INT 3
76149: PUSH
76150: LD_INT 5
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: ST_TO_ADDR
// for i in tmp do
76159: LD_ADDR_VAR 0 8
76163: PUSH
76164: LD_VAR 0 14
76168: PUSH
76169: FOR_IN
76170: IFFALSE 76340
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76172: LD_ADDR_VAR 0 9
76176: PUSH
76177: LD_VAR 0 10
76181: PPUSH
76182: LD_VAR 0 8
76186: PPUSH
76187: LD_INT 5
76189: PPUSH
76190: CALL_OW 272
76194: PUSH
76195: LD_VAR 0 11
76199: PPUSH
76200: LD_VAR 0 8
76204: PPUSH
76205: LD_INT 5
76207: PPUSH
76208: CALL_OW 273
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76217: LD_VAR 0 9
76221: PUSH
76222: LD_INT 1
76224: ARRAY
76225: PPUSH
76226: LD_VAR 0 9
76230: PUSH
76231: LD_INT 2
76233: ARRAY
76234: PPUSH
76235: CALL_OW 488
76239: IFFALSE 76338
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76241: LD_ADDR_VAR 0 4
76245: PUSH
76246: LD_VAR 0 9
76250: PUSH
76251: LD_INT 1
76253: ARRAY
76254: PPUSH
76255: LD_VAR 0 9
76259: PUSH
76260: LD_INT 2
76262: ARRAY
76263: PPUSH
76264: CALL_OW 546
76268: ST_TO_ADDR
// if hex [ 1 ] then
76269: LD_VAR 0 4
76273: PUSH
76274: LD_INT 1
76276: ARRAY
76277: IFFALSE 76281
// continue ;
76279: GO 76169
// h := hex [ 2 ] ;
76281: LD_ADDR_VAR 0 13
76285: PUSH
76286: LD_VAR 0 4
76290: PUSH
76291: LD_INT 2
76293: ARRAY
76294: ST_TO_ADDR
// if h + 7 < height then
76295: LD_VAR 0 13
76299: PUSH
76300: LD_INT 7
76302: PLUS
76303: PUSH
76304: LD_VAR 0 15
76308: LESS
76309: IFFALSE 76338
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76311: LD_ADDR_VAR 0 18
76315: PUSH
76316: LD_INT 7
76318: PUSH
76319: LD_INT 28
76321: PUSH
76322: LD_INT 45
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: LIST
76329: PUSH
76330: LD_VAR 0 12
76334: ARRAY
76335: ST_TO_ADDR
// break ;
76336: GO 76340
// end ; end ; end ;
76338: GO 76169
76340: POP
76341: POP
// end ; if not weapon then
76342: LD_VAR 0 18
76346: NOT
76347: IFFALSE 76407
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76349: LD_ADDR_VAR 0 5
76353: PUSH
76354: LD_VAR 0 5
76358: PUSH
76359: LD_INT 11
76361: PUSH
76362: LD_INT 30
76364: PUSH
76365: LD_INT 49
76367: PUSH
76368: EMPTY
76369: LIST
76370: LIST
76371: LIST
76372: DIFF
76373: ST_TO_ADDR
// if not list then
76374: LD_VAR 0 5
76378: NOT
76379: IFFALSE 76383
// exit ;
76381: GO 76525
// weapon := list [ rand ( 1 , list ) ] ;
76383: LD_ADDR_VAR 0 18
76387: PUSH
76388: LD_VAR 0 5
76392: PUSH
76393: LD_INT 1
76395: PPUSH
76396: LD_VAR 0 5
76400: PPUSH
76401: CALL_OW 12
76405: ARRAY
76406: ST_TO_ADDR
// end ; if weapon then
76407: LD_VAR 0 18
76411: IFFALSE 76525
// begin tmp := CostOfWeapon ( weapon ) ;
76413: LD_ADDR_VAR 0 14
76417: PUSH
76418: LD_VAR 0 18
76422: PPUSH
76423: CALL_OW 451
76427: ST_TO_ADDR
// j := GetBase ( tower ) ;
76428: LD_ADDR_VAR 0 9
76432: PUSH
76433: LD_VAR 0 1
76437: PPUSH
76438: CALL_OW 274
76442: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76443: LD_VAR 0 9
76447: PPUSH
76448: LD_INT 1
76450: PPUSH
76451: CALL_OW 275
76455: PUSH
76456: LD_VAR 0 14
76460: PUSH
76461: LD_INT 1
76463: ARRAY
76464: GREATEREQUAL
76465: PUSH
76466: LD_VAR 0 9
76470: PPUSH
76471: LD_INT 2
76473: PPUSH
76474: CALL_OW 275
76478: PUSH
76479: LD_VAR 0 14
76483: PUSH
76484: LD_INT 2
76486: ARRAY
76487: GREATEREQUAL
76488: AND
76489: PUSH
76490: LD_VAR 0 9
76494: PPUSH
76495: LD_INT 3
76497: PPUSH
76498: CALL_OW 275
76502: PUSH
76503: LD_VAR 0 14
76507: PUSH
76508: LD_INT 3
76510: ARRAY
76511: GREATEREQUAL
76512: AND
76513: IFFALSE 76525
// result := weapon ;
76515: LD_ADDR_VAR 0 3
76519: PUSH
76520: LD_VAR 0 18
76524: ST_TO_ADDR
// end ; end ;
76525: LD_VAR 0 3
76529: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76530: LD_INT 0
76532: PPUSH
76533: PPUSH
// result := true ;
76534: LD_ADDR_VAR 0 3
76538: PUSH
76539: LD_INT 1
76541: ST_TO_ADDR
// if array1 = array2 then
76542: LD_VAR 0 1
76546: PUSH
76547: LD_VAR 0 2
76551: EQUAL
76552: IFFALSE 76612
// begin for i = 1 to array1 do
76554: LD_ADDR_VAR 0 4
76558: PUSH
76559: DOUBLE
76560: LD_INT 1
76562: DEC
76563: ST_TO_ADDR
76564: LD_VAR 0 1
76568: PUSH
76569: FOR_TO
76570: IFFALSE 76608
// if array1 [ i ] <> array2 [ i ] then
76572: LD_VAR 0 1
76576: PUSH
76577: LD_VAR 0 4
76581: ARRAY
76582: PUSH
76583: LD_VAR 0 2
76587: PUSH
76588: LD_VAR 0 4
76592: ARRAY
76593: NONEQUAL
76594: IFFALSE 76606
// begin result := false ;
76596: LD_ADDR_VAR 0 3
76600: PUSH
76601: LD_INT 0
76603: ST_TO_ADDR
// break ;
76604: GO 76608
// end ;
76606: GO 76569
76608: POP
76609: POP
// end else
76610: GO 76620
// result := false ;
76612: LD_ADDR_VAR 0 3
76616: PUSH
76617: LD_INT 0
76619: ST_TO_ADDR
// end ;
76620: LD_VAR 0 3
76624: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76625: LD_INT 0
76627: PPUSH
76628: PPUSH
76629: PPUSH
// pom := GetBase ( fac ) ;
76630: LD_ADDR_VAR 0 5
76634: PUSH
76635: LD_VAR 0 1
76639: PPUSH
76640: CALL_OW 274
76644: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76645: LD_ADDR_VAR 0 4
76649: PUSH
76650: LD_VAR 0 2
76654: PUSH
76655: LD_INT 1
76657: ARRAY
76658: PPUSH
76659: LD_VAR 0 2
76663: PUSH
76664: LD_INT 2
76666: ARRAY
76667: PPUSH
76668: LD_VAR 0 2
76672: PUSH
76673: LD_INT 3
76675: ARRAY
76676: PPUSH
76677: LD_VAR 0 2
76681: PUSH
76682: LD_INT 4
76684: ARRAY
76685: PPUSH
76686: CALL_OW 449
76690: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76691: LD_ADDR_VAR 0 3
76695: PUSH
76696: LD_VAR 0 5
76700: PPUSH
76701: LD_INT 1
76703: PPUSH
76704: CALL_OW 275
76708: PUSH
76709: LD_VAR 0 4
76713: PUSH
76714: LD_INT 1
76716: ARRAY
76717: GREATEREQUAL
76718: PUSH
76719: LD_VAR 0 5
76723: PPUSH
76724: LD_INT 2
76726: PPUSH
76727: CALL_OW 275
76731: PUSH
76732: LD_VAR 0 4
76736: PUSH
76737: LD_INT 2
76739: ARRAY
76740: GREATEREQUAL
76741: AND
76742: PUSH
76743: LD_VAR 0 5
76747: PPUSH
76748: LD_INT 3
76750: PPUSH
76751: CALL_OW 275
76755: PUSH
76756: LD_VAR 0 4
76760: PUSH
76761: LD_INT 3
76763: ARRAY
76764: GREATEREQUAL
76765: AND
76766: ST_TO_ADDR
// end ;
76767: LD_VAR 0 3
76771: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76772: LD_INT 0
76774: PPUSH
76775: PPUSH
76776: PPUSH
76777: PPUSH
// pom := GetBase ( building ) ;
76778: LD_ADDR_VAR 0 3
76782: PUSH
76783: LD_VAR 0 1
76787: PPUSH
76788: CALL_OW 274
76792: ST_TO_ADDR
// if not pom then
76793: LD_VAR 0 3
76797: NOT
76798: IFFALSE 76802
// exit ;
76800: GO 76972
// btype := GetBType ( building ) ;
76802: LD_ADDR_VAR 0 5
76806: PUSH
76807: LD_VAR 0 1
76811: PPUSH
76812: CALL_OW 266
76816: ST_TO_ADDR
// if btype = b_armoury then
76817: LD_VAR 0 5
76821: PUSH
76822: LD_INT 4
76824: EQUAL
76825: IFFALSE 76835
// btype := b_barracks ;
76827: LD_ADDR_VAR 0 5
76831: PUSH
76832: LD_INT 5
76834: ST_TO_ADDR
// if btype = b_depot then
76835: LD_VAR 0 5
76839: PUSH
76840: LD_INT 0
76842: EQUAL
76843: IFFALSE 76853
// btype := b_warehouse ;
76845: LD_ADDR_VAR 0 5
76849: PUSH
76850: LD_INT 1
76852: ST_TO_ADDR
// if btype = b_workshop then
76853: LD_VAR 0 5
76857: PUSH
76858: LD_INT 2
76860: EQUAL
76861: IFFALSE 76871
// btype := b_factory ;
76863: LD_ADDR_VAR 0 5
76867: PUSH
76868: LD_INT 3
76870: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76871: LD_ADDR_VAR 0 4
76875: PUSH
76876: LD_VAR 0 5
76880: PPUSH
76881: LD_VAR 0 1
76885: PPUSH
76886: CALL_OW 248
76890: PPUSH
76891: CALL_OW 450
76895: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76896: LD_ADDR_VAR 0 2
76900: PUSH
76901: LD_VAR 0 3
76905: PPUSH
76906: LD_INT 1
76908: PPUSH
76909: CALL_OW 275
76913: PUSH
76914: LD_VAR 0 4
76918: PUSH
76919: LD_INT 1
76921: ARRAY
76922: GREATEREQUAL
76923: PUSH
76924: LD_VAR 0 3
76928: PPUSH
76929: LD_INT 2
76931: PPUSH
76932: CALL_OW 275
76936: PUSH
76937: LD_VAR 0 4
76941: PUSH
76942: LD_INT 2
76944: ARRAY
76945: GREATEREQUAL
76946: AND
76947: PUSH
76948: LD_VAR 0 3
76952: PPUSH
76953: LD_INT 3
76955: PPUSH
76956: CALL_OW 275
76960: PUSH
76961: LD_VAR 0 4
76965: PUSH
76966: LD_INT 3
76968: ARRAY
76969: GREATEREQUAL
76970: AND
76971: ST_TO_ADDR
// end ;
76972: LD_VAR 0 2
76976: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76977: LD_INT 0
76979: PPUSH
76980: PPUSH
76981: PPUSH
// pom := GetBase ( building ) ;
76982: LD_ADDR_VAR 0 4
76986: PUSH
76987: LD_VAR 0 1
76991: PPUSH
76992: CALL_OW 274
76996: ST_TO_ADDR
// if not pom then
76997: LD_VAR 0 4
77001: NOT
77002: IFFALSE 77006
// exit ;
77004: GO 77107
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77006: LD_ADDR_VAR 0 5
77010: PUSH
77011: LD_VAR 0 2
77015: PPUSH
77016: LD_VAR 0 1
77020: PPUSH
77021: CALL_OW 248
77025: PPUSH
77026: CALL_OW 450
77030: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77031: LD_ADDR_VAR 0 3
77035: PUSH
77036: LD_VAR 0 4
77040: PPUSH
77041: LD_INT 1
77043: PPUSH
77044: CALL_OW 275
77048: PUSH
77049: LD_VAR 0 5
77053: PUSH
77054: LD_INT 1
77056: ARRAY
77057: GREATEREQUAL
77058: PUSH
77059: LD_VAR 0 4
77063: PPUSH
77064: LD_INT 2
77066: PPUSH
77067: CALL_OW 275
77071: PUSH
77072: LD_VAR 0 5
77076: PUSH
77077: LD_INT 2
77079: ARRAY
77080: GREATEREQUAL
77081: AND
77082: PUSH
77083: LD_VAR 0 4
77087: PPUSH
77088: LD_INT 3
77090: PPUSH
77091: CALL_OW 275
77095: PUSH
77096: LD_VAR 0 5
77100: PUSH
77101: LD_INT 3
77103: ARRAY
77104: GREATEREQUAL
77105: AND
77106: ST_TO_ADDR
// end ;
77107: LD_VAR 0 3
77111: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77112: LD_INT 0
77114: PPUSH
77115: PPUSH
77116: PPUSH
77117: PPUSH
77118: PPUSH
77119: PPUSH
77120: PPUSH
77121: PPUSH
77122: PPUSH
77123: PPUSH
// result := false ;
77124: LD_ADDR_VAR 0 6
77128: PUSH
77129: LD_INT 0
77131: ST_TO_ADDR
// if not base or not btype or not x or not y then
77132: LD_VAR 0 1
77136: NOT
77137: PUSH
77138: LD_VAR 0 2
77142: NOT
77143: OR
77144: PUSH
77145: LD_VAR 0 3
77149: NOT
77150: OR
77151: PUSH
77152: LD_VAR 0 4
77156: NOT
77157: OR
77158: IFFALSE 77162
// exit ;
77160: GO 77771
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
77162: LD_ADDR_VAR 0 12
77166: PUSH
77167: LD_VAR 0 2
77171: PPUSH
77172: LD_VAR 0 3
77176: PPUSH
77177: LD_VAR 0 4
77181: PPUSH
77182: LD_VAR 0 5
77186: PPUSH
77187: LD_VAR 0 1
77191: PUSH
77192: LD_INT 1
77194: ARRAY
77195: PPUSH
77196: CALL_OW 248
77200: PPUSH
77201: LD_INT 0
77203: PPUSH
77204: CALL 78608 0 6
77208: ST_TO_ADDR
// if not hexes then
77209: LD_VAR 0 12
77213: NOT
77214: IFFALSE 77218
// exit ;
77216: GO 77771
// for i = 1 to hexes do
77218: LD_ADDR_VAR 0 7
77222: PUSH
77223: DOUBLE
77224: LD_INT 1
77226: DEC
77227: ST_TO_ADDR
77228: LD_VAR 0 12
77232: PUSH
77233: FOR_TO
77234: IFFALSE 77769
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77236: LD_ADDR_VAR 0 11
77240: PUSH
77241: LD_VAR 0 12
77245: PUSH
77246: LD_VAR 0 7
77250: ARRAY
77251: PUSH
77252: LD_INT 1
77254: ARRAY
77255: PPUSH
77256: LD_VAR 0 12
77260: PUSH
77261: LD_VAR 0 7
77265: ARRAY
77266: PUSH
77267: LD_INT 2
77269: ARRAY
77270: PPUSH
77271: CALL_OW 428
77275: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77276: LD_VAR 0 12
77280: PUSH
77281: LD_VAR 0 7
77285: ARRAY
77286: PUSH
77287: LD_INT 1
77289: ARRAY
77290: PPUSH
77291: LD_VAR 0 12
77295: PUSH
77296: LD_VAR 0 7
77300: ARRAY
77301: PUSH
77302: LD_INT 2
77304: ARRAY
77305: PPUSH
77306: CALL_OW 351
77310: PUSH
77311: LD_VAR 0 12
77315: PUSH
77316: LD_VAR 0 7
77320: ARRAY
77321: PUSH
77322: LD_INT 1
77324: ARRAY
77325: PPUSH
77326: LD_VAR 0 12
77330: PUSH
77331: LD_VAR 0 7
77335: ARRAY
77336: PUSH
77337: LD_INT 2
77339: ARRAY
77340: PPUSH
77341: CALL_OW 488
77345: NOT
77346: OR
77347: PUSH
77348: LD_VAR 0 11
77352: PPUSH
77353: CALL_OW 247
77357: PUSH
77358: LD_INT 3
77360: EQUAL
77361: OR
77362: IFFALSE 77368
// exit ;
77364: POP
77365: POP
77366: GO 77771
// if not tmp or not tmp in base then
77368: LD_VAR 0 11
77372: NOT
77373: PUSH
77374: LD_VAR 0 11
77378: PUSH
77379: LD_VAR 0 1
77383: IN
77384: NOT
77385: OR
77386: IFFALSE 77390
// continue ;
77388: GO 77233
// result := true ;
77390: LD_ADDR_VAR 0 6
77394: PUSH
77395: LD_INT 1
77397: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77398: LD_ADDR_VAR 0 15
77402: PUSH
77403: LD_VAR 0 1
77407: PPUSH
77408: LD_INT 22
77410: PUSH
77411: LD_VAR 0 11
77415: PPUSH
77416: CALL_OW 255
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 2
77427: PUSH
77428: LD_INT 30
77430: PUSH
77431: LD_INT 0
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 30
77440: PUSH
77441: LD_INT 1
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: LIST
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PPUSH
77457: CALL_OW 72
77461: ST_TO_ADDR
// if dep then
77462: LD_VAR 0 15
77466: IFFALSE 77602
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77468: LD_ADDR_VAR 0 14
77472: PUSH
77473: LD_VAR 0 15
77477: PUSH
77478: LD_INT 1
77480: ARRAY
77481: PPUSH
77482: CALL_OW 250
77486: PPUSH
77487: LD_VAR 0 15
77491: PUSH
77492: LD_INT 1
77494: ARRAY
77495: PPUSH
77496: CALL_OW 254
77500: PPUSH
77501: LD_INT 5
77503: PPUSH
77504: CALL_OW 272
77508: PUSH
77509: LD_VAR 0 15
77513: PUSH
77514: LD_INT 1
77516: ARRAY
77517: PPUSH
77518: CALL_OW 251
77522: PPUSH
77523: LD_VAR 0 15
77527: PUSH
77528: LD_INT 1
77530: ARRAY
77531: PPUSH
77532: CALL_OW 254
77536: PPUSH
77537: LD_INT 5
77539: PPUSH
77540: CALL_OW 273
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77549: LD_VAR 0 14
77553: PUSH
77554: LD_INT 1
77556: ARRAY
77557: PPUSH
77558: LD_VAR 0 14
77562: PUSH
77563: LD_INT 2
77565: ARRAY
77566: PPUSH
77567: CALL_OW 488
77571: IFFALSE 77602
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77573: LD_VAR 0 11
77577: PPUSH
77578: LD_VAR 0 14
77582: PUSH
77583: LD_INT 1
77585: ARRAY
77586: PPUSH
77587: LD_VAR 0 14
77591: PUSH
77592: LD_INT 2
77594: ARRAY
77595: PPUSH
77596: CALL_OW 111
// continue ;
77600: GO 77233
// end ; end ; r := GetDir ( tmp ) ;
77602: LD_ADDR_VAR 0 13
77606: PUSH
77607: LD_VAR 0 11
77611: PPUSH
77612: CALL_OW 254
77616: ST_TO_ADDR
// if r = 5 then
77617: LD_VAR 0 13
77621: PUSH
77622: LD_INT 5
77624: EQUAL
77625: IFFALSE 77635
// r := 0 ;
77627: LD_ADDR_VAR 0 13
77631: PUSH
77632: LD_INT 0
77634: ST_TO_ADDR
// for j = r to 5 do
77635: LD_ADDR_VAR 0 8
77639: PUSH
77640: DOUBLE
77641: LD_VAR 0 13
77645: DEC
77646: ST_TO_ADDR
77647: LD_INT 5
77649: PUSH
77650: FOR_TO
77651: IFFALSE 77765
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77653: LD_ADDR_VAR 0 9
77657: PUSH
77658: LD_VAR 0 11
77662: PPUSH
77663: CALL_OW 250
77667: PPUSH
77668: LD_VAR 0 8
77672: PPUSH
77673: LD_INT 2
77675: PPUSH
77676: CALL_OW 272
77680: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77681: LD_ADDR_VAR 0 10
77685: PUSH
77686: LD_VAR 0 11
77690: PPUSH
77691: CALL_OW 251
77695: PPUSH
77696: LD_VAR 0 8
77700: PPUSH
77701: LD_INT 2
77703: PPUSH
77704: CALL_OW 273
77708: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77709: LD_VAR 0 9
77713: PPUSH
77714: LD_VAR 0 10
77718: PPUSH
77719: CALL_OW 488
77723: PUSH
77724: LD_VAR 0 9
77728: PPUSH
77729: LD_VAR 0 10
77733: PPUSH
77734: CALL_OW 428
77738: NOT
77739: AND
77740: IFFALSE 77763
// begin ComMoveXY ( tmp , _x , _y ) ;
77742: LD_VAR 0 11
77746: PPUSH
77747: LD_VAR 0 9
77751: PPUSH
77752: LD_VAR 0 10
77756: PPUSH
77757: CALL_OW 111
// break ;
77761: GO 77765
// end ; end ;
77763: GO 77650
77765: POP
77766: POP
// end ;
77767: GO 77233
77769: POP
77770: POP
// end ;
77771: LD_VAR 0 6
77775: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77776: LD_INT 0
77778: PPUSH
77779: PPUSH
77780: PPUSH
77781: PPUSH
77782: PPUSH
77783: PPUSH
77784: PPUSH
77785: PPUSH
77786: PPUSH
77787: PPUSH
// result := false ;
77788: LD_ADDR_VAR 0 6
77792: PUSH
77793: LD_INT 0
77795: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77796: LD_VAR 0 1
77800: NOT
77801: PUSH
77802: LD_VAR 0 1
77806: PPUSH
77807: CALL_OW 266
77811: PUSH
77812: LD_INT 0
77814: PUSH
77815: LD_INT 1
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: IN
77822: NOT
77823: OR
77824: PUSH
77825: LD_VAR 0 2
77829: NOT
77830: OR
77831: PUSH
77832: LD_VAR 0 5
77836: PUSH
77837: LD_INT 0
77839: PUSH
77840: LD_INT 1
77842: PUSH
77843: LD_INT 2
77845: PUSH
77846: LD_INT 3
77848: PUSH
77849: LD_INT 4
77851: PUSH
77852: LD_INT 5
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: LIST
77861: LIST
77862: IN
77863: NOT
77864: OR
77865: PUSH
77866: LD_VAR 0 3
77870: PPUSH
77871: LD_VAR 0 4
77875: PPUSH
77876: CALL_OW 488
77880: NOT
77881: OR
77882: IFFALSE 77886
// exit ;
77884: GO 78603
// pom := GetBase ( depot ) ;
77886: LD_ADDR_VAR 0 10
77890: PUSH
77891: LD_VAR 0 1
77895: PPUSH
77896: CALL_OW 274
77900: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77901: LD_ADDR_VAR 0 11
77905: PUSH
77906: LD_VAR 0 2
77910: PPUSH
77911: LD_VAR 0 1
77915: PPUSH
77916: CALL_OW 248
77920: PPUSH
77921: CALL_OW 450
77925: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77926: LD_VAR 0 10
77930: PPUSH
77931: LD_INT 1
77933: PPUSH
77934: CALL_OW 275
77938: PUSH
77939: LD_VAR 0 11
77943: PUSH
77944: LD_INT 1
77946: ARRAY
77947: GREATEREQUAL
77948: PUSH
77949: LD_VAR 0 10
77953: PPUSH
77954: LD_INT 2
77956: PPUSH
77957: CALL_OW 275
77961: PUSH
77962: LD_VAR 0 11
77966: PUSH
77967: LD_INT 2
77969: ARRAY
77970: GREATEREQUAL
77971: AND
77972: PUSH
77973: LD_VAR 0 10
77977: PPUSH
77978: LD_INT 3
77980: PPUSH
77981: CALL_OW 275
77985: PUSH
77986: LD_VAR 0 11
77990: PUSH
77991: LD_INT 3
77993: ARRAY
77994: GREATEREQUAL
77995: AND
77996: NOT
77997: IFFALSE 78001
// exit ;
77999: GO 78603
// if GetBType ( depot ) = b_depot then
78001: LD_VAR 0 1
78005: PPUSH
78006: CALL_OW 266
78010: PUSH
78011: LD_INT 0
78013: EQUAL
78014: IFFALSE 78026
// dist := 28 else
78016: LD_ADDR_VAR 0 14
78020: PUSH
78021: LD_INT 28
78023: ST_TO_ADDR
78024: GO 78034
// dist := 36 ;
78026: LD_ADDR_VAR 0 14
78030: PUSH
78031: LD_INT 36
78033: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78034: LD_VAR 0 1
78038: PPUSH
78039: LD_VAR 0 3
78043: PPUSH
78044: LD_VAR 0 4
78048: PPUSH
78049: CALL_OW 297
78053: PUSH
78054: LD_VAR 0 14
78058: GREATER
78059: IFFALSE 78063
// exit ;
78061: GO 78603
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78063: LD_ADDR_VAR 0 12
78067: PUSH
78068: LD_VAR 0 2
78072: PPUSH
78073: LD_VAR 0 3
78077: PPUSH
78078: LD_VAR 0 4
78082: PPUSH
78083: LD_VAR 0 5
78087: PPUSH
78088: LD_VAR 0 1
78092: PPUSH
78093: CALL_OW 248
78097: PPUSH
78098: LD_INT 0
78100: PPUSH
78101: CALL 78608 0 6
78105: ST_TO_ADDR
// if not hexes then
78106: LD_VAR 0 12
78110: NOT
78111: IFFALSE 78115
// exit ;
78113: GO 78603
// hex := GetHexInfo ( x , y ) ;
78115: LD_ADDR_VAR 0 15
78119: PUSH
78120: LD_VAR 0 3
78124: PPUSH
78125: LD_VAR 0 4
78129: PPUSH
78130: CALL_OW 546
78134: ST_TO_ADDR
// if hex [ 1 ] then
78135: LD_VAR 0 15
78139: PUSH
78140: LD_INT 1
78142: ARRAY
78143: IFFALSE 78147
// exit ;
78145: GO 78603
// height := hex [ 2 ] ;
78147: LD_ADDR_VAR 0 13
78151: PUSH
78152: LD_VAR 0 15
78156: PUSH
78157: LD_INT 2
78159: ARRAY
78160: ST_TO_ADDR
// for i = 1 to hexes do
78161: LD_ADDR_VAR 0 7
78165: PUSH
78166: DOUBLE
78167: LD_INT 1
78169: DEC
78170: ST_TO_ADDR
78171: LD_VAR 0 12
78175: PUSH
78176: FOR_TO
78177: IFFALSE 78507
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
78179: LD_VAR 0 12
78183: PUSH
78184: LD_VAR 0 7
78188: ARRAY
78189: PUSH
78190: LD_INT 1
78192: ARRAY
78193: PPUSH
78194: LD_VAR 0 12
78198: PUSH
78199: LD_VAR 0 7
78203: ARRAY
78204: PUSH
78205: LD_INT 2
78207: ARRAY
78208: PPUSH
78209: CALL_OW 488
78213: NOT
78214: PUSH
78215: LD_VAR 0 12
78219: PUSH
78220: LD_VAR 0 7
78224: ARRAY
78225: PUSH
78226: LD_INT 1
78228: ARRAY
78229: PPUSH
78230: LD_VAR 0 12
78234: PUSH
78235: LD_VAR 0 7
78239: ARRAY
78240: PUSH
78241: LD_INT 2
78243: ARRAY
78244: PPUSH
78245: CALL_OW 428
78249: PUSH
78250: LD_INT 0
78252: GREATER
78253: OR
78254: PUSH
78255: LD_VAR 0 12
78259: PUSH
78260: LD_VAR 0 7
78264: ARRAY
78265: PUSH
78266: LD_INT 1
78268: ARRAY
78269: PPUSH
78270: LD_VAR 0 12
78274: PUSH
78275: LD_VAR 0 7
78279: ARRAY
78280: PUSH
78281: LD_INT 2
78283: ARRAY
78284: PPUSH
78285: CALL_OW 351
78289: OR
78290: IFFALSE 78296
// exit ;
78292: POP
78293: POP
78294: GO 78603
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78296: LD_ADDR_VAR 0 8
78300: PUSH
78301: LD_VAR 0 12
78305: PUSH
78306: LD_VAR 0 7
78310: ARRAY
78311: PUSH
78312: LD_INT 1
78314: ARRAY
78315: PPUSH
78316: LD_VAR 0 12
78320: PUSH
78321: LD_VAR 0 7
78325: ARRAY
78326: PUSH
78327: LD_INT 2
78329: ARRAY
78330: PPUSH
78331: CALL_OW 546
78335: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78336: LD_VAR 0 8
78340: PUSH
78341: LD_INT 1
78343: ARRAY
78344: PUSH
78345: LD_VAR 0 8
78349: PUSH
78350: LD_INT 2
78352: ARRAY
78353: PUSH
78354: LD_VAR 0 13
78358: PUSH
78359: LD_INT 2
78361: PLUS
78362: GREATER
78363: OR
78364: PUSH
78365: LD_VAR 0 8
78369: PUSH
78370: LD_INT 2
78372: ARRAY
78373: PUSH
78374: LD_VAR 0 13
78378: PUSH
78379: LD_INT 2
78381: MINUS
78382: LESS
78383: OR
78384: PUSH
78385: LD_VAR 0 8
78389: PUSH
78390: LD_INT 3
78392: ARRAY
78393: PUSH
78394: LD_INT 0
78396: PUSH
78397: LD_INT 8
78399: PUSH
78400: LD_INT 9
78402: PUSH
78403: LD_INT 10
78405: PUSH
78406: LD_INT 11
78408: PUSH
78409: LD_INT 12
78411: PUSH
78412: LD_INT 13
78414: PUSH
78415: LD_INT 16
78417: PUSH
78418: LD_INT 17
78420: PUSH
78421: LD_INT 18
78423: PUSH
78424: LD_INT 19
78426: PUSH
78427: LD_INT 20
78429: PUSH
78430: LD_INT 21
78432: PUSH
78433: EMPTY
78434: LIST
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: IN
78448: NOT
78449: OR
78450: PUSH
78451: LD_VAR 0 8
78455: PUSH
78456: LD_INT 5
78458: ARRAY
78459: NOT
78460: OR
78461: PUSH
78462: LD_VAR 0 8
78466: PUSH
78467: LD_INT 6
78469: ARRAY
78470: PUSH
78471: LD_INT 1
78473: PUSH
78474: LD_INT 2
78476: PUSH
78477: LD_INT 7
78479: PUSH
78480: LD_INT 9
78482: PUSH
78483: LD_INT 10
78485: PUSH
78486: LD_INT 11
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: IN
78497: NOT
78498: OR
78499: IFFALSE 78505
// exit ;
78501: POP
78502: POP
78503: GO 78603
// end ;
78505: GO 78176
78507: POP
78508: POP
// side := GetSide ( depot ) ;
78509: LD_ADDR_VAR 0 9
78513: PUSH
78514: LD_VAR 0 1
78518: PPUSH
78519: CALL_OW 255
78523: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78524: LD_VAR 0 9
78528: PPUSH
78529: LD_VAR 0 3
78533: PPUSH
78534: LD_VAR 0 4
78538: PPUSH
78539: LD_INT 20
78541: PPUSH
78542: CALL 71257 0 4
78546: PUSH
78547: LD_INT 4
78549: ARRAY
78550: IFFALSE 78554
// exit ;
78552: GO 78603
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78554: LD_VAR 0 2
78558: PUSH
78559: LD_INT 29
78561: PUSH
78562: LD_INT 30
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: IN
78569: PUSH
78570: LD_VAR 0 3
78574: PPUSH
78575: LD_VAR 0 4
78579: PPUSH
78580: LD_VAR 0 9
78584: PPUSH
78585: CALL_OW 440
78589: NOT
78590: AND
78591: IFFALSE 78595
// exit ;
78593: GO 78603
// result := true ;
78595: LD_ADDR_VAR 0 6
78599: PUSH
78600: LD_INT 1
78602: ST_TO_ADDR
// end ;
78603: LD_VAR 0 6
78607: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
78608: LD_INT 0
78610: PPUSH
78611: PPUSH
78612: PPUSH
78613: PPUSH
78614: PPUSH
78615: PPUSH
78616: PPUSH
78617: PPUSH
78618: PPUSH
78619: PPUSH
78620: PPUSH
78621: PPUSH
78622: PPUSH
78623: PPUSH
78624: PPUSH
78625: PPUSH
78626: PPUSH
78627: PPUSH
78628: PPUSH
78629: PPUSH
78630: PPUSH
78631: PPUSH
78632: PPUSH
78633: PPUSH
78634: PPUSH
78635: PPUSH
78636: PPUSH
78637: PPUSH
78638: PPUSH
78639: PPUSH
78640: PPUSH
78641: PPUSH
78642: PPUSH
78643: PPUSH
78644: PPUSH
78645: PPUSH
78646: PPUSH
78647: PPUSH
78648: PPUSH
78649: PPUSH
78650: PPUSH
78651: PPUSH
78652: PPUSH
78653: PPUSH
78654: PPUSH
78655: PPUSH
78656: PPUSH
78657: PPUSH
78658: PPUSH
78659: PPUSH
78660: PPUSH
78661: PPUSH
78662: PPUSH
78663: PPUSH
78664: PPUSH
78665: PPUSH
78666: PPUSH
78667: PPUSH
// result = [ ] ;
78668: LD_ADDR_VAR 0 7
78672: PUSH
78673: EMPTY
78674: ST_TO_ADDR
// temp_list = [ ] ;
78675: LD_ADDR_VAR 0 9
78679: PUSH
78680: EMPTY
78681: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78682: LD_VAR 0 4
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: LD_INT 1
78692: PUSH
78693: LD_INT 2
78695: PUSH
78696: LD_INT 3
78698: PUSH
78699: LD_INT 4
78701: PUSH
78702: LD_INT 5
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: IN
78713: NOT
78714: PUSH
78715: LD_VAR 0 1
78719: PUSH
78720: LD_INT 0
78722: PUSH
78723: LD_INT 1
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: IN
78730: PUSH
78731: LD_VAR 0 5
78735: PUSH
78736: LD_INT 1
78738: PUSH
78739: LD_INT 2
78741: PUSH
78742: LD_INT 3
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: LIST
78749: IN
78750: NOT
78751: AND
78752: OR
78753: IFFALSE 78757
// exit ;
78755: GO 97148
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78757: LD_VAR 0 1
78761: PUSH
78762: LD_INT 6
78764: PUSH
78765: LD_INT 7
78767: PUSH
78768: LD_INT 8
78770: PUSH
78771: LD_INT 13
78773: PUSH
78774: LD_INT 12
78776: PUSH
78777: LD_INT 15
78779: PUSH
78780: LD_INT 11
78782: PUSH
78783: LD_INT 14
78785: PUSH
78786: LD_INT 10
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: IN
78800: IFFALSE 78810
// btype = b_lab ;
78802: LD_ADDR_VAR 0 1
78806: PUSH
78807: LD_INT 6
78809: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78810: LD_VAR 0 6
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 1
78820: PUSH
78821: LD_INT 2
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: LIST
78828: IN
78829: NOT
78830: PUSH
78831: LD_VAR 0 1
78835: PUSH
78836: LD_INT 0
78838: PUSH
78839: LD_INT 1
78841: PUSH
78842: LD_INT 2
78844: PUSH
78845: LD_INT 3
78847: PUSH
78848: LD_INT 6
78850: PUSH
78851: LD_INT 36
78853: PUSH
78854: LD_INT 4
78856: PUSH
78857: LD_INT 5
78859: PUSH
78860: LD_INT 31
78862: PUSH
78863: LD_INT 32
78865: PUSH
78866: LD_INT 33
78868: PUSH
78869: EMPTY
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: IN
78882: NOT
78883: PUSH
78884: LD_VAR 0 6
78888: PUSH
78889: LD_INT 1
78891: EQUAL
78892: AND
78893: OR
78894: PUSH
78895: LD_VAR 0 1
78899: PUSH
78900: LD_INT 2
78902: PUSH
78903: LD_INT 3
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: IN
78910: NOT
78911: PUSH
78912: LD_VAR 0 6
78916: PUSH
78917: LD_INT 2
78919: EQUAL
78920: AND
78921: OR
78922: IFFALSE 78932
// mode = 0 ;
78924: LD_ADDR_VAR 0 6
78928: PUSH
78929: LD_INT 0
78931: ST_TO_ADDR
// case mode of 0 :
78932: LD_VAR 0 6
78936: PUSH
78937: LD_INT 0
78939: DOUBLE
78940: EQUAL
78941: IFTRUE 78945
78943: GO 90398
78945: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78946: LD_ADDR_VAR 0 11
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: LD_INT 0
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: LD_INT 1
78966: NEG
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 1
78974: PUSH
78975: LD_INT 0
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 1
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 0
78994: PUSH
78995: LD_INT 1
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 1
79004: NEG
79005: PUSH
79006: LD_INT 0
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 1
79015: NEG
79016: PUSH
79017: LD_INT 1
79019: NEG
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: LD_INT 2
79031: NEG
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: LD_INT 2
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 1
79061: PUSH
79062: LD_INT 2
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 0
79071: PUSH
79072: LD_INT 2
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 1
79081: NEG
79082: PUSH
79083: LD_INT 1
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 1
79092: PUSH
79093: LD_INT 3
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: LD_INT 0
79102: PUSH
79103: LD_INT 3
79105: PUSH
79106: EMPTY
79107: LIST
79108: LIST
79109: PUSH
79110: LD_INT 1
79112: NEG
79113: PUSH
79114: LD_INT 2
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79139: LD_ADDR_VAR 0 12
79143: PUSH
79144: LD_INT 0
79146: PUSH
79147: LD_INT 0
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 0
79156: PUSH
79157: LD_INT 1
79159: NEG
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 1
79167: PUSH
79168: LD_INT 0
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 1
79177: PUSH
79178: LD_INT 1
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 0
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 1
79197: NEG
79198: PUSH
79199: LD_INT 0
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 1
79208: NEG
79209: PUSH
79210: LD_INT 1
79212: NEG
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 1
79220: PUSH
79221: LD_INT 1
79223: NEG
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 2
79231: PUSH
79232: LD_INT 0
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 1
79251: NEG
79252: PUSH
79253: LD_INT 1
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 2
79262: NEG
79263: PUSH
79264: LD_INT 0
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 2
79273: NEG
79274: PUSH
79275: LD_INT 1
79277: NEG
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 2
79285: NEG
79286: PUSH
79287: LD_INT 1
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 3
79296: NEG
79297: PUSH
79298: LD_INT 0
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: PUSH
79305: LD_INT 3
79307: NEG
79308: PUSH
79309: LD_INT 1
79311: NEG
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79335: LD_ADDR_VAR 0 13
79339: PUSH
79340: LD_INT 0
79342: PUSH
79343: LD_INT 0
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: LD_INT 1
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 1
79363: PUSH
79364: LD_INT 0
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 1
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 0
79383: PUSH
79384: LD_INT 1
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 1
79393: NEG
79394: PUSH
79395: LD_INT 0
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 1
79404: NEG
79405: PUSH
79406: LD_INT 1
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: LD_INT 1
79416: NEG
79417: PUSH
79418: LD_INT 2
79420: NEG
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 2
79428: PUSH
79429: LD_INT 1
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 2
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 1
79448: PUSH
79449: LD_INT 2
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 2
79458: NEG
79459: PUSH
79460: LD_INT 1
79462: NEG
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 2
79470: NEG
79471: PUSH
79472: LD_INT 2
79474: NEG
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 2
79482: NEG
79483: PUSH
79484: LD_INT 3
79486: NEG
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 3
79494: NEG
79495: PUSH
79496: LD_INT 2
79498: NEG
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 3
79506: NEG
79507: PUSH
79508: LD_INT 3
79510: NEG
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79534: LD_ADDR_VAR 0 14
79538: PUSH
79539: LD_INT 0
79541: PUSH
79542: LD_INT 0
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: LD_INT 1
79554: NEG
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: LD_INT 0
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 1
79572: PUSH
79573: LD_INT 1
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: LD_INT 1
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: LD_INT 0
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 1
79603: NEG
79604: PUSH
79605: LD_INT 1
79607: NEG
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 1
79615: NEG
79616: PUSH
79617: LD_INT 2
79619: NEG
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 0
79627: PUSH
79628: LD_INT 2
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 1
79638: PUSH
79639: LD_INT 1
79641: NEG
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: LD_INT 1
79649: PUSH
79650: LD_INT 2
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 0
79659: PUSH
79660: LD_INT 2
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 1
79669: NEG
79670: PUSH
79671: LD_INT 1
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 1
79680: NEG
79681: PUSH
79682: LD_INT 3
79684: NEG
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 0
79692: PUSH
79693: LD_INT 3
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 1
79703: PUSH
79704: LD_INT 2
79706: NEG
79707: PUSH
79708: EMPTY
79709: LIST
79710: LIST
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79730: LD_ADDR_VAR 0 15
79734: PUSH
79735: LD_INT 0
79737: PUSH
79738: LD_INT 0
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 0
79747: PUSH
79748: LD_INT 1
79750: NEG
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PUSH
79756: LD_INT 1
79758: PUSH
79759: LD_INT 0
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: PUSH
79766: LD_INT 1
79768: PUSH
79769: LD_INT 1
79771: PUSH
79772: EMPTY
79773: LIST
79774: LIST
79775: PUSH
79776: LD_INT 0
79778: PUSH
79779: LD_INT 1
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: LD_INT 0
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: LD_INT 1
79799: NEG
79800: PUSH
79801: LD_INT 1
79803: NEG
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 1
79811: PUSH
79812: LD_INT 1
79814: NEG
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 2
79822: PUSH
79823: LD_INT 0
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: LD_INT 1
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 2
79853: NEG
79854: PUSH
79855: LD_INT 0
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: LD_INT 2
79864: NEG
79865: PUSH
79866: LD_INT 1
79868: NEG
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 2
79876: PUSH
79877: LD_INT 1
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 3
79887: PUSH
79888: LD_INT 0
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 3
79897: PUSH
79898: LD_INT 1
79900: PUSH
79901: EMPTY
79902: LIST
79903: LIST
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79923: LD_ADDR_VAR 0 16
79927: PUSH
79928: LD_INT 0
79930: PUSH
79931: LD_INT 0
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 1
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: LD_INT 0
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: LD_INT 1
79961: PUSH
79962: LD_INT 1
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: LD_INT 0
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 1
79981: NEG
79982: PUSH
79983: LD_INT 0
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 1
79992: NEG
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 2
80016: PUSH
80017: LD_INT 1
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 2
80026: PUSH
80027: LD_INT 2
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 1
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: PUSH
80044: LD_INT 2
80046: NEG
80047: PUSH
80048: LD_INT 1
80050: NEG
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: LD_INT 2
80062: NEG
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 3
80070: PUSH
80071: LD_INT 2
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 3
80080: PUSH
80081: LD_INT 3
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 2
80090: PUSH
80091: LD_INT 3
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80116: LD_ADDR_VAR 0 17
80120: PUSH
80121: LD_INT 0
80123: PUSH
80124: LD_INT 0
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: LD_INT 1
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 1
80144: PUSH
80145: LD_INT 0
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 1
80154: PUSH
80155: LD_INT 1
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: LD_INT 0
80164: PUSH
80165: LD_INT 1
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 1
80174: NEG
80175: PUSH
80176: LD_INT 0
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 1
80185: NEG
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 1
80197: NEG
80198: PUSH
80199: LD_INT 2
80201: NEG
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 0
80209: PUSH
80210: LD_INT 2
80212: NEG
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 1
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 2
80231: PUSH
80232: LD_INT 0
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 2
80241: PUSH
80242: LD_INT 1
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 2
80251: PUSH
80252: LD_INT 2
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 1
80261: PUSH
80262: LD_INT 2
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 0
80271: PUSH
80272: LD_INT 2
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 1
80281: NEG
80282: PUSH
80283: LD_INT 1
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 2
80303: NEG
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 2
80315: NEG
80316: PUSH
80317: LD_INT 2
80319: NEG
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: LIST
80329: LIST
80330: LIST
80331: LIST
80332: LIST
80333: LIST
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80346: LD_ADDR_VAR 0 18
80350: PUSH
80351: LD_INT 0
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 0
80363: PUSH
80364: LD_INT 1
80366: NEG
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 1
80374: PUSH
80375: LD_INT 0
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 1
80384: PUSH
80385: LD_INT 1
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: LD_INT 1
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 1
80404: NEG
80405: PUSH
80406: LD_INT 0
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 1
80427: NEG
80428: PUSH
80429: LD_INT 2
80431: NEG
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: LD_INT 2
80442: NEG
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: LD_INT 1
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 2
80461: PUSH
80462: LD_INT 0
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 2
80471: PUSH
80472: LD_INT 1
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: PUSH
80482: LD_INT 2
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 1
80491: PUSH
80492: LD_INT 2
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: LD_INT 2
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 1
80511: NEG
80512: PUSH
80513: LD_INT 1
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 2
80522: NEG
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 2
80533: NEG
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 2
80545: NEG
80546: PUSH
80547: LD_INT 2
80549: NEG
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80576: LD_ADDR_VAR 0 19
80580: PUSH
80581: LD_INT 0
80583: PUSH
80584: LD_INT 0
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 0
80624: PUSH
80625: LD_INT 1
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: NEG
80635: PUSH
80636: LD_INT 0
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 1
80645: NEG
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: LD_INT 2
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 0
80669: PUSH
80670: LD_INT 2
80672: NEG
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: LD_INT 1
80683: NEG
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 2
80691: PUSH
80692: LD_INT 0
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 2
80701: PUSH
80702: LD_INT 1
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 2
80711: PUSH
80712: LD_INT 2
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 1
80721: PUSH
80722: LD_INT 2
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: LD_INT 2
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 1
80741: NEG
80742: PUSH
80743: LD_INT 1
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 2
80752: NEG
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 2
80763: NEG
80764: PUSH
80765: LD_INT 1
80767: NEG
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 2
80775: NEG
80776: PUSH
80777: LD_INT 2
80779: NEG
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: LIST
80794: LIST
80795: LIST
80796: LIST
80797: LIST
80798: LIST
80799: LIST
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80806: LD_ADDR_VAR 0 20
80810: PUSH
80811: LD_INT 0
80813: PUSH
80814: LD_INT 0
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: LD_INT 1
80826: NEG
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 1
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 1
80844: PUSH
80845: LD_INT 1
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 0
80854: PUSH
80855: LD_INT 1
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: NEG
80865: PUSH
80866: LD_INT 0
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: NEG
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 1
80887: NEG
80888: PUSH
80889: LD_INT 2
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 0
80899: PUSH
80900: LD_INT 2
80902: NEG
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 1
80910: PUSH
80911: LD_INT 1
80913: NEG
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 2
80921: PUSH
80922: LD_INT 0
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 2
80931: PUSH
80932: LD_INT 1
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 2
80941: PUSH
80942: LD_INT 2
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: LD_INT 2
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: LD_INT 2
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 1
80971: NEG
80972: PUSH
80973: LD_INT 1
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 2
80982: NEG
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 2
80993: NEG
80994: PUSH
80995: LD_INT 1
80997: NEG
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 2
81005: NEG
81006: PUSH
81007: LD_INT 2
81009: NEG
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: LIST
81022: LIST
81023: LIST
81024: LIST
81025: LIST
81026: LIST
81027: LIST
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81036: LD_ADDR_VAR 0 21
81040: PUSH
81041: LD_INT 0
81043: PUSH
81044: LD_INT 0
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: LD_INT 1
81056: NEG
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: LD_INT 0
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 1
81074: PUSH
81075: LD_INT 1
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 0
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 1
81094: NEG
81095: PUSH
81096: LD_INT 0
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 1
81105: NEG
81106: PUSH
81107: LD_INT 1
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: LD_INT 2
81121: NEG
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 0
81129: PUSH
81130: LD_INT 2
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 1
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 2
81151: PUSH
81152: LD_INT 0
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 2
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: LD_INT 2
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 1
81181: PUSH
81182: LD_INT 2
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 0
81191: PUSH
81192: LD_INT 2
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 1
81201: NEG
81202: PUSH
81203: LD_INT 1
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 2
81212: NEG
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 2
81223: NEG
81224: PUSH
81225: LD_INT 1
81227: NEG
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 2
81235: NEG
81236: PUSH
81237: LD_INT 2
81239: NEG
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81266: LD_ADDR_VAR 0 22
81270: PUSH
81271: LD_INT 0
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 0
81283: PUSH
81284: LD_INT 1
81286: NEG
81287: PUSH
81288: EMPTY
81289: LIST
81290: LIST
81291: PUSH
81292: LD_INT 1
81294: PUSH
81295: LD_INT 0
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: LD_INT 1
81304: PUSH
81305: LD_INT 1
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 0
81314: PUSH
81315: LD_INT 1
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 1
81324: NEG
81325: PUSH
81326: LD_INT 0
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 1
81335: NEG
81336: PUSH
81337: LD_INT 1
81339: NEG
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: LD_INT 2
81351: NEG
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: LD_INT 2
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 1
81370: PUSH
81371: LD_INT 1
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: PUSH
81382: LD_INT 0
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 2
81391: PUSH
81392: LD_INT 1
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 2
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: EMPTY
81406: LIST
81407: LIST
81408: PUSH
81409: LD_INT 1
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: LD_INT 2
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 1
81431: NEG
81432: PUSH
81433: LD_INT 1
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 2
81442: NEG
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 2
81453: NEG
81454: PUSH
81455: LD_INT 1
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 2
81465: NEG
81466: PUSH
81467: LD_INT 2
81469: NEG
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81496: LD_ADDR_VAR 0 23
81500: PUSH
81501: LD_INT 0
81503: PUSH
81504: LD_INT 0
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 0
81513: PUSH
81514: LD_INT 1
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 1
81534: PUSH
81535: LD_INT 1
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: LD_INT 1
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 1
81554: NEG
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 1
81565: NEG
81566: PUSH
81567: LD_INT 1
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 2
81581: NEG
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 0
81589: PUSH
81590: LD_INT 2
81592: NEG
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 1
81600: PUSH
81601: LD_INT 1
81603: NEG
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 2
81611: PUSH
81612: LD_INT 0
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 2
81621: PUSH
81622: LD_INT 1
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 2
81631: PUSH
81632: LD_INT 2
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 1
81641: PUSH
81642: LD_INT 2
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 0
81651: PUSH
81652: LD_INT 2
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 1
81661: NEG
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 2
81672: NEG
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 2
81683: NEG
81684: PUSH
81685: LD_INT 1
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 2
81695: NEG
81696: PUSH
81697: LD_INT 2
81699: NEG
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 2
81707: NEG
81708: PUSH
81709: LD_INT 3
81711: NEG
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 1
81719: NEG
81720: PUSH
81721: LD_INT 3
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 1
81731: PUSH
81732: LD_INT 2
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 2
81742: PUSH
81743: LD_INT 1
81745: NEG
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81776: LD_ADDR_VAR 0 24
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: LD_INT 0
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 0
81793: PUSH
81794: LD_INT 1
81796: NEG
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 1
81804: PUSH
81805: LD_INT 0
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: PUSH
81815: LD_INT 1
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 0
81824: PUSH
81825: LD_INT 1
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: LD_INT 0
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: LD_INT 1
81849: NEG
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: NEG
81858: PUSH
81859: LD_INT 2
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 0
81869: PUSH
81870: LD_INT 2
81872: NEG
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 1
81880: PUSH
81881: LD_INT 1
81883: NEG
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 2
81891: PUSH
81892: LD_INT 0
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 2
81901: PUSH
81902: LD_INT 1
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 2
81911: PUSH
81912: LD_INT 2
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 1
81921: PUSH
81922: LD_INT 2
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_INT 0
81931: PUSH
81932: LD_INT 2
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 1
81941: NEG
81942: PUSH
81943: LD_INT 1
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 2
81952: NEG
81953: PUSH
81954: LD_INT 0
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: LD_INT 1
81967: NEG
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 2
81975: NEG
81976: PUSH
81977: LD_INT 2
81979: NEG
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 1
81987: PUSH
81988: LD_INT 2
81990: NEG
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 2
81998: PUSH
81999: LD_INT 1
82001: NEG
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 3
82009: PUSH
82010: LD_INT 1
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 3
82019: PUSH
82020: LD_INT 2
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82052: LD_ADDR_VAR 0 25
82056: PUSH
82057: LD_INT 0
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 0
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 1
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 1
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 0
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 1
82110: NEG
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: LD_INT 1
82125: NEG
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 2
82137: NEG
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 0
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 2
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 2
82187: PUSH
82188: LD_INT 2
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: PUSH
82198: LD_INT 2
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 0
82207: PUSH
82208: LD_INT 2
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 1
82217: NEG
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 2
82228: NEG
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 2
82239: NEG
82240: PUSH
82241: LD_INT 1
82243: NEG
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 2
82251: NEG
82252: PUSH
82253: LD_INT 2
82255: NEG
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 3
82263: PUSH
82264: LD_INT 1
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 3
82273: PUSH
82274: LD_INT 2
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 2
82283: PUSH
82284: LD_INT 3
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 1
82293: PUSH
82294: LD_INT 3
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82326: LD_ADDR_VAR 0 26
82330: PUSH
82331: LD_INT 0
82333: PUSH
82334: LD_INT 0
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: LD_INT 1
82346: NEG
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: LD_INT 0
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 1
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 0
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: LD_INT 0
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 1
82395: NEG
82396: PUSH
82397: LD_INT 1
82399: NEG
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 1
82407: NEG
82408: PUSH
82409: LD_INT 2
82411: NEG
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 0
82419: PUSH
82420: LD_INT 2
82422: NEG
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 1
82430: PUSH
82431: LD_INT 1
82433: NEG
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 2
82441: PUSH
82442: LD_INT 0
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: LD_INT 2
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 1
82471: PUSH
82472: LD_INT 2
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 0
82481: PUSH
82482: LD_INT 2
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 2
82502: NEG
82503: PUSH
82504: LD_INT 0
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: LD_INT 1
82517: NEG
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 2
82525: NEG
82526: PUSH
82527: LD_INT 2
82529: NEG
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 2
82537: PUSH
82538: LD_INT 3
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 1
82547: PUSH
82548: LD_INT 3
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: LD_INT 2
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 2
82568: NEG
82569: PUSH
82570: LD_INT 1
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82602: LD_ADDR_VAR 0 27
82606: PUSH
82607: LD_INT 0
82609: PUSH
82610: LD_INT 0
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: LD_INT 1
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 1
82630: PUSH
82631: LD_INT 0
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: PUSH
82641: LD_INT 1
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 0
82650: PUSH
82651: LD_INT 1
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 1
82660: NEG
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 1
82671: NEG
82672: PUSH
82673: LD_INT 1
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 1
82683: NEG
82684: PUSH
82685: LD_INT 2
82687: NEG
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: LD_INT 2
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 1
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 2
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 2
82727: PUSH
82728: LD_INT 1
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 2
82737: PUSH
82738: LD_INT 2
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: LD_INT 2
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: LD_INT 2
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 1
82767: NEG
82768: PUSH
82769: LD_INT 1
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 2
82778: NEG
82779: PUSH
82780: LD_INT 0
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 2
82789: NEG
82790: PUSH
82791: LD_INT 1
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 2
82801: NEG
82802: PUSH
82803: LD_INT 2
82805: NEG
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: LD_INT 2
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 2
82824: NEG
82825: PUSH
82826: LD_INT 1
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 3
82835: NEG
82836: PUSH
82837: LD_INT 1
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 3
82847: NEG
82848: PUSH
82849: LD_INT 2
82851: NEG
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82882: LD_ADDR_VAR 0 28
82886: PUSH
82887: LD_INT 0
82889: PUSH
82890: LD_INT 0
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 0
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: PUSH
82911: LD_INT 0
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 1
82920: PUSH
82921: LD_INT 1
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 0
82930: PUSH
82931: LD_INT 1
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 1
82940: NEG
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 1
82951: NEG
82952: PUSH
82953: LD_INT 1
82955: NEG
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 1
82963: NEG
82964: PUSH
82965: LD_INT 2
82967: NEG
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 0
82975: PUSH
82976: LD_INT 2
82978: NEG
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 1
82986: PUSH
82987: LD_INT 1
82989: NEG
82990: PUSH
82991: EMPTY
82992: LIST
82993: LIST
82994: PUSH
82995: LD_INT 2
82997: PUSH
82998: LD_INT 0
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 2
83007: PUSH
83008: LD_INT 1
83010: PUSH
83011: EMPTY
83012: LIST
83013: LIST
83014: PUSH
83015: LD_INT 2
83017: PUSH
83018: LD_INT 2
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 2
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 0
83037: PUSH
83038: LD_INT 2
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: NEG
83048: PUSH
83049: LD_INT 1
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 2
83058: NEG
83059: PUSH
83060: LD_INT 0
83062: PUSH
83063: EMPTY
83064: LIST
83065: LIST
83066: PUSH
83067: LD_INT 2
83069: NEG
83070: PUSH
83071: LD_INT 1
83073: NEG
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 2
83081: NEG
83082: PUSH
83083: LD_INT 2
83085: NEG
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: PUSH
83091: LD_INT 2
83093: NEG
83094: PUSH
83095: LD_INT 3
83097: NEG
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PUSH
83103: LD_INT 1
83105: NEG
83106: PUSH
83107: LD_INT 3
83109: NEG
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 3
83117: NEG
83118: PUSH
83119: LD_INT 1
83121: NEG
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 3
83129: NEG
83130: PUSH
83131: LD_INT 2
83133: NEG
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83164: LD_ADDR_VAR 0 29
83168: PUSH
83169: LD_INT 0
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 0
83181: PUSH
83182: LD_INT 1
83184: NEG
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: LD_INT 1
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: NEG
83223: PUSH
83224: LD_INT 0
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 1
83233: NEG
83234: PUSH
83235: LD_INT 1
83237: NEG
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 1
83245: NEG
83246: PUSH
83247: LD_INT 2
83249: NEG
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 0
83257: PUSH
83258: LD_INT 2
83260: NEG
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 1
83268: PUSH
83269: LD_INT 1
83271: NEG
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: LD_INT 1
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 1
83299: PUSH
83300: LD_INT 2
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 0
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 1
83319: NEG
83320: PUSH
83321: LD_INT 1
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 2
83330: NEG
83331: PUSH
83332: LD_INT 1
83334: NEG
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 2
83342: NEG
83343: PUSH
83344: LD_INT 2
83346: NEG
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 2
83354: NEG
83355: PUSH
83356: LD_INT 3
83358: NEG
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 2
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 3
83377: PUSH
83378: LD_INT 1
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: LD_INT 3
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 1
83397: NEG
83398: PUSH
83399: LD_INT 2
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 3
83408: NEG
83409: PUSH
83410: LD_INT 2
83412: NEG
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83443: LD_ADDR_VAR 0 30
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: LD_INT 0
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: LD_INT 1
83463: NEG
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 1
83471: PUSH
83472: LD_INT 0
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 1
83481: PUSH
83482: LD_INT 1
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 0
83491: PUSH
83492: LD_INT 1
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 1
83512: NEG
83513: PUSH
83514: LD_INT 1
83516: NEG
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 1
83524: NEG
83525: PUSH
83526: LD_INT 2
83528: NEG
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 0
83536: PUSH
83537: LD_INT 2
83539: NEG
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 1
83547: PUSH
83548: LD_INT 1
83550: NEG
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 2
83558: PUSH
83559: LD_INT 0
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 2
83568: PUSH
83569: LD_INT 1
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: LD_INT 2
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 1
83588: PUSH
83589: LD_INT 2
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 1
83598: NEG
83599: PUSH
83600: LD_INT 1
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_INT 2
83609: NEG
83610: PUSH
83611: LD_INT 0
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 2
83620: NEG
83621: PUSH
83622: LD_INT 1
83624: NEG
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 1
83632: NEG
83633: PUSH
83634: LD_INT 3
83636: NEG
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: LD_INT 2
83647: NEG
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 3
83655: PUSH
83656: LD_INT 2
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 2
83665: PUSH
83666: LD_INT 3
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 3
83686: NEG
83687: PUSH
83688: LD_INT 1
83690: NEG
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83721: LD_ADDR_VAR 0 31
83725: PUSH
83726: LD_INT 0
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 0
83738: PUSH
83739: LD_INT 1
83741: NEG
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 1
83749: PUSH
83750: LD_INT 0
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: PUSH
83757: LD_INT 1
83759: PUSH
83760: LD_INT 1
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 0
83769: PUSH
83770: LD_INT 1
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 1
83779: NEG
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 1
83790: NEG
83791: PUSH
83792: LD_INT 1
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 1
83802: NEG
83803: PUSH
83804: LD_INT 2
83806: NEG
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: LD_INT 1
83817: NEG
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 2
83825: PUSH
83826: LD_INT 0
83828: PUSH
83829: EMPTY
83830: LIST
83831: LIST
83832: PUSH
83833: LD_INT 2
83835: PUSH
83836: LD_INT 1
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: PUSH
83846: LD_INT 2
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 1
83855: PUSH
83856: LD_INT 2
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 0
83865: PUSH
83866: LD_INT 2
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: NEG
83876: PUSH
83877: LD_INT 1
83879: PUSH
83880: EMPTY
83881: LIST
83882: LIST
83883: PUSH
83884: LD_INT 2
83886: NEG
83887: PUSH
83888: LD_INT 1
83890: NEG
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 2
83898: NEG
83899: PUSH
83900: LD_INT 2
83902: NEG
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 2
83910: NEG
83911: PUSH
83912: LD_INT 3
83914: NEG
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: PUSH
83920: LD_INT 2
83922: PUSH
83923: LD_INT 1
83925: NEG
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 3
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 1
83943: PUSH
83944: LD_INT 3
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: NEG
83954: PUSH
83955: LD_INT 2
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 3
83964: NEG
83965: PUSH
83966: LD_INT 2
83968: NEG
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83999: LD_ADDR_VAR 0 32
84003: PUSH
84004: LD_INT 0
84006: PUSH
84007: LD_INT 0
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 0
84016: PUSH
84017: LD_INT 1
84019: NEG
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 1
84027: PUSH
84028: LD_INT 0
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 1
84037: PUSH
84038: LD_INT 1
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 0
84047: PUSH
84048: LD_INT 1
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 1
84068: NEG
84069: PUSH
84070: LD_INT 1
84072: NEG
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 1
84080: NEG
84081: PUSH
84082: LD_INT 2
84084: NEG
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 0
84092: PUSH
84093: LD_INT 2
84095: NEG
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 1
84103: PUSH
84104: LD_INT 1
84106: NEG
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 2
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 2
84124: PUSH
84125: LD_INT 2
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: LD_INT 2
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 0
84144: PUSH
84145: LD_INT 2
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: LD_INT 1
84154: NEG
84155: PUSH
84156: LD_INT 1
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 2
84165: NEG
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 2
84176: NEG
84177: PUSH
84178: LD_INT 1
84180: NEG
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 1
84188: NEG
84189: PUSH
84190: LD_INT 3
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 2
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 3
84211: PUSH
84212: LD_INT 2
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: LD_INT 3
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 2
84231: NEG
84232: PUSH
84233: LD_INT 1
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 3
84242: NEG
84243: PUSH
84244: LD_INT 1
84246: NEG
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: LIST
84256: LIST
84257: LIST
84258: LIST
84259: LIST
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: LIST
84266: LIST
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84277: LD_ADDR_VAR 0 33
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 0
84294: PUSH
84295: LD_INT 1
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: PUSH
84306: LD_INT 0
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: PUSH
84313: LD_INT 1
84315: PUSH
84316: LD_INT 1
84318: PUSH
84319: EMPTY
84320: LIST
84321: LIST
84322: PUSH
84323: LD_INT 0
84325: PUSH
84326: LD_INT 1
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 1
84335: NEG
84336: PUSH
84337: LD_INT 0
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: LD_INT 1
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 1
84358: NEG
84359: PUSH
84360: LD_INT 2
84362: NEG
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 1
84370: PUSH
84371: LD_INT 1
84373: NEG
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 2
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: LD_INT 1
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 1
84401: PUSH
84402: LD_INT 2
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 0
84411: PUSH
84412: LD_INT 2
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 2
84432: NEG
84433: PUSH
84434: LD_INT 0
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 2
84443: NEG
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 2
84455: NEG
84456: PUSH
84457: LD_INT 2
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 3
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 3
84490: PUSH
84491: LD_INT 1
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: PUSH
84498: LD_INT 1
84500: PUSH
84501: LD_INT 3
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: LD_INT 1
84510: NEG
84511: PUSH
84512: LD_INT 2
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 3
84521: NEG
84522: PUSH
84523: LD_INT 2
84525: NEG
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84556: LD_ADDR_VAR 0 34
84560: PUSH
84561: LD_INT 0
84563: PUSH
84564: LD_INT 0
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 0
84573: PUSH
84574: LD_INT 1
84576: NEG
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 1
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 0
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: NEG
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 1
84625: NEG
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: PUSH
84635: LD_INT 1
84637: NEG
84638: PUSH
84639: LD_INT 2
84641: NEG
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 0
84649: PUSH
84650: LD_INT 2
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 1
84660: PUSH
84661: LD_INT 1
84663: NEG
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 2
84671: PUSH
84672: LD_INT 1
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 2
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: PUSH
84692: LD_INT 2
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 1
84701: NEG
84702: PUSH
84703: LD_INT 1
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 2
84712: NEG
84713: PUSH
84714: LD_INT 0
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 1
84727: NEG
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: LD_INT 2
84735: NEG
84736: PUSH
84737: LD_INT 2
84739: NEG
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PUSH
84745: LD_INT 1
84747: NEG
84748: PUSH
84749: LD_INT 3
84751: NEG
84752: PUSH
84753: EMPTY
84754: LIST
84755: LIST
84756: PUSH
84757: LD_INT 1
84759: PUSH
84760: LD_INT 2
84762: NEG
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 3
84770: PUSH
84771: LD_INT 2
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: PUSH
84778: LD_INT 2
84780: PUSH
84781: LD_INT 3
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 2
84790: NEG
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 3
84801: NEG
84802: PUSH
84803: LD_INT 1
84805: NEG
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: LIST
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84836: LD_ADDR_VAR 0 35
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 0
84853: PUSH
84854: LD_INT 1
84856: NEG
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: PUSH
84862: LD_INT 1
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: PUSH
84872: LD_INT 1
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 0
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: NEG
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 1
84905: NEG
84906: PUSH
84907: LD_INT 1
84909: NEG
84910: PUSH
84911: EMPTY
84912: LIST
84913: LIST
84914: PUSH
84915: LD_INT 2
84917: PUSH
84918: LD_INT 1
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 2
84927: NEG
84928: PUSH
84929: LD_INT 1
84931: NEG
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84948: LD_ADDR_VAR 0 36
84952: PUSH
84953: LD_INT 0
84955: PUSH
84956: LD_INT 0
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: PUSH
84963: LD_INT 0
84965: PUSH
84966: LD_INT 1
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 1
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 1
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: LD_INT 0
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: PUSH
85004: LD_INT 1
85006: NEG
85007: PUSH
85008: LD_INT 0
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 1
85017: NEG
85018: PUSH
85019: LD_INT 1
85021: NEG
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 1
85029: NEG
85030: PUSH
85031: LD_INT 2
85033: NEG
85034: PUSH
85035: EMPTY
85036: LIST
85037: LIST
85038: PUSH
85039: LD_INT 1
85041: PUSH
85042: LD_INT 2
85044: PUSH
85045: EMPTY
85046: LIST
85047: LIST
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85060: LD_ADDR_VAR 0 37
85064: PUSH
85065: LD_INT 0
85067: PUSH
85068: LD_INT 0
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: LD_INT 1
85080: NEG
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 1
85088: PUSH
85089: LD_INT 0
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 1
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 0
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: EMPTY
85113: LIST
85114: LIST
85115: PUSH
85116: LD_INT 1
85118: NEG
85119: PUSH
85120: LD_INT 0
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 1
85129: NEG
85130: PUSH
85131: LD_INT 1
85133: NEG
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 1
85141: PUSH
85142: LD_INT 1
85144: NEG
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 1
85152: NEG
85153: PUSH
85154: LD_INT 1
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: LIST
85168: LIST
85169: LIST
85170: LIST
85171: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85172: LD_ADDR_VAR 0 38
85176: PUSH
85177: LD_INT 0
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 0
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 1
85200: PUSH
85201: LD_INT 0
85203: PUSH
85204: EMPTY
85205: LIST
85206: LIST
85207: PUSH
85208: LD_INT 1
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 0
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: NEG
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: LD_INT 1
85245: NEG
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 2
85253: PUSH
85254: LD_INT 1
85256: PUSH
85257: EMPTY
85258: LIST
85259: LIST
85260: PUSH
85261: LD_INT 2
85263: NEG
85264: PUSH
85265: LD_INT 1
85267: NEG
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85284: LD_ADDR_VAR 0 39
85288: PUSH
85289: LD_INT 0
85291: PUSH
85292: LD_INT 0
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 0
85301: PUSH
85302: LD_INT 1
85304: NEG
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 1
85312: PUSH
85313: LD_INT 0
85315: PUSH
85316: EMPTY
85317: LIST
85318: LIST
85319: PUSH
85320: LD_INT 1
85322: PUSH
85323: LD_INT 1
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 0
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: NEG
85343: PUSH
85344: LD_INT 0
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 1
85353: NEG
85354: PUSH
85355: LD_INT 1
85357: NEG
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 1
85365: NEG
85366: PUSH
85367: LD_INT 2
85369: NEG
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 1
85377: PUSH
85378: LD_INT 2
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85396: LD_ADDR_VAR 0 40
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: LD_INT 0
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 0
85413: PUSH
85414: LD_INT 1
85416: NEG
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 1
85424: PUSH
85425: LD_INT 0
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 1
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 0
85444: PUSH
85445: LD_INT 1
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 1
85454: NEG
85455: PUSH
85456: LD_INT 0
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 1
85465: NEG
85466: PUSH
85467: LD_INT 1
85469: NEG
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: PUSH
85475: LD_INT 1
85477: PUSH
85478: LD_INT 1
85480: NEG
85481: PUSH
85482: EMPTY
85483: LIST
85484: LIST
85485: PUSH
85486: LD_INT 1
85488: NEG
85489: PUSH
85490: LD_INT 1
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: EMPTY
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85508: LD_ADDR_VAR 0 41
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: LD_INT 0
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 0
85525: PUSH
85526: LD_INT 1
85528: NEG
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: LD_INT 1
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 0
85556: PUSH
85557: LD_INT 1
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 1
85566: NEG
85567: PUSH
85568: LD_INT 0
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 1
85577: NEG
85578: PUSH
85579: LD_INT 1
85581: NEG
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 1
85589: NEG
85590: PUSH
85591: LD_INT 2
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 1
85601: PUSH
85602: LD_INT 1
85604: NEG
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 2
85612: PUSH
85613: LD_INT 0
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: LD_INT 1
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: LD_INT 2
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: LD_INT 2
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 1
85652: NEG
85653: PUSH
85654: LD_INT 1
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: PUSH
85661: LD_INT 2
85663: NEG
85664: PUSH
85665: LD_INT 0
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PUSH
85672: LD_INT 2
85674: NEG
85675: PUSH
85676: LD_INT 1
85678: NEG
85679: PUSH
85680: EMPTY
85681: LIST
85682: LIST
85683: PUSH
85684: LD_INT 2
85686: NEG
85687: PUSH
85688: LD_INT 2
85690: NEG
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 2
85698: NEG
85699: PUSH
85700: LD_INT 3
85702: NEG
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 2
85710: PUSH
85711: LD_INT 1
85713: NEG
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 3
85721: PUSH
85722: LD_INT 0
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 3
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 3
85741: PUSH
85742: LD_INT 2
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 3
85751: PUSH
85752: LD_INT 3
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 2
85761: PUSH
85762: LD_INT 3
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 2
85771: NEG
85772: PUSH
85773: LD_INT 1
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PUSH
85780: LD_INT 3
85782: NEG
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 3
85793: NEG
85794: PUSH
85795: LD_INT 1
85797: NEG
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 3
85805: NEG
85806: PUSH
85807: LD_INT 2
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 3
85817: NEG
85818: PUSH
85819: LD_INT 3
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: LIST
85852: LIST
85853: LIST
85854: LIST
85855: LIST
85856: LIST
85857: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85858: LD_ADDR_VAR 0 42
85862: PUSH
85863: LD_INT 0
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: LD_INT 1
85878: NEG
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 1
85886: PUSH
85887: LD_INT 0
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 1
85896: PUSH
85897: LD_INT 1
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 0
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: LD_INT 1
85927: NEG
85928: PUSH
85929: LD_INT 1
85931: NEG
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 1
85939: NEG
85940: PUSH
85941: LD_INT 2
85943: NEG
85944: PUSH
85945: EMPTY
85946: LIST
85947: LIST
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: LD_INT 2
85954: NEG
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 1
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 2
85973: PUSH
85974: LD_INT 1
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 2
85983: PUSH
85984: LD_INT 2
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: LD_INT 2
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: LD_INT 2
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 1
86013: NEG
86014: PUSH
86015: LD_INT 1
86017: PUSH
86018: EMPTY
86019: LIST
86020: LIST
86021: PUSH
86022: LD_INT 2
86024: NEG
86025: PUSH
86026: LD_INT 1
86028: NEG
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: LD_INT 2
86036: NEG
86037: PUSH
86038: LD_INT 2
86040: NEG
86041: PUSH
86042: EMPTY
86043: LIST
86044: LIST
86045: PUSH
86046: LD_INT 2
86048: NEG
86049: PUSH
86050: LD_INT 3
86052: NEG
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: NEG
86061: PUSH
86062: LD_INT 3
86064: NEG
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 0
86072: PUSH
86073: LD_INT 3
86075: NEG
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 1
86083: PUSH
86084: LD_INT 2
86086: NEG
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 3
86094: PUSH
86095: LD_INT 2
86097: PUSH
86098: EMPTY
86099: LIST
86100: LIST
86101: PUSH
86102: LD_INT 3
86104: PUSH
86105: LD_INT 3
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 2
86114: PUSH
86115: LD_INT 3
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 1
86124: PUSH
86125: LD_INT 3
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: LD_INT 0
86134: PUSH
86135: LD_INT 3
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 1
86144: NEG
86145: PUSH
86146: LD_INT 2
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 3
86155: NEG
86156: PUSH
86157: LD_INT 2
86159: NEG
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 3
86167: NEG
86168: PUSH
86169: LD_INT 3
86171: NEG
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: LIST
86195: LIST
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86208: LD_ADDR_VAR 0 43
86212: PUSH
86213: LD_INT 0
86215: PUSH
86216: LD_INT 0
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 0
86225: PUSH
86226: LD_INT 1
86228: NEG
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: PUSH
86237: LD_INT 0
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: PUSH
86244: LD_INT 1
86246: PUSH
86247: LD_INT 1
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 1
86266: NEG
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 1
86277: NEG
86278: PUSH
86279: LD_INT 1
86281: NEG
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: LD_INT 2
86293: NEG
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 2
86304: NEG
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 1
86312: PUSH
86313: LD_INT 1
86315: NEG
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 2
86333: PUSH
86334: LD_INT 1
86336: PUSH
86337: EMPTY
86338: LIST
86339: LIST
86340: PUSH
86341: LD_INT 1
86343: PUSH
86344: LD_INT 2
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_INT 0
86353: PUSH
86354: LD_INT 2
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: LD_INT 1
86363: NEG
86364: PUSH
86365: LD_INT 1
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 2
86374: NEG
86375: PUSH
86376: LD_INT 0
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 2
86385: NEG
86386: PUSH
86387: LD_INT 1
86389: NEG
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 3
86401: NEG
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: PUSH
86407: LD_INT 0
86409: PUSH
86410: LD_INT 3
86412: NEG
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 2
86431: PUSH
86432: LD_INT 1
86434: NEG
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 3
86442: PUSH
86443: LD_INT 0
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 3
86452: PUSH
86453: LD_INT 1
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: LD_INT 3
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 0
86472: PUSH
86473: LD_INT 3
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 1
86482: NEG
86483: PUSH
86484: LD_INT 2
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 2
86493: NEG
86494: PUSH
86495: LD_INT 1
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 3
86504: NEG
86505: PUSH
86506: LD_INT 0
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 3
86515: NEG
86516: PUSH
86517: LD_INT 1
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: LIST
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: LIST
86554: LIST
86555: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86556: LD_ADDR_VAR 0 44
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: LD_INT 0
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 0
86573: PUSH
86574: LD_INT 1
86576: NEG
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 1
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 1
86594: PUSH
86595: LD_INT 1
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: LD_INT 1
86607: PUSH
86608: EMPTY
86609: LIST
86610: LIST
86611: PUSH
86612: LD_INT 1
86614: NEG
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 1
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 1
86637: NEG
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 1
86649: PUSH
86650: LD_INT 1
86652: NEG
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 2
86660: PUSH
86661: LD_INT 0
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: PUSH
86668: LD_INT 2
86670: PUSH
86671: LD_INT 1
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 2
86680: PUSH
86681: LD_INT 2
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 1
86690: PUSH
86691: LD_INT 2
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 1
86700: NEG
86701: PUSH
86702: LD_INT 1
86704: PUSH
86705: EMPTY
86706: LIST
86707: LIST
86708: PUSH
86709: LD_INT 2
86711: NEG
86712: PUSH
86713: LD_INT 0
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: LD_INT 2
86722: NEG
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 2
86734: NEG
86735: PUSH
86736: LD_INT 2
86738: NEG
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 2
86746: NEG
86747: PUSH
86748: LD_INT 3
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 2
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 3
86769: PUSH
86770: LD_INT 0
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 3
86779: PUSH
86780: LD_INT 1
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 3
86789: PUSH
86790: LD_INT 2
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 3
86799: PUSH
86800: LD_INT 3
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 2
86809: PUSH
86810: LD_INT 3
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: NEG
86820: PUSH
86821: LD_INT 1
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 3
86830: NEG
86831: PUSH
86832: LD_INT 0
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 3
86841: NEG
86842: PUSH
86843: LD_INT 1
86845: NEG
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 3
86853: NEG
86854: PUSH
86855: LD_INT 2
86857: NEG
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 3
86865: NEG
86866: PUSH
86867: LD_INT 3
86869: NEG
86870: PUSH
86871: EMPTY
86872: LIST
86873: LIST
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: LIST
86903: LIST
86904: LIST
86905: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86906: LD_ADDR_VAR 0 45
86910: PUSH
86911: LD_INT 0
86913: PUSH
86914: LD_INT 0
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: LD_INT 1
86926: NEG
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 1
86934: PUSH
86935: LD_INT 0
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: PUSH
86945: LD_INT 1
86947: PUSH
86948: EMPTY
86949: LIST
86950: LIST
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: LD_INT 1
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: LD_INT 0
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: LD_INT 1
86975: NEG
86976: PUSH
86977: LD_INT 1
86979: NEG
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 0
86999: PUSH
87000: LD_INT 2
87002: NEG
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 1
87010: PUSH
87011: LD_INT 1
87013: NEG
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 2
87021: PUSH
87022: LD_INT 1
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 2
87031: PUSH
87032: LD_INT 2
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 1
87041: PUSH
87042: LD_INT 2
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: LD_INT 2
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: NEG
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 2
87072: NEG
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 2
87084: NEG
87085: PUSH
87086: LD_INT 2
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 2
87096: NEG
87097: PUSH
87098: LD_INT 3
87100: NEG
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: LD_INT 1
87108: NEG
87109: PUSH
87110: LD_INT 3
87112: NEG
87113: PUSH
87114: EMPTY
87115: LIST
87116: LIST
87117: PUSH
87118: LD_INT 0
87120: PUSH
87121: LD_INT 3
87123: NEG
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 1
87131: PUSH
87132: LD_INT 2
87134: NEG
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 3
87142: PUSH
87143: LD_INT 2
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 3
87152: PUSH
87153: LD_INT 3
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 2
87162: PUSH
87163: LD_INT 3
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: PUSH
87173: LD_INT 3
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 0
87182: PUSH
87183: LD_INT 3
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 1
87192: NEG
87193: PUSH
87194: LD_INT 2
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 3
87203: NEG
87204: PUSH
87205: LD_INT 2
87207: NEG
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 3
87215: NEG
87216: PUSH
87217: LD_INT 3
87219: NEG
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: LIST
87231: LIST
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87256: LD_ADDR_VAR 0 46
87260: PUSH
87261: LD_INT 0
87263: PUSH
87264: LD_INT 0
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: LD_INT 1
87276: NEG
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 1
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 1
87294: PUSH
87295: LD_INT 1
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: LD_INT 1
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 1
87314: NEG
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: PUSH
87323: LD_INT 1
87325: NEG
87326: PUSH
87327: LD_INT 1
87329: NEG
87330: PUSH
87331: EMPTY
87332: LIST
87333: LIST
87334: PUSH
87335: LD_INT 1
87337: NEG
87338: PUSH
87339: LD_INT 2
87341: NEG
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: LD_INT 2
87352: NEG
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 1
87360: PUSH
87361: LD_INT 1
87363: NEG
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 2
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: EMPTY
87376: LIST
87377: LIST
87378: PUSH
87379: LD_INT 2
87381: PUSH
87382: LD_INT 1
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: PUSH
87392: LD_INT 2
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 0
87401: PUSH
87402: LD_INT 2
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 1
87411: NEG
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 2
87422: NEG
87423: PUSH
87424: LD_INT 0
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 2
87433: NEG
87434: PUSH
87435: LD_INT 1
87437: NEG
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 1
87445: NEG
87446: PUSH
87447: LD_INT 3
87449: NEG
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 0
87457: PUSH
87458: LD_INT 3
87460: NEG
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 1
87468: PUSH
87469: LD_INT 2
87471: NEG
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: LD_INT 2
87479: PUSH
87480: LD_INT 1
87482: NEG
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PUSH
87488: LD_INT 3
87490: PUSH
87491: LD_INT 0
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 3
87500: PUSH
87501: LD_INT 1
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 1
87510: PUSH
87511: LD_INT 3
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 0
87520: PUSH
87521: LD_INT 3
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: NEG
87531: PUSH
87532: LD_INT 2
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: NEG
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 3
87552: NEG
87553: PUSH
87554: LD_INT 0
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 3
87563: NEG
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87604: LD_ADDR_VAR 0 47
87608: PUSH
87609: LD_INT 0
87611: PUSH
87612: LD_INT 0
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 0
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 0
87652: PUSH
87653: LD_INT 1
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 1
87662: NEG
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 1
87673: NEG
87674: PUSH
87675: LD_INT 1
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 1
87685: NEG
87686: PUSH
87687: LD_INT 2
87689: NEG
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: LD_INT 2
87700: NEG
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 1
87708: PUSH
87709: LD_INT 1
87711: NEG
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: PUSH
87717: LD_INT 2
87719: NEG
87720: PUSH
87721: LD_INT 1
87723: NEG
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 2
87731: NEG
87732: PUSH
87733: LD_INT 2
87735: NEG
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87755: LD_ADDR_VAR 0 48
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: LD_INT 0
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: LD_INT 1
87775: NEG
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 1
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: LD_INT 0
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: NEG
87837: PUSH
87838: LD_INT 2
87840: NEG
87841: PUSH
87842: EMPTY
87843: LIST
87844: LIST
87845: PUSH
87846: LD_INT 0
87848: PUSH
87849: LD_INT 2
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: LD_INT 1
87862: NEG
87863: PUSH
87864: EMPTY
87865: LIST
87866: LIST
87867: PUSH
87868: LD_INT 2
87870: PUSH
87871: LD_INT 0
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 2
87880: PUSH
87881: LD_INT 1
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: LIST
87892: LIST
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87902: LD_ADDR_VAR 0 49
87906: PUSH
87907: LD_INT 0
87909: PUSH
87910: LD_INT 0
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 0
87919: PUSH
87920: LD_INT 1
87922: NEG
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: PUSH
87928: LD_INT 1
87930: PUSH
87931: LD_INT 0
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 1
87940: PUSH
87941: LD_INT 1
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 0
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: NEG
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 1
87971: NEG
87972: PUSH
87973: LD_INT 1
87975: NEG
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 1
87983: PUSH
87984: LD_INT 1
87986: NEG
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: LD_INT 0
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 2
88004: PUSH
88005: LD_INT 1
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: LD_INT 2
88014: PUSH
88015: LD_INT 2
88017: PUSH
88018: EMPTY
88019: LIST
88020: LIST
88021: PUSH
88022: LD_INT 1
88024: PUSH
88025: LD_INT 2
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88046: LD_ADDR_VAR 0 50
88050: PUSH
88051: LD_INT 0
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 0
88063: PUSH
88064: LD_INT 1
88066: NEG
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 1
88074: PUSH
88075: LD_INT 0
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: PUSH
88085: LD_INT 1
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: PUSH
88092: LD_INT 0
88094: PUSH
88095: LD_INT 1
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 1
88104: NEG
88105: PUSH
88106: LD_INT 0
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: LD_INT 1
88119: NEG
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 2
88127: PUSH
88128: LD_INT 1
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 2
88137: PUSH
88138: LD_INT 2
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 1
88147: PUSH
88148: LD_INT 2
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: LD_INT 2
88160: PUSH
88161: EMPTY
88162: LIST
88163: LIST
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88190: LD_ADDR_VAR 0 51
88194: PUSH
88195: LD_INT 0
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 0
88207: PUSH
88208: LD_INT 1
88210: NEG
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 1
88228: PUSH
88229: LD_INT 1
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 0
88238: PUSH
88239: LD_INT 1
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 1
88248: NEG
88249: PUSH
88250: LD_INT 0
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: LD_INT 1
88263: NEG
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: LD_INT 2
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 0
88281: PUSH
88282: LD_INT 2
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 1
88291: NEG
88292: PUSH
88293: LD_INT 1
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 2
88302: NEG
88303: PUSH
88304: LD_INT 0
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 2
88313: NEG
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88337: LD_ADDR_VAR 0 52
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 0
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: LD_INT 1
88357: NEG
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 1
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 1
88375: PUSH
88376: LD_INT 1
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 0
88385: PUSH
88386: LD_INT 1
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: LD_INT 1
88395: NEG
88396: PUSH
88397: LD_INT 0
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: LD_INT 1
88418: NEG
88419: PUSH
88420: LD_INT 2
88422: NEG
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 1
88430: NEG
88431: PUSH
88432: LD_INT 1
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 2
88441: NEG
88442: PUSH
88443: LD_INT 0
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: PUSH
88450: LD_INT 2
88452: NEG
88453: PUSH
88454: LD_INT 1
88456: NEG
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: LD_INT 2
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88488: LD_ADDR_VAR 0 53
88492: PUSH
88493: LD_INT 0
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: LD_INT 1
88508: NEG
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 1
88516: PUSH
88517: LD_INT 0
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 1
88526: PUSH
88527: LD_INT 1
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: LD_INT 1
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 1
88546: NEG
88547: PUSH
88548: LD_INT 0
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: PUSH
88555: LD_INT 1
88557: NEG
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 1
88569: NEG
88570: PUSH
88571: LD_INT 2
88573: NEG
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 0
88581: PUSH
88582: LD_INT 2
88584: NEG
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 1
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 2
88603: PUSH
88604: LD_INT 0
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 2
88613: PUSH
88614: LD_INT 1
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 2
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: LD_INT 2
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 1
88653: NEG
88654: PUSH
88655: LD_INT 1
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 2
88664: NEG
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 2
88675: NEG
88676: PUSH
88677: LD_INT 1
88679: NEG
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: LD_INT 2
88687: NEG
88688: PUSH
88689: LD_INT 2
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: EMPTY
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88718: LD_ADDR_VAR 0 54
88722: PUSH
88723: LD_INT 0
88725: PUSH
88726: LD_INT 0
88728: PUSH
88729: EMPTY
88730: LIST
88731: LIST
88732: PUSH
88733: LD_INT 0
88735: PUSH
88736: LD_INT 1
88738: NEG
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 1
88746: PUSH
88747: LD_INT 0
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: LD_INT 1
88759: PUSH
88760: EMPTY
88761: LIST
88762: LIST
88763: PUSH
88764: LD_INT 0
88766: PUSH
88767: LD_INT 1
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 1
88776: NEG
88777: PUSH
88778: LD_INT 0
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 1
88787: NEG
88788: PUSH
88789: LD_INT 1
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 1
88799: NEG
88800: PUSH
88801: LD_INT 2
88803: NEG
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 0
88811: PUSH
88812: LD_INT 2
88814: NEG
88815: PUSH
88816: EMPTY
88817: LIST
88818: LIST
88819: PUSH
88820: LD_INT 1
88822: PUSH
88823: LD_INT 1
88825: NEG
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: LD_INT 2
88833: PUSH
88834: LD_INT 0
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: LD_INT 2
88843: PUSH
88844: LD_INT 1
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: PUSH
88851: LD_INT 2
88853: PUSH
88854: LD_INT 2
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 1
88863: PUSH
88864: LD_INT 2
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 0
88873: PUSH
88874: LD_INT 2
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: NEG
88884: PUSH
88885: LD_INT 1
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 2
88894: NEG
88895: PUSH
88896: LD_INT 0
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 2
88905: NEG
88906: PUSH
88907: LD_INT 1
88909: NEG
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 2
88917: NEG
88918: PUSH
88919: LD_INT 2
88921: NEG
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88948: LD_ADDR_VAR 0 55
88952: PUSH
88953: LD_INT 0
88955: PUSH
88956: LD_INT 0
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: PUSH
88963: LD_INT 0
88965: PUSH
88966: LD_INT 1
88968: NEG
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 1
88976: PUSH
88977: LD_INT 0
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 1
88986: PUSH
88987: LD_INT 1
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: LD_INT 1
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 1
89006: NEG
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: NEG
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 1
89029: NEG
89030: PUSH
89031: LD_INT 2
89033: NEG
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 0
89041: PUSH
89042: LD_INT 2
89044: NEG
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 1
89052: PUSH
89053: LD_INT 1
89055: NEG
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 2
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 2
89073: PUSH
89074: LD_INT 1
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: LD_INT 2
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 1
89093: PUSH
89094: LD_INT 2
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: LD_INT 2
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 1
89113: NEG
89114: PUSH
89115: LD_INT 1
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 2
89124: NEG
89125: PUSH
89126: LD_INT 0
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 2
89135: NEG
89136: PUSH
89137: LD_INT 1
89139: NEG
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: PUSH
89145: LD_INT 2
89147: NEG
89148: PUSH
89149: LD_INT 2
89151: NEG
89152: PUSH
89153: EMPTY
89154: LIST
89155: LIST
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89178: LD_ADDR_VAR 0 56
89182: PUSH
89183: LD_INT 0
89185: PUSH
89186: LD_INT 0
89188: PUSH
89189: EMPTY
89190: LIST
89191: LIST
89192: PUSH
89193: LD_INT 0
89195: PUSH
89196: LD_INT 1
89198: NEG
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: LD_INT 1
89206: PUSH
89207: LD_INT 0
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: PUSH
89214: LD_INT 1
89216: PUSH
89217: LD_INT 1
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 0
89226: PUSH
89227: LD_INT 1
89229: PUSH
89230: EMPTY
89231: LIST
89232: LIST
89233: PUSH
89234: LD_INT 1
89236: NEG
89237: PUSH
89238: LD_INT 0
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 1
89247: NEG
89248: PUSH
89249: LD_INT 1
89251: NEG
89252: PUSH
89253: EMPTY
89254: LIST
89255: LIST
89256: PUSH
89257: LD_INT 1
89259: NEG
89260: PUSH
89261: LD_INT 2
89263: NEG
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 0
89271: PUSH
89272: LD_INT 2
89274: NEG
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 1
89282: PUSH
89283: LD_INT 1
89285: NEG
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: PUSH
89291: LD_INT 2
89293: PUSH
89294: LD_INT 0
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 2
89303: PUSH
89304: LD_INT 1
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 2
89313: PUSH
89314: LD_INT 2
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: LD_INT 1
89323: PUSH
89324: LD_INT 2
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 0
89333: PUSH
89334: LD_INT 2
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 1
89343: NEG
89344: PUSH
89345: LD_INT 1
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: LD_INT 2
89354: NEG
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 2
89365: NEG
89366: PUSH
89367: LD_INT 1
89369: NEG
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: LD_INT 2
89377: NEG
89378: PUSH
89379: LD_INT 2
89381: NEG
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: LIST
89391: LIST
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89408: LD_ADDR_VAR 0 57
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: LD_INT 2
89493: NEG
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 0
89501: PUSH
89502: LD_INT 2
89504: NEG
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: PUSH
89524: LD_INT 0
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 2
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 2
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 1
89553: PUSH
89554: LD_INT 2
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 0
89563: PUSH
89564: LD_INT 2
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 1
89573: NEG
89574: PUSH
89575: LD_INT 1
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 2
89584: NEG
89585: PUSH
89586: LD_INT 0
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 2
89595: NEG
89596: PUSH
89597: LD_INT 1
89599: NEG
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 2
89607: NEG
89608: PUSH
89609: LD_INT 2
89611: NEG
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: LIST
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89638: LD_ADDR_VAR 0 58
89642: PUSH
89643: LD_INT 0
89645: PUSH
89646: LD_INT 0
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: LD_INT 1
89658: NEG
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 1
89666: PUSH
89667: LD_INT 0
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 1
89676: PUSH
89677: LD_INT 1
89679: PUSH
89680: EMPTY
89681: LIST
89682: LIST
89683: PUSH
89684: LD_INT 0
89686: PUSH
89687: LD_INT 1
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 1
89696: NEG
89697: PUSH
89698: LD_INT 0
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: LD_INT 1
89707: NEG
89708: PUSH
89709: LD_INT 1
89711: NEG
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 1
89719: NEG
89720: PUSH
89721: LD_INT 2
89723: NEG
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: LD_INT 2
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: PUSH
89743: LD_INT 1
89745: NEG
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 2
89753: PUSH
89754: LD_INT 0
89756: PUSH
89757: EMPTY
89758: LIST
89759: LIST
89760: PUSH
89761: LD_INT 2
89763: PUSH
89764: LD_INT 1
89766: PUSH
89767: EMPTY
89768: LIST
89769: LIST
89770: PUSH
89771: LD_INT 2
89773: PUSH
89774: LD_INT 2
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 1
89783: PUSH
89784: LD_INT 2
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 2
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 1
89803: NEG
89804: PUSH
89805: LD_INT 1
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: LD_INT 2
89814: NEG
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 2
89825: NEG
89826: PUSH
89827: LD_INT 1
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 2
89837: NEG
89838: PUSH
89839: LD_INT 2
89841: NEG
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89868: LD_ADDR_VAR 0 59
89872: PUSH
89873: LD_INT 0
89875: PUSH
89876: LD_INT 0
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 0
89885: PUSH
89886: LD_INT 1
89888: NEG
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 1
89896: PUSH
89897: LD_INT 0
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: PUSH
89904: LD_INT 1
89906: PUSH
89907: LD_INT 1
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 1
89926: NEG
89927: PUSH
89928: LD_INT 0
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 1
89937: NEG
89938: PUSH
89939: LD_INT 1
89941: NEG
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89956: LD_ADDR_VAR 0 60
89960: PUSH
89961: LD_INT 0
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 0
89973: PUSH
89974: LD_INT 1
89976: NEG
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 1
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 1
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 1
90014: NEG
90015: PUSH
90016: LD_INT 0
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: NEG
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90044: LD_ADDR_VAR 0 61
90048: PUSH
90049: LD_INT 0
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 0
90061: PUSH
90062: LD_INT 1
90064: NEG
90065: PUSH
90066: EMPTY
90067: LIST
90068: LIST
90069: PUSH
90070: LD_INT 1
90072: PUSH
90073: LD_INT 0
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 1
90082: PUSH
90083: LD_INT 1
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: LD_INT 0
90092: PUSH
90093: LD_INT 1
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: LD_INT 1
90102: NEG
90103: PUSH
90104: LD_INT 0
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: LD_INT 1
90113: NEG
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90132: LD_ADDR_VAR 0 62
90136: PUSH
90137: LD_INT 0
90139: PUSH
90140: LD_INT 0
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: PUSH
90147: LD_INT 0
90149: PUSH
90150: LD_INT 1
90152: NEG
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 1
90160: PUSH
90161: LD_INT 0
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 1
90170: PUSH
90171: LD_INT 1
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 0
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 1
90190: NEG
90191: PUSH
90192: LD_INT 0
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 1
90201: NEG
90202: PUSH
90203: LD_INT 1
90205: NEG
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90220: LD_ADDR_VAR 0 63
90224: PUSH
90225: LD_INT 0
90227: PUSH
90228: LD_INT 0
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: LD_INT 1
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 1
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: PUSH
90259: LD_INT 1
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 0
90268: PUSH
90269: LD_INT 1
90271: PUSH
90272: EMPTY
90273: LIST
90274: LIST
90275: PUSH
90276: LD_INT 1
90278: NEG
90279: PUSH
90280: LD_INT 0
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: LD_INT 1
90289: NEG
90290: PUSH
90291: LD_INT 1
90293: NEG
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90308: LD_ADDR_VAR 0 64
90312: PUSH
90313: LD_INT 0
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: LD_INT 1
90328: NEG
90329: PUSH
90330: EMPTY
90331: LIST
90332: LIST
90333: PUSH
90334: LD_INT 1
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: LD_INT 1
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: LD_INT 1
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: LD_INT 1
90366: NEG
90367: PUSH
90368: LD_INT 0
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: LD_INT 1
90377: NEG
90378: PUSH
90379: LD_INT 1
90381: NEG
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: ST_TO_ADDR
// end ; 1 :
90396: GO 96293
90398: LD_INT 1
90400: DOUBLE
90401: EQUAL
90402: IFTRUE 90406
90404: GO 93029
90406: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90407: LD_ADDR_VAR 0 11
90411: PUSH
90412: LD_INT 1
90414: NEG
90415: PUSH
90416: LD_INT 3
90418: NEG
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: LD_INT 3
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 1
90437: PUSH
90438: LD_INT 2
90440: NEG
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: LIST
90450: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90451: LD_ADDR_VAR 0 12
90455: PUSH
90456: LD_INT 2
90458: PUSH
90459: LD_INT 1
90461: NEG
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 3
90469: PUSH
90470: LD_INT 0
90472: PUSH
90473: EMPTY
90474: LIST
90475: LIST
90476: PUSH
90477: LD_INT 3
90479: PUSH
90480: LD_INT 1
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: LIST
90491: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90492: LD_ADDR_VAR 0 13
90496: PUSH
90497: LD_INT 3
90499: PUSH
90500: LD_INT 2
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 3
90509: PUSH
90510: LD_INT 3
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 2
90519: PUSH
90520: LD_INT 3
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: LIST
90531: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90532: LD_ADDR_VAR 0 14
90536: PUSH
90537: LD_INT 1
90539: PUSH
90540: LD_INT 3
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: PUSH
90547: LD_INT 0
90549: PUSH
90550: LD_INT 3
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: LD_INT 1
90559: NEG
90560: PUSH
90561: LD_INT 2
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: LIST
90572: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90573: LD_ADDR_VAR 0 15
90577: PUSH
90578: LD_INT 2
90580: NEG
90581: PUSH
90582: LD_INT 1
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PUSH
90589: LD_INT 3
90591: NEG
90592: PUSH
90593: LD_INT 0
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: LD_INT 1
90606: NEG
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: LIST
90616: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90617: LD_ADDR_VAR 0 16
90621: PUSH
90622: LD_INT 2
90624: NEG
90625: PUSH
90626: LD_INT 3
90628: NEG
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 3
90636: NEG
90637: PUSH
90638: LD_INT 2
90640: NEG
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 3
90648: NEG
90649: PUSH
90650: LD_INT 3
90652: NEG
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: LIST
90662: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90663: LD_ADDR_VAR 0 17
90667: PUSH
90668: LD_INT 1
90670: NEG
90671: PUSH
90672: LD_INT 3
90674: NEG
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 0
90682: PUSH
90683: LD_INT 3
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 1
90693: PUSH
90694: LD_INT 2
90696: NEG
90697: PUSH
90698: EMPTY
90699: LIST
90700: LIST
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: LIST
90706: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90707: LD_ADDR_VAR 0 18
90711: PUSH
90712: LD_INT 2
90714: PUSH
90715: LD_INT 1
90717: NEG
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 3
90725: PUSH
90726: LD_INT 0
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 3
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: LIST
90747: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90748: LD_ADDR_VAR 0 19
90752: PUSH
90753: LD_INT 3
90755: PUSH
90756: LD_INT 2
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: PUSH
90763: LD_INT 3
90765: PUSH
90766: LD_INT 3
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: PUSH
90773: LD_INT 2
90775: PUSH
90776: LD_INT 3
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: EMPTY
90784: LIST
90785: LIST
90786: LIST
90787: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90788: LD_ADDR_VAR 0 20
90792: PUSH
90793: LD_INT 1
90795: PUSH
90796: LD_INT 3
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: LD_INT 3
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: LD_INT 1
90815: NEG
90816: PUSH
90817: LD_INT 2
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: LIST
90828: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90829: LD_ADDR_VAR 0 21
90833: PUSH
90834: LD_INT 2
90836: NEG
90837: PUSH
90838: LD_INT 1
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 3
90847: NEG
90848: PUSH
90849: LD_INT 0
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 3
90858: NEG
90859: PUSH
90860: LD_INT 1
90862: NEG
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: LIST
90872: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90873: LD_ADDR_VAR 0 22
90877: PUSH
90878: LD_INT 2
90880: NEG
90881: PUSH
90882: LD_INT 3
90884: NEG
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 3
90892: NEG
90893: PUSH
90894: LD_INT 2
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 3
90904: NEG
90905: PUSH
90906: LD_INT 3
90908: NEG
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: LIST
90918: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90919: LD_ADDR_VAR 0 23
90923: PUSH
90924: LD_INT 0
90926: PUSH
90927: LD_INT 3
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: NEG
90938: PUSH
90939: LD_INT 4
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 1
90949: PUSH
90950: LD_INT 3
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: LIST
90962: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90963: LD_ADDR_VAR 0 24
90967: PUSH
90968: LD_INT 3
90970: PUSH
90971: LD_INT 0
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 3
90980: PUSH
90981: LD_INT 1
90983: NEG
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 4
90991: PUSH
90992: LD_INT 1
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: LIST
91003: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91004: LD_ADDR_VAR 0 25
91008: PUSH
91009: LD_INT 3
91011: PUSH
91012: LD_INT 3
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 4
91021: PUSH
91022: LD_INT 3
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 3
91031: PUSH
91032: LD_INT 4
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: LIST
91043: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91044: LD_ADDR_VAR 0 26
91048: PUSH
91049: LD_INT 0
91051: PUSH
91052: LD_INT 3
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 1
91061: PUSH
91062: LD_INT 4
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 1
91071: NEG
91072: PUSH
91073: LD_INT 3
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: EMPTY
91081: LIST
91082: LIST
91083: LIST
91084: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91085: LD_ADDR_VAR 0 27
91089: PUSH
91090: LD_INT 3
91092: NEG
91093: PUSH
91094: LD_INT 0
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 3
91103: NEG
91104: PUSH
91105: LD_INT 1
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 4
91114: NEG
91115: PUSH
91116: LD_INT 1
91118: NEG
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: LIST
91128: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91129: LD_ADDR_VAR 0 28
91133: PUSH
91134: LD_INT 3
91136: NEG
91137: PUSH
91138: LD_INT 3
91140: NEG
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PUSH
91146: LD_INT 3
91148: NEG
91149: PUSH
91150: LD_INT 4
91152: NEG
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: LD_INT 4
91160: NEG
91161: PUSH
91162: LD_INT 3
91164: NEG
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: LIST
91174: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
91175: LD_ADDR_VAR 0 29
91179: PUSH
91180: LD_INT 1
91182: NEG
91183: PUSH
91184: LD_INT 3
91186: NEG
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: LD_INT 3
91197: NEG
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 1
91205: PUSH
91206: LD_INT 2
91208: NEG
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: LD_INT 1
91216: NEG
91217: PUSH
91218: LD_INT 4
91220: NEG
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: LD_INT 4
91231: NEG
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 1
91239: PUSH
91240: LD_INT 3
91242: NEG
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 1
91250: NEG
91251: PUSH
91252: LD_INT 5
91254: NEG
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 0
91262: PUSH
91263: LD_INT 5
91265: NEG
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 1
91273: PUSH
91274: LD_INT 4
91276: NEG
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 1
91284: NEG
91285: PUSH
91286: LD_INT 6
91288: NEG
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: LD_INT 0
91296: PUSH
91297: LD_INT 6
91299: NEG
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 1
91307: PUSH
91308: LD_INT 5
91310: NEG
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91330: LD_ADDR_VAR 0 30
91334: PUSH
91335: LD_INT 2
91337: PUSH
91338: LD_INT 1
91340: NEG
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 3
91348: PUSH
91349: LD_INT 0
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 3
91358: PUSH
91359: LD_INT 1
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 3
91368: PUSH
91369: LD_INT 1
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 4
91379: PUSH
91380: LD_INT 0
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 4
91389: PUSH
91390: LD_INT 1
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 4
91399: PUSH
91400: LD_INT 1
91402: NEG
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 5
91410: PUSH
91411: LD_INT 0
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 5
91420: PUSH
91421: LD_INT 1
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 5
91430: PUSH
91431: LD_INT 1
91433: NEG
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 6
91441: PUSH
91442: LD_INT 0
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 6
91451: PUSH
91452: LD_INT 1
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91473: LD_ADDR_VAR 0 31
91477: PUSH
91478: LD_INT 3
91480: PUSH
91481: LD_INT 2
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 3
91490: PUSH
91491: LD_INT 3
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 2
91500: PUSH
91501: LD_INT 3
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: LD_INT 4
91510: PUSH
91511: LD_INT 3
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 4
91520: PUSH
91521: LD_INT 4
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 3
91530: PUSH
91531: LD_INT 4
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: LD_INT 5
91540: PUSH
91541: LD_INT 4
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 5
91550: PUSH
91551: LD_INT 5
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: PUSH
91558: LD_INT 4
91560: PUSH
91561: LD_INT 5
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 6
91570: PUSH
91571: LD_INT 5
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 6
91580: PUSH
91581: LD_INT 6
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 5
91590: PUSH
91591: LD_INT 6
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91612: LD_ADDR_VAR 0 32
91616: PUSH
91617: LD_INT 1
91619: PUSH
91620: LD_INT 3
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 0
91629: PUSH
91630: LD_INT 3
91632: PUSH
91633: EMPTY
91634: LIST
91635: LIST
91636: PUSH
91637: LD_INT 1
91639: NEG
91640: PUSH
91641: LD_INT 2
91643: PUSH
91644: EMPTY
91645: LIST
91646: LIST
91647: PUSH
91648: LD_INT 1
91650: PUSH
91651: LD_INT 4
91653: PUSH
91654: EMPTY
91655: LIST
91656: LIST
91657: PUSH
91658: LD_INT 0
91660: PUSH
91661: LD_INT 4
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: PUSH
91668: LD_INT 1
91670: NEG
91671: PUSH
91672: LD_INT 3
91674: PUSH
91675: EMPTY
91676: LIST
91677: LIST
91678: PUSH
91679: LD_INT 1
91681: PUSH
91682: LD_INT 5
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: LD_INT 0
91691: PUSH
91692: LD_INT 5
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 1
91701: NEG
91702: PUSH
91703: LD_INT 4
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 1
91712: PUSH
91713: LD_INT 6
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 0
91722: PUSH
91723: LD_INT 6
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: LD_INT 1
91732: NEG
91733: PUSH
91734: LD_INT 5
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91755: LD_ADDR_VAR 0 33
91759: PUSH
91760: LD_INT 2
91762: NEG
91763: PUSH
91764: LD_INT 1
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: PUSH
91771: LD_INT 3
91773: NEG
91774: PUSH
91775: LD_INT 0
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: PUSH
91782: LD_INT 3
91784: NEG
91785: PUSH
91786: LD_INT 1
91788: NEG
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 3
91796: NEG
91797: PUSH
91798: LD_INT 1
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 4
91807: NEG
91808: PUSH
91809: LD_INT 0
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 4
91818: NEG
91819: PUSH
91820: LD_INT 1
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 4
91830: NEG
91831: PUSH
91832: LD_INT 1
91834: PUSH
91835: EMPTY
91836: LIST
91837: LIST
91838: PUSH
91839: LD_INT 5
91841: NEG
91842: PUSH
91843: LD_INT 0
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 5
91852: NEG
91853: PUSH
91854: LD_INT 1
91856: NEG
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 5
91864: NEG
91865: PUSH
91866: LD_INT 1
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 6
91875: NEG
91876: PUSH
91877: LD_INT 0
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 6
91886: NEG
91887: PUSH
91888: LD_INT 1
91890: NEG
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91910: LD_ADDR_VAR 0 34
91914: PUSH
91915: LD_INT 2
91917: NEG
91918: PUSH
91919: LD_INT 3
91921: NEG
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: PUSH
91927: LD_INT 3
91929: NEG
91930: PUSH
91931: LD_INT 2
91933: NEG
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 3
91941: NEG
91942: PUSH
91943: LD_INT 3
91945: NEG
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 3
91953: NEG
91954: PUSH
91955: LD_INT 4
91957: NEG
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 4
91965: NEG
91966: PUSH
91967: LD_INT 3
91969: NEG
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 4
91977: NEG
91978: PUSH
91979: LD_INT 4
91981: NEG
91982: PUSH
91983: EMPTY
91984: LIST
91985: LIST
91986: PUSH
91987: LD_INT 4
91989: NEG
91990: PUSH
91991: LD_INT 5
91993: NEG
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 5
92001: NEG
92002: PUSH
92003: LD_INT 4
92005: NEG
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 5
92013: NEG
92014: PUSH
92015: LD_INT 5
92017: NEG
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 5
92025: NEG
92026: PUSH
92027: LD_INT 6
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 6
92037: NEG
92038: PUSH
92039: LD_INT 5
92041: NEG
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 6
92049: NEG
92050: PUSH
92051: LD_INT 6
92053: NEG
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92073: LD_ADDR_VAR 0 41
92077: PUSH
92078: LD_INT 0
92080: PUSH
92081: LD_INT 2
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 1
92091: NEG
92092: PUSH
92093: LD_INT 3
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 1
92103: PUSH
92104: LD_INT 2
92106: NEG
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: PUSH
92112: EMPTY
92113: LIST
92114: LIST
92115: LIST
92116: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92117: LD_ADDR_VAR 0 42
92121: PUSH
92122: LD_INT 2
92124: PUSH
92125: LD_INT 0
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: LD_INT 2
92134: PUSH
92135: LD_INT 1
92137: NEG
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: PUSH
92143: LD_INT 3
92145: PUSH
92146: LD_INT 1
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: LIST
92157: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92158: LD_ADDR_VAR 0 43
92162: PUSH
92163: LD_INT 2
92165: PUSH
92166: LD_INT 2
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: PUSH
92173: LD_INT 3
92175: PUSH
92176: LD_INT 2
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 2
92185: PUSH
92186: LD_INT 3
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: LIST
92197: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
92198: LD_ADDR_VAR 0 44
92202: PUSH
92203: LD_INT 0
92205: PUSH
92206: LD_INT 2
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 1
92215: PUSH
92216: LD_INT 3
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 1
92225: NEG
92226: PUSH
92227: LD_INT 2
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: LIST
92238: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92239: LD_ADDR_VAR 0 45
92243: PUSH
92244: LD_INT 2
92246: NEG
92247: PUSH
92248: LD_INT 0
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: PUSH
92255: LD_INT 2
92257: NEG
92258: PUSH
92259: LD_INT 1
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 3
92268: NEG
92269: PUSH
92270: LD_INT 1
92272: NEG
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: LIST
92282: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92283: LD_ADDR_VAR 0 46
92287: PUSH
92288: LD_INT 2
92290: NEG
92291: PUSH
92292: LD_INT 2
92294: NEG
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 2
92302: NEG
92303: PUSH
92304: LD_INT 3
92306: NEG
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 3
92314: NEG
92315: PUSH
92316: LD_INT 2
92318: NEG
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92329: LD_ADDR_VAR 0 47
92333: PUSH
92334: LD_INT 2
92336: NEG
92337: PUSH
92338: LD_INT 3
92340: NEG
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 1
92348: NEG
92349: PUSH
92350: LD_INT 3
92352: NEG
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92362: LD_ADDR_VAR 0 48
92366: PUSH
92367: LD_INT 1
92369: PUSH
92370: LD_INT 2
92372: NEG
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 2
92380: PUSH
92381: LD_INT 1
92383: NEG
92384: PUSH
92385: EMPTY
92386: LIST
92387: LIST
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92393: LD_ADDR_VAR 0 49
92397: PUSH
92398: LD_INT 3
92400: PUSH
92401: LD_INT 1
92403: PUSH
92404: EMPTY
92405: LIST
92406: LIST
92407: PUSH
92408: LD_INT 3
92410: PUSH
92411: LD_INT 2
92413: PUSH
92414: EMPTY
92415: LIST
92416: LIST
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92422: LD_ADDR_VAR 0 50
92426: PUSH
92427: LD_INT 2
92429: PUSH
92430: LD_INT 3
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 1
92439: PUSH
92440: LD_INT 3
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92451: LD_ADDR_VAR 0 51
92455: PUSH
92456: LD_INT 1
92458: NEG
92459: PUSH
92460: LD_INT 2
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 2
92469: NEG
92470: PUSH
92471: LD_INT 1
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92482: LD_ADDR_VAR 0 52
92486: PUSH
92487: LD_INT 3
92489: NEG
92490: PUSH
92491: LD_INT 1
92493: NEG
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 3
92501: NEG
92502: PUSH
92503: LD_INT 2
92505: NEG
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92515: LD_ADDR_VAR 0 53
92519: PUSH
92520: LD_INT 1
92522: NEG
92523: PUSH
92524: LD_INT 3
92526: NEG
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 0
92534: PUSH
92535: LD_INT 3
92537: NEG
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 1
92545: PUSH
92546: LD_INT 2
92548: NEG
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: LIST
92558: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92559: LD_ADDR_VAR 0 54
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: LD_INT 1
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: LD_INT 0
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 3
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: LIST
92599: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92600: LD_ADDR_VAR 0 55
92604: PUSH
92605: LD_INT 3
92607: PUSH
92608: LD_INT 2
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: LD_INT 3
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: PUSH
92628: LD_INT 3
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: LIST
92639: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92640: LD_ADDR_VAR 0 56
92644: PUSH
92645: LD_INT 1
92647: PUSH
92648: LD_INT 3
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: LD_INT 3
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: NEG
92668: PUSH
92669: LD_INT 2
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: LIST
92680: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92681: LD_ADDR_VAR 0 57
92685: PUSH
92686: LD_INT 2
92688: NEG
92689: PUSH
92690: LD_INT 1
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 3
92699: NEG
92700: PUSH
92701: LD_INT 0
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 3
92710: NEG
92711: PUSH
92712: LD_INT 1
92714: NEG
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: LIST
92724: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92725: LD_ADDR_VAR 0 58
92729: PUSH
92730: LD_INT 2
92732: NEG
92733: PUSH
92734: LD_INT 3
92736: NEG
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 3
92744: NEG
92745: PUSH
92746: LD_INT 2
92748: NEG
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 3
92756: NEG
92757: PUSH
92758: LD_INT 3
92760: NEG
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: LIST
92770: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92771: LD_ADDR_VAR 0 59
92775: PUSH
92776: LD_INT 1
92778: NEG
92779: PUSH
92780: LD_INT 2
92782: NEG
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: LD_INT 0
92790: PUSH
92791: LD_INT 2
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 1
92801: PUSH
92802: LD_INT 1
92804: NEG
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: LIST
92814: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92815: LD_ADDR_VAR 0 60
92819: PUSH
92820: LD_INT 1
92822: PUSH
92823: LD_INT 1
92825: NEG
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 2
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 2
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: LIST
92855: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92856: LD_ADDR_VAR 0 61
92860: PUSH
92861: LD_INT 2
92863: PUSH
92864: LD_INT 1
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 2
92873: PUSH
92874: LD_INT 2
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 1
92883: PUSH
92884: LD_INT 2
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: LIST
92895: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92896: LD_ADDR_VAR 0 62
92900: PUSH
92901: LD_INT 1
92903: PUSH
92904: LD_INT 2
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 0
92913: PUSH
92914: LD_INT 2
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PUSH
92921: LD_INT 1
92923: NEG
92924: PUSH
92925: LD_INT 1
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: LIST
92936: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92937: LD_ADDR_VAR 0 63
92941: PUSH
92942: LD_INT 1
92944: NEG
92945: PUSH
92946: LD_INT 1
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 2
92955: NEG
92956: PUSH
92957: LD_INT 0
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 2
92966: NEG
92967: PUSH
92968: LD_INT 1
92970: NEG
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: LIST
92980: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92981: LD_ADDR_VAR 0 64
92985: PUSH
92986: LD_INT 1
92988: NEG
92989: PUSH
92990: LD_INT 2
92992: NEG
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 2
93000: NEG
93001: PUSH
93002: LD_INT 1
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 2
93012: NEG
93013: PUSH
93014: LD_INT 2
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: LIST
93026: ST_TO_ADDR
// end ; 2 :
93027: GO 96293
93029: LD_INT 2
93031: DOUBLE
93032: EQUAL
93033: IFTRUE 93037
93035: GO 96292
93037: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93038: LD_ADDR_VAR 0 29
93042: PUSH
93043: LD_INT 4
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 4
93055: PUSH
93056: LD_INT 1
93058: NEG
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 5
93066: PUSH
93067: LD_INT 0
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 5
93076: PUSH
93077: LD_INT 1
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: LD_INT 4
93086: PUSH
93087: LD_INT 1
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 3
93096: PUSH
93097: LD_INT 0
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 3
93106: PUSH
93107: LD_INT 1
93109: NEG
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 3
93117: PUSH
93118: LD_INT 2
93120: NEG
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 5
93128: PUSH
93129: LD_INT 2
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 3
93138: PUSH
93139: LD_INT 3
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 3
93148: PUSH
93149: LD_INT 2
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 4
93158: PUSH
93159: LD_INT 3
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 4
93168: PUSH
93169: LD_INT 4
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 3
93178: PUSH
93179: LD_INT 4
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 2
93188: PUSH
93189: LD_INT 3
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 2
93198: PUSH
93199: LD_INT 2
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 4
93208: PUSH
93209: LD_INT 2
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 2
93218: PUSH
93219: LD_INT 4
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 0
93228: PUSH
93229: LD_INT 4
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 0
93238: PUSH
93239: LD_INT 3
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 1
93248: PUSH
93249: LD_INT 4
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 1
93258: PUSH
93259: LD_INT 5
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_INT 0
93268: PUSH
93269: LD_INT 5
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: PUSH
93276: LD_INT 1
93278: NEG
93279: PUSH
93280: LD_INT 4
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: PUSH
93287: LD_INT 1
93289: NEG
93290: PUSH
93291: LD_INT 3
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 2
93300: PUSH
93301: LD_INT 5
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 2
93310: NEG
93311: PUSH
93312: LD_INT 3
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 3
93321: NEG
93322: PUSH
93323: LD_INT 0
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 3
93332: NEG
93333: PUSH
93334: LD_INT 1
93336: NEG
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 2
93344: NEG
93345: PUSH
93346: LD_INT 0
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 2
93355: NEG
93356: PUSH
93357: LD_INT 1
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 3
93366: NEG
93367: PUSH
93368: LD_INT 1
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: LD_INT 4
93377: NEG
93378: PUSH
93379: LD_INT 0
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: LD_INT 4
93388: NEG
93389: PUSH
93390: LD_INT 1
93392: NEG
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 4
93400: NEG
93401: PUSH
93402: LD_INT 2
93404: NEG
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 2
93412: NEG
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 4
93423: NEG
93424: PUSH
93425: LD_INT 4
93427: NEG
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 4
93435: NEG
93436: PUSH
93437: LD_INT 5
93439: NEG
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: LD_INT 3
93447: NEG
93448: PUSH
93449: LD_INT 4
93451: NEG
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 3
93459: NEG
93460: PUSH
93461: LD_INT 3
93463: NEG
93464: PUSH
93465: EMPTY
93466: LIST
93467: LIST
93468: PUSH
93469: LD_INT 4
93471: NEG
93472: PUSH
93473: LD_INT 3
93475: NEG
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 5
93483: NEG
93484: PUSH
93485: LD_INT 4
93487: NEG
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 5
93495: NEG
93496: PUSH
93497: LD_INT 5
93499: NEG
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: PUSH
93505: LD_INT 3
93507: NEG
93508: PUSH
93509: LD_INT 5
93511: NEG
93512: PUSH
93513: EMPTY
93514: LIST
93515: LIST
93516: PUSH
93517: LD_INT 5
93519: NEG
93520: PUSH
93521: LD_INT 3
93523: NEG
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93576: LD_ADDR_VAR 0 30
93580: PUSH
93581: LD_INT 4
93583: PUSH
93584: LD_INT 4
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 4
93593: PUSH
93594: LD_INT 3
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 5
93603: PUSH
93604: LD_INT 4
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 5
93613: PUSH
93614: LD_INT 5
93616: PUSH
93617: EMPTY
93618: LIST
93619: LIST
93620: PUSH
93621: LD_INT 4
93623: PUSH
93624: LD_INT 5
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: LD_INT 3
93633: PUSH
93634: LD_INT 4
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 3
93643: PUSH
93644: LD_INT 3
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 5
93653: PUSH
93654: LD_INT 3
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 3
93663: PUSH
93664: LD_INT 5
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 0
93673: PUSH
93674: LD_INT 3
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 0
93683: PUSH
93684: LD_INT 2
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 1
93693: PUSH
93694: LD_INT 3
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 1
93703: PUSH
93704: LD_INT 4
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 0
93713: PUSH
93714: LD_INT 4
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 1
93723: NEG
93724: PUSH
93725: LD_INT 3
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 1
93734: NEG
93735: PUSH
93736: LD_INT 2
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: PUSH
93743: LD_INT 2
93745: PUSH
93746: LD_INT 4
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 2
93755: NEG
93756: PUSH
93757: LD_INT 2
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 4
93766: NEG
93767: PUSH
93768: LD_INT 0
93770: PUSH
93771: EMPTY
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 4
93777: NEG
93778: PUSH
93779: LD_INT 1
93781: NEG
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 3
93789: NEG
93790: PUSH
93791: LD_INT 0
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 3
93800: NEG
93801: PUSH
93802: LD_INT 1
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 4
93811: NEG
93812: PUSH
93813: LD_INT 1
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 5
93822: NEG
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 5
93833: NEG
93834: PUSH
93835: LD_INT 1
93837: NEG
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 5
93845: NEG
93846: PUSH
93847: LD_INT 2
93849: NEG
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 3
93857: NEG
93858: PUSH
93859: LD_INT 2
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 3
93868: NEG
93869: PUSH
93870: LD_INT 3
93872: NEG
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 3
93880: NEG
93881: PUSH
93882: LD_INT 4
93884: NEG
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: LD_INT 2
93892: NEG
93893: PUSH
93894: LD_INT 3
93896: NEG
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 2
93904: NEG
93905: PUSH
93906: LD_INT 2
93908: NEG
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 3
93916: NEG
93917: PUSH
93918: LD_INT 2
93920: NEG
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 4
93928: NEG
93929: PUSH
93930: LD_INT 3
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 4
93940: NEG
93941: PUSH
93942: LD_INT 4
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 2
93952: NEG
93953: PUSH
93954: LD_INT 4
93956: NEG
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 4
93964: NEG
93965: PUSH
93966: LD_INT 2
93968: NEG
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 0
93976: PUSH
93977: LD_INT 4
93979: NEG
93980: PUSH
93981: EMPTY
93982: LIST
93983: LIST
93984: PUSH
93985: LD_INT 0
93987: PUSH
93988: LD_INT 5
93990: NEG
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 1
93998: PUSH
93999: LD_INT 4
94001: NEG
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 1
94009: PUSH
94010: LD_INT 3
94012: NEG
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: PUSH
94018: LD_INT 0
94020: PUSH
94021: LD_INT 3
94023: NEG
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 1
94031: NEG
94032: PUSH
94033: LD_INT 4
94035: NEG
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 1
94043: NEG
94044: PUSH
94045: LD_INT 5
94047: NEG
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 2
94055: PUSH
94056: LD_INT 3
94058: NEG
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 2
94066: NEG
94067: PUSH
94068: LD_INT 5
94070: NEG
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94123: LD_ADDR_VAR 0 31
94127: PUSH
94128: LD_INT 0
94130: PUSH
94131: LD_INT 4
94133: PUSH
94134: EMPTY
94135: LIST
94136: LIST
94137: PUSH
94138: LD_INT 0
94140: PUSH
94141: LD_INT 3
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 1
94150: PUSH
94151: LD_INT 4
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 1
94160: PUSH
94161: LD_INT 5
94163: PUSH
94164: EMPTY
94165: LIST
94166: LIST
94167: PUSH
94168: LD_INT 0
94170: PUSH
94171: LD_INT 5
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 1
94180: NEG
94181: PUSH
94182: LD_INT 4
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 1
94191: NEG
94192: PUSH
94193: LD_INT 3
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: PUSH
94200: LD_INT 2
94202: PUSH
94203: LD_INT 5
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: LD_INT 3
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 3
94223: NEG
94224: PUSH
94225: LD_INT 0
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: LD_INT 3
94234: NEG
94235: PUSH
94236: LD_INT 1
94238: NEG
94239: PUSH
94240: EMPTY
94241: LIST
94242: LIST
94243: PUSH
94244: LD_INT 2
94246: NEG
94247: PUSH
94248: LD_INT 0
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 2
94257: NEG
94258: PUSH
94259: LD_INT 1
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: NEG
94269: PUSH
94270: LD_INT 1
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: LD_INT 4
94279: NEG
94280: PUSH
94281: LD_INT 0
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 4
94290: NEG
94291: PUSH
94292: LD_INT 1
94294: NEG
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 4
94302: NEG
94303: PUSH
94304: LD_INT 2
94306: NEG
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 2
94314: NEG
94315: PUSH
94316: LD_INT 2
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 4
94325: NEG
94326: PUSH
94327: LD_INT 4
94329: NEG
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 4
94337: NEG
94338: PUSH
94339: LD_INT 5
94341: NEG
94342: PUSH
94343: EMPTY
94344: LIST
94345: LIST
94346: PUSH
94347: LD_INT 3
94349: NEG
94350: PUSH
94351: LD_INT 4
94353: NEG
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 3
94361: NEG
94362: PUSH
94363: LD_INT 3
94365: NEG
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 4
94373: NEG
94374: PUSH
94375: LD_INT 3
94377: NEG
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 5
94385: NEG
94386: PUSH
94387: LD_INT 4
94389: NEG
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 5
94397: NEG
94398: PUSH
94399: LD_INT 5
94401: NEG
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 3
94409: NEG
94410: PUSH
94411: LD_INT 5
94413: NEG
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: PUSH
94419: LD_INT 5
94421: NEG
94422: PUSH
94423: LD_INT 3
94425: NEG
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PUSH
94431: LD_INT 0
94433: PUSH
94434: LD_INT 3
94436: NEG
94437: PUSH
94438: EMPTY
94439: LIST
94440: LIST
94441: PUSH
94442: LD_INT 0
94444: PUSH
94445: LD_INT 4
94447: NEG
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 1
94455: PUSH
94456: LD_INT 3
94458: NEG
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: LD_INT 1
94466: PUSH
94467: LD_INT 2
94469: NEG
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 0
94477: PUSH
94478: LD_INT 2
94480: NEG
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 1
94488: NEG
94489: PUSH
94490: LD_INT 3
94492: NEG
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 1
94500: NEG
94501: PUSH
94502: LD_INT 4
94504: NEG
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 2
94512: PUSH
94513: LD_INT 2
94515: NEG
94516: PUSH
94517: EMPTY
94518: LIST
94519: LIST
94520: PUSH
94521: LD_INT 2
94523: NEG
94524: PUSH
94525: LD_INT 4
94527: NEG
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 4
94535: PUSH
94536: LD_INT 0
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 4
94545: PUSH
94546: LD_INT 1
94548: NEG
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: LD_INT 5
94556: PUSH
94557: LD_INT 0
94559: PUSH
94560: EMPTY
94561: LIST
94562: LIST
94563: PUSH
94564: LD_INT 5
94566: PUSH
94567: LD_INT 1
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 4
94576: PUSH
94577: LD_INT 1
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 3
94586: PUSH
94587: LD_INT 0
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 3
94596: PUSH
94597: LD_INT 1
94599: NEG
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 3
94607: PUSH
94608: LD_INT 2
94610: NEG
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 5
94618: PUSH
94619: LD_INT 2
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: EMPTY
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94673: LD_ADDR_VAR 0 32
94677: PUSH
94678: LD_INT 4
94680: NEG
94681: PUSH
94682: LD_INT 0
94684: PUSH
94685: EMPTY
94686: LIST
94687: LIST
94688: PUSH
94689: LD_INT 4
94691: NEG
94692: PUSH
94693: LD_INT 1
94695: NEG
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 3
94703: NEG
94704: PUSH
94705: LD_INT 0
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: PUSH
94712: LD_INT 3
94714: NEG
94715: PUSH
94716: LD_INT 1
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 4
94725: NEG
94726: PUSH
94727: LD_INT 1
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 5
94736: NEG
94737: PUSH
94738: LD_INT 0
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: LD_INT 5
94747: NEG
94748: PUSH
94749: LD_INT 1
94751: NEG
94752: PUSH
94753: EMPTY
94754: LIST
94755: LIST
94756: PUSH
94757: LD_INT 5
94759: NEG
94760: PUSH
94761: LD_INT 2
94763: NEG
94764: PUSH
94765: EMPTY
94766: LIST
94767: LIST
94768: PUSH
94769: LD_INT 3
94771: NEG
94772: PUSH
94773: LD_INT 2
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 3
94782: NEG
94783: PUSH
94784: LD_INT 3
94786: NEG
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 3
94794: NEG
94795: PUSH
94796: LD_INT 4
94798: NEG
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 2
94806: NEG
94807: PUSH
94808: LD_INT 3
94810: NEG
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 2
94818: NEG
94819: PUSH
94820: LD_INT 2
94822: NEG
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 3
94830: NEG
94831: PUSH
94832: LD_INT 2
94834: NEG
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 4
94842: NEG
94843: PUSH
94844: LD_INT 3
94846: NEG
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 4
94854: NEG
94855: PUSH
94856: LD_INT 4
94858: NEG
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 2
94866: NEG
94867: PUSH
94868: LD_INT 4
94870: NEG
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 4
94878: NEG
94879: PUSH
94880: LD_INT 2
94882: NEG
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: LD_INT 4
94893: NEG
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 0
94901: PUSH
94902: LD_INT 5
94904: NEG
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 1
94912: PUSH
94913: LD_INT 4
94915: NEG
94916: PUSH
94917: EMPTY
94918: LIST
94919: LIST
94920: PUSH
94921: LD_INT 1
94923: PUSH
94924: LD_INT 3
94926: NEG
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: PUSH
94932: LD_INT 0
94934: PUSH
94935: LD_INT 3
94937: NEG
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: PUSH
94943: LD_INT 1
94945: NEG
94946: PUSH
94947: LD_INT 4
94949: NEG
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 1
94957: NEG
94958: PUSH
94959: LD_INT 5
94961: NEG
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 2
94969: PUSH
94970: LD_INT 3
94972: NEG
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 2
94980: NEG
94981: PUSH
94982: LD_INT 5
94984: NEG
94985: PUSH
94986: EMPTY
94987: LIST
94988: LIST
94989: PUSH
94990: LD_INT 3
94992: PUSH
94993: LD_INT 0
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 3
95002: PUSH
95003: LD_INT 1
95005: NEG
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 4
95013: PUSH
95014: LD_INT 0
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: LD_INT 4
95023: PUSH
95024: LD_INT 1
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: LD_INT 3
95033: PUSH
95034: LD_INT 1
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: PUSH
95041: LD_INT 2
95043: PUSH
95044: LD_INT 0
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: LD_INT 2
95053: PUSH
95054: LD_INT 1
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 2
95064: PUSH
95065: LD_INT 2
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 4
95075: PUSH
95076: LD_INT 2
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 4
95085: PUSH
95086: LD_INT 4
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: LD_INT 4
95095: PUSH
95096: LD_INT 3
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 5
95105: PUSH
95106: LD_INT 4
95108: PUSH
95109: EMPTY
95110: LIST
95111: LIST
95112: PUSH
95113: LD_INT 5
95115: PUSH
95116: LD_INT 5
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: PUSH
95123: LD_INT 4
95125: PUSH
95126: LD_INT 5
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 3
95135: PUSH
95136: LD_INT 4
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 3
95145: PUSH
95146: LD_INT 3
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 5
95155: PUSH
95156: LD_INT 3
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 3
95165: PUSH
95166: LD_INT 5
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: LIST
95201: LIST
95202: LIST
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95220: LD_ADDR_VAR 0 33
95224: PUSH
95225: LD_INT 4
95227: NEG
95228: PUSH
95229: LD_INT 4
95231: NEG
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 4
95239: NEG
95240: PUSH
95241: LD_INT 5
95243: NEG
95244: PUSH
95245: EMPTY
95246: LIST
95247: LIST
95248: PUSH
95249: LD_INT 3
95251: NEG
95252: PUSH
95253: LD_INT 4
95255: NEG
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: PUSH
95261: LD_INT 3
95263: NEG
95264: PUSH
95265: LD_INT 3
95267: NEG
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 4
95275: NEG
95276: PUSH
95277: LD_INT 3
95279: NEG
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 5
95287: NEG
95288: PUSH
95289: LD_INT 4
95291: NEG
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 5
95299: NEG
95300: PUSH
95301: LD_INT 5
95303: NEG
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 3
95311: NEG
95312: PUSH
95313: LD_INT 5
95315: NEG
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: PUSH
95321: LD_INT 5
95323: NEG
95324: PUSH
95325: LD_INT 3
95327: NEG
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: PUSH
95333: LD_INT 0
95335: PUSH
95336: LD_INT 3
95338: NEG
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 0
95346: PUSH
95347: LD_INT 4
95349: NEG
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: LD_INT 1
95357: PUSH
95358: LD_INT 3
95360: NEG
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 1
95368: PUSH
95369: LD_INT 2
95371: NEG
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 0
95379: PUSH
95380: LD_INT 2
95382: NEG
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 1
95390: NEG
95391: PUSH
95392: LD_INT 3
95394: NEG
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: LD_INT 1
95402: NEG
95403: PUSH
95404: LD_INT 4
95406: NEG
95407: PUSH
95408: EMPTY
95409: LIST
95410: LIST
95411: PUSH
95412: LD_INT 2
95414: PUSH
95415: LD_INT 2
95417: NEG
95418: PUSH
95419: EMPTY
95420: LIST
95421: LIST
95422: PUSH
95423: LD_INT 2
95425: NEG
95426: PUSH
95427: LD_INT 4
95429: NEG
95430: PUSH
95431: EMPTY
95432: LIST
95433: LIST
95434: PUSH
95435: LD_INT 4
95437: PUSH
95438: LD_INT 0
95440: PUSH
95441: EMPTY
95442: LIST
95443: LIST
95444: PUSH
95445: LD_INT 4
95447: PUSH
95448: LD_INT 1
95450: NEG
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 5
95458: PUSH
95459: LD_INT 0
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: LD_INT 5
95468: PUSH
95469: LD_INT 1
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 4
95478: PUSH
95479: LD_INT 1
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 3
95488: PUSH
95489: LD_INT 0
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 3
95498: PUSH
95499: LD_INT 1
95501: NEG
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 3
95509: PUSH
95510: LD_INT 2
95512: NEG
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 5
95520: PUSH
95521: LD_INT 2
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: LD_INT 3
95530: PUSH
95531: LD_INT 3
95533: PUSH
95534: EMPTY
95535: LIST
95536: LIST
95537: PUSH
95538: LD_INT 3
95540: PUSH
95541: LD_INT 2
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 4
95550: PUSH
95551: LD_INT 3
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: PUSH
95558: LD_INT 4
95560: PUSH
95561: LD_INT 4
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 3
95570: PUSH
95571: LD_INT 4
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: LD_INT 2
95580: PUSH
95581: LD_INT 3
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: LD_INT 2
95590: PUSH
95591: LD_INT 2
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 4
95600: PUSH
95601: LD_INT 2
95603: PUSH
95604: EMPTY
95605: LIST
95606: LIST
95607: PUSH
95608: LD_INT 2
95610: PUSH
95611: LD_INT 4
95613: PUSH
95614: EMPTY
95615: LIST
95616: LIST
95617: PUSH
95618: LD_INT 0
95620: PUSH
95621: LD_INT 4
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_INT 0
95630: PUSH
95631: LD_INT 3
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 1
95640: PUSH
95641: LD_INT 4
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 1
95650: PUSH
95651: LD_INT 5
95653: PUSH
95654: EMPTY
95655: LIST
95656: LIST
95657: PUSH
95658: LD_INT 0
95660: PUSH
95661: LD_INT 5
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: PUSH
95668: LD_INT 1
95670: NEG
95671: PUSH
95672: LD_INT 4
95674: PUSH
95675: EMPTY
95676: LIST
95677: LIST
95678: PUSH
95679: LD_INT 1
95681: NEG
95682: PUSH
95683: LD_INT 3
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PUSH
95690: LD_INT 2
95692: PUSH
95693: LD_INT 5
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 2
95702: NEG
95703: PUSH
95704: LD_INT 3
95706: PUSH
95707: EMPTY
95708: LIST
95709: LIST
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95758: LD_ADDR_VAR 0 34
95762: PUSH
95763: LD_INT 0
95765: PUSH
95766: LD_INT 4
95768: NEG
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 0
95776: PUSH
95777: LD_INT 5
95779: NEG
95780: PUSH
95781: EMPTY
95782: LIST
95783: LIST
95784: PUSH
95785: LD_INT 1
95787: PUSH
95788: LD_INT 4
95790: NEG
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: PUSH
95796: LD_INT 1
95798: PUSH
95799: LD_INT 3
95801: NEG
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 0
95809: PUSH
95810: LD_INT 3
95812: NEG
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: PUSH
95818: LD_INT 1
95820: NEG
95821: PUSH
95822: LD_INT 4
95824: NEG
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: PUSH
95830: LD_INT 1
95832: NEG
95833: PUSH
95834: LD_INT 5
95836: NEG
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 2
95844: PUSH
95845: LD_INT 3
95847: NEG
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 2
95855: NEG
95856: PUSH
95857: LD_INT 5
95859: NEG
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 3
95867: PUSH
95868: LD_INT 0
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: PUSH
95878: LD_INT 1
95880: NEG
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 4
95888: PUSH
95889: LD_INT 0
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: PUSH
95896: LD_INT 4
95898: PUSH
95899: LD_INT 1
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 3
95908: PUSH
95909: LD_INT 1
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 2
95918: PUSH
95919: LD_INT 0
95921: PUSH
95922: EMPTY
95923: LIST
95924: LIST
95925: PUSH
95926: LD_INT 2
95928: PUSH
95929: LD_INT 1
95931: NEG
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 2
95939: PUSH
95940: LD_INT 2
95942: NEG
95943: PUSH
95944: EMPTY
95945: LIST
95946: LIST
95947: PUSH
95948: LD_INT 4
95950: PUSH
95951: LD_INT 2
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: PUSH
95958: LD_INT 4
95960: PUSH
95961: LD_INT 4
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 4
95970: PUSH
95971: LD_INT 3
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 5
95980: PUSH
95981: LD_INT 4
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 5
95990: PUSH
95991: LD_INT 5
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 4
96000: PUSH
96001: LD_INT 5
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 3
96010: PUSH
96011: LD_INT 4
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 3
96020: PUSH
96021: LD_INT 3
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 5
96030: PUSH
96031: LD_INT 3
96033: PUSH
96034: EMPTY
96035: LIST
96036: LIST
96037: PUSH
96038: LD_INT 3
96040: PUSH
96041: LD_INT 5
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 0
96050: PUSH
96051: LD_INT 3
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 0
96060: PUSH
96061: LD_INT 2
96063: PUSH
96064: EMPTY
96065: LIST
96066: LIST
96067: PUSH
96068: LD_INT 1
96070: PUSH
96071: LD_INT 3
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 1
96080: PUSH
96081: LD_INT 4
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 0
96090: PUSH
96091: LD_INT 4
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: LD_INT 1
96100: NEG
96101: PUSH
96102: LD_INT 3
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 1
96111: NEG
96112: PUSH
96113: LD_INT 2
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 2
96122: PUSH
96123: LD_INT 4
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 2
96132: NEG
96133: PUSH
96134: LD_INT 2
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 4
96143: NEG
96144: PUSH
96145: LD_INT 0
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 4
96154: NEG
96155: PUSH
96156: LD_INT 1
96158: NEG
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 3
96166: NEG
96167: PUSH
96168: LD_INT 0
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 3
96177: NEG
96178: PUSH
96179: LD_INT 1
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 4
96188: NEG
96189: PUSH
96190: LD_INT 1
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 5
96199: NEG
96200: PUSH
96201: LD_INT 0
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 5
96210: NEG
96211: PUSH
96212: LD_INT 1
96214: NEG
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: PUSH
96220: LD_INT 5
96222: NEG
96223: PUSH
96224: LD_INT 2
96226: NEG
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 3
96234: NEG
96235: PUSH
96236: LD_INT 2
96238: PUSH
96239: EMPTY
96240: LIST
96241: LIST
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: ST_TO_ADDR
// end ; end ;
96290: GO 96293
96292: POP
// case btype of b_depot , b_warehouse :
96293: LD_VAR 0 1
96297: PUSH
96298: LD_INT 0
96300: DOUBLE
96301: EQUAL
96302: IFTRUE 96312
96304: LD_INT 1
96306: DOUBLE
96307: EQUAL
96308: IFTRUE 96312
96310: GO 96513
96312: POP
// case nation of nation_american :
96313: LD_VAR 0 5
96317: PUSH
96318: LD_INT 1
96320: DOUBLE
96321: EQUAL
96322: IFTRUE 96326
96324: GO 96382
96326: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
96327: LD_ADDR_VAR 0 9
96331: PUSH
96332: LD_VAR 0 11
96336: PUSH
96337: LD_VAR 0 12
96341: PUSH
96342: LD_VAR 0 13
96346: PUSH
96347: LD_VAR 0 14
96351: PUSH
96352: LD_VAR 0 15
96356: PUSH
96357: LD_VAR 0 16
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: LIST
96366: LIST
96367: LIST
96368: LIST
96369: PUSH
96370: LD_VAR 0 4
96374: PUSH
96375: LD_INT 1
96377: PLUS
96378: ARRAY
96379: ST_TO_ADDR
96380: GO 96511
96382: LD_INT 2
96384: DOUBLE
96385: EQUAL
96386: IFTRUE 96390
96388: GO 96446
96390: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96391: LD_ADDR_VAR 0 9
96395: PUSH
96396: LD_VAR 0 17
96400: PUSH
96401: LD_VAR 0 18
96405: PUSH
96406: LD_VAR 0 19
96410: PUSH
96411: LD_VAR 0 20
96415: PUSH
96416: LD_VAR 0 21
96420: PUSH
96421: LD_VAR 0 22
96425: PUSH
96426: EMPTY
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: PUSH
96434: LD_VAR 0 4
96438: PUSH
96439: LD_INT 1
96441: PLUS
96442: ARRAY
96443: ST_TO_ADDR
96444: GO 96511
96446: LD_INT 3
96448: DOUBLE
96449: EQUAL
96450: IFTRUE 96454
96452: GO 96510
96454: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96455: LD_ADDR_VAR 0 9
96459: PUSH
96460: LD_VAR 0 23
96464: PUSH
96465: LD_VAR 0 24
96469: PUSH
96470: LD_VAR 0 25
96474: PUSH
96475: LD_VAR 0 26
96479: PUSH
96480: LD_VAR 0 27
96484: PUSH
96485: LD_VAR 0 28
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: PUSH
96498: LD_VAR 0 4
96502: PUSH
96503: LD_INT 1
96505: PLUS
96506: ARRAY
96507: ST_TO_ADDR
96508: GO 96511
96510: POP
96511: GO 97066
96513: LD_INT 2
96515: DOUBLE
96516: EQUAL
96517: IFTRUE 96527
96519: LD_INT 3
96521: DOUBLE
96522: EQUAL
96523: IFTRUE 96527
96525: GO 96583
96527: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96528: LD_ADDR_VAR 0 9
96532: PUSH
96533: LD_VAR 0 29
96537: PUSH
96538: LD_VAR 0 30
96542: PUSH
96543: LD_VAR 0 31
96547: PUSH
96548: LD_VAR 0 32
96552: PUSH
96553: LD_VAR 0 33
96557: PUSH
96558: LD_VAR 0 34
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: PUSH
96571: LD_VAR 0 4
96575: PUSH
96576: LD_INT 1
96578: PLUS
96579: ARRAY
96580: ST_TO_ADDR
96581: GO 97066
96583: LD_INT 16
96585: DOUBLE
96586: EQUAL
96587: IFTRUE 96645
96589: LD_INT 17
96591: DOUBLE
96592: EQUAL
96593: IFTRUE 96645
96595: LD_INT 18
96597: DOUBLE
96598: EQUAL
96599: IFTRUE 96645
96601: LD_INT 19
96603: DOUBLE
96604: EQUAL
96605: IFTRUE 96645
96607: LD_INT 22
96609: DOUBLE
96610: EQUAL
96611: IFTRUE 96645
96613: LD_INT 20
96615: DOUBLE
96616: EQUAL
96617: IFTRUE 96645
96619: LD_INT 21
96621: DOUBLE
96622: EQUAL
96623: IFTRUE 96645
96625: LD_INT 23
96627: DOUBLE
96628: EQUAL
96629: IFTRUE 96645
96631: LD_INT 24
96633: DOUBLE
96634: EQUAL
96635: IFTRUE 96645
96637: LD_INT 25
96639: DOUBLE
96640: EQUAL
96641: IFTRUE 96645
96643: GO 96701
96645: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96646: LD_ADDR_VAR 0 9
96650: PUSH
96651: LD_VAR 0 35
96655: PUSH
96656: LD_VAR 0 36
96660: PUSH
96661: LD_VAR 0 37
96665: PUSH
96666: LD_VAR 0 38
96670: PUSH
96671: LD_VAR 0 39
96675: PUSH
96676: LD_VAR 0 40
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: PUSH
96689: LD_VAR 0 4
96693: PUSH
96694: LD_INT 1
96696: PLUS
96697: ARRAY
96698: ST_TO_ADDR
96699: GO 97066
96701: LD_INT 6
96703: DOUBLE
96704: EQUAL
96705: IFTRUE 96757
96707: LD_INT 7
96709: DOUBLE
96710: EQUAL
96711: IFTRUE 96757
96713: LD_INT 8
96715: DOUBLE
96716: EQUAL
96717: IFTRUE 96757
96719: LD_INT 13
96721: DOUBLE
96722: EQUAL
96723: IFTRUE 96757
96725: LD_INT 12
96727: DOUBLE
96728: EQUAL
96729: IFTRUE 96757
96731: LD_INT 15
96733: DOUBLE
96734: EQUAL
96735: IFTRUE 96757
96737: LD_INT 11
96739: DOUBLE
96740: EQUAL
96741: IFTRUE 96757
96743: LD_INT 14
96745: DOUBLE
96746: EQUAL
96747: IFTRUE 96757
96749: LD_INT 10
96751: DOUBLE
96752: EQUAL
96753: IFTRUE 96757
96755: GO 96813
96757: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96758: LD_ADDR_VAR 0 9
96762: PUSH
96763: LD_VAR 0 41
96767: PUSH
96768: LD_VAR 0 42
96772: PUSH
96773: LD_VAR 0 43
96777: PUSH
96778: LD_VAR 0 44
96782: PUSH
96783: LD_VAR 0 45
96787: PUSH
96788: LD_VAR 0 46
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: PUSH
96801: LD_VAR 0 4
96805: PUSH
96806: LD_INT 1
96808: PLUS
96809: ARRAY
96810: ST_TO_ADDR
96811: GO 97066
96813: LD_INT 36
96815: DOUBLE
96816: EQUAL
96817: IFTRUE 96821
96819: GO 96877
96821: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96822: LD_ADDR_VAR 0 9
96826: PUSH
96827: LD_VAR 0 47
96831: PUSH
96832: LD_VAR 0 48
96836: PUSH
96837: LD_VAR 0 49
96841: PUSH
96842: LD_VAR 0 50
96846: PUSH
96847: LD_VAR 0 51
96851: PUSH
96852: LD_VAR 0 52
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: PUSH
96865: LD_VAR 0 4
96869: PUSH
96870: LD_INT 1
96872: PLUS
96873: ARRAY
96874: ST_TO_ADDR
96875: GO 97066
96877: LD_INT 4
96879: DOUBLE
96880: EQUAL
96881: IFTRUE 96903
96883: LD_INT 5
96885: DOUBLE
96886: EQUAL
96887: IFTRUE 96903
96889: LD_INT 34
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96903
96895: LD_INT 37
96897: DOUBLE
96898: EQUAL
96899: IFTRUE 96903
96901: GO 96959
96903: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96904: LD_ADDR_VAR 0 9
96908: PUSH
96909: LD_VAR 0 53
96913: PUSH
96914: LD_VAR 0 54
96918: PUSH
96919: LD_VAR 0 55
96923: PUSH
96924: LD_VAR 0 56
96928: PUSH
96929: LD_VAR 0 57
96933: PUSH
96934: LD_VAR 0 58
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: PUSH
96947: LD_VAR 0 4
96951: PUSH
96952: LD_INT 1
96954: PLUS
96955: ARRAY
96956: ST_TO_ADDR
96957: GO 97066
96959: LD_INT 31
96961: DOUBLE
96962: EQUAL
96963: IFTRUE 97009
96965: LD_INT 32
96967: DOUBLE
96968: EQUAL
96969: IFTRUE 97009
96971: LD_INT 33
96973: DOUBLE
96974: EQUAL
96975: IFTRUE 97009
96977: LD_INT 27
96979: DOUBLE
96980: EQUAL
96981: IFTRUE 97009
96983: LD_INT 26
96985: DOUBLE
96986: EQUAL
96987: IFTRUE 97009
96989: LD_INT 28
96991: DOUBLE
96992: EQUAL
96993: IFTRUE 97009
96995: LD_INT 29
96997: DOUBLE
96998: EQUAL
96999: IFTRUE 97009
97001: LD_INT 30
97003: DOUBLE
97004: EQUAL
97005: IFTRUE 97009
97007: GO 97065
97009: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97010: LD_ADDR_VAR 0 9
97014: PUSH
97015: LD_VAR 0 59
97019: PUSH
97020: LD_VAR 0 60
97024: PUSH
97025: LD_VAR 0 61
97029: PUSH
97030: LD_VAR 0 62
97034: PUSH
97035: LD_VAR 0 63
97039: PUSH
97040: LD_VAR 0 64
97044: PUSH
97045: EMPTY
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: PUSH
97053: LD_VAR 0 4
97057: PUSH
97058: LD_INT 1
97060: PLUS
97061: ARRAY
97062: ST_TO_ADDR
97063: GO 97066
97065: POP
// temp_list2 = [ ] ;
97066: LD_ADDR_VAR 0 10
97070: PUSH
97071: EMPTY
97072: ST_TO_ADDR
// for i in temp_list do
97073: LD_ADDR_VAR 0 8
97077: PUSH
97078: LD_VAR 0 9
97082: PUSH
97083: FOR_IN
97084: IFFALSE 97136
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97086: LD_ADDR_VAR 0 10
97090: PUSH
97091: LD_VAR 0 10
97095: PUSH
97096: LD_VAR 0 8
97100: PUSH
97101: LD_INT 1
97103: ARRAY
97104: PUSH
97105: LD_VAR 0 2
97109: PLUS
97110: PUSH
97111: LD_VAR 0 8
97115: PUSH
97116: LD_INT 2
97118: ARRAY
97119: PUSH
97120: LD_VAR 0 3
97124: PLUS
97125: PUSH
97126: EMPTY
97127: LIST
97128: LIST
97129: PUSH
97130: EMPTY
97131: LIST
97132: ADD
97133: ST_TO_ADDR
97134: GO 97083
97136: POP
97137: POP
// result = temp_list2 ;
97138: LD_ADDR_VAR 0 7
97142: PUSH
97143: LD_VAR 0 10
97147: ST_TO_ADDR
// end ;
97148: LD_VAR 0 7
97152: RET
// export function EnemyInRange ( unit , dist ) ; begin
97153: LD_INT 0
97155: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97156: LD_ADDR_VAR 0 3
97160: PUSH
97161: LD_VAR 0 1
97165: PPUSH
97166: CALL_OW 255
97170: PPUSH
97171: LD_VAR 0 1
97175: PPUSH
97176: CALL_OW 250
97180: PPUSH
97181: LD_VAR 0 1
97185: PPUSH
97186: CALL_OW 251
97190: PPUSH
97191: LD_VAR 0 2
97195: PPUSH
97196: CALL 71257 0 4
97200: PUSH
97201: LD_INT 4
97203: ARRAY
97204: ST_TO_ADDR
// end ;
97205: LD_VAR 0 3
97209: RET
// export function PlayerSeeMe ( unit ) ; begin
97210: LD_INT 0
97212: PPUSH
// result := See ( your_side , unit ) ;
97213: LD_ADDR_VAR 0 2
97217: PUSH
97218: LD_OWVAR 2
97222: PPUSH
97223: LD_VAR 0 1
97227: PPUSH
97228: CALL_OW 292
97232: ST_TO_ADDR
// end ;
97233: LD_VAR 0 2
97237: RET
// export function ReverseDir ( unit ) ; begin
97238: LD_INT 0
97240: PPUSH
// if not unit then
97241: LD_VAR 0 1
97245: NOT
97246: IFFALSE 97250
// exit ;
97248: GO 97296
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
97250: LD_ADDR_VAR 0 2
97254: PUSH
97255: LD_INT 3
97257: PUSH
97258: LD_INT 4
97260: PUSH
97261: LD_INT 5
97263: PUSH
97264: LD_INT 0
97266: PUSH
97267: LD_INT 1
97269: PUSH
97270: LD_INT 2
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: PUSH
97281: LD_VAR 0 1
97285: PPUSH
97286: CALL_OW 254
97290: PUSH
97291: LD_INT 1
97293: PLUS
97294: ARRAY
97295: ST_TO_ADDR
// end ;
97296: LD_VAR 0 2
97300: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97301: LD_INT 0
97303: PPUSH
97304: PPUSH
97305: PPUSH
97306: PPUSH
97307: PPUSH
// if not hexes then
97308: LD_VAR 0 2
97312: NOT
97313: IFFALSE 97317
// exit ;
97315: GO 97465
// dist := 9999 ;
97317: LD_ADDR_VAR 0 5
97321: PUSH
97322: LD_INT 9999
97324: ST_TO_ADDR
// for i = 1 to hexes do
97325: LD_ADDR_VAR 0 4
97329: PUSH
97330: DOUBLE
97331: LD_INT 1
97333: DEC
97334: ST_TO_ADDR
97335: LD_VAR 0 2
97339: PUSH
97340: FOR_TO
97341: IFFALSE 97453
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97343: LD_VAR 0 1
97347: PPUSH
97348: LD_VAR 0 2
97352: PUSH
97353: LD_VAR 0 4
97357: ARRAY
97358: PUSH
97359: LD_INT 1
97361: ARRAY
97362: PPUSH
97363: LD_VAR 0 2
97367: PUSH
97368: LD_VAR 0 4
97372: ARRAY
97373: PUSH
97374: LD_INT 2
97376: ARRAY
97377: PPUSH
97378: CALL_OW 297
97382: PUSH
97383: LD_VAR 0 5
97387: LESS
97388: IFFALSE 97451
// begin hex := hexes [ i ] ;
97390: LD_ADDR_VAR 0 7
97394: PUSH
97395: LD_VAR 0 2
97399: PUSH
97400: LD_VAR 0 4
97404: ARRAY
97405: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97406: LD_ADDR_VAR 0 5
97410: PUSH
97411: LD_VAR 0 1
97415: PPUSH
97416: LD_VAR 0 2
97420: PUSH
97421: LD_VAR 0 4
97425: ARRAY
97426: PUSH
97427: LD_INT 1
97429: ARRAY
97430: PPUSH
97431: LD_VAR 0 2
97435: PUSH
97436: LD_VAR 0 4
97440: ARRAY
97441: PUSH
97442: LD_INT 2
97444: ARRAY
97445: PPUSH
97446: CALL_OW 297
97450: ST_TO_ADDR
// end ; end ;
97451: GO 97340
97453: POP
97454: POP
// result := hex ;
97455: LD_ADDR_VAR 0 3
97459: PUSH
97460: LD_VAR 0 7
97464: ST_TO_ADDR
// end ;
97465: LD_VAR 0 3
97469: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97470: LD_INT 0
97472: PPUSH
97473: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97474: LD_VAR 0 1
97478: NOT
97479: PUSH
97480: LD_VAR 0 1
97484: PUSH
97485: LD_INT 21
97487: PUSH
97488: LD_INT 2
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: PUSH
97495: LD_INT 23
97497: PUSH
97498: LD_INT 2
97500: PUSH
97501: EMPTY
97502: LIST
97503: LIST
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PPUSH
97509: CALL_OW 69
97513: IN
97514: NOT
97515: OR
97516: IFFALSE 97520
// exit ;
97518: GO 97567
// for i = 1 to 3 do
97520: LD_ADDR_VAR 0 3
97524: PUSH
97525: DOUBLE
97526: LD_INT 1
97528: DEC
97529: ST_TO_ADDR
97530: LD_INT 3
97532: PUSH
97533: FOR_TO
97534: IFFALSE 97565
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97536: LD_VAR 0 1
97540: PPUSH
97541: CALL_OW 250
97545: PPUSH
97546: LD_VAR 0 1
97550: PPUSH
97551: CALL_OW 251
97555: PPUSH
97556: LD_INT 1
97558: PPUSH
97559: CALL_OW 453
97563: GO 97533
97565: POP
97566: POP
// end ;
97567: LD_VAR 0 2
97571: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97572: LD_INT 0
97574: PPUSH
97575: PPUSH
97576: PPUSH
97577: PPUSH
97578: PPUSH
97579: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97580: LD_VAR 0 1
97584: NOT
97585: PUSH
97586: LD_VAR 0 2
97590: NOT
97591: OR
97592: PUSH
97593: LD_VAR 0 1
97597: PPUSH
97598: CALL_OW 314
97602: OR
97603: IFFALSE 97607
// exit ;
97605: GO 98048
// x := GetX ( enemy_unit ) ;
97607: LD_ADDR_VAR 0 7
97611: PUSH
97612: LD_VAR 0 2
97616: PPUSH
97617: CALL_OW 250
97621: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97622: LD_ADDR_VAR 0 8
97626: PUSH
97627: LD_VAR 0 2
97631: PPUSH
97632: CALL_OW 251
97636: ST_TO_ADDR
// if not x or not y then
97637: LD_VAR 0 7
97641: NOT
97642: PUSH
97643: LD_VAR 0 8
97647: NOT
97648: OR
97649: IFFALSE 97653
// exit ;
97651: GO 98048
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97653: LD_ADDR_VAR 0 6
97657: PUSH
97658: LD_VAR 0 7
97662: PPUSH
97663: LD_INT 0
97665: PPUSH
97666: LD_INT 4
97668: PPUSH
97669: CALL_OW 272
97673: PUSH
97674: LD_VAR 0 8
97678: PPUSH
97679: LD_INT 0
97681: PPUSH
97682: LD_INT 4
97684: PPUSH
97685: CALL_OW 273
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: PUSH
97694: LD_VAR 0 7
97698: PPUSH
97699: LD_INT 1
97701: PPUSH
97702: LD_INT 4
97704: PPUSH
97705: CALL_OW 272
97709: PUSH
97710: LD_VAR 0 8
97714: PPUSH
97715: LD_INT 1
97717: PPUSH
97718: LD_INT 4
97720: PPUSH
97721: CALL_OW 273
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: LD_VAR 0 7
97734: PPUSH
97735: LD_INT 2
97737: PPUSH
97738: LD_INT 4
97740: PPUSH
97741: CALL_OW 272
97745: PUSH
97746: LD_VAR 0 8
97750: PPUSH
97751: LD_INT 2
97753: PPUSH
97754: LD_INT 4
97756: PPUSH
97757: CALL_OW 273
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: PUSH
97766: LD_VAR 0 7
97770: PPUSH
97771: LD_INT 3
97773: PPUSH
97774: LD_INT 4
97776: PPUSH
97777: CALL_OW 272
97781: PUSH
97782: LD_VAR 0 8
97786: PPUSH
97787: LD_INT 3
97789: PPUSH
97790: LD_INT 4
97792: PPUSH
97793: CALL_OW 273
97797: PUSH
97798: EMPTY
97799: LIST
97800: LIST
97801: PUSH
97802: LD_VAR 0 7
97806: PPUSH
97807: LD_INT 4
97809: PPUSH
97810: LD_INT 4
97812: PPUSH
97813: CALL_OW 272
97817: PUSH
97818: LD_VAR 0 8
97822: PPUSH
97823: LD_INT 4
97825: PPUSH
97826: LD_INT 4
97828: PPUSH
97829: CALL_OW 273
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: PUSH
97838: LD_VAR 0 7
97842: PPUSH
97843: LD_INT 5
97845: PPUSH
97846: LD_INT 4
97848: PPUSH
97849: CALL_OW 272
97853: PUSH
97854: LD_VAR 0 8
97858: PPUSH
97859: LD_INT 5
97861: PPUSH
97862: LD_INT 4
97864: PPUSH
97865: CALL_OW 273
97869: PUSH
97870: EMPTY
97871: LIST
97872: LIST
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: ST_TO_ADDR
// for i = tmp downto 1 do
97882: LD_ADDR_VAR 0 4
97886: PUSH
97887: DOUBLE
97888: LD_VAR 0 6
97892: INC
97893: ST_TO_ADDR
97894: LD_INT 1
97896: PUSH
97897: FOR_DOWNTO
97898: IFFALSE 97999
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97900: LD_VAR 0 6
97904: PUSH
97905: LD_VAR 0 4
97909: ARRAY
97910: PUSH
97911: LD_INT 1
97913: ARRAY
97914: PPUSH
97915: LD_VAR 0 6
97919: PUSH
97920: LD_VAR 0 4
97924: ARRAY
97925: PUSH
97926: LD_INT 2
97928: ARRAY
97929: PPUSH
97930: CALL_OW 488
97934: NOT
97935: PUSH
97936: LD_VAR 0 6
97940: PUSH
97941: LD_VAR 0 4
97945: ARRAY
97946: PUSH
97947: LD_INT 1
97949: ARRAY
97950: PPUSH
97951: LD_VAR 0 6
97955: PUSH
97956: LD_VAR 0 4
97960: ARRAY
97961: PUSH
97962: LD_INT 2
97964: ARRAY
97965: PPUSH
97966: CALL_OW 428
97970: PUSH
97971: LD_INT 0
97973: NONEQUAL
97974: OR
97975: IFFALSE 97997
// tmp := Delete ( tmp , i ) ;
97977: LD_ADDR_VAR 0 6
97981: PUSH
97982: LD_VAR 0 6
97986: PPUSH
97987: LD_VAR 0 4
97991: PPUSH
97992: CALL_OW 3
97996: ST_TO_ADDR
97997: GO 97897
97999: POP
98000: POP
// j := GetClosestHex ( unit , tmp ) ;
98001: LD_ADDR_VAR 0 5
98005: PUSH
98006: LD_VAR 0 1
98010: PPUSH
98011: LD_VAR 0 6
98015: PPUSH
98016: CALL 97301 0 2
98020: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98021: LD_VAR 0 1
98025: PPUSH
98026: LD_VAR 0 5
98030: PUSH
98031: LD_INT 1
98033: ARRAY
98034: PPUSH
98035: LD_VAR 0 5
98039: PUSH
98040: LD_INT 2
98042: ARRAY
98043: PPUSH
98044: CALL_OW 111
// end ;
98048: LD_VAR 0 3
98052: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98053: LD_INT 0
98055: PPUSH
98056: PPUSH
98057: PPUSH
// uc_side = 0 ;
98058: LD_ADDR_OWVAR 20
98062: PUSH
98063: LD_INT 0
98065: ST_TO_ADDR
// uc_nation = 0 ;
98066: LD_ADDR_OWVAR 21
98070: PUSH
98071: LD_INT 0
98073: ST_TO_ADDR
// InitHc ;
98074: CALL_OW 19
// InitVc ;
98078: CALL_OW 20
// if mastodonts then
98082: LD_VAR 0 6
98086: IFFALSE 98153
// for i = 1 to mastodonts do
98088: LD_ADDR_VAR 0 11
98092: PUSH
98093: DOUBLE
98094: LD_INT 1
98096: DEC
98097: ST_TO_ADDR
98098: LD_VAR 0 6
98102: PUSH
98103: FOR_TO
98104: IFFALSE 98151
// begin vc_chassis := 31 ;
98106: LD_ADDR_OWVAR 37
98110: PUSH
98111: LD_INT 31
98113: ST_TO_ADDR
// vc_control := control_rider ;
98114: LD_ADDR_OWVAR 38
98118: PUSH
98119: LD_INT 4
98121: ST_TO_ADDR
// animal := CreateVehicle ;
98122: LD_ADDR_VAR 0 12
98126: PUSH
98127: CALL_OW 45
98131: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98132: LD_VAR 0 12
98136: PPUSH
98137: LD_VAR 0 8
98141: PPUSH
98142: LD_INT 0
98144: PPUSH
98145: CALL 104898 0 3
// end ;
98149: GO 98103
98151: POP
98152: POP
// if horses then
98153: LD_VAR 0 5
98157: IFFALSE 98224
// for i = 1 to horses do
98159: LD_ADDR_VAR 0 11
98163: PUSH
98164: DOUBLE
98165: LD_INT 1
98167: DEC
98168: ST_TO_ADDR
98169: LD_VAR 0 5
98173: PUSH
98174: FOR_TO
98175: IFFALSE 98222
// begin hc_class := 21 ;
98177: LD_ADDR_OWVAR 28
98181: PUSH
98182: LD_INT 21
98184: ST_TO_ADDR
// hc_gallery :=  ;
98185: LD_ADDR_OWVAR 33
98189: PUSH
98190: LD_STRING 
98192: ST_TO_ADDR
// animal := CreateHuman ;
98193: LD_ADDR_VAR 0 12
98197: PUSH
98198: CALL_OW 44
98202: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98203: LD_VAR 0 12
98207: PPUSH
98208: LD_VAR 0 8
98212: PPUSH
98213: LD_INT 0
98215: PPUSH
98216: CALL 104898 0 3
// end ;
98220: GO 98174
98222: POP
98223: POP
// if birds then
98224: LD_VAR 0 1
98228: IFFALSE 98295
// for i = 1 to birds do
98230: LD_ADDR_VAR 0 11
98234: PUSH
98235: DOUBLE
98236: LD_INT 1
98238: DEC
98239: ST_TO_ADDR
98240: LD_VAR 0 1
98244: PUSH
98245: FOR_TO
98246: IFFALSE 98293
// begin hc_class = 18 ;
98248: LD_ADDR_OWVAR 28
98252: PUSH
98253: LD_INT 18
98255: ST_TO_ADDR
// hc_gallery =  ;
98256: LD_ADDR_OWVAR 33
98260: PUSH
98261: LD_STRING 
98263: ST_TO_ADDR
// animal := CreateHuman ;
98264: LD_ADDR_VAR 0 12
98268: PUSH
98269: CALL_OW 44
98273: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98274: LD_VAR 0 12
98278: PPUSH
98279: LD_VAR 0 8
98283: PPUSH
98284: LD_INT 0
98286: PPUSH
98287: CALL 104898 0 3
// end ;
98291: GO 98245
98293: POP
98294: POP
// if tigers then
98295: LD_VAR 0 2
98299: IFFALSE 98383
// for i = 1 to tigers do
98301: LD_ADDR_VAR 0 11
98305: PUSH
98306: DOUBLE
98307: LD_INT 1
98309: DEC
98310: ST_TO_ADDR
98311: LD_VAR 0 2
98315: PUSH
98316: FOR_TO
98317: IFFALSE 98381
// begin hc_class = class_tiger ;
98319: LD_ADDR_OWVAR 28
98323: PUSH
98324: LD_INT 14
98326: ST_TO_ADDR
// hc_gallery =  ;
98327: LD_ADDR_OWVAR 33
98331: PUSH
98332: LD_STRING 
98334: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98335: LD_ADDR_OWVAR 35
98339: PUSH
98340: LD_INT 7
98342: NEG
98343: PPUSH
98344: LD_INT 7
98346: PPUSH
98347: CALL_OW 12
98351: ST_TO_ADDR
// animal := CreateHuman ;
98352: LD_ADDR_VAR 0 12
98356: PUSH
98357: CALL_OW 44
98361: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98362: LD_VAR 0 12
98366: PPUSH
98367: LD_VAR 0 8
98371: PPUSH
98372: LD_INT 0
98374: PPUSH
98375: CALL 104898 0 3
// end ;
98379: GO 98316
98381: POP
98382: POP
// if apemans then
98383: LD_VAR 0 3
98387: IFFALSE 98510
// for i = 1 to apemans do
98389: LD_ADDR_VAR 0 11
98393: PUSH
98394: DOUBLE
98395: LD_INT 1
98397: DEC
98398: ST_TO_ADDR
98399: LD_VAR 0 3
98403: PUSH
98404: FOR_TO
98405: IFFALSE 98508
// begin hc_class = class_apeman ;
98407: LD_ADDR_OWVAR 28
98411: PUSH
98412: LD_INT 12
98414: ST_TO_ADDR
// hc_gallery =  ;
98415: LD_ADDR_OWVAR 33
98419: PUSH
98420: LD_STRING 
98422: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98423: LD_ADDR_OWVAR 35
98427: PUSH
98428: LD_INT 5
98430: NEG
98431: PPUSH
98432: LD_INT 5
98434: PPUSH
98435: CALL_OW 12
98439: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98440: LD_ADDR_OWVAR 31
98444: PUSH
98445: LD_INT 1
98447: PPUSH
98448: LD_INT 3
98450: PPUSH
98451: CALL_OW 12
98455: PUSH
98456: LD_INT 1
98458: PPUSH
98459: LD_INT 3
98461: PPUSH
98462: CALL_OW 12
98466: PUSH
98467: LD_INT 0
98469: PUSH
98470: LD_INT 0
98472: PUSH
98473: EMPTY
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: ST_TO_ADDR
// animal := CreateHuman ;
98479: LD_ADDR_VAR 0 12
98483: PUSH
98484: CALL_OW 44
98488: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98489: LD_VAR 0 12
98493: PPUSH
98494: LD_VAR 0 8
98498: PPUSH
98499: LD_INT 0
98501: PPUSH
98502: CALL 104898 0 3
// end ;
98506: GO 98404
98508: POP
98509: POP
// if enchidnas then
98510: LD_VAR 0 4
98514: IFFALSE 98581
// for i = 1 to enchidnas do
98516: LD_ADDR_VAR 0 11
98520: PUSH
98521: DOUBLE
98522: LD_INT 1
98524: DEC
98525: ST_TO_ADDR
98526: LD_VAR 0 4
98530: PUSH
98531: FOR_TO
98532: IFFALSE 98579
// begin hc_class = 13 ;
98534: LD_ADDR_OWVAR 28
98538: PUSH
98539: LD_INT 13
98541: ST_TO_ADDR
// hc_gallery =  ;
98542: LD_ADDR_OWVAR 33
98546: PUSH
98547: LD_STRING 
98549: ST_TO_ADDR
// animal := CreateHuman ;
98550: LD_ADDR_VAR 0 12
98554: PUSH
98555: CALL_OW 44
98559: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98560: LD_VAR 0 12
98564: PPUSH
98565: LD_VAR 0 8
98569: PPUSH
98570: LD_INT 0
98572: PPUSH
98573: CALL 104898 0 3
// end ;
98577: GO 98531
98579: POP
98580: POP
// if fishes then
98581: LD_VAR 0 7
98585: IFFALSE 98652
// for i = 1 to fishes do
98587: LD_ADDR_VAR 0 11
98591: PUSH
98592: DOUBLE
98593: LD_INT 1
98595: DEC
98596: ST_TO_ADDR
98597: LD_VAR 0 7
98601: PUSH
98602: FOR_TO
98603: IFFALSE 98650
// begin hc_class = 20 ;
98605: LD_ADDR_OWVAR 28
98609: PUSH
98610: LD_INT 20
98612: ST_TO_ADDR
// hc_gallery =  ;
98613: LD_ADDR_OWVAR 33
98617: PUSH
98618: LD_STRING 
98620: ST_TO_ADDR
// animal := CreateHuman ;
98621: LD_ADDR_VAR 0 12
98625: PUSH
98626: CALL_OW 44
98630: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98631: LD_VAR 0 12
98635: PPUSH
98636: LD_VAR 0 9
98640: PPUSH
98641: LD_INT 0
98643: PPUSH
98644: CALL 104898 0 3
// end ;
98648: GO 98602
98650: POP
98651: POP
// end ;
98652: LD_VAR 0 10
98656: RET
// export function WantHeal ( sci , unit ) ; begin
98657: LD_INT 0
98659: PPUSH
// if GetTaskList ( sci ) > 0 then
98660: LD_VAR 0 1
98664: PPUSH
98665: CALL_OW 437
98669: PUSH
98670: LD_INT 0
98672: GREATER
98673: IFFALSE 98743
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98675: LD_VAR 0 1
98679: PPUSH
98680: CALL_OW 437
98684: PUSH
98685: LD_INT 1
98687: ARRAY
98688: PUSH
98689: LD_INT 1
98691: ARRAY
98692: PUSH
98693: LD_STRING l
98695: EQUAL
98696: PUSH
98697: LD_VAR 0 1
98701: PPUSH
98702: CALL_OW 437
98706: PUSH
98707: LD_INT 1
98709: ARRAY
98710: PUSH
98711: LD_INT 4
98713: ARRAY
98714: PUSH
98715: LD_VAR 0 2
98719: EQUAL
98720: AND
98721: IFFALSE 98733
// result := true else
98723: LD_ADDR_VAR 0 3
98727: PUSH
98728: LD_INT 1
98730: ST_TO_ADDR
98731: GO 98741
// result := false ;
98733: LD_ADDR_VAR 0 3
98737: PUSH
98738: LD_INT 0
98740: ST_TO_ADDR
// end else
98741: GO 98751
// result := false ;
98743: LD_ADDR_VAR 0 3
98747: PUSH
98748: LD_INT 0
98750: ST_TO_ADDR
// end ;
98751: LD_VAR 0 3
98755: RET
// export function HealTarget ( sci ) ; begin
98756: LD_INT 0
98758: PPUSH
// if not sci then
98759: LD_VAR 0 1
98763: NOT
98764: IFFALSE 98768
// exit ;
98766: GO 98833
// result := 0 ;
98768: LD_ADDR_VAR 0 2
98772: PUSH
98773: LD_INT 0
98775: ST_TO_ADDR
// if GetTaskList ( sci ) then
98776: LD_VAR 0 1
98780: PPUSH
98781: CALL_OW 437
98785: IFFALSE 98833
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98787: LD_VAR 0 1
98791: PPUSH
98792: CALL_OW 437
98796: PUSH
98797: LD_INT 1
98799: ARRAY
98800: PUSH
98801: LD_INT 1
98803: ARRAY
98804: PUSH
98805: LD_STRING l
98807: EQUAL
98808: IFFALSE 98833
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98810: LD_ADDR_VAR 0 2
98814: PUSH
98815: LD_VAR 0 1
98819: PPUSH
98820: CALL_OW 437
98824: PUSH
98825: LD_INT 1
98827: ARRAY
98828: PUSH
98829: LD_INT 4
98831: ARRAY
98832: ST_TO_ADDR
// end ;
98833: LD_VAR 0 2
98837: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98838: LD_INT 0
98840: PPUSH
98841: PPUSH
98842: PPUSH
98843: PPUSH
98844: PPUSH
98845: PPUSH
98846: PPUSH
98847: PPUSH
98848: PPUSH
98849: PPUSH
98850: PPUSH
98851: PPUSH
98852: PPUSH
98853: PPUSH
98854: PPUSH
98855: PPUSH
98856: PPUSH
98857: PPUSH
98858: PPUSH
98859: PPUSH
98860: PPUSH
98861: PPUSH
98862: PPUSH
98863: PPUSH
98864: PPUSH
98865: PPUSH
98866: PPUSH
98867: PPUSH
98868: PPUSH
98869: PPUSH
98870: PPUSH
98871: PPUSH
98872: PPUSH
98873: PPUSH
// if not list then
98874: LD_VAR 0 1
98878: NOT
98879: IFFALSE 98883
// exit ;
98881: GO 103509
// base := list [ 1 ] ;
98883: LD_ADDR_VAR 0 3
98887: PUSH
98888: LD_VAR 0 1
98892: PUSH
98893: LD_INT 1
98895: ARRAY
98896: ST_TO_ADDR
// group := list [ 2 ] ;
98897: LD_ADDR_VAR 0 4
98901: PUSH
98902: LD_VAR 0 1
98906: PUSH
98907: LD_INT 2
98909: ARRAY
98910: ST_TO_ADDR
// path := list [ 3 ] ;
98911: LD_ADDR_VAR 0 5
98915: PUSH
98916: LD_VAR 0 1
98920: PUSH
98921: LD_INT 3
98923: ARRAY
98924: ST_TO_ADDR
// flags := list [ 4 ] ;
98925: LD_ADDR_VAR 0 6
98929: PUSH
98930: LD_VAR 0 1
98934: PUSH
98935: LD_INT 4
98937: ARRAY
98938: ST_TO_ADDR
// mined := [ ] ;
98939: LD_ADDR_VAR 0 27
98943: PUSH
98944: EMPTY
98945: ST_TO_ADDR
// bombed := [ ] ;
98946: LD_ADDR_VAR 0 28
98950: PUSH
98951: EMPTY
98952: ST_TO_ADDR
// healers := [ ] ;
98953: LD_ADDR_VAR 0 31
98957: PUSH
98958: EMPTY
98959: ST_TO_ADDR
// to_heal := [ ] ;
98960: LD_ADDR_VAR 0 30
98964: PUSH
98965: EMPTY
98966: ST_TO_ADDR
// repairs := [ ] ;
98967: LD_ADDR_VAR 0 33
98971: PUSH
98972: EMPTY
98973: ST_TO_ADDR
// to_repair := [ ] ;
98974: LD_ADDR_VAR 0 32
98978: PUSH
98979: EMPTY
98980: ST_TO_ADDR
// if not group or not path then
98981: LD_VAR 0 4
98985: NOT
98986: PUSH
98987: LD_VAR 0 5
98991: NOT
98992: OR
98993: IFFALSE 98997
// exit ;
98995: GO 103509
// side := GetSide ( group [ 1 ] ) ;
98997: LD_ADDR_VAR 0 35
99001: PUSH
99002: LD_VAR 0 4
99006: PUSH
99007: LD_INT 1
99009: ARRAY
99010: PPUSH
99011: CALL_OW 255
99015: ST_TO_ADDR
// if flags then
99016: LD_VAR 0 6
99020: IFFALSE 99164
// begin f_ignore_area := flags [ 1 ] ;
99022: LD_ADDR_VAR 0 17
99026: PUSH
99027: LD_VAR 0 6
99031: PUSH
99032: LD_INT 1
99034: ARRAY
99035: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99036: LD_ADDR_VAR 0 18
99040: PUSH
99041: LD_VAR 0 6
99045: PUSH
99046: LD_INT 2
99048: ARRAY
99049: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99050: LD_ADDR_VAR 0 19
99054: PUSH
99055: LD_VAR 0 6
99059: PUSH
99060: LD_INT 3
99062: ARRAY
99063: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99064: LD_ADDR_VAR 0 20
99068: PUSH
99069: LD_VAR 0 6
99073: PUSH
99074: LD_INT 4
99076: ARRAY
99077: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99078: LD_ADDR_VAR 0 21
99082: PUSH
99083: LD_VAR 0 6
99087: PUSH
99088: LD_INT 5
99090: ARRAY
99091: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99092: LD_ADDR_VAR 0 22
99096: PUSH
99097: LD_VAR 0 6
99101: PUSH
99102: LD_INT 6
99104: ARRAY
99105: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99106: LD_ADDR_VAR 0 23
99110: PUSH
99111: LD_VAR 0 6
99115: PUSH
99116: LD_INT 7
99118: ARRAY
99119: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99120: LD_ADDR_VAR 0 24
99124: PUSH
99125: LD_VAR 0 6
99129: PUSH
99130: LD_INT 8
99132: ARRAY
99133: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99134: LD_ADDR_VAR 0 25
99138: PUSH
99139: LD_VAR 0 6
99143: PUSH
99144: LD_INT 9
99146: ARRAY
99147: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99148: LD_ADDR_VAR 0 26
99152: PUSH
99153: LD_VAR 0 6
99157: PUSH
99158: LD_INT 10
99160: ARRAY
99161: ST_TO_ADDR
// end else
99162: GO 99244
// begin f_ignore_area := false ;
99164: LD_ADDR_VAR 0 17
99168: PUSH
99169: LD_INT 0
99171: ST_TO_ADDR
// f_capture := false ;
99172: LD_ADDR_VAR 0 18
99176: PUSH
99177: LD_INT 0
99179: ST_TO_ADDR
// f_ignore_civ := false ;
99180: LD_ADDR_VAR 0 19
99184: PUSH
99185: LD_INT 0
99187: ST_TO_ADDR
// f_murder := false ;
99188: LD_ADDR_VAR 0 20
99192: PUSH
99193: LD_INT 0
99195: ST_TO_ADDR
// f_mines := false ;
99196: LD_ADDR_VAR 0 21
99200: PUSH
99201: LD_INT 0
99203: ST_TO_ADDR
// f_repair := false ;
99204: LD_ADDR_VAR 0 22
99208: PUSH
99209: LD_INT 0
99211: ST_TO_ADDR
// f_heal := false ;
99212: LD_ADDR_VAR 0 23
99216: PUSH
99217: LD_INT 0
99219: ST_TO_ADDR
// f_spacetime := false ;
99220: LD_ADDR_VAR 0 24
99224: PUSH
99225: LD_INT 0
99227: ST_TO_ADDR
// f_attack_depot := false ;
99228: LD_ADDR_VAR 0 25
99232: PUSH
99233: LD_INT 0
99235: ST_TO_ADDR
// f_crawl := false ;
99236: LD_ADDR_VAR 0 26
99240: PUSH
99241: LD_INT 0
99243: ST_TO_ADDR
// end ; if f_heal then
99244: LD_VAR 0 23
99248: IFFALSE 99275
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99250: LD_ADDR_VAR 0 31
99254: PUSH
99255: LD_VAR 0 4
99259: PPUSH
99260: LD_INT 25
99262: PUSH
99263: LD_INT 4
99265: PUSH
99266: EMPTY
99267: LIST
99268: LIST
99269: PPUSH
99270: CALL_OW 72
99274: ST_TO_ADDR
// if f_repair then
99275: LD_VAR 0 22
99279: IFFALSE 99306
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99281: LD_ADDR_VAR 0 33
99285: PUSH
99286: LD_VAR 0 4
99290: PPUSH
99291: LD_INT 25
99293: PUSH
99294: LD_INT 3
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: PPUSH
99301: CALL_OW 72
99305: ST_TO_ADDR
// units_path := [ ] ;
99306: LD_ADDR_VAR 0 16
99310: PUSH
99311: EMPTY
99312: ST_TO_ADDR
// for i = 1 to group do
99313: LD_ADDR_VAR 0 7
99317: PUSH
99318: DOUBLE
99319: LD_INT 1
99321: DEC
99322: ST_TO_ADDR
99323: LD_VAR 0 4
99327: PUSH
99328: FOR_TO
99329: IFFALSE 99358
// units_path := Replace ( units_path , i , path ) ;
99331: LD_ADDR_VAR 0 16
99335: PUSH
99336: LD_VAR 0 16
99340: PPUSH
99341: LD_VAR 0 7
99345: PPUSH
99346: LD_VAR 0 5
99350: PPUSH
99351: CALL_OW 1
99355: ST_TO_ADDR
99356: GO 99328
99358: POP
99359: POP
// repeat for i = group downto 1 do
99360: LD_ADDR_VAR 0 7
99364: PUSH
99365: DOUBLE
99366: LD_VAR 0 4
99370: INC
99371: ST_TO_ADDR
99372: LD_INT 1
99374: PUSH
99375: FOR_DOWNTO
99376: IFFALSE 103472
// begin wait ( 5 ) ;
99378: LD_INT 5
99380: PPUSH
99381: CALL_OW 67
// tmp := [ ] ;
99385: LD_ADDR_VAR 0 14
99389: PUSH
99390: EMPTY
99391: ST_TO_ADDR
// attacking := false ;
99392: LD_ADDR_VAR 0 29
99396: PUSH
99397: LD_INT 0
99399: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99400: LD_VAR 0 4
99404: PUSH
99405: LD_VAR 0 7
99409: ARRAY
99410: PPUSH
99411: CALL_OW 301
99415: PUSH
99416: LD_VAR 0 4
99420: PUSH
99421: LD_VAR 0 7
99425: ARRAY
99426: NOT
99427: OR
99428: IFFALSE 99537
// begin if GetType ( group [ i ] ) = unit_human then
99430: LD_VAR 0 4
99434: PUSH
99435: LD_VAR 0 7
99439: ARRAY
99440: PPUSH
99441: CALL_OW 247
99445: PUSH
99446: LD_INT 1
99448: EQUAL
99449: IFFALSE 99495
// begin to_heal := to_heal diff group [ i ] ;
99451: LD_ADDR_VAR 0 30
99455: PUSH
99456: LD_VAR 0 30
99460: PUSH
99461: LD_VAR 0 4
99465: PUSH
99466: LD_VAR 0 7
99470: ARRAY
99471: DIFF
99472: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99473: LD_ADDR_VAR 0 31
99477: PUSH
99478: LD_VAR 0 31
99482: PUSH
99483: LD_VAR 0 4
99487: PUSH
99488: LD_VAR 0 7
99492: ARRAY
99493: DIFF
99494: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99495: LD_ADDR_VAR 0 4
99499: PUSH
99500: LD_VAR 0 4
99504: PPUSH
99505: LD_VAR 0 7
99509: PPUSH
99510: CALL_OW 3
99514: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99515: LD_ADDR_VAR 0 16
99519: PUSH
99520: LD_VAR 0 16
99524: PPUSH
99525: LD_VAR 0 7
99529: PPUSH
99530: CALL_OW 3
99534: ST_TO_ADDR
// continue ;
99535: GO 99375
// end ; if f_repair then
99537: LD_VAR 0 22
99541: IFFALSE 100030
// begin if GetType ( group [ i ] ) = unit_vehicle then
99543: LD_VAR 0 4
99547: PUSH
99548: LD_VAR 0 7
99552: ARRAY
99553: PPUSH
99554: CALL_OW 247
99558: PUSH
99559: LD_INT 2
99561: EQUAL
99562: IFFALSE 99752
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99564: LD_VAR 0 4
99568: PUSH
99569: LD_VAR 0 7
99573: ARRAY
99574: PPUSH
99575: CALL_OW 256
99579: PUSH
99580: LD_INT 700
99582: LESS
99583: PUSH
99584: LD_VAR 0 4
99588: PUSH
99589: LD_VAR 0 7
99593: ARRAY
99594: PUSH
99595: LD_VAR 0 32
99599: IN
99600: NOT
99601: AND
99602: IFFALSE 99626
// to_repair := to_repair union group [ i ] ;
99604: LD_ADDR_VAR 0 32
99608: PUSH
99609: LD_VAR 0 32
99613: PUSH
99614: LD_VAR 0 4
99618: PUSH
99619: LD_VAR 0 7
99623: ARRAY
99624: UNION
99625: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99626: LD_VAR 0 4
99630: PUSH
99631: LD_VAR 0 7
99635: ARRAY
99636: PPUSH
99637: CALL_OW 256
99641: PUSH
99642: LD_INT 1000
99644: EQUAL
99645: PUSH
99646: LD_VAR 0 4
99650: PUSH
99651: LD_VAR 0 7
99655: ARRAY
99656: PUSH
99657: LD_VAR 0 32
99661: IN
99662: AND
99663: IFFALSE 99687
// to_repair := to_repair diff group [ i ] ;
99665: LD_ADDR_VAR 0 32
99669: PUSH
99670: LD_VAR 0 32
99674: PUSH
99675: LD_VAR 0 4
99679: PUSH
99680: LD_VAR 0 7
99684: ARRAY
99685: DIFF
99686: ST_TO_ADDR
// if group [ i ] in to_repair then
99687: LD_VAR 0 4
99691: PUSH
99692: LD_VAR 0 7
99696: ARRAY
99697: PUSH
99698: LD_VAR 0 32
99702: IN
99703: IFFALSE 99750
// begin if not IsInArea ( group [ i ] , f_repair ) then
99705: LD_VAR 0 4
99709: PUSH
99710: LD_VAR 0 7
99714: ARRAY
99715: PPUSH
99716: LD_VAR 0 22
99720: PPUSH
99721: CALL_OW 308
99725: NOT
99726: IFFALSE 99748
// ComMoveToArea ( group [ i ] , f_repair ) ;
99728: LD_VAR 0 4
99732: PUSH
99733: LD_VAR 0 7
99737: ARRAY
99738: PPUSH
99739: LD_VAR 0 22
99743: PPUSH
99744: CALL_OW 113
// continue ;
99748: GO 99375
// end ; end else
99750: GO 100030
// if group [ i ] in repairs then
99752: LD_VAR 0 4
99756: PUSH
99757: LD_VAR 0 7
99761: ARRAY
99762: PUSH
99763: LD_VAR 0 33
99767: IN
99768: IFFALSE 100030
// begin if IsInUnit ( group [ i ] ) then
99770: LD_VAR 0 4
99774: PUSH
99775: LD_VAR 0 7
99779: ARRAY
99780: PPUSH
99781: CALL_OW 310
99785: IFFALSE 99853
// begin z := IsInUnit ( group [ i ] ) ;
99787: LD_ADDR_VAR 0 13
99791: PUSH
99792: LD_VAR 0 4
99796: PUSH
99797: LD_VAR 0 7
99801: ARRAY
99802: PPUSH
99803: CALL_OW 310
99807: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99808: LD_VAR 0 13
99812: PUSH
99813: LD_VAR 0 32
99817: IN
99818: PUSH
99819: LD_VAR 0 13
99823: PPUSH
99824: LD_VAR 0 22
99828: PPUSH
99829: CALL_OW 308
99833: AND
99834: IFFALSE 99851
// ComExitVehicle ( group [ i ] ) ;
99836: LD_VAR 0 4
99840: PUSH
99841: LD_VAR 0 7
99845: ARRAY
99846: PPUSH
99847: CALL_OW 121
// end else
99851: GO 100030
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99853: LD_ADDR_VAR 0 13
99857: PUSH
99858: LD_VAR 0 4
99862: PPUSH
99863: LD_INT 95
99865: PUSH
99866: LD_VAR 0 22
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: PUSH
99875: LD_INT 58
99877: PUSH
99878: EMPTY
99879: LIST
99880: PUSH
99881: EMPTY
99882: LIST
99883: LIST
99884: PPUSH
99885: CALL_OW 72
99889: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99890: LD_VAR 0 4
99894: PUSH
99895: LD_VAR 0 7
99899: ARRAY
99900: PPUSH
99901: CALL_OW 314
99905: NOT
99906: IFFALSE 100028
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99908: LD_ADDR_VAR 0 10
99912: PUSH
99913: LD_VAR 0 13
99917: PPUSH
99918: LD_VAR 0 4
99922: PUSH
99923: LD_VAR 0 7
99927: ARRAY
99928: PPUSH
99929: CALL_OW 74
99933: ST_TO_ADDR
// if not x then
99934: LD_VAR 0 10
99938: NOT
99939: IFFALSE 99943
// continue ;
99941: GO 99375
// if GetLives ( x ) < 1000 then
99943: LD_VAR 0 10
99947: PPUSH
99948: CALL_OW 256
99952: PUSH
99953: LD_INT 1000
99955: LESS
99956: IFFALSE 99980
// ComRepairVehicle ( group [ i ] , x ) else
99958: LD_VAR 0 4
99962: PUSH
99963: LD_VAR 0 7
99967: ARRAY
99968: PPUSH
99969: LD_VAR 0 10
99973: PPUSH
99974: CALL_OW 129
99978: GO 100028
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99980: LD_VAR 0 23
99984: PUSH
99985: LD_VAR 0 4
99989: PUSH
99990: LD_VAR 0 7
99994: ARRAY
99995: PPUSH
99996: CALL_OW 256
100000: PUSH
100001: LD_INT 1000
100003: LESS
100004: AND
100005: NOT
100006: IFFALSE 100028
// ComEnterUnit ( group [ i ] , x ) ;
100008: LD_VAR 0 4
100012: PUSH
100013: LD_VAR 0 7
100017: ARRAY
100018: PPUSH
100019: LD_VAR 0 10
100023: PPUSH
100024: CALL_OW 120
// end ; continue ;
100028: GO 99375
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100030: LD_VAR 0 23
100034: PUSH
100035: LD_VAR 0 4
100039: PUSH
100040: LD_VAR 0 7
100044: ARRAY
100045: PPUSH
100046: CALL_OW 247
100050: PUSH
100051: LD_INT 1
100053: EQUAL
100054: AND
100055: IFFALSE 100533
// begin if group [ i ] in healers then
100057: LD_VAR 0 4
100061: PUSH
100062: LD_VAR 0 7
100066: ARRAY
100067: PUSH
100068: LD_VAR 0 31
100072: IN
100073: IFFALSE 100346
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100075: LD_VAR 0 4
100079: PUSH
100080: LD_VAR 0 7
100084: ARRAY
100085: PPUSH
100086: LD_VAR 0 23
100090: PPUSH
100091: CALL_OW 308
100095: NOT
100096: PUSH
100097: LD_VAR 0 4
100101: PUSH
100102: LD_VAR 0 7
100106: ARRAY
100107: PPUSH
100108: CALL_OW 314
100112: NOT
100113: AND
100114: IFFALSE 100138
// ComMoveToArea ( group [ i ] , f_heal ) else
100116: LD_VAR 0 4
100120: PUSH
100121: LD_VAR 0 7
100125: ARRAY
100126: PPUSH
100127: LD_VAR 0 23
100131: PPUSH
100132: CALL_OW 113
100136: GO 100344
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100138: LD_VAR 0 4
100142: PUSH
100143: LD_VAR 0 7
100147: ARRAY
100148: PPUSH
100149: CALL 98756 0 1
100153: PPUSH
100154: CALL_OW 256
100158: PUSH
100159: LD_INT 1000
100161: EQUAL
100162: IFFALSE 100181
// ComStop ( group [ i ] ) else
100164: LD_VAR 0 4
100168: PUSH
100169: LD_VAR 0 7
100173: ARRAY
100174: PPUSH
100175: CALL_OW 141
100179: GO 100344
// if not HasTask ( group [ i ] ) and to_heal then
100181: LD_VAR 0 4
100185: PUSH
100186: LD_VAR 0 7
100190: ARRAY
100191: PPUSH
100192: CALL_OW 314
100196: NOT
100197: PUSH
100198: LD_VAR 0 30
100202: AND
100203: IFFALSE 100344
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100205: LD_ADDR_VAR 0 13
100209: PUSH
100210: LD_VAR 0 30
100214: PPUSH
100215: LD_INT 3
100217: PUSH
100218: LD_INT 54
100220: PUSH
100221: EMPTY
100222: LIST
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PPUSH
100228: CALL_OW 72
100232: PPUSH
100233: LD_VAR 0 4
100237: PUSH
100238: LD_VAR 0 7
100242: ARRAY
100243: PPUSH
100244: CALL_OW 74
100248: ST_TO_ADDR
// if z then
100249: LD_VAR 0 13
100253: IFFALSE 100344
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100255: LD_INT 91
100257: PUSH
100258: LD_VAR 0 13
100262: PUSH
100263: LD_INT 10
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 81
100273: PUSH
100274: LD_VAR 0 13
100278: PPUSH
100279: CALL_OW 255
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: PUSH
100288: EMPTY
100289: LIST
100290: LIST
100291: PPUSH
100292: CALL_OW 69
100296: PUSH
100297: LD_INT 0
100299: EQUAL
100300: IFFALSE 100324
// ComHeal ( group [ i ] , z ) else
100302: LD_VAR 0 4
100306: PUSH
100307: LD_VAR 0 7
100311: ARRAY
100312: PPUSH
100313: LD_VAR 0 13
100317: PPUSH
100318: CALL_OW 128
100322: GO 100344
// ComMoveToArea ( group [ i ] , f_heal ) ;
100324: LD_VAR 0 4
100328: PUSH
100329: LD_VAR 0 7
100333: ARRAY
100334: PPUSH
100335: LD_VAR 0 23
100339: PPUSH
100340: CALL_OW 113
// end ; continue ;
100344: GO 99375
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100346: LD_VAR 0 4
100350: PUSH
100351: LD_VAR 0 7
100355: ARRAY
100356: PPUSH
100357: CALL_OW 256
100361: PUSH
100362: LD_INT 700
100364: LESS
100365: PUSH
100366: LD_VAR 0 4
100370: PUSH
100371: LD_VAR 0 7
100375: ARRAY
100376: PUSH
100377: LD_VAR 0 30
100381: IN
100382: NOT
100383: AND
100384: IFFALSE 100408
// to_heal := to_heal union group [ i ] ;
100386: LD_ADDR_VAR 0 30
100390: PUSH
100391: LD_VAR 0 30
100395: PUSH
100396: LD_VAR 0 4
100400: PUSH
100401: LD_VAR 0 7
100405: ARRAY
100406: UNION
100407: ST_TO_ADDR
// if group [ i ] in to_heal then
100408: LD_VAR 0 4
100412: PUSH
100413: LD_VAR 0 7
100417: ARRAY
100418: PUSH
100419: LD_VAR 0 30
100423: IN
100424: IFFALSE 100533
// begin if GetLives ( group [ i ] ) = 1000 then
100426: LD_VAR 0 4
100430: PUSH
100431: LD_VAR 0 7
100435: ARRAY
100436: PPUSH
100437: CALL_OW 256
100441: PUSH
100442: LD_INT 1000
100444: EQUAL
100445: IFFALSE 100471
// to_heal := to_heal diff group [ i ] else
100447: LD_ADDR_VAR 0 30
100451: PUSH
100452: LD_VAR 0 30
100456: PUSH
100457: LD_VAR 0 4
100461: PUSH
100462: LD_VAR 0 7
100466: ARRAY
100467: DIFF
100468: ST_TO_ADDR
100469: GO 100533
// begin if not IsInArea ( group [ i ] , to_heal ) then
100471: LD_VAR 0 4
100475: PUSH
100476: LD_VAR 0 7
100480: ARRAY
100481: PPUSH
100482: LD_VAR 0 30
100486: PPUSH
100487: CALL_OW 308
100491: NOT
100492: IFFALSE 100516
// ComMoveToArea ( group [ i ] , f_heal ) else
100494: LD_VAR 0 4
100498: PUSH
100499: LD_VAR 0 7
100503: ARRAY
100504: PPUSH
100505: LD_VAR 0 23
100509: PPUSH
100510: CALL_OW 113
100514: GO 100531
// ComHold ( group [ i ] ) ;
100516: LD_VAR 0 4
100520: PUSH
100521: LD_VAR 0 7
100525: ARRAY
100526: PPUSH
100527: CALL_OW 140
// continue ;
100531: GO 99375
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100533: LD_VAR 0 4
100537: PUSH
100538: LD_VAR 0 7
100542: ARRAY
100543: PPUSH
100544: LD_INT 10
100546: PPUSH
100547: CALL 97153 0 2
100551: NOT
100552: PUSH
100553: LD_VAR 0 16
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: PUSH
100564: EMPTY
100565: EQUAL
100566: NOT
100567: AND
100568: IFFALSE 100834
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100570: LD_VAR 0 4
100574: PUSH
100575: LD_VAR 0 7
100579: ARRAY
100580: PPUSH
100581: CALL_OW 262
100585: PUSH
100586: LD_INT 1
100588: PUSH
100589: LD_INT 2
100591: PUSH
100592: EMPTY
100593: LIST
100594: LIST
100595: IN
100596: IFFALSE 100637
// if GetFuel ( group [ i ] ) < 10 then
100598: LD_VAR 0 4
100602: PUSH
100603: LD_VAR 0 7
100607: ARRAY
100608: PPUSH
100609: CALL_OW 261
100613: PUSH
100614: LD_INT 10
100616: LESS
100617: IFFALSE 100637
// SetFuel ( group [ i ] , 12 ) ;
100619: LD_VAR 0 4
100623: PUSH
100624: LD_VAR 0 7
100628: ARRAY
100629: PPUSH
100630: LD_INT 12
100632: PPUSH
100633: CALL_OW 240
// if units_path [ i ] then
100637: LD_VAR 0 16
100641: PUSH
100642: LD_VAR 0 7
100646: ARRAY
100647: IFFALSE 100832
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100649: LD_VAR 0 4
100653: PUSH
100654: LD_VAR 0 7
100658: ARRAY
100659: PPUSH
100660: LD_VAR 0 16
100664: PUSH
100665: LD_VAR 0 7
100669: ARRAY
100670: PUSH
100671: LD_INT 1
100673: ARRAY
100674: PUSH
100675: LD_INT 1
100677: ARRAY
100678: PPUSH
100679: LD_VAR 0 16
100683: PUSH
100684: LD_VAR 0 7
100688: ARRAY
100689: PUSH
100690: LD_INT 1
100692: ARRAY
100693: PUSH
100694: LD_INT 2
100696: ARRAY
100697: PPUSH
100698: CALL_OW 297
100702: PUSH
100703: LD_INT 6
100705: GREATER
100706: IFFALSE 100781
// begin if not HasTask ( group [ i ] ) then
100708: LD_VAR 0 4
100712: PUSH
100713: LD_VAR 0 7
100717: ARRAY
100718: PPUSH
100719: CALL_OW 314
100723: NOT
100724: IFFALSE 100779
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100726: LD_VAR 0 4
100730: PUSH
100731: LD_VAR 0 7
100735: ARRAY
100736: PPUSH
100737: LD_VAR 0 16
100741: PUSH
100742: LD_VAR 0 7
100746: ARRAY
100747: PUSH
100748: LD_INT 1
100750: ARRAY
100751: PUSH
100752: LD_INT 1
100754: ARRAY
100755: PPUSH
100756: LD_VAR 0 16
100760: PUSH
100761: LD_VAR 0 7
100765: ARRAY
100766: PUSH
100767: LD_INT 1
100769: ARRAY
100770: PUSH
100771: LD_INT 2
100773: ARRAY
100774: PPUSH
100775: CALL_OW 114
// end else
100779: GO 100832
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100781: LD_ADDR_VAR 0 15
100785: PUSH
100786: LD_VAR 0 16
100790: PUSH
100791: LD_VAR 0 7
100795: ARRAY
100796: PPUSH
100797: LD_INT 1
100799: PPUSH
100800: CALL_OW 3
100804: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100805: LD_ADDR_VAR 0 16
100809: PUSH
100810: LD_VAR 0 16
100814: PPUSH
100815: LD_VAR 0 7
100819: PPUSH
100820: LD_VAR 0 15
100824: PPUSH
100825: CALL_OW 1
100829: ST_TO_ADDR
// continue ;
100830: GO 99375
// end ; end ; end else
100832: GO 103470
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100834: LD_ADDR_VAR 0 14
100838: PUSH
100839: LD_INT 81
100841: PUSH
100842: LD_VAR 0 4
100846: PUSH
100847: LD_VAR 0 7
100851: ARRAY
100852: PPUSH
100853: CALL_OW 255
100857: PUSH
100858: EMPTY
100859: LIST
100860: LIST
100861: PPUSH
100862: CALL_OW 69
100866: ST_TO_ADDR
// if not tmp then
100867: LD_VAR 0 14
100871: NOT
100872: IFFALSE 100876
// continue ;
100874: GO 99375
// if f_ignore_area then
100876: LD_VAR 0 17
100880: IFFALSE 100968
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100882: LD_ADDR_VAR 0 15
100886: PUSH
100887: LD_VAR 0 14
100891: PPUSH
100892: LD_INT 3
100894: PUSH
100895: LD_INT 92
100897: PUSH
100898: LD_VAR 0 17
100902: PUSH
100903: LD_INT 1
100905: ARRAY
100906: PUSH
100907: LD_VAR 0 17
100911: PUSH
100912: LD_INT 2
100914: ARRAY
100915: PUSH
100916: LD_VAR 0 17
100920: PUSH
100921: LD_INT 3
100923: ARRAY
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: LIST
100929: LIST
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PPUSH
100935: CALL_OW 72
100939: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100940: LD_VAR 0 14
100944: PUSH
100945: LD_VAR 0 15
100949: DIFF
100950: IFFALSE 100968
// tmp := tmp diff tmp2 ;
100952: LD_ADDR_VAR 0 14
100956: PUSH
100957: LD_VAR 0 14
100961: PUSH
100962: LD_VAR 0 15
100966: DIFF
100967: ST_TO_ADDR
// end ; if not f_murder then
100968: LD_VAR 0 20
100972: NOT
100973: IFFALSE 101031
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100975: LD_ADDR_VAR 0 15
100979: PUSH
100980: LD_VAR 0 14
100984: PPUSH
100985: LD_INT 3
100987: PUSH
100988: LD_INT 50
100990: PUSH
100991: EMPTY
100992: LIST
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: PPUSH
100998: CALL_OW 72
101002: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101003: LD_VAR 0 14
101007: PUSH
101008: LD_VAR 0 15
101012: DIFF
101013: IFFALSE 101031
// tmp := tmp diff tmp2 ;
101015: LD_ADDR_VAR 0 14
101019: PUSH
101020: LD_VAR 0 14
101024: PUSH
101025: LD_VAR 0 15
101029: DIFF
101030: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101031: LD_ADDR_VAR 0 14
101035: PUSH
101036: LD_VAR 0 4
101040: PUSH
101041: LD_VAR 0 7
101045: ARRAY
101046: PPUSH
101047: LD_VAR 0 14
101051: PPUSH
101052: LD_INT 1
101054: PPUSH
101055: LD_INT 1
101057: PPUSH
101058: CALL 70796 0 4
101062: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101063: LD_VAR 0 4
101067: PUSH
101068: LD_VAR 0 7
101072: ARRAY
101073: PPUSH
101074: CALL_OW 257
101078: PUSH
101079: LD_INT 1
101081: EQUAL
101082: IFFALSE 101530
// begin if WantPlant ( group [ i ] ) then
101084: LD_VAR 0 4
101088: PUSH
101089: LD_VAR 0 7
101093: ARRAY
101094: PPUSH
101095: CALL 70297 0 1
101099: IFFALSE 101103
// continue ;
101101: GO 99375
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101103: LD_VAR 0 18
101107: PUSH
101108: LD_VAR 0 4
101112: PUSH
101113: LD_VAR 0 7
101117: ARRAY
101118: PPUSH
101119: CALL_OW 310
101123: NOT
101124: AND
101125: PUSH
101126: LD_VAR 0 14
101130: PUSH
101131: LD_INT 1
101133: ARRAY
101134: PUSH
101135: LD_VAR 0 14
101139: PPUSH
101140: LD_INT 21
101142: PUSH
101143: LD_INT 2
101145: PUSH
101146: EMPTY
101147: LIST
101148: LIST
101149: PUSH
101150: LD_INT 58
101152: PUSH
101153: EMPTY
101154: LIST
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PPUSH
101160: CALL_OW 72
101164: IN
101165: AND
101166: IFFALSE 101202
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101168: LD_VAR 0 4
101172: PUSH
101173: LD_VAR 0 7
101177: ARRAY
101178: PPUSH
101179: LD_VAR 0 14
101183: PUSH
101184: LD_INT 1
101186: ARRAY
101187: PPUSH
101188: CALL_OW 120
// attacking := true ;
101192: LD_ADDR_VAR 0 29
101196: PUSH
101197: LD_INT 1
101199: ST_TO_ADDR
// continue ;
101200: GO 99375
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101202: LD_VAR 0 26
101206: PUSH
101207: LD_VAR 0 4
101211: PUSH
101212: LD_VAR 0 7
101216: ARRAY
101217: PPUSH
101218: CALL_OW 257
101222: PUSH
101223: LD_INT 1
101225: EQUAL
101226: AND
101227: PUSH
101228: LD_VAR 0 4
101232: PUSH
101233: LD_VAR 0 7
101237: ARRAY
101238: PPUSH
101239: CALL_OW 256
101243: PUSH
101244: LD_INT 800
101246: LESS
101247: AND
101248: PUSH
101249: LD_VAR 0 4
101253: PUSH
101254: LD_VAR 0 7
101258: ARRAY
101259: PPUSH
101260: CALL_OW 318
101264: NOT
101265: AND
101266: IFFALSE 101283
// ComCrawl ( group [ i ] ) ;
101268: LD_VAR 0 4
101272: PUSH
101273: LD_VAR 0 7
101277: ARRAY
101278: PPUSH
101279: CALL_OW 137
// if f_mines then
101283: LD_VAR 0 21
101287: IFFALSE 101530
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101289: LD_VAR 0 14
101293: PUSH
101294: LD_INT 1
101296: ARRAY
101297: PPUSH
101298: CALL_OW 247
101302: PUSH
101303: LD_INT 3
101305: EQUAL
101306: PUSH
101307: LD_VAR 0 14
101311: PUSH
101312: LD_INT 1
101314: ARRAY
101315: PUSH
101316: LD_VAR 0 27
101320: IN
101321: NOT
101322: AND
101323: IFFALSE 101530
// begin x := GetX ( tmp [ 1 ] ) ;
101325: LD_ADDR_VAR 0 10
101329: PUSH
101330: LD_VAR 0 14
101334: PUSH
101335: LD_INT 1
101337: ARRAY
101338: PPUSH
101339: CALL_OW 250
101343: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101344: LD_ADDR_VAR 0 11
101348: PUSH
101349: LD_VAR 0 14
101353: PUSH
101354: LD_INT 1
101356: ARRAY
101357: PPUSH
101358: CALL_OW 251
101362: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101363: LD_ADDR_VAR 0 12
101367: PUSH
101368: LD_VAR 0 4
101372: PUSH
101373: LD_VAR 0 7
101377: ARRAY
101378: PPUSH
101379: CALL 97238 0 1
101383: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101384: LD_VAR 0 4
101388: PUSH
101389: LD_VAR 0 7
101393: ARRAY
101394: PPUSH
101395: LD_VAR 0 10
101399: PPUSH
101400: LD_VAR 0 11
101404: PPUSH
101405: LD_VAR 0 14
101409: PUSH
101410: LD_INT 1
101412: ARRAY
101413: PPUSH
101414: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101418: LD_VAR 0 4
101422: PUSH
101423: LD_VAR 0 7
101427: ARRAY
101428: PPUSH
101429: LD_VAR 0 10
101433: PPUSH
101434: LD_VAR 0 12
101438: PPUSH
101439: LD_INT 7
101441: PPUSH
101442: CALL_OW 272
101446: PPUSH
101447: LD_VAR 0 11
101451: PPUSH
101452: LD_VAR 0 12
101456: PPUSH
101457: LD_INT 7
101459: PPUSH
101460: CALL_OW 273
101464: PPUSH
101465: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101469: LD_VAR 0 4
101473: PUSH
101474: LD_VAR 0 7
101478: ARRAY
101479: PPUSH
101480: LD_INT 71
101482: PPUSH
101483: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101487: LD_ADDR_VAR 0 27
101491: PUSH
101492: LD_VAR 0 27
101496: PPUSH
101497: LD_VAR 0 27
101501: PUSH
101502: LD_INT 1
101504: PLUS
101505: PPUSH
101506: LD_VAR 0 14
101510: PUSH
101511: LD_INT 1
101513: ARRAY
101514: PPUSH
101515: CALL_OW 1
101519: ST_TO_ADDR
// attacking := true ;
101520: LD_ADDR_VAR 0 29
101524: PUSH
101525: LD_INT 1
101527: ST_TO_ADDR
// continue ;
101528: GO 99375
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101530: LD_VAR 0 4
101534: PUSH
101535: LD_VAR 0 7
101539: ARRAY
101540: PPUSH
101541: CALL_OW 257
101545: PUSH
101546: LD_INT 17
101548: EQUAL
101549: PUSH
101550: LD_VAR 0 4
101554: PUSH
101555: LD_VAR 0 7
101559: ARRAY
101560: PPUSH
101561: CALL_OW 110
101565: PUSH
101566: LD_INT 71
101568: EQUAL
101569: NOT
101570: AND
101571: IFFALSE 101717
// begin attacking := false ;
101573: LD_ADDR_VAR 0 29
101577: PUSH
101578: LD_INT 0
101580: ST_TO_ADDR
// k := 5 ;
101581: LD_ADDR_VAR 0 9
101585: PUSH
101586: LD_INT 5
101588: ST_TO_ADDR
// if tmp < k then
101589: LD_VAR 0 14
101593: PUSH
101594: LD_VAR 0 9
101598: LESS
101599: IFFALSE 101611
// k := tmp ;
101601: LD_ADDR_VAR 0 9
101605: PUSH
101606: LD_VAR 0 14
101610: ST_TO_ADDR
// for j = 1 to k do
101611: LD_ADDR_VAR 0 8
101615: PUSH
101616: DOUBLE
101617: LD_INT 1
101619: DEC
101620: ST_TO_ADDR
101621: LD_VAR 0 9
101625: PUSH
101626: FOR_TO
101627: IFFALSE 101715
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101629: LD_VAR 0 14
101633: PUSH
101634: LD_VAR 0 8
101638: ARRAY
101639: PUSH
101640: LD_VAR 0 14
101644: PPUSH
101645: LD_INT 58
101647: PUSH
101648: EMPTY
101649: LIST
101650: PPUSH
101651: CALL_OW 72
101655: IN
101656: NOT
101657: IFFALSE 101713
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101659: LD_VAR 0 4
101663: PUSH
101664: LD_VAR 0 7
101668: ARRAY
101669: PPUSH
101670: LD_VAR 0 14
101674: PUSH
101675: LD_VAR 0 8
101679: ARRAY
101680: PPUSH
101681: CALL_OW 115
// attacking := true ;
101685: LD_ADDR_VAR 0 29
101689: PUSH
101690: LD_INT 1
101692: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101693: LD_VAR 0 4
101697: PUSH
101698: LD_VAR 0 7
101702: ARRAY
101703: PPUSH
101704: LD_INT 71
101706: PPUSH
101707: CALL_OW 109
// continue ;
101711: GO 101626
// end ; end ;
101713: GO 101626
101715: POP
101716: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101717: LD_VAR 0 4
101721: PUSH
101722: LD_VAR 0 7
101726: ARRAY
101727: PPUSH
101728: CALL_OW 257
101732: PUSH
101733: LD_INT 8
101735: EQUAL
101736: PUSH
101737: LD_VAR 0 4
101741: PUSH
101742: LD_VAR 0 7
101746: ARRAY
101747: PPUSH
101748: CALL_OW 264
101752: PUSH
101753: LD_INT 28
101755: PUSH
101756: LD_INT 45
101758: PUSH
101759: LD_INT 7
101761: PUSH
101762: LD_INT 47
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: LIST
101769: LIST
101770: IN
101771: OR
101772: IFFALSE 102002
// begin attacking := false ;
101774: LD_ADDR_VAR 0 29
101778: PUSH
101779: LD_INT 0
101781: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101782: LD_VAR 0 14
101786: PUSH
101787: LD_INT 1
101789: ARRAY
101790: PPUSH
101791: CALL_OW 266
101795: PUSH
101796: LD_INT 32
101798: PUSH
101799: LD_INT 31
101801: PUSH
101802: LD_INT 33
101804: PUSH
101805: LD_INT 4
101807: PUSH
101808: LD_INT 5
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: LIST
101815: LIST
101816: LIST
101817: IN
101818: IFFALSE 102002
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101820: LD_ADDR_VAR 0 9
101824: PUSH
101825: LD_VAR 0 14
101829: PUSH
101830: LD_INT 1
101832: ARRAY
101833: PPUSH
101834: CALL_OW 266
101838: PPUSH
101839: LD_VAR 0 14
101843: PUSH
101844: LD_INT 1
101846: ARRAY
101847: PPUSH
101848: CALL_OW 250
101852: PPUSH
101853: LD_VAR 0 14
101857: PUSH
101858: LD_INT 1
101860: ARRAY
101861: PPUSH
101862: CALL_OW 251
101866: PPUSH
101867: LD_VAR 0 14
101871: PUSH
101872: LD_INT 1
101874: ARRAY
101875: PPUSH
101876: CALL_OW 254
101880: PPUSH
101881: LD_VAR 0 14
101885: PUSH
101886: LD_INT 1
101888: ARRAY
101889: PPUSH
101890: CALL_OW 248
101894: PPUSH
101895: LD_INT 0
101897: PPUSH
101898: CALL 78608 0 6
101902: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101903: LD_ADDR_VAR 0 8
101907: PUSH
101908: LD_VAR 0 4
101912: PUSH
101913: LD_VAR 0 7
101917: ARRAY
101918: PPUSH
101919: LD_VAR 0 9
101923: PPUSH
101924: CALL 97301 0 2
101928: ST_TO_ADDR
// if j then
101929: LD_VAR 0 8
101933: IFFALSE 102002
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101935: LD_VAR 0 8
101939: PUSH
101940: LD_INT 1
101942: ARRAY
101943: PPUSH
101944: LD_VAR 0 8
101948: PUSH
101949: LD_INT 2
101951: ARRAY
101952: PPUSH
101953: CALL_OW 488
101957: IFFALSE 102002
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101959: LD_VAR 0 4
101963: PUSH
101964: LD_VAR 0 7
101968: ARRAY
101969: PPUSH
101970: LD_VAR 0 8
101974: PUSH
101975: LD_INT 1
101977: ARRAY
101978: PPUSH
101979: LD_VAR 0 8
101983: PUSH
101984: LD_INT 2
101986: ARRAY
101987: PPUSH
101988: CALL_OW 116
// attacking := true ;
101992: LD_ADDR_VAR 0 29
101996: PUSH
101997: LD_INT 1
101999: ST_TO_ADDR
// continue ;
102000: GO 99375
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102002: LD_VAR 0 4
102006: PUSH
102007: LD_VAR 0 7
102011: ARRAY
102012: PPUSH
102013: CALL_OW 265
102017: PUSH
102018: LD_INT 11
102020: EQUAL
102021: IFFALSE 102299
// begin k := 10 ;
102023: LD_ADDR_VAR 0 9
102027: PUSH
102028: LD_INT 10
102030: ST_TO_ADDR
// x := 0 ;
102031: LD_ADDR_VAR 0 10
102035: PUSH
102036: LD_INT 0
102038: ST_TO_ADDR
// if tmp < k then
102039: LD_VAR 0 14
102043: PUSH
102044: LD_VAR 0 9
102048: LESS
102049: IFFALSE 102061
// k := tmp ;
102051: LD_ADDR_VAR 0 9
102055: PUSH
102056: LD_VAR 0 14
102060: ST_TO_ADDR
// for j = k downto 1 do
102061: LD_ADDR_VAR 0 8
102065: PUSH
102066: DOUBLE
102067: LD_VAR 0 9
102071: INC
102072: ST_TO_ADDR
102073: LD_INT 1
102075: PUSH
102076: FOR_DOWNTO
102077: IFFALSE 102152
// begin if GetType ( tmp [ j ] ) = unit_human then
102079: LD_VAR 0 14
102083: PUSH
102084: LD_VAR 0 8
102088: ARRAY
102089: PPUSH
102090: CALL_OW 247
102094: PUSH
102095: LD_INT 1
102097: EQUAL
102098: IFFALSE 102150
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102100: LD_VAR 0 4
102104: PUSH
102105: LD_VAR 0 7
102109: ARRAY
102110: PPUSH
102111: LD_VAR 0 14
102115: PUSH
102116: LD_VAR 0 8
102120: ARRAY
102121: PPUSH
102122: CALL 97572 0 2
// x := tmp [ j ] ;
102126: LD_ADDR_VAR 0 10
102130: PUSH
102131: LD_VAR 0 14
102135: PUSH
102136: LD_VAR 0 8
102140: ARRAY
102141: ST_TO_ADDR
// attacking := true ;
102142: LD_ADDR_VAR 0 29
102146: PUSH
102147: LD_INT 1
102149: ST_TO_ADDR
// end ; end ;
102150: GO 102076
102152: POP
102153: POP
// if not x then
102154: LD_VAR 0 10
102158: NOT
102159: IFFALSE 102299
// begin attacking := true ;
102161: LD_ADDR_VAR 0 29
102165: PUSH
102166: LD_INT 1
102168: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102169: LD_VAR 0 4
102173: PUSH
102174: LD_VAR 0 7
102178: ARRAY
102179: PPUSH
102180: CALL_OW 250
102184: PPUSH
102185: LD_VAR 0 4
102189: PUSH
102190: LD_VAR 0 7
102194: ARRAY
102195: PPUSH
102196: CALL_OW 251
102200: PPUSH
102201: CALL_OW 546
102205: PUSH
102206: LD_INT 2
102208: ARRAY
102209: PUSH
102210: LD_VAR 0 14
102214: PUSH
102215: LD_INT 1
102217: ARRAY
102218: PPUSH
102219: CALL_OW 250
102223: PPUSH
102224: LD_VAR 0 14
102228: PUSH
102229: LD_INT 1
102231: ARRAY
102232: PPUSH
102233: CALL_OW 251
102237: PPUSH
102238: CALL_OW 546
102242: PUSH
102243: LD_INT 2
102245: ARRAY
102246: EQUAL
102247: IFFALSE 102275
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102249: LD_VAR 0 4
102253: PUSH
102254: LD_VAR 0 7
102258: ARRAY
102259: PPUSH
102260: LD_VAR 0 14
102264: PUSH
102265: LD_INT 1
102267: ARRAY
102268: PPUSH
102269: CALL 97572 0 2
102273: GO 102299
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102275: LD_VAR 0 4
102279: PUSH
102280: LD_VAR 0 7
102284: ARRAY
102285: PPUSH
102286: LD_VAR 0 14
102290: PUSH
102291: LD_INT 1
102293: ARRAY
102294: PPUSH
102295: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102299: LD_VAR 0 4
102303: PUSH
102304: LD_VAR 0 7
102308: ARRAY
102309: PPUSH
102310: CALL_OW 264
102314: PUSH
102315: LD_INT 29
102317: EQUAL
102318: IFFALSE 102684
// begin if WantsToAttack ( group [ i ] ) in bombed then
102320: LD_VAR 0 4
102324: PUSH
102325: LD_VAR 0 7
102329: ARRAY
102330: PPUSH
102331: CALL_OW 319
102335: PUSH
102336: LD_VAR 0 28
102340: IN
102341: IFFALSE 102345
// continue ;
102343: GO 99375
// k := 8 ;
102345: LD_ADDR_VAR 0 9
102349: PUSH
102350: LD_INT 8
102352: ST_TO_ADDR
// x := 0 ;
102353: LD_ADDR_VAR 0 10
102357: PUSH
102358: LD_INT 0
102360: ST_TO_ADDR
// if tmp < k then
102361: LD_VAR 0 14
102365: PUSH
102366: LD_VAR 0 9
102370: LESS
102371: IFFALSE 102383
// k := tmp ;
102373: LD_ADDR_VAR 0 9
102377: PUSH
102378: LD_VAR 0 14
102382: ST_TO_ADDR
// for j = 1 to k do
102383: LD_ADDR_VAR 0 8
102387: PUSH
102388: DOUBLE
102389: LD_INT 1
102391: DEC
102392: ST_TO_ADDR
102393: LD_VAR 0 9
102397: PUSH
102398: FOR_TO
102399: IFFALSE 102531
// begin if GetType ( tmp [ j ] ) = unit_building then
102401: LD_VAR 0 14
102405: PUSH
102406: LD_VAR 0 8
102410: ARRAY
102411: PPUSH
102412: CALL_OW 247
102416: PUSH
102417: LD_INT 3
102419: EQUAL
102420: IFFALSE 102529
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102422: LD_VAR 0 14
102426: PUSH
102427: LD_VAR 0 8
102431: ARRAY
102432: PUSH
102433: LD_VAR 0 28
102437: IN
102438: NOT
102439: PUSH
102440: LD_VAR 0 14
102444: PUSH
102445: LD_VAR 0 8
102449: ARRAY
102450: PPUSH
102451: CALL_OW 313
102455: AND
102456: IFFALSE 102529
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102458: LD_VAR 0 4
102462: PUSH
102463: LD_VAR 0 7
102467: ARRAY
102468: PPUSH
102469: LD_VAR 0 14
102473: PUSH
102474: LD_VAR 0 8
102478: ARRAY
102479: PPUSH
102480: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102484: LD_ADDR_VAR 0 28
102488: PUSH
102489: LD_VAR 0 28
102493: PPUSH
102494: LD_VAR 0 28
102498: PUSH
102499: LD_INT 1
102501: PLUS
102502: PPUSH
102503: LD_VAR 0 14
102507: PUSH
102508: LD_VAR 0 8
102512: ARRAY
102513: PPUSH
102514: CALL_OW 1
102518: ST_TO_ADDR
// attacking := true ;
102519: LD_ADDR_VAR 0 29
102523: PUSH
102524: LD_INT 1
102526: ST_TO_ADDR
// break ;
102527: GO 102531
// end ; end ;
102529: GO 102398
102531: POP
102532: POP
// if not attacking and f_attack_depot then
102533: LD_VAR 0 29
102537: NOT
102538: PUSH
102539: LD_VAR 0 25
102543: AND
102544: IFFALSE 102639
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102546: LD_ADDR_VAR 0 13
102550: PUSH
102551: LD_VAR 0 14
102555: PPUSH
102556: LD_INT 2
102558: PUSH
102559: LD_INT 30
102561: PUSH
102562: LD_INT 0
102564: PUSH
102565: EMPTY
102566: LIST
102567: LIST
102568: PUSH
102569: LD_INT 30
102571: PUSH
102572: LD_INT 1
102574: PUSH
102575: EMPTY
102576: LIST
102577: LIST
102578: PUSH
102579: EMPTY
102580: LIST
102581: LIST
102582: LIST
102583: PPUSH
102584: CALL_OW 72
102588: ST_TO_ADDR
// if z then
102589: LD_VAR 0 13
102593: IFFALSE 102639
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102595: LD_VAR 0 4
102599: PUSH
102600: LD_VAR 0 7
102604: ARRAY
102605: PPUSH
102606: LD_VAR 0 13
102610: PPUSH
102611: LD_VAR 0 4
102615: PUSH
102616: LD_VAR 0 7
102620: ARRAY
102621: PPUSH
102622: CALL_OW 74
102626: PPUSH
102627: CALL_OW 115
// attacking := true ;
102631: LD_ADDR_VAR 0 29
102635: PUSH
102636: LD_INT 1
102638: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102639: LD_VAR 0 4
102643: PUSH
102644: LD_VAR 0 7
102648: ARRAY
102649: PPUSH
102650: CALL_OW 256
102654: PUSH
102655: LD_INT 500
102657: LESS
102658: IFFALSE 102684
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102660: LD_VAR 0 4
102664: PUSH
102665: LD_VAR 0 7
102669: ARRAY
102670: PPUSH
102671: LD_VAR 0 14
102675: PUSH
102676: LD_INT 1
102678: ARRAY
102679: PPUSH
102680: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102684: LD_VAR 0 4
102688: PUSH
102689: LD_VAR 0 7
102693: ARRAY
102694: PPUSH
102695: CALL_OW 264
102699: PUSH
102700: LD_INT 49
102702: EQUAL
102703: IFFALSE 102824
// begin if not HasTask ( group [ i ] ) then
102705: LD_VAR 0 4
102709: PUSH
102710: LD_VAR 0 7
102714: ARRAY
102715: PPUSH
102716: CALL_OW 314
102720: NOT
102721: IFFALSE 102824
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102723: LD_ADDR_VAR 0 9
102727: PUSH
102728: LD_INT 81
102730: PUSH
102731: LD_VAR 0 4
102735: PUSH
102736: LD_VAR 0 7
102740: ARRAY
102741: PPUSH
102742: CALL_OW 255
102746: PUSH
102747: EMPTY
102748: LIST
102749: LIST
102750: PPUSH
102751: CALL_OW 69
102755: PPUSH
102756: LD_VAR 0 4
102760: PUSH
102761: LD_VAR 0 7
102765: ARRAY
102766: PPUSH
102767: CALL_OW 74
102771: ST_TO_ADDR
// if k then
102772: LD_VAR 0 9
102776: IFFALSE 102824
// if GetDistUnits ( group [ i ] , k ) > 10 then
102778: LD_VAR 0 4
102782: PUSH
102783: LD_VAR 0 7
102787: ARRAY
102788: PPUSH
102789: LD_VAR 0 9
102793: PPUSH
102794: CALL_OW 296
102798: PUSH
102799: LD_INT 10
102801: GREATER
102802: IFFALSE 102824
// ComMoveUnit ( group [ i ] , k ) ;
102804: LD_VAR 0 4
102808: PUSH
102809: LD_VAR 0 7
102813: ARRAY
102814: PPUSH
102815: LD_VAR 0 9
102819: PPUSH
102820: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102824: LD_VAR 0 4
102828: PUSH
102829: LD_VAR 0 7
102833: ARRAY
102834: PPUSH
102835: CALL_OW 256
102839: PUSH
102840: LD_INT 250
102842: LESS
102843: PUSH
102844: LD_VAR 0 4
102848: PUSH
102849: LD_VAR 0 7
102853: ARRAY
102854: PUSH
102855: LD_INT 21
102857: PUSH
102858: LD_INT 2
102860: PUSH
102861: EMPTY
102862: LIST
102863: LIST
102864: PUSH
102865: LD_INT 23
102867: PUSH
102868: LD_INT 2
102870: PUSH
102871: EMPTY
102872: LIST
102873: LIST
102874: PUSH
102875: EMPTY
102876: LIST
102877: LIST
102878: PPUSH
102879: CALL_OW 69
102883: IN
102884: AND
102885: IFFALSE 103010
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102887: LD_ADDR_VAR 0 9
102891: PUSH
102892: LD_OWVAR 3
102896: PUSH
102897: LD_VAR 0 4
102901: PUSH
102902: LD_VAR 0 7
102906: ARRAY
102907: DIFF
102908: PPUSH
102909: LD_VAR 0 4
102913: PUSH
102914: LD_VAR 0 7
102918: ARRAY
102919: PPUSH
102920: CALL_OW 74
102924: ST_TO_ADDR
// if not k then
102925: LD_VAR 0 9
102929: NOT
102930: IFFALSE 102934
// continue ;
102932: GO 99375
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102934: LD_VAR 0 9
102938: PUSH
102939: LD_INT 81
102941: PUSH
102942: LD_VAR 0 4
102946: PUSH
102947: LD_VAR 0 7
102951: ARRAY
102952: PPUSH
102953: CALL_OW 255
102957: PUSH
102958: EMPTY
102959: LIST
102960: LIST
102961: PPUSH
102962: CALL_OW 69
102966: IN
102967: PUSH
102968: LD_VAR 0 9
102972: PPUSH
102973: LD_VAR 0 4
102977: PUSH
102978: LD_VAR 0 7
102982: ARRAY
102983: PPUSH
102984: CALL_OW 296
102988: PUSH
102989: LD_INT 5
102991: LESS
102992: AND
102993: IFFALSE 103010
// ComAutodestruct ( group [ i ] ) ;
102995: LD_VAR 0 4
102999: PUSH
103000: LD_VAR 0 7
103004: ARRAY
103005: PPUSH
103006: CALL 97470 0 1
// end ; if f_attack_depot then
103010: LD_VAR 0 25
103014: IFFALSE 103126
// begin k := 6 ;
103016: LD_ADDR_VAR 0 9
103020: PUSH
103021: LD_INT 6
103023: ST_TO_ADDR
// if tmp < k then
103024: LD_VAR 0 14
103028: PUSH
103029: LD_VAR 0 9
103033: LESS
103034: IFFALSE 103046
// k := tmp ;
103036: LD_ADDR_VAR 0 9
103040: PUSH
103041: LD_VAR 0 14
103045: ST_TO_ADDR
// for j = 1 to k do
103046: LD_ADDR_VAR 0 8
103050: PUSH
103051: DOUBLE
103052: LD_INT 1
103054: DEC
103055: ST_TO_ADDR
103056: LD_VAR 0 9
103060: PUSH
103061: FOR_TO
103062: IFFALSE 103124
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103064: LD_VAR 0 8
103068: PPUSH
103069: CALL_OW 266
103073: PUSH
103074: LD_INT 0
103076: PUSH
103077: LD_INT 1
103079: PUSH
103080: EMPTY
103081: LIST
103082: LIST
103083: IN
103084: IFFALSE 103122
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103086: LD_VAR 0 4
103090: PUSH
103091: LD_VAR 0 7
103095: ARRAY
103096: PPUSH
103097: LD_VAR 0 14
103101: PUSH
103102: LD_VAR 0 8
103106: ARRAY
103107: PPUSH
103108: CALL_OW 115
// attacking := true ;
103112: LD_ADDR_VAR 0 29
103116: PUSH
103117: LD_INT 1
103119: ST_TO_ADDR
// break ;
103120: GO 103124
// end ;
103122: GO 103061
103124: POP
103125: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103126: LD_VAR 0 4
103130: PUSH
103131: LD_VAR 0 7
103135: ARRAY
103136: PPUSH
103137: CALL_OW 302
103141: PUSH
103142: LD_VAR 0 29
103146: NOT
103147: AND
103148: IFFALSE 103470
// begin if GetTag ( group [ i ] ) = 71 then
103150: LD_VAR 0 4
103154: PUSH
103155: LD_VAR 0 7
103159: ARRAY
103160: PPUSH
103161: CALL_OW 110
103165: PUSH
103166: LD_INT 71
103168: EQUAL
103169: IFFALSE 103210
// begin if HasTask ( group [ i ] ) then
103171: LD_VAR 0 4
103175: PUSH
103176: LD_VAR 0 7
103180: ARRAY
103181: PPUSH
103182: CALL_OW 314
103186: IFFALSE 103192
// continue else
103188: GO 99375
103190: GO 103210
// SetTag ( group [ i ] , 0 ) ;
103192: LD_VAR 0 4
103196: PUSH
103197: LD_VAR 0 7
103201: ARRAY
103202: PPUSH
103203: LD_INT 0
103205: PPUSH
103206: CALL_OW 109
// end ; k := 8 ;
103210: LD_ADDR_VAR 0 9
103214: PUSH
103215: LD_INT 8
103217: ST_TO_ADDR
// x := 0 ;
103218: LD_ADDR_VAR 0 10
103222: PUSH
103223: LD_INT 0
103225: ST_TO_ADDR
// if tmp < k then
103226: LD_VAR 0 14
103230: PUSH
103231: LD_VAR 0 9
103235: LESS
103236: IFFALSE 103248
// k := tmp ;
103238: LD_ADDR_VAR 0 9
103242: PUSH
103243: LD_VAR 0 14
103247: ST_TO_ADDR
// for j = 1 to k do
103248: LD_ADDR_VAR 0 8
103252: PUSH
103253: DOUBLE
103254: LD_INT 1
103256: DEC
103257: ST_TO_ADDR
103258: LD_VAR 0 9
103262: PUSH
103263: FOR_TO
103264: IFFALSE 103362
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103266: LD_VAR 0 14
103270: PUSH
103271: LD_VAR 0 8
103275: ARRAY
103276: PPUSH
103277: CALL_OW 247
103281: PUSH
103282: LD_INT 1
103284: EQUAL
103285: PUSH
103286: LD_VAR 0 14
103290: PUSH
103291: LD_VAR 0 8
103295: ARRAY
103296: PPUSH
103297: CALL_OW 256
103301: PUSH
103302: LD_INT 250
103304: LESS
103305: PUSH
103306: LD_VAR 0 20
103310: AND
103311: PUSH
103312: LD_VAR 0 20
103316: NOT
103317: PUSH
103318: LD_VAR 0 14
103322: PUSH
103323: LD_VAR 0 8
103327: ARRAY
103328: PPUSH
103329: CALL_OW 256
103333: PUSH
103334: LD_INT 250
103336: GREATEREQUAL
103337: AND
103338: OR
103339: AND
103340: IFFALSE 103360
// begin x := tmp [ j ] ;
103342: LD_ADDR_VAR 0 10
103346: PUSH
103347: LD_VAR 0 14
103351: PUSH
103352: LD_VAR 0 8
103356: ARRAY
103357: ST_TO_ADDR
// break ;
103358: GO 103362
// end ;
103360: GO 103263
103362: POP
103363: POP
// if x then
103364: LD_VAR 0 10
103368: IFFALSE 103392
// ComAttackUnit ( group [ i ] , x ) else
103370: LD_VAR 0 4
103374: PUSH
103375: LD_VAR 0 7
103379: ARRAY
103380: PPUSH
103381: LD_VAR 0 10
103385: PPUSH
103386: CALL_OW 115
103390: GO 103416
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103392: LD_VAR 0 4
103396: PUSH
103397: LD_VAR 0 7
103401: ARRAY
103402: PPUSH
103403: LD_VAR 0 14
103407: PUSH
103408: LD_INT 1
103410: ARRAY
103411: PPUSH
103412: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103416: LD_VAR 0 4
103420: PUSH
103421: LD_VAR 0 7
103425: ARRAY
103426: PPUSH
103427: CALL_OW 314
103431: NOT
103432: IFFALSE 103470
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103434: LD_VAR 0 4
103438: PUSH
103439: LD_VAR 0 7
103443: ARRAY
103444: PPUSH
103445: LD_VAR 0 14
103449: PPUSH
103450: LD_VAR 0 4
103454: PUSH
103455: LD_VAR 0 7
103459: ARRAY
103460: PPUSH
103461: CALL_OW 74
103465: PPUSH
103466: CALL_OW 115
// end ; end ; end ;
103470: GO 99375
103472: POP
103473: POP
// wait ( 0 0$1 ) ;
103474: LD_INT 35
103476: PPUSH
103477: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103481: LD_VAR 0 4
103485: PUSH
103486: EMPTY
103487: EQUAL
103488: PUSH
103489: LD_INT 81
103491: PUSH
103492: LD_VAR 0 35
103496: PUSH
103497: EMPTY
103498: LIST
103499: LIST
103500: PPUSH
103501: CALL_OW 69
103505: NOT
103506: OR
103507: IFFALSE 99360
// end ;
103509: LD_VAR 0 2
103513: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103514: LD_INT 0
103516: PPUSH
103517: PPUSH
103518: PPUSH
103519: PPUSH
// if not base_units then
103520: LD_VAR 0 1
103524: NOT
103525: IFFALSE 103529
// exit ;
103527: GO 103616
// result := false ;
103529: LD_ADDR_VAR 0 2
103533: PUSH
103534: LD_INT 0
103536: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103537: LD_ADDR_VAR 0 5
103541: PUSH
103542: LD_VAR 0 1
103546: PPUSH
103547: LD_INT 21
103549: PUSH
103550: LD_INT 3
103552: PUSH
103553: EMPTY
103554: LIST
103555: LIST
103556: PPUSH
103557: CALL_OW 72
103561: ST_TO_ADDR
// if not tmp then
103562: LD_VAR 0 5
103566: NOT
103567: IFFALSE 103571
// exit ;
103569: GO 103616
// for i in tmp do
103571: LD_ADDR_VAR 0 3
103575: PUSH
103576: LD_VAR 0 5
103580: PUSH
103581: FOR_IN
103582: IFFALSE 103614
// begin result := EnemyInRange ( i , 22 ) ;
103584: LD_ADDR_VAR 0 2
103588: PUSH
103589: LD_VAR 0 3
103593: PPUSH
103594: LD_INT 22
103596: PPUSH
103597: CALL 97153 0 2
103601: ST_TO_ADDR
// if result then
103602: LD_VAR 0 2
103606: IFFALSE 103612
// exit ;
103608: POP
103609: POP
103610: GO 103616
// end ;
103612: GO 103581
103614: POP
103615: POP
// end ;
103616: LD_VAR 0 2
103620: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
103621: LD_INT 0
103623: PPUSH
103624: PPUSH
// if not units then
103625: LD_VAR 0 1
103629: NOT
103630: IFFALSE 103634
// exit ;
103632: GO 103704
// result := [ ] ;
103634: LD_ADDR_VAR 0 3
103638: PUSH
103639: EMPTY
103640: ST_TO_ADDR
// for i in units do
103641: LD_ADDR_VAR 0 4
103645: PUSH
103646: LD_VAR 0 1
103650: PUSH
103651: FOR_IN
103652: IFFALSE 103702
// if GetTag ( i ) = tag then
103654: LD_VAR 0 4
103658: PPUSH
103659: CALL_OW 110
103663: PUSH
103664: LD_VAR 0 2
103668: EQUAL
103669: IFFALSE 103700
// result := Insert ( result , result + 1 , i ) ;
103671: LD_ADDR_VAR 0 3
103675: PUSH
103676: LD_VAR 0 3
103680: PPUSH
103681: LD_VAR 0 3
103685: PUSH
103686: LD_INT 1
103688: PLUS
103689: PPUSH
103690: LD_VAR 0 4
103694: PPUSH
103695: CALL_OW 2
103699: ST_TO_ADDR
103700: GO 103651
103702: POP
103703: POP
// end ;
103704: LD_VAR 0 3
103708: RET
// export function IsDriver ( un ) ; begin
103709: LD_INT 0
103711: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103712: LD_ADDR_VAR 0 2
103716: PUSH
103717: LD_VAR 0 1
103721: PUSH
103722: LD_INT 55
103724: PUSH
103725: EMPTY
103726: LIST
103727: PPUSH
103728: CALL_OW 69
103732: IN
103733: ST_TO_ADDR
// end ;
103734: LD_VAR 0 2
103738: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103739: LD_INT 0
103741: PPUSH
103742: PPUSH
// list := [ ] ;
103743: LD_ADDR_VAR 0 5
103747: PUSH
103748: EMPTY
103749: ST_TO_ADDR
// case d of 0 :
103750: LD_VAR 0 3
103754: PUSH
103755: LD_INT 0
103757: DOUBLE
103758: EQUAL
103759: IFTRUE 103763
103761: GO 103896
103763: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103764: LD_ADDR_VAR 0 5
103768: PUSH
103769: LD_VAR 0 1
103773: PUSH
103774: LD_INT 4
103776: MINUS
103777: PUSH
103778: LD_VAR 0 2
103782: PUSH
103783: LD_INT 4
103785: MINUS
103786: PUSH
103787: LD_INT 2
103789: PUSH
103790: EMPTY
103791: LIST
103792: LIST
103793: LIST
103794: PUSH
103795: LD_VAR 0 1
103799: PUSH
103800: LD_INT 3
103802: MINUS
103803: PUSH
103804: LD_VAR 0 2
103808: PUSH
103809: LD_INT 1
103811: PUSH
103812: EMPTY
103813: LIST
103814: LIST
103815: LIST
103816: PUSH
103817: LD_VAR 0 1
103821: PUSH
103822: LD_INT 4
103824: PLUS
103825: PUSH
103826: LD_VAR 0 2
103830: PUSH
103831: LD_INT 4
103833: PUSH
103834: EMPTY
103835: LIST
103836: LIST
103837: LIST
103838: PUSH
103839: LD_VAR 0 1
103843: PUSH
103844: LD_INT 3
103846: PLUS
103847: PUSH
103848: LD_VAR 0 2
103852: PUSH
103853: LD_INT 3
103855: PLUS
103856: PUSH
103857: LD_INT 5
103859: PUSH
103860: EMPTY
103861: LIST
103862: LIST
103863: LIST
103864: PUSH
103865: LD_VAR 0 1
103869: PUSH
103870: LD_VAR 0 2
103874: PUSH
103875: LD_INT 4
103877: PLUS
103878: PUSH
103879: LD_INT 0
103881: PUSH
103882: EMPTY
103883: LIST
103884: LIST
103885: LIST
103886: PUSH
103887: EMPTY
103888: LIST
103889: LIST
103890: LIST
103891: LIST
103892: LIST
103893: ST_TO_ADDR
// end ; 1 :
103894: GO 104594
103896: LD_INT 1
103898: DOUBLE
103899: EQUAL
103900: IFTRUE 103904
103902: GO 104037
103904: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103905: LD_ADDR_VAR 0 5
103909: PUSH
103910: LD_VAR 0 1
103914: PUSH
103915: LD_VAR 0 2
103919: PUSH
103920: LD_INT 4
103922: MINUS
103923: PUSH
103924: LD_INT 3
103926: PUSH
103927: EMPTY
103928: LIST
103929: LIST
103930: LIST
103931: PUSH
103932: LD_VAR 0 1
103936: PUSH
103937: LD_INT 3
103939: MINUS
103940: PUSH
103941: LD_VAR 0 2
103945: PUSH
103946: LD_INT 3
103948: MINUS
103949: PUSH
103950: LD_INT 2
103952: PUSH
103953: EMPTY
103954: LIST
103955: LIST
103956: LIST
103957: PUSH
103958: LD_VAR 0 1
103962: PUSH
103963: LD_INT 4
103965: MINUS
103966: PUSH
103967: LD_VAR 0 2
103971: PUSH
103972: LD_INT 1
103974: PUSH
103975: EMPTY
103976: LIST
103977: LIST
103978: LIST
103979: PUSH
103980: LD_VAR 0 1
103984: PUSH
103985: LD_VAR 0 2
103989: PUSH
103990: LD_INT 3
103992: PLUS
103993: PUSH
103994: LD_INT 0
103996: PUSH
103997: EMPTY
103998: LIST
103999: LIST
104000: LIST
104001: PUSH
104002: LD_VAR 0 1
104006: PUSH
104007: LD_INT 4
104009: PLUS
104010: PUSH
104011: LD_VAR 0 2
104015: PUSH
104016: LD_INT 4
104018: PLUS
104019: PUSH
104020: LD_INT 5
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: LIST
104027: PUSH
104028: EMPTY
104029: LIST
104030: LIST
104031: LIST
104032: LIST
104033: LIST
104034: ST_TO_ADDR
// end ; 2 :
104035: GO 104594
104037: LD_INT 2
104039: DOUBLE
104040: EQUAL
104041: IFTRUE 104045
104043: GO 104174
104045: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104046: LD_ADDR_VAR 0 5
104050: PUSH
104051: LD_VAR 0 1
104055: PUSH
104056: LD_VAR 0 2
104060: PUSH
104061: LD_INT 3
104063: MINUS
104064: PUSH
104065: LD_INT 3
104067: PUSH
104068: EMPTY
104069: LIST
104070: LIST
104071: LIST
104072: PUSH
104073: LD_VAR 0 1
104077: PUSH
104078: LD_INT 4
104080: PLUS
104081: PUSH
104082: LD_VAR 0 2
104086: PUSH
104087: LD_INT 4
104089: PUSH
104090: EMPTY
104091: LIST
104092: LIST
104093: LIST
104094: PUSH
104095: LD_VAR 0 1
104099: PUSH
104100: LD_VAR 0 2
104104: PUSH
104105: LD_INT 4
104107: PLUS
104108: PUSH
104109: LD_INT 0
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: LIST
104116: PUSH
104117: LD_VAR 0 1
104121: PUSH
104122: LD_INT 3
104124: MINUS
104125: PUSH
104126: LD_VAR 0 2
104130: PUSH
104131: LD_INT 1
104133: PUSH
104134: EMPTY
104135: LIST
104136: LIST
104137: LIST
104138: PUSH
104139: LD_VAR 0 1
104143: PUSH
104144: LD_INT 4
104146: MINUS
104147: PUSH
104148: LD_VAR 0 2
104152: PUSH
104153: LD_INT 4
104155: MINUS
104156: PUSH
104157: LD_INT 2
104159: PUSH
104160: EMPTY
104161: LIST
104162: LIST
104163: LIST
104164: PUSH
104165: EMPTY
104166: LIST
104167: LIST
104168: LIST
104169: LIST
104170: LIST
104171: ST_TO_ADDR
// end ; 3 :
104172: GO 104594
104174: LD_INT 3
104176: DOUBLE
104177: EQUAL
104178: IFTRUE 104182
104180: GO 104315
104182: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104183: LD_ADDR_VAR 0 5
104187: PUSH
104188: LD_VAR 0 1
104192: PUSH
104193: LD_INT 3
104195: PLUS
104196: PUSH
104197: LD_VAR 0 2
104201: PUSH
104202: LD_INT 4
104204: PUSH
104205: EMPTY
104206: LIST
104207: LIST
104208: LIST
104209: PUSH
104210: LD_VAR 0 1
104214: PUSH
104215: LD_INT 4
104217: PLUS
104218: PUSH
104219: LD_VAR 0 2
104223: PUSH
104224: LD_INT 4
104226: PLUS
104227: PUSH
104228: LD_INT 5
104230: PUSH
104231: EMPTY
104232: LIST
104233: LIST
104234: LIST
104235: PUSH
104236: LD_VAR 0 1
104240: PUSH
104241: LD_INT 4
104243: MINUS
104244: PUSH
104245: LD_VAR 0 2
104249: PUSH
104250: LD_INT 1
104252: PUSH
104253: EMPTY
104254: LIST
104255: LIST
104256: LIST
104257: PUSH
104258: LD_VAR 0 1
104262: PUSH
104263: LD_VAR 0 2
104267: PUSH
104268: LD_INT 4
104270: MINUS
104271: PUSH
104272: LD_INT 3
104274: PUSH
104275: EMPTY
104276: LIST
104277: LIST
104278: LIST
104279: PUSH
104280: LD_VAR 0 1
104284: PUSH
104285: LD_INT 3
104287: MINUS
104288: PUSH
104289: LD_VAR 0 2
104293: PUSH
104294: LD_INT 3
104296: MINUS
104297: PUSH
104298: LD_INT 2
104300: PUSH
104301: EMPTY
104302: LIST
104303: LIST
104304: LIST
104305: PUSH
104306: EMPTY
104307: LIST
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: ST_TO_ADDR
// end ; 4 :
104313: GO 104594
104315: LD_INT 4
104317: DOUBLE
104318: EQUAL
104319: IFTRUE 104323
104321: GO 104456
104323: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104324: LD_ADDR_VAR 0 5
104328: PUSH
104329: LD_VAR 0 1
104333: PUSH
104334: LD_VAR 0 2
104338: PUSH
104339: LD_INT 4
104341: PLUS
104342: PUSH
104343: LD_INT 0
104345: PUSH
104346: EMPTY
104347: LIST
104348: LIST
104349: LIST
104350: PUSH
104351: LD_VAR 0 1
104355: PUSH
104356: LD_INT 3
104358: PLUS
104359: PUSH
104360: LD_VAR 0 2
104364: PUSH
104365: LD_INT 3
104367: PLUS
104368: PUSH
104369: LD_INT 5
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: LIST
104376: PUSH
104377: LD_VAR 0 1
104381: PUSH
104382: LD_INT 4
104384: PLUS
104385: PUSH
104386: LD_VAR 0 2
104390: PUSH
104391: LD_INT 4
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: LIST
104398: PUSH
104399: LD_VAR 0 1
104403: PUSH
104404: LD_VAR 0 2
104408: PUSH
104409: LD_INT 3
104411: MINUS
104412: PUSH
104413: LD_INT 3
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: LIST
104420: PUSH
104421: LD_VAR 0 1
104425: PUSH
104426: LD_INT 4
104428: MINUS
104429: PUSH
104430: LD_VAR 0 2
104434: PUSH
104435: LD_INT 4
104437: MINUS
104438: PUSH
104439: LD_INT 2
104441: PUSH
104442: EMPTY
104443: LIST
104444: LIST
104445: LIST
104446: PUSH
104447: EMPTY
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: ST_TO_ADDR
// end ; 5 :
104454: GO 104594
104456: LD_INT 5
104458: DOUBLE
104459: EQUAL
104460: IFTRUE 104464
104462: GO 104593
104464: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104465: LD_ADDR_VAR 0 5
104469: PUSH
104470: LD_VAR 0 1
104474: PUSH
104475: LD_INT 4
104477: MINUS
104478: PUSH
104479: LD_VAR 0 2
104483: PUSH
104484: LD_INT 1
104486: PUSH
104487: EMPTY
104488: LIST
104489: LIST
104490: LIST
104491: PUSH
104492: LD_VAR 0 1
104496: PUSH
104497: LD_VAR 0 2
104501: PUSH
104502: LD_INT 4
104504: MINUS
104505: PUSH
104506: LD_INT 3
104508: PUSH
104509: EMPTY
104510: LIST
104511: LIST
104512: LIST
104513: PUSH
104514: LD_VAR 0 1
104518: PUSH
104519: LD_INT 4
104521: PLUS
104522: PUSH
104523: LD_VAR 0 2
104527: PUSH
104528: LD_INT 4
104530: PLUS
104531: PUSH
104532: LD_INT 5
104534: PUSH
104535: EMPTY
104536: LIST
104537: LIST
104538: LIST
104539: PUSH
104540: LD_VAR 0 1
104544: PUSH
104545: LD_INT 3
104547: PLUS
104548: PUSH
104549: LD_VAR 0 2
104553: PUSH
104554: LD_INT 4
104556: PUSH
104557: EMPTY
104558: LIST
104559: LIST
104560: LIST
104561: PUSH
104562: LD_VAR 0 1
104566: PUSH
104567: LD_VAR 0 2
104571: PUSH
104572: LD_INT 3
104574: PLUS
104575: PUSH
104576: LD_INT 0
104578: PUSH
104579: EMPTY
104580: LIST
104581: LIST
104582: LIST
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: LIST
104588: LIST
104589: LIST
104590: ST_TO_ADDR
// end ; end ;
104591: GO 104594
104593: POP
// result := list ;
104594: LD_ADDR_VAR 0 4
104598: PUSH
104599: LD_VAR 0 5
104603: ST_TO_ADDR
// end ;
104604: LD_VAR 0 4
104608: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
104609: LD_INT 0
104611: PPUSH
104612: PPUSH
104613: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
104614: LD_VAR 0 1
104618: NOT
104619: PUSH
104620: LD_VAR 0 2
104624: PUSH
104625: LD_INT 1
104627: PUSH
104628: LD_INT 2
104630: PUSH
104631: LD_INT 3
104633: PUSH
104634: LD_INT 4
104636: PUSH
104637: EMPTY
104638: LIST
104639: LIST
104640: LIST
104641: LIST
104642: IN
104643: NOT
104644: OR
104645: IFFALSE 104649
// exit ;
104647: GO 104741
// tmp := [ ] ;
104649: LD_ADDR_VAR 0 5
104653: PUSH
104654: EMPTY
104655: ST_TO_ADDR
// for i in units do
104656: LD_ADDR_VAR 0 4
104660: PUSH
104661: LD_VAR 0 1
104665: PUSH
104666: FOR_IN
104667: IFFALSE 104710
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
104669: LD_ADDR_VAR 0 5
104673: PUSH
104674: LD_VAR 0 5
104678: PPUSH
104679: LD_VAR 0 5
104683: PUSH
104684: LD_INT 1
104686: PLUS
104687: PPUSH
104688: LD_VAR 0 4
104692: PPUSH
104693: LD_VAR 0 2
104697: PPUSH
104698: CALL_OW 259
104702: PPUSH
104703: CALL_OW 2
104707: ST_TO_ADDR
104708: GO 104666
104710: POP
104711: POP
// if not tmp then
104712: LD_VAR 0 5
104716: NOT
104717: IFFALSE 104721
// exit ;
104719: GO 104741
// result := SortListByListDesc ( units , tmp ) ;
104721: LD_ADDR_VAR 0 3
104725: PUSH
104726: LD_VAR 0 1
104730: PPUSH
104731: LD_VAR 0 5
104735: PPUSH
104736: CALL_OW 77
104740: ST_TO_ADDR
// end ;
104741: LD_VAR 0 3
104745: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104746: LD_INT 0
104748: PPUSH
104749: PPUSH
104750: PPUSH
// x := GetX ( building ) ;
104751: LD_ADDR_VAR 0 4
104755: PUSH
104756: LD_VAR 0 2
104760: PPUSH
104761: CALL_OW 250
104765: ST_TO_ADDR
// y := GetY ( building ) ;
104766: LD_ADDR_VAR 0 5
104770: PUSH
104771: LD_VAR 0 2
104775: PPUSH
104776: CALL_OW 251
104780: ST_TO_ADDR
// if GetTaskList ( unit ) then
104781: LD_VAR 0 1
104785: PPUSH
104786: CALL_OW 437
104790: IFFALSE 104885
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104792: LD_STRING e
104794: PUSH
104795: LD_VAR 0 1
104799: PPUSH
104800: CALL_OW 437
104804: PUSH
104805: LD_INT 1
104807: ARRAY
104808: PUSH
104809: LD_INT 1
104811: ARRAY
104812: EQUAL
104813: PUSH
104814: LD_VAR 0 4
104818: PUSH
104819: LD_VAR 0 1
104823: PPUSH
104824: CALL_OW 437
104828: PUSH
104829: LD_INT 1
104831: ARRAY
104832: PUSH
104833: LD_INT 2
104835: ARRAY
104836: EQUAL
104837: AND
104838: PUSH
104839: LD_VAR 0 5
104843: PUSH
104844: LD_VAR 0 1
104848: PPUSH
104849: CALL_OW 437
104853: PUSH
104854: LD_INT 1
104856: ARRAY
104857: PUSH
104858: LD_INT 3
104860: ARRAY
104861: EQUAL
104862: AND
104863: IFFALSE 104875
// result := true else
104865: LD_ADDR_VAR 0 3
104869: PUSH
104870: LD_INT 1
104872: ST_TO_ADDR
104873: GO 104883
// result := false ;
104875: LD_ADDR_VAR 0 3
104879: PUSH
104880: LD_INT 0
104882: ST_TO_ADDR
// end else
104883: GO 104893
// result := false ;
104885: LD_ADDR_VAR 0 3
104889: PUSH
104890: LD_INT 0
104892: ST_TO_ADDR
// end ;
104893: LD_VAR 0 3
104897: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104898: LD_INT 0
104900: PPUSH
104901: PPUSH
104902: PPUSH
104903: PPUSH
// if not unit or not area then
104904: LD_VAR 0 1
104908: NOT
104909: PUSH
104910: LD_VAR 0 2
104914: NOT
104915: OR
104916: IFFALSE 104920
// exit ;
104918: GO 105084
// tmp := AreaToList ( area , i ) ;
104920: LD_ADDR_VAR 0 6
104924: PUSH
104925: LD_VAR 0 2
104929: PPUSH
104930: LD_VAR 0 5
104934: PPUSH
104935: CALL_OW 517
104939: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104940: LD_ADDR_VAR 0 5
104944: PUSH
104945: DOUBLE
104946: LD_INT 1
104948: DEC
104949: ST_TO_ADDR
104950: LD_VAR 0 6
104954: PUSH
104955: LD_INT 1
104957: ARRAY
104958: PUSH
104959: FOR_TO
104960: IFFALSE 105082
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104962: LD_ADDR_VAR 0 7
104966: PUSH
104967: LD_VAR 0 6
104971: PUSH
104972: LD_INT 1
104974: ARRAY
104975: PUSH
104976: LD_VAR 0 5
104980: ARRAY
104981: PUSH
104982: LD_VAR 0 6
104986: PUSH
104987: LD_INT 2
104989: ARRAY
104990: PUSH
104991: LD_VAR 0 5
104995: ARRAY
104996: PUSH
104997: EMPTY
104998: LIST
104999: LIST
105000: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105001: LD_VAR 0 7
105005: PUSH
105006: LD_INT 1
105008: ARRAY
105009: PPUSH
105010: LD_VAR 0 7
105014: PUSH
105015: LD_INT 2
105017: ARRAY
105018: PPUSH
105019: CALL_OW 428
105023: PUSH
105024: LD_INT 0
105026: EQUAL
105027: IFFALSE 105080
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105029: LD_VAR 0 1
105033: PPUSH
105034: LD_VAR 0 7
105038: PUSH
105039: LD_INT 1
105041: ARRAY
105042: PPUSH
105043: LD_VAR 0 7
105047: PUSH
105048: LD_INT 2
105050: ARRAY
105051: PPUSH
105052: LD_VAR 0 3
105056: PPUSH
105057: CALL_OW 48
// result := IsPlaced ( unit ) ;
105061: LD_ADDR_VAR 0 4
105065: PUSH
105066: LD_VAR 0 1
105070: PPUSH
105071: CALL_OW 305
105075: ST_TO_ADDR
// exit ;
105076: POP
105077: POP
105078: GO 105084
// end ; end ;
105080: GO 104959
105082: POP
105083: POP
// end ;
105084: LD_VAR 0 4
105088: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105089: LD_INT 0
105091: PPUSH
105092: PPUSH
105093: PPUSH
// if not side or side > 8 then
105094: LD_VAR 0 1
105098: NOT
105099: PUSH
105100: LD_VAR 0 1
105104: PUSH
105105: LD_INT 8
105107: GREATER
105108: OR
105109: IFFALSE 105113
// exit ;
105111: GO 105300
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105113: LD_ADDR_VAR 0 4
105117: PUSH
105118: LD_INT 22
105120: PUSH
105121: LD_VAR 0 1
105125: PUSH
105126: EMPTY
105127: LIST
105128: LIST
105129: PUSH
105130: LD_INT 21
105132: PUSH
105133: LD_INT 3
105135: PUSH
105136: EMPTY
105137: LIST
105138: LIST
105139: PUSH
105140: EMPTY
105141: LIST
105142: LIST
105143: PPUSH
105144: CALL_OW 69
105148: ST_TO_ADDR
// if not tmp then
105149: LD_VAR 0 4
105153: NOT
105154: IFFALSE 105158
// exit ;
105156: GO 105300
// enable_addtolog := true ;
105158: LD_ADDR_OWVAR 81
105162: PUSH
105163: LD_INT 1
105165: ST_TO_ADDR
// AddToLog ( [ ) ;
105166: LD_STRING [
105168: PPUSH
105169: CALL_OW 561
// for i in tmp do
105173: LD_ADDR_VAR 0 3
105177: PUSH
105178: LD_VAR 0 4
105182: PUSH
105183: FOR_IN
105184: IFFALSE 105291
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105186: LD_STRING [
105188: PUSH
105189: LD_VAR 0 3
105193: PPUSH
105194: CALL_OW 266
105198: STR
105199: PUSH
105200: LD_STRING , 
105202: STR
105203: PUSH
105204: LD_VAR 0 3
105208: PPUSH
105209: CALL_OW 250
105213: STR
105214: PUSH
105215: LD_STRING , 
105217: STR
105218: PUSH
105219: LD_VAR 0 3
105223: PPUSH
105224: CALL_OW 251
105228: STR
105229: PUSH
105230: LD_STRING , 
105232: STR
105233: PUSH
105234: LD_VAR 0 3
105238: PPUSH
105239: CALL_OW 254
105243: STR
105244: PUSH
105245: LD_STRING , 
105247: STR
105248: PUSH
105249: LD_VAR 0 3
105253: PPUSH
105254: LD_INT 1
105256: PPUSH
105257: CALL_OW 268
105261: STR
105262: PUSH
105263: LD_STRING , 
105265: STR
105266: PUSH
105267: LD_VAR 0 3
105271: PPUSH
105272: LD_INT 2
105274: PPUSH
105275: CALL_OW 268
105279: STR
105280: PUSH
105281: LD_STRING ],
105283: STR
105284: PPUSH
105285: CALL_OW 561
// end ;
105289: GO 105183
105291: POP
105292: POP
// AddToLog ( ]; ) ;
105293: LD_STRING ];
105295: PPUSH
105296: CALL_OW 561
// end ;
105300: LD_VAR 0 2
105304: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105305: LD_INT 0
105307: PPUSH
105308: PPUSH
105309: PPUSH
105310: PPUSH
105311: PPUSH
// if not area or not rate or not max then
105312: LD_VAR 0 1
105316: NOT
105317: PUSH
105318: LD_VAR 0 2
105322: NOT
105323: OR
105324: PUSH
105325: LD_VAR 0 4
105329: NOT
105330: OR
105331: IFFALSE 105335
// exit ;
105333: GO 105527
// while 1 do
105335: LD_INT 1
105337: IFFALSE 105527
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105339: LD_ADDR_VAR 0 9
105343: PUSH
105344: LD_VAR 0 1
105348: PPUSH
105349: LD_INT 1
105351: PPUSH
105352: CALL_OW 287
105356: PUSH
105357: LD_INT 10
105359: MUL
105360: ST_TO_ADDR
// r := rate / 10 ;
105361: LD_ADDR_VAR 0 7
105365: PUSH
105366: LD_VAR 0 2
105370: PUSH
105371: LD_INT 10
105373: DIVREAL
105374: ST_TO_ADDR
// time := 1 1$00 ;
105375: LD_ADDR_VAR 0 8
105379: PUSH
105380: LD_INT 2100
105382: ST_TO_ADDR
// if amount < min then
105383: LD_VAR 0 9
105387: PUSH
105388: LD_VAR 0 3
105392: LESS
105393: IFFALSE 105411
// r := r * 2 else
105395: LD_ADDR_VAR 0 7
105399: PUSH
105400: LD_VAR 0 7
105404: PUSH
105405: LD_INT 2
105407: MUL
105408: ST_TO_ADDR
105409: GO 105437
// if amount > max then
105411: LD_VAR 0 9
105415: PUSH
105416: LD_VAR 0 4
105420: GREATER
105421: IFFALSE 105437
// r := r / 2 ;
105423: LD_ADDR_VAR 0 7
105427: PUSH
105428: LD_VAR 0 7
105432: PUSH
105433: LD_INT 2
105435: DIVREAL
105436: ST_TO_ADDR
// time := time / r ;
105437: LD_ADDR_VAR 0 8
105441: PUSH
105442: LD_VAR 0 8
105446: PUSH
105447: LD_VAR 0 7
105451: DIVREAL
105452: ST_TO_ADDR
// if time < 0 then
105453: LD_VAR 0 8
105457: PUSH
105458: LD_INT 0
105460: LESS
105461: IFFALSE 105478
// time := time * - 1 ;
105463: LD_ADDR_VAR 0 8
105467: PUSH
105468: LD_VAR 0 8
105472: PUSH
105473: LD_INT 1
105475: NEG
105476: MUL
105477: ST_TO_ADDR
// wait ( time ) ;
105478: LD_VAR 0 8
105482: PPUSH
105483: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
105487: LD_INT 35
105489: PPUSH
105490: LD_INT 875
105492: PPUSH
105493: CALL_OW 12
105497: PPUSH
105498: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105502: LD_INT 1
105504: PPUSH
105505: LD_INT 5
105507: PPUSH
105508: CALL_OW 12
105512: PPUSH
105513: LD_VAR 0 1
105517: PPUSH
105518: LD_INT 1
105520: PPUSH
105521: CALL_OW 55
// end ;
105525: GO 105335
// end ;
105527: LD_VAR 0 5
105531: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105532: LD_INT 0
105534: PPUSH
105535: PPUSH
105536: PPUSH
105537: PPUSH
105538: PPUSH
105539: PPUSH
105540: PPUSH
105541: PPUSH
// if not turrets or not factories then
105542: LD_VAR 0 1
105546: NOT
105547: PUSH
105548: LD_VAR 0 2
105552: NOT
105553: OR
105554: IFFALSE 105558
// exit ;
105556: GO 105865
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105558: LD_ADDR_VAR 0 10
105562: PUSH
105563: LD_INT 5
105565: PUSH
105566: LD_INT 6
105568: PUSH
105569: EMPTY
105570: LIST
105571: LIST
105572: PUSH
105573: LD_INT 2
105575: PUSH
105576: LD_INT 4
105578: PUSH
105579: EMPTY
105580: LIST
105581: LIST
105582: PUSH
105583: LD_INT 3
105585: PUSH
105586: LD_INT 5
105588: PUSH
105589: EMPTY
105590: LIST
105591: LIST
105592: PUSH
105593: EMPTY
105594: LIST
105595: LIST
105596: LIST
105597: PUSH
105598: LD_INT 24
105600: PUSH
105601: LD_INT 25
105603: PUSH
105604: EMPTY
105605: LIST
105606: LIST
105607: PUSH
105608: LD_INT 23
105610: PUSH
105611: LD_INT 27
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: PUSH
105618: EMPTY
105619: LIST
105620: LIST
105621: PUSH
105622: LD_INT 42
105624: PUSH
105625: LD_INT 43
105627: PUSH
105628: EMPTY
105629: LIST
105630: LIST
105631: PUSH
105632: LD_INT 44
105634: PUSH
105635: LD_INT 46
105637: PUSH
105638: EMPTY
105639: LIST
105640: LIST
105641: PUSH
105642: LD_INT 45
105644: PUSH
105645: LD_INT 47
105647: PUSH
105648: EMPTY
105649: LIST
105650: LIST
105651: PUSH
105652: EMPTY
105653: LIST
105654: LIST
105655: LIST
105656: PUSH
105657: EMPTY
105658: LIST
105659: LIST
105660: LIST
105661: ST_TO_ADDR
// result := [ ] ;
105662: LD_ADDR_VAR 0 3
105666: PUSH
105667: EMPTY
105668: ST_TO_ADDR
// for i in turrets do
105669: LD_ADDR_VAR 0 4
105673: PUSH
105674: LD_VAR 0 1
105678: PUSH
105679: FOR_IN
105680: IFFALSE 105863
// begin nat := GetNation ( i ) ;
105682: LD_ADDR_VAR 0 7
105686: PUSH
105687: LD_VAR 0 4
105691: PPUSH
105692: CALL_OW 248
105696: ST_TO_ADDR
// weapon := 0 ;
105697: LD_ADDR_VAR 0 8
105701: PUSH
105702: LD_INT 0
105704: ST_TO_ADDR
// if not nat then
105705: LD_VAR 0 7
105709: NOT
105710: IFFALSE 105714
// continue ;
105712: GO 105679
// for j in list [ nat ] do
105714: LD_ADDR_VAR 0 5
105718: PUSH
105719: LD_VAR 0 10
105723: PUSH
105724: LD_VAR 0 7
105728: ARRAY
105729: PUSH
105730: FOR_IN
105731: IFFALSE 105772
// if GetBWeapon ( i ) = j [ 1 ] then
105733: LD_VAR 0 4
105737: PPUSH
105738: CALL_OW 269
105742: PUSH
105743: LD_VAR 0 5
105747: PUSH
105748: LD_INT 1
105750: ARRAY
105751: EQUAL
105752: IFFALSE 105770
// begin weapon := j [ 2 ] ;
105754: LD_ADDR_VAR 0 8
105758: PUSH
105759: LD_VAR 0 5
105763: PUSH
105764: LD_INT 2
105766: ARRAY
105767: ST_TO_ADDR
// break ;
105768: GO 105772
// end ;
105770: GO 105730
105772: POP
105773: POP
// if not weapon then
105774: LD_VAR 0 8
105778: NOT
105779: IFFALSE 105783
// continue ;
105781: GO 105679
// for k in factories do
105783: LD_ADDR_VAR 0 6
105787: PUSH
105788: LD_VAR 0 2
105792: PUSH
105793: FOR_IN
105794: IFFALSE 105859
// begin weapons := AvailableWeaponList ( k ) ;
105796: LD_ADDR_VAR 0 9
105800: PUSH
105801: LD_VAR 0 6
105805: PPUSH
105806: CALL_OW 478
105810: ST_TO_ADDR
// if not weapons then
105811: LD_VAR 0 9
105815: NOT
105816: IFFALSE 105820
// continue ;
105818: GO 105793
// if weapon in weapons then
105820: LD_VAR 0 8
105824: PUSH
105825: LD_VAR 0 9
105829: IN
105830: IFFALSE 105857
// begin result := [ i , weapon ] ;
105832: LD_ADDR_VAR 0 3
105836: PUSH
105837: LD_VAR 0 4
105841: PUSH
105842: LD_VAR 0 8
105846: PUSH
105847: EMPTY
105848: LIST
105849: LIST
105850: ST_TO_ADDR
// exit ;
105851: POP
105852: POP
105853: POP
105854: POP
105855: GO 105865
// end ; end ;
105857: GO 105793
105859: POP
105860: POP
// end ;
105861: GO 105679
105863: POP
105864: POP
// end ;
105865: LD_VAR 0 3
105869: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105870: LD_INT 0
105872: PPUSH
// if not side or side > 8 then
105873: LD_VAR 0 3
105877: NOT
105878: PUSH
105879: LD_VAR 0 3
105883: PUSH
105884: LD_INT 8
105886: GREATER
105887: OR
105888: IFFALSE 105892
// exit ;
105890: GO 105951
// if not range then
105892: LD_VAR 0 4
105896: NOT
105897: IFFALSE 105908
// range := - 12 ;
105899: LD_ADDR_VAR 0 4
105903: PUSH
105904: LD_INT 12
105906: NEG
105907: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105908: LD_VAR 0 1
105912: PPUSH
105913: LD_VAR 0 2
105917: PPUSH
105918: LD_VAR 0 3
105922: PPUSH
105923: LD_VAR 0 4
105927: PPUSH
105928: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105932: LD_VAR 0 1
105936: PPUSH
105937: LD_VAR 0 2
105941: PPUSH
105942: LD_VAR 0 3
105946: PPUSH
105947: CALL_OW 331
// end ;
105951: LD_VAR 0 5
105955: RET
// export function Video ( mode ) ; begin
105956: LD_INT 0
105958: PPUSH
// ingame_video = mode ;
105959: LD_ADDR_OWVAR 52
105963: PUSH
105964: LD_VAR 0 1
105968: ST_TO_ADDR
// interface_hidden = mode ;
105969: LD_ADDR_OWVAR 54
105973: PUSH
105974: LD_VAR 0 1
105978: ST_TO_ADDR
// end ;
105979: LD_VAR 0 2
105983: RET
// export function Join ( array , element ) ; begin
105984: LD_INT 0
105986: PPUSH
// result := array ^ element ;
105987: LD_ADDR_VAR 0 3
105991: PUSH
105992: LD_VAR 0 1
105996: PUSH
105997: LD_VAR 0 2
106001: ADD
106002: ST_TO_ADDR
// end ;
106003: LD_VAR 0 3
106007: RET
// export function JoinUnion ( array , element ) ; begin
106008: LD_INT 0
106010: PPUSH
// result := array union element ;
106011: LD_ADDR_VAR 0 3
106015: PUSH
106016: LD_VAR 0 1
106020: PUSH
106021: LD_VAR 0 2
106025: UNION
106026: ST_TO_ADDR
// end ;
106027: LD_VAR 0 3
106031: RET
// export function GetBehemoths ( side ) ; begin
106032: LD_INT 0
106034: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106035: LD_ADDR_VAR 0 2
106039: PUSH
106040: LD_INT 22
106042: PUSH
106043: LD_VAR 0 1
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: PUSH
106052: LD_INT 31
106054: PUSH
106055: LD_INT 25
106057: PUSH
106058: EMPTY
106059: LIST
106060: LIST
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: PPUSH
106066: CALL_OW 69
106070: ST_TO_ADDR
// end ;
106071: LD_VAR 0 2
106075: RET
// export function Shuffle ( array ) ; var i , index ; begin
106076: LD_INT 0
106078: PPUSH
106079: PPUSH
106080: PPUSH
// result := [ ] ;
106081: LD_ADDR_VAR 0 2
106085: PUSH
106086: EMPTY
106087: ST_TO_ADDR
// if not array then
106088: LD_VAR 0 1
106092: NOT
106093: IFFALSE 106097
// exit ;
106095: GO 106196
// Randomize ;
106097: CALL_OW 10
// for i = array downto 1 do
106101: LD_ADDR_VAR 0 3
106105: PUSH
106106: DOUBLE
106107: LD_VAR 0 1
106111: INC
106112: ST_TO_ADDR
106113: LD_INT 1
106115: PUSH
106116: FOR_DOWNTO
106117: IFFALSE 106194
// begin index := rand ( 1 , array ) ;
106119: LD_ADDR_VAR 0 4
106123: PUSH
106124: LD_INT 1
106126: PPUSH
106127: LD_VAR 0 1
106131: PPUSH
106132: CALL_OW 12
106136: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106137: LD_ADDR_VAR 0 2
106141: PUSH
106142: LD_VAR 0 2
106146: PPUSH
106147: LD_VAR 0 2
106151: PUSH
106152: LD_INT 1
106154: PLUS
106155: PPUSH
106156: LD_VAR 0 1
106160: PUSH
106161: LD_VAR 0 4
106165: ARRAY
106166: PPUSH
106167: CALL_OW 2
106171: ST_TO_ADDR
// array := Delete ( array , index ) ;
106172: LD_ADDR_VAR 0 1
106176: PUSH
106177: LD_VAR 0 1
106181: PPUSH
106182: LD_VAR 0 4
106186: PPUSH
106187: CALL_OW 3
106191: ST_TO_ADDR
// end ;
106192: GO 106116
106194: POP
106195: POP
// end ; end_of_file end_of_file end_of_file
106196: LD_VAR 0 2
106200: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
106201: LD_INT 0
106203: PPUSH
106204: PPUSH
106205: PPUSH
106206: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106207: LD_VAR 0 1
106211: PPUSH
106212: CALL_OW 264
106216: PUSH
106217: LD_EXP 96
106221: EQUAL
106222: IFFALSE 106294
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106224: LD_INT 68
106226: PPUSH
106227: LD_VAR 0 1
106231: PPUSH
106232: CALL_OW 255
106236: PPUSH
106237: CALL_OW 321
106241: PUSH
106242: LD_INT 2
106244: EQUAL
106245: IFFALSE 106257
// eff := 70 else
106247: LD_ADDR_VAR 0 6
106251: PUSH
106252: LD_INT 70
106254: ST_TO_ADDR
106255: GO 106265
// eff := 30 ;
106257: LD_ADDR_VAR 0 6
106261: PUSH
106262: LD_INT 30
106264: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106265: LD_VAR 0 1
106269: PPUSH
106270: CALL_OW 250
106274: PPUSH
106275: LD_VAR 0 1
106279: PPUSH
106280: CALL_OW 251
106284: PPUSH
106285: LD_VAR 0 6
106289: PPUSH
106290: CALL_OW 495
// end ; end ;
106294: LD_VAR 0 4
106298: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
106299: LD_INT 0
106301: PPUSH
106302: PPUSH
106303: PPUSH
106304: PPUSH
106305: PPUSH
106306: PPUSH
// if cmd = 124 then
106307: LD_VAR 0 1
106311: PUSH
106312: LD_INT 124
106314: EQUAL
106315: IFFALSE 106521
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
106317: LD_ADDR_VAR 0 5
106321: PUSH
106322: LD_INT 2
106324: PUSH
106325: LD_INT 34
106327: PUSH
106328: LD_INT 53
106330: PUSH
106331: EMPTY
106332: LIST
106333: LIST
106334: PUSH
106335: LD_INT 34
106337: PUSH
106338: LD_INT 14
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: PUSH
106345: EMPTY
106346: LIST
106347: LIST
106348: LIST
106349: PPUSH
106350: CALL_OW 69
106354: ST_TO_ADDR
// if not tmp then
106355: LD_VAR 0 5
106359: NOT
106360: IFFALSE 106364
// exit ;
106362: GO 106521
// for i in tmp do
106364: LD_ADDR_VAR 0 3
106368: PUSH
106369: LD_VAR 0 5
106373: PUSH
106374: FOR_IN
106375: IFFALSE 106519
// begin taskList := GetTaskList ( i ) ;
106377: LD_ADDR_VAR 0 6
106381: PUSH
106382: LD_VAR 0 3
106386: PPUSH
106387: CALL_OW 437
106391: ST_TO_ADDR
// if not taskList then
106392: LD_VAR 0 6
106396: NOT
106397: IFFALSE 106401
// continue ;
106399: GO 106374
// for j = 1 to taskList do
106401: LD_ADDR_VAR 0 4
106405: PUSH
106406: DOUBLE
106407: LD_INT 1
106409: DEC
106410: ST_TO_ADDR
106411: LD_VAR 0 6
106415: PUSH
106416: FOR_TO
106417: IFFALSE 106515
// if taskList [ j ] [ 1 ] = | then
106419: LD_VAR 0 6
106423: PUSH
106424: LD_VAR 0 4
106428: ARRAY
106429: PUSH
106430: LD_INT 1
106432: ARRAY
106433: PUSH
106434: LD_STRING |
106436: EQUAL
106437: IFFALSE 106513
// begin _taskList := Delete ( taskList , 1 ) ;
106439: LD_ADDR_VAR 0 7
106443: PUSH
106444: LD_VAR 0 6
106448: PPUSH
106449: LD_INT 1
106451: PPUSH
106452: CALL_OW 3
106456: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
106457: LD_VAR 0 3
106461: PPUSH
106462: LD_VAR 0 7
106466: PPUSH
106467: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
106471: LD_VAR 0 3
106475: PPUSH
106476: LD_VAR 0 6
106480: PUSH
106481: LD_VAR 0 4
106485: ARRAY
106486: PUSH
106487: LD_INT 2
106489: ARRAY
106490: PPUSH
106491: LD_VAR 0 6
106495: PUSH
106496: LD_VAR 0 4
106500: ARRAY
106501: PUSH
106502: LD_INT 3
106504: ARRAY
106505: PPUSH
106506: LD_INT 8
106508: PPUSH
106509: CALL 106526 0 4
// end ;
106513: GO 106416
106515: POP
106516: POP
// end ;
106517: GO 106374
106519: POP
106520: POP
// end ; end ;
106521: LD_VAR 0 2
106525: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106526: LD_INT 0
106528: PPUSH
106529: PPUSH
106530: PPUSH
106531: PPUSH
106532: PPUSH
106533: PPUSH
106534: PPUSH
106535: PPUSH
106536: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106537: LD_VAR 0 1
106541: NOT
106542: PUSH
106543: LD_VAR 0 2
106547: PPUSH
106548: LD_VAR 0 3
106552: PPUSH
106553: CALL_OW 488
106557: NOT
106558: OR
106559: PUSH
106560: LD_VAR 0 4
106564: NOT
106565: OR
106566: IFFALSE 106570
// exit ;
106568: GO 106910
// list := [ ] ;
106570: LD_ADDR_VAR 0 13
106574: PUSH
106575: EMPTY
106576: ST_TO_ADDR
// if x - r < 0 then
106577: LD_VAR 0 2
106581: PUSH
106582: LD_VAR 0 4
106586: MINUS
106587: PUSH
106588: LD_INT 0
106590: LESS
106591: IFFALSE 106603
// min_x := 0 else
106593: LD_ADDR_VAR 0 7
106597: PUSH
106598: LD_INT 0
106600: ST_TO_ADDR
106601: GO 106619
// min_x := x - r ;
106603: LD_ADDR_VAR 0 7
106607: PUSH
106608: LD_VAR 0 2
106612: PUSH
106613: LD_VAR 0 4
106617: MINUS
106618: ST_TO_ADDR
// if y - r < 0 then
106619: LD_VAR 0 3
106623: PUSH
106624: LD_VAR 0 4
106628: MINUS
106629: PUSH
106630: LD_INT 0
106632: LESS
106633: IFFALSE 106645
// min_y := 0 else
106635: LD_ADDR_VAR 0 8
106639: PUSH
106640: LD_INT 0
106642: ST_TO_ADDR
106643: GO 106661
// min_y := y - r ;
106645: LD_ADDR_VAR 0 8
106649: PUSH
106650: LD_VAR 0 3
106654: PUSH
106655: LD_VAR 0 4
106659: MINUS
106660: ST_TO_ADDR
// max_x := x + r ;
106661: LD_ADDR_VAR 0 9
106665: PUSH
106666: LD_VAR 0 2
106670: PUSH
106671: LD_VAR 0 4
106675: PLUS
106676: ST_TO_ADDR
// max_y := y + r ;
106677: LD_ADDR_VAR 0 10
106681: PUSH
106682: LD_VAR 0 3
106686: PUSH
106687: LD_VAR 0 4
106691: PLUS
106692: ST_TO_ADDR
// for _x = min_x to max_x do
106693: LD_ADDR_VAR 0 11
106697: PUSH
106698: DOUBLE
106699: LD_VAR 0 7
106703: DEC
106704: ST_TO_ADDR
106705: LD_VAR 0 9
106709: PUSH
106710: FOR_TO
106711: IFFALSE 106828
// for _y = min_y to max_y do
106713: LD_ADDR_VAR 0 12
106717: PUSH
106718: DOUBLE
106719: LD_VAR 0 8
106723: DEC
106724: ST_TO_ADDR
106725: LD_VAR 0 10
106729: PUSH
106730: FOR_TO
106731: IFFALSE 106824
// begin if not ValidHex ( _x , _y ) then
106733: LD_VAR 0 11
106737: PPUSH
106738: LD_VAR 0 12
106742: PPUSH
106743: CALL_OW 488
106747: NOT
106748: IFFALSE 106752
// continue ;
106750: GO 106730
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106752: LD_VAR 0 11
106756: PPUSH
106757: LD_VAR 0 12
106761: PPUSH
106762: CALL_OW 351
106766: PUSH
106767: LD_VAR 0 11
106771: PPUSH
106772: LD_VAR 0 12
106776: PPUSH
106777: CALL_OW 554
106781: AND
106782: IFFALSE 106822
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106784: LD_ADDR_VAR 0 13
106788: PUSH
106789: LD_VAR 0 13
106793: PPUSH
106794: LD_VAR 0 13
106798: PUSH
106799: LD_INT 1
106801: PLUS
106802: PPUSH
106803: LD_VAR 0 11
106807: PUSH
106808: LD_VAR 0 12
106812: PUSH
106813: EMPTY
106814: LIST
106815: LIST
106816: PPUSH
106817: CALL_OW 2
106821: ST_TO_ADDR
// end ;
106822: GO 106730
106824: POP
106825: POP
106826: GO 106710
106828: POP
106829: POP
// if not list then
106830: LD_VAR 0 13
106834: NOT
106835: IFFALSE 106839
// exit ;
106837: GO 106910
// for i in list do
106839: LD_ADDR_VAR 0 6
106843: PUSH
106844: LD_VAR 0 13
106848: PUSH
106849: FOR_IN
106850: IFFALSE 106908
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106852: LD_VAR 0 1
106856: PPUSH
106857: LD_STRING M
106859: PUSH
106860: LD_VAR 0 6
106864: PUSH
106865: LD_INT 1
106867: ARRAY
106868: PUSH
106869: LD_VAR 0 6
106873: PUSH
106874: LD_INT 2
106876: ARRAY
106877: PUSH
106878: LD_INT 0
106880: PUSH
106881: LD_INT 0
106883: PUSH
106884: LD_INT 0
106886: PUSH
106887: LD_INT 0
106889: PUSH
106890: EMPTY
106891: LIST
106892: LIST
106893: LIST
106894: LIST
106895: LIST
106896: LIST
106897: LIST
106898: PUSH
106899: EMPTY
106900: LIST
106901: PPUSH
106902: CALL_OW 447
106906: GO 106849
106908: POP
106909: POP
// end ;
106910: LD_VAR 0 5
106914: RET
