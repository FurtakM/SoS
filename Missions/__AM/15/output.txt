// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38837 0 0
// InitNature ;
  19: CALL 38705 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12609 0 0
// PrepareRussian ;
  40: CALL 7491 0 0
// PrepareLegion ;
  44: CALL 4573 0 0
// PreparePowell ;
  48: CALL 3107 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 17472 0 0
// MC_Start ( ) ;
  60: CALL 41017 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63813 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63906 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 63256 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 63071 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63813 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63906 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 63071 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 63256 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63686 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62734 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63813 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63906 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 63071 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63813 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63906 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62963 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 64224 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 63395 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63686 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63686 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 64018 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 63071 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 63637 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 69545 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 74385 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 74385 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 59
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 59
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 74385 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 59
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 59
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 59
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 59
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 74385 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 74385 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 60
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 60
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 60
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 69545 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 60
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 69545 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 60
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 69545 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 60
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 69545 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 69545 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 69545 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 69545 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 69545 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 69545 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 69545 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 69545 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 69545 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 69545 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 69545 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 69545 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; if not DeltaDoctor then
3022: LD_EXP 58
3026: NOT
3027: IFFALSE 3073
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3029: LD_ADDR_EXP 58
3033: PUSH
3034: LD_STRING DeltaDoctor
3036: PPUSH
3037: LD_EXP 1
3041: NOT
3042: PPUSH
3043: LD_STRING 13f_
3045: PPUSH
3046: CALL 69545 0 3
3050: ST_TO_ADDR
// if Bobby then
3051: LD_EXP 45
3055: IFFALSE 3073
// tmp := tmp ^ DeltaDoctor ;
3057: LD_ADDR_VAR 0 2
3061: PUSH
3062: LD_VAR 0 2
3066: PUSH
3067: LD_EXP 58
3071: ADD
3072: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3073: LD_ADDR_VAR 0 2
3077: PUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_STRING 13_other_survivors
3085: PPUSH
3086: CALL_OW 31
3090: UNION
3091: ST_TO_ADDR
// result := tmp ;
3092: LD_ADDR_VAR 0 1
3096: PUSH
3097: LD_VAR 0 2
3101: ST_TO_ADDR
// end ; end_of_file
3102: LD_VAR 0 1
3106: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3107: LD_INT 0
3109: PPUSH
3110: PPUSH
3111: PPUSH
3112: PPUSH
3113: PPUSH
3114: PPUSH
3115: PPUSH
3116: PPUSH
3117: PPUSH
3118: PPUSH
// uc_side := 4 ;
3119: LD_ADDR_OWVAR 20
3123: PUSH
3124: LD_INT 4
3126: ST_TO_ADDR
// uc_nation := 1 ;
3127: LD_ADDR_OWVAR 21
3131: PUSH
3132: LD_INT 1
3134: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3135: LD_INT 387
3137: PPUSH
3138: CALL_OW 274
3142: PPUSH
3143: LD_INT 1
3145: PPUSH
3146: LD_INT 3500
3148: PUSH
3149: LD_INT 3000
3151: PUSH
3152: LD_INT 2500
3154: PUSH
3155: LD_INT 2000
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: PUSH
3164: LD_OWVAR 67
3168: ARRAY
3169: PPUSH
3170: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3174: LD_INT 387
3176: PPUSH
3177: CALL_OW 274
3181: PPUSH
3182: LD_INT 2
3184: PPUSH
3185: LD_INT 400
3187: PPUSH
3188: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3192: LD_INT 387
3194: PPUSH
3195: CALL_OW 274
3199: PPUSH
3200: LD_INT 3
3202: PPUSH
3203: LD_INT 10
3205: PPUSH
3206: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3210: LD_INT 387
3212: PPUSH
3213: LD_STRING sigma
3215: PPUSH
3216: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3220: LD_ADDR_EXP 61
3224: PUSH
3225: LD_STRING Powell
3227: PPUSH
3228: CALL_OW 25
3232: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3233: LD_EXP 61
3237: PPUSH
3238: LD_INT 57
3240: PPUSH
3241: LD_INT 94
3243: PPUSH
3244: LD_INT 0
3246: PPUSH
3247: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3251: LD_EXP 61
3255: PPUSH
3256: LD_INT 58
3258: PPUSH
3259: LD_INT 94
3261: PPUSH
3262: CALL_OW 118
// vip := [ ] ;
3266: LD_ADDR_EXP 62
3270: PUSH
3271: EMPTY
3272: ST_TO_ADDR
// extraSquad := [ ] ;
3273: LD_ADDR_EXP 63
3277: PUSH
3278: EMPTY
3279: ST_TO_ADDR
// tmp := [ ] ;
3280: LD_ADDR_VAR 0 5
3284: PUSH
3285: EMPTY
3286: ST_TO_ADDR
// if JMMGirl <> 2 then
3287: LD_EXP 7
3291: PUSH
3292: LD_INT 2
3294: NONEQUAL
3295: IFFALSE 3319
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3297: LD_ADDR_EXP 43
3301: PUSH
3302: LD_STRING Lisa
3304: PPUSH
3305: LD_EXP 1
3309: NOT
3310: PPUSH
3311: LD_STRING 13s_
3313: PPUSH
3314: CALL 69545 0 3
3318: ST_TO_ADDR
// if Lisa then
3319: LD_EXP 43
3323: IFFALSE 3341
// tmp := tmp ^ Lisa ;
3325: LD_ADDR_VAR 0 5
3329: PUSH
3330: LD_VAR 0 5
3334: PUSH
3335: LD_EXP 43
3339: ADD
3340: ST_TO_ADDR
// if JMMGirl < 3 then
3341: LD_EXP 7
3345: PUSH
3346: LD_INT 3
3348: LESS
3349: IFFALSE 3380
// begin Connie := NewCharacter ( Coonie ) ;
3351: LD_ADDR_EXP 55
3355: PUSH
3356: LD_STRING Coonie
3358: PPUSH
3359: CALL_OW 25
3363: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: LD_EXP 55
3378: ADD
3379: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 44
3384: PUSH
3385: LD_STRING Donaldson
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 69545 0 3
3401: ST_TO_ADDR
// if Donaldson then
3402: LD_EXP 44
3406: IFFALSE 3424
// tmp := tmp ^ Donaldson ;
3408: LD_ADDR_VAR 0 5
3412: PUSH
3413: LD_VAR 0 5
3417: PUSH
3418: LD_EXP 44
3422: ADD
3423: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 45
3428: PUSH
3429: LD_STRING Bobby
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 69545 0 3
3445: ST_TO_ADDR
// if Bobby then
3446: LD_EXP 45
3450: IFFALSE 3468
// tmp := tmp ^ Bobby ;
3452: LD_ADDR_VAR 0 5
3456: PUSH
3457: LD_VAR 0 5
3461: PUSH
3462: LD_EXP 45
3466: ADD
3467: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 46
3472: PUSH
3473: LD_STRING Cyrus
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 69545 0 3
3489: ST_TO_ADDR
// if Cyrus then
3490: LD_EXP 46
3494: IFFALSE 3512
// tmp := tmp ^ Cyrus ;
3496: LD_ADDR_VAR 0 5
3500: PUSH
3501: LD_VAR 0 5
3505: PUSH
3506: LD_EXP 46
3510: ADD
3511: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 47
3516: PUSH
3517: LD_STRING Denis
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 69545 0 3
3533: ST_TO_ADDR
// if not Denis then
3534: LD_EXP 47
3538: NOT
3539: IFFALSE 3563
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3541: LD_ADDR_EXP 47
3545: PUSH
3546: LD_STRING Denis
3548: PPUSH
3549: LD_EXP 1
3553: NOT
3554: PPUSH
3555: LD_STRING 13f_
3557: PPUSH
3558: CALL 69545 0 3
3562: ST_TO_ADDR
// if Denis then
3563: LD_EXP 47
3567: IFFALSE 3585
// tmp := tmp ^ Denis ;
3569: LD_ADDR_VAR 0 5
3573: PUSH
3574: LD_VAR 0 5
3578: PUSH
3579: LD_EXP 47
3583: ADD
3584: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3585: LD_ADDR_EXP 48
3589: PUSH
3590: LD_STRING Brown
3592: PPUSH
3593: LD_EXP 1
3597: NOT
3598: PPUSH
3599: LD_STRING 13s_
3601: PPUSH
3602: CALL 69545 0 3
3606: ST_TO_ADDR
// if Brown then
3607: LD_EXP 48
3611: IFFALSE 3629
// tmp := tmp ^ Brown ;
3613: LD_ADDR_VAR 0 5
3617: PUSH
3618: LD_VAR 0 5
3622: PUSH
3623: LD_EXP 48
3627: ADD
3628: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3629: LD_ADDR_EXP 49
3633: PUSH
3634: LD_STRING Gladstone
3636: PPUSH
3637: LD_EXP 1
3641: NOT
3642: PPUSH
3643: LD_STRING 13s_
3645: PPUSH
3646: CALL 69545 0 3
3650: ST_TO_ADDR
// if Gladstone then
3651: LD_EXP 49
3655: IFFALSE 3673
// tmp := tmp ^ Gladstone ;
3657: LD_ADDR_VAR 0 5
3661: PUSH
3662: LD_VAR 0 5
3666: PUSH
3667: LD_EXP 49
3671: ADD
3672: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3673: LD_ADDR_EXP 50
3677: PUSH
3678: LD_STRING Houten
3680: PPUSH
3681: LD_EXP 1
3685: NOT
3686: PPUSH
3687: LD_STRING 13s_
3689: PPUSH
3690: CALL 69545 0 3
3694: ST_TO_ADDR
// if Houten then
3695: LD_EXP 50
3699: IFFALSE 3717
// tmp := tmp ^ Houten ;
3701: LD_ADDR_VAR 0 5
3705: PUSH
3706: LD_VAR 0 5
3710: PUSH
3711: LD_EXP 50
3715: ADD
3716: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3717: LD_ADDR_EXP 51
3721: PUSH
3722: LD_STRING Cornel
3724: PPUSH
3725: LD_EXP 1
3729: NOT
3730: PPUSH
3731: LD_STRING 13s_
3733: PPUSH
3734: CALL 69545 0 3
3738: ST_TO_ADDR
// if Cornel then
3739: LD_EXP 51
3743: IFFALSE 3761
// tmp := tmp ^ Cornel ;
3745: LD_ADDR_VAR 0 5
3749: PUSH
3750: LD_VAR 0 5
3754: PUSH
3755: LD_EXP 51
3759: ADD
3760: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3761: LD_ADDR_EXP 52
3765: PUSH
3766: LD_STRING Gary
3768: PPUSH
3769: LD_EXP 1
3773: NOT
3774: PPUSH
3775: LD_STRING 13s_
3777: PPUSH
3778: CALL 69545 0 3
3782: ST_TO_ADDR
// if Gary then
3783: LD_EXP 52
3787: IFFALSE 3805
// tmp := tmp ^ Gary ;
3789: LD_ADDR_VAR 0 5
3793: PUSH
3794: LD_VAR 0 5
3798: PUSH
3799: LD_EXP 52
3803: ADD
3804: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3805: LD_ADDR_EXP 53
3809: PUSH
3810: LD_STRING Frank
3812: PPUSH
3813: LD_EXP 1
3817: NOT
3818: PPUSH
3819: LD_STRING 13s_
3821: PPUSH
3822: CALL 69545 0 3
3826: ST_TO_ADDR
// if Frank then
3827: LD_EXP 53
3831: IFFALSE 3849
// tmp := tmp ^ Frank ;
3833: LD_ADDR_VAR 0 5
3837: PUSH
3838: LD_VAR 0 5
3842: PUSH
3843: LD_EXP 53
3847: ADD
3848: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3849: LD_ADDR_EXP 54
3853: PUSH
3854: LD_STRING Kikuchi
3856: PPUSH
3857: LD_EXP 1
3861: NOT
3862: PPUSH
3863: LD_STRING 13s_
3865: PPUSH
3866: CALL 69545 0 3
3870: ST_TO_ADDR
// if Kikuchi then
3871: LD_EXP 54
3875: IFFALSE 3893
// tmp := tmp ^ Kikuchi ;
3877: LD_ADDR_VAR 0 5
3881: PUSH
3882: LD_VAR 0 5
3886: PUSH
3887: LD_EXP 54
3891: ADD
3892: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
3893: LD_ADDR_EXP 58
3897: PUSH
3898: LD_STRING DeltaDoctor
3900: PPUSH
3901: LD_EXP 1
3905: NOT
3906: PPUSH
3907: LD_STRING 13s_
3909: PPUSH
3910: CALL 69545 0 3
3914: ST_TO_ADDR
// if DeltaDoctor then
3915: LD_EXP 58
3919: IFFALSE 3937
// tmp := tmp ^ DeltaDoctor ;
3921: LD_ADDR_VAR 0 5
3925: PUSH
3926: LD_VAR 0 5
3930: PUSH
3931: LD_EXP 58
3935: ADD
3936: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3937: LD_ADDR_EXP 57
3941: PUSH
3942: LD_STRING Mike
3944: PPUSH
3945: LD_EXP 1
3949: NOT
3950: PPUSH
3951: LD_STRING 10c_
3953: PPUSH
3954: CALL 69545 0 3
3958: ST_TO_ADDR
// if Mike then
3959: LD_EXP 57
3963: IFFALSE 3986
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3965: LD_EXP 57
3969: PPUSH
3970: LD_INT 61
3972: PPUSH
3973: LD_INT 89
3975: PPUSH
3976: LD_INT 8
3978: PPUSH
3979: LD_INT 0
3981: PPUSH
3982: CALL_OW 50
// vip := tmp ;
3986: LD_ADDR_EXP 62
3990: PUSH
3991: LD_VAR 0 5
3995: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3996: LD_ADDR_VAR 0 5
4000: PUSH
4001: LD_VAR 0 5
4005: PUSH
4006: LD_STRING 13s_others
4008: PPUSH
4009: CALL_OW 31
4013: UNION
4014: ST_TO_ADDR
// if tmp < 18 then
4015: LD_VAR 0 5
4019: PUSH
4020: LD_INT 18
4022: LESS
4023: IFFALSE 4128
// begin InitHC_All ( ) ;
4025: CALL_OW 584
// for i = 1 to 18 - tmp do
4029: LD_ADDR_VAR 0 2
4033: PUSH
4034: DOUBLE
4035: LD_INT 1
4037: DEC
4038: ST_TO_ADDR
4039: LD_INT 18
4041: PUSH
4042: LD_VAR 0 5
4046: MINUS
4047: PUSH
4048: FOR_TO
4049: IFFALSE 4126
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4051: LD_INT 1
4053: PPUSH
4054: LD_VAR 0 2
4058: PUSH
4059: LD_INT 4
4061: MOD
4062: PUSH
4063: LD_INT 1
4065: PLUS
4066: PPUSH
4067: LD_INT 4
4069: PPUSH
4070: CALL_OW 380
// un := CreateHuman ;
4074: LD_ADDR_VAR 0 10
4078: PUSH
4079: CALL_OW 44
4083: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4084: LD_ADDR_VAR 0 5
4088: PUSH
4089: LD_VAR 0 5
4093: PPUSH
4094: LD_VAR 0 10
4098: PPUSH
4099: CALL 107236 0 2
4103: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4104: LD_ADDR_EXP 63
4108: PUSH
4109: LD_EXP 63
4113: PPUSH
4114: LD_VAR 0 10
4118: PPUSH
4119: CALL 107236 0 2
4123: ST_TO_ADDR
// end ;
4124: GO 4048
4126: POP
4127: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4128: LD_ADDR_VAR 0 6
4132: PUSH
4133: LD_INT 53
4135: PPUSH
4136: LD_INT 94
4138: PPUSH
4139: CALL_OW 428
4143: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4144: LD_ADDR_VAR 0 7
4148: PUSH
4149: LD_INT 56
4151: PPUSH
4152: LD_INT 101
4154: PPUSH
4155: CALL_OW 428
4159: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4160: LD_ADDR_VAR 0 8
4164: PUSH
4165: LD_INT 67
4167: PPUSH
4168: LD_INT 101
4170: PPUSH
4171: CALL_OW 428
4175: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4176: LD_ADDR_VAR 0 9
4180: PUSH
4181: LD_INT 54
4183: PPUSH
4184: LD_INT 85
4186: PPUSH
4187: CALL_OW 428
4191: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4192: LD_ADDR_VAR 0 3
4196: PUSH
4197: LD_VAR 0 8
4201: PUSH
4202: LD_VAR 0 6
4206: PUSH
4207: LD_VAR 0 9
4211: PUSH
4212: LD_VAR 0 7
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: ST_TO_ADDR
// for i in tmp do
4223: LD_ADDR_VAR 0 2
4227: PUSH
4228: LD_VAR 0 5
4232: PUSH
4233: FOR_IN
4234: IFFALSE 4429
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4236: LD_VAR 0 3
4240: PUSH
4241: LD_INT 1
4243: ARRAY
4244: PPUSH
4245: CALL_OW 266
4249: PUSH
4250: LD_INT 4
4252: DOUBLE
4253: EQUAL
4254: IFTRUE 4258
4256: GO 4273
4258: POP
// SetClass ( i , class_soldier ) ; b_depot :
4259: LD_VAR 0 2
4263: PPUSH
4264: LD_INT 1
4266: PPUSH
4267: CALL_OW 336
4271: GO 4343
4273: LD_INT 0
4275: DOUBLE
4276: EQUAL
4277: IFTRUE 4281
4279: GO 4296
4281: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4282: LD_VAR 0 2
4286: PPUSH
4287: LD_INT 2
4289: PPUSH
4290: CALL_OW 336
4294: GO 4343
4296: LD_INT 2
4298: DOUBLE
4299: EQUAL
4300: IFTRUE 4304
4302: GO 4319
4304: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4305: LD_VAR 0 2
4309: PPUSH
4310: LD_INT 3
4312: PPUSH
4313: CALL_OW 336
4317: GO 4343
4319: LD_INT 6
4321: DOUBLE
4322: EQUAL
4323: IFTRUE 4327
4325: GO 4342
4327: POP
// SetClass ( i , class_scientistic ) ; end ;
4328: LD_VAR 0 2
4332: PPUSH
4333: LD_INT 4
4335: PPUSH
4336: CALL_OW 336
4340: GO 4343
4342: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4343: LD_VAR 0 3
4347: PUSH
4348: LD_INT 1
4350: ARRAY
4351: PPUSH
4352: CALL_OW 313
4356: PUSH
4357: LD_INT 6
4359: EQUAL
4360: IFFALSE 4380
// b := Delete ( b , 1 ) ;
4362: LD_ADDR_VAR 0 3
4366: PUSH
4367: LD_VAR 0 3
4371: PPUSH
4372: LD_INT 1
4374: PPUSH
4375: CALL_OW 3
4379: ST_TO_ADDR
// if b then
4380: LD_VAR 0 3
4384: IFFALSE 4406
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4386: LD_VAR 0 2
4390: PPUSH
4391: LD_VAR 0 3
4395: PUSH
4396: LD_INT 1
4398: ARRAY
4399: PPUSH
4400: CALL_OW 52
4404: GO 4427
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4406: LD_VAR 0 2
4410: PPUSH
4411: LD_INT 61
4413: PPUSH
4414: LD_INT 89
4416: PPUSH
4417: LD_INT 8
4419: PPUSH
4420: LD_INT 0
4422: PPUSH
4423: CALL_OW 50
// end ;
4427: GO 4233
4429: POP
4430: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4431: LD_INT 2
4433: PPUSH
4434: LD_INT 1
4436: PPUSH
4437: LD_INT 1
4439: PPUSH
4440: LD_INT 12
4442: PPUSH
4443: LD_INT 100
4445: PPUSH
4446: CALL 74385 0 5
// veh := CreateVehicle ;
4450: LD_ADDR_VAR 0 4
4454: PUSH
4455: CALL_OW 45
4459: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4460: LD_VAR 0 4
4464: PPUSH
4465: LD_INT 4
4467: PPUSH
4468: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4472: LD_VAR 0 4
4476: PPUSH
4477: LD_INT 49
4479: PPUSH
4480: LD_INT 88
4482: PPUSH
4483: LD_INT 0
4485: PPUSH
4486: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4490: LD_VAR 0 4
4494: PPUSH
4495: LD_INT 1
4497: PPUSH
4498: LD_INT 100
4500: PPUSH
4501: CALL_OW 290
// uc_side := 0 ;
4505: LD_ADDR_OWVAR 20
4509: PUSH
4510: LD_INT 0
4512: ST_TO_ADDR
// uc_nation := 0 ;
4513: LD_ADDR_OWVAR 21
4517: PUSH
4518: LD_INT 0
4520: ST_TO_ADDR
// for i := 1 to 3 do
4521: LD_ADDR_VAR 0 2
4525: PUSH
4526: DOUBLE
4527: LD_INT 1
4529: DEC
4530: ST_TO_ADDR
4531: LD_INT 3
4533: PUSH
4534: FOR_TO
4535: IFFALSE 4566
// begin InitHc ;
4537: CALL_OW 19
// hc_class := class_apeman ;
4541: LD_ADDR_OWVAR 28
4545: PUSH
4546: LD_INT 12
4548: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4549: CALL_OW 44
4553: PPUSH
4554: LD_INT 13
4556: PPUSH
4557: LD_INT 0
4559: PPUSH
4560: CALL_OW 49
// end ;
4564: GO 4534
4566: POP
4567: POP
// end ; end_of_file
4568: LD_VAR 0 1
4572: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4573: LD_INT 0
4575: PPUSH
4576: PPUSH
4577: PPUSH
4578: PPUSH
4579: PPUSH
// side := 8 ;
4580: LD_ADDR_VAR 0 3
4584: PUSH
4585: LD_INT 8
4587: ST_TO_ADDR
// uc_side := side ;
4588: LD_ADDR_OWVAR 20
4592: PUSH
4593: LD_VAR 0 3
4597: ST_TO_ADDR
// uc_nation := 2 ;
4598: LD_ADDR_OWVAR 21
4602: PUSH
4603: LD_INT 2
4605: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4606: LD_ADDR_VAR 0 2
4610: PUSH
4611: LD_INT 22
4613: PUSH
4614: LD_VAR 0 3
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PUSH
4623: LD_INT 21
4625: PUSH
4626: LD_INT 3
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PPUSH
4637: CALL_OW 69
4641: PUSH
4642: FOR_IN
4643: IFFALSE 4659
// SetBLevel ( i , 10 ) ;
4645: LD_VAR 0 2
4649: PPUSH
4650: LD_INT 10
4652: PPUSH
4653: CALL_OW 241
4657: GO 4642
4659: POP
4660: POP
// if KurtStatus then
4661: LD_EXP 3
4665: IFFALSE 4688
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4667: LD_ADDR_EXP 64
4671: PUSH
4672: LD_STRING Kurt
4674: PPUSH
4675: LD_INT 0
4677: PPUSH
4678: LD_STRING 
4680: PPUSH
4681: CALL 69545 0 3
4685: ST_TO_ADDR
4686: GO 4710
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4688: LD_ADDR_EXP 64
4692: PUSH
4693: LD_STRING AltKurt
4695: PPUSH
4696: LD_EXP 1
4700: NOT
4701: PPUSH
4702: LD_STRING 
4704: PPUSH
4705: CALL 69545 0 3
4709: ST_TO_ADDR
// if not Kurt then
4710: LD_EXP 64
4714: NOT
4715: IFFALSE 4741
// begin InitHc ;
4717: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4721: LD_INT 1
4723: PPUSH
4724: LD_INT 10
4726: PPUSH
4727: CALL_OW 381
// Kurt := CreateHuman ;
4731: LD_ADDR_EXP 64
4735: PUSH
4736: CALL_OW 44
4740: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4741: LD_EXP 64
4745: PPUSH
4746: LD_INT 324
4748: PPUSH
4749: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4753: LD_ADDR_EXP 65
4757: PUSH
4758: LD_STRING Kozlov
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: LD_STRING 
4766: PPUSH
4767: CALL 69545 0 3
4771: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4772: LD_EXP 65
4776: PPUSH
4777: LD_INT 22
4779: PUSH
4780: LD_INT 8
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: LD_INT 23
4789: PUSH
4790: LD_INT 3
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PUSH
4797: LD_INT 30
4799: PUSH
4800: LD_INT 8
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: EMPTY
4808: LIST
4809: LIST
4810: LIST
4811: PPUSH
4812: CALL_OW 69
4816: PUSH
4817: LD_INT 1
4819: ARRAY
4820: PPUSH
4821: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4825: LD_EXP 65
4829: PPUSH
4830: LD_INT 3
4832: PPUSH
4833: LD_INT 10
4835: PPUSH
4836: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4840: LD_EXP 65
4844: PPUSH
4845: LD_INT 4
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4855: LD_ADDR_VAR 0 5
4859: PUSH
4860: LD_INT 22
4862: PUSH
4863: LD_VAR 0 3
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: LD_INT 30
4874: PUSH
4875: LD_INT 32
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: LD_INT 58
4884: PUSH
4885: EMPTY
4886: LIST
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: LIST
4892: PPUSH
4893: CALL_OW 69
4897: ST_TO_ADDR
// for i = 1 to 10 do
4898: LD_ADDR_VAR 0 2
4902: PUSH
4903: DOUBLE
4904: LD_INT 1
4906: DEC
4907: ST_TO_ADDR
4908: LD_INT 10
4910: PUSH
4911: FOR_TO
4912: IFFALSE 4984
// begin uc_nation := nation_nature ;
4914: LD_ADDR_OWVAR 21
4918: PUSH
4919: LD_INT 0
4921: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4922: LD_ADDR_OWVAR 28
4926: PUSH
4927: LD_INT 15
4929: ST_TO_ADDR
// hc_gallery :=  ;
4930: LD_ADDR_OWVAR 33
4934: PUSH
4935: LD_STRING 
4937: ST_TO_ADDR
// hc_name :=  ;
4938: LD_ADDR_OWVAR 26
4942: PUSH
4943: LD_STRING 
4945: ST_TO_ADDR
// un := CreateHuman ;
4946: LD_ADDR_VAR 0 4
4950: PUSH
4951: CALL_OW 44
4955: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4956: LD_VAR 0 4
4960: PPUSH
4961: LD_VAR 0 5
4965: PUSH
4966: LD_VAR 0 5
4970: PUSH
4971: LD_VAR 0 2
4975: MINUS
4976: ARRAY
4977: PPUSH
4978: CALL_OW 52
// end ;
4982: GO 4911
4984: POP
4985: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4986: LD_ADDR_VAR 0 5
4990: PUSH
4991: LD_STRING 12_kurt_squad
4993: PPUSH
4994: CALL_OW 31
4998: ST_TO_ADDR
// if tmp then
4999: LD_VAR 0 5
5003: IFFALSE 5037
// for i in tmp do
5005: LD_ADDR_VAR 0 2
5009: PUSH
5010: LD_VAR 0 5
5014: PUSH
5015: FOR_IN
5016: IFFALSE 5035
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5018: LD_VAR 0 2
5022: PPUSH
5023: LD_INT 5
5025: PPUSH
5026: LD_INT 0
5028: PPUSH
5029: CALL_OW 49
5033: GO 5015
5035: POP
5036: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5037: LD_INT 324
5039: PPUSH
5040: LD_INT 5
5042: PPUSH
5043: LD_STRING 
5045: PPUSH
5046: LD_INT 8
5048: PUSH
5049: LD_INT 9
5051: PUSH
5052: LD_INT 10
5054: PUSH
5055: LD_INT 10
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: PPUSH
5070: LD_INT 3000
5072: PUSH
5073: LD_INT 500
5075: PUSH
5076: LD_INT 150
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: LIST
5083: PPUSH
5084: LD_INT 16
5086: PUSH
5087: LD_INT 6
5089: PUSH
5090: LD_INT 6
5092: PUSH
5093: LD_INT 8
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: PPUSH
5102: CALL 78206 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5106: LD_ADDR_EXP 102
5110: PUSH
5111: LD_EXP 102
5115: PPUSH
5116: LD_INT 3
5118: PPUSH
5119: LD_INT 22
5121: PUSH
5122: LD_VAR 0 3
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: PUSH
5131: LD_INT 23
5133: PUSH
5134: LD_INT 2
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PUSH
5141: LD_INT 3
5143: PUSH
5144: LD_INT 21
5146: PUSH
5147: LD_INT 2
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: LIST
5162: PPUSH
5163: CALL_OW 69
5167: PUSH
5168: LD_EXP 64
5172: DIFF
5173: PPUSH
5174: CALL_OW 1
5178: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5179: LD_INT 1
5181: PPUSH
5182: LD_INT 7
5184: PPUSH
5185: CALL_OW 383
// hc_name := Ali Hadrach ;
5189: LD_ADDR_OWVAR 26
5193: PUSH
5194: LD_STRING Ali Hadrach
5196: ST_TO_ADDR
// hc_face_number := 31 ;
5197: LD_ADDR_OWVAR 34
5201: PUSH
5202: LD_INT 31
5204: ST_TO_ADDR
// Friend := CreateHuman ;
5205: LD_ADDR_EXP 66
5209: PUSH
5210: CALL_OW 44
5214: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5215: LD_INT 14
5217: PPUSH
5218: LD_INT 3
5220: PPUSH
5221: LD_INT 1
5223: PPUSH
5224: LD_INT 29
5226: PPUSH
5227: LD_INT 100
5229: PPUSH
5230: CALL 74385 0 5
// powellBomb := CreateVehicle ;
5234: LD_ADDR_EXP 67
5238: PUSH
5239: CALL_OW 45
5243: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5244: LD_EXP 67
5248: PPUSH
5249: LD_INT 90
5251: PPUSH
5252: LD_INT 51
5254: PPUSH
5255: LD_INT 0
5257: PPUSH
5258: CALL_OW 48
// end ;
5262: LD_VAR 0 1
5266: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5267: LD_INT 0
5269: PPUSH
5270: PPUSH
5271: PPUSH
// if IsLive ( kozlov_fac ) then
5272: LD_INT 332
5274: PPUSH
5275: CALL_OW 300
5279: IFFALSE 5283
// exit ;
5281: GO 5850
// ComExitBuilding ( Kozlov ) ;
5283: LD_EXP 65
5287: PPUSH
5288: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5292: LD_EXP 65
5296: PPUSH
5297: CALL_OW 257
5301: PUSH
5302: LD_INT 2
5304: NONEQUAL
5305: IFFALSE 5340
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5307: LD_EXP 65
5311: PPUSH
5312: LD_INT 324
5314: PPUSH
5315: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5319: LD_EXP 65
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5331: LD_EXP 65
5335: PPUSH
5336: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5340: LD_EXP 65
5344: PPUSH
5345: LD_INT 2
5347: PPUSH
5348: LD_INT 93
5350: PPUSH
5351: LD_INT 32
5353: PPUSH
5354: LD_INT 3
5356: PPUSH
5357: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5361: LD_INT 35
5363: PPUSH
5364: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5368: LD_INT 22
5370: PUSH
5371: LD_INT 8
5373: PUSH
5374: EMPTY
5375: LIST
5376: LIST
5377: PUSH
5378: LD_INT 30
5380: PUSH
5381: LD_INT 3
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 23
5390: PUSH
5391: LD_INT 3
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: LD_INT 57
5400: PUSH
5401: EMPTY
5402: LIST
5403: PUSH
5404: EMPTY
5405: LIST
5406: LIST
5407: LIST
5408: LIST
5409: PPUSH
5410: CALL_OW 69
5414: IFFALSE 5361
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5416: LD_ADDR_VAR 0 2
5420: PUSH
5421: LD_INT 22
5423: PUSH
5424: LD_INT 8
5426: PUSH
5427: EMPTY
5428: LIST
5429: LIST
5430: PUSH
5431: LD_INT 30
5433: PUSH
5434: LD_INT 3
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PUSH
5441: LD_INT 23
5443: PUSH
5444: LD_INT 3
5446: PUSH
5447: EMPTY
5448: LIST
5449: LIST
5450: PUSH
5451: LD_INT 57
5453: PUSH
5454: EMPTY
5455: LIST
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL_OW 69
5467: PUSH
5468: LD_INT 1
5470: ARRAY
5471: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5472: LD_INT 22
5474: PUSH
5475: LD_INT 8
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: PUSH
5482: LD_INT 23
5484: PUSH
5485: LD_INT 3
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: PUSH
5492: LD_INT 30
5494: PUSH
5495: LD_INT 21
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: PPUSH
5507: CALL_OW 69
5511: NOT
5512: IFFALSE 5590
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5514: LD_EXP 65
5518: PPUSH
5519: LD_INT 21
5521: PPUSH
5522: LD_INT 97
5524: PPUSH
5525: LD_INT 36
5527: PPUSH
5528: LD_INT 5
5530: PPUSH
5531: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5535: LD_INT 35
5537: PPUSH
5538: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5542: LD_INT 22
5544: PUSH
5545: LD_INT 8
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: PUSH
5552: LD_INT 23
5554: PUSH
5555: LD_INT 3
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: PUSH
5562: LD_INT 30
5564: PUSH
5565: LD_INT 21
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PUSH
5572: LD_INT 57
5574: PUSH
5575: EMPTY
5576: LIST
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: LIST
5582: LIST
5583: PPUSH
5584: CALL_OW 69
5588: IFFALSE 5535
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5590: LD_INT 22
5592: PUSH
5593: LD_INT 8
5595: PUSH
5596: EMPTY
5597: LIST
5598: LIST
5599: PUSH
5600: LD_INT 23
5602: PUSH
5603: LD_INT 3
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: PUSH
5610: LD_INT 30
5612: PUSH
5613: LD_INT 18
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: PPUSH
5625: CALL_OW 69
5629: NOT
5630: IFFALSE 5708
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5632: LD_EXP 65
5636: PPUSH
5637: LD_INT 18
5639: PPUSH
5640: LD_INT 89
5642: PPUSH
5643: LD_INT 32
5645: PPUSH
5646: LD_INT 1
5648: PPUSH
5649: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5660: LD_INT 22
5662: PUSH
5663: LD_INT 8
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PUSH
5670: LD_INT 23
5672: PUSH
5673: LD_INT 3
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 30
5682: PUSH
5683: LD_INT 18
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 57
5692: PUSH
5693: EMPTY
5694: LIST
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: LIST
5701: PPUSH
5702: CALL_OW 69
5706: IFFALSE 5653
// end ; lab := kozlov_lab ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_INT 336
5715: ST_TO_ADDR
// if not lab then
5716: LD_VAR 0 3
5720: NOT
5721: IFFALSE 5725
// exit ;
5723: GO 5850
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5725: LD_EXP 65
5729: PPUSH
5730: LD_VAR 0 3
5734: PUSH
5735: LD_INT 1
5737: ARRAY
5738: PPUSH
5739: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5743: LD_EXP 65
5747: PPUSH
5748: LD_INT 4
5750: PPUSH
5751: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5755: LD_VAR 0 3
5759: PUSH
5760: LD_INT 1
5762: ARRAY
5763: PPUSH
5764: LD_INT 25
5766: PPUSH
5767: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5771: LD_INT 35
5773: PPUSH
5774: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5778: LD_INT 25
5780: PPUSH
5781: LD_INT 8
5783: PPUSH
5784: CALL_OW 321
5788: PUSH
5789: LD_INT 2
5791: EQUAL
5792: IFFALSE 5771
// ComExitBuilding ( Kozlov ) ;
5794: LD_EXP 65
5798: PPUSH
5799: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5803: LD_EXP 65
5807: PPUSH
5808: LD_VAR 0 2
5812: PPUSH
5813: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5817: LD_EXP 65
5821: PPUSH
5822: LD_INT 3
5824: PPUSH
5825: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5829: LD_VAR 0 2
5833: PPUSH
5834: LD_INT 23
5836: PPUSH
5837: LD_INT 3
5839: PPUSH
5840: LD_INT 1
5842: PPUSH
5843: LD_INT 48
5845: PPUSH
5846: CALL_OW 125
// end ;
5850: LD_VAR 0 1
5854: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5855: LD_EXP 22
5859: NOT
5860: PUSH
5861: LD_EXP 15
5865: PUSH
5866: LD_INT 6
5868: GREATEREQUAL
5869: AND
5870: IFFALSE 5951
5872: GO 5874
5874: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5875: LD_INT 3
5877: PPUSH
5878: LD_INT 3
5880: PPUSH
5881: CALL 63256 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5885: LD_INT 3
5887: PPUSH
5888: LD_INT 14
5890: PUSH
5891: LD_INT 1
5893: PUSH
5894: LD_INT 1
5896: PUSH
5897: LD_INT 28
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 14
5908: PUSH
5909: LD_INT 1
5911: PUSH
5912: LD_INT 1
5914: PUSH
5915: LD_INT 28
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: PUSH
5924: LD_INT 14
5926: PUSH
5927: LD_INT 1
5929: PUSH
5930: LD_INT 1
5932: PUSH
5933: LD_INT 28
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: LIST
5946: PPUSH
5947: CALL 63119 0 2
// end ;
5951: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
5952: LD_EXP 22
5956: NOT
5957: PUSH
5958: LD_EXP 15
5962: PUSH
5963: LD_INT 6
5965: GREATEREQUAL
5966: AND
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 64537 0 2
5978: NOT
5979: AND
5980: IFFALSE 6927
5982: GO 5984
5984: DISABLE
5985: LD_INT 0
5987: PPUSH
5988: PPUSH
5989: PPUSH
5990: PPUSH
// begin enable ;
5991: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5992: LD_INT 22
5994: PUSH
5995: LD_INT 8
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 23
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: LD_INT 30
6014: PUSH
6015: LD_INT 3
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 69
6031: NOT
6032: IFFALSE 6036
// exit ;
6034: GO 6927
// if Prob ( 40 ) then
6036: LD_INT 40
6038: PPUSH
6039: CALL_OW 13
6043: IFFALSE 6170
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6045: LD_INT 3
6047: PPUSH
6048: LD_INT 14
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 14
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 28
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_INT 14
6086: PUSH
6087: LD_INT 1
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: LD_INT 28
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 14
6104: PUSH
6105: LD_INT 1
6107: PUSH
6108: LD_INT 2
6110: PUSH
6111: LD_INT 28
6113: PUSH
6114: EMPTY
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: PUSH
6120: LD_INT 14
6122: PUSH
6123: LD_INT 1
6125: PUSH
6126: LD_INT 2
6128: PUSH
6129: LD_INT 28
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: PUSH
6138: LD_INT 14
6140: PUSH
6141: LD_INT 1
6143: PUSH
6144: LD_INT 2
6146: PUSH
6147: LD_INT 26
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PPUSH
6164: CALL 63119 0 2
// end else
6168: GO 6377
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6170: LD_INT 3
6172: PPUSH
6173: LD_INT 14
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 27
6184: PUSH
6185: LD_INT 26
6187: PUSH
6188: LD_INT 26
6190: PUSH
6191: LD_INT 28
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PUSH
6200: LD_OWVAR 67
6204: ARRAY
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PUSH
6212: LD_INT 14
6214: PUSH
6215: LD_INT 1
6217: PUSH
6218: LD_INT 2
6220: PUSH
6221: LD_INT 27
6223: PUSH
6224: LD_INT 26
6226: PUSH
6227: LD_INT 26
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: PUSH
6239: LD_OWVAR 67
6243: ARRAY
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 14
6253: PUSH
6254: LD_INT 1
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 26
6262: PUSH
6263: LD_INT 26
6265: PUSH
6266: LD_INT 29
6268: PUSH
6269: LD_INT 29
6271: PUSH
6272: EMPTY
6273: LIST
6274: LIST
6275: LIST
6276: LIST
6277: PUSH
6278: LD_OWVAR 67
6282: ARRAY
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 13
6292: PUSH
6293: LD_INT 1
6295: PUSH
6296: LD_INT 2
6298: PUSH
6299: LD_INT 26
6301: PUSH
6302: LD_INT 29
6304: PUSH
6305: LD_INT 29
6307: PUSH
6308: LD_INT 29
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: LIST
6315: LIST
6316: PUSH
6317: LD_OWVAR 67
6321: ARRAY
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PUSH
6329: LD_INT 13
6331: PUSH
6332: LD_INT 1
6334: PUSH
6335: LD_INT 2
6337: PUSH
6338: LD_INT 29
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: LIST
6346: PUSH
6347: LD_INT 14
6349: PUSH
6350: LD_INT 1
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 26
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: PPUSH
6373: CALL 63119 0 2
// end ; wait ( 2 2$00 ) ;
6377: LD_INT 4200
6379: PPUSH
6380: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 8
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 2
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: LD_INT 3
6411: PUSH
6412: LD_INT 34
6414: PUSH
6415: LD_INT 31
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 34
6424: PUSH
6425: LD_INT 32
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 34
6434: PUSH
6435: LD_INT 88
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: PPUSH
6453: CALL_OW 69
6457: PUSH
6458: LD_EXP 124
6462: PUSH
6463: LD_INT 3
6465: ARRAY
6466: DIFF
6467: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6468: LD_ADDR_EXP 121
6472: PUSH
6473: LD_EXP 121
6477: PPUSH
6478: LD_INT 3
6480: PPUSH
6481: LD_EXP 121
6485: PUSH
6486: LD_INT 3
6488: ARRAY
6489: PUSH
6490: LD_VAR 0 2
6494: DIFF
6495: PPUSH
6496: CALL_OW 1
6500: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6501: LD_ADDR_VAR 0 3
6505: PUSH
6506: LD_INT 0
6508: PPUSH
6509: LD_INT 2
6511: PPUSH
6512: CALL_OW 12
6516: ST_TO_ADDR
// if target then
6517: LD_VAR 0 3
6521: IFFALSE 6683
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6523: LD_ADDR_VAR 0 2
6527: PUSH
6528: LD_VAR 0 2
6532: PPUSH
6533: LD_INT 24
6535: PUSH
6536: LD_INT 250
6538: PUSH
6539: EMPTY
6540: LIST
6541: LIST
6542: PPUSH
6543: CALL_OW 72
6547: ST_TO_ADDR
// if not tmp then
6548: LD_VAR 0 2
6552: NOT
6553: IFFALSE 6557
// break ;
6555: GO 6681
// for i in tmp do
6557: LD_ADDR_VAR 0 1
6561: PUSH
6562: LD_VAR 0 2
6566: PUSH
6567: FOR_IN
6568: IFFALSE 6608
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6570: LD_VAR 0 1
6574: PPUSH
6575: LD_INT 89
6577: PPUSH
6578: LD_INT 71
6580: PPUSH
6581: CALL_OW 297
6585: PUSH
6586: LD_INT 9
6588: GREATER
6589: IFFALSE 6606
// ComMoveXY ( i , 89 , 71 ) ;
6591: LD_VAR 0 1
6595: PPUSH
6596: LD_INT 89
6598: PPUSH
6599: LD_INT 71
6601: PPUSH
6602: CALL_OW 111
6606: GO 6567
6608: POP
6609: POP
// wait ( 0 0$1 ) ;
6610: LD_INT 35
6612: PPUSH
6613: CALL_OW 67
// p := Inc ( p ) ;
6617: LD_ADDR_VAR 0 4
6621: PUSH
6622: LD_VAR 0 4
6626: PPUSH
6627: CALL 108597 0 1
6631: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6632: LD_VAR 0 2
6636: PPUSH
6637: LD_INT 92
6639: PUSH
6640: LD_INT 89
6642: PUSH
6643: LD_INT 71
6645: PUSH
6646: LD_INT 9
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: LIST
6653: LIST
6654: PPUSH
6655: CALL_OW 72
6659: PUSH
6660: LD_VAR 0 2
6664: PUSH
6665: LD_INT 1
6667: MINUS
6668: GREATEREQUAL
6669: PUSH
6670: LD_VAR 0 4
6674: PUSH
6675: LD_INT 30
6677: GREATER
6678: OR
6679: IFFALSE 6523
// end else
6681: GO 6841
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6683: LD_ADDR_VAR 0 2
6687: PUSH
6688: LD_VAR 0 2
6692: PPUSH
6693: LD_INT 24
6695: PUSH
6696: LD_INT 250
6698: PUSH
6699: EMPTY
6700: LIST
6701: LIST
6702: PPUSH
6703: CALL_OW 72
6707: ST_TO_ADDR
// if not tmp then
6708: LD_VAR 0 2
6712: NOT
6713: IFFALSE 6717
// break ;
6715: GO 6841
// for i in tmp do
6717: LD_ADDR_VAR 0 1
6721: PUSH
6722: LD_VAR 0 2
6726: PUSH
6727: FOR_IN
6728: IFFALSE 6768
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6730: LD_VAR 0 1
6734: PPUSH
6735: LD_INT 125
6737: PPUSH
6738: LD_INT 129
6740: PPUSH
6741: CALL_OW 297
6745: PUSH
6746: LD_INT 9
6748: GREATER
6749: IFFALSE 6766
// ComMoveXY ( i , 125 , 129 ) ;
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 125
6758: PPUSH
6759: LD_INT 129
6761: PPUSH
6762: CALL_OW 111
6766: GO 6727
6768: POP
6769: POP
// wait ( 0 0$1 ) ;
6770: LD_INT 35
6772: PPUSH
6773: CALL_OW 67
// p := Inc ( p ) ;
6777: LD_ADDR_VAR 0 4
6781: PUSH
6782: LD_VAR 0 4
6786: PPUSH
6787: CALL 108597 0 1
6791: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6792: LD_VAR 0 2
6796: PPUSH
6797: LD_INT 92
6799: PUSH
6800: LD_INT 125
6802: PUSH
6803: LD_INT 129
6805: PUSH
6806: LD_INT 9
6808: PUSH
6809: EMPTY
6810: LIST
6811: LIST
6812: LIST
6813: LIST
6814: PPUSH
6815: CALL_OW 72
6819: PUSH
6820: LD_VAR 0 2
6824: PUSH
6825: LD_INT 1
6827: MINUS
6828: GREATEREQUAL
6829: PUSH
6830: LD_VAR 0 4
6834: PUSH
6835: LD_INT 30
6837: GREATER
6838: OR
6839: IFFALSE 6683
// end ; repeat wait ( 0 0$1 ) ;
6841: LD_INT 35
6843: PPUSH
6844: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6848: LD_ADDR_VAR 0 2
6852: PUSH
6853: LD_VAR 0 2
6857: PPUSH
6858: LD_INT 50
6860: PUSH
6861: EMPTY
6862: LIST
6863: PPUSH
6864: CALL_OW 72
6868: ST_TO_ADDR
// for i in tmp do
6869: LD_ADDR_VAR 0 1
6873: PUSH
6874: LD_VAR 0 2
6878: PUSH
6879: FOR_IN
6880: IFFALSE 6918
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6882: LD_VAR 0 1
6886: PPUSH
6887: LD_INT 81
6889: PUSH
6890: LD_INT 8
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PPUSH
6897: CALL_OW 69
6901: PPUSH
6902: LD_VAR 0 1
6906: PPUSH
6907: CALL_OW 74
6911: PPUSH
6912: CALL_OW 115
6916: GO 6879
6918: POP
6919: POP
// until not tmp ;
6920: LD_VAR 0 2
6924: NOT
6925: IFFALSE 6841
// end ;
6927: PPOPN 4
6929: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6930: LD_EXP 22
6934: NOT
6935: PUSH
6936: LD_EXP 15
6940: PUSH
6941: LD_INT 6
6943: GREATEREQUAL
6944: AND
6945: PUSH
6946: LD_OWVAR 67
6950: PUSH
6951: LD_INT 1
6953: GREATER
6954: AND
6955: IFFALSE 7488
6957: GO 6959
6959: DISABLE
6960: LD_INT 0
6962: PPUSH
6963: PPUSH
6964: PPUSH
// begin enable ;
6965: ENABLE
// tmp := [ ] ;
6966: LD_ADDR_VAR 0 3
6970: PUSH
6971: EMPTY
6972: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6973: LD_ADDR_VAR 0 1
6977: PUSH
6978: DOUBLE
6979: LD_INT 1
6981: DEC
6982: ST_TO_ADDR
6983: LD_INT 4
6985: PUSH
6986: LD_INT 6
6988: PUSH
6989: LD_INT 7
6991: PUSH
6992: LD_INT 8
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: LIST
6999: LIST
7000: PUSH
7001: LD_OWVAR 67
7005: ARRAY
7006: PUSH
7007: FOR_TO
7008: IFFALSE 7168
// begin uc_side := 8 ;
7010: LD_ADDR_OWVAR 20
7014: PUSH
7015: LD_INT 8
7017: ST_TO_ADDR
// uc_nation := 2 ;
7018: LD_ADDR_OWVAR 21
7022: PUSH
7023: LD_INT 2
7025: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7026: LD_INT 13
7028: PUSH
7029: LD_INT 14
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: LD_INT 1
7038: PPUSH
7039: LD_INT 2
7041: PPUSH
7042: CALL_OW 12
7046: ARRAY
7047: PPUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 5
7053: PPUSH
7054: LD_INT 27
7056: PUSH
7057: LD_INT 28
7059: PUSH
7060: LD_INT 26
7062: PUSH
7063: LD_INT 25
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 4
7077: PPUSH
7078: CALL_OW 12
7082: ARRAY
7083: PPUSH
7084: LD_INT 88
7086: PPUSH
7087: CALL 74385 0 5
// un := CreateVehicle ;
7091: LD_ADDR_VAR 0 2
7095: PUSH
7096: CALL_OW 45
7100: ST_TO_ADDR
// tmp := tmp ^ un ;
7101: LD_ADDR_VAR 0 3
7105: PUSH
7106: LD_VAR 0 3
7110: PUSH
7111: LD_VAR 0 2
7115: ADD
7116: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7117: LD_VAR 0 2
7121: PPUSH
7122: LD_INT 3
7124: PPUSH
7125: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7129: LD_VAR 0 2
7133: PPUSH
7134: LD_INT 30
7136: PPUSH
7137: LD_INT 0
7139: PPUSH
7140: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7144: LD_VAR 0 2
7148: PPUSH
7149: LD_INT 16
7151: PPUSH
7152: LD_INT 11
7154: PPUSH
7155: CALL_OW 111
// wait ( 0 0$2 ) ;
7159: LD_INT 70
7161: PPUSH
7162: CALL_OW 67
// end ;
7166: GO 7007
7168: POP
7169: POP
// for i = 1 to Difficulty do
7170: LD_ADDR_VAR 0 1
7174: PUSH
7175: DOUBLE
7176: LD_INT 1
7178: DEC
7179: ST_TO_ADDR
7180: LD_OWVAR 67
7184: PUSH
7185: FOR_TO
7186: IFFALSE 7315
// begin uc_side := 8 ;
7188: LD_ADDR_OWVAR 20
7192: PUSH
7193: LD_INT 8
7195: ST_TO_ADDR
// uc_nation := 2 ;
7196: LD_ADDR_OWVAR 21
7200: PUSH
7201: LD_INT 2
7203: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7204: LD_INT 0
7206: PPUSH
7207: LD_INT 8
7209: PPUSH
7210: LD_INT 8
7212: PUSH
7213: LD_INT 8
7215: PUSH
7216: LD_INT 9
7218: PUSH
7219: LD_INT 10
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: LIST
7226: LIST
7227: PUSH
7228: LD_OWVAR 67
7232: ARRAY
7233: PPUSH
7234: CALL_OW 380
// un := CreateHuman ;
7238: LD_ADDR_VAR 0 2
7242: PUSH
7243: CALL_OW 44
7247: ST_TO_ADDR
// tmp := tmp ^ un ;
7248: LD_ADDR_VAR 0 3
7252: PUSH
7253: LD_VAR 0 3
7257: PUSH
7258: LD_VAR 0 2
7262: ADD
7263: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7264: LD_VAR 0 2
7268: PPUSH
7269: LD_INT 3
7271: PPUSH
7272: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7276: LD_VAR 0 2
7280: PPUSH
7281: LD_INT 30
7283: PPUSH
7284: LD_INT 0
7286: PPUSH
7287: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7291: LD_VAR 0 2
7295: PPUSH
7296: LD_INT 16
7298: PPUSH
7299: LD_INT 11
7301: PPUSH
7302: CALL_OW 111
// wait ( 0 0$2 ) ;
7306: LD_INT 70
7308: PPUSH
7309: CALL_OW 67
// end ;
7313: GO 7185
7315: POP
7316: POP
// repeat wait ( 0 0$1 ) ;
7317: LD_INT 35
7319: PPUSH
7320: CALL_OW 67
// if legionDestroyed then
7324: LD_EXP 22
7328: IFFALSE 7332
// exit ;
7330: GO 7488
// for i in tmp do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: LD_VAR 0 3
7341: PUSH
7342: FOR_IN
7343: IFFALSE 7479
// begin if GetLives ( i ) > 250 then
7345: LD_VAR 0 1
7349: PPUSH
7350: CALL_OW 256
7354: PUSH
7355: LD_INT 250
7357: GREATER
7358: IFFALSE 7450
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7360: LD_INT 81
7362: PUSH
7363: LD_INT 8
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 91
7372: PUSH
7373: LD_VAR 0 1
7377: PUSH
7378: LD_INT 10
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PPUSH
7390: CALL_OW 69
7394: NOT
7395: IFFALSE 7414
// ComAgressiveMove ( i , 67 , 110 ) else
7397: LD_VAR 0 1
7401: PPUSH
7402: LD_INT 67
7404: PPUSH
7405: LD_INT 110
7407: PPUSH
7408: CALL_OW 114
7412: GO 7448
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7414: LD_VAR 0 1
7418: PPUSH
7419: LD_INT 81
7421: PUSH
7422: LD_INT 8
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PPUSH
7429: CALL_OW 69
7433: PPUSH
7434: LD_VAR 0 1
7438: PPUSH
7439: CALL_OW 74
7443: PPUSH
7444: CALL_OW 115
// end else
7448: GO 7477
// if IsDead ( i ) then
7450: LD_VAR 0 1
7454: PPUSH
7455: CALL_OW 301
7459: IFFALSE 7477
// tmp := tmp diff i ;
7461: LD_ADDR_VAR 0 3
7465: PUSH
7466: LD_VAR 0 3
7470: PUSH
7471: LD_VAR 0 1
7475: DIFF
7476: ST_TO_ADDR
// end ;
7477: GO 7342
7479: POP
7480: POP
// until not tmp ;
7481: LD_VAR 0 3
7485: NOT
7486: IFFALSE 7317
// end ; end_of_file
7488: PPOPN 3
7490: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7491: LD_INT 0
7493: PPUSH
7494: PPUSH
7495: PPUSH
7496: PPUSH
7497: PPUSH
7498: PPUSH
7499: PPUSH
7500: PPUSH
7501: PPUSH
7502: PPUSH
// side := 3 ;
7503: LD_ADDR_VAR 0 6
7507: PUSH
7508: LD_INT 3
7510: ST_TO_ADDR
// uc_side := side ;
7511: LD_ADDR_OWVAR 20
7515: PUSH
7516: LD_VAR 0 6
7520: ST_TO_ADDR
// uc_nation := 3 ;
7521: LD_ADDR_OWVAR 21
7525: PUSH
7526: LD_INT 3
7528: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7529: LD_ADDR_VAR 0 2
7533: PUSH
7534: LD_INT 22
7536: PUSH
7537: LD_VAR 0 6
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 21
7548: PUSH
7549: LD_INT 3
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: EMPTY
7557: LIST
7558: LIST
7559: PPUSH
7560: CALL_OW 69
7564: PUSH
7565: FOR_IN
7566: IFFALSE 7582
// SetBLevel ( i , 10 ) ;
7568: LD_VAR 0 2
7572: PPUSH
7573: LD_INT 10
7575: PPUSH
7576: CALL_OW 241
7580: GO 7565
7582: POP
7583: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7584: LD_ADDR_VAR 0 10
7588: PUSH
7589: LD_INT 22
7591: PUSH
7592: LD_VAR 0 6
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PUSH
7601: LD_INT 30
7603: PUSH
7604: LD_INT 34
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PPUSH
7615: CALL_OW 69
7619: ST_TO_ADDR
// if teleport then
7620: LD_VAR 0 10
7624: IFFALSE 7645
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7626: LD_VAR 0 10
7630: PUSH
7631: LD_INT 1
7633: ARRAY
7634: PPUSH
7635: LD_INT 123
7637: PPUSH
7638: LD_INT 122
7640: PPUSH
7641: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7645: LD_ADDR_EXP 68
7649: PUSH
7650: LD_STRING Platonov
7652: PPUSH
7653: CALL_OW 25
7657: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7658: LD_ADDR_EXP 69
7662: PUSH
7663: LD_STRING Kovalyuk
7665: PPUSH
7666: CALL_OW 25
7670: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7671: LD_ADDR_EXP 71
7675: PUSH
7676: LD_STRING Yakotich
7678: PPUSH
7679: LD_EXP 1
7683: NOT
7684: PPUSH
7685: LD_STRING 09_
7687: PPUSH
7688: CALL 69545 0 3
7692: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7693: LD_ADDR_EXP 70
7697: PUSH
7698: LD_STRING Bystrov
7700: PPUSH
7701: CALL_OW 25
7705: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7706: LD_ADDR_EXP 72
7710: PUSH
7711: LD_STRING Gleb
7713: PPUSH
7714: CALL_OW 25
7718: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7719: LD_STRING 03_Cornel
7721: PPUSH
7722: CALL_OW 28
7726: IFFALSE 7774
// begin Bierezov := NewCharacter ( Mikhail ) ;
7728: LD_ADDR_EXP 73
7732: PUSH
7733: LD_STRING Mikhail
7735: PPUSH
7736: CALL_OW 25
7740: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7741: LD_EXP 73
7745: PPUSH
7746: LD_INT 197
7748: PPUSH
7749: LD_INT 111
7751: PPUSH
7752: LD_INT 9
7754: PPUSH
7755: LD_INT 0
7757: PPUSH
7758: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7762: LD_EXP 73
7766: PPUSH
7767: LD_INT 3
7769: PPUSH
7770: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7774: LD_EXP 68
7778: PPUSH
7779: LD_INT 126
7781: PPUSH
7782: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7786: LD_EXP 69
7790: PPUSH
7791: LD_INT 134
7793: PPUSH
7794: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7798: LD_EXP 71
7802: PPUSH
7803: LD_INT 197
7805: PPUSH
7806: LD_INT 111
7808: PPUSH
7809: LD_INT 9
7811: PPUSH
7812: LD_INT 0
7814: PPUSH
7815: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7819: LD_EXP 70
7823: PPUSH
7824: LD_INT 197
7826: PPUSH
7827: LD_INT 111
7829: PPUSH
7830: LD_INT 9
7832: PPUSH
7833: LD_INT 0
7835: PPUSH
7836: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7840: LD_EXP 72
7844: PPUSH
7845: LD_INT 197
7847: PPUSH
7848: LD_INT 111
7850: PPUSH
7851: LD_INT 9
7853: PPUSH
7854: LD_INT 0
7856: PPUSH
7857: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
7861: LD_ADDR_VAR 0 5
7865: PUSH
7866: LD_INT 126
7868: PPUSH
7869: LD_INT 4
7871: PPUSH
7872: LD_STRING zhukov
7874: PPUSH
7875: LD_INT 9
7877: PUSH
7878: LD_INT 10
7880: PUSH
7881: LD_INT 10
7883: PUSH
7884: LD_INT 10
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: PUSH
7893: LD_OWVAR 67
7897: ARRAY
7898: PPUSH
7899: LD_INT 90000
7901: PUSH
7902: LD_INT 1000
7904: PUSH
7905: LD_INT 300
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: LIST
7912: PPUSH
7913: LD_INT 18
7915: PUSH
7916: LD_INT 8
7918: PUSH
7919: LD_INT 12
7921: PUSH
7922: LD_INT 6
7924: PUSH
7925: EMPTY
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: PPUSH
7931: CALL 78206 0 6
7935: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7936: LD_ADDR_EXP 102
7940: PUSH
7941: LD_EXP 102
7945: PPUSH
7946: LD_INT 2
7948: PPUSH
7949: LD_VAR 0 5
7953: PUSH
7954: LD_EXP 71
7958: PUSH
7959: LD_EXP 70
7963: PUSH
7964: LD_EXP 72
7968: PUSH
7969: LD_EXP 73
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: LIST
7978: LIST
7979: UNION
7980: PPUSH
7981: CALL_OW 1
7985: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7986: LD_ADDR_VAR 0 4
7990: PUSH
7991: LD_INT 267
7993: PPUSH
7994: CALL_OW 274
7998: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7999: LD_VAR 0 4
8003: PPUSH
8004: LD_INT 1
8006: PPUSH
8007: LD_INT 5000
8009: PPUSH
8010: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8014: LD_VAR 0 4
8018: PPUSH
8019: LD_INT 2
8021: PPUSH
8022: LD_INT 200
8024: PPUSH
8025: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8029: LD_VAR 0 4
8033: PPUSH
8034: LD_INT 3
8036: PPUSH
8037: LD_INT 200
8039: PPUSH
8040: CALL_OW 277
// for i := 1 to 6 do
8044: LD_ADDR_VAR 0 2
8048: PUSH
8049: DOUBLE
8050: LD_INT 1
8052: DEC
8053: ST_TO_ADDR
8054: LD_INT 6
8056: PUSH
8057: FOR_TO
8058: IFFALSE 8141
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8060: LD_INT 0
8062: PPUSH
8063: LD_INT 8
8065: PUSH
8066: LD_INT 9
8068: PUSH
8069: LD_INT 10
8071: PUSH
8072: LD_INT 10
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: LD_OWVAR 67
8085: ARRAY
8086: PPUSH
8087: CALL_OW 381
// un := CreateHuman ;
8091: LD_ADDR_VAR 0 8
8095: PUSH
8096: CALL_OW 44
8100: ST_TO_ADDR
// if i mod 2 = 0 then
8101: LD_VAR 0 2
8105: PUSH
8106: LD_INT 2
8108: MOD
8109: PUSH
8110: LD_INT 0
8112: EQUAL
8113: IFFALSE 8127
// SetClass ( un , class_bazooker ) ;
8115: LD_VAR 0 8
8119: PPUSH
8120: LD_INT 9
8122: PPUSH
8123: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8127: LD_VAR 0 8
8131: PPUSH
8132: LD_INT 460
8134: PPUSH
8135: CALL_OW 52
// end ;
8139: GO 8057
8141: POP
8142: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8143: LD_INT 21
8145: PPUSH
8146: LD_INT 3
8148: PPUSH
8149: LD_INT 3
8151: PPUSH
8152: LD_INT 52
8154: PPUSH
8155: LD_INT 100
8157: PPUSH
8158: CALL 74385 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8162: CALL_OW 45
8166: PPUSH
8167: LD_INT 259
8169: PPUSH
8170: LD_INT 145
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 0
8178: PPUSH
8179: CALL 109376 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8183: CALL_OW 45
8187: PPUSH
8188: LD_INT 245
8190: PPUSH
8191: LD_INT 139
8193: PPUSH
8194: LD_INT 3
8196: PPUSH
8197: LD_INT 0
8199: PPUSH
8200: CALL 109376 0 5
// behemoths := [ ] ;
8204: LD_ADDR_EXP 76
8208: PUSH
8209: EMPTY
8210: ST_TO_ADDR
// behemothBuilders := [ ] ;
8211: LD_ADDR_EXP 77
8215: PUSH
8216: EMPTY
8217: ST_TO_ADDR
// if Kovalyuk then
8218: LD_EXP 69
8222: IFFALSE 8244
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8224: LD_ADDR_EXP 77
8228: PUSH
8229: LD_EXP 77
8233: PPUSH
8234: LD_EXP 69
8238: PPUSH
8239: CALL 107236 0 2
8243: ST_TO_ADDR
// j := 3 ;
8244: LD_ADDR_VAR 0 3
8248: PUSH
8249: LD_INT 3
8251: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
8252: LD_ADDR_VAR 0 2
8256: PUSH
8257: LD_INT 22
8259: PUSH
8260: LD_INT 3
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: PUSH
8267: LD_INT 25
8269: PUSH
8270: LD_INT 3
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 69
8285: PUSH
8286: LD_EXP 69
8290: DIFF
8291: PUSH
8292: FOR_IN
8293: IFFALSE 8343
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8295: LD_ADDR_EXP 77
8299: PUSH
8300: LD_EXP 77
8304: PPUSH
8305: LD_VAR 0 2
8309: PPUSH
8310: CALL 107236 0 2
8314: ST_TO_ADDR
// j := j - 1 ;
8315: LD_ADDR_VAR 0 3
8319: PUSH
8320: LD_VAR 0 3
8324: PUSH
8325: LD_INT 1
8327: MINUS
8328: ST_TO_ADDR
// if j = 0 then
8329: LD_VAR 0 3
8333: PUSH
8334: LD_INT 0
8336: EQUAL
8337: IFFALSE 8341
// break ;
8339: GO 8343
// end ;
8341: GO 8292
8343: POP
8344: POP
// end ;
8345: LD_VAR 0 1
8349: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8350: LD_INT 0
8352: PPUSH
8353: PPUSH
8354: PPUSH
8355: PPUSH
8356: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8357: LD_ADDR_VAR 0 4
8361: PUSH
8362: LD_INT 209
8364: PUSH
8365: LD_INT 149
8367: PUSH
8368: EMPTY
8369: LIST
8370: LIST
8371: PUSH
8372: LD_INT 219
8374: PUSH
8375: LD_INT 154
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 223
8384: PUSH
8385: LD_INT 149
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: LD_INT 232
8394: PUSH
8395: LD_INT 155
8397: PUSH
8398: EMPTY
8399: LIST
8400: LIST
8401: PUSH
8402: EMPTY
8403: LIST
8404: LIST
8405: LIST
8406: LIST
8407: ST_TO_ADDR
// if not behemothBuilders then
8408: LD_EXP 77
8412: NOT
8413: IFFALSE 8417
// exit ;
8415: GO 8548
// j := 1 ;
8417: LD_ADDR_VAR 0 3
8421: PUSH
8422: LD_INT 1
8424: ST_TO_ADDR
// for i in behemothBuilders do
8425: LD_ADDR_VAR 0 2
8429: PUSH
8430: LD_EXP 77
8434: PUSH
8435: FOR_IN
8436: IFFALSE 8546
// begin if GetClass ( i ) <> class_mechanic then
8438: LD_VAR 0 2
8442: PPUSH
8443: CALL_OW 257
8447: PUSH
8448: LD_INT 3
8450: NONEQUAL
8451: IFFALSE 8465
// SetClass ( i , class_mechanic ) ;
8453: LD_VAR 0 2
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 336
// if IsInUnit ( i ) then
8465: LD_VAR 0 2
8469: PPUSH
8470: CALL_OW 310
8474: IFFALSE 8485
// ComExitBuilding ( i ) ;
8476: LD_VAR 0 2
8480: PPUSH
8481: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8485: LD_VAR 0 2
8489: PPUSH
8490: LD_INT 37
8492: PPUSH
8493: LD_VAR 0 4
8497: PUSH
8498: LD_VAR 0 3
8502: ARRAY
8503: PUSH
8504: LD_INT 1
8506: ARRAY
8507: PPUSH
8508: LD_VAR 0 4
8512: PUSH
8513: LD_VAR 0 3
8517: ARRAY
8518: PUSH
8519: LD_INT 2
8521: ARRAY
8522: PPUSH
8523: LD_INT 0
8525: PPUSH
8526: CALL_OW 230
// j := j + 1 ;
8530: LD_ADDR_VAR 0 3
8534: PUSH
8535: LD_VAR 0 3
8539: PUSH
8540: LD_INT 1
8542: PLUS
8543: ST_TO_ADDR
// end ;
8544: GO 8435
8546: POP
8547: POP
// end ;
8548: LD_VAR 0 1
8552: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8553: LD_INT 24
8555: PPUSH
8556: LD_INT 30
8558: PUSH
8559: LD_INT 37
8561: PUSH
8562: EMPTY
8563: LIST
8564: LIST
8565: PPUSH
8566: CALL_OW 70
8570: IFFALSE 8583
8572: GO 8574
8574: DISABLE
// behemothUnderConstruct := true ;
8575: LD_ADDR_EXP 26
8579: PUSH
8580: LD_INT 1
8582: ST_TO_ADDR
8583: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8584: LD_INT 3
8586: PPUSH
8587: CALL 107297 0 1
8591: PUSH
8592: LD_INT 22
8594: PUSH
8595: LD_INT 3
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PUSH
8602: LD_INT 30
8604: PUSH
8605: LD_INT 37
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 69
8620: NOT
8621: AND
8622: IFFALSE 8808
8624: GO 8626
8626: DISABLE
8627: LD_INT 0
8629: PPUSH
8630: PPUSH
// begin enable ;
8631: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8632: LD_ADDR_VAR 0 2
8636: PUSH
8637: LD_INT 3
8639: PPUSH
8640: CALL 107297 0 1
8644: ST_TO_ADDR
// for i in tmp do
8645: LD_ADDR_VAR 0 1
8649: PUSH
8650: LD_VAR 0 2
8654: PUSH
8655: FOR_IN
8656: IFFALSE 8806
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8658: LD_VAR 0 1
8662: PPUSH
8663: LD_INT 9
8665: PPUSH
8666: CALL_OW 308
8670: PUSH
8671: LD_VAR 0 1
8675: PPUSH
8676: CALL_OW 110
8680: PUSH
8681: LD_INT 2
8683: EQUAL
8684: NOT
8685: AND
8686: IFFALSE 8700
// SetTag ( i , 2 ) ;
8688: LD_VAR 0 1
8692: PPUSH
8693: LD_INT 2
8695: PPUSH
8696: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8700: LD_INT 81
8702: PUSH
8703: LD_INT 3
8705: PUSH
8706: EMPTY
8707: LIST
8708: LIST
8709: PUSH
8710: LD_INT 91
8712: PUSH
8713: LD_VAR 0 1
8717: PUSH
8718: LD_INT 12
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: LIST
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PPUSH
8730: CALL_OW 69
8734: NOT
8735: PUSH
8736: LD_VAR 0 1
8740: PPUSH
8741: CALL_OW 110
8745: PUSH
8746: LD_INT 2
8748: EQUAL
8749: NOT
8750: AND
8751: IFFALSE 8770
// ComAgressiveMove ( i , 64 , 93 ) else
8753: LD_VAR 0 1
8757: PPUSH
8758: LD_INT 64
8760: PPUSH
8761: LD_INT 93
8763: PPUSH
8764: CALL_OW 114
8768: GO 8804
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8770: LD_VAR 0 1
8774: PPUSH
8775: LD_INT 81
8777: PUSH
8778: LD_INT 3
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PPUSH
8785: CALL_OW 69
8789: PPUSH
8790: LD_VAR 0 1
8794: PPUSH
8795: CALL_OW 74
8799: PPUSH
8800: CALL_OW 115
// end ;
8804: GO 8655
8806: POP
8807: POP
// end ;
8808: PPOPN 2
8810: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8811: LD_INT 0
8813: PPUSH
8814: PPUSH
8815: PPUSH
// result := [ ] ;
8816: LD_ADDR_VAR 0 2
8820: PUSH
8821: EMPTY
8822: ST_TO_ADDR
// uc_side := 6 ;
8823: LD_ADDR_OWVAR 20
8827: PUSH
8828: LD_INT 6
8830: ST_TO_ADDR
// uc_nation := 3 ;
8831: LD_ADDR_OWVAR 21
8835: PUSH
8836: LD_INT 3
8838: ST_TO_ADDR
// case strength of 1 :
8839: LD_VAR 0 1
8843: PUSH
8844: LD_INT 1
8846: DOUBLE
8847: EQUAL
8848: IFTRUE 8852
8850: GO 8994
8852: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8853: LD_ADDR_VAR 0 3
8857: PUSH
8858: DOUBLE
8859: LD_INT 1
8861: DEC
8862: ST_TO_ADDR
8863: LD_INT 4
8865: PUSH
8866: LD_INT 5
8868: PUSH
8869: LD_INT 6
8871: PUSH
8872: LD_INT 7
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: PUSH
8881: LD_OWVAR 67
8885: ARRAY
8886: PUSH
8887: FOR_TO
8888: IFFALSE 8990
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8890: LD_INT 22
8892: PUSH
8893: LD_INT 24
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_VAR 0 3
8904: PUSH
8905: LD_INT 2
8907: MOD
8908: PUSH
8909: LD_INT 1
8911: PLUS
8912: ARRAY
8913: PPUSH
8914: LD_INT 1
8916: PUSH
8917: LD_INT 3
8919: PUSH
8920: EMPTY
8921: LIST
8922: LIST
8923: PUSH
8924: LD_INT 1
8926: PPUSH
8927: LD_INT 2
8929: PPUSH
8930: CALL_OW 12
8934: ARRAY
8935: PPUSH
8936: LD_INT 3
8938: PPUSH
8939: LD_INT 43
8941: PUSH
8942: LD_INT 44
8944: PUSH
8945: LD_INT 45
8947: PUSH
8948: EMPTY
8949: LIST
8950: LIST
8951: LIST
8952: PUSH
8953: LD_INT 1
8955: PPUSH
8956: LD_INT 3
8958: PPUSH
8959: CALL_OW 12
8963: ARRAY
8964: PPUSH
8965: LD_INT 80
8967: PPUSH
8968: CALL 74385 0 5
// result := result union CreateVehicle ;
8972: LD_ADDR_VAR 0 2
8976: PUSH
8977: LD_VAR 0 2
8981: PUSH
8982: CALL_OW 45
8986: UNION
8987: ST_TO_ADDR
// end ;
8988: GO 8887
8990: POP
8991: POP
// end ; 2 :
8992: GO 9989
8994: LD_INT 2
8996: DOUBLE
8997: EQUAL
8998: IFTRUE 9002
9000: GO 9170
9002: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9003: LD_ADDR_VAR 0 3
9007: PUSH
9008: DOUBLE
9009: LD_INT 1
9011: DEC
9012: ST_TO_ADDR
9013: LD_INT 5
9015: PUSH
9016: LD_INT 6
9018: PUSH
9019: LD_INT 7
9021: PUSH
9022: LD_INT 8
9024: PUSH
9025: EMPTY
9026: LIST
9027: LIST
9028: LIST
9029: LIST
9030: PUSH
9031: LD_OWVAR 67
9035: ARRAY
9036: PUSH
9037: FOR_TO
9038: IFFALSE 9166
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9040: LD_INT 22
9042: PUSH
9043: LD_INT 24
9045: PUSH
9046: LD_INT 24
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: PUSH
9054: LD_VAR 0 3
9058: PUSH
9059: LD_INT 3
9061: MOD
9062: PUSH
9063: LD_INT 1
9065: PLUS
9066: ARRAY
9067: PPUSH
9068: LD_INT 1
9070: PUSH
9071: LD_INT 3
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 1
9080: PPUSH
9081: LD_INT 2
9083: PPUSH
9084: CALL_OW 12
9088: ARRAY
9089: PPUSH
9090: LD_INT 3
9092: PPUSH
9093: LD_INT 43
9095: PUSH
9096: LD_INT 44
9098: PUSH
9099: LD_INT 45
9101: PUSH
9102: LD_INT 44
9104: PUSH
9105: LD_INT 46
9107: PUSH
9108: LD_INT 46
9110: PUSH
9111: LD_INT 49
9113: PUSH
9114: LD_INT 49
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: LIST
9121: LIST
9122: LIST
9123: LIST
9124: LIST
9125: LIST
9126: PUSH
9127: LD_VAR 0 3
9131: PUSH
9132: LD_INT 8
9134: MOD
9135: PUSH
9136: LD_INT 1
9138: PLUS
9139: ARRAY
9140: PPUSH
9141: LD_INT 80
9143: PPUSH
9144: CALL 74385 0 5
// result := result union CreateVehicle ;
9148: LD_ADDR_VAR 0 2
9152: PUSH
9153: LD_VAR 0 2
9157: PUSH
9158: CALL_OW 45
9162: UNION
9163: ST_TO_ADDR
// end ;
9164: GO 9037
9166: POP
9167: POP
// end ; 3 :
9168: GO 9989
9170: LD_INT 3
9172: DOUBLE
9173: EQUAL
9174: IFTRUE 9178
9176: GO 9350
9178: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9179: LD_ADDR_VAR 0 3
9183: PUSH
9184: DOUBLE
9185: LD_INT 1
9187: DEC
9188: ST_TO_ADDR
9189: LD_INT 6
9191: PUSH
9192: LD_INT 7
9194: PUSH
9195: LD_INT 8
9197: PUSH
9198: LD_INT 9
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: LIST
9205: LIST
9206: PUSH
9207: LD_OWVAR 67
9211: ARRAY
9212: PUSH
9213: FOR_TO
9214: IFFALSE 9346
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9216: LD_INT 22
9218: PUSH
9219: LD_INT 24
9221: PUSH
9222: LD_INT 24
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: PUSH
9230: LD_VAR 0 3
9234: PUSH
9235: LD_INT 3
9237: MOD
9238: PUSH
9239: LD_INT 1
9241: PLUS
9242: ARRAY
9243: PPUSH
9244: LD_INT 1
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 1
9256: PPUSH
9257: LD_INT 2
9259: PPUSH
9260: CALL_OW 12
9264: ARRAY
9265: PPUSH
9266: LD_INT 3
9268: PPUSH
9269: LD_INT 43
9271: PUSH
9272: LD_INT 47
9274: PUSH
9275: LD_INT 45
9277: PUSH
9278: LD_INT 45
9280: PUSH
9281: LD_INT 46
9283: PUSH
9284: LD_INT 46
9286: PUSH
9287: LD_INT 49
9289: PUSH
9290: LD_INT 49
9292: PUSH
9293: LD_INT 49
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: LIST
9300: LIST
9301: LIST
9302: LIST
9303: LIST
9304: LIST
9305: LIST
9306: PUSH
9307: LD_VAR 0 3
9311: PUSH
9312: LD_INT 9
9314: MOD
9315: PUSH
9316: LD_INT 1
9318: PLUS
9319: ARRAY
9320: PPUSH
9321: LD_INT 80
9323: PPUSH
9324: CALL 74385 0 5
// result := result union CreateVehicle ;
9328: LD_ADDR_VAR 0 2
9332: PUSH
9333: LD_VAR 0 2
9337: PUSH
9338: CALL_OW 45
9342: UNION
9343: ST_TO_ADDR
// end ;
9344: GO 9213
9346: POP
9347: POP
// end ; 4 :
9348: GO 9989
9350: LD_INT 4
9352: DOUBLE
9353: EQUAL
9354: IFTRUE 9358
9356: GO 9988
9358: POP
// begin uc_nation := 3 ;
9359: LD_ADDR_OWVAR 21
9363: PUSH
9364: LD_INT 3
9366: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9367: LD_ADDR_VAR 0 3
9371: PUSH
9372: DOUBLE
9373: LD_INT 1
9375: DEC
9376: ST_TO_ADDR
9377: LD_INT 6
9379: PUSH
9380: LD_INT 8
9382: PUSH
9383: LD_INT 9
9385: PUSH
9386: LD_INT 10
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: PUSH
9395: LD_OWVAR 67
9399: ARRAY
9400: PUSH
9401: FOR_TO
9402: IFFALSE 9534
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9404: LD_INT 22
9406: PUSH
9407: LD_INT 24
9409: PUSH
9410: LD_INT 24
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: LIST
9417: PUSH
9418: LD_VAR 0 3
9422: PUSH
9423: LD_INT 3
9425: MOD
9426: PUSH
9427: LD_INT 1
9429: PLUS
9430: ARRAY
9431: PPUSH
9432: LD_INT 1
9434: PUSH
9435: LD_INT 3
9437: PUSH
9438: EMPTY
9439: LIST
9440: LIST
9441: PUSH
9442: LD_INT 1
9444: PPUSH
9445: LD_INT 2
9447: PPUSH
9448: CALL_OW 12
9452: ARRAY
9453: PPUSH
9454: LD_INT 3
9456: PPUSH
9457: LD_INT 45
9459: PUSH
9460: LD_INT 47
9462: PUSH
9463: LD_INT 47
9465: PUSH
9466: LD_INT 45
9468: PUSH
9469: LD_INT 46
9471: PUSH
9472: LD_INT 46
9474: PUSH
9475: LD_INT 49
9477: PUSH
9478: LD_INT 49
9480: PUSH
9481: LD_INT 49
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: LIST
9488: LIST
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: LIST
9494: PUSH
9495: LD_VAR 0 3
9499: PUSH
9500: LD_INT 9
9502: MOD
9503: PUSH
9504: LD_INT 1
9506: PLUS
9507: ARRAY
9508: PPUSH
9509: LD_INT 80
9511: PPUSH
9512: CALL 74385 0 5
// result := result union CreateVehicle ;
9516: LD_ADDR_VAR 0 2
9520: PUSH
9521: LD_VAR 0 2
9525: PUSH
9526: CALL_OW 45
9530: UNION
9531: ST_TO_ADDR
// end ;
9532: GO 9401
9534: POP
9535: POP
// if not KappaStatus then
9536: LD_EXP 2
9540: NOT
9541: IFFALSE 9776
// begin uc_nation := 1 ;
9543: LD_ADDR_OWVAR 21
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// for i = 1 to 3 do
9551: LD_ADDR_VAR 0 3
9555: PUSH
9556: DOUBLE
9557: LD_INT 1
9559: DEC
9560: ST_TO_ADDR
9561: LD_INT 3
9563: PUSH
9564: FOR_TO
9565: IFFALSE 9701
// begin j := rand ( 0 , 1 ) ;
9567: LD_ADDR_VAR 0 4
9571: PUSH
9572: LD_INT 0
9574: PPUSH
9575: LD_INT 1
9577: PPUSH
9578: CALL_OW 12
9582: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9583: LD_INT 3
9585: PUSH
9586: LD_INT 5
9588: PUSH
9589: LD_INT 5
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: LIST
9599: LIST
9600: PUSH
9601: LD_VAR 0 4
9605: PUSH
9606: LD_INT 1
9608: PPUSH
9609: LD_INT 3
9611: PPUSH
9612: CALL_OW 12
9616: PLUS
9617: ARRAY
9618: PPUSH
9619: LD_INT 1
9621: PUSH
9622: LD_INT 3
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 1
9631: PPUSH
9632: LD_INT 2
9634: PPUSH
9635: CALL_OW 12
9639: ARRAY
9640: PPUSH
9641: LD_INT 3
9643: PPUSH
9644: LD_INT 9
9646: PUSH
9647: LD_INT 7
9649: PUSH
9650: LD_INT 6
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: LIST
9657: PUSH
9658: LD_VAR 0 4
9662: PUSH
9663: LD_INT 1
9665: PPUSH
9666: LD_INT 2
9668: PPUSH
9669: CALL_OW 12
9673: PLUS
9674: ARRAY
9675: PPUSH
9676: LD_INT 85
9678: PPUSH
9679: CALL 74385 0 5
// result := result union CreateVehicle ;
9683: LD_ADDR_VAR 0 2
9687: PUSH
9688: LD_VAR 0 2
9692: PUSH
9693: CALL_OW 45
9697: UNION
9698: ST_TO_ADDR
// end ;
9699: GO 9564
9701: POP
9702: POP
// if vsevolodFirstAttack then
9703: LD_EXP 24
9707: IFFALSE 9774
// begin vsevolodFirstAttack := false ;
9709: LD_ADDR_EXP 24
9713: PUSH
9714: LD_INT 0
9716: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9717: LD_INT 5
9719: PPUSH
9720: LD_INT 3
9722: PPUSH
9723: LD_INT 1
9725: PPUSH
9726: LD_INT 6
9728: PPUSH
9729: LD_INT 100
9731: PPUSH
9732: CALL 74385 0 5
// sewiVeh := CreateVehicle ;
9736: LD_ADDR_EXP 75
9740: PUSH
9741: CALL_OW 45
9745: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9746: LD_EXP 75
9750: PPUSH
9751: LD_INT 1
9753: PPUSH
9754: CALL_OW 242
// result := result union sewiVeh ;
9758: LD_ADDR_VAR 0 2
9762: PUSH
9763: LD_VAR 0 2
9767: PUSH
9768: LD_EXP 75
9772: UNION
9773: ST_TO_ADDR
// end ; end else
9774: GO 9986
// if vsevolodFirstAttack then
9776: LD_EXP 24
9780: IFFALSE 9986
// begin vsevolodFirstAttack := false ;
9782: LD_ADDR_EXP 24
9786: PUSH
9787: LD_INT 0
9789: ST_TO_ADDR
// uc_nation := 3 ;
9790: LD_ADDR_OWVAR 21
9794: PUSH
9795: LD_INT 3
9797: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9798: LD_ADDR_VAR 0 3
9802: PUSH
9803: DOUBLE
9804: LD_INT 1
9806: DEC
9807: ST_TO_ADDR
9808: LD_INT 2
9810: PUSH
9811: LD_OWVAR 67
9815: PLUS
9816: PUSH
9817: FOR_TO
9818: IFFALSE 9926
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9820: LD_INT 22
9822: PUSH
9823: LD_INT 24
9825: PUSH
9826: LD_INT 24
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: LIST
9833: PUSH
9834: LD_VAR 0 3
9838: PUSH
9839: LD_INT 3
9841: MOD
9842: PUSH
9843: LD_INT 1
9845: PLUS
9846: ARRAY
9847: PPUSH
9848: LD_INT 1
9850: PUSH
9851: LD_INT 3
9853: PUSH
9854: EMPTY
9855: LIST
9856: LIST
9857: PUSH
9858: LD_INT 1
9860: PPUSH
9861: LD_INT 2
9863: PPUSH
9864: CALL_OW 12
9868: ARRAY
9869: PPUSH
9870: LD_INT 1
9872: PPUSH
9873: LD_INT 45
9875: PUSH
9876: LD_INT 47
9878: PUSH
9879: LD_INT 47
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: LIST
9886: PUSH
9887: LD_VAR 0 3
9891: PUSH
9892: LD_INT 3
9894: MOD
9895: PUSH
9896: LD_INT 1
9898: PLUS
9899: ARRAY
9900: PPUSH
9901: LD_INT 80
9903: PPUSH
9904: CALL 74385 0 5
// result := result union CreateVehicle ;
9908: LD_ADDR_VAR 0 2
9912: PUSH
9913: LD_VAR 0 2
9917: PUSH
9918: CALL_OW 45
9922: UNION
9923: ST_TO_ADDR
// end ;
9924: GO 9817
9926: POP
9927: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9928: LD_INT 24
9930: PPUSH
9931: LD_INT 3
9933: PPUSH
9934: LD_INT 1
9936: PPUSH
9937: LD_INT 47
9939: PPUSH
9940: LD_INT 100
9942: PPUSH
9943: CALL 74385 0 5
// sewiVeh := CreateVehicle ;
9947: LD_ADDR_EXP 75
9951: PUSH
9952: CALL_OW 45
9956: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9957: LD_EXP 75
9961: PPUSH
9962: LD_INT 6
9964: NEG
9965: PPUSH
9966: CALL_OW 242
// result := result union sewiVeh ;
9970: LD_ADDR_VAR 0 2
9974: PUSH
9975: LD_VAR 0 2
9979: PUSH
9980: LD_EXP 75
9984: UNION
9985: ST_TO_ADDR
// end ; end ; end ;
9986: GO 9989
9988: POP
// end ;
9989: LD_VAR 0 2
9993: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9994: LD_EXP 16
9998: IFFALSE 10739
10000: GO 10002
10002: DISABLE
10003: LD_INT 0
10005: PPUSH
10006: PPUSH
10007: PPUSH
10008: PPUSH
10009: PPUSH
10010: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10011: LD_ADDR_VAR 0 4
10015: PUSH
10016: LD_INT 11
10018: PUSH
10019: LD_INT 12
10021: PUSH
10022: EMPTY
10023: LIST
10024: LIST
10025: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10026: LD_ADDR_VAR 0 3
10030: PUSH
10031: LD_INT 11550
10033: PUSH
10034: LD_INT 10150
10036: PUSH
10037: LD_INT 9800
10039: PUSH
10040: LD_INT 9450
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_OWVAR 67
10053: ARRAY
10054: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10055: LD_ADDR_VAR 0 6
10059: PUSH
10060: LD_INT 70
10062: PUSH
10063: LD_INT 118
10065: PUSH
10066: EMPTY
10067: LIST
10068: LIST
10069: PUSH
10070: LD_INT 78
10072: PUSH
10073: LD_INT 31
10075: PUSH
10076: EMPTY
10077: LIST
10078: LIST
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: ST_TO_ADDR
// repeat if missionStage = 2 then
10084: LD_EXP 15
10088: PUSH
10089: LD_INT 2
10091: EQUAL
10092: IFFALSE 10103
// wait ( 1 1$30 ) else
10094: LD_INT 3150
10096: PPUSH
10097: CALL_OW 67
10101: GO 10112
// wait ( time ) ;
10103: LD_VAR 0 3
10107: PPUSH
10108: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10112: LD_EXP 15
10116: PUSH
10117: LD_INT 6
10119: EQUAL
10120: PUSH
10121: LD_OWVAR 67
10125: PUSH
10126: LD_INT 2
10128: GREATER
10129: OR
10130: IFFALSE 10158
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10132: LD_INT 51
10134: PPUSH
10135: LD_INT 6
10137: PPUSH
10138: LD_INT 2
10140: PPUSH
10141: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10145: LD_INT 57
10147: PPUSH
10148: LD_INT 6
10150: PPUSH
10151: LD_INT 2
10153: PPUSH
10154: CALL_OW 322
// end ; if missionStage = 8 then
10158: LD_EXP 15
10162: PUSH
10163: LD_INT 8
10165: EQUAL
10166: IFFALSE 10194
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10168: LD_INT 52
10170: PPUSH
10171: LD_INT 6
10173: PPUSH
10174: LD_INT 2
10176: PPUSH
10177: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10181: LD_INT 58
10183: PPUSH
10184: LD_INT 6
10186: PPUSH
10187: LD_INT 2
10189: PPUSH
10190: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10194: LD_OWVAR 67
10198: PUSH
10199: LD_INT 4
10201: EQUAL
10202: PUSH
10203: LD_EXP 15
10207: PUSH
10208: LD_INT 10
10210: EQUAL
10211: OR
10212: IFFALSE 10240
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10214: LD_INT 53
10216: PPUSH
10217: LD_INT 6
10219: PPUSH
10220: LD_INT 2
10222: PPUSH
10223: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10227: LD_INT 59
10229: PPUSH
10230: LD_INT 6
10232: PPUSH
10233: LD_INT 2
10235: PPUSH
10236: CALL_OW 322
// end ; if activeAttacks then
10240: LD_EXP 16
10244: IFFALSE 10733
// begin if missionStage = 2 then
10246: LD_EXP 15
10250: PUSH
10251: LD_INT 2
10253: EQUAL
10254: IFFALSE 10264
// strength := 1 ;
10256: LD_ADDR_VAR 0 5
10260: PUSH
10261: LD_INT 1
10263: ST_TO_ADDR
// if missionStage > 2 then
10264: LD_EXP 15
10268: PUSH
10269: LD_INT 2
10271: GREATER
10272: IFFALSE 10282
// strength := 2 ;
10274: LD_ADDR_VAR 0 5
10278: PUSH
10279: LD_INT 2
10281: ST_TO_ADDR
// if missionStage > 6 then
10282: LD_EXP 15
10286: PUSH
10287: LD_INT 6
10289: GREATER
10290: IFFALSE 10300
// strength := 3 ;
10292: LD_ADDR_VAR 0 5
10296: PUSH
10297: LD_INT 3
10299: ST_TO_ADDR
// if missionStage > 10 then
10300: LD_EXP 15
10304: PUSH
10305: LD_INT 10
10307: GREATER
10308: IFFALSE 10318
// strength := 4 ;
10310: LD_ADDR_VAR 0 5
10314: PUSH
10315: LD_INT 4
10317: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10318: LD_ADDR_VAR 0 2
10322: PUSH
10323: LD_VAR 0 5
10327: PPUSH
10328: CALL 8811 0 1
10332: ST_TO_ADDR
// for i in tmp do
10333: LD_ADDR_VAR 0 1
10337: PUSH
10338: LD_VAR 0 2
10342: PUSH
10343: FOR_IN
10344: IFFALSE 10602
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10346: LD_VAR 0 1
10350: PPUSH
10351: LD_VAR 0 4
10355: PUSH
10356: LD_INT 1
10358: PPUSH
10359: LD_INT 2
10361: PPUSH
10362: CALL_OW 12
10366: ARRAY
10367: PPUSH
10368: LD_INT 0
10370: PPUSH
10371: CALL_OW 49
// if i = sewiVeh then
10375: LD_VAR 0 1
10379: PUSH
10380: LD_EXP 75
10384: EQUAL
10385: IFFALSE 10422
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10387: LD_ADDR_EXP 74
10391: PUSH
10392: LD_STRING Vsevolod
10394: PPUSH
10395: LD_INT 0
10397: PPUSH
10398: LD_STRING 
10400: PPUSH
10401: CALL 69545 0 3
10405: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10406: LD_EXP 74
10410: PPUSH
10411: LD_VAR 0 1
10415: PPUSH
10416: CALL_OW 52
// end else
10420: GO 10503
// if GetControl ( i ) = control_manual then
10422: LD_VAR 0 1
10426: PPUSH
10427: CALL_OW 263
10431: PUSH
10432: LD_INT 1
10434: EQUAL
10435: IFFALSE 10503
// begin uc_side := 6 ;
10437: LD_ADDR_OWVAR 20
10441: PUSH
10442: LD_INT 6
10444: ST_TO_ADDR
// uc_nation := 3 ;
10445: LD_ADDR_OWVAR 21
10449: PUSH
10450: LD_INT 3
10452: ST_TO_ADDR
// hc_gallery :=  ;
10453: LD_ADDR_OWVAR 33
10457: PUSH
10458: LD_STRING 
10460: ST_TO_ADDR
// hc_name :=  ;
10461: LD_ADDR_OWVAR 26
10465: PUSH
10466: LD_STRING 
10468: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10469: LD_INT 0
10471: PPUSH
10472: LD_INT 3
10474: PPUSH
10475: LD_INT 10
10477: PPUSH
10478: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10482: CALL_OW 44
10486: PPUSH
10487: LD_VAR 0 1
10491: PPUSH
10492: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10496: LD_INT 10
10498: PPUSH
10499: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10503: LD_INT 1
10505: PPUSH
10506: LD_INT 3
10508: PPUSH
10509: CALL_OW 12
10513: PUSH
10514: LD_INT 1
10516: DOUBLE
10517: EQUAL
10518: IFTRUE 10522
10520: GO 10540
10522: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10523: LD_VAR 0 1
10527: PPUSH
10528: LD_INT 111
10530: PPUSH
10531: LD_INT 197
10533: PPUSH
10534: CALL_OW 111
10538: GO 10593
10540: LD_INT 2
10542: DOUBLE
10543: EQUAL
10544: IFTRUE 10548
10546: GO 10566
10548: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10549: LD_VAR 0 1
10553: PPUSH
10554: LD_INT 91
10556: PPUSH
10557: LD_INT 165
10559: PPUSH
10560: CALL_OW 111
10564: GO 10593
10566: LD_INT 3
10568: DOUBLE
10569: EQUAL
10570: IFTRUE 10574
10572: GO 10592
10574: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 137
10582: PPUSH
10583: LD_INT 157
10585: PPUSH
10586: CALL_OW 111
10590: GO 10593
10592: POP
// wait ( 0 0$2 ) ;
10593: LD_INT 70
10595: PPUSH
10596: CALL_OW 67
// end ;
10600: GO 10343
10602: POP
10603: POP
// repeat wait ( 0 0$1 ) ;
10604: LD_INT 35
10606: PPUSH
10607: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10611: LD_ADDR_VAR 0 1
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 50
10623: PUSH
10624: EMPTY
10625: LIST
10626: PPUSH
10627: CALL_OW 72
10631: PUSH
10632: FOR_IN
10633: IFFALSE 10692
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10635: LD_VAR 0 1
10639: PPUSH
10640: LD_INT 108
10642: PUSH
10643: LD_INT 153
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PUSH
10650: LD_INT 105
10652: PUSH
10653: LD_INT 149
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PUSH
10660: LD_INT 85
10662: PUSH
10663: LD_INT 131
10665: PUSH
10666: EMPTY
10667: LIST
10668: LIST
10669: PUSH
10670: LD_INT 64
10672: PUSH
10673: LD_INT 105
10675: PUSH
10676: EMPTY
10677: LIST
10678: LIST
10679: PUSH
10680: EMPTY
10681: LIST
10682: LIST
10683: LIST
10684: LIST
10685: PPUSH
10686: CALL 109840 0 2
10690: GO 10632
10692: POP
10693: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10694: LD_VAR 0 2
10698: PPUSH
10699: LD_INT 3
10701: PUSH
10702: LD_INT 34
10704: PUSH
10705: LD_INT 49
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: EMPTY
10713: LIST
10714: LIST
10715: PUSH
10716: LD_INT 50
10718: PUSH
10719: EMPTY
10720: LIST
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 72
10730: NOT
10731: IFFALSE 10604
// end ; until russianDestroyed ;
10733: LD_EXP 21
10737: IFFALSE 10084
// end ;
10739: PPOPN 6
10741: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10742: LD_EXP 21
10746: NOT
10747: PUSH
10748: LD_EXP 15
10752: PUSH
10753: LD_INT 6
10755: GREATEREQUAL
10756: AND
10757: IFFALSE 11777
10759: GO 10761
10761: DISABLE
10762: LD_INT 0
10764: PPUSH
10765: PPUSH
10766: PPUSH
10767: PPUSH
10768: PPUSH
// begin enable ;
10769: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10770: LD_INT 22
10772: PUSH
10773: LD_INT 3
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: PUSH
10780: LD_INT 30
10782: PUSH
10783: LD_INT 3
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PPUSH
10794: CALL_OW 69
10798: NOT
10799: IFFALSE 10803
// exit ;
10801: GO 11777
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10803: LD_ADDR_VAR 0 4
10807: PUSH
10808: LD_INT 22
10810: PUSH
10811: LD_INT 3
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 30
10820: PUSH
10821: LD_INT 34
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: PPUSH
10832: CALL_OW 69
10836: ST_TO_ADDR
// if Prob ( 40 ) then
10837: LD_INT 40
10839: PPUSH
10840: CALL_OW 13
10844: IFFALSE 10990
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10846: LD_INT 2
10848: PPUSH
10849: LD_INT 22
10851: PUSH
10852: LD_INT 3
10854: PUSH
10855: LD_INT 3
10857: PUSH
10858: LD_INT 49
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: LIST
10865: LIST
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 3
10872: PUSH
10873: LD_INT 3
10875: PUSH
10876: LD_INT 49
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: LIST
10884: PUSH
10885: LD_INT 22
10887: PUSH
10888: LD_INT 3
10890: PUSH
10891: LD_INT 3
10893: PUSH
10894: LD_INT 49
10896: PUSH
10897: EMPTY
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: PUSH
10903: LD_INT 24
10905: PUSH
10906: LD_INT 3
10908: PUSH
10909: LD_INT 3
10911: PUSH
10912: LD_INT 46
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: LIST
10919: LIST
10920: PUSH
10921: LD_INT 24
10923: PUSH
10924: LD_INT 3
10926: PUSH
10927: LD_INT 3
10929: PUSH
10930: LD_INT 46
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: PUSH
10939: LD_INT 24
10941: PUSH
10942: LD_INT 3
10944: PUSH
10945: LD_INT 3
10947: PUSH
10948: LD_INT 46
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: PUSH
10957: LD_INT 24
10959: PUSH
10960: LD_INT 3
10962: PUSH
10963: LD_INT 3
10965: PUSH
10966: LD_INT 46
10968: PUSH
10969: EMPTY
10970: LIST
10971: LIST
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: LIST
10981: LIST
10982: LIST
10983: PPUSH
10984: CALL 63119 0 2
// end else
10988: GO 11132
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10990: LD_INT 2
10992: PPUSH
10993: LD_INT 24
10995: PUSH
10996: LD_INT 3
10998: PUSH
10999: LD_INT 3
11001: PUSH
11002: LD_INT 47
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: PUSH
11011: LD_INT 24
11013: PUSH
11014: LD_INT 3
11016: PUSH
11017: LD_INT 3
11019: PUSH
11020: LD_INT 47
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PUSH
11029: LD_INT 24
11031: PUSH
11032: LD_INT 3
11034: PUSH
11035: LD_INT 3
11037: PUSH
11038: LD_INT 47
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: PUSH
11047: LD_INT 24
11049: PUSH
11050: LD_INT 3
11052: PUSH
11053: LD_INT 3
11055: PUSH
11056: LD_INT 46
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 24
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: LD_INT 3
11073: PUSH
11074: LD_INT 46
11076: PUSH
11077: EMPTY
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: PUSH
11083: LD_INT 24
11085: PUSH
11086: LD_INT 3
11088: PUSH
11089: LD_INT 3
11091: PUSH
11092: LD_INT 46
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: LIST
11099: LIST
11100: PUSH
11101: LD_INT 24
11103: PUSH
11104: LD_INT 3
11106: PUSH
11107: LD_INT 3
11109: PUSH
11110: LD_INT 46
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: LIST
11123: LIST
11124: LIST
11125: LIST
11126: LIST
11127: PPUSH
11128: CALL 63119 0 2
// end ; wait ( 2 2$00 ) ;
11132: LD_INT 4200
11134: PPUSH
11135: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_INT 22
11146: PUSH
11147: LD_INT 3
11149: PUSH
11150: EMPTY
11151: LIST
11152: LIST
11153: PUSH
11154: LD_INT 21
11156: PUSH
11157: LD_INT 2
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: PUSH
11164: LD_INT 3
11166: PUSH
11167: LD_INT 34
11169: PUSH
11170: LD_INT 48
11172: PUSH
11173: EMPTY
11174: LIST
11175: LIST
11176: PUSH
11177: LD_INT 34
11179: PUSH
11180: LD_INT 51
11182: PUSH
11183: EMPTY
11184: LIST
11185: LIST
11186: PUSH
11187: LD_INT 34
11189: PUSH
11190: LD_INT 52
11192: PUSH
11193: EMPTY
11194: LIST
11195: LIST
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: LIST
11201: LIST
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: LIST
11207: PPUSH
11208: CALL_OW 69
11212: PUSH
11213: LD_EXP 124
11217: PUSH
11218: LD_INT 2
11220: ARRAY
11221: DIFF
11222: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11223: LD_ADDR_EXP 121
11227: PUSH
11228: LD_EXP 121
11232: PPUSH
11233: LD_INT 2
11235: PPUSH
11236: LD_EXP 121
11240: PUSH
11241: LD_INT 2
11243: ARRAY
11244: PUSH
11245: LD_VAR 0 2
11249: DIFF
11250: PPUSH
11251: CALL_OW 1
11255: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11256: LD_ADDR_VAR 0 3
11260: PUSH
11261: LD_INT 0
11263: PPUSH
11264: LD_INT 1
11266: PPUSH
11267: CALL_OW 12
11271: ST_TO_ADDR
// p := 0 ;
11272: LD_ADDR_VAR 0 5
11276: PUSH
11277: LD_INT 0
11279: ST_TO_ADDR
// if target then
11280: LD_VAR 0 3
11284: IFFALSE 11437
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11286: LD_ADDR_VAR 0 2
11290: PUSH
11291: LD_VAR 0 2
11295: PPUSH
11296: LD_INT 24
11298: PUSH
11299: LD_INT 250
11301: PUSH
11302: EMPTY
11303: LIST
11304: LIST
11305: PPUSH
11306: CALL_OW 72
11310: ST_TO_ADDR
// for i in tmp do
11311: LD_ADDR_VAR 0 1
11315: PUSH
11316: LD_VAR 0 2
11320: PUSH
11321: FOR_IN
11322: IFFALSE 11362
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11324: LD_VAR 0 1
11328: PPUSH
11329: LD_INT 139
11331: PPUSH
11332: LD_INT 89
11334: PPUSH
11335: CALL_OW 297
11339: PUSH
11340: LD_INT 9
11342: GREATER
11343: IFFALSE 11360
// ComMoveXY ( i , 139 , 89 ) ;
11345: LD_VAR 0 1
11349: PPUSH
11350: LD_INT 139
11352: PPUSH
11353: LD_INT 89
11355: PPUSH
11356: CALL_OW 111
11360: GO 11321
11362: POP
11363: POP
// wait ( 0 0$1 ) ;
11364: LD_INT 35
11366: PPUSH
11367: CALL_OW 67
// p := Inc ( p ) ;
11371: LD_ADDR_VAR 0 5
11375: PUSH
11376: LD_VAR 0 5
11380: PPUSH
11381: CALL 108597 0 1
11385: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11386: LD_VAR 0 2
11390: PPUSH
11391: LD_INT 92
11393: PUSH
11394: LD_INT 139
11396: PUSH
11397: LD_INT 89
11399: PUSH
11400: LD_INT 9
11402: PUSH
11403: EMPTY
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: PPUSH
11409: CALL_OW 72
11413: PUSH
11414: LD_VAR 0 2
11418: PUSH
11419: LD_INT 1
11421: MINUS
11422: GREATEREQUAL
11423: PUSH
11424: LD_VAR 0 5
11428: PUSH
11429: LD_INT 60
11431: GREATER
11432: OR
11433: IFFALSE 11286
// end else
11435: GO 11604
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11437: LD_VAR 0 2
11441: PPUSH
11442: LD_VAR 0 4
11446: PUSH
11447: LD_INT 1
11449: ARRAY
11450: PPUSH
11451: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11455: LD_ADDR_VAR 0 2
11459: PUSH
11460: LD_VAR 0 2
11464: PPUSH
11465: LD_INT 24
11467: PUSH
11468: LD_INT 250
11470: PUSH
11471: EMPTY
11472: LIST
11473: LIST
11474: PPUSH
11475: CALL_OW 72
11479: ST_TO_ADDR
// for i in tmp do
11480: LD_ADDR_VAR 0 1
11484: PUSH
11485: LD_VAR 0 2
11489: PUSH
11490: FOR_IN
11491: IFFALSE 11531
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11493: LD_VAR 0 1
11497: PPUSH
11498: LD_INT 124
11500: PPUSH
11501: LD_INT 139
11503: PPUSH
11504: CALL_OW 297
11508: PUSH
11509: LD_INT 9
11511: GREATER
11512: IFFALSE 11529
// ComMoveXY ( i , 124 , 139 ) ;
11514: LD_VAR 0 1
11518: PPUSH
11519: LD_INT 124
11521: PPUSH
11522: LD_INT 139
11524: PPUSH
11525: CALL_OW 111
11529: GO 11490
11531: POP
11532: POP
// wait ( 0 0$1 ) ;
11533: LD_INT 35
11535: PPUSH
11536: CALL_OW 67
// p := Inc ( p ) ;
11540: LD_ADDR_VAR 0 5
11544: PUSH
11545: LD_VAR 0 5
11549: PPUSH
11550: CALL 108597 0 1
11554: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11555: LD_VAR 0 2
11559: PPUSH
11560: LD_INT 92
11562: PUSH
11563: LD_INT 124
11565: PUSH
11566: LD_INT 139
11568: PUSH
11569: LD_INT 9
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: LIST
11576: LIST
11577: PPUSH
11578: CALL_OW 72
11582: PUSH
11583: LD_VAR 0 2
11587: PUSH
11588: LD_INT 1
11590: MINUS
11591: GREATEREQUAL
11592: PUSH
11593: LD_VAR 0 5
11597: PUSH
11598: LD_INT 60
11600: GREATER
11601: OR
11602: IFFALSE 11455
// end ; repeat wait ( 0 0$1 ) ;
11604: LD_INT 35
11606: PPUSH
11607: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11611: LD_ADDR_VAR 0 2
11615: PUSH
11616: LD_VAR 0 2
11620: PPUSH
11621: LD_INT 50
11623: PUSH
11624: EMPTY
11625: LIST
11626: PPUSH
11627: CALL_OW 72
11631: ST_TO_ADDR
// for i in tmp do
11632: LD_ADDR_VAR 0 1
11636: PUSH
11637: LD_VAR 0 2
11641: PUSH
11642: FOR_IN
11643: IFFALSE 11768
// begin if GetWeapon ( i ) = ru_time_lapser then
11645: LD_VAR 0 1
11649: PPUSH
11650: CALL_OW 264
11654: PUSH
11655: LD_INT 49
11657: EQUAL
11658: IFFALSE 11714
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11660: LD_VAR 0 1
11664: PPUSH
11665: LD_INT 2
11667: PUSH
11668: LD_INT 22
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_INT 8
11683: PUSH
11684: EMPTY
11685: LIST
11686: LIST
11687: PUSH
11688: EMPTY
11689: LIST
11690: LIST
11691: LIST
11692: PPUSH
11693: CALL_OW 69
11697: PPUSH
11698: LD_VAR 0 1
11702: PPUSH
11703: CALL_OW 74
11707: PPUSH
11708: CALL_OW 112
11712: GO 11766
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11714: LD_VAR 0 1
11718: PPUSH
11719: LD_INT 2
11721: PUSH
11722: LD_INT 22
11724: PUSH
11725: LD_INT 1
11727: PUSH
11728: EMPTY
11729: LIST
11730: LIST
11731: PUSH
11732: LD_INT 22
11734: PUSH
11735: LD_INT 8
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: LIST
11746: PPUSH
11747: CALL_OW 69
11751: PPUSH
11752: LD_VAR 0 1
11756: PPUSH
11757: CALL_OW 74
11761: PPUSH
11762: CALL_OW 115
// end ;
11766: GO 11642
11768: POP
11769: POP
// until not tmp ;
11770: LD_VAR 0 2
11774: NOT
11775: IFFALSE 11604
// end ;
11777: PPOPN 5
11779: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11780: LD_EXP 15
11784: PUSH
11785: LD_INT 7
11787: GREATEREQUAL
11788: PUSH
11789: LD_OWVAR 67
11793: PUSH
11794: LD_INT 1
11796: GREATER
11797: AND
11798: IFFALSE 12090
11800: GO 11802
11802: DISABLE
11803: LD_INT 0
11805: PPUSH
11806: PPUSH
11807: PPUSH
// begin ruMobile := [ ] ;
11808: LD_ADDR_EXP 78
11812: PUSH
11813: EMPTY
11814: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: DOUBLE
11821: LD_INT 1
11823: DEC
11824: ST_TO_ADDR
11825: LD_INT 4
11827: PUSH
11828: LD_INT 5
11830: PUSH
11831: LD_INT 6
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: LIST
11838: PUSH
11839: LD_OWVAR 67
11843: PUSH
11844: LD_INT 1
11846: MINUS
11847: ARRAY
11848: PUSH
11849: FOR_TO
11850: IFFALSE 12088
// begin uc_side := 3 ;
11852: LD_ADDR_OWVAR 20
11856: PUSH
11857: LD_INT 3
11859: ST_TO_ADDR
// uc_nation := 1 ;
11860: LD_ADDR_OWVAR 21
11864: PUSH
11865: LD_INT 1
11867: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11868: LD_INT 5
11870: PPUSH
11871: LD_INT 3
11873: PPUSH
11874: LD_INT 1
11876: PPUSH
11877: LD_INT 9
11879: PUSH
11880: LD_INT 7
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: LD_INT 2
11894: MOD
11895: PUSH
11896: LD_INT 1
11898: PLUS
11899: ARRAY
11900: PPUSH
11901: LD_INT 100
11903: PPUSH
11904: CALL 74385 0 5
// veh := CreateVehicle ;
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: CALL_OW 45
11917: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11918: LD_VAR 0 2
11922: PPUSH
11923: LD_INT 3
11925: PPUSH
11926: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11930: LD_VAR 0 2
11934: PPUSH
11935: LD_INT 29
11937: PPUSH
11938: LD_INT 0
11940: PPUSH
11941: CALL_OW 49
// uc_nation := 3 ;
11945: LD_ADDR_OWVAR 21
11949: PUSH
11950: LD_INT 3
11952: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11953: LD_INT 0
11955: PPUSH
11956: LD_INT 10
11958: PPUSH
11959: CALL_OW 383
// un := CreateHuman ;
11963: LD_ADDR_VAR 0 3
11967: PUSH
11968: CALL_OW 44
11972: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11973: LD_VAR 0 3
11977: PPUSH
11978: LD_INT 105
11980: PPUSH
11981: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11985: LD_VAR 0 3
11989: PPUSH
11990: LD_INT 3
11992: PPUSH
11993: CALL_OW 259
11997: PUSH
11998: LD_INT 8
12000: PUSH
12001: LD_INT 9
12003: PUSH
12004: LD_INT 10
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: LIST
12011: PUSH
12012: LD_OWVAR 67
12016: ARRAY
12017: LESS
12018: IFFALSE 12052
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12020: LD_VAR 0 3
12024: PPUSH
12025: LD_INT 3
12027: PPUSH
12028: LD_INT 8
12030: PUSH
12031: LD_INT 9
12033: PUSH
12034: LD_INT 10
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: LIST
12041: PUSH
12042: LD_OWVAR 67
12046: ARRAY
12047: PPUSH
12048: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12052: LD_VAR 0 3
12056: PPUSH
12057: LD_VAR 0 2
12061: PPUSH
12062: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12066: LD_ADDR_EXP 78
12070: PUSH
12071: LD_EXP 78
12075: PPUSH
12076: LD_VAR 0 2
12080: PPUSH
12081: CALL 107236 0 2
12085: ST_TO_ADDR
// end ;
12086: GO 11849
12088: POP
12089: POP
// end ;
12090: PPOPN 3
12092: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12093: LD_EXP 78
12097: IFFALSE 12606
12099: GO 12101
12101: DISABLE
12102: LD_INT 0
12104: PPUSH
12105: PPUSH
12106: PPUSH
// begin enable ;
12107: ENABLE
// if not ruMobile then
12108: LD_EXP 78
12112: NOT
12113: IFFALSE 12118
// begin disable ;
12115: DISABLE
// exit ;
12116: GO 12606
// end ; for i in ruMobile do
12118: LD_ADDR_VAR 0 1
12122: PUSH
12123: LD_EXP 78
12127: PUSH
12128: FOR_IN
12129: IFFALSE 12604
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12131: LD_VAR 0 1
12135: PPUSH
12136: CALL_OW 302
12140: NOT
12141: PUSH
12142: LD_VAR 0 1
12146: PPUSH
12147: CALL_OW 255
12151: PUSH
12152: LD_INT 3
12154: NONEQUAL
12155: OR
12156: IFFALSE 12176
// begin ruMobile := ruMobile diff i ;
12158: LD_ADDR_EXP 78
12162: PUSH
12163: LD_EXP 78
12167: PUSH
12168: LD_VAR 0 1
12172: DIFF
12173: ST_TO_ADDR
// continue ;
12174: GO 12128
// end ; if GetTag ( i ) = 300 then
12176: LD_VAR 0 1
12180: PPUSH
12181: CALL_OW 110
12185: PUSH
12186: LD_INT 300
12188: EQUAL
12189: IFFALSE 12239
// begin ComMoveXY ( i , 160 , 81 ) ;
12191: LD_VAR 0 1
12195: PPUSH
12196: LD_INT 160
12198: PPUSH
12199: LD_INT 81
12201: PPUSH
12202: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12206: LD_VAR 0 1
12210: PPUSH
12211: LD_INT 160
12213: PPUSH
12214: LD_INT 81
12216: PPUSH
12217: CALL_OW 297
12221: PUSH
12222: LD_INT 8
12224: LESS
12225: IFFALSE 12239
// SetTag ( i , 301 ) ;
12227: LD_VAR 0 1
12231: PPUSH
12232: LD_INT 301
12234: PPUSH
12235: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12239: LD_VAR 0 1
12243: PPUSH
12244: CALL_OW 110
12248: PUSH
12249: LD_INT 301
12251: EQUAL
12252: IFFALSE 12295
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12254: LD_VAR 0 1
12258: PPUSH
12259: LD_INT 33
12261: PPUSH
12262: CALL_OW 308
12266: NOT
12267: IFFALSE 12283
// ComMoveToArea ( i , ruMobileParkingArea ) else
12269: LD_VAR 0 1
12273: PPUSH
12274: LD_INT 33
12276: PPUSH
12277: CALL_OW 113
12281: GO 12295
// SetTag ( i , 302 ) ;
12283: LD_VAR 0 1
12287: PPUSH
12288: LD_INT 302
12290: PPUSH
12291: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12295: LD_VAR 0 1
12299: PPUSH
12300: CALL_OW 110
12304: PUSH
12305: LD_INT 302
12307: EQUAL
12308: IFFALSE 12438
// begin if GetLives ( i ) < 1000 then
12310: LD_VAR 0 1
12314: PPUSH
12315: CALL_OW 256
12319: PUSH
12320: LD_INT 1000
12322: LESS
12323: IFFALSE 12415
// begin if not IsDrivenBy ( i ) then
12325: LD_VAR 0 1
12329: PPUSH
12330: CALL_OW 311
12334: NOT
12335: IFFALSE 12339
// continue ;
12337: GO 12128
// mech := IsDrivenBy ( i ) ;
12339: LD_ADDR_VAR 0 2
12343: PUSH
12344: LD_VAR 0 1
12348: PPUSH
12349: CALL_OW 311
12353: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12363: LD_VAR 0 2
12367: PPUSH
12368: LD_VAR 0 1
12372: PPUSH
12373: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12377: LD_INT 35
12379: PPUSH
12380: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12384: LD_VAR 0 1
12388: PPUSH
12389: CALL_OW 256
12393: PUSH
12394: LD_INT 1000
12396: EQUAL
12397: IFFALSE 12377
// ComEnterUnit ( mech , i ) ;
12399: LD_VAR 0 2
12403: PPUSH
12404: LD_VAR 0 1
12408: PPUSH
12409: CALL_OW 120
// end else
12413: GO 12438
// if IsDrivenBy ( i ) then
12415: LD_VAR 0 1
12419: PPUSH
12420: CALL_OW 311
12424: IFFALSE 12438
// SetTag ( i , 0 ) ;
12426: LD_VAR 0 1
12430: PPUSH
12431: LD_INT 0
12433: PPUSH
12434: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12438: LD_VAR 0 1
12442: PPUSH
12443: CALL_OW 110
12447: PUSH
12448: LD_INT 300
12450: LESS
12451: IFFALSE 12602
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12453: LD_ADDR_VAR 0 3
12457: PUSH
12458: LD_INT 4
12460: PPUSH
12461: LD_INT 81
12463: PUSH
12464: LD_INT 3
12466: PUSH
12467: EMPTY
12468: LIST
12469: LIST
12470: PPUSH
12471: CALL_OW 70
12475: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12476: LD_VAR 0 1
12480: PPUSH
12481: CALL_OW 256
12485: PUSH
12486: LD_INT 650
12488: LESS
12489: IFFALSE 12514
// begin ComStop ( i ) ;
12491: LD_VAR 0 1
12495: PPUSH
12496: CALL_OW 141
// SetTag ( i , 300 ) ;
12500: LD_VAR 0 1
12504: PPUSH
12505: LD_INT 300
12507: PPUSH
12508: CALL_OW 109
// continue ;
12512: GO 12128
// end ; if enemy then
12514: LD_VAR 0 3
12518: IFFALSE 12558
// begin if not HasTask ( i ) then
12520: LD_VAR 0 1
12524: PPUSH
12525: CALL_OW 314
12529: NOT
12530: IFFALSE 12556
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12532: LD_VAR 0 1
12536: PPUSH
12537: LD_VAR 0 3
12541: PPUSH
12542: LD_VAR 0 1
12546: PPUSH
12547: CALL_OW 74
12551: PPUSH
12552: CALL_OW 115
// end else
12556: GO 12602
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12558: LD_VAR 0 1
12562: PPUSH
12563: LD_INT 158
12565: PUSH
12566: LD_INT 61
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PUSH
12573: LD_INT 98
12575: PUSH
12576: LD_INT 100
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PUSH
12583: LD_INT 78
12585: PUSH
12586: LD_INT 93
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: PUSH
12593: EMPTY
12594: LIST
12595: LIST
12596: LIST
12597: PPUSH
12598: CALL 109840 0 2
// end ; end ;
12602: GO 12128
12604: POP
12605: POP
// end ; end_of_file
12606: PPOPN 3
12608: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12609: LD_INT 0
12611: PPUSH
12612: PPUSH
12613: PPUSH
12614: PPUSH
12615: PPUSH
12616: PPUSH
12617: PPUSH
// SetInvulnrability ( alien , true ) ;
12618: LD_INT 1
12620: PPUSH
12621: LD_INT 1
12623: PPUSH
12624: CALL_OW 607
// side := 7 ;
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: LD_INT 7
12635: ST_TO_ADDR
// uc_side := side ;
12636: LD_ADDR_OWVAR 20
12640: PUSH
12641: LD_VAR 0 5
12645: ST_TO_ADDR
// uc_nation := 1 ;
12646: LD_ADDR_OWVAR 21
12650: PUSH
12651: LD_INT 1
12653: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12654: LD_ADDR_VAR 0 2
12658: PUSH
12659: LD_INT 22
12661: PUSH
12662: LD_VAR 0 5
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: LD_INT 21
12673: PUSH
12674: LD_INT 3
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PPUSH
12685: CALL_OW 69
12689: PUSH
12690: FOR_IN
12691: IFFALSE 12707
// SetBLevel ( i , 10 ) ;
12693: LD_VAR 0 2
12697: PPUSH
12698: LD_INT 10
12700: PPUSH
12701: CALL_OW 241
12705: GO 12690
12707: POP
12708: POP
// base := GetBase ( al_depot ) ;
12709: LD_ADDR_VAR 0 4
12713: PUSH
12714: LD_INT 2
12716: PPUSH
12717: CALL_OW 274
12721: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12722: LD_ADDR_VAR 0 6
12726: PUSH
12727: LD_INT 22
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: EMPTY
12736: LIST
12737: LIST
12738: PUSH
12739: LD_INT 30
12741: PUSH
12742: LD_INT 34
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PPUSH
12753: CALL_OW 69
12757: ST_TO_ADDR
// if teleport then
12758: LD_VAR 0 6
12762: IFFALSE 12783
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12764: LD_VAR 0 6
12768: PUSH
12769: LD_INT 1
12771: ARRAY
12772: PPUSH
12773: LD_INT 262
12775: PPUSH
12776: LD_INT 119
12778: PPUSH
12779: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12783: LD_VAR 0 4
12787: PPUSH
12788: LD_INT 1
12790: PPUSH
12791: LD_INT 19500
12793: PPUSH
12794: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12798: LD_VAR 0 4
12802: PPUSH
12803: LD_INT 2
12805: PPUSH
12806: LD_INT 200
12808: PPUSH
12809: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12813: LD_VAR 0 4
12817: PPUSH
12818: LD_INT 3
12820: PPUSH
12821: LD_INT 650
12823: PPUSH
12824: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12828: LD_ADDR_EXP 79
12832: PUSH
12833: LD_STRING Roth
12835: PPUSH
12836: CALL_OW 25
12840: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12841: LD_ADDR_EXP 80
12845: PUSH
12846: LD_STRING Simms
12848: PPUSH
12849: LD_EXP 1
12853: NOT
12854: PPUSH
12855: LD_STRING 10c_
12857: PPUSH
12858: CALL 69545 0 3
12862: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12863: LD_EXP 80
12867: PPUSH
12868: LD_INT 4
12870: PPUSH
12871: CALL_OW 336
// if not Simms then
12875: LD_EXP 80
12879: NOT
12880: IFFALSE 12910
// begin uc_nation := 1 ;
12882: LD_ADDR_OWVAR 21
12886: PUSH
12887: LD_INT 1
12889: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12890: LD_INT 2
12892: PPUSH
12893: LD_INT 10
12895: PPUSH
12896: CALL_OW 384
// Simms := CreateHuman ;
12900: LD_ADDR_EXP 80
12904: PUSH
12905: CALL_OW 44
12909: ST_TO_ADDR
// end ; uc_nation := 3 ;
12910: LD_ADDR_OWVAR 21
12914: PUSH
12915: LD_INT 3
12917: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12918: LD_ADDR_EXP 81
12922: PUSH
12923: LD_STRING Kirilenkova
12925: PPUSH
12926: CALL_OW 25
12930: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12931: LD_ADDR_EXP 95
12935: PUSH
12936: LD_STRING Oblukov
12938: PPUSH
12939: CALL_OW 25
12943: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12944: LD_ADDR_EXP 82
12948: PUSH
12949: LD_STRING Dolgov
12951: PPUSH
12952: CALL_OW 25
12956: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12957: LD_ADDR_EXP 83
12961: PUSH
12962: LD_STRING Petrosyan
12964: PPUSH
12965: CALL_OW 25
12969: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12970: LD_ADDR_EXP 94
12974: PUSH
12975: LD_STRING Scholtze
12977: PPUSH
12978: CALL_OW 25
12982: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12983: LD_ADDR_EXP 93
12987: PUSH
12988: LD_STRING Kapitsova
12990: PPUSH
12991: CALL_OW 25
12995: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12996: LD_ADDR_EXP 84
13000: PUSH
13001: LD_STRING Petrovova
13003: PPUSH
13004: CALL_OW 25
13008: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13009: LD_ADDR_EXP 85
13013: PUSH
13014: LD_STRING Kuzmov
13016: PPUSH
13017: CALL_OW 25
13021: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13022: LD_ADDR_EXP 92
13026: PUSH
13027: LD_STRING Karamazov
13029: PPUSH
13030: CALL_OW 25
13034: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13035: LD_STRING 13_Lipshchin_1
13037: PPUSH
13038: LD_INT 0
13040: PPUSH
13041: CALL_OW 30
13045: IFFALSE 13060
// Lipshchin := NewCharacter ( Lipshchin ) ;
13047: LD_ADDR_EXP 86
13051: PUSH
13052: LD_STRING Lipshchin
13054: PPUSH
13055: CALL_OW 25
13059: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13060: LD_STRING 13_Titov_1
13062: PPUSH
13063: LD_INT 0
13065: PPUSH
13066: CALL_OW 30
13070: IFFALSE 13085
// Titov := NewCharacter ( Titov ) ;
13072: LD_ADDR_EXP 88
13076: PUSH
13077: LD_STRING Titov
13079: PPUSH
13080: CALL_OW 25
13084: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13085: LD_STRING 13_Gnyevko_1
13087: PPUSH
13088: LD_INT 0
13090: PPUSH
13091: CALL_OW 30
13095: IFFALSE 13110
// Gnyevko := NewCharacter ( Gnyevko ) ;
13097: LD_ADDR_EXP 87
13101: PUSH
13102: LD_STRING Gnyevko
13104: PPUSH
13105: CALL_OW 25
13109: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13110: LD_STRING 13_Xavier_1
13112: PPUSH
13113: LD_INT 0
13115: PPUSH
13116: CALL_OW 30
13120: IFFALSE 13135
// Xavier := NewCharacter ( Xavier2 ) ;
13122: LD_ADDR_EXP 89
13126: PUSH
13127: LD_STRING Xavier2
13129: PPUSH
13130: CALL_OW 25
13134: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13135: LD_STRING 13_Belkov_1
13137: PPUSH
13138: LD_INT 0
13140: PPUSH
13141: CALL_OW 30
13145: IFFALSE 13160
// Belkov := NewCharacter ( Belkov ) ;
13147: LD_ADDR_EXP 90
13151: PUSH
13152: LD_STRING Belkov
13154: PPUSH
13155: CALL_OW 25
13159: ST_TO_ADDR
// if not BurlakStatus then
13160: LD_EXP 9
13164: NOT
13165: IFFALSE 13180
// Burlak = NewCharacter ( Burlak ) ;
13167: LD_ADDR_EXP 91
13171: PUSH
13172: LD_STRING Burlak
13174: PPUSH
13175: CALL_OW 25
13179: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13180: LD_ADDR_VAR 0 3
13184: PUSH
13185: LD_EXP 79
13189: PUSH
13190: LD_EXP 81
13194: PUSH
13195: LD_EXP 95
13199: PUSH
13200: LD_EXP 82
13204: PUSH
13205: LD_EXP 83
13209: PUSH
13210: LD_EXP 94
13214: PUSH
13215: LD_EXP 93
13219: PUSH
13220: LD_EXP 84
13224: PUSH
13225: LD_EXP 85
13229: PUSH
13230: LD_EXP 92
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: ST_TO_ADDR
// if Simms then
13247: LD_EXP 80
13251: IFFALSE 13269
// tmp := tmp ^ Simms ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_VAR 0 3
13262: PUSH
13263: LD_EXP 80
13267: ADD
13268: ST_TO_ADDR
// if Titov then
13269: LD_EXP 88
13273: IFFALSE 13291
// tmp := tmp ^ Titov ;
13275: LD_ADDR_VAR 0 3
13279: PUSH
13280: LD_VAR 0 3
13284: PUSH
13285: LD_EXP 88
13289: ADD
13290: ST_TO_ADDR
// if Lipshchin then
13291: LD_EXP 86
13295: IFFALSE 13313
// tmp := tmp ^ Lipshchin ;
13297: LD_ADDR_VAR 0 3
13301: PUSH
13302: LD_VAR 0 3
13306: PUSH
13307: LD_EXP 86
13311: ADD
13312: ST_TO_ADDR
// if Gnyevko then
13313: LD_EXP 87
13317: IFFALSE 13335
// tmp := tmp ^ Gnyevko ;
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_VAR 0 3
13328: PUSH
13329: LD_EXP 87
13333: ADD
13334: ST_TO_ADDR
// if Xavier then
13335: LD_EXP 89
13339: IFFALSE 13357
// tmp := tmp ^ Xavier ;
13341: LD_ADDR_VAR 0 3
13345: PUSH
13346: LD_VAR 0 3
13350: PUSH
13351: LD_EXP 89
13355: ADD
13356: ST_TO_ADDR
// if Belkov then
13357: LD_EXP 90
13361: IFFALSE 13379
// tmp := tmp ^ Belkov ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_VAR 0 3
13372: PUSH
13373: LD_EXP 90
13377: ADD
13378: ST_TO_ADDR
// if Burlak then
13379: LD_EXP 91
13383: IFFALSE 13401
// tmp := tmp ^ Burlak ;
13385: LD_ADDR_VAR 0 3
13389: PUSH
13390: LD_VAR 0 3
13394: PUSH
13395: LD_EXP 91
13399: ADD
13400: ST_TO_ADDR
// for i = 1 to 11 do
13401: LD_ADDR_VAR 0 2
13405: PUSH
13406: DOUBLE
13407: LD_INT 1
13409: DEC
13410: ST_TO_ADDR
13411: LD_INT 11
13413: PUSH
13414: FOR_TO
13415: IFFALSE 13483
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13417: LD_ADDR_OWVAR 21
13421: PUSH
13422: LD_INT 1
13424: PUSH
13425: LD_INT 3
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 1
13434: PPUSH
13435: LD_INT 2
13437: PPUSH
13438: CALL_OW 12
13442: ARRAY
13443: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13444: LD_INT 0
13446: PPUSH
13447: LD_INT 1
13449: PPUSH
13450: LD_INT 4
13452: PPUSH
13453: CALL_OW 12
13457: PPUSH
13458: LD_INT 10
13460: PPUSH
13461: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13465: LD_ADDR_VAR 0 3
13469: PUSH
13470: LD_VAR 0 3
13474: PUSH
13475: CALL_OW 44
13479: ADD
13480: ST_TO_ADDR
// end ;
13481: GO 13414
13483: POP
13484: POP
// for i in tmp do
13485: LD_ADDR_VAR 0 2
13489: PUSH
13490: LD_VAR 0 3
13494: PUSH
13495: FOR_IN
13496: IFFALSE 13521
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13498: LD_VAR 0 2
13502: PPUSH
13503: LD_INT 260
13505: PPUSH
13506: LD_INT 235
13508: PPUSH
13509: LD_INT 8
13511: PPUSH
13512: LD_INT 0
13514: PPUSH
13515: CALL_OW 50
13519: GO 13495
13521: POP
13522: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13523: LD_ADDR_EXP 102
13527: PUSH
13528: LD_EXP 102
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: LD_INT 22
13538: PUSH
13539: LD_VAR 0 5
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: PUSH
13548: LD_INT 3
13550: PUSH
13551: LD_INT 21
13553: PUSH
13554: LD_INT 2
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PPUSH
13569: CALL_OW 69
13573: PUSH
13574: LD_EXP 79
13578: PUSH
13579: LD_EXP 80
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: DIFF
13588: PPUSH
13589: CALL_OW 1
13593: ST_TO_ADDR
// uc_side := 0 ;
13594: LD_ADDR_OWVAR 20
13598: PUSH
13599: LD_INT 0
13601: ST_TO_ADDR
// uc_nation := 0 ;
13602: LD_ADDR_OWVAR 21
13606: PUSH
13607: LD_INT 0
13609: ST_TO_ADDR
// for i = 1 to 5 do
13610: LD_ADDR_VAR 0 2
13614: PUSH
13615: DOUBLE
13616: LD_INT 1
13618: DEC
13619: ST_TO_ADDR
13620: LD_INT 5
13622: PUSH
13623: FOR_TO
13624: IFFALSE 13661
// begin InitHc ;
13626: CALL_OW 19
// hc_class := class_apeman ;
13630: LD_ADDR_OWVAR 28
13634: PUSH
13635: LD_INT 12
13637: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13638: CALL_OW 44
13642: PPUSH
13643: LD_INT 299
13645: PPUSH
13646: LD_INT 229
13648: PPUSH
13649: LD_INT 10
13651: PPUSH
13652: LD_INT 0
13654: PPUSH
13655: CALL_OW 50
// end ;
13659: GO 13623
13661: POP
13662: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13663: LD_EXP 79
13667: PPUSH
13668: LD_INT 259
13670: PPUSH
13671: LD_INT 235
13673: PPUSH
13674: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13678: LD_EXP 79
13682: PPUSH
13683: LD_INT 262
13685: PPUSH
13686: LD_INT 235
13688: PPUSH
13689: CALL_OW 178
// if Simms then
13693: LD_EXP 80
13697: IFFALSE 13728
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13699: LD_EXP 80
13703: PPUSH
13704: LD_INT 262
13706: PPUSH
13707: LD_INT 235
13709: PPUSH
13710: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13714: LD_EXP 80
13718: PPUSH
13719: LD_EXP 79
13723: PPUSH
13724: CALL_OW 179
// end ; uc_side := 7 ;
13728: LD_ADDR_OWVAR 20
13732: PUSH
13733: LD_INT 7
13735: ST_TO_ADDR
// uc_nation := 1 ;
13736: LD_ADDR_OWVAR 21
13740: PUSH
13741: LD_INT 1
13743: ST_TO_ADDR
// bc_type := b_control_tower ;
13744: LD_ADDR_OWVAR 42
13748: PUSH
13749: LD_INT 36
13751: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13752: LD_ADDR_VAR 0 7
13756: PUSH
13757: LD_INT 268
13759: PPUSH
13760: LD_INT 251
13762: PPUSH
13763: LD_INT 4
13765: PPUSH
13766: CALL_OW 47
13770: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13771: LD_INT 0
13773: PPUSH
13774: LD_INT 10
13776: PPUSH
13777: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13781: CALL_OW 44
13785: PPUSH
13786: LD_VAR 0 7
13790: PPUSH
13791: CALL_OW 52
// end ;
13795: LD_VAR 0 1
13799: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13800: LD_EXP 31
13804: PUSH
13805: LD_EXP 23
13809: NOT
13810: AND
13811: PUSH
13812: LD_INT 22
13814: PUSH
13815: LD_INT 7
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: PUSH
13822: LD_INT 30
13824: PUSH
13825: LD_INT 8
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PPUSH
13836: CALL_OW 69
13840: AND
13841: IFFALSE 14069
13843: GO 13845
13845: DISABLE
13846: LD_INT 0
13848: PPUSH
13849: PPUSH
13850: PPUSH
// begin enable ;
13851: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13852: LD_ADDR_VAR 0 2
13856: PUSH
13857: LD_INT 81
13859: PUSH
13860: LD_INT 7
13862: PUSH
13863: EMPTY
13864: LIST
13865: LIST
13866: PUSH
13867: LD_INT 2
13869: PUSH
13870: LD_INT 32
13872: PUSH
13873: LD_INT 3
13875: PUSH
13876: EMPTY
13877: LIST
13878: LIST
13879: PUSH
13880: LD_INT 30
13882: PUSH
13883: LD_INT 30
13885: PUSH
13886: EMPTY
13887: LIST
13888: LIST
13889: PUSH
13890: LD_INT 30
13892: PUSH
13893: LD_INT 28
13895: PUSH
13896: EMPTY
13897: LIST
13898: LIST
13899: PUSH
13900: LD_INT 34
13902: PUSH
13903: LD_INT 49
13905: PUSH
13906: EMPTY
13907: LIST
13908: LIST
13909: PUSH
13910: LD_INT 34
13912: PUSH
13913: LD_INT 10
13915: PUSH
13916: EMPTY
13917: LIST
13918: LIST
13919: PUSH
13920: LD_INT 34
13922: PUSH
13923: LD_INT 8
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: PUSH
13930: EMPTY
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: PPUSH
13943: CALL_OW 69
13947: ST_TO_ADDR
// if not tmp then
13948: LD_VAR 0 2
13952: NOT
13953: IFFALSE 13957
// exit ;
13955: GO 14069
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13957: LD_VAR 0 2
13961: PPUSH
13962: LD_INT 34
13964: PUSH
13965: LD_INT 8
13967: PUSH
13968: EMPTY
13969: LIST
13970: LIST
13971: PPUSH
13972: CALL_OW 72
13976: IFFALSE 14009
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13978: LD_ADDR_VAR 0 3
13982: PUSH
13983: LD_VAR 0 2
13987: PPUSH
13988: LD_INT 34
13990: PUSH
13991: LD_INT 8
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: PPUSH
13998: CALL_OW 72
14002: PUSH
14003: LD_INT 1
14005: ARRAY
14006: ST_TO_ADDR
14007: GO 14033
// target := tmp [ rand ( 1 , tmp ) ] ;
14009: LD_ADDR_VAR 0 3
14013: PUSH
14014: LD_VAR 0 2
14018: PUSH
14019: LD_INT 1
14021: PPUSH
14022: LD_VAR 0 2
14026: PPUSH
14027: CALL_OW 12
14031: ARRAY
14032: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14033: LD_VAR 0 3
14037: PPUSH
14038: CALL_OW 255
14042: PUSH
14043: LD_INT 1
14045: EQUAL
14046: IFFALSE 14057
// CenterNowOnUnits ( target ) ;
14048: LD_VAR 0 3
14052: PPUSH
14053: CALL_OW 87
// SetLives ( target , 0 ) ;
14057: LD_VAR 0 3
14061: PPUSH
14062: LD_INT 0
14064: PPUSH
14065: CALL_OW 234
// end ;
14069: PPOPN 3
14071: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14072: LD_EXP 23
14076: NOT
14077: PUSH
14078: LD_EXP 31
14082: AND
14083: IFFALSE 14599
14085: GO 14087
14087: DISABLE
14088: LD_INT 0
14090: PPUSH
14091: PPUSH
14092: PPUSH
// begin uc_side := 7 ;
14093: LD_ADDR_OWVAR 20
14097: PUSH
14098: LD_INT 7
14100: ST_TO_ADDR
// uc_nation := 1 ;
14101: LD_ADDR_OWVAR 21
14105: PUSH
14106: LD_INT 1
14108: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14109: LD_ADDR_VAR 0 3
14113: PUSH
14114: LD_INT 125
14116: PUSH
14117: LD_INT 163
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: PUSH
14124: LD_INT 185
14126: PUSH
14127: LD_INT 168
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: PUSH
14134: LD_INT 111
14136: PUSH
14137: LD_INT 97
14139: PUSH
14140: EMPTY
14141: LIST
14142: LIST
14143: PUSH
14144: LD_INT 94
14146: PUSH
14147: LD_INT 114
14149: PUSH
14150: EMPTY
14151: LIST
14152: LIST
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: PPUSH
14160: CALL 107341 0 1
14164: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14165: LD_ADDR_EXP 96
14169: PUSH
14170: EMPTY
14171: ST_TO_ADDR
// for i = 1 to Difficulty do
14172: LD_ADDR_VAR 0 1
14176: PUSH
14177: DOUBLE
14178: LD_INT 1
14180: DEC
14181: ST_TO_ADDR
14182: LD_OWVAR 67
14186: PUSH
14187: FOR_TO
14188: IFFALSE 14346
// begin InitHc ;
14190: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14194: LD_INT 0
14196: PPUSH
14197: LD_INT 8
14199: PPUSH
14200: CALL_OW 381
// un := CreateHuman ;
14204: LD_ADDR_VAR 0 2
14208: PUSH
14209: CALL_OW 44
14213: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14214: LD_VAR 0 2
14218: PPUSH
14219: LD_INT 258
14221: PPUSH
14222: LD_INT 267
14224: PPUSH
14225: LD_INT 4
14227: PPUSH
14228: LD_INT 0
14230: PPUSH
14231: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14235: LD_ADDR_EXP 96
14239: PUSH
14240: LD_EXP 96
14244: PUSH
14245: LD_VAR 0 2
14249: UNION
14250: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14251: LD_VAR 0 2
14255: PPUSH
14256: LD_VAR 0 3
14260: PUSH
14261: LD_VAR 0 1
14265: ARRAY
14266: PUSH
14267: LD_INT 1
14269: ARRAY
14270: PPUSH
14271: LD_VAR 0 3
14275: PUSH
14276: LD_VAR 0 1
14280: ARRAY
14281: PUSH
14282: LD_INT 2
14284: ARRAY
14285: PPUSH
14286: LD_INT 4
14288: PPUSH
14289: LD_INT 1
14291: PPUSH
14292: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14296: LD_VAR 0 2
14300: PPUSH
14301: LD_VAR 0 3
14305: PUSH
14306: LD_VAR 0 1
14310: ARRAY
14311: PUSH
14312: LD_INT 1
14314: ARRAY
14315: PPUSH
14316: LD_VAR 0 3
14320: PUSH
14321: LD_VAR 0 1
14325: ARRAY
14326: PUSH
14327: LD_INT 2
14329: ARRAY
14330: PPUSH
14331: CALL_OW 171
// AddComInvisible ( un ) ;
14335: LD_VAR 0 2
14339: PPUSH
14340: CALL_OW 212
// end ;
14344: GO 14187
14346: POP
14347: POP
// repeat wait ( 0 0$45 ) ;
14348: LD_INT 1575
14350: PPUSH
14351: CALL_OW 67
// for i in allianceSpecialForce do
14355: LD_ADDR_VAR 0 1
14359: PUSH
14360: LD_EXP 96
14364: PUSH
14365: FOR_IN
14366: IFFALSE 14584
// begin if IsInvisible ( i ) then
14368: LD_VAR 0 1
14372: PPUSH
14373: CALL_OW 571
14377: IFFALSE 14553
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14379: LD_ADDR_VAR 0 3
14383: PUSH
14384: LD_INT 22
14386: PUSH
14387: LD_INT 1
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: PUSH
14394: LD_INT 50
14396: PUSH
14397: EMPTY
14398: LIST
14399: PUSH
14400: LD_INT 56
14402: PUSH
14403: EMPTY
14404: LIST
14405: PUSH
14406: LD_INT 91
14408: PUSH
14409: LD_VAR 0 1
14413: PUSH
14414: LD_INT 25
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: LIST
14421: PUSH
14422: LD_INT 2
14424: PUSH
14425: LD_INT 25
14427: PUSH
14428: LD_INT 1
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: LD_INT 25
14437: PUSH
14438: LD_INT 2
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 25
14447: PUSH
14448: LD_INT 3
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PUSH
14455: LD_INT 25
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: EMPTY
14462: LIST
14463: LIST
14464: PUSH
14465: LD_INT 25
14467: PUSH
14468: LD_INT 5
14470: PUSH
14471: EMPTY
14472: LIST
14473: LIST
14474: PUSH
14475: LD_INT 25
14477: PUSH
14478: LD_INT 8
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: PPUSH
14501: CALL_OW 69
14505: ST_TO_ADDR
// if not tmp then
14506: LD_VAR 0 3
14510: NOT
14511: IFFALSE 14515
// continue ;
14513: GO 14365
// if Prob ( 30 * Difficulty ) then
14515: LD_INT 30
14517: PUSH
14518: LD_OWVAR 67
14522: MUL
14523: PPUSH
14524: CALL_OW 13
14528: IFFALSE 14553
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14530: LD_VAR 0 3
14534: PUSH
14535: LD_INT 1
14537: PPUSH
14538: LD_VAR 0 3
14542: PPUSH
14543: CALL_OW 12
14547: ARRAY
14548: PPUSH
14549: CALL 34635 0 1
// end ; if IsDead ( i ) then
14553: LD_VAR 0 1
14557: PPUSH
14558: CALL_OW 301
14562: IFFALSE 14582
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14564: LD_ADDR_EXP 96
14568: PUSH
14569: LD_EXP 96
14573: PUSH
14574: LD_VAR 0 1
14578: DIFF
14579: ST_TO_ADDR
// continue ;
14580: GO 14365
// end ; end ;
14582: GO 14365
14584: POP
14585: POP
// until allianceDestroyed or not allianceSpecialForce ;
14586: LD_EXP 23
14590: PUSH
14591: LD_EXP 96
14595: NOT
14596: OR
14597: IFFALSE 14348
// end ;
14599: PPOPN 3
14601: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14602: LD_EXP 31
14606: PUSH
14607: LD_INT 22
14609: PUSH
14610: LD_INT 1
14612: PUSH
14613: EMPTY
14614: LIST
14615: LIST
14616: PUSH
14617: LD_INT 2
14619: PUSH
14620: LD_INT 35
14622: PUSH
14623: LD_INT 8
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 34
14632: PUSH
14633: LD_INT 8
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: LIST
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 69
14653: AND
14654: IFFALSE 15054
14656: GO 14658
14658: DISABLE
14659: LD_INT 0
14661: PPUSH
14662: PPUSH
14663: PPUSH
14664: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14665: LD_ADDR_VAR 0 1
14669: PUSH
14670: DOUBLE
14671: LD_INT 1
14673: DEC
14674: ST_TO_ADDR
14675: LD_INT 6
14677: PUSH
14678: LD_INT 8
14680: PUSH
14681: LD_INT 10
14683: PUSH
14684: LD_INT 12
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: PUSH
14693: LD_OWVAR 67
14697: ARRAY
14698: PUSH
14699: FOR_TO
14700: IFFALSE 14892
// begin uc_side := 7 ;
14702: LD_ADDR_OWVAR 20
14706: PUSH
14707: LD_INT 7
14709: ST_TO_ADDR
// uc_nation := 1 ;
14710: LD_ADDR_OWVAR 21
14714: PUSH
14715: LD_INT 1
14717: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14718: LD_INT 5
14720: PPUSH
14721: LD_INT 3
14723: PPUSH
14724: LD_INT 2
14726: PUSH
14727: LD_INT 3
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: PUSH
14734: LD_INT 1
14736: PPUSH
14737: LD_INT 2
14739: PPUSH
14740: CALL_OW 12
14744: ARRAY
14745: PPUSH
14746: LD_INT 6
14748: PUSH
14749: LD_INT 9
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: LD_INT 1
14758: PPUSH
14759: LD_INT 2
14761: PPUSH
14762: CALL_OW 12
14766: ARRAY
14767: PPUSH
14768: LD_INT 100
14770: PPUSH
14771: CALL 74385 0 5
// un := CreateVehicle ;
14775: LD_ADDR_VAR 0 2
14779: PUSH
14780: CALL_OW 45
14784: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14785: LD_VAR 0 2
14789: PPUSH
14790: LD_INT 4
14792: PPUSH
14793: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14797: LD_VAR 0 2
14801: PPUSH
14802: LD_INT 307
14804: PPUSH
14805: LD_INT 219
14807: PPUSH
14808: LD_INT 6
14810: PPUSH
14811: LD_INT 0
14813: PPUSH
14814: CALL_OW 50
// if GetControl ( un ) = control_remote then
14818: LD_VAR 0 2
14822: PPUSH
14823: CALL_OW 263
14827: PUSH
14828: LD_INT 2
14830: EQUAL
14831: IFFALSE 14842
// Connect ( un ) ;
14833: LD_VAR 0 2
14837: PPUSH
14838: CALL 77853 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14842: LD_VAR 0 2
14846: PPUSH
14847: LD_INT 124
14849: PPUSH
14850: LD_INT 92
14852: PPUSH
14853: LD_INT 12
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_VAR 0 3
14872: PPUSH
14873: LD_VAR 0 2
14877: PPUSH
14878: CALL 107236 0 2
14882: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14883: LD_INT 10
14885: PPUSH
14886: CALL_OW 67
// end ;
14890: GO 14699
14892: POP
14893: POP
// repeat wait ( 0 0$2 ) ;
14894: LD_INT 70
14896: PPUSH
14897: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14901: LD_ADDR_VAR 0 4
14905: PUSH
14906: LD_INT 22
14908: PUSH
14909: LD_INT 1
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 34
14918: PUSH
14919: LD_INT 8
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: PUSH
14926: EMPTY
14927: LIST
14928: LIST
14929: PPUSH
14930: CALL_OW 69
14934: ST_TO_ADDR
// if not e then
14935: LD_VAR 0 4
14939: NOT
14940: IFFALSE 14976
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14942: LD_ADDR_VAR 0 4
14946: PUSH
14947: LD_INT 22
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 21
14959: PUSH
14960: LD_INT 2
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PPUSH
14971: CALL_OW 69
14975: ST_TO_ADDR
// for i in tmp do
14976: LD_ADDR_VAR 0 1
14980: PUSH
14981: LD_VAR 0 3
14985: PUSH
14986: FOR_IN
14987: IFFALSE 15045
// if not IsOK ( i ) then
14989: LD_VAR 0 1
14993: PPUSH
14994: CALL_OW 302
14998: NOT
14999: IFFALSE 15019
// tmp := tmp diff i else
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_VAR 0 3
15010: PUSH
15011: LD_VAR 0 1
15015: DIFF
15016: ST_TO_ADDR
15017: GO 15043
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15019: LD_VAR 0 1
15023: PPUSH
15024: LD_VAR 0 4
15028: PPUSH
15029: LD_VAR 0 1
15033: PPUSH
15034: CALL_OW 74
15038: PPUSH
15039: CALL_OW 115
15043: GO 14986
15045: POP
15046: POP
// until not tmp ;
15047: LD_VAR 0 3
15051: NOT
15052: IFFALSE 14894
// end ;
15054: PPOPN 4
15056: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15057: LD_EXP 23
15061: NOT
15062: PUSH
15063: LD_EXP 31
15067: AND
15068: IFFALSE 16121
15070: GO 15072
15072: DISABLE
15073: LD_INT 0
15075: PPUSH
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
// begin enable ;
15080: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15081: LD_INT 22
15083: PUSH
15084: LD_INT 7
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: PUSH
15091: LD_INT 30
15093: PUSH
15094: LD_INT 3
15096: PUSH
15097: EMPTY
15098: LIST
15099: LIST
15100: PUSH
15101: EMPTY
15102: LIST
15103: LIST
15104: PPUSH
15105: CALL_OW 69
15109: NOT
15110: IFFALSE 15114
// exit ;
15112: GO 16121
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15114: LD_ADDR_VAR 0 4
15118: PUSH
15119: LD_INT 22
15121: PUSH
15122: LD_INT 7
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: PUSH
15129: LD_INT 30
15131: PUSH
15132: LD_INT 34
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: EMPTY
15140: LIST
15141: LIST
15142: PPUSH
15143: CALL_OW 69
15147: ST_TO_ADDR
// if Prob ( 40 ) then
15148: LD_INT 40
15150: PPUSH
15151: CALL_OW 13
15155: IFFALSE 15301
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15157: LD_INT 1
15159: PPUSH
15160: LD_INT 5
15162: PUSH
15163: LD_INT 3
15165: PUSH
15166: LD_INT 2
15168: PUSH
15169: LD_INT 6
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: LIST
15176: LIST
15177: PUSH
15178: LD_INT 5
15180: PUSH
15181: LD_INT 3
15183: PUSH
15184: LD_INT 2
15186: PUSH
15187: LD_INT 6
15189: PUSH
15190: EMPTY
15191: LIST
15192: LIST
15193: LIST
15194: LIST
15195: PUSH
15196: LD_INT 5
15198: PUSH
15199: LD_INT 3
15201: PUSH
15202: LD_INT 2
15204: PUSH
15205: LD_INT 6
15207: PUSH
15208: EMPTY
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: PUSH
15214: LD_INT 5
15216: PUSH
15217: LD_INT 3
15219: PUSH
15220: LD_INT 2
15222: PUSH
15223: LD_INT 9
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: PUSH
15232: LD_INT 24
15234: PUSH
15235: LD_INT 3
15237: PUSH
15238: LD_INT 3
15240: PUSH
15241: LD_INT 45
15243: PUSH
15244: EMPTY
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: PUSH
15250: LD_INT 24
15252: PUSH
15253: LD_INT 3
15255: PUSH
15256: LD_INT 3
15258: PUSH
15259: LD_INT 47
15261: PUSH
15262: EMPTY
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: PUSH
15268: LD_INT 24
15270: PUSH
15271: LD_INT 3
15273: PUSH
15274: LD_INT 3
15276: PUSH
15277: LD_INT 45
15279: PUSH
15280: EMPTY
15281: LIST
15282: LIST
15283: LIST
15284: LIST
15285: PUSH
15286: EMPTY
15287: LIST
15288: LIST
15289: LIST
15290: LIST
15291: LIST
15292: LIST
15293: LIST
15294: PPUSH
15295: CALL 63119 0 2
// end else
15299: GO 15443
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15301: LD_INT 1
15303: PPUSH
15304: LD_INT 24
15306: PUSH
15307: LD_INT 3
15309: PUSH
15310: LD_INT 3
15312: PUSH
15313: LD_INT 47
15315: PUSH
15316: EMPTY
15317: LIST
15318: LIST
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 24
15324: PUSH
15325: LD_INT 3
15327: PUSH
15328: LD_INT 3
15330: PUSH
15331: LD_INT 47
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: PUSH
15340: LD_INT 5
15342: PUSH
15343: LD_INT 3
15345: PUSH
15346: LD_INT 2
15348: PUSH
15349: LD_INT 9
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: PUSH
15358: LD_INT 5
15360: PUSH
15361: LD_INT 3
15363: PUSH
15364: LD_INT 2
15366: PUSH
15367: LD_INT 9
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: PUSH
15376: LD_INT 5
15378: PUSH
15379: LD_INT 3
15381: PUSH
15382: LD_INT 2
15384: PUSH
15385: LD_INT 9
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: PUSH
15394: LD_INT 24
15396: PUSH
15397: LD_INT 1
15399: PUSH
15400: LD_INT 3
15402: PUSH
15403: LD_INT 45
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: PUSH
15412: LD_INT 24
15414: PUSH
15415: LD_INT 1
15417: PUSH
15418: LD_INT 3
15420: PUSH
15421: LD_INT 45
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: PPUSH
15439: CALL 63119 0 2
// end ; wait ( 2 2$00 ) ;
15443: LD_INT 4200
15445: PPUSH
15446: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15450: LD_ADDR_VAR 0 2
15454: PUSH
15455: LD_INT 22
15457: PUSH
15458: LD_INT 7
15460: PUSH
15461: EMPTY
15462: LIST
15463: LIST
15464: PUSH
15465: LD_INT 21
15467: PUSH
15468: LD_INT 2
15470: PUSH
15471: EMPTY
15472: LIST
15473: LIST
15474: PUSH
15475: LD_INT 3
15477: PUSH
15478: LD_INT 34
15480: PUSH
15481: LD_INT 13
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 34
15490: PUSH
15491: LD_INT 12
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 34
15500: PUSH
15501: LD_INT 51
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: LD_INT 34
15510: PUSH
15511: LD_INT 52
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: EMPTY
15519: LIST
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: LIST
15529: PPUSH
15530: CALL_OW 69
15534: PUSH
15535: LD_EXP 124
15539: PUSH
15540: LD_INT 1
15542: ARRAY
15543: DIFF
15544: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15545: LD_ADDR_EXP 121
15549: PUSH
15550: LD_EXP 121
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_EXP 121
15562: PUSH
15563: LD_INT 1
15565: ARRAY
15566: PUSH
15567: LD_VAR 0 2
15571: DIFF
15572: PPUSH
15573: CALL_OW 1
15577: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15578: LD_ADDR_VAR 0 3
15582: PUSH
15583: LD_INT 0
15585: PPUSH
15586: LD_INT 1
15588: PPUSH
15589: CALL_OW 12
15593: ST_TO_ADDR
// p := 0 ;
15594: LD_ADDR_VAR 0 5
15598: PUSH
15599: LD_INT 0
15601: ST_TO_ADDR
// if target then
15602: LD_VAR 0 3
15606: IFFALSE 15797
// begin for i in tmp do
15608: LD_ADDR_VAR 0 1
15612: PUSH
15613: LD_VAR 0 2
15617: PUSH
15618: FOR_IN
15619: IFFALSE 15644
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 179
15628: PPUSH
15629: LD_INT 209
15631: PPUSH
15632: LD_INT 8
15634: PPUSH
15635: LD_INT 1
15637: PPUSH
15638: CALL_OW 483
15642: GO 15618
15644: POP
15645: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15646: LD_ADDR_VAR 0 2
15650: PUSH
15651: LD_VAR 0 2
15655: PPUSH
15656: LD_INT 24
15658: PUSH
15659: LD_INT 250
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: PPUSH
15666: CALL_OW 72
15670: ST_TO_ADDR
// for i in tmp do
15671: LD_ADDR_VAR 0 1
15675: PUSH
15676: LD_VAR 0 2
15680: PUSH
15681: FOR_IN
15682: IFFALSE 15722
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15684: LD_VAR 0 1
15688: PPUSH
15689: LD_INT 179
15691: PPUSH
15692: LD_INT 209
15694: PPUSH
15695: CALL_OW 297
15699: PUSH
15700: LD_INT 9
15702: GREATER
15703: IFFALSE 15720
// ComMoveXY ( i , 179 , 209 ) ;
15705: LD_VAR 0 1
15709: PPUSH
15710: LD_INT 179
15712: PPUSH
15713: LD_INT 209
15715: PPUSH
15716: CALL_OW 111
15720: GO 15681
15722: POP
15723: POP
// wait ( 0 0$1 ) ;
15724: LD_INT 35
15726: PPUSH
15727: CALL_OW 67
// p := Inc ( p ) ;
15731: LD_ADDR_VAR 0 5
15735: PUSH
15736: LD_VAR 0 5
15740: PPUSH
15741: CALL 108597 0 1
15745: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15746: LD_VAR 0 2
15750: PPUSH
15751: LD_INT 92
15753: PUSH
15754: LD_INT 179
15756: PUSH
15757: LD_INT 209
15759: PUSH
15760: LD_INT 9
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: PPUSH
15769: CALL_OW 72
15773: PUSH
15774: LD_VAR 0 2
15778: PUSH
15779: LD_INT 1
15781: MINUS
15782: GREATEREQUAL
15783: PUSH
15784: LD_VAR 0 5
15788: PUSH
15789: LD_INT 30
15791: GREATER
15792: OR
15793: IFFALSE 15646
// end else
15795: GO 15984
// begin for i in tmp do
15797: LD_ADDR_VAR 0 1
15801: PUSH
15802: LD_VAR 0 2
15806: PUSH
15807: FOR_IN
15808: IFFALSE 15833
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15810: LD_VAR 0 1
15814: PPUSH
15815: LD_INT 285
15817: PPUSH
15818: LD_INT 163
15820: PPUSH
15821: LD_INT 8
15823: PPUSH
15824: LD_INT 1
15826: PPUSH
15827: CALL_OW 483
15831: GO 15807
15833: POP
15834: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15835: LD_ADDR_VAR 0 2
15839: PUSH
15840: LD_VAR 0 2
15844: PPUSH
15845: LD_INT 24
15847: PUSH
15848: LD_INT 250
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PPUSH
15855: CALL_OW 72
15859: ST_TO_ADDR
// for i in tmp do
15860: LD_ADDR_VAR 0 1
15864: PUSH
15865: LD_VAR 0 2
15869: PUSH
15870: FOR_IN
15871: IFFALSE 15911
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15873: LD_VAR 0 1
15877: PPUSH
15878: LD_INT 285
15880: PPUSH
15881: LD_INT 163
15883: PPUSH
15884: CALL_OW 297
15888: PUSH
15889: LD_INT 9
15891: GREATER
15892: IFFALSE 15909
// ComMoveXY ( i , 285 , 163 ) ;
15894: LD_VAR 0 1
15898: PPUSH
15899: LD_INT 285
15901: PPUSH
15902: LD_INT 163
15904: PPUSH
15905: CALL_OW 111
15909: GO 15870
15911: POP
15912: POP
// wait ( 0 0$1 ) ;
15913: LD_INT 35
15915: PPUSH
15916: CALL_OW 67
// p := Inc ( p ) ;
15920: LD_ADDR_VAR 0 5
15924: PUSH
15925: LD_VAR 0 5
15929: PPUSH
15930: CALL 108597 0 1
15934: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15935: LD_VAR 0 2
15939: PPUSH
15940: LD_INT 92
15942: PUSH
15943: LD_INT 285
15945: PUSH
15946: LD_INT 163
15948: PUSH
15949: LD_INT 9
15951: PUSH
15952: EMPTY
15953: LIST
15954: LIST
15955: LIST
15956: LIST
15957: PPUSH
15958: CALL_OW 72
15962: PUSH
15963: LD_VAR 0 2
15967: PUSH
15968: LD_INT 1
15970: MINUS
15971: GREATEREQUAL
15972: PUSH
15973: LD_VAR 0 5
15977: PUSH
15978: LD_INT 30
15980: GREATER
15981: OR
15982: IFFALSE 15835
// end ; repeat wait ( 0 0$1 ) ;
15984: LD_INT 35
15986: PPUSH
15987: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
15991: LD_ADDR_VAR 0 2
15995: PUSH
15996: LD_VAR 0 2
16000: PPUSH
16001: LD_INT 50
16003: PUSH
16004: EMPTY
16005: LIST
16006: PPUSH
16007: CALL_OW 72
16011: ST_TO_ADDR
// for i in tmp do
16012: LD_ADDR_VAR 0 1
16016: PUSH
16017: LD_VAR 0 2
16021: PUSH
16022: FOR_IN
16023: IFFALSE 16112
// if GetWeapon ( i ) = ru_time_lapser then
16025: LD_VAR 0 1
16029: PPUSH
16030: CALL_OW 264
16034: PUSH
16035: LD_INT 49
16037: EQUAL
16038: IFFALSE 16076
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16040: LD_VAR 0 1
16044: PPUSH
16045: LD_INT 81
16047: PUSH
16048: LD_INT 7
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: PPUSH
16055: CALL_OW 69
16059: PPUSH
16060: LD_VAR 0 1
16064: PPUSH
16065: CALL_OW 74
16069: PPUSH
16070: CALL_OW 112
16074: GO 16110
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16076: LD_VAR 0 1
16080: PPUSH
16081: LD_INT 81
16083: PUSH
16084: LD_INT 7
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PPUSH
16091: CALL_OW 69
16095: PPUSH
16096: LD_VAR 0 1
16100: PPUSH
16101: CALL_OW 74
16105: PPUSH
16106: CALL_OW 115
16110: GO 16022
16112: POP
16113: POP
// until not tmp ;
16114: LD_VAR 0 2
16118: NOT
16119: IFFALSE 15984
// end ;
16121: PPOPN 5
16123: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16124: LD_EXP 31
16128: PUSH
16129: LD_EXP 79
16133: PPUSH
16134: CALL_OW 302
16138: AND
16139: PUSH
16140: LD_OWVAR 67
16144: PUSH
16145: LD_INT 2
16147: GREATER
16148: AND
16149: IFFALSE 16249
16151: GO 16153
16153: DISABLE
// begin enable ;
16154: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16155: LD_EXP 79
16159: PPUSH
16160: LD_INT 245
16162: PPUSH
16163: LD_INT 234
16165: PPUSH
16166: CALL_OW 297
16170: PUSH
16171: LD_INT 6
16173: GREATER
16174: IFFALSE 16193
// ComMoveXY ( Roth , 245 , 234 ) else
16176: LD_EXP 79
16180: PPUSH
16181: LD_INT 245
16183: PPUSH
16184: LD_INT 234
16186: PPUSH
16187: CALL_OW 111
16191: GO 16249
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16193: LD_EXP 79
16197: PPUSH
16198: LD_INT 259
16200: PUSH
16201: LD_INT 235
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PUSH
16208: LD_INT 252
16210: PUSH
16211: LD_INT 209
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PUSH
16218: LD_INT 275
16220: PUSH
16221: LD_INT 235
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: LIST
16232: PUSH
16233: LD_INT 1
16235: PPUSH
16236: LD_INT 3
16238: PPUSH
16239: CALL_OW 12
16243: ARRAY
16244: PPUSH
16245: CALL 111384 0 2
// end ; end_of_file
16249: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16250: LD_INT 0
16252: PPUSH
16253: PPUSH
16254: PPUSH
16255: PPUSH
// missionStage := 13 ;
16256: LD_ADDR_EXP 15
16260: PUSH
16261: LD_INT 13
16263: ST_TO_ADDR
// uc_side := 2 ;
16264: LD_ADDR_OWVAR 20
16268: PUSH
16269: LD_INT 2
16271: ST_TO_ADDR
// uc_nation := 2 ;
16272: LD_ADDR_OWVAR 21
16276: PUSH
16277: LD_INT 2
16279: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16280: LD_ADDR_EXP 97
16284: PUSH
16285: LD_STRING Omar
16287: PPUSH
16288: CALL_OW 25
16292: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16293: LD_EXP 97
16297: PPUSH
16298: LD_INT 4
16300: PPUSH
16301: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16305: LD_EXP 97
16309: PPUSH
16310: LD_INT 242
16312: PPUSH
16313: LD_INT 75
16315: PPUSH
16316: LD_INT 0
16318: PPUSH
16319: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16323: LD_ADDR_EXP 98
16327: PUSH
16328: LD_STRING Heike
16330: PPUSH
16331: CALL_OW 25
16335: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16336: LD_INT 14
16338: PPUSH
16339: LD_INT 3
16341: PPUSH
16342: LD_INT 1
16344: PPUSH
16345: LD_INT 27
16347: PPUSH
16348: LD_INT 100
16350: PPUSH
16351: CALL 74385 0 5
// veh := CreateVehicle ;
16355: LD_ADDR_VAR 0 3
16359: PUSH
16360: CALL_OW 45
16364: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16365: LD_VAR 0 3
16369: PPUSH
16370: LD_INT 2
16372: NEG
16373: PPUSH
16374: CALL_OW 242
// SetDir ( veh , 4 ) ;
16378: LD_VAR 0 3
16382: PPUSH
16383: LD_INT 4
16385: PPUSH
16386: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16390: LD_VAR 0 3
16394: PPUSH
16395: LD_INT 241
16397: PPUSH
16398: LD_INT 72
16400: PPUSH
16401: LD_INT 0
16403: PPUSH
16404: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16408: LD_EXP 98
16412: PPUSH
16413: LD_VAR 0 3
16417: PPUSH
16418: CALL_OW 52
// if KhatamStatus then
16422: LD_EXP 8
16426: IFFALSE 16489
// begin Khatam := NewCharacter ( Khatam ) ;
16428: LD_ADDR_EXP 99
16432: PUSH
16433: LD_STRING Khatam
16435: PPUSH
16436: CALL_OW 25
16440: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16441: LD_EXP 99
16445: PPUSH
16446: LD_INT 245
16448: PPUSH
16449: LD_INT 78
16451: PPUSH
16452: LD_INT 3
16454: PPUSH
16455: LD_INT 0
16457: PPUSH
16458: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16462: LD_EXP 99
16466: PPUSH
16467: LD_INT 4
16469: PPUSH
16470: LD_INT 10
16472: PPUSH
16473: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16477: LD_EXP 99
16481: PPUSH
16482: LD_INT 4
16484: PPUSH
16485: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16489: LD_ADDR_VAR 0 2
16493: PUSH
16494: DOUBLE
16495: LD_INT 1
16497: DEC
16498: ST_TO_ADDR
16499: LD_INT 2
16501: PUSH
16502: LD_INT 2
16504: PUSH
16505: LD_INT 3
16507: PUSH
16508: LD_INT 3
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: LIST
16515: LIST
16516: PUSH
16517: LD_OWVAR 67
16521: ARRAY
16522: PUSH
16523: FOR_TO
16524: IFFALSE 16590
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16526: LD_INT 0
16528: PPUSH
16529: LD_INT 6
16531: PUSH
16532: LD_OWVAR 67
16536: PLUS
16537: PPUSH
16538: CALL_OW 384
// un := CreateHuman ;
16542: LD_ADDR_VAR 0 4
16546: PUSH
16547: CALL_OW 44
16551: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16552: LD_VAR 0 4
16556: PPUSH
16557: LD_INT 28
16559: PUSH
16560: LD_INT 29
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_VAR 0 2
16571: PUSH
16572: LD_INT 2
16574: MOD
16575: PUSH
16576: LD_INT 1
16578: PLUS
16579: ARRAY
16580: PPUSH
16581: LD_INT 0
16583: PPUSH
16584: CALL_OW 49
// end ;
16588: GO 16523
16590: POP
16591: POP
// for i = 1 to 6 do
16592: LD_ADDR_VAR 0 2
16596: PUSH
16597: DOUBLE
16598: LD_INT 1
16600: DEC
16601: ST_TO_ADDR
16602: LD_INT 6
16604: PUSH
16605: FOR_TO
16606: IFFALSE 16651
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16608: LD_INT 0
16610: PPUSH
16611: LD_INT 6
16613: PUSH
16614: LD_OWVAR 67
16618: PLUS
16619: PPUSH
16620: CALL_OW 381
// un := CreateHuman ;
16624: LD_ADDR_VAR 0 4
16628: PUSH
16629: CALL_OW 44
16633: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16634: LD_VAR 0 4
16638: PPUSH
16639: LD_INT 32
16641: PPUSH
16642: LD_INT 0
16644: PPUSH
16645: CALL_OW 49
// end ;
16649: GO 16605
16651: POP
16652: POP
// for i = 1 to 3 do
16653: LD_ADDR_VAR 0 2
16657: PUSH
16658: DOUBLE
16659: LD_INT 1
16661: DEC
16662: ST_TO_ADDR
16663: LD_INT 3
16665: PUSH
16666: FOR_TO
16667: IFFALSE 16715
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16669: LD_INT 0
16671: PPUSH
16672: LD_INT 8
16674: PPUSH
16675: LD_INT 6
16677: PUSH
16678: LD_OWVAR 67
16682: PLUS
16683: PPUSH
16684: CALL_OW 380
// un := CreateHuman ;
16688: LD_ADDR_VAR 0 4
16692: PUSH
16693: CALL_OW 44
16697: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16698: LD_VAR 0 4
16702: PPUSH
16703: LD_INT 32
16705: PPUSH
16706: LD_INT 0
16708: PPUSH
16709: CALL_OW 49
// end ;
16713: GO 16666
16715: POP
16716: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16717: LD_ADDR_VAR 0 2
16721: PUSH
16722: DOUBLE
16723: LD_INT 1
16725: DEC
16726: ST_TO_ADDR
16727: LD_INT 2
16729: PUSH
16730: LD_INT 3
16732: PUSH
16733: LD_INT 4
16735: PUSH
16736: LD_INT 4
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: LIST
16743: LIST
16744: PUSH
16745: LD_OWVAR 67
16749: ARRAY
16750: PUSH
16751: FOR_TO
16752: IFFALSE 16842
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16754: LD_INT 14
16756: PPUSH
16757: LD_INT 2
16759: PPUSH
16760: LD_INT 1
16762: PPUSH
16763: LD_INT 28
16765: PPUSH
16766: LD_INT 80
16768: PPUSH
16769: CALL 74385 0 5
// veh := CreateVehicle ;
16773: LD_ADDR_VAR 0 3
16777: PUSH
16778: CALL_OW 45
16782: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16783: LD_VAR 0 3
16787: PPUSH
16788: LD_INT 3
16790: PPUSH
16791: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16795: LD_VAR 0 3
16799: PPUSH
16800: LD_INT 29
16802: PPUSH
16803: LD_INT 0
16805: PPUSH
16806: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16810: LD_INT 0
16812: PPUSH
16813: LD_INT 6
16815: PUSH
16816: LD_OWVAR 67
16820: PLUS
16821: PPUSH
16822: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16826: CALL_OW 44
16830: PPUSH
16831: LD_VAR 0 3
16835: PPUSH
16836: CALL_OW 52
// end ;
16840: GO 16751
16842: POP
16843: POP
// for i = 1 to 5 + Difficulty do
16844: LD_ADDR_VAR 0 2
16848: PUSH
16849: DOUBLE
16850: LD_INT 1
16852: DEC
16853: ST_TO_ADDR
16854: LD_INT 5
16856: PUSH
16857: LD_OWVAR 67
16861: PLUS
16862: PUSH
16863: FOR_TO
16864: IFFALSE 16991
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16866: LD_INT 14
16868: PPUSH
16869: LD_INT 1
16871: PPUSH
16872: LD_INT 3
16874: PPUSH
16875: CALL_OW 12
16879: PPUSH
16880: LD_INT 1
16882: PPUSH
16883: LD_INT 28
16885: PUSH
16886: LD_INT 26
16888: PUSH
16889: LD_INT 27
16891: PUSH
16892: LD_INT 25
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PUSH
16901: LD_VAR 0 2
16905: PUSH
16906: LD_INT 4
16908: MOD
16909: PUSH
16910: LD_INT 1
16912: PLUS
16913: ARRAY
16914: PPUSH
16915: LD_INT 80
16917: PPUSH
16918: CALL 74385 0 5
// veh := CreateVehicle ;
16922: LD_ADDR_VAR 0 3
16926: PUSH
16927: CALL_OW 45
16931: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16932: LD_VAR 0 3
16936: PPUSH
16937: LD_INT 4
16939: PPUSH
16940: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16944: LD_VAR 0 3
16948: PPUSH
16949: LD_INT 28
16951: PPUSH
16952: LD_INT 0
16954: PPUSH
16955: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16959: LD_INT 0
16961: PPUSH
16962: LD_INT 6
16964: PUSH
16965: LD_OWVAR 67
16969: PLUS
16970: PPUSH
16971: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16975: CALL_OW 44
16979: PPUSH
16980: LD_VAR 0 3
16984: PPUSH
16985: CALL_OW 52
// end ;
16989: GO 16863
16991: POP
16992: POP
// for i = 1 to Difficulty do
16993: LD_ADDR_VAR 0 2
16997: PUSH
16998: DOUBLE
16999: LD_INT 1
17001: DEC
17002: ST_TO_ADDR
17003: LD_OWVAR 67
17007: PUSH
17008: FOR_TO
17009: IFFALSE 17069
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17011: LD_INT 14
17013: PPUSH
17014: LD_INT 3
17016: PPUSH
17017: LD_INT 5
17019: PPUSH
17020: LD_INT 29
17022: PPUSH
17023: LD_INT 80
17025: PPUSH
17026: CALL 74385 0 5
// veh := CreateVehicle ;
17030: LD_ADDR_VAR 0 3
17034: PUSH
17035: CALL_OW 45
17039: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17040: LD_VAR 0 3
17044: PPUSH
17045: LD_INT 4
17047: PPUSH
17048: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17052: LD_VAR 0 3
17056: PPUSH
17057: LD_INT 28
17059: PPUSH
17060: LD_INT 0
17062: PPUSH
17063: CALL_OW 49
// end ;
17067: GO 17008
17069: POP
17070: POP
// end ;
17071: LD_VAR 0 1
17075: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17076: LD_INT 22
17078: PUSH
17079: LD_INT 2
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PPUSH
17086: CALL_OW 69
17090: IFFALSE 17469
17092: GO 17094
17094: DISABLE
17095: LD_INT 0
17097: PPUSH
17098: PPUSH
17099: PPUSH
17100: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 22
17108: PUSH
17109: LD_INT 2
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: PUSH
17116: LD_INT 25
17118: PUSH
17119: LD_INT 4
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PPUSH
17130: CALL_OW 69
17134: PUSH
17135: LD_EXP 99
17139: DIFF
17140: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17141: LD_ADDR_VAR 0 2
17145: PUSH
17146: LD_INT 22
17148: PUSH
17149: LD_INT 2
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PPUSH
17156: CALL_OW 69
17160: PUSH
17161: LD_EXP 99
17165: PUSH
17166: LD_VAR 0 3
17170: UNION
17171: DIFF
17172: ST_TO_ADDR
// if Khatam then
17173: LD_EXP 99
17177: IFFALSE 17194
// ComMoveXY ( Khatam , 211 , 92 ) ;
17179: LD_EXP 99
17183: PPUSH
17184: LD_INT 211
17186: PPUSH
17187: LD_INT 92
17189: PPUSH
17190: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17194: LD_INT 197
17196: PPUSH
17197: LD_INT 80
17199: PPUSH
17200: LD_INT 2
17202: PPUSH
17203: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17207: LD_INT 213
17209: PPUSH
17210: LD_INT 90
17212: PPUSH
17213: LD_INT 2
17215: PPUSH
17216: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17220: LD_INT 215
17222: PPUSH
17223: LD_INT 129
17225: PPUSH
17226: LD_INT 2
17228: PPUSH
17229: CALL_OW 441
// if sci then
17233: LD_VAR 0 3
17237: IFFALSE 17258
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17239: LD_VAR 0 3
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_INT 197
17250: PPUSH
17251: LD_INT 80
17253: PPUSH
17254: CALL_OW 158
// if sci > 1 then
17258: LD_VAR 0 3
17262: PUSH
17263: LD_INT 1
17265: GREATER
17266: IFFALSE 17287
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17268: LD_VAR 0 3
17272: PUSH
17273: LD_INT 2
17275: ARRAY
17276: PPUSH
17277: LD_INT 213
17279: PPUSH
17280: LD_INT 90
17282: PPUSH
17283: CALL_OW 158
// if sci > 2 then
17287: LD_VAR 0 3
17291: PUSH
17292: LD_INT 2
17294: GREATER
17295: IFFALSE 17316
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17297: LD_VAR 0 3
17301: PUSH
17302: LD_INT 3
17304: ARRAY
17305: PPUSH
17306: LD_INT 215
17308: PPUSH
17309: LD_INT 129
17311: PPUSH
17312: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17316: LD_VAR 0 2
17320: PPUSH
17321: LD_INT 195
17323: PPUSH
17324: LD_INT 102
17326: PPUSH
17327: CALL_OW 114
// wait ( 0 0$5 ) ;
17331: LD_INT 175
17333: PPUSH
17334: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17338: LD_INT 70
17340: PPUSH
17341: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17345: LD_ADDR_VAR 0 4
17349: PUSH
17350: LD_INT 92
17352: PUSH
17353: LD_INT 195
17355: PUSH
17356: LD_INT 102
17358: PUSH
17359: LD_INT 36
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: LIST
17367: PUSH
17368: LD_INT 22
17370: PUSH
17371: LD_INT 1
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: PUSH
17378: EMPTY
17379: LIST
17380: LIST
17381: PPUSH
17382: CALL_OW 69
17386: ST_TO_ADDR
// for i in tmp do
17387: LD_ADDR_VAR 0 1
17391: PUSH
17392: LD_VAR 0 2
17396: PUSH
17397: FOR_IN
17398: IFFALSE 17449
// if enemy then
17400: LD_VAR 0 4
17404: IFFALSE 17432
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17406: LD_VAR 0 1
17410: PPUSH
17411: LD_VAR 0 4
17415: PPUSH
17416: LD_VAR 0 1
17420: PPUSH
17421: CALL_OW 74
17425: PPUSH
17426: CALL_OW 115
17430: GO 17447
// ComAgressiveMove ( i , 195 , 102 ) ;
17432: LD_VAR 0 1
17436: PPUSH
17437: LD_INT 195
17439: PPUSH
17440: LD_INT 102
17442: PPUSH
17443: CALL_OW 114
17447: GO 17397
17449: POP
17450: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17451: LD_VAR 0 2
17455: PPUSH
17456: LD_INT 50
17458: PUSH
17459: EMPTY
17460: LIST
17461: PPUSH
17462: CALL_OW 72
17466: NOT
17467: IFFALSE 17338
// end ; end_of_file
17469: PPOPN 4
17471: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
17472: LD_INT 0
17474: PPUSH
17475: PPUSH
17476: PPUSH
17477: PPUSH
17478: PPUSH
17479: PPUSH
17480: PPUSH
17481: PPUSH
17482: PPUSH
// Video ( true ) ;
17483: LD_INT 1
17485: PPUSH
17486: CALL 107208 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17490: LD_ADDR_VAR 0 5
17494: PUSH
17495: LD_INT 7
17497: PPUSH
17498: LD_INT 0
17500: PPUSH
17501: CALL_OW 517
17505: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17506: LD_ADDR_VAR 0 2
17510: PUSH
17511: DOUBLE
17512: LD_INT 1
17514: DEC
17515: ST_TO_ADDR
17516: LD_VAR 0 5
17520: PUSH
17521: LD_INT 1
17523: ARRAY
17524: PUSH
17525: FOR_TO
17526: IFFALSE 17571
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17528: LD_VAR 0 5
17532: PUSH
17533: LD_INT 1
17535: ARRAY
17536: PUSH
17537: LD_VAR 0 2
17541: ARRAY
17542: PPUSH
17543: LD_VAR 0 5
17547: PUSH
17548: LD_INT 2
17550: ARRAY
17551: PUSH
17552: LD_VAR 0 2
17556: ARRAY
17557: PPUSH
17558: LD_INT 1
17560: PPUSH
17561: LD_INT 15
17563: NEG
17564: PPUSH
17565: CALL 107122 0 4
17569: GO 17525
17571: POP
17572: POP
// CenterNowOnUnits ( Powell ) ;
17573: LD_EXP 61
17577: PPUSH
17578: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17582: LD_ADDR_VAR 0 5
17586: PUSH
17587: LD_EXP 59
17591: PUSH
17592: EMPTY
17593: LIST
17594: ST_TO_ADDR
// if GirlNewVeh then
17595: LD_EXP 60
17599: IFFALSE 17617
// tmp := tmp ^ GirlNewVeh ;
17601: LD_ADDR_VAR 0 5
17605: PUSH
17606: LD_VAR 0 5
17610: PUSH
17611: LD_EXP 60
17615: ADD
17616: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17617: LD_VAR 0 5
17621: PPUSH
17622: LD_INT 60
17624: PPUSH
17625: LD_INT 109
17627: PPUSH
17628: CALL_OW 111
// if KappaStatus then
17632: LD_EXP 2
17636: IFFALSE 17688
// begin Say ( JMM , D1nT-JMM-1 ) ;
17638: LD_EXP 40
17642: PPUSH
17643: LD_STRING D1nT-JMM-1
17645: PPUSH
17646: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17650: LD_EXP 61
17654: PPUSH
17655: LD_STRING D1T-Pow-1
17657: PPUSH
17658: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17662: LD_EXP 40
17666: PPUSH
17667: LD_STRING D1T-JMM-2
17669: PPUSH
17670: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17674: LD_EXP 61
17678: PPUSH
17679: LD_STRING D1T-Pow-2
17681: PPUSH
17682: CALL_OW 88
// end else
17686: GO 17894
// if JMMGirlStatus then
17688: LD_EXP 6
17692: IFFALSE 17837
// begin Say ( JMM , D1T-JMM-1 ) ;
17694: LD_EXP 40
17698: PPUSH
17699: LD_STRING D1T-JMM-1
17701: PPUSH
17702: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17706: LD_EXP 61
17710: PPUSH
17711: LD_STRING D1T-Pow-1
17713: PPUSH
17714: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17718: LD_EXP 40
17722: PPUSH
17723: LD_STRING D1T-JMM-3
17725: PPUSH
17726: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17730: LD_EXP 61
17734: PPUSH
17735: LD_STRING D1T-Pow-3
17737: PPUSH
17738: CALL_OW 88
// if JMMGirl then
17742: LD_EXP 7
17746: IFFALSE 17835
// begin case JMMGirl of 1 :
17748: LD_EXP 7
17752: PUSH
17753: LD_INT 1
17755: DOUBLE
17756: EQUAL
17757: IFTRUE 17761
17759: GO 17776
17761: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17762: LD_EXP 41
17766: PPUSH
17767: LD_STRING D1T-Joan-3
17769: PPUSH
17770: CALL_OW 88
17774: GO 17823
17776: LD_INT 2
17778: DOUBLE
17779: EQUAL
17780: IFTRUE 17784
17782: GO 17799
17784: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17785: LD_EXP 43
17789: PPUSH
17790: LD_STRING D1T-Lisa-3
17792: PPUSH
17793: CALL_OW 88
17797: GO 17823
17799: LD_INT 3
17801: DOUBLE
17802: EQUAL
17803: IFTRUE 17807
17805: GO 17822
17807: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17808: LD_EXP 55
17812: PPUSH
17813: LD_STRING D1T-Con-3
17815: PPUSH
17816: CALL_OW 88
17820: GO 17823
17822: POP
// Say ( Powell , D1T-Pow-4 ) ;
17823: LD_EXP 61
17827: PPUSH
17828: LD_STRING D1T-Pow-4
17830: PPUSH
17831: CALL_OW 88
// end ; end else
17835: GO 17894
// if not FastEnd then
17837: LD_EXP 11
17841: NOT
17842: IFFALSE 17870
// begin Say ( JMM , D1T-JMM-4 ) ;
17844: LD_EXP 40
17848: PPUSH
17849: LD_STRING D1T-JMM-4
17851: PPUSH
17852: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17856: LD_EXP 61
17860: PPUSH
17861: LD_STRING D1T-Pow-5
17863: PPUSH
17864: CALL_OW 88
// end else
17868: GO 17894
// begin Say ( JMM , D1nT-JMM-1 ) ;
17870: LD_EXP 40
17874: PPUSH
17875: LD_STRING D1nT-JMM-1
17877: PPUSH
17878: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17882: LD_EXP 61
17886: PPUSH
17887: LD_STRING D1nT-Pow-1
17889: PPUSH
17890: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17894: LD_INT 3
17896: PPUSH
17897: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17901: LD_EXP 59
17905: PPUSH
17906: CALL_OW 314
17910: NOT
17911: IFFALSE 17894
// ComExitVehicle ( JMM ) ;
17913: LD_EXP 40
17917: PPUSH
17918: CALL_OW 121
// repeat wait ( 3 ) ;
17922: LD_INT 3
17924: PPUSH
17925: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17929: LD_EXP 40
17933: PPUSH
17934: CALL_OW 310
17938: NOT
17939: IFFALSE 17922
// ComMoveXY ( JMM , 60 , 94 ) ;
17941: LD_EXP 40
17945: PPUSH
17946: LD_INT 60
17948: PPUSH
17949: LD_INT 94
17951: PPUSH
17952: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17956: LD_EXP 40
17960: PPUSH
17961: LD_EXP 61
17965: PPUSH
17966: CALL_OW 179
// if Joan then
17970: LD_EXP 41
17974: IFFALSE 18028
// begin ComExitVehicle ( Joan ) ;
17976: LD_EXP 41
17980: PPUSH
17981: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17985: LD_EXP 41
17989: PPUSH
17990: LD_INT 35
17992: PPUSH
17993: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17997: LD_EXP 41
18001: PPUSH
18002: LD_INT 65
18004: PPUSH
18005: LD_INT 104
18007: PPUSH
18008: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18012: LD_EXP 41
18016: PPUSH
18017: LD_EXP 40
18021: PPUSH
18022: CALL_OW 179
// end else
18026: GO 18162
// if Lisa and JMMGirl = 2 then
18028: LD_EXP 43
18032: PUSH
18033: LD_EXP 7
18037: PUSH
18038: LD_INT 2
18040: EQUAL
18041: AND
18042: IFFALSE 18096
// begin ComExitVehicle ( Lisa ) ;
18044: LD_EXP 43
18048: PPUSH
18049: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18053: LD_EXP 43
18057: PPUSH
18058: LD_INT 35
18060: PPUSH
18061: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18065: LD_EXP 43
18069: PPUSH
18070: LD_INT 65
18072: PPUSH
18073: LD_INT 104
18075: PPUSH
18076: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18080: LD_EXP 43
18084: PPUSH
18085: LD_EXP 40
18089: PPUSH
18090: CALL_OW 179
// end else
18094: GO 18162
// if Connie and JMMGirl = 3 then
18096: LD_EXP 55
18100: PUSH
18101: LD_EXP 7
18105: PUSH
18106: LD_INT 3
18108: EQUAL
18109: AND
18110: IFFALSE 18162
// begin ComExitVehicle ( Connie ) ;
18112: LD_EXP 55
18116: PPUSH
18117: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18121: LD_EXP 55
18125: PPUSH
18126: LD_INT 35
18128: PPUSH
18129: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18133: LD_EXP 55
18137: PPUSH
18138: LD_INT 65
18140: PPUSH
18141: LD_INT 104
18143: PPUSH
18144: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18148: LD_EXP 55
18152: PPUSH
18153: LD_EXP 40
18157: PPUSH
18158: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18162: LD_INT 35
18164: PPUSH
18165: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18169: LD_EXP 40
18173: PPUSH
18174: LD_EXP 61
18178: PPUSH
18179: CALL_OW 296
18183: PUSH
18184: LD_INT 8
18186: LESS
18187: IFFALSE 18162
// wait ( 0 0$0.5 ) ;
18189: LD_INT 18
18191: PPUSH
18192: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18196: LD_EXP 40
18200: PPUSH
18201: LD_STRING D1-JMM-1
18203: PPUSH
18204: CALL_OW 88
// async ;
18208: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18209: LD_EXP 61
18213: PPUSH
18214: LD_STRING D1-Pow-1
18216: PPUSH
18217: CALL_OW 88
// if not dialogue_skipped then
18221: LD_OWVAR 59
18225: NOT
18226: IFFALSE 18235
// wait ( 0 0$2 ) ;
18228: LD_INT 70
18230: PPUSH
18231: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18235: LD_INT 170
18237: PPUSH
18238: LD_INT 99
18240: PPUSH
18241: LD_INT 1
18243: PPUSH
18244: LD_INT 6
18246: NEG
18247: PPUSH
18248: CALL 107122 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18252: LD_INT 174
18254: PPUSH
18255: LD_INT 115
18257: PPUSH
18258: LD_INT 1
18260: PPUSH
18261: LD_INT 6
18263: NEG
18264: PPUSH
18265: CALL 107122 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18269: LD_INT 169
18271: PPUSH
18272: LD_INT 71
18274: PPUSH
18275: LD_INT 1
18277: PPUSH
18278: LD_INT 6
18280: NEG
18281: PPUSH
18282: CALL 107122 0 4
// if not dialogue_skipped then
18286: LD_OWVAR 59
18290: NOT
18291: IFFALSE 18310
// begin CenterOnXY ( 170 , 99 ) ;
18293: LD_INT 170
18295: PPUSH
18296: LD_INT 99
18298: PPUSH
18299: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18303: LD_INT 80
18305: PPUSH
18306: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18310: LD_INT 75
18312: PPUSH
18313: LD_INT 53
18315: PPUSH
18316: LD_INT 1
18318: PPUSH
18319: LD_INT 9
18321: NEG
18322: PPUSH
18323: CALL 107122 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18327: LD_INT 54
18329: PPUSH
18330: LD_INT 42
18332: PPUSH
18333: LD_INT 1
18335: PPUSH
18336: LD_INT 9
18338: NEG
18339: PPUSH
18340: CALL 107122 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18344: LD_INT 62
18346: PPUSH
18347: LD_INT 51
18349: PPUSH
18350: LD_INT 1
18352: PPUSH
18353: LD_INT 9
18355: NEG
18356: PPUSH
18357: CALL 107122 0 4
// if not dialogue_skipped then
18361: LD_OWVAR 59
18365: NOT
18366: IFFALSE 18385
// begin CenterOnXY ( 75 , 53 ) ;
18368: LD_INT 75
18370: PPUSH
18371: LD_INT 53
18373: PPUSH
18374: CALL_OW 84
// wait ( 0 0$4 ) ;
18378: LD_INT 140
18380: PPUSH
18381: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18385: LD_EXP 61
18389: PPUSH
18390: CALL_OW 87
// if not dialogue_skipped then
18394: LD_OWVAR 59
18398: NOT
18399: IFFALSE 18408
// wait ( 0 0$2 ) ;
18401: LD_INT 70
18403: PPUSH
18404: CALL_OW 67
// sync ;
18408: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18409: LD_EXP 40
18413: PPUSH
18414: LD_STRING D1-JMM-2
18416: PPUSH
18417: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18421: LD_EXP 61
18425: PPUSH
18426: LD_STRING D1-Pow-2
18428: PPUSH
18429: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18433: LD_EXP 40
18437: PPUSH
18438: LD_STRING D1-JMM-3
18440: PPUSH
18441: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18445: LD_EXP 61
18449: PPUSH
18450: LD_STRING D1-Pow-3
18452: PPUSH
18453: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18457: LD_EXP 40
18461: PPUSH
18462: LD_STRING D1-JMM-4
18464: PPUSH
18465: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18469: LD_EXP 61
18473: PPUSH
18474: LD_STRING D1-Pow-4
18476: PPUSH
18477: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18481: LD_EXP 40
18485: PPUSH
18486: LD_STRING D1-JMM-5
18488: PPUSH
18489: CALL_OW 88
// async ;
18493: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18494: LD_EXP 61
18498: PPUSH
18499: LD_STRING D1-Pow-5
18501: PPUSH
18502: CALL_OW 88
// if not dialogue_skipped then
18506: LD_OWVAR 59
18510: NOT
18511: IFFALSE 18520
// wait ( 0 0$3.6 ) ;
18513: LD_INT 126
18515: PPUSH
18516: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18520: LD_INT 134
18522: PPUSH
18523: LD_INT 210
18525: PPUSH
18526: LD_INT 1
18528: PPUSH
18529: LD_INT 11
18531: NEG
18532: PPUSH
18533: CALL 107122 0 4
// if not dialogue_skipped then
18537: LD_OWVAR 59
18541: NOT
18542: IFFALSE 18561
// begin CenterOnXY ( 134 , 210 ) ;
18544: LD_INT 134
18546: PPUSH
18547: LD_INT 210
18549: PPUSH
18550: CALL_OW 84
// wait ( 0 0$2 ) ;
18554: LD_INT 70
18556: PPUSH
18557: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18561: LD_INT 101
18563: PPUSH
18564: LD_INT 159
18566: PPUSH
18567: LD_INT 1
18569: PPUSH
18570: LD_INT 10
18572: NEG
18573: PPUSH
18574: CALL 107122 0 4
// if not dialogue_skipped then
18578: LD_OWVAR 59
18582: NOT
18583: IFFALSE 18602
// begin CenterOnXY ( 101 , 159 ) ;
18585: LD_INT 101
18587: PPUSH
18588: LD_INT 159
18590: PPUSH
18591: CALL_OW 84
// wait ( 0 0$2 ) ;
18595: LD_INT 70
18597: PPUSH
18598: CALL_OW 67
// end ; sync ;
18602: SYNC
// CenterNowOnUnits ( Powell ) ;
18603: LD_EXP 61
18607: PPUSH
18608: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18612: LD_ADDR_VAR 0 6
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 2
18622: PUSH
18623: LD_INT 3
18625: PUSH
18626: LD_INT 4
18628: PUSH
18629: LD_INT 5
18631: PUSH
18632: LD_INT 6
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: LIST
18642: ST_TO_ADDR
// if not dialogue_skipped then
18643: LD_OWVAR 59
18647: NOT
18648: IFFALSE 18817
// begin game_speed := 4 ;
18650: LD_ADDR_OWVAR 65
18654: PUSH
18655: LD_INT 4
18657: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18658: LD_INT 210
18660: PPUSH
18661: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18665: LD_ADDR_VAR 0 7
18669: PUSH
18670: LD_STRING Q1
18672: PPUSH
18673: LD_VAR 0 6
18677: PPUSH
18678: CALL_OW 98
18682: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18683: LD_ADDR_VAR 0 7
18687: PUSH
18688: LD_STRING Q1
18690: PPUSH
18691: LD_VAR 0 6
18695: PPUSH
18696: CALL_OW 98
18700: ST_TO_ADDR
// options := options diff dec ;
18701: LD_ADDR_VAR 0 6
18705: PUSH
18706: LD_VAR 0 6
18710: PUSH
18711: LD_VAR 0 7
18715: DIFF
18716: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18717: LD_VAR 0 7
18721: PPUSH
18722: LD_VAR 0 6
18726: PPUSH
18727: CALL 20381 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18731: LD_VAR 0 7
18735: PUSH
18736: LD_INT 5
18738: PUSH
18739: LD_INT 6
18741: PUSH
18742: EMPTY
18743: LIST
18744: LIST
18745: IN
18746: PUSH
18747: LD_VAR 0 6
18751: PUSH
18752: LD_INT 2
18754: EQUAL
18755: OR
18756: IFFALSE 18683
// if not ( dec in [ 5 , 6 ] ) then
18758: LD_VAR 0 7
18762: PUSH
18763: LD_INT 5
18765: PUSH
18766: LD_INT 6
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: IN
18773: NOT
18774: IFFALSE 18817
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18776: LD_ADDR_VAR 0 7
18780: PUSH
18781: LD_STRING Q1a
18783: PPUSH
18784: LD_INT 1
18786: PUSH
18787: LD_INT 2
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: PPUSH
18794: CALL_OW 98
18798: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18799: LD_VAR 0 7
18803: PUSH
18804: LD_INT 4
18806: PLUS
18807: PPUSH
18808: LD_VAR 0 6
18812: PPUSH
18813: CALL 20381 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18817: LD_INT 81
18819: PPUSH
18820: LD_INT 127
18822: PPUSH
18823: CALL_OW 84
// amount := 8 ;
18827: LD_ADDR_VAR 0 8
18831: PUSH
18832: LD_INT 8
18834: ST_TO_ADDR
// macmilan_squad := [ ] ;
18835: LD_ADDR_VAR 0 9
18839: PUSH
18840: EMPTY
18841: ST_TO_ADDR
// if vip < amount then
18842: LD_EXP 62
18846: PUSH
18847: LD_VAR 0 8
18851: LESS
18852: IFFALSE 18896
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18854: LD_ADDR_VAR 0 5
18858: PUSH
18859: LD_EXP 62
18863: PUSH
18864: LD_INT 22
18866: PUSH
18867: LD_INT 4
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: PUSH
18874: LD_INT 21
18876: PUSH
18877: LD_INT 1
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PPUSH
18888: CALL_OW 69
18892: UNION
18893: ST_TO_ADDR
18894: GO 18906
// tmp := vip ;
18896: LD_ADDR_VAR 0 5
18900: PUSH
18901: LD_EXP 62
18905: ST_TO_ADDR
// tmp := tmp diff Powell ;
18906: LD_ADDR_VAR 0 5
18910: PUSH
18911: LD_VAR 0 5
18915: PUSH
18916: LD_EXP 61
18920: DIFF
18921: ST_TO_ADDR
// if tmp < amount then
18922: LD_VAR 0 5
18926: PUSH
18927: LD_VAR 0 8
18931: LESS
18932: IFFALSE 18944
// amount := tmp ;
18934: LD_ADDR_VAR 0 8
18938: PUSH
18939: LD_VAR 0 5
18943: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18944: LD_VAR 0 5
18948: PUSH
18949: LD_INT 1
18951: ARRAY
18952: PPUSH
18953: CALL_OW 257
18957: PUSH
18958: LD_INT 2
18960: NONEQUAL
18961: IFFALSE 19059
// begin if IsInUnit ( tmp [ 1 ] ) then
18963: LD_VAR 0 5
18967: PUSH
18968: LD_INT 1
18970: ARRAY
18971: PPUSH
18972: CALL_OW 310
18976: IFFALSE 18991
// ComExitBuilding ( tmp [ 1 ] ) ;
18978: LD_VAR 0 5
18982: PUSH
18983: LD_INT 1
18985: ARRAY
18986: PPUSH
18987: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18991: LD_INT 387
18993: PPUSH
18994: CALL_OW 313
18998: PUSH
18999: LD_INT 6
19001: EQUAL
19002: IFFALSE 19027
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19004: LD_INT 387
19006: PPUSH
19007: CALL_OW 313
19011: PUSH
19012: LD_INT 1
19014: ARRAY
19015: PPUSH
19016: CALL_OW 122
// wait ( 3 ) ;
19020: LD_INT 3
19022: PPUSH
19023: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19027: LD_VAR 0 5
19031: PUSH
19032: LD_INT 1
19034: ARRAY
19035: PPUSH
19036: LD_INT 387
19038: PPUSH
19039: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19043: LD_VAR 0 5
19047: PUSH
19048: LD_INT 1
19050: ARRAY
19051: PPUSH
19052: LD_INT 2
19054: PPUSH
19055: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19059: LD_EXP 40
19063: PPUSH
19064: LD_INT 82
19066: PPUSH
19067: LD_INT 129
19069: PPUSH
19070: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19074: LD_EXP 40
19078: PPUSH
19079: LD_EXP 61
19083: PPUSH
19084: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19088: LD_INT 22
19090: PUSH
19091: LD_INT 1
19093: PUSH
19094: EMPTY
19095: LIST
19096: LIST
19097: PPUSH
19098: CALL_OW 69
19102: PUSH
19103: LD_EXP 40
19107: DIFF
19108: PPUSH
19109: LD_INT 84
19111: PPUSH
19112: LD_INT 128
19114: PPUSH
19115: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19119: LD_INT 22
19121: PUSH
19122: LD_INT 1
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PPUSH
19129: CALL_OW 69
19133: PUSH
19134: LD_EXP 40
19138: DIFF
19139: PPUSH
19140: LD_EXP 40
19144: PPUSH
19145: CALL_OW 179
// for i = 1 to amount do
19149: LD_ADDR_VAR 0 2
19153: PUSH
19154: DOUBLE
19155: LD_INT 1
19157: DEC
19158: ST_TO_ADDR
19159: LD_VAR 0 8
19163: PUSH
19164: FOR_TO
19165: IFFALSE 19333
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19167: LD_ADDR_VAR 0 9
19171: PUSH
19172: LD_VAR 0 9
19176: PUSH
19177: LD_VAR 0 5
19181: PUSH
19182: LD_VAR 0 2
19186: ARRAY
19187: ADD
19188: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19189: LD_VAR 0 5
19193: PUSH
19194: LD_VAR 0 2
19198: ARRAY
19199: PPUSH
19200: CALL_OW 310
19204: IFFALSE 19221
// AddComExitBuilding ( tmp [ i ] ) ;
19206: LD_VAR 0 5
19210: PUSH
19211: LD_VAR 0 2
19215: ARRAY
19216: PPUSH
19217: CALL_OW 182
// if i = 2 and JMMNewVeh then
19221: LD_VAR 0 2
19225: PUSH
19226: LD_INT 2
19228: EQUAL
19229: PUSH
19230: LD_EXP 59
19234: AND
19235: IFFALSE 19293
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19237: LD_VAR 0 5
19241: PUSH
19242: LD_VAR 0 2
19246: ARRAY
19247: PPUSH
19248: LD_EXP 59
19252: PPUSH
19253: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19257: LD_VAR 0 5
19261: PUSH
19262: LD_VAR 0 2
19266: ARRAY
19267: PPUSH
19268: LD_INT 86
19270: PPUSH
19271: LD_INT 133
19273: PPUSH
19274: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19278: LD_VAR 0 5
19282: PUSH
19283: LD_VAR 0 2
19287: ARRAY
19288: PPUSH
19289: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19293: LD_VAR 0 5
19297: PUSH
19298: LD_VAR 0 2
19302: ARRAY
19303: PPUSH
19304: LD_INT 8
19306: PPUSH
19307: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19311: LD_VAR 0 5
19315: PUSH
19316: LD_VAR 0 2
19320: ARRAY
19321: PPUSH
19322: LD_EXP 40
19326: PPUSH
19327: CALL_OW 179
// end ;
19331: GO 19164
19333: POP
19334: POP
// if GirlNewVeh then
19335: LD_EXP 60
19339: IFFALSE 19353
// SetSide ( GirlNewVeh , 4 ) ;
19341: LD_EXP 60
19345: PPUSH
19346: LD_INT 4
19348: PPUSH
19349: CALL_OW 235
// if Mike then
19353: LD_EXP 57
19357: IFFALSE 19394
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19359: LD_ADDR_VAR 0 9
19363: PUSH
19364: LD_VAR 0 9
19368: PPUSH
19369: LD_EXP 57
19373: PPUSH
19374: CALL 107236 0 2
19378: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19379: LD_EXP 57
19383: PPUSH
19384: LD_INT 86
19386: PPUSH
19387: LD_INT 133
19389: PPUSH
19390: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19394: LD_INT 35
19396: PPUSH
19397: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19401: LD_VAR 0 9
19405: PPUSH
19406: LD_INT 95
19408: PUSH
19409: LD_INT 9
19411: PUSH
19412: EMPTY
19413: LIST
19414: LIST
19415: PPUSH
19416: CALL_OW 72
19420: PUSH
19421: LD_INT 0
19423: EQUAL
19424: PUSH
19425: LD_EXP 40
19429: PPUSH
19430: LD_INT 9
19432: PPUSH
19433: CALL_OW 308
19437: NOT
19438: AND
19439: IFFALSE 19394
// wait ( 0 0$2 ) ;
19441: LD_INT 70
19443: PPUSH
19444: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19448: LD_VAR 0 9
19452: PPUSH
19453: LD_INT 1
19455: PPUSH
19456: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19460: LD_INT 21
19462: PUSH
19463: LD_INT 2
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: PUSH
19470: LD_INT 92
19472: PUSH
19473: LD_INT 83
19475: PUSH
19476: LD_INT 130
19478: PUSH
19479: LD_INT 10
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: LIST
19486: LIST
19487: PUSH
19488: EMPTY
19489: LIST
19490: LIST
19491: PPUSH
19492: CALL_OW 69
19496: PPUSH
19497: LD_INT 1
19499: PPUSH
19500: CALL_OW 235
// tick := 0 ;
19504: LD_ADDR_OWVAR 1
19508: PUSH
19509: LD_INT 0
19511: ST_TO_ADDR
// Video ( false ) ;
19512: LD_INT 0
19514: PPUSH
19515: CALL 107208 0 1
// ChangeMissionObjectives ( M1 ) ;
19519: LD_STRING M1
19521: PPUSH
19522: CALL_OW 337
// SaveForQuickRestart ;
19526: CALL_OW 22
// missionStart := true ;
19530: LD_ADDR_EXP 13
19534: PUSH
19535: LD_INT 1
19537: ST_TO_ADDR
// missionStage := 2 ;
19538: LD_ADDR_EXP 15
19542: PUSH
19543: LD_INT 2
19545: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19546: LD_INT 35
19548: PPUSH
19549: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19553: LD_ADDR_VAR 0 5
19557: PUSH
19558: LD_INT 22
19560: PUSH
19561: LD_INT 4
19563: PUSH
19564: EMPTY
19565: LIST
19566: LIST
19567: PUSH
19568: LD_INT 21
19570: PUSH
19571: LD_INT 1
19573: PUSH
19574: EMPTY
19575: LIST
19576: LIST
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PPUSH
19582: CALL_OW 69
19586: PUSH
19587: LD_EXP 61
19591: DIFF
19592: ST_TO_ADDR
// if not tmp then
19593: LD_VAR 0 5
19597: NOT
19598: IFFALSE 19613
// tmp := [ Powell ] ;
19600: LD_ADDR_VAR 0 5
19604: PUSH
19605: LD_EXP 61
19609: PUSH
19610: EMPTY
19611: LIST
19612: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19613: LD_ADDR_VAR 0 4
19617: PUSH
19618: LD_INT 22
19620: PUSH
19621: LD_INT 4
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 34
19630: PUSH
19631: LD_INT 12
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: EMPTY
19639: LIST
19640: LIST
19641: PPUSH
19642: CALL_OW 69
19646: PUSH
19647: LD_INT 1
19649: ARRAY
19650: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19651: LD_VAR 0 5
19655: PUSH
19656: LD_INT 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 310
19664: IFFALSE 19679
// ComExitBuilding ( tmp [ 1 ] ) ;
19666: LD_VAR 0 5
19670: PUSH
19671: LD_INT 1
19673: ARRAY
19674: PPUSH
19675: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19679: LD_VAR 0 5
19683: PUSH
19684: LD_INT 1
19686: ARRAY
19687: PPUSH
19688: LD_VAR 0 4
19692: PPUSH
19693: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19697: LD_VAR 0 5
19701: PUSH
19702: LD_INT 1
19704: ARRAY
19705: PPUSH
19706: LD_INT 80
19708: PPUSH
19709: LD_INT 136
19711: PPUSH
19712: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19716: LD_VAR 0 5
19720: PUSH
19721: LD_INT 1
19723: ARRAY
19724: PPUSH
19725: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19729: LD_VAR 0 5
19733: PUSH
19734: LD_INT 1
19736: ARRAY
19737: PPUSH
19738: LD_INT 59
19740: PPUSH
19741: LD_INT 112
19743: PPUSH
19744: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19748: LD_VAR 0 5
19752: PUSH
19753: LD_INT 1
19755: ARRAY
19756: PPUSH
19757: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19761: LD_EXP 41
19765: PUSH
19766: LD_EXP 41
19770: PPUSH
19771: CALL_OW 255
19775: PUSH
19776: LD_INT 1
19778: EQUAL
19779: AND
19780: IFFALSE 19806
// begin Say ( Joan , D3W-Joan-1 ) ;
19782: LD_EXP 41
19786: PPUSH
19787: LD_STRING D3W-Joan-1
19789: PPUSH
19790: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19794: LD_EXP 40
19798: PPUSH
19799: LD_STRING D3W-JMM-1
19801: PPUSH
19802: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19806: LD_EXP 43
19810: PUSH
19811: LD_EXP 43
19815: PPUSH
19816: CALL_OW 255
19820: PUSH
19821: LD_INT 1
19823: EQUAL
19824: AND
19825: PUSH
19826: LD_EXP 43
19830: PUSH
19831: LD_EXP 62
19835: IN
19836: NOT
19837: AND
19838: IFFALSE 19864
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19840: LD_EXP 43
19844: PPUSH
19845: LD_STRING D3W-Lisa-1
19847: PPUSH
19848: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19852: LD_EXP 40
19856: PPUSH
19857: LD_STRING D3W-JMM-1
19859: PPUSH
19860: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19864: LD_EXP 55
19868: PUSH
19869: LD_EXP 55
19873: PPUSH
19874: CALL_OW 255
19878: PUSH
19879: LD_INT 1
19881: EQUAL
19882: AND
19883: IFFALSE 19909
// begin Say ( Connie , D3W-Con-1 ) ;
19885: LD_EXP 55
19889: PPUSH
19890: LD_STRING D3W-Con-1
19892: PPUSH
19893: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19897: LD_EXP 40
19901: PPUSH
19902: LD_STRING D3W-JMM-1
19904: PPUSH
19905: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19909: LD_INT 18
19911: PPUSH
19912: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19916: LD_EXP 43
19920: PUSH
19921: LD_EXP 62
19925: IN
19926: PUSH
19927: LD_EXP 43
19931: PPUSH
19932: CALL_OW 255
19936: PUSH
19937: LD_INT 1
19939: EQUAL
19940: AND
19941: IFFALSE 19957
// Say ( Lisa , D3nW-Lisa-1 ) else
19943: LD_EXP 43
19947: PPUSH
19948: LD_STRING D3nW-Lisa-1
19950: PPUSH
19951: CALL_OW 88
19955: GO 20201
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19957: LD_EXP 46
19961: PUSH
19962: LD_EXP 62
19966: IN
19967: PUSH
19968: LD_EXP 46
19972: PPUSH
19973: CALL_OW 255
19977: PUSH
19978: LD_INT 1
19980: EQUAL
19981: AND
19982: IFFALSE 19998
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19984: LD_EXP 46
19988: PPUSH
19989: LD_STRING D3nW-Cyrus-1
19991: PPUSH
19992: CALL_OW 88
19996: GO 20201
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19998: LD_EXP 45
20002: PUSH
20003: LD_EXP 62
20007: IN
20008: PUSH
20009: LD_EXP 45
20013: PPUSH
20014: CALL_OW 255
20018: PUSH
20019: LD_INT 1
20021: EQUAL
20022: AND
20023: IFFALSE 20039
// Say ( Bobby , D3nW-Bobby-1 ) else
20025: LD_EXP 45
20029: PPUSH
20030: LD_STRING D3nW-Bobby-1
20032: PPUSH
20033: CALL_OW 88
20037: GO 20201
// if Gary in vip and GetSide ( Gary ) = 1 then
20039: LD_EXP 52
20043: PUSH
20044: LD_EXP 62
20048: IN
20049: PUSH
20050: LD_EXP 52
20054: PPUSH
20055: CALL_OW 255
20059: PUSH
20060: LD_INT 1
20062: EQUAL
20063: AND
20064: IFFALSE 20080
// Say ( Gary , D3nW-Gary-1 ) else
20066: LD_EXP 52
20070: PPUSH
20071: LD_STRING D3nW-Gary-1
20073: PPUSH
20074: CALL_OW 88
20078: GO 20201
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20080: LD_EXP 44
20084: PUSH
20085: LD_EXP 62
20089: IN
20090: PUSH
20091: LD_EXP 44
20095: PPUSH
20096: CALL_OW 255
20100: PUSH
20101: LD_INT 1
20103: EQUAL
20104: AND
20105: IFFALSE 20121
// Say ( Donaldson , D3nW-Don-1 ) else
20107: LD_EXP 44
20111: PPUSH
20112: LD_STRING D3nW-Don-1
20114: PPUSH
20115: CALL_OW 88
20119: GO 20201
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20121: LD_EXP 51
20125: PUSH
20126: LD_EXP 62
20130: IN
20131: PUSH
20132: LD_EXP 51
20136: PPUSH
20137: CALL_OW 255
20141: PUSH
20142: LD_INT 1
20144: EQUAL
20145: AND
20146: IFFALSE 20162
// Say ( Cornel , D3nW-Corn-1 ) else
20148: LD_EXP 51
20152: PPUSH
20153: LD_STRING D3nW-Corn-1
20155: PPUSH
20156: CALL_OW 88
20160: GO 20201
// if Frank in vip and GetSide ( Frank ) = 1 then
20162: LD_EXP 53
20166: PUSH
20167: LD_EXP 62
20171: IN
20172: PUSH
20173: LD_EXP 53
20177: PPUSH
20178: CALL_OW 255
20182: PUSH
20183: LD_INT 1
20185: EQUAL
20186: AND
20187: IFFALSE 20201
// Say ( Frank , D3nW-Frank-1 ) ;
20189: LD_EXP 53
20193: PPUSH
20194: LD_STRING D3nW-Frank-1
20196: PPUSH
20197: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
20201: LD_EXP 62
20205: PPUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 1
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PPUSH
20216: CALL_OW 72
20220: IFFALSE 20246
// begin Say ( JMM , D3nW-JMM-1 ) ;
20222: LD_EXP 40
20226: PPUSH
20227: LD_STRING D3nW-JMM-1
20229: PPUSH
20230: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20234: LD_EXP 40
20238: PPUSH
20239: LD_STRING D3nW-JMM-1a
20241: PPUSH
20242: CALL_OW 88
// end ; t := 0 0$00 ;
20246: LD_ADDR_VAR 0 3
20250: PUSH
20251: LD_INT 0
20253: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20254: LD_INT 35
20256: PPUSH
20257: CALL_OW 67
// t := t + 0 0$1 ;
20261: LD_ADDR_VAR 0 3
20265: PUSH
20266: LD_VAR 0 3
20270: PUSH
20271: LD_INT 35
20273: PLUS
20274: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20275: LD_INT 59
20277: PPUSH
20278: LD_INT 112
20280: PPUSH
20281: CALL_OW 428
20285: PUSH
20286: LD_VAR 0 3
20290: PUSH
20291: LD_INT 2100
20293: GREATER
20294: OR
20295: IFFALSE 20254
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20297: LD_ADDR_EXP 102
20301: PUSH
20302: LD_EXP 102
20306: PPUSH
20307: LD_INT 4
20309: PPUSH
20310: LD_INT 22
20312: PUSH
20313: LD_INT 4
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: PUSH
20320: LD_INT 23
20322: PUSH
20323: LD_INT 1
20325: PUSH
20326: EMPTY
20327: LIST
20328: LIST
20329: PUSH
20330: LD_INT 3
20332: PUSH
20333: LD_INT 21
20335: PUSH
20336: LD_INT 2
20338: PUSH
20339: EMPTY
20340: LIST
20341: LIST
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: EMPTY
20348: LIST
20349: LIST
20350: LIST
20351: PPUSH
20352: CALL_OW 69
20356: PUSH
20357: LD_EXP 61
20361: DIFF
20362: PPUSH
20363: CALL_OW 1
20367: ST_TO_ADDR
// activeAttacks := true ;
20368: LD_ADDR_EXP 16
20372: PUSH
20373: LD_INT 1
20375: ST_TO_ADDR
// end ;
20376: LD_VAR 0 1
20380: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20381: LD_INT 0
20383: PPUSH
// case question of 1 :
20384: LD_VAR 0 1
20388: PUSH
20389: LD_INT 1
20391: DOUBLE
20392: EQUAL
20393: IFTRUE 20397
20395: GO 20448
20397: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20398: LD_EXP 40
20402: PPUSH
20403: LD_STRING D2Mot-JMM-1
20405: PPUSH
20406: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20410: LD_EXP 61
20414: PPUSH
20415: LD_STRING D2Mot-Pow-1
20417: PPUSH
20418: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20422: LD_EXP 40
20426: PPUSH
20427: LD_STRING D2Mot-JMM-2
20429: PPUSH
20430: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20434: LD_EXP 61
20438: PPUSH
20439: LD_STRING D2Mot-Pow-2
20441: PPUSH
20442: CALL_OW 88
// end ; 2 :
20446: GO 20799
20448: LD_INT 2
20450: DOUBLE
20451: EQUAL
20452: IFTRUE 20456
20454: GO 20532
20456: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20457: LD_EXP 40
20461: PPUSH
20462: LD_STRING D2Rus-JMM-1
20464: PPUSH
20465: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20469: LD_EXP 61
20473: PPUSH
20474: LD_STRING D2Rus-Pow-1
20476: PPUSH
20477: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20481: LD_EXP 40
20485: PPUSH
20486: LD_STRING D2Rus-JMM-2
20488: PPUSH
20489: CALL_OW 88
// if not ( 3 in list_of_q ) then
20493: LD_INT 3
20495: PUSH
20496: LD_VAR 0 2
20500: IN
20501: NOT
20502: IFFALSE 20518
// Say ( Powell , D2Rus-Pow-2 ) else
20504: LD_EXP 61
20508: PPUSH
20509: LD_STRING D2Rus-Pow-2
20511: PPUSH
20512: CALL_OW 88
20516: GO 20530
// Say ( Powell , D2Rus-Pow-2a ) ;
20518: LD_EXP 61
20522: PPUSH
20523: LD_STRING D2Rus-Pow-2a
20525: PPUSH
20526: CALL_OW 88
// end ; 3 :
20530: GO 20799
20532: LD_INT 3
20534: DOUBLE
20535: EQUAL
20536: IFTRUE 20540
20538: GO 20625
20540: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20541: LD_EXP 40
20545: PPUSH
20546: LD_STRING D2Leg-JMM-1
20548: PPUSH
20549: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20553: LD_EXP 61
20557: PPUSH
20558: LD_STRING D2Leg-Pow-1
20560: PPUSH
20561: CALL_OW 88
// if 2 in list_of_q then
20565: LD_INT 2
20567: PUSH
20568: LD_VAR 0 2
20572: IN
20573: IFFALSE 20599
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20575: LD_EXP 40
20579: PPUSH
20580: LD_STRING D2Leg-JMM-2
20582: PPUSH
20583: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20587: LD_EXP 61
20591: PPUSH
20592: LD_STRING D2Leg-Pow-2
20594: PPUSH
20595: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20599: LD_EXP 40
20603: PPUSH
20604: LD_STRING D2Leg-JMM-3
20606: PPUSH
20607: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20611: LD_EXP 61
20615: PPUSH
20616: LD_STRING D2Leg-Pow-3
20618: PPUSH
20619: CALL_OW 88
// end ; 4 :
20623: GO 20799
20625: LD_INT 4
20627: DOUBLE
20628: EQUAL
20629: IFTRUE 20633
20631: GO 20708
20633: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20634: LD_EXP 40
20638: PPUSH
20639: LD_STRING D2Ar-JMM-1
20641: PPUSH
20642: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20646: LD_EXP 61
20650: PPUSH
20651: LD_STRING D2Ar-Pow-1
20653: PPUSH
20654: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20658: LD_EXP 40
20662: PPUSH
20663: LD_STRING D2Ar-JMM-2
20665: PPUSH
20666: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20670: LD_EXP 61
20674: PPUSH
20675: LD_STRING D2Ar-Pow-2
20677: PPUSH
20678: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20682: LD_EXP 40
20686: PPUSH
20687: LD_STRING D2Ar-JMM-3
20689: PPUSH
20690: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20694: LD_EXP 61
20698: PPUSH
20699: LD_STRING D2Ar-Pow-3
20701: PPUSH
20702: CALL_OW 88
// end ; 5 :
20706: GO 20799
20708: LD_INT 5
20710: DOUBLE
20711: EQUAL
20712: IFTRUE 20716
20714: GO 20731
20716: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20717: LD_EXP 40
20721: PPUSH
20722: LD_STRING D2Conf-JMM-1
20724: PPUSH
20725: CALL_OW 88
20729: GO 20799
20731: LD_INT 6
20733: DOUBLE
20734: EQUAL
20735: IFTRUE 20739
20737: GO 20798
20739: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20740: LD_EXP 40
20744: PPUSH
20745: LD_STRING D2Com-JMM-1
20747: PPUSH
20748: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20752: LD_EXP 61
20756: PPUSH
20757: LD_STRING D2Com-Pow-1
20759: PPUSH
20760: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20764: LD_EXP 40
20768: PPUSH
20769: LD_STRING D2Com-JMM-2
20771: PPUSH
20772: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20776: LD_EXP 61
20780: PPUSH
20781: LD_STRING D2Com-Pow-2
20783: PPUSH
20784: CALL_OW 88
// powellAngerQuery := true ;
20788: LD_ADDR_EXP 36
20792: PUSH
20793: LD_INT 1
20795: ST_TO_ADDR
// end ; end ;
20796: GO 20799
20798: POP
// end ;
20799: LD_VAR 0 3
20803: RET
// every 0 0$5 trigger missionStart do var tmp ;
20804: LD_EXP 13
20808: IFFALSE 21133
20810: GO 20812
20812: DISABLE
20813: LD_INT 0
20815: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20816: LD_INT 35
20818: PPUSH
20819: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20823: LD_INT 14
20825: PPUSH
20826: LD_INT 22
20828: PUSH
20829: LD_INT 1
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PUSH
20836: LD_INT 3
20838: PUSH
20839: LD_INT 21
20841: PUSH
20842: LD_INT 3
20844: PUSH
20845: EMPTY
20846: LIST
20847: LIST
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: PPUSH
20857: CALL_OW 70
20861: PUSH
20862: LD_EXP 15
20866: PUSH
20867: LD_INT 2
20869: PUSH
20870: LD_INT 3
20872: PUSH
20873: LD_INT 4
20875: PUSH
20876: LD_INT 5
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: IN
20885: AND
20886: IFFALSE 21123
// begin powellAnger := powellAnger + 1 ;
20888: LD_ADDR_EXP 17
20892: PUSH
20893: LD_EXP 17
20897: PUSH
20898: LD_INT 1
20900: PLUS
20901: ST_TO_ADDR
// Video ( true ) ;
20902: LD_INT 1
20904: PPUSH
20905: CALL 107208 0 1
// CenterNowOnUnits ( tmp ) ;
20909: LD_VAR 0 1
20913: PPUSH
20914: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20918: LD_INT 14
20920: PPUSH
20921: LD_INT 22
20923: PUSH
20924: LD_INT 1
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: PPUSH
20931: CALL_OW 70
20935: PPUSH
20936: LD_INT 86
20938: PPUSH
20939: LD_INT 133
20941: PPUSH
20942: CALL_OW 111
// async ;
20946: ASYNC
// case powellAnger of 1 :
20947: LD_EXP 17
20951: PUSH
20952: LD_INT 1
20954: DOUBLE
20955: EQUAL
20956: IFTRUE 20960
20958: GO 20975
20960: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20961: LD_EXP 61
20965: PPUSH
20966: LD_STRING DBack1-Pow-1
20968: PPUSH
20969: CALL_OW 88
20973: GO 21022
20975: LD_INT 2
20977: DOUBLE
20978: EQUAL
20979: IFTRUE 20983
20981: GO 20998
20983: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20984: LD_EXP 61
20988: PPUSH
20989: LD_STRING DBack2-Pow-1
20991: PPUSH
20992: CALL_OW 88
20996: GO 21022
20998: LD_INT 3
21000: DOUBLE
21001: EQUAL
21002: IFTRUE 21006
21004: GO 21021
21006: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21007: LD_EXP 61
21011: PPUSH
21012: LD_STRING DBack3-Pow-1
21014: PPUSH
21015: CALL_OW 88
21019: GO 21022
21021: POP
// sync ;
21022: SYNC
// repeat wait ( 0 0$1 ) ;
21023: LD_INT 35
21025: PPUSH
21026: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21030: LD_INT 14
21032: PPUSH
21033: LD_INT 22
21035: PUSH
21036: LD_INT 1
21038: PUSH
21039: EMPTY
21040: LIST
21041: LIST
21042: PPUSH
21043: CALL_OW 70
21047: PPUSH
21048: LD_INT 86
21050: PPUSH
21051: LD_INT 133
21053: PPUSH
21054: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21058: LD_INT 14
21060: PPUSH
21061: LD_INT 22
21063: PUSH
21064: LD_INT 1
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: PUSH
21071: LD_INT 3
21073: PUSH
21074: LD_INT 21
21076: PUSH
21077: LD_INT 3
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: PUSH
21084: EMPTY
21085: LIST
21086: LIST
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: PPUSH
21092: CALL_OW 70
21096: NOT
21097: IFFALSE 21023
// if powellAnger >= 3 then
21099: LD_EXP 17
21103: PUSH
21104: LD_INT 3
21106: GREATEREQUAL
21107: IFFALSE 21116
// YouLost ( Dismissed ) ;
21109: LD_STRING Dismissed
21111: PPUSH
21112: CALL_OW 104
// Video ( false ) ;
21116: LD_INT 0
21118: PPUSH
21119: CALL 107208 0 1
// end ; until missionStage > 5 ;
21123: LD_EXP 15
21127: PUSH
21128: LD_INT 5
21130: GREATER
21131: IFFALSE 20816
// end ;
21133: PPOPN 1
21135: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21136: LD_EXP 13
21140: PUSH
21141: LD_INT 22
21143: PUSH
21144: LD_INT 4
21146: PUSH
21147: EMPTY
21148: LIST
21149: LIST
21150: PUSH
21151: LD_INT 21
21153: PUSH
21154: LD_INT 2
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: PUSH
21161: EMPTY
21162: LIST
21163: LIST
21164: PPUSH
21165: CALL_OW 69
21169: PUSH
21170: LD_INT 4
21172: GREATEREQUAL
21173: AND
21174: PUSH
21175: LD_EXP 15
21179: PUSH
21180: LD_INT 2
21182: EQUAL
21183: AND
21184: IFFALSE 23434
21186: GO 21188
21188: DISABLE
21189: LD_INT 0
21191: PPUSH
21192: PPUSH
21193: PPUSH
21194: PPUSH
21195: PPUSH
21196: PPUSH
21197: PPUSH
21198: PPUSH
21199: PPUSH
21200: PPUSH
21201: PPUSH
// begin missionStage := 3 ;
21202: LD_ADDR_EXP 15
21206: PUSH
21207: LD_INT 3
21209: ST_TO_ADDR
// retreat := false ;
21210: LD_ADDR_VAR 0 4
21214: PUSH
21215: LD_INT 0
21217: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21218: LD_ADDR_VAR 0 5
21222: PUSH
21223: LD_INT 22
21225: PUSH
21226: LD_INT 4
21228: PUSH
21229: EMPTY
21230: LIST
21231: LIST
21232: PUSH
21233: LD_INT 30
21235: PUSH
21236: LD_INT 4
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: PUSH
21243: EMPTY
21244: LIST
21245: LIST
21246: PPUSH
21247: CALL_OW 69
21251: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21252: LD_ADDR_VAR 0 6
21256: PUSH
21257: LD_INT 22
21259: PUSH
21260: LD_INT 4
21262: PUSH
21263: EMPTY
21264: LIST
21265: LIST
21266: PUSH
21267: LD_INT 30
21269: PUSH
21270: LD_INT 5
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PPUSH
21281: CALL_OW 69
21285: ST_TO_ADDR
// if not bar then
21286: LD_VAR 0 6
21290: NOT
21291: IFFALSE 21344
// begin repeat wait ( 0 0$1 ) ;
21293: LD_INT 35
21295: PPUSH
21296: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21300: LD_INT 22
21302: PUSH
21303: LD_INT 4
21305: PUSH
21306: EMPTY
21307: LIST
21308: LIST
21309: PUSH
21310: LD_INT 3
21312: PUSH
21313: LD_INT 57
21315: PUSH
21316: EMPTY
21317: LIST
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: PUSH
21323: LD_INT 30
21325: PUSH
21326: LD_INT 5
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: LIST
21337: PPUSH
21338: CALL_OW 69
21342: IFFALSE 21293
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21344: LD_ADDR_VAR 0 6
21348: PUSH
21349: LD_INT 22
21351: PUSH
21352: LD_INT 4
21354: PUSH
21355: EMPTY
21356: LIST
21357: LIST
21358: PUSH
21359: LD_INT 30
21361: PUSH
21362: LD_INT 5
21364: PUSH
21365: EMPTY
21366: LIST
21367: LIST
21368: PUSH
21369: EMPTY
21370: LIST
21371: LIST
21372: PPUSH
21373: CALL_OW 69
21377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21378: LD_INT 35
21380: PPUSH
21381: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21385: LD_EXP 121
21389: PUSH
21390: LD_INT 4
21392: ARRAY
21393: PUSH
21394: LD_INT 4
21396: GREATEREQUAL
21397: IFFALSE 21378
// tmp := [ ] ;
21399: LD_ADDR_VAR 0 2
21403: PUSH
21404: EMPTY
21405: ST_TO_ADDR
// tmp2 := [ ] ;
21406: LD_ADDR_VAR 0 3
21410: PUSH
21411: EMPTY
21412: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21413: LD_ADDR_VAR 0 1
21417: PUSH
21418: LD_INT 22
21420: PUSH
21421: LD_INT 4
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 2
21430: PUSH
21431: LD_INT 25
21433: PUSH
21434: LD_INT 1
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: PUSH
21441: LD_INT 25
21443: PUSH
21444: LD_INT 2
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: PUSH
21451: LD_INT 25
21453: PUSH
21454: LD_INT 3
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 25
21463: PUSH
21464: LD_INT 4
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 25
21473: PUSH
21474: LD_INT 5
21476: PUSH
21477: EMPTY
21478: LIST
21479: LIST
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: LIST
21487: LIST
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: PPUSH
21493: CALL_OW 69
21497: PUSH
21498: LD_EXP 61
21502: PUSH
21503: LD_EXP 62
21507: UNION
21508: DIFF
21509: PUSH
21510: FOR_IN
21511: IFFALSE 21573
// if not i in extraSquad then
21513: LD_VAR 0 1
21517: PUSH
21518: LD_EXP 63
21522: IN
21523: NOT
21524: IFFALSE 21548
// tmp := Join ( tmp , i ) else
21526: LD_ADDR_VAR 0 2
21530: PUSH
21531: LD_VAR 0 2
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: CALL 107236 0 2
21545: ST_TO_ADDR
21546: GO 21571
// tmp := Insert ( tmp , 1 , i ) ;
21548: LD_ADDR_VAR 0 2
21552: PUSH
21553: LD_VAR 0 2
21557: PPUSH
21558: LD_INT 1
21560: PPUSH
21561: LD_VAR 0 1
21565: PPUSH
21566: CALL_OW 2
21570: ST_TO_ADDR
21571: GO 21510
21573: POP
21574: POP
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21575: LD_ADDR_VAR 0 1
21579: PUSH
21580: LD_VAR 0 2
21584: PPUSH
21585: LD_INT 26
21587: PUSH
21588: LD_INT 1
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: PPUSH
21595: CALL_OW 72
21599: PUSH
21600: FOR_IN
21601: IFFALSE 21652
// begin p := Inc ( p ) ;
21603: LD_ADDR_VAR 0 11
21607: PUSH
21608: LD_VAR 0 11
21612: PPUSH
21613: CALL 108597 0 1
21617: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21618: LD_ADDR_VAR 0 3
21622: PUSH
21623: LD_VAR 0 3
21627: PPUSH
21628: LD_VAR 0 1
21632: PPUSH
21633: CALL 107236 0 2
21637: ST_TO_ADDR
// if p = 4 then
21638: LD_VAR 0 11
21642: PUSH
21643: LD_INT 4
21645: EQUAL
21646: IFFALSE 21650
// break ;
21648: GO 21652
// end ;
21650: GO 21600
21652: POP
21653: POP
// tmp := tmp diff tmp2 ;
21654: LD_ADDR_VAR 0 2
21658: PUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 3
21668: DIFF
21669: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21670: LD_ADDR_VAR 0 2
21674: PUSH
21675: LD_VAR 0 2
21679: PPUSH
21680: LD_INT 3
21682: PPUSH
21683: CALL 105740 0 2
21687: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21688: LD_ADDR_VAR 0 3
21692: PUSH
21693: LD_VAR 0 3
21697: PPUSH
21698: LD_INT 3
21700: PPUSH
21701: CALL 105740 0 2
21705: ST_TO_ADDR
// for i := 1 to 4 do
21706: LD_ADDR_VAR 0 1
21710: PUSH
21711: DOUBLE
21712: LD_INT 1
21714: DEC
21715: ST_TO_ADDR
21716: LD_INT 4
21718: PUSH
21719: FOR_TO
21720: IFFALSE 21873
// begin if tmp2 then
21722: LD_VAR 0 3
21726: IFFALSE 21794
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21728: LD_ADDR_EXP 18
21732: PUSH
21733: LD_EXP 18
21737: PPUSH
21738: LD_INT 1
21740: PPUSH
21741: LD_EXP 18
21745: PUSH
21746: LD_INT 1
21748: ARRAY
21749: PUSH
21750: LD_VAR 0 3
21754: PUSH
21755: LD_VAR 0 3
21759: ARRAY
21760: ADD
21761: PPUSH
21762: CALL_OW 1
21766: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21767: LD_VAR 0 3
21771: PUSH
21772: LD_VAR 0 3
21776: ARRAY
21777: PPUSH
21778: LD_INT 1
21780: PPUSH
21781: CALL_OW 109
// tmp2 := [ ] ;
21785: LD_ADDR_VAR 0 3
21789: PUSH
21790: EMPTY
21791: ST_TO_ADDR
// end else
21792: GO 21871
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21794: LD_ADDR_EXP 18
21798: PUSH
21799: LD_EXP 18
21803: PPUSH
21804: LD_INT 1
21806: PPUSH
21807: LD_EXP 18
21811: PUSH
21812: LD_INT 1
21814: ARRAY
21815: PUSH
21816: LD_VAR 0 2
21820: PUSH
21821: LD_VAR 0 2
21825: ARRAY
21826: ADD
21827: PPUSH
21828: CALL_OW 1
21832: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21833: LD_VAR 0 2
21837: PUSH
21838: LD_VAR 0 2
21842: ARRAY
21843: PPUSH
21844: LD_INT 1
21846: PPUSH
21847: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21851: LD_ADDR_VAR 0 2
21855: PUSH
21856: LD_VAR 0 2
21860: PPUSH
21861: LD_VAR 0 2
21865: PPUSH
21866: CALL_OW 3
21870: ST_TO_ADDR
// end ; end ;
21871: GO 21719
21873: POP
21874: POP
// if tmp2 then
21875: LD_VAR 0 3
21879: IFFALSE 21897
// tmp := tmp union tmp2 ;
21881: LD_ADDR_VAR 0 2
21885: PUSH
21886: LD_VAR 0 2
21890: PUSH
21891: LD_VAR 0 3
21895: UNION
21896: ST_TO_ADDR
// for i := 1 to 4 do
21897: LD_ADDR_VAR 0 1
21901: PUSH
21902: DOUBLE
21903: LD_INT 1
21905: DEC
21906: ST_TO_ADDR
21907: LD_INT 4
21909: PUSH
21910: FOR_TO
21911: IFFALSE 21960
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21913: LD_ADDR_EXP 18
21917: PUSH
21918: LD_EXP 18
21922: PPUSH
21923: LD_INT 2
21925: PPUSH
21926: LD_EXP 18
21930: PUSH
21931: LD_INT 2
21933: ARRAY
21934: PUSH
21935: LD_VAR 0 2
21939: PUSH
21940: LD_VAR 0 2
21944: PUSH
21945: LD_VAR 0 1
21949: MINUS
21950: ARRAY
21951: ADD
21952: PPUSH
21953: CALL_OW 1
21957: ST_TO_ADDR
21958: GO 21910
21960: POP
21961: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21962: LD_ADDR_EXP 102
21966: PUSH
21967: LD_EXP 102
21971: PPUSH
21972: LD_INT 4
21974: PPUSH
21975: LD_EXP 102
21979: PUSH
21980: LD_INT 4
21982: ARRAY
21983: PUSH
21984: LD_EXP 18
21988: PUSH
21989: LD_INT 1
21991: ARRAY
21992: DIFF
21993: PPUSH
21994: CALL_OW 1
21998: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21999: LD_VAR 0 5
22003: PUSH
22004: LD_INT 1
22006: ARRAY
22007: PPUSH
22008: CALL_OW 313
22012: IFFALSE 22067
// begin for i in UnitsInside ( arm [ 1 ] ) do
22014: LD_ADDR_VAR 0 1
22018: PUSH
22019: LD_VAR 0 5
22023: PUSH
22024: LD_INT 1
22026: ARRAY
22027: PPUSH
22028: CALL_OW 313
22032: PUSH
22033: FOR_IN
22034: IFFALSE 22065
// begin ComExitBuilding ( i ) ;
22036: LD_VAR 0 1
22040: PPUSH
22041: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22045: LD_VAR 0 1
22049: PPUSH
22050: LD_VAR 0 6
22054: PUSH
22055: LD_INT 1
22057: ARRAY
22058: PPUSH
22059: CALL_OW 180
// end ;
22063: GO 22033
22065: POP
22066: POP
// end ; wait ( 0 0$3 ) ;
22067: LD_INT 105
22069: PPUSH
22070: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22074: LD_ADDR_VAR 0 1
22078: PUSH
22079: LD_EXP 18
22083: PUSH
22084: LD_INT 1
22086: ARRAY
22087: PUSH
22088: FOR_IN
22089: IFFALSE 22196
// begin if IsInUnit ( i ) then
22091: LD_VAR 0 1
22095: PPUSH
22096: CALL_OW 310
22100: IFFALSE 22111
// ComExitBuilding ( i ) ;
22102: LD_VAR 0 1
22106: PPUSH
22107: CALL_OW 122
// if GetClass ( i ) <> 1 then
22111: LD_VAR 0 1
22115: PPUSH
22116: CALL_OW 257
22120: PUSH
22121: LD_INT 1
22123: NONEQUAL
22124: IFFALSE 22165
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22126: LD_VAR 0 1
22130: PPUSH
22131: LD_VAR 0 5
22135: PUSH
22136: LD_INT 1
22138: ARRAY
22139: PPUSH
22140: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22144: LD_VAR 0 1
22148: PPUSH
22149: LD_INT 1
22151: PPUSH
22152: CALL_OW 183
// AddComExitBuilding ( i ) ;
22156: LD_VAR 0 1
22160: PPUSH
22161: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22165: LD_VAR 0 1
22169: PPUSH
22170: LD_INT 60
22172: PPUSH
22173: LD_INT 94
22175: PPUSH
22176: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22180: LD_VAR 0 1
22184: PPUSH
22185: LD_EXP 61
22189: PPUSH
22190: CALL_OW 179
// end ;
22194: GO 22088
22196: POP
22197: POP
// wait ( 0 0$45 ) ;
22198: LD_INT 1575
22200: PPUSH
22201: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22205: LD_EXP 61
22209: PPUSH
22210: LD_STRING D4-Pow-1
22212: PPUSH
22213: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22217: LD_ADDR_VAR 0 2
22221: PUSH
22222: LD_EXP 18
22226: PUSH
22227: LD_INT 1
22229: ARRAY
22230: PPUSH
22231: LD_INT 26
22233: PUSH
22234: LD_INT 1
22236: PUSH
22237: EMPTY
22238: LIST
22239: LIST
22240: PPUSH
22241: CALL_OW 72
22245: ST_TO_ADDR
// if tmp then
22246: LD_VAR 0 2
22250: IFFALSE 22268
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22252: LD_VAR 0 2
22256: PUSH
22257: LD_INT 1
22259: ARRAY
22260: PPUSH
22261: LD_STRING D4-Sol1-1
22263: PPUSH
22264: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22268: LD_EXP 61
22272: PPUSH
22273: LD_STRING D4-Pow-2
22275: PPUSH
22276: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22280: LD_ADDR_VAR 0 1
22284: PUSH
22285: DOUBLE
22286: LD_INT 1
22288: DEC
22289: ST_TO_ADDR
22290: LD_EXP 18
22294: PUSH
22295: LD_INT 1
22297: ARRAY
22298: PUSH
22299: FOR_TO
22300: IFFALSE 22393
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22302: LD_EXP 18
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PUSH
22311: LD_VAR 0 1
22315: ARRAY
22316: PPUSH
22317: LD_EXP 121
22321: PUSH
22322: LD_INT 4
22324: ARRAY
22325: PUSH
22326: LD_INT 1
22328: ARRAY
22329: PPUSH
22330: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22334: LD_ADDR_EXP 121
22338: PUSH
22339: LD_EXP 121
22343: PPUSH
22344: LD_INT 4
22346: PPUSH
22347: LD_EXP 121
22351: PUSH
22352: LD_INT 4
22354: ARRAY
22355: PPUSH
22356: LD_INT 1
22358: PPUSH
22359: CALL_OW 3
22363: PPUSH
22364: CALL_OW 1
22368: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22369: LD_INT 8
22371: PPUSH
22372: LD_EXP 18
22376: PUSH
22377: LD_INT 1
22379: ARRAY
22380: PUSH
22381: LD_VAR 0 1
22385: ARRAY
22386: PPUSH
22387: CALL_OW 471
// end ;
22391: GO 22299
22393: POP
22394: POP
// repeat wait ( 0 0$1 ) ;
22395: LD_INT 35
22397: PPUSH
22398: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22402: LD_EXP 18
22406: PUSH
22407: LD_INT 1
22409: ARRAY
22410: PPUSH
22411: LD_INT 55
22413: PUSH
22414: EMPTY
22415: LIST
22416: PPUSH
22417: CALL_OW 72
22421: PUSH
22422: LD_INT 4
22424: GREATEREQUAL
22425: IFFALSE 22395
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22427: LD_EXP 18
22431: PUSH
22432: LD_INT 1
22434: ARRAY
22435: PPUSH
22436: LD_INT 69
22438: PPUSH
22439: LD_INT 94
22441: PPUSH
22442: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22446: LD_EXP 18
22450: PUSH
22451: LD_INT 1
22453: ARRAY
22454: PPUSH
22455: LD_INT 82
22457: PPUSH
22458: LD_INT 83
22460: PPUSH
22461: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22465: LD_EXP 18
22469: PUSH
22470: LD_INT 1
22472: ARRAY
22473: PPUSH
22474: LD_INT 77
22476: PPUSH
22477: LD_INT 69
22479: PPUSH
22480: CALL_OW 174
// repeat wait ( 3 ) ;
22484: LD_INT 3
22486: PPUSH
22487: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22491: LD_ADDR_VAR 0 1
22495: PUSH
22496: LD_EXP 18
22500: PUSH
22501: LD_INT 1
22503: ARRAY
22504: PUSH
22505: FOR_IN
22506: IFFALSE 22642
// begin if GetLives ( i ) < 990 then
22508: LD_VAR 0 1
22512: PPUSH
22513: CALL_OW 256
22517: PUSH
22518: LD_INT 990
22520: LESS
22521: IFFALSE 22535
// SetLives ( i , 1000 ) ;
22523: LD_VAR 0 1
22527: PPUSH
22528: LD_INT 1000
22530: PPUSH
22531: CALL_OW 234
// if not IsInUnit ( i ) then
22535: LD_VAR 0 1
22539: PPUSH
22540: CALL_OW 310
22544: NOT
22545: IFFALSE 22640
// begin if not HasTask ( i ) then
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL_OW 314
22556: NOT
22557: IFFALSE 22574
// ComMoveXY ( i , 64 , 93 ) ;
22559: LD_VAR 0 1
22563: PPUSH
22564: LD_INT 64
22566: PPUSH
22567: LD_INT 93
22569: PPUSH
22570: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22574: LD_VAR 0 4
22578: NOT
22579: PUSH
22580: LD_VAR 0 1
22584: PPUSH
22585: CALL_OW 258
22589: PUSH
22590: LD_INT 1
22592: EQUAL
22593: AND
22594: IFFALSE 22640
// begin retreat := true ;
22596: LD_ADDR_VAR 0 4
22600: PUSH
22601: LD_INT 1
22603: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22604: LD_VAR 0 1
22608: PPUSH
22609: LD_INT 2
22611: PPUSH
22612: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22616: LD_VAR 0 1
22620: PPUSH
22621: LD_STRING D4a-Sol1-1
22623: PPUSH
22624: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22628: LD_EXP 61
22632: PPUSH
22633: LD_STRING D4a-Pow-1
22635: PPUSH
22636: CALL_OW 88
// end ; end ; end ;
22640: GO 22505
22642: POP
22643: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22644: LD_EXP 18
22648: PUSH
22649: LD_INT 1
22651: ARRAY
22652: PPUSH
22653: LD_INT 95
22655: PUSH
22656: LD_INT 9
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 3
22665: PUSH
22666: LD_INT 55
22668: PUSH
22669: EMPTY
22670: LIST
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PPUSH
22680: CALL_OW 72
22684: PUSH
22685: LD_INT 4
22687: GREATEREQUAL
22688: IFFALSE 22484
// for i in powellSquadAttack [ 1 ] do
22690: LD_ADDR_VAR 0 1
22694: PUSH
22695: LD_EXP 18
22699: PUSH
22700: LD_INT 1
22702: ARRAY
22703: PUSH
22704: FOR_IN
22705: IFFALSE 22841
// begin if GetTag ( i ) = 2 then
22707: LD_VAR 0 1
22711: PPUSH
22712: CALL_OW 110
22716: PUSH
22717: LD_INT 2
22719: EQUAL
22720: IFFALSE 22782
// begin ComMoveXY ( i , 60 , 94 ) ;
22722: LD_VAR 0 1
22726: PPUSH
22727: LD_INT 60
22729: PPUSH
22730: LD_INT 94
22732: PPUSH
22733: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22737: LD_VAR 0 1
22741: PPUSH
22742: LD_EXP 61
22746: PPUSH
22747: CALL_OW 179
// wait ( 0 0$3 ) ;
22751: LD_INT 105
22753: PPUSH
22754: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22758: LD_VAR 0 1
22762: PPUSH
22763: LD_STRING D4a-Sol1-2
22765: PPUSH
22766: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22770: LD_EXP 61
22774: PPUSH
22775: LD_STRING D4a-Pow-2
22777: PPUSH
22778: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22782: LD_VAR 0 1
22786: PPUSH
22787: LD_INT 0
22789: PPUSH
22790: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22794: LD_ADDR_EXP 102
22798: PUSH
22799: LD_EXP 102
22803: PPUSH
22804: LD_INT 4
22806: PPUSH
22807: LD_EXP 102
22811: PUSH
22812: LD_INT 4
22814: ARRAY
22815: PUSH
22816: LD_VAR 0 1
22820: UNION
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22827: LD_INT 8
22829: PPUSH
22830: LD_VAR 0 1
22834: PPUSH
22835: CALL_OW 472
// end ;
22839: GO 22704
22841: POP
22842: POP
// wait ( 2 2$00 ) ;
22843: LD_INT 4200
22845: PPUSH
22846: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22850: LD_ADDR_VAR 0 9
22854: PUSH
22855: LD_INT 22
22857: PUSH
22858: LD_INT 4
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: LD_INT 30
22867: PUSH
22868: LD_INT 32
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: PUSH
22875: LD_INT 58
22877: PUSH
22878: EMPTY
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: LIST
22885: PPUSH
22886: CALL_OW 69
22890: ST_TO_ADDR
// if tmp then
22891: LD_VAR 0 2
22895: IFFALSE 23135
// begin for i := 1 to tmp do
22897: LD_ADDR_VAR 0 1
22901: PUSH
22902: DOUBLE
22903: LD_INT 1
22905: DEC
22906: ST_TO_ADDR
22907: LD_VAR 0 2
22911: PUSH
22912: FOR_TO
22913: IFFALSE 23126
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22915: LD_ADDR_EXP 102
22919: PUSH
22920: LD_EXP 102
22924: PPUSH
22925: LD_INT 4
22927: PPUSH
22928: LD_EXP 102
22932: PUSH
22933: LD_INT 4
22935: ARRAY
22936: PUSH
22937: LD_VAR 0 2
22941: PUSH
22942: LD_VAR 0 1
22946: ARRAY
22947: DIFF
22948: PPUSH
22949: CALL_OW 1
22953: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22954: LD_ADDR_VAR 0 10
22958: PUSH
22959: LD_VAR 0 2
22963: PUSH
22964: LD_VAR 0 1
22968: ARRAY
22969: PPUSH
22970: CALL_OW 310
22974: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22975: LD_VAR 0 10
22979: PUSH
22980: LD_VAR 0 10
22984: PPUSH
22985: CALL_OW 266
22989: PUSH
22990: LD_INT 32
22992: EQUAL
22993: AND
22994: IFFALSE 22998
// continue ;
22996: GO 22912
// if t then
22998: LD_VAR 0 10
23002: IFFALSE 23019
// ComExitBuilding ( tmp [ i ] ) ;
23004: LD_VAR 0 2
23008: PUSH
23009: LD_VAR 0 1
23013: ARRAY
23014: PPUSH
23015: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23019: LD_VAR 0 2
23023: PUSH
23024: LD_VAR 0 1
23028: ARRAY
23029: PPUSH
23030: LD_VAR 0 5
23034: PUSH
23035: LD_INT 1
23037: ARRAY
23038: PPUSH
23039: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23043: LD_VAR 0 2
23047: PUSH
23048: LD_VAR 0 1
23052: ARRAY
23053: PPUSH
23054: LD_INT 1
23056: PPUSH
23057: CALL_OW 183
// if emptyTowers then
23061: LD_VAR 0 9
23065: IFFALSE 23124
// begin AddComExitBuilding ( tmp [ i ] ) ;
23067: LD_VAR 0 2
23071: PUSH
23072: LD_VAR 0 1
23076: ARRAY
23077: PPUSH
23078: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23082: LD_VAR 0 2
23086: PUSH
23087: LD_VAR 0 1
23091: ARRAY
23092: PPUSH
23093: LD_VAR 0 9
23097: PUSH
23098: LD_INT 1
23100: ARRAY
23101: PPUSH
23102: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23106: LD_ADDR_VAR 0 9
23110: PUSH
23111: LD_VAR 0 9
23115: PPUSH
23116: LD_INT 1
23118: PPUSH
23119: CALL_OW 3
23123: ST_TO_ADDR
// end ; end ;
23124: GO 22912
23126: POP
23127: POP
// wait ( 0 0$30 ) ;
23128: LD_INT 1050
23130: PPUSH
23131: CALL_OW 67
// end ; uc_side := 6 ;
23135: LD_ADDR_OWVAR 20
23139: PUSH
23140: LD_INT 6
23142: ST_TO_ADDR
// uc_nation := 3 ;
23143: LD_ADDR_OWVAR 21
23147: PUSH
23148: LD_INT 3
23150: ST_TO_ADDR
// ru := [ ] ;
23151: LD_ADDR_VAR 0 7
23155: PUSH
23156: EMPTY
23157: ST_TO_ADDR
// for i = 1 to 5 do
23158: LD_ADDR_VAR 0 1
23162: PUSH
23163: DOUBLE
23164: LD_INT 1
23166: DEC
23167: ST_TO_ADDR
23168: LD_INT 5
23170: PUSH
23171: FOR_TO
23172: IFFALSE 23292
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23174: LD_INT 22
23176: PUSH
23177: LD_INT 23
23179: PUSH
23180: EMPTY
23181: LIST
23182: LIST
23183: PUSH
23184: LD_INT 1
23186: PPUSH
23187: LD_INT 2
23189: PPUSH
23190: CALL_OW 12
23194: ARRAY
23195: PPUSH
23196: LD_INT 1
23198: PPUSH
23199: LD_INT 3
23201: PPUSH
23202: LD_INT 43
23204: PUSH
23205: LD_INT 44
23207: PUSH
23208: EMPTY
23209: LIST
23210: LIST
23211: PUSH
23212: LD_INT 1
23214: PPUSH
23215: LD_INT 2
23217: PPUSH
23218: CALL_OW 12
23222: ARRAY
23223: PPUSH
23224: LD_INT 89
23226: PPUSH
23227: CALL 74385 0 5
// un := CreateVehicle ;
23231: LD_ADDR_VAR 0 8
23235: PUSH
23236: CALL_OW 45
23240: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23241: LD_VAR 0 8
23245: PPUSH
23246: LD_INT 4
23248: PPUSH
23249: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23253: LD_VAR 0 8
23257: PPUSH
23258: LD_INT 136
23260: PPUSH
23261: LD_INT 90
23263: PPUSH
23264: LD_INT 8
23266: PPUSH
23267: LD_INT 0
23269: PPUSH
23270: CALL_OW 50
// ru := ru ^ un ;
23274: LD_ADDR_VAR 0 7
23278: PUSH
23279: LD_VAR 0 7
23283: PUSH
23284: LD_VAR 0 8
23288: ADD
23289: ST_TO_ADDR
// end ;
23290: GO 23171
23292: POP
23293: POP
// if ru then
23294: LD_VAR 0 7
23298: IFFALSE 23315
// ComAgressiveMove ( ru , 57 , 94 ) ;
23300: LD_VAR 0 7
23304: PPUSH
23305: LD_INT 57
23307: PPUSH
23308: LD_INT 94
23310: PPUSH
23311: CALL_OW 114
// wait ( 3 3$00 ) ;
23315: LD_INT 6300
23317: PPUSH
23318: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23322: LD_INT 4
23324: PPUSH
23325: LD_INT 3
23327: PUSH
23328: LD_INT 1
23330: PUSH
23331: LD_INT 1
23333: PUSH
23334: LD_INT 5
23336: PUSH
23337: EMPTY
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: PUSH
23343: LD_INT 4
23345: PUSH
23346: LD_INT 1
23348: PUSH
23349: LD_INT 1
23351: PUSH
23352: LD_INT 6
23354: PUSH
23355: EMPTY
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 4
23363: PUSH
23364: LD_INT 1
23366: PUSH
23367: LD_INT 1
23369: PUSH
23370: LD_INT 7
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: LIST
23377: LIST
23378: PUSH
23379: LD_INT 3
23381: PUSH
23382: LD_INT 1
23384: PUSH
23385: LD_INT 1
23387: PUSH
23388: LD_INT 7
23390: PUSH
23391: EMPTY
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: PUSH
23397: LD_INT 3
23399: PUSH
23400: LD_INT 1
23402: PUSH
23403: LD_INT 1
23405: PUSH
23406: LD_INT 5
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: PUSH
23415: EMPTY
23416: LIST
23417: LIST
23418: LIST
23419: LIST
23420: LIST
23421: PPUSH
23422: CALL 63071 0 2
// missionStage := 4 ;
23426: LD_ADDR_EXP 15
23430: PUSH
23431: LD_INT 4
23433: ST_TO_ADDR
// end ;
23434: PPOPN 11
23436: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
23437: LD_EXP 15
23441: PUSH
23442: LD_INT 4
23444: EQUAL
23445: PUSH
23446: LD_INT 22
23448: PUSH
23449: LD_INT 4
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: PUSH
23456: LD_INT 21
23458: PUSH
23459: LD_INT 2
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PPUSH
23470: CALL_OW 69
23474: PUSH
23475: LD_INT 5
23477: GREATEREQUAL
23478: AND
23479: IFFALSE 27746
23481: GO 23483
23483: DISABLE
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
23494: PPUSH
23495: PPUSH
23496: PPUSH
23497: PPUSH
23498: PPUSH
// begin wait ( 0 0$10 ) ;
23499: LD_INT 350
23501: PPUSH
23502: CALL_OW 67
// missionStage := 5 ;
23506: LD_ADDR_EXP 15
23510: PUSH
23511: LD_INT 5
23513: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
23514: LD_ADDR_VAR 0 10
23518: PUSH
23519: LD_INT 22
23521: PUSH
23522: LD_INT 4
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: PUSH
23529: LD_INT 2
23531: PUSH
23532: LD_INT 30
23534: PUSH
23535: LD_INT 4
23537: PUSH
23538: EMPTY
23539: LIST
23540: LIST
23541: PUSH
23542: LD_INT 30
23544: PUSH
23545: LD_INT 5
23547: PUSH
23548: EMPTY
23549: LIST
23550: LIST
23551: PUSH
23552: EMPTY
23553: LIST
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PPUSH
23561: CALL_OW 69
23565: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23566: LD_ADDR_VAR 0 6
23570: PUSH
23571: LD_INT 22
23573: PUSH
23574: LD_INT 4
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: PUSH
23581: LD_INT 21
23583: PUSH
23584: LD_INT 1
23586: PUSH
23587: EMPTY
23588: LIST
23589: LIST
23590: PUSH
23591: LD_INT 3
23593: PUSH
23594: LD_INT 25
23596: PUSH
23597: LD_INT 16
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 3
23610: PUSH
23611: LD_INT 25
23613: PUSH
23614: LD_INT 12
23616: PUSH
23617: EMPTY
23618: LIST
23619: LIST
23620: PUSH
23621: EMPTY
23622: LIST
23623: LIST
23624: PUSH
23625: EMPTY
23626: LIST
23627: LIST
23628: LIST
23629: LIST
23630: PPUSH
23631: CALL_OW 69
23635: PUSH
23636: LD_EXP 61
23640: DIFF
23641: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23642: LD_ADDR_VAR 0 9
23646: PUSH
23647: LD_INT 22
23649: PUSH
23650: LD_INT 4
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 30
23659: PUSH
23660: LD_INT 3
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PPUSH
23671: CALL_OW 69
23675: PUSH
23676: LD_INT 1
23678: ARRAY
23679: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23680: LD_INT 350
23682: PPUSH
23683: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23687: LD_EXP 121
23691: PUSH
23692: LD_INT 4
23694: ARRAY
23695: PUSH
23696: LD_INT 5
23698: LESS
23699: PUSH
23700: LD_VAR 0 9
23704: PPUSH
23705: CALL_OW 461
23709: PUSH
23710: LD_INT 2
23712: EQUAL
23713: AND
23714: IFFALSE 23744
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23716: LD_INT 4
23718: PPUSH
23719: LD_INT 3
23721: PUSH
23722: LD_INT 1
23724: PUSH
23725: LD_INT 1
23727: PUSH
23728: LD_INT 5
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: PUSH
23737: EMPTY
23738: LIST
23739: PPUSH
23740: CALL 63119 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23744: LD_EXP 121
23748: PUSH
23749: LD_INT 4
23751: ARRAY
23752: PUSH
23753: LD_INT 5
23755: GREATEREQUAL
23756: PUSH
23757: LD_EXP 121
23761: PUSH
23762: LD_INT 4
23764: ARRAY
23765: PPUSH
23766: LD_INT 58
23768: PUSH
23769: EMPTY
23770: LIST
23771: PPUSH
23772: CALL_OW 72
23776: PUSH
23777: LD_INT 5
23779: GREATEREQUAL
23780: AND
23781: IFFALSE 23680
// powellAllowRetreat := false ;
23783: LD_ADDR_EXP 19
23787: PUSH
23788: LD_INT 0
23790: ST_TO_ADDR
// activeAttacks := false ;
23791: LD_ADDR_EXP 16
23795: PUSH
23796: LD_INT 0
23798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23799: LD_INT 35
23801: PPUSH
23802: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23806: LD_INT 22
23808: PUSH
23809: LD_INT 6
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: PPUSH
23816: CALL_OW 69
23820: PUSH
23821: LD_INT 0
23823: EQUAL
23824: IFFALSE 23799
// tmp := mc_vehicles [ 4 ] ;
23826: LD_ADDR_VAR 0 3
23830: PUSH
23831: LD_EXP 121
23835: PUSH
23836: LD_INT 4
23838: ARRAY
23839: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23840: LD_ADDR_VAR 0 1
23844: PUSH
23845: DOUBLE
23846: LD_INT 1
23848: DEC
23849: ST_TO_ADDR
23850: LD_EXP 18
23854: PUSH
23855: FOR_TO
23856: IFFALSE 24117
// begin for j in powellSquadAttack [ i ] do
23858: LD_ADDR_VAR 0 2
23862: PUSH
23863: LD_EXP 18
23867: PUSH
23868: LD_VAR 0 1
23872: ARRAY
23873: PUSH
23874: FOR_IN
23875: IFFALSE 24113
// begin forces := forces diff j ;
23877: LD_ADDR_VAR 0 6
23881: PUSH
23882: LD_VAR 0 6
23886: PUSH
23887: LD_VAR 0 2
23891: DIFF
23892: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23893: LD_VAR 0 2
23897: PPUSH
23898: LD_INT 1
23900: PPUSH
23901: CALL_OW 109
// wait ( 0 0$2 ) ;
23905: LD_INT 70
23907: PPUSH
23908: CALL_OW 67
// if IsInUnit ( j ) then
23912: LD_VAR 0 2
23916: PPUSH
23917: CALL_OW 310
23921: IFFALSE 23932
// ComExitBuilding ( j ) ;
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 122
// if GetClass ( j ) <> 1 then
23932: LD_VAR 0 2
23936: PPUSH
23937: CALL_OW 257
23941: PUSH
23942: LD_INT 1
23944: NONEQUAL
23945: IFFALSE 24025
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23947: LD_VAR 0 10
23951: PUSH
23952: LD_INT 1
23954: ARRAY
23955: PPUSH
23956: CALL_OW 313
23960: PUSH
23961: LD_INT 5
23963: GREATEREQUAL
23964: IFFALSE 23986
// AddComEnterUnit ( j , arm [ 2 ] ) else
23966: LD_VAR 0 2
23970: PPUSH
23971: LD_VAR 0 10
23975: PUSH
23976: LD_INT 2
23978: ARRAY
23979: PPUSH
23980: CALL_OW 180
23984: GO 24004
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23986: LD_VAR 0 2
23990: PPUSH
23991: LD_VAR 0 10
23995: PUSH
23996: LD_INT 1
23998: ARRAY
23999: PPUSH
24000: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
24004: LD_VAR 0 2
24008: PPUSH
24009: LD_INT 1
24011: PPUSH
24012: CALL_OW 183
// AddComExitBuilding ( j ) ;
24016: LD_VAR 0 2
24020: PPUSH
24021: CALL_OW 182
// end ; if i = 2 then
24025: LD_VAR 0 1
24029: PUSH
24030: LD_INT 2
24032: EQUAL
24033: IFFALSE 24050
// AddComMoveXY ( j , 61 , 93 ) ;
24035: LD_VAR 0 2
24039: PPUSH
24040: LD_INT 61
24042: PPUSH
24043: LD_INT 93
24045: PPUSH
24046: CALL_OW 171
// if i = 1 then
24050: LD_VAR 0 1
24054: PUSH
24055: LD_INT 1
24057: EQUAL
24058: IFFALSE 24111
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24060: LD_VAR 0 2
24064: PPUSH
24065: LD_VAR 0 3
24069: PUSH
24070: LD_INT 1
24072: ARRAY
24073: PPUSH
24074: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24078: LD_ADDR_VAR 0 3
24082: PUSH
24083: LD_VAR 0 3
24087: PPUSH
24088: LD_INT 1
24090: PPUSH
24091: CALL_OW 3
24095: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24096: LD_VAR 0 2
24100: PPUSH
24101: LD_INT 69
24103: PPUSH
24104: LD_INT 94
24106: PPUSH
24107: CALL_OW 171
// end ; end ;
24111: GO 23874
24113: POP
24114: POP
// end ;
24115: GO 23855
24117: POP
24118: POP
// wait ( 0 0$30 ) ;
24119: LD_INT 1050
24121: PPUSH
24122: CALL_OW 67
// MC_Kill ( 4 ) ;
24126: LD_INT 4
24128: PPUSH
24129: CALL 39094 0 1
// tmp := UnitsInside ( fac ) ;
24133: LD_ADDR_VAR 0 3
24137: PUSH
24138: LD_VAR 0 9
24142: PPUSH
24143: CALL_OW 313
24147: ST_TO_ADDR
// if tmp then
24148: LD_VAR 0 3
24152: IFFALSE 24273
// for i in tmp do
24154: LD_ADDR_VAR 0 1
24158: PUSH
24159: LD_VAR 0 3
24163: PUSH
24164: FOR_IN
24165: IFFALSE 24271
// begin ComExitBuilding ( i ) ;
24167: LD_VAR 0 1
24171: PPUSH
24172: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24176: LD_VAR 0 10
24180: PUSH
24181: LD_INT 2
24183: ARRAY
24184: PPUSH
24185: CALL_OW 313
24189: PUSH
24190: LD_INT 6
24192: LESS
24193: IFFALSE 24215
// AddComEnterUnit ( i , arm [ 2 ] ) else
24195: LD_VAR 0 1
24199: PPUSH
24200: LD_VAR 0 10
24204: PUSH
24205: LD_INT 2
24207: ARRAY
24208: PPUSH
24209: CALL_OW 180
24213: GO 24269
// if UnitsInside ( arm [ 1 ] ) < 6 then
24215: LD_VAR 0 10
24219: PUSH
24220: LD_INT 1
24222: ARRAY
24223: PPUSH
24224: CALL_OW 313
24228: PUSH
24229: LD_INT 6
24231: LESS
24232: IFFALSE 24254
// AddComEnterUnit ( i , arm [ 1 ] ) else
24234: LD_VAR 0 1
24238: PPUSH
24239: LD_VAR 0 10
24243: PUSH
24244: LD_INT 1
24246: ARRAY
24247: PPUSH
24248: CALL_OW 180
24252: GO 24269
// AddComMoveXY ( i , 37 , 68 ) ;
24254: LD_VAR 0 1
24258: PPUSH
24259: LD_INT 37
24261: PPUSH
24262: LD_INT 68
24264: PPUSH
24265: CALL_OW 171
// end ;
24269: GO 24164
24271: POP
24272: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
24273: LD_ADDR_VAR 0 11
24277: PUSH
24278: LD_VAR 0 6
24282: PPUSH
24283: LD_INT 26
24285: PUSH
24286: LD_INT 1
24288: PUSH
24289: EMPTY
24290: LIST
24291: LIST
24292: PPUSH
24293: CALL_OW 72
24297: PUSH
24298: LD_EXP 62
24302: DIFF
24303: ST_TO_ADDR
// if not speaker then
24304: LD_VAR 0 11
24308: NOT
24309: IFFALSE 24336
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 6
24320: PPUSH
24321: LD_INT 26
24323: PUSH
24324: LD_INT 1
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PPUSH
24331: CALL_OW 72
24335: ST_TO_ADDR
// if speaker then
24336: LD_VAR 0 11
24340: IFFALSE 24356
// speaker := speaker [ 1 ] ;
24342: LD_ADDR_VAR 0 11
24346: PUSH
24347: LD_VAR 0 11
24351: PUSH
24352: LD_INT 1
24354: ARRAY
24355: ST_TO_ADDR
// Video ( true ) ;
24356: LD_INT 1
24358: PPUSH
24359: CALL 107208 0 1
// CenterNowOnUnits ( Powell ) ;
24363: LD_EXP 61
24367: PPUSH
24368: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
24372: LD_ADDR_VAR 0 3
24376: PUSH
24377: LD_VAR 0 6
24381: PPUSH
24382: LD_INT 3
24384: PUSH
24385: LD_INT 25
24387: PUSH
24388: LD_INT 1
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PUSH
24395: EMPTY
24396: LIST
24397: LIST
24398: PPUSH
24399: CALL_OW 72
24403: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
24404: LD_ADDR_VAR 0 12
24408: PUSH
24409: LD_INT 22
24411: PUSH
24412: LD_INT 4
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: PUSH
24419: LD_INT 30
24421: PUSH
24422: LD_INT 32
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 58
24431: PUSH
24432: EMPTY
24433: LIST
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: LIST
24439: PPUSH
24440: CALL_OW 69
24444: ST_TO_ADDR
// for i := 1 to 4 do
24445: LD_ADDR_VAR 0 1
24449: PUSH
24450: DOUBLE
24451: LD_INT 1
24453: DEC
24454: ST_TO_ADDR
24455: LD_INT 4
24457: PUSH
24458: FOR_TO
24459: IFFALSE 24605
// begin if IsInUnit ( tmp [ i ] ) then
24461: LD_VAR 0 3
24465: PUSH
24466: LD_VAR 0 1
24470: ARRAY
24471: PPUSH
24472: CALL_OW 310
24476: IFFALSE 24493
// ComExitBuilding ( tmp [ i ] ) ;
24478: LD_VAR 0 3
24482: PUSH
24483: LD_VAR 0 1
24487: ARRAY
24488: PPUSH
24489: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
24493: LD_VAR 0 3
24497: PUSH
24498: LD_VAR 0 1
24502: ARRAY
24503: PPUSH
24504: LD_VAR 0 10
24508: PUSH
24509: LD_INT 1
24511: ARRAY
24512: PPUSH
24513: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
24517: LD_VAR 0 3
24521: PUSH
24522: LD_VAR 0 1
24526: ARRAY
24527: PPUSH
24528: LD_INT 1
24530: PPUSH
24531: CALL_OW 183
// if Count ( emp_towers ) then
24535: LD_VAR 0 12
24539: PPUSH
24540: CALL 71647 0 1
24544: IFFALSE 24603
// begin AddComExitBuilding ( tmp [ i ] ) ;
24546: LD_VAR 0 3
24550: PUSH
24551: LD_VAR 0 1
24555: ARRAY
24556: PPUSH
24557: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24561: LD_VAR 0 3
24565: PUSH
24566: LD_VAR 0 1
24570: ARRAY
24571: PPUSH
24572: LD_VAR 0 12
24576: PUSH
24577: LD_INT 1
24579: ARRAY
24580: PPUSH
24581: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24585: LD_ADDR_VAR 0 12
24589: PUSH
24590: LD_VAR 0 12
24594: PPUSH
24595: LD_INT 1
24597: PPUSH
24598: CALL_OW 3
24602: ST_TO_ADDR
// end ; end ;
24603: GO 24458
24605: POP
24606: POP
// wait ( 0 0$5 ) ;
24607: LD_INT 175
24609: PPUSH
24610: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24614: LD_VAR 0 3
24618: PPUSH
24619: LD_INT 3
24621: PUSH
24622: LD_INT 54
24624: PUSH
24625: EMPTY
24626: LIST
24627: PUSH
24628: EMPTY
24629: LIST
24630: LIST
24631: PPUSH
24632: CALL_OW 72
24636: IFFALSE 24656
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24638: LD_VAR 0 3
24642: PPUSH
24643: LD_VAR 0 10
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: PPUSH
24652: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24656: LD_ADDR_VAR 0 3
24660: PUSH
24661: LD_EXP 18
24665: PUSH
24666: LD_INT 1
24668: ARRAY
24669: PUSH
24670: LD_EXP 18
24674: PUSH
24675: LD_INT 2
24677: ARRAY
24678: ADD
24679: PPUSH
24680: LD_INT 26
24682: PUSH
24683: LD_INT 1
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PPUSH
24690: CALL_OW 72
24694: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24695: LD_ADDR_VAR 0 1
24699: PUSH
24700: LD_EXP 18
24704: PUSH
24705: LD_INT 2
24707: ARRAY
24708: PUSH
24709: FOR_IN
24710: IFFALSE 24728
// ComTurnUnit ( i , Powell ) ;
24712: LD_VAR 0 1
24716: PPUSH
24717: LD_EXP 61
24721: PPUSH
24722: CALL_OW 119
24726: GO 24709
24728: POP
24729: POP
// Say ( Powell , D5-Pow-1 ) ;
24730: LD_EXP 61
24734: PPUSH
24735: LD_STRING D5-Pow-1
24737: PPUSH
24738: CALL_OW 88
// if tmp then
24742: LD_VAR 0 3
24746: IFFALSE 24764
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24748: LD_VAR 0 3
24752: PUSH
24753: LD_INT 1
24755: ARRAY
24756: PPUSH
24757: LD_STRING D5-Sol2-1
24759: PPUSH
24760: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24764: LD_EXP 61
24768: PPUSH
24769: LD_STRING D5-Pow-2
24771: PPUSH
24772: CALL_OW 88
// if tmp > 1 then
24776: LD_VAR 0 3
24780: PUSH
24781: LD_INT 1
24783: GREATER
24784: IFFALSE 24802
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24786: LD_VAR 0 3
24790: PUSH
24791: LD_INT 2
24793: ARRAY
24794: PPUSH
24795: LD_STRING D5-Sol2-2
24797: PPUSH
24798: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24802: LD_EXP 61
24806: PPUSH
24807: LD_STRING D5-Pow-3
24809: PPUSH
24810: CALL_OW 88
// wait ( 0 0$1 ) ;
24814: LD_INT 35
24816: PPUSH
24817: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24821: LD_ADDR_VAR 0 3
24825: PUSH
24826: LD_EXP 18
24830: PUSH
24831: LD_INT 1
24833: ARRAY
24834: PUSH
24835: LD_EXP 18
24839: PUSH
24840: LD_INT 2
24842: ARRAY
24843: UNION
24844: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24845: LD_VAR 0 3
24849: PPUSH
24850: LD_INT 80
24852: PPUSH
24853: LD_INT 67
24855: PPUSH
24856: CALL_OW 114
// wait ( 0 0$2 ) ;
24860: LD_INT 70
24862: PPUSH
24863: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24867: LD_INT 79
24869: PPUSH
24870: LD_INT 72
24872: PPUSH
24873: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24877: LD_INT 70
24879: PPUSH
24880: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24884: LD_VAR 0 3
24888: PPUSH
24889: LD_INT 3
24891: PUSH
24892: LD_INT 24
24894: PUSH
24895: LD_INT 1000
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PPUSH
24906: CALL_OW 72
24910: IFFALSE 24877
// Say ( Powell , D5a-Pow-1 ) ;
24912: LD_EXP 61
24916: PPUSH
24917: LD_STRING D5a-Pow-1
24919: PPUSH
24920: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24924: LD_EXP 61
24928: PPUSH
24929: LD_STRING D5a-Pow-1a
24931: PPUSH
24932: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24936: LD_INT 24
24938: PPUSH
24939: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24943: LD_EXP 61
24947: PPUSH
24948: LD_STRING D5a-Pow-1b
24950: PPUSH
24951: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24955: LD_INT 10
24957: PPUSH
24958: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24962: LD_EXP 61
24966: PPUSH
24967: LD_STRING D5a-Pow-1c
24969: PPUSH
24970: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24974: LD_VAR 0 3
24978: PPUSH
24979: LD_INT 68
24981: PPUSH
24982: LD_INT 63
24984: PPUSH
24985: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24989: LD_INT 18
24991: PPUSH
24992: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24996: LD_EXP 61
25000: PPUSH
25001: LD_STRING D5a-Pow-1d
25003: PPUSH
25004: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25008: LD_INT 35
25010: PPUSH
25011: CALL_OW 67
// if not HasTask ( tmp ) then
25015: LD_VAR 0 3
25019: PPUSH
25020: CALL_OW 314
25024: NOT
25025: IFFALSE 25042
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25027: LD_VAR 0 3
25031: PPUSH
25032: LD_INT 68
25034: PPUSH
25035: LD_INT 63
25037: PPUSH
25038: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25042: LD_VAR 0 3
25046: PPUSH
25047: LD_INT 24
25049: PUSH
25050: LD_INT 1
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: PPUSH
25057: CALL_OW 72
25061: NOT
25062: IFFALSE 25008
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25064: LD_ADDR_VAR 0 3
25068: PUSH
25069: LD_INT 22
25071: PUSH
25072: LD_INT 4
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: LD_INT 92
25081: PUSH
25082: LD_INT 60
25084: PUSH
25085: LD_INT 93
25087: PUSH
25088: LD_INT 10
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: LIST
25095: LIST
25096: PUSH
25097: LD_INT 3
25099: PUSH
25100: LD_INT 54
25102: PUSH
25103: EMPTY
25104: LIST
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: EMPTY
25111: LIST
25112: LIST
25113: LIST
25114: PPUSH
25115: CALL_OW 69
25119: PUSH
25120: LD_EXP 61
25124: DIFF
25125: ST_TO_ADDR
// if tmp then
25126: LD_VAR 0 3
25130: IFFALSE 25164
// for i in tmp do
25132: LD_ADDR_VAR 0 1
25136: PUSH
25137: LD_VAR 0 3
25141: PUSH
25142: FOR_IN
25143: IFFALSE 25162
// ComMoveXY ( i , 36 , 67 ) ;
25145: LD_VAR 0 1
25149: PPUSH
25150: LD_INT 36
25152: PPUSH
25153: LD_INT 67
25155: PPUSH
25156: CALL_OW 111
25160: GO 25142
25162: POP
25163: POP
// wait ( 0 0$3 ) ;
25164: LD_INT 105
25166: PPUSH
25167: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25171: LD_VAR 0 11
25175: PPUSH
25176: LD_STRING D6-Sol3-1
25178: PPUSH
25179: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25183: LD_EXP 61
25187: PPUSH
25188: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25192: LD_EXP 61
25196: PPUSH
25197: LD_STRING D6-Pow-1
25199: PPUSH
25200: CALL_OW 88
// tmp := [ ] ;
25204: LD_ADDR_VAR 0 3
25208: PUSH
25209: EMPTY
25210: ST_TO_ADDR
// for i = 1 to 2 do
25211: LD_ADDR_VAR 0 1
25215: PUSH
25216: DOUBLE
25217: LD_INT 1
25219: DEC
25220: ST_TO_ADDR
25221: LD_INT 2
25223: PUSH
25224: FOR_TO
25225: IFFALSE 25339
// begin uc_side := 8 ;
25227: LD_ADDR_OWVAR 20
25231: PUSH
25232: LD_INT 8
25234: ST_TO_ADDR
// uc_nation := 2 ;
25235: LD_ADDR_OWVAR 21
25239: PUSH
25240: LD_INT 2
25242: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
25243: LD_INT 14
25245: PPUSH
25246: LD_INT 3
25248: PPUSH
25249: LD_INT 2
25251: PPUSH
25252: LD_INT 29
25254: PPUSH
25255: LD_INT 100
25257: PPUSH
25258: CALL 74385 0 5
// veh := CreateVehicle ;
25262: LD_ADDR_VAR 0 13
25266: PUSH
25267: CALL_OW 45
25271: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
25272: LD_VAR 0 13
25276: PPUSH
25277: LD_INT 4
25279: PPUSH
25280: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
25284: LD_VAR 0 13
25288: PPUSH
25289: LD_INT 99
25291: PPUSH
25292: LD_INT 83
25294: PPUSH
25295: LD_INT 3
25297: PPUSH
25298: LD_INT 0
25300: PPUSH
25301: CALL_OW 50
// wait ( 3 ) ;
25305: LD_INT 3
25307: PPUSH
25308: CALL_OW 67
// Connect ( veh ) ;
25312: LD_VAR 0 13
25316: PPUSH
25317: CALL 77853 0 1
// tmp := tmp ^ veh ;
25321: LD_ADDR_VAR 0 3
25325: PUSH
25326: LD_VAR 0 3
25330: PUSH
25331: LD_VAR 0 13
25335: ADD
25336: ST_TO_ADDR
// end ;
25337: GO 25224
25339: POP
25340: POP
// wait ( 0 0$1 ) ;
25341: LD_INT 35
25343: PPUSH
25344: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
25348: LD_INT 99
25350: PPUSH
25351: LD_INT 83
25353: PPUSH
25354: LD_INT 1
25356: PPUSH
25357: LD_INT 10
25359: PPUSH
25360: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
25364: LD_INT 99
25366: PPUSH
25367: LD_INT 83
25369: PPUSH
25370: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
25374: LD_VAR 0 11
25378: PPUSH
25379: LD_STRING D6-Sol3-2
25381: PPUSH
25382: CALL_OW 88
// async ;
25386: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
25387: LD_EXP 61
25391: PPUSH
25392: LD_STRING D6-Pow-2
25394: PPUSH
25395: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
25399: LD_VAR 0 3
25403: PUSH
25404: LD_INT 1
25406: ARRAY
25407: PPUSH
25408: LD_VAR 0 9
25412: PPUSH
25413: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
25417: LD_VAR 0 3
25421: PUSH
25422: LD_INT 2
25424: ARRAY
25425: PPUSH
25426: LD_INT 22
25428: PUSH
25429: LD_INT 4
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 21
25438: PUSH
25439: LD_INT 3
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: PPUSH
25450: CALL_OW 69
25454: PPUSH
25455: LD_VAR 0 3
25459: PUSH
25460: LD_INT 2
25462: ARRAY
25463: PPUSH
25464: CALL_OW 74
25468: PPUSH
25469: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
25473: LD_EXP 61
25477: PPUSH
25478: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
25482: LD_INT 99
25484: PPUSH
25485: LD_INT 83
25487: PPUSH
25488: LD_INT 1
25490: PPUSH
25491: CALL_OW 331
// repeat wait ( 4 ) ;
25495: LD_INT 4
25497: PPUSH
25498: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
25502: LD_VAR 0 3
25506: PUSH
25507: LD_INT 1
25509: ARRAY
25510: PPUSH
25511: CALL_OW 256
25515: PUSH
25516: LD_INT 1000
25518: LESS
25519: IFFALSE 25537
// SetLives ( tmp [ 1 ] , 1000 ) ;
25521: LD_VAR 0 3
25525: PUSH
25526: LD_INT 1
25528: ARRAY
25529: PPUSH
25530: LD_INT 1000
25532: PPUSH
25533: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
25537: LD_INT 22
25539: PUSH
25540: LD_INT 4
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 30
25549: PUSH
25550: LD_INT 3
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PPUSH
25561: CALL_OW 69
25565: PUSH
25566: LD_INT 0
25568: EQUAL
25569: IFFALSE 25495
// skirmish := false ;
25571: LD_ADDR_EXP 100
25575: PUSH
25576: LD_INT 0
25578: ST_TO_ADDR
// sync ;
25579: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25580: LD_EXP 61
25584: PPUSH
25585: LD_STRING D6a-Pow-1
25587: PPUSH
25588: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25592: LD_VAR 0 11
25596: PPUSH
25597: LD_STRING D6a-Sol3-1
25599: PPUSH
25600: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25604: LD_EXP 61
25608: PPUSH
25609: LD_STRING D6a-Pow-2
25611: PPUSH
25612: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25616: LD_VAR 0 11
25620: PPUSH
25621: LD_STRING D6a-Sol3-2
25623: PPUSH
25624: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25628: LD_EXP 61
25632: PPUSH
25633: LD_STRING D6a-Pow-3
25635: PPUSH
25636: CALL_OW 88
// powellCenterCameraMode := true ;
25640: LD_ADDR_EXP 20
25644: PUSH
25645: LD_INT 1
25647: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25648: LD_ADDR_VAR 0 1
25652: PUSH
25653: LD_INT 22
25655: PUSH
25656: LD_INT 8
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 25
25665: PUSH
25666: LD_INT 2
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: PPUSH
25677: CALL_OW 69
25681: PUSH
25682: FOR_IN
25683: IFFALSE 25738
// begin SetTag ( i , 1 ) ;
25685: LD_VAR 0 1
25689: PPUSH
25690: LD_INT 1
25692: PPUSH
25693: CALL_OW 109
// ComExitBuilding ( i ) ;
25697: LD_VAR 0 1
25701: PPUSH
25702: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25706: LD_VAR 0 1
25710: PPUSH
25711: LD_INT 35
25713: PPUSH
25714: LD_INT 6
25716: PPUSH
25717: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25721: LD_VAR 0 1
25725: PPUSH
25726: LD_INT 53
25728: PPUSH
25729: LD_INT 4
25731: PPUSH
25732: CALL_OW 171
// end ;
25736: GO 25682
25738: POP
25739: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25740: LD_ADDR_VAR 0 3
25744: PUSH
25745: LD_INT 22
25747: PUSH
25748: LD_INT 4
25750: PUSH
25751: EMPTY
25752: LIST
25753: LIST
25754: PUSH
25755: LD_INT 21
25757: PUSH
25758: LD_INT 2
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: PUSH
25765: LD_INT 3
25767: PUSH
25768: LD_INT 34
25770: PUSH
25771: LD_INT 12
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: LIST
25786: PPUSH
25787: CALL_OW 69
25791: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25792: LD_EXP 61
25796: PPUSH
25797: LD_VAR 0 3
25801: PPUSH
25802: LD_EXP 61
25806: PPUSH
25807: CALL_OW 74
25811: PPUSH
25812: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25816: LD_EXP 61
25820: PPUSH
25821: LD_INT 100
25823: PPUSH
25824: LD_INT 88
25826: PPUSH
25827: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25831: LD_EXP 61
25835: PPUSH
25836: LD_INT 100
25838: PPUSH
25839: LD_INT 75
25841: PPUSH
25842: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25846: LD_EXP 61
25850: PPUSH
25851: LD_INT 88
25853: PPUSH
25854: LD_INT 53
25856: PPUSH
25857: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25861: LD_INT 8
25863: PPUSH
25864: LD_EXP 61
25868: PPUSH
25869: CALL_OW 471
// repeat wait ( 3 ) ;
25873: LD_INT 3
25875: PPUSH
25876: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25880: LD_INT 22
25882: PUSH
25883: LD_INT 4
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 92
25892: PUSH
25893: LD_INT 100
25895: PUSH
25896: LD_INT 75
25898: PUSH
25899: LD_INT 6
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PPUSH
25912: CALL_OW 69
25916: IFFALSE 25873
// async ;
25918: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25919: LD_EXP 61
25923: PPUSH
25924: LD_STRING D6b-Pow-1
25926: PPUSH
25927: CALL_OW 88
// repeat wait ( 3 ) ;
25931: LD_INT 3
25933: PPUSH
25934: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25938: LD_EXP 61
25942: PPUSH
25943: CALL_OW 310
25947: PPUSH
25948: CALL_OW 256
25952: PUSH
25953: LD_INT 1000
25955: LESS
25956: IFFALSE 25975
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25958: LD_EXP 61
25962: PPUSH
25963: CALL_OW 310
25967: PPUSH
25968: LD_INT 1000
25970: PPUSH
25971: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25975: LD_EXP 61
25979: PPUSH
25980: CALL_OW 256
25984: PUSH
25985: LD_INT 1000
25987: LESS
25988: IFFALSE 26002
// SetLives ( Powell , 1000 ) ;
25990: LD_EXP 61
25994: PPUSH
25995: LD_INT 1000
25997: PPUSH
25998: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26002: LD_EXP 61
26006: PPUSH
26007: LD_EXP 67
26011: PPUSH
26012: CALL_OW 296
26016: PUSH
26017: LD_INT 5
26019: LESS
26020: PUSH
26021: LD_EXP 61
26025: PPUSH
26026: CALL_OW 310
26030: PPUSH
26031: LD_EXP 67
26035: PPUSH
26036: CALL_OW 296
26040: PUSH
26041: LD_INT 5
26043: LESS
26044: OR
26045: IFFALSE 26064
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26047: LD_EXP 61
26051: PPUSH
26052: CALL_OW 310
26056: PPUSH
26057: LD_INT 100
26059: PPUSH
26060: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26064: LD_EXP 61
26068: PPUSH
26069: CALL_OW 310
26073: NOT
26074: IFFALSE 25931
// DoNotAttack ( 8 , powellBomb ) ;
26076: LD_INT 8
26078: PPUSH
26079: LD_EXP 67
26083: PPUSH
26084: CALL_OW 471
// game_speed := 4 ;
26088: LD_ADDR_OWVAR 65
26092: PUSH
26093: LD_INT 4
26095: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26096: LD_EXP 61
26100: PPUSH
26101: LD_STRING D6b-Pow-1a
26103: PPUSH
26104: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26108: LD_EXP 61
26112: PPUSH
26113: LD_EXP 67
26117: PPUSH
26118: CALL_OW 180
// sync ;
26122: SYNC
// repeat wait ( 0 0$1 ) ;
26123: LD_INT 35
26125: PPUSH
26126: CALL_OW 67
// until IsInUnit ( Powell ) ;
26130: LD_EXP 61
26134: PPUSH
26135: CALL_OW 310
26139: IFFALSE 26123
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26141: LD_INT 8
26143: PPUSH
26144: LD_EXP 61
26148: PPUSH
26149: CALL_OW 310
26153: PPUSH
26154: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26158: LD_EXP 61
26162: PPUSH
26163: LD_INT 91
26165: PPUSH
26166: LD_INT 44
26168: PPUSH
26169: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26173: LD_EXP 61
26177: PPUSH
26178: LD_INT 96
26180: PPUSH
26181: LD_INT 44
26183: PPUSH
26184: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26188: LD_EXP 61
26192: PPUSH
26193: LD_INT 96
26195: PPUSH
26196: LD_INT 41
26198: PPUSH
26199: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26203: LD_EXP 61
26207: PPUSH
26208: LD_INT 92
26210: PPUSH
26211: LD_INT 39
26213: PPUSH
26214: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26218: LD_EXP 61
26222: PPUSH
26223: LD_INT 88
26225: PPUSH
26226: LD_INT 41
26228: PPUSH
26229: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26233: LD_EXP 61
26237: PPUSH
26238: LD_INT 91
26240: PPUSH
26241: LD_INT 44
26243: PPUSH
26244: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26248: LD_EXP 61
26252: PPUSH
26253: LD_INT 96
26255: PPUSH
26256: LD_INT 44
26258: PPUSH
26259: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26263: LD_EXP 61
26267: PPUSH
26268: LD_INT 96
26270: PPUSH
26271: LD_INT 41
26273: PPUSH
26274: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
26278: LD_EXP 61
26282: PPUSH
26283: LD_INT 92
26285: PPUSH
26286: LD_INT 39
26288: PPUSH
26289: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
26293: LD_EXP 61
26297: PPUSH
26298: LD_INT 88
26300: PPUSH
26301: LD_INT 41
26303: PPUSH
26304: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
26308: LD_EXP 61
26312: PPUSH
26313: LD_INT 91
26315: PPUSH
26316: LD_INT 44
26318: PPUSH
26319: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
26323: LD_EXP 61
26327: PPUSH
26328: LD_INT 93
26330: PPUSH
26331: LD_INT 39
26333: PPUSH
26334: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
26338: LD_EXP 61
26342: PPUSH
26343: LD_INT 93
26345: PPUSH
26346: LD_INT 36
26348: PPUSH
26349: CALL_OW 171
// wait ( 0 0$3.5 ) ;
26353: LD_INT 122
26355: PPUSH
26356: CALL_OW 67
// game_speed := 4 ;
26360: LD_ADDR_OWVAR 65
26364: PUSH
26365: LD_INT 4
26367: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
26368: LD_EXP 61
26372: PPUSH
26373: LD_STRING D6b-Pow-1b
26375: PPUSH
26376: CALL_OW 88
// tmp := [ ] ;
26380: LD_ADDR_VAR 0 3
26384: PUSH
26385: EMPTY
26386: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
26387: LD_ADDR_VAR 0 5
26391: PUSH
26392: LD_INT 78
26394: PUSH
26395: LD_INT 47
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: LD_INT 106
26404: PUSH
26405: LD_INT 53
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
26416: LD_ADDR_VAR 0 1
26420: PUSH
26421: LD_INT 22
26423: PUSH
26424: LD_INT 8
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 21
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: LD_INT 92
26443: PUSH
26444: LD_INT 90
26446: PUSH
26447: LD_INT 52
26449: PUSH
26450: LD_INT 12
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: LIST
26457: LIST
26458: PUSH
26459: EMPTY
26460: LIST
26461: LIST
26462: LIST
26463: PPUSH
26464: CALL_OW 69
26468: PUSH
26469: FOR_IN
26470: IFFALSE 26495
// tmp := tmp ^ UnitsInside ( i ) ;
26472: LD_ADDR_VAR 0 3
26476: PUSH
26477: LD_VAR 0 3
26481: PUSH
26482: LD_VAR 0 1
26486: PPUSH
26487: CALL_OW 313
26491: ADD
26492: ST_TO_ADDR
26493: GO 26469
26495: POP
26496: POP
// for i in tmp do
26497: LD_ADDR_VAR 0 1
26501: PUSH
26502: LD_VAR 0 3
26506: PUSH
26507: FOR_IN
26508: IFFALSE 26670
// begin dist := 9999 ;
26510: LD_ADDR_VAR 0 8
26514: PUSH
26515: LD_INT 9999
26517: ST_TO_ADDR
// _xy := [ ] ;
26518: LD_ADDR_VAR 0 7
26522: PUSH
26523: EMPTY
26524: ST_TO_ADDR
// SetTag ( i , 1 ) ;
26525: LD_VAR 0 1
26529: PPUSH
26530: LD_INT 1
26532: PPUSH
26533: CALL_OW 109
// ComExitBuilding ( i ) ;
26537: LD_VAR 0 1
26541: PPUSH
26542: CALL_OW 122
// for j in xy do
26546: LD_ADDR_VAR 0 2
26550: PUSH
26551: LD_VAR 0 5
26555: PUSH
26556: FOR_IN
26557: IFFALSE 26639
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26559: LD_VAR 0 1
26563: PPUSH
26564: LD_VAR 0 2
26568: PUSH
26569: LD_INT 1
26571: ARRAY
26572: PPUSH
26573: LD_VAR 0 2
26577: PUSH
26578: LD_INT 2
26580: ARRAY
26581: PPUSH
26582: CALL_OW 297
26586: PUSH
26587: LD_VAR 0 8
26591: LESS
26592: IFFALSE 26637
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26594: LD_ADDR_VAR 0 8
26598: PUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: LD_VAR 0 2
26608: PUSH
26609: LD_INT 1
26611: ARRAY
26612: PPUSH
26613: LD_VAR 0 2
26617: PUSH
26618: LD_INT 2
26620: ARRAY
26621: PPUSH
26622: CALL_OW 297
26626: ST_TO_ADDR
// _xy := j ;
26627: LD_ADDR_VAR 0 7
26631: PUSH
26632: LD_VAR 0 2
26636: ST_TO_ADDR
// end ;
26637: GO 26556
26639: POP
26640: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26641: LD_VAR 0 1
26645: PPUSH
26646: LD_VAR 0 7
26650: PUSH
26651: LD_INT 1
26653: ARRAY
26654: PPUSH
26655: LD_VAR 0 7
26659: PUSH
26660: LD_INT 2
26662: ARRAY
26663: PPUSH
26664: CALL_OW 171
// end ;
26668: GO 26507
26670: POP
26671: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26672: LD_ADDR_VAR 0 4
26676: PUSH
26677: LD_VAR 0 3
26681: PPUSH
26682: LD_INT 26
26684: PUSH
26685: LD_INT 1
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 25
26694: PUSH
26695: LD_INT 1
26697: PUSH
26698: EMPTY
26699: LIST
26700: LIST
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL_OW 72
26710: ST_TO_ADDR
// if tmp2 < 2 then
26711: LD_VAR 0 4
26715: PUSH
26716: LD_INT 2
26718: LESS
26719: IFFALSE 26788
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26721: LD_ADDR_VAR 0 4
26725: PUSH
26726: LD_INT 22
26728: PUSH
26729: LD_INT 8
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 26
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 3
26748: PUSH
26749: LD_INT 25
26751: PUSH
26752: LD_INT 15
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: LIST
26767: PPUSH
26768: CALL_OW 69
26772: PUSH
26773: LD_EXP 64
26777: PUSH
26778: LD_EXP 65
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: DIFF
26787: ST_TO_ADDR
// if tmp2 then
26788: LD_VAR 0 4
26792: IFFALSE 26810
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26794: LD_VAR 0 4
26798: PUSH
26799: LD_INT 1
26801: ARRAY
26802: PPUSH
26803: LD_STRING D6b-ArSol1-1
26805: PPUSH
26806: CALL_OW 88
// async ;
26810: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26811: LD_EXP 61
26815: PPUSH
26816: LD_STRING D6b-Pow-2
26818: PPUSH
26819: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26823: LD_INT 18
26825: PPUSH
26826: CALL_OW 67
// if tmp2 > 1 then
26830: LD_VAR 0 4
26834: PUSH
26835: LD_INT 1
26837: GREATER
26838: IFFALSE 26856
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26840: LD_VAR 0 4
26844: PUSH
26845: LD_INT 2
26847: ARRAY
26848: PPUSH
26849: LD_STRING D6b-ArSol2-1
26851: PPUSH
26852: CALL_OW 88
// sync ;
26856: SYNC
// repeat wait ( 5 ) ;
26857: LD_INT 5
26859: PPUSH
26860: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26864: LD_INT 93
26866: PPUSH
26867: LD_INT 36
26869: PPUSH
26870: CALL_OW 428
26874: PPUSH
26875: CALL_OW 255
26879: PUSH
26880: LD_INT 4
26882: EQUAL
26883: IFFALSE 26857
// DialogueOn ;
26885: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26889: LD_INT 10
26891: PPUSH
26892: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26896: LD_EXP 61
26900: PPUSH
26901: LD_STRING D6b-Pow-2a
26903: PPUSH
26904: CALL_OW 88
// DialogueOff ;
26908: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26912: LD_EXP 61
26916: PPUSH
26917: CALL_OW 310
26921: PPUSH
26922: LD_INT 332
26924: PPUSH
26925: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26929: LD_INT 93
26931: PPUSH
26932: LD_INT 35
26934: PPUSH
26935: LD_INT 1
26937: PPUSH
26938: LD_INT 6
26940: NEG
26941: PPUSH
26942: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26946: LD_INT 35
26948: PPUSH
26949: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26953: LD_INT 332
26955: PPUSH
26956: CALL_OW 256
26960: PUSH
26961: LD_INT 1000
26963: LESS
26964: PUSH
26965: LD_INT 332
26967: PPUSH
26968: CALL_OW 300
26972: AND
26973: IFFALSE 26985
// SetLives ( kozlov_fac , 0 ) ;
26975: LD_INT 332
26977: PPUSH
26978: LD_INT 0
26980: PPUSH
26981: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26985: LD_INT 332
26987: PPUSH
26988: CALL_OW 301
26992: PUSH
26993: LD_EXP 61
26997: PPUSH
26998: CALL_OW 301
27002: OR
27003: IFFALSE 26946
// game_speed := 4 ;
27005: LD_ADDR_OWVAR 65
27009: PUSH
27010: LD_INT 4
27012: ST_TO_ADDR
// powellCenterCameraMode := false ;
27013: LD_ADDR_EXP 20
27017: PUSH
27018: LD_INT 0
27020: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27021: LD_ADDR_VAR 0 1
27025: PUSH
27026: LD_VAR 0 3
27030: PUSH
27031: LD_INT 22
27033: PUSH
27034: LD_INT 8
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: LD_INT 25
27043: PUSH
27044: LD_INT 2
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PPUSH
27055: CALL_OW 69
27059: UNION
27060: PUSH
27061: FOR_IN
27062: IFFALSE 27078
// SetTag ( i , 0 ) ;
27064: LD_VAR 0 1
27068: PPUSH
27069: LD_INT 0
27071: PPUSH
27072: CALL_OW 109
27076: GO 27061
27078: POP
27079: POP
// wait ( 0 0$3 ) ;
27080: LD_INT 105
27082: PPUSH
27083: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27087: LD_INT 93
27089: PPUSH
27090: LD_INT 35
27092: PPUSH
27093: LD_INT 1
27095: PPUSH
27096: CALL_OW 331
// DialogueOn ;
27100: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27104: LD_VAR 0 11
27108: PPUSH
27109: LD_STRING D6c-Sol3-1
27111: PPUSH
27112: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27116: LD_INT 10
27118: PPUSH
27119: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27123: LD_EXP 40
27127: PPUSH
27128: LD_STRING D6c-JMM-1
27130: PPUSH
27131: CALL_OW 88
// if Cyrus then
27135: LD_EXP 46
27139: IFFALSE 27153
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27141: LD_EXP 46
27145: PPUSH
27146: LD_STRING D6c-Cyrus-1
27148: PPUSH
27149: CALL_OW 88
// if Bobby then
27153: LD_EXP 45
27157: IFFALSE 27171
// Say ( Bobby , D6c-Bobby-1 ) ;
27159: LD_EXP 45
27163: PPUSH
27164: LD_STRING D6c-Bobby-1
27166: PPUSH
27167: CALL_OW 88
// if Cornel then
27171: LD_EXP 51
27175: IFFALSE 27189
// Say ( Cornel , D6c-Corn-1 ) ;
27177: LD_EXP 51
27181: PPUSH
27182: LD_STRING D6c-Corn-1
27184: PPUSH
27185: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27189: LD_ADDR_VAR 0 4
27193: PUSH
27194: LD_INT 2
27196: PUSH
27197: LD_INT 22
27199: PUSH
27200: LD_INT 1
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 22
27209: PUSH
27210: LD_INT 4
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 26
27224: PUSH
27225: LD_INT 1
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 23
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: LIST
27246: PPUSH
27247: CALL_OW 69
27251: PUSH
27252: LD_VAR 0 11
27256: PUSH
27257: LD_EXP 40
27261: UNION
27262: PUSH
27263: LD_EXP 62
27267: UNION
27268: DIFF
27269: ST_TO_ADDR
// if tmp2 then
27270: LD_VAR 0 4
27274: IFFALSE 27292
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
27276: LD_VAR 0 4
27280: PUSH
27281: LD_INT 1
27283: ARRAY
27284: PPUSH
27285: LD_STRING D6c-Sol1-1
27287: PPUSH
27288: CALL_OW 88
// if Lisa then
27292: LD_EXP 43
27296: IFFALSE 27310
// Say ( Lisa , D6c-Lisa-1 ) ;
27298: LD_EXP 43
27302: PPUSH
27303: LD_STRING D6c-Lisa-1
27305: PPUSH
27306: CALL_OW 88
// if Gary then
27310: LD_EXP 52
27314: IFFALSE 27328
// Say ( Gary , D6c-Gary-1 ) ;
27316: LD_EXP 52
27320: PPUSH
27321: LD_STRING D6c-Gary-1
27323: PPUSH
27324: CALL_OW 88
// if Donaldson then
27328: LD_EXP 44
27332: IFFALSE 27346
// Say ( Donaldson , D6c-Don-1 ) ;
27334: LD_EXP 44
27338: PPUSH
27339: LD_STRING D6c-Don-1
27341: PPUSH
27342: CALL_OW 88
// if tmp2 > 1 then
27346: LD_VAR 0 4
27350: PUSH
27351: LD_INT 1
27353: GREATER
27354: IFFALSE 27372
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
27356: LD_VAR 0 4
27360: PUSH
27361: LD_INT 2
27363: ARRAY
27364: PPUSH
27365: LD_STRING D6c-Sol2-1
27367: PPUSH
27368: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
27372: LD_VAR 0 11
27376: PPUSH
27377: LD_STRING D6c-Sol3-2
27379: PPUSH
27380: CALL_OW 88
// if IsInUnit ( JMM ) then
27384: LD_EXP 40
27388: PPUSH
27389: CALL_OW 310
27393: IFFALSE 27411
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
27395: LD_EXP 40
27399: PPUSH
27400: CALL_OW 310
27404: PPUSH
27405: CALL_OW 87
27409: GO 27420
// CenterNowOnUnits ( JMM ) ;
27411: LD_EXP 40
27415: PPUSH
27416: CALL_OW 87
// dwait ( 0 0$2 ) ;
27420: LD_INT 70
27422: PPUSH
27423: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
27427: LD_EXP 40
27431: PPUSH
27432: LD_STRING D6c-JMM-2
27434: PPUSH
27435: CALL_OW 88
// DialogueOff ;
27439: CALL_OW 7
// Video ( false ) ;
27443: LD_INT 0
27445: PPUSH
27446: CALL 107208 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
27450: LD_INT 22
27452: PUSH
27453: LD_INT 4
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PPUSH
27460: CALL_OW 69
27464: PPUSH
27465: LD_INT 1
27467: PPUSH
27468: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
27472: LD_INT 4
27474: PPUSH
27475: LD_INT 4
27477: PPUSH
27478: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
27482: LD_ADDR_VAR 0 1
27486: PUSH
27487: LD_INT 4
27489: PPUSH
27490: LD_INT 1
27492: PPUSH
27493: LD_INT 2
27495: PPUSH
27496: CALL 69608 0 3
27500: PUSH
27501: FOR_IN
27502: IFFALSE 27539
// if GetTech ( i , 1 ) <> state_researched then
27504: LD_VAR 0 1
27508: PPUSH
27509: LD_INT 1
27511: PPUSH
27512: CALL_OW 321
27516: PUSH
27517: LD_INT 2
27519: NONEQUAL
27520: IFFALSE 27537
// SetTech ( i , 1 , state_researched ) ;
27522: LD_VAR 0 1
27526: PPUSH
27527: LD_INT 1
27529: PPUSH
27530: LD_INT 2
27532: PPUSH
27533: CALL_OW 322
27537: GO 27501
27539: POP
27540: POP
// missionStage := 6 ;
27541: LD_ADDR_EXP 15
27545: PUSH
27546: LD_INT 6
27548: ST_TO_ADDR
// activeAttacks := true ;
27549: LD_ADDR_EXP 16
27553: PUSH
27554: LD_INT 1
27556: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27557: LD_STRING M2
27559: PPUSH
27560: CALL_OW 337
// SaveForQuickRestart ;
27564: CALL_OW 22
// wait ( 0 0$40 ) ;
27568: LD_INT 1400
27570: PPUSH
27571: CALL_OW 67
// DialogueOn ;
27575: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27579: LD_EXP 66
27583: PPUSH
27584: LD_STRING D7-Friend-1
27586: PPUSH
27587: CALL 111301 0 2
// Say ( JMM , D7-JMM-1 ) ;
27591: LD_EXP 40
27595: PPUSH
27596: LD_STRING D7-JMM-1
27598: PPUSH
27599: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27603: LD_EXP 66
27607: PPUSH
27608: LD_STRING D7-Friend-2
27610: PPUSH
27611: CALL 111301 0 2
// Say ( JMM , D7-JMM-2 ) ;
27615: LD_EXP 40
27619: PPUSH
27620: LD_STRING D7-JMM-2
27622: PPUSH
27623: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27627: LD_EXP 66
27631: PPUSH
27632: LD_STRING D7-Friend-3
27634: PPUSH
27635: CALL 111301 0 2
// Say ( JMM , D7-JMM-3 ) ;
27639: LD_EXP 40
27643: PPUSH
27644: LD_STRING D7-JMM-3
27646: PPUSH
27647: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27651: LD_EXP 66
27655: PPUSH
27656: LD_STRING D7-Friend-4
27658: PPUSH
27659: CALL 111301 0 2
// Say ( JMM , D7-JMM-4 ) ;
27663: LD_EXP 40
27667: PPUSH
27668: LD_STRING D7-JMM-4
27670: PPUSH
27671: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27675: LD_EXP 66
27679: PPUSH
27680: LD_STRING D7-Friend-5
27682: PPUSH
27683: CALL 111301 0 2
// Say ( JMM , D7-JMM-5 ) ;
27687: LD_EXP 40
27691: PPUSH
27692: LD_STRING D7-JMM-5
27694: PPUSH
27695: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27699: LD_EXP 66
27703: PPUSH
27704: LD_STRING D7-Friend-6
27706: PPUSH
27707: CALL 111301 0 2
// Say ( JMM , D7-JMM-6 ) ;
27711: LD_EXP 40
27715: PPUSH
27716: LD_STRING D7-JMM-6
27718: PPUSH
27719: CALL_OW 88
// DialogueOff ;
27723: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27727: LD_STRING Mlegion
27729: PPUSH
27730: CALL_OW 337
// skirmish := true ;
27734: LD_ADDR_EXP 100
27738: PUSH
27739: LD_INT 1
27741: ST_TO_ADDR
// RebuildKozlovFactory ;
27742: CALL 5267 0 0
// end ;
27746: PPOPN 13
27748: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27749: LD_EXP 20
27753: PUSH
27754: LD_EXP 61
27758: PPUSH
27759: CALL_OW 300
27763: AND
27764: IFFALSE 27806
27766: GO 27768
27768: DISABLE
// begin enable ;
27769: ENABLE
// if IsInUnit ( Powell ) then
27770: LD_EXP 61
27774: PPUSH
27775: CALL_OW 310
27779: IFFALSE 27797
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27781: LD_EXP 61
27785: PPUSH
27786: CALL_OW 310
27790: PPUSH
27791: CALL_OW 85
27795: GO 27806
// CenterOnUnits ( Powell ) ;
27797: LD_EXP 61
27801: PPUSH
27802: CALL_OW 85
// end ;
27806: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27807: LD_INT 22
27809: PUSH
27810: LD_INT 8
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PUSH
27817: LD_INT 34
27819: PUSH
27820: LD_INT 48
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: EMPTY
27828: LIST
27829: LIST
27830: PPUSH
27831: CALL_OW 69
27835: IFFALSE 28109
27837: GO 27839
27839: DISABLE
27840: LD_INT 0
27842: PPUSH
27843: PPUSH
// begin if missionStage < 9 then
27844: LD_EXP 15
27848: PUSH
27849: LD_INT 9
27851: LESS
27852: IFFALSE 27862
// missionStage := 9 ;
27854: LD_ADDR_EXP 15
27858: PUSH
27859: LD_INT 9
27861: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27862: LD_ADDR_VAR 0 1
27866: PUSH
27867: LD_INT 22
27869: PUSH
27870: LD_INT 8
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 34
27879: PUSH
27880: LD_INT 48
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PPUSH
27891: CALL_OW 69
27895: PUSH
27896: LD_INT 1
27898: ARRAY
27899: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27900: LD_INT 175
27902: PPUSH
27903: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27907: LD_EXP 12
27911: PUSH
27912: LD_EXP 3
27916: PUSH
27917: LD_INT 0
27919: PUSH
27920: LD_INT 2
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: IN
27927: OR
27928: IFFALSE 27951
// target := [ 68 , 108 , 1 ] else
27930: LD_ADDR_VAR 0 2
27934: PUSH
27935: LD_INT 68
27937: PUSH
27938: LD_INT 108
27940: PUSH
27941: LD_INT 1
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: LIST
27948: ST_TO_ADDR
27949: GO 27970
// target := [ 181 , 88 , 2 ] ;
27951: LD_ADDR_VAR 0 2
27955: PUSH
27956: LD_INT 181
27958: PUSH
27959: LD_INT 88
27961: PUSH
27962: LD_INT 2
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: LIST
27969: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27970: LD_VAR 0 1
27974: PPUSH
27975: LD_VAR 0 2
27979: PUSH
27980: LD_INT 1
27982: ARRAY
27983: PPUSH
27984: LD_VAR 0 2
27988: PUSH
27989: LD_INT 2
27991: ARRAY
27992: PPUSH
27993: CALL_OW 176
// if target [ 3 ] = 1 then
27997: LD_VAR 0 2
28001: PUSH
28002: LD_INT 3
28004: ARRAY
28005: PUSH
28006: LD_INT 1
28008: EQUAL
28009: IFFALSE 28025
// SayRadio ( Kurt , D12-Kurt-1 ) else
28011: LD_EXP 64
28015: PPUSH
28016: LD_STRING D12-Kurt-1
28018: PPUSH
28019: CALL_OW 94
28023: GO 28049
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28025: LD_EXP 64
28029: PPUSH
28030: LD_STRING D12a-Kurt-1
28032: PPUSH
28033: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28037: LD_EXP 79
28041: PPUSH
28042: LD_STRING D12a-Roth-1
28044: PPUSH
28045: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28049: LD_INT 350
28051: PPUSH
28052: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28056: LD_VAR 0 1
28060: PPUSH
28061: LD_INT 22
28063: PUSH
28064: LD_INT 8
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: PUSH
28071: LD_INT 23
28073: PUSH
28074: LD_INT 2
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 30
28083: PUSH
28084: LD_INT 3
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: LIST
28095: PPUSH
28096: CALL_OW 69
28100: PUSH
28101: LD_INT 1
28103: ARRAY
28104: PPUSH
28105: CALL_OW 228
// end ;
28109: PPOPN 2
28111: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28112: LD_EXP 64
28116: PPUSH
28117: CALL_OW 256
28121: PUSH
28122: LD_INT 999
28124: LESS
28125: PUSH
28126: LD_INT 22
28128: PUSH
28129: LD_INT 8
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 21
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: PUSH
28146: LD_INT 23
28148: PUSH
28149: LD_INT 2
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: LIST
28160: PPUSH
28161: CALL_OW 69
28165: PUSH
28166: LD_INT 9
28168: PUSH
28169: LD_INT 8
28171: PUSH
28172: LD_INT 7
28174: PUSH
28175: LD_INT 6
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: LIST
28182: LIST
28183: PUSH
28184: LD_OWVAR 67
28188: ARRAY
28189: LESSEQUAL
28190: OR
28191: PUSH
28192: LD_INT 22
28194: PUSH
28195: LD_INT 8
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: LD_INT 34
28204: PUSH
28205: LD_INT 48
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PPUSH
28216: CALL_OW 69
28220: NOT
28221: AND
28222: PUSH
28223: LD_EXP 64
28227: PPUSH
28228: CALL_OW 302
28232: AND
28233: PUSH
28234: LD_INT 5
28236: PPUSH
28237: LD_INT 22
28239: PUSH
28240: LD_INT 1
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PPUSH
28247: CALL_OW 70
28251: AND
28252: IFFALSE 29014
28254: GO 28256
28256: DISABLE
28257: LD_INT 0
28259: PPUSH
28260: PPUSH
28261: PPUSH
// begin legionDestroyed := true ;
28262: LD_ADDR_EXP 22
28266: PUSH
28267: LD_INT 1
28269: ST_TO_ADDR
// DialogueOn ;
28270: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
28274: LD_EXP 40
28278: PPUSH
28279: LD_STRING D13-JMM-1
28281: PPUSH
28282: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
28286: LD_EXP 64
28290: PPUSH
28291: LD_STRING D13-Kurt-1
28293: PPUSH
28294: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
28298: LD_EXP 40
28302: PPUSH
28303: LD_STRING D13-JMM-2
28305: PPUSH
28306: CALL_OW 88
// if FakeInfo then
28310: LD_EXP 12
28314: IFFALSE 28334
// begin Say ( Kurt , D13-Kurt-2 ) ;
28316: LD_EXP 64
28320: PPUSH
28321: LD_STRING D13-Kurt-2
28323: PPUSH
28324: CALL_OW 88
// DialogueOff ;
28328: CALL_OW 7
// exit ;
28332: GO 29014
// end ; if not KurtStatus then
28334: LD_EXP 3
28338: NOT
28339: IFFALSE 28355
// Say ( Kurt , D13-Kurt-2b ) else
28341: LD_EXP 64
28345: PPUSH
28346: LD_STRING D13-Kurt-2b
28348: PPUSH
28349: CALL_OW 88
28353: GO 28367
// Say ( Kurt , D13-Kurt-2a ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D13-Kurt-2a
28362: PPUSH
28363: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
28367: LD_EXP 40
28371: PPUSH
28372: LD_STRING D13-JMM-3
28374: PPUSH
28375: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
28379: LD_EXP 64
28383: PPUSH
28384: LD_STRING D13-Kurt-3
28386: PPUSH
28387: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
28391: LD_EXP 40
28395: PPUSH
28396: LD_STRING D13-JMM-4
28398: PPUSH
28399: CALL_OW 88
// DialogueOff ;
28403: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
28407: LD_STRING MlegionOut
28409: PPUSH
28410: CALL_OW 337
// MC_Kill ( 3 ) ;
28414: LD_INT 3
28416: PPUSH
28417: CALL 39094 0 1
// KillUnit ( Kozlov ) ;
28421: LD_EXP 65
28425: PPUSH
28426: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
28430: LD_ADDR_VAR 0 1
28434: PUSH
28435: LD_INT 22
28437: PUSH
28438: LD_INT 8
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: LD_INT 23
28447: PUSH
28448: LD_INT 3
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: PUSH
28455: LD_INT 3
28457: PUSH
28458: LD_INT 21
28460: PUSH
28461: LD_INT 33
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: LIST
28476: PPUSH
28477: CALL_OW 69
28481: PUSH
28482: FOR_IN
28483: IFFALSE 28496
// KillUnit ( i ) ;
28485: LD_VAR 0 1
28489: PPUSH
28490: CALL_OW 66
28494: GO 28482
28496: POP
28497: POP
// ChangeSideFog ( 8 , 1 ) ;
28498: LD_INT 8
28500: PPUSH
28501: LD_INT 1
28503: PPUSH
28504: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
28508: LD_ADDR_VAR 0 2
28512: PUSH
28513: LD_INT 22
28515: PUSH
28516: LD_INT 8
28518: PUSH
28519: EMPTY
28520: LIST
28521: LIST
28522: PUSH
28523: LD_INT 21
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PPUSH
28537: CALL_OW 69
28541: PUSH
28542: LD_EXP 65
28546: PUSH
28547: LD_EXP 64
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: DIFF
28556: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28557: LD_VAR 0 2
28561: PUSH
28562: LD_INT 6
28564: PUSH
28565: LD_INT 5
28567: PUSH
28568: LD_INT 4
28570: PUSH
28571: LD_INT 3
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: PUSH
28580: LD_OWVAR 67
28584: ARRAY
28585: GREATEREQUAL
28586: IFFALSE 28738
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28588: LD_ADDR_VAR 0 3
28592: PUSH
28593: LD_INT 6
28595: PUSH
28596: LD_INT 5
28598: PUSH
28599: LD_INT 4
28601: PUSH
28602: LD_INT 3
28604: PUSH
28605: EMPTY
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: PUSH
28611: LD_OWVAR 67
28615: ARRAY
28616: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28617: LD_ADDR_VAR 0 1
28621: PUSH
28622: DOUBLE
28623: LD_VAR 0 2
28627: PUSH
28628: LD_VAR 0 3
28632: PUSH
28633: LD_INT 1
28635: PLUS
28636: MINUS
28637: INC
28638: ST_TO_ADDR
28639: LD_INT 1
28641: PUSH
28642: FOR_DOWNTO
28643: IFFALSE 28734
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28645: LD_ADDR_EXP 38
28649: PUSH
28650: LD_EXP 38
28654: PUSH
28655: LD_VAR 0 2
28659: PUSH
28660: LD_VAR 0 1
28664: ARRAY
28665: ADD
28666: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28667: LD_VAR 0 2
28671: PUSH
28672: LD_VAR 0 1
28676: ARRAY
28677: PPUSH
28678: CALL_OW 310
28682: IFFALSE 28699
// ComExit ( tmp [ i ] ) ;
28684: LD_VAR 0 2
28688: PUSH
28689: LD_VAR 0 1
28693: ARRAY
28694: PPUSH
28695: CALL 107634 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28699: LD_VAR 0 2
28703: PUSH
28704: LD_VAR 0 1
28708: ARRAY
28709: PPUSH
28710: LD_INT 34
28712: PUSH
28713: LD_INT 0
28715: PPUSH
28716: LD_INT 6
28718: PPUSH
28719: CALL_OW 12
28723: PLUS
28724: PPUSH
28725: LD_INT 1
28727: PPUSH
28728: CALL_OW 171
// end ;
28732: GO 28642
28734: POP
28735: POP
// end else
28736: GO 28748
// x := tmp ;
28738: LD_ADDR_VAR 0 3
28742: PUSH
28743: LD_VAR 0 2
28747: ST_TO_ADDR
// for i := tmp downto tmp - x do
28748: LD_ADDR_VAR 0 1
28752: PUSH
28753: DOUBLE
28754: LD_VAR 0 2
28758: INC
28759: ST_TO_ADDR
28760: LD_VAR 0 2
28764: PUSH
28765: LD_VAR 0 3
28769: MINUS
28770: PUSH
28771: FOR_DOWNTO
28772: IFFALSE 28844
// begin if IsInUnit ( tmp [ i ] ) then
28774: LD_VAR 0 2
28778: PUSH
28779: LD_VAR 0 1
28783: ARRAY
28784: PPUSH
28785: CALL_OW 310
28789: IFFALSE 28806
// ComExit ( tmp [ i ] ) ;
28791: LD_VAR 0 2
28795: PUSH
28796: LD_VAR 0 1
28800: ARRAY
28801: PPUSH
28802: CALL 107634 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28806: LD_VAR 0 2
28810: PUSH
28811: LD_VAR 0 1
28815: ARRAY
28816: PPUSH
28817: LD_INT 1
28819: PPUSH
28820: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28824: LD_VAR 0 2
28828: PUSH
28829: LD_VAR 0 1
28833: ARRAY
28834: PPUSH
28835: LD_INT 1000
28837: PPUSH
28838: CALL_OW 234
// end ;
28842: GO 28771
28844: POP
28845: POP
// wait ( 0 0$0.3 ) ;
28846: LD_INT 10
28848: PPUSH
28849: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28853: LD_ADDR_VAR 0 1
28857: PUSH
28858: LD_INT 22
28860: PUSH
28861: LD_INT 8
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 21
28870: PUSH
28871: LD_INT 2
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PPUSH
28882: CALL_OW 69
28886: PUSH
28887: FOR_IN
28888: IFFALSE 28901
// KillUnit ( i ) ;
28890: LD_VAR 0 1
28894: PPUSH
28895: CALL_OW 66
28899: GO 28887
28901: POP
28902: POP
// SetSide ( Kurt , 1 ) ;
28903: LD_EXP 64
28907: PPUSH
28908: LD_INT 1
28910: PPUSH
28911: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28915: LD_INT 22
28917: PUSH
28918: LD_INT 8
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 21
28927: PUSH
28928: LD_INT 3
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PPUSH
28939: CALL_OW 69
28943: PPUSH
28944: LD_INT 1
28946: PPUSH
28947: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28951: LD_INT 8
28953: PPUSH
28954: LD_INT 1
28956: PPUSH
28957: LD_INT 1
28959: PPUSH
28960: LD_INT 1
28962: PPUSH
28963: CALL_OW 80
// wait ( 1 1$20 ) ;
28967: LD_INT 2800
28969: PPUSH
28970: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28974: LD_EXP 66
28978: PPUSH
28979: LD_INT 37
28981: PPUSH
28982: LD_INT 1
28984: PPUSH
28985: LD_INT 0
28987: PPUSH
28988: CALL_OW 48
// wait ( 0 0$1 ) ;
28992: LD_INT 35
28994: PPUSH
28995: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28999: LD_EXP 66
29003: PPUSH
29004: LD_INT 60
29006: PPUSH
29007: LD_INT 95
29009: PPUSH
29010: CALL_OW 111
// end ;
29014: PPOPN 3
29016: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29017: LD_EXP 22
29021: NOT
29022: PUSH
29023: LD_INT 22
29025: PUSH
29026: LD_INT 8
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: LD_INT 21
29035: PUSH
29036: LD_INT 1
29038: PUSH
29039: EMPTY
29040: LIST
29041: LIST
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PPUSH
29047: CALL_OW 69
29051: PUSH
29052: LD_INT 0
29054: EQUAL
29055: AND
29056: IFFALSE 29076
29058: GO 29060
29060: DISABLE
// begin legionDestroyed := true ;
29061: LD_ADDR_EXP 22
29065: PUSH
29066: LD_INT 1
29068: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29069: LD_STRING MlegionOut
29071: PPUSH
29072: CALL_OW 337
// end ;
29076: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29077: LD_EXP 38
29081: IFFALSE 29156
29083: GO 29085
29085: DISABLE
29086: LD_INT 0
29088: PPUSH
// begin enable ;
29089: ENABLE
// for i in legionEscapeUnits do
29090: LD_ADDR_VAR 0 1
29094: PUSH
29095: LD_EXP 38
29099: PUSH
29100: FOR_IN
29101: IFFALSE 29154
// begin if IsInArea ( i , legionEscapeArea ) then
29103: LD_VAR 0 1
29107: PPUSH
29108: LD_INT 31
29110: PPUSH
29111: CALL_OW 308
29115: IFFALSE 29128
// RemoveUnit ( i ) else
29117: LD_VAR 0 1
29121: PPUSH
29122: CALL_OW 64
29126: GO 29152
// if not HasTask ( i ) then
29128: LD_VAR 0 1
29132: PPUSH
29133: CALL_OW 314
29137: NOT
29138: IFFALSE 29152
// ComMoveToArea ( i , legionEscapeArea ) ;
29140: LD_VAR 0 1
29144: PPUSH
29145: LD_INT 31
29147: PPUSH
29148: CALL_OW 113
// end ;
29152: GO 29100
29154: POP
29155: POP
// end ;
29156: PPOPN 1
29158: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29159: LD_INT 1
29161: PPUSH
29162: LD_EXP 66
29166: PPUSH
29167: CALL_OW 292
29171: IFFALSE 29469
29173: GO 29175
29175: DISABLE
29176: LD_INT 0
29178: PPUSH
// begin wait ( 0 0$2 ) ;
29179: LD_INT 70
29181: PPUSH
29182: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
29186: LD_EXP 66
29190: PPUSH
29191: CALL_OW 87
// DialogueOn ;
29195: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
29199: LD_EXP 40
29203: PPUSH
29204: LD_STRING D14-JMM-1
29206: PPUSH
29207: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
29211: LD_EXP 66
29215: PPUSH
29216: LD_STRING D14-Friend-1
29218: PPUSH
29219: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
29223: LD_EXP 40
29227: PPUSH
29228: LD_STRING D14-JMM-2
29230: PPUSH
29231: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
29235: LD_EXP 66
29239: PPUSH
29240: LD_STRING D14-Friend-2
29242: PPUSH
29243: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
29247: LD_EXP 40
29251: PPUSH
29252: LD_STRING D14-JMM-3
29254: PPUSH
29255: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
29259: LD_EXP 66
29263: PPUSH
29264: LD_STRING D14-Friend-3
29266: PPUSH
29267: CALL_OW 88
// DialogueOff ;
29271: CALL_OW 7
// dec := Query ( Q14 ) ;
29275: LD_ADDR_VAR 0 1
29279: PUSH
29280: LD_STRING Q14
29282: PPUSH
29283: CALL_OW 97
29287: ST_TO_ADDR
// if dec = 1 then
29288: LD_VAR 0 1
29292: PUSH
29293: LD_INT 1
29295: EQUAL
29296: IFFALSE 29330
// begin DialogueOn ;
29298: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
29302: LD_EXP 40
29306: PPUSH
29307: LD_STRING D14a-JMM-1
29309: PPUSH
29310: CALL_OW 88
// DialogueOff ;
29314: CALL_OW 7
// SetSide ( Friend , 1 ) ;
29318: LD_EXP 66
29322: PPUSH
29323: LD_INT 1
29325: PPUSH
29326: CALL_OW 235
// end ; if dec = 2 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 2
29337: EQUAL
29338: IFFALSE 29391
// begin DialogueOn ;
29340: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
29344: LD_EXP 40
29348: PPUSH
29349: LD_STRING D14b-JMM-1
29351: PPUSH
29352: CALL_OW 88
// DialogueOff ;
29356: CALL_OW 7
// wait ( 0 0$1 ) ;
29360: LD_INT 35
29362: PPUSH
29363: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
29367: LD_EXP 66
29371: PPUSH
29372: LD_INT 9
29374: PPUSH
29375: LD_INT 2
29377: PPUSH
29378: CALL_OW 111
// AddComHold ( Friend ) ;
29382: LD_EXP 66
29386: PPUSH
29387: CALL_OW 200
// end ; if dec = 3 then
29391: LD_VAR 0 1
29395: PUSH
29396: LD_INT 3
29398: EQUAL
29399: IFFALSE 29469
// begin DialogueOn ;
29401: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
29405: LD_EXP 40
29409: PPUSH
29410: LD_STRING D14c-JMM-1
29412: PPUSH
29413: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
29417: LD_EXP 66
29421: PPUSH
29422: LD_STRING D14c-Friend-1
29424: PPUSH
29425: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
29429: LD_EXP 40
29433: PPUSH
29434: LD_STRING D14c-JMM-2
29436: PPUSH
29437: CALL_OW 88
// DialogueOff ;
29441: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
29445: LD_EXP 66
29449: PPUSH
29450: LD_INT 9
29452: PPUSH
29453: LD_INT 2
29455: PPUSH
29456: CALL_OW 111
// AddComHold ( Friend ) ;
29460: LD_EXP 66
29464: PPUSH
29465: CALL_OW 200
// end ; end ;
29469: PPOPN 1
29471: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
29472: LD_INT 9
29474: PPUSH
29475: LD_INT 2
29477: PPUSH
29478: CALL_OW 428
29482: PUSH
29483: LD_EXP 66
29487: EQUAL
29488: PUSH
29489: LD_EXP 66
29493: PPUSH
29494: CALL_OW 255
29498: PUSH
29499: LD_INT 8
29501: EQUAL
29502: AND
29503: IFFALSE 29517
29505: GO 29507
29507: DISABLE
// RemoveUnit ( Friend ) ;
29508: LD_EXP 66
29512: PPUSH
29513: CALL_OW 64
29517: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
29518: LD_EXP 14
29522: PUSH
29523: LD_INT 31500
29525: GREATEREQUAL
29526: PUSH
29527: LD_EXP 7
29531: AND
29532: PUSH
29533: LD_EXP 2
29537: AND
29538: IFFALSE 29984
29540: GO 29542
29542: DISABLE
29543: LD_INT 0
29545: PPUSH
29546: PPUSH
29547: PPUSH
// begin missionStage := 7 ;
29548: LD_ADDR_EXP 15
29552: PUSH
29553: LD_INT 7
29555: ST_TO_ADDR
// for i := 1 to 5 do
29556: LD_ADDR_VAR 0 1
29560: PUSH
29561: DOUBLE
29562: LD_INT 1
29564: DEC
29565: ST_TO_ADDR
29566: LD_INT 5
29568: PUSH
29569: FOR_TO
29570: IFFALSE 29682
// begin uc_side = 1 ;
29572: LD_ADDR_OWVAR 20
29576: PUSH
29577: LD_INT 1
29579: ST_TO_ADDR
// uc_nation = 1 ;
29580: LD_ADDR_OWVAR 21
29584: PUSH
29585: LD_INT 1
29587: ST_TO_ADDR
// vc_engine = 3 ;
29588: LD_ADDR_OWVAR 39
29592: PUSH
29593: LD_INT 3
29595: ST_TO_ADDR
// vc_control = 3 ;
29596: LD_ADDR_OWVAR 38
29600: PUSH
29601: LD_INT 3
29603: ST_TO_ADDR
// vc_chassis = 3 ;
29604: LD_ADDR_OWVAR 37
29608: PUSH
29609: LD_INT 3
29611: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29612: LD_ADDR_OWVAR 40
29616: PUSH
29617: LD_INT 5
29619: PUSH
29620: LD_INT 9
29622: PUSH
29623: LD_INT 7
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 1
29633: PPUSH
29634: LD_INT 3
29636: PPUSH
29637: CALL_OW 12
29641: ARRAY
29642: ST_TO_ADDR
// veh = CreateVehicle ;
29643: LD_ADDR_VAR 0 2
29647: PUSH
29648: CALL_OW 45
29652: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29653: LD_VAR 0 2
29657: PPUSH
29658: LD_INT 1
29660: PPUSH
29661: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29665: LD_VAR 0 2
29669: PPUSH
29670: LD_INT 19
29672: PPUSH
29673: LD_INT 0
29675: PPUSH
29676: CALL_OW 49
// end ;
29680: GO 29569
29682: POP
29683: POP
// uc_side = 1 ;
29684: LD_ADDR_OWVAR 20
29688: PUSH
29689: LD_INT 1
29691: ST_TO_ADDR
// uc_nation = 1 ;
29692: LD_ADDR_OWVAR 21
29696: PUSH
29697: LD_INT 1
29699: ST_TO_ADDR
// vc_engine = 3 ;
29700: LD_ADDR_OWVAR 39
29704: PUSH
29705: LD_INT 3
29707: ST_TO_ADDR
// vc_control = 1 ;
29708: LD_ADDR_OWVAR 38
29712: PUSH
29713: LD_INT 1
29715: ST_TO_ADDR
// vc_chassis = 3 ;
29716: LD_ADDR_OWVAR 37
29720: PUSH
29721: LD_INT 3
29723: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29724: LD_ADDR_OWVAR 40
29728: PUSH
29729: LD_INT 5
29731: PUSH
29732: LD_INT 9
29734: PUSH
29735: LD_INT 7
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PPUSH
29746: LD_INT 3
29748: PPUSH
29749: CALL_OW 12
29753: ARRAY
29754: ST_TO_ADDR
// vehG = CreateVehicle ;
29755: LD_ADDR_VAR 0 3
29759: PUSH
29760: CALL_OW 45
29764: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29765: LD_VAR 0 3
29769: PPUSH
29770: LD_INT 1
29772: PPUSH
29773: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29777: LD_VAR 0 3
29781: PPUSH
29782: LD_INT 19
29784: PPUSH
29785: LD_INT 0
29787: PPUSH
29788: CALL_OW 49
// if JMMGirl = 1 then
29792: LD_EXP 7
29796: PUSH
29797: LD_INT 1
29799: EQUAL
29800: IFFALSE 29856
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29802: LD_ADDR_EXP 41
29806: PUSH
29807: LD_STRING Joan
29809: PPUSH
29810: LD_INT 1
29812: PPUSH
29813: LD_STRING 14_
29815: PPUSH
29816: CALL 69545 0 3
29820: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29821: LD_EXP 41
29825: PPUSH
29826: LD_VAR 0 3
29830: PPUSH
29831: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29835: LD_VAR 0 3
29839: PPUSH
29840: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29844: LD_EXP 41
29848: PPUSH
29849: LD_STRING D10BW-Joan-1
29851: PPUSH
29852: CALL_OW 94
// end ; if JMMGirl = 2 then
29856: LD_EXP 7
29860: PUSH
29861: LD_INT 2
29863: EQUAL
29864: IFFALSE 29920
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29866: LD_ADDR_EXP 43
29870: PUSH
29871: LD_STRING Lisa
29873: PPUSH
29874: LD_INT 1
29876: PPUSH
29877: LD_STRING 14_
29879: PPUSH
29880: CALL 69545 0 3
29884: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29885: LD_EXP 43
29889: PPUSH
29890: LD_VAR 0 3
29894: PPUSH
29895: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29899: LD_VAR 0 3
29903: PPUSH
29904: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29908: LD_EXP 43
29912: PPUSH
29913: LD_STRING D10BW-Lisa-1
29915: PPUSH
29916: CALL_OW 94
// end ; if JMMGirl = 3 then
29920: LD_EXP 7
29924: PUSH
29925: LD_INT 3
29927: EQUAL
29928: IFFALSE 29984
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29930: LD_ADDR_EXP 55
29934: PUSH
29935: LD_STRING Connie
29937: PPUSH
29938: LD_INT 1
29940: PPUSH
29941: LD_STRING 14_
29943: PPUSH
29944: CALL 69545 0 3
29948: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29949: LD_EXP 55
29953: PPUSH
29954: LD_VAR 0 3
29958: PPUSH
29959: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29963: LD_VAR 0 3
29967: PPUSH
29968: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29972: LD_EXP 55
29976: PPUSH
29977: LD_STRING D10BW-Con-1
29979: PPUSH
29980: CALL_OW 94
// end ; end ;
29984: PPOPN 3
29986: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29987: LD_EXP 14
29991: PUSH
29992: LD_INT 94500
29994: GREATEREQUAL
29995: IFFALSE 30407
29997: GO 29999
29999: DISABLE
30000: LD_INT 0
30002: PPUSH
30003: PPUSH
30004: PPUSH
// begin tmp := PrepareStevensSquad ;
30005: LD_ADDR_VAR 0 3
30009: PUSH
30010: CALL 2323 0 0
30014: ST_TO_ADDR
// if not tmp then
30015: LD_VAR 0 3
30019: NOT
30020: IFFALSE 30024
// exit ;
30022: GO 30407
// uc_side := 1 ;
30024: LD_ADDR_OWVAR 20
30028: PUSH
30029: LD_INT 1
30031: ST_TO_ADDR
// uc_nation := 1 ;
30032: LD_ADDR_OWVAR 21
30036: PUSH
30037: LD_INT 1
30039: ST_TO_ADDR
// for i in tmp do
30040: LD_ADDR_VAR 0 1
30044: PUSH
30045: LD_VAR 0 3
30049: PUSH
30050: FOR_IN
30051: IFFALSE 30148
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30053: LD_INT 3
30055: PPUSH
30056: LD_INT 3
30058: PPUSH
30059: LD_INT 1
30061: PPUSH
30062: LD_INT 5
30064: PUSH
30065: LD_INT 9
30067: PUSH
30068: LD_INT 7
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: PPUSH
30079: LD_INT 3
30081: PPUSH
30082: CALL_OW 12
30086: ARRAY
30087: PPUSH
30088: LD_INT 40
30090: PPUSH
30091: CALL 74385 0 5
// veh := CreateVehicle ;
30095: LD_ADDR_VAR 0 2
30099: PUSH
30100: CALL_OW 45
30104: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30105: LD_VAR 0 2
30109: PPUSH
30110: LD_INT 1
30112: PPUSH
30113: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30117: LD_VAR 0 2
30121: PPUSH
30122: LD_INT 19
30124: PPUSH
30125: LD_INT 0
30127: PPUSH
30128: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30132: LD_VAR 0 1
30136: PPUSH
30137: LD_VAR 0 2
30141: PPUSH
30142: CALL_OW 52
// end ;
30146: GO 30050
30148: POP
30149: POP
// missionStage := 8 ;
30150: LD_ADDR_EXP 15
30154: PUSH
30155: LD_INT 8
30157: ST_TO_ADDR
// DialogueOn ;
30158: CALL_OW 6
// if Stevens then
30162: LD_EXP 42
30166: IFFALSE 30280
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30168: LD_EXP 42
30172: PPUSH
30173: CALL_OW 310
30177: PPUSH
30178: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
30182: LD_EXP 42
30186: PPUSH
30187: LD_STRING D8-Huck-1
30189: PPUSH
30190: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
30194: LD_EXP 40
30198: PPUSH
30199: LD_STRING D8-JMM-1
30201: PPUSH
30202: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
30206: LD_EXP 42
30210: PPUSH
30211: LD_STRING D8-Huck-2
30213: PPUSH
30214: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30218: LD_EXP 40
30222: PPUSH
30223: LD_STRING D8-JMM-2
30225: PPUSH
30226: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
30230: LD_EXP 42
30234: PPUSH
30235: LD_STRING D8-Huck-3
30237: PPUSH
30238: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30242: LD_EXP 40
30246: PPUSH
30247: LD_STRING D8-JMM-3
30249: PPUSH
30250: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
30254: LD_EXP 42
30258: PPUSH
30259: LD_STRING D8-Huck-4
30261: PPUSH
30262: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30266: LD_EXP 40
30270: PPUSH
30271: LD_STRING D8-JMM-4
30273: PPUSH
30274: CALL_OW 88
// end else
30278: GO 30390
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
30280: LD_EXP 56
30284: PPUSH
30285: CALL_OW 310
30289: PPUSH
30290: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
30294: LD_EXP 56
30298: PPUSH
30299: LD_STRING D8-Huck-1
30301: PPUSH
30302: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
30306: LD_EXP 40
30310: PPUSH
30311: LD_STRING D8-JMM-1a
30313: PPUSH
30314: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
30318: LD_EXP 56
30322: PPUSH
30323: LD_STRING D8-Huck-2
30325: PPUSH
30326: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
30330: LD_EXP 40
30334: PPUSH
30335: LD_STRING D8-JMM-2
30337: PPUSH
30338: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
30342: LD_EXP 56
30346: PPUSH
30347: LD_STRING D8-Huck-3
30349: PPUSH
30350: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
30354: LD_EXP 40
30358: PPUSH
30359: LD_STRING D8-JMM-3
30361: PPUSH
30362: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
30366: LD_EXP 56
30370: PPUSH
30371: LD_STRING D8-Huck-4
30373: PPUSH
30374: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
30378: LD_EXP 40
30382: PPUSH
30383: LD_STRING D8-JMM-4
30385: PPUSH
30386: CALL_OW 88
// end ; DialogueOff ;
30390: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
30394: LD_INT 25
30396: PPUSH
30397: LD_INT 1
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 322
// end ;
30407: PPOPN 3
30409: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
30410: LD_EXP 75
30414: PPUSH
30415: CALL_OW 302
30419: PUSH
30420: LD_INT 1
30422: PPUSH
30423: LD_EXP 75
30427: PPUSH
30428: CALL_OW 292
30432: AND
30433: IFFALSE 30684
30435: GO 30437
30437: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
30438: LD_EXP 75
30442: PPUSH
30443: CALL_OW 87
// DialogueOn ;
30447: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
30451: LD_EXP 40
30455: PPUSH
30456: LD_STRING D10nB-JMM-1
30458: PPUSH
30459: CALL_OW 88
// if BurlakStatus = 1 then
30463: LD_EXP 9
30467: PUSH
30468: LD_INT 1
30470: EQUAL
30471: IFFALSE 30485
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
30473: LD_EXP 74
30477: PPUSH
30478: LD_STRING D10nB-Vse-1a
30480: PPUSH
30481: CALL_OW 94
// end ; if BurlakStatus = 0 then
30485: LD_EXP 9
30489: PUSH
30490: LD_INT 0
30492: EQUAL
30493: IFFALSE 30507
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
30495: LD_EXP 74
30499: PPUSH
30500: LD_STRING D10nB-Vse-1
30502: PPUSH
30503: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
30507: LD_EXP 40
30511: PPUSH
30512: LD_STRING D10nB-JMM-2
30514: PPUSH
30515: CALL_OW 88
// if KappaStatus then
30519: LD_EXP 2
30523: IFFALSE 30537
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
30525: LD_EXP 74
30529: PPUSH
30530: LD_STRING D10nB-Vse-5a
30532: PPUSH
30533: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
30537: LD_EXP 2
30541: NOT
30542: PUSH
30543: LD_EXP 6
30547: PUSH
30548: LD_INT 0
30550: EQUAL
30551: AND
30552: IFFALSE 30680
// begin if JMMGirl = 1 then
30554: LD_EXP 7
30558: PUSH
30559: LD_INT 1
30561: EQUAL
30562: IFFALSE 30612
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30564: LD_EXP 74
30568: PPUSH
30569: LD_STRING D10nB-Vse-2
30571: PPUSH
30572: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30576: LD_EXP 40
30580: PPUSH
30581: LD_STRING D10nB-JMM-3
30583: PPUSH
30584: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30588: LD_EXP 74
30592: PPUSH
30593: LD_STRING D10nB-Vse-3
30595: PPUSH
30596: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30600: LD_EXP 40
30604: PPUSH
30605: LD_STRING D10nB-JMM-4
30607: PPUSH
30608: CALL_OW 88
// end ; if JMMGirl = 2 then
30612: LD_EXP 7
30616: PUSH
30617: LD_INT 2
30619: EQUAL
30620: IFFALSE 30646
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30622: LD_EXP 74
30626: PPUSH
30627: LD_STRING D10nB-Vse-4
30629: PPUSH
30630: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30634: LD_EXP 40
30638: PPUSH
30639: LD_STRING D10nB-JMM-5
30641: PPUSH
30642: CALL_OW 88
// end ; if JMMGirl = 3 then
30646: LD_EXP 7
30650: PUSH
30651: LD_INT 3
30653: EQUAL
30654: IFFALSE 30680
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30656: LD_EXP 74
30660: PPUSH
30661: LD_STRING D10nB-Vse-5
30663: PPUSH
30664: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30668: LD_EXP 40
30672: PPUSH
30673: LD_STRING D10nB-JMM-6
30675: PPUSH
30676: CALL_OW 88
// end ; end ; DialogueOff ;
30680: CALL_OW 7
// end ;
30684: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30685: LD_EXP 14
30689: PUSH
30690: LD_INT 115500
30692: GREATEREQUAL
30693: PUSH
30694: LD_EXP 69
30698: PPUSH
30699: CALL_OW 302
30703: AND
30704: PUSH
30705: LD_INT 267
30707: PPUSH
30708: CALL_OW 302
30712: AND
30713: IFFALSE 31089
30715: GO 30717
30717: DISABLE
30718: LD_INT 0
30720: PPUSH
// begin missionStage := 10 ;
30721: LD_ADDR_EXP 15
30725: PUSH
30726: LD_INT 10
30728: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30729: LD_ADDR_VAR 0 1
30733: PUSH
30734: LD_INT 22
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 23
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 26
30756: PUSH
30757: LD_INT 1
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 3
30766: PUSH
30767: LD_INT 25
30769: PUSH
30770: LD_INT 12
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 3
30783: PUSH
30784: LD_INT 25
30786: PUSH
30787: LD_INT 16
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: PPUSH
30805: CALL_OW 69
30809: PUSH
30810: LD_EXP 40
30814: PUSH
30815: LD_EXP 64
30819: PUSH
30820: LD_EXP 42
30824: PUSH
30825: LD_EXP 56
30829: PUSH
30830: LD_EXP 43
30834: PUSH
30835: LD_EXP 44
30839: PUSH
30840: LD_EXP 45
30844: PUSH
30845: LD_EXP 46
30849: PUSH
30850: LD_EXP 47
30854: PUSH
30855: LD_EXP 48
30859: PUSH
30860: LD_EXP 49
30864: PUSH
30865: LD_EXP 50
30869: PUSH
30870: LD_EXP 51
30874: PUSH
30875: LD_EXP 52
30879: PUSH
30880: LD_EXP 53
30884: PUSH
30885: LD_EXP 54
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: LIST
30896: LIST
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: LIST
30904: LIST
30905: LIST
30906: LIST
30907: DIFF
30908: ST_TO_ADDR
// if not tmp and Brown then
30909: LD_VAR 0 1
30913: NOT
30914: PUSH
30915: LD_EXP 48
30919: AND
30920: IFFALSE 30935
// tmp := [ Brown ] ;
30922: LD_ADDR_VAR 0 1
30926: PUSH
30927: LD_EXP 48
30931: PUSH
30932: EMPTY
30933: LIST
30934: ST_TO_ADDR
// DialogueOn ;
30935: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30939: LD_VAR 0 1
30943: PUSH
30944: LD_INT 1
30946: ARRAY
30947: PPUSH
30948: LD_STRING D11-Sol1-1
30950: PPUSH
30951: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30955: LD_EXP 68
30959: PPUSH
30960: LD_STRING D11-Pla-1
30962: PPUSH
30963: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30967: LD_EXP 69
30971: PPUSH
30972: LD_STRING D11-Kov-1
30974: PPUSH
30975: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30979: LD_EXP 68
30983: PPUSH
30984: LD_STRING D11-Pla-2
30986: PPUSH
30987: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30991: LD_VAR 0 1
30995: PUSH
30996: LD_INT 1
30998: ARRAY
30999: PPUSH
31000: LD_STRING D11-Sol1-2
31002: PPUSH
31003: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31007: LD_EXP 40
31011: PPUSH
31012: LD_STRING D11-JMM-2
31014: PPUSH
31015: CALL_OW 88
// DialogueOff ;
31019: CALL_OW 7
// allowBehemothConstruct := true ;
31023: LD_ADDR_EXP 25
31027: PUSH
31028: LD_INT 1
31030: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31031: LD_STRING M4
31033: PPUSH
31034: CALL_OW 337
// BuildBehemoths ;
31038: CALL 8350 0 0
// repeat wait ( 15 15$00 ) ;
31042: LD_INT 31500
31044: PPUSH
31045: CALL_OW 67
// if behemothDestroyedBeforeFinish then
31049: LD_EXP 27
31053: IFFALSE 31057
// break ;
31055: GO 31089
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
31057: LD_INT 267
31059: PPUSH
31060: CALL_OW 274
31064: PPUSH
31065: LD_INT 1
31067: PPUSH
31068: CALL_OW 275
31072: PUSH
31073: LD_INT 1000
31075: GREATEREQUAL
31076: IFFALSE 31082
// BuildBehemoths ;
31078: CALL 8350 0 0
// until not behemothBuilders ;
31082: LD_EXP 77
31086: NOT
31087: IFFALSE 31042
// end ;
31089: PPOPN 1
31091: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
31092: LD_EXP 77
31096: NOT
31097: PUSH
31098: LD_EXP 28
31102: NOT
31103: AND
31104: PUSH
31105: LD_EXP 25
31109: AND
31110: IFFALSE 31130
31112: GO 31114
31114: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
31115: LD_STRING M4a
31117: PPUSH
31118: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
31122: LD_ADDR_EXP 27
31126: PUSH
31127: LD_INT 1
31129: ST_TO_ADDR
// end ;
31130: END
// every 0 0$1 trigger behemothDone do
31131: LD_EXP 28
31135: IFFALSE 31147
31137: GO 31139
31139: DISABLE
// ChangeMissionObjectives ( M4b ) ;
31140: LD_STRING M4b
31142: PPUSH
31143: CALL_OW 337
31147: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
31148: LD_EXP 29
31152: NOT
31153: IFFALSE 31349
31155: GO 31157
31157: DISABLE
31158: LD_INT 0
31160: PPUSH
31161: PPUSH
// begin enable ;
31162: ENABLE
// tmp := GetBehemoths ( 3 ) ;
31163: LD_ADDR_VAR 0 1
31167: PUSH
31168: LD_INT 3
31170: PPUSH
31171: CALL 107297 0 1
31175: ST_TO_ADDR
// if not tmp and not behemothDone then
31176: LD_VAR 0 1
31180: NOT
31181: PUSH
31182: LD_EXP 28
31186: NOT
31187: AND
31188: IFFALSE 31224
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
31190: LD_ADDR_VAR 0 1
31194: PUSH
31195: LD_INT 22
31197: PUSH
31198: LD_INT 3
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 30
31207: PUSH
31208: LD_INT 37
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PPUSH
31219: CALL_OW 69
31223: ST_TO_ADDR
// if not tmp then
31224: LD_VAR 0 1
31228: NOT
31229: IFFALSE 31233
// exit ;
31231: GO 31349
// for i in tmp do
31233: LD_ADDR_VAR 0 2
31237: PUSH
31238: LD_VAR 0 1
31242: PUSH
31243: FOR_IN
31244: IFFALSE 31347
// if See ( 1 , i ) then
31246: LD_INT 1
31248: PPUSH
31249: LD_VAR 0 2
31253: PPUSH
31254: CALL_OW 292
31258: IFFALSE 31345
// begin if GetType ( i ) = unit_building then
31260: LD_VAR 0 2
31264: PPUSH
31265: CALL_OW 247
31269: PUSH
31270: LD_INT 3
31272: EQUAL
31273: IFFALSE 31311
// begin disable ;
31275: DISABLE
// CenterNowOnUnits ( i ) ;
31276: LD_VAR 0 2
31280: PPUSH
31281: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
31285: LD_EXP 40
31289: PPUSH
31290: LD_STRING D17a-JMM-1
31292: PPUSH
31293: CALL_OW 88
// seeBehemoth := true ;
31297: LD_ADDR_EXP 29
31301: PUSH
31302: LD_INT 1
31304: ST_TO_ADDR
// exit ;
31305: POP
31306: POP
31307: GO 31349
// end else
31309: GO 31345
// begin disable ;
31311: DISABLE
// CenterNowOnUnits ( i ) ;
31312: LD_VAR 0 2
31316: PPUSH
31317: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
31321: LD_EXP 40
31325: PPUSH
31326: LD_STRING D17b-JMM-1
31328: PPUSH
31329: CALL_OW 88
// seeBehemoth := true ;
31333: LD_ADDR_EXP 29
31337: PUSH
31338: LD_INT 1
31340: ST_TO_ADDR
// exit ;
31341: POP
31342: POP
31343: GO 31349
// end ; end ;
31345: GO 31243
31347: POP
31348: POP
// end ;
31349: PPOPN 2
31351: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
31352: LD_EXP 14
31356: PUSH
31357: LD_INT 123200
31359: GREATEREQUAL
31360: IFFALSE 32560
31362: GO 31364
31364: DISABLE
31365: LD_INT 0
31367: PPUSH
31368: PPUSH
31369: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
31370: LD_INT 2
31372: PPUSH
31373: LD_INT 23
31375: PUSH
31376: LD_INT 3
31378: PUSH
31379: LD_INT 3
31381: PUSH
31382: LD_INT 48
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: PUSH
31391: EMPTY
31392: LIST
31393: PPUSH
31394: CALL 63119 0 2
// repeat wait ( 0 0$1 ) ;
31398: LD_INT 35
31400: PPUSH
31401: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
31405: LD_INT 22
31407: PUSH
31408: LD_INT 3
31410: PUSH
31411: EMPTY
31412: LIST
31413: LIST
31414: PUSH
31415: LD_INT 34
31417: PUSH
31418: LD_INT 48
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PPUSH
31429: CALL_OW 69
31433: IFFALSE 31398
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
31435: LD_ADDR_VAR 0 1
31439: PUSH
31440: LD_INT 22
31442: PUSH
31443: LD_INT 3
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 34
31452: PUSH
31453: LD_INT 48
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PPUSH
31464: CALL_OW 69
31468: PUSH
31469: LD_INT 1
31471: ARRAY
31472: ST_TO_ADDR
// missionStage := 12 ;
31473: LD_ADDR_EXP 15
31477: PUSH
31478: LD_INT 12
31480: ST_TO_ADDR
// platonovHasBomb := true ;
31481: LD_ADDR_EXP 30
31485: PUSH
31486: LD_INT 1
31488: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
31489: LD_VAR 0 1
31493: PPUSH
31494: LD_INT 181
31496: PPUSH
31497: LD_INT 86
31499: PPUSH
31500: CALL_OW 171
// AddComHold ( bomb ) ;
31504: LD_VAR 0 1
31508: PPUSH
31509: CALL_OW 200
// wait ( 0 0$10 ) ;
31513: LD_INT 350
31515: PPUSH
31516: CALL_OW 67
// DialogueOn ;
31520: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
31524: LD_EXP 68
31528: PPUSH
31529: LD_STRING D15-Pla-1
31531: PPUSH
31532: CALL_OW 94
// dec := Query ( Q15a ) ;
31536: LD_ADDR_VAR 0 2
31540: PUSH
31541: LD_STRING Q15a
31543: PPUSH
31544: CALL_OW 97
31548: ST_TO_ADDR
// if dec = 1 then
31549: LD_VAR 0 2
31553: PUSH
31554: LD_INT 1
31556: EQUAL
31557: IFFALSE 31580
// begin Say ( JMM , D15a-JMM-1 ) ;
31559: LD_EXP 40
31563: PPUSH
31564: LD_STRING D15a-JMM-1
31566: PPUSH
31567: CALL_OW 88
// YouLost ( Surrender ) ;
31571: LD_STRING Surrender
31573: PPUSH
31574: CALL_OW 104
// exit ;
31578: GO 32560
// end ; if dec = 2 then
31580: LD_VAR 0 2
31584: PUSH
31585: LD_INT 2
31587: EQUAL
31588: IFFALSE 31657
// begin Say ( JMM , D15b-JMM-1 ) ;
31590: LD_EXP 40
31594: PPUSH
31595: LD_STRING D15b-JMM-1
31597: PPUSH
31598: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31602: LD_EXP 68
31606: PPUSH
31607: LD_STRING D15b-Pla-1
31609: PPUSH
31610: CALL_OW 94
// DialogueOff ;
31614: CALL_OW 7
// wait ( 3 3$00 ) ;
31618: LD_INT 6300
31620: PPUSH
31621: CALL_OW 67
// DialogueOn ;
31625: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31629: LD_EXP 40
31633: PPUSH
31634: LD_STRING D15d-JMM-1a
31636: PPUSH
31637: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31641: LD_EXP 68
31645: PPUSH
31646: LD_STRING D15d-Pla-1
31648: PPUSH
31649: CALL_OW 94
// DialogueOff ;
31653: CALL_OW 7
// end ; if dec = 3 then
31657: LD_VAR 0 2
31661: PUSH
31662: LD_INT 3
31664: EQUAL
31665: IFFALSE 31719
// begin Say ( JMM , D15c-JMM-1 ) ;
31667: LD_EXP 40
31671: PPUSH
31672: LD_STRING D15c-JMM-1
31674: PPUSH
31675: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31679: LD_EXP 68
31683: PPUSH
31684: LD_STRING D15c-Pla-1
31686: PPUSH
31687: CALL_OW 94
// DialogueOff ;
31691: CALL_OW 7
// wait ( 0 0$15 ) ;
31695: LD_INT 525
31697: PPUSH
31698: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31702: LD_VAR 0 1
31706: PPUSH
31707: LD_INT 60
31709: PPUSH
31710: LD_INT 95
31712: PPUSH
31713: CALL_OW 116
// exit ;
31717: GO 32560
// end ; if dec = 4 then
31719: LD_VAR 0 2
31723: PUSH
31724: LD_INT 4
31726: EQUAL
31727: IFFALSE 31757
// begin Say ( JMM , D15d-JMM-1 ) ;
31729: LD_EXP 40
31733: PPUSH
31734: LD_STRING D15d-JMM-1
31736: PPUSH
31737: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31741: LD_EXP 68
31745: PPUSH
31746: LD_STRING D15d-Pla-1
31748: PPUSH
31749: CALL_OW 94
// DialogueOff ;
31753: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31757: LD_EXP 66
31761: PPUSH
31762: CALL_OW 302
31766: PUSH
31767: LD_EXP 66
31771: PPUSH
31772: CALL_OW 255
31776: PUSH
31777: LD_INT 1
31779: EQUAL
31780: AND
31781: PUSH
31782: LD_INT 22
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 34
31794: PUSH
31795: LD_INT 8
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: EMPTY
31803: LIST
31804: LIST
31805: PPUSH
31806: CALL_OW 69
31810: NOT
31811: AND
31812: IFFALSE 32461
// begin SetSide ( Friend , 8 ) ;
31814: LD_EXP 66
31818: PPUSH
31819: LD_INT 8
31821: PPUSH
31822: CALL_OW 235
// if IsInUnit ( Friend ) then
31826: LD_EXP 66
31830: PPUSH
31831: CALL_OW 310
31835: IFFALSE 31846
// ComExitBuilding ( Friend ) ;
31837: LD_EXP 66
31841: PPUSH
31842: CALL_OW 122
// if IsDriver ( Friend ) then
31846: LD_EXP 66
31850: PPUSH
31851: CALL 104840 0 1
31855: IFFALSE 31866
// ComExitVehicle ( Friend ) ;
31857: LD_EXP 66
31861: PPUSH
31862: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31866: LD_EXP 66
31870: PPUSH
31871: LD_INT 9
31873: PPUSH
31874: LD_INT 2
31876: PPUSH
31877: CALL_OW 171
// wait ( 0 0$05 ) ;
31881: LD_INT 175
31883: PPUSH
31884: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31888: LD_EXP 66
31892: PPUSH
31893: CALL_OW 87
// DialogueOn ;
31897: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31901: LD_EXP 40
31905: PPUSH
31906: LD_STRING D16-JMM-1
31908: PPUSH
31909: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31913: LD_EXP 66
31917: PPUSH
31918: LD_STRING D16-Friend-1
31920: PPUSH
31921: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31925: LD_EXP 40
31929: PPUSH
31930: LD_STRING D16-JMM-2
31932: PPUSH
31933: CALL_OW 88
// DialogueOff ;
31937: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31941: LD_EXP 66
31945: PPUSH
31946: LD_INT 1
31948: PPUSH
31949: CALL_OW 235
// ComHold ( Friend ) ;
31953: LD_EXP 66
31957: PPUSH
31958: CALL_OW 140
// wait ( 0 0$20 ) ;
31962: LD_INT 700
31964: PPUSH
31965: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31969: LD_EXP 66
31973: PPUSH
31974: LD_INT 9
31976: PPUSH
31977: LD_INT 2
31979: PPUSH
31980: CALL_OW 297
31984: PUSH
31985: LD_INT 30
31987: LESS
31988: IFFALSE 32057
// begin SetSide ( Friend , 8 ) ;
31990: LD_EXP 66
31994: PPUSH
31995: LD_INT 8
31997: PPUSH
31998: CALL_OW 235
// if IsInUnit ( Friend ) then
32002: LD_EXP 66
32006: PPUSH
32007: CALL_OW 310
32011: IFFALSE 32022
// ComExitBuilding ( Friend ) ;
32013: LD_EXP 66
32017: PPUSH
32018: CALL_OW 122
// if IsDriver ( Friend ) then
32022: LD_EXP 66
32026: PPUSH
32027: CALL 104840 0 1
32031: IFFALSE 32042
// ComExitVehicle ( Friend ) ;
32033: LD_EXP 66
32037: PPUSH
32038: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32042: LD_EXP 66
32046: PPUSH
32047: LD_INT 9
32049: PPUSH
32050: LD_INT 2
32052: PPUSH
32053: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
32057: LD_INT 1050
32059: PPUSH
32060: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32064: LD_INT 22
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 34
32076: PUSH
32077: LD_INT 8
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PPUSH
32088: CALL_OW 69
32092: NOT
32093: IFFALSE 32439
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
32095: LD_ADDR_VAR 0 3
32099: PUSH
32100: LD_INT 22
32102: PUSH
32103: LD_INT 1
32105: PUSH
32106: EMPTY
32107: LIST
32108: LIST
32109: PUSH
32110: LD_INT 26
32112: PUSH
32113: LD_INT 1
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 3
32122: PUSH
32123: LD_INT 25
32125: PUSH
32126: LD_INT 12
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 25
32135: PUSH
32136: LD_INT 16
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: LIST
32152: PPUSH
32153: CALL_OW 69
32157: PUSH
32158: LD_EXP 40
32162: PUSH
32163: LD_EXP 42
32167: PUSH
32168: LD_EXP 56
32172: PUSH
32173: LD_EXP 43
32177: PUSH
32178: LD_EXP 44
32182: PUSH
32183: LD_EXP 45
32187: PUSH
32188: LD_EXP 46
32192: PUSH
32193: LD_EXP 47
32197: PUSH
32198: LD_EXP 48
32202: PUSH
32203: LD_EXP 49
32207: PUSH
32208: LD_EXP 50
32212: PUSH
32213: LD_EXP 51
32217: PUSH
32218: LD_EXP 52
32222: PUSH
32223: LD_EXP 53
32227: PUSH
32228: LD_EXP 54
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: DIFF
32250: ST_TO_ADDR
// DialogueOn ;
32251: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
32255: LD_EXP 68
32259: PPUSH
32260: LD_STRING D16a-Pla-1
32262: PPUSH
32263: CALL_OW 94
// if Stevens then
32267: LD_EXP 42
32271: IFFALSE 32287
// Say ( Stevens , D16a-Huck-1 ) else
32273: LD_EXP 42
32277: PPUSH
32278: LD_STRING D16a-Huck-1
32280: PPUSH
32281: CALL_OW 88
32285: GO 32329
// if Baker then
32287: LD_EXP 56
32291: IFFALSE 32307
// Say ( Baker , D16a-Huck-1 ) else
32293: LD_EXP 56
32297: PPUSH
32298: LD_STRING D16a-Huck-1
32300: PPUSH
32301: CALL_OW 88
32305: GO 32329
// if tmp then
32307: LD_VAR 0 3
32311: IFFALSE 32329
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
32313: LD_VAR 0 3
32317: PUSH
32318: LD_INT 1
32320: ARRAY
32321: PPUSH
32322: LD_STRING D16a-Sol1-1
32324: PPUSH
32325: CALL_OW 88
// if GetSide ( Friend ) = 8 then
32329: LD_EXP 66
32333: PPUSH
32334: CALL_OW 255
32338: PUSH
32339: LD_INT 8
32341: EQUAL
32342: IFFALSE 32358
// Say ( JMM , D16a-JMM-1 ) else
32344: LD_EXP 40
32348: PPUSH
32349: LD_STRING D16a-JMM-1
32351: PPUSH
32352: CALL_OW 88
32356: GO 32418
// begin Say ( JMM , D16a-JMM-1a ) ;
32358: LD_EXP 40
32362: PPUSH
32363: LD_STRING D16a-JMM-1a
32365: PPUSH
32366: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
32370: LD_EXP 66
32374: PPUSH
32375: LD_STRING D16a-Friend-1
32377: PPUSH
32378: CALL_OW 88
// ComExitBuilding ( Friend ) ;
32382: LD_EXP 66
32386: PPUSH
32387: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
32391: LD_EXP 66
32395: PPUSH
32396: LD_INT 191
32398: PPUSH
32399: LD_INT 103
32401: PPUSH
32402: CALL_OW 171
// SetSide ( Friend , 3 ) ;
32406: LD_EXP 66
32410: PPUSH
32411: LD_INT 3
32413: PPUSH
32414: CALL_OW 235
// end ; DialogueOff ;
32418: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
32422: LD_VAR 0 1
32426: PPUSH
32427: LD_INT 60
32429: PPUSH
32430: LD_INT 95
32432: PPUSH
32433: CALL_OW 116
// end else
32437: GO 32459
// begin DialogueOn ;
32439: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32443: LD_EXP 68
32447: PPUSH
32448: LD_STRING D16c-Pla-1
32450: PPUSH
32451: CALL_OW 94
// DialogueOff ;
32455: CALL_OW 7
// end ; end else
32459: GO 32560
// begin wait ( 3 3$00 ) ;
32461: LD_INT 6300
32463: PPUSH
32464: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32468: LD_INT 22
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 34
32480: PUSH
32481: LD_INT 8
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PPUSH
32492: CALL_OW 69
32496: NOT
32497: IFFALSE 32540
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
32499: LD_EXP 68
32503: PPUSH
32504: LD_STRING D16b-Pla-1
32506: PPUSH
32507: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
32511: LD_EXP 40
32515: PPUSH
32516: LD_STRING D16b-JMM-1
32518: PPUSH
32519: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
32523: LD_VAR 0 1
32527: PPUSH
32528: LD_INT 60
32530: PPUSH
32531: LD_INT 95
32533: PPUSH
32534: CALL_OW 116
// end else
32538: GO 32560
// begin DialogueOn ;
32540: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
32544: LD_EXP 68
32548: PPUSH
32549: LD_STRING D16c-Pla-1
32551: PPUSH
32552: CALL_OW 94
// DialogueOff ;
32556: CALL_OW 7
// end ; end ; end ;
32560: PPOPN 3
32562: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32563: LD_INT 25
32565: PPUSH
32566: LD_INT 1
32568: PPUSH
32569: CALL_OW 321
32573: PUSH
32574: LD_INT 2
32576: EQUAL
32577: PUSH
32578: LD_EXP 14
32582: PUSH
32583: LD_INT 126000
32585: GREATEREQUAL
32586: OR
32587: PUSH
32588: LD_EXP 23
32592: NOT
32593: AND
32594: PUSH
32595: LD_EXP 79
32599: PPUSH
32600: CALL_OW 302
32604: AND
32605: IFFALSE 32963
32607: GO 32609
32609: DISABLE
32610: LD_INT 0
32612: PPUSH
// begin missionStage := 11 ;
32613: LD_ADDR_EXP 15
32617: PUSH
32618: LD_INT 11
32620: ST_TO_ADDR
// DialogueOn ;
32621: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32625: LD_EXP 79
32629: PPUSH
32630: LD_STRING D9-Roth-1
32632: PPUSH
32633: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32637: LD_EXP 40
32641: PPUSH
32642: LD_STRING D9-JMM-1
32644: PPUSH
32645: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32649: LD_EXP 79
32653: PPUSH
32654: LD_STRING D9-Roth-2
32656: PPUSH
32657: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32661: LD_EXP 79
32665: PPUSH
32666: LD_STRING D9-Roth-2a
32668: PPUSH
32669: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32673: LD_EXP 68
32677: PPUSH
32678: LD_STRING D9-Pla-2
32680: PPUSH
32681: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32685: LD_EXP 79
32689: PPUSH
32690: LD_STRING D9-Roth-3
32692: PPUSH
32693: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32697: LD_EXP 68
32701: PPUSH
32702: LD_STRING D9-Pla-3
32704: PPUSH
32705: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32709: LD_EXP 79
32713: PPUSH
32714: LD_STRING D9-Roth-4
32716: PPUSH
32717: CALL_OW 94
// dec := Query ( Q9 ) ;
32721: LD_ADDR_VAR 0 1
32725: PUSH
32726: LD_STRING Q9
32728: PPUSH
32729: CALL_OW 97
32733: ST_TO_ADDR
// if dec = 1 then
32734: LD_VAR 0 1
32738: PUSH
32739: LD_INT 1
32741: EQUAL
32742: IFFALSE 32756
// SayRadio ( Roth , D9a-Roth-1 ) ;
32744: LD_EXP 79
32748: PPUSH
32749: LD_STRING D9a-Roth-1
32751: PPUSH
32752: CALL_OW 94
// if dec = 2 then
32756: LD_VAR 0 1
32760: PUSH
32761: LD_INT 2
32763: EQUAL
32764: IFFALSE 32790
// begin Say ( JMM , D9b-JMM-1 ) ;
32766: LD_EXP 40
32770: PPUSH
32771: LD_STRING D9b-JMM-1
32773: PPUSH
32774: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32778: LD_EXP 79
32782: PPUSH
32783: LD_STRING D9b-Roth-1
32785: PPUSH
32786: CALL_OW 94
// end ; if dec = 3 then
32790: LD_VAR 0 1
32794: PUSH
32795: LD_INT 3
32797: EQUAL
32798: IFFALSE 32860
// begin Say ( JMM , D9c-JMM-1 ) ;
32800: LD_EXP 40
32804: PPUSH
32805: LD_STRING D9c-JMM-1
32807: PPUSH
32808: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32812: LD_EXP 79
32816: PPUSH
32817: LD_STRING D9c-Roth-1
32819: PPUSH
32820: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32824: LD_EXP 40
32828: PPUSH
32829: LD_STRING D9c-JMM-2
32831: PPUSH
32832: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32836: LD_EXP 79
32840: PPUSH
32841: LD_STRING D9c-Roth-2
32843: PPUSH
32844: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32848: LD_EXP 40
32852: PPUSH
32853: LD_STRING D9c-JMM-3
32855: PPUSH
32856: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32860: LD_EXP 79
32864: PPUSH
32865: LD_STRING D9c-Roth-3
32867: PPUSH
32868: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32872: LD_EXP 79
32876: PPUSH
32877: LD_STRING D9cont-Roth-1
32879: PPUSH
32880: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32884: LD_EXP 40
32888: PPUSH
32889: LD_STRING D9cont-JMM-1
32891: PPUSH
32892: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32896: LD_EXP 79
32900: PPUSH
32901: LD_STRING D9cont-Roth-2
32903: PPUSH
32904: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32908: LD_EXP 40
32912: PPUSH
32913: LD_STRING D9cont-JMM-2
32915: PPUSH
32916: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32920: LD_EXP 79
32924: PPUSH
32925: LD_STRING D9cont-Roth-3
32927: PPUSH
32928: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32932: LD_EXP 40
32936: PPUSH
32937: LD_STRING D9cont-JMM-3
32939: PPUSH
32940: CALL_OW 88
// DialogueOff ;
32944: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32948: LD_STRING M3
32950: PPUSH
32951: CALL_OW 337
// allianceActive := true ;
32955: LD_ADDR_EXP 31
32959: PUSH
32960: LD_INT 1
32962: ST_TO_ADDR
// end ;
32963: PPOPN 1
32965: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32966: LD_INT 1
32968: PPUSH
32969: LD_INT 126
32971: PPUSH
32972: CALL_OW 292
32976: PUSH
32977: LD_EXP 68
32981: PPUSH
32982: CALL_OW 310
32986: AND
32987: IFFALSE 33140
32989: GO 32991
32991: DISABLE
32992: LD_INT 0
32994: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32995: LD_EXP 68
32999: PPUSH
33000: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33004: LD_ADDR_VAR 0 1
33008: PUSH
33009: LD_INT 4
33011: PPUSH
33012: LD_INT 22
33014: PUSH
33015: LD_INT 1
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PPUSH
33022: CALL_OW 70
33026: PPUSH
33027: LD_EXP 68
33031: PPUSH
33032: CALL_OW 74
33036: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
33037: LD_EXP 68
33041: PPUSH
33042: LD_VAR 0 1
33046: PUSH
33047: LD_INT 1
33049: ARRAY
33050: PPUSH
33051: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
33055: LD_EXP 68
33059: PPUSH
33060: LD_STRING D18-Pla-1
33062: PPUSH
33063: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
33067: LD_INT 22
33069: PUSH
33070: LD_INT 3
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 34
33079: PUSH
33080: LD_INT 48
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PPUSH
33091: CALL_OW 69
33095: IFFALSE 33140
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
33097: LD_INT 22
33099: PUSH
33100: LD_INT 3
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 34
33109: PUSH
33110: LD_INT 48
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PPUSH
33121: CALL_OW 69
33125: PUSH
33126: LD_INT 1
33128: ARRAY
33129: PPUSH
33130: LD_INT 111
33132: PPUSH
33133: LD_INT 97
33135: PPUSH
33136: CALL_OW 116
// end ;
33140: PPOPN 1
33142: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
33143: LD_EXP 68
33147: PPUSH
33148: CALL_OW 301
33152: PUSH
33153: LD_EXP 71
33157: PPUSH
33158: CALL_OW 301
33162: AND
33163: PUSH
33164: LD_INT 22
33166: PUSH
33167: LD_INT 3
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 21
33176: PUSH
33177: LD_INT 1
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: LD_INT 50
33186: PUSH
33187: EMPTY
33188: LIST
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: LIST
33194: PPUSH
33195: CALL_OW 69
33199: PUSH
33200: LD_INT 7
33202: PUSH
33203: LD_INT 8
33205: PUSH
33206: LD_INT 9
33208: PUSH
33209: LD_INT 10
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: PUSH
33218: LD_OWVAR 67
33222: ARRAY
33223: LESS
33224: AND
33225: IFFALSE 34024
33227: GO 33229
33229: DISABLE
33230: LD_INT 0
33232: PPUSH
33233: PPUSH
33234: PPUSH
33235: PPUSH
// begin MC_Kill ( 2 ) ;
33236: LD_INT 2
33238: PPUSH
33239: CALL 39094 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
33243: LD_INT 1
33245: PPUSH
33246: LD_INT 3
33248: PPUSH
33249: LD_INT 1
33251: PPUSH
33252: LD_INT 1
33254: PPUSH
33255: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
33259: LD_ADDR_VAR 0 2
33263: PUSH
33264: LD_INT 22
33266: PUSH
33267: LD_INT 3
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 21
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 50
33286: PUSH
33287: EMPTY
33288: LIST
33289: PUSH
33290: LD_INT 26
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: PPUSH
33306: CALL_OW 69
33310: ST_TO_ADDR
// if not tmp then
33311: LD_VAR 0 2
33315: NOT
33316: IFFALSE 33372
// begin uc_side = 3 ;
33318: LD_ADDR_OWVAR 20
33322: PUSH
33323: LD_INT 3
33325: ST_TO_ADDR
// uc_nation = 3 ;
33326: LD_ADDR_OWVAR 21
33330: PUSH
33331: LD_INT 3
33333: ST_TO_ADDR
// hc_name =  ;
33334: LD_ADDR_OWVAR 26
33338: PUSH
33339: LD_STRING 
33341: ST_TO_ADDR
// hc_gallery =  ;
33342: LD_ADDR_OWVAR 33
33346: PUSH
33347: LD_STRING 
33349: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
33350: LD_INT 1
33352: PPUSH
33353: LD_INT 10
33355: PPUSH
33356: CALL_OW 381
// tmp = CreateHuman ;
33360: LD_ADDR_VAR 0 2
33364: PUSH
33365: CALL_OW 44
33369: ST_TO_ADDR
// end else
33370: GO 33386
// tmp := tmp [ 1 ] ;
33372: LD_ADDR_VAR 0 2
33376: PUSH
33377: LD_VAR 0 2
33381: PUSH
33382: LD_INT 1
33384: ARRAY
33385: ST_TO_ADDR
// DialogueOn ;
33386: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
33390: LD_VAR 0 2
33394: PPUSH
33395: LD_STRING DSurrenderRussians-RSol1-1a
33397: PPUSH
33398: CALL_OW 94
// DialogueOff ;
33402: CALL_OW 7
// russianDestroyed := true ;
33406: LD_ADDR_EXP 21
33410: PUSH
33411: LD_INT 1
33413: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
33414: LD_ADDR_VAR 0 1
33418: PUSH
33419: LD_INT 22
33421: PUSH
33422: LD_INT 6
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PPUSH
33429: CALL_OW 69
33433: PUSH
33434: FOR_IN
33435: IFFALSE 33448
// KillUnit ( i ) ;
33437: LD_VAR 0 1
33441: PPUSH
33442: CALL_OW 66
33446: GO 33434
33448: POP
33449: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
33450: LD_INT 22
33452: PUSH
33453: LD_INT 3
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: LD_INT 21
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PPUSH
33474: CALL_OW 69
33478: PPUSH
33479: CALL_OW 122
// wait ( 0 0$1 ) ;
33483: LD_INT 35
33485: PPUSH
33486: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
33490: LD_INT 22
33492: PUSH
33493: LD_INT 3
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 21
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PPUSH
33514: CALL_OW 69
33518: PPUSH
33519: LD_INT 25
33521: PPUSH
33522: CALL_OW 173
// wait ( 0 0$35 ) ;
33526: LD_INT 1225
33528: PPUSH
33529: CALL_OW 67
// PrepareOmarInvasion ;
33533: CALL 16250 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
33537: LD_ADDR_VAR 0 2
33541: PUSH
33542: LD_EXP 97
33546: PPUSH
33547: CALL_OW 250
33551: PUSH
33552: LD_EXP 97
33556: PPUSH
33557: CALL_OW 251
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33566: LD_VAR 0 2
33570: PUSH
33571: LD_INT 1
33573: ARRAY
33574: PPUSH
33575: LD_VAR 0 2
33579: PUSH
33580: LD_INT 2
33582: ARRAY
33583: PPUSH
33584: LD_INT 1
33586: PPUSH
33587: LD_INT 8
33589: NEG
33590: PPUSH
33591: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33595: LD_EXP 97
33599: PPUSH
33600: CALL_OW 87
// DialogueOn ;
33604: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33608: LD_EXP 40
33612: PPUSH
33613: LD_STRING D19-JMM-1
33615: PPUSH
33616: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33620: LD_ADDR_VAR 0 3
33624: PUSH
33625: LD_INT 22
33627: PUSH
33628: LD_INT 1
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 26
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: PUSH
33648: LD_INT 25
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 25
33660: PUSH
33661: LD_INT 2
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 25
33670: PUSH
33671: LD_INT 3
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 25
33680: PUSH
33681: LD_INT 4
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 25
33690: PUSH
33691: LD_INT 5
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 25
33700: PUSH
33701: LD_INT 8
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: LIST
33721: PPUSH
33722: CALL_OW 69
33726: PUSH
33727: LD_EXP 40
33731: PUSH
33732: LD_EXP 41
33736: PUSH
33737: LD_EXP 64
33741: PUSH
33742: LD_EXP 42
33746: PUSH
33747: LD_EXP 43
33751: PUSH
33752: LD_EXP 44
33756: PUSH
33757: LD_EXP 45
33761: PUSH
33762: LD_EXP 46
33766: PUSH
33767: LD_EXP 47
33771: PUSH
33772: LD_EXP 48
33776: PUSH
33777: LD_EXP 49
33781: PUSH
33782: LD_EXP 50
33786: PUSH
33787: LD_EXP 51
33791: PUSH
33792: LD_EXP 52
33796: PUSH
33797: LD_EXP 53
33801: PUSH
33802: LD_EXP 54
33806: PUSH
33807: LD_EXP 55
33811: PUSH
33812: LD_EXP 56
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: DIFF
33837: ST_TO_ADDR
// if tmp2 then
33838: LD_VAR 0 3
33842: IFFALSE 33860
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33844: LD_VAR 0 3
33848: PUSH
33849: LD_INT 1
33851: ARRAY
33852: PPUSH
33853: LD_STRING D19-Sol1-1
33855: PPUSH
33856: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33860: LD_EXP 40
33864: PPUSH
33865: LD_STRING D19-JMM-2
33867: PPUSH
33868: CALL_OW 88
// DialogueOff ;
33872: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33876: LD_VAR 0 2
33880: PUSH
33881: LD_INT 1
33883: ARRAY
33884: PPUSH
33885: LD_VAR 0 2
33889: PUSH
33890: LD_INT 2
33892: ARRAY
33893: PPUSH
33894: LD_INT 1
33896: PPUSH
33897: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33901: LD_STRING M5
33903: PPUSH
33904: CALL_OW 337
// omarOnMotherLode := false ;
33908: LD_ADDR_VAR 0 4
33912: PUSH
33913: LD_INT 0
33915: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33916: LD_INT 35
33918: PPUSH
33919: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33923: LD_EXP 97
33927: PPUSH
33928: LD_INT 215
33930: PPUSH
33931: LD_INT 100
33933: PPUSH
33934: CALL_OW 297
33938: PUSH
33939: LD_INT 10
33941: LESS
33942: PUSH
33943: LD_VAR 0 4
33947: NOT
33948: AND
33949: IFFALSE 33983
// begin omarOnMotherLode := true ;
33951: LD_ADDR_VAR 0 4
33955: PUSH
33956: LD_INT 1
33958: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33959: LD_EXP 40
33963: PPUSH
33964: LD_STRING D19b-JMM-1
33966: PPUSH
33967: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33971: LD_EXP 97
33975: PPUSH
33976: LD_STRING DOmarContam-Omar-1
33978: PPUSH
33979: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33983: LD_EXP 97
33987: PPUSH
33988: CALL_OW 301
33992: IFFALSE 33916
// Say ( JMM , D19a-JMM-1 ) ;
33994: LD_EXP 40
33998: PPUSH
33999: LD_STRING D19a-JMM-1
34001: PPUSH
34002: CALL_OW 88
// if Heike then
34006: LD_EXP 98
34010: IFFALSE 34024
// Say ( Heike , D19a-Hke-1 ) ;
34012: LD_EXP 98
34016: PPUSH
34017: LD_STRING D19a-Hke-1
34019: PPUSH
34020: CALL_OW 88
// end ;
34024: PPOPN 4
34026: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
34027: LD_INT 22
34029: PUSH
34030: LD_INT 3
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 21
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PPUSH
34051: CALL_OW 69
34055: PUSH
34056: LD_EXP 21
34060: AND
34061: IFFALSE 34129
34063: GO 34065
34065: DISABLE
34066: LD_INT 0
34068: PPUSH
34069: PPUSH
// begin enable ;
34070: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
34071: LD_ADDR_VAR 0 2
34075: PUSH
34076: LD_INT 25
34078: PPUSH
34079: LD_INT 22
34081: PUSH
34082: LD_INT 3
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PPUSH
34089: CALL_OW 70
34093: ST_TO_ADDR
// if not tmp then
34094: LD_VAR 0 2
34098: NOT
34099: IFFALSE 34103
// exit ;
34101: GO 34129
// for i in tmp do
34103: LD_ADDR_VAR 0 1
34107: PUSH
34108: LD_VAR 0 2
34112: PUSH
34113: FOR_IN
34114: IFFALSE 34127
// RemoveUnit ( i ) ;
34116: LD_VAR 0 1
34120: PPUSH
34121: CALL_OW 64
34125: GO 34113
34127: POP
34128: POP
// end ;
34129: PPOPN 2
34131: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
34132: LD_INT 22
34134: PUSH
34135: LD_INT 7
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 21
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PPUSH
34156: CALL_OW 69
34160: PUSH
34161: LD_INT 6
34163: LESS
34164: IFFALSE 34632
34166: GO 34168
34168: DISABLE
34169: LD_INT 0
34171: PPUSH
34172: PPUSH
// begin MC_Kill ( 1 ) ;
34173: LD_INT 1
34175: PPUSH
34176: CALL 39094 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
34180: LD_INT 7
34182: PPUSH
34183: LD_INT 1
34185: PPUSH
34186: LD_INT 1
34188: PPUSH
34189: LD_INT 1
34191: PPUSH
34192: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
34196: LD_ADDR_VAR 0 1
34200: PUSH
34201: LD_INT 22
34203: PUSH
34204: LD_INT 7
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 26
34213: PUSH
34214: LD_INT 1
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PPUSH
34225: CALL_OW 69
34229: PUSH
34230: LD_EXP 79
34234: DIFF
34235: ST_TO_ADDR
// if tmp then
34236: LD_VAR 0 1
34240: IFFALSE 34258
// tmp := tmp [ 1 ] else
34242: LD_ADDR_VAR 0 1
34246: PUSH
34247: LD_VAR 0 1
34251: PUSH
34252: LD_INT 1
34254: ARRAY
34255: ST_TO_ADDR
34256: GO 34294
// begin uc_side := 7 ;
34258: LD_ADDR_OWVAR 20
34262: PUSH
34263: LD_INT 7
34265: ST_TO_ADDR
// uc_nation := 1 ;
34266: LD_ADDR_OWVAR 21
34270: PUSH
34271: LD_INT 1
34273: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
34274: LD_INT 1
34276: PPUSH
34277: LD_INT 8
34279: PPUSH
34280: CALL_OW 384
// tmp := CreateHuman ;
34284: LD_ADDR_VAR 0 1
34288: PUSH
34289: CALL_OW 44
34293: ST_TO_ADDR
// end ; DialogueOn ;
34294: CALL_OW 6
// if IsOK ( Roth ) then
34298: LD_EXP 79
34302: PPUSH
34303: CALL_OW 302
34307: IFFALSE 34321
// Say ( JMM , DAb-JMM-1 ) ;
34309: LD_EXP 40
34313: PPUSH
34314: LD_STRING DAb-JMM-1
34316: PPUSH
34317: CALL_OW 88
// if IsOK ( Roth ) then
34321: LD_EXP 79
34325: PPUSH
34326: CALL_OW 302
34330: IFFALSE 34354
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
34332: LD_EXP 79
34336: PPUSH
34337: LD_STRING DSurrenderAlliance-Roth-1
34339: PPUSH
34340: CALL_OW 88
// RothCaptured := true ;
34344: LD_ADDR_EXP 33
34348: PUSH
34349: LD_INT 1
34351: ST_TO_ADDR
// end else
34352: GO 34366
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
34354: LD_VAR 0 1
34358: PPUSH
34359: LD_STRING DSurrenderAlliance-Sci1-1
34361: PPUSH
34362: CALL_OW 88
// DialogueOff ;
34366: CALL_OW 7
// allianceDestroyed := true ;
34370: LD_ADDR_EXP 23
34374: PUSH
34375: LD_INT 1
34377: ST_TO_ADDR
// if capturedUnit = 0 then
34378: LD_EXP 34
34382: PUSH
34383: LD_INT 0
34385: EQUAL
34386: IFFALSE 34395
// SetAchievement ( ACH_ALLIANCE ) ;
34388: LD_STRING ACH_ALLIANCE
34390: PPUSH
34391: CALL_OW 543
// if trueAmericans then
34395: LD_EXP 35
34399: IFFALSE 34475
// begin if trueAmericans = 1 then
34401: LD_EXP 35
34405: PUSH
34406: LD_INT 1
34408: EQUAL
34409: IFFALSE 34425
// Say ( JMM , DAb-JMM-1a ) else
34411: LD_EXP 40
34415: PPUSH
34416: LD_STRING DAb-JMM-1a
34418: PPUSH
34419: CALL_OW 88
34423: GO 34437
// Say ( JMM , DAb-JMM-1b ) ;
34425: LD_EXP 40
34429: PPUSH
34430: LD_STRING DAb-JMM-1b
34432: PPUSH
34433: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
34437: LD_EXP 35
34441: PPUSH
34442: CALL_OW 87
// for i in trueAmericans do
34446: LD_ADDR_VAR 0 2
34450: PUSH
34451: LD_EXP 35
34455: PUSH
34456: FOR_IN
34457: IFFALSE 34473
// SetSide ( i , 1 ) ;
34459: LD_VAR 0 2
34463: PPUSH
34464: LD_INT 1
34466: PPUSH
34467: CALL_OW 235
34471: GO 34456
34473: POP
34474: POP
// end ; repeat wait ( 0 0$1 ) ;
34475: LD_INT 35
34477: PPUSH
34478: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
34482: LD_ADDR_VAR 0 2
34486: PUSH
34487: LD_INT 22
34489: PUSH
34490: LD_INT 7
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 21
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PPUSH
34511: CALL_OW 69
34515: PUSH
34516: FOR_IN
34517: IFFALSE 34599
// begin if IsInUnit ( i ) then
34519: LD_VAR 0 2
34523: PPUSH
34524: CALL_OW 310
34528: IFFALSE 34539
// ComExitBuilding ( i ) ;
34530: LD_VAR 0 2
34534: PPUSH
34535: CALL_OW 122
// if IsDriver ( i ) then
34539: LD_VAR 0 2
34543: PPUSH
34544: CALL 104840 0 1
34548: IFFALSE 34559
// ComExitVehicle ( i ) ;
34550: LD_VAR 0 2
34554: PPUSH
34555: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34559: LD_VAR 0 2
34563: PPUSH
34564: LD_INT 26
34566: PPUSH
34567: CALL_OW 308
34571: NOT
34572: IFFALSE 34588
// AddComMoveToArea ( i , allianceEscapeArea ) else
34574: LD_VAR 0 2
34578: PPUSH
34579: LD_INT 26
34581: PPUSH
34582: CALL_OW 173
34586: GO 34597
// RemoveUnit ( i ) ;
34588: LD_VAR 0 2
34592: PPUSH
34593: CALL_OW 64
// end ;
34597: GO 34516
34599: POP
34600: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34601: LD_INT 22
34603: PUSH
34604: LD_INT 7
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 21
34613: PUSH
34614: LD_INT 1
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PPUSH
34625: CALL_OW 69
34629: NOT
34630: IFFALSE 34475
// end ;
34632: PPOPN 2
34634: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34635: LD_INT 0
34637: PPUSH
34638: PPUSH
// if not unit then
34639: LD_VAR 0 1
34643: NOT
34644: IFFALSE 34648
// exit ;
34646: GO 36162
// DoNotAttack ( 7 , unit ) ;
34648: LD_INT 7
34650: PPUSH
34651: LD_VAR 0 1
34655: PPUSH
34656: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34660: LD_VAR 0 1
34664: PPUSH
34665: LD_INT 260
34667: PPUSH
34668: LD_INT 235
34670: PPUSH
34671: LD_INT 3
34673: PPUSH
34674: LD_INT 1
34676: PPUSH
34677: CALL_OW 483
// SetSide ( unit , 4 ) ;
34681: LD_VAR 0 1
34685: PPUSH
34686: LD_INT 4
34688: PPUSH
34689: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34693: LD_ADDR_EXP 34
34697: PUSH
34698: LD_EXP 34
34702: PUSH
34703: LD_INT 1
34705: PLUS
34706: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34707: LD_INT 70
34709: PPUSH
34710: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34714: LD_INT 260
34716: PPUSH
34717: LD_INT 235
34719: PPUSH
34720: LD_INT 1
34722: PPUSH
34723: LD_INT 8
34725: NEG
34726: PPUSH
34727: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34731: LD_VAR 0 1
34735: PPUSH
34736: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34740: LD_VAR 0 1
34744: PPUSH
34745: LD_EXP 79
34749: PPUSH
34750: CALL_OW 119
// DialogueOn ;
34754: CALL_OW 6
// case unit of JMM :
34758: LD_VAR 0 1
34762: PUSH
34763: LD_EXP 40
34767: DOUBLE
34768: EQUAL
34769: IFTRUE 34773
34771: GO 34788
34773: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34774: LD_EXP 40
34778: PPUSH
34779: LD_STRING DA1-JMM-1
34781: PPUSH
34782: CALL_OW 91
34786: GO 35230
34788: LD_EXP 41
34792: DOUBLE
34793: EQUAL
34794: IFTRUE 34798
34796: GO 34813
34798: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34799: LD_EXP 41
34803: PPUSH
34804: LD_STRING DA1-Joan-1
34806: PPUSH
34807: CALL_OW 91
34811: GO 35230
34813: LD_EXP 43
34817: DOUBLE
34818: EQUAL
34819: IFTRUE 34823
34821: GO 34838
34823: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34824: LD_EXP 43
34828: PPUSH
34829: LD_STRING DA1-Lisa-1
34831: PPUSH
34832: CALL_OW 91
34836: GO 35230
34838: LD_EXP 44
34842: DOUBLE
34843: EQUAL
34844: IFTRUE 34848
34846: GO 34863
34848: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34849: LD_EXP 44
34853: PPUSH
34854: LD_STRING DA1-Don-1
34856: PPUSH
34857: CALL_OW 91
34861: GO 35230
34863: LD_EXP 51
34867: DOUBLE
34868: EQUAL
34869: IFTRUE 34873
34871: GO 34888
34873: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34874: LD_EXP 51
34878: PPUSH
34879: LD_STRING DA1-Corn-1
34881: PPUSH
34882: CALL_OW 91
34886: GO 35230
34888: LD_EXP 47
34892: DOUBLE
34893: EQUAL
34894: IFTRUE 34898
34896: GO 34913
34898: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34899: LD_EXP 47
34903: PPUSH
34904: LD_STRING DA1-Den-1
34906: PPUSH
34907: CALL_OW 91
34911: GO 35230
34913: LD_EXP 45
34917: DOUBLE
34918: EQUAL
34919: IFTRUE 34923
34921: GO 34938
34923: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34924: LD_EXP 45
34928: PPUSH
34929: LD_STRING DA1-Bobby-1
34931: PPUSH
34932: CALL_OW 91
34936: GO 35230
34938: LD_EXP 49
34942: DOUBLE
34943: EQUAL
34944: IFTRUE 34948
34946: GO 34963
34948: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34949: LD_EXP 49
34953: PPUSH
34954: LD_STRING DA1-Glad-1
34956: PPUSH
34957: CALL_OW 91
34961: GO 35230
34963: LD_EXP 46
34967: DOUBLE
34968: EQUAL
34969: IFTRUE 34973
34971: GO 34988
34973: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34974: LD_EXP 46
34978: PPUSH
34979: LD_STRING DA1-Cyrus-1
34981: PPUSH
34982: CALL_OW 91
34986: GO 35230
34988: LD_EXP 42
34992: DOUBLE
34993: EQUAL
34994: IFTRUE 34998
34996: GO 35013
34998: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34999: LD_EXP 42
35003: PPUSH
35004: LD_STRING DA1-Huck-1
35006: PPUSH
35007: CALL_OW 91
35011: GO 35230
35013: LD_EXP 56
35017: DOUBLE
35018: EQUAL
35019: IFTRUE 35023
35021: GO 35038
35023: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
35024: LD_EXP 56
35028: PPUSH
35029: LD_STRING DA1-Huck-1
35031: PPUSH
35032: CALL_OW 91
35036: GO 35230
35038: LD_EXP 48
35042: DOUBLE
35043: EQUAL
35044: IFTRUE 35048
35046: GO 35063
35048: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
35049: LD_EXP 48
35053: PPUSH
35054: LD_STRING DA1-Brown-1
35056: PPUSH
35057: CALL_OW 91
35061: GO 35230
35063: LD_EXP 52
35067: DOUBLE
35068: EQUAL
35069: IFTRUE 35073
35071: GO 35088
35073: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
35074: LD_EXP 52
35078: PPUSH
35079: LD_STRING DA1-Gary-1
35081: PPUSH
35082: CALL_OW 91
35086: GO 35230
35088: LD_EXP 55
35092: DOUBLE
35093: EQUAL
35094: IFTRUE 35098
35096: GO 35113
35098: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
35099: LD_EXP 55
35103: PPUSH
35104: LD_STRING DA1-Con-1
35106: PPUSH
35107: CALL_OW 91
35111: GO 35230
35113: LD_EXP 64
35117: DOUBLE
35118: EQUAL
35119: IFTRUE 35123
35121: GO 35138
35123: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
35124: LD_EXP 64
35128: PPUSH
35129: LD_STRING DA1-Kurt-1
35131: PPUSH
35132: CALL_OW 91
35136: GO 35230
35138: LD_EXP 54
35142: DOUBLE
35143: EQUAL
35144: IFTRUE 35148
35146: GO 35163
35148: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
35149: LD_EXP 54
35153: PPUSH
35154: LD_STRING DA1-Yam-1
35156: PPUSH
35157: CALL_OW 91
35161: GO 35230
35163: LD_EXP 53
35167: DOUBLE
35168: EQUAL
35169: IFTRUE 35173
35171: GO 35188
35173: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
35174: LD_EXP 53
35178: PPUSH
35179: LD_STRING DA1-Frank-1
35181: PPUSH
35182: CALL_OW 91
35186: GO 35230
35188: POP
// begin if GetSex ( unit ) = sex_male then
35189: LD_VAR 0 1
35193: PPUSH
35194: CALL_OW 258
35198: PUSH
35199: LD_INT 1
35201: EQUAL
35202: IFFALSE 35218
// ForceSay ( unit , DA1-Sol1-1 ) else
35204: LD_VAR 0 1
35208: PPUSH
35209: LD_STRING DA1-Sol1-1
35211: PPUSH
35212: CALL_OW 91
35216: GO 35230
// ForceSay ( unit , DA1-FSol1-1 ) ;
35218: LD_VAR 0 1
35222: PPUSH
35223: LD_STRING DA1-FSol1-1
35225: PPUSH
35226: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
35230: LD_EXP 79
35234: PPUSH
35235: LD_STRING DA-Roth-1
35237: PPUSH
35238: CALL_OW 88
// if capturedUnit = 1 then
35242: LD_EXP 34
35246: PUSH
35247: LD_INT 1
35249: EQUAL
35250: IFFALSE 35278
// begin Say ( Simms , DA-Sim-1 ) ;
35252: LD_EXP 80
35256: PPUSH
35257: LD_STRING DA-Sim-1
35259: PPUSH
35260: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
35264: LD_EXP 79
35268: PPUSH
35269: LD_STRING DA-Roth-2
35271: PPUSH
35272: CALL_OW 88
// end else
35276: GO 35290
// Say ( Simms , DA-Sim-2 ) ;
35278: LD_EXP 80
35282: PPUSH
35283: LD_STRING DA-Sim-2
35285: PPUSH
35286: CALL_OW 88
// case unit of JMM :
35290: LD_VAR 0 1
35294: PUSH
35295: LD_EXP 40
35299: DOUBLE
35300: EQUAL
35301: IFTRUE 35305
35303: GO 35320
35305: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
35306: LD_EXP 40
35310: PPUSH
35311: LD_STRING DA1-JMM-1a
35313: PPUSH
35314: CALL_OW 91
35318: GO 35837
35320: LD_EXP 41
35324: DOUBLE
35325: EQUAL
35326: IFTRUE 35330
35328: GO 35345
35330: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
35331: LD_EXP 41
35335: PPUSH
35336: LD_STRING DA1-Joan-1a
35338: PPUSH
35339: CALL_OW 91
35343: GO 35837
35345: LD_EXP 43
35349: DOUBLE
35350: EQUAL
35351: IFTRUE 35355
35353: GO 35370
35355: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
35356: LD_EXP 43
35360: PPUSH
35361: LD_STRING DA1-Lisa-1a
35363: PPUSH
35364: CALL_OW 91
35368: GO 35837
35370: LD_EXP 44
35374: DOUBLE
35375: EQUAL
35376: IFTRUE 35380
35378: GO 35395
35380: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
35381: LD_EXP 44
35385: PPUSH
35386: LD_STRING DA1-Don-1a
35388: PPUSH
35389: CALL_OW 91
35393: GO 35837
35395: LD_EXP 51
35399: DOUBLE
35400: EQUAL
35401: IFTRUE 35405
35403: GO 35420
35405: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
35406: LD_EXP 51
35410: PPUSH
35411: LD_STRING DA1-Corn-1a
35413: PPUSH
35414: CALL_OW 91
35418: GO 35837
35420: LD_EXP 47
35424: DOUBLE
35425: EQUAL
35426: IFTRUE 35430
35428: GO 35445
35430: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
35431: LD_EXP 47
35435: PPUSH
35436: LD_STRING DA1-Den-1a
35438: PPUSH
35439: CALL_OW 91
35443: GO 35837
35445: LD_EXP 45
35449: DOUBLE
35450: EQUAL
35451: IFTRUE 35455
35453: GO 35470
35455: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
35456: LD_EXP 45
35460: PPUSH
35461: LD_STRING DA1-Bobby-1a
35463: PPUSH
35464: CALL_OW 91
35468: GO 35837
35470: LD_EXP 49
35474: DOUBLE
35475: EQUAL
35476: IFTRUE 35480
35478: GO 35495
35480: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
35481: LD_EXP 49
35485: PPUSH
35486: LD_STRING DA1-Glad-1a
35488: PPUSH
35489: CALL_OW 91
35493: GO 35837
35495: LD_EXP 46
35499: DOUBLE
35500: EQUAL
35501: IFTRUE 35505
35503: GO 35520
35505: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
35506: LD_EXP 46
35510: PPUSH
35511: LD_STRING DA1-Cyrus-1a
35513: PPUSH
35514: CALL_OW 91
35518: GO 35837
35520: LD_EXP 42
35524: DOUBLE
35525: EQUAL
35526: IFTRUE 35530
35528: GO 35545
35530: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
35531: LD_EXP 42
35535: PPUSH
35536: LD_STRING DA1-Huck-1a
35538: PPUSH
35539: CALL_OW 91
35543: GO 35837
35545: LD_EXP 56
35549: DOUBLE
35550: EQUAL
35551: IFTRUE 35555
35553: GO 35570
35555: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35556: LD_EXP 56
35560: PPUSH
35561: LD_STRING DA1-Huck-1a
35563: PPUSH
35564: CALL_OW 91
35568: GO 35837
35570: LD_EXP 48
35574: DOUBLE
35575: EQUAL
35576: IFTRUE 35580
35578: GO 35595
35580: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35581: LD_EXP 48
35585: PPUSH
35586: LD_STRING DA1-Brown-1a
35588: PPUSH
35589: CALL_OW 91
35593: GO 35837
35595: LD_EXP 52
35599: DOUBLE
35600: EQUAL
35601: IFTRUE 35605
35603: GO 35620
35605: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35606: LD_EXP 52
35610: PPUSH
35611: LD_STRING DA1-Gary-1a
35613: PPUSH
35614: CALL_OW 91
35618: GO 35837
35620: LD_EXP 55
35624: DOUBLE
35625: EQUAL
35626: IFTRUE 35630
35628: GO 35655
35630: POP
// if JMMGirl = 3 then
35631: LD_EXP 7
35635: PUSH
35636: LD_INT 3
35638: EQUAL
35639: IFFALSE 35653
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35641: LD_EXP 55
35645: PPUSH
35646: LD_STRING DA1-Con-1a
35648: PPUSH
35649: CALL_OW 91
35653: GO 35837
35655: LD_EXP 64
35659: DOUBLE
35660: EQUAL
35661: IFTRUE 35665
35663: GO 35680
35665: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35666: LD_EXP 64
35670: PPUSH
35671: LD_STRING DA1-Kurt-1a
35673: PPUSH
35674: CALL_OW 91
35678: GO 35837
35680: LD_EXP 54
35684: DOUBLE
35685: EQUAL
35686: IFTRUE 35690
35688: GO 35705
35690: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35691: LD_EXP 54
35695: PPUSH
35696: LD_STRING DA1-Yam-1a
35698: PPUSH
35699: CALL_OW 91
35703: GO 35837
35705: LD_EXP 53
35709: DOUBLE
35710: EQUAL
35711: IFTRUE 35715
35713: GO 35730
35715: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35716: LD_EXP 53
35720: PPUSH
35721: LD_STRING DA1-Frank-1a
35723: PPUSH
35724: CALL_OW 91
35728: GO 35837
35730: POP
// begin join := rand ( 0 , 1 ) ;
35731: LD_ADDR_VAR 0 3
35735: PUSH
35736: LD_INT 0
35738: PPUSH
35739: LD_INT 1
35741: PPUSH
35742: CALL_OW 12
35746: ST_TO_ADDR
// if join then
35747: LD_VAR 0 3
35751: IFFALSE 35796
// begin if GetSex ( unit ) = sex_male then
35753: LD_VAR 0 1
35757: PPUSH
35758: CALL_OW 258
35762: PUSH
35763: LD_INT 1
35765: EQUAL
35766: IFFALSE 35782
// ForceSay ( unit , DA1-Sol1-1b ) else
35768: LD_VAR 0 1
35772: PPUSH
35773: LD_STRING DA1-Sol1-1b
35775: PPUSH
35776: CALL_OW 91
35780: GO 35794
// ForceSay ( unit , DA1-FSol1-1b ) ;
35782: LD_VAR 0 1
35786: PPUSH
35787: LD_STRING DA1-FSol1-1b
35789: PPUSH
35790: CALL_OW 91
// end else
35794: GO 35837
// begin if GetSex ( unit ) = sex_male then
35796: LD_VAR 0 1
35800: PPUSH
35801: CALL_OW 258
35805: PUSH
35806: LD_INT 1
35808: EQUAL
35809: IFFALSE 35825
// ForceSay ( unit , DA1-Sol1-1a ) else
35811: LD_VAR 0 1
35815: PPUSH
35816: LD_STRING DA1-Sol1-1a
35818: PPUSH
35819: CALL_OW 91
35823: GO 35837
// ForceSay ( unit , DA1-FSol1-1a ) ;
35825: LD_VAR 0 1
35829: PPUSH
35830: LD_STRING DA1-FSol1-1a
35832: PPUSH
35833: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35837: LD_VAR 0 1
35841: PUSH
35842: LD_EXP 40
35846: EQUAL
35847: IFFALSE 35858
// begin YouLost ( JMMCaptured ) ;
35849: LD_STRING JMMCaptured
35851: PPUSH
35852: CALL_OW 104
// exit ;
35856: GO 36162
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
35858: LD_VAR 0 1
35862: PUSH
35863: LD_EXP 44
35867: PUSH
35868: LD_EXP 47
35872: PUSH
35873: LD_EXP 45
35877: PUSH
35878: LD_EXP 42
35882: PUSH
35883: LD_EXP 56
35887: PUSH
35888: LD_EXP 48
35892: PUSH
35893: LD_EXP 54
35897: PUSH
35898: LD_EXP 58
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: IN
35913: PUSH
35914: LD_VAR 0 3
35918: OR
35919: IFFALSE 36018
// begin Say ( Roth , DA-Roth-3 ) ;
35921: LD_EXP 79
35925: PPUSH
35926: LD_STRING DA-Roth-3
35928: PPUSH
35929: CALL_OW 88
// SetSide ( unit , 7 ) ;
35933: LD_VAR 0 1
35937: PPUSH
35938: LD_INT 7
35940: PPUSH
35941: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35945: LD_ADDR_EXP 102
35949: PUSH
35950: LD_EXP 102
35954: PPUSH
35955: LD_INT 1
35957: PPUSH
35958: LD_EXP 102
35962: PUSH
35963: LD_INT 1
35965: ARRAY
35966: PUSH
35967: LD_VAR 0 1
35971: ADD
35972: PPUSH
35973: CALL_OW 1
35977: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35978: LD_INT 260
35980: PPUSH
35981: LD_INT 235
35983: PPUSH
35984: LD_INT 1
35986: PPUSH
35987: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35991: LD_VAR 0 1
35995: PPUSH
35996: LD_INT 1000
35998: PPUSH
35999: CALL_OW 234
// DialogueOff ;
36003: CALL_OW 7
// ComFree ( unit ) ;
36007: LD_VAR 0 1
36011: PPUSH
36012: CALL_OW 139
// end else
36016: GO 36099
// begin Say ( Roth , DA-Roth-3a ) ;
36018: LD_EXP 79
36022: PPUSH
36023: LD_STRING DA-Roth-3a
36025: PPUSH
36026: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
36030: LD_ADDR_EXP 35
36034: PUSH
36035: LD_EXP 35
36039: PUSH
36040: LD_VAR 0 1
36044: ADD
36045: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36046: LD_INT 260
36048: PPUSH
36049: LD_INT 235
36051: PPUSH
36052: LD_INT 1
36054: PPUSH
36055: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36059: LD_VAR 0 1
36063: PPUSH
36064: LD_INT 1000
36066: PPUSH
36067: CALL_OW 234
// DialogueOff ;
36071: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
36075: LD_VAR 0 1
36079: PPUSH
36080: LD_INT 272
36082: PPUSH
36083: LD_INT 254
36085: PPUSH
36086: CALL_OW 111
// AddComHold ( unit ) ;
36090: LD_VAR 0 1
36094: PPUSH
36095: CALL_OW 200
// end ; if capturedUnit = 1 then
36099: LD_EXP 34
36103: PUSH
36104: LD_INT 1
36106: EQUAL
36107: IFFALSE 36162
// begin DialogueOn ;
36109: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
36113: LD_EXP 40
36117: PPUSH
36118: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
36122: LD_EXP 40
36126: PPUSH
36127: LD_STRING DAa-JMM-1
36129: PPUSH
36130: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
36134: LD_EXP 40
36138: PPUSH
36139: LD_STRING DAa-JMM-1a
36141: PPUSH
36142: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
36146: LD_EXP 40
36150: PPUSH
36151: LD_STRING DAa-JMM-1b
36153: PPUSH
36154: CALL_OW 88
// DialogueOff ;
36158: CALL_OW 7
// end ; end ;
36162: LD_VAR 0 2
36166: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
36167: LD_EXP 15
36171: PUSH
36172: LD_INT 13
36174: GREATEREQUAL
36175: PUSH
36176: LD_INT 22
36178: PUSH
36179: LD_INT 2
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 21
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PPUSH
36200: CALL_OW 69
36204: PUSH
36205: LD_INT 0
36207: EQUAL
36208: AND
36209: PUSH
36210: LD_INT 22
36212: PUSH
36213: LD_INT 2
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 33
36222: PUSH
36223: LD_INT 5
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 21
36232: PUSH
36233: LD_INT 2
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 50
36242: PUSH
36243: EMPTY
36244: LIST
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: LIST
36250: LIST
36251: PPUSH
36252: CALL_OW 69
36256: PUSH
36257: LD_INT 0
36259: EQUAL
36260: AND
36261: PUSH
36262: LD_EXP 21
36266: AND
36267: PUSH
36268: LD_EXP 22
36272: AND
36273: PUSH
36274: LD_EXP 23
36278: AND
36279: IFFALSE 37048
36281: GO 36283
36283: DISABLE
36284: LD_INT 0
36286: PPUSH
36287: PPUSH
36288: PPUSH
// begin wait ( 0 0$05 ) ;
36289: LD_INT 175
36291: PPUSH
36292: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
36296: LD_INT 22
36298: PUSH
36299: LD_INT 1
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: LD_INT 21
36308: PUSH
36309: LD_INT 1
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 23
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 50
36328: PUSH
36329: EMPTY
36330: LIST
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: PPUSH
36338: CALL_OW 69
36342: PPUSH
36343: CALL 71647 0 1
36347: PUSH
36348: LD_INT 2
36350: LESS
36351: IFFALSE 36362
// begin YouLost ( LostVictory ) ;
36353: LD_STRING LostVictory
36355: PPUSH
36356: CALL_OW 104
// exit ;
36360: GO 37048
// end ; m1 := false ;
36362: LD_ADDR_VAR 0 1
36366: PUSH
36367: LD_INT 0
36369: ST_TO_ADDR
// m2 := false ;
36370: LD_ADDR_VAR 0 2
36374: PUSH
36375: LD_INT 0
36377: ST_TO_ADDR
// m3 := false ;
36378: LD_ADDR_VAR 0 3
36382: PUSH
36383: LD_INT 0
36385: ST_TO_ADDR
// if not bombExploded then
36386: LD_EXP 37
36390: NOT
36391: IFFALSE 36400
// SetAchievement ( ACH_SIBROCKET ) ;
36393: LD_STRING ACH_SIBROCKET
36395: PPUSH
36396: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
36400: LD_EXP 66
36404: PPUSH
36405: CALL_OW 255
36409: PUSH
36410: LD_INT 1
36412: EQUAL
36413: PUSH
36414: LD_EXP 66
36418: PPUSH
36419: CALL_OW 302
36423: AND
36424: IFFALSE 36440
// begin wait ( 3 ) ;
36426: LD_INT 3
36428: PPUSH
36429: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
36433: LD_STRING ACH_OPO
36435: PPUSH
36436: CALL_OW 543
// end ; if tick <= 120 120$00 then
36440: LD_OWVAR 1
36444: PUSH
36445: LD_INT 252000
36447: LESSEQUAL
36448: IFFALSE 36464
// begin wait ( 3 ) ;
36450: LD_INT 3
36452: PPUSH
36453: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
36457: LD_STRING ACH_ASPEED_15
36459: PPUSH
36460: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
36464: LD_EXP 40
36468: PPUSH
36469: CALL_OW 87
// music_class := 5 ;
36473: LD_ADDR_OWVAR 72
36477: PUSH
36478: LD_INT 5
36480: ST_TO_ADDR
// music_nat := 5 ;
36481: LD_ADDR_OWVAR 71
36485: PUSH
36486: LD_INT 5
36488: ST_TO_ADDR
// DialogueOn ;
36489: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
36493: LD_EXP 40
36497: PPUSH
36498: LD_STRING D20-JMM-1
36500: PPUSH
36501: CALL_OW 88
// if IsOK ( Joan ) then
36505: LD_EXP 41
36509: PPUSH
36510: CALL_OW 302
36514: IFFALSE 36528
// Say ( Joan , D20-Joan-1 ) ;
36516: LD_EXP 41
36520: PPUSH
36521: LD_STRING D20-Joan-1
36523: PPUSH
36524: CALL_OW 88
// if IsOk ( Lisa ) then
36528: LD_EXP 43
36532: PPUSH
36533: CALL_OW 302
36537: IFFALSE 36551
// Say ( Lisa , D20-Lisa-1 ) ;
36539: LD_EXP 43
36543: PPUSH
36544: LD_STRING D20-Lisa-1
36546: PPUSH
36547: CALL_OW 88
// if IsOk ( Donaldson ) then
36551: LD_EXP 44
36555: PPUSH
36556: CALL_OW 302
36560: IFFALSE 36574
// Say ( Donaldson , D20-Don-1 ) ;
36562: LD_EXP 44
36566: PPUSH
36567: LD_STRING D20-Don-1
36569: PPUSH
36570: CALL_OW 88
// if IsOK ( Cornel ) then
36574: LD_EXP 51
36578: PPUSH
36579: CALL_OW 302
36583: IFFALSE 36597
// Say ( Cornel , D20-Corn-1 ) ;
36585: LD_EXP 51
36589: PPUSH
36590: LD_STRING D20-Corn-1
36592: PPUSH
36593: CALL_OW 88
// if IsOk ( Denis ) then
36597: LD_EXP 47
36601: PPUSH
36602: CALL_OW 302
36606: IFFALSE 36620
// Say ( Denis , D20-Den-1 ) ;
36608: LD_EXP 47
36612: PPUSH
36613: LD_STRING D20-Den-1
36615: PPUSH
36616: CALL_OW 88
// if IsOk ( Bobby ) then
36620: LD_EXP 45
36624: PPUSH
36625: CALL_OW 302
36629: IFFALSE 36643
// Say ( Bobby , D20-Bobby-1 ) ;
36631: LD_EXP 45
36635: PPUSH
36636: LD_STRING D20-Bobby-1
36638: PPUSH
36639: CALL_OW 88
// if IsOk ( Gladstone ) then
36643: LD_EXP 49
36647: PPUSH
36648: CALL_OW 302
36652: IFFALSE 36666
// Say ( Gladstone , D20-Glad-1 ) ;
36654: LD_EXP 49
36658: PPUSH
36659: LD_STRING D20-Glad-1
36661: PPUSH
36662: CALL_OW 88
// if IsOk ( Cyrus ) then
36666: LD_EXP 46
36670: PPUSH
36671: CALL_OW 302
36675: IFFALSE 36689
// Say ( Cyrus , D20-Cyrus-1 ) ;
36677: LD_EXP 46
36681: PPUSH
36682: LD_STRING D20-Cyrus-1
36684: PPUSH
36685: CALL_OW 88
// if IsOk ( Stevens ) then
36689: LD_EXP 42
36693: PPUSH
36694: CALL_OW 302
36698: IFFALSE 36712
// Say ( Stevens , D20-Huck-1 ) ;
36700: LD_EXP 42
36704: PPUSH
36705: LD_STRING D20-Huck-1
36707: PPUSH
36708: CALL_OW 88
// if IsOk ( Brown ) then
36712: LD_EXP 48
36716: PPUSH
36717: CALL_OW 302
36721: IFFALSE 36735
// Say ( Brown , D20-Brown-1 ) ;
36723: LD_EXP 48
36727: PPUSH
36728: LD_STRING D20-Brown-1
36730: PPUSH
36731: CALL_OW 88
// if IsOk ( Gary ) then
36735: LD_EXP 52
36739: PPUSH
36740: CALL_OW 302
36744: IFFALSE 36758
// Say ( Gary , D20-Gary-1 ) ;
36746: LD_EXP 52
36750: PPUSH
36751: LD_STRING D20-Gary-1
36753: PPUSH
36754: CALL_OW 88
// if IsOk ( Connie ) then
36758: LD_EXP 55
36762: PPUSH
36763: CALL_OW 302
36767: IFFALSE 36781
// Say ( Connie , D20-Con-1 ) ;
36769: LD_EXP 55
36773: PPUSH
36774: LD_STRING D20-Con-1
36776: PPUSH
36777: CALL_OW 88
// if IsOk ( Kurt ) then
36781: LD_EXP 64
36785: PPUSH
36786: CALL_OW 302
36790: IFFALSE 36804
// Say ( Kurt , D20-Kurt-1 ) ;
36792: LD_EXP 64
36796: PPUSH
36797: LD_STRING D20-Kurt-1
36799: PPUSH
36800: CALL_OW 88
// if IsOk ( Kikuchi ) then
36804: LD_EXP 54
36808: PPUSH
36809: CALL_OW 302
36813: IFFALSE 36827
// Say ( Kikuchi , D20-Yam-1 ) ;
36815: LD_EXP 54
36819: PPUSH
36820: LD_STRING D20-Yam-1
36822: PPUSH
36823: CALL_OW 88
// if IsOk ( Frank ) then
36827: LD_EXP 53
36831: PPUSH
36832: CALL_OW 302
36836: IFFALSE 36850
// Say ( Frank , D20-Frank-1 ) ;
36838: LD_EXP 53
36842: PPUSH
36843: LD_STRING D20-Frank-1
36845: PPUSH
36846: CALL_OW 88
// DialogueOff ;
36850: CALL_OW 7
// if RothCaptured then
36854: LD_EXP 33
36858: IFFALSE 36880
// begin m1 := true ;
36860: LD_ADDR_VAR 0 1
36864: PUSH
36865: LD_INT 1
36867: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36868: LD_STRING Roth
36870: PPUSH
36871: LD_INT 1
36873: PPUSH
36874: CALL_OW 101
// end else
36878: GO 36891
// AddMedal ( Roth , - 1 ) ;
36880: LD_STRING Roth
36882: PPUSH
36883: LD_INT 1
36885: NEG
36886: PPUSH
36887: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36891: LD_EXP 25
36895: NOT
36896: PUSH
36897: LD_EXP 27
36901: OR
36902: PUSH
36903: LD_EXP 28
36907: NOT
36908: OR
36909: IFFALSE 36931
// begin m2 := true ;
36911: LD_ADDR_VAR 0 2
36915: PUSH
36916: LD_INT 1
36918: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36919: LD_STRING Project
36921: PPUSH
36922: LD_INT 1
36924: PPUSH
36925: CALL_OW 101
// end else
36929: GO 36942
// AddMedal ( Project , - 1 ) ;
36931: LD_STRING Project
36933: PPUSH
36934: LD_INT 1
36936: NEG
36937: PPUSH
36938: CALL_OW 101
// if lostCounter = 0 then
36942: LD_EXP 32
36946: PUSH
36947: LD_INT 0
36949: EQUAL
36950: IFFALSE 36972
// begin m3 := true ;
36952: LD_ADDR_VAR 0 3
36956: PUSH
36957: LD_INT 1
36959: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36960: LD_STRING NoLosses
36962: PPUSH
36963: LD_INT 1
36965: PPUSH
36966: CALL_OW 101
// end else
36970: GO 36983
// AddMedal ( NoLosses , - 1 ) ;
36972: LD_STRING NoLosses
36974: PPUSH
36975: LD_INT 1
36977: NEG
36978: PPUSH
36979: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36983: LD_VAR 0 1
36987: PUSH
36988: LD_VAR 0 2
36992: AND
36993: PUSH
36994: LD_VAR 0 3
36998: AND
36999: PUSH
37000: LD_OWVAR 67
37004: PUSH
37005: LD_INT 3
37007: GREATEREQUAL
37008: AND
37009: IFFALSE 37021
// SetAchievementEX ( ACH_AMER , 15 ) ;
37011: LD_STRING ACH_AMER
37013: PPUSH
37014: LD_INT 15
37016: PPUSH
37017: CALL_OW 564
// GiveMedals ( MAIN ) ;
37021: LD_STRING MAIN
37023: PPUSH
37024: CALL_OW 102
// music_class := 4 ;
37028: LD_ADDR_OWVAR 72
37032: PUSH
37033: LD_INT 4
37035: ST_TO_ADDR
// music_nat := 1 ;
37036: LD_ADDR_OWVAR 71
37040: PUSH
37041: LD_INT 1
37043: ST_TO_ADDR
// YouWin ;
37044: CALL_OW 103
// end ; end_of_file
37048: PPOPN 3
37050: END
// export function CustomEvent ( event ) ; begin
37051: LD_INT 0
37053: PPUSH
// end ;
37054: LD_VAR 0 2
37058: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
37059: LD_VAR 0 1
37063: PUSH
37064: LD_INT 1
37066: EQUAL
37067: PUSH
37068: LD_VAR 0 2
37072: PUSH
37073: LD_INT 4
37075: EQUAL
37076: AND
37077: PUSH
37078: LD_EXP 61
37082: PPUSH
37083: CALL_OW 300
37087: AND
37088: IFFALSE 37104
// begin wait ( 0 0$2 ) ;
37090: LD_INT 70
37092: PPUSH
37093: CALL_OW 67
// YouLost ( Dismissed ) ;
37097: LD_STRING Dismissed
37099: PPUSH
37100: CALL_OW 104
// end ; end ;
37104: PPOPN 2
37106: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
37107: LD_VAR 0 2
37111: PPUSH
37112: LD_VAR 0 3
37116: PPUSH
37117: LD_INT 18
37119: PPUSH
37120: CALL_OW 309
37124: IFFALSE 37133
// YouLost ( Motherlode3 ) ;
37126: LD_STRING Motherlode3
37128: PPUSH
37129: CALL_OW 104
// end ;
37133: PPOPN 3
37135: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
37136: LD_EXP 27
37140: NOT
37141: IFFALSE 37151
// behemothDone := true ;
37143: LD_ADDR_EXP 28
37147: PUSH
37148: LD_INT 1
37150: ST_TO_ADDR
// end ;
37151: PPOPN 1
37153: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
37154: LD_VAR 0 1
37158: PPUSH
37159: CALL_OW 255
37163: PUSH
37164: LD_INT 1
37166: EQUAL
37167: IFFALSE 37177
// bombExploded := true ;
37169: LD_ADDR_EXP 37
37173: PUSH
37174: LD_INT 1
37176: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
37177: LD_VAR 0 1
37181: PPUSH
37182: CALL_OW 255
37186: PUSH
37187: LD_INT 3
37189: EQUAL
37190: IFFALSE 37220
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
37192: LD_INT 2
37194: PPUSH
37195: LD_INT 23
37197: PUSH
37198: LD_INT 3
37200: PUSH
37201: LD_INT 3
37203: PUSH
37204: LD_INT 48
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: PUSH
37213: EMPTY
37214: LIST
37215: PPUSH
37216: CALL 63119 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
37220: LD_VAR 0 1
37224: PPUSH
37225: CALL_OW 255
37229: PUSH
37230: LD_INT 1
37232: EQUAL
37233: PUSH
37234: LD_EXP 66
37238: PPUSH
37239: CALL_OW 255
37243: PUSH
37244: LD_INT 1
37246: EQUAL
37247: AND
37248: PUSH
37249: LD_EXP 66
37253: PPUSH
37254: CALL_OW 302
37258: AND
37259: PUSH
37260: LD_EXP 30
37264: AND
37265: PUSH
37266: LD_INT 22
37268: PUSH
37269: LD_INT 3
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 34
37278: PUSH
37279: LD_INT 48
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PPUSH
37290: CALL_OW 69
37294: AND
37295: PUSH
37296: LD_INT 22
37298: PUSH
37299: LD_INT 1
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 34
37308: PUSH
37309: LD_INT 8
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PPUSH
37320: CALL_OW 69
37324: NOT
37325: AND
37326: IFFALSE 37378
// begin wait ( 0 0$5 ) ;
37328: LD_INT 175
37330: PPUSH
37331: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
37335: LD_INT 22
37337: PUSH
37338: LD_INT 3
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 34
37347: PUSH
37348: LD_INT 48
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PPUSH
37359: CALL_OW 69
37363: PUSH
37364: LD_INT 1
37366: ARRAY
37367: PPUSH
37368: LD_INT 60
37370: PPUSH
37371: LD_INT 95
37373: PPUSH
37374: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
37378: LD_VAR 0 2
37382: PPUSH
37383: LD_VAR 0 3
37387: PPUSH
37388: LD_INT 18
37390: PPUSH
37391: CALL_OW 309
37395: PUSH
37396: LD_VAR 0 2
37400: PPUSH
37401: LD_VAR 0 3
37405: PPUSH
37406: LD_INT 18
37408: PPUSH
37409: CALL 111045 0 3
37413: OR
37414: IFFALSE 37461
// begin if GetSide ( unit ) = 1 then
37416: LD_VAR 0 1
37420: PPUSH
37421: CALL_OW 255
37425: PUSH
37426: LD_INT 1
37428: EQUAL
37429: IFFALSE 37447
// begin wait ( 0 0$6 ) ;
37431: LD_INT 210
37433: PPUSH
37434: CALL_OW 67
// YouLost ( Motherlode2 ) ;
37438: LD_STRING Motherlode2
37440: PPUSH
37441: CALL_OW 104
// end else
37445: GO 37461
// begin wait ( 0 0$6 ) ;
37447: LD_INT 210
37449: PPUSH
37450: CALL_OW 67
// YouLost ( Motherlode1 ) ;
37454: LD_STRING Motherlode1
37456: PPUSH
37457: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
37461: LD_VAR 0 1
37465: PPUSH
37466: CALL_OW 255
37470: PUSH
37471: LD_INT 3
37473: EQUAL
37474: IFFALSE 37495
// begin wait ( 0 0$5 ) ;
37476: LD_INT 175
37478: PPUSH
37479: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
37483: LD_EXP 68
37487: PPUSH
37488: LD_STRING D18-Pla-1
37490: PPUSH
37491: CALL_OW 94
// end ; end ;
37495: PPOPN 3
37497: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
37498: LD_VAR 0 1
37502: PPUSH
37503: CALL 128135 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
37507: LD_VAR 0 1
37511: PUSH
37512: LD_INT 22
37514: PUSH
37515: LD_INT 1
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 21
37524: PUSH
37525: LD_INT 1
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 23
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: LIST
37546: PPUSH
37547: CALL_OW 69
37551: IN
37552: IFFALSE 37568
// lostCounter := lostCounter + 1 ;
37554: LD_ADDR_EXP 32
37558: PUSH
37559: LD_EXP 32
37563: PUSH
37564: LD_INT 1
37566: PLUS
37567: ST_TO_ADDR
// if un in behemothBuilders then
37568: LD_VAR 0 1
37572: PUSH
37573: LD_EXP 77
37577: IN
37578: IFFALSE 37598
// begin behemothBuilders := behemothBuilders diff un ;
37580: LD_ADDR_EXP 77
37584: PUSH
37585: LD_EXP 77
37589: PUSH
37590: LD_VAR 0 1
37594: DIFF
37595: ST_TO_ADDR
// exit ;
37596: GO 37628
// end ; if un = JMM then
37598: LD_VAR 0 1
37602: PUSH
37603: LD_EXP 40
37607: EQUAL
37608: IFFALSE 37619
// begin YouLost ( JMM ) ;
37610: LD_STRING JMM
37612: PPUSH
37613: CALL_OW 104
// exit ;
37617: GO 37628
// end ; MCE_UnitDestroyed ( un ) ;
37619: LD_VAR 0 1
37623: PPUSH
37624: CALL 66561 0 1
// end ;
37628: PPOPN 1
37630: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
37631: LD_VAR 0 1
37635: PPUSH
37636: LD_VAR 0 2
37640: PPUSH
37641: CALL 68893 0 2
// end ;
37645: PPOPN 2
37647: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37648: LD_VAR 0 1
37652: PPUSH
37653: CALL 67961 0 1
// end ;
37657: PPOPN 1
37659: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37660: LD_VAR 0 1
37664: PUSH
37665: LD_INT 22
37667: PUSH
37668: LD_INT 8
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 30
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 23
37687: PUSH
37688: LD_INT 3
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: LIST
37699: PPUSH
37700: CALL_OW 69
37704: IN
37705: IFFALSE 37732
// begin ComUpgrade ( building ) ;
37707: LD_VAR 0 1
37711: PPUSH
37712: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37716: LD_EXP 65
37720: PPUSH
37721: LD_VAR 0 1
37725: PPUSH
37726: CALL 77745 0 2
// exit ;
37730: GO 37741
// end ; MCE_BuildingComplete ( building ) ;
37732: LD_VAR 0 1
37736: PPUSH
37737: CALL 68202 0 1
// end ;
37741: PPOPN 1
37743: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37744: LD_VAR 0 1
37748: PPUSH
37749: LD_VAR 0 2
37753: PPUSH
37754: CALL 66257 0 2
// end ;
37758: PPOPN 2
37760: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37761: LD_VAR 0 1
37765: PPUSH
37766: LD_VAR 0 2
37770: PPUSH
37771: LD_VAR 0 3
37775: PPUSH
37776: LD_VAR 0 4
37780: PPUSH
37781: LD_VAR 0 5
37785: PPUSH
37786: CALL 65877 0 5
// end ;
37790: PPOPN 5
37792: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37793: LD_VAR 0 1
37797: PPUSH
37798: CALL_OW 255
37802: PUSH
37803: LD_INT 1
37805: EQUAL
37806: IFFALSE 37823
// amConstructCounter := Inc ( amConstructCounter ) ;
37808: LD_ADDR_EXP 39
37812: PUSH
37813: LD_EXP 39
37817: PPUSH
37818: CALL 108597 0 1
37822: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37823: LD_VAR 0 1
37827: PPUSH
37828: LD_VAR 0 2
37832: PPUSH
37833: CALL 128255 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37837: LD_VAR 0 1
37841: PPUSH
37842: LD_VAR 0 2
37846: PPUSH
37847: CALL 65430 0 2
// end ;
37851: PPOPN 2
37853: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37854: LD_VAR 0 1
37858: PPUSH
37859: LD_VAR 0 2
37863: PPUSH
37864: LD_VAR 0 3
37868: PPUSH
37869: LD_VAR 0 4
37873: PPUSH
37874: CALL 65268 0 4
// end ;
37878: PPOPN 4
37880: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37881: LD_VAR 0 1
37885: PPUSH
37886: LD_VAR 0 2
37890: PPUSH
37891: LD_VAR 0 3
37895: PPUSH
37896: CALL 65043 0 3
// end ;
37900: PPOPN 3
37902: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37903: LD_VAR 0 1
37907: PPUSH
37908: LD_VAR 0 2
37912: PPUSH
37913: CALL 64928 0 2
// end ;
37917: PPOPN 2
37919: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37920: LD_VAR 0 1
37924: PPUSH
37925: LD_VAR 0 2
37929: PPUSH
37930: CALL 69188 0 2
// end ;
37934: PPOPN 2
37936: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37937: LD_VAR 0 1
37941: PUSH
37942: LD_INT 460
37944: EQUAL
37945: IFFALSE 37967
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37947: LD_VAR 0 2
37951: PPUSH
37952: LD_INT 227
37954: PPUSH
37955: LD_INT 136
37957: PPUSH
37958: CALL_OW 428
37962: PPUSH
37963: CALL_OW 120
// end ;
37967: PPOPN 2
37969: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37970: LD_VAR 0 1
37974: PPUSH
37975: CALL_OW 255
37979: PUSH
37980: LD_INT 4
37982: EQUAL
37983: PUSH
37984: LD_VAR 0 1
37988: PUSH
37989: LD_EXP 18
37993: PUSH
37994: LD_INT 1
37996: ARRAY
37997: IN
37998: AND
37999: PUSH
38000: LD_EXP 19
38004: AND
38005: IFFALSE 38024
// begin ComMoveXY ( driver , 61 , 93 ) ;
38007: LD_VAR 0 1
38011: PPUSH
38012: LD_INT 61
38014: PPUSH
38015: LD_INT 93
38017: PPUSH
38018: CALL_OW 111
// exit ;
38022: GO 38093
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
38024: LD_VAR 0 1
38028: PPUSH
38029: CALL_OW 255
38033: PUSH
38034: LD_INT 3
38036: EQUAL
38037: PUSH
38038: LD_VAR 0 1
38042: PPUSH
38043: CALL_OW 110
38047: PUSH
38048: LD_INT 105
38050: EQUAL
38051: AND
38052: IFFALSE 38069
// begin ComMoveXY ( driver , 187 , 92 ) ;
38054: LD_VAR 0 1
38058: PPUSH
38059: LD_INT 187
38061: PPUSH
38062: LD_INT 92
38064: PPUSH
38065: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
38069: LD_VAR 0 1
38073: PPUSH
38074: LD_VAR 0 2
38078: PPUSH
38079: LD_VAR 0 3
38083: PPUSH
38084: LD_VAR 0 4
38088: PPUSH
38089: CALL 69404 0 4
// end ;
38093: PPOPN 4
38095: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
38096: LD_VAR 0 1
38100: PPUSH
38101: LD_VAR 0 2
38105: PPUSH
38106: CALL 64737 0 2
// end ;
38110: PPOPN 2
38112: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
38113: LD_VAR 0 1
38117: PPUSH
38118: CALL 128239 0 1
// end ; end_of_file
38122: PPOPN 1
38124: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
38125: LD_EXP 15
38129: PUSH
38130: LD_INT 2
38132: EQUAL
38133: IFFALSE 38650
38135: GO 38137
38137: DISABLE
38138: LD_INT 0
38140: PPUSH
38141: PPUSH
// begin time := 0 0$35 ;
38142: LD_ADDR_VAR 0 2
38146: PUSH
38147: LD_INT 1225
38149: ST_TO_ADDR
// repeat wait ( time ) ;
38150: LD_VAR 0 2
38154: PPUSH
38155: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
38159: LD_INT 1
38161: PPUSH
38162: LD_INT 5
38164: PPUSH
38165: CALL_OW 12
38169: PPUSH
38170: LD_INT 106
38172: PPUSH
38173: LD_INT 150
38175: PPUSH
38176: LD_INT 19
38178: PPUSH
38179: LD_INT 1
38181: PPUSH
38182: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
38186: LD_INT 455
38188: PPUSH
38189: LD_INT 770
38191: PPUSH
38192: CALL_OW 12
38196: PPUSH
38197: CALL_OW 67
// if Prob ( 50 ) then
38201: LD_INT 50
38203: PPUSH
38204: CALL_OW 13
38208: IFFALSE 38237
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
38210: LD_INT 1
38212: PPUSH
38213: LD_INT 5
38215: PPUSH
38216: CALL_OW 12
38220: PPUSH
38221: LD_INT 62
38223: PPUSH
38224: LD_INT 108
38226: PPUSH
38227: LD_INT 10
38229: PPUSH
38230: LD_INT 1
38232: PPUSH
38233: CALL_OW 56
// until missionStage > 4 ;
38237: LD_EXP 15
38241: PUSH
38242: LD_INT 4
38244: GREATER
38245: IFFALSE 38150
// repeat wait ( 0 0$1 ) ;
38247: LD_INT 35
38249: PPUSH
38250: CALL_OW 67
// until missionStage = 6 ;
38254: LD_EXP 15
38258: PUSH
38259: LD_INT 6
38261: EQUAL
38262: IFFALSE 38247
// time := 0 0$20 ;
38264: LD_ADDR_VAR 0 2
38268: PUSH
38269: LD_INT 700
38271: ST_TO_ADDR
// repeat wait ( time ) ;
38272: LD_VAR 0 2
38276: PPUSH
38277: CALL_OW 67
// if Prob ( 90 ) then
38281: LD_INT 90
38283: PPUSH
38284: CALL_OW 13
38288: IFFALSE 38331
// begin time := time + 0 0$2 ;
38290: LD_ADDR_VAR 0 2
38294: PUSH
38295: LD_VAR 0 2
38299: PUSH
38300: LD_INT 70
38302: PLUS
38303: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
38304: LD_INT 1
38306: PPUSH
38307: LD_INT 5
38309: PPUSH
38310: CALL_OW 12
38314: PPUSH
38315: LD_INT 106
38317: PPUSH
38318: LD_INT 89
38320: PPUSH
38321: LD_INT 45
38323: PPUSH
38324: LD_INT 1
38326: PPUSH
38327: CALL_OW 56
// end ; if Prob ( 45 ) then
38331: LD_INT 45
38333: PPUSH
38334: CALL_OW 13
38338: IFFALSE 38394
// begin for i := 1 to 4 do
38340: LD_ADDR_VAR 0 1
38344: PUSH
38345: DOUBLE
38346: LD_INT 1
38348: DEC
38349: ST_TO_ADDR
38350: LD_INT 4
38352: PUSH
38353: FOR_TO
38354: IFFALSE 38392
// begin wait ( 0 0$5 ) ;
38356: LD_INT 175
38358: PPUSH
38359: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
38363: LD_INT 1
38365: PPUSH
38366: LD_INT 5
38368: PPUSH
38369: CALL_OW 12
38373: PPUSH
38374: LD_INT 113
38376: PPUSH
38377: LD_INT 117
38379: PPUSH
38380: LD_INT 25
38382: PPUSH
38383: LD_INT 1
38385: PPUSH
38386: CALL_OW 56
// end ;
38390: GO 38353
38392: POP
38393: POP
// end ; if Prob ( 40 ) then
38394: LD_INT 40
38396: PPUSH
38397: CALL_OW 13
38401: IFFALSE 38447
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
38403: LD_INT 385
38405: PPUSH
38406: LD_INT 945
38408: PPUSH
38409: CALL_OW 12
38413: PPUSH
38414: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
38418: LD_INT 1
38420: PPUSH
38421: LD_INT 5
38423: PPUSH
38424: CALL_OW 12
38428: PPUSH
38429: LD_INT 21
38431: PPUSH
38432: LD_INT 26
38434: PPUSH
38435: LD_INT 12
38437: PPUSH
38438: LD_INT 1
38440: PPUSH
38441: CALL_OW 56
// end else
38445: GO 38483
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
38447: LD_INT 700
38449: PPUSH
38450: LD_INT 1225
38452: PPUSH
38453: CALL_OW 12
38457: PPUSH
38458: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
38462: LD_INT 1
38464: PPUSH
38465: LD_INT 5
38467: PPUSH
38468: CALL_OW 12
38472: PPUSH
38473: LD_INT 16
38475: PPUSH
38476: LD_INT 1
38478: PPUSH
38479: CALL_OW 55
// end ; if Prob ( 50 ) then
38483: LD_INT 50
38485: PPUSH
38486: CALL_OW 13
38490: IFFALSE 38536
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
38492: LD_INT 700
38494: PPUSH
38495: LD_INT 1050
38497: PPUSH
38498: CALL_OW 12
38502: PPUSH
38503: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
38507: LD_INT 1
38509: PPUSH
38510: LD_INT 5
38512: PPUSH
38513: CALL_OW 12
38517: PPUSH
38518: LD_INT 168
38520: PPUSH
38521: LD_INT 168
38523: PPUSH
38524: LD_INT 16
38526: PPUSH
38527: LD_INT 1
38529: PPUSH
38530: CALL_OW 56
// end else
38534: GO 38572
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
38536: LD_INT 350
38538: PPUSH
38539: LD_INT 525
38541: PPUSH
38542: CALL_OW 12
38546: PPUSH
38547: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
38551: LD_INT 1
38553: PPUSH
38554: LD_INT 5
38556: PPUSH
38557: CALL_OW 12
38561: PPUSH
38562: LD_INT 15
38564: PPUSH
38565: LD_INT 1
38567: PPUSH
38568: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
38572: LD_INT 175
38574: PPUSH
38575: LD_INT 315
38577: PPUSH
38578: CALL_OW 12
38582: PPUSH
38583: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
38587: LD_INT 1
38589: PPUSH
38590: LD_INT 5
38592: PPUSH
38593: CALL_OW 12
38597: PPUSH
38598: LD_INT 103
38600: PPUSH
38601: LD_INT 140
38603: PPUSH
38604: LD_INT 20
38606: PPUSH
38607: LD_INT 1
38609: PPUSH
38610: CALL_OW 56
// time := time + 0 0$2 ;
38614: LD_ADDR_VAR 0 2
38618: PUSH
38619: LD_VAR 0 2
38623: PUSH
38624: LD_INT 70
38626: PLUS
38627: ST_TO_ADDR
// if time > 1 1$20 then
38628: LD_VAR 0 2
38632: PUSH
38633: LD_INT 2800
38635: GREATER
38636: IFFALSE 38646
// time := 0 0$30 ;
38638: LD_ADDR_VAR 0 2
38642: PUSH
38643: LD_INT 1050
38645: ST_TO_ADDR
// until false ;
38646: LD_INT 0
38648: IFFALSE 38272
// end ; end_of_file
38650: PPOPN 2
38652: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38653: LD_EXP 13
38657: PUSH
38658: LD_EXP 15
38662: PUSH
38663: LD_INT 6
38665: GREATEREQUAL
38666: AND
38667: IFFALSE 38704
38669: GO 38671
38671: DISABLE
// begin enable ;
38672: ENABLE
// missionTime := missionTime + 0 0$1 ;
38673: LD_ADDR_EXP 14
38677: PUSH
38678: LD_EXP 14
38682: PUSH
38683: LD_INT 35
38685: PLUS
38686: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38687: LD_ADDR_OWVAR 47
38691: PUSH
38692: LD_STRING #Am15-1
38694: PUSH
38695: LD_EXP 14
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: ST_TO_ADDR
// end ; end_of_file
38704: END
// export function InitNature ; begin
38705: LD_INT 0
38707: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38708: LD_INT 3
38710: PPUSH
38711: LD_INT 3
38713: PPUSH
38714: LD_INT 2
38716: PPUSH
38717: LD_INT 1
38719: PPUSH
38720: LD_INT 1
38722: PPUSH
38723: LD_INT 0
38725: PPUSH
38726: LD_INT 0
38728: PPUSH
38729: LD_INT 20
38731: PPUSH
38732: LD_INT 0
38734: PPUSH
38735: CALL 103913 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38739: LD_INT 2
38741: PPUSH
38742: LD_INT 1
38744: PPUSH
38745: LD_INT 1
38747: PPUSH
38748: LD_INT 1
38750: PPUSH
38751: LD_INT 1
38753: PPUSH
38754: LD_INT 0
38756: PPUSH
38757: LD_INT 0
38759: PPUSH
38760: LD_INT 21
38762: PPUSH
38763: LD_INT 0
38765: PPUSH
38766: CALL 103913 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38770: LD_INT 4
38772: PPUSH
38773: LD_INT 1
38775: PPUSH
38776: LD_INT 2
38778: PPUSH
38779: LD_INT 4
38781: PPUSH
38782: LD_INT 2
38784: PPUSH
38785: LD_INT 1
38787: PPUSH
38788: LD_INT 0
38790: PPUSH
38791: LD_INT 22
38793: PPUSH
38794: LD_INT 0
38796: PPUSH
38797: CALL 103913 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38801: LD_INT 0
38803: PPUSH
38804: LD_INT 0
38806: PPUSH
38807: LD_INT 0
38809: PPUSH
38810: LD_INT 0
38812: PPUSH
38813: LD_INT 0
38815: PPUSH
38816: LD_INT 0
38818: PPUSH
38819: LD_INT 9
38821: PPUSH
38822: LD_INT 0
38824: PPUSH
38825: LD_INT 23
38827: PPUSH
38828: CALL 103913 0 9
// end ; end_of_file
38832: LD_VAR 0 1
38836: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38837: LD_INT 0
38839: PPUSH
38840: PPUSH
// skirmish := false ;
38841: LD_ADDR_EXP 100
38845: PUSH
38846: LD_INT 0
38848: ST_TO_ADDR
// debug_mc := false ;
38849: LD_ADDR_EXP 101
38853: PUSH
38854: LD_INT 0
38856: ST_TO_ADDR
// mc_bases := [ ] ;
38857: LD_ADDR_EXP 102
38861: PUSH
38862: EMPTY
38863: ST_TO_ADDR
// mc_sides := [ ] ;
38864: LD_ADDR_EXP 128
38868: PUSH
38869: EMPTY
38870: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38871: LD_ADDR_EXP 103
38875: PUSH
38876: EMPTY
38877: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38878: LD_ADDR_EXP 104
38882: PUSH
38883: EMPTY
38884: ST_TO_ADDR
// mc_need_heal := [ ] ;
38885: LD_ADDR_EXP 105
38889: PUSH
38890: EMPTY
38891: ST_TO_ADDR
// mc_healers := [ ] ;
38892: LD_ADDR_EXP 106
38896: PUSH
38897: EMPTY
38898: ST_TO_ADDR
// mc_build_list := [ ] ;
38899: LD_ADDR_EXP 107
38903: PUSH
38904: EMPTY
38905: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38906: LD_ADDR_EXP 134
38910: PUSH
38911: EMPTY
38912: ST_TO_ADDR
// mc_builders := [ ] ;
38913: LD_ADDR_EXP 108
38917: PUSH
38918: EMPTY
38919: ST_TO_ADDR
// mc_construct_list := [ ] ;
38920: LD_ADDR_EXP 109
38924: PUSH
38925: EMPTY
38926: ST_TO_ADDR
// mc_turret_list := [ ] ;
38927: LD_ADDR_EXP 110
38931: PUSH
38932: EMPTY
38933: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38934: LD_ADDR_EXP 111
38938: PUSH
38939: EMPTY
38940: ST_TO_ADDR
// mc_miners := [ ] ;
38941: LD_ADDR_EXP 116
38945: PUSH
38946: EMPTY
38947: ST_TO_ADDR
// mc_mines := [ ] ;
38948: LD_ADDR_EXP 115
38952: PUSH
38953: EMPTY
38954: ST_TO_ADDR
// mc_minefields := [ ] ;
38955: LD_ADDR_EXP 117
38959: PUSH
38960: EMPTY
38961: ST_TO_ADDR
// mc_crates := [ ] ;
38962: LD_ADDR_EXP 118
38966: PUSH
38967: EMPTY
38968: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38969: LD_ADDR_EXP 119
38973: PUSH
38974: EMPTY
38975: ST_TO_ADDR
// mc_crates_area := [ ] ;
38976: LD_ADDR_EXP 120
38980: PUSH
38981: EMPTY
38982: ST_TO_ADDR
// mc_vehicles := [ ] ;
38983: LD_ADDR_EXP 121
38987: PUSH
38988: EMPTY
38989: ST_TO_ADDR
// mc_attack := [ ] ;
38990: LD_ADDR_EXP 122
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// mc_produce := [ ] ;
38997: LD_ADDR_EXP 123
39001: PUSH
39002: EMPTY
39003: ST_TO_ADDR
// mc_defender := [ ] ;
39004: LD_ADDR_EXP 124
39008: PUSH
39009: EMPTY
39010: ST_TO_ADDR
// mc_parking := [ ] ;
39011: LD_ADDR_EXP 126
39015: PUSH
39016: EMPTY
39017: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
39018: LD_ADDR_EXP 112
39022: PUSH
39023: EMPTY
39024: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
39025: LD_ADDR_EXP 114
39029: PUSH
39030: EMPTY
39031: ST_TO_ADDR
// mc_scan := [ ] ;
39032: LD_ADDR_EXP 125
39036: PUSH
39037: EMPTY
39038: ST_TO_ADDR
// mc_scan_area := [ ] ;
39039: LD_ADDR_EXP 127
39043: PUSH
39044: EMPTY
39045: ST_TO_ADDR
// mc_tech := [ ] ;
39046: LD_ADDR_EXP 129
39050: PUSH
39051: EMPTY
39052: ST_TO_ADDR
// mc_class := [ ] ;
39053: LD_ADDR_EXP 143
39057: PUSH
39058: EMPTY
39059: ST_TO_ADDR
// mc_class_case_use := [ ] ;
39060: LD_ADDR_EXP 144
39064: PUSH
39065: EMPTY
39066: ST_TO_ADDR
// mc_is_defending := [ ] ;
39067: LD_ADDR_EXP 145
39071: PUSH
39072: EMPTY
39073: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
39074: LD_ADDR_EXP 136
39078: PUSH
39079: EMPTY
39080: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
39081: LD_ADDR_EXP 146
39085: PUSH
39086: LD_INT 0
39088: ST_TO_ADDR
// end ;
39089: LD_VAR 0 1
39093: RET
// export function MC_Kill ( base ) ; begin
39094: LD_INT 0
39096: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
39097: LD_ADDR_EXP 102
39101: PUSH
39102: LD_EXP 102
39106: PPUSH
39107: LD_VAR 0 1
39111: PPUSH
39112: EMPTY
39113: PPUSH
39114: CALL_OW 1
39118: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39119: LD_ADDR_EXP 103
39123: PUSH
39124: LD_EXP 103
39128: PPUSH
39129: LD_VAR 0 1
39133: PPUSH
39134: EMPTY
39135: PPUSH
39136: CALL_OW 1
39140: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39141: LD_ADDR_EXP 104
39145: PUSH
39146: LD_EXP 104
39150: PPUSH
39151: LD_VAR 0 1
39155: PPUSH
39156: EMPTY
39157: PPUSH
39158: CALL_OW 1
39162: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39163: LD_ADDR_EXP 105
39167: PUSH
39168: LD_EXP 105
39172: PPUSH
39173: LD_VAR 0 1
39177: PPUSH
39178: EMPTY
39179: PPUSH
39180: CALL_OW 1
39184: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39185: LD_ADDR_EXP 106
39189: PUSH
39190: LD_EXP 106
39194: PPUSH
39195: LD_VAR 0 1
39199: PPUSH
39200: EMPTY
39201: PPUSH
39202: CALL_OW 1
39206: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39207: LD_ADDR_EXP 107
39211: PUSH
39212: LD_EXP 107
39216: PPUSH
39217: LD_VAR 0 1
39221: PPUSH
39222: EMPTY
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39229: LD_ADDR_EXP 108
39233: PUSH
39234: LD_EXP 108
39238: PPUSH
39239: LD_VAR 0 1
39243: PPUSH
39244: EMPTY
39245: PPUSH
39246: CALL_OW 1
39250: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39251: LD_ADDR_EXP 109
39255: PUSH
39256: LD_EXP 109
39260: PPUSH
39261: LD_VAR 0 1
39265: PPUSH
39266: EMPTY
39267: PPUSH
39268: CALL_OW 1
39272: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39273: LD_ADDR_EXP 110
39277: PUSH
39278: LD_EXP 110
39282: PPUSH
39283: LD_VAR 0 1
39287: PPUSH
39288: EMPTY
39289: PPUSH
39290: CALL_OW 1
39294: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39295: LD_ADDR_EXP 111
39299: PUSH
39300: LD_EXP 111
39304: PPUSH
39305: LD_VAR 0 1
39309: PPUSH
39310: EMPTY
39311: PPUSH
39312: CALL_OW 1
39316: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39317: LD_ADDR_EXP 112
39321: PUSH
39322: LD_EXP 112
39326: PPUSH
39327: LD_VAR 0 1
39331: PPUSH
39332: EMPTY
39333: PPUSH
39334: CALL_OW 1
39338: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39339: LD_ADDR_EXP 113
39343: PUSH
39344: LD_EXP 113
39348: PPUSH
39349: LD_VAR 0 1
39353: PPUSH
39354: LD_INT 0
39356: PPUSH
39357: CALL_OW 1
39361: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39362: LD_ADDR_EXP 114
39366: PUSH
39367: LD_EXP 114
39371: PPUSH
39372: LD_VAR 0 1
39376: PPUSH
39377: EMPTY
39378: PPUSH
39379: CALL_OW 1
39383: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39384: LD_ADDR_EXP 115
39388: PUSH
39389: LD_EXP 115
39393: PPUSH
39394: LD_VAR 0 1
39398: PPUSH
39399: EMPTY
39400: PPUSH
39401: CALL_OW 1
39405: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39406: LD_ADDR_EXP 116
39410: PUSH
39411: LD_EXP 116
39415: PPUSH
39416: LD_VAR 0 1
39420: PPUSH
39421: EMPTY
39422: PPUSH
39423: CALL_OW 1
39427: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39428: LD_ADDR_EXP 117
39432: PUSH
39433: LD_EXP 117
39437: PPUSH
39438: LD_VAR 0 1
39442: PPUSH
39443: EMPTY
39444: PPUSH
39445: CALL_OW 1
39449: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39450: LD_ADDR_EXP 118
39454: PUSH
39455: LD_EXP 118
39459: PPUSH
39460: LD_VAR 0 1
39464: PPUSH
39465: EMPTY
39466: PPUSH
39467: CALL_OW 1
39471: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39472: LD_ADDR_EXP 119
39476: PUSH
39477: LD_EXP 119
39481: PPUSH
39482: LD_VAR 0 1
39486: PPUSH
39487: EMPTY
39488: PPUSH
39489: CALL_OW 1
39493: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39494: LD_ADDR_EXP 120
39498: PUSH
39499: LD_EXP 120
39503: PPUSH
39504: LD_VAR 0 1
39508: PPUSH
39509: EMPTY
39510: PPUSH
39511: CALL_OW 1
39515: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39516: LD_ADDR_EXP 121
39520: PUSH
39521: LD_EXP 121
39525: PPUSH
39526: LD_VAR 0 1
39530: PPUSH
39531: EMPTY
39532: PPUSH
39533: CALL_OW 1
39537: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39538: LD_ADDR_EXP 122
39542: PUSH
39543: LD_EXP 122
39547: PPUSH
39548: LD_VAR 0 1
39552: PPUSH
39553: EMPTY
39554: PPUSH
39555: CALL_OW 1
39559: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39560: LD_ADDR_EXP 123
39564: PUSH
39565: LD_EXP 123
39569: PPUSH
39570: LD_VAR 0 1
39574: PPUSH
39575: EMPTY
39576: PPUSH
39577: CALL_OW 1
39581: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39582: LD_ADDR_EXP 124
39586: PUSH
39587: LD_EXP 124
39591: PPUSH
39592: LD_VAR 0 1
39596: PPUSH
39597: EMPTY
39598: PPUSH
39599: CALL_OW 1
39603: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39604: LD_ADDR_EXP 125
39608: PUSH
39609: LD_EXP 125
39613: PPUSH
39614: LD_VAR 0 1
39618: PPUSH
39619: EMPTY
39620: PPUSH
39621: CALL_OW 1
39625: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39626: LD_ADDR_EXP 126
39630: PUSH
39631: LD_EXP 126
39635: PPUSH
39636: LD_VAR 0 1
39640: PPUSH
39641: EMPTY
39642: PPUSH
39643: CALL_OW 1
39647: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39648: LD_ADDR_EXP 127
39652: PUSH
39653: LD_EXP 127
39657: PPUSH
39658: LD_VAR 0 1
39662: PPUSH
39663: EMPTY
39664: PPUSH
39665: CALL_OW 1
39669: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39670: LD_ADDR_EXP 129
39674: PUSH
39675: LD_EXP 129
39679: PPUSH
39680: LD_VAR 0 1
39684: PPUSH
39685: EMPTY
39686: PPUSH
39687: CALL_OW 1
39691: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39692: LD_ADDR_EXP 131
39696: PUSH
39697: LD_EXP 131
39701: PPUSH
39702: LD_VAR 0 1
39706: PPUSH
39707: EMPTY
39708: PPUSH
39709: CALL_OW 1
39713: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39714: LD_ADDR_EXP 132
39718: PUSH
39719: LD_EXP 132
39723: PPUSH
39724: LD_VAR 0 1
39728: PPUSH
39729: EMPTY
39730: PPUSH
39731: CALL_OW 1
39735: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39736: LD_ADDR_EXP 133
39740: PUSH
39741: LD_EXP 133
39745: PPUSH
39746: LD_VAR 0 1
39750: PPUSH
39751: EMPTY
39752: PPUSH
39753: CALL_OW 1
39757: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39758: LD_ADDR_EXP 134
39762: PUSH
39763: LD_EXP 134
39767: PPUSH
39768: LD_VAR 0 1
39772: PPUSH
39773: EMPTY
39774: PPUSH
39775: CALL_OW 1
39779: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39780: LD_ADDR_EXP 135
39784: PUSH
39785: LD_EXP 135
39789: PPUSH
39790: LD_VAR 0 1
39794: PPUSH
39795: EMPTY
39796: PPUSH
39797: CALL_OW 1
39801: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39802: LD_ADDR_EXP 136
39806: PUSH
39807: LD_EXP 136
39811: PPUSH
39812: LD_VAR 0 1
39816: PPUSH
39817: EMPTY
39818: PPUSH
39819: CALL_OW 1
39823: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39824: LD_ADDR_EXP 137
39828: PUSH
39829: LD_EXP 137
39833: PPUSH
39834: LD_VAR 0 1
39838: PPUSH
39839: EMPTY
39840: PPUSH
39841: CALL_OW 1
39845: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39846: LD_ADDR_EXP 138
39850: PUSH
39851: LD_EXP 138
39855: PPUSH
39856: LD_VAR 0 1
39860: PPUSH
39861: EMPTY
39862: PPUSH
39863: CALL_OW 1
39867: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39868: LD_ADDR_EXP 139
39872: PUSH
39873: LD_EXP 139
39877: PPUSH
39878: LD_VAR 0 1
39882: PPUSH
39883: EMPTY
39884: PPUSH
39885: CALL_OW 1
39889: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39890: LD_ADDR_EXP 140
39894: PUSH
39895: LD_EXP 140
39899: PPUSH
39900: LD_VAR 0 1
39904: PPUSH
39905: EMPTY
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39912: LD_ADDR_EXP 141
39916: PUSH
39917: LD_EXP 141
39921: PPUSH
39922: LD_VAR 0 1
39926: PPUSH
39927: EMPTY
39928: PPUSH
39929: CALL_OW 1
39933: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39934: LD_ADDR_EXP 142
39938: PUSH
39939: LD_EXP 142
39943: PPUSH
39944: LD_VAR 0 1
39948: PPUSH
39949: EMPTY
39950: PPUSH
39951: CALL_OW 1
39955: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39956: LD_ADDR_EXP 143
39960: PUSH
39961: LD_EXP 143
39965: PPUSH
39966: LD_VAR 0 1
39970: PPUSH
39971: EMPTY
39972: PPUSH
39973: CALL_OW 1
39977: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39978: LD_ADDR_EXP 144
39982: PUSH
39983: LD_EXP 144
39987: PPUSH
39988: LD_VAR 0 1
39992: PPUSH
39993: LD_INT 0
39995: PPUSH
39996: CALL_OW 1
40000: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40001: LD_ADDR_EXP 145
40005: PUSH
40006: LD_EXP 145
40010: PPUSH
40011: LD_VAR 0 1
40015: PPUSH
40016: LD_INT 0
40018: PPUSH
40019: CALL_OW 1
40023: ST_TO_ADDR
// end ;
40024: LD_VAR 0 2
40028: RET
// export function MC_Add ( side , units ) ; var base ; begin
40029: LD_INT 0
40031: PPUSH
40032: PPUSH
// base := mc_bases + 1 ;
40033: LD_ADDR_VAR 0 4
40037: PUSH
40038: LD_EXP 102
40042: PUSH
40043: LD_INT 1
40045: PLUS
40046: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
40047: LD_ADDR_EXP 128
40051: PUSH
40052: LD_EXP 128
40056: PPUSH
40057: LD_VAR 0 4
40061: PPUSH
40062: LD_VAR 0 1
40066: PPUSH
40067: CALL_OW 1
40071: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
40072: LD_ADDR_EXP 102
40076: PUSH
40077: LD_EXP 102
40081: PPUSH
40082: LD_VAR 0 4
40086: PPUSH
40087: LD_VAR 0 2
40091: PPUSH
40092: CALL_OW 1
40096: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40097: LD_ADDR_EXP 103
40101: PUSH
40102: LD_EXP 103
40106: PPUSH
40107: LD_VAR 0 4
40111: PPUSH
40112: EMPTY
40113: PPUSH
40114: CALL_OW 1
40118: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40119: LD_ADDR_EXP 104
40123: PUSH
40124: LD_EXP 104
40128: PPUSH
40129: LD_VAR 0 4
40133: PPUSH
40134: EMPTY
40135: PPUSH
40136: CALL_OW 1
40140: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40141: LD_ADDR_EXP 105
40145: PUSH
40146: LD_EXP 105
40150: PPUSH
40151: LD_VAR 0 4
40155: PPUSH
40156: EMPTY
40157: PPUSH
40158: CALL_OW 1
40162: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40163: LD_ADDR_EXP 106
40167: PUSH
40168: LD_EXP 106
40172: PPUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: EMPTY
40179: PPUSH
40180: CALL_OW 1
40184: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40185: LD_ADDR_EXP 107
40189: PUSH
40190: LD_EXP 107
40194: PPUSH
40195: LD_VAR 0 4
40199: PPUSH
40200: EMPTY
40201: PPUSH
40202: CALL_OW 1
40206: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40207: LD_ADDR_EXP 108
40211: PUSH
40212: LD_EXP 108
40216: PPUSH
40217: LD_VAR 0 4
40221: PPUSH
40222: EMPTY
40223: PPUSH
40224: CALL_OW 1
40228: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40229: LD_ADDR_EXP 109
40233: PUSH
40234: LD_EXP 109
40238: PPUSH
40239: LD_VAR 0 4
40243: PPUSH
40244: EMPTY
40245: PPUSH
40246: CALL_OW 1
40250: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40251: LD_ADDR_EXP 110
40255: PUSH
40256: LD_EXP 110
40260: PPUSH
40261: LD_VAR 0 4
40265: PPUSH
40266: EMPTY
40267: PPUSH
40268: CALL_OW 1
40272: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40273: LD_ADDR_EXP 111
40277: PUSH
40278: LD_EXP 111
40282: PPUSH
40283: LD_VAR 0 4
40287: PPUSH
40288: EMPTY
40289: PPUSH
40290: CALL_OW 1
40294: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40295: LD_ADDR_EXP 112
40299: PUSH
40300: LD_EXP 112
40304: PPUSH
40305: LD_VAR 0 4
40309: PPUSH
40310: EMPTY
40311: PPUSH
40312: CALL_OW 1
40316: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40317: LD_ADDR_EXP 113
40321: PUSH
40322: LD_EXP 113
40326: PPUSH
40327: LD_VAR 0 4
40331: PPUSH
40332: LD_INT 0
40334: PPUSH
40335: CALL_OW 1
40339: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40340: LD_ADDR_EXP 114
40344: PUSH
40345: LD_EXP 114
40349: PPUSH
40350: LD_VAR 0 4
40354: PPUSH
40355: EMPTY
40356: PPUSH
40357: CALL_OW 1
40361: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40362: LD_ADDR_EXP 115
40366: PUSH
40367: LD_EXP 115
40371: PPUSH
40372: LD_VAR 0 4
40376: PPUSH
40377: EMPTY
40378: PPUSH
40379: CALL_OW 1
40383: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40384: LD_ADDR_EXP 116
40388: PUSH
40389: LD_EXP 116
40393: PPUSH
40394: LD_VAR 0 4
40398: PPUSH
40399: EMPTY
40400: PPUSH
40401: CALL_OW 1
40405: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40406: LD_ADDR_EXP 117
40410: PUSH
40411: LD_EXP 117
40415: PPUSH
40416: LD_VAR 0 4
40420: PPUSH
40421: EMPTY
40422: PPUSH
40423: CALL_OW 1
40427: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40428: LD_ADDR_EXP 118
40432: PUSH
40433: LD_EXP 118
40437: PPUSH
40438: LD_VAR 0 4
40442: PPUSH
40443: EMPTY
40444: PPUSH
40445: CALL_OW 1
40449: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40450: LD_ADDR_EXP 119
40454: PUSH
40455: LD_EXP 119
40459: PPUSH
40460: LD_VAR 0 4
40464: PPUSH
40465: EMPTY
40466: PPUSH
40467: CALL_OW 1
40471: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40472: LD_ADDR_EXP 120
40476: PUSH
40477: LD_EXP 120
40481: PPUSH
40482: LD_VAR 0 4
40486: PPUSH
40487: EMPTY
40488: PPUSH
40489: CALL_OW 1
40493: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40494: LD_ADDR_EXP 121
40498: PUSH
40499: LD_EXP 121
40503: PPUSH
40504: LD_VAR 0 4
40508: PPUSH
40509: EMPTY
40510: PPUSH
40511: CALL_OW 1
40515: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40516: LD_ADDR_EXP 122
40520: PUSH
40521: LD_EXP 122
40525: PPUSH
40526: LD_VAR 0 4
40530: PPUSH
40531: EMPTY
40532: PPUSH
40533: CALL_OW 1
40537: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40538: LD_ADDR_EXP 123
40542: PUSH
40543: LD_EXP 123
40547: PPUSH
40548: LD_VAR 0 4
40552: PPUSH
40553: EMPTY
40554: PPUSH
40555: CALL_OW 1
40559: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40560: LD_ADDR_EXP 124
40564: PUSH
40565: LD_EXP 124
40569: PPUSH
40570: LD_VAR 0 4
40574: PPUSH
40575: EMPTY
40576: PPUSH
40577: CALL_OW 1
40581: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40582: LD_ADDR_EXP 125
40586: PUSH
40587: LD_EXP 125
40591: PPUSH
40592: LD_VAR 0 4
40596: PPUSH
40597: EMPTY
40598: PPUSH
40599: CALL_OW 1
40603: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40604: LD_ADDR_EXP 126
40608: PUSH
40609: LD_EXP 126
40613: PPUSH
40614: LD_VAR 0 4
40618: PPUSH
40619: EMPTY
40620: PPUSH
40621: CALL_OW 1
40625: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40626: LD_ADDR_EXP 127
40630: PUSH
40631: LD_EXP 127
40635: PPUSH
40636: LD_VAR 0 4
40640: PPUSH
40641: EMPTY
40642: PPUSH
40643: CALL_OW 1
40647: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40648: LD_ADDR_EXP 129
40652: PUSH
40653: LD_EXP 129
40657: PPUSH
40658: LD_VAR 0 4
40662: PPUSH
40663: EMPTY
40664: PPUSH
40665: CALL_OW 1
40669: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40670: LD_ADDR_EXP 131
40674: PUSH
40675: LD_EXP 131
40679: PPUSH
40680: LD_VAR 0 4
40684: PPUSH
40685: EMPTY
40686: PPUSH
40687: CALL_OW 1
40691: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40692: LD_ADDR_EXP 132
40696: PUSH
40697: LD_EXP 132
40701: PPUSH
40702: LD_VAR 0 4
40706: PPUSH
40707: EMPTY
40708: PPUSH
40709: CALL_OW 1
40713: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40714: LD_ADDR_EXP 133
40718: PUSH
40719: LD_EXP 133
40723: PPUSH
40724: LD_VAR 0 4
40728: PPUSH
40729: EMPTY
40730: PPUSH
40731: CALL_OW 1
40735: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40736: LD_ADDR_EXP 134
40740: PUSH
40741: LD_EXP 134
40745: PPUSH
40746: LD_VAR 0 4
40750: PPUSH
40751: EMPTY
40752: PPUSH
40753: CALL_OW 1
40757: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40758: LD_ADDR_EXP 135
40762: PUSH
40763: LD_EXP 135
40767: PPUSH
40768: LD_VAR 0 4
40772: PPUSH
40773: EMPTY
40774: PPUSH
40775: CALL_OW 1
40779: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40780: LD_ADDR_EXP 136
40784: PUSH
40785: LD_EXP 136
40789: PPUSH
40790: LD_VAR 0 4
40794: PPUSH
40795: EMPTY
40796: PPUSH
40797: CALL_OW 1
40801: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40802: LD_ADDR_EXP 137
40806: PUSH
40807: LD_EXP 137
40811: PPUSH
40812: LD_VAR 0 4
40816: PPUSH
40817: EMPTY
40818: PPUSH
40819: CALL_OW 1
40823: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40824: LD_ADDR_EXP 138
40828: PUSH
40829: LD_EXP 138
40833: PPUSH
40834: LD_VAR 0 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL_OW 1
40845: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40846: LD_ADDR_EXP 139
40850: PUSH
40851: LD_EXP 139
40855: PPUSH
40856: LD_VAR 0 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL_OW 1
40867: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40868: LD_ADDR_EXP 140
40872: PUSH
40873: LD_EXP 140
40877: PPUSH
40878: LD_VAR 0 4
40882: PPUSH
40883: EMPTY
40884: PPUSH
40885: CALL_OW 1
40889: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40890: LD_ADDR_EXP 141
40894: PUSH
40895: LD_EXP 141
40899: PPUSH
40900: LD_VAR 0 4
40904: PPUSH
40905: EMPTY
40906: PPUSH
40907: CALL_OW 1
40911: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40912: LD_ADDR_EXP 142
40916: PUSH
40917: LD_EXP 142
40921: PPUSH
40922: LD_VAR 0 4
40926: PPUSH
40927: EMPTY
40928: PPUSH
40929: CALL_OW 1
40933: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40934: LD_ADDR_EXP 143
40938: PUSH
40939: LD_EXP 143
40943: PPUSH
40944: LD_VAR 0 4
40948: PPUSH
40949: EMPTY
40950: PPUSH
40951: CALL_OW 1
40955: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40956: LD_ADDR_EXP 144
40960: PUSH
40961: LD_EXP 144
40965: PPUSH
40966: LD_VAR 0 4
40970: PPUSH
40971: LD_INT 0
40973: PPUSH
40974: CALL_OW 1
40978: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40979: LD_ADDR_EXP 145
40983: PUSH
40984: LD_EXP 145
40988: PPUSH
40989: LD_VAR 0 4
40993: PPUSH
40994: LD_INT 0
40996: PPUSH
40997: CALL_OW 1
41001: ST_TO_ADDR
// result := base ;
41002: LD_ADDR_VAR 0 3
41006: PUSH
41007: LD_VAR 0 4
41011: ST_TO_ADDR
// end ;
41012: LD_VAR 0 3
41016: RET
// export function MC_Start ( ) ; var i ; begin
41017: LD_INT 0
41019: PPUSH
41020: PPUSH
// for i = 1 to mc_bases do
41021: LD_ADDR_VAR 0 2
41025: PUSH
41026: DOUBLE
41027: LD_INT 1
41029: DEC
41030: ST_TO_ADDR
41031: LD_EXP 102
41035: PUSH
41036: FOR_TO
41037: IFFALSE 42137
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
41039: LD_ADDR_EXP 102
41043: PUSH
41044: LD_EXP 102
41048: PPUSH
41049: LD_VAR 0 2
41053: PPUSH
41054: LD_EXP 102
41058: PUSH
41059: LD_VAR 0 2
41063: ARRAY
41064: PUSH
41065: LD_INT 0
41067: DIFF
41068: PPUSH
41069: CALL_OW 1
41073: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
41074: LD_ADDR_EXP 103
41078: PUSH
41079: LD_EXP 103
41083: PPUSH
41084: LD_VAR 0 2
41088: PPUSH
41089: EMPTY
41090: PPUSH
41091: CALL_OW 1
41095: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
41096: LD_ADDR_EXP 104
41100: PUSH
41101: LD_EXP 104
41105: PPUSH
41106: LD_VAR 0 2
41110: PPUSH
41111: EMPTY
41112: PPUSH
41113: CALL_OW 1
41117: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
41118: LD_ADDR_EXP 105
41122: PUSH
41123: LD_EXP 105
41127: PPUSH
41128: LD_VAR 0 2
41132: PPUSH
41133: EMPTY
41134: PPUSH
41135: CALL_OW 1
41139: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
41140: LD_ADDR_EXP 106
41144: PUSH
41145: LD_EXP 106
41149: PPUSH
41150: LD_VAR 0 2
41154: PPUSH
41155: EMPTY
41156: PUSH
41157: EMPTY
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PPUSH
41163: CALL_OW 1
41167: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
41168: LD_ADDR_EXP 107
41172: PUSH
41173: LD_EXP 107
41177: PPUSH
41178: LD_VAR 0 2
41182: PPUSH
41183: EMPTY
41184: PPUSH
41185: CALL_OW 1
41189: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
41190: LD_ADDR_EXP 134
41194: PUSH
41195: LD_EXP 134
41199: PPUSH
41200: LD_VAR 0 2
41204: PPUSH
41205: EMPTY
41206: PPUSH
41207: CALL_OW 1
41211: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
41212: LD_ADDR_EXP 108
41216: PUSH
41217: LD_EXP 108
41221: PPUSH
41222: LD_VAR 0 2
41226: PPUSH
41227: EMPTY
41228: PPUSH
41229: CALL_OW 1
41233: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
41234: LD_ADDR_EXP 109
41238: PUSH
41239: LD_EXP 109
41243: PPUSH
41244: LD_VAR 0 2
41248: PPUSH
41249: EMPTY
41250: PPUSH
41251: CALL_OW 1
41255: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
41256: LD_ADDR_EXP 110
41260: PUSH
41261: LD_EXP 110
41265: PPUSH
41266: LD_VAR 0 2
41270: PPUSH
41271: LD_EXP 102
41275: PUSH
41276: LD_VAR 0 2
41280: ARRAY
41281: PPUSH
41282: LD_INT 2
41284: PUSH
41285: LD_INT 30
41287: PUSH
41288: LD_INT 32
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 30
41297: PUSH
41298: LD_INT 33
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: LIST
41309: PPUSH
41310: CALL_OW 72
41314: PPUSH
41315: CALL_OW 1
41319: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
41320: LD_ADDR_EXP 111
41324: PUSH
41325: LD_EXP 111
41329: PPUSH
41330: LD_VAR 0 2
41334: PPUSH
41335: LD_EXP 102
41339: PUSH
41340: LD_VAR 0 2
41344: ARRAY
41345: PPUSH
41346: LD_INT 2
41348: PUSH
41349: LD_INT 30
41351: PUSH
41352: LD_INT 32
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 30
41361: PUSH
41362: LD_INT 31
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 58
41376: PUSH
41377: EMPTY
41378: LIST
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PPUSH
41384: CALL_OW 72
41388: PPUSH
41389: CALL_OW 1
41393: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
41394: LD_ADDR_EXP 112
41398: PUSH
41399: LD_EXP 112
41403: PPUSH
41404: LD_VAR 0 2
41408: PPUSH
41409: EMPTY
41410: PPUSH
41411: CALL_OW 1
41415: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
41416: LD_ADDR_EXP 116
41420: PUSH
41421: LD_EXP 116
41425: PPUSH
41426: LD_VAR 0 2
41430: PPUSH
41431: EMPTY
41432: PPUSH
41433: CALL_OW 1
41437: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
41438: LD_ADDR_EXP 115
41442: PUSH
41443: LD_EXP 115
41447: PPUSH
41448: LD_VAR 0 2
41452: PPUSH
41453: EMPTY
41454: PPUSH
41455: CALL_OW 1
41459: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
41460: LD_ADDR_EXP 117
41464: PUSH
41465: LD_EXP 117
41469: PPUSH
41470: LD_VAR 0 2
41474: PPUSH
41475: EMPTY
41476: PPUSH
41477: CALL_OW 1
41481: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
41482: LD_ADDR_EXP 118
41486: PUSH
41487: LD_EXP 118
41491: PPUSH
41492: LD_VAR 0 2
41496: PPUSH
41497: EMPTY
41498: PPUSH
41499: CALL_OW 1
41503: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
41504: LD_ADDR_EXP 119
41508: PUSH
41509: LD_EXP 119
41513: PPUSH
41514: LD_VAR 0 2
41518: PPUSH
41519: EMPTY
41520: PPUSH
41521: CALL_OW 1
41525: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
41526: LD_ADDR_EXP 120
41530: PUSH
41531: LD_EXP 120
41535: PPUSH
41536: LD_VAR 0 2
41540: PPUSH
41541: EMPTY
41542: PPUSH
41543: CALL_OW 1
41547: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
41548: LD_ADDR_EXP 121
41552: PUSH
41553: LD_EXP 121
41557: PPUSH
41558: LD_VAR 0 2
41562: PPUSH
41563: EMPTY
41564: PPUSH
41565: CALL_OW 1
41569: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
41570: LD_ADDR_EXP 122
41574: PUSH
41575: LD_EXP 122
41579: PPUSH
41580: LD_VAR 0 2
41584: PPUSH
41585: EMPTY
41586: PPUSH
41587: CALL_OW 1
41591: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
41592: LD_ADDR_EXP 123
41596: PUSH
41597: LD_EXP 123
41601: PPUSH
41602: LD_VAR 0 2
41606: PPUSH
41607: EMPTY
41608: PPUSH
41609: CALL_OW 1
41613: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
41614: LD_ADDR_EXP 124
41618: PUSH
41619: LD_EXP 124
41623: PPUSH
41624: LD_VAR 0 2
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL_OW 1
41635: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41636: LD_ADDR_EXP 113
41640: PUSH
41641: LD_EXP 113
41645: PPUSH
41646: LD_VAR 0 2
41650: PPUSH
41651: LD_INT 0
41653: PPUSH
41654: CALL_OW 1
41658: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41659: LD_ADDR_EXP 126
41663: PUSH
41664: LD_EXP 126
41668: PPUSH
41669: LD_VAR 0 2
41673: PPUSH
41674: LD_INT 0
41676: PPUSH
41677: CALL_OW 1
41681: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41682: LD_ADDR_EXP 114
41686: PUSH
41687: LD_EXP 114
41691: PPUSH
41692: LD_VAR 0 2
41696: PPUSH
41697: EMPTY
41698: PPUSH
41699: CALL_OW 1
41703: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41704: LD_ADDR_EXP 125
41708: PUSH
41709: LD_EXP 125
41713: PPUSH
41714: LD_VAR 0 2
41718: PPUSH
41719: LD_INT 0
41721: PPUSH
41722: CALL_OW 1
41726: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41727: LD_ADDR_EXP 127
41731: PUSH
41732: LD_EXP 127
41736: PPUSH
41737: LD_VAR 0 2
41741: PPUSH
41742: EMPTY
41743: PPUSH
41744: CALL_OW 1
41748: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41749: LD_ADDR_EXP 130
41753: PUSH
41754: LD_EXP 130
41758: PPUSH
41759: LD_VAR 0 2
41763: PPUSH
41764: LD_INT 0
41766: PPUSH
41767: CALL_OW 1
41771: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41772: LD_ADDR_EXP 131
41776: PUSH
41777: LD_EXP 131
41781: PPUSH
41782: LD_VAR 0 2
41786: PPUSH
41787: EMPTY
41788: PPUSH
41789: CALL_OW 1
41793: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41794: LD_ADDR_EXP 132
41798: PUSH
41799: LD_EXP 132
41803: PPUSH
41804: LD_VAR 0 2
41808: PPUSH
41809: EMPTY
41810: PPUSH
41811: CALL_OW 1
41815: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41816: LD_ADDR_EXP 133
41820: PUSH
41821: LD_EXP 133
41825: PPUSH
41826: LD_VAR 0 2
41830: PPUSH
41831: EMPTY
41832: PPUSH
41833: CALL_OW 1
41837: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41838: LD_ADDR_EXP 135
41842: PUSH
41843: LD_EXP 135
41847: PPUSH
41848: LD_VAR 0 2
41852: PPUSH
41853: LD_EXP 102
41857: PUSH
41858: LD_VAR 0 2
41862: ARRAY
41863: PPUSH
41864: LD_INT 2
41866: PUSH
41867: LD_INT 30
41869: PUSH
41870: LD_INT 6
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 30
41879: PUSH
41880: LD_INT 7
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 30
41889: PUSH
41890: LD_INT 8
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: PPUSH
41903: CALL_OW 72
41907: PPUSH
41908: CALL_OW 1
41912: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41913: LD_ADDR_EXP 136
41917: PUSH
41918: LD_EXP 136
41922: PPUSH
41923: LD_VAR 0 2
41927: PPUSH
41928: EMPTY
41929: PPUSH
41930: CALL_OW 1
41934: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41935: LD_ADDR_EXP 137
41939: PUSH
41940: LD_EXP 137
41944: PPUSH
41945: LD_VAR 0 2
41949: PPUSH
41950: EMPTY
41951: PPUSH
41952: CALL_OW 1
41956: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41957: LD_ADDR_EXP 138
41961: PUSH
41962: LD_EXP 138
41966: PPUSH
41967: LD_VAR 0 2
41971: PPUSH
41972: EMPTY
41973: PPUSH
41974: CALL_OW 1
41978: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41979: LD_ADDR_EXP 139
41983: PUSH
41984: LD_EXP 139
41988: PPUSH
41989: LD_VAR 0 2
41993: PPUSH
41994: EMPTY
41995: PPUSH
41996: CALL_OW 1
42000: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42001: LD_ADDR_EXP 140
42005: PUSH
42006: LD_EXP 140
42010: PPUSH
42011: LD_VAR 0 2
42015: PPUSH
42016: EMPTY
42017: PPUSH
42018: CALL_OW 1
42022: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
42023: LD_ADDR_EXP 141
42027: PUSH
42028: LD_EXP 141
42032: PPUSH
42033: LD_VAR 0 2
42037: PPUSH
42038: EMPTY
42039: PPUSH
42040: CALL_OW 1
42044: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
42045: LD_ADDR_EXP 142
42049: PUSH
42050: LD_EXP 142
42054: PPUSH
42055: LD_VAR 0 2
42059: PPUSH
42060: EMPTY
42061: PPUSH
42062: CALL_OW 1
42066: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
42067: LD_ADDR_EXP 143
42071: PUSH
42072: LD_EXP 143
42076: PPUSH
42077: LD_VAR 0 2
42081: PPUSH
42082: EMPTY
42083: PPUSH
42084: CALL_OW 1
42088: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
42089: LD_ADDR_EXP 144
42093: PUSH
42094: LD_EXP 144
42098: PPUSH
42099: LD_VAR 0 2
42103: PPUSH
42104: LD_INT 0
42106: PPUSH
42107: CALL_OW 1
42111: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
42112: LD_ADDR_EXP 145
42116: PUSH
42117: LD_EXP 145
42121: PPUSH
42122: LD_VAR 0 2
42126: PPUSH
42127: LD_INT 0
42129: PPUSH
42130: CALL_OW 1
42134: ST_TO_ADDR
// end ;
42135: GO 41036
42137: POP
42138: POP
// MC_InitSides ( ) ;
42139: CALL 42425 0 0
// MC_InitResearch ( ) ;
42143: CALL 42164 0 0
// CustomInitMacro ( ) ;
42147: CALL 475 0 0
// skirmish := true ;
42151: LD_ADDR_EXP 100
42155: PUSH
42156: LD_INT 1
42158: ST_TO_ADDR
// end ;
42159: LD_VAR 0 1
42163: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
42164: LD_INT 0
42166: PPUSH
42167: PPUSH
42168: PPUSH
42169: PPUSH
42170: PPUSH
42171: PPUSH
// if not mc_bases then
42172: LD_EXP 102
42176: NOT
42177: IFFALSE 42181
// exit ;
42179: GO 42420
// for i = 1 to 8 do
42181: LD_ADDR_VAR 0 2
42185: PUSH
42186: DOUBLE
42187: LD_INT 1
42189: DEC
42190: ST_TO_ADDR
42191: LD_INT 8
42193: PUSH
42194: FOR_TO
42195: IFFALSE 42221
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
42197: LD_ADDR_EXP 129
42201: PUSH
42202: LD_EXP 129
42206: PPUSH
42207: LD_VAR 0 2
42211: PPUSH
42212: EMPTY
42213: PPUSH
42214: CALL_OW 1
42218: ST_TO_ADDR
42219: GO 42194
42221: POP
42222: POP
// tmp := [ ] ;
42223: LD_ADDR_VAR 0 5
42227: PUSH
42228: EMPTY
42229: ST_TO_ADDR
// for i = 1 to mc_sides do
42230: LD_ADDR_VAR 0 2
42234: PUSH
42235: DOUBLE
42236: LD_INT 1
42238: DEC
42239: ST_TO_ADDR
42240: LD_EXP 128
42244: PUSH
42245: FOR_TO
42246: IFFALSE 42304
// if not mc_sides [ i ] in tmp then
42248: LD_EXP 128
42252: PUSH
42253: LD_VAR 0 2
42257: ARRAY
42258: PUSH
42259: LD_VAR 0 5
42263: IN
42264: NOT
42265: IFFALSE 42302
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
42267: LD_ADDR_VAR 0 5
42271: PUSH
42272: LD_VAR 0 5
42276: PPUSH
42277: LD_VAR 0 5
42281: PUSH
42282: LD_INT 1
42284: PLUS
42285: PPUSH
42286: LD_EXP 128
42290: PUSH
42291: LD_VAR 0 2
42295: ARRAY
42296: PPUSH
42297: CALL_OW 2
42301: ST_TO_ADDR
42302: GO 42245
42304: POP
42305: POP
// if not tmp then
42306: LD_VAR 0 5
42310: NOT
42311: IFFALSE 42315
// exit ;
42313: GO 42420
// for j in tmp do
42315: LD_ADDR_VAR 0 3
42319: PUSH
42320: LD_VAR 0 5
42324: PUSH
42325: FOR_IN
42326: IFFALSE 42418
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
42328: LD_ADDR_VAR 0 6
42332: PUSH
42333: LD_INT 22
42335: PUSH
42336: LD_VAR 0 3
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PPUSH
42345: CALL_OW 69
42349: ST_TO_ADDR
// if not un then
42350: LD_VAR 0 6
42354: NOT
42355: IFFALSE 42359
// continue ;
42357: GO 42325
// nation := GetNation ( un [ 1 ] ) ;
42359: LD_ADDR_VAR 0 4
42363: PUSH
42364: LD_VAR 0 6
42368: PUSH
42369: LD_INT 1
42371: ARRAY
42372: PPUSH
42373: CALL_OW 248
42377: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
42378: LD_ADDR_EXP 129
42382: PUSH
42383: LD_EXP 129
42387: PPUSH
42388: LD_VAR 0 3
42392: PPUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: LD_VAR 0 4
42402: PPUSH
42403: LD_INT 1
42405: PPUSH
42406: CALL 69608 0 3
42410: PPUSH
42411: CALL_OW 1
42415: ST_TO_ADDR
// end ;
42416: GO 42325
42418: POP
42419: POP
// end ;
42420: LD_VAR 0 1
42424: RET
// export function MC_InitSides ( ) ; var i ; begin
42425: LD_INT 0
42427: PPUSH
42428: PPUSH
// if not mc_bases then
42429: LD_EXP 102
42433: NOT
42434: IFFALSE 42438
// exit ;
42436: GO 42512
// for i = 1 to mc_bases do
42438: LD_ADDR_VAR 0 2
42442: PUSH
42443: DOUBLE
42444: LD_INT 1
42446: DEC
42447: ST_TO_ADDR
42448: LD_EXP 102
42452: PUSH
42453: FOR_TO
42454: IFFALSE 42510
// if mc_bases [ i ] then
42456: LD_EXP 102
42460: PUSH
42461: LD_VAR 0 2
42465: ARRAY
42466: IFFALSE 42508
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
42468: LD_ADDR_EXP 128
42472: PUSH
42473: LD_EXP 128
42477: PPUSH
42478: LD_VAR 0 2
42482: PPUSH
42483: LD_EXP 102
42487: PUSH
42488: LD_VAR 0 2
42492: ARRAY
42493: PUSH
42494: LD_INT 1
42496: ARRAY
42497: PPUSH
42498: CALL_OW 255
42502: PPUSH
42503: CALL_OW 1
42507: ST_TO_ADDR
42508: GO 42453
42510: POP
42511: POP
// end ;
42512: LD_VAR 0 1
42516: RET
// every 0 0$03 trigger skirmish do
42517: LD_EXP 100
42521: IFFALSE 42675
42523: GO 42525
42525: DISABLE
// begin enable ;
42526: ENABLE
// MC_CheckBuildings ( ) ;
42527: CALL 47187 0 0
// MC_CheckPeopleLife ( ) ;
42531: CALL 47348 0 0
// RaiseSailEvent ( 100 ) ;
42535: LD_INT 100
42537: PPUSH
42538: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
42542: LD_INT 103
42544: PPUSH
42545: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
42549: LD_INT 104
42551: PPUSH
42552: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
42556: LD_INT 105
42558: PPUSH
42559: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
42563: LD_INT 106
42565: PPUSH
42566: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
42570: LD_INT 107
42572: PPUSH
42573: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
42577: LD_INT 108
42579: PPUSH
42580: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
42584: LD_INT 109
42586: PPUSH
42587: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
42591: LD_INT 110
42593: PPUSH
42594: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
42598: LD_INT 111
42600: PPUSH
42601: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
42605: LD_INT 112
42607: PPUSH
42608: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
42612: LD_INT 113
42614: PPUSH
42615: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
42619: LD_INT 120
42621: PPUSH
42622: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
42626: LD_INT 121
42628: PPUSH
42629: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42633: LD_INT 122
42635: PPUSH
42636: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42640: LD_INT 123
42642: PPUSH
42643: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42647: LD_INT 124
42649: PPUSH
42650: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42654: LD_INT 125
42656: PPUSH
42657: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42661: LD_INT 126
42663: PPUSH
42664: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42668: LD_INT 200
42670: PPUSH
42671: CALL_OW 427
// end ;
42675: END
// on SailEvent ( event ) do begin if event < 100 then
42676: LD_VAR 0 1
42680: PUSH
42681: LD_INT 100
42683: LESS
42684: IFFALSE 42695
// CustomEvent ( event ) ;
42686: LD_VAR 0 1
42690: PPUSH
42691: CALL 37051 0 1
// if event = 100 then
42695: LD_VAR 0 1
42699: PUSH
42700: LD_INT 100
42702: EQUAL
42703: IFFALSE 42709
// MC_ClassManager ( ) ;
42705: CALL 43101 0 0
// if event = 101 then
42709: LD_VAR 0 1
42713: PUSH
42714: LD_INT 101
42716: EQUAL
42717: IFFALSE 42723
// MC_RepairBuildings ( ) ;
42719: CALL 47933 0 0
// if event = 102 then
42723: LD_VAR 0 1
42727: PUSH
42728: LD_INT 102
42730: EQUAL
42731: IFFALSE 42737
// MC_Heal ( ) ;
42733: CALL 48868 0 0
// if event = 103 then
42737: LD_VAR 0 1
42741: PUSH
42742: LD_INT 103
42744: EQUAL
42745: IFFALSE 42751
// MC_Build ( ) ;
42747: CALL 49290 0 0
// if event = 104 then
42751: LD_VAR 0 1
42755: PUSH
42756: LD_INT 104
42758: EQUAL
42759: IFFALSE 42765
// MC_TurretWeapon ( ) ;
42761: CALL 50924 0 0
// if event = 105 then
42765: LD_VAR 0 1
42769: PUSH
42770: LD_INT 105
42772: EQUAL
42773: IFFALSE 42779
// MC_BuildUpgrade ( ) ;
42775: CALL 50475 0 0
// if event = 106 then
42779: LD_VAR 0 1
42783: PUSH
42784: LD_INT 106
42786: EQUAL
42787: IFFALSE 42793
// MC_PlantMines ( ) ;
42789: CALL 51354 0 0
// if event = 107 then
42793: LD_VAR 0 1
42797: PUSH
42798: LD_INT 107
42800: EQUAL
42801: IFFALSE 42807
// MC_CollectCrates ( ) ;
42803: CALL 52152 0 0
// if event = 108 then
42807: LD_VAR 0 1
42811: PUSH
42812: LD_INT 108
42814: EQUAL
42815: IFFALSE 42821
// MC_LinkRemoteControl ( ) ;
42817: CALL 54002 0 0
// if event = 109 then
42821: LD_VAR 0 1
42825: PUSH
42826: LD_INT 109
42828: EQUAL
42829: IFFALSE 42835
// MC_ProduceVehicle ( ) ;
42831: CALL 54183 0 0
// if event = 110 then
42835: LD_VAR 0 1
42839: PUSH
42840: LD_INT 110
42842: EQUAL
42843: IFFALSE 42849
// MC_SendAttack ( ) ;
42845: CALL 54649 0 0
// if event = 111 then
42849: LD_VAR 0 1
42853: PUSH
42854: LD_INT 111
42856: EQUAL
42857: IFFALSE 42863
// MC_Defend ( ) ;
42859: CALL 54757 0 0
// if event = 112 then
42863: LD_VAR 0 1
42867: PUSH
42868: LD_INT 112
42870: EQUAL
42871: IFFALSE 42877
// MC_Research ( ) ;
42873: CALL 55637 0 0
// if event = 113 then
42877: LD_VAR 0 1
42881: PUSH
42882: LD_INT 113
42884: EQUAL
42885: IFFALSE 42891
// MC_MinesTrigger ( ) ;
42887: CALL 56751 0 0
// if event = 120 then
42891: LD_VAR 0 1
42895: PUSH
42896: LD_INT 120
42898: EQUAL
42899: IFFALSE 42905
// MC_RepairVehicle ( ) ;
42901: CALL 56850 0 0
// if event = 121 then
42905: LD_VAR 0 1
42909: PUSH
42910: LD_INT 121
42912: EQUAL
42913: IFFALSE 42919
// MC_TameApe ( ) ;
42915: CALL 57619 0 0
// if event = 122 then
42919: LD_VAR 0 1
42923: PUSH
42924: LD_INT 122
42926: EQUAL
42927: IFFALSE 42933
// MC_ChangeApeClass ( ) ;
42929: CALL 58448 0 0
// if event = 123 then
42933: LD_VAR 0 1
42937: PUSH
42938: LD_INT 123
42940: EQUAL
42941: IFFALSE 42947
// MC_Bazooka ( ) ;
42943: CALL 59098 0 0
// if event = 124 then
42947: LD_VAR 0 1
42951: PUSH
42952: LD_INT 124
42954: EQUAL
42955: IFFALSE 42961
// MC_TeleportExit ( ) ;
42957: CALL 59296 0 0
// if event = 125 then
42961: LD_VAR 0 1
42965: PUSH
42966: LD_INT 125
42968: EQUAL
42969: IFFALSE 42975
// MC_Deposits ( ) ;
42971: CALL 59943 0 0
// if event = 126 then
42975: LD_VAR 0 1
42979: PUSH
42980: LD_INT 126
42982: EQUAL
42983: IFFALSE 42989
// MC_RemoteDriver ( ) ;
42985: CALL 60568 0 0
// if event = 200 then
42989: LD_VAR 0 1
42993: PUSH
42994: LD_INT 200
42996: EQUAL
42997: IFFALSE 43003
// MC_Idle ( ) ;
42999: CALL 62475 0 0
// end ;
43003: PPOPN 1
43005: END
// export function MC_Reset ( base , tag ) ; var i ; begin
43006: LD_INT 0
43008: PPUSH
43009: PPUSH
// if not mc_bases [ base ] or not tag then
43010: LD_EXP 102
43014: PUSH
43015: LD_VAR 0 1
43019: ARRAY
43020: NOT
43021: PUSH
43022: LD_VAR 0 2
43026: NOT
43027: OR
43028: IFFALSE 43032
// exit ;
43030: GO 43096
// for i in mc_bases [ base ] union mc_ape [ base ] do
43032: LD_ADDR_VAR 0 4
43036: PUSH
43037: LD_EXP 102
43041: PUSH
43042: LD_VAR 0 1
43046: ARRAY
43047: PUSH
43048: LD_EXP 131
43052: PUSH
43053: LD_VAR 0 1
43057: ARRAY
43058: UNION
43059: PUSH
43060: FOR_IN
43061: IFFALSE 43094
// if GetTag ( i ) = tag then
43063: LD_VAR 0 4
43067: PPUSH
43068: CALL_OW 110
43072: PUSH
43073: LD_VAR 0 2
43077: EQUAL
43078: IFFALSE 43092
// SetTag ( i , 0 ) ;
43080: LD_VAR 0 4
43084: PPUSH
43085: LD_INT 0
43087: PPUSH
43088: CALL_OW 109
43092: GO 43060
43094: POP
43095: POP
// end ;
43096: LD_VAR 0 3
43100: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
43101: LD_INT 0
43103: PPUSH
43104: PPUSH
43105: PPUSH
43106: PPUSH
43107: PPUSH
43108: PPUSH
43109: PPUSH
43110: PPUSH
// if not mc_bases then
43111: LD_EXP 102
43115: NOT
43116: IFFALSE 43120
// exit ;
43118: GO 43569
// for i = 1 to mc_bases do
43120: LD_ADDR_VAR 0 2
43124: PUSH
43125: DOUBLE
43126: LD_INT 1
43128: DEC
43129: ST_TO_ADDR
43130: LD_EXP 102
43134: PUSH
43135: FOR_TO
43136: IFFALSE 43567
// begin tmp := MC_ClassCheckReq ( i ) ;
43138: LD_ADDR_VAR 0 4
43142: PUSH
43143: LD_VAR 0 2
43147: PPUSH
43148: CALL 43574 0 1
43152: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
43153: LD_ADDR_EXP 143
43157: PUSH
43158: LD_EXP 143
43162: PPUSH
43163: LD_VAR 0 2
43167: PPUSH
43168: LD_VAR 0 4
43172: PPUSH
43173: CALL_OW 1
43177: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
43178: LD_ADDR_VAR 0 6
43182: PUSH
43183: LD_EXP 102
43187: PUSH
43188: LD_VAR 0 2
43192: ARRAY
43193: PPUSH
43194: LD_INT 2
43196: PUSH
43197: LD_INT 30
43199: PUSH
43200: LD_INT 4
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 30
43209: PUSH
43210: LD_INT 5
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: LIST
43221: PPUSH
43222: CALL_OW 72
43226: PUSH
43227: LD_EXP 102
43231: PUSH
43232: LD_VAR 0 2
43236: ARRAY
43237: PPUSH
43238: LD_INT 2
43240: PUSH
43241: LD_INT 30
43243: PUSH
43244: LD_INT 0
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: LD_INT 30
43253: PUSH
43254: LD_INT 1
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: LIST
43265: PPUSH
43266: CALL_OW 72
43270: PUSH
43271: LD_EXP 102
43275: PUSH
43276: LD_VAR 0 2
43280: ARRAY
43281: PPUSH
43282: LD_INT 30
43284: PUSH
43285: LD_INT 3
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PPUSH
43292: CALL_OW 72
43296: PUSH
43297: LD_EXP 102
43301: PUSH
43302: LD_VAR 0 2
43306: ARRAY
43307: PPUSH
43308: LD_INT 2
43310: PUSH
43311: LD_INT 30
43313: PUSH
43314: LD_INT 6
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 30
43323: PUSH
43324: LD_INT 7
43326: PUSH
43327: EMPTY
43328: LIST
43329: LIST
43330: PUSH
43331: LD_INT 30
43333: PUSH
43334: LD_INT 8
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: LIST
43345: LIST
43346: PPUSH
43347: CALL_OW 72
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: ST_TO_ADDR
// for j := 1 to 4 do
43358: LD_ADDR_VAR 0 3
43362: PUSH
43363: DOUBLE
43364: LD_INT 1
43366: DEC
43367: ST_TO_ADDR
43368: LD_INT 4
43370: PUSH
43371: FOR_TO
43372: IFFALSE 43563
// begin if not tmp [ j ] then
43374: LD_VAR 0 4
43378: PUSH
43379: LD_VAR 0 3
43383: ARRAY
43384: NOT
43385: IFFALSE 43389
// continue ;
43387: GO 43371
// for p in tmp [ j ] do
43389: LD_ADDR_VAR 0 5
43393: PUSH
43394: LD_VAR 0 4
43398: PUSH
43399: LD_VAR 0 3
43403: ARRAY
43404: PUSH
43405: FOR_IN
43406: IFFALSE 43559
// begin if not b [ j ] then
43408: LD_VAR 0 6
43412: PUSH
43413: LD_VAR 0 3
43417: ARRAY
43418: NOT
43419: IFFALSE 43423
// break ;
43421: GO 43559
// e := 0 ;
43423: LD_ADDR_VAR 0 7
43427: PUSH
43428: LD_INT 0
43430: ST_TO_ADDR
// for k in b [ j ] do
43431: LD_ADDR_VAR 0 8
43435: PUSH
43436: LD_VAR 0 6
43440: PUSH
43441: LD_VAR 0 3
43445: ARRAY
43446: PUSH
43447: FOR_IN
43448: IFFALSE 43475
// if IsNotFull ( k ) then
43450: LD_VAR 0 8
43454: PPUSH
43455: CALL 71729 0 1
43459: IFFALSE 43473
// begin e := k ;
43461: LD_ADDR_VAR 0 7
43465: PUSH
43466: LD_VAR 0 8
43470: ST_TO_ADDR
// break ;
43471: GO 43475
// end ;
43473: GO 43447
43475: POP
43476: POP
// if e and not UnitGoingToBuilding ( p , e ) then
43477: LD_VAR 0 7
43481: PUSH
43482: LD_VAR 0 5
43486: PPUSH
43487: LD_VAR 0 7
43491: PPUSH
43492: CALL 105868 0 2
43496: NOT
43497: AND
43498: IFFALSE 43557
// begin if IsInUnit ( p ) then
43500: LD_VAR 0 5
43504: PPUSH
43505: CALL_OW 310
43509: IFFALSE 43520
// ComExitBuilding ( p ) ;
43511: LD_VAR 0 5
43515: PPUSH
43516: CALL_OW 122
// ComEnterUnit ( p , e ) ;
43520: LD_VAR 0 5
43524: PPUSH
43525: LD_VAR 0 7
43529: PPUSH
43530: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
43534: LD_VAR 0 5
43538: PPUSH
43539: LD_VAR 0 3
43543: PPUSH
43544: CALL_OW 183
// AddComExitBuilding ( p ) ;
43548: LD_VAR 0 5
43552: PPUSH
43553: CALL_OW 182
// end ; end ;
43557: GO 43405
43559: POP
43560: POP
// end ;
43561: GO 43371
43563: POP
43564: POP
// end ;
43565: GO 43135
43567: POP
43568: POP
// end ;
43569: LD_VAR 0 1
43573: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
43574: LD_INT 0
43576: PPUSH
43577: PPUSH
43578: PPUSH
43579: PPUSH
43580: PPUSH
43581: PPUSH
43582: PPUSH
43583: PPUSH
43584: PPUSH
43585: PPUSH
43586: PPUSH
43587: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
43588: LD_ADDR_VAR 0 2
43592: PUSH
43593: LD_INT 0
43595: PUSH
43596: LD_INT 0
43598: PUSH
43599: LD_INT 0
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43611: LD_VAR 0 1
43615: NOT
43616: PUSH
43617: LD_EXP 102
43621: PUSH
43622: LD_VAR 0 1
43626: ARRAY
43627: NOT
43628: OR
43629: PUSH
43630: LD_EXP 102
43634: PUSH
43635: LD_VAR 0 1
43639: ARRAY
43640: PPUSH
43641: LD_INT 2
43643: PUSH
43644: LD_INT 30
43646: PUSH
43647: LD_INT 0
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 30
43656: PUSH
43657: LD_INT 1
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PPUSH
43669: CALL_OW 72
43673: NOT
43674: OR
43675: IFFALSE 43679
// exit ;
43677: GO 47182
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43679: LD_ADDR_VAR 0 4
43683: PUSH
43684: LD_EXP 102
43688: PUSH
43689: LD_VAR 0 1
43693: ARRAY
43694: PPUSH
43695: LD_INT 2
43697: PUSH
43698: LD_INT 25
43700: PUSH
43701: LD_INT 1
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 25
43710: PUSH
43711: LD_INT 2
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 25
43720: PUSH
43721: LD_INT 3
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 25
43730: PUSH
43731: LD_INT 4
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 25
43740: PUSH
43741: LD_INT 5
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 25
43750: PUSH
43751: LD_INT 8
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 25
43760: PUSH
43761: LD_INT 9
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: EMPTY
43769: LIST
43770: LIST
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: PPUSH
43778: CALL_OW 72
43782: ST_TO_ADDR
// if not tmp then
43783: LD_VAR 0 4
43787: NOT
43788: IFFALSE 43792
// exit ;
43790: GO 47182
// for i in tmp do
43792: LD_ADDR_VAR 0 3
43796: PUSH
43797: LD_VAR 0 4
43801: PUSH
43802: FOR_IN
43803: IFFALSE 43834
// if GetTag ( i ) then
43805: LD_VAR 0 3
43809: PPUSH
43810: CALL_OW 110
43814: IFFALSE 43832
// tmp := tmp diff i ;
43816: LD_ADDR_VAR 0 4
43820: PUSH
43821: LD_VAR 0 4
43825: PUSH
43826: LD_VAR 0 3
43830: DIFF
43831: ST_TO_ADDR
43832: GO 43802
43834: POP
43835: POP
// if not tmp then
43836: LD_VAR 0 4
43840: NOT
43841: IFFALSE 43845
// exit ;
43843: GO 47182
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43845: LD_ADDR_VAR 0 5
43849: PUSH
43850: LD_EXP 102
43854: PUSH
43855: LD_VAR 0 1
43859: ARRAY
43860: PPUSH
43861: LD_INT 2
43863: PUSH
43864: LD_INT 25
43866: PUSH
43867: LD_INT 1
43869: PUSH
43870: EMPTY
43871: LIST
43872: LIST
43873: PUSH
43874: LD_INT 25
43876: PUSH
43877: LD_INT 5
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 25
43886: PUSH
43887: LD_INT 8
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 25
43896: PUSH
43897: LD_INT 9
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: PPUSH
43911: CALL_OW 72
43915: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43916: LD_ADDR_VAR 0 6
43920: PUSH
43921: LD_EXP 102
43925: PUSH
43926: LD_VAR 0 1
43930: ARRAY
43931: PPUSH
43932: LD_INT 25
43934: PUSH
43935: LD_INT 2
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: PPUSH
43942: CALL_OW 72
43946: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43947: LD_ADDR_VAR 0 7
43951: PUSH
43952: LD_EXP 102
43956: PUSH
43957: LD_VAR 0 1
43961: ARRAY
43962: PPUSH
43963: LD_INT 25
43965: PUSH
43966: LD_INT 3
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PPUSH
43973: CALL_OW 72
43977: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43978: LD_ADDR_VAR 0 8
43982: PUSH
43983: LD_EXP 102
43987: PUSH
43988: LD_VAR 0 1
43992: ARRAY
43993: PPUSH
43994: LD_INT 25
43996: PUSH
43997: LD_INT 4
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: LD_INT 24
44006: PUSH
44007: LD_INT 251
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PPUSH
44018: CALL_OW 72
44022: ST_TO_ADDR
// if mc_is_defending [ base ] then
44023: LD_EXP 145
44027: PUSH
44028: LD_VAR 0 1
44032: ARRAY
44033: IFFALSE 44494
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
44035: LD_ADDR_EXP 144
44039: PUSH
44040: LD_EXP 144
44044: PPUSH
44045: LD_VAR 0 1
44049: PPUSH
44050: LD_INT 4
44052: PPUSH
44053: CALL_OW 1
44057: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
44058: LD_ADDR_VAR 0 12
44062: PUSH
44063: LD_EXP 102
44067: PUSH
44068: LD_VAR 0 1
44072: ARRAY
44073: PPUSH
44074: LD_INT 2
44076: PUSH
44077: LD_INT 30
44079: PUSH
44080: LD_INT 4
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 30
44089: PUSH
44090: LD_INT 5
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: LIST
44101: PPUSH
44102: CALL_OW 72
44106: ST_TO_ADDR
// if not b then
44107: LD_VAR 0 12
44111: NOT
44112: IFFALSE 44116
// exit ;
44114: GO 47182
// p := [ ] ;
44116: LD_ADDR_VAR 0 11
44120: PUSH
44121: EMPTY
44122: ST_TO_ADDR
// if sci >= 2 then
44123: LD_VAR 0 8
44127: PUSH
44128: LD_INT 2
44130: GREATEREQUAL
44131: IFFALSE 44162
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
44133: LD_ADDR_VAR 0 8
44137: PUSH
44138: LD_VAR 0 8
44142: PUSH
44143: LD_INT 1
44145: ARRAY
44146: PUSH
44147: LD_VAR 0 8
44151: PUSH
44152: LD_INT 2
44154: ARRAY
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: ST_TO_ADDR
44160: GO 44223
// if sci = 1 then
44162: LD_VAR 0 8
44166: PUSH
44167: LD_INT 1
44169: EQUAL
44170: IFFALSE 44191
// sci := [ sci [ 1 ] ] else
44172: LD_ADDR_VAR 0 8
44176: PUSH
44177: LD_VAR 0 8
44181: PUSH
44182: LD_INT 1
44184: ARRAY
44185: PUSH
44186: EMPTY
44187: LIST
44188: ST_TO_ADDR
44189: GO 44223
// if sci = 0 then
44191: LD_VAR 0 8
44195: PUSH
44196: LD_INT 0
44198: EQUAL
44199: IFFALSE 44223
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
44201: LD_ADDR_VAR 0 11
44205: PUSH
44206: LD_VAR 0 4
44210: PPUSH
44211: LD_INT 4
44213: PPUSH
44214: CALL 105740 0 2
44218: PUSH
44219: LD_INT 1
44221: ARRAY
44222: ST_TO_ADDR
// if eng > 4 then
44223: LD_VAR 0 6
44227: PUSH
44228: LD_INT 4
44230: GREATER
44231: IFFALSE 44277
// for i = eng downto 4 do
44233: LD_ADDR_VAR 0 3
44237: PUSH
44238: DOUBLE
44239: LD_VAR 0 6
44243: INC
44244: ST_TO_ADDR
44245: LD_INT 4
44247: PUSH
44248: FOR_DOWNTO
44249: IFFALSE 44275
// eng := eng diff eng [ i ] ;
44251: LD_ADDR_VAR 0 6
44255: PUSH
44256: LD_VAR 0 6
44260: PUSH
44261: LD_VAR 0 6
44265: PUSH
44266: LD_VAR 0 3
44270: ARRAY
44271: DIFF
44272: ST_TO_ADDR
44273: GO 44248
44275: POP
44276: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
44277: LD_ADDR_VAR 0 4
44281: PUSH
44282: LD_VAR 0 4
44286: PUSH
44287: LD_VAR 0 5
44291: PUSH
44292: LD_VAR 0 6
44296: UNION
44297: PUSH
44298: LD_VAR 0 7
44302: UNION
44303: PUSH
44304: LD_VAR 0 8
44308: UNION
44309: DIFF
44310: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
44311: LD_ADDR_VAR 0 13
44315: PUSH
44316: LD_EXP 102
44320: PUSH
44321: LD_VAR 0 1
44325: ARRAY
44326: PPUSH
44327: LD_INT 2
44329: PUSH
44330: LD_INT 30
44332: PUSH
44333: LD_INT 32
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 30
44342: PUSH
44343: LD_INT 31
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: LIST
44354: PPUSH
44355: CALL_OW 72
44359: PUSH
44360: LD_EXP 102
44364: PUSH
44365: LD_VAR 0 1
44369: ARRAY
44370: PPUSH
44371: LD_INT 2
44373: PUSH
44374: LD_INT 30
44376: PUSH
44377: LD_INT 4
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 30
44386: PUSH
44387: LD_INT 5
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: PPUSH
44399: CALL_OW 72
44403: PUSH
44404: LD_INT 6
44406: MUL
44407: PLUS
44408: ST_TO_ADDR
// if bcount < tmp then
44409: LD_VAR 0 13
44413: PUSH
44414: LD_VAR 0 4
44418: LESS
44419: IFFALSE 44465
// for i = tmp downto bcount do
44421: LD_ADDR_VAR 0 3
44425: PUSH
44426: DOUBLE
44427: LD_VAR 0 4
44431: INC
44432: ST_TO_ADDR
44433: LD_VAR 0 13
44437: PUSH
44438: FOR_DOWNTO
44439: IFFALSE 44463
// tmp := Delete ( tmp , tmp ) ;
44441: LD_ADDR_VAR 0 4
44445: PUSH
44446: LD_VAR 0 4
44450: PPUSH
44451: LD_VAR 0 4
44455: PPUSH
44456: CALL_OW 3
44460: ST_TO_ADDR
44461: GO 44438
44463: POP
44464: POP
// result := [ tmp , 0 , 0 , p ] ;
44465: LD_ADDR_VAR 0 2
44469: PUSH
44470: LD_VAR 0 4
44474: PUSH
44475: LD_INT 0
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: LD_VAR 0 11
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: ST_TO_ADDR
// exit ;
44492: GO 47182
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44494: LD_EXP 102
44498: PUSH
44499: LD_VAR 0 1
44503: ARRAY
44504: PPUSH
44505: LD_INT 2
44507: PUSH
44508: LD_INT 30
44510: PUSH
44511: LD_INT 6
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 30
44520: PUSH
44521: LD_INT 7
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 30
44530: PUSH
44531: LD_INT 8
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: PPUSH
44544: CALL_OW 72
44548: NOT
44549: PUSH
44550: LD_EXP 102
44554: PUSH
44555: LD_VAR 0 1
44559: ARRAY
44560: PPUSH
44561: LD_INT 30
44563: PUSH
44564: LD_INT 3
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PPUSH
44571: CALL_OW 72
44575: NOT
44576: AND
44577: IFFALSE 44649
// begin if eng = tmp then
44579: LD_VAR 0 6
44583: PUSH
44584: LD_VAR 0 4
44588: EQUAL
44589: IFFALSE 44593
// exit ;
44591: GO 47182
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
44593: LD_ADDR_EXP 144
44597: PUSH
44598: LD_EXP 144
44602: PPUSH
44603: LD_VAR 0 1
44607: PPUSH
44608: LD_INT 1
44610: PPUSH
44611: CALL_OW 1
44615: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
44616: LD_ADDR_VAR 0 2
44620: PUSH
44621: LD_INT 0
44623: PUSH
44624: LD_VAR 0 4
44628: PUSH
44629: LD_VAR 0 6
44633: DIFF
44634: PUSH
44635: LD_INT 0
44637: PUSH
44638: LD_INT 0
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: ST_TO_ADDR
// exit ;
44647: GO 47182
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44649: LD_EXP 129
44653: PUSH
44654: LD_EXP 128
44658: PUSH
44659: LD_VAR 0 1
44663: ARRAY
44664: ARRAY
44665: PUSH
44666: LD_EXP 102
44670: PUSH
44671: LD_VAR 0 1
44675: ARRAY
44676: PPUSH
44677: LD_INT 2
44679: PUSH
44680: LD_INT 30
44682: PUSH
44683: LD_INT 6
44685: PUSH
44686: EMPTY
44687: LIST
44688: LIST
44689: PUSH
44690: LD_INT 30
44692: PUSH
44693: LD_INT 7
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 30
44702: PUSH
44703: LD_INT 8
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: PPUSH
44716: CALL_OW 72
44720: AND
44721: PUSH
44722: LD_EXP 102
44726: PUSH
44727: LD_VAR 0 1
44731: ARRAY
44732: PPUSH
44733: LD_INT 30
44735: PUSH
44736: LD_INT 3
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PPUSH
44743: CALL_OW 72
44747: NOT
44748: AND
44749: IFFALSE 44963
// begin if sci >= 6 then
44751: LD_VAR 0 8
44755: PUSH
44756: LD_INT 6
44758: GREATEREQUAL
44759: IFFALSE 44763
// exit ;
44761: GO 47182
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44763: LD_ADDR_EXP 144
44767: PUSH
44768: LD_EXP 144
44772: PPUSH
44773: LD_VAR 0 1
44777: PPUSH
44778: LD_INT 2
44780: PPUSH
44781: CALL_OW 1
44785: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44786: LD_ADDR_VAR 0 9
44790: PUSH
44791: LD_VAR 0 4
44795: PUSH
44796: LD_VAR 0 8
44800: DIFF
44801: PPUSH
44802: LD_INT 4
44804: PPUSH
44805: CALL 105740 0 2
44809: ST_TO_ADDR
// p := [ ] ;
44810: LD_ADDR_VAR 0 11
44814: PUSH
44815: EMPTY
44816: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44817: LD_VAR 0 8
44821: PUSH
44822: LD_INT 6
44824: LESS
44825: PUSH
44826: LD_VAR 0 9
44830: PUSH
44831: LD_INT 6
44833: GREATER
44834: AND
44835: IFFALSE 44916
// begin for i = 1 to 6 - sci do
44837: LD_ADDR_VAR 0 3
44841: PUSH
44842: DOUBLE
44843: LD_INT 1
44845: DEC
44846: ST_TO_ADDR
44847: LD_INT 6
44849: PUSH
44850: LD_VAR 0 8
44854: MINUS
44855: PUSH
44856: FOR_TO
44857: IFFALSE 44912
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44859: LD_ADDR_VAR 0 11
44863: PUSH
44864: LD_VAR 0 11
44868: PPUSH
44869: LD_VAR 0 11
44873: PUSH
44874: LD_INT 1
44876: PLUS
44877: PPUSH
44878: LD_VAR 0 9
44882: PUSH
44883: LD_INT 1
44885: ARRAY
44886: PPUSH
44887: CALL_OW 2
44891: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44892: LD_ADDR_VAR 0 9
44896: PUSH
44897: LD_VAR 0 9
44901: PPUSH
44902: LD_INT 1
44904: PPUSH
44905: CALL_OW 3
44909: ST_TO_ADDR
// end ;
44910: GO 44856
44912: POP
44913: POP
// end else
44914: GO 44936
// if sort then
44916: LD_VAR 0 9
44920: IFFALSE 44936
// p := sort [ 1 ] ;
44922: LD_ADDR_VAR 0 11
44926: PUSH
44927: LD_VAR 0 9
44931: PUSH
44932: LD_INT 1
44934: ARRAY
44935: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44936: LD_ADDR_VAR 0 2
44940: PUSH
44941: LD_INT 0
44943: PUSH
44944: LD_INT 0
44946: PUSH
44947: LD_INT 0
44949: PUSH
44950: LD_VAR 0 11
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: ST_TO_ADDR
// exit ;
44961: GO 47182
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44963: LD_EXP 129
44967: PUSH
44968: LD_EXP 128
44972: PUSH
44973: LD_VAR 0 1
44977: ARRAY
44978: ARRAY
44979: PUSH
44980: LD_EXP 102
44984: PUSH
44985: LD_VAR 0 1
44989: ARRAY
44990: PPUSH
44991: LD_INT 2
44993: PUSH
44994: LD_INT 30
44996: PUSH
44997: LD_INT 6
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 30
45006: PUSH
45007: LD_INT 7
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 30
45016: PUSH
45017: LD_INT 8
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: PPUSH
45030: CALL_OW 72
45034: AND
45035: PUSH
45036: LD_EXP 102
45040: PUSH
45041: LD_VAR 0 1
45045: ARRAY
45046: PPUSH
45047: LD_INT 30
45049: PUSH
45050: LD_INT 3
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PPUSH
45057: CALL_OW 72
45061: AND
45062: IFFALSE 45796
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
45064: LD_ADDR_EXP 144
45068: PUSH
45069: LD_EXP 144
45073: PPUSH
45074: LD_VAR 0 1
45078: PPUSH
45079: LD_INT 3
45081: PPUSH
45082: CALL_OW 1
45086: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45087: LD_ADDR_VAR 0 2
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: LD_INT 0
45097: PUSH
45098: LD_INT 0
45100: PUSH
45101: LD_INT 0
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: ST_TO_ADDR
// if not eng then
45110: LD_VAR 0 6
45114: NOT
45115: IFFALSE 45178
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
45117: LD_ADDR_VAR 0 11
45121: PUSH
45122: LD_VAR 0 4
45126: PPUSH
45127: LD_INT 2
45129: PPUSH
45130: CALL 105740 0 2
45134: PUSH
45135: LD_INT 1
45137: ARRAY
45138: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
45139: LD_ADDR_VAR 0 2
45143: PUSH
45144: LD_VAR 0 2
45148: PPUSH
45149: LD_INT 2
45151: PPUSH
45152: LD_VAR 0 11
45156: PPUSH
45157: CALL_OW 1
45161: ST_TO_ADDR
// tmp := tmp diff p ;
45162: LD_ADDR_VAR 0 4
45166: PUSH
45167: LD_VAR 0 4
45171: PUSH
45172: LD_VAR 0 11
45176: DIFF
45177: ST_TO_ADDR
// end ; if tmp and sci < 6 then
45178: LD_VAR 0 4
45182: PUSH
45183: LD_VAR 0 8
45187: PUSH
45188: LD_INT 6
45190: LESS
45191: AND
45192: IFFALSE 45380
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
45194: LD_ADDR_VAR 0 9
45198: PUSH
45199: LD_VAR 0 4
45203: PUSH
45204: LD_VAR 0 8
45208: PUSH
45209: LD_VAR 0 7
45213: UNION
45214: DIFF
45215: PPUSH
45216: LD_INT 4
45218: PPUSH
45219: CALL 105740 0 2
45223: ST_TO_ADDR
// p := [ ] ;
45224: LD_ADDR_VAR 0 11
45228: PUSH
45229: EMPTY
45230: ST_TO_ADDR
// if sort then
45231: LD_VAR 0 9
45235: IFFALSE 45351
// for i = 1 to 6 - sci do
45237: LD_ADDR_VAR 0 3
45241: PUSH
45242: DOUBLE
45243: LD_INT 1
45245: DEC
45246: ST_TO_ADDR
45247: LD_INT 6
45249: PUSH
45250: LD_VAR 0 8
45254: MINUS
45255: PUSH
45256: FOR_TO
45257: IFFALSE 45349
// begin if i = sort then
45259: LD_VAR 0 3
45263: PUSH
45264: LD_VAR 0 9
45268: EQUAL
45269: IFFALSE 45273
// break ;
45271: GO 45349
// if GetClass ( i ) = 4 then
45273: LD_VAR 0 3
45277: PPUSH
45278: CALL_OW 257
45282: PUSH
45283: LD_INT 4
45285: EQUAL
45286: IFFALSE 45290
// continue ;
45288: GO 45256
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45290: LD_ADDR_VAR 0 11
45294: PUSH
45295: LD_VAR 0 11
45299: PPUSH
45300: LD_VAR 0 11
45304: PUSH
45305: LD_INT 1
45307: PLUS
45308: PPUSH
45309: LD_VAR 0 9
45313: PUSH
45314: LD_VAR 0 3
45318: ARRAY
45319: PPUSH
45320: CALL_OW 2
45324: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45325: LD_ADDR_VAR 0 4
45329: PUSH
45330: LD_VAR 0 4
45334: PUSH
45335: LD_VAR 0 9
45339: PUSH
45340: LD_VAR 0 3
45344: ARRAY
45345: DIFF
45346: ST_TO_ADDR
// end ;
45347: GO 45256
45349: POP
45350: POP
// if p then
45351: LD_VAR 0 11
45355: IFFALSE 45380
// result := Replace ( result , 4 , p ) ;
45357: LD_ADDR_VAR 0 2
45361: PUSH
45362: LD_VAR 0 2
45366: PPUSH
45367: LD_INT 4
45369: PPUSH
45370: LD_VAR 0 11
45374: PPUSH
45375: CALL_OW 1
45379: ST_TO_ADDR
// end ; if tmp and mech < 6 then
45380: LD_VAR 0 4
45384: PUSH
45385: LD_VAR 0 7
45389: PUSH
45390: LD_INT 6
45392: LESS
45393: AND
45394: IFFALSE 45582
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45396: LD_ADDR_VAR 0 9
45400: PUSH
45401: LD_VAR 0 4
45405: PUSH
45406: LD_VAR 0 8
45410: PUSH
45411: LD_VAR 0 7
45415: UNION
45416: DIFF
45417: PPUSH
45418: LD_INT 3
45420: PPUSH
45421: CALL 105740 0 2
45425: ST_TO_ADDR
// p := [ ] ;
45426: LD_ADDR_VAR 0 11
45430: PUSH
45431: EMPTY
45432: ST_TO_ADDR
// if sort then
45433: LD_VAR 0 9
45437: IFFALSE 45553
// for i = 1 to 6 - mech do
45439: LD_ADDR_VAR 0 3
45443: PUSH
45444: DOUBLE
45445: LD_INT 1
45447: DEC
45448: ST_TO_ADDR
45449: LD_INT 6
45451: PUSH
45452: LD_VAR 0 7
45456: MINUS
45457: PUSH
45458: FOR_TO
45459: IFFALSE 45551
// begin if i = sort then
45461: LD_VAR 0 3
45465: PUSH
45466: LD_VAR 0 9
45470: EQUAL
45471: IFFALSE 45475
// break ;
45473: GO 45551
// if GetClass ( i ) = 3 then
45475: LD_VAR 0 3
45479: PPUSH
45480: CALL_OW 257
45484: PUSH
45485: LD_INT 3
45487: EQUAL
45488: IFFALSE 45492
// continue ;
45490: GO 45458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45492: LD_ADDR_VAR 0 11
45496: PUSH
45497: LD_VAR 0 11
45501: PPUSH
45502: LD_VAR 0 11
45506: PUSH
45507: LD_INT 1
45509: PLUS
45510: PPUSH
45511: LD_VAR 0 9
45515: PUSH
45516: LD_VAR 0 3
45520: ARRAY
45521: PPUSH
45522: CALL_OW 2
45526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45527: LD_ADDR_VAR 0 4
45531: PUSH
45532: LD_VAR 0 4
45536: PUSH
45537: LD_VAR 0 9
45541: PUSH
45542: LD_VAR 0 3
45546: ARRAY
45547: DIFF
45548: ST_TO_ADDR
// end ;
45549: GO 45458
45551: POP
45552: POP
// if p then
45553: LD_VAR 0 11
45557: IFFALSE 45582
// result := Replace ( result , 3 , p ) ;
45559: LD_ADDR_VAR 0 2
45563: PUSH
45564: LD_VAR 0 2
45568: PPUSH
45569: LD_INT 3
45571: PPUSH
45572: LD_VAR 0 11
45576: PPUSH
45577: CALL_OW 1
45581: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
45582: LD_VAR 0 4
45586: PUSH
45587: LD_INT 6
45589: GREATER
45590: PUSH
45591: LD_VAR 0 6
45595: PUSH
45596: LD_INT 6
45598: LESS
45599: AND
45600: IFFALSE 45794
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45602: LD_ADDR_VAR 0 9
45606: PUSH
45607: LD_VAR 0 4
45611: PUSH
45612: LD_VAR 0 8
45616: PUSH
45617: LD_VAR 0 7
45621: UNION
45622: PUSH
45623: LD_VAR 0 6
45627: UNION
45628: DIFF
45629: PPUSH
45630: LD_INT 2
45632: PPUSH
45633: CALL 105740 0 2
45637: ST_TO_ADDR
// p := [ ] ;
45638: LD_ADDR_VAR 0 11
45642: PUSH
45643: EMPTY
45644: ST_TO_ADDR
// if sort then
45645: LD_VAR 0 9
45649: IFFALSE 45765
// for i = 1 to 6 - eng do
45651: LD_ADDR_VAR 0 3
45655: PUSH
45656: DOUBLE
45657: LD_INT 1
45659: DEC
45660: ST_TO_ADDR
45661: LD_INT 6
45663: PUSH
45664: LD_VAR 0 6
45668: MINUS
45669: PUSH
45670: FOR_TO
45671: IFFALSE 45763
// begin if i = sort then
45673: LD_VAR 0 3
45677: PUSH
45678: LD_VAR 0 9
45682: EQUAL
45683: IFFALSE 45687
// break ;
45685: GO 45763
// if GetClass ( i ) = 2 then
45687: LD_VAR 0 3
45691: PPUSH
45692: CALL_OW 257
45696: PUSH
45697: LD_INT 2
45699: EQUAL
45700: IFFALSE 45704
// continue ;
45702: GO 45670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45704: LD_ADDR_VAR 0 11
45708: PUSH
45709: LD_VAR 0 11
45713: PPUSH
45714: LD_VAR 0 11
45718: PUSH
45719: LD_INT 1
45721: PLUS
45722: PPUSH
45723: LD_VAR 0 9
45727: PUSH
45728: LD_VAR 0 3
45732: ARRAY
45733: PPUSH
45734: CALL_OW 2
45738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45739: LD_ADDR_VAR 0 4
45743: PUSH
45744: LD_VAR 0 4
45748: PUSH
45749: LD_VAR 0 9
45753: PUSH
45754: LD_VAR 0 3
45758: ARRAY
45759: DIFF
45760: ST_TO_ADDR
// end ;
45761: GO 45670
45763: POP
45764: POP
// if p then
45765: LD_VAR 0 11
45769: IFFALSE 45794
// result := Replace ( result , 2 , p ) ;
45771: LD_ADDR_VAR 0 2
45775: PUSH
45776: LD_VAR 0 2
45780: PPUSH
45781: LD_INT 2
45783: PPUSH
45784: LD_VAR 0 11
45788: PPUSH
45789: CALL_OW 1
45793: ST_TO_ADDR
// end ; exit ;
45794: GO 47182
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45796: LD_EXP 129
45800: PUSH
45801: LD_EXP 128
45805: PUSH
45806: LD_VAR 0 1
45810: ARRAY
45811: ARRAY
45812: NOT
45813: PUSH
45814: LD_EXP 102
45818: PUSH
45819: LD_VAR 0 1
45823: ARRAY
45824: PPUSH
45825: LD_INT 30
45827: PUSH
45828: LD_INT 3
45830: PUSH
45831: EMPTY
45832: LIST
45833: LIST
45834: PPUSH
45835: CALL_OW 72
45839: AND
45840: PUSH
45841: LD_EXP 107
45845: PUSH
45846: LD_VAR 0 1
45850: ARRAY
45851: AND
45852: IFFALSE 46460
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45854: LD_ADDR_EXP 144
45858: PUSH
45859: LD_EXP 144
45863: PPUSH
45864: LD_VAR 0 1
45868: PPUSH
45869: LD_INT 5
45871: PPUSH
45872: CALL_OW 1
45876: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45877: LD_ADDR_VAR 0 2
45881: PUSH
45882: LD_INT 0
45884: PUSH
45885: LD_INT 0
45887: PUSH
45888: LD_INT 0
45890: PUSH
45891: LD_INT 0
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: ST_TO_ADDR
// if sci > 1 then
45900: LD_VAR 0 8
45904: PUSH
45905: LD_INT 1
45907: GREATER
45908: IFFALSE 45936
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45910: LD_ADDR_VAR 0 4
45914: PUSH
45915: LD_VAR 0 4
45919: PUSH
45920: LD_VAR 0 8
45924: PUSH
45925: LD_VAR 0 8
45929: PUSH
45930: LD_INT 1
45932: ARRAY
45933: DIFF
45934: DIFF
45935: ST_TO_ADDR
// if tmp and not sci then
45936: LD_VAR 0 4
45940: PUSH
45941: LD_VAR 0 8
45945: NOT
45946: AND
45947: IFFALSE 46016
// begin sort := SortBySkill ( tmp , 4 ) ;
45949: LD_ADDR_VAR 0 9
45953: PUSH
45954: LD_VAR 0 4
45958: PPUSH
45959: LD_INT 4
45961: PPUSH
45962: CALL 105740 0 2
45966: ST_TO_ADDR
// if sort then
45967: LD_VAR 0 9
45971: IFFALSE 45987
// p := sort [ 1 ] ;
45973: LD_ADDR_VAR 0 11
45977: PUSH
45978: LD_VAR 0 9
45982: PUSH
45983: LD_INT 1
45985: ARRAY
45986: ST_TO_ADDR
// if p then
45987: LD_VAR 0 11
45991: IFFALSE 46016
// result := Replace ( result , 4 , p ) ;
45993: LD_ADDR_VAR 0 2
45997: PUSH
45998: LD_VAR 0 2
46002: PPUSH
46003: LD_INT 4
46005: PPUSH
46006: LD_VAR 0 11
46010: PPUSH
46011: CALL_OW 1
46015: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46016: LD_ADDR_VAR 0 4
46020: PUSH
46021: LD_VAR 0 4
46025: PUSH
46026: LD_VAR 0 7
46030: DIFF
46031: ST_TO_ADDR
// if tmp and mech < 6 then
46032: LD_VAR 0 4
46036: PUSH
46037: LD_VAR 0 7
46041: PUSH
46042: LD_INT 6
46044: LESS
46045: AND
46046: IFFALSE 46234
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46048: LD_ADDR_VAR 0 9
46052: PUSH
46053: LD_VAR 0 4
46057: PUSH
46058: LD_VAR 0 8
46062: PUSH
46063: LD_VAR 0 7
46067: UNION
46068: DIFF
46069: PPUSH
46070: LD_INT 3
46072: PPUSH
46073: CALL 105740 0 2
46077: ST_TO_ADDR
// p := [ ] ;
46078: LD_ADDR_VAR 0 11
46082: PUSH
46083: EMPTY
46084: ST_TO_ADDR
// if sort then
46085: LD_VAR 0 9
46089: IFFALSE 46205
// for i = 1 to 6 - mech do
46091: LD_ADDR_VAR 0 3
46095: PUSH
46096: DOUBLE
46097: LD_INT 1
46099: DEC
46100: ST_TO_ADDR
46101: LD_INT 6
46103: PUSH
46104: LD_VAR 0 7
46108: MINUS
46109: PUSH
46110: FOR_TO
46111: IFFALSE 46203
// begin if i = sort then
46113: LD_VAR 0 3
46117: PUSH
46118: LD_VAR 0 9
46122: EQUAL
46123: IFFALSE 46127
// break ;
46125: GO 46203
// if GetClass ( i ) = 3 then
46127: LD_VAR 0 3
46131: PPUSH
46132: CALL_OW 257
46136: PUSH
46137: LD_INT 3
46139: EQUAL
46140: IFFALSE 46144
// continue ;
46142: GO 46110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46144: LD_ADDR_VAR 0 11
46148: PUSH
46149: LD_VAR 0 11
46153: PPUSH
46154: LD_VAR 0 11
46158: PUSH
46159: LD_INT 1
46161: PLUS
46162: PPUSH
46163: LD_VAR 0 9
46167: PUSH
46168: LD_VAR 0 3
46172: ARRAY
46173: PPUSH
46174: CALL_OW 2
46178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: LD_VAR 0 4
46188: PUSH
46189: LD_VAR 0 9
46193: PUSH
46194: LD_VAR 0 3
46198: ARRAY
46199: DIFF
46200: ST_TO_ADDR
// end ;
46201: GO 46110
46203: POP
46204: POP
// if p then
46205: LD_VAR 0 11
46209: IFFALSE 46234
// result := Replace ( result , 3 , p ) ;
46211: LD_ADDR_VAR 0 2
46215: PUSH
46216: LD_VAR 0 2
46220: PPUSH
46221: LD_INT 3
46223: PPUSH
46224: LD_VAR 0 11
46228: PPUSH
46229: CALL_OW 1
46233: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46234: LD_ADDR_VAR 0 4
46238: PUSH
46239: LD_VAR 0 4
46243: PUSH
46244: LD_VAR 0 6
46248: DIFF
46249: ST_TO_ADDR
// if tmp and eng < 6 then
46250: LD_VAR 0 4
46254: PUSH
46255: LD_VAR 0 6
46259: PUSH
46260: LD_INT 6
46262: LESS
46263: AND
46264: IFFALSE 46458
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46266: LD_ADDR_VAR 0 9
46270: PUSH
46271: LD_VAR 0 4
46275: PUSH
46276: LD_VAR 0 8
46280: PUSH
46281: LD_VAR 0 7
46285: UNION
46286: PUSH
46287: LD_VAR 0 6
46291: UNION
46292: DIFF
46293: PPUSH
46294: LD_INT 2
46296: PPUSH
46297: CALL 105740 0 2
46301: ST_TO_ADDR
// p := [ ] ;
46302: LD_ADDR_VAR 0 11
46306: PUSH
46307: EMPTY
46308: ST_TO_ADDR
// if sort then
46309: LD_VAR 0 9
46313: IFFALSE 46429
// for i = 1 to 6 - eng do
46315: LD_ADDR_VAR 0 3
46319: PUSH
46320: DOUBLE
46321: LD_INT 1
46323: DEC
46324: ST_TO_ADDR
46325: LD_INT 6
46327: PUSH
46328: LD_VAR 0 6
46332: MINUS
46333: PUSH
46334: FOR_TO
46335: IFFALSE 46427
// begin if i = sort then
46337: LD_VAR 0 3
46341: PUSH
46342: LD_VAR 0 9
46346: EQUAL
46347: IFFALSE 46351
// break ;
46349: GO 46427
// if GetClass ( i ) = 2 then
46351: LD_VAR 0 3
46355: PPUSH
46356: CALL_OW 257
46360: PUSH
46361: LD_INT 2
46363: EQUAL
46364: IFFALSE 46368
// continue ;
46366: GO 46334
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46368: LD_ADDR_VAR 0 11
46372: PUSH
46373: LD_VAR 0 11
46377: PPUSH
46378: LD_VAR 0 11
46382: PUSH
46383: LD_INT 1
46385: PLUS
46386: PPUSH
46387: LD_VAR 0 9
46391: PUSH
46392: LD_VAR 0 3
46396: ARRAY
46397: PPUSH
46398: CALL_OW 2
46402: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46403: LD_ADDR_VAR 0 4
46407: PUSH
46408: LD_VAR 0 4
46412: PUSH
46413: LD_VAR 0 9
46417: PUSH
46418: LD_VAR 0 3
46422: ARRAY
46423: DIFF
46424: ST_TO_ADDR
// end ;
46425: GO 46334
46427: POP
46428: POP
// if p then
46429: LD_VAR 0 11
46433: IFFALSE 46458
// result := Replace ( result , 2 , p ) ;
46435: LD_ADDR_VAR 0 2
46439: PUSH
46440: LD_VAR 0 2
46444: PPUSH
46445: LD_INT 2
46447: PPUSH
46448: LD_VAR 0 11
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// end ; exit ;
46458: GO 47182
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
46460: LD_EXP 129
46464: PUSH
46465: LD_EXP 128
46469: PUSH
46470: LD_VAR 0 1
46474: ARRAY
46475: ARRAY
46476: NOT
46477: PUSH
46478: LD_EXP 102
46482: PUSH
46483: LD_VAR 0 1
46487: ARRAY
46488: PPUSH
46489: LD_INT 30
46491: PUSH
46492: LD_INT 3
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PPUSH
46499: CALL_OW 72
46503: AND
46504: PUSH
46505: LD_EXP 107
46509: PUSH
46510: LD_VAR 0 1
46514: ARRAY
46515: NOT
46516: AND
46517: IFFALSE 47182
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
46519: LD_ADDR_EXP 144
46523: PUSH
46524: LD_EXP 144
46528: PPUSH
46529: LD_VAR 0 1
46533: PPUSH
46534: LD_INT 6
46536: PPUSH
46537: CALL_OW 1
46541: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46542: LD_ADDR_VAR 0 2
46546: PUSH
46547: LD_INT 0
46549: PUSH
46550: LD_INT 0
46552: PUSH
46553: LD_INT 0
46555: PUSH
46556: LD_INT 0
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: ST_TO_ADDR
// if sci >= 1 then
46565: LD_VAR 0 8
46569: PUSH
46570: LD_INT 1
46572: GREATEREQUAL
46573: IFFALSE 46595
// tmp := tmp diff sci [ 1 ] ;
46575: LD_ADDR_VAR 0 4
46579: PUSH
46580: LD_VAR 0 4
46584: PUSH
46585: LD_VAR 0 8
46589: PUSH
46590: LD_INT 1
46592: ARRAY
46593: DIFF
46594: ST_TO_ADDR
// if tmp and not sci then
46595: LD_VAR 0 4
46599: PUSH
46600: LD_VAR 0 8
46604: NOT
46605: AND
46606: IFFALSE 46675
// begin sort := SortBySkill ( tmp , 4 ) ;
46608: LD_ADDR_VAR 0 9
46612: PUSH
46613: LD_VAR 0 4
46617: PPUSH
46618: LD_INT 4
46620: PPUSH
46621: CALL 105740 0 2
46625: ST_TO_ADDR
// if sort then
46626: LD_VAR 0 9
46630: IFFALSE 46646
// p := sort [ 1 ] ;
46632: LD_ADDR_VAR 0 11
46636: PUSH
46637: LD_VAR 0 9
46641: PUSH
46642: LD_INT 1
46644: ARRAY
46645: ST_TO_ADDR
// if p then
46646: LD_VAR 0 11
46650: IFFALSE 46675
// result := Replace ( result , 4 , p ) ;
46652: LD_ADDR_VAR 0 2
46656: PUSH
46657: LD_VAR 0 2
46661: PPUSH
46662: LD_INT 4
46664: PPUSH
46665: LD_VAR 0 11
46669: PPUSH
46670: CALL_OW 1
46674: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46675: LD_ADDR_VAR 0 4
46679: PUSH
46680: LD_VAR 0 4
46684: PUSH
46685: LD_VAR 0 7
46689: DIFF
46690: ST_TO_ADDR
// if tmp and mech < 6 then
46691: LD_VAR 0 4
46695: PUSH
46696: LD_VAR 0 7
46700: PUSH
46701: LD_INT 6
46703: LESS
46704: AND
46705: IFFALSE 46887
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46707: LD_ADDR_VAR 0 9
46711: PUSH
46712: LD_VAR 0 4
46716: PUSH
46717: LD_VAR 0 7
46721: DIFF
46722: PPUSH
46723: LD_INT 3
46725: PPUSH
46726: CALL 105740 0 2
46730: ST_TO_ADDR
// p := [ ] ;
46731: LD_ADDR_VAR 0 11
46735: PUSH
46736: EMPTY
46737: ST_TO_ADDR
// if sort then
46738: LD_VAR 0 9
46742: IFFALSE 46858
// for i = 1 to 6 - mech do
46744: LD_ADDR_VAR 0 3
46748: PUSH
46749: DOUBLE
46750: LD_INT 1
46752: DEC
46753: ST_TO_ADDR
46754: LD_INT 6
46756: PUSH
46757: LD_VAR 0 7
46761: MINUS
46762: PUSH
46763: FOR_TO
46764: IFFALSE 46856
// begin if i = sort then
46766: LD_VAR 0 3
46770: PUSH
46771: LD_VAR 0 9
46775: EQUAL
46776: IFFALSE 46780
// break ;
46778: GO 46856
// if GetClass ( i ) = 3 then
46780: LD_VAR 0 3
46784: PPUSH
46785: CALL_OW 257
46789: PUSH
46790: LD_INT 3
46792: EQUAL
46793: IFFALSE 46797
// continue ;
46795: GO 46763
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46797: LD_ADDR_VAR 0 11
46801: PUSH
46802: LD_VAR 0 11
46806: PPUSH
46807: LD_VAR 0 11
46811: PUSH
46812: LD_INT 1
46814: PLUS
46815: PPUSH
46816: LD_VAR 0 9
46820: PUSH
46821: LD_VAR 0 3
46825: ARRAY
46826: PPUSH
46827: CALL_OW 2
46831: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46832: LD_ADDR_VAR 0 4
46836: PUSH
46837: LD_VAR 0 4
46841: PUSH
46842: LD_VAR 0 9
46846: PUSH
46847: LD_VAR 0 3
46851: ARRAY
46852: DIFF
46853: ST_TO_ADDR
// end ;
46854: GO 46763
46856: POP
46857: POP
// if p then
46858: LD_VAR 0 11
46862: IFFALSE 46887
// result := Replace ( result , 3 , p ) ;
46864: LD_ADDR_VAR 0 2
46868: PUSH
46869: LD_VAR 0 2
46873: PPUSH
46874: LD_INT 3
46876: PPUSH
46877: LD_VAR 0 11
46881: PPUSH
46882: CALL_OW 1
46886: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46887: LD_ADDR_VAR 0 4
46891: PUSH
46892: LD_VAR 0 4
46896: PUSH
46897: LD_VAR 0 6
46901: DIFF
46902: ST_TO_ADDR
// if tmp and eng < 4 then
46903: LD_VAR 0 4
46907: PUSH
46908: LD_VAR 0 6
46912: PUSH
46913: LD_INT 4
46915: LESS
46916: AND
46917: IFFALSE 47107
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46919: LD_ADDR_VAR 0 9
46923: PUSH
46924: LD_VAR 0 4
46928: PUSH
46929: LD_VAR 0 7
46933: PUSH
46934: LD_VAR 0 6
46938: UNION
46939: DIFF
46940: PPUSH
46941: LD_INT 2
46943: PPUSH
46944: CALL 105740 0 2
46948: ST_TO_ADDR
// p := [ ] ;
46949: LD_ADDR_VAR 0 11
46953: PUSH
46954: EMPTY
46955: ST_TO_ADDR
// if sort then
46956: LD_VAR 0 9
46960: IFFALSE 47076
// for i = 1 to 4 - eng do
46962: LD_ADDR_VAR 0 3
46966: PUSH
46967: DOUBLE
46968: LD_INT 1
46970: DEC
46971: ST_TO_ADDR
46972: LD_INT 4
46974: PUSH
46975: LD_VAR 0 6
46979: MINUS
46980: PUSH
46981: FOR_TO
46982: IFFALSE 47074
// begin if i = sort then
46984: LD_VAR 0 3
46988: PUSH
46989: LD_VAR 0 9
46993: EQUAL
46994: IFFALSE 46998
// break ;
46996: GO 47074
// if GetClass ( i ) = 2 then
46998: LD_VAR 0 3
47002: PPUSH
47003: CALL_OW 257
47007: PUSH
47008: LD_INT 2
47010: EQUAL
47011: IFFALSE 47015
// continue ;
47013: GO 46981
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47015: LD_ADDR_VAR 0 11
47019: PUSH
47020: LD_VAR 0 11
47024: PPUSH
47025: LD_VAR 0 11
47029: PUSH
47030: LD_INT 1
47032: PLUS
47033: PPUSH
47034: LD_VAR 0 9
47038: PUSH
47039: LD_VAR 0 3
47043: ARRAY
47044: PPUSH
47045: CALL_OW 2
47049: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47050: LD_ADDR_VAR 0 4
47054: PUSH
47055: LD_VAR 0 4
47059: PUSH
47060: LD_VAR 0 9
47064: PUSH
47065: LD_VAR 0 3
47069: ARRAY
47070: DIFF
47071: ST_TO_ADDR
// end ;
47072: GO 46981
47074: POP
47075: POP
// if p then
47076: LD_VAR 0 11
47080: IFFALSE 47105
// result := Replace ( result , 2 , p ) ;
47082: LD_ADDR_VAR 0 2
47086: PUSH
47087: LD_VAR 0 2
47091: PPUSH
47092: LD_INT 2
47094: PPUSH
47095: LD_VAR 0 11
47099: PPUSH
47100: CALL_OW 1
47104: ST_TO_ADDR
// end else
47105: GO 47151
// for i = eng downto 5 do
47107: LD_ADDR_VAR 0 3
47111: PUSH
47112: DOUBLE
47113: LD_VAR 0 6
47117: INC
47118: ST_TO_ADDR
47119: LD_INT 5
47121: PUSH
47122: FOR_DOWNTO
47123: IFFALSE 47149
// tmp := tmp union eng [ i ] ;
47125: LD_ADDR_VAR 0 4
47129: PUSH
47130: LD_VAR 0 4
47134: PUSH
47135: LD_VAR 0 6
47139: PUSH
47140: LD_VAR 0 3
47144: ARRAY
47145: UNION
47146: ST_TO_ADDR
47147: GO 47122
47149: POP
47150: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
47151: LD_ADDR_VAR 0 2
47155: PUSH
47156: LD_VAR 0 2
47160: PPUSH
47161: LD_INT 1
47163: PPUSH
47164: LD_VAR 0 4
47168: PUSH
47169: LD_VAR 0 5
47173: DIFF
47174: PPUSH
47175: CALL_OW 1
47179: ST_TO_ADDR
// exit ;
47180: GO 47182
// end ; end ;
47182: LD_VAR 0 2
47186: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
47187: LD_INT 0
47189: PPUSH
47190: PPUSH
47191: PPUSH
// if not mc_bases then
47192: LD_EXP 102
47196: NOT
47197: IFFALSE 47201
// exit ;
47199: GO 47343
// for i = 1 to mc_bases do
47201: LD_ADDR_VAR 0 2
47205: PUSH
47206: DOUBLE
47207: LD_INT 1
47209: DEC
47210: ST_TO_ADDR
47211: LD_EXP 102
47215: PUSH
47216: FOR_TO
47217: IFFALSE 47334
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47219: LD_ADDR_VAR 0 3
47223: PUSH
47224: LD_EXP 102
47228: PUSH
47229: LD_VAR 0 2
47233: ARRAY
47234: PPUSH
47235: LD_INT 21
47237: PUSH
47238: LD_INT 3
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 3
47247: PUSH
47248: LD_INT 2
47250: PUSH
47251: LD_INT 30
47253: PUSH
47254: LD_INT 29
47256: PUSH
47257: EMPTY
47258: LIST
47259: LIST
47260: PUSH
47261: LD_INT 30
47263: PUSH
47264: LD_INT 30
47266: PUSH
47267: EMPTY
47268: LIST
47269: LIST
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: LIST
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 3
47282: PUSH
47283: LD_INT 24
47285: PUSH
47286: LD_INT 1000
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: PUSH
47293: EMPTY
47294: LIST
47295: LIST
47296: PUSH
47297: EMPTY
47298: LIST
47299: LIST
47300: LIST
47301: PPUSH
47302: CALL_OW 72
47306: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
47307: LD_ADDR_EXP 103
47311: PUSH
47312: LD_EXP 103
47316: PPUSH
47317: LD_VAR 0 2
47321: PPUSH
47322: LD_VAR 0 3
47326: PPUSH
47327: CALL_OW 1
47331: ST_TO_ADDR
// end ;
47332: GO 47216
47334: POP
47335: POP
// RaiseSailEvent ( 101 ) ;
47336: LD_INT 101
47338: PPUSH
47339: CALL_OW 427
// end ;
47343: LD_VAR 0 1
47347: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
47348: LD_INT 0
47350: PPUSH
47351: PPUSH
47352: PPUSH
47353: PPUSH
47354: PPUSH
47355: PPUSH
47356: PPUSH
// if not mc_bases then
47357: LD_EXP 102
47361: NOT
47362: IFFALSE 47366
// exit ;
47364: GO 47928
// for i = 1 to mc_bases do
47366: LD_ADDR_VAR 0 2
47370: PUSH
47371: DOUBLE
47372: LD_INT 1
47374: DEC
47375: ST_TO_ADDR
47376: LD_EXP 102
47380: PUSH
47381: FOR_TO
47382: IFFALSE 47919
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
47384: LD_ADDR_VAR 0 5
47388: PUSH
47389: LD_EXP 102
47393: PUSH
47394: LD_VAR 0 2
47398: ARRAY
47399: PUSH
47400: LD_EXP 131
47404: PUSH
47405: LD_VAR 0 2
47409: ARRAY
47410: UNION
47411: PPUSH
47412: LD_INT 21
47414: PUSH
47415: LD_INT 1
47417: PUSH
47418: EMPTY
47419: LIST
47420: LIST
47421: PUSH
47422: LD_INT 1
47424: PUSH
47425: LD_INT 3
47427: PUSH
47428: LD_INT 54
47430: PUSH
47431: EMPTY
47432: LIST
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: PUSH
47438: LD_INT 3
47440: PUSH
47441: LD_INT 24
47443: PUSH
47444: LD_INT 1000
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: EMPTY
47456: LIST
47457: LIST
47458: LIST
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PPUSH
47464: CALL_OW 72
47468: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
47469: LD_ADDR_VAR 0 6
47473: PUSH
47474: LD_EXP 102
47478: PUSH
47479: LD_VAR 0 2
47483: ARRAY
47484: PPUSH
47485: LD_INT 21
47487: PUSH
47488: LD_INT 1
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PUSH
47495: LD_INT 1
47497: PUSH
47498: LD_INT 3
47500: PUSH
47501: LD_INT 54
47503: PUSH
47504: EMPTY
47505: LIST
47506: PUSH
47507: EMPTY
47508: LIST
47509: LIST
47510: PUSH
47511: LD_INT 3
47513: PUSH
47514: LD_INT 24
47516: PUSH
47517: LD_INT 250
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: PUSH
47528: EMPTY
47529: LIST
47530: LIST
47531: LIST
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PPUSH
47537: CALL_OW 72
47541: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
47542: LD_ADDR_VAR 0 7
47546: PUSH
47547: LD_VAR 0 5
47551: PUSH
47552: LD_VAR 0 6
47556: DIFF
47557: ST_TO_ADDR
// if not need_heal_1 then
47558: LD_VAR 0 6
47562: NOT
47563: IFFALSE 47596
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
47565: LD_ADDR_EXP 105
47569: PUSH
47570: LD_EXP 105
47574: PPUSH
47575: LD_VAR 0 2
47579: PUSH
47580: LD_INT 1
47582: PUSH
47583: EMPTY
47584: LIST
47585: LIST
47586: PPUSH
47587: EMPTY
47588: PPUSH
47589: CALL 74507 0 3
47593: ST_TO_ADDR
47594: GO 47666
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
47596: LD_ADDR_EXP 105
47600: PUSH
47601: LD_EXP 105
47605: PPUSH
47606: LD_VAR 0 2
47610: PUSH
47611: LD_INT 1
47613: PUSH
47614: EMPTY
47615: LIST
47616: LIST
47617: PPUSH
47618: LD_EXP 105
47622: PUSH
47623: LD_VAR 0 2
47627: ARRAY
47628: PUSH
47629: LD_INT 1
47631: ARRAY
47632: PPUSH
47633: LD_INT 3
47635: PUSH
47636: LD_INT 24
47638: PUSH
47639: LD_INT 1000
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PPUSH
47650: CALL_OW 72
47654: PUSH
47655: LD_VAR 0 6
47659: UNION
47660: PPUSH
47661: CALL 74507 0 3
47665: ST_TO_ADDR
// if not need_heal_2 then
47666: LD_VAR 0 7
47670: NOT
47671: IFFALSE 47704
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47673: LD_ADDR_EXP 105
47677: PUSH
47678: LD_EXP 105
47682: PPUSH
47683: LD_VAR 0 2
47687: PUSH
47688: LD_INT 2
47690: PUSH
47691: EMPTY
47692: LIST
47693: LIST
47694: PPUSH
47695: EMPTY
47696: PPUSH
47697: CALL 74507 0 3
47701: ST_TO_ADDR
47702: GO 47736
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47704: LD_ADDR_EXP 105
47708: PUSH
47709: LD_EXP 105
47713: PPUSH
47714: LD_VAR 0 2
47718: PUSH
47719: LD_INT 2
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PPUSH
47726: LD_VAR 0 7
47730: PPUSH
47731: CALL 74507 0 3
47735: ST_TO_ADDR
// if need_heal_2 then
47736: LD_VAR 0 7
47740: IFFALSE 47901
// for j in need_heal_2 do
47742: LD_ADDR_VAR 0 3
47746: PUSH
47747: LD_VAR 0 7
47751: PUSH
47752: FOR_IN
47753: IFFALSE 47899
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47755: LD_ADDR_VAR 0 5
47759: PUSH
47760: LD_EXP 102
47764: PUSH
47765: LD_VAR 0 2
47769: ARRAY
47770: PPUSH
47771: LD_INT 2
47773: PUSH
47774: LD_INT 30
47776: PUSH
47777: LD_INT 6
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: LD_INT 30
47786: PUSH
47787: LD_INT 7
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PUSH
47794: LD_INT 30
47796: PUSH
47797: LD_INT 8
47799: PUSH
47800: EMPTY
47801: LIST
47802: LIST
47803: PUSH
47804: LD_INT 30
47806: PUSH
47807: LD_INT 0
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: PUSH
47814: LD_INT 30
47816: PUSH
47817: LD_INT 1
47819: PUSH
47820: EMPTY
47821: LIST
47822: LIST
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: PPUSH
47832: CALL_OW 72
47836: ST_TO_ADDR
// if tmp then
47837: LD_VAR 0 5
47841: IFFALSE 47897
// begin k := NearestUnitToUnit ( tmp , j ) ;
47843: LD_ADDR_VAR 0 4
47847: PUSH
47848: LD_VAR 0 5
47852: PPUSH
47853: LD_VAR 0 3
47857: PPUSH
47858: CALL_OW 74
47862: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47863: LD_VAR 0 3
47867: PPUSH
47868: LD_VAR 0 4
47872: PPUSH
47873: CALL_OW 296
47877: PUSH
47878: LD_INT 5
47880: GREATER
47881: IFFALSE 47897
// ComMoveToNearbyEntrance ( j , k ) ;
47883: LD_VAR 0 3
47887: PPUSH
47888: LD_VAR 0 4
47892: PPUSH
47893: CALL 108113 0 2
// end ; end ;
47897: GO 47752
47899: POP
47900: POP
// if not need_heal_1 and not need_heal_2 then
47901: LD_VAR 0 6
47905: NOT
47906: PUSH
47907: LD_VAR 0 7
47911: NOT
47912: AND
47913: IFFALSE 47917
// continue ;
47915: GO 47381
// end ;
47917: GO 47381
47919: POP
47920: POP
// RaiseSailEvent ( 102 ) ;
47921: LD_INT 102
47923: PPUSH
47924: CALL_OW 427
// end ;
47928: LD_VAR 0 1
47932: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47933: LD_INT 0
47935: PPUSH
47936: PPUSH
47937: PPUSH
47938: PPUSH
47939: PPUSH
47940: PPUSH
47941: PPUSH
47942: PPUSH
// if not mc_bases then
47943: LD_EXP 102
47947: NOT
47948: IFFALSE 47952
// exit ;
47950: GO 48863
// for i = 1 to mc_bases do
47952: LD_ADDR_VAR 0 2
47956: PUSH
47957: DOUBLE
47958: LD_INT 1
47960: DEC
47961: ST_TO_ADDR
47962: LD_EXP 102
47966: PUSH
47967: FOR_TO
47968: IFFALSE 48861
// begin if not mc_building_need_repair [ i ] then
47970: LD_EXP 103
47974: PUSH
47975: LD_VAR 0 2
47979: ARRAY
47980: NOT
47981: IFFALSE 48166
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47983: LD_ADDR_VAR 0 6
47987: PUSH
47988: LD_EXP 121
47992: PUSH
47993: LD_VAR 0 2
47997: ARRAY
47998: PPUSH
47999: LD_INT 3
48001: PUSH
48002: LD_INT 24
48004: PUSH
48005: LD_INT 1000
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: PUSH
48016: LD_INT 2
48018: PUSH
48019: LD_INT 34
48021: PUSH
48022: LD_INT 13
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: PUSH
48029: LD_INT 34
48031: PUSH
48032: LD_INT 52
48034: PUSH
48035: EMPTY
48036: LIST
48037: LIST
48038: PUSH
48039: LD_INT 34
48041: PUSH
48042: LD_INT 88
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: PUSH
48055: EMPTY
48056: LIST
48057: LIST
48058: PPUSH
48059: CALL_OW 72
48063: ST_TO_ADDR
// if cranes then
48064: LD_VAR 0 6
48068: IFFALSE 48130
// for j in cranes do
48070: LD_ADDR_VAR 0 3
48074: PUSH
48075: LD_VAR 0 6
48079: PUSH
48080: FOR_IN
48081: IFFALSE 48128
// if not IsInArea ( j , mc_parking [ i ] ) then
48083: LD_VAR 0 3
48087: PPUSH
48088: LD_EXP 126
48092: PUSH
48093: LD_VAR 0 2
48097: ARRAY
48098: PPUSH
48099: CALL_OW 308
48103: NOT
48104: IFFALSE 48126
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48106: LD_VAR 0 3
48110: PPUSH
48111: LD_EXP 126
48115: PUSH
48116: LD_VAR 0 2
48120: ARRAY
48121: PPUSH
48122: CALL_OW 113
48126: GO 48080
48128: POP
48129: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48130: LD_ADDR_EXP 104
48134: PUSH
48135: LD_EXP 104
48139: PPUSH
48140: LD_VAR 0 2
48144: PPUSH
48145: EMPTY
48146: PPUSH
48147: CALL_OW 1
48151: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
48152: LD_VAR 0 2
48156: PPUSH
48157: LD_INT 101
48159: PPUSH
48160: CALL 43006 0 2
// continue ;
48164: GO 47967
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
48166: LD_ADDR_EXP 108
48170: PUSH
48171: LD_EXP 108
48175: PPUSH
48176: LD_VAR 0 2
48180: PPUSH
48181: EMPTY
48182: PPUSH
48183: CALL_OW 1
48187: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48188: LD_VAR 0 2
48192: PPUSH
48193: LD_INT 103
48195: PPUSH
48196: CALL 43006 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
48200: LD_ADDR_VAR 0 5
48204: PUSH
48205: LD_EXP 102
48209: PUSH
48210: LD_VAR 0 2
48214: ARRAY
48215: PUSH
48216: LD_EXP 131
48220: PUSH
48221: LD_VAR 0 2
48225: ARRAY
48226: UNION
48227: PPUSH
48228: LD_INT 2
48230: PUSH
48231: LD_INT 25
48233: PUSH
48234: LD_INT 2
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: PUSH
48241: LD_INT 25
48243: PUSH
48244: LD_INT 16
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: LIST
48255: PUSH
48256: EMPTY
48257: LIST
48258: PPUSH
48259: CALL_OW 72
48263: ST_TO_ADDR
// if mc_need_heal [ i ] then
48264: LD_EXP 105
48268: PUSH
48269: LD_VAR 0 2
48273: ARRAY
48274: IFFALSE 48318
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
48276: LD_ADDR_VAR 0 5
48280: PUSH
48281: LD_VAR 0 5
48285: PUSH
48286: LD_EXP 105
48290: PUSH
48291: LD_VAR 0 2
48295: ARRAY
48296: PUSH
48297: LD_INT 1
48299: ARRAY
48300: PUSH
48301: LD_EXP 105
48305: PUSH
48306: LD_VAR 0 2
48310: ARRAY
48311: PUSH
48312: LD_INT 2
48314: ARRAY
48315: UNION
48316: DIFF
48317: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
48318: LD_ADDR_VAR 0 6
48322: PUSH
48323: LD_EXP 121
48327: PUSH
48328: LD_VAR 0 2
48332: ARRAY
48333: PPUSH
48334: LD_INT 2
48336: PUSH
48337: LD_INT 34
48339: PUSH
48340: LD_INT 13
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: LD_INT 34
48349: PUSH
48350: LD_INT 52
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: LD_INT 34
48359: PUSH
48360: LD_INT 88
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: PPUSH
48373: CALL_OW 72
48377: ST_TO_ADDR
// if cranes then
48378: LD_VAR 0 6
48382: IFFALSE 48550
// begin for j in cranes do
48384: LD_ADDR_VAR 0 3
48388: PUSH
48389: LD_VAR 0 6
48393: PUSH
48394: FOR_IN
48395: IFFALSE 48548
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
48397: LD_VAR 0 3
48401: PPUSH
48402: CALL_OW 256
48406: PUSH
48407: LD_INT 1000
48409: EQUAL
48410: PUSH
48411: LD_VAR 0 3
48415: PPUSH
48416: CALL_OW 314
48420: NOT
48421: AND
48422: IFFALSE 48488
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
48424: LD_ADDR_VAR 0 8
48428: PUSH
48429: LD_EXP 103
48433: PUSH
48434: LD_VAR 0 2
48438: ARRAY
48439: PPUSH
48440: LD_VAR 0 3
48444: PPUSH
48445: CALL_OW 74
48449: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
48450: LD_VAR 0 8
48454: PPUSH
48455: LD_INT 16
48457: PPUSH
48458: CALL 77472 0 2
48462: PUSH
48463: LD_INT 4
48465: ARRAY
48466: PUSH
48467: LD_INT 10
48469: LESS
48470: IFFALSE 48486
// ComRepairBuilding ( j , to_repair ) ;
48472: LD_VAR 0 3
48476: PPUSH
48477: LD_VAR 0 8
48481: PPUSH
48482: CALL_OW 130
// end else
48486: GO 48546
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
48488: LD_VAR 0 3
48492: PPUSH
48493: CALL_OW 256
48497: PUSH
48498: LD_INT 500
48500: LESS
48501: PUSH
48502: LD_VAR 0 3
48506: PPUSH
48507: LD_EXP 126
48511: PUSH
48512: LD_VAR 0 2
48516: ARRAY
48517: PPUSH
48518: CALL_OW 308
48522: NOT
48523: AND
48524: IFFALSE 48546
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48526: LD_VAR 0 3
48530: PPUSH
48531: LD_EXP 126
48535: PUSH
48536: LD_VAR 0 2
48540: ARRAY
48541: PPUSH
48542: CALL_OW 113
// end ;
48546: GO 48394
48548: POP
48549: POP
// end ; if tmp > 3 then
48550: LD_VAR 0 5
48554: PUSH
48555: LD_INT 3
48557: GREATER
48558: IFFALSE 48578
// tmp := ShrinkArray ( tmp , 4 ) ;
48560: LD_ADDR_VAR 0 5
48564: PUSH
48565: LD_VAR 0 5
48569: PPUSH
48570: LD_INT 4
48572: PPUSH
48573: CALL 107551 0 2
48577: ST_TO_ADDR
// if not tmp then
48578: LD_VAR 0 5
48582: NOT
48583: IFFALSE 48587
// continue ;
48585: GO 47967
// for j in tmp do
48587: LD_ADDR_VAR 0 3
48591: PUSH
48592: LD_VAR 0 5
48596: PUSH
48597: FOR_IN
48598: IFFALSE 48857
// begin if IsInUnit ( j ) then
48600: LD_VAR 0 3
48604: PPUSH
48605: CALL_OW 310
48609: IFFALSE 48620
// ComExitBuilding ( j ) ;
48611: LD_VAR 0 3
48615: PPUSH
48616: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
48620: LD_VAR 0 3
48624: PUSH
48625: LD_EXP 104
48629: PUSH
48630: LD_VAR 0 2
48634: ARRAY
48635: IN
48636: NOT
48637: IFFALSE 48695
// begin SetTag ( j , 101 ) ;
48639: LD_VAR 0 3
48643: PPUSH
48644: LD_INT 101
48646: PPUSH
48647: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48651: LD_ADDR_EXP 104
48655: PUSH
48656: LD_EXP 104
48660: PPUSH
48661: LD_VAR 0 2
48665: PUSH
48666: LD_EXP 104
48670: PUSH
48671: LD_VAR 0 2
48675: ARRAY
48676: PUSH
48677: LD_INT 1
48679: PLUS
48680: PUSH
48681: EMPTY
48682: LIST
48683: LIST
48684: PPUSH
48685: LD_VAR 0 3
48689: PPUSH
48690: CALL 74507 0 3
48694: ST_TO_ADDR
// end ; wait ( 1 ) ;
48695: LD_INT 1
48697: PPUSH
48698: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48702: LD_ADDR_VAR 0 7
48706: PUSH
48707: LD_EXP 103
48711: PUSH
48712: LD_VAR 0 2
48716: ARRAY
48717: ST_TO_ADDR
// if mc_scan [ i ] then
48718: LD_EXP 125
48722: PUSH
48723: LD_VAR 0 2
48727: ARRAY
48728: IFFALSE 48790
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48730: LD_ADDR_VAR 0 7
48734: PUSH
48735: LD_EXP 103
48739: PUSH
48740: LD_VAR 0 2
48744: ARRAY
48745: PPUSH
48746: LD_INT 3
48748: PUSH
48749: LD_INT 30
48751: PUSH
48752: LD_INT 32
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PUSH
48759: LD_INT 30
48761: PUSH
48762: LD_INT 33
48764: PUSH
48765: EMPTY
48766: LIST
48767: LIST
48768: PUSH
48769: LD_INT 30
48771: PUSH
48772: LD_INT 31
48774: PUSH
48775: EMPTY
48776: LIST
48777: LIST
48778: PUSH
48779: EMPTY
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: PPUSH
48785: CALL_OW 72
48789: ST_TO_ADDR
// if not to_repair_tmp then
48790: LD_VAR 0 7
48794: NOT
48795: IFFALSE 48799
// continue ;
48797: GO 48597
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48799: LD_ADDR_VAR 0 8
48803: PUSH
48804: LD_VAR 0 7
48808: PPUSH
48809: LD_VAR 0 3
48813: PPUSH
48814: CALL_OW 74
48818: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48819: LD_VAR 0 8
48823: PPUSH
48824: LD_INT 16
48826: PPUSH
48827: CALL 77472 0 2
48831: PUSH
48832: LD_INT 4
48834: ARRAY
48835: PUSH
48836: LD_INT 14
48838: LESS
48839: IFFALSE 48855
// ComRepairBuilding ( j , to_repair ) ;
48841: LD_VAR 0 3
48845: PPUSH
48846: LD_VAR 0 8
48850: PPUSH
48851: CALL_OW 130
// end ;
48855: GO 48597
48857: POP
48858: POP
// end ;
48859: GO 47967
48861: POP
48862: POP
// end ;
48863: LD_VAR 0 1
48867: RET
// export function MC_Heal ; var i , j , tmp ; begin
48868: LD_INT 0
48870: PPUSH
48871: PPUSH
48872: PPUSH
48873: PPUSH
// if not mc_bases then
48874: LD_EXP 102
48878: NOT
48879: IFFALSE 48883
// exit ;
48881: GO 49285
// for i = 1 to mc_bases do
48883: LD_ADDR_VAR 0 2
48887: PUSH
48888: DOUBLE
48889: LD_INT 1
48891: DEC
48892: ST_TO_ADDR
48893: LD_EXP 102
48897: PUSH
48898: FOR_TO
48899: IFFALSE 49283
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48901: LD_EXP 105
48905: PUSH
48906: LD_VAR 0 2
48910: ARRAY
48911: PUSH
48912: LD_INT 1
48914: ARRAY
48915: NOT
48916: PUSH
48917: LD_EXP 105
48921: PUSH
48922: LD_VAR 0 2
48926: ARRAY
48927: PUSH
48928: LD_INT 2
48930: ARRAY
48931: NOT
48932: AND
48933: IFFALSE 48971
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48935: LD_ADDR_EXP 106
48939: PUSH
48940: LD_EXP 106
48944: PPUSH
48945: LD_VAR 0 2
48949: PPUSH
48950: EMPTY
48951: PPUSH
48952: CALL_OW 1
48956: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48957: LD_VAR 0 2
48961: PPUSH
48962: LD_INT 102
48964: PPUSH
48965: CALL 43006 0 2
// continue ;
48969: GO 48898
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48971: LD_ADDR_VAR 0 4
48975: PUSH
48976: LD_EXP 102
48980: PUSH
48981: LD_VAR 0 2
48985: ARRAY
48986: PPUSH
48987: LD_INT 25
48989: PUSH
48990: LD_INT 4
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: PPUSH
48997: CALL_OW 72
49001: ST_TO_ADDR
// if not tmp then
49002: LD_VAR 0 4
49006: NOT
49007: IFFALSE 49011
// continue ;
49009: GO 48898
// if mc_taming [ i ] then
49011: LD_EXP 133
49015: PUSH
49016: LD_VAR 0 2
49020: ARRAY
49021: IFFALSE 49045
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49023: LD_ADDR_EXP 133
49027: PUSH
49028: LD_EXP 133
49032: PPUSH
49033: LD_VAR 0 2
49037: PPUSH
49038: EMPTY
49039: PPUSH
49040: CALL_OW 1
49044: ST_TO_ADDR
// for j in tmp do
49045: LD_ADDR_VAR 0 3
49049: PUSH
49050: LD_VAR 0 4
49054: PUSH
49055: FOR_IN
49056: IFFALSE 49279
// begin if IsInUnit ( j ) then
49058: LD_VAR 0 3
49062: PPUSH
49063: CALL_OW 310
49067: IFFALSE 49078
// ComExitBuilding ( j ) ;
49069: LD_VAR 0 3
49073: PPUSH
49074: CALL_OW 122
// if not j in mc_healers [ i ] then
49078: LD_VAR 0 3
49082: PUSH
49083: LD_EXP 106
49087: PUSH
49088: LD_VAR 0 2
49092: ARRAY
49093: IN
49094: NOT
49095: IFFALSE 49141
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
49097: LD_ADDR_EXP 106
49101: PUSH
49102: LD_EXP 106
49106: PPUSH
49107: LD_VAR 0 2
49111: PUSH
49112: LD_EXP 106
49116: PUSH
49117: LD_VAR 0 2
49121: ARRAY
49122: PUSH
49123: LD_INT 1
49125: PLUS
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PPUSH
49131: LD_VAR 0 3
49135: PPUSH
49136: CALL 74507 0 3
49140: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
49141: LD_VAR 0 3
49145: PPUSH
49146: CALL_OW 110
49150: PUSH
49151: LD_INT 102
49153: NONEQUAL
49154: IFFALSE 49168
// SetTag ( j , 102 ) ;
49156: LD_VAR 0 3
49160: PPUSH
49161: LD_INT 102
49163: PPUSH
49164: CALL_OW 109
// Wait ( 3 ) ;
49168: LD_INT 3
49170: PPUSH
49171: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
49175: LD_EXP 105
49179: PUSH
49180: LD_VAR 0 2
49184: ARRAY
49185: PUSH
49186: LD_INT 1
49188: ARRAY
49189: IFFALSE 49221
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
49191: LD_VAR 0 3
49195: PPUSH
49196: LD_EXP 105
49200: PUSH
49201: LD_VAR 0 2
49205: ARRAY
49206: PUSH
49207: LD_INT 1
49209: ARRAY
49210: PUSH
49211: LD_INT 1
49213: ARRAY
49214: PPUSH
49215: CALL_OW 128
49219: GO 49277
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
49221: LD_VAR 0 3
49225: PPUSH
49226: CALL_OW 314
49230: NOT
49231: PUSH
49232: LD_EXP 105
49236: PUSH
49237: LD_VAR 0 2
49241: ARRAY
49242: PUSH
49243: LD_INT 2
49245: ARRAY
49246: AND
49247: IFFALSE 49277
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
49249: LD_VAR 0 3
49253: PPUSH
49254: LD_EXP 105
49258: PUSH
49259: LD_VAR 0 2
49263: ARRAY
49264: PUSH
49265: LD_INT 2
49267: ARRAY
49268: PUSH
49269: LD_INT 1
49271: ARRAY
49272: PPUSH
49273: CALL_OW 128
// end ;
49277: GO 49055
49279: POP
49280: POP
// end ;
49281: GO 48898
49283: POP
49284: POP
// end ;
49285: LD_VAR 0 1
49289: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
49290: LD_INT 0
49292: PPUSH
49293: PPUSH
49294: PPUSH
49295: PPUSH
49296: PPUSH
49297: PPUSH
// if not mc_bases then
49298: LD_EXP 102
49302: NOT
49303: IFFALSE 49307
// exit ;
49305: GO 50470
// for i = 1 to mc_bases do
49307: LD_ADDR_VAR 0 2
49311: PUSH
49312: DOUBLE
49313: LD_INT 1
49315: DEC
49316: ST_TO_ADDR
49317: LD_EXP 102
49321: PUSH
49322: FOR_TO
49323: IFFALSE 50468
// begin if mc_scan [ i ] then
49325: LD_EXP 125
49329: PUSH
49330: LD_VAR 0 2
49334: ARRAY
49335: IFFALSE 49339
// continue ;
49337: GO 49322
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
49339: LD_EXP 107
49343: PUSH
49344: LD_VAR 0 2
49348: ARRAY
49349: NOT
49350: PUSH
49351: LD_EXP 109
49355: PUSH
49356: LD_VAR 0 2
49360: ARRAY
49361: NOT
49362: AND
49363: PUSH
49364: LD_EXP 108
49368: PUSH
49369: LD_VAR 0 2
49373: ARRAY
49374: AND
49375: IFFALSE 49413
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
49377: LD_ADDR_EXP 108
49381: PUSH
49382: LD_EXP 108
49386: PPUSH
49387: LD_VAR 0 2
49391: PPUSH
49392: EMPTY
49393: PPUSH
49394: CALL_OW 1
49398: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49399: LD_VAR 0 2
49403: PPUSH
49404: LD_INT 103
49406: PPUSH
49407: CALL 43006 0 2
// continue ;
49411: GO 49322
// end ; if mc_construct_list [ i ] then
49413: LD_EXP 109
49417: PUSH
49418: LD_VAR 0 2
49422: ARRAY
49423: IFFALSE 49643
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49425: LD_ADDR_VAR 0 5
49429: PUSH
49430: LD_EXP 102
49434: PUSH
49435: LD_VAR 0 2
49439: ARRAY
49440: PPUSH
49441: LD_INT 25
49443: PUSH
49444: LD_INT 2
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: PPUSH
49451: CALL_OW 72
49455: PUSH
49456: LD_EXP 104
49460: PUSH
49461: LD_VAR 0 2
49465: ARRAY
49466: DIFF
49467: ST_TO_ADDR
// if not tmp then
49468: LD_VAR 0 5
49472: NOT
49473: IFFALSE 49477
// continue ;
49475: GO 49322
// for j in tmp do
49477: LD_ADDR_VAR 0 3
49481: PUSH
49482: LD_VAR 0 5
49486: PUSH
49487: FOR_IN
49488: IFFALSE 49639
// begin if not mc_builders [ i ] then
49490: LD_EXP 108
49494: PUSH
49495: LD_VAR 0 2
49499: ARRAY
49500: NOT
49501: IFFALSE 49559
// begin SetTag ( j , 103 ) ;
49503: LD_VAR 0 3
49507: PPUSH
49508: LD_INT 103
49510: PPUSH
49511: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49515: LD_ADDR_EXP 108
49519: PUSH
49520: LD_EXP 108
49524: PPUSH
49525: LD_VAR 0 2
49529: PUSH
49530: LD_EXP 108
49534: PUSH
49535: LD_VAR 0 2
49539: ARRAY
49540: PUSH
49541: LD_INT 1
49543: PLUS
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: PPUSH
49549: LD_VAR 0 3
49553: PPUSH
49554: CALL 74507 0 3
49558: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49559: LD_VAR 0 3
49563: PPUSH
49564: CALL_OW 310
49568: IFFALSE 49579
// ComExitBuilding ( j ) ;
49570: LD_VAR 0 3
49574: PPUSH
49575: CALL_OW 122
// wait ( 3 ) ;
49579: LD_INT 3
49581: PPUSH
49582: CALL_OW 67
// if not mc_construct_list [ i ] then
49586: LD_EXP 109
49590: PUSH
49591: LD_VAR 0 2
49595: ARRAY
49596: NOT
49597: IFFALSE 49601
// break ;
49599: GO 49639
// if not HasTask ( j ) then
49601: LD_VAR 0 3
49605: PPUSH
49606: CALL_OW 314
49610: NOT
49611: IFFALSE 49637
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
49613: LD_VAR 0 3
49617: PPUSH
49618: LD_EXP 109
49622: PUSH
49623: LD_VAR 0 2
49627: ARRAY
49628: PUSH
49629: LD_INT 1
49631: ARRAY
49632: PPUSH
49633: CALL 77745 0 2
// end ;
49637: GO 49487
49639: POP
49640: POP
// end else
49641: GO 50466
// if mc_build_list [ i ] then
49643: LD_EXP 107
49647: PUSH
49648: LD_VAR 0 2
49652: ARRAY
49653: IFFALSE 50466
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49655: LD_EXP 107
49659: PUSH
49660: LD_VAR 0 2
49664: ARRAY
49665: PUSH
49666: LD_INT 1
49668: ARRAY
49669: PUSH
49670: LD_INT 1
49672: ARRAY
49673: PPUSH
49674: CALL 77569 0 1
49678: PUSH
49679: LD_EXP 102
49683: PUSH
49684: LD_VAR 0 2
49688: ARRAY
49689: PPUSH
49690: LD_INT 2
49692: PUSH
49693: LD_INT 30
49695: PUSH
49696: LD_INT 2
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: PUSH
49703: LD_INT 30
49705: PUSH
49706: LD_INT 3
49708: PUSH
49709: EMPTY
49710: LIST
49711: LIST
49712: PUSH
49713: EMPTY
49714: LIST
49715: LIST
49716: LIST
49717: PPUSH
49718: CALL_OW 72
49722: NOT
49723: AND
49724: IFFALSE 49829
// begin for j = 1 to mc_build_list [ i ] do
49726: LD_ADDR_VAR 0 3
49730: PUSH
49731: DOUBLE
49732: LD_INT 1
49734: DEC
49735: ST_TO_ADDR
49736: LD_EXP 107
49740: PUSH
49741: LD_VAR 0 2
49745: ARRAY
49746: PUSH
49747: FOR_TO
49748: IFFALSE 49827
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49750: LD_EXP 107
49754: PUSH
49755: LD_VAR 0 2
49759: ARRAY
49760: PUSH
49761: LD_VAR 0 3
49765: ARRAY
49766: PUSH
49767: LD_INT 1
49769: ARRAY
49770: PUSH
49771: LD_INT 2
49773: EQUAL
49774: IFFALSE 49825
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49776: LD_ADDR_EXP 107
49780: PUSH
49781: LD_EXP 107
49785: PPUSH
49786: LD_VAR 0 2
49790: PPUSH
49791: LD_EXP 107
49795: PUSH
49796: LD_VAR 0 2
49800: ARRAY
49801: PPUSH
49802: LD_VAR 0 3
49806: PPUSH
49807: LD_INT 1
49809: PPUSH
49810: LD_INT 0
49812: PPUSH
49813: CALL 73925 0 4
49817: PPUSH
49818: CALL_OW 1
49822: ST_TO_ADDR
// break ;
49823: GO 49827
// end ;
49825: GO 49747
49827: POP
49828: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49829: LD_ADDR_VAR 0 6
49833: PUSH
49834: LD_EXP 102
49838: PUSH
49839: LD_VAR 0 2
49843: ARRAY
49844: PPUSH
49845: LD_INT 2
49847: PUSH
49848: LD_INT 30
49850: PUSH
49851: LD_INT 0
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PUSH
49858: LD_INT 30
49860: PUSH
49861: LD_INT 1
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: LIST
49872: PPUSH
49873: CALL_OW 72
49877: ST_TO_ADDR
// for k := 1 to depot do
49878: LD_ADDR_VAR 0 4
49882: PUSH
49883: DOUBLE
49884: LD_INT 1
49886: DEC
49887: ST_TO_ADDR
49888: LD_VAR 0 6
49892: PUSH
49893: FOR_TO
49894: IFFALSE 50464
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49896: LD_EXP 107
49900: PUSH
49901: LD_VAR 0 2
49905: ARRAY
49906: PUSH
49907: LD_INT 1
49909: ARRAY
49910: PUSH
49911: LD_INT 1
49913: ARRAY
49914: PUSH
49915: LD_INT 0
49917: EQUAL
49918: PUSH
49919: LD_VAR 0 6
49923: PUSH
49924: LD_VAR 0 4
49928: ARRAY
49929: PPUSH
49930: LD_EXP 107
49934: PUSH
49935: LD_VAR 0 2
49939: ARRAY
49940: PUSH
49941: LD_INT 1
49943: ARRAY
49944: PUSH
49945: LD_INT 1
49947: ARRAY
49948: PPUSH
49949: LD_EXP 107
49953: PUSH
49954: LD_VAR 0 2
49958: ARRAY
49959: PUSH
49960: LD_INT 1
49962: ARRAY
49963: PUSH
49964: LD_INT 2
49966: ARRAY
49967: PPUSH
49968: LD_EXP 107
49972: PUSH
49973: LD_VAR 0 2
49977: ARRAY
49978: PUSH
49979: LD_INT 1
49981: ARRAY
49982: PUSH
49983: LD_INT 3
49985: ARRAY
49986: PPUSH
49987: LD_EXP 107
49991: PUSH
49992: LD_VAR 0 2
49996: ARRAY
49997: PUSH
49998: LD_INT 1
50000: ARRAY
50001: PUSH
50002: LD_INT 4
50004: ARRAY
50005: PPUSH
50006: CALL 82981 0 5
50010: OR
50011: IFFALSE 50292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50013: LD_ADDR_VAR 0 5
50017: PUSH
50018: LD_EXP 102
50022: PUSH
50023: LD_VAR 0 2
50027: ARRAY
50028: PPUSH
50029: LD_INT 25
50031: PUSH
50032: LD_INT 2
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PPUSH
50039: CALL_OW 72
50043: PUSH
50044: LD_EXP 104
50048: PUSH
50049: LD_VAR 0 2
50053: ARRAY
50054: DIFF
50055: ST_TO_ADDR
// if not tmp then
50056: LD_VAR 0 5
50060: NOT
50061: IFFALSE 50065
// continue ;
50063: GO 49893
// for j in tmp do
50065: LD_ADDR_VAR 0 3
50069: PUSH
50070: LD_VAR 0 5
50074: PUSH
50075: FOR_IN
50076: IFFALSE 50288
// begin if not mc_builders [ i ] then
50078: LD_EXP 108
50082: PUSH
50083: LD_VAR 0 2
50087: ARRAY
50088: NOT
50089: IFFALSE 50147
// begin SetTag ( j , 103 ) ;
50091: LD_VAR 0 3
50095: PPUSH
50096: LD_INT 103
50098: PPUSH
50099: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50103: LD_ADDR_EXP 108
50107: PUSH
50108: LD_EXP 108
50112: PPUSH
50113: LD_VAR 0 2
50117: PUSH
50118: LD_EXP 108
50122: PUSH
50123: LD_VAR 0 2
50127: ARRAY
50128: PUSH
50129: LD_INT 1
50131: PLUS
50132: PUSH
50133: EMPTY
50134: LIST
50135: LIST
50136: PPUSH
50137: LD_VAR 0 3
50141: PPUSH
50142: CALL 74507 0 3
50146: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50147: LD_VAR 0 3
50151: PPUSH
50152: CALL_OW 310
50156: IFFALSE 50167
// ComExitBuilding ( j ) ;
50158: LD_VAR 0 3
50162: PPUSH
50163: CALL_OW 122
// wait ( 3 ) ;
50167: LD_INT 3
50169: PPUSH
50170: CALL_OW 67
// if not mc_build_list [ i ] then
50174: LD_EXP 107
50178: PUSH
50179: LD_VAR 0 2
50183: ARRAY
50184: NOT
50185: IFFALSE 50189
// break ;
50187: GO 50288
// if not HasTask ( j ) then
50189: LD_VAR 0 3
50193: PPUSH
50194: CALL_OW 314
50198: NOT
50199: IFFALSE 50286
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
50201: LD_VAR 0 3
50205: PPUSH
50206: LD_EXP 107
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: PUSH
50217: LD_INT 1
50219: ARRAY
50220: PUSH
50221: LD_INT 1
50223: ARRAY
50224: PPUSH
50225: LD_EXP 107
50229: PUSH
50230: LD_VAR 0 2
50234: ARRAY
50235: PUSH
50236: LD_INT 1
50238: ARRAY
50239: PUSH
50240: LD_INT 2
50242: ARRAY
50243: PPUSH
50244: LD_EXP 107
50248: PUSH
50249: LD_VAR 0 2
50253: ARRAY
50254: PUSH
50255: LD_INT 1
50257: ARRAY
50258: PUSH
50259: LD_INT 3
50261: ARRAY
50262: PPUSH
50263: LD_EXP 107
50267: PUSH
50268: LD_VAR 0 2
50272: ARRAY
50273: PUSH
50274: LD_INT 1
50276: ARRAY
50277: PUSH
50278: LD_INT 4
50280: ARRAY
50281: PPUSH
50282: CALL_OW 145
// end ;
50286: GO 50075
50288: POP
50289: POP
// end else
50290: GO 50462
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
50292: LD_EXP 102
50296: PUSH
50297: LD_VAR 0 2
50301: ARRAY
50302: PPUSH
50303: LD_EXP 107
50307: PUSH
50308: LD_VAR 0 2
50312: ARRAY
50313: PUSH
50314: LD_INT 1
50316: ARRAY
50317: PUSH
50318: LD_INT 1
50320: ARRAY
50321: PPUSH
50322: LD_EXP 107
50326: PUSH
50327: LD_VAR 0 2
50331: ARRAY
50332: PUSH
50333: LD_INT 1
50335: ARRAY
50336: PUSH
50337: LD_INT 2
50339: ARRAY
50340: PPUSH
50341: LD_EXP 107
50345: PUSH
50346: LD_VAR 0 2
50350: ARRAY
50351: PUSH
50352: LD_INT 1
50354: ARRAY
50355: PUSH
50356: LD_INT 3
50358: ARRAY
50359: PPUSH
50360: LD_EXP 107
50364: PUSH
50365: LD_VAR 0 2
50369: ARRAY
50370: PUSH
50371: LD_INT 1
50373: ARRAY
50374: PUSH
50375: LD_INT 4
50377: ARRAY
50378: PPUSH
50379: LD_EXP 102
50383: PUSH
50384: LD_VAR 0 2
50388: ARRAY
50389: PPUSH
50390: LD_INT 21
50392: PUSH
50393: LD_INT 3
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: PPUSH
50400: CALL_OW 72
50404: PPUSH
50405: EMPTY
50406: PPUSH
50407: CALL 81735 0 7
50411: NOT
50412: IFFALSE 50462
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
50414: LD_ADDR_EXP 107
50418: PUSH
50419: LD_EXP 107
50423: PPUSH
50424: LD_VAR 0 2
50428: PPUSH
50429: LD_EXP 107
50433: PUSH
50434: LD_VAR 0 2
50438: ARRAY
50439: PPUSH
50440: LD_INT 1
50442: PPUSH
50443: LD_INT 1
50445: NEG
50446: PPUSH
50447: LD_INT 0
50449: PPUSH
50450: CALL 73925 0 4
50454: PPUSH
50455: CALL_OW 1
50459: ST_TO_ADDR
// continue ;
50460: GO 49893
// end ; end ;
50462: GO 49893
50464: POP
50465: POP
// end ; end ;
50466: GO 49322
50468: POP
50469: POP
// end ;
50470: LD_VAR 0 1
50474: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
50475: LD_INT 0
50477: PPUSH
50478: PPUSH
50479: PPUSH
50480: PPUSH
50481: PPUSH
50482: PPUSH
// if not mc_bases then
50483: LD_EXP 102
50487: NOT
50488: IFFALSE 50492
// exit ;
50490: GO 50919
// for i = 1 to mc_bases do
50492: LD_ADDR_VAR 0 2
50496: PUSH
50497: DOUBLE
50498: LD_INT 1
50500: DEC
50501: ST_TO_ADDR
50502: LD_EXP 102
50506: PUSH
50507: FOR_TO
50508: IFFALSE 50917
// begin tmp := mc_build_upgrade [ i ] ;
50510: LD_ADDR_VAR 0 4
50514: PUSH
50515: LD_EXP 134
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
50526: LD_ADDR_VAR 0 6
50530: PUSH
50531: LD_EXP 135
50535: PUSH
50536: LD_VAR 0 2
50540: ARRAY
50541: PPUSH
50542: LD_INT 2
50544: PUSH
50545: LD_INT 30
50547: PUSH
50548: LD_INT 6
50550: PUSH
50551: EMPTY
50552: LIST
50553: LIST
50554: PUSH
50555: LD_INT 30
50557: PUSH
50558: LD_INT 7
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: LIST
50569: PPUSH
50570: CALL_OW 72
50574: ST_TO_ADDR
// if not tmp and not lab then
50575: LD_VAR 0 4
50579: NOT
50580: PUSH
50581: LD_VAR 0 6
50585: NOT
50586: AND
50587: IFFALSE 50591
// continue ;
50589: GO 50507
// if tmp then
50591: LD_VAR 0 4
50595: IFFALSE 50715
// for j in tmp do
50597: LD_ADDR_VAR 0 3
50601: PUSH
50602: LD_VAR 0 4
50606: PUSH
50607: FOR_IN
50608: IFFALSE 50713
// begin if UpgradeCost ( j ) then
50610: LD_VAR 0 3
50614: PPUSH
50615: CALL 81395 0 1
50619: IFFALSE 50711
// begin ComUpgrade ( j ) ;
50621: LD_VAR 0 3
50625: PPUSH
50626: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
50630: LD_ADDR_EXP 134
50634: PUSH
50635: LD_EXP 134
50639: PPUSH
50640: LD_VAR 0 2
50644: PPUSH
50645: LD_EXP 134
50649: PUSH
50650: LD_VAR 0 2
50654: ARRAY
50655: PUSH
50656: LD_VAR 0 3
50660: DIFF
50661: PPUSH
50662: CALL_OW 1
50666: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50667: LD_ADDR_EXP 109
50671: PUSH
50672: LD_EXP 109
50676: PPUSH
50677: LD_VAR 0 2
50681: PUSH
50682: LD_EXP 109
50686: PUSH
50687: LD_VAR 0 2
50691: ARRAY
50692: PUSH
50693: LD_INT 1
50695: PLUS
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: PPUSH
50701: LD_VAR 0 3
50705: PPUSH
50706: CALL 74507 0 3
50710: ST_TO_ADDR
// end ; end ;
50711: GO 50607
50713: POP
50714: POP
// if not lab or not mc_lab_upgrade [ i ] then
50715: LD_VAR 0 6
50719: NOT
50720: PUSH
50721: LD_EXP 136
50725: PUSH
50726: LD_VAR 0 2
50730: ARRAY
50731: NOT
50732: OR
50733: IFFALSE 50737
// continue ;
50735: GO 50507
// for j in lab do
50737: LD_ADDR_VAR 0 3
50741: PUSH
50742: LD_VAR 0 6
50746: PUSH
50747: FOR_IN
50748: IFFALSE 50913
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50750: LD_VAR 0 3
50754: PPUSH
50755: CALL_OW 266
50759: PUSH
50760: LD_INT 6
50762: PUSH
50763: LD_INT 7
50765: PUSH
50766: EMPTY
50767: LIST
50768: LIST
50769: IN
50770: PUSH
50771: LD_VAR 0 3
50775: PPUSH
50776: CALL_OW 461
50780: PUSH
50781: LD_INT 1
50783: NONEQUAL
50784: AND
50785: IFFALSE 50911
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50787: LD_VAR 0 3
50791: PPUSH
50792: LD_EXP 136
50796: PUSH
50797: LD_VAR 0 2
50801: ARRAY
50802: PUSH
50803: LD_INT 1
50805: ARRAY
50806: PPUSH
50807: CALL 81600 0 2
50811: IFFALSE 50911
// begin ComCancel ( j ) ;
50813: LD_VAR 0 3
50817: PPUSH
50818: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50822: LD_VAR 0 3
50826: PPUSH
50827: LD_EXP 136
50831: PUSH
50832: LD_VAR 0 2
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: PPUSH
50842: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50846: LD_VAR 0 3
50850: PUSH
50851: LD_EXP 109
50855: PUSH
50856: LD_VAR 0 2
50860: ARRAY
50861: IN
50862: NOT
50863: IFFALSE 50909
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50865: LD_ADDR_EXP 109
50869: PUSH
50870: LD_EXP 109
50874: PPUSH
50875: LD_VAR 0 2
50879: PUSH
50880: LD_EXP 109
50884: PUSH
50885: LD_VAR 0 2
50889: ARRAY
50890: PUSH
50891: LD_INT 1
50893: PLUS
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PPUSH
50899: LD_VAR 0 3
50903: PPUSH
50904: CALL 74507 0 3
50908: ST_TO_ADDR
// break ;
50909: GO 50913
// end ; end ; end ;
50911: GO 50747
50913: POP
50914: POP
// end ;
50915: GO 50507
50917: POP
50918: POP
// end ;
50919: LD_VAR 0 1
50923: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50924: LD_INT 0
50926: PPUSH
50927: PPUSH
50928: PPUSH
50929: PPUSH
50930: PPUSH
50931: PPUSH
50932: PPUSH
50933: PPUSH
50934: PPUSH
// if not mc_bases then
50935: LD_EXP 102
50939: NOT
50940: IFFALSE 50944
// exit ;
50942: GO 51349
// for i = 1 to mc_bases do
50944: LD_ADDR_VAR 0 2
50948: PUSH
50949: DOUBLE
50950: LD_INT 1
50952: DEC
50953: ST_TO_ADDR
50954: LD_EXP 102
50958: PUSH
50959: FOR_TO
50960: IFFALSE 51347
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50962: LD_EXP 110
50966: PUSH
50967: LD_VAR 0 2
50971: ARRAY
50972: NOT
50973: PUSH
50974: LD_EXP 102
50978: PUSH
50979: LD_VAR 0 2
50983: ARRAY
50984: PPUSH
50985: LD_INT 30
50987: PUSH
50988: LD_INT 3
50990: PUSH
50991: EMPTY
50992: LIST
50993: LIST
50994: PPUSH
50995: CALL_OW 72
50999: NOT
51000: OR
51001: IFFALSE 51005
// continue ;
51003: GO 50959
// busy := false ;
51005: LD_ADDR_VAR 0 8
51009: PUSH
51010: LD_INT 0
51012: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51013: LD_ADDR_VAR 0 4
51017: PUSH
51018: LD_EXP 102
51022: PUSH
51023: LD_VAR 0 2
51027: ARRAY
51028: PPUSH
51029: LD_INT 30
51031: PUSH
51032: LD_INT 3
51034: PUSH
51035: EMPTY
51036: LIST
51037: LIST
51038: PPUSH
51039: CALL_OW 72
51043: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
51044: LD_ADDR_VAR 0 6
51048: PUSH
51049: LD_EXP 110
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: PPUSH
51060: LD_INT 2
51062: PUSH
51063: LD_INT 30
51065: PUSH
51066: LD_INT 32
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: LD_INT 30
51075: PUSH
51076: LD_INT 33
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: PUSH
51083: EMPTY
51084: LIST
51085: LIST
51086: LIST
51087: PPUSH
51088: CALL_OW 72
51092: ST_TO_ADDR
// if not t then
51093: LD_VAR 0 6
51097: NOT
51098: IFFALSE 51102
// continue ;
51100: GO 50959
// for j in tmp do
51102: LD_ADDR_VAR 0 3
51106: PUSH
51107: LD_VAR 0 4
51111: PUSH
51112: FOR_IN
51113: IFFALSE 51143
// if not BuildingStatus ( j ) = bs_idle then
51115: LD_VAR 0 3
51119: PPUSH
51120: CALL_OW 461
51124: PUSH
51125: LD_INT 2
51127: EQUAL
51128: NOT
51129: IFFALSE 51141
// begin busy := true ;
51131: LD_ADDR_VAR 0 8
51135: PUSH
51136: LD_INT 1
51138: ST_TO_ADDR
// break ;
51139: GO 51143
// end ;
51141: GO 51112
51143: POP
51144: POP
// if busy then
51145: LD_VAR 0 8
51149: IFFALSE 51153
// continue ;
51151: GO 50959
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
51153: LD_ADDR_VAR 0 7
51157: PUSH
51158: LD_VAR 0 6
51162: PPUSH
51163: LD_INT 35
51165: PUSH
51166: LD_INT 0
51168: PUSH
51169: EMPTY
51170: LIST
51171: LIST
51172: PPUSH
51173: CALL_OW 72
51177: ST_TO_ADDR
// if tw then
51178: LD_VAR 0 7
51182: IFFALSE 51259
// begin tw := tw [ 1 ] ;
51184: LD_ADDR_VAR 0 7
51188: PUSH
51189: LD_VAR 0 7
51193: PUSH
51194: LD_INT 1
51196: ARRAY
51197: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
51198: LD_ADDR_VAR 0 9
51202: PUSH
51203: LD_VAR 0 7
51207: PPUSH
51208: LD_EXP 127
51212: PUSH
51213: LD_VAR 0 2
51217: ARRAY
51218: PPUSH
51219: CALL 79892 0 2
51223: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
51224: LD_EXP 141
51228: PUSH
51229: LD_VAR 0 2
51233: ARRAY
51234: IFFALSE 51257
// if not weapon in mc_allowed_tower_weapons [ i ] then
51236: LD_VAR 0 9
51240: PUSH
51241: LD_EXP 141
51245: PUSH
51246: LD_VAR 0 2
51250: ARRAY
51251: IN
51252: NOT
51253: IFFALSE 51257
// continue ;
51255: GO 50959
// end else
51257: GO 51322
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
51259: LD_ADDR_VAR 0 5
51263: PUSH
51264: LD_EXP 110
51268: PUSH
51269: LD_VAR 0 2
51273: ARRAY
51274: PPUSH
51275: LD_VAR 0 4
51279: PPUSH
51280: CALL 106784 0 2
51284: ST_TO_ADDR
// if not tmp2 then
51285: LD_VAR 0 5
51289: NOT
51290: IFFALSE 51294
// continue ;
51292: GO 50959
// tw := tmp2 [ 1 ] ;
51294: LD_ADDR_VAR 0 7
51298: PUSH
51299: LD_VAR 0 5
51303: PUSH
51304: LD_INT 1
51306: ARRAY
51307: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
51308: LD_ADDR_VAR 0 9
51312: PUSH
51313: LD_VAR 0 5
51317: PUSH
51318: LD_INT 2
51320: ARRAY
51321: ST_TO_ADDR
// end ; if not weapon then
51322: LD_VAR 0 9
51326: NOT
51327: IFFALSE 51331
// continue ;
51329: GO 50959
// ComPlaceWeapon ( tw , weapon ) ;
51331: LD_VAR 0 7
51335: PPUSH
51336: LD_VAR 0 9
51340: PPUSH
51341: CALL_OW 148
// end ;
51345: GO 50959
51347: POP
51348: POP
// end ;
51349: LD_VAR 0 1
51353: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
51354: LD_INT 0
51356: PPUSH
51357: PPUSH
51358: PPUSH
51359: PPUSH
51360: PPUSH
51361: PPUSH
51362: PPUSH
// if not mc_bases then
51363: LD_EXP 102
51367: NOT
51368: IFFALSE 51372
// exit ;
51370: GO 52147
// for i = 1 to mc_bases do
51372: LD_ADDR_VAR 0 2
51376: PUSH
51377: DOUBLE
51378: LD_INT 1
51380: DEC
51381: ST_TO_ADDR
51382: LD_EXP 102
51386: PUSH
51387: FOR_TO
51388: IFFALSE 52145
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
51390: LD_EXP 115
51394: PUSH
51395: LD_VAR 0 2
51399: ARRAY
51400: NOT
51401: PUSH
51402: LD_EXP 115
51406: PUSH
51407: LD_VAR 0 2
51411: ARRAY
51412: PUSH
51413: LD_EXP 116
51417: PUSH
51418: LD_VAR 0 2
51422: ARRAY
51423: EQUAL
51424: OR
51425: PUSH
51426: LD_EXP 125
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: OR
51437: IFFALSE 51441
// continue ;
51439: GO 51387
// if mc_miners [ i ] then
51441: LD_EXP 116
51445: PUSH
51446: LD_VAR 0 2
51450: ARRAY
51451: IFFALSE 51832
// begin for j = mc_miners [ i ] downto 1 do
51453: LD_ADDR_VAR 0 3
51457: PUSH
51458: DOUBLE
51459: LD_EXP 116
51463: PUSH
51464: LD_VAR 0 2
51468: ARRAY
51469: INC
51470: ST_TO_ADDR
51471: LD_INT 1
51473: PUSH
51474: FOR_DOWNTO
51475: IFFALSE 51830
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
51477: LD_EXP 116
51481: PUSH
51482: LD_VAR 0 2
51486: ARRAY
51487: PUSH
51488: LD_VAR 0 3
51492: ARRAY
51493: PPUSH
51494: CALL_OW 301
51498: PUSH
51499: LD_EXP 116
51503: PUSH
51504: LD_VAR 0 2
51508: ARRAY
51509: PUSH
51510: LD_VAR 0 3
51514: ARRAY
51515: PPUSH
51516: CALL_OW 257
51520: PUSH
51521: LD_INT 1
51523: NONEQUAL
51524: OR
51525: IFFALSE 51588
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
51527: LD_ADDR_VAR 0 5
51531: PUSH
51532: LD_EXP 116
51536: PUSH
51537: LD_VAR 0 2
51541: ARRAY
51542: PUSH
51543: LD_EXP 116
51547: PUSH
51548: LD_VAR 0 2
51552: ARRAY
51553: PUSH
51554: LD_VAR 0 3
51558: ARRAY
51559: DIFF
51560: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
51561: LD_ADDR_EXP 116
51565: PUSH
51566: LD_EXP 116
51570: PPUSH
51571: LD_VAR 0 2
51575: PPUSH
51576: LD_VAR 0 5
51580: PPUSH
51581: CALL_OW 1
51585: ST_TO_ADDR
// continue ;
51586: GO 51474
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
51588: LD_EXP 116
51592: PUSH
51593: LD_VAR 0 2
51597: ARRAY
51598: PUSH
51599: LD_VAR 0 3
51603: ARRAY
51604: PPUSH
51605: CALL_OW 257
51609: PUSH
51610: LD_INT 1
51612: EQUAL
51613: PUSH
51614: LD_EXP 116
51618: PUSH
51619: LD_VAR 0 2
51623: ARRAY
51624: PUSH
51625: LD_VAR 0 3
51629: ARRAY
51630: PPUSH
51631: CALL_OW 459
51635: NOT
51636: AND
51637: PUSH
51638: LD_EXP 116
51642: PUSH
51643: LD_VAR 0 2
51647: ARRAY
51648: PUSH
51649: LD_VAR 0 3
51653: ARRAY
51654: PPUSH
51655: CALL_OW 314
51659: NOT
51660: AND
51661: IFFALSE 51828
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51663: LD_EXP 116
51667: PUSH
51668: LD_VAR 0 2
51672: ARRAY
51673: PUSH
51674: LD_VAR 0 3
51678: ARRAY
51679: PPUSH
51680: CALL_OW 310
51684: IFFALSE 51707
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51686: LD_EXP 116
51690: PUSH
51691: LD_VAR 0 2
51695: ARRAY
51696: PUSH
51697: LD_VAR 0 3
51701: ARRAY
51702: PPUSH
51703: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51707: LD_EXP 116
51711: PUSH
51712: LD_VAR 0 2
51716: ARRAY
51717: PUSH
51718: LD_VAR 0 3
51722: ARRAY
51723: PPUSH
51724: CALL_OW 314
51728: NOT
51729: IFFALSE 51828
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51731: LD_ADDR_VAR 0 7
51735: PUSH
51736: LD_VAR 0 3
51740: PUSH
51741: LD_EXP 115
51745: PUSH
51746: LD_VAR 0 2
51750: ARRAY
51751: PPUSH
51752: CALL 71647 0 1
51756: MOD
51757: PUSH
51758: LD_INT 1
51760: PLUS
51761: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51762: LD_EXP 116
51766: PUSH
51767: LD_VAR 0 2
51771: ARRAY
51772: PUSH
51773: LD_VAR 0 3
51777: ARRAY
51778: PPUSH
51779: LD_EXP 115
51783: PUSH
51784: LD_VAR 0 2
51788: ARRAY
51789: PUSH
51790: LD_VAR 0 7
51794: ARRAY
51795: PUSH
51796: LD_INT 1
51798: ARRAY
51799: PPUSH
51800: LD_EXP 115
51804: PUSH
51805: LD_VAR 0 2
51809: ARRAY
51810: PUSH
51811: LD_VAR 0 7
51815: ARRAY
51816: PUSH
51817: LD_INT 2
51819: ARRAY
51820: PPUSH
51821: LD_INT 0
51823: PPUSH
51824: CALL_OW 193
// end ; end ; end ;
51828: GO 51474
51830: POP
51831: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51832: LD_ADDR_VAR 0 5
51836: PUSH
51837: LD_EXP 102
51841: PUSH
51842: LD_VAR 0 2
51846: ARRAY
51847: PPUSH
51848: LD_INT 2
51850: PUSH
51851: LD_INT 30
51853: PUSH
51854: LD_INT 4
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: PUSH
51861: LD_INT 30
51863: PUSH
51864: LD_INT 5
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: PUSH
51871: LD_INT 30
51873: PUSH
51874: LD_INT 32
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: PUSH
51881: EMPTY
51882: LIST
51883: LIST
51884: LIST
51885: LIST
51886: PPUSH
51887: CALL_OW 72
51891: ST_TO_ADDR
// if not tmp then
51892: LD_VAR 0 5
51896: NOT
51897: IFFALSE 51901
// continue ;
51899: GO 51387
// list := [ ] ;
51901: LD_ADDR_VAR 0 6
51905: PUSH
51906: EMPTY
51907: ST_TO_ADDR
// for j in tmp do
51908: LD_ADDR_VAR 0 3
51912: PUSH
51913: LD_VAR 0 5
51917: PUSH
51918: FOR_IN
51919: IFFALSE 51988
// begin for k in UnitsInside ( j ) do
51921: LD_ADDR_VAR 0 4
51925: PUSH
51926: LD_VAR 0 3
51930: PPUSH
51931: CALL_OW 313
51935: PUSH
51936: FOR_IN
51937: IFFALSE 51984
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51939: LD_VAR 0 4
51943: PPUSH
51944: CALL_OW 257
51948: PUSH
51949: LD_INT 1
51951: EQUAL
51952: PUSH
51953: LD_VAR 0 4
51957: PPUSH
51958: CALL_OW 459
51962: NOT
51963: AND
51964: IFFALSE 51982
// list := list ^ k ;
51966: LD_ADDR_VAR 0 6
51970: PUSH
51971: LD_VAR 0 6
51975: PUSH
51976: LD_VAR 0 4
51980: ADD
51981: ST_TO_ADDR
51982: GO 51936
51984: POP
51985: POP
// end ;
51986: GO 51918
51988: POP
51989: POP
// list := list diff mc_miners [ i ] ;
51990: LD_ADDR_VAR 0 6
51994: PUSH
51995: LD_VAR 0 6
51999: PUSH
52000: LD_EXP 116
52004: PUSH
52005: LD_VAR 0 2
52009: ARRAY
52010: DIFF
52011: ST_TO_ADDR
// if not list then
52012: LD_VAR 0 6
52016: NOT
52017: IFFALSE 52021
// continue ;
52019: GO 51387
// k := mc_mines [ i ] - mc_miners [ i ] ;
52021: LD_ADDR_VAR 0 4
52025: PUSH
52026: LD_EXP 115
52030: PUSH
52031: LD_VAR 0 2
52035: ARRAY
52036: PUSH
52037: LD_EXP 116
52041: PUSH
52042: LD_VAR 0 2
52046: ARRAY
52047: MINUS
52048: ST_TO_ADDR
// if k > list then
52049: LD_VAR 0 4
52053: PUSH
52054: LD_VAR 0 6
52058: GREATER
52059: IFFALSE 52071
// k := list ;
52061: LD_ADDR_VAR 0 4
52065: PUSH
52066: LD_VAR 0 6
52070: ST_TO_ADDR
// for j = 1 to k do
52071: LD_ADDR_VAR 0 3
52075: PUSH
52076: DOUBLE
52077: LD_INT 1
52079: DEC
52080: ST_TO_ADDR
52081: LD_VAR 0 4
52085: PUSH
52086: FOR_TO
52087: IFFALSE 52141
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
52089: LD_ADDR_EXP 116
52093: PUSH
52094: LD_EXP 116
52098: PPUSH
52099: LD_VAR 0 2
52103: PUSH
52104: LD_EXP 116
52108: PUSH
52109: LD_VAR 0 2
52113: ARRAY
52114: PUSH
52115: LD_INT 1
52117: PLUS
52118: PUSH
52119: EMPTY
52120: LIST
52121: LIST
52122: PPUSH
52123: LD_VAR 0 6
52127: PUSH
52128: LD_VAR 0 3
52132: ARRAY
52133: PPUSH
52134: CALL 74507 0 3
52138: ST_TO_ADDR
52139: GO 52086
52141: POP
52142: POP
// end ;
52143: GO 51387
52145: POP
52146: POP
// end ;
52147: LD_VAR 0 1
52151: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
52152: LD_INT 0
52154: PPUSH
52155: PPUSH
52156: PPUSH
52157: PPUSH
52158: PPUSH
52159: PPUSH
52160: PPUSH
52161: PPUSH
52162: PPUSH
52163: PPUSH
52164: PPUSH
// if not mc_bases then
52165: LD_EXP 102
52169: NOT
52170: IFFALSE 52174
// exit ;
52172: GO 53997
// for i = 1 to mc_bases do
52174: LD_ADDR_VAR 0 2
52178: PUSH
52179: DOUBLE
52180: LD_INT 1
52182: DEC
52183: ST_TO_ADDR
52184: LD_EXP 102
52188: PUSH
52189: FOR_TO
52190: IFFALSE 53995
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
52192: LD_EXP 102
52196: PUSH
52197: LD_VAR 0 2
52201: ARRAY
52202: NOT
52203: PUSH
52204: LD_EXP 109
52208: PUSH
52209: LD_VAR 0 2
52213: ARRAY
52214: OR
52215: IFFALSE 52219
// continue ;
52217: GO 52189
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
52219: LD_EXP 118
52223: PUSH
52224: LD_VAR 0 2
52228: ARRAY
52229: NOT
52230: PUSH
52231: LD_EXP 119
52235: PUSH
52236: LD_VAR 0 2
52240: ARRAY
52241: AND
52242: IFFALSE 52280
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52244: LD_ADDR_EXP 119
52248: PUSH
52249: LD_EXP 119
52253: PPUSH
52254: LD_VAR 0 2
52258: PPUSH
52259: EMPTY
52260: PPUSH
52261: CALL_OW 1
52265: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
52266: LD_VAR 0 2
52270: PPUSH
52271: LD_INT 107
52273: PPUSH
52274: CALL 43006 0 2
// continue ;
52278: GO 52189
// end ; target := [ ] ;
52280: LD_ADDR_VAR 0 7
52284: PUSH
52285: EMPTY
52286: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52287: LD_ADDR_VAR 0 6
52291: PUSH
52292: LD_EXP 102
52296: PUSH
52297: LD_VAR 0 2
52301: ARRAY
52302: PUSH
52303: LD_INT 1
52305: ARRAY
52306: PPUSH
52307: CALL_OW 255
52311: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52312: LD_ADDR_VAR 0 9
52316: PUSH
52317: LD_EXP 102
52321: PUSH
52322: LD_VAR 0 2
52326: ARRAY
52327: PPUSH
52328: LD_INT 2
52330: PUSH
52331: LD_INT 30
52333: PUSH
52334: LD_INT 0
52336: PUSH
52337: EMPTY
52338: LIST
52339: LIST
52340: PUSH
52341: LD_INT 30
52343: PUSH
52344: LD_INT 1
52346: PUSH
52347: EMPTY
52348: LIST
52349: LIST
52350: PUSH
52351: EMPTY
52352: LIST
52353: LIST
52354: LIST
52355: PPUSH
52356: CALL_OW 72
52360: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
52361: LD_ADDR_VAR 0 3
52365: PUSH
52366: DOUBLE
52367: LD_EXP 118
52371: PUSH
52372: LD_VAR 0 2
52376: ARRAY
52377: INC
52378: ST_TO_ADDR
52379: LD_INT 1
52381: PUSH
52382: FOR_DOWNTO
52383: IFFALSE 52628
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
52385: LD_EXP 118
52389: PUSH
52390: LD_VAR 0 2
52394: ARRAY
52395: PUSH
52396: LD_VAR 0 3
52400: ARRAY
52401: PUSH
52402: LD_INT 2
52404: ARRAY
52405: PPUSH
52406: LD_EXP 118
52410: PUSH
52411: LD_VAR 0 2
52415: ARRAY
52416: PUSH
52417: LD_VAR 0 3
52421: ARRAY
52422: PUSH
52423: LD_INT 3
52425: ARRAY
52426: PPUSH
52427: CALL_OW 488
52431: PUSH
52432: LD_EXP 118
52436: PUSH
52437: LD_VAR 0 2
52441: ARRAY
52442: PUSH
52443: LD_VAR 0 3
52447: ARRAY
52448: PUSH
52449: LD_INT 2
52451: ARRAY
52452: PPUSH
52453: LD_EXP 118
52457: PUSH
52458: LD_VAR 0 2
52462: ARRAY
52463: PUSH
52464: LD_VAR 0 3
52468: ARRAY
52469: PUSH
52470: LD_INT 3
52472: ARRAY
52473: PPUSH
52474: CALL_OW 284
52478: PUSH
52479: LD_INT 0
52481: EQUAL
52482: AND
52483: IFFALSE 52538
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
52485: LD_ADDR_VAR 0 5
52489: PUSH
52490: LD_EXP 118
52494: PUSH
52495: LD_VAR 0 2
52499: ARRAY
52500: PPUSH
52501: LD_VAR 0 3
52505: PPUSH
52506: CALL_OW 3
52510: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
52511: LD_ADDR_EXP 118
52515: PUSH
52516: LD_EXP 118
52520: PPUSH
52521: LD_VAR 0 2
52525: PPUSH
52526: LD_VAR 0 5
52530: PPUSH
52531: CALL_OW 1
52535: ST_TO_ADDR
// continue ;
52536: GO 52382
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
52538: LD_VAR 0 6
52542: PPUSH
52543: LD_EXP 118
52547: PUSH
52548: LD_VAR 0 2
52552: ARRAY
52553: PUSH
52554: LD_VAR 0 3
52558: ARRAY
52559: PUSH
52560: LD_INT 2
52562: ARRAY
52563: PPUSH
52564: LD_EXP 118
52568: PUSH
52569: LD_VAR 0 2
52573: ARRAY
52574: PUSH
52575: LD_VAR 0 3
52579: ARRAY
52580: PUSH
52581: LD_INT 3
52583: ARRAY
52584: PPUSH
52585: LD_INT 30
52587: PPUSH
52588: CALL 75771 0 4
52592: PUSH
52593: LD_INT 4
52595: ARRAY
52596: PUSH
52597: LD_INT 0
52599: EQUAL
52600: IFFALSE 52626
// begin target := mc_crates [ i ] [ j ] ;
52602: LD_ADDR_VAR 0 7
52606: PUSH
52607: LD_EXP 118
52611: PUSH
52612: LD_VAR 0 2
52616: ARRAY
52617: PUSH
52618: LD_VAR 0 3
52622: ARRAY
52623: ST_TO_ADDR
// break ;
52624: GO 52628
// end ; end ;
52626: GO 52382
52628: POP
52629: POP
// if not target then
52630: LD_VAR 0 7
52634: NOT
52635: IFFALSE 52639
// continue ;
52637: GO 52189
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
52639: LD_ADDR_VAR 0 8
52643: PUSH
52644: LD_EXP 121
52648: PUSH
52649: LD_VAR 0 2
52653: ARRAY
52654: PPUSH
52655: LD_INT 2
52657: PUSH
52658: LD_INT 3
52660: PUSH
52661: LD_INT 58
52663: PUSH
52664: EMPTY
52665: LIST
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: PUSH
52671: LD_INT 61
52673: PUSH
52674: EMPTY
52675: LIST
52676: PUSH
52677: LD_INT 33
52679: PUSH
52680: LD_INT 5
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PUSH
52687: LD_INT 33
52689: PUSH
52690: LD_INT 3
52692: PUSH
52693: EMPTY
52694: LIST
52695: LIST
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: LIST
52701: LIST
52702: LIST
52703: PUSH
52704: LD_INT 2
52706: PUSH
52707: LD_INT 34
52709: PUSH
52710: LD_INT 32
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: PUSH
52717: LD_INT 34
52719: PUSH
52720: LD_INT 51
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: LD_INT 34
52729: PUSH
52730: LD_INT 12
52732: PUSH
52733: EMPTY
52734: LIST
52735: LIST
52736: PUSH
52737: EMPTY
52738: LIST
52739: LIST
52740: LIST
52741: LIST
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: PPUSH
52747: CALL_OW 72
52751: ST_TO_ADDR
// if not cargo then
52752: LD_VAR 0 8
52756: NOT
52757: IFFALSE 53463
// begin if mc_crates_collector [ i ] < 5 then
52759: LD_EXP 119
52763: PUSH
52764: LD_VAR 0 2
52768: ARRAY
52769: PUSH
52770: LD_INT 5
52772: LESS
52773: IFFALSE 53139
// begin if mc_ape [ i ] then
52775: LD_EXP 131
52779: PUSH
52780: LD_VAR 0 2
52784: ARRAY
52785: IFFALSE 52832
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52787: LD_ADDR_VAR 0 5
52791: PUSH
52792: LD_EXP 131
52796: PUSH
52797: LD_VAR 0 2
52801: ARRAY
52802: PPUSH
52803: LD_INT 25
52805: PUSH
52806: LD_INT 16
52808: PUSH
52809: EMPTY
52810: LIST
52811: LIST
52812: PUSH
52813: LD_INT 24
52815: PUSH
52816: LD_INT 750
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PPUSH
52827: CALL_OW 72
52831: ST_TO_ADDR
// if not tmp then
52832: LD_VAR 0 5
52836: NOT
52837: IFFALSE 52884
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52839: LD_ADDR_VAR 0 5
52843: PUSH
52844: LD_EXP 102
52848: PUSH
52849: LD_VAR 0 2
52853: ARRAY
52854: PPUSH
52855: LD_INT 25
52857: PUSH
52858: LD_INT 2
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: PUSH
52865: LD_INT 24
52867: PUSH
52868: LD_INT 750
52870: PUSH
52871: EMPTY
52872: LIST
52873: LIST
52874: PUSH
52875: EMPTY
52876: LIST
52877: LIST
52878: PPUSH
52879: CALL_OW 72
52883: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52884: LD_EXP 131
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_EXP 102
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: PPUSH
52906: LD_INT 25
52908: PUSH
52909: LD_INT 2
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: PUSH
52916: LD_INT 24
52918: PUSH
52919: LD_INT 750
52921: PUSH
52922: EMPTY
52923: LIST
52924: LIST
52925: PUSH
52926: EMPTY
52927: LIST
52928: LIST
52929: PPUSH
52930: CALL_OW 72
52934: AND
52935: PUSH
52936: LD_VAR 0 5
52940: PUSH
52941: LD_INT 5
52943: LESS
52944: AND
52945: IFFALSE 53027
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52947: LD_ADDR_VAR 0 3
52951: PUSH
52952: LD_EXP 102
52956: PUSH
52957: LD_VAR 0 2
52961: ARRAY
52962: PPUSH
52963: LD_INT 25
52965: PUSH
52966: LD_INT 2
52968: PUSH
52969: EMPTY
52970: LIST
52971: LIST
52972: PUSH
52973: LD_INT 24
52975: PUSH
52976: LD_INT 750
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: EMPTY
52984: LIST
52985: LIST
52986: PPUSH
52987: CALL_OW 72
52991: PUSH
52992: FOR_IN
52993: IFFALSE 53025
// begin tmp := tmp union j ;
52995: LD_ADDR_VAR 0 5
52999: PUSH
53000: LD_VAR 0 5
53004: PUSH
53005: LD_VAR 0 3
53009: UNION
53010: ST_TO_ADDR
// if tmp >= 5 then
53011: LD_VAR 0 5
53015: PUSH
53016: LD_INT 5
53018: GREATEREQUAL
53019: IFFALSE 53023
// break ;
53021: GO 53025
// end ;
53023: GO 52992
53025: POP
53026: POP
// end ; if not tmp then
53027: LD_VAR 0 5
53031: NOT
53032: IFFALSE 53036
// continue ;
53034: GO 52189
// for j in tmp do
53036: LD_ADDR_VAR 0 3
53040: PUSH
53041: LD_VAR 0 5
53045: PUSH
53046: FOR_IN
53047: IFFALSE 53137
// if not GetTag ( j ) then
53049: LD_VAR 0 3
53053: PPUSH
53054: CALL_OW 110
53058: NOT
53059: IFFALSE 53135
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
53061: LD_ADDR_EXP 119
53065: PUSH
53066: LD_EXP 119
53070: PPUSH
53071: LD_VAR 0 2
53075: PUSH
53076: LD_EXP 119
53080: PUSH
53081: LD_VAR 0 2
53085: ARRAY
53086: PUSH
53087: LD_INT 1
53089: PLUS
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: PPUSH
53095: LD_VAR 0 3
53099: PPUSH
53100: CALL 74507 0 3
53104: ST_TO_ADDR
// SetTag ( j , 107 ) ;
53105: LD_VAR 0 3
53109: PPUSH
53110: LD_INT 107
53112: PPUSH
53113: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
53117: LD_EXP 119
53121: PUSH
53122: LD_VAR 0 2
53126: ARRAY
53127: PUSH
53128: LD_INT 5
53130: GREATEREQUAL
53131: IFFALSE 53135
// break ;
53133: GO 53137
// end ;
53135: GO 53046
53137: POP
53138: POP
// end ; if mc_crates_collector [ i ] and target then
53139: LD_EXP 119
53143: PUSH
53144: LD_VAR 0 2
53148: ARRAY
53149: PUSH
53150: LD_VAR 0 7
53154: AND
53155: IFFALSE 53461
// begin if mc_crates_collector [ i ] < target [ 1 ] then
53157: LD_EXP 119
53161: PUSH
53162: LD_VAR 0 2
53166: ARRAY
53167: PUSH
53168: LD_VAR 0 7
53172: PUSH
53173: LD_INT 1
53175: ARRAY
53176: LESS
53177: IFFALSE 53197
// tmp := mc_crates_collector [ i ] else
53179: LD_ADDR_VAR 0 5
53183: PUSH
53184: LD_EXP 119
53188: PUSH
53189: LD_VAR 0 2
53193: ARRAY
53194: ST_TO_ADDR
53195: GO 53211
// tmp := target [ 1 ] ;
53197: LD_ADDR_VAR 0 5
53201: PUSH
53202: LD_VAR 0 7
53206: PUSH
53207: LD_INT 1
53209: ARRAY
53210: ST_TO_ADDR
// k := 0 ;
53211: LD_ADDR_VAR 0 4
53215: PUSH
53216: LD_INT 0
53218: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
53219: LD_ADDR_VAR 0 3
53223: PUSH
53224: LD_EXP 119
53228: PUSH
53229: LD_VAR 0 2
53233: ARRAY
53234: PUSH
53235: FOR_IN
53236: IFFALSE 53459
// begin k := k + 1 ;
53238: LD_ADDR_VAR 0 4
53242: PUSH
53243: LD_VAR 0 4
53247: PUSH
53248: LD_INT 1
53250: PLUS
53251: ST_TO_ADDR
// if k > tmp then
53252: LD_VAR 0 4
53256: PUSH
53257: LD_VAR 0 5
53261: GREATER
53262: IFFALSE 53266
// break ;
53264: GO 53459
// if not GetClass ( j ) in [ 2 , 16 ] then
53266: LD_VAR 0 3
53270: PPUSH
53271: CALL_OW 257
53275: PUSH
53276: LD_INT 2
53278: PUSH
53279: LD_INT 16
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: IN
53286: NOT
53287: IFFALSE 53340
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
53289: LD_ADDR_EXP 119
53293: PUSH
53294: LD_EXP 119
53298: PPUSH
53299: LD_VAR 0 2
53303: PPUSH
53304: LD_EXP 119
53308: PUSH
53309: LD_VAR 0 2
53313: ARRAY
53314: PUSH
53315: LD_VAR 0 3
53319: DIFF
53320: PPUSH
53321: CALL_OW 1
53325: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53326: LD_VAR 0 3
53330: PPUSH
53331: LD_INT 0
53333: PPUSH
53334: CALL_OW 109
// continue ;
53338: GO 53235
// end ; if IsInUnit ( j ) then
53340: LD_VAR 0 3
53344: PPUSH
53345: CALL_OW 310
53349: IFFALSE 53360
// ComExitBuilding ( j ) ;
53351: LD_VAR 0 3
53355: PPUSH
53356: CALL_OW 122
// wait ( 3 ) ;
53360: LD_INT 3
53362: PPUSH
53363: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
53367: LD_VAR 0 3
53371: PPUSH
53372: CALL_OW 314
53376: PUSH
53377: LD_VAR 0 6
53381: PPUSH
53382: LD_VAR 0 7
53386: PUSH
53387: LD_INT 2
53389: ARRAY
53390: PPUSH
53391: LD_VAR 0 7
53395: PUSH
53396: LD_INT 3
53398: ARRAY
53399: PPUSH
53400: LD_INT 30
53402: PPUSH
53403: CALL 75771 0 4
53407: PUSH
53408: LD_INT 4
53410: ARRAY
53411: AND
53412: IFFALSE 53430
// ComStandNearbyBuilding ( j , depot ) else
53414: LD_VAR 0 3
53418: PPUSH
53419: LD_VAR 0 9
53423: PPUSH
53424: CALL 71109 0 2
53428: GO 53457
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53430: LD_VAR 0 3
53434: PPUSH
53435: LD_VAR 0 7
53439: PUSH
53440: LD_INT 2
53442: ARRAY
53443: PPUSH
53444: LD_VAR 0 7
53448: PUSH
53449: LD_INT 3
53451: ARRAY
53452: PPUSH
53453: CALL_OW 117
// end ;
53457: GO 53235
53459: POP
53460: POP
// end ; end else
53461: GO 53993
// begin for j in cargo do
53463: LD_ADDR_VAR 0 3
53467: PUSH
53468: LD_VAR 0 8
53472: PUSH
53473: FOR_IN
53474: IFFALSE 53991
// begin if GetTag ( j ) <> 0 then
53476: LD_VAR 0 3
53480: PPUSH
53481: CALL_OW 110
53485: PUSH
53486: LD_INT 0
53488: NONEQUAL
53489: IFFALSE 53493
// continue ;
53491: GO 53473
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
53493: LD_VAR 0 3
53497: PPUSH
53498: CALL_OW 256
53502: PUSH
53503: LD_INT 1000
53505: LESS
53506: PUSH
53507: LD_VAR 0 3
53511: PPUSH
53512: LD_EXP 126
53516: PUSH
53517: LD_VAR 0 2
53521: ARRAY
53522: PPUSH
53523: CALL_OW 308
53527: NOT
53528: AND
53529: IFFALSE 53551
// ComMoveToArea ( j , mc_parking [ i ] ) ;
53531: LD_VAR 0 3
53535: PPUSH
53536: LD_EXP 126
53540: PUSH
53541: LD_VAR 0 2
53545: ARRAY
53546: PPUSH
53547: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
53551: LD_VAR 0 3
53555: PPUSH
53556: CALL_OW 256
53560: PUSH
53561: LD_INT 1000
53563: LESS
53564: PUSH
53565: LD_VAR 0 3
53569: PPUSH
53570: LD_EXP 126
53574: PUSH
53575: LD_VAR 0 2
53579: ARRAY
53580: PPUSH
53581: CALL_OW 308
53585: AND
53586: IFFALSE 53590
// continue ;
53588: GO 53473
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
53590: LD_VAR 0 3
53594: PPUSH
53595: CALL_OW 262
53599: PUSH
53600: LD_INT 2
53602: EQUAL
53603: PUSH
53604: LD_VAR 0 3
53608: PPUSH
53609: CALL_OW 261
53613: PUSH
53614: LD_INT 15
53616: LESS
53617: AND
53618: IFFALSE 53622
// continue ;
53620: GO 53473
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
53622: LD_VAR 0 3
53626: PPUSH
53627: CALL_OW 262
53631: PUSH
53632: LD_INT 1
53634: EQUAL
53635: PUSH
53636: LD_VAR 0 3
53640: PPUSH
53641: CALL_OW 261
53645: PUSH
53646: LD_INT 10
53648: LESS
53649: AND
53650: IFFALSE 53930
// begin if not depot then
53652: LD_VAR 0 9
53656: NOT
53657: IFFALSE 53661
// continue ;
53659: GO 53473
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53661: LD_VAR 0 3
53665: PPUSH
53666: LD_VAR 0 9
53670: PPUSH
53671: LD_VAR 0 3
53675: PPUSH
53676: CALL_OW 74
53680: PPUSH
53681: CALL_OW 296
53685: PUSH
53686: LD_INT 6
53688: LESS
53689: IFFALSE 53705
// SetFuel ( j , 100 ) else
53691: LD_VAR 0 3
53695: PPUSH
53696: LD_INT 100
53698: PPUSH
53699: CALL_OW 240
53703: GO 53930
// if GetFuel ( j ) = 0 then
53705: LD_VAR 0 3
53709: PPUSH
53710: CALL_OW 261
53714: PUSH
53715: LD_INT 0
53717: EQUAL
53718: IFFALSE 53930
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53720: LD_ADDR_EXP 121
53724: PUSH
53725: LD_EXP 121
53729: PPUSH
53730: LD_VAR 0 2
53734: PPUSH
53735: LD_EXP 121
53739: PUSH
53740: LD_VAR 0 2
53744: ARRAY
53745: PUSH
53746: LD_VAR 0 3
53750: DIFF
53751: PPUSH
53752: CALL_OW 1
53756: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53757: LD_VAR 0 3
53761: PPUSH
53762: CALL_OW 263
53766: PUSH
53767: LD_INT 1
53769: EQUAL
53770: IFFALSE 53786
// ComExitVehicle ( IsInUnit ( j ) ) ;
53772: LD_VAR 0 3
53776: PPUSH
53777: CALL_OW 310
53781: PPUSH
53782: CALL_OW 121
// if GetControl ( j ) = control_remote then
53786: LD_VAR 0 3
53790: PPUSH
53791: CALL_OW 263
53795: PUSH
53796: LD_INT 2
53798: EQUAL
53799: IFFALSE 53810
// ComUnlink ( j ) ;
53801: LD_VAR 0 3
53805: PPUSH
53806: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53810: LD_ADDR_VAR 0 10
53814: PUSH
53815: LD_VAR 0 2
53819: PPUSH
53820: LD_INT 3
53822: PPUSH
53823: CALL 63574 0 2
53827: ST_TO_ADDR
// if fac then
53828: LD_VAR 0 10
53832: IFFALSE 53928
// begin for k in fac do
53834: LD_ADDR_VAR 0 4
53838: PUSH
53839: LD_VAR 0 10
53843: PUSH
53844: FOR_IN
53845: IFFALSE 53926
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53847: LD_ADDR_VAR 0 11
53851: PUSH
53852: LD_VAR 0 10
53856: PPUSH
53857: LD_VAR 0 3
53861: PPUSH
53862: CALL_OW 265
53866: PPUSH
53867: LD_VAR 0 3
53871: PPUSH
53872: CALL_OW 262
53876: PPUSH
53877: LD_VAR 0 3
53881: PPUSH
53882: CALL_OW 263
53886: PPUSH
53887: LD_VAR 0 3
53891: PPUSH
53892: CALL_OW 264
53896: PPUSH
53897: CALL 72005 0 5
53901: ST_TO_ADDR
// if components then
53902: LD_VAR 0 11
53906: IFFALSE 53924
// begin MC_InsertProduceList ( i , components ) ;
53908: LD_VAR 0 2
53912: PPUSH
53913: LD_VAR 0 11
53917: PPUSH
53918: CALL 63119 0 2
// break ;
53922: GO 53926
// end ; end ;
53924: GO 53844
53926: POP
53927: POP
// end ; continue ;
53928: GO 53473
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53930: LD_VAR 0 3
53934: PPUSH
53935: LD_INT 1
53937: PPUSH
53938: CALL_OW 289
53942: PUSH
53943: LD_INT 100
53945: LESS
53946: PUSH
53947: LD_VAR 0 3
53951: PPUSH
53952: CALL_OW 314
53956: NOT
53957: AND
53958: IFFALSE 53987
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53960: LD_VAR 0 3
53964: PPUSH
53965: LD_VAR 0 7
53969: PUSH
53970: LD_INT 2
53972: ARRAY
53973: PPUSH
53974: LD_VAR 0 7
53978: PUSH
53979: LD_INT 3
53981: ARRAY
53982: PPUSH
53983: CALL_OW 117
// break ;
53987: GO 53991
// end ;
53989: GO 53473
53991: POP
53992: POP
// end ; end ;
53993: GO 52189
53995: POP
53996: POP
// end ;
53997: LD_VAR 0 1
54001: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
54002: LD_INT 0
54004: PPUSH
54005: PPUSH
54006: PPUSH
54007: PPUSH
// if not mc_bases then
54008: LD_EXP 102
54012: NOT
54013: IFFALSE 54017
// exit ;
54015: GO 54178
// for i = 1 to mc_bases do
54017: LD_ADDR_VAR 0 2
54021: PUSH
54022: DOUBLE
54023: LD_INT 1
54025: DEC
54026: ST_TO_ADDR
54027: LD_EXP 102
54031: PUSH
54032: FOR_TO
54033: IFFALSE 54176
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
54035: LD_ADDR_VAR 0 4
54039: PUSH
54040: LD_EXP 121
54044: PUSH
54045: LD_VAR 0 2
54049: ARRAY
54050: PUSH
54051: LD_EXP 124
54055: PUSH
54056: LD_VAR 0 2
54060: ARRAY
54061: UNION
54062: PPUSH
54063: LD_INT 33
54065: PUSH
54066: LD_INT 2
54068: PUSH
54069: EMPTY
54070: LIST
54071: LIST
54072: PPUSH
54073: CALL_OW 72
54077: ST_TO_ADDR
// if tmp then
54078: LD_VAR 0 4
54082: IFFALSE 54174
// for j in tmp do
54084: LD_ADDR_VAR 0 3
54088: PUSH
54089: LD_VAR 0 4
54093: PUSH
54094: FOR_IN
54095: IFFALSE 54172
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
54097: LD_VAR 0 3
54101: PPUSH
54102: CALL_OW 312
54106: NOT
54107: PUSH
54108: LD_VAR 0 3
54112: PPUSH
54113: CALL_OW 256
54117: PUSH
54118: LD_INT 250
54120: GREATEREQUAL
54121: AND
54122: IFFALSE 54135
// Connect ( j ) else
54124: LD_VAR 0 3
54128: PPUSH
54129: CALL 77853 0 1
54133: GO 54170
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
54135: LD_VAR 0 3
54139: PPUSH
54140: CALL_OW 256
54144: PUSH
54145: LD_INT 250
54147: LESS
54148: PUSH
54149: LD_VAR 0 3
54153: PPUSH
54154: CALL_OW 312
54158: AND
54159: IFFALSE 54170
// ComUnlink ( j ) ;
54161: LD_VAR 0 3
54165: PPUSH
54166: CALL_OW 136
54170: GO 54094
54172: POP
54173: POP
// end ;
54174: GO 54032
54176: POP
54177: POP
// end ;
54178: LD_VAR 0 1
54182: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
54183: LD_INT 0
54185: PPUSH
54186: PPUSH
54187: PPUSH
54188: PPUSH
54189: PPUSH
// if not mc_bases then
54190: LD_EXP 102
54194: NOT
54195: IFFALSE 54199
// exit ;
54197: GO 54644
// for i = 1 to mc_bases do
54199: LD_ADDR_VAR 0 2
54203: PUSH
54204: DOUBLE
54205: LD_INT 1
54207: DEC
54208: ST_TO_ADDR
54209: LD_EXP 102
54213: PUSH
54214: FOR_TO
54215: IFFALSE 54642
// begin if not mc_produce [ i ] then
54217: LD_EXP 123
54221: PUSH
54222: LD_VAR 0 2
54226: ARRAY
54227: NOT
54228: IFFALSE 54232
// continue ;
54230: GO 54214
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54232: LD_ADDR_VAR 0 5
54236: PUSH
54237: LD_EXP 102
54241: PUSH
54242: LD_VAR 0 2
54246: ARRAY
54247: PPUSH
54248: LD_INT 30
54250: PUSH
54251: LD_INT 3
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PPUSH
54258: CALL_OW 72
54262: ST_TO_ADDR
// if not fac then
54263: LD_VAR 0 5
54267: NOT
54268: IFFALSE 54272
// continue ;
54270: GO 54214
// for j in fac do
54272: LD_ADDR_VAR 0 3
54276: PUSH
54277: LD_VAR 0 5
54281: PUSH
54282: FOR_IN
54283: IFFALSE 54638
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
54285: LD_VAR 0 3
54289: PPUSH
54290: CALL_OW 461
54294: PUSH
54295: LD_INT 2
54297: NONEQUAL
54298: PUSH
54299: LD_VAR 0 3
54303: PPUSH
54304: LD_INT 15
54306: PPUSH
54307: CALL 77472 0 2
54311: PUSH
54312: LD_INT 4
54314: ARRAY
54315: OR
54316: IFFALSE 54320
// continue ;
54318: GO 54282
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
54320: LD_VAR 0 3
54324: PPUSH
54325: LD_EXP 123
54329: PUSH
54330: LD_VAR 0 2
54334: ARRAY
54335: PUSH
54336: LD_INT 1
54338: ARRAY
54339: PUSH
54340: LD_INT 1
54342: ARRAY
54343: PPUSH
54344: LD_EXP 123
54348: PUSH
54349: LD_VAR 0 2
54353: ARRAY
54354: PUSH
54355: LD_INT 1
54357: ARRAY
54358: PUSH
54359: LD_INT 2
54361: ARRAY
54362: PPUSH
54363: LD_EXP 123
54367: PUSH
54368: LD_VAR 0 2
54372: ARRAY
54373: PUSH
54374: LD_INT 1
54376: ARRAY
54377: PUSH
54378: LD_INT 3
54380: ARRAY
54381: PPUSH
54382: LD_EXP 123
54386: PUSH
54387: LD_VAR 0 2
54391: ARRAY
54392: PUSH
54393: LD_INT 1
54395: ARRAY
54396: PUSH
54397: LD_INT 4
54399: ARRAY
54400: PPUSH
54401: CALL_OW 448
54405: PUSH
54406: LD_VAR 0 3
54410: PPUSH
54411: LD_EXP 123
54415: PUSH
54416: LD_VAR 0 2
54420: ARRAY
54421: PUSH
54422: LD_INT 1
54424: ARRAY
54425: PUSH
54426: LD_INT 1
54428: ARRAY
54429: PUSH
54430: LD_EXP 123
54434: PUSH
54435: LD_VAR 0 2
54439: ARRAY
54440: PUSH
54441: LD_INT 1
54443: ARRAY
54444: PUSH
54445: LD_INT 2
54447: ARRAY
54448: PUSH
54449: LD_EXP 123
54453: PUSH
54454: LD_VAR 0 2
54458: ARRAY
54459: PUSH
54460: LD_INT 1
54462: ARRAY
54463: PUSH
54464: LD_INT 3
54466: ARRAY
54467: PUSH
54468: LD_EXP 123
54472: PUSH
54473: LD_VAR 0 2
54477: ARRAY
54478: PUSH
54479: LD_INT 1
54481: ARRAY
54482: PUSH
54483: LD_INT 4
54485: ARRAY
54486: PUSH
54487: EMPTY
54488: LIST
54489: LIST
54490: LIST
54491: LIST
54492: PPUSH
54493: CALL 81248 0 2
54497: AND
54498: IFFALSE 54636
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
54500: LD_VAR 0 3
54504: PPUSH
54505: LD_EXP 123
54509: PUSH
54510: LD_VAR 0 2
54514: ARRAY
54515: PUSH
54516: LD_INT 1
54518: ARRAY
54519: PUSH
54520: LD_INT 1
54522: ARRAY
54523: PPUSH
54524: LD_EXP 123
54528: PUSH
54529: LD_VAR 0 2
54533: ARRAY
54534: PUSH
54535: LD_INT 1
54537: ARRAY
54538: PUSH
54539: LD_INT 2
54541: ARRAY
54542: PPUSH
54543: LD_EXP 123
54547: PUSH
54548: LD_VAR 0 2
54552: ARRAY
54553: PUSH
54554: LD_INT 1
54556: ARRAY
54557: PUSH
54558: LD_INT 3
54560: ARRAY
54561: PPUSH
54562: LD_EXP 123
54566: PUSH
54567: LD_VAR 0 2
54571: ARRAY
54572: PUSH
54573: LD_INT 1
54575: ARRAY
54576: PUSH
54577: LD_INT 4
54579: ARRAY
54580: PPUSH
54581: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
54585: LD_ADDR_VAR 0 4
54589: PUSH
54590: LD_EXP 123
54594: PUSH
54595: LD_VAR 0 2
54599: ARRAY
54600: PPUSH
54601: LD_INT 1
54603: PPUSH
54604: CALL_OW 3
54608: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
54609: LD_ADDR_EXP 123
54613: PUSH
54614: LD_EXP 123
54618: PPUSH
54619: LD_VAR 0 2
54623: PPUSH
54624: LD_VAR 0 4
54628: PPUSH
54629: CALL_OW 1
54633: ST_TO_ADDR
// break ;
54634: GO 54638
// end ; end ;
54636: GO 54282
54638: POP
54639: POP
// end ;
54640: GO 54214
54642: POP
54643: POP
// end ;
54644: LD_VAR 0 1
54648: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54649: LD_INT 0
54651: PPUSH
54652: PPUSH
54653: PPUSH
// if not mc_bases then
54654: LD_EXP 102
54658: NOT
54659: IFFALSE 54663
// exit ;
54661: GO 54752
// for i = 1 to mc_bases do
54663: LD_ADDR_VAR 0 2
54667: PUSH
54668: DOUBLE
54669: LD_INT 1
54671: DEC
54672: ST_TO_ADDR
54673: LD_EXP 102
54677: PUSH
54678: FOR_TO
54679: IFFALSE 54750
// begin if mc_attack [ i ] then
54681: LD_EXP 122
54685: PUSH
54686: LD_VAR 0 2
54690: ARRAY
54691: IFFALSE 54748
// begin tmp := mc_attack [ i ] [ 1 ] ;
54693: LD_ADDR_VAR 0 3
54697: PUSH
54698: LD_EXP 122
54702: PUSH
54703: LD_VAR 0 2
54707: ARRAY
54708: PUSH
54709: LD_INT 1
54711: ARRAY
54712: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54713: LD_ADDR_EXP 122
54717: PUSH
54718: LD_EXP 122
54722: PPUSH
54723: LD_VAR 0 2
54727: PPUSH
54728: EMPTY
54729: PPUSH
54730: CALL_OW 1
54734: ST_TO_ADDR
// Attack ( tmp ) ;
54735: LD_VAR 0 3
54739: PPUSH
54740: CALL 133029 0 1
// exit ;
54744: POP
54745: POP
54746: GO 54752
// end ; end ;
54748: GO 54678
54750: POP
54751: POP
// end ;
54752: LD_VAR 0 1
54756: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54757: LD_INT 0
54759: PPUSH
54760: PPUSH
54761: PPUSH
54762: PPUSH
54763: PPUSH
54764: PPUSH
54765: PPUSH
// if not mc_bases then
54766: LD_EXP 102
54770: NOT
54771: IFFALSE 54775
// exit ;
54773: GO 55632
// for i = 1 to mc_bases do
54775: LD_ADDR_VAR 0 2
54779: PUSH
54780: DOUBLE
54781: LD_INT 1
54783: DEC
54784: ST_TO_ADDR
54785: LD_EXP 102
54789: PUSH
54790: FOR_TO
54791: IFFALSE 55630
// begin if not mc_bases [ i ] then
54793: LD_EXP 102
54797: PUSH
54798: LD_VAR 0 2
54802: ARRAY
54803: NOT
54804: IFFALSE 54808
// continue ;
54806: GO 54790
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54808: LD_ADDR_VAR 0 7
54812: PUSH
54813: LD_EXP 102
54817: PUSH
54818: LD_VAR 0 2
54822: ARRAY
54823: PUSH
54824: LD_INT 1
54826: ARRAY
54827: PPUSH
54828: CALL 71331 0 1
54832: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54833: LD_ADDR_EXP 125
54837: PUSH
54838: LD_EXP 125
54842: PPUSH
54843: LD_VAR 0 2
54847: PPUSH
54848: LD_EXP 102
54852: PUSH
54853: LD_VAR 0 2
54857: ARRAY
54858: PUSH
54859: LD_INT 1
54861: ARRAY
54862: PPUSH
54863: CALL_OW 255
54867: PPUSH
54868: LD_EXP 127
54872: PUSH
54873: LD_VAR 0 2
54877: ARRAY
54878: PPUSH
54879: CALL 71296 0 2
54883: PPUSH
54884: CALL_OW 1
54888: ST_TO_ADDR
// if not mc_scan [ i ] then
54889: LD_EXP 125
54893: PUSH
54894: LD_VAR 0 2
54898: ARRAY
54899: NOT
54900: IFFALSE 55078
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54902: LD_ADDR_EXP 145
54906: PUSH
54907: LD_EXP 145
54911: PPUSH
54912: LD_VAR 0 2
54916: PPUSH
54917: LD_INT 0
54919: PPUSH
54920: CALL_OW 1
54924: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54925: LD_ADDR_VAR 0 4
54929: PUSH
54930: LD_EXP 102
54934: PUSH
54935: LD_VAR 0 2
54939: ARRAY
54940: PPUSH
54941: LD_INT 2
54943: PUSH
54944: LD_INT 25
54946: PUSH
54947: LD_INT 5
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: PUSH
54954: LD_INT 25
54956: PUSH
54957: LD_INT 8
54959: PUSH
54960: EMPTY
54961: LIST
54962: LIST
54963: PUSH
54964: LD_INT 25
54966: PUSH
54967: LD_INT 9
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: PUSH
54974: EMPTY
54975: LIST
54976: LIST
54977: LIST
54978: LIST
54979: PPUSH
54980: CALL_OW 72
54984: ST_TO_ADDR
// if not tmp then
54985: LD_VAR 0 4
54989: NOT
54990: IFFALSE 54994
// continue ;
54992: GO 54790
// for j in tmp do
54994: LD_ADDR_VAR 0 3
54998: PUSH
54999: LD_VAR 0 4
55003: PUSH
55004: FOR_IN
55005: IFFALSE 55076
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
55007: LD_VAR 0 3
55011: PPUSH
55012: CALL_OW 310
55016: PPUSH
55017: CALL_OW 266
55021: PUSH
55022: LD_INT 5
55024: EQUAL
55025: PUSH
55026: LD_VAR 0 3
55030: PPUSH
55031: CALL_OW 257
55035: PUSH
55036: LD_INT 1
55038: EQUAL
55039: AND
55040: PUSH
55041: LD_VAR 0 3
55045: PPUSH
55046: CALL_OW 459
55050: NOT
55051: AND
55052: PUSH
55053: LD_VAR 0 7
55057: AND
55058: IFFALSE 55074
// ComChangeProfession ( j , class ) ;
55060: LD_VAR 0 3
55064: PPUSH
55065: LD_VAR 0 7
55069: PPUSH
55070: CALL_OW 123
55074: GO 55004
55076: POP
55077: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
55078: LD_EXP 125
55082: PUSH
55083: LD_VAR 0 2
55087: ARRAY
55088: PUSH
55089: LD_EXP 145
55093: PUSH
55094: LD_VAR 0 2
55098: ARRAY
55099: NOT
55100: AND
55101: PUSH
55102: LD_EXP 124
55106: PUSH
55107: LD_VAR 0 2
55111: ARRAY
55112: NOT
55113: AND
55114: PUSH
55115: LD_EXP 102
55119: PUSH
55120: LD_VAR 0 2
55124: ARRAY
55125: PPUSH
55126: LD_INT 50
55128: PUSH
55129: EMPTY
55130: LIST
55131: PUSH
55132: LD_INT 2
55134: PUSH
55135: LD_INT 30
55137: PUSH
55138: LD_INT 32
55140: PUSH
55141: EMPTY
55142: LIST
55143: LIST
55144: PUSH
55145: LD_INT 30
55147: PUSH
55148: LD_INT 33
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: PUSH
55155: LD_INT 30
55157: PUSH
55158: LD_INT 4
55160: PUSH
55161: EMPTY
55162: LIST
55163: LIST
55164: PUSH
55165: LD_INT 30
55167: PUSH
55168: LD_INT 5
55170: PUSH
55171: EMPTY
55172: LIST
55173: LIST
55174: PUSH
55175: EMPTY
55176: LIST
55177: LIST
55178: LIST
55179: LIST
55180: LIST
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PPUSH
55186: CALL_OW 72
55190: PUSH
55191: LD_INT 4
55193: LESS
55194: PUSH
55195: LD_EXP 102
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: PPUSH
55206: LD_INT 3
55208: PUSH
55209: LD_INT 24
55211: PUSH
55212: LD_INT 1000
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: PUSH
55223: LD_INT 2
55225: PUSH
55226: LD_INT 30
55228: PUSH
55229: LD_INT 0
55231: PUSH
55232: EMPTY
55233: LIST
55234: LIST
55235: PUSH
55236: LD_INT 30
55238: PUSH
55239: LD_INT 1
55241: PUSH
55242: EMPTY
55243: LIST
55244: LIST
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: LIST
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: PPUSH
55255: CALL_OW 72
55259: OR
55260: AND
55261: IFFALSE 55512
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55263: LD_ADDR_EXP 145
55267: PUSH
55268: LD_EXP 145
55272: PPUSH
55273: LD_VAR 0 2
55277: PPUSH
55278: LD_INT 1
55280: PPUSH
55281: CALL_OW 1
55285: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55286: LD_ADDR_VAR 0 4
55290: PUSH
55291: LD_EXP 102
55295: PUSH
55296: LD_VAR 0 2
55300: ARRAY
55301: PPUSH
55302: LD_INT 2
55304: PUSH
55305: LD_INT 25
55307: PUSH
55308: LD_INT 1
55310: PUSH
55311: EMPTY
55312: LIST
55313: LIST
55314: PUSH
55315: LD_INT 25
55317: PUSH
55318: LD_INT 5
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: PUSH
55325: LD_INT 25
55327: PUSH
55328: LD_INT 8
55330: PUSH
55331: EMPTY
55332: LIST
55333: LIST
55334: PUSH
55335: LD_INT 25
55337: PUSH
55338: LD_INT 9
55340: PUSH
55341: EMPTY
55342: LIST
55343: LIST
55344: PUSH
55345: EMPTY
55346: LIST
55347: LIST
55348: LIST
55349: LIST
55350: LIST
55351: PPUSH
55352: CALL_OW 72
55356: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
55357: LD_ADDR_VAR 0 4
55361: PUSH
55362: LD_VAR 0 4
55366: PUSH
55367: LD_VAR 0 4
55371: PPUSH
55372: LD_INT 18
55374: PPUSH
55375: CALL 104805 0 2
55379: DIFF
55380: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
55381: LD_VAR 0 4
55385: NOT
55386: PUSH
55387: LD_EXP 102
55391: PUSH
55392: LD_VAR 0 2
55396: ARRAY
55397: PPUSH
55398: LD_INT 2
55400: PUSH
55401: LD_INT 30
55403: PUSH
55404: LD_INT 4
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: PUSH
55411: LD_INT 30
55413: PUSH
55414: LD_INT 5
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: EMPTY
55422: LIST
55423: LIST
55424: LIST
55425: PPUSH
55426: CALL_OW 72
55430: NOT
55431: AND
55432: IFFALSE 55494
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
55434: LD_ADDR_VAR 0 4
55438: PUSH
55439: LD_EXP 102
55443: PUSH
55444: LD_VAR 0 2
55448: ARRAY
55449: PPUSH
55450: LD_INT 2
55452: PUSH
55453: LD_INT 25
55455: PUSH
55456: LD_INT 2
55458: PUSH
55459: EMPTY
55460: LIST
55461: LIST
55462: PUSH
55463: LD_INT 25
55465: PUSH
55466: LD_INT 3
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PUSH
55473: LD_INT 25
55475: PUSH
55476: LD_INT 4
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: LIST
55487: LIST
55488: PPUSH
55489: CALL_OW 72
55493: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
55494: LD_VAR 0 2
55498: PPUSH
55499: LD_VAR 0 4
55503: PPUSH
55504: CALL 137738 0 2
// exit ;
55508: POP
55509: POP
55510: GO 55632
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
55512: LD_EXP 125
55516: PUSH
55517: LD_VAR 0 2
55521: ARRAY
55522: PUSH
55523: LD_EXP 145
55527: PUSH
55528: LD_VAR 0 2
55532: ARRAY
55533: NOT
55534: AND
55535: PUSH
55536: LD_EXP 124
55540: PUSH
55541: LD_VAR 0 2
55545: ARRAY
55546: AND
55547: IFFALSE 55628
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
55549: LD_ADDR_EXP 145
55553: PUSH
55554: LD_EXP 145
55558: PPUSH
55559: LD_VAR 0 2
55563: PPUSH
55564: LD_INT 1
55566: PPUSH
55567: CALL_OW 1
55571: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
55572: LD_ADDR_VAR 0 4
55576: PUSH
55577: LD_EXP 124
55581: PUSH
55582: LD_VAR 0 2
55586: ARRAY
55587: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55588: LD_ADDR_EXP 124
55592: PUSH
55593: LD_EXP 124
55597: PPUSH
55598: LD_VAR 0 2
55602: PPUSH
55603: EMPTY
55604: PPUSH
55605: CALL_OW 1
55609: ST_TO_ADDR
// Defend ( i , tmp ) ;
55610: LD_VAR 0 2
55614: PPUSH
55615: LD_VAR 0 4
55619: PPUSH
55620: CALL 138334 0 2
// exit ;
55624: POP
55625: POP
55626: GO 55632
// end ; end ;
55628: GO 54790
55630: POP
55631: POP
// end ;
55632: LD_VAR 0 1
55636: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
55637: LD_INT 0
55639: PPUSH
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
55644: PPUSH
55645: PPUSH
55646: PPUSH
55647: PPUSH
55648: PPUSH
55649: PPUSH
// if not mc_bases then
55650: LD_EXP 102
55654: NOT
55655: IFFALSE 55659
// exit ;
55657: GO 56746
// for i = 1 to mc_bases do
55659: LD_ADDR_VAR 0 2
55663: PUSH
55664: DOUBLE
55665: LD_INT 1
55667: DEC
55668: ST_TO_ADDR
55669: LD_EXP 102
55673: PUSH
55674: FOR_TO
55675: IFFALSE 56744
// begin tmp := mc_lab [ i ] ;
55677: LD_ADDR_VAR 0 6
55681: PUSH
55682: LD_EXP 135
55686: PUSH
55687: LD_VAR 0 2
55691: ARRAY
55692: ST_TO_ADDR
// if not tmp then
55693: LD_VAR 0 6
55697: NOT
55698: IFFALSE 55702
// continue ;
55700: GO 55674
// idle_lab := 0 ;
55702: LD_ADDR_VAR 0 11
55706: PUSH
55707: LD_INT 0
55709: ST_TO_ADDR
// for j in tmp do
55710: LD_ADDR_VAR 0 3
55714: PUSH
55715: LD_VAR 0 6
55719: PUSH
55720: FOR_IN
55721: IFFALSE 56740
// begin researching := false ;
55723: LD_ADDR_VAR 0 10
55727: PUSH
55728: LD_INT 0
55730: ST_TO_ADDR
// side := GetSide ( j ) ;
55731: LD_ADDR_VAR 0 4
55735: PUSH
55736: LD_VAR 0 3
55740: PPUSH
55741: CALL_OW 255
55745: ST_TO_ADDR
// if not mc_tech [ side ] then
55746: LD_EXP 129
55750: PUSH
55751: LD_VAR 0 4
55755: ARRAY
55756: NOT
55757: IFFALSE 55761
// continue ;
55759: GO 55720
// if BuildingStatus ( j ) = bs_idle then
55761: LD_VAR 0 3
55765: PPUSH
55766: CALL_OW 461
55770: PUSH
55771: LD_INT 2
55773: EQUAL
55774: IFFALSE 55962
// begin if idle_lab and UnitsInside ( j ) < 6 then
55776: LD_VAR 0 11
55780: PUSH
55781: LD_VAR 0 3
55785: PPUSH
55786: CALL_OW 313
55790: PUSH
55791: LD_INT 6
55793: LESS
55794: AND
55795: IFFALSE 55866
// begin tmp2 := UnitsInside ( idle_lab ) ;
55797: LD_ADDR_VAR 0 9
55801: PUSH
55802: LD_VAR 0 11
55806: PPUSH
55807: CALL_OW 313
55811: ST_TO_ADDR
// if tmp2 then
55812: LD_VAR 0 9
55816: IFFALSE 55858
// for x in tmp2 do
55818: LD_ADDR_VAR 0 7
55822: PUSH
55823: LD_VAR 0 9
55827: PUSH
55828: FOR_IN
55829: IFFALSE 55856
// begin ComExitBuilding ( x ) ;
55831: LD_VAR 0 7
55835: PPUSH
55836: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55840: LD_VAR 0 7
55844: PPUSH
55845: LD_VAR 0 3
55849: PPUSH
55850: CALL_OW 180
// end ;
55854: GO 55828
55856: POP
55857: POP
// idle_lab := 0 ;
55858: LD_ADDR_VAR 0 11
55862: PUSH
55863: LD_INT 0
55865: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55866: LD_ADDR_VAR 0 5
55870: PUSH
55871: LD_EXP 129
55875: PUSH
55876: LD_VAR 0 4
55880: ARRAY
55881: PUSH
55882: FOR_IN
55883: IFFALSE 55943
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55885: LD_VAR 0 3
55889: PPUSH
55890: LD_VAR 0 5
55894: PPUSH
55895: CALL_OW 430
55899: PUSH
55900: LD_VAR 0 4
55904: PPUSH
55905: LD_VAR 0 5
55909: PPUSH
55910: CALL 70401 0 2
55914: AND
55915: IFFALSE 55941
// begin researching := true ;
55917: LD_ADDR_VAR 0 10
55921: PUSH
55922: LD_INT 1
55924: ST_TO_ADDR
// ComResearch ( j , t ) ;
55925: LD_VAR 0 3
55929: PPUSH
55930: LD_VAR 0 5
55934: PPUSH
55935: CALL_OW 124
// break ;
55939: GO 55943
// end ;
55941: GO 55882
55943: POP
55944: POP
// if not researching then
55945: LD_VAR 0 10
55949: NOT
55950: IFFALSE 55962
// idle_lab := j ;
55952: LD_ADDR_VAR 0 11
55956: PUSH
55957: LD_VAR 0 3
55961: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55962: LD_VAR 0 3
55966: PPUSH
55967: CALL_OW 461
55971: PUSH
55972: LD_INT 10
55974: EQUAL
55975: IFFALSE 56563
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55977: LD_EXP 131
55981: PUSH
55982: LD_VAR 0 2
55986: ARRAY
55987: NOT
55988: PUSH
55989: LD_EXP 132
55993: PUSH
55994: LD_VAR 0 2
55998: ARRAY
55999: NOT
56000: AND
56001: PUSH
56002: LD_EXP 129
56006: PUSH
56007: LD_VAR 0 4
56011: ARRAY
56012: PUSH
56013: LD_INT 1
56015: GREATER
56016: AND
56017: IFFALSE 56148
// begin ComCancel ( j ) ;
56019: LD_VAR 0 3
56023: PPUSH
56024: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
56028: LD_ADDR_EXP 129
56032: PUSH
56033: LD_EXP 129
56037: PPUSH
56038: LD_VAR 0 4
56042: PPUSH
56043: LD_EXP 129
56047: PUSH
56048: LD_VAR 0 4
56052: ARRAY
56053: PPUSH
56054: LD_EXP 129
56058: PUSH
56059: LD_VAR 0 4
56063: ARRAY
56064: PUSH
56065: LD_INT 1
56067: MINUS
56068: PPUSH
56069: LD_EXP 129
56073: PUSH
56074: LD_VAR 0 4
56078: ARRAY
56079: PPUSH
56080: LD_INT 0
56082: PPUSH
56083: CALL 73925 0 4
56087: PPUSH
56088: CALL_OW 1
56092: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
56093: LD_ADDR_EXP 129
56097: PUSH
56098: LD_EXP 129
56102: PPUSH
56103: LD_VAR 0 4
56107: PPUSH
56108: LD_EXP 129
56112: PUSH
56113: LD_VAR 0 4
56117: ARRAY
56118: PPUSH
56119: LD_EXP 129
56123: PUSH
56124: LD_VAR 0 4
56128: ARRAY
56129: PPUSH
56130: LD_INT 1
56132: PPUSH
56133: LD_INT 0
56135: PPUSH
56136: CALL 73925 0 4
56140: PPUSH
56141: CALL_OW 1
56145: ST_TO_ADDR
// continue ;
56146: GO 55720
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
56148: LD_EXP 131
56152: PUSH
56153: LD_VAR 0 2
56157: ARRAY
56158: PUSH
56159: LD_EXP 132
56163: PUSH
56164: LD_VAR 0 2
56168: ARRAY
56169: NOT
56170: AND
56171: IFFALSE 56298
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
56173: LD_ADDR_EXP 132
56177: PUSH
56178: LD_EXP 132
56182: PPUSH
56183: LD_VAR 0 2
56187: PUSH
56188: LD_EXP 132
56192: PUSH
56193: LD_VAR 0 2
56197: ARRAY
56198: PUSH
56199: LD_INT 1
56201: PLUS
56202: PUSH
56203: EMPTY
56204: LIST
56205: LIST
56206: PPUSH
56207: LD_EXP 131
56211: PUSH
56212: LD_VAR 0 2
56216: ARRAY
56217: PUSH
56218: LD_INT 1
56220: ARRAY
56221: PPUSH
56222: CALL 74507 0 3
56226: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
56227: LD_EXP 131
56231: PUSH
56232: LD_VAR 0 2
56236: ARRAY
56237: PUSH
56238: LD_INT 1
56240: ARRAY
56241: PPUSH
56242: LD_INT 112
56244: PPUSH
56245: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
56249: LD_ADDR_VAR 0 9
56253: PUSH
56254: LD_EXP 131
56258: PUSH
56259: LD_VAR 0 2
56263: ARRAY
56264: PPUSH
56265: LD_INT 1
56267: PPUSH
56268: CALL_OW 3
56272: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
56273: LD_ADDR_EXP 131
56277: PUSH
56278: LD_EXP 131
56282: PPUSH
56283: LD_VAR 0 2
56287: PPUSH
56288: LD_VAR 0 9
56292: PPUSH
56293: CALL_OW 1
56297: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
56298: LD_EXP 131
56302: PUSH
56303: LD_VAR 0 2
56307: ARRAY
56308: PUSH
56309: LD_EXP 132
56313: PUSH
56314: LD_VAR 0 2
56318: ARRAY
56319: AND
56320: PUSH
56321: LD_EXP 132
56325: PUSH
56326: LD_VAR 0 2
56330: ARRAY
56331: PUSH
56332: LD_INT 1
56334: ARRAY
56335: PPUSH
56336: CALL_OW 310
56340: NOT
56341: AND
56342: PUSH
56343: LD_VAR 0 3
56347: PPUSH
56348: CALL_OW 313
56352: PUSH
56353: LD_INT 6
56355: EQUAL
56356: AND
56357: IFFALSE 56413
// begin tmp2 := UnitsInside ( j ) ;
56359: LD_ADDR_VAR 0 9
56363: PUSH
56364: LD_VAR 0 3
56368: PPUSH
56369: CALL_OW 313
56373: ST_TO_ADDR
// if tmp2 = 6 then
56374: LD_VAR 0 9
56378: PUSH
56379: LD_INT 6
56381: EQUAL
56382: IFFALSE 56413
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
56384: LD_VAR 0 9
56388: PUSH
56389: LD_INT 1
56391: ARRAY
56392: PPUSH
56393: LD_INT 112
56395: PPUSH
56396: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
56400: LD_VAR 0 9
56404: PUSH
56405: LD_INT 1
56407: ARRAY
56408: PPUSH
56409: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
56413: LD_EXP 132
56417: PUSH
56418: LD_VAR 0 2
56422: ARRAY
56423: PUSH
56424: LD_EXP 132
56428: PUSH
56429: LD_VAR 0 2
56433: ARRAY
56434: PUSH
56435: LD_INT 1
56437: ARRAY
56438: PPUSH
56439: CALL_OW 314
56443: NOT
56444: AND
56445: PUSH
56446: LD_EXP 132
56450: PUSH
56451: LD_VAR 0 2
56455: ARRAY
56456: PUSH
56457: LD_INT 1
56459: ARRAY
56460: PPUSH
56461: CALL_OW 310
56465: NOT
56466: AND
56467: IFFALSE 56493
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
56469: LD_EXP 132
56473: PUSH
56474: LD_VAR 0 2
56478: ARRAY
56479: PUSH
56480: LD_INT 1
56482: ARRAY
56483: PPUSH
56484: LD_VAR 0 3
56488: PPUSH
56489: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
56493: LD_EXP 132
56497: PUSH
56498: LD_VAR 0 2
56502: ARRAY
56503: PUSH
56504: LD_INT 1
56506: ARRAY
56507: PPUSH
56508: CALL_OW 310
56512: PUSH
56513: LD_EXP 132
56517: PUSH
56518: LD_VAR 0 2
56522: ARRAY
56523: PUSH
56524: LD_INT 1
56526: ARRAY
56527: PPUSH
56528: CALL_OW 310
56532: PPUSH
56533: CALL_OW 461
56537: PUSH
56538: LD_INT 3
56540: NONEQUAL
56541: AND
56542: IFFALSE 56563
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
56544: LD_EXP 132
56548: PUSH
56549: LD_VAR 0 2
56553: ARRAY
56554: PUSH
56555: LD_INT 1
56557: ARRAY
56558: PPUSH
56559: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
56563: LD_VAR 0 3
56567: PPUSH
56568: CALL_OW 461
56572: PUSH
56573: LD_INT 6
56575: EQUAL
56576: PUSH
56577: LD_VAR 0 6
56581: PUSH
56582: LD_INT 1
56584: GREATER
56585: AND
56586: IFFALSE 56738
// begin sci := [ ] ;
56588: LD_ADDR_VAR 0 8
56592: PUSH
56593: EMPTY
56594: ST_TO_ADDR
// for x in ( tmp diff j ) do
56595: LD_ADDR_VAR 0 7
56599: PUSH
56600: LD_VAR 0 6
56604: PUSH
56605: LD_VAR 0 3
56609: DIFF
56610: PUSH
56611: FOR_IN
56612: IFFALSE 56664
// begin if sci = 6 then
56614: LD_VAR 0 8
56618: PUSH
56619: LD_INT 6
56621: EQUAL
56622: IFFALSE 56626
// break ;
56624: GO 56664
// if BuildingStatus ( x ) = bs_idle then
56626: LD_VAR 0 7
56630: PPUSH
56631: CALL_OW 461
56635: PUSH
56636: LD_INT 2
56638: EQUAL
56639: IFFALSE 56662
// sci := sci ^ UnitsInside ( x ) ;
56641: LD_ADDR_VAR 0 8
56645: PUSH
56646: LD_VAR 0 8
56650: PUSH
56651: LD_VAR 0 7
56655: PPUSH
56656: CALL_OW 313
56660: ADD
56661: ST_TO_ADDR
// end ;
56662: GO 56611
56664: POP
56665: POP
// if not sci then
56666: LD_VAR 0 8
56670: NOT
56671: IFFALSE 56675
// continue ;
56673: GO 55720
// for x in sci do
56675: LD_ADDR_VAR 0 7
56679: PUSH
56680: LD_VAR 0 8
56684: PUSH
56685: FOR_IN
56686: IFFALSE 56736
// if IsInUnit ( x ) and not HasTask ( x ) then
56688: LD_VAR 0 7
56692: PPUSH
56693: CALL_OW 310
56697: PUSH
56698: LD_VAR 0 7
56702: PPUSH
56703: CALL_OW 314
56707: NOT
56708: AND
56709: IFFALSE 56734
// begin ComExitBuilding ( x ) ;
56711: LD_VAR 0 7
56715: PPUSH
56716: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56720: LD_VAR 0 7
56724: PPUSH
56725: LD_VAR 0 3
56729: PPUSH
56730: CALL_OW 180
// end ;
56734: GO 56685
56736: POP
56737: POP
// end ; end ;
56738: GO 55720
56740: POP
56741: POP
// end ;
56742: GO 55674
56744: POP
56745: POP
// end ;
56746: LD_VAR 0 1
56750: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56751: LD_INT 0
56753: PPUSH
56754: PPUSH
// if not mc_bases then
56755: LD_EXP 102
56759: NOT
56760: IFFALSE 56764
// exit ;
56762: GO 56845
// for i = 1 to mc_bases do
56764: LD_ADDR_VAR 0 2
56768: PUSH
56769: DOUBLE
56770: LD_INT 1
56772: DEC
56773: ST_TO_ADDR
56774: LD_EXP 102
56778: PUSH
56779: FOR_TO
56780: IFFALSE 56843
// if mc_mines [ i ] and mc_miners [ i ] then
56782: LD_EXP 115
56786: PUSH
56787: LD_VAR 0 2
56791: ARRAY
56792: PUSH
56793: LD_EXP 116
56797: PUSH
56798: LD_VAR 0 2
56802: ARRAY
56803: AND
56804: IFFALSE 56841
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56806: LD_EXP 116
56810: PUSH
56811: LD_VAR 0 2
56815: ARRAY
56816: PUSH
56817: LD_INT 1
56819: ARRAY
56820: PPUSH
56821: CALL_OW 255
56825: PPUSH
56826: LD_EXP 115
56830: PUSH
56831: LD_VAR 0 2
56835: ARRAY
56836: PPUSH
56837: CALL 71484 0 2
56841: GO 56779
56843: POP
56844: POP
// end ;
56845: LD_VAR 0 1
56849: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56850: LD_INT 0
56852: PPUSH
56853: PPUSH
56854: PPUSH
56855: PPUSH
56856: PPUSH
56857: PPUSH
56858: PPUSH
56859: PPUSH
// if not mc_bases or not mc_parking then
56860: LD_EXP 102
56864: NOT
56865: PUSH
56866: LD_EXP 126
56870: NOT
56871: OR
56872: IFFALSE 56876
// exit ;
56874: GO 57614
// for i = 1 to mc_bases do
56876: LD_ADDR_VAR 0 2
56880: PUSH
56881: DOUBLE
56882: LD_INT 1
56884: DEC
56885: ST_TO_ADDR
56886: LD_EXP 102
56890: PUSH
56891: FOR_TO
56892: IFFALSE 57612
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56894: LD_EXP 102
56898: PUSH
56899: LD_VAR 0 2
56903: ARRAY
56904: NOT
56905: PUSH
56906: LD_EXP 126
56910: PUSH
56911: LD_VAR 0 2
56915: ARRAY
56916: NOT
56917: OR
56918: IFFALSE 56922
// continue ;
56920: GO 56891
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56922: LD_ADDR_VAR 0 5
56926: PUSH
56927: LD_EXP 102
56931: PUSH
56932: LD_VAR 0 2
56936: ARRAY
56937: PUSH
56938: LD_INT 1
56940: ARRAY
56941: PPUSH
56942: CALL_OW 255
56946: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56947: LD_ADDR_VAR 0 6
56951: PUSH
56952: LD_EXP 102
56956: PUSH
56957: LD_VAR 0 2
56961: ARRAY
56962: PPUSH
56963: LD_INT 30
56965: PUSH
56966: LD_INT 3
56968: PUSH
56969: EMPTY
56970: LIST
56971: LIST
56972: PPUSH
56973: CALL_OW 72
56977: ST_TO_ADDR
// if not fac then
56978: LD_VAR 0 6
56982: NOT
56983: IFFALSE 57034
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56985: LD_ADDR_VAR 0 6
56989: PUSH
56990: LD_EXP 102
56994: PUSH
56995: LD_VAR 0 2
56999: ARRAY
57000: PPUSH
57001: LD_INT 2
57003: PUSH
57004: LD_INT 30
57006: PUSH
57007: LD_INT 0
57009: PUSH
57010: EMPTY
57011: LIST
57012: LIST
57013: PUSH
57014: LD_INT 30
57016: PUSH
57017: LD_INT 1
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: LIST
57028: PPUSH
57029: CALL_OW 72
57033: ST_TO_ADDR
// if not fac then
57034: LD_VAR 0 6
57038: NOT
57039: IFFALSE 57043
// continue ;
57041: GO 56891
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57043: LD_ADDR_VAR 0 7
57047: PUSH
57048: LD_EXP 126
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: PPUSH
57059: LD_INT 22
57061: PUSH
57062: LD_VAR 0 5
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: PUSH
57071: LD_INT 21
57073: PUSH
57074: LD_INT 2
57076: PUSH
57077: EMPTY
57078: LIST
57079: LIST
57080: PUSH
57081: LD_INT 3
57083: PUSH
57084: LD_INT 60
57086: PUSH
57087: EMPTY
57088: LIST
57089: PUSH
57090: EMPTY
57091: LIST
57092: LIST
57093: PUSH
57094: LD_INT 3
57096: PUSH
57097: LD_INT 24
57099: PUSH
57100: LD_INT 1000
57102: PUSH
57103: EMPTY
57104: LIST
57105: LIST
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 70
57121: ST_TO_ADDR
// for j in fac do
57122: LD_ADDR_VAR 0 3
57126: PUSH
57127: LD_VAR 0 6
57131: PUSH
57132: FOR_IN
57133: IFFALSE 57228
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57135: LD_ADDR_VAR 0 7
57139: PUSH
57140: LD_VAR 0 7
57144: PUSH
57145: LD_INT 22
57147: PUSH
57148: LD_VAR 0 5
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PUSH
57157: LD_INT 91
57159: PUSH
57160: LD_VAR 0 3
57164: PUSH
57165: LD_INT 15
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: LIST
57172: PUSH
57173: LD_INT 21
57175: PUSH
57176: LD_INT 2
57178: PUSH
57179: EMPTY
57180: LIST
57181: LIST
57182: PUSH
57183: LD_INT 3
57185: PUSH
57186: LD_INT 60
57188: PUSH
57189: EMPTY
57190: LIST
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: PUSH
57196: LD_INT 3
57198: PUSH
57199: LD_INT 24
57201: PUSH
57202: LD_INT 1000
57204: PUSH
57205: EMPTY
57206: LIST
57207: LIST
57208: PUSH
57209: EMPTY
57210: LIST
57211: LIST
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: LIST
57218: LIST
57219: PPUSH
57220: CALL_OW 69
57224: UNION
57225: ST_TO_ADDR
57226: GO 57132
57228: POP
57229: POP
// if not vehs then
57230: LD_VAR 0 7
57234: NOT
57235: IFFALSE 57261
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57237: LD_ADDR_EXP 114
57241: PUSH
57242: LD_EXP 114
57246: PPUSH
57247: LD_VAR 0 2
57251: PPUSH
57252: EMPTY
57253: PPUSH
57254: CALL_OW 1
57258: ST_TO_ADDR
// continue ;
57259: GO 56891
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57261: LD_ADDR_VAR 0 8
57265: PUSH
57266: LD_EXP 102
57270: PUSH
57271: LD_VAR 0 2
57275: ARRAY
57276: PPUSH
57277: LD_INT 30
57279: PUSH
57280: LD_INT 3
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: PPUSH
57287: CALL_OW 72
57291: ST_TO_ADDR
// if tmp then
57292: LD_VAR 0 8
57296: IFFALSE 57399
// begin for j in tmp do
57298: LD_ADDR_VAR 0 3
57302: PUSH
57303: LD_VAR 0 8
57307: PUSH
57308: FOR_IN
57309: IFFALSE 57397
// for k in UnitsInside ( j ) do
57311: LD_ADDR_VAR 0 4
57315: PUSH
57316: LD_VAR 0 3
57320: PPUSH
57321: CALL_OW 313
57325: PUSH
57326: FOR_IN
57327: IFFALSE 57393
// if k then
57329: LD_VAR 0 4
57333: IFFALSE 57391
// if not k in mc_repair_vehicle [ i ] then
57335: LD_VAR 0 4
57339: PUSH
57340: LD_EXP 114
57344: PUSH
57345: LD_VAR 0 2
57349: ARRAY
57350: IN
57351: NOT
57352: IFFALSE 57391
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
57354: LD_ADDR_EXP 114
57358: PUSH
57359: LD_EXP 114
57363: PPUSH
57364: LD_VAR 0 2
57368: PPUSH
57369: LD_EXP 114
57373: PUSH
57374: LD_VAR 0 2
57378: ARRAY
57379: PUSH
57380: LD_VAR 0 4
57384: UNION
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
57391: GO 57326
57393: POP
57394: POP
57395: GO 57308
57397: POP
57398: POP
// end ; if not mc_repair_vehicle [ i ] then
57399: LD_EXP 114
57403: PUSH
57404: LD_VAR 0 2
57408: ARRAY
57409: NOT
57410: IFFALSE 57414
// continue ;
57412: GO 56891
// for j in mc_repair_vehicle [ i ] do
57414: LD_ADDR_VAR 0 3
57418: PUSH
57419: LD_EXP 114
57423: PUSH
57424: LD_VAR 0 2
57428: ARRAY
57429: PUSH
57430: FOR_IN
57431: IFFALSE 57608
// begin if GetClass ( j ) <> 3 then
57433: LD_VAR 0 3
57437: PPUSH
57438: CALL_OW 257
57442: PUSH
57443: LD_INT 3
57445: NONEQUAL
57446: IFFALSE 57487
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
57448: LD_ADDR_EXP 114
57452: PUSH
57453: LD_EXP 114
57457: PPUSH
57458: LD_VAR 0 2
57462: PPUSH
57463: LD_EXP 114
57467: PUSH
57468: LD_VAR 0 2
57472: ARRAY
57473: PUSH
57474: LD_VAR 0 3
57478: DIFF
57479: PPUSH
57480: CALL_OW 1
57484: ST_TO_ADDR
// continue ;
57485: GO 57430
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
57487: LD_VAR 0 3
57491: PPUSH
57492: CALL_OW 311
57496: NOT
57497: PUSH
57498: LD_VAR 0 3
57502: PUSH
57503: LD_EXP 105
57507: PUSH
57508: LD_VAR 0 2
57512: ARRAY
57513: PUSH
57514: LD_INT 1
57516: ARRAY
57517: IN
57518: NOT
57519: AND
57520: PUSH
57521: LD_VAR 0 3
57525: PUSH
57526: LD_EXP 105
57530: PUSH
57531: LD_VAR 0 2
57535: ARRAY
57536: PUSH
57537: LD_INT 2
57539: ARRAY
57540: IN
57541: NOT
57542: AND
57543: IFFALSE 57606
// begin if IsInUnit ( j ) then
57545: LD_VAR 0 3
57549: PPUSH
57550: CALL_OW 310
57554: IFFALSE 57567
// ComExitBuilding ( j ) else
57556: LD_VAR 0 3
57560: PPUSH
57561: CALL_OW 122
57565: GO 57606
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
57567: LD_VAR 0 3
57571: PPUSH
57572: LD_VAR 0 7
57576: PUSH
57577: LD_INT 1
57579: ARRAY
57580: PPUSH
57581: CALL 109301 0 2
57585: NOT
57586: IFFALSE 57606
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
57588: LD_VAR 0 3
57592: PPUSH
57593: LD_VAR 0 7
57597: PUSH
57598: LD_INT 1
57600: ARRAY
57601: PPUSH
57602: CALL_OW 129
// end ; end ;
57606: GO 57430
57608: POP
57609: POP
// end ;
57610: GO 56891
57612: POP
57613: POP
// end ;
57614: LD_VAR 0 1
57618: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
57619: LD_INT 0
57621: PPUSH
57622: PPUSH
57623: PPUSH
57624: PPUSH
57625: PPUSH
57626: PPUSH
57627: PPUSH
57628: PPUSH
57629: PPUSH
57630: PPUSH
57631: PPUSH
// if not mc_bases then
57632: LD_EXP 102
57636: NOT
57637: IFFALSE 57641
// exit ;
57639: GO 58443
// for i = 1 to mc_bases do
57641: LD_ADDR_VAR 0 2
57645: PUSH
57646: DOUBLE
57647: LD_INT 1
57649: DEC
57650: ST_TO_ADDR
57651: LD_EXP 102
57655: PUSH
57656: FOR_TO
57657: IFFALSE 58441
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57659: LD_EXP 130
57663: PUSH
57664: LD_VAR 0 2
57668: ARRAY
57669: NOT
57670: PUSH
57671: LD_EXP 105
57675: PUSH
57676: LD_VAR 0 2
57680: ARRAY
57681: PUSH
57682: LD_INT 1
57684: ARRAY
57685: OR
57686: PUSH
57687: LD_EXP 105
57691: PUSH
57692: LD_VAR 0 2
57696: ARRAY
57697: PUSH
57698: LD_INT 2
57700: ARRAY
57701: OR
57702: PUSH
57703: LD_EXP 128
57707: PUSH
57708: LD_VAR 0 2
57712: ARRAY
57713: PPUSH
57714: LD_INT 1
57716: PPUSH
57717: CALL_OW 325
57721: NOT
57722: OR
57723: PUSH
57724: LD_EXP 125
57728: PUSH
57729: LD_VAR 0 2
57733: ARRAY
57734: OR
57735: IFFALSE 57739
// continue ;
57737: GO 57656
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57739: LD_ADDR_VAR 0 8
57743: PUSH
57744: LD_EXP 102
57748: PUSH
57749: LD_VAR 0 2
57753: ARRAY
57754: PPUSH
57755: LD_INT 25
57757: PUSH
57758: LD_INT 4
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: PUSH
57765: LD_INT 50
57767: PUSH
57768: EMPTY
57769: LIST
57770: PUSH
57771: LD_INT 3
57773: PUSH
57774: LD_INT 60
57776: PUSH
57777: EMPTY
57778: LIST
57779: PUSH
57780: EMPTY
57781: LIST
57782: LIST
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: LIST
57788: PPUSH
57789: CALL_OW 72
57793: PUSH
57794: LD_EXP 106
57798: PUSH
57799: LD_VAR 0 2
57803: ARRAY
57804: DIFF
57805: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57806: LD_ADDR_VAR 0 9
57810: PUSH
57811: LD_EXP 102
57815: PUSH
57816: LD_VAR 0 2
57820: ARRAY
57821: PPUSH
57822: LD_INT 2
57824: PUSH
57825: LD_INT 30
57827: PUSH
57828: LD_INT 0
57830: PUSH
57831: EMPTY
57832: LIST
57833: LIST
57834: PUSH
57835: LD_INT 30
57837: PUSH
57838: LD_INT 1
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: EMPTY
57846: LIST
57847: LIST
57848: LIST
57849: PPUSH
57850: CALL_OW 72
57854: ST_TO_ADDR
// if not tmp or not dep then
57855: LD_VAR 0 8
57859: NOT
57860: PUSH
57861: LD_VAR 0 9
57865: NOT
57866: OR
57867: IFFALSE 57871
// continue ;
57869: GO 57656
// side := GetSide ( tmp [ 1 ] ) ;
57871: LD_ADDR_VAR 0 11
57875: PUSH
57876: LD_VAR 0 8
57880: PUSH
57881: LD_INT 1
57883: ARRAY
57884: PPUSH
57885: CALL_OW 255
57889: ST_TO_ADDR
// dep := dep [ 1 ] ;
57890: LD_ADDR_VAR 0 9
57894: PUSH
57895: LD_VAR 0 9
57899: PUSH
57900: LD_INT 1
57902: ARRAY
57903: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57904: LD_ADDR_VAR 0 7
57908: PUSH
57909: LD_EXP 130
57913: PUSH
57914: LD_VAR 0 2
57918: ARRAY
57919: PPUSH
57920: LD_INT 22
57922: PUSH
57923: LD_INT 0
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: PUSH
57930: LD_INT 25
57932: PUSH
57933: LD_INT 12
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: EMPTY
57941: LIST
57942: LIST
57943: PPUSH
57944: CALL_OW 70
57948: PUSH
57949: LD_INT 22
57951: PUSH
57952: LD_INT 0
57954: PUSH
57955: EMPTY
57956: LIST
57957: LIST
57958: PUSH
57959: LD_INT 25
57961: PUSH
57962: LD_INT 12
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: LD_INT 91
57971: PUSH
57972: LD_VAR 0 9
57976: PUSH
57977: LD_INT 20
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: LIST
57984: PUSH
57985: EMPTY
57986: LIST
57987: LIST
57988: LIST
57989: PPUSH
57990: CALL_OW 69
57994: UNION
57995: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57996: LD_ADDR_VAR 0 10
58000: PUSH
58001: LD_EXP 130
58005: PUSH
58006: LD_VAR 0 2
58010: ARRAY
58011: PPUSH
58012: LD_INT 81
58014: PUSH
58015: LD_VAR 0 11
58019: PUSH
58020: EMPTY
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 70
58028: ST_TO_ADDR
// if not apes or danger_at_area then
58029: LD_VAR 0 7
58033: NOT
58034: PUSH
58035: LD_VAR 0 10
58039: OR
58040: IFFALSE 58090
// begin if mc_taming [ i ] then
58042: LD_EXP 133
58046: PUSH
58047: LD_VAR 0 2
58051: ARRAY
58052: IFFALSE 58088
// begin MC_Reset ( i , 121 ) ;
58054: LD_VAR 0 2
58058: PPUSH
58059: LD_INT 121
58061: PPUSH
58062: CALL 43006 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58066: LD_ADDR_EXP 133
58070: PUSH
58071: LD_EXP 133
58075: PPUSH
58076: LD_VAR 0 2
58080: PPUSH
58081: EMPTY
58082: PPUSH
58083: CALL_OW 1
58087: ST_TO_ADDR
// end ; continue ;
58088: GO 57656
// end ; for j in tmp do
58090: LD_ADDR_VAR 0 3
58094: PUSH
58095: LD_VAR 0 8
58099: PUSH
58100: FOR_IN
58101: IFFALSE 58437
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
58103: LD_VAR 0 3
58107: PUSH
58108: LD_EXP 133
58112: PUSH
58113: LD_VAR 0 2
58117: ARRAY
58118: IN
58119: NOT
58120: PUSH
58121: LD_EXP 133
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: PUSH
58132: LD_INT 3
58134: LESS
58135: AND
58136: IFFALSE 58194
// begin SetTag ( j , 121 ) ;
58138: LD_VAR 0 3
58142: PPUSH
58143: LD_INT 121
58145: PPUSH
58146: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
58150: LD_ADDR_EXP 133
58154: PUSH
58155: LD_EXP 133
58159: PPUSH
58160: LD_VAR 0 2
58164: PUSH
58165: LD_EXP 133
58169: PUSH
58170: LD_VAR 0 2
58174: ARRAY
58175: PUSH
58176: LD_INT 1
58178: PLUS
58179: PUSH
58180: EMPTY
58181: LIST
58182: LIST
58183: PPUSH
58184: LD_VAR 0 3
58188: PPUSH
58189: CALL 74507 0 3
58193: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
58194: LD_VAR 0 3
58198: PUSH
58199: LD_EXP 133
58203: PUSH
58204: LD_VAR 0 2
58208: ARRAY
58209: IN
58210: IFFALSE 58435
// begin if GetClass ( j ) <> 4 then
58212: LD_VAR 0 3
58216: PPUSH
58217: CALL_OW 257
58221: PUSH
58222: LD_INT 4
58224: NONEQUAL
58225: IFFALSE 58278
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
58227: LD_ADDR_EXP 133
58231: PUSH
58232: LD_EXP 133
58236: PPUSH
58237: LD_VAR 0 2
58241: PPUSH
58242: LD_EXP 133
58246: PUSH
58247: LD_VAR 0 2
58251: ARRAY
58252: PUSH
58253: LD_VAR 0 3
58257: DIFF
58258: PPUSH
58259: CALL_OW 1
58263: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58264: LD_VAR 0 3
58268: PPUSH
58269: LD_INT 0
58271: PPUSH
58272: CALL_OW 109
// continue ;
58276: GO 58100
// end ; if IsInUnit ( j ) then
58278: LD_VAR 0 3
58282: PPUSH
58283: CALL_OW 310
58287: IFFALSE 58298
// ComExitBuilding ( j ) ;
58289: LD_VAR 0 3
58293: PPUSH
58294: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
58298: LD_ADDR_VAR 0 6
58302: PUSH
58303: LD_VAR 0 7
58307: PPUSH
58308: LD_VAR 0 3
58312: PPUSH
58313: CALL_OW 74
58317: ST_TO_ADDR
// if not ape then
58318: LD_VAR 0 6
58322: NOT
58323: IFFALSE 58327
// break ;
58325: GO 58437
// x := GetX ( ape ) ;
58327: LD_ADDR_VAR 0 4
58331: PUSH
58332: LD_VAR 0 6
58336: PPUSH
58337: CALL_OW 250
58341: ST_TO_ADDR
// y := GetY ( ape ) ;
58342: LD_ADDR_VAR 0 5
58346: PUSH
58347: LD_VAR 0 6
58351: PPUSH
58352: CALL_OW 251
58356: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
58357: LD_VAR 0 4
58361: PPUSH
58362: LD_VAR 0 5
58366: PPUSH
58367: CALL_OW 488
58371: NOT
58372: PUSH
58373: LD_VAR 0 11
58377: PPUSH
58378: LD_VAR 0 4
58382: PPUSH
58383: LD_VAR 0 5
58387: PPUSH
58388: LD_INT 20
58390: PPUSH
58391: CALL 75771 0 4
58395: PUSH
58396: LD_INT 4
58398: ARRAY
58399: OR
58400: IFFALSE 58404
// break ;
58402: GO 58437
// if not HasTask ( j ) then
58404: LD_VAR 0 3
58408: PPUSH
58409: CALL_OW 314
58413: NOT
58414: IFFALSE 58435
// ComTameXY ( j , x , y ) ;
58416: LD_VAR 0 3
58420: PPUSH
58421: LD_VAR 0 4
58425: PPUSH
58426: LD_VAR 0 5
58430: PPUSH
58431: CALL_OW 131
// end ; end ;
58435: GO 58100
58437: POP
58438: POP
// end ;
58439: GO 57656
58441: POP
58442: POP
// end ;
58443: LD_VAR 0 1
58447: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
58448: LD_INT 0
58450: PPUSH
58451: PPUSH
58452: PPUSH
58453: PPUSH
58454: PPUSH
58455: PPUSH
58456: PPUSH
58457: PPUSH
// if not mc_bases then
58458: LD_EXP 102
58462: NOT
58463: IFFALSE 58467
// exit ;
58465: GO 59093
// for i = 1 to mc_bases do
58467: LD_ADDR_VAR 0 2
58471: PUSH
58472: DOUBLE
58473: LD_INT 1
58475: DEC
58476: ST_TO_ADDR
58477: LD_EXP 102
58481: PUSH
58482: FOR_TO
58483: IFFALSE 59091
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
58485: LD_EXP 131
58489: PUSH
58490: LD_VAR 0 2
58494: ARRAY
58495: NOT
58496: PUSH
58497: LD_EXP 131
58501: PUSH
58502: LD_VAR 0 2
58506: ARRAY
58507: PPUSH
58508: LD_INT 25
58510: PUSH
58511: LD_INT 12
58513: PUSH
58514: EMPTY
58515: LIST
58516: LIST
58517: PPUSH
58518: CALL_OW 72
58522: NOT
58523: OR
58524: IFFALSE 58528
// continue ;
58526: GO 58482
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
58528: LD_ADDR_VAR 0 5
58532: PUSH
58533: LD_EXP 131
58537: PUSH
58538: LD_VAR 0 2
58542: ARRAY
58543: PUSH
58544: LD_INT 1
58546: ARRAY
58547: PPUSH
58548: CALL_OW 255
58552: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
58553: LD_VAR 0 5
58557: PPUSH
58558: LD_INT 2
58560: PPUSH
58561: CALL_OW 325
58565: IFFALSE 58818
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58567: LD_ADDR_VAR 0 4
58571: PUSH
58572: LD_EXP 131
58576: PUSH
58577: LD_VAR 0 2
58581: ARRAY
58582: PPUSH
58583: LD_INT 25
58585: PUSH
58586: LD_INT 16
58588: PUSH
58589: EMPTY
58590: LIST
58591: LIST
58592: PPUSH
58593: CALL_OW 72
58597: ST_TO_ADDR
// if tmp < 6 then
58598: LD_VAR 0 4
58602: PUSH
58603: LD_INT 6
58605: LESS
58606: IFFALSE 58818
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58608: LD_ADDR_VAR 0 6
58612: PUSH
58613: LD_EXP 102
58617: PUSH
58618: LD_VAR 0 2
58622: ARRAY
58623: PPUSH
58624: LD_INT 2
58626: PUSH
58627: LD_INT 30
58629: PUSH
58630: LD_INT 0
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: PUSH
58637: LD_INT 30
58639: PUSH
58640: LD_INT 1
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PUSH
58647: EMPTY
58648: LIST
58649: LIST
58650: LIST
58651: PPUSH
58652: CALL_OW 72
58656: ST_TO_ADDR
// if depot then
58657: LD_VAR 0 6
58661: IFFALSE 58818
// begin selected := 0 ;
58663: LD_ADDR_VAR 0 7
58667: PUSH
58668: LD_INT 0
58670: ST_TO_ADDR
// for j in depot do
58671: LD_ADDR_VAR 0 3
58675: PUSH
58676: LD_VAR 0 6
58680: PUSH
58681: FOR_IN
58682: IFFALSE 58713
// begin if UnitsInside ( j ) < 6 then
58684: LD_VAR 0 3
58688: PPUSH
58689: CALL_OW 313
58693: PUSH
58694: LD_INT 6
58696: LESS
58697: IFFALSE 58711
// begin selected := j ;
58699: LD_ADDR_VAR 0 7
58703: PUSH
58704: LD_VAR 0 3
58708: ST_TO_ADDR
// break ;
58709: GO 58713
// end ; end ;
58711: GO 58681
58713: POP
58714: POP
// if selected then
58715: LD_VAR 0 7
58719: IFFALSE 58818
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58721: LD_ADDR_VAR 0 3
58725: PUSH
58726: LD_EXP 131
58730: PUSH
58731: LD_VAR 0 2
58735: ARRAY
58736: PPUSH
58737: LD_INT 25
58739: PUSH
58740: LD_INT 12
58742: PUSH
58743: EMPTY
58744: LIST
58745: LIST
58746: PPUSH
58747: CALL_OW 72
58751: PUSH
58752: FOR_IN
58753: IFFALSE 58816
// if not HasTask ( j ) then
58755: LD_VAR 0 3
58759: PPUSH
58760: CALL_OW 314
58764: NOT
58765: IFFALSE 58814
// begin if not IsInUnit ( j ) then
58767: LD_VAR 0 3
58771: PPUSH
58772: CALL_OW 310
58776: NOT
58777: IFFALSE 58793
// ComEnterUnit ( j , selected ) ;
58779: LD_VAR 0 3
58783: PPUSH
58784: LD_VAR 0 7
58788: PPUSH
58789: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58793: LD_VAR 0 3
58797: PPUSH
58798: LD_INT 16
58800: PPUSH
58801: CALL_OW 183
// AddComExitBuilding ( j ) ;
58805: LD_VAR 0 3
58809: PPUSH
58810: CALL_OW 182
// end ;
58814: GO 58752
58816: POP
58817: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58818: LD_VAR 0 5
58822: PPUSH
58823: LD_INT 11
58825: PPUSH
58826: CALL_OW 325
58830: IFFALSE 59089
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58832: LD_ADDR_VAR 0 4
58836: PUSH
58837: LD_EXP 131
58841: PUSH
58842: LD_VAR 0 2
58846: ARRAY
58847: PPUSH
58848: LD_INT 25
58850: PUSH
58851: LD_INT 16
58853: PUSH
58854: EMPTY
58855: LIST
58856: LIST
58857: PPUSH
58858: CALL_OW 72
58862: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58863: LD_VAR 0 4
58867: PUSH
58868: LD_INT 6
58870: GREATEREQUAL
58871: PUSH
58872: LD_VAR 0 5
58876: PPUSH
58877: LD_INT 2
58879: PPUSH
58880: CALL_OW 325
58884: NOT
58885: OR
58886: IFFALSE 59089
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58888: LD_ADDR_VAR 0 8
58892: PUSH
58893: LD_EXP 102
58897: PUSH
58898: LD_VAR 0 2
58902: ARRAY
58903: PPUSH
58904: LD_INT 2
58906: PUSH
58907: LD_INT 30
58909: PUSH
58910: LD_INT 4
58912: PUSH
58913: EMPTY
58914: LIST
58915: LIST
58916: PUSH
58917: LD_INT 30
58919: PUSH
58920: LD_INT 5
58922: PUSH
58923: EMPTY
58924: LIST
58925: LIST
58926: PUSH
58927: EMPTY
58928: LIST
58929: LIST
58930: LIST
58931: PPUSH
58932: CALL_OW 72
58936: ST_TO_ADDR
// if barracks then
58937: LD_VAR 0 8
58941: IFFALSE 59089
// begin selected := 0 ;
58943: LD_ADDR_VAR 0 7
58947: PUSH
58948: LD_INT 0
58950: ST_TO_ADDR
// for j in barracks do
58951: LD_ADDR_VAR 0 3
58955: PUSH
58956: LD_VAR 0 8
58960: PUSH
58961: FOR_IN
58962: IFFALSE 58993
// begin if UnitsInside ( j ) < 6 then
58964: LD_VAR 0 3
58968: PPUSH
58969: CALL_OW 313
58973: PUSH
58974: LD_INT 6
58976: LESS
58977: IFFALSE 58991
// begin selected := j ;
58979: LD_ADDR_VAR 0 7
58983: PUSH
58984: LD_VAR 0 3
58988: ST_TO_ADDR
// break ;
58989: GO 58993
// end ; end ;
58991: GO 58961
58993: POP
58994: POP
// if selected then
58995: LD_VAR 0 7
58999: IFFALSE 59089
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59001: LD_ADDR_VAR 0 3
59005: PUSH
59006: LD_EXP 131
59010: PUSH
59011: LD_VAR 0 2
59015: ARRAY
59016: PPUSH
59017: LD_INT 25
59019: PUSH
59020: LD_INT 12
59022: PUSH
59023: EMPTY
59024: LIST
59025: LIST
59026: PPUSH
59027: CALL_OW 72
59031: PUSH
59032: FOR_IN
59033: IFFALSE 59087
// if not IsInUnit ( j ) and not HasTask ( j ) then
59035: LD_VAR 0 3
59039: PPUSH
59040: CALL_OW 310
59044: NOT
59045: PUSH
59046: LD_VAR 0 3
59050: PPUSH
59051: CALL_OW 314
59055: NOT
59056: AND
59057: IFFALSE 59085
// begin ComEnterUnit ( j , selected ) ;
59059: LD_VAR 0 3
59063: PPUSH
59064: LD_VAR 0 7
59068: PPUSH
59069: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
59073: LD_VAR 0 3
59077: PPUSH
59078: LD_INT 15
59080: PPUSH
59081: CALL_OW 183
// end ;
59085: GO 59032
59087: POP
59088: POP
// end ; end ; end ; end ; end ;
59089: GO 58482
59091: POP
59092: POP
// end ;
59093: LD_VAR 0 1
59097: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
59098: LD_INT 0
59100: PPUSH
59101: PPUSH
59102: PPUSH
59103: PPUSH
// if not mc_bases then
59104: LD_EXP 102
59108: NOT
59109: IFFALSE 59113
// exit ;
59111: GO 59291
// for i = 1 to mc_bases do
59113: LD_ADDR_VAR 0 2
59117: PUSH
59118: DOUBLE
59119: LD_INT 1
59121: DEC
59122: ST_TO_ADDR
59123: LD_EXP 102
59127: PUSH
59128: FOR_TO
59129: IFFALSE 59289
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
59131: LD_ADDR_VAR 0 4
59135: PUSH
59136: LD_EXP 102
59140: PUSH
59141: LD_VAR 0 2
59145: ARRAY
59146: PPUSH
59147: LD_INT 25
59149: PUSH
59150: LD_INT 9
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PPUSH
59157: CALL_OW 72
59161: ST_TO_ADDR
// if not tmp then
59162: LD_VAR 0 4
59166: NOT
59167: IFFALSE 59171
// continue ;
59169: GO 59128
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
59171: LD_EXP 128
59175: PUSH
59176: LD_VAR 0 2
59180: ARRAY
59181: PPUSH
59182: LD_INT 29
59184: PPUSH
59185: CALL_OW 325
59189: NOT
59190: PUSH
59191: LD_EXP 128
59195: PUSH
59196: LD_VAR 0 2
59200: ARRAY
59201: PPUSH
59202: LD_INT 28
59204: PPUSH
59205: CALL_OW 325
59209: NOT
59210: AND
59211: IFFALSE 59215
// continue ;
59213: GO 59128
// for j in tmp do
59215: LD_ADDR_VAR 0 3
59219: PUSH
59220: LD_VAR 0 4
59224: PUSH
59225: FOR_IN
59226: IFFALSE 59285
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59228: LD_VAR 0 3
59232: PUSH
59233: LD_EXP 105
59237: PUSH
59238: LD_VAR 0 2
59242: ARRAY
59243: PUSH
59244: LD_INT 1
59246: ARRAY
59247: IN
59248: NOT
59249: PUSH
59250: LD_VAR 0 3
59254: PUSH
59255: LD_EXP 105
59259: PUSH
59260: LD_VAR 0 2
59264: ARRAY
59265: PUSH
59266: LD_INT 2
59268: ARRAY
59269: IN
59270: NOT
59271: AND
59272: IFFALSE 59283
// ComSpaceTimeShoot ( j ) ;
59274: LD_VAR 0 3
59278: PPUSH
59279: CALL 70492 0 1
59283: GO 59225
59285: POP
59286: POP
// end ;
59287: GO 59128
59289: POP
59290: POP
// end ;
59291: LD_VAR 0 1
59295: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
59301: PPUSH
59302: PPUSH
59303: PPUSH
59304: PPUSH
59305: PPUSH
59306: PPUSH
// if not mc_bases then
59307: LD_EXP 102
59311: NOT
59312: IFFALSE 59316
// exit ;
59314: GO 59938
// for i = 1 to mc_bases do
59316: LD_ADDR_VAR 0 2
59320: PUSH
59321: DOUBLE
59322: LD_INT 1
59324: DEC
59325: ST_TO_ADDR
59326: LD_EXP 102
59330: PUSH
59331: FOR_TO
59332: IFFALSE 59936
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
59334: LD_EXP 137
59338: PUSH
59339: LD_VAR 0 2
59343: ARRAY
59344: NOT
59345: PUSH
59346: LD_INT 38
59348: PPUSH
59349: LD_EXP 128
59353: PUSH
59354: LD_VAR 0 2
59358: ARRAY
59359: PPUSH
59360: CALL_OW 321
59364: PUSH
59365: LD_INT 2
59367: NONEQUAL
59368: OR
59369: IFFALSE 59373
// continue ;
59371: GO 59331
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
59373: LD_ADDR_VAR 0 8
59377: PUSH
59378: LD_EXP 102
59382: PUSH
59383: LD_VAR 0 2
59387: ARRAY
59388: PPUSH
59389: LD_INT 30
59391: PUSH
59392: LD_INT 34
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PPUSH
59399: CALL_OW 72
59403: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
59404: LD_ADDR_VAR 0 9
59408: PUSH
59409: LD_EXP 102
59413: PUSH
59414: LD_VAR 0 2
59418: ARRAY
59419: PPUSH
59420: LD_INT 25
59422: PUSH
59423: LD_INT 4
59425: PUSH
59426: EMPTY
59427: LIST
59428: LIST
59429: PPUSH
59430: CALL_OW 72
59434: PPUSH
59435: LD_INT 0
59437: PPUSH
59438: CALL 104805 0 2
59442: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
59443: LD_VAR 0 9
59447: NOT
59448: PUSH
59449: LD_VAR 0 8
59453: NOT
59454: OR
59455: PUSH
59456: LD_EXP 102
59460: PUSH
59461: LD_VAR 0 2
59465: ARRAY
59466: PPUSH
59467: LD_INT 124
59469: PPUSH
59470: CALL 104805 0 2
59474: OR
59475: IFFALSE 59479
// continue ;
59477: GO 59331
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
59479: LD_EXP 138
59483: PUSH
59484: LD_VAR 0 2
59488: ARRAY
59489: PUSH
59490: LD_EXP 137
59494: PUSH
59495: LD_VAR 0 2
59499: ARRAY
59500: LESS
59501: PUSH
59502: LD_EXP 138
59506: PUSH
59507: LD_VAR 0 2
59511: ARRAY
59512: PUSH
59513: LD_VAR 0 8
59517: LESS
59518: AND
59519: IFFALSE 59934
// begin tmp := sci [ 1 ] ;
59521: LD_ADDR_VAR 0 7
59525: PUSH
59526: LD_VAR 0 9
59530: PUSH
59531: LD_INT 1
59533: ARRAY
59534: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
59535: LD_VAR 0 7
59539: PPUSH
59540: LD_INT 124
59542: PPUSH
59543: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
59547: LD_ADDR_VAR 0 3
59551: PUSH
59552: DOUBLE
59553: LD_EXP 137
59557: PUSH
59558: LD_VAR 0 2
59562: ARRAY
59563: INC
59564: ST_TO_ADDR
59565: LD_EXP 137
59569: PUSH
59570: LD_VAR 0 2
59574: ARRAY
59575: PUSH
59576: FOR_DOWNTO
59577: IFFALSE 59920
// begin if IsInUnit ( tmp ) then
59579: LD_VAR 0 7
59583: PPUSH
59584: CALL_OW 310
59588: IFFALSE 59599
// ComExitBuilding ( tmp ) ;
59590: LD_VAR 0 7
59594: PPUSH
59595: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
59599: LD_INT 35
59601: PPUSH
59602: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
59606: LD_VAR 0 7
59610: PPUSH
59611: CALL_OW 310
59615: NOT
59616: PUSH
59617: LD_VAR 0 7
59621: PPUSH
59622: CALL_OW 314
59626: NOT
59627: AND
59628: IFFALSE 59599
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
59630: LD_ADDR_VAR 0 6
59634: PUSH
59635: LD_VAR 0 7
59639: PPUSH
59640: CALL_OW 250
59644: PUSH
59645: LD_VAR 0 7
59649: PPUSH
59650: CALL_OW 251
59654: PUSH
59655: EMPTY
59656: LIST
59657: LIST
59658: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59659: LD_INT 35
59661: PPUSH
59662: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59666: LD_ADDR_VAR 0 4
59670: PUSH
59671: LD_EXP 137
59675: PUSH
59676: LD_VAR 0 2
59680: ARRAY
59681: PUSH
59682: LD_VAR 0 3
59686: ARRAY
59687: PUSH
59688: LD_INT 1
59690: ARRAY
59691: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59692: LD_ADDR_VAR 0 5
59696: PUSH
59697: LD_EXP 137
59701: PUSH
59702: LD_VAR 0 2
59706: ARRAY
59707: PUSH
59708: LD_VAR 0 3
59712: ARRAY
59713: PUSH
59714: LD_INT 2
59716: ARRAY
59717: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59718: LD_VAR 0 7
59722: PPUSH
59723: LD_INT 10
59725: PPUSH
59726: CALL 77472 0 2
59730: PUSH
59731: LD_INT 4
59733: ARRAY
59734: IFFALSE 59772
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59736: LD_VAR 0 7
59740: PPUSH
59741: LD_VAR 0 6
59745: PUSH
59746: LD_INT 1
59748: ARRAY
59749: PPUSH
59750: LD_VAR 0 6
59754: PUSH
59755: LD_INT 2
59757: ARRAY
59758: PPUSH
59759: CALL_OW 111
// wait ( 0 0$10 ) ;
59763: LD_INT 350
59765: PPUSH
59766: CALL_OW 67
// end else
59770: GO 59798
// begin ComMoveXY ( tmp , x , y ) ;
59772: LD_VAR 0 7
59776: PPUSH
59777: LD_VAR 0 4
59781: PPUSH
59782: LD_VAR 0 5
59786: PPUSH
59787: CALL_OW 111
// wait ( 0 0$3 ) ;
59791: LD_INT 105
59793: PPUSH
59794: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59798: LD_VAR 0 7
59802: PPUSH
59803: LD_VAR 0 4
59807: PPUSH
59808: LD_VAR 0 5
59812: PPUSH
59813: CALL_OW 307
59817: IFFALSE 59659
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59819: LD_VAR 0 7
59823: PPUSH
59824: LD_VAR 0 4
59828: PPUSH
59829: LD_VAR 0 5
59833: PPUSH
59834: LD_VAR 0 8
59838: PUSH
59839: LD_VAR 0 3
59843: ARRAY
59844: PPUSH
59845: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59849: LD_INT 35
59851: PPUSH
59852: CALL_OW 67
// until not HasTask ( tmp ) ;
59856: LD_VAR 0 7
59860: PPUSH
59861: CALL_OW 314
59865: NOT
59866: IFFALSE 59849
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59868: LD_ADDR_EXP 138
59872: PUSH
59873: LD_EXP 138
59877: PPUSH
59878: LD_VAR 0 2
59882: PUSH
59883: LD_EXP 138
59887: PUSH
59888: LD_VAR 0 2
59892: ARRAY
59893: PUSH
59894: LD_INT 1
59896: PLUS
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: PPUSH
59902: LD_VAR 0 8
59906: PUSH
59907: LD_VAR 0 3
59911: ARRAY
59912: PPUSH
59913: CALL 74507 0 3
59917: ST_TO_ADDR
// end ;
59918: GO 59576
59920: POP
59921: POP
// MC_Reset ( i , 124 ) ;
59922: LD_VAR 0 2
59926: PPUSH
59927: LD_INT 124
59929: PPUSH
59930: CALL 43006 0 2
// end ; end ;
59934: GO 59331
59936: POP
59937: POP
// end ;
59938: LD_VAR 0 1
59942: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59943: LD_INT 0
59945: PPUSH
59946: PPUSH
59947: PPUSH
// if not mc_bases then
59948: LD_EXP 102
59952: NOT
59953: IFFALSE 59957
// exit ;
59955: GO 60563
// for i = 1 to mc_bases do
59957: LD_ADDR_VAR 0 2
59961: PUSH
59962: DOUBLE
59963: LD_INT 1
59965: DEC
59966: ST_TO_ADDR
59967: LD_EXP 102
59971: PUSH
59972: FOR_TO
59973: IFFALSE 60561
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59975: LD_ADDR_VAR 0 3
59979: PUSH
59980: LD_EXP 102
59984: PUSH
59985: LD_VAR 0 2
59989: ARRAY
59990: PPUSH
59991: LD_INT 25
59993: PUSH
59994: LD_INT 4
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: PPUSH
60001: CALL_OW 72
60005: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60006: LD_VAR 0 3
60010: NOT
60011: PUSH
60012: LD_EXP 139
60016: PUSH
60017: LD_VAR 0 2
60021: ARRAY
60022: NOT
60023: OR
60024: PUSH
60025: LD_EXP 102
60029: PUSH
60030: LD_VAR 0 2
60034: ARRAY
60035: PPUSH
60036: LD_INT 2
60038: PUSH
60039: LD_INT 30
60041: PUSH
60042: LD_INT 0
60044: PUSH
60045: EMPTY
60046: LIST
60047: LIST
60048: PUSH
60049: LD_INT 30
60051: PUSH
60052: LD_INT 1
60054: PUSH
60055: EMPTY
60056: LIST
60057: LIST
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: LIST
60063: PPUSH
60064: CALL_OW 72
60068: NOT
60069: OR
60070: IFFALSE 60120
// begin if mc_deposits_finder [ i ] then
60072: LD_EXP 140
60076: PUSH
60077: LD_VAR 0 2
60081: ARRAY
60082: IFFALSE 60118
// begin MC_Reset ( i , 125 ) ;
60084: LD_VAR 0 2
60088: PPUSH
60089: LD_INT 125
60091: PPUSH
60092: CALL 43006 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60096: LD_ADDR_EXP 140
60100: PUSH
60101: LD_EXP 140
60105: PPUSH
60106: LD_VAR 0 2
60110: PPUSH
60111: EMPTY
60112: PPUSH
60113: CALL_OW 1
60117: ST_TO_ADDR
// end ; continue ;
60118: GO 59972
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
60120: LD_EXP 139
60124: PUSH
60125: LD_VAR 0 2
60129: ARRAY
60130: PUSH
60131: LD_INT 1
60133: ARRAY
60134: PUSH
60135: LD_INT 3
60137: ARRAY
60138: PUSH
60139: LD_INT 1
60141: EQUAL
60142: PUSH
60143: LD_INT 20
60145: PPUSH
60146: LD_EXP 128
60150: PUSH
60151: LD_VAR 0 2
60155: ARRAY
60156: PPUSH
60157: CALL_OW 321
60161: PUSH
60162: LD_INT 2
60164: NONEQUAL
60165: AND
60166: IFFALSE 60216
// begin if mc_deposits_finder [ i ] then
60168: LD_EXP 140
60172: PUSH
60173: LD_VAR 0 2
60177: ARRAY
60178: IFFALSE 60214
// begin MC_Reset ( i , 125 ) ;
60180: LD_VAR 0 2
60184: PPUSH
60185: LD_INT 125
60187: PPUSH
60188: CALL 43006 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60192: LD_ADDR_EXP 140
60196: PUSH
60197: LD_EXP 140
60201: PPUSH
60202: LD_VAR 0 2
60206: PPUSH
60207: EMPTY
60208: PPUSH
60209: CALL_OW 1
60213: ST_TO_ADDR
// end ; continue ;
60214: GO 59972
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
60216: LD_EXP 139
60220: PUSH
60221: LD_VAR 0 2
60225: ARRAY
60226: PUSH
60227: LD_INT 1
60229: ARRAY
60230: PUSH
60231: LD_INT 1
60233: ARRAY
60234: PPUSH
60235: LD_EXP 139
60239: PUSH
60240: LD_VAR 0 2
60244: ARRAY
60245: PUSH
60246: LD_INT 1
60248: ARRAY
60249: PUSH
60250: LD_INT 2
60252: ARRAY
60253: PPUSH
60254: LD_EXP 128
60258: PUSH
60259: LD_VAR 0 2
60263: ARRAY
60264: PPUSH
60265: CALL_OW 440
60269: IFFALSE 60312
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
60271: LD_ADDR_EXP 139
60275: PUSH
60276: LD_EXP 139
60280: PPUSH
60281: LD_VAR 0 2
60285: PPUSH
60286: LD_EXP 139
60290: PUSH
60291: LD_VAR 0 2
60295: ARRAY
60296: PPUSH
60297: LD_INT 1
60299: PPUSH
60300: CALL_OW 3
60304: PPUSH
60305: CALL_OW 1
60309: ST_TO_ADDR
60310: GO 60559
// begin if not mc_deposits_finder [ i ] then
60312: LD_EXP 140
60316: PUSH
60317: LD_VAR 0 2
60321: ARRAY
60322: NOT
60323: IFFALSE 60375
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
60325: LD_ADDR_EXP 140
60329: PUSH
60330: LD_EXP 140
60334: PPUSH
60335: LD_VAR 0 2
60339: PPUSH
60340: LD_VAR 0 3
60344: PUSH
60345: LD_INT 1
60347: ARRAY
60348: PUSH
60349: EMPTY
60350: LIST
60351: PPUSH
60352: CALL_OW 1
60356: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
60357: LD_VAR 0 3
60361: PUSH
60362: LD_INT 1
60364: ARRAY
60365: PPUSH
60366: LD_INT 125
60368: PPUSH
60369: CALL_OW 109
// end else
60373: GO 60559
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
60375: LD_EXP 140
60379: PUSH
60380: LD_VAR 0 2
60384: ARRAY
60385: PUSH
60386: LD_INT 1
60388: ARRAY
60389: PPUSH
60390: CALL_OW 310
60394: IFFALSE 60417
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
60396: LD_EXP 140
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: PUSH
60407: LD_INT 1
60409: ARRAY
60410: PPUSH
60411: CALL_OW 122
60415: GO 60559
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
60417: LD_EXP 140
60421: PUSH
60422: LD_VAR 0 2
60426: ARRAY
60427: PUSH
60428: LD_INT 1
60430: ARRAY
60431: PPUSH
60432: CALL_OW 314
60436: NOT
60437: PUSH
60438: LD_EXP 140
60442: PUSH
60443: LD_VAR 0 2
60447: ARRAY
60448: PUSH
60449: LD_INT 1
60451: ARRAY
60452: PPUSH
60453: LD_EXP 139
60457: PUSH
60458: LD_VAR 0 2
60462: ARRAY
60463: PUSH
60464: LD_INT 1
60466: ARRAY
60467: PUSH
60468: LD_INT 1
60470: ARRAY
60471: PPUSH
60472: LD_EXP 139
60476: PUSH
60477: LD_VAR 0 2
60481: ARRAY
60482: PUSH
60483: LD_INT 1
60485: ARRAY
60486: PUSH
60487: LD_INT 2
60489: ARRAY
60490: PPUSH
60491: CALL_OW 297
60495: PUSH
60496: LD_INT 6
60498: GREATER
60499: AND
60500: IFFALSE 60559
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
60502: LD_EXP 140
60506: PUSH
60507: LD_VAR 0 2
60511: ARRAY
60512: PUSH
60513: LD_INT 1
60515: ARRAY
60516: PPUSH
60517: LD_EXP 139
60521: PUSH
60522: LD_VAR 0 2
60526: ARRAY
60527: PUSH
60528: LD_INT 1
60530: ARRAY
60531: PUSH
60532: LD_INT 1
60534: ARRAY
60535: PPUSH
60536: LD_EXP 139
60540: PUSH
60541: LD_VAR 0 2
60545: ARRAY
60546: PUSH
60547: LD_INT 1
60549: ARRAY
60550: PUSH
60551: LD_INT 2
60553: ARRAY
60554: PPUSH
60555: CALL_OW 111
// end ; end ; end ;
60559: GO 59972
60561: POP
60562: POP
// end ;
60563: LD_VAR 0 1
60567: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
60568: LD_INT 0
60570: PPUSH
60571: PPUSH
60572: PPUSH
60573: PPUSH
60574: PPUSH
60575: PPUSH
60576: PPUSH
60577: PPUSH
60578: PPUSH
60579: PPUSH
60580: PPUSH
// if not mc_bases then
60581: LD_EXP 102
60585: NOT
60586: IFFALSE 60590
// exit ;
60588: GO 61530
// for i = 1 to mc_bases do
60590: LD_ADDR_VAR 0 2
60594: PUSH
60595: DOUBLE
60596: LD_INT 1
60598: DEC
60599: ST_TO_ADDR
60600: LD_EXP 102
60604: PUSH
60605: FOR_TO
60606: IFFALSE 61528
// begin if not mc_bases [ i ] or mc_scan [ i ] then
60608: LD_EXP 102
60612: PUSH
60613: LD_VAR 0 2
60617: ARRAY
60618: NOT
60619: PUSH
60620: LD_EXP 125
60624: PUSH
60625: LD_VAR 0 2
60629: ARRAY
60630: OR
60631: IFFALSE 60635
// continue ;
60633: GO 60605
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
60635: LD_ADDR_VAR 0 7
60639: PUSH
60640: LD_EXP 102
60644: PUSH
60645: LD_VAR 0 2
60649: ARRAY
60650: PUSH
60651: LD_INT 1
60653: ARRAY
60654: PPUSH
60655: CALL_OW 248
60659: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60660: LD_VAR 0 7
60664: PUSH
60665: LD_INT 3
60667: EQUAL
60668: PUSH
60669: LD_EXP 121
60673: PUSH
60674: LD_VAR 0 2
60678: ARRAY
60679: PUSH
60680: LD_EXP 124
60684: PUSH
60685: LD_VAR 0 2
60689: ARRAY
60690: UNION
60691: PPUSH
60692: LD_INT 33
60694: PUSH
60695: LD_INT 2
60697: PUSH
60698: EMPTY
60699: LIST
60700: LIST
60701: PPUSH
60702: CALL_OW 72
60706: NOT
60707: OR
60708: IFFALSE 60712
// continue ;
60710: GO 60605
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60712: LD_ADDR_VAR 0 9
60716: PUSH
60717: LD_EXP 102
60721: PUSH
60722: LD_VAR 0 2
60726: ARRAY
60727: PPUSH
60728: LD_INT 30
60730: PUSH
60731: LD_INT 36
60733: PUSH
60734: EMPTY
60735: LIST
60736: LIST
60737: PPUSH
60738: CALL_OW 72
60742: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60743: LD_ADDR_VAR 0 10
60747: PUSH
60748: LD_EXP 121
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PPUSH
60759: LD_INT 34
60761: PUSH
60762: LD_INT 31
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PPUSH
60769: CALL_OW 72
60773: ST_TO_ADDR
// if not cts and not mcts then
60774: LD_VAR 0 9
60778: NOT
60779: PUSH
60780: LD_VAR 0 10
60784: NOT
60785: AND
60786: IFFALSE 60790
// continue ;
60788: GO 60605
// x := cts ;
60790: LD_ADDR_VAR 0 11
60794: PUSH
60795: LD_VAR 0 9
60799: ST_TO_ADDR
// if not x then
60800: LD_VAR 0 11
60804: NOT
60805: IFFALSE 60817
// x := mcts ;
60807: LD_ADDR_VAR 0 11
60811: PUSH
60812: LD_VAR 0 10
60816: ST_TO_ADDR
// if not x then
60817: LD_VAR 0 11
60821: NOT
60822: IFFALSE 60826
// continue ;
60824: GO 60605
// if mc_remote_driver [ i ] then
60826: LD_EXP 142
60830: PUSH
60831: LD_VAR 0 2
60835: ARRAY
60836: IFFALSE 61223
// for j in mc_remote_driver [ i ] do
60838: LD_ADDR_VAR 0 3
60842: PUSH
60843: LD_EXP 142
60847: PUSH
60848: LD_VAR 0 2
60852: ARRAY
60853: PUSH
60854: FOR_IN
60855: IFFALSE 61221
// begin if GetClass ( j ) <> 3 then
60857: LD_VAR 0 3
60861: PPUSH
60862: CALL_OW 257
60866: PUSH
60867: LD_INT 3
60869: NONEQUAL
60870: IFFALSE 60923
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60872: LD_ADDR_EXP 142
60876: PUSH
60877: LD_EXP 142
60881: PPUSH
60882: LD_VAR 0 2
60886: PPUSH
60887: LD_EXP 142
60891: PUSH
60892: LD_VAR 0 2
60896: ARRAY
60897: PUSH
60898: LD_VAR 0 3
60902: DIFF
60903: PPUSH
60904: CALL_OW 1
60908: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60909: LD_VAR 0 3
60913: PPUSH
60914: LD_INT 0
60916: PPUSH
60917: CALL_OW 109
// continue ;
60921: GO 60854
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60923: LD_EXP 121
60927: PUSH
60928: LD_VAR 0 2
60932: ARRAY
60933: PPUSH
60934: LD_INT 34
60936: PUSH
60937: LD_INT 31
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: PUSH
60944: LD_INT 58
60946: PUSH
60947: EMPTY
60948: LIST
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PPUSH
60954: CALL_OW 72
60958: PUSH
60959: LD_VAR 0 3
60963: PPUSH
60964: CALL 104840 0 1
60968: NOT
60969: AND
60970: IFFALSE 61041
// begin if IsInUnit ( j ) then
60972: LD_VAR 0 3
60976: PPUSH
60977: CALL_OW 310
60981: IFFALSE 60992
// ComExitBuilding ( j ) ;
60983: LD_VAR 0 3
60987: PPUSH
60988: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60992: LD_VAR 0 3
60996: PPUSH
60997: LD_EXP 121
61001: PUSH
61002: LD_VAR 0 2
61006: ARRAY
61007: PPUSH
61008: LD_INT 34
61010: PUSH
61011: LD_INT 31
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: LD_INT 58
61020: PUSH
61021: EMPTY
61022: LIST
61023: PUSH
61024: EMPTY
61025: LIST
61026: LIST
61027: PPUSH
61028: CALL_OW 72
61032: PUSH
61033: LD_INT 1
61035: ARRAY
61036: PPUSH
61037: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
61041: LD_VAR 0 3
61045: PPUSH
61046: CALL_OW 310
61050: NOT
61051: PUSH
61052: LD_VAR 0 3
61056: PPUSH
61057: CALL_OW 310
61061: PPUSH
61062: CALL_OW 266
61066: PUSH
61067: LD_INT 36
61069: NONEQUAL
61070: PUSH
61071: LD_VAR 0 3
61075: PPUSH
61076: CALL 104840 0 1
61080: NOT
61081: AND
61082: OR
61083: IFFALSE 61219
// begin if IsInUnit ( j ) then
61085: LD_VAR 0 3
61089: PPUSH
61090: CALL_OW 310
61094: IFFALSE 61105
// ComExitBuilding ( j ) ;
61096: LD_VAR 0 3
61100: PPUSH
61101: CALL_OW 122
// ct := 0 ;
61105: LD_ADDR_VAR 0 8
61109: PUSH
61110: LD_INT 0
61112: ST_TO_ADDR
// for k in x do
61113: LD_ADDR_VAR 0 4
61117: PUSH
61118: LD_VAR 0 11
61122: PUSH
61123: FOR_IN
61124: IFFALSE 61197
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
61126: LD_VAR 0 4
61130: PPUSH
61131: CALL_OW 264
61135: PUSH
61136: LD_INT 31
61138: EQUAL
61139: PUSH
61140: LD_VAR 0 4
61144: PPUSH
61145: CALL_OW 311
61149: NOT
61150: AND
61151: PUSH
61152: LD_VAR 0 4
61156: PPUSH
61157: CALL_OW 266
61161: PUSH
61162: LD_INT 36
61164: EQUAL
61165: PUSH
61166: LD_VAR 0 4
61170: PPUSH
61171: CALL_OW 313
61175: PUSH
61176: LD_INT 3
61178: LESS
61179: AND
61180: OR
61181: IFFALSE 61195
// begin ct := k ;
61183: LD_ADDR_VAR 0 8
61187: PUSH
61188: LD_VAR 0 4
61192: ST_TO_ADDR
// break ;
61193: GO 61197
// end ;
61195: GO 61123
61197: POP
61198: POP
// if ct then
61199: LD_VAR 0 8
61203: IFFALSE 61219
// ComEnterUnit ( j , ct ) ;
61205: LD_VAR 0 3
61209: PPUSH
61210: LD_VAR 0 8
61214: PPUSH
61215: CALL_OW 120
// end ; end ;
61219: GO 60854
61221: POP
61222: POP
// places := 0 ;
61223: LD_ADDR_VAR 0 5
61227: PUSH
61228: LD_INT 0
61230: ST_TO_ADDR
// for j = 1 to x do
61231: LD_ADDR_VAR 0 3
61235: PUSH
61236: DOUBLE
61237: LD_INT 1
61239: DEC
61240: ST_TO_ADDR
61241: LD_VAR 0 11
61245: PUSH
61246: FOR_TO
61247: IFFALSE 61323
// if GetWeapon ( x [ j ] ) = ar_control_tower then
61249: LD_VAR 0 11
61253: PUSH
61254: LD_VAR 0 3
61258: ARRAY
61259: PPUSH
61260: CALL_OW 264
61264: PUSH
61265: LD_INT 31
61267: EQUAL
61268: IFFALSE 61286
// places := places + 1 else
61270: LD_ADDR_VAR 0 5
61274: PUSH
61275: LD_VAR 0 5
61279: PUSH
61280: LD_INT 1
61282: PLUS
61283: ST_TO_ADDR
61284: GO 61321
// if GetBType ( x [ j ] ) = b_control_tower then
61286: LD_VAR 0 11
61290: PUSH
61291: LD_VAR 0 3
61295: ARRAY
61296: PPUSH
61297: CALL_OW 266
61301: PUSH
61302: LD_INT 36
61304: EQUAL
61305: IFFALSE 61321
// places := places + 3 ;
61307: LD_ADDR_VAR 0 5
61311: PUSH
61312: LD_VAR 0 5
61316: PUSH
61317: LD_INT 3
61319: PLUS
61320: ST_TO_ADDR
61321: GO 61246
61323: POP
61324: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
61325: LD_VAR 0 5
61329: PUSH
61330: LD_INT 0
61332: EQUAL
61333: PUSH
61334: LD_VAR 0 5
61338: PUSH
61339: LD_EXP 142
61343: PUSH
61344: LD_VAR 0 2
61348: ARRAY
61349: LESSEQUAL
61350: OR
61351: IFFALSE 61355
// continue ;
61353: GO 60605
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
61355: LD_ADDR_VAR 0 6
61359: PUSH
61360: LD_EXP 102
61364: PUSH
61365: LD_VAR 0 2
61369: ARRAY
61370: PPUSH
61371: LD_INT 25
61373: PUSH
61374: LD_INT 3
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PPUSH
61381: CALL_OW 72
61385: PUSH
61386: LD_EXP 142
61390: PUSH
61391: LD_VAR 0 2
61395: ARRAY
61396: DIFF
61397: PPUSH
61398: LD_INT 3
61400: PPUSH
61401: CALL 105740 0 2
61405: ST_TO_ADDR
// for j in tmp do
61406: LD_ADDR_VAR 0 3
61410: PUSH
61411: LD_VAR 0 6
61415: PUSH
61416: FOR_IN
61417: IFFALSE 61452
// if GetTag ( j ) > 0 then
61419: LD_VAR 0 3
61423: PPUSH
61424: CALL_OW 110
61428: PUSH
61429: LD_INT 0
61431: GREATER
61432: IFFALSE 61450
// tmp := tmp diff j ;
61434: LD_ADDR_VAR 0 6
61438: PUSH
61439: LD_VAR 0 6
61443: PUSH
61444: LD_VAR 0 3
61448: DIFF
61449: ST_TO_ADDR
61450: GO 61416
61452: POP
61453: POP
// if not tmp then
61454: LD_VAR 0 6
61458: NOT
61459: IFFALSE 61463
// continue ;
61461: GO 60605
// if places then
61463: LD_VAR 0 5
61467: IFFALSE 61526
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
61469: LD_ADDR_EXP 142
61473: PUSH
61474: LD_EXP 142
61478: PPUSH
61479: LD_VAR 0 2
61483: PPUSH
61484: LD_EXP 142
61488: PUSH
61489: LD_VAR 0 2
61493: ARRAY
61494: PUSH
61495: LD_VAR 0 6
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: UNION
61504: PPUSH
61505: CALL_OW 1
61509: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
61510: LD_VAR 0 6
61514: PUSH
61515: LD_INT 1
61517: ARRAY
61518: PPUSH
61519: LD_INT 126
61521: PPUSH
61522: CALL_OW 109
// end ; end ;
61526: GO 60605
61528: POP
61529: POP
// end ;
61530: LD_VAR 0 1
61534: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
61535: LD_INT 0
61537: PPUSH
61538: PPUSH
61539: PPUSH
61540: PPUSH
61541: PPUSH
61542: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
61543: LD_VAR 0 1
61547: NOT
61548: PUSH
61549: LD_VAR 0 2
61553: NOT
61554: OR
61555: PUSH
61556: LD_VAR 0 3
61560: NOT
61561: OR
61562: PUSH
61563: LD_VAR 0 4
61567: PUSH
61568: LD_INT 1
61570: PUSH
61571: LD_INT 2
61573: PUSH
61574: LD_INT 3
61576: PUSH
61577: LD_INT 4
61579: PUSH
61580: LD_INT 5
61582: PUSH
61583: LD_INT 8
61585: PUSH
61586: LD_INT 9
61588: PUSH
61589: LD_INT 15
61591: PUSH
61592: LD_INT 16
61594: PUSH
61595: EMPTY
61596: LIST
61597: LIST
61598: LIST
61599: LIST
61600: LIST
61601: LIST
61602: LIST
61603: LIST
61604: LIST
61605: IN
61606: NOT
61607: OR
61608: IFFALSE 61612
// exit ;
61610: GO 62470
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
61612: LD_ADDR_VAR 0 2
61616: PUSH
61617: LD_VAR 0 2
61621: PPUSH
61622: LD_INT 21
61624: PUSH
61625: LD_INT 3
61627: PUSH
61628: EMPTY
61629: LIST
61630: LIST
61631: PUSH
61632: LD_INT 24
61634: PUSH
61635: LD_INT 250
61637: PUSH
61638: EMPTY
61639: LIST
61640: LIST
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: PPUSH
61646: CALL_OW 72
61650: ST_TO_ADDR
// case class of 1 , 15 :
61651: LD_VAR 0 4
61655: PUSH
61656: LD_INT 1
61658: DOUBLE
61659: EQUAL
61660: IFTRUE 61670
61662: LD_INT 15
61664: DOUBLE
61665: EQUAL
61666: IFTRUE 61670
61668: GO 61755
61670: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61671: LD_ADDR_VAR 0 8
61675: PUSH
61676: LD_VAR 0 2
61680: PPUSH
61681: LD_INT 2
61683: PUSH
61684: LD_INT 30
61686: PUSH
61687: LD_INT 32
61689: PUSH
61690: EMPTY
61691: LIST
61692: LIST
61693: PUSH
61694: LD_INT 30
61696: PUSH
61697: LD_INT 31
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: LIST
61708: PPUSH
61709: CALL_OW 72
61713: PUSH
61714: LD_VAR 0 2
61718: PPUSH
61719: LD_INT 2
61721: PUSH
61722: LD_INT 30
61724: PUSH
61725: LD_INT 4
61727: PUSH
61728: EMPTY
61729: LIST
61730: LIST
61731: PUSH
61732: LD_INT 30
61734: PUSH
61735: LD_INT 5
61737: PUSH
61738: EMPTY
61739: LIST
61740: LIST
61741: PUSH
61742: EMPTY
61743: LIST
61744: LIST
61745: LIST
61746: PPUSH
61747: CALL_OW 72
61751: ADD
61752: ST_TO_ADDR
61753: GO 62001
61755: LD_INT 2
61757: DOUBLE
61758: EQUAL
61759: IFTRUE 61769
61761: LD_INT 16
61763: DOUBLE
61764: EQUAL
61765: IFTRUE 61769
61767: GO 61815
61769: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61770: LD_ADDR_VAR 0 8
61774: PUSH
61775: LD_VAR 0 2
61779: PPUSH
61780: LD_INT 2
61782: PUSH
61783: LD_INT 30
61785: PUSH
61786: LD_INT 0
61788: PUSH
61789: EMPTY
61790: LIST
61791: LIST
61792: PUSH
61793: LD_INT 30
61795: PUSH
61796: LD_INT 1
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: EMPTY
61804: LIST
61805: LIST
61806: LIST
61807: PPUSH
61808: CALL_OW 72
61812: ST_TO_ADDR
61813: GO 62001
61815: LD_INT 3
61817: DOUBLE
61818: EQUAL
61819: IFTRUE 61823
61821: GO 61869
61823: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61824: LD_ADDR_VAR 0 8
61828: PUSH
61829: LD_VAR 0 2
61833: PPUSH
61834: LD_INT 2
61836: PUSH
61837: LD_INT 30
61839: PUSH
61840: LD_INT 2
61842: PUSH
61843: EMPTY
61844: LIST
61845: LIST
61846: PUSH
61847: LD_INT 30
61849: PUSH
61850: LD_INT 3
61852: PUSH
61853: EMPTY
61854: LIST
61855: LIST
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: LIST
61861: PPUSH
61862: CALL_OW 72
61866: ST_TO_ADDR
61867: GO 62001
61869: LD_INT 4
61871: DOUBLE
61872: EQUAL
61873: IFTRUE 61877
61875: GO 61934
61877: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61878: LD_ADDR_VAR 0 8
61882: PUSH
61883: LD_VAR 0 2
61887: PPUSH
61888: LD_INT 2
61890: PUSH
61891: LD_INT 30
61893: PUSH
61894: LD_INT 6
61896: PUSH
61897: EMPTY
61898: LIST
61899: LIST
61900: PUSH
61901: LD_INT 30
61903: PUSH
61904: LD_INT 7
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PUSH
61911: LD_INT 30
61913: PUSH
61914: LD_INT 8
61916: PUSH
61917: EMPTY
61918: LIST
61919: LIST
61920: PUSH
61921: EMPTY
61922: LIST
61923: LIST
61924: LIST
61925: LIST
61926: PPUSH
61927: CALL_OW 72
61931: ST_TO_ADDR
61932: GO 62001
61934: LD_INT 5
61936: DOUBLE
61937: EQUAL
61938: IFTRUE 61954
61940: LD_INT 8
61942: DOUBLE
61943: EQUAL
61944: IFTRUE 61954
61946: LD_INT 9
61948: DOUBLE
61949: EQUAL
61950: IFTRUE 61954
61952: GO 62000
61954: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61955: LD_ADDR_VAR 0 8
61959: PUSH
61960: LD_VAR 0 2
61964: PPUSH
61965: LD_INT 2
61967: PUSH
61968: LD_INT 30
61970: PUSH
61971: LD_INT 4
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 30
61980: PUSH
61981: LD_INT 5
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: LIST
61992: PPUSH
61993: CALL_OW 72
61997: ST_TO_ADDR
61998: GO 62001
62000: POP
// if not tmp then
62001: LD_VAR 0 8
62005: NOT
62006: IFFALSE 62010
// exit ;
62008: GO 62470
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
62010: LD_VAR 0 4
62014: PUSH
62015: LD_INT 1
62017: PUSH
62018: LD_INT 15
62020: PUSH
62021: EMPTY
62022: LIST
62023: LIST
62024: IN
62025: PUSH
62026: LD_EXP 111
62030: PUSH
62031: LD_VAR 0 1
62035: ARRAY
62036: AND
62037: IFFALSE 62193
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
62039: LD_ADDR_VAR 0 9
62043: PUSH
62044: LD_EXP 111
62048: PUSH
62049: LD_VAR 0 1
62053: ARRAY
62054: PUSH
62055: LD_INT 1
62057: ARRAY
62058: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
62059: LD_VAR 0 9
62063: PUSH
62064: LD_EXP 112
62068: PUSH
62069: LD_VAR 0 1
62073: ARRAY
62074: IN
62075: NOT
62076: IFFALSE 62191
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
62078: LD_ADDR_EXP 112
62082: PUSH
62083: LD_EXP 112
62087: PPUSH
62088: LD_VAR 0 1
62092: PUSH
62093: LD_EXP 112
62097: PUSH
62098: LD_VAR 0 1
62102: ARRAY
62103: PUSH
62104: LD_INT 1
62106: PLUS
62107: PUSH
62108: EMPTY
62109: LIST
62110: LIST
62111: PPUSH
62112: LD_VAR 0 9
62116: PPUSH
62117: CALL 74507 0 3
62121: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
62122: LD_ADDR_EXP 111
62126: PUSH
62127: LD_EXP 111
62131: PPUSH
62132: LD_VAR 0 1
62136: PPUSH
62137: LD_EXP 111
62141: PUSH
62142: LD_VAR 0 1
62146: ARRAY
62147: PUSH
62148: LD_VAR 0 9
62152: DIFF
62153: PPUSH
62154: CALL_OW 1
62158: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
62159: LD_VAR 0 3
62163: PPUSH
62164: LD_EXP 112
62168: PUSH
62169: LD_VAR 0 1
62173: ARRAY
62174: PUSH
62175: LD_EXP 112
62179: PUSH
62180: LD_VAR 0 1
62184: ARRAY
62185: ARRAY
62186: PPUSH
62187: CALL_OW 120
// end ; exit ;
62191: GO 62470
// end ; if tmp > 1 then
62193: LD_VAR 0 8
62197: PUSH
62198: LD_INT 1
62200: GREATER
62201: IFFALSE 62305
// for i = 2 to tmp do
62203: LD_ADDR_VAR 0 6
62207: PUSH
62208: DOUBLE
62209: LD_INT 2
62211: DEC
62212: ST_TO_ADDR
62213: LD_VAR 0 8
62217: PUSH
62218: FOR_TO
62219: IFFALSE 62303
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
62221: LD_VAR 0 8
62225: PUSH
62226: LD_VAR 0 6
62230: ARRAY
62231: PPUSH
62232: CALL_OW 461
62236: PUSH
62237: LD_INT 6
62239: EQUAL
62240: IFFALSE 62301
// begin x := tmp [ i ] ;
62242: LD_ADDR_VAR 0 9
62246: PUSH
62247: LD_VAR 0 8
62251: PUSH
62252: LD_VAR 0 6
62256: ARRAY
62257: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
62258: LD_ADDR_VAR 0 8
62262: PUSH
62263: LD_VAR 0 8
62267: PPUSH
62268: LD_VAR 0 6
62272: PPUSH
62273: CALL_OW 3
62277: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
62278: LD_ADDR_VAR 0 8
62282: PUSH
62283: LD_VAR 0 8
62287: PPUSH
62288: LD_INT 1
62290: PPUSH
62291: LD_VAR 0 9
62295: PPUSH
62296: CALL_OW 2
62300: ST_TO_ADDR
// end ;
62301: GO 62218
62303: POP
62304: POP
// for i in tmp do
62305: LD_ADDR_VAR 0 6
62309: PUSH
62310: LD_VAR 0 8
62314: PUSH
62315: FOR_IN
62316: IFFALSE 62343
// begin if IsNotFull ( i ) then
62318: LD_VAR 0 6
62322: PPUSH
62323: CALL 71729 0 1
62327: IFFALSE 62341
// begin j := i ;
62329: LD_ADDR_VAR 0 7
62333: PUSH
62334: LD_VAR 0 6
62338: ST_TO_ADDR
// break ;
62339: GO 62343
// end ; end ;
62341: GO 62315
62343: POP
62344: POP
// if j then
62345: LD_VAR 0 7
62349: IFFALSE 62367
// ComEnterUnit ( unit , j ) else
62351: LD_VAR 0 3
62355: PPUSH
62356: LD_VAR 0 7
62360: PPUSH
62361: CALL_OW 120
62365: GO 62470
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62367: LD_ADDR_VAR 0 10
62371: PUSH
62372: LD_VAR 0 2
62376: PPUSH
62377: LD_INT 2
62379: PUSH
62380: LD_INT 30
62382: PUSH
62383: LD_INT 0
62385: PUSH
62386: EMPTY
62387: LIST
62388: LIST
62389: PUSH
62390: LD_INT 30
62392: PUSH
62393: LD_INT 1
62395: PUSH
62396: EMPTY
62397: LIST
62398: LIST
62399: PUSH
62400: EMPTY
62401: LIST
62402: LIST
62403: LIST
62404: PPUSH
62405: CALL_OW 72
62409: ST_TO_ADDR
// if depot then
62410: LD_VAR 0 10
62414: IFFALSE 62470
// begin depot := NearestUnitToUnit ( depot , unit ) ;
62416: LD_ADDR_VAR 0 10
62420: PUSH
62421: LD_VAR 0 10
62425: PPUSH
62426: LD_VAR 0 3
62430: PPUSH
62431: CALL_OW 74
62435: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
62436: LD_VAR 0 3
62440: PPUSH
62441: LD_VAR 0 10
62445: PPUSH
62446: CALL_OW 296
62450: PUSH
62451: LD_INT 10
62453: GREATER
62454: IFFALSE 62470
// ComStandNearbyBuilding ( unit , depot ) ;
62456: LD_VAR 0 3
62460: PPUSH
62461: LD_VAR 0 10
62465: PPUSH
62466: CALL 71109 0 2
// end ; end ; end ;
62470: LD_VAR 0 5
62474: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
62475: LD_INT 0
62477: PPUSH
62478: PPUSH
62479: PPUSH
62480: PPUSH
// if not mc_bases then
62481: LD_EXP 102
62485: NOT
62486: IFFALSE 62490
// exit ;
62488: GO 62729
// for i = 1 to mc_bases do
62490: LD_ADDR_VAR 0 2
62494: PUSH
62495: DOUBLE
62496: LD_INT 1
62498: DEC
62499: ST_TO_ADDR
62500: LD_EXP 102
62504: PUSH
62505: FOR_TO
62506: IFFALSE 62727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
62508: LD_ADDR_VAR 0 4
62512: PUSH
62513: LD_EXP 102
62517: PUSH
62518: LD_VAR 0 2
62522: ARRAY
62523: PPUSH
62524: LD_INT 21
62526: PUSH
62527: LD_INT 1
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: PPUSH
62534: CALL_OW 72
62538: PUSH
62539: LD_EXP 131
62543: PUSH
62544: LD_VAR 0 2
62548: ARRAY
62549: UNION
62550: ST_TO_ADDR
// if not tmp then
62551: LD_VAR 0 4
62555: NOT
62556: IFFALSE 62560
// continue ;
62558: GO 62505
// for j in tmp do
62560: LD_ADDR_VAR 0 3
62564: PUSH
62565: LD_VAR 0 4
62569: PUSH
62570: FOR_IN
62571: IFFALSE 62723
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
62573: LD_VAR 0 3
62577: PPUSH
62578: CALL_OW 110
62582: NOT
62583: PUSH
62584: LD_VAR 0 3
62588: PPUSH
62589: CALL_OW 314
62593: NOT
62594: AND
62595: PUSH
62596: LD_VAR 0 3
62600: PPUSH
62601: CALL_OW 311
62605: NOT
62606: AND
62607: PUSH
62608: LD_VAR 0 3
62612: PPUSH
62613: CALL_OW 310
62617: NOT
62618: AND
62619: PUSH
62620: LD_VAR 0 3
62624: PUSH
62625: LD_EXP 105
62629: PUSH
62630: LD_VAR 0 2
62634: ARRAY
62635: PUSH
62636: LD_INT 1
62638: ARRAY
62639: IN
62640: NOT
62641: AND
62642: PUSH
62643: LD_VAR 0 3
62647: PUSH
62648: LD_EXP 105
62652: PUSH
62653: LD_VAR 0 2
62657: ARRAY
62658: PUSH
62659: LD_INT 2
62661: ARRAY
62662: IN
62663: NOT
62664: AND
62665: PUSH
62666: LD_VAR 0 3
62670: PUSH
62671: LD_EXP 114
62675: PUSH
62676: LD_VAR 0 2
62680: ARRAY
62681: IN
62682: NOT
62683: AND
62684: IFFALSE 62721
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62686: LD_VAR 0 2
62690: PPUSH
62691: LD_EXP 102
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: PPUSH
62702: LD_VAR 0 3
62706: PPUSH
62707: LD_VAR 0 3
62711: PPUSH
62712: CALL_OW 257
62716: PPUSH
62717: CALL 61535 0 4
// end ;
62721: GO 62570
62723: POP
62724: POP
// end ;
62725: GO 62505
62727: POP
62728: POP
// end ;
62729: LD_VAR 0 1
62733: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62734: LD_INT 0
62736: PPUSH
62737: PPUSH
62738: PPUSH
62739: PPUSH
62740: PPUSH
62741: PPUSH
// if not mc_bases [ base ] then
62742: LD_EXP 102
62746: PUSH
62747: LD_VAR 0 1
62751: ARRAY
62752: NOT
62753: IFFALSE 62757
// exit ;
62755: GO 62958
// tmp := [ ] ;
62757: LD_ADDR_VAR 0 6
62761: PUSH
62762: EMPTY
62763: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62764: LD_ADDR_VAR 0 7
62768: PUSH
62769: LD_VAR 0 3
62773: PPUSH
62774: LD_INT 0
62776: PPUSH
62777: CALL_OW 517
62781: ST_TO_ADDR
// if not list then
62782: LD_VAR 0 7
62786: NOT
62787: IFFALSE 62791
// exit ;
62789: GO 62958
// c := Count ( list [ 1 ] ) ;
62791: LD_ADDR_VAR 0 9
62795: PUSH
62796: LD_VAR 0 7
62800: PUSH
62801: LD_INT 1
62803: ARRAY
62804: PPUSH
62805: CALL 71647 0 1
62809: ST_TO_ADDR
// if amount > c then
62810: LD_VAR 0 2
62814: PUSH
62815: LD_VAR 0 9
62819: GREATER
62820: IFFALSE 62832
// amount := c ;
62822: LD_ADDR_VAR 0 2
62826: PUSH
62827: LD_VAR 0 9
62831: ST_TO_ADDR
// for i := 1 to amount do
62832: LD_ADDR_VAR 0 5
62836: PUSH
62837: DOUBLE
62838: LD_INT 1
62840: DEC
62841: ST_TO_ADDR
62842: LD_VAR 0 2
62846: PUSH
62847: FOR_TO
62848: IFFALSE 62906
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62850: LD_ADDR_VAR 0 6
62854: PUSH
62855: LD_VAR 0 6
62859: PPUSH
62860: LD_VAR 0 5
62864: PPUSH
62865: LD_VAR 0 7
62869: PUSH
62870: LD_INT 1
62872: ARRAY
62873: PUSH
62874: LD_VAR 0 5
62878: ARRAY
62879: PUSH
62880: LD_VAR 0 7
62884: PUSH
62885: LD_INT 2
62887: ARRAY
62888: PUSH
62889: LD_VAR 0 5
62893: ARRAY
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: PPUSH
62899: CALL_OW 1
62903: ST_TO_ADDR
62904: GO 62847
62906: POP
62907: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62908: LD_ADDR_EXP 115
62912: PUSH
62913: LD_EXP 115
62917: PPUSH
62918: LD_VAR 0 1
62922: PPUSH
62923: LD_VAR 0 6
62927: PPUSH
62928: CALL_OW 1
62932: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62933: LD_ADDR_EXP 117
62937: PUSH
62938: LD_EXP 117
62942: PPUSH
62943: LD_VAR 0 1
62947: PPUSH
62948: LD_VAR 0 3
62952: PPUSH
62953: CALL_OW 1
62957: ST_TO_ADDR
// end ;
62958: LD_VAR 0 4
62962: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62963: LD_INT 0
62965: PPUSH
// if not mc_bases [ base ] then
62966: LD_EXP 102
62970: PUSH
62971: LD_VAR 0 1
62975: ARRAY
62976: NOT
62977: IFFALSE 62981
// exit ;
62979: GO 63006
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62981: LD_ADDR_EXP 107
62985: PUSH
62986: LD_EXP 107
62990: PPUSH
62991: LD_VAR 0 1
62995: PPUSH
62996: LD_VAR 0 2
63000: PPUSH
63001: CALL_OW 1
63005: ST_TO_ADDR
// end ;
63006: LD_VAR 0 3
63010: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
63011: LD_INT 0
63013: PPUSH
// if not mc_bases [ base ] then
63014: LD_EXP 102
63018: PUSH
63019: LD_VAR 0 1
63023: ARRAY
63024: NOT
63025: IFFALSE 63029
// exit ;
63027: GO 63066
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
63029: LD_ADDR_EXP 107
63033: PUSH
63034: LD_EXP 107
63038: PPUSH
63039: LD_VAR 0 1
63043: PPUSH
63044: LD_EXP 107
63048: PUSH
63049: LD_VAR 0 1
63053: ARRAY
63054: PUSH
63055: LD_VAR 0 2
63059: UNION
63060: PPUSH
63061: CALL_OW 1
63065: ST_TO_ADDR
// end ;
63066: LD_VAR 0 3
63070: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
63071: LD_INT 0
63073: PPUSH
// if not mc_bases [ base ] then
63074: LD_EXP 102
63078: PUSH
63079: LD_VAR 0 1
63083: ARRAY
63084: NOT
63085: IFFALSE 63089
// exit ;
63087: GO 63114
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
63089: LD_ADDR_EXP 123
63093: PUSH
63094: LD_EXP 123
63098: PPUSH
63099: LD_VAR 0 1
63103: PPUSH
63104: LD_VAR 0 2
63108: PPUSH
63109: CALL_OW 1
63113: ST_TO_ADDR
// end ;
63114: LD_VAR 0 3
63118: RET
// export function MC_InsertProduceList ( base , components ) ; begin
63119: LD_INT 0
63121: PPUSH
// if not mc_bases [ base ] then
63122: LD_EXP 102
63126: PUSH
63127: LD_VAR 0 1
63131: ARRAY
63132: NOT
63133: IFFALSE 63137
// exit ;
63135: GO 63174
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
63137: LD_ADDR_EXP 123
63141: PUSH
63142: LD_EXP 123
63146: PPUSH
63147: LD_VAR 0 1
63151: PPUSH
63152: LD_EXP 123
63156: PUSH
63157: LD_VAR 0 1
63161: ARRAY
63162: PUSH
63163: LD_VAR 0 2
63167: ADD
63168: PPUSH
63169: CALL_OW 1
63173: ST_TO_ADDR
// end ;
63174: LD_VAR 0 3
63178: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
63179: LD_INT 0
63181: PPUSH
// if not mc_bases [ base ] then
63182: LD_EXP 102
63186: PUSH
63187: LD_VAR 0 1
63191: ARRAY
63192: NOT
63193: IFFALSE 63197
// exit ;
63195: GO 63251
// mc_defender := Replace ( mc_defender , base , deflist ) ;
63197: LD_ADDR_EXP 124
63201: PUSH
63202: LD_EXP 124
63206: PPUSH
63207: LD_VAR 0 1
63211: PPUSH
63212: LD_VAR 0 2
63216: PPUSH
63217: CALL_OW 1
63221: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
63222: LD_ADDR_EXP 113
63226: PUSH
63227: LD_EXP 113
63231: PPUSH
63232: LD_VAR 0 1
63236: PPUSH
63237: LD_VAR 0 2
63241: PUSH
63242: LD_INT 0
63244: PLUS
63245: PPUSH
63246: CALL_OW 1
63250: ST_TO_ADDR
// end ;
63251: LD_VAR 0 3
63255: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
63256: LD_INT 0
63258: PPUSH
// if not mc_bases [ base ] then
63259: LD_EXP 102
63263: PUSH
63264: LD_VAR 0 1
63268: ARRAY
63269: NOT
63270: IFFALSE 63274
// exit ;
63272: GO 63299
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
63274: LD_ADDR_EXP 113
63278: PUSH
63279: LD_EXP 113
63283: PPUSH
63284: LD_VAR 0 1
63288: PPUSH
63289: LD_VAR 0 2
63293: PPUSH
63294: CALL_OW 1
63298: ST_TO_ADDR
// end ;
63299: LD_VAR 0 3
63303: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
63304: LD_INT 0
63306: PPUSH
63307: PPUSH
63308: PPUSH
63309: PPUSH
// if not mc_bases [ base ] then
63310: LD_EXP 102
63314: PUSH
63315: LD_VAR 0 1
63319: ARRAY
63320: NOT
63321: IFFALSE 63325
// exit ;
63323: GO 63390
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
63325: LD_ADDR_EXP 122
63329: PUSH
63330: LD_EXP 122
63334: PPUSH
63335: LD_VAR 0 1
63339: PUSH
63340: LD_EXP 122
63344: PUSH
63345: LD_VAR 0 1
63349: ARRAY
63350: PUSH
63351: LD_INT 1
63353: PLUS
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PPUSH
63359: LD_VAR 0 1
63363: PUSH
63364: LD_VAR 0 2
63368: PUSH
63369: LD_VAR 0 3
63373: PUSH
63374: LD_VAR 0 4
63378: PUSH
63379: EMPTY
63380: LIST
63381: LIST
63382: LIST
63383: LIST
63384: PPUSH
63385: CALL 74507 0 3
63389: ST_TO_ADDR
// end ;
63390: LD_VAR 0 5
63394: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
63395: LD_INT 0
63397: PPUSH
// if not mc_bases [ base ] then
63398: LD_EXP 102
63402: PUSH
63403: LD_VAR 0 1
63407: ARRAY
63408: NOT
63409: IFFALSE 63413
// exit ;
63411: GO 63438
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
63413: LD_ADDR_EXP 139
63417: PUSH
63418: LD_EXP 139
63422: PPUSH
63423: LD_VAR 0 1
63427: PPUSH
63428: LD_VAR 0 2
63432: PPUSH
63433: CALL_OW 1
63437: ST_TO_ADDR
// end ;
63438: LD_VAR 0 3
63442: RET
// export function MC_GetMinesField ( base ) ; begin
63443: LD_INT 0
63445: PPUSH
// result := mc_mines [ base ] ;
63446: LD_ADDR_VAR 0 2
63450: PUSH
63451: LD_EXP 115
63455: PUSH
63456: LD_VAR 0 1
63460: ARRAY
63461: ST_TO_ADDR
// end ;
63462: LD_VAR 0 2
63466: RET
// export function MC_GetProduceList ( base ) ; begin
63467: LD_INT 0
63469: PPUSH
// result := mc_produce [ base ] ;
63470: LD_ADDR_VAR 0 2
63474: PUSH
63475: LD_EXP 123
63479: PUSH
63480: LD_VAR 0 1
63484: ARRAY
63485: ST_TO_ADDR
// end ;
63486: LD_VAR 0 2
63490: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
63491: LD_INT 0
63493: PPUSH
63494: PPUSH
// if not mc_bases then
63495: LD_EXP 102
63499: NOT
63500: IFFALSE 63504
// exit ;
63502: GO 63569
// if mc_bases [ base ] then
63504: LD_EXP 102
63508: PUSH
63509: LD_VAR 0 1
63513: ARRAY
63514: IFFALSE 63569
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63516: LD_ADDR_VAR 0 3
63520: PUSH
63521: LD_EXP 102
63525: PUSH
63526: LD_VAR 0 1
63530: ARRAY
63531: PPUSH
63532: LD_INT 30
63534: PUSH
63535: LD_VAR 0 2
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PPUSH
63544: CALL_OW 72
63548: ST_TO_ADDR
// if result then
63549: LD_VAR 0 3
63553: IFFALSE 63569
// result := result [ 1 ] ;
63555: LD_ADDR_VAR 0 3
63559: PUSH
63560: LD_VAR 0 3
63564: PUSH
63565: LD_INT 1
63567: ARRAY
63568: ST_TO_ADDR
// end ; end ;
63569: LD_VAR 0 3
63573: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
63574: LD_INT 0
63576: PPUSH
63577: PPUSH
// if not mc_bases then
63578: LD_EXP 102
63582: NOT
63583: IFFALSE 63587
// exit ;
63585: GO 63632
// if mc_bases [ base ] then
63587: LD_EXP 102
63591: PUSH
63592: LD_VAR 0 1
63596: ARRAY
63597: IFFALSE 63632
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63599: LD_ADDR_VAR 0 3
63603: PUSH
63604: LD_EXP 102
63608: PUSH
63609: LD_VAR 0 1
63613: ARRAY
63614: PPUSH
63615: LD_INT 30
63617: PUSH
63618: LD_VAR 0 2
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PPUSH
63627: CALL_OW 72
63631: ST_TO_ADDR
// end ;
63632: LD_VAR 0 3
63636: RET
// export function MC_SetTame ( base , area ) ; begin
63637: LD_INT 0
63639: PPUSH
// if not mc_bases or not base then
63640: LD_EXP 102
63644: NOT
63645: PUSH
63646: LD_VAR 0 1
63650: NOT
63651: OR
63652: IFFALSE 63656
// exit ;
63654: GO 63681
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63656: LD_ADDR_EXP 130
63660: PUSH
63661: LD_EXP 130
63665: PPUSH
63666: LD_VAR 0 1
63670: PPUSH
63671: LD_VAR 0 2
63675: PPUSH
63676: CALL_OW 1
63680: ST_TO_ADDR
// end ;
63681: LD_VAR 0 3
63685: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63686: LD_INT 0
63688: PPUSH
63689: PPUSH
// if not mc_bases or not base then
63690: LD_EXP 102
63694: NOT
63695: PUSH
63696: LD_VAR 0 1
63700: NOT
63701: OR
63702: IFFALSE 63706
// exit ;
63704: GO 63808
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63706: LD_ADDR_VAR 0 4
63710: PUSH
63711: LD_EXP 102
63715: PUSH
63716: LD_VAR 0 1
63720: ARRAY
63721: PPUSH
63722: LD_INT 30
63724: PUSH
63725: LD_VAR 0 2
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PPUSH
63734: CALL_OW 72
63738: ST_TO_ADDR
// if not tmp then
63739: LD_VAR 0 4
63743: NOT
63744: IFFALSE 63748
// exit ;
63746: GO 63808
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63748: LD_ADDR_EXP 134
63752: PUSH
63753: LD_EXP 134
63757: PPUSH
63758: LD_VAR 0 1
63762: PPUSH
63763: LD_EXP 134
63767: PUSH
63768: LD_VAR 0 1
63772: ARRAY
63773: PPUSH
63774: LD_EXP 134
63778: PUSH
63779: LD_VAR 0 1
63783: ARRAY
63784: PUSH
63785: LD_INT 1
63787: PLUS
63788: PPUSH
63789: LD_VAR 0 4
63793: PUSH
63794: LD_INT 1
63796: ARRAY
63797: PPUSH
63798: CALL_OW 2
63802: PPUSH
63803: CALL_OW 1
63807: ST_TO_ADDR
// end ;
63808: LD_VAR 0 3
63812: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63813: LD_INT 0
63815: PPUSH
63816: PPUSH
// if not mc_bases or not base or not kinds then
63817: LD_EXP 102
63821: NOT
63822: PUSH
63823: LD_VAR 0 1
63827: NOT
63828: OR
63829: PUSH
63830: LD_VAR 0 2
63834: NOT
63835: OR
63836: IFFALSE 63840
// exit ;
63838: GO 63901
// for i in kinds do
63840: LD_ADDR_VAR 0 4
63844: PUSH
63845: LD_VAR 0 2
63849: PUSH
63850: FOR_IN
63851: IFFALSE 63899
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63853: LD_ADDR_EXP 136
63857: PUSH
63858: LD_EXP 136
63862: PPUSH
63863: LD_VAR 0 1
63867: PUSH
63868: LD_EXP 136
63872: PUSH
63873: LD_VAR 0 1
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: PLUS
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: PPUSH
63887: LD_VAR 0 4
63891: PPUSH
63892: CALL 74507 0 3
63896: ST_TO_ADDR
63897: GO 63850
63899: POP
63900: POP
// end ;
63901: LD_VAR 0 3
63905: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63906: LD_INT 0
63908: PPUSH
// if not mc_bases or not base or not areas then
63909: LD_EXP 102
63913: NOT
63914: PUSH
63915: LD_VAR 0 1
63919: NOT
63920: OR
63921: PUSH
63922: LD_VAR 0 2
63926: NOT
63927: OR
63928: IFFALSE 63932
// exit ;
63930: GO 63957
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63932: LD_ADDR_EXP 120
63936: PUSH
63937: LD_EXP 120
63941: PPUSH
63942: LD_VAR 0 1
63946: PPUSH
63947: LD_VAR 0 2
63951: PPUSH
63952: CALL_OW 1
63956: ST_TO_ADDR
// end ;
63957: LD_VAR 0 3
63961: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63962: LD_INT 0
63964: PPUSH
// if not mc_bases or not base or not teleports_exit then
63965: LD_EXP 102
63969: NOT
63970: PUSH
63971: LD_VAR 0 1
63975: NOT
63976: OR
63977: PUSH
63978: LD_VAR 0 2
63982: NOT
63983: OR
63984: IFFALSE 63988
// exit ;
63986: GO 64013
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63988: LD_ADDR_EXP 137
63992: PUSH
63993: LD_EXP 137
63997: PPUSH
63998: LD_VAR 0 1
64002: PPUSH
64003: LD_VAR 0 2
64007: PPUSH
64008: CALL_OW 1
64012: ST_TO_ADDR
// end ;
64013: LD_VAR 0 3
64017: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
64018: LD_INT 0
64020: PPUSH
64021: PPUSH
64022: PPUSH
// if not mc_bases or not base or not ext_list then
64023: LD_EXP 102
64027: NOT
64028: PUSH
64029: LD_VAR 0 1
64033: NOT
64034: OR
64035: PUSH
64036: LD_VAR 0 5
64040: NOT
64041: OR
64042: IFFALSE 64046
// exit ;
64044: GO 64219
// tmp := GetFacExtXYD ( x , y , d ) ;
64046: LD_ADDR_VAR 0 8
64050: PUSH
64051: LD_VAR 0 2
64055: PPUSH
64056: LD_VAR 0 3
64060: PPUSH
64061: LD_VAR 0 4
64065: PPUSH
64066: CALL 104870 0 3
64070: ST_TO_ADDR
// if not tmp then
64071: LD_VAR 0 8
64075: NOT
64076: IFFALSE 64080
// exit ;
64078: GO 64219
// for i in tmp do
64080: LD_ADDR_VAR 0 7
64084: PUSH
64085: LD_VAR 0 8
64089: PUSH
64090: FOR_IN
64091: IFFALSE 64217
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
64093: LD_ADDR_EXP 107
64097: PUSH
64098: LD_EXP 107
64102: PPUSH
64103: LD_VAR 0 1
64107: PPUSH
64108: LD_EXP 107
64112: PUSH
64113: LD_VAR 0 1
64117: ARRAY
64118: PPUSH
64119: LD_EXP 107
64123: PUSH
64124: LD_VAR 0 1
64128: ARRAY
64129: PUSH
64130: LD_INT 1
64132: PLUS
64133: PPUSH
64134: LD_VAR 0 5
64138: PUSH
64139: LD_INT 1
64141: ARRAY
64142: PUSH
64143: LD_VAR 0 7
64147: PUSH
64148: LD_INT 1
64150: ARRAY
64151: PUSH
64152: LD_VAR 0 7
64156: PUSH
64157: LD_INT 2
64159: ARRAY
64160: PUSH
64161: LD_VAR 0 7
64165: PUSH
64166: LD_INT 3
64168: ARRAY
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: LIST
64174: LIST
64175: PPUSH
64176: CALL_OW 2
64180: PPUSH
64181: CALL_OW 1
64185: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
64186: LD_ADDR_VAR 0 5
64190: PUSH
64191: LD_VAR 0 5
64195: PPUSH
64196: LD_INT 1
64198: PPUSH
64199: CALL_OW 3
64203: ST_TO_ADDR
// if not ext_list then
64204: LD_VAR 0 5
64208: NOT
64209: IFFALSE 64215
// exit ;
64211: POP
64212: POP
64213: GO 64219
// end ;
64215: GO 64090
64217: POP
64218: POP
// end ;
64219: LD_VAR 0 6
64223: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
64224: LD_INT 0
64226: PPUSH
// if not mc_bases or not base or not weapon_list then
64227: LD_EXP 102
64231: NOT
64232: PUSH
64233: LD_VAR 0 1
64237: NOT
64238: OR
64239: PUSH
64240: LD_VAR 0 2
64244: NOT
64245: OR
64246: IFFALSE 64250
// exit ;
64248: GO 64275
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
64250: LD_ADDR_EXP 141
64254: PUSH
64255: LD_EXP 141
64259: PPUSH
64260: LD_VAR 0 1
64264: PPUSH
64265: LD_VAR 0 2
64269: PPUSH
64270: CALL_OW 1
64274: ST_TO_ADDR
// end ;
64275: LD_VAR 0 3
64279: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
64280: LD_INT 0
64282: PPUSH
// if not mc_bases or not base or not tech_list then
64283: LD_EXP 102
64287: NOT
64288: PUSH
64289: LD_VAR 0 1
64293: NOT
64294: OR
64295: PUSH
64296: LD_VAR 0 2
64300: NOT
64301: OR
64302: IFFALSE 64306
// exit ;
64304: GO 64331
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
64306: LD_ADDR_EXP 129
64310: PUSH
64311: LD_EXP 129
64315: PPUSH
64316: LD_VAR 0 1
64320: PPUSH
64321: LD_VAR 0 2
64325: PPUSH
64326: CALL_OW 1
64330: ST_TO_ADDR
// end ;
64331: LD_VAR 0 3
64335: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
64336: LD_INT 0
64338: PPUSH
// if not mc_bases or not parking_area or not base then
64339: LD_EXP 102
64343: NOT
64344: PUSH
64345: LD_VAR 0 2
64349: NOT
64350: OR
64351: PUSH
64352: LD_VAR 0 1
64356: NOT
64357: OR
64358: IFFALSE 64362
// exit ;
64360: GO 64387
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
64362: LD_ADDR_EXP 126
64366: PUSH
64367: LD_EXP 126
64371: PPUSH
64372: LD_VAR 0 1
64376: PPUSH
64377: LD_VAR 0 2
64381: PPUSH
64382: CALL_OW 1
64386: ST_TO_ADDR
// end ;
64387: LD_VAR 0 3
64391: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
64392: LD_INT 0
64394: PPUSH
// if not mc_bases or not base or not scan_area then
64395: LD_EXP 102
64399: NOT
64400: PUSH
64401: LD_VAR 0 1
64405: NOT
64406: OR
64407: PUSH
64408: LD_VAR 0 2
64412: NOT
64413: OR
64414: IFFALSE 64418
// exit ;
64416: GO 64443
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
64418: LD_ADDR_EXP 127
64422: PUSH
64423: LD_EXP 127
64427: PPUSH
64428: LD_VAR 0 1
64432: PPUSH
64433: LD_VAR 0 2
64437: PPUSH
64438: CALL_OW 1
64442: ST_TO_ADDR
// end ;
64443: LD_VAR 0 3
64447: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
64448: LD_INT 0
64450: PPUSH
64451: PPUSH
// if not mc_bases or not base then
64452: LD_EXP 102
64456: NOT
64457: PUSH
64458: LD_VAR 0 1
64462: NOT
64463: OR
64464: IFFALSE 64468
// exit ;
64466: GO 64532
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
64468: LD_ADDR_VAR 0 3
64472: PUSH
64473: LD_INT 1
64475: PUSH
64476: LD_INT 2
64478: PUSH
64479: LD_INT 3
64481: PUSH
64482: LD_INT 4
64484: PUSH
64485: LD_INT 11
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
64495: LD_ADDR_EXP 129
64499: PUSH
64500: LD_EXP 129
64504: PPUSH
64505: LD_VAR 0 1
64509: PPUSH
64510: LD_EXP 129
64514: PUSH
64515: LD_VAR 0 1
64519: ARRAY
64520: PUSH
64521: LD_VAR 0 3
64525: DIFF
64526: PPUSH
64527: CALL_OW 1
64531: ST_TO_ADDR
// end ;
64532: LD_VAR 0 2
64536: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
64537: LD_INT 0
64539: PPUSH
// result := mc_vehicles [ base ] ;
64540: LD_ADDR_VAR 0 3
64544: PUSH
64545: LD_EXP 121
64549: PUSH
64550: LD_VAR 0 1
64554: ARRAY
64555: ST_TO_ADDR
// if onlyCombat then
64556: LD_VAR 0 2
64560: IFFALSE 64732
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
64562: LD_ADDR_VAR 0 3
64566: PUSH
64567: LD_VAR 0 3
64571: PUSH
64572: LD_VAR 0 3
64576: PPUSH
64577: LD_INT 2
64579: PUSH
64580: LD_INT 34
64582: PUSH
64583: LD_INT 12
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: LD_INT 34
64592: PUSH
64593: LD_INT 51
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 34
64602: PUSH
64603: LD_INT 89
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: PUSH
64610: LD_INT 34
64612: PUSH
64613: LD_INT 32
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 34
64622: PUSH
64623: LD_INT 13
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: PUSH
64630: LD_INT 34
64632: PUSH
64633: LD_INT 52
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: PUSH
64640: LD_INT 34
64642: PUSH
64643: LD_INT 88
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 34
64652: PUSH
64653: LD_INT 14
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: LD_INT 34
64662: PUSH
64663: LD_INT 53
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: PUSH
64670: LD_INT 34
64672: PUSH
64673: LD_INT 98
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PUSH
64680: LD_INT 34
64682: PUSH
64683: LD_INT 31
64685: PUSH
64686: EMPTY
64687: LIST
64688: LIST
64689: PUSH
64690: LD_INT 34
64692: PUSH
64693: LD_INT 48
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 34
64702: PUSH
64703: LD_INT 8
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: PPUSH
64726: CALL_OW 72
64730: DIFF
64731: ST_TO_ADDR
// end ; end_of_file
64732: LD_VAR 0 3
64736: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64737: LD_INT 0
64739: PPUSH
64740: PPUSH
64741: PPUSH
// if not mc_bases or not skirmish then
64742: LD_EXP 102
64746: NOT
64747: PUSH
64748: LD_EXP 100
64752: NOT
64753: OR
64754: IFFALSE 64758
// exit ;
64756: GO 64923
// for i = 1 to mc_bases do
64758: LD_ADDR_VAR 0 4
64762: PUSH
64763: DOUBLE
64764: LD_INT 1
64766: DEC
64767: ST_TO_ADDR
64768: LD_EXP 102
64772: PUSH
64773: FOR_TO
64774: IFFALSE 64921
// begin if sci in mc_bases [ i ] then
64776: LD_VAR 0 2
64780: PUSH
64781: LD_EXP 102
64785: PUSH
64786: LD_VAR 0 4
64790: ARRAY
64791: IN
64792: IFFALSE 64919
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64794: LD_ADDR_EXP 131
64798: PUSH
64799: LD_EXP 131
64803: PPUSH
64804: LD_VAR 0 4
64808: PUSH
64809: LD_EXP 131
64813: PUSH
64814: LD_VAR 0 4
64818: ARRAY
64819: PUSH
64820: LD_INT 1
64822: PLUS
64823: PUSH
64824: EMPTY
64825: LIST
64826: LIST
64827: PPUSH
64828: LD_VAR 0 1
64832: PPUSH
64833: CALL 74507 0 3
64837: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64838: LD_ADDR_VAR 0 5
64842: PUSH
64843: LD_EXP 102
64847: PUSH
64848: LD_VAR 0 4
64852: ARRAY
64853: PPUSH
64854: LD_INT 2
64856: PUSH
64857: LD_INT 30
64859: PUSH
64860: LD_INT 0
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 30
64869: PUSH
64870: LD_INT 1
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: LIST
64881: PPUSH
64882: CALL_OW 72
64886: PPUSH
64887: LD_VAR 0 1
64891: PPUSH
64892: CALL_OW 74
64896: ST_TO_ADDR
// if tmp then
64897: LD_VAR 0 5
64901: IFFALSE 64917
// ComStandNearbyBuilding ( ape , tmp ) ;
64903: LD_VAR 0 1
64907: PPUSH
64908: LD_VAR 0 5
64912: PPUSH
64913: CALL 71109 0 2
// break ;
64917: GO 64921
// end ; end ;
64919: GO 64773
64921: POP
64922: POP
// end ;
64923: LD_VAR 0 3
64927: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64928: LD_INT 0
64930: PPUSH
64931: PPUSH
64932: PPUSH
// if not mc_bases or not skirmish then
64933: LD_EXP 102
64937: NOT
64938: PUSH
64939: LD_EXP 100
64943: NOT
64944: OR
64945: IFFALSE 64949
// exit ;
64947: GO 65038
// for i = 1 to mc_bases do
64949: LD_ADDR_VAR 0 4
64953: PUSH
64954: DOUBLE
64955: LD_INT 1
64957: DEC
64958: ST_TO_ADDR
64959: LD_EXP 102
64963: PUSH
64964: FOR_TO
64965: IFFALSE 65036
// begin if building in mc_busy_turret_list [ i ] then
64967: LD_VAR 0 1
64971: PUSH
64972: LD_EXP 112
64976: PUSH
64977: LD_VAR 0 4
64981: ARRAY
64982: IN
64983: IFFALSE 65034
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64985: LD_ADDR_VAR 0 5
64989: PUSH
64990: LD_EXP 112
64994: PUSH
64995: LD_VAR 0 4
64999: ARRAY
65000: PUSH
65001: LD_VAR 0 1
65005: DIFF
65006: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
65007: LD_ADDR_EXP 112
65011: PUSH
65012: LD_EXP 112
65016: PPUSH
65017: LD_VAR 0 4
65021: PPUSH
65022: LD_VAR 0 5
65026: PPUSH
65027: CALL_OW 1
65031: ST_TO_ADDR
// break ;
65032: GO 65036
// end ; end ;
65034: GO 64964
65036: POP
65037: POP
// end ;
65038: LD_VAR 0 3
65042: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
65043: LD_INT 0
65045: PPUSH
65046: PPUSH
65047: PPUSH
// if not mc_bases or not skirmish then
65048: LD_EXP 102
65052: NOT
65053: PUSH
65054: LD_EXP 100
65058: NOT
65059: OR
65060: IFFALSE 65064
// exit ;
65062: GO 65263
// for i = 1 to mc_bases do
65064: LD_ADDR_VAR 0 5
65068: PUSH
65069: DOUBLE
65070: LD_INT 1
65072: DEC
65073: ST_TO_ADDR
65074: LD_EXP 102
65078: PUSH
65079: FOR_TO
65080: IFFALSE 65261
// if building in mc_bases [ i ] then
65082: LD_VAR 0 1
65086: PUSH
65087: LD_EXP 102
65091: PUSH
65092: LD_VAR 0 5
65096: ARRAY
65097: IN
65098: IFFALSE 65259
// begin tmp := mc_bases [ i ] diff building ;
65100: LD_ADDR_VAR 0 6
65104: PUSH
65105: LD_EXP 102
65109: PUSH
65110: LD_VAR 0 5
65114: ARRAY
65115: PUSH
65116: LD_VAR 0 1
65120: DIFF
65121: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
65122: LD_ADDR_EXP 102
65126: PUSH
65127: LD_EXP 102
65131: PPUSH
65132: LD_VAR 0 5
65136: PPUSH
65137: LD_VAR 0 6
65141: PPUSH
65142: CALL_OW 1
65146: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
65147: LD_VAR 0 1
65151: PUSH
65152: LD_EXP 110
65156: PUSH
65157: LD_VAR 0 5
65161: ARRAY
65162: IN
65163: IFFALSE 65202
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
65165: LD_ADDR_EXP 110
65169: PUSH
65170: LD_EXP 110
65174: PPUSH
65175: LD_VAR 0 5
65179: PPUSH
65180: LD_EXP 110
65184: PUSH
65185: LD_VAR 0 5
65189: ARRAY
65190: PUSH
65191: LD_VAR 0 1
65195: DIFF
65196: PPUSH
65197: CALL_OW 1
65201: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
65202: LD_VAR 0 1
65206: PUSH
65207: LD_EXP 111
65211: PUSH
65212: LD_VAR 0 5
65216: ARRAY
65217: IN
65218: IFFALSE 65257
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
65220: LD_ADDR_EXP 111
65224: PUSH
65225: LD_EXP 111
65229: PPUSH
65230: LD_VAR 0 5
65234: PPUSH
65235: LD_EXP 111
65239: PUSH
65240: LD_VAR 0 5
65244: ARRAY
65245: PUSH
65246: LD_VAR 0 1
65250: DIFF
65251: PPUSH
65252: CALL_OW 1
65256: ST_TO_ADDR
// break ;
65257: GO 65261
// end ;
65259: GO 65079
65261: POP
65262: POP
// end ;
65263: LD_VAR 0 4
65267: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
65268: LD_INT 0
65270: PPUSH
65271: PPUSH
65272: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
65273: LD_EXP 102
65277: NOT
65278: PUSH
65279: LD_EXP 100
65283: NOT
65284: OR
65285: PUSH
65286: LD_VAR 0 3
65290: PUSH
65291: LD_EXP 128
65295: IN
65296: NOT
65297: OR
65298: IFFALSE 65302
// exit ;
65300: GO 65425
// for i = 1 to mc_vehicles do
65302: LD_ADDR_VAR 0 6
65306: PUSH
65307: DOUBLE
65308: LD_INT 1
65310: DEC
65311: ST_TO_ADDR
65312: LD_EXP 121
65316: PUSH
65317: FOR_TO
65318: IFFALSE 65423
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
65320: LD_VAR 0 2
65324: PUSH
65325: LD_EXP 121
65329: PUSH
65330: LD_VAR 0 6
65334: ARRAY
65335: IN
65336: PUSH
65337: LD_VAR 0 1
65341: PUSH
65342: LD_EXP 121
65346: PUSH
65347: LD_VAR 0 6
65351: ARRAY
65352: IN
65353: OR
65354: IFFALSE 65421
// begin tmp := mc_vehicles [ i ] diff old ;
65356: LD_ADDR_VAR 0 7
65360: PUSH
65361: LD_EXP 121
65365: PUSH
65366: LD_VAR 0 6
65370: ARRAY
65371: PUSH
65372: LD_VAR 0 2
65376: DIFF
65377: ST_TO_ADDR
// tmp := tmp diff new ;
65378: LD_ADDR_VAR 0 7
65382: PUSH
65383: LD_VAR 0 7
65387: PUSH
65388: LD_VAR 0 1
65392: DIFF
65393: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
65394: LD_ADDR_EXP 121
65398: PUSH
65399: LD_EXP 121
65403: PPUSH
65404: LD_VAR 0 6
65408: PPUSH
65409: LD_VAR 0 7
65413: PPUSH
65414: CALL_OW 1
65418: ST_TO_ADDR
// break ;
65419: GO 65423
// end ;
65421: GO 65317
65423: POP
65424: POP
// end ;
65425: LD_VAR 0 5
65429: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
65430: LD_INT 0
65432: PPUSH
65433: PPUSH
65434: PPUSH
65435: PPUSH
// if not mc_bases or not skirmish then
65436: LD_EXP 102
65440: NOT
65441: PUSH
65442: LD_EXP 100
65446: NOT
65447: OR
65448: IFFALSE 65452
// exit ;
65450: GO 65872
// repeat wait ( 0 0$1 ) ;
65452: LD_INT 35
65454: PPUSH
65455: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
65459: LD_EXP 146
65463: NOT
65464: IFFALSE 65452
// mc_block_vehicle_constructed_thread := true ;
65466: LD_ADDR_EXP 146
65470: PUSH
65471: LD_INT 1
65473: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
65474: LD_ADDR_VAR 0 5
65478: PUSH
65479: LD_VAR 0 1
65483: PPUSH
65484: CALL_OW 255
65488: ST_TO_ADDR
// for i = 1 to mc_bases do
65489: LD_ADDR_VAR 0 4
65493: PUSH
65494: DOUBLE
65495: LD_INT 1
65497: DEC
65498: ST_TO_ADDR
65499: LD_EXP 102
65503: PUSH
65504: FOR_TO
65505: IFFALSE 65862
// begin if factory in mc_bases [ i ] then
65507: LD_VAR 0 2
65511: PUSH
65512: LD_EXP 102
65516: PUSH
65517: LD_VAR 0 4
65521: ARRAY
65522: IN
65523: IFFALSE 65860
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
65525: LD_EXP 124
65529: PUSH
65530: LD_VAR 0 4
65534: ARRAY
65535: PUSH
65536: LD_EXP 113
65540: PUSH
65541: LD_VAR 0 4
65545: ARRAY
65546: LESS
65547: PUSH
65548: LD_VAR 0 1
65552: PPUSH
65553: CALL_OW 264
65557: PUSH
65558: LD_INT 31
65560: PUSH
65561: LD_INT 32
65563: PUSH
65564: LD_INT 51
65566: PUSH
65567: LD_INT 89
65569: PUSH
65570: LD_INT 12
65572: PUSH
65573: LD_INT 30
65575: PUSH
65576: LD_INT 98
65578: PUSH
65579: LD_INT 11
65581: PUSH
65582: LD_INT 53
65584: PUSH
65585: LD_INT 14
65587: PUSH
65588: LD_INT 91
65590: PUSH
65591: LD_INT 29
65593: PUSH
65594: LD_INT 99
65596: PUSH
65597: LD_INT 13
65599: PUSH
65600: LD_INT 52
65602: PUSH
65603: LD_INT 88
65605: PUSH
65606: LD_INT 48
65608: PUSH
65609: LD_INT 8
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: IN
65632: NOT
65633: AND
65634: IFFALSE 65682
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
65636: LD_ADDR_EXP 124
65640: PUSH
65641: LD_EXP 124
65645: PPUSH
65646: LD_VAR 0 4
65650: PUSH
65651: LD_EXP 124
65655: PUSH
65656: LD_VAR 0 4
65660: ARRAY
65661: PUSH
65662: LD_INT 1
65664: PLUS
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PPUSH
65670: LD_VAR 0 1
65674: PPUSH
65675: CALL 74507 0 3
65679: ST_TO_ADDR
65680: GO 65726
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65682: LD_ADDR_EXP 121
65686: PUSH
65687: LD_EXP 121
65691: PPUSH
65692: LD_VAR 0 4
65696: PUSH
65697: LD_EXP 121
65701: PUSH
65702: LD_VAR 0 4
65706: ARRAY
65707: PUSH
65708: LD_INT 1
65710: PLUS
65711: PUSH
65712: EMPTY
65713: LIST
65714: LIST
65715: PPUSH
65716: LD_VAR 0 1
65720: PPUSH
65721: CALL 74507 0 3
65725: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65726: LD_ADDR_EXP 146
65730: PUSH
65731: LD_INT 0
65733: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65734: LD_VAR 0 1
65738: PPUSH
65739: CALL_OW 263
65743: PUSH
65744: LD_INT 2
65746: EQUAL
65747: IFFALSE 65776
// begin repeat wait ( 0 0$3 ) ;
65749: LD_INT 105
65751: PPUSH
65752: CALL_OW 67
// Connect ( vehicle ) ;
65756: LD_VAR 0 1
65760: PPUSH
65761: CALL 77853 0 1
// until IsControledBy ( vehicle ) ;
65765: LD_VAR 0 1
65769: PPUSH
65770: CALL_OW 312
65774: IFFALSE 65749
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65776: LD_VAR 0 1
65780: PPUSH
65781: LD_EXP 126
65785: PUSH
65786: LD_VAR 0 4
65790: ARRAY
65791: PPUSH
65792: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65796: LD_VAR 0 1
65800: PPUSH
65801: CALL_OW 263
65805: PUSH
65806: LD_INT 1
65808: NONEQUAL
65809: IFFALSE 65813
// break ;
65811: GO 65862
// repeat wait ( 0 0$1 ) ;
65813: LD_INT 35
65815: PPUSH
65816: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65820: LD_VAR 0 1
65824: PPUSH
65825: LD_EXP 126
65829: PUSH
65830: LD_VAR 0 4
65834: ARRAY
65835: PPUSH
65836: CALL_OW 308
65840: IFFALSE 65813
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65842: LD_VAR 0 1
65846: PPUSH
65847: CALL_OW 311
65851: PPUSH
65852: CALL_OW 121
// exit ;
65856: POP
65857: POP
65858: GO 65872
// end ; end ;
65860: GO 65504
65862: POP
65863: POP
// mc_block_vehicle_constructed_thread := false ;
65864: LD_ADDR_EXP 146
65868: PUSH
65869: LD_INT 0
65871: ST_TO_ADDR
// end ;
65872: LD_VAR 0 3
65876: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65877: LD_INT 0
65879: PPUSH
65880: PPUSH
65881: PPUSH
65882: PPUSH
// if not mc_bases or not skirmish then
65883: LD_EXP 102
65887: NOT
65888: PUSH
65889: LD_EXP 100
65893: NOT
65894: OR
65895: IFFALSE 65899
// exit ;
65897: GO 66252
// repeat wait ( 0 0$1 ) ;
65899: LD_INT 35
65901: PPUSH
65902: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65906: LD_VAR 0 2
65910: PPUSH
65911: LD_VAR 0 3
65915: PPUSH
65916: CALL_OW 284
65920: IFFALSE 65899
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65922: LD_VAR 0 2
65926: PPUSH
65927: LD_VAR 0 3
65931: PPUSH
65932: CALL_OW 283
65936: PUSH
65937: LD_INT 4
65939: EQUAL
65940: IFFALSE 65944
// exit ;
65942: GO 66252
// for i = 1 to mc_bases do
65944: LD_ADDR_VAR 0 7
65948: PUSH
65949: DOUBLE
65950: LD_INT 1
65952: DEC
65953: ST_TO_ADDR
65954: LD_EXP 102
65958: PUSH
65959: FOR_TO
65960: IFFALSE 66250
// begin if mc_crates_area [ i ] then
65962: LD_EXP 120
65966: PUSH
65967: LD_VAR 0 7
65971: ARRAY
65972: IFFALSE 66083
// for j in mc_crates_area [ i ] do
65974: LD_ADDR_VAR 0 8
65978: PUSH
65979: LD_EXP 120
65983: PUSH
65984: LD_VAR 0 7
65988: ARRAY
65989: PUSH
65990: FOR_IN
65991: IFFALSE 66081
// if InArea ( x , y , j ) then
65993: LD_VAR 0 2
65997: PPUSH
65998: LD_VAR 0 3
66002: PPUSH
66003: LD_VAR 0 8
66007: PPUSH
66008: CALL_OW 309
66012: IFFALSE 66079
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66014: LD_ADDR_EXP 118
66018: PUSH
66019: LD_EXP 118
66023: PPUSH
66024: LD_VAR 0 7
66028: PUSH
66029: LD_EXP 118
66033: PUSH
66034: LD_VAR 0 7
66038: ARRAY
66039: PUSH
66040: LD_INT 1
66042: PLUS
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PPUSH
66048: LD_VAR 0 4
66052: PUSH
66053: LD_VAR 0 2
66057: PUSH
66058: LD_VAR 0 3
66062: PUSH
66063: EMPTY
66064: LIST
66065: LIST
66066: LIST
66067: PPUSH
66068: CALL 74507 0 3
66072: ST_TO_ADDR
// exit ;
66073: POP
66074: POP
66075: POP
66076: POP
66077: GO 66252
// end ;
66079: GO 65990
66081: POP
66082: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66083: LD_ADDR_VAR 0 9
66087: PUSH
66088: LD_EXP 102
66092: PUSH
66093: LD_VAR 0 7
66097: ARRAY
66098: PPUSH
66099: LD_INT 2
66101: PUSH
66102: LD_INT 30
66104: PUSH
66105: LD_INT 0
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: PUSH
66112: LD_INT 30
66114: PUSH
66115: LD_INT 1
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: LIST
66126: PPUSH
66127: CALL_OW 72
66131: ST_TO_ADDR
// if not depot then
66132: LD_VAR 0 9
66136: NOT
66137: IFFALSE 66141
// continue ;
66139: GO 65959
// for j in depot do
66141: LD_ADDR_VAR 0 8
66145: PUSH
66146: LD_VAR 0 9
66150: PUSH
66151: FOR_IN
66152: IFFALSE 66246
// if GetDistUnitXY ( j , x , y ) < 30 then
66154: LD_VAR 0 8
66158: PPUSH
66159: LD_VAR 0 2
66163: PPUSH
66164: LD_VAR 0 3
66168: PPUSH
66169: CALL_OW 297
66173: PUSH
66174: LD_INT 30
66176: LESS
66177: IFFALSE 66244
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
66179: LD_ADDR_EXP 118
66183: PUSH
66184: LD_EXP 118
66188: PPUSH
66189: LD_VAR 0 7
66193: PUSH
66194: LD_EXP 118
66198: PUSH
66199: LD_VAR 0 7
66203: ARRAY
66204: PUSH
66205: LD_INT 1
66207: PLUS
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PPUSH
66213: LD_VAR 0 4
66217: PUSH
66218: LD_VAR 0 2
66222: PUSH
66223: LD_VAR 0 3
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: LIST
66232: PPUSH
66233: CALL 74507 0 3
66237: ST_TO_ADDR
// exit ;
66238: POP
66239: POP
66240: POP
66241: POP
66242: GO 66252
// end ;
66244: GO 66151
66246: POP
66247: POP
// end ;
66248: GO 65959
66250: POP
66251: POP
// end ;
66252: LD_VAR 0 6
66256: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
66257: LD_INT 0
66259: PPUSH
66260: PPUSH
66261: PPUSH
66262: PPUSH
// if not mc_bases or not skirmish then
66263: LD_EXP 102
66267: NOT
66268: PUSH
66269: LD_EXP 100
66273: NOT
66274: OR
66275: IFFALSE 66279
// exit ;
66277: GO 66556
// side := GetSide ( lab ) ;
66279: LD_ADDR_VAR 0 4
66283: PUSH
66284: LD_VAR 0 2
66288: PPUSH
66289: CALL_OW 255
66293: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
66294: LD_VAR 0 4
66298: PUSH
66299: LD_EXP 128
66303: IN
66304: NOT
66305: PUSH
66306: LD_EXP 129
66310: NOT
66311: OR
66312: PUSH
66313: LD_EXP 102
66317: NOT
66318: OR
66319: IFFALSE 66323
// exit ;
66321: GO 66556
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
66323: LD_ADDR_EXP 129
66327: PUSH
66328: LD_EXP 129
66332: PPUSH
66333: LD_VAR 0 4
66337: PPUSH
66338: LD_EXP 129
66342: PUSH
66343: LD_VAR 0 4
66347: ARRAY
66348: PUSH
66349: LD_VAR 0 1
66353: DIFF
66354: PPUSH
66355: CALL_OW 1
66359: ST_TO_ADDR
// for i = 1 to mc_bases do
66360: LD_ADDR_VAR 0 5
66364: PUSH
66365: DOUBLE
66366: LD_INT 1
66368: DEC
66369: ST_TO_ADDR
66370: LD_EXP 102
66374: PUSH
66375: FOR_TO
66376: IFFALSE 66554
// begin if lab in mc_bases [ i ] then
66378: LD_VAR 0 2
66382: PUSH
66383: LD_EXP 102
66387: PUSH
66388: LD_VAR 0 5
66392: ARRAY
66393: IN
66394: IFFALSE 66552
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
66396: LD_VAR 0 1
66400: PUSH
66401: LD_INT 11
66403: PUSH
66404: LD_INT 4
66406: PUSH
66407: LD_INT 3
66409: PUSH
66410: LD_INT 2
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: IN
66419: PUSH
66420: LD_EXP 132
66424: PUSH
66425: LD_VAR 0 5
66429: ARRAY
66430: AND
66431: IFFALSE 66552
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
66433: LD_ADDR_VAR 0 6
66437: PUSH
66438: LD_EXP 132
66442: PUSH
66443: LD_VAR 0 5
66447: ARRAY
66448: PUSH
66449: LD_INT 1
66451: ARRAY
66452: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66453: LD_ADDR_EXP 132
66457: PUSH
66458: LD_EXP 132
66462: PPUSH
66463: LD_VAR 0 5
66467: PPUSH
66468: EMPTY
66469: PPUSH
66470: CALL_OW 1
66474: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
66475: LD_VAR 0 6
66479: PPUSH
66480: LD_INT 0
66482: PPUSH
66483: CALL_OW 109
// ComExitBuilding ( tmp ) ;
66487: LD_VAR 0 6
66491: PPUSH
66492: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
66496: LD_ADDR_EXP 131
66500: PUSH
66501: LD_EXP 131
66505: PPUSH
66506: LD_VAR 0 5
66510: PPUSH
66511: LD_EXP 131
66515: PUSH
66516: LD_VAR 0 5
66520: ARRAY
66521: PPUSH
66522: LD_INT 1
66524: PPUSH
66525: LD_VAR 0 6
66529: PPUSH
66530: CALL_OW 2
66534: PPUSH
66535: CALL_OW 1
66539: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
66540: LD_VAR 0 5
66544: PPUSH
66545: LD_INT 112
66547: PPUSH
66548: CALL 43006 0 2
// end ; end ; end ;
66552: GO 66375
66554: POP
66555: POP
// end ;
66556: LD_VAR 0 3
66560: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
66561: LD_INT 0
66563: PPUSH
66564: PPUSH
66565: PPUSH
66566: PPUSH
66567: PPUSH
66568: PPUSH
66569: PPUSH
66570: PPUSH
// if not mc_bases or not skirmish then
66571: LD_EXP 102
66575: NOT
66576: PUSH
66577: LD_EXP 100
66581: NOT
66582: OR
66583: IFFALSE 66587
// exit ;
66585: GO 67956
// for i = 1 to mc_bases do
66587: LD_ADDR_VAR 0 3
66591: PUSH
66592: DOUBLE
66593: LD_INT 1
66595: DEC
66596: ST_TO_ADDR
66597: LD_EXP 102
66601: PUSH
66602: FOR_TO
66603: IFFALSE 67954
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
66605: LD_VAR 0 1
66609: PUSH
66610: LD_EXP 102
66614: PUSH
66615: LD_VAR 0 3
66619: ARRAY
66620: IN
66621: PUSH
66622: LD_VAR 0 1
66626: PUSH
66627: LD_EXP 109
66631: PUSH
66632: LD_VAR 0 3
66636: ARRAY
66637: IN
66638: OR
66639: PUSH
66640: LD_VAR 0 1
66644: PUSH
66645: LD_EXP 124
66649: PUSH
66650: LD_VAR 0 3
66654: ARRAY
66655: IN
66656: OR
66657: PUSH
66658: LD_VAR 0 1
66662: PUSH
66663: LD_EXP 121
66667: PUSH
66668: LD_VAR 0 3
66672: ARRAY
66673: IN
66674: OR
66675: PUSH
66676: LD_VAR 0 1
66680: PUSH
66681: LD_EXP 131
66685: PUSH
66686: LD_VAR 0 3
66690: ARRAY
66691: IN
66692: OR
66693: PUSH
66694: LD_VAR 0 1
66698: PUSH
66699: LD_EXP 132
66703: PUSH
66704: LD_VAR 0 3
66708: ARRAY
66709: IN
66710: OR
66711: IFFALSE 67952
// begin if un in mc_ape [ i ] then
66713: LD_VAR 0 1
66717: PUSH
66718: LD_EXP 131
66722: PUSH
66723: LD_VAR 0 3
66727: ARRAY
66728: IN
66729: IFFALSE 66768
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66731: LD_ADDR_EXP 131
66735: PUSH
66736: LD_EXP 131
66740: PPUSH
66741: LD_VAR 0 3
66745: PPUSH
66746: LD_EXP 131
66750: PUSH
66751: LD_VAR 0 3
66755: ARRAY
66756: PUSH
66757: LD_VAR 0 1
66761: DIFF
66762: PPUSH
66763: CALL_OW 1
66767: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66768: LD_VAR 0 1
66772: PUSH
66773: LD_EXP 132
66777: PUSH
66778: LD_VAR 0 3
66782: ARRAY
66783: IN
66784: IFFALSE 66808
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66786: LD_ADDR_EXP 132
66790: PUSH
66791: LD_EXP 132
66795: PPUSH
66796: LD_VAR 0 3
66800: PPUSH
66801: EMPTY
66802: PPUSH
66803: CALL_OW 1
66807: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66808: LD_VAR 0 1
66812: PPUSH
66813: CALL_OW 247
66817: PUSH
66818: LD_INT 2
66820: EQUAL
66821: PUSH
66822: LD_VAR 0 1
66826: PPUSH
66827: CALL_OW 110
66831: PUSH
66832: LD_INT 20
66834: EQUAL
66835: PUSH
66836: LD_VAR 0 1
66840: PUSH
66841: LD_EXP 124
66845: PUSH
66846: LD_VAR 0 3
66850: ARRAY
66851: IN
66852: OR
66853: PUSH
66854: LD_VAR 0 1
66858: PPUSH
66859: CALL_OW 264
66863: PUSH
66864: LD_INT 12
66866: PUSH
66867: LD_INT 51
66869: PUSH
66870: LD_INT 89
66872: PUSH
66873: LD_INT 32
66875: PUSH
66876: LD_INT 13
66878: PUSH
66879: LD_INT 52
66881: PUSH
66882: LD_INT 31
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: IN
66894: OR
66895: AND
66896: IFFALSE 67204
// begin if un in mc_defender [ i ] then
66898: LD_VAR 0 1
66902: PUSH
66903: LD_EXP 124
66907: PUSH
66908: LD_VAR 0 3
66912: ARRAY
66913: IN
66914: IFFALSE 66953
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66916: LD_ADDR_EXP 124
66920: PUSH
66921: LD_EXP 124
66925: PPUSH
66926: LD_VAR 0 3
66930: PPUSH
66931: LD_EXP 124
66935: PUSH
66936: LD_VAR 0 3
66940: ARRAY
66941: PUSH
66942: LD_VAR 0 1
66946: DIFF
66947: PPUSH
66948: CALL_OW 1
66952: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66953: LD_ADDR_VAR 0 8
66957: PUSH
66958: LD_VAR 0 3
66962: PPUSH
66963: LD_INT 3
66965: PPUSH
66966: CALL 63574 0 2
66970: ST_TO_ADDR
// if fac then
66971: LD_VAR 0 8
66975: IFFALSE 67204
// begin for j in fac do
66977: LD_ADDR_VAR 0 4
66981: PUSH
66982: LD_VAR 0 8
66986: PUSH
66987: FOR_IN
66988: IFFALSE 67202
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66990: LD_ADDR_VAR 0 9
66994: PUSH
66995: LD_VAR 0 8
66999: PPUSH
67000: LD_VAR 0 1
67004: PPUSH
67005: CALL_OW 265
67009: PPUSH
67010: LD_VAR 0 1
67014: PPUSH
67015: CALL_OW 262
67019: PPUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL_OW 263
67029: PPUSH
67030: LD_VAR 0 1
67034: PPUSH
67035: CALL_OW 264
67039: PPUSH
67040: CALL 72005 0 5
67044: ST_TO_ADDR
// if components then
67045: LD_VAR 0 9
67049: IFFALSE 67200
// begin if GetWeapon ( un ) = ar_control_tower then
67051: LD_VAR 0 1
67055: PPUSH
67056: CALL_OW 264
67060: PUSH
67061: LD_INT 31
67063: EQUAL
67064: IFFALSE 67181
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
67066: LD_VAR 0 1
67070: PPUSH
67071: CALL_OW 311
67075: PPUSH
67076: LD_INT 0
67078: PPUSH
67079: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
67083: LD_ADDR_EXP 142
67087: PUSH
67088: LD_EXP 142
67092: PPUSH
67093: LD_VAR 0 3
67097: PPUSH
67098: LD_EXP 142
67102: PUSH
67103: LD_VAR 0 3
67107: ARRAY
67108: PUSH
67109: LD_VAR 0 1
67113: PPUSH
67114: CALL_OW 311
67118: DIFF
67119: PPUSH
67120: CALL_OW 1
67124: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
67125: LD_ADDR_VAR 0 7
67129: PUSH
67130: LD_EXP 123
67134: PUSH
67135: LD_VAR 0 3
67139: ARRAY
67140: PPUSH
67141: LD_INT 1
67143: PPUSH
67144: LD_VAR 0 9
67148: PPUSH
67149: CALL_OW 2
67153: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67154: LD_ADDR_EXP 123
67158: PUSH
67159: LD_EXP 123
67163: PPUSH
67164: LD_VAR 0 3
67168: PPUSH
67169: LD_VAR 0 7
67173: PPUSH
67174: CALL_OW 1
67178: ST_TO_ADDR
// end else
67179: GO 67198
// MC_InsertProduceList ( i , [ components ] ) ;
67181: LD_VAR 0 3
67185: PPUSH
67186: LD_VAR 0 9
67190: PUSH
67191: EMPTY
67192: LIST
67193: PPUSH
67194: CALL 63119 0 2
// break ;
67198: GO 67202
// end ; end ;
67200: GO 66987
67202: POP
67203: POP
// end ; end ; if GetType ( un ) = unit_building then
67204: LD_VAR 0 1
67208: PPUSH
67209: CALL_OW 247
67213: PUSH
67214: LD_INT 3
67216: EQUAL
67217: IFFALSE 67620
// begin btype := GetBType ( un ) ;
67219: LD_ADDR_VAR 0 5
67223: PUSH
67224: LD_VAR 0 1
67228: PPUSH
67229: CALL_OW 266
67233: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
67234: LD_VAR 0 5
67238: PUSH
67239: LD_INT 29
67241: PUSH
67242: LD_INT 30
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: IN
67249: IFFALSE 67322
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
67251: LD_VAR 0 1
67255: PPUSH
67256: CALL_OW 250
67260: PPUSH
67261: LD_VAR 0 1
67265: PPUSH
67266: CALL_OW 251
67270: PPUSH
67271: LD_VAR 0 1
67275: PPUSH
67276: CALL_OW 255
67280: PPUSH
67281: CALL_OW 440
67285: NOT
67286: IFFALSE 67322
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
67288: LD_VAR 0 1
67292: PPUSH
67293: CALL_OW 250
67297: PPUSH
67298: LD_VAR 0 1
67302: PPUSH
67303: CALL_OW 251
67307: PPUSH
67308: LD_VAR 0 1
67312: PPUSH
67313: CALL_OW 255
67317: PPUSH
67318: CALL_OW 441
// end ; if btype = b_warehouse then
67322: LD_VAR 0 5
67326: PUSH
67327: LD_INT 1
67329: EQUAL
67330: IFFALSE 67348
// begin btype := b_depot ;
67332: LD_ADDR_VAR 0 5
67336: PUSH
67337: LD_INT 0
67339: ST_TO_ADDR
// pos := 1 ;
67340: LD_ADDR_VAR 0 6
67344: PUSH
67345: LD_INT 1
67347: ST_TO_ADDR
// end ; if btype = b_factory then
67348: LD_VAR 0 5
67352: PUSH
67353: LD_INT 3
67355: EQUAL
67356: IFFALSE 67374
// begin btype := b_workshop ;
67358: LD_ADDR_VAR 0 5
67362: PUSH
67363: LD_INT 2
67365: ST_TO_ADDR
// pos := 1 ;
67366: LD_ADDR_VAR 0 6
67370: PUSH
67371: LD_INT 1
67373: ST_TO_ADDR
// end ; if btype = b_barracks then
67374: LD_VAR 0 5
67378: PUSH
67379: LD_INT 5
67381: EQUAL
67382: IFFALSE 67392
// btype := b_armoury ;
67384: LD_ADDR_VAR 0 5
67388: PUSH
67389: LD_INT 4
67391: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
67392: LD_VAR 0 5
67396: PUSH
67397: LD_INT 7
67399: PUSH
67400: LD_INT 8
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: IN
67407: IFFALSE 67417
// btype := b_lab ;
67409: LD_ADDR_VAR 0 5
67413: PUSH
67414: LD_INT 6
67416: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
67417: LD_ADDR_EXP 107
67421: PUSH
67422: LD_EXP 107
67426: PPUSH
67427: LD_VAR 0 3
67431: PUSH
67432: LD_EXP 107
67436: PUSH
67437: LD_VAR 0 3
67441: ARRAY
67442: PUSH
67443: LD_INT 1
67445: PLUS
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PPUSH
67451: LD_VAR 0 5
67455: PUSH
67456: LD_VAR 0 1
67460: PPUSH
67461: CALL_OW 250
67465: PUSH
67466: LD_VAR 0 1
67470: PPUSH
67471: CALL_OW 251
67475: PUSH
67476: LD_VAR 0 1
67480: PPUSH
67481: CALL_OW 254
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: PPUSH
67492: CALL 74507 0 3
67496: ST_TO_ADDR
// if pos = 1 then
67497: LD_VAR 0 6
67501: PUSH
67502: LD_INT 1
67504: EQUAL
67505: IFFALSE 67620
// begin tmp := mc_build_list [ i ] ;
67507: LD_ADDR_VAR 0 7
67511: PUSH
67512: LD_EXP 107
67516: PUSH
67517: LD_VAR 0 3
67521: ARRAY
67522: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67523: LD_VAR 0 7
67527: PPUSH
67528: LD_INT 2
67530: PUSH
67531: LD_INT 30
67533: PUSH
67534: LD_INT 0
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 30
67543: PUSH
67544: LD_INT 1
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: EMPTY
67552: LIST
67553: LIST
67554: LIST
67555: PPUSH
67556: CALL_OW 72
67560: IFFALSE 67570
// pos := 2 ;
67562: LD_ADDR_VAR 0 6
67566: PUSH
67567: LD_INT 2
67569: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
67570: LD_ADDR_VAR 0 7
67574: PUSH
67575: LD_VAR 0 7
67579: PPUSH
67580: LD_VAR 0 6
67584: PPUSH
67585: LD_VAR 0 7
67589: PPUSH
67590: CALL 74833 0 3
67594: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
67595: LD_ADDR_EXP 107
67599: PUSH
67600: LD_EXP 107
67604: PPUSH
67605: LD_VAR 0 3
67609: PPUSH
67610: LD_VAR 0 7
67614: PPUSH
67615: CALL_OW 1
67619: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
67620: LD_VAR 0 1
67624: PUSH
67625: LD_EXP 102
67629: PUSH
67630: LD_VAR 0 3
67634: ARRAY
67635: IN
67636: IFFALSE 67675
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
67638: LD_ADDR_EXP 102
67642: PUSH
67643: LD_EXP 102
67647: PPUSH
67648: LD_VAR 0 3
67652: PPUSH
67653: LD_EXP 102
67657: PUSH
67658: LD_VAR 0 3
67662: ARRAY
67663: PUSH
67664: LD_VAR 0 1
67668: DIFF
67669: PPUSH
67670: CALL_OW 1
67674: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67675: LD_VAR 0 1
67679: PUSH
67680: LD_EXP 109
67684: PUSH
67685: LD_VAR 0 3
67689: ARRAY
67690: IN
67691: IFFALSE 67730
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67693: LD_ADDR_EXP 109
67697: PUSH
67698: LD_EXP 109
67702: PPUSH
67703: LD_VAR 0 3
67707: PPUSH
67708: LD_EXP 109
67712: PUSH
67713: LD_VAR 0 3
67717: ARRAY
67718: PUSH
67719: LD_VAR 0 1
67723: DIFF
67724: PPUSH
67725: CALL_OW 1
67729: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67730: LD_VAR 0 1
67734: PUSH
67735: LD_EXP 121
67739: PUSH
67740: LD_VAR 0 3
67744: ARRAY
67745: IN
67746: IFFALSE 67785
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67748: LD_ADDR_EXP 121
67752: PUSH
67753: LD_EXP 121
67757: PPUSH
67758: LD_VAR 0 3
67762: PPUSH
67763: LD_EXP 121
67767: PUSH
67768: LD_VAR 0 3
67772: ARRAY
67773: PUSH
67774: LD_VAR 0 1
67778: DIFF
67779: PPUSH
67780: CALL_OW 1
67784: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67785: LD_VAR 0 1
67789: PUSH
67790: LD_EXP 124
67794: PUSH
67795: LD_VAR 0 3
67799: ARRAY
67800: IN
67801: IFFALSE 67840
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67803: LD_ADDR_EXP 124
67807: PUSH
67808: LD_EXP 124
67812: PPUSH
67813: LD_VAR 0 3
67817: PPUSH
67818: LD_EXP 124
67822: PUSH
67823: LD_VAR 0 3
67827: ARRAY
67828: PUSH
67829: LD_VAR 0 1
67833: DIFF
67834: PPUSH
67835: CALL_OW 1
67839: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67840: LD_VAR 0 1
67844: PUSH
67845: LD_EXP 111
67849: PUSH
67850: LD_VAR 0 3
67854: ARRAY
67855: IN
67856: IFFALSE 67895
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67858: LD_ADDR_EXP 111
67862: PUSH
67863: LD_EXP 111
67867: PPUSH
67868: LD_VAR 0 3
67872: PPUSH
67873: LD_EXP 111
67877: PUSH
67878: LD_VAR 0 3
67882: ARRAY
67883: PUSH
67884: LD_VAR 0 1
67888: DIFF
67889: PPUSH
67890: CALL_OW 1
67894: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67895: LD_VAR 0 1
67899: PUSH
67900: LD_EXP 110
67904: PUSH
67905: LD_VAR 0 3
67909: ARRAY
67910: IN
67911: IFFALSE 67950
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67913: LD_ADDR_EXP 110
67917: PUSH
67918: LD_EXP 110
67922: PPUSH
67923: LD_VAR 0 3
67927: PPUSH
67928: LD_EXP 110
67932: PUSH
67933: LD_VAR 0 3
67937: ARRAY
67938: PUSH
67939: LD_VAR 0 1
67943: DIFF
67944: PPUSH
67945: CALL_OW 1
67949: ST_TO_ADDR
// end ; break ;
67950: GO 67954
// end ;
67952: GO 66602
67954: POP
67955: POP
// end ;
67956: LD_VAR 0 2
67960: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67961: LD_INT 0
67963: PPUSH
67964: PPUSH
67965: PPUSH
// if not mc_bases or not skirmish then
67966: LD_EXP 102
67970: NOT
67971: PUSH
67972: LD_EXP 100
67976: NOT
67977: OR
67978: IFFALSE 67982
// exit ;
67980: GO 68197
// for i = 1 to mc_bases do
67982: LD_ADDR_VAR 0 3
67986: PUSH
67987: DOUBLE
67988: LD_INT 1
67990: DEC
67991: ST_TO_ADDR
67992: LD_EXP 102
67996: PUSH
67997: FOR_TO
67998: IFFALSE 68195
// begin if building in mc_construct_list [ i ] then
68000: LD_VAR 0 1
68004: PUSH
68005: LD_EXP 109
68009: PUSH
68010: LD_VAR 0 3
68014: ARRAY
68015: IN
68016: IFFALSE 68193
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68018: LD_ADDR_EXP 109
68022: PUSH
68023: LD_EXP 109
68027: PPUSH
68028: LD_VAR 0 3
68032: PPUSH
68033: LD_EXP 109
68037: PUSH
68038: LD_VAR 0 3
68042: ARRAY
68043: PUSH
68044: LD_VAR 0 1
68048: DIFF
68049: PPUSH
68050: CALL_OW 1
68054: ST_TO_ADDR
// if building in mc_lab [ i ] then
68055: LD_VAR 0 1
68059: PUSH
68060: LD_EXP 135
68064: PUSH
68065: LD_VAR 0 3
68069: ARRAY
68070: IN
68071: IFFALSE 68126
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
68073: LD_ADDR_EXP 136
68077: PUSH
68078: LD_EXP 136
68082: PPUSH
68083: LD_VAR 0 3
68087: PPUSH
68088: LD_EXP 136
68092: PUSH
68093: LD_VAR 0 3
68097: ARRAY
68098: PPUSH
68099: LD_INT 1
68101: PPUSH
68102: LD_EXP 136
68106: PUSH
68107: LD_VAR 0 3
68111: ARRAY
68112: PPUSH
68113: LD_INT 0
68115: PPUSH
68116: CALL 73925 0 4
68120: PPUSH
68121: CALL_OW 1
68125: ST_TO_ADDR
// if not building in mc_bases [ i ] then
68126: LD_VAR 0 1
68130: PUSH
68131: LD_EXP 102
68135: PUSH
68136: LD_VAR 0 3
68140: ARRAY
68141: IN
68142: NOT
68143: IFFALSE 68189
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68145: LD_ADDR_EXP 102
68149: PUSH
68150: LD_EXP 102
68154: PPUSH
68155: LD_VAR 0 3
68159: PUSH
68160: LD_EXP 102
68164: PUSH
68165: LD_VAR 0 3
68169: ARRAY
68170: PUSH
68171: LD_INT 1
68173: PLUS
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PPUSH
68179: LD_VAR 0 1
68183: PPUSH
68184: CALL 74507 0 3
68188: ST_TO_ADDR
// exit ;
68189: POP
68190: POP
68191: GO 68197
// end ; end ;
68193: GO 67997
68195: POP
68196: POP
// end ;
68197: LD_VAR 0 2
68201: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
68202: LD_INT 0
68204: PPUSH
68205: PPUSH
68206: PPUSH
68207: PPUSH
68208: PPUSH
68209: PPUSH
68210: PPUSH
// if not mc_bases or not skirmish then
68211: LD_EXP 102
68215: NOT
68216: PUSH
68217: LD_EXP 100
68221: NOT
68222: OR
68223: IFFALSE 68227
// exit ;
68225: GO 68888
// for i = 1 to mc_bases do
68227: LD_ADDR_VAR 0 3
68231: PUSH
68232: DOUBLE
68233: LD_INT 1
68235: DEC
68236: ST_TO_ADDR
68237: LD_EXP 102
68241: PUSH
68242: FOR_TO
68243: IFFALSE 68886
// begin if building in mc_construct_list [ i ] then
68245: LD_VAR 0 1
68249: PUSH
68250: LD_EXP 109
68254: PUSH
68255: LD_VAR 0 3
68259: ARRAY
68260: IN
68261: IFFALSE 68884
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
68263: LD_ADDR_EXP 109
68267: PUSH
68268: LD_EXP 109
68272: PPUSH
68273: LD_VAR 0 3
68277: PPUSH
68278: LD_EXP 109
68282: PUSH
68283: LD_VAR 0 3
68287: ARRAY
68288: PUSH
68289: LD_VAR 0 1
68293: DIFF
68294: PPUSH
68295: CALL_OW 1
68299: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
68300: LD_ADDR_EXP 102
68304: PUSH
68305: LD_EXP 102
68309: PPUSH
68310: LD_VAR 0 3
68314: PUSH
68315: LD_EXP 102
68319: PUSH
68320: LD_VAR 0 3
68324: ARRAY
68325: PUSH
68326: LD_INT 1
68328: PLUS
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PPUSH
68334: LD_VAR 0 1
68338: PPUSH
68339: CALL 74507 0 3
68343: ST_TO_ADDR
// btype := GetBType ( building ) ;
68344: LD_ADDR_VAR 0 5
68348: PUSH
68349: LD_VAR 0 1
68353: PPUSH
68354: CALL_OW 266
68358: ST_TO_ADDR
// side := GetSide ( building ) ;
68359: LD_ADDR_VAR 0 8
68363: PUSH
68364: LD_VAR 0 1
68368: PPUSH
68369: CALL_OW 255
68373: ST_TO_ADDR
// if btype = b_lab then
68374: LD_VAR 0 5
68378: PUSH
68379: LD_INT 6
68381: EQUAL
68382: IFFALSE 68432
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
68384: LD_ADDR_EXP 135
68388: PUSH
68389: LD_EXP 135
68393: PPUSH
68394: LD_VAR 0 3
68398: PUSH
68399: LD_EXP 135
68403: PUSH
68404: LD_VAR 0 3
68408: ARRAY
68409: PUSH
68410: LD_INT 1
68412: PLUS
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PPUSH
68418: LD_VAR 0 1
68422: PPUSH
68423: CALL 74507 0 3
68427: ST_TO_ADDR
// exit ;
68428: POP
68429: POP
68430: GO 68888
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
68432: LD_VAR 0 5
68436: PUSH
68437: LD_INT 0
68439: PUSH
68440: LD_INT 2
68442: PUSH
68443: LD_INT 4
68445: PUSH
68446: EMPTY
68447: LIST
68448: LIST
68449: LIST
68450: IN
68451: IFFALSE 68575
// begin if btype = b_armoury then
68453: LD_VAR 0 5
68457: PUSH
68458: LD_INT 4
68460: EQUAL
68461: IFFALSE 68471
// btype := b_barracks ;
68463: LD_ADDR_VAR 0 5
68467: PUSH
68468: LD_INT 5
68470: ST_TO_ADDR
// if btype = b_depot then
68471: LD_VAR 0 5
68475: PUSH
68476: LD_INT 0
68478: EQUAL
68479: IFFALSE 68489
// btype := b_warehouse ;
68481: LD_ADDR_VAR 0 5
68485: PUSH
68486: LD_INT 1
68488: ST_TO_ADDR
// if btype = b_workshop then
68489: LD_VAR 0 5
68493: PUSH
68494: LD_INT 2
68496: EQUAL
68497: IFFALSE 68507
// btype := b_factory ;
68499: LD_ADDR_VAR 0 5
68503: PUSH
68504: LD_INT 3
68506: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
68507: LD_VAR 0 5
68511: PPUSH
68512: LD_VAR 0 8
68516: PPUSH
68517: CALL_OW 323
68521: PUSH
68522: LD_INT 1
68524: EQUAL
68525: IFFALSE 68571
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
68527: LD_ADDR_EXP 134
68531: PUSH
68532: LD_EXP 134
68536: PPUSH
68537: LD_VAR 0 3
68541: PUSH
68542: LD_EXP 134
68546: PUSH
68547: LD_VAR 0 3
68551: ARRAY
68552: PUSH
68553: LD_INT 1
68555: PLUS
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PPUSH
68561: LD_VAR 0 1
68565: PPUSH
68566: CALL 74507 0 3
68570: ST_TO_ADDR
// exit ;
68571: POP
68572: POP
68573: GO 68888
// end ; if btype in [ b_bunker , b_turret ] then
68575: LD_VAR 0 5
68579: PUSH
68580: LD_INT 32
68582: PUSH
68583: LD_INT 33
68585: PUSH
68586: EMPTY
68587: LIST
68588: LIST
68589: IN
68590: IFFALSE 68880
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
68592: LD_ADDR_EXP 110
68596: PUSH
68597: LD_EXP 110
68601: PPUSH
68602: LD_VAR 0 3
68606: PUSH
68607: LD_EXP 110
68611: PUSH
68612: LD_VAR 0 3
68616: ARRAY
68617: PUSH
68618: LD_INT 1
68620: PLUS
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PPUSH
68626: LD_VAR 0 1
68630: PPUSH
68631: CALL 74507 0 3
68635: ST_TO_ADDR
// if btype = b_bunker then
68636: LD_VAR 0 5
68640: PUSH
68641: LD_INT 32
68643: EQUAL
68644: IFFALSE 68880
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68646: LD_ADDR_EXP 111
68650: PUSH
68651: LD_EXP 111
68655: PPUSH
68656: LD_VAR 0 3
68660: PUSH
68661: LD_EXP 111
68665: PUSH
68666: LD_VAR 0 3
68670: ARRAY
68671: PUSH
68672: LD_INT 1
68674: PLUS
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PPUSH
68680: LD_VAR 0 1
68684: PPUSH
68685: CALL 74507 0 3
68689: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68690: LD_ADDR_VAR 0 6
68694: PUSH
68695: LD_EXP 102
68699: PUSH
68700: LD_VAR 0 3
68704: ARRAY
68705: PPUSH
68706: LD_INT 25
68708: PUSH
68709: LD_INT 1
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 3
68718: PUSH
68719: LD_INT 54
68721: PUSH
68722: EMPTY
68723: LIST
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PPUSH
68733: CALL_OW 72
68737: ST_TO_ADDR
// if tmp then
68738: LD_VAR 0 6
68742: IFFALSE 68748
// exit ;
68744: POP
68745: POP
68746: GO 68888
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68748: LD_ADDR_VAR 0 6
68752: PUSH
68753: LD_EXP 102
68757: PUSH
68758: LD_VAR 0 3
68762: ARRAY
68763: PPUSH
68764: LD_INT 2
68766: PUSH
68767: LD_INT 30
68769: PUSH
68770: LD_INT 4
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 30
68779: PUSH
68780: LD_INT 5
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: LIST
68791: PPUSH
68792: CALL_OW 72
68796: ST_TO_ADDR
// if not tmp then
68797: LD_VAR 0 6
68801: NOT
68802: IFFALSE 68808
// exit ;
68804: POP
68805: POP
68806: GO 68888
// for j in tmp do
68808: LD_ADDR_VAR 0 4
68812: PUSH
68813: LD_VAR 0 6
68817: PUSH
68818: FOR_IN
68819: IFFALSE 68878
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68821: LD_ADDR_VAR 0 7
68825: PUSH
68826: LD_VAR 0 4
68830: PPUSH
68831: CALL_OW 313
68835: PPUSH
68836: LD_INT 25
68838: PUSH
68839: LD_INT 1
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PPUSH
68846: CALL_OW 72
68850: ST_TO_ADDR
// if units then
68851: LD_VAR 0 7
68855: IFFALSE 68876
// begin ComExitBuilding ( units [ 1 ] ) ;
68857: LD_VAR 0 7
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: PPUSH
68866: CALL_OW 122
// exit ;
68870: POP
68871: POP
68872: POP
68873: POP
68874: GO 68888
// end ; end ;
68876: GO 68818
68878: POP
68879: POP
// end ; end ; exit ;
68880: POP
68881: POP
68882: GO 68888
// end ; end ;
68884: GO 68242
68886: POP
68887: POP
// end ;
68888: LD_VAR 0 2
68892: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68893: LD_INT 0
68895: PPUSH
68896: PPUSH
68897: PPUSH
68898: PPUSH
68899: PPUSH
68900: PPUSH
68901: PPUSH
// if not mc_bases or not skirmish then
68902: LD_EXP 102
68906: NOT
68907: PUSH
68908: LD_EXP 100
68912: NOT
68913: OR
68914: IFFALSE 68918
// exit ;
68916: GO 69183
// btype := GetBType ( building ) ;
68918: LD_ADDR_VAR 0 6
68922: PUSH
68923: LD_VAR 0 1
68927: PPUSH
68928: CALL_OW 266
68932: ST_TO_ADDR
// x := GetX ( building ) ;
68933: LD_ADDR_VAR 0 7
68937: PUSH
68938: LD_VAR 0 1
68942: PPUSH
68943: CALL_OW 250
68947: ST_TO_ADDR
// y := GetY ( building ) ;
68948: LD_ADDR_VAR 0 8
68952: PUSH
68953: LD_VAR 0 1
68957: PPUSH
68958: CALL_OW 251
68962: ST_TO_ADDR
// d := GetDir ( building ) ;
68963: LD_ADDR_VAR 0 9
68967: PUSH
68968: LD_VAR 0 1
68972: PPUSH
68973: CALL_OW 254
68977: ST_TO_ADDR
// for i = 1 to mc_bases do
68978: LD_ADDR_VAR 0 4
68982: PUSH
68983: DOUBLE
68984: LD_INT 1
68986: DEC
68987: ST_TO_ADDR
68988: LD_EXP 102
68992: PUSH
68993: FOR_TO
68994: IFFALSE 69181
// begin if not mc_build_list [ i ] then
68996: LD_EXP 107
69000: PUSH
69001: LD_VAR 0 4
69005: ARRAY
69006: NOT
69007: IFFALSE 69011
// continue ;
69009: GO 68993
// for j := 1 to mc_build_list [ i ] do
69011: LD_ADDR_VAR 0 5
69015: PUSH
69016: DOUBLE
69017: LD_INT 1
69019: DEC
69020: ST_TO_ADDR
69021: LD_EXP 107
69025: PUSH
69026: LD_VAR 0 4
69030: ARRAY
69031: PUSH
69032: FOR_TO
69033: IFFALSE 69177
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
69035: LD_VAR 0 6
69039: PUSH
69040: LD_VAR 0 7
69044: PUSH
69045: LD_VAR 0 8
69049: PUSH
69050: LD_VAR 0 9
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: LIST
69059: LIST
69060: PPUSH
69061: LD_EXP 107
69065: PUSH
69066: LD_VAR 0 4
69070: ARRAY
69071: PUSH
69072: LD_VAR 0 5
69076: ARRAY
69077: PPUSH
69078: CALL 81064 0 2
69082: IFFALSE 69175
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
69084: LD_ADDR_EXP 107
69088: PUSH
69089: LD_EXP 107
69093: PPUSH
69094: LD_VAR 0 4
69098: PPUSH
69099: LD_EXP 107
69103: PUSH
69104: LD_VAR 0 4
69108: ARRAY
69109: PPUSH
69110: LD_VAR 0 5
69114: PPUSH
69115: CALL_OW 3
69119: PPUSH
69120: CALL_OW 1
69124: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
69125: LD_ADDR_EXP 109
69129: PUSH
69130: LD_EXP 109
69134: PPUSH
69135: LD_VAR 0 4
69139: PUSH
69140: LD_EXP 109
69144: PUSH
69145: LD_VAR 0 4
69149: ARRAY
69150: PUSH
69151: LD_INT 1
69153: PLUS
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PPUSH
69159: LD_VAR 0 1
69163: PPUSH
69164: CALL 74507 0 3
69168: ST_TO_ADDR
// exit ;
69169: POP
69170: POP
69171: POP
69172: POP
69173: GO 69183
// end ;
69175: GO 69032
69177: POP
69178: POP
// end ;
69179: GO 68993
69181: POP
69182: POP
// end ;
69183: LD_VAR 0 3
69187: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
69188: LD_INT 0
69190: PPUSH
69191: PPUSH
69192: PPUSH
// if not mc_bases or not skirmish then
69193: LD_EXP 102
69197: NOT
69198: PUSH
69199: LD_EXP 100
69203: NOT
69204: OR
69205: IFFALSE 69209
// exit ;
69207: GO 69399
// for i = 1 to mc_bases do
69209: LD_ADDR_VAR 0 4
69213: PUSH
69214: DOUBLE
69215: LD_INT 1
69217: DEC
69218: ST_TO_ADDR
69219: LD_EXP 102
69223: PUSH
69224: FOR_TO
69225: IFFALSE 69312
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
69227: LD_VAR 0 1
69231: PUSH
69232: LD_EXP 110
69236: PUSH
69237: LD_VAR 0 4
69241: ARRAY
69242: IN
69243: PUSH
69244: LD_VAR 0 1
69248: PUSH
69249: LD_EXP 111
69253: PUSH
69254: LD_VAR 0 4
69258: ARRAY
69259: IN
69260: NOT
69261: AND
69262: IFFALSE 69310
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
69264: LD_ADDR_EXP 111
69268: PUSH
69269: LD_EXP 111
69273: PPUSH
69274: LD_VAR 0 4
69278: PUSH
69279: LD_EXP 111
69283: PUSH
69284: LD_VAR 0 4
69288: ARRAY
69289: PUSH
69290: LD_INT 1
69292: PLUS
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PPUSH
69298: LD_VAR 0 1
69302: PPUSH
69303: CALL 74507 0 3
69307: ST_TO_ADDR
// break ;
69308: GO 69312
// end ; end ;
69310: GO 69224
69312: POP
69313: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
69314: LD_VAR 0 1
69318: PPUSH
69319: CALL_OW 257
69323: PUSH
69324: LD_EXP 128
69328: IN
69329: PUSH
69330: LD_VAR 0 1
69334: PPUSH
69335: CALL_OW 266
69339: PUSH
69340: LD_INT 5
69342: EQUAL
69343: AND
69344: PUSH
69345: LD_VAR 0 2
69349: PPUSH
69350: CALL_OW 110
69354: PUSH
69355: LD_INT 18
69357: NONEQUAL
69358: AND
69359: IFFALSE 69399
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
69361: LD_VAR 0 2
69365: PPUSH
69366: CALL_OW 257
69370: PUSH
69371: LD_INT 5
69373: PUSH
69374: LD_INT 8
69376: PUSH
69377: LD_INT 9
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: LIST
69384: IN
69385: IFFALSE 69399
// SetClass ( unit , 1 ) ;
69387: LD_VAR 0 2
69391: PPUSH
69392: LD_INT 1
69394: PPUSH
69395: CALL_OW 336
// end ;
69399: LD_VAR 0 3
69403: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
69404: LD_INT 0
69406: PPUSH
69407: PPUSH
// if not mc_bases or not skirmish then
69408: LD_EXP 102
69412: NOT
69413: PUSH
69414: LD_EXP 100
69418: NOT
69419: OR
69420: IFFALSE 69424
// exit ;
69422: GO 69540
// if GetLives ( abandoned_vehicle ) > 250 then
69424: LD_VAR 0 2
69428: PPUSH
69429: CALL_OW 256
69433: PUSH
69434: LD_INT 250
69436: GREATER
69437: IFFALSE 69441
// exit ;
69439: GO 69540
// for i = 1 to mc_bases do
69441: LD_ADDR_VAR 0 6
69445: PUSH
69446: DOUBLE
69447: LD_INT 1
69449: DEC
69450: ST_TO_ADDR
69451: LD_EXP 102
69455: PUSH
69456: FOR_TO
69457: IFFALSE 69538
// begin if driver in mc_bases [ i ] then
69459: LD_VAR 0 1
69463: PUSH
69464: LD_EXP 102
69468: PUSH
69469: LD_VAR 0 6
69473: ARRAY
69474: IN
69475: IFFALSE 69536
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
69477: LD_VAR 0 1
69481: PPUSH
69482: LD_EXP 102
69486: PUSH
69487: LD_VAR 0 6
69491: ARRAY
69492: PPUSH
69493: LD_INT 2
69495: PUSH
69496: LD_INT 30
69498: PUSH
69499: LD_INT 0
69501: PUSH
69502: EMPTY
69503: LIST
69504: LIST
69505: PUSH
69506: LD_INT 30
69508: PUSH
69509: LD_INT 1
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: LIST
69520: PPUSH
69521: CALL_OW 72
69525: PUSH
69526: LD_INT 1
69528: ARRAY
69529: PPUSH
69530: CALL 108113 0 2
// break ;
69534: GO 69538
// end ; end ;
69536: GO 69456
69538: POP
69539: POP
// end ; end_of_file
69540: LD_VAR 0 5
69544: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
69545: LD_INT 0
69547: PPUSH
69548: PPUSH
// if exist_mode then
69549: LD_VAR 0 2
69553: IFFALSE 69578
// unit := CreateCharacter ( prefix & ident ) else
69555: LD_ADDR_VAR 0 5
69559: PUSH
69560: LD_VAR 0 3
69564: PUSH
69565: LD_VAR 0 1
69569: STR
69570: PPUSH
69571: CALL_OW 34
69575: ST_TO_ADDR
69576: GO 69593
// unit := NewCharacter ( ident ) ;
69578: LD_ADDR_VAR 0 5
69582: PUSH
69583: LD_VAR 0 1
69587: PPUSH
69588: CALL_OW 25
69592: ST_TO_ADDR
// result := unit ;
69593: LD_ADDR_VAR 0 4
69597: PUSH
69598: LD_VAR 0 5
69602: ST_TO_ADDR
// end ;
69603: LD_VAR 0 4
69607: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
69608: LD_INT 0
69610: PPUSH
69611: PPUSH
// if not side or not nation then
69612: LD_VAR 0 1
69616: NOT
69617: PUSH
69618: LD_VAR 0 2
69622: NOT
69623: OR
69624: IFFALSE 69628
// exit ;
69626: GO 70396
// case nation of nation_american :
69628: LD_VAR 0 2
69632: PUSH
69633: LD_INT 1
69635: DOUBLE
69636: EQUAL
69637: IFTRUE 69641
69639: GO 69855
69641: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
69642: LD_ADDR_VAR 0 4
69646: PUSH
69647: LD_INT 35
69649: PUSH
69650: LD_INT 45
69652: PUSH
69653: LD_INT 46
69655: PUSH
69656: LD_INT 47
69658: PUSH
69659: LD_INT 82
69661: PUSH
69662: LD_INT 83
69664: PUSH
69665: LD_INT 84
69667: PUSH
69668: LD_INT 85
69670: PUSH
69671: LD_INT 86
69673: PUSH
69674: LD_INT 1
69676: PUSH
69677: LD_INT 2
69679: PUSH
69680: LD_INT 6
69682: PUSH
69683: LD_INT 15
69685: PUSH
69686: LD_INT 16
69688: PUSH
69689: LD_INT 7
69691: PUSH
69692: LD_INT 12
69694: PUSH
69695: LD_INT 13
69697: PUSH
69698: LD_INT 10
69700: PUSH
69701: LD_INT 14
69703: PUSH
69704: LD_INT 20
69706: PUSH
69707: LD_INT 21
69709: PUSH
69710: LD_INT 22
69712: PUSH
69713: LD_INT 25
69715: PUSH
69716: LD_INT 32
69718: PUSH
69719: LD_INT 27
69721: PUSH
69722: LD_INT 36
69724: PUSH
69725: LD_INT 69
69727: PUSH
69728: LD_INT 39
69730: PUSH
69731: LD_INT 34
69733: PUSH
69734: LD_INT 40
69736: PUSH
69737: LD_INT 48
69739: PUSH
69740: LD_INT 49
69742: PUSH
69743: LD_INT 50
69745: PUSH
69746: LD_INT 51
69748: PUSH
69749: LD_INT 52
69751: PUSH
69752: LD_INT 53
69754: PUSH
69755: LD_INT 54
69757: PUSH
69758: LD_INT 55
69760: PUSH
69761: LD_INT 56
69763: PUSH
69764: LD_INT 57
69766: PUSH
69767: LD_INT 58
69769: PUSH
69770: LD_INT 59
69772: PUSH
69773: LD_INT 60
69775: PUSH
69776: LD_INT 61
69778: PUSH
69779: LD_INT 62
69781: PUSH
69782: LD_INT 80
69784: PUSH
69785: LD_INT 82
69787: PUSH
69788: LD_INT 83
69790: PUSH
69791: LD_INT 84
69793: PUSH
69794: LD_INT 85
69796: PUSH
69797: LD_INT 86
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: LIST
69808: LIST
69809: LIST
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: LIST
69817: LIST
69818: LIST
69819: LIST
69820: LIST
69821: LIST
69822: LIST
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: LIST
69833: LIST
69834: LIST
69835: LIST
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: ST_TO_ADDR
69853: GO 70320
69855: LD_INT 2
69857: DOUBLE
69858: EQUAL
69859: IFTRUE 69863
69861: GO 70089
69863: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69864: LD_ADDR_VAR 0 4
69868: PUSH
69869: LD_INT 35
69871: PUSH
69872: LD_INT 45
69874: PUSH
69875: LD_INT 46
69877: PUSH
69878: LD_INT 47
69880: PUSH
69881: LD_INT 82
69883: PUSH
69884: LD_INT 83
69886: PUSH
69887: LD_INT 84
69889: PUSH
69890: LD_INT 85
69892: PUSH
69893: LD_INT 87
69895: PUSH
69896: LD_INT 70
69898: PUSH
69899: LD_INT 1
69901: PUSH
69902: LD_INT 11
69904: PUSH
69905: LD_INT 3
69907: PUSH
69908: LD_INT 4
69910: PUSH
69911: LD_INT 5
69913: PUSH
69914: LD_INT 6
69916: PUSH
69917: LD_INT 15
69919: PUSH
69920: LD_INT 18
69922: PUSH
69923: LD_INT 7
69925: PUSH
69926: LD_INT 17
69928: PUSH
69929: LD_INT 8
69931: PUSH
69932: LD_INT 20
69934: PUSH
69935: LD_INT 21
69937: PUSH
69938: LD_INT 22
69940: PUSH
69941: LD_INT 72
69943: PUSH
69944: LD_INT 26
69946: PUSH
69947: LD_INT 69
69949: PUSH
69950: LD_INT 39
69952: PUSH
69953: LD_INT 40
69955: PUSH
69956: LD_INT 41
69958: PUSH
69959: LD_INT 42
69961: PUSH
69962: LD_INT 43
69964: PUSH
69965: LD_INT 48
69967: PUSH
69968: LD_INT 49
69970: PUSH
69971: LD_INT 50
69973: PUSH
69974: LD_INT 51
69976: PUSH
69977: LD_INT 52
69979: PUSH
69980: LD_INT 53
69982: PUSH
69983: LD_INT 54
69985: PUSH
69986: LD_INT 55
69988: PUSH
69989: LD_INT 56
69991: PUSH
69992: LD_INT 60
69994: PUSH
69995: LD_INT 61
69997: PUSH
69998: LD_INT 62
70000: PUSH
70001: LD_INT 66
70003: PUSH
70004: LD_INT 67
70006: PUSH
70007: LD_INT 68
70009: PUSH
70010: LD_INT 81
70012: PUSH
70013: LD_INT 82
70015: PUSH
70016: LD_INT 83
70018: PUSH
70019: LD_INT 84
70021: PUSH
70022: LD_INT 85
70024: PUSH
70025: LD_INT 87
70027: PUSH
70028: LD_INT 88
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: LIST
70071: LIST
70072: LIST
70073: LIST
70074: LIST
70075: LIST
70076: LIST
70077: LIST
70078: LIST
70079: LIST
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: ST_TO_ADDR
70087: GO 70320
70089: LD_INT 3
70091: DOUBLE
70092: EQUAL
70093: IFTRUE 70097
70095: GO 70319
70097: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
70098: LD_ADDR_VAR 0 4
70102: PUSH
70103: LD_INT 46
70105: PUSH
70106: LD_INT 47
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: LD_INT 2
70114: PUSH
70115: LD_INT 82
70117: PUSH
70118: LD_INT 83
70120: PUSH
70121: LD_INT 84
70123: PUSH
70124: LD_INT 85
70126: PUSH
70127: LD_INT 86
70129: PUSH
70130: LD_INT 11
70132: PUSH
70133: LD_INT 9
70135: PUSH
70136: LD_INT 20
70138: PUSH
70139: LD_INT 19
70141: PUSH
70142: LD_INT 21
70144: PUSH
70145: LD_INT 24
70147: PUSH
70148: LD_INT 22
70150: PUSH
70151: LD_INT 25
70153: PUSH
70154: LD_INT 28
70156: PUSH
70157: LD_INT 29
70159: PUSH
70160: LD_INT 30
70162: PUSH
70163: LD_INT 31
70165: PUSH
70166: LD_INT 37
70168: PUSH
70169: LD_INT 38
70171: PUSH
70172: LD_INT 32
70174: PUSH
70175: LD_INT 27
70177: PUSH
70178: LD_INT 33
70180: PUSH
70181: LD_INT 69
70183: PUSH
70184: LD_INT 39
70186: PUSH
70187: LD_INT 34
70189: PUSH
70190: LD_INT 40
70192: PUSH
70193: LD_INT 71
70195: PUSH
70196: LD_INT 23
70198: PUSH
70199: LD_INT 44
70201: PUSH
70202: LD_INT 48
70204: PUSH
70205: LD_INT 49
70207: PUSH
70208: LD_INT 50
70210: PUSH
70211: LD_INT 51
70213: PUSH
70214: LD_INT 52
70216: PUSH
70217: LD_INT 53
70219: PUSH
70220: LD_INT 54
70222: PUSH
70223: LD_INT 55
70225: PUSH
70226: LD_INT 56
70228: PUSH
70229: LD_INT 57
70231: PUSH
70232: LD_INT 58
70234: PUSH
70235: LD_INT 59
70237: PUSH
70238: LD_INT 63
70240: PUSH
70241: LD_INT 64
70243: PUSH
70244: LD_INT 65
70246: PUSH
70247: LD_INT 82
70249: PUSH
70250: LD_INT 83
70252: PUSH
70253: LD_INT 84
70255: PUSH
70256: LD_INT 85
70258: PUSH
70259: LD_INT 86
70261: PUSH
70262: EMPTY
70263: LIST
70264: LIST
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: ST_TO_ADDR
70317: GO 70320
70319: POP
// if state > - 1 and state < 3 then
70320: LD_VAR 0 3
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: GREATER
70329: PUSH
70330: LD_VAR 0 3
70334: PUSH
70335: LD_INT 3
70337: LESS
70338: AND
70339: IFFALSE 70396
// for i in result do
70341: LD_ADDR_VAR 0 5
70345: PUSH
70346: LD_VAR 0 4
70350: PUSH
70351: FOR_IN
70352: IFFALSE 70394
// if GetTech ( i , side ) <> state then
70354: LD_VAR 0 5
70358: PPUSH
70359: LD_VAR 0 1
70363: PPUSH
70364: CALL_OW 321
70368: PUSH
70369: LD_VAR 0 3
70373: NONEQUAL
70374: IFFALSE 70392
// result := result diff i ;
70376: LD_ADDR_VAR 0 4
70380: PUSH
70381: LD_VAR 0 4
70385: PUSH
70386: LD_VAR 0 5
70390: DIFF
70391: ST_TO_ADDR
70392: GO 70351
70394: POP
70395: POP
// end ;
70396: LD_VAR 0 4
70400: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
70401: LD_INT 0
70403: PPUSH
70404: PPUSH
70405: PPUSH
// result := true ;
70406: LD_ADDR_VAR 0 3
70410: PUSH
70411: LD_INT 1
70413: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
70414: LD_ADDR_VAR 0 5
70418: PUSH
70419: LD_VAR 0 2
70423: PPUSH
70424: CALL_OW 480
70428: ST_TO_ADDR
// if not tmp then
70429: LD_VAR 0 5
70433: NOT
70434: IFFALSE 70438
// exit ;
70436: GO 70487
// for i in tmp do
70438: LD_ADDR_VAR 0 4
70442: PUSH
70443: LD_VAR 0 5
70447: PUSH
70448: FOR_IN
70449: IFFALSE 70485
// if GetTech ( i , side ) <> state_researched then
70451: LD_VAR 0 4
70455: PPUSH
70456: LD_VAR 0 1
70460: PPUSH
70461: CALL_OW 321
70465: PUSH
70466: LD_INT 2
70468: NONEQUAL
70469: IFFALSE 70483
// begin result := false ;
70471: LD_ADDR_VAR 0 3
70475: PUSH
70476: LD_INT 0
70478: ST_TO_ADDR
// exit ;
70479: POP
70480: POP
70481: GO 70487
// end ;
70483: GO 70448
70485: POP
70486: POP
// end ;
70487: LD_VAR 0 3
70491: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
70492: LD_INT 0
70494: PPUSH
70495: PPUSH
70496: PPUSH
70497: PPUSH
70498: PPUSH
70499: PPUSH
70500: PPUSH
70501: PPUSH
70502: PPUSH
70503: PPUSH
70504: PPUSH
70505: PPUSH
70506: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
70507: LD_VAR 0 1
70511: NOT
70512: PUSH
70513: LD_VAR 0 1
70517: PPUSH
70518: CALL_OW 257
70522: PUSH
70523: LD_INT 9
70525: NONEQUAL
70526: OR
70527: IFFALSE 70531
// exit ;
70529: GO 71104
// side := GetSide ( unit ) ;
70531: LD_ADDR_VAR 0 9
70535: PUSH
70536: LD_VAR 0 1
70540: PPUSH
70541: CALL_OW 255
70545: ST_TO_ADDR
// tech_space := tech_spacanom ;
70546: LD_ADDR_VAR 0 12
70550: PUSH
70551: LD_INT 29
70553: ST_TO_ADDR
// tech_time := tech_taurad ;
70554: LD_ADDR_VAR 0 13
70558: PUSH
70559: LD_INT 28
70561: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
70562: LD_ADDR_VAR 0 11
70566: PUSH
70567: LD_VAR 0 1
70571: PPUSH
70572: CALL_OW 310
70576: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
70577: LD_VAR 0 11
70581: PPUSH
70582: CALL_OW 247
70586: PUSH
70587: LD_INT 2
70589: EQUAL
70590: IFFALSE 70594
// exit ;
70592: GO 71104
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70594: LD_ADDR_VAR 0 8
70598: PUSH
70599: LD_INT 81
70601: PUSH
70602: LD_VAR 0 9
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 3
70613: PUSH
70614: LD_INT 21
70616: PUSH
70617: LD_INT 3
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PPUSH
70632: CALL_OW 69
70636: ST_TO_ADDR
// if not tmp then
70637: LD_VAR 0 8
70641: NOT
70642: IFFALSE 70646
// exit ;
70644: GO 71104
// if in_unit then
70646: LD_VAR 0 11
70650: IFFALSE 70674
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70652: LD_ADDR_VAR 0 10
70656: PUSH
70657: LD_VAR 0 8
70661: PPUSH
70662: LD_VAR 0 11
70666: PPUSH
70667: CALL_OW 74
70671: ST_TO_ADDR
70672: GO 70694
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70674: LD_ADDR_VAR 0 10
70678: PUSH
70679: LD_VAR 0 8
70683: PPUSH
70684: LD_VAR 0 1
70688: PPUSH
70689: CALL_OW 74
70693: ST_TO_ADDR
// if not enemy then
70694: LD_VAR 0 10
70698: NOT
70699: IFFALSE 70703
// exit ;
70701: GO 71104
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70703: LD_VAR 0 11
70707: PUSH
70708: LD_VAR 0 11
70712: PPUSH
70713: LD_VAR 0 10
70717: PPUSH
70718: CALL_OW 296
70722: PUSH
70723: LD_INT 13
70725: GREATER
70726: AND
70727: PUSH
70728: LD_VAR 0 1
70732: PPUSH
70733: LD_VAR 0 10
70737: PPUSH
70738: CALL_OW 296
70742: PUSH
70743: LD_INT 12
70745: GREATER
70746: OR
70747: IFFALSE 70751
// exit ;
70749: GO 71104
// missile := [ 1 ] ;
70751: LD_ADDR_VAR 0 14
70755: PUSH
70756: LD_INT 1
70758: PUSH
70759: EMPTY
70760: LIST
70761: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70762: LD_VAR 0 9
70766: PPUSH
70767: LD_VAR 0 12
70771: PPUSH
70772: CALL_OW 325
70776: IFFALSE 70805
// missile := Replace ( missile , missile + 1 , 2 ) ;
70778: LD_ADDR_VAR 0 14
70782: PUSH
70783: LD_VAR 0 14
70787: PPUSH
70788: LD_VAR 0 14
70792: PUSH
70793: LD_INT 1
70795: PLUS
70796: PPUSH
70797: LD_INT 2
70799: PPUSH
70800: CALL_OW 1
70804: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70805: LD_VAR 0 9
70809: PPUSH
70810: LD_VAR 0 13
70814: PPUSH
70815: CALL_OW 325
70819: PUSH
70820: LD_VAR 0 10
70824: PPUSH
70825: CALL_OW 255
70829: PPUSH
70830: LD_VAR 0 13
70834: PPUSH
70835: CALL_OW 325
70839: NOT
70840: AND
70841: IFFALSE 70870
// missile := Replace ( missile , missile + 1 , 3 ) ;
70843: LD_ADDR_VAR 0 14
70847: PUSH
70848: LD_VAR 0 14
70852: PPUSH
70853: LD_VAR 0 14
70857: PUSH
70858: LD_INT 1
70860: PLUS
70861: PPUSH
70862: LD_INT 3
70864: PPUSH
70865: CALL_OW 1
70869: ST_TO_ADDR
// if missile < 2 then
70870: LD_VAR 0 14
70874: PUSH
70875: LD_INT 2
70877: LESS
70878: IFFALSE 70882
// exit ;
70880: GO 71104
// x := GetX ( enemy ) ;
70882: LD_ADDR_VAR 0 4
70886: PUSH
70887: LD_VAR 0 10
70891: PPUSH
70892: CALL_OW 250
70896: ST_TO_ADDR
// y := GetY ( enemy ) ;
70897: LD_ADDR_VAR 0 5
70901: PUSH
70902: LD_VAR 0 10
70906: PPUSH
70907: CALL_OW 251
70911: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70912: LD_ADDR_VAR 0 6
70916: PUSH
70917: LD_VAR 0 4
70921: PUSH
70922: LD_INT 1
70924: NEG
70925: PPUSH
70926: LD_INT 1
70928: PPUSH
70929: CALL_OW 12
70933: PLUS
70934: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70935: LD_ADDR_VAR 0 7
70939: PUSH
70940: LD_VAR 0 5
70944: PUSH
70945: LD_INT 1
70947: NEG
70948: PPUSH
70949: LD_INT 1
70951: PPUSH
70952: CALL_OW 12
70956: PLUS
70957: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70958: LD_VAR 0 6
70962: PPUSH
70963: LD_VAR 0 7
70967: PPUSH
70968: CALL_OW 488
70972: NOT
70973: IFFALSE 70995
// begin _x := x ;
70975: LD_ADDR_VAR 0 6
70979: PUSH
70980: LD_VAR 0 4
70984: ST_TO_ADDR
// _y := y ;
70985: LD_ADDR_VAR 0 7
70989: PUSH
70990: LD_VAR 0 5
70994: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70995: LD_ADDR_VAR 0 3
70999: PUSH
71000: LD_INT 1
71002: PPUSH
71003: LD_VAR 0 14
71007: PPUSH
71008: CALL_OW 12
71012: ST_TO_ADDR
// case i of 1 :
71013: LD_VAR 0 3
71017: PUSH
71018: LD_INT 1
71020: DOUBLE
71021: EQUAL
71022: IFTRUE 71026
71024: GO 71043
71026: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
71027: LD_VAR 0 1
71031: PPUSH
71032: LD_VAR 0 10
71036: PPUSH
71037: CALL_OW 115
71041: GO 71104
71043: LD_INT 2
71045: DOUBLE
71046: EQUAL
71047: IFTRUE 71051
71049: GO 71073
71051: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
71052: LD_VAR 0 1
71056: PPUSH
71057: LD_VAR 0 6
71061: PPUSH
71062: LD_VAR 0 7
71066: PPUSH
71067: CALL_OW 153
71071: GO 71104
71073: LD_INT 3
71075: DOUBLE
71076: EQUAL
71077: IFTRUE 71081
71079: GO 71103
71081: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
71082: LD_VAR 0 1
71086: PPUSH
71087: LD_VAR 0 6
71091: PPUSH
71092: LD_VAR 0 7
71096: PPUSH
71097: CALL_OW 154
71101: GO 71104
71103: POP
// end ;
71104: LD_VAR 0 2
71108: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
71109: LD_INT 0
71111: PPUSH
71112: PPUSH
71113: PPUSH
71114: PPUSH
71115: PPUSH
71116: PPUSH
// if not unit or not building then
71117: LD_VAR 0 1
71121: NOT
71122: PUSH
71123: LD_VAR 0 2
71127: NOT
71128: OR
71129: IFFALSE 71133
// exit ;
71131: GO 71291
// x := GetX ( building ) ;
71133: LD_ADDR_VAR 0 5
71137: PUSH
71138: LD_VAR 0 2
71142: PPUSH
71143: CALL_OW 250
71147: ST_TO_ADDR
// y := GetY ( building ) ;
71148: LD_ADDR_VAR 0 6
71152: PUSH
71153: LD_VAR 0 2
71157: PPUSH
71158: CALL_OW 251
71162: ST_TO_ADDR
// for i = 0 to 5 do
71163: LD_ADDR_VAR 0 4
71167: PUSH
71168: DOUBLE
71169: LD_INT 0
71171: DEC
71172: ST_TO_ADDR
71173: LD_INT 5
71175: PUSH
71176: FOR_TO
71177: IFFALSE 71289
// begin _x := ShiftX ( x , i , 3 ) ;
71179: LD_ADDR_VAR 0 7
71183: PUSH
71184: LD_VAR 0 5
71188: PPUSH
71189: LD_VAR 0 4
71193: PPUSH
71194: LD_INT 3
71196: PPUSH
71197: CALL_OW 272
71201: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
71202: LD_ADDR_VAR 0 8
71206: PUSH
71207: LD_VAR 0 6
71211: PPUSH
71212: LD_VAR 0 4
71216: PPUSH
71217: LD_INT 3
71219: PPUSH
71220: CALL_OW 273
71224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
71225: LD_VAR 0 7
71229: PPUSH
71230: LD_VAR 0 8
71234: PPUSH
71235: CALL_OW 488
71239: NOT
71240: IFFALSE 71244
// continue ;
71242: GO 71176
// if HexInfo ( _x , _y ) = 0 then
71244: LD_VAR 0 7
71248: PPUSH
71249: LD_VAR 0 8
71253: PPUSH
71254: CALL_OW 428
71258: PUSH
71259: LD_INT 0
71261: EQUAL
71262: IFFALSE 71287
// begin ComMoveXY ( unit , _x , _y ) ;
71264: LD_VAR 0 1
71268: PPUSH
71269: LD_VAR 0 7
71273: PPUSH
71274: LD_VAR 0 8
71278: PPUSH
71279: CALL_OW 111
// exit ;
71283: POP
71284: POP
71285: GO 71291
// end ; end ;
71287: GO 71176
71289: POP
71290: POP
// end ;
71291: LD_VAR 0 3
71295: RET
// export function ScanBase ( side , base_area ) ; begin
71296: LD_INT 0
71298: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
71299: LD_ADDR_VAR 0 3
71303: PUSH
71304: LD_VAR 0 2
71308: PPUSH
71309: LD_INT 81
71311: PUSH
71312: LD_VAR 0 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PPUSH
71321: CALL_OW 70
71325: ST_TO_ADDR
// end ;
71326: LD_VAR 0 3
71330: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
71331: LD_INT 0
71333: PPUSH
71334: PPUSH
71335: PPUSH
71336: PPUSH
// result := false ;
71337: LD_ADDR_VAR 0 2
71341: PUSH
71342: LD_INT 0
71344: ST_TO_ADDR
// side := GetSide ( unit ) ;
71345: LD_ADDR_VAR 0 3
71349: PUSH
71350: LD_VAR 0 1
71354: PPUSH
71355: CALL_OW 255
71359: ST_TO_ADDR
// nat := GetNation ( unit ) ;
71360: LD_ADDR_VAR 0 4
71364: PUSH
71365: LD_VAR 0 1
71369: PPUSH
71370: CALL_OW 248
71374: ST_TO_ADDR
// case nat of 1 :
71375: LD_VAR 0 4
71379: PUSH
71380: LD_INT 1
71382: DOUBLE
71383: EQUAL
71384: IFTRUE 71388
71386: GO 71399
71388: POP
// tech := tech_lassight ; 2 :
71389: LD_ADDR_VAR 0 5
71393: PUSH
71394: LD_INT 12
71396: ST_TO_ADDR
71397: GO 71438
71399: LD_INT 2
71401: DOUBLE
71402: EQUAL
71403: IFTRUE 71407
71405: GO 71418
71407: POP
// tech := tech_mortar ; 3 :
71408: LD_ADDR_VAR 0 5
71412: PUSH
71413: LD_INT 41
71415: ST_TO_ADDR
71416: GO 71438
71418: LD_INT 3
71420: DOUBLE
71421: EQUAL
71422: IFTRUE 71426
71424: GO 71437
71426: POP
// tech := tech_bazooka ; end ;
71427: LD_ADDR_VAR 0 5
71431: PUSH
71432: LD_INT 44
71434: ST_TO_ADDR
71435: GO 71438
71437: POP
// if Researched ( side , tech ) then
71438: LD_VAR 0 3
71442: PPUSH
71443: LD_VAR 0 5
71447: PPUSH
71448: CALL_OW 325
71452: IFFALSE 71479
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
71454: LD_ADDR_VAR 0 2
71458: PUSH
71459: LD_INT 5
71461: PUSH
71462: LD_INT 8
71464: PUSH
71465: LD_INT 9
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: LIST
71472: PUSH
71473: LD_VAR 0 4
71477: ARRAY
71478: ST_TO_ADDR
// end ;
71479: LD_VAR 0 2
71483: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
71484: LD_INT 0
71486: PPUSH
71487: PPUSH
71488: PPUSH
// if not mines then
71489: LD_VAR 0 2
71493: NOT
71494: IFFALSE 71498
// exit ;
71496: GO 71642
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71498: LD_ADDR_VAR 0 5
71502: PUSH
71503: LD_INT 81
71505: PUSH
71506: LD_VAR 0 1
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: LD_INT 3
71517: PUSH
71518: LD_INT 21
71520: PUSH
71521: LD_INT 3
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PPUSH
71536: CALL_OW 69
71540: ST_TO_ADDR
// for i in mines do
71541: LD_ADDR_VAR 0 4
71545: PUSH
71546: LD_VAR 0 2
71550: PUSH
71551: FOR_IN
71552: IFFALSE 71640
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
71554: LD_VAR 0 4
71558: PUSH
71559: LD_INT 1
71561: ARRAY
71562: PPUSH
71563: LD_VAR 0 4
71567: PUSH
71568: LD_INT 2
71570: ARRAY
71571: PPUSH
71572: CALL_OW 458
71576: NOT
71577: IFFALSE 71581
// continue ;
71579: GO 71551
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
71581: LD_VAR 0 4
71585: PUSH
71586: LD_INT 1
71588: ARRAY
71589: PPUSH
71590: LD_VAR 0 4
71594: PUSH
71595: LD_INT 2
71597: ARRAY
71598: PPUSH
71599: CALL_OW 428
71603: PUSH
71604: LD_VAR 0 5
71608: IN
71609: IFFALSE 71638
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
71611: LD_VAR 0 4
71615: PUSH
71616: LD_INT 1
71618: ARRAY
71619: PPUSH
71620: LD_VAR 0 4
71624: PUSH
71625: LD_INT 2
71627: ARRAY
71628: PPUSH
71629: LD_VAR 0 1
71633: PPUSH
71634: CALL_OW 456
// end ;
71638: GO 71551
71640: POP
71641: POP
// end ;
71642: LD_VAR 0 3
71646: RET
// export function Count ( array ) ; begin
71647: LD_INT 0
71649: PPUSH
// result := array + 0 ;
71650: LD_ADDR_VAR 0 2
71654: PUSH
71655: LD_VAR 0 1
71659: PUSH
71660: LD_INT 0
71662: PLUS
71663: ST_TO_ADDR
// end ;
71664: LD_VAR 0 2
71668: RET
// export function IsEmpty ( building ) ; begin
71669: LD_INT 0
71671: PPUSH
// if not building then
71672: LD_VAR 0 1
71676: NOT
71677: IFFALSE 71681
// exit ;
71679: GO 71724
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71681: LD_ADDR_VAR 0 2
71685: PUSH
71686: LD_VAR 0 1
71690: PUSH
71691: LD_INT 22
71693: PUSH
71694: LD_VAR 0 1
71698: PPUSH
71699: CALL_OW 255
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 58
71710: PUSH
71711: EMPTY
71712: LIST
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PPUSH
71718: CALL_OW 69
71722: IN
71723: ST_TO_ADDR
// end ;
71724: LD_VAR 0 2
71728: RET
// export function IsNotFull ( building ) ; var places ; begin
71729: LD_INT 0
71731: PPUSH
71732: PPUSH
// if not building then
71733: LD_VAR 0 1
71737: NOT
71738: IFFALSE 71742
// exit ;
71740: GO 71770
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71742: LD_ADDR_VAR 0 2
71746: PUSH
71747: LD_VAR 0 1
71751: PPUSH
71752: LD_INT 3
71754: PUSH
71755: LD_INT 62
71757: PUSH
71758: EMPTY
71759: LIST
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PPUSH
71765: CALL_OW 72
71769: ST_TO_ADDR
// end ;
71770: LD_VAR 0 2
71774: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71775: LD_INT 0
71777: PPUSH
71778: PPUSH
71779: PPUSH
71780: PPUSH
// tmp := [ ] ;
71781: LD_ADDR_VAR 0 3
71785: PUSH
71786: EMPTY
71787: ST_TO_ADDR
// list := [ ] ;
71788: LD_ADDR_VAR 0 5
71792: PUSH
71793: EMPTY
71794: ST_TO_ADDR
// for i = 16 to 25 do
71795: LD_ADDR_VAR 0 4
71799: PUSH
71800: DOUBLE
71801: LD_INT 16
71803: DEC
71804: ST_TO_ADDR
71805: LD_INT 25
71807: PUSH
71808: FOR_TO
71809: IFFALSE 71882
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71811: LD_ADDR_VAR 0 3
71815: PUSH
71816: LD_VAR 0 3
71820: PUSH
71821: LD_INT 22
71823: PUSH
71824: LD_VAR 0 1
71828: PPUSH
71829: CALL_OW 255
71833: PUSH
71834: EMPTY
71835: LIST
71836: LIST
71837: PUSH
71838: LD_INT 91
71840: PUSH
71841: LD_VAR 0 1
71845: PUSH
71846: LD_INT 6
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 30
71856: PUSH
71857: LD_VAR 0 4
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: LIST
71870: PUSH
71871: EMPTY
71872: LIST
71873: PPUSH
71874: CALL_OW 69
71878: ADD
71879: ST_TO_ADDR
71880: GO 71808
71882: POP
71883: POP
// for i = 1 to tmp do
71884: LD_ADDR_VAR 0 4
71888: PUSH
71889: DOUBLE
71890: LD_INT 1
71892: DEC
71893: ST_TO_ADDR
71894: LD_VAR 0 3
71898: PUSH
71899: FOR_TO
71900: IFFALSE 71988
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71902: LD_ADDR_VAR 0 5
71906: PUSH
71907: LD_VAR 0 5
71911: PUSH
71912: LD_VAR 0 3
71916: PUSH
71917: LD_VAR 0 4
71921: ARRAY
71922: PPUSH
71923: CALL_OW 266
71927: PUSH
71928: LD_VAR 0 3
71932: PUSH
71933: LD_VAR 0 4
71937: ARRAY
71938: PPUSH
71939: CALL_OW 250
71943: PUSH
71944: LD_VAR 0 3
71948: PUSH
71949: LD_VAR 0 4
71953: ARRAY
71954: PPUSH
71955: CALL_OW 251
71959: PUSH
71960: LD_VAR 0 3
71964: PUSH
71965: LD_VAR 0 4
71969: ARRAY
71970: PPUSH
71971: CALL_OW 254
71975: PUSH
71976: EMPTY
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: PUSH
71982: EMPTY
71983: LIST
71984: ADD
71985: ST_TO_ADDR
71986: GO 71899
71988: POP
71989: POP
// result := list ;
71990: LD_ADDR_VAR 0 2
71994: PUSH
71995: LD_VAR 0 5
71999: ST_TO_ADDR
// end ;
72000: LD_VAR 0 2
72004: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
72005: LD_INT 0
72007: PPUSH
72008: PPUSH
72009: PPUSH
72010: PPUSH
72011: PPUSH
72012: PPUSH
72013: PPUSH
// if not factory then
72014: LD_VAR 0 1
72018: NOT
72019: IFFALSE 72023
// exit ;
72021: GO 72616
// if control = control_apeman then
72023: LD_VAR 0 4
72027: PUSH
72028: LD_INT 5
72030: EQUAL
72031: IFFALSE 72140
// begin tmp := UnitsInside ( factory ) ;
72033: LD_ADDR_VAR 0 8
72037: PUSH
72038: LD_VAR 0 1
72042: PPUSH
72043: CALL_OW 313
72047: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
72048: LD_VAR 0 8
72052: PPUSH
72053: LD_INT 25
72055: PUSH
72056: LD_INT 12
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PPUSH
72063: CALL_OW 72
72067: NOT
72068: IFFALSE 72078
// control := control_manual ;
72070: LD_ADDR_VAR 0 4
72074: PUSH
72075: LD_INT 1
72077: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
72078: LD_ADDR_VAR 0 8
72082: PUSH
72083: LD_VAR 0 1
72087: PPUSH
72088: CALL 71775 0 1
72092: ST_TO_ADDR
// if tmp then
72093: LD_VAR 0 8
72097: IFFALSE 72140
// begin for i in tmp do
72099: LD_ADDR_VAR 0 7
72103: PUSH
72104: LD_VAR 0 8
72108: PUSH
72109: FOR_IN
72110: IFFALSE 72138
// if i [ 1 ] = b_ext_radio then
72112: LD_VAR 0 7
72116: PUSH
72117: LD_INT 1
72119: ARRAY
72120: PUSH
72121: LD_INT 22
72123: EQUAL
72124: IFFALSE 72136
// begin control := control_remote ;
72126: LD_ADDR_VAR 0 4
72130: PUSH
72131: LD_INT 2
72133: ST_TO_ADDR
// break ;
72134: GO 72138
// end ;
72136: GO 72109
72138: POP
72139: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72140: LD_VAR 0 1
72144: PPUSH
72145: LD_VAR 0 2
72149: PPUSH
72150: LD_VAR 0 3
72154: PPUSH
72155: LD_VAR 0 4
72159: PPUSH
72160: LD_VAR 0 5
72164: PPUSH
72165: CALL_OW 448
72169: IFFALSE 72204
// begin result := [ chassis , engine , control , weapon ] ;
72171: LD_ADDR_VAR 0 6
72175: PUSH
72176: LD_VAR 0 2
72180: PUSH
72181: LD_VAR 0 3
72185: PUSH
72186: LD_VAR 0 4
72190: PUSH
72191: LD_VAR 0 5
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: ST_TO_ADDR
// exit ;
72202: GO 72616
// end ; _chassis := AvailableChassisList ( factory ) ;
72204: LD_ADDR_VAR 0 9
72208: PUSH
72209: LD_VAR 0 1
72213: PPUSH
72214: CALL_OW 475
72218: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
72219: LD_ADDR_VAR 0 11
72223: PUSH
72224: LD_VAR 0 1
72228: PPUSH
72229: CALL_OW 476
72233: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
72234: LD_ADDR_VAR 0 12
72238: PUSH
72239: LD_VAR 0 1
72243: PPUSH
72244: CALL_OW 477
72248: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
72249: LD_ADDR_VAR 0 10
72253: PUSH
72254: LD_VAR 0 1
72258: PPUSH
72259: CALL_OW 478
72263: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
72264: LD_VAR 0 9
72268: NOT
72269: PUSH
72270: LD_VAR 0 11
72274: NOT
72275: OR
72276: PUSH
72277: LD_VAR 0 12
72281: NOT
72282: OR
72283: PUSH
72284: LD_VAR 0 10
72288: NOT
72289: OR
72290: IFFALSE 72325
// begin result := [ chassis , engine , control , weapon ] ;
72292: LD_ADDR_VAR 0 6
72296: PUSH
72297: LD_VAR 0 2
72301: PUSH
72302: LD_VAR 0 3
72306: PUSH
72307: LD_VAR 0 4
72311: PUSH
72312: LD_VAR 0 5
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: ST_TO_ADDR
// exit ;
72323: GO 72616
// end ; if not chassis in _chassis then
72325: LD_VAR 0 2
72329: PUSH
72330: LD_VAR 0 9
72334: IN
72335: NOT
72336: IFFALSE 72362
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
72338: LD_ADDR_VAR 0 2
72342: PUSH
72343: LD_VAR 0 9
72347: PUSH
72348: LD_INT 1
72350: PPUSH
72351: LD_VAR 0 9
72355: PPUSH
72356: CALL_OW 12
72360: ARRAY
72361: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
72362: LD_VAR 0 2
72366: PPUSH
72367: LD_VAR 0 3
72371: PPUSH
72372: CALL 72621 0 2
72376: NOT
72377: IFFALSE 72436
// repeat engine := _engine [ 1 ] ;
72379: LD_ADDR_VAR 0 3
72383: PUSH
72384: LD_VAR 0 11
72388: PUSH
72389: LD_INT 1
72391: ARRAY
72392: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
72393: LD_ADDR_VAR 0 11
72397: PUSH
72398: LD_VAR 0 11
72402: PPUSH
72403: LD_INT 1
72405: PPUSH
72406: CALL_OW 3
72410: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
72411: LD_VAR 0 2
72415: PPUSH
72416: LD_VAR 0 3
72420: PPUSH
72421: CALL 72621 0 2
72425: PUSH
72426: LD_VAR 0 11
72430: PUSH
72431: EMPTY
72432: EQUAL
72433: OR
72434: IFFALSE 72379
// if not control in _control then
72436: LD_VAR 0 4
72440: PUSH
72441: LD_VAR 0 12
72445: IN
72446: NOT
72447: IFFALSE 72473
// control := _control [ rand ( 1 , _control ) ] ;
72449: LD_ADDR_VAR 0 4
72453: PUSH
72454: LD_VAR 0 12
72458: PUSH
72459: LD_INT 1
72461: PPUSH
72462: LD_VAR 0 12
72466: PPUSH
72467: CALL_OW 12
72471: ARRAY
72472: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
72473: LD_VAR 0 2
72477: PPUSH
72478: LD_VAR 0 5
72482: PPUSH
72483: CALL 72841 0 2
72487: NOT
72488: IFFALSE 72547
// repeat weapon := _weapon [ 1 ] ;
72490: LD_ADDR_VAR 0 5
72494: PUSH
72495: LD_VAR 0 10
72499: PUSH
72500: LD_INT 1
72502: ARRAY
72503: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
72504: LD_ADDR_VAR 0 10
72508: PUSH
72509: LD_VAR 0 10
72513: PPUSH
72514: LD_INT 1
72516: PPUSH
72517: CALL_OW 3
72521: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
72522: LD_VAR 0 2
72526: PPUSH
72527: LD_VAR 0 5
72531: PPUSH
72532: CALL 72841 0 2
72536: PUSH
72537: LD_VAR 0 10
72541: PUSH
72542: EMPTY
72543: EQUAL
72544: OR
72545: IFFALSE 72490
// result := [ ] ;
72547: LD_ADDR_VAR 0 6
72551: PUSH
72552: EMPTY
72553: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
72554: LD_VAR 0 1
72558: PPUSH
72559: LD_VAR 0 2
72563: PPUSH
72564: LD_VAR 0 3
72568: PPUSH
72569: LD_VAR 0 4
72573: PPUSH
72574: LD_VAR 0 5
72578: PPUSH
72579: CALL_OW 448
72583: IFFALSE 72616
// result := [ chassis , engine , control , weapon ] ;
72585: LD_ADDR_VAR 0 6
72589: PUSH
72590: LD_VAR 0 2
72594: PUSH
72595: LD_VAR 0 3
72599: PUSH
72600: LD_VAR 0 4
72604: PUSH
72605: LD_VAR 0 5
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: ST_TO_ADDR
// end ;
72616: LD_VAR 0 6
72620: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
72621: LD_INT 0
72623: PPUSH
// if not chassis or not engine then
72624: LD_VAR 0 1
72628: NOT
72629: PUSH
72630: LD_VAR 0 2
72634: NOT
72635: OR
72636: IFFALSE 72640
// exit ;
72638: GO 72836
// case engine of engine_solar :
72640: LD_VAR 0 2
72644: PUSH
72645: LD_INT 2
72647: DOUBLE
72648: EQUAL
72649: IFTRUE 72653
72651: GO 72691
72653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72654: LD_ADDR_VAR 0 3
72658: PUSH
72659: LD_INT 11
72661: PUSH
72662: LD_INT 12
72664: PUSH
72665: LD_INT 13
72667: PUSH
72668: LD_INT 14
72670: PUSH
72671: LD_INT 1
72673: PUSH
72674: LD_INT 2
72676: PUSH
72677: LD_INT 3
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: LIST
72684: LIST
72685: LIST
72686: LIST
72687: LIST
72688: ST_TO_ADDR
72689: GO 72820
72691: LD_INT 1
72693: DOUBLE
72694: EQUAL
72695: IFTRUE 72699
72697: GO 72761
72699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72700: LD_ADDR_VAR 0 3
72704: PUSH
72705: LD_INT 11
72707: PUSH
72708: LD_INT 12
72710: PUSH
72711: LD_INT 13
72713: PUSH
72714: LD_INT 14
72716: PUSH
72717: LD_INT 1
72719: PUSH
72720: LD_INT 2
72722: PUSH
72723: LD_INT 3
72725: PUSH
72726: LD_INT 4
72728: PUSH
72729: LD_INT 5
72731: PUSH
72732: LD_INT 21
72734: PUSH
72735: LD_INT 23
72737: PUSH
72738: LD_INT 22
72740: PUSH
72741: LD_INT 24
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: ST_TO_ADDR
72759: GO 72820
72761: LD_INT 3
72763: DOUBLE
72764: EQUAL
72765: IFTRUE 72769
72767: GO 72819
72769: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72770: LD_ADDR_VAR 0 3
72774: PUSH
72775: LD_INT 13
72777: PUSH
72778: LD_INT 14
72780: PUSH
72781: LD_INT 2
72783: PUSH
72784: LD_INT 3
72786: PUSH
72787: LD_INT 4
72789: PUSH
72790: LD_INT 5
72792: PUSH
72793: LD_INT 21
72795: PUSH
72796: LD_INT 22
72798: PUSH
72799: LD_INT 23
72801: PUSH
72802: LD_INT 24
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: ST_TO_ADDR
72817: GO 72820
72819: POP
// result := ( chassis in result ) ;
72820: LD_ADDR_VAR 0 3
72824: PUSH
72825: LD_VAR 0 1
72829: PUSH
72830: LD_VAR 0 3
72834: IN
72835: ST_TO_ADDR
// end ;
72836: LD_VAR 0 3
72840: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72841: LD_INT 0
72843: PPUSH
// if not chassis or not weapon then
72844: LD_VAR 0 1
72848: NOT
72849: PUSH
72850: LD_VAR 0 2
72854: NOT
72855: OR
72856: IFFALSE 72860
// exit ;
72858: GO 73920
// case weapon of us_machine_gun :
72860: LD_VAR 0 2
72864: PUSH
72865: LD_INT 2
72867: DOUBLE
72868: EQUAL
72869: IFTRUE 72873
72871: GO 72903
72873: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72874: LD_ADDR_VAR 0 3
72878: PUSH
72879: LD_INT 1
72881: PUSH
72882: LD_INT 2
72884: PUSH
72885: LD_INT 3
72887: PUSH
72888: LD_INT 4
72890: PUSH
72891: LD_INT 5
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: LIST
72898: LIST
72899: LIST
72900: ST_TO_ADDR
72901: GO 73904
72903: LD_INT 3
72905: DOUBLE
72906: EQUAL
72907: IFTRUE 72911
72909: GO 72941
72911: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72912: LD_ADDR_VAR 0 3
72916: PUSH
72917: LD_INT 1
72919: PUSH
72920: LD_INT 2
72922: PUSH
72923: LD_INT 3
72925: PUSH
72926: LD_INT 4
72928: PUSH
72929: LD_INT 5
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: LIST
72936: LIST
72937: LIST
72938: ST_TO_ADDR
72939: GO 73904
72941: LD_INT 11
72943: DOUBLE
72944: EQUAL
72945: IFTRUE 72949
72947: GO 72979
72949: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72950: LD_ADDR_VAR 0 3
72954: PUSH
72955: LD_INT 1
72957: PUSH
72958: LD_INT 2
72960: PUSH
72961: LD_INT 3
72963: PUSH
72964: LD_INT 4
72966: PUSH
72967: LD_INT 5
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: ST_TO_ADDR
72977: GO 73904
72979: LD_INT 4
72981: DOUBLE
72982: EQUAL
72983: IFTRUE 72987
72985: GO 73013
72987: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72988: LD_ADDR_VAR 0 3
72992: PUSH
72993: LD_INT 2
72995: PUSH
72996: LD_INT 3
72998: PUSH
72999: LD_INT 4
73001: PUSH
73002: LD_INT 5
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: ST_TO_ADDR
73011: GO 73904
73013: LD_INT 5
73015: DOUBLE
73016: EQUAL
73017: IFTRUE 73021
73019: GO 73047
73021: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
73022: LD_ADDR_VAR 0 3
73026: PUSH
73027: LD_INT 2
73029: PUSH
73030: LD_INT 3
73032: PUSH
73033: LD_INT 4
73035: PUSH
73036: LD_INT 5
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: ST_TO_ADDR
73045: GO 73904
73047: LD_INT 9
73049: DOUBLE
73050: EQUAL
73051: IFTRUE 73055
73053: GO 73081
73055: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
73056: LD_ADDR_VAR 0 3
73060: PUSH
73061: LD_INT 2
73063: PUSH
73064: LD_INT 3
73066: PUSH
73067: LD_INT 4
73069: PUSH
73070: LD_INT 5
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: LIST
73077: LIST
73078: ST_TO_ADDR
73079: GO 73904
73081: LD_INT 7
73083: DOUBLE
73084: EQUAL
73085: IFTRUE 73089
73087: GO 73115
73089: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
73090: LD_ADDR_VAR 0 3
73094: PUSH
73095: LD_INT 2
73097: PUSH
73098: LD_INT 3
73100: PUSH
73101: LD_INT 4
73103: PUSH
73104: LD_INT 5
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: LIST
73111: LIST
73112: ST_TO_ADDR
73113: GO 73904
73115: LD_INT 12
73117: DOUBLE
73118: EQUAL
73119: IFTRUE 73123
73121: GO 73149
73123: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
73124: LD_ADDR_VAR 0 3
73128: PUSH
73129: LD_INT 2
73131: PUSH
73132: LD_INT 3
73134: PUSH
73135: LD_INT 4
73137: PUSH
73138: LD_INT 5
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: ST_TO_ADDR
73147: GO 73904
73149: LD_INT 13
73151: DOUBLE
73152: EQUAL
73153: IFTRUE 73157
73155: GO 73183
73157: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
73158: LD_ADDR_VAR 0 3
73162: PUSH
73163: LD_INT 2
73165: PUSH
73166: LD_INT 3
73168: PUSH
73169: LD_INT 4
73171: PUSH
73172: LD_INT 5
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: LIST
73179: LIST
73180: ST_TO_ADDR
73181: GO 73904
73183: LD_INT 14
73185: DOUBLE
73186: EQUAL
73187: IFTRUE 73191
73189: GO 73209
73191: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
73192: LD_ADDR_VAR 0 3
73196: PUSH
73197: LD_INT 4
73199: PUSH
73200: LD_INT 5
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: ST_TO_ADDR
73207: GO 73904
73209: LD_INT 6
73211: DOUBLE
73212: EQUAL
73213: IFTRUE 73217
73215: GO 73235
73217: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
73218: LD_ADDR_VAR 0 3
73222: PUSH
73223: LD_INT 4
73225: PUSH
73226: LD_INT 5
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: ST_TO_ADDR
73233: GO 73904
73235: LD_INT 10
73237: DOUBLE
73238: EQUAL
73239: IFTRUE 73243
73241: GO 73261
73243: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
73244: LD_ADDR_VAR 0 3
73248: PUSH
73249: LD_INT 4
73251: PUSH
73252: LD_INT 5
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: ST_TO_ADDR
73259: GO 73904
73261: LD_INT 22
73263: DOUBLE
73264: EQUAL
73265: IFTRUE 73269
73267: GO 73295
73269: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
73270: LD_ADDR_VAR 0 3
73274: PUSH
73275: LD_INT 11
73277: PUSH
73278: LD_INT 12
73280: PUSH
73281: LD_INT 13
73283: PUSH
73284: LD_INT 14
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: ST_TO_ADDR
73293: GO 73904
73295: LD_INT 23
73297: DOUBLE
73298: EQUAL
73299: IFTRUE 73303
73301: GO 73329
73303: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
73304: LD_ADDR_VAR 0 3
73308: PUSH
73309: LD_INT 11
73311: PUSH
73312: LD_INT 12
73314: PUSH
73315: LD_INT 13
73317: PUSH
73318: LD_INT 14
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: LIST
73325: LIST
73326: ST_TO_ADDR
73327: GO 73904
73329: LD_INT 24
73331: DOUBLE
73332: EQUAL
73333: IFTRUE 73337
73335: GO 73363
73337: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
73338: LD_ADDR_VAR 0 3
73342: PUSH
73343: LD_INT 11
73345: PUSH
73346: LD_INT 12
73348: PUSH
73349: LD_INT 13
73351: PUSH
73352: LD_INT 14
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: ST_TO_ADDR
73361: GO 73904
73363: LD_INT 30
73365: DOUBLE
73366: EQUAL
73367: IFTRUE 73371
73369: GO 73397
73371: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
73372: LD_ADDR_VAR 0 3
73376: PUSH
73377: LD_INT 11
73379: PUSH
73380: LD_INT 12
73382: PUSH
73383: LD_INT 13
73385: PUSH
73386: LD_INT 14
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: LIST
73393: LIST
73394: ST_TO_ADDR
73395: GO 73904
73397: LD_INT 25
73399: DOUBLE
73400: EQUAL
73401: IFTRUE 73405
73403: GO 73423
73405: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
73406: LD_ADDR_VAR 0 3
73410: PUSH
73411: LD_INT 13
73413: PUSH
73414: LD_INT 14
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: ST_TO_ADDR
73421: GO 73904
73423: LD_INT 27
73425: DOUBLE
73426: EQUAL
73427: IFTRUE 73431
73429: GO 73449
73431: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
73432: LD_ADDR_VAR 0 3
73436: PUSH
73437: LD_INT 13
73439: PUSH
73440: LD_INT 14
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: ST_TO_ADDR
73447: GO 73904
73449: LD_INT 92
73451: DOUBLE
73452: EQUAL
73453: IFTRUE 73457
73455: GO 73483
73457: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
73458: LD_ADDR_VAR 0 3
73462: PUSH
73463: LD_INT 11
73465: PUSH
73466: LD_INT 12
73468: PUSH
73469: LD_INT 13
73471: PUSH
73472: LD_INT 14
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: ST_TO_ADDR
73481: GO 73904
73483: LD_INT 28
73485: DOUBLE
73486: EQUAL
73487: IFTRUE 73491
73489: GO 73509
73491: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
73492: LD_ADDR_VAR 0 3
73496: PUSH
73497: LD_INT 13
73499: PUSH
73500: LD_INT 14
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: ST_TO_ADDR
73507: GO 73904
73509: LD_INT 29
73511: DOUBLE
73512: EQUAL
73513: IFTRUE 73517
73515: GO 73535
73517: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
73518: LD_ADDR_VAR 0 3
73522: PUSH
73523: LD_INT 13
73525: PUSH
73526: LD_INT 14
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: ST_TO_ADDR
73533: GO 73904
73535: LD_INT 31
73537: DOUBLE
73538: EQUAL
73539: IFTRUE 73543
73541: GO 73561
73543: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
73544: LD_ADDR_VAR 0 3
73548: PUSH
73549: LD_INT 13
73551: PUSH
73552: LD_INT 14
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: ST_TO_ADDR
73559: GO 73904
73561: LD_INT 26
73563: DOUBLE
73564: EQUAL
73565: IFTRUE 73569
73567: GO 73587
73569: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
73570: LD_ADDR_VAR 0 3
73574: PUSH
73575: LD_INT 13
73577: PUSH
73578: LD_INT 14
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: ST_TO_ADDR
73585: GO 73904
73587: LD_INT 42
73589: DOUBLE
73590: EQUAL
73591: IFTRUE 73595
73593: GO 73621
73595: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
73596: LD_ADDR_VAR 0 3
73600: PUSH
73601: LD_INT 21
73603: PUSH
73604: LD_INT 22
73606: PUSH
73607: LD_INT 23
73609: PUSH
73610: LD_INT 24
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: ST_TO_ADDR
73619: GO 73904
73621: LD_INT 43
73623: DOUBLE
73624: EQUAL
73625: IFTRUE 73629
73627: GO 73655
73629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
73630: LD_ADDR_VAR 0 3
73634: PUSH
73635: LD_INT 21
73637: PUSH
73638: LD_INT 22
73640: PUSH
73641: LD_INT 23
73643: PUSH
73644: LD_INT 24
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: LIST
73651: LIST
73652: ST_TO_ADDR
73653: GO 73904
73655: LD_INT 44
73657: DOUBLE
73658: EQUAL
73659: IFTRUE 73663
73661: GO 73689
73663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73664: LD_ADDR_VAR 0 3
73668: PUSH
73669: LD_INT 21
73671: PUSH
73672: LD_INT 22
73674: PUSH
73675: LD_INT 23
73677: PUSH
73678: LD_INT 24
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: LIST
73685: LIST
73686: ST_TO_ADDR
73687: GO 73904
73689: LD_INT 45
73691: DOUBLE
73692: EQUAL
73693: IFTRUE 73697
73695: GO 73723
73697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73698: LD_ADDR_VAR 0 3
73702: PUSH
73703: LD_INT 21
73705: PUSH
73706: LD_INT 22
73708: PUSH
73709: LD_INT 23
73711: PUSH
73712: LD_INT 24
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: ST_TO_ADDR
73721: GO 73904
73723: LD_INT 49
73725: DOUBLE
73726: EQUAL
73727: IFTRUE 73731
73729: GO 73757
73731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73732: LD_ADDR_VAR 0 3
73736: PUSH
73737: LD_INT 21
73739: PUSH
73740: LD_INT 22
73742: PUSH
73743: LD_INT 23
73745: PUSH
73746: LD_INT 24
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: ST_TO_ADDR
73755: GO 73904
73757: LD_INT 51
73759: DOUBLE
73760: EQUAL
73761: IFTRUE 73765
73763: GO 73791
73765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73766: LD_ADDR_VAR 0 3
73770: PUSH
73771: LD_INT 21
73773: PUSH
73774: LD_INT 22
73776: PUSH
73777: LD_INT 23
73779: PUSH
73780: LD_INT 24
73782: PUSH
73783: EMPTY
73784: LIST
73785: LIST
73786: LIST
73787: LIST
73788: ST_TO_ADDR
73789: GO 73904
73791: LD_INT 52
73793: DOUBLE
73794: EQUAL
73795: IFTRUE 73799
73797: GO 73825
73799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73800: LD_ADDR_VAR 0 3
73804: PUSH
73805: LD_INT 21
73807: PUSH
73808: LD_INT 22
73810: PUSH
73811: LD_INT 23
73813: PUSH
73814: LD_INT 24
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: ST_TO_ADDR
73823: GO 73904
73825: LD_INT 53
73827: DOUBLE
73828: EQUAL
73829: IFTRUE 73833
73831: GO 73851
73833: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73834: LD_ADDR_VAR 0 3
73838: PUSH
73839: LD_INT 23
73841: PUSH
73842: LD_INT 24
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: ST_TO_ADDR
73849: GO 73904
73851: LD_INT 46
73853: DOUBLE
73854: EQUAL
73855: IFTRUE 73859
73857: GO 73877
73859: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73860: LD_ADDR_VAR 0 3
73864: PUSH
73865: LD_INT 23
73867: PUSH
73868: LD_INT 24
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: ST_TO_ADDR
73875: GO 73904
73877: LD_INT 47
73879: DOUBLE
73880: EQUAL
73881: IFTRUE 73885
73883: GO 73903
73885: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73886: LD_ADDR_VAR 0 3
73890: PUSH
73891: LD_INT 23
73893: PUSH
73894: LD_INT 24
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: ST_TO_ADDR
73901: GO 73904
73903: POP
// result := ( chassis in result ) ;
73904: LD_ADDR_VAR 0 3
73908: PUSH
73909: LD_VAR 0 1
73913: PUSH
73914: LD_VAR 0 3
73918: IN
73919: ST_TO_ADDR
// end ;
73920: LD_VAR 0 3
73924: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73925: LD_INT 0
73927: PPUSH
73928: PPUSH
73929: PPUSH
73930: PPUSH
73931: PPUSH
73932: PPUSH
73933: PPUSH
// result := array ;
73934: LD_ADDR_VAR 0 5
73938: PUSH
73939: LD_VAR 0 1
73943: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73944: LD_VAR 0 1
73948: NOT
73949: PUSH
73950: LD_VAR 0 2
73954: NOT
73955: OR
73956: PUSH
73957: LD_VAR 0 3
73961: NOT
73962: OR
73963: PUSH
73964: LD_VAR 0 2
73968: PUSH
73969: LD_VAR 0 1
73973: GREATER
73974: OR
73975: PUSH
73976: LD_VAR 0 3
73980: PUSH
73981: LD_VAR 0 1
73985: GREATER
73986: OR
73987: IFFALSE 73991
// exit ;
73989: GO 74287
// if direction then
73991: LD_VAR 0 4
73995: IFFALSE 74059
// begin d := 1 ;
73997: LD_ADDR_VAR 0 9
74001: PUSH
74002: LD_INT 1
74004: ST_TO_ADDR
// if i_from > i_to then
74005: LD_VAR 0 2
74009: PUSH
74010: LD_VAR 0 3
74014: GREATER
74015: IFFALSE 74041
// length := ( array - i_from ) + i_to else
74017: LD_ADDR_VAR 0 11
74021: PUSH
74022: LD_VAR 0 1
74026: PUSH
74027: LD_VAR 0 2
74031: MINUS
74032: PUSH
74033: LD_VAR 0 3
74037: PLUS
74038: ST_TO_ADDR
74039: GO 74057
// length := i_to - i_from ;
74041: LD_ADDR_VAR 0 11
74045: PUSH
74046: LD_VAR 0 3
74050: PUSH
74051: LD_VAR 0 2
74055: MINUS
74056: ST_TO_ADDR
// end else
74057: GO 74120
// begin d := - 1 ;
74059: LD_ADDR_VAR 0 9
74063: PUSH
74064: LD_INT 1
74066: NEG
74067: ST_TO_ADDR
// if i_from > i_to then
74068: LD_VAR 0 2
74072: PUSH
74073: LD_VAR 0 3
74077: GREATER
74078: IFFALSE 74098
// length := i_from - i_to else
74080: LD_ADDR_VAR 0 11
74084: PUSH
74085: LD_VAR 0 2
74089: PUSH
74090: LD_VAR 0 3
74094: MINUS
74095: ST_TO_ADDR
74096: GO 74120
// length := ( array - i_to ) + i_from ;
74098: LD_ADDR_VAR 0 11
74102: PUSH
74103: LD_VAR 0 1
74107: PUSH
74108: LD_VAR 0 3
74112: MINUS
74113: PUSH
74114: LD_VAR 0 2
74118: PLUS
74119: ST_TO_ADDR
// end ; if not length then
74120: LD_VAR 0 11
74124: NOT
74125: IFFALSE 74129
// exit ;
74127: GO 74287
// tmp := array ;
74129: LD_ADDR_VAR 0 10
74133: PUSH
74134: LD_VAR 0 1
74138: ST_TO_ADDR
// for i = 1 to length do
74139: LD_ADDR_VAR 0 6
74143: PUSH
74144: DOUBLE
74145: LD_INT 1
74147: DEC
74148: ST_TO_ADDR
74149: LD_VAR 0 11
74153: PUSH
74154: FOR_TO
74155: IFFALSE 74275
// begin for j = 1 to array do
74157: LD_ADDR_VAR 0 7
74161: PUSH
74162: DOUBLE
74163: LD_INT 1
74165: DEC
74166: ST_TO_ADDR
74167: LD_VAR 0 1
74171: PUSH
74172: FOR_TO
74173: IFFALSE 74261
// begin k := j + d ;
74175: LD_ADDR_VAR 0 8
74179: PUSH
74180: LD_VAR 0 7
74184: PUSH
74185: LD_VAR 0 9
74189: PLUS
74190: ST_TO_ADDR
// if k > array then
74191: LD_VAR 0 8
74195: PUSH
74196: LD_VAR 0 1
74200: GREATER
74201: IFFALSE 74211
// k := 1 ;
74203: LD_ADDR_VAR 0 8
74207: PUSH
74208: LD_INT 1
74210: ST_TO_ADDR
// if not k then
74211: LD_VAR 0 8
74215: NOT
74216: IFFALSE 74228
// k := array ;
74218: LD_ADDR_VAR 0 8
74222: PUSH
74223: LD_VAR 0 1
74227: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
74228: LD_ADDR_VAR 0 10
74232: PUSH
74233: LD_VAR 0 10
74237: PPUSH
74238: LD_VAR 0 8
74242: PPUSH
74243: LD_VAR 0 1
74247: PUSH
74248: LD_VAR 0 7
74252: ARRAY
74253: PPUSH
74254: CALL_OW 1
74258: ST_TO_ADDR
// end ;
74259: GO 74172
74261: POP
74262: POP
// array := tmp ;
74263: LD_ADDR_VAR 0 1
74267: PUSH
74268: LD_VAR 0 10
74272: ST_TO_ADDR
// end ;
74273: GO 74154
74275: POP
74276: POP
// result := array ;
74277: LD_ADDR_VAR 0 5
74281: PUSH
74282: LD_VAR 0 1
74286: ST_TO_ADDR
// end ;
74287: LD_VAR 0 5
74291: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
74292: LD_INT 0
74294: PPUSH
74295: PPUSH
// result := 0 ;
74296: LD_ADDR_VAR 0 3
74300: PUSH
74301: LD_INT 0
74303: ST_TO_ADDR
// if not array or not value in array then
74304: LD_VAR 0 1
74308: NOT
74309: PUSH
74310: LD_VAR 0 2
74314: PUSH
74315: LD_VAR 0 1
74319: IN
74320: NOT
74321: OR
74322: IFFALSE 74326
// exit ;
74324: GO 74380
// for i = 1 to array do
74326: LD_ADDR_VAR 0 4
74330: PUSH
74331: DOUBLE
74332: LD_INT 1
74334: DEC
74335: ST_TO_ADDR
74336: LD_VAR 0 1
74340: PUSH
74341: FOR_TO
74342: IFFALSE 74378
// if value = array [ i ] then
74344: LD_VAR 0 2
74348: PUSH
74349: LD_VAR 0 1
74353: PUSH
74354: LD_VAR 0 4
74358: ARRAY
74359: EQUAL
74360: IFFALSE 74376
// begin result := i ;
74362: LD_ADDR_VAR 0 3
74366: PUSH
74367: LD_VAR 0 4
74371: ST_TO_ADDR
// exit ;
74372: POP
74373: POP
74374: GO 74380
// end ;
74376: GO 74341
74378: POP
74379: POP
// end ;
74380: LD_VAR 0 3
74384: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
74385: LD_INT 0
74387: PPUSH
// vc_chassis := chassis ;
74388: LD_ADDR_OWVAR 37
74392: PUSH
74393: LD_VAR 0 1
74397: ST_TO_ADDR
// vc_engine := engine ;
74398: LD_ADDR_OWVAR 39
74402: PUSH
74403: LD_VAR 0 2
74407: ST_TO_ADDR
// vc_control := control ;
74408: LD_ADDR_OWVAR 38
74412: PUSH
74413: LD_VAR 0 3
74417: ST_TO_ADDR
// vc_weapon := weapon ;
74418: LD_ADDR_OWVAR 40
74422: PUSH
74423: LD_VAR 0 4
74427: ST_TO_ADDR
// vc_fuel_battery := fuel ;
74428: LD_ADDR_OWVAR 41
74432: PUSH
74433: LD_VAR 0 5
74437: ST_TO_ADDR
// end ;
74438: LD_VAR 0 6
74442: RET
// export function WantPlant ( unit ) ; var task ; begin
74443: LD_INT 0
74445: PPUSH
74446: PPUSH
// result := false ;
74447: LD_ADDR_VAR 0 2
74451: PUSH
74452: LD_INT 0
74454: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
74455: LD_ADDR_VAR 0 3
74459: PUSH
74460: LD_VAR 0 1
74464: PPUSH
74465: CALL_OW 437
74469: ST_TO_ADDR
// if task then
74470: LD_VAR 0 3
74474: IFFALSE 74502
// if task [ 1 ] [ 1 ] = p then
74476: LD_VAR 0 3
74480: PUSH
74481: LD_INT 1
74483: ARRAY
74484: PUSH
74485: LD_INT 1
74487: ARRAY
74488: PUSH
74489: LD_STRING p
74491: EQUAL
74492: IFFALSE 74502
// result := true ;
74494: LD_ADDR_VAR 0 2
74498: PUSH
74499: LD_INT 1
74501: ST_TO_ADDR
// end ;
74502: LD_VAR 0 2
74506: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
74507: LD_INT 0
74509: PPUSH
74510: PPUSH
74511: PPUSH
74512: PPUSH
// if pos < 1 then
74513: LD_VAR 0 2
74517: PUSH
74518: LD_INT 1
74520: LESS
74521: IFFALSE 74525
// exit ;
74523: GO 74828
// if pos = 1 then
74525: LD_VAR 0 2
74529: PUSH
74530: LD_INT 1
74532: EQUAL
74533: IFFALSE 74566
// result := Replace ( arr , pos [ 1 ] , value ) else
74535: LD_ADDR_VAR 0 4
74539: PUSH
74540: LD_VAR 0 1
74544: PPUSH
74545: LD_VAR 0 2
74549: PUSH
74550: LD_INT 1
74552: ARRAY
74553: PPUSH
74554: LD_VAR 0 3
74558: PPUSH
74559: CALL_OW 1
74563: ST_TO_ADDR
74564: GO 74828
// begin tmp := arr ;
74566: LD_ADDR_VAR 0 6
74570: PUSH
74571: LD_VAR 0 1
74575: ST_TO_ADDR
// s_arr := [ tmp ] ;
74576: LD_ADDR_VAR 0 7
74580: PUSH
74581: LD_VAR 0 6
74585: PUSH
74586: EMPTY
74587: LIST
74588: ST_TO_ADDR
// for i = 1 to pos - 1 do
74589: LD_ADDR_VAR 0 5
74593: PUSH
74594: DOUBLE
74595: LD_INT 1
74597: DEC
74598: ST_TO_ADDR
74599: LD_VAR 0 2
74603: PUSH
74604: LD_INT 1
74606: MINUS
74607: PUSH
74608: FOR_TO
74609: IFFALSE 74654
// begin tmp := tmp [ pos [ i ] ] ;
74611: LD_ADDR_VAR 0 6
74615: PUSH
74616: LD_VAR 0 6
74620: PUSH
74621: LD_VAR 0 2
74625: PUSH
74626: LD_VAR 0 5
74630: ARRAY
74631: ARRAY
74632: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
74633: LD_ADDR_VAR 0 7
74637: PUSH
74638: LD_VAR 0 7
74642: PUSH
74643: LD_VAR 0 6
74647: PUSH
74648: EMPTY
74649: LIST
74650: ADD
74651: ST_TO_ADDR
// end ;
74652: GO 74608
74654: POP
74655: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74656: LD_ADDR_VAR 0 6
74660: PUSH
74661: LD_VAR 0 6
74665: PPUSH
74666: LD_VAR 0 2
74670: PUSH
74671: LD_VAR 0 2
74675: ARRAY
74676: PPUSH
74677: LD_VAR 0 3
74681: PPUSH
74682: CALL_OW 1
74686: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74687: LD_ADDR_VAR 0 7
74691: PUSH
74692: LD_VAR 0 7
74696: PPUSH
74697: LD_VAR 0 7
74701: PPUSH
74702: LD_VAR 0 6
74706: PPUSH
74707: CALL_OW 1
74711: ST_TO_ADDR
// for i = s_arr downto 2 do
74712: LD_ADDR_VAR 0 5
74716: PUSH
74717: DOUBLE
74718: LD_VAR 0 7
74722: INC
74723: ST_TO_ADDR
74724: LD_INT 2
74726: PUSH
74727: FOR_DOWNTO
74728: IFFALSE 74812
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74730: LD_ADDR_VAR 0 6
74734: PUSH
74735: LD_VAR 0 7
74739: PUSH
74740: LD_VAR 0 5
74744: PUSH
74745: LD_INT 1
74747: MINUS
74748: ARRAY
74749: PPUSH
74750: LD_VAR 0 2
74754: PUSH
74755: LD_VAR 0 5
74759: PUSH
74760: LD_INT 1
74762: MINUS
74763: ARRAY
74764: PPUSH
74765: LD_VAR 0 7
74769: PUSH
74770: LD_VAR 0 5
74774: ARRAY
74775: PPUSH
74776: CALL_OW 1
74780: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74781: LD_ADDR_VAR 0 7
74785: PUSH
74786: LD_VAR 0 7
74790: PPUSH
74791: LD_VAR 0 5
74795: PUSH
74796: LD_INT 1
74798: MINUS
74799: PPUSH
74800: LD_VAR 0 6
74804: PPUSH
74805: CALL_OW 1
74809: ST_TO_ADDR
// end ;
74810: GO 74727
74812: POP
74813: POP
// result := s_arr [ 1 ] ;
74814: LD_ADDR_VAR 0 4
74818: PUSH
74819: LD_VAR 0 7
74823: PUSH
74824: LD_INT 1
74826: ARRAY
74827: ST_TO_ADDR
// end ; end ;
74828: LD_VAR 0 4
74832: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74833: LD_INT 0
74835: PPUSH
74836: PPUSH
// if not list then
74837: LD_VAR 0 1
74841: NOT
74842: IFFALSE 74846
// exit ;
74844: GO 74937
// i := list [ pos1 ] ;
74846: LD_ADDR_VAR 0 5
74850: PUSH
74851: LD_VAR 0 1
74855: PUSH
74856: LD_VAR 0 2
74860: ARRAY
74861: ST_TO_ADDR
// if not i then
74862: LD_VAR 0 5
74866: NOT
74867: IFFALSE 74871
// exit ;
74869: GO 74937
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74871: LD_ADDR_VAR 0 1
74875: PUSH
74876: LD_VAR 0 1
74880: PPUSH
74881: LD_VAR 0 2
74885: PPUSH
74886: LD_VAR 0 1
74890: PUSH
74891: LD_VAR 0 3
74895: ARRAY
74896: PPUSH
74897: CALL_OW 1
74901: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74902: LD_ADDR_VAR 0 1
74906: PUSH
74907: LD_VAR 0 1
74911: PPUSH
74912: LD_VAR 0 3
74916: PPUSH
74917: LD_VAR 0 5
74921: PPUSH
74922: CALL_OW 1
74926: ST_TO_ADDR
// result := list ;
74927: LD_ADDR_VAR 0 4
74931: PUSH
74932: LD_VAR 0 1
74936: ST_TO_ADDR
// end ;
74937: LD_VAR 0 4
74941: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74942: LD_INT 0
74944: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74945: LD_ADDR_VAR 0 5
74949: PUSH
74950: LD_VAR 0 1
74954: PPUSH
74955: CALL_OW 250
74959: PPUSH
74960: LD_VAR 0 1
74964: PPUSH
74965: CALL_OW 251
74969: PPUSH
74970: LD_VAR 0 2
74974: PPUSH
74975: LD_VAR 0 3
74979: PPUSH
74980: LD_VAR 0 4
74984: PPUSH
74985: CALL 75363 0 5
74989: ST_TO_ADDR
// end ;
74990: LD_VAR 0 5
74994: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
74995: LD_INT 0
74997: PPUSH
74998: PPUSH
74999: PPUSH
75000: PPUSH
// if not list or not unit then
75001: LD_VAR 0 2
75005: NOT
75006: PUSH
75007: LD_VAR 0 1
75011: NOT
75012: OR
75013: IFFALSE 75017
// exit ;
75015: GO 75358
// result := [ ] ;
75017: LD_ADDR_VAR 0 5
75021: PUSH
75022: EMPTY
75023: ST_TO_ADDR
// for i in list do
75024: LD_ADDR_VAR 0 6
75028: PUSH
75029: LD_VAR 0 2
75033: PUSH
75034: FOR_IN
75035: IFFALSE 75253
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
75037: LD_ADDR_VAR 0 8
75041: PUSH
75042: LD_VAR 0 1
75046: PPUSH
75047: LD_VAR 0 6
75051: PUSH
75052: LD_INT 1
75054: ARRAY
75055: PPUSH
75056: LD_VAR 0 6
75060: PUSH
75061: LD_INT 2
75063: ARRAY
75064: PPUSH
75065: CALL_OW 297
75069: ST_TO_ADDR
// if not Count ( result ) then
75070: LD_VAR 0 5
75074: PPUSH
75075: CALL 71647 0 1
75079: NOT
75080: IFFALSE 75113
// begin result := Join ( result , [ i , tmp ] ) ;
75082: LD_ADDR_VAR 0 5
75086: PUSH
75087: LD_VAR 0 5
75091: PPUSH
75092: LD_VAR 0 6
75096: PUSH
75097: LD_VAR 0 8
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PPUSH
75106: CALL 107236 0 2
75110: ST_TO_ADDR
// continue ;
75111: GO 75034
// end ; if result [ result ] [ 2 ] <= tmp then
75113: LD_VAR 0 5
75117: PUSH
75118: LD_VAR 0 5
75122: ARRAY
75123: PUSH
75124: LD_INT 2
75126: ARRAY
75127: PUSH
75128: LD_VAR 0 8
75132: LESSEQUAL
75133: IFFALSE 75166
// result := Join ( result , [ i , tmp ] ) else
75135: LD_ADDR_VAR 0 5
75139: PUSH
75140: LD_VAR 0 5
75144: PPUSH
75145: LD_VAR 0 6
75149: PUSH
75150: LD_VAR 0 8
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PPUSH
75159: CALL 107236 0 2
75163: ST_TO_ADDR
75164: GO 75251
// begin for j := 1 to Count ( result ) do
75166: LD_ADDR_VAR 0 7
75170: PUSH
75171: DOUBLE
75172: LD_INT 1
75174: DEC
75175: ST_TO_ADDR
75176: LD_VAR 0 5
75180: PPUSH
75181: CALL 71647 0 1
75185: PUSH
75186: FOR_TO
75187: IFFALSE 75249
// begin if tmp < result [ j ] [ 2 ] then
75189: LD_VAR 0 8
75193: PUSH
75194: LD_VAR 0 5
75198: PUSH
75199: LD_VAR 0 7
75203: ARRAY
75204: PUSH
75205: LD_INT 2
75207: ARRAY
75208: LESS
75209: IFFALSE 75247
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75211: LD_ADDR_VAR 0 5
75215: PUSH
75216: LD_VAR 0 5
75220: PPUSH
75221: LD_VAR 0 7
75225: PPUSH
75226: LD_VAR 0 6
75230: PUSH
75231: LD_VAR 0 8
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PPUSH
75240: CALL_OW 2
75244: ST_TO_ADDR
// break ;
75245: GO 75249
// end ; end ;
75247: GO 75186
75249: POP
75250: POP
// end ; end ;
75251: GO 75034
75253: POP
75254: POP
// if result and not asc then
75255: LD_VAR 0 5
75259: PUSH
75260: LD_VAR 0 3
75264: NOT
75265: AND
75266: IFFALSE 75283
// result := ReverseArray ( result ) ;
75268: LD_ADDR_VAR 0 5
75272: PUSH
75273: LD_VAR 0 5
75277: PPUSH
75278: CALL 102523 0 1
75282: ST_TO_ADDR
// tmp := [ ] ;
75283: LD_ADDR_VAR 0 8
75287: PUSH
75288: EMPTY
75289: ST_TO_ADDR
// if mode then
75290: LD_VAR 0 4
75294: IFFALSE 75358
// begin for i := 1 to result do
75296: LD_ADDR_VAR 0 6
75300: PUSH
75301: DOUBLE
75302: LD_INT 1
75304: DEC
75305: ST_TO_ADDR
75306: LD_VAR 0 5
75310: PUSH
75311: FOR_TO
75312: IFFALSE 75346
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
75314: LD_ADDR_VAR 0 8
75318: PUSH
75319: LD_VAR 0 8
75323: PPUSH
75324: LD_VAR 0 5
75328: PUSH
75329: LD_VAR 0 6
75333: ARRAY
75334: PUSH
75335: LD_INT 1
75337: ARRAY
75338: PPUSH
75339: CALL 107236 0 2
75343: ST_TO_ADDR
75344: GO 75311
75346: POP
75347: POP
// result := tmp ;
75348: LD_ADDR_VAR 0 5
75352: PUSH
75353: LD_VAR 0 8
75357: ST_TO_ADDR
// end ; end ;
75358: LD_VAR 0 5
75362: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
75363: LD_INT 0
75365: PPUSH
75366: PPUSH
75367: PPUSH
75368: PPUSH
// if not list then
75369: LD_VAR 0 3
75373: NOT
75374: IFFALSE 75378
// exit ;
75376: GO 75766
// result := [ ] ;
75378: LD_ADDR_VAR 0 6
75382: PUSH
75383: EMPTY
75384: ST_TO_ADDR
// for i in list do
75385: LD_ADDR_VAR 0 7
75389: PUSH
75390: LD_VAR 0 3
75394: PUSH
75395: FOR_IN
75396: IFFALSE 75598
// begin tmp := GetDistUnitXY ( i , x , y ) ;
75398: LD_ADDR_VAR 0 9
75402: PUSH
75403: LD_VAR 0 7
75407: PPUSH
75408: LD_VAR 0 1
75412: PPUSH
75413: LD_VAR 0 2
75417: PPUSH
75418: CALL_OW 297
75422: ST_TO_ADDR
// if not result then
75423: LD_VAR 0 6
75427: NOT
75428: IFFALSE 75454
// result := [ [ i , tmp ] ] else
75430: LD_ADDR_VAR 0 6
75434: PUSH
75435: LD_VAR 0 7
75439: PUSH
75440: LD_VAR 0 9
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: EMPTY
75450: LIST
75451: ST_TO_ADDR
75452: GO 75596
// begin if result [ result ] [ 2 ] < tmp then
75454: LD_VAR 0 6
75458: PUSH
75459: LD_VAR 0 6
75463: ARRAY
75464: PUSH
75465: LD_INT 2
75467: ARRAY
75468: PUSH
75469: LD_VAR 0 9
75473: LESS
75474: IFFALSE 75516
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
75476: LD_ADDR_VAR 0 6
75480: PUSH
75481: LD_VAR 0 6
75485: PPUSH
75486: LD_VAR 0 6
75490: PUSH
75491: LD_INT 1
75493: PLUS
75494: PPUSH
75495: LD_VAR 0 7
75499: PUSH
75500: LD_VAR 0 9
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PPUSH
75509: CALL_OW 2
75513: ST_TO_ADDR
75514: GO 75596
// for j = 1 to result do
75516: LD_ADDR_VAR 0 8
75520: PUSH
75521: DOUBLE
75522: LD_INT 1
75524: DEC
75525: ST_TO_ADDR
75526: LD_VAR 0 6
75530: PUSH
75531: FOR_TO
75532: IFFALSE 75594
// begin if tmp < result [ j ] [ 2 ] then
75534: LD_VAR 0 9
75538: PUSH
75539: LD_VAR 0 6
75543: PUSH
75544: LD_VAR 0 8
75548: ARRAY
75549: PUSH
75550: LD_INT 2
75552: ARRAY
75553: LESS
75554: IFFALSE 75592
// begin result := Insert ( result , j , [ i , tmp ] ) ;
75556: LD_ADDR_VAR 0 6
75560: PUSH
75561: LD_VAR 0 6
75565: PPUSH
75566: LD_VAR 0 8
75570: PPUSH
75571: LD_VAR 0 7
75575: PUSH
75576: LD_VAR 0 9
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PPUSH
75585: CALL_OW 2
75589: ST_TO_ADDR
// break ;
75590: GO 75594
// end ; end ;
75592: GO 75531
75594: POP
75595: POP
// end ; end ;
75596: GO 75395
75598: POP
75599: POP
// if result and not asc then
75600: LD_VAR 0 6
75604: PUSH
75605: LD_VAR 0 4
75609: NOT
75610: AND
75611: IFFALSE 75686
// begin tmp := result ;
75613: LD_ADDR_VAR 0 9
75617: PUSH
75618: LD_VAR 0 6
75622: ST_TO_ADDR
// for i = tmp downto 1 do
75623: LD_ADDR_VAR 0 7
75627: PUSH
75628: DOUBLE
75629: LD_VAR 0 9
75633: INC
75634: ST_TO_ADDR
75635: LD_INT 1
75637: PUSH
75638: FOR_DOWNTO
75639: IFFALSE 75684
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
75641: LD_ADDR_VAR 0 6
75645: PUSH
75646: LD_VAR 0 6
75650: PPUSH
75651: LD_VAR 0 9
75655: PUSH
75656: LD_VAR 0 7
75660: MINUS
75661: PUSH
75662: LD_INT 1
75664: PLUS
75665: PPUSH
75666: LD_VAR 0 9
75670: PUSH
75671: LD_VAR 0 7
75675: ARRAY
75676: PPUSH
75677: CALL_OW 1
75681: ST_TO_ADDR
75682: GO 75638
75684: POP
75685: POP
// end ; tmp := [ ] ;
75686: LD_ADDR_VAR 0 9
75690: PUSH
75691: EMPTY
75692: ST_TO_ADDR
// if mode then
75693: LD_VAR 0 5
75697: IFFALSE 75766
// begin for i = 1 to result do
75699: LD_ADDR_VAR 0 7
75703: PUSH
75704: DOUBLE
75705: LD_INT 1
75707: DEC
75708: ST_TO_ADDR
75709: LD_VAR 0 6
75713: PUSH
75714: FOR_TO
75715: IFFALSE 75754
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
75717: LD_ADDR_VAR 0 9
75721: PUSH
75722: LD_VAR 0 9
75726: PPUSH
75727: LD_VAR 0 7
75731: PPUSH
75732: LD_VAR 0 6
75736: PUSH
75737: LD_VAR 0 7
75741: ARRAY
75742: PUSH
75743: LD_INT 1
75745: ARRAY
75746: PPUSH
75747: CALL_OW 1
75751: ST_TO_ADDR
75752: GO 75714
75754: POP
75755: POP
// result := tmp ;
75756: LD_ADDR_VAR 0 6
75760: PUSH
75761: LD_VAR 0 9
75765: ST_TO_ADDR
// end ; end ;
75766: LD_VAR 0 6
75770: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
75771: LD_INT 0
75773: PPUSH
75774: PPUSH
75775: PPUSH
75776: PPUSH
75777: PPUSH
75778: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
75779: LD_ADDR_VAR 0 5
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: LD_INT 0
75789: PUSH
75790: LD_INT 0
75792: PUSH
75793: EMPTY
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: LIST
75799: LIST
75800: ST_TO_ADDR
// if not x or not y then
75801: LD_VAR 0 2
75805: NOT
75806: PUSH
75807: LD_VAR 0 3
75811: NOT
75812: OR
75813: IFFALSE 75817
// exit ;
75815: GO 77467
// if not range then
75817: LD_VAR 0 4
75821: NOT
75822: IFFALSE 75832
// range := 10 ;
75824: LD_ADDR_VAR 0 4
75828: PUSH
75829: LD_INT 10
75831: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
75832: LD_ADDR_VAR 0 8
75836: PUSH
75837: LD_INT 81
75839: PUSH
75840: LD_VAR 0 1
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 92
75851: PUSH
75852: LD_VAR 0 2
75856: PUSH
75857: LD_VAR 0 3
75861: PUSH
75862: LD_VAR 0 4
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 3
75875: PUSH
75876: LD_INT 21
75878: PUSH
75879: LD_INT 3
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: LIST
75894: PPUSH
75895: CALL_OW 69
75899: ST_TO_ADDR
// if not tmp then
75900: LD_VAR 0 8
75904: NOT
75905: IFFALSE 75909
// exit ;
75907: GO 77467
// for i in tmp do
75909: LD_ADDR_VAR 0 6
75913: PUSH
75914: LD_VAR 0 8
75918: PUSH
75919: FOR_IN
75920: IFFALSE 77442
// begin points := [ 0 , 0 , 0 ] ;
75922: LD_ADDR_VAR 0 9
75926: PUSH
75927: LD_INT 0
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: LD_INT 0
75935: PUSH
75936: EMPTY
75937: LIST
75938: LIST
75939: LIST
75940: ST_TO_ADDR
// bpoints := 1 ;
75941: LD_ADDR_VAR 0 10
75945: PUSH
75946: LD_INT 1
75948: ST_TO_ADDR
// case GetType ( i ) of unit_human :
75949: LD_VAR 0 6
75953: PPUSH
75954: CALL_OW 247
75958: PUSH
75959: LD_INT 1
75961: DOUBLE
75962: EQUAL
75963: IFTRUE 75967
75965: GO 76545
75967: POP
// begin if GetClass ( i ) = 1 then
75968: LD_VAR 0 6
75972: PPUSH
75973: CALL_OW 257
75977: PUSH
75978: LD_INT 1
75980: EQUAL
75981: IFFALSE 76002
// points := [ 10 , 5 , 3 ] ;
75983: LD_ADDR_VAR 0 9
75987: PUSH
75988: LD_INT 10
75990: PUSH
75991: LD_INT 5
75993: PUSH
75994: LD_INT 3
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: LIST
76001: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
76002: LD_VAR 0 6
76006: PPUSH
76007: CALL_OW 257
76011: PUSH
76012: LD_INT 2
76014: PUSH
76015: LD_INT 3
76017: PUSH
76018: LD_INT 4
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: LIST
76025: IN
76026: IFFALSE 76047
// points := [ 3 , 2 , 1 ] ;
76028: LD_ADDR_VAR 0 9
76032: PUSH
76033: LD_INT 3
76035: PUSH
76036: LD_INT 2
76038: PUSH
76039: LD_INT 1
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: LIST
76046: ST_TO_ADDR
// if GetClass ( i ) = 5 then
76047: LD_VAR 0 6
76051: PPUSH
76052: CALL_OW 257
76056: PUSH
76057: LD_INT 5
76059: EQUAL
76060: IFFALSE 76081
// points := [ 130 , 5 , 2 ] ;
76062: LD_ADDR_VAR 0 9
76066: PUSH
76067: LD_INT 130
76069: PUSH
76070: LD_INT 5
76072: PUSH
76073: LD_INT 2
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: LIST
76080: ST_TO_ADDR
// if GetClass ( i ) = 8 then
76081: LD_VAR 0 6
76085: PPUSH
76086: CALL_OW 257
76090: PUSH
76091: LD_INT 8
76093: EQUAL
76094: IFFALSE 76115
// points := [ 35 , 35 , 30 ] ;
76096: LD_ADDR_VAR 0 9
76100: PUSH
76101: LD_INT 35
76103: PUSH
76104: LD_INT 35
76106: PUSH
76107: LD_INT 30
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: LIST
76114: ST_TO_ADDR
// if GetClass ( i ) = 9 then
76115: LD_VAR 0 6
76119: PPUSH
76120: CALL_OW 257
76124: PUSH
76125: LD_INT 9
76127: EQUAL
76128: IFFALSE 76149
// points := [ 20 , 55 , 40 ] ;
76130: LD_ADDR_VAR 0 9
76134: PUSH
76135: LD_INT 20
76137: PUSH
76138: LD_INT 55
76140: PUSH
76141: LD_INT 40
76143: PUSH
76144: EMPTY
76145: LIST
76146: LIST
76147: LIST
76148: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
76149: LD_VAR 0 6
76153: PPUSH
76154: CALL_OW 257
76158: PUSH
76159: LD_INT 12
76161: PUSH
76162: LD_INT 16
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: IN
76169: IFFALSE 76190
// points := [ 5 , 3 , 2 ] ;
76171: LD_ADDR_VAR 0 9
76175: PUSH
76176: LD_INT 5
76178: PUSH
76179: LD_INT 3
76181: PUSH
76182: LD_INT 2
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: LIST
76189: ST_TO_ADDR
// if GetClass ( i ) = 17 then
76190: LD_VAR 0 6
76194: PPUSH
76195: CALL_OW 257
76199: PUSH
76200: LD_INT 17
76202: EQUAL
76203: IFFALSE 76224
// points := [ 100 , 50 , 75 ] ;
76205: LD_ADDR_VAR 0 9
76209: PUSH
76210: LD_INT 100
76212: PUSH
76213: LD_INT 50
76215: PUSH
76216: LD_INT 75
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: LIST
76223: ST_TO_ADDR
// if GetClass ( i ) = 15 then
76224: LD_VAR 0 6
76228: PPUSH
76229: CALL_OW 257
76233: PUSH
76234: LD_INT 15
76236: EQUAL
76237: IFFALSE 76258
// points := [ 10 , 5 , 3 ] ;
76239: LD_ADDR_VAR 0 9
76243: PUSH
76244: LD_INT 10
76246: PUSH
76247: LD_INT 5
76249: PUSH
76250: LD_INT 3
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: LIST
76257: ST_TO_ADDR
// if GetClass ( i ) = 14 then
76258: LD_VAR 0 6
76262: PPUSH
76263: CALL_OW 257
76267: PUSH
76268: LD_INT 14
76270: EQUAL
76271: IFFALSE 76292
// points := [ 10 , 0 , 0 ] ;
76273: LD_ADDR_VAR 0 9
76277: PUSH
76278: LD_INT 10
76280: PUSH
76281: LD_INT 0
76283: PUSH
76284: LD_INT 0
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: LIST
76291: ST_TO_ADDR
// if GetClass ( i ) = 11 then
76292: LD_VAR 0 6
76296: PPUSH
76297: CALL_OW 257
76301: PUSH
76302: LD_INT 11
76304: EQUAL
76305: IFFALSE 76326
// points := [ 30 , 10 , 5 ] ;
76307: LD_ADDR_VAR 0 9
76311: PUSH
76312: LD_INT 30
76314: PUSH
76315: LD_INT 10
76317: PUSH
76318: LD_INT 5
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: LIST
76325: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
76326: LD_VAR 0 1
76330: PPUSH
76331: LD_INT 5
76333: PPUSH
76334: CALL_OW 321
76338: PUSH
76339: LD_INT 2
76341: EQUAL
76342: IFFALSE 76359
// bpoints := bpoints * 1.8 ;
76344: LD_ADDR_VAR 0 10
76348: PUSH
76349: LD_VAR 0 10
76353: PUSH
76354: LD_REAL  1.80000000000000E+0000
76357: MUL
76358: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
76359: LD_VAR 0 6
76363: PPUSH
76364: CALL_OW 257
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: LD_INT 2
76374: PUSH
76375: LD_INT 3
76377: PUSH
76378: LD_INT 4
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: LIST
76385: LIST
76386: IN
76387: PUSH
76388: LD_VAR 0 1
76392: PPUSH
76393: LD_INT 51
76395: PPUSH
76396: CALL_OW 321
76400: PUSH
76401: LD_INT 2
76403: EQUAL
76404: AND
76405: IFFALSE 76422
// bpoints := bpoints * 1.2 ;
76407: LD_ADDR_VAR 0 10
76411: PUSH
76412: LD_VAR 0 10
76416: PUSH
76417: LD_REAL  1.20000000000000E+0000
76420: MUL
76421: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
76422: LD_VAR 0 6
76426: PPUSH
76427: CALL_OW 257
76431: PUSH
76432: LD_INT 5
76434: PUSH
76435: LD_INT 7
76437: PUSH
76438: LD_INT 9
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: LIST
76445: IN
76446: PUSH
76447: LD_VAR 0 1
76451: PPUSH
76452: LD_INT 52
76454: PPUSH
76455: CALL_OW 321
76459: PUSH
76460: LD_INT 2
76462: EQUAL
76463: AND
76464: IFFALSE 76481
// bpoints := bpoints * 1.5 ;
76466: LD_ADDR_VAR 0 10
76470: PUSH
76471: LD_VAR 0 10
76475: PUSH
76476: LD_REAL  1.50000000000000E+0000
76479: MUL
76480: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
76481: LD_VAR 0 1
76485: PPUSH
76486: LD_INT 66
76488: PPUSH
76489: CALL_OW 321
76493: PUSH
76494: LD_INT 2
76496: EQUAL
76497: IFFALSE 76514
// bpoints := bpoints * 1.1 ;
76499: LD_ADDR_VAR 0 10
76503: PUSH
76504: LD_VAR 0 10
76508: PUSH
76509: LD_REAL  1.10000000000000E+0000
76512: MUL
76513: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
76514: LD_ADDR_VAR 0 10
76518: PUSH
76519: LD_VAR 0 10
76523: PUSH
76524: LD_VAR 0 6
76528: PPUSH
76529: LD_INT 1
76531: PPUSH
76532: CALL_OW 259
76536: PUSH
76537: LD_REAL  1.15000000000000E+0000
76540: MUL
76541: MUL
76542: ST_TO_ADDR
// end ; unit_vehicle :
76543: GO 77371
76545: LD_INT 2
76547: DOUBLE
76548: EQUAL
76549: IFTRUE 76553
76551: GO 77359
76553: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
76554: LD_VAR 0 6
76558: PPUSH
76559: CALL_OW 264
76563: PUSH
76564: LD_INT 2
76566: PUSH
76567: LD_INT 42
76569: PUSH
76570: LD_INT 24
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: LIST
76577: IN
76578: IFFALSE 76599
// points := [ 25 , 5 , 3 ] ;
76580: LD_ADDR_VAR 0 9
76584: PUSH
76585: LD_INT 25
76587: PUSH
76588: LD_INT 5
76590: PUSH
76591: LD_INT 3
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: LIST
76598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
76599: LD_VAR 0 6
76603: PPUSH
76604: CALL_OW 264
76608: PUSH
76609: LD_INT 4
76611: PUSH
76612: LD_INT 43
76614: PUSH
76615: LD_INT 25
76617: PUSH
76618: EMPTY
76619: LIST
76620: LIST
76621: LIST
76622: IN
76623: IFFALSE 76644
// points := [ 40 , 15 , 5 ] ;
76625: LD_ADDR_VAR 0 9
76629: PUSH
76630: LD_INT 40
76632: PUSH
76633: LD_INT 15
76635: PUSH
76636: LD_INT 5
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: LIST
76643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
76644: LD_VAR 0 6
76648: PPUSH
76649: CALL_OW 264
76653: PUSH
76654: LD_INT 3
76656: PUSH
76657: LD_INT 23
76659: PUSH
76660: EMPTY
76661: LIST
76662: LIST
76663: IN
76664: IFFALSE 76685
// points := [ 7 , 25 , 8 ] ;
76666: LD_ADDR_VAR 0 9
76670: PUSH
76671: LD_INT 7
76673: PUSH
76674: LD_INT 25
76676: PUSH
76677: LD_INT 8
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: LIST
76684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
76685: LD_VAR 0 6
76689: PPUSH
76690: CALL_OW 264
76694: PUSH
76695: LD_INT 5
76697: PUSH
76698: LD_INT 27
76700: PUSH
76701: LD_INT 44
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: LIST
76708: IN
76709: IFFALSE 76730
// points := [ 14 , 50 , 16 ] ;
76711: LD_ADDR_VAR 0 9
76715: PUSH
76716: LD_INT 14
76718: PUSH
76719: LD_INT 50
76721: PUSH
76722: LD_INT 16
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: LIST
76729: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
76730: LD_VAR 0 6
76734: PPUSH
76735: CALL_OW 264
76739: PUSH
76740: LD_INT 6
76742: PUSH
76743: LD_INT 46
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: IN
76750: IFFALSE 76771
// points := [ 32 , 120 , 70 ] ;
76752: LD_ADDR_VAR 0 9
76756: PUSH
76757: LD_INT 32
76759: PUSH
76760: LD_INT 120
76762: PUSH
76763: LD_INT 70
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: LIST
76770: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
76771: LD_VAR 0 6
76775: PPUSH
76776: CALL_OW 264
76780: PUSH
76781: LD_INT 7
76783: PUSH
76784: LD_INT 28
76786: PUSH
76787: LD_INT 45
76789: PUSH
76790: LD_INT 92
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: LIST
76797: LIST
76798: IN
76799: IFFALSE 76820
// points := [ 35 , 20 , 45 ] ;
76801: LD_ADDR_VAR 0 9
76805: PUSH
76806: LD_INT 35
76808: PUSH
76809: LD_INT 20
76811: PUSH
76812: LD_INT 45
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: LIST
76819: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
76820: LD_VAR 0 6
76824: PPUSH
76825: CALL_OW 264
76829: PUSH
76830: LD_INT 47
76832: PUSH
76833: EMPTY
76834: LIST
76835: IN
76836: IFFALSE 76857
// points := [ 67 , 45 , 75 ] ;
76838: LD_ADDR_VAR 0 9
76842: PUSH
76843: LD_INT 67
76845: PUSH
76846: LD_INT 45
76848: PUSH
76849: LD_INT 75
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: LIST
76856: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
76857: LD_VAR 0 6
76861: PPUSH
76862: CALL_OW 264
76866: PUSH
76867: LD_INT 26
76869: PUSH
76870: EMPTY
76871: LIST
76872: IN
76873: IFFALSE 76894
// points := [ 120 , 30 , 80 ] ;
76875: LD_ADDR_VAR 0 9
76879: PUSH
76880: LD_INT 120
76882: PUSH
76883: LD_INT 30
76885: PUSH
76886: LD_INT 80
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: LIST
76893: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
76894: LD_VAR 0 6
76898: PPUSH
76899: CALL_OW 264
76903: PUSH
76904: LD_INT 22
76906: PUSH
76907: EMPTY
76908: LIST
76909: IN
76910: IFFALSE 76931
// points := [ 40 , 1 , 1 ] ;
76912: LD_ADDR_VAR 0 9
76916: PUSH
76917: LD_INT 40
76919: PUSH
76920: LD_INT 1
76922: PUSH
76923: LD_INT 1
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: LIST
76930: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
76931: LD_VAR 0 6
76935: PPUSH
76936: CALL_OW 264
76940: PUSH
76941: LD_INT 29
76943: PUSH
76944: EMPTY
76945: LIST
76946: IN
76947: IFFALSE 76968
// points := [ 70 , 200 , 400 ] ;
76949: LD_ADDR_VAR 0 9
76953: PUSH
76954: LD_INT 70
76956: PUSH
76957: LD_INT 200
76959: PUSH
76960: LD_INT 400
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: LIST
76967: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
76968: LD_VAR 0 6
76972: PPUSH
76973: CALL_OW 264
76977: PUSH
76978: LD_INT 14
76980: PUSH
76981: LD_INT 53
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: IN
76988: IFFALSE 77009
// points := [ 40 , 10 , 20 ] ;
76990: LD_ADDR_VAR 0 9
76994: PUSH
76995: LD_INT 40
76997: PUSH
76998: LD_INT 10
77000: PUSH
77001: LD_INT 20
77003: PUSH
77004: EMPTY
77005: LIST
77006: LIST
77007: LIST
77008: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
77009: LD_VAR 0 6
77013: PPUSH
77014: CALL_OW 264
77018: PUSH
77019: LD_INT 9
77021: PUSH
77022: EMPTY
77023: LIST
77024: IN
77025: IFFALSE 77046
// points := [ 5 , 70 , 20 ] ;
77027: LD_ADDR_VAR 0 9
77031: PUSH
77032: LD_INT 5
77034: PUSH
77035: LD_INT 70
77037: PUSH
77038: LD_INT 20
77040: PUSH
77041: EMPTY
77042: LIST
77043: LIST
77044: LIST
77045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
77046: LD_VAR 0 6
77050: PPUSH
77051: CALL_OW 264
77055: PUSH
77056: LD_INT 10
77058: PUSH
77059: EMPTY
77060: LIST
77061: IN
77062: IFFALSE 77083
// points := [ 35 , 110 , 70 ] ;
77064: LD_ADDR_VAR 0 9
77068: PUSH
77069: LD_INT 35
77071: PUSH
77072: LD_INT 110
77074: PUSH
77075: LD_INT 70
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: LIST
77082: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
77083: LD_VAR 0 6
77087: PPUSH
77088: CALL_OW 265
77092: PUSH
77093: LD_INT 25
77095: EQUAL
77096: IFFALSE 77117
// points := [ 80 , 65 , 100 ] ;
77098: LD_ADDR_VAR 0 9
77102: PUSH
77103: LD_INT 80
77105: PUSH
77106: LD_INT 65
77108: PUSH
77109: LD_INT 100
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: LIST
77116: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
77117: LD_VAR 0 6
77121: PPUSH
77122: CALL_OW 263
77126: PUSH
77127: LD_INT 1
77129: EQUAL
77130: IFFALSE 77165
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
77132: LD_ADDR_VAR 0 10
77136: PUSH
77137: LD_VAR 0 10
77141: PUSH
77142: LD_VAR 0 6
77146: PPUSH
77147: CALL_OW 311
77151: PPUSH
77152: LD_INT 3
77154: PPUSH
77155: CALL_OW 259
77159: PUSH
77160: LD_INT 4
77162: MUL
77163: MUL
77164: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
77165: LD_VAR 0 6
77169: PPUSH
77170: CALL_OW 263
77174: PUSH
77175: LD_INT 2
77177: EQUAL
77178: IFFALSE 77229
// begin j := IsControledBy ( i ) ;
77180: LD_ADDR_VAR 0 7
77184: PUSH
77185: LD_VAR 0 6
77189: PPUSH
77190: CALL_OW 312
77194: ST_TO_ADDR
// if j then
77195: LD_VAR 0 7
77199: IFFALSE 77229
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
77201: LD_ADDR_VAR 0 10
77205: PUSH
77206: LD_VAR 0 10
77210: PUSH
77211: LD_VAR 0 7
77215: PPUSH
77216: LD_INT 3
77218: PPUSH
77219: CALL_OW 259
77223: PUSH
77224: LD_INT 3
77226: MUL
77227: MUL
77228: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
77229: LD_VAR 0 6
77233: PPUSH
77234: CALL_OW 264
77238: PUSH
77239: LD_INT 5
77241: PUSH
77242: LD_INT 6
77244: PUSH
77245: LD_INT 46
77247: PUSH
77248: LD_INT 44
77250: PUSH
77251: LD_INT 47
77253: PUSH
77254: LD_INT 45
77256: PUSH
77257: LD_INT 28
77259: PUSH
77260: LD_INT 7
77262: PUSH
77263: LD_INT 27
77265: PUSH
77266: LD_INT 29
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: IN
77281: PUSH
77282: LD_VAR 0 1
77286: PPUSH
77287: LD_INT 52
77289: PPUSH
77290: CALL_OW 321
77294: PUSH
77295: LD_INT 2
77297: EQUAL
77298: AND
77299: IFFALSE 77316
// bpoints := bpoints * 1.2 ;
77301: LD_ADDR_VAR 0 10
77305: PUSH
77306: LD_VAR 0 10
77310: PUSH
77311: LD_REAL  1.20000000000000E+0000
77314: MUL
77315: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
77316: LD_VAR 0 6
77320: PPUSH
77321: CALL_OW 264
77325: PUSH
77326: LD_INT 6
77328: PUSH
77329: LD_INT 46
77331: PUSH
77332: LD_INT 47
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: LIST
77339: IN
77340: IFFALSE 77357
// bpoints := bpoints * 1.2 ;
77342: LD_ADDR_VAR 0 10
77346: PUSH
77347: LD_VAR 0 10
77351: PUSH
77352: LD_REAL  1.20000000000000E+0000
77355: MUL
77356: ST_TO_ADDR
// end ; unit_building :
77357: GO 77371
77359: LD_INT 3
77361: DOUBLE
77362: EQUAL
77363: IFTRUE 77367
77365: GO 77370
77367: POP
// ; end ;
77368: GO 77371
77370: POP
// for j = 1 to 3 do
77371: LD_ADDR_VAR 0 7
77375: PUSH
77376: DOUBLE
77377: LD_INT 1
77379: DEC
77380: ST_TO_ADDR
77381: LD_INT 3
77383: PUSH
77384: FOR_TO
77385: IFFALSE 77438
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
77387: LD_ADDR_VAR 0 5
77391: PUSH
77392: LD_VAR 0 5
77396: PPUSH
77397: LD_VAR 0 7
77401: PPUSH
77402: LD_VAR 0 5
77406: PUSH
77407: LD_VAR 0 7
77411: ARRAY
77412: PUSH
77413: LD_VAR 0 9
77417: PUSH
77418: LD_VAR 0 7
77422: ARRAY
77423: PUSH
77424: LD_VAR 0 10
77428: MUL
77429: PLUS
77430: PPUSH
77431: CALL_OW 1
77435: ST_TO_ADDR
77436: GO 77384
77438: POP
77439: POP
// end ;
77440: GO 75919
77442: POP
77443: POP
// result := Replace ( result , 4 , tmp ) ;
77444: LD_ADDR_VAR 0 5
77448: PUSH
77449: LD_VAR 0 5
77453: PPUSH
77454: LD_INT 4
77456: PPUSH
77457: LD_VAR 0 8
77461: PPUSH
77462: CALL_OW 1
77466: ST_TO_ADDR
// end ;
77467: LD_VAR 0 5
77471: RET
// export function DangerAtRange ( unit , range ) ; begin
77472: LD_INT 0
77474: PPUSH
// if not unit then
77475: LD_VAR 0 1
77479: NOT
77480: IFFALSE 77484
// exit ;
77482: GO 77529
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
77484: LD_ADDR_VAR 0 3
77488: PUSH
77489: LD_VAR 0 1
77493: PPUSH
77494: CALL_OW 255
77498: PPUSH
77499: LD_VAR 0 1
77503: PPUSH
77504: CALL_OW 250
77508: PPUSH
77509: LD_VAR 0 1
77513: PPUSH
77514: CALL_OW 251
77518: PPUSH
77519: LD_VAR 0 2
77523: PPUSH
77524: CALL 75771 0 4
77528: ST_TO_ADDR
// end ;
77529: LD_VAR 0 3
77533: RET
// export function DangerInArea ( side , area ) ; begin
77534: LD_INT 0
77536: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
77537: LD_ADDR_VAR 0 3
77541: PUSH
77542: LD_VAR 0 2
77546: PPUSH
77547: LD_INT 81
77549: PUSH
77550: LD_VAR 0 1
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PPUSH
77559: CALL_OW 70
77563: ST_TO_ADDR
// end ;
77564: LD_VAR 0 3
77568: RET
// export function IsExtension ( b ) ; begin
77569: LD_INT 0
77571: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
77572: LD_ADDR_VAR 0 2
77576: PUSH
77577: LD_VAR 0 1
77581: PUSH
77582: LD_INT 23
77584: PUSH
77585: LD_INT 20
77587: PUSH
77588: LD_INT 22
77590: PUSH
77591: LD_INT 17
77593: PUSH
77594: LD_INT 24
77596: PUSH
77597: LD_INT 21
77599: PUSH
77600: LD_INT 19
77602: PUSH
77603: LD_INT 16
77605: PUSH
77606: LD_INT 25
77608: PUSH
77609: LD_INT 18
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: IN
77624: ST_TO_ADDR
// end ;
77625: LD_VAR 0 2
77629: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
77630: LD_INT 0
77632: PPUSH
77633: PPUSH
77634: PPUSH
// result := [ ] ;
77635: LD_ADDR_VAR 0 4
77639: PUSH
77640: EMPTY
77641: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
77642: LD_ADDR_VAR 0 5
77646: PUSH
77647: LD_VAR 0 2
77651: PPUSH
77652: LD_INT 21
77654: PUSH
77655: LD_INT 3
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PPUSH
77662: CALL_OW 70
77666: ST_TO_ADDR
// if not tmp then
77667: LD_VAR 0 5
77671: NOT
77672: IFFALSE 77676
// exit ;
77674: GO 77740
// if checkLink then
77676: LD_VAR 0 3
77680: IFFALSE 77730
// begin for i in tmp do
77682: LD_ADDR_VAR 0 6
77686: PUSH
77687: LD_VAR 0 5
77691: PUSH
77692: FOR_IN
77693: IFFALSE 77728
// if GetBase ( i ) <> base then
77695: LD_VAR 0 6
77699: PPUSH
77700: CALL_OW 274
77704: PUSH
77705: LD_VAR 0 1
77709: NONEQUAL
77710: IFFALSE 77726
// ComLinkToBase ( base , i ) ;
77712: LD_VAR 0 1
77716: PPUSH
77717: LD_VAR 0 6
77721: PPUSH
77722: CALL_OW 169
77726: GO 77692
77728: POP
77729: POP
// end ; result := tmp ;
77730: LD_ADDR_VAR 0 4
77734: PUSH
77735: LD_VAR 0 5
77739: ST_TO_ADDR
// end ;
77740: LD_VAR 0 4
77744: RET
// export function ComComplete ( units , b ) ; var i ; begin
77745: LD_INT 0
77747: PPUSH
77748: PPUSH
// if not units then
77749: LD_VAR 0 1
77753: NOT
77754: IFFALSE 77758
// exit ;
77756: GO 77848
// for i in units do
77758: LD_ADDR_VAR 0 4
77762: PUSH
77763: LD_VAR 0 1
77767: PUSH
77768: FOR_IN
77769: IFFALSE 77846
// if BuildingStatus ( b ) = bs_build then
77771: LD_VAR 0 2
77775: PPUSH
77776: CALL_OW 461
77780: PUSH
77781: LD_INT 1
77783: EQUAL
77784: IFFALSE 77844
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
77786: LD_VAR 0 4
77790: PPUSH
77791: LD_STRING h
77793: PUSH
77794: LD_VAR 0 2
77798: PPUSH
77799: CALL_OW 250
77803: PUSH
77804: LD_VAR 0 2
77808: PPUSH
77809: CALL_OW 251
77813: PUSH
77814: LD_VAR 0 2
77818: PUSH
77819: LD_INT 0
77821: PUSH
77822: LD_INT 0
77824: PUSH
77825: LD_INT 0
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: LIST
77835: LIST
77836: PUSH
77837: EMPTY
77838: LIST
77839: PPUSH
77840: CALL_OW 446
77844: GO 77768
77846: POP
77847: POP
// end ;
77848: LD_VAR 0 3
77852: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
77853: LD_INT 0
77855: PPUSH
77856: PPUSH
77857: PPUSH
77858: PPUSH
77859: PPUSH
77860: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
77861: LD_VAR 0 1
77865: NOT
77866: PUSH
77867: LD_VAR 0 1
77871: PPUSH
77872: CALL_OW 263
77876: PUSH
77877: LD_INT 2
77879: NONEQUAL
77880: OR
77881: IFFALSE 77885
// exit ;
77883: GO 78201
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
77885: LD_ADDR_VAR 0 6
77889: PUSH
77890: LD_INT 22
77892: PUSH
77893: LD_VAR 0 1
77897: PPUSH
77898: CALL_OW 255
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: LD_INT 2
77909: PUSH
77910: LD_INT 30
77912: PUSH
77913: LD_INT 36
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 34
77922: PUSH
77923: LD_INT 31
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: LIST
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PPUSH
77939: CALL_OW 69
77943: ST_TO_ADDR
// if not tmp then
77944: LD_VAR 0 6
77948: NOT
77949: IFFALSE 77953
// exit ;
77951: GO 78201
// result := [ ] ;
77953: LD_ADDR_VAR 0 2
77957: PUSH
77958: EMPTY
77959: ST_TO_ADDR
// for i in tmp do
77960: LD_ADDR_VAR 0 3
77964: PUSH
77965: LD_VAR 0 6
77969: PUSH
77970: FOR_IN
77971: IFFALSE 78042
// begin t := UnitsInside ( i ) ;
77973: LD_ADDR_VAR 0 4
77977: PUSH
77978: LD_VAR 0 3
77982: PPUSH
77983: CALL_OW 313
77987: ST_TO_ADDR
// if t then
77988: LD_VAR 0 4
77992: IFFALSE 78040
// for j in t do
77994: LD_ADDR_VAR 0 7
77998: PUSH
77999: LD_VAR 0 4
78003: PUSH
78004: FOR_IN
78005: IFFALSE 78038
// result := Replace ( result , result + 1 , j ) ;
78007: LD_ADDR_VAR 0 2
78011: PUSH
78012: LD_VAR 0 2
78016: PPUSH
78017: LD_VAR 0 2
78021: PUSH
78022: LD_INT 1
78024: PLUS
78025: PPUSH
78026: LD_VAR 0 7
78030: PPUSH
78031: CALL_OW 1
78035: ST_TO_ADDR
78036: GO 78004
78038: POP
78039: POP
// end ;
78040: GO 77970
78042: POP
78043: POP
// if not result then
78044: LD_VAR 0 2
78048: NOT
78049: IFFALSE 78053
// exit ;
78051: GO 78201
// mech := result [ 1 ] ;
78053: LD_ADDR_VAR 0 5
78057: PUSH
78058: LD_VAR 0 2
78062: PUSH
78063: LD_INT 1
78065: ARRAY
78066: ST_TO_ADDR
// if result > 1 then
78067: LD_VAR 0 2
78071: PUSH
78072: LD_INT 1
78074: GREATER
78075: IFFALSE 78187
// begin for i = 2 to result do
78077: LD_ADDR_VAR 0 3
78081: PUSH
78082: DOUBLE
78083: LD_INT 2
78085: DEC
78086: ST_TO_ADDR
78087: LD_VAR 0 2
78091: PUSH
78092: FOR_TO
78093: IFFALSE 78185
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
78095: LD_ADDR_VAR 0 4
78099: PUSH
78100: LD_VAR 0 2
78104: PUSH
78105: LD_VAR 0 3
78109: ARRAY
78110: PPUSH
78111: LD_INT 3
78113: PPUSH
78114: CALL_OW 259
78118: PUSH
78119: LD_VAR 0 2
78123: PUSH
78124: LD_VAR 0 3
78128: ARRAY
78129: PPUSH
78130: CALL_OW 432
78134: MINUS
78135: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
78136: LD_VAR 0 4
78140: PUSH
78141: LD_VAR 0 5
78145: PPUSH
78146: LD_INT 3
78148: PPUSH
78149: CALL_OW 259
78153: PUSH
78154: LD_VAR 0 5
78158: PPUSH
78159: CALL_OW 432
78163: MINUS
78164: GREATEREQUAL
78165: IFFALSE 78183
// mech := result [ i ] ;
78167: LD_ADDR_VAR 0 5
78171: PUSH
78172: LD_VAR 0 2
78176: PUSH
78177: LD_VAR 0 3
78181: ARRAY
78182: ST_TO_ADDR
// end ;
78183: GO 78092
78185: POP
78186: POP
// end ; ComLinkTo ( vehicle , mech ) ;
78187: LD_VAR 0 1
78191: PPUSH
78192: LD_VAR 0 5
78196: PPUSH
78197: CALL_OW 135
// end ;
78201: LD_VAR 0 2
78205: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
78206: LD_INT 0
78208: PPUSH
78209: PPUSH
78210: PPUSH
78211: PPUSH
78212: PPUSH
78213: PPUSH
78214: PPUSH
78215: PPUSH
78216: PPUSH
78217: PPUSH
78218: PPUSH
78219: PPUSH
78220: PPUSH
// result := [ ] ;
78221: LD_ADDR_VAR 0 7
78225: PUSH
78226: EMPTY
78227: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
78228: LD_VAR 0 1
78232: PPUSH
78233: CALL_OW 266
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: LD_INT 1
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: IN
78248: NOT
78249: IFFALSE 78253
// exit ;
78251: GO 79887
// if name then
78253: LD_VAR 0 3
78257: IFFALSE 78273
// SetBName ( base_dep , name ) ;
78259: LD_VAR 0 1
78263: PPUSH
78264: LD_VAR 0 3
78268: PPUSH
78269: CALL_OW 500
// base := GetBase ( base_dep ) ;
78273: LD_ADDR_VAR 0 15
78277: PUSH
78278: LD_VAR 0 1
78282: PPUSH
78283: CALL_OW 274
78287: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
78288: LD_ADDR_VAR 0 16
78292: PUSH
78293: LD_VAR 0 1
78297: PPUSH
78298: CALL_OW 255
78302: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
78303: LD_ADDR_VAR 0 17
78307: PUSH
78308: LD_VAR 0 1
78312: PPUSH
78313: CALL_OW 248
78317: ST_TO_ADDR
// if sources then
78318: LD_VAR 0 5
78322: IFFALSE 78369
// for i = 1 to 3 do
78324: LD_ADDR_VAR 0 8
78328: PUSH
78329: DOUBLE
78330: LD_INT 1
78332: DEC
78333: ST_TO_ADDR
78334: LD_INT 3
78336: PUSH
78337: FOR_TO
78338: IFFALSE 78367
// AddResourceType ( base , i , sources [ i ] ) ;
78340: LD_VAR 0 15
78344: PPUSH
78345: LD_VAR 0 8
78349: PPUSH
78350: LD_VAR 0 5
78354: PUSH
78355: LD_VAR 0 8
78359: ARRAY
78360: PPUSH
78361: CALL_OW 276
78365: GO 78337
78367: POP
78368: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
78369: LD_ADDR_VAR 0 18
78373: PUSH
78374: LD_VAR 0 15
78378: PPUSH
78379: LD_VAR 0 2
78383: PPUSH
78384: LD_INT 1
78386: PPUSH
78387: CALL 77630 0 3
78391: ST_TO_ADDR
// InitHc ;
78392: CALL_OW 19
// InitUc ;
78396: CALL_OW 18
// uc_side := side ;
78400: LD_ADDR_OWVAR 20
78404: PUSH
78405: LD_VAR 0 16
78409: ST_TO_ADDR
// uc_nation := nation ;
78410: LD_ADDR_OWVAR 21
78414: PUSH
78415: LD_VAR 0 17
78419: ST_TO_ADDR
// if buildings then
78420: LD_VAR 0 18
78424: IFFALSE 79746
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
78426: LD_ADDR_VAR 0 19
78430: PUSH
78431: LD_VAR 0 18
78435: PPUSH
78436: LD_INT 2
78438: PUSH
78439: LD_INT 30
78441: PUSH
78442: LD_INT 29
78444: PUSH
78445: EMPTY
78446: LIST
78447: LIST
78448: PUSH
78449: LD_INT 30
78451: PUSH
78452: LD_INT 30
78454: PUSH
78455: EMPTY
78456: LIST
78457: LIST
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: LIST
78463: PPUSH
78464: CALL_OW 72
78468: ST_TO_ADDR
// if tmp then
78469: LD_VAR 0 19
78473: IFFALSE 78521
// for i in tmp do
78475: LD_ADDR_VAR 0 8
78479: PUSH
78480: LD_VAR 0 19
78484: PUSH
78485: FOR_IN
78486: IFFALSE 78519
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
78488: LD_VAR 0 8
78492: PPUSH
78493: CALL_OW 250
78497: PPUSH
78498: LD_VAR 0 8
78502: PPUSH
78503: CALL_OW 251
78507: PPUSH
78508: LD_VAR 0 16
78512: PPUSH
78513: CALL_OW 441
78517: GO 78485
78519: POP
78520: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
78521: LD_VAR 0 18
78525: PPUSH
78526: LD_INT 2
78528: PUSH
78529: LD_INT 30
78531: PUSH
78532: LD_INT 32
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 30
78541: PUSH
78542: LD_INT 33
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: LIST
78553: PPUSH
78554: CALL_OW 72
78558: IFFALSE 78646
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
78560: LD_ADDR_VAR 0 8
78564: PUSH
78565: LD_VAR 0 18
78569: PPUSH
78570: LD_INT 2
78572: PUSH
78573: LD_INT 30
78575: PUSH
78576: LD_INT 32
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 30
78585: PUSH
78586: LD_INT 33
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: LIST
78597: PPUSH
78598: CALL_OW 72
78602: PUSH
78603: FOR_IN
78604: IFFALSE 78644
// begin if not GetBWeapon ( i ) then
78606: LD_VAR 0 8
78610: PPUSH
78611: CALL_OW 269
78615: NOT
78616: IFFALSE 78642
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
78618: LD_VAR 0 8
78622: PPUSH
78623: LD_VAR 0 8
78627: PPUSH
78628: LD_VAR 0 2
78632: PPUSH
78633: CALL 79892 0 2
78637: PPUSH
78638: CALL_OW 431
// end ;
78642: GO 78603
78644: POP
78645: POP
// end ; for i = 1 to personel do
78646: LD_ADDR_VAR 0 8
78650: PUSH
78651: DOUBLE
78652: LD_INT 1
78654: DEC
78655: ST_TO_ADDR
78656: LD_VAR 0 6
78660: PUSH
78661: FOR_TO
78662: IFFALSE 79726
// begin if i > 4 then
78664: LD_VAR 0 8
78668: PUSH
78669: LD_INT 4
78671: GREATER
78672: IFFALSE 78676
// break ;
78674: GO 79726
// case i of 1 :
78676: LD_VAR 0 8
78680: PUSH
78681: LD_INT 1
78683: DOUBLE
78684: EQUAL
78685: IFTRUE 78689
78687: GO 78769
78689: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
78690: LD_ADDR_VAR 0 12
78694: PUSH
78695: LD_VAR 0 18
78699: PPUSH
78700: LD_INT 22
78702: PUSH
78703: LD_VAR 0 16
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 58
78714: PUSH
78715: EMPTY
78716: LIST
78717: PUSH
78718: LD_INT 2
78720: PUSH
78721: LD_INT 30
78723: PUSH
78724: LD_INT 32
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 30
78733: PUSH
78734: LD_INT 4
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 30
78743: PUSH
78744: LD_INT 5
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: EMPTY
78752: LIST
78753: LIST
78754: LIST
78755: LIST
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: LIST
78761: PPUSH
78762: CALL_OW 72
78766: ST_TO_ADDR
78767: GO 78991
78769: LD_INT 2
78771: DOUBLE
78772: EQUAL
78773: IFTRUE 78777
78775: GO 78839
78777: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
78778: LD_ADDR_VAR 0 12
78782: PUSH
78783: LD_VAR 0 18
78787: PPUSH
78788: LD_INT 22
78790: PUSH
78791: LD_VAR 0 16
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 2
78802: PUSH
78803: LD_INT 30
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 30
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: LIST
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PPUSH
78832: CALL_OW 72
78836: ST_TO_ADDR
78837: GO 78991
78839: LD_INT 3
78841: DOUBLE
78842: EQUAL
78843: IFTRUE 78847
78845: GO 78909
78847: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
78848: LD_ADDR_VAR 0 12
78852: PUSH
78853: LD_VAR 0 18
78857: PPUSH
78858: LD_INT 22
78860: PUSH
78861: LD_VAR 0 16
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 2
78872: PUSH
78873: LD_INT 30
78875: PUSH
78876: LD_INT 2
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 30
78885: PUSH
78886: LD_INT 3
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: LIST
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PPUSH
78902: CALL_OW 72
78906: ST_TO_ADDR
78907: GO 78991
78909: LD_INT 4
78911: DOUBLE
78912: EQUAL
78913: IFTRUE 78917
78915: GO 78990
78917: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
78918: LD_ADDR_VAR 0 12
78922: PUSH
78923: LD_VAR 0 18
78927: PPUSH
78928: LD_INT 22
78930: PUSH
78931: LD_VAR 0 16
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 2
78942: PUSH
78943: LD_INT 30
78945: PUSH
78946: LD_INT 6
78948: PUSH
78949: EMPTY
78950: LIST
78951: LIST
78952: PUSH
78953: LD_INT 30
78955: PUSH
78956: LD_INT 7
78958: PUSH
78959: EMPTY
78960: LIST
78961: LIST
78962: PUSH
78963: LD_INT 30
78965: PUSH
78966: LD_INT 8
78968: PUSH
78969: EMPTY
78970: LIST
78971: LIST
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PPUSH
78983: CALL_OW 72
78987: ST_TO_ADDR
78988: GO 78991
78990: POP
// if i = 1 then
78991: LD_VAR 0 8
78995: PUSH
78996: LD_INT 1
78998: EQUAL
78999: IFFALSE 79110
// begin tmp := [ ] ;
79001: LD_ADDR_VAR 0 19
79005: PUSH
79006: EMPTY
79007: ST_TO_ADDR
// for j in f do
79008: LD_ADDR_VAR 0 9
79012: PUSH
79013: LD_VAR 0 12
79017: PUSH
79018: FOR_IN
79019: IFFALSE 79092
// if GetBType ( j ) = b_bunker then
79021: LD_VAR 0 9
79025: PPUSH
79026: CALL_OW 266
79030: PUSH
79031: LD_INT 32
79033: EQUAL
79034: IFFALSE 79061
// tmp := Insert ( tmp , 1 , j ) else
79036: LD_ADDR_VAR 0 19
79040: PUSH
79041: LD_VAR 0 19
79045: PPUSH
79046: LD_INT 1
79048: PPUSH
79049: LD_VAR 0 9
79053: PPUSH
79054: CALL_OW 2
79058: ST_TO_ADDR
79059: GO 79090
// tmp := Insert ( tmp , tmp + 1 , j ) ;
79061: LD_ADDR_VAR 0 19
79065: PUSH
79066: LD_VAR 0 19
79070: PPUSH
79071: LD_VAR 0 19
79075: PUSH
79076: LD_INT 1
79078: PLUS
79079: PPUSH
79080: LD_VAR 0 9
79084: PPUSH
79085: CALL_OW 2
79089: ST_TO_ADDR
79090: GO 79018
79092: POP
79093: POP
// if tmp then
79094: LD_VAR 0 19
79098: IFFALSE 79110
// f := tmp ;
79100: LD_ADDR_VAR 0 12
79104: PUSH
79105: LD_VAR 0 19
79109: ST_TO_ADDR
// end ; x := personel [ i ] ;
79110: LD_ADDR_VAR 0 13
79114: PUSH
79115: LD_VAR 0 6
79119: PUSH
79120: LD_VAR 0 8
79124: ARRAY
79125: ST_TO_ADDR
// if x = - 1 then
79126: LD_VAR 0 13
79130: PUSH
79131: LD_INT 1
79133: NEG
79134: EQUAL
79135: IFFALSE 79344
// begin for j in f do
79137: LD_ADDR_VAR 0 9
79141: PUSH
79142: LD_VAR 0 12
79146: PUSH
79147: FOR_IN
79148: IFFALSE 79340
// repeat InitHc ;
79150: CALL_OW 19
// if GetBType ( j ) = b_barracks then
79154: LD_VAR 0 9
79158: PPUSH
79159: CALL_OW 266
79163: PUSH
79164: LD_INT 5
79166: EQUAL
79167: IFFALSE 79237
// begin if UnitsInside ( j ) < 3 then
79169: LD_VAR 0 9
79173: PPUSH
79174: CALL_OW 313
79178: PUSH
79179: LD_INT 3
79181: LESS
79182: IFFALSE 79218
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79184: LD_INT 0
79186: PPUSH
79187: LD_INT 5
79189: PUSH
79190: LD_INT 8
79192: PUSH
79193: LD_INT 9
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: LIST
79200: PUSH
79201: LD_VAR 0 17
79205: ARRAY
79206: PPUSH
79207: LD_VAR 0 4
79211: PPUSH
79212: CALL_OW 380
79216: GO 79235
// PrepareHuman ( false , i , skill ) ;
79218: LD_INT 0
79220: PPUSH
79221: LD_VAR 0 8
79225: PPUSH
79226: LD_VAR 0 4
79230: PPUSH
79231: CALL_OW 380
// end else
79235: GO 79254
// PrepareHuman ( false , i , skill ) ;
79237: LD_INT 0
79239: PPUSH
79240: LD_VAR 0 8
79244: PPUSH
79245: LD_VAR 0 4
79249: PPUSH
79250: CALL_OW 380
// un := CreateHuman ;
79254: LD_ADDR_VAR 0 14
79258: PUSH
79259: CALL_OW 44
79263: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79264: LD_ADDR_VAR 0 7
79268: PUSH
79269: LD_VAR 0 7
79273: PPUSH
79274: LD_INT 1
79276: PPUSH
79277: LD_VAR 0 14
79281: PPUSH
79282: CALL_OW 2
79286: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
79287: LD_VAR 0 14
79291: PPUSH
79292: LD_VAR 0 9
79296: PPUSH
79297: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
79301: LD_VAR 0 9
79305: PPUSH
79306: CALL_OW 313
79310: PUSH
79311: LD_INT 6
79313: EQUAL
79314: PUSH
79315: LD_VAR 0 9
79319: PPUSH
79320: CALL_OW 266
79324: PUSH
79325: LD_INT 32
79327: PUSH
79328: LD_INT 31
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: IN
79335: OR
79336: IFFALSE 79150
79338: GO 79147
79340: POP
79341: POP
// end else
79342: GO 79724
// for j = 1 to x do
79344: LD_ADDR_VAR 0 9
79348: PUSH
79349: DOUBLE
79350: LD_INT 1
79352: DEC
79353: ST_TO_ADDR
79354: LD_VAR 0 13
79358: PUSH
79359: FOR_TO
79360: IFFALSE 79722
// begin InitHc ;
79362: CALL_OW 19
// if not f then
79366: LD_VAR 0 12
79370: NOT
79371: IFFALSE 79460
// begin PrepareHuman ( false , i , skill ) ;
79373: LD_INT 0
79375: PPUSH
79376: LD_VAR 0 8
79380: PPUSH
79381: LD_VAR 0 4
79385: PPUSH
79386: CALL_OW 380
// un := CreateHuman ;
79390: LD_ADDR_VAR 0 14
79394: PUSH
79395: CALL_OW 44
79399: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79400: LD_ADDR_VAR 0 7
79404: PUSH
79405: LD_VAR 0 7
79409: PPUSH
79410: LD_INT 1
79412: PPUSH
79413: LD_VAR 0 14
79417: PPUSH
79418: CALL_OW 2
79422: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79423: LD_VAR 0 14
79427: PPUSH
79428: LD_VAR 0 1
79432: PPUSH
79433: CALL_OW 250
79437: PPUSH
79438: LD_VAR 0 1
79442: PPUSH
79443: CALL_OW 251
79447: PPUSH
79448: LD_INT 10
79450: PPUSH
79451: LD_INT 0
79453: PPUSH
79454: CALL_OW 50
// continue ;
79458: GO 79359
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
79460: LD_VAR 0 12
79464: PUSH
79465: LD_INT 1
79467: ARRAY
79468: PPUSH
79469: CALL_OW 313
79473: PUSH
79474: LD_VAR 0 12
79478: PUSH
79479: LD_INT 1
79481: ARRAY
79482: PPUSH
79483: CALL_OW 266
79487: PUSH
79488: LD_INT 32
79490: PUSH
79491: LD_INT 31
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: IN
79498: AND
79499: PUSH
79500: LD_VAR 0 12
79504: PUSH
79505: LD_INT 1
79507: ARRAY
79508: PPUSH
79509: CALL_OW 313
79513: PUSH
79514: LD_INT 6
79516: EQUAL
79517: OR
79518: IFFALSE 79538
// f := Delete ( f , 1 ) ;
79520: LD_ADDR_VAR 0 12
79524: PUSH
79525: LD_VAR 0 12
79529: PPUSH
79530: LD_INT 1
79532: PPUSH
79533: CALL_OW 3
79537: ST_TO_ADDR
// if not f then
79538: LD_VAR 0 12
79542: NOT
79543: IFFALSE 79561
// begin x := x + 2 ;
79545: LD_ADDR_VAR 0 13
79549: PUSH
79550: LD_VAR 0 13
79554: PUSH
79555: LD_INT 2
79557: PLUS
79558: ST_TO_ADDR
// continue ;
79559: GO 79359
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
79561: LD_VAR 0 12
79565: PUSH
79566: LD_INT 1
79568: ARRAY
79569: PPUSH
79570: CALL_OW 266
79574: PUSH
79575: LD_INT 5
79577: EQUAL
79578: IFFALSE 79652
// begin if UnitsInside ( f [ 1 ] ) < 3 then
79580: LD_VAR 0 12
79584: PUSH
79585: LD_INT 1
79587: ARRAY
79588: PPUSH
79589: CALL_OW 313
79593: PUSH
79594: LD_INT 3
79596: LESS
79597: IFFALSE 79633
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
79599: LD_INT 0
79601: PPUSH
79602: LD_INT 5
79604: PUSH
79605: LD_INT 8
79607: PUSH
79608: LD_INT 9
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: LIST
79615: PUSH
79616: LD_VAR 0 17
79620: ARRAY
79621: PPUSH
79622: LD_VAR 0 4
79626: PPUSH
79627: CALL_OW 380
79631: GO 79650
// PrepareHuman ( false , i , skill ) ;
79633: LD_INT 0
79635: PPUSH
79636: LD_VAR 0 8
79640: PPUSH
79641: LD_VAR 0 4
79645: PPUSH
79646: CALL_OW 380
// end else
79650: GO 79669
// PrepareHuman ( false , i , skill ) ;
79652: LD_INT 0
79654: PPUSH
79655: LD_VAR 0 8
79659: PPUSH
79660: LD_VAR 0 4
79664: PPUSH
79665: CALL_OW 380
// un := CreateHuman ;
79669: LD_ADDR_VAR 0 14
79673: PUSH
79674: CALL_OW 44
79678: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
79679: LD_ADDR_VAR 0 7
79683: PUSH
79684: LD_VAR 0 7
79688: PPUSH
79689: LD_INT 1
79691: PPUSH
79692: LD_VAR 0 14
79696: PPUSH
79697: CALL_OW 2
79701: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
79702: LD_VAR 0 14
79706: PPUSH
79707: LD_VAR 0 12
79711: PUSH
79712: LD_INT 1
79714: ARRAY
79715: PPUSH
79716: CALL_OW 52
// end ;
79720: GO 79359
79722: POP
79723: POP
// end ;
79724: GO 78661
79726: POP
79727: POP
// result := result ^ buildings ;
79728: LD_ADDR_VAR 0 7
79732: PUSH
79733: LD_VAR 0 7
79737: PUSH
79738: LD_VAR 0 18
79742: ADD
79743: ST_TO_ADDR
// end else
79744: GO 79887
// begin for i = 1 to personel do
79746: LD_ADDR_VAR 0 8
79750: PUSH
79751: DOUBLE
79752: LD_INT 1
79754: DEC
79755: ST_TO_ADDR
79756: LD_VAR 0 6
79760: PUSH
79761: FOR_TO
79762: IFFALSE 79885
// begin if i > 4 then
79764: LD_VAR 0 8
79768: PUSH
79769: LD_INT 4
79771: GREATER
79772: IFFALSE 79776
// break ;
79774: GO 79885
// x := personel [ i ] ;
79776: LD_ADDR_VAR 0 13
79780: PUSH
79781: LD_VAR 0 6
79785: PUSH
79786: LD_VAR 0 8
79790: ARRAY
79791: ST_TO_ADDR
// if x = - 1 then
79792: LD_VAR 0 13
79796: PUSH
79797: LD_INT 1
79799: NEG
79800: EQUAL
79801: IFFALSE 79805
// continue ;
79803: GO 79761
// PrepareHuman ( false , i , skill ) ;
79805: LD_INT 0
79807: PPUSH
79808: LD_VAR 0 8
79812: PPUSH
79813: LD_VAR 0 4
79817: PPUSH
79818: CALL_OW 380
// un := CreateHuman ;
79822: LD_ADDR_VAR 0 14
79826: PUSH
79827: CALL_OW 44
79831: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
79832: LD_VAR 0 14
79836: PPUSH
79837: LD_VAR 0 1
79841: PPUSH
79842: CALL_OW 250
79846: PPUSH
79847: LD_VAR 0 1
79851: PPUSH
79852: CALL_OW 251
79856: PPUSH
79857: LD_INT 10
79859: PPUSH
79860: LD_INT 0
79862: PPUSH
79863: CALL_OW 50
// result := result ^ un ;
79867: LD_ADDR_VAR 0 7
79871: PUSH
79872: LD_VAR 0 7
79876: PUSH
79877: LD_VAR 0 14
79881: ADD
79882: ST_TO_ADDR
// end ;
79883: GO 79761
79885: POP
79886: POP
// end ; end ;
79887: LD_VAR 0 7
79891: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
79892: LD_INT 0
79894: PPUSH
79895: PPUSH
79896: PPUSH
79897: PPUSH
79898: PPUSH
79899: PPUSH
79900: PPUSH
79901: PPUSH
79902: PPUSH
79903: PPUSH
79904: PPUSH
79905: PPUSH
79906: PPUSH
79907: PPUSH
79908: PPUSH
79909: PPUSH
// result := false ;
79910: LD_ADDR_VAR 0 3
79914: PUSH
79915: LD_INT 0
79917: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
79918: LD_VAR 0 1
79922: NOT
79923: PUSH
79924: LD_VAR 0 1
79928: PPUSH
79929: CALL_OW 266
79933: PUSH
79934: LD_INT 32
79936: PUSH
79937: LD_INT 33
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: IN
79944: NOT
79945: OR
79946: IFFALSE 79950
// exit ;
79948: GO 81059
// nat := GetNation ( tower ) ;
79950: LD_ADDR_VAR 0 12
79954: PUSH
79955: LD_VAR 0 1
79959: PPUSH
79960: CALL_OW 248
79964: ST_TO_ADDR
// side := GetSide ( tower ) ;
79965: LD_ADDR_VAR 0 16
79969: PUSH
79970: LD_VAR 0 1
79974: PPUSH
79975: CALL_OW 255
79979: ST_TO_ADDR
// x := GetX ( tower ) ;
79980: LD_ADDR_VAR 0 10
79984: PUSH
79985: LD_VAR 0 1
79989: PPUSH
79990: CALL_OW 250
79994: ST_TO_ADDR
// y := GetY ( tower ) ;
79995: LD_ADDR_VAR 0 11
79999: PUSH
80000: LD_VAR 0 1
80004: PPUSH
80005: CALL_OW 251
80009: ST_TO_ADDR
// if not x or not y then
80010: LD_VAR 0 10
80014: NOT
80015: PUSH
80016: LD_VAR 0 11
80020: NOT
80021: OR
80022: IFFALSE 80026
// exit ;
80024: GO 81059
// weapon := 0 ;
80026: LD_ADDR_VAR 0 18
80030: PUSH
80031: LD_INT 0
80033: ST_TO_ADDR
// fac_list := [ ] ;
80034: LD_ADDR_VAR 0 17
80038: PUSH
80039: EMPTY
80040: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
80041: LD_ADDR_VAR 0 6
80045: PUSH
80046: LD_VAR 0 1
80050: PPUSH
80051: CALL_OW 274
80055: PPUSH
80056: LD_VAR 0 2
80060: PPUSH
80061: LD_INT 0
80063: PPUSH
80064: CALL 77630 0 3
80068: PPUSH
80069: LD_INT 30
80071: PUSH
80072: LD_INT 3
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PPUSH
80079: CALL_OW 72
80083: ST_TO_ADDR
// if not factories then
80084: LD_VAR 0 6
80088: NOT
80089: IFFALSE 80093
// exit ;
80091: GO 81059
// for i in factories do
80093: LD_ADDR_VAR 0 8
80097: PUSH
80098: LD_VAR 0 6
80102: PUSH
80103: FOR_IN
80104: IFFALSE 80129
// fac_list := fac_list union AvailableWeaponList ( i ) ;
80106: LD_ADDR_VAR 0 17
80110: PUSH
80111: LD_VAR 0 17
80115: PUSH
80116: LD_VAR 0 8
80120: PPUSH
80121: CALL_OW 478
80125: UNION
80126: ST_TO_ADDR
80127: GO 80103
80129: POP
80130: POP
// if not fac_list then
80131: LD_VAR 0 17
80135: NOT
80136: IFFALSE 80140
// exit ;
80138: GO 81059
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
80140: LD_ADDR_VAR 0 5
80144: PUSH
80145: LD_INT 4
80147: PUSH
80148: LD_INT 5
80150: PUSH
80151: LD_INT 9
80153: PUSH
80154: LD_INT 10
80156: PUSH
80157: LD_INT 6
80159: PUSH
80160: LD_INT 7
80162: PUSH
80163: LD_INT 11
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 27
80177: PUSH
80178: LD_INT 28
80180: PUSH
80181: LD_INT 26
80183: PUSH
80184: LD_INT 30
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 43
80195: PUSH
80196: LD_INT 44
80198: PUSH
80199: LD_INT 46
80201: PUSH
80202: LD_INT 45
80204: PUSH
80205: LD_INT 47
80207: PUSH
80208: LD_INT 49
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: LIST
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: LIST
80223: PUSH
80224: LD_VAR 0 12
80228: ARRAY
80229: ST_TO_ADDR
// list := list isect fac_list ;
80230: LD_ADDR_VAR 0 5
80234: PUSH
80235: LD_VAR 0 5
80239: PUSH
80240: LD_VAR 0 17
80244: ISECT
80245: ST_TO_ADDR
// if not list then
80246: LD_VAR 0 5
80250: NOT
80251: IFFALSE 80255
// exit ;
80253: GO 81059
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
80255: LD_VAR 0 12
80259: PUSH
80260: LD_INT 3
80262: EQUAL
80263: PUSH
80264: LD_INT 49
80266: PUSH
80267: LD_VAR 0 5
80271: IN
80272: AND
80273: PUSH
80274: LD_INT 31
80276: PPUSH
80277: LD_VAR 0 16
80281: PPUSH
80282: CALL_OW 321
80286: PUSH
80287: LD_INT 2
80289: EQUAL
80290: AND
80291: IFFALSE 80351
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
80293: LD_INT 22
80295: PUSH
80296: LD_VAR 0 16
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 35
80307: PUSH
80308: LD_INT 49
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 91
80317: PUSH
80318: LD_VAR 0 1
80322: PUSH
80323: LD_INT 10
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: LIST
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: LIST
80335: PPUSH
80336: CALL_OW 69
80340: NOT
80341: IFFALSE 80351
// weapon := ru_time_lapser ;
80343: LD_ADDR_VAR 0 18
80347: PUSH
80348: LD_INT 49
80350: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
80351: LD_VAR 0 12
80355: PUSH
80356: LD_INT 1
80358: PUSH
80359: LD_INT 2
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: IN
80366: PUSH
80367: LD_INT 11
80369: PUSH
80370: LD_VAR 0 5
80374: IN
80375: PUSH
80376: LD_INT 30
80378: PUSH
80379: LD_VAR 0 5
80383: IN
80384: OR
80385: AND
80386: PUSH
80387: LD_INT 6
80389: PPUSH
80390: LD_VAR 0 16
80394: PPUSH
80395: CALL_OW 321
80399: PUSH
80400: LD_INT 2
80402: EQUAL
80403: AND
80404: IFFALSE 80569
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
80406: LD_INT 22
80408: PUSH
80409: LD_VAR 0 16
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 2
80420: PUSH
80421: LD_INT 35
80423: PUSH
80424: LD_INT 11
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 35
80433: PUSH
80434: LD_INT 30
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 91
80448: PUSH
80449: LD_VAR 0 1
80453: PUSH
80454: LD_INT 18
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: LIST
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: LIST
80466: PPUSH
80467: CALL_OW 69
80471: NOT
80472: PUSH
80473: LD_INT 22
80475: PUSH
80476: LD_VAR 0 16
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 2
80487: PUSH
80488: LD_INT 30
80490: PUSH
80491: LD_INT 32
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 30
80500: PUSH
80501: LD_INT 33
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 91
80515: PUSH
80516: LD_VAR 0 1
80520: PUSH
80521: LD_INT 12
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: LIST
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: LIST
80533: PUSH
80534: EMPTY
80535: LIST
80536: PPUSH
80537: CALL_OW 69
80541: PUSH
80542: LD_INT 2
80544: GREATER
80545: AND
80546: IFFALSE 80569
// weapon := [ us_radar , ar_radar ] [ nat ] ;
80548: LD_ADDR_VAR 0 18
80552: PUSH
80553: LD_INT 11
80555: PUSH
80556: LD_INT 30
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_VAR 0 12
80567: ARRAY
80568: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
80569: LD_VAR 0 18
80573: NOT
80574: PUSH
80575: LD_INT 40
80577: PPUSH
80578: LD_VAR 0 16
80582: PPUSH
80583: CALL_OW 321
80587: PUSH
80588: LD_INT 2
80590: EQUAL
80591: AND
80592: PUSH
80593: LD_INT 7
80595: PUSH
80596: LD_VAR 0 5
80600: IN
80601: PUSH
80602: LD_INT 28
80604: PUSH
80605: LD_VAR 0 5
80609: IN
80610: OR
80611: PUSH
80612: LD_INT 45
80614: PUSH
80615: LD_VAR 0 5
80619: IN
80620: OR
80621: AND
80622: IFFALSE 80876
// begin hex := GetHexInfo ( x , y ) ;
80624: LD_ADDR_VAR 0 4
80628: PUSH
80629: LD_VAR 0 10
80633: PPUSH
80634: LD_VAR 0 11
80638: PPUSH
80639: CALL_OW 546
80643: ST_TO_ADDR
// if hex [ 1 ] then
80644: LD_VAR 0 4
80648: PUSH
80649: LD_INT 1
80651: ARRAY
80652: IFFALSE 80656
// exit ;
80654: GO 81059
// height := hex [ 2 ] ;
80656: LD_ADDR_VAR 0 15
80660: PUSH
80661: LD_VAR 0 4
80665: PUSH
80666: LD_INT 2
80668: ARRAY
80669: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
80670: LD_ADDR_VAR 0 14
80674: PUSH
80675: LD_INT 0
80677: PUSH
80678: LD_INT 2
80680: PUSH
80681: LD_INT 3
80683: PUSH
80684: LD_INT 5
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: ST_TO_ADDR
// for i in tmp do
80693: LD_ADDR_VAR 0 8
80697: PUSH
80698: LD_VAR 0 14
80702: PUSH
80703: FOR_IN
80704: IFFALSE 80874
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
80706: LD_ADDR_VAR 0 9
80710: PUSH
80711: LD_VAR 0 10
80715: PPUSH
80716: LD_VAR 0 8
80720: PPUSH
80721: LD_INT 5
80723: PPUSH
80724: CALL_OW 272
80728: PUSH
80729: LD_VAR 0 11
80733: PPUSH
80734: LD_VAR 0 8
80738: PPUSH
80739: LD_INT 5
80741: PPUSH
80742: CALL_OW 273
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80751: LD_VAR 0 9
80755: PUSH
80756: LD_INT 1
80758: ARRAY
80759: PPUSH
80760: LD_VAR 0 9
80764: PUSH
80765: LD_INT 2
80767: ARRAY
80768: PPUSH
80769: CALL_OW 488
80773: IFFALSE 80872
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
80775: LD_ADDR_VAR 0 4
80779: PUSH
80780: LD_VAR 0 9
80784: PUSH
80785: LD_INT 1
80787: ARRAY
80788: PPUSH
80789: LD_VAR 0 9
80793: PUSH
80794: LD_INT 2
80796: ARRAY
80797: PPUSH
80798: CALL_OW 546
80802: ST_TO_ADDR
// if hex [ 1 ] then
80803: LD_VAR 0 4
80807: PUSH
80808: LD_INT 1
80810: ARRAY
80811: IFFALSE 80815
// continue ;
80813: GO 80703
// h := hex [ 2 ] ;
80815: LD_ADDR_VAR 0 13
80819: PUSH
80820: LD_VAR 0 4
80824: PUSH
80825: LD_INT 2
80827: ARRAY
80828: ST_TO_ADDR
// if h + 7 < height then
80829: LD_VAR 0 13
80833: PUSH
80834: LD_INT 7
80836: PLUS
80837: PUSH
80838: LD_VAR 0 15
80842: LESS
80843: IFFALSE 80872
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
80845: LD_ADDR_VAR 0 18
80849: PUSH
80850: LD_INT 7
80852: PUSH
80853: LD_INT 28
80855: PUSH
80856: LD_INT 45
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: LIST
80863: PUSH
80864: LD_VAR 0 12
80868: ARRAY
80869: ST_TO_ADDR
// break ;
80870: GO 80874
// end ; end ; end ;
80872: GO 80703
80874: POP
80875: POP
// end ; if not weapon then
80876: LD_VAR 0 18
80880: NOT
80881: IFFALSE 80941
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
80883: LD_ADDR_VAR 0 5
80887: PUSH
80888: LD_VAR 0 5
80892: PUSH
80893: LD_INT 11
80895: PUSH
80896: LD_INT 30
80898: PUSH
80899: LD_INT 49
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: LIST
80906: DIFF
80907: ST_TO_ADDR
// if not list then
80908: LD_VAR 0 5
80912: NOT
80913: IFFALSE 80917
// exit ;
80915: GO 81059
// weapon := list [ rand ( 1 , list ) ] ;
80917: LD_ADDR_VAR 0 18
80921: PUSH
80922: LD_VAR 0 5
80926: PUSH
80927: LD_INT 1
80929: PPUSH
80930: LD_VAR 0 5
80934: PPUSH
80935: CALL_OW 12
80939: ARRAY
80940: ST_TO_ADDR
// end ; if weapon then
80941: LD_VAR 0 18
80945: IFFALSE 81059
// begin tmp := CostOfWeapon ( weapon ) ;
80947: LD_ADDR_VAR 0 14
80951: PUSH
80952: LD_VAR 0 18
80956: PPUSH
80957: CALL_OW 451
80961: ST_TO_ADDR
// j := GetBase ( tower ) ;
80962: LD_ADDR_VAR 0 9
80966: PUSH
80967: LD_VAR 0 1
80971: PPUSH
80972: CALL_OW 274
80976: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
80977: LD_VAR 0 9
80981: PPUSH
80982: LD_INT 1
80984: PPUSH
80985: CALL_OW 275
80989: PUSH
80990: LD_VAR 0 14
80994: PUSH
80995: LD_INT 1
80997: ARRAY
80998: GREATEREQUAL
80999: PUSH
81000: LD_VAR 0 9
81004: PPUSH
81005: LD_INT 2
81007: PPUSH
81008: CALL_OW 275
81012: PUSH
81013: LD_VAR 0 14
81017: PUSH
81018: LD_INT 2
81020: ARRAY
81021: GREATEREQUAL
81022: AND
81023: PUSH
81024: LD_VAR 0 9
81028: PPUSH
81029: LD_INT 3
81031: PPUSH
81032: CALL_OW 275
81036: PUSH
81037: LD_VAR 0 14
81041: PUSH
81042: LD_INT 3
81044: ARRAY
81045: GREATEREQUAL
81046: AND
81047: IFFALSE 81059
// result := weapon ;
81049: LD_ADDR_VAR 0 3
81053: PUSH
81054: LD_VAR 0 18
81058: ST_TO_ADDR
// end ; end ;
81059: LD_VAR 0 3
81063: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
81064: LD_INT 0
81066: PPUSH
81067: PPUSH
// result := true ;
81068: LD_ADDR_VAR 0 3
81072: PUSH
81073: LD_INT 1
81075: ST_TO_ADDR
// if array1 = array2 then
81076: LD_VAR 0 1
81080: PUSH
81081: LD_VAR 0 2
81085: EQUAL
81086: IFFALSE 81146
// begin for i = 1 to array1 do
81088: LD_ADDR_VAR 0 4
81092: PUSH
81093: DOUBLE
81094: LD_INT 1
81096: DEC
81097: ST_TO_ADDR
81098: LD_VAR 0 1
81102: PUSH
81103: FOR_TO
81104: IFFALSE 81142
// if array1 [ i ] <> array2 [ i ] then
81106: LD_VAR 0 1
81110: PUSH
81111: LD_VAR 0 4
81115: ARRAY
81116: PUSH
81117: LD_VAR 0 2
81121: PUSH
81122: LD_VAR 0 4
81126: ARRAY
81127: NONEQUAL
81128: IFFALSE 81140
// begin result := false ;
81130: LD_ADDR_VAR 0 3
81134: PUSH
81135: LD_INT 0
81137: ST_TO_ADDR
// break ;
81138: GO 81142
// end ;
81140: GO 81103
81142: POP
81143: POP
// end else
81144: GO 81154
// result := false ;
81146: LD_ADDR_VAR 0 3
81150: PUSH
81151: LD_INT 0
81153: ST_TO_ADDR
// end ;
81154: LD_VAR 0 3
81158: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
81159: LD_INT 0
81161: PPUSH
81162: PPUSH
// if not array1 or not array2 then
81163: LD_VAR 0 1
81167: NOT
81168: PUSH
81169: LD_VAR 0 2
81173: NOT
81174: OR
81175: IFFALSE 81179
// exit ;
81177: GO 81243
// result := true ;
81179: LD_ADDR_VAR 0 3
81183: PUSH
81184: LD_INT 1
81186: ST_TO_ADDR
// for i = 1 to array1 do
81187: LD_ADDR_VAR 0 4
81191: PUSH
81192: DOUBLE
81193: LD_INT 1
81195: DEC
81196: ST_TO_ADDR
81197: LD_VAR 0 1
81201: PUSH
81202: FOR_TO
81203: IFFALSE 81241
// if array1 [ i ] <> array2 [ i ] then
81205: LD_VAR 0 1
81209: PUSH
81210: LD_VAR 0 4
81214: ARRAY
81215: PUSH
81216: LD_VAR 0 2
81220: PUSH
81221: LD_VAR 0 4
81225: ARRAY
81226: NONEQUAL
81227: IFFALSE 81239
// begin result := false ;
81229: LD_ADDR_VAR 0 3
81233: PUSH
81234: LD_INT 0
81236: ST_TO_ADDR
// break ;
81237: GO 81241
// end ;
81239: GO 81202
81241: POP
81242: POP
// end ;
81243: LD_VAR 0 3
81247: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
81248: LD_INT 0
81250: PPUSH
81251: PPUSH
81252: PPUSH
// pom := GetBase ( fac ) ;
81253: LD_ADDR_VAR 0 5
81257: PUSH
81258: LD_VAR 0 1
81262: PPUSH
81263: CALL_OW 274
81267: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
81268: LD_ADDR_VAR 0 4
81272: PUSH
81273: LD_VAR 0 2
81277: PUSH
81278: LD_INT 1
81280: ARRAY
81281: PPUSH
81282: LD_VAR 0 2
81286: PUSH
81287: LD_INT 2
81289: ARRAY
81290: PPUSH
81291: LD_VAR 0 2
81295: PUSH
81296: LD_INT 3
81298: ARRAY
81299: PPUSH
81300: LD_VAR 0 2
81304: PUSH
81305: LD_INT 4
81307: ARRAY
81308: PPUSH
81309: CALL_OW 449
81313: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81314: LD_ADDR_VAR 0 3
81318: PUSH
81319: LD_VAR 0 5
81323: PPUSH
81324: LD_INT 1
81326: PPUSH
81327: CALL_OW 275
81331: PUSH
81332: LD_VAR 0 4
81336: PUSH
81337: LD_INT 1
81339: ARRAY
81340: GREATEREQUAL
81341: PUSH
81342: LD_VAR 0 5
81346: PPUSH
81347: LD_INT 2
81349: PPUSH
81350: CALL_OW 275
81354: PUSH
81355: LD_VAR 0 4
81359: PUSH
81360: LD_INT 2
81362: ARRAY
81363: GREATEREQUAL
81364: AND
81365: PUSH
81366: LD_VAR 0 5
81370: PPUSH
81371: LD_INT 3
81373: PPUSH
81374: CALL_OW 275
81378: PUSH
81379: LD_VAR 0 4
81383: PUSH
81384: LD_INT 3
81386: ARRAY
81387: GREATEREQUAL
81388: AND
81389: ST_TO_ADDR
// end ;
81390: LD_VAR 0 3
81394: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
81395: LD_INT 0
81397: PPUSH
81398: PPUSH
81399: PPUSH
81400: PPUSH
// pom := GetBase ( building ) ;
81401: LD_ADDR_VAR 0 3
81405: PUSH
81406: LD_VAR 0 1
81410: PPUSH
81411: CALL_OW 274
81415: ST_TO_ADDR
// if not pom then
81416: LD_VAR 0 3
81420: NOT
81421: IFFALSE 81425
// exit ;
81423: GO 81595
// btype := GetBType ( building ) ;
81425: LD_ADDR_VAR 0 5
81429: PUSH
81430: LD_VAR 0 1
81434: PPUSH
81435: CALL_OW 266
81439: ST_TO_ADDR
// if btype = b_armoury then
81440: LD_VAR 0 5
81444: PUSH
81445: LD_INT 4
81447: EQUAL
81448: IFFALSE 81458
// btype := b_barracks ;
81450: LD_ADDR_VAR 0 5
81454: PUSH
81455: LD_INT 5
81457: ST_TO_ADDR
// if btype = b_depot then
81458: LD_VAR 0 5
81462: PUSH
81463: LD_INT 0
81465: EQUAL
81466: IFFALSE 81476
// btype := b_warehouse ;
81468: LD_ADDR_VAR 0 5
81472: PUSH
81473: LD_INT 1
81475: ST_TO_ADDR
// if btype = b_workshop then
81476: LD_VAR 0 5
81480: PUSH
81481: LD_INT 2
81483: EQUAL
81484: IFFALSE 81494
// btype := b_factory ;
81486: LD_ADDR_VAR 0 5
81490: PUSH
81491: LD_INT 3
81493: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81494: LD_ADDR_VAR 0 4
81498: PUSH
81499: LD_VAR 0 5
81503: PPUSH
81504: LD_VAR 0 1
81508: PPUSH
81509: CALL_OW 248
81513: PPUSH
81514: CALL_OW 450
81518: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81519: LD_ADDR_VAR 0 2
81523: PUSH
81524: LD_VAR 0 3
81528: PPUSH
81529: LD_INT 1
81531: PPUSH
81532: CALL_OW 275
81536: PUSH
81537: LD_VAR 0 4
81541: PUSH
81542: LD_INT 1
81544: ARRAY
81545: GREATEREQUAL
81546: PUSH
81547: LD_VAR 0 3
81551: PPUSH
81552: LD_INT 2
81554: PPUSH
81555: CALL_OW 275
81559: PUSH
81560: LD_VAR 0 4
81564: PUSH
81565: LD_INT 2
81567: ARRAY
81568: GREATEREQUAL
81569: AND
81570: PUSH
81571: LD_VAR 0 3
81575: PPUSH
81576: LD_INT 3
81578: PPUSH
81579: CALL_OW 275
81583: PUSH
81584: LD_VAR 0 4
81588: PUSH
81589: LD_INT 3
81591: ARRAY
81592: GREATEREQUAL
81593: AND
81594: ST_TO_ADDR
// end ;
81595: LD_VAR 0 2
81599: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
81600: LD_INT 0
81602: PPUSH
81603: PPUSH
81604: PPUSH
// pom := GetBase ( building ) ;
81605: LD_ADDR_VAR 0 4
81609: PUSH
81610: LD_VAR 0 1
81614: PPUSH
81615: CALL_OW 274
81619: ST_TO_ADDR
// if not pom then
81620: LD_VAR 0 4
81624: NOT
81625: IFFALSE 81629
// exit ;
81627: GO 81730
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
81629: LD_ADDR_VAR 0 5
81633: PUSH
81634: LD_VAR 0 2
81638: PPUSH
81639: LD_VAR 0 1
81643: PPUSH
81644: CALL_OW 248
81648: PPUSH
81649: CALL_OW 450
81653: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
81654: LD_ADDR_VAR 0 3
81658: PUSH
81659: LD_VAR 0 4
81663: PPUSH
81664: LD_INT 1
81666: PPUSH
81667: CALL_OW 275
81671: PUSH
81672: LD_VAR 0 5
81676: PUSH
81677: LD_INT 1
81679: ARRAY
81680: GREATEREQUAL
81681: PUSH
81682: LD_VAR 0 4
81686: PPUSH
81687: LD_INT 2
81689: PPUSH
81690: CALL_OW 275
81694: PUSH
81695: LD_VAR 0 5
81699: PUSH
81700: LD_INT 2
81702: ARRAY
81703: GREATEREQUAL
81704: AND
81705: PUSH
81706: LD_VAR 0 4
81710: PPUSH
81711: LD_INT 3
81713: PPUSH
81714: CALL_OW 275
81718: PUSH
81719: LD_VAR 0 5
81723: PUSH
81724: LD_INT 3
81726: ARRAY
81727: GREATEREQUAL
81728: AND
81729: ST_TO_ADDR
// end ;
81730: LD_VAR 0 3
81734: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
81735: LD_INT 0
81737: PPUSH
81738: PPUSH
81739: PPUSH
81740: PPUSH
81741: PPUSH
81742: PPUSH
81743: PPUSH
81744: PPUSH
81745: PPUSH
81746: PPUSH
81747: PPUSH
// result := false ;
81748: LD_ADDR_VAR 0 8
81752: PUSH
81753: LD_INT 0
81755: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
81756: LD_VAR 0 5
81760: NOT
81761: PUSH
81762: LD_VAR 0 1
81766: NOT
81767: OR
81768: PUSH
81769: LD_VAR 0 2
81773: NOT
81774: OR
81775: PUSH
81776: LD_VAR 0 3
81780: NOT
81781: OR
81782: IFFALSE 81786
// exit ;
81784: GO 82600
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
81786: LD_ADDR_VAR 0 14
81790: PUSH
81791: LD_VAR 0 1
81795: PPUSH
81796: LD_VAR 0 2
81800: PPUSH
81801: LD_VAR 0 3
81805: PPUSH
81806: LD_VAR 0 4
81810: PPUSH
81811: LD_VAR 0 5
81815: PUSH
81816: LD_INT 1
81818: ARRAY
81819: PPUSH
81820: CALL_OW 248
81824: PPUSH
81825: LD_INT 0
81827: PPUSH
81828: CALL 83853 0 6
81832: ST_TO_ADDR
// if not hexes then
81833: LD_VAR 0 14
81837: NOT
81838: IFFALSE 81842
// exit ;
81840: GO 82600
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
81842: LD_ADDR_VAR 0 17
81846: PUSH
81847: LD_VAR 0 5
81851: PPUSH
81852: LD_INT 22
81854: PUSH
81855: LD_VAR 0 13
81859: PPUSH
81860: CALL_OW 255
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: LD_INT 30
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 30
81884: PUSH
81885: LD_INT 1
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: LIST
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PPUSH
81901: CALL_OW 72
81905: ST_TO_ADDR
// for i = 1 to hexes do
81906: LD_ADDR_VAR 0 9
81910: PUSH
81911: DOUBLE
81912: LD_INT 1
81914: DEC
81915: ST_TO_ADDR
81916: LD_VAR 0 14
81920: PUSH
81921: FOR_TO
81922: IFFALSE 82598
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81924: LD_ADDR_VAR 0 13
81928: PUSH
81929: LD_VAR 0 14
81933: PUSH
81934: LD_VAR 0 9
81938: ARRAY
81939: PUSH
81940: LD_INT 1
81942: ARRAY
81943: PPUSH
81944: LD_VAR 0 14
81948: PUSH
81949: LD_VAR 0 9
81953: ARRAY
81954: PUSH
81955: LD_INT 2
81957: ARRAY
81958: PPUSH
81959: CALL_OW 428
81963: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
81964: LD_VAR 0 14
81968: PUSH
81969: LD_VAR 0 9
81973: ARRAY
81974: PUSH
81975: LD_INT 1
81977: ARRAY
81978: PPUSH
81979: LD_VAR 0 14
81983: PUSH
81984: LD_VAR 0 9
81988: ARRAY
81989: PUSH
81990: LD_INT 2
81992: ARRAY
81993: PPUSH
81994: CALL_OW 351
81998: PUSH
81999: LD_VAR 0 14
82003: PUSH
82004: LD_VAR 0 9
82008: ARRAY
82009: PUSH
82010: LD_INT 1
82012: ARRAY
82013: PPUSH
82014: LD_VAR 0 14
82018: PUSH
82019: LD_VAR 0 9
82023: ARRAY
82024: PUSH
82025: LD_INT 2
82027: ARRAY
82028: PPUSH
82029: CALL_OW 488
82033: NOT
82034: OR
82035: PUSH
82036: LD_VAR 0 13
82040: PPUSH
82041: CALL_OW 247
82045: PUSH
82046: LD_INT 3
82048: EQUAL
82049: OR
82050: IFFALSE 82056
// exit ;
82052: POP
82053: POP
82054: GO 82600
// if not tmp then
82056: LD_VAR 0 13
82060: NOT
82061: IFFALSE 82065
// continue ;
82063: GO 81921
// result := true ;
82065: LD_ADDR_VAR 0 8
82069: PUSH
82070: LD_INT 1
82072: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
82073: LD_VAR 0 6
82077: PUSH
82078: LD_VAR 0 13
82082: PPUSH
82083: CALL_OW 247
82087: PUSH
82088: LD_INT 2
82090: EQUAL
82091: AND
82092: PUSH
82093: LD_VAR 0 13
82097: PPUSH
82098: CALL_OW 263
82102: PUSH
82103: LD_INT 1
82105: EQUAL
82106: AND
82107: IFFALSE 82271
// begin if IsDrivenBy ( tmp ) then
82109: LD_VAR 0 13
82113: PPUSH
82114: CALL_OW 311
82118: IFFALSE 82122
// continue ;
82120: GO 81921
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
82122: LD_VAR 0 6
82126: PPUSH
82127: LD_INT 3
82129: PUSH
82130: LD_INT 60
82132: PUSH
82133: EMPTY
82134: LIST
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 3
82142: PUSH
82143: LD_INT 55
82145: PUSH
82146: EMPTY
82147: LIST
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PPUSH
82157: CALL_OW 72
82161: IFFALSE 82269
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
82163: LD_ADDR_VAR 0 18
82167: PUSH
82168: LD_VAR 0 6
82172: PPUSH
82173: LD_INT 3
82175: PUSH
82176: LD_INT 60
82178: PUSH
82179: EMPTY
82180: LIST
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 3
82188: PUSH
82189: LD_INT 55
82191: PUSH
82192: EMPTY
82193: LIST
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PPUSH
82203: CALL_OW 72
82207: PUSH
82208: LD_INT 1
82210: ARRAY
82211: ST_TO_ADDR
// if IsInUnit ( driver ) then
82212: LD_VAR 0 18
82216: PPUSH
82217: CALL_OW 310
82221: IFFALSE 82232
// ComExit ( driver ) ;
82223: LD_VAR 0 18
82227: PPUSH
82228: CALL 107634 0 1
// AddComEnterUnit ( driver , tmp ) ;
82232: LD_VAR 0 18
82236: PPUSH
82237: LD_VAR 0 13
82241: PPUSH
82242: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
82246: LD_VAR 0 18
82250: PPUSH
82251: LD_VAR 0 7
82255: PPUSH
82256: CALL_OW 173
// AddComExitVehicle ( driver ) ;
82260: LD_VAR 0 18
82264: PPUSH
82265: CALL_OW 181
// end ; continue ;
82269: GO 81921
// end ; if not cleaners or not tmp in cleaners then
82271: LD_VAR 0 6
82275: NOT
82276: PUSH
82277: LD_VAR 0 13
82281: PUSH
82282: LD_VAR 0 6
82286: IN
82287: NOT
82288: OR
82289: IFFALSE 82596
// begin if dep then
82291: LD_VAR 0 17
82295: IFFALSE 82431
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
82297: LD_ADDR_VAR 0 16
82301: PUSH
82302: LD_VAR 0 17
82306: PUSH
82307: LD_INT 1
82309: ARRAY
82310: PPUSH
82311: CALL_OW 250
82315: PPUSH
82316: LD_VAR 0 17
82320: PUSH
82321: LD_INT 1
82323: ARRAY
82324: PPUSH
82325: CALL_OW 254
82329: PPUSH
82330: LD_INT 5
82332: PPUSH
82333: CALL_OW 272
82337: PUSH
82338: LD_VAR 0 17
82342: PUSH
82343: LD_INT 1
82345: ARRAY
82346: PPUSH
82347: CALL_OW 251
82351: PPUSH
82352: LD_VAR 0 17
82356: PUSH
82357: LD_INT 1
82359: ARRAY
82360: PPUSH
82361: CALL_OW 254
82365: PPUSH
82366: LD_INT 5
82368: PPUSH
82369: CALL_OW 273
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
82378: LD_VAR 0 16
82382: PUSH
82383: LD_INT 1
82385: ARRAY
82386: PPUSH
82387: LD_VAR 0 16
82391: PUSH
82392: LD_INT 2
82394: ARRAY
82395: PPUSH
82396: CALL_OW 488
82400: IFFALSE 82431
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
82402: LD_VAR 0 13
82406: PPUSH
82407: LD_VAR 0 16
82411: PUSH
82412: LD_INT 1
82414: ARRAY
82415: PPUSH
82416: LD_VAR 0 16
82420: PUSH
82421: LD_INT 2
82423: ARRAY
82424: PPUSH
82425: CALL_OW 111
// continue ;
82429: GO 81921
// end ; end ; r := GetDir ( tmp ) ;
82431: LD_ADDR_VAR 0 15
82435: PUSH
82436: LD_VAR 0 13
82440: PPUSH
82441: CALL_OW 254
82445: ST_TO_ADDR
// if r = 5 then
82446: LD_VAR 0 15
82450: PUSH
82451: LD_INT 5
82453: EQUAL
82454: IFFALSE 82464
// r := 0 ;
82456: LD_ADDR_VAR 0 15
82460: PUSH
82461: LD_INT 0
82463: ST_TO_ADDR
// for j = r to 5 do
82464: LD_ADDR_VAR 0 10
82468: PUSH
82469: DOUBLE
82470: LD_VAR 0 15
82474: DEC
82475: ST_TO_ADDR
82476: LD_INT 5
82478: PUSH
82479: FOR_TO
82480: IFFALSE 82594
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
82482: LD_ADDR_VAR 0 11
82486: PUSH
82487: LD_VAR 0 13
82491: PPUSH
82492: CALL_OW 250
82496: PPUSH
82497: LD_VAR 0 10
82501: PPUSH
82502: LD_INT 2
82504: PPUSH
82505: CALL_OW 272
82509: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
82510: LD_ADDR_VAR 0 12
82514: PUSH
82515: LD_VAR 0 13
82519: PPUSH
82520: CALL_OW 251
82524: PPUSH
82525: LD_VAR 0 10
82529: PPUSH
82530: LD_INT 2
82532: PPUSH
82533: CALL_OW 273
82537: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
82538: LD_VAR 0 11
82542: PPUSH
82543: LD_VAR 0 12
82547: PPUSH
82548: CALL_OW 488
82552: PUSH
82553: LD_VAR 0 11
82557: PPUSH
82558: LD_VAR 0 12
82562: PPUSH
82563: CALL_OW 428
82567: NOT
82568: AND
82569: IFFALSE 82592
// begin ComMoveXY ( tmp , _x , _y ) ;
82571: LD_VAR 0 13
82575: PPUSH
82576: LD_VAR 0 11
82580: PPUSH
82581: LD_VAR 0 12
82585: PPUSH
82586: CALL_OW 111
// break ;
82590: GO 82594
// end ; end ;
82592: GO 82479
82594: POP
82595: POP
// end ; end ;
82596: GO 81921
82598: POP
82599: POP
// end ;
82600: LD_VAR 0 8
82604: RET
// export function BuildingTechInvented ( side , btype ) ; begin
82605: LD_INT 0
82607: PPUSH
// result := true ;
82608: LD_ADDR_VAR 0 3
82612: PUSH
82613: LD_INT 1
82615: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
82616: LD_VAR 0 2
82620: PUSH
82621: LD_INT 24
82623: DOUBLE
82624: EQUAL
82625: IFTRUE 82635
82627: LD_INT 33
82629: DOUBLE
82630: EQUAL
82631: IFTRUE 82635
82633: GO 82660
82635: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
82636: LD_ADDR_VAR 0 3
82640: PUSH
82641: LD_INT 32
82643: PPUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: CALL_OW 321
82653: PUSH
82654: LD_INT 2
82656: EQUAL
82657: ST_TO_ADDR
82658: GO 82976
82660: LD_INT 20
82662: DOUBLE
82663: EQUAL
82664: IFTRUE 82668
82666: GO 82693
82668: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
82669: LD_ADDR_VAR 0 3
82673: PUSH
82674: LD_INT 6
82676: PPUSH
82677: LD_VAR 0 1
82681: PPUSH
82682: CALL_OW 321
82686: PUSH
82687: LD_INT 2
82689: EQUAL
82690: ST_TO_ADDR
82691: GO 82976
82693: LD_INT 22
82695: DOUBLE
82696: EQUAL
82697: IFTRUE 82707
82699: LD_INT 36
82701: DOUBLE
82702: EQUAL
82703: IFTRUE 82707
82705: GO 82732
82707: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
82708: LD_ADDR_VAR 0 3
82712: PUSH
82713: LD_INT 15
82715: PPUSH
82716: LD_VAR 0 1
82720: PPUSH
82721: CALL_OW 321
82725: PUSH
82726: LD_INT 2
82728: EQUAL
82729: ST_TO_ADDR
82730: GO 82976
82732: LD_INT 30
82734: DOUBLE
82735: EQUAL
82736: IFTRUE 82740
82738: GO 82765
82740: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
82741: LD_ADDR_VAR 0 3
82745: PUSH
82746: LD_INT 20
82748: PPUSH
82749: LD_VAR 0 1
82753: PPUSH
82754: CALL_OW 321
82758: PUSH
82759: LD_INT 2
82761: EQUAL
82762: ST_TO_ADDR
82763: GO 82976
82765: LD_INT 28
82767: DOUBLE
82768: EQUAL
82769: IFTRUE 82779
82771: LD_INT 21
82773: DOUBLE
82774: EQUAL
82775: IFTRUE 82779
82777: GO 82804
82779: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
82780: LD_ADDR_VAR 0 3
82784: PUSH
82785: LD_INT 21
82787: PPUSH
82788: LD_VAR 0 1
82792: PPUSH
82793: CALL_OW 321
82797: PUSH
82798: LD_INT 2
82800: EQUAL
82801: ST_TO_ADDR
82802: GO 82976
82804: LD_INT 16
82806: DOUBLE
82807: EQUAL
82808: IFTRUE 82812
82810: GO 82837
82812: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
82813: LD_ADDR_VAR 0 3
82817: PUSH
82818: LD_INT 84
82820: PPUSH
82821: LD_VAR 0 1
82825: PPUSH
82826: CALL_OW 321
82830: PUSH
82831: LD_INT 2
82833: EQUAL
82834: ST_TO_ADDR
82835: GO 82976
82837: LD_INT 19
82839: DOUBLE
82840: EQUAL
82841: IFTRUE 82851
82843: LD_INT 23
82845: DOUBLE
82846: EQUAL
82847: IFTRUE 82851
82849: GO 82876
82851: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
82852: LD_ADDR_VAR 0 3
82856: PUSH
82857: LD_INT 83
82859: PPUSH
82860: LD_VAR 0 1
82864: PPUSH
82865: CALL_OW 321
82869: PUSH
82870: LD_INT 2
82872: EQUAL
82873: ST_TO_ADDR
82874: GO 82976
82876: LD_INT 17
82878: DOUBLE
82879: EQUAL
82880: IFTRUE 82884
82882: GO 82909
82884: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
82885: LD_ADDR_VAR 0 3
82889: PUSH
82890: LD_INT 39
82892: PPUSH
82893: LD_VAR 0 1
82897: PPUSH
82898: CALL_OW 321
82902: PUSH
82903: LD_INT 2
82905: EQUAL
82906: ST_TO_ADDR
82907: GO 82976
82909: LD_INT 18
82911: DOUBLE
82912: EQUAL
82913: IFTRUE 82917
82915: GO 82942
82917: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
82918: LD_ADDR_VAR 0 3
82922: PUSH
82923: LD_INT 40
82925: PPUSH
82926: LD_VAR 0 1
82930: PPUSH
82931: CALL_OW 321
82935: PUSH
82936: LD_INT 2
82938: EQUAL
82939: ST_TO_ADDR
82940: GO 82976
82942: LD_INT 27
82944: DOUBLE
82945: EQUAL
82946: IFTRUE 82950
82948: GO 82975
82950: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
82951: LD_ADDR_VAR 0 3
82955: PUSH
82956: LD_INT 35
82958: PPUSH
82959: LD_VAR 0 1
82963: PPUSH
82964: CALL_OW 321
82968: PUSH
82969: LD_INT 2
82971: EQUAL
82972: ST_TO_ADDR
82973: GO 82976
82975: POP
// end ;
82976: LD_VAR 0 3
82980: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
82981: LD_INT 0
82983: PPUSH
82984: PPUSH
82985: PPUSH
82986: PPUSH
82987: PPUSH
82988: PPUSH
82989: PPUSH
82990: PPUSH
82991: PPUSH
82992: PPUSH
82993: PPUSH
// result := false ;
82994: LD_ADDR_VAR 0 6
82998: PUSH
82999: LD_INT 0
83001: ST_TO_ADDR
// if btype = b_depot then
83002: LD_VAR 0 2
83006: PUSH
83007: LD_INT 0
83009: EQUAL
83010: IFFALSE 83022
// begin result := true ;
83012: LD_ADDR_VAR 0 6
83016: PUSH
83017: LD_INT 1
83019: ST_TO_ADDR
// exit ;
83020: GO 83848
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
83022: LD_VAR 0 1
83026: NOT
83027: PUSH
83028: LD_VAR 0 1
83032: PPUSH
83033: CALL_OW 266
83037: PUSH
83038: LD_INT 0
83040: PUSH
83041: LD_INT 1
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: IN
83048: NOT
83049: OR
83050: PUSH
83051: LD_VAR 0 2
83055: NOT
83056: OR
83057: PUSH
83058: LD_VAR 0 5
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: LD_INT 1
83068: PUSH
83069: LD_INT 2
83071: PUSH
83072: LD_INT 3
83074: PUSH
83075: LD_INT 4
83077: PUSH
83078: LD_INT 5
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: IN
83089: NOT
83090: OR
83091: PUSH
83092: LD_VAR 0 3
83096: PPUSH
83097: LD_VAR 0 4
83101: PPUSH
83102: CALL_OW 488
83106: NOT
83107: OR
83108: IFFALSE 83112
// exit ;
83110: GO 83848
// side := GetSide ( depot ) ;
83112: LD_ADDR_VAR 0 9
83116: PUSH
83117: LD_VAR 0 1
83121: PPUSH
83122: CALL_OW 255
83126: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
83127: LD_VAR 0 9
83131: PPUSH
83132: LD_VAR 0 2
83136: PPUSH
83137: CALL 82605 0 2
83141: NOT
83142: IFFALSE 83146
// exit ;
83144: GO 83848
// pom := GetBase ( depot ) ;
83146: LD_ADDR_VAR 0 10
83150: PUSH
83151: LD_VAR 0 1
83155: PPUSH
83156: CALL_OW 274
83160: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
83161: LD_ADDR_VAR 0 11
83165: PUSH
83166: LD_VAR 0 2
83170: PPUSH
83171: LD_VAR 0 1
83175: PPUSH
83176: CALL_OW 248
83180: PPUSH
83181: CALL_OW 450
83185: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
83186: LD_VAR 0 10
83190: PPUSH
83191: LD_INT 1
83193: PPUSH
83194: CALL_OW 275
83198: PUSH
83199: LD_VAR 0 11
83203: PUSH
83204: LD_INT 1
83206: ARRAY
83207: GREATEREQUAL
83208: PUSH
83209: LD_VAR 0 10
83213: PPUSH
83214: LD_INT 2
83216: PPUSH
83217: CALL_OW 275
83221: PUSH
83222: LD_VAR 0 11
83226: PUSH
83227: LD_INT 2
83229: ARRAY
83230: GREATEREQUAL
83231: AND
83232: PUSH
83233: LD_VAR 0 10
83237: PPUSH
83238: LD_INT 3
83240: PPUSH
83241: CALL_OW 275
83245: PUSH
83246: LD_VAR 0 11
83250: PUSH
83251: LD_INT 3
83253: ARRAY
83254: GREATEREQUAL
83255: AND
83256: NOT
83257: IFFALSE 83261
// exit ;
83259: GO 83848
// if GetBType ( depot ) = b_depot then
83261: LD_VAR 0 1
83265: PPUSH
83266: CALL_OW 266
83270: PUSH
83271: LD_INT 0
83273: EQUAL
83274: IFFALSE 83286
// dist := 28 else
83276: LD_ADDR_VAR 0 14
83280: PUSH
83281: LD_INT 28
83283: ST_TO_ADDR
83284: GO 83294
// dist := 36 ;
83286: LD_ADDR_VAR 0 14
83290: PUSH
83291: LD_INT 36
83293: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
83294: LD_VAR 0 1
83298: PPUSH
83299: LD_VAR 0 3
83303: PPUSH
83304: LD_VAR 0 4
83308: PPUSH
83309: CALL_OW 297
83313: PUSH
83314: LD_VAR 0 14
83318: GREATER
83319: IFFALSE 83323
// exit ;
83321: GO 83848
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
83323: LD_ADDR_VAR 0 12
83327: PUSH
83328: LD_VAR 0 2
83332: PPUSH
83333: LD_VAR 0 3
83337: PPUSH
83338: LD_VAR 0 4
83342: PPUSH
83343: LD_VAR 0 5
83347: PPUSH
83348: LD_VAR 0 1
83352: PPUSH
83353: CALL_OW 248
83357: PPUSH
83358: LD_INT 0
83360: PPUSH
83361: CALL 83853 0 6
83365: ST_TO_ADDR
// if not hexes then
83366: LD_VAR 0 12
83370: NOT
83371: IFFALSE 83375
// exit ;
83373: GO 83848
// hex := GetHexInfo ( x , y ) ;
83375: LD_ADDR_VAR 0 15
83379: PUSH
83380: LD_VAR 0 3
83384: PPUSH
83385: LD_VAR 0 4
83389: PPUSH
83390: CALL_OW 546
83394: ST_TO_ADDR
// if hex [ 1 ] then
83395: LD_VAR 0 15
83399: PUSH
83400: LD_INT 1
83402: ARRAY
83403: IFFALSE 83407
// exit ;
83405: GO 83848
// height := hex [ 2 ] ;
83407: LD_ADDR_VAR 0 13
83411: PUSH
83412: LD_VAR 0 15
83416: PUSH
83417: LD_INT 2
83419: ARRAY
83420: ST_TO_ADDR
// for i = 1 to hexes do
83421: LD_ADDR_VAR 0 7
83425: PUSH
83426: DOUBLE
83427: LD_INT 1
83429: DEC
83430: ST_TO_ADDR
83431: LD_VAR 0 12
83435: PUSH
83436: FOR_TO
83437: IFFALSE 83767
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
83439: LD_VAR 0 12
83443: PUSH
83444: LD_VAR 0 7
83448: ARRAY
83449: PUSH
83450: LD_INT 1
83452: ARRAY
83453: PPUSH
83454: LD_VAR 0 12
83458: PUSH
83459: LD_VAR 0 7
83463: ARRAY
83464: PUSH
83465: LD_INT 2
83467: ARRAY
83468: PPUSH
83469: CALL_OW 488
83473: NOT
83474: PUSH
83475: LD_VAR 0 12
83479: PUSH
83480: LD_VAR 0 7
83484: ARRAY
83485: PUSH
83486: LD_INT 1
83488: ARRAY
83489: PPUSH
83490: LD_VAR 0 12
83494: PUSH
83495: LD_VAR 0 7
83499: ARRAY
83500: PUSH
83501: LD_INT 2
83503: ARRAY
83504: PPUSH
83505: CALL_OW 428
83509: PUSH
83510: LD_INT 0
83512: GREATER
83513: OR
83514: PUSH
83515: LD_VAR 0 12
83519: PUSH
83520: LD_VAR 0 7
83524: ARRAY
83525: PUSH
83526: LD_INT 1
83528: ARRAY
83529: PPUSH
83530: LD_VAR 0 12
83534: PUSH
83535: LD_VAR 0 7
83539: ARRAY
83540: PUSH
83541: LD_INT 2
83543: ARRAY
83544: PPUSH
83545: CALL_OW 351
83549: OR
83550: IFFALSE 83556
// exit ;
83552: POP
83553: POP
83554: GO 83848
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83556: LD_ADDR_VAR 0 8
83560: PUSH
83561: LD_VAR 0 12
83565: PUSH
83566: LD_VAR 0 7
83570: ARRAY
83571: PUSH
83572: LD_INT 1
83574: ARRAY
83575: PPUSH
83576: LD_VAR 0 12
83580: PUSH
83581: LD_VAR 0 7
83585: ARRAY
83586: PUSH
83587: LD_INT 2
83589: ARRAY
83590: PPUSH
83591: CALL_OW 546
83595: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
83596: LD_VAR 0 8
83600: PUSH
83601: LD_INT 1
83603: ARRAY
83604: PUSH
83605: LD_VAR 0 8
83609: PUSH
83610: LD_INT 2
83612: ARRAY
83613: PUSH
83614: LD_VAR 0 13
83618: PUSH
83619: LD_INT 2
83621: PLUS
83622: GREATER
83623: OR
83624: PUSH
83625: LD_VAR 0 8
83629: PUSH
83630: LD_INT 2
83632: ARRAY
83633: PUSH
83634: LD_VAR 0 13
83638: PUSH
83639: LD_INT 2
83641: MINUS
83642: LESS
83643: OR
83644: PUSH
83645: LD_VAR 0 8
83649: PUSH
83650: LD_INT 3
83652: ARRAY
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: LD_INT 8
83659: PUSH
83660: LD_INT 9
83662: PUSH
83663: LD_INT 10
83665: PUSH
83666: LD_INT 11
83668: PUSH
83669: LD_INT 12
83671: PUSH
83672: LD_INT 13
83674: PUSH
83675: LD_INT 16
83677: PUSH
83678: LD_INT 17
83680: PUSH
83681: LD_INT 18
83683: PUSH
83684: LD_INT 19
83686: PUSH
83687: LD_INT 20
83689: PUSH
83690: LD_INT 21
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: IN
83708: NOT
83709: OR
83710: PUSH
83711: LD_VAR 0 8
83715: PUSH
83716: LD_INT 5
83718: ARRAY
83719: NOT
83720: OR
83721: PUSH
83722: LD_VAR 0 8
83726: PUSH
83727: LD_INT 6
83729: ARRAY
83730: PUSH
83731: LD_INT 1
83733: PUSH
83734: LD_INT 2
83736: PUSH
83737: LD_INT 7
83739: PUSH
83740: LD_INT 9
83742: PUSH
83743: LD_INT 10
83745: PUSH
83746: LD_INT 11
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: LIST
83756: IN
83757: NOT
83758: OR
83759: IFFALSE 83765
// exit ;
83761: POP
83762: POP
83763: GO 83848
// end ;
83765: GO 83436
83767: POP
83768: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
83769: LD_VAR 0 9
83773: PPUSH
83774: LD_VAR 0 3
83778: PPUSH
83779: LD_VAR 0 4
83783: PPUSH
83784: LD_INT 20
83786: PPUSH
83787: CALL 75771 0 4
83791: PUSH
83792: LD_INT 4
83794: ARRAY
83795: IFFALSE 83799
// exit ;
83797: GO 83848
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
83799: LD_VAR 0 2
83803: PUSH
83804: LD_INT 29
83806: PUSH
83807: LD_INT 30
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: IN
83814: PUSH
83815: LD_VAR 0 3
83819: PPUSH
83820: LD_VAR 0 4
83824: PPUSH
83825: LD_VAR 0 9
83829: PPUSH
83830: CALL_OW 440
83834: NOT
83835: AND
83836: IFFALSE 83840
// exit ;
83838: GO 83848
// result := true ;
83840: LD_ADDR_VAR 0 6
83844: PUSH
83845: LD_INT 1
83847: ST_TO_ADDR
// end ;
83848: LD_VAR 0 6
83852: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
83853: LD_INT 0
83855: PPUSH
83856: PPUSH
83857: PPUSH
83858: PPUSH
83859: PPUSH
83860: PPUSH
83861: PPUSH
83862: PPUSH
83863: PPUSH
83864: PPUSH
83865: PPUSH
83866: PPUSH
83867: PPUSH
83868: PPUSH
83869: PPUSH
83870: PPUSH
83871: PPUSH
83872: PPUSH
83873: PPUSH
83874: PPUSH
83875: PPUSH
83876: PPUSH
83877: PPUSH
83878: PPUSH
83879: PPUSH
83880: PPUSH
83881: PPUSH
83882: PPUSH
83883: PPUSH
83884: PPUSH
83885: PPUSH
83886: PPUSH
83887: PPUSH
83888: PPUSH
83889: PPUSH
83890: PPUSH
83891: PPUSH
83892: PPUSH
83893: PPUSH
83894: PPUSH
83895: PPUSH
83896: PPUSH
83897: PPUSH
83898: PPUSH
83899: PPUSH
83900: PPUSH
83901: PPUSH
83902: PPUSH
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
83907: PPUSH
83908: PPUSH
83909: PPUSH
83910: PPUSH
83911: PPUSH
83912: PPUSH
// result = [ ] ;
83913: LD_ADDR_VAR 0 7
83917: PUSH
83918: EMPTY
83919: ST_TO_ADDR
// temp_list = [ ] ;
83920: LD_ADDR_VAR 0 9
83924: PUSH
83925: EMPTY
83926: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
83927: LD_VAR 0 4
83931: PUSH
83932: LD_INT 0
83934: PUSH
83935: LD_INT 1
83937: PUSH
83938: LD_INT 2
83940: PUSH
83941: LD_INT 3
83943: PUSH
83944: LD_INT 4
83946: PUSH
83947: LD_INT 5
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: IN
83958: NOT
83959: PUSH
83960: LD_VAR 0 1
83964: PUSH
83965: LD_INT 0
83967: PUSH
83968: LD_INT 1
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: IN
83975: PUSH
83976: LD_VAR 0 5
83980: PUSH
83981: LD_INT 1
83983: PUSH
83984: LD_INT 2
83986: PUSH
83987: LD_INT 3
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: LIST
83994: IN
83995: NOT
83996: AND
83997: OR
83998: IFFALSE 84002
// exit ;
84000: GO 102393
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
84002: LD_VAR 0 1
84006: PUSH
84007: LD_INT 6
84009: PUSH
84010: LD_INT 7
84012: PUSH
84013: LD_INT 8
84015: PUSH
84016: LD_INT 13
84018: PUSH
84019: LD_INT 12
84021: PUSH
84022: LD_INT 15
84024: PUSH
84025: LD_INT 11
84027: PUSH
84028: LD_INT 14
84030: PUSH
84031: LD_INT 10
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: LIST
84041: LIST
84042: LIST
84043: LIST
84044: IN
84045: IFFALSE 84055
// btype = b_lab ;
84047: LD_ADDR_VAR 0 1
84051: PUSH
84052: LD_INT 6
84054: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
84055: LD_VAR 0 6
84059: PUSH
84060: LD_INT 0
84062: PUSH
84063: LD_INT 1
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: LIST
84073: IN
84074: NOT
84075: PUSH
84076: LD_VAR 0 1
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: LD_INT 1
84086: PUSH
84087: LD_INT 2
84089: PUSH
84090: LD_INT 3
84092: PUSH
84093: LD_INT 6
84095: PUSH
84096: LD_INT 36
84098: PUSH
84099: LD_INT 4
84101: PUSH
84102: LD_INT 5
84104: PUSH
84105: LD_INT 31
84107: PUSH
84108: LD_INT 32
84110: PUSH
84111: LD_INT 33
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: IN
84127: NOT
84128: PUSH
84129: LD_VAR 0 6
84133: PUSH
84134: LD_INT 1
84136: EQUAL
84137: AND
84138: OR
84139: PUSH
84140: LD_VAR 0 1
84144: PUSH
84145: LD_INT 2
84147: PUSH
84148: LD_INT 3
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: IN
84155: NOT
84156: PUSH
84157: LD_VAR 0 6
84161: PUSH
84162: LD_INT 2
84164: EQUAL
84165: AND
84166: OR
84167: IFFALSE 84177
// mode = 0 ;
84169: LD_ADDR_VAR 0 6
84173: PUSH
84174: LD_INT 0
84176: ST_TO_ADDR
// case mode of 0 :
84177: LD_VAR 0 6
84181: PUSH
84182: LD_INT 0
84184: DOUBLE
84185: EQUAL
84186: IFTRUE 84190
84188: GO 95643
84190: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
84191: LD_ADDR_VAR 0 11
84195: PUSH
84196: LD_INT 0
84198: PUSH
84199: LD_INT 0
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: LD_INT 0
84208: PUSH
84209: LD_INT 1
84211: NEG
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: PUSH
84217: LD_INT 1
84219: PUSH
84220: LD_INT 0
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 1
84229: PUSH
84230: LD_INT 1
84232: PUSH
84233: EMPTY
84234: LIST
84235: LIST
84236: PUSH
84237: LD_INT 0
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 1
84249: NEG
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 1
84260: NEG
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 1
84272: NEG
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: LD_INT 2
84287: NEG
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 1
84295: PUSH
84296: LD_INT 1
84298: NEG
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PUSH
84304: LD_INT 1
84306: PUSH
84307: LD_INT 2
84309: PUSH
84310: EMPTY
84311: LIST
84312: LIST
84313: PUSH
84314: LD_INT 0
84316: PUSH
84317: LD_INT 2
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 1
84337: PUSH
84338: LD_INT 3
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: LD_INT 3
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 1
84357: NEG
84358: PUSH
84359: LD_INT 2
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84384: LD_ADDR_VAR 0 12
84388: PUSH
84389: LD_INT 0
84391: PUSH
84392: LD_INT 0
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 0
84401: PUSH
84402: LD_INT 1
84404: NEG
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 1
84412: PUSH
84413: LD_INT 0
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 1
84422: PUSH
84423: LD_INT 1
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 0
84432: PUSH
84433: LD_INT 1
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 1
84442: NEG
84443: PUSH
84444: LD_INT 0
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 1
84453: NEG
84454: PUSH
84455: LD_INT 1
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 1
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 2
84476: PUSH
84477: LD_INT 0
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 2
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: LD_INT 1
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 2
84507: NEG
84508: PUSH
84509: LD_INT 0
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 2
84518: NEG
84519: PUSH
84520: LD_INT 1
84522: NEG
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 2
84530: NEG
84531: PUSH
84532: LD_INT 1
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 3
84541: NEG
84542: PUSH
84543: LD_INT 0
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 3
84552: NEG
84553: PUSH
84554: LD_INT 1
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: LIST
84572: LIST
84573: LIST
84574: LIST
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84580: LD_ADDR_VAR 0 13
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: LD_INT 0
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: LD_INT 1
84600: NEG
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 1
84608: PUSH
84609: LD_INT 0
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 1
84618: PUSH
84619: LD_INT 1
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 0
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 1
84638: NEG
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 1
84649: NEG
84650: PUSH
84651: LD_INT 1
84653: NEG
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 2
84665: NEG
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 2
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 2
84683: PUSH
84684: LD_INT 2
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: PUSH
84694: LD_INT 2
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 2
84703: NEG
84704: PUSH
84705: LD_INT 1
84707: NEG
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 2
84715: NEG
84716: PUSH
84717: LD_INT 2
84719: NEG
84720: PUSH
84721: EMPTY
84722: LIST
84723: LIST
84724: PUSH
84725: LD_INT 2
84727: NEG
84728: PUSH
84729: LD_INT 3
84731: NEG
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: PUSH
84737: LD_INT 3
84739: NEG
84740: PUSH
84741: LD_INT 2
84743: NEG
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 3
84751: NEG
84752: PUSH
84753: LD_INT 3
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
84779: LD_ADDR_VAR 0 14
84783: PUSH
84784: LD_INT 0
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 0
84796: PUSH
84797: LD_INT 1
84799: NEG
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 1
84807: PUSH
84808: LD_INT 0
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: PUSH
84815: LD_INT 1
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: LD_INT 1
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: NEG
84838: PUSH
84839: LD_INT 0
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 1
84848: NEG
84849: PUSH
84850: LD_INT 1
84852: NEG
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 1
84860: NEG
84861: PUSH
84862: LD_INT 2
84864: NEG
84865: PUSH
84866: EMPTY
84867: LIST
84868: LIST
84869: PUSH
84870: LD_INT 0
84872: PUSH
84873: LD_INT 2
84875: NEG
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 1
84883: PUSH
84884: LD_INT 1
84886: NEG
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: LD_INT 2
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 0
84904: PUSH
84905: LD_INT 2
84907: PUSH
84908: EMPTY
84909: LIST
84910: LIST
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: EMPTY
84920: LIST
84921: LIST
84922: PUSH
84923: LD_INT 1
84925: NEG
84926: PUSH
84927: LD_INT 3
84929: NEG
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: LD_INT 0
84937: PUSH
84938: LD_INT 3
84940: NEG
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: PUSH
84949: LD_INT 2
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
84975: LD_ADDR_VAR 0 15
84979: PUSH
84980: LD_INT 0
84982: PUSH
84983: LD_INT 0
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: LD_INT 1
84995: NEG
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: LD_INT 0
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 1
85013: PUSH
85014: LD_INT 1
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: LD_INT 1
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 1
85033: NEG
85034: PUSH
85035: LD_INT 0
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 1
85044: NEG
85045: PUSH
85046: LD_INT 1
85048: NEG
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PUSH
85054: LD_INT 1
85056: PUSH
85057: LD_INT 1
85059: NEG
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: LD_INT 2
85067: PUSH
85068: LD_INT 0
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 2
85077: PUSH
85078: LD_INT 1
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 1
85087: NEG
85088: PUSH
85089: LD_INT 1
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 2
85098: NEG
85099: PUSH
85100: LD_INT 0
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 2
85109: NEG
85110: PUSH
85111: LD_INT 1
85113: NEG
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 2
85121: PUSH
85122: LD_INT 1
85124: NEG
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 3
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 3
85142: PUSH
85143: LD_INT 1
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: LIST
85165: LIST
85166: LIST
85167: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85168: LD_ADDR_VAR 0 16
85172: PUSH
85173: LD_INT 0
85175: PUSH
85176: LD_INT 0
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 0
85185: PUSH
85186: LD_INT 1
85188: NEG
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 1
85196: PUSH
85197: LD_INT 0
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: PUSH
85207: LD_INT 1
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: LD_INT 1
85219: PUSH
85220: EMPTY
85221: LIST
85222: LIST
85223: PUSH
85224: LD_INT 1
85226: NEG
85227: PUSH
85228: LD_INT 0
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 1
85237: NEG
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 1
85249: NEG
85250: PUSH
85251: LD_INT 2
85253: NEG
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: LD_INT 2
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 2
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 2
85303: NEG
85304: PUSH
85305: LD_INT 2
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 3
85315: PUSH
85316: LD_INT 2
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PUSH
85323: LD_INT 3
85325: PUSH
85326: LD_INT 3
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: PUSH
85333: LD_INT 2
85335: PUSH
85336: LD_INT 3
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: EMPTY
85344: LIST
85345: LIST
85346: LIST
85347: LIST
85348: LIST
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85361: LD_ADDR_VAR 0 17
85365: PUSH
85366: LD_INT 0
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: EMPTY
85373: LIST
85374: LIST
85375: PUSH
85376: LD_INT 0
85378: PUSH
85379: LD_INT 1
85381: NEG
85382: PUSH
85383: EMPTY
85384: LIST
85385: LIST
85386: PUSH
85387: LD_INT 1
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 1
85399: PUSH
85400: LD_INT 1
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 0
85409: PUSH
85410: LD_INT 1
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 1
85419: NEG
85420: PUSH
85421: LD_INT 0
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 1
85430: NEG
85431: PUSH
85432: LD_INT 1
85434: NEG
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 1
85442: NEG
85443: PUSH
85444: LD_INT 2
85446: NEG
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 0
85454: PUSH
85455: LD_INT 2
85457: NEG
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 1
85465: PUSH
85466: LD_INT 1
85468: NEG
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: LD_INT 2
85476: PUSH
85477: LD_INT 0
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 2
85486: PUSH
85487: LD_INT 1
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 2
85496: PUSH
85497: LD_INT 2
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 1
85506: PUSH
85507: LD_INT 2
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 0
85516: PUSH
85517: LD_INT 2
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: LD_INT 1
85526: NEG
85527: PUSH
85528: LD_INT 1
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 2
85537: NEG
85538: PUSH
85539: LD_INT 0
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 2
85548: NEG
85549: PUSH
85550: LD_INT 1
85552: NEG
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 2
85560: NEG
85561: PUSH
85562: LD_INT 2
85564: NEG
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85591: LD_ADDR_VAR 0 18
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: LD_INT 0
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 0
85608: PUSH
85609: LD_INT 1
85611: NEG
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 0
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 1
85629: PUSH
85630: LD_INT 1
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 0
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 1
85649: NEG
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 1
85660: NEG
85661: PUSH
85662: LD_INT 1
85664: NEG
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 1
85672: NEG
85673: PUSH
85674: LD_INT 2
85676: NEG
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 0
85684: PUSH
85685: LD_INT 2
85687: NEG
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: LD_INT 1
85698: NEG
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: PUSH
85704: LD_INT 2
85706: PUSH
85707: LD_INT 0
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 2
85716: PUSH
85717: LD_INT 1
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 2
85726: PUSH
85727: LD_INT 2
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: PUSH
85734: LD_INT 1
85736: PUSH
85737: LD_INT 2
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PUSH
85744: LD_INT 0
85746: PUSH
85747: LD_INT 2
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: LD_INT 1
85756: NEG
85757: PUSH
85758: LD_INT 1
85760: PUSH
85761: EMPTY
85762: LIST
85763: LIST
85764: PUSH
85765: LD_INT 2
85767: NEG
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 2
85778: NEG
85779: PUSH
85780: LD_INT 1
85782: NEG
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 2
85790: NEG
85791: PUSH
85792: LD_INT 2
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85821: LD_ADDR_VAR 0 19
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: LD_INT 0
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 0
85838: PUSH
85839: LD_INT 1
85841: NEG
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 1
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: EMPTY
85854: LIST
85855: LIST
85856: PUSH
85857: LD_INT 1
85859: PUSH
85860: LD_INT 1
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 0
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: NEG
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 1
85890: NEG
85891: PUSH
85892: LD_INT 1
85894: NEG
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: NEG
85903: PUSH
85904: LD_INT 2
85906: NEG
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 2
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 2
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: PUSH
85957: LD_INT 2
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: PUSH
85967: LD_INT 2
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 0
85976: PUSH
85977: LD_INT 2
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 1
85986: NEG
85987: PUSH
85988: LD_INT 1
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PUSH
85995: LD_INT 2
85997: NEG
85998: PUSH
85999: LD_INT 0
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 2
86008: NEG
86009: PUSH
86010: LD_INT 1
86012: NEG
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 2
86020: NEG
86021: PUSH
86022: LD_INT 2
86024: NEG
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86051: LD_ADDR_VAR 0 20
86055: PUSH
86056: LD_INT 0
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 0
86068: PUSH
86069: LD_INT 1
86071: NEG
86072: PUSH
86073: EMPTY
86074: LIST
86075: LIST
86076: PUSH
86077: LD_INT 1
86079: PUSH
86080: LD_INT 0
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 1
86089: PUSH
86090: LD_INT 1
86092: PUSH
86093: EMPTY
86094: LIST
86095: LIST
86096: PUSH
86097: LD_INT 0
86099: PUSH
86100: LD_INT 1
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 1
86109: NEG
86110: PUSH
86111: LD_INT 0
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 1
86120: NEG
86121: PUSH
86122: LD_INT 1
86124: NEG
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 1
86132: NEG
86133: PUSH
86134: LD_INT 2
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 0
86144: PUSH
86145: LD_INT 2
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: PUSH
86156: LD_INT 1
86158: NEG
86159: PUSH
86160: EMPTY
86161: LIST
86162: LIST
86163: PUSH
86164: LD_INT 2
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 2
86176: PUSH
86177: LD_INT 1
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 2
86186: PUSH
86187: LD_INT 2
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: LD_INT 2
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: LD_INT 2
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: NEG
86217: PUSH
86218: LD_INT 1
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 2
86227: NEG
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: EMPTY
86233: LIST
86234: LIST
86235: PUSH
86236: LD_INT 2
86238: NEG
86239: PUSH
86240: LD_INT 1
86242: NEG
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 2
86250: NEG
86251: PUSH
86252: LD_INT 2
86254: NEG
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86281: LD_ADDR_VAR 0 21
86285: PUSH
86286: LD_INT 0
86288: PUSH
86289: LD_INT 0
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 0
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 1
86309: PUSH
86310: LD_INT 0
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 1
86319: PUSH
86320: LD_INT 1
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 0
86329: PUSH
86330: LD_INT 1
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 1
86339: NEG
86340: PUSH
86341: LD_INT 0
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 1
86350: NEG
86351: PUSH
86352: LD_INT 1
86354: NEG
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: LD_INT 2
86366: NEG
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 0
86374: PUSH
86375: LD_INT 2
86377: NEG
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: LD_INT 1
86385: PUSH
86386: LD_INT 1
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 2
86396: PUSH
86397: LD_INT 0
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 2
86406: PUSH
86407: LD_INT 1
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: LD_INT 2
86416: PUSH
86417: LD_INT 2
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: PUSH
86424: LD_INT 1
86426: PUSH
86427: LD_INT 2
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 0
86436: PUSH
86437: LD_INT 2
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: LD_INT 1
86446: NEG
86447: PUSH
86448: LD_INT 1
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 2
86457: NEG
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 2
86468: NEG
86469: PUSH
86470: LD_INT 1
86472: NEG
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 2
86480: NEG
86481: PUSH
86482: LD_INT 2
86484: NEG
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86511: LD_ADDR_VAR 0 22
86515: PUSH
86516: LD_INT 0
86518: PUSH
86519: LD_INT 0
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: LD_INT 0
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 1
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 1
86549: PUSH
86550: LD_INT 1
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 0
86559: PUSH
86560: LD_INT 1
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 1
86569: NEG
86570: PUSH
86571: LD_INT 0
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 1
86580: NEG
86581: PUSH
86582: LD_INT 1
86584: NEG
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 1
86592: NEG
86593: PUSH
86594: LD_INT 2
86596: NEG
86597: PUSH
86598: EMPTY
86599: LIST
86600: LIST
86601: PUSH
86602: LD_INT 0
86604: PUSH
86605: LD_INT 2
86607: NEG
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 1
86615: PUSH
86616: LD_INT 1
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 2
86626: PUSH
86627: LD_INT 0
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 2
86636: PUSH
86637: LD_INT 1
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 2
86646: PUSH
86647: LD_INT 2
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 1
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 0
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: LD_INT 1
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 2
86687: NEG
86688: PUSH
86689: LD_INT 0
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 2
86698: NEG
86699: PUSH
86700: LD_INT 1
86702: NEG
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: NEG
86711: PUSH
86712: LD_INT 2
86714: NEG
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
86741: LD_ADDR_VAR 0 23
86745: PUSH
86746: LD_INT 0
86748: PUSH
86749: LD_INT 0
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 1
86769: PUSH
86770: LD_INT 0
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 1
86779: PUSH
86780: LD_INT 1
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PUSH
86787: LD_INT 0
86789: PUSH
86790: LD_INT 1
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: LD_INT 0
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 1
86810: NEG
86811: PUSH
86812: LD_INT 1
86814: NEG
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: LD_INT 2
86826: NEG
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 0
86834: PUSH
86835: LD_INT 2
86837: NEG
86838: PUSH
86839: EMPTY
86840: LIST
86841: LIST
86842: PUSH
86843: LD_INT 1
86845: PUSH
86846: LD_INT 1
86848: NEG
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: LD_INT 0
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: PUSH
86864: LD_INT 2
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: LD_INT 2
86876: PUSH
86877: LD_INT 2
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PUSH
86884: LD_INT 1
86886: PUSH
86887: LD_INT 2
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: LD_INT 2
86899: PUSH
86900: EMPTY
86901: LIST
86902: LIST
86903: PUSH
86904: LD_INT 1
86906: NEG
86907: PUSH
86908: LD_INT 1
86910: PUSH
86911: EMPTY
86912: LIST
86913: LIST
86914: PUSH
86915: LD_INT 2
86917: NEG
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 2
86928: NEG
86929: PUSH
86930: LD_INT 1
86932: NEG
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 2
86940: NEG
86941: PUSH
86942: LD_INT 2
86944: NEG
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 2
86952: NEG
86953: PUSH
86954: LD_INT 3
86956: NEG
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 1
86964: NEG
86965: PUSH
86966: LD_INT 3
86968: NEG
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: LD_INT 1
86976: PUSH
86977: LD_INT 2
86979: NEG
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 2
86987: PUSH
86988: LD_INT 1
86990: NEG
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
87021: LD_ADDR_VAR 0 24
87025: PUSH
87026: LD_INT 0
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: LD_INT 1
87041: NEG
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 1
87049: PUSH
87050: LD_INT 0
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 0
87069: PUSH
87070: LD_INT 1
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 1
87079: NEG
87080: PUSH
87081: LD_INT 0
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 1
87090: NEG
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 1
87102: NEG
87103: PUSH
87104: LD_INT 2
87106: NEG
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: LD_INT 2
87117: NEG
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: LD_INT 1
87128: NEG
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 2
87136: PUSH
87137: LD_INT 0
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 2
87146: PUSH
87147: LD_INT 1
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: LD_INT 2
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 1
87166: PUSH
87167: LD_INT 2
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: LD_INT 2
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 1
87186: NEG
87187: PUSH
87188: LD_INT 1
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 2
87197: NEG
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: PUSH
87206: LD_INT 2
87208: NEG
87209: PUSH
87210: LD_INT 1
87212: NEG
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 2
87220: NEG
87221: PUSH
87222: LD_INT 2
87224: NEG
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: PUSH
87233: LD_INT 2
87235: NEG
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 2
87243: PUSH
87244: LD_INT 1
87246: NEG
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 3
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 3
87264: PUSH
87265: LD_INT 2
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: LIST
87291: LIST
87292: LIST
87293: LIST
87294: LIST
87295: LIST
87296: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
87297: LD_ADDR_VAR 0 25
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: LD_INT 0
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: PUSH
87312: LD_INT 0
87314: PUSH
87315: LD_INT 1
87317: NEG
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: PUSH
87323: LD_INT 1
87325: PUSH
87326: LD_INT 0
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 1
87335: PUSH
87336: LD_INT 1
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 0
87345: PUSH
87346: LD_INT 1
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 1
87355: NEG
87356: PUSH
87357: LD_INT 0
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 1
87366: NEG
87367: PUSH
87368: LD_INT 1
87370: NEG
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PUSH
87376: LD_INT 1
87378: NEG
87379: PUSH
87380: LD_INT 2
87382: NEG
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: PUSH
87388: LD_INT 0
87390: PUSH
87391: LD_INT 2
87393: NEG
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: PUSH
87399: LD_INT 1
87401: PUSH
87402: LD_INT 1
87404: NEG
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 2
87412: PUSH
87413: LD_INT 0
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 2
87422: PUSH
87423: LD_INT 1
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 2
87432: PUSH
87433: LD_INT 2
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 1
87442: PUSH
87443: LD_INT 2
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: LD_INT 2
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 1
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 2
87473: NEG
87474: PUSH
87475: LD_INT 0
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: NEG
87485: PUSH
87486: LD_INT 1
87488: NEG
87489: PUSH
87490: EMPTY
87491: LIST
87492: LIST
87493: PUSH
87494: LD_INT 2
87496: NEG
87497: PUSH
87498: LD_INT 2
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 3
87508: PUSH
87509: LD_INT 1
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 3
87518: PUSH
87519: LD_INT 2
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: LD_INT 3
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: PUSH
87539: LD_INT 3
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87571: LD_ADDR_VAR 0 26
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: LD_INT 0
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 0
87588: PUSH
87589: LD_INT 1
87591: NEG
87592: PUSH
87593: EMPTY
87594: LIST
87595: LIST
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: LD_INT 0
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 1
87609: PUSH
87610: LD_INT 1
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: LD_INT 1
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 1
87629: NEG
87630: PUSH
87631: LD_INT 0
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: PUSH
87638: LD_INT 1
87640: NEG
87641: PUSH
87642: LD_INT 1
87644: NEG
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 1
87652: NEG
87653: PUSH
87654: LD_INT 2
87656: NEG
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 0
87664: PUSH
87665: LD_INT 2
87667: NEG
87668: PUSH
87669: EMPTY
87670: LIST
87671: LIST
87672: PUSH
87673: LD_INT 1
87675: PUSH
87676: LD_INT 1
87678: NEG
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 2
87686: PUSH
87687: LD_INT 0
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: LD_INT 1
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 2
87706: PUSH
87707: LD_INT 2
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 1
87716: PUSH
87717: LD_INT 2
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: LD_INT 2
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 1
87736: NEG
87737: PUSH
87738: LD_INT 1
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 2
87747: NEG
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 2
87758: NEG
87759: PUSH
87760: LD_INT 1
87762: NEG
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 2
87770: NEG
87771: PUSH
87772: LD_INT 2
87774: NEG
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 2
87782: PUSH
87783: LD_INT 3
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: PUSH
87793: LD_INT 3
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 2
87813: NEG
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87847: LD_ADDR_VAR 0 27
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 0
87864: PUSH
87865: LD_INT 1
87867: NEG
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 1
87875: PUSH
87876: LD_INT 0
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 1
87885: PUSH
87886: LD_INT 1
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 0
87895: PUSH
87896: LD_INT 1
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 1
87905: NEG
87906: PUSH
87907: LD_INT 0
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 1
87916: NEG
87917: PUSH
87918: LD_INT 1
87920: NEG
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 1
87928: NEG
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 0
87940: PUSH
87941: LD_INT 2
87943: NEG
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 1
87951: PUSH
87952: LD_INT 1
87954: NEG
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 2
87962: PUSH
87963: LD_INT 0
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: PUSH
87970: LD_INT 2
87972: PUSH
87973: LD_INT 1
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 2
87982: PUSH
87983: LD_INT 2
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 1
87992: PUSH
87993: LD_INT 2
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 0
88002: PUSH
88003: LD_INT 2
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 1
88012: NEG
88013: PUSH
88014: LD_INT 1
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 2
88023: NEG
88024: PUSH
88025: LD_INT 0
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 2
88034: NEG
88035: PUSH
88036: LD_INT 1
88038: NEG
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 2
88046: NEG
88047: PUSH
88048: LD_INT 2
88050: NEG
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: LD_INT 2
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: LD_INT 2
88069: NEG
88070: PUSH
88071: LD_INT 1
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 3
88080: NEG
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 3
88092: NEG
88093: PUSH
88094: LD_INT 2
88096: NEG
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88127: LD_ADDR_VAR 0 28
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: LD_INT 0
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 0
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: LD_INT 0
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: LD_INT 1
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 0
88175: PUSH
88176: LD_INT 1
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 0
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: PUSH
88194: LD_INT 1
88196: NEG
88197: PUSH
88198: LD_INT 1
88200: NEG
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 1
88208: NEG
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: PUSH
88232: LD_INT 1
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 2
88242: PUSH
88243: LD_INT 0
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 2
88252: PUSH
88253: LD_INT 1
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 2
88262: PUSH
88263: LD_INT 2
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 1
88272: PUSH
88273: LD_INT 2
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 0
88282: PUSH
88283: LD_INT 2
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 1
88292: NEG
88293: PUSH
88294: LD_INT 1
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: NEG
88304: PUSH
88305: LD_INT 0
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: NEG
88315: PUSH
88316: LD_INT 1
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 2
88326: NEG
88327: PUSH
88328: LD_INT 2
88330: NEG
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 2
88338: NEG
88339: PUSH
88340: LD_INT 3
88342: NEG
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: PUSH
88348: LD_INT 1
88350: NEG
88351: PUSH
88352: LD_INT 3
88354: NEG
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 3
88362: NEG
88363: PUSH
88364: LD_INT 1
88366: NEG
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: LD_INT 3
88374: NEG
88375: PUSH
88376: LD_INT 2
88378: NEG
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88409: LD_ADDR_VAR 0 29
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: LD_INT 0
88419: PUSH
88420: EMPTY
88421: LIST
88422: LIST
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: LD_INT 1
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: PUSH
88438: LD_INT 0
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: LD_INT 1
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: PUSH
88455: LD_INT 0
88457: PUSH
88458: LD_INT 1
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 1
88467: NEG
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: PUSH
88476: LD_INT 1
88478: NEG
88479: PUSH
88480: LD_INT 1
88482: NEG
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 1
88490: NEG
88491: PUSH
88492: LD_INT 2
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 0
88502: PUSH
88503: LD_INT 2
88505: NEG
88506: PUSH
88507: EMPTY
88508: LIST
88509: LIST
88510: PUSH
88511: LD_INT 1
88513: PUSH
88514: LD_INT 1
88516: NEG
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 2
88524: PUSH
88525: LD_INT 0
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 2
88534: PUSH
88535: LD_INT 1
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 1
88544: PUSH
88545: LD_INT 2
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 0
88554: PUSH
88555: LD_INT 2
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 1
88564: NEG
88565: PUSH
88566: LD_INT 1
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: PUSH
88573: LD_INT 2
88575: NEG
88576: PUSH
88577: LD_INT 1
88579: NEG
88580: PUSH
88581: EMPTY
88582: LIST
88583: LIST
88584: PUSH
88585: LD_INT 2
88587: NEG
88588: PUSH
88589: LD_INT 2
88591: NEG
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 2
88599: NEG
88600: PUSH
88601: LD_INT 3
88603: NEG
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 2
88611: PUSH
88612: LD_INT 1
88614: NEG
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 3
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: LD_INT 3
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 1
88642: NEG
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 3
88653: NEG
88654: PUSH
88655: LD_INT 2
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88688: LD_ADDR_VAR 0 30
88692: PUSH
88693: LD_INT 0
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: LD_INT 1
88708: NEG
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 1
88716: PUSH
88717: LD_INT 0
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 1
88726: PUSH
88727: LD_INT 1
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 0
88736: PUSH
88737: LD_INT 1
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 1
88746: NEG
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: LD_INT 1
88761: NEG
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: PUSH
88767: LD_INT 1
88769: NEG
88770: PUSH
88771: LD_INT 2
88773: NEG
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 0
88781: PUSH
88782: LD_INT 2
88784: NEG
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 1
88792: PUSH
88793: LD_INT 1
88795: NEG
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 2
88803: PUSH
88804: LD_INT 0
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 2
88813: PUSH
88814: LD_INT 1
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 2
88823: PUSH
88824: LD_INT 2
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: LD_INT 1
88833: PUSH
88834: LD_INT 2
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: PUSH
88841: LD_INT 1
88843: NEG
88844: PUSH
88845: LD_INT 1
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PUSH
88852: LD_INT 2
88854: NEG
88855: PUSH
88856: LD_INT 0
88858: PUSH
88859: EMPTY
88860: LIST
88861: LIST
88862: PUSH
88863: LD_INT 2
88865: NEG
88866: PUSH
88867: LD_INT 1
88869: NEG
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 1
88877: NEG
88878: PUSH
88879: LD_INT 3
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 1
88889: PUSH
88890: LD_INT 2
88892: NEG
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 3
88900: PUSH
88901: LD_INT 2
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 2
88910: PUSH
88911: LD_INT 3
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: LD_INT 2
88920: NEG
88921: PUSH
88922: LD_INT 1
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 3
88931: NEG
88932: PUSH
88933: LD_INT 1
88935: NEG
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88966: LD_ADDR_VAR 0 31
88970: PUSH
88971: LD_INT 0
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: LD_INT 1
88986: NEG
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 1
88994: PUSH
88995: LD_INT 0
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PUSH
89002: LD_INT 1
89004: PUSH
89005: LD_INT 1
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 0
89014: PUSH
89015: LD_INT 1
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: PUSH
89026: LD_INT 0
89028: PUSH
89029: EMPTY
89030: LIST
89031: LIST
89032: PUSH
89033: LD_INT 1
89035: NEG
89036: PUSH
89037: LD_INT 1
89039: NEG
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 1
89047: NEG
89048: PUSH
89049: LD_INT 2
89051: NEG
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 2
89070: PUSH
89071: LD_INT 0
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: LD_INT 1
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 1
89100: PUSH
89101: LD_INT 2
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 0
89110: PUSH
89111: LD_INT 2
89113: PUSH
89114: EMPTY
89115: LIST
89116: LIST
89117: PUSH
89118: LD_INT 1
89120: NEG
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: LD_INT 2
89131: NEG
89132: PUSH
89133: LD_INT 1
89135: NEG
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 2
89143: NEG
89144: PUSH
89145: LD_INT 2
89147: NEG
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 2
89155: NEG
89156: PUSH
89157: LD_INT 3
89159: NEG
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: LD_INT 2
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 3
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 1
89188: PUSH
89189: LD_INT 3
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: PUSH
89196: LD_INT 1
89198: NEG
89199: PUSH
89200: LD_INT 2
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: LD_INT 3
89209: NEG
89210: PUSH
89211: LD_INT 2
89213: NEG
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89244: LD_ADDR_VAR 0 32
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 0
89261: PUSH
89262: LD_INT 1
89264: NEG
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 1
89282: PUSH
89283: LD_INT 1
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 0
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: NEG
89314: PUSH
89315: LD_INT 1
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 2
89329: NEG
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: LD_INT 2
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 1
89351: NEG
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: LD_INT 2
89359: PUSH
89360: LD_INT 1
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: LD_INT 2
89369: PUSH
89370: LD_INT 2
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 1
89379: PUSH
89380: LD_INT 2
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: LD_INT 2
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: PUSH
89397: LD_INT 1
89399: NEG
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 2
89410: NEG
89411: PUSH
89412: LD_INT 0
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 2
89421: NEG
89422: PUSH
89423: LD_INT 1
89425: NEG
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: LD_INT 1
89433: NEG
89434: PUSH
89435: LD_INT 3
89437: NEG
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 1
89445: PUSH
89446: LD_INT 2
89448: NEG
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 3
89456: PUSH
89457: LD_INT 2
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 2
89466: PUSH
89467: LD_INT 3
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: LD_INT 2
89476: NEG
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PUSH
89485: LD_INT 3
89487: NEG
89488: PUSH
89489: LD_INT 1
89491: NEG
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
89522: LD_ADDR_VAR 0 33
89526: PUSH
89527: LD_INT 0
89529: PUSH
89530: LD_INT 0
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: PUSH
89537: LD_INT 0
89539: PUSH
89540: LD_INT 1
89542: NEG
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 1
89550: PUSH
89551: LD_INT 0
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 1
89560: PUSH
89561: LD_INT 1
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: LD_INT 1
89573: PUSH
89574: EMPTY
89575: LIST
89576: LIST
89577: PUSH
89578: LD_INT 1
89580: NEG
89581: PUSH
89582: LD_INT 0
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 1
89591: NEG
89592: PUSH
89593: LD_INT 1
89595: NEG
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 1
89603: NEG
89604: PUSH
89605: LD_INT 2
89607: NEG
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: LD_INT 1
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 2
89626: PUSH
89627: LD_INT 0
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 2
89636: PUSH
89637: LD_INT 1
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: PUSH
89644: LD_INT 1
89646: PUSH
89647: LD_INT 2
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: LD_INT 0
89656: PUSH
89657: LD_INT 2
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: LD_INT 1
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 2
89677: NEG
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 2
89688: NEG
89689: PUSH
89690: LD_INT 1
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: LD_INT 2
89704: NEG
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 2
89712: NEG
89713: PUSH
89714: LD_INT 3
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 2
89724: PUSH
89725: LD_INT 1
89727: NEG
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 3
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 1
89745: PUSH
89746: LD_INT 3
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 1
89755: NEG
89756: PUSH
89757: LD_INT 2
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: PUSH
89764: LD_INT 3
89766: NEG
89767: PUSH
89768: LD_INT 2
89770: NEG
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: LIST
89799: LIST
89800: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
89801: LD_ADDR_VAR 0 34
89805: PUSH
89806: LD_INT 0
89808: PUSH
89809: LD_INT 0
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 0
89818: PUSH
89819: LD_INT 1
89821: NEG
89822: PUSH
89823: EMPTY
89824: LIST
89825: LIST
89826: PUSH
89827: LD_INT 1
89829: PUSH
89830: LD_INT 0
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: PUSH
89840: LD_INT 1
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: LD_INT 1
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 1
89859: NEG
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: PUSH
89868: LD_INT 1
89870: NEG
89871: PUSH
89872: LD_INT 1
89874: NEG
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 1
89882: NEG
89883: PUSH
89884: LD_INT 2
89886: NEG
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 0
89894: PUSH
89895: LD_INT 2
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 1
89905: PUSH
89906: LD_INT 1
89908: NEG
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 2
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 2
89926: PUSH
89927: LD_INT 2
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: PUSH
89937: LD_INT 2
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: LD_INT 1
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 2
89957: NEG
89958: PUSH
89959: LD_INT 0
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 2
89968: NEG
89969: PUSH
89970: LD_INT 1
89972: NEG
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 2
89980: NEG
89981: PUSH
89982: LD_INT 2
89984: NEG
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 1
89992: NEG
89993: PUSH
89994: LD_INT 3
89996: NEG
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 1
90004: PUSH
90005: LD_INT 2
90007: NEG
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: LD_INT 3
90015: PUSH
90016: LD_INT 2
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 2
90025: PUSH
90026: LD_INT 3
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 2
90035: NEG
90036: PUSH
90037: LD_INT 1
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 3
90046: NEG
90047: PUSH
90048: LD_INT 1
90050: NEG
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90081: LD_ADDR_VAR 0 35
90085: PUSH
90086: LD_INT 0
90088: PUSH
90089: LD_INT 0
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 0
90098: PUSH
90099: LD_INT 1
90101: NEG
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 1
90109: PUSH
90110: LD_INT 0
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 1
90119: PUSH
90120: LD_INT 1
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: PUSH
90127: LD_INT 0
90129: PUSH
90130: LD_INT 1
90132: PUSH
90133: EMPTY
90134: LIST
90135: LIST
90136: PUSH
90137: LD_INT 1
90139: NEG
90140: PUSH
90141: LD_INT 0
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: LD_INT 1
90154: NEG
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 1
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 2
90172: NEG
90173: PUSH
90174: LD_INT 1
90176: NEG
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90193: LD_ADDR_VAR 0 36
90197: PUSH
90198: LD_INT 0
90200: PUSH
90201: LD_INT 0
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 0
90210: PUSH
90211: LD_INT 1
90213: NEG
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 1
90221: PUSH
90222: LD_INT 0
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 1
90231: PUSH
90232: LD_INT 1
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 0
90241: PUSH
90242: LD_INT 1
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: PUSH
90249: LD_INT 1
90251: NEG
90252: PUSH
90253: LD_INT 0
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: LD_INT 1
90266: NEG
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: PUSH
90272: LD_INT 1
90274: NEG
90275: PUSH
90276: LD_INT 2
90278: NEG
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: LD_INT 2
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90305: LD_ADDR_VAR 0 37
90309: PUSH
90310: LD_INT 0
90312: PUSH
90313: LD_INT 0
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PUSH
90320: LD_INT 0
90322: PUSH
90323: LD_INT 1
90325: NEG
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 1
90333: PUSH
90334: LD_INT 0
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 1
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 0
90353: PUSH
90354: LD_INT 1
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PUSH
90361: LD_INT 1
90363: NEG
90364: PUSH
90365: LD_INT 0
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 1
90374: NEG
90375: PUSH
90376: LD_INT 1
90378: NEG
90379: PUSH
90380: EMPTY
90381: LIST
90382: LIST
90383: PUSH
90384: LD_INT 1
90386: PUSH
90387: LD_INT 1
90389: NEG
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 1
90397: NEG
90398: PUSH
90399: LD_INT 1
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
90417: LD_ADDR_VAR 0 38
90421: PUSH
90422: LD_INT 0
90424: PUSH
90425: LD_INT 0
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 0
90434: PUSH
90435: LD_INT 1
90437: NEG
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 1
90445: PUSH
90446: LD_INT 0
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: LD_INT 1
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 0
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 1
90475: NEG
90476: PUSH
90477: LD_INT 0
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: LD_INT 1
90490: NEG
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: LD_INT 1
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: PUSH
90506: LD_INT 2
90508: NEG
90509: PUSH
90510: LD_INT 1
90512: NEG
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
90529: LD_ADDR_VAR 0 39
90533: PUSH
90534: LD_INT 0
90536: PUSH
90537: LD_INT 0
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PUSH
90544: LD_INT 0
90546: PUSH
90547: LD_INT 1
90549: NEG
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 1
90557: PUSH
90558: LD_INT 0
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 1
90567: PUSH
90568: LD_INT 1
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 1
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 1
90587: NEG
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: NEG
90599: PUSH
90600: LD_INT 1
90602: NEG
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 1
90610: NEG
90611: PUSH
90612: LD_INT 2
90614: NEG
90615: PUSH
90616: EMPTY
90617: LIST
90618: LIST
90619: PUSH
90620: LD_INT 1
90622: PUSH
90623: LD_INT 2
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
90641: LD_ADDR_VAR 0 40
90645: PUSH
90646: LD_INT 0
90648: PUSH
90649: LD_INT 0
90651: PUSH
90652: EMPTY
90653: LIST
90654: LIST
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: LD_INT 1
90661: NEG
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 1
90669: PUSH
90670: LD_INT 0
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PUSH
90677: LD_INT 1
90679: PUSH
90680: LD_INT 1
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: PUSH
90687: LD_INT 0
90689: PUSH
90690: LD_INT 1
90692: PUSH
90693: EMPTY
90694: LIST
90695: LIST
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: LD_INT 0
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 1
90710: NEG
90711: PUSH
90712: LD_INT 1
90714: NEG
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: LD_INT 1
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: LD_INT 1
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90753: LD_ADDR_VAR 0 41
90757: PUSH
90758: LD_INT 0
90760: PUSH
90761: LD_INT 0
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 0
90770: PUSH
90771: LD_INT 1
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 1
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 1
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: PUSH
90799: LD_INT 0
90801: PUSH
90802: LD_INT 1
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 1
90811: NEG
90812: PUSH
90813: LD_INT 0
90815: PUSH
90816: EMPTY
90817: LIST
90818: LIST
90819: PUSH
90820: LD_INT 1
90822: NEG
90823: PUSH
90824: LD_INT 1
90826: NEG
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: PUSH
90832: LD_INT 1
90834: NEG
90835: PUSH
90836: LD_INT 2
90838: NEG
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 1
90846: PUSH
90847: LD_INT 1
90849: NEG
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: PUSH
90855: LD_INT 2
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 2
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 2
90877: PUSH
90878: LD_INT 2
90880: PUSH
90881: EMPTY
90882: LIST
90883: LIST
90884: PUSH
90885: LD_INT 1
90887: PUSH
90888: LD_INT 2
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 1
90897: NEG
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 2
90908: NEG
90909: PUSH
90910: LD_INT 0
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: LD_INT 2
90919: NEG
90920: PUSH
90921: LD_INT 1
90923: NEG
90924: PUSH
90925: EMPTY
90926: LIST
90927: LIST
90928: PUSH
90929: LD_INT 2
90931: NEG
90932: PUSH
90933: LD_INT 2
90935: NEG
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 2
90943: NEG
90944: PUSH
90945: LD_INT 3
90947: NEG
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 2
90955: PUSH
90956: LD_INT 1
90958: NEG
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: PUSH
90964: LD_INT 3
90966: PUSH
90967: LD_INT 0
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 3
90976: PUSH
90977: LD_INT 1
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 3
90986: PUSH
90987: LD_INT 2
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 3
90996: PUSH
90997: LD_INT 3
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 2
91006: PUSH
91007: LD_INT 3
91009: PUSH
91010: EMPTY
91011: LIST
91012: LIST
91013: PUSH
91014: LD_INT 2
91016: NEG
91017: PUSH
91018: LD_INT 1
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 3
91027: NEG
91028: PUSH
91029: LD_INT 0
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 3
91038: NEG
91039: PUSH
91040: LD_INT 1
91042: NEG
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 3
91050: NEG
91051: PUSH
91052: LD_INT 2
91054: NEG
91055: PUSH
91056: EMPTY
91057: LIST
91058: LIST
91059: PUSH
91060: LD_INT 3
91062: NEG
91063: PUSH
91064: LD_INT 3
91066: NEG
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91103: LD_ADDR_VAR 0 42
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: LD_INT 0
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: PUSH
91118: LD_INT 0
91120: PUSH
91121: LD_INT 1
91123: NEG
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 1
91131: PUSH
91132: LD_INT 0
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 1
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 0
91151: PUSH
91152: LD_INT 1
91154: PUSH
91155: EMPTY
91156: LIST
91157: LIST
91158: PUSH
91159: LD_INT 1
91161: NEG
91162: PUSH
91163: LD_INT 0
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 1
91172: NEG
91173: PUSH
91174: LD_INT 1
91176: NEG
91177: PUSH
91178: EMPTY
91179: LIST
91180: LIST
91181: PUSH
91182: LD_INT 1
91184: NEG
91185: PUSH
91186: LD_INT 2
91188: NEG
91189: PUSH
91190: EMPTY
91191: LIST
91192: LIST
91193: PUSH
91194: LD_INT 0
91196: PUSH
91197: LD_INT 2
91199: NEG
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: LD_INT 1
91210: NEG
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 2
91218: PUSH
91219: LD_INT 1
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 2
91228: PUSH
91229: LD_INT 2
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: LD_INT 2
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 0
91248: PUSH
91249: LD_INT 2
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 1
91258: NEG
91259: PUSH
91260: LD_INT 1
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 2
91269: NEG
91270: PUSH
91271: LD_INT 1
91273: NEG
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: PUSH
91279: LD_INT 2
91281: NEG
91282: PUSH
91283: LD_INT 2
91285: NEG
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 2
91293: NEG
91294: PUSH
91295: LD_INT 3
91297: NEG
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: LD_INT 3
91309: NEG
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 0
91317: PUSH
91318: LD_INT 3
91320: NEG
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 1
91328: PUSH
91329: LD_INT 2
91331: NEG
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 3
91339: PUSH
91340: LD_INT 2
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 3
91349: PUSH
91350: LD_INT 3
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 2
91359: PUSH
91360: LD_INT 3
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 1
91369: PUSH
91370: LD_INT 3
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 0
91379: PUSH
91380: LD_INT 3
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 1
91389: NEG
91390: PUSH
91391: LD_INT 2
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 3
91400: NEG
91401: PUSH
91402: LD_INT 2
91404: NEG
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 3
91412: NEG
91413: PUSH
91414: LD_INT 3
91416: NEG
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91453: LD_ADDR_VAR 0 43
91457: PUSH
91458: LD_INT 0
91460: PUSH
91461: LD_INT 0
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: LD_INT 1
91473: NEG
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 1
91481: PUSH
91482: LD_INT 0
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: LD_INT 1
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 0
91501: PUSH
91502: LD_INT 1
91504: PUSH
91505: EMPTY
91506: LIST
91507: LIST
91508: PUSH
91509: LD_INT 1
91511: NEG
91512: PUSH
91513: LD_INT 0
91515: PUSH
91516: EMPTY
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 1
91522: NEG
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 1
91534: NEG
91535: PUSH
91536: LD_INT 2
91538: NEG
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PUSH
91544: LD_INT 0
91546: PUSH
91547: LD_INT 2
91549: NEG
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: LD_INT 1
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: LD_INT 2
91568: PUSH
91569: LD_INT 0
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 2
91578: PUSH
91579: LD_INT 1
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 1
91588: PUSH
91589: LD_INT 2
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 0
91598: PUSH
91599: LD_INT 2
91601: PUSH
91602: EMPTY
91603: LIST
91604: LIST
91605: PUSH
91606: LD_INT 1
91608: NEG
91609: PUSH
91610: LD_INT 1
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 2
91619: NEG
91620: PUSH
91621: LD_INT 0
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 2
91630: NEG
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: NEG
91643: PUSH
91644: LD_INT 3
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 0
91654: PUSH
91655: LD_INT 3
91657: NEG
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: PUSH
91663: LD_INT 1
91665: PUSH
91666: LD_INT 2
91668: NEG
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 2
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 3
91687: PUSH
91688: LD_INT 0
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: LD_INT 3
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: LD_INT 1
91707: PUSH
91708: LD_INT 3
91710: PUSH
91711: EMPTY
91712: LIST
91713: LIST
91714: PUSH
91715: LD_INT 0
91717: PUSH
91718: LD_INT 3
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 1
91727: NEG
91728: PUSH
91729: LD_INT 2
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 2
91738: NEG
91739: PUSH
91740: LD_INT 1
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 3
91749: NEG
91750: PUSH
91751: LD_INT 0
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 3
91760: NEG
91761: PUSH
91762: LD_INT 1
91764: NEG
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91801: LD_ADDR_VAR 0 44
91805: PUSH
91806: LD_INT 0
91808: PUSH
91809: LD_INT 0
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 0
91818: PUSH
91819: LD_INT 1
91821: NEG
91822: PUSH
91823: EMPTY
91824: LIST
91825: LIST
91826: PUSH
91827: LD_INT 1
91829: PUSH
91830: LD_INT 0
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PUSH
91837: LD_INT 1
91839: PUSH
91840: LD_INT 1
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: PUSH
91847: LD_INT 0
91849: PUSH
91850: LD_INT 1
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 1
91859: NEG
91860: PUSH
91861: LD_INT 0
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: PUSH
91868: LD_INT 1
91870: NEG
91871: PUSH
91872: LD_INT 1
91874: NEG
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: LD_INT 1
91882: NEG
91883: PUSH
91884: LD_INT 2
91886: NEG
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 1
91894: PUSH
91895: LD_INT 1
91897: NEG
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 2
91905: PUSH
91906: LD_INT 0
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 2
91915: PUSH
91916: LD_INT 1
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 2
91925: PUSH
91926: LD_INT 2
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PUSH
91933: LD_INT 1
91935: PUSH
91936: LD_INT 2
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 1
91945: NEG
91946: PUSH
91947: LD_INT 1
91949: PUSH
91950: EMPTY
91951: LIST
91952: LIST
91953: PUSH
91954: LD_INT 2
91956: NEG
91957: PUSH
91958: LD_INT 0
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: PUSH
91965: LD_INT 2
91967: NEG
91968: PUSH
91969: LD_INT 1
91971: NEG
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 2
91979: NEG
91980: PUSH
91981: LD_INT 2
91983: NEG
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 2
91991: NEG
91992: PUSH
91993: LD_INT 3
91995: NEG
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: LD_INT 2
92003: PUSH
92004: LD_INT 1
92006: NEG
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 3
92014: PUSH
92015: LD_INT 0
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 3
92024: PUSH
92025: LD_INT 1
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 3
92034: PUSH
92035: LD_INT 2
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: LD_INT 3
92044: PUSH
92045: LD_INT 3
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: PUSH
92052: LD_INT 2
92054: PUSH
92055: LD_INT 3
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 2
92064: NEG
92065: PUSH
92066: LD_INT 1
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: PUSH
92073: LD_INT 3
92075: NEG
92076: PUSH
92077: LD_INT 0
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 3
92086: NEG
92087: PUSH
92088: LD_INT 1
92090: NEG
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 3
92098: NEG
92099: PUSH
92100: LD_INT 2
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 3
92110: NEG
92111: PUSH
92112: LD_INT 3
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92151: LD_ADDR_VAR 0 45
92155: PUSH
92156: LD_INT 0
92158: PUSH
92159: LD_INT 0
92161: PUSH
92162: EMPTY
92163: LIST
92164: LIST
92165: PUSH
92166: LD_INT 0
92168: PUSH
92169: LD_INT 1
92171: NEG
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: PUSH
92177: LD_INT 1
92179: PUSH
92180: LD_INT 0
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 1
92189: PUSH
92190: LD_INT 1
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: LD_INT 1
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 1
92209: NEG
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 1
92220: NEG
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 1
92232: NEG
92233: PUSH
92234: LD_INT 2
92236: NEG
92237: PUSH
92238: EMPTY
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 0
92244: PUSH
92245: LD_INT 2
92247: NEG
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: PUSH
92253: LD_INT 1
92255: PUSH
92256: LD_INT 1
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 2
92266: PUSH
92267: LD_INT 1
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 2
92276: PUSH
92277: LD_INT 2
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: LD_INT 1
92286: PUSH
92287: LD_INT 2
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 0
92296: PUSH
92297: LD_INT 2
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 1
92306: NEG
92307: PUSH
92308: LD_INT 1
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 2
92317: NEG
92318: PUSH
92319: LD_INT 1
92321: NEG
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 2
92329: NEG
92330: PUSH
92331: LD_INT 2
92333: NEG
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: LD_INT 2
92341: NEG
92342: PUSH
92343: LD_INT 3
92345: NEG
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 1
92353: NEG
92354: PUSH
92355: LD_INT 3
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 0
92365: PUSH
92366: LD_INT 3
92368: NEG
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 1
92376: PUSH
92377: LD_INT 2
92379: NEG
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 3
92387: PUSH
92388: LD_INT 2
92390: PUSH
92391: EMPTY
92392: LIST
92393: LIST
92394: PUSH
92395: LD_INT 3
92397: PUSH
92398: LD_INT 3
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 2
92407: PUSH
92408: LD_INT 3
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 1
92417: PUSH
92418: LD_INT 3
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: LD_INT 3
92430: PUSH
92431: EMPTY
92432: LIST
92433: LIST
92434: PUSH
92435: LD_INT 1
92437: NEG
92438: PUSH
92439: LD_INT 2
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 3
92448: NEG
92449: PUSH
92450: LD_INT 2
92452: NEG
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 3
92460: NEG
92461: PUSH
92462: LD_INT 3
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92501: LD_ADDR_VAR 0 46
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: LD_INT 0
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 0
92518: PUSH
92519: LD_INT 1
92521: NEG
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 1
92529: PUSH
92530: LD_INT 0
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 1
92539: PUSH
92540: LD_INT 1
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 0
92549: PUSH
92550: LD_INT 1
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 1
92559: NEG
92560: PUSH
92561: LD_INT 0
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 1
92570: NEG
92571: PUSH
92572: LD_INT 1
92574: NEG
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 1
92582: NEG
92583: PUSH
92584: LD_INT 2
92586: NEG
92587: PUSH
92588: EMPTY
92589: LIST
92590: LIST
92591: PUSH
92592: LD_INT 0
92594: PUSH
92595: LD_INT 2
92597: NEG
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 1
92605: PUSH
92606: LD_INT 1
92608: NEG
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: PUSH
92614: LD_INT 2
92616: PUSH
92617: LD_INT 0
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: PUSH
92624: LD_INT 2
92626: PUSH
92627: LD_INT 1
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 1
92636: PUSH
92637: LD_INT 2
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: PUSH
92644: LD_INT 0
92646: PUSH
92647: LD_INT 2
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 1
92656: NEG
92657: PUSH
92658: LD_INT 1
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 2
92667: NEG
92668: PUSH
92669: LD_INT 0
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 2
92678: NEG
92679: PUSH
92680: LD_INT 1
92682: NEG
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 1
92690: NEG
92691: PUSH
92692: LD_INT 3
92694: NEG
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 0
92702: PUSH
92703: LD_INT 3
92705: NEG
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: LD_INT 1
92713: PUSH
92714: LD_INT 2
92716: NEG
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 2
92724: PUSH
92725: LD_INT 1
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: PUSH
92736: LD_INT 0
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 3
92745: PUSH
92746: LD_INT 1
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 1
92755: PUSH
92756: LD_INT 3
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 0
92765: PUSH
92766: LD_INT 3
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 1
92775: NEG
92776: PUSH
92777: LD_INT 2
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 2
92786: NEG
92787: PUSH
92788: LD_INT 1
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: PUSH
92795: LD_INT 3
92797: NEG
92798: PUSH
92799: LD_INT 0
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 3
92808: NEG
92809: PUSH
92810: LD_INT 1
92812: NEG
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92849: LD_ADDR_VAR 0 47
92853: PUSH
92854: LD_INT 0
92856: PUSH
92857: LD_INT 0
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: LD_INT 1
92869: NEG
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 1
92877: PUSH
92878: LD_INT 0
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 1
92887: PUSH
92888: LD_INT 1
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 0
92897: PUSH
92898: LD_INT 1
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 1
92907: NEG
92908: PUSH
92909: LD_INT 0
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PUSH
92916: LD_INT 1
92918: NEG
92919: PUSH
92920: LD_INT 1
92922: NEG
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 1
92930: NEG
92931: PUSH
92932: LD_INT 2
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 0
92942: PUSH
92943: LD_INT 2
92945: NEG
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: PUSH
92954: LD_INT 1
92956: NEG
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 2
92964: NEG
92965: PUSH
92966: LD_INT 1
92968: NEG
92969: PUSH
92970: EMPTY
92971: LIST
92972: LIST
92973: PUSH
92974: LD_INT 2
92976: NEG
92977: PUSH
92978: LD_INT 2
92980: NEG
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93000: LD_ADDR_VAR 0 48
93004: PUSH
93005: LD_INT 0
93007: PUSH
93008: LD_INT 0
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: LD_INT 1
93020: NEG
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 1
93028: PUSH
93029: LD_INT 0
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: PUSH
93036: LD_INT 1
93038: PUSH
93039: LD_INT 1
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: LD_INT 1
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 1
93058: NEG
93059: PUSH
93060: LD_INT 0
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 1
93069: NEG
93070: PUSH
93071: LD_INT 1
93073: NEG
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 1
93081: NEG
93082: PUSH
93083: LD_INT 2
93085: NEG
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 0
93093: PUSH
93094: LD_INT 2
93096: NEG
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 1
93104: PUSH
93105: LD_INT 1
93107: NEG
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 2
93115: PUSH
93116: LD_INT 0
93118: PUSH
93119: EMPTY
93120: LIST
93121: LIST
93122: PUSH
93123: LD_INT 2
93125: PUSH
93126: LD_INT 1
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93147: LD_ADDR_VAR 0 49
93151: PUSH
93152: LD_INT 0
93154: PUSH
93155: LD_INT 0
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: PUSH
93162: LD_INT 0
93164: PUSH
93165: LD_INT 1
93167: NEG
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_INT 1
93175: PUSH
93176: LD_INT 0
93178: PUSH
93179: EMPTY
93180: LIST
93181: LIST
93182: PUSH
93183: LD_INT 1
93185: PUSH
93186: LD_INT 1
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: LD_INT 0
93195: PUSH
93196: LD_INT 1
93198: PUSH
93199: EMPTY
93200: LIST
93201: LIST
93202: PUSH
93203: LD_INT 1
93205: NEG
93206: PUSH
93207: LD_INT 0
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 1
93216: NEG
93217: PUSH
93218: LD_INT 1
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 1
93228: PUSH
93229: LD_INT 1
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 2
93239: PUSH
93240: LD_INT 0
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 2
93249: PUSH
93250: LD_INT 1
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: LD_INT 2
93259: PUSH
93260: LD_INT 2
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: LD_INT 1
93269: PUSH
93270: LD_INT 2
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93291: LD_ADDR_VAR 0 50
93295: PUSH
93296: LD_INT 0
93298: PUSH
93299: LD_INT 0
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 0
93308: PUSH
93309: LD_INT 1
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 1
93319: PUSH
93320: LD_INT 0
93322: PUSH
93323: EMPTY
93324: LIST
93325: LIST
93326: PUSH
93327: LD_INT 1
93329: PUSH
93330: LD_INT 1
93332: PUSH
93333: EMPTY
93334: LIST
93335: LIST
93336: PUSH
93337: LD_INT 0
93339: PUSH
93340: LD_INT 1
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 1
93349: NEG
93350: PUSH
93351: LD_INT 0
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 1
93360: NEG
93361: PUSH
93362: LD_INT 1
93364: NEG
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 2
93372: PUSH
93373: LD_INT 1
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 2
93382: PUSH
93383: LD_INT 2
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 1
93392: PUSH
93393: LD_INT 2
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 0
93402: PUSH
93403: LD_INT 2
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 1
93412: NEG
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93435: LD_ADDR_VAR 0 51
93439: PUSH
93440: LD_INT 0
93442: PUSH
93443: LD_INT 0
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: LD_INT 0
93452: PUSH
93453: LD_INT 1
93455: NEG
93456: PUSH
93457: EMPTY
93458: LIST
93459: LIST
93460: PUSH
93461: LD_INT 1
93463: PUSH
93464: LD_INT 0
93466: PUSH
93467: EMPTY
93468: LIST
93469: LIST
93470: PUSH
93471: LD_INT 1
93473: PUSH
93474: LD_INT 1
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 0
93483: PUSH
93484: LD_INT 1
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: LD_INT 1
93493: NEG
93494: PUSH
93495: LD_INT 0
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 1
93504: NEG
93505: PUSH
93506: LD_INT 1
93508: NEG
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 1
93516: PUSH
93517: LD_INT 2
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 0
93526: PUSH
93527: LD_INT 2
93529: PUSH
93530: EMPTY
93531: LIST
93532: LIST
93533: PUSH
93534: LD_INT 1
93536: NEG
93537: PUSH
93538: LD_INT 1
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: LD_INT 2
93547: NEG
93548: PUSH
93549: LD_INT 0
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 2
93558: NEG
93559: PUSH
93560: LD_INT 1
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93582: LD_ADDR_VAR 0 52
93586: PUSH
93587: LD_INT 0
93589: PUSH
93590: LD_INT 0
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: PUSH
93597: LD_INT 0
93599: PUSH
93600: LD_INT 1
93602: NEG
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: PUSH
93611: LD_INT 0
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PUSH
93618: LD_INT 1
93620: PUSH
93621: LD_INT 1
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: LD_INT 0
93630: PUSH
93631: LD_INT 1
93633: PUSH
93634: EMPTY
93635: LIST
93636: LIST
93637: PUSH
93638: LD_INT 1
93640: NEG
93641: PUSH
93642: LD_INT 0
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 1
93651: NEG
93652: PUSH
93653: LD_INT 1
93655: NEG
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 1
93663: NEG
93664: PUSH
93665: LD_INT 2
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 1
93675: NEG
93676: PUSH
93677: LD_INT 1
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 2
93686: NEG
93687: PUSH
93688: LD_INT 0
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 2
93697: NEG
93698: PUSH
93699: LD_INT 1
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 2
93709: NEG
93710: PUSH
93711: LD_INT 2
93713: NEG
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: LIST
93725: LIST
93726: LIST
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93733: LD_ADDR_VAR 0 53
93737: PUSH
93738: LD_INT 0
93740: PUSH
93741: LD_INT 0
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: PUSH
93748: LD_INT 0
93750: PUSH
93751: LD_INT 1
93753: NEG
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 1
93761: PUSH
93762: LD_INT 0
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 1
93771: PUSH
93772: LD_INT 1
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: PUSH
93779: LD_INT 0
93781: PUSH
93782: LD_INT 1
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: PUSH
93789: LD_INT 1
93791: NEG
93792: PUSH
93793: LD_INT 0
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 1
93802: NEG
93803: PUSH
93804: LD_INT 1
93806: NEG
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: LD_INT 1
93814: NEG
93815: PUSH
93816: LD_INT 2
93818: NEG
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: LD_INT 2
93829: NEG
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 1
93837: PUSH
93838: LD_INT 1
93840: NEG
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 2
93848: PUSH
93849: LD_INT 0
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 2
93858: PUSH
93859: LD_INT 1
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: PUSH
93869: LD_INT 2
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: LD_INT 1
93878: PUSH
93879: LD_INT 2
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PUSH
93886: LD_INT 0
93888: PUSH
93889: LD_INT 2
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 1
93898: NEG
93899: PUSH
93900: LD_INT 1
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: LD_INT 0
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 2
93920: NEG
93921: PUSH
93922: LD_INT 1
93924: NEG
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 2
93932: NEG
93933: PUSH
93934: LD_INT 2
93936: NEG
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93963: LD_ADDR_VAR 0 54
93967: PUSH
93968: LD_INT 0
93970: PUSH
93971: LD_INT 0
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 0
93980: PUSH
93981: LD_INT 1
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 1
93991: PUSH
93992: LD_INT 0
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 1
94001: PUSH
94002: LD_INT 1
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: PUSH
94009: LD_INT 0
94011: PUSH
94012: LD_INT 1
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 1
94021: NEG
94022: PUSH
94023: LD_INT 0
94025: PUSH
94026: EMPTY
94027: LIST
94028: LIST
94029: PUSH
94030: LD_INT 1
94032: NEG
94033: PUSH
94034: LD_INT 1
94036: NEG
94037: PUSH
94038: EMPTY
94039: LIST
94040: LIST
94041: PUSH
94042: LD_INT 1
94044: NEG
94045: PUSH
94046: LD_INT 2
94048: NEG
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 0
94056: PUSH
94057: LD_INT 2
94059: NEG
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 1
94067: PUSH
94068: LD_INT 1
94070: NEG
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 2
94078: PUSH
94079: LD_INT 0
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: LD_INT 2
94088: PUSH
94089: LD_INT 1
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 2
94098: PUSH
94099: LD_INT 2
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: PUSH
94106: LD_INT 1
94108: PUSH
94109: LD_INT 2
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 0
94118: PUSH
94119: LD_INT 2
94121: PUSH
94122: EMPTY
94123: LIST
94124: LIST
94125: PUSH
94126: LD_INT 1
94128: NEG
94129: PUSH
94130: LD_INT 1
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 2
94139: NEG
94140: PUSH
94141: LD_INT 0
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: LD_INT 2
94150: NEG
94151: PUSH
94152: LD_INT 1
94154: NEG
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 2
94162: NEG
94163: PUSH
94164: LD_INT 2
94166: NEG
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94193: LD_ADDR_VAR 0 55
94197: PUSH
94198: LD_INT 0
94200: PUSH
94201: LD_INT 0
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: LD_INT 1
94213: NEG
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: PUSH
94222: LD_INT 0
94224: PUSH
94225: EMPTY
94226: LIST
94227: LIST
94228: PUSH
94229: LD_INT 1
94231: PUSH
94232: LD_INT 1
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 0
94241: PUSH
94242: LD_INT 1
94244: PUSH
94245: EMPTY
94246: LIST
94247: LIST
94248: PUSH
94249: LD_INT 1
94251: NEG
94252: PUSH
94253: LD_INT 0
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 1
94262: NEG
94263: PUSH
94264: LD_INT 1
94266: NEG
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 1
94274: NEG
94275: PUSH
94276: LD_INT 2
94278: NEG
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 0
94286: PUSH
94287: LD_INT 2
94289: NEG
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PUSH
94295: LD_INT 1
94297: PUSH
94298: LD_INT 1
94300: NEG
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 2
94308: PUSH
94309: LD_INT 0
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: LD_INT 2
94318: PUSH
94319: LD_INT 1
94321: PUSH
94322: EMPTY
94323: LIST
94324: LIST
94325: PUSH
94326: LD_INT 2
94328: PUSH
94329: LD_INT 2
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: PUSH
94336: LD_INT 1
94338: PUSH
94339: LD_INT 2
94341: PUSH
94342: EMPTY
94343: LIST
94344: LIST
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: LD_INT 2
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 1
94358: NEG
94359: PUSH
94360: LD_INT 1
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: PUSH
94367: LD_INT 2
94369: NEG
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 2
94380: NEG
94381: PUSH
94382: LD_INT 1
94384: NEG
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 2
94392: NEG
94393: PUSH
94394: LD_INT 2
94396: NEG
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94423: LD_ADDR_VAR 0 56
94427: PUSH
94428: LD_INT 0
94430: PUSH
94431: LD_INT 0
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PUSH
94438: LD_INT 0
94440: PUSH
94441: LD_INT 1
94443: NEG
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 1
94451: PUSH
94452: LD_INT 0
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 1
94461: PUSH
94462: LD_INT 1
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 0
94471: PUSH
94472: LD_INT 1
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 1
94481: NEG
94482: PUSH
94483: LD_INT 0
94485: PUSH
94486: EMPTY
94487: LIST
94488: LIST
94489: PUSH
94490: LD_INT 1
94492: NEG
94493: PUSH
94494: LD_INT 1
94496: NEG
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 1
94504: NEG
94505: PUSH
94506: LD_INT 2
94508: NEG
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 0
94516: PUSH
94517: LD_INT 2
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 1
94527: PUSH
94528: LD_INT 1
94530: NEG
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 2
94538: PUSH
94539: LD_INT 0
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 2
94548: PUSH
94549: LD_INT 1
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 2
94558: PUSH
94559: LD_INT 2
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 1
94568: PUSH
94569: LD_INT 2
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: LD_INT 2
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 1
94588: NEG
94589: PUSH
94590: LD_INT 1
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PUSH
94597: LD_INT 2
94599: NEG
94600: PUSH
94601: LD_INT 0
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: PUSH
94608: LD_INT 2
94610: NEG
94611: PUSH
94612: LD_INT 1
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: LD_INT 2
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94653: LD_ADDR_VAR 0 57
94657: PUSH
94658: LD_INT 0
94660: PUSH
94661: LD_INT 0
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 0
94670: PUSH
94671: LD_INT 1
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 1
94681: PUSH
94682: LD_INT 0
94684: PUSH
94685: EMPTY
94686: LIST
94687: LIST
94688: PUSH
94689: LD_INT 1
94691: PUSH
94692: LD_INT 1
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 0
94701: PUSH
94702: LD_INT 1
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: PUSH
94709: LD_INT 1
94711: NEG
94712: PUSH
94713: LD_INT 0
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 1
94722: NEG
94723: PUSH
94724: LD_INT 1
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 1
94734: NEG
94735: PUSH
94736: LD_INT 2
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 0
94746: PUSH
94747: LD_INT 2
94749: NEG
94750: PUSH
94751: EMPTY
94752: LIST
94753: LIST
94754: PUSH
94755: LD_INT 1
94757: PUSH
94758: LD_INT 1
94760: NEG
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: LD_INT 2
94768: PUSH
94769: LD_INT 0
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PUSH
94776: LD_INT 2
94778: PUSH
94779: LD_INT 1
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 2
94788: PUSH
94789: LD_INT 2
94791: PUSH
94792: EMPTY
94793: LIST
94794: LIST
94795: PUSH
94796: LD_INT 1
94798: PUSH
94799: LD_INT 2
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: LD_INT 0
94808: PUSH
94809: LD_INT 2
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 1
94818: NEG
94819: PUSH
94820: LD_INT 1
94822: PUSH
94823: EMPTY
94824: LIST
94825: LIST
94826: PUSH
94827: LD_INT 2
94829: NEG
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 2
94840: NEG
94841: PUSH
94842: LD_INT 1
94844: NEG
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 2
94852: NEG
94853: PUSH
94854: LD_INT 2
94856: NEG
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94883: LD_ADDR_VAR 0 58
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: LD_INT 0
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 0
94900: PUSH
94901: LD_INT 1
94903: NEG
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 1
94911: PUSH
94912: LD_INT 0
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 1
94921: PUSH
94922: LD_INT 1
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 0
94931: PUSH
94932: LD_INT 1
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: NEG
94942: PUSH
94943: LD_INT 0
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 1
94952: NEG
94953: PUSH
94954: LD_INT 1
94956: NEG
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 1
94964: NEG
94965: PUSH
94966: LD_INT 2
94968: NEG
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 0
94976: PUSH
94977: LD_INT 2
94979: NEG
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 1
94987: PUSH
94988: LD_INT 1
94990: NEG
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 2
94998: PUSH
94999: LD_INT 0
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 2
95008: PUSH
95009: LD_INT 1
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 2
95018: PUSH
95019: LD_INT 2
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: LD_INT 2
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 0
95038: PUSH
95039: LD_INT 2
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 1
95048: NEG
95049: PUSH
95050: LD_INT 1
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 2
95059: NEG
95060: PUSH
95061: LD_INT 0
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 2
95070: NEG
95071: PUSH
95072: LD_INT 1
95074: NEG
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: PUSH
95080: LD_INT 2
95082: NEG
95083: PUSH
95084: LD_INT 2
95086: NEG
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95113: LD_ADDR_VAR 0 59
95117: PUSH
95118: LD_INT 0
95120: PUSH
95121: LD_INT 0
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: PUSH
95128: LD_INT 0
95130: PUSH
95131: LD_INT 1
95133: NEG
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 1
95141: PUSH
95142: LD_INT 0
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: PUSH
95149: LD_INT 1
95151: PUSH
95152: LD_INT 1
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: LD_INT 0
95161: PUSH
95162: LD_INT 1
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: PUSH
95169: LD_INT 1
95171: NEG
95172: PUSH
95173: LD_INT 0
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 1
95182: NEG
95183: PUSH
95184: LD_INT 1
95186: NEG
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95201: LD_ADDR_VAR 0 60
95205: PUSH
95206: LD_INT 0
95208: PUSH
95209: LD_INT 0
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 0
95218: PUSH
95219: LD_INT 1
95221: NEG
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 1
95229: PUSH
95230: LD_INT 0
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 1
95239: PUSH
95240: LD_INT 1
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 0
95249: PUSH
95250: LD_INT 1
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 1
95259: NEG
95260: PUSH
95261: LD_INT 0
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 1
95270: NEG
95271: PUSH
95272: LD_INT 1
95274: NEG
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95289: LD_ADDR_VAR 0 61
95293: PUSH
95294: LD_INT 0
95296: PUSH
95297: LD_INT 0
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 0
95306: PUSH
95307: LD_INT 1
95309: NEG
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 1
95317: PUSH
95318: LD_INT 0
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 1
95327: PUSH
95328: LD_INT 1
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 0
95337: PUSH
95338: LD_INT 1
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 1
95347: NEG
95348: PUSH
95349: LD_INT 0
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 1
95358: NEG
95359: PUSH
95360: LD_INT 1
95362: NEG
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95377: LD_ADDR_VAR 0 62
95381: PUSH
95382: LD_INT 0
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: PUSH
95392: LD_INT 0
95394: PUSH
95395: LD_INT 1
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 1
95405: PUSH
95406: LD_INT 0
95408: PUSH
95409: EMPTY
95410: LIST
95411: LIST
95412: PUSH
95413: LD_INT 1
95415: PUSH
95416: LD_INT 1
95418: PUSH
95419: EMPTY
95420: LIST
95421: LIST
95422: PUSH
95423: LD_INT 0
95425: PUSH
95426: LD_INT 1
95428: PUSH
95429: EMPTY
95430: LIST
95431: LIST
95432: PUSH
95433: LD_INT 1
95435: NEG
95436: PUSH
95437: LD_INT 0
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: LD_INT 1
95446: NEG
95447: PUSH
95448: LD_INT 1
95450: NEG
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: EMPTY
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95465: LD_ADDR_VAR 0 63
95469: PUSH
95470: LD_INT 0
95472: PUSH
95473: LD_INT 0
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 0
95482: PUSH
95483: LD_INT 1
95485: NEG
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 1
95493: PUSH
95494: LD_INT 0
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 1
95503: PUSH
95504: LD_INT 1
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 0
95513: PUSH
95514: LD_INT 1
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 1
95523: NEG
95524: PUSH
95525: LD_INT 0
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: LD_INT 1
95534: NEG
95535: PUSH
95536: LD_INT 1
95538: NEG
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
95553: LD_ADDR_VAR 0 64
95557: PUSH
95558: LD_INT 0
95560: PUSH
95561: LD_INT 0
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 0
95570: PUSH
95571: LD_INT 1
95573: NEG
95574: PUSH
95575: EMPTY
95576: LIST
95577: LIST
95578: PUSH
95579: LD_INT 1
95581: PUSH
95582: LD_INT 0
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 1
95591: PUSH
95592: LD_INT 1
95594: PUSH
95595: EMPTY
95596: LIST
95597: LIST
95598: PUSH
95599: LD_INT 0
95601: PUSH
95602: LD_INT 1
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 1
95611: NEG
95612: PUSH
95613: LD_INT 0
95615: PUSH
95616: EMPTY
95617: LIST
95618: LIST
95619: PUSH
95620: LD_INT 1
95622: NEG
95623: PUSH
95624: LD_INT 1
95626: NEG
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: ST_TO_ADDR
// end ; 1 :
95641: GO 101538
95643: LD_INT 1
95645: DOUBLE
95646: EQUAL
95647: IFTRUE 95651
95649: GO 98274
95651: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95652: LD_ADDR_VAR 0 11
95656: PUSH
95657: LD_INT 1
95659: NEG
95660: PUSH
95661: LD_INT 3
95663: NEG
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: PUSH
95669: LD_INT 0
95671: PUSH
95672: LD_INT 3
95674: NEG
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 1
95682: PUSH
95683: LD_INT 2
95685: NEG
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: LIST
95695: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95696: LD_ADDR_VAR 0 12
95700: PUSH
95701: LD_INT 2
95703: PUSH
95704: LD_INT 1
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 3
95714: PUSH
95715: LD_INT 0
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: PUSH
95722: LD_INT 3
95724: PUSH
95725: LD_INT 1
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: LIST
95736: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95737: LD_ADDR_VAR 0 13
95741: PUSH
95742: LD_INT 3
95744: PUSH
95745: LD_INT 2
95747: PUSH
95748: EMPTY
95749: LIST
95750: LIST
95751: PUSH
95752: LD_INT 3
95754: PUSH
95755: LD_INT 3
95757: PUSH
95758: EMPTY
95759: LIST
95760: LIST
95761: PUSH
95762: LD_INT 2
95764: PUSH
95765: LD_INT 3
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: EMPTY
95773: LIST
95774: LIST
95775: LIST
95776: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95777: LD_ADDR_VAR 0 14
95781: PUSH
95782: LD_INT 1
95784: PUSH
95785: LD_INT 3
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 0
95794: PUSH
95795: LD_INT 3
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 1
95804: NEG
95805: PUSH
95806: LD_INT 2
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: PUSH
95813: EMPTY
95814: LIST
95815: LIST
95816: LIST
95817: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95818: LD_ADDR_VAR 0 15
95822: PUSH
95823: LD_INT 2
95825: NEG
95826: PUSH
95827: LD_INT 1
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: LD_INT 3
95836: NEG
95837: PUSH
95838: LD_INT 0
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 3
95847: NEG
95848: PUSH
95849: LD_INT 1
95851: NEG
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: LIST
95861: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95862: LD_ADDR_VAR 0 16
95866: PUSH
95867: LD_INT 2
95869: NEG
95870: PUSH
95871: LD_INT 3
95873: NEG
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 3
95881: NEG
95882: PUSH
95883: LD_INT 2
95885: NEG
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: PUSH
95891: LD_INT 3
95893: NEG
95894: PUSH
95895: LD_INT 3
95897: NEG
95898: PUSH
95899: EMPTY
95900: LIST
95901: LIST
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: LIST
95907: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95908: LD_ADDR_VAR 0 17
95912: PUSH
95913: LD_INT 1
95915: NEG
95916: PUSH
95917: LD_INT 3
95919: NEG
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 0
95927: PUSH
95928: LD_INT 3
95930: NEG
95931: PUSH
95932: EMPTY
95933: LIST
95934: LIST
95935: PUSH
95936: LD_INT 1
95938: PUSH
95939: LD_INT 2
95941: NEG
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: LIST
95951: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95952: LD_ADDR_VAR 0 18
95956: PUSH
95957: LD_INT 2
95959: PUSH
95960: LD_INT 1
95962: NEG
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 3
95970: PUSH
95971: LD_INT 0
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 3
95980: PUSH
95981: LD_INT 1
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: LIST
95992: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95993: LD_ADDR_VAR 0 19
95997: PUSH
95998: LD_INT 3
96000: PUSH
96001: LD_INT 2
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 3
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: LD_INT 2
96020: PUSH
96021: LD_INT 3
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: LIST
96032: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96033: LD_ADDR_VAR 0 20
96037: PUSH
96038: LD_INT 1
96040: PUSH
96041: LD_INT 3
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 0
96050: PUSH
96051: LD_INT 3
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 1
96060: NEG
96061: PUSH
96062: LD_INT 2
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: LIST
96073: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96074: LD_ADDR_VAR 0 21
96078: PUSH
96079: LD_INT 2
96081: NEG
96082: PUSH
96083: LD_INT 1
96085: PUSH
96086: EMPTY
96087: LIST
96088: LIST
96089: PUSH
96090: LD_INT 3
96092: NEG
96093: PUSH
96094: LD_INT 0
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: PUSH
96101: LD_INT 3
96103: NEG
96104: PUSH
96105: LD_INT 1
96107: NEG
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: LIST
96117: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96118: LD_ADDR_VAR 0 22
96122: PUSH
96123: LD_INT 2
96125: NEG
96126: PUSH
96127: LD_INT 3
96129: NEG
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: PUSH
96135: LD_INT 3
96137: NEG
96138: PUSH
96139: LD_INT 2
96141: NEG
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PUSH
96147: LD_INT 3
96149: NEG
96150: PUSH
96151: LD_INT 3
96153: NEG
96154: PUSH
96155: EMPTY
96156: LIST
96157: LIST
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: LIST
96163: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
96164: LD_ADDR_VAR 0 23
96168: PUSH
96169: LD_INT 0
96171: PUSH
96172: LD_INT 3
96174: NEG
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 1
96182: NEG
96183: PUSH
96184: LD_INT 4
96186: NEG
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 1
96194: PUSH
96195: LD_INT 3
96197: NEG
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: EMPTY
96204: LIST
96205: LIST
96206: LIST
96207: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
96208: LD_ADDR_VAR 0 24
96212: PUSH
96213: LD_INT 3
96215: PUSH
96216: LD_INT 0
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 3
96225: PUSH
96226: LD_INT 1
96228: NEG
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: PUSH
96234: LD_INT 4
96236: PUSH
96237: LD_INT 1
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: LIST
96248: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
96249: LD_ADDR_VAR 0 25
96253: PUSH
96254: LD_INT 3
96256: PUSH
96257: LD_INT 3
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 4
96266: PUSH
96267: LD_INT 3
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 3
96276: PUSH
96277: LD_INT 4
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: LIST
96288: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
96289: LD_ADDR_VAR 0 26
96293: PUSH
96294: LD_INT 0
96296: PUSH
96297: LD_INT 3
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: LD_INT 1
96306: PUSH
96307: LD_INT 4
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 1
96316: NEG
96317: PUSH
96318: LD_INT 3
96320: PUSH
96321: EMPTY
96322: LIST
96323: LIST
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: LIST
96329: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
96330: LD_ADDR_VAR 0 27
96334: PUSH
96335: LD_INT 3
96337: NEG
96338: PUSH
96339: LD_INT 0
96341: PUSH
96342: EMPTY
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 3
96348: NEG
96349: PUSH
96350: LD_INT 1
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: PUSH
96357: LD_INT 4
96359: NEG
96360: PUSH
96361: LD_INT 1
96363: NEG
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: LIST
96373: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
96374: LD_ADDR_VAR 0 28
96378: PUSH
96379: LD_INT 3
96381: NEG
96382: PUSH
96383: LD_INT 3
96385: NEG
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: LD_INT 3
96393: NEG
96394: PUSH
96395: LD_INT 4
96397: NEG
96398: PUSH
96399: EMPTY
96400: LIST
96401: LIST
96402: PUSH
96403: LD_INT 4
96405: NEG
96406: PUSH
96407: LD_INT 3
96409: NEG
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: LIST
96419: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
96420: LD_ADDR_VAR 0 29
96424: PUSH
96425: LD_INT 1
96427: NEG
96428: PUSH
96429: LD_INT 3
96431: NEG
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 0
96439: PUSH
96440: LD_INT 3
96442: NEG
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 1
96450: PUSH
96451: LD_INT 2
96453: NEG
96454: PUSH
96455: EMPTY
96456: LIST
96457: LIST
96458: PUSH
96459: LD_INT 1
96461: NEG
96462: PUSH
96463: LD_INT 4
96465: NEG
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 0
96473: PUSH
96474: LD_INT 4
96476: NEG
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 1
96484: PUSH
96485: LD_INT 3
96487: NEG
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 1
96495: NEG
96496: PUSH
96497: LD_INT 5
96499: NEG
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: PUSH
96505: LD_INT 0
96507: PUSH
96508: LD_INT 5
96510: NEG
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 1
96518: PUSH
96519: LD_INT 4
96521: NEG
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 1
96529: NEG
96530: PUSH
96531: LD_INT 6
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 0
96541: PUSH
96542: LD_INT 6
96544: NEG
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 1
96552: PUSH
96553: LD_INT 5
96555: NEG
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
96575: LD_ADDR_VAR 0 30
96579: PUSH
96580: LD_INT 2
96582: PUSH
96583: LD_INT 1
96585: NEG
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 3
96593: PUSH
96594: LD_INT 0
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: LD_INT 3
96603: PUSH
96604: LD_INT 1
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: PUSH
96611: LD_INT 3
96613: PUSH
96614: LD_INT 1
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 4
96624: PUSH
96625: LD_INT 0
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 4
96634: PUSH
96635: LD_INT 1
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 4
96644: PUSH
96645: LD_INT 1
96647: NEG
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 5
96655: PUSH
96656: LD_INT 0
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 5
96665: PUSH
96666: LD_INT 1
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: PUSH
96673: LD_INT 5
96675: PUSH
96676: LD_INT 1
96678: NEG
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 6
96686: PUSH
96687: LD_INT 0
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 6
96696: PUSH
96697: LD_INT 1
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: PUSH
96704: EMPTY
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
96718: LD_ADDR_VAR 0 31
96722: PUSH
96723: LD_INT 3
96725: PUSH
96726: LD_INT 2
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 3
96735: PUSH
96736: LD_INT 3
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: PUSH
96743: LD_INT 2
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: PUSH
96753: LD_INT 4
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PUSH
96763: LD_INT 4
96765: PUSH
96766: LD_INT 4
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 3
96775: PUSH
96776: LD_INT 4
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: PUSH
96783: LD_INT 5
96785: PUSH
96786: LD_INT 4
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PUSH
96793: LD_INT 5
96795: PUSH
96796: LD_INT 5
96798: PUSH
96799: EMPTY
96800: LIST
96801: LIST
96802: PUSH
96803: LD_INT 4
96805: PUSH
96806: LD_INT 5
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: PUSH
96813: LD_INT 6
96815: PUSH
96816: LD_INT 5
96818: PUSH
96819: EMPTY
96820: LIST
96821: LIST
96822: PUSH
96823: LD_INT 6
96825: PUSH
96826: LD_INT 6
96828: PUSH
96829: EMPTY
96830: LIST
96831: LIST
96832: PUSH
96833: LD_INT 5
96835: PUSH
96836: LD_INT 6
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
96857: LD_ADDR_VAR 0 32
96861: PUSH
96862: LD_INT 1
96864: PUSH
96865: LD_INT 3
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: PUSH
96872: LD_INT 0
96874: PUSH
96875: LD_INT 3
96877: PUSH
96878: EMPTY
96879: LIST
96880: LIST
96881: PUSH
96882: LD_INT 1
96884: NEG
96885: PUSH
96886: LD_INT 2
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: PUSH
96893: LD_INT 1
96895: PUSH
96896: LD_INT 4
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 0
96905: PUSH
96906: LD_INT 4
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 1
96915: NEG
96916: PUSH
96917: LD_INT 3
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PUSH
96924: LD_INT 1
96926: PUSH
96927: LD_INT 5
96929: PUSH
96930: EMPTY
96931: LIST
96932: LIST
96933: PUSH
96934: LD_INT 0
96936: PUSH
96937: LD_INT 5
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: PUSH
96944: LD_INT 1
96946: NEG
96947: PUSH
96948: LD_INT 4
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 1
96957: PUSH
96958: LD_INT 6
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 0
96967: PUSH
96968: LD_INT 6
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 1
96977: NEG
96978: PUSH
96979: LD_INT 5
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
97000: LD_ADDR_VAR 0 33
97004: PUSH
97005: LD_INT 2
97007: NEG
97008: PUSH
97009: LD_INT 1
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: PUSH
97016: LD_INT 3
97018: NEG
97019: PUSH
97020: LD_INT 0
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 3
97029: NEG
97030: PUSH
97031: LD_INT 1
97033: NEG
97034: PUSH
97035: EMPTY
97036: LIST
97037: LIST
97038: PUSH
97039: LD_INT 3
97041: NEG
97042: PUSH
97043: LD_INT 1
97045: PUSH
97046: EMPTY
97047: LIST
97048: LIST
97049: PUSH
97050: LD_INT 4
97052: NEG
97053: PUSH
97054: LD_INT 0
97056: PUSH
97057: EMPTY
97058: LIST
97059: LIST
97060: PUSH
97061: LD_INT 4
97063: NEG
97064: PUSH
97065: LD_INT 1
97067: NEG
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 4
97075: NEG
97076: PUSH
97077: LD_INT 1
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 5
97086: NEG
97087: PUSH
97088: LD_INT 0
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 5
97097: NEG
97098: PUSH
97099: LD_INT 1
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 5
97109: NEG
97110: PUSH
97111: LD_INT 1
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 6
97120: NEG
97121: PUSH
97122: LD_INT 0
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 6
97131: NEG
97132: PUSH
97133: LD_INT 1
97135: NEG
97136: PUSH
97137: EMPTY
97138: LIST
97139: LIST
97140: PUSH
97141: EMPTY
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
97155: LD_ADDR_VAR 0 34
97159: PUSH
97160: LD_INT 2
97162: NEG
97163: PUSH
97164: LD_INT 3
97166: NEG
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: PUSH
97172: LD_INT 3
97174: NEG
97175: PUSH
97176: LD_INT 2
97178: NEG
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: LD_INT 3
97186: NEG
97187: PUSH
97188: LD_INT 3
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 3
97198: NEG
97199: PUSH
97200: LD_INT 4
97202: NEG
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PUSH
97208: LD_INT 4
97210: NEG
97211: PUSH
97212: LD_INT 3
97214: NEG
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 4
97222: NEG
97223: PUSH
97224: LD_INT 4
97226: NEG
97227: PUSH
97228: EMPTY
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 4
97234: NEG
97235: PUSH
97236: LD_INT 5
97238: NEG
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: LD_INT 5
97246: NEG
97247: PUSH
97248: LD_INT 4
97250: NEG
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 5
97258: NEG
97259: PUSH
97260: LD_INT 5
97262: NEG
97263: PUSH
97264: EMPTY
97265: LIST
97266: LIST
97267: PUSH
97268: LD_INT 5
97270: NEG
97271: PUSH
97272: LD_INT 6
97274: NEG
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 6
97282: NEG
97283: PUSH
97284: LD_INT 5
97286: NEG
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PUSH
97292: LD_INT 6
97294: NEG
97295: PUSH
97296: LD_INT 6
97298: NEG
97299: PUSH
97300: EMPTY
97301: LIST
97302: LIST
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: LIST
97317: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
97318: LD_ADDR_VAR 0 41
97322: PUSH
97323: LD_INT 0
97325: PUSH
97326: LD_INT 2
97328: NEG
97329: PUSH
97330: EMPTY
97331: LIST
97332: LIST
97333: PUSH
97334: LD_INT 1
97336: NEG
97337: PUSH
97338: LD_INT 3
97340: NEG
97341: PUSH
97342: EMPTY
97343: LIST
97344: LIST
97345: PUSH
97346: LD_INT 1
97348: PUSH
97349: LD_INT 2
97351: NEG
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: LIST
97361: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
97362: LD_ADDR_VAR 0 42
97366: PUSH
97367: LD_INT 2
97369: PUSH
97370: LD_INT 0
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: PUSH
97377: LD_INT 2
97379: PUSH
97380: LD_INT 1
97382: NEG
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 3
97390: PUSH
97391: LD_INT 1
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: EMPTY
97399: LIST
97400: LIST
97401: LIST
97402: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
97403: LD_ADDR_VAR 0 43
97407: PUSH
97408: LD_INT 2
97410: PUSH
97411: LD_INT 2
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 3
97420: PUSH
97421: LD_INT 2
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: LD_INT 2
97430: PUSH
97431: LD_INT 3
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: LIST
97442: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
97443: LD_ADDR_VAR 0 44
97447: PUSH
97448: LD_INT 0
97450: PUSH
97451: LD_INT 2
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 1
97460: PUSH
97461: LD_INT 3
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: LD_INT 1
97470: NEG
97471: PUSH
97472: LD_INT 2
97474: PUSH
97475: EMPTY
97476: LIST
97477: LIST
97478: PUSH
97479: EMPTY
97480: LIST
97481: LIST
97482: LIST
97483: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
97484: LD_ADDR_VAR 0 45
97488: PUSH
97489: LD_INT 2
97491: NEG
97492: PUSH
97493: LD_INT 0
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 2
97502: NEG
97503: PUSH
97504: LD_INT 1
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 3
97513: NEG
97514: PUSH
97515: LD_INT 1
97517: NEG
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: EMPTY
97524: LIST
97525: LIST
97526: LIST
97527: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
97528: LD_ADDR_VAR 0 46
97532: PUSH
97533: LD_INT 2
97535: NEG
97536: PUSH
97537: LD_INT 2
97539: NEG
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: PUSH
97545: LD_INT 2
97547: NEG
97548: PUSH
97549: LD_INT 3
97551: NEG
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: PUSH
97557: LD_INT 3
97559: NEG
97560: PUSH
97561: LD_INT 2
97563: NEG
97564: PUSH
97565: EMPTY
97566: LIST
97567: LIST
97568: PUSH
97569: EMPTY
97570: LIST
97571: LIST
97572: LIST
97573: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
97574: LD_ADDR_VAR 0 47
97578: PUSH
97579: LD_INT 2
97581: NEG
97582: PUSH
97583: LD_INT 3
97585: NEG
97586: PUSH
97587: EMPTY
97588: LIST
97589: LIST
97590: PUSH
97591: LD_INT 1
97593: NEG
97594: PUSH
97595: LD_INT 3
97597: NEG
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
97607: LD_ADDR_VAR 0 48
97611: PUSH
97612: LD_INT 1
97614: PUSH
97615: LD_INT 2
97617: NEG
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: PUSH
97623: LD_INT 2
97625: PUSH
97626: LD_INT 1
97628: NEG
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
97638: LD_ADDR_VAR 0 49
97642: PUSH
97643: LD_INT 3
97645: PUSH
97646: LD_INT 1
97648: PUSH
97649: EMPTY
97650: LIST
97651: LIST
97652: PUSH
97653: LD_INT 3
97655: PUSH
97656: LD_INT 2
97658: PUSH
97659: EMPTY
97660: LIST
97661: LIST
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
97667: LD_ADDR_VAR 0 50
97671: PUSH
97672: LD_INT 2
97674: PUSH
97675: LD_INT 3
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 1
97684: PUSH
97685: LD_INT 3
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
97696: LD_ADDR_VAR 0 51
97700: PUSH
97701: LD_INT 1
97703: NEG
97704: PUSH
97705: LD_INT 2
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: PUSH
97712: LD_INT 2
97714: NEG
97715: PUSH
97716: LD_INT 1
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
97727: LD_ADDR_VAR 0 52
97731: PUSH
97732: LD_INT 3
97734: NEG
97735: PUSH
97736: LD_INT 1
97738: NEG
97739: PUSH
97740: EMPTY
97741: LIST
97742: LIST
97743: PUSH
97744: LD_INT 3
97746: NEG
97747: PUSH
97748: LD_INT 2
97750: NEG
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: EMPTY
97757: LIST
97758: LIST
97759: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97760: LD_ADDR_VAR 0 53
97764: PUSH
97765: LD_INT 1
97767: NEG
97768: PUSH
97769: LD_INT 3
97771: NEG
97772: PUSH
97773: EMPTY
97774: LIST
97775: LIST
97776: PUSH
97777: LD_INT 0
97779: PUSH
97780: LD_INT 3
97782: NEG
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 1
97790: PUSH
97791: LD_INT 2
97793: NEG
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: PUSH
97799: EMPTY
97800: LIST
97801: LIST
97802: LIST
97803: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97804: LD_ADDR_VAR 0 54
97808: PUSH
97809: LD_INT 2
97811: PUSH
97812: LD_INT 1
97814: NEG
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: LD_INT 3
97822: PUSH
97823: LD_INT 0
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 3
97832: PUSH
97833: LD_INT 1
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: EMPTY
97841: LIST
97842: LIST
97843: LIST
97844: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97845: LD_ADDR_VAR 0 55
97849: PUSH
97850: LD_INT 3
97852: PUSH
97853: LD_INT 2
97855: PUSH
97856: EMPTY
97857: LIST
97858: LIST
97859: PUSH
97860: LD_INT 3
97862: PUSH
97863: LD_INT 3
97865: PUSH
97866: EMPTY
97867: LIST
97868: LIST
97869: PUSH
97870: LD_INT 2
97872: PUSH
97873: LD_INT 3
97875: PUSH
97876: EMPTY
97877: LIST
97878: LIST
97879: PUSH
97880: EMPTY
97881: LIST
97882: LIST
97883: LIST
97884: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97885: LD_ADDR_VAR 0 56
97889: PUSH
97890: LD_INT 1
97892: PUSH
97893: LD_INT 3
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PUSH
97900: LD_INT 0
97902: PUSH
97903: LD_INT 3
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 1
97912: NEG
97913: PUSH
97914: LD_INT 2
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: LIST
97925: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97926: LD_ADDR_VAR 0 57
97930: PUSH
97931: LD_INT 2
97933: NEG
97934: PUSH
97935: LD_INT 1
97937: PUSH
97938: EMPTY
97939: LIST
97940: LIST
97941: PUSH
97942: LD_INT 3
97944: NEG
97945: PUSH
97946: LD_INT 0
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PUSH
97953: LD_INT 3
97955: NEG
97956: PUSH
97957: LD_INT 1
97959: NEG
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: LIST
97969: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97970: LD_ADDR_VAR 0 58
97974: PUSH
97975: LD_INT 2
97977: NEG
97978: PUSH
97979: LD_INT 3
97981: NEG
97982: PUSH
97983: EMPTY
97984: LIST
97985: LIST
97986: PUSH
97987: LD_INT 3
97989: NEG
97990: PUSH
97991: LD_INT 2
97993: NEG
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PUSH
97999: LD_INT 3
98001: NEG
98002: PUSH
98003: LD_INT 3
98005: NEG
98006: PUSH
98007: EMPTY
98008: LIST
98009: LIST
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: LIST
98015: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
98016: LD_ADDR_VAR 0 59
98020: PUSH
98021: LD_INT 1
98023: NEG
98024: PUSH
98025: LD_INT 2
98027: NEG
98028: PUSH
98029: EMPTY
98030: LIST
98031: LIST
98032: PUSH
98033: LD_INT 0
98035: PUSH
98036: LD_INT 2
98038: NEG
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: LD_INT 1
98046: PUSH
98047: LD_INT 1
98049: NEG
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: EMPTY
98056: LIST
98057: LIST
98058: LIST
98059: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
98060: LD_ADDR_VAR 0 60
98064: PUSH
98065: LD_INT 1
98067: PUSH
98068: LD_INT 1
98070: NEG
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: LD_INT 2
98078: PUSH
98079: LD_INT 0
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PUSH
98086: LD_INT 2
98088: PUSH
98089: LD_INT 1
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: LIST
98100: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
98101: LD_ADDR_VAR 0 61
98105: PUSH
98106: LD_INT 2
98108: PUSH
98109: LD_INT 1
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: LD_INT 2
98118: PUSH
98119: LD_INT 2
98121: PUSH
98122: EMPTY
98123: LIST
98124: LIST
98125: PUSH
98126: LD_INT 1
98128: PUSH
98129: LD_INT 2
98131: PUSH
98132: EMPTY
98133: LIST
98134: LIST
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: LIST
98140: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
98141: LD_ADDR_VAR 0 62
98145: PUSH
98146: LD_INT 1
98148: PUSH
98149: LD_INT 2
98151: PUSH
98152: EMPTY
98153: LIST
98154: LIST
98155: PUSH
98156: LD_INT 0
98158: PUSH
98159: LD_INT 2
98161: PUSH
98162: EMPTY
98163: LIST
98164: LIST
98165: PUSH
98166: LD_INT 1
98168: NEG
98169: PUSH
98170: LD_INT 1
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: LIST
98181: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
98182: LD_ADDR_VAR 0 63
98186: PUSH
98187: LD_INT 1
98189: NEG
98190: PUSH
98191: LD_INT 1
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: PUSH
98198: LD_INT 2
98200: NEG
98201: PUSH
98202: LD_INT 0
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: PUSH
98209: LD_INT 2
98211: NEG
98212: PUSH
98213: LD_INT 1
98215: NEG
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: LIST
98225: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
98226: LD_ADDR_VAR 0 64
98230: PUSH
98231: LD_INT 1
98233: NEG
98234: PUSH
98235: LD_INT 2
98237: NEG
98238: PUSH
98239: EMPTY
98240: LIST
98241: LIST
98242: PUSH
98243: LD_INT 2
98245: NEG
98246: PUSH
98247: LD_INT 1
98249: NEG
98250: PUSH
98251: EMPTY
98252: LIST
98253: LIST
98254: PUSH
98255: LD_INT 2
98257: NEG
98258: PUSH
98259: LD_INT 2
98261: NEG
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: LIST
98271: ST_TO_ADDR
// end ; 2 :
98272: GO 101538
98274: LD_INT 2
98276: DOUBLE
98277: EQUAL
98278: IFTRUE 98282
98280: GO 101537
98282: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
98283: LD_ADDR_VAR 0 29
98287: PUSH
98288: LD_INT 4
98290: PUSH
98291: LD_INT 0
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: PUSH
98298: LD_INT 4
98300: PUSH
98301: LD_INT 1
98303: NEG
98304: PUSH
98305: EMPTY
98306: LIST
98307: LIST
98308: PUSH
98309: LD_INT 5
98311: PUSH
98312: LD_INT 0
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: PUSH
98319: LD_INT 5
98321: PUSH
98322: LD_INT 1
98324: PUSH
98325: EMPTY
98326: LIST
98327: LIST
98328: PUSH
98329: LD_INT 4
98331: PUSH
98332: LD_INT 1
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PUSH
98339: LD_INT 3
98341: PUSH
98342: LD_INT 0
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 3
98351: PUSH
98352: LD_INT 1
98354: NEG
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: PUSH
98360: LD_INT 3
98362: PUSH
98363: LD_INT 2
98365: NEG
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 5
98373: PUSH
98374: LD_INT 2
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PUSH
98381: LD_INT 3
98383: PUSH
98384: LD_INT 3
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 3
98393: PUSH
98394: LD_INT 2
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 4
98403: PUSH
98404: LD_INT 3
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 4
98413: PUSH
98414: LD_INT 4
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: LD_INT 3
98423: PUSH
98424: LD_INT 4
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PUSH
98431: LD_INT 2
98433: PUSH
98434: LD_INT 3
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: PUSH
98441: LD_INT 2
98443: PUSH
98444: LD_INT 2
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: PUSH
98451: LD_INT 4
98453: PUSH
98454: LD_INT 2
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PUSH
98461: LD_INT 2
98463: PUSH
98464: LD_INT 4
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 0
98473: PUSH
98474: LD_INT 4
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: LD_INT 0
98483: PUSH
98484: LD_INT 3
98486: PUSH
98487: EMPTY
98488: LIST
98489: LIST
98490: PUSH
98491: LD_INT 1
98493: PUSH
98494: LD_INT 4
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PUSH
98501: LD_INT 1
98503: PUSH
98504: LD_INT 5
98506: PUSH
98507: EMPTY
98508: LIST
98509: LIST
98510: PUSH
98511: LD_INT 0
98513: PUSH
98514: LD_INT 5
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: PUSH
98521: LD_INT 1
98523: NEG
98524: PUSH
98525: LD_INT 4
98527: PUSH
98528: EMPTY
98529: LIST
98530: LIST
98531: PUSH
98532: LD_INT 1
98534: NEG
98535: PUSH
98536: LD_INT 3
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: PUSH
98543: LD_INT 2
98545: PUSH
98546: LD_INT 5
98548: PUSH
98549: EMPTY
98550: LIST
98551: LIST
98552: PUSH
98553: LD_INT 2
98555: NEG
98556: PUSH
98557: LD_INT 3
98559: PUSH
98560: EMPTY
98561: LIST
98562: LIST
98563: PUSH
98564: LD_INT 3
98566: NEG
98567: PUSH
98568: LD_INT 0
98570: PUSH
98571: EMPTY
98572: LIST
98573: LIST
98574: PUSH
98575: LD_INT 3
98577: NEG
98578: PUSH
98579: LD_INT 1
98581: NEG
98582: PUSH
98583: EMPTY
98584: LIST
98585: LIST
98586: PUSH
98587: LD_INT 2
98589: NEG
98590: PUSH
98591: LD_INT 0
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 2
98600: NEG
98601: PUSH
98602: LD_INT 1
98604: PUSH
98605: EMPTY
98606: LIST
98607: LIST
98608: PUSH
98609: LD_INT 3
98611: NEG
98612: PUSH
98613: LD_INT 1
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: PUSH
98620: LD_INT 4
98622: NEG
98623: PUSH
98624: LD_INT 0
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: LD_INT 4
98633: NEG
98634: PUSH
98635: LD_INT 1
98637: NEG
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: PUSH
98643: LD_INT 4
98645: NEG
98646: PUSH
98647: LD_INT 2
98649: NEG
98650: PUSH
98651: EMPTY
98652: LIST
98653: LIST
98654: PUSH
98655: LD_INT 2
98657: NEG
98658: PUSH
98659: LD_INT 2
98661: PUSH
98662: EMPTY
98663: LIST
98664: LIST
98665: PUSH
98666: LD_INT 4
98668: NEG
98669: PUSH
98670: LD_INT 4
98672: NEG
98673: PUSH
98674: EMPTY
98675: LIST
98676: LIST
98677: PUSH
98678: LD_INT 4
98680: NEG
98681: PUSH
98682: LD_INT 5
98684: NEG
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 3
98692: NEG
98693: PUSH
98694: LD_INT 4
98696: NEG
98697: PUSH
98698: EMPTY
98699: LIST
98700: LIST
98701: PUSH
98702: LD_INT 3
98704: NEG
98705: PUSH
98706: LD_INT 3
98708: NEG
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: PUSH
98714: LD_INT 4
98716: NEG
98717: PUSH
98718: LD_INT 3
98720: NEG
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: PUSH
98726: LD_INT 5
98728: NEG
98729: PUSH
98730: LD_INT 4
98732: NEG
98733: PUSH
98734: EMPTY
98735: LIST
98736: LIST
98737: PUSH
98738: LD_INT 5
98740: NEG
98741: PUSH
98742: LD_INT 5
98744: NEG
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PUSH
98750: LD_INT 3
98752: NEG
98753: PUSH
98754: LD_INT 5
98756: NEG
98757: PUSH
98758: EMPTY
98759: LIST
98760: LIST
98761: PUSH
98762: LD_INT 5
98764: NEG
98765: PUSH
98766: LD_INT 3
98768: NEG
98769: PUSH
98770: EMPTY
98771: LIST
98772: LIST
98773: PUSH
98774: EMPTY
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
98821: LD_ADDR_VAR 0 30
98825: PUSH
98826: LD_INT 4
98828: PUSH
98829: LD_INT 4
98831: PUSH
98832: EMPTY
98833: LIST
98834: LIST
98835: PUSH
98836: LD_INT 4
98838: PUSH
98839: LD_INT 3
98841: PUSH
98842: EMPTY
98843: LIST
98844: LIST
98845: PUSH
98846: LD_INT 5
98848: PUSH
98849: LD_INT 4
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 5
98858: PUSH
98859: LD_INT 5
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: PUSH
98866: LD_INT 4
98868: PUSH
98869: LD_INT 5
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: PUSH
98876: LD_INT 3
98878: PUSH
98879: LD_INT 4
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: PUSH
98886: LD_INT 3
98888: PUSH
98889: LD_INT 3
98891: PUSH
98892: EMPTY
98893: LIST
98894: LIST
98895: PUSH
98896: LD_INT 5
98898: PUSH
98899: LD_INT 3
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: LD_INT 3
98908: PUSH
98909: LD_INT 5
98911: PUSH
98912: EMPTY
98913: LIST
98914: LIST
98915: PUSH
98916: LD_INT 0
98918: PUSH
98919: LD_INT 3
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: PUSH
98926: LD_INT 0
98928: PUSH
98929: LD_INT 2
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: PUSH
98936: LD_INT 1
98938: PUSH
98939: LD_INT 3
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 1
98948: PUSH
98949: LD_INT 4
98951: PUSH
98952: EMPTY
98953: LIST
98954: LIST
98955: PUSH
98956: LD_INT 0
98958: PUSH
98959: LD_INT 4
98961: PUSH
98962: EMPTY
98963: LIST
98964: LIST
98965: PUSH
98966: LD_INT 1
98968: NEG
98969: PUSH
98970: LD_INT 3
98972: PUSH
98973: EMPTY
98974: LIST
98975: LIST
98976: PUSH
98977: LD_INT 1
98979: NEG
98980: PUSH
98981: LD_INT 2
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: LD_INT 2
98990: PUSH
98991: LD_INT 4
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: PUSH
98998: LD_INT 2
99000: NEG
99001: PUSH
99002: LD_INT 2
99004: PUSH
99005: EMPTY
99006: LIST
99007: LIST
99008: PUSH
99009: LD_INT 4
99011: NEG
99012: PUSH
99013: LD_INT 0
99015: PUSH
99016: EMPTY
99017: LIST
99018: LIST
99019: PUSH
99020: LD_INT 4
99022: NEG
99023: PUSH
99024: LD_INT 1
99026: NEG
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: PUSH
99032: LD_INT 3
99034: NEG
99035: PUSH
99036: LD_INT 0
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PUSH
99043: LD_INT 3
99045: NEG
99046: PUSH
99047: LD_INT 1
99049: PUSH
99050: EMPTY
99051: LIST
99052: LIST
99053: PUSH
99054: LD_INT 4
99056: NEG
99057: PUSH
99058: LD_INT 1
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: PUSH
99065: LD_INT 5
99067: NEG
99068: PUSH
99069: LD_INT 0
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: LD_INT 5
99078: NEG
99079: PUSH
99080: LD_INT 1
99082: NEG
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PUSH
99088: LD_INT 5
99090: NEG
99091: PUSH
99092: LD_INT 2
99094: NEG
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: LD_INT 3
99102: NEG
99103: PUSH
99104: LD_INT 2
99106: PUSH
99107: EMPTY
99108: LIST
99109: LIST
99110: PUSH
99111: LD_INT 3
99113: NEG
99114: PUSH
99115: LD_INT 3
99117: NEG
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: LD_INT 3
99125: NEG
99126: PUSH
99127: LD_INT 4
99129: NEG
99130: PUSH
99131: EMPTY
99132: LIST
99133: LIST
99134: PUSH
99135: LD_INT 2
99137: NEG
99138: PUSH
99139: LD_INT 3
99141: NEG
99142: PUSH
99143: EMPTY
99144: LIST
99145: LIST
99146: PUSH
99147: LD_INT 2
99149: NEG
99150: PUSH
99151: LD_INT 2
99153: NEG
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: LD_INT 3
99161: NEG
99162: PUSH
99163: LD_INT 2
99165: NEG
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: PUSH
99171: LD_INT 4
99173: NEG
99174: PUSH
99175: LD_INT 3
99177: NEG
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PUSH
99183: LD_INT 4
99185: NEG
99186: PUSH
99187: LD_INT 4
99189: NEG
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 2
99197: NEG
99198: PUSH
99199: LD_INT 4
99201: NEG
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: PUSH
99207: LD_INT 4
99209: NEG
99210: PUSH
99211: LD_INT 2
99213: NEG
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: LD_INT 0
99221: PUSH
99222: LD_INT 4
99224: NEG
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: LD_INT 0
99232: PUSH
99233: LD_INT 5
99235: NEG
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: LD_INT 1
99243: PUSH
99244: LD_INT 4
99246: NEG
99247: PUSH
99248: EMPTY
99249: LIST
99250: LIST
99251: PUSH
99252: LD_INT 1
99254: PUSH
99255: LD_INT 3
99257: NEG
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PUSH
99263: LD_INT 0
99265: PUSH
99266: LD_INT 3
99268: NEG
99269: PUSH
99270: EMPTY
99271: LIST
99272: LIST
99273: PUSH
99274: LD_INT 1
99276: NEG
99277: PUSH
99278: LD_INT 4
99280: NEG
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PUSH
99286: LD_INT 1
99288: NEG
99289: PUSH
99290: LD_INT 5
99292: NEG
99293: PUSH
99294: EMPTY
99295: LIST
99296: LIST
99297: PUSH
99298: LD_INT 2
99300: PUSH
99301: LD_INT 3
99303: NEG
99304: PUSH
99305: EMPTY
99306: LIST
99307: LIST
99308: PUSH
99309: LD_INT 2
99311: NEG
99312: PUSH
99313: LD_INT 5
99315: NEG
99316: PUSH
99317: EMPTY
99318: LIST
99319: LIST
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
99368: LD_ADDR_VAR 0 31
99372: PUSH
99373: LD_INT 0
99375: PUSH
99376: LD_INT 4
99378: PUSH
99379: EMPTY
99380: LIST
99381: LIST
99382: PUSH
99383: LD_INT 0
99385: PUSH
99386: LD_INT 3
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: PUSH
99393: LD_INT 1
99395: PUSH
99396: LD_INT 4
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: LD_INT 1
99405: PUSH
99406: LD_INT 5
99408: PUSH
99409: EMPTY
99410: LIST
99411: LIST
99412: PUSH
99413: LD_INT 0
99415: PUSH
99416: LD_INT 5
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: PUSH
99423: LD_INT 1
99425: NEG
99426: PUSH
99427: LD_INT 4
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 1
99436: NEG
99437: PUSH
99438: LD_INT 3
99440: PUSH
99441: EMPTY
99442: LIST
99443: LIST
99444: PUSH
99445: LD_INT 2
99447: PUSH
99448: LD_INT 5
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: PUSH
99455: LD_INT 2
99457: NEG
99458: PUSH
99459: LD_INT 3
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: LD_INT 3
99468: NEG
99469: PUSH
99470: LD_INT 0
99472: PUSH
99473: EMPTY
99474: LIST
99475: LIST
99476: PUSH
99477: LD_INT 3
99479: NEG
99480: PUSH
99481: LD_INT 1
99483: NEG
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: PUSH
99489: LD_INT 2
99491: NEG
99492: PUSH
99493: LD_INT 0
99495: PUSH
99496: EMPTY
99497: LIST
99498: LIST
99499: PUSH
99500: LD_INT 2
99502: NEG
99503: PUSH
99504: LD_INT 1
99506: PUSH
99507: EMPTY
99508: LIST
99509: LIST
99510: PUSH
99511: LD_INT 3
99513: NEG
99514: PUSH
99515: LD_INT 1
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: LD_INT 4
99524: NEG
99525: PUSH
99526: LD_INT 0
99528: PUSH
99529: EMPTY
99530: LIST
99531: LIST
99532: PUSH
99533: LD_INT 4
99535: NEG
99536: PUSH
99537: LD_INT 1
99539: NEG
99540: PUSH
99541: EMPTY
99542: LIST
99543: LIST
99544: PUSH
99545: LD_INT 4
99547: NEG
99548: PUSH
99549: LD_INT 2
99551: NEG
99552: PUSH
99553: EMPTY
99554: LIST
99555: LIST
99556: PUSH
99557: LD_INT 2
99559: NEG
99560: PUSH
99561: LD_INT 2
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: PUSH
99568: LD_INT 4
99570: NEG
99571: PUSH
99572: LD_INT 4
99574: NEG
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: PUSH
99580: LD_INT 4
99582: NEG
99583: PUSH
99584: LD_INT 5
99586: NEG
99587: PUSH
99588: EMPTY
99589: LIST
99590: LIST
99591: PUSH
99592: LD_INT 3
99594: NEG
99595: PUSH
99596: LD_INT 4
99598: NEG
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: PUSH
99604: LD_INT 3
99606: NEG
99607: PUSH
99608: LD_INT 3
99610: NEG
99611: PUSH
99612: EMPTY
99613: LIST
99614: LIST
99615: PUSH
99616: LD_INT 4
99618: NEG
99619: PUSH
99620: LD_INT 3
99622: NEG
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: LD_INT 5
99630: NEG
99631: PUSH
99632: LD_INT 4
99634: NEG
99635: PUSH
99636: EMPTY
99637: LIST
99638: LIST
99639: PUSH
99640: LD_INT 5
99642: NEG
99643: PUSH
99644: LD_INT 5
99646: NEG
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: PUSH
99652: LD_INT 3
99654: NEG
99655: PUSH
99656: LD_INT 5
99658: NEG
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: PUSH
99664: LD_INT 5
99666: NEG
99667: PUSH
99668: LD_INT 3
99670: NEG
99671: PUSH
99672: EMPTY
99673: LIST
99674: LIST
99675: PUSH
99676: LD_INT 0
99678: PUSH
99679: LD_INT 3
99681: NEG
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PUSH
99687: LD_INT 0
99689: PUSH
99690: LD_INT 4
99692: NEG
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PUSH
99698: LD_INT 1
99700: PUSH
99701: LD_INT 3
99703: NEG
99704: PUSH
99705: EMPTY
99706: LIST
99707: LIST
99708: PUSH
99709: LD_INT 1
99711: PUSH
99712: LD_INT 2
99714: NEG
99715: PUSH
99716: EMPTY
99717: LIST
99718: LIST
99719: PUSH
99720: LD_INT 0
99722: PUSH
99723: LD_INT 2
99725: NEG
99726: PUSH
99727: EMPTY
99728: LIST
99729: LIST
99730: PUSH
99731: LD_INT 1
99733: NEG
99734: PUSH
99735: LD_INT 3
99737: NEG
99738: PUSH
99739: EMPTY
99740: LIST
99741: LIST
99742: PUSH
99743: LD_INT 1
99745: NEG
99746: PUSH
99747: LD_INT 4
99749: NEG
99750: PUSH
99751: EMPTY
99752: LIST
99753: LIST
99754: PUSH
99755: LD_INT 2
99757: PUSH
99758: LD_INT 2
99760: NEG
99761: PUSH
99762: EMPTY
99763: LIST
99764: LIST
99765: PUSH
99766: LD_INT 2
99768: NEG
99769: PUSH
99770: LD_INT 4
99772: NEG
99773: PUSH
99774: EMPTY
99775: LIST
99776: LIST
99777: PUSH
99778: LD_INT 4
99780: PUSH
99781: LD_INT 0
99783: PUSH
99784: EMPTY
99785: LIST
99786: LIST
99787: PUSH
99788: LD_INT 4
99790: PUSH
99791: LD_INT 1
99793: NEG
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: PUSH
99799: LD_INT 5
99801: PUSH
99802: LD_INT 0
99804: PUSH
99805: EMPTY
99806: LIST
99807: LIST
99808: PUSH
99809: LD_INT 5
99811: PUSH
99812: LD_INT 1
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: PUSH
99819: LD_INT 4
99821: PUSH
99822: LD_INT 1
99824: PUSH
99825: EMPTY
99826: LIST
99827: LIST
99828: PUSH
99829: LD_INT 3
99831: PUSH
99832: LD_INT 0
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PUSH
99839: LD_INT 3
99841: PUSH
99842: LD_INT 1
99844: NEG
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: LD_INT 3
99852: PUSH
99853: LD_INT 2
99855: NEG
99856: PUSH
99857: EMPTY
99858: LIST
99859: LIST
99860: PUSH
99861: LD_INT 5
99863: PUSH
99864: LD_INT 2
99866: PUSH
99867: EMPTY
99868: LIST
99869: LIST
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: LIST
99902: LIST
99903: LIST
99904: LIST
99905: LIST
99906: LIST
99907: LIST
99908: LIST
99909: LIST
99910: LIST
99911: LIST
99912: LIST
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
99918: LD_ADDR_VAR 0 32
99922: PUSH
99923: LD_INT 4
99925: NEG
99926: PUSH
99927: LD_INT 0
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PUSH
99934: LD_INT 4
99936: NEG
99937: PUSH
99938: LD_INT 1
99940: NEG
99941: PUSH
99942: EMPTY
99943: LIST
99944: LIST
99945: PUSH
99946: LD_INT 3
99948: NEG
99949: PUSH
99950: LD_INT 0
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: PUSH
99957: LD_INT 3
99959: NEG
99960: PUSH
99961: LD_INT 1
99963: PUSH
99964: EMPTY
99965: LIST
99966: LIST
99967: PUSH
99968: LD_INT 4
99970: NEG
99971: PUSH
99972: LD_INT 1
99974: PUSH
99975: EMPTY
99976: LIST
99977: LIST
99978: PUSH
99979: LD_INT 5
99981: NEG
99982: PUSH
99983: LD_INT 0
99985: PUSH
99986: EMPTY
99987: LIST
99988: LIST
99989: PUSH
99990: LD_INT 5
99992: NEG
99993: PUSH
99994: LD_INT 1
99996: NEG
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PUSH
100002: LD_INT 5
100004: NEG
100005: PUSH
100006: LD_INT 2
100008: NEG
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: PUSH
100014: LD_INT 3
100016: NEG
100017: PUSH
100018: LD_INT 2
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: LD_INT 3
100027: NEG
100028: PUSH
100029: LD_INT 3
100031: NEG
100032: PUSH
100033: EMPTY
100034: LIST
100035: LIST
100036: PUSH
100037: LD_INT 3
100039: NEG
100040: PUSH
100041: LD_INT 4
100043: NEG
100044: PUSH
100045: EMPTY
100046: LIST
100047: LIST
100048: PUSH
100049: LD_INT 2
100051: NEG
100052: PUSH
100053: LD_INT 3
100055: NEG
100056: PUSH
100057: EMPTY
100058: LIST
100059: LIST
100060: PUSH
100061: LD_INT 2
100063: NEG
100064: PUSH
100065: LD_INT 2
100067: NEG
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: PUSH
100073: LD_INT 3
100075: NEG
100076: PUSH
100077: LD_INT 2
100079: NEG
100080: PUSH
100081: EMPTY
100082: LIST
100083: LIST
100084: PUSH
100085: LD_INT 4
100087: NEG
100088: PUSH
100089: LD_INT 3
100091: NEG
100092: PUSH
100093: EMPTY
100094: LIST
100095: LIST
100096: PUSH
100097: LD_INT 4
100099: NEG
100100: PUSH
100101: LD_INT 4
100103: NEG
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: PUSH
100109: LD_INT 2
100111: NEG
100112: PUSH
100113: LD_INT 4
100115: NEG
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: PUSH
100121: LD_INT 4
100123: NEG
100124: PUSH
100125: LD_INT 2
100127: NEG
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PUSH
100133: LD_INT 0
100135: PUSH
100136: LD_INT 4
100138: NEG
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: LD_INT 0
100146: PUSH
100147: LD_INT 5
100149: NEG
100150: PUSH
100151: EMPTY
100152: LIST
100153: LIST
100154: PUSH
100155: LD_INT 1
100157: PUSH
100158: LD_INT 4
100160: NEG
100161: PUSH
100162: EMPTY
100163: LIST
100164: LIST
100165: PUSH
100166: LD_INT 1
100168: PUSH
100169: LD_INT 3
100171: NEG
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PUSH
100177: LD_INT 0
100179: PUSH
100180: LD_INT 3
100182: NEG
100183: PUSH
100184: EMPTY
100185: LIST
100186: LIST
100187: PUSH
100188: LD_INT 1
100190: NEG
100191: PUSH
100192: LD_INT 4
100194: NEG
100195: PUSH
100196: EMPTY
100197: LIST
100198: LIST
100199: PUSH
100200: LD_INT 1
100202: NEG
100203: PUSH
100204: LD_INT 5
100206: NEG
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: PUSH
100212: LD_INT 2
100214: PUSH
100215: LD_INT 3
100217: NEG
100218: PUSH
100219: EMPTY
100220: LIST
100221: LIST
100222: PUSH
100223: LD_INT 2
100225: NEG
100226: PUSH
100227: LD_INT 5
100229: NEG
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: PUSH
100235: LD_INT 3
100237: PUSH
100238: LD_INT 0
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PUSH
100245: LD_INT 3
100247: PUSH
100248: LD_INT 1
100250: NEG
100251: PUSH
100252: EMPTY
100253: LIST
100254: LIST
100255: PUSH
100256: LD_INT 4
100258: PUSH
100259: LD_INT 0
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: PUSH
100266: LD_INT 4
100268: PUSH
100269: LD_INT 1
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: PUSH
100276: LD_INT 3
100278: PUSH
100279: LD_INT 1
100281: PUSH
100282: EMPTY
100283: LIST
100284: LIST
100285: PUSH
100286: LD_INT 2
100288: PUSH
100289: LD_INT 0
100291: PUSH
100292: EMPTY
100293: LIST
100294: LIST
100295: PUSH
100296: LD_INT 2
100298: PUSH
100299: LD_INT 1
100301: NEG
100302: PUSH
100303: EMPTY
100304: LIST
100305: LIST
100306: PUSH
100307: LD_INT 2
100309: PUSH
100310: LD_INT 2
100312: NEG
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PUSH
100318: LD_INT 4
100320: PUSH
100321: LD_INT 2
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 4
100330: PUSH
100331: LD_INT 4
100333: PUSH
100334: EMPTY
100335: LIST
100336: LIST
100337: PUSH
100338: LD_INT 4
100340: PUSH
100341: LD_INT 3
100343: PUSH
100344: EMPTY
100345: LIST
100346: LIST
100347: PUSH
100348: LD_INT 5
100350: PUSH
100351: LD_INT 4
100353: PUSH
100354: EMPTY
100355: LIST
100356: LIST
100357: PUSH
100358: LD_INT 5
100360: PUSH
100361: LD_INT 5
100363: PUSH
100364: EMPTY
100365: LIST
100366: LIST
100367: PUSH
100368: LD_INT 4
100370: PUSH
100371: LD_INT 5
100373: PUSH
100374: EMPTY
100375: LIST
100376: LIST
100377: PUSH
100378: LD_INT 3
100380: PUSH
100381: LD_INT 4
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: PUSH
100388: LD_INT 3
100390: PUSH
100391: LD_INT 3
100393: PUSH
100394: EMPTY
100395: LIST
100396: LIST
100397: PUSH
100398: LD_INT 5
100400: PUSH
100401: LD_INT 3
100403: PUSH
100404: EMPTY
100405: LIST
100406: LIST
100407: PUSH
100408: LD_INT 3
100410: PUSH
100411: LD_INT 5
100413: PUSH
100414: EMPTY
100415: LIST
100416: LIST
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
100465: LD_ADDR_VAR 0 33
100469: PUSH
100470: LD_INT 4
100472: NEG
100473: PUSH
100474: LD_INT 4
100476: NEG
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: LD_INT 4
100484: NEG
100485: PUSH
100486: LD_INT 5
100488: NEG
100489: PUSH
100490: EMPTY
100491: LIST
100492: LIST
100493: PUSH
100494: LD_INT 3
100496: NEG
100497: PUSH
100498: LD_INT 4
100500: NEG
100501: PUSH
100502: EMPTY
100503: LIST
100504: LIST
100505: PUSH
100506: LD_INT 3
100508: NEG
100509: PUSH
100510: LD_INT 3
100512: NEG
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PUSH
100518: LD_INT 4
100520: NEG
100521: PUSH
100522: LD_INT 3
100524: NEG
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PUSH
100530: LD_INT 5
100532: NEG
100533: PUSH
100534: LD_INT 4
100536: NEG
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 5
100544: NEG
100545: PUSH
100546: LD_INT 5
100548: NEG
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: LD_INT 3
100556: NEG
100557: PUSH
100558: LD_INT 5
100560: NEG
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PUSH
100566: LD_INT 5
100568: NEG
100569: PUSH
100570: LD_INT 3
100572: NEG
100573: PUSH
100574: EMPTY
100575: LIST
100576: LIST
100577: PUSH
100578: LD_INT 0
100580: PUSH
100581: LD_INT 3
100583: NEG
100584: PUSH
100585: EMPTY
100586: LIST
100587: LIST
100588: PUSH
100589: LD_INT 0
100591: PUSH
100592: LD_INT 4
100594: NEG
100595: PUSH
100596: EMPTY
100597: LIST
100598: LIST
100599: PUSH
100600: LD_INT 1
100602: PUSH
100603: LD_INT 3
100605: NEG
100606: PUSH
100607: EMPTY
100608: LIST
100609: LIST
100610: PUSH
100611: LD_INT 1
100613: PUSH
100614: LD_INT 2
100616: NEG
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: LD_INT 0
100624: PUSH
100625: LD_INT 2
100627: NEG
100628: PUSH
100629: EMPTY
100630: LIST
100631: LIST
100632: PUSH
100633: LD_INT 1
100635: NEG
100636: PUSH
100637: LD_INT 3
100639: NEG
100640: PUSH
100641: EMPTY
100642: LIST
100643: LIST
100644: PUSH
100645: LD_INT 1
100647: NEG
100648: PUSH
100649: LD_INT 4
100651: NEG
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: PUSH
100657: LD_INT 2
100659: PUSH
100660: LD_INT 2
100662: NEG
100663: PUSH
100664: EMPTY
100665: LIST
100666: LIST
100667: PUSH
100668: LD_INT 2
100670: NEG
100671: PUSH
100672: LD_INT 4
100674: NEG
100675: PUSH
100676: EMPTY
100677: LIST
100678: LIST
100679: PUSH
100680: LD_INT 4
100682: PUSH
100683: LD_INT 0
100685: PUSH
100686: EMPTY
100687: LIST
100688: LIST
100689: PUSH
100690: LD_INT 4
100692: PUSH
100693: LD_INT 1
100695: NEG
100696: PUSH
100697: EMPTY
100698: LIST
100699: LIST
100700: PUSH
100701: LD_INT 5
100703: PUSH
100704: LD_INT 0
100706: PUSH
100707: EMPTY
100708: LIST
100709: LIST
100710: PUSH
100711: LD_INT 5
100713: PUSH
100714: LD_INT 1
100716: PUSH
100717: EMPTY
100718: LIST
100719: LIST
100720: PUSH
100721: LD_INT 4
100723: PUSH
100724: LD_INT 1
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 3
100733: PUSH
100734: LD_INT 0
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_INT 3
100743: PUSH
100744: LD_INT 1
100746: NEG
100747: PUSH
100748: EMPTY
100749: LIST
100750: LIST
100751: PUSH
100752: LD_INT 3
100754: PUSH
100755: LD_INT 2
100757: NEG
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: PUSH
100763: LD_INT 5
100765: PUSH
100766: LD_INT 2
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 3
100775: PUSH
100776: LD_INT 3
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: PUSH
100783: LD_INT 3
100785: PUSH
100786: LD_INT 2
100788: PUSH
100789: EMPTY
100790: LIST
100791: LIST
100792: PUSH
100793: LD_INT 4
100795: PUSH
100796: LD_INT 3
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: LD_INT 4
100805: PUSH
100806: LD_INT 4
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: PUSH
100813: LD_INT 3
100815: PUSH
100816: LD_INT 4
100818: PUSH
100819: EMPTY
100820: LIST
100821: LIST
100822: PUSH
100823: LD_INT 2
100825: PUSH
100826: LD_INT 3
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 2
100835: PUSH
100836: LD_INT 2
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: LD_INT 4
100845: PUSH
100846: LD_INT 2
100848: PUSH
100849: EMPTY
100850: LIST
100851: LIST
100852: PUSH
100853: LD_INT 2
100855: PUSH
100856: LD_INT 4
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: PUSH
100863: LD_INT 0
100865: PUSH
100866: LD_INT 4
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: PUSH
100873: LD_INT 0
100875: PUSH
100876: LD_INT 3
100878: PUSH
100879: EMPTY
100880: LIST
100881: LIST
100882: PUSH
100883: LD_INT 1
100885: PUSH
100886: LD_INT 4
100888: PUSH
100889: EMPTY
100890: LIST
100891: LIST
100892: PUSH
100893: LD_INT 1
100895: PUSH
100896: LD_INT 5
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 0
100905: PUSH
100906: LD_INT 5
100908: PUSH
100909: EMPTY
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 1
100915: NEG
100916: PUSH
100917: LD_INT 4
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: LD_INT 1
100926: NEG
100927: PUSH
100928: LD_INT 3
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PUSH
100935: LD_INT 2
100937: PUSH
100938: LD_INT 5
100940: PUSH
100941: EMPTY
100942: LIST
100943: LIST
100944: PUSH
100945: LD_INT 2
100947: NEG
100948: PUSH
100949: LD_INT 3
100951: PUSH
100952: EMPTY
100953: LIST
100954: LIST
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: LIST
100983: LIST
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: LIST
100994: LIST
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: LIST
101002: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
101003: LD_ADDR_VAR 0 34
101007: PUSH
101008: LD_INT 0
101010: PUSH
101011: LD_INT 4
101013: NEG
101014: PUSH
101015: EMPTY
101016: LIST
101017: LIST
101018: PUSH
101019: LD_INT 0
101021: PUSH
101022: LD_INT 5
101024: NEG
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PUSH
101030: LD_INT 1
101032: PUSH
101033: LD_INT 4
101035: NEG
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PUSH
101041: LD_INT 1
101043: PUSH
101044: LD_INT 3
101046: NEG
101047: PUSH
101048: EMPTY
101049: LIST
101050: LIST
101051: PUSH
101052: LD_INT 0
101054: PUSH
101055: LD_INT 3
101057: NEG
101058: PUSH
101059: EMPTY
101060: LIST
101061: LIST
101062: PUSH
101063: LD_INT 1
101065: NEG
101066: PUSH
101067: LD_INT 4
101069: NEG
101070: PUSH
101071: EMPTY
101072: LIST
101073: LIST
101074: PUSH
101075: LD_INT 1
101077: NEG
101078: PUSH
101079: LD_INT 5
101081: NEG
101082: PUSH
101083: EMPTY
101084: LIST
101085: LIST
101086: PUSH
101087: LD_INT 2
101089: PUSH
101090: LD_INT 3
101092: NEG
101093: PUSH
101094: EMPTY
101095: LIST
101096: LIST
101097: PUSH
101098: LD_INT 2
101100: NEG
101101: PUSH
101102: LD_INT 5
101104: NEG
101105: PUSH
101106: EMPTY
101107: LIST
101108: LIST
101109: PUSH
101110: LD_INT 3
101112: PUSH
101113: LD_INT 0
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PUSH
101120: LD_INT 3
101122: PUSH
101123: LD_INT 1
101125: NEG
101126: PUSH
101127: EMPTY
101128: LIST
101129: LIST
101130: PUSH
101131: LD_INT 4
101133: PUSH
101134: LD_INT 0
101136: PUSH
101137: EMPTY
101138: LIST
101139: LIST
101140: PUSH
101141: LD_INT 4
101143: PUSH
101144: LD_INT 1
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PUSH
101151: LD_INT 3
101153: PUSH
101154: LD_INT 1
101156: PUSH
101157: EMPTY
101158: LIST
101159: LIST
101160: PUSH
101161: LD_INT 2
101163: PUSH
101164: LD_INT 0
101166: PUSH
101167: EMPTY
101168: LIST
101169: LIST
101170: PUSH
101171: LD_INT 2
101173: PUSH
101174: LD_INT 1
101176: NEG
101177: PUSH
101178: EMPTY
101179: LIST
101180: LIST
101181: PUSH
101182: LD_INT 2
101184: PUSH
101185: LD_INT 2
101187: NEG
101188: PUSH
101189: EMPTY
101190: LIST
101191: LIST
101192: PUSH
101193: LD_INT 4
101195: PUSH
101196: LD_INT 2
101198: PUSH
101199: EMPTY
101200: LIST
101201: LIST
101202: PUSH
101203: LD_INT 4
101205: PUSH
101206: LD_INT 4
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: LD_INT 4
101215: PUSH
101216: LD_INT 3
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PUSH
101223: LD_INT 5
101225: PUSH
101226: LD_INT 4
101228: PUSH
101229: EMPTY
101230: LIST
101231: LIST
101232: PUSH
101233: LD_INT 5
101235: PUSH
101236: LD_INT 5
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: PUSH
101243: LD_INT 4
101245: PUSH
101246: LD_INT 5
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: PUSH
101253: LD_INT 3
101255: PUSH
101256: LD_INT 4
101258: PUSH
101259: EMPTY
101260: LIST
101261: LIST
101262: PUSH
101263: LD_INT 3
101265: PUSH
101266: LD_INT 3
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: LD_INT 5
101275: PUSH
101276: LD_INT 3
101278: PUSH
101279: EMPTY
101280: LIST
101281: LIST
101282: PUSH
101283: LD_INT 3
101285: PUSH
101286: LD_INT 5
101288: PUSH
101289: EMPTY
101290: LIST
101291: LIST
101292: PUSH
101293: LD_INT 0
101295: PUSH
101296: LD_INT 3
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: PUSH
101303: LD_INT 0
101305: PUSH
101306: LD_INT 2
101308: PUSH
101309: EMPTY
101310: LIST
101311: LIST
101312: PUSH
101313: LD_INT 1
101315: PUSH
101316: LD_INT 3
101318: PUSH
101319: EMPTY
101320: LIST
101321: LIST
101322: PUSH
101323: LD_INT 1
101325: PUSH
101326: LD_INT 4
101328: PUSH
101329: EMPTY
101330: LIST
101331: LIST
101332: PUSH
101333: LD_INT 0
101335: PUSH
101336: LD_INT 4
101338: PUSH
101339: EMPTY
101340: LIST
101341: LIST
101342: PUSH
101343: LD_INT 1
101345: NEG
101346: PUSH
101347: LD_INT 3
101349: PUSH
101350: EMPTY
101351: LIST
101352: LIST
101353: PUSH
101354: LD_INT 1
101356: NEG
101357: PUSH
101358: LD_INT 2
101360: PUSH
101361: EMPTY
101362: LIST
101363: LIST
101364: PUSH
101365: LD_INT 2
101367: PUSH
101368: LD_INT 4
101370: PUSH
101371: EMPTY
101372: LIST
101373: LIST
101374: PUSH
101375: LD_INT 2
101377: NEG
101378: PUSH
101379: LD_INT 2
101381: PUSH
101382: EMPTY
101383: LIST
101384: LIST
101385: PUSH
101386: LD_INT 4
101388: NEG
101389: PUSH
101390: LD_INT 0
101392: PUSH
101393: EMPTY
101394: LIST
101395: LIST
101396: PUSH
101397: LD_INT 4
101399: NEG
101400: PUSH
101401: LD_INT 1
101403: NEG
101404: PUSH
101405: EMPTY
101406: LIST
101407: LIST
101408: PUSH
101409: LD_INT 3
101411: NEG
101412: PUSH
101413: LD_INT 0
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: PUSH
101420: LD_INT 3
101422: NEG
101423: PUSH
101424: LD_INT 1
101426: PUSH
101427: EMPTY
101428: LIST
101429: LIST
101430: PUSH
101431: LD_INT 4
101433: NEG
101434: PUSH
101435: LD_INT 1
101437: PUSH
101438: EMPTY
101439: LIST
101440: LIST
101441: PUSH
101442: LD_INT 5
101444: NEG
101445: PUSH
101446: LD_INT 0
101448: PUSH
101449: EMPTY
101450: LIST
101451: LIST
101452: PUSH
101453: LD_INT 5
101455: NEG
101456: PUSH
101457: LD_INT 1
101459: NEG
101460: PUSH
101461: EMPTY
101462: LIST
101463: LIST
101464: PUSH
101465: LD_INT 5
101467: NEG
101468: PUSH
101469: LD_INT 2
101471: NEG
101472: PUSH
101473: EMPTY
101474: LIST
101475: LIST
101476: PUSH
101477: LD_INT 3
101479: NEG
101480: PUSH
101481: LD_INT 2
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: PUSH
101488: EMPTY
101489: LIST
101490: LIST
101491: LIST
101492: LIST
101493: LIST
101494: LIST
101495: LIST
101496: LIST
101497: LIST
101498: LIST
101499: LIST
101500: LIST
101501: LIST
101502: LIST
101503: LIST
101504: LIST
101505: LIST
101506: LIST
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: ST_TO_ADDR
// end ; end ;
101535: GO 101538
101537: POP
// case btype of b_depot , b_warehouse :
101538: LD_VAR 0 1
101542: PUSH
101543: LD_INT 0
101545: DOUBLE
101546: EQUAL
101547: IFTRUE 101557
101549: LD_INT 1
101551: DOUBLE
101552: EQUAL
101553: IFTRUE 101557
101555: GO 101758
101557: POP
// case nation of nation_american :
101558: LD_VAR 0 5
101562: PUSH
101563: LD_INT 1
101565: DOUBLE
101566: EQUAL
101567: IFTRUE 101571
101569: GO 101627
101571: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
101572: LD_ADDR_VAR 0 9
101576: PUSH
101577: LD_VAR 0 11
101581: PUSH
101582: LD_VAR 0 12
101586: PUSH
101587: LD_VAR 0 13
101591: PUSH
101592: LD_VAR 0 14
101596: PUSH
101597: LD_VAR 0 15
101601: PUSH
101602: LD_VAR 0 16
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: LIST
101614: PUSH
101615: LD_VAR 0 4
101619: PUSH
101620: LD_INT 1
101622: PLUS
101623: ARRAY
101624: ST_TO_ADDR
101625: GO 101756
101627: LD_INT 2
101629: DOUBLE
101630: EQUAL
101631: IFTRUE 101635
101633: GO 101691
101635: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
101636: LD_ADDR_VAR 0 9
101640: PUSH
101641: LD_VAR 0 17
101645: PUSH
101646: LD_VAR 0 18
101650: PUSH
101651: LD_VAR 0 19
101655: PUSH
101656: LD_VAR 0 20
101660: PUSH
101661: LD_VAR 0 21
101665: PUSH
101666: LD_VAR 0 22
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: LIST
101675: LIST
101676: LIST
101677: LIST
101678: PUSH
101679: LD_VAR 0 4
101683: PUSH
101684: LD_INT 1
101686: PLUS
101687: ARRAY
101688: ST_TO_ADDR
101689: GO 101756
101691: LD_INT 3
101693: DOUBLE
101694: EQUAL
101695: IFTRUE 101699
101697: GO 101755
101699: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
101700: LD_ADDR_VAR 0 9
101704: PUSH
101705: LD_VAR 0 23
101709: PUSH
101710: LD_VAR 0 24
101714: PUSH
101715: LD_VAR 0 25
101719: PUSH
101720: LD_VAR 0 26
101724: PUSH
101725: LD_VAR 0 27
101729: PUSH
101730: LD_VAR 0 28
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: LIST
101739: LIST
101740: LIST
101741: LIST
101742: PUSH
101743: LD_VAR 0 4
101747: PUSH
101748: LD_INT 1
101750: PLUS
101751: ARRAY
101752: ST_TO_ADDR
101753: GO 101756
101755: POP
101756: GO 102311
101758: LD_INT 2
101760: DOUBLE
101761: EQUAL
101762: IFTRUE 101772
101764: LD_INT 3
101766: DOUBLE
101767: EQUAL
101768: IFTRUE 101772
101770: GO 101828
101772: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
101773: LD_ADDR_VAR 0 9
101777: PUSH
101778: LD_VAR 0 29
101782: PUSH
101783: LD_VAR 0 30
101787: PUSH
101788: LD_VAR 0 31
101792: PUSH
101793: LD_VAR 0 32
101797: PUSH
101798: LD_VAR 0 33
101802: PUSH
101803: LD_VAR 0 34
101807: PUSH
101808: EMPTY
101809: LIST
101810: LIST
101811: LIST
101812: LIST
101813: LIST
101814: LIST
101815: PUSH
101816: LD_VAR 0 4
101820: PUSH
101821: LD_INT 1
101823: PLUS
101824: ARRAY
101825: ST_TO_ADDR
101826: GO 102311
101828: LD_INT 16
101830: DOUBLE
101831: EQUAL
101832: IFTRUE 101890
101834: LD_INT 17
101836: DOUBLE
101837: EQUAL
101838: IFTRUE 101890
101840: LD_INT 18
101842: DOUBLE
101843: EQUAL
101844: IFTRUE 101890
101846: LD_INT 19
101848: DOUBLE
101849: EQUAL
101850: IFTRUE 101890
101852: LD_INT 22
101854: DOUBLE
101855: EQUAL
101856: IFTRUE 101890
101858: LD_INT 20
101860: DOUBLE
101861: EQUAL
101862: IFTRUE 101890
101864: LD_INT 21
101866: DOUBLE
101867: EQUAL
101868: IFTRUE 101890
101870: LD_INT 23
101872: DOUBLE
101873: EQUAL
101874: IFTRUE 101890
101876: LD_INT 24
101878: DOUBLE
101879: EQUAL
101880: IFTRUE 101890
101882: LD_INT 25
101884: DOUBLE
101885: EQUAL
101886: IFTRUE 101890
101888: GO 101946
101890: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
101891: LD_ADDR_VAR 0 9
101895: PUSH
101896: LD_VAR 0 35
101900: PUSH
101901: LD_VAR 0 36
101905: PUSH
101906: LD_VAR 0 37
101910: PUSH
101911: LD_VAR 0 38
101915: PUSH
101916: LD_VAR 0 39
101920: PUSH
101921: LD_VAR 0 40
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: LIST
101930: LIST
101931: LIST
101932: LIST
101933: PUSH
101934: LD_VAR 0 4
101938: PUSH
101939: LD_INT 1
101941: PLUS
101942: ARRAY
101943: ST_TO_ADDR
101944: GO 102311
101946: LD_INT 6
101948: DOUBLE
101949: EQUAL
101950: IFTRUE 102002
101952: LD_INT 7
101954: DOUBLE
101955: EQUAL
101956: IFTRUE 102002
101958: LD_INT 8
101960: DOUBLE
101961: EQUAL
101962: IFTRUE 102002
101964: LD_INT 13
101966: DOUBLE
101967: EQUAL
101968: IFTRUE 102002
101970: LD_INT 12
101972: DOUBLE
101973: EQUAL
101974: IFTRUE 102002
101976: LD_INT 15
101978: DOUBLE
101979: EQUAL
101980: IFTRUE 102002
101982: LD_INT 11
101984: DOUBLE
101985: EQUAL
101986: IFTRUE 102002
101988: LD_INT 14
101990: DOUBLE
101991: EQUAL
101992: IFTRUE 102002
101994: LD_INT 10
101996: DOUBLE
101997: EQUAL
101998: IFTRUE 102002
102000: GO 102058
102002: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
102003: LD_ADDR_VAR 0 9
102007: PUSH
102008: LD_VAR 0 41
102012: PUSH
102013: LD_VAR 0 42
102017: PUSH
102018: LD_VAR 0 43
102022: PUSH
102023: LD_VAR 0 44
102027: PUSH
102028: LD_VAR 0 45
102032: PUSH
102033: LD_VAR 0 46
102037: PUSH
102038: EMPTY
102039: LIST
102040: LIST
102041: LIST
102042: LIST
102043: LIST
102044: LIST
102045: PUSH
102046: LD_VAR 0 4
102050: PUSH
102051: LD_INT 1
102053: PLUS
102054: ARRAY
102055: ST_TO_ADDR
102056: GO 102311
102058: LD_INT 36
102060: DOUBLE
102061: EQUAL
102062: IFTRUE 102066
102064: GO 102122
102066: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
102067: LD_ADDR_VAR 0 9
102071: PUSH
102072: LD_VAR 0 47
102076: PUSH
102077: LD_VAR 0 48
102081: PUSH
102082: LD_VAR 0 49
102086: PUSH
102087: LD_VAR 0 50
102091: PUSH
102092: LD_VAR 0 51
102096: PUSH
102097: LD_VAR 0 52
102101: PUSH
102102: EMPTY
102103: LIST
102104: LIST
102105: LIST
102106: LIST
102107: LIST
102108: LIST
102109: PUSH
102110: LD_VAR 0 4
102114: PUSH
102115: LD_INT 1
102117: PLUS
102118: ARRAY
102119: ST_TO_ADDR
102120: GO 102311
102122: LD_INT 4
102124: DOUBLE
102125: EQUAL
102126: IFTRUE 102148
102128: LD_INT 5
102130: DOUBLE
102131: EQUAL
102132: IFTRUE 102148
102134: LD_INT 34
102136: DOUBLE
102137: EQUAL
102138: IFTRUE 102148
102140: LD_INT 37
102142: DOUBLE
102143: EQUAL
102144: IFTRUE 102148
102146: GO 102204
102148: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
102149: LD_ADDR_VAR 0 9
102153: PUSH
102154: LD_VAR 0 53
102158: PUSH
102159: LD_VAR 0 54
102163: PUSH
102164: LD_VAR 0 55
102168: PUSH
102169: LD_VAR 0 56
102173: PUSH
102174: LD_VAR 0 57
102178: PUSH
102179: LD_VAR 0 58
102183: PUSH
102184: EMPTY
102185: LIST
102186: LIST
102187: LIST
102188: LIST
102189: LIST
102190: LIST
102191: PUSH
102192: LD_VAR 0 4
102196: PUSH
102197: LD_INT 1
102199: PLUS
102200: ARRAY
102201: ST_TO_ADDR
102202: GO 102311
102204: LD_INT 31
102206: DOUBLE
102207: EQUAL
102208: IFTRUE 102254
102210: LD_INT 32
102212: DOUBLE
102213: EQUAL
102214: IFTRUE 102254
102216: LD_INT 33
102218: DOUBLE
102219: EQUAL
102220: IFTRUE 102254
102222: LD_INT 27
102224: DOUBLE
102225: EQUAL
102226: IFTRUE 102254
102228: LD_INT 26
102230: DOUBLE
102231: EQUAL
102232: IFTRUE 102254
102234: LD_INT 28
102236: DOUBLE
102237: EQUAL
102238: IFTRUE 102254
102240: LD_INT 29
102242: DOUBLE
102243: EQUAL
102244: IFTRUE 102254
102246: LD_INT 30
102248: DOUBLE
102249: EQUAL
102250: IFTRUE 102254
102252: GO 102310
102254: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
102255: LD_ADDR_VAR 0 9
102259: PUSH
102260: LD_VAR 0 59
102264: PUSH
102265: LD_VAR 0 60
102269: PUSH
102270: LD_VAR 0 61
102274: PUSH
102275: LD_VAR 0 62
102279: PUSH
102280: LD_VAR 0 63
102284: PUSH
102285: LD_VAR 0 64
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: LIST
102294: LIST
102295: LIST
102296: LIST
102297: PUSH
102298: LD_VAR 0 4
102302: PUSH
102303: LD_INT 1
102305: PLUS
102306: ARRAY
102307: ST_TO_ADDR
102308: GO 102311
102310: POP
// temp_list2 = [ ] ;
102311: LD_ADDR_VAR 0 10
102315: PUSH
102316: EMPTY
102317: ST_TO_ADDR
// for i in temp_list do
102318: LD_ADDR_VAR 0 8
102322: PUSH
102323: LD_VAR 0 9
102327: PUSH
102328: FOR_IN
102329: IFFALSE 102381
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
102331: LD_ADDR_VAR 0 10
102335: PUSH
102336: LD_VAR 0 10
102340: PUSH
102341: LD_VAR 0 8
102345: PUSH
102346: LD_INT 1
102348: ARRAY
102349: PUSH
102350: LD_VAR 0 2
102354: PLUS
102355: PUSH
102356: LD_VAR 0 8
102360: PUSH
102361: LD_INT 2
102363: ARRAY
102364: PUSH
102365: LD_VAR 0 3
102369: PLUS
102370: PUSH
102371: EMPTY
102372: LIST
102373: LIST
102374: PUSH
102375: EMPTY
102376: LIST
102377: ADD
102378: ST_TO_ADDR
102379: GO 102328
102381: POP
102382: POP
// result = temp_list2 ;
102383: LD_ADDR_VAR 0 7
102387: PUSH
102388: LD_VAR 0 10
102392: ST_TO_ADDR
// end ;
102393: LD_VAR 0 7
102397: RET
// export function EnemyInRange ( unit , dist ) ; begin
102398: LD_INT 0
102400: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
102401: LD_ADDR_VAR 0 3
102405: PUSH
102406: LD_VAR 0 1
102410: PPUSH
102411: CALL_OW 255
102415: PPUSH
102416: LD_VAR 0 1
102420: PPUSH
102421: CALL_OW 250
102425: PPUSH
102426: LD_VAR 0 1
102430: PPUSH
102431: CALL_OW 251
102435: PPUSH
102436: LD_VAR 0 2
102440: PPUSH
102441: CALL 75771 0 4
102445: PUSH
102446: LD_INT 4
102448: ARRAY
102449: ST_TO_ADDR
// end ;
102450: LD_VAR 0 3
102454: RET
// export function PlayerSeeMe ( unit ) ; begin
102455: LD_INT 0
102457: PPUSH
// result := See ( your_side , unit ) ;
102458: LD_ADDR_VAR 0 2
102462: PUSH
102463: LD_OWVAR 2
102467: PPUSH
102468: LD_VAR 0 1
102472: PPUSH
102473: CALL_OW 292
102477: ST_TO_ADDR
// end ;
102478: LD_VAR 0 2
102482: RET
// export function ReverseDir ( unit ) ; begin
102483: LD_INT 0
102485: PPUSH
// if not unit then
102486: LD_VAR 0 1
102490: NOT
102491: IFFALSE 102495
// exit ;
102493: GO 102518
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
102495: LD_ADDR_VAR 0 2
102499: PUSH
102500: LD_VAR 0 1
102504: PPUSH
102505: CALL_OW 254
102509: PUSH
102510: LD_INT 3
102512: PLUS
102513: PUSH
102514: LD_INT 6
102516: MOD
102517: ST_TO_ADDR
// end ;
102518: LD_VAR 0 2
102522: RET
// export function ReverseArray ( array ) ; var i ; begin
102523: LD_INT 0
102525: PPUSH
102526: PPUSH
// if not array then
102527: LD_VAR 0 1
102531: NOT
102532: IFFALSE 102536
// exit ;
102534: GO 102591
// result := [ ] ;
102536: LD_ADDR_VAR 0 2
102540: PUSH
102541: EMPTY
102542: ST_TO_ADDR
// for i := array downto 1 do
102543: LD_ADDR_VAR 0 3
102547: PUSH
102548: DOUBLE
102549: LD_VAR 0 1
102553: INC
102554: ST_TO_ADDR
102555: LD_INT 1
102557: PUSH
102558: FOR_DOWNTO
102559: IFFALSE 102589
// result := Join ( result , array [ i ] ) ;
102561: LD_ADDR_VAR 0 2
102565: PUSH
102566: LD_VAR 0 2
102570: PPUSH
102571: LD_VAR 0 1
102575: PUSH
102576: LD_VAR 0 3
102580: ARRAY
102581: PPUSH
102582: CALL 107236 0 2
102586: ST_TO_ADDR
102587: GO 102558
102589: POP
102590: POP
// end ;
102591: LD_VAR 0 2
102595: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
102596: LD_INT 0
102598: PPUSH
102599: PPUSH
102600: PPUSH
102601: PPUSH
102602: PPUSH
102603: PPUSH
// if not unit or not hexes then
102604: LD_VAR 0 1
102608: NOT
102609: PUSH
102610: LD_VAR 0 2
102614: NOT
102615: OR
102616: IFFALSE 102620
// exit ;
102618: GO 102743
// dist := 9999 ;
102620: LD_ADDR_VAR 0 5
102624: PUSH
102625: LD_INT 9999
102627: ST_TO_ADDR
// for i = 1 to hexes do
102628: LD_ADDR_VAR 0 4
102632: PUSH
102633: DOUBLE
102634: LD_INT 1
102636: DEC
102637: ST_TO_ADDR
102638: LD_VAR 0 2
102642: PUSH
102643: FOR_TO
102644: IFFALSE 102731
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
102646: LD_ADDR_VAR 0 6
102650: PUSH
102651: LD_VAR 0 1
102655: PPUSH
102656: LD_VAR 0 2
102660: PUSH
102661: LD_VAR 0 4
102665: ARRAY
102666: PUSH
102667: LD_INT 1
102669: ARRAY
102670: PPUSH
102671: LD_VAR 0 2
102675: PUSH
102676: LD_VAR 0 4
102680: ARRAY
102681: PUSH
102682: LD_INT 2
102684: ARRAY
102685: PPUSH
102686: CALL_OW 297
102690: ST_TO_ADDR
// if tdist < dist then
102691: LD_VAR 0 6
102695: PUSH
102696: LD_VAR 0 5
102700: LESS
102701: IFFALSE 102729
// begin hex := hexes [ i ] ;
102703: LD_ADDR_VAR 0 8
102707: PUSH
102708: LD_VAR 0 2
102712: PUSH
102713: LD_VAR 0 4
102717: ARRAY
102718: ST_TO_ADDR
// dist := tdist ;
102719: LD_ADDR_VAR 0 5
102723: PUSH
102724: LD_VAR 0 6
102728: ST_TO_ADDR
// end ; end ;
102729: GO 102643
102731: POP
102732: POP
// result := hex ;
102733: LD_ADDR_VAR 0 3
102737: PUSH
102738: LD_VAR 0 8
102742: ST_TO_ADDR
// end ;
102743: LD_VAR 0 3
102747: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
102748: LD_INT 0
102750: PPUSH
102751: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102752: LD_VAR 0 1
102756: NOT
102757: PUSH
102758: LD_VAR 0 1
102762: PUSH
102763: LD_INT 21
102765: PUSH
102766: LD_INT 2
102768: PUSH
102769: EMPTY
102770: LIST
102771: LIST
102772: PUSH
102773: LD_INT 23
102775: PUSH
102776: LD_INT 2
102778: PUSH
102779: EMPTY
102780: LIST
102781: LIST
102782: PUSH
102783: EMPTY
102784: LIST
102785: LIST
102786: PPUSH
102787: CALL_OW 69
102791: IN
102792: NOT
102793: OR
102794: IFFALSE 102798
// exit ;
102796: GO 102845
// for i = 1 to 3 do
102798: LD_ADDR_VAR 0 3
102802: PUSH
102803: DOUBLE
102804: LD_INT 1
102806: DEC
102807: ST_TO_ADDR
102808: LD_INT 3
102810: PUSH
102811: FOR_TO
102812: IFFALSE 102843
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
102814: LD_VAR 0 1
102818: PPUSH
102819: CALL_OW 250
102823: PPUSH
102824: LD_VAR 0 1
102828: PPUSH
102829: CALL_OW 251
102833: PPUSH
102834: LD_INT 1
102836: PPUSH
102837: CALL_OW 453
102841: GO 102811
102843: POP
102844: POP
// end ;
102845: LD_VAR 0 2
102849: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
102850: LD_INT 0
102852: PPUSH
102853: PPUSH
102854: PPUSH
102855: PPUSH
102856: PPUSH
102857: PPUSH
// if not unit or not enemy_unit then
102858: LD_VAR 0 1
102862: NOT
102863: PUSH
102864: LD_VAR 0 2
102868: NOT
102869: OR
102870: IFFALSE 102874
// exit ;
102872: GO 103341
// if GetLives ( i ) < 250 then
102874: LD_VAR 0 4
102878: PPUSH
102879: CALL_OW 256
102883: PUSH
102884: LD_INT 250
102886: LESS
102887: IFFALSE 102900
// begin ComAutodestruct ( i ) ;
102889: LD_VAR 0 4
102893: PPUSH
102894: CALL 102748 0 1
// exit ;
102898: GO 103341
// end ; x := GetX ( enemy_unit ) ;
102900: LD_ADDR_VAR 0 7
102904: PUSH
102905: LD_VAR 0 2
102909: PPUSH
102910: CALL_OW 250
102914: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
102915: LD_ADDR_VAR 0 8
102919: PUSH
102920: LD_VAR 0 2
102924: PPUSH
102925: CALL_OW 251
102929: ST_TO_ADDR
// if not x or not y then
102930: LD_VAR 0 7
102934: NOT
102935: PUSH
102936: LD_VAR 0 8
102940: NOT
102941: OR
102942: IFFALSE 102946
// exit ;
102944: GO 103341
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
102946: LD_ADDR_VAR 0 6
102950: PUSH
102951: LD_VAR 0 7
102955: PPUSH
102956: LD_INT 0
102958: PPUSH
102959: LD_INT 4
102961: PPUSH
102962: CALL_OW 272
102966: PUSH
102967: LD_VAR 0 8
102971: PPUSH
102972: LD_INT 0
102974: PPUSH
102975: LD_INT 4
102977: PPUSH
102978: CALL_OW 273
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: PUSH
102987: LD_VAR 0 7
102991: PPUSH
102992: LD_INT 1
102994: PPUSH
102995: LD_INT 4
102997: PPUSH
102998: CALL_OW 272
103002: PUSH
103003: LD_VAR 0 8
103007: PPUSH
103008: LD_INT 1
103010: PPUSH
103011: LD_INT 4
103013: PPUSH
103014: CALL_OW 273
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: PUSH
103023: LD_VAR 0 7
103027: PPUSH
103028: LD_INT 2
103030: PPUSH
103031: LD_INT 4
103033: PPUSH
103034: CALL_OW 272
103038: PUSH
103039: LD_VAR 0 8
103043: PPUSH
103044: LD_INT 2
103046: PPUSH
103047: LD_INT 4
103049: PPUSH
103050: CALL_OW 273
103054: PUSH
103055: EMPTY
103056: LIST
103057: LIST
103058: PUSH
103059: LD_VAR 0 7
103063: PPUSH
103064: LD_INT 3
103066: PPUSH
103067: LD_INT 4
103069: PPUSH
103070: CALL_OW 272
103074: PUSH
103075: LD_VAR 0 8
103079: PPUSH
103080: LD_INT 3
103082: PPUSH
103083: LD_INT 4
103085: PPUSH
103086: CALL_OW 273
103090: PUSH
103091: EMPTY
103092: LIST
103093: LIST
103094: PUSH
103095: LD_VAR 0 7
103099: PPUSH
103100: LD_INT 4
103102: PPUSH
103103: LD_INT 4
103105: PPUSH
103106: CALL_OW 272
103110: PUSH
103111: LD_VAR 0 8
103115: PPUSH
103116: LD_INT 4
103118: PPUSH
103119: LD_INT 4
103121: PPUSH
103122: CALL_OW 273
103126: PUSH
103127: EMPTY
103128: LIST
103129: LIST
103130: PUSH
103131: LD_VAR 0 7
103135: PPUSH
103136: LD_INT 5
103138: PPUSH
103139: LD_INT 4
103141: PPUSH
103142: CALL_OW 272
103146: PUSH
103147: LD_VAR 0 8
103151: PPUSH
103152: LD_INT 5
103154: PPUSH
103155: LD_INT 4
103157: PPUSH
103158: CALL_OW 273
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: LIST
103173: LIST
103174: ST_TO_ADDR
// for i = tmp downto 1 do
103175: LD_ADDR_VAR 0 4
103179: PUSH
103180: DOUBLE
103181: LD_VAR 0 6
103185: INC
103186: ST_TO_ADDR
103187: LD_INT 1
103189: PUSH
103190: FOR_DOWNTO
103191: IFFALSE 103292
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
103193: LD_VAR 0 6
103197: PUSH
103198: LD_VAR 0 4
103202: ARRAY
103203: PUSH
103204: LD_INT 1
103206: ARRAY
103207: PPUSH
103208: LD_VAR 0 6
103212: PUSH
103213: LD_VAR 0 4
103217: ARRAY
103218: PUSH
103219: LD_INT 2
103221: ARRAY
103222: PPUSH
103223: CALL_OW 488
103227: NOT
103228: PUSH
103229: LD_VAR 0 6
103233: PUSH
103234: LD_VAR 0 4
103238: ARRAY
103239: PUSH
103240: LD_INT 1
103242: ARRAY
103243: PPUSH
103244: LD_VAR 0 6
103248: PUSH
103249: LD_VAR 0 4
103253: ARRAY
103254: PUSH
103255: LD_INT 2
103257: ARRAY
103258: PPUSH
103259: CALL_OW 428
103263: PUSH
103264: LD_INT 0
103266: NONEQUAL
103267: OR
103268: IFFALSE 103290
// tmp := Delete ( tmp , i ) ;
103270: LD_ADDR_VAR 0 6
103274: PUSH
103275: LD_VAR 0 6
103279: PPUSH
103280: LD_VAR 0 4
103284: PPUSH
103285: CALL_OW 3
103289: ST_TO_ADDR
103290: GO 103190
103292: POP
103293: POP
// j := GetClosestHex ( unit , tmp ) ;
103294: LD_ADDR_VAR 0 5
103298: PUSH
103299: LD_VAR 0 1
103303: PPUSH
103304: LD_VAR 0 6
103308: PPUSH
103309: CALL 102596 0 2
103313: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
103314: LD_VAR 0 1
103318: PPUSH
103319: LD_VAR 0 5
103323: PUSH
103324: LD_INT 1
103326: ARRAY
103327: PPUSH
103328: LD_VAR 0 5
103332: PUSH
103333: LD_INT 2
103335: ARRAY
103336: PPUSH
103337: CALL_OW 111
// end ;
103341: LD_VAR 0 3
103345: RET
// export function PrepareApemanSoldier ( ) ; begin
103346: LD_INT 0
103348: PPUSH
// uc_nation := 0 ;
103349: LD_ADDR_OWVAR 21
103353: PUSH
103354: LD_INT 0
103356: ST_TO_ADDR
// hc_sex := sex_male ;
103357: LD_ADDR_OWVAR 27
103361: PUSH
103362: LD_INT 1
103364: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
103365: LD_ADDR_OWVAR 28
103369: PUSH
103370: LD_INT 15
103372: ST_TO_ADDR
// hc_gallery :=  ;
103373: LD_ADDR_OWVAR 33
103377: PUSH
103378: LD_STRING 
103380: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103381: LD_ADDR_OWVAR 31
103385: PUSH
103386: LD_INT 0
103388: PPUSH
103389: LD_INT 3
103391: PPUSH
103392: CALL_OW 12
103396: PUSH
103397: LD_INT 0
103399: PPUSH
103400: LD_INT 3
103402: PPUSH
103403: CALL_OW 12
103407: PUSH
103408: LD_INT 0
103410: PUSH
103411: LD_INT 0
103413: PUSH
103414: EMPTY
103415: LIST
103416: LIST
103417: LIST
103418: LIST
103419: ST_TO_ADDR
// end ;
103420: LD_VAR 0 1
103424: RET
// export function PrepareApemanEngineer ( ) ; begin
103425: LD_INT 0
103427: PPUSH
// uc_nation := 0 ;
103428: LD_ADDR_OWVAR 21
103432: PUSH
103433: LD_INT 0
103435: ST_TO_ADDR
// hc_sex := sex_male ;
103436: LD_ADDR_OWVAR 27
103440: PUSH
103441: LD_INT 1
103443: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
103444: LD_ADDR_OWVAR 28
103448: PUSH
103449: LD_INT 16
103451: ST_TO_ADDR
// hc_gallery :=  ;
103452: LD_ADDR_OWVAR 33
103456: PUSH
103457: LD_STRING 
103459: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103460: LD_ADDR_OWVAR 31
103464: PUSH
103465: LD_INT 0
103467: PPUSH
103468: LD_INT 3
103470: PPUSH
103471: CALL_OW 12
103475: PUSH
103476: LD_INT 0
103478: PPUSH
103479: LD_INT 3
103481: PPUSH
103482: CALL_OW 12
103486: PUSH
103487: LD_INT 0
103489: PUSH
103490: LD_INT 0
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: LIST
103497: LIST
103498: ST_TO_ADDR
// end ;
103499: LD_VAR 0 1
103503: RET
// export function PrepareApeman ( agressivity ) ; begin
103504: LD_INT 0
103506: PPUSH
// uc_side := 0 ;
103507: LD_ADDR_OWVAR 20
103511: PUSH
103512: LD_INT 0
103514: ST_TO_ADDR
// uc_nation := 0 ;
103515: LD_ADDR_OWVAR 21
103519: PUSH
103520: LD_INT 0
103522: ST_TO_ADDR
// hc_sex := sex_male ;
103523: LD_ADDR_OWVAR 27
103527: PUSH
103528: LD_INT 1
103530: ST_TO_ADDR
// hc_class := class_apeman ;
103531: LD_ADDR_OWVAR 28
103535: PUSH
103536: LD_INT 12
103538: ST_TO_ADDR
// hc_gallery :=  ;
103539: LD_ADDR_OWVAR 33
103543: PUSH
103544: LD_STRING 
103546: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103547: LD_ADDR_OWVAR 35
103551: PUSH
103552: LD_VAR 0 1
103556: NEG
103557: PPUSH
103558: LD_VAR 0 1
103562: PPUSH
103563: CALL_OW 12
103567: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
103568: LD_ADDR_OWVAR 31
103572: PUSH
103573: LD_INT 0
103575: PPUSH
103576: LD_INT 3
103578: PPUSH
103579: CALL_OW 12
103583: PUSH
103584: LD_INT 0
103586: PPUSH
103587: LD_INT 3
103589: PPUSH
103590: CALL_OW 12
103594: PUSH
103595: LD_INT 0
103597: PUSH
103598: LD_INT 0
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: LIST
103605: LIST
103606: ST_TO_ADDR
// end ;
103607: LD_VAR 0 2
103611: RET
// export function PrepareTiger ( agressivity ) ; begin
103612: LD_INT 0
103614: PPUSH
// uc_side := 0 ;
103615: LD_ADDR_OWVAR 20
103619: PUSH
103620: LD_INT 0
103622: ST_TO_ADDR
// uc_nation := 0 ;
103623: LD_ADDR_OWVAR 21
103627: PUSH
103628: LD_INT 0
103630: ST_TO_ADDR
// hc_class := class_tiger ;
103631: LD_ADDR_OWVAR 28
103635: PUSH
103636: LD_INT 14
103638: ST_TO_ADDR
// hc_gallery :=  ;
103639: LD_ADDR_OWVAR 33
103643: PUSH
103644: LD_STRING 
103646: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
103647: LD_ADDR_OWVAR 35
103651: PUSH
103652: LD_VAR 0 1
103656: NEG
103657: PPUSH
103658: LD_VAR 0 1
103662: PPUSH
103663: CALL_OW 12
103667: ST_TO_ADDR
// end ;
103668: LD_VAR 0 2
103672: RET
// export function PrepareEnchidna ( ) ; begin
103673: LD_INT 0
103675: PPUSH
// uc_side := 0 ;
103676: LD_ADDR_OWVAR 20
103680: PUSH
103681: LD_INT 0
103683: ST_TO_ADDR
// uc_nation := 0 ;
103684: LD_ADDR_OWVAR 21
103688: PUSH
103689: LD_INT 0
103691: ST_TO_ADDR
// hc_class := class_baggie ;
103692: LD_ADDR_OWVAR 28
103696: PUSH
103697: LD_INT 13
103699: ST_TO_ADDR
// hc_gallery :=  ;
103700: LD_ADDR_OWVAR 33
103704: PUSH
103705: LD_STRING 
103707: ST_TO_ADDR
// end ;
103708: LD_VAR 0 1
103712: RET
// export function PrepareFrog ( ) ; begin
103713: LD_INT 0
103715: PPUSH
// uc_side := 0 ;
103716: LD_ADDR_OWVAR 20
103720: PUSH
103721: LD_INT 0
103723: ST_TO_ADDR
// uc_nation := 0 ;
103724: LD_ADDR_OWVAR 21
103728: PUSH
103729: LD_INT 0
103731: ST_TO_ADDR
// hc_class := class_frog ;
103732: LD_ADDR_OWVAR 28
103736: PUSH
103737: LD_INT 19
103739: ST_TO_ADDR
// hc_gallery :=  ;
103740: LD_ADDR_OWVAR 33
103744: PUSH
103745: LD_STRING 
103747: ST_TO_ADDR
// end ;
103748: LD_VAR 0 1
103752: RET
// export function PrepareFish ( ) ; begin
103753: LD_INT 0
103755: PPUSH
// uc_side := 0 ;
103756: LD_ADDR_OWVAR 20
103760: PUSH
103761: LD_INT 0
103763: ST_TO_ADDR
// uc_nation := 0 ;
103764: LD_ADDR_OWVAR 21
103768: PUSH
103769: LD_INT 0
103771: ST_TO_ADDR
// hc_class := class_fish ;
103772: LD_ADDR_OWVAR 28
103776: PUSH
103777: LD_INT 20
103779: ST_TO_ADDR
// hc_gallery :=  ;
103780: LD_ADDR_OWVAR 33
103784: PUSH
103785: LD_STRING 
103787: ST_TO_ADDR
// end ;
103788: LD_VAR 0 1
103792: RET
// export function PrepareBird ( ) ; begin
103793: LD_INT 0
103795: PPUSH
// uc_side := 0 ;
103796: LD_ADDR_OWVAR 20
103800: PUSH
103801: LD_INT 0
103803: ST_TO_ADDR
// uc_nation := 0 ;
103804: LD_ADDR_OWVAR 21
103808: PUSH
103809: LD_INT 0
103811: ST_TO_ADDR
// hc_class := class_phororhacos ;
103812: LD_ADDR_OWVAR 28
103816: PUSH
103817: LD_INT 18
103819: ST_TO_ADDR
// hc_gallery :=  ;
103820: LD_ADDR_OWVAR 33
103824: PUSH
103825: LD_STRING 
103827: ST_TO_ADDR
// end ;
103828: LD_VAR 0 1
103832: RET
// export function PrepareHorse ( ) ; begin
103833: LD_INT 0
103835: PPUSH
// uc_side := 0 ;
103836: LD_ADDR_OWVAR 20
103840: PUSH
103841: LD_INT 0
103843: ST_TO_ADDR
// uc_nation := 0 ;
103844: LD_ADDR_OWVAR 21
103848: PUSH
103849: LD_INT 0
103851: ST_TO_ADDR
// hc_class := class_horse ;
103852: LD_ADDR_OWVAR 28
103856: PUSH
103857: LD_INT 21
103859: ST_TO_ADDR
// hc_gallery :=  ;
103860: LD_ADDR_OWVAR 33
103864: PUSH
103865: LD_STRING 
103867: ST_TO_ADDR
// end ;
103868: LD_VAR 0 1
103872: RET
// export function PrepareMastodont ( ) ; begin
103873: LD_INT 0
103875: PPUSH
// uc_side := 0 ;
103876: LD_ADDR_OWVAR 20
103880: PUSH
103881: LD_INT 0
103883: ST_TO_ADDR
// uc_nation := 0 ;
103884: LD_ADDR_OWVAR 21
103888: PUSH
103889: LD_INT 0
103891: ST_TO_ADDR
// vc_chassis := class_mastodont ;
103892: LD_ADDR_OWVAR 37
103896: PUSH
103897: LD_INT 31
103899: ST_TO_ADDR
// vc_control := control_rider ;
103900: LD_ADDR_OWVAR 38
103904: PUSH
103905: LD_INT 4
103907: ST_TO_ADDR
// end ;
103908: LD_VAR 0 1
103912: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
103913: LD_INT 0
103915: PPUSH
103916: PPUSH
103917: PPUSH
// uc_side = 0 ;
103918: LD_ADDR_OWVAR 20
103922: PUSH
103923: LD_INT 0
103925: ST_TO_ADDR
// uc_nation = 0 ;
103926: LD_ADDR_OWVAR 21
103930: PUSH
103931: LD_INT 0
103933: ST_TO_ADDR
// InitHc_All ( ) ;
103934: CALL_OW 584
// InitVc ;
103938: CALL_OW 20
// if mastodonts then
103942: LD_VAR 0 6
103946: IFFALSE 104013
// for i = 1 to mastodonts do
103948: LD_ADDR_VAR 0 11
103952: PUSH
103953: DOUBLE
103954: LD_INT 1
103956: DEC
103957: ST_TO_ADDR
103958: LD_VAR 0 6
103962: PUSH
103963: FOR_TO
103964: IFFALSE 104011
// begin vc_chassis := 31 ;
103966: LD_ADDR_OWVAR 37
103970: PUSH
103971: LD_INT 31
103973: ST_TO_ADDR
// vc_control := control_rider ;
103974: LD_ADDR_OWVAR 38
103978: PUSH
103979: LD_INT 4
103981: ST_TO_ADDR
// animal := CreateVehicle ;
103982: LD_ADDR_VAR 0 12
103986: PUSH
103987: CALL_OW 45
103991: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103992: LD_VAR 0 12
103996: PPUSH
103997: LD_VAR 0 8
104001: PPUSH
104002: LD_INT 0
104004: PPUSH
104005: CALL 106141 0 3
// end ;
104009: GO 103963
104011: POP
104012: POP
// if horses then
104013: LD_VAR 0 5
104017: IFFALSE 104084
// for i = 1 to horses do
104019: LD_ADDR_VAR 0 11
104023: PUSH
104024: DOUBLE
104025: LD_INT 1
104027: DEC
104028: ST_TO_ADDR
104029: LD_VAR 0 5
104033: PUSH
104034: FOR_TO
104035: IFFALSE 104082
// begin hc_class := 21 ;
104037: LD_ADDR_OWVAR 28
104041: PUSH
104042: LD_INT 21
104044: ST_TO_ADDR
// hc_gallery :=  ;
104045: LD_ADDR_OWVAR 33
104049: PUSH
104050: LD_STRING 
104052: ST_TO_ADDR
// animal := CreateHuman ;
104053: LD_ADDR_VAR 0 12
104057: PUSH
104058: CALL_OW 44
104062: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104063: LD_VAR 0 12
104067: PPUSH
104068: LD_VAR 0 8
104072: PPUSH
104073: LD_INT 0
104075: PPUSH
104076: CALL 106141 0 3
// end ;
104080: GO 104034
104082: POP
104083: POP
// if birds then
104084: LD_VAR 0 1
104088: IFFALSE 104155
// for i = 1 to birds do
104090: LD_ADDR_VAR 0 11
104094: PUSH
104095: DOUBLE
104096: LD_INT 1
104098: DEC
104099: ST_TO_ADDR
104100: LD_VAR 0 1
104104: PUSH
104105: FOR_TO
104106: IFFALSE 104153
// begin hc_class := 18 ;
104108: LD_ADDR_OWVAR 28
104112: PUSH
104113: LD_INT 18
104115: ST_TO_ADDR
// hc_gallery =  ;
104116: LD_ADDR_OWVAR 33
104120: PUSH
104121: LD_STRING 
104123: ST_TO_ADDR
// animal := CreateHuman ;
104124: LD_ADDR_VAR 0 12
104128: PUSH
104129: CALL_OW 44
104133: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104134: LD_VAR 0 12
104138: PPUSH
104139: LD_VAR 0 8
104143: PPUSH
104144: LD_INT 0
104146: PPUSH
104147: CALL 106141 0 3
// end ;
104151: GO 104105
104153: POP
104154: POP
// if tigers then
104155: LD_VAR 0 2
104159: IFFALSE 104243
// for i = 1 to tigers do
104161: LD_ADDR_VAR 0 11
104165: PUSH
104166: DOUBLE
104167: LD_INT 1
104169: DEC
104170: ST_TO_ADDR
104171: LD_VAR 0 2
104175: PUSH
104176: FOR_TO
104177: IFFALSE 104241
// begin hc_class = class_tiger ;
104179: LD_ADDR_OWVAR 28
104183: PUSH
104184: LD_INT 14
104186: ST_TO_ADDR
// hc_gallery =  ;
104187: LD_ADDR_OWVAR 33
104191: PUSH
104192: LD_STRING 
104194: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
104195: LD_ADDR_OWVAR 35
104199: PUSH
104200: LD_INT 7
104202: NEG
104203: PPUSH
104204: LD_INT 7
104206: PPUSH
104207: CALL_OW 12
104211: ST_TO_ADDR
// animal := CreateHuman ;
104212: LD_ADDR_VAR 0 12
104216: PUSH
104217: CALL_OW 44
104221: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104222: LD_VAR 0 12
104226: PPUSH
104227: LD_VAR 0 8
104231: PPUSH
104232: LD_INT 0
104234: PPUSH
104235: CALL 106141 0 3
// end ;
104239: GO 104176
104241: POP
104242: POP
// if apemans then
104243: LD_VAR 0 3
104247: IFFALSE 104370
// for i = 1 to apemans do
104249: LD_ADDR_VAR 0 11
104253: PUSH
104254: DOUBLE
104255: LD_INT 1
104257: DEC
104258: ST_TO_ADDR
104259: LD_VAR 0 3
104263: PUSH
104264: FOR_TO
104265: IFFALSE 104368
// begin hc_class = class_apeman ;
104267: LD_ADDR_OWVAR 28
104271: PUSH
104272: LD_INT 12
104274: ST_TO_ADDR
// hc_gallery =  ;
104275: LD_ADDR_OWVAR 33
104279: PUSH
104280: LD_STRING 
104282: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
104283: LD_ADDR_OWVAR 35
104287: PUSH
104288: LD_INT 2
104290: NEG
104291: PPUSH
104292: LD_INT 2
104294: PPUSH
104295: CALL_OW 12
104299: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
104300: LD_ADDR_OWVAR 31
104304: PUSH
104305: LD_INT 1
104307: PPUSH
104308: LD_INT 3
104310: PPUSH
104311: CALL_OW 12
104315: PUSH
104316: LD_INT 1
104318: PPUSH
104319: LD_INT 3
104321: PPUSH
104322: CALL_OW 12
104326: PUSH
104327: LD_INT 0
104329: PUSH
104330: LD_INT 0
104332: PUSH
104333: EMPTY
104334: LIST
104335: LIST
104336: LIST
104337: LIST
104338: ST_TO_ADDR
// animal := CreateHuman ;
104339: LD_ADDR_VAR 0 12
104343: PUSH
104344: CALL_OW 44
104348: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104349: LD_VAR 0 12
104353: PPUSH
104354: LD_VAR 0 8
104358: PPUSH
104359: LD_INT 0
104361: PPUSH
104362: CALL 106141 0 3
// end ;
104366: GO 104264
104368: POP
104369: POP
// if enchidnas then
104370: LD_VAR 0 4
104374: IFFALSE 104441
// for i = 1 to enchidnas do
104376: LD_ADDR_VAR 0 11
104380: PUSH
104381: DOUBLE
104382: LD_INT 1
104384: DEC
104385: ST_TO_ADDR
104386: LD_VAR 0 4
104390: PUSH
104391: FOR_TO
104392: IFFALSE 104439
// begin hc_class = 13 ;
104394: LD_ADDR_OWVAR 28
104398: PUSH
104399: LD_INT 13
104401: ST_TO_ADDR
// hc_gallery =  ;
104402: LD_ADDR_OWVAR 33
104406: PUSH
104407: LD_STRING 
104409: ST_TO_ADDR
// animal := CreateHuman ;
104410: LD_ADDR_VAR 0 12
104414: PUSH
104415: CALL_OW 44
104419: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
104420: LD_VAR 0 12
104424: PPUSH
104425: LD_VAR 0 8
104429: PPUSH
104430: LD_INT 0
104432: PPUSH
104433: CALL 106141 0 3
// end ;
104437: GO 104391
104439: POP
104440: POP
// if fishes then
104441: LD_VAR 0 7
104445: IFFALSE 104512
// for i = 1 to fishes do
104447: LD_ADDR_VAR 0 11
104451: PUSH
104452: DOUBLE
104453: LD_INT 1
104455: DEC
104456: ST_TO_ADDR
104457: LD_VAR 0 7
104461: PUSH
104462: FOR_TO
104463: IFFALSE 104510
// begin hc_class = 20 ;
104465: LD_ADDR_OWVAR 28
104469: PUSH
104470: LD_INT 20
104472: ST_TO_ADDR
// hc_gallery =  ;
104473: LD_ADDR_OWVAR 33
104477: PUSH
104478: LD_STRING 
104480: ST_TO_ADDR
// animal := CreateHuman ;
104481: LD_ADDR_VAR 0 12
104485: PUSH
104486: CALL_OW 44
104490: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
104491: LD_VAR 0 12
104495: PPUSH
104496: LD_VAR 0 9
104500: PPUSH
104501: LD_INT 0
104503: PPUSH
104504: CALL 106141 0 3
// end ;
104508: GO 104462
104510: POP
104511: POP
// end ;
104512: LD_VAR 0 10
104516: RET
// export function WantHeal ( sci , unit ) ; begin
104517: LD_INT 0
104519: PPUSH
// if GetTaskList ( sci ) > 0 then
104520: LD_VAR 0 1
104524: PPUSH
104525: CALL_OW 437
104529: PUSH
104530: LD_INT 0
104532: GREATER
104533: IFFALSE 104603
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
104535: LD_VAR 0 1
104539: PPUSH
104540: CALL_OW 437
104544: PUSH
104545: LD_INT 1
104547: ARRAY
104548: PUSH
104549: LD_INT 1
104551: ARRAY
104552: PUSH
104553: LD_STRING l
104555: EQUAL
104556: PUSH
104557: LD_VAR 0 1
104561: PPUSH
104562: CALL_OW 437
104566: PUSH
104567: LD_INT 1
104569: ARRAY
104570: PUSH
104571: LD_INT 4
104573: ARRAY
104574: PUSH
104575: LD_VAR 0 2
104579: EQUAL
104580: AND
104581: IFFALSE 104593
// result := true else
104583: LD_ADDR_VAR 0 3
104587: PUSH
104588: LD_INT 1
104590: ST_TO_ADDR
104591: GO 104601
// result := false ;
104593: LD_ADDR_VAR 0 3
104597: PUSH
104598: LD_INT 0
104600: ST_TO_ADDR
// end else
104601: GO 104611
// result := false ;
104603: LD_ADDR_VAR 0 3
104607: PUSH
104608: LD_INT 0
104610: ST_TO_ADDR
// end ;
104611: LD_VAR 0 3
104615: RET
// export function HealTarget ( sci ) ; begin
104616: LD_INT 0
104618: PPUSH
// if not sci then
104619: LD_VAR 0 1
104623: NOT
104624: IFFALSE 104628
// exit ;
104626: GO 104693
// result := 0 ;
104628: LD_ADDR_VAR 0 2
104632: PUSH
104633: LD_INT 0
104635: ST_TO_ADDR
// if GetTaskList ( sci ) then
104636: LD_VAR 0 1
104640: PPUSH
104641: CALL_OW 437
104645: IFFALSE 104693
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
104647: LD_VAR 0 1
104651: PPUSH
104652: CALL_OW 437
104656: PUSH
104657: LD_INT 1
104659: ARRAY
104660: PUSH
104661: LD_INT 1
104663: ARRAY
104664: PUSH
104665: LD_STRING l
104667: EQUAL
104668: IFFALSE 104693
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
104670: LD_ADDR_VAR 0 2
104674: PUSH
104675: LD_VAR 0 1
104679: PPUSH
104680: CALL_OW 437
104684: PUSH
104685: LD_INT 1
104687: ARRAY
104688: PUSH
104689: LD_INT 4
104691: ARRAY
104692: ST_TO_ADDR
// end ;
104693: LD_VAR 0 2
104697: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104698: LD_INT 0
104700: PPUSH
104701: PPUSH
104702: PPUSH
104703: PPUSH
// if not base_units then
104704: LD_VAR 0 1
104708: NOT
104709: IFFALSE 104713
// exit ;
104711: GO 104800
// result := false ;
104713: LD_ADDR_VAR 0 2
104717: PUSH
104718: LD_INT 0
104720: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104721: LD_ADDR_VAR 0 5
104725: PUSH
104726: LD_VAR 0 1
104730: PPUSH
104731: LD_INT 21
104733: PUSH
104734: LD_INT 3
104736: PUSH
104737: EMPTY
104738: LIST
104739: LIST
104740: PPUSH
104741: CALL_OW 72
104745: ST_TO_ADDR
// if not tmp then
104746: LD_VAR 0 5
104750: NOT
104751: IFFALSE 104755
// exit ;
104753: GO 104800
// for i in tmp do
104755: LD_ADDR_VAR 0 3
104759: PUSH
104760: LD_VAR 0 5
104764: PUSH
104765: FOR_IN
104766: IFFALSE 104798
// begin result := EnemyInRange ( i , 22 ) ;
104768: LD_ADDR_VAR 0 2
104772: PUSH
104773: LD_VAR 0 3
104777: PPUSH
104778: LD_INT 22
104780: PPUSH
104781: CALL 102398 0 2
104785: ST_TO_ADDR
// if result then
104786: LD_VAR 0 2
104790: IFFALSE 104796
// exit ;
104792: POP
104793: POP
104794: GO 104800
// end ;
104796: GO 104765
104798: POP
104799: POP
// end ;
104800: LD_VAR 0 2
104804: RET
// export function FilterByTag ( units , tag ) ; begin
104805: LD_INT 0
104807: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
104808: LD_ADDR_VAR 0 3
104812: PUSH
104813: LD_VAR 0 1
104817: PPUSH
104818: LD_INT 120
104820: PUSH
104821: LD_VAR 0 2
104825: PUSH
104826: EMPTY
104827: LIST
104828: LIST
104829: PPUSH
104830: CALL_OW 72
104834: ST_TO_ADDR
// end ;
104835: LD_VAR 0 3
104839: RET
// export function IsDriver ( un ) ; begin
104840: LD_INT 0
104842: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104843: LD_ADDR_VAR 0 2
104847: PUSH
104848: LD_VAR 0 1
104852: PUSH
104853: LD_INT 55
104855: PUSH
104856: EMPTY
104857: LIST
104858: PPUSH
104859: CALL_OW 69
104863: IN
104864: ST_TO_ADDR
// end ;
104865: LD_VAR 0 2
104869: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104870: LD_INT 0
104872: PPUSH
104873: PPUSH
// list := [ ] ;
104874: LD_ADDR_VAR 0 5
104878: PUSH
104879: EMPTY
104880: ST_TO_ADDR
// case d of 0 :
104881: LD_VAR 0 3
104885: PUSH
104886: LD_INT 0
104888: DOUBLE
104889: EQUAL
104890: IFTRUE 104894
104892: GO 105027
104894: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104895: LD_ADDR_VAR 0 5
104899: PUSH
104900: LD_VAR 0 1
104904: PUSH
104905: LD_INT 4
104907: MINUS
104908: PUSH
104909: LD_VAR 0 2
104913: PUSH
104914: LD_INT 4
104916: MINUS
104917: PUSH
104918: LD_INT 2
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: LIST
104925: PUSH
104926: LD_VAR 0 1
104930: PUSH
104931: LD_INT 3
104933: MINUS
104934: PUSH
104935: LD_VAR 0 2
104939: PUSH
104940: LD_INT 1
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: LIST
104947: PUSH
104948: LD_VAR 0 1
104952: PUSH
104953: LD_INT 4
104955: PLUS
104956: PUSH
104957: LD_VAR 0 2
104961: PUSH
104962: LD_INT 4
104964: PUSH
104965: EMPTY
104966: LIST
104967: LIST
104968: LIST
104969: PUSH
104970: LD_VAR 0 1
104974: PUSH
104975: LD_INT 3
104977: PLUS
104978: PUSH
104979: LD_VAR 0 2
104983: PUSH
104984: LD_INT 3
104986: PLUS
104987: PUSH
104988: LD_INT 5
104990: PUSH
104991: EMPTY
104992: LIST
104993: LIST
104994: LIST
104995: PUSH
104996: LD_VAR 0 1
105000: PUSH
105001: LD_VAR 0 2
105005: PUSH
105006: LD_INT 4
105008: PLUS
105009: PUSH
105010: LD_INT 0
105012: PUSH
105013: EMPTY
105014: LIST
105015: LIST
105016: LIST
105017: PUSH
105018: EMPTY
105019: LIST
105020: LIST
105021: LIST
105022: LIST
105023: LIST
105024: ST_TO_ADDR
// end ; 1 :
105025: GO 105725
105027: LD_INT 1
105029: DOUBLE
105030: EQUAL
105031: IFTRUE 105035
105033: GO 105168
105035: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105036: LD_ADDR_VAR 0 5
105040: PUSH
105041: LD_VAR 0 1
105045: PUSH
105046: LD_VAR 0 2
105050: PUSH
105051: LD_INT 4
105053: MINUS
105054: PUSH
105055: LD_INT 3
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: LIST
105062: PUSH
105063: LD_VAR 0 1
105067: PUSH
105068: LD_INT 3
105070: MINUS
105071: PUSH
105072: LD_VAR 0 2
105076: PUSH
105077: LD_INT 3
105079: MINUS
105080: PUSH
105081: LD_INT 2
105083: PUSH
105084: EMPTY
105085: LIST
105086: LIST
105087: LIST
105088: PUSH
105089: LD_VAR 0 1
105093: PUSH
105094: LD_INT 4
105096: MINUS
105097: PUSH
105098: LD_VAR 0 2
105102: PUSH
105103: LD_INT 1
105105: PUSH
105106: EMPTY
105107: LIST
105108: LIST
105109: LIST
105110: PUSH
105111: LD_VAR 0 1
105115: PUSH
105116: LD_VAR 0 2
105120: PUSH
105121: LD_INT 3
105123: PLUS
105124: PUSH
105125: LD_INT 0
105127: PUSH
105128: EMPTY
105129: LIST
105130: LIST
105131: LIST
105132: PUSH
105133: LD_VAR 0 1
105137: PUSH
105138: LD_INT 4
105140: PLUS
105141: PUSH
105142: LD_VAR 0 2
105146: PUSH
105147: LD_INT 4
105149: PLUS
105150: PUSH
105151: LD_INT 5
105153: PUSH
105154: EMPTY
105155: LIST
105156: LIST
105157: LIST
105158: PUSH
105159: EMPTY
105160: LIST
105161: LIST
105162: LIST
105163: LIST
105164: LIST
105165: ST_TO_ADDR
// end ; 2 :
105166: GO 105725
105168: LD_INT 2
105170: DOUBLE
105171: EQUAL
105172: IFTRUE 105176
105174: GO 105305
105176: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105177: LD_ADDR_VAR 0 5
105181: PUSH
105182: LD_VAR 0 1
105186: PUSH
105187: LD_VAR 0 2
105191: PUSH
105192: LD_INT 3
105194: MINUS
105195: PUSH
105196: LD_INT 3
105198: PUSH
105199: EMPTY
105200: LIST
105201: LIST
105202: LIST
105203: PUSH
105204: LD_VAR 0 1
105208: PUSH
105209: LD_INT 4
105211: PLUS
105212: PUSH
105213: LD_VAR 0 2
105217: PUSH
105218: LD_INT 4
105220: PUSH
105221: EMPTY
105222: LIST
105223: LIST
105224: LIST
105225: PUSH
105226: LD_VAR 0 1
105230: PUSH
105231: LD_VAR 0 2
105235: PUSH
105236: LD_INT 4
105238: PLUS
105239: PUSH
105240: LD_INT 0
105242: PUSH
105243: EMPTY
105244: LIST
105245: LIST
105246: LIST
105247: PUSH
105248: LD_VAR 0 1
105252: PUSH
105253: LD_INT 3
105255: MINUS
105256: PUSH
105257: LD_VAR 0 2
105261: PUSH
105262: LD_INT 1
105264: PUSH
105265: EMPTY
105266: LIST
105267: LIST
105268: LIST
105269: PUSH
105270: LD_VAR 0 1
105274: PUSH
105275: LD_INT 4
105277: MINUS
105278: PUSH
105279: LD_VAR 0 2
105283: PUSH
105284: LD_INT 4
105286: MINUS
105287: PUSH
105288: LD_INT 2
105290: PUSH
105291: EMPTY
105292: LIST
105293: LIST
105294: LIST
105295: PUSH
105296: EMPTY
105297: LIST
105298: LIST
105299: LIST
105300: LIST
105301: LIST
105302: ST_TO_ADDR
// end ; 3 :
105303: GO 105725
105305: LD_INT 3
105307: DOUBLE
105308: EQUAL
105309: IFTRUE 105313
105311: GO 105446
105313: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105314: LD_ADDR_VAR 0 5
105318: PUSH
105319: LD_VAR 0 1
105323: PUSH
105324: LD_INT 3
105326: PLUS
105327: PUSH
105328: LD_VAR 0 2
105332: PUSH
105333: LD_INT 4
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: LIST
105340: PUSH
105341: LD_VAR 0 1
105345: PUSH
105346: LD_INT 4
105348: PLUS
105349: PUSH
105350: LD_VAR 0 2
105354: PUSH
105355: LD_INT 4
105357: PLUS
105358: PUSH
105359: LD_INT 5
105361: PUSH
105362: EMPTY
105363: LIST
105364: LIST
105365: LIST
105366: PUSH
105367: LD_VAR 0 1
105371: PUSH
105372: LD_INT 4
105374: MINUS
105375: PUSH
105376: LD_VAR 0 2
105380: PUSH
105381: LD_INT 1
105383: PUSH
105384: EMPTY
105385: LIST
105386: LIST
105387: LIST
105388: PUSH
105389: LD_VAR 0 1
105393: PUSH
105394: LD_VAR 0 2
105398: PUSH
105399: LD_INT 4
105401: MINUS
105402: PUSH
105403: LD_INT 3
105405: PUSH
105406: EMPTY
105407: LIST
105408: LIST
105409: LIST
105410: PUSH
105411: LD_VAR 0 1
105415: PUSH
105416: LD_INT 3
105418: MINUS
105419: PUSH
105420: LD_VAR 0 2
105424: PUSH
105425: LD_INT 3
105427: MINUS
105428: PUSH
105429: LD_INT 2
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: LIST
105436: PUSH
105437: EMPTY
105438: LIST
105439: LIST
105440: LIST
105441: LIST
105442: LIST
105443: ST_TO_ADDR
// end ; 4 :
105444: GO 105725
105446: LD_INT 4
105448: DOUBLE
105449: EQUAL
105450: IFTRUE 105454
105452: GO 105587
105454: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105455: LD_ADDR_VAR 0 5
105459: PUSH
105460: LD_VAR 0 1
105464: PUSH
105465: LD_VAR 0 2
105469: PUSH
105470: LD_INT 4
105472: PLUS
105473: PUSH
105474: LD_INT 0
105476: PUSH
105477: EMPTY
105478: LIST
105479: LIST
105480: LIST
105481: PUSH
105482: LD_VAR 0 1
105486: PUSH
105487: LD_INT 3
105489: PLUS
105490: PUSH
105491: LD_VAR 0 2
105495: PUSH
105496: LD_INT 3
105498: PLUS
105499: PUSH
105500: LD_INT 5
105502: PUSH
105503: EMPTY
105504: LIST
105505: LIST
105506: LIST
105507: PUSH
105508: LD_VAR 0 1
105512: PUSH
105513: LD_INT 4
105515: PLUS
105516: PUSH
105517: LD_VAR 0 2
105521: PUSH
105522: LD_INT 4
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: LIST
105529: PUSH
105530: LD_VAR 0 1
105534: PUSH
105535: LD_VAR 0 2
105539: PUSH
105540: LD_INT 3
105542: MINUS
105543: PUSH
105544: LD_INT 3
105546: PUSH
105547: EMPTY
105548: LIST
105549: LIST
105550: LIST
105551: PUSH
105552: LD_VAR 0 1
105556: PUSH
105557: LD_INT 4
105559: MINUS
105560: PUSH
105561: LD_VAR 0 2
105565: PUSH
105566: LD_INT 4
105568: MINUS
105569: PUSH
105570: LD_INT 2
105572: PUSH
105573: EMPTY
105574: LIST
105575: LIST
105576: LIST
105577: PUSH
105578: EMPTY
105579: LIST
105580: LIST
105581: LIST
105582: LIST
105583: LIST
105584: ST_TO_ADDR
// end ; 5 :
105585: GO 105725
105587: LD_INT 5
105589: DOUBLE
105590: EQUAL
105591: IFTRUE 105595
105593: GO 105724
105595: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105596: LD_ADDR_VAR 0 5
105600: PUSH
105601: LD_VAR 0 1
105605: PUSH
105606: LD_INT 4
105608: MINUS
105609: PUSH
105610: LD_VAR 0 2
105614: PUSH
105615: LD_INT 1
105617: PUSH
105618: EMPTY
105619: LIST
105620: LIST
105621: LIST
105622: PUSH
105623: LD_VAR 0 1
105627: PUSH
105628: LD_VAR 0 2
105632: PUSH
105633: LD_INT 4
105635: MINUS
105636: PUSH
105637: LD_INT 3
105639: PUSH
105640: EMPTY
105641: LIST
105642: LIST
105643: LIST
105644: PUSH
105645: LD_VAR 0 1
105649: PUSH
105650: LD_INT 4
105652: PLUS
105653: PUSH
105654: LD_VAR 0 2
105658: PUSH
105659: LD_INT 4
105661: PLUS
105662: PUSH
105663: LD_INT 5
105665: PUSH
105666: EMPTY
105667: LIST
105668: LIST
105669: LIST
105670: PUSH
105671: LD_VAR 0 1
105675: PUSH
105676: LD_INT 3
105678: PLUS
105679: PUSH
105680: LD_VAR 0 2
105684: PUSH
105685: LD_INT 4
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: LIST
105692: PUSH
105693: LD_VAR 0 1
105697: PUSH
105698: LD_VAR 0 2
105702: PUSH
105703: LD_INT 3
105705: PLUS
105706: PUSH
105707: LD_INT 0
105709: PUSH
105710: EMPTY
105711: LIST
105712: LIST
105713: LIST
105714: PUSH
105715: EMPTY
105716: LIST
105717: LIST
105718: LIST
105719: LIST
105720: LIST
105721: ST_TO_ADDR
// end ; end ;
105722: GO 105725
105724: POP
// result := list ;
105725: LD_ADDR_VAR 0 4
105729: PUSH
105730: LD_VAR 0 5
105734: ST_TO_ADDR
// end ;
105735: LD_VAR 0 4
105739: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105740: LD_INT 0
105742: PPUSH
105743: PPUSH
105744: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105745: LD_VAR 0 1
105749: NOT
105750: PUSH
105751: LD_VAR 0 2
105755: PUSH
105756: LD_INT 1
105758: PUSH
105759: LD_INT 2
105761: PUSH
105762: LD_INT 3
105764: PUSH
105765: LD_INT 4
105767: PUSH
105768: EMPTY
105769: LIST
105770: LIST
105771: LIST
105772: LIST
105773: IN
105774: NOT
105775: OR
105776: IFFALSE 105780
// exit ;
105778: GO 105863
// tmp := [ ] ;
105780: LD_ADDR_VAR 0 5
105784: PUSH
105785: EMPTY
105786: ST_TO_ADDR
// for i in units do
105787: LD_ADDR_VAR 0 4
105791: PUSH
105792: LD_VAR 0 1
105796: PUSH
105797: FOR_IN
105798: IFFALSE 105832
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
105800: LD_ADDR_VAR 0 5
105804: PUSH
105805: LD_VAR 0 5
105809: PPUSH
105810: LD_VAR 0 4
105814: PPUSH
105815: LD_VAR 0 2
105819: PPUSH
105820: CALL_OW 259
105824: PPUSH
105825: CALL 107236 0 2
105829: ST_TO_ADDR
105830: GO 105797
105832: POP
105833: POP
// if not tmp then
105834: LD_VAR 0 5
105838: NOT
105839: IFFALSE 105843
// exit ;
105841: GO 105863
// result := SortListByListDesc ( units , tmp ) ;
105843: LD_ADDR_VAR 0 3
105847: PUSH
105848: LD_VAR 0 1
105852: PPUSH
105853: LD_VAR 0 5
105857: PPUSH
105858: CALL_OW 77
105862: ST_TO_ADDR
// end ;
105863: LD_VAR 0 3
105867: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105868: LD_INT 0
105870: PPUSH
105871: PPUSH
105872: PPUSH
// result := false ;
105873: LD_ADDR_VAR 0 3
105877: PUSH
105878: LD_INT 0
105880: ST_TO_ADDR
// if not building then
105881: LD_VAR 0 2
105885: NOT
105886: IFFALSE 105890
// exit ;
105888: GO 106028
// x := GetX ( building ) ;
105890: LD_ADDR_VAR 0 4
105894: PUSH
105895: LD_VAR 0 2
105899: PPUSH
105900: CALL_OW 250
105904: ST_TO_ADDR
// y := GetY ( building ) ;
105905: LD_ADDR_VAR 0 5
105909: PUSH
105910: LD_VAR 0 2
105914: PPUSH
105915: CALL_OW 251
105919: ST_TO_ADDR
// if not x or not y then
105920: LD_VAR 0 4
105924: NOT
105925: PUSH
105926: LD_VAR 0 5
105930: NOT
105931: OR
105932: IFFALSE 105936
// exit ;
105934: GO 106028
// if GetTaskList ( unit ) then
105936: LD_VAR 0 1
105940: PPUSH
105941: CALL_OW 437
105945: IFFALSE 106028
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105947: LD_STRING e
105949: PUSH
105950: LD_VAR 0 1
105954: PPUSH
105955: CALL_OW 437
105959: PUSH
105960: LD_INT 1
105962: ARRAY
105963: PUSH
105964: LD_INT 1
105966: ARRAY
105967: EQUAL
105968: PUSH
105969: LD_VAR 0 4
105973: PUSH
105974: LD_VAR 0 1
105978: PPUSH
105979: CALL_OW 437
105983: PUSH
105984: LD_INT 1
105986: ARRAY
105987: PUSH
105988: LD_INT 2
105990: ARRAY
105991: EQUAL
105992: AND
105993: PUSH
105994: LD_VAR 0 5
105998: PUSH
105999: LD_VAR 0 1
106003: PPUSH
106004: CALL_OW 437
106008: PUSH
106009: LD_INT 1
106011: ARRAY
106012: PUSH
106013: LD_INT 3
106015: ARRAY
106016: EQUAL
106017: AND
106018: IFFALSE 106028
// result := true end ;
106020: LD_ADDR_VAR 0 3
106024: PUSH
106025: LD_INT 1
106027: ST_TO_ADDR
// end ;
106028: LD_VAR 0 3
106032: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
106033: LD_INT 0
106035: PPUSH
// result := false ;
106036: LD_ADDR_VAR 0 4
106040: PUSH
106041: LD_INT 0
106043: ST_TO_ADDR
// if GetTaskList ( unit ) then
106044: LD_VAR 0 1
106048: PPUSH
106049: CALL_OW 437
106053: IFFALSE 106136
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106055: LD_STRING M
106057: PUSH
106058: LD_VAR 0 1
106062: PPUSH
106063: CALL_OW 437
106067: PUSH
106068: LD_INT 1
106070: ARRAY
106071: PUSH
106072: LD_INT 1
106074: ARRAY
106075: EQUAL
106076: PUSH
106077: LD_VAR 0 2
106081: PUSH
106082: LD_VAR 0 1
106086: PPUSH
106087: CALL_OW 437
106091: PUSH
106092: LD_INT 1
106094: ARRAY
106095: PUSH
106096: LD_INT 2
106098: ARRAY
106099: EQUAL
106100: AND
106101: PUSH
106102: LD_VAR 0 3
106106: PUSH
106107: LD_VAR 0 1
106111: PPUSH
106112: CALL_OW 437
106116: PUSH
106117: LD_INT 1
106119: ARRAY
106120: PUSH
106121: LD_INT 3
106123: ARRAY
106124: EQUAL
106125: AND
106126: IFFALSE 106136
// result := true ;
106128: LD_ADDR_VAR 0 4
106132: PUSH
106133: LD_INT 1
106135: ST_TO_ADDR
// end ; end ;
106136: LD_VAR 0 4
106140: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106141: LD_INT 0
106143: PPUSH
106144: PPUSH
106145: PPUSH
106146: PPUSH
// if not unit or not area then
106147: LD_VAR 0 1
106151: NOT
106152: PUSH
106153: LD_VAR 0 2
106157: NOT
106158: OR
106159: IFFALSE 106163
// exit ;
106161: GO 106339
// tmp := AreaToList ( area , i ) ;
106163: LD_ADDR_VAR 0 6
106167: PUSH
106168: LD_VAR 0 2
106172: PPUSH
106173: LD_VAR 0 5
106177: PPUSH
106178: CALL_OW 517
106182: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106183: LD_ADDR_VAR 0 5
106187: PUSH
106188: DOUBLE
106189: LD_INT 1
106191: DEC
106192: ST_TO_ADDR
106193: LD_VAR 0 6
106197: PUSH
106198: LD_INT 1
106200: ARRAY
106201: PUSH
106202: FOR_TO
106203: IFFALSE 106337
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106205: LD_ADDR_VAR 0 7
106209: PUSH
106210: LD_VAR 0 6
106214: PUSH
106215: LD_INT 1
106217: ARRAY
106218: PUSH
106219: LD_VAR 0 5
106223: ARRAY
106224: PUSH
106225: LD_VAR 0 6
106229: PUSH
106230: LD_INT 2
106232: ARRAY
106233: PUSH
106234: LD_VAR 0 5
106238: ARRAY
106239: PUSH
106240: EMPTY
106241: LIST
106242: LIST
106243: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
106244: LD_INT 92
106246: PUSH
106247: LD_VAR 0 7
106251: PUSH
106252: LD_INT 1
106254: ARRAY
106255: PUSH
106256: LD_VAR 0 7
106260: PUSH
106261: LD_INT 2
106263: ARRAY
106264: PUSH
106265: LD_INT 2
106267: PUSH
106268: EMPTY
106269: LIST
106270: LIST
106271: LIST
106272: LIST
106273: PPUSH
106274: CALL_OW 69
106278: PUSH
106279: LD_INT 0
106281: EQUAL
106282: IFFALSE 106335
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106284: LD_VAR 0 1
106288: PPUSH
106289: LD_VAR 0 7
106293: PUSH
106294: LD_INT 1
106296: ARRAY
106297: PPUSH
106298: LD_VAR 0 7
106302: PUSH
106303: LD_INT 2
106305: ARRAY
106306: PPUSH
106307: LD_VAR 0 3
106311: PPUSH
106312: CALL_OW 48
// result := IsPlaced ( unit ) ;
106316: LD_ADDR_VAR 0 4
106320: PUSH
106321: LD_VAR 0 1
106325: PPUSH
106326: CALL_OW 305
106330: ST_TO_ADDR
// exit ;
106331: POP
106332: POP
106333: GO 106339
// end ; end ;
106335: GO 106202
106337: POP
106338: POP
// end ;
106339: LD_VAR 0 4
106343: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106344: LD_INT 0
106346: PPUSH
106347: PPUSH
106348: PPUSH
// if not side or side > 8 then
106349: LD_VAR 0 1
106353: NOT
106354: PUSH
106355: LD_VAR 0 1
106359: PUSH
106360: LD_INT 8
106362: GREATER
106363: OR
106364: IFFALSE 106368
// exit ;
106366: GO 106555
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106368: LD_ADDR_VAR 0 4
106372: PUSH
106373: LD_INT 22
106375: PUSH
106376: LD_VAR 0 1
106380: PUSH
106381: EMPTY
106382: LIST
106383: LIST
106384: PUSH
106385: LD_INT 21
106387: PUSH
106388: LD_INT 3
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: PUSH
106395: EMPTY
106396: LIST
106397: LIST
106398: PPUSH
106399: CALL_OW 69
106403: ST_TO_ADDR
// if not tmp then
106404: LD_VAR 0 4
106408: NOT
106409: IFFALSE 106413
// exit ;
106411: GO 106555
// enable_addtolog := true ;
106413: LD_ADDR_OWVAR 81
106417: PUSH
106418: LD_INT 1
106420: ST_TO_ADDR
// AddToLog ( [ ) ;
106421: LD_STRING [
106423: PPUSH
106424: CALL_OW 561
// for i in tmp do
106428: LD_ADDR_VAR 0 3
106432: PUSH
106433: LD_VAR 0 4
106437: PUSH
106438: FOR_IN
106439: IFFALSE 106546
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106441: LD_STRING [
106443: PUSH
106444: LD_VAR 0 3
106448: PPUSH
106449: CALL_OW 266
106453: STR
106454: PUSH
106455: LD_STRING , 
106457: STR
106458: PUSH
106459: LD_VAR 0 3
106463: PPUSH
106464: CALL_OW 250
106468: STR
106469: PUSH
106470: LD_STRING , 
106472: STR
106473: PUSH
106474: LD_VAR 0 3
106478: PPUSH
106479: CALL_OW 251
106483: STR
106484: PUSH
106485: LD_STRING , 
106487: STR
106488: PUSH
106489: LD_VAR 0 3
106493: PPUSH
106494: CALL_OW 254
106498: STR
106499: PUSH
106500: LD_STRING , 
106502: STR
106503: PUSH
106504: LD_VAR 0 3
106508: PPUSH
106509: LD_INT 1
106511: PPUSH
106512: CALL_OW 268
106516: STR
106517: PUSH
106518: LD_STRING , 
106520: STR
106521: PUSH
106522: LD_VAR 0 3
106526: PPUSH
106527: LD_INT 2
106529: PPUSH
106530: CALL_OW 268
106534: STR
106535: PUSH
106536: LD_STRING ],
106538: STR
106539: PPUSH
106540: CALL_OW 561
// end ;
106544: GO 106438
106546: POP
106547: POP
// AddToLog ( ]; ) ;
106548: LD_STRING ];
106550: PPUSH
106551: CALL_OW 561
// end ;
106555: LD_VAR 0 2
106559: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106560: LD_INT 0
106562: PPUSH
106563: PPUSH
106564: PPUSH
106565: PPUSH
106566: PPUSH
// if not area or not rate or not max then
106567: LD_VAR 0 1
106571: NOT
106572: PUSH
106573: LD_VAR 0 2
106577: NOT
106578: OR
106579: PUSH
106580: LD_VAR 0 4
106584: NOT
106585: OR
106586: IFFALSE 106590
// exit ;
106588: GO 106779
// while 1 do
106590: LD_INT 1
106592: IFFALSE 106779
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106594: LD_ADDR_VAR 0 9
106598: PUSH
106599: LD_VAR 0 1
106603: PPUSH
106604: LD_INT 1
106606: PPUSH
106607: CALL_OW 287
106611: PUSH
106612: LD_INT 10
106614: MUL
106615: ST_TO_ADDR
// r := rate / 10 ;
106616: LD_ADDR_VAR 0 7
106620: PUSH
106621: LD_VAR 0 2
106625: PUSH
106626: LD_INT 10
106628: DIVREAL
106629: ST_TO_ADDR
// time := 1 1$00 ;
106630: LD_ADDR_VAR 0 8
106634: PUSH
106635: LD_INT 2100
106637: ST_TO_ADDR
// if amount < min then
106638: LD_VAR 0 9
106642: PUSH
106643: LD_VAR 0 3
106647: LESS
106648: IFFALSE 106666
// r := r * 2 else
106650: LD_ADDR_VAR 0 7
106654: PUSH
106655: LD_VAR 0 7
106659: PUSH
106660: LD_INT 2
106662: MUL
106663: ST_TO_ADDR
106664: GO 106692
// if amount > max then
106666: LD_VAR 0 9
106670: PUSH
106671: LD_VAR 0 4
106675: GREATER
106676: IFFALSE 106692
// r := r / 2 ;
106678: LD_ADDR_VAR 0 7
106682: PUSH
106683: LD_VAR 0 7
106687: PUSH
106688: LD_INT 2
106690: DIVREAL
106691: ST_TO_ADDR
// time := time / r ;
106692: LD_ADDR_VAR 0 8
106696: PUSH
106697: LD_VAR 0 8
106701: PUSH
106702: LD_VAR 0 7
106706: DIVREAL
106707: ST_TO_ADDR
// if time < 0 then
106708: LD_VAR 0 8
106712: PUSH
106713: LD_INT 0
106715: LESS
106716: IFFALSE 106733
// time := time * - 1 ;
106718: LD_ADDR_VAR 0 8
106722: PUSH
106723: LD_VAR 0 8
106727: PUSH
106728: LD_INT 1
106730: NEG
106731: MUL
106732: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
106733: LD_VAR 0 8
106737: PUSH
106738: LD_INT 35
106740: PPUSH
106741: LD_INT 875
106743: PPUSH
106744: CALL_OW 12
106748: PLUS
106749: PPUSH
106750: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106754: LD_INT 1
106756: PPUSH
106757: LD_INT 5
106759: PPUSH
106760: CALL_OW 12
106764: PPUSH
106765: LD_VAR 0 1
106769: PPUSH
106770: LD_INT 1
106772: PPUSH
106773: CALL_OW 55
// end ;
106777: GO 106590
// end ;
106779: LD_VAR 0 5
106783: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106784: LD_INT 0
106786: PPUSH
106787: PPUSH
106788: PPUSH
106789: PPUSH
106790: PPUSH
106791: PPUSH
106792: PPUSH
106793: PPUSH
// if not turrets or not factories then
106794: LD_VAR 0 1
106798: NOT
106799: PUSH
106800: LD_VAR 0 2
106804: NOT
106805: OR
106806: IFFALSE 106810
// exit ;
106808: GO 107117
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106810: LD_ADDR_VAR 0 10
106814: PUSH
106815: LD_INT 5
106817: PUSH
106818: LD_INT 6
106820: PUSH
106821: EMPTY
106822: LIST
106823: LIST
106824: PUSH
106825: LD_INT 2
106827: PUSH
106828: LD_INT 4
106830: PUSH
106831: EMPTY
106832: LIST
106833: LIST
106834: PUSH
106835: LD_INT 3
106837: PUSH
106838: LD_INT 5
106840: PUSH
106841: EMPTY
106842: LIST
106843: LIST
106844: PUSH
106845: EMPTY
106846: LIST
106847: LIST
106848: LIST
106849: PUSH
106850: LD_INT 24
106852: PUSH
106853: LD_INT 25
106855: PUSH
106856: EMPTY
106857: LIST
106858: LIST
106859: PUSH
106860: LD_INT 23
106862: PUSH
106863: LD_INT 27
106865: PUSH
106866: EMPTY
106867: LIST
106868: LIST
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: PUSH
106874: LD_INT 42
106876: PUSH
106877: LD_INT 43
106879: PUSH
106880: EMPTY
106881: LIST
106882: LIST
106883: PUSH
106884: LD_INT 44
106886: PUSH
106887: LD_INT 46
106889: PUSH
106890: EMPTY
106891: LIST
106892: LIST
106893: PUSH
106894: LD_INT 45
106896: PUSH
106897: LD_INT 47
106899: PUSH
106900: EMPTY
106901: LIST
106902: LIST
106903: PUSH
106904: EMPTY
106905: LIST
106906: LIST
106907: LIST
106908: PUSH
106909: EMPTY
106910: LIST
106911: LIST
106912: LIST
106913: ST_TO_ADDR
// result := [ ] ;
106914: LD_ADDR_VAR 0 3
106918: PUSH
106919: EMPTY
106920: ST_TO_ADDR
// for i in turrets do
106921: LD_ADDR_VAR 0 4
106925: PUSH
106926: LD_VAR 0 1
106930: PUSH
106931: FOR_IN
106932: IFFALSE 107115
// begin nat := GetNation ( i ) ;
106934: LD_ADDR_VAR 0 7
106938: PUSH
106939: LD_VAR 0 4
106943: PPUSH
106944: CALL_OW 248
106948: ST_TO_ADDR
// weapon := 0 ;
106949: LD_ADDR_VAR 0 8
106953: PUSH
106954: LD_INT 0
106956: ST_TO_ADDR
// if not nat then
106957: LD_VAR 0 7
106961: NOT
106962: IFFALSE 106966
// continue ;
106964: GO 106931
// for j in list [ nat ] do
106966: LD_ADDR_VAR 0 5
106970: PUSH
106971: LD_VAR 0 10
106975: PUSH
106976: LD_VAR 0 7
106980: ARRAY
106981: PUSH
106982: FOR_IN
106983: IFFALSE 107024
// if GetBWeapon ( i ) = j [ 1 ] then
106985: LD_VAR 0 4
106989: PPUSH
106990: CALL_OW 269
106994: PUSH
106995: LD_VAR 0 5
106999: PUSH
107000: LD_INT 1
107002: ARRAY
107003: EQUAL
107004: IFFALSE 107022
// begin weapon := j [ 2 ] ;
107006: LD_ADDR_VAR 0 8
107010: PUSH
107011: LD_VAR 0 5
107015: PUSH
107016: LD_INT 2
107018: ARRAY
107019: ST_TO_ADDR
// break ;
107020: GO 107024
// end ;
107022: GO 106982
107024: POP
107025: POP
// if not weapon then
107026: LD_VAR 0 8
107030: NOT
107031: IFFALSE 107035
// continue ;
107033: GO 106931
// for k in factories do
107035: LD_ADDR_VAR 0 6
107039: PUSH
107040: LD_VAR 0 2
107044: PUSH
107045: FOR_IN
107046: IFFALSE 107111
// begin weapons := AvailableWeaponList ( k ) ;
107048: LD_ADDR_VAR 0 9
107052: PUSH
107053: LD_VAR 0 6
107057: PPUSH
107058: CALL_OW 478
107062: ST_TO_ADDR
// if not weapons then
107063: LD_VAR 0 9
107067: NOT
107068: IFFALSE 107072
// continue ;
107070: GO 107045
// if weapon in weapons then
107072: LD_VAR 0 8
107076: PUSH
107077: LD_VAR 0 9
107081: IN
107082: IFFALSE 107109
// begin result := [ i , weapon ] ;
107084: LD_ADDR_VAR 0 3
107088: PUSH
107089: LD_VAR 0 4
107093: PUSH
107094: LD_VAR 0 8
107098: PUSH
107099: EMPTY
107100: LIST
107101: LIST
107102: ST_TO_ADDR
// exit ;
107103: POP
107104: POP
107105: POP
107106: POP
107107: GO 107117
// end ; end ;
107109: GO 107045
107111: POP
107112: POP
// end ;
107113: GO 106931
107115: POP
107116: POP
// end ;
107117: LD_VAR 0 3
107121: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107122: LD_INT 0
107124: PPUSH
// if not side or side > 8 then
107125: LD_VAR 0 3
107129: NOT
107130: PUSH
107131: LD_VAR 0 3
107135: PUSH
107136: LD_INT 8
107138: GREATER
107139: OR
107140: IFFALSE 107144
// exit ;
107142: GO 107203
// if not range then
107144: LD_VAR 0 4
107148: NOT
107149: IFFALSE 107160
// range := - 12 ;
107151: LD_ADDR_VAR 0 4
107155: PUSH
107156: LD_INT 12
107158: NEG
107159: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107160: LD_VAR 0 1
107164: PPUSH
107165: LD_VAR 0 2
107169: PPUSH
107170: LD_VAR 0 3
107174: PPUSH
107175: LD_VAR 0 4
107179: PPUSH
107180: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107184: LD_VAR 0 1
107188: PPUSH
107189: LD_VAR 0 2
107193: PPUSH
107194: LD_VAR 0 3
107198: PPUSH
107199: CALL_OW 331
// end ;
107203: LD_VAR 0 5
107207: RET
// export function Video ( mode ) ; begin
107208: LD_INT 0
107210: PPUSH
// ingame_video = mode ;
107211: LD_ADDR_OWVAR 52
107215: PUSH
107216: LD_VAR 0 1
107220: ST_TO_ADDR
// interface_hidden = mode ;
107221: LD_ADDR_OWVAR 54
107225: PUSH
107226: LD_VAR 0 1
107230: ST_TO_ADDR
// end ;
107231: LD_VAR 0 2
107235: RET
// export function Join ( array , element ) ; begin
107236: LD_INT 0
107238: PPUSH
// result := Replace ( array , array + 1 , element ) ;
107239: LD_ADDR_VAR 0 3
107243: PUSH
107244: LD_VAR 0 1
107248: PPUSH
107249: LD_VAR 0 1
107253: PUSH
107254: LD_INT 1
107256: PLUS
107257: PPUSH
107258: LD_VAR 0 2
107262: PPUSH
107263: CALL_OW 1
107267: ST_TO_ADDR
// end ;
107268: LD_VAR 0 3
107272: RET
// export function JoinUnion ( array , element ) ; begin
107273: LD_INT 0
107275: PPUSH
// result := array union element ;
107276: LD_ADDR_VAR 0 3
107280: PUSH
107281: LD_VAR 0 1
107285: PUSH
107286: LD_VAR 0 2
107290: UNION
107291: ST_TO_ADDR
// end ;
107292: LD_VAR 0 3
107296: RET
// export function GetBehemoths ( side ) ; begin
107297: LD_INT 0
107299: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
107300: LD_ADDR_VAR 0 2
107304: PUSH
107305: LD_INT 22
107307: PUSH
107308: LD_VAR 0 1
107312: PUSH
107313: EMPTY
107314: LIST
107315: LIST
107316: PUSH
107317: LD_INT 31
107319: PUSH
107320: LD_INT 25
107322: PUSH
107323: EMPTY
107324: LIST
107325: LIST
107326: PUSH
107327: EMPTY
107328: LIST
107329: LIST
107330: PPUSH
107331: CALL_OW 69
107335: ST_TO_ADDR
// end ;
107336: LD_VAR 0 2
107340: RET
// export function Shuffle ( array ) ; var i , index ; begin
107341: LD_INT 0
107343: PPUSH
107344: PPUSH
107345: PPUSH
// result := [ ] ;
107346: LD_ADDR_VAR 0 2
107350: PUSH
107351: EMPTY
107352: ST_TO_ADDR
// if not array then
107353: LD_VAR 0 1
107357: NOT
107358: IFFALSE 107362
// exit ;
107360: GO 107461
// Randomize ;
107362: CALL_OW 10
// for i = array downto 1 do
107366: LD_ADDR_VAR 0 3
107370: PUSH
107371: DOUBLE
107372: LD_VAR 0 1
107376: INC
107377: ST_TO_ADDR
107378: LD_INT 1
107380: PUSH
107381: FOR_DOWNTO
107382: IFFALSE 107459
// begin index := rand ( 1 , array ) ;
107384: LD_ADDR_VAR 0 4
107388: PUSH
107389: LD_INT 1
107391: PPUSH
107392: LD_VAR 0 1
107396: PPUSH
107397: CALL_OW 12
107401: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107402: LD_ADDR_VAR 0 2
107406: PUSH
107407: LD_VAR 0 2
107411: PPUSH
107412: LD_VAR 0 2
107416: PUSH
107417: LD_INT 1
107419: PLUS
107420: PPUSH
107421: LD_VAR 0 1
107425: PUSH
107426: LD_VAR 0 4
107430: ARRAY
107431: PPUSH
107432: CALL_OW 2
107436: ST_TO_ADDR
// array := Delete ( array , index ) ;
107437: LD_ADDR_VAR 0 1
107441: PUSH
107442: LD_VAR 0 1
107446: PPUSH
107447: LD_VAR 0 4
107451: PPUSH
107452: CALL_OW 3
107456: ST_TO_ADDR
// end ;
107457: GO 107381
107459: POP
107460: POP
// end ;
107461: LD_VAR 0 2
107465: RET
// export function GetBaseMaterials ( base ) ; begin
107466: LD_INT 0
107468: PPUSH
// result := [ 0 , 0 , 0 ] ;
107469: LD_ADDR_VAR 0 2
107473: PUSH
107474: LD_INT 0
107476: PUSH
107477: LD_INT 0
107479: PUSH
107480: LD_INT 0
107482: PUSH
107483: EMPTY
107484: LIST
107485: LIST
107486: LIST
107487: ST_TO_ADDR
// if not base then
107488: LD_VAR 0 1
107492: NOT
107493: IFFALSE 107497
// exit ;
107495: GO 107546
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107497: LD_ADDR_VAR 0 2
107501: PUSH
107502: LD_VAR 0 1
107506: PPUSH
107507: LD_INT 1
107509: PPUSH
107510: CALL_OW 275
107514: PUSH
107515: LD_VAR 0 1
107519: PPUSH
107520: LD_INT 2
107522: PPUSH
107523: CALL_OW 275
107527: PUSH
107528: LD_VAR 0 1
107532: PPUSH
107533: LD_INT 3
107535: PPUSH
107536: CALL_OW 275
107540: PUSH
107541: EMPTY
107542: LIST
107543: LIST
107544: LIST
107545: ST_TO_ADDR
// end ;
107546: LD_VAR 0 2
107550: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
107551: LD_INT 0
107553: PPUSH
107554: PPUSH
// result := array ;
107555: LD_ADDR_VAR 0 3
107559: PUSH
107560: LD_VAR 0 1
107564: ST_TO_ADDR
// if size >= result then
107565: LD_VAR 0 2
107569: PUSH
107570: LD_VAR 0 3
107574: GREATEREQUAL
107575: IFFALSE 107579
// exit ;
107577: GO 107629
// if size then
107579: LD_VAR 0 2
107583: IFFALSE 107629
// for i := array downto size do
107585: LD_ADDR_VAR 0 4
107589: PUSH
107590: DOUBLE
107591: LD_VAR 0 1
107595: INC
107596: ST_TO_ADDR
107597: LD_VAR 0 2
107601: PUSH
107602: FOR_DOWNTO
107603: IFFALSE 107627
// result := Delete ( result , result ) ;
107605: LD_ADDR_VAR 0 3
107609: PUSH
107610: LD_VAR 0 3
107614: PPUSH
107615: LD_VAR 0 3
107619: PPUSH
107620: CALL_OW 3
107624: ST_TO_ADDR
107625: GO 107602
107627: POP
107628: POP
// end ;
107629: LD_VAR 0 3
107633: RET
// export function ComExit ( unit ) ; var tmp ; begin
107634: LD_INT 0
107636: PPUSH
107637: PPUSH
// if not IsInUnit ( unit ) then
107638: LD_VAR 0 1
107642: PPUSH
107643: CALL_OW 310
107647: NOT
107648: IFFALSE 107652
// exit ;
107650: GO 107712
// tmp := IsInUnit ( unit ) ;
107652: LD_ADDR_VAR 0 3
107656: PUSH
107657: LD_VAR 0 1
107661: PPUSH
107662: CALL_OW 310
107666: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
107667: LD_VAR 0 3
107671: PPUSH
107672: CALL_OW 247
107676: PUSH
107677: LD_INT 2
107679: EQUAL
107680: IFFALSE 107693
// ComExitVehicle ( unit ) else
107682: LD_VAR 0 1
107686: PPUSH
107687: CALL_OW 121
107691: GO 107702
// ComExitBuilding ( unit ) ;
107693: LD_VAR 0 1
107697: PPUSH
107698: CALL_OW 122
// result := tmp ;
107702: LD_ADDR_VAR 0 2
107706: PUSH
107707: LD_VAR 0 3
107711: ST_TO_ADDR
// end ;
107712: LD_VAR 0 2
107716: RET
// export function ComExitAll ( units ) ; var i ; begin
107717: LD_INT 0
107719: PPUSH
107720: PPUSH
// if not units then
107721: LD_VAR 0 1
107725: NOT
107726: IFFALSE 107730
// exit ;
107728: GO 107756
// for i in units do
107730: LD_ADDR_VAR 0 3
107734: PUSH
107735: LD_VAR 0 1
107739: PUSH
107740: FOR_IN
107741: IFFALSE 107754
// ComExit ( i ) ;
107743: LD_VAR 0 3
107747: PPUSH
107748: CALL 107634 0 1
107752: GO 107740
107754: POP
107755: POP
// end ;
107756: LD_VAR 0 2
107760: RET
// export function ResetHc ; begin
107761: LD_INT 0
107763: PPUSH
// InitHc ;
107764: CALL_OW 19
// hc_importance := 0 ;
107768: LD_ADDR_OWVAR 32
107772: PUSH
107773: LD_INT 0
107775: ST_TO_ADDR
// end ;
107776: LD_VAR 0 1
107780: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
107781: LD_INT 0
107783: PPUSH
107784: PPUSH
107785: PPUSH
// _x := ( x1 + x2 ) div 2 ;
107786: LD_ADDR_VAR 0 6
107790: PUSH
107791: LD_VAR 0 1
107795: PUSH
107796: LD_VAR 0 3
107800: PLUS
107801: PUSH
107802: LD_INT 2
107804: DIV
107805: ST_TO_ADDR
// if _x < 0 then
107806: LD_VAR 0 6
107810: PUSH
107811: LD_INT 0
107813: LESS
107814: IFFALSE 107831
// _x := _x * - 1 ;
107816: LD_ADDR_VAR 0 6
107820: PUSH
107821: LD_VAR 0 6
107825: PUSH
107826: LD_INT 1
107828: NEG
107829: MUL
107830: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
107831: LD_ADDR_VAR 0 7
107835: PUSH
107836: LD_VAR 0 2
107840: PUSH
107841: LD_VAR 0 4
107845: PLUS
107846: PUSH
107847: LD_INT 2
107849: DIV
107850: ST_TO_ADDR
// if _y < 0 then
107851: LD_VAR 0 7
107855: PUSH
107856: LD_INT 0
107858: LESS
107859: IFFALSE 107876
// _y := _y * - 1 ;
107861: LD_ADDR_VAR 0 7
107865: PUSH
107866: LD_VAR 0 7
107870: PUSH
107871: LD_INT 1
107873: NEG
107874: MUL
107875: ST_TO_ADDR
// result := [ _x , _y ] ;
107876: LD_ADDR_VAR 0 5
107880: PUSH
107881: LD_VAR 0 6
107885: PUSH
107886: LD_VAR 0 7
107890: PUSH
107891: EMPTY
107892: LIST
107893: LIST
107894: ST_TO_ADDR
// end ;
107895: LD_VAR 0 5
107899: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
107900: LD_INT 0
107902: PPUSH
107903: PPUSH
107904: PPUSH
107905: PPUSH
// task := GetTaskList ( unit ) ;
107906: LD_ADDR_VAR 0 7
107910: PUSH
107911: LD_VAR 0 1
107915: PPUSH
107916: CALL_OW 437
107920: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
107921: LD_VAR 0 7
107925: NOT
107926: PUSH
107927: LD_VAR 0 1
107931: PPUSH
107932: LD_VAR 0 2
107936: PPUSH
107937: CALL_OW 308
107941: NOT
107942: AND
107943: IFFALSE 107947
// exit ;
107945: GO 108065
// if IsInArea ( unit , area ) then
107947: LD_VAR 0 1
107951: PPUSH
107952: LD_VAR 0 2
107956: PPUSH
107957: CALL_OW 308
107961: IFFALSE 107979
// begin ComMoveToArea ( unit , goAway ) ;
107963: LD_VAR 0 1
107967: PPUSH
107968: LD_VAR 0 3
107972: PPUSH
107973: CALL_OW 113
// exit ;
107977: GO 108065
// end ; if task [ 1 ] [ 1 ] <> M then
107979: LD_VAR 0 7
107983: PUSH
107984: LD_INT 1
107986: ARRAY
107987: PUSH
107988: LD_INT 1
107990: ARRAY
107991: PUSH
107992: LD_STRING M
107994: NONEQUAL
107995: IFFALSE 107999
// exit ;
107997: GO 108065
// x := task [ 1 ] [ 2 ] ;
107999: LD_ADDR_VAR 0 5
108003: PUSH
108004: LD_VAR 0 7
108008: PUSH
108009: LD_INT 1
108011: ARRAY
108012: PUSH
108013: LD_INT 2
108015: ARRAY
108016: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
108017: LD_ADDR_VAR 0 6
108021: PUSH
108022: LD_VAR 0 7
108026: PUSH
108027: LD_INT 1
108029: ARRAY
108030: PUSH
108031: LD_INT 3
108033: ARRAY
108034: ST_TO_ADDR
// if InArea ( x , y , area ) then
108035: LD_VAR 0 5
108039: PPUSH
108040: LD_VAR 0 6
108044: PPUSH
108045: LD_VAR 0 2
108049: PPUSH
108050: CALL_OW 309
108054: IFFALSE 108065
// ComStop ( unit ) ;
108056: LD_VAR 0 1
108060: PPUSH
108061: CALL_OW 141
// end ;
108065: LD_VAR 0 4
108069: RET
// export function Abs ( value ) ; begin
108070: LD_INT 0
108072: PPUSH
// result := value ;
108073: LD_ADDR_VAR 0 2
108077: PUSH
108078: LD_VAR 0 1
108082: ST_TO_ADDR
// if value < 0 then
108083: LD_VAR 0 1
108087: PUSH
108088: LD_INT 0
108090: LESS
108091: IFFALSE 108108
// result := value * - 1 ;
108093: LD_ADDR_VAR 0 2
108097: PUSH
108098: LD_VAR 0 1
108102: PUSH
108103: LD_INT 1
108105: NEG
108106: MUL
108107: ST_TO_ADDR
// end ;
108108: LD_VAR 0 2
108112: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
108113: LD_INT 0
108115: PPUSH
108116: PPUSH
108117: PPUSH
108118: PPUSH
108119: PPUSH
108120: PPUSH
108121: PPUSH
108122: PPUSH
// if not unit or not building then
108123: LD_VAR 0 1
108127: NOT
108128: PUSH
108129: LD_VAR 0 2
108133: NOT
108134: OR
108135: IFFALSE 108139
// exit ;
108137: GO 108365
// x := GetX ( building ) ;
108139: LD_ADDR_VAR 0 4
108143: PUSH
108144: LD_VAR 0 2
108148: PPUSH
108149: CALL_OW 250
108153: ST_TO_ADDR
// y := GetY ( building ) ;
108154: LD_ADDR_VAR 0 6
108158: PUSH
108159: LD_VAR 0 2
108163: PPUSH
108164: CALL_OW 251
108168: ST_TO_ADDR
// d := GetDir ( building ) ;
108169: LD_ADDR_VAR 0 8
108173: PUSH
108174: LD_VAR 0 2
108178: PPUSH
108179: CALL_OW 254
108183: ST_TO_ADDR
// r := 4 ;
108184: LD_ADDR_VAR 0 9
108188: PUSH
108189: LD_INT 4
108191: ST_TO_ADDR
// for i := 1 to 5 do
108192: LD_ADDR_VAR 0 10
108196: PUSH
108197: DOUBLE
108198: LD_INT 1
108200: DEC
108201: ST_TO_ADDR
108202: LD_INT 5
108204: PUSH
108205: FOR_TO
108206: IFFALSE 108363
// begin _x := ShiftX ( x , d , r + i ) ;
108208: LD_ADDR_VAR 0 5
108212: PUSH
108213: LD_VAR 0 4
108217: PPUSH
108218: LD_VAR 0 8
108222: PPUSH
108223: LD_VAR 0 9
108227: PUSH
108228: LD_VAR 0 10
108232: PLUS
108233: PPUSH
108234: CALL_OW 272
108238: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
108239: LD_ADDR_VAR 0 7
108243: PUSH
108244: LD_VAR 0 6
108248: PPUSH
108249: LD_VAR 0 8
108253: PPUSH
108254: LD_VAR 0 9
108258: PUSH
108259: LD_VAR 0 10
108263: PLUS
108264: PPUSH
108265: CALL_OW 273
108269: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
108270: LD_VAR 0 5
108274: PPUSH
108275: LD_VAR 0 7
108279: PPUSH
108280: CALL_OW 488
108284: PUSH
108285: LD_VAR 0 5
108289: PPUSH
108290: LD_VAR 0 7
108294: PPUSH
108295: CALL_OW 428
108299: PPUSH
108300: CALL_OW 247
108304: PUSH
108305: LD_INT 3
108307: PUSH
108308: LD_INT 2
108310: PUSH
108311: EMPTY
108312: LIST
108313: LIST
108314: IN
108315: NOT
108316: AND
108317: IFFALSE 108361
// begin ComMoveXY ( unit , _x , _y ) ;
108319: LD_VAR 0 1
108323: PPUSH
108324: LD_VAR 0 5
108328: PPUSH
108329: LD_VAR 0 7
108333: PPUSH
108334: CALL_OW 111
// result := [ _x , _y ] ;
108338: LD_ADDR_VAR 0 3
108342: PUSH
108343: LD_VAR 0 5
108347: PUSH
108348: LD_VAR 0 7
108352: PUSH
108353: EMPTY
108354: LIST
108355: LIST
108356: ST_TO_ADDR
// exit ;
108357: POP
108358: POP
108359: GO 108365
// end ; end ;
108361: GO 108205
108363: POP
108364: POP
// end ;
108365: LD_VAR 0 3
108369: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
108370: LD_INT 0
108372: PPUSH
108373: PPUSH
108374: PPUSH
// result := 0 ;
108375: LD_ADDR_VAR 0 3
108379: PUSH
108380: LD_INT 0
108382: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
108383: LD_VAR 0 1
108387: PUSH
108388: LD_INT 0
108390: LESS
108391: PUSH
108392: LD_VAR 0 1
108396: PUSH
108397: LD_INT 8
108399: GREATER
108400: OR
108401: PUSH
108402: LD_VAR 0 2
108406: PUSH
108407: LD_INT 0
108409: LESS
108410: OR
108411: PUSH
108412: LD_VAR 0 2
108416: PUSH
108417: LD_INT 8
108419: GREATER
108420: OR
108421: IFFALSE 108425
// exit ;
108423: GO 108500
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
108425: LD_ADDR_VAR 0 4
108429: PUSH
108430: LD_INT 22
108432: PUSH
108433: LD_VAR 0 2
108437: PUSH
108438: EMPTY
108439: LIST
108440: LIST
108441: PPUSH
108442: CALL_OW 69
108446: PUSH
108447: FOR_IN
108448: IFFALSE 108498
// begin un := UnitShoot ( i ) ;
108450: LD_ADDR_VAR 0 5
108454: PUSH
108455: LD_VAR 0 4
108459: PPUSH
108460: CALL_OW 504
108464: ST_TO_ADDR
// if GetSide ( un ) = side1 then
108465: LD_VAR 0 5
108469: PPUSH
108470: CALL_OW 255
108474: PUSH
108475: LD_VAR 0 1
108479: EQUAL
108480: IFFALSE 108496
// begin result := un ;
108482: LD_ADDR_VAR 0 3
108486: PUSH
108487: LD_VAR 0 5
108491: ST_TO_ADDR
// exit ;
108492: POP
108493: POP
108494: GO 108500
// end ; end ;
108496: GO 108447
108498: POP
108499: POP
// end ;
108500: LD_VAR 0 3
108504: RET
// export function GetCargoBay ( units ) ; begin
108505: LD_INT 0
108507: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
108508: LD_ADDR_VAR 0 2
108512: PUSH
108513: LD_VAR 0 1
108517: PPUSH
108518: LD_INT 2
108520: PUSH
108521: LD_INT 34
108523: PUSH
108524: LD_INT 12
108526: PUSH
108527: EMPTY
108528: LIST
108529: LIST
108530: PUSH
108531: LD_INT 34
108533: PUSH
108534: LD_INT 51
108536: PUSH
108537: EMPTY
108538: LIST
108539: LIST
108540: PUSH
108541: LD_INT 34
108543: PUSH
108544: LD_INT 32
108546: PUSH
108547: EMPTY
108548: LIST
108549: LIST
108550: PUSH
108551: LD_INT 34
108553: PUSH
108554: LD_INT 89
108556: PUSH
108557: EMPTY
108558: LIST
108559: LIST
108560: PUSH
108561: EMPTY
108562: LIST
108563: LIST
108564: LIST
108565: LIST
108566: LIST
108567: PPUSH
108568: CALL_OW 72
108572: ST_TO_ADDR
// end ;
108573: LD_VAR 0 2
108577: RET
// export function Negate ( value ) ; begin
108578: LD_INT 0
108580: PPUSH
// result := not value ;
108581: LD_ADDR_VAR 0 2
108585: PUSH
108586: LD_VAR 0 1
108590: NOT
108591: ST_TO_ADDR
// end ;
108592: LD_VAR 0 2
108596: RET
// export function Inc ( value ) ; begin
108597: LD_INT 0
108599: PPUSH
// result := value + 1 ;
108600: LD_ADDR_VAR 0 2
108604: PUSH
108605: LD_VAR 0 1
108609: PUSH
108610: LD_INT 1
108612: PLUS
108613: ST_TO_ADDR
// end ;
108614: LD_VAR 0 2
108618: RET
// export function Dec ( value ) ; begin
108619: LD_INT 0
108621: PPUSH
// result := value - 1 ;
108622: LD_ADDR_VAR 0 2
108626: PUSH
108627: LD_VAR 0 1
108631: PUSH
108632: LD_INT 1
108634: MINUS
108635: ST_TO_ADDR
// end ;
108636: LD_VAR 0 2
108640: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
108641: LD_INT 0
108643: PPUSH
108644: PPUSH
108645: PPUSH
108646: PPUSH
108647: PPUSH
108648: PPUSH
108649: PPUSH
108650: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
108651: LD_VAR 0 1
108655: PPUSH
108656: LD_VAR 0 2
108660: PPUSH
108661: CALL_OW 488
108665: NOT
108666: PUSH
108667: LD_VAR 0 3
108671: PPUSH
108672: LD_VAR 0 4
108676: PPUSH
108677: CALL_OW 488
108681: NOT
108682: OR
108683: IFFALSE 108696
// begin result := - 1 ;
108685: LD_ADDR_VAR 0 5
108689: PUSH
108690: LD_INT 1
108692: NEG
108693: ST_TO_ADDR
// exit ;
108694: GO 108931
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
108696: LD_ADDR_VAR 0 12
108700: PUSH
108701: LD_VAR 0 1
108705: PPUSH
108706: LD_VAR 0 2
108710: PPUSH
108711: LD_VAR 0 3
108715: PPUSH
108716: LD_VAR 0 4
108720: PPUSH
108721: CALL 107781 0 4
108725: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
108726: LD_ADDR_VAR 0 11
108730: PUSH
108731: LD_VAR 0 1
108735: PPUSH
108736: LD_VAR 0 2
108740: PPUSH
108741: LD_VAR 0 12
108745: PUSH
108746: LD_INT 1
108748: ARRAY
108749: PPUSH
108750: LD_VAR 0 12
108754: PUSH
108755: LD_INT 2
108757: ARRAY
108758: PPUSH
108759: CALL_OW 298
108763: ST_TO_ADDR
// distance := 9999 ;
108764: LD_ADDR_VAR 0 10
108768: PUSH
108769: LD_INT 9999
108771: ST_TO_ADDR
// for i := 0 to 5 do
108772: LD_ADDR_VAR 0 6
108776: PUSH
108777: DOUBLE
108778: LD_INT 0
108780: DEC
108781: ST_TO_ADDR
108782: LD_INT 5
108784: PUSH
108785: FOR_TO
108786: IFFALSE 108929
// begin _x := ShiftX ( x1 , i , centerDist ) ;
108788: LD_ADDR_VAR 0 7
108792: PUSH
108793: LD_VAR 0 1
108797: PPUSH
108798: LD_VAR 0 6
108802: PPUSH
108803: LD_VAR 0 11
108807: PPUSH
108808: CALL_OW 272
108812: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
108813: LD_ADDR_VAR 0 8
108817: PUSH
108818: LD_VAR 0 2
108822: PPUSH
108823: LD_VAR 0 6
108827: PPUSH
108828: LD_VAR 0 11
108832: PPUSH
108833: CALL_OW 273
108837: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
108838: LD_VAR 0 7
108842: PPUSH
108843: LD_VAR 0 8
108847: PPUSH
108848: CALL_OW 488
108852: NOT
108853: IFFALSE 108857
// continue ;
108855: GO 108785
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
108857: LD_ADDR_VAR 0 9
108861: PUSH
108862: LD_VAR 0 12
108866: PUSH
108867: LD_INT 1
108869: ARRAY
108870: PPUSH
108871: LD_VAR 0 12
108875: PUSH
108876: LD_INT 2
108878: ARRAY
108879: PPUSH
108880: LD_VAR 0 7
108884: PPUSH
108885: LD_VAR 0 8
108889: PPUSH
108890: CALL_OW 298
108894: ST_TO_ADDR
// if tmp < distance then
108895: LD_VAR 0 9
108899: PUSH
108900: LD_VAR 0 10
108904: LESS
108905: IFFALSE 108927
// begin result := i ;
108907: LD_ADDR_VAR 0 5
108911: PUSH
108912: LD_VAR 0 6
108916: ST_TO_ADDR
// distance := tmp ;
108917: LD_ADDR_VAR 0 10
108921: PUSH
108922: LD_VAR 0 9
108926: ST_TO_ADDR
// end ; end ;
108927: GO 108785
108929: POP
108930: POP
// end ;
108931: LD_VAR 0 5
108935: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108936: LD_INT 0
108938: PPUSH
108939: PPUSH
// if not driver or not IsInUnit ( driver ) then
108940: LD_VAR 0 1
108944: NOT
108945: PUSH
108946: LD_VAR 0 1
108950: PPUSH
108951: CALL_OW 310
108955: NOT
108956: OR
108957: IFFALSE 108961
// exit ;
108959: GO 109051
// vehicle := IsInUnit ( driver ) ;
108961: LD_ADDR_VAR 0 3
108965: PUSH
108966: LD_VAR 0 1
108970: PPUSH
108971: CALL_OW 310
108975: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108976: LD_VAR 0 1
108980: PPUSH
108981: LD_STRING \
108983: PUSH
108984: LD_INT 0
108986: PUSH
108987: LD_INT 0
108989: PUSH
108990: LD_INT 0
108992: PUSH
108993: LD_INT 0
108995: PUSH
108996: LD_INT 0
108998: PUSH
108999: LD_INT 0
109001: PUSH
109002: EMPTY
109003: LIST
109004: LIST
109005: LIST
109006: LIST
109007: LIST
109008: LIST
109009: LIST
109010: PUSH
109011: LD_STRING E
109013: PUSH
109014: LD_INT 0
109016: PUSH
109017: LD_INT 0
109019: PUSH
109020: LD_VAR 0 3
109024: PUSH
109025: LD_INT 0
109027: PUSH
109028: LD_INT 0
109030: PUSH
109031: LD_INT 0
109033: PUSH
109034: EMPTY
109035: LIST
109036: LIST
109037: LIST
109038: LIST
109039: LIST
109040: LIST
109041: LIST
109042: PUSH
109043: EMPTY
109044: LIST
109045: LIST
109046: PPUSH
109047: CALL_OW 446
// end ;
109051: LD_VAR 0 2
109055: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
109056: LD_INT 0
109058: PPUSH
109059: PPUSH
// if not driver or not IsInUnit ( driver ) then
109060: LD_VAR 0 1
109064: NOT
109065: PUSH
109066: LD_VAR 0 1
109070: PPUSH
109071: CALL_OW 310
109075: NOT
109076: OR
109077: IFFALSE 109081
// exit ;
109079: GO 109171
// vehicle := IsInUnit ( driver ) ;
109081: LD_ADDR_VAR 0 3
109085: PUSH
109086: LD_VAR 0 1
109090: PPUSH
109091: CALL_OW 310
109095: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
109096: LD_VAR 0 1
109100: PPUSH
109101: LD_STRING \
109103: PUSH
109104: LD_INT 0
109106: PUSH
109107: LD_INT 0
109109: PUSH
109110: LD_INT 0
109112: PUSH
109113: LD_INT 0
109115: PUSH
109116: LD_INT 0
109118: PUSH
109119: LD_INT 0
109121: PUSH
109122: EMPTY
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: LIST
109130: PUSH
109131: LD_STRING E
109133: PUSH
109134: LD_INT 0
109136: PUSH
109137: LD_INT 0
109139: PUSH
109140: LD_VAR 0 3
109144: PUSH
109145: LD_INT 0
109147: PUSH
109148: LD_INT 0
109150: PUSH
109151: LD_INT 0
109153: PUSH
109154: EMPTY
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: LIST
109161: LIST
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: PPUSH
109167: CALL_OW 447
// end ;
109171: LD_VAR 0 2
109175: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
109176: LD_INT 0
109178: PPUSH
109179: PPUSH
109180: PPUSH
// tmp := [ ] ;
109181: LD_ADDR_VAR 0 5
109185: PUSH
109186: EMPTY
109187: ST_TO_ADDR
// for i in units do
109188: LD_ADDR_VAR 0 4
109192: PUSH
109193: LD_VAR 0 1
109197: PUSH
109198: FOR_IN
109199: IFFALSE 109237
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
109201: LD_ADDR_VAR 0 5
109205: PUSH
109206: LD_VAR 0 5
109210: PPUSH
109211: LD_VAR 0 5
109215: PUSH
109216: LD_INT 1
109218: PLUS
109219: PPUSH
109220: LD_VAR 0 4
109224: PPUSH
109225: CALL_OW 256
109229: PPUSH
109230: CALL_OW 2
109234: ST_TO_ADDR
109235: GO 109198
109237: POP
109238: POP
// if not tmp then
109239: LD_VAR 0 5
109243: NOT
109244: IFFALSE 109248
// exit ;
109246: GO 109296
// if asc then
109248: LD_VAR 0 2
109252: IFFALSE 109276
// result := SortListByListAsc ( units , tmp ) else
109254: LD_ADDR_VAR 0 3
109258: PUSH
109259: LD_VAR 0 1
109263: PPUSH
109264: LD_VAR 0 5
109268: PPUSH
109269: CALL_OW 76
109273: ST_TO_ADDR
109274: GO 109296
// result := SortListByListDesc ( units , tmp ) ;
109276: LD_ADDR_VAR 0 3
109280: PUSH
109281: LD_VAR 0 1
109285: PPUSH
109286: LD_VAR 0 5
109290: PPUSH
109291: CALL_OW 77
109295: ST_TO_ADDR
// end ;
109296: LD_VAR 0 3
109300: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
109301: LD_INT 0
109303: PPUSH
109304: PPUSH
// task := GetTaskList ( mech ) ;
109305: LD_ADDR_VAR 0 4
109309: PUSH
109310: LD_VAR 0 1
109314: PPUSH
109315: CALL_OW 437
109319: ST_TO_ADDR
// if not task then
109320: LD_VAR 0 4
109324: NOT
109325: IFFALSE 109329
// exit ;
109327: GO 109371
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
109329: LD_ADDR_VAR 0 3
109333: PUSH
109334: LD_VAR 0 4
109338: PUSH
109339: LD_INT 1
109341: ARRAY
109342: PUSH
109343: LD_INT 1
109345: ARRAY
109346: PUSH
109347: LD_STRING r
109349: EQUAL
109350: PUSH
109351: LD_VAR 0 4
109355: PUSH
109356: LD_INT 1
109358: ARRAY
109359: PUSH
109360: LD_INT 4
109362: ARRAY
109363: PUSH
109364: LD_VAR 0 2
109368: EQUAL
109369: AND
109370: ST_TO_ADDR
// end ;
109371: LD_VAR 0 3
109375: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
109376: LD_INT 0
109378: PPUSH
// SetDir ( unit , d ) ;
109379: LD_VAR 0 1
109383: PPUSH
109384: LD_VAR 0 4
109388: PPUSH
109389: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
109393: LD_VAR 0 1
109397: PPUSH
109398: LD_VAR 0 2
109402: PPUSH
109403: LD_VAR 0 3
109407: PPUSH
109408: LD_VAR 0 5
109412: PPUSH
109413: CALL_OW 48
// end ;
109417: LD_VAR 0 6
109421: RET
// export function ToNaturalNumber ( number ) ; begin
109422: LD_INT 0
109424: PPUSH
// result := number div 1 ;
109425: LD_ADDR_VAR 0 2
109429: PUSH
109430: LD_VAR 0 1
109434: PUSH
109435: LD_INT 1
109437: DIV
109438: ST_TO_ADDR
// if number < 0 then
109439: LD_VAR 0 1
109443: PUSH
109444: LD_INT 0
109446: LESS
109447: IFFALSE 109457
// result := 0 ;
109449: LD_ADDR_VAR 0 2
109453: PUSH
109454: LD_INT 0
109456: ST_TO_ADDR
// end ;
109457: LD_VAR 0 2
109461: RET
// export function SortByClass ( units , class ) ; var un ; begin
109462: LD_INT 0
109464: PPUSH
109465: PPUSH
// if not units or not class then
109466: LD_VAR 0 1
109470: NOT
109471: PUSH
109472: LD_VAR 0 2
109476: NOT
109477: OR
109478: IFFALSE 109482
// exit ;
109480: GO 109577
// result := [ ] ;
109482: LD_ADDR_VAR 0 3
109486: PUSH
109487: EMPTY
109488: ST_TO_ADDR
// for un in units do
109489: LD_ADDR_VAR 0 4
109493: PUSH
109494: LD_VAR 0 1
109498: PUSH
109499: FOR_IN
109500: IFFALSE 109575
// if GetClass ( un ) = class then
109502: LD_VAR 0 4
109506: PPUSH
109507: CALL_OW 257
109511: PUSH
109512: LD_VAR 0 2
109516: EQUAL
109517: IFFALSE 109544
// result := Insert ( result , 1 , un ) else
109519: LD_ADDR_VAR 0 3
109523: PUSH
109524: LD_VAR 0 3
109528: PPUSH
109529: LD_INT 1
109531: PPUSH
109532: LD_VAR 0 4
109536: PPUSH
109537: CALL_OW 2
109541: ST_TO_ADDR
109542: GO 109573
// result := Replace ( result , result + 1 , un ) ;
109544: LD_ADDR_VAR 0 3
109548: PUSH
109549: LD_VAR 0 3
109553: PPUSH
109554: LD_VAR 0 3
109558: PUSH
109559: LD_INT 1
109561: PLUS
109562: PPUSH
109563: LD_VAR 0 4
109567: PPUSH
109568: CALL_OW 1
109572: ST_TO_ADDR
109573: GO 109499
109575: POP
109576: POP
// end ;
109577: LD_VAR 0 3
109581: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
109582: LD_INT 0
109584: PPUSH
109585: PPUSH
109586: PPUSH
109587: PPUSH
109588: PPUSH
109589: PPUSH
109590: PPUSH
// result := [ ] ;
109591: LD_ADDR_VAR 0 4
109595: PUSH
109596: EMPTY
109597: ST_TO_ADDR
// if x - r < 0 then
109598: LD_VAR 0 1
109602: PUSH
109603: LD_VAR 0 3
109607: MINUS
109608: PUSH
109609: LD_INT 0
109611: LESS
109612: IFFALSE 109624
// min_x := 0 else
109614: LD_ADDR_VAR 0 8
109618: PUSH
109619: LD_INT 0
109621: ST_TO_ADDR
109622: GO 109640
// min_x := x - r ;
109624: LD_ADDR_VAR 0 8
109628: PUSH
109629: LD_VAR 0 1
109633: PUSH
109634: LD_VAR 0 3
109638: MINUS
109639: ST_TO_ADDR
// if y - r < 0 then
109640: LD_VAR 0 2
109644: PUSH
109645: LD_VAR 0 3
109649: MINUS
109650: PUSH
109651: LD_INT 0
109653: LESS
109654: IFFALSE 109666
// min_y := 0 else
109656: LD_ADDR_VAR 0 7
109660: PUSH
109661: LD_INT 0
109663: ST_TO_ADDR
109664: GO 109682
// min_y := y - r ;
109666: LD_ADDR_VAR 0 7
109670: PUSH
109671: LD_VAR 0 2
109675: PUSH
109676: LD_VAR 0 3
109680: MINUS
109681: ST_TO_ADDR
// max_x := x + r ;
109682: LD_ADDR_VAR 0 9
109686: PUSH
109687: LD_VAR 0 1
109691: PUSH
109692: LD_VAR 0 3
109696: PLUS
109697: ST_TO_ADDR
// max_y := y + r ;
109698: LD_ADDR_VAR 0 10
109702: PUSH
109703: LD_VAR 0 2
109707: PUSH
109708: LD_VAR 0 3
109712: PLUS
109713: ST_TO_ADDR
// for _x = min_x to max_x do
109714: LD_ADDR_VAR 0 5
109718: PUSH
109719: DOUBLE
109720: LD_VAR 0 8
109724: DEC
109725: ST_TO_ADDR
109726: LD_VAR 0 9
109730: PUSH
109731: FOR_TO
109732: IFFALSE 109833
// for _y = min_y to max_y do
109734: LD_ADDR_VAR 0 6
109738: PUSH
109739: DOUBLE
109740: LD_VAR 0 7
109744: DEC
109745: ST_TO_ADDR
109746: LD_VAR 0 10
109750: PUSH
109751: FOR_TO
109752: IFFALSE 109829
// begin if not ValidHex ( _x , _y ) then
109754: LD_VAR 0 5
109758: PPUSH
109759: LD_VAR 0 6
109763: PPUSH
109764: CALL_OW 488
109768: NOT
109769: IFFALSE 109773
// continue ;
109771: GO 109751
// if GetResourceTypeXY ( _x , _y ) then
109773: LD_VAR 0 5
109777: PPUSH
109778: LD_VAR 0 6
109782: PPUSH
109783: CALL_OW 283
109787: IFFALSE 109827
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
109789: LD_ADDR_VAR 0 4
109793: PUSH
109794: LD_VAR 0 4
109798: PPUSH
109799: LD_VAR 0 4
109803: PUSH
109804: LD_INT 1
109806: PLUS
109807: PPUSH
109808: LD_VAR 0 5
109812: PUSH
109813: LD_VAR 0 6
109817: PUSH
109818: EMPTY
109819: LIST
109820: LIST
109821: PPUSH
109822: CALL_OW 1
109826: ST_TO_ADDR
// end ;
109827: GO 109751
109829: POP
109830: POP
109831: GO 109731
109833: POP
109834: POP
// end ;
109835: LD_VAR 0 4
109839: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
109840: LD_INT 0
109842: PPUSH
109843: PPUSH
109844: PPUSH
109845: PPUSH
109846: PPUSH
109847: PPUSH
109848: PPUSH
109849: PPUSH
// if not units then
109850: LD_VAR 0 1
109854: NOT
109855: IFFALSE 109859
// exit ;
109857: GO 110383
// result := UnitFilter ( units , [ f_ok ] ) ;
109859: LD_ADDR_VAR 0 3
109863: PUSH
109864: LD_VAR 0 1
109868: PPUSH
109869: LD_INT 50
109871: PUSH
109872: EMPTY
109873: LIST
109874: PPUSH
109875: CALL_OW 72
109879: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
109880: LD_ADDR_VAR 0 8
109884: PUSH
109885: LD_VAR 0 1
109889: PUSH
109890: LD_INT 1
109892: ARRAY
109893: PPUSH
109894: CALL_OW 255
109898: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
109899: LD_ADDR_VAR 0 10
109903: PUSH
109904: LD_INT 29
109906: PUSH
109907: LD_INT 91
109909: PUSH
109910: LD_INT 49
109912: PUSH
109913: EMPTY
109914: LIST
109915: LIST
109916: LIST
109917: ST_TO_ADDR
// if not result then
109918: LD_VAR 0 3
109922: NOT
109923: IFFALSE 109927
// exit ;
109925: GO 110383
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
109927: LD_ADDR_VAR 0 5
109931: PUSH
109932: LD_INT 81
109934: PUSH
109935: LD_VAR 0 8
109939: PUSH
109940: EMPTY
109941: LIST
109942: LIST
109943: PPUSH
109944: CALL_OW 69
109948: ST_TO_ADDR
// for i in result do
109949: LD_ADDR_VAR 0 4
109953: PUSH
109954: LD_VAR 0 3
109958: PUSH
109959: FOR_IN
109960: IFFALSE 110381
// begin tag := GetTag ( i ) + 1 ;
109962: LD_ADDR_VAR 0 9
109966: PUSH
109967: LD_VAR 0 4
109971: PPUSH
109972: CALL_OW 110
109976: PUSH
109977: LD_INT 1
109979: PLUS
109980: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
109981: LD_ADDR_VAR 0 7
109985: PUSH
109986: LD_VAR 0 4
109990: PPUSH
109991: CALL_OW 250
109995: PPUSH
109996: LD_VAR 0 4
110000: PPUSH
110001: CALL_OW 251
110005: PPUSH
110006: LD_INT 6
110008: PPUSH
110009: CALL 109582 0 3
110013: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
110014: LD_VAR 0 4
110018: PPUSH
110019: CALL_OW 247
110023: PUSH
110024: LD_INT 2
110026: EQUAL
110027: PUSH
110028: LD_VAR 0 7
110032: AND
110033: PUSH
110034: LD_VAR 0 4
110038: PPUSH
110039: CALL_OW 264
110043: PUSH
110044: LD_VAR 0 10
110048: IN
110049: NOT
110050: AND
110051: IFFALSE 110090
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
110053: LD_VAR 0 4
110057: PPUSH
110058: LD_VAR 0 7
110062: PUSH
110063: LD_INT 1
110065: ARRAY
110066: PUSH
110067: LD_INT 1
110069: ARRAY
110070: PPUSH
110071: LD_VAR 0 7
110075: PUSH
110076: LD_INT 1
110078: ARRAY
110079: PUSH
110080: LD_INT 2
110082: ARRAY
110083: PPUSH
110084: CALL_OW 116
110088: GO 110379
// if path > tag then
110090: LD_VAR 0 2
110094: PUSH
110095: LD_VAR 0 9
110099: GREATER
110100: IFFALSE 110308
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
110102: LD_ADDR_VAR 0 6
110106: PUSH
110107: LD_VAR 0 5
110111: PPUSH
110112: LD_INT 91
110114: PUSH
110115: LD_VAR 0 4
110119: PUSH
110120: LD_INT 8
110122: PUSH
110123: EMPTY
110124: LIST
110125: LIST
110126: LIST
110127: PPUSH
110128: CALL_OW 72
110132: ST_TO_ADDR
// if nearEnemy then
110133: LD_VAR 0 6
110137: IFFALSE 110206
// begin if GetWeapon ( i ) = ru_time_lapser then
110139: LD_VAR 0 4
110143: PPUSH
110144: CALL_OW 264
110148: PUSH
110149: LD_INT 49
110151: EQUAL
110152: IFFALSE 110180
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
110154: LD_VAR 0 4
110158: PPUSH
110159: LD_VAR 0 6
110163: PPUSH
110164: LD_VAR 0 4
110168: PPUSH
110169: CALL_OW 74
110173: PPUSH
110174: CALL_OW 112
110178: GO 110204
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
110180: LD_VAR 0 4
110184: PPUSH
110185: LD_VAR 0 6
110189: PPUSH
110190: LD_VAR 0 4
110194: PPUSH
110195: CALL_OW 74
110199: PPUSH
110200: CALL 111454 0 2
// end else
110204: GO 110306
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
110206: LD_VAR 0 4
110210: PPUSH
110211: LD_VAR 0 2
110215: PUSH
110216: LD_VAR 0 9
110220: ARRAY
110221: PUSH
110222: LD_INT 1
110224: ARRAY
110225: PPUSH
110226: LD_VAR 0 2
110230: PUSH
110231: LD_VAR 0 9
110235: ARRAY
110236: PUSH
110237: LD_INT 2
110239: ARRAY
110240: PPUSH
110241: CALL_OW 297
110245: PUSH
110246: LD_INT 6
110248: GREATER
110249: IFFALSE 110292
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
110251: LD_VAR 0 4
110255: PPUSH
110256: LD_VAR 0 2
110260: PUSH
110261: LD_VAR 0 9
110265: ARRAY
110266: PUSH
110267: LD_INT 1
110269: ARRAY
110270: PPUSH
110271: LD_VAR 0 2
110275: PUSH
110276: LD_VAR 0 9
110280: ARRAY
110281: PUSH
110282: LD_INT 2
110284: ARRAY
110285: PPUSH
110286: CALL_OW 114
110290: GO 110306
// SetTag ( i , tag ) ;
110292: LD_VAR 0 4
110296: PPUSH
110297: LD_VAR 0 9
110301: PPUSH
110302: CALL_OW 109
// end else
110306: GO 110379
// if enemy then
110308: LD_VAR 0 5
110312: IFFALSE 110379
// begin if GetWeapon ( i ) = ru_time_lapser then
110314: LD_VAR 0 4
110318: PPUSH
110319: CALL_OW 264
110323: PUSH
110324: LD_INT 49
110326: EQUAL
110327: IFFALSE 110355
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
110329: LD_VAR 0 4
110333: PPUSH
110334: LD_VAR 0 5
110338: PPUSH
110339: LD_VAR 0 4
110343: PPUSH
110344: CALL_OW 74
110348: PPUSH
110349: CALL_OW 112
110353: GO 110379
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
110355: LD_VAR 0 4
110359: PPUSH
110360: LD_VAR 0 5
110364: PPUSH
110365: LD_VAR 0 4
110369: PPUSH
110370: CALL_OW 74
110374: PPUSH
110375: CALL 111454 0 2
// end ; end ;
110379: GO 109959
110381: POP
110382: POP
// end ;
110383: LD_VAR 0 3
110387: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
110388: LD_INT 0
110390: PPUSH
110391: PPUSH
110392: PPUSH
// if not unit or IsInUnit ( unit ) then
110393: LD_VAR 0 1
110397: NOT
110398: PUSH
110399: LD_VAR 0 1
110403: PPUSH
110404: CALL_OW 310
110408: OR
110409: IFFALSE 110413
// exit ;
110411: GO 110504
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
110413: LD_ADDR_VAR 0 4
110417: PUSH
110418: LD_VAR 0 1
110422: PPUSH
110423: CALL_OW 250
110427: PPUSH
110428: LD_VAR 0 2
110432: PPUSH
110433: LD_INT 1
110435: PPUSH
110436: CALL_OW 272
110440: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
110441: LD_ADDR_VAR 0 5
110445: PUSH
110446: LD_VAR 0 1
110450: PPUSH
110451: CALL_OW 251
110455: PPUSH
110456: LD_VAR 0 2
110460: PPUSH
110461: LD_INT 1
110463: PPUSH
110464: CALL_OW 273
110468: ST_TO_ADDR
// if ValidHex ( x , y ) then
110469: LD_VAR 0 4
110473: PPUSH
110474: LD_VAR 0 5
110478: PPUSH
110479: CALL_OW 488
110483: IFFALSE 110504
// ComTurnXY ( unit , x , y ) ;
110485: LD_VAR 0 1
110489: PPUSH
110490: LD_VAR 0 4
110494: PPUSH
110495: LD_VAR 0 5
110499: PPUSH
110500: CALL_OW 118
// end ;
110504: LD_VAR 0 3
110508: RET
// export function SeeUnits ( side , units ) ; var i ; begin
110509: LD_INT 0
110511: PPUSH
110512: PPUSH
// result := false ;
110513: LD_ADDR_VAR 0 3
110517: PUSH
110518: LD_INT 0
110520: ST_TO_ADDR
// if not units then
110521: LD_VAR 0 2
110525: NOT
110526: IFFALSE 110530
// exit ;
110528: GO 110575
// for i in units do
110530: LD_ADDR_VAR 0 4
110534: PUSH
110535: LD_VAR 0 2
110539: PUSH
110540: FOR_IN
110541: IFFALSE 110573
// if See ( side , i ) then
110543: LD_VAR 0 1
110547: PPUSH
110548: LD_VAR 0 4
110552: PPUSH
110553: CALL_OW 292
110557: IFFALSE 110571
// begin result := true ;
110559: LD_ADDR_VAR 0 3
110563: PUSH
110564: LD_INT 1
110566: ST_TO_ADDR
// exit ;
110567: POP
110568: POP
110569: GO 110575
// end ;
110571: GO 110540
110573: POP
110574: POP
// end ;
110575: LD_VAR 0 3
110579: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
110580: LD_INT 0
110582: PPUSH
110583: PPUSH
110584: PPUSH
110585: PPUSH
// if not unit or not points then
110586: LD_VAR 0 1
110590: NOT
110591: PUSH
110592: LD_VAR 0 2
110596: NOT
110597: OR
110598: IFFALSE 110602
// exit ;
110600: GO 110692
// dist := 99999 ;
110602: LD_ADDR_VAR 0 5
110606: PUSH
110607: LD_INT 99999
110609: ST_TO_ADDR
// for i in points do
110610: LD_ADDR_VAR 0 4
110614: PUSH
110615: LD_VAR 0 2
110619: PUSH
110620: FOR_IN
110621: IFFALSE 110690
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
110623: LD_ADDR_VAR 0 6
110627: PUSH
110628: LD_VAR 0 1
110632: PPUSH
110633: LD_VAR 0 4
110637: PUSH
110638: LD_INT 1
110640: ARRAY
110641: PPUSH
110642: LD_VAR 0 4
110646: PUSH
110647: LD_INT 2
110649: ARRAY
110650: PPUSH
110651: CALL_OW 297
110655: ST_TO_ADDR
// if tmpDist < dist then
110656: LD_VAR 0 6
110660: PUSH
110661: LD_VAR 0 5
110665: LESS
110666: IFFALSE 110688
// begin result := i ;
110668: LD_ADDR_VAR 0 3
110672: PUSH
110673: LD_VAR 0 4
110677: ST_TO_ADDR
// dist := tmpDist ;
110678: LD_ADDR_VAR 0 5
110682: PUSH
110683: LD_VAR 0 6
110687: ST_TO_ADDR
// end ; end ;
110688: GO 110620
110690: POP
110691: POP
// end ;
110692: LD_VAR 0 3
110696: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
110697: LD_INT 0
110699: PPUSH
// uc_side := side ;
110700: LD_ADDR_OWVAR 20
110704: PUSH
110705: LD_VAR 0 1
110709: ST_TO_ADDR
// uc_nation := 3 ;
110710: LD_ADDR_OWVAR 21
110714: PUSH
110715: LD_INT 3
110717: ST_TO_ADDR
// vc_chassis := 25 ;
110718: LD_ADDR_OWVAR 37
110722: PUSH
110723: LD_INT 25
110725: ST_TO_ADDR
// vc_engine := engine_siberite ;
110726: LD_ADDR_OWVAR 39
110730: PUSH
110731: LD_INT 3
110733: ST_TO_ADDR
// vc_control := control_computer ;
110734: LD_ADDR_OWVAR 38
110738: PUSH
110739: LD_INT 3
110741: ST_TO_ADDR
// vc_weapon := 59 ;
110742: LD_ADDR_OWVAR 40
110746: PUSH
110747: LD_INT 59
110749: ST_TO_ADDR
// result := CreateVehicle ;
110750: LD_ADDR_VAR 0 5
110754: PUSH
110755: CALL_OW 45
110759: ST_TO_ADDR
// SetDir ( result , d ) ;
110760: LD_VAR 0 5
110764: PPUSH
110765: LD_VAR 0 4
110769: PPUSH
110770: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
110774: LD_VAR 0 5
110778: PPUSH
110779: LD_VAR 0 2
110783: PPUSH
110784: LD_VAR 0 3
110788: PPUSH
110789: LD_INT 0
110791: PPUSH
110792: CALL_OW 48
// end ;
110796: LD_VAR 0 5
110800: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
110801: LD_INT 0
110803: PPUSH
110804: PPUSH
110805: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
110806: LD_ADDR_VAR 0 2
110810: PUSH
110811: LD_INT 0
110813: PUSH
110814: LD_INT 0
110816: PUSH
110817: LD_INT 0
110819: PUSH
110820: LD_INT 0
110822: PUSH
110823: EMPTY
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
110829: LD_VAR 0 1
110833: NOT
110834: PUSH
110835: LD_VAR 0 1
110839: PPUSH
110840: CALL_OW 264
110844: PUSH
110845: LD_INT 12
110847: PUSH
110848: LD_INT 51
110850: PUSH
110851: LD_INT 32
110853: PUSH
110854: LD_INT 89
110856: PUSH
110857: EMPTY
110858: LIST
110859: LIST
110860: LIST
110861: LIST
110862: IN
110863: NOT
110864: OR
110865: IFFALSE 110869
// exit ;
110867: GO 110967
// for i := 1 to 3 do
110869: LD_ADDR_VAR 0 3
110873: PUSH
110874: DOUBLE
110875: LD_INT 1
110877: DEC
110878: ST_TO_ADDR
110879: LD_INT 3
110881: PUSH
110882: FOR_TO
110883: IFFALSE 110965
// begin tmp := GetCargo ( cargo , i ) ;
110885: LD_ADDR_VAR 0 4
110889: PUSH
110890: LD_VAR 0 1
110894: PPUSH
110895: LD_VAR 0 3
110899: PPUSH
110900: CALL_OW 289
110904: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
110905: LD_ADDR_VAR 0 2
110909: PUSH
110910: LD_VAR 0 2
110914: PPUSH
110915: LD_VAR 0 3
110919: PPUSH
110920: LD_VAR 0 4
110924: PPUSH
110925: CALL_OW 1
110929: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
110930: LD_ADDR_VAR 0 2
110934: PUSH
110935: LD_VAR 0 2
110939: PPUSH
110940: LD_INT 4
110942: PPUSH
110943: LD_VAR 0 2
110947: PUSH
110948: LD_INT 4
110950: ARRAY
110951: PUSH
110952: LD_VAR 0 4
110956: PLUS
110957: PPUSH
110958: CALL_OW 1
110962: ST_TO_ADDR
// end ;
110963: GO 110882
110965: POP
110966: POP
// end ;
110967: LD_VAR 0 2
110971: RET
// export function Length ( array ) ; begin
110972: LD_INT 0
110974: PPUSH
// result := array + 0 ;
110975: LD_ADDR_VAR 0 2
110979: PUSH
110980: LD_VAR 0 1
110984: PUSH
110985: LD_INT 0
110987: PLUS
110988: ST_TO_ADDR
// end ;
110989: LD_VAR 0 2
110993: RET
// export function PrepareArray ( array ) ; begin
110994: LD_INT 0
110996: PPUSH
// result := array diff 0 ;
110997: LD_ADDR_VAR 0 2
111001: PUSH
111002: LD_VAR 0 1
111006: PUSH
111007: LD_INT 0
111009: DIFF
111010: ST_TO_ADDR
// if not result [ 1 ] then
111011: LD_VAR 0 2
111015: PUSH
111016: LD_INT 1
111018: ARRAY
111019: NOT
111020: IFFALSE 111040
// result := Delete ( result , 1 ) ;
111022: LD_ADDR_VAR 0 2
111026: PUSH
111027: LD_VAR 0 2
111031: PPUSH
111032: LD_INT 1
111034: PPUSH
111035: CALL_OW 3
111039: ST_TO_ADDR
// end ;
111040: LD_VAR 0 2
111044: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
111045: LD_INT 0
111047: PPUSH
111048: PPUSH
111049: PPUSH
111050: PPUSH
// sibRocketRange := 25 ;
111051: LD_ADDR_VAR 0 6
111055: PUSH
111056: LD_INT 25
111058: ST_TO_ADDR
// result := false ;
111059: LD_ADDR_VAR 0 4
111063: PUSH
111064: LD_INT 0
111066: ST_TO_ADDR
// for i := 0 to 5 do
111067: LD_ADDR_VAR 0 5
111071: PUSH
111072: DOUBLE
111073: LD_INT 0
111075: DEC
111076: ST_TO_ADDR
111077: LD_INT 5
111079: PUSH
111080: FOR_TO
111081: IFFALSE 111148
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
111083: LD_VAR 0 1
111087: PPUSH
111088: LD_VAR 0 5
111092: PPUSH
111093: LD_VAR 0 6
111097: PPUSH
111098: CALL_OW 272
111102: PPUSH
111103: LD_VAR 0 2
111107: PPUSH
111108: LD_VAR 0 5
111112: PPUSH
111113: LD_VAR 0 6
111117: PPUSH
111118: CALL_OW 273
111122: PPUSH
111123: LD_VAR 0 3
111127: PPUSH
111128: CALL_OW 309
111132: IFFALSE 111146
// begin result := true ;
111134: LD_ADDR_VAR 0 4
111138: PUSH
111139: LD_INT 1
111141: ST_TO_ADDR
// exit ;
111142: POP
111143: POP
111144: GO 111150
// end ;
111146: GO 111080
111148: POP
111149: POP
// end ;
111150: LD_VAR 0 4
111154: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
111155: LD_INT 0
111157: PPUSH
111158: PPUSH
111159: PPUSH
// if btype = b_depot then
111160: LD_VAR 0 2
111164: PUSH
111165: LD_INT 0
111167: EQUAL
111168: IFFALSE 111180
// begin result := true ;
111170: LD_ADDR_VAR 0 3
111174: PUSH
111175: LD_INT 1
111177: ST_TO_ADDR
// exit ;
111178: GO 111296
// end ; pom := GetBase ( depot ) ;
111180: LD_ADDR_VAR 0 4
111184: PUSH
111185: LD_VAR 0 1
111189: PPUSH
111190: CALL_OW 274
111194: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
111195: LD_ADDR_VAR 0 5
111199: PUSH
111200: LD_VAR 0 2
111204: PPUSH
111205: LD_VAR 0 1
111209: PPUSH
111210: CALL_OW 248
111214: PPUSH
111215: CALL_OW 450
111219: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
111220: LD_ADDR_VAR 0 3
111224: PUSH
111225: LD_VAR 0 4
111229: PPUSH
111230: LD_INT 1
111232: PPUSH
111233: CALL_OW 275
111237: PUSH
111238: LD_VAR 0 5
111242: PUSH
111243: LD_INT 1
111245: ARRAY
111246: GREATEREQUAL
111247: PUSH
111248: LD_VAR 0 4
111252: PPUSH
111253: LD_INT 2
111255: PPUSH
111256: CALL_OW 275
111260: PUSH
111261: LD_VAR 0 5
111265: PUSH
111266: LD_INT 2
111268: ARRAY
111269: GREATEREQUAL
111270: AND
111271: PUSH
111272: LD_VAR 0 4
111276: PPUSH
111277: LD_INT 3
111279: PPUSH
111280: CALL_OW 275
111284: PUSH
111285: LD_VAR 0 5
111289: PUSH
111290: LD_INT 3
111292: ARRAY
111293: GREATEREQUAL
111294: AND
111295: ST_TO_ADDR
// end ;
111296: LD_VAR 0 3
111300: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
111301: LD_INT 0
111303: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
111304: LD_VAR 0 1
111308: PPUSH
111309: LD_VAR 0 2
111313: PPUSH
111314: LD_INT 0
111316: PPUSH
111317: LD_INT 0
111319: PPUSH
111320: LD_INT 1
111322: PPUSH
111323: LD_INT 0
111325: PPUSH
111326: CALL_OW 587
// end ;
111330: LD_VAR 0 3
111334: RET
// export function CenterOnNow ( unit ) ; begin
111335: LD_INT 0
111337: PPUSH
// result := IsInUnit ( unit ) ;
111338: LD_ADDR_VAR 0 2
111342: PUSH
111343: LD_VAR 0 1
111347: PPUSH
111348: CALL_OW 310
111352: ST_TO_ADDR
// if not result then
111353: LD_VAR 0 2
111357: NOT
111358: IFFALSE 111370
// result := unit ;
111360: LD_ADDR_VAR 0 2
111364: PUSH
111365: LD_VAR 0 1
111369: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
111370: LD_VAR 0 1
111374: PPUSH
111375: CALL_OW 87
// end ;
111379: LD_VAR 0 2
111383: RET
// export function ComMoveHex ( unit , hex ) ; begin
111384: LD_INT 0
111386: PPUSH
// if not hex then
111387: LD_VAR 0 2
111391: NOT
111392: IFFALSE 111396
// exit ;
111394: GO 111449
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
111396: LD_VAR 0 2
111400: PUSH
111401: LD_INT 1
111403: ARRAY
111404: PPUSH
111405: LD_VAR 0 2
111409: PUSH
111410: LD_INT 2
111412: ARRAY
111413: PPUSH
111414: CALL_OW 428
111418: IFFALSE 111422
// exit ;
111420: GO 111449
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
111422: LD_VAR 0 1
111426: PPUSH
111427: LD_VAR 0 2
111431: PUSH
111432: LD_INT 1
111434: ARRAY
111435: PPUSH
111436: LD_VAR 0 2
111440: PUSH
111441: LD_INT 2
111443: ARRAY
111444: PPUSH
111445: CALL_OW 111
// end ;
111449: LD_VAR 0 3
111453: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
111454: LD_INT 0
111456: PPUSH
111457: PPUSH
111458: PPUSH
// if not unit or not enemy then
111459: LD_VAR 0 1
111463: NOT
111464: PUSH
111465: LD_VAR 0 2
111469: NOT
111470: OR
111471: IFFALSE 111475
// exit ;
111473: GO 111599
// x := GetX ( enemy ) ;
111475: LD_ADDR_VAR 0 4
111479: PUSH
111480: LD_VAR 0 2
111484: PPUSH
111485: CALL_OW 250
111489: ST_TO_ADDR
// y := GetY ( enemy ) ;
111490: LD_ADDR_VAR 0 5
111494: PUSH
111495: LD_VAR 0 2
111499: PPUSH
111500: CALL_OW 251
111504: ST_TO_ADDR
// if ValidHex ( x , y ) then
111505: LD_VAR 0 4
111509: PPUSH
111510: LD_VAR 0 5
111514: PPUSH
111515: CALL_OW 488
111519: IFFALSE 111599
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
111521: LD_VAR 0 2
111525: PPUSH
111526: CALL_OW 247
111530: PUSH
111531: LD_INT 3
111533: PUSH
111534: LD_INT 2
111536: PUSH
111537: EMPTY
111538: LIST
111539: LIST
111540: IN
111541: PUSH
111542: LD_VAR 0 1
111546: PPUSH
111547: CALL_OW 255
111551: PPUSH
111552: LD_VAR 0 2
111556: PPUSH
111557: CALL_OW 292
111561: OR
111562: IFFALSE 111580
// ComAttackUnit ( unit , enemy ) else
111564: LD_VAR 0 1
111568: PPUSH
111569: LD_VAR 0 2
111573: PPUSH
111574: CALL_OW 115
111578: GO 111599
// ComAgressiveMove ( unit , x , y ) ;
111580: LD_VAR 0 1
111584: PPUSH
111585: LD_VAR 0 4
111589: PPUSH
111590: LD_VAR 0 5
111594: PPUSH
111595: CALL_OW 114
// end ;
111599: LD_VAR 0 3
111603: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
111604: LD_INT 0
111606: PPUSH
111607: PPUSH
111608: PPUSH
// list := AreaToList ( area , 0 ) ;
111609: LD_ADDR_VAR 0 5
111613: PUSH
111614: LD_VAR 0 1
111618: PPUSH
111619: LD_INT 0
111621: PPUSH
111622: CALL_OW 517
111626: ST_TO_ADDR
// if not list then
111627: LD_VAR 0 5
111631: NOT
111632: IFFALSE 111636
// exit ;
111634: GO 111766
// if all then
111636: LD_VAR 0 2
111640: IFFALSE 111728
// begin for i := 1 to list [ 1 ] do
111642: LD_ADDR_VAR 0 4
111646: PUSH
111647: DOUBLE
111648: LD_INT 1
111650: DEC
111651: ST_TO_ADDR
111652: LD_VAR 0 5
111656: PUSH
111657: LD_INT 1
111659: ARRAY
111660: PUSH
111661: FOR_TO
111662: IFFALSE 111724
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
111664: LD_ADDR_VAR 0 3
111668: PUSH
111669: LD_VAR 0 3
111673: PPUSH
111674: LD_VAR 0 3
111678: PUSH
111679: LD_INT 1
111681: PLUS
111682: PPUSH
111683: LD_VAR 0 5
111687: PUSH
111688: LD_INT 1
111690: ARRAY
111691: PUSH
111692: LD_VAR 0 4
111696: ARRAY
111697: PUSH
111698: LD_VAR 0 5
111702: PUSH
111703: LD_INT 2
111705: ARRAY
111706: PUSH
111707: LD_VAR 0 4
111711: ARRAY
111712: PUSH
111713: EMPTY
111714: LIST
111715: LIST
111716: PPUSH
111717: CALL_OW 1
111721: ST_TO_ADDR
111722: GO 111661
111724: POP
111725: POP
// exit ;
111726: GO 111766
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
111728: LD_ADDR_VAR 0 3
111732: PUSH
111733: LD_VAR 0 5
111737: PUSH
111738: LD_INT 1
111740: ARRAY
111741: PUSH
111742: LD_INT 1
111744: ARRAY
111745: PUSH
111746: LD_VAR 0 5
111750: PUSH
111751: LD_INT 2
111753: ARRAY
111754: PUSH
111755: LD_INT 1
111757: ARRAY
111758: PUSH
111759: EMPTY
111760: LIST
111761: LIST
111762: PUSH
111763: EMPTY
111764: LIST
111765: ST_TO_ADDR
// end ;
111766: LD_VAR 0 3
111770: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
111771: LD_INT 0
111773: PPUSH
111774: PPUSH
// list := AreaToList ( area , 0 ) ;
111775: LD_ADDR_VAR 0 4
111779: PUSH
111780: LD_VAR 0 1
111784: PPUSH
111785: LD_INT 0
111787: PPUSH
111788: CALL_OW 517
111792: ST_TO_ADDR
// if not list then
111793: LD_VAR 0 4
111797: NOT
111798: IFFALSE 111802
// exit ;
111800: GO 111843
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
111802: LD_ADDR_VAR 0 3
111806: PUSH
111807: LD_VAR 0 4
111811: PUSH
111812: LD_INT 1
111814: ARRAY
111815: PUSH
111816: LD_INT 1
111818: ARRAY
111819: PUSH
111820: LD_VAR 0 4
111824: PUSH
111825: LD_INT 2
111827: ARRAY
111828: PUSH
111829: LD_INT 1
111831: ARRAY
111832: PUSH
111833: LD_VAR 0 2
111837: PUSH
111838: EMPTY
111839: LIST
111840: LIST
111841: LIST
111842: ST_TO_ADDR
// end ;
111843: LD_VAR 0 3
111847: RET
// export function First ( array ) ; begin
111848: LD_INT 0
111850: PPUSH
// if not array then
111851: LD_VAR 0 1
111855: NOT
111856: IFFALSE 111860
// exit ;
111858: GO 111874
// result := array [ 1 ] ;
111860: LD_ADDR_VAR 0 2
111864: PUSH
111865: LD_VAR 0 1
111869: PUSH
111870: LD_INT 1
111872: ARRAY
111873: ST_TO_ADDR
// end ;
111874: LD_VAR 0 2
111878: RET
// export function Last ( array ) ; begin
111879: LD_INT 0
111881: PPUSH
// if not array then
111882: LD_VAR 0 1
111886: NOT
111887: IFFALSE 111891
// exit ;
111889: GO 111907
// result := array [ array ] ;
111891: LD_ADDR_VAR 0 2
111895: PUSH
111896: LD_VAR 0 1
111900: PUSH
111901: LD_VAR 0 1
111905: ARRAY
111906: ST_TO_ADDR
// end ;
111907: LD_VAR 0 2
111911: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
111912: LD_INT 0
111914: PPUSH
111915: PPUSH
// result := [ ] ;
111916: LD_ADDR_VAR 0 5
111920: PUSH
111921: EMPTY
111922: ST_TO_ADDR
// if not array then
111923: LD_VAR 0 1
111927: NOT
111928: IFFALSE 111932
// exit ;
111930: GO 112044
// for i := 1 to array do
111932: LD_ADDR_VAR 0 6
111936: PUSH
111937: DOUBLE
111938: LD_INT 1
111940: DEC
111941: ST_TO_ADDR
111942: LD_VAR 0 1
111946: PUSH
111947: FOR_TO
111948: IFFALSE 112042
// if array [ i ] [ index ] = value then
111950: LD_VAR 0 1
111954: PUSH
111955: LD_VAR 0 6
111959: ARRAY
111960: PUSH
111961: LD_VAR 0 2
111965: ARRAY
111966: PUSH
111967: LD_VAR 0 3
111971: EQUAL
111972: IFFALSE 112040
// begin if indexColumn then
111974: LD_VAR 0 4
111978: IFFALSE 112014
// result := Join ( result , array [ i ] [ indexColumn ] ) else
111980: LD_ADDR_VAR 0 5
111984: PUSH
111985: LD_VAR 0 5
111989: PPUSH
111990: LD_VAR 0 1
111994: PUSH
111995: LD_VAR 0 6
111999: ARRAY
112000: PUSH
112001: LD_VAR 0 4
112005: ARRAY
112006: PPUSH
112007: CALL 107236 0 2
112011: ST_TO_ADDR
112012: GO 112040
// result := Join ( result , array [ i ] ) ;
112014: LD_ADDR_VAR 0 5
112018: PUSH
112019: LD_VAR 0 5
112023: PPUSH
112024: LD_VAR 0 1
112028: PUSH
112029: LD_VAR 0 6
112033: ARRAY
112034: PPUSH
112035: CALL 107236 0 2
112039: ST_TO_ADDR
// end ;
112040: GO 111947
112042: POP
112043: POP
// end ;
112044: LD_VAR 0 5
112048: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
112049: LD_INT 0
112051: PPUSH
// if not vehicles or not parkingPoint then
112052: LD_VAR 0 1
112056: NOT
112057: PUSH
112058: LD_VAR 0 2
112062: NOT
112063: OR
112064: IFFALSE 112068
// exit ;
112066: GO 112166
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
112068: LD_ADDR_VAR 0 1
112072: PUSH
112073: LD_VAR 0 1
112077: PPUSH
112078: LD_INT 50
112080: PUSH
112081: EMPTY
112082: LIST
112083: PUSH
112084: LD_INT 3
112086: PUSH
112087: LD_INT 92
112089: PUSH
112090: LD_VAR 0 2
112094: PUSH
112095: LD_INT 1
112097: ARRAY
112098: PUSH
112099: LD_VAR 0 2
112103: PUSH
112104: LD_INT 2
112106: ARRAY
112107: PUSH
112108: LD_INT 8
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: LIST
112115: LIST
112116: PUSH
112117: EMPTY
112118: LIST
112119: LIST
112120: PUSH
112121: EMPTY
112122: LIST
112123: LIST
112124: PPUSH
112125: CALL_OW 72
112129: ST_TO_ADDR
// if not vehicles then
112130: LD_VAR 0 1
112134: NOT
112135: IFFALSE 112139
// exit ;
112137: GO 112166
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
112139: LD_VAR 0 1
112143: PPUSH
112144: LD_VAR 0 2
112148: PUSH
112149: LD_INT 1
112151: ARRAY
112152: PPUSH
112153: LD_VAR 0 2
112157: PUSH
112158: LD_INT 2
112160: ARRAY
112161: PPUSH
112162: CALL_OW 111
// end ;
112166: LD_VAR 0 3
112170: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
112171: LD_INT 0
112173: PPUSH
112174: PPUSH
112175: PPUSH
// if not side or not area then
112176: LD_VAR 0 1
112180: NOT
112181: PUSH
112182: LD_VAR 0 2
112186: NOT
112187: OR
112188: IFFALSE 112192
// exit ;
112190: GO 112311
// tmp := AreaToList ( area , 0 ) ;
112192: LD_ADDR_VAR 0 5
112196: PUSH
112197: LD_VAR 0 2
112201: PPUSH
112202: LD_INT 0
112204: PPUSH
112205: CALL_OW 517
112209: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
112210: LD_ADDR_VAR 0 4
112214: PUSH
112215: DOUBLE
112216: LD_INT 1
112218: DEC
112219: ST_TO_ADDR
112220: LD_VAR 0 5
112224: PUSH
112225: LD_INT 1
112227: ARRAY
112228: PUSH
112229: FOR_TO
112230: IFFALSE 112309
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
112232: LD_VAR 0 5
112236: PUSH
112237: LD_INT 1
112239: ARRAY
112240: PUSH
112241: LD_VAR 0 4
112245: ARRAY
112246: PPUSH
112247: LD_VAR 0 5
112251: PUSH
112252: LD_INT 2
112254: ARRAY
112255: PUSH
112256: LD_VAR 0 4
112260: ARRAY
112261: PPUSH
112262: CALL_OW 351
112266: IFFALSE 112307
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
112268: LD_VAR 0 5
112272: PUSH
112273: LD_INT 1
112275: ARRAY
112276: PUSH
112277: LD_VAR 0 4
112281: ARRAY
112282: PPUSH
112283: LD_VAR 0 5
112287: PUSH
112288: LD_INT 2
112290: ARRAY
112291: PUSH
112292: LD_VAR 0 4
112296: ARRAY
112297: PPUSH
112298: LD_VAR 0 1
112302: PPUSH
112303: CALL_OW 244
// end ;
112307: GO 112229
112309: POP
112310: POP
// end ; end_of_file end_of_file
112311: LD_VAR 0 3
112315: RET
// export globalGameSaveCounter ; every 0 0$1 do
112316: GO 112318
112318: DISABLE
// begin enable ;
112319: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
112320: LD_STRING updateTimer(
112322: PUSH
112323: LD_OWVAR 1
112327: STR
112328: PUSH
112329: LD_STRING );
112331: STR
112332: PPUSH
112333: CALL_OW 559
// end ;
112337: END
// every 0 0$1 do
112338: GO 112340
112340: DISABLE
// begin globalGameSaveCounter := 0 ;
112341: LD_ADDR_EXP 147
112345: PUSH
112346: LD_INT 0
112348: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
112349: LD_STRING setGameSaveCounter(0)
112351: PPUSH
112352: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
112356: LD_STRING initStreamRollete();
112358: PPUSH
112359: CALL_OW 559
// InitStreamMode ;
112363: CALL 113706 0 0
// DefineStreamItems ( false ) ;
112367: LD_INT 0
112369: PPUSH
112370: CALL 114170 0 1
// end ;
112374: END
// export function SOS_MapStart ( ) ; begin
112375: LD_INT 0
112377: PPUSH
// if streamModeActive then
112378: LD_EXP 148
112382: IFFALSE 112391
// DefineStreamItems ( true ) ;
112384: LD_INT 1
112386: PPUSH
112387: CALL 114170 0 1
// UpdateLuaVariables ( ) ;
112391: CALL 112408 0 0
// UpdateFactoryWaypoints ( ) ;
112395: CALL 127039 0 0
// UpdateWarehouseGatheringPoints ( ) ;
112399: CALL 127296 0 0
// end ;
112403: LD_VAR 0 1
112407: RET
// function UpdateLuaVariables ( ) ; begin
112408: LD_INT 0
112410: PPUSH
// if globalGameSaveCounter then
112411: LD_EXP 147
112415: IFFALSE 112449
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
112417: LD_ADDR_EXP 147
112421: PUSH
112422: LD_EXP 147
112426: PPUSH
112427: CALL 108597 0 1
112431: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
112432: LD_STRING setGameSaveCounter(
112434: PUSH
112435: LD_EXP 147
112439: STR
112440: PUSH
112441: LD_STRING )
112443: STR
112444: PPUSH
112445: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
112449: LD_STRING setGameDifficulty(
112451: PUSH
112452: LD_OWVAR 67
112456: STR
112457: PUSH
112458: LD_STRING )
112460: STR
112461: PPUSH
112462: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
112466: LD_STRING displayDifficulty(
112468: PUSH
112469: LD_OWVAR 67
112473: STR
112474: PUSH
112475: LD_STRING )
112477: STR
112478: PPUSH
112479: CALL_OW 559
// end ;
112483: LD_VAR 0 1
112487: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112488: LD_INT 0
112490: PPUSH
// if p2 = stream_mode then
112491: LD_VAR 0 2
112495: PUSH
112496: LD_INT 100
112498: EQUAL
112499: IFFALSE 113502
// begin if not StreamModeActive then
112501: LD_EXP 148
112505: NOT
112506: IFFALSE 112516
// StreamModeActive := true ;
112508: LD_ADDR_EXP 148
112512: PUSH
112513: LD_INT 1
112515: ST_TO_ADDR
// if p3 = 0 then
112516: LD_VAR 0 3
112520: PUSH
112521: LD_INT 0
112523: EQUAL
112524: IFFALSE 112530
// InitStreamMode ;
112526: CALL 113706 0 0
// if p3 = 1 then
112530: LD_VAR 0 3
112534: PUSH
112535: LD_INT 1
112537: EQUAL
112538: IFFALSE 112548
// sRocket := true ;
112540: LD_ADDR_EXP 153
112544: PUSH
112545: LD_INT 1
112547: ST_TO_ADDR
// if p3 = 2 then
112548: LD_VAR 0 3
112552: PUSH
112553: LD_INT 2
112555: EQUAL
112556: IFFALSE 112566
// sSpeed := true ;
112558: LD_ADDR_EXP 152
112562: PUSH
112563: LD_INT 1
112565: ST_TO_ADDR
// if p3 = 3 then
112566: LD_VAR 0 3
112570: PUSH
112571: LD_INT 3
112573: EQUAL
112574: IFFALSE 112584
// sEngine := true ;
112576: LD_ADDR_EXP 154
112580: PUSH
112581: LD_INT 1
112583: ST_TO_ADDR
// if p3 = 4 then
112584: LD_VAR 0 3
112588: PUSH
112589: LD_INT 4
112591: EQUAL
112592: IFFALSE 112602
// sSpec := true ;
112594: LD_ADDR_EXP 151
112598: PUSH
112599: LD_INT 1
112601: ST_TO_ADDR
// if p3 = 5 then
112602: LD_VAR 0 3
112606: PUSH
112607: LD_INT 5
112609: EQUAL
112610: IFFALSE 112620
// sLevel := true ;
112612: LD_ADDR_EXP 155
112616: PUSH
112617: LD_INT 1
112619: ST_TO_ADDR
// if p3 = 6 then
112620: LD_VAR 0 3
112624: PUSH
112625: LD_INT 6
112627: EQUAL
112628: IFFALSE 112638
// sArmoury := true ;
112630: LD_ADDR_EXP 156
112634: PUSH
112635: LD_INT 1
112637: ST_TO_ADDR
// if p3 = 7 then
112638: LD_VAR 0 3
112642: PUSH
112643: LD_INT 7
112645: EQUAL
112646: IFFALSE 112656
// sRadar := true ;
112648: LD_ADDR_EXP 157
112652: PUSH
112653: LD_INT 1
112655: ST_TO_ADDR
// if p3 = 8 then
112656: LD_VAR 0 3
112660: PUSH
112661: LD_INT 8
112663: EQUAL
112664: IFFALSE 112674
// sBunker := true ;
112666: LD_ADDR_EXP 158
112670: PUSH
112671: LD_INT 1
112673: ST_TO_ADDR
// if p3 = 9 then
112674: LD_VAR 0 3
112678: PUSH
112679: LD_INT 9
112681: EQUAL
112682: IFFALSE 112692
// sHack := true ;
112684: LD_ADDR_EXP 159
112688: PUSH
112689: LD_INT 1
112691: ST_TO_ADDR
// if p3 = 10 then
112692: LD_VAR 0 3
112696: PUSH
112697: LD_INT 10
112699: EQUAL
112700: IFFALSE 112710
// sFire := true ;
112702: LD_ADDR_EXP 160
112706: PUSH
112707: LD_INT 1
112709: ST_TO_ADDR
// if p3 = 11 then
112710: LD_VAR 0 3
112714: PUSH
112715: LD_INT 11
112717: EQUAL
112718: IFFALSE 112728
// sRefresh := true ;
112720: LD_ADDR_EXP 161
112724: PUSH
112725: LD_INT 1
112727: ST_TO_ADDR
// if p3 = 12 then
112728: LD_VAR 0 3
112732: PUSH
112733: LD_INT 12
112735: EQUAL
112736: IFFALSE 112746
// sExp := true ;
112738: LD_ADDR_EXP 162
112742: PUSH
112743: LD_INT 1
112745: ST_TO_ADDR
// if p3 = 13 then
112746: LD_VAR 0 3
112750: PUSH
112751: LD_INT 13
112753: EQUAL
112754: IFFALSE 112764
// sDepot := true ;
112756: LD_ADDR_EXP 163
112760: PUSH
112761: LD_INT 1
112763: ST_TO_ADDR
// if p3 = 14 then
112764: LD_VAR 0 3
112768: PUSH
112769: LD_INT 14
112771: EQUAL
112772: IFFALSE 112782
// sFlag := true ;
112774: LD_ADDR_EXP 164
112778: PUSH
112779: LD_INT 1
112781: ST_TO_ADDR
// if p3 = 15 then
112782: LD_VAR 0 3
112786: PUSH
112787: LD_INT 15
112789: EQUAL
112790: IFFALSE 112800
// sKamikadze := true ;
112792: LD_ADDR_EXP 172
112796: PUSH
112797: LD_INT 1
112799: ST_TO_ADDR
// if p3 = 16 then
112800: LD_VAR 0 3
112804: PUSH
112805: LD_INT 16
112807: EQUAL
112808: IFFALSE 112818
// sTroll := true ;
112810: LD_ADDR_EXP 173
112814: PUSH
112815: LD_INT 1
112817: ST_TO_ADDR
// if p3 = 17 then
112818: LD_VAR 0 3
112822: PUSH
112823: LD_INT 17
112825: EQUAL
112826: IFFALSE 112836
// sSlow := true ;
112828: LD_ADDR_EXP 174
112832: PUSH
112833: LD_INT 1
112835: ST_TO_ADDR
// if p3 = 18 then
112836: LD_VAR 0 3
112840: PUSH
112841: LD_INT 18
112843: EQUAL
112844: IFFALSE 112854
// sLack := true ;
112846: LD_ADDR_EXP 175
112850: PUSH
112851: LD_INT 1
112853: ST_TO_ADDR
// if p3 = 19 then
112854: LD_VAR 0 3
112858: PUSH
112859: LD_INT 19
112861: EQUAL
112862: IFFALSE 112872
// sTank := true ;
112864: LD_ADDR_EXP 177
112868: PUSH
112869: LD_INT 1
112871: ST_TO_ADDR
// if p3 = 20 then
112872: LD_VAR 0 3
112876: PUSH
112877: LD_INT 20
112879: EQUAL
112880: IFFALSE 112890
// sRemote := true ;
112882: LD_ADDR_EXP 178
112886: PUSH
112887: LD_INT 1
112889: ST_TO_ADDR
// if p3 = 21 then
112890: LD_VAR 0 3
112894: PUSH
112895: LD_INT 21
112897: EQUAL
112898: IFFALSE 112908
// sPowell := true ;
112900: LD_ADDR_EXP 179
112904: PUSH
112905: LD_INT 1
112907: ST_TO_ADDR
// if p3 = 22 then
112908: LD_VAR 0 3
112912: PUSH
112913: LD_INT 22
112915: EQUAL
112916: IFFALSE 112926
// sTeleport := true ;
112918: LD_ADDR_EXP 182
112922: PUSH
112923: LD_INT 1
112925: ST_TO_ADDR
// if p3 = 23 then
112926: LD_VAR 0 3
112930: PUSH
112931: LD_INT 23
112933: EQUAL
112934: IFFALSE 112944
// sOilTower := true ;
112936: LD_ADDR_EXP 184
112940: PUSH
112941: LD_INT 1
112943: ST_TO_ADDR
// if p3 = 24 then
112944: LD_VAR 0 3
112948: PUSH
112949: LD_INT 24
112951: EQUAL
112952: IFFALSE 112962
// sShovel := true ;
112954: LD_ADDR_EXP 185
112958: PUSH
112959: LD_INT 1
112961: ST_TO_ADDR
// if p3 = 25 then
112962: LD_VAR 0 3
112966: PUSH
112967: LD_INT 25
112969: EQUAL
112970: IFFALSE 112980
// sSheik := true ;
112972: LD_ADDR_EXP 186
112976: PUSH
112977: LD_INT 1
112979: ST_TO_ADDR
// if p3 = 26 then
112980: LD_VAR 0 3
112984: PUSH
112985: LD_INT 26
112987: EQUAL
112988: IFFALSE 112998
// sEarthquake := true ;
112990: LD_ADDR_EXP 188
112994: PUSH
112995: LD_INT 1
112997: ST_TO_ADDR
// if p3 = 27 then
112998: LD_VAR 0 3
113002: PUSH
113003: LD_INT 27
113005: EQUAL
113006: IFFALSE 113016
// sAI := true ;
113008: LD_ADDR_EXP 189
113012: PUSH
113013: LD_INT 1
113015: ST_TO_ADDR
// if p3 = 28 then
113016: LD_VAR 0 3
113020: PUSH
113021: LD_INT 28
113023: EQUAL
113024: IFFALSE 113034
// sCargo := true ;
113026: LD_ADDR_EXP 192
113030: PUSH
113031: LD_INT 1
113033: ST_TO_ADDR
// if p3 = 29 then
113034: LD_VAR 0 3
113038: PUSH
113039: LD_INT 29
113041: EQUAL
113042: IFFALSE 113052
// sDLaser := true ;
113044: LD_ADDR_EXP 193
113048: PUSH
113049: LD_INT 1
113051: ST_TO_ADDR
// if p3 = 30 then
113052: LD_VAR 0 3
113056: PUSH
113057: LD_INT 30
113059: EQUAL
113060: IFFALSE 113070
// sExchange := true ;
113062: LD_ADDR_EXP 194
113066: PUSH
113067: LD_INT 1
113069: ST_TO_ADDR
// if p3 = 31 then
113070: LD_VAR 0 3
113074: PUSH
113075: LD_INT 31
113077: EQUAL
113078: IFFALSE 113088
// sFac := true ;
113080: LD_ADDR_EXP 195
113084: PUSH
113085: LD_INT 1
113087: ST_TO_ADDR
// if p3 = 32 then
113088: LD_VAR 0 3
113092: PUSH
113093: LD_INT 32
113095: EQUAL
113096: IFFALSE 113106
// sPower := true ;
113098: LD_ADDR_EXP 196
113102: PUSH
113103: LD_INT 1
113105: ST_TO_ADDR
// if p3 = 33 then
113106: LD_VAR 0 3
113110: PUSH
113111: LD_INT 33
113113: EQUAL
113114: IFFALSE 113124
// sRandom := true ;
113116: LD_ADDR_EXP 197
113120: PUSH
113121: LD_INT 1
113123: ST_TO_ADDR
// if p3 = 34 then
113124: LD_VAR 0 3
113128: PUSH
113129: LD_INT 34
113131: EQUAL
113132: IFFALSE 113142
// sShield := true ;
113134: LD_ADDR_EXP 198
113138: PUSH
113139: LD_INT 1
113141: ST_TO_ADDR
// if p3 = 35 then
113142: LD_VAR 0 3
113146: PUSH
113147: LD_INT 35
113149: EQUAL
113150: IFFALSE 113160
// sTime := true ;
113152: LD_ADDR_EXP 199
113156: PUSH
113157: LD_INT 1
113159: ST_TO_ADDR
// if p3 = 36 then
113160: LD_VAR 0 3
113164: PUSH
113165: LD_INT 36
113167: EQUAL
113168: IFFALSE 113178
// sTools := true ;
113170: LD_ADDR_EXP 200
113174: PUSH
113175: LD_INT 1
113177: ST_TO_ADDR
// if p3 = 101 then
113178: LD_VAR 0 3
113182: PUSH
113183: LD_INT 101
113185: EQUAL
113186: IFFALSE 113196
// sSold := true ;
113188: LD_ADDR_EXP 165
113192: PUSH
113193: LD_INT 1
113195: ST_TO_ADDR
// if p3 = 102 then
113196: LD_VAR 0 3
113200: PUSH
113201: LD_INT 102
113203: EQUAL
113204: IFFALSE 113214
// sDiff := true ;
113206: LD_ADDR_EXP 166
113210: PUSH
113211: LD_INT 1
113213: ST_TO_ADDR
// if p3 = 103 then
113214: LD_VAR 0 3
113218: PUSH
113219: LD_INT 103
113221: EQUAL
113222: IFFALSE 113232
// sFog := true ;
113224: LD_ADDR_EXP 169
113228: PUSH
113229: LD_INT 1
113231: ST_TO_ADDR
// if p3 = 104 then
113232: LD_VAR 0 3
113236: PUSH
113237: LD_INT 104
113239: EQUAL
113240: IFFALSE 113250
// sReset := true ;
113242: LD_ADDR_EXP 170
113246: PUSH
113247: LD_INT 1
113249: ST_TO_ADDR
// if p3 = 105 then
113250: LD_VAR 0 3
113254: PUSH
113255: LD_INT 105
113257: EQUAL
113258: IFFALSE 113268
// sSun := true ;
113260: LD_ADDR_EXP 171
113264: PUSH
113265: LD_INT 1
113267: ST_TO_ADDR
// if p3 = 106 then
113268: LD_VAR 0 3
113272: PUSH
113273: LD_INT 106
113275: EQUAL
113276: IFFALSE 113286
// sTiger := true ;
113278: LD_ADDR_EXP 167
113282: PUSH
113283: LD_INT 1
113285: ST_TO_ADDR
// if p3 = 107 then
113286: LD_VAR 0 3
113290: PUSH
113291: LD_INT 107
113293: EQUAL
113294: IFFALSE 113304
// sBomb := true ;
113296: LD_ADDR_EXP 168
113300: PUSH
113301: LD_INT 1
113303: ST_TO_ADDR
// if p3 = 108 then
113304: LD_VAR 0 3
113308: PUSH
113309: LD_INT 108
113311: EQUAL
113312: IFFALSE 113322
// sWound := true ;
113314: LD_ADDR_EXP 176
113318: PUSH
113319: LD_INT 1
113321: ST_TO_ADDR
// if p3 = 109 then
113322: LD_VAR 0 3
113326: PUSH
113327: LD_INT 109
113329: EQUAL
113330: IFFALSE 113340
// sBetray := true ;
113332: LD_ADDR_EXP 180
113336: PUSH
113337: LD_INT 1
113339: ST_TO_ADDR
// if p3 = 110 then
113340: LD_VAR 0 3
113344: PUSH
113345: LD_INT 110
113347: EQUAL
113348: IFFALSE 113358
// sContamin := true ;
113350: LD_ADDR_EXP 181
113354: PUSH
113355: LD_INT 1
113357: ST_TO_ADDR
// if p3 = 111 then
113358: LD_VAR 0 3
113362: PUSH
113363: LD_INT 111
113365: EQUAL
113366: IFFALSE 113376
// sOil := true ;
113368: LD_ADDR_EXP 183
113372: PUSH
113373: LD_INT 1
113375: ST_TO_ADDR
// if p3 = 112 then
113376: LD_VAR 0 3
113380: PUSH
113381: LD_INT 112
113383: EQUAL
113384: IFFALSE 113394
// sStu := true ;
113386: LD_ADDR_EXP 187
113390: PUSH
113391: LD_INT 1
113393: ST_TO_ADDR
// if p3 = 113 then
113394: LD_VAR 0 3
113398: PUSH
113399: LD_INT 113
113401: EQUAL
113402: IFFALSE 113412
// sBazooka := true ;
113404: LD_ADDR_EXP 190
113408: PUSH
113409: LD_INT 1
113411: ST_TO_ADDR
// if p3 = 114 then
113412: LD_VAR 0 3
113416: PUSH
113417: LD_INT 114
113419: EQUAL
113420: IFFALSE 113430
// sMortar := true ;
113422: LD_ADDR_EXP 191
113426: PUSH
113427: LD_INT 1
113429: ST_TO_ADDR
// if p3 = 115 then
113430: LD_VAR 0 3
113434: PUSH
113435: LD_INT 115
113437: EQUAL
113438: IFFALSE 113448
// sRanger := true ;
113440: LD_ADDR_EXP 201
113444: PUSH
113445: LD_INT 1
113447: ST_TO_ADDR
// if p3 = 116 then
113448: LD_VAR 0 3
113452: PUSH
113453: LD_INT 116
113455: EQUAL
113456: IFFALSE 113466
// sComputer := true ;
113458: LD_ADDR_EXP 202
113462: PUSH
113463: LD_INT 1
113465: ST_TO_ADDR
// if p3 = 117 then
113466: LD_VAR 0 3
113470: PUSH
113471: LD_INT 117
113473: EQUAL
113474: IFFALSE 113484
// s30 := true ;
113476: LD_ADDR_EXP 203
113480: PUSH
113481: LD_INT 1
113483: ST_TO_ADDR
// if p3 = 118 then
113484: LD_VAR 0 3
113488: PUSH
113489: LD_INT 118
113491: EQUAL
113492: IFFALSE 113502
// s60 := true ;
113494: LD_ADDR_EXP 204
113498: PUSH
113499: LD_INT 1
113501: ST_TO_ADDR
// end ; if p2 = hack_mode then
113502: LD_VAR 0 2
113506: PUSH
113507: LD_INT 101
113509: EQUAL
113510: IFFALSE 113638
// begin case p3 of 1 :
113512: LD_VAR 0 3
113516: PUSH
113517: LD_INT 1
113519: DOUBLE
113520: EQUAL
113521: IFTRUE 113525
113523: GO 113532
113525: POP
// hHackUnlimitedResources ; 2 :
113526: CALL 125785 0 0
113530: GO 113638
113532: LD_INT 2
113534: DOUBLE
113535: EQUAL
113536: IFTRUE 113540
113538: GO 113547
113540: POP
// hHackSetLevel10 ; 3 :
113541: CALL 125918 0 0
113545: GO 113638
113547: LD_INT 3
113549: DOUBLE
113550: EQUAL
113551: IFTRUE 113555
113553: GO 113562
113555: POP
// hHackSetLevel10YourUnits ; 4 :
113556: CALL 126003 0 0
113560: GO 113638
113562: LD_INT 4
113564: DOUBLE
113565: EQUAL
113566: IFTRUE 113570
113568: GO 113577
113570: POP
// hHackInvincible ; 5 :
113571: CALL 126451 0 0
113575: GO 113638
113577: LD_INT 5
113579: DOUBLE
113580: EQUAL
113581: IFTRUE 113585
113583: GO 113592
113585: POP
// hHackInvisible ; 6 :
113586: CALL 126562 0 0
113590: GO 113638
113592: LD_INT 6
113594: DOUBLE
113595: EQUAL
113596: IFTRUE 113600
113598: GO 113607
113600: POP
// hHackChangeYourSide ; 7 :
113601: CALL 126619 0 0
113605: GO 113638
113607: LD_INT 7
113609: DOUBLE
113610: EQUAL
113611: IFTRUE 113615
113613: GO 113622
113615: POP
// hHackChangeUnitSide ; 8 :
113616: CALL 126661 0 0
113620: GO 113638
113622: LD_INT 8
113624: DOUBLE
113625: EQUAL
113626: IFTRUE 113630
113628: GO 113637
113630: POP
// hHackFog ; end ;
113631: CALL 126762 0 0
113635: GO 113638
113637: POP
// end ; if p2 = game_save_mode then
113638: LD_VAR 0 2
113642: PUSH
113643: LD_INT 102
113645: EQUAL
113646: IFFALSE 113701
// begin if p3 = 1 then
113648: LD_VAR 0 3
113652: PUSH
113653: LD_INT 1
113655: EQUAL
113656: IFFALSE 113668
// globalGameSaveCounter := p4 ;
113658: LD_ADDR_EXP 147
113662: PUSH
113663: LD_VAR 0 4
113667: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
113668: LD_VAR 0 3
113672: PUSH
113673: LD_INT 2
113675: EQUAL
113676: PUSH
113677: LD_EXP 147
113681: AND
113682: IFFALSE 113701
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
113684: LD_STRING setGameSaveCounter(
113686: PUSH
113687: LD_EXP 147
113691: STR
113692: PUSH
113693: LD_STRING )
113695: STR
113696: PPUSH
113697: CALL_OW 559
// end ; end ;
113701: LD_VAR 0 7
113705: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
113706: LD_INT 0
113708: PPUSH
// streamModeActive := false ;
113709: LD_ADDR_EXP 148
113713: PUSH
113714: LD_INT 0
113716: ST_TO_ADDR
// normalCounter := 36 ;
113717: LD_ADDR_EXP 149
113721: PUSH
113722: LD_INT 36
113724: ST_TO_ADDR
// hardcoreCounter := 18 ;
113725: LD_ADDR_EXP 150
113729: PUSH
113730: LD_INT 18
113732: ST_TO_ADDR
// sRocket := false ;
113733: LD_ADDR_EXP 153
113737: PUSH
113738: LD_INT 0
113740: ST_TO_ADDR
// sSpeed := false ;
113741: LD_ADDR_EXP 152
113745: PUSH
113746: LD_INT 0
113748: ST_TO_ADDR
// sEngine := false ;
113749: LD_ADDR_EXP 154
113753: PUSH
113754: LD_INT 0
113756: ST_TO_ADDR
// sSpec := false ;
113757: LD_ADDR_EXP 151
113761: PUSH
113762: LD_INT 0
113764: ST_TO_ADDR
// sLevel := false ;
113765: LD_ADDR_EXP 155
113769: PUSH
113770: LD_INT 0
113772: ST_TO_ADDR
// sArmoury := false ;
113773: LD_ADDR_EXP 156
113777: PUSH
113778: LD_INT 0
113780: ST_TO_ADDR
// sRadar := false ;
113781: LD_ADDR_EXP 157
113785: PUSH
113786: LD_INT 0
113788: ST_TO_ADDR
// sBunker := false ;
113789: LD_ADDR_EXP 158
113793: PUSH
113794: LD_INT 0
113796: ST_TO_ADDR
// sHack := false ;
113797: LD_ADDR_EXP 159
113801: PUSH
113802: LD_INT 0
113804: ST_TO_ADDR
// sFire := false ;
113805: LD_ADDR_EXP 160
113809: PUSH
113810: LD_INT 0
113812: ST_TO_ADDR
// sRefresh := false ;
113813: LD_ADDR_EXP 161
113817: PUSH
113818: LD_INT 0
113820: ST_TO_ADDR
// sExp := false ;
113821: LD_ADDR_EXP 162
113825: PUSH
113826: LD_INT 0
113828: ST_TO_ADDR
// sDepot := false ;
113829: LD_ADDR_EXP 163
113833: PUSH
113834: LD_INT 0
113836: ST_TO_ADDR
// sFlag := false ;
113837: LD_ADDR_EXP 164
113841: PUSH
113842: LD_INT 0
113844: ST_TO_ADDR
// sKamikadze := false ;
113845: LD_ADDR_EXP 172
113849: PUSH
113850: LD_INT 0
113852: ST_TO_ADDR
// sTroll := false ;
113853: LD_ADDR_EXP 173
113857: PUSH
113858: LD_INT 0
113860: ST_TO_ADDR
// sSlow := false ;
113861: LD_ADDR_EXP 174
113865: PUSH
113866: LD_INT 0
113868: ST_TO_ADDR
// sLack := false ;
113869: LD_ADDR_EXP 175
113873: PUSH
113874: LD_INT 0
113876: ST_TO_ADDR
// sTank := false ;
113877: LD_ADDR_EXP 177
113881: PUSH
113882: LD_INT 0
113884: ST_TO_ADDR
// sRemote := false ;
113885: LD_ADDR_EXP 178
113889: PUSH
113890: LD_INT 0
113892: ST_TO_ADDR
// sPowell := false ;
113893: LD_ADDR_EXP 179
113897: PUSH
113898: LD_INT 0
113900: ST_TO_ADDR
// sTeleport := false ;
113901: LD_ADDR_EXP 182
113905: PUSH
113906: LD_INT 0
113908: ST_TO_ADDR
// sOilTower := false ;
113909: LD_ADDR_EXP 184
113913: PUSH
113914: LD_INT 0
113916: ST_TO_ADDR
// sShovel := false ;
113917: LD_ADDR_EXP 185
113921: PUSH
113922: LD_INT 0
113924: ST_TO_ADDR
// sSheik := false ;
113925: LD_ADDR_EXP 186
113929: PUSH
113930: LD_INT 0
113932: ST_TO_ADDR
// sEarthquake := false ;
113933: LD_ADDR_EXP 188
113937: PUSH
113938: LD_INT 0
113940: ST_TO_ADDR
// sAI := false ;
113941: LD_ADDR_EXP 189
113945: PUSH
113946: LD_INT 0
113948: ST_TO_ADDR
// sCargo := false ;
113949: LD_ADDR_EXP 192
113953: PUSH
113954: LD_INT 0
113956: ST_TO_ADDR
// sDLaser := false ;
113957: LD_ADDR_EXP 193
113961: PUSH
113962: LD_INT 0
113964: ST_TO_ADDR
// sExchange := false ;
113965: LD_ADDR_EXP 194
113969: PUSH
113970: LD_INT 0
113972: ST_TO_ADDR
// sFac := false ;
113973: LD_ADDR_EXP 195
113977: PUSH
113978: LD_INT 0
113980: ST_TO_ADDR
// sPower := false ;
113981: LD_ADDR_EXP 196
113985: PUSH
113986: LD_INT 0
113988: ST_TO_ADDR
// sRandom := false ;
113989: LD_ADDR_EXP 197
113993: PUSH
113994: LD_INT 0
113996: ST_TO_ADDR
// sShield := false ;
113997: LD_ADDR_EXP 198
114001: PUSH
114002: LD_INT 0
114004: ST_TO_ADDR
// sTime := false ;
114005: LD_ADDR_EXP 199
114009: PUSH
114010: LD_INT 0
114012: ST_TO_ADDR
// sTools := false ;
114013: LD_ADDR_EXP 200
114017: PUSH
114018: LD_INT 0
114020: ST_TO_ADDR
// sSold := false ;
114021: LD_ADDR_EXP 165
114025: PUSH
114026: LD_INT 0
114028: ST_TO_ADDR
// sDiff := false ;
114029: LD_ADDR_EXP 166
114033: PUSH
114034: LD_INT 0
114036: ST_TO_ADDR
// sFog := false ;
114037: LD_ADDR_EXP 169
114041: PUSH
114042: LD_INT 0
114044: ST_TO_ADDR
// sReset := false ;
114045: LD_ADDR_EXP 170
114049: PUSH
114050: LD_INT 0
114052: ST_TO_ADDR
// sSun := false ;
114053: LD_ADDR_EXP 171
114057: PUSH
114058: LD_INT 0
114060: ST_TO_ADDR
// sTiger := false ;
114061: LD_ADDR_EXP 167
114065: PUSH
114066: LD_INT 0
114068: ST_TO_ADDR
// sBomb := false ;
114069: LD_ADDR_EXP 168
114073: PUSH
114074: LD_INT 0
114076: ST_TO_ADDR
// sWound := false ;
114077: LD_ADDR_EXP 176
114081: PUSH
114082: LD_INT 0
114084: ST_TO_ADDR
// sBetray := false ;
114085: LD_ADDR_EXP 180
114089: PUSH
114090: LD_INT 0
114092: ST_TO_ADDR
// sContamin := false ;
114093: LD_ADDR_EXP 181
114097: PUSH
114098: LD_INT 0
114100: ST_TO_ADDR
// sOil := false ;
114101: LD_ADDR_EXP 183
114105: PUSH
114106: LD_INT 0
114108: ST_TO_ADDR
// sStu := false ;
114109: LD_ADDR_EXP 187
114113: PUSH
114114: LD_INT 0
114116: ST_TO_ADDR
// sBazooka := false ;
114117: LD_ADDR_EXP 190
114121: PUSH
114122: LD_INT 0
114124: ST_TO_ADDR
// sMortar := false ;
114125: LD_ADDR_EXP 191
114129: PUSH
114130: LD_INT 0
114132: ST_TO_ADDR
// sRanger := false ;
114133: LD_ADDR_EXP 201
114137: PUSH
114138: LD_INT 0
114140: ST_TO_ADDR
// sComputer := false ;
114141: LD_ADDR_EXP 202
114145: PUSH
114146: LD_INT 0
114148: ST_TO_ADDR
// s30 := false ;
114149: LD_ADDR_EXP 203
114153: PUSH
114154: LD_INT 0
114156: ST_TO_ADDR
// s60 := false ;
114157: LD_ADDR_EXP 204
114161: PUSH
114162: LD_INT 0
114164: ST_TO_ADDR
// end ;
114165: LD_VAR 0 1
114169: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
114170: LD_INT 0
114172: PPUSH
114173: PPUSH
114174: PPUSH
114175: PPUSH
114176: PPUSH
114177: PPUSH
114178: PPUSH
// result := [ ] ;
114179: LD_ADDR_VAR 0 2
114183: PUSH
114184: EMPTY
114185: ST_TO_ADDR
// if campaign_id = 1 then
114186: LD_OWVAR 69
114190: PUSH
114191: LD_INT 1
114193: EQUAL
114194: IFFALSE 117360
// begin case mission_number of 1 :
114196: LD_OWVAR 70
114200: PUSH
114201: LD_INT 1
114203: DOUBLE
114204: EQUAL
114205: IFTRUE 114209
114207: GO 114285
114209: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
114210: LD_ADDR_VAR 0 2
114214: PUSH
114215: LD_INT 2
114217: PUSH
114218: LD_INT 4
114220: PUSH
114221: LD_INT 11
114223: PUSH
114224: LD_INT 12
114226: PUSH
114227: LD_INT 15
114229: PUSH
114230: LD_INT 16
114232: PUSH
114233: LD_INT 22
114235: PUSH
114236: LD_INT 23
114238: PUSH
114239: LD_INT 26
114241: PUSH
114242: EMPTY
114243: LIST
114244: LIST
114245: LIST
114246: LIST
114247: LIST
114248: LIST
114249: LIST
114250: LIST
114251: LIST
114252: PUSH
114253: LD_INT 101
114255: PUSH
114256: LD_INT 102
114258: PUSH
114259: LD_INT 106
114261: PUSH
114262: LD_INT 116
114264: PUSH
114265: LD_INT 117
114267: PUSH
114268: LD_INT 118
114270: PUSH
114271: EMPTY
114272: LIST
114273: LIST
114274: LIST
114275: LIST
114276: LIST
114277: LIST
114278: PUSH
114279: EMPTY
114280: LIST
114281: LIST
114282: ST_TO_ADDR
114283: GO 117358
114285: LD_INT 2
114287: DOUBLE
114288: EQUAL
114289: IFTRUE 114293
114291: GO 114377
114293: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
114294: LD_ADDR_VAR 0 2
114298: PUSH
114299: LD_INT 2
114301: PUSH
114302: LD_INT 4
114304: PUSH
114305: LD_INT 11
114307: PUSH
114308: LD_INT 12
114310: PUSH
114311: LD_INT 15
114313: PUSH
114314: LD_INT 16
114316: PUSH
114317: LD_INT 22
114319: PUSH
114320: LD_INT 23
114322: PUSH
114323: LD_INT 26
114325: PUSH
114326: EMPTY
114327: LIST
114328: LIST
114329: LIST
114330: LIST
114331: LIST
114332: LIST
114333: LIST
114334: LIST
114335: LIST
114336: PUSH
114337: LD_INT 101
114339: PUSH
114340: LD_INT 102
114342: PUSH
114343: LD_INT 105
114345: PUSH
114346: LD_INT 106
114348: PUSH
114349: LD_INT 108
114351: PUSH
114352: LD_INT 116
114354: PUSH
114355: LD_INT 117
114357: PUSH
114358: LD_INT 118
114360: PUSH
114361: EMPTY
114362: LIST
114363: LIST
114364: LIST
114365: LIST
114366: LIST
114367: LIST
114368: LIST
114369: LIST
114370: PUSH
114371: EMPTY
114372: LIST
114373: LIST
114374: ST_TO_ADDR
114375: GO 117358
114377: LD_INT 3
114379: DOUBLE
114380: EQUAL
114381: IFTRUE 114385
114383: GO 114473
114385: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
114386: LD_ADDR_VAR 0 2
114390: PUSH
114391: LD_INT 2
114393: PUSH
114394: LD_INT 4
114396: PUSH
114397: LD_INT 5
114399: PUSH
114400: LD_INT 11
114402: PUSH
114403: LD_INT 12
114405: PUSH
114406: LD_INT 15
114408: PUSH
114409: LD_INT 16
114411: PUSH
114412: LD_INT 22
114414: PUSH
114415: LD_INT 26
114417: PUSH
114418: LD_INT 36
114420: PUSH
114421: EMPTY
114422: LIST
114423: LIST
114424: LIST
114425: LIST
114426: LIST
114427: LIST
114428: LIST
114429: LIST
114430: LIST
114431: LIST
114432: PUSH
114433: LD_INT 101
114435: PUSH
114436: LD_INT 102
114438: PUSH
114439: LD_INT 105
114441: PUSH
114442: LD_INT 106
114444: PUSH
114445: LD_INT 108
114447: PUSH
114448: LD_INT 116
114450: PUSH
114451: LD_INT 117
114453: PUSH
114454: LD_INT 118
114456: PUSH
114457: EMPTY
114458: LIST
114459: LIST
114460: LIST
114461: LIST
114462: LIST
114463: LIST
114464: LIST
114465: LIST
114466: PUSH
114467: EMPTY
114468: LIST
114469: LIST
114470: ST_TO_ADDR
114471: GO 117358
114473: LD_INT 4
114475: DOUBLE
114476: EQUAL
114477: IFTRUE 114481
114479: GO 114577
114481: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
114482: LD_ADDR_VAR 0 2
114486: PUSH
114487: LD_INT 2
114489: PUSH
114490: LD_INT 4
114492: PUSH
114493: LD_INT 5
114495: PUSH
114496: LD_INT 8
114498: PUSH
114499: LD_INT 11
114501: PUSH
114502: LD_INT 12
114504: PUSH
114505: LD_INT 15
114507: PUSH
114508: LD_INT 16
114510: PUSH
114511: LD_INT 22
114513: PUSH
114514: LD_INT 23
114516: PUSH
114517: LD_INT 26
114519: PUSH
114520: LD_INT 36
114522: PUSH
114523: EMPTY
114524: LIST
114525: LIST
114526: LIST
114527: LIST
114528: LIST
114529: LIST
114530: LIST
114531: LIST
114532: LIST
114533: LIST
114534: LIST
114535: LIST
114536: PUSH
114537: LD_INT 101
114539: PUSH
114540: LD_INT 102
114542: PUSH
114543: LD_INT 105
114545: PUSH
114546: LD_INT 106
114548: PUSH
114549: LD_INT 108
114551: PUSH
114552: LD_INT 116
114554: PUSH
114555: LD_INT 117
114557: PUSH
114558: LD_INT 118
114560: PUSH
114561: EMPTY
114562: LIST
114563: LIST
114564: LIST
114565: LIST
114566: LIST
114567: LIST
114568: LIST
114569: LIST
114570: PUSH
114571: EMPTY
114572: LIST
114573: LIST
114574: ST_TO_ADDR
114575: GO 117358
114577: LD_INT 5
114579: DOUBLE
114580: EQUAL
114581: IFTRUE 114585
114583: GO 114697
114585: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
114586: LD_ADDR_VAR 0 2
114590: PUSH
114591: LD_INT 2
114593: PUSH
114594: LD_INT 4
114596: PUSH
114597: LD_INT 5
114599: PUSH
114600: LD_INT 6
114602: PUSH
114603: LD_INT 8
114605: PUSH
114606: LD_INT 11
114608: PUSH
114609: LD_INT 12
114611: PUSH
114612: LD_INT 15
114614: PUSH
114615: LD_INT 16
114617: PUSH
114618: LD_INT 22
114620: PUSH
114621: LD_INT 23
114623: PUSH
114624: LD_INT 25
114626: PUSH
114627: LD_INT 26
114629: PUSH
114630: LD_INT 36
114632: PUSH
114633: EMPTY
114634: LIST
114635: LIST
114636: LIST
114637: LIST
114638: LIST
114639: LIST
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: LIST
114645: LIST
114646: LIST
114647: LIST
114648: PUSH
114649: LD_INT 101
114651: PUSH
114652: LD_INT 102
114654: PUSH
114655: LD_INT 105
114657: PUSH
114658: LD_INT 106
114660: PUSH
114661: LD_INT 108
114663: PUSH
114664: LD_INT 109
114666: PUSH
114667: LD_INT 112
114669: PUSH
114670: LD_INT 116
114672: PUSH
114673: LD_INT 117
114675: PUSH
114676: LD_INT 118
114678: PUSH
114679: EMPTY
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: PUSH
114691: EMPTY
114692: LIST
114693: LIST
114694: ST_TO_ADDR
114695: GO 117358
114697: LD_INT 6
114699: DOUBLE
114700: EQUAL
114701: IFTRUE 114705
114703: GO 114837
114705: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
114706: LD_ADDR_VAR 0 2
114710: PUSH
114711: LD_INT 2
114713: PUSH
114714: LD_INT 4
114716: PUSH
114717: LD_INT 5
114719: PUSH
114720: LD_INT 6
114722: PUSH
114723: LD_INT 8
114725: PUSH
114726: LD_INT 11
114728: PUSH
114729: LD_INT 12
114731: PUSH
114732: LD_INT 15
114734: PUSH
114735: LD_INT 16
114737: PUSH
114738: LD_INT 20
114740: PUSH
114741: LD_INT 21
114743: PUSH
114744: LD_INT 22
114746: PUSH
114747: LD_INT 23
114749: PUSH
114750: LD_INT 25
114752: PUSH
114753: LD_INT 26
114755: PUSH
114756: LD_INT 30
114758: PUSH
114759: LD_INT 31
114761: PUSH
114762: LD_INT 32
114764: PUSH
114765: LD_INT 36
114767: PUSH
114768: EMPTY
114769: LIST
114770: LIST
114771: LIST
114772: LIST
114773: LIST
114774: LIST
114775: LIST
114776: LIST
114777: LIST
114778: LIST
114779: LIST
114780: LIST
114781: LIST
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: PUSH
114789: LD_INT 101
114791: PUSH
114792: LD_INT 102
114794: PUSH
114795: LD_INT 105
114797: PUSH
114798: LD_INT 106
114800: PUSH
114801: LD_INT 108
114803: PUSH
114804: LD_INT 109
114806: PUSH
114807: LD_INT 112
114809: PUSH
114810: LD_INT 116
114812: PUSH
114813: LD_INT 117
114815: PUSH
114816: LD_INT 118
114818: PUSH
114819: EMPTY
114820: LIST
114821: LIST
114822: LIST
114823: LIST
114824: LIST
114825: LIST
114826: LIST
114827: LIST
114828: LIST
114829: LIST
114830: PUSH
114831: EMPTY
114832: LIST
114833: LIST
114834: ST_TO_ADDR
114835: GO 117358
114837: LD_INT 7
114839: DOUBLE
114840: EQUAL
114841: IFTRUE 114845
114843: GO 114957
114845: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
114846: LD_ADDR_VAR 0 2
114850: PUSH
114851: LD_INT 2
114853: PUSH
114854: LD_INT 4
114856: PUSH
114857: LD_INT 5
114859: PUSH
114860: LD_INT 7
114862: PUSH
114863: LD_INT 11
114865: PUSH
114866: LD_INT 12
114868: PUSH
114869: LD_INT 15
114871: PUSH
114872: LD_INT 16
114874: PUSH
114875: LD_INT 20
114877: PUSH
114878: LD_INT 21
114880: PUSH
114881: LD_INT 22
114883: PUSH
114884: LD_INT 23
114886: PUSH
114887: LD_INT 25
114889: PUSH
114890: LD_INT 26
114892: PUSH
114893: EMPTY
114894: LIST
114895: LIST
114896: LIST
114897: LIST
114898: LIST
114899: LIST
114900: LIST
114901: LIST
114902: LIST
114903: LIST
114904: LIST
114905: LIST
114906: LIST
114907: LIST
114908: PUSH
114909: LD_INT 101
114911: PUSH
114912: LD_INT 102
114914: PUSH
114915: LD_INT 103
114917: PUSH
114918: LD_INT 105
114920: PUSH
114921: LD_INT 106
114923: PUSH
114924: LD_INT 108
114926: PUSH
114927: LD_INT 112
114929: PUSH
114930: LD_INT 116
114932: PUSH
114933: LD_INT 117
114935: PUSH
114936: LD_INT 118
114938: PUSH
114939: EMPTY
114940: LIST
114941: LIST
114942: LIST
114943: LIST
114944: LIST
114945: LIST
114946: LIST
114947: LIST
114948: LIST
114949: LIST
114950: PUSH
114951: EMPTY
114952: LIST
114953: LIST
114954: ST_TO_ADDR
114955: GO 117358
114957: LD_INT 8
114959: DOUBLE
114960: EQUAL
114961: IFTRUE 114965
114963: GO 115105
114965: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
114966: LD_ADDR_VAR 0 2
114970: PUSH
114971: LD_INT 2
114973: PUSH
114974: LD_INT 4
114976: PUSH
114977: LD_INT 5
114979: PUSH
114980: LD_INT 6
114982: PUSH
114983: LD_INT 7
114985: PUSH
114986: LD_INT 8
114988: PUSH
114989: LD_INT 11
114991: PUSH
114992: LD_INT 12
114994: PUSH
114995: LD_INT 15
114997: PUSH
114998: LD_INT 16
115000: PUSH
115001: LD_INT 20
115003: PUSH
115004: LD_INT 21
115006: PUSH
115007: LD_INT 22
115009: PUSH
115010: LD_INT 23
115012: PUSH
115013: LD_INT 25
115015: PUSH
115016: LD_INT 26
115018: PUSH
115019: LD_INT 30
115021: PUSH
115022: LD_INT 31
115024: PUSH
115025: LD_INT 32
115027: PUSH
115028: LD_INT 36
115030: PUSH
115031: EMPTY
115032: LIST
115033: LIST
115034: LIST
115035: LIST
115036: LIST
115037: LIST
115038: LIST
115039: LIST
115040: LIST
115041: LIST
115042: LIST
115043: LIST
115044: LIST
115045: LIST
115046: LIST
115047: LIST
115048: LIST
115049: LIST
115050: LIST
115051: LIST
115052: PUSH
115053: LD_INT 101
115055: PUSH
115056: LD_INT 102
115058: PUSH
115059: LD_INT 103
115061: PUSH
115062: LD_INT 105
115064: PUSH
115065: LD_INT 106
115067: PUSH
115068: LD_INT 108
115070: PUSH
115071: LD_INT 109
115073: PUSH
115074: LD_INT 112
115076: PUSH
115077: LD_INT 116
115079: PUSH
115080: LD_INT 117
115082: PUSH
115083: LD_INT 118
115085: PUSH
115086: EMPTY
115087: LIST
115088: LIST
115089: LIST
115090: LIST
115091: LIST
115092: LIST
115093: LIST
115094: LIST
115095: LIST
115096: LIST
115097: LIST
115098: PUSH
115099: EMPTY
115100: LIST
115101: LIST
115102: ST_TO_ADDR
115103: GO 117358
115105: LD_INT 9
115107: DOUBLE
115108: EQUAL
115109: IFTRUE 115113
115111: GO 115261
115113: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
115114: LD_ADDR_VAR 0 2
115118: PUSH
115119: LD_INT 2
115121: PUSH
115122: LD_INT 4
115124: PUSH
115125: LD_INT 5
115127: PUSH
115128: LD_INT 6
115130: PUSH
115131: LD_INT 7
115133: PUSH
115134: LD_INT 8
115136: PUSH
115137: LD_INT 11
115139: PUSH
115140: LD_INT 12
115142: PUSH
115143: LD_INT 15
115145: PUSH
115146: LD_INT 16
115148: PUSH
115149: LD_INT 20
115151: PUSH
115152: LD_INT 21
115154: PUSH
115155: LD_INT 22
115157: PUSH
115158: LD_INT 23
115160: PUSH
115161: LD_INT 25
115163: PUSH
115164: LD_INT 26
115166: PUSH
115167: LD_INT 28
115169: PUSH
115170: LD_INT 30
115172: PUSH
115173: LD_INT 31
115175: PUSH
115176: LD_INT 32
115178: PUSH
115179: LD_INT 36
115181: PUSH
115182: EMPTY
115183: LIST
115184: LIST
115185: LIST
115186: LIST
115187: LIST
115188: LIST
115189: LIST
115190: LIST
115191: LIST
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: LIST
115199: LIST
115200: LIST
115201: LIST
115202: LIST
115203: LIST
115204: PUSH
115205: LD_INT 101
115207: PUSH
115208: LD_INT 102
115210: PUSH
115211: LD_INT 103
115213: PUSH
115214: LD_INT 105
115216: PUSH
115217: LD_INT 106
115219: PUSH
115220: LD_INT 108
115222: PUSH
115223: LD_INT 109
115225: PUSH
115226: LD_INT 112
115228: PUSH
115229: LD_INT 114
115231: PUSH
115232: LD_INT 116
115234: PUSH
115235: LD_INT 117
115237: PUSH
115238: LD_INT 118
115240: PUSH
115241: EMPTY
115242: LIST
115243: LIST
115244: LIST
115245: LIST
115246: LIST
115247: LIST
115248: LIST
115249: LIST
115250: LIST
115251: LIST
115252: LIST
115253: LIST
115254: PUSH
115255: EMPTY
115256: LIST
115257: LIST
115258: ST_TO_ADDR
115259: GO 117358
115261: LD_INT 10
115263: DOUBLE
115264: EQUAL
115265: IFTRUE 115269
115267: GO 115465
115269: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
115270: LD_ADDR_VAR 0 2
115274: PUSH
115275: LD_INT 2
115277: PUSH
115278: LD_INT 4
115280: PUSH
115281: LD_INT 5
115283: PUSH
115284: LD_INT 6
115286: PUSH
115287: LD_INT 7
115289: PUSH
115290: LD_INT 8
115292: PUSH
115293: LD_INT 9
115295: PUSH
115296: LD_INT 10
115298: PUSH
115299: LD_INT 11
115301: PUSH
115302: LD_INT 12
115304: PUSH
115305: LD_INT 13
115307: PUSH
115308: LD_INT 14
115310: PUSH
115311: LD_INT 15
115313: PUSH
115314: LD_INT 16
115316: PUSH
115317: LD_INT 17
115319: PUSH
115320: LD_INT 18
115322: PUSH
115323: LD_INT 19
115325: PUSH
115326: LD_INT 20
115328: PUSH
115329: LD_INT 21
115331: PUSH
115332: LD_INT 22
115334: PUSH
115335: LD_INT 23
115337: PUSH
115338: LD_INT 24
115340: PUSH
115341: LD_INT 25
115343: PUSH
115344: LD_INT 26
115346: PUSH
115347: LD_INT 28
115349: PUSH
115350: LD_INT 30
115352: PUSH
115353: LD_INT 31
115355: PUSH
115356: LD_INT 32
115358: PUSH
115359: LD_INT 36
115361: PUSH
115362: EMPTY
115363: LIST
115364: LIST
115365: LIST
115366: LIST
115367: LIST
115368: LIST
115369: LIST
115370: LIST
115371: LIST
115372: LIST
115373: LIST
115374: LIST
115375: LIST
115376: LIST
115377: LIST
115378: LIST
115379: LIST
115380: LIST
115381: LIST
115382: LIST
115383: LIST
115384: LIST
115385: LIST
115386: LIST
115387: LIST
115388: LIST
115389: LIST
115390: LIST
115391: LIST
115392: PUSH
115393: LD_INT 101
115395: PUSH
115396: LD_INT 102
115398: PUSH
115399: LD_INT 103
115401: PUSH
115402: LD_INT 104
115404: PUSH
115405: LD_INT 105
115407: PUSH
115408: LD_INT 106
115410: PUSH
115411: LD_INT 107
115413: PUSH
115414: LD_INT 108
115416: PUSH
115417: LD_INT 109
115419: PUSH
115420: LD_INT 110
115422: PUSH
115423: LD_INT 111
115425: PUSH
115426: LD_INT 112
115428: PUSH
115429: LD_INT 114
115431: PUSH
115432: LD_INT 116
115434: PUSH
115435: LD_INT 117
115437: PUSH
115438: LD_INT 118
115440: PUSH
115441: EMPTY
115442: LIST
115443: LIST
115444: LIST
115445: LIST
115446: LIST
115447: LIST
115448: LIST
115449: LIST
115450: LIST
115451: LIST
115452: LIST
115453: LIST
115454: LIST
115455: LIST
115456: LIST
115457: LIST
115458: PUSH
115459: EMPTY
115460: LIST
115461: LIST
115462: ST_TO_ADDR
115463: GO 117358
115465: LD_INT 11
115467: DOUBLE
115468: EQUAL
115469: IFTRUE 115473
115471: GO 115677
115473: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
115474: LD_ADDR_VAR 0 2
115478: PUSH
115479: LD_INT 2
115481: PUSH
115482: LD_INT 3
115484: PUSH
115485: LD_INT 4
115487: PUSH
115488: LD_INT 5
115490: PUSH
115491: LD_INT 6
115493: PUSH
115494: LD_INT 7
115496: PUSH
115497: LD_INT 8
115499: PUSH
115500: LD_INT 9
115502: PUSH
115503: LD_INT 10
115505: PUSH
115506: LD_INT 11
115508: PUSH
115509: LD_INT 12
115511: PUSH
115512: LD_INT 13
115514: PUSH
115515: LD_INT 14
115517: PUSH
115518: LD_INT 15
115520: PUSH
115521: LD_INT 16
115523: PUSH
115524: LD_INT 17
115526: PUSH
115527: LD_INT 18
115529: PUSH
115530: LD_INT 19
115532: PUSH
115533: LD_INT 20
115535: PUSH
115536: LD_INT 21
115538: PUSH
115539: LD_INT 22
115541: PUSH
115542: LD_INT 23
115544: PUSH
115545: LD_INT 24
115547: PUSH
115548: LD_INT 25
115550: PUSH
115551: LD_INT 26
115553: PUSH
115554: LD_INT 28
115556: PUSH
115557: LD_INT 30
115559: PUSH
115560: LD_INT 31
115562: PUSH
115563: LD_INT 32
115565: PUSH
115566: LD_INT 34
115568: PUSH
115569: LD_INT 36
115571: PUSH
115572: EMPTY
115573: LIST
115574: LIST
115575: LIST
115576: LIST
115577: LIST
115578: LIST
115579: LIST
115580: LIST
115581: LIST
115582: LIST
115583: LIST
115584: LIST
115585: LIST
115586: LIST
115587: LIST
115588: LIST
115589: LIST
115590: LIST
115591: LIST
115592: LIST
115593: LIST
115594: LIST
115595: LIST
115596: LIST
115597: LIST
115598: LIST
115599: LIST
115600: LIST
115601: LIST
115602: LIST
115603: LIST
115604: PUSH
115605: LD_INT 101
115607: PUSH
115608: LD_INT 102
115610: PUSH
115611: LD_INT 103
115613: PUSH
115614: LD_INT 104
115616: PUSH
115617: LD_INT 105
115619: PUSH
115620: LD_INT 106
115622: PUSH
115623: LD_INT 107
115625: PUSH
115626: LD_INT 108
115628: PUSH
115629: LD_INT 109
115631: PUSH
115632: LD_INT 110
115634: PUSH
115635: LD_INT 111
115637: PUSH
115638: LD_INT 112
115640: PUSH
115641: LD_INT 114
115643: PUSH
115644: LD_INT 116
115646: PUSH
115647: LD_INT 117
115649: PUSH
115650: LD_INT 118
115652: PUSH
115653: EMPTY
115654: LIST
115655: LIST
115656: LIST
115657: LIST
115658: LIST
115659: LIST
115660: LIST
115661: LIST
115662: LIST
115663: LIST
115664: LIST
115665: LIST
115666: LIST
115667: LIST
115668: LIST
115669: LIST
115670: PUSH
115671: EMPTY
115672: LIST
115673: LIST
115674: ST_TO_ADDR
115675: GO 117358
115677: LD_INT 12
115679: DOUBLE
115680: EQUAL
115681: IFTRUE 115685
115683: GO 115905
115685: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
115686: LD_ADDR_VAR 0 2
115690: PUSH
115691: LD_INT 1
115693: PUSH
115694: LD_INT 2
115696: PUSH
115697: LD_INT 3
115699: PUSH
115700: LD_INT 4
115702: PUSH
115703: LD_INT 5
115705: PUSH
115706: LD_INT 6
115708: PUSH
115709: LD_INT 7
115711: PUSH
115712: LD_INT 8
115714: PUSH
115715: LD_INT 9
115717: PUSH
115718: LD_INT 10
115720: PUSH
115721: LD_INT 11
115723: PUSH
115724: LD_INT 12
115726: PUSH
115727: LD_INT 13
115729: PUSH
115730: LD_INT 14
115732: PUSH
115733: LD_INT 15
115735: PUSH
115736: LD_INT 16
115738: PUSH
115739: LD_INT 17
115741: PUSH
115742: LD_INT 18
115744: PUSH
115745: LD_INT 19
115747: PUSH
115748: LD_INT 20
115750: PUSH
115751: LD_INT 21
115753: PUSH
115754: LD_INT 22
115756: PUSH
115757: LD_INT 23
115759: PUSH
115760: LD_INT 24
115762: PUSH
115763: LD_INT 25
115765: PUSH
115766: LD_INT 26
115768: PUSH
115769: LD_INT 27
115771: PUSH
115772: LD_INT 28
115774: PUSH
115775: LD_INT 30
115777: PUSH
115778: LD_INT 31
115780: PUSH
115781: LD_INT 32
115783: PUSH
115784: LD_INT 33
115786: PUSH
115787: LD_INT 34
115789: PUSH
115790: LD_INT 36
115792: PUSH
115793: EMPTY
115794: LIST
115795: LIST
115796: LIST
115797: LIST
115798: LIST
115799: LIST
115800: LIST
115801: LIST
115802: LIST
115803: LIST
115804: LIST
115805: LIST
115806: LIST
115807: LIST
115808: LIST
115809: LIST
115810: LIST
115811: LIST
115812: LIST
115813: LIST
115814: LIST
115815: LIST
115816: LIST
115817: LIST
115818: LIST
115819: LIST
115820: LIST
115821: LIST
115822: LIST
115823: LIST
115824: LIST
115825: LIST
115826: LIST
115827: LIST
115828: PUSH
115829: LD_INT 101
115831: PUSH
115832: LD_INT 102
115834: PUSH
115835: LD_INT 103
115837: PUSH
115838: LD_INT 104
115840: PUSH
115841: LD_INT 105
115843: PUSH
115844: LD_INT 106
115846: PUSH
115847: LD_INT 107
115849: PUSH
115850: LD_INT 108
115852: PUSH
115853: LD_INT 109
115855: PUSH
115856: LD_INT 110
115858: PUSH
115859: LD_INT 111
115861: PUSH
115862: LD_INT 112
115864: PUSH
115865: LD_INT 113
115867: PUSH
115868: LD_INT 114
115870: PUSH
115871: LD_INT 116
115873: PUSH
115874: LD_INT 117
115876: PUSH
115877: LD_INT 118
115879: PUSH
115880: EMPTY
115881: LIST
115882: LIST
115883: LIST
115884: LIST
115885: LIST
115886: LIST
115887: LIST
115888: LIST
115889: LIST
115890: LIST
115891: LIST
115892: LIST
115893: LIST
115894: LIST
115895: LIST
115896: LIST
115897: LIST
115898: PUSH
115899: EMPTY
115900: LIST
115901: LIST
115902: ST_TO_ADDR
115903: GO 117358
115905: LD_INT 13
115907: DOUBLE
115908: EQUAL
115909: IFTRUE 115913
115911: GO 116121
115913: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
115914: LD_ADDR_VAR 0 2
115918: PUSH
115919: LD_INT 1
115921: PUSH
115922: LD_INT 2
115924: PUSH
115925: LD_INT 3
115927: PUSH
115928: LD_INT 4
115930: PUSH
115931: LD_INT 5
115933: PUSH
115934: LD_INT 8
115936: PUSH
115937: LD_INT 9
115939: PUSH
115940: LD_INT 10
115942: PUSH
115943: LD_INT 11
115945: PUSH
115946: LD_INT 12
115948: PUSH
115949: LD_INT 14
115951: PUSH
115952: LD_INT 15
115954: PUSH
115955: LD_INT 16
115957: PUSH
115958: LD_INT 17
115960: PUSH
115961: LD_INT 18
115963: PUSH
115964: LD_INT 19
115966: PUSH
115967: LD_INT 20
115969: PUSH
115970: LD_INT 21
115972: PUSH
115973: LD_INT 22
115975: PUSH
115976: LD_INT 23
115978: PUSH
115979: LD_INT 24
115981: PUSH
115982: LD_INT 25
115984: PUSH
115985: LD_INT 26
115987: PUSH
115988: LD_INT 27
115990: PUSH
115991: LD_INT 28
115993: PUSH
115994: LD_INT 30
115996: PUSH
115997: LD_INT 31
115999: PUSH
116000: LD_INT 32
116002: PUSH
116003: LD_INT 33
116005: PUSH
116006: LD_INT 34
116008: PUSH
116009: LD_INT 36
116011: PUSH
116012: EMPTY
116013: LIST
116014: LIST
116015: LIST
116016: LIST
116017: LIST
116018: LIST
116019: LIST
116020: LIST
116021: LIST
116022: LIST
116023: LIST
116024: LIST
116025: LIST
116026: LIST
116027: LIST
116028: LIST
116029: LIST
116030: LIST
116031: LIST
116032: LIST
116033: LIST
116034: LIST
116035: LIST
116036: LIST
116037: LIST
116038: LIST
116039: LIST
116040: LIST
116041: LIST
116042: LIST
116043: LIST
116044: PUSH
116045: LD_INT 101
116047: PUSH
116048: LD_INT 102
116050: PUSH
116051: LD_INT 103
116053: PUSH
116054: LD_INT 104
116056: PUSH
116057: LD_INT 105
116059: PUSH
116060: LD_INT 106
116062: PUSH
116063: LD_INT 107
116065: PUSH
116066: LD_INT 108
116068: PUSH
116069: LD_INT 109
116071: PUSH
116072: LD_INT 110
116074: PUSH
116075: LD_INT 111
116077: PUSH
116078: LD_INT 112
116080: PUSH
116081: LD_INT 113
116083: PUSH
116084: LD_INT 114
116086: PUSH
116087: LD_INT 116
116089: PUSH
116090: LD_INT 117
116092: PUSH
116093: LD_INT 118
116095: PUSH
116096: EMPTY
116097: LIST
116098: LIST
116099: LIST
116100: LIST
116101: LIST
116102: LIST
116103: LIST
116104: LIST
116105: LIST
116106: LIST
116107: LIST
116108: LIST
116109: LIST
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: PUSH
116115: EMPTY
116116: LIST
116117: LIST
116118: ST_TO_ADDR
116119: GO 117358
116121: LD_INT 14
116123: DOUBLE
116124: EQUAL
116125: IFTRUE 116129
116127: GO 116353
116129: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
116130: LD_ADDR_VAR 0 2
116134: PUSH
116135: LD_INT 1
116137: PUSH
116138: LD_INT 2
116140: PUSH
116141: LD_INT 3
116143: PUSH
116144: LD_INT 4
116146: PUSH
116147: LD_INT 5
116149: PUSH
116150: LD_INT 6
116152: PUSH
116153: LD_INT 7
116155: PUSH
116156: LD_INT 8
116158: PUSH
116159: LD_INT 9
116161: PUSH
116162: LD_INT 10
116164: PUSH
116165: LD_INT 11
116167: PUSH
116168: LD_INT 12
116170: PUSH
116171: LD_INT 13
116173: PUSH
116174: LD_INT 14
116176: PUSH
116177: LD_INT 15
116179: PUSH
116180: LD_INT 16
116182: PUSH
116183: LD_INT 17
116185: PUSH
116186: LD_INT 18
116188: PUSH
116189: LD_INT 19
116191: PUSH
116192: LD_INT 20
116194: PUSH
116195: LD_INT 21
116197: PUSH
116198: LD_INT 22
116200: PUSH
116201: LD_INT 23
116203: PUSH
116204: LD_INT 24
116206: PUSH
116207: LD_INT 25
116209: PUSH
116210: LD_INT 26
116212: PUSH
116213: LD_INT 27
116215: PUSH
116216: LD_INT 28
116218: PUSH
116219: LD_INT 29
116221: PUSH
116222: LD_INT 30
116224: PUSH
116225: LD_INT 31
116227: PUSH
116228: LD_INT 32
116230: PUSH
116231: LD_INT 33
116233: PUSH
116234: LD_INT 34
116236: PUSH
116237: LD_INT 36
116239: PUSH
116240: EMPTY
116241: LIST
116242: LIST
116243: LIST
116244: LIST
116245: LIST
116246: LIST
116247: LIST
116248: LIST
116249: LIST
116250: LIST
116251: LIST
116252: LIST
116253: LIST
116254: LIST
116255: LIST
116256: LIST
116257: LIST
116258: LIST
116259: LIST
116260: LIST
116261: LIST
116262: LIST
116263: LIST
116264: LIST
116265: LIST
116266: LIST
116267: LIST
116268: LIST
116269: LIST
116270: LIST
116271: LIST
116272: LIST
116273: LIST
116274: LIST
116275: LIST
116276: PUSH
116277: LD_INT 101
116279: PUSH
116280: LD_INT 102
116282: PUSH
116283: LD_INT 103
116285: PUSH
116286: LD_INT 104
116288: PUSH
116289: LD_INT 105
116291: PUSH
116292: LD_INT 106
116294: PUSH
116295: LD_INT 107
116297: PUSH
116298: LD_INT 108
116300: PUSH
116301: LD_INT 109
116303: PUSH
116304: LD_INT 110
116306: PUSH
116307: LD_INT 111
116309: PUSH
116310: LD_INT 112
116312: PUSH
116313: LD_INT 113
116315: PUSH
116316: LD_INT 114
116318: PUSH
116319: LD_INT 116
116321: PUSH
116322: LD_INT 117
116324: PUSH
116325: LD_INT 118
116327: PUSH
116328: EMPTY
116329: LIST
116330: LIST
116331: LIST
116332: LIST
116333: LIST
116334: LIST
116335: LIST
116336: LIST
116337: LIST
116338: LIST
116339: LIST
116340: LIST
116341: LIST
116342: LIST
116343: LIST
116344: LIST
116345: LIST
116346: PUSH
116347: EMPTY
116348: LIST
116349: LIST
116350: ST_TO_ADDR
116351: GO 117358
116353: LD_INT 15
116355: DOUBLE
116356: EQUAL
116357: IFTRUE 116361
116359: GO 116585
116361: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
116362: LD_ADDR_VAR 0 2
116366: PUSH
116367: LD_INT 1
116369: PUSH
116370: LD_INT 2
116372: PUSH
116373: LD_INT 3
116375: PUSH
116376: LD_INT 4
116378: PUSH
116379: LD_INT 5
116381: PUSH
116382: LD_INT 6
116384: PUSH
116385: LD_INT 7
116387: PUSH
116388: LD_INT 8
116390: PUSH
116391: LD_INT 9
116393: PUSH
116394: LD_INT 10
116396: PUSH
116397: LD_INT 11
116399: PUSH
116400: LD_INT 12
116402: PUSH
116403: LD_INT 13
116405: PUSH
116406: LD_INT 14
116408: PUSH
116409: LD_INT 15
116411: PUSH
116412: LD_INT 16
116414: PUSH
116415: LD_INT 17
116417: PUSH
116418: LD_INT 18
116420: PUSH
116421: LD_INT 19
116423: PUSH
116424: LD_INT 20
116426: PUSH
116427: LD_INT 21
116429: PUSH
116430: LD_INT 22
116432: PUSH
116433: LD_INT 23
116435: PUSH
116436: LD_INT 24
116438: PUSH
116439: LD_INT 25
116441: PUSH
116442: LD_INT 26
116444: PUSH
116445: LD_INT 27
116447: PUSH
116448: LD_INT 28
116450: PUSH
116451: LD_INT 29
116453: PUSH
116454: LD_INT 30
116456: PUSH
116457: LD_INT 31
116459: PUSH
116460: LD_INT 32
116462: PUSH
116463: LD_INT 33
116465: PUSH
116466: LD_INT 34
116468: PUSH
116469: LD_INT 36
116471: PUSH
116472: EMPTY
116473: LIST
116474: LIST
116475: LIST
116476: LIST
116477: LIST
116478: LIST
116479: LIST
116480: LIST
116481: LIST
116482: LIST
116483: LIST
116484: LIST
116485: LIST
116486: LIST
116487: LIST
116488: LIST
116489: LIST
116490: LIST
116491: LIST
116492: LIST
116493: LIST
116494: LIST
116495: LIST
116496: LIST
116497: LIST
116498: LIST
116499: LIST
116500: LIST
116501: LIST
116502: LIST
116503: LIST
116504: LIST
116505: LIST
116506: LIST
116507: LIST
116508: PUSH
116509: LD_INT 101
116511: PUSH
116512: LD_INT 102
116514: PUSH
116515: LD_INT 103
116517: PUSH
116518: LD_INT 104
116520: PUSH
116521: LD_INT 105
116523: PUSH
116524: LD_INT 106
116526: PUSH
116527: LD_INT 107
116529: PUSH
116530: LD_INT 108
116532: PUSH
116533: LD_INT 109
116535: PUSH
116536: LD_INT 110
116538: PUSH
116539: LD_INT 111
116541: PUSH
116542: LD_INT 112
116544: PUSH
116545: LD_INT 113
116547: PUSH
116548: LD_INT 114
116550: PUSH
116551: LD_INT 116
116553: PUSH
116554: LD_INT 117
116556: PUSH
116557: LD_INT 118
116559: PUSH
116560: EMPTY
116561: LIST
116562: LIST
116563: LIST
116564: LIST
116565: LIST
116566: LIST
116567: LIST
116568: LIST
116569: LIST
116570: LIST
116571: LIST
116572: LIST
116573: LIST
116574: LIST
116575: LIST
116576: LIST
116577: LIST
116578: PUSH
116579: EMPTY
116580: LIST
116581: LIST
116582: ST_TO_ADDR
116583: GO 117358
116585: LD_INT 16
116587: DOUBLE
116588: EQUAL
116589: IFTRUE 116593
116591: GO 116729
116593: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
116594: LD_ADDR_VAR 0 2
116598: PUSH
116599: LD_INT 2
116601: PUSH
116602: LD_INT 4
116604: PUSH
116605: LD_INT 5
116607: PUSH
116608: LD_INT 7
116610: PUSH
116611: LD_INT 11
116613: PUSH
116614: LD_INT 12
116616: PUSH
116617: LD_INT 15
116619: PUSH
116620: LD_INT 16
116622: PUSH
116623: LD_INT 20
116625: PUSH
116626: LD_INT 21
116628: PUSH
116629: LD_INT 22
116631: PUSH
116632: LD_INT 23
116634: PUSH
116635: LD_INT 25
116637: PUSH
116638: LD_INT 26
116640: PUSH
116641: LD_INT 30
116643: PUSH
116644: LD_INT 31
116646: PUSH
116647: LD_INT 32
116649: PUSH
116650: LD_INT 33
116652: PUSH
116653: LD_INT 34
116655: PUSH
116656: EMPTY
116657: LIST
116658: LIST
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: LIST
116672: LIST
116673: LIST
116674: LIST
116675: LIST
116676: PUSH
116677: LD_INT 101
116679: PUSH
116680: LD_INT 102
116682: PUSH
116683: LD_INT 103
116685: PUSH
116686: LD_INT 106
116688: PUSH
116689: LD_INT 108
116691: PUSH
116692: LD_INT 112
116694: PUSH
116695: LD_INT 113
116697: PUSH
116698: LD_INT 114
116700: PUSH
116701: LD_INT 116
116703: PUSH
116704: LD_INT 117
116706: PUSH
116707: LD_INT 118
116709: PUSH
116710: EMPTY
116711: LIST
116712: LIST
116713: LIST
116714: LIST
116715: LIST
116716: LIST
116717: LIST
116718: LIST
116719: LIST
116720: LIST
116721: LIST
116722: PUSH
116723: EMPTY
116724: LIST
116725: LIST
116726: ST_TO_ADDR
116727: GO 117358
116729: LD_INT 17
116731: DOUBLE
116732: EQUAL
116733: IFTRUE 116737
116735: GO 116961
116737: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
116738: LD_ADDR_VAR 0 2
116742: PUSH
116743: LD_INT 1
116745: PUSH
116746: LD_INT 2
116748: PUSH
116749: LD_INT 3
116751: PUSH
116752: LD_INT 4
116754: PUSH
116755: LD_INT 5
116757: PUSH
116758: LD_INT 6
116760: PUSH
116761: LD_INT 7
116763: PUSH
116764: LD_INT 8
116766: PUSH
116767: LD_INT 9
116769: PUSH
116770: LD_INT 10
116772: PUSH
116773: LD_INT 11
116775: PUSH
116776: LD_INT 12
116778: PUSH
116779: LD_INT 13
116781: PUSH
116782: LD_INT 14
116784: PUSH
116785: LD_INT 15
116787: PUSH
116788: LD_INT 16
116790: PUSH
116791: LD_INT 17
116793: PUSH
116794: LD_INT 18
116796: PUSH
116797: LD_INT 19
116799: PUSH
116800: LD_INT 20
116802: PUSH
116803: LD_INT 21
116805: PUSH
116806: LD_INT 22
116808: PUSH
116809: LD_INT 23
116811: PUSH
116812: LD_INT 24
116814: PUSH
116815: LD_INT 25
116817: PUSH
116818: LD_INT 26
116820: PUSH
116821: LD_INT 27
116823: PUSH
116824: LD_INT 28
116826: PUSH
116827: LD_INT 29
116829: PUSH
116830: LD_INT 30
116832: PUSH
116833: LD_INT 31
116835: PUSH
116836: LD_INT 32
116838: PUSH
116839: LD_INT 33
116841: PUSH
116842: LD_INT 34
116844: PUSH
116845: LD_INT 36
116847: PUSH
116848: EMPTY
116849: LIST
116850: LIST
116851: LIST
116852: LIST
116853: LIST
116854: LIST
116855: LIST
116856: LIST
116857: LIST
116858: LIST
116859: LIST
116860: LIST
116861: LIST
116862: LIST
116863: LIST
116864: LIST
116865: LIST
116866: LIST
116867: LIST
116868: LIST
116869: LIST
116870: LIST
116871: LIST
116872: LIST
116873: LIST
116874: LIST
116875: LIST
116876: LIST
116877: LIST
116878: LIST
116879: LIST
116880: LIST
116881: LIST
116882: LIST
116883: LIST
116884: PUSH
116885: LD_INT 101
116887: PUSH
116888: LD_INT 102
116890: PUSH
116891: LD_INT 103
116893: PUSH
116894: LD_INT 104
116896: PUSH
116897: LD_INT 105
116899: PUSH
116900: LD_INT 106
116902: PUSH
116903: LD_INT 107
116905: PUSH
116906: LD_INT 108
116908: PUSH
116909: LD_INT 109
116911: PUSH
116912: LD_INT 110
116914: PUSH
116915: LD_INT 111
116917: PUSH
116918: LD_INT 112
116920: PUSH
116921: LD_INT 113
116923: PUSH
116924: LD_INT 114
116926: PUSH
116927: LD_INT 116
116929: PUSH
116930: LD_INT 117
116932: PUSH
116933: LD_INT 118
116935: PUSH
116936: EMPTY
116937: LIST
116938: LIST
116939: LIST
116940: LIST
116941: LIST
116942: LIST
116943: LIST
116944: LIST
116945: LIST
116946: LIST
116947: LIST
116948: LIST
116949: LIST
116950: LIST
116951: LIST
116952: LIST
116953: LIST
116954: PUSH
116955: EMPTY
116956: LIST
116957: LIST
116958: ST_TO_ADDR
116959: GO 117358
116961: LD_INT 18
116963: DOUBLE
116964: EQUAL
116965: IFTRUE 116969
116967: GO 117117
116969: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
116970: LD_ADDR_VAR 0 2
116974: PUSH
116975: LD_INT 2
116977: PUSH
116978: LD_INT 4
116980: PUSH
116981: LD_INT 5
116983: PUSH
116984: LD_INT 7
116986: PUSH
116987: LD_INT 11
116989: PUSH
116990: LD_INT 12
116992: PUSH
116993: LD_INT 15
116995: PUSH
116996: LD_INT 16
116998: PUSH
116999: LD_INT 20
117001: PUSH
117002: LD_INT 21
117004: PUSH
117005: LD_INT 22
117007: PUSH
117008: LD_INT 23
117010: PUSH
117011: LD_INT 25
117013: PUSH
117014: LD_INT 26
117016: PUSH
117017: LD_INT 30
117019: PUSH
117020: LD_INT 31
117022: PUSH
117023: LD_INT 32
117025: PUSH
117026: LD_INT 33
117028: PUSH
117029: LD_INT 34
117031: PUSH
117032: LD_INT 35
117034: PUSH
117035: LD_INT 36
117037: PUSH
117038: EMPTY
117039: LIST
117040: LIST
117041: LIST
117042: LIST
117043: LIST
117044: LIST
117045: LIST
117046: LIST
117047: LIST
117048: LIST
117049: LIST
117050: LIST
117051: LIST
117052: LIST
117053: LIST
117054: LIST
117055: LIST
117056: LIST
117057: LIST
117058: LIST
117059: LIST
117060: PUSH
117061: LD_INT 101
117063: PUSH
117064: LD_INT 102
117066: PUSH
117067: LD_INT 103
117069: PUSH
117070: LD_INT 106
117072: PUSH
117073: LD_INT 108
117075: PUSH
117076: LD_INT 112
117078: PUSH
117079: LD_INT 113
117081: PUSH
117082: LD_INT 114
117084: PUSH
117085: LD_INT 115
117087: PUSH
117088: LD_INT 116
117090: PUSH
117091: LD_INT 117
117093: PUSH
117094: LD_INT 118
117096: PUSH
117097: EMPTY
117098: LIST
117099: LIST
117100: LIST
117101: LIST
117102: LIST
117103: LIST
117104: LIST
117105: LIST
117106: LIST
117107: LIST
117108: LIST
117109: LIST
117110: PUSH
117111: EMPTY
117112: LIST
117113: LIST
117114: ST_TO_ADDR
117115: GO 117358
117117: LD_INT 19
117119: DOUBLE
117120: EQUAL
117121: IFTRUE 117125
117123: GO 117357
117125: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
117126: LD_ADDR_VAR 0 2
117130: PUSH
117131: LD_INT 1
117133: PUSH
117134: LD_INT 2
117136: PUSH
117137: LD_INT 3
117139: PUSH
117140: LD_INT 4
117142: PUSH
117143: LD_INT 5
117145: PUSH
117146: LD_INT 6
117148: PUSH
117149: LD_INT 7
117151: PUSH
117152: LD_INT 8
117154: PUSH
117155: LD_INT 9
117157: PUSH
117158: LD_INT 10
117160: PUSH
117161: LD_INT 11
117163: PUSH
117164: LD_INT 12
117166: PUSH
117167: LD_INT 13
117169: PUSH
117170: LD_INT 14
117172: PUSH
117173: LD_INT 15
117175: PUSH
117176: LD_INT 16
117178: PUSH
117179: LD_INT 17
117181: PUSH
117182: LD_INT 18
117184: PUSH
117185: LD_INT 19
117187: PUSH
117188: LD_INT 20
117190: PUSH
117191: LD_INT 21
117193: PUSH
117194: LD_INT 22
117196: PUSH
117197: LD_INT 23
117199: PUSH
117200: LD_INT 24
117202: PUSH
117203: LD_INT 25
117205: PUSH
117206: LD_INT 26
117208: PUSH
117209: LD_INT 27
117211: PUSH
117212: LD_INT 28
117214: PUSH
117215: LD_INT 29
117217: PUSH
117218: LD_INT 30
117220: PUSH
117221: LD_INT 31
117223: PUSH
117224: LD_INT 32
117226: PUSH
117227: LD_INT 33
117229: PUSH
117230: LD_INT 34
117232: PUSH
117233: LD_INT 35
117235: PUSH
117236: LD_INT 36
117238: PUSH
117239: EMPTY
117240: LIST
117241: LIST
117242: LIST
117243: LIST
117244: LIST
117245: LIST
117246: LIST
117247: LIST
117248: LIST
117249: LIST
117250: LIST
117251: LIST
117252: LIST
117253: LIST
117254: LIST
117255: LIST
117256: LIST
117257: LIST
117258: LIST
117259: LIST
117260: LIST
117261: LIST
117262: LIST
117263: LIST
117264: LIST
117265: LIST
117266: LIST
117267: LIST
117268: LIST
117269: LIST
117270: LIST
117271: LIST
117272: LIST
117273: LIST
117274: LIST
117275: LIST
117276: PUSH
117277: LD_INT 101
117279: PUSH
117280: LD_INT 102
117282: PUSH
117283: LD_INT 103
117285: PUSH
117286: LD_INT 104
117288: PUSH
117289: LD_INT 105
117291: PUSH
117292: LD_INT 106
117294: PUSH
117295: LD_INT 107
117297: PUSH
117298: LD_INT 108
117300: PUSH
117301: LD_INT 109
117303: PUSH
117304: LD_INT 110
117306: PUSH
117307: LD_INT 111
117309: PUSH
117310: LD_INT 112
117312: PUSH
117313: LD_INT 113
117315: PUSH
117316: LD_INT 114
117318: PUSH
117319: LD_INT 115
117321: PUSH
117322: LD_INT 116
117324: PUSH
117325: LD_INT 117
117327: PUSH
117328: LD_INT 118
117330: PUSH
117331: EMPTY
117332: LIST
117333: LIST
117334: LIST
117335: LIST
117336: LIST
117337: LIST
117338: LIST
117339: LIST
117340: LIST
117341: LIST
117342: LIST
117343: LIST
117344: LIST
117345: LIST
117346: LIST
117347: LIST
117348: LIST
117349: LIST
117350: PUSH
117351: EMPTY
117352: LIST
117353: LIST
117354: ST_TO_ADDR
117355: GO 117358
117357: POP
// end else
117358: GO 117589
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
117360: LD_ADDR_VAR 0 2
117364: PUSH
117365: LD_INT 1
117367: PUSH
117368: LD_INT 2
117370: PUSH
117371: LD_INT 3
117373: PUSH
117374: LD_INT 4
117376: PUSH
117377: LD_INT 5
117379: PUSH
117380: LD_INT 6
117382: PUSH
117383: LD_INT 7
117385: PUSH
117386: LD_INT 8
117388: PUSH
117389: LD_INT 9
117391: PUSH
117392: LD_INT 10
117394: PUSH
117395: LD_INT 11
117397: PUSH
117398: LD_INT 12
117400: PUSH
117401: LD_INT 13
117403: PUSH
117404: LD_INT 14
117406: PUSH
117407: LD_INT 15
117409: PUSH
117410: LD_INT 16
117412: PUSH
117413: LD_INT 17
117415: PUSH
117416: LD_INT 18
117418: PUSH
117419: LD_INT 19
117421: PUSH
117422: LD_INT 20
117424: PUSH
117425: LD_INT 21
117427: PUSH
117428: LD_INT 22
117430: PUSH
117431: LD_INT 23
117433: PUSH
117434: LD_INT 24
117436: PUSH
117437: LD_INT 25
117439: PUSH
117440: LD_INT 26
117442: PUSH
117443: LD_INT 27
117445: PUSH
117446: LD_INT 28
117448: PUSH
117449: LD_INT 29
117451: PUSH
117452: LD_INT 30
117454: PUSH
117455: LD_INT 31
117457: PUSH
117458: LD_INT 32
117460: PUSH
117461: LD_INT 33
117463: PUSH
117464: LD_INT 34
117466: PUSH
117467: LD_INT 35
117469: PUSH
117470: LD_INT 36
117472: PUSH
117473: EMPTY
117474: LIST
117475: LIST
117476: LIST
117477: LIST
117478: LIST
117479: LIST
117480: LIST
117481: LIST
117482: LIST
117483: LIST
117484: LIST
117485: LIST
117486: LIST
117487: LIST
117488: LIST
117489: LIST
117490: LIST
117491: LIST
117492: LIST
117493: LIST
117494: LIST
117495: LIST
117496: LIST
117497: LIST
117498: LIST
117499: LIST
117500: LIST
117501: LIST
117502: LIST
117503: LIST
117504: LIST
117505: LIST
117506: LIST
117507: LIST
117508: LIST
117509: LIST
117510: PUSH
117511: LD_INT 101
117513: PUSH
117514: LD_INT 102
117516: PUSH
117517: LD_INT 103
117519: PUSH
117520: LD_INT 104
117522: PUSH
117523: LD_INT 105
117525: PUSH
117526: LD_INT 106
117528: PUSH
117529: LD_INT 107
117531: PUSH
117532: LD_INT 108
117534: PUSH
117535: LD_INT 109
117537: PUSH
117538: LD_INT 110
117540: PUSH
117541: LD_INT 111
117543: PUSH
117544: LD_INT 112
117546: PUSH
117547: LD_INT 113
117549: PUSH
117550: LD_INT 114
117552: PUSH
117553: LD_INT 115
117555: PUSH
117556: LD_INT 116
117558: PUSH
117559: LD_INT 117
117561: PUSH
117562: LD_INT 118
117564: PUSH
117565: EMPTY
117566: LIST
117567: LIST
117568: LIST
117569: LIST
117570: LIST
117571: LIST
117572: LIST
117573: LIST
117574: LIST
117575: LIST
117576: LIST
117577: LIST
117578: LIST
117579: LIST
117580: LIST
117581: LIST
117582: LIST
117583: LIST
117584: PUSH
117585: EMPTY
117586: LIST
117587: LIST
117588: ST_TO_ADDR
// if result then
117589: LD_VAR 0 2
117593: IFFALSE 118379
// begin normal :=  ;
117595: LD_ADDR_VAR 0 5
117599: PUSH
117600: LD_STRING 
117602: ST_TO_ADDR
// hardcore :=  ;
117603: LD_ADDR_VAR 0 6
117607: PUSH
117608: LD_STRING 
117610: ST_TO_ADDR
// active :=  ;
117611: LD_ADDR_VAR 0 7
117615: PUSH
117616: LD_STRING 
117618: ST_TO_ADDR
// for i = 1 to normalCounter do
117619: LD_ADDR_VAR 0 8
117623: PUSH
117624: DOUBLE
117625: LD_INT 1
117627: DEC
117628: ST_TO_ADDR
117629: LD_EXP 149
117633: PUSH
117634: FOR_TO
117635: IFFALSE 117736
// begin tmp := 0 ;
117637: LD_ADDR_VAR 0 3
117641: PUSH
117642: LD_STRING 0
117644: ST_TO_ADDR
// if result [ 1 ] then
117645: LD_VAR 0 2
117649: PUSH
117650: LD_INT 1
117652: ARRAY
117653: IFFALSE 117718
// if result [ 1 ] [ 1 ] = i then
117655: LD_VAR 0 2
117659: PUSH
117660: LD_INT 1
117662: ARRAY
117663: PUSH
117664: LD_INT 1
117666: ARRAY
117667: PUSH
117668: LD_VAR 0 8
117672: EQUAL
117673: IFFALSE 117718
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
117675: LD_ADDR_VAR 0 2
117679: PUSH
117680: LD_VAR 0 2
117684: PPUSH
117685: LD_INT 1
117687: PPUSH
117688: LD_VAR 0 2
117692: PUSH
117693: LD_INT 1
117695: ARRAY
117696: PPUSH
117697: LD_INT 1
117699: PPUSH
117700: CALL_OW 3
117704: PPUSH
117705: CALL_OW 1
117709: ST_TO_ADDR
// tmp := 1 ;
117710: LD_ADDR_VAR 0 3
117714: PUSH
117715: LD_STRING 1
117717: ST_TO_ADDR
// end ; normal := normal & tmp ;
117718: LD_ADDR_VAR 0 5
117722: PUSH
117723: LD_VAR 0 5
117727: PUSH
117728: LD_VAR 0 3
117732: STR
117733: ST_TO_ADDR
// end ;
117734: GO 117634
117736: POP
117737: POP
// for i = 1 to hardcoreCounter do
117738: LD_ADDR_VAR 0 8
117742: PUSH
117743: DOUBLE
117744: LD_INT 1
117746: DEC
117747: ST_TO_ADDR
117748: LD_EXP 150
117752: PUSH
117753: FOR_TO
117754: IFFALSE 117859
// begin tmp := 0 ;
117756: LD_ADDR_VAR 0 3
117760: PUSH
117761: LD_STRING 0
117763: ST_TO_ADDR
// if result [ 2 ] then
117764: LD_VAR 0 2
117768: PUSH
117769: LD_INT 2
117771: ARRAY
117772: IFFALSE 117841
// if result [ 2 ] [ 1 ] = 100 + i then
117774: LD_VAR 0 2
117778: PUSH
117779: LD_INT 2
117781: ARRAY
117782: PUSH
117783: LD_INT 1
117785: ARRAY
117786: PUSH
117787: LD_INT 100
117789: PUSH
117790: LD_VAR 0 8
117794: PLUS
117795: EQUAL
117796: IFFALSE 117841
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
117798: LD_ADDR_VAR 0 2
117802: PUSH
117803: LD_VAR 0 2
117807: PPUSH
117808: LD_INT 2
117810: PPUSH
117811: LD_VAR 0 2
117815: PUSH
117816: LD_INT 2
117818: ARRAY
117819: PPUSH
117820: LD_INT 1
117822: PPUSH
117823: CALL_OW 3
117827: PPUSH
117828: CALL_OW 1
117832: ST_TO_ADDR
// tmp := 1 ;
117833: LD_ADDR_VAR 0 3
117837: PUSH
117838: LD_STRING 1
117840: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
117841: LD_ADDR_VAR 0 6
117845: PUSH
117846: LD_VAR 0 6
117850: PUSH
117851: LD_VAR 0 3
117855: STR
117856: ST_TO_ADDR
// end ;
117857: GO 117753
117859: POP
117860: POP
// if isGameLoad then
117861: LD_VAR 0 1
117865: IFFALSE 118340
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
117867: LD_ADDR_VAR 0 4
117871: PUSH
117872: LD_EXP 153
117876: PUSH
117877: LD_EXP 152
117881: PUSH
117882: LD_EXP 154
117886: PUSH
117887: LD_EXP 151
117891: PUSH
117892: LD_EXP 155
117896: PUSH
117897: LD_EXP 156
117901: PUSH
117902: LD_EXP 157
117906: PUSH
117907: LD_EXP 158
117911: PUSH
117912: LD_EXP 159
117916: PUSH
117917: LD_EXP 160
117921: PUSH
117922: LD_EXP 161
117926: PUSH
117927: LD_EXP 162
117931: PUSH
117932: LD_EXP 163
117936: PUSH
117937: LD_EXP 164
117941: PUSH
117942: LD_EXP 172
117946: PUSH
117947: LD_EXP 173
117951: PUSH
117952: LD_EXP 174
117956: PUSH
117957: LD_EXP 175
117961: PUSH
117962: LD_EXP 177
117966: PUSH
117967: LD_EXP 178
117971: PUSH
117972: LD_EXP 179
117976: PUSH
117977: LD_EXP 182
117981: PUSH
117982: LD_EXP 184
117986: PUSH
117987: LD_EXP 185
117991: PUSH
117992: LD_EXP 186
117996: PUSH
117997: LD_EXP 188
118001: PUSH
118002: LD_EXP 189
118006: PUSH
118007: LD_EXP 192
118011: PUSH
118012: LD_EXP 193
118016: PUSH
118017: LD_EXP 194
118021: PUSH
118022: LD_EXP 195
118026: PUSH
118027: LD_EXP 196
118031: PUSH
118032: LD_EXP 197
118036: PUSH
118037: LD_EXP 198
118041: PUSH
118042: LD_EXP 199
118046: PUSH
118047: LD_EXP 200
118051: PUSH
118052: LD_EXP 165
118056: PUSH
118057: LD_EXP 166
118061: PUSH
118062: LD_EXP 169
118066: PUSH
118067: LD_EXP 170
118071: PUSH
118072: LD_EXP 171
118076: PUSH
118077: LD_EXP 167
118081: PUSH
118082: LD_EXP 168
118086: PUSH
118087: LD_EXP 176
118091: PUSH
118092: LD_EXP 180
118096: PUSH
118097: LD_EXP 181
118101: PUSH
118102: LD_EXP 183
118106: PUSH
118107: LD_EXP 187
118111: PUSH
118112: LD_EXP 190
118116: PUSH
118117: LD_EXP 191
118121: PUSH
118122: LD_EXP 201
118126: PUSH
118127: LD_EXP 202
118131: PUSH
118132: LD_EXP 203
118136: PUSH
118137: LD_EXP 204
118141: PUSH
118142: EMPTY
118143: LIST
118144: LIST
118145: LIST
118146: LIST
118147: LIST
118148: LIST
118149: LIST
118150: LIST
118151: LIST
118152: LIST
118153: LIST
118154: LIST
118155: LIST
118156: LIST
118157: LIST
118158: LIST
118159: LIST
118160: LIST
118161: LIST
118162: LIST
118163: LIST
118164: LIST
118165: LIST
118166: LIST
118167: LIST
118168: LIST
118169: LIST
118170: LIST
118171: LIST
118172: LIST
118173: LIST
118174: LIST
118175: LIST
118176: LIST
118177: LIST
118178: LIST
118179: LIST
118180: LIST
118181: LIST
118182: LIST
118183: LIST
118184: LIST
118185: LIST
118186: LIST
118187: LIST
118188: LIST
118189: LIST
118190: LIST
118191: LIST
118192: LIST
118193: LIST
118194: LIST
118195: LIST
118196: LIST
118197: ST_TO_ADDR
// tmp :=  ;
118198: LD_ADDR_VAR 0 3
118202: PUSH
118203: LD_STRING 
118205: ST_TO_ADDR
// for i = 1 to normalCounter do
118206: LD_ADDR_VAR 0 8
118210: PUSH
118211: DOUBLE
118212: LD_INT 1
118214: DEC
118215: ST_TO_ADDR
118216: LD_EXP 149
118220: PUSH
118221: FOR_TO
118222: IFFALSE 118258
// begin if flags [ i ] then
118224: LD_VAR 0 4
118228: PUSH
118229: LD_VAR 0 8
118233: ARRAY
118234: IFFALSE 118256
// tmp := tmp & i & ; ;
118236: LD_ADDR_VAR 0 3
118240: PUSH
118241: LD_VAR 0 3
118245: PUSH
118246: LD_VAR 0 8
118250: STR
118251: PUSH
118252: LD_STRING ;
118254: STR
118255: ST_TO_ADDR
// end ;
118256: GO 118221
118258: POP
118259: POP
// for i = 1 to hardcoreCounter do
118260: LD_ADDR_VAR 0 8
118264: PUSH
118265: DOUBLE
118266: LD_INT 1
118268: DEC
118269: ST_TO_ADDR
118270: LD_EXP 150
118274: PUSH
118275: FOR_TO
118276: IFFALSE 118322
// begin if flags [ normalCounter + i ] then
118278: LD_VAR 0 4
118282: PUSH
118283: LD_EXP 149
118287: PUSH
118288: LD_VAR 0 8
118292: PLUS
118293: ARRAY
118294: IFFALSE 118320
// tmp := tmp & ( 100 + i ) & ; ;
118296: LD_ADDR_VAR 0 3
118300: PUSH
118301: LD_VAR 0 3
118305: PUSH
118306: LD_INT 100
118308: PUSH
118309: LD_VAR 0 8
118313: PLUS
118314: STR
118315: PUSH
118316: LD_STRING ;
118318: STR
118319: ST_TO_ADDR
// end ;
118320: GO 118275
118322: POP
118323: POP
// if tmp then
118324: LD_VAR 0 3
118328: IFFALSE 118340
// active := tmp ;
118330: LD_ADDR_VAR 0 7
118334: PUSH
118335: LD_VAR 0 3
118339: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
118340: LD_STRING getStreamItemsFromMission("
118342: PUSH
118343: LD_VAR 0 5
118347: STR
118348: PUSH
118349: LD_STRING ","
118351: STR
118352: PUSH
118353: LD_VAR 0 6
118357: STR
118358: PUSH
118359: LD_STRING ","
118361: STR
118362: PUSH
118363: LD_VAR 0 7
118367: STR
118368: PUSH
118369: LD_STRING ")
118371: STR
118372: PPUSH
118373: CALL_OW 559
// end else
118377: GO 118386
// ToLua ( getStreamItemsFromMission("","","") ) ;
118379: LD_STRING getStreamItemsFromMission("","","")
118381: PPUSH
118382: CALL_OW 559
// end ;
118386: LD_VAR 0 2
118390: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
118391: LD_EXP 148
118395: PUSH
118396: LD_EXP 153
118400: AND
118401: IFFALSE 118525
118403: GO 118405
118405: DISABLE
118406: LD_INT 0
118408: PPUSH
118409: PPUSH
// begin enable ;
118410: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
118411: LD_ADDR_VAR 0 2
118415: PUSH
118416: LD_INT 22
118418: PUSH
118419: LD_OWVAR 2
118423: PUSH
118424: EMPTY
118425: LIST
118426: LIST
118427: PUSH
118428: LD_INT 2
118430: PUSH
118431: LD_INT 34
118433: PUSH
118434: LD_INT 7
118436: PUSH
118437: EMPTY
118438: LIST
118439: LIST
118440: PUSH
118441: LD_INT 34
118443: PUSH
118444: LD_INT 45
118446: PUSH
118447: EMPTY
118448: LIST
118449: LIST
118450: PUSH
118451: LD_INT 34
118453: PUSH
118454: LD_INT 28
118456: PUSH
118457: EMPTY
118458: LIST
118459: LIST
118460: PUSH
118461: LD_INT 34
118463: PUSH
118464: LD_INT 47
118466: PUSH
118467: EMPTY
118468: LIST
118469: LIST
118470: PUSH
118471: EMPTY
118472: LIST
118473: LIST
118474: LIST
118475: LIST
118476: LIST
118477: PUSH
118478: EMPTY
118479: LIST
118480: LIST
118481: PPUSH
118482: CALL_OW 69
118486: ST_TO_ADDR
// if not tmp then
118487: LD_VAR 0 2
118491: NOT
118492: IFFALSE 118496
// exit ;
118494: GO 118525
// for i in tmp do
118496: LD_ADDR_VAR 0 1
118500: PUSH
118501: LD_VAR 0 2
118505: PUSH
118506: FOR_IN
118507: IFFALSE 118523
// begin SetLives ( i , 0 ) ;
118509: LD_VAR 0 1
118513: PPUSH
118514: LD_INT 0
118516: PPUSH
118517: CALL_OW 234
// end ;
118521: GO 118506
118523: POP
118524: POP
// end ;
118525: PPOPN 2
118527: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
118528: LD_EXP 148
118532: PUSH
118533: LD_EXP 154
118537: AND
118538: IFFALSE 118622
118540: GO 118542
118542: DISABLE
118543: LD_INT 0
118545: PPUSH
118546: PPUSH
// begin enable ;
118547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
118548: LD_ADDR_VAR 0 2
118552: PUSH
118553: LD_INT 22
118555: PUSH
118556: LD_OWVAR 2
118560: PUSH
118561: EMPTY
118562: LIST
118563: LIST
118564: PUSH
118565: LD_INT 32
118567: PUSH
118568: LD_INT 3
118570: PUSH
118571: EMPTY
118572: LIST
118573: LIST
118574: PUSH
118575: EMPTY
118576: LIST
118577: LIST
118578: PPUSH
118579: CALL_OW 69
118583: ST_TO_ADDR
// if not tmp then
118584: LD_VAR 0 2
118588: NOT
118589: IFFALSE 118593
// exit ;
118591: GO 118622
// for i in tmp do
118593: LD_ADDR_VAR 0 1
118597: PUSH
118598: LD_VAR 0 2
118602: PUSH
118603: FOR_IN
118604: IFFALSE 118620
// begin SetLives ( i , 0 ) ;
118606: LD_VAR 0 1
118610: PPUSH
118611: LD_INT 0
118613: PPUSH
118614: CALL_OW 234
// end ;
118618: GO 118603
118620: POP
118621: POP
// end ;
118622: PPOPN 2
118624: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
118625: LD_EXP 148
118629: PUSH
118630: LD_EXP 151
118634: AND
118635: IFFALSE 118728
118637: GO 118639
118639: DISABLE
118640: LD_INT 0
118642: PPUSH
// begin enable ;
118643: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
118644: LD_ADDR_VAR 0 1
118648: PUSH
118649: LD_INT 22
118651: PUSH
118652: LD_OWVAR 2
118656: PUSH
118657: EMPTY
118658: LIST
118659: LIST
118660: PUSH
118661: LD_INT 2
118663: PUSH
118664: LD_INT 25
118666: PUSH
118667: LD_INT 5
118669: PUSH
118670: EMPTY
118671: LIST
118672: LIST
118673: PUSH
118674: LD_INT 25
118676: PUSH
118677: LD_INT 9
118679: PUSH
118680: EMPTY
118681: LIST
118682: LIST
118683: PUSH
118684: LD_INT 25
118686: PUSH
118687: LD_INT 8
118689: PUSH
118690: EMPTY
118691: LIST
118692: LIST
118693: PUSH
118694: EMPTY
118695: LIST
118696: LIST
118697: LIST
118698: LIST
118699: PUSH
118700: EMPTY
118701: LIST
118702: LIST
118703: PPUSH
118704: CALL_OW 69
118708: PUSH
118709: FOR_IN
118710: IFFALSE 118726
// begin SetClass ( i , 1 ) ;
118712: LD_VAR 0 1
118716: PPUSH
118717: LD_INT 1
118719: PPUSH
118720: CALL_OW 336
// end ;
118724: GO 118709
118726: POP
118727: POP
// end ;
118728: PPOPN 1
118730: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
118731: LD_EXP 148
118735: PUSH
118736: LD_EXP 152
118740: AND
118741: PUSH
118742: LD_OWVAR 65
118746: PUSH
118747: LD_INT 7
118749: LESS
118750: AND
118751: IFFALSE 118765
118753: GO 118755
118755: DISABLE
// begin enable ;
118756: ENABLE
// game_speed := 7 ;
118757: LD_ADDR_OWVAR 65
118761: PUSH
118762: LD_INT 7
118764: ST_TO_ADDR
// end ;
118765: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
118766: LD_EXP 148
118770: PUSH
118771: LD_EXP 155
118775: AND
118776: IFFALSE 118978
118778: GO 118780
118780: DISABLE
118781: LD_INT 0
118783: PPUSH
118784: PPUSH
118785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
118786: LD_ADDR_VAR 0 3
118790: PUSH
118791: LD_INT 81
118793: PUSH
118794: LD_OWVAR 2
118798: PUSH
118799: EMPTY
118800: LIST
118801: LIST
118802: PUSH
118803: LD_INT 21
118805: PUSH
118806: LD_INT 1
118808: PUSH
118809: EMPTY
118810: LIST
118811: LIST
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PPUSH
118817: CALL_OW 69
118821: ST_TO_ADDR
// if not tmp then
118822: LD_VAR 0 3
118826: NOT
118827: IFFALSE 118831
// exit ;
118829: GO 118978
// if tmp > 5 then
118831: LD_VAR 0 3
118835: PUSH
118836: LD_INT 5
118838: GREATER
118839: IFFALSE 118851
// k := 5 else
118841: LD_ADDR_VAR 0 2
118845: PUSH
118846: LD_INT 5
118848: ST_TO_ADDR
118849: GO 118861
// k := tmp ;
118851: LD_ADDR_VAR 0 2
118855: PUSH
118856: LD_VAR 0 3
118860: ST_TO_ADDR
// for i := 1 to k do
118861: LD_ADDR_VAR 0 1
118865: PUSH
118866: DOUBLE
118867: LD_INT 1
118869: DEC
118870: ST_TO_ADDR
118871: LD_VAR 0 2
118875: PUSH
118876: FOR_TO
118877: IFFALSE 118976
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
118879: LD_VAR 0 3
118883: PUSH
118884: LD_VAR 0 1
118888: ARRAY
118889: PPUSH
118890: LD_VAR 0 1
118894: PUSH
118895: LD_INT 4
118897: MOD
118898: PUSH
118899: LD_INT 1
118901: PLUS
118902: PPUSH
118903: CALL_OW 259
118907: PUSH
118908: LD_INT 10
118910: LESS
118911: IFFALSE 118974
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
118913: LD_VAR 0 3
118917: PUSH
118918: LD_VAR 0 1
118922: ARRAY
118923: PPUSH
118924: LD_VAR 0 1
118928: PUSH
118929: LD_INT 4
118931: MOD
118932: PUSH
118933: LD_INT 1
118935: PLUS
118936: PPUSH
118937: LD_VAR 0 3
118941: PUSH
118942: LD_VAR 0 1
118946: ARRAY
118947: PPUSH
118948: LD_VAR 0 1
118952: PUSH
118953: LD_INT 4
118955: MOD
118956: PUSH
118957: LD_INT 1
118959: PLUS
118960: PPUSH
118961: CALL_OW 259
118965: PUSH
118966: LD_INT 1
118968: PLUS
118969: PPUSH
118970: CALL_OW 237
118974: GO 118876
118976: POP
118977: POP
// end ;
118978: PPOPN 3
118980: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
118981: LD_EXP 148
118985: PUSH
118986: LD_EXP 156
118990: AND
118991: IFFALSE 119011
118993: GO 118995
118995: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
118996: LD_INT 4
118998: PPUSH
118999: LD_OWVAR 2
119003: PPUSH
119004: LD_INT 0
119006: PPUSH
119007: CALL_OW 324
119011: END
// every 0 0$1 trigger StreamModeActive and sShovel do
119012: LD_EXP 148
119016: PUSH
119017: LD_EXP 185
119021: AND
119022: IFFALSE 119042
119024: GO 119026
119026: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
119027: LD_INT 19
119029: PPUSH
119030: LD_OWVAR 2
119034: PPUSH
119035: LD_INT 0
119037: PPUSH
119038: CALL_OW 324
119042: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
119043: LD_EXP 148
119047: PUSH
119048: LD_EXP 157
119052: AND
119053: IFFALSE 119155
119055: GO 119057
119057: DISABLE
119058: LD_INT 0
119060: PPUSH
119061: PPUSH
// begin enable ;
119062: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
119063: LD_ADDR_VAR 0 2
119067: PUSH
119068: LD_INT 22
119070: PUSH
119071: LD_OWVAR 2
119075: PUSH
119076: EMPTY
119077: LIST
119078: LIST
119079: PUSH
119080: LD_INT 2
119082: PUSH
119083: LD_INT 34
119085: PUSH
119086: LD_INT 11
119088: PUSH
119089: EMPTY
119090: LIST
119091: LIST
119092: PUSH
119093: LD_INT 34
119095: PUSH
119096: LD_INT 30
119098: PUSH
119099: EMPTY
119100: LIST
119101: LIST
119102: PUSH
119103: EMPTY
119104: LIST
119105: LIST
119106: LIST
119107: PUSH
119108: EMPTY
119109: LIST
119110: LIST
119111: PPUSH
119112: CALL_OW 69
119116: ST_TO_ADDR
// if not tmp then
119117: LD_VAR 0 2
119121: NOT
119122: IFFALSE 119126
// exit ;
119124: GO 119155
// for i in tmp do
119126: LD_ADDR_VAR 0 1
119130: PUSH
119131: LD_VAR 0 2
119135: PUSH
119136: FOR_IN
119137: IFFALSE 119153
// begin SetLives ( i , 0 ) ;
119139: LD_VAR 0 1
119143: PPUSH
119144: LD_INT 0
119146: PPUSH
119147: CALL_OW 234
// end ;
119151: GO 119136
119153: POP
119154: POP
// end ;
119155: PPOPN 2
119157: END
// every 0 0$1 trigger StreamModeActive and sBunker do
119158: LD_EXP 148
119162: PUSH
119163: LD_EXP 158
119167: AND
119168: IFFALSE 119188
119170: GO 119172
119172: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
119173: LD_INT 32
119175: PPUSH
119176: LD_OWVAR 2
119180: PPUSH
119181: LD_INT 0
119183: PPUSH
119184: CALL_OW 324
119188: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
119189: LD_EXP 148
119193: PUSH
119194: LD_EXP 159
119198: AND
119199: IFFALSE 119380
119201: GO 119203
119203: DISABLE
119204: LD_INT 0
119206: PPUSH
119207: PPUSH
119208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
119209: LD_ADDR_VAR 0 2
119213: PUSH
119214: LD_INT 22
119216: PUSH
119217: LD_OWVAR 2
119221: PUSH
119222: EMPTY
119223: LIST
119224: LIST
119225: PUSH
119226: LD_INT 33
119228: PUSH
119229: LD_INT 3
119231: PUSH
119232: EMPTY
119233: LIST
119234: LIST
119235: PUSH
119236: EMPTY
119237: LIST
119238: LIST
119239: PPUSH
119240: CALL_OW 69
119244: ST_TO_ADDR
// if not tmp then
119245: LD_VAR 0 2
119249: NOT
119250: IFFALSE 119254
// exit ;
119252: GO 119380
// side := 0 ;
119254: LD_ADDR_VAR 0 3
119258: PUSH
119259: LD_INT 0
119261: ST_TO_ADDR
// for i := 1 to 8 do
119262: LD_ADDR_VAR 0 1
119266: PUSH
119267: DOUBLE
119268: LD_INT 1
119270: DEC
119271: ST_TO_ADDR
119272: LD_INT 8
119274: PUSH
119275: FOR_TO
119276: IFFALSE 119324
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
119278: LD_OWVAR 2
119282: PUSH
119283: LD_VAR 0 1
119287: NONEQUAL
119288: PUSH
119289: LD_OWVAR 2
119293: PPUSH
119294: LD_VAR 0 1
119298: PPUSH
119299: CALL_OW 81
119303: PUSH
119304: LD_INT 2
119306: EQUAL
119307: AND
119308: IFFALSE 119322
// begin side := i ;
119310: LD_ADDR_VAR 0 3
119314: PUSH
119315: LD_VAR 0 1
119319: ST_TO_ADDR
// break ;
119320: GO 119324
// end ;
119322: GO 119275
119324: POP
119325: POP
// if not side then
119326: LD_VAR 0 3
119330: NOT
119331: IFFALSE 119335
// exit ;
119333: GO 119380
// for i := 1 to tmp do
119335: LD_ADDR_VAR 0 1
119339: PUSH
119340: DOUBLE
119341: LD_INT 1
119343: DEC
119344: ST_TO_ADDR
119345: LD_VAR 0 2
119349: PUSH
119350: FOR_TO
119351: IFFALSE 119378
// if Prob ( 60 ) then
119353: LD_INT 60
119355: PPUSH
119356: CALL_OW 13
119360: IFFALSE 119376
// SetSide ( i , side ) ;
119362: LD_VAR 0 1
119366: PPUSH
119367: LD_VAR 0 3
119371: PPUSH
119372: CALL_OW 235
119376: GO 119350
119378: POP
119379: POP
// end ;
119380: PPOPN 3
119382: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
119383: LD_EXP 148
119387: PUSH
119388: LD_EXP 161
119392: AND
119393: IFFALSE 119512
119395: GO 119397
119397: DISABLE
119398: LD_INT 0
119400: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
119401: LD_ADDR_VAR 0 1
119405: PUSH
119406: LD_INT 22
119408: PUSH
119409: LD_OWVAR 2
119413: PUSH
119414: EMPTY
119415: LIST
119416: LIST
119417: PUSH
119418: LD_INT 21
119420: PUSH
119421: LD_INT 1
119423: PUSH
119424: EMPTY
119425: LIST
119426: LIST
119427: PUSH
119428: LD_INT 3
119430: PUSH
119431: LD_INT 23
119433: PUSH
119434: LD_INT 0
119436: PUSH
119437: EMPTY
119438: LIST
119439: LIST
119440: PUSH
119441: EMPTY
119442: LIST
119443: LIST
119444: PUSH
119445: EMPTY
119446: LIST
119447: LIST
119448: LIST
119449: PPUSH
119450: CALL_OW 69
119454: PUSH
119455: FOR_IN
119456: IFFALSE 119510
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
119458: LD_VAR 0 1
119462: PPUSH
119463: CALL_OW 257
119467: PUSH
119468: LD_INT 1
119470: PUSH
119471: LD_INT 2
119473: PUSH
119474: LD_INT 3
119476: PUSH
119477: LD_INT 4
119479: PUSH
119480: EMPTY
119481: LIST
119482: LIST
119483: LIST
119484: LIST
119485: IN
119486: IFFALSE 119508
// SetClass ( un , rand ( 1 , 4 ) ) ;
119488: LD_VAR 0 1
119492: PPUSH
119493: LD_INT 1
119495: PPUSH
119496: LD_INT 4
119498: PPUSH
119499: CALL_OW 12
119503: PPUSH
119504: CALL_OW 336
119508: GO 119455
119510: POP
119511: POP
// end ;
119512: PPOPN 1
119514: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
119515: LD_EXP 148
119519: PUSH
119520: LD_EXP 160
119524: AND
119525: IFFALSE 119604
119527: GO 119529
119529: DISABLE
119530: LD_INT 0
119532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119533: LD_ADDR_VAR 0 1
119537: PUSH
119538: LD_INT 22
119540: PUSH
119541: LD_OWVAR 2
119545: PUSH
119546: EMPTY
119547: LIST
119548: LIST
119549: PUSH
119550: LD_INT 21
119552: PUSH
119553: LD_INT 3
119555: PUSH
119556: EMPTY
119557: LIST
119558: LIST
119559: PUSH
119560: EMPTY
119561: LIST
119562: LIST
119563: PPUSH
119564: CALL_OW 69
119568: ST_TO_ADDR
// if not tmp then
119569: LD_VAR 0 1
119573: NOT
119574: IFFALSE 119578
// exit ;
119576: GO 119604
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
119578: LD_VAR 0 1
119582: PUSH
119583: LD_INT 1
119585: PPUSH
119586: LD_VAR 0 1
119590: PPUSH
119591: CALL_OW 12
119595: ARRAY
119596: PPUSH
119597: LD_INT 100
119599: PPUSH
119600: CALL_OW 234
// end ;
119604: PPOPN 1
119606: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
119607: LD_EXP 148
119611: PUSH
119612: LD_EXP 162
119616: AND
119617: IFFALSE 119715
119619: GO 119621
119621: DISABLE
119622: LD_INT 0
119624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119625: LD_ADDR_VAR 0 1
119629: PUSH
119630: LD_INT 22
119632: PUSH
119633: LD_OWVAR 2
119637: PUSH
119638: EMPTY
119639: LIST
119640: LIST
119641: PUSH
119642: LD_INT 21
119644: PUSH
119645: LD_INT 1
119647: PUSH
119648: EMPTY
119649: LIST
119650: LIST
119651: PUSH
119652: EMPTY
119653: LIST
119654: LIST
119655: PPUSH
119656: CALL_OW 69
119660: ST_TO_ADDR
// if not tmp then
119661: LD_VAR 0 1
119665: NOT
119666: IFFALSE 119670
// exit ;
119668: GO 119715
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
119670: LD_VAR 0 1
119674: PUSH
119675: LD_INT 1
119677: PPUSH
119678: LD_VAR 0 1
119682: PPUSH
119683: CALL_OW 12
119687: ARRAY
119688: PPUSH
119689: LD_INT 1
119691: PPUSH
119692: LD_INT 4
119694: PPUSH
119695: CALL_OW 12
119699: PPUSH
119700: LD_INT 3000
119702: PPUSH
119703: LD_INT 9000
119705: PPUSH
119706: CALL_OW 12
119710: PPUSH
119711: CALL_OW 492
// end ;
119715: PPOPN 1
119717: END
// every 0 0$1 trigger StreamModeActive and sDepot do
119718: LD_EXP 148
119722: PUSH
119723: LD_EXP 163
119727: AND
119728: IFFALSE 119748
119730: GO 119732
119732: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
119733: LD_INT 1
119735: PPUSH
119736: LD_OWVAR 2
119740: PPUSH
119741: LD_INT 0
119743: PPUSH
119744: CALL_OW 324
119748: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
119749: LD_EXP 148
119753: PUSH
119754: LD_EXP 164
119758: AND
119759: IFFALSE 119842
119761: GO 119763
119763: DISABLE
119764: LD_INT 0
119766: PPUSH
119767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
119768: LD_ADDR_VAR 0 2
119772: PUSH
119773: LD_INT 22
119775: PUSH
119776: LD_OWVAR 2
119780: PUSH
119781: EMPTY
119782: LIST
119783: LIST
119784: PUSH
119785: LD_INT 21
119787: PUSH
119788: LD_INT 3
119790: PUSH
119791: EMPTY
119792: LIST
119793: LIST
119794: PUSH
119795: EMPTY
119796: LIST
119797: LIST
119798: PPUSH
119799: CALL_OW 69
119803: ST_TO_ADDR
// if not tmp then
119804: LD_VAR 0 2
119808: NOT
119809: IFFALSE 119813
// exit ;
119811: GO 119842
// for i in tmp do
119813: LD_ADDR_VAR 0 1
119817: PUSH
119818: LD_VAR 0 2
119822: PUSH
119823: FOR_IN
119824: IFFALSE 119840
// SetBLevel ( i , 10 ) ;
119826: LD_VAR 0 1
119830: PPUSH
119831: LD_INT 10
119833: PPUSH
119834: CALL_OW 241
119838: GO 119823
119840: POP
119841: POP
// end ;
119842: PPOPN 2
119844: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
119845: LD_EXP 148
119849: PUSH
119850: LD_EXP 165
119854: AND
119855: IFFALSE 119966
119857: GO 119859
119859: DISABLE
119860: LD_INT 0
119862: PPUSH
119863: PPUSH
119864: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119865: LD_ADDR_VAR 0 3
119869: PUSH
119870: LD_INT 22
119872: PUSH
119873: LD_OWVAR 2
119877: PUSH
119878: EMPTY
119879: LIST
119880: LIST
119881: PUSH
119882: LD_INT 25
119884: PUSH
119885: LD_INT 1
119887: PUSH
119888: EMPTY
119889: LIST
119890: LIST
119891: PUSH
119892: EMPTY
119893: LIST
119894: LIST
119895: PPUSH
119896: CALL_OW 69
119900: ST_TO_ADDR
// if not tmp then
119901: LD_VAR 0 3
119905: NOT
119906: IFFALSE 119910
// exit ;
119908: GO 119966
// un := tmp [ rand ( 1 , tmp ) ] ;
119910: LD_ADDR_VAR 0 2
119914: PUSH
119915: LD_VAR 0 3
119919: PUSH
119920: LD_INT 1
119922: PPUSH
119923: LD_VAR 0 3
119927: PPUSH
119928: CALL_OW 12
119932: ARRAY
119933: ST_TO_ADDR
// if Crawls ( un ) then
119934: LD_VAR 0 2
119938: PPUSH
119939: CALL_OW 318
119943: IFFALSE 119954
// ComWalk ( un ) ;
119945: LD_VAR 0 2
119949: PPUSH
119950: CALL_OW 138
// SetClass ( un , class_sniper ) ;
119954: LD_VAR 0 2
119958: PPUSH
119959: LD_INT 5
119961: PPUSH
119962: CALL_OW 336
// end ;
119966: PPOPN 3
119968: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
119969: LD_EXP 148
119973: PUSH
119974: LD_EXP 166
119978: AND
119979: PUSH
119980: LD_OWVAR 67
119984: PUSH
119985: LD_INT 4
119987: LESS
119988: AND
119989: IFFALSE 120008
119991: GO 119993
119993: DISABLE
// begin Difficulty := Difficulty + 1 ;
119994: LD_ADDR_OWVAR 67
119998: PUSH
119999: LD_OWVAR 67
120003: PUSH
120004: LD_INT 1
120006: PLUS
120007: ST_TO_ADDR
// end ;
120008: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
120009: LD_EXP 148
120013: PUSH
120014: LD_EXP 167
120018: AND
120019: IFFALSE 120122
120021: GO 120023
120023: DISABLE
120024: LD_INT 0
120026: PPUSH
// begin for i := 1 to 5 do
120027: LD_ADDR_VAR 0 1
120031: PUSH
120032: DOUBLE
120033: LD_INT 1
120035: DEC
120036: ST_TO_ADDR
120037: LD_INT 5
120039: PUSH
120040: FOR_TO
120041: IFFALSE 120120
// begin uc_nation := nation_nature ;
120043: LD_ADDR_OWVAR 21
120047: PUSH
120048: LD_INT 0
120050: ST_TO_ADDR
// uc_side := 0 ;
120051: LD_ADDR_OWVAR 20
120055: PUSH
120056: LD_INT 0
120058: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120059: LD_ADDR_OWVAR 29
120063: PUSH
120064: LD_INT 12
120066: PUSH
120067: LD_INT 12
120069: PUSH
120070: EMPTY
120071: LIST
120072: LIST
120073: ST_TO_ADDR
// hc_agressivity := 20 ;
120074: LD_ADDR_OWVAR 35
120078: PUSH
120079: LD_INT 20
120081: ST_TO_ADDR
// hc_class := class_tiger ;
120082: LD_ADDR_OWVAR 28
120086: PUSH
120087: LD_INT 14
120089: ST_TO_ADDR
// hc_gallery :=  ;
120090: LD_ADDR_OWVAR 33
120094: PUSH
120095: LD_STRING 
120097: ST_TO_ADDR
// hc_name :=  ;
120098: LD_ADDR_OWVAR 26
120102: PUSH
120103: LD_STRING 
120105: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
120106: CALL_OW 44
120110: PPUSH
120111: LD_INT 0
120113: PPUSH
120114: CALL_OW 51
// end ;
120118: GO 120040
120120: POP
120121: POP
// end ;
120122: PPOPN 1
120124: END
// every 0 0$1 trigger StreamModeActive and sBomb do
120125: LD_EXP 148
120129: PUSH
120130: LD_EXP 168
120134: AND
120135: IFFALSE 120144
120137: GO 120139
120139: DISABLE
// StreamSibBomb ;
120140: CALL 120145 0 0
120144: END
// export function StreamSibBomb ; var i , x , y ; begin
120145: LD_INT 0
120147: PPUSH
120148: PPUSH
120149: PPUSH
120150: PPUSH
// result := false ;
120151: LD_ADDR_VAR 0 1
120155: PUSH
120156: LD_INT 0
120158: ST_TO_ADDR
// for i := 1 to 16 do
120159: LD_ADDR_VAR 0 2
120163: PUSH
120164: DOUBLE
120165: LD_INT 1
120167: DEC
120168: ST_TO_ADDR
120169: LD_INT 16
120171: PUSH
120172: FOR_TO
120173: IFFALSE 120372
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120175: LD_ADDR_VAR 0 3
120179: PUSH
120180: LD_INT 10
120182: PUSH
120183: LD_INT 20
120185: PUSH
120186: LD_INT 30
120188: PUSH
120189: LD_INT 40
120191: PUSH
120192: LD_INT 50
120194: PUSH
120195: LD_INT 60
120197: PUSH
120198: LD_INT 70
120200: PUSH
120201: LD_INT 80
120203: PUSH
120204: LD_INT 90
120206: PUSH
120207: LD_INT 100
120209: PUSH
120210: LD_INT 110
120212: PUSH
120213: LD_INT 120
120215: PUSH
120216: LD_INT 130
120218: PUSH
120219: LD_INT 140
120221: PUSH
120222: LD_INT 150
120224: PUSH
120225: EMPTY
120226: LIST
120227: LIST
120228: LIST
120229: LIST
120230: LIST
120231: LIST
120232: LIST
120233: LIST
120234: LIST
120235: LIST
120236: LIST
120237: LIST
120238: LIST
120239: LIST
120240: LIST
120241: PUSH
120242: LD_INT 1
120244: PPUSH
120245: LD_INT 15
120247: PPUSH
120248: CALL_OW 12
120252: ARRAY
120253: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
120254: LD_ADDR_VAR 0 4
120258: PUSH
120259: LD_INT 10
120261: PUSH
120262: LD_INT 20
120264: PUSH
120265: LD_INT 30
120267: PUSH
120268: LD_INT 40
120270: PUSH
120271: LD_INT 50
120273: PUSH
120274: LD_INT 60
120276: PUSH
120277: LD_INT 70
120279: PUSH
120280: LD_INT 80
120282: PUSH
120283: LD_INT 90
120285: PUSH
120286: LD_INT 100
120288: PUSH
120289: LD_INT 110
120291: PUSH
120292: LD_INT 120
120294: PUSH
120295: LD_INT 130
120297: PUSH
120298: LD_INT 140
120300: PUSH
120301: LD_INT 150
120303: PUSH
120304: EMPTY
120305: LIST
120306: LIST
120307: LIST
120308: LIST
120309: LIST
120310: LIST
120311: LIST
120312: LIST
120313: LIST
120314: LIST
120315: LIST
120316: LIST
120317: LIST
120318: LIST
120319: LIST
120320: PUSH
120321: LD_INT 1
120323: PPUSH
120324: LD_INT 15
120326: PPUSH
120327: CALL_OW 12
120331: ARRAY
120332: ST_TO_ADDR
// if ValidHex ( x , y ) then
120333: LD_VAR 0 3
120337: PPUSH
120338: LD_VAR 0 4
120342: PPUSH
120343: CALL_OW 488
120347: IFFALSE 120370
// begin result := [ x , y ] ;
120349: LD_ADDR_VAR 0 1
120353: PUSH
120354: LD_VAR 0 3
120358: PUSH
120359: LD_VAR 0 4
120363: PUSH
120364: EMPTY
120365: LIST
120366: LIST
120367: ST_TO_ADDR
// break ;
120368: GO 120372
// end ; end ;
120370: GO 120172
120372: POP
120373: POP
// if result then
120374: LD_VAR 0 1
120378: IFFALSE 120438
// begin ToLua ( playSibBomb() ) ;
120380: LD_STRING playSibBomb()
120382: PPUSH
120383: CALL_OW 559
// wait ( 0 0$14 ) ;
120387: LD_INT 490
120389: PPUSH
120390: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
120394: LD_VAR 0 1
120398: PUSH
120399: LD_INT 1
120401: ARRAY
120402: PPUSH
120403: LD_VAR 0 1
120407: PUSH
120408: LD_INT 2
120410: ARRAY
120411: PPUSH
120412: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
120416: LD_VAR 0 1
120420: PUSH
120421: LD_INT 1
120423: ARRAY
120424: PPUSH
120425: LD_VAR 0 1
120429: PUSH
120430: LD_INT 2
120432: ARRAY
120433: PPUSH
120434: CALL_OW 429
// end ; end ;
120438: LD_VAR 0 1
120442: RET
// every 0 0$1 trigger StreamModeActive and sReset do
120443: LD_EXP 148
120447: PUSH
120448: LD_EXP 170
120452: AND
120453: IFFALSE 120465
120455: GO 120457
120457: DISABLE
// YouLost (  ) ;
120458: LD_STRING 
120460: PPUSH
120461: CALL_OW 104
120465: END
// every 0 0$1 trigger StreamModeActive and sFog do
120466: LD_EXP 148
120470: PUSH
120471: LD_EXP 169
120475: AND
120476: IFFALSE 120490
120478: GO 120480
120480: DISABLE
// FogOff ( your_side ) ;
120481: LD_OWVAR 2
120485: PPUSH
120486: CALL_OW 344
120490: END
// every 0 0$1 trigger StreamModeActive and sSun do
120491: LD_EXP 148
120495: PUSH
120496: LD_EXP 171
120500: AND
120501: IFFALSE 120529
120503: GO 120505
120505: DISABLE
// begin solar_recharge_percent := 0 ;
120506: LD_ADDR_OWVAR 79
120510: PUSH
120511: LD_INT 0
120513: ST_TO_ADDR
// wait ( 5 5$00 ) ;
120514: LD_INT 10500
120516: PPUSH
120517: CALL_OW 67
// solar_recharge_percent := 100 ;
120521: LD_ADDR_OWVAR 79
120525: PUSH
120526: LD_INT 100
120528: ST_TO_ADDR
// end ;
120529: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
120530: LD_EXP 148
120534: PUSH
120535: LD_EXP 172
120539: AND
120540: IFFALSE 120779
120542: GO 120544
120544: DISABLE
120545: LD_INT 0
120547: PPUSH
120548: PPUSH
120549: PPUSH
// begin tmp := [ ] ;
120550: LD_ADDR_VAR 0 3
120554: PUSH
120555: EMPTY
120556: ST_TO_ADDR
// for i := 1 to 6 do
120557: LD_ADDR_VAR 0 1
120561: PUSH
120562: DOUBLE
120563: LD_INT 1
120565: DEC
120566: ST_TO_ADDR
120567: LD_INT 6
120569: PUSH
120570: FOR_TO
120571: IFFALSE 120676
// begin uc_nation := nation_nature ;
120573: LD_ADDR_OWVAR 21
120577: PUSH
120578: LD_INT 0
120580: ST_TO_ADDR
// uc_side := 0 ;
120581: LD_ADDR_OWVAR 20
120585: PUSH
120586: LD_INT 0
120588: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
120589: LD_ADDR_OWVAR 29
120593: PUSH
120594: LD_INT 12
120596: PUSH
120597: LD_INT 12
120599: PUSH
120600: EMPTY
120601: LIST
120602: LIST
120603: ST_TO_ADDR
// hc_agressivity := 20 ;
120604: LD_ADDR_OWVAR 35
120608: PUSH
120609: LD_INT 20
120611: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
120612: LD_ADDR_OWVAR 28
120616: PUSH
120617: LD_INT 17
120619: ST_TO_ADDR
// hc_gallery :=  ;
120620: LD_ADDR_OWVAR 33
120624: PUSH
120625: LD_STRING 
120627: ST_TO_ADDR
// hc_name :=  ;
120628: LD_ADDR_OWVAR 26
120632: PUSH
120633: LD_STRING 
120635: ST_TO_ADDR
// un := CreateHuman ;
120636: LD_ADDR_VAR 0 2
120640: PUSH
120641: CALL_OW 44
120645: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
120646: LD_VAR 0 2
120650: PPUSH
120651: LD_INT 1
120653: PPUSH
120654: CALL_OW 51
// tmp := tmp ^ un ;
120658: LD_ADDR_VAR 0 3
120662: PUSH
120663: LD_VAR 0 3
120667: PUSH
120668: LD_VAR 0 2
120672: ADD
120673: ST_TO_ADDR
// end ;
120674: GO 120570
120676: POP
120677: POP
// repeat wait ( 0 0$1 ) ;
120678: LD_INT 35
120680: PPUSH
120681: CALL_OW 67
// for un in tmp do
120685: LD_ADDR_VAR 0 2
120689: PUSH
120690: LD_VAR 0 3
120694: PUSH
120695: FOR_IN
120696: IFFALSE 120770
// begin if IsDead ( un ) then
120698: LD_VAR 0 2
120702: PPUSH
120703: CALL_OW 301
120707: IFFALSE 120727
// begin tmp := tmp diff un ;
120709: LD_ADDR_VAR 0 3
120713: PUSH
120714: LD_VAR 0 3
120718: PUSH
120719: LD_VAR 0 2
120723: DIFF
120724: ST_TO_ADDR
// continue ;
120725: GO 120695
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
120727: LD_VAR 0 2
120731: PPUSH
120732: LD_INT 3
120734: PUSH
120735: LD_INT 22
120737: PUSH
120738: LD_INT 0
120740: PUSH
120741: EMPTY
120742: LIST
120743: LIST
120744: PUSH
120745: EMPTY
120746: LIST
120747: LIST
120748: PPUSH
120749: CALL_OW 69
120753: PPUSH
120754: LD_VAR 0 2
120758: PPUSH
120759: CALL_OW 74
120763: PPUSH
120764: CALL_OW 115
// end ;
120768: GO 120695
120770: POP
120771: POP
// until not tmp ;
120772: LD_VAR 0 3
120776: NOT
120777: IFFALSE 120678
// end ;
120779: PPOPN 3
120781: END
// every 0 0$1 trigger StreamModeActive and sTroll do
120782: LD_EXP 148
120786: PUSH
120787: LD_EXP 173
120791: AND
120792: IFFALSE 120846
120794: GO 120796
120796: DISABLE
// begin ToLua ( displayTroll(); ) ;
120797: LD_STRING displayTroll();
120799: PPUSH
120800: CALL_OW 559
// wait ( 3 3$00 ) ;
120804: LD_INT 6300
120806: PPUSH
120807: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120811: LD_STRING hideTroll();
120813: PPUSH
120814: CALL_OW 559
// wait ( 1 1$00 ) ;
120818: LD_INT 2100
120820: PPUSH
120821: CALL_OW 67
// ToLua ( displayTroll(); ) ;
120825: LD_STRING displayTroll();
120827: PPUSH
120828: CALL_OW 559
// wait ( 1 1$00 ) ;
120832: LD_INT 2100
120834: PPUSH
120835: CALL_OW 67
// ToLua ( hideTroll(); ) ;
120839: LD_STRING hideTroll();
120841: PPUSH
120842: CALL_OW 559
// end ;
120846: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
120847: LD_EXP 148
120851: PUSH
120852: LD_EXP 174
120856: AND
120857: IFFALSE 120920
120859: GO 120861
120861: DISABLE
120862: LD_INT 0
120864: PPUSH
// begin p := 0 ;
120865: LD_ADDR_VAR 0 1
120869: PUSH
120870: LD_INT 0
120872: ST_TO_ADDR
// repeat game_speed := 1 ;
120873: LD_ADDR_OWVAR 65
120877: PUSH
120878: LD_INT 1
120880: ST_TO_ADDR
// wait ( 0 0$1 ) ;
120881: LD_INT 35
120883: PPUSH
120884: CALL_OW 67
// p := p + 1 ;
120888: LD_ADDR_VAR 0 1
120892: PUSH
120893: LD_VAR 0 1
120897: PUSH
120898: LD_INT 1
120900: PLUS
120901: ST_TO_ADDR
// until p >= 60 ;
120902: LD_VAR 0 1
120906: PUSH
120907: LD_INT 60
120909: GREATEREQUAL
120910: IFFALSE 120873
// game_speed := 4 ;
120912: LD_ADDR_OWVAR 65
120916: PUSH
120917: LD_INT 4
120919: ST_TO_ADDR
// end ;
120920: PPOPN 1
120922: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
120923: LD_EXP 148
120927: PUSH
120928: LD_EXP 175
120932: AND
120933: IFFALSE 121079
120935: GO 120937
120937: DISABLE
120938: LD_INT 0
120940: PPUSH
120941: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
120942: LD_ADDR_VAR 0 1
120946: PUSH
120947: LD_INT 22
120949: PUSH
120950: LD_OWVAR 2
120954: PUSH
120955: EMPTY
120956: LIST
120957: LIST
120958: PUSH
120959: LD_INT 2
120961: PUSH
120962: LD_INT 30
120964: PUSH
120965: LD_INT 0
120967: PUSH
120968: EMPTY
120969: LIST
120970: LIST
120971: PUSH
120972: LD_INT 30
120974: PUSH
120975: LD_INT 1
120977: PUSH
120978: EMPTY
120979: LIST
120980: LIST
120981: PUSH
120982: EMPTY
120983: LIST
120984: LIST
120985: LIST
120986: PUSH
120987: EMPTY
120988: LIST
120989: LIST
120990: PPUSH
120991: CALL_OW 69
120995: ST_TO_ADDR
// if not depot then
120996: LD_VAR 0 1
121000: NOT
121001: IFFALSE 121005
// exit ;
121003: GO 121079
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
121005: LD_ADDR_VAR 0 2
121009: PUSH
121010: LD_VAR 0 1
121014: PUSH
121015: LD_INT 1
121017: PPUSH
121018: LD_VAR 0 1
121022: PPUSH
121023: CALL_OW 12
121027: ARRAY
121028: PPUSH
121029: CALL_OW 274
121033: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
121034: LD_VAR 0 2
121038: PPUSH
121039: LD_INT 1
121041: PPUSH
121042: LD_INT 0
121044: PPUSH
121045: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
121049: LD_VAR 0 2
121053: PPUSH
121054: LD_INT 2
121056: PPUSH
121057: LD_INT 0
121059: PPUSH
121060: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
121064: LD_VAR 0 2
121068: PPUSH
121069: LD_INT 3
121071: PPUSH
121072: LD_INT 0
121074: PPUSH
121075: CALL_OW 277
// end ;
121079: PPOPN 2
121081: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
121082: LD_EXP 148
121086: PUSH
121087: LD_EXP 176
121091: AND
121092: IFFALSE 121189
121094: GO 121096
121096: DISABLE
121097: LD_INT 0
121099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121100: LD_ADDR_VAR 0 1
121104: PUSH
121105: LD_INT 22
121107: PUSH
121108: LD_OWVAR 2
121112: PUSH
121113: EMPTY
121114: LIST
121115: LIST
121116: PUSH
121117: LD_INT 21
121119: PUSH
121120: LD_INT 1
121122: PUSH
121123: EMPTY
121124: LIST
121125: LIST
121126: PUSH
121127: LD_INT 3
121129: PUSH
121130: LD_INT 23
121132: PUSH
121133: LD_INT 0
121135: PUSH
121136: EMPTY
121137: LIST
121138: LIST
121139: PUSH
121140: EMPTY
121141: LIST
121142: LIST
121143: PUSH
121144: EMPTY
121145: LIST
121146: LIST
121147: LIST
121148: PPUSH
121149: CALL_OW 69
121153: ST_TO_ADDR
// if not tmp then
121154: LD_VAR 0 1
121158: NOT
121159: IFFALSE 121163
// exit ;
121161: GO 121189
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
121163: LD_VAR 0 1
121167: PUSH
121168: LD_INT 1
121170: PPUSH
121171: LD_VAR 0 1
121175: PPUSH
121176: CALL_OW 12
121180: ARRAY
121181: PPUSH
121182: LD_INT 200
121184: PPUSH
121185: CALL_OW 234
// end ;
121189: PPOPN 1
121191: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
121192: LD_EXP 148
121196: PUSH
121197: LD_EXP 177
121201: AND
121202: IFFALSE 121281
121204: GO 121206
121206: DISABLE
121207: LD_INT 0
121209: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
121210: LD_ADDR_VAR 0 1
121214: PUSH
121215: LD_INT 22
121217: PUSH
121218: LD_OWVAR 2
121222: PUSH
121223: EMPTY
121224: LIST
121225: LIST
121226: PUSH
121227: LD_INT 21
121229: PUSH
121230: LD_INT 2
121232: PUSH
121233: EMPTY
121234: LIST
121235: LIST
121236: PUSH
121237: EMPTY
121238: LIST
121239: LIST
121240: PPUSH
121241: CALL_OW 69
121245: ST_TO_ADDR
// if not tmp then
121246: LD_VAR 0 1
121250: NOT
121251: IFFALSE 121255
// exit ;
121253: GO 121281
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
121255: LD_VAR 0 1
121259: PUSH
121260: LD_INT 1
121262: PPUSH
121263: LD_VAR 0 1
121267: PPUSH
121268: CALL_OW 12
121272: ARRAY
121273: PPUSH
121274: LD_INT 60
121276: PPUSH
121277: CALL_OW 234
// end ;
121281: PPOPN 1
121283: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
121284: LD_EXP 148
121288: PUSH
121289: LD_EXP 178
121293: AND
121294: IFFALSE 121393
121296: GO 121298
121298: DISABLE
121299: LD_INT 0
121301: PPUSH
121302: PPUSH
// begin enable ;
121303: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
121304: LD_ADDR_VAR 0 1
121308: PUSH
121309: LD_INT 22
121311: PUSH
121312: LD_OWVAR 2
121316: PUSH
121317: EMPTY
121318: LIST
121319: LIST
121320: PUSH
121321: LD_INT 61
121323: PUSH
121324: EMPTY
121325: LIST
121326: PUSH
121327: LD_INT 33
121329: PUSH
121330: LD_INT 2
121332: PUSH
121333: EMPTY
121334: LIST
121335: LIST
121336: PUSH
121337: EMPTY
121338: LIST
121339: LIST
121340: LIST
121341: PPUSH
121342: CALL_OW 69
121346: ST_TO_ADDR
// if not tmp then
121347: LD_VAR 0 1
121351: NOT
121352: IFFALSE 121356
// exit ;
121354: GO 121393
// for i in tmp do
121356: LD_ADDR_VAR 0 2
121360: PUSH
121361: LD_VAR 0 1
121365: PUSH
121366: FOR_IN
121367: IFFALSE 121391
// if IsControledBy ( i ) then
121369: LD_VAR 0 2
121373: PPUSH
121374: CALL_OW 312
121378: IFFALSE 121389
// ComUnlink ( i ) ;
121380: LD_VAR 0 2
121384: PPUSH
121385: CALL_OW 136
121389: GO 121366
121391: POP
121392: POP
// end ;
121393: PPOPN 2
121395: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
121396: LD_EXP 148
121400: PUSH
121401: LD_EXP 179
121405: AND
121406: IFFALSE 121546
121408: GO 121410
121410: DISABLE
121411: LD_INT 0
121413: PPUSH
121414: PPUSH
// begin ToLua ( displayPowell(); ) ;
121415: LD_STRING displayPowell();
121417: PPUSH
121418: CALL_OW 559
// uc_side := 0 ;
121422: LD_ADDR_OWVAR 20
121426: PUSH
121427: LD_INT 0
121429: ST_TO_ADDR
// uc_nation := 2 ;
121430: LD_ADDR_OWVAR 21
121434: PUSH
121435: LD_INT 2
121437: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
121438: LD_ADDR_OWVAR 37
121442: PUSH
121443: LD_INT 14
121445: ST_TO_ADDR
// vc_engine := engine_siberite ;
121446: LD_ADDR_OWVAR 39
121450: PUSH
121451: LD_INT 3
121453: ST_TO_ADDR
// vc_control := control_apeman ;
121454: LD_ADDR_OWVAR 38
121458: PUSH
121459: LD_INT 5
121461: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
121462: LD_ADDR_OWVAR 40
121466: PUSH
121467: LD_INT 29
121469: ST_TO_ADDR
// un := CreateVehicle ;
121470: LD_ADDR_VAR 0 2
121474: PUSH
121475: CALL_OW 45
121479: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
121480: LD_VAR 0 2
121484: PPUSH
121485: LD_INT 1
121487: PPUSH
121488: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
121492: LD_INT 35
121494: PPUSH
121495: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
121499: LD_VAR 0 2
121503: PPUSH
121504: LD_INT 22
121506: PUSH
121507: LD_OWVAR 2
121511: PUSH
121512: EMPTY
121513: LIST
121514: LIST
121515: PPUSH
121516: CALL_OW 69
121520: PPUSH
121521: LD_VAR 0 2
121525: PPUSH
121526: CALL_OW 74
121530: PPUSH
121531: CALL_OW 115
// until IsDead ( un ) ;
121535: LD_VAR 0 2
121539: PPUSH
121540: CALL_OW 301
121544: IFFALSE 121492
// end ;
121546: PPOPN 2
121548: END
// every 0 0$1 trigger StreamModeActive and sStu do
121549: LD_EXP 148
121553: PUSH
121554: LD_EXP 187
121558: AND
121559: IFFALSE 121575
121561: GO 121563
121563: DISABLE
// begin ToLua ( displayStucuk(); ) ;
121564: LD_STRING displayStucuk();
121566: PPUSH
121567: CALL_OW 559
// ResetFog ;
121571: CALL_OW 335
// end ;
121575: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
121576: LD_EXP 148
121580: PUSH
121581: LD_EXP 180
121585: AND
121586: IFFALSE 121727
121588: GO 121590
121590: DISABLE
121591: LD_INT 0
121593: PPUSH
121594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121595: LD_ADDR_VAR 0 2
121599: PUSH
121600: LD_INT 22
121602: PUSH
121603: LD_OWVAR 2
121607: PUSH
121608: EMPTY
121609: LIST
121610: LIST
121611: PUSH
121612: LD_INT 21
121614: PUSH
121615: LD_INT 1
121617: PUSH
121618: EMPTY
121619: LIST
121620: LIST
121621: PUSH
121622: EMPTY
121623: LIST
121624: LIST
121625: PPUSH
121626: CALL_OW 69
121630: ST_TO_ADDR
// if not tmp then
121631: LD_VAR 0 2
121635: NOT
121636: IFFALSE 121640
// exit ;
121638: GO 121727
// un := tmp [ rand ( 1 , tmp ) ] ;
121640: LD_ADDR_VAR 0 1
121644: PUSH
121645: LD_VAR 0 2
121649: PUSH
121650: LD_INT 1
121652: PPUSH
121653: LD_VAR 0 2
121657: PPUSH
121658: CALL_OW 12
121662: ARRAY
121663: ST_TO_ADDR
// SetSide ( un , 0 ) ;
121664: LD_VAR 0 1
121668: PPUSH
121669: LD_INT 0
121671: PPUSH
121672: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
121676: LD_VAR 0 1
121680: PPUSH
121681: LD_OWVAR 3
121685: PUSH
121686: LD_VAR 0 1
121690: DIFF
121691: PPUSH
121692: LD_VAR 0 1
121696: PPUSH
121697: CALL_OW 74
121701: PPUSH
121702: CALL_OW 115
// wait ( 0 0$20 ) ;
121706: LD_INT 700
121708: PPUSH
121709: CALL_OW 67
// SetSide ( un , your_side ) ;
121713: LD_VAR 0 1
121717: PPUSH
121718: LD_OWVAR 2
121722: PPUSH
121723: CALL_OW 235
// end ;
121727: PPOPN 2
121729: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
121730: LD_EXP 148
121734: PUSH
121735: LD_EXP 181
121739: AND
121740: IFFALSE 121846
121742: GO 121744
121744: DISABLE
121745: LD_INT 0
121747: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121748: LD_ADDR_VAR 0 1
121752: PUSH
121753: LD_INT 22
121755: PUSH
121756: LD_OWVAR 2
121760: PUSH
121761: EMPTY
121762: LIST
121763: LIST
121764: PUSH
121765: LD_INT 2
121767: PUSH
121768: LD_INT 30
121770: PUSH
121771: LD_INT 0
121773: PUSH
121774: EMPTY
121775: LIST
121776: LIST
121777: PUSH
121778: LD_INT 30
121780: PUSH
121781: LD_INT 1
121783: PUSH
121784: EMPTY
121785: LIST
121786: LIST
121787: PUSH
121788: EMPTY
121789: LIST
121790: LIST
121791: LIST
121792: PUSH
121793: EMPTY
121794: LIST
121795: LIST
121796: PPUSH
121797: CALL_OW 69
121801: ST_TO_ADDR
// if not depot then
121802: LD_VAR 0 1
121806: NOT
121807: IFFALSE 121811
// exit ;
121809: GO 121846
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
121811: LD_VAR 0 1
121815: PUSH
121816: LD_INT 1
121818: ARRAY
121819: PPUSH
121820: CALL_OW 250
121824: PPUSH
121825: LD_VAR 0 1
121829: PUSH
121830: LD_INT 1
121832: ARRAY
121833: PPUSH
121834: CALL_OW 251
121838: PPUSH
121839: LD_INT 70
121841: PPUSH
121842: CALL_OW 495
// end ;
121846: PPOPN 1
121848: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
121849: LD_EXP 148
121853: PUSH
121854: LD_EXP 182
121858: AND
121859: IFFALSE 122070
121861: GO 121863
121863: DISABLE
121864: LD_INT 0
121866: PPUSH
121867: PPUSH
121868: PPUSH
121869: PPUSH
121870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121871: LD_ADDR_VAR 0 5
121875: PUSH
121876: LD_INT 22
121878: PUSH
121879: LD_OWVAR 2
121883: PUSH
121884: EMPTY
121885: LIST
121886: LIST
121887: PUSH
121888: LD_INT 21
121890: PUSH
121891: LD_INT 1
121893: PUSH
121894: EMPTY
121895: LIST
121896: LIST
121897: PUSH
121898: EMPTY
121899: LIST
121900: LIST
121901: PPUSH
121902: CALL_OW 69
121906: ST_TO_ADDR
// if not tmp then
121907: LD_VAR 0 5
121911: NOT
121912: IFFALSE 121916
// exit ;
121914: GO 122070
// for i in tmp do
121916: LD_ADDR_VAR 0 1
121920: PUSH
121921: LD_VAR 0 5
121925: PUSH
121926: FOR_IN
121927: IFFALSE 122068
// begin d := rand ( 0 , 5 ) ;
121929: LD_ADDR_VAR 0 4
121933: PUSH
121934: LD_INT 0
121936: PPUSH
121937: LD_INT 5
121939: PPUSH
121940: CALL_OW 12
121944: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
121945: LD_ADDR_VAR 0 2
121949: PUSH
121950: LD_VAR 0 1
121954: PPUSH
121955: CALL_OW 250
121959: PPUSH
121960: LD_VAR 0 4
121964: PPUSH
121965: LD_INT 3
121967: PPUSH
121968: LD_INT 12
121970: PPUSH
121971: CALL_OW 12
121975: PPUSH
121976: CALL_OW 272
121980: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
121981: LD_ADDR_VAR 0 3
121985: PUSH
121986: LD_VAR 0 1
121990: PPUSH
121991: CALL_OW 251
121995: PPUSH
121996: LD_VAR 0 4
122000: PPUSH
122001: LD_INT 3
122003: PPUSH
122004: LD_INT 12
122006: PPUSH
122007: CALL_OW 12
122011: PPUSH
122012: CALL_OW 273
122016: ST_TO_ADDR
// if ValidHex ( x , y ) then
122017: LD_VAR 0 2
122021: PPUSH
122022: LD_VAR 0 3
122026: PPUSH
122027: CALL_OW 488
122031: IFFALSE 122066
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
122033: LD_VAR 0 1
122037: PPUSH
122038: LD_VAR 0 2
122042: PPUSH
122043: LD_VAR 0 3
122047: PPUSH
122048: LD_INT 3
122050: PPUSH
122051: LD_INT 6
122053: PPUSH
122054: CALL_OW 12
122058: PPUSH
122059: LD_INT 1
122061: PPUSH
122062: CALL_OW 483
// end ;
122066: GO 121926
122068: POP
122069: POP
// end ;
122070: PPOPN 5
122072: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
122073: LD_EXP 148
122077: PUSH
122078: LD_EXP 183
122082: AND
122083: IFFALSE 122177
122085: GO 122087
122087: DISABLE
122088: LD_INT 0
122090: PPUSH
122091: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
122092: LD_ADDR_VAR 0 2
122096: PUSH
122097: LD_INT 22
122099: PUSH
122100: LD_OWVAR 2
122104: PUSH
122105: EMPTY
122106: LIST
122107: LIST
122108: PUSH
122109: LD_INT 32
122111: PUSH
122112: LD_INT 1
122114: PUSH
122115: EMPTY
122116: LIST
122117: LIST
122118: PUSH
122119: LD_INT 21
122121: PUSH
122122: LD_INT 2
122124: PUSH
122125: EMPTY
122126: LIST
122127: LIST
122128: PUSH
122129: EMPTY
122130: LIST
122131: LIST
122132: LIST
122133: PPUSH
122134: CALL_OW 69
122138: ST_TO_ADDR
// if not tmp then
122139: LD_VAR 0 2
122143: NOT
122144: IFFALSE 122148
// exit ;
122146: GO 122177
// for i in tmp do
122148: LD_ADDR_VAR 0 1
122152: PUSH
122153: LD_VAR 0 2
122157: PUSH
122158: FOR_IN
122159: IFFALSE 122175
// SetFuel ( i , 0 ) ;
122161: LD_VAR 0 1
122165: PPUSH
122166: LD_INT 0
122168: PPUSH
122169: CALL_OW 240
122173: GO 122158
122175: POP
122176: POP
// end ;
122177: PPOPN 2
122179: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
122180: LD_EXP 148
122184: PUSH
122185: LD_EXP 184
122189: AND
122190: IFFALSE 122256
122192: GO 122194
122194: DISABLE
122195: LD_INT 0
122197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
122198: LD_ADDR_VAR 0 1
122202: PUSH
122203: LD_INT 22
122205: PUSH
122206: LD_OWVAR 2
122210: PUSH
122211: EMPTY
122212: LIST
122213: LIST
122214: PUSH
122215: LD_INT 30
122217: PUSH
122218: LD_INT 29
122220: PUSH
122221: EMPTY
122222: LIST
122223: LIST
122224: PUSH
122225: EMPTY
122226: LIST
122227: LIST
122228: PPUSH
122229: CALL_OW 69
122233: ST_TO_ADDR
// if not tmp then
122234: LD_VAR 0 1
122238: NOT
122239: IFFALSE 122243
// exit ;
122241: GO 122256
// DestroyUnit ( tmp [ 1 ] ) ;
122243: LD_VAR 0 1
122247: PUSH
122248: LD_INT 1
122250: ARRAY
122251: PPUSH
122252: CALL_OW 65
// end ;
122256: PPOPN 1
122258: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
122259: LD_EXP 148
122263: PUSH
122264: LD_EXP 186
122268: AND
122269: IFFALSE 122398
122271: GO 122273
122273: DISABLE
122274: LD_INT 0
122276: PPUSH
// begin uc_side := 0 ;
122277: LD_ADDR_OWVAR 20
122281: PUSH
122282: LD_INT 0
122284: ST_TO_ADDR
// uc_nation := nation_arabian ;
122285: LD_ADDR_OWVAR 21
122289: PUSH
122290: LD_INT 2
122292: ST_TO_ADDR
// hc_gallery :=  ;
122293: LD_ADDR_OWVAR 33
122297: PUSH
122298: LD_STRING 
122300: ST_TO_ADDR
// hc_name :=  ;
122301: LD_ADDR_OWVAR 26
122305: PUSH
122306: LD_STRING 
122308: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
122309: LD_INT 1
122311: PPUSH
122312: LD_INT 11
122314: PPUSH
122315: LD_INT 10
122317: PPUSH
122318: CALL_OW 380
// un := CreateHuman ;
122322: LD_ADDR_VAR 0 1
122326: PUSH
122327: CALL_OW 44
122331: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122332: LD_VAR 0 1
122336: PPUSH
122337: LD_INT 1
122339: PPUSH
122340: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
122344: LD_INT 35
122346: PPUSH
122347: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
122351: LD_VAR 0 1
122355: PPUSH
122356: LD_INT 22
122358: PUSH
122359: LD_OWVAR 2
122363: PUSH
122364: EMPTY
122365: LIST
122366: LIST
122367: PPUSH
122368: CALL_OW 69
122372: PPUSH
122373: LD_VAR 0 1
122377: PPUSH
122378: CALL_OW 74
122382: PPUSH
122383: CALL_OW 115
// until IsDead ( un ) ;
122387: LD_VAR 0 1
122391: PPUSH
122392: CALL_OW 301
122396: IFFALSE 122344
// end ;
122398: PPOPN 1
122400: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
122401: LD_EXP 148
122405: PUSH
122406: LD_EXP 188
122410: AND
122411: IFFALSE 122423
122413: GO 122415
122415: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
122416: LD_STRING earthquake(getX(game), 0, 32)
122418: PPUSH
122419: CALL_OW 559
122423: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
122424: LD_EXP 148
122428: PUSH
122429: LD_EXP 189
122433: AND
122434: IFFALSE 122525
122436: GO 122438
122438: DISABLE
122439: LD_INT 0
122441: PPUSH
// begin enable ;
122442: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
122443: LD_ADDR_VAR 0 1
122447: PUSH
122448: LD_INT 22
122450: PUSH
122451: LD_OWVAR 2
122455: PUSH
122456: EMPTY
122457: LIST
122458: LIST
122459: PUSH
122460: LD_INT 21
122462: PUSH
122463: LD_INT 2
122465: PUSH
122466: EMPTY
122467: LIST
122468: LIST
122469: PUSH
122470: LD_INT 33
122472: PUSH
122473: LD_INT 3
122475: PUSH
122476: EMPTY
122477: LIST
122478: LIST
122479: PUSH
122480: EMPTY
122481: LIST
122482: LIST
122483: LIST
122484: PPUSH
122485: CALL_OW 69
122489: ST_TO_ADDR
// if not tmp then
122490: LD_VAR 0 1
122494: NOT
122495: IFFALSE 122499
// exit ;
122497: GO 122525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
122499: LD_VAR 0 1
122503: PUSH
122504: LD_INT 1
122506: PPUSH
122507: LD_VAR 0 1
122511: PPUSH
122512: CALL_OW 12
122516: ARRAY
122517: PPUSH
122518: LD_INT 1
122520: PPUSH
122521: CALL_OW 234
// end ;
122525: PPOPN 1
122527: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
122528: LD_EXP 148
122532: PUSH
122533: LD_EXP 190
122537: AND
122538: IFFALSE 122679
122540: GO 122542
122542: DISABLE
122543: LD_INT 0
122545: PPUSH
122546: PPUSH
122547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122548: LD_ADDR_VAR 0 3
122552: PUSH
122553: LD_INT 22
122555: PUSH
122556: LD_OWVAR 2
122560: PUSH
122561: EMPTY
122562: LIST
122563: LIST
122564: PUSH
122565: LD_INT 25
122567: PUSH
122568: LD_INT 1
122570: PUSH
122571: EMPTY
122572: LIST
122573: LIST
122574: PUSH
122575: EMPTY
122576: LIST
122577: LIST
122578: PPUSH
122579: CALL_OW 69
122583: ST_TO_ADDR
// if not tmp then
122584: LD_VAR 0 3
122588: NOT
122589: IFFALSE 122593
// exit ;
122591: GO 122679
// un := tmp [ rand ( 1 , tmp ) ] ;
122593: LD_ADDR_VAR 0 2
122597: PUSH
122598: LD_VAR 0 3
122602: PUSH
122603: LD_INT 1
122605: PPUSH
122606: LD_VAR 0 3
122610: PPUSH
122611: CALL_OW 12
122615: ARRAY
122616: ST_TO_ADDR
// if Crawls ( un ) then
122617: LD_VAR 0 2
122621: PPUSH
122622: CALL_OW 318
122626: IFFALSE 122637
// ComWalk ( un ) ;
122628: LD_VAR 0 2
122632: PPUSH
122633: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
122637: LD_VAR 0 2
122641: PPUSH
122642: LD_INT 9
122644: PPUSH
122645: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
122649: LD_INT 28
122651: PPUSH
122652: LD_OWVAR 2
122656: PPUSH
122657: LD_INT 2
122659: PPUSH
122660: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
122664: LD_INT 29
122666: PPUSH
122667: LD_OWVAR 2
122671: PPUSH
122672: LD_INT 2
122674: PPUSH
122675: CALL_OW 322
// end ;
122679: PPOPN 3
122681: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
122682: LD_EXP 148
122686: PUSH
122687: LD_EXP 191
122691: AND
122692: IFFALSE 122803
122694: GO 122696
122696: DISABLE
122697: LD_INT 0
122699: PPUSH
122700: PPUSH
122701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122702: LD_ADDR_VAR 0 3
122706: PUSH
122707: LD_INT 22
122709: PUSH
122710: LD_OWVAR 2
122714: PUSH
122715: EMPTY
122716: LIST
122717: LIST
122718: PUSH
122719: LD_INT 25
122721: PUSH
122722: LD_INT 1
122724: PUSH
122725: EMPTY
122726: LIST
122727: LIST
122728: PUSH
122729: EMPTY
122730: LIST
122731: LIST
122732: PPUSH
122733: CALL_OW 69
122737: ST_TO_ADDR
// if not tmp then
122738: LD_VAR 0 3
122742: NOT
122743: IFFALSE 122747
// exit ;
122745: GO 122803
// un := tmp [ rand ( 1 , tmp ) ] ;
122747: LD_ADDR_VAR 0 2
122751: PUSH
122752: LD_VAR 0 3
122756: PUSH
122757: LD_INT 1
122759: PPUSH
122760: LD_VAR 0 3
122764: PPUSH
122765: CALL_OW 12
122769: ARRAY
122770: ST_TO_ADDR
// if Crawls ( un ) then
122771: LD_VAR 0 2
122775: PPUSH
122776: CALL_OW 318
122780: IFFALSE 122791
// ComWalk ( un ) ;
122782: LD_VAR 0 2
122786: PPUSH
122787: CALL_OW 138
// SetClass ( un , class_mortar ) ;
122791: LD_VAR 0 2
122795: PPUSH
122796: LD_INT 8
122798: PPUSH
122799: CALL_OW 336
// end ;
122803: PPOPN 3
122805: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
122806: LD_EXP 148
122810: PUSH
122811: LD_EXP 192
122815: AND
122816: IFFALSE 122960
122818: GO 122820
122820: DISABLE
122821: LD_INT 0
122823: PPUSH
122824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
122825: LD_ADDR_VAR 0 2
122829: PUSH
122830: LD_INT 22
122832: PUSH
122833: LD_OWVAR 2
122837: PUSH
122838: EMPTY
122839: LIST
122840: LIST
122841: PUSH
122842: LD_INT 21
122844: PUSH
122845: LD_INT 2
122847: PUSH
122848: EMPTY
122849: LIST
122850: LIST
122851: PUSH
122852: LD_INT 2
122854: PUSH
122855: LD_INT 34
122857: PUSH
122858: LD_INT 12
122860: PUSH
122861: EMPTY
122862: LIST
122863: LIST
122864: PUSH
122865: LD_INT 34
122867: PUSH
122868: LD_INT 51
122870: PUSH
122871: EMPTY
122872: LIST
122873: LIST
122874: PUSH
122875: LD_INT 34
122877: PUSH
122878: LD_INT 32
122880: PUSH
122881: EMPTY
122882: LIST
122883: LIST
122884: PUSH
122885: EMPTY
122886: LIST
122887: LIST
122888: LIST
122889: LIST
122890: PUSH
122891: EMPTY
122892: LIST
122893: LIST
122894: LIST
122895: PPUSH
122896: CALL_OW 69
122900: ST_TO_ADDR
// if not tmp then
122901: LD_VAR 0 2
122905: NOT
122906: IFFALSE 122910
// exit ;
122908: GO 122960
// for i in tmp do
122910: LD_ADDR_VAR 0 1
122914: PUSH
122915: LD_VAR 0 2
122919: PUSH
122920: FOR_IN
122921: IFFALSE 122958
// if GetCargo ( i , mat_artifact ) = 0 then
122923: LD_VAR 0 1
122927: PPUSH
122928: LD_INT 4
122930: PPUSH
122931: CALL_OW 289
122935: PUSH
122936: LD_INT 0
122938: EQUAL
122939: IFFALSE 122956
// SetCargo ( i , mat_siberit , 100 ) ;
122941: LD_VAR 0 1
122945: PPUSH
122946: LD_INT 3
122948: PPUSH
122949: LD_INT 100
122951: PPUSH
122952: CALL_OW 290
122956: GO 122920
122958: POP
122959: POP
// end ;
122960: PPOPN 2
122962: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
122963: LD_EXP 148
122967: PUSH
122968: LD_EXP 193
122972: AND
122973: IFFALSE 123156
122975: GO 122977
122977: DISABLE
122978: LD_INT 0
122980: PPUSH
122981: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122982: LD_ADDR_VAR 0 2
122986: PUSH
122987: LD_INT 22
122989: PUSH
122990: LD_OWVAR 2
122994: PUSH
122995: EMPTY
122996: LIST
122997: LIST
122998: PPUSH
122999: CALL_OW 69
123003: ST_TO_ADDR
// if not tmp then
123004: LD_VAR 0 2
123008: NOT
123009: IFFALSE 123013
// exit ;
123011: GO 123156
// for i := 1 to 2 do
123013: LD_ADDR_VAR 0 1
123017: PUSH
123018: DOUBLE
123019: LD_INT 1
123021: DEC
123022: ST_TO_ADDR
123023: LD_INT 2
123025: PUSH
123026: FOR_TO
123027: IFFALSE 123154
// begin uc_side := your_side ;
123029: LD_ADDR_OWVAR 20
123033: PUSH
123034: LD_OWVAR 2
123038: ST_TO_ADDR
// uc_nation := nation_american ;
123039: LD_ADDR_OWVAR 21
123043: PUSH
123044: LD_INT 1
123046: ST_TO_ADDR
// vc_chassis := us_morphling ;
123047: LD_ADDR_OWVAR 37
123051: PUSH
123052: LD_INT 5
123054: ST_TO_ADDR
// vc_engine := engine_siberite ;
123055: LD_ADDR_OWVAR 39
123059: PUSH
123060: LD_INT 3
123062: ST_TO_ADDR
// vc_control := control_computer ;
123063: LD_ADDR_OWVAR 38
123067: PUSH
123068: LD_INT 3
123070: ST_TO_ADDR
// vc_weapon := us_double_laser ;
123071: LD_ADDR_OWVAR 40
123075: PUSH
123076: LD_INT 10
123078: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
123079: LD_VAR 0 2
123083: PUSH
123084: LD_INT 1
123086: ARRAY
123087: PPUSH
123088: CALL_OW 310
123092: NOT
123093: IFFALSE 123140
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
123095: CALL_OW 45
123099: PPUSH
123100: LD_VAR 0 2
123104: PUSH
123105: LD_INT 1
123107: ARRAY
123108: PPUSH
123109: CALL_OW 250
123113: PPUSH
123114: LD_VAR 0 2
123118: PUSH
123119: LD_INT 1
123121: ARRAY
123122: PPUSH
123123: CALL_OW 251
123127: PPUSH
123128: LD_INT 12
123130: PPUSH
123131: LD_INT 1
123133: PPUSH
123134: CALL_OW 50
123138: GO 123152
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
123140: CALL_OW 45
123144: PPUSH
123145: LD_INT 1
123147: PPUSH
123148: CALL_OW 51
// end ;
123152: GO 123026
123154: POP
123155: POP
// end ;
123156: PPOPN 2
123158: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
123159: LD_EXP 148
123163: PUSH
123164: LD_EXP 194
123168: AND
123169: IFFALSE 123391
123171: GO 123173
123173: DISABLE
123174: LD_INT 0
123176: PPUSH
123177: PPUSH
123178: PPUSH
123179: PPUSH
123180: PPUSH
123181: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123182: LD_ADDR_VAR 0 6
123186: PUSH
123187: LD_INT 22
123189: PUSH
123190: LD_OWVAR 2
123194: PUSH
123195: EMPTY
123196: LIST
123197: LIST
123198: PUSH
123199: LD_INT 21
123201: PUSH
123202: LD_INT 1
123204: PUSH
123205: EMPTY
123206: LIST
123207: LIST
123208: PUSH
123209: LD_INT 3
123211: PUSH
123212: LD_INT 23
123214: PUSH
123215: LD_INT 0
123217: PUSH
123218: EMPTY
123219: LIST
123220: LIST
123221: PUSH
123222: EMPTY
123223: LIST
123224: LIST
123225: PUSH
123226: EMPTY
123227: LIST
123228: LIST
123229: LIST
123230: PPUSH
123231: CALL_OW 69
123235: ST_TO_ADDR
// if not tmp then
123236: LD_VAR 0 6
123240: NOT
123241: IFFALSE 123245
// exit ;
123243: GO 123391
// s1 := rand ( 1 , 4 ) ;
123245: LD_ADDR_VAR 0 2
123249: PUSH
123250: LD_INT 1
123252: PPUSH
123253: LD_INT 4
123255: PPUSH
123256: CALL_OW 12
123260: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
123261: LD_ADDR_VAR 0 4
123265: PUSH
123266: LD_VAR 0 6
123270: PUSH
123271: LD_INT 1
123273: ARRAY
123274: PPUSH
123275: LD_VAR 0 2
123279: PPUSH
123280: CALL_OW 259
123284: ST_TO_ADDR
// if s1 = 1 then
123285: LD_VAR 0 2
123289: PUSH
123290: LD_INT 1
123292: EQUAL
123293: IFFALSE 123313
// s2 := rand ( 2 , 4 ) else
123295: LD_ADDR_VAR 0 3
123299: PUSH
123300: LD_INT 2
123302: PPUSH
123303: LD_INT 4
123305: PPUSH
123306: CALL_OW 12
123310: ST_TO_ADDR
123311: GO 123321
// s2 := 1 ;
123313: LD_ADDR_VAR 0 3
123317: PUSH
123318: LD_INT 1
123320: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
123321: LD_ADDR_VAR 0 5
123325: PUSH
123326: LD_VAR 0 6
123330: PUSH
123331: LD_INT 1
123333: ARRAY
123334: PPUSH
123335: LD_VAR 0 3
123339: PPUSH
123340: CALL_OW 259
123344: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
123345: LD_VAR 0 6
123349: PUSH
123350: LD_INT 1
123352: ARRAY
123353: PPUSH
123354: LD_VAR 0 2
123358: PPUSH
123359: LD_VAR 0 5
123363: PPUSH
123364: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
123368: LD_VAR 0 6
123372: PUSH
123373: LD_INT 1
123375: ARRAY
123376: PPUSH
123377: LD_VAR 0 3
123381: PPUSH
123382: LD_VAR 0 4
123386: PPUSH
123387: CALL_OW 237
// end ;
123391: PPOPN 6
123393: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
123394: LD_EXP 148
123398: PUSH
123399: LD_EXP 195
123403: AND
123404: IFFALSE 123483
123406: GO 123408
123408: DISABLE
123409: LD_INT 0
123411: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
123412: LD_ADDR_VAR 0 1
123416: PUSH
123417: LD_INT 22
123419: PUSH
123420: LD_OWVAR 2
123424: PUSH
123425: EMPTY
123426: LIST
123427: LIST
123428: PUSH
123429: LD_INT 30
123431: PUSH
123432: LD_INT 3
123434: PUSH
123435: EMPTY
123436: LIST
123437: LIST
123438: PUSH
123439: EMPTY
123440: LIST
123441: LIST
123442: PPUSH
123443: CALL_OW 69
123447: ST_TO_ADDR
// if not tmp then
123448: LD_VAR 0 1
123452: NOT
123453: IFFALSE 123457
// exit ;
123455: GO 123483
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
123457: LD_VAR 0 1
123461: PUSH
123462: LD_INT 1
123464: PPUSH
123465: LD_VAR 0 1
123469: PPUSH
123470: CALL_OW 12
123474: ARRAY
123475: PPUSH
123476: LD_INT 1
123478: PPUSH
123479: CALL_OW 234
// end ;
123483: PPOPN 1
123485: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
123486: LD_EXP 148
123490: PUSH
123491: LD_EXP 196
123495: AND
123496: IFFALSE 123608
123498: GO 123500
123500: DISABLE
123501: LD_INT 0
123503: PPUSH
123504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
123505: LD_ADDR_VAR 0 2
123509: PUSH
123510: LD_INT 22
123512: PUSH
123513: LD_OWVAR 2
123517: PUSH
123518: EMPTY
123519: LIST
123520: LIST
123521: PUSH
123522: LD_INT 2
123524: PUSH
123525: LD_INT 30
123527: PUSH
123528: LD_INT 27
123530: PUSH
123531: EMPTY
123532: LIST
123533: LIST
123534: PUSH
123535: LD_INT 30
123537: PUSH
123538: LD_INT 26
123540: PUSH
123541: EMPTY
123542: LIST
123543: LIST
123544: PUSH
123545: LD_INT 30
123547: PUSH
123548: LD_INT 28
123550: PUSH
123551: EMPTY
123552: LIST
123553: LIST
123554: PUSH
123555: EMPTY
123556: LIST
123557: LIST
123558: LIST
123559: LIST
123560: PUSH
123561: EMPTY
123562: LIST
123563: LIST
123564: PPUSH
123565: CALL_OW 69
123569: ST_TO_ADDR
// if not tmp then
123570: LD_VAR 0 2
123574: NOT
123575: IFFALSE 123579
// exit ;
123577: GO 123608
// for i in tmp do
123579: LD_ADDR_VAR 0 1
123583: PUSH
123584: LD_VAR 0 2
123588: PUSH
123589: FOR_IN
123590: IFFALSE 123606
// SetLives ( i , 1 ) ;
123592: LD_VAR 0 1
123596: PPUSH
123597: LD_INT 1
123599: PPUSH
123600: CALL_OW 234
123604: GO 123589
123606: POP
123607: POP
// end ;
123608: PPOPN 2
123610: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
123611: LD_EXP 148
123615: PUSH
123616: LD_EXP 197
123620: AND
123621: IFFALSE 123908
123623: GO 123625
123625: DISABLE
123626: LD_INT 0
123628: PPUSH
123629: PPUSH
123630: PPUSH
// begin i := rand ( 1 , 7 ) ;
123631: LD_ADDR_VAR 0 1
123635: PUSH
123636: LD_INT 1
123638: PPUSH
123639: LD_INT 7
123641: PPUSH
123642: CALL_OW 12
123646: ST_TO_ADDR
// case i of 1 :
123647: LD_VAR 0 1
123651: PUSH
123652: LD_INT 1
123654: DOUBLE
123655: EQUAL
123656: IFTRUE 123660
123658: GO 123670
123660: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
123661: LD_STRING earthquake(getX(game), 0, 32)
123663: PPUSH
123664: CALL_OW 559
123668: GO 123908
123670: LD_INT 2
123672: DOUBLE
123673: EQUAL
123674: IFTRUE 123678
123676: GO 123692
123678: POP
// begin ToLua ( displayStucuk(); ) ;
123679: LD_STRING displayStucuk();
123681: PPUSH
123682: CALL_OW 559
// ResetFog ;
123686: CALL_OW 335
// end ; 3 :
123690: GO 123908
123692: LD_INT 3
123694: DOUBLE
123695: EQUAL
123696: IFTRUE 123700
123698: GO 123804
123700: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
123701: LD_ADDR_VAR 0 2
123705: PUSH
123706: LD_INT 22
123708: PUSH
123709: LD_OWVAR 2
123713: PUSH
123714: EMPTY
123715: LIST
123716: LIST
123717: PUSH
123718: LD_INT 25
123720: PUSH
123721: LD_INT 1
123723: PUSH
123724: EMPTY
123725: LIST
123726: LIST
123727: PUSH
123728: EMPTY
123729: LIST
123730: LIST
123731: PPUSH
123732: CALL_OW 69
123736: ST_TO_ADDR
// if not tmp then
123737: LD_VAR 0 2
123741: NOT
123742: IFFALSE 123746
// exit ;
123744: GO 123908
// un := tmp [ rand ( 1 , tmp ) ] ;
123746: LD_ADDR_VAR 0 3
123750: PUSH
123751: LD_VAR 0 2
123755: PUSH
123756: LD_INT 1
123758: PPUSH
123759: LD_VAR 0 2
123763: PPUSH
123764: CALL_OW 12
123768: ARRAY
123769: ST_TO_ADDR
// if Crawls ( un ) then
123770: LD_VAR 0 3
123774: PPUSH
123775: CALL_OW 318
123779: IFFALSE 123790
// ComWalk ( un ) ;
123781: LD_VAR 0 3
123785: PPUSH
123786: CALL_OW 138
// SetClass ( un , class_mortar ) ;
123790: LD_VAR 0 3
123794: PPUSH
123795: LD_INT 8
123797: PPUSH
123798: CALL_OW 336
// end ; 4 :
123802: GO 123908
123804: LD_INT 4
123806: DOUBLE
123807: EQUAL
123808: IFTRUE 123812
123810: GO 123886
123812: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
123813: LD_ADDR_VAR 0 2
123817: PUSH
123818: LD_INT 22
123820: PUSH
123821: LD_OWVAR 2
123825: PUSH
123826: EMPTY
123827: LIST
123828: LIST
123829: PUSH
123830: LD_INT 30
123832: PUSH
123833: LD_INT 29
123835: PUSH
123836: EMPTY
123837: LIST
123838: LIST
123839: PUSH
123840: EMPTY
123841: LIST
123842: LIST
123843: PPUSH
123844: CALL_OW 69
123848: ST_TO_ADDR
// if not tmp then
123849: LD_VAR 0 2
123853: NOT
123854: IFFALSE 123858
// exit ;
123856: GO 123908
// CenterNowOnUnits ( tmp [ 1 ] ) ;
123858: LD_VAR 0 2
123862: PUSH
123863: LD_INT 1
123865: ARRAY
123866: PPUSH
123867: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
123871: LD_VAR 0 2
123875: PUSH
123876: LD_INT 1
123878: ARRAY
123879: PPUSH
123880: CALL_OW 65
// end ; 5 .. 7 :
123884: GO 123908
123886: LD_INT 5
123888: DOUBLE
123889: GREATEREQUAL
123890: IFFALSE 123898
123892: LD_INT 7
123894: DOUBLE
123895: LESSEQUAL
123896: IFTRUE 123900
123898: GO 123907
123900: POP
// StreamSibBomb ; end ;
123901: CALL 120145 0 0
123905: GO 123908
123907: POP
// end ;
123908: PPOPN 3
123910: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
123911: LD_EXP 148
123915: PUSH
123916: LD_EXP 198
123920: AND
123921: IFFALSE 124077
123923: GO 123925
123925: DISABLE
123926: LD_INT 0
123928: PPUSH
123929: PPUSH
123930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
123931: LD_ADDR_VAR 0 2
123935: PUSH
123936: LD_INT 81
123938: PUSH
123939: LD_OWVAR 2
123943: PUSH
123944: EMPTY
123945: LIST
123946: LIST
123947: PUSH
123948: LD_INT 2
123950: PUSH
123951: LD_INT 21
123953: PUSH
123954: LD_INT 1
123956: PUSH
123957: EMPTY
123958: LIST
123959: LIST
123960: PUSH
123961: LD_INT 21
123963: PUSH
123964: LD_INT 2
123966: PUSH
123967: EMPTY
123968: LIST
123969: LIST
123970: PUSH
123971: EMPTY
123972: LIST
123973: LIST
123974: LIST
123975: PUSH
123976: EMPTY
123977: LIST
123978: LIST
123979: PPUSH
123980: CALL_OW 69
123984: ST_TO_ADDR
// if not tmp then
123985: LD_VAR 0 2
123989: NOT
123990: IFFALSE 123994
// exit ;
123992: GO 124077
// p := 0 ;
123994: LD_ADDR_VAR 0 3
123998: PUSH
123999: LD_INT 0
124001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124002: LD_INT 35
124004: PPUSH
124005: CALL_OW 67
// p := p + 1 ;
124009: LD_ADDR_VAR 0 3
124013: PUSH
124014: LD_VAR 0 3
124018: PUSH
124019: LD_INT 1
124021: PLUS
124022: ST_TO_ADDR
// for i in tmp do
124023: LD_ADDR_VAR 0 1
124027: PUSH
124028: LD_VAR 0 2
124032: PUSH
124033: FOR_IN
124034: IFFALSE 124065
// if GetLives ( i ) < 1000 then
124036: LD_VAR 0 1
124040: PPUSH
124041: CALL_OW 256
124045: PUSH
124046: LD_INT 1000
124048: LESS
124049: IFFALSE 124063
// SetLives ( i , 1000 ) ;
124051: LD_VAR 0 1
124055: PPUSH
124056: LD_INT 1000
124058: PPUSH
124059: CALL_OW 234
124063: GO 124033
124065: POP
124066: POP
// until p > 20 ;
124067: LD_VAR 0 3
124071: PUSH
124072: LD_INT 20
124074: GREATER
124075: IFFALSE 124002
// end ;
124077: PPOPN 3
124079: END
// every 0 0$1 trigger StreamModeActive and sTime do
124080: LD_EXP 148
124084: PUSH
124085: LD_EXP 199
124089: AND
124090: IFFALSE 124125
124092: GO 124094
124094: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
124095: LD_INT 28
124097: PPUSH
124098: LD_OWVAR 2
124102: PPUSH
124103: LD_INT 2
124105: PPUSH
124106: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
124110: LD_INT 30
124112: PPUSH
124113: LD_OWVAR 2
124117: PPUSH
124118: LD_INT 2
124120: PPUSH
124121: CALL_OW 322
// end ;
124125: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
124126: LD_EXP 148
124130: PUSH
124131: LD_EXP 200
124135: AND
124136: IFFALSE 124257
124138: GO 124140
124140: DISABLE
124141: LD_INT 0
124143: PPUSH
124144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
124145: LD_ADDR_VAR 0 2
124149: PUSH
124150: LD_INT 22
124152: PUSH
124153: LD_OWVAR 2
124157: PUSH
124158: EMPTY
124159: LIST
124160: LIST
124161: PUSH
124162: LD_INT 21
124164: PUSH
124165: LD_INT 1
124167: PUSH
124168: EMPTY
124169: LIST
124170: LIST
124171: PUSH
124172: LD_INT 3
124174: PUSH
124175: LD_INT 23
124177: PUSH
124178: LD_INT 0
124180: PUSH
124181: EMPTY
124182: LIST
124183: LIST
124184: PUSH
124185: EMPTY
124186: LIST
124187: LIST
124188: PUSH
124189: EMPTY
124190: LIST
124191: LIST
124192: LIST
124193: PPUSH
124194: CALL_OW 69
124198: ST_TO_ADDR
// if not tmp then
124199: LD_VAR 0 2
124203: NOT
124204: IFFALSE 124208
// exit ;
124206: GO 124257
// for i in tmp do
124208: LD_ADDR_VAR 0 1
124212: PUSH
124213: LD_VAR 0 2
124217: PUSH
124218: FOR_IN
124219: IFFALSE 124255
// begin if Crawls ( i ) then
124221: LD_VAR 0 1
124225: PPUSH
124226: CALL_OW 318
124230: IFFALSE 124241
// ComWalk ( i ) ;
124232: LD_VAR 0 1
124236: PPUSH
124237: CALL_OW 138
// SetClass ( i , 2 ) ;
124241: LD_VAR 0 1
124245: PPUSH
124246: LD_INT 2
124248: PPUSH
124249: CALL_OW 336
// end ;
124253: GO 124218
124255: POP
124256: POP
// end ;
124257: PPOPN 2
124259: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
124260: LD_EXP 148
124264: PUSH
124265: LD_EXP 201
124269: AND
124270: IFFALSE 124558
124272: GO 124274
124274: DISABLE
124275: LD_INT 0
124277: PPUSH
124278: PPUSH
124279: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
124280: LD_OWVAR 2
124284: PPUSH
124285: LD_INT 9
124287: PPUSH
124288: LD_INT 1
124290: PPUSH
124291: LD_INT 1
124293: PPUSH
124294: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
124298: LD_INT 9
124300: PPUSH
124301: LD_OWVAR 2
124305: PPUSH
124306: CALL_OW 343
// uc_side := 9 ;
124310: LD_ADDR_OWVAR 20
124314: PUSH
124315: LD_INT 9
124317: ST_TO_ADDR
// uc_nation := 2 ;
124318: LD_ADDR_OWVAR 21
124322: PUSH
124323: LD_INT 2
124325: ST_TO_ADDR
// hc_name := Dark Warrior ;
124326: LD_ADDR_OWVAR 26
124330: PUSH
124331: LD_STRING Dark Warrior
124333: ST_TO_ADDR
// hc_gallery :=  ;
124334: LD_ADDR_OWVAR 33
124338: PUSH
124339: LD_STRING 
124341: ST_TO_ADDR
// hc_noskilllimit := true ;
124342: LD_ADDR_OWVAR 76
124346: PUSH
124347: LD_INT 1
124349: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
124350: LD_ADDR_OWVAR 31
124354: PUSH
124355: LD_INT 30
124357: PUSH
124358: LD_INT 30
124360: PUSH
124361: LD_INT 30
124363: PUSH
124364: LD_INT 30
124366: PUSH
124367: EMPTY
124368: LIST
124369: LIST
124370: LIST
124371: LIST
124372: ST_TO_ADDR
// un := CreateHuman ;
124373: LD_ADDR_VAR 0 3
124377: PUSH
124378: CALL_OW 44
124382: ST_TO_ADDR
// hc_noskilllimit := false ;
124383: LD_ADDR_OWVAR 76
124387: PUSH
124388: LD_INT 0
124390: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124391: LD_VAR 0 3
124395: PPUSH
124396: LD_INT 1
124398: PPUSH
124399: CALL_OW 51
// ToLua ( playRanger() ) ;
124403: LD_STRING playRanger()
124405: PPUSH
124406: CALL_OW 559
// p := 0 ;
124410: LD_ADDR_VAR 0 2
124414: PUSH
124415: LD_INT 0
124417: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
124418: LD_INT 35
124420: PPUSH
124421: CALL_OW 67
// p := p + 1 ;
124425: LD_ADDR_VAR 0 2
124429: PUSH
124430: LD_VAR 0 2
124434: PUSH
124435: LD_INT 1
124437: PLUS
124438: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
124439: LD_VAR 0 3
124443: PPUSH
124444: CALL_OW 256
124448: PUSH
124449: LD_INT 1000
124451: LESS
124452: IFFALSE 124466
// SetLives ( un , 1000 ) ;
124454: LD_VAR 0 3
124458: PPUSH
124459: LD_INT 1000
124461: PPUSH
124462: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
124466: LD_VAR 0 3
124470: PPUSH
124471: LD_INT 81
124473: PUSH
124474: LD_OWVAR 2
124478: PUSH
124479: EMPTY
124480: LIST
124481: LIST
124482: PUSH
124483: LD_INT 91
124485: PUSH
124486: LD_VAR 0 3
124490: PUSH
124491: LD_INT 30
124493: PUSH
124494: EMPTY
124495: LIST
124496: LIST
124497: LIST
124498: PUSH
124499: EMPTY
124500: LIST
124501: LIST
124502: PPUSH
124503: CALL_OW 69
124507: PPUSH
124508: LD_VAR 0 3
124512: PPUSH
124513: CALL_OW 74
124517: PPUSH
124518: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
124522: LD_VAR 0 2
124526: PUSH
124527: LD_INT 80
124529: GREATER
124530: PUSH
124531: LD_VAR 0 3
124535: PPUSH
124536: CALL_OW 301
124540: OR
124541: IFFALSE 124418
// if un then
124543: LD_VAR 0 3
124547: IFFALSE 124558
// RemoveUnit ( un ) ;
124549: LD_VAR 0 3
124553: PPUSH
124554: CALL_OW 64
// end ;
124558: PPOPN 3
124560: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
124561: LD_EXP 202
124565: IFFALSE 124681
124567: GO 124569
124569: DISABLE
124570: LD_INT 0
124572: PPUSH
124573: PPUSH
124574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
124575: LD_ADDR_VAR 0 2
124579: PUSH
124580: LD_INT 81
124582: PUSH
124583: LD_OWVAR 2
124587: PUSH
124588: EMPTY
124589: LIST
124590: LIST
124591: PUSH
124592: LD_INT 21
124594: PUSH
124595: LD_INT 1
124597: PUSH
124598: EMPTY
124599: LIST
124600: LIST
124601: PUSH
124602: EMPTY
124603: LIST
124604: LIST
124605: PPUSH
124606: CALL_OW 69
124610: ST_TO_ADDR
// ToLua ( playComputer() ) ;
124611: LD_STRING playComputer()
124613: PPUSH
124614: CALL_OW 559
// if not tmp then
124618: LD_VAR 0 2
124622: NOT
124623: IFFALSE 124627
// exit ;
124625: GO 124681
// for i in tmp do
124627: LD_ADDR_VAR 0 1
124631: PUSH
124632: LD_VAR 0 2
124636: PUSH
124637: FOR_IN
124638: IFFALSE 124679
// for j := 1 to 4 do
124640: LD_ADDR_VAR 0 3
124644: PUSH
124645: DOUBLE
124646: LD_INT 1
124648: DEC
124649: ST_TO_ADDR
124650: LD_INT 4
124652: PUSH
124653: FOR_TO
124654: IFFALSE 124675
// SetSkill ( i , j , 10 ) ;
124656: LD_VAR 0 1
124660: PPUSH
124661: LD_VAR 0 3
124665: PPUSH
124666: LD_INT 10
124668: PPUSH
124669: CALL_OW 237
124673: GO 124653
124675: POP
124676: POP
124677: GO 124637
124679: POP
124680: POP
// end ;
124681: PPOPN 3
124683: END
// every 0 0$1 trigger s30 do var i , tmp ;
124684: LD_EXP 203
124688: IFFALSE 124757
124690: GO 124692
124692: DISABLE
124693: LD_INT 0
124695: PPUSH
124696: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124697: LD_ADDR_VAR 0 2
124701: PUSH
124702: LD_INT 22
124704: PUSH
124705: LD_OWVAR 2
124709: PUSH
124710: EMPTY
124711: LIST
124712: LIST
124713: PPUSH
124714: CALL_OW 69
124718: ST_TO_ADDR
// if not tmp then
124719: LD_VAR 0 2
124723: NOT
124724: IFFALSE 124728
// exit ;
124726: GO 124757
// for i in tmp do
124728: LD_ADDR_VAR 0 1
124732: PUSH
124733: LD_VAR 0 2
124737: PUSH
124738: FOR_IN
124739: IFFALSE 124755
// SetLives ( i , 300 ) ;
124741: LD_VAR 0 1
124745: PPUSH
124746: LD_INT 300
124748: PPUSH
124749: CALL_OW 234
124753: GO 124738
124755: POP
124756: POP
// end ;
124757: PPOPN 2
124759: END
// every 0 0$1 trigger s60 do var i , tmp ;
124760: LD_EXP 204
124764: IFFALSE 124833
124766: GO 124768
124768: DISABLE
124769: LD_INT 0
124771: PPUSH
124772: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
124773: LD_ADDR_VAR 0 2
124777: PUSH
124778: LD_INT 22
124780: PUSH
124781: LD_OWVAR 2
124785: PUSH
124786: EMPTY
124787: LIST
124788: LIST
124789: PPUSH
124790: CALL_OW 69
124794: ST_TO_ADDR
// if not tmp then
124795: LD_VAR 0 2
124799: NOT
124800: IFFALSE 124804
// exit ;
124802: GO 124833
// for i in tmp do
124804: LD_ADDR_VAR 0 1
124808: PUSH
124809: LD_VAR 0 2
124813: PUSH
124814: FOR_IN
124815: IFFALSE 124831
// SetLives ( i , 600 ) ;
124817: LD_VAR 0 1
124821: PPUSH
124822: LD_INT 600
124824: PPUSH
124825: CALL_OW 234
124829: GO 124814
124831: POP
124832: POP
// end ;
124833: PPOPN 2
124835: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
124836: LD_INT 0
124838: PPUSH
// case cmd of 301 :
124839: LD_VAR 0 1
124843: PUSH
124844: LD_INT 301
124846: DOUBLE
124847: EQUAL
124848: IFTRUE 124852
124850: GO 124884
124852: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
124853: LD_VAR 0 6
124857: PPUSH
124858: LD_VAR 0 7
124862: PPUSH
124863: LD_VAR 0 8
124867: PPUSH
124868: LD_VAR 0 4
124872: PPUSH
124873: LD_VAR 0 5
124877: PPUSH
124878: CALL 126093 0 5
124882: GO 125005
124884: LD_INT 302
124886: DOUBLE
124887: EQUAL
124888: IFTRUE 124892
124890: GO 124929
124892: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
124893: LD_VAR 0 6
124897: PPUSH
124898: LD_VAR 0 7
124902: PPUSH
124903: LD_VAR 0 8
124907: PPUSH
124908: LD_VAR 0 9
124912: PPUSH
124913: LD_VAR 0 4
124917: PPUSH
124918: LD_VAR 0 5
124922: PPUSH
124923: CALL 126184 0 6
124927: GO 125005
124929: LD_INT 303
124931: DOUBLE
124932: EQUAL
124933: IFTRUE 124937
124935: GO 124974
124937: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
124938: LD_VAR 0 6
124942: PPUSH
124943: LD_VAR 0 7
124947: PPUSH
124948: LD_VAR 0 8
124952: PPUSH
124953: LD_VAR 0 9
124957: PPUSH
124958: LD_VAR 0 4
124962: PPUSH
124963: LD_VAR 0 5
124967: PPUSH
124968: CALL 125010 0 6
124972: GO 125005
124974: LD_INT 304
124976: DOUBLE
124977: EQUAL
124978: IFTRUE 124982
124980: GO 125004
124982: POP
// hHackTeleport ( unit , x , y ) ; end ;
124983: LD_VAR 0 2
124987: PPUSH
124988: LD_VAR 0 4
124992: PPUSH
124993: LD_VAR 0 5
124997: PPUSH
124998: CALL 126777 0 3
125002: GO 125005
125004: POP
// end ;
125005: LD_VAR 0 12
125009: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
125010: LD_INT 0
125012: PPUSH
125013: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
125014: LD_VAR 0 1
125018: PUSH
125019: LD_INT 1
125021: LESS
125022: PUSH
125023: LD_VAR 0 1
125027: PUSH
125028: LD_INT 3
125030: GREATER
125031: OR
125032: PUSH
125033: LD_VAR 0 5
125037: PPUSH
125038: LD_VAR 0 6
125042: PPUSH
125043: CALL_OW 428
125047: OR
125048: IFFALSE 125052
// exit ;
125050: GO 125780
// uc_side := your_side ;
125052: LD_ADDR_OWVAR 20
125056: PUSH
125057: LD_OWVAR 2
125061: ST_TO_ADDR
// uc_nation := nation ;
125062: LD_ADDR_OWVAR 21
125066: PUSH
125067: LD_VAR 0 1
125071: ST_TO_ADDR
// bc_level = 1 ;
125072: LD_ADDR_OWVAR 43
125076: PUSH
125077: LD_INT 1
125079: ST_TO_ADDR
// case btype of 1 :
125080: LD_VAR 0 2
125084: PUSH
125085: LD_INT 1
125087: DOUBLE
125088: EQUAL
125089: IFTRUE 125093
125091: GO 125104
125093: POP
// bc_type := b_depot ; 2 :
125094: LD_ADDR_OWVAR 42
125098: PUSH
125099: LD_INT 0
125101: ST_TO_ADDR
125102: GO 125724
125104: LD_INT 2
125106: DOUBLE
125107: EQUAL
125108: IFTRUE 125112
125110: GO 125123
125112: POP
// bc_type := b_warehouse ; 3 :
125113: LD_ADDR_OWVAR 42
125117: PUSH
125118: LD_INT 1
125120: ST_TO_ADDR
125121: GO 125724
125123: LD_INT 3
125125: DOUBLE
125126: EQUAL
125127: IFTRUE 125131
125129: GO 125142
125131: POP
// bc_type := b_lab ; 4 .. 9 :
125132: LD_ADDR_OWVAR 42
125136: PUSH
125137: LD_INT 6
125139: ST_TO_ADDR
125140: GO 125724
125142: LD_INT 4
125144: DOUBLE
125145: GREATEREQUAL
125146: IFFALSE 125154
125148: LD_INT 9
125150: DOUBLE
125151: LESSEQUAL
125152: IFTRUE 125156
125154: GO 125216
125156: POP
// begin bc_type := b_lab_half ;
125157: LD_ADDR_OWVAR 42
125161: PUSH
125162: LD_INT 7
125164: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
125165: LD_ADDR_OWVAR 44
125169: PUSH
125170: LD_INT 10
125172: PUSH
125173: LD_INT 11
125175: PUSH
125176: LD_INT 12
125178: PUSH
125179: LD_INT 15
125181: PUSH
125182: LD_INT 14
125184: PUSH
125185: LD_INT 13
125187: PUSH
125188: EMPTY
125189: LIST
125190: LIST
125191: LIST
125192: LIST
125193: LIST
125194: LIST
125195: PUSH
125196: LD_VAR 0 2
125200: PUSH
125201: LD_INT 3
125203: MINUS
125204: ARRAY
125205: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
125206: LD_ADDR_OWVAR 45
125210: PUSH
125211: LD_INT 9
125213: ST_TO_ADDR
// end ; 10 .. 13 :
125214: GO 125724
125216: LD_INT 10
125218: DOUBLE
125219: GREATEREQUAL
125220: IFFALSE 125228
125222: LD_INT 13
125224: DOUBLE
125225: LESSEQUAL
125226: IFTRUE 125230
125228: GO 125307
125230: POP
// begin bc_type := b_lab_full ;
125231: LD_ADDR_OWVAR 42
125235: PUSH
125236: LD_INT 8
125238: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
125239: LD_ADDR_OWVAR 44
125243: PUSH
125244: LD_INT 10
125246: PUSH
125247: LD_INT 12
125249: PUSH
125250: LD_INT 14
125252: PUSH
125253: LD_INT 13
125255: PUSH
125256: EMPTY
125257: LIST
125258: LIST
125259: LIST
125260: LIST
125261: PUSH
125262: LD_VAR 0 2
125266: PUSH
125267: LD_INT 9
125269: MINUS
125270: ARRAY
125271: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
125272: LD_ADDR_OWVAR 45
125276: PUSH
125277: LD_INT 11
125279: PUSH
125280: LD_INT 15
125282: PUSH
125283: LD_INT 12
125285: PUSH
125286: LD_INT 15
125288: PUSH
125289: EMPTY
125290: LIST
125291: LIST
125292: LIST
125293: LIST
125294: PUSH
125295: LD_VAR 0 2
125299: PUSH
125300: LD_INT 9
125302: MINUS
125303: ARRAY
125304: ST_TO_ADDR
// end ; 14 :
125305: GO 125724
125307: LD_INT 14
125309: DOUBLE
125310: EQUAL
125311: IFTRUE 125315
125313: GO 125326
125315: POP
// bc_type := b_workshop ; 15 :
125316: LD_ADDR_OWVAR 42
125320: PUSH
125321: LD_INT 2
125323: ST_TO_ADDR
125324: GO 125724
125326: LD_INT 15
125328: DOUBLE
125329: EQUAL
125330: IFTRUE 125334
125332: GO 125345
125334: POP
// bc_type := b_factory ; 16 :
125335: LD_ADDR_OWVAR 42
125339: PUSH
125340: LD_INT 3
125342: ST_TO_ADDR
125343: GO 125724
125345: LD_INT 16
125347: DOUBLE
125348: EQUAL
125349: IFTRUE 125353
125351: GO 125364
125353: POP
// bc_type := b_ext_gun ; 17 :
125354: LD_ADDR_OWVAR 42
125358: PUSH
125359: LD_INT 17
125361: ST_TO_ADDR
125362: GO 125724
125364: LD_INT 17
125366: DOUBLE
125367: EQUAL
125368: IFTRUE 125372
125370: GO 125400
125372: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
125373: LD_ADDR_OWVAR 42
125377: PUSH
125378: LD_INT 19
125380: PUSH
125381: LD_INT 23
125383: PUSH
125384: LD_INT 19
125386: PUSH
125387: EMPTY
125388: LIST
125389: LIST
125390: LIST
125391: PUSH
125392: LD_VAR 0 1
125396: ARRAY
125397: ST_TO_ADDR
125398: GO 125724
125400: LD_INT 18
125402: DOUBLE
125403: EQUAL
125404: IFTRUE 125408
125406: GO 125419
125408: POP
// bc_type := b_ext_radar ; 19 :
125409: LD_ADDR_OWVAR 42
125413: PUSH
125414: LD_INT 20
125416: ST_TO_ADDR
125417: GO 125724
125419: LD_INT 19
125421: DOUBLE
125422: EQUAL
125423: IFTRUE 125427
125425: GO 125438
125427: POP
// bc_type := b_ext_radio ; 20 :
125428: LD_ADDR_OWVAR 42
125432: PUSH
125433: LD_INT 22
125435: ST_TO_ADDR
125436: GO 125724
125438: LD_INT 20
125440: DOUBLE
125441: EQUAL
125442: IFTRUE 125446
125444: GO 125457
125446: POP
// bc_type := b_ext_siberium ; 21 :
125447: LD_ADDR_OWVAR 42
125451: PUSH
125452: LD_INT 21
125454: ST_TO_ADDR
125455: GO 125724
125457: LD_INT 21
125459: DOUBLE
125460: EQUAL
125461: IFTRUE 125465
125463: GO 125476
125465: POP
// bc_type := b_ext_computer ; 22 :
125466: LD_ADDR_OWVAR 42
125470: PUSH
125471: LD_INT 24
125473: ST_TO_ADDR
125474: GO 125724
125476: LD_INT 22
125478: DOUBLE
125479: EQUAL
125480: IFTRUE 125484
125482: GO 125495
125484: POP
// bc_type := b_ext_track ; 23 :
125485: LD_ADDR_OWVAR 42
125489: PUSH
125490: LD_INT 16
125492: ST_TO_ADDR
125493: GO 125724
125495: LD_INT 23
125497: DOUBLE
125498: EQUAL
125499: IFTRUE 125503
125501: GO 125514
125503: POP
// bc_type := b_ext_laser ; 24 :
125504: LD_ADDR_OWVAR 42
125508: PUSH
125509: LD_INT 25
125511: ST_TO_ADDR
125512: GO 125724
125514: LD_INT 24
125516: DOUBLE
125517: EQUAL
125518: IFTRUE 125522
125520: GO 125533
125522: POP
// bc_type := b_control_tower ; 25 :
125523: LD_ADDR_OWVAR 42
125527: PUSH
125528: LD_INT 36
125530: ST_TO_ADDR
125531: GO 125724
125533: LD_INT 25
125535: DOUBLE
125536: EQUAL
125537: IFTRUE 125541
125539: GO 125552
125541: POP
// bc_type := b_breastwork ; 26 :
125542: LD_ADDR_OWVAR 42
125546: PUSH
125547: LD_INT 31
125549: ST_TO_ADDR
125550: GO 125724
125552: LD_INT 26
125554: DOUBLE
125555: EQUAL
125556: IFTRUE 125560
125558: GO 125571
125560: POP
// bc_type := b_bunker ; 27 :
125561: LD_ADDR_OWVAR 42
125565: PUSH
125566: LD_INT 32
125568: ST_TO_ADDR
125569: GO 125724
125571: LD_INT 27
125573: DOUBLE
125574: EQUAL
125575: IFTRUE 125579
125577: GO 125590
125579: POP
// bc_type := b_turret ; 28 :
125580: LD_ADDR_OWVAR 42
125584: PUSH
125585: LD_INT 33
125587: ST_TO_ADDR
125588: GO 125724
125590: LD_INT 28
125592: DOUBLE
125593: EQUAL
125594: IFTRUE 125598
125596: GO 125609
125598: POP
// bc_type := b_armoury ; 29 :
125599: LD_ADDR_OWVAR 42
125603: PUSH
125604: LD_INT 4
125606: ST_TO_ADDR
125607: GO 125724
125609: LD_INT 29
125611: DOUBLE
125612: EQUAL
125613: IFTRUE 125617
125615: GO 125628
125617: POP
// bc_type := b_barracks ; 30 :
125618: LD_ADDR_OWVAR 42
125622: PUSH
125623: LD_INT 5
125625: ST_TO_ADDR
125626: GO 125724
125628: LD_INT 30
125630: DOUBLE
125631: EQUAL
125632: IFTRUE 125636
125634: GO 125647
125636: POP
// bc_type := b_solar_power ; 31 :
125637: LD_ADDR_OWVAR 42
125641: PUSH
125642: LD_INT 27
125644: ST_TO_ADDR
125645: GO 125724
125647: LD_INT 31
125649: DOUBLE
125650: EQUAL
125651: IFTRUE 125655
125653: GO 125666
125655: POP
// bc_type := b_oil_power ; 32 :
125656: LD_ADDR_OWVAR 42
125660: PUSH
125661: LD_INT 26
125663: ST_TO_ADDR
125664: GO 125724
125666: LD_INT 32
125668: DOUBLE
125669: EQUAL
125670: IFTRUE 125674
125672: GO 125685
125674: POP
// bc_type := b_siberite_power ; 33 :
125675: LD_ADDR_OWVAR 42
125679: PUSH
125680: LD_INT 28
125682: ST_TO_ADDR
125683: GO 125724
125685: LD_INT 33
125687: DOUBLE
125688: EQUAL
125689: IFTRUE 125693
125691: GO 125704
125693: POP
// bc_type := b_oil_mine ; 34 :
125694: LD_ADDR_OWVAR 42
125698: PUSH
125699: LD_INT 29
125701: ST_TO_ADDR
125702: GO 125724
125704: LD_INT 34
125706: DOUBLE
125707: EQUAL
125708: IFTRUE 125712
125710: GO 125723
125712: POP
// bc_type := b_siberite_mine ; end ;
125713: LD_ADDR_OWVAR 42
125717: PUSH
125718: LD_INT 30
125720: ST_TO_ADDR
125721: GO 125724
125723: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
125724: LD_ADDR_VAR 0 8
125728: PUSH
125729: LD_VAR 0 5
125733: PPUSH
125734: LD_VAR 0 6
125738: PPUSH
125739: LD_VAR 0 3
125743: PPUSH
125744: CALL_OW 47
125748: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
125749: LD_OWVAR 42
125753: PUSH
125754: LD_INT 32
125756: PUSH
125757: LD_INT 33
125759: PUSH
125760: EMPTY
125761: LIST
125762: LIST
125763: IN
125764: IFFALSE 125780
// PlaceWeaponTurret ( b , weapon ) ;
125766: LD_VAR 0 8
125770: PPUSH
125771: LD_VAR 0 4
125775: PPUSH
125776: CALL_OW 431
// end ;
125780: LD_VAR 0 7
125784: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
125785: LD_INT 0
125787: PPUSH
125788: PPUSH
125789: PPUSH
125790: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
125791: LD_ADDR_VAR 0 4
125795: PUSH
125796: LD_INT 22
125798: PUSH
125799: LD_OWVAR 2
125803: PUSH
125804: EMPTY
125805: LIST
125806: LIST
125807: PUSH
125808: LD_INT 2
125810: PUSH
125811: LD_INT 30
125813: PUSH
125814: LD_INT 0
125816: PUSH
125817: EMPTY
125818: LIST
125819: LIST
125820: PUSH
125821: LD_INT 30
125823: PUSH
125824: LD_INT 1
125826: PUSH
125827: EMPTY
125828: LIST
125829: LIST
125830: PUSH
125831: EMPTY
125832: LIST
125833: LIST
125834: LIST
125835: PUSH
125836: EMPTY
125837: LIST
125838: LIST
125839: PPUSH
125840: CALL_OW 69
125844: ST_TO_ADDR
// if not tmp then
125845: LD_VAR 0 4
125849: NOT
125850: IFFALSE 125854
// exit ;
125852: GO 125913
// for i in tmp do
125854: LD_ADDR_VAR 0 2
125858: PUSH
125859: LD_VAR 0 4
125863: PUSH
125864: FOR_IN
125865: IFFALSE 125911
// for j = 1 to 3 do
125867: LD_ADDR_VAR 0 3
125871: PUSH
125872: DOUBLE
125873: LD_INT 1
125875: DEC
125876: ST_TO_ADDR
125877: LD_INT 3
125879: PUSH
125880: FOR_TO
125881: IFFALSE 125907
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
125883: LD_VAR 0 2
125887: PPUSH
125888: CALL_OW 274
125892: PPUSH
125893: LD_VAR 0 3
125897: PPUSH
125898: LD_INT 99999
125900: PPUSH
125901: CALL_OW 277
125905: GO 125880
125907: POP
125908: POP
125909: GO 125864
125911: POP
125912: POP
// end ;
125913: LD_VAR 0 1
125917: RET
// export function hHackSetLevel10 ; var i , j ; begin
125918: LD_INT 0
125920: PPUSH
125921: PPUSH
125922: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
125923: LD_ADDR_VAR 0 2
125927: PUSH
125928: LD_INT 21
125930: PUSH
125931: LD_INT 1
125933: PUSH
125934: EMPTY
125935: LIST
125936: LIST
125937: PPUSH
125938: CALL_OW 69
125942: PUSH
125943: FOR_IN
125944: IFFALSE 125996
// if IsSelected ( i ) then
125946: LD_VAR 0 2
125950: PPUSH
125951: CALL_OW 306
125955: IFFALSE 125994
// begin for j := 1 to 4 do
125957: LD_ADDR_VAR 0 3
125961: PUSH
125962: DOUBLE
125963: LD_INT 1
125965: DEC
125966: ST_TO_ADDR
125967: LD_INT 4
125969: PUSH
125970: FOR_TO
125971: IFFALSE 125992
// SetSkill ( i , j , 10 ) ;
125973: LD_VAR 0 2
125977: PPUSH
125978: LD_VAR 0 3
125982: PPUSH
125983: LD_INT 10
125985: PPUSH
125986: CALL_OW 237
125990: GO 125970
125992: POP
125993: POP
// end ;
125994: GO 125943
125996: POP
125997: POP
// end ;
125998: LD_VAR 0 1
126002: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
126003: LD_INT 0
126005: PPUSH
126006: PPUSH
126007: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
126008: LD_ADDR_VAR 0 2
126012: PUSH
126013: LD_INT 22
126015: PUSH
126016: LD_OWVAR 2
126020: PUSH
126021: EMPTY
126022: LIST
126023: LIST
126024: PUSH
126025: LD_INT 21
126027: PUSH
126028: LD_INT 1
126030: PUSH
126031: EMPTY
126032: LIST
126033: LIST
126034: PUSH
126035: EMPTY
126036: LIST
126037: LIST
126038: PPUSH
126039: CALL_OW 69
126043: PUSH
126044: FOR_IN
126045: IFFALSE 126086
// begin for j := 1 to 4 do
126047: LD_ADDR_VAR 0 3
126051: PUSH
126052: DOUBLE
126053: LD_INT 1
126055: DEC
126056: ST_TO_ADDR
126057: LD_INT 4
126059: PUSH
126060: FOR_TO
126061: IFFALSE 126082
// SetSkill ( i , j , 10 ) ;
126063: LD_VAR 0 2
126067: PPUSH
126068: LD_VAR 0 3
126072: PPUSH
126073: LD_INT 10
126075: PPUSH
126076: CALL_OW 237
126080: GO 126060
126082: POP
126083: POP
// end ;
126084: GO 126044
126086: POP
126087: POP
// end ;
126088: LD_VAR 0 1
126092: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
126093: LD_INT 0
126095: PPUSH
// uc_side := your_side ;
126096: LD_ADDR_OWVAR 20
126100: PUSH
126101: LD_OWVAR 2
126105: ST_TO_ADDR
// uc_nation := nation ;
126106: LD_ADDR_OWVAR 21
126110: PUSH
126111: LD_VAR 0 1
126115: ST_TO_ADDR
// InitHc ;
126116: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
126120: LD_INT 0
126122: PPUSH
126123: LD_VAR 0 2
126127: PPUSH
126128: LD_VAR 0 3
126132: PPUSH
126133: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
126137: LD_VAR 0 4
126141: PPUSH
126142: LD_VAR 0 5
126146: PPUSH
126147: CALL_OW 428
126151: PUSH
126152: LD_INT 0
126154: EQUAL
126155: IFFALSE 126179
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
126157: CALL_OW 44
126161: PPUSH
126162: LD_VAR 0 4
126166: PPUSH
126167: LD_VAR 0 5
126171: PPUSH
126172: LD_INT 1
126174: PPUSH
126175: CALL_OW 48
// end ;
126179: LD_VAR 0 6
126183: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
126184: LD_INT 0
126186: PPUSH
126187: PPUSH
// uc_side := your_side ;
126188: LD_ADDR_OWVAR 20
126192: PUSH
126193: LD_OWVAR 2
126197: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
126198: LD_VAR 0 1
126202: PUSH
126203: LD_INT 1
126205: PUSH
126206: LD_INT 2
126208: PUSH
126209: LD_INT 3
126211: PUSH
126212: LD_INT 4
126214: PUSH
126215: LD_INT 5
126217: PUSH
126218: EMPTY
126219: LIST
126220: LIST
126221: LIST
126222: LIST
126223: LIST
126224: IN
126225: IFFALSE 126237
// uc_nation := nation_american else
126227: LD_ADDR_OWVAR 21
126231: PUSH
126232: LD_INT 1
126234: ST_TO_ADDR
126235: GO 126280
// if chassis in [ 11 , 12 , 13 , 14 ] then
126237: LD_VAR 0 1
126241: PUSH
126242: LD_INT 11
126244: PUSH
126245: LD_INT 12
126247: PUSH
126248: LD_INT 13
126250: PUSH
126251: LD_INT 14
126253: PUSH
126254: EMPTY
126255: LIST
126256: LIST
126257: LIST
126258: LIST
126259: IN
126260: IFFALSE 126272
// uc_nation := nation_arabian else
126262: LD_ADDR_OWVAR 21
126266: PUSH
126267: LD_INT 2
126269: ST_TO_ADDR
126270: GO 126280
// uc_nation := nation_russian ;
126272: LD_ADDR_OWVAR 21
126276: PUSH
126277: LD_INT 3
126279: ST_TO_ADDR
// vc_chassis := chassis ;
126280: LD_ADDR_OWVAR 37
126284: PUSH
126285: LD_VAR 0 1
126289: ST_TO_ADDR
// vc_engine := engine ;
126290: LD_ADDR_OWVAR 39
126294: PUSH
126295: LD_VAR 0 2
126299: ST_TO_ADDR
// vc_control := control ;
126300: LD_ADDR_OWVAR 38
126304: PUSH
126305: LD_VAR 0 3
126309: ST_TO_ADDR
// vc_weapon := weapon ;
126310: LD_ADDR_OWVAR 40
126314: PUSH
126315: LD_VAR 0 4
126319: ST_TO_ADDR
// un := CreateVehicle ;
126320: LD_ADDR_VAR 0 8
126324: PUSH
126325: CALL_OW 45
126329: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
126330: LD_VAR 0 8
126334: PPUSH
126335: LD_INT 0
126337: PPUSH
126338: LD_INT 5
126340: PPUSH
126341: CALL_OW 12
126345: PPUSH
126346: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
126350: LD_VAR 0 8
126354: PPUSH
126355: LD_VAR 0 5
126359: PPUSH
126360: LD_VAR 0 6
126364: PPUSH
126365: LD_INT 1
126367: PPUSH
126368: CALL_OW 48
// end ;
126372: LD_VAR 0 7
126376: RET
// export hInvincible ; every 1 do
126377: GO 126379
126379: DISABLE
// hInvincible := [ ] ;
126380: LD_ADDR_EXP 205
126384: PUSH
126385: EMPTY
126386: ST_TO_ADDR
126387: END
// every 10 do var i ;
126388: GO 126390
126390: DISABLE
126391: LD_INT 0
126393: PPUSH
// begin enable ;
126394: ENABLE
// if not hInvincible then
126395: LD_EXP 205
126399: NOT
126400: IFFALSE 126404
// exit ;
126402: GO 126448
// for i in hInvincible do
126404: LD_ADDR_VAR 0 1
126408: PUSH
126409: LD_EXP 205
126413: PUSH
126414: FOR_IN
126415: IFFALSE 126446
// if GetLives ( i ) < 1000 then
126417: LD_VAR 0 1
126421: PPUSH
126422: CALL_OW 256
126426: PUSH
126427: LD_INT 1000
126429: LESS
126430: IFFALSE 126444
// SetLives ( i , 1000 ) ;
126432: LD_VAR 0 1
126436: PPUSH
126437: LD_INT 1000
126439: PPUSH
126440: CALL_OW 234
126444: GO 126414
126446: POP
126447: POP
// end ;
126448: PPOPN 1
126450: END
// export function hHackInvincible ; var i ; begin
126451: LD_INT 0
126453: PPUSH
126454: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
126455: LD_ADDR_VAR 0 2
126459: PUSH
126460: LD_INT 2
126462: PUSH
126463: LD_INT 21
126465: PUSH
126466: LD_INT 1
126468: PUSH
126469: EMPTY
126470: LIST
126471: LIST
126472: PUSH
126473: LD_INT 21
126475: PUSH
126476: LD_INT 2
126478: PUSH
126479: EMPTY
126480: LIST
126481: LIST
126482: PUSH
126483: EMPTY
126484: LIST
126485: LIST
126486: LIST
126487: PPUSH
126488: CALL_OW 69
126492: PUSH
126493: FOR_IN
126494: IFFALSE 126555
// if IsSelected ( i ) then
126496: LD_VAR 0 2
126500: PPUSH
126501: CALL_OW 306
126505: IFFALSE 126553
// begin if i in hInvincible then
126507: LD_VAR 0 2
126511: PUSH
126512: LD_EXP 205
126516: IN
126517: IFFALSE 126537
// hInvincible := hInvincible diff i else
126519: LD_ADDR_EXP 205
126523: PUSH
126524: LD_EXP 205
126528: PUSH
126529: LD_VAR 0 2
126533: DIFF
126534: ST_TO_ADDR
126535: GO 126553
// hInvincible := hInvincible union i ;
126537: LD_ADDR_EXP 205
126541: PUSH
126542: LD_EXP 205
126546: PUSH
126547: LD_VAR 0 2
126551: UNION
126552: ST_TO_ADDR
// end ;
126553: GO 126493
126555: POP
126556: POP
// end ;
126557: LD_VAR 0 1
126561: RET
// export function hHackInvisible ; var i , j ; begin
126562: LD_INT 0
126564: PPUSH
126565: PPUSH
126566: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
126567: LD_ADDR_VAR 0 2
126571: PUSH
126572: LD_INT 21
126574: PUSH
126575: LD_INT 1
126577: PUSH
126578: EMPTY
126579: LIST
126580: LIST
126581: PPUSH
126582: CALL_OW 69
126586: PUSH
126587: FOR_IN
126588: IFFALSE 126612
// if IsSelected ( i ) then
126590: LD_VAR 0 2
126594: PPUSH
126595: CALL_OW 306
126599: IFFALSE 126610
// ComForceInvisible ( i ) ;
126601: LD_VAR 0 2
126605: PPUSH
126606: CALL_OW 496
126610: GO 126587
126612: POP
126613: POP
// end ;
126614: LD_VAR 0 1
126618: RET
// export function hHackChangeYourSide ; begin
126619: LD_INT 0
126621: PPUSH
// if your_side = 8 then
126622: LD_OWVAR 2
126626: PUSH
126627: LD_INT 8
126629: EQUAL
126630: IFFALSE 126642
// your_side := 0 else
126632: LD_ADDR_OWVAR 2
126636: PUSH
126637: LD_INT 0
126639: ST_TO_ADDR
126640: GO 126656
// your_side := your_side + 1 ;
126642: LD_ADDR_OWVAR 2
126646: PUSH
126647: LD_OWVAR 2
126651: PUSH
126652: LD_INT 1
126654: PLUS
126655: ST_TO_ADDR
// end ;
126656: LD_VAR 0 1
126660: RET
// export function hHackChangeUnitSide ; var i , j ; begin
126661: LD_INT 0
126663: PPUSH
126664: PPUSH
126665: PPUSH
// for i in all_units do
126666: LD_ADDR_VAR 0 2
126670: PUSH
126671: LD_OWVAR 3
126675: PUSH
126676: FOR_IN
126677: IFFALSE 126755
// if IsSelected ( i ) then
126679: LD_VAR 0 2
126683: PPUSH
126684: CALL_OW 306
126688: IFFALSE 126753
// begin j := GetSide ( i ) ;
126690: LD_ADDR_VAR 0 3
126694: PUSH
126695: LD_VAR 0 2
126699: PPUSH
126700: CALL_OW 255
126704: ST_TO_ADDR
// if j = 8 then
126705: LD_VAR 0 3
126709: PUSH
126710: LD_INT 8
126712: EQUAL
126713: IFFALSE 126725
// j := 0 else
126715: LD_ADDR_VAR 0 3
126719: PUSH
126720: LD_INT 0
126722: ST_TO_ADDR
126723: GO 126739
// j := j + 1 ;
126725: LD_ADDR_VAR 0 3
126729: PUSH
126730: LD_VAR 0 3
126734: PUSH
126735: LD_INT 1
126737: PLUS
126738: ST_TO_ADDR
// SetSide ( i , j ) ;
126739: LD_VAR 0 2
126743: PPUSH
126744: LD_VAR 0 3
126748: PPUSH
126749: CALL_OW 235
// end ;
126753: GO 126676
126755: POP
126756: POP
// end ;
126757: LD_VAR 0 1
126761: RET
// export function hHackFog ; begin
126762: LD_INT 0
126764: PPUSH
// FogOff ( true ) ;
126765: LD_INT 1
126767: PPUSH
126768: CALL_OW 344
// end ;
126772: LD_VAR 0 1
126776: RET
// export function hHackTeleport ( unit , x , y ) ; begin
126777: LD_INT 0
126779: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
126780: LD_VAR 0 1
126784: PPUSH
126785: LD_VAR 0 2
126789: PPUSH
126790: LD_VAR 0 3
126794: PPUSH
126795: LD_INT 1
126797: PPUSH
126798: LD_INT 1
126800: PPUSH
126801: CALL_OW 483
// CenterOnXY ( x , y ) ;
126805: LD_VAR 0 2
126809: PPUSH
126810: LD_VAR 0 3
126814: PPUSH
126815: CALL_OW 84
// end ;
126819: LD_VAR 0 4
126823: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
126824: LD_INT 0
126826: PPUSH
126827: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
126828: LD_VAR 0 1
126832: NOT
126833: PUSH
126834: LD_VAR 0 2
126838: PPUSH
126839: LD_VAR 0 3
126843: PPUSH
126844: CALL_OW 488
126848: NOT
126849: OR
126850: PUSH
126851: LD_VAR 0 1
126855: PPUSH
126856: CALL_OW 266
126860: PUSH
126861: LD_INT 3
126863: NONEQUAL
126864: PUSH
126865: LD_VAR 0 1
126869: PPUSH
126870: CALL_OW 247
126874: PUSH
126875: LD_INT 1
126877: EQUAL
126878: NOT
126879: AND
126880: OR
126881: IFFALSE 126885
// exit ;
126883: GO 127034
// if GetType ( factory ) = unit_human then
126885: LD_VAR 0 1
126889: PPUSH
126890: CALL_OW 247
126894: PUSH
126895: LD_INT 1
126897: EQUAL
126898: IFFALSE 126915
// factory := IsInUnit ( factory ) ;
126900: LD_ADDR_VAR 0 1
126904: PUSH
126905: LD_VAR 0 1
126909: PPUSH
126910: CALL_OW 310
126914: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
126915: LD_VAR 0 1
126919: PPUSH
126920: CALL_OW 266
126924: PUSH
126925: LD_INT 3
126927: NONEQUAL
126928: IFFALSE 126932
// exit ;
126930: GO 127034
// if HexInfo ( x , y ) = factory then
126932: LD_VAR 0 2
126936: PPUSH
126937: LD_VAR 0 3
126941: PPUSH
126942: CALL_OW 428
126946: PUSH
126947: LD_VAR 0 1
126951: EQUAL
126952: IFFALSE 126979
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
126954: LD_ADDR_EXP 206
126958: PUSH
126959: LD_EXP 206
126963: PPUSH
126964: LD_VAR 0 1
126968: PPUSH
126969: LD_INT 0
126971: PPUSH
126972: CALL_OW 1
126976: ST_TO_ADDR
126977: GO 127030
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
126979: LD_ADDR_EXP 206
126983: PUSH
126984: LD_EXP 206
126988: PPUSH
126989: LD_VAR 0 1
126993: PPUSH
126994: LD_VAR 0 1
126998: PPUSH
126999: CALL_OW 255
127003: PUSH
127004: LD_VAR 0 1
127008: PUSH
127009: LD_VAR 0 2
127013: PUSH
127014: LD_VAR 0 3
127018: PUSH
127019: EMPTY
127020: LIST
127021: LIST
127022: LIST
127023: LIST
127024: PPUSH
127025: CALL_OW 1
127029: ST_TO_ADDR
// UpdateFactoryWaypoints ;
127030: CALL 127039 0 0
// end ;
127034: LD_VAR 0 4
127038: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
127039: LD_INT 0
127041: PPUSH
127042: PPUSH
127043: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
127044: LD_STRING resetFactoryWaypoint();
127046: PPUSH
127047: CALL_OW 559
// if factoryWaypoints then
127051: LD_EXP 206
127055: IFFALSE 127181
// begin list := PrepareArray ( factoryWaypoints ) ;
127057: LD_ADDR_VAR 0 3
127061: PUSH
127062: LD_EXP 206
127066: PPUSH
127067: CALL 110994 0 1
127071: ST_TO_ADDR
// for i := 1 to list do
127072: LD_ADDR_VAR 0 2
127076: PUSH
127077: DOUBLE
127078: LD_INT 1
127080: DEC
127081: ST_TO_ADDR
127082: LD_VAR 0 3
127086: PUSH
127087: FOR_TO
127088: IFFALSE 127179
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127090: LD_STRING setFactoryWaypointXY(
127092: PUSH
127093: LD_VAR 0 3
127097: PUSH
127098: LD_VAR 0 2
127102: ARRAY
127103: PUSH
127104: LD_INT 1
127106: ARRAY
127107: STR
127108: PUSH
127109: LD_STRING ,
127111: STR
127112: PUSH
127113: LD_VAR 0 3
127117: PUSH
127118: LD_VAR 0 2
127122: ARRAY
127123: PUSH
127124: LD_INT 2
127126: ARRAY
127127: STR
127128: PUSH
127129: LD_STRING ,
127131: STR
127132: PUSH
127133: LD_VAR 0 3
127137: PUSH
127138: LD_VAR 0 2
127142: ARRAY
127143: PUSH
127144: LD_INT 3
127146: ARRAY
127147: STR
127148: PUSH
127149: LD_STRING ,
127151: STR
127152: PUSH
127153: LD_VAR 0 3
127157: PUSH
127158: LD_VAR 0 2
127162: ARRAY
127163: PUSH
127164: LD_INT 4
127166: ARRAY
127167: STR
127168: PUSH
127169: LD_STRING )
127171: STR
127172: PPUSH
127173: CALL_OW 559
127177: GO 127087
127179: POP
127180: POP
// end ; end ;
127181: LD_VAR 0 1
127185: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
127186: LD_INT 0
127188: PPUSH
// if HexInfo ( x , y ) = warehouse then
127189: LD_VAR 0 2
127193: PPUSH
127194: LD_VAR 0 3
127198: PPUSH
127199: CALL_OW 428
127203: PUSH
127204: LD_VAR 0 1
127208: EQUAL
127209: IFFALSE 127236
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
127211: LD_ADDR_EXP 207
127215: PUSH
127216: LD_EXP 207
127220: PPUSH
127221: LD_VAR 0 1
127225: PPUSH
127226: LD_INT 0
127228: PPUSH
127229: CALL_OW 1
127233: ST_TO_ADDR
127234: GO 127287
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
127236: LD_ADDR_EXP 207
127240: PUSH
127241: LD_EXP 207
127245: PPUSH
127246: LD_VAR 0 1
127250: PPUSH
127251: LD_VAR 0 1
127255: PPUSH
127256: CALL_OW 255
127260: PUSH
127261: LD_VAR 0 1
127265: PUSH
127266: LD_VAR 0 2
127270: PUSH
127271: LD_VAR 0 3
127275: PUSH
127276: EMPTY
127277: LIST
127278: LIST
127279: LIST
127280: LIST
127281: PPUSH
127282: CALL_OW 1
127286: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
127287: CALL 127296 0 0
// end ;
127291: LD_VAR 0 4
127295: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
127296: LD_INT 0
127298: PPUSH
127299: PPUSH
127300: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
127301: LD_STRING resetWarehouseGatheringPoints();
127303: PPUSH
127304: CALL_OW 559
// if warehouseGatheringPoints then
127308: LD_EXP 207
127312: IFFALSE 127438
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
127314: LD_ADDR_VAR 0 3
127318: PUSH
127319: LD_EXP 207
127323: PPUSH
127324: CALL 110994 0 1
127328: ST_TO_ADDR
// for i := 1 to list do
127329: LD_ADDR_VAR 0 2
127333: PUSH
127334: DOUBLE
127335: LD_INT 1
127337: DEC
127338: ST_TO_ADDR
127339: LD_VAR 0 3
127343: PUSH
127344: FOR_TO
127345: IFFALSE 127436
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
127347: LD_STRING setWarehouseGatheringPointXY(
127349: PUSH
127350: LD_VAR 0 3
127354: PUSH
127355: LD_VAR 0 2
127359: ARRAY
127360: PUSH
127361: LD_INT 1
127363: ARRAY
127364: STR
127365: PUSH
127366: LD_STRING ,
127368: STR
127369: PUSH
127370: LD_VAR 0 3
127374: PUSH
127375: LD_VAR 0 2
127379: ARRAY
127380: PUSH
127381: LD_INT 2
127383: ARRAY
127384: STR
127385: PUSH
127386: LD_STRING ,
127388: STR
127389: PUSH
127390: LD_VAR 0 3
127394: PUSH
127395: LD_VAR 0 2
127399: ARRAY
127400: PUSH
127401: LD_INT 3
127403: ARRAY
127404: STR
127405: PUSH
127406: LD_STRING ,
127408: STR
127409: PUSH
127410: LD_VAR 0 3
127414: PUSH
127415: LD_VAR 0 2
127419: ARRAY
127420: PUSH
127421: LD_INT 4
127423: ARRAY
127424: STR
127425: PUSH
127426: LD_STRING )
127428: STR
127429: PPUSH
127430: CALL_OW 559
127434: GO 127344
127436: POP
127437: POP
// end ; end ;
127438: LD_VAR 0 1
127442: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
127443: LD_EXP 207
127447: IFFALSE 128132
127449: GO 127451
127451: DISABLE
127452: LD_INT 0
127454: PPUSH
127455: PPUSH
127456: PPUSH
127457: PPUSH
127458: PPUSH
127459: PPUSH
127460: PPUSH
127461: PPUSH
127462: PPUSH
// begin enable ;
127463: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
127464: LD_ADDR_VAR 0 3
127468: PUSH
127469: LD_EXP 207
127473: PPUSH
127474: CALL 110994 0 1
127478: ST_TO_ADDR
// if not list then
127479: LD_VAR 0 3
127483: NOT
127484: IFFALSE 127488
// exit ;
127486: GO 128132
// for i := 1 to list do
127488: LD_ADDR_VAR 0 1
127492: PUSH
127493: DOUBLE
127494: LD_INT 1
127496: DEC
127497: ST_TO_ADDR
127498: LD_VAR 0 3
127502: PUSH
127503: FOR_TO
127504: IFFALSE 128130
// begin depot := list [ i ] [ 2 ] ;
127506: LD_ADDR_VAR 0 8
127510: PUSH
127511: LD_VAR 0 3
127515: PUSH
127516: LD_VAR 0 1
127520: ARRAY
127521: PUSH
127522: LD_INT 2
127524: ARRAY
127525: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
127526: LD_ADDR_VAR 0 5
127530: PUSH
127531: LD_VAR 0 3
127535: PUSH
127536: LD_VAR 0 1
127540: ARRAY
127541: PUSH
127542: LD_INT 1
127544: ARRAY
127545: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
127546: LD_VAR 0 8
127550: PPUSH
127551: CALL_OW 301
127555: PUSH
127556: LD_VAR 0 5
127560: PUSH
127561: LD_VAR 0 8
127565: PPUSH
127566: CALL_OW 255
127570: NONEQUAL
127571: OR
127572: IFFALSE 127601
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
127574: LD_ADDR_EXP 207
127578: PUSH
127579: LD_EXP 207
127583: PPUSH
127584: LD_VAR 0 8
127588: PPUSH
127589: LD_INT 0
127591: PPUSH
127592: CALL_OW 1
127596: ST_TO_ADDR
// exit ;
127597: POP
127598: POP
127599: GO 128132
// end ; x := list [ i ] [ 3 ] ;
127601: LD_ADDR_VAR 0 6
127605: PUSH
127606: LD_VAR 0 3
127610: PUSH
127611: LD_VAR 0 1
127615: ARRAY
127616: PUSH
127617: LD_INT 3
127619: ARRAY
127620: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
127621: LD_ADDR_VAR 0 7
127625: PUSH
127626: LD_VAR 0 3
127630: PUSH
127631: LD_VAR 0 1
127635: ARRAY
127636: PUSH
127637: LD_INT 4
127639: ARRAY
127640: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
127641: LD_ADDR_VAR 0 9
127645: PUSH
127646: LD_VAR 0 6
127650: PPUSH
127651: LD_VAR 0 7
127655: PPUSH
127656: LD_INT 16
127658: PPUSH
127659: CALL 109582 0 3
127663: ST_TO_ADDR
// if not cratesNearbyPoint then
127664: LD_VAR 0 9
127668: NOT
127669: IFFALSE 127675
// exit ;
127671: POP
127672: POP
127673: GO 128132
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
127675: LD_ADDR_VAR 0 4
127679: PUSH
127680: LD_INT 22
127682: PUSH
127683: LD_VAR 0 5
127687: PUSH
127688: EMPTY
127689: LIST
127690: LIST
127691: PUSH
127692: LD_INT 3
127694: PUSH
127695: LD_INT 60
127697: PUSH
127698: EMPTY
127699: LIST
127700: PUSH
127701: EMPTY
127702: LIST
127703: LIST
127704: PUSH
127705: LD_INT 91
127707: PUSH
127708: LD_VAR 0 8
127712: PUSH
127713: LD_INT 6
127715: PUSH
127716: EMPTY
127717: LIST
127718: LIST
127719: LIST
127720: PUSH
127721: LD_INT 2
127723: PUSH
127724: LD_INT 25
127726: PUSH
127727: LD_INT 2
127729: PUSH
127730: EMPTY
127731: LIST
127732: LIST
127733: PUSH
127734: LD_INT 25
127736: PUSH
127737: LD_INT 16
127739: PUSH
127740: EMPTY
127741: LIST
127742: LIST
127743: PUSH
127744: EMPTY
127745: LIST
127746: LIST
127747: LIST
127748: PUSH
127749: EMPTY
127750: LIST
127751: LIST
127752: LIST
127753: LIST
127754: PPUSH
127755: CALL_OW 69
127759: PUSH
127760: LD_VAR 0 8
127764: PPUSH
127765: CALL_OW 313
127769: PPUSH
127770: LD_INT 3
127772: PUSH
127773: LD_INT 60
127775: PUSH
127776: EMPTY
127777: LIST
127778: PUSH
127779: EMPTY
127780: LIST
127781: LIST
127782: PUSH
127783: LD_INT 2
127785: PUSH
127786: LD_INT 25
127788: PUSH
127789: LD_INT 2
127791: PUSH
127792: EMPTY
127793: LIST
127794: LIST
127795: PUSH
127796: LD_INT 25
127798: PUSH
127799: LD_INT 16
127801: PUSH
127802: EMPTY
127803: LIST
127804: LIST
127805: PUSH
127806: EMPTY
127807: LIST
127808: LIST
127809: LIST
127810: PUSH
127811: EMPTY
127812: LIST
127813: LIST
127814: PPUSH
127815: CALL_OW 72
127819: UNION
127820: ST_TO_ADDR
// if tmp then
127821: LD_VAR 0 4
127825: IFFALSE 127905
// begin tmp := ShrinkArray ( tmp , 3 ) ;
127827: LD_ADDR_VAR 0 4
127831: PUSH
127832: LD_VAR 0 4
127836: PPUSH
127837: LD_INT 3
127839: PPUSH
127840: CALL 107551 0 2
127844: ST_TO_ADDR
// for j in tmp do
127845: LD_ADDR_VAR 0 2
127849: PUSH
127850: LD_VAR 0 4
127854: PUSH
127855: FOR_IN
127856: IFFALSE 127899
// begin if IsInUnit ( j ) then
127858: LD_VAR 0 2
127862: PPUSH
127863: CALL_OW 310
127867: IFFALSE 127878
// ComExit ( j ) ;
127869: LD_VAR 0 2
127873: PPUSH
127874: CALL 107634 0 1
// AddComCollect ( j , x , y ) ;
127878: LD_VAR 0 2
127882: PPUSH
127883: LD_VAR 0 6
127887: PPUSH
127888: LD_VAR 0 7
127892: PPUSH
127893: CALL_OW 177
// end ;
127897: GO 127855
127899: POP
127900: POP
// exit ;
127901: POP
127902: POP
127903: GO 128132
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
127905: LD_ADDR_VAR 0 4
127909: PUSH
127910: LD_INT 22
127912: PUSH
127913: LD_VAR 0 5
127917: PUSH
127918: EMPTY
127919: LIST
127920: LIST
127921: PUSH
127922: LD_INT 91
127924: PUSH
127925: LD_VAR 0 8
127929: PUSH
127930: LD_INT 8
127932: PUSH
127933: EMPTY
127934: LIST
127935: LIST
127936: LIST
127937: PUSH
127938: LD_INT 2
127940: PUSH
127941: LD_INT 34
127943: PUSH
127944: LD_INT 12
127946: PUSH
127947: EMPTY
127948: LIST
127949: LIST
127950: PUSH
127951: LD_INT 34
127953: PUSH
127954: LD_INT 51
127956: PUSH
127957: EMPTY
127958: LIST
127959: LIST
127960: PUSH
127961: LD_INT 34
127963: PUSH
127964: LD_INT 32
127966: PUSH
127967: EMPTY
127968: LIST
127969: LIST
127970: PUSH
127971: LD_INT 34
127973: PUSH
127974: LD_INT 89
127976: PUSH
127977: EMPTY
127978: LIST
127979: LIST
127980: PUSH
127981: EMPTY
127982: LIST
127983: LIST
127984: LIST
127985: LIST
127986: LIST
127987: PUSH
127988: EMPTY
127989: LIST
127990: LIST
127991: LIST
127992: PPUSH
127993: CALL_OW 69
127997: ST_TO_ADDR
// if tmp then
127998: LD_VAR 0 4
128002: IFFALSE 128128
// begin for j in tmp do
128004: LD_ADDR_VAR 0 2
128008: PUSH
128009: LD_VAR 0 4
128013: PUSH
128014: FOR_IN
128015: IFFALSE 128126
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
128017: LD_VAR 0 2
128021: PPUSH
128022: CALL_OW 262
128026: PUSH
128027: LD_INT 3
128029: EQUAL
128030: PUSH
128031: LD_VAR 0 2
128035: PPUSH
128036: CALL_OW 261
128040: PUSH
128041: LD_INT 20
128043: GREATER
128044: OR
128045: PUSH
128046: LD_VAR 0 2
128050: PPUSH
128051: CALL_OW 314
128055: NOT
128056: AND
128057: PUSH
128058: LD_VAR 0 2
128062: PPUSH
128063: CALL_OW 263
128067: PUSH
128068: LD_INT 1
128070: NONEQUAL
128071: PUSH
128072: LD_VAR 0 2
128076: PPUSH
128077: CALL_OW 311
128081: OR
128082: AND
128083: IFFALSE 128124
// begin ComCollect ( j , x , y ) ;
128085: LD_VAR 0 2
128089: PPUSH
128090: LD_VAR 0 6
128094: PPUSH
128095: LD_VAR 0 7
128099: PPUSH
128100: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
128104: LD_VAR 0 2
128108: PPUSH
128109: LD_VAR 0 8
128113: PPUSH
128114: CALL_OW 172
// exit ;
128118: POP
128119: POP
128120: POP
128121: POP
128122: GO 128132
// end ;
128124: GO 128014
128126: POP
128127: POP
// end ; end ;
128128: GO 127503
128130: POP
128131: POP
// end ; end_of_file
128132: PPOPN 9
128134: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
128135: LD_INT 0
128137: PPUSH
128138: PPUSH
128139: PPUSH
128140: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
128141: LD_VAR 0 1
128145: PPUSH
128146: CALL_OW 264
128150: PUSH
128151: LD_INT 91
128153: EQUAL
128154: IFFALSE 128226
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
128156: LD_INT 68
128158: PPUSH
128159: LD_VAR 0 1
128163: PPUSH
128164: CALL_OW 255
128168: PPUSH
128169: CALL_OW 321
128173: PUSH
128174: LD_INT 2
128176: EQUAL
128177: IFFALSE 128189
// eff := 70 else
128179: LD_ADDR_VAR 0 4
128183: PUSH
128184: LD_INT 70
128186: ST_TO_ADDR
128187: GO 128197
// eff := 30 ;
128189: LD_ADDR_VAR 0 4
128193: PUSH
128194: LD_INT 30
128196: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
128197: LD_VAR 0 1
128201: PPUSH
128202: CALL_OW 250
128206: PPUSH
128207: LD_VAR 0 1
128211: PPUSH
128212: CALL_OW 251
128216: PPUSH
128217: LD_VAR 0 4
128221: PPUSH
128222: CALL_OW 495
// end ; end ;
128226: LD_VAR 0 2
128230: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
128231: LD_INT 0
128233: PPUSH
// end ;
128234: LD_VAR 0 4
128238: RET
// export function SOS_Command ( cmd ) ; begin
128239: LD_INT 0
128241: PPUSH
// end ;
128242: LD_VAR 0 2
128246: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
128247: LD_INT 0
128249: PPUSH
// end ;
128250: LD_VAR 0 6
128254: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
128255: LD_INT 0
128257: PPUSH
128258: PPUSH
// if not vehicle or not factory then
128259: LD_VAR 0 1
128263: NOT
128264: PUSH
128265: LD_VAR 0 2
128269: NOT
128270: OR
128271: IFFALSE 128275
// exit ;
128273: GO 128506
// if factoryWaypoints >= factory then
128275: LD_EXP 206
128279: PUSH
128280: LD_VAR 0 2
128284: GREATEREQUAL
128285: IFFALSE 128506
// if factoryWaypoints [ factory ] then
128287: LD_EXP 206
128291: PUSH
128292: LD_VAR 0 2
128296: ARRAY
128297: IFFALSE 128506
// begin if GetControl ( vehicle ) = control_manual then
128299: LD_VAR 0 1
128303: PPUSH
128304: CALL_OW 263
128308: PUSH
128309: LD_INT 1
128311: EQUAL
128312: IFFALSE 128393
// begin driver := IsDrivenBy ( vehicle ) ;
128314: LD_ADDR_VAR 0 4
128318: PUSH
128319: LD_VAR 0 1
128323: PPUSH
128324: CALL_OW 311
128328: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128329: LD_VAR 0 4
128333: PPUSH
128334: LD_EXP 206
128338: PUSH
128339: LD_VAR 0 2
128343: ARRAY
128344: PUSH
128345: LD_INT 3
128347: ARRAY
128348: PPUSH
128349: LD_EXP 206
128353: PUSH
128354: LD_VAR 0 2
128358: ARRAY
128359: PUSH
128360: LD_INT 4
128362: ARRAY
128363: PPUSH
128364: CALL_OW 171
// AddComExitVehicle ( driver ) ;
128368: LD_VAR 0 4
128372: PPUSH
128373: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
128377: LD_VAR 0 4
128381: PPUSH
128382: LD_VAR 0 2
128386: PPUSH
128387: CALL_OW 180
// end else
128391: GO 128506
// if GetControl ( vehicle ) = control_remote then
128393: LD_VAR 0 1
128397: PPUSH
128398: CALL_OW 263
128402: PUSH
128403: LD_INT 2
128405: EQUAL
128406: IFFALSE 128467
// begin wait ( 0 0$2 ) ;
128408: LD_INT 70
128410: PPUSH
128411: CALL_OW 67
// if Connect ( vehicle ) then
128415: LD_VAR 0 1
128419: PPUSH
128420: CALL 77853 0 1
128424: IFFALSE 128465
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128426: LD_VAR 0 1
128430: PPUSH
128431: LD_EXP 206
128435: PUSH
128436: LD_VAR 0 2
128440: ARRAY
128441: PUSH
128442: LD_INT 3
128444: ARRAY
128445: PPUSH
128446: LD_EXP 206
128450: PUSH
128451: LD_VAR 0 2
128455: ARRAY
128456: PUSH
128457: LD_INT 4
128459: ARRAY
128460: PPUSH
128461: CALL_OW 171
// end else
128465: GO 128506
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
128467: LD_VAR 0 1
128471: PPUSH
128472: LD_EXP 206
128476: PUSH
128477: LD_VAR 0 2
128481: ARRAY
128482: PUSH
128483: LD_INT 3
128485: ARRAY
128486: PPUSH
128487: LD_EXP 206
128491: PUSH
128492: LD_VAR 0 2
128496: ARRAY
128497: PUSH
128498: LD_INT 4
128500: ARRAY
128501: PPUSH
128502: CALL_OW 171
// end ; end ;
128506: LD_VAR 0 3
128510: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
128511: LD_INT 0
128513: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
128514: LD_VAR 0 1
128518: PUSH
128519: LD_INT 250
128521: EQUAL
128522: PUSH
128523: LD_VAR 0 2
128527: PPUSH
128528: CALL_OW 264
128532: PUSH
128533: LD_INT 81
128535: EQUAL
128536: AND
128537: IFFALSE 128558
// MinerPlaceMine ( unit , x , y ) ;
128539: LD_VAR 0 2
128543: PPUSH
128544: LD_VAR 0 4
128548: PPUSH
128549: LD_VAR 0 5
128553: PPUSH
128554: CALL 131548 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
128558: LD_VAR 0 1
128562: PUSH
128563: LD_INT 251
128565: EQUAL
128566: PUSH
128567: LD_VAR 0 2
128571: PPUSH
128572: CALL_OW 264
128576: PUSH
128577: LD_INT 81
128579: EQUAL
128580: AND
128581: IFFALSE 128602
// MinerDetonateMine ( unit , x , y ) ;
128583: LD_VAR 0 2
128587: PPUSH
128588: LD_VAR 0 4
128592: PPUSH
128593: LD_VAR 0 5
128597: PPUSH
128598: CALL 131823 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
128602: LD_VAR 0 1
128606: PUSH
128607: LD_INT 252
128609: EQUAL
128610: PUSH
128611: LD_VAR 0 2
128615: PPUSH
128616: CALL_OW 264
128620: PUSH
128621: LD_INT 81
128623: EQUAL
128624: AND
128625: IFFALSE 128646
// MinerCreateMinefield ( unit , x , y ) ;
128627: LD_VAR 0 2
128631: PPUSH
128632: LD_VAR 0 4
128636: PPUSH
128637: LD_VAR 0 5
128641: PPUSH
128642: CALL 132240 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
128646: LD_VAR 0 1
128650: PUSH
128651: LD_INT 253
128653: EQUAL
128654: PUSH
128655: LD_VAR 0 2
128659: PPUSH
128660: CALL_OW 257
128664: PUSH
128665: LD_INT 5
128667: EQUAL
128668: AND
128669: IFFALSE 128690
// ComBinocular ( unit , x , y ) ;
128671: LD_VAR 0 2
128675: PPUSH
128676: LD_VAR 0 4
128680: PPUSH
128681: LD_VAR 0 5
128685: PPUSH
128686: CALL 132609 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
128690: LD_VAR 0 1
128694: PUSH
128695: LD_INT 254
128697: EQUAL
128698: PUSH
128699: LD_VAR 0 2
128703: PPUSH
128704: CALL_OW 264
128708: PUSH
128709: LD_INT 99
128711: EQUAL
128712: AND
128713: PUSH
128714: LD_VAR 0 3
128718: PPUSH
128719: CALL_OW 263
128723: PUSH
128724: LD_INT 3
128726: EQUAL
128727: AND
128728: IFFALSE 128744
// HackDestroyVehicle ( unit , selectedUnit ) ;
128730: LD_VAR 0 2
128734: PPUSH
128735: LD_VAR 0 3
128739: PPUSH
128740: CALL 130912 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
128744: LD_VAR 0 1
128748: PUSH
128749: LD_INT 255
128751: EQUAL
128752: PUSH
128753: LD_VAR 0 2
128757: PPUSH
128758: CALL_OW 264
128762: PUSH
128763: LD_INT 14
128765: PUSH
128766: LD_INT 53
128768: PUSH
128769: EMPTY
128770: LIST
128771: LIST
128772: IN
128773: AND
128774: PUSH
128775: LD_VAR 0 4
128779: PPUSH
128780: LD_VAR 0 5
128784: PPUSH
128785: CALL_OW 488
128789: AND
128790: IFFALSE 128814
// CutTreeXYR ( unit , x , y , 12 ) ;
128792: LD_VAR 0 2
128796: PPUSH
128797: LD_VAR 0 4
128801: PPUSH
128802: LD_VAR 0 5
128806: PPUSH
128807: LD_INT 12
128809: PPUSH
128810: CALL 128909 0 4
// if cmd = 256 then
128814: LD_VAR 0 1
128818: PUSH
128819: LD_INT 256
128821: EQUAL
128822: IFFALSE 128843
// SetFactoryWaypoint ( unit , x , y ) ;
128824: LD_VAR 0 2
128828: PPUSH
128829: LD_VAR 0 4
128833: PPUSH
128834: LD_VAR 0 5
128838: PPUSH
128839: CALL 126824 0 3
// if cmd = 257 then
128843: LD_VAR 0 1
128847: PUSH
128848: LD_INT 257
128850: EQUAL
128851: IFFALSE 128872
// SetWarehouseGatheringPoint ( unit , x , y ) ;
128853: LD_VAR 0 2
128857: PPUSH
128858: LD_VAR 0 4
128862: PPUSH
128863: LD_VAR 0 5
128867: PPUSH
128868: CALL 127186 0 3
// if cmd = 258 then
128872: LD_VAR 0 1
128876: PUSH
128877: LD_INT 258
128879: EQUAL
128880: IFFALSE 128904
// BurnTreeXYR ( unit , x , y , 8 ) ;
128882: LD_VAR 0 2
128886: PPUSH
128887: LD_VAR 0 4
128891: PPUSH
128892: LD_VAR 0 5
128896: PPUSH
128897: LD_INT 8
128899: PPUSH
128900: CALL 129303 0 4
// end ;
128904: LD_VAR 0 6
128908: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
128909: LD_INT 0
128911: PPUSH
128912: PPUSH
128913: PPUSH
128914: PPUSH
128915: PPUSH
128916: PPUSH
128917: PPUSH
128918: PPUSH
128919: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
128920: LD_VAR 0 1
128924: PPUSH
128925: CALL_OW 302
128929: NOT
128930: PUSH
128931: LD_VAR 0 2
128935: PPUSH
128936: LD_VAR 0 3
128940: PPUSH
128941: CALL_OW 488
128945: NOT
128946: OR
128947: PUSH
128948: LD_VAR 0 4
128952: NOT
128953: OR
128954: IFFALSE 128958
// exit ;
128956: GO 129298
// list := [ ] ;
128958: LD_ADDR_VAR 0 13
128962: PUSH
128963: EMPTY
128964: ST_TO_ADDR
// if x - r < 0 then
128965: LD_VAR 0 2
128969: PUSH
128970: LD_VAR 0 4
128974: MINUS
128975: PUSH
128976: LD_INT 0
128978: LESS
128979: IFFALSE 128991
// min_x := 0 else
128981: LD_ADDR_VAR 0 7
128985: PUSH
128986: LD_INT 0
128988: ST_TO_ADDR
128989: GO 129007
// min_x := x - r ;
128991: LD_ADDR_VAR 0 7
128995: PUSH
128996: LD_VAR 0 2
129000: PUSH
129001: LD_VAR 0 4
129005: MINUS
129006: ST_TO_ADDR
// if y - r < 0 then
129007: LD_VAR 0 3
129011: PUSH
129012: LD_VAR 0 4
129016: MINUS
129017: PUSH
129018: LD_INT 0
129020: LESS
129021: IFFALSE 129033
// min_y := 0 else
129023: LD_ADDR_VAR 0 8
129027: PUSH
129028: LD_INT 0
129030: ST_TO_ADDR
129031: GO 129049
// min_y := y - r ;
129033: LD_ADDR_VAR 0 8
129037: PUSH
129038: LD_VAR 0 3
129042: PUSH
129043: LD_VAR 0 4
129047: MINUS
129048: ST_TO_ADDR
// max_x := x + r ;
129049: LD_ADDR_VAR 0 9
129053: PUSH
129054: LD_VAR 0 2
129058: PUSH
129059: LD_VAR 0 4
129063: PLUS
129064: ST_TO_ADDR
// max_y := y + r ;
129065: LD_ADDR_VAR 0 10
129069: PUSH
129070: LD_VAR 0 3
129074: PUSH
129075: LD_VAR 0 4
129079: PLUS
129080: ST_TO_ADDR
// for _x = min_x to max_x do
129081: LD_ADDR_VAR 0 11
129085: PUSH
129086: DOUBLE
129087: LD_VAR 0 7
129091: DEC
129092: ST_TO_ADDR
129093: LD_VAR 0 9
129097: PUSH
129098: FOR_TO
129099: IFFALSE 129216
// for _y = min_y to max_y do
129101: LD_ADDR_VAR 0 12
129105: PUSH
129106: DOUBLE
129107: LD_VAR 0 8
129111: DEC
129112: ST_TO_ADDR
129113: LD_VAR 0 10
129117: PUSH
129118: FOR_TO
129119: IFFALSE 129212
// begin if not ValidHex ( _x , _y ) then
129121: LD_VAR 0 11
129125: PPUSH
129126: LD_VAR 0 12
129130: PPUSH
129131: CALL_OW 488
129135: NOT
129136: IFFALSE 129140
// continue ;
129138: GO 129118
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129140: LD_VAR 0 11
129144: PPUSH
129145: LD_VAR 0 12
129149: PPUSH
129150: CALL_OW 351
129154: PUSH
129155: LD_VAR 0 11
129159: PPUSH
129160: LD_VAR 0 12
129164: PPUSH
129165: CALL_OW 554
129169: AND
129170: IFFALSE 129210
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129172: LD_ADDR_VAR 0 13
129176: PUSH
129177: LD_VAR 0 13
129181: PPUSH
129182: LD_VAR 0 13
129186: PUSH
129187: LD_INT 1
129189: PLUS
129190: PPUSH
129191: LD_VAR 0 11
129195: PUSH
129196: LD_VAR 0 12
129200: PUSH
129201: EMPTY
129202: LIST
129203: LIST
129204: PPUSH
129205: CALL_OW 2
129209: ST_TO_ADDR
// end ;
129210: GO 129118
129212: POP
129213: POP
129214: GO 129098
129216: POP
129217: POP
// if not list then
129218: LD_VAR 0 13
129222: NOT
129223: IFFALSE 129227
// exit ;
129225: GO 129298
// for i in list do
129227: LD_ADDR_VAR 0 6
129231: PUSH
129232: LD_VAR 0 13
129236: PUSH
129237: FOR_IN
129238: IFFALSE 129296
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
129240: LD_VAR 0 1
129244: PPUSH
129245: LD_STRING M
129247: PUSH
129248: LD_VAR 0 6
129252: PUSH
129253: LD_INT 1
129255: ARRAY
129256: PUSH
129257: LD_VAR 0 6
129261: PUSH
129262: LD_INT 2
129264: ARRAY
129265: PUSH
129266: LD_INT 0
129268: PUSH
129269: LD_INT 0
129271: PUSH
129272: LD_INT 0
129274: PUSH
129275: LD_INT 0
129277: PUSH
129278: EMPTY
129279: LIST
129280: LIST
129281: LIST
129282: LIST
129283: LIST
129284: LIST
129285: LIST
129286: PUSH
129287: EMPTY
129288: LIST
129289: PPUSH
129290: CALL_OW 447
129294: GO 129237
129296: POP
129297: POP
// end ;
129298: LD_VAR 0 5
129302: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
129303: LD_INT 0
129305: PPUSH
129306: PPUSH
129307: PPUSH
129308: PPUSH
129309: PPUSH
129310: PPUSH
129311: PPUSH
129312: PPUSH
129313: PPUSH
129314: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
129315: LD_VAR 0 1
129319: PPUSH
129320: CALL_OW 302
129324: NOT
129325: PUSH
129326: LD_VAR 0 2
129330: PPUSH
129331: LD_VAR 0 3
129335: PPUSH
129336: CALL_OW 488
129340: NOT
129341: OR
129342: PUSH
129343: LD_VAR 0 4
129347: NOT
129348: OR
129349: IFFALSE 129353
// exit ;
129351: GO 129866
// list := [ ] ;
129353: LD_ADDR_VAR 0 13
129357: PUSH
129358: EMPTY
129359: ST_TO_ADDR
// if x - r < 0 then
129360: LD_VAR 0 2
129364: PUSH
129365: LD_VAR 0 4
129369: MINUS
129370: PUSH
129371: LD_INT 0
129373: LESS
129374: IFFALSE 129386
// min_x := 0 else
129376: LD_ADDR_VAR 0 7
129380: PUSH
129381: LD_INT 0
129383: ST_TO_ADDR
129384: GO 129402
// min_x := x - r ;
129386: LD_ADDR_VAR 0 7
129390: PUSH
129391: LD_VAR 0 2
129395: PUSH
129396: LD_VAR 0 4
129400: MINUS
129401: ST_TO_ADDR
// if y - r < 0 then
129402: LD_VAR 0 3
129406: PUSH
129407: LD_VAR 0 4
129411: MINUS
129412: PUSH
129413: LD_INT 0
129415: LESS
129416: IFFALSE 129428
// min_y := 0 else
129418: LD_ADDR_VAR 0 8
129422: PUSH
129423: LD_INT 0
129425: ST_TO_ADDR
129426: GO 129444
// min_y := y - r ;
129428: LD_ADDR_VAR 0 8
129432: PUSH
129433: LD_VAR 0 3
129437: PUSH
129438: LD_VAR 0 4
129442: MINUS
129443: ST_TO_ADDR
// max_x := x + r ;
129444: LD_ADDR_VAR 0 9
129448: PUSH
129449: LD_VAR 0 2
129453: PUSH
129454: LD_VAR 0 4
129458: PLUS
129459: ST_TO_ADDR
// max_y := y + r ;
129460: LD_ADDR_VAR 0 10
129464: PUSH
129465: LD_VAR 0 3
129469: PUSH
129470: LD_VAR 0 4
129474: PLUS
129475: ST_TO_ADDR
// for _x = min_x to max_x do
129476: LD_ADDR_VAR 0 11
129480: PUSH
129481: DOUBLE
129482: LD_VAR 0 7
129486: DEC
129487: ST_TO_ADDR
129488: LD_VAR 0 9
129492: PUSH
129493: FOR_TO
129494: IFFALSE 129611
// for _y = min_y to max_y do
129496: LD_ADDR_VAR 0 12
129500: PUSH
129501: DOUBLE
129502: LD_VAR 0 8
129506: DEC
129507: ST_TO_ADDR
129508: LD_VAR 0 10
129512: PUSH
129513: FOR_TO
129514: IFFALSE 129607
// begin if not ValidHex ( _x , _y ) then
129516: LD_VAR 0 11
129520: PPUSH
129521: LD_VAR 0 12
129525: PPUSH
129526: CALL_OW 488
129530: NOT
129531: IFFALSE 129535
// continue ;
129533: GO 129513
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
129535: LD_VAR 0 11
129539: PPUSH
129540: LD_VAR 0 12
129544: PPUSH
129545: CALL_OW 351
129549: PUSH
129550: LD_VAR 0 11
129554: PPUSH
129555: LD_VAR 0 12
129559: PPUSH
129560: CALL_OW 554
129564: AND
129565: IFFALSE 129605
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
129567: LD_ADDR_VAR 0 13
129571: PUSH
129572: LD_VAR 0 13
129576: PPUSH
129577: LD_VAR 0 13
129581: PUSH
129582: LD_INT 1
129584: PLUS
129585: PPUSH
129586: LD_VAR 0 11
129590: PUSH
129591: LD_VAR 0 12
129595: PUSH
129596: EMPTY
129597: LIST
129598: LIST
129599: PPUSH
129600: CALL_OW 2
129604: ST_TO_ADDR
// end ;
129605: GO 129513
129607: POP
129608: POP
129609: GO 129493
129611: POP
129612: POP
// if not list then
129613: LD_VAR 0 13
129617: NOT
129618: IFFALSE 129622
// exit ;
129620: GO 129866
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
129622: LD_ADDR_VAR 0 13
129626: PUSH
129627: LD_VAR 0 1
129631: PPUSH
129632: LD_VAR 0 13
129636: PPUSH
129637: LD_INT 1
129639: PPUSH
129640: LD_INT 1
129642: PPUSH
129643: CALL 74995 0 4
129647: ST_TO_ADDR
// ComStop ( flame ) ;
129648: LD_VAR 0 1
129652: PPUSH
129653: CALL_OW 141
// for i in list do
129657: LD_ADDR_VAR 0 6
129661: PUSH
129662: LD_VAR 0 13
129666: PUSH
129667: FOR_IN
129668: IFFALSE 129699
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
129670: LD_VAR 0 1
129674: PPUSH
129675: LD_VAR 0 6
129679: PUSH
129680: LD_INT 1
129682: ARRAY
129683: PPUSH
129684: LD_VAR 0 6
129688: PUSH
129689: LD_INT 2
129691: ARRAY
129692: PPUSH
129693: CALL_OW 176
129697: GO 129667
129699: POP
129700: POP
// repeat wait ( 0 0$1 ) ;
129701: LD_INT 35
129703: PPUSH
129704: CALL_OW 67
// task := GetTaskList ( flame ) ;
129708: LD_ADDR_VAR 0 14
129712: PUSH
129713: LD_VAR 0 1
129717: PPUSH
129718: CALL_OW 437
129722: ST_TO_ADDR
// if not task then
129723: LD_VAR 0 14
129727: NOT
129728: IFFALSE 129732
// exit ;
129730: GO 129866
// if task [ 1 ] [ 1 ] <> | then
129732: LD_VAR 0 14
129736: PUSH
129737: LD_INT 1
129739: ARRAY
129740: PUSH
129741: LD_INT 1
129743: ARRAY
129744: PUSH
129745: LD_STRING |
129747: NONEQUAL
129748: IFFALSE 129752
// exit ;
129750: GO 129866
// _x := task [ 1 ] [ 2 ] ;
129752: LD_ADDR_VAR 0 11
129756: PUSH
129757: LD_VAR 0 14
129761: PUSH
129762: LD_INT 1
129764: ARRAY
129765: PUSH
129766: LD_INT 2
129768: ARRAY
129769: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
129770: LD_ADDR_VAR 0 12
129774: PUSH
129775: LD_VAR 0 14
129779: PUSH
129780: LD_INT 1
129782: ARRAY
129783: PUSH
129784: LD_INT 3
129786: ARRAY
129787: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
129788: LD_VAR 0 11
129792: PPUSH
129793: LD_VAR 0 12
129797: PPUSH
129798: CALL_OW 351
129802: NOT
129803: PUSH
129804: LD_VAR 0 11
129808: PPUSH
129809: LD_VAR 0 12
129813: PPUSH
129814: CALL_OW 554
129818: NOT
129819: OR
129820: IFFALSE 129854
// begin task := Delete ( task , 1 ) ;
129822: LD_ADDR_VAR 0 14
129826: PUSH
129827: LD_VAR 0 14
129831: PPUSH
129832: LD_INT 1
129834: PPUSH
129835: CALL_OW 3
129839: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
129840: LD_VAR 0 1
129844: PPUSH
129845: LD_VAR 0 14
129849: PPUSH
129850: CALL_OW 446
// end ; until not HasTask ( flame ) ;
129854: LD_VAR 0 1
129858: PPUSH
129859: CALL_OW 314
129863: NOT
129864: IFFALSE 129701
// end ;
129866: LD_VAR 0 5
129870: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
129871: LD_EXP 209
129875: NOT
129876: IFFALSE 129926
129878: GO 129880
129880: DISABLE
// begin initHack := true ;
129881: LD_ADDR_EXP 209
129885: PUSH
129886: LD_INT 1
129888: ST_TO_ADDR
// hackTanks := [ ] ;
129889: LD_ADDR_EXP 210
129893: PUSH
129894: EMPTY
129895: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
129896: LD_ADDR_EXP 211
129900: PUSH
129901: EMPTY
129902: ST_TO_ADDR
// hackLimit := 3 ;
129903: LD_ADDR_EXP 212
129907: PUSH
129908: LD_INT 3
129910: ST_TO_ADDR
// hackDist := 12 ;
129911: LD_ADDR_EXP 213
129915: PUSH
129916: LD_INT 12
129918: ST_TO_ADDR
// hackCounter := [ ] ;
129919: LD_ADDR_EXP 214
129923: PUSH
129924: EMPTY
129925: ST_TO_ADDR
// end ;
129926: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
129927: LD_EXP 209
129931: PUSH
129932: LD_INT 34
129934: PUSH
129935: LD_INT 99
129937: PUSH
129938: EMPTY
129939: LIST
129940: LIST
129941: PPUSH
129942: CALL_OW 69
129946: AND
129947: IFFALSE 130200
129949: GO 129951
129951: DISABLE
129952: LD_INT 0
129954: PPUSH
129955: PPUSH
// begin enable ;
129956: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
129957: LD_ADDR_VAR 0 1
129961: PUSH
129962: LD_INT 34
129964: PUSH
129965: LD_INT 99
129967: PUSH
129968: EMPTY
129969: LIST
129970: LIST
129971: PPUSH
129972: CALL_OW 69
129976: PUSH
129977: FOR_IN
129978: IFFALSE 130198
// begin if not i in hackTanks then
129980: LD_VAR 0 1
129984: PUSH
129985: LD_EXP 210
129989: IN
129990: NOT
129991: IFFALSE 130074
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
129993: LD_ADDR_EXP 210
129997: PUSH
129998: LD_EXP 210
130002: PPUSH
130003: LD_EXP 210
130007: PUSH
130008: LD_INT 1
130010: PLUS
130011: PPUSH
130012: LD_VAR 0 1
130016: PPUSH
130017: CALL_OW 1
130021: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
130022: LD_ADDR_EXP 211
130026: PUSH
130027: LD_EXP 211
130031: PPUSH
130032: LD_EXP 211
130036: PUSH
130037: LD_INT 1
130039: PLUS
130040: PPUSH
130041: EMPTY
130042: PPUSH
130043: CALL_OW 1
130047: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
130048: LD_ADDR_EXP 214
130052: PUSH
130053: LD_EXP 214
130057: PPUSH
130058: LD_EXP 214
130062: PUSH
130063: LD_INT 1
130065: PLUS
130066: PPUSH
130067: EMPTY
130068: PPUSH
130069: CALL_OW 1
130073: ST_TO_ADDR
// end ; if not IsOk ( i ) then
130074: LD_VAR 0 1
130078: PPUSH
130079: CALL_OW 302
130083: NOT
130084: IFFALSE 130097
// begin HackUnlinkAll ( i ) ;
130086: LD_VAR 0 1
130090: PPUSH
130091: CALL 130203 0 1
// continue ;
130095: GO 129977
// end ; HackCheckCapturedStatus ( i ) ;
130097: LD_VAR 0 1
130101: PPUSH
130102: CALL 130646 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
130106: LD_ADDR_VAR 0 2
130110: PUSH
130111: LD_INT 81
130113: PUSH
130114: LD_VAR 0 1
130118: PPUSH
130119: CALL_OW 255
130123: PUSH
130124: EMPTY
130125: LIST
130126: LIST
130127: PUSH
130128: LD_INT 33
130130: PUSH
130131: LD_INT 3
130133: PUSH
130134: EMPTY
130135: LIST
130136: LIST
130137: PUSH
130138: LD_INT 91
130140: PUSH
130141: LD_VAR 0 1
130145: PUSH
130146: LD_EXP 213
130150: PUSH
130151: EMPTY
130152: LIST
130153: LIST
130154: LIST
130155: PUSH
130156: LD_INT 50
130158: PUSH
130159: EMPTY
130160: LIST
130161: PUSH
130162: EMPTY
130163: LIST
130164: LIST
130165: LIST
130166: LIST
130167: PPUSH
130168: CALL_OW 69
130172: ST_TO_ADDR
// if not tmp then
130173: LD_VAR 0 2
130177: NOT
130178: IFFALSE 130182
// continue ;
130180: GO 129977
// HackLink ( i , tmp ) ;
130182: LD_VAR 0 1
130186: PPUSH
130187: LD_VAR 0 2
130191: PPUSH
130192: CALL 130339 0 2
// end ;
130196: GO 129977
130198: POP
130199: POP
// end ;
130200: PPOPN 2
130202: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
130203: LD_INT 0
130205: PPUSH
130206: PPUSH
130207: PPUSH
// if not hack in hackTanks then
130208: LD_VAR 0 1
130212: PUSH
130213: LD_EXP 210
130217: IN
130218: NOT
130219: IFFALSE 130223
// exit ;
130221: GO 130334
// index := GetElementIndex ( hackTanks , hack ) ;
130223: LD_ADDR_VAR 0 4
130227: PUSH
130228: LD_EXP 210
130232: PPUSH
130233: LD_VAR 0 1
130237: PPUSH
130238: CALL 74292 0 2
130242: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
130243: LD_EXP 211
130247: PUSH
130248: LD_VAR 0 4
130252: ARRAY
130253: IFFALSE 130334
// begin for i in hackTanksCaptured [ index ] do
130255: LD_ADDR_VAR 0 3
130259: PUSH
130260: LD_EXP 211
130264: PUSH
130265: LD_VAR 0 4
130269: ARRAY
130270: PUSH
130271: FOR_IN
130272: IFFALSE 130298
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
130274: LD_VAR 0 3
130278: PUSH
130279: LD_INT 1
130281: ARRAY
130282: PPUSH
130283: LD_VAR 0 3
130287: PUSH
130288: LD_INT 2
130290: ARRAY
130291: PPUSH
130292: CALL_OW 235
130296: GO 130271
130298: POP
130299: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
130300: LD_ADDR_EXP 211
130304: PUSH
130305: LD_EXP 211
130309: PPUSH
130310: LD_VAR 0 4
130314: PPUSH
130315: EMPTY
130316: PPUSH
130317: CALL_OW 1
130321: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
130322: LD_VAR 0 1
130326: PPUSH
130327: LD_INT 0
130329: PPUSH
130330: CALL_OW 505
// end ; end ;
130334: LD_VAR 0 2
130338: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
130339: LD_INT 0
130341: PPUSH
130342: PPUSH
130343: PPUSH
// if not hack in hackTanks or not vehicles then
130344: LD_VAR 0 1
130348: PUSH
130349: LD_EXP 210
130353: IN
130354: NOT
130355: PUSH
130356: LD_VAR 0 2
130360: NOT
130361: OR
130362: IFFALSE 130366
// exit ;
130364: GO 130641
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
130366: LD_ADDR_VAR 0 2
130370: PUSH
130371: LD_VAR 0 1
130375: PPUSH
130376: LD_VAR 0 2
130380: PPUSH
130381: LD_INT 1
130383: PPUSH
130384: LD_INT 1
130386: PPUSH
130387: CALL 74942 0 4
130391: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
130392: LD_ADDR_VAR 0 5
130396: PUSH
130397: LD_EXP 210
130401: PPUSH
130402: LD_VAR 0 1
130406: PPUSH
130407: CALL 74292 0 2
130411: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
130412: LD_EXP 211
130416: PUSH
130417: LD_VAR 0 5
130421: ARRAY
130422: PUSH
130423: LD_EXP 212
130427: LESS
130428: IFFALSE 130617
// begin for i := 1 to vehicles do
130430: LD_ADDR_VAR 0 4
130434: PUSH
130435: DOUBLE
130436: LD_INT 1
130438: DEC
130439: ST_TO_ADDR
130440: LD_VAR 0 2
130444: PUSH
130445: FOR_TO
130446: IFFALSE 130615
// begin if hackTanksCaptured [ index ] = hackLimit then
130448: LD_EXP 211
130452: PUSH
130453: LD_VAR 0 5
130457: ARRAY
130458: PUSH
130459: LD_EXP 212
130463: EQUAL
130464: IFFALSE 130468
// break ;
130466: GO 130615
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
130468: LD_ADDR_EXP 214
130472: PUSH
130473: LD_EXP 214
130477: PPUSH
130478: LD_VAR 0 5
130482: PPUSH
130483: LD_EXP 214
130487: PUSH
130488: LD_VAR 0 5
130492: ARRAY
130493: PUSH
130494: LD_INT 1
130496: PLUS
130497: PPUSH
130498: CALL_OW 1
130502: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
130503: LD_ADDR_EXP 211
130507: PUSH
130508: LD_EXP 211
130512: PPUSH
130513: LD_VAR 0 5
130517: PUSH
130518: LD_EXP 211
130522: PUSH
130523: LD_VAR 0 5
130527: ARRAY
130528: PUSH
130529: LD_INT 1
130531: PLUS
130532: PUSH
130533: EMPTY
130534: LIST
130535: LIST
130536: PPUSH
130537: LD_VAR 0 2
130541: PUSH
130542: LD_VAR 0 4
130546: ARRAY
130547: PUSH
130548: LD_VAR 0 2
130552: PUSH
130553: LD_VAR 0 4
130557: ARRAY
130558: PPUSH
130559: CALL_OW 255
130563: PUSH
130564: EMPTY
130565: LIST
130566: LIST
130567: PPUSH
130568: CALL 74507 0 3
130572: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
130573: LD_VAR 0 2
130577: PUSH
130578: LD_VAR 0 4
130582: ARRAY
130583: PPUSH
130584: LD_VAR 0 1
130588: PPUSH
130589: CALL_OW 255
130593: PPUSH
130594: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
130598: LD_VAR 0 2
130602: PUSH
130603: LD_VAR 0 4
130607: ARRAY
130608: PPUSH
130609: CALL_OW 141
// end ;
130613: GO 130445
130615: POP
130616: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130617: LD_VAR 0 1
130621: PPUSH
130622: LD_EXP 211
130626: PUSH
130627: LD_VAR 0 5
130631: ARRAY
130632: PUSH
130633: LD_INT 0
130635: PLUS
130636: PPUSH
130637: CALL_OW 505
// end ;
130641: LD_VAR 0 3
130645: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
130646: LD_INT 0
130648: PPUSH
130649: PPUSH
130650: PPUSH
130651: PPUSH
// if not hack in hackTanks then
130652: LD_VAR 0 1
130656: PUSH
130657: LD_EXP 210
130661: IN
130662: NOT
130663: IFFALSE 130667
// exit ;
130665: GO 130907
// index := GetElementIndex ( hackTanks , hack ) ;
130667: LD_ADDR_VAR 0 4
130671: PUSH
130672: LD_EXP 210
130676: PPUSH
130677: LD_VAR 0 1
130681: PPUSH
130682: CALL 74292 0 2
130686: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
130687: LD_ADDR_VAR 0 3
130691: PUSH
130692: DOUBLE
130693: LD_EXP 211
130697: PUSH
130698: LD_VAR 0 4
130702: ARRAY
130703: INC
130704: ST_TO_ADDR
130705: LD_INT 1
130707: PUSH
130708: FOR_DOWNTO
130709: IFFALSE 130881
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
130711: LD_ADDR_VAR 0 5
130715: PUSH
130716: LD_EXP 211
130720: PUSH
130721: LD_VAR 0 4
130725: ARRAY
130726: PUSH
130727: LD_VAR 0 3
130731: ARRAY
130732: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
130733: LD_VAR 0 5
130737: PUSH
130738: LD_INT 1
130740: ARRAY
130741: PPUSH
130742: CALL_OW 302
130746: NOT
130747: PUSH
130748: LD_VAR 0 5
130752: PUSH
130753: LD_INT 1
130755: ARRAY
130756: PPUSH
130757: CALL_OW 255
130761: PUSH
130762: LD_VAR 0 1
130766: PPUSH
130767: CALL_OW 255
130771: NONEQUAL
130772: OR
130773: IFFALSE 130879
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
130775: LD_VAR 0 5
130779: PUSH
130780: LD_INT 1
130782: ARRAY
130783: PPUSH
130784: CALL_OW 305
130788: PUSH
130789: LD_VAR 0 5
130793: PUSH
130794: LD_INT 1
130796: ARRAY
130797: PPUSH
130798: CALL_OW 255
130802: PUSH
130803: LD_VAR 0 1
130807: PPUSH
130808: CALL_OW 255
130812: EQUAL
130813: AND
130814: IFFALSE 130838
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
130816: LD_VAR 0 5
130820: PUSH
130821: LD_INT 1
130823: ARRAY
130824: PPUSH
130825: LD_VAR 0 5
130829: PUSH
130830: LD_INT 2
130832: ARRAY
130833: PPUSH
130834: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
130838: LD_ADDR_EXP 211
130842: PUSH
130843: LD_EXP 211
130847: PPUSH
130848: LD_VAR 0 4
130852: PPUSH
130853: LD_EXP 211
130857: PUSH
130858: LD_VAR 0 4
130862: ARRAY
130863: PPUSH
130864: LD_VAR 0 3
130868: PPUSH
130869: CALL_OW 3
130873: PPUSH
130874: CALL_OW 1
130878: ST_TO_ADDR
// end ; end ;
130879: GO 130708
130881: POP
130882: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
130883: LD_VAR 0 1
130887: PPUSH
130888: LD_EXP 211
130892: PUSH
130893: LD_VAR 0 4
130897: ARRAY
130898: PUSH
130899: LD_INT 0
130901: PLUS
130902: PPUSH
130903: CALL_OW 505
// end ;
130907: LD_VAR 0 2
130911: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
130912: LD_INT 0
130914: PPUSH
130915: PPUSH
130916: PPUSH
130917: PPUSH
// if not hack in hackTanks then
130918: LD_VAR 0 1
130922: PUSH
130923: LD_EXP 210
130927: IN
130928: NOT
130929: IFFALSE 130933
// exit ;
130931: GO 131018
// index := GetElementIndex ( hackTanks , hack ) ;
130933: LD_ADDR_VAR 0 5
130937: PUSH
130938: LD_EXP 210
130942: PPUSH
130943: LD_VAR 0 1
130947: PPUSH
130948: CALL 74292 0 2
130952: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
130953: LD_ADDR_VAR 0 4
130957: PUSH
130958: DOUBLE
130959: LD_INT 1
130961: DEC
130962: ST_TO_ADDR
130963: LD_EXP 211
130967: PUSH
130968: LD_VAR 0 5
130972: ARRAY
130973: PUSH
130974: FOR_TO
130975: IFFALSE 131016
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
130977: LD_EXP 211
130981: PUSH
130982: LD_VAR 0 5
130986: ARRAY
130987: PUSH
130988: LD_VAR 0 4
130992: ARRAY
130993: PUSH
130994: LD_INT 1
130996: ARRAY
130997: PUSH
130998: LD_VAR 0 2
131002: EQUAL
131003: IFFALSE 131014
// KillUnit ( vehicle ) ;
131005: LD_VAR 0 2
131009: PPUSH
131010: CALL_OW 66
131014: GO 130974
131016: POP
131017: POP
// end ;
131018: LD_VAR 0 3
131022: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
131023: LD_EXP 215
131027: NOT
131028: IFFALSE 131063
131030: GO 131032
131032: DISABLE
// begin initMiner := true ;
131033: LD_ADDR_EXP 215
131037: PUSH
131038: LD_INT 1
131040: ST_TO_ADDR
// minersList := [ ] ;
131041: LD_ADDR_EXP 216
131045: PUSH
131046: EMPTY
131047: ST_TO_ADDR
// minerMinesList := [ ] ;
131048: LD_ADDR_EXP 217
131052: PUSH
131053: EMPTY
131054: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
131055: LD_ADDR_EXP 218
131059: PUSH
131060: LD_INT 5
131062: ST_TO_ADDR
// end ;
131063: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
131064: LD_EXP 215
131068: PUSH
131069: LD_INT 34
131071: PUSH
131072: LD_INT 81
131074: PUSH
131075: EMPTY
131076: LIST
131077: LIST
131078: PPUSH
131079: CALL_OW 69
131083: AND
131084: IFFALSE 131545
131086: GO 131088
131088: DISABLE
131089: LD_INT 0
131091: PPUSH
131092: PPUSH
131093: PPUSH
131094: PPUSH
// begin enable ;
131095: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
131096: LD_ADDR_VAR 0 1
131100: PUSH
131101: LD_INT 34
131103: PUSH
131104: LD_INT 81
131106: PUSH
131107: EMPTY
131108: LIST
131109: LIST
131110: PPUSH
131111: CALL_OW 69
131115: PUSH
131116: FOR_IN
131117: IFFALSE 131189
// begin if not i in minersList then
131119: LD_VAR 0 1
131123: PUSH
131124: LD_EXP 216
131128: IN
131129: NOT
131130: IFFALSE 131187
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
131132: LD_ADDR_EXP 216
131136: PUSH
131137: LD_EXP 216
131141: PPUSH
131142: LD_EXP 216
131146: PUSH
131147: LD_INT 1
131149: PLUS
131150: PPUSH
131151: LD_VAR 0 1
131155: PPUSH
131156: CALL_OW 1
131160: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
131161: LD_ADDR_EXP 217
131165: PUSH
131166: LD_EXP 217
131170: PPUSH
131171: LD_EXP 217
131175: PUSH
131176: LD_INT 1
131178: PLUS
131179: PPUSH
131180: EMPTY
131181: PPUSH
131182: CALL_OW 1
131186: ST_TO_ADDR
// end end ;
131187: GO 131116
131189: POP
131190: POP
// for i := minerMinesList downto 1 do
131191: LD_ADDR_VAR 0 1
131195: PUSH
131196: DOUBLE
131197: LD_EXP 217
131201: INC
131202: ST_TO_ADDR
131203: LD_INT 1
131205: PUSH
131206: FOR_DOWNTO
131207: IFFALSE 131543
// begin if IsLive ( minersList [ i ] ) then
131209: LD_EXP 216
131213: PUSH
131214: LD_VAR 0 1
131218: ARRAY
131219: PPUSH
131220: CALL_OW 300
131224: IFFALSE 131252
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
131226: LD_EXP 216
131230: PUSH
131231: LD_VAR 0 1
131235: ARRAY
131236: PPUSH
131237: LD_EXP 217
131241: PUSH
131242: LD_VAR 0 1
131246: ARRAY
131247: PPUSH
131248: CALL_OW 505
// if not minerMinesList [ i ] then
131252: LD_EXP 217
131256: PUSH
131257: LD_VAR 0 1
131261: ARRAY
131262: NOT
131263: IFFALSE 131267
// continue ;
131265: GO 131206
// for j := minerMinesList [ i ] downto 1 do
131267: LD_ADDR_VAR 0 2
131271: PUSH
131272: DOUBLE
131273: LD_EXP 217
131277: PUSH
131278: LD_VAR 0 1
131282: ARRAY
131283: INC
131284: ST_TO_ADDR
131285: LD_INT 1
131287: PUSH
131288: FOR_DOWNTO
131289: IFFALSE 131539
// begin side := GetSide ( minersList [ i ] ) ;
131291: LD_ADDR_VAR 0 3
131295: PUSH
131296: LD_EXP 216
131300: PUSH
131301: LD_VAR 0 1
131305: ARRAY
131306: PPUSH
131307: CALL_OW 255
131311: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
131312: LD_ADDR_VAR 0 4
131316: PUSH
131317: LD_EXP 217
131321: PUSH
131322: LD_VAR 0 1
131326: ARRAY
131327: PUSH
131328: LD_VAR 0 2
131332: ARRAY
131333: PUSH
131334: LD_INT 1
131336: ARRAY
131337: PPUSH
131338: LD_EXP 217
131342: PUSH
131343: LD_VAR 0 1
131347: ARRAY
131348: PUSH
131349: LD_VAR 0 2
131353: ARRAY
131354: PUSH
131355: LD_INT 2
131357: ARRAY
131358: PPUSH
131359: CALL_OW 428
131363: ST_TO_ADDR
// if not tmp then
131364: LD_VAR 0 4
131368: NOT
131369: IFFALSE 131373
// continue ;
131371: GO 131288
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
131373: LD_VAR 0 4
131377: PUSH
131378: LD_INT 81
131380: PUSH
131381: LD_VAR 0 3
131385: PUSH
131386: EMPTY
131387: LIST
131388: LIST
131389: PPUSH
131390: CALL_OW 69
131394: IN
131395: PUSH
131396: LD_EXP 217
131400: PUSH
131401: LD_VAR 0 1
131405: ARRAY
131406: PUSH
131407: LD_VAR 0 2
131411: ARRAY
131412: PUSH
131413: LD_INT 1
131415: ARRAY
131416: PPUSH
131417: LD_EXP 217
131421: PUSH
131422: LD_VAR 0 1
131426: ARRAY
131427: PUSH
131428: LD_VAR 0 2
131432: ARRAY
131433: PUSH
131434: LD_INT 2
131436: ARRAY
131437: PPUSH
131438: CALL_OW 458
131442: AND
131443: IFFALSE 131537
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
131445: LD_EXP 217
131449: PUSH
131450: LD_VAR 0 1
131454: ARRAY
131455: PUSH
131456: LD_VAR 0 2
131460: ARRAY
131461: PUSH
131462: LD_INT 1
131464: ARRAY
131465: PPUSH
131466: LD_EXP 217
131470: PUSH
131471: LD_VAR 0 1
131475: ARRAY
131476: PUSH
131477: LD_VAR 0 2
131481: ARRAY
131482: PUSH
131483: LD_INT 2
131485: ARRAY
131486: PPUSH
131487: LD_VAR 0 3
131491: PPUSH
131492: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
131496: LD_ADDR_EXP 217
131500: PUSH
131501: LD_EXP 217
131505: PPUSH
131506: LD_VAR 0 1
131510: PPUSH
131511: LD_EXP 217
131515: PUSH
131516: LD_VAR 0 1
131520: ARRAY
131521: PPUSH
131522: LD_VAR 0 2
131526: PPUSH
131527: CALL_OW 3
131531: PPUSH
131532: CALL_OW 1
131536: ST_TO_ADDR
// end ; end ;
131537: GO 131288
131539: POP
131540: POP
// end ;
131541: GO 131206
131543: POP
131544: POP
// end ;
131545: PPOPN 4
131547: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
131548: LD_INT 0
131550: PPUSH
131551: PPUSH
// result := false ;
131552: LD_ADDR_VAR 0 4
131556: PUSH
131557: LD_INT 0
131559: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
131560: LD_VAR 0 1
131564: PPUSH
131565: CALL_OW 264
131569: PUSH
131570: LD_INT 81
131572: EQUAL
131573: NOT
131574: IFFALSE 131578
// exit ;
131576: GO 131818
// index := GetElementIndex ( minersList , unit ) ;
131578: LD_ADDR_VAR 0 5
131582: PUSH
131583: LD_EXP 216
131587: PPUSH
131588: LD_VAR 0 1
131592: PPUSH
131593: CALL 74292 0 2
131597: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
131598: LD_EXP 217
131602: PUSH
131603: LD_VAR 0 5
131607: ARRAY
131608: PUSH
131609: LD_EXP 218
131613: GREATEREQUAL
131614: IFFALSE 131618
// exit ;
131616: GO 131818
// ComMoveXY ( unit , x , y ) ;
131618: LD_VAR 0 1
131622: PPUSH
131623: LD_VAR 0 2
131627: PPUSH
131628: LD_VAR 0 3
131632: PPUSH
131633: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
131637: LD_INT 35
131639: PPUSH
131640: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
131644: LD_VAR 0 1
131648: PPUSH
131649: LD_VAR 0 2
131653: PPUSH
131654: LD_VAR 0 3
131658: PPUSH
131659: CALL 106033 0 3
131663: NOT
131664: PUSH
131665: LD_VAR 0 1
131669: PPUSH
131670: CALL_OW 314
131674: AND
131675: IFFALSE 131679
// exit ;
131677: GO 131818
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
131679: LD_VAR 0 2
131683: PPUSH
131684: LD_VAR 0 3
131688: PPUSH
131689: CALL_OW 428
131693: PUSH
131694: LD_VAR 0 1
131698: EQUAL
131699: PUSH
131700: LD_VAR 0 1
131704: PPUSH
131705: CALL_OW 314
131709: NOT
131710: AND
131711: IFFALSE 131637
// PlaySoundXY ( x , y , PlantMine ) ;
131713: LD_VAR 0 2
131717: PPUSH
131718: LD_VAR 0 3
131722: PPUSH
131723: LD_STRING PlantMine
131725: PPUSH
131726: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
131730: LD_VAR 0 2
131734: PPUSH
131735: LD_VAR 0 3
131739: PPUSH
131740: LD_VAR 0 1
131744: PPUSH
131745: CALL_OW 255
131749: PPUSH
131750: LD_INT 0
131752: PPUSH
131753: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
131757: LD_ADDR_EXP 217
131761: PUSH
131762: LD_EXP 217
131766: PPUSH
131767: LD_VAR 0 5
131771: PUSH
131772: LD_EXP 217
131776: PUSH
131777: LD_VAR 0 5
131781: ARRAY
131782: PUSH
131783: LD_INT 1
131785: PLUS
131786: PUSH
131787: EMPTY
131788: LIST
131789: LIST
131790: PPUSH
131791: LD_VAR 0 2
131795: PUSH
131796: LD_VAR 0 3
131800: PUSH
131801: EMPTY
131802: LIST
131803: LIST
131804: PPUSH
131805: CALL 74507 0 3
131809: ST_TO_ADDR
// result := true ;
131810: LD_ADDR_VAR 0 4
131814: PUSH
131815: LD_INT 1
131817: ST_TO_ADDR
// end ;
131818: LD_VAR 0 4
131822: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
131823: LD_INT 0
131825: PPUSH
131826: PPUSH
131827: PPUSH
// if not unit in minersList then
131828: LD_VAR 0 1
131832: PUSH
131833: LD_EXP 216
131837: IN
131838: NOT
131839: IFFALSE 131843
// exit ;
131841: GO 132235
// index := GetElementIndex ( minersList , unit ) ;
131843: LD_ADDR_VAR 0 6
131847: PUSH
131848: LD_EXP 216
131852: PPUSH
131853: LD_VAR 0 1
131857: PPUSH
131858: CALL 74292 0 2
131862: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
131863: LD_ADDR_VAR 0 5
131867: PUSH
131868: DOUBLE
131869: LD_EXP 217
131873: PUSH
131874: LD_VAR 0 6
131878: ARRAY
131879: INC
131880: ST_TO_ADDR
131881: LD_INT 1
131883: PUSH
131884: FOR_DOWNTO
131885: IFFALSE 132046
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
131887: LD_EXP 217
131891: PUSH
131892: LD_VAR 0 6
131896: ARRAY
131897: PUSH
131898: LD_VAR 0 5
131902: ARRAY
131903: PUSH
131904: LD_INT 1
131906: ARRAY
131907: PUSH
131908: LD_VAR 0 2
131912: EQUAL
131913: PUSH
131914: LD_EXP 217
131918: PUSH
131919: LD_VAR 0 6
131923: ARRAY
131924: PUSH
131925: LD_VAR 0 5
131929: ARRAY
131930: PUSH
131931: LD_INT 2
131933: ARRAY
131934: PUSH
131935: LD_VAR 0 3
131939: EQUAL
131940: AND
131941: IFFALSE 132044
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
131943: LD_EXP 217
131947: PUSH
131948: LD_VAR 0 6
131952: ARRAY
131953: PUSH
131954: LD_VAR 0 5
131958: ARRAY
131959: PUSH
131960: LD_INT 1
131962: ARRAY
131963: PPUSH
131964: LD_EXP 217
131968: PUSH
131969: LD_VAR 0 6
131973: ARRAY
131974: PUSH
131975: LD_VAR 0 5
131979: ARRAY
131980: PUSH
131981: LD_INT 2
131983: ARRAY
131984: PPUSH
131985: LD_VAR 0 1
131989: PPUSH
131990: CALL_OW 255
131994: PPUSH
131995: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
131999: LD_ADDR_EXP 217
132003: PUSH
132004: LD_EXP 217
132008: PPUSH
132009: LD_VAR 0 6
132013: PPUSH
132014: LD_EXP 217
132018: PUSH
132019: LD_VAR 0 6
132023: ARRAY
132024: PPUSH
132025: LD_VAR 0 5
132029: PPUSH
132030: CALL_OW 3
132034: PPUSH
132035: CALL_OW 1
132039: ST_TO_ADDR
// exit ;
132040: POP
132041: POP
132042: GO 132235
// end ; end ;
132044: GO 131884
132046: POP
132047: POP
// for i := minerMinesList [ index ] downto 1 do
132048: LD_ADDR_VAR 0 5
132052: PUSH
132053: DOUBLE
132054: LD_EXP 217
132058: PUSH
132059: LD_VAR 0 6
132063: ARRAY
132064: INC
132065: ST_TO_ADDR
132066: LD_INT 1
132068: PUSH
132069: FOR_DOWNTO
132070: IFFALSE 132233
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
132072: LD_EXP 217
132076: PUSH
132077: LD_VAR 0 6
132081: ARRAY
132082: PUSH
132083: LD_VAR 0 5
132087: ARRAY
132088: PUSH
132089: LD_INT 1
132091: ARRAY
132092: PPUSH
132093: LD_EXP 217
132097: PUSH
132098: LD_VAR 0 6
132102: ARRAY
132103: PUSH
132104: LD_VAR 0 5
132108: ARRAY
132109: PUSH
132110: LD_INT 2
132112: ARRAY
132113: PPUSH
132114: LD_VAR 0 2
132118: PPUSH
132119: LD_VAR 0 3
132123: PPUSH
132124: CALL_OW 298
132128: PUSH
132129: LD_INT 6
132131: LESS
132132: IFFALSE 132231
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
132134: LD_EXP 217
132138: PUSH
132139: LD_VAR 0 6
132143: ARRAY
132144: PUSH
132145: LD_VAR 0 5
132149: ARRAY
132150: PUSH
132151: LD_INT 1
132153: ARRAY
132154: PPUSH
132155: LD_EXP 217
132159: PUSH
132160: LD_VAR 0 6
132164: ARRAY
132165: PUSH
132166: LD_VAR 0 5
132170: ARRAY
132171: PUSH
132172: LD_INT 2
132174: ARRAY
132175: PPUSH
132176: LD_VAR 0 1
132180: PPUSH
132181: CALL_OW 255
132185: PPUSH
132186: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
132190: LD_ADDR_EXP 217
132194: PUSH
132195: LD_EXP 217
132199: PPUSH
132200: LD_VAR 0 6
132204: PPUSH
132205: LD_EXP 217
132209: PUSH
132210: LD_VAR 0 6
132214: ARRAY
132215: PPUSH
132216: LD_VAR 0 5
132220: PPUSH
132221: CALL_OW 3
132225: PPUSH
132226: CALL_OW 1
132230: ST_TO_ADDR
// end ; end ;
132231: GO 132069
132233: POP
132234: POP
// end ;
132235: LD_VAR 0 4
132239: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
132240: LD_INT 0
132242: PPUSH
132243: PPUSH
132244: PPUSH
132245: PPUSH
132246: PPUSH
132247: PPUSH
132248: PPUSH
132249: PPUSH
132250: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
132251: LD_VAR 0 1
132255: PPUSH
132256: CALL_OW 264
132260: PUSH
132261: LD_INT 81
132263: EQUAL
132264: NOT
132265: PUSH
132266: LD_VAR 0 1
132270: PUSH
132271: LD_EXP 216
132275: IN
132276: NOT
132277: OR
132278: IFFALSE 132282
// exit ;
132280: GO 132604
// index := GetElementIndex ( minersList , unit ) ;
132282: LD_ADDR_VAR 0 6
132286: PUSH
132287: LD_EXP 216
132291: PPUSH
132292: LD_VAR 0 1
132296: PPUSH
132297: CALL 74292 0 2
132301: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
132302: LD_ADDR_VAR 0 8
132306: PUSH
132307: LD_EXP 218
132311: PUSH
132312: LD_EXP 217
132316: PUSH
132317: LD_VAR 0 6
132321: ARRAY
132322: MINUS
132323: ST_TO_ADDR
// if not minesFreeAmount then
132324: LD_VAR 0 8
132328: NOT
132329: IFFALSE 132333
// exit ;
132331: GO 132604
// tmp := [ ] ;
132333: LD_ADDR_VAR 0 7
132337: PUSH
132338: EMPTY
132339: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
132340: LD_ADDR_VAR 0 5
132344: PUSH
132345: DOUBLE
132346: LD_INT 1
132348: DEC
132349: ST_TO_ADDR
132350: LD_VAR 0 8
132354: PUSH
132355: FOR_TO
132356: IFFALSE 132551
// begin _d := rand ( 0 , 5 ) ;
132358: LD_ADDR_VAR 0 11
132362: PUSH
132363: LD_INT 0
132365: PPUSH
132366: LD_INT 5
132368: PPUSH
132369: CALL_OW 12
132373: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
132374: LD_ADDR_VAR 0 12
132378: PUSH
132379: LD_INT 2
132381: PPUSH
132382: LD_INT 6
132384: PPUSH
132385: CALL_OW 12
132389: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
132390: LD_ADDR_VAR 0 9
132394: PUSH
132395: LD_VAR 0 2
132399: PPUSH
132400: LD_VAR 0 11
132404: PPUSH
132405: LD_VAR 0 12
132409: PPUSH
132410: CALL_OW 272
132414: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
132415: LD_ADDR_VAR 0 10
132419: PUSH
132420: LD_VAR 0 3
132424: PPUSH
132425: LD_VAR 0 11
132429: PPUSH
132430: LD_VAR 0 12
132434: PPUSH
132435: CALL_OW 273
132439: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
132440: LD_VAR 0 9
132444: PPUSH
132445: LD_VAR 0 10
132449: PPUSH
132450: CALL_OW 488
132454: PUSH
132455: LD_VAR 0 9
132459: PUSH
132460: LD_VAR 0 10
132464: PUSH
132465: EMPTY
132466: LIST
132467: LIST
132468: PUSH
132469: LD_VAR 0 7
132473: IN
132474: NOT
132475: AND
132476: PUSH
132477: LD_VAR 0 9
132481: PPUSH
132482: LD_VAR 0 10
132486: PPUSH
132487: CALL_OW 458
132491: NOT
132492: AND
132493: IFFALSE 132535
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
132495: LD_ADDR_VAR 0 7
132499: PUSH
132500: LD_VAR 0 7
132504: PPUSH
132505: LD_VAR 0 7
132509: PUSH
132510: LD_INT 1
132512: PLUS
132513: PPUSH
132514: LD_VAR 0 9
132518: PUSH
132519: LD_VAR 0 10
132523: PUSH
132524: EMPTY
132525: LIST
132526: LIST
132527: PPUSH
132528: CALL_OW 1
132532: ST_TO_ADDR
132533: GO 132549
// i := i - 1 ;
132535: LD_ADDR_VAR 0 5
132539: PUSH
132540: LD_VAR 0 5
132544: PUSH
132545: LD_INT 1
132547: MINUS
132548: ST_TO_ADDR
// end ;
132549: GO 132355
132551: POP
132552: POP
// for i in tmp do
132553: LD_ADDR_VAR 0 5
132557: PUSH
132558: LD_VAR 0 7
132562: PUSH
132563: FOR_IN
132564: IFFALSE 132602
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
132566: LD_VAR 0 1
132570: PPUSH
132571: LD_VAR 0 5
132575: PUSH
132576: LD_INT 1
132578: ARRAY
132579: PPUSH
132580: LD_VAR 0 5
132584: PUSH
132585: LD_INT 2
132587: ARRAY
132588: PPUSH
132589: CALL 131548 0 3
132593: NOT
132594: IFFALSE 132600
// exit ;
132596: POP
132597: POP
132598: GO 132604
132600: GO 132563
132602: POP
132603: POP
// end ;
132604: LD_VAR 0 4
132608: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
132609: LD_INT 0
132611: PPUSH
132612: PPUSH
132613: PPUSH
132614: PPUSH
132615: PPUSH
132616: PPUSH
132617: PPUSH
// if not GetClass ( unit ) = class_sniper then
132618: LD_VAR 0 1
132622: PPUSH
132623: CALL_OW 257
132627: PUSH
132628: LD_INT 5
132630: EQUAL
132631: NOT
132632: IFFALSE 132636
// exit ;
132634: GO 133024
// dist := 8 ;
132636: LD_ADDR_VAR 0 5
132640: PUSH
132641: LD_INT 8
132643: ST_TO_ADDR
// viewRange := 12 ;
132644: LD_ADDR_VAR 0 7
132648: PUSH
132649: LD_INT 12
132651: ST_TO_ADDR
// side := GetSide ( unit ) ;
132652: LD_ADDR_VAR 0 6
132656: PUSH
132657: LD_VAR 0 1
132661: PPUSH
132662: CALL_OW 255
132666: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
132667: LD_INT 61
132669: PPUSH
132670: LD_VAR 0 6
132674: PPUSH
132675: CALL_OW 321
132679: PUSH
132680: LD_INT 2
132682: EQUAL
132683: IFFALSE 132693
// viewRange := 16 ;
132685: LD_ADDR_VAR 0 7
132689: PUSH
132690: LD_INT 16
132692: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
132693: LD_VAR 0 1
132697: PPUSH
132698: LD_VAR 0 2
132702: PPUSH
132703: LD_VAR 0 3
132707: PPUSH
132708: CALL_OW 297
132712: PUSH
132713: LD_VAR 0 5
132717: GREATER
132718: IFFALSE 132797
// begin ComMoveXY ( unit , x , y ) ;
132720: LD_VAR 0 1
132724: PPUSH
132725: LD_VAR 0 2
132729: PPUSH
132730: LD_VAR 0 3
132734: PPUSH
132735: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
132739: LD_INT 35
132741: PPUSH
132742: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
132746: LD_VAR 0 1
132750: PPUSH
132751: LD_VAR 0 2
132755: PPUSH
132756: LD_VAR 0 3
132760: PPUSH
132761: CALL 106033 0 3
132765: NOT
132766: IFFALSE 132770
// exit ;
132768: GO 133024
// until GetDistUnitXY ( unit , x , y ) < dist ;
132770: LD_VAR 0 1
132774: PPUSH
132775: LD_VAR 0 2
132779: PPUSH
132780: LD_VAR 0 3
132784: PPUSH
132785: CALL_OW 297
132789: PUSH
132790: LD_VAR 0 5
132794: LESS
132795: IFFALSE 132739
// end ; ComTurnXY ( unit , x , y ) ;
132797: LD_VAR 0 1
132801: PPUSH
132802: LD_VAR 0 2
132806: PPUSH
132807: LD_VAR 0 3
132811: PPUSH
132812: CALL_OW 118
// wait ( 5 ) ;
132816: LD_INT 5
132818: PPUSH
132819: CALL_OW 67
// _d := GetDir ( unit ) ;
132823: LD_ADDR_VAR 0 10
132827: PUSH
132828: LD_VAR 0 1
132832: PPUSH
132833: CALL_OW 254
132837: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
132838: LD_ADDR_VAR 0 8
132842: PUSH
132843: LD_VAR 0 1
132847: PPUSH
132848: CALL_OW 250
132852: PPUSH
132853: LD_VAR 0 10
132857: PPUSH
132858: LD_VAR 0 5
132862: PPUSH
132863: CALL_OW 272
132867: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
132868: LD_ADDR_VAR 0 9
132872: PUSH
132873: LD_VAR 0 1
132877: PPUSH
132878: CALL_OW 251
132882: PPUSH
132883: LD_VAR 0 10
132887: PPUSH
132888: LD_VAR 0 5
132892: PPUSH
132893: CALL_OW 273
132897: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
132898: LD_VAR 0 8
132902: PPUSH
132903: LD_VAR 0 9
132907: PPUSH
132908: CALL_OW 488
132912: NOT
132913: IFFALSE 132917
// exit ;
132915: GO 133024
// ComAnimCustom ( unit , 1 ) ;
132917: LD_VAR 0 1
132921: PPUSH
132922: LD_INT 1
132924: PPUSH
132925: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
132929: LD_VAR 0 8
132933: PPUSH
132934: LD_VAR 0 9
132938: PPUSH
132939: LD_VAR 0 6
132943: PPUSH
132944: LD_VAR 0 7
132948: PPUSH
132949: CALL_OW 330
// repeat wait ( 1 ) ;
132953: LD_INT 1
132955: PPUSH
132956: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
132960: LD_VAR 0 1
132964: PPUSH
132965: CALL_OW 316
132969: PUSH
132970: LD_VAR 0 1
132974: PPUSH
132975: CALL_OW 314
132979: OR
132980: PUSH
132981: LD_VAR 0 1
132985: PPUSH
132986: CALL_OW 302
132990: NOT
132991: OR
132992: PUSH
132993: LD_VAR 0 1
132997: PPUSH
132998: CALL_OW 301
133002: OR
133003: IFFALSE 132953
// RemoveSeeing ( _x , _y , side ) ;
133005: LD_VAR 0 8
133009: PPUSH
133010: LD_VAR 0 9
133014: PPUSH
133015: LD_VAR 0 6
133019: PPUSH
133020: CALL_OW 331
// end ; end_of_file
133024: LD_VAR 0 4
133028: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
133029: LD_INT 0
133031: PPUSH
133032: PPUSH
133033: PPUSH
133034: PPUSH
133035: PPUSH
133036: PPUSH
133037: PPUSH
133038: PPUSH
133039: PPUSH
133040: PPUSH
133041: PPUSH
133042: PPUSH
133043: PPUSH
133044: PPUSH
133045: PPUSH
133046: PPUSH
133047: PPUSH
133048: PPUSH
133049: PPUSH
133050: PPUSH
133051: PPUSH
133052: PPUSH
133053: PPUSH
133054: PPUSH
133055: PPUSH
133056: PPUSH
133057: PPUSH
133058: PPUSH
133059: PPUSH
133060: PPUSH
133061: PPUSH
133062: PPUSH
133063: PPUSH
133064: PPUSH
// if not list then
133065: LD_VAR 0 1
133069: NOT
133070: IFFALSE 133074
// exit ;
133072: GO 137733
// base := list [ 1 ] ;
133074: LD_ADDR_VAR 0 3
133078: PUSH
133079: LD_VAR 0 1
133083: PUSH
133084: LD_INT 1
133086: ARRAY
133087: ST_TO_ADDR
// group := list [ 2 ] ;
133088: LD_ADDR_VAR 0 4
133092: PUSH
133093: LD_VAR 0 1
133097: PUSH
133098: LD_INT 2
133100: ARRAY
133101: ST_TO_ADDR
// path := list [ 3 ] ;
133102: LD_ADDR_VAR 0 5
133106: PUSH
133107: LD_VAR 0 1
133111: PUSH
133112: LD_INT 3
133114: ARRAY
133115: ST_TO_ADDR
// flags := list [ 4 ] ;
133116: LD_ADDR_VAR 0 6
133120: PUSH
133121: LD_VAR 0 1
133125: PUSH
133126: LD_INT 4
133128: ARRAY
133129: ST_TO_ADDR
// mined := [ ] ;
133130: LD_ADDR_VAR 0 27
133134: PUSH
133135: EMPTY
133136: ST_TO_ADDR
// bombed := [ ] ;
133137: LD_ADDR_VAR 0 28
133141: PUSH
133142: EMPTY
133143: ST_TO_ADDR
// healers := [ ] ;
133144: LD_ADDR_VAR 0 31
133148: PUSH
133149: EMPTY
133150: ST_TO_ADDR
// to_heal := [ ] ;
133151: LD_ADDR_VAR 0 30
133155: PUSH
133156: EMPTY
133157: ST_TO_ADDR
// repairs := [ ] ;
133158: LD_ADDR_VAR 0 33
133162: PUSH
133163: EMPTY
133164: ST_TO_ADDR
// to_repair := [ ] ;
133165: LD_ADDR_VAR 0 32
133169: PUSH
133170: EMPTY
133171: ST_TO_ADDR
// if not group or not path then
133172: LD_VAR 0 4
133176: NOT
133177: PUSH
133178: LD_VAR 0 5
133182: NOT
133183: OR
133184: IFFALSE 133188
// exit ;
133186: GO 137733
// side := GetSide ( group [ 1 ] ) ;
133188: LD_ADDR_VAR 0 35
133192: PUSH
133193: LD_VAR 0 4
133197: PUSH
133198: LD_INT 1
133200: ARRAY
133201: PPUSH
133202: CALL_OW 255
133206: ST_TO_ADDR
// if flags then
133207: LD_VAR 0 6
133211: IFFALSE 133355
// begin f_ignore_area := flags [ 1 ] ;
133213: LD_ADDR_VAR 0 17
133217: PUSH
133218: LD_VAR 0 6
133222: PUSH
133223: LD_INT 1
133225: ARRAY
133226: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
133227: LD_ADDR_VAR 0 18
133231: PUSH
133232: LD_VAR 0 6
133236: PUSH
133237: LD_INT 2
133239: ARRAY
133240: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
133241: LD_ADDR_VAR 0 19
133245: PUSH
133246: LD_VAR 0 6
133250: PUSH
133251: LD_INT 3
133253: ARRAY
133254: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
133255: LD_ADDR_VAR 0 20
133259: PUSH
133260: LD_VAR 0 6
133264: PUSH
133265: LD_INT 4
133267: ARRAY
133268: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
133269: LD_ADDR_VAR 0 21
133273: PUSH
133274: LD_VAR 0 6
133278: PUSH
133279: LD_INT 5
133281: ARRAY
133282: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
133283: LD_ADDR_VAR 0 22
133287: PUSH
133288: LD_VAR 0 6
133292: PUSH
133293: LD_INT 6
133295: ARRAY
133296: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
133297: LD_ADDR_VAR 0 23
133301: PUSH
133302: LD_VAR 0 6
133306: PUSH
133307: LD_INT 7
133309: ARRAY
133310: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
133311: LD_ADDR_VAR 0 24
133315: PUSH
133316: LD_VAR 0 6
133320: PUSH
133321: LD_INT 8
133323: ARRAY
133324: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
133325: LD_ADDR_VAR 0 25
133329: PUSH
133330: LD_VAR 0 6
133334: PUSH
133335: LD_INT 9
133337: ARRAY
133338: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
133339: LD_ADDR_VAR 0 26
133343: PUSH
133344: LD_VAR 0 6
133348: PUSH
133349: LD_INT 10
133351: ARRAY
133352: ST_TO_ADDR
// end else
133353: GO 133435
// begin f_ignore_area := false ;
133355: LD_ADDR_VAR 0 17
133359: PUSH
133360: LD_INT 0
133362: ST_TO_ADDR
// f_capture := false ;
133363: LD_ADDR_VAR 0 18
133367: PUSH
133368: LD_INT 0
133370: ST_TO_ADDR
// f_ignore_civ := false ;
133371: LD_ADDR_VAR 0 19
133375: PUSH
133376: LD_INT 0
133378: ST_TO_ADDR
// f_murder := false ;
133379: LD_ADDR_VAR 0 20
133383: PUSH
133384: LD_INT 0
133386: ST_TO_ADDR
// f_mines := false ;
133387: LD_ADDR_VAR 0 21
133391: PUSH
133392: LD_INT 0
133394: ST_TO_ADDR
// f_repair := false ;
133395: LD_ADDR_VAR 0 22
133399: PUSH
133400: LD_INT 0
133402: ST_TO_ADDR
// f_heal := false ;
133403: LD_ADDR_VAR 0 23
133407: PUSH
133408: LD_INT 0
133410: ST_TO_ADDR
// f_spacetime := false ;
133411: LD_ADDR_VAR 0 24
133415: PUSH
133416: LD_INT 0
133418: ST_TO_ADDR
// f_attack_depot := false ;
133419: LD_ADDR_VAR 0 25
133423: PUSH
133424: LD_INT 0
133426: ST_TO_ADDR
// f_crawl := false ;
133427: LD_ADDR_VAR 0 26
133431: PUSH
133432: LD_INT 0
133434: ST_TO_ADDR
// end ; if f_heal then
133435: LD_VAR 0 23
133439: IFFALSE 133466
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
133441: LD_ADDR_VAR 0 31
133445: PUSH
133446: LD_VAR 0 4
133450: PPUSH
133451: LD_INT 25
133453: PUSH
133454: LD_INT 4
133456: PUSH
133457: EMPTY
133458: LIST
133459: LIST
133460: PPUSH
133461: CALL_OW 72
133465: ST_TO_ADDR
// if f_repair then
133466: LD_VAR 0 22
133470: IFFALSE 133497
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
133472: LD_ADDR_VAR 0 33
133476: PUSH
133477: LD_VAR 0 4
133481: PPUSH
133482: LD_INT 25
133484: PUSH
133485: LD_INT 3
133487: PUSH
133488: EMPTY
133489: LIST
133490: LIST
133491: PPUSH
133492: CALL_OW 72
133496: ST_TO_ADDR
// units_path := [ ] ;
133497: LD_ADDR_VAR 0 16
133501: PUSH
133502: EMPTY
133503: ST_TO_ADDR
// for i = 1 to group do
133504: LD_ADDR_VAR 0 7
133508: PUSH
133509: DOUBLE
133510: LD_INT 1
133512: DEC
133513: ST_TO_ADDR
133514: LD_VAR 0 4
133518: PUSH
133519: FOR_TO
133520: IFFALSE 133549
// units_path := Replace ( units_path , i , path ) ;
133522: LD_ADDR_VAR 0 16
133526: PUSH
133527: LD_VAR 0 16
133531: PPUSH
133532: LD_VAR 0 7
133536: PPUSH
133537: LD_VAR 0 5
133541: PPUSH
133542: CALL_OW 1
133546: ST_TO_ADDR
133547: GO 133519
133549: POP
133550: POP
// repeat for i = group downto 1 do
133551: LD_ADDR_VAR 0 7
133555: PUSH
133556: DOUBLE
133557: LD_VAR 0 4
133561: INC
133562: ST_TO_ADDR
133563: LD_INT 1
133565: PUSH
133566: FOR_DOWNTO
133567: IFFALSE 137689
// begin wait ( 5 ) ;
133569: LD_INT 5
133571: PPUSH
133572: CALL_OW 67
// tmp := [ ] ;
133576: LD_ADDR_VAR 0 14
133580: PUSH
133581: EMPTY
133582: ST_TO_ADDR
// attacking := false ;
133583: LD_ADDR_VAR 0 29
133587: PUSH
133588: LD_INT 0
133590: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
133591: LD_VAR 0 4
133595: PUSH
133596: LD_VAR 0 7
133600: ARRAY
133601: PPUSH
133602: CALL_OW 301
133606: PUSH
133607: LD_VAR 0 4
133611: PUSH
133612: LD_VAR 0 7
133616: ARRAY
133617: NOT
133618: OR
133619: IFFALSE 133728
// begin if GetType ( group [ i ] ) = unit_human then
133621: LD_VAR 0 4
133625: PUSH
133626: LD_VAR 0 7
133630: ARRAY
133631: PPUSH
133632: CALL_OW 247
133636: PUSH
133637: LD_INT 1
133639: EQUAL
133640: IFFALSE 133686
// begin to_heal := to_heal diff group [ i ] ;
133642: LD_ADDR_VAR 0 30
133646: PUSH
133647: LD_VAR 0 30
133651: PUSH
133652: LD_VAR 0 4
133656: PUSH
133657: LD_VAR 0 7
133661: ARRAY
133662: DIFF
133663: ST_TO_ADDR
// healers := healers diff group [ i ] ;
133664: LD_ADDR_VAR 0 31
133668: PUSH
133669: LD_VAR 0 31
133673: PUSH
133674: LD_VAR 0 4
133678: PUSH
133679: LD_VAR 0 7
133683: ARRAY
133684: DIFF
133685: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
133686: LD_ADDR_VAR 0 4
133690: PUSH
133691: LD_VAR 0 4
133695: PPUSH
133696: LD_VAR 0 7
133700: PPUSH
133701: CALL_OW 3
133705: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
133706: LD_ADDR_VAR 0 16
133710: PUSH
133711: LD_VAR 0 16
133715: PPUSH
133716: LD_VAR 0 7
133720: PPUSH
133721: CALL_OW 3
133725: ST_TO_ADDR
// continue ;
133726: GO 133566
// end ; if f_repair then
133728: LD_VAR 0 22
133732: IFFALSE 134221
// begin if GetType ( group [ i ] ) = unit_vehicle then
133734: LD_VAR 0 4
133738: PUSH
133739: LD_VAR 0 7
133743: ARRAY
133744: PPUSH
133745: CALL_OW 247
133749: PUSH
133750: LD_INT 2
133752: EQUAL
133753: IFFALSE 133943
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
133755: LD_VAR 0 4
133759: PUSH
133760: LD_VAR 0 7
133764: ARRAY
133765: PPUSH
133766: CALL_OW 256
133770: PUSH
133771: LD_INT 700
133773: LESS
133774: PUSH
133775: LD_VAR 0 4
133779: PUSH
133780: LD_VAR 0 7
133784: ARRAY
133785: PUSH
133786: LD_VAR 0 32
133790: IN
133791: NOT
133792: AND
133793: IFFALSE 133817
// to_repair := to_repair union group [ i ] ;
133795: LD_ADDR_VAR 0 32
133799: PUSH
133800: LD_VAR 0 32
133804: PUSH
133805: LD_VAR 0 4
133809: PUSH
133810: LD_VAR 0 7
133814: ARRAY
133815: UNION
133816: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
133817: LD_VAR 0 4
133821: PUSH
133822: LD_VAR 0 7
133826: ARRAY
133827: PPUSH
133828: CALL_OW 256
133832: PUSH
133833: LD_INT 1000
133835: EQUAL
133836: PUSH
133837: LD_VAR 0 4
133841: PUSH
133842: LD_VAR 0 7
133846: ARRAY
133847: PUSH
133848: LD_VAR 0 32
133852: IN
133853: AND
133854: IFFALSE 133878
// to_repair := to_repair diff group [ i ] ;
133856: LD_ADDR_VAR 0 32
133860: PUSH
133861: LD_VAR 0 32
133865: PUSH
133866: LD_VAR 0 4
133870: PUSH
133871: LD_VAR 0 7
133875: ARRAY
133876: DIFF
133877: ST_TO_ADDR
// if group [ i ] in to_repair then
133878: LD_VAR 0 4
133882: PUSH
133883: LD_VAR 0 7
133887: ARRAY
133888: PUSH
133889: LD_VAR 0 32
133893: IN
133894: IFFALSE 133941
// begin if not IsInArea ( group [ i ] , f_repair ) then
133896: LD_VAR 0 4
133900: PUSH
133901: LD_VAR 0 7
133905: ARRAY
133906: PPUSH
133907: LD_VAR 0 22
133911: PPUSH
133912: CALL_OW 308
133916: NOT
133917: IFFALSE 133939
// ComMoveToArea ( group [ i ] , f_repair ) ;
133919: LD_VAR 0 4
133923: PUSH
133924: LD_VAR 0 7
133928: ARRAY
133929: PPUSH
133930: LD_VAR 0 22
133934: PPUSH
133935: CALL_OW 113
// continue ;
133939: GO 133566
// end ; end else
133941: GO 134221
// if group [ i ] in repairs then
133943: LD_VAR 0 4
133947: PUSH
133948: LD_VAR 0 7
133952: ARRAY
133953: PUSH
133954: LD_VAR 0 33
133958: IN
133959: IFFALSE 134221
// begin if IsInUnit ( group [ i ] ) then
133961: LD_VAR 0 4
133965: PUSH
133966: LD_VAR 0 7
133970: ARRAY
133971: PPUSH
133972: CALL_OW 310
133976: IFFALSE 134044
// begin z := IsInUnit ( group [ i ] ) ;
133978: LD_ADDR_VAR 0 13
133982: PUSH
133983: LD_VAR 0 4
133987: PUSH
133988: LD_VAR 0 7
133992: ARRAY
133993: PPUSH
133994: CALL_OW 310
133998: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
133999: LD_VAR 0 13
134003: PUSH
134004: LD_VAR 0 32
134008: IN
134009: PUSH
134010: LD_VAR 0 13
134014: PPUSH
134015: LD_VAR 0 22
134019: PPUSH
134020: CALL_OW 308
134024: AND
134025: IFFALSE 134042
// ComExitVehicle ( group [ i ] ) ;
134027: LD_VAR 0 4
134031: PUSH
134032: LD_VAR 0 7
134036: ARRAY
134037: PPUSH
134038: CALL_OW 121
// end else
134042: GO 134221
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
134044: LD_ADDR_VAR 0 13
134048: PUSH
134049: LD_VAR 0 4
134053: PPUSH
134054: LD_INT 95
134056: PUSH
134057: LD_VAR 0 22
134061: PUSH
134062: EMPTY
134063: LIST
134064: LIST
134065: PUSH
134066: LD_INT 58
134068: PUSH
134069: EMPTY
134070: LIST
134071: PUSH
134072: EMPTY
134073: LIST
134074: LIST
134075: PPUSH
134076: CALL_OW 72
134080: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
134081: LD_VAR 0 4
134085: PUSH
134086: LD_VAR 0 7
134090: ARRAY
134091: PPUSH
134092: CALL_OW 314
134096: NOT
134097: IFFALSE 134219
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
134099: LD_ADDR_VAR 0 10
134103: PUSH
134104: LD_VAR 0 13
134108: PPUSH
134109: LD_VAR 0 4
134113: PUSH
134114: LD_VAR 0 7
134118: ARRAY
134119: PPUSH
134120: CALL_OW 74
134124: ST_TO_ADDR
// if not x then
134125: LD_VAR 0 10
134129: NOT
134130: IFFALSE 134134
// continue ;
134132: GO 133566
// if GetLives ( x ) < 1000 then
134134: LD_VAR 0 10
134138: PPUSH
134139: CALL_OW 256
134143: PUSH
134144: LD_INT 1000
134146: LESS
134147: IFFALSE 134171
// ComRepairVehicle ( group [ i ] , x ) else
134149: LD_VAR 0 4
134153: PUSH
134154: LD_VAR 0 7
134158: ARRAY
134159: PPUSH
134160: LD_VAR 0 10
134164: PPUSH
134165: CALL_OW 129
134169: GO 134219
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
134171: LD_VAR 0 23
134175: PUSH
134176: LD_VAR 0 4
134180: PUSH
134181: LD_VAR 0 7
134185: ARRAY
134186: PPUSH
134187: CALL_OW 256
134191: PUSH
134192: LD_INT 1000
134194: LESS
134195: AND
134196: NOT
134197: IFFALSE 134219
// ComEnterUnit ( group [ i ] , x ) ;
134199: LD_VAR 0 4
134203: PUSH
134204: LD_VAR 0 7
134208: ARRAY
134209: PPUSH
134210: LD_VAR 0 10
134214: PPUSH
134215: CALL_OW 120
// end ; continue ;
134219: GO 133566
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
134221: LD_VAR 0 23
134225: PUSH
134226: LD_VAR 0 4
134230: PUSH
134231: LD_VAR 0 7
134235: ARRAY
134236: PPUSH
134237: CALL_OW 247
134241: PUSH
134242: LD_INT 1
134244: EQUAL
134245: AND
134246: IFFALSE 134724
// begin if group [ i ] in healers then
134248: LD_VAR 0 4
134252: PUSH
134253: LD_VAR 0 7
134257: ARRAY
134258: PUSH
134259: LD_VAR 0 31
134263: IN
134264: IFFALSE 134537
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
134266: LD_VAR 0 4
134270: PUSH
134271: LD_VAR 0 7
134275: ARRAY
134276: PPUSH
134277: LD_VAR 0 23
134281: PPUSH
134282: CALL_OW 308
134286: NOT
134287: PUSH
134288: LD_VAR 0 4
134292: PUSH
134293: LD_VAR 0 7
134297: ARRAY
134298: PPUSH
134299: CALL_OW 314
134303: NOT
134304: AND
134305: IFFALSE 134329
// ComMoveToArea ( group [ i ] , f_heal ) else
134307: LD_VAR 0 4
134311: PUSH
134312: LD_VAR 0 7
134316: ARRAY
134317: PPUSH
134318: LD_VAR 0 23
134322: PPUSH
134323: CALL_OW 113
134327: GO 134535
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
134329: LD_VAR 0 4
134333: PUSH
134334: LD_VAR 0 7
134338: ARRAY
134339: PPUSH
134340: CALL 104616 0 1
134344: PPUSH
134345: CALL_OW 256
134349: PUSH
134350: LD_INT 1000
134352: EQUAL
134353: IFFALSE 134372
// ComStop ( group [ i ] ) else
134355: LD_VAR 0 4
134359: PUSH
134360: LD_VAR 0 7
134364: ARRAY
134365: PPUSH
134366: CALL_OW 141
134370: GO 134535
// if not HasTask ( group [ i ] ) and to_heal then
134372: LD_VAR 0 4
134376: PUSH
134377: LD_VAR 0 7
134381: ARRAY
134382: PPUSH
134383: CALL_OW 314
134387: NOT
134388: PUSH
134389: LD_VAR 0 30
134393: AND
134394: IFFALSE 134535
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
134396: LD_ADDR_VAR 0 13
134400: PUSH
134401: LD_VAR 0 30
134405: PPUSH
134406: LD_INT 3
134408: PUSH
134409: LD_INT 54
134411: PUSH
134412: EMPTY
134413: LIST
134414: PUSH
134415: EMPTY
134416: LIST
134417: LIST
134418: PPUSH
134419: CALL_OW 72
134423: PPUSH
134424: LD_VAR 0 4
134428: PUSH
134429: LD_VAR 0 7
134433: ARRAY
134434: PPUSH
134435: CALL_OW 74
134439: ST_TO_ADDR
// if z then
134440: LD_VAR 0 13
134444: IFFALSE 134535
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
134446: LD_INT 91
134448: PUSH
134449: LD_VAR 0 13
134453: PUSH
134454: LD_INT 10
134456: PUSH
134457: EMPTY
134458: LIST
134459: LIST
134460: LIST
134461: PUSH
134462: LD_INT 81
134464: PUSH
134465: LD_VAR 0 13
134469: PPUSH
134470: CALL_OW 255
134474: PUSH
134475: EMPTY
134476: LIST
134477: LIST
134478: PUSH
134479: EMPTY
134480: LIST
134481: LIST
134482: PPUSH
134483: CALL_OW 69
134487: PUSH
134488: LD_INT 0
134490: EQUAL
134491: IFFALSE 134515
// ComHeal ( group [ i ] , z ) else
134493: LD_VAR 0 4
134497: PUSH
134498: LD_VAR 0 7
134502: ARRAY
134503: PPUSH
134504: LD_VAR 0 13
134508: PPUSH
134509: CALL_OW 128
134513: GO 134535
// ComMoveToArea ( group [ i ] , f_heal ) ;
134515: LD_VAR 0 4
134519: PUSH
134520: LD_VAR 0 7
134524: ARRAY
134525: PPUSH
134526: LD_VAR 0 23
134530: PPUSH
134531: CALL_OW 113
// end ; continue ;
134535: GO 133566
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
134537: LD_VAR 0 4
134541: PUSH
134542: LD_VAR 0 7
134546: ARRAY
134547: PPUSH
134548: CALL_OW 256
134552: PUSH
134553: LD_INT 700
134555: LESS
134556: PUSH
134557: LD_VAR 0 4
134561: PUSH
134562: LD_VAR 0 7
134566: ARRAY
134567: PUSH
134568: LD_VAR 0 30
134572: IN
134573: NOT
134574: AND
134575: IFFALSE 134599
// to_heal := to_heal union group [ i ] ;
134577: LD_ADDR_VAR 0 30
134581: PUSH
134582: LD_VAR 0 30
134586: PUSH
134587: LD_VAR 0 4
134591: PUSH
134592: LD_VAR 0 7
134596: ARRAY
134597: UNION
134598: ST_TO_ADDR
// if group [ i ] in to_heal then
134599: LD_VAR 0 4
134603: PUSH
134604: LD_VAR 0 7
134608: ARRAY
134609: PUSH
134610: LD_VAR 0 30
134614: IN
134615: IFFALSE 134724
// begin if GetLives ( group [ i ] ) = 1000 then
134617: LD_VAR 0 4
134621: PUSH
134622: LD_VAR 0 7
134626: ARRAY
134627: PPUSH
134628: CALL_OW 256
134632: PUSH
134633: LD_INT 1000
134635: EQUAL
134636: IFFALSE 134662
// to_heal := to_heal diff group [ i ] else
134638: LD_ADDR_VAR 0 30
134642: PUSH
134643: LD_VAR 0 30
134647: PUSH
134648: LD_VAR 0 4
134652: PUSH
134653: LD_VAR 0 7
134657: ARRAY
134658: DIFF
134659: ST_TO_ADDR
134660: GO 134724
// begin if not IsInArea ( group [ i ] , to_heal ) then
134662: LD_VAR 0 4
134666: PUSH
134667: LD_VAR 0 7
134671: ARRAY
134672: PPUSH
134673: LD_VAR 0 30
134677: PPUSH
134678: CALL_OW 308
134682: NOT
134683: IFFALSE 134707
// ComMoveToArea ( group [ i ] , f_heal ) else
134685: LD_VAR 0 4
134689: PUSH
134690: LD_VAR 0 7
134694: ARRAY
134695: PPUSH
134696: LD_VAR 0 23
134700: PPUSH
134701: CALL_OW 113
134705: GO 134722
// ComHold ( group [ i ] ) ;
134707: LD_VAR 0 4
134711: PUSH
134712: LD_VAR 0 7
134716: ARRAY
134717: PPUSH
134718: CALL_OW 140
// continue ;
134722: GO 133566
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
134724: LD_VAR 0 4
134728: PUSH
134729: LD_VAR 0 7
134733: ARRAY
134734: PPUSH
134735: LD_INT 10
134737: PPUSH
134738: CALL 102398 0 2
134742: NOT
134743: PUSH
134744: LD_VAR 0 16
134748: PUSH
134749: LD_VAR 0 7
134753: ARRAY
134754: PUSH
134755: EMPTY
134756: EQUAL
134757: NOT
134758: AND
134759: IFFALSE 135025
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
134761: LD_VAR 0 4
134765: PUSH
134766: LD_VAR 0 7
134770: ARRAY
134771: PPUSH
134772: CALL_OW 262
134776: PUSH
134777: LD_INT 1
134779: PUSH
134780: LD_INT 2
134782: PUSH
134783: EMPTY
134784: LIST
134785: LIST
134786: IN
134787: IFFALSE 134828
// if GetFuel ( group [ i ] ) < 10 then
134789: LD_VAR 0 4
134793: PUSH
134794: LD_VAR 0 7
134798: ARRAY
134799: PPUSH
134800: CALL_OW 261
134804: PUSH
134805: LD_INT 10
134807: LESS
134808: IFFALSE 134828
// SetFuel ( group [ i ] , 12 ) ;
134810: LD_VAR 0 4
134814: PUSH
134815: LD_VAR 0 7
134819: ARRAY
134820: PPUSH
134821: LD_INT 12
134823: PPUSH
134824: CALL_OW 240
// if units_path [ i ] then
134828: LD_VAR 0 16
134832: PUSH
134833: LD_VAR 0 7
134837: ARRAY
134838: IFFALSE 135023
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
134840: LD_VAR 0 4
134844: PUSH
134845: LD_VAR 0 7
134849: ARRAY
134850: PPUSH
134851: LD_VAR 0 16
134855: PUSH
134856: LD_VAR 0 7
134860: ARRAY
134861: PUSH
134862: LD_INT 1
134864: ARRAY
134865: PUSH
134866: LD_INT 1
134868: ARRAY
134869: PPUSH
134870: LD_VAR 0 16
134874: PUSH
134875: LD_VAR 0 7
134879: ARRAY
134880: PUSH
134881: LD_INT 1
134883: ARRAY
134884: PUSH
134885: LD_INT 2
134887: ARRAY
134888: PPUSH
134889: CALL_OW 297
134893: PUSH
134894: LD_INT 6
134896: GREATER
134897: IFFALSE 134972
// begin if not HasTask ( group [ i ] ) then
134899: LD_VAR 0 4
134903: PUSH
134904: LD_VAR 0 7
134908: ARRAY
134909: PPUSH
134910: CALL_OW 314
134914: NOT
134915: IFFALSE 134970
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
134917: LD_VAR 0 4
134921: PUSH
134922: LD_VAR 0 7
134926: ARRAY
134927: PPUSH
134928: LD_VAR 0 16
134932: PUSH
134933: LD_VAR 0 7
134937: ARRAY
134938: PUSH
134939: LD_INT 1
134941: ARRAY
134942: PUSH
134943: LD_INT 1
134945: ARRAY
134946: PPUSH
134947: LD_VAR 0 16
134951: PUSH
134952: LD_VAR 0 7
134956: ARRAY
134957: PUSH
134958: LD_INT 1
134960: ARRAY
134961: PUSH
134962: LD_INT 2
134964: ARRAY
134965: PPUSH
134966: CALL_OW 114
// end else
134970: GO 135023
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
134972: LD_ADDR_VAR 0 15
134976: PUSH
134977: LD_VAR 0 16
134981: PUSH
134982: LD_VAR 0 7
134986: ARRAY
134987: PPUSH
134988: LD_INT 1
134990: PPUSH
134991: CALL_OW 3
134995: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
134996: LD_ADDR_VAR 0 16
135000: PUSH
135001: LD_VAR 0 16
135005: PPUSH
135006: LD_VAR 0 7
135010: PPUSH
135011: LD_VAR 0 15
135015: PPUSH
135016: CALL_OW 1
135020: ST_TO_ADDR
// continue ;
135021: GO 133566
// end ; end ; end else
135023: GO 137687
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
135025: LD_ADDR_VAR 0 14
135029: PUSH
135030: LD_INT 81
135032: PUSH
135033: LD_VAR 0 4
135037: PUSH
135038: LD_VAR 0 7
135042: ARRAY
135043: PPUSH
135044: CALL_OW 255
135048: PUSH
135049: EMPTY
135050: LIST
135051: LIST
135052: PPUSH
135053: CALL_OW 69
135057: ST_TO_ADDR
// if not tmp then
135058: LD_VAR 0 14
135062: NOT
135063: IFFALSE 135067
// continue ;
135065: GO 133566
// if f_ignore_area then
135067: LD_VAR 0 17
135071: IFFALSE 135159
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
135073: LD_ADDR_VAR 0 15
135077: PUSH
135078: LD_VAR 0 14
135082: PPUSH
135083: LD_INT 3
135085: PUSH
135086: LD_INT 92
135088: PUSH
135089: LD_VAR 0 17
135093: PUSH
135094: LD_INT 1
135096: ARRAY
135097: PUSH
135098: LD_VAR 0 17
135102: PUSH
135103: LD_INT 2
135105: ARRAY
135106: PUSH
135107: LD_VAR 0 17
135111: PUSH
135112: LD_INT 3
135114: ARRAY
135115: PUSH
135116: EMPTY
135117: LIST
135118: LIST
135119: LIST
135120: LIST
135121: PUSH
135122: EMPTY
135123: LIST
135124: LIST
135125: PPUSH
135126: CALL_OW 72
135130: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135131: LD_VAR 0 14
135135: PUSH
135136: LD_VAR 0 15
135140: DIFF
135141: IFFALSE 135159
// tmp := tmp diff tmp2 ;
135143: LD_ADDR_VAR 0 14
135147: PUSH
135148: LD_VAR 0 14
135152: PUSH
135153: LD_VAR 0 15
135157: DIFF
135158: ST_TO_ADDR
// end ; if not f_murder then
135159: LD_VAR 0 20
135163: NOT
135164: IFFALSE 135222
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
135166: LD_ADDR_VAR 0 15
135170: PUSH
135171: LD_VAR 0 14
135175: PPUSH
135176: LD_INT 3
135178: PUSH
135179: LD_INT 50
135181: PUSH
135182: EMPTY
135183: LIST
135184: PUSH
135185: EMPTY
135186: LIST
135187: LIST
135188: PPUSH
135189: CALL_OW 72
135193: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
135194: LD_VAR 0 14
135198: PUSH
135199: LD_VAR 0 15
135203: DIFF
135204: IFFALSE 135222
// tmp := tmp diff tmp2 ;
135206: LD_ADDR_VAR 0 14
135210: PUSH
135211: LD_VAR 0 14
135215: PUSH
135216: LD_VAR 0 15
135220: DIFF
135221: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
135222: LD_ADDR_VAR 0 14
135226: PUSH
135227: LD_VAR 0 4
135231: PUSH
135232: LD_VAR 0 7
135236: ARRAY
135237: PPUSH
135238: LD_VAR 0 14
135242: PPUSH
135243: LD_INT 1
135245: PPUSH
135246: LD_INT 1
135248: PPUSH
135249: CALL 74942 0 4
135253: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
135254: LD_VAR 0 4
135258: PUSH
135259: LD_VAR 0 7
135263: ARRAY
135264: PPUSH
135265: CALL_OW 257
135269: PUSH
135270: LD_INT 1
135272: EQUAL
135273: IFFALSE 135721
// begin if WantPlant ( group [ i ] ) then
135275: LD_VAR 0 4
135279: PUSH
135280: LD_VAR 0 7
135284: ARRAY
135285: PPUSH
135286: CALL 74443 0 1
135290: IFFALSE 135294
// continue ;
135292: GO 133566
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
135294: LD_VAR 0 18
135298: PUSH
135299: LD_VAR 0 4
135303: PUSH
135304: LD_VAR 0 7
135308: ARRAY
135309: PPUSH
135310: CALL_OW 310
135314: NOT
135315: AND
135316: PUSH
135317: LD_VAR 0 14
135321: PUSH
135322: LD_INT 1
135324: ARRAY
135325: PUSH
135326: LD_VAR 0 14
135330: PPUSH
135331: LD_INT 21
135333: PUSH
135334: LD_INT 2
135336: PUSH
135337: EMPTY
135338: LIST
135339: LIST
135340: PUSH
135341: LD_INT 58
135343: PUSH
135344: EMPTY
135345: LIST
135346: PUSH
135347: EMPTY
135348: LIST
135349: LIST
135350: PPUSH
135351: CALL_OW 72
135355: IN
135356: AND
135357: IFFALSE 135393
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
135359: LD_VAR 0 4
135363: PUSH
135364: LD_VAR 0 7
135368: ARRAY
135369: PPUSH
135370: LD_VAR 0 14
135374: PUSH
135375: LD_INT 1
135377: ARRAY
135378: PPUSH
135379: CALL_OW 120
// attacking := true ;
135383: LD_ADDR_VAR 0 29
135387: PUSH
135388: LD_INT 1
135390: ST_TO_ADDR
// continue ;
135391: GO 133566
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
135393: LD_VAR 0 26
135397: PUSH
135398: LD_VAR 0 4
135402: PUSH
135403: LD_VAR 0 7
135407: ARRAY
135408: PPUSH
135409: CALL_OW 257
135413: PUSH
135414: LD_INT 1
135416: EQUAL
135417: AND
135418: PUSH
135419: LD_VAR 0 4
135423: PUSH
135424: LD_VAR 0 7
135428: ARRAY
135429: PPUSH
135430: CALL_OW 256
135434: PUSH
135435: LD_INT 800
135437: LESS
135438: AND
135439: PUSH
135440: LD_VAR 0 4
135444: PUSH
135445: LD_VAR 0 7
135449: ARRAY
135450: PPUSH
135451: CALL_OW 318
135455: NOT
135456: AND
135457: IFFALSE 135474
// ComCrawl ( group [ i ] ) ;
135459: LD_VAR 0 4
135463: PUSH
135464: LD_VAR 0 7
135468: ARRAY
135469: PPUSH
135470: CALL_OW 137
// if f_mines then
135474: LD_VAR 0 21
135478: IFFALSE 135721
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
135480: LD_VAR 0 14
135484: PUSH
135485: LD_INT 1
135487: ARRAY
135488: PPUSH
135489: CALL_OW 247
135493: PUSH
135494: LD_INT 3
135496: EQUAL
135497: PUSH
135498: LD_VAR 0 14
135502: PUSH
135503: LD_INT 1
135505: ARRAY
135506: PUSH
135507: LD_VAR 0 27
135511: IN
135512: NOT
135513: AND
135514: IFFALSE 135721
// begin x := GetX ( tmp [ 1 ] ) ;
135516: LD_ADDR_VAR 0 10
135520: PUSH
135521: LD_VAR 0 14
135525: PUSH
135526: LD_INT 1
135528: ARRAY
135529: PPUSH
135530: CALL_OW 250
135534: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
135535: LD_ADDR_VAR 0 11
135539: PUSH
135540: LD_VAR 0 14
135544: PUSH
135545: LD_INT 1
135547: ARRAY
135548: PPUSH
135549: CALL_OW 251
135553: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
135554: LD_ADDR_VAR 0 12
135558: PUSH
135559: LD_VAR 0 4
135563: PUSH
135564: LD_VAR 0 7
135568: ARRAY
135569: PPUSH
135570: CALL 102483 0 1
135574: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
135575: LD_VAR 0 4
135579: PUSH
135580: LD_VAR 0 7
135584: ARRAY
135585: PPUSH
135586: LD_VAR 0 10
135590: PPUSH
135591: LD_VAR 0 11
135595: PPUSH
135596: LD_VAR 0 14
135600: PUSH
135601: LD_INT 1
135603: ARRAY
135604: PPUSH
135605: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
135609: LD_VAR 0 4
135613: PUSH
135614: LD_VAR 0 7
135618: ARRAY
135619: PPUSH
135620: LD_VAR 0 10
135624: PPUSH
135625: LD_VAR 0 12
135629: PPUSH
135630: LD_INT 7
135632: PPUSH
135633: CALL_OW 272
135637: PPUSH
135638: LD_VAR 0 11
135642: PPUSH
135643: LD_VAR 0 12
135647: PPUSH
135648: LD_INT 7
135650: PPUSH
135651: CALL_OW 273
135655: PPUSH
135656: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
135660: LD_VAR 0 4
135664: PUSH
135665: LD_VAR 0 7
135669: ARRAY
135670: PPUSH
135671: LD_INT 71
135673: PPUSH
135674: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
135678: LD_ADDR_VAR 0 27
135682: PUSH
135683: LD_VAR 0 27
135687: PPUSH
135688: LD_VAR 0 27
135692: PUSH
135693: LD_INT 1
135695: PLUS
135696: PPUSH
135697: LD_VAR 0 14
135701: PUSH
135702: LD_INT 1
135704: ARRAY
135705: PPUSH
135706: CALL_OW 1
135710: ST_TO_ADDR
// attacking := true ;
135711: LD_ADDR_VAR 0 29
135715: PUSH
135716: LD_INT 1
135718: ST_TO_ADDR
// continue ;
135719: GO 133566
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
135721: LD_VAR 0 4
135725: PUSH
135726: LD_VAR 0 7
135730: ARRAY
135731: PPUSH
135732: CALL_OW 257
135736: PUSH
135737: LD_INT 17
135739: EQUAL
135740: PUSH
135741: LD_VAR 0 4
135745: PUSH
135746: LD_VAR 0 7
135750: ARRAY
135751: PPUSH
135752: CALL_OW 110
135756: PUSH
135757: LD_INT 71
135759: EQUAL
135760: NOT
135761: AND
135762: IFFALSE 135908
// begin attacking := false ;
135764: LD_ADDR_VAR 0 29
135768: PUSH
135769: LD_INT 0
135771: ST_TO_ADDR
// k := 5 ;
135772: LD_ADDR_VAR 0 9
135776: PUSH
135777: LD_INT 5
135779: ST_TO_ADDR
// if tmp < k then
135780: LD_VAR 0 14
135784: PUSH
135785: LD_VAR 0 9
135789: LESS
135790: IFFALSE 135802
// k := tmp ;
135792: LD_ADDR_VAR 0 9
135796: PUSH
135797: LD_VAR 0 14
135801: ST_TO_ADDR
// for j = 1 to k do
135802: LD_ADDR_VAR 0 8
135806: PUSH
135807: DOUBLE
135808: LD_INT 1
135810: DEC
135811: ST_TO_ADDR
135812: LD_VAR 0 9
135816: PUSH
135817: FOR_TO
135818: IFFALSE 135906
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
135820: LD_VAR 0 14
135824: PUSH
135825: LD_VAR 0 8
135829: ARRAY
135830: PUSH
135831: LD_VAR 0 14
135835: PPUSH
135836: LD_INT 58
135838: PUSH
135839: EMPTY
135840: LIST
135841: PPUSH
135842: CALL_OW 72
135846: IN
135847: NOT
135848: IFFALSE 135904
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
135850: LD_VAR 0 4
135854: PUSH
135855: LD_VAR 0 7
135859: ARRAY
135860: PPUSH
135861: LD_VAR 0 14
135865: PUSH
135866: LD_VAR 0 8
135870: ARRAY
135871: PPUSH
135872: CALL_OW 115
// attacking := true ;
135876: LD_ADDR_VAR 0 29
135880: PUSH
135881: LD_INT 1
135883: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
135884: LD_VAR 0 4
135888: PUSH
135889: LD_VAR 0 7
135893: ARRAY
135894: PPUSH
135895: LD_INT 71
135897: PPUSH
135898: CALL_OW 109
// continue ;
135902: GO 135817
// end ; end ;
135904: GO 135817
135906: POP
135907: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
135908: LD_VAR 0 4
135912: PUSH
135913: LD_VAR 0 7
135917: ARRAY
135918: PPUSH
135919: CALL_OW 257
135923: PUSH
135924: LD_INT 8
135926: EQUAL
135927: PUSH
135928: LD_VAR 0 4
135932: PUSH
135933: LD_VAR 0 7
135937: ARRAY
135938: PPUSH
135939: CALL_OW 264
135943: PUSH
135944: LD_INT 28
135946: PUSH
135947: LD_INT 45
135949: PUSH
135950: LD_INT 7
135952: PUSH
135953: LD_INT 47
135955: PUSH
135956: EMPTY
135957: LIST
135958: LIST
135959: LIST
135960: LIST
135961: IN
135962: OR
135963: IFFALSE 136219
// begin attacking := false ;
135965: LD_ADDR_VAR 0 29
135969: PUSH
135970: LD_INT 0
135972: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
135973: LD_VAR 0 14
135977: PUSH
135978: LD_INT 1
135980: ARRAY
135981: PPUSH
135982: CALL_OW 266
135986: PUSH
135987: LD_INT 32
135989: PUSH
135990: LD_INT 31
135992: PUSH
135993: LD_INT 33
135995: PUSH
135996: LD_INT 4
135998: PUSH
135999: LD_INT 5
136001: PUSH
136002: EMPTY
136003: LIST
136004: LIST
136005: LIST
136006: LIST
136007: LIST
136008: IN
136009: IFFALSE 136195
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
136011: LD_ADDR_VAR 0 9
136015: PUSH
136016: LD_VAR 0 14
136020: PUSH
136021: LD_INT 1
136023: ARRAY
136024: PPUSH
136025: CALL_OW 266
136029: PPUSH
136030: LD_VAR 0 14
136034: PUSH
136035: LD_INT 1
136037: ARRAY
136038: PPUSH
136039: CALL_OW 250
136043: PPUSH
136044: LD_VAR 0 14
136048: PUSH
136049: LD_INT 1
136051: ARRAY
136052: PPUSH
136053: CALL_OW 251
136057: PPUSH
136058: LD_VAR 0 14
136062: PUSH
136063: LD_INT 1
136065: ARRAY
136066: PPUSH
136067: CALL_OW 254
136071: PPUSH
136072: LD_VAR 0 14
136076: PUSH
136077: LD_INT 1
136079: ARRAY
136080: PPUSH
136081: CALL_OW 248
136085: PPUSH
136086: LD_INT 0
136088: PPUSH
136089: CALL 83853 0 6
136093: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
136094: LD_ADDR_VAR 0 8
136098: PUSH
136099: LD_VAR 0 4
136103: PUSH
136104: LD_VAR 0 7
136108: ARRAY
136109: PPUSH
136110: LD_VAR 0 9
136114: PPUSH
136115: CALL 102596 0 2
136119: ST_TO_ADDR
// if j then
136120: LD_VAR 0 8
136124: IFFALSE 136193
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
136126: LD_VAR 0 8
136130: PUSH
136131: LD_INT 1
136133: ARRAY
136134: PPUSH
136135: LD_VAR 0 8
136139: PUSH
136140: LD_INT 2
136142: ARRAY
136143: PPUSH
136144: CALL_OW 488
136148: IFFALSE 136193
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
136150: LD_VAR 0 4
136154: PUSH
136155: LD_VAR 0 7
136159: ARRAY
136160: PPUSH
136161: LD_VAR 0 8
136165: PUSH
136166: LD_INT 1
136168: ARRAY
136169: PPUSH
136170: LD_VAR 0 8
136174: PUSH
136175: LD_INT 2
136177: ARRAY
136178: PPUSH
136179: CALL_OW 116
// attacking := true ;
136183: LD_ADDR_VAR 0 29
136187: PUSH
136188: LD_INT 1
136190: ST_TO_ADDR
// continue ;
136191: GO 133566
// end ; end else
136193: GO 136219
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136195: LD_VAR 0 4
136199: PUSH
136200: LD_VAR 0 7
136204: ARRAY
136205: PPUSH
136206: LD_VAR 0 14
136210: PUSH
136211: LD_INT 1
136213: ARRAY
136214: PPUSH
136215: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
136219: LD_VAR 0 4
136223: PUSH
136224: LD_VAR 0 7
136228: ARRAY
136229: PPUSH
136230: CALL_OW 265
136234: PUSH
136235: LD_INT 11
136237: EQUAL
136238: IFFALSE 136516
// begin k := 10 ;
136240: LD_ADDR_VAR 0 9
136244: PUSH
136245: LD_INT 10
136247: ST_TO_ADDR
// x := 0 ;
136248: LD_ADDR_VAR 0 10
136252: PUSH
136253: LD_INT 0
136255: ST_TO_ADDR
// if tmp < k then
136256: LD_VAR 0 14
136260: PUSH
136261: LD_VAR 0 9
136265: LESS
136266: IFFALSE 136278
// k := tmp ;
136268: LD_ADDR_VAR 0 9
136272: PUSH
136273: LD_VAR 0 14
136277: ST_TO_ADDR
// for j = k downto 1 do
136278: LD_ADDR_VAR 0 8
136282: PUSH
136283: DOUBLE
136284: LD_VAR 0 9
136288: INC
136289: ST_TO_ADDR
136290: LD_INT 1
136292: PUSH
136293: FOR_DOWNTO
136294: IFFALSE 136369
// begin if GetType ( tmp [ j ] ) = unit_human then
136296: LD_VAR 0 14
136300: PUSH
136301: LD_VAR 0 8
136305: ARRAY
136306: PPUSH
136307: CALL_OW 247
136311: PUSH
136312: LD_INT 1
136314: EQUAL
136315: IFFALSE 136367
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
136317: LD_VAR 0 4
136321: PUSH
136322: LD_VAR 0 7
136326: ARRAY
136327: PPUSH
136328: LD_VAR 0 14
136332: PUSH
136333: LD_VAR 0 8
136337: ARRAY
136338: PPUSH
136339: CALL 102850 0 2
// x := tmp [ j ] ;
136343: LD_ADDR_VAR 0 10
136347: PUSH
136348: LD_VAR 0 14
136352: PUSH
136353: LD_VAR 0 8
136357: ARRAY
136358: ST_TO_ADDR
// attacking := true ;
136359: LD_ADDR_VAR 0 29
136363: PUSH
136364: LD_INT 1
136366: ST_TO_ADDR
// end ; end ;
136367: GO 136293
136369: POP
136370: POP
// if not x then
136371: LD_VAR 0 10
136375: NOT
136376: IFFALSE 136516
// begin attacking := true ;
136378: LD_ADDR_VAR 0 29
136382: PUSH
136383: LD_INT 1
136385: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
136386: LD_VAR 0 4
136390: PUSH
136391: LD_VAR 0 7
136395: ARRAY
136396: PPUSH
136397: CALL_OW 250
136401: PPUSH
136402: LD_VAR 0 4
136406: PUSH
136407: LD_VAR 0 7
136411: ARRAY
136412: PPUSH
136413: CALL_OW 251
136417: PPUSH
136418: CALL_OW 546
136422: PUSH
136423: LD_INT 2
136425: ARRAY
136426: PUSH
136427: LD_VAR 0 14
136431: PUSH
136432: LD_INT 1
136434: ARRAY
136435: PPUSH
136436: CALL_OW 250
136440: PPUSH
136441: LD_VAR 0 14
136445: PUSH
136446: LD_INT 1
136448: ARRAY
136449: PPUSH
136450: CALL_OW 251
136454: PPUSH
136455: CALL_OW 546
136459: PUSH
136460: LD_INT 2
136462: ARRAY
136463: EQUAL
136464: IFFALSE 136492
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
136466: LD_VAR 0 4
136470: PUSH
136471: LD_VAR 0 7
136475: ARRAY
136476: PPUSH
136477: LD_VAR 0 14
136481: PUSH
136482: LD_INT 1
136484: ARRAY
136485: PPUSH
136486: CALL 102850 0 2
136490: GO 136516
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136492: LD_VAR 0 4
136496: PUSH
136497: LD_VAR 0 7
136501: ARRAY
136502: PPUSH
136503: LD_VAR 0 14
136507: PUSH
136508: LD_INT 1
136510: ARRAY
136511: PPUSH
136512: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
136516: LD_VAR 0 4
136520: PUSH
136521: LD_VAR 0 7
136525: ARRAY
136526: PPUSH
136527: CALL_OW 264
136531: PUSH
136532: LD_INT 29
136534: EQUAL
136535: IFFALSE 136901
// begin if WantsToAttack ( group [ i ] ) in bombed then
136537: LD_VAR 0 4
136541: PUSH
136542: LD_VAR 0 7
136546: ARRAY
136547: PPUSH
136548: CALL_OW 319
136552: PUSH
136553: LD_VAR 0 28
136557: IN
136558: IFFALSE 136562
// continue ;
136560: GO 133566
// k := 8 ;
136562: LD_ADDR_VAR 0 9
136566: PUSH
136567: LD_INT 8
136569: ST_TO_ADDR
// x := 0 ;
136570: LD_ADDR_VAR 0 10
136574: PUSH
136575: LD_INT 0
136577: ST_TO_ADDR
// if tmp < k then
136578: LD_VAR 0 14
136582: PUSH
136583: LD_VAR 0 9
136587: LESS
136588: IFFALSE 136600
// k := tmp ;
136590: LD_ADDR_VAR 0 9
136594: PUSH
136595: LD_VAR 0 14
136599: ST_TO_ADDR
// for j = 1 to k do
136600: LD_ADDR_VAR 0 8
136604: PUSH
136605: DOUBLE
136606: LD_INT 1
136608: DEC
136609: ST_TO_ADDR
136610: LD_VAR 0 9
136614: PUSH
136615: FOR_TO
136616: IFFALSE 136748
// begin if GetType ( tmp [ j ] ) = unit_building then
136618: LD_VAR 0 14
136622: PUSH
136623: LD_VAR 0 8
136627: ARRAY
136628: PPUSH
136629: CALL_OW 247
136633: PUSH
136634: LD_INT 3
136636: EQUAL
136637: IFFALSE 136746
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
136639: LD_VAR 0 14
136643: PUSH
136644: LD_VAR 0 8
136648: ARRAY
136649: PUSH
136650: LD_VAR 0 28
136654: IN
136655: NOT
136656: PUSH
136657: LD_VAR 0 14
136661: PUSH
136662: LD_VAR 0 8
136666: ARRAY
136667: PPUSH
136668: CALL_OW 313
136672: AND
136673: IFFALSE 136746
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
136675: LD_VAR 0 4
136679: PUSH
136680: LD_VAR 0 7
136684: ARRAY
136685: PPUSH
136686: LD_VAR 0 14
136690: PUSH
136691: LD_VAR 0 8
136695: ARRAY
136696: PPUSH
136697: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
136701: LD_ADDR_VAR 0 28
136705: PUSH
136706: LD_VAR 0 28
136710: PPUSH
136711: LD_VAR 0 28
136715: PUSH
136716: LD_INT 1
136718: PLUS
136719: PPUSH
136720: LD_VAR 0 14
136724: PUSH
136725: LD_VAR 0 8
136729: ARRAY
136730: PPUSH
136731: CALL_OW 1
136735: ST_TO_ADDR
// attacking := true ;
136736: LD_ADDR_VAR 0 29
136740: PUSH
136741: LD_INT 1
136743: ST_TO_ADDR
// break ;
136744: GO 136748
// end ; end ;
136746: GO 136615
136748: POP
136749: POP
// if not attacking and f_attack_depot then
136750: LD_VAR 0 29
136754: NOT
136755: PUSH
136756: LD_VAR 0 25
136760: AND
136761: IFFALSE 136856
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136763: LD_ADDR_VAR 0 13
136767: PUSH
136768: LD_VAR 0 14
136772: PPUSH
136773: LD_INT 2
136775: PUSH
136776: LD_INT 30
136778: PUSH
136779: LD_INT 0
136781: PUSH
136782: EMPTY
136783: LIST
136784: LIST
136785: PUSH
136786: LD_INT 30
136788: PUSH
136789: LD_INT 1
136791: PUSH
136792: EMPTY
136793: LIST
136794: LIST
136795: PUSH
136796: EMPTY
136797: LIST
136798: LIST
136799: LIST
136800: PPUSH
136801: CALL_OW 72
136805: ST_TO_ADDR
// if z then
136806: LD_VAR 0 13
136810: IFFALSE 136856
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
136812: LD_VAR 0 4
136816: PUSH
136817: LD_VAR 0 7
136821: ARRAY
136822: PPUSH
136823: LD_VAR 0 13
136827: PPUSH
136828: LD_VAR 0 4
136832: PUSH
136833: LD_VAR 0 7
136837: ARRAY
136838: PPUSH
136839: CALL_OW 74
136843: PPUSH
136844: CALL_OW 115
// attacking := true ;
136848: LD_ADDR_VAR 0 29
136852: PUSH
136853: LD_INT 1
136855: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
136856: LD_VAR 0 4
136860: PUSH
136861: LD_VAR 0 7
136865: ARRAY
136866: PPUSH
136867: CALL_OW 256
136871: PUSH
136872: LD_INT 500
136874: LESS
136875: IFFALSE 136901
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
136877: LD_VAR 0 4
136881: PUSH
136882: LD_VAR 0 7
136886: ARRAY
136887: PPUSH
136888: LD_VAR 0 14
136892: PUSH
136893: LD_INT 1
136895: ARRAY
136896: PPUSH
136897: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
136901: LD_VAR 0 4
136905: PUSH
136906: LD_VAR 0 7
136910: ARRAY
136911: PPUSH
136912: CALL_OW 264
136916: PUSH
136917: LD_INT 49
136919: EQUAL
136920: IFFALSE 137041
// begin if not HasTask ( group [ i ] ) then
136922: LD_VAR 0 4
136926: PUSH
136927: LD_VAR 0 7
136931: ARRAY
136932: PPUSH
136933: CALL_OW 314
136937: NOT
136938: IFFALSE 137041
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
136940: LD_ADDR_VAR 0 9
136944: PUSH
136945: LD_INT 81
136947: PUSH
136948: LD_VAR 0 4
136952: PUSH
136953: LD_VAR 0 7
136957: ARRAY
136958: PPUSH
136959: CALL_OW 255
136963: PUSH
136964: EMPTY
136965: LIST
136966: LIST
136967: PPUSH
136968: CALL_OW 69
136972: PPUSH
136973: LD_VAR 0 4
136977: PUSH
136978: LD_VAR 0 7
136982: ARRAY
136983: PPUSH
136984: CALL_OW 74
136988: ST_TO_ADDR
// if k then
136989: LD_VAR 0 9
136993: IFFALSE 137041
// if GetDistUnits ( group [ i ] , k ) > 10 then
136995: LD_VAR 0 4
136999: PUSH
137000: LD_VAR 0 7
137004: ARRAY
137005: PPUSH
137006: LD_VAR 0 9
137010: PPUSH
137011: CALL_OW 296
137015: PUSH
137016: LD_INT 10
137018: GREATER
137019: IFFALSE 137041
// ComMoveUnit ( group [ i ] , k ) ;
137021: LD_VAR 0 4
137025: PUSH
137026: LD_VAR 0 7
137030: ARRAY
137031: PPUSH
137032: LD_VAR 0 9
137036: PPUSH
137037: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
137041: LD_VAR 0 4
137045: PUSH
137046: LD_VAR 0 7
137050: ARRAY
137051: PPUSH
137052: CALL_OW 256
137056: PUSH
137057: LD_INT 250
137059: LESS
137060: PUSH
137061: LD_VAR 0 4
137065: PUSH
137066: LD_VAR 0 7
137070: ARRAY
137071: PUSH
137072: LD_INT 21
137074: PUSH
137075: LD_INT 2
137077: PUSH
137078: EMPTY
137079: LIST
137080: LIST
137081: PUSH
137082: LD_INT 23
137084: PUSH
137085: LD_INT 2
137087: PUSH
137088: EMPTY
137089: LIST
137090: LIST
137091: PUSH
137092: EMPTY
137093: LIST
137094: LIST
137095: PPUSH
137096: CALL_OW 69
137100: IN
137101: AND
137102: IFFALSE 137227
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
137104: LD_ADDR_VAR 0 9
137108: PUSH
137109: LD_OWVAR 3
137113: PUSH
137114: LD_VAR 0 4
137118: PUSH
137119: LD_VAR 0 7
137123: ARRAY
137124: DIFF
137125: PPUSH
137126: LD_VAR 0 4
137130: PUSH
137131: LD_VAR 0 7
137135: ARRAY
137136: PPUSH
137137: CALL_OW 74
137141: ST_TO_ADDR
// if not k then
137142: LD_VAR 0 9
137146: NOT
137147: IFFALSE 137151
// continue ;
137149: GO 133566
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
137151: LD_VAR 0 9
137155: PUSH
137156: LD_INT 81
137158: PUSH
137159: LD_VAR 0 4
137163: PUSH
137164: LD_VAR 0 7
137168: ARRAY
137169: PPUSH
137170: CALL_OW 255
137174: PUSH
137175: EMPTY
137176: LIST
137177: LIST
137178: PPUSH
137179: CALL_OW 69
137183: IN
137184: PUSH
137185: LD_VAR 0 9
137189: PPUSH
137190: LD_VAR 0 4
137194: PUSH
137195: LD_VAR 0 7
137199: ARRAY
137200: PPUSH
137201: CALL_OW 296
137205: PUSH
137206: LD_INT 5
137208: LESS
137209: AND
137210: IFFALSE 137227
// ComAutodestruct ( group [ i ] ) ;
137212: LD_VAR 0 4
137216: PUSH
137217: LD_VAR 0 7
137221: ARRAY
137222: PPUSH
137223: CALL 102748 0 1
// end ; if f_attack_depot then
137227: LD_VAR 0 25
137231: IFFALSE 137343
// begin k := 6 ;
137233: LD_ADDR_VAR 0 9
137237: PUSH
137238: LD_INT 6
137240: ST_TO_ADDR
// if tmp < k then
137241: LD_VAR 0 14
137245: PUSH
137246: LD_VAR 0 9
137250: LESS
137251: IFFALSE 137263
// k := tmp ;
137253: LD_ADDR_VAR 0 9
137257: PUSH
137258: LD_VAR 0 14
137262: ST_TO_ADDR
// for j = 1 to k do
137263: LD_ADDR_VAR 0 8
137267: PUSH
137268: DOUBLE
137269: LD_INT 1
137271: DEC
137272: ST_TO_ADDR
137273: LD_VAR 0 9
137277: PUSH
137278: FOR_TO
137279: IFFALSE 137341
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
137281: LD_VAR 0 8
137285: PPUSH
137286: CALL_OW 266
137290: PUSH
137291: LD_INT 0
137293: PUSH
137294: LD_INT 1
137296: PUSH
137297: EMPTY
137298: LIST
137299: LIST
137300: IN
137301: IFFALSE 137339
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
137303: LD_VAR 0 4
137307: PUSH
137308: LD_VAR 0 7
137312: ARRAY
137313: PPUSH
137314: LD_VAR 0 14
137318: PUSH
137319: LD_VAR 0 8
137323: ARRAY
137324: PPUSH
137325: CALL_OW 115
// attacking := true ;
137329: LD_ADDR_VAR 0 29
137333: PUSH
137334: LD_INT 1
137336: ST_TO_ADDR
// break ;
137337: GO 137341
// end ;
137339: GO 137278
137341: POP
137342: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
137343: LD_VAR 0 4
137347: PUSH
137348: LD_VAR 0 7
137352: ARRAY
137353: PPUSH
137354: CALL_OW 302
137358: PUSH
137359: LD_VAR 0 29
137363: NOT
137364: AND
137365: IFFALSE 137687
// begin if GetTag ( group [ i ] ) = 71 then
137367: LD_VAR 0 4
137371: PUSH
137372: LD_VAR 0 7
137376: ARRAY
137377: PPUSH
137378: CALL_OW 110
137382: PUSH
137383: LD_INT 71
137385: EQUAL
137386: IFFALSE 137427
// begin if HasTask ( group [ i ] ) then
137388: LD_VAR 0 4
137392: PUSH
137393: LD_VAR 0 7
137397: ARRAY
137398: PPUSH
137399: CALL_OW 314
137403: IFFALSE 137409
// continue else
137405: GO 133566
137407: GO 137427
// SetTag ( group [ i ] , 0 ) ;
137409: LD_VAR 0 4
137413: PUSH
137414: LD_VAR 0 7
137418: ARRAY
137419: PPUSH
137420: LD_INT 0
137422: PPUSH
137423: CALL_OW 109
// end ; k := 8 ;
137427: LD_ADDR_VAR 0 9
137431: PUSH
137432: LD_INT 8
137434: ST_TO_ADDR
// x := 0 ;
137435: LD_ADDR_VAR 0 10
137439: PUSH
137440: LD_INT 0
137442: ST_TO_ADDR
// if tmp < k then
137443: LD_VAR 0 14
137447: PUSH
137448: LD_VAR 0 9
137452: LESS
137453: IFFALSE 137465
// k := tmp ;
137455: LD_ADDR_VAR 0 9
137459: PUSH
137460: LD_VAR 0 14
137464: ST_TO_ADDR
// for j = 1 to k do
137465: LD_ADDR_VAR 0 8
137469: PUSH
137470: DOUBLE
137471: LD_INT 1
137473: DEC
137474: ST_TO_ADDR
137475: LD_VAR 0 9
137479: PUSH
137480: FOR_TO
137481: IFFALSE 137579
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
137483: LD_VAR 0 14
137487: PUSH
137488: LD_VAR 0 8
137492: ARRAY
137493: PPUSH
137494: CALL_OW 247
137498: PUSH
137499: LD_INT 1
137501: EQUAL
137502: PUSH
137503: LD_VAR 0 14
137507: PUSH
137508: LD_VAR 0 8
137512: ARRAY
137513: PPUSH
137514: CALL_OW 256
137518: PUSH
137519: LD_INT 250
137521: LESS
137522: PUSH
137523: LD_VAR 0 20
137527: AND
137528: PUSH
137529: LD_VAR 0 20
137533: NOT
137534: PUSH
137535: LD_VAR 0 14
137539: PUSH
137540: LD_VAR 0 8
137544: ARRAY
137545: PPUSH
137546: CALL_OW 256
137550: PUSH
137551: LD_INT 250
137553: GREATEREQUAL
137554: AND
137555: OR
137556: AND
137557: IFFALSE 137577
// begin x := tmp [ j ] ;
137559: LD_ADDR_VAR 0 10
137563: PUSH
137564: LD_VAR 0 14
137568: PUSH
137569: LD_VAR 0 8
137573: ARRAY
137574: ST_TO_ADDR
// break ;
137575: GO 137579
// end ;
137577: GO 137480
137579: POP
137580: POP
// if x then
137581: LD_VAR 0 10
137585: IFFALSE 137609
// ComAttackUnit ( group [ i ] , x ) else
137587: LD_VAR 0 4
137591: PUSH
137592: LD_VAR 0 7
137596: ARRAY
137597: PPUSH
137598: LD_VAR 0 10
137602: PPUSH
137603: CALL_OW 115
137607: GO 137633
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
137609: LD_VAR 0 4
137613: PUSH
137614: LD_VAR 0 7
137618: ARRAY
137619: PPUSH
137620: LD_VAR 0 14
137624: PUSH
137625: LD_INT 1
137627: ARRAY
137628: PPUSH
137629: CALL_OW 115
// if not HasTask ( group [ i ] ) then
137633: LD_VAR 0 4
137637: PUSH
137638: LD_VAR 0 7
137642: ARRAY
137643: PPUSH
137644: CALL_OW 314
137648: NOT
137649: IFFALSE 137687
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
137651: LD_VAR 0 4
137655: PUSH
137656: LD_VAR 0 7
137660: ARRAY
137661: PPUSH
137662: LD_VAR 0 14
137666: PPUSH
137667: LD_VAR 0 4
137671: PUSH
137672: LD_VAR 0 7
137676: ARRAY
137677: PPUSH
137678: CALL_OW 74
137682: PPUSH
137683: CALL_OW 115
// end ; end ; end ;
137687: GO 133566
137689: POP
137690: POP
// wait ( 0 0$2 ) ;
137691: LD_INT 70
137693: PPUSH
137694: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
137698: LD_VAR 0 4
137702: NOT
137703: PUSH
137704: LD_VAR 0 4
137708: PUSH
137709: EMPTY
137710: EQUAL
137711: OR
137712: PUSH
137713: LD_INT 81
137715: PUSH
137716: LD_VAR 0 35
137720: PUSH
137721: EMPTY
137722: LIST
137723: LIST
137724: PPUSH
137725: CALL_OW 69
137729: NOT
137730: OR
137731: IFFALSE 133551
// end ;
137733: LD_VAR 0 2
137737: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
137738: LD_INT 0
137740: PPUSH
137741: PPUSH
137742: PPUSH
137743: PPUSH
137744: PPUSH
137745: PPUSH
// if not base or not mc_bases [ base ] or not solds then
137746: LD_VAR 0 1
137750: NOT
137751: PUSH
137752: LD_EXP 102
137756: PUSH
137757: LD_VAR 0 1
137761: ARRAY
137762: NOT
137763: OR
137764: PUSH
137765: LD_VAR 0 2
137769: NOT
137770: OR
137771: IFFALSE 137775
// exit ;
137773: GO 138329
// side := mc_sides [ base ] ;
137775: LD_ADDR_VAR 0 6
137779: PUSH
137780: LD_EXP 128
137784: PUSH
137785: LD_VAR 0 1
137789: ARRAY
137790: ST_TO_ADDR
// if not side then
137791: LD_VAR 0 6
137795: NOT
137796: IFFALSE 137800
// exit ;
137798: GO 138329
// for i in solds do
137800: LD_ADDR_VAR 0 7
137804: PUSH
137805: LD_VAR 0 2
137809: PUSH
137810: FOR_IN
137811: IFFALSE 137872
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
137813: LD_VAR 0 7
137817: PPUSH
137818: CALL_OW 310
137822: PPUSH
137823: CALL_OW 266
137827: PUSH
137828: LD_INT 32
137830: PUSH
137831: LD_INT 31
137833: PUSH
137834: EMPTY
137835: LIST
137836: LIST
137837: IN
137838: IFFALSE 137858
// solds := solds diff i else
137840: LD_ADDR_VAR 0 2
137844: PUSH
137845: LD_VAR 0 2
137849: PUSH
137850: LD_VAR 0 7
137854: DIFF
137855: ST_TO_ADDR
137856: GO 137870
// SetTag ( i , 18 ) ;
137858: LD_VAR 0 7
137862: PPUSH
137863: LD_INT 18
137865: PPUSH
137866: CALL_OW 109
137870: GO 137810
137872: POP
137873: POP
// if not solds then
137874: LD_VAR 0 2
137878: NOT
137879: IFFALSE 137883
// exit ;
137881: GO 138329
// repeat wait ( 0 0$2 ) ;
137883: LD_INT 70
137885: PPUSH
137886: CALL_OW 67
// enemy := mc_scan [ base ] ;
137890: LD_ADDR_VAR 0 4
137894: PUSH
137895: LD_EXP 125
137899: PUSH
137900: LD_VAR 0 1
137904: ARRAY
137905: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137906: LD_EXP 102
137910: PUSH
137911: LD_VAR 0 1
137915: ARRAY
137916: NOT
137917: PUSH
137918: LD_EXP 102
137922: PUSH
137923: LD_VAR 0 1
137927: ARRAY
137928: PUSH
137929: EMPTY
137930: EQUAL
137931: OR
137932: IFFALSE 137969
// begin for i in solds do
137934: LD_ADDR_VAR 0 7
137938: PUSH
137939: LD_VAR 0 2
137943: PUSH
137944: FOR_IN
137945: IFFALSE 137958
// ComStop ( i ) ;
137947: LD_VAR 0 7
137951: PPUSH
137952: CALL_OW 141
137956: GO 137944
137958: POP
137959: POP
// solds := [ ] ;
137960: LD_ADDR_VAR 0 2
137964: PUSH
137965: EMPTY
137966: ST_TO_ADDR
// exit ;
137967: GO 138329
// end ; for i in solds do
137969: LD_ADDR_VAR 0 7
137973: PUSH
137974: LD_VAR 0 2
137978: PUSH
137979: FOR_IN
137980: IFFALSE 138301
// begin if IsInUnit ( i ) then
137982: LD_VAR 0 7
137986: PPUSH
137987: CALL_OW 310
137991: IFFALSE 138002
// ComExitBuilding ( i ) ;
137993: LD_VAR 0 7
137997: PPUSH
137998: CALL_OW 122
// if GetLives ( i ) > 500 then
138002: LD_VAR 0 7
138006: PPUSH
138007: CALL_OW 256
138011: PUSH
138012: LD_INT 500
138014: GREATER
138015: IFFALSE 138068
// begin e := NearestUnitToUnit ( enemy , i ) ;
138017: LD_ADDR_VAR 0 5
138021: PUSH
138022: LD_VAR 0 4
138026: PPUSH
138027: LD_VAR 0 7
138031: PPUSH
138032: CALL_OW 74
138036: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
138037: LD_VAR 0 7
138041: PPUSH
138042: LD_VAR 0 5
138046: PPUSH
138047: CALL_OW 250
138051: PPUSH
138052: LD_VAR 0 5
138056: PPUSH
138057: CALL_OW 251
138061: PPUSH
138062: CALL_OW 114
// end else
138066: GO 138299
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
138068: LD_VAR 0 7
138072: PPUSH
138073: LD_EXP 102
138077: PUSH
138078: LD_VAR 0 1
138082: ARRAY
138083: PPUSH
138084: LD_INT 2
138086: PUSH
138087: LD_INT 30
138089: PUSH
138090: LD_INT 0
138092: PUSH
138093: EMPTY
138094: LIST
138095: LIST
138096: PUSH
138097: LD_INT 30
138099: PUSH
138100: LD_INT 1
138102: PUSH
138103: EMPTY
138104: LIST
138105: LIST
138106: PUSH
138107: LD_INT 30
138109: PUSH
138110: LD_INT 6
138112: PUSH
138113: EMPTY
138114: LIST
138115: LIST
138116: PUSH
138117: EMPTY
138118: LIST
138119: LIST
138120: LIST
138121: LIST
138122: PPUSH
138123: CALL_OW 72
138127: PPUSH
138128: LD_VAR 0 7
138132: PPUSH
138133: CALL_OW 74
138137: PPUSH
138138: CALL_OW 296
138142: PUSH
138143: LD_INT 10
138145: GREATER
138146: IFFALSE 138299
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
138148: LD_ADDR_VAR 0 8
138152: PUSH
138153: LD_EXP 102
138157: PUSH
138158: LD_VAR 0 1
138162: ARRAY
138163: PPUSH
138164: LD_INT 2
138166: PUSH
138167: LD_INT 30
138169: PUSH
138170: LD_INT 0
138172: PUSH
138173: EMPTY
138174: LIST
138175: LIST
138176: PUSH
138177: LD_INT 30
138179: PUSH
138180: LD_INT 1
138182: PUSH
138183: EMPTY
138184: LIST
138185: LIST
138186: PUSH
138187: LD_INT 30
138189: PUSH
138190: LD_INT 6
138192: PUSH
138193: EMPTY
138194: LIST
138195: LIST
138196: PUSH
138197: EMPTY
138198: LIST
138199: LIST
138200: LIST
138201: LIST
138202: PPUSH
138203: CALL_OW 72
138207: PPUSH
138208: LD_VAR 0 7
138212: PPUSH
138213: CALL_OW 74
138217: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
138218: LD_VAR 0 7
138222: PPUSH
138223: LD_VAR 0 8
138227: PPUSH
138228: CALL_OW 250
138232: PPUSH
138233: LD_INT 3
138235: PPUSH
138236: LD_INT 5
138238: PPUSH
138239: CALL_OW 272
138243: PPUSH
138244: LD_VAR 0 8
138248: PPUSH
138249: CALL_OW 251
138253: PPUSH
138254: LD_INT 3
138256: PPUSH
138257: LD_INT 5
138259: PPUSH
138260: CALL_OW 273
138264: PPUSH
138265: CALL_OW 111
// SetTag ( i , 0 ) ;
138269: LD_VAR 0 7
138273: PPUSH
138274: LD_INT 0
138276: PPUSH
138277: CALL_OW 109
// solds := solds diff i ;
138281: LD_ADDR_VAR 0 2
138285: PUSH
138286: LD_VAR 0 2
138290: PUSH
138291: LD_VAR 0 7
138295: DIFF
138296: ST_TO_ADDR
// continue ;
138297: GO 137979
// end ; end ;
138299: GO 137979
138301: POP
138302: POP
// until not solds or not enemy ;
138303: LD_VAR 0 2
138307: NOT
138308: PUSH
138309: LD_VAR 0 4
138313: NOT
138314: OR
138315: IFFALSE 137883
// MC_Reset ( base , 18 ) ;
138317: LD_VAR 0 1
138321: PPUSH
138322: LD_INT 18
138324: PPUSH
138325: CALL 43006 0 2
// end ;
138329: LD_VAR 0 3
138333: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
138334: LD_INT 0
138336: PPUSH
138337: PPUSH
138338: PPUSH
138339: PPUSH
138340: PPUSH
138341: PPUSH
138342: PPUSH
138343: PPUSH
138344: PPUSH
138345: PPUSH
138346: PPUSH
138347: PPUSH
138348: PPUSH
138349: PPUSH
138350: PPUSH
138351: PPUSH
138352: PPUSH
138353: PPUSH
138354: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
138355: LD_ADDR_VAR 0 12
138359: PUSH
138360: LD_EXP 102
138364: PUSH
138365: LD_VAR 0 1
138369: ARRAY
138370: PPUSH
138371: LD_INT 25
138373: PUSH
138374: LD_INT 3
138376: PUSH
138377: EMPTY
138378: LIST
138379: LIST
138380: PPUSH
138381: CALL_OW 72
138385: ST_TO_ADDR
// if mc_remote_driver [ base ] then
138386: LD_EXP 142
138390: PUSH
138391: LD_VAR 0 1
138395: ARRAY
138396: IFFALSE 138420
// mechs := mechs diff mc_remote_driver [ base ] ;
138398: LD_ADDR_VAR 0 12
138402: PUSH
138403: LD_VAR 0 12
138407: PUSH
138408: LD_EXP 142
138412: PUSH
138413: LD_VAR 0 1
138417: ARRAY
138418: DIFF
138419: ST_TO_ADDR
// for i in mechs do
138420: LD_ADDR_VAR 0 4
138424: PUSH
138425: LD_VAR 0 12
138429: PUSH
138430: FOR_IN
138431: IFFALSE 138466
// if GetTag ( i ) > 0 then
138433: LD_VAR 0 4
138437: PPUSH
138438: CALL_OW 110
138442: PUSH
138443: LD_INT 0
138445: GREATER
138446: IFFALSE 138464
// mechs := mechs diff i ;
138448: LD_ADDR_VAR 0 12
138452: PUSH
138453: LD_VAR 0 12
138457: PUSH
138458: LD_VAR 0 4
138462: DIFF
138463: ST_TO_ADDR
138464: GO 138430
138466: POP
138467: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
138468: LD_ADDR_VAR 0 8
138472: PUSH
138473: LD_EXP 102
138477: PUSH
138478: LD_VAR 0 1
138482: ARRAY
138483: PPUSH
138484: LD_INT 2
138486: PUSH
138487: LD_INT 25
138489: PUSH
138490: LD_INT 1
138492: PUSH
138493: EMPTY
138494: LIST
138495: LIST
138496: PUSH
138497: LD_INT 25
138499: PUSH
138500: LD_INT 5
138502: PUSH
138503: EMPTY
138504: LIST
138505: LIST
138506: PUSH
138507: LD_INT 25
138509: PUSH
138510: LD_INT 8
138512: PUSH
138513: EMPTY
138514: LIST
138515: LIST
138516: PUSH
138517: LD_INT 25
138519: PUSH
138520: LD_INT 9
138522: PUSH
138523: EMPTY
138524: LIST
138525: LIST
138526: PUSH
138527: EMPTY
138528: LIST
138529: LIST
138530: LIST
138531: LIST
138532: LIST
138533: PPUSH
138534: CALL_OW 72
138538: ST_TO_ADDR
// if not defenders and not solds then
138539: LD_VAR 0 2
138543: NOT
138544: PUSH
138545: LD_VAR 0 8
138549: NOT
138550: AND
138551: IFFALSE 138555
// exit ;
138553: GO 140325
// depot_under_attack := false ;
138555: LD_ADDR_VAR 0 16
138559: PUSH
138560: LD_INT 0
138562: ST_TO_ADDR
// sold_defenders := [ ] ;
138563: LD_ADDR_VAR 0 17
138567: PUSH
138568: EMPTY
138569: ST_TO_ADDR
// if mechs then
138570: LD_VAR 0 12
138574: IFFALSE 138727
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
138576: LD_ADDR_VAR 0 4
138580: PUSH
138581: LD_VAR 0 2
138585: PPUSH
138586: LD_INT 21
138588: PUSH
138589: LD_INT 2
138591: PUSH
138592: EMPTY
138593: LIST
138594: LIST
138595: PPUSH
138596: CALL_OW 72
138600: PUSH
138601: FOR_IN
138602: IFFALSE 138725
// begin if GetTag ( i ) <> 20 then
138604: LD_VAR 0 4
138608: PPUSH
138609: CALL_OW 110
138613: PUSH
138614: LD_INT 20
138616: NONEQUAL
138617: IFFALSE 138631
// SetTag ( i , 20 ) ;
138619: LD_VAR 0 4
138623: PPUSH
138624: LD_INT 20
138626: PPUSH
138627: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
138631: LD_VAR 0 4
138635: PPUSH
138636: CALL_OW 263
138640: PUSH
138641: LD_INT 1
138643: EQUAL
138644: PUSH
138645: LD_VAR 0 4
138649: PPUSH
138650: CALL_OW 311
138654: NOT
138655: AND
138656: IFFALSE 138723
// begin un := mechs [ 1 ] ;
138658: LD_ADDR_VAR 0 10
138662: PUSH
138663: LD_VAR 0 12
138667: PUSH
138668: LD_INT 1
138670: ARRAY
138671: ST_TO_ADDR
// ComExit ( un ) ;
138672: LD_VAR 0 10
138676: PPUSH
138677: CALL 107634 0 1
// AddComEnterUnit ( un , i ) ;
138681: LD_VAR 0 10
138685: PPUSH
138686: LD_VAR 0 4
138690: PPUSH
138691: CALL_OW 180
// SetTag ( un , 19 ) ;
138695: LD_VAR 0 10
138699: PPUSH
138700: LD_INT 19
138702: PPUSH
138703: CALL_OW 109
// mechs := mechs diff un ;
138707: LD_ADDR_VAR 0 12
138711: PUSH
138712: LD_VAR 0 12
138716: PUSH
138717: LD_VAR 0 10
138721: DIFF
138722: ST_TO_ADDR
// end ; end ;
138723: GO 138601
138725: POP
138726: POP
// if solds then
138727: LD_VAR 0 8
138731: IFFALSE 138790
// for i in solds do
138733: LD_ADDR_VAR 0 4
138737: PUSH
138738: LD_VAR 0 8
138742: PUSH
138743: FOR_IN
138744: IFFALSE 138788
// if not GetTag ( i ) then
138746: LD_VAR 0 4
138750: PPUSH
138751: CALL_OW 110
138755: NOT
138756: IFFALSE 138786
// begin defenders := defenders union i ;
138758: LD_ADDR_VAR 0 2
138762: PUSH
138763: LD_VAR 0 2
138767: PUSH
138768: LD_VAR 0 4
138772: UNION
138773: ST_TO_ADDR
// SetTag ( i , 18 ) ;
138774: LD_VAR 0 4
138778: PPUSH
138779: LD_INT 18
138781: PPUSH
138782: CALL_OW 109
// end ;
138786: GO 138743
138788: POP
138789: POP
// repeat wait ( 0 0$2 ) ;
138790: LD_INT 70
138792: PPUSH
138793: CALL_OW 67
// enemy := mc_scan [ base ] ;
138797: LD_ADDR_VAR 0 21
138801: PUSH
138802: LD_EXP 125
138806: PUSH
138807: LD_VAR 0 1
138811: ARRAY
138812: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
138813: LD_EXP 102
138817: PUSH
138818: LD_VAR 0 1
138822: ARRAY
138823: NOT
138824: PUSH
138825: LD_EXP 102
138829: PUSH
138830: LD_VAR 0 1
138834: ARRAY
138835: PUSH
138836: EMPTY
138837: EQUAL
138838: OR
138839: IFFALSE 138876
// begin for i in defenders do
138841: LD_ADDR_VAR 0 4
138845: PUSH
138846: LD_VAR 0 2
138850: PUSH
138851: FOR_IN
138852: IFFALSE 138865
// ComStop ( i ) ;
138854: LD_VAR 0 4
138858: PPUSH
138859: CALL_OW 141
138863: GO 138851
138865: POP
138866: POP
// defenders := [ ] ;
138867: LD_ADDR_VAR 0 2
138871: PUSH
138872: EMPTY
138873: ST_TO_ADDR
// exit ;
138874: GO 140325
// end ; for i in defenders do
138876: LD_ADDR_VAR 0 4
138880: PUSH
138881: LD_VAR 0 2
138885: PUSH
138886: FOR_IN
138887: IFFALSE 139785
// begin e := NearestUnitToUnit ( enemy , i ) ;
138889: LD_ADDR_VAR 0 13
138893: PUSH
138894: LD_VAR 0 21
138898: PPUSH
138899: LD_VAR 0 4
138903: PPUSH
138904: CALL_OW 74
138908: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
138909: LD_ADDR_VAR 0 7
138913: PUSH
138914: LD_EXP 102
138918: PUSH
138919: LD_VAR 0 1
138923: ARRAY
138924: PPUSH
138925: LD_INT 2
138927: PUSH
138928: LD_INT 30
138930: PUSH
138931: LD_INT 0
138933: PUSH
138934: EMPTY
138935: LIST
138936: LIST
138937: PUSH
138938: LD_INT 30
138940: PUSH
138941: LD_INT 1
138943: PUSH
138944: EMPTY
138945: LIST
138946: LIST
138947: PUSH
138948: EMPTY
138949: LIST
138950: LIST
138951: LIST
138952: PPUSH
138953: CALL_OW 72
138957: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
138958: LD_ADDR_VAR 0 16
138962: PUSH
138963: LD_VAR 0 7
138967: NOT
138968: PUSH
138969: LD_VAR 0 7
138973: PPUSH
138974: LD_INT 3
138976: PUSH
138977: LD_INT 24
138979: PUSH
138980: LD_INT 600
138982: PUSH
138983: EMPTY
138984: LIST
138985: LIST
138986: PUSH
138987: EMPTY
138988: LIST
138989: LIST
138990: PPUSH
138991: CALL_OW 72
138995: OR
138996: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
138997: LD_VAR 0 4
139001: PPUSH
139002: CALL_OW 247
139006: PUSH
139007: LD_INT 2
139009: DOUBLE
139010: EQUAL
139011: IFTRUE 139015
139013: GO 139411
139015: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
139016: LD_VAR 0 4
139020: PPUSH
139021: CALL_OW 256
139025: PUSH
139026: LD_INT 1000
139028: EQUAL
139029: PUSH
139030: LD_VAR 0 4
139034: PPUSH
139035: LD_VAR 0 13
139039: PPUSH
139040: CALL_OW 296
139044: PUSH
139045: LD_INT 40
139047: LESS
139048: PUSH
139049: LD_VAR 0 13
139053: PPUSH
139054: LD_EXP 127
139058: PUSH
139059: LD_VAR 0 1
139063: ARRAY
139064: PPUSH
139065: CALL_OW 308
139069: OR
139070: AND
139071: IFFALSE 139193
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
139073: LD_VAR 0 4
139077: PPUSH
139078: CALL_OW 262
139082: PUSH
139083: LD_INT 1
139085: EQUAL
139086: PUSH
139087: LD_VAR 0 4
139091: PPUSH
139092: CALL_OW 261
139096: PUSH
139097: LD_INT 30
139099: LESS
139100: AND
139101: PUSH
139102: LD_VAR 0 7
139106: AND
139107: IFFALSE 139177
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
139109: LD_VAR 0 4
139113: PPUSH
139114: LD_VAR 0 7
139118: PPUSH
139119: LD_VAR 0 4
139123: PPUSH
139124: CALL_OW 74
139128: PPUSH
139129: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
139133: LD_VAR 0 4
139137: PPUSH
139138: LD_VAR 0 7
139142: PPUSH
139143: LD_VAR 0 4
139147: PPUSH
139148: CALL_OW 74
139152: PPUSH
139153: CALL_OW 296
139157: PUSH
139158: LD_INT 6
139160: LESS
139161: IFFALSE 139175
// SetFuel ( i , 100 ) ;
139163: LD_VAR 0 4
139167: PPUSH
139168: LD_INT 100
139170: PPUSH
139171: CALL_OW 240
// end else
139175: GO 139191
// ComAttackUnit ( i , e ) ;
139177: LD_VAR 0 4
139181: PPUSH
139182: LD_VAR 0 13
139186: PPUSH
139187: CALL_OW 115
// end else
139191: GO 139294
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
139193: LD_VAR 0 13
139197: PPUSH
139198: LD_EXP 127
139202: PUSH
139203: LD_VAR 0 1
139207: ARRAY
139208: PPUSH
139209: CALL_OW 308
139213: NOT
139214: PUSH
139215: LD_VAR 0 4
139219: PPUSH
139220: LD_VAR 0 13
139224: PPUSH
139225: CALL_OW 296
139229: PUSH
139230: LD_INT 40
139232: GREATEREQUAL
139233: AND
139234: PUSH
139235: LD_VAR 0 4
139239: PPUSH
139240: CALL_OW 256
139244: PUSH
139245: LD_INT 650
139247: LESSEQUAL
139248: OR
139249: PUSH
139250: LD_VAR 0 4
139254: PPUSH
139255: LD_EXP 126
139259: PUSH
139260: LD_VAR 0 1
139264: ARRAY
139265: PPUSH
139266: CALL_OW 308
139270: NOT
139271: AND
139272: IFFALSE 139294
// ComMoveToArea ( i , mc_parking [ base ] ) ;
139274: LD_VAR 0 4
139278: PPUSH
139279: LD_EXP 126
139283: PUSH
139284: LD_VAR 0 1
139288: ARRAY
139289: PPUSH
139290: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
139294: LD_VAR 0 4
139298: PPUSH
139299: CALL_OW 256
139303: PUSH
139304: LD_INT 1000
139306: LESS
139307: PUSH
139308: LD_VAR 0 4
139312: PPUSH
139313: CALL_OW 263
139317: PUSH
139318: LD_INT 1
139320: EQUAL
139321: AND
139322: PUSH
139323: LD_VAR 0 4
139327: PPUSH
139328: CALL_OW 311
139332: AND
139333: PUSH
139334: LD_VAR 0 4
139338: PPUSH
139339: LD_EXP 126
139343: PUSH
139344: LD_VAR 0 1
139348: ARRAY
139349: PPUSH
139350: CALL_OW 308
139354: AND
139355: IFFALSE 139409
// begin mech := IsDrivenBy ( i ) ;
139357: LD_ADDR_VAR 0 9
139361: PUSH
139362: LD_VAR 0 4
139366: PPUSH
139367: CALL_OW 311
139371: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
139372: LD_VAR 0 9
139376: PPUSH
139377: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
139381: LD_VAR 0 9
139385: PPUSH
139386: LD_VAR 0 4
139390: PPUSH
139391: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
139395: LD_VAR 0 9
139399: PPUSH
139400: LD_VAR 0 4
139404: PPUSH
139405: CALL_OW 180
// end ; end ; unit_human :
139409: GO 139756
139411: LD_INT 1
139413: DOUBLE
139414: EQUAL
139415: IFTRUE 139419
139417: GO 139755
139419: POP
// begin b := IsInUnit ( i ) ;
139420: LD_ADDR_VAR 0 18
139424: PUSH
139425: LD_VAR 0 4
139429: PPUSH
139430: CALL_OW 310
139434: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
139435: LD_ADDR_VAR 0 19
139439: PUSH
139440: LD_VAR 0 18
139444: NOT
139445: PUSH
139446: LD_VAR 0 18
139450: PPUSH
139451: CALL_OW 266
139455: PUSH
139456: LD_INT 32
139458: PUSH
139459: LD_INT 31
139461: PUSH
139462: EMPTY
139463: LIST
139464: LIST
139465: IN
139466: OR
139467: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
139468: LD_VAR 0 18
139472: PPUSH
139473: CALL_OW 266
139477: PUSH
139478: LD_INT 5
139480: EQUAL
139481: PUSH
139482: LD_VAR 0 4
139486: PPUSH
139487: CALL_OW 257
139491: PUSH
139492: LD_INT 1
139494: PUSH
139495: LD_INT 2
139497: PUSH
139498: LD_INT 3
139500: PUSH
139501: LD_INT 4
139503: PUSH
139504: EMPTY
139505: LIST
139506: LIST
139507: LIST
139508: LIST
139509: IN
139510: AND
139511: IFFALSE 139548
// begin class := AllowSpecClass ( i ) ;
139513: LD_ADDR_VAR 0 20
139517: PUSH
139518: LD_VAR 0 4
139522: PPUSH
139523: CALL 71331 0 1
139527: ST_TO_ADDR
// if class then
139528: LD_VAR 0 20
139532: IFFALSE 139548
// ComChangeProfession ( i , class ) ;
139534: LD_VAR 0 4
139538: PPUSH
139539: LD_VAR 0 20
139543: PPUSH
139544: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
139548: LD_VAR 0 16
139552: PUSH
139553: LD_VAR 0 2
139557: PPUSH
139558: LD_INT 21
139560: PUSH
139561: LD_INT 2
139563: PUSH
139564: EMPTY
139565: LIST
139566: LIST
139567: PPUSH
139568: CALL_OW 72
139572: PUSH
139573: LD_INT 1
139575: LESSEQUAL
139576: OR
139577: PUSH
139578: LD_VAR 0 19
139582: AND
139583: PUSH
139584: LD_VAR 0 4
139588: PUSH
139589: LD_VAR 0 17
139593: IN
139594: NOT
139595: AND
139596: IFFALSE 139689
// begin if b then
139598: LD_VAR 0 18
139602: IFFALSE 139651
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
139604: LD_VAR 0 18
139608: PPUSH
139609: LD_VAR 0 21
139613: PPUSH
139614: LD_VAR 0 18
139618: PPUSH
139619: CALL_OW 74
139623: PPUSH
139624: CALL_OW 296
139628: PUSH
139629: LD_INT 10
139631: LESS
139632: PUSH
139633: LD_VAR 0 18
139637: PPUSH
139638: CALL_OW 461
139642: PUSH
139643: LD_INT 7
139645: NONEQUAL
139646: AND
139647: IFFALSE 139651
// continue ;
139649: GO 138886
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
139651: LD_ADDR_VAR 0 17
139655: PUSH
139656: LD_VAR 0 17
139660: PPUSH
139661: LD_VAR 0 17
139665: PUSH
139666: LD_INT 1
139668: PLUS
139669: PPUSH
139670: LD_VAR 0 4
139674: PPUSH
139675: CALL_OW 1
139679: ST_TO_ADDR
// ComExitBuilding ( i ) ;
139680: LD_VAR 0 4
139684: PPUSH
139685: CALL_OW 122
// end ; if sold_defenders then
139689: LD_VAR 0 17
139693: IFFALSE 139753
// if i in sold_defenders then
139695: LD_VAR 0 4
139699: PUSH
139700: LD_VAR 0 17
139704: IN
139705: IFFALSE 139753
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
139707: LD_VAR 0 4
139711: PPUSH
139712: CALL_OW 314
139716: NOT
139717: PUSH
139718: LD_VAR 0 4
139722: PPUSH
139723: LD_VAR 0 13
139727: PPUSH
139728: CALL_OW 296
139732: PUSH
139733: LD_INT 30
139735: LESS
139736: AND
139737: IFFALSE 139753
// ComAttackUnit ( i , e ) ;
139739: LD_VAR 0 4
139743: PPUSH
139744: LD_VAR 0 13
139748: PPUSH
139749: CALL_OW 115
// end ; end ; end ;
139753: GO 139756
139755: POP
// if IsDead ( i ) then
139756: LD_VAR 0 4
139760: PPUSH
139761: CALL_OW 301
139765: IFFALSE 139783
// defenders := defenders diff i ;
139767: LD_ADDR_VAR 0 2
139771: PUSH
139772: LD_VAR 0 2
139776: PUSH
139777: LD_VAR 0 4
139781: DIFF
139782: ST_TO_ADDR
// end ;
139783: GO 138886
139785: POP
139786: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
139787: LD_VAR 0 21
139791: NOT
139792: PUSH
139793: LD_VAR 0 2
139797: NOT
139798: OR
139799: PUSH
139800: LD_EXP 102
139804: PUSH
139805: LD_VAR 0 1
139809: ARRAY
139810: NOT
139811: OR
139812: IFFALSE 138790
// MC_Reset ( base , 18 ) ;
139814: LD_VAR 0 1
139818: PPUSH
139819: LD_INT 18
139821: PPUSH
139822: CALL 43006 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
139826: LD_ADDR_VAR 0 2
139830: PUSH
139831: LD_VAR 0 2
139835: PUSH
139836: LD_VAR 0 2
139840: PPUSH
139841: LD_INT 2
139843: PUSH
139844: LD_INT 25
139846: PUSH
139847: LD_INT 1
139849: PUSH
139850: EMPTY
139851: LIST
139852: LIST
139853: PUSH
139854: LD_INT 25
139856: PUSH
139857: LD_INT 5
139859: PUSH
139860: EMPTY
139861: LIST
139862: LIST
139863: PUSH
139864: LD_INT 25
139866: PUSH
139867: LD_INT 8
139869: PUSH
139870: EMPTY
139871: LIST
139872: LIST
139873: PUSH
139874: LD_INT 25
139876: PUSH
139877: LD_INT 9
139879: PUSH
139880: EMPTY
139881: LIST
139882: LIST
139883: PUSH
139884: EMPTY
139885: LIST
139886: LIST
139887: LIST
139888: LIST
139889: LIST
139890: PPUSH
139891: CALL_OW 72
139895: DIFF
139896: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
139897: LD_VAR 0 21
139901: NOT
139902: PUSH
139903: LD_VAR 0 2
139907: PPUSH
139908: LD_INT 21
139910: PUSH
139911: LD_INT 2
139913: PUSH
139914: EMPTY
139915: LIST
139916: LIST
139917: PPUSH
139918: CALL_OW 72
139922: AND
139923: IFFALSE 140261
// begin tmp := FilterByTag ( defenders , 19 ) ;
139925: LD_ADDR_VAR 0 11
139929: PUSH
139930: LD_VAR 0 2
139934: PPUSH
139935: LD_INT 19
139937: PPUSH
139938: CALL 104805 0 2
139942: ST_TO_ADDR
// if tmp then
139943: LD_VAR 0 11
139947: IFFALSE 140017
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
139949: LD_ADDR_VAR 0 11
139953: PUSH
139954: LD_VAR 0 11
139958: PPUSH
139959: LD_INT 25
139961: PUSH
139962: LD_INT 3
139964: PUSH
139965: EMPTY
139966: LIST
139967: LIST
139968: PPUSH
139969: CALL_OW 72
139973: ST_TO_ADDR
// if tmp then
139974: LD_VAR 0 11
139978: IFFALSE 140017
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
139980: LD_ADDR_EXP 114
139984: PUSH
139985: LD_EXP 114
139989: PPUSH
139990: LD_VAR 0 1
139994: PPUSH
139995: LD_EXP 114
139999: PUSH
140000: LD_VAR 0 1
140004: ARRAY
140005: PUSH
140006: LD_VAR 0 11
140010: UNION
140011: PPUSH
140012: CALL_OW 1
140016: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
140017: LD_VAR 0 1
140021: PPUSH
140022: LD_INT 19
140024: PPUSH
140025: CALL 43006 0 2
// repeat wait ( 0 0$1 ) ;
140029: LD_INT 35
140031: PPUSH
140032: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140036: LD_EXP 102
140040: PUSH
140041: LD_VAR 0 1
140045: ARRAY
140046: NOT
140047: PUSH
140048: LD_EXP 102
140052: PUSH
140053: LD_VAR 0 1
140057: ARRAY
140058: PUSH
140059: EMPTY
140060: EQUAL
140061: OR
140062: IFFALSE 140099
// begin for i in defenders do
140064: LD_ADDR_VAR 0 4
140068: PUSH
140069: LD_VAR 0 2
140073: PUSH
140074: FOR_IN
140075: IFFALSE 140088
// ComStop ( i ) ;
140077: LD_VAR 0 4
140081: PPUSH
140082: CALL_OW 141
140086: GO 140074
140088: POP
140089: POP
// defenders := [ ] ;
140090: LD_ADDR_VAR 0 2
140094: PUSH
140095: EMPTY
140096: ST_TO_ADDR
// exit ;
140097: GO 140325
// end ; for i in defenders do
140099: LD_ADDR_VAR 0 4
140103: PUSH
140104: LD_VAR 0 2
140108: PUSH
140109: FOR_IN
140110: IFFALSE 140199
// begin if not IsInArea ( i , mc_parking [ base ] ) then
140112: LD_VAR 0 4
140116: PPUSH
140117: LD_EXP 126
140121: PUSH
140122: LD_VAR 0 1
140126: ARRAY
140127: PPUSH
140128: CALL_OW 308
140132: NOT
140133: IFFALSE 140157
// ComMoveToArea ( i , mc_parking [ base ] ) else
140135: LD_VAR 0 4
140139: PPUSH
140140: LD_EXP 126
140144: PUSH
140145: LD_VAR 0 1
140149: ARRAY
140150: PPUSH
140151: CALL_OW 113
140155: GO 140197
// if GetControl ( i ) = control_manual then
140157: LD_VAR 0 4
140161: PPUSH
140162: CALL_OW 263
140166: PUSH
140167: LD_INT 1
140169: EQUAL
140170: IFFALSE 140197
// if IsDrivenBy ( i ) then
140172: LD_VAR 0 4
140176: PPUSH
140177: CALL_OW 311
140181: IFFALSE 140197
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
140183: LD_VAR 0 4
140187: PPUSH
140188: CALL_OW 311
140192: PPUSH
140193: CALL_OW 121
// end ;
140197: GO 140109
140199: POP
140200: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
140201: LD_VAR 0 2
140205: PPUSH
140206: LD_INT 95
140208: PUSH
140209: LD_EXP 126
140213: PUSH
140214: LD_VAR 0 1
140218: ARRAY
140219: PUSH
140220: EMPTY
140221: LIST
140222: LIST
140223: PPUSH
140224: CALL_OW 72
140228: PUSH
140229: LD_VAR 0 2
140233: EQUAL
140234: PUSH
140235: LD_EXP 125
140239: PUSH
140240: LD_VAR 0 1
140244: ARRAY
140245: OR
140246: PUSH
140247: LD_EXP 102
140251: PUSH
140252: LD_VAR 0 1
140256: ARRAY
140257: NOT
140258: OR
140259: IFFALSE 140029
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
140261: LD_ADDR_EXP 124
140265: PUSH
140266: LD_EXP 124
140270: PPUSH
140271: LD_VAR 0 1
140275: PPUSH
140276: LD_VAR 0 2
140280: PPUSH
140281: LD_INT 21
140283: PUSH
140284: LD_INT 2
140286: PUSH
140287: EMPTY
140288: LIST
140289: LIST
140290: PPUSH
140291: CALL_OW 72
140295: PPUSH
140296: CALL_OW 1
140300: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
140301: LD_VAR 0 1
140305: PPUSH
140306: LD_INT 19
140308: PPUSH
140309: CALL 43006 0 2
// MC_Reset ( base , 20 ) ;
140313: LD_VAR 0 1
140317: PPUSH
140318: LD_INT 20
140320: PPUSH
140321: CALL 43006 0 2
// end ; end_of_file
140325: LD_VAR 0 3
140329: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
140330: LD_VAR 0 1
140334: PUSH
140335: LD_INT 200
140337: DOUBLE
140338: GREATEREQUAL
140339: IFFALSE 140347
140341: LD_INT 299
140343: DOUBLE
140344: LESSEQUAL
140345: IFTRUE 140349
140347: GO 140381
140349: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
140350: LD_VAR 0 1
140354: PPUSH
140355: LD_VAR 0 2
140359: PPUSH
140360: LD_VAR 0 3
140364: PPUSH
140365: LD_VAR 0 4
140369: PPUSH
140370: LD_VAR 0 5
140374: PPUSH
140375: CALL 128511 0 5
140379: GO 140458
140381: LD_INT 300
140383: DOUBLE
140384: GREATEREQUAL
140385: IFFALSE 140393
140387: LD_INT 399
140389: DOUBLE
140390: LESSEQUAL
140391: IFTRUE 140395
140393: GO 140457
140395: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
140396: LD_VAR 0 1
140400: PPUSH
140401: LD_VAR 0 2
140405: PPUSH
140406: LD_VAR 0 3
140410: PPUSH
140411: LD_VAR 0 4
140415: PPUSH
140416: LD_VAR 0 5
140420: PPUSH
140421: LD_VAR 0 6
140425: PPUSH
140426: LD_VAR 0 7
140430: PPUSH
140431: LD_VAR 0 8
140435: PPUSH
140436: LD_VAR 0 9
140440: PPUSH
140441: LD_VAR 0 10
140445: PPUSH
140446: LD_VAR 0 11
140450: PPUSH
140451: CALL 124836 0 11
140455: GO 140458
140457: POP
// end ;
140458: PPOPN 11
140460: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
140461: LD_VAR 0 1
140465: PPUSH
140466: LD_VAR 0 2
140470: PPUSH
140471: LD_VAR 0 3
140475: PPUSH
140476: LD_VAR 0 4
140480: PPUSH
140481: LD_VAR 0 5
140485: PPUSH
140486: CALL 128247 0 5
// end ; end_of_file
140490: PPOPN 5
140492: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
140493: LD_VAR 0 1
140497: PPUSH
140498: LD_VAR 0 2
140502: PPUSH
140503: LD_VAR 0 3
140507: PPUSH
140508: LD_VAR 0 4
140512: PPUSH
140513: LD_VAR 0 5
140517: PPUSH
140518: LD_VAR 0 6
140522: PPUSH
140523: CALL 112488 0 6
// end ;
140527: PPOPN 6
140529: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
140530: LD_INT 0
140532: PPUSH
// begin if not units then
140533: LD_VAR 0 1
140537: NOT
140538: IFFALSE 140542
// exit ;
140540: GO 140542
// end ;
140542: PPOPN 7
140544: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
140545: CALL 112375 0 0
// end ;
140549: PPOPN 1
140551: END
